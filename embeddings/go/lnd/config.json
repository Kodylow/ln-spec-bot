{
  "filepath": "../implementations/go/lnd/config.go",
  "package": "lnd",
  "sections": [
    {
      "slug": "type Config struct {",
      "content": "type Config struct {\n\tShowVersion bool `short:\"V\" long:\"version\" description:\"Display version information and exit\"`\n\n\tLndDir       string `long:\"lnddir\" description:\"The base directory that contains lnd's data, logs, configuration file, etc.\"`\n\tConfigFile   string `short:\"C\" long:\"configfile\" description:\"Path to configuration file\"`\n\tDataDir      string `short:\"b\" long:\"datadir\" description:\"The directory to store lnd's data within\"`\n\tSyncFreelist bool   `long:\"sync-freelist\" description:\"Whether the databases used within lnd should sync their freelist to disk. This is disabled by default resulting in improved memory performance during operation, but with an increase in startup time.\"`\n\n\tTLSCertPath        string        `long:\"tlscertpath\" description:\"Path to write the TLS certificate for lnd's RPC and REST services\"`\n\tTLSKeyPath         string        `long:\"tlskeypath\" description:\"Path to write the TLS private key for lnd's RPC and REST services\"`\n\tTLSExtraIPs        []string      `long:\"tlsextraip\" description:\"Adds an extra ip to the generated certificate\"`\n\tTLSExtraDomains    []string      `long:\"tlsextradomain\" description:\"Adds an extra domain to the generated certificate\"`\n\tTLSAutoRefresh     bool          `long:\"tlsautorefresh\" description:\"Re-generate TLS certificate and key if the IPs or domains are changed\"`\n\tTLSDisableAutofill bool          `long:\"tlsdisableautofill\" description:\"Do not include the interface IPs or the system hostname in TLS certificate, use first --tlsextradomain as Common Name instead, if set\"`\n\tTLSCertDuration    time.Duration `long:\"tlscertduration\" description:\"The duration for which the auto-generated TLS certificate will be valid for\"`\n\tTLSEncryptKey      bool          `long:\"tlsencryptkey\" description:\"Automatically encrypts the TLS private key and generates ephemeral TLS key pairs when the wallet is locked or not initialized\"`\n\n\tNoMacaroons     bool          `long:\"no-macaroons\" description:\"Disable macaroon authentication, can only be used if server is not listening on a public interface.\"`\n\tAdminMacPath    string        `long:\"adminmacaroonpath\" description:\"Path to write the admin macaroon for lnd's RPC and REST services if it doesn't exist\"`\n\tReadMacPath     string        `long:\"readonlymacaroonpath\" description:\"Path to write the read-only macaroon for lnd's RPC and REST services if it doesn't exist\"`\n\tInvoiceMacPath  string        `long:\"invoicemacaroonpath\" description:\"Path to the invoice-only macaroon for lnd's RPC and REST services if it doesn't exist\"`\n\tLogDir          string        `long:\"logdir\" description:\"Directory to log output.\"`\n\tMaxLogFiles     int           `long:\"maxlogfiles\" description:\"Maximum logfiles to keep (0 for no rotation)\"`\n\tMaxLogFileSize  int           `long:\"maxlogfilesize\" description:\"Maximum logfile size in MB\"`\n\tAcceptorTimeout time.Duration `long:\"acceptortimeout\" description:\"Time after which an RPCAcceptor will time out and return false if it hasn't yet received a response\"`\n\n\tLetsEncryptDir    string `long:\"letsencryptdir\" description:\"The directory to store Let's Encrypt certificates within\"`\n\tLetsEncryptListen string `long:\"letsencryptlisten\" description:\"The IP:port on which lnd will listen for Let's Encrypt challenges. Let's Encrypt will always try to contact on port 80. Often non-root processes are not allowed to bind to ports lower than 1024. This configuration option allows a different port to be used, but must be used in combination with port forwarding from port 80. This configuration can also be used to specify another IP address to listen on, for example an IPv6 address.\"`\n\tLetsEncryptDomain string `long:\"letsencryptdomain\" description:\"Request a Let's Encrypt certificate for this domain. Note that the certificate is only requested and stored when the first rpc connection comes in.\"`\n\n\t// We'll parse these 'raw' string arguments into real net.Addrs in the\n\t// loadConfig function. We need to expose the 'raw' strings so the\n\t// command line library can access them.\n\t// Only the parsed net.Addrs should be used!\n\tRawRPCListeners   []string `long:\"rpclisten\" description:\"Add an interface/port/socket to listen for RPC connections\"`\n\tRawRESTListeners  []string `long:\"restlisten\" description:\"Add an interface/port/socket to listen for REST connections\"`\n\tRawListeners      []string `long:\"listen\" description:\"Add an interface/port to listen for peer connections\"`\n\tRawExternalIPs    []string `long:\"externalip\" description:\"Add an ip:port to the list of local addresses we claim to listen on to peers. If a port is not specified, the default (9735) will be used regardless of other parameters\"`\n\tExternalHosts     []string `long:\"externalhosts\" description:\"Add a hostname:port that should be periodically resolved to announce IPs for. If a port is not specified, the default (9735) will be used.\"`\n\tRPCListeners      []net.Addr\n\tRESTListeners     []net.Addr\n\tRestCORS          []string `long:\"restcors\" description:\"Add an ip:port/hostname to allow cross origin access from. To allow all origins, set as \\\"*\\\".\"`\n\tListeners         []net.Addr\n\tExternalIPs       []net.Addr\n\tDisableListen     bool          `long:\"nolisten\" description:\"Disable listening for incoming peer connections\"`\n\tDisableRest       bool          `long:\"norest\" description:\"Disable REST API\"`\n\tDisableRestTLS    bool          `long:\"no-rest-tls\" description:\"Disable TLS for REST connections\"`\n\tWSPingInterval    time.Duration `long:\"ws-ping-interval\" description:\"The ping interval for REST based WebSocket connections, set to 0 to disable sending ping messages from the server side\"`\n\tWSPongWait        time.Duration `long:\"ws-pong-wait\" description:\"The time we wait for a pong response message on REST based WebSocket connections before the connection is closed as inactive\"`\n\tNAT               bool          `long:\"nat\" description:\"Toggle NAT traversal support (using either UPnP or NAT-PMP) to automatically advertise your external IP address to the network -- NOTE this does not support devices behind multiple NATs\"`\n\tAddPeers          []string      `long:\"addpeer\" description:\"Specify peers to connect to first\"`\n\tMinBackoff        time.Duration `long:\"minbackoff\" description:\"Shortest backoff when reconnecting to persistent peers. Valid time units are {s, m, h}.\"`\n\tMaxBackoff        time.Duration `long:\"maxbackoff\" description:\"Longest backoff when reconnecting to persistent peers. Valid time units are {s, m, h}.\"`\n\tConnectionTimeout time.Duration `long:\"connectiontimeout\" description:\"The timeout value for network connections. Valid time units are {ms, s, m, h}.\"`\n\n\tDebugLevel string `short:\"d\" long:\"debuglevel\" description:\"Logging level for all subsystems {trace, debug, info, warn, error, critical} -- You may also specify <global-level>,<subsystem>=<level>,<subsystem2>=<level>,... to set the log level for individual subsystems -- Use show to list available subsystems\"`\n\n\tCPUProfile string `long:\"cpuprofile\" description:\"Write CPU profile to the specified file\"`\n\n\tProfile string `long:\"profile\" description:\"Enable HTTP profiling on either a port or host:port\"`\n\n\tUnsafeDisconnect   bool   `long:\"unsafe-disconnect\" description:\"DEPRECATED: Allows the rpcserver to intentionally disconnect from peers with open channels. THIS FLAG WILL BE REMOVED IN 0.10.0\"`\n\tUnsafeReplay       bool   `long:\"unsafe-replay\" description:\"Causes a link to replay the adds on its commitment txn after starting up, this enables testing of the sphinx replay logic.\"`\n\tMaxPendingChannels int    `long:\"maxpendingchannels\" description:\"The maximum number of incoming pending channels permitted per peer.\"`\n\tBackupFilePath     string `long:\"backupfilepath\" description:\"The target location of the channel backup file\"`\n\n\tFeeURL string `long:\"feeurl\" description:\"Optional URL for external fee estimation. If no URL is specified, the method for fee estimation will depend on the chosen backend and network. Must be set for neutrino on mainnet.\"`\n\n\tBitcoin      *lncfg.Chain    `group:\"Bitcoin\" namespace:\"bitcoin\"`\n\tBtcdMode     *lncfg.Btcd     `group:\"btcd\" namespace:\"btcd\"`\n\tBitcoindMode *lncfg.Bitcoind `group:\"bitcoind\" namespace:\"bitcoind\"`\n\tNeutrinoMode *lncfg.Neutrino `group:\"neutrino\" namespace:\"neutrino\"`\n\n\tLitecoin      *lncfg.Chain    `group:\"Litecoin\" namespace:\"litecoin\"`\n\tLtcdMode      *lncfg.Btcd     `group:\"ltcd\" namespace:\"ltcd\"`\n\tLitecoindMode *lncfg.Bitcoind `group:\"litecoind\" namespace:\"litecoind\"`\n\n\tBlockCacheSize uint64 `long:\"blockcachesize\" description:\"The maximum capacity of the block cache\"`\n\n\tAutopilot *lncfg.AutoPilot `group:\"Autopilot\" namespace:\"autopilot\"`\n\n\tTor *lncfg.Tor `group:\"Tor\" namespace:\"tor\"`\n\n\tSubRPCServers *subRPCServerConfigs `group:\"subrpc\"`\n\n\tHodl *hodl.Config `group:\"hodl\" namespace:\"hodl\"`\n\n\tNoNetBootstrap bool `long:\"nobootstrap\" description:\"If true, then automatic network bootstrapping will not be attempted.\"`\n\n\tNoSeedBackup             bool   `long:\"noseedbackup\" description:\"If true, NO SEED WILL BE EXPOSED -- EVER, AND THE WALLET WILL BE ENCRYPTED USING THE DEFAULT PASSPHRASE. THIS FLAG IS ONLY FOR TESTING AND SHOULD NEVER BE USED ON MAINNET.\"`\n\tWalletUnlockPasswordFile string `long:\"wallet-unlock-password-file\" description:\"The full path to a file (or pipe/device) that contains the password for unlocking the wallet; if set, no unlocking through RPC is possible and lnd will exit if no wallet exists or the password is incorrect; if wallet-unlock-allow-create is also set then lnd will ignore this flag if no wallet exists and allow a wallet to be created through RPC.\"`\n\tWalletUnlockAllowCreate  bool   `long:\"wallet-unlock-allow-create\" description:\"Don't fail with an error if wallet-unlock-password-file is set but no wallet exists yet.\"`\n\n\tResetWalletTransactions bool `long:\"reset-wallet-transactions\" description:\"Removes all transaction history from the on-chain wallet on startup, forcing a full chain rescan starting at the wallet's birthday. Implements the same functionality as btcwallet's dropwtxmgr command. Should be set to false after successful execution to avoid rescanning on every restart of lnd.\"`\n\n\tCoinSelectionStrategy string `long:\"coin-selection-strategy\" description:\"The strategy to use for selecting coins for wallet transactions.\" choice:\"largest\" choice:\"random\"`\n\n\tPaymentsExpirationGracePeriod time.Duration `long:\"payments-expiration-grace-period\" description:\"A period to wait before force closing channels with outgoing htlcs that have timed-out and are a result of this node initiated payments.\"`\n\tTrickleDelay                  int           `long:\"trickledelay\" description:\"Time in milliseconds between each release of announcements to the network\"`\n\tChanEnableTimeout             time.Duration `long:\"chan-enable-timeout\" description:\"The duration that a peer connection must be stable before attempting to send a channel update to re-enable or cancel a pending disables of the peer's channels on the network.\"`\n\tChanDisableTimeout            time.Duration `long:\"chan-disable-timeout\" description:\"The duration that must elapse after first detecting that an already active channel is actually inactive and sending channel update disabling it to the network. The pending disable can be canceled if the peer reconnects and becomes stable for chan-enable-timeout before the disable update is sent.\"`\n\tChanStatusSampleInterval      time.Duration `long:\"chan-status-sample-interval\" description:\"The polling interval between attempts to detect if an active channel has become inactive due to its peer going offline.\"`\n\tHeightHintCacheQueryDisable   bool          `long:\"height-hint-cache-query-disable\" description:\"Disable queries from the height-hint cache to try to recover channels stuck in the pending close state. Disabling height hint queries may cause longer chain rescans, resulting in a performance hit. Unset this after channels are unstuck so you can get better performance again.\"`\n\tAlias                         string        `long:\"alias\" description:\"The node alias. Used as a moniker by peers and intelligence services\"`\n\tColor                         string        `long:\"color\" description:\"The color of the node in hex format (i.e. '#3399FF'). Used to customize node appearance in intelligence services\"`\n\tMinChanSize                   int64         `long:\"minchansize\" description:\"The smallest channel size (in satoshis) that we should accept. Incoming channels smaller than this will be rejected\"`\n\tMaxChanSize                   int64         `long:\"maxchansize\" description:\"The largest channel size (in satoshis) that we should accept. Incoming channels larger than this will be rejected\"`\n\tCoopCloseTargetConfs          uint32        `long:\"coop-close-target-confs\" description:\"The target number of blocks that a cooperative channel close transaction should confirm in. This is used to estimate the fee to use as the lower bound during fee negotiation for the channel closure.\"`\n\n\tChannelCommitInterval time.Duration `long:\"channel-commit-interval\" description:\"The maximum time that is allowed to pass between receiving a channel state update and signing the next commitment. Setting this to a longer duration allows for more efficient channel operations at the cost of latency.\"`\n\n\tPendingCommitInterval time.Duration `long:\"pending-commit-interval\" description:\"The maximum time that is allowed to pass while waiting for the remote party to revoke a locally initiated commitment state. Setting this to a longer duration if a slow response is expected from the remote party or large number of payments are attempted at the same time.\"`\n\n\tChannelCommitBatchSize uint32 `long:\"channel-commit-batch-size\" description:\"The maximum number of channel state updates that is accumulated before signing a new commitment.\"`\n\n\tKeepFailedPaymentAttempts bool `long:\"keep-failed-payment-attempts\" description:\"Keeps persistent record of all failed payment attempts for successfully settled payments.\"`\n\n\tStoreFinalHtlcResolutions bool `long:\"store-final-htlc-resolutions\" description:\"Persistently store the final resolution of incoming htlcs.\"`\n\n\tDefaultRemoteMaxHtlcs uint16 `long:\"default-remote-max-htlcs\" description:\"The default max_htlc applied when opening or accepting channels. This value limits the number of concurrent HTLCs that the remote party can add to the commitment. The maximum possible value is 483.\"`\n\n\tNumGraphSyncPeers      int           `long:\"numgraphsyncpeers\" description:\"The number of peers that we should receive new graph updates from. This option can be tuned to save bandwidth for light clients or routing nodes.\"`\n\tHistoricalSyncInterval time.Duration `long:\"historicalsyncinterval\" description:\"The polling interval between historical graph sync attempts. Each historical graph sync attempt ensures we reconcile with the remote peer's graph from the genesis block.\"`\n\n\tIgnoreHistoricalGossipFilters bool `long:\"ignore-historical-gossip-filters\" description:\"If true, will not reply with historical data that matches the range specified by a remote peer's gossip_timestamp_filter. Doing so will result in lower memory and bandwidth requirements.\"`\n\n\tRejectPush bool `long:\"rejectpush\" description:\"If true, lnd will not accept channel opening requests with non-zero push amounts. This should prevent accidental pushes to merchant nodes.\"`\n\n\tRejectHTLC bool `long:\"rejecthtlc\" description:\"If true, lnd will not forward any HTLCs that are meant as onward payments. This option will still allow lnd to send HTLCs and receive HTLCs but lnd won't be used as a hop.\"`\n\n\t// RequireInterceptor determines whether the HTLC interceptor is\n\t// registered regardless of whether the RPC is called or not.\n\tRequireInterceptor bool `long:\"requireinterceptor\" description:\"Whether to always intercept HTLCs, even if no stream is attached\"`\n\n\tStaggerInitialReconnect bool `long:\"stagger-initial-reconnect\" description:\"If true, will apply a randomized staggering between 0s and 30s when reconnecting to persistent peers on startup. The first 10 reconnections will be attempted instantly, regardless of the flag's value\"`\n\n\tMaxOutgoingCltvExpiry uint32 `long:\"max-cltv-expiry\" description:\"The maximum number of blocks funds could be locked up for when forwarding payments.\"`\n\n\tMaxChannelFeeAllocation float64 `long:\"max-channel-fee-allocation\" description:\"The maximum percentage of total funds that can be allocated to a channel's commitment fee. This only applies for the initiator of the channel. Valid values are within [0.1, 1].\"`\n\n\tMaxCommitFeeRateAnchors uint64 `long:\"max-commit-fee-rate-anchors\" description:\"The maximum fee rate in sat/vbyte that will be used for commitments of channels of the anchors type. Must be large enough to ensure transaction propagation\"`\n\n\tDryRunMigration bool `long:\"dry-run-migration\" description:\"If true, lnd will abort committing a migration if it would otherwise have been successful. This leaves the database unmodified, and still compatible with the previously active version of lnd.\"`\n\n\tnet tor.Net\n\n\tEnableUpfrontShutdown bool `long:\"enable-upfront-shutdown\" description:\"If true, option upfront shutdown script will be enabled. If peers that we open channels with support this feature, we will automatically set the script to which cooperative closes should be paid out to on channel open. This offers the partial protection of a channel peer disconnecting from us if cooperative close is attempted with a different script.\"`\n\n\tAcceptKeySend bool `long:\"accept-keysend\" description:\"If true, spontaneous payments through keysend will be accepted. [experimental]\"`\n\n\tAcceptAMP bool `long:\"accept-amp\" description:\"If true, spontaneous payments via AMP will be accepted.\"`\n\n\tKeysendHoldTime time.Duration `long:\"keysend-hold-time\" description:\"If non-zero, keysend payments are accepted but not immediately settled. If the payment isn't settled manually after the specified time, it is canceled automatically. [experimental]\"`\n\n\tGcCanceledInvoicesOnStartup bool `long:\"gc-canceled-invoices-on-startup\" description:\"If true, we'll attempt to garbage collect canceled invoices upon start.\"`\n\n\tGcCanceledInvoicesOnTheFly bool `long:\"gc-canceled-invoices-on-the-fly\" description:\"If true, we'll delete newly canceled invoices on the fly.\"`\n\n\tDustThreshold uint64 `long:\"dust-threshold\" description:\"Sets the dust sum threshold in satoshis for a channel after which dust HTLC's will be failed.\"`\n\n\tInvoices *lncfg.Invoices `group:\"invoices\" namespace:\"invoices\"`\n\n\tRouting *lncfg.Routing `group:\"routing\" namespace:\"routing\"`\n\n\tGossip *lncfg.Gossip `group:\"gossip\" namespace:\"gossip\"`\n\n\tWorkers *lncfg.Workers `group:\"workers\" namespace:\"workers\"`\n\n\tCaches *lncfg.Caches `group:\"caches\" namespace:\"caches\"`\n\n\tPrometheus lncfg.Prometheus `group:\"prometheus\" namespace:\"prometheus\"`\n\n\tWtClient *lncfg.WtClient `group:\"wtclient\" namespace:\"wtclient\"`\n\n\tWatchtower *lncfg.Watchtower `group:\"watchtower\" namespace:\"watchtower\"`\n\n\tProtocolOptions *lncfg.ProtocolOptions `group:\"protocol\" namespace:\"protocol\"`\n\n\tAllowCircularRoute bool `long:\"allow-circular-route\" description:\"If true, our node will allow htlc forwards that arrive and depart on the same channel.\"`\n\n\tHealthChecks *lncfg.HealthCheckConfig `group:\"healthcheck\" namespace:\"healthcheck\"`\n\n\tDB *lncfg.DB `group:\"db\" namespace:\"db\"`\n\n\tCluster *lncfg.Cluster `group:\"cluster\" namespace:\"cluster\"`\n\n\tRPCMiddleware *lncfg.RPCMiddleware `group:\"rpcmiddleware\" namespace:\"rpcmiddleware\"`\n\n\tRemoteSigner *lncfg.RemoteSigner `group:\"remotesigner\" namespace:\"remotesigner\"`\n\n\tSweeper *lncfg.Sweeper `group:\"sweeper\" namespace:\"sweeper\"`\n\n\tHtlcswitch *lncfg.Htlcswitch `group:\"htlcswitch\" namespace:\"htlcswitch\"`\n\n\t// LogWriter is the root logger that all of the daemon's subloggers are\n\t// hooked up to.\n\tLogWriter *build.RotatingLogWriter\n\n\t// registeredChains keeps track of all chains that have been registered\n\t// with the daemon.\n\tregisteredChains *chainreg.ChainRegistry\n\n\t// networkDir is the path to the directory of the currently active\n\t// network. This path will hold the files related to each different\n\t// network.\n\tnetworkDir string\n\n\t// ActiveNetParams contains parameters of the target chain.\n\tActiveNetParams chainreg.BitcoinNetParams\n\n\t// Estimator is used to estimate routing probabilities.\n\tEstimator routing.Estimator\n}\n\n// DefaultConfig returns all default values for the Config struct.\n//\n//nolint:lll",
      "length": 20176,
      "tokens": 2322,
      "embedding": []
    },
    {
      "slug": "func DefaultConfig() Config {",
      "content": "func DefaultConfig() Config {\n\treturn Config{\n\t\tLndDir:            DefaultLndDir,\n\t\tConfigFile:        DefaultConfigFile,\n\t\tDataDir:           defaultDataDir,\n\t\tDebugLevel:        defaultLogLevel,\n\t\tTLSCertPath:       defaultTLSCertPath,\n\t\tTLSKeyPath:        defaultTLSKeyPath,\n\t\tTLSCertDuration:   defaultTLSCertDuration,\n\t\tLetsEncryptDir:    defaultLetsEncryptDir,\n\t\tLetsEncryptListen: defaultLetsEncryptListen,\n\t\tLogDir:            defaultLogDir,\n\t\tMaxLogFiles:       defaultMaxLogFiles,\n\t\tMaxLogFileSize:    defaultMaxLogFileSize,\n\t\tAcceptorTimeout:   defaultAcceptorTimeout,\n\t\tWSPingInterval:    lnrpc.DefaultPingInterval,\n\t\tWSPongWait:        lnrpc.DefaultPongWait,\n\t\tBitcoin: &lncfg.Chain{\n\t\t\tMinHTLCIn:     chainreg.DefaultBitcoinMinHTLCInMSat,\n\t\t\tMinHTLCOut:    chainreg.DefaultBitcoinMinHTLCOutMSat,\n\t\t\tBaseFee:       chainreg.DefaultBitcoinBaseFeeMSat,\n\t\t\tFeeRate:       chainreg.DefaultBitcoinFeeRate,\n\t\t\tTimeLockDelta: chainreg.DefaultBitcoinTimeLockDelta,\n\t\t\tMaxLocalDelay: defaultMaxLocalCSVDelay,\n\t\t\tNode:          \"btcd\",\n\t\t},\n\t\tBtcdMode: &lncfg.Btcd{\n\t\t\tDir:     defaultBtcdDir,\n\t\t\tRPCHost: defaultRPCHost,\n\t\t\tRPCCert: defaultBtcdRPCCertFile,\n\t\t},\n\t\tBitcoindMode: &lncfg.Bitcoind{\n\t\t\tDir:                defaultBitcoindDir,\n\t\t\tRPCHost:            defaultRPCHost,\n\t\t\tEstimateMode:       defaultBitcoindEstimateMode,\n\t\t\tPrunedNodeMaxPeers: defaultPrunedNodeMaxPeers,\n\t\t\tZMQReadDeadline:    defaultZMQReadDeadline,\n\t\t},\n\t\tLitecoin: &lncfg.Chain{\n\t\t\tMinHTLCIn:     chainreg.DefaultLitecoinMinHTLCInMSat,\n\t\t\tMinHTLCOut:    chainreg.DefaultLitecoinMinHTLCOutMSat,\n\t\t\tBaseFee:       chainreg.DefaultLitecoinBaseFeeMSat,\n\t\t\tFeeRate:       chainreg.DefaultLitecoinFeeRate,\n\t\t\tTimeLockDelta: chainreg.DefaultLitecoinTimeLockDelta,\n\t\t\tMaxLocalDelay: defaultMaxLocalCSVDelay,\n\t\t\tNode:          \"ltcd\",\n\t\t},\n\t\tLtcdMode: &lncfg.Btcd{\n\t\t\tDir:     defaultLtcdDir,\n\t\t\tRPCHost: defaultRPCHost,\n\t\t\tRPCCert: defaultLtcdRPCCertFile,\n\t\t},\n\t\tLitecoindMode: &lncfg.Bitcoind{\n\t\t\tDir:                defaultLitecoindDir,\n\t\t\tRPCHost:            defaultRPCHost,\n\t\t\tEstimateMode:       defaultBitcoindEstimateMode,\n\t\t\tPrunedNodeMaxPeers: defaultPrunedNodeMaxPeers,\n\t\t},\n\t\tNeutrinoMode: &lncfg.Neutrino{\n\t\t\tUserAgentName:    neutrino.UserAgentName,\n\t\t\tUserAgentVersion: neutrino.UserAgentVersion,\n\t\t},\n\t\tBlockCacheSize:     defaultBlockCacheSize,\n\t\tUnsafeDisconnect:   true,\n\t\tMaxPendingChannels: lncfg.DefaultMaxPendingChannels,\n\t\tNoSeedBackup:       defaultNoSeedBackup,\n\t\tMinBackoff:         defaultMinBackoff,\n\t\tMaxBackoff:         defaultMaxBackoff,\n\t\tConnectionTimeout:  tor.DefaultConnTimeout,\n\t\tSubRPCServers: &subRPCServerConfigs{\n\t\t\tSignRPC:   &signrpc.Config{},\n\t\t\tRouterRPC: routerrpc.DefaultConfig(),\n\t\t\tPeersRPC:  &peersrpc.Config{},\n\t\t},\n\t\tAutopilot: &lncfg.AutoPilot{\n\t\t\tMaxChannels:    5,\n\t\t\tAllocation:     0.6,\n\t\t\tMinChannelSize: int64(funding.MinChanFundingSize),\n\t\t\tMaxChannelSize: int64(MaxFundingAmount),\n\t\t\tMinConfs:       1,\n\t\t\tConfTarget:     autopilot.DefaultConfTarget,\n\t\t\tHeuristic: map[string]float64{\n\t\t\t\t\"top_centrality\": 1.0,\n\t\t\t},\n\t\t},\n\t\tPaymentsExpirationGracePeriod: defaultPaymentsExpirationGracePeriod,\n\t\tTrickleDelay:                  defaultTrickleDelay,\n\t\tChanStatusSampleInterval:      defaultChanStatusSampleInterval,\n\t\tChanEnableTimeout:             defaultChanEnableTimeout,\n\t\tChanDisableTimeout:            defaultChanDisableTimeout,\n\t\tHeightHintCacheQueryDisable:   defaultHeightHintCacheQueryDisable,\n\t\tAlias:                         defaultAlias,\n\t\tColor:                         defaultColor,\n\t\tMinChanSize:                   int64(funding.MinChanFundingSize),\n\t\tMaxChanSize:                   int64(0),\n\t\tCoopCloseTargetConfs:          defaultCoopCloseTargetConfs,\n\t\tDefaultRemoteMaxHtlcs:         defaultRemoteMaxHtlcs,\n\t\tNumGraphSyncPeers:             defaultMinPeers,\n\t\tHistoricalSyncInterval:        discovery.DefaultHistoricalSyncInterval,\n\t\tTor: &lncfg.Tor{\n\t\t\tSOCKS:   defaultTorSOCKS,\n\t\t\tDNS:     defaultTorDNS,\n\t\t\tControl: defaultTorControl,\n\t\t},\n\t\tnet: &tor.ClearNet{},\n\t\tWorkers: &lncfg.Workers{\n\t\t\tRead:  lncfg.DefaultReadWorkers,\n\t\t\tWrite: lncfg.DefaultWriteWorkers,\n\t\t\tSig:   lncfg.DefaultSigWorkers,\n\t\t},\n\t\tCaches: &lncfg.Caches{\n\t\t\tRejectCacheSize:  channeldb.DefaultRejectCacheSize,\n\t\t\tChannelCacheSize: channeldb.DefaultChannelCacheSize,\n\t\t},\n\t\tPrometheus: lncfg.DefaultPrometheus(),\n\t\tWatchtower: &lncfg.Watchtower{\n\t\t\tTowerDir: defaultTowerDir,\n\t\t},\n\t\tHealthChecks: &lncfg.HealthCheckConfig{\n\t\t\tChainCheck: &lncfg.CheckConfig{\n\t\t\t\tInterval: defaultChainInterval,\n\t\t\t\tTimeout:  defaultChainTimeout,\n\t\t\t\tAttempts: defaultChainAttempts,\n\t\t\t\tBackoff:  defaultChainBackoff,\n\t\t\t},\n\t\t\tDiskCheck: &lncfg.DiskCheckConfig{\n\t\t\t\tRequiredRemaining: defaultRequiredDisk,\n\t\t\t\tCheckConfig: &lncfg.CheckConfig{\n\t\t\t\t\tInterval: defaultDiskInterval,\n\t\t\t\t\tAttempts: defaultDiskAttempts,\n\t\t\t\t\tTimeout:  defaultDiskTimeout,\n\t\t\t\t\tBackoff:  defaultDiskBackoff,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTLSCheck: &lncfg.CheckConfig{\n\t\t\t\tInterval: defaultTLSInterval,\n\t\t\t\tTimeout:  defaultTLSTimeout,\n\t\t\t\tAttempts: defaultTLSAttempts,\n\t\t\t\tBackoff:  defaultTLSBackoff,\n\t\t\t},\n\t\t\tTorConnection: &lncfg.CheckConfig{\n\t\t\t\tInterval: defaultTCInterval,\n\t\t\t\tTimeout:  defaultTCTimeout,\n\t\t\t\tAttempts: defaultTCAttempts,\n\t\t\t\tBackoff:  defaultTCBackoff,\n\t\t\t},\n\t\t\tRemoteSigner: &lncfg.CheckConfig{\n\t\t\t\tInterval: defaultRSInterval,\n\t\t\t\tTimeout:  defaultRSTimeout,\n\t\t\t\tAttempts: defaultRSAttempts,\n\t\t\t\tBackoff:  defaultRSBackoff,\n\t\t\t},\n\t\t},\n\t\tGossip: &lncfg.Gossip{\n\t\t\tMaxChannelUpdateBurst: discovery.DefaultMaxChannelUpdateBurst,\n\t\t\tChannelUpdateInterval: discovery.DefaultChannelUpdateInterval,\n\t\t\tSubBatchDelay:         discovery.DefaultSubBatchDelay,\n\t\t},\n\t\tInvoices: &lncfg.Invoices{\n\t\t\tHoldExpiryDelta: lncfg.DefaultHoldInvoiceExpiryDelta,\n\t\t},\n\t\tMaxOutgoingCltvExpiry:     htlcswitch.DefaultMaxOutgoingCltvExpiry,\n\t\tMaxChannelFeeAllocation:   htlcswitch.DefaultMaxLinkFeeAllocation,\n\t\tMaxCommitFeeRateAnchors:   lnwallet.DefaultAnchorsCommitMaxFeeRateSatPerVByte,\n\t\tDustThreshold:             uint64(htlcswitch.DefaultDustThreshold.ToSatoshis()),\n\t\tLogWriter:                 build.NewRotatingLogWriter(),\n\t\tDB:                        lncfg.DefaultDB(),\n\t\tCluster:                   lncfg.DefaultCluster(),\n\t\tRPCMiddleware:             lncfg.DefaultRPCMiddleware(),\n\t\tregisteredChains:          chainreg.NewChainRegistry(),\n\t\tActiveNetParams:           chainreg.BitcoinTestNetParams,\n\t\tChannelCommitInterval:     defaultChannelCommitInterval,\n\t\tPendingCommitInterval:     defaultPendingCommitInterval,\n\t\tChannelCommitBatchSize:    defaultChannelCommitBatchSize,\n\t\tCoinSelectionStrategy:     defaultCoinSelectionStrategy,\n\t\tKeepFailedPaymentAttempts: defaultKeepFailedPaymentAttempts,\n\t\tRemoteSigner: &lncfg.RemoteSigner{\n\t\t\tTimeout: lncfg.DefaultRemoteSignerRPCTimeout,\n\t\t},\n\t\tSweeper: &lncfg.Sweeper{\n\t\t\tBatchWindowDuration: sweep.DefaultBatchWindowDuration,\n\t\t},\n\t\tHtlcswitch: &lncfg.Htlcswitch{\n\t\t\tMailboxDeliveryTimeout: htlcswitch.DefaultMailboxDeliveryTimeout,\n\t\t},\n\t}\n}\n\n// LoadConfig initializes and parses the config using a config file and command\n// line options.\n//\n// The configuration proceeds as follows:\n//  1. Start with a default config with sane settings\n//  2. Pre-parse the command line to check for an alternative config file\n//  3. Load configuration file overwriting defaults with any specified options\n//  4. Parse CLI options and overwrite/add any specified options",
      "length": 7167,
      "tokens": 411,
      "embedding": []
    },
    {
      "slug": "func LoadConfig(interceptor signal.Interceptor) (*Config, error) {",
      "content": "func LoadConfig(interceptor signal.Interceptor) (*Config, error) {\n\t// Pre-parse the command line options to pick up an alternative config\n\t// file.\n\tpreCfg := DefaultConfig()\n\tif _, err := flags.Parse(&preCfg); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Show the version and exit if the version flag was specified.\n\tappName := filepath.Base(os.Args[0])\n\tappName = strings.TrimSuffix(appName, filepath.Ext(appName))\n\tusageMessage := fmt.Sprintf(\"Use %s -h to show usage\", appName)\n\tif preCfg.ShowVersion {\n\t\tfmt.Println(appName, \"version\", build.Version(),\n\t\t\t\"commit=\"+build.Commit)\n\t\tos.Exit(0)\n\t}\n\n\t// If the config file path has not been modified by the user, then we'll\n\t// use the default config file path. However, if the user has modified\n\t// their lnddir, then we should assume they intend to use the config\n\t// file within it.\n\tconfigFileDir := CleanAndExpandPath(preCfg.LndDir)\n\tconfigFilePath := CleanAndExpandPath(preCfg.ConfigFile)\n\tswitch {\n\t// User specified --lnddir but no --configfile. Update the config file\n\t// path to the lnd config directory, but don't require it to exist.\n\tcase configFileDir != DefaultLndDir &&\n\t\tconfigFilePath == DefaultConfigFile:\n\n\t\tconfigFilePath = filepath.Join(\n\t\t\tconfigFileDir, lncfg.DefaultConfigFilename,\n\t\t)\n\n\t// User did specify an explicit --configfile, so we check that it does\n\t// exist under that path to avoid surprises.\n\tcase configFilePath != DefaultConfigFile:\n\t\tif !lnrpc.FileExists(configFilePath) {\n\t\t\treturn nil, fmt.Errorf(\"specified config file does \"+\n\t\t\t\t\"not exist in %s\", configFilePath)\n\t\t}\n\t}\n\n\t// Next, load any additional configuration options from the file.\n\tvar configFileError error\n\tcfg := preCfg\n\tfileParser := flags.NewParser(&cfg, flags.Default)\n\terr := flags.NewIniParser(fileParser).ParseFile(configFilePath)\n\tif err != nil {\n\t\t// If it's a parsing related error, then we'll return\n\t\t// immediately, otherwise we can proceed as possibly the config\n\t\t// file doesn't exist which is OK.\n\t\tif _, ok := err.(*flags.IniError); ok {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tconfigFileError = err\n\t}\n\n\t// Finally, parse the remaining command line options again to ensure\n\t// they take precedence.\n\tflagParser := flags.NewParser(&cfg, flags.Default)\n\tif _, err := flagParser.Parse(); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Make sure everything we just loaded makes sense.\n\tcleanCfg, err := ValidateConfig(\n\t\tcfg, interceptor, fileParser, flagParser,\n\t)\n\tif usageErr, ok := err.(*usageError); ok {\n\t\t// The logging system might not yet be initialized, so we also\n\t\t// write to stderr to make sure the error appears somewhere.\n\t\t_, _ = fmt.Fprintln(os.Stderr, usageMessage)\n\t\tltndLog.Warnf(\"Incorrect usage: %v\", usageMessage)\n\n\t\t// The log subsystem might not yet be initialized. But we still\n\t\t// try to log the error there since some packaging solutions\n\t\t// might only look at the log and not stdout/stderr.\n\t\tltndLog.Warnf(\"Error validating config: %v\", usageErr.err)\n\n\t\treturn nil, usageErr.err\n\t}\n\tif err != nil {\n\t\t// The log subsystem might not yet be initialized. But we still\n\t\t// try to log the error there since some packaging solutions\n\t\t// might only look at the log and not stdout/stderr.\n\t\tltndLog.Warnf(\"Error validating config: %v\", err)\n\n\t\treturn nil, err\n\t}\n\n\t// Warn about missing config file only after all other configuration is\n\t// done. This prevents the warning on help messages and invalid options.\n\t// Note this should go directly before the return.\n\tif configFileError != nil {\n\t\tltndLog.Warnf(\"%v\", configFileError)\n\t}\n\n\treturn cleanCfg, nil\n}\n\n// usageError is an error type that signals a problem with the supplied flags.",
      "length": 3443,
      "tokens": 507,
      "embedding": []
    },
    {
      "slug": "type usageError struct {",
      "content": "type usageError struct {\n\terr error\n}\n\n// Error returns the error string.\n//\n// NOTE: This is part of the error interface.",
      "length": 92,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func (u *usageError) Error() string {",
      "content": "func (u *usageError) Error() string {\n\treturn u.err.Error()\n}\n\n// ValidateConfig check the given configuration to be sane. This makes sure no\n// illegal values or combination of values are set. All file system paths are\n// normalized. The cleaned up config is returned on success.",
      "length": 237,
      "tokens": 40,
      "embedding": []
    },
    {
      "slug": "func ValidateConfig(cfg Config, interceptor signal.Interceptor, fileParser,",
      "content": "func ValidateConfig(cfg Config, interceptor signal.Interceptor, fileParser,\n\tflagParser *flags.Parser) (*Config, error) {\n\n\t// If the provided lnd directory is not the default, we'll modify the\n\t// path to all of the files and directories that will live within it.\n\tlndDir := CleanAndExpandPath(cfg.LndDir)\n\tif lndDir != DefaultLndDir {\n\t\tcfg.DataDir = filepath.Join(lndDir, defaultDataDirname)\n\t\tcfg.LetsEncryptDir = filepath.Join(\n\t\t\tlndDir, defaultLetsEncryptDirname,\n\t\t)\n\t\tcfg.TLSCertPath = filepath.Join(lndDir, defaultTLSCertFilename)\n\t\tcfg.TLSKeyPath = filepath.Join(lndDir, defaultTLSKeyFilename)\n\t\tcfg.LogDir = filepath.Join(lndDir, defaultLogDirname)\n\n\t\t// If the watchtower's directory is set to the default, i.e. the\n\t\t// user has not requested a different location, we'll move the\n\t\t// location to be relative to the specified lnd directory.\n\t\tif cfg.Watchtower.TowerDir == defaultTowerDir {\n\t\t\tcfg.Watchtower.TowerDir = filepath.Join(\n\t\t\t\tcfg.DataDir, defaultTowerSubDirname,\n\t\t\t)\n\t\t}\n\t}\n\n\tfuncName := \"ValidateConfig\"\n\tmkErr := func(format string, args ...interface{}) error {\n\t\treturn fmt.Errorf(funcName+\": \"+format, args...)\n\t}\n\tmakeDirectory := func(dir string) error {\n\t\terr := os.MkdirAll(dir, 0700)\n\t\tif err != nil {\n\t\t\t// Show a nicer error message if it's because a symlink\n\t\t\t// is linked to a directory that does not exist\n\t\t\t// (probably because it's not mounted).\n\t\t\tif e, ok := err.(*os.PathError); ok && os.IsExist(err) {\n\t\t\t\tlink, lerr := os.Readlink(e.Path)\n\t\t\t\tif lerr == nil {\n\t\t\t\t\tstr := \"is symlink %s -> %s mounted?\"\n\t\t\t\t\terr = fmt.Errorf(str, e.Path, link)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstr := \"Failed to create lnd directory '%s': %v\"\n\t\t\treturn mkErr(str, dir, err)\n\t\t}\n\n\t\treturn nil\n\t}\n\n\t// IsSet returns true if an option has been set in either the config\n\t// file or by a flag.\n\tisSet := func(field string) (bool, error) {\n\t\tfieldName, ok := reflect.TypeOf(Config{}).FieldByName(field)\n\t\tif !ok {\n\t\t\tstr := \"could not find field %s\"\n\t\t\treturn false, mkErr(str, field)\n\t\t}\n\n\t\tlong, ok := fieldName.Tag.Lookup(\"long\")\n\t\tif !ok {\n\t\t\tstr := \"field %s does not have a long tag\"\n\t\t\treturn false, mkErr(str, field)\n\t\t}\n\n\t\t// The user has the option to set the flag in either the config\n\t\t// file or as a command line flag. If any is set, we consider it\n\t\t// to be set, not applying any precedence rules here (since it\n\t\t// is a boolean the default is false anyway which would screw up\n\t\t// any precedence rules). Additionally, we need to also support\n\t\t// the use case where the config struct is embedded _within_\n\t\t// another struct with a prefix (as is the case with\n\t\t// lightning-terminal).\n\t\tfileOption := fileParser.FindOptionByLongName(long)\n\t\tfileOptionNested := fileParser.FindOptionByLongName(\n\t\t\t\"lnd.\" + long,\n\t\t)\n\t\tflagOption := flagParser.FindOptionByLongName(long)\n\t\tflagOptionNested := flagParser.FindOptionByLongName(\n\t\t\t\"lnd.\" + long,\n\t\t)\n\n\t\treturn (fileOption != nil && fileOption.IsSet()) ||\n\t\t\t\t(fileOptionNested != nil && fileOptionNested.IsSet()) ||\n\t\t\t\t(flagOption != nil && flagOption.IsSet()) ||\n\t\t\t\t(flagOptionNested != nil && flagOptionNested.IsSet()),\n\t\t\tnil\n\t}\n\n\t// As soon as we're done parsing configuration options, ensure all paths\n\t// to directories and files are cleaned and expanded before attempting\n\t// to use them later on.\n\tcfg.DataDir = CleanAndExpandPath(cfg.DataDir)\n\tcfg.TLSCertPath = CleanAndExpandPath(cfg.TLSCertPath)\n\tcfg.TLSKeyPath = CleanAndExpandPath(cfg.TLSKeyPath)\n\tcfg.LetsEncryptDir = CleanAndExpandPath(cfg.LetsEncryptDir)\n\tcfg.AdminMacPath = CleanAndExpandPath(cfg.AdminMacPath)\n\tcfg.ReadMacPath = CleanAndExpandPath(cfg.ReadMacPath)\n\tcfg.InvoiceMacPath = CleanAndExpandPath(cfg.InvoiceMacPath)\n\tcfg.LogDir = CleanAndExpandPath(cfg.LogDir)\n\tcfg.BtcdMode.Dir = CleanAndExpandPath(cfg.BtcdMode.Dir)\n\tcfg.LtcdMode.Dir = CleanAndExpandPath(cfg.LtcdMode.Dir)\n\tcfg.BitcoindMode.Dir = CleanAndExpandPath(cfg.BitcoindMode.Dir)\n\tcfg.BitcoindMode.ConfigPath = CleanAndExpandPath(\n\t\tcfg.BitcoindMode.ConfigPath,\n\t)\n\tcfg.BitcoindMode.RPCCookie = CleanAndExpandPath(cfg.BitcoindMode.RPCCookie)\n\tcfg.LitecoindMode.Dir = CleanAndExpandPath(cfg.LitecoindMode.Dir)\n\tcfg.LitecoindMode.ConfigPath = CleanAndExpandPath(\n\t\tcfg.LitecoindMode.ConfigPath,\n\t)\n\tcfg.LitecoindMode.RPCCookie = CleanAndExpandPath(\n\t\tcfg.LitecoindMode.RPCCookie,\n\t)\n\tcfg.Tor.PrivateKeyPath = CleanAndExpandPath(cfg.Tor.PrivateKeyPath)\n\tcfg.Tor.WatchtowerKeyPath = CleanAndExpandPath(cfg.Tor.WatchtowerKeyPath)\n\tcfg.Watchtower.TowerDir = CleanAndExpandPath(cfg.Watchtower.TowerDir)\n\tcfg.BackupFilePath = CleanAndExpandPath(cfg.BackupFilePath)\n\tcfg.WalletUnlockPasswordFile = CleanAndExpandPath(\n\t\tcfg.WalletUnlockPasswordFile,\n\t)\n\n\t// Ensure that the user didn't attempt to specify negative values for\n\t// any of the autopilot params.\n\tif cfg.Autopilot.MaxChannels < 0 {\n\t\tstr := \"autopilot.maxchannels must be non-negative\"\n\t\treturn nil, mkErr(str)\n\t}\n\tif cfg.Autopilot.Allocation < 0 {\n\t\tstr := \"autopilot.allocation must be non-negative\"\n\t\treturn nil, mkErr(str)\n\t}\n\tif cfg.Autopilot.MinChannelSize < 0 {\n\t\tstr := \"autopilot.minchansize must be non-negative\"\n\t\treturn nil, mkErr(str)\n\t}\n\tif cfg.Autopilot.MaxChannelSize < 0 {\n\t\tstr := \"autopilot.maxchansize must be non-negative\"\n\t\treturn nil, mkErr(str)\n\t}\n\tif cfg.Autopilot.MinConfs < 0 {\n\t\tstr := \"autopilot.minconfs must be non-negative\"\n\t\treturn nil, mkErr(str)\n\t}\n\tif cfg.Autopilot.ConfTarget < 1 {\n\t\tstr := \"autopilot.conftarget must be positive\"\n\t\treturn nil, mkErr(str)\n\t}\n\n\t// Ensure that the specified values for the min and max channel size\n\t// are within the bounds of the normal chan size constraints.\n\tif cfg.Autopilot.MinChannelSize < int64(funding.MinChanFundingSize) {\n\t\tcfg.Autopilot.MinChannelSize = int64(funding.MinChanFundingSize)\n\t}\n\tif cfg.Autopilot.MaxChannelSize > int64(MaxFundingAmount) {\n\t\tcfg.Autopilot.MaxChannelSize = int64(MaxFundingAmount)\n\t}\n\n\tif _, err := validateAtplCfg(cfg.Autopilot); err != nil {\n\t\treturn nil, mkErr(\"error validating autopilot: %v\", err)\n\t}\n\n\t// Ensure that --maxchansize is properly handled when set by user.\n\t// For non-Wumbo channels this limit remains 16777215 satoshis by default\n\t// as specified in BOLT-02. For wumbo channels this limit is 1,000,000,000.\n\t// satoshis (10 BTC). Always enforce --maxchansize explicitly set by user.\n\t// If unset (marked by 0 value), then enforce proper default.\n\tif cfg.MaxChanSize == 0 {\n\t\tif cfg.ProtocolOptions.Wumbo() {\n\t\t\tcfg.MaxChanSize = int64(funding.MaxBtcFundingAmountWumbo)\n\t\t} else {\n\t\t\tcfg.MaxChanSize = int64(funding.MaxBtcFundingAmount)\n\t\t}\n\t}\n\n\t// Ensure that the user specified values for the min and max channel\n\t// size make sense.\n\tif cfg.MaxChanSize < cfg.MinChanSize {\n\t\treturn nil, mkErr(\"invalid channel size parameters: \"+\n\t\t\t\"max channel size %v, must be no less than min chan \"+\n\t\t\t\"size %v\", cfg.MaxChanSize, cfg.MinChanSize,\n\t\t)\n\t}\n\n\t// Don't allow superfluous --maxchansize greater than\n\t// BOLT 02 soft-limit for non-wumbo channel\n\tif !cfg.ProtocolOptions.Wumbo() &&\n\t\tcfg.MaxChanSize > int64(MaxFundingAmount) {\n\n\t\treturn nil, mkErr(\"invalid channel size parameters: \"+\n\t\t\t\"maximum channel size %v is greater than maximum \"+\n\t\t\t\"non-wumbo channel size %v\", cfg.MaxChanSize,\n\t\t\tMaxFundingAmount,\n\t\t)\n\t}\n\n\t// Ensure that the amount data for revoked commitment transactions is\n\t// stored if the watchtower client is active.\n\tif cfg.DB.NoRevLogAmtData && cfg.WtClient.Active {\n\t\treturn nil, mkErr(\"revocation log amount data must be stored \" +\n\t\t\t\"if the watchtower client is active\")\n\t}\n\n\t// Ensure a valid max channel fee allocation was set.\n\tif cfg.MaxChannelFeeAllocation <= 0 || cfg.MaxChannelFeeAllocation > 1 {\n\t\treturn nil, mkErr(\"invalid max channel fee allocation: %v, \"+\n\t\t\t\"must be within (0, 1]\", cfg.MaxChannelFeeAllocation)\n\t}\n\n\tif cfg.MaxCommitFeeRateAnchors < 1 {\n\t\treturn nil, mkErr(\"invalid max commit fee rate anchors: %v, \"+\n\t\t\t\"must be at least 1 sat/vByte\",\n\t\t\tcfg.MaxCommitFeeRateAnchors)\n\t}\n\n\t// Validate the Tor config parameters.\n\tsocks, err := lncfg.ParseAddressString(\n\t\tcfg.Tor.SOCKS, strconv.Itoa(defaultTorSOCKSPort),\n\t\tcfg.net.ResolveTCPAddr,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcfg.Tor.SOCKS = socks.String()\n\n\t// We'll only attempt to normalize and resolve the DNS host if it hasn't\n\t// changed, as it doesn't need to be done for the default.\n\tif cfg.Tor.DNS != defaultTorDNS {\n\t\tdns, err := lncfg.ParseAddressString(\n\t\t\tcfg.Tor.DNS, strconv.Itoa(defaultTorDNSPort),\n\t\t\tcfg.net.ResolveTCPAddr,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, mkErr(\"error parsing tor dns: %v\", err)\n\t\t}\n\t\tcfg.Tor.DNS = dns.String()\n\t}\n\n\tcontrol, err := lncfg.ParseAddressString(\n\t\tcfg.Tor.Control, strconv.Itoa(defaultTorControlPort),\n\t\tcfg.net.ResolveTCPAddr,\n\t)\n\tif err != nil {\n\t\treturn nil, mkErr(\"error parsing tor control address: %v\", err)\n\t}\n\tcfg.Tor.Control = control.String()\n\n\t// Ensure that tor socks host:port is not equal to tor control\n\t// host:port. This would lead to lnd not starting up properly.\n\tif cfg.Tor.SOCKS == cfg.Tor.Control {\n\t\tstr := \"tor.socks and tor.control can not us the same host:port\"\n\t\treturn nil, mkErr(str)\n\t}\n\n\tswitch {\n\tcase cfg.Tor.V2 && cfg.Tor.V3:\n\t\treturn nil, mkErr(\"either tor.v2 or tor.v3 can be set, \" +\n\t\t\t\"but not both\")\n\tcase cfg.DisableListen && (cfg.Tor.V2 || cfg.Tor.V3):\n\t\treturn nil, mkErr(\"listening must be enabled when enabling \" +\n\t\t\t\"inbound connections over Tor\")\n\t}\n\n\tif cfg.Tor.PrivateKeyPath == \"\" {\n\t\tswitch {\n\t\tcase cfg.Tor.V2:\n\t\t\tcfg.Tor.PrivateKeyPath = filepath.Join(\n\t\t\t\tlndDir, defaultTorV2PrivateKeyFilename,\n\t\t\t)\n\t\tcase cfg.Tor.V3:\n\t\t\tcfg.Tor.PrivateKeyPath = filepath.Join(\n\t\t\t\tlndDir, defaultTorV3PrivateKeyFilename,\n\t\t\t)\n\t\t}\n\t}\n\n\tif cfg.Tor.WatchtowerKeyPath == \"\" {\n\t\tswitch {\n\t\tcase cfg.Tor.V2:\n\t\t\tcfg.Tor.WatchtowerKeyPath = filepath.Join(\n\t\t\t\tcfg.Watchtower.TowerDir,\n\t\t\t\tdefaultTorV2PrivateKeyFilename,\n\t\t\t)\n\t\tcase cfg.Tor.V3:\n\t\t\tcfg.Tor.WatchtowerKeyPath = filepath.Join(\n\t\t\t\tcfg.Watchtower.TowerDir,\n\t\t\t\tdefaultTorV3PrivateKeyFilename,\n\t\t\t)\n\t\t}\n\t}\n\n\t// Set up the network-related functions that will be used throughout\n\t// the daemon. We use the standard Go \"net\" package functions by\n\t// default. If we should be proxying all traffic through Tor, then\n\t// we'll use the Tor proxy specific functions in order to avoid leaking\n\t// our real information.\n\tif cfg.Tor.Active {\n\t\tcfg.net = &tor.ProxyNet{\n\t\t\tSOCKS:                       cfg.Tor.SOCKS,\n\t\t\tDNS:                         cfg.Tor.DNS,\n\t\t\tStreamIsolation:             cfg.Tor.StreamIsolation,\n\t\t\tSkipProxyForClearNetTargets: cfg.Tor.SkipProxyForClearNetTargets,\n\t\t}\n\t}\n\n\tif cfg.DisableListen && cfg.NAT {\n\t\treturn nil, mkErr(\"NAT traversal cannot be used when \" +\n\t\t\t\"listening is disabled\")\n\t}\n\tif cfg.NAT && len(cfg.ExternalHosts) != 0 {\n\t\treturn nil, mkErr(\"NAT support and externalhosts are \" +\n\t\t\t\"mutually exclusive, only one should be selected\")\n\t}\n\n\t// Determine the active chain configuration and its parameters.\n\tswitch {\n\t// At this moment, multiple active chains are not supported.\n\tcase cfg.Litecoin.Active && cfg.Bitcoin.Active:\n\t\tstr := \"Currently both Bitcoin and Litecoin cannot be \" +\n\t\t\t\"active together\"\n\t\treturn nil, mkErr(str)\n\n\t// Either Bitcoin must be active, or Litecoin must be active.\n\t// Otherwise, we don't know which chain we're on.\n\tcase !cfg.Bitcoin.Active && !cfg.Litecoin.Active:\n\t\treturn nil, mkErr(\"either bitcoin.active or \" +\n\t\t\t\"litecoin.active must be set to 1 (true)\")\n\n\tcase cfg.Litecoin.Active:\n\t\terr := cfg.Litecoin.Validate(\n\t\t\tminTimeLockDelta, funding.MinLtcRemoteDelay,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, mkErr(\"error validating litecoin: %v\", err)\n\t\t}\n\n\t\t// Multiple networks can't be selected simultaneously.  Count\n\t\t// number of network flags passed; assign active network params\n\t\t// while we're at it.\n\t\tnumNets := 0\n\t\tvar ltcParams chainreg.LitecoinNetParams\n\t\tif cfg.Litecoin.MainNet {\n\t\t\tnumNets++\n\t\t\tltcParams = chainreg.LitecoinMainNetParams\n\t\t}\n\t\tif cfg.Litecoin.TestNet3 {\n\t\t\tnumNets++\n\t\t\tltcParams = chainreg.LitecoinTestNetParams\n\t\t}\n\t\tif cfg.Litecoin.RegTest {\n\t\t\tnumNets++\n\t\t\tltcParams = chainreg.LitecoinRegTestNetParams\n\t\t}\n\t\tif cfg.Litecoin.SimNet {\n\t\t\tnumNets++\n\t\t\tltcParams = chainreg.LitecoinSimNetParams\n\t\t}\n\t\tif cfg.Litecoin.SigNet {\n\t\t\treturn nil, mkErr(\"litecoin.signet is not supported\")\n\t\t}\n\n\t\tif numNets > 1 {\n\t\t\tstr := \"The mainnet, testnet, and simnet params \" +\n\t\t\t\t\"can't be used together -- choose one of the \" +\n\t\t\t\t\"three\"\n\t\t\treturn nil, mkErr(str)\n\t\t}\n\n\t\t// The target network must be provided, otherwise, we won't\n\t\t// know how to initialize the daemon.\n\t\tif numNets == 0 {\n\t\t\tstr := \"either --litecoin.mainnet, or \" +\n\t\t\t\t\"litecoin.testnet must be specified\"\n\t\t\treturn nil, mkErr(str)\n\t\t}\n\n\t\t// The litecoin chain is the current active chain. However\n\t\t// throughout the codebase we required chaincfg.Params. So as a\n\t\t// temporary hack, we'll mutate the default net params for\n\t\t// bitcoin with the litecoin specific information.\n\t\tchainreg.ApplyLitecoinParams(&cfg.ActiveNetParams, &ltcParams)\n\n\t\tswitch cfg.Litecoin.Node {\n\t\tcase \"ltcd\":\n\t\t\terr := parseRPCParams(\n\t\t\t\tcfg.Litecoin, cfg.LtcdMode,\n\t\t\t\tchainreg.LitecoinChain, cfg.ActiveNetParams,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, mkErr(\"unable to load RPC \"+\n\t\t\t\t\t\"credentials for ltcd: %v\", err)\n\t\t\t}\n\t\tcase \"litecoind\":\n\t\t\tif cfg.Litecoin.SimNet {\n\t\t\t\treturn nil, mkErr(\"litecoind does not \" +\n\t\t\t\t\t\"support simnet\")\n\t\t\t}\n\t\t\terr := parseRPCParams(\n\t\t\t\tcfg.Litecoin, cfg.LitecoindMode,\n\t\t\t\tchainreg.LitecoinChain, cfg.ActiveNetParams,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, mkErr(\"unable to load RPC \"+\n\t\t\t\t\t\"credentials for litecoind: %v\", err)\n\t\t\t}\n\t\tdefault:\n\t\t\tstr := \"only ltcd and litecoind mode supported for \" +\n\t\t\t\t\"litecoin at this time\"\n\t\t\treturn nil, mkErr(str)\n\t\t}\n\n\t\tcfg.Litecoin.ChainDir = filepath.Join(\n\t\t\tcfg.DataDir, defaultChainSubDirname,\n\t\t\tchainreg.LitecoinChain.String(),\n\t\t)\n\n\t\t// Finally, we'll register the litecoin chain as our current\n\t\t// primary chain.\n\t\tcfg.registeredChains.RegisterPrimaryChain(chainreg.LitecoinChain)\n\t\tMaxFundingAmount = funding.MaxLtcFundingAmount\n\n\tcase cfg.Bitcoin.Active:\n\t\t// Multiple networks can't be selected simultaneously.  Count\n\t\t// number of network flags passed; assign active network params\n\t\t// while we're at it.\n\t\tnumNets := 0\n\t\tif cfg.Bitcoin.MainNet {\n\t\t\tnumNets++\n\t\t\tcfg.ActiveNetParams = chainreg.BitcoinMainNetParams\n\t\t}\n\t\tif cfg.Bitcoin.TestNet3 {\n\t\t\tnumNets++\n\t\t\tcfg.ActiveNetParams = chainreg.BitcoinTestNetParams\n\t\t}\n\t\tif cfg.Bitcoin.RegTest {\n\t\t\tnumNets++\n\t\t\tcfg.ActiveNetParams = chainreg.BitcoinRegTestNetParams\n\t\t}\n\t\tif cfg.Bitcoin.SimNet {\n\t\t\tnumNets++\n\t\t\tcfg.ActiveNetParams = chainreg.BitcoinSimNetParams\n\t\t}\n\t\tif cfg.Bitcoin.SigNet {\n\t\t\tnumNets++\n\t\t\tcfg.ActiveNetParams = chainreg.BitcoinSigNetParams\n\n\t\t\t// Let the user overwrite the default signet parameters.\n\t\t\t// The challenge defines the actual signet network to\n\t\t\t// join and the seed nodes are needed for network\n\t\t\t// discovery.\n\t\t\tsigNetChallenge := chaincfg.DefaultSignetChallenge\n\t\t\tsigNetSeeds := chaincfg.DefaultSignetDNSSeeds\n\t\t\tif cfg.Bitcoin.SigNetChallenge != \"\" {\n\t\t\t\tchallenge, err := hex.DecodeString(\n\t\t\t\t\tcfg.Bitcoin.SigNetChallenge,\n\t\t\t\t)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, mkErr(\"Invalid \"+\n\t\t\t\t\t\t\"signet challenge, hex decode \"+\n\t\t\t\t\t\t\"failed: %v\", err)\n\t\t\t\t}\n\t\t\t\tsigNetChallenge = challenge\n\t\t\t}\n\n\t\t\tif len(cfg.Bitcoin.SigNetSeedNode) > 0 {\n\t\t\t\tsigNetSeeds = make([]chaincfg.DNSSeed, len(\n\t\t\t\t\tcfg.Bitcoin.SigNetSeedNode,\n\t\t\t\t))\n\t\t\t\tfor idx, seed := range cfg.Bitcoin.SigNetSeedNode {\n\t\t\t\t\tsigNetSeeds[idx] = chaincfg.DNSSeed{\n\t\t\t\t\t\tHost:         seed,\n\t\t\t\t\t\tHasFiltering: false,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchainParams := chaincfg.CustomSignetParams(\n\t\t\t\tsigNetChallenge, sigNetSeeds,\n\t\t\t)\n\t\t\tcfg.ActiveNetParams.Params = &chainParams\n\t\t}\n\t\tif numNets > 1 {\n\t\t\tstr := \"The mainnet, testnet, regtest, and simnet \" +\n\t\t\t\t\"params can't be used together -- choose one \" +\n\t\t\t\t\"of the four\"\n\t\t\treturn nil, mkErr(str)\n\t\t}\n\n\t\t// The target network must be provided, otherwise, we won't\n\t\t// know how to initialize the daemon.\n\t\tif numNets == 0 {\n\t\t\tstr := \"either --bitcoin.mainnet, or bitcoin.testnet,\" +\n\t\t\t\t\"bitcoin.simnet, or bitcoin.regtest \" +\n\t\t\t\t\"must be specified\"\n\t\t\treturn nil, mkErr(str)\n\t\t}\n\n\t\terr := cfg.Bitcoin.Validate(\n\t\t\tminTimeLockDelta, funding.MinBtcRemoteDelay,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, mkErr(\"error validating bitcoin params: %v\",\n\t\t\t\terr)\n\t\t}\n\n\t\tswitch cfg.Bitcoin.Node {\n\t\tcase \"btcd\":\n\t\t\terr := parseRPCParams(\n\t\t\t\tcfg.Bitcoin, cfg.BtcdMode,\n\t\t\t\tchainreg.BitcoinChain, cfg.ActiveNetParams,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, mkErr(\"unable to load RPC \"+\n\t\t\t\t\t\"credentials for btcd: %v\", err)\n\t\t\t}\n\t\tcase \"bitcoind\":\n\t\t\tif cfg.Bitcoin.SimNet {\n\t\t\t\treturn nil, mkErr(\"bitcoind does not \" +\n\t\t\t\t\t\"support simnet\")\n\t\t\t}\n\n\t\t\terr := parseRPCParams(\n\t\t\t\tcfg.Bitcoin, cfg.BitcoindMode,\n\t\t\t\tchainreg.BitcoinChain, cfg.ActiveNetParams,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, mkErr(\"unable to load RPC \"+\n\t\t\t\t\t\"credentials for bitcoind: %v\", err)\n\t\t\t}\n\t\tcase \"neutrino\":\n\t\t\t// No need to get RPC parameters.\n\n\t\tcase \"nochainbackend\":\n\t\t\t// Nothing to configure, we're running without any chain\n\t\t\t// backend whatsoever (pure signing mode).\n\n\t\tdefault:\n\t\t\tstr := \"only btcd, bitcoind, and neutrino mode \" +\n\t\t\t\t\"supported for bitcoin at this time\"\n\t\t\treturn nil, mkErr(str)\n\t\t}\n\n\t\tcfg.Bitcoin.ChainDir = filepath.Join(\n\t\t\tcfg.DataDir, defaultChainSubDirname,\n\t\t\tchainreg.BitcoinChain.String(),\n\t\t)\n\n\t\t// Finally we'll register the bitcoin chain as our current\n\t\t// primary chain.\n\t\tcfg.registeredChains.RegisterPrimaryChain(chainreg.BitcoinChain)\n\t}\n\n\t// Ensure that the user didn't attempt to specify negative values for\n\t// any of the autopilot params.\n\tif cfg.Autopilot.MaxChannels < 0 {\n\t\tstr := \"autopilot.maxchannels must be non-negative\"\n\t\treturn nil, mkErr(str)\n\t}\n\tif cfg.Autopilot.Allocation < 0 {\n\t\tstr := \"autopilot.allocation must be non-negative\"\n\t\treturn nil, mkErr(str)\n\t}\n\tif cfg.Autopilot.MinChannelSize < 0 {\n\t\tstr := \"autopilot.minchansize must be non-negative\"\n\t\treturn nil, mkErr(str)\n\t}\n\tif cfg.Autopilot.MaxChannelSize < 0 {\n\t\tstr := \"autopilot.maxchansize must be non-negative\"\n\t\treturn nil, mkErr(str)\n\t}\n\n\t// Ensure that the specified values for the min and max channel size\n\t// don't are within the bounds of the normal chan size constraints.\n\tif cfg.Autopilot.MinChannelSize < int64(funding.MinChanFundingSize) {\n\t\tcfg.Autopilot.MinChannelSize = int64(funding.MinChanFundingSize)\n\t}\n\tif cfg.Autopilot.MaxChannelSize > int64(MaxFundingAmount) {\n\t\tcfg.Autopilot.MaxChannelSize = int64(MaxFundingAmount)\n\t}\n\n\t// Validate profile port or host:port.\n\tif cfg.Profile != \"\" {\n\t\tstr := \"%s: The profile port must be between 1024 and 65535\"\n\n\t\t// Try to parse Profile as a host:port.\n\t\t_, hostPort, err := net.SplitHostPort(cfg.Profile)\n\t\tif err == nil {\n\t\t\t// Determine if the port is valid.\n\t\t\tprofilePort, err := strconv.Atoi(hostPort)\n\t\t\tif err != nil || profilePort < 1024 || profilePort > 65535 {\n\t\t\t\treturn nil, &usageError{mkErr(str)}\n\t\t\t}\n\t\t} else {\n\t\t\t// Try to parse Profile as a port.\n\t\t\tprofilePort, err := strconv.Atoi(cfg.Profile)\n\t\t\tif err != nil || profilePort < 1024 || profilePort > 65535 {\n\t\t\t\treturn nil, &usageError{mkErr(str)}\n\t\t\t}\n\n\t\t\t// Since the user just set a port, we will serve debugging\n\t\t\t// information over localhost.\n\t\t\tcfg.Profile = net.JoinHostPort(\"127.0.0.1\", cfg.Profile)\n\t\t}\n\t}\n\n\t// We'll now construct the network directory which will be where we\n\t// store all the data specific to this chain/network.\n\tcfg.networkDir = filepath.Join(\n\t\tcfg.DataDir, defaultChainSubDirname,\n\t\tcfg.registeredChains.PrimaryChain().String(),\n\t\tlncfg.NormalizeNetwork(cfg.ActiveNetParams.Name),\n\t)\n\n\t// If a custom macaroon directory wasn't specified and the data\n\t// directory has changed from the default path, then we'll also update\n\t// the path for the macaroons to be generated.\n\tif cfg.AdminMacPath == \"\" {\n\t\tcfg.AdminMacPath = filepath.Join(\n\t\t\tcfg.networkDir, defaultAdminMacFilename,\n\t\t)\n\t}\n\tif cfg.ReadMacPath == \"\" {\n\t\tcfg.ReadMacPath = filepath.Join(\n\t\t\tcfg.networkDir, defaultReadMacFilename,\n\t\t)\n\t}\n\tif cfg.InvoiceMacPath == \"\" {\n\t\tcfg.InvoiceMacPath = filepath.Join(\n\t\t\tcfg.networkDir, defaultInvoiceMacFilename,\n\t\t)\n\t}\n\n\ttowerDir := filepath.Join(\n\t\tcfg.Watchtower.TowerDir,\n\t\tcfg.registeredChains.PrimaryChain().String(),\n\t\tlncfg.NormalizeNetwork(cfg.ActiveNetParams.Name),\n\t)\n\n\t// Create the lnd directory and all other sub-directories if they don't\n\t// already exist. This makes sure that directory trees are also created\n\t// for files that point to outside the lnddir.\n\tdirs := []string{\n\t\tlndDir, cfg.DataDir, cfg.networkDir,\n\t\tcfg.LetsEncryptDir, towerDir, cfg.graphDatabaseDir(),\n\t\tfilepath.Dir(cfg.TLSCertPath), filepath.Dir(cfg.TLSKeyPath),\n\t\tfilepath.Dir(cfg.AdminMacPath), filepath.Dir(cfg.ReadMacPath),\n\t\tfilepath.Dir(cfg.InvoiceMacPath),\n\t\tfilepath.Dir(cfg.Tor.PrivateKeyPath),\n\t\tfilepath.Dir(cfg.Tor.WatchtowerKeyPath),\n\t}\n\tfor _, dir := range dirs {\n\t\tif err := makeDirectory(dir); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Similarly, if a custom back up file path wasn't specified, then\n\t// we'll update the file location to match our set network directory.\n\tif cfg.BackupFilePath == \"\" {\n\t\tcfg.BackupFilePath = filepath.Join(\n\t\t\tcfg.networkDir, chanbackup.DefaultBackupFileName,\n\t\t)\n\t}\n\n\t// Append the network type to the log directory so it is \"namespaced\"\n\t// per network in the same fashion as the data directory.\n\tcfg.LogDir = filepath.Join(\n\t\tcfg.LogDir, cfg.registeredChains.PrimaryChain().String(),\n\t\tlncfg.NormalizeNetwork(cfg.ActiveNetParams.Name),\n\t)\n\n\t// A log writer must be passed in, otherwise we can't function and would\n\t// run into a panic later on.\n\tif cfg.LogWriter == nil {\n\t\treturn nil, mkErr(\"log writer missing in config\")\n\t}\n\n\t// Special show command to list supported subsystems and exit.\n\tif cfg.DebugLevel == \"show\" {\n\t\tfmt.Println(\"Supported subsystems\",\n\t\t\tcfg.LogWriter.SupportedSubsystems())\n\t\tos.Exit(0)\n\t}\n\n\t// Initialize logging at the default logging level.\n\tSetupLoggers(cfg.LogWriter, interceptor)\n\terr = cfg.LogWriter.InitLogRotator(\n\t\tfilepath.Join(cfg.LogDir, defaultLogFilename),\n\t\tcfg.MaxLogFileSize, cfg.MaxLogFiles,\n\t)\n\tif err != nil {\n\t\tstr := \"log rotation setup failed: %v\"\n\t\treturn nil, mkErr(str, err)\n\t}\n\n\t// Parse, validate, and set debug log level(s).\n\terr = build.ParseAndSetDebugLevels(cfg.DebugLevel, cfg.LogWriter)\n\tif err != nil {\n\t\tstr := \"error parsing debug level: %v\"\n\t\treturn nil, &usageError{mkErr(str, err)}\n\t}\n\n\t// At least one RPCListener is required. So listen on localhost per\n\t// default.\n\tif len(cfg.RawRPCListeners) == 0 {\n\t\taddr := fmt.Sprintf(\"localhost:%d\", defaultRPCPort)\n\t\tcfg.RawRPCListeners = append(cfg.RawRPCListeners, addr)\n\t}\n\n\t// Listen on localhost if no REST listeners were specified.\n\tif len(cfg.RawRESTListeners) == 0 {\n\t\taddr := fmt.Sprintf(\"localhost:%d\", defaultRESTPort)\n\t\tcfg.RawRESTListeners = append(cfg.RawRESTListeners, addr)\n\t}\n\n\t// Listen on the default interface/port if no listeners were specified.\n\t// An empty address string means default interface/address, which on\n\t// most unix systems is the same as 0.0.0.0. If Tor is active, we\n\t// default to only listening on localhost for hidden service\n\t// connections.\n\tif len(cfg.RawListeners) == 0 {\n\t\taddr := fmt.Sprintf(\":%d\", defaultPeerPort)\n\t\tif cfg.Tor.Active && !cfg.Tor.SkipProxyForClearNetTargets {\n\t\t\taddr = fmt.Sprintf(\"localhost:%d\", defaultPeerPort)\n\t\t}\n\t\tcfg.RawListeners = append(cfg.RawListeners, addr)\n\t}\n\n\t// Add default port to all RPC listener addresses if needed and remove\n\t// duplicate addresses.\n\tcfg.RPCListeners, err = lncfg.NormalizeAddresses(\n\t\tcfg.RawRPCListeners, strconv.Itoa(defaultRPCPort),\n\t\tcfg.net.ResolveTCPAddr,\n\t)\n\tif err != nil {\n\t\treturn nil, mkErr(\"error normalizing RPC listen addrs: %v\", err)\n\t}\n\n\t// Add default port to all REST listener addresses if needed and remove\n\t// duplicate addresses.\n\tcfg.RESTListeners, err = lncfg.NormalizeAddresses(\n\t\tcfg.RawRESTListeners, strconv.Itoa(defaultRESTPort),\n\t\tcfg.net.ResolveTCPAddr,\n\t)\n\tif err != nil {\n\t\treturn nil, mkErr(\"error normalizing REST listen addrs: %v\", err)\n\t}\n\n\tswitch {\n\t// The no seed backup and auto unlock are mutually exclusive.\n\tcase cfg.NoSeedBackup && cfg.WalletUnlockPasswordFile != \"\":\n\t\treturn nil, mkErr(\"cannot set noseedbackup and \" +\n\t\t\t\"wallet-unlock-password-file at the same time\")\n\n\t// The \"allow-create\" flag cannot be set without the auto unlock file.\n\tcase cfg.WalletUnlockAllowCreate && cfg.WalletUnlockPasswordFile == \"\":\n\t\treturn nil, mkErr(\"cannot set wallet-unlock-allow-create \" +\n\t\t\t\"without wallet-unlock-password-file\")\n\n\t// If a password file was specified, we need it to exist.\n\tcase cfg.WalletUnlockPasswordFile != \"\" &&\n\t\t!lnrpc.FileExists(cfg.WalletUnlockPasswordFile):\n\n\t\treturn nil, mkErr(\"wallet unlock password file %s does \"+\n\t\t\t\"not exist\", cfg.WalletUnlockPasswordFile)\n\t}\n\n\t// For each of the RPC listeners (REST+gRPC), we'll ensure that users\n\t// have specified a safe combo for authentication. If not, we'll bail\n\t// out with an error. Since we don't allow disabling TLS for gRPC\n\t// connections we pass in tlsActive=true.\n\terr = lncfg.EnforceSafeAuthentication(\n\t\tcfg.RPCListeners, !cfg.NoMacaroons, true,\n\t)\n\tif err != nil {\n\t\treturn nil, mkErr(\"error enforcing safe authentication on \"+\n\t\t\t\"RPC ports: %v\", err)\n\t}\n\n\tif cfg.DisableRest {\n\t\tltndLog.Infof(\"REST API is disabled!\")\n\t\tcfg.RESTListeners = nil\n\t} else {\n\t\terr = lncfg.EnforceSafeAuthentication(\n\t\t\tcfg.RESTListeners, !cfg.NoMacaroons, !cfg.DisableRestTLS,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, mkErr(\"error enforcing safe \"+\n\t\t\t\t\"authentication on REST ports: %v\", err)\n\t\t}\n\t}\n\n\t// Remove the listening addresses specified if listening is disabled.\n\tif cfg.DisableListen {\n\t\tltndLog.Infof(\"Listening on the p2p interface is disabled!\")\n\t\tcfg.Listeners = nil\n\t\tcfg.ExternalIPs = nil\n\t} else {\n\n\t\t// Add default port to all listener addresses if needed and remove\n\t\t// duplicate addresses.\n\t\tcfg.Listeners, err = lncfg.NormalizeAddresses(\n\t\t\tcfg.RawListeners, strconv.Itoa(defaultPeerPort),\n\t\t\tcfg.net.ResolveTCPAddr,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, mkErr(\"error normalizing p2p listen \"+\n\t\t\t\t\"addrs: %v\", err)\n\t\t}\n\n\t\t// Add default port to all external IP addresses if needed and remove\n\t\t// duplicate addresses.\n\t\tcfg.ExternalIPs, err = lncfg.NormalizeAddresses(\n\t\t\tcfg.RawExternalIPs, strconv.Itoa(defaultPeerPort),\n\t\t\tcfg.net.ResolveTCPAddr,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// For the p2p port it makes no sense to listen to an Unix socket.\n\t\t// Also, we would need to refactor the brontide listener to support\n\t\t// that.\n\t\tfor _, p2pListener := range cfg.Listeners {\n\t\t\tif lncfg.IsUnix(p2pListener) {\n\t\t\t\treturn nil, mkErr(\"unix socket addresses \"+\n\t\t\t\t\t\"cannot be used for the p2p \"+\n\t\t\t\t\t\"connection listener: %s\", p2pListener)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Ensure that the specified minimum backoff is below or equal to the\n\t// maximum backoff.\n\tif cfg.MinBackoff > cfg.MaxBackoff {\n\t\treturn nil, mkErr(\"maxbackoff must be greater than minbackoff\")\n\t}\n\n\t// Newer versions of lnd added a new sub-config for bolt-specific\n\t// parameters. However, we want to also allow existing users to use the\n\t// value on the top-level config. If the outer config value is set,\n\t// then we'll use that directly.\n\tflagSet, err := isSet(\"SyncFreelist\")\n\tif err != nil {\n\t\treturn nil, mkErr(\"error parsing freelist sync flag: %v\", err)\n\t}\n\tif flagSet {\n\t\tcfg.DB.Bolt.NoFreelistSync = !cfg.SyncFreelist\n\t}\n\n\t// Parse any extra sqlite pragma options that may have been provided\n\t// to determine if they override any of the defaults that we will\n\t// otherwise add.\n\tvar (\n\t\tdefaultSynchronous = true\n\t\tdefaultAutoVacuum  = true\n\t\tdefaultFullfsync   = true\n\t)\n\tfor _, option := range cfg.DB.Sqlite.PragmaOptions {\n\t\tswitch {\n\t\tcase strings.HasPrefix(option, \"synchronous=\"):\n\t\t\tdefaultSynchronous = false\n\n\t\tcase strings.HasPrefix(option, \"auto_vacuum=\"):\n\t\t\tdefaultAutoVacuum = false\n\n\t\tcase strings.HasPrefix(option, \"fullfsync=\"):\n\t\t\tdefaultFullfsync = false\n\n\t\tdefault:\n\t\t}\n\t}\n\n\tif defaultSynchronous {\n\t\tcfg.DB.Sqlite.PragmaOptions = append(\n\t\t\tcfg.DB.Sqlite.PragmaOptions, \"synchronous=full\",\n\t\t)\n\t}\n\n\tif defaultAutoVacuum {\n\t\tcfg.DB.Sqlite.PragmaOptions = append(\n\t\t\tcfg.DB.Sqlite.PragmaOptions, \"auto_vacuum=incremental\",\n\t\t)\n\t}\n\n\tif defaultFullfsync {\n\t\tcfg.DB.Sqlite.PragmaOptions = append(\n\t\t\tcfg.DB.Sqlite.PragmaOptions, \"fullfsync=true\",\n\t\t)\n\t}\n\n\t// Ensure that the user hasn't chosen a remote-max-htlc value greater\n\t// than the protocol maximum.\n\tmaxRemoteHtlcs := uint16(input.MaxHTLCNumber / 2)\n\tif cfg.DefaultRemoteMaxHtlcs > maxRemoteHtlcs {\n\t\treturn nil, mkErr(\"default-remote-max-htlcs (%v) must be \"+\n\t\t\t\"less than %v\", cfg.DefaultRemoteMaxHtlcs,\n\t\t\tmaxRemoteHtlcs)\n\t}\n\n\t// Clamp the ChannelCommitInterval so that commitment updates can still\n\t// happen in a reasonable timeframe.\n\tif cfg.ChannelCommitInterval > maxChannelCommitInterval {\n\t\treturn nil, mkErr(\"channel-commit-interval (%v) must be less \"+\n\t\t\t\"than %v\", cfg.ChannelCommitInterval,\n\t\t\tmaxChannelCommitInterval)\n\t}\n\n\t// Limit PendingCommitInterval so we don't wait too long for the remote\n\t// party to send back a revoke.\n\tif cfg.PendingCommitInterval > maxPendingCommitInterval {\n\t\treturn nil, mkErr(\"pending-commit-interval (%v) must be less \"+\n\t\t\t\"than %v\", cfg.PendingCommitInterval,\n\t\t\tmaxPendingCommitInterval)\n\t}\n\n\tif err := cfg.Gossip.Parse(); err != nil {\n\t\treturn nil, mkErr(\"error parsing gossip syncer: %v\", err)\n\t}\n\n\t// Log a warning if our expiry delta is not greater than our incoming\n\t// broadcast delta. We do not fail here because this value may be set\n\t// to zero to intentionally keep lnd's behavior unchanged from when we\n\t// didn't auto-cancel these invoices.\n\tif cfg.Invoices.HoldExpiryDelta <= lncfg.DefaultIncomingBroadcastDelta {\n\t\tltndLog.Warnf(\"Invoice hold expiry delta: %v <= incoming \"+\n\t\t\t\"delta: %v, accepted hold invoices will force close \"+\n\t\t\t\"channels if they are not canceled manually\",\n\t\t\tcfg.Invoices.HoldExpiryDelta,\n\t\t\tlncfg.DefaultIncomingBroadcastDelta)\n\t}\n\n\t// If the experimental protocol options specify any protocol messages\n\t// that we want to handle as custom messages, set them now.\n\t//nolint:lll\n\tcustomMsg := cfg.ProtocolOptions.ExperimentalProtocol.CustomMessageOverrides()\n\n\t// We can safely set our custom override values during startup because\n\t// startup is blocked on config parsing.\n\tif err := lnwire.SetCustomOverrides(customMsg); err != nil {\n\t\treturn nil, mkErr(\"custom-message: %v\", err)\n\t}\n\n\t// Validate the subconfigs for workers, caches, and the tower client.\n\terr = lncfg.Validate(\n\t\tcfg.Workers,\n\t\tcfg.Caches,\n\t\tcfg.WtClient,\n\t\tcfg.DB,\n\t\tcfg.Cluster,\n\t\tcfg.HealthChecks,\n\t\tcfg.RPCMiddleware,\n\t\tcfg.RemoteSigner,\n\t\tcfg.Sweeper,\n\t\tcfg.Htlcswitch,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Finally, ensure that the user's color is correctly formatted,\n\t// otherwise the server will not be able to start after the unlocking\n\t// the wallet.\n\t_, err = lncfg.ParseHexColor(cfg.Color)\n\tif err != nil {\n\t\treturn nil, mkErr(\"unable to parse node color: %v\", err)\n\t}\n\n\t// All good, return the sanitized result.\n\treturn &cfg, nil\n}\n\n// graphDatabaseDir returns the default directory where the local bolt graph db\n// files are stored.",
      "length": 30162,
      "tokens": 3837,
      "embedding": []
    },
    {
      "slug": "func (c *Config) graphDatabaseDir() string {",
      "content": "func (c *Config) graphDatabaseDir() string {\n\treturn filepath.Join(\n\t\tc.DataDir, defaultGraphSubDirname,\n\t\tlncfg.NormalizeNetwork(c.ActiveNetParams.Name),\n\t)\n}\n\n// ImplementationConfig returns the configuration of what actual implementations\n// should be used when creating the main lnd instance.",
      "length": 244,
      "tokens": 26,
      "embedding": []
    },
    {
      "slug": "func (c *Config) ImplementationConfig(",
      "content": "func (c *Config) ImplementationConfig(\n\tinterceptor signal.Interceptor) *ImplementationCfg {\n\n\t// If we're using a remote signer, we still need the base wallet as a\n\t// watch-only source of chain and address data. But we don't need any\n\t// private key material in that btcwallet base wallet.\n\tif c.RemoteSigner.Enable {\n\t\trpcImpl := NewRPCSignerWalletImpl(\n\t\t\tc, ltndLog, interceptor,\n\t\t\tc.RemoteSigner.MigrateWatchOnly,\n\t\t)\n\t\treturn &ImplementationCfg{\n\t\t\tGrpcRegistrar:     rpcImpl,\n\t\t\tRestRegistrar:     rpcImpl,\n\t\t\tExternalValidator: rpcImpl,\n\t\t\tDatabaseBuilder: NewDefaultDatabaseBuilder(\n\t\t\t\tc, ltndLog,\n\t\t\t),\n\t\t\tWalletConfigBuilder: rpcImpl,\n\t\t\tChainControlBuilder: rpcImpl,\n\t\t}\n\t}\n\n\tdefaultImpl := NewDefaultWalletImpl(c, ltndLog, interceptor, false)\n\treturn &ImplementationCfg{\n\t\tGrpcRegistrar:       defaultImpl,\n\t\tRestRegistrar:       defaultImpl,\n\t\tExternalValidator:   defaultImpl,\n\t\tDatabaseBuilder:     NewDefaultDatabaseBuilder(c, ltndLog),\n\t\tWalletConfigBuilder: defaultImpl,\n\t\tChainControlBuilder: defaultImpl,\n\t}\n}\n\n// CleanAndExpandPath expands environment variables and leading ~ in the\n// passed path, cleans the result, and returns it.\n// This function is taken from https://github.com/btcsuite/btcd",
      "length": 1148,
      "tokens": 120,
      "embedding": []
    },
    {
      "slug": "func CleanAndExpandPath(path string) string {",
      "content": "func CleanAndExpandPath(path string) string {\n\tif path == \"\" {\n\t\treturn \"\"\n\t}\n\n\t// Expand initial ~ to OS specific home directory.\n\tif strings.HasPrefix(path, \"~\") {\n\t\tvar homeDir string\n\t\tu, err := user.Current()\n\t\tif err == nil {\n\t\t\thomeDir = u.HomeDir\n\t\t} else {\n\t\t\thomeDir = os.Getenv(\"HOME\")\n\t\t}\n\n\t\tpath = strings.Replace(path, \"~\", homeDir, 1)\n\t}\n\n\t// NOTE: The os.ExpandEnv doesn't work with Windows-style %VARIABLE%,\n\t// but the variables can still be expanded via POSIX-style $VARIABLE.\n\treturn filepath.Clean(os.ExpandEnv(path))\n}\n",
      "length": 474,
      "tokens": 73,
      "embedding": []
    },
    {
      "slug": "func parseRPCParams(cConfig *lncfg.Chain, nodeConfig interface{},",
      "content": "func parseRPCParams(cConfig *lncfg.Chain, nodeConfig interface{},\n\tnet chainreg.ChainCode, netParams chainreg.BitcoinNetParams) error {\n\n\t// First, we'll check our node config to make sure the RPC parameters\n\t// were set correctly. We'll also determine the path to the conf file\n\t// depending on the backend node.\n\tvar daemonName, confDir, confFile, confFileBase string\n\tswitch conf := nodeConfig.(type) {\n\tcase *lncfg.Btcd:\n\t\t// If both RPCUser and RPCPass are set, we assume those\n\t\t// credentials are good to use.\n\t\tif conf.RPCUser != \"\" && conf.RPCPass != \"\" {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Get the daemon name for displaying proper errors.\n\t\tswitch net {\n\t\tcase chainreg.BitcoinChain:\n\t\t\tdaemonName = \"btcd\"\n\t\t\tconfDir = conf.Dir\n\t\t\tconfFileBase = \"btcd\"\n\t\tcase chainreg.LitecoinChain:\n\t\t\tdaemonName = \"ltcd\"\n\t\t\tconfDir = conf.Dir\n\t\t\tconfFileBase = \"ltcd\"\n\t\t}\n\n\t\t// If only ONE of RPCUser or RPCPass is set, we assume the\n\t\t// user did that unintentionally.\n\t\tif conf.RPCUser != \"\" || conf.RPCPass != \"\" {\n\t\t\treturn fmt.Errorf(\"please set both or neither of \"+\n\t\t\t\t\"%[1]v.rpcuser, %[1]v.rpcpass\", daemonName)\n\t\t}\n\n\tcase *lncfg.Bitcoind:\n\t\t// Ensure that if the ZMQ options are set, that they are not\n\t\t// equal.\n\t\tif conf.ZMQPubRawBlock != \"\" && conf.ZMQPubRawTx != \"\" {\n\t\t\terr := checkZMQOptions(\n\t\t\t\tconf.ZMQPubRawBlock, conf.ZMQPubRawTx,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\t// Ensure that if the estimate mode is set, that it is a legal\n\t\t// value.\n\t\tif conf.EstimateMode != \"\" {\n\t\t\terr := checkEstimateMode(conf.EstimateMode)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\t// Get the daemon name for displaying proper errors.\n\t\tswitch net {\n\t\tcase chainreg.BitcoinChain:\n\t\t\tdaemonName = \"bitcoind\"\n\t\t\tconfDir = conf.Dir\n\t\t\tconfFile = conf.ConfigPath\n\t\t\tconfFileBase = \"bitcoin\"\n\t\tcase chainreg.LitecoinChain:\n\t\t\tdaemonName = \"litecoind\"\n\t\t\tconfDir = conf.Dir\n\t\t\tconfFile = conf.ConfigPath\n\t\t\tconfFileBase = \"litecoin\"\n\t\t}\n\n\t\t// Check that cookie and credentials don't contradict each\n\t\t// other.\n\t\tif (conf.RPCUser != \"\" || conf.RPCPass != \"\") &&\n\t\t\tconf.RPCCookie != \"\" {\n\n\t\t\treturn fmt.Errorf(\"please only provide either \"+\n\t\t\t\t\"%[1]v.rpccookie or %[1]v.rpcuser and \"+\n\t\t\t\t\"%[1]v.rpcpass\", daemonName)\n\t\t}\n\n\t\t// We convert the cookie into a user name and password.\n\t\tif conf.RPCCookie != \"\" {\n\t\t\tcookie, err := ioutil.ReadFile(conf.RPCCookie)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"cannot read cookie file: %w\",\n\t\t\t\t\terr)\n\t\t\t}\n\n\t\t\tsplitCookie := strings.Split(string(cookie), \":\")\n\t\t\tif len(splitCookie) != 2 {\n\t\t\t\treturn fmt.Errorf(\"cookie file has a wrong \" +\n\t\t\t\t\t\"format\")\n\t\t\t}\n\t\t\tconf.RPCUser = splitCookie[0]\n\t\t\tconf.RPCPass = splitCookie[1]\n\t\t}\n\n\t\tif conf.RPCUser != \"\" && conf.RPCPass != \"\" {\n\t\t\t// If all of RPCUser, RPCPass, ZMQBlockHost, and\n\t\t\t// ZMQTxHost are set, we assume those parameters are\n\t\t\t// good to use.\n\t\t\tif conf.ZMQPubRawBlock != \"\" && conf.ZMQPubRawTx != \"\" {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// If RPCUser and RPCPass are set and RPCPolling is\n\t\t\t// enabled, we assume the parameters are good to use.\n\t\t\tif conf.RPCPolling {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\n\t\t// If not all of the parameters are set, we'll assume the user\n\t\t// did this unintentionally.\n\t\tif conf.RPCUser != \"\" || conf.RPCPass != \"\" ||\n\t\t\tconf.ZMQPubRawBlock != \"\" || conf.ZMQPubRawTx != \"\" {\n\n\t\t\treturn fmt.Errorf(\"please set %[1]v.rpcuser and \"+\n\t\t\t\t\"%[1]v.rpcpass (or %[1]v.rpccookie) together \"+\n\t\t\t\t\"with %[1]v.zmqpubrawblock, %[1]v.zmqpubrawtx\",\n\t\t\t\tdaemonName)\n\t\t}\n\t}\n\n\t// If we're in simnet mode, then the running btcd instance won't read\n\t// the RPC credentials from the configuration. So if lnd wasn't\n\t// specified the parameters, then we won't be able to start.\n\tif cConfig.SimNet {\n\t\treturn fmt.Errorf(\"rpcuser and rpcpass must be set to your \" +\n\t\t\t\"btcd node's RPC parameters for simnet mode\")\n\t}\n\n\tfmt.Println(\"Attempting automatic RPC configuration to \" + daemonName)\n\n\tif confFile == \"\" {\n\t\tconfFile = filepath.Join(confDir, fmt.Sprintf(\"%v.conf\",\n\t\t\tconfFileBase))\n\t}\n\tswitch cConfig.Node {\n\tcase \"btcd\", \"ltcd\":\n\t\tnConf := nodeConfig.(*lncfg.Btcd)\n\t\trpcUser, rpcPass, err := extractBtcdRPCParams(confFile)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to extract RPC credentials: \"+\n\t\t\t\t\"%v, cannot start w/o RPC connection\", err)\n\t\t}\n\t\tnConf.RPCUser, nConf.RPCPass = rpcUser, rpcPass\n\n\tcase \"bitcoind\", \"litecoind\":\n\t\tnConf := nodeConfig.(*lncfg.Bitcoind)\n\t\trpcUser, rpcPass, zmqBlockHost, zmqTxHost, err :=\n\t\t\textractBitcoindRPCParams(netParams.Params.Name,\n\t\t\t\tnConf.Dir, confFile, nConf.RPCCookie)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to extract RPC credentials: \"+\n\t\t\t\t\"%v, cannot start w/o RPC connection\", err)\n\t\t}\n\t\tnConf.RPCUser, nConf.RPCPass = rpcUser, rpcPass\n\t\tnConf.ZMQPubRawBlock, nConf.ZMQPubRawTx = zmqBlockHost, zmqTxHost\n\t}\n\n\tfmt.Printf(\"Automatically obtained %v's RPC credentials\\n\", daemonName)\n\treturn nil\n}\n\n// extractBtcdRPCParams attempts to extract the RPC credentials for an existing\n// btcd instance. The passed path is expected to be the location of btcd's\n// application data directory on the target system.",
      "length": 4839,
      "tokens": 690,
      "embedding": []
    },
    {
      "slug": "func extractBtcdRPCParams(btcdConfigPath string) (string, string, error) {",
      "content": "func extractBtcdRPCParams(btcdConfigPath string) (string, string, error) {\n\t// First, we'll open up the btcd configuration file found at the target\n\t// destination.\n\tbtcdConfigFile, err := os.Open(btcdConfigPath)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tdefer func() { _ = btcdConfigFile.Close() }()\n\n\t// With the file open extract the contents of the configuration file so\n\t// we can attempt to locate the RPC credentials.\n\tconfigContents, err := ioutil.ReadAll(btcdConfigFile)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\t// Attempt to locate the RPC user using a regular expression. If we\n\t// don't have a match for our regular expression then we'll exit with\n\t// an error.\n\trpcUserRegexp, err := regexp.Compile(`(?m)^\\s*rpcuser\\s*=\\s*([^\\s]+)`)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tuserSubmatches := rpcUserRegexp.FindSubmatch(configContents)\n\tif userSubmatches == nil {\n\t\treturn \"\", \"\", fmt.Errorf(\"unable to find rpcuser in config\")\n\t}\n\n\t// Similarly, we'll use another regular expression to find the set\n\t// rpcpass (if any). If we can't find the pass, then we'll exit with an\n\t// error.\n\trpcPassRegexp, err := regexp.Compile(`(?m)^\\s*rpcpass\\s*=\\s*([^\\s]+)`)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tpassSubmatches := rpcPassRegexp.FindSubmatch(configContents)\n\tif passSubmatches == nil {\n\t\treturn \"\", \"\", fmt.Errorf(\"unable to find rpcuser in config\")\n\t}\n\n\treturn string(userSubmatches[1]), string(passSubmatches[1]), nil\n}\n\n// extractBitcoindRPCParams attempts to extract the RPC credentials for an\n// existing bitcoind node instance. The routine looks for a cookie first,\n// optionally following the datadir configuration option in the bitcoin.conf. If\n// it doesn't find one, it looks for rpcuser/rpcpassword.",
      "length": 1606,
      "tokens": 240,
      "embedding": []
    },
    {
      "slug": "func extractBitcoindRPCParams(networkName, bitcoindDataDir, bitcoindConfigPath,",
      "content": "func extractBitcoindRPCParams(networkName, bitcoindDataDir, bitcoindConfigPath,\n\trpcCookiePath string) (string, string, string, string, error) {\n\n\t// First, we'll open up the bitcoind configuration file found at the\n\t// target destination.\n\tbitcoindConfigFile, err := os.Open(bitcoindConfigPath)\n\tif err != nil {\n\t\treturn \"\", \"\", \"\", \"\", err\n\t}\n\tdefer func() { _ = bitcoindConfigFile.Close() }()\n\n\t// With the file open extract the contents of the configuration file so\n\t// we can attempt to locate the RPC credentials.\n\tconfigContents, err := ioutil.ReadAll(bitcoindConfigFile)\n\tif err != nil {\n\t\treturn \"\", \"\", \"\", \"\", err\n\t}\n\n\t// First, we'll look for the ZMQ hosts providing raw block and raw\n\t// transaction notifications.\n\tzmqBlockHostRE, err := regexp.Compile(\n\t\t`(?m)^\\s*zmqpubrawblock\\s*=\\s*([^\\s]+)`,\n\t)\n\tif err != nil {\n\t\treturn \"\", \"\", \"\", \"\", err\n\t}\n\tzmqBlockHostSubmatches := zmqBlockHostRE.FindSubmatch(configContents)\n\tif len(zmqBlockHostSubmatches) < 2 {\n\t\treturn \"\", \"\", \"\", \"\", fmt.Errorf(\"unable to find \" +\n\t\t\t\"zmqpubrawblock in config\")\n\t}\n\tzmqTxHostRE, err := regexp.Compile(`(?m)^\\s*zmqpubrawtx\\s*=\\s*([^\\s]+)`)\n\tif err != nil {\n\t\treturn \"\", \"\", \"\", \"\", err\n\t}\n\tzmqTxHostSubmatches := zmqTxHostRE.FindSubmatch(configContents)\n\tif len(zmqTxHostSubmatches) < 2 {\n\t\treturn \"\", \"\", \"\", \"\", errors.New(\"unable to find zmqpubrawtx \" +\n\t\t\t\"in config\")\n\t}\n\tzmqBlockHost := string(zmqBlockHostSubmatches[1])\n\tzmqTxHost := string(zmqTxHostSubmatches[1])\n\tif err := checkZMQOptions(zmqBlockHost, zmqTxHost); err != nil {\n\t\treturn \"\", \"\", \"\", \"\", err\n\t}\n\n\t// Next, we'll try to find an auth cookie. We need to detect the chain\n\t// by seeing if one is specified in the configuration file.\n\tdataDir := filepath.Dir(bitcoindConfigPath)\n\tif bitcoindDataDir != \"\" {\n\t\tdataDir = bitcoindDataDir\n\t}\n\tdataDirRE, err := regexp.Compile(`(?m)^\\s*datadir\\s*=\\s*([^\\s]+)`)\n\tif err != nil {\n\t\treturn \"\", \"\", \"\", \"\", err\n\t}\n\tdataDirSubmatches := dataDirRE.FindSubmatch(configContents)\n\tif dataDirSubmatches != nil {\n\t\tdataDir = string(dataDirSubmatches[1])\n\t}\n\n\tvar chainDir string\n\tswitch networkName {\n\tcase \"mainnet\":\n\t\tchainDir = \"\"\n\tcase \"regtest\", \"testnet3\", \"signet\":\n\t\tchainDir = networkName\n\tdefault:\n\t\treturn \"\", \"\", \"\", \"\", fmt.Errorf(\"unexpected networkname %v\", networkName)\n\t}\n\n\tcookiePath := filepath.Join(dataDir, chainDir, \".cookie\")\n\tif rpcCookiePath != \"\" {\n\t\tcookiePath = rpcCookiePath\n\t}\n\tcookie, err := ioutil.ReadFile(cookiePath)\n\tif err == nil {\n\t\tsplitCookie := strings.Split(string(cookie), \":\")\n\t\tif len(splitCookie) == 2 {\n\t\t\treturn splitCookie[0], splitCookie[1], zmqBlockHost,\n\t\t\t\tzmqTxHost, nil\n\t\t}\n\t}\n\n\t// We didn't find a cookie, so we attempt to locate the RPC user using\n\t// a regular expression. If we  don't have a match for our regular\n\t// expression then we'll exit with an error.\n\trpcUserRegexp, err := regexp.Compile(`(?m)^\\s*rpcuser\\s*=\\s*([^\\s]+)`)\n\tif err != nil {\n\t\treturn \"\", \"\", \"\", \"\", err\n\t}\n\tuserSubmatches := rpcUserRegexp.FindSubmatch(configContents)\n\n\t// Similarly, we'll use another regular expression to find the set\n\t// rpcpass (if any). If we can't find the pass, then we'll exit with an\n\t// error.\n\trpcPassRegexp, err := regexp.Compile(`(?m)^\\s*rpcpassword\\s*=\\s*([^\\s]+)`)\n\tif err != nil {\n\t\treturn \"\", \"\", \"\", \"\", err\n\t}\n\tpassSubmatches := rpcPassRegexp.FindSubmatch(configContents)\n\n\t// Exit with an error if the cookie file, is defined in config, and\n\t// can not be found, with both rpcuser and rpcpassword undefined.\n\tif rpcCookiePath != \"\" && userSubmatches == nil && passSubmatches == nil {\n\t\treturn \"\", \"\", \"\", \"\", fmt.Errorf(\"unable to open cookie file (%v)\",\n\t\t\trpcCookiePath)\n\t}\n\n\tif userSubmatches == nil {\n\t\treturn \"\", \"\", \"\", \"\", fmt.Errorf(\"unable to find rpcuser in \" +\n\t\t\t\"config\")\n\t}\n\tif passSubmatches == nil {\n\t\treturn \"\", \"\", \"\", \"\", fmt.Errorf(\"unable to find rpcpassword \" +\n\t\t\t\"in config\")\n\t}\n\n\treturn string(userSubmatches[1]), string(passSubmatches[1]),\n\t\tzmqBlockHost, zmqTxHost, nil\n}\n\n// checkZMQOptions ensures that the provided addresses to use as the hosts for\n// ZMQ rawblock and rawtx notifications are different.",
      "length": 3901,
      "tokens": 554,
      "embedding": []
    },
    {
      "slug": "func checkZMQOptions(zmqBlockHost, zmqTxHost string) error {",
      "content": "func checkZMQOptions(zmqBlockHost, zmqTxHost string) error {\n\tif zmqBlockHost == zmqTxHost {\n\t\treturn errors.New(\"zmqpubrawblock and zmqpubrawtx must be set \" +\n\t\t\t\"to different addresses\")\n\t}\n\n\treturn nil\n}\n\n// checkEstimateMode ensures that the provided estimate mode is legal.",
      "length": 210,
      "tokens": 31,
      "embedding": []
    },
    {
      "slug": "func checkEstimateMode(estimateMode string) error {",
      "content": "func checkEstimateMode(estimateMode string) error {\n\tfor _, mode := range bitcoindEstimateModes {\n\t\tif estimateMode == mode {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn fmt.Errorf(\"estimatemode must be one of the following: %v\",\n\t\tbitcoindEstimateModes[:])\n}\n",
      "length": 185,
      "tokens": 27,
      "embedding": []
    }
  ]
}