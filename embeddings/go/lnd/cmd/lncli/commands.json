{
  "filepath": "../implementations/go/lnd/cmd/lncli/commands.go",
  "package": "main",
  "sections": [
    {
      "slug": "func getContext() context.Context {",
      "content": "func getContext() context.Context {\n\tshutdownInterceptor, err := signal.Intercept()\n\tif err != nil {\n\t\t_, _ = fmt.Fprintln(os.Stderr, err)\n\t\tos.Exit(1)\n\t}\n\n\tctxc, cancel := context.WithCancel(context.Background())\n\tgo func() {\n\t\t<-shutdownInterceptor.ShutdownChannel()\n\t\tcancel()\n\t}()\n\treturn ctxc\n}\n",
      "length": 251,
      "tokens": 29,
      "embedding": []
    },
    {
      "slug": "func printJSON(resp interface{}) {",
      "content": "func printJSON(resp interface{}) {\n\tb, err := json.Marshal(resp)\n\tif err != nil {\n\t\tfatal(err)\n\t}\n\n\tvar out bytes.Buffer\n\tjson.Indent(&out, b, \"\", \"\\t\")\n\tout.WriteString(\"\\n\")\n\tout.WriteTo(os.Stdout)\n}\n",
      "length": 157,
      "tokens": 21,
      "embedding": []
    },
    {
      "slug": "func printRespJSON(resp proto.Message) {",
      "content": "func printRespJSON(resp proto.Message) {\n\tjsonMarshaler := &jsonpb.Marshaler{\n\t\tEmitDefaults: true,\n\t\tOrigName:     true,\n\t\tIndent:       \"    \",\n\t}\n\n\tjsonStr, err := jsonMarshaler.MarshalToString(resp)\n\tif err != nil {\n\t\tfmt.Println(\"unable to decode response: \", err)\n\t\treturn\n\t}\n\n\tfmt.Println(jsonStr)\n}\n\n// actionDecorator is used to add additional information and error handling\n// to command actions.",
      "length": 349,
      "tokens": 45,
      "embedding": []
    },
    {
      "slug": "func actionDecorator(f func(*cli.Context) error) func(*cli.Context) error {",
      "content": "func actionDecorator(f func(*cli.Context) error) func(*cli.Context) error {\n\treturn func(c *cli.Context) error {\n\t\tif err := f(c); err != nil {\n\t\t\ts, ok := status.FromError(err)\n\n\t\t\t// If it's a command for the UnlockerService (like\n\t\t\t// 'create' or 'unlock') but the wallet is already\n\t\t\t// unlocked, then these methods aren't recognized any\n\t\t\t// more because this service is shut down after\n\t\t\t// successful unlock. That's why the code\n\t\t\t// 'Unimplemented' means something different for these\n\t\t\t// two commands.\n\t\t\tif s.Code() == codes.Unimplemented &&\n\t\t\t\t(c.Command.Name == \"create\" ||\n\t\t\t\t\tc.Command.Name == \"unlock\" ||\n\t\t\t\t\tc.Command.Name == \"changepassword\" ||\n\t\t\t\t\tc.Command.Name == \"createwatchonly\") {\n\n\t\t\t\treturn fmt.Errorf(\"Wallet is already unlocked\")\n\t\t\t}\n\n\t\t\t// lnd might be active, but not possible to contact\n\t\t\t// using RPC if the wallet is encrypted. If we get\n\t\t\t// error code Unimplemented, it means that lnd is\n\t\t\t// running, but the RPC server is not active yet (only\n\t\t\t// WalletUnlocker server active) and most likely this\n\t\t\t// is because of an encrypted wallet.\n\t\t\tif ok && s.Code() == codes.Unimplemented {\n\t\t\t\treturn fmt.Errorf(\"Wallet is encrypted. \" +\n\t\t\t\t\t\"Please unlock using 'lncli unlock', \" +\n\t\t\t\t\t\"or set password using 'lncli create'\" +\n\t\t\t\t\t\" if this is the first time starting \" +\n\t\t\t\t\t\"lnd.\")\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}\n}\n\nvar newAddressCommand = cli.Command{\n\tName:      \"newaddress\",\n\tCategory:  \"Wallet\",\n\tUsage:     \"Generates a new address.\",\n\tArgsUsage: \"address-type\",\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName: \"account\",\n\t\t\tUsage: \"(optional) the name of the account to \" +\n\t\t\t\t\"generate a new address for\",\n\t\t},\n\t},\n\tDescription: `\n\tGenerate a wallet new address. Address-types has to be one of:\n\t    - p2wkh:  Pay to witness key hash\n\t    - np2wkh: Pay to nested witness key hash\n\t    - p2tr:   Pay to taproot pubkey`,\n\tAction: actionDecorator(newAddress),\n}\n",
      "length": 1797,
      "tokens": 272,
      "embedding": []
    },
    {
      "slug": "func newAddress(ctx *cli.Context) error {",
      "content": "func newAddress(ctx *cli.Context) error {\n\tctxc := getContext()\n\n\t// Display the command's help message if we do not have the expected\n\t// number of arguments/flags.\n\tif ctx.NArg() != 1 || ctx.NumFlags() > 1 {\n\t\treturn cli.ShowCommandHelp(ctx, \"newaddress\")\n\t}\n\n\t// Map the string encoded address type, to the concrete typed address\n\t// type enum. An unrecognized address type will result in an error.\n\tstringAddrType := ctx.Args().First()\n\tvar addrType lnrpc.AddressType\n\tswitch stringAddrType { // TODO(roasbeef): make them ints on the cli?\n\tcase \"p2wkh\":\n\t\taddrType = lnrpc.AddressType_WITNESS_PUBKEY_HASH\n\tcase \"np2wkh\":\n\t\taddrType = lnrpc.AddressType_NESTED_PUBKEY_HASH\n\tcase \"p2tr\":\n\t\taddrType = lnrpc.AddressType_TAPROOT_PUBKEY\n\tdefault:\n\t\treturn fmt.Errorf(\"invalid address type %v, support address type \"+\n\t\t\t\"are: p2wkh, np2wkh, and p2tr\", stringAddrType)\n\t}\n\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\taddr, err := client.NewAddress(ctxc, &lnrpc.NewAddressRequest{\n\t\tType:    addrType,\n\t\tAccount: ctx.String(\"account\"),\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(addr)\n\treturn nil\n}\n\nvar estimateFeeCommand = cli.Command{\n\tName:      \"estimatefee\",\n\tCategory:  \"On-chain\",\n\tUsage:     \"Get fee estimates for sending bitcoin on-chain to multiple addresses.\",\n\tArgsUsage: \"send-json-string [--conf_target=N]\",\n\tDescription: `\n\tGet fee estimates for sending a transaction paying the specified amount(s) to the passed address(es).\n\n\tThe send-json-string' param decodes addresses and the amount to send respectively in the following format:\n\n\t    '{\"ExampleAddr\": NumCoinsInSatoshis, \"SecondAddr\": NumCoins}'\n\t`,\n\tFlags: []cli.Flag{\n\t\tcli.Int64Flag{\n\t\t\tName: \"conf_target\",\n\t\t\tUsage: \"(optional) the number of blocks that the transaction *should* \" +\n\t\t\t\t\"confirm in\",\n\t\t},\n\t},\n\tAction: actionDecorator(estimateFees),\n}\n",
      "length": 1745,
      "tokens": 217,
      "embedding": []
    },
    {
      "slug": "func estimateFees(ctx *cli.Context) error {",
      "content": "func estimateFees(ctx *cli.Context) error {\n\tctxc := getContext()\n\tvar amountToAddr map[string]int64\n\n\tjsonMap := ctx.Args().First()\n\tif err := json.Unmarshal([]byte(jsonMap), &amountToAddr); err != nil {\n\t\treturn err\n\t}\n\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\tresp, err := client.EstimateFee(ctxc, &lnrpc.EstimateFeeRequest{\n\t\tAddrToAmount: amountToAddr,\n\t\tTargetConf:   int32(ctx.Int64(\"conf_target\")),\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(resp)\n\treturn nil\n}\n\nvar txLabelFlag = cli.StringFlag{\n\tName:  \"label\",\n\tUsage: \"(optional) a label for the transaction\",\n}\n\nvar sendCoinsCommand = cli.Command{\n\tName:      \"sendcoins\",\n\tCategory:  \"On-chain\",\n\tUsage:     \"Send bitcoin on-chain to an address.\",\n\tArgsUsage: \"addr amt\",\n\tDescription: `\n\tSend amt coins in satoshis to the base58 or bech32 encoded bitcoin address addr.\n\n\tFees used when sending the transaction can be specified via the --conf_target, or\n\t--sat_per_vbyte optional flags.\n\n\tPositional arguments and flags can be used interchangeably but not at the same time!\n\t`,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName: \"addr\",\n\t\t\tUsage: \"the base58 or bech32 encoded bitcoin address to send coins \" +\n\t\t\t\t\"to on-chain\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName: \"sweepall\",\n\t\t\tUsage: \"if set, then the amount field will be ignored, \" +\n\t\t\t\t\"and the wallet will attempt to sweep all \" +\n\t\t\t\t\"outputs within the wallet to the target \" +\n\t\t\t\t\"address\",\n\t\t},\n\t\tcli.Int64Flag{\n\t\t\tName:  \"amt\",\n\t\t\tUsage: \"the number of bitcoin denominated in satoshis to send\",\n\t\t},\n\t\tcli.Int64Flag{\n\t\t\tName: \"conf_target\",\n\t\t\tUsage: \"(optional) the number of blocks that the \" +\n\t\t\t\t\"transaction *should* confirm in, will be \" +\n\t\t\t\t\"used for fee estimation\",\n\t\t},\n\t\tcli.Int64Flag{\n\t\t\tName:   \"sat_per_byte\",\n\t\t\tUsage:  \"Deprecated, use sat_per_vbyte instead.\",\n\t\t\tHidden: true,\n\t\t},\n\t\tcli.Int64Flag{\n\t\t\tName: \"sat_per_vbyte\",\n\t\t\tUsage: \"(optional) a manual fee expressed in \" +\n\t\t\t\t\"sat/vbyte that should be used when crafting \" +\n\t\t\t\t\"the transaction\",\n\t\t},\n\t\tcli.Uint64Flag{\n\t\t\tName: \"min_confs\",\n\t\t\tUsage: \"(optional) the minimum number of confirmations \" +\n\t\t\t\t\"each one of your outputs used for the transaction \" +\n\t\t\t\t\"must satisfy\",\n\t\t\tValue: defaultUtxoMinConf,\n\t\t},\n\t\ttxLabelFlag,\n\t},\n\tAction: actionDecorator(sendCoins),\n}\n",
      "length": 2164,
      "tokens": 293,
      "embedding": []
    },
    {
      "slug": "func sendCoins(ctx *cli.Context) error {",
      "content": "func sendCoins(ctx *cli.Context) error {\n\tvar (\n\t\taddr string\n\t\tamt  int64\n\t\terr  error\n\t)\n\tctxc := getContext()\n\targs := ctx.Args()\n\n\tif ctx.NArg() == 0 && ctx.NumFlags() == 0 {\n\t\tcli.ShowCommandHelp(ctx, \"sendcoins\")\n\t\treturn nil\n\t}\n\n\t// Check that only the field sat_per_vbyte or the deprecated field\n\t// sat_per_byte is used.\n\tfeeRateFlag, err := checkNotBothSet(\n\t\tctx, \"sat_per_vbyte\", \"sat_per_byte\",\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Only fee rate flag or conf_target should be set, not both.\n\tif _, err := checkNotBothSet(\n\t\tctx, feeRateFlag, \"conf_target\",\n\t); err != nil {\n\t\treturn err\n\t}\n\n\tswitch {\n\tcase ctx.IsSet(\"addr\"):\n\t\taddr = ctx.String(\"addr\")\n\tcase args.Present():\n\t\taddr = args.First()\n\t\targs = args.Tail()\n\tdefault:\n\t\treturn fmt.Errorf(\"Address argument missing\")\n\t}\n\n\tswitch {\n\tcase ctx.IsSet(\"amt\"):\n\t\tamt = ctx.Int64(\"amt\")\n\tcase args.Present():\n\t\tamt, err = strconv.ParseInt(args.First(), 10, 64)\n\tcase !ctx.Bool(\"sweepall\"):\n\t\treturn fmt.Errorf(\"Amount argument missing\")\n\t}\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to decode amount: %v\", err)\n\t}\n\n\tif amt != 0 && ctx.Bool(\"sweepall\") {\n\t\treturn fmt.Errorf(\"amount cannot be set if attempting to \" +\n\t\t\t\"sweep all coins out of the wallet\")\n\t}\n\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\tminConfs := int32(ctx.Uint64(\"min_confs\"))\n\treq := &lnrpc.SendCoinsRequest{\n\t\tAddr:             addr,\n\t\tAmount:           amt,\n\t\tTargetConf:       int32(ctx.Int64(\"conf_target\")),\n\t\tSatPerVbyte:      ctx.Uint64(feeRateFlag),\n\t\tSendAll:          ctx.Bool(\"sweepall\"),\n\t\tLabel:            ctx.String(txLabelFlag.Name),\n\t\tMinConfs:         minConfs,\n\t\tSpendUnconfirmed: minConfs == 0,\n\t}\n\ttxid, err := client.SendCoins(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(txid)\n\treturn nil\n}\n\nvar listUnspentCommand = cli.Command{\n\tName:      \"listunspent\",\n\tCategory:  \"On-chain\",\n\tUsage:     \"List utxos available for spending.\",\n\tArgsUsage: \"[min-confs [max-confs]] [--unconfirmed_only]\",\n\tDescription: `\n\tFor each spendable utxo currently in the wallet, with at least min_confs\n\tconfirmations, and at most max_confs confirmations, lists the txid,\n\tindex, amount, address, address type, scriptPubkey and number of\n\tconfirmations.  Use --min_confs=0 to include unconfirmed coins. To list\n\tall coins with at least min_confs confirmations, omit the second\n\targument or flag '--max_confs'. To list all confirmed and unconfirmed\n\tcoins, no arguments are required. To see only unconfirmed coins, use\n\t'--unconfirmed_only' with '--min_confs' and '--max_confs' set to zero or\n\tnot present.\n\t`,\n\tFlags: []cli.Flag{\n\t\tcli.Int64Flag{\n\t\t\tName:  \"min_confs\",\n\t\t\tUsage: \"the minimum number of confirmations for a utxo\",\n\t\t},\n\t\tcli.Int64Flag{\n\t\t\tName:  \"max_confs\",\n\t\t\tUsage: \"the maximum number of confirmations for a utxo\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName: \"unconfirmed_only\",\n\t\t\tUsage: \"when min_confs and max_confs are zero, \" +\n\t\t\t\t\"setting false implicitly overrides max_confs \" +\n\t\t\t\t\"to be MaxInt32, otherwise max_confs remains \" +\n\t\t\t\t\"zero. An error is returned if the value is \" +\n\t\t\t\t\"true and both min_confs and max_confs are \" +\n\t\t\t\t\"non-zero. (default: false)\",\n\t\t},\n\t},\n\tAction: actionDecorator(listUnspent),\n}\n",
      "length": 3046,
      "tokens": 402,
      "embedding": []
    },
    {
      "slug": "func listUnspent(ctx *cli.Context) error {",
      "content": "func listUnspent(ctx *cli.Context) error {\n\tvar (\n\t\tminConfirms int64\n\t\tmaxConfirms int64\n\t\terr         error\n\t)\n\tctxc := getContext()\n\targs := ctx.Args()\n\n\tif ctx.IsSet(\"max_confs\") && !ctx.IsSet(\"min_confs\") {\n\t\treturn fmt.Errorf(\"max_confs cannot be set without \" +\n\t\t\t\"min_confs being set\")\n\t}\n\n\tswitch {\n\tcase ctx.IsSet(\"min_confs\"):\n\t\tminConfirms = ctx.Int64(\"min_confs\")\n\tcase args.Present():\n\t\tminConfirms, err = strconv.ParseInt(args.First(), 10, 64)\n\t\tif err != nil {\n\t\t\tcli.ShowCommandHelp(ctx, \"listunspent\")\n\t\t\treturn nil\n\t\t}\n\t\targs = args.Tail()\n\t}\n\n\tswitch {\n\tcase ctx.IsSet(\"max_confs\"):\n\t\tmaxConfirms = ctx.Int64(\"max_confs\")\n\tcase args.Present():\n\t\tmaxConfirms, err = strconv.ParseInt(args.First(), 10, 64)\n\t\tif err != nil {\n\t\t\tcli.ShowCommandHelp(ctx, \"listunspent\")\n\t\t\treturn nil\n\t\t}\n\t\targs = args.Tail()\n\t}\n\n\tunconfirmedOnly := ctx.Bool(\"unconfirmed_only\")\n\n\t// Force minConfirms and maxConfirms to be zero if unconfirmedOnly is\n\t// true.\n\tif unconfirmedOnly && (minConfirms != 0 || maxConfirms != 0) {\n\t\tcli.ShowCommandHelp(ctx, \"listunspent\")\n\t\treturn nil\n\t}\n\n\t// When unconfirmedOnly is inactive, we will override maxConfirms to be\n\t// a MaxInt32 to return all confirmed and unconfirmed utxos.\n\tif maxConfirms == 0 && !unconfirmedOnly {\n\t\tmaxConfirms = math.MaxInt32\n\t}\n\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\treq := &lnrpc.ListUnspentRequest{\n\t\tMinConfs: int32(minConfirms),\n\t\tMaxConfs: int32(maxConfirms),\n\t}\n\tresp, err := client.ListUnspent(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Parse the response into the final json object that will be printed\n\t// to stdout. At the moment, this filters out the raw txid bytes from\n\t// each utxo's outpoint and only prints the txid string.\n\tvar listUnspentResp = struct {\n\t\tUtxos []*Utxo `json:\"utxos\"`\n\t}{\n\t\tUtxos: make([]*Utxo, 0, len(resp.Utxos)),\n\t}\n\tfor _, protoUtxo := range resp.Utxos {\n\t\tutxo := NewUtxoFromProto(protoUtxo)\n\t\tlistUnspentResp.Utxos = append(listUnspentResp.Utxos, utxo)\n\t}\n\n\tprintJSON(listUnspentResp)\n\n\treturn nil\n}\n\nvar sendManyCommand = cli.Command{\n\tName:      \"sendmany\",\n\tCategory:  \"On-chain\",\n\tUsage:     \"Send bitcoin on-chain to multiple addresses.\",\n\tArgsUsage: \"send-json-string [--conf_target=N] [--sat_per_vbyte=P]\",\n\tDescription: `\n\tCreate and broadcast a transaction paying the specified amount(s) to the passed address(es).\n\n\tThe send-json-string' param decodes addresses and the amount to send\n\trespectively in the following format:\n\n\t    '{\"ExampleAddr\": NumCoinsInSatoshis, \"SecondAddr\": NumCoins}'\n\t`,\n\tFlags: []cli.Flag{\n\t\tcli.Int64Flag{\n\t\t\tName: \"conf_target\",\n\t\t\tUsage: \"(optional) the number of blocks that the transaction *should* \" +\n\t\t\t\t\"confirm in, will be used for fee estimation\",\n\t\t},\n\t\tcli.Int64Flag{\n\t\t\tName:   \"sat_per_byte\",\n\t\t\tUsage:  \"Deprecated, use sat_per_vbyte instead.\",\n\t\t\tHidden: true,\n\t\t},\n\t\tcli.Int64Flag{\n\t\t\tName: \"sat_per_vbyte\",\n\t\t\tUsage: \"(optional) a manual fee expressed in \" +\n\t\t\t\t\"sat/vbyte that should be used when crafting \" +\n\t\t\t\t\"the transaction\",\n\t\t},\n\t\tcli.Uint64Flag{\n\t\t\tName: \"min_confs\",\n\t\t\tUsage: \"(optional) the minimum number of confirmations \" +\n\t\t\t\t\"each one of your outputs used for the transaction \" +\n\t\t\t\t\"must satisfy\",\n\t\t\tValue: defaultUtxoMinConf,\n\t\t},\n\t\ttxLabelFlag,\n\t},\n\tAction: actionDecorator(sendMany),\n}\n",
      "length": 3131,
      "tokens": 399,
      "embedding": []
    },
    {
      "slug": "func sendMany(ctx *cli.Context) error {",
      "content": "func sendMany(ctx *cli.Context) error {\n\tctxc := getContext()\n\tvar amountToAddr map[string]int64\n\n\tjsonMap := ctx.Args().First()\n\tif err := json.Unmarshal([]byte(jsonMap), &amountToAddr); err != nil {\n\t\treturn err\n\t}\n\n\t// Check that only the field sat_per_vbyte or the deprecated field\n\t// sat_per_byte is used.\n\tfeeRateFlag, err := checkNotBothSet(\n\t\tctx, \"sat_per_vbyte\", \"sat_per_byte\",\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Only fee rate flag or conf_target should be set, not both.\n\tif _, err := checkNotBothSet(\n\t\tctx, feeRateFlag, \"conf_target\",\n\t); err != nil {\n\t\treturn err\n\t}\n\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\tminConfs := int32(ctx.Uint64(\"min_confs\"))\n\ttxid, err := client.SendMany(ctxc, &lnrpc.SendManyRequest{\n\t\tAddrToAmount:     amountToAddr,\n\t\tTargetConf:       int32(ctx.Int64(\"conf_target\")),\n\t\tSatPerVbyte:      ctx.Uint64(feeRateFlag),\n\t\tLabel:            ctx.String(txLabelFlag.Name),\n\t\tMinConfs:         minConfs,\n\t\tSpendUnconfirmed: minConfs == 0,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(txid)\n\treturn nil\n}\n\nvar connectCommand = cli.Command{\n\tName:      \"connect\",\n\tCategory:  \"Peers\",\n\tUsage:     \"Connect to a remote lnd peer.\",\n\tArgsUsage: \"<pubkey>@host\",\n\tDescription: `\n\tConnect to a peer using its <pubkey> and host.\n\n\tA custom timeout on the connection is supported. For instance, to timeout\n\tthe connection request in 30 seconds, use the following:\n\n\tlncli connect <pubkey>@host --timeout 30s\n\t`,\n\tFlags: []cli.Flag{\n\t\tcli.BoolFlag{\n\t\t\tName: \"perm\",\n\t\t\tUsage: \"If set, the daemon will attempt to persistently \" +\n\t\t\t\t\"connect to the target peer.\\n\" +\n\t\t\t\t\"           If not, the call will be synchronous.\",\n\t\t},\n\t\tcli.DurationFlag{\n\t\t\tName: \"timeout\",\n\t\t\tUsage: \"The connection timeout value for current request. \" +\n\t\t\t\t\"Valid uints are {ms, s, m, h}.\\n\" +\n\t\t\t\t\"If not set, the global connection \" +\n\t\t\t\t\"timeout value (default to 120s) is used.\",\n\t\t},\n\t},\n\tAction: actionDecorator(connectPeer),\n}\n",
      "length": 1854,
      "tokens": 248,
      "embedding": []
    },
    {
      "slug": "func connectPeer(ctx *cli.Context) error {",
      "content": "func connectPeer(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\ttargetAddress := ctx.Args().First()\n\tsplitAddr := strings.Split(targetAddress, \"@\")\n\tif len(splitAddr) != 2 {\n\t\treturn fmt.Errorf(\"target address expected in format: \" +\n\t\t\t\"pubkey@host:port\")\n\t}\n\n\taddr := &lnrpc.LightningAddress{\n\t\tPubkey: splitAddr[0],\n\t\tHost:   splitAddr[1],\n\t}\n\treq := &lnrpc.ConnectPeerRequest{\n\t\tAddr:    addr,\n\t\tPerm:    ctx.Bool(\"perm\"),\n\t\tTimeout: uint64(ctx.Duration(\"timeout\").Seconds()),\n\t}\n\n\tlnid, err := client.ConnectPeer(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(lnid)\n\treturn nil\n}\n\nvar disconnectCommand = cli.Command{\n\tName:      \"disconnect\",\n\tCategory:  \"Peers\",\n\tUsage:     \"Disconnect a remote lnd peer identified by public key.\",\n\tArgsUsage: \"<pubkey>\",\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName: \"node_key\",\n\t\t\tUsage: \"The hex-encoded compressed public key of the peer \" +\n\t\t\t\t\"to disconnect from\",\n\t\t},\n\t},\n\tAction: actionDecorator(disconnectPeer),\n}\n",
      "length": 948,
      "tokens": 110,
      "embedding": []
    },
    {
      "slug": "func disconnectPeer(ctx *cli.Context) error {",
      "content": "func disconnectPeer(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\tvar pubKey string\n\tswitch {\n\tcase ctx.IsSet(\"node_key\"):\n\t\tpubKey = ctx.String(\"node_key\")\n\tcase ctx.Args().Present():\n\t\tpubKey = ctx.Args().First()\n\tdefault:\n\t\treturn fmt.Errorf(\"must specify target public key\")\n\t}\n\n\treq := &lnrpc.DisconnectPeerRequest{\n\t\tPubKey: pubKey,\n\t}\n\n\tlnid, err := client.DisconnectPeer(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(lnid)\n\treturn nil\n}\n\n// TODO(roasbeef): also allow short relative channel ID.\n\nvar closeChannelCommand = cli.Command{\n\tName:     \"closechannel\",\n\tCategory: \"Channels\",\n\tUsage:    \"Close an existing channel.\",\n\tDescription: `\n\tClose an existing channel. The channel can be closed either cooperatively,\n\tor unilaterally (--force).\n\n\tA unilateral channel closure means that the latest commitment\n\ttransaction will be broadcast to the network. As a result, any settled\n\tfunds will be time locked for a few blocks before they can be spent.\n\n\tIn the case of a cooperative closure, one can manually set the fee to\n\tbe used for the closing transaction via either the --conf_target or\n\t--sat_per_vbyte arguments. This will be the starting value used during\n\tfee negotiation. This is optional.\n\n\tIn the case of a cooperative closure, one can manually set the address\n\tto deliver funds to upon closure. This is optional, and may only be used\n\tif an upfront shutdown address has not already been set. If neither are\n\tset the funds will be delivered to a new wallet address.\n\n\tTo view which funding_txids/output_indexes can be used for a channel close,\n\tsee the channel_point values within the listchannels command output.\n\tThe format for a channel_point is 'funding_txid:output_index'.`,\n\tArgsUsage: \"funding_txid [output_index]\",\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName:  \"funding_txid\",\n\t\t\tUsage: \"the txid of the channel's funding transaction\",\n\t\t},\n\t\tcli.IntFlag{\n\t\t\tName: \"output_index\",\n\t\t\tUsage: \"the output index for the funding output of the funding \" +\n\t\t\t\t\"transaction\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName: \"chan_point\",\n\t\t\tUsage: \"(optional) the channel point. If set, \" +\n\t\t\t\t\"funding_txid and output_index flags and \" +\n\t\t\t\t\"positional arguments will be ignored\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"force\",\n\t\t\tUsage: \"attempt an uncooperative closure\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"block\",\n\t\t\tUsage: \"block until the channel is closed\",\n\t\t},\n\t\tcli.Int64Flag{\n\t\t\tName: \"conf_target\",\n\t\t\tUsage: \"(optional) the number of blocks that the \" +\n\t\t\t\t\"transaction *should* confirm in, will be \" +\n\t\t\t\t\"used for fee estimation. If not set, \" +\n\t\t\t\t\"then the conf-target value set in the main \" +\n\t\t\t\t\"lnd config will be used.\",\n\t\t},\n\t\tcli.Int64Flag{\n\t\t\tName:   \"sat_per_byte\",\n\t\t\tUsage:  \"Deprecated, use sat_per_vbyte instead.\",\n\t\t\tHidden: true,\n\t\t},\n\t\tcli.Int64Flag{\n\t\t\tName: \"sat_per_vbyte\",\n\t\t\tUsage: \"(optional) a manual fee expressed in \" +\n\t\t\t\t\"sat/vbyte that should be used when crafting \" +\n\t\t\t\t\"the transaction\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName: \"delivery_addr\",\n\t\t\tUsage: \"(optional) an address to deliver funds \" +\n\t\t\t\t\"upon cooperative channel closing, may only \" +\n\t\t\t\t\"be used if an upfront shutdown address is not \" +\n\t\t\t\t\"already set\",\n\t\t},\n\t},\n\tAction: actionDecorator(closeChannel),\n}\n",
      "length": 3139,
      "tokens": 444,
      "embedding": []
    },
    {
      "slug": "func closeChannel(ctx *cli.Context) error {",
      "content": "func closeChannel(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\t// Show command help if no arguments and flags were provided.\n\tif ctx.NArg() == 0 && ctx.NumFlags() == 0 {\n\t\tcli.ShowCommandHelp(ctx, \"closechannel\")\n\t\treturn nil\n\t}\n\n\t// Check that only the field sat_per_vbyte or the deprecated field\n\t// sat_per_byte is used.\n\tfeeRateFlag, err := checkNotBothSet(\n\t\tctx, \"sat_per_vbyte\", \"sat_per_byte\",\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tchannelPoint, err := parseChannelPoint(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// TODO(roasbeef): implement time deadline within server\n\treq := &lnrpc.CloseChannelRequest{\n\t\tChannelPoint:    channelPoint,\n\t\tForce:           ctx.Bool(\"force\"),\n\t\tTargetConf:      int32(ctx.Int64(\"conf_target\")),\n\t\tSatPerVbyte:     ctx.Uint64(feeRateFlag),\n\t\tDeliveryAddress: ctx.String(\"delivery_addr\"),\n\t}\n\n\t// After parsing the request, we'll spin up a goroutine that will\n\t// retrieve the closing transaction ID when attempting to close the\n\t// channel. We do this to because `executeChannelClose` can block, so we\n\t// would like to present the closing transaction ID to the user as soon\n\t// as it is broadcasted.\n\tvar wg sync.WaitGroup\n\ttxidChan := make(chan string, 1)\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\n\t\tprintJSON(struct {\n\t\t\tClosingTxid string `json:\"closing_txid\"`\n\t\t}{\n\t\t\tClosingTxid: <-txidChan,\n\t\t})\n\t}()\n\n\terr = executeChannelClose(ctxc, client, req, txidChan, ctx.Bool(\"block\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// In the case that the user did not provide the `block` flag, then we\n\t// need to wait for the goroutine to be done to prevent it from being\n\t// destroyed when exiting before printing the closing transaction ID.\n\twg.Wait()\n\n\treturn nil\n}\n\n// executeChannelClose attempts to close the channel from a request. The closing\n// transaction ID is sent through `txidChan` as soon as it is broadcasted to the\n// network. The block boolean is used to determine if we should block until the\n// closing transaction receives all of its required confirmations.",
      "length": 1953,
      "tokens": 286,
      "embedding": []
    },
    {
      "slug": "func executeChannelClose(ctxc context.Context, client lnrpc.LightningClient,",
      "content": "func executeChannelClose(ctxc context.Context, client lnrpc.LightningClient,\n\treq *lnrpc.CloseChannelRequest, txidChan chan<- string, block bool) error {\n\n\tstream, err := client.CloseChannel(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor {\n\t\tresp, err := stream.Recv()\n\t\tif err == io.EOF {\n\t\t\treturn nil\n\t\t} else if err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tswitch update := resp.Update.(type) {\n\t\tcase *lnrpc.CloseStatusUpdate_ClosePending:\n\t\t\tclosingHash := update.ClosePending.Txid\n\t\t\ttxid, err := chainhash.NewHash(closingHash)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\ttxidChan <- txid.String()\n\n\t\t\tif !block {\n\t\t\t\treturn nil\n\t\t\t}\n\t\tcase *lnrpc.CloseStatusUpdate_ChanClose:\n\t\t\treturn nil\n\t\t}\n\t}\n}\n\nvar closeAllChannelsCommand = cli.Command{\n\tName:     \"closeallchannels\",\n\tCategory: \"Channels\",\n\tUsage:    \"Close all existing channels.\",\n\tDescription: `\n\tClose all existing channels.\n\n\tChannels will be closed either cooperatively or unilaterally, depending\n\ton whether the channel is active or not. If the channel is inactive, any\n\tsettled funds within it will be time locked for a few blocks before they\n\tcan be spent.\n\n\tOne can request to close inactive channels only by using the\n\t--inactive_only flag.\n\n\tBy default, one is prompted for confirmation every time an inactive\n\tchannel is requested to be closed. To avoid this, one can set the\n\t--force flag, which will only prompt for confirmation once for all\n\tinactive channels and proceed to close them.\n\n\tIn the case of cooperative closures, one can manually set the fee to\n\tbe used for the closing transactions via either the --conf_target or\n\t--sat_per_vbyte arguments. This will be the starting value used during\n\tfee negotiation. This is optional.`,\n\tFlags: []cli.Flag{\n\t\tcli.BoolFlag{\n\t\t\tName:  \"inactive_only\",\n\t\t\tUsage: \"close inactive channels only\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName: \"force\",\n\t\t\tUsage: \"ask for confirmation once before attempting \" +\n\t\t\t\t\"to close existing channels\",\n\t\t},\n\t\tcli.Int64Flag{\n\t\t\tName: \"conf_target\",\n\t\t\tUsage: \"(optional) the number of blocks that the \" +\n\t\t\t\t\"closing transactions *should* confirm in, will be \" +\n\t\t\t\t\"used for fee estimation\",\n\t\t},\n\t\tcli.Int64Flag{\n\t\t\tName:   \"sat_per_byte\",\n\t\t\tUsage:  \"Deprecated, use sat_per_vbyte instead.\",\n\t\t\tHidden: true,\n\t\t},\n\t\tcli.Int64Flag{\n\t\t\tName: \"sat_per_vbyte\",\n\t\t\tUsage: \"(optional) a manual fee expressed in \" +\n\t\t\t\t\"sat/vbyte that should be used when crafting \" +\n\t\t\t\t\"the closing transactions\",\n\t\t},\n\t},\n\tAction: actionDecorator(closeAllChannels),\n}\n",
      "length": 2333,
      "tokens": 331,
      "embedding": []
    },
    {
      "slug": "func closeAllChannels(ctx *cli.Context) error {",
      "content": "func closeAllChannels(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\t// Check that only the field sat_per_vbyte or the deprecated field\n\t// sat_per_byte is used.\n\tfeeRateFlag, err := checkNotBothSet(\n\t\tctx, \"sat_per_vbyte\", \"sat_per_byte\",\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlistReq := &lnrpc.ListChannelsRequest{}\n\topenChannels, err := client.ListChannels(ctxc, listReq)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to fetch open channels: %v\", err)\n\t}\n\n\tif len(openChannels.Channels) == 0 {\n\t\treturn errors.New(\"no open channels to close\")\n\t}\n\n\tvar channelsToClose []*lnrpc.Channel\n\n\tswitch {\n\tcase ctx.Bool(\"force\") && ctx.Bool(\"inactive_only\"):\n\t\tmsg := \"Unilaterally close all inactive channels? The funds \" +\n\t\t\t\"within these channels will be locked for some blocks \" +\n\t\t\t\"(CSV delay) before they can be spent. (yes/no): \"\n\n\t\tconfirmed := promptForConfirmation(msg)\n\n\t\t// We can safely exit if the user did not confirm.\n\t\tif !confirmed {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Go through the list of open channels and only add inactive\n\t\t// channels to the closing list.\n\t\tfor _, channel := range openChannels.Channels {\n\t\t\tif !channel.GetActive() {\n\t\t\t\tchannelsToClose = append(\n\t\t\t\t\tchannelsToClose, channel,\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\tcase ctx.Bool(\"force\"):\n\t\tmsg := \"Close all active and inactive channels? Inactive \" +\n\t\t\t\"channels will be closed unilaterally, so funds \" +\n\t\t\t\"within them will be locked for a few blocks (CSV \" +\n\t\t\t\"delay) before they can be spent. (yes/no): \"\n\n\t\tconfirmed := promptForConfirmation(msg)\n\n\t\t// We can safely exit if the user did not confirm.\n\t\tif !confirmed {\n\t\t\treturn nil\n\t\t}\n\n\t\tchannelsToClose = openChannels.Channels\n\tdefault:\n\t\t// Go through the list of open channels and determine which\n\t\t// should be added to the closing list.\n\t\tfor _, channel := range openChannels.Channels {\n\t\t\t// If the channel is inactive, we'll attempt to\n\t\t\t// unilaterally close the channel, so we should prompt\n\t\t\t// the user for confirmation beforehand.\n\t\t\tif !channel.GetActive() {\n\t\t\t\tmsg := fmt.Sprintf(\"Unilaterally close channel \"+\n\t\t\t\t\t\"with node %s and channel point %s? \"+\n\t\t\t\t\t\"The closing transaction will need %d \"+\n\t\t\t\t\t\"confirmations before the funds can be \"+\n\t\t\t\t\t\"spent. (yes/no): \", channel.RemotePubkey,\n\t\t\t\t\tchannel.ChannelPoint, channel.LocalConstraints.CsvDelay)\n\n\t\t\t\tconfirmed := promptForConfirmation(msg)\n\n\t\t\t\tif confirmed {\n\t\t\t\t\tchannelsToClose = append(\n\t\t\t\t\t\tchannelsToClose, channel,\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t} else if !ctx.Bool(\"inactive_only\") {\n\t\t\t\t// Otherwise, we'll only add active channels if\n\t\t\t\t// we were not requested to close inactive\n\t\t\t\t// channels only.\n\t\t\t\tchannelsToClose = append(\n\t\t\t\t\tchannelsToClose, channel,\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t}\n\n\t// result defines the result of closing a channel. The closing\n\t// transaction ID is populated if a channel is successfully closed.\n\t// Otherwise, the error that prevented closing the channel is populated.\n\ttype result struct {\n\t\tRemotePubKey string `json:\"remote_pub_key\"`\n\t\tChannelPoint string `json:\"channel_point\"`\n\t\tClosingTxid  string `json:\"closing_txid\"`\n\t\tFailErr      string `json:\"error\"`\n\t}\n\n\t// Launch each channel closure in a goroutine in order to execute them\n\t// in parallel. Once they're all executed, we will print the results as\n\t// they come.\n\tresultChan := make(chan result, len(channelsToClose))\n\tfor _, channel := range channelsToClose {\n\t\tgo func(channel *lnrpc.Channel) {\n\t\t\tres := result{}\n\t\t\tres.RemotePubKey = channel.RemotePubkey\n\t\t\tres.ChannelPoint = channel.ChannelPoint\n\t\t\tdefer func() {\n\t\t\t\tresultChan <- res\n\t\t\t}()\n\n\t\t\t// Parse the channel point in order to create the close\n\t\t\t// channel request.\n\t\t\ts := strings.Split(res.ChannelPoint, \":\")\n\t\t\tif len(s) != 2 {\n\t\t\t\tres.FailErr = \"expected channel point with \" +\n\t\t\t\t\t\"format txid:index\"\n\t\t\t\treturn\n\t\t\t}\n\t\t\tindex, err := strconv.ParseUint(s[1], 10, 32)\n\t\t\tif err != nil {\n\t\t\t\tres.FailErr = fmt.Sprintf(\"unable to parse \"+\n\t\t\t\t\t\"channel point output index: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\treq := &lnrpc.CloseChannelRequest{\n\t\t\t\tChannelPoint: &lnrpc.ChannelPoint{\n\t\t\t\t\tFundingTxid: &lnrpc.ChannelPoint_FundingTxidStr{\n\t\t\t\t\t\tFundingTxidStr: s[0],\n\t\t\t\t\t},\n\t\t\t\t\tOutputIndex: uint32(index),\n\t\t\t\t},\n\t\t\t\tForce:       !channel.GetActive(),\n\t\t\t\tTargetConf:  int32(ctx.Int64(\"conf_target\")),\n\t\t\t\tSatPerVbyte: ctx.Uint64(feeRateFlag),\n\t\t\t}\n\n\t\t\ttxidChan := make(chan string, 1)\n\t\t\terr = executeChannelClose(ctxc, client, req, txidChan, false)\n\t\t\tif err != nil {\n\t\t\t\tres.FailErr = fmt.Sprintf(\"unable to close \"+\n\t\t\t\t\t\"channel: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tres.ClosingTxid = <-txidChan\n\t\t}(channel)\n\t}\n\n\tfor range channelsToClose {\n\t\tres := <-resultChan\n\t\tprintJSON(res)\n\t}\n\n\treturn nil\n}\n\n// promptForConfirmation continuously prompts the user for the message until\n// receiving a response of \"yes\" or \"no\" and returns their answer as a bool.",
      "length": 4634,
      "tokens": 630,
      "embedding": []
    },
    {
      "slug": "func promptForConfirmation(msg string) bool {",
      "content": "func promptForConfirmation(msg string) bool {\n\treader := bufio.NewReader(os.Stdin)\n\n\tfor {\n\t\tfmt.Print(msg)\n\n\t\tanswer, err := reader.ReadString('\\n')\n\t\tif err != nil {\n\t\t\treturn false\n\t\t}\n\n\t\tanswer = strings.ToLower(strings.TrimSpace(answer))\n\n\t\tswitch {\n\t\tcase answer == \"yes\":\n\t\t\treturn true\n\t\tcase answer == \"no\":\n\t\t\treturn false\n\t\tdefault:\n\t\t\tcontinue\n\t\t}\n\t}\n}\n\nvar abandonChannelCommand = cli.Command{\n\tName:     \"abandonchannel\",\n\tCategory: \"Channels\",\n\tUsage:    \"Abandons an existing channel.\",\n\tDescription: `\n\tRemoves all channel state from the database except for a close\n\tsummary. This method can be used to get rid of permanently unusable\n\tchannels due to bugs fixed in newer versions of lnd.\n\n\tOnly available when lnd is built in debug mode. The flag\n\t--i_know_what_i_am_doing can be set to override the debug/dev mode\n\trequirement.\n\n\tTo view which funding_txids/output_indexes can be used for this command,\n\tsee the channel_point values within the listchannels command output.\n\tThe format for a channel_point is 'funding_txid:output_index'.`,\n\tArgsUsage: \"funding_txid [output_index]\",\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName:  \"funding_txid\",\n\t\t\tUsage: \"the txid of the channel's funding transaction\",\n\t\t},\n\t\tcli.IntFlag{\n\t\t\tName: \"output_index\",\n\t\t\tUsage: \"the output index for the funding output of the funding \" +\n\t\t\t\t\"transaction\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName: \"chan_point\",\n\t\t\tUsage: \"(optional) the channel point. If set, \" +\n\t\t\t\t\"funding_txid and output_index flags and \" +\n\t\t\t\t\"positional arguments will be ignored\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName: \"i_know_what_i_am_doing\",\n\t\t\tUsage: \"override the requirement for lnd needing to \" +\n\t\t\t\t\"be in dev/debug mode to use this command; \" +\n\t\t\t\t\"when setting this the user attests that \" +\n\t\t\t\t\"they know the danger of using this command \" +\n\t\t\t\t\"on channels and that doing so can lead to \" +\n\t\t\t\t\"loss of funds if the channel funding TX \" +\n\t\t\t\t\"ever confirms (or was confirmed)\",\n\t\t},\n\t},\n\tAction: actionDecorator(abandonChannel),\n}\n",
      "length": 1895,
      "tokens": 268,
      "embedding": []
    },
    {
      "slug": "func abandonChannel(ctx *cli.Context) error {",
      "content": "func abandonChannel(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\t// Show command help if no arguments and flags were provided.\n\tif ctx.NArg() == 0 && ctx.NumFlags() == 0 {\n\t\tcli.ShowCommandHelp(ctx, \"abandonchannel\")\n\t\treturn nil\n\t}\n\n\tchannelPoint, err := parseChannelPoint(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treq := &lnrpc.AbandonChannelRequest{\n\t\tChannelPoint:      channelPoint,\n\t\tIKnowWhatIAmDoing: ctx.Bool(\"i_know_what_i_am_doing\"),\n\t}\n\n\tresp, err := client.AbandonChannel(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(resp)\n\treturn nil\n}\n\n// parseChannelPoint parses a funding txid and output index from the command\n// line. Both named options as well as unnamed parameters are supported.",
      "length": 694,
      "tokens": 95,
      "embedding": []
    },
    {
      "slug": "func parseChannelPoint(ctx *cli.Context) (*lnrpc.ChannelPoint, error) {",
      "content": "func parseChannelPoint(ctx *cli.Context) (*lnrpc.ChannelPoint, error) {\n\tchannelPoint := &lnrpc.ChannelPoint{}\n\tvar err error\n\n\targs := ctx.Args()\n\n\tswitch {\n\tcase ctx.IsSet(\"chan_point\"):\n\t\tchannelPoint, err = parseChanPoint(ctx.String(\"chan_point\"))\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to parse chan_point: \"+\n\t\t\t\t\"%v\", err)\n\t\t}\n\t\treturn channelPoint, nil\n\n\tcase ctx.IsSet(\"funding_txid\"):\n\t\tchannelPoint.FundingTxid = &lnrpc.ChannelPoint_FundingTxidStr{\n\t\t\tFundingTxidStr: ctx.String(\"funding_txid\"),\n\t\t}\n\tcase args.Present():\n\t\tchannelPoint.FundingTxid = &lnrpc.ChannelPoint_FundingTxidStr{\n\t\t\tFundingTxidStr: args.First(),\n\t\t}\n\t\targs = args.Tail()\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"funding txid argument missing\")\n\t}\n\n\tswitch {\n\tcase ctx.IsSet(\"output_index\"):\n\t\tchannelPoint.OutputIndex = uint32(ctx.Int(\"output_index\"))\n\tcase args.Present():\n\t\tindex, err := strconv.ParseUint(args.First(), 10, 32)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to decode output index: %v\", err)\n\t\t}\n\t\tchannelPoint.OutputIndex = uint32(index)\n\tdefault:\n\t\tchannelPoint.OutputIndex = 0\n\t}\n\n\treturn channelPoint, nil\n}\n\nvar listPeersCommand = cli.Command{\n\tName:     \"listpeers\",\n\tCategory: \"Peers\",\n\tUsage:    \"List all active, currently connected peers.\",\n\tFlags: []cli.Flag{\n\t\tcli.BoolFlag{\n\t\t\tName:  \"list_errors\",\n\t\t\tUsage: \"list a full set of most recent errors for the peer\",\n\t\t},\n\t},\n\tAction: actionDecorator(listPeers),\n}\n",
      "length": 1314,
      "tokens": 141,
      "embedding": []
    },
    {
      "slug": "func listPeers(ctx *cli.Context) error {",
      "content": "func listPeers(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\t// By default, we display a single error on the cli. If the user\n\t// specifically requests a full error set, then we will provide it.\n\treq := &lnrpc.ListPeersRequest{\n\t\tLatestError: !ctx.IsSet(\"list_errors\"),\n\t}\n\tresp, err := client.ListPeers(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(resp)\n\treturn nil\n}\n\nvar walletBalanceCommand = cli.Command{\n\tName:     \"walletbalance\",\n\tCategory: \"Wallet\",\n\tUsage:    \"Compute and display the wallet's current balance.\",\n\tAction:   actionDecorator(walletBalance),\n}\n",
      "length": 574,
      "tokens": 77,
      "embedding": []
    },
    {
      "slug": "func walletBalance(ctx *cli.Context) error {",
      "content": "func walletBalance(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\treq := &lnrpc.WalletBalanceRequest{}\n\tresp, err := client.WalletBalance(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(resp)\n\treturn nil\n}\n\nvar channelBalanceCommand = cli.Command{\n\tName:     \"channelbalance\",\n\tCategory: \"Channels\",\n\tUsage: \"Returns the sum of the total available channel balance across \" +\n\t\t\"all open channels.\",\n\tAction: actionDecorator(channelBalance),\n}\n",
      "length": 444,
      "tokens": 56,
      "embedding": []
    },
    {
      "slug": "func channelBalance(ctx *cli.Context) error {",
      "content": "func channelBalance(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\treq := &lnrpc.ChannelBalanceRequest{}\n\tresp, err := client.ChannelBalance(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(resp)\n\treturn nil\n}\n\nvar getInfoCommand = cli.Command{\n\tName:   \"getinfo\",\n\tUsage:  \"Returns basic information related to the active daemon.\",\n\tAction: actionDecorator(getInfo),\n}\n",
      "length": 371,
      "tokens": 47,
      "embedding": []
    },
    {
      "slug": "func getInfo(ctx *cli.Context) error {",
      "content": "func getInfo(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\treq := &lnrpc.GetInfoRequest{}\n\tresp, err := client.GetInfo(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(resp)\n\treturn nil\n}\n\nvar getRecoveryInfoCommand = cli.Command{\n\tName:   \"getrecoveryinfo\",\n\tUsage:  \"Display information about an ongoing recovery attempt.\",\n\tAction: actionDecorator(getRecoveryInfo),\n}\n",
      "length": 380,
      "tokens": 46,
      "embedding": []
    },
    {
      "slug": "func getRecoveryInfo(ctx *cli.Context) error {",
      "content": "func getRecoveryInfo(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\treq := &lnrpc.GetRecoveryInfoRequest{}\n\tresp, err := client.GetRecoveryInfo(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(resp)\n\treturn nil\n}\n\nvar pendingChannelsCommand = cli.Command{\n\tName:     \"pendingchannels\",\n\tCategory: \"Channels\",\n\tUsage:    \"Display information pertaining to pending channels.\",\n\tAction:   actionDecorator(pendingChannels),\n}\n",
      "length": 421,
      "tokens": 47,
      "embedding": []
    },
    {
      "slug": "func pendingChannels(ctx *cli.Context) error {",
      "content": "func pendingChannels(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\treq := &lnrpc.PendingChannelsRequest{}\n\tresp, err := client.PendingChannels(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(resp)\n\n\treturn nil\n}\n\nvar listChannelsCommand = cli.Command{\n\tName:     \"listchannels\",\n\tCategory: \"Channels\",\n\tUsage:    \"List all open channels.\",\n\tFlags: []cli.Flag{\n\t\tcli.BoolFlag{\n\t\t\tName:  \"active_only\",\n\t\t\tUsage: \"only list channels which are currently active\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"inactive_only\",\n\t\t\tUsage: \"only list channels which are currently inactive\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"public_only\",\n\t\t\tUsage: \"only list channels which are currently public\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"private_only\",\n\t\t\tUsage: \"only list channels which are currently private\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName: \"peer\",\n\t\t\tUsage: \"(optional) only display channels with a \" +\n\t\t\t\t\"particular peer, accepts 66-byte, \" +\n\t\t\t\t\"hex-encoded pubkeys\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName: \"skip_peer_alias_lookup\",\n\t\t\tUsage: \"skip the peer alias lookup per channel in \" +\n\t\t\t\t\"order to improve performance\",\n\t\t},\n\t},\n\tAction: actionDecorator(listChannels),\n}\n\nvar listAliasesCommand = cli.Command{\n\tName:     \"listaliases\",\n\tCategory: \"Channels\",\n\tUsage:    \"List all aliases.\",\n\tFlags:    []cli.Flag{},\n\tAction:   actionDecorator(listaliases),\n}\n",
      "length": 1297,
      "tokens": 153,
      "embedding": []
    },
    {
      "slug": "func listaliases(ctx *cli.Context) error {",
      "content": "func listaliases(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\treq := &lnrpc.ListAliasesRequest{}\n\n\tresp, err := client.ListAliases(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(resp)\n\n\treturn nil\n}\n",
      "length": 211,
      "tokens": 29,
      "embedding": []
    },
    {
      "slug": "func listChannels(ctx *cli.Context) error {",
      "content": "func listChannels(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\tpeer := ctx.String(\"peer\")\n\n\t// If the user requested channels with a particular key, parse the\n\t// provided pubkey.\n\tvar peerKey []byte\n\tif len(peer) > 0 {\n\t\tpk, err := route.NewVertexFromStr(peer)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"invalid --peer pubkey: %v\", err)\n\t\t}\n\n\t\tpeerKey = pk[:]\n\t}\n\n\t// By default we will look up the peers' alias information unless the\n\t// skip_peer_alias_lookup flag indicates otherwise.\n\tlookupPeerAlias := !ctx.Bool(\"skip_peer_alias_lookup\")\n\n\treq := &lnrpc.ListChannelsRequest{\n\t\tActiveOnly:      ctx.Bool(\"active_only\"),\n\t\tInactiveOnly:    ctx.Bool(\"inactive_only\"),\n\t\tPublicOnly:      ctx.Bool(\"public_only\"),\n\t\tPrivateOnly:     ctx.Bool(\"private_only\"),\n\t\tPeer:            peerKey,\n\t\tPeerAliasLookup: lookupPeerAlias,\n\t}\n\n\tresp, err := client.ListChannels(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(resp)\n\n\treturn nil\n}\n\nvar closedChannelsCommand = cli.Command{\n\tName:     \"closedchannels\",\n\tCategory: \"Channels\",\n\tUsage:    \"List all closed channels.\",\n\tFlags: []cli.Flag{\n\t\tcli.BoolFlag{\n\t\t\tName:  \"cooperative\",\n\t\t\tUsage: \"list channels that were closed cooperatively\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName: \"local_force\",\n\t\t\tUsage: \"list channels that were force-closed \" +\n\t\t\t\t\"by the local node\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName: \"remote_force\",\n\t\t\tUsage: \"list channels that were force-closed \" +\n\t\t\t\t\"by the remote node\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName: \"breach\",\n\t\t\tUsage: \"list channels for which the remote node \" +\n\t\t\t\t\"attempted to broadcast a prior \" +\n\t\t\t\t\"revoked channel state\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"funding_canceled\",\n\t\t\tUsage: \"list channels that were never fully opened\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName: \"abandoned\",\n\t\t\tUsage: \"list channels that were abandoned by \" +\n\t\t\t\t\"the local node\",\n\t\t},\n\t},\n\tAction: actionDecorator(closedChannels),\n}\n",
      "length": 1816,
      "tokens": 223,
      "embedding": []
    },
    {
      "slug": "func closedChannels(ctx *cli.Context) error {",
      "content": "func closedChannels(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\treq := &lnrpc.ClosedChannelsRequest{\n\t\tCooperative:     ctx.Bool(\"cooperative\"),\n\t\tLocalForce:      ctx.Bool(\"local_force\"),\n\t\tRemoteForce:     ctx.Bool(\"remote_force\"),\n\t\tBreach:          ctx.Bool(\"breach\"),\n\t\tFundingCanceled: ctx.Bool(\"funding_canceled\"),\n\t\tAbandoned:       ctx.Bool(\"abandoned\"),\n\t}\n\n\tresp, err := client.ClosedChannels(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(resp)\n\n\treturn nil\n}\n\nvar describeGraphCommand = cli.Command{\n\tName:     \"describegraph\",\n\tCategory: \"Graph\",\n\tDescription: \"Prints a human readable version of the known channel \" +\n\t\t\"graph from the PoV of the node\",\n\tUsage: \"Describe the network graph.\",\n\tFlags: []cli.Flag{\n\t\tcli.BoolFlag{\n\t\t\tName: \"include_unannounced\",\n\t\t\tUsage: \"If set, unannounced channels will be included in the \" +\n\t\t\t\t\"graph. Unannounced channels are both private channels, and \" +\n\t\t\t\t\"public channels that are not yet announced to the network.\",\n\t\t},\n\t},\n\tAction: actionDecorator(describeGraph),\n}\n",
      "length": 1016,
      "tokens": 116,
      "embedding": []
    },
    {
      "slug": "func describeGraph(ctx *cli.Context) error {",
      "content": "func describeGraph(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\treq := &lnrpc.ChannelGraphRequest{\n\t\tIncludeUnannounced: ctx.Bool(\"include_unannounced\"),\n\t}\n\n\tgraph, err := client.DescribeGraph(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(graph)\n\treturn nil\n}\n\nvar getNodeMetricsCommand = cli.Command{\n\tName:        \"getnodemetrics\",\n\tCategory:    \"Graph\",\n\tDescription: \"Prints out node metrics calculated from the current graph\",\n\tUsage:       \"Get node metrics.\",\n\tAction:      actionDecorator(getNodeMetrics),\n}\n",
      "length": 519,
      "tokens": 57,
      "embedding": []
    },
    {
      "slug": "func getNodeMetrics(ctx *cli.Context) error {",
      "content": "func getNodeMetrics(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\treq := &lnrpc.NodeMetricsRequest{\n\t\tTypes: []lnrpc.NodeMetricType{lnrpc.NodeMetricType_BETWEENNESS_CENTRALITY},\n\t}\n\n\tnodeMetrics, err := client.GetNodeMetrics(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(nodeMetrics)\n\treturn nil\n}\n\nvar getChanInfoCommand = cli.Command{\n\tName:     \"getchaninfo\",\n\tCategory: \"Graph\",\n\tUsage:    \"Get the state of a channel.\",\n\tDescription: \"Prints out the latest authenticated state for a \" +\n\t\t\"particular channel\",\n\tArgsUsage: \"chan_id\",\n\tFlags: []cli.Flag{\n\t\tcli.Uint64Flag{\n\t\t\tName:  \"chan_id\",\n\t\t\tUsage: \"the 8-byte compact channel ID to query for\",\n\t\t},\n\t},\n\tAction: actionDecorator(getChanInfo),\n}\n",
      "length": 696,
      "tokens": 81,
      "embedding": []
    },
    {
      "slug": "func getChanInfo(ctx *cli.Context) error {",
      "content": "func getChanInfo(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\tvar (\n\t\tchanID uint64\n\t\terr    error\n\t)\n\n\tswitch {\n\tcase ctx.IsSet(\"chan_id\"):\n\t\tchanID = ctx.Uint64(\"chan_id\")\n\tcase ctx.Args().Present():\n\t\tchanID, err = strconv.ParseUint(ctx.Args().First(), 10, 64)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error parsing chan_id: %s\", err)\n\t\t}\n\tdefault:\n\t\treturn fmt.Errorf(\"chan_id argument missing\")\n\t}\n\n\treq := &lnrpc.ChanInfoRequest{\n\t\tChanId: chanID,\n\t}\n\n\tchanInfo, err := client.GetChanInfo(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(chanInfo)\n\treturn nil\n}\n\nvar getNodeInfoCommand = cli.Command{\n\tName:     \"getnodeinfo\",\n\tCategory: \"Graph\",\n\tUsage:    \"Get information on a specific node.\",\n\tDescription: \"Prints out the latest authenticated node state for an \" +\n\t\t\"advertised node\",\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName: \"pub_key\",\n\t\t\tUsage: \"the 33-byte hex-encoded compressed public of the target \" +\n\t\t\t\t\"node\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName: \"include_channels\",\n\t\t\tUsage: \"if true, will return all known channels \" +\n\t\t\t\t\"associated with the node\",\n\t\t},\n\t},\n\tAction: actionDecorator(getNodeInfo),\n}\n",
      "length": 1095,
      "tokens": 141,
      "embedding": []
    },
    {
      "slug": "func getNodeInfo(ctx *cli.Context) error {",
      "content": "func getNodeInfo(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\targs := ctx.Args()\n\n\tvar pubKey string\n\tswitch {\n\tcase ctx.IsSet(\"pub_key\"):\n\t\tpubKey = ctx.String(\"pub_key\")\n\tcase args.Present():\n\t\tpubKey = args.First()\n\tdefault:\n\t\treturn fmt.Errorf(\"pub_key argument missing\")\n\t}\n\n\treq := &lnrpc.NodeInfoRequest{\n\t\tPubKey:          pubKey,\n\t\tIncludeChannels: ctx.Bool(\"include_channels\"),\n\t}\n\n\tnodeInfo, err := client.GetNodeInfo(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(nodeInfo)\n\treturn nil\n}\n\nvar getNetworkInfoCommand = cli.Command{\n\tName:     \"getnetworkinfo\",\n\tCategory: \"Channels\",\n\tUsage: \"Get statistical information about the current \" +\n\t\t\"state of the network.\",\n\tDescription: \"Returns a set of statistics pertaining to the known \" +\n\t\t\"channel graph\",\n\tAction: actionDecorator(getNetworkInfo),\n}\n",
      "length": 802,
      "tokens": 96,
      "embedding": []
    },
    {
      "slug": "func getNetworkInfo(ctx *cli.Context) error {",
      "content": "func getNetworkInfo(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\treq := &lnrpc.NetworkInfoRequest{}\n\n\tnetInfo, err := client.GetNetworkInfo(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(netInfo)\n\treturn nil\n}\n\nvar debugLevelCommand = cli.Command{\n\tName:  \"debuglevel\",\n\tUsage: \"Set the debug level.\",\n\tDescription: `Logging level for all subsystems {trace, debug, info, warn, error, critical, off}\n\tYou may also specify <subsystem>=<level>,<subsystem2>=<level>,... to set the log level for individual subsystems\n\n\tUse show to list available subsystems`,\n\tFlags: []cli.Flag{\n\t\tcli.BoolFlag{\n\t\t\tName:  \"show\",\n\t\t\tUsage: \"if true, then the list of available sub-systems will be printed out\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"level\",\n\t\t\tUsage: \"the level specification to target either a coarse logging level, or granular set of specific sub-systems with logging levels for each\",\n\t\t},\n\t},\n\tAction: actionDecorator(debugLevel),\n}\n",
      "length": 918,
      "tokens": 121,
      "embedding": []
    },
    {
      "slug": "func debugLevel(ctx *cli.Context) error {",
      "content": "func debugLevel(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\treq := &lnrpc.DebugLevelRequest{\n\t\tShow:      ctx.Bool(\"show\"),\n\t\tLevelSpec: ctx.String(\"level\"),\n\t}\n\n\tresp, err := client.DebugLevel(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(resp)\n\treturn nil\n}\n\nvar listChainTxnsCommand = cli.Command{\n\tName:     \"listchaintxns\",\n\tCategory: \"On-chain\",\n\tUsage:    \"List transactions from the wallet.\",\n\tFlags: []cli.Flag{\n\t\tcli.Int64Flag{\n\t\t\tName: \"start_height\",\n\t\t\tUsage: \"the block height from which to list \" +\n\t\t\t\t\"transactions, inclusive\",\n\t\t},\n\t\tcli.Int64Flag{\n\t\t\tName: \"end_height\",\n\t\t\tUsage: \"the block height until which to list \" +\n\t\t\t\t\"transactions, inclusive, to get transactions \" +\n\t\t\t\t\"until the chain tip, including unconfirmed, \" +\n\t\t\t\t\"set this value to -1\",\n\t\t},\n\t},\n\tDescription: `\n\tList all transactions an address of the wallet was involved in.\n\n\tThis call will return a list of wallet related transactions that paid\n\tto an address our wallet controls, or spent utxos that we held. The\n\tstart_height and end_height flags can be used to specify an inclusive\n\tblock range over which to query for transactions. If the end_height is\n\tless than the start_height, transactions will be queried in reverse.\n\tTo get all transactions until the chain tip, including unconfirmed\n\ttransactions (identifiable with BlockHeight=0), set end_height to -1.\n\tBy default, this call will get all transactions our wallet was involved\n\tin, including unconfirmed transactions.\n`,\n\tAction: actionDecorator(listChainTxns),\n}\n",
      "length": 1499,
      "tokens": 210,
      "embedding": []
    },
    {
      "slug": "func listChainTxns(ctx *cli.Context) error {",
      "content": "func listChainTxns(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\treq := &lnrpc.GetTransactionsRequest{}\n\n\tif ctx.IsSet(\"start_height\") {\n\t\treq.StartHeight = int32(ctx.Int64(\"start_height\"))\n\t}\n\tif ctx.IsSet(\"end_height\") {\n\t\treq.EndHeight = int32(ctx.Int64(\"end_height\"))\n\t}\n\n\tresp, err := client.GetTransactions(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(resp)\n\treturn nil\n}\n\nvar stopCommand = cli.Command{\n\tName:  \"stop\",\n\tUsage: \"Stop and shutdown the daemon.\",\n\tDescription: `\n\tGracefully stop all daemon subsystems before stopping the daemon itself.\n\tThis is equivalent to stopping it using CTRL-C.`,\n\tAction: actionDecorator(stopDaemon),\n}\n",
      "length": 644,
      "tokens": 78,
      "embedding": []
    },
    {
      "slug": "func stopDaemon(ctx *cli.Context) error {",
      "content": "func stopDaemon(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\t_, err := client.StopDaemon(ctxc, &lnrpc.StopRequest{})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nvar signMessageCommand = cli.Command{\n\tName:      \"signmessage\",\n\tCategory:  \"Wallet\",\n\tUsage:     \"Sign a message with the node's private key.\",\n\tArgsUsage: \"msg\",\n\tDescription: `\n\tSign msg with the resident node's private key.\n\tReturns the signature as a zbase32 string.\n\n\tPositional arguments and flags can be used interchangeably but not at the same time!`,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName:  \"msg\",\n\t\t\tUsage: \"the message to sign\",\n\t\t},\n\t},\n\tAction: actionDecorator(signMessage),\n}\n",
      "length": 651,
      "tokens": 90,
      "embedding": []
    },
    {
      "slug": "func signMessage(ctx *cli.Context) error {",
      "content": "func signMessage(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\tvar msg []byte\n\n\tswitch {\n\tcase ctx.IsSet(\"msg\"):\n\t\tmsg = []byte(ctx.String(\"msg\"))\n\tcase ctx.Args().Present():\n\t\tmsg = []byte(ctx.Args().First())\n\tdefault:\n\t\treturn fmt.Errorf(\"msg argument missing\")\n\t}\n\n\tresp, err := client.SignMessage(ctxc, &lnrpc.SignMessageRequest{Msg: msg})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(resp)\n\treturn nil\n}\n\nvar verifyMessageCommand = cli.Command{\n\tName:      \"verifymessage\",\n\tCategory:  \"Wallet\",\n\tUsage:     \"Verify a message signed with the signature.\",\n\tArgsUsage: \"msg signature\",\n\tDescription: `\n\tVerify that the message was signed with a properly-formed signature\n\tThe signature must be zbase32 encoded and signed with the private key of\n\tan active node in the resident node's channel database.\n\n\tPositional arguments and flags can be used interchangeably but not at the same time!`,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName:  \"msg\",\n\t\t\tUsage: \"the message to verify\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"sig\",\n\t\t\tUsage: \"the zbase32 encoded signature of the message\",\n\t\t},\n\t},\n\tAction: actionDecorator(verifyMessage),\n}\n",
      "length": 1104,
      "tokens": 142,
      "embedding": []
    },
    {
      "slug": "func verifyMessage(ctx *cli.Context) error {",
      "content": "func verifyMessage(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\tvar (\n\t\tmsg []byte\n\t\tsig string\n\t)\n\n\targs := ctx.Args()\n\n\tswitch {\n\tcase ctx.IsSet(\"msg\"):\n\t\tmsg = []byte(ctx.String(\"msg\"))\n\tcase args.Present():\n\t\tmsg = []byte(ctx.Args().First())\n\t\targs = args.Tail()\n\tdefault:\n\t\treturn fmt.Errorf(\"msg argument missing\")\n\t}\n\n\tswitch {\n\tcase ctx.IsSet(\"sig\"):\n\t\tsig = ctx.String(\"sig\")\n\tcase args.Present():\n\t\tsig = args.First()\n\tdefault:\n\t\treturn fmt.Errorf(\"signature argument missing\")\n\t}\n\n\treq := &lnrpc.VerifyMessageRequest{Msg: msg, Signature: sig}\n\tresp, err := client.VerifyMessage(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(resp)\n\treturn nil\n}\n\nvar feeReportCommand = cli.Command{\n\tName:     \"feereport\",\n\tCategory: \"Channels\",\n\tUsage:    \"Display the current fee policies of all active channels.\",\n\tDescription: `\n\tReturns the current fee policies of all active channels.\n\tFee policies can be updated using the updatechanpolicy command.`,\n\tAction: actionDecorator(feeReport),\n}\n",
      "length": 967,
      "tokens": 122,
      "embedding": []
    },
    {
      "slug": "func feeReport(ctx *cli.Context) error {",
      "content": "func feeReport(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\treq := &lnrpc.FeeReportRequest{}\n\tresp, err := client.FeeReport(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(resp)\n\treturn nil\n}\n\nvar updateChannelPolicyCommand = cli.Command{\n\tName:     \"updatechanpolicy\",\n\tCategory: \"Channels\",\n\tUsage: \"Update the channel policy for all channels, or a single \" +\n\t\t\"channel.\",\n\tArgsUsage: \"base_fee_msat fee_rate time_lock_delta \" +\n\t\t\"[--max_htlc_msat=N] [channel_point]\",\n\tDescription: `\n\tUpdates the channel policy for all channels, or just a particular channel\n\tidentified by its channel point. The update will be committed, and\n\tbroadcast to the rest of the network within the next batch.\n\tChannel points are encoded as: funding_txid:output_index`,\n\tFlags: []cli.Flag{\n\t\tcli.Int64Flag{\n\t\t\tName: \"base_fee_msat\",\n\t\t\tUsage: \"the base fee in milli-satoshis that will \" +\n\t\t\t\t\"be charged for each forwarded HTLC, regardless \" +\n\t\t\t\t\"of payment size\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName: \"fee_rate\",\n\t\t\tUsage: \"the fee rate that will be charged \" +\n\t\t\t\t\"proportionally based on the value of each \" +\n\t\t\t\t\"forwarded HTLC, the lowest possible rate is 0 \" +\n\t\t\t\t\"with a granularity of 0.000001 (millionths). Can not \" +\n\t\t\t\t\"be set at the same time as fee_rate_ppm.\",\n\t\t},\n\t\tcli.Uint64Flag{\n\t\t\tName: \"fee_rate_ppm\",\n\t\t\tUsage: \"the fee rate ppm (parts per million) that \" +\n\t\t\t\t\"will be charged proportionally based on the value of each \" +\n\t\t\t\t\"forwarded HTLC, the lowest possible rate is 0 \" +\n\t\t\t\t\"with a granularity of 0.000001 (millionths). Can not \" +\n\t\t\t\t\"be set at the same time as fee_rate.\",\n\t\t},\n\t\tcli.Int64Flag{\n\t\t\tName: \"time_lock_delta\",\n\t\t\tUsage: \"the CLTV delta that will be applied to all \" +\n\t\t\t\t\"forwarded HTLCs\",\n\t\t},\n\t\tcli.Uint64Flag{\n\t\t\tName: \"min_htlc_msat\",\n\t\t\tUsage: \"if set, the min HTLC size that will be applied \" +\n\t\t\t\t\"to all forwarded HTLCs. If unset, the min HTLC \" +\n\t\t\t\t\"is left unchanged.\",\n\t\t},\n\t\tcli.Uint64Flag{\n\t\t\tName: \"max_htlc_msat\",\n\t\t\tUsage: \"if set, the max HTLC size that will be applied \" +\n\t\t\t\t\"to all forwarded HTLCs. If unset, the max HTLC \" +\n\t\t\t\t\"is left unchanged.\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName: \"chan_point\",\n\t\t\tUsage: \"The channel whose fee policy should be \" +\n\t\t\t\t\"updated, if nil the policies for all channels \" +\n\t\t\t\t\"will be updated. Takes the form of: txid:output_index\",\n\t\t},\n\t},\n\tAction: actionDecorator(updateChannelPolicy),\n}\n",
      "length": 2337,
      "tokens": 351,
      "embedding": []
    },
    {
      "slug": "func parseChanPoint(s string) (*lnrpc.ChannelPoint, error) {",
      "content": "func parseChanPoint(s string) (*lnrpc.ChannelPoint, error) {\n\tsplit := strings.Split(s, \":\")\n\tif len(split) != 2 || len(split[0]) == 0 || len(split[1]) == 0 {\n\t\treturn nil, errBadChanPoint\n\t}\n\n\tindex, err := strconv.ParseInt(split[1], 10, 64)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to decode output index: %v\", err)\n\t}\n\n\ttxid, err := chainhash.NewHashFromStr(split[0])\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to parse hex string: %v\", err)\n\t}\n\n\treturn &lnrpc.ChannelPoint{\n\t\tFundingTxid: &lnrpc.ChannelPoint_FundingTxidBytes{\n\t\t\tFundingTxidBytes: txid[:],\n\t\t},\n\t\tOutputIndex: uint32(index),\n\t}, nil\n}\n",
      "length": 539,
      "tokens": 73,
      "embedding": []
    },
    {
      "slug": "func updateChannelPolicy(ctx *cli.Context) error {",
      "content": "func updateChannelPolicy(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\tvar (\n\t\tbaseFee       int64\n\t\tfeeRate       float64\n\t\tfeeRatePpm    uint64\n\t\ttimeLockDelta int64\n\t\terr           error\n\t)\n\targs := ctx.Args()\n\n\tswitch {\n\tcase ctx.IsSet(\"base_fee_msat\"):\n\t\tbaseFee = ctx.Int64(\"base_fee_msat\")\n\tcase args.Present():\n\t\tbaseFee, err = strconv.ParseInt(args.First(), 10, 64)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to decode base_fee_msat: %v\", err)\n\t\t}\n\t\targs = args.Tail()\n\tdefault:\n\t\treturn fmt.Errorf(\"base_fee_msat argument missing\")\n\t}\n\n\tswitch {\n\tcase ctx.IsSet(\"fee_rate\") && ctx.IsSet(\"fee_rate_ppm\"):\n\t\treturn fmt.Errorf(\"fee_rate or fee_rate_ppm can not both be set\")\n\tcase ctx.IsSet(\"fee_rate\"):\n\t\tfeeRate = ctx.Float64(\"fee_rate\")\n\tcase ctx.IsSet(\"fee_rate_ppm\"):\n\t\tfeeRatePpm = ctx.Uint64(\"fee_rate_ppm\")\n\tcase args.Present():\n\t\tfeeRate, err = strconv.ParseFloat(args.First(), 64)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to decode fee_rate: %v\", err)\n\t\t}\n\n\t\targs = args.Tail()\n\tdefault:\n\t\treturn fmt.Errorf(\"fee_rate or fee_rate_ppm argument missing\")\n\t}\n\n\tswitch {\n\tcase ctx.IsSet(\"time_lock_delta\"):\n\t\ttimeLockDelta = ctx.Int64(\"time_lock_delta\")\n\tcase args.Present():\n\t\ttimeLockDelta, err = strconv.ParseInt(args.First(), 10, 64)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to decode time_lock_delta: %v\",\n\t\t\t\terr)\n\t\t}\n\n\t\targs = args.Tail()\n\tdefault:\n\t\treturn fmt.Errorf(\"time_lock_delta argument missing\")\n\t}\n\n\tvar (\n\t\tchanPoint    *lnrpc.ChannelPoint\n\t\tchanPointStr string\n\t)\n\n\tswitch {\n\tcase ctx.IsSet(\"chan_point\"):\n\t\tchanPointStr = ctx.String(\"chan_point\")\n\tcase args.Present():\n\t\tchanPointStr = args.First()\n\t}\n\n\tif chanPointStr != \"\" {\n\t\tchanPoint, err = parseChanPoint(chanPointStr)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to parse chan_point: %v\", err)\n\t\t}\n\t}\n\n\treq := &lnrpc.PolicyUpdateRequest{\n\t\tBaseFeeMsat:   baseFee,\n\t\tTimeLockDelta: uint32(timeLockDelta),\n\t\tMaxHtlcMsat:   ctx.Uint64(\"max_htlc_msat\"),\n\t}\n\n\tif ctx.IsSet(\"min_htlc_msat\") {\n\t\treq.MinHtlcMsat = ctx.Uint64(\"min_htlc_msat\")\n\t\treq.MinHtlcMsatSpecified = true\n\t}\n\n\tif chanPoint != nil {\n\t\treq.Scope = &lnrpc.PolicyUpdateRequest_ChanPoint{\n\t\t\tChanPoint: chanPoint,\n\t\t}\n\t} else {\n\t\treq.Scope = &lnrpc.PolicyUpdateRequest_Global{\n\t\t\tGlobal: true,\n\t\t}\n\t}\n\n\tif feeRate != 0 {\n\t\treq.FeeRate = feeRate\n\t} else if feeRatePpm != 0 {\n\t\treq.FeeRatePpm = uint32(feeRatePpm)\n\t}\n\n\tresp, err := client.UpdateChannelPolicy(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Parse the response into the final json object that will be printed\n\t// to stdout. At the moment, this filters out the raw txid bytes from\n\t// each failed update's outpoint and only prints the txid string.\n\tvar listFailedUpdateResp = struct {\n\t\tFailedUpdates []*FailedUpdate `json:\"failed_updates\"`\n\t}{\n\t\tFailedUpdates: make([]*FailedUpdate, 0, len(resp.FailedUpdates)),\n\t}\n\tfor _, protoUpdate := range resp.FailedUpdates {\n\t\tfailedUpdate := NewFailedUpdateFromProto(protoUpdate)\n\t\tlistFailedUpdateResp.FailedUpdates = append(\n\t\t\tlistFailedUpdateResp.FailedUpdates, failedUpdate)\n\t}\n\n\tprintJSON(listFailedUpdateResp)\n\n\treturn nil\n}\n\nvar fishCompletionCommand = cli.Command{\n\tName:   \"fish-completion\",\n\tHidden: true,\n\tAction: func(c *cli.Context) error {\n\t\tcompletion, err := c.App.ToFishCompletion()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// We don't want to suggest files, so we add this\n\t\t// first line to the completions.\n\t\t_, err = fmt.Printf(\"complete -c %q -f \\n%s\", c.App.Name, completion)\n\t\treturn err\n\t},\n}\n\nvar exportChanBackupCommand = cli.Command{\n\tName:     \"exportchanbackup\",\n\tCategory: \"Channels\",\n\tUsage: \"Obtain a static channel back up for a selected channels, \" +\n\t\t\"or all known channels.\",\n\tArgsUsage: \"[chan_point] [--all] [--output_file]\",\n\tDescription: `\n\tThis command allows a user to export a Static Channel Backup (SCB) for\n\ta selected channel. SCB's are encrypted backups of a channel's initial\n\tstate that are encrypted with a key derived from the seed of a user. In\n\tthe case of partial or complete data loss, the SCB will allow the user\n\tto reclaim settled funds in the channel at its final state. The\n\texported channel backups can be restored at a later time using the\n\trestorechanbackup command.\n\n\tThis command will return one of two types of channel backups depending\n\ton the set of passed arguments:\n\n\t   * If a target channel point is specified, then a single channel\n\t     backup containing only the information for that channel will be\n\t     returned.\n\n\t   * If the --all flag is passed, then a multi-channel backup will be\n\t     returned. A multi backup is a single encrypted blob (displayed in\n\t     hex encoding) that contains several channels in a single cipher\n\t     text.\n\n\tBoth of the backup types can be restored using the restorechanbackup\n\tcommand.\n\t`,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName:  \"chan_point\",\n\t\t\tUsage: \"the target channel to obtain an SCB for\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName: \"all\",\n\t\t\tUsage: \"if specified, then a multi backup of all \" +\n\t\t\t\t\"active channels will be returned\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName: \"output_file\",\n\t\t\tUsage: `\n\t\t\tif specified, then rather than printing a JSON output\n\t\t\tof the static channel backup, a serialized version of\n\t\t\tthe backup (either Single or Multi) will be written to\n\t\t\tthe target file, this is the same format used by lnd in\n\t\t\tits channel.backup file `,\n\t\t},\n\t},\n\tAction: actionDecorator(exportChanBackup),\n}\n",
      "length": 5207,
      "tokens": 687,
      "embedding": []
    },
    {
      "slug": "func exportChanBackup(ctx *cli.Context) error {",
      "content": "func exportChanBackup(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\t// Show command help if no arguments provided\n\tif ctx.NArg() == 0 && ctx.NumFlags() == 0 {\n\t\tcli.ShowCommandHelp(ctx, \"exportchanbackup\")\n\t\treturn nil\n\t}\n\n\tvar (\n\t\terr          error\n\t\tchanPointStr string\n\t)\n\targs := ctx.Args()\n\n\tswitch {\n\tcase ctx.IsSet(\"chan_point\"):\n\t\tchanPointStr = ctx.String(\"chan_point\")\n\n\tcase args.Present():\n\t\tchanPointStr = args.First()\n\n\tcase !ctx.IsSet(\"all\"):\n\t\treturn fmt.Errorf(\"must specify chan_point if --all isn't set\")\n\t}\n\n\tif chanPointStr != \"\" {\n\t\tchanPointRPC, err := parseChanPoint(chanPointStr)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to parse chan_point: %v\", err)\n\t\t}\n\n\t\tchanBackup, err := client.ExportChannelBackup(\n\t\t\tctxc, &lnrpc.ExportChannelBackupRequest{\n\t\t\t\tChanPoint: chanPointRPC,\n\t\t\t},\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\ttxid, err := chainhash.NewHash(\n\t\t\tchanPointRPC.GetFundingTxidBytes(),\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tchanPoint := wire.OutPoint{\n\t\t\tHash:  *txid,\n\t\t\tIndex: chanPointRPC.OutputIndex,\n\t\t}\n\n\t\tprintJSON(struct {\n\t\t\tChanPoint  string `json:\"chan_point\"`\n\t\t\tChanBackup []byte `json:\"chan_backup\"`\n\t\t}{\n\t\t\tChanPoint:  chanPoint.String(),\n\t\t\tChanBackup: chanBackup.ChanBackup,\n\t\t})\n\t\treturn nil\n\t}\n\n\tif !ctx.IsSet(\"all\") {\n\t\treturn fmt.Errorf(\"if a channel isn't specified, -all must be\")\n\t}\n\n\tchanBackup, err := client.ExportAllChannelBackups(\n\t\tctxc, &lnrpc.ChanBackupExportRequest{},\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif ctx.IsSet(\"output_file\") {\n\t\treturn ioutil.WriteFile(\n\t\t\tctx.String(\"output_file\"),\n\t\t\tchanBackup.MultiChanBackup.MultiChanBackup,\n\t\t\t0666,\n\t\t)\n\t}\n\n\t// TODO(roasbeef): support for export | restore ?\n\n\tvar chanPoints []string\n\tfor _, chanPoint := range chanBackup.MultiChanBackup.ChanPoints {\n\t\ttxid, err := chainhash.NewHash(chanPoint.GetFundingTxidBytes())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tchanPoints = append(chanPoints, wire.OutPoint{\n\t\t\tHash:  *txid,\n\t\t\tIndex: chanPoint.OutputIndex,\n\t\t}.String())\n\t}\n\n\tprintRespJSON(chanBackup)\n\n\treturn nil\n}\n\nvar verifyChanBackupCommand = cli.Command{\n\tName:      \"verifychanbackup\",\n\tCategory:  \"Channels\",\n\tUsage:     \"Verify an existing channel backup.\",\n\tArgsUsage: \"[--single_backup] [--multi_backup] [--multi_file]\",\n\tDescription: `\n    This command allows a user to verify an existing Single or Multi channel\n    backup for integrity. This is useful when a user has a backup, but is\n    unsure as to if it's valid or for the target node.\n\n    The command will accept backups in one of three forms:\n\n       * A single channel packed SCB, which can be obtained from\n\t exportchanbackup. This should be passed in hex encoded format.\n\n       * A packed multi-channel SCB, which couples several individual\n\t static channel backups in single blob.\n\n       * A file path which points to a packed multi-channel backup within a\n\t file, using the same format that lnd does in its channel.backup\n\t file.\n    `,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName: \"single_backup\",\n\t\t\tUsage: \"a hex encoded single channel backup obtained \" +\n\t\t\t\t\"from exportchanbackup\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName: \"multi_backup\",\n\t\t\tUsage: \"a hex encoded multi-channel backup obtained \" +\n\t\t\t\t\"from exportchanbackup\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:      \"multi_file\",\n\t\t\tUsage:     \"the path to a multi-channel back up file\",\n\t\t\tTakesFile: true,\n\t\t},\n\t},\n\tAction: actionDecorator(verifyChanBackup),\n}\n",
      "length": 3282,
      "tokens": 406,
      "embedding": []
    },
    {
      "slug": "func verifyChanBackup(ctx *cli.Context) error {",
      "content": "func verifyChanBackup(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\t// Show command help if no arguments provided\n\tif ctx.NArg() == 0 && ctx.NumFlags() == 0 {\n\t\tcli.ShowCommandHelp(ctx, \"verifychanbackup\")\n\t\treturn nil\n\t}\n\n\tbackups, err := parseChanBackups(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tverifyReq := lnrpc.ChanBackupSnapshot{}\n\n\tif backups.GetChanBackups() != nil {\n\t\tverifyReq.SingleChanBackups = backups.GetChanBackups()\n\t}\n\tif backups.GetMultiChanBackup() != nil {\n\t\tverifyReq.MultiChanBackup = &lnrpc.MultiChanBackup{\n\t\t\tMultiChanBackup: backups.GetMultiChanBackup(),\n\t\t}\n\t}\n\n\tresp, err := client.VerifyChanBackup(ctxc, &verifyReq)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(resp)\n\treturn nil\n}\n\nvar restoreChanBackupCommand = cli.Command{\n\tName:     \"restorechanbackup\",\n\tCategory: \"Channels\",\n\tUsage: \"Restore an existing single or multi-channel static channel \" +\n\t\t\"backup.\",\n\tArgsUsage: \"[--single_backup] [--multi_backup] [--multi_file=\",\n\tDescription: `\n\tAllows a user to restore a Static Channel Backup (SCB) that was\n\tobtained either via the exportchanbackup command, or from lnd's\n\tautomatically managed channel.backup file. This command should be used\n\tif a user is attempting to restore a channel due to data loss on a\n\trunning node restored with the same seed as the node that created the\n\tchannel. If successful, this command will allows the user to recover\n\tthe settled funds stored in the recovered channels.\n\n\tThe command will accept backups in one of three forms:\n\n\t   * A single channel packed SCB, which can be obtained from\n\t     exportchanbackup. This should be passed in hex encoded format.\n\n\t   * A packed multi-channel SCB, which couples several individual\n\t     static channel backups in single blob.\n\n\t   * A file path which points to a packed multi-channel backup within a\n\t     file, using the same format that lnd does in its channel.backup\n\t     file.\n\t`,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName: \"single_backup\",\n\t\t\tUsage: \"a hex encoded single channel backup obtained \" +\n\t\t\t\t\"from exportchanbackup\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName: \"multi_backup\",\n\t\t\tUsage: \"a hex encoded multi-channel backup obtained \" +\n\t\t\t\t\"from exportchanbackup\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:      \"multi_file\",\n\t\t\tUsage:     \"the path to a multi-channel back up file\",\n\t\t\tTakesFile: true,\n\t\t},\n\t},\n\tAction: actionDecorator(restoreChanBackup),\n}\n\n// errMissingChanBackup is an error returned when we attempt to parse a channel\n// backup from a CLI command and it is missing.\nvar errMissingChanBackup = errors.New(\"missing channel backup\")\n",
      "length": 2497,
      "tokens": 339,
      "embedding": []
    },
    {
      "slug": "func parseChanBackups(ctx *cli.Context) (*lnrpc.RestoreChanBackupRequest, error) {",
      "content": "func parseChanBackups(ctx *cli.Context) (*lnrpc.RestoreChanBackupRequest, error) {\n\tswitch {\n\tcase ctx.IsSet(\"single_backup\"):\n\t\tpackedBackup, err := hex.DecodeString(\n\t\t\tctx.String(\"single_backup\"),\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to decode single packed \"+\n\t\t\t\t\"backup: %v\", err)\n\t\t}\n\n\t\treturn &lnrpc.RestoreChanBackupRequest{\n\t\t\tBackup: &lnrpc.RestoreChanBackupRequest_ChanBackups{\n\t\t\t\tChanBackups: &lnrpc.ChannelBackups{\n\t\t\t\t\tChanBackups: []*lnrpc.ChannelBackup{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tChanBackup: packedBackup,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\n\tcase ctx.IsSet(\"multi_backup\"):\n\t\tpackedMulti, err := hex.DecodeString(\n\t\t\tctx.String(\"multi_backup\"),\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to decode multi packed \"+\n\t\t\t\t\"backup: %v\", err)\n\t\t}\n\n\t\treturn &lnrpc.RestoreChanBackupRequest{\n\t\t\tBackup: &lnrpc.RestoreChanBackupRequest_MultiChanBackup{\n\t\t\t\tMultiChanBackup: packedMulti,\n\t\t\t},\n\t\t}, nil\n\n\tcase ctx.IsSet(\"multi_file\"):\n\t\tpackedMulti, err := ioutil.ReadFile(ctx.String(\"multi_file\"))\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to decode multi packed \"+\n\t\t\t\t\"backup: %v\", err)\n\t\t}\n\n\t\treturn &lnrpc.RestoreChanBackupRequest{\n\t\t\tBackup: &lnrpc.RestoreChanBackupRequest_MultiChanBackup{\n\t\t\t\tMultiChanBackup: packedMulti,\n\t\t\t},\n\t\t}, nil\n\n\tdefault:\n\t\treturn nil, errMissingChanBackup\n\t}\n}\n",
      "length": 1204,
      "tokens": 116,
      "embedding": []
    },
    {
      "slug": "func restoreChanBackup(ctx *cli.Context) error {",
      "content": "func restoreChanBackup(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\t// Show command help if no arguments provided\n\tif ctx.NArg() == 0 && ctx.NumFlags() == 0 {\n\t\tcli.ShowCommandHelp(ctx, \"restorechanbackup\")\n\t\treturn nil\n\t}\n\n\tvar req lnrpc.RestoreChanBackupRequest\n\n\tbackups, err := parseChanBackups(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treq.Backup = backups.Backup\n\n\t_, err = client.RestoreChannelBackups(ctxc, &req)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to restore chan backups: %v\", err)\n\t}\n\n\treturn nil\n}\n",
      "length": 499,
      "tokens": 71,
      "embedding": []
    }
  ]
}