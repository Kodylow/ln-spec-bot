{
  "filepath": "../implementations/go/lnd/cmd/lncli/cmd_mission_control.go",
  "package": "main",
  "sections": [
    {
      "slug": "func getCfg(ctx *cli.Context) error {",
      "content": "func getCfg(ctx *cli.Context) error {\n\tctxc := getContext()\n\tconn := getClientConn(ctx, false)\n\tdefer conn.Close()\n\n\tclient := routerrpc.NewRouterClient(conn)\n\n\tresp, err := client.GetMissionControlConfig(\n\t\tctxc, &routerrpc.GetMissionControlConfigRequest{},\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(resp)\n\n\treturn nil\n}\n\nvar setCfgCommand = cli.Command{\n\tName:     \"setmccfg\",\n\tCategory: \"Mission Control\",\n\tUsage:    \"Set mission control's config.\",\n\tDescription: `\n        Update the config values being used by mission control to calculate the\n        probability that payment routes will succeed. The estimator type must be\n        provided to set estimator-related parameters.`,\n\tFlags: []cli.Flag{\n\t\t// General settings.\n\t\tcli.UintFlag{\n\t\t\tName: \"pmtnr\",\n\t\t\tUsage: \"the number of payments mission control \" +\n\t\t\t\t\"should store\",\n\t\t},\n\t\tcli.DurationFlag{\n\t\t\tName: \"failrelax\",\n\t\t\tUsage: \"the amount of time to wait after a failure \" +\n\t\t\t\t\"before raising failure amount\",\n\t\t},\n\t\t// Probability estimator.\n\t\tcli.StringFlag{\n\t\t\tName: \"estimator\",\n\t\t\tUsage: \"the probability estimator to use, choose \" +\n\t\t\t\t\"between 'apriori' or 'bimodal'\",\n\t\t},\n\t\t// Apriori config.\n\t\tcli.DurationFlag{\n\t\t\tName: \"apriorihalflife\",\n\t\t\tUsage: \"the amount of time taken to restore a node \" +\n\t\t\t\t\"or channel to 50% probability of success.\",\n\t\t},\n\t\tcli.Float64Flag{\n\t\t\tName: \"apriorihopprob\",\n\t\t\tUsage: \"the probability of success assigned \" +\n\t\t\t\t\"to hops that we have no information about\",\n\t\t},\n\t\tcli.Float64Flag{\n\t\t\tName: \"aprioriweight\",\n\t\t\tUsage: \"the degree to which mission control should \" +\n\t\t\t\t\"rely on historical results, expressed as \" +\n\t\t\t\t\"value in [0, 1]\",\n\t\t},\n\t\tcli.Float64Flag{\n\t\t\tName: \"aprioricapacityfraction\",\n\t\t\tUsage: \"the fraction of channels' capacities that is \" +\n\t\t\t\t\"considered liquid in pathfinding, a value \" +\n\t\t\t\t\"between [0.75-1.0]. a value of 1.0 disables \" +\n\t\t\t\t\"this feature.\",\n\t\t},\n\t\t// Bimodal config.\n\t\tcli.DurationFlag{\n\t\t\tName: \"bimodaldecaytime\",\n\t\t\tUsage: \"the time span after which we phase out \" +\n\t\t\t\t\"learnings from previous payment attempts\",\n\t\t},\n\t\tcli.Uint64Flag{\n\t\t\tName: \"bimodalscale\",\n\t\t\tUsage: \"controls the assumed channel liquidity \" +\n\t\t\t\t\"imbalance in the network, measured in msat. \" +\n\t\t\t\t\"a low value (compared to typical channel \" +\n\t\t\t\t\"capacity) anticipates unbalanced channels.\",\n\t\t},\n\t\tcli.Float64Flag{\n\t\t\tName: \"bimodalweight\",\n\t\t\tUsage: \"controls the degree to which the probability \" +\n\t\t\t\t\"estimator takes into account other channels \" +\n\t\t\t\t\"of a router\",\n\t\t},\n\t},\n\tAction: actionDecorator(setCfg),\n}\n",
      "length": 2445,
      "tokens": 326,
      "embedding": []
    },
    {
      "slug": "func setCfg(ctx *cli.Context) error {",
      "content": "func setCfg(ctx *cli.Context) error {\n\tctxc := getContext()\n\tconn := getClientConn(ctx, false)\n\tdefer conn.Close()\n\n\tclient := routerrpc.NewRouterClient(conn)\n\n\t// Fetch current mission control config which we update to create our\n\t// response.\n\tmcCfg, err := client.GetMissionControlConfig(\n\t\tctxc, &routerrpc.GetMissionControlConfigRequest{},\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// haveValue is a helper variable to determine if a flag has been set or\n\t// the help should be displayed.\n\tvar haveValue bool\n\n\t// Handle general mission control settings.\n\tif ctx.IsSet(\"pmtnr\") {\n\t\thaveValue = true\n\t\tmcCfg.Config.MaximumPaymentResults = uint32(ctx.Int(\"pmtnr\"))\n\t}\n\tif ctx.IsSet(\"failrelax\") {\n\t\thaveValue = true\n\t\tmcCfg.Config.MinimumFailureRelaxInterval = uint64(ctx.Duration(\n\t\t\t\"failrelax\",\n\t\t).Seconds())\n\t}\n\n\t// We switch between estimators and set corresponding configs. If\n\t// estimator is not set, we ignore the values.\n\tif ctx.IsSet(\"estimator\") {\n\t\tswitch ctx.String(\"estimator\") {\n\t\tcase routing.AprioriEstimatorName:\n\t\t\thaveValue = true\n\n\t\t\t// If we switch from another estimator, initialize with\n\t\t\t// default values.\n\t\t\tif mcCfg.Config.Model !=\n\t\t\t\trouterrpc.MissionControlConfig_APRIORI {\n\n\t\t\t\tdCfg := routing.DefaultAprioriConfig()\n\t\t\t\taParams := &routerrpc.AprioriParameters{\n\t\t\t\t\tHalfLifeSeconds: uint64(\n\t\t\t\t\t\tdCfg.PenaltyHalfLife.Seconds(),\n\t\t\t\t\t),\n\t\t\t\t\tHopProbability: dCfg.\n\t\t\t\t\t\tAprioriHopProbability,\n\t\t\t\t\tWeight:           dCfg.AprioriWeight,\n\t\t\t\t\tCapacityFraction: dCfg.CapacityFraction,\n\t\t\t\t}\n\n\t\t\t\t// We make sure the correct config is set.\n\t\t\t\tmcCfg.Config.EstimatorConfig =\n\t\t\t\t\t&routerrpc.MissionControlConfig_Apriori{\n\t\t\t\t\t\tApriori: aParams,\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\t// We update all values for the apriori estimator.\n\t\t\tmcCfg.Config.Model = routerrpc.\n\t\t\t\tMissionControlConfig_APRIORI\n\n\t\t\taCfg := mcCfg.Config.GetApriori()\n\t\t\tif ctx.IsSet(\"apriorihalflife\") {\n\t\t\t\taCfg.HalfLifeSeconds = uint64(ctx.Duration(\n\t\t\t\t\t\"apriorihalflife\",\n\t\t\t\t).Seconds())\n\t\t\t}\n\n\t\t\tif ctx.IsSet(\"apriorihopprob\") {\n\t\t\t\taCfg.HopProbability = ctx.Float64(\n\t\t\t\t\t\"apriorihopprob\",\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tif ctx.IsSet(\"aprioriweight\") {\n\t\t\t\taCfg.Weight = ctx.Float64(\"aprioriweight\")\n\t\t\t}\n\n\t\t\tif ctx.IsSet(\"aprioricapacityfraction\") {\n\t\t\t\taCfg.CapacityFraction =\n\t\t\t\t\tctx.Float64(\"aprioricapacityfraction\")\n\t\t\t}\n\n\t\tcase routing.BimodalEstimatorName:\n\t\t\thaveValue = true\n\n\t\t\t// If we switch from another estimator, initialize with\n\t\t\t// default values.\n\t\t\tif mcCfg.Config.Model !=\n\t\t\t\trouterrpc.MissionControlConfig_BIMODAL {\n\n\t\t\t\tdCfg := routing.DefaultBimodalConfig()\n\t\t\t\tbParams := &routerrpc.BimodalParameters{\n\t\t\t\t\tDecayTime: uint64(\n\t\t\t\t\t\tdCfg.BimodalDecayTime.Seconds(),\n\t\t\t\t\t),\n\t\t\t\t\tScaleMsat: uint64(\n\t\t\t\t\t\tdCfg.BimodalScaleMsat,\n\t\t\t\t\t),\n\t\t\t\t\tNodeWeight: dCfg.BimodalNodeWeight,\n\t\t\t\t}\n\n\t\t\t\t// We make sure the correct config is set.\n\t\t\t\tmcCfg.Config.EstimatorConfig =\n\t\t\t\t\t&routerrpc.MissionControlConfig_Bimodal{\n\t\t\t\t\t\tBimodal: bParams,\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\t// We update all values for the bimodal estimator.\n\t\t\tmcCfg.Config.Model = routerrpc.\n\t\t\t\tMissionControlConfig_BIMODAL\n\n\t\t\tbCfg := mcCfg.Config.GetBimodal()\n\t\t\tif ctx.IsSet(\"bimodaldecaytime\") {\n\t\t\t\tbCfg.DecayTime = uint64(ctx.Duration(\n\t\t\t\t\t\"bimodaldecaytime\",\n\t\t\t\t).Seconds())\n\t\t\t}\n\n\t\t\tif ctx.IsSet(\"bimodalscale\") {\n\t\t\t\tbCfg.ScaleMsat = ctx.Uint64(\"bimodalscale\")\n\t\t\t}\n\n\t\t\tif ctx.IsSet(\"bimodalweight\") {\n\t\t\t\tbCfg.NodeWeight = ctx.Float64(\n\t\t\t\t\t\"bimodalweight\",\n\t\t\t\t)\n\t\t\t}\n\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"unknown estimator %v\",\n\t\t\t\tctx.String(\"estimator\"))\n\t\t}\n\t}\n\n\tif !haveValue {\n\t\treturn cli.ShowCommandHelp(ctx, \"setmccfg\")\n\t}\n\n\t_, err = client.SetMissionControlConfig(\n\t\tctxc, &routerrpc.SetMissionControlConfigRequest{\n\t\t\tConfig: mcCfg.Config,\n\t\t},\n\t)\n\treturn err\n}\n\nvar queryMissionControlCommand = cli.Command{\n\tName:     \"querymc\",\n\tCategory: \"Mission Control\",\n\tUsage:    \"Query the internal mission control state.\",\n\tAction:   actionDecorator(queryMissionControl),\n}\n",
      "length": 3738,
      "tokens": 365,
      "embedding": []
    },
    {
      "slug": "func queryMissionControl(ctx *cli.Context) error {",
      "content": "func queryMissionControl(ctx *cli.Context) error {\n\tctxc := getContext()\n\tconn := getClientConn(ctx, false)\n\tdefer conn.Close()\n\n\tclient := routerrpc.NewRouterClient(conn)\n\n\treq := &routerrpc.QueryMissionControlRequest{}\n\tsnapshot, err := client.QueryMissionControl(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(snapshot)\n\n\treturn nil\n}\n\nvar queryProbCommand = cli.Command{\n\tName:      \"queryprob\",\n\tCategory:  \"Mission Control\",\n\tUsage:     \"Deprecated. Estimate a success probability.\",\n\tArgsUsage: \"from-node to-node amt\",\n\tAction:    actionDecorator(queryProb),\n\tHidden:    true,\n}\n",
      "length": 524,
      "tokens": 56,
      "embedding": []
    },
    {
      "slug": "func queryProb(ctx *cli.Context) error {",
      "content": "func queryProb(ctx *cli.Context) error {\n\tctxc := getContext()\n\targs := ctx.Args()\n\n\tif len(args) != 3 {\n\t\treturn cli.ShowCommandHelp(ctx, \"queryprob\")\n\t}\n\n\tfromNode, err := route.NewVertexFromStr(args.Get(0))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"invalid from node key: %v\", err)\n\t}\n\n\ttoNode, err := route.NewVertexFromStr(args.Get(1))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"invalid to node key: %v\", err)\n\t}\n\n\tamtSat, err := strconv.ParseUint(args.Get(2), 10, 64)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"invalid amt: %v\", err)\n\t}\n\n\tamtMsat := lnwire.NewMSatFromSatoshis(\n\t\tbtcutil.Amount(amtSat),\n\t)\n\n\tconn := getClientConn(ctx, false)\n\tdefer conn.Close()\n\n\tclient := routerrpc.NewRouterClient(conn)\n\n\treq := &routerrpc.QueryProbabilityRequest{\n\t\tFromNode: fromNode[:],\n\t\tToNode:   toNode[:],\n\t\tAmtMsat:  int64(amtMsat),\n\t}\n\n\tresponse, err := client.QueryProbability(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(response)\n\n\treturn nil\n}\n\nvar resetMissionControlCommand = cli.Command{\n\tName:     \"resetmc\",\n\tCategory: \"Mission Control\",\n\tUsage:    \"Reset internal mission control state.\",\n\tAction:   actionDecorator(resetMissionControl),\n}\n",
      "length": 1059,
      "tokens": 125,
      "embedding": []
    },
    {
      "slug": "func resetMissionControl(ctx *cli.Context) error {",
      "content": "func resetMissionControl(ctx *cli.Context) error {\n\tctxc := getContext()\n\tconn := getClientConn(ctx, false)\n\tdefer conn.Close()\n\n\tclient := routerrpc.NewRouterClient(conn)\n\n\treq := &routerrpc.ResetMissionControlRequest{}\n\t_, err := client.ResetMissionControl(ctxc, req)\n\treturn err\n}\n",
      "length": 223,
      "tokens": 23,
      "embedding": []
    }
  ]
}