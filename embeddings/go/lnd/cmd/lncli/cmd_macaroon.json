{
  "filepath": "../implementations/go/lnd/cmd/lncli/cmd_macaroon.go",
  "package": "main",
  "sections": [
    {
      "slug": "func bakeMacaroon(ctx *cli.Context) error {",
      "content": "func bakeMacaroon(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\t// Show command help if no arguments.\n\tif ctx.NArg() == 0 {\n\t\treturn cli.ShowCommandHelp(ctx, \"bakemacaroon\")\n\t}\n\targs := ctx.Args()\n\n\tvar (\n\t\tsavePath          string\n\t\trootKeyID         uint64\n\t\tparsedPermissions []*lnrpc.MacaroonPermission\n\t\terr               error\n\t)\n\n\tif ctx.String(\"save_to\") != \"\" {\n\t\tsavePath = lncfg.CleanAndExpandPath(ctx.String(\"save_to\"))\n\t}\n\n\tif ctx.IsSet(\"root_key_id\") {\n\t\trootKeyID = ctx.Uint64(\"root_key_id\")\n\t}\n\n\t// A command line argument can't be an empty string. So we'll check each\n\t// entry if it's a valid entity:action tuple. The content itself is\n\t// validated server side. We just make sure we can parse it correctly.\n\tfor _, permission := range args {\n\t\ttuple := strings.Split(permission, \":\")\n\t\tif len(tuple) != 2 {\n\t\t\treturn fmt.Errorf(\"unable to parse \"+\n\t\t\t\t\"permission tuple: %s\", permission)\n\t\t}\n\t\tentity, action := tuple[0], tuple[1]\n\t\tif entity == \"\" {\n\t\t\treturn fmt.Errorf(\"invalid permission [%s]. entity \"+\n\t\t\t\t\"cannot be empty\", permission)\n\t\t}\n\t\tif action == \"\" {\n\t\t\treturn fmt.Errorf(\"invalid permission [%s]. action \"+\n\t\t\t\t\"cannot be empty\", permission)\n\t\t}\n\n\t\t// No we can assume that we have a formally valid entity:action\n\t\t// tuple. The rest of the validation happens server side.\n\t\tparsedPermissions = append(\n\t\t\tparsedPermissions, &lnrpc.MacaroonPermission{\n\t\t\t\tEntity: entity,\n\t\t\t\tAction: action,\n\t\t\t},\n\t\t)\n\t}\n\n\t// Now we have gathered all the input we need and can do the actual\n\t// RPC call.\n\treq := &lnrpc.BakeMacaroonRequest{\n\t\tPermissions:              parsedPermissions,\n\t\tRootKeyId:                rootKeyID,\n\t\tAllowExternalPermissions: ctx.Bool(\"allow_external_permissions\"),\n\t}\n\tresp, err := client.BakeMacaroon(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Now we should have gotten a valid macaroon. Unmarshal it so we can\n\t// add first-party caveats (if necessary) to it.\n\tmacBytes, err := hex.DecodeString(resp.Macaroon)\n\tif err != nil {\n\t\treturn err\n\t}\n\tunmarshalMac := &macaroon.Macaroon{}\n\tif err = unmarshalMac.UnmarshalBinary(macBytes); err != nil {\n\t\treturn err\n\t}\n\n\t// Now apply the desired constraints to the macaroon. This will always\n\t// create a new macaroon object, even if no constraints are added.\n\tconstrainedMac, err := applyMacaroonConstraints(ctx, unmarshalMac)\n\tif err != nil {\n\t\treturn err\n\t}\n\tmacBytes, err = constrainedMac.MarshalBinary()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Now we can output the result. We either write it binary serialized to\n\t// a file or write to the standard output using hex encoding.\n\tswitch {\n\tcase savePath != \"\":\n\t\terr = ioutil.WriteFile(savePath, macBytes, 0644)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfmt.Printf(\"Macaroon saved to %s\\n\", savePath)\n\n\tdefault:\n\t\tfmt.Printf(\"%s\\n\", hex.EncodeToString(macBytes))\n\t}\n\n\treturn nil\n}\n\nvar listMacaroonIDsCommand = cli.Command{\n\tName:     \"listmacaroonids\",\n\tCategory: \"Macaroons\",\n\tUsage:    \"List all macaroons root key IDs in use.\",\n\tAction:   actionDecorator(listMacaroonIDs),\n}\n",
      "length": 2926,
      "tokens": 406,
      "embedding": []
    },
    {
      "slug": "func listMacaroonIDs(ctx *cli.Context) error {",
      "content": "func listMacaroonIDs(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\treq := &lnrpc.ListMacaroonIDsRequest{}\n\tresp, err := client.ListMacaroonIDs(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(resp)\n\treturn nil\n}\n\nvar deleteMacaroonIDCommand = cli.Command{\n\tName:      \"deletemacaroonid\",\n\tCategory:  \"Macaroons\",\n\tUsage:     \"Delete a specific macaroon ID.\",\n\tArgsUsage: \"root_key_id\",\n\tDescription: `\n\tRemove a macaroon ID using the specified root key ID. For example:\n\n\tlncli deletemacaroonid 1\n\n\tWARNING\n\tWhen the ID is deleted, all macaroons created from that root key will\n\tbe invalidated.\n\n\tNote that the default root key ID 0 cannot be deleted.\n\t`,\n\tAction: actionDecorator(deleteMacaroonID),\n}\n",
      "length": 690,
      "tokens": 93,
      "embedding": []
    },
    {
      "slug": "func deleteMacaroonID(ctx *cli.Context) error {",
      "content": "func deleteMacaroonID(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\t// Validate args length. Only one argument is allowed.\n\tif ctx.NArg() != 1 {\n\t\treturn cli.ShowCommandHelp(ctx, \"deletemacaroonid\")\n\t}\n\n\trootKeyIDString := ctx.Args().First()\n\n\t// Convert string into uint64.\n\trootKeyID, err := strconv.ParseUint(rootKeyIDString, 10, 64)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"root key ID must be a positive integer\")\n\t}\n\n\t// Check that the value is not equal to DefaultRootKeyID. Note that the\n\t// server also validates the root key ID when removing it. However, we check\n\t// it here too so that we can give users a nice warning.\n\tif bytes.Equal([]byte(rootKeyIDString), macaroons.DefaultRootKeyID) {\n\t\treturn fmt.Errorf(\"deleting the default root key ID 0 is not allowed\")\n\t}\n\n\t// Make the actual RPC call.\n\treq := &lnrpc.DeleteMacaroonIDRequest{\n\t\tRootKeyId: rootKeyID,\n\t}\n\tresp, err := client.DeleteMacaroonID(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(resp)\n\treturn nil\n}\n\nvar listPermissionsCommand = cli.Command{\n\tName:     \"listpermissions\",\n\tCategory: \"Macaroons\",\n\tUsage: \"Lists all RPC method URIs and the macaroon permissions they \" +\n\t\t\"require to be invoked.\",\n\tAction: actionDecorator(listPermissions),\n}\n",
      "length": 1199,
      "tokens": 169,
      "embedding": []
    },
    {
      "slug": "func listPermissions(ctx *cli.Context) error {",
      "content": "func listPermissions(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\trequest := &lnrpc.ListPermissionsRequest{}\n\tresponse, err := client.ListPermissions(ctxc, request)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(response)\n\n\treturn nil\n}\n",
      "length": 235,
      "tokens": 29,
      "embedding": []
    },
    {
      "slug": "type macaroonContent struct {",
      "content": "type macaroonContent struct {\n\tVersion     uint16   `json:\"version\"`\n\tLocation    string   `json:\"location\"`\n\tRootKeyID   string   `json:\"root_key_id\"`\n\tPermissions []string `json:\"permissions\"`\n\tCaveats     []string `json:\"caveats\"`\n}\n\nvar printMacaroonCommand = cli.Command{\n\tName:      \"printmacaroon\",\n\tCategory:  \"Macaroons\",\n\tUsage:     \"Print the content of a macaroon in a human readable format.\",\n\tArgsUsage: \"[macaroon_content_hex]\",\n\tDescription: `\n\tDecode a macaroon and show its content in a more human readable format.\n\tThe macaroon can either be passed as a hex encoded positional parameter\n\tor loaded from a file.\n\t`,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName: \"macaroon_file\",\n\t\t\tUsage: \"load the macaroon from a file instead of the \" +\n\t\t\t\t\"command line directly\",\n\t\t},\n\t},\n\tAction: actionDecorator(printMacaroon),\n}\n",
      "length": 783,
      "tokens": 96,
      "embedding": []
    },
    {
      "slug": "func printMacaroon(ctx *cli.Context) error {",
      "content": "func printMacaroon(ctx *cli.Context) error {\n\t// Show command help if no arguments or flags are set.\n\tif ctx.NArg() == 0 && ctx.NumFlags() == 0 {\n\t\treturn cli.ShowCommandHelp(ctx, \"printmacaroon\")\n\t}\n\n\tvar (\n\t\tmacBytes []byte\n\t\terr      error\n\t\targs     = ctx.Args()\n\t)\n\tswitch {\n\tcase ctx.IsSet(\"macaroon_file\"):\n\t\tmacPath := lncfg.CleanAndExpandPath(ctx.String(\"macaroon_file\"))\n\n\t\t// Load the specified macaroon file.\n\t\tmacBytes, err = ioutil.ReadFile(macPath)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to read macaroon path %v: %v\",\n\t\t\t\tmacPath, err)\n\t\t}\n\n\tcase args.Present():\n\t\tmacBytes, err = hex.DecodeString(args.First())\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to hex decode macaroon: %v\",\n\t\t\t\terr)\n\t\t}\n\n\tdefault:\n\t\treturn fmt.Errorf(\"macaroon parameter missing\")\n\t}\n\n\t// Decode the macaroon and its protobuf encoded internal identifier.\n\tmac := &macaroon.Macaroon{}\n\tif err = mac.UnmarshalBinary(macBytes); err != nil {\n\t\treturn fmt.Errorf(\"unable to decode macaroon: %v\", err)\n\t}\n\trawID := mac.Id()\n\tif rawID[0] != byte(bakery.LatestVersion) {\n\t\treturn fmt.Errorf(\"invalid macaroon version: %x\", rawID)\n\t}\n\tdecodedID := &lnrpc.MacaroonId{}\n\tidProto := rawID[1:]\n\terr = proto.Unmarshal(idProto, decodedID)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to decode macaroon version: %v\", err)\n\t}\n\n\t// Prepare everything to be printed in a more human readable format.\n\tcontent := &macaroonContent{\n\t\tVersion:     uint16(mac.Version()),\n\t\tLocation:    mac.Location(),\n\t\tRootKeyID:   string(decodedID.StorageId),\n\t\tPermissions: nil,\n\t\tCaveats:     nil,\n\t}\n\n\tfor _, caveat := range mac.Caveats() {\n\t\tcontent.Caveats = append(content.Caveats, string(caveat.Id))\n\t}\n\tfor _, op := range decodedID.Ops {\n\t\tfor _, action := range op.Actions {\n\t\t\tpermission := fmt.Sprintf(\"%s:%s\", op.Entity, action)\n\t\t\tcontent.Permissions = append(\n\t\t\t\tcontent.Permissions, permission,\n\t\t\t)\n\t\t}\n\t}\n\n\tprintJSON(content)\n\n\treturn nil\n}\n\nvar constrainMacaroonCommand = cli.Command{\n\tName:     \"constrainmacaroon\",\n\tCategory: \"Macaroons\",\n\tUsage:    \"Adds one or more restriction(s) to an existing macaroon\",\n\tArgsUsage: \"[--timeout=] [--ip_address=] [--custom_caveat_name= \" +\n\t\t\"[--custom_caveat_condition=]] input-macaroon-file \" +\n\t\t\"constrained-macaroon-file\",\n\tDescription: `\n\tAdd one or more first-party caveat(s) (a.k.a. constraints/restrictions)\n\tto an existing macaroon.\n\t`,\n\tFlags: []cli.Flag{\n\t\tmacTimeoutFlag,\n\t\tmacIPAddressFlag,\n\t\tmacCustomCaveatNameFlag,\n\t\tmacCustomCaveatConditionFlag,\n\t},\n\tAction: actionDecorator(constrainMacaroon),\n}\n",
      "length": 2405,
      "tokens": 284,
      "embedding": []
    },
    {
      "slug": "func constrainMacaroon(ctx *cli.Context) error {",
      "content": "func constrainMacaroon(ctx *cli.Context) error {\n\t// Show command help if not enough arguments.\n\tif ctx.NArg() != 2 {\n\t\treturn cli.ShowCommandHelp(ctx, \"constrainmacaroon\")\n\t}\n\targs := ctx.Args()\n\n\tsourceMacFile := lncfg.CleanAndExpandPath(args.First())\n\targs = args.Tail()\n\n\tsourceMacBytes, err := ioutil.ReadFile(sourceMacFile)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error trying to read source macaroon file \"+\n\t\t\t\"%s: %v\", sourceMacFile, err)\n\t}\n\n\tdestMacFile := lncfg.CleanAndExpandPath(args.First())\n\n\t// Now we should have gotten a valid macaroon. Unmarshal it so we can\n\t// add first-party caveats (if necessary) to it.\n\tsourceMac := &macaroon.Macaroon{}\n\tif err = sourceMac.UnmarshalBinary(sourceMacBytes); err != nil {\n\t\treturn fmt.Errorf(\"error unmarshaling source macaroon file \"+\n\t\t\t\"%s: %v\", sourceMacFile, err)\n\t}\n\n\t// Now apply the desired constraints to the macaroon. This will always\n\t// create a new macaroon object, even if no constraints are added.\n\tconstrainedMac, err := applyMacaroonConstraints(ctx, sourceMac)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdestMacBytes, err := constrainedMac.MarshalBinary()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error marshaling destination macaroon \"+\n\t\t\t\"file: %v\", err)\n\t}\n\n\t// Now we can output the result.\n\terr = ioutil.WriteFile(destMacFile, destMacBytes, 0644)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error writing destination macaroon file \"+\n\t\t\t\"%s: %v\", destMacFile, err)\n\t}\n\tfmt.Printf(\"Macaroon saved to %s\\n\", destMacFile)\n\n\treturn nil\n}\n\n// applyMacaroonConstraints parses and applies all currently supported macaroon\n// condition flags from the command line to the given macaroon and returns a new\n// macaroon instance.",
      "length": 1579,
      "tokens": 217,
      "embedding": []
    },
    {
      "slug": "func applyMacaroonConstraints(ctx *cli.Context,",
      "content": "func applyMacaroonConstraints(ctx *cli.Context,\n\tmac *macaroon.Macaroon) (*macaroon.Macaroon, error) {\n\n\tmacConstraints := make([]macaroons.Constraint, 0)\n\n\tif ctx.IsSet(macTimeoutFlag.Name) {\n\t\ttimeout := ctx.Int64(macTimeoutFlag.Name)\n\t\tif timeout <= 0 {\n\t\t\treturn nil, fmt.Errorf(\"timeout must be greater than 0\")\n\t\t}\n\t\tmacConstraints = append(\n\t\t\tmacConstraints, macaroons.TimeoutConstraint(timeout),\n\t\t)\n\t}\n\n\tif ctx.IsSet(macIPAddressFlag.Name) {\n\t\tipAddress := net.ParseIP(ctx.String(macIPAddressFlag.Name))\n\t\tif ipAddress == nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to parse ip_address: %s\",\n\t\t\t\tctx.String(\"ip_address\"))\n\t\t}\n\n\t\tmacConstraints = append(\n\t\t\tmacConstraints,\n\t\t\tmacaroons.IPLockConstraint(ipAddress.String()),\n\t\t)\n\t}\n\n\tif ctx.IsSet(macCustomCaveatNameFlag.Name) {\n\t\tcustomCaveatName := ctx.String(macCustomCaveatNameFlag.Name)\n\t\tif containsWhiteSpace(customCaveatName) {\n\t\t\treturn nil, fmt.Errorf(\"unexpected white space found \" +\n\t\t\t\t\"in custom caveat name\")\n\t\t}\n\t\tif customCaveatName == \"\" {\n\t\t\treturn nil, fmt.Errorf(\"invalid custom caveat name\")\n\t\t}\n\n\t\tvar customCaveatCond string\n\t\tif ctx.IsSet(macCustomCaveatConditionFlag.Name) {\n\t\t\tcustomCaveatCond = ctx.String(\n\t\t\t\tmacCustomCaveatConditionFlag.Name,\n\t\t\t)\n\t\t\tif containsWhiteSpace(customCaveatCond) {\n\t\t\t\treturn nil, fmt.Errorf(\"unexpected white \" +\n\t\t\t\t\t\"space found in custom caveat \" +\n\t\t\t\t\t\"condition\")\n\t\t\t}\n\t\t\tif customCaveatCond == \"\" {\n\t\t\t\treturn nil, fmt.Errorf(\"invalid custom \" +\n\t\t\t\t\t\"caveat condition\")\n\t\t\t}\n\t\t}\n\n\t\t// The custom caveat condition is optional, it could just be a\n\t\t// marker tag in the macaroon with just a name. The interceptor\n\t\t// itself doesn't care about the value anyway.\n\t\tmacConstraints = append(\n\t\t\tmacConstraints, macaroons.CustomConstraint(\n\t\t\t\tcustomCaveatName, customCaveatCond,\n\t\t\t),\n\t\t)\n\t}\n\n\tconstrainedMac, err := macaroons.AddConstraints(mac, macConstraints...)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error adding constraints: %v\", err)\n\t}\n\n\treturn constrainedMac, nil\n}\n\n// containsWhiteSpace returns true if the given string contains any character\n// that is considered to be a white space or non-printable character such as\n// space, tabulator, newline, carriage return and some more exotic ones.",
      "length": 2105,
      "tokens": 241,
      "embedding": []
    },
    {
      "slug": "func containsWhiteSpace(str string) bool {",
      "content": "func containsWhiteSpace(str string) bool {\n\treturn strings.IndexFunc(str, unicode.IsSpace) >= 0\n}\n",
      "length": 53,
      "tokens": 6,
      "embedding": []
    }
  ]
}