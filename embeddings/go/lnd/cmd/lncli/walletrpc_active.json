{
  "filepath": "../implementations/go/lnd/cmd/lncli/walletrpc_active.go",
  "package": "main",
  "sections": [
    {
      "slug": "//go:build walletrpc",
      "content": "//go:build walletrpc\n// +build walletrpc\n\npackage main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/base64\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"sort\"\n\n\t\"github.com/btcsuite/btcd/chaincfg/chainhash\"\n\t\"github.com/btcsuite/btcd/wire\"\n\t\"github.com/lightningnetwork/lnd/lnrpc\"\n\t\"github.com/lightningnetwork/lnd/lnrpc/walletrpc\"\n\t\"github.com/urfave/cli\"\n)\n\nvar (\n\t// psbtCommand is a wallet subcommand that is responsible for PSBT\n\t// operations.\n\tpsbtCommand = cli.Command{\n\t\tName: \"psbt\",\n\t\tUsage: \"Interact with partially signed bitcoin transactions \" +\n\t\t\t\"(PSBTs).\",\n\t\tSubcommands: []cli.Command{\n\t\t\tfundPsbtCommand,\n\t\t\tfinalizePsbtCommand,\n\t\t},\n\t}\n\n\t// accountsCommand is a wallet subcommand that is responsible for\n\t// account management operations.\n\taccountsCommand = cli.Command{\n\t\tName:  \"accounts\",\n\t\tUsage: \"Interact with wallet accounts.\",\n\t\tSubcommands: []cli.Command{\n\t\t\tlistAccountsCommand,\n\t\t\timportAccountCommand,\n\t\t\timportPubKeyCommand,\n\t\t},\n\t}\n\n\t// addressesCommand is a wallet subcommand that is responsible for\n\t// address management operations.\n\taddressesCommand = cli.Command{\n\t\tName:  \"addresses\",\n\t\tUsage: \"Interact with wallet addresses.\",\n\t\tSubcommands: []cli.Command{\n\t\t\tlistAddressesCommand,\n\t\t\tsignMessageWithAddrCommand,\n\t\t\tverifyMessageWithAddrCommand,\n\t\t},\n\t}\n)\n\n// walletCommands will return the set of commands to enable for walletrpc\n// builds.",
      "length": 1306,
      "tokens": 134,
      "embedding": []
    },
    {
      "slug": "func walletCommands() []cli.Command {",
      "content": "func walletCommands() []cli.Command {\n\treturn []cli.Command{\n\t\t{\n\t\t\tName:        \"wallet\",\n\t\t\tCategory:    \"Wallet\",\n\t\t\tUsage:       \"Interact with the wallet.\",\n\t\t\tDescription: \"\",\n\t\t\tSubcommands: []cli.Command{\n\t\t\t\tpendingSweepsCommand,\n\t\t\t\tbumpFeeCommand,\n\t\t\t\tbumpCloseFeeCommand,\n\t\t\t\tlistSweepsCommand,\n\t\t\t\tlabelTxCommand,\n\t\t\t\tpublishTxCommand,\n\t\t\t\treleaseOutputCommand,\n\t\t\t\tleaseOutputCommand,\n\t\t\t\tlistLeasesCommand,\n\t\t\t\tpsbtCommand,\n\t\t\t\taccountsCommand,\n\t\t\t\trequiredReserveCommand,\n\t\t\t\taddressesCommand,\n\t\t\t},\n\t\t},\n\t}\n}\n",
      "length": 464,
      "tokens": 33,
      "embedding": []
    },
    {
      "slug": "func parseAddrType(addrTypeStr string) (walletrpc.AddressType, error) {",
      "content": "func parseAddrType(addrTypeStr string) (walletrpc.AddressType, error) {\n\tswitch addrTypeStr {\n\tcase \"\":\n\t\treturn walletrpc.AddressType_UNKNOWN, nil\n\tcase \"p2wkh\":\n\t\treturn walletrpc.AddressType_WITNESS_PUBKEY_HASH, nil\n\tcase \"np2wkh\":\n\t\treturn walletrpc.AddressType_NESTED_WITNESS_PUBKEY_HASH, nil\n\tcase \"np2wkh-p2wkh\":\n\t\treturn walletrpc.AddressType_HYBRID_NESTED_WITNESS_PUBKEY_HASH, nil\n\tcase \"p2tr\":\n\t\treturn walletrpc.AddressType_TAPROOT_PUBKEY, nil\n\tdefault:\n\t\treturn 0, errors.New(\"invalid address type, supported address \" +\n\t\t\t\"types are: p2wkh, p2tr, np2wkh, and np2wkh-p2wkh\")\n\t}\n}\n",
      "length": 505,
      "tokens": 47,
      "embedding": []
    },
    {
      "slug": "func getWalletClient(ctx *cli.Context) (walletrpc.WalletKitClient, func()) {",
      "content": "func getWalletClient(ctx *cli.Context) (walletrpc.WalletKitClient, func()) {\n\tconn := getClientConn(ctx, false)\n\tcleanUp := func() {\n\t\tconn.Close()\n\t}\n\treturn walletrpc.NewWalletKitClient(conn), cleanUp\n}\n\nvar pendingSweepsCommand = cli.Command{\n\tName:      \"pendingsweeps\",\n\tUsage:     \"List all outputs that are pending to be swept within lnd.\",\n\tArgsUsage: \"\",\n\tDescription: `\n\tList all on-chain outputs that lnd is currently attempting to sweep\n\twithin its central batching engine. Outputs with similar fee rates are\n\tbatched together in order to sweep them within a single transaction.\n\t`,\n\tFlags:  []cli.Flag{},\n\tAction: actionDecorator(pendingSweeps),\n}\n",
      "length": 565,
      "tokens": 75,
      "embedding": []
    },
    {
      "slug": "func pendingSweeps(ctx *cli.Context) error {",
      "content": "func pendingSweeps(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getWalletClient(ctx)\n\tdefer cleanUp()\n\n\treq := &walletrpc.PendingSweepsRequest{}\n\tresp, err := client.PendingSweeps(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Sort them in ascending fee rate order for display purposes.\n\tsort.Slice(resp.PendingSweeps, func(i, j int) bool {\n\t\treturn resp.PendingSweeps[i].SatPerVbyte <\n\t\t\tresp.PendingSweeps[j].SatPerVbyte\n\t})\n\n\tvar pendingSweepsResp = struct {\n\t\tPendingSweeps []*PendingSweep `json:\"pending_sweeps\"`\n\t}{\n\t\tPendingSweeps: make([]*PendingSweep, 0, len(resp.PendingSweeps)),\n\t}\n\n\tfor _, protoPendingSweep := range resp.PendingSweeps {\n\t\tpendingSweep := NewPendingSweepFromProto(protoPendingSweep)\n\t\tpendingSweepsResp.PendingSweeps = append(\n\t\t\tpendingSweepsResp.PendingSweeps, pendingSweep,\n\t\t)\n\t}\n\n\tprintJSON(pendingSweepsResp)\n\n\treturn nil\n}\n\nvar bumpFeeCommand = cli.Command{\n\tName:      \"bumpfee\",\n\tUsage:     \"Bumps the fee of an arbitrary input/transaction.\",\n\tArgsUsage: \"outpoint\",\n\tDescription: `\n\tThis command takes a different approach than bitcoind's bumpfee command.\n\tlnd has a central batching engine in which inputs with similar fee rates\n\tare batched together to save on transaction fees. Due to this, we cannot\n\trely on bumping the fee on a specific transaction, since transactions\n\tcan change at any point with the addition of new inputs. The list of\n\tinputs that currently exist within lnd's central batching engine can be\n\tretrieved through lncli wallet pendingsweeps.\n\n\tWhen bumping the fee of an input that currently exists within lnd's\n\tcentral batching engine, a higher fee transaction will be created that\n\treplaces the lower fee transaction through the Replace-By-Fee (RBF)\n\tpolicy.\n\n\tThis command also serves useful when wanting to perform a\n\tChild-Pays-For-Parent (CPFP), where the child transaction pays for its\n\tparent's fee. This can be done by specifying an outpoint within the low\n\tfee transaction that is under the control of the wallet.\n\n\tA fee preference must be provided, either through the conf_target or\n\tsat_per_vbyte parameters.\n\n\tNote that this command currently doesn't perform any validation checks\n\ton the fee preference being provided. For now, the responsibility of\n\tensuring that the new fee preference is sufficient is delegated to the\n\tuser.\n\n\tThe force flag enables sweeping of inputs that are negatively yielding.\n\tNormally it does not make sense to lose money on sweeping, unless a\n\tparent transaction needs to get confirmed and there is only a small\n\toutput available to attach the child transaction to.\n\t`,\n\tFlags: []cli.Flag{\n\t\tcli.Uint64Flag{\n\t\t\tName: \"conf_target\",\n\t\t\tUsage: \"the number of blocks that the output should \" +\n\t\t\t\t\"be swept on-chain within\",\n\t\t},\n\t\tcli.Uint64Flag{\n\t\t\tName:   \"sat_per_byte\",\n\t\t\tUsage:  \"Deprecated, use sat_per_vbyte instead.\",\n\t\t\tHidden: true,\n\t\t},\n\t\tcli.Uint64Flag{\n\t\t\tName: \"sat_per_vbyte\",\n\t\t\tUsage: \"a manual fee expressed in sat/vbyte that \" +\n\t\t\t\t\"should be used when sweeping the output\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"force\",\n\t\t\tUsage: \"sweep even if the yield is negative\",\n\t\t},\n\t},\n\tAction: actionDecorator(bumpFee),\n}\n",
      "length": 3024,
      "tokens": 413,
      "embedding": []
    },
    {
      "slug": "func bumpFee(ctx *cli.Context) error {",
      "content": "func bumpFee(ctx *cli.Context) error {\n\tctxc := getContext()\n\n\t// Display the command's help message if we do not have the expected\n\t// number of arguments/flags.\n\tif ctx.NArg() != 1 {\n\t\treturn cli.ShowCommandHelp(ctx, \"bumpfee\")\n\t}\n\n\t// Check that only the field sat_per_vbyte or the deprecated field\n\t// sat_per_byte is used.\n\tfeeRateFlag, err := checkNotBothSet(\n\t\tctx, \"sat_per_vbyte\", \"sat_per_byte\",\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Validate and parse the relevant arguments/flags.\n\tprotoOutPoint, err := NewProtoOutPoint(ctx.Args().Get(0))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tclient, cleanUp := getWalletClient(ctx)\n\tdefer cleanUp()\n\n\tresp, err := client.BumpFee(ctxc, &walletrpc.BumpFeeRequest{\n\t\tOutpoint:    protoOutPoint,\n\t\tTargetConf:  uint32(ctx.Uint64(\"conf_target\")),\n\t\tSatPerVbyte: ctx.Uint64(feeRateFlag),\n\t\tForce:       ctx.Bool(\"force\"),\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(resp)\n\n\treturn nil\n}\n\nvar bumpCloseFeeCommand = cli.Command{\n\tName:      \"bumpclosefee\",\n\tUsage:     \"Bumps the fee of a channel closing transaction.\",\n\tArgsUsage: \"channel_point\",\n\tDescription: `\n\tThis command allows the fee of a channel closing transaction to be\n\tincreased by using the child-pays-for-parent mechanism. It will instruct\n\tthe sweeper to sweep the anchor outputs of transactions in the set\n\tof valid commitments for the specified channel at the requested fee\n\trate or confirmation target.\n\t`,\n\tFlags: []cli.Flag{\n\t\tcli.Uint64Flag{\n\t\t\tName: \"conf_target\",\n\t\t\tUsage: \"the number of blocks that the output should \" +\n\t\t\t\t\"be swept on-chain within\",\n\t\t},\n\t\tcli.Uint64Flag{\n\t\t\tName:   \"sat_per_byte\",\n\t\t\tUsage:  \"Deprecated, use sat_per_vbyte instead.\",\n\t\t\tHidden: true,\n\t\t},\n\t\tcli.Uint64Flag{\n\t\t\tName: \"sat_per_vbyte\",\n\t\t\tUsage: \"a manual fee expressed in sat/vbyte that \" +\n\t\t\t\t\"should be used when sweeping the output\",\n\t\t},\n\t},\n\tAction: actionDecorator(bumpCloseFee),\n}\n",
      "length": 1793,
      "tokens": 236,
      "embedding": []
    },
    {
      "slug": "func bumpCloseFee(ctx *cli.Context) error {",
      "content": "func bumpCloseFee(ctx *cli.Context) error {\n\tctxc := getContext()\n\n\t// Display the command's help message if we do not have the expected\n\t// number of arguments/flags.\n\tif ctx.NArg() != 1 {\n\t\treturn cli.ShowCommandHelp(ctx, \"bumpclosefee\")\n\t}\n\n\t// Check that only the field sat_per_vbyte or the deprecated field\n\t// sat_per_byte is used.\n\tfeeRateFlag, err := checkNotBothSet(\n\t\tctx, \"sat_per_vbyte\", \"sat_per_byte\",\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Validate the channel point.\n\tchannelPoint := ctx.Args().Get(0)\n\t_, err = NewProtoOutPoint(channelPoint)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Fetch all waiting close channels.\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\t// Fetch waiting close channel commitments.\n\tcommitments, err := getWaitingCloseCommitments(\n\t\tctxc, client, channelPoint,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Retrieve pending sweeps.\n\twalletClient, cleanUp := getWalletClient(ctx)\n\tdefer cleanUp()\n\n\tsweeps, err := walletClient.PendingSweeps(\n\t\tctxc, &walletrpc.PendingSweepsRequest{},\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Match pending sweeps with commitments of the channel for which a bump\n\t// is requested and bump their fees.\n\tcommitSet := map[string]struct{}{\n\t\tcommitments.LocalTxid:  {},\n\t\tcommitments.RemoteTxid: {},\n\t}\n\tif commitments.RemotePendingTxid != \"\" {\n\t\tcommitSet[commitments.RemotePendingTxid] = struct{}{}\n\t}\n\n\tfor _, sweep := range sweeps.PendingSweeps {\n\t\t// Only bump anchor sweeps.\n\t\tif sweep.WitnessType != walletrpc.WitnessType_COMMITMENT_ANCHOR {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Skip unrelated sweeps.\n\t\tsweepTxID, err := chainhash.NewHash(sweep.Outpoint.TxidBytes)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, match := commitSet[sweepTxID.String()]; !match {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Bump fee of the anchor sweep.\n\t\tfmt.Printf(\"Bumping fee of %v:%v\\n\",\n\t\t\tsweepTxID, sweep.Outpoint.OutputIndex)\n\n\t\t_, err = walletClient.BumpFee(ctxc, &walletrpc.BumpFeeRequest{\n\t\t\tOutpoint:    sweep.Outpoint,\n\t\t\tTargetConf:  uint32(ctx.Uint64(\"conf_target\")),\n\t\t\tSatPerVbyte: ctx.Uint64(feeRateFlag),\n\t\t\tForce:       true,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n",
      "length": 1994,
      "tokens": 259,
      "embedding": []
    },
    {
      "slug": "func getWaitingCloseCommitments(ctxc context.Context,",
      "content": "func getWaitingCloseCommitments(ctxc context.Context,\n\tclient lnrpc.LightningClient, channelPoint string) (\n\t*lnrpc.PendingChannelsResponse_Commitments, error) {\n\n\treq := &lnrpc.PendingChannelsRequest{}\n\tresp, err := client.PendingChannels(ctxc, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Lookup the channel commit tx hashes.\n\tfor _, channel := range resp.WaitingCloseChannels {\n\t\tif channel.Channel.ChannelPoint == channelPoint {\n\t\t\treturn channel.Commitments, nil\n\t\t}\n\t}\n\n\treturn nil, errors.New(\"channel not found\")\n}\n\nvar listSweepsCommand = cli.Command{\n\tName:  \"listsweeps\",\n\tUsage: \"Lists all sweeps that have been published by our node.\",\n\tFlags: []cli.Flag{\n\t\tcli.BoolFlag{\n\t\t\tName:  \"verbose\",\n\t\t\tUsage: \"lookup full transaction\",\n\t\t},\n\t},\n\tDescription: `\n\tGet a list of the hex-encoded transaction ids of every sweep that our\n\tnode has published. Note that these sweeps may not be confirmed on chain\n\tyet, as we store them on transaction broadcast, not confirmation.\n\n\tIf the verbose flag is set, the full set of transactions will be \n\treturned, otherwise only the sweep transaction ids will be returned. \n\t`,\n\tAction: actionDecorator(listSweeps),\n}\n",
      "length": 1074,
      "tokens": 148,
      "embedding": []
    },
    {
      "slug": "func listSweeps(ctx *cli.Context) error {",
      "content": "func listSweeps(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getWalletClient(ctx)\n\tdefer cleanUp()\n\n\tresp, err := client.ListSweeps(\n\t\tctxc, &walletrpc.ListSweepsRequest{\n\t\t\tVerbose: ctx.IsSet(\"verbose\"),\n\t\t},\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintJSON(resp)\n\n\treturn nil\n}\n\nvar labelTxCommand = cli.Command{\n\tName:      \"labeltx\",\n\tUsage:     \"Adds a label to a transaction.\",\n\tArgsUsage: \"txid label\",\n\tDescription: `\n\tAdd a label to a transaction. If the transaction already has a label, \n\tthis call will fail unless the overwrite option is set. The label is \n\tlimited to 500 characters. Note that multi word labels must be contained\n\tin quotation marks (\"\").\n\t`,\n\tFlags: []cli.Flag{\n\t\tcli.BoolFlag{\n\t\t\tName:  \"overwrite\",\n\t\t\tUsage: \"set to overwrite existing labels\",\n\t\t},\n\t},\n\tAction: actionDecorator(labelTransaction),\n}\n",
      "length": 777,
      "tokens": 108,
      "embedding": []
    },
    {
      "slug": "func labelTransaction(ctx *cli.Context) error {",
      "content": "func labelTransaction(ctx *cli.Context) error {\n\tctxc := getContext()\n\n\t// Display the command's help message if we do not have the expected\n\t// number of arguments/flags.\n\tif ctx.NArg() != 2 {\n\t\treturn cli.ShowCommandHelp(ctx, \"labeltx\")\n\t}\n\n\t// Get the transaction id and check that it is a valid hash.\n\ttxid := ctx.Args().Get(0)\n\thash, err := chainhash.NewHashFromStr(txid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlabel := ctx.Args().Get(1)\n\n\twalletClient, cleanUp := getWalletClient(ctx)\n\tdefer cleanUp()\n\n\t_, err = walletClient.LabelTransaction(\n\t\tctxc, &walletrpc.LabelTransactionRequest{\n\t\t\tTxid:      hash[:],\n\t\t\tLabel:     label,\n\t\t\tOverwrite: ctx.Bool(\"overwrite\"),\n\t\t},\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Printf(\"Transaction: %v labelled with: %v\\n\", txid, label)\n\n\treturn nil\n}\n\nvar publishTxCommand = cli.Command{\n\tName:      \"publishtx\",\n\tUsage:     \"Attempts to publish the passed transaction to the network.\",\n\tArgsUsage: \"tx_hex\",\n\tDescription: `\n\tPublish a hex-encoded raw transaction to the on-chain network. The \n\twallet will continually attempt to re-broadcast the transaction on start up, until it \n\tenters the chain. The label parameter is optional and limited to 500 characters. Note \n\tthat multi word labels must be contained in quotation marks (\"\").\n\t`,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName:  \"label\",\n\t\t\tUsage: \"(optional) transaction label\",\n\t\t},\n\t},\n\tAction: actionDecorator(publishTransaction),\n}\n",
      "length": 1336,
      "tokens": 181,
      "embedding": []
    },
    {
      "slug": "func publishTransaction(ctx *cli.Context) error {",
      "content": "func publishTransaction(ctx *cli.Context) error {\n\tctxc := getContext()\n\n\t// Display the command's help message if we do not have the expected\n\t// number of arguments/flags.\n\tif ctx.NArg() != 1 || ctx.NumFlags() > 1 {\n\t\treturn cli.ShowCommandHelp(ctx, \"publishtx\")\n\t}\n\n\twalletClient, cleanUp := getWalletClient(ctx)\n\tdefer cleanUp()\n\n\ttx, err := hex.DecodeString(ctx.Args().First())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Deserialize the transaction to get the transaction hash.\n\tmsgTx := &wire.MsgTx{}\n\ttxReader := bytes.NewReader(tx)\n\tif err := msgTx.Deserialize(txReader); err != nil {\n\t\treturn err\n\t}\n\n\treq := &walletrpc.Transaction{\n\t\tTxHex: tx,\n\t\tLabel: ctx.String(\"label\"),\n\t}\n\n\t_, err = walletClient.PublishTransaction(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintJSON(&struct {\n\t\tTXID string `json:\"txid\"`\n\t}{\n\t\tTXID: msgTx.TxHash().String(),\n\t})\n\n\treturn nil\n}\n\n// utxoLease contains JSON annotations for a lease on an unspent output.",
      "length": 857,
      "tokens": 122,
      "embedding": []
    },
    {
      "slug": "type utxoLease struct {",
      "content": "type utxoLease struct {\n\tID         string   `json:\"id\"`\n\tOutPoint   OutPoint `json:\"outpoint\"`\n\tExpiration uint64   `json:\"expiration\"`\n\tPkScript   []byte   `json:\"pk_script\"`\n\tValue      uint64   `json:\"value\"`\n}\n\n// fundPsbtResponse is a struct that contains JSON annotations for nice result\n// serialization.",
      "length": 280,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "type fundPsbtResponse struct {",
      "content": "type fundPsbtResponse struct {\n\tPsbt              string       `json:\"psbt\"`\n\tChangeOutputIndex int32        `json:\"change_output_index\"`\n\tLocks             []*utxoLease `json:\"locks\"`\n}\n\nvar fundPsbtCommand = cli.Command{\n\tName:  \"fund\",\n\tUsage: \"Fund a Partially Signed Bitcoin Transaction (PSBT).\",\n\tArgsUsage: \"[--template_psbt=T | [--outputs=O [--inputs=I]]] \" +\n\t\t\"[--conf_target=C | --sat_per_vbyte=S] [--change_type=A]\",\n\tDescription: `\n\tThe fund command creates a fully populated PSBT that contains enough\n\tinputs to fund the outputs specified in either the PSBT or the\n\t--outputs flag.\n\n\tIf there are no inputs specified in the template (or --inputs flag),\n\tcoin selection is performed automatically. If inputs are specified, the\n\twallet assumes that full coin selection happened externally and it will\n\tnot add any additional inputs to the PSBT. If the specified inputs\n\taren't enough to fund the outputs with the given fee rate, an error is\n\treturned.\n\n\tAfter either selecting or verifying the inputs, all input UTXOs are\n\tlocked with an internal app ID.\n\n\tThe 'outputs' flag decodes addresses and the amount to send respectively\n\tin the following JSON format:\n\n\t    --outputs='{\"ExampleAddr\": NumCoinsInSatoshis, \"SecondAddr\": Sats}'\n\n\tThe optional 'inputs' flag decodes a JSON list of UTXO outpoints as\n\treturned by the listunspent command for example:\n\n\t    --inputs='[\"<txid1>:<output-index1>\",\"<txid2>:<output-index2>\",...]\n\n\tThe optional '--change-type' flag permits to choose the address type\n\tfor the change for default accounts and single imported public keys.\n\tThe custom address type can only be p2tr at the moment (p2wkh will be\n\tused by default). No custom address type should be provided for custom\n\taccounts as we will always generate the change address using the coin\n\tselection key scope.\n\t`,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName: \"template_psbt\",\n\t\t\tUsage: \"the outputs to fund and optional inputs to \" +\n\t\t\t\t\"spend provided in the base64 PSBT format\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName: \"outputs\",\n\t\t\tUsage: \"a JSON compatible map of destination \" +\n\t\t\t\t\"addresses to amounts to send, must not \" +\n\t\t\t\t\"include a change address as that will be \" +\n\t\t\t\t\"added automatically by the wallet\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName: \"inputs\",\n\t\t\tUsage: \"an optional JSON compatible list of UTXO \" +\n\t\t\t\t\"outpoints to use as the PSBT's inputs\",\n\t\t},\n\t\tcli.Uint64Flag{\n\t\t\tName: \"conf_target\",\n\t\t\tUsage: \"the number of blocks that the transaction \" +\n\t\t\t\t\"should be confirmed on-chain within\",\n\t\t\tValue: 6,\n\t\t},\n\t\tcli.Uint64Flag{\n\t\t\tName: \"sat_per_vbyte\",\n\t\t\tUsage: \"a manual fee expressed in sat/vbyte that \" +\n\t\t\t\t\"should be used when creating the transaction\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName: \"account\",\n\t\t\tUsage: \"(optional) the name of the account to use to \" +\n\t\t\t\t\"create/fund the PSBT\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName: \"change_type\",\n\t\t\tUsage: \"(optional) the type of the change address to \" +\n\t\t\t\t\"use to create/fund the PSBT. If no address \" +\n\t\t\t\t\"type is provided, p2wpkh will be used for \" +\n\t\t\t\t\"default accounts and single imported public \" +\n\t\t\t\t\"keys. No custom address type should be \" +\n\t\t\t\t\"provided for custom accounts as we will \" +\n\t\t\t\t\"always use the coin selection key scope to \" +\n\t\t\t\t\"generate the change address\",\n\t\t},\n\t},\n\tAction: actionDecorator(fundPsbt),\n}\n",
      "length": 3190,
      "tokens": 464,
      "embedding": []
    },
    {
      "slug": "func fundPsbt(ctx *cli.Context) error {",
      "content": "func fundPsbt(ctx *cli.Context) error {\n\tctxc := getContext()\n\n\t// Display the command's help message if there aren't any flags\n\t// specified.\n\tif ctx.NumFlags() == 0 {\n\t\treturn cli.ShowCommandHelp(ctx, \"fund\")\n\t}\n\n\treq := &walletrpc.FundPsbtRequest{\n\t\tAccount: ctx.String(\"account\"),\n\t}\n\n\t// Parse template flags.\n\tswitch {\n\t// The PSBT flag is mutally exclusive with the outputs/inputs flags.\n\tcase ctx.IsSet(\"template_psbt\") &&\n\t\t(ctx.IsSet(\"inputs\") || ctx.IsSet(\"outputs\")):\n\n\t\treturn fmt.Errorf(\"cannot set template_psbt and inputs/\" +\n\t\t\t\"outputs flags at the same time\")\n\n\t// Use a pre-existing PSBT as the transaction template.\n\tcase len(ctx.String(\"template_psbt\")) > 0:\n\t\tpsbtBase64 := ctx.String(\"template_psbt\")\n\t\tpsbtBytes, err := base64.StdEncoding.DecodeString(psbtBase64)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treq.Template = &walletrpc.FundPsbtRequest_Psbt{\n\t\t\tPsbt: psbtBytes,\n\t\t}\n\n\t// The user manually specified outputs and/or inputs in JSON\n\t// format.\n\tcase len(ctx.String(\"outputs\")) > 0 || len(ctx.String(\"inputs\")) > 0:\n\t\tvar (\n\t\t\ttpl          = &walletrpc.TxTemplate{}\n\t\t\tamountToAddr map[string]uint64\n\t\t)\n\n\t\tif len(ctx.String(\"outputs\")) > 0 {\n\t\t\t// Parse the address to amount map as JSON now. At least one\n\t\t\t// entry must be present.\n\t\t\tjsonMap := []byte(ctx.String(\"outputs\"))\n\t\t\tif err := json.Unmarshal(jsonMap, &amountToAddr); err != nil {\n\t\t\t\treturn fmt.Errorf(\"error parsing outputs JSON: %v\",\n\t\t\t\t\terr)\n\t\t\t}\n\t\t\ttpl.Outputs = amountToAddr\n\t\t}\n\n\t\t// Inputs are optional.\n\t\tif len(ctx.String(\"inputs\")) > 0 {\n\t\t\tvar inputs []string\n\n\t\t\tjsonList := []byte(ctx.String(\"inputs\"))\n\t\t\tif err := json.Unmarshal(jsonList, &inputs); err != nil {\n\t\t\t\treturn fmt.Errorf(\"error parsing inputs JSON: \"+\n\t\t\t\t\t\"%v\", err)\n\t\t\t}\n\n\t\t\tfor idx, input := range inputs {\n\t\t\t\top, err := NewProtoOutPoint(input)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"error parsing \"+\n\t\t\t\t\t\t\"UTXO outpoint %d: %v\", idx,\n\t\t\t\t\t\terr)\n\t\t\t\t}\n\t\t\t\ttpl.Inputs = append(tpl.Inputs, op)\n\t\t\t}\n\t\t}\n\n\t\treq.Template = &walletrpc.FundPsbtRequest_Raw{\n\t\t\tRaw: tpl,\n\t\t}\n\n\tdefault:\n\t\treturn fmt.Errorf(\"must specify either template_psbt or \" +\n\t\t\t\"inputs/outputs flag\")\n\t}\n\n\t// Parse fee flags.\n\tswitch {\n\tcase ctx.IsSet(\"conf_target\") && ctx.IsSet(\"sat_per_vbyte\"):\n\t\treturn fmt.Errorf(\"cannot set conf_target and sat_per_vbyte \" +\n\t\t\t\"at the same time\")\n\n\tcase ctx.Uint64(\"sat_per_vbyte\") > 0:\n\t\treq.Fees = &walletrpc.FundPsbtRequest_SatPerVbyte{\n\t\t\tSatPerVbyte: ctx.Uint64(\"sat_per_vbyte\"),\n\t\t}\n\n\t// Check conf_target last because it has a default value.\n\tcase ctx.Uint64(\"conf_target\") > 0:\n\t\treq.Fees = &walletrpc.FundPsbtRequest_TargetConf{\n\t\t\tTargetConf: uint32(ctx.Uint64(\"conf_target\")),\n\t\t}\n\t}\n\n\tif ctx.IsSet(\"change_type\") {\n\t\tswitch addressType := ctx.String(\"change_type\"); addressType {\n\t\tcase \"p2tr\":\n\t\t\t//nolint:lll\n\t\t\treq.ChangeType = walletrpc.ChangeAddressType_CHANGE_ADDRESS_TYPE_P2TR\n\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"invalid type for the \"+\n\t\t\t\t\"change type: %s. At the moment, the \"+\n\t\t\t\t\"only address type supported is p2tr \"+\n\t\t\t\t\"(default to p2wkh)\",\n\t\t\t\taddressType)\n\t\t}\n\t}\n\n\twalletClient, cleanUp := getWalletClient(ctx)\n\tdefer cleanUp()\n\n\tresponse, err := walletClient.FundPsbt(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tjsonLocks := marshallLocks(response.LockedUtxos)\n\n\tprintJSON(&fundPsbtResponse{\n\t\tPsbt: base64.StdEncoding.EncodeToString(\n\t\t\tresponse.FundedPsbt,\n\t\t),\n\t\tChangeOutputIndex: response.ChangeOutputIndex,\n\t\tLocks:             jsonLocks,\n\t})\n\n\treturn nil\n}\n\n// marshallLocks converts the rpc lease information to a more json-friendly\n// format.",
      "length": 3397,
      "tokens": 404,
      "embedding": []
    },
    {
      "slug": "func marshallLocks(lockedUtxos []*walletrpc.UtxoLease) []*utxoLease {",
      "content": "func marshallLocks(lockedUtxos []*walletrpc.UtxoLease) []*utxoLease {\n\tjsonLocks := make([]*utxoLease, len(lockedUtxos))\n\tfor idx, lock := range lockedUtxos {\n\t\tjsonLocks[idx] = &utxoLease{\n\t\t\tID:         hex.EncodeToString(lock.Id),\n\t\t\tOutPoint:   NewOutPointFromProto(lock.Outpoint),\n\t\t\tExpiration: lock.Expiration,\n\t\t\tPkScript:   lock.PkScript,\n\t\t\tValue:      lock.Value,\n\t\t}\n\t}\n\n\treturn jsonLocks\n}\n\n// finalizePsbtResponse is a struct that contains JSON annotations for nice\n// result serialization.",
      "length": 419,
      "tokens": 43,
      "embedding": []
    },
    {
      "slug": "type finalizePsbtResponse struct {",
      "content": "type finalizePsbtResponse struct {\n\tPsbt    string `json:\"psbt\"`\n\tFinalTx string `json:\"final_tx\"`\n}\n\nvar finalizePsbtCommand = cli.Command{\n\tName:      \"finalize\",\n\tUsage:     \"Finalize a Partially Signed Bitcoin Transaction (PSBT).\",\n\tArgsUsage: \"funded_psbt\",\n\tDescription: `\n\tThe finalize command expects a partial transaction with all inputs\n\tand outputs fully declared and tries to sign all inputs that belong to\n\tthe wallet. Lnd must be the last signer of the transaction. That means,\n\tif there are any unsigned non-witness inputs or inputs without UTXO\n\tinformation attached or inputs without witness data that do not belong\n\tto lnd's wallet, this method will fail. If no error is returned, the\n\tPSBT is ready to be extracted and the final TX within to be broadcast.\n\n\tThis method does NOT publish the transaction after it's been finalized\n\tsuccessfully.\n\t`,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName:  \"funded_psbt\",\n\t\t\tUsage: \"the base64 encoded PSBT to finalize\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName: \"account\",\n\t\t\tUsage: \"(optional) the name of the account to \" +\n\t\t\t\t\"finalize the PSBT with\",\n\t\t},\n\t},\n\tAction: actionDecorator(finalizePsbt),\n}\n",
      "length": 1088,
      "tokens": 158,
      "embedding": []
    },
    {
      "slug": "func finalizePsbt(ctx *cli.Context) error {",
      "content": "func finalizePsbt(ctx *cli.Context) error {\n\tctxc := getContext()\n\n\t// Display the command's help message if we do not have the expected\n\t// number of arguments/flags.\n\tif ctx.NArg() > 1 || ctx.NumFlags() > 2 {\n\t\treturn cli.ShowCommandHelp(ctx, \"finalize\")\n\t}\n\n\tvar (\n\t\targs       = ctx.Args()\n\t\tpsbtBase64 string\n\t)\n\tswitch {\n\tcase ctx.IsSet(\"funded_psbt\"):\n\t\tpsbtBase64 = ctx.String(\"funded_psbt\")\n\tcase args.Present():\n\t\tpsbtBase64 = args.First()\n\tdefault:\n\t\treturn fmt.Errorf(\"funded_psbt argument missing\")\n\t}\n\n\tpsbtBytes, err := base64.StdEncoding.DecodeString(psbtBase64)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq := &walletrpc.FinalizePsbtRequest{\n\t\tFundedPsbt: psbtBytes,\n\t\tAccount:    ctx.String(\"account\"),\n\t}\n\n\twalletClient, cleanUp := getWalletClient(ctx)\n\tdefer cleanUp()\n\n\tresponse, err := walletClient.FinalizePsbt(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintJSON(&finalizePsbtResponse{\n\t\tPsbt:    base64.StdEncoding.EncodeToString(response.SignedPsbt),\n\t\tFinalTx: hex.EncodeToString(response.RawFinalTx),\n\t})\n\n\treturn nil\n}\n\nvar leaseOutputCommand = cli.Command{\n\tName:  \"leaseoutput\",\n\tUsage: \"Lease an output.\",\n\tDescription: `\n\tThe leaseoutput command locks an output, making it unavailable\n\tfor coin selection.\n\n\tAn app lock ID and expiration duration must be specified when locking\n\tthe output.\n\t`,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName:  \"outpoint\",\n\t\t\tUsage: \"the output to lock\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"lockid\",\n\t\t\tUsage: \"the hex-encoded app lock ID\",\n\t\t},\n\t\tcli.Uint64Flag{\n\t\t\tName:  \"expiry\",\n\t\t\tUsage: \"expiration duration in seconds\",\n\t\t},\n\t},\n\tAction: actionDecorator(leaseOutput),\n}\n",
      "length": 1521,
      "tokens": 180,
      "embedding": []
    },
    {
      "slug": "func leaseOutput(ctx *cli.Context) error {",
      "content": "func leaseOutput(ctx *cli.Context) error {\n\tctxc := getContext()\n\n\t// Display the command's help message if we do not have the expected\n\t// number of arguments/flags.\n\tif ctx.NArg() != 0 || ctx.NumFlags() == 0 {\n\t\treturn cli.ShowCommandHelp(ctx, \"leaseoutput\")\n\t}\n\n\toutpointStr := ctx.String(\"outpoint\")\n\toutpoint, err := NewProtoOutPoint(outpointStr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error parsing outpoint: %v\", err)\n\t}\n\n\tlockIDStr := ctx.String(\"lockid\")\n\tif lockIDStr == \"\" {\n\t\treturn errors.New(\"lockid not specified\")\n\t}\n\tlockID, err := hex.DecodeString(lockIDStr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error parsing lockid: %v\", err)\n\t}\n\n\texpiry := ctx.Uint64(\"expiry\")\n\tif expiry == 0 {\n\t\treturn errors.New(\"expiry not specified or invalid\")\n\t}\n\n\treq := &walletrpc.LeaseOutputRequest{\n\t\tOutpoint:          outpoint,\n\t\tId:                lockID,\n\t\tExpirationSeconds: expiry,\n\t}\n\n\twalletClient, cleanUp := getWalletClient(ctx)\n\tdefer cleanUp()\n\n\tresponse, err := walletClient.LeaseOutput(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(response)\n\n\treturn nil\n}\n\nvar releaseOutputCommand = cli.Command{\n\tName:      \"releaseoutput\",\n\tUsage:     \"Release an output previously locked by lnd.\",\n\tArgsUsage: \"outpoint\",\n\tDescription: `\n\tThe releaseoutput command unlocks an output, allowing it to be available\n\tfor coin selection if it remains unspent.\n\n\tIf no lock ID is specified, the internal lnd app lock ID is used when\n\treleasing the output. With the internal ID, only UTXOs locked by the\n\tfundpsbt command can be released.\n\t`,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName:  \"outpoint\",\n\t\t\tUsage: \"the output to unlock\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"lockid\",\n\t\t\tUsage: \"the hex-encoded app lock ID\",\n\t\t},\n\t},\n\tAction: actionDecorator(releaseOutput),\n}\n",
      "length": 1667,
      "tokens": 223,
      "embedding": []
    },
    {
      "slug": "func releaseOutput(ctx *cli.Context) error {",
      "content": "func releaseOutput(ctx *cli.Context) error {\n\tctxc := getContext()\n\n\t// Display the command's help message if we do not have the expected\n\t// number of arguments/flags.\n\tif ctx.NArg() != 1 && ctx.NumFlags() != 1 {\n\t\treturn cli.ShowCommandHelp(ctx, \"releaseoutput\")\n\t}\n\n\tvar (\n\t\targs        = ctx.Args()\n\t\toutpointStr string\n\t)\n\tswitch {\n\tcase ctx.IsSet(\"outpoint\"):\n\t\toutpointStr = ctx.String(\"outpoint\")\n\tcase args.Present():\n\t\toutpointStr = args.First()\n\tdefault:\n\t\treturn fmt.Errorf(\"outpoint argument missing\")\n\t}\n\n\toutpoint, err := NewProtoOutPoint(outpointStr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error parsing outpoint: %v\", err)\n\t}\n\n\tlockID := walletrpc.LndInternalLockID[:]\n\tlockIDStr := ctx.String(\"lockid\")\n\tif lockIDStr != \"\" {\n\t\tvar err error\n\t\tlockID, err = hex.DecodeString(lockIDStr)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error parsing lockid: %v\", err)\n\t\t}\n\t}\n\n\treq := &walletrpc.ReleaseOutputRequest{\n\t\tOutpoint: outpoint,\n\t\tId:       lockID,\n\t}\n\n\twalletClient, cleanUp := getWalletClient(ctx)\n\tdefer cleanUp()\n\n\tresponse, err := walletClient.ReleaseOutput(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(response)\n\n\treturn nil\n}\n\nvar listLeasesCommand = cli.Command{\n\tName:   \"listleases\",\n\tUsage:  \"Return a list of currently held leases.\",\n\tAction: actionDecorator(listLeases),\n}\n",
      "length": 1213,
      "tokens": 154,
      "embedding": []
    },
    {
      "slug": "func listLeases(ctx *cli.Context) error {",
      "content": "func listLeases(ctx *cli.Context) error {\n\tctxc := getContext()\n\n\twalletClient, cleanUp := getWalletClient(ctx)\n\tdefer cleanUp()\n\n\treq := &walletrpc.ListLeasesRequest{}\n\tresponse, err := walletClient.ListLeases(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintJSON(marshallLocks(response.LockedUtxos))\n\treturn nil\n}\n\nvar listAccountsCommand = cli.Command{\n\tName:  \"list\",\n\tUsage: \"Retrieve information of existing on-chain wallet accounts.\",\n\tDescription: `\n\tRetrieves all accounts belonging to the wallet by default. A name and\n\tkey scope filter can be provided to filter through all of the wallet\n\taccounts and return only those matching.\n\t`,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName: \"name\",\n\t\t\tUsage: \"(optional) only accounts matching this name \" +\n\t\t\t\t\"are returned\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName: \"address_type\",\n\t\t\tUsage: \"(optional) only accounts matching this \" +\n\t\t\t\t\"address type are returned\",\n\t\t},\n\t},\n\tAction: actionDecorator(listAccounts),\n}\n",
      "length": 888,
      "tokens": 114,
      "embedding": []
    },
    {
      "slug": "func listAccounts(ctx *cli.Context) error {",
      "content": "func listAccounts(ctx *cli.Context) error {\n\tctxc := getContext()\n\n\t// Display the command's help message if we do not have the expected\n\t// number of arguments/flags.\n\tif ctx.NArg() > 0 || ctx.NumFlags() > 2 {\n\t\treturn cli.ShowCommandHelp(ctx, \"list\")\n\t}\n\n\taddrType, err := parseAddrType(ctx.String(\"address_type\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\twalletClient, cleanUp := getWalletClient(ctx)\n\tdefer cleanUp()\n\n\treq := &walletrpc.ListAccountsRequest{\n\t\tName:        ctx.String(\"name\"),\n\t\tAddressType: addrType,\n\t}\n\tresp, err := walletClient.ListAccounts(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(resp)\n\n\treturn nil\n}\n\nvar requiredReserveCommand = cli.Command{\n\tName:  \"requiredreserve\",\n\tUsage: \"Returns the wallet reserve.\",\n\tDescription: `\n\tReturns the minimum amount of satoshis that should be kept in the\n\twallet in order to fee bump anchor channels if necessary. The value\n\tscales with the number of public anchor channels but is\tcapped at\n\ta maximum.\n\n\tUse the flag --additional_channels to get the reserve value based\n\ton the additional channels you would like to open.\n\t`,\n\tFlags: []cli.Flag{\n\t\tcli.Uint64Flag{\n\t\t\tName: \"additional_channels\",\n\t\t\tUsage: \"(optional) specify the additional public channels \" +\n\t\t\t\t\"that you would like to open\",\n\t\t},\n\t},\n\tAction: actionDecorator(requiredReserve),\n}\n",
      "length": 1233,
      "tokens": 172,
      "embedding": []
    },
    {
      "slug": "func requiredReserve(ctx *cli.Context) error {",
      "content": "func requiredReserve(ctx *cli.Context) error {\n\tctxc := getContext()\n\n\t// Display the command's help message if we do not have the expected\n\t// number of arguments/flags.\n\tif ctx.NArg() > 0 || ctx.NumFlags() > 1 {\n\t\treturn cli.ShowCommandHelp(ctx, \"requiredreserve\")\n\t}\n\n\twalletClient, cleanUp := getWalletClient(ctx)\n\tdefer cleanUp()\n\n\treq := &walletrpc.RequiredReserveRequest{\n\t\tAdditionalPublicChannels: uint32(ctx.Uint64(\"additional_channels\")),\n\t}\n\tresp, err := walletClient.RequiredReserve(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(resp)\n\n\treturn nil\n}\n\nvar listAddressesCommand = cli.Command{\n\tName:  \"list\",\n\tUsage: \"Retrieve information of existing on-chain wallet addresses.\",\n\tDescription: `\n\tRetrieves information of existing on-chain wallet addresses along with\n\ttheir type, internal/external and balance.\n\t`,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName: \"account_name\",\n\t\t\tUsage: \"(optional) only addreses matching this account \" +\n\t\t\t\t\"are returned\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName: \"show_custom_accounts\",\n\t\t\tUsage: \"(optional) set this to true to show lnd's \" +\n\t\t\t\t\"custom accounts\",\n\t\t},\n\t},\n\tAction: actionDecorator(listAddresses),\n}\n",
      "length": 1080,
      "tokens": 131,
      "embedding": []
    },
    {
      "slug": "func listAddresses(ctx *cli.Context) error {",
      "content": "func listAddresses(ctx *cli.Context) error {\n\tctxc := getContext()\n\n\t// Display the command's help message if we do not have the expected\n\t// number of arguments/flags.\n\tif ctx.NArg() > 0 || ctx.NumFlags() > 2 {\n\t\treturn cli.ShowCommandHelp(ctx, \"list\")\n\t}\n\n\twalletClient, cleanUp := getWalletClient(ctx)\n\tdefer cleanUp()\n\n\treq := &walletrpc.ListAddressesRequest{\n\t\tAccountName:        ctx.String(\"account_name\"),\n\t\tShowCustomAccounts: ctx.Bool(\"show_custom_accounts\"),\n\t}\n\tresp, err := walletClient.ListAddresses(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(resp)\n\n\treturn nil\n}\n\nvar signMessageWithAddrCommand = cli.Command{\n\tName: \"signmessage\",\n\tUsage: \"Sign a message with the private key of the provided \" +\n\t\t\"address.\",\n\tArgsUsage: \"address msg\",\n\tDescription: `\n\tSign a message with the private key of the specified address, and\n\treturn the signature. Signing is solely done in the ECDSA compact\n\tsignature format. This is also done when signing with a P2TR address\n\tmeaning that the private key of the P2TR address (internal key) is used\n\tto sign the provided message with the ECDSA format. Only addresses are\n\taccepted which are owned by the internal lnd wallet.\n\t`,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName: \"address\",\n\t\t\tUsage: \"specify the address which private key \" +\n\t\t\t\t\"will be used to sign the message\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"msg\",\n\t\t\tUsage: \"the message to sign for\",\n\t\t},\n\t},\n\tAction: actionDecorator(signMessageWithAddr),\n}\n",
      "length": 1383,
      "tokens": 195,
      "embedding": []
    },
    {
      "slug": "func signMessageWithAddr(ctx *cli.Context) error {",
      "content": "func signMessageWithAddr(ctx *cli.Context) error {\n\tctxc := getContext()\n\n\t// Display the command's help message if we do not have the expected\n\t// number of arguments/flags.\n\tif ctx.NArg() > 2 || ctx.NumFlags() > 2 {\n\t\treturn cli.ShowCommandHelp(ctx, \"signmessagewithaddr\")\n\t}\n\n\twalletClient, cleanUp := getWalletClient(ctx)\n\tdefer cleanUp()\n\n\tvar (\n\t\targs = ctx.Args()\n\t\taddr string\n\t\tmsg  []byte\n\t)\n\n\tswitch {\n\tcase ctx.IsSet(\"address\"):\n\t\taddr = ctx.String(\"address\")\n\n\tcase ctx.Args().Present():\n\t\taddr = args.First()\n\t\targs = args.Tail()\n\n\tdefault:\n\t\treturn fmt.Errorf(\"address argument missing\")\n\t}\n\n\tswitch {\n\tcase ctx.IsSet(\"msg\"):\n\t\tmsg = []byte(ctx.String(\"msg\"))\n\n\tcase ctx.Args().Present():\n\t\tmsg = []byte(args.First())\n\t\targs = args.Tail()\n\n\tdefault:\n\t\treturn fmt.Errorf(\"msg argument missing\")\n\t}\n\n\tresp, err := walletClient.SignMessageWithAddr(\n\t\tctxc,\n\t\t&walletrpc.SignMessageWithAddrRequest{\n\t\t\tMsg:  msg,\n\t\t\tAddr: addr,\n\t\t},\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(resp)\n\n\treturn nil\n}\n\nvar verifyMessageWithAddrCommand = cli.Command{\n\tName: \"verifymessage\",\n\tUsage: \"Verify a message signed with the private key of the \" +\n\t\t\"provided address.\",\n\tArgsUsage: \"address sig msg\",\n\tDescription: `\n\tVerify a message signed with the signature of the public key\n\tof the provided address. The signature must be in compact ECDSA format\n\tThe verification is independent whether the address belongs to the\n\twallet or not. This is achieved by only accepting ECDSA compacted\n\tsignatures. When verifying a signature with a taproot address, the\n\tsignature still has to be in the ECDSA compact format and no tapscript\n\thas to be included in the P2TR address.\n\tSupports address types P2PKH, P2WKH, NP2WKH, P2TR.\n\n\tBesides whether the signature is valid or not, the recoverd public key\n\tof the compact ECDSA signature is returned.\n\t`,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName: \"address\",\n\t\t\tUsage: \"specify the address which corresponding\" +\n\t\t\t\t\"public key will be used\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName: \"sig\",\n\t\t\tUsage: \"the base64 encoded compact signature \" +\n\t\t\t\t\"of the message\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"msg\",\n\t\t\tUsage: \"the message to sign\",\n\t\t},\n\t},\n\tAction: actionDecorator(verifyMessageWithAddr),\n}\n",
      "length": 2094,
      "tokens": 290,
      "embedding": []
    },
    {
      "slug": "func verifyMessageWithAddr(ctx *cli.Context) error {",
      "content": "func verifyMessageWithAddr(ctx *cli.Context) error {\n\tctxc := getContext()\n\n\t// Display the command's help message if we do not have the expected\n\t// number of arguments/flags.\n\tif ctx.NArg() > 3 || ctx.NumFlags() > 3 {\n\t\treturn cli.ShowCommandHelp(ctx, \"signmessagewithaddr\")\n\t}\n\n\twalletClient, cleanUp := getWalletClient(ctx)\n\tdefer cleanUp()\n\n\tvar (\n\t\targs = ctx.Args()\n\t\taddr string\n\t\tsig  string\n\t\tmsg  []byte\n\t)\n\n\tswitch {\n\tcase ctx.IsSet(\"address\"):\n\t\taddr = ctx.String(\"address\")\n\n\tcase args.Present():\n\t\taddr = args.First()\n\t\targs = args.Tail()\n\n\tdefault:\n\t\treturn fmt.Errorf(\"address argument missing\")\n\t}\n\n\tswitch {\n\tcase ctx.IsSet(\"sig\"):\n\t\tsig = ctx.String(\"sig\")\n\n\tcase ctx.Args().Present():\n\t\tsig = args.First()\n\t\targs = args.Tail()\n\n\tdefault:\n\t\treturn fmt.Errorf(\"sig argument missing\")\n\t}\n\n\tswitch {\n\tcase ctx.IsSet(\"msg\"):\n\t\tmsg = []byte(ctx.String(\"msg\"))\n\n\tcase ctx.Args().Present():\n\t\tmsg = []byte(args.First())\n\t\targs = args.Tail()\n\n\tdefault:\n\t\treturn fmt.Errorf(\"msg argument missing\")\n\t}\n\n\tresp, err := walletClient.VerifyMessageWithAddr(\n\t\tctxc,\n\t\t&walletrpc.VerifyMessageWithAddrRequest{\n\t\t\tMsg:       msg,\n\t\t\tSignature: sig,\n\t\t\tAddr:      addr,\n\t\t},\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(resp)\n\n\treturn nil\n}\n\nvar importAccountCommand = cli.Command{\n\tName: \"import\",\n\tUsage: \"Import an on-chain account into the wallet through its \" +\n\t\t\"extended public key.\",\n\tArgsUsage: \"extended_public_key name\",\n\tDescription: `\n\tImports an account backed by an account extended public key. The master\n\tkey fingerprint denotes the fingerprint of the root key corresponding to\n\tthe account public key (also known as the key with derivation path m/).\n\tThis may be required by some hardware wallets for proper identification\n\tand signing.\n\n\tThe address type can usually be inferred from the key's version, but may\n\tbe required for certain keys to map them into the proper scope.\n\n\tFor BIP-0044 keys, an address type must be specified as we intend to not\n\tsupport importing BIP-0044 keys into the wallet using the legacy\n\tpay-to-pubkey-hash (P2PKH) scheme. A nested witness address type will\n\tforce the standard BIP-0049 derivation scheme, while a witness address\n\ttype will force the standard BIP-0084 derivation scheme.\n\n\tFor BIP-0049 keys, an address type must also be specified to make a\n\tdistinction between the standard BIP-0049 address schema (nested witness\n\tpubkeys everywhere) and our own BIP-0049Plus address schema (nested\n\tpubkeys externally, witness pubkeys internally).\n\n\tNOTE: Events (deposits/spends) for keys derived from an account will\n\tonly be detected by lnd if they happen after the import. Rescans to\n\tdetect past events will be supported later on.\n\t`,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName: \"address_type\",\n\t\t\tUsage: \"(optional) specify the type of addresses the \" +\n\t\t\t\t\"imported account should generate\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName: \"master_key_fingerprint\",\n\t\t\tUsage: \"(optional) the fingerprint of the root key \" +\n\t\t\t\t\"(derivation path m/) corresponding to the \" +\n\t\t\t\t\"account public key\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"dry_run\",\n\t\t\tUsage: \"(optional) perform a dry run\",\n\t\t},\n\t},\n\tAction: actionDecorator(importAccount),\n}\n",
      "length": 3021,
      "tokens": 418,
      "embedding": []
    },
    {
      "slug": "func importAccount(ctx *cli.Context) error {",
      "content": "func importAccount(ctx *cli.Context) error {\n\tctxc := getContext()\n\n\t// Display the command's help message if we do not have the expected\n\t// number of arguments/flags.\n\tif ctx.NArg() != 2 || ctx.NumFlags() > 3 {\n\t\treturn cli.ShowCommandHelp(ctx, \"import\")\n\t}\n\n\taddrType, err := parseAddrType(ctx.String(\"address_type\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar mkfpBytes []byte\n\tif ctx.IsSet(\"master_key_fingerprint\") {\n\t\tmkfpBytes, err = hex.DecodeString(\n\t\t\tctx.String(\"master_key_fingerprint\"),\n\t\t)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"invalid master key fingerprint: %v\", err)\n\t\t}\n\t}\n\n\twalletClient, cleanUp := getWalletClient(ctx)\n\tdefer cleanUp()\n\n\tdryRun := ctx.Bool(\"dry_run\")\n\treq := &walletrpc.ImportAccountRequest{\n\t\tName:                 ctx.Args().Get(1),\n\t\tExtendedPublicKey:    ctx.Args().Get(0),\n\t\tMasterKeyFingerprint: mkfpBytes,\n\t\tAddressType:          addrType,\n\t\tDryRun:               dryRun,\n\t}\n\tresp, err := walletClient.ImportAccount(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(resp)\n\treturn nil\n}\n\nvar importPubKeyCommand = cli.Command{\n\tName:      \"import-pubkey\",\n\tUsage:     \"Import a public key as watch-only into the wallet.\",\n\tArgsUsage: \"public_key address_type\",\n\tDescription: `\n\tImports a public key represented in hex as watch-only into the wallet.\n\tThe address type must be one of the following: np2wkh, p2wkh.\n\n\tNOTE: Events (deposits/spends) for a key will only be detected by lnd if\n\tthey happen after the import. Rescans to detect past events will be\n\tsupported later on.\n\t`,\n\tAction: actionDecorator(importPubKey),\n}\n",
      "length": 1473,
      "tokens": 187,
      "embedding": []
    },
    {
      "slug": "func importPubKey(ctx *cli.Context) error {",
      "content": "func importPubKey(ctx *cli.Context) error {\n\tctxc := getContext()\n\n\t// Display the command's help message if we do not have the expected\n\t// number of arguments/flags.\n\tif ctx.NArg() != 2 || ctx.NumFlags() > 0 {\n\t\treturn cli.ShowCommandHelp(ctx, \"import-pubkey\")\n\t}\n\n\tpubKeyBytes, err := hex.DecodeString(ctx.Args().Get(0))\n\tif err != nil {\n\t\treturn err\n\t}\n\taddrType, err := parseAddrType(ctx.Args().Get(1))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\twalletClient, cleanUp := getWalletClient(ctx)\n\tdefer cleanUp()\n\n\treq := &walletrpc.ImportPublicKeyRequest{\n\t\tPublicKey:   pubKeyBytes,\n\t\tAddressType: addrType,\n\t}\n\tresp, err := walletClient.ImportPublicKey(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(resp)\n\treturn nil\n}\n",
      "length": 653,
      "tokens": 88,
      "embedding": []
    }
  ]
}