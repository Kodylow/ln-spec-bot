{
  "filepath": "../implementations/go/lnd/cmd/lncli/cmd_profile.go",
  "package": "main",
  "sections": [
    {
      "slug": "func profileList(_ *cli.Context) error {",
      "content": "func profileList(_ *cli.Context) error {\n\tf, err := loadProfileFile(defaultProfileFile)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintJSON(f)\n\treturn nil\n}\n\nvar profileAddCommand = cli.Command{\n\tName:      \"add\",\n\tUsage:     \"Add a new profile.\",\n\tArgsUsage: \"name\",\n\tDescription: `\n\tAdd a new named profile to the main profiles.json. All global options\n\t(see 'lncli --help') passed into this command are stored in that named\n\tprofile.\n\t`,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName:  \"name\",\n\t\t\tUsage: \"the name of the new profile\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"default\",\n\t\t\tUsage: \"set the new profile to be the default profile\",\n\t\t},\n\t},\n\tAction: profileAdd,\n}\n",
      "length": 593,
      "tokens": 88,
      "embedding": []
    },
    {
      "slug": "func profileAdd(ctx *cli.Context) error {",
      "content": "func profileAdd(ctx *cli.Context) error {\n\tif ctx.NArg() == 0 && ctx.NumFlags() == 0 {\n\t\treturn cli.ShowCommandHelp(ctx, \"add\")\n\t}\n\n\t// Load the default profile file or create a new one if it doesn't exist\n\t// yet.\n\tf, err := loadProfileFile(defaultProfileFile)\n\tswitch {\n\tcase err == errNoProfileFile:\n\t\tf = &profileFile{}\n\t\t_ = os.MkdirAll(path.Dir(defaultProfileFile), 0700)\n\n\tcase err != nil:\n\t\treturn err\n\t}\n\n\t// Create a profile struct from all the global options.\n\tprofile, err := profileFromContext(ctx, true, false)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not load global options: %v\", err)\n\t}\n\n\t// Finally, all that's left is to get the profile name from either\n\t// positional argument or flag.\n\targs := ctx.Args()\n\tswitch {\n\tcase ctx.IsSet(\"name\"):\n\t\tprofile.Name = ctx.String(\"name\")\n\tcase args.Present():\n\t\tprofile.Name = args.First()\n\tdefault:\n\t\treturn fmt.Errorf(\"name argument missing\")\n\t}\n\n\t// Is there already a profile with that name?\n\tfor _, p := range f.Profiles {\n\t\tif p.Name == profile.Name {\n\t\t\treturn fmt.Errorf(\"a profile with the name %s already \"+\n\t\t\t\t\"exists\", profile.Name)\n\t\t}\n\t}\n\n\t// Do we need to update the default entry to be this one?\n\tif ctx.Bool(\"default\") {\n\t\tf.Default = profile.Name\n\t}\n\n\t// All done, store the updated profile file.\n\tf.Profiles = append(f.Profiles, profile)\n\tif err = saveProfileFile(defaultProfileFile, f); err != nil {\n\t\treturn fmt.Errorf(\"error writing profile file %s: %v\",\n\t\t\tdefaultProfileFile, err)\n\t}\n\n\tfmt.Printf(\"Profile %s added to file %s.\\n\", profile.Name,\n\t\tdefaultProfileFile)\n\treturn nil\n}\n\nvar profileRemoveCommand = cli.Command{\n\tName:        \"remove\",\n\tUsage:       \"Remove a profile\",\n\tArgsUsage:   \"name\",\n\tDescription: `Remove the specified profile from the profile file.`,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName:  \"name\",\n\t\t\tUsage: \"the name of the profile to delete\",\n\t\t},\n\t},\n\tAction: profileRemove,\n}\n",
      "length": 1782,
      "tokens": 258,
      "embedding": []
    },
    {
      "slug": "func profileRemove(ctx *cli.Context) error {",
      "content": "func profileRemove(ctx *cli.Context) error {\n\tif ctx.NArg() == 0 && ctx.NumFlags() == 0 {\n\t\treturn cli.ShowCommandHelp(ctx, \"remove\")\n\t}\n\n\t// Load the default profile file.\n\tf, err := loadProfileFile(defaultProfileFile)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not load profile file: %v\", err)\n\t}\n\n\t// Get the profile name from either positional argument or flag.\n\tvar (\n\t\targs  = ctx.Args()\n\t\tname  string\n\t\tfound = false\n\t)\n\tswitch {\n\tcase ctx.IsSet(\"name\"):\n\t\tname = ctx.String(\"name\")\n\tcase args.Present():\n\t\tname = args.First()\n\tdefault:\n\t\treturn fmt.Errorf(\"name argument missing\")\n\t}\n\n\tif len(f.Profiles) == 0 {\n\t\treturn fmt.Errorf(\"there are no existing profiles\")\n\t}\n\n\t// Create a copy of all profiles but don't include the one to delete.\n\tnewProfiles := make([]*profileEntry, 0, len(f.Profiles)-1)\n\tfor _, p := range f.Profiles {\n\t\t// Skip the one we want to delete.\n\t\tif p.Name == name {\n\t\t\tfound = true\n\n\t\t\tif p.Name == f.Default {\n\t\t\t\tfmt.Println(\"Warning: removing default profile.\")\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\t// Keep all others.\n\t\tnewProfiles = append(newProfiles, p)\n\t}\n\n\t// If what we were looking for didn't exist in the first place, there's\n\t// no need for updating the file.\n\tif !found {\n\t\treturn fmt.Errorf(\"profile with name %s not found in file\",\n\t\t\tname)\n\t}\n\n\t// Great, everything updated, now let's save the file.\n\tf.Profiles = newProfiles\n\treturn saveProfileFile(defaultProfileFile, f)\n}\n\nvar profileSetDefaultCommand = cli.Command{\n\tName:      \"setdefault\",\n\tUsage:     \"Set the default profile.\",\n\tArgsUsage: \"name\",\n\tDescription: `\n\tSet a specified profile to be used as the default profile.\n\n\tWARNING: Setting a default profile changes the default behavior of\n\tlncli! To disable the use of the default profile for a single command,\n\tset '--profile= '.\n\t`,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName:  \"name\",\n\t\t\tUsage: \"the name of the profile to set as default\",\n\t\t},\n\t},\n\tAction: profileSetDefault,\n}\n",
      "length": 1815,
      "tokens": 276,
      "embedding": []
    },
    {
      "slug": "func profileSetDefault(ctx *cli.Context) error {",
      "content": "func profileSetDefault(ctx *cli.Context) error {\n\tif ctx.NArg() == 0 && ctx.NumFlags() == 0 {\n\t\treturn cli.ShowCommandHelp(ctx, \"setdefault\")\n\t}\n\n\t// Load the default profile file.\n\tf, err := loadProfileFile(defaultProfileFile)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not load profile file: %v\", err)\n\t}\n\n\t// Get the profile name from either positional argument or flag.\n\tvar (\n\t\targs  = ctx.Args()\n\t\tname  string\n\t\tfound = false\n\t)\n\tswitch {\n\tcase ctx.IsSet(\"name\"):\n\t\tname = ctx.String(\"name\")\n\tcase args.Present():\n\t\tname = args.First()\n\tdefault:\n\t\treturn fmt.Errorf(\"name argument missing\")\n\t}\n\n\t// Make sure the new default profile actually exists.\n\tfor _, p := range f.Profiles {\n\t\tif p.Name == name {\n\t\t\tfound = true\n\t\t\tf.Default = p.Name\n\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// If the default profile doesn't exist, there's no need for updating\n\t// the file.\n\tif !found {\n\t\treturn fmt.Errorf(\"profile with name %s not found in file\",\n\t\t\tname)\n\t}\n\n\t// Great, everything updated, now let's save the file.\n\treturn saveProfileFile(defaultProfileFile, f)\n}\n\nvar profileUnsetDefaultCommand = cli.Command{\n\tName:  \"unsetdefault\",\n\tUsage: \"Unsets the default profile.\",\n\tDescription: `\n\tDisables the use of a default profile and restores lncli to its original\n\tbehavior.\n\t`,\n\tAction: profileUnsetDefault,\n}\n",
      "length": 1189,
      "tokens": 180,
      "embedding": []
    },
    {
      "slug": "func profileUnsetDefault(_ *cli.Context) error {",
      "content": "func profileUnsetDefault(_ *cli.Context) error {\n\t// Load the default profile file.\n\tf, err := loadProfileFile(defaultProfileFile)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not load profile file: %v\", err)\n\t}\n\n\t// Save the file with the flag disabled.\n\tf.Default = \"\"\n\treturn saveProfileFile(defaultProfileFile, f)\n}\n\nvar profileAddMacaroonCommand = cli.Command{\n\tName:      \"addmacaroon\",\n\tUsage:     \"Add a macaroon to a profile's macaroon jar.\",\n\tArgsUsage: \"macaroon-name\",\n\tDescription: `\n\tAdd an additional macaroon specified by the global option --macaroonpath\n\tto an existing profile's macaroon jar.\n\n\tIf no profile is selected, the macaroon is added to the default profile\n\t(if one exists). To add a macaroon to a specific profile, use the global\n\t--profile=myprofile option.\n\n\tIf multiple macaroons exist in a profile's macaroon jar, the one to use\n\tcan be specified with the global option --macfromjar=xyz.\n\t`,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName:  \"name\",\n\t\t\tUsage: \"the name of the macaroon\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName: \"default\",\n\t\t\tUsage: \"set the new macaroon to be the default \" +\n\t\t\t\t\"macaroon in the jar\",\n\t\t},\n\t},\n\tAction: profileAddMacaroon,\n}\n",
      "length": 1092,
      "tokens": 160,
      "embedding": []
    },
    {
      "slug": "func profileAddMacaroon(ctx *cli.Context) error {",
      "content": "func profileAddMacaroon(ctx *cli.Context) error {\n\tif ctx.NArg() == 0 && ctx.NumFlags() == 0 {\n\t\treturn cli.ShowCommandHelp(ctx, \"addmacaroon\")\n\t}\n\n\t// Load the default profile file or create a new one if it doesn't exist\n\t// yet.\n\tf, err := loadProfileFile(defaultProfileFile)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not load profile file: %v\", err)\n\t}\n\n\t// Finally, all that's left is to get the profile name from either\n\t// positional argument or flag.\n\tvar (\n\t\targs        = ctx.Args()\n\t\tprofileName string\n\t\tmacName     string\n\t)\n\tswitch {\n\tcase ctx.IsSet(\"name\"):\n\t\tmacName = ctx.String(\"name\")\n\tcase args.Present():\n\t\tmacName = args.First()\n\tdefault:\n\t\treturn fmt.Errorf(\"name argument missing\")\n\t}\n\n\t// Make sure the user actually set a macaroon path to use.\n\tif !ctx.GlobalIsSet(\"macaroonpath\") {\n\t\treturn fmt.Errorf(\"macaroonpath global option missing\")\n\t}\n\n\t// Find out which profile we should add the macaroon. The global flag\n\t// takes precedence over the default profile.\n\tif f.Default != \"\" {\n\t\tprofileName = f.Default\n\t}\n\tif ctx.GlobalIsSet(\"profile\") {\n\t\tprofileName = ctx.GlobalString(\"profile\")\n\t}\n\tif len(strings.TrimSpace(profileName)) == 0 {\n\t\treturn fmt.Errorf(\"no profile specified and no default \" +\n\t\t\t\"profile exists\")\n\t}\n\n\t// Is there a profile with that name?\n\tvar selectedProfile *profileEntry\n\tfor _, p := range f.Profiles {\n\t\tif p.Name == profileName {\n\t\t\tselectedProfile = p\n\t\t\tbreak\n\t\t}\n\t}\n\tif selectedProfile == nil {\n\t\treturn fmt.Errorf(\"profile with name %s not found\", profileName)\n\t}\n\n\t// Does a macaroon with that name already exist?\n\tfor _, m := range selectedProfile.Macaroons.Jar {\n\t\tif m.Name == macName {\n\t\t\treturn fmt.Errorf(\"a macaroon with the name %s \"+\n\t\t\t\t\"already exists\", macName)\n\t\t}\n\t}\n\n\t// Do we need to update the default entry to be this one?\n\tif ctx.Bool(\"default\") {\n\t\tselectedProfile.Macaroons.Default = macName\n\t}\n\n\t// Now load and possibly encrypt the macaroon file.\n\tmacPath := lncfg.CleanAndExpandPath(ctx.GlobalString(\"macaroonpath\"))\n\tmacBytes, err := ioutil.ReadFile(macPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to read macaroon path: %v\", err)\n\t}\n\tmac := &macaroon.Macaroon{}\n\tif err = mac.UnmarshalBinary(macBytes); err != nil {\n\t\treturn fmt.Errorf(\"unable to decode macaroon: %v\", err)\n\t}\n\tmacEntry := &macaroonEntry{\n\t\tName: macName,\n\t}\n\tif err = macEntry.storeMacaroon(mac, nil); err != nil {\n\t\treturn fmt.Errorf(\"unable to store macaroon: %v\", err)\n\t}\n\n\t// All done, store the updated profile file.\n\tselectedProfile.Macaroons.Jar = append(\n\t\tselectedProfile.Macaroons.Jar, macEntry,\n\t)\n\tif err = saveProfileFile(defaultProfileFile, f); err != nil {\n\t\treturn fmt.Errorf(\"error writing profile file %s: %v\",\n\t\t\tdefaultProfileFile, err)\n\t}\n\n\tfmt.Printf(\"Macaroon %s added to profile %s in file %s.\\n\", macName,\n\t\tselectedProfile.Name, defaultProfileFile)\n\treturn nil\n}\n",
      "length": 2703,
      "tokens": 385,
      "embedding": []
    }
  ]
}