{
  "filepath": "../implementations/go/lnd/cmd/lncli/cmd_invoice.go",
  "package": "main",
  "sections": [
    {
      "slug": "func addInvoice(ctx *cli.Context) error {",
      "content": "func addInvoice(ctx *cli.Context) error {\n\tvar (\n\t\tpreimage []byte\n\t\tdescHash []byte\n\t\tamt      int64\n\t\tamtMsat  int64\n\t\terr      error\n\t)\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\targs := ctx.Args()\n\n\tamt = ctx.Int64(\"amt\")\n\tamtMsat = ctx.Int64(\"amt_msat\")\n\tif !ctx.IsSet(\"amt\") && !ctx.IsSet(\"amt_msat\") && args.Present() {\n\t\tamt, err = strconv.ParseInt(args.First(), 10, 64)\n\t\targs = args.Tail()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to decode amt argument: %v\", err)\n\t\t}\n\t}\n\n\tswitch {\n\tcase ctx.IsSet(\"preimage\"):\n\t\tpreimage, err = hex.DecodeString(ctx.String(\"preimage\"))\n\tcase args.Present():\n\t\tpreimage, err = hex.DecodeString(args.First())\n\t}\n\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to parse preimage: %v\", err)\n\t}\n\n\tdescHash, err = hex.DecodeString(ctx.String(\"description_hash\"))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to parse description_hash: %v\", err)\n\t}\n\n\tinvoice := &lnrpc.Invoice{\n\t\tMemo:            ctx.String(\"memo\"),\n\t\tRPreimage:       preimage,\n\t\tValue:           amt,\n\t\tValueMsat:       amtMsat,\n\t\tDescriptionHash: descHash,\n\t\tFallbackAddr:    ctx.String(\"fallback_addr\"),\n\t\tExpiry:          ctx.Int64(\"expiry\"),\n\t\tPrivate:         ctx.Bool(\"private\"),\n\t\tIsAmp:           ctx.Bool(\"amp\"),\n\t}\n\n\tresp, err := client.AddInvoice(ctxc, invoice)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(resp)\n\n\treturn nil\n}\n\nvar lookupInvoiceCommand = cli.Command{\n\tName:      \"lookupinvoice\",\n\tCategory:  \"Invoices\",\n\tUsage:     \"Lookup an existing invoice by its payment hash.\",\n\tArgsUsage: \"rhash\",\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName: \"rhash\",\n\t\t\tUsage: \"the 32 byte payment hash of the invoice to query for, the hash \" +\n\t\t\t\t\"should be a hex-encoded string\",\n\t\t},\n\t},\n\tAction: actionDecorator(lookupInvoice),\n}\n",
      "length": 1672,
      "tokens": 196,
      "embedding": []
    },
    {
      "slug": "func lookupInvoice(ctx *cli.Context) error {",
      "content": "func lookupInvoice(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\tvar (\n\t\trHash []byte\n\t\terr   error\n\t)\n\n\tswitch {\n\tcase ctx.IsSet(\"rhash\"):\n\t\trHash, err = hex.DecodeString(ctx.String(\"rhash\"))\n\tcase ctx.Args().Present():\n\t\trHash, err = hex.DecodeString(ctx.Args().First())\n\tdefault:\n\t\treturn fmt.Errorf(\"rhash argument missing\")\n\t}\n\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to decode rhash argument: %v\", err)\n\t}\n\n\treq := &lnrpc.PaymentHash{\n\t\tRHash: rHash,\n\t}\n\n\tinvoice, err := client.LookupInvoice(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(invoice)\n\n\treturn nil\n}\n\nvar listInvoicesCommand = cli.Command{\n\tName:     \"listinvoices\",\n\tCategory: \"Invoices\",\n\tUsage: \"List all invoices currently stored within the database. Any \" +\n\t\t\"active debug invoices are ignored.\",\n\tDescription: `\n\tThis command enables the retrieval of all invoices currently stored\n\twithin the database. It has full support for paginationed responses,\n\tallowing users to query for specific invoices through their add_index.\n\tThis can be done by using either the first_index_offset or\n\tlast_index_offset fields included in the response as the index_offset of\n\tthe next request. Backward pagination is enabled by default to receive\n\tcurrent invoices first. If you wish to paginate forwards, set the \n\tpaginate-forwards flag.\tIf none of the parameters are specified, then \n\tthe last 100 invoices will be returned.\n\n\tFor example: if you have 200 invoices, \"lncli listinvoices\" will return\n\tthe last 100 created. If you wish to retrieve the previous 100, the\n\tfirst_offset_index of the response can be used as the index_offset of\n\tthe next listinvoices request.`,\n\tFlags: []cli.Flag{\n\t\tcli.BoolFlag{\n\t\t\tName: \"pending_only\",\n\t\t\tUsage: \"toggles if all invoices should be returned, \" +\n\t\t\t\t\"or only those that are currently unsettled\",\n\t\t},\n\t\tcli.Uint64Flag{\n\t\t\tName: \"index_offset\",\n\t\t\tUsage: \"the index of an invoice that will be used as \" +\n\t\t\t\t\"either the start or end of a query to \" +\n\t\t\t\t\"determine which invoices should be returned \" +\n\t\t\t\t\"in the response\",\n\t\t},\n\t\tcli.Uint64Flag{\n\t\t\tName:  \"max_invoices\",\n\t\t\tUsage: \"the max number of invoices to return\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName: \"paginate-forwards\",\n\t\t\tUsage: \"if set, invoices succeeding the \" +\n\t\t\t\t\"index_offset will be returned\",\n\t\t},\n\t\tcli.Uint64Flag{\n\t\t\tName: \"creation_date_start\",\n\t\t\tUsage: \"timestamp in seconds, if set, filter \" +\n\t\t\t\t\"invoices with creation date greater than or \" +\n\t\t\t\t\"equal to it\",\n\t\t},\n\t\tcli.Uint64Flag{\n\t\t\tName: \"creation_date_end\",\n\t\t\tUsage: \"timestamp in seconds, if set, filter \" +\n\t\t\t\t\"invoices with creation date less than or \" +\n\t\t\t\t\"equal to it\",\n\t\t},\n\t},\n\tAction: actionDecorator(listInvoices),\n}\n",
      "length": 2610,
      "tokens": 372,
      "embedding": []
    },
    {
      "slug": "func listInvoices(ctx *cli.Context) error {",
      "content": "func listInvoices(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\treq := &lnrpc.ListInvoiceRequest{\n\t\tPendingOnly:       ctx.Bool(\"pending_only\"),\n\t\tIndexOffset:       ctx.Uint64(\"index_offset\"),\n\t\tNumMaxInvoices:    ctx.Uint64(\"max_invoices\"),\n\t\tReversed:          !ctx.Bool(\"paginate-forwards\"),\n\t\tCreationDateStart: ctx.Uint64(\"creation_date_start\"),\n\t\tCreationDateEnd:   ctx.Uint64(\"creation_date_end\"),\n\t}\n\n\tinvoices, err := client.ListInvoices(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(invoices)\n\n\treturn nil\n}\n\nvar decodePayReqCommand = cli.Command{\n\tName:        \"decodepayreq\",\n\tCategory:    \"Invoices\",\n\tUsage:       \"Decode a payment request.\",\n\tDescription: \"Decode the passed payment request revealing the destination, payment hash and value of the payment request\",\n\tArgsUsage:   \"pay_req\",\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName:  \"pay_req\",\n\t\t\tUsage: \"the bech32 encoded payment request\",\n\t\t},\n\t},\n\tAction: actionDecorator(decodePayReq),\n}\n",
      "length": 954,
      "tokens": 90,
      "embedding": []
    },
    {
      "slug": "func decodePayReq(ctx *cli.Context) error {",
      "content": "func decodePayReq(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\tvar payreq string\n\n\tswitch {\n\tcase ctx.IsSet(\"pay_req\"):\n\t\tpayreq = ctx.String(\"pay_req\")\n\tcase ctx.Args().Present():\n\t\tpayreq = ctx.Args().First()\n\tdefault:\n\t\treturn fmt.Errorf(\"pay_req argument missing\")\n\t}\n\n\tresp, err := client.DecodePayReq(ctxc, &lnrpc.PayReqString{\n\t\tPayReq: stripPrefix(payreq),\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(resp)\n\treturn nil\n}\n",
      "length": 426,
      "tokens": 50,
      "embedding": []
    }
  ]
}