{
  "filepath": "../implementations/go/lnd/cmd/lncli/cmd_walletunlocker.go",
  "package": "main",
  "sections": [
    {
      "slug": "func monowidthColumns(words []string, ncols int) []string {",
      "content": "func monowidthColumns(words []string, ncols int) []string {\n\t// Determine max size of words in each column.\n\tcolWidths := make([]int, ncols)\n\tfor i, word := range words {\n\t\tcol := i % ncols\n\t\tcurWidth := colWidths[col]\n\t\tif len(word) > curWidth {\n\t\t\tcolWidths[col] = len(word)\n\t\t}\n\t}\n\n\t// Append whitespace to each word to make columns mono-width.\n\tfinalWords := make([]string, len(words))\n\tfor i, word := range words {\n\t\tcol := i % ncols\n\t\twidth := colWidths[col]\n\n\t\tdiff := width - len(word)\n\t\tfinalWords[i] = word + strings.Repeat(\" \", diff)\n\t}\n\n\treturn finalWords\n}\n",
      "length": 488,
      "tokens": 83,
      "embedding": []
    },
    {
      "slug": "func create(ctx *cli.Context) error {",
      "content": "func create(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getWalletUnlockerClient(ctx)\n\tdefer cleanUp()\n\n\tvar (\n\t\tchanBackups *lnrpc.ChanBackupSnapshot\n\n\t\t// We use var restoreSCB to track if we will be including an SCB\n\t\t// recovery in the init wallet request.\n\t\trestoreSCB = false\n\t)\n\n\tbackups, err := parseChanBackups(ctx)\n\n\t// We'll check to see if the user provided any static channel backups (SCB),\n\t// if so, we will warn the user that SCB recovery closes all open channels\n\t// and ask them to confirm their intention.\n\t// If the user agrees, we'll add the SCB recovery onto the final init wallet\n\t// request.\n\tswitch {\n\t// parseChanBackups returns an errMissingBackup error (which we ignore) if\n\t// the user did not request a SCB recovery.\n\tcase err == errMissingChanBackup:\n\n\t// Passed an invalid channel backup file.\n\tcase err != nil:\n\t\treturn fmt.Errorf(\"unable to parse chan backups: %v\", err)\n\n\t// We have an SCB recovery option with a valid backup file.\n\tdefault:\n\n\twarningLoop:\n\t\tfor {\n\t\t\tfmt.Println()\n\t\t\tfmt.Printf(\"WARNING: You are attempting to restore from a \" +\n\t\t\t\t\"static channel backup (SCB) file.\\nThis action will CLOSE \" +\n\t\t\t\t\"all currently open channels, and you will pay on-chain fees.\" +\n\t\t\t\t\"\\n\\nAre you sure you want to recover funds from a\" +\n\t\t\t\t\" static channel backup? (Enter y/n): \")\n\n\t\t\treader := bufio.NewReader(os.Stdin)\n\t\t\tanswer, err := reader.ReadString('\\n')\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tanswer = strings.TrimSpace(answer)\n\t\t\tanswer = strings.ToLower(answer)\n\n\t\t\tswitch answer {\n\t\t\tcase \"y\":\n\t\t\t\trestoreSCB = true\n\t\t\t\tbreak warningLoop\n\t\t\tcase \"n\":\n\t\t\t\tfmt.Println(\"Aborting SCB recovery\")\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n\n\t// Proceed with SCB recovery.\n\tif restoreSCB {\n\t\tfmt.Println(\"Static Channel Backup (SCB) recovery selected!\")\n\t\tif backups != nil {\n\t\t\tswitch {\n\t\t\tcase backups.GetChanBackups() != nil:\n\t\t\t\tsingleBackup := backups.GetChanBackups()\n\t\t\t\tchanBackups = &lnrpc.ChanBackupSnapshot{\n\t\t\t\t\tSingleChanBackups: singleBackup,\n\t\t\t\t}\n\n\t\t\tcase backups.GetMultiChanBackup() != nil:\n\t\t\t\tmultiBackup := backups.GetMultiChanBackup()\n\t\t\t\tchanBackups = &lnrpc.ChanBackupSnapshot{\n\t\t\t\t\tMultiChanBackup: &lnrpc.MultiChanBackup{\n\t\t\t\t\t\tMultiChanBackup: multiBackup,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Should the daemon be initialized stateless? Then we expect an answer\n\t// with the admin macaroon later. Because the --save_to is related to\n\t// stateless init, it doesn't make sense to be set on its own.\n\tstatelessInit := ctx.Bool(statelessInitFlag.Name)\n\tif !statelessInit && ctx.IsSet(saveToFlag.Name) {\n\t\treturn fmt.Errorf(\"cannot set save_to parameter without \" +\n\t\t\t\"stateless_init\")\n\t}\n\n\twalletPassword, err := capturePassword(\n\t\t\"Input wallet password: \", false, walletunlocker.ValidatePassword,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Next, we'll see if the user has 24-word mnemonic they want to use to\n\t// derive a seed within the wallet or if they want to specify an\n\t// extended master root key (xprv) directly.\n\tvar (\n\t\thasMnemonic bool\n\t\thasXprv     bool\n\t)\n\nmnemonicCheck:\n\tfor {\n\t\tfmt.Println()\n\t\tfmt.Printf(\"Do you have an existing cipher seed \" +\n\t\t\t\"mnemonic or extended master root key you want to \" +\n\t\t\t\"use?\\nEnter 'y' to use an existing cipher seed \" +\n\t\t\t\"mnemonic, 'x' to use an extended master root key \" +\n\t\t\t\"\\nor 'n' to create a new seed (Enter y/x/n): \")\n\n\t\treader := bufio.NewReader(os.Stdin)\n\t\tanswer, err := reader.ReadString('\\n')\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfmt.Println()\n\n\t\tanswer = strings.TrimSpace(answer)\n\t\tanswer = strings.ToLower(answer)\n\n\t\tswitch answer {\n\t\tcase \"y\":\n\t\t\thasMnemonic = true\n\t\t\tbreak mnemonicCheck\n\n\t\tcase \"x\":\n\t\t\thasXprv = true\n\t\t\tbreak mnemonicCheck\n\n\t\tcase \"n\":\n\t\t\tbreak mnemonicCheck\n\t\t}\n\t}\n\n\t// If the user *does* have an existing seed or root key they want to\n\t// use, then we'll read that in directly from the terminal.\n\tvar (\n\t\tcipherSeedMnemonic      []string\n\t\taezeedPass              []byte\n\t\textendedRootKey         string\n\t\textendedRootKeyBirthday uint64\n\t\trecoveryWindow          int32\n\t)\n\tswitch {\n\t// Use an existing cipher seed mnemonic in the aezeed format.\n\tcase hasMnemonic:\n\t\t// We'll now prompt the user to enter in their 24-word\n\t\t// mnemonic.\n\t\tfmt.Printf(\"Input your 24-word mnemonic separated by spaces: \")\n\t\treader := bufio.NewReader(os.Stdin)\n\t\tmnemonic, err := reader.ReadString('\\n')\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// We'll trim off extra spaces, and ensure the mnemonic is all\n\t\t// lower case, then populate our request.\n\t\tmnemonic = strings.TrimSpace(mnemonic)\n\t\tmnemonic = strings.ToLower(mnemonic)\n\n\t\tcipherSeedMnemonic = strings.Split(mnemonic, \" \")\n\n\t\tfmt.Println()\n\n\t\tif len(cipherSeedMnemonic) != 24 {\n\t\t\treturn fmt.Errorf(\"wrong cipher seed mnemonic \"+\n\t\t\t\t\"length: got %v words, expecting %v words\",\n\t\t\t\tlen(cipherSeedMnemonic), 24)\n\t\t}\n\n\t\t// Additionally, the user may have a passphrase, that will also\n\t\t// need to be provided so the daemon can properly decipher the\n\t\t// cipher seed.\n\t\taezeedPass, err = readPassword(\"Input your cipher seed \" +\n\t\t\t\"passphrase (press enter if your seed doesn't have a \" +\n\t\t\t\"passphrase): \")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\trecoveryWindow, err = askRecoveryWindow()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t// Use an existing extended master root key to create the wallet.\n\tcase hasXprv:\n\t\t// We'll now prompt the user to enter in their extended master\n\t\t// root key.\n\t\tfmt.Printf(\"Input your extended master root key (usually \" +\n\t\t\t\"starting with xprv... on mainnet): \")\n\t\treader := bufio.NewReader(os.Stdin)\n\t\textendedRootKey, err = reader.ReadString('\\n')\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\textendedRootKey = strings.TrimSpace(extendedRootKey)\n\n\t\textendedRootKeyBirthday, err = askBirthdayTimestamp()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\trecoveryWindow, err = askRecoveryWindow()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t// Neither a seed nor a master root key was specified, the user wants\n\t// to create a new seed.\n\tdefault:\n\t\t// Otherwise, if the user doesn't have a mnemonic that they\n\t\t// want to use, we'll generate a fresh one with the GenSeed\n\t\t// command.\n\t\tfmt.Println(\"Your cipher seed can optionally be encrypted.\")\n\n\t\tinstruction := \"Input your passphrase if you wish to encrypt it \" +\n\t\t\t\"(or press enter to proceed without a cipher seed \" +\n\t\t\t\"passphrase): \"\n\t\taezeedPass, err = capturePassword(\n\t\t\tinstruction, true, func(_ []byte) error { return nil },\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfmt.Println()\n\t\tfmt.Println(\"Generating fresh cipher seed...\")\n\t\tfmt.Println()\n\n\t\tgenSeedReq := &lnrpc.GenSeedRequest{\n\t\t\tAezeedPassphrase: aezeedPass,\n\t\t}\n\t\tseedResp, err := client.GenSeed(ctxc, genSeedReq)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to generate seed: %v\", err)\n\t\t}\n\n\t\tcipherSeedMnemonic = seedResp.CipherSeedMnemonic\n\t}\n\n\t// Before we initialize the wallet, we'll display the cipher seed to\n\t// the user so they can write it down.\n\tif len(cipherSeedMnemonic) > 0 {\n\t\tprintCipherSeedWords(cipherSeedMnemonic)\n\t}\n\n\t// With either the user's prior cipher seed, or a newly generated one,\n\t// we'll go ahead and initialize the wallet.\n\treq := &lnrpc.InitWalletRequest{\n\t\tWalletPassword:                     walletPassword,\n\t\tCipherSeedMnemonic:                 cipherSeedMnemonic,\n\t\tAezeedPassphrase:                   aezeedPass,\n\t\tExtendedMasterKey:                  extendedRootKey,\n\t\tExtendedMasterKeyBirthdayTimestamp: extendedRootKeyBirthday,\n\t\tRecoveryWindow:                     recoveryWindow,\n\t\tChannelBackups:                     chanBackups,\n\t\tStatelessInit:                      statelessInit,\n\t}\n\tresponse, err := client.InitWallet(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Println(\"\\nlnd successfully initialized!\")\n\n\tif statelessInit {\n\t\treturn storeOrPrintAdminMac(ctx, response.AdminMacaroon)\n\t}\n\n\treturn nil\n}\n\n// capturePassword returns a password value that has been entered twice by the\n// user, to ensure that the user knows what password they have entered. The user\n// will be prompted to retry until the passwords match. If the optional param is\n// true, the function may return an empty byte array if the user opts against\n// using a password.",
      "length": 7824,
      "tokens": 1105,
      "embedding": []
    },
    {
      "slug": "func capturePassword(instruction string, optional bool,",
      "content": "func capturePassword(instruction string, optional bool,\n\tvalidate func([]byte) error) ([]byte, error) {\n\n\tfor {\n\t\tpassword, err := readPassword(instruction)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Do not require users to repeat password if\n\t\t// it is optional and they are not using one.\n\t\tif len(password) == 0 && optional {\n\t\t\treturn nil, nil\n\t\t}\n\n\t\t// If the password provided is not valid, restart\n\t\t// password capture process from the beginning.\n\t\tif err := validate(password); err != nil {\n\t\t\tfmt.Println(err.Error())\n\t\t\tfmt.Println()\n\t\t\tcontinue\n\t\t}\n\n\t\tpasswordConfirmed, err := readPassword(\"Confirm password: \")\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif bytes.Equal(password, passwordConfirmed) {\n\t\t\treturn password, nil\n\t\t}\n\n\t\tfmt.Println(\"Passwords don't match, please try again\")\n\t\tfmt.Println()\n\t}\n}\n\nvar unlockCommand = cli.Command{\n\tName:     \"unlock\",\n\tCategory: \"Startup\",\n\tUsage:    \"Unlock an encrypted wallet at startup.\",\n\tDescription: `\n\tThe unlock command is used to decrypt lnd's wallet state in order to\n\tstart up. This command MUST be run after booting up lnd before it's\n\table to carry out its duties. An exception is if a user is running with\n\t--noseedbackup, then a default passphrase will be used.\n\n\tIf the --stateless_init flag is set, no macaroon files are created by\n\tthe daemon. This should be set for every unlock if the daemon was\n\tinitially initialized stateless. Otherwise the daemon will create\n\tunencrypted macaroon files which could leak information to the system\n\tthat the daemon runs on.\n\t`,\n\tFlags: []cli.Flag{\n\t\tcli.IntFlag{\n\t\t\tName: \"recovery_window\",\n\t\t\tUsage: \"address lookahead to resume recovery rescan, \" +\n\t\t\t\t\"value should be non-zero --  To recover all \" +\n\t\t\t\t\"funds, this should be greater than the \" +\n\t\t\t\t\"maximum number of consecutive, unused \" +\n\t\t\t\t\"addresses ever generated by the wallet.\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName: \"stdin\",\n\t\t\tUsage: \"read password from standard input instead of \" +\n\t\t\t\t\"prompting for it. THIS IS CONSIDERED TO \" +\n\t\t\t\t\"BE DANGEROUS if the password is located in \" +\n\t\t\t\t\"a file that can be read by another user. \" +\n\t\t\t\t\"This flag should only be used in \" +\n\t\t\t\t\"combination with some sort of password \" +\n\t\t\t\t\"manager or secrets vault.\",\n\t\t},\n\t\tstatelessInitFlag,\n\t},\n\tAction: actionDecorator(unlock),\n}\n",
      "length": 2174,
      "tokens": 343,
      "embedding": []
    },
    {
      "slug": "func unlock(ctx *cli.Context) error {",
      "content": "func unlock(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getWalletUnlockerClient(ctx)\n\tdefer cleanUp()\n\n\tvar (\n\t\tpw  []byte\n\t\terr error\n\t)\n\tswitch {\n\t// Read the password from standard in as if it were a file. This should\n\t// only be used if the password is piped into lncli from some sort of\n\t// password manager. If the user types the password instead, it will be\n\t// echoed in the console.\n\tcase ctx.IsSet(\"stdin\"):\n\t\treader := bufio.NewReader(os.Stdin)\n\t\tpw, err = reader.ReadBytes('\\n')\n\n\t\t// Remove carriage return and newline characters.\n\t\tpw = bytes.Trim(pw, \"\\r\\n\")\n\n\t// Read the password from a terminal by default. This requires the\n\t// terminal to be a real tty and will fail if a string is piped into\n\t// lncli.\n\tdefault:\n\t\tpw, err = readPassword(\"Input wallet password: \")\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\n\targs := ctx.Args()\n\n\t// Parse the optional recovery window if it is specified. By default,\n\t// the recovery window will be 0, indicating no lookahead should be\n\t// used.\n\tvar recoveryWindow int32\n\tswitch {\n\tcase ctx.IsSet(\"recovery_window\"):\n\t\trecoveryWindow = int32(ctx.Int64(\"recovery_window\"))\n\tcase args.Present():\n\t\twindow, err := strconv.ParseInt(args.First(), 10, 64)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trecoveryWindow = int32(window)\n\t}\n\n\treq := &lnrpc.UnlockWalletRequest{\n\t\tWalletPassword: pw,\n\t\tRecoveryWindow: recoveryWindow,\n\t\tStatelessInit:  ctx.Bool(statelessInitFlag.Name),\n\t}\n\t_, err = client.UnlockWallet(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Println(\"\\nlnd successfully unlocked!\")\n\n\t// TODO(roasbeef): add ability to accept hex single and multi backups\n\n\treturn nil\n}\n\nvar changePasswordCommand = cli.Command{\n\tName:     \"changepassword\",\n\tCategory: \"Startup\",\n\tUsage:    \"Change an encrypted wallet's password at startup.\",\n\tDescription: `\n\tThe changepassword command is used to Change lnd's encrypted wallet's\n\tpassword. It will automatically unlock the daemon if the password change\n\tis successful.\n\n\tIf one did not specify a password for their wallet (running lnd with\n\t--noseedbackup), one must restart their daemon without\n\t--noseedbackup and use this command. The \"current password\" field\n\tshould be left empty.\n\n\tIf the daemon was originally initialized stateless, then the\n\t--stateless_init flag needs to be set for the change password request\n\tas well! Otherwise the daemon will generate unencrypted macaroon files\n\tin its file system again and possibly leak sensitive information.\n\tChanging the password will by default not change the macaroon root key\n\t(just re-encrypt the macaroon database with the new password). So all\n\tmacaroons will still be valid.\n\tIf one wants to make sure that all previously created macaroons are\n\tinvalidated, a new macaroon root key can be generated by using the\n\t--new_mac_root_key flag.\n\n\tAfter a successful password change with the --stateless_init flag set,\n\tthe current or new admin macaroon is returned binary serialized in the\n\tanswer. This answer MUST then be stored somewhere, otherwise\n\tall access to the RPC server will be lost and the wallet must be re-\n\tcreated to re-gain access. If the --save_to parameter is set, the\n\tmacaroon is saved to this file, otherwise it is printed to standard out.\n\t`,\n\tFlags: []cli.Flag{\n\t\tstatelessInitFlag,\n\t\tsaveToFlag,\n\t\tcli.BoolFlag{\n\t\t\tName: \"new_mac_root_key\",\n\t\t\tUsage: \"rotate the macaroon root key resulting in \" +\n\t\t\t\t\"all previously created macaroons to be \" +\n\t\t\t\t\"invalidated\",\n\t\t},\n\t},\n\tAction: actionDecorator(changePassword),\n}\n",
      "length": 3365,
      "tokens": 502,
      "embedding": []
    },
    {
      "slug": "func changePassword(ctx *cli.Context) error {",
      "content": "func changePassword(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getWalletUnlockerClient(ctx)\n\tdefer cleanUp()\n\n\tcurrentPw, err := readPassword(\"Input current wallet password: \")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tnewPw, err := readPassword(\"Input new wallet password: \")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tconfirmPw, err := readPassword(\"Confirm new wallet password: \")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !bytes.Equal(newPw, confirmPw) {\n\t\treturn fmt.Errorf(\"passwords don't match\")\n\t}\n\n\t// Should the daemon be initialized stateless? Then we expect an answer\n\t// with the admin macaroon later. Because the --save_to is related to\n\t// stateless init, it doesn't make sense to be set on its own.\n\tstatelessInit := ctx.Bool(statelessInitFlag.Name)\n\tif !statelessInit && ctx.IsSet(saveToFlag.Name) {\n\t\treturn fmt.Errorf(\"cannot set save_to parameter without \" +\n\t\t\t\"stateless_init\")\n\t}\n\n\treq := &lnrpc.ChangePasswordRequest{\n\t\tCurrentPassword:    currentPw,\n\t\tNewPassword:        newPw,\n\t\tStatelessInit:      statelessInit,\n\t\tNewMacaroonRootKey: ctx.Bool(\"new_mac_root_key\"),\n\t}\n\n\tresponse, err := client.ChangePassword(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif statelessInit {\n\t\treturn storeOrPrintAdminMac(ctx, response.AdminMacaroon)\n\t}\n\n\treturn nil\n}\n\nvar createWatchOnlyCommand = cli.Command{\n\tName:      \"createwatchonly\",\n\tCategory:  \"Startup\",\n\tArgsUsage: \"accounts-json-file\",\n\tUsage: \"Initialize a watch-only wallet after starting lnd for the \" +\n\t\t\"first time.\",\n\tDescription: `\n\tThe create command is used to initialize an lnd wallet from scratch for\n\tthe very first time, in watch-only mode. Watch-only means, there will be\n\tno private keys in lnd's wallet. This is only useful in combination with\n\ta remote signer or when lnd should be used as an on-chain wallet with\n\tPSBT interaction only.\n\n\tThis is an interactive command that takes a JSON file as its first and\n\tonly argument. The JSON is in the same format as the output of the\n\t'lncli wallet accounts list' command. This makes it easy to initialize\n\tthe remote signer with the seed, then export the extended public account\n\tkeys (xpubs) to import the watch-only wallet.\n\n\tExample JSON (non-mandatory or ignored fields are omitted):\n\t{\n\t    \"accounts\": [\n\t\t{\n\t\t    \"extended_public_key\": \"upub5Eep7....\",\n\t\t    \"derivation_path\": \"m/49'/0'/0'\"\n\t\t},\n\t\t{\n\t\t    \"extended_public_key\": \"vpub5ZU1PH...\",\n\t\t    \"derivation_path\": \"m/84'/0'/0'\"\n\t\t},\n\t\t{\n\t\t    \"extended_public_key\": \"tpubDDXFH...\",\n\t\t    \"derivation_path\": \"m/1017'/1'/0'\"\n\t\t},\n\t        ...\n\t\t{\n\t\t    \"extended_public_key\": \"tpubDDXFH...\",\n\t\t    \"derivation_path\": \"m/1017'/1'/9'\"\n\t\t}\n\t   ]\n\t}\n\n\tThere must be an account for each of the existing key families that lnd\n\tuses internally (currently 0-9, see keychain/derivation.go).\n\n\tRead the documentation under docs/remote-signing.md for more information\n\ton how to set up a remote signing node over RPC.\n\t`,\n\tFlags: []cli.Flag{\n\t\tstatelessInitFlag,\n\t\tsaveToFlag,\n\t},\n\tAction: actionDecorator(createWatchOnly),\n}\n",
      "length": 2872,
      "tokens": 381,
      "embedding": []
    },
    {
      "slug": "func createWatchOnly(ctx *cli.Context) error {",
      "content": "func createWatchOnly(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getWalletUnlockerClient(ctx)\n\tdefer cleanUp()\n\n\tif ctx.NArg() != 1 {\n\t\treturn cli.ShowCommandHelp(ctx, \"createwatchonly\")\n\t}\n\n\t// Should the daemon be initialized stateless? Then we expect an answer\n\t// with the admin macaroon later. Because the --save_to is related to\n\t// stateless init, it doesn't make sense to be set on its own.\n\tstatelessInit := ctx.Bool(statelessInitFlag.Name)\n\tif !statelessInit && ctx.IsSet(saveToFlag.Name) {\n\t\treturn fmt.Errorf(\"cannot set save_to parameter without \" +\n\t\t\t\"stateless_init\")\n\t}\n\n\tjsonFile := lncfg.CleanAndExpandPath(ctx.Args().First())\n\tjsonBytes, err := ioutil.ReadFile(jsonFile)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error reading JSON from file %v: %v\",\n\t\t\tjsonFile, err)\n\t}\n\n\tjsonAccts := &walletrpc.ListAccountsResponse{}\n\terr = jsonpb.Unmarshal(bytes.NewReader(jsonBytes), jsonAccts)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error parsing JSON: %v\", err)\n\t}\n\tif len(jsonAccts.Accounts) == 0 {\n\t\treturn fmt.Errorf(\"cannot import empty account list\")\n\t}\n\n\twalletPassword, err := capturePassword(\n\t\t\"Input wallet password: \", false,\n\t\twalletunlocker.ValidatePassword,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\textendedRootKeyBirthday, err := askBirthdayTimestamp()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trecoveryWindow, err := askRecoveryWindow()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trpcAccounts, err := walletrpc.AccountsToWatchOnly(jsonAccts.Accounts)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trpcResp := &lnrpc.WatchOnly{\n\t\tMasterKeyBirthdayTimestamp: extendedRootKeyBirthday,\n\t\tAccounts:                   rpcAccounts,\n\t}\n\n\t// We assume that all accounts were exported from the same master root\n\t// key. So if one is set, we just forward that. If other accounts should\n\t// be watched later on, they should be imported into the watch-only\n\t// node, that then also forwards the import request to the remote\n\t// signer.\n\tfor _, acct := range jsonAccts.Accounts {\n\t\tif len(acct.MasterKeyFingerprint) > 0 {\n\t\t\trpcResp.MasterKeyFingerprint = acct.MasterKeyFingerprint\n\t\t}\n\t}\n\n\tinitResp, err := client.InitWallet(ctxc, &lnrpc.InitWalletRequest{\n\t\tWalletPassword: walletPassword,\n\t\tWatchOnly:      rpcResp,\n\t\tRecoveryWindow: recoveryWindow,\n\t\tStatelessInit:  statelessInit,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif statelessInit {\n\t\treturn storeOrPrintAdminMac(ctx, initResp.AdminMacaroon)\n\t}\n\n\treturn nil\n}\n\n// storeOrPrintAdminMac either stores the admin macaroon to a file specified or\n// prints it to standard out, depending on the user flags set.",
      "length": 2428,
      "tokens": 317,
      "embedding": []
    },
    {
      "slug": "func storeOrPrintAdminMac(ctx *cli.Context, adminMac []byte) error {",
      "content": "func storeOrPrintAdminMac(ctx *cli.Context, adminMac []byte) error {\n\t// The user specified the optional --save_to parameter. We'll save the\n\t// macaroon to that file.\n\tif ctx.IsSet(saveToFlag.Name) {\n\t\tmacSavePath := lncfg.CleanAndExpandPath(ctx.String(\n\t\t\tsaveToFlag.Name,\n\t\t))\n\t\terr := os.WriteFile(macSavePath, adminMac, 0644)\n\t\tif err != nil {\n\t\t\t_ = os.Remove(macSavePath)\n\t\t\treturn err\n\t\t}\n\t\tfmt.Printf(\"Admin macaroon saved to %s\\n\", macSavePath)\n\t\treturn nil\n\t}\n\n\t// Otherwise we just print it. The user MUST store this macaroon\n\t// somewhere so we either save it to a provided file path or just print\n\t// it to standard output.\n\tfmt.Printf(\"Admin macaroon: %s\\n\", hex.EncodeToString(adminMac))\n\treturn nil\n}\n",
      "length": 628,
      "tokens": 88,
      "embedding": []
    },
    {
      "slug": "func askRecoveryWindow() (int32, error) {",
      "content": "func askRecoveryWindow() (int32, error) {\n\tfor {\n\t\tfmt.Println()\n\t\tfmt.Printf(\"Input an optional address look-ahead used to scan \"+\n\t\t\t\"for used keys (default %d): \", defaultRecoveryWindow)\n\n\t\treader := bufio.NewReader(os.Stdin)\n\t\tanswer, err := reader.ReadString('\\n')\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tfmt.Println()\n\n\t\tanswer = strings.TrimSpace(answer)\n\n\t\tif len(answer) == 0 {\n\t\t\treturn defaultRecoveryWindow, nil\n\t\t}\n\n\t\tlookAhead, err := strconv.ParseInt(answer, 10, 32)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Unable to parse recovery window: %v\\n\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\treturn int32(lookAhead), nil\n\t}\n}\n",
      "length": 545,
      "tokens": 73,
      "embedding": []
    },
    {
      "slug": "func askBirthdayTimestamp() (uint64, error) {",
      "content": "func askBirthdayTimestamp() (uint64, error) {\n\tfor {\n\t\tfmt.Println()\n\t\tfmt.Printf(\"Input an optional wallet birthday unix timestamp \" +\n\t\t\t\"of first block to start scanning from (default 0): \")\n\n\t\treader := bufio.NewReader(os.Stdin)\n\t\tanswer, err := reader.ReadString('\\n')\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tfmt.Println()\n\n\t\tanswer = strings.TrimSpace(answer)\n\n\t\tif len(answer) == 0 {\n\t\t\treturn 0, nil\n\t\t}\n\n\t\tbirthdayTimestamp, err := strconv.ParseUint(answer, 10, 64)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Unable to parse birthday timestamp: %v\\n\",\n\t\t\t\terr)\n\n\t\t\tcontinue\n\t\t}\n\n\t\treturn birthdayTimestamp, nil\n\t}\n}\n",
      "length": 541,
      "tokens": 76,
      "embedding": []
    },
    {
      "slug": "func printCipherSeedWords(mnemonicWords []string) {",
      "content": "func printCipherSeedWords(mnemonicWords []string) {\n\tfmt.Println(\"!!!YOU MUST WRITE DOWN THIS SEED TO BE ABLE TO \" +\n\t\t\"RESTORE THE WALLET!!!\")\n\tfmt.Println()\n\n\tfmt.Println(\"---------------BEGIN LND CIPHER SEED---------------\")\n\n\tnumCols := 4\n\tcolWords := monowidthColumns(mnemonicWords, numCols)\n\tfor i := 0; i < len(colWords); i += numCols {\n\t\tfmt.Printf(\"%2d. %3s  %2d. %3s  %2d. %3s  %2d. %3s\\n\",\n\t\t\ti+1, colWords[i], i+2, colWords[i+1], i+3,\n\t\t\tcolWords[i+2], i+4, colWords[i+3])\n\t}\n\n\tfmt.Println(\"---------------END LND CIPHER SEED-----------------\")\n\n\tfmt.Println(\"\\n!!!YOU MUST WRITE DOWN THIS SEED TO BE ABLE TO \" +\n\t\t\"RESTORE THE WALLET!!!\")\n}\n",
      "length": 583,
      "tokens": 75,
      "embedding": []
    }
  ]
}