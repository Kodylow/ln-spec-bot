{
  "filepath": "../implementations/go/lnd/cmd/lncli/cmd_payments.go",
  "package": "main",
  "sections": [
    {
      "slug": "func paymentFlags() []cli.Flag {",
      "content": "func paymentFlags() []cli.Flag {\n\treturn []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName:  \"pay_req\",\n\t\t\tUsage: \"a zpay32 encoded payment request to fulfill\",\n\t\t},\n\t\tcli.Int64Flag{\n\t\t\tName: \"fee_limit\",\n\t\t\tUsage: \"maximum fee allowed in satoshis when \" +\n\t\t\t\t\"sending the payment\",\n\t\t},\n\t\tcli.Int64Flag{\n\t\t\tName: \"fee_limit_percent\",\n\t\t\tUsage: \"percentage of the payment's amount used as \" +\n\t\t\t\t\"the maximum fee allowed when sending the \" +\n\t\t\t\t\"payment\",\n\t\t},\n\t\tcli.DurationFlag{\n\t\t\tName: \"timeout\",\n\t\t\tUsage: \"the maximum amount of time we should spend \" +\n\t\t\t\t\"trying to fulfill the payment, failing \" +\n\t\t\t\t\"after the timeout has elapsed\",\n\t\t\tValue: paymentTimeout,\n\t\t},\n\t\tcltvLimitFlag,\n\t\tlastHopFlag,\n\t\tcli.Uint64Flag{\n\t\t\tName: \"outgoing_chan_id\",\n\t\t\tUsage: \"short channel id of the outgoing channel to \" +\n\t\t\t\t\"use for the first hop of the payment\",\n\t\t\tValue: 0,\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"force, f\",\n\t\t\tUsage: \"will skip payment request confirmation\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"allow_self_payment\",\n\t\t\tUsage: \"allow sending a circular payment to self\",\n\t\t},\n\t\tdataFlag, inflightUpdatesFlag, maxPartsFlag, jsonFlag,\n\t\tmaxShardSizeSatFlag, maxShardSizeMsatFlag, ampFlag,\n\t\ttimePrefFlag,\n\t}\n}\n\nvar sendPaymentCommand = cli.Command{\n\tName:     \"sendpayment\",\n\tCategory: \"Payments\",\n\tUsage:    \"Send a payment over lightning.\",\n\tDescription: `\n\tSend a payment over Lightning. One can either specify the full\n\tparameters of the payment, or just use a payment request which encodes\n\tall the payment details.\n\n\tIf payment isn't manually specified, then only a payment request needs\n\tto be passed using the --pay_req argument.\n\n\tIf the payment *is* manually specified, then the following arguments\n\tneed to be specified in order to complete the payment:\n\n\tFor invoice with keysend,\n\t    --dest=N --amt=A --final_cltv_delta=T --keysend\n\tFor invoice without payment address:\n\t    --dest=N --amt=A --payment_hash=H --final_cltv_delta=T\n\tFor invoice with payment address:\n\t    --dest=N --amt=A --payment_hash=H --final_cltv_delta=T --pay_addr=H\n\t`,\n\tArgsUsage: \"dest amt payment_hash final_cltv_delta pay_addr | \" +\n\t\t\"--pay_req=R [--pay_addr=H]\",\n\tFlags: append(paymentFlags(),\n\t\tcli.StringFlag{\n\t\t\tName: \"dest, d\",\n\t\t\tUsage: \"the compressed identity pubkey of the \" +\n\t\t\t\t\"payment recipient\",\n\t\t},\n\t\tcli.Int64Flag{\n\t\t\tName:  \"amt, a\",\n\t\t\tUsage: \"number of satoshis to send\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"payment_hash, r\",\n\t\t\tUsage: \"the hash to use within the payment's HTLC\",\n\t\t},\n\t\tcli.Int64Flag{\n\t\t\tName:  \"final_cltv_delta\",\n\t\t\tUsage: \"the number of blocks the last hop has to reveal the preimage\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"pay_addr\",\n\t\t\tUsage: \"the payment address of the generated invoice\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"keysend\",\n\t\t\tUsage: \"will generate a pre-image and encode it in the sphinx packet, a dest must be set [experimental]\",\n\t\t},\n\t),\n\tAction: sendPayment,\n}\n\n// retrieveFeeLimit retrieves the fee limit based on the different fee limit\n// flags passed. It always returns a value and doesn't rely on lnd applying a\n// default.",
      "length": 2927,
      "tokens": 391,
      "embedding": []
    },
    {
      "slug": "func retrieveFeeLimit(ctx *cli.Context, amt int64) (int64, error) {",
      "content": "func retrieveFeeLimit(ctx *cli.Context, amt int64) (int64, error) {\n\tswitch {\n\tcase ctx.IsSet(\"fee_limit\") && ctx.IsSet(\"fee_limit_percent\"):\n\t\treturn 0, fmt.Errorf(\"either fee_limit or fee_limit_percent \" +\n\t\t\t\"can be set, but not both\")\n\n\tcase ctx.IsSet(\"fee_limit\"):\n\t\treturn ctx.Int64(\"fee_limit\"), nil\n\n\tcase ctx.IsSet(\"fee_limit_percent\"):\n\t\t// Round up the fee limit to prevent hitting zero on small\n\t\t// amounts.\n\t\tfeeLimitRoundedUp :=\n\t\t\t(amt*ctx.Int64(\"fee_limit_percent\") + 99) / 100\n\n\t\treturn feeLimitRoundedUp, nil\n\t}\n\n\t// If no fee limit is set, use a default value based on the amount.\n\tamtMsat := lnwire.NewMSatFromSatoshis(btcutil.Amount(amt))\n\tlimitMsat := lnwallet.DefaultRoutingFeeLimitForAmount(amtMsat)\n\treturn int64(limitMsat.ToSatoshis()), nil\n}\n",
      "length": 680,
      "tokens": 77,
      "embedding": []
    },
    {
      "slug": "func confirmPayReq(resp *lnrpc.PayReq, amt, feeLimit int64) error {",
      "content": "func confirmPayReq(resp *lnrpc.PayReq, amt, feeLimit int64) error {\n\tfmt.Printf(\"Payment hash: %v\\n\", resp.GetPaymentHash())\n\tfmt.Printf(\"Description: %v\\n\", resp.GetDescription())\n\tfmt.Printf(\"Amount (in satoshis): %v\\n\", amt)\n\tfmt.Printf(\"Fee limit (in satoshis): %v\\n\", feeLimit)\n\tfmt.Printf(\"Destination: %v\\n\", resp.GetDestination())\n\n\tconfirm := promptForConfirmation(\"Confirm payment (yes/no): \")\n\tif !confirm {\n\t\treturn fmt.Errorf(\"payment not confirmed\")\n\t}\n\n\treturn nil\n}\n",
      "length": 401,
      "tokens": 38,
      "embedding": []
    },
    {
      "slug": "func parsePayAddr(ctx *cli.Context, args cli.Args) ([]byte, error) {",
      "content": "func parsePayAddr(ctx *cli.Context, args cli.Args) ([]byte, error) {\n\tvar (\n\t\tpayAddr []byte\n\t\terr     error\n\t)\n\tswitch {\n\tcase ctx.IsSet(\"pay_addr\"):\n\t\tpayAddr, err = hex.DecodeString(ctx.String(\"pay_addr\"))\n\n\tcase args.Present():\n\t\tpayAddr, err = hex.DecodeString(args.First())\n\t}\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// payAddr may be not required if it's a legacy invoice.\n\tif len(payAddr) != 0 && len(payAddr) != 32 {\n\t\treturn nil, fmt.Errorf(\"payment addr must be exactly 32 \"+\n\t\t\t\"bytes, is instead %v\", len(payAddr))\n\t}\n\n\treturn payAddr, nil\n}\n",
      "length": 463,
      "tokens": 70,
      "embedding": []
    },
    {
      "slug": "func sendPayment(ctx *cli.Context) error {",
      "content": "func sendPayment(ctx *cli.Context) error {\n\t// Show command help if no arguments provided\n\tif ctx.NArg() == 0 && ctx.NumFlags() == 0 {\n\t\t_ = cli.ShowCommandHelp(ctx, \"sendpayment\")\n\t\treturn nil\n\t}\n\n\targs := ctx.Args()\n\n\t// If a payment request was provided, we can exit early since all of the\n\t// details of the payment are encoded within the request.\n\tif ctx.IsSet(\"pay_req\") {\n\t\treq := &routerrpc.SendPaymentRequest{\n\t\t\tPaymentRequest:    stripPrefix(ctx.String(\"pay_req\")),\n\t\t\tAmt:               ctx.Int64(\"amt\"),\n\t\t\tDestCustomRecords: make(map[uint64][]byte),\n\t\t}\n\n\t\t// We'll attempt to parse a payment address as well, given that\n\t\t// if the user is using an AMP invoice, then they may be trying\n\t\t// to specify that value manually.\n\t\t//\n\t\t// Don't parse unnamed arguments to prevent confusion with the main\n\t\t// unnamed argument format for non-AMP payments.\n\t\tpayAddr, err := parsePayAddr(ctx, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treq.PaymentAddr = payAddr\n\n\t\treturn sendPaymentRequest(ctx, req)\n\t}\n\n\tvar (\n\t\tdestNode []byte\n\t\tamount   int64\n\t\terr      error\n\t)\n\n\tswitch {\n\tcase ctx.IsSet(\"dest\"):\n\t\tdestNode, err = hex.DecodeString(ctx.String(\"dest\"))\n\tcase args.Present():\n\t\tdestNode, err = hex.DecodeString(args.First())\n\t\targs = args.Tail()\n\tdefault:\n\t\treturn fmt.Errorf(\"destination txid argument missing\")\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif len(destNode) != 33 {\n\t\treturn fmt.Errorf(\"dest node pubkey must be exactly 33 bytes, is \"+\n\t\t\t\"instead: %v\", len(destNode))\n\t}\n\n\tif ctx.IsSet(\"amt\") {\n\t\tamount = ctx.Int64(\"amt\")\n\t} else if args.Present() {\n\t\tamount, err = strconv.ParseInt(args.First(), 10, 64)\n\t\targs = args.Tail()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to decode payment amount: %v\", err)\n\t\t}\n\t}\n\n\treq := &routerrpc.SendPaymentRequest{\n\t\tDest:              destNode,\n\t\tAmt:               amount,\n\t\tDestCustomRecords: make(map[uint64][]byte),\n\t\tAmp:               ctx.Bool(ampFlag.Name),\n\t}\n\n\tvar rHash []byte\n\n\tswitch {\n\tcase ctx.Bool(\"keysend\") && ctx.Bool(ampFlag.Name):\n\t\treturn errors.New(\"either keysend or amp may be set, but not both\")\n\n\tcase ctx.Bool(\"keysend\"):\n\t\tif ctx.IsSet(\"payment_hash\") {\n\t\t\treturn errors.New(\"cannot set payment hash when using \" +\n\t\t\t\t\"keysend\")\n\t\t}\n\t\tvar preimage lntypes.Preimage\n\t\tif _, err := rand.Read(preimage[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Set the preimage. If the user supplied a preimage with the\n\t\t// data flag, the preimage that is set here will be overwritten\n\t\t// later.\n\t\treq.DestCustomRecords[record.KeySendType] = preimage[:]\n\n\t\thash := preimage.Hash()\n\t\trHash = hash[:]\n\tcase !ctx.Bool(ampFlag.Name):\n\t\tswitch {\n\t\tcase ctx.IsSet(\"payment_hash\"):\n\t\t\trHash, err = hex.DecodeString(ctx.String(\"payment_hash\"))\n\t\tcase args.Present():\n\t\t\trHash, err = hex.DecodeString(args.First())\n\t\t\targs = args.Tail()\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"payment hash argument missing\")\n\t\t}\n\t}\n\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !req.Amp && len(rHash) != 32 {\n\t\treturn fmt.Errorf(\"payment hash must be exactly 32 \"+\n\t\t\t\"bytes, is instead %v\", len(rHash))\n\t}\n\treq.PaymentHash = rHash\n\n\tswitch {\n\tcase ctx.IsSet(\"final_cltv_delta\"):\n\t\treq.FinalCltvDelta = int32(ctx.Int64(\"final_cltv_delta\"))\n\tcase args.Present():\n\t\tdelta, err := strconv.ParseInt(args.First(), 10, 64)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\targs = args.Tail()\n\t\treq.FinalCltvDelta = int32(delta)\n\t}\n\n\tpayAddr, err := parsePayAddr(ctx, args)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treq.PaymentAddr = payAddr\n\n\treturn sendPaymentRequest(ctx, req)\n}\n",
      "length": 3311,
      "tokens": 439,
      "embedding": []
    },
    {
      "slug": "func sendPaymentRequest(ctx *cli.Context,",
      "content": "func sendPaymentRequest(ctx *cli.Context,\n\treq *routerrpc.SendPaymentRequest) error {\n\n\tctxc := getContext()\n\n\tconn := getClientConn(ctx, false)\n\tdefer conn.Close()\n\n\tclient := lnrpc.NewLightningClient(conn)\n\trouterClient := routerrpc.NewRouterClient(conn)\n\n\toutChan := ctx.Uint64(\"outgoing_chan_id\")\n\tif outChan != 0 {\n\t\treq.OutgoingChanIds = []uint64{outChan}\n\t}\n\tif ctx.IsSet(lastHopFlag.Name) {\n\t\tlastHop, err := route.NewVertexFromStr(\n\t\t\tctx.String(lastHopFlag.Name),\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treq.LastHopPubkey = lastHop[:]\n\t}\n\n\treq.CltvLimit = int32(ctx.Int(cltvLimitFlag.Name))\n\n\tpmtTimeout := ctx.Duration(\"timeout\")\n\tif pmtTimeout <= 0 {\n\t\treturn errors.New(\"payment timeout must be greater than zero\")\n\t}\n\treq.TimeoutSeconds = int32(pmtTimeout.Seconds())\n\n\treq.AllowSelfPayment = ctx.Bool(\"allow_self_payment\")\n\n\treq.MaxParts = uint32(ctx.Uint(maxPartsFlag.Name))\n\n\tswitch {\n\t// If the max shard size is specified, then it should either be in sat\n\t// or msat, but not both.\n\tcase ctx.Uint64(maxShardSizeMsatFlag.Name) != 0 &&\n\t\tctx.Uint64(maxShardSizeSatFlag.Name) != 0:\n\t\treturn fmt.Errorf(\"only --max_split_size_msat or \" +\n\t\t\t\"--max_split_size_sat should be set, but not both\")\n\n\tcase ctx.Uint64(maxShardSizeMsatFlag.Name) != 0:\n\t\treq.MaxShardSizeMsat = ctx.Uint64(maxShardSizeMsatFlag.Name)\n\n\tcase ctx.Uint64(maxShardSizeSatFlag.Name) != 0:\n\t\treq.MaxShardSizeMsat = uint64(lnwire.NewMSatFromSatoshis(\n\t\t\tbtcutil.Amount(ctx.Uint64(maxShardSizeSatFlag.Name)),\n\t\t))\n\t}\n\n\t// Parse custom data records.\n\tdata := ctx.String(dataFlag.Name)\n\tif data != \"\" {\n\t\trecords := strings.Split(data, \",\")\n\t\tfor _, r := range records {\n\t\t\tkv := strings.Split(r, \"=\")\n\t\t\tif len(kv) != 2 {\n\t\t\t\treturn errors.New(\"invalid data format: \" +\n\t\t\t\t\t\"multiple equal signs in record\")\n\t\t\t}\n\n\t\t\trecordID, err := strconv.ParseUint(kv[0], 10, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"invalid data format: %v\",\n\t\t\t\t\terr)\n\t\t\t}\n\n\t\t\thexValue, err := hex.DecodeString(kv[1])\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"invalid data format: %v\",\n\t\t\t\t\terr)\n\t\t\t}\n\n\t\t\treq.DestCustomRecords[recordID] = hexValue\n\t\t}\n\t}\n\n\tvar feeLimit int64\n\tif req.PaymentRequest != \"\" {\n\t\t// Decode payment request to find out the amount.\n\t\tdecodeReq := &lnrpc.PayReqString{PayReq: req.PaymentRequest}\n\t\tdecodeResp, err := client.DecodePayReq(ctxc, decodeReq)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// If amount is present in the request, override the request\n\t\t// amount.\n\t\tamt := req.Amt\n\t\tinvoiceAmt := decodeResp.GetNumSatoshis()\n\t\tif invoiceAmt != 0 {\n\t\t\tamt = invoiceAmt\n\t\t}\n\n\t\t// Calculate fee limit based on the determined amount.\n\t\tfeeLimit, err = retrieveFeeLimit(ctx, amt)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Ask for confirmation of amount and fee limit if payment is\n\t\t// forced.\n\t\tif !ctx.Bool(\"force\") {\n\t\t\terr := confirmPayReq(decodeResp, amt, feeLimit)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t} else {\n\t\tvar err error\n\t\tfeeLimit, err = retrieveFeeLimit(ctx, req.Amt)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treq.FeeLimitSat = feeLimit\n\n\t// Set time pref.\n\treq.TimePref = ctx.Float64(timePrefFlag.Name)\n\n\t// Always print in-flight updates for the table output.\n\tprintJSON := ctx.Bool(jsonFlag.Name)\n\treq.NoInflightUpdates = !ctx.Bool(inflightUpdatesFlag.Name) && printJSON\n\n\tstream, err := routerClient.SendPaymentV2(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfinalState, err := printLivePayment(\n\t\tctxc, stream, client, printJSON,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// If we get a payment error back, we pass an error up\n\t// to main which eventually calls fatal() and returns\n\t// with a non-zero exit code.\n\tif finalState.Status != lnrpc.Payment_SUCCEEDED {\n\t\treturn errors.New(finalState.Status.String())\n\t}\n\n\treturn nil\n}\n\nvar trackPaymentCommand = cli.Command{\n\tName:     \"trackpayment\",\n\tCategory: \"Payments\",\n\tUsage:    \"Track progress of an existing payment.\",\n\tDescription: `\n\tPick up monitoring the progression of a previously initiated payment\n\tspecified by the hash argument.\n\t`,\n\tArgsUsage: \"hash\",\n\tFlags: []cli.Flag{\n\t\tjsonFlag,\n\t},\n\tAction: actionDecorator(trackPayment),\n}\n",
      "length": 3892,
      "tokens": 499,
      "embedding": []
    },
    {
      "slug": "func trackPayment(ctx *cli.Context) error {",
      "content": "func trackPayment(ctx *cli.Context) error {\n\tctxc := getContext()\n\targs := ctx.Args()\n\n\tconn := getClientConn(ctx, false)\n\tdefer conn.Close()\n\n\trouterClient := routerrpc.NewRouterClient(conn)\n\n\tif !args.Present() {\n\t\treturn fmt.Errorf(\"hash argument missing\")\n\t}\n\n\thash, err := hex.DecodeString(args.First())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treq := &routerrpc.TrackPaymentRequest{\n\t\tPaymentHash: hash,\n\t}\n\n\tstream, err := routerClient.TrackPaymentV2(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tclient := lnrpc.NewLightningClient(conn)\n\t_, err = printLivePayment(ctxc, stream, client, ctx.Bool(jsonFlag.Name))\n\treturn err\n}\n\n// printLivePayment receives payment updates from the given stream and either\n// outputs them as json or as a more user-friendly formatted table. The table\n// option uses terminal control codes to rewrite the output. This call\n// terminates when the payment reaches a final state.",
      "length": 830,
      "tokens": 113,
      "embedding": []
    },
    {
      "slug": "func printLivePayment(ctxc context.Context,",
      "content": "func printLivePayment(ctxc context.Context,\n\tstream routerrpc.Router_TrackPaymentV2Client,\n\tclient lnrpc.LightningClient, json bool) (*lnrpc.Payment, error) {\n\n\t// Terminal escape codes aren't supported on Windows, fall back to json.\n\tif !json && runtime.GOOS == \"windows\" {\n\t\tjson = true\n\t}\n\n\taliases := newAliasCache(client)\n\n\tfirst := true\n\tvar lastLineCount int\n\tfor {\n\t\tpayment, err := stream.Recv()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif json {\n\t\t\t// Delimit json messages by newlines (inspired by\n\t\t\t// grpc over rest chunking).\n\t\t\tif first {\n\t\t\t\tfirst = false\n\t\t\t} else {\n\t\t\t\tfmt.Println()\n\t\t\t}\n\n\t\t\t// Write raw json to stdout.\n\t\t\tprintRespJSON(payment)\n\t\t} else {\n\t\t\ttable := formatPayment(ctxc, payment, aliases)\n\n\t\t\t// Clear all previously written lines and print the\n\t\t\t// updated table.\n\t\t\tclearLines(lastLineCount)\n\t\t\tfmt.Print(table)\n\n\t\t\t// Store the number of lines written for the next update\n\t\t\t// pass.\n\t\t\tlastLineCount = 0\n\t\t\tfor _, b := range table {\n\t\t\t\tif b == '\\n' {\n\t\t\t\t\tlastLineCount++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Terminate loop if payments state is final.\n\t\tif payment.Status != lnrpc.Payment_IN_FLIGHT {\n\t\t\treturn payment, nil\n\t\t}\n\t}\n}\n\n// aliasCache allows cached retrieval of node aliases.",
      "length": 1122,
      "tokens": 171,
      "embedding": []
    },
    {
      "slug": "type aliasCache struct {",
      "content": "type aliasCache struct {\n\tcache  map[string]string\n\tclient lnrpc.LightningClient\n}\n",
      "length": 55,
      "tokens": 5,
      "embedding": []
    },
    {
      "slug": "func newAliasCache(client lnrpc.LightningClient) *aliasCache {",
      "content": "func newAliasCache(client lnrpc.LightningClient) *aliasCache {\n\treturn &aliasCache{\n\t\tclient: client,\n\t\tcache:  make(map[string]string),\n\t}\n}\n\n// get returns a node alias either from cache or freshly requested from lnd.",
      "length": 150,
      "tokens": 22,
      "embedding": []
    },
    {
      "slug": "func (a *aliasCache) get(ctxc context.Context, pubkey string) string {",
      "content": "func (a *aliasCache) get(ctxc context.Context, pubkey string) string {\n\talias, ok := a.cache[pubkey]\n\tif ok {\n\t\treturn alias\n\t}\n\n\t// Request node info.\n\tresp, err := a.client.GetNodeInfo(\n\t\tctxc,\n\t\t&lnrpc.NodeInfoRequest{\n\t\t\tPubKey: pubkey,\n\t\t},\n\t)\n\tif err != nil {\n\t\t// If no info is available, use the\n\t\t// pubkey as identifier.\n\t\talias = pubkey[:6]\n\t} else {\n\t\talias = resp.Node.Alias\n\t}\n\ta.cache[pubkey] = alias\n\n\treturn alias\n}\n\n// formatMsat formats msat amounts as fractional sats.",
      "length": 393,
      "tokens": 65,
      "embedding": []
    },
    {
      "slug": "func formatMsat(amt int64) string {",
      "content": "func formatMsat(amt int64) string {\n\treturn strconv.FormatFloat(float64(amt)/1000.0, 'f', -1, 64)\n}\n\n// formatPayment formats the payment state as an ascii table.",
      "length": 123,
      "tokens": 16,
      "embedding": []
    },
    {
      "slug": "func formatPayment(ctxc context.Context, payment *lnrpc.Payment,",
      "content": "func formatPayment(ctxc context.Context, payment *lnrpc.Payment,\n\taliases *aliasCache) string {\n\n\tt := table.NewWriter()\n\n\t// Build table header.\n\tt.AppendHeader(table.Row{\n\t\t\"HTLC_STATE\", \"ATTEMPT_TIME\", \"RESOLVE_TIME\", \"RECEIVER_AMT\",\n\t\t\"FEE\", \"TIMELOCK\", \"CHAN_OUT\", \"ROUTE\",\n\t})\n\tt.SetColumnConfigs([]table.ColumnConfig{\n\t\t{Name: \"ATTEMPT_TIME\", Align: text.AlignRight},\n\t\t{Name: \"RESOLVE_TIME\", Align: text.AlignRight},\n\t\t{Name: \"CHAN_OUT\", Align: text.AlignLeft,\n\t\t\tAlignHeader: text.AlignLeft},\n\t})\n\n\t// Add all htlcs as rows.\n\tcreateTime := time.Unix(0, payment.CreationTimeNs)\n\tvar totalPaid, totalFees int64\n\tfor _, htlc := range payment.Htlcs {\n\t\tformatTime := func(timeNs int64) string {\n\t\t\tif timeNs == 0 {\n\t\t\t\treturn \"-\"\n\t\t\t}\n\t\t\tresolveTime := time.Unix(0, timeNs)\n\t\t\tresolveTimeDiff := resolveTime.Sub(createTime)\n\t\t\tresolveTimeMs := resolveTimeDiff / time.Millisecond\n\t\t\treturn fmt.Sprintf(\n\t\t\t\t\"%.3f\", float64(resolveTimeMs)/1000.0,\n\t\t\t)\n\t\t}\n\n\t\tattemptTime := formatTime(htlc.AttemptTimeNs)\n\t\tresolveTime := formatTime(htlc.ResolveTimeNs)\n\n\t\troute := htlc.Route\n\t\tlastHop := route.Hops[len(route.Hops)-1]\n\n\t\thops := []string{}\n\t\tfor _, h := range route.Hops {\n\t\t\talias := aliases.get(ctxc, h.PubKey)\n\t\t\thops = append(hops, alias)\n\t\t}\n\n\t\tstate := htlc.Status.String()\n\t\tif htlc.Failure != nil {\n\t\t\tstate = fmt.Sprintf(\n\t\t\t\t\"%v @ %s hop\",\n\t\t\t\thtlc.Failure.Code,\n\t\t\t\tordinalNumber(htlc.Failure.FailureSourceIndex),\n\t\t\t)\n\t\t}\n\n\t\tt.AppendRow([]interface{}{\n\t\t\tstate, attemptTime, resolveTime,\n\t\t\tformatMsat(lastHop.AmtToForwardMsat),\n\t\t\tformatMsat(route.TotalFeesMsat),\n\t\t\troute.TotalTimeLock, route.Hops[0].ChanId,\n\t\t\tstrings.Join(hops, \"->\")},\n\t\t)\n\n\t\tif htlc.Status == lnrpc.HTLCAttempt_SUCCEEDED {\n\t\t\ttotalPaid += lastHop.AmtToForwardMsat\n\t\t\ttotalFees += route.TotalFeesMsat\n\t\t}\n\t}\n\n\t// Render table.\n\tb := &bytes.Buffer{}\n\tt.SetOutputMirror(b)\n\tt.Render()\n\n\t// Add additional payment-level data.\n\tfmt.Fprintf(b, \"Amount + fee:   %v + %v sat\\n\",\n\t\tformatMsat(totalPaid), formatMsat(totalFees))\n\tfmt.Fprintf(b, \"Payment hash:   %v\\n\", payment.PaymentHash)\n\tfmt.Fprintf(b, \"Payment status: %v\", payment.Status)\n\tswitch payment.Status {\n\tcase lnrpc.Payment_SUCCEEDED:\n\t\tfmt.Fprintf(b, \", preimage: %v\", payment.PaymentPreimage)\n\tcase lnrpc.Payment_FAILED:\n\t\tfmt.Fprintf(b, \", reason: %v\", payment.FailureReason)\n\t}\n\tfmt.Fprintf(b, \"\\n\")\n\n\treturn b.String()\n}\n\nvar payInvoiceCommand = cli.Command{\n\tName:      \"payinvoice\",\n\tCategory:  \"Payments\",\n\tUsage:     \"Pay an invoice over lightning.\",\n\tArgsUsage: \"pay_req\",\n\tFlags: append(paymentFlags(),\n\t\tcli.Int64Flag{\n\t\t\tName: \"amt\",\n\t\t\tUsage: \"(optional) number of satoshis to fulfill the \" +\n\t\t\t\t\"invoice\",\n\t\t},\n\t),\n\tAction: actionDecorator(payInvoice),\n}\n",
      "length": 2548,
      "tokens": 257,
      "embedding": []
    },
    {
      "slug": "func payInvoice(ctx *cli.Context) error {",
      "content": "func payInvoice(ctx *cli.Context) error {\n\targs := ctx.Args()\n\n\tvar payReq string\n\tswitch {\n\tcase ctx.IsSet(\"pay_req\"):\n\t\tpayReq = ctx.String(\"pay_req\")\n\tcase args.Present():\n\t\tpayReq = args.First()\n\tdefault:\n\t\treturn fmt.Errorf(\"pay_req argument missing\")\n\t}\n\n\treq := &routerrpc.SendPaymentRequest{\n\t\tPaymentRequest:    stripPrefix(payReq),\n\t\tAmt:               ctx.Int64(\"amt\"),\n\t\tDestCustomRecords: make(map[uint64][]byte),\n\t}\n\n\treturn sendPaymentRequest(ctx, req)\n}\n\nvar sendToRouteCommand = cli.Command{\n\tName:     \"sendtoroute\",\n\tCategory: \"Payments\",\n\tUsage:    \"Send a payment over a predefined route.\",\n\tDescription: `\n\tSend a payment over Lightning using a specific route. One must specify\n\tthe route to attempt and the payment hash. This command can even\n\tbe chained with the response to queryroutes or buildroute. This command\n\tcan be used to implement channel rebalancing by crafting a self-route,\n\tor even atomic swaps using a self-route that crosses multiple chains.\n\n\tThere are three ways to specify a route:\n\t   * using the --routes parameter to manually specify a JSON encoded\n\t     route in the format of the return value of queryroutes or\n\t     buildroute:\n\t         (lncli sendtoroute --payment_hash=<pay_hash> --routes=<route>)\n\n\t   * passing the route as a positional argument:\n\t         (lncli sendtoroute --payment_hash=pay_hash <route>)\n\n\t   * or reading in the route from stdin, which can allow chaining the\n\t     response from queryroutes or buildroute, or even read in a file\n\t     with a pre-computed route:\n\t         (lncli queryroutes --args.. | lncli sendtoroute --payment_hash= -\n\n\t     notice the '-' at the end, which signals that lncli should read\n\t     the route in from stdin\n\t`,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName:  \"payment_hash, pay_hash\",\n\t\t\tUsage: \"the hash to use within the payment's HTLC\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName: \"routes, r\",\n\t\t\tUsage: \"a json array string in the format of the response \" +\n\t\t\t\t\"of queryroutes that denotes which routes to use\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName: \"skip_temp_err\",\n\t\t\tUsage: \"Whether the payment should be marked as \" +\n\t\t\t\t\"failed when a temporary error occurred. Set \" +\n\t\t\t\t\"it to true so the payment won't be failed \" +\n\t\t\t\t\"unless a terminal error has occurred.\",\n\t\t},\n\t},\n\tAction: sendToRoute,\n}\n",
      "length": 2186,
      "tokens": 300,
      "embedding": []
    },
    {
      "slug": "func sendToRoute(ctx *cli.Context) error {",
      "content": "func sendToRoute(ctx *cli.Context) error {\n\t// Show command help if no arguments provided.\n\tif ctx.NArg() == 0 && ctx.NumFlags() == 0 {\n\t\t_ = cli.ShowCommandHelp(ctx, \"sendtoroute\")\n\t\treturn nil\n\t}\n\n\targs := ctx.Args()\n\n\tvar (\n\t\trHash []byte\n\t\terr   error\n\t)\n\tswitch {\n\tcase ctx.IsSet(\"payment_hash\"):\n\t\trHash, err = hex.DecodeString(ctx.String(\"payment_hash\"))\n\tcase args.Present():\n\t\trHash, err = hex.DecodeString(args.First())\n\n\t\targs = args.Tail()\n\tdefault:\n\t\treturn fmt.Errorf(\"payment hash argument missing\")\n\t}\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif len(rHash) != 32 {\n\t\treturn fmt.Errorf(\"payment hash must be exactly 32 \"+\n\t\t\t\"bytes, is instead %d\", len(rHash))\n\t}\n\n\tvar jsonRoutes string\n\tswitch {\n\t// The user is specifying the routes explicitly via the key word\n\t// argument.\n\tcase ctx.IsSet(\"routes\"):\n\t\tjsonRoutes = ctx.String(\"routes\")\n\n\t// The user is specifying the routes as a positional argument.\n\tcase args.Present() && args.First() != \"-\":\n\t\tjsonRoutes = args.First()\n\n\t// The user is signalling that we should read stdin in order to parse\n\t// the set of target routes.\n\tcase args.Present() && args.First() == \"-\":\n\t\tb, err := ioutil.ReadAll(os.Stdin)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif len(b) == 0 {\n\t\t\treturn fmt.Errorf(\"queryroutes output is empty\")\n\t\t}\n\n\t\tjsonRoutes = string(b)\n\t}\n\n\t// Try to parse the provided json both in the legacy QueryRoutes format\n\t// that contains a list of routes and the single route BuildRoute\n\t// format.\n\tvar route *lnrpc.Route\n\troutes := &lnrpc.QueryRoutesResponse{}\n\terr = jsonpb.UnmarshalString(jsonRoutes, routes)\n\tif err == nil {\n\t\tif len(routes.Routes) == 0 {\n\t\t\treturn fmt.Errorf(\"no routes provided\")\n\t\t}\n\n\t\tif len(routes.Routes) != 1 {\n\t\t\treturn fmt.Errorf(\"expected a single route, but got %v\",\n\t\t\t\tlen(routes.Routes))\n\t\t}\n\n\t\troute = routes.Routes[0]\n\t} else {\n\t\troutes := &routerrpc.BuildRouteResponse{}\n\t\terr = jsonpb.UnmarshalString(jsonRoutes, routes)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to unmarshal json string \"+\n\t\t\t\t\"from incoming array of routes: %v\", err)\n\t\t}\n\n\t\troute = routes.Route\n\t}\n\n\treq := &routerrpc.SendToRouteRequest{\n\t\tPaymentHash: rHash,\n\t\tRoute:       route,\n\t\tSkipTempErr: ctx.Bool(\"skip_temp_err\"),\n\t}\n\n\treturn sendToRouteRequest(ctx, req)\n}\n",
      "length": 2113,
      "tokens": 300,
      "embedding": []
    },
    {
      "slug": "func sendToRouteRequest(ctx *cli.Context, req *routerrpc.SendToRouteRequest) error {",
      "content": "func sendToRouteRequest(ctx *cli.Context, req *routerrpc.SendToRouteRequest) error {\n\tctxc := getContext()\n\tconn := getClientConn(ctx, false)\n\tdefer conn.Close()\n\n\tclient := routerrpc.NewRouterClient(conn)\n\n\tresp, err := client.SendToRouteV2(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(resp)\n\n\treturn nil\n}\n\nvar queryRoutesCommand = cli.Command{\n\tName:        \"queryroutes\",\n\tCategory:    \"Payments\",\n\tUsage:       \"Query a route to a destination.\",\n\tDescription: \"Queries the channel router for a potential path to the destination that has sufficient flow for the amount including fees\",\n\tArgsUsage:   \"dest amt\",\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName: \"dest\",\n\t\t\tUsage: \"the 33-byte hex-encoded public key for the payment \" +\n\t\t\t\t\"destination\",\n\t\t},\n\t\tcli.Int64Flag{\n\t\t\tName:  \"amt\",\n\t\t\tUsage: \"the amount to send expressed in satoshis\",\n\t\t},\n\t\tcli.Int64Flag{\n\t\t\tName: \"fee_limit\",\n\t\t\tUsage: \"maximum fee allowed in satoshis when sending \" +\n\t\t\t\t\"the payment\",\n\t\t},\n\t\tcli.Int64Flag{\n\t\t\tName: \"fee_limit_percent\",\n\t\t\tUsage: \"percentage of the payment's amount used as the \" +\n\t\t\t\t\"maximum fee allowed when sending the payment\",\n\t\t},\n\t\tcli.Int64Flag{\n\t\t\tName: \"final_cltv_delta\",\n\t\t\tUsage: \"(optional) number of blocks the last hop has to reveal \" +\n\t\t\t\t\"the preimage\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"use_mc\",\n\t\t\tUsage: \"use mission control probabilities\",\n\t\t},\n\t\tcli.Uint64Flag{\n\t\t\tName: \"outgoing_chanid\",\n\t\t\tUsage: \"(optional) the channel id of the channel \" +\n\t\t\t\t\"that must be taken to the first hop\",\n\t\t},\n\t\tcli.StringSliceFlag{\n\t\t\tName: \"ignore_pair\",\n\t\t\tUsage: \"ignore directional node pair \" +\n\t\t\t\t\"<node1>:<node2>. This flag can be specified \" +\n\t\t\t\t\"multiple times if multiple node pairs are \" +\n\t\t\t\t\"to be ignored\",\n\t\t},\n\t\ttimePrefFlag,\n\t\tcltvLimitFlag,\n\t},\n\tAction: actionDecorator(queryRoutes),\n}\n",
      "length": 1683,
      "tokens": 223,
      "embedding": []
    },
    {
      "slug": "func queryRoutes(ctx *cli.Context) error {",
      "content": "func queryRoutes(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\tvar (\n\t\tdest string\n\t\tamt  int64\n\t\terr  error\n\t)\n\n\targs := ctx.Args()\n\n\tswitch {\n\tcase ctx.IsSet(\"dest\"):\n\t\tdest = ctx.String(\"dest\")\n\tcase args.Present():\n\t\tdest = args.First()\n\t\targs = args.Tail()\n\tdefault:\n\t\treturn fmt.Errorf(\"dest argument missing\")\n\t}\n\n\tswitch {\n\tcase ctx.IsSet(\"amt\"):\n\t\tamt = ctx.Int64(\"amt\")\n\tcase args.Present():\n\t\tamt, err = strconv.ParseInt(args.First(), 10, 64)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to decode amt argument: %v\", err)\n\t\t}\n\tdefault:\n\t\treturn fmt.Errorf(\"amt argument missing\")\n\t}\n\n\tfeeLimit, err := retrieveFeeLimitLegacy(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpairs := ctx.StringSlice(\"ignore_pair\")\n\tignoredPairs := make([]*lnrpc.NodePair, len(pairs))\n\tfor i, pair := range pairs {\n\t\tnodes := strings.Split(pair, \":\")\n\t\tif len(nodes) != 2 {\n\t\t\treturn fmt.Errorf(\"invalid node pair format. \" +\n\t\t\t\t\"Expected <node1 pub key>:<node2 pub key>\")\n\t\t}\n\n\t\tnode1, err := hex.DecodeString(nodes[0])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tnode2, err := hex.DecodeString(nodes[1])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tignoredPairs[i] = &lnrpc.NodePair{\n\t\t\tFrom: node1,\n\t\t\tTo:   node2,\n\t\t}\n\t}\n\n\treq := &lnrpc.QueryRoutesRequest{\n\t\tPubKey:            dest,\n\t\tAmt:               amt,\n\t\tFeeLimit:          feeLimit,\n\t\tFinalCltvDelta:    int32(ctx.Int(\"final_cltv_delta\")),\n\t\tUseMissionControl: ctx.Bool(\"use_mc\"),\n\t\tCltvLimit:         uint32(ctx.Uint64(cltvLimitFlag.Name)),\n\t\tOutgoingChanId:    ctx.Uint64(\"outgoing_chanid\"),\n\t\tTimePref:          ctx.Float64(timePrefFlag.Name),\n\t\tIgnoredPairs:      ignoredPairs,\n\t}\n\n\troute, err := client.QueryRoutes(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(route)\n\treturn nil\n}\n\n// retrieveFeeLimitLegacy retrieves the fee limit based on the different fee\n// limit flags passed. This function will eventually disappear in favor of\n// retrieveFeeLimit and the new payment rpc.",
      "length": 1862,
      "tokens": 228,
      "embedding": []
    },
    {
      "slug": "func retrieveFeeLimitLegacy(ctx *cli.Context) (*lnrpc.FeeLimit, error) {",
      "content": "func retrieveFeeLimitLegacy(ctx *cli.Context) (*lnrpc.FeeLimit, error) {\n\tswitch {\n\tcase ctx.IsSet(\"fee_limit\") && ctx.IsSet(\"fee_limit_percent\"):\n\t\treturn nil, fmt.Errorf(\"either fee_limit or fee_limit_percent \" +\n\t\t\t\"can be set, but not both\")\n\tcase ctx.IsSet(\"fee_limit\"):\n\t\treturn &lnrpc.FeeLimit{\n\t\t\tLimit: &lnrpc.FeeLimit_Fixed{\n\t\t\t\tFixed: ctx.Int64(\"fee_limit\"),\n\t\t\t},\n\t\t}, nil\n\tcase ctx.IsSet(\"fee_limit_percent\"):\n\t\tfeeLimitPercent := ctx.Int64(\"fee_limit_percent\")\n\t\tif feeLimitPercent < 0 {\n\t\t\treturn nil, errors.New(\"negative fee limit percentage \" +\n\t\t\t\t\"provided\")\n\t\t}\n\t\treturn &lnrpc.FeeLimit{\n\t\t\tLimit: &lnrpc.FeeLimit_Percent{\n\t\t\t\tPercent: feeLimitPercent,\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Since the fee limit flags aren't required, we don't return an error\n\t// if they're not set.\n\treturn nil, nil\n}\n\nvar listPaymentsCommand = cli.Command{\n\tName:     \"listpayments\",\n\tCategory: \"Payments\",\n\tUsage:    \"List all outgoing payments.\",\n\tDescription: `\n\tThis command enables the retrieval of payments stored\n\tin the database.\n\n\tPagination is supported by the usage of index_offset in combination with\n\tthe paginate_forwards flag.\n\tReversed pagination is enabled by default to receive current payments\n\tfirst. Pagination can be resumed by using the returned last_index_offset\n\t(for forwards order), or first_index_offset (for reversed order) as the\n\toffset_index.\n\n\tBecause counting all payments in the payment database can take a long\n\ttime on systems with many payments, the count is not returned by\n\tdefault. That feature can be turned on with the --count_total_payments\n\tflag.\n\t`,\n\tFlags: []cli.Flag{\n\t\tcli.BoolFlag{\n\t\t\tName: \"include_incomplete\",\n\t\t\tUsage: \"if set to true, payments still in flight (or \" +\n\t\t\t\t\"failed) will be returned as well, keeping\" +\n\t\t\t\t\"indices for payments the same as without \" +\n\t\t\t\t\"the flag\",\n\t\t},\n\t\tcli.UintFlag{\n\t\t\tName: \"index_offset\",\n\t\t\tUsage: \"The index of a payment that will be used as \" +\n\t\t\t\t\"either the start (in forwards mode) or end \" +\n\t\t\t\t\"(in reverse mode) of a query to determine \" +\n\t\t\t\t\"which payments should be returned in the \" +\n\t\t\t\t\"response, where the index_offset is \" +\n\t\t\t\t\"excluded. If index_offset is set to zero in \" +\n\t\t\t\t\"reversed mode, the query will end with the \" +\n\t\t\t\t\"last payment made.\",\n\t\t},\n\t\tcli.UintFlag{\n\t\t\tName: \"max_payments\",\n\t\t\tUsage: \"the max number of payments to return, by \" +\n\t\t\t\t\"default, all completed payments are returned\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName: \"paginate_forwards\",\n\t\t\tUsage: \"if set, payments succeeding the \" +\n\t\t\t\t\"index_offset will be returned, allowing \" +\n\t\t\t\t\"forwards pagination\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName: \"count_total_payments\",\n\t\t\tUsage: \"if set, all payments (complete or incomplete, \" +\n\t\t\t\t\"independent of max_payments parameter) will \" +\n\t\t\t\t\"be counted; can take a long time on systems \" +\n\t\t\t\t\"with many payments\",\n\t\t},\n\t\tcli.Uint64Flag{\n\t\t\tName: \"creation_date_start\",\n\t\t\tUsage: \"timestamp in seconds, if set, filter \" +\n\t\t\t\t\"payments with creation date greater than or \" +\n\t\t\t\t\"equal to it\",\n\t\t},\n\t\tcli.Uint64Flag{\n\t\t\tName: \"creation_date_end\",\n\t\t\tUsage: \"timestamp in seconds, if set, filter \" +\n\t\t\t\t\"payments with creation date less than or \" +\n\t\t\t\t\"equal to it\",\n\t\t},\n\t},\n\tAction: actionDecorator(listPayments),\n}\n",
      "length": 3070,
      "tokens": 434,
      "embedding": []
    },
    {
      "slug": "func listPayments(ctx *cli.Context) error {",
      "content": "func listPayments(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\treq := &lnrpc.ListPaymentsRequest{\n\t\tIncludeIncomplete:  ctx.Bool(\"include_incomplete\"),\n\t\tIndexOffset:        uint64(ctx.Uint(\"index_offset\")),\n\t\tMaxPayments:        uint64(ctx.Uint(\"max_payments\")),\n\t\tReversed:           !ctx.Bool(\"paginate_forwards\"),\n\t\tCountTotalPayments: ctx.Bool(\"count_total_payments\"),\n\t\tCreationDateStart:  ctx.Uint64(\"creation_date_start\"),\n\t\tCreationDateEnd:    ctx.Uint64(\"creation_date_end\"),\n\t}\n\n\tpayments, err := client.ListPayments(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(payments)\n\treturn nil\n}\n\nvar forwardingHistoryCommand = cli.Command{\n\tName:      \"fwdinghistory\",\n\tCategory:  \"Payments\",\n\tUsage:     \"Query the history of all forwarded HTLCs.\",\n\tArgsUsage: \"start_time [end_time] [index_offset] [max_events]\",\n\tDescription: `\n\tQuery the HTLC switch's internal forwarding log for all completed\n\tpayment circuits (HTLCs) over a particular time range (--start_time and\n\t--end_time). The start and end times are meant to be expressed in\n\tseconds since the Unix epoch.\n\tAlternatively negative time ranges can be used, e.g. \"-3d\". Supports\n\ts(seconds), m(minutes), h(ours), d(ays), w(eeks), M(onths), y(ears).\n\tMonth equals 30.44 days, year equals 365.25 days.\n\tIf --start_time isn't provided, then 24 hours ago is used. If\n\t--end_time isn't provided, then the current time is used.\n\n\tThe max number of events returned is 50k. The default number is 100,\n\tcallers can use the --max_events param to modify this value.\n\n\tFinally, callers can skip a series of events using the --index_offset\n\tparameter. Each response will contain the offset index of the last\n\tentry. Using this callers can manually paginate within a time slice.\n\t`,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName: \"start_time\",\n\t\t\tUsage: \"the starting time for the query \" +\n\t\t\t\t`as unix timestamp or relative e.g. \"-1w\"`,\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName: \"end_time\",\n\t\t\tUsage: \"the end time for the query \" +\n\t\t\t\t`as unix timestamp or relative e.g. \"-1w\"`,\n\t\t},\n\t\tcli.Int64Flag{\n\t\t\tName:  \"index_offset\",\n\t\t\tUsage: \"the number of events to skip\",\n\t\t},\n\t\tcli.Int64Flag{\n\t\t\tName:  \"max_events\",\n\t\t\tUsage: \"the max number of events to return\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName: \"skip_peer_alias_lookup\",\n\t\t\tUsage: \"skip the peer alias lookup per forwarding \" +\n\t\t\t\t\"event in order to improve performance\",\n\t\t},\n\t},\n\tAction: actionDecorator(forwardingHistory),\n}\n",
      "length": 2374,
      "tokens": 295,
      "embedding": []
    },
    {
      "slug": "func forwardingHistory(ctx *cli.Context) error {",
      "content": "func forwardingHistory(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\tvar (\n\t\tstartTime, endTime     uint64\n\t\tindexOffset, maxEvents uint32\n\t\terr                    error\n\t)\n\targs := ctx.Args()\n\tnow := time.Now()\n\n\tswitch {\n\tcase ctx.IsSet(\"start_time\"):\n\t\tstartTime, err = parseTime(ctx.String(\"start_time\"), now)\n\tcase args.Present():\n\t\tstartTime, err = parseTime(args.First(), now)\n\t\targs = args.Tail()\n\tdefault:\n\t\tnow := time.Now()\n\t\tstartTime = uint64(now.Add(-time.Hour * 24).Unix())\n\t}\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to decode start_time: %v\", err)\n\t}\n\n\tswitch {\n\tcase ctx.IsSet(\"end_time\"):\n\t\tendTime, err = parseTime(ctx.String(\"end_time\"), now)\n\tcase args.Present():\n\t\tendTime, err = parseTime(args.First(), now)\n\t\targs = args.Tail()\n\tdefault:\n\t\tendTime = uint64(now.Unix())\n\t}\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to decode end_time: %v\", err)\n\t}\n\n\tswitch {\n\tcase ctx.IsSet(\"index_offset\"):\n\t\tindexOffset = uint32(ctx.Int64(\"index_offset\"))\n\tcase args.Present():\n\t\ti, err := strconv.ParseInt(args.First(), 10, 64)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to decode index_offset: %v\",\n\t\t\t\terr)\n\t\t}\n\t\tindexOffset = uint32(i)\n\t\targs = args.Tail()\n\t}\n\n\tswitch {\n\tcase ctx.IsSet(\"max_events\"):\n\t\tmaxEvents = uint32(ctx.Int64(\"max_events\"))\n\tcase args.Present():\n\t\tm, err := strconv.ParseInt(args.First(), 10, 64)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to decode max_events: %v\",\n\t\t\t\terr)\n\t\t}\n\t\tmaxEvents = uint32(m)\n\t}\n\n\t// By default we will look up the peers' alias information unless the\n\t// skip_peer_alias_lookup flag is specified.\n\tlookupPeerAlias := !ctx.Bool(\"skip_peer_alias_lookup\")\n\n\treq := &lnrpc.ForwardingHistoryRequest{\n\t\tStartTime:       startTime,\n\t\tEndTime:         endTime,\n\t\tIndexOffset:     indexOffset,\n\t\tNumMaxEvents:    maxEvents,\n\t\tPeerAliasLookup: lookupPeerAlias,\n\t}\n\tresp, err := client.ForwardingHistory(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(resp)\n\treturn nil\n}\n\nvar buildRouteCommand = cli.Command{\n\tName:     \"buildroute\",\n\tCategory: \"Payments\",\n\tUsage:    \"Build a route from a list of hop pubkeys.\",\n\tAction:   actionDecorator(buildRoute),\n\tFlags: []cli.Flag{\n\t\tcli.Int64Flag{\n\t\t\tName: \"amt\",\n\t\t\tUsage: \"the amount to send expressed in satoshis. If\" +\n\t\t\t\t\"not set, the minimum routable amount is used\",\n\t\t},\n\t\tcli.Int64Flag{\n\t\t\tName: \"final_cltv_delta\",\n\t\t\tUsage: \"number of blocks the last hop has to reveal \" +\n\t\t\t\t\"the preimage\",\n\t\t\tValue: chainreg.DefaultBitcoinTimeLockDelta,\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"hops\",\n\t\t\tUsage: \"comma separated hex pubkeys\",\n\t\t},\n\t\tcli.Uint64Flag{\n\t\t\tName: \"outgoing_chan_id\",\n\t\t\tUsage: \"short channel id of the outgoing channel to \" +\n\t\t\t\t\"use for the first hop of the payment\",\n\t\t\tValue: 0,\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName: \"payment_addr\",\n\t\t\tUsage: \"hex encoded payment address to set in the \" +\n\t\t\t\t\"last hop's mpp record\",\n\t\t},\n\t},\n}\n",
      "length": 2762,
      "tokens": 343,
      "embedding": []
    },
    {
      "slug": "func buildRoute(ctx *cli.Context) error {",
      "content": "func buildRoute(ctx *cli.Context) error {\n\tctxc := getContext()\n\tconn := getClientConn(ctx, false)\n\tdefer conn.Close()\n\n\tclient := routerrpc.NewRouterClient(conn)\n\n\tif !ctx.IsSet(\"hops\") {\n\t\treturn errors.New(\"hops required\")\n\t}\n\n\t// Build list of hop addresses for the rpc.\n\thops := strings.Split(ctx.String(\"hops\"), \",\")\n\trpcHops := make([][]byte, 0, len(hops))\n\tfor _, k := range hops {\n\t\tpubkey, err := route.NewVertexFromStr(k)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error parsing %v: %v\", k, err)\n\t\t}\n\t\trpcHops = append(rpcHops, pubkey[:])\n\t}\n\n\tvar amtMsat int64\n\thasAmt := ctx.IsSet(\"amt\")\n\tif hasAmt {\n\t\tamtMsat = ctx.Int64(\"amt\") * 1000\n\t\tif amtMsat == 0 {\n\t\t\treturn fmt.Errorf(\"non-zero amount required\")\n\t\t}\n\t}\n\n\tvar (\n\t\tpayAddr []byte\n\t\terr     error\n\t)\n\tif ctx.IsSet(\"payment_addr\") {\n\t\tpayAddr, err = hex.DecodeString(ctx.String(\"payment_addr\"))\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error parsing payment_addr: %v\", err)\n\t\t}\n\t}\n\n\t// Call BuildRoute rpc.\n\treq := &routerrpc.BuildRouteRequest{\n\t\tAmtMsat:        amtMsat,\n\t\tFinalCltvDelta: int32(ctx.Int64(\"final_cltv_delta\")),\n\t\tHopPubkeys:     rpcHops,\n\t\tOutgoingChanId: ctx.Uint64(\"outgoing_chan_id\"),\n\t\tPaymentAddr:    payAddr,\n\t}\n\n\troute, err := client.BuildRoute(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintRespJSON(route)\n\n\treturn nil\n}\n\nvar deletePaymentsCommand = cli.Command{\n\tName:     \"deletepayments\",\n\tCategory: \"Payments\",\n\tUsage:    \"Delete a single or multiple payments from the database.\",\n\tArgsUsage: \"--all [--failed_htlcs_only --include_non_failed] | \" +\n\t\t\"--payment_hash hash [--failed_htlcs_only]\",\n\tDescription: `\n\tThis command either deletes all failed payments or a single payment from\n\tthe database to reclaim disk space.\n\n\tIf the --all flag is used, then all failed payments are removed. If so\n\tdesired, _ALL_ payments (even the successful ones) can be deleted\n\tby additionally specifying --include_non_failed.\n\n\tIf a --payment_hash is specified, that single payment is deleted,\n\tindependent of its state.\n\n\tIf --failed_htlcs_only is specified then the payments themselves (or the\n\tsingle payment itself if used with --payment_hash) is not deleted, only\n\tthe information about any failed HTLC attempts during the payment.\n\n\tNOTE: Removing payments from the database does free up disk space within\n\tthe internal bbolt database. But that disk space is only reclaimed after\n\tcompacting the database. Users might want to turn on auto compaction\n\t(db.bolt.auto-compact=true in the config file or --db.bolt.auto-compact\n\tas a command line flag) and restart lnd after deleting a large number of\n\tpayments to see a reduction in the file size of the channel.db file.\n\t`,\n\tAction: actionDecorator(deletePayments),\n\tFlags: []cli.Flag{\n\t\tcli.BoolFlag{\n\t\t\tName:  \"all\",\n\t\t\tUsage: \"delete all failed payments\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName: \"payment_hash\",\n\t\t\tUsage: \"delete a specific payment identified by its \" +\n\t\t\t\t\"payment hash\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName: \"failed_htlcs_only\",\n\t\t\tUsage: \"only delete failed HTLCs from payments, not \" +\n\t\t\t\t\"the payment itself\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"include_non_failed\",\n\t\t\tUsage: \"delete ALL payments, not just the failed ones\",\n\t\t},\n\t},\n}\n",
      "length": 3032,
      "tokens": 405,
      "embedding": []
    },
    {
      "slug": "func deletePayments(ctx *cli.Context) error {",
      "content": "func deletePayments(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\t// Show command help if arguments or no flags are provided.\n\tif ctx.NArg() > 0 || ctx.NumFlags() == 0 {\n\t\t_ = cli.ShowCommandHelp(ctx, \"deletepayments\")\n\t\treturn nil\n\t}\n\n\tvar (\n\t\tpaymentHash      []byte\n\t\tall              = ctx.Bool(\"all\")\n\t\tsinglePayment    = ctx.IsSet(\"payment_hash\")\n\t\tfailedHTLCsOnly  = ctx.Bool(\"failed_htlcs_only\")\n\t\tincludeNonFailed = ctx.Bool(\"include_non_failed\")\n\t\terr              error\n\t\tokMsg            = struct {\n\t\t\tOK bool `json:\"ok\"`\n\t\t}{\n\t\t\tOK: true,\n\t\t}\n\t)\n\n\t// We pack two RPCs into the same CLI so there are a few non-valid\n\t// combinations of the flags we need to filter out.\n\tswitch {\n\tcase all && singlePayment:\n\t\treturn fmt.Errorf(\"cannot use --all and --payment_hash at \" +\n\t\t\t\"the same time\")\n\n\tcase singlePayment && includeNonFailed:\n\t\treturn fmt.Errorf(\"cannot use --payment_hash and \" +\n\t\t\t\"--include_non_failed at the same time, when using \" +\n\t\t\t\"a payment hash the payment is deleted independent \" +\n\t\t\t\"of its state\")\n\t}\n\n\t// Deleting a single payment is implemented in a different RPC than\n\t// removing all/multiple payments.\n\tswitch {\n\tcase singlePayment:\n\t\tpaymentHash, err = hex.DecodeString(ctx.String(\"payment_hash\"))\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error decoding payment_hash: %v\",\n\t\t\t\terr)\n\t\t}\n\n\t\t_, err = client.DeletePayment(ctxc, &lnrpc.DeletePaymentRequest{\n\t\t\tPaymentHash:     paymentHash,\n\t\t\tFailedHtlcsOnly: failedHTLCsOnly,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error deleting single payment: %v\",\n\t\t\t\terr)\n\t\t}\n\n\tcase all:\n\t\twhat := \"failed\"\n\t\tif includeNonFailed {\n\t\t\twhat = \"all\"\n\t\t}\n\t\tif failedHTLCsOnly {\n\t\t\twhat = fmt.Sprintf(\"failed HTLCs from %s\", what)\n\t\t}\n\n\t\tfmt.Printf(\"Removing %s payments, this might take a while...\\n\",\n\t\t\twhat)\n\t\t_, err = client.DeleteAllPayments(\n\t\t\tctxc, &lnrpc.DeleteAllPaymentsRequest{\n\t\t\t\tFailedPaymentsOnly: !includeNonFailed,\n\t\t\t\tFailedHtlcsOnly:    failedHTLCsOnly,\n\t\t\t},\n\t\t)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error deleting payments: %v\", err)\n\t\t}\n\t}\n\n\t// Users are confused by empty JSON outputs so let's return a simple OK\n\t// instead of just printing the empty response RPC message.\n\tprintJSON(okMsg)\n\n\treturn nil\n}\n\n// ESC is the ASCII code for escape character.\nconst ESC = 27\n\n// clearCode defines a terminal escape code to clear the currently line and move\n// the cursor up.\nvar clearCode = fmt.Sprintf(\"%c[%dA%c[2K\", ESC, 1, ESC)\n\n// clearLines erases the last count lines in the terminal window.",
      "length": 2416,
      "tokens": 336,
      "embedding": []
    },
    {
      "slug": "func clearLines(count int) {",
      "content": "func clearLines(count int) {\n\t_, _ = fmt.Print(strings.Repeat(clearCode, count))\n}\n\n// ordinalNumber returns the ordinal number as a string of a number.",
      "length": 120,
      "tokens": 18,
      "embedding": []
    },
    {
      "slug": "func ordinalNumber(num uint32) string {",
      "content": "func ordinalNumber(num uint32) string {\n\tswitch num {\n\tcase 1:\n\t\treturn \"1st\"\n\tcase 2:\n\t\treturn \"2nd\"\n\tcase 3:\n\t\treturn \"3rd\"\n\tdefault:\n\t\treturn fmt.Sprintf(\"%dth\", num)\n\t}\n}\n",
      "length": 124,
      "tokens": 21,
      "embedding": []
    }
  ]
}