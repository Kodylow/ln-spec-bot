{
  "filepath": "../implementations/go/lnd/cmd/lncli/cmd_open_channel.go",
  "package": "main",
  "sections": [
    {
      "slug": "func openChannel(ctx *cli.Context) error {",
      "content": "func openChannel(ctx *cli.Context) error {\n\t// TODO(roasbeef): add deadline to context\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\targs := ctx.Args()\n\tvar err error\n\n\t// Show command help if no arguments provided\n\tif ctx.NArg() == 0 && ctx.NumFlags() == 0 {\n\t\t_ = cli.ShowCommandHelp(ctx, \"openchannel\")\n\t\treturn nil\n\t}\n\n\t// Check that only the field sat_per_vbyte or the deprecated field\n\t// sat_per_byte is used.\n\tfeeRateFlag, err := checkNotBothSet(\n\t\tctx, \"sat_per_vbyte\", \"sat_per_byte\",\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tminConfs := int32(ctx.Uint64(\"min_confs\"))\n\treq := &lnrpc.OpenChannelRequest{\n\t\tTargetConf:                 int32(ctx.Int64(\"conf_target\")),\n\t\tSatPerVbyte:                ctx.Uint64(feeRateFlag),\n\t\tMinHtlcMsat:                ctx.Int64(\"min_htlc_msat\"),\n\t\tRemoteCsvDelay:             uint32(ctx.Uint64(\"remote_csv_delay\")),\n\t\tMinConfs:                   minConfs,\n\t\tSpendUnconfirmed:           minConfs == 0,\n\t\tCloseAddress:               ctx.String(\"close_address\"),\n\t\tRemoteMaxValueInFlightMsat: ctx.Uint64(\"remote_max_value_in_flight_msat\"),\n\t\tMaxLocalCsv:                uint32(ctx.Uint64(\"max_local_csv\")),\n\t\tZeroConf:                   ctx.Bool(\"zero_conf\"),\n\t\tScidAlias:                  ctx.Bool(\"scid_alias\"),\n\t\tRemoteChanReserveSat:       ctx.Uint64(\"remote_reserve_sats\"),\n\t}\n\n\tswitch {\n\tcase ctx.IsSet(\"node_key\"):\n\t\tnodePubHex, err := hex.DecodeString(ctx.String(\"node_key\"))\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to decode node public key: \"+\n\t\t\t\t\"%v\", err)\n\t\t}\n\t\treq.NodePubkey = nodePubHex\n\n\tcase args.Present():\n\t\tnodePubHex, err := hex.DecodeString(args.First())\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to decode node public key: \"+\n\t\t\t\t\"%v\", err)\n\t\t}\n\t\targs = args.Tail()\n\t\treq.NodePubkey = nodePubHex\n\tdefault:\n\t\treturn fmt.Errorf(\"node id argument missing\")\n\t}\n\n\t// As soon as we can confirm that the node's node_key was set, rather\n\t// than the peer_id, we can check if the host:port was also set to\n\t// connect to it before opening the channel.\n\tif req.NodePubkey != nil && ctx.IsSet(\"connect\") {\n\t\taddr := &lnrpc.LightningAddress{\n\t\t\tPubkey: hex.EncodeToString(req.NodePubkey),\n\t\t\tHost:   ctx.String(\"connect\"),\n\t\t}\n\n\t\treq := &lnrpc.ConnectPeerRequest{\n\t\t\tAddr: addr,\n\t\t\tPerm: false,\n\t\t}\n\n\t\t// Check if connecting to the node was successful.\n\t\t// We discard the peer id returned as it is not needed.\n\t\t_, err := client.ConnectPeer(ctxc, req)\n\t\tif err != nil &&\n\t\t\t!strings.Contains(err.Error(), \"already connected\") {\n\n\t\t\treturn err\n\t\t}\n\t}\n\n\tswitch {\n\tcase ctx.IsSet(\"local_amt\"):\n\t\treq.LocalFundingAmount = int64(ctx.Int(\"local_amt\"))\n\tcase args.Present():\n\t\treq.LocalFundingAmount, err = strconv.ParseInt(\n\t\t\targs.First(), 10, 64,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to decode local amt: %v\", err)\n\t\t}\n\t\targs = args.Tail()\n\tdefault:\n\t\treturn fmt.Errorf(\"local amt argument missing\")\n\t}\n\n\tif ctx.IsSet(\"push_amt\") {\n\t\treq.PushSat = int64(ctx.Int(\"push_amt\"))\n\t} else if args.Present() {\n\t\treq.PushSat, err = strconv.ParseInt(args.First(), 10, 64)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to decode push amt: %v\", err)\n\t\t}\n\t}\n\n\tif ctx.IsSet(\"base_fee_msat\") {\n\t\treq.BaseFee = ctx.Uint64(\"base_fee_msat\")\n\t\treq.UseBaseFee = true\n\t}\n\n\tif ctx.IsSet(\"fee_rate_ppm\") {\n\t\treq.FeeRate = ctx.Uint64(\"fee_rate_ppm\")\n\t\treq.UseFeeRate = true\n\t}\n\n\treq.Private = ctx.Bool(\"private\")\n\n\t// Parse the channel type and map it to its RPC representation.\n\tchannelType := ctx.String(\"channel_type\")\n\tswitch channelType {\n\tcase \"\":\n\t\tbreak\n\tcase channelTypeTweakless:\n\t\treq.CommitmentType = lnrpc.CommitmentType_STATIC_REMOTE_KEY\n\tcase channelTypeAnchors:\n\t\treq.CommitmentType = lnrpc.CommitmentType_ANCHORS\n\tdefault:\n\t\treturn fmt.Errorf(\"unsupported channel type %v\", channelType)\n\t}\n\n\t// PSBT funding is a more involved, interactive process that is too\n\t// large to also fit into this already long function.\n\tif ctx.Bool(\"psbt\") {\n\t\treturn openChannelPsbt(ctxc, ctx, client, req)\n\t}\n\tif !ctx.Bool(\"psbt\") && ctx.Bool(\"no_publish\") {\n\t\treturn fmt.Errorf(\"the --no_publish flag can only be used in \" +\n\t\t\t\"combination with the --psbt flag\")\n\t}\n\n\tstream, err := client.OpenChannel(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor {\n\t\tresp, err := stream.Recv()\n\t\tif err == io.EOF {\n\t\t\treturn nil\n\t\t} else if err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tswitch update := resp.Update.(type) {\n\t\tcase *lnrpc.OpenStatusUpdate_ChanPending:\n\t\t\terr := printChanPending(update)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif !ctx.Bool(\"block\") {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\tcase *lnrpc.OpenStatusUpdate_ChanOpen:\n\t\t\treturn printChanOpen(update)\n\t\t}\n\t}\n}\n\n// openChannelPsbt starts an interactive channel open protocol that uses a\n// partially signed bitcoin transaction (PSBT) to fund the channel output. The\n// protocol involves several steps between the RPC server and the CLI client:\n//\n// RPC server                           CLI client\n//\n//\t|                                    |\n//\t|  |<------open channel (stream)-----|\n//\t|  |-------ready for funding----->|  |\n//\t|  |<------PSBT verify------------|  |\n//\t|  |-------ready for signing----->|  |\n//\t|  |<------PSBT finalize----------|  |\n//\t|  |-------channel pending------->|  |\n//\t|  |-------channel open------------->|\n//\t|                                    |",
      "length": 5069,
      "tokens": 609,
      "embedding": []
    },
    {
      "slug": "func openChannelPsbt(rpcCtx context.Context, ctx *cli.Context,",
      "content": "func openChannelPsbt(rpcCtx context.Context, ctx *cli.Context,\n\tclient lnrpc.LightningClient,\n\treq *lnrpc.OpenChannelRequest) error {\n\n\tvar (\n\t\tpendingChanID [32]byte\n\t\tshimPending   = true\n\t\tbasePsbtBytes []byte\n\t\tquit          = make(chan struct{})\n\t\tsrvMsg        = make(chan *lnrpc.OpenStatusUpdate, 1)\n\t\tsrvErr        = make(chan error, 1)\n\t\tctxc, cancel  = context.WithCancel(rpcCtx)\n\t)\n\tdefer cancel()\n\n\t// Make sure the user didn't supply any command line flags that are\n\t// incompatible with PSBT funding.\n\terr := checkPsbtFlags(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// If the user supplied a base PSBT, only make sure it's valid base64.\n\t// The RPC server will make sure it's also a valid PSBT.\n\tbasePsbt := ctx.String(\"base_psbt\")\n\tif basePsbt != \"\" {\n\t\tbasePsbtBytes, err = base64.StdEncoding.DecodeString(basePsbt)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error parsing base PSBT: %v\", err)\n\t\t}\n\t}\n\n\t// Generate a new, random pending channel ID that we'll use as the main\n\t// identifier when sending update messages to the RPC server.\n\tif _, err := rand.Read(pendingChanID[:]); err != nil {\n\t\treturn fmt.Errorf(\"unable to generate random chan ID: %v\", err)\n\t}\n\tfmt.Printf(\"Starting PSBT funding flow with pending channel ID %x.\\n\",\n\t\tpendingChanID)\n\n\t// maybeCancelShim is a helper function that cancels the funding shim\n\t// with the RPC server in case we end up aborting early.\n\tmaybeCancelShim := func() {\n\t\t// If the user canceled while there was still a shim registered\n\t\t// with the wallet, release the resources now.\n\t\tif shimPending {\n\t\t\tfmt.Printf(\"Canceling PSBT funding flow for pending \"+\n\t\t\t\t\"channel ID %x.\\n\", pendingChanID)\n\t\t\tcancelMsg := &lnrpc.FundingTransitionMsg{\n\t\t\t\tTrigger: &lnrpc.FundingTransitionMsg_ShimCancel{\n\t\t\t\t\tShimCancel: &lnrpc.FundingShimCancel{\n\t\t\t\t\t\tPendingChanId: pendingChanID[:],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\terr := sendFundingState(ctxc, ctx, cancelMsg)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Printf(\"Error canceling shim: %v\\n\", err)\n\t\t\t}\n\t\t\tshimPending = false\n\t\t}\n\n\t\t// Abort the stream connection to the server.\n\t\tcancel()\n\t}\n\tdefer maybeCancelShim()\n\n\t// Create the PSBT funding shim that will tell the funding manager we\n\t// want to use a PSBT.\n\treq.FundingShim = &lnrpc.FundingShim{\n\t\tShim: &lnrpc.FundingShim_PsbtShim{\n\t\t\tPsbtShim: &lnrpc.PsbtShim{\n\t\t\t\tPendingChanId: pendingChanID[:],\n\t\t\t\tBasePsbt:      basePsbtBytes,\n\t\t\t\tNoPublish:     ctx.Bool(\"no_publish\"),\n\t\t\t},\n\t\t},\n\t}\n\n\t// Start the interactive process by opening the stream connection to the\n\t// daemon. If the user cancels by pressing <Ctrl+C> we need to cancel\n\t// the shim. To not just kill the process on interrupt, we need to\n\t// explicitly capture the signal.\n\tstream, err := client.OpenChannel(ctxc, req)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"opening stream to server failed: %v\", err)\n\t}\n\n\t// We also need to spawn a goroutine that reads from the server. This\n\t// will copy the messages to the channel as long as they come in or add\n\t// exactly one error to the error stream and then bail out.\n\tgo func() {\n\t\tfor {\n\t\t\t// Recv blocks until a message or error arrives.\n\t\t\tresp, err := stream.Recv()\n\t\t\tif err == io.EOF {\n\t\t\t\tsrvErr <- fmt.Errorf(\"lnd shutting down: %v\",\n\t\t\t\t\terr)\n\t\t\t\treturn\n\t\t\t} else if err != nil {\n\t\t\t\tsrvErr <- fmt.Errorf(\"got error from server: \"+\n\t\t\t\t\t\"%v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Don't block on sending in case of shutting down.\n\t\t\tselect {\n\t\t\tcase srvMsg <- resp:\n\t\t\tcase <-quit:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Spawn another goroutine that only handles abort from user or errors\n\t// from the server. Both will trigger an attempt to cancel the shim with\n\t// the server.\n\tgo func() {\n\t\tselect {\n\t\tcase <-rpcCtx.Done():\n\t\t\tfmt.Printf(\"\\nInterrupt signal received.\\n\")\n\t\t\tclose(quit)\n\n\t\tcase err := <-srvErr:\n\t\t\tfmt.Printf(\"\\nError received: %v\\n\", err)\n\n\t\t\t// If the remote peer canceled on us, the reservation\n\t\t\t// has already been deleted. We don't need to try to\n\t\t\t// remove it again, this would just produce another\n\t\t\t// error.\n\t\t\tcancelErr := chanfunding.ErrRemoteCanceled.Error()\n\t\t\tif err != nil && strings.Contains(\n\t\t\t\terr.Error(), cancelErr,\n\t\t\t) {\n\n\t\t\t\tshimPending = false\n\t\t\t}\n\t\t\tclose(quit)\n\n\t\tcase <-quit:\n\t\t}\n\t}()\n\n\t// Our main event loop where we wait for triggers\n\tfor {\n\t\tvar srvResponse *lnrpc.OpenStatusUpdate\n\t\tselect {\n\t\tcase srvResponse = <-srvMsg:\n\t\tcase <-quit:\n\t\t\treturn nil\n\t\t}\n\n\t\tswitch update := srvResponse.Update.(type) {\n\t\tcase *lnrpc.OpenStatusUpdate_PsbtFund:\n\t\t\t// First tell the user how to create the PSBT with the\n\t\t\t// address and amount we now know.\n\t\t\tamt := btcutil.Amount(update.PsbtFund.FundingAmount)\n\t\t\taddr := update.PsbtFund.FundingAddress\n\t\t\tfmt.Printf(\n\t\t\t\tuserMsgFund, req.NodePubkey, amt, amt, addr,\n\t\t\t\taddr, amt.ToBTC(),\n\t\t\t\tbase64.StdEncoding.EncodeToString(\n\t\t\t\t\tupdate.PsbtFund.Psbt,\n\t\t\t\t),\n\t\t\t)\n\n\t\t\t// Read the user's response and send it to the server to\n\t\t\t// verify everything's correct before anything is\n\t\t\t// signed.\n\t\t\tinputPsbt, err := readTerminalOrFile(quit)\n\t\t\tif err == io.EOF {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"reading from terminal or \"+\n\t\t\t\t\t\"file failed: %v\", err)\n\t\t\t}\n\t\t\tfundedPsbt, err := decodePsbt(inputPsbt)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"psbt decode failed: %v\",\n\t\t\t\t\terr)\n\t\t\t}\n\t\t\tverifyMsg := &lnrpc.FundingTransitionMsg{\n\t\t\t\tTrigger: &lnrpc.FundingTransitionMsg_PsbtVerify{\n\t\t\t\t\tPsbtVerify: &lnrpc.FundingPsbtVerify{\n\t\t\t\t\t\tFundedPsbt:    fundedPsbt,\n\t\t\t\t\t\tPendingChanId: pendingChanID[:],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\terr = sendFundingState(ctxc, ctx, verifyMsg)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"verifying PSBT by lnd \"+\n\t\t\t\t\t\"failed: %v\", err)\n\t\t\t}\n\n\t\t\t// Now that we know the PSBT looks good, we can let it\n\t\t\t// be signed by the user.\n\t\t\tfmt.Print(userMsgSign)\n\n\t\t\t// Read the signed PSBT and send it to lnd.\n\t\t\tfinalTxStr, err := readTerminalOrFile(quit)\n\t\t\tif err == io.EOF {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"reading from terminal or \"+\n\t\t\t\t\t\"file failed: %v\", err)\n\t\t\t}\n\t\t\tfinalizeMsg, err := finalizeMsgFromString(\n\t\t\t\tfinalTxStr, pendingChanID[:],\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\ttransitionMsg := &lnrpc.FundingTransitionMsg{\n\t\t\t\tTrigger: finalizeMsg,\n\t\t\t}\n\t\t\terr = sendFundingState(ctxc, ctx, transitionMsg)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"finalizing PSBT funding \"+\n\t\t\t\t\t\"flow failed: %v\", err)\n\t\t\t}\n\n\t\tcase *lnrpc.OpenStatusUpdate_ChanPending:\n\t\t\t// As soon as the channel is pending, there is no more\n\t\t\t// shim that needs to be canceled. If the user\n\t\t\t// interrupts now, we don't need to clean up anything.\n\t\t\tshimPending = false\n\n\t\t\terr := printChanPending(update)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif !ctx.Bool(\"block\") {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\tcase *lnrpc.OpenStatusUpdate_ChanOpen:\n\t\t\treturn printChanOpen(update)\n\t\t}\n\t}\n}\n\nvar batchOpenChannelCommand = cli.Command{\n\tName:     \"batchopenchannel\",\n\tCategory: \"Channels\",\n\tUsage: \"Open multiple channels to existing peers in a single \" +\n\t\t\"transaction.\",\n\tDescription: `\n\tAttempt to open one or more new channels to an existing peer with the\n\tgiven node-keys.\n\n\tExample:\n\tlncli batchopenchannel --sat_per_vbyte=5 '[{\n\t\t\"node_pubkey\": \"02abcdef...\",\n\t\t\"local_funding_amount\": 500000,\n\t\t\"private\": true,\n\t\t\"close_address\": \"bc1qxxx...\"\n\t}, {\n\t\t\"node_pubkey\": \"03fedcba...\",\n\t\t\"local_funding_amount\": 200000,\n\t\t\"remote_csv_delay\": 288\n\t}]'\n\n\tAll nodes listed must already be connected peers, otherwise funding will\n\tfail.\n\n\tThe channel will be initialized with local_funding_amount satoshis \n\tlocally and push_sat satoshis for the remote node. Note that specifying \n\tpush_sat means you give that amount to the remote node as part of the \n\tchannel\topening. Once the channel is open, a channelPoint (txid:vout) of \n\tthe funding output is returned.\n\n\tIf the remote peer supports the option upfront shutdown feature bit\n\t(query listpeers to see their supported feature bits), an address to\n\tenforce\tpayout of funds on cooperative close can optionally be provided.\n\tNote that if you set this value, you will not be able to cooperatively\n\tclose out to another address.\n\n\tOne can manually set the fee to be used for the funding transaction via\n\teither the --conf_target or --sat_per_vbyte arguments. This is optional.\n`,\n\tArgsUsage: \"channels-json\",\n\tFlags: []cli.Flag{\n\t\tcli.Int64Flag{\n\t\t\tName: \"conf_target\",\n\t\t\tUsage: \"(optional) the number of blocks that the \" +\n\t\t\t\t\"transaction *should* confirm in, will be \" +\n\t\t\t\t\"used for fee estimation\",\n\t\t},\n\t\tcli.Int64Flag{\n\t\t\tName: \"sat_per_vbyte\",\n\t\t\tUsage: \"(optional) a manual fee expressed in \" +\n\t\t\t\t\"sat/vByte that should be used when crafting \" +\n\t\t\t\t\"the transaction\",\n\t\t},\n\t\tcli.Uint64Flag{\n\t\t\tName: \"min_confs\",\n\t\t\tUsage: \"(optional) the minimum number of \" +\n\t\t\t\t\"confirmations each one of your outputs used \" +\n\t\t\t\t\"for the funding transaction must satisfy\",\n\t\t\tValue: defaultUtxoMinConf,\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName: \"label\",\n\t\t\tUsage: \"(optional) a label to attach to the batch \" +\n\t\t\t\t\"transaction when storing it to the local \" +\n\t\t\t\t\"wallet after publishing it\",\n\t\t},\n\t},\n\tAction: actionDecorator(batchOpenChannel),\n}\n",
      "length": 8695,
      "tokens": 1230,
      "embedding": []
    },
    {
      "slug": "type batchChannelJSON struct {",
      "content": "type batchChannelJSON struct {\n\tNodePubkey         string `json:\"node_pubkey,omitempty\"`\n\tLocalFundingAmount int64  `json:\"local_funding_amount,omitempty\"`\n\tPushSat            int64  `json:\"push_sat,omitempty\"`\n\tPrivate            bool   `json:\"private,omitempty\"`\n\tMinHtlcMsat        int64  `json:\"min_htlc_msat,omitempty\"`\n\tRemoteCsvDelay     uint32 `json:\"remote_csv_delay,omitempty\"`\n\tCloseAddress       string `json:\"close_address,omitempty\"`\n\tPendingChanID      string `json:\"pending_chan_id,omitempty\"`\n}\n",
      "length": 472,
      "tokens": 25,
      "embedding": []
    },
    {
      "slug": "func batchOpenChannel(ctx *cli.Context) error {",
      "content": "func batchOpenChannel(ctx *cli.Context) error {\n\tctxc := getContext()\n\tclient, cleanUp := getClient(ctx)\n\tdefer cleanUp()\n\n\targs := ctx.Args()\n\n\t// Show command help if no arguments provided\n\tif ctx.NArg() == 0 {\n\t\t_ = cli.ShowCommandHelp(ctx, \"batchopenchannel\")\n\t\treturn nil\n\t}\n\n\tminConfs := int32(ctx.Uint64(\"min_confs\"))\n\treq := &lnrpc.BatchOpenChannelRequest{\n\t\tTargetConf:       int32(ctx.Int64(\"conf_target\")),\n\t\tSatPerVbyte:      int64(ctx.Uint64(\"sat_per_vbyte\")),\n\t\tMinConfs:         minConfs,\n\t\tSpendUnconfirmed: minConfs == 0,\n\t\tLabel:            ctx.String(\"label\"),\n\t}\n\n\t// Let's try and parse the JSON part of the CLI now. Fortunately we can\n\t// parse it directly into the RPC struct if we use the correct\n\t// marshaler that keeps the original snake case.\n\tvar jsonChannels []*batchChannelJSON\n\tif err := json.Unmarshal([]byte(args.First()), &jsonChannels); err != nil {\n\t\treturn fmt.Errorf(\"error parsing channels JSON: %v\", err)\n\t}\n\n\treq.Channels = make([]*lnrpc.BatchOpenChannel, len(jsonChannels))\n\tfor idx, jsonChannel := range jsonChannels {\n\t\tpubKeyBytes, err := hex.DecodeString(jsonChannel.NodePubkey)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error parsing node pubkey hex: %v\",\n\t\t\t\terr)\n\t\t}\n\t\tpendingChanBytes, err := hex.DecodeString(\n\t\t\tjsonChannel.PendingChanID,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error parsing pending chan ID: %v\",\n\t\t\t\terr)\n\t\t}\n\n\t\treq.Channels[idx] = &lnrpc.BatchOpenChannel{\n\t\t\tNodePubkey:         pubKeyBytes,\n\t\t\tLocalFundingAmount: jsonChannel.LocalFundingAmount,\n\t\t\tPushSat:            jsonChannel.PushSat,\n\t\t\tPrivate:            jsonChannel.Private,\n\t\t\tMinHtlcMsat:        jsonChannel.MinHtlcMsat,\n\t\t\tRemoteCsvDelay:     jsonChannel.RemoteCsvDelay,\n\t\t\tCloseAddress:       jsonChannel.CloseAddress,\n\t\t\tPendingChanId:      pendingChanBytes,\n\t\t}\n\t}\n\n\tresp, err := client.BatchOpenChannel(ctxc, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, pending := range resp.PendingChannels {\n\t\ttxid, err := chainhash.NewHash(pending.Txid)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tprintJSON(struct {\n\t\t\tFundingTxid        string `json:\"funding_txid\"`\n\t\t\tFundingOutputIndex uint32 `json:\"funding_output_index\"`\n\t\t}{\n\t\t\tFundingTxid:        txid.String(),\n\t\t\tFundingOutputIndex: pending.OutputIndex,\n\t\t})\n\t}\n\n\treturn nil\n}\n\n// printChanOpen prints the channel point of the channel open message.",
      "length": 2207,
      "tokens": 238,
      "embedding": []
    },
    {
      "slug": "func printChanOpen(update *lnrpc.OpenStatusUpdate_ChanOpen) error {",
      "content": "func printChanOpen(update *lnrpc.OpenStatusUpdate_ChanOpen) error {\n\tchannelPoint := update.ChanOpen.ChannelPoint\n\n\t// A channel point's funding txid can be get/set as a\n\t// byte slice or a string. In the case it is a string,\n\t// decode it.\n\tvar txidHash []byte\n\tswitch channelPoint.GetFundingTxid().(type) {\n\tcase *lnrpc.ChannelPoint_FundingTxidBytes:\n\t\ttxidHash = channelPoint.GetFundingTxidBytes()\n\tcase *lnrpc.ChannelPoint_FundingTxidStr:\n\t\ts := channelPoint.GetFundingTxidStr()\n\t\th, err := chainhash.NewHashFromStr(s)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\ttxidHash = h[:]\n\t}\n\n\ttxid, err := chainhash.NewHash(txidHash)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tindex := channelPoint.OutputIndex\n\tprintJSON(struct {\n\t\tChannelPoint string `json:\"channel_point\"`\n\t}{\n\t\tChannelPoint: fmt.Sprintf(\"%v:%v\", txid, index),\n\t})\n\treturn nil\n}\n\n// printChanPending prints the funding transaction ID of the channel pending\n// message.",
      "length": 818,
      "tokens": 104,
      "embedding": []
    },
    {
      "slug": "func printChanPending(update *lnrpc.OpenStatusUpdate_ChanPending) error {",
      "content": "func printChanPending(update *lnrpc.OpenStatusUpdate_ChanPending) error {\n\ttxid, err := chainhash.NewHash(update.ChanPending.Txid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprintJSON(struct {\n\t\tFundingTxid string `json:\"funding_txid\"`\n\t}{\n\t\tFundingTxid: txid.String(),\n\t})\n\treturn nil\n}\n\n// readTerminalOrFile reads a single line from the terminal. If the line read is\n// short enough to be a file and a file with that exact name exists, the content\n// of that file is read and returned as a string. If the content is longer or no\n// file exists, the string read from the terminal is returned directly. This\n// function can be used to circumvent the N_TTY_BUF_SIZE kernel parameter that\n// prevents pasting more than 4096 characters (on most systems) into a terminal.",
      "length": 668,
      "tokens": 111,
      "embedding": []
    },
    {
      "slug": "func readTerminalOrFile(quit chan struct{}) (string, error) {",
      "content": "func readTerminalOrFile(quit chan struct{}) (string, error) {\n\tmaybeFile, err := readLine(quit)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Absolute file paths normally can't be longer than 255 characters so\n\t// we don't even check if it's a file in that case.\n\tif len(maybeFile) > 255 {\n\t\treturn maybeFile, nil\n\t}\n\n\t// It might be a file since the length is small enough. Calling os.Stat\n\t// should be safe with any arbitrary input as it will only query info\n\t// about the file, not open or execute it directly.\n\tstat, err := os.Stat(maybeFile)\n\n\t// The file doesn't exist, we must assume this wasn't a file path after\n\t// all.\n\tif err != nil && os.IsNotExist(err) {\n\t\treturn maybeFile, nil\n\t}\n\n\t// Some other error, perhaps access denied or something similar, let's\n\t// surface that to the user.\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Make sure we don't read a huge file by accident which might lead to\n\t// undesired side effects. Even very large PSBTs should still only be a\n\t// few hundred kilobytes so it makes sense to put a cap here.\n\tif stat.Size() > psbtMaxFileSize {\n\t\treturn \"\", fmt.Errorf(\"error reading file %s: size of %d \"+\n\t\t\t\"bytes exceeds max PSBT file size of %d\", maybeFile,\n\t\t\tstat.Size(), psbtMaxFileSize)\n\t}\n\n\t// If it's a path to an existing file and it's small enough, let's try\n\t// to read its content now.\n\tcontent, err := ioutil.ReadFile(maybeFile)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn string(content), nil\n}\n\n// readLine reads a line from standard in but does not block in case of a\n// system interrupt like syscall.SIGINT (Ctrl+C).",
      "length": 1461,
      "tokens": 269,
      "embedding": []
    },
    {
      "slug": "func readLine(quit chan struct{}) (string, error) {",
      "content": "func readLine(quit chan struct{}) (string, error) {\n\tmsg := make(chan string, 1)\n\n\t// In a normal console, reading from stdin won't signal EOF when the\n\t// user presses Ctrl+C. That's why we need to put this in a separate\n\t// goroutine so it doesn't block.\n\tgo func() {\n\t\tfor {\n\t\t\tvar str string\n\t\t\t_, _ = fmt.Scan(&str)\n\t\t\tmsg <- str\n\t\t\treturn\n\t\t}\n\t}()\n\tfor {\n\t\tselect {\n\t\tcase <-quit:\n\t\t\treturn \"\", io.EOF\n\n\t\tcase str := <-msg:\n\t\t\treturn str, nil\n\t\t}\n\t}\n}\n\n// checkPsbtFlags make sure a request to open a channel doesn't set any\n// parameters that are incompatible with the PSBT funding flow.",
      "length": 517,
      "tokens": 98,
      "embedding": []
    },
    {
      "slug": "func checkPsbtFlags(req *lnrpc.OpenChannelRequest) error {",
      "content": "func checkPsbtFlags(req *lnrpc.OpenChannelRequest) error {\n\tif req.MinConfs != defaultUtxoMinConf || req.SpendUnconfirmed {\n\t\treturn fmt.Errorf(\"specifying minimum confirmations for PSBT \" +\n\t\t\t\"funding is not supported\")\n\t}\n\tif req.TargetConf != 0 || req.SatPerByte != 0 || req.SatPerVbyte != 0 { // nolint:staticcheck\n\t\treturn fmt.Errorf(\"setting fee estimation parameters not \" +\n\t\t\t\"supported for PSBT funding\")\n\t}\n\treturn nil\n}\n\n// sendFundingState sends a single funding state step message by using a new\n// client connection. This is necessary if the whole funding flow takes longer\n// than the default macaroon timeout, then we cannot use a single client\n// connection.",
      "length": 604,
      "tokens": 92,
      "embedding": []
    },
    {
      "slug": "func sendFundingState(cancelCtx context.Context, cliCtx *cli.Context,",
      "content": "func sendFundingState(cancelCtx context.Context, cliCtx *cli.Context,\n\tmsg *lnrpc.FundingTransitionMsg) error {\n\n\tclient, cleanUp := getClient(cliCtx)\n\tdefer cleanUp()\n\n\t_, err := client.FundingStateStep(cancelCtx, msg)\n\treturn err\n}\n\n// finalizeMsgFromString creates the final message for the PsbtFinalize step\n// from either a hex encoded raw wire transaction or a base64/binary encoded\n// PSBT packet.",
      "length": 323,
      "tokens": 44,
      "embedding": []
    },
    {
      "slug": "func finalizeMsgFromString(tx string,",
      "content": "func finalizeMsgFromString(tx string,\n\tpendingChanID []byte) (*lnrpc.FundingTransitionMsg_PsbtFinalize,\n\terror) {\n\n\tpsbtBytes, err := decodePsbt(tx)\n\tif err == nil {\n\t\treturn &lnrpc.FundingTransitionMsg_PsbtFinalize{\n\t\t\tPsbtFinalize: &lnrpc.FundingPsbtFinalize{\n\t\t\t\tSignedPsbt:    psbtBytes,\n\t\t\t\tPendingChanId: pendingChanID,\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// PSBT decode failed, try to parse it as a hex encoded Bitcoin\n\t// transaction\n\trawTx, err := hex.DecodeString(strings.TrimSpace(tx))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"hex decode failed: %w\", err)\n\t}\n\tmsgtx := &wire.MsgTx{}\n\terr = msgtx.Deserialize(bytes.NewReader(rawTx))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"deserializing as raw wire \"+\n\t\t\t\"transaction failed: %v\", err)\n\t}\n\treturn &lnrpc.FundingTransitionMsg_PsbtFinalize{\n\t\tPsbtFinalize: &lnrpc.FundingPsbtFinalize{\n\t\t\tFinalRawTx:    rawTx,\n\t\t\tPendingChanId: pendingChanID,\n\t\t},\n\t}, nil\n}\n\n// decodePsbt tries to decode the input as a binary or base64 PSBT. If this\n// succeeded, the PSBT bytes are returned, an error otherwise.",
      "length": 972,
      "tokens": 118,
      "embedding": []
    },
    {
      "slug": "func decodePsbt(psbt string) ([]byte, error) {",
      "content": "func decodePsbt(psbt string) ([]byte, error) {\n\tswitch {\n\tcase strings.HasPrefix(psbt, \"psbt\\xff\"):\n\t\t// A binary PSBT (read from a file) always starts with the PSBT\n\t\t// magic \"psbt\\xff\" according to BIP 174\n\t\treturn []byte(psbt), nil\n\n\tcase strings.HasPrefix(strings.TrimSpace(psbt), \"cHNidP\"):\n\t\t// A base64 PSBT always starts with \"cHNidP\". This is the\n\t\t// longest base64 representation of the PSBT magic that is not\n\t\t// dependent on the byte after it.\n\t\tpsbtBytes, err := base64.StdEncoding.DecodeString(\n\t\t\tstrings.TrimSpace(psbt),\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"base64 decode failed: %w\", err)\n\t\t}\n\n\t\treturn psbtBytes, nil\n\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"not a PSBT\")\n\t}\n}\n",
      "length": 635,
      "tokens": 90,
      "embedding": []
    }
  ]
}