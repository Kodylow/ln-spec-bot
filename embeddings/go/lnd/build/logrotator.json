{
  "filepath": "../implementations/go/lnd/build/logrotator.go",
  "package": "build",
  "sections": [
    {
      "slug": "type RotatingLogWriter struct {",
      "content": "type RotatingLogWriter struct {\n\tlogWriter *LogWriter\n\n\tbackendLog *btclog.Backend\n\n\tlogRotator *rotator.Rotator\n\n\tsubsystemLoggers SubLoggers\n}\n\n// A compile time check to ensure RotatingLogWriter implements the\n// LeveledSubLogger interface.\nvar _ LeveledSubLogger = (*RotatingLogWriter)(nil)\n\n// NewRotatingLogWriter creates a new file rotating log writer.\n//\n// NOTE: `InitLogRotator` must be called to set up log rotation after creating\n// the writer.",
      "length": 408,
      "tokens": 53,
      "embedding": []
    },
    {
      "slug": "func NewRotatingLogWriter() *RotatingLogWriter {",
      "content": "func NewRotatingLogWriter() *RotatingLogWriter {\n\tlogWriter := &LogWriter{}\n\tbackendLog := btclog.NewBackend(logWriter)\n\treturn &RotatingLogWriter{\n\t\tlogWriter:        logWriter,\n\t\tbackendLog:       backendLog,\n\t\tsubsystemLoggers: SubLoggers{},\n\t}\n}\n\n// GenSubLogger creates a new sublogger. A shutdown callback function\n// is provided to be able to shutdown in case of a critical error.",
      "length": 328,
      "tokens": 40,
      "embedding": []
    },
    {
      "slug": "func (r *RotatingLogWriter) GenSubLogger(tag string, shutdown func()) btclog.Logger {",
      "content": "func (r *RotatingLogWriter) GenSubLogger(tag string, shutdown func()) btclog.Logger {\n\tlogger := r.backendLog.Logger(tag)\n\treturn NewShutdownLogger(logger, shutdown)\n}\n\n// RegisterSubLogger registers a new subsystem logger.",
      "length": 133,
      "tokens": 14,
      "embedding": []
    },
    {
      "slug": "func (r *RotatingLogWriter) RegisterSubLogger(subsystem string,",
      "content": "func (r *RotatingLogWriter) RegisterSubLogger(subsystem string,\n\tlogger btclog.Logger) {\n\n\tr.subsystemLoggers[subsystem] = logger\n}\n\n// InitLogRotator initializes the log file rotator to write logs to logFile and\n// create roll files in the same directory. It should be called as early on\n// startup and possible and must be closed on shutdown by calling `Close`.",
      "length": 292,
      "tokens": 48,
      "embedding": []
    },
    {
      "slug": "func (r *RotatingLogWriter) InitLogRotator(logFile string, maxLogFileSize int,",
      "content": "func (r *RotatingLogWriter) InitLogRotator(logFile string, maxLogFileSize int,\n\tmaxLogFiles int) error {\n\n\tlogDir, _ := filepath.Split(logFile)\n\terr := os.MkdirAll(logDir, 0700)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create log directory: %v\", err)\n\t}\n\tr.logRotator, err = rotator.New(\n\t\tlogFile, int64(maxLogFileSize*1024), false, maxLogFiles,\n\t)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create file rotator: %v\", err)\n\t}\n\n\t// Run rotator as a goroutine now but make sure we catch any errors\n\t// that happen in case something with the rotation goes wrong during\n\t// runtime (like running out of disk space or not being allowed to\n\t// create a new logfile for whatever reason).\n\tpr, pw := io.Pipe()\n\tgo func() {\n\t\terr := r.logRotator.Run(pr)\n\t\tif err != nil {\n\t\t\t_, _ = fmt.Fprintf(os.Stderr,\n\t\t\t\t\"failed to run file rotator: %v\\n\", err)\n\t\t}\n\t}()\n\n\tr.logWriter.RotatorPipe = pw\n\treturn nil\n}\n\n// Close closes the underlying log rotator if it has already been created.",
      "length": 873,
      "tokens": 143,
      "embedding": []
    },
    {
      "slug": "func (r *RotatingLogWriter) Close() error {",
      "content": "func (r *RotatingLogWriter) Close() error {\n\tif r.logRotator != nil {\n\t\treturn r.logRotator.Close()\n\t}\n\treturn nil\n}\n\n// SubLoggers returns all currently registered subsystem loggers for this log\n// writer.\n//\n// NOTE: This is part of the LeveledSubLogger interface.",
      "length": 213,
      "tokens": 34,
      "embedding": []
    },
    {
      "slug": "func (r *RotatingLogWriter) SubLoggers() SubLoggers {",
      "content": "func (r *RotatingLogWriter) SubLoggers() SubLoggers {\n\treturn r.subsystemLoggers\n}\n\n// SupportedSubsystems returns a sorted string slice of all keys in the\n// subsystems map, corresponding to the names of the subsystems.\n//\n// NOTE: This is part of the LeveledSubLogger interface.",
      "length": 220,
      "tokens": 35,
      "embedding": []
    },
    {
      "slug": "func (r *RotatingLogWriter) SupportedSubsystems() []string {",
      "content": "func (r *RotatingLogWriter) SupportedSubsystems() []string {\n\t// Convert the subsystemLoggers map keys to a string slice.\n\tsubsystems := make([]string, 0, len(r.subsystemLoggers))\n\tfor subsysID := range r.subsystemLoggers {\n\t\tsubsystems = append(subsystems, subsysID)\n\t}\n\n\t// Sort the subsystems for stable display.\n\tsort.Strings(subsystems)\n\treturn subsystems\n}\n\n// SetLogLevel sets the logging level for provided subsystem. Invalid\n// subsystems are ignored. Uninitialized subsystems are dynamically created as\n// needed.\n//\n// NOTE: This is part of the LeveledSubLogger interface.",
      "length": 507,
      "tokens": 69,
      "embedding": []
    },
    {
      "slug": "func (r *RotatingLogWriter) SetLogLevel(subsystemID string, logLevel string) {",
      "content": "func (r *RotatingLogWriter) SetLogLevel(subsystemID string, logLevel string) {\n\t// Ignore invalid subsystems.\n\tlogger, ok := r.subsystemLoggers[subsystemID]\n\tif !ok {\n\t\treturn\n\t}\n\n\t// Defaults to info if the log level is invalid.\n\tlevel, _ := btclog.LevelFromString(logLevel)\n\tlogger.SetLevel(level)\n}\n\n// SetLogLevels sets the log level for all subsystem loggers to the passed\n// level. It also dynamically creates the subsystem loggers as needed, so it\n// can be used to initialize the logging system.\n//\n// NOTE: This is part of the LeveledSubLogger interface.",
      "length": 469,
      "tokens": 74,
      "embedding": []
    },
    {
      "slug": "func (r *RotatingLogWriter) SetLogLevels(logLevel string) {",
      "content": "func (r *RotatingLogWriter) SetLogLevels(logLevel string) {\n\t// Configure all sub-systems with the new logging level. Dynamically\n\t// create loggers as needed.\n\tfor subsystemID := range r.subsystemLoggers {\n\t\tr.SetLogLevel(subsystemID, logLevel)\n\t}\n}\n",
      "length": 185,
      "tokens": 25,
      "embedding": []
    }
  ]
}