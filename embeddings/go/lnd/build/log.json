{
  "filepath": "../implementations/go/lnd/build/log.go",
  "package": "build",
  "sections": [
    {
      "slug": "type LogType byte",
      "content": "type LogType byte\n\nconst (\n\t// LogTypeNone indicates no logging.\n\tLogTypeNone LogType = iota\n\n\t// LogTypeStdOut all logging is written directly to stdout.\n\tLogTypeStdOut\n\n\t// LogTypeDefault logs to both stdout and a given io.PipeWriter.\n\tLogTypeDefault\n)\n\n// String returns a human readable identifier for the logging type.",
      "length": 293,
      "tokens": 44,
      "embedding": []
    },
    {
      "slug": "func (t LogType) String() string {",
      "content": "func (t LogType) String() string {\n\tswitch t {\n\tcase LogTypeNone:\n\t\treturn \"none\"\n\tcase LogTypeStdOut:\n\t\treturn \"stdout\"\n\tcase LogTypeDefault:\n\t\treturn \"default\"\n\tdefault:\n\t\treturn \"unknown\"\n\t}\n}\n\n// LogWriter is a stub type whose behavior can be changed using the build flags\n// \"stdlog\" and \"nolog\". The default behavior is to write to both stdout and the\n// RotatorPipe. Passing \"stdlog\" will cause it only to write to stdout, and\n// \"nolog\" implements Write as a no-op.",
      "length": 423,
      "tokens": 70,
      "embedding": []
    },
    {
      "slug": "type LogWriter struct {",
      "content": "type LogWriter struct {\n\t// RotatorPipe is the write-end pipe for writing to the log rotator.  It\n\t// is written to by the Write method of the LogWriter type. This only\n\t// needs to be set if neither the stdlog or nolog builds are set.\n\tRotatorPipe *io.PipeWriter\n}\n\n// NewSubLogger constructs a new subsystem log from the current LogWriter\n// implementation. This is primarily intended for use with stdlog, as the actual\n// writer is shared amongst all instantiations.",
      "length": 437,
      "tokens": 75,
      "embedding": []
    },
    {
      "slug": "func NewSubLogger(subsystem string,",
      "content": "func NewSubLogger(subsystem string,\n\tgenSubLogger func(string) btclog.Logger) btclog.Logger {\n\n\tswitch Deployment {\n\n\t// For production builds, generate a new subsystem logger from the\n\t// primary log backend. If no function is provided, logging will be\n\t// disabled.\n\tcase Production:\n\t\tif genSubLogger != nil {\n\t\t\treturn genSubLogger(subsystem)\n\t\t}\n\n\t// For development builds, we must handle two distinct types of logging:\n\t// unit tests and running the live daemon, e.g. for integration testing.\n\tcase Development:\n\t\tswitch LoggingType {\n\n\t\t// Default logging is used when running the standalone daemon.\n\t\t// We'll use the optional sublogger constructor to mimic the\n\t\t// production behavior.\n\t\tcase LogTypeDefault:\n\t\t\tif genSubLogger != nil {\n\t\t\t\treturn genSubLogger(subsystem)\n\t\t\t}\n\n\t\t// Logging to stdout is used in unit tests. It is not important\n\t\t// that they share the same backend, since all output is written\n\t\t// to std out.\n\t\tcase LogTypeStdOut:\n\t\t\tbackend := btclog.NewBackend(&LogWriter{})\n\t\t\tlogger := backend.Logger(subsystem)\n\n\t\t\t// Set the logging level of the stdout logger to use the\n\t\t\t// configured logging level specified by build flags.\n\t\t\tlevel, _ := btclog.LevelFromString(LogLevel)\n\t\t\tlogger.SetLevel(level)\n\n\t\t\treturn logger\n\t\t}\n\t}\n\n\t// For any other configurations, we'll disable logging.\n\treturn btclog.Disabled\n}\n\n// SubLoggers is a type that holds a map of subsystem loggers keyed by their\n// subsystem name.",
      "length": 1361,
      "tokens": 200,
      "embedding": []
    },
    {
      "slug": "type SubLoggers map[string]btclog.Logger",
      "content": "type SubLoggers map[string]btclog.Logger\n\n// LeveledSubLogger provides the ability to retrieve the subsystem loggers of\n// a logger and set their log levels individually or all at once.",
      "length": 142,
      "tokens": 24,
      "embedding": []
    },
    {
      "slug": "type LeveledSubLogger interface {",
      "content": "type LeveledSubLogger interface {\n\t// SubLoggers returns the map of all registered subsystem loggers.\n\tSubLoggers() SubLoggers\n\n\t// SupportedSubsystems returns a slice of strings containing the names\n\t// of the supported subsystems. Should ideally correspond to the keys\n\t// of the subsystem logger map and be sorted.\n\tSupportedSubsystems() []string\n\n\t// SetLogLevel assigns an individual subsystem logger a new log level.\n\tSetLogLevel(subsystemID string, logLevel string)\n\n\t// SetLogLevels assigns all subsystem loggers the same new log level.\n\tSetLogLevels(logLevel string)\n}\n\n// ParseAndSetDebugLevels attempts to parse the specified debug level and set\n// the levels accordingly on the given logger. An appropriate error is returned\n// if anything is invalid.",
      "length": 712,
      "tokens": 102,
      "embedding": []
    },
    {
      "slug": "func ParseAndSetDebugLevels(level string, logger LeveledSubLogger) error {",
      "content": "func ParseAndSetDebugLevels(level string, logger LeveledSubLogger) error {\n\t// Split at the delimiter.\n\tlevels := strings.Split(level, \",\")\n\tif len(levels) == 0 {\n\t\treturn fmt.Errorf(\"invalid log level: %v\", level)\n\t}\n\n\t// If the first entry has no =, treat is as the log level for all\n\t// subsystems.\n\tglobalLevel := levels[0]\n\tif !strings.Contains(globalLevel, \"=\") {\n\t\t// Validate debug log level.\n\t\tif !validLogLevel(globalLevel) {\n\t\t\tstr := \"the specified debug level [%v] is invalid\"\n\t\t\treturn fmt.Errorf(str, globalLevel)\n\t\t}\n\n\t\t// Change the logging level for all subsystems.\n\t\tlogger.SetLogLevels(globalLevel)\n\n\t\t// The rest will target specific subsystems.\n\t\tlevels = levels[1:]\n\t}\n\n\t// Go through the subsystem/level pairs while detecting issues and\n\t// update the log levels accordingly.\n\tfor _, logLevelPair := range levels {\n\t\tif !strings.Contains(logLevelPair, \"=\") {\n\t\t\tstr := \"the specified debug level contains an \" +\n\t\t\t\t\"invalid subsystem/level pair [%v]\"\n\t\t\treturn fmt.Errorf(str, logLevelPair)\n\t\t}\n\n\t\t// Extract the specified subsystem and log level.\n\t\tfields := strings.Split(logLevelPair, \"=\")\n\t\tif len(fields) != 2 {\n\t\t\tstr := \"the specified debug level has an invalid \" +\n\t\t\t\t\"format [%v] -- use format subsystem1=level1,\" +\n\t\t\t\t\"subsystem2=level2\"\n\t\t\treturn fmt.Errorf(str, logLevelPair)\n\t\t}\n\t\tsubsysID, logLevel := fields[0], fields[1]\n\t\tsubLoggers := logger.SubLoggers()\n\n\t\t// Validate subsystem.\n\t\tif _, exists := subLoggers[subsysID]; !exists {\n\t\t\tstr := \"the specified subsystem [%v] is invalid -- \" +\n\t\t\t\t\"supported subsystems are %v\"\n\t\t\treturn fmt.Errorf(\n\t\t\t\tstr, subsysID, logger.SupportedSubsystems(),\n\t\t\t)\n\t\t}\n\n\t\t// Validate log level.\n\t\tif !validLogLevel(logLevel) {\n\t\t\tstr := \"the specified debug level [%v] is invalid\"\n\t\t\treturn fmt.Errorf(str, logLevel)\n\t\t}\n\n\t\tlogger.SetLogLevel(subsysID, logLevel)\n\t}\n\n\treturn nil\n}\n\n// validLogLevel returns whether or not logLevel is a valid debug log level.",
      "length": 1798,
      "tokens": 251,
      "embedding": []
    },
    {
      "slug": "func validLogLevel(logLevel string) bool {",
      "content": "func validLogLevel(logLevel string) bool {\n\tswitch logLevel {\n\tcase \"trace\":\n\t\tfallthrough\n\tcase \"debug\":\n\t\tfallthrough\n\tcase \"info\":\n\t\tfallthrough\n\tcase \"warn\":\n\t\tfallthrough\n\tcase \"error\":\n\t\tfallthrough\n\tcase \"critical\":\n\t\tfallthrough\n\tcase \"off\":\n\t\treturn true\n\t}\n\treturn false\n}\n",
      "length": 222,
      "tokens": 29,
      "embedding": []
    }
  ]
}