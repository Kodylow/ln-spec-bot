{
  "filepath": "../implementations/go/lnd/build/log_test.go",
  "package": "build_test",
  "sections": [
    {
      "slug": "type mockSubLogger struct {",
      "content": "type mockSubLogger struct {\n\tglobalLogLevel string\n\tsubLogLevels   map[string]string\n}\n",
      "length": 56,
      "tokens": 5,
      "embedding": []
    },
    {
      "slug": "func (m *mockSubLogger) SubLoggers() build.SubLoggers {",
      "content": "func (m *mockSubLogger) SubLoggers() build.SubLoggers {\n\treturn build.SubLoggers{\n\t\t\"PEER\": btclog.Disabled,\n\t\t\"SRVR\": btclog.Disabled,\n\t}\n}\n",
      "length": 80,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (m *mockSubLogger) SupportedSubsystems() []string {",
      "content": "func (m *mockSubLogger) SupportedSubsystems() []string {\n\treturn nil\n}\n",
      "length": 12,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (m *mockSubLogger) SetLogLevel(subsystemID string, logLevel string) {",
      "content": "func (m *mockSubLogger) SetLogLevel(subsystemID string, logLevel string) {\n\tm.subLogLevels[subsystemID] = logLevel\n}\n",
      "length": 40,
      "tokens": 4,
      "embedding": []
    },
    {
      "slug": "func (m *mockSubLogger) SetLogLevels(logLevel string) {",
      "content": "func (m *mockSubLogger) SetLogLevels(logLevel string) {\n\tm.globalLogLevel = logLevel\n}\n\n// TestParseAndSetDebugLevels tests that we can properly set the log levels for\n// all andspecified subsystems.",
      "length": 139,
      "tokens": 20,
      "embedding": []
    },
    {
      "slug": "func TestParseAndSetDebugLevels(t *testing.T) {",
      "content": "func TestParseAndSetDebugLevels(t *testing.T) {\n\ttestCases := []struct {\n\t\tname         string\n\t\tdebugLevel   string\n\t\texpErr       string\n\t\texpGlobal    string\n\t\texpSubLevels map[string]string\n\t}{\n\t\t{\n\t\t\tname:       \"empty log level\",\n\t\t\tdebugLevel: \"\",\n\t\t\texpErr:     \"invalid\",\n\t\t},\n\t\t{\n\t\t\tname:       \"invalid global debug level\",\n\t\t\tdebugLevel: \"ddddddebug\",\n\t\t\texpErr:     \"invalid\",\n\t\t},\n\t\t{\n\t\t\tname:       \"global debug level\",\n\t\t\tdebugLevel: \"debug\",\n\t\t\texpGlobal:  \"debug\",\n\t\t},\n\t\t{\n\t\t\tname:       \"invalid global debug level#2\",\n\t\t\tdebugLevel: \"debug,info\",\n\t\t\texpErr:     \"invalid\",\n\t\t},\n\t\t{\n\t\t\tname:       \"invalid subsystem debug level\",\n\t\t\tdebugLevel: \"AAAA=debug\",\n\t\t\texpErr:     \"invalid\",\n\t\t},\n\t\t{\n\t\t\tname:       \"valid subsystem debug level\",\n\t\t\tdebugLevel: \"PEER=info,SRVR=debug\",\n\t\t\texpSubLevels: map[string]string{\n\t\t\t\t\"PEER\": \"info\",\n\t\t\t\t\"SRVR\": \"debug\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:       \"valid global+subsystem debug level\",\n\t\t\tdebugLevel: \"trace,PEER=info,SRVR=debug\",\n\t\t\texpGlobal:  \"trace\",\n\t\t\texpSubLevels: map[string]string{\n\t\t\t\t\"PEER\": \"info\",\n\t\t\t\t\"SRVR\": \"debug\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:       \"invalid global+subsystem debug level\",\n\t\t\tdebugLevel: \"PEER=info,debug,SRVR=debug\",\n\t\t\texpErr:     \"invalid\",\n\t\t},\n\t}\n\n\tfor _, test := range testCases {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tm := &mockSubLogger{\n\t\t\t\tsubLogLevels: make(map[string]string),\n\t\t\t}\n\n\t\t\t// If the subsystem map is empty, make and empty one to ensure\n\t\t\t// the equal test later succeeds.\n\t\t\tif len(test.expSubLevels) == 0 {\n\t\t\t\ttest.expSubLevels = make(map[string]string)\n\t\t\t}\n\n\t\t\terr := build.ParseAndSetDebugLevels(test.debugLevel, m)\n\t\t\tif test.expErr != \"\" {\n\t\t\t\trequire.Contains(t, err.Error(), test.expErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\trequire.NoError(t, err)\n\n\t\t\trequire.Equal(t, test.expGlobal, m.globalLogLevel)\n\t\t\trequire.Equal(t, test.expSubLevels, m.subLogLevels)\n\t\t})\n\t}\n}\n",
      "length": 1766,
      "tokens": 187,
      "embedding": []
    }
  ]
}