{
  "filepath": "../implementations/go/lnd/channel_notifier.go",
  "package": "lnd",
  "sections": [
    {
      "slug": "type addrSource interface {",
      "content": "type addrSource interface {\n\t// AddrsForNode returns all known addresses for the target node public\n\t// key.\n\tAddrsForNode(nodePub *btcec.PublicKey) ([]net.Addr, error)\n}\n\n// channelNotifier is an implementation of the chanbackup.ChannelNotifier\n// interface using the existing channelnotifier.ChannelNotifier struct. This\n// implementation allows us to satisfy all the dependencies of the\n// chanbackup.SubSwapper struct.",
      "length": 386,
      "tokens": 48,
      "embedding": []
    },
    {
      "slug": "type channelNotifier struct {",
      "content": "type channelNotifier struct {\n\t// chanNotifier is the based channel notifier that we'll proxy requests\n\t// from.\n\tchanNotifier *channelnotifier.ChannelNotifier\n\n\t// addrs is an implementation of the addrSource interface that allows\n\t// us to get the latest set of addresses for a given node. We'll need\n\t// this to be able to create an SCB for new channels.\n\taddrs addrSource\n}\n\n// SubscribeChans requests a new channel subscription relative to the initial\n// set of known channels. We use the knownChans as a synchronization point to\n// ensure that the chanbackup.SubSwapper does not miss any channel open or\n// close events in the period between when it's created, and when it requests\n// the channel subscription.\n//\n// NOTE: This is part of the chanbackup.ChannelNotifier interface.",
      "length": 740,
      "tokens": 121,
      "embedding": []
    },
    {
      "slug": "func (c *channelNotifier) SubscribeChans(startingChans map[wire.OutPoint]struct{}) (",
      "content": "func (c *channelNotifier) SubscribeChans(startingChans map[wire.OutPoint]struct{}) (\n\t*chanbackup.ChannelSubscription, error) {\n\n\tltndLog.Infof(\"Channel backup proxy channel notifier starting\")\n\n\t// TODO(roasbeef): read existing set of chans and diff\n\n\tquit := make(chan struct{})\n\tchanUpdates := make(chan chanbackup.ChannelEvent, 1)\n\n\t// sendChanOpenUpdate is a closure that sends a ChannelEvent to the\n\t// chanUpdates channel to inform subscribers about new pending or\n\t// confirmed channels.\n\tsendChanOpenUpdate := func(newOrPendingChan *channeldb.OpenChannel) {\n\t\tnodeAddrs, err := c.addrs.AddrsForNode(\n\t\t\tnewOrPendingChan.IdentityPub,\n\t\t)\n\t\tif err != nil {\n\t\t\tpub := newOrPendingChan.IdentityPub\n\t\t\tltndLog.Errorf(\"unable to fetch addrs for %x: %v\",\n\t\t\t\tpub.SerializeCompressed(), err)\n\t\t}\n\n\t\tchanEvent := chanbackup.ChannelEvent{\n\t\t\tNewChans: []chanbackup.ChannelWithAddrs{\n\t\t\t\t{\n\t\t\t\t\tOpenChannel: newOrPendingChan,\n\t\t\t\t\tAddrs:       nodeAddrs,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tselect {\n\t\tcase chanUpdates <- chanEvent:\n\t\tcase <-quit:\n\t\t\treturn\n\t\t}\n\t}\n\n\t// In order to adhere to the interface, we'll proxy the events from the\n\t// channel notifier to the sub-swapper in a format it understands.\n\tgo func() {\n\t\t// First, we'll subscribe to the primary channel notifier so we can\n\t\t// obtain events for new opened/closed channels.\n\t\tchanSubscription, err := c.chanNotifier.SubscribeChannelEvents()\n\t\tif err != nil {\n\t\t\tpanic(fmt.Sprintf(\"unable to subscribe to chans: %v\",\n\t\t\t\terr))\n\t\t}\n\n\t\tdefer chanSubscription.Cancel()\n\n\t\tfor {\n\t\t\tselect {\n\n\t\t\t// A new event has been sent by the chanNotifier, we'll\n\t\t\t// filter out the events we actually care about and\n\t\t\t// send them to the sub-swapper.\n\t\t\tcase e := <-chanSubscription.Updates():\n\t\t\t\t// TODO(roasbeef): batch dispatch ntnfs\n\n\t\t\t\tswitch event := e.(type) {\n\t\t\t\t// A new channel has been opened and is still\n\t\t\t\t// pending. We can still create a backup, even\n\t\t\t\t// if the final channel ID is not yet available.\n\t\t\t\tcase channelnotifier.PendingOpenChannelEvent:\n\t\t\t\t\tpendingChan := event.PendingChannel\n\t\t\t\t\tsendChanOpenUpdate(pendingChan)\n\n\t\t\t\t// A new channel has been confirmed, we'll\n\t\t\t\t// obtain the node address, then send to the\n\t\t\t\t// sub-swapper.\n\t\t\t\tcase channelnotifier.OpenChannelEvent:\n\t\t\t\t\tsendChanOpenUpdate(event.Channel)\n\n\t\t\t\t// An existing channel has been closed, we'll\n\t\t\t\t// send only the chanPoint of the closed\n\t\t\t\t// channel to the sub-swapper.\n\t\t\t\tcase channelnotifier.ClosedChannelEvent:\n\t\t\t\t\tchanPoint := event.CloseSummary.ChanPoint\n\t\t\t\t\tcloseType := event.CloseSummary.CloseType\n\n\t\t\t\t\t// Because we see the contract as closed\n\t\t\t\t\t// once our local force close TX\n\t\t\t\t\t// confirms, the channel arbitrator\n\t\t\t\t\t// already fires on this event. But\n\t\t\t\t\t// because our funds can be in limbo for\n\t\t\t\t\t// up to 2 weeks worst case we don't\n\t\t\t\t\t// want to remove the crucial info we\n\t\t\t\t\t// need for sweeping that time locked\n\t\t\t\t\t// output before we've actually done so.\n\t\t\t\t\tif closeType == channeldb.LocalForceClose {\n\t\t\t\t\t\tltndLog.Debugf(\"Channel %v \"+\n\t\t\t\t\t\t\t\"was force closed by \"+\n\t\t\t\t\t\t\t\"us, not removing \"+\n\t\t\t\t\t\t\t\"from channel backup \"+\n\t\t\t\t\t\t\t\"until fully resolved\",\n\t\t\t\t\t\t\tchanPoint)\n\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\tchanEvent := chanbackup.ChannelEvent{\n\t\t\t\t\t\tClosedChans: []wire.OutPoint{\n\t\t\t\t\t\t\tchanPoint,\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\n\t\t\t\t\tselect {\n\t\t\t\t\tcase chanUpdates <- chanEvent:\n\t\t\t\t\tcase <-quit:\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t// A channel was fully resolved on chain. This\n\t\t\t\t// should only really interest us if it was a\n\t\t\t\t// locally force closed channel where we didn't\n\t\t\t\t// remove the channel already when the close\n\t\t\t\t// event was fired.\n\t\t\t\tcase channelnotifier.FullyResolvedChannelEvent:\n\t\t\t\t\tchanEvent := chanbackup.ChannelEvent{\n\t\t\t\t\t\tClosedChans: []wire.OutPoint{\n\t\t\t\t\t\t\t*event.ChannelPoint,\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\n\t\t\t\t\tselect {\n\t\t\t\t\tcase chanUpdates <- chanEvent:\n\t\t\t\t\tcase <-quit:\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// The cancel method has been called, signalling us to\n\t\t\t// exit\n\t\t\tcase <-quit:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn &chanbackup.ChannelSubscription{\n\t\tChanUpdates: chanUpdates,\n\t\tCancel: func() {\n\t\t\tclose(quit)\n\t\t},\n\t}, nil\n}\n\n// A compile-time constraint to ensure channelNotifier implements\n// chanbackup.ChannelNotifier.\nvar _ chanbackup.ChannelNotifier = (*channelNotifier)(nil)\n",
      "length": 4041,
      "tokens": 518,
      "embedding": []
    }
  ]
}