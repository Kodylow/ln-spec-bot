{
  "filepath": "../implementations/go/lnd/htlcswitch/payment_result_test.go",
  "package": "htlcswitch",
  "sections": [
    {
      "slug": "func TestNetworkResultSerialization(t *testing.T) {",
      "content": "func TestNetworkResultSerialization(t *testing.T) {\n\tt.Parallel()\n\n\tvar preimage lntypes.Preimage\n\tif _, err := rand.Read(preimage[:]); err != nil {\n\t\tt.Fatalf(\"unable gen rand preimag: %v\", err)\n\t}\n\n\tvar chanID lnwire.ChannelID\n\tif _, err := rand.Read(chanID[:]); err != nil {\n\t\tt.Fatalf(\"unable gen rand chanid: %v\", err)\n\t}\n\n\tvar reason [256]byte\n\tif _, err := rand.Read(reason[:]); err != nil {\n\t\tt.Fatalf(\"unable gen rand reason: %v\", err)\n\t}\n\n\tsettle := &lnwire.UpdateFulfillHTLC{\n\t\tChanID:          chanID,\n\t\tID:              2,\n\t\tPaymentPreimage: preimage,\n\t\tExtraData:       make([]byte, 0),\n\t}\n\n\tfail := &lnwire.UpdateFailHTLC{\n\t\tChanID:    chanID,\n\t\tID:        1,\n\t\tReason:    []byte{},\n\t\tExtraData: make([]byte, 0),\n\t}\n\n\tfail2 := &lnwire.UpdateFailHTLC{\n\t\tChanID:    chanID,\n\t\tID:        1,\n\t\tReason:    reason[:],\n\t\tExtraData: make([]byte, 0),\n\t}\n\n\ttestCases := []*networkResult{\n\t\t{\n\t\t\tmsg: settle,\n\t\t},\n\t\t{\n\t\t\tmsg:          fail,\n\t\t\tunencrypted:  false,\n\t\t\tisResolution: false,\n\t\t},\n\t\t{\n\t\t\tmsg:          fail,\n\t\t\tunencrypted:  false,\n\t\t\tisResolution: true,\n\t\t},\n\t\t{\n\t\t\tmsg:          fail2,\n\t\t\tunencrypted:  true,\n\t\t\tisResolution: false,\n\t\t},\n\t}\n\n\tfor _, p := range testCases {\n\t\tvar buf bytes.Buffer\n\t\tif err := serializeNetworkResult(&buf, p); err != nil {\n\t\t\tt.Fatalf(\"serialize failed: %v\", err)\n\t\t}\n\n\t\tr := bytes.NewReader(buf.Bytes())\n\t\tp1, err := deserializeNetworkResult(r)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to deserizlize: %v\", err)\n\t\t}\n\n\t\tif !reflect.DeepEqual(p, p1) {\n\t\t\tt.Fatalf(\"not equal. %v vs %v\", spew.Sdump(p),\n\t\t\t\tspew.Sdump(p1))\n\t\t}\n\t}\n}\n\n// TestNetworkResultStore tests that the networkResult store behaves as\n// expected, and that we can store, get and subscribe to results.",
      "length": 1584,
      "tokens": 206,
      "embedding": []
    },
    {
      "slug": "func TestNetworkResultStore(t *testing.T) {",
      "content": "func TestNetworkResultStore(t *testing.T) {\n\tt.Parallel()\n\n\tconst numResults = 4\n\n\tdb, err := channeldb.Open(t.TempDir())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Cleanup(func() { db.Close() })\n\n\tstore := newNetworkResultStore(db)\n\n\tvar results []*networkResult\n\tfor i := 0; i < numResults; i++ {\n\t\tn := &networkResult{\n\t\t\tmsg:          &lnwire.UpdateAddHTLC{},\n\t\t\tunencrypted:  true,\n\t\t\tisResolution: true,\n\t\t}\n\t\tresults = append(results, n)\n\t}\n\n\t// Subscribe to 2 of them.\n\tvar subs []<-chan *networkResult\n\tfor i := uint64(0); i < 2; i++ {\n\t\tsub, err := store.subscribeResult(i)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to subscribe: %v\", err)\n\t\t}\n\t\tsubs = append(subs, sub)\n\t}\n\n\t// Store three of them.\n\tfor i := uint64(0); i < 3; i++ {\n\t\terr := store.storeResult(i, results[i])\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to store result: %v\", err)\n\t\t}\n\t}\n\n\t// The two subscribers should be notified.\n\tfor _, sub := range subs {\n\t\tselect {\n\t\tcase <-sub:\n\t\tcase <-time.After(1 * time.Second):\n\t\t\tt.Fatalf(\"no result received\")\n\t\t}\n\t}\n\n\t// Let the third one subscribe now. THe result should be received\n\t// immediately.\n\tsub, err := store.subscribeResult(2)\n\trequire.NoError(t, err, \"unable to subscribe\")\n\tselect {\n\tcase <-sub:\n\tcase <-time.After(1 * time.Second):\n\t\tt.Fatalf(\"no result received\")\n\t}\n\n\t// Try fetching the result directly for the non-stored one. This should\n\t// fail.\n\t_, err = store.getResult(3)\n\tif err != ErrPaymentIDNotFound {\n\t\tt.Fatalf(\"expected ErrPaymentIDNotFound, got %v\", err)\n\t}\n\n\t// Add the result and try again.\n\terr = store.storeResult(3, results[3])\n\trequire.NoError(t, err, \"unable to store result\")\n\n\t_, err = store.getResult(3)\n\trequire.NoError(t, err, \"unable to get result\")\n\n\t// Since we don't delete results from the store (yet), make sure we\n\t// will get subscriptions for all of them.\n\tfor i := uint64(0); i < numResults; i++ {\n\t\tsub, err := store.subscribeResult(i)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to subscribe: %v\", err)\n\t\t}\n\n\t\tselect {\n\t\tcase <-sub:\n\t\tcase <-time.After(1 * time.Second):\n\t\t\tt.Fatalf(\"no result received\")\n\t\t}\n\t}\n\n\t// Clean the store keeping the first two results.\n\ttoKeep := map[uint64]struct{}{\n\t\t0: {},\n\t\t1: {},\n\t}\n\t// Finally, delete the result.\n\terr = store.cleanStore(toKeep)\n\trequire.NoError(t, err)\n\n\t// Payment IDs 0 and 1 should be found, 2 and 3 should be deleted.\n\tfor i := uint64(0); i < numResults; i++ {\n\t\t_, err = store.getResult(i)\n\t\tif i <= 1 {\n\t\t\trequire.NoError(t, err, \"unable to get result\")\n\t\t}\n\t\tif i >= 2 && err != ErrPaymentIDNotFound {\n\t\t\tt.Fatalf(\"expected ErrPaymentIDNotFound, got %v\", err)\n\t\t}\n\t}\n}\n",
      "length": 2437,
      "tokens": 380,
      "embedding": []
    }
  ]
}