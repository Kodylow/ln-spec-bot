{
  "filepath": "../implementations/go/lnd/htlcswitch/circuit_map_test.go",
  "package": "htlcswitch_test",
  "sections": [
    {
      "slug": "func TestCircuitMapCleanClosedChannels(t *testing.T) {",
      "content": "func TestCircuitMapCleanClosedChannels(t *testing.T) {\n\tt.Parallel()\n\n\tvar (\n\t\t// chanID0 is a zero value channel ID indicating a locally\n\t\t// initiated payment.\n\t\tchanID0 = lnwire.NewShortChanIDFromInt(uint64(0))\n\t\tchanID1 = lnwire.NewShortChanIDFromInt(uint64(1))\n\t\tchanID2 = lnwire.NewShortChanIDFromInt(uint64(2))\n\n\t\tinKey00  = htlcswitch.CircuitKey{ChanID: chanID0, HtlcID: 0}\n\t\tinKey10  = htlcswitch.CircuitKey{ChanID: chanID1, HtlcID: 0}\n\t\tinKey11  = htlcswitch.CircuitKey{ChanID: chanID1, HtlcID: 1}\n\t\tinKey20  = htlcswitch.CircuitKey{ChanID: chanID2, HtlcID: 0}\n\t\tinKey21  = htlcswitch.CircuitKey{ChanID: chanID2, HtlcID: 1}\n\t\tinKey22  = htlcswitch.CircuitKey{ChanID: chanID2, HtlcID: 2}\n\t\toutKey00 = htlcswitch.CircuitKey{ChanID: chanID0, HtlcID: 0}\n\t\toutKey10 = htlcswitch.CircuitKey{ChanID: chanID1, HtlcID: 0}\n\t\toutKey11 = htlcswitch.CircuitKey{ChanID: chanID1, HtlcID: 1}\n\t\toutKey20 = htlcswitch.CircuitKey{ChanID: chanID2, HtlcID: 0}\n\t\toutKey21 = htlcswitch.CircuitKey{ChanID: chanID2, HtlcID: 1}\n\t\toutKey22 = htlcswitch.CircuitKey{ChanID: chanID2, HtlcID: 2}\n\t)\n\n\ttype closeChannelParams struct {\n\t\tchanID    lnwire.ShortChannelID\n\t\tisPending bool\n\t}\n\n\ttestParams := []struct {\n\t\tname string\n\n\t\t// keystones is used to create and open circuits. A keystone is\n\t\t// a pair of circuit keys, inKey and outKey, with the outKey\n\t\t// optionally being empty. If a keystone with an outKey is used,\n\t\t// a circuit will be created and opened, thus creating a circuit\n\t\t// and a keystone in the DB. Otherwise, only the circuit is\n\t\t// created.\n\t\tkeystones []htlcswitch.Keystone\n\n\t\tchanParams []closeChannelParams\n\t\tdeleted    []htlcswitch.Keystone\n\t\tuntouched  []htlcswitch.Keystone\n\n\t\t// If resMsg is true, then closed channels will not delete\n\t\t// circuits if the channel was the keystone / outgoing key in\n\t\t// the open circuit.\n\t\tresMsg bool\n\t}{\n\t\t{\n\t\t\tname: \"no deletion if there are no closed channels\",\n\t\t\tkeystones: []htlcswitch.Keystone{\n\t\t\t\t// Creates a circuit and a keystone\n\t\t\t\t{InKey: inKey10, OutKey: outKey10},\n\t\t\t},\n\t\t\tuntouched: []htlcswitch.Keystone{\n\t\t\t\t{InKey: inKey10, OutKey: outKey10},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"no deletion if channel is pending close\",\n\t\t\tchanParams: []closeChannelParams{\n\t\t\t\t// Creates a pending close channel.\n\t\t\t\t{chanID: chanID1, isPending: true},\n\t\t\t},\n\t\t\tkeystones: []htlcswitch.Keystone{\n\t\t\t\t// Creates a circuit and a keystone\n\t\t\t\t{InKey: inKey10, OutKey: outKey10},\n\t\t\t},\n\t\t\tuntouched: []htlcswitch.Keystone{\n\t\t\t\t{InKey: inKey10, OutKey: outKey10},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"no deletion if the chanID is zero value\",\n\t\t\tchanParams: []closeChannelParams{\n\t\t\t\t// Creates a close channel with chanID0.\n\t\t\t\t{chanID: chanID0, isPending: false},\n\t\t\t},\n\t\t\tkeystones: []htlcswitch.Keystone{\n\t\t\t\t// Creates a circuit and a keystone\n\t\t\t\t{InKey: inKey00, OutKey: outKey00},\n\t\t\t},\n\t\t\tuntouched: []htlcswitch.Keystone{\n\t\t\t\t{InKey: inKey00, OutKey: outKey00},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"delete half circuits on inKey match\",\n\t\t\tchanParams: []closeChannelParams{\n\t\t\t\t// Creates a close channel with chanID1.\n\t\t\t\t{chanID: chanID1, isPending: false},\n\t\t\t},\n\t\t\tkeystones: []htlcswitch.Keystone{\n\t\t\t\t// Creates a circuit, no keystone created\n\t\t\t\t{InKey: inKey10},\n\t\t\t\t// Creates a circuit, no keystone created\n\t\t\t\t{InKey: inKey11},\n\t\t\t\t// Creates a circuit and a keystone\n\t\t\t\t{InKey: inKey20, OutKey: outKey20},\n\t\t\t},\n\t\t\tdeleted: []htlcswitch.Keystone{\n\t\t\t\t{InKey: inKey10}, {InKey: inKey11},\n\t\t\t},\n\t\t\tuntouched: []htlcswitch.Keystone{\n\t\t\t\t{InKey: inKey20, OutKey: outKey20},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"delete half circuits on outKey match\",\n\t\t\tchanParams: []closeChannelParams{\n\t\t\t\t// Creates a close channel with chanID1.\n\t\t\t\t{chanID: chanID1, isPending: false},\n\t\t\t},\n\t\t\tkeystones: []htlcswitch.Keystone{\n\t\t\t\t// Creates a circuit and a keystone\n\t\t\t\t{InKey: inKey20, OutKey: outKey10},\n\t\t\t\t// Creates a circuit and a keystone\n\t\t\t\t{InKey: inKey21, OutKey: outKey11},\n\t\t\t\t// Creates a circuit and a keystone\n\t\t\t\t{InKey: inKey22, OutKey: outKey21},\n\t\t\t},\n\t\t\tdeleted: []htlcswitch.Keystone{\n\t\t\t\t{InKey: inKey20, OutKey: outKey10},\n\t\t\t\t{InKey: inKey21, OutKey: outKey11},\n\t\t\t},\n\t\t\tuntouched: []htlcswitch.Keystone{\n\t\t\t\t{InKey: inKey22, OutKey: outKey21},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"delete full circuits on inKey match\",\n\t\t\tchanParams: []closeChannelParams{\n\t\t\t\t// Creates a close channel with chanID1.\n\t\t\t\t{chanID: chanID1, isPending: false},\n\t\t\t},\n\t\t\tkeystones: []htlcswitch.Keystone{\n\t\t\t\t// Creates a circuit and a keystone\n\t\t\t\t{InKey: inKey10, OutKey: outKey20},\n\t\t\t\t// Creates a circuit and a keystone\n\t\t\t\t{InKey: inKey11, OutKey: outKey21},\n\t\t\t\t// Creates a circuit and a keystone\n\t\t\t\t{InKey: inKey20, OutKey: outKey22},\n\t\t\t},\n\t\t\tdeleted: []htlcswitch.Keystone{\n\t\t\t\t{InKey: inKey10, OutKey: outKey20},\n\t\t\t\t{InKey: inKey11, OutKey: outKey21},\n\t\t\t},\n\t\t\tuntouched: []htlcswitch.Keystone{\n\t\t\t\t{InKey: inKey20, OutKey: outKey22},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"delete full circuits on outKey match\",\n\t\t\tchanParams: []closeChannelParams{\n\t\t\t\t// Creates a close channel with chanID1.\n\t\t\t\t{chanID: chanID1, isPending: false},\n\t\t\t},\n\t\t\tkeystones: []htlcswitch.Keystone{\n\t\t\t\t// Creates a circuit and a keystone\n\t\t\t\t{InKey: inKey20, OutKey: outKey10},\n\t\t\t\t// Creates a circuit and a keystone\n\t\t\t\t{InKey: inKey21, OutKey: outKey11},\n\t\t\t\t// Creates a circuit and a keystone\n\t\t\t\t{InKey: inKey22, OutKey: outKey20},\n\t\t\t},\n\t\t\tdeleted: []htlcswitch.Keystone{\n\t\t\t\t{InKey: inKey20, OutKey: outKey10},\n\t\t\t\t{InKey: inKey21, OutKey: outKey11},\n\t\t\t},\n\t\t\tuntouched: []htlcswitch.Keystone{\n\t\t\t\t{InKey: inKey22, OutKey: outKey20},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"delete all circuits\",\n\t\t\tchanParams: []closeChannelParams{\n\t\t\t\t// Creates a close channel with chanID1.\n\t\t\t\t{chanID: chanID1, isPending: false},\n\t\t\t\t// Creates a close channel with chanID2.\n\t\t\t\t{chanID: chanID2, isPending: false},\n\t\t\t},\n\t\t\tkeystones: []htlcswitch.Keystone{\n\t\t\t\t// Creates a circuit and a keystone\n\t\t\t\t{InKey: inKey20, OutKey: outKey10},\n\t\t\t\t// Creates a circuit and a keystone\n\t\t\t\t{InKey: inKey21, OutKey: outKey11},\n\t\t\t\t// Creates a circuit and a keystone\n\t\t\t\t{InKey: inKey22, OutKey: outKey20},\n\t\t\t},\n\t\t\tdeleted: []htlcswitch.Keystone{\n\t\t\t\t{InKey: inKey20, OutKey: outKey10},\n\t\t\t\t{InKey: inKey21, OutKey: outKey11},\n\t\t\t\t{InKey: inKey22, OutKey: outKey20},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"don't delete circuits for outgoing\",\n\t\t\tchanParams: []closeChannelParams{\n\t\t\t\t// Creates a close channel with chanID1.\n\t\t\t\t{chanID: chanID1, isPending: false},\n\t\t\t},\n\t\t\tkeystones: []htlcswitch.Keystone{\n\t\t\t\t// Creates a circuit and a keystone\n\t\t\t\t{InKey: inKey10, OutKey: outKey10},\n\t\t\t\t// Creates a circuit and a keystone\n\t\t\t\t{InKey: inKey11, OutKey: outKey20},\n\t\t\t\t// Creates a circuit and a keystone\n\t\t\t\t{InKey: inKey00, OutKey: outKey11},\n\t\t\t},\n\t\t\tdeleted: []htlcswitch.Keystone{\n\t\t\t\t{InKey: inKey10, OutKey: outKey10},\n\t\t\t\t{InKey: inKey11, OutKey: outKey20},\n\t\t\t},\n\t\t\tresMsg: true,\n\t\t},\n\t}\n\n\tfor _, tt := range testParams {\n\t\ttest := tt\n\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tcfg, circuitMap := newCircuitMap(t, test.resMsg)\n\n\t\t\t// create test circuits\n\t\t\tfor _, ks := range test.keystones {\n\t\t\t\terr := createTestCircuit(ks, circuitMap)\n\t\t\t\trequire.NoError(\n\t\t\t\t\tt, err,\n\t\t\t\t\t\"failed to create test circuit\",\n\t\t\t\t)\n\t\t\t}\n\n\t\t\t// create close channels\n\t\t\terr := kvdb.Update(cfg.DB, func(tx kvdb.RwTx) error {\n\t\t\t\tfor _, channel := range test.chanParams {\n\t\t\t\t\tif err := createTestCloseChannelSummery(\n\t\t\t\t\t\ttx, channel.isPending,\n\t\t\t\t\t\tchannel.chanID,\n\t\t\t\t\t); err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}, func() {})\n\n\t\t\trequire.NoError(\n\t\t\t\tt, err,\n\t\t\t\t\"failed to create close channel summery\",\n\t\t\t)\n\n\t\t\t// Now, restart the circuit map, and check that the\n\t\t\t// circuits and keystones of closed channels are\n\t\t\t// deleted in DB.\n\t\t\t_, circuitMap = restartCircuitMap(t, cfg)\n\n\t\t\t// Check that items are deleted. LookupCircuit and\n\t\t\t// LookupOpenCircuit will check the cached circuits,\n\t\t\t// which are loaded on restart from the DB.\n\t\t\tfor _, ks := range test.deleted {\n\t\t\t\tassertKeystoneDeleted(t, circuitMap, ks)\n\t\t\t}\n\n\t\t\t// We also check we are not deleting wanted circuits.\n\t\t\tfor _, ks := range test.untouched {\n\t\t\t\tassertKeystoneNotDeleted(t, circuitMap, ks)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// createTestCircuit creates a circuit for testing with its incoming key being\n// the keystone's InKey. If the keystone has an OutKey, the circuit will be\n// opened, which causes a Keystone to be created in DB.",
      "length": 8044,
      "tokens": 1006,
      "embedding": []
    },
    {
      "slug": "func createTestCircuit(ks htlcswitch.Keystone, cm htlcswitch.CircuitMap) error {",
      "content": "func createTestCircuit(ks htlcswitch.Keystone, cm htlcswitch.CircuitMap) error {\n\tcircuit := &htlcswitch.PaymentCircuit{\n\t\tIncoming:       ks.InKey,\n\t\tErrorEncrypter: testExtracter,\n\t}\n\n\t// First we will try to add an new circuit to the circuit map, this\n\t// should succeed.\n\t_, err := cm.CommitCircuits(circuit)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to commit circuits: %v\", err)\n\t}\n\n\t// If the keystone has no outgoing key, we won't open it.\n\tif ks.OutKey == htlcswitch.EmptyCircuitKey {\n\t\treturn nil\n\t}\n\n\t// Open the circuit, implicitly creates a keystone on disk.\n\terr = cm.OpenCircuits(ks)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to open circuits: %v\", err)\n\t}\n\n\treturn nil\n}\n\n// assertKeystoneDeleted checks that a given keystone is deleted from the\n// circuit map.",
      "length": 675,
      "tokens": 106,
      "embedding": []
    },
    {
      "slug": "func assertKeystoneDeleted(t *testing.T,",
      "content": "func assertKeystoneDeleted(t *testing.T,\n\tcm htlcswitch.CircuitLookup, ks htlcswitch.Keystone) {\n\n\tc := cm.LookupCircuit(ks.InKey)\n\trequire.Nil(t, c, \"no circuit should be found using InKey\")\n\n\tif ks.OutKey != htlcswitch.EmptyCircuitKey {\n\t\tc = cm.LookupOpenCircuit(ks.OutKey)\n\t\trequire.Nil(t, c, \"no circuit should be found using OutKey\")\n\t}\n}\n\n// assertKeystoneDeleted checks that a given keystone is not deleted from the\n// circuit map.",
      "length": 386,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func assertKeystoneNotDeleted(t *testing.T,",
      "content": "func assertKeystoneNotDeleted(t *testing.T,\n\tcm htlcswitch.CircuitLookup, ks htlcswitch.Keystone) {\n\n\tc := cm.LookupCircuit(ks.InKey)\n\trequire.NotNil(t, c, \"expecting circuit found using InKey\")\n\n\tif ks.OutKey != htlcswitch.EmptyCircuitKey {\n\t\tc = cm.LookupOpenCircuit(ks.OutKey)\n\t\trequire.NotNil(t, c, \"expecting circuit found using OutKey\")\n\t}\n}\n\n// createTestCloseChannelSummery creates a CloseChannelSummery for testing.",
      "length": 369,
      "tokens": 39,
      "embedding": []
    },
    {
      "slug": "func createTestCloseChannelSummery(tx kvdb.RwTx, isPending bool,",
      "content": "func createTestCloseChannelSummery(tx kvdb.RwTx, isPending bool,\n\tchanID lnwire.ShortChannelID) error {\n\n\tclosedChanBucket, err := tx.CreateTopLevelBucket(closedChannelBucket)\n\tif err != nil {\n\t\treturn err\n\t}\n\toutputPoint := wire.OutPoint{Hash: hash1, Index: 1}\n\n\tccs := &channeldb.ChannelCloseSummary{\n\t\tChanPoint:      outputPoint,\n\t\tShortChanID:    chanID,\n\t\tChainHash:      hash1,\n\t\tClosingTXID:    hash2,\n\t\tCloseHeight:    100,\n\t\tRemotePub:      testEphemeralKey,\n\t\tCapacity:       btcutil.Amount(10000),\n\t\tSettledBalance: btcutil.Amount(50000),\n\t\tCloseType:      channeldb.RemoteForceClose,\n\t\tIsPending:      isPending,\n\t}\n\tvar b bytes.Buffer\n\tif err := serializeChannelCloseSummary(&b, ccs); err != nil {\n\t\treturn err\n\t}\n\n\tvar chanPointBuf bytes.Buffer\n\tif err := lnwire.WriteOutPoint(&chanPointBuf, outputPoint); err != nil {\n\t\treturn err\n\t}\n\n\treturn closedChanBucket.Put(chanPointBuf.Bytes(), b.Bytes())\n}\n",
      "length": 818,
      "tokens": 80,
      "embedding": []
    },
    {
      "slug": "func serializeChannelCloseSummary(",
      "content": "func serializeChannelCloseSummary(\n\tw io.Writer,\n\tcs *channeldb.ChannelCloseSummary) error {\n\n\terr := channeldb.WriteElements(\n\t\tw,\n\t\tcs.ChanPoint, cs.ShortChanID, cs.ChainHash, cs.ClosingTXID,\n\t\tcs.CloseHeight, cs.RemotePub, cs.Capacity, cs.SettledBalance,\n\t\tcs.TimeLockedBalance, cs.CloseType, cs.IsPending,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// If this is a close channel summary created before the addition of\n\t// the new fields, then we can exit here.\n\tif cs.RemoteCurrentRevocation == nil {\n\t\treturn channeldb.WriteElements(w, false)\n\t}\n\n\treturn nil\n}\n",
      "length": 505,
      "tokens": 64,
      "embedding": []
    }
  ]
}