{
  "filepath": "../implementations/go/lnd/htlcswitch/circuit_test.go",
  "package": "htlcswitch_test",
  "sections": [
    {
      "slug": "func init() {",
      "content": "func init() {\n\t// Generate a fresh key for our sphinx router.\n\tvar err error\n\tsphinxPrivKey, err = btcec.NewPrivateKey()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// And another, whose public key will serve as the test ephemeral key.\n\ttestEphemeralPriv, err := btcec.NewPrivateKey()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\ttestEphemeralKey = testEphemeralPriv.PubKey()\n\n\t// Finally, properly initialize the test extracter\n\tinitTestExtracter()\n}\n\n// initTestExtracter spins up a new onion processor specifically for the purpose\n// of generating our testExtracter, which should be derived from the\n// testEphemeralKey, and which randomly-generated key is used to init the sphinx\n// router.\n//\n// NOTE: This should be called in init(), after testEphemeralKey has been\n// properly initialized.",
      "length": 738,
      "tokens": 112,
      "embedding": []
    },
    {
      "slug": "func initTestExtracter() {",
      "content": "func initTestExtracter() {\n\tonionProcessor := newOnionProcessor(nil)\n\tdefer onionProcessor.Stop()\n\n\tobfuscator, _ := onionProcessor.ExtractErrorEncrypter(\n\t\ttestEphemeralKey,\n\t)\n\n\tsphinxExtracter, ok := obfuscator.(*hop.SphinxErrorEncrypter)\n\tif !ok {\n\t\tpanic(\"did not extract sphinx error encrypter\")\n\t}\n\n\ttestExtracter = sphinxExtracter\n\n\t// We also set this error extracter on startup, otherwise it will be nil\n\t// at compile-time.\n\thalfCircuitTests[2].encrypter = testExtracter\n}\n\n// newOnionProcessor creates starts a new htlcswitch.OnionProcessor using a temp\n// db and no garbage collection.",
      "length": 551,
      "tokens": 65,
      "embedding": []
    },
    {
      "slug": "func newOnionProcessor(t *testing.T) *hop.OnionProcessor {",
      "content": "func newOnionProcessor(t *testing.T) *hop.OnionProcessor {\n\tsphinxRouter := sphinx.NewRouter(\n\t\t&keychain.PrivKeyECDH{PrivKey: sphinxPrivKey},\n\t\t&bitcoinCfg.SimNetParams, sphinx.NewMemoryReplayLog(),\n\t)\n\n\tif err := sphinxRouter.Start(); err != nil {\n\t\tt.Fatalf(\"unable to start sphinx router: %v\", err)\n\t}\n\n\treturn hop.NewOnionProcessor(sphinxRouter)\n}\n\n// newCircuitMap creates a new htlcswitch.CircuitMap using a temp db and a\n// fresh sphinx router. When resMsg is set to true, CheckResolutionMsg will\n// always return nil. Otherwise it will always return an error.",
      "length": 495,
      "tokens": 62,
      "embedding": []
    },
    {
      "slug": "func newCircuitMap(t *testing.T, resMsg bool) (*htlcswitch.CircuitMapConfig,",
      "content": "func newCircuitMap(t *testing.T, resMsg bool) (*htlcswitch.CircuitMapConfig,\n\thtlcswitch.CircuitMap) {\n\n\tonionProcessor := newOnionProcessor(t)\n\n\tdb := makeCircuitDB(t, \"\")\n\tcircuitMapCfg := &htlcswitch.CircuitMapConfig{\n\t\tDB:                    db,\n\t\tFetchAllOpenChannels:  db.ChannelStateDB().FetchAllOpenChannels,\n\t\tFetchClosedChannels:   db.ChannelStateDB().FetchClosedChannels,\n\t\tExtractErrorEncrypter: onionProcessor.ExtractErrorEncrypter,\n\t}\n\n\tif resMsg {\n\t\tcheckRes := func(out *htlcswitch.CircuitKey) error {\n\t\t\treturn nil\n\t\t}\n\t\tcircuitMapCfg.CheckResolutionMsg = checkRes\n\t} else {\n\t\tcheckRes := func(out *htlcswitch.CircuitKey) error {\n\t\t\treturn fmt.Errorf(\"not found\")\n\t\t}\n\t\tcircuitMapCfg.CheckResolutionMsg = checkRes\n\t}\n\n\tcircuitMap, err := htlcswitch.NewCircuitMap(circuitMapCfg)\n\trequire.NoError(t, err, \"unable to create persistent circuit map\")\n\n\treturn circuitMapCfg, circuitMap\n}\n\n// TestCircuitMapInit is a quick check to ensure that we can start and restore\n// the circuit map, as this will be used extensively in this suite.",
      "length": 939,
      "tokens": 96,
      "embedding": []
    },
    {
      "slug": "func TestCircuitMapInit(t *testing.T) {",
      "content": "func TestCircuitMapInit(t *testing.T) {\n\tt.Parallel()\n\n\tcfg, _ := newCircuitMap(t, false)\n\trestartCircuitMap(t, cfg)\n}\n\nvar halfCircuitTests = []struct {\n\thash      [32]byte\n\tinValue   btcutil.Amount\n\toutValue  btcutil.Amount\n\tchanID    lnwire.ShortChannelID\n\thtlcID    uint64\n\tencrypter hop.ErrorEncrypter\n}{\n\t{\n\t\thash:      hash1,\n\t\tinValue:   0,\n\t\toutValue:  1000,\n\t\tchanID:    lnwire.NewShortChanIDFromInt(1),\n\t\thtlcID:    1,\n\t\tencrypter: nil,\n\t},\n\t{\n\t\thash:      hash2,\n\t\tinValue:   2100,\n\t\toutValue:  2000,\n\t\tchanID:    lnwire.NewShortChanIDFromInt(2),\n\t\thtlcID:    2,\n\t\tencrypter: htlcswitch.NewMockObfuscator(),\n\t},\n\t{\n\t\thash:     hash3,\n\t\tinValue:  10000,\n\t\toutValue: 9000,\n\t\tchanID:   lnwire.NewShortChanIDFromInt(3),\n\t\thtlcID:   3,\n\t\t// NOTE: The value of testExtracter is nil at compile-time, it\n\t\t// is fully-initialized in initTestExtracter, which should\n\t\t// repopulate this encrypter.\n\t\tencrypter: testExtracter,\n\t},\n}\n\n// TestHalfCircuitSerialization checks that the half circuits can be properly\n// encoded and decoded properly. A critical responsibility of this test is to\n// verify that the various ErrorEncrypter implementations can be properly\n// reconstructed from a serialized half circuit.",
      "length": 1128,
      "tokens": 132,
      "embedding": []
    },
    {
      "slug": "func TestHalfCircuitSerialization(t *testing.T) {",
      "content": "func TestHalfCircuitSerialization(t *testing.T) {\n\tt.Parallel()\n\n\tonionProcessor := newOnionProcessor(t)\n\n\tfor i, test := range halfCircuitTests {\n\t\tcircuit := &htlcswitch.PaymentCircuit{\n\t\t\tPaymentHash:    test.hash,\n\t\t\tIncomingAmount: lnwire.NewMSatFromSatoshis(test.inValue),\n\t\t\tOutgoingAmount: lnwire.NewMSatFromSatoshis(test.outValue),\n\t\t\tIncoming: htlcswitch.CircuitKey{\n\t\t\t\tChanID: test.chanID,\n\t\t\t\tHtlcID: test.htlcID,\n\t\t\t},\n\t\t\tErrorEncrypter: test.encrypter,\n\t\t}\n\n\t\t// Write the half circuit to our buffer.\n\t\tvar b bytes.Buffer\n\t\tif err := circuit.Encode(&b); err != nil {\n\t\t\tt.Fatalf(\"unable to encode half payment circuit test=%d: %v\", i, err)\n\t\t}\n\n\t\t// Then try to decode the serialized bytes.\n\t\tvar circuit2 htlcswitch.PaymentCircuit\n\t\tcircuitReader := bytes.NewReader(b.Bytes())\n\t\tif err := circuit2.Decode(circuitReader); err != nil {\n\t\t\tt.Fatalf(\"unable to decode half payment circuit test=%d: %v\", i, err)\n\t\t}\n\n\t\t// If the error encrypter is initialized, we will need to\n\t\t// reextract it from it's decoded state, as this requires an\n\t\t// ECDH with the onion processor's private key. For mock error\n\t\t// encrypters, this will be a NOP.\n\t\tif circuit2.ErrorEncrypter != nil {\n\t\t\terr := circuit2.ErrorEncrypter.Reextract(\n\t\t\t\tonionProcessor.ExtractErrorEncrypter,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to reextract sphinx error \"+\n\t\t\t\t\t\"encrypter: %v\", err)\n\t\t\t}\n\t\t}\n\n\t\t// Reconstructed half circuit should match the original.\n\t\tif !equalIgnoreLFD(circuit, &circuit2) {\n\t\t\tt.Fatalf(\"unexpected half circuit test=%d, want %v, got %v\",\n\t\t\t\ti, circuit, circuit2)\n\t\t}\n\t}\n}\n",
      "length": 1490,
      "tokens": 185,
      "embedding": []
    },
    {
      "slug": "func TestCircuitMapPersistence(t *testing.T) {",
      "content": "func TestCircuitMapPersistence(t *testing.T) {\n\tt.Parallel()\n\n\tvar (\n\t\tchan1      = lnwire.NewShortChanIDFromInt(1)\n\t\tchan2      = lnwire.NewShortChanIDFromInt(2)\n\t\tcircuitMap htlcswitch.CircuitMap\n\t\terr        error\n\t)\n\n\tcfg, circuitMap := newCircuitMap(t, false)\n\n\tcircuit := circuitMap.LookupCircuit(htlcswitch.CircuitKey{\n\t\tChanID: chan1,\n\t\tHtlcID: 0,\n\t})\n\tif circuit != nil {\n\t\tt.Fatalf(\"LookupByHTLC returned a circuit before any were added: %v\",\n\t\t\tcircuit)\n\t}\n\n\tcircuit1 := &htlcswitch.PaymentCircuit{\n\t\tIncoming: htlcswitch.CircuitKey{\n\t\t\tChanID: chan2,\n\t\t\tHtlcID: 1,\n\t\t},\n\t\tPaymentHash:    hash1,\n\t\tErrorEncrypter: htlcswitch.NewMockObfuscator(),\n\t}\n\tif _, err := circuitMap.CommitCircuits(circuit1); err != nil {\n\t\tt.Fatalf(\"unable to add half circuit: %v\", err)\n\t}\n\n\t// Circuit map should have one circuit that has not been fully opened.\n\tassertNumCircuitsWithHash(t, circuitMap, hash1, 0)\n\tassertHasCircuit(t, circuitMap, circuit1)\n\n\tcfg, circuitMap = restartCircuitMap(t, cfg)\n\n\tassertNumCircuitsWithHash(t, circuitMap, hash1, 0)\n\tassertHasCircuit(t, circuitMap, circuit1)\n\n\t// Add multiple circuits with same destination channel but different HTLC\n\t// IDs and payment hashes.\n\tkeystone1 := htlcswitch.Keystone{\n\t\tInKey: circuit1.Incoming,\n\t\tOutKey: htlcswitch.CircuitKey{\n\t\t\tChanID: chan1,\n\t\t\tHtlcID: 0,\n\t\t},\n\t}\n\tcircuit1.Outgoing = &keystone1.OutKey\n\tif err := circuitMap.OpenCircuits(keystone1); err != nil {\n\t\tt.Fatalf(\"unable to add full circuit: %v\", err)\n\t}\n\n\t// Circuit map should reflect addition of circuit1, and the change\n\t// should survive a restart.\n\tassertNumCircuitsWithHash(t, circuitMap, hash1, 1)\n\tassertHasCircuit(t, circuitMap, circuit1)\n\tassertHasKeystone(t, circuitMap, keystone1.OutKey, circuit1)\n\n\tcfg, circuitMap = restartCircuitMap(t, cfg)\n\n\tassertNumCircuitsWithHash(t, circuitMap, hash1, 1)\n\tassertHasCircuit(t, circuitMap, circuit1)\n\tassertHasKeystone(t, circuitMap, keystone1.OutKey, circuit1)\n\n\tcircuit2 := &htlcswitch.PaymentCircuit{\n\t\tIncoming: htlcswitch.CircuitKey{\n\t\t\tChanID: chan2,\n\t\t\tHtlcID: 2,\n\t\t},\n\t\tPaymentHash:    hash2,\n\t\tErrorEncrypter: htlcswitch.NewMockObfuscator(),\n\t}\n\tif _, err := circuitMap.CommitCircuits(circuit2); err != nil {\n\t\tt.Fatalf(\"unable to add half circuit: %v\", err)\n\t}\n\n\tassertHasCircuit(t, circuitMap, circuit2)\n\n\tkeystone2 := htlcswitch.Keystone{\n\t\tInKey: circuit2.Incoming,\n\t\tOutKey: htlcswitch.CircuitKey{\n\t\t\tChanID: chan1,\n\t\t\tHtlcID: 1,\n\t\t},\n\t}\n\tcircuit2.Outgoing = &keystone2.OutKey\n\tif err := circuitMap.OpenCircuits(keystone2); err != nil {\n\t\tt.Fatalf(\"unable to add full circuit: %v\", err)\n\t}\n\n\t// Should have two full circuits, one under hash1 and another under\n\t// hash2. Both half payment circuits should have been removed when the\n\t// full circuits were added.\n\tassertNumCircuitsWithHash(t, circuitMap, hash1, 1)\n\tassertHasCircuit(t, circuitMap, circuit1)\n\tassertHasKeystone(t, circuitMap, keystone1.OutKey, circuit1)\n\n\tassertNumCircuitsWithHash(t, circuitMap, hash2, 1)\n\tassertHasCircuit(t, circuitMap, circuit2)\n\tassertHasKeystone(t, circuitMap, keystone2.OutKey, circuit2)\n\n\tassertNumCircuitsWithHash(t, circuitMap, hash3, 0)\n\n\tcfg, circuitMap = restartCircuitMap(t, cfg)\n\n\tassertNumCircuitsWithHash(t, circuitMap, hash1, 1)\n\tassertHasCircuit(t, circuitMap, circuit1)\n\tassertHasKeystone(t, circuitMap, keystone1.OutKey, circuit1)\n\n\tassertNumCircuitsWithHash(t, circuitMap, hash2, 1)\n\tassertHasCircuit(t, circuitMap, circuit2)\n\tassertHasKeystone(t, circuitMap, keystone2.OutKey, circuit2)\n\n\tassertNumCircuitsWithHash(t, circuitMap, hash3, 0)\n\n\tcircuit3 := &htlcswitch.PaymentCircuit{\n\t\tIncoming: htlcswitch.CircuitKey{\n\t\t\tChanID: chan1,\n\t\t\tHtlcID: 2,\n\t\t},\n\t\tPaymentHash:    hash3,\n\t\tErrorEncrypter: htlcswitch.NewMockObfuscator(),\n\t}\n\tif _, err := circuitMap.CommitCircuits(circuit3); err != nil {\n\t\tt.Fatalf(\"unable to add half circuit: %v\", err)\n\t}\n\n\tassertHasCircuit(t, circuitMap, circuit3)\n\tcfg, circuitMap = restartCircuitMap(t, cfg)\n\tassertHasCircuit(t, circuitMap, circuit3)\n\n\t// Add another circuit with an already-used HTLC ID but different\n\t// destination channel.\n\tkeystone3 := htlcswitch.Keystone{\n\t\tInKey: circuit3.Incoming,\n\t\tOutKey: htlcswitch.CircuitKey{\n\t\t\tChanID: chan2,\n\t\t\tHtlcID: 0,\n\t\t},\n\t}\n\tcircuit3.Outgoing = &keystone3.OutKey\n\tif err := circuitMap.OpenCircuits(keystone3); err != nil {\n\t\tt.Fatalf(\"unable to add full circuit: %v\", err)\n\t}\n\n\t// Check that all have been marked as full circuits, and that no half\n\t// circuits are currently being tracked.\n\tassertHasKeystone(t, circuitMap, keystone1.OutKey, circuit1)\n\tassertHasKeystone(t, circuitMap, keystone2.OutKey, circuit2)\n\tassertHasKeystone(t, circuitMap, keystone3.OutKey, circuit3)\n\tcfg, circuitMap = restartCircuitMap(t, cfg)\n\tassertHasKeystone(t, circuitMap, keystone1.OutKey, circuit1)\n\tassertHasKeystone(t, circuitMap, keystone2.OutKey, circuit2)\n\tassertHasKeystone(t, circuitMap, keystone3.OutKey, circuit3)\n\n\t// Even though a circuit was added with chan1, HTLC ID 2 as the source,\n\t// the lookup should go by destination channel, HTLC ID.\n\tinvalidKeystone := htlcswitch.CircuitKey{\n\t\tChanID: chan1,\n\t\tHtlcID: 2,\n\t}\n\tcircuit = circuitMap.LookupOpenCircuit(invalidKeystone)\n\tif circuit != nil {\n\t\tt.Fatalf(\"LookupByHTLC returned a circuit without being added: %v\",\n\t\t\tcircuit)\n\t}\n\n\tcircuit4 := &htlcswitch.PaymentCircuit{\n\t\tIncoming: htlcswitch.CircuitKey{\n\t\t\tChanID: chan2,\n\t\t\tHtlcID: 3,\n\t\t},\n\t\tPaymentHash:    hash1,\n\t\tErrorEncrypter: htlcswitch.NewMockObfuscator(),\n\t}\n\tif _, err := circuitMap.CommitCircuits(circuit4); err != nil {\n\t\tt.Fatalf(\"unable to add half circuit: %v\", err)\n\t}\n\n\t// Circuit map should still only show one circuit with hash1, since we\n\t// have not set the keystone for circuit4.\n\tassertNumCircuitsWithHash(t, circuitMap, hash1, 1)\n\tassertHasCircuit(t, circuitMap, circuit4)\n\n\tcfg, circuitMap = restartCircuitMap(t, cfg)\n\n\tassertNumCircuitsWithHash(t, circuitMap, hash1, 1)\n\tassertHasCircuit(t, circuitMap, circuit4)\n\n\t// Add a circuit with a destination channel and payment hash that are\n\t// already added but a different HTLC ID.\n\tkeystone4 := htlcswitch.Keystone{\n\t\tInKey: circuit4.Incoming,\n\t\tOutKey: htlcswitch.CircuitKey{\n\t\t\tChanID: chan1,\n\t\t\tHtlcID: 3,\n\t\t},\n\t}\n\tcircuit4.Outgoing = &keystone4.OutKey\n\tif err := circuitMap.OpenCircuits(keystone4); err != nil {\n\t\tt.Fatalf(\"unable to add full circuit: %v\", err)\n\t}\n\n\t// Verify that all circuits have been fully added.\n\tassertHasCircuit(t, circuitMap, circuit1)\n\tassertHasKeystone(t, circuitMap, keystone1.OutKey, circuit1)\n\tassertHasCircuit(t, circuitMap, circuit2)\n\tassertHasKeystone(t, circuitMap, keystone2.OutKey, circuit2)\n\tassertHasCircuit(t, circuitMap, circuit3)\n\tassertHasKeystone(t, circuitMap, keystone3.OutKey, circuit3)\n\tassertHasCircuit(t, circuitMap, circuit4)\n\tassertHasKeystone(t, circuitMap, keystone4.OutKey, circuit4)\n\n\t// Verify that each circuit is exposed via the proper hash bucketing.\n\tassertNumCircuitsWithHash(t, circuitMap, hash1, 2)\n\tassertHasCircuitForHash(t, circuitMap, hash1, circuit1)\n\tassertHasCircuitForHash(t, circuitMap, hash1, circuit4)\n\n\tassertNumCircuitsWithHash(t, circuitMap, hash2, 1)\n\tassertHasCircuitForHash(t, circuitMap, hash2, circuit2)\n\n\tassertNumCircuitsWithHash(t, circuitMap, hash3, 1)\n\tassertHasCircuitForHash(t, circuitMap, hash3, circuit3)\n\n\t// Restart, then run checks again.\n\tcfg, circuitMap = restartCircuitMap(t, cfg)\n\n\t// Verify that all circuits have been fully added.\n\tassertHasCircuit(t, circuitMap, circuit1)\n\tassertHasKeystone(t, circuitMap, keystone1.OutKey, circuit1)\n\tassertHasCircuit(t, circuitMap, circuit2)\n\tassertHasKeystone(t, circuitMap, keystone2.OutKey, circuit2)\n\tassertHasCircuit(t, circuitMap, circuit3)\n\tassertHasKeystone(t, circuitMap, keystone3.OutKey, circuit3)\n\tassertHasCircuit(t, circuitMap, circuit4)\n\tassertHasKeystone(t, circuitMap, keystone4.OutKey, circuit4)\n\n\t// Verify that each circuit is exposed via the proper hash bucketing.\n\tassertNumCircuitsWithHash(t, circuitMap, hash1, 2)\n\tassertHasCircuitForHash(t, circuitMap, hash1, circuit1)\n\tassertHasCircuitForHash(t, circuitMap, hash1, circuit4)\n\n\tassertNumCircuitsWithHash(t, circuitMap, hash2, 1)\n\tassertHasCircuitForHash(t, circuitMap, hash2, circuit2)\n\n\tassertNumCircuitsWithHash(t, circuitMap, hash3, 1)\n\tassertHasCircuitForHash(t, circuitMap, hash3, circuit3)\n\n\t// Test removing circuits and the subsequent lookups.\n\terr = circuitMap.DeleteCircuits(circuit1.Incoming)\n\trequire.NoError(t, err, \"Remove returned unexpected error\")\n\n\t// There should be exactly one remaining circuit with hash1, and it\n\t// should be circuit4.\n\tassertNumCircuitsWithHash(t, circuitMap, hash1, 1)\n\tassertHasCircuitForHash(t, circuitMap, hash1, circuit4)\n\tcfg, circuitMap = restartCircuitMap(t, cfg)\n\tassertNumCircuitsWithHash(t, circuitMap, hash1, 1)\n\tassertHasCircuitForHash(t, circuitMap, hash1, circuit4)\n\n\t// Removing already-removed circuit should return an error.\n\terr = circuitMap.DeleteCircuits(circuit1.Incoming)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected failure when deleting already \"+\n\t\t\t\"deleted circuit: %v\", err)\n\t}\n\n\t// Verify that nothing related to hash1 has changed\n\tassertNumCircuitsWithHash(t, circuitMap, hash1, 1)\n\tassertHasCircuitForHash(t, circuitMap, hash1, circuit4)\n\n\t// Remove last remaining circuit with payment hash hash1.\n\terr = circuitMap.DeleteCircuits(circuit4.Incoming)\n\trequire.NoError(t, err, \"Remove returned unexpected error\")\n\n\tassertNumCircuitsWithHash(t, circuitMap, hash1, 0)\n\tassertNumCircuitsWithHash(t, circuitMap, hash2, 1)\n\tassertNumCircuitsWithHash(t, circuitMap, hash3, 1)\n\tcfg, circuitMap = restartCircuitMap(t, cfg)\n\tassertNumCircuitsWithHash(t, circuitMap, hash1, 0)\n\tassertNumCircuitsWithHash(t, circuitMap, hash2, 1)\n\tassertNumCircuitsWithHash(t, circuitMap, hash3, 1)\n\n\t// Remove last remaining circuit with payment hash hash2.\n\terr = circuitMap.DeleteCircuits(circuit2.Incoming)\n\trequire.NoError(t, err, \"Remove returned unexpected error\")\n\n\t// There should now only be one remaining circuit, with hash3.\n\tassertNumCircuitsWithHash(t, circuitMap, hash2, 0)\n\tassertNumCircuitsWithHash(t, circuitMap, hash3, 1)\n\tcfg, circuitMap = restartCircuitMap(t, cfg)\n\tassertNumCircuitsWithHash(t, circuitMap, hash2, 0)\n\tassertNumCircuitsWithHash(t, circuitMap, hash3, 1)\n\n\t// In removing the final circuit, we will try and remove all other known\n\t// circuits as well. Any circuits that are unknown to the circuit map\n\t// will be ignored, and only circuit 3 should be cause any change in the\n\t// state.\n\terr = circuitMap.DeleteCircuits(\n\t\tcircuit1.Incoming, circuit2.Incoming,\n\t\tcircuit3.Incoming, circuit4.Incoming,\n\t)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected failure when removing circuit while also \"+\n\t\t\t\"deleting already deleted circuits: %v\", err)\n\t}\n\n\t// Check that the circuit map is empty, even after restarting.\n\tassertNumCircuitsWithHash(t, circuitMap, hash3, 0)\n\t_, circuitMap = restartCircuitMap(t, cfg)\n\tassertNumCircuitsWithHash(t, circuitMap, hash3, 0)\n}\n\n// assertHasKeystone tests that the circuit map contains the provided payment\n// circuit.",
      "length": 10626,
      "tokens": 1135,
      "embedding": []
    },
    {
      "slug": "func assertHasKeystone(t *testing.T, cm htlcswitch.CircuitMap,",
      "content": "func assertHasKeystone(t *testing.T, cm htlcswitch.CircuitMap,\n\toutKey htlcswitch.CircuitKey, c *htlcswitch.PaymentCircuit) {\n\n\tcircuit := cm.LookupOpenCircuit(outKey)\n\tif !equalIgnoreLFD(circuit, c) {\n\t\tt.Fatalf(\"unexpected circuit, want: %v, got %v\", c, circuit)\n\t}\n}\n\n// assertHasCircuitForHash tests that the provided circuit appears in the list\n// of circuits for the given hash.",
      "length": 312,
      "tokens": 40,
      "embedding": []
    },
    {
      "slug": "func assertHasCircuitForHash(t *testing.T, cm htlcswitch.CircuitMap, hash [32]byte,",
      "content": "func assertHasCircuitForHash(t *testing.T, cm htlcswitch.CircuitMap, hash [32]byte,\n\tcircuit *htlcswitch.PaymentCircuit) {\n\n\tcircuits := cm.LookupByPaymentHash(hash)\n\tfor _, c := range circuits {\n\t\tif equalIgnoreLFD(c, circuit) {\n\t\t\treturn\n\t\t}\n\t}\n\n\tt.Fatalf(\"unable to find circuit: %v by hash: %v\", circuit, hash)\n}\n\n// assertNumCircuitsWithHash tests that the circuit has the right number of full\n// circuits, indexed by the given hash.",
      "length": 341,
      "tokens": 50,
      "embedding": []
    },
    {
      "slug": "func assertNumCircuitsWithHash(t *testing.T, cm htlcswitch.CircuitMap,",
      "content": "func assertNumCircuitsWithHash(t *testing.T, cm htlcswitch.CircuitMap,\n\thash [32]byte, expectedNum int) {\n\n\tcircuits := cm.LookupByPaymentHash(hash)\n\tif len(circuits) != expectedNum {\n\t\tt.Fatalf(\"LookupByPaymentHash returned wrong number of circuits for \"+\n\t\t\t\"hash=%v: expecected %d, got %d\", hash, expectedNum,\n\t\t\tlen(circuits))\n\t}\n}\n\n// assertHasCircuit queries the circuit map using the half-circuit's half\n// key, and fails if the returned half-circuit differs from the provided one.",
      "length": 406,
      "tokens": 54,
      "embedding": []
    },
    {
      "slug": "func assertHasCircuit(t *testing.T, cm htlcswitch.CircuitMap,",
      "content": "func assertHasCircuit(t *testing.T, cm htlcswitch.CircuitMap,\n\tc *htlcswitch.PaymentCircuit) {\n\n\tc2 := cm.LookupCircuit(c.Incoming)\n\tif !equalIgnoreLFD(c, c2) {\n\t\tt.Fatalf(\"expected circuit: %v, got %v\", c, c2)\n\t}\n}\n\n// equalIgnoreLFD compares two payment circuits, but ignores the current value\n// of LoadedFromDisk. The value is temporarily set to false for the comparison\n// and then restored.",
      "length": 324,
      "tokens": 47,
      "embedding": []
    },
    {
      "slug": "func equalIgnoreLFD(c, c2 *htlcswitch.PaymentCircuit) bool {",
      "content": "func equalIgnoreLFD(c, c2 *htlcswitch.PaymentCircuit) bool {\n\togLFD := c.LoadedFromDisk\n\togLFD2 := c2.LoadedFromDisk\n\n\tc.LoadedFromDisk = false\n\tc2.LoadedFromDisk = false\n\n\tisEqual := reflect.DeepEqual(c, c2)\n\n\tc.LoadedFromDisk = ogLFD\n\tc2.LoadedFromDisk = ogLFD2\n\n\treturn isEqual\n}\n\n// makeCircuitDB initializes a new test channeldb for testing the persistence of\n// the circuit map. If an empty string is provided as a path, a temp directory\n// will be created.",
      "length": 386,
      "tokens": 57,
      "embedding": []
    },
    {
      "slug": "func makeCircuitDB(t *testing.T, path string) *channeldb.DB {",
      "content": "func makeCircuitDB(t *testing.T, path string) *channeldb.DB {\n\tif path == \"\" {\n\t\tpath = t.TempDir()\n\t}\n\n\tdb, err := channeldb.Open(path)\n\trequire.NoError(t, err, \"unable to open channel db\")\n\tt.Cleanup(func() { db.Close() })\n\n\treturn db\n}\n\n// Creates a new circuit map, backed by a freshly opened channeldb. The existing\n// channeldb is closed in order to simulate a complete restart.",
      "length": 310,
      "tokens": 52,
      "embedding": []
    },
    {
      "slug": "func restartCircuitMap(t *testing.T, cfg *htlcswitch.CircuitMapConfig) (",
      "content": "func restartCircuitMap(t *testing.T, cfg *htlcswitch.CircuitMapConfig) (\n\t*htlcswitch.CircuitMapConfig, htlcswitch.CircuitMap) {\n\n\t// Record the current temp path and close current db. We know we have\n\t// a full channeldb.DB here since we created it just above.\n\tdbPath := cfg.DB.(*channeldb.DB).Path()\n\tcfg.DB.Close()\n\n\t// Reinitialize circuit map with same db path.\n\tdb := makeCircuitDB(t, dbPath)\n\tcfg2 := &htlcswitch.CircuitMapConfig{\n\t\tDB:                    db,\n\t\tFetchAllOpenChannels:  db.ChannelStateDB().FetchAllOpenChannels,\n\t\tFetchClosedChannels:   db.ChannelStateDB().FetchClosedChannels,\n\t\tExtractErrorEncrypter: cfg.ExtractErrorEncrypter,\n\t\tCheckResolutionMsg:    cfg.CheckResolutionMsg,\n\t}\n\tcm2, err := htlcswitch.NewCircuitMap(cfg2)\n\trequire.NoError(t, err, \"unable to recreate persistent circuit map\")\n\n\treturn cfg2, cm2\n}\n\n// TestCircuitMapCommitCircuits tests the following behavior of CommitCircuits:\n// 1. New circuits are successfully added.\n// 2. Duplicate circuits are dropped anytime before circuit map shutsdown.\n// 3. Duplicate circuits are failed anytime after circuit map restarts.",
      "length": 1012,
      "tokens": 111,
      "embedding": []
    },
    {
      "slug": "func TestCircuitMapCommitCircuits(t *testing.T) {",
      "content": "func TestCircuitMapCommitCircuits(t *testing.T) {\n\tt.Parallel()\n\n\tvar (\n\t\tchan1      = lnwire.NewShortChanIDFromInt(1)\n\t\tcircuitMap htlcswitch.CircuitMap\n\t\terr        error\n\t)\n\n\tcfg, circuitMap := newCircuitMap(t, false)\n\n\tcircuit := &htlcswitch.PaymentCircuit{\n\t\tIncoming: htlcswitch.CircuitKey{\n\t\t\tChanID: chan1,\n\t\t\tHtlcID: 3,\n\t\t},\n\t\tErrorEncrypter: testExtracter,\n\t}\n\n\t// First we will try to add an new circuit to the circuit map, this\n\t// should succeed.\n\tactions, err := circuitMap.CommitCircuits(circuit)\n\trequire.NoError(t, err, \"failed to commit circuits\")\n\tif len(actions.Drops) > 0 {\n\t\tt.Fatalf(\"new circuit should not have been dropped\")\n\t}\n\tif len(actions.Fails) > 0 {\n\t\tt.Fatalf(\"new circuit should not have failed\")\n\t}\n\tif len(actions.Adds) != 1 {\n\t\tt.Fatalf(\"only one circuit should have been added, found %d\",\n\t\t\tlen(actions.Adds))\n\t}\n\n\tcircuit2 := circuitMap.LookupCircuit(circuit.Incoming)\n\tif !reflect.DeepEqual(circuit, circuit2) {\n\t\tt.Fatalf(\"unexpected committed circuit: got %v, want %v\",\n\t\t\tcircuit2, circuit)\n\t}\n\n\t// Then we will try to readd the same circuit again, this should result\n\t// in the circuit being dropped. This can happen if the incoming link\n\t// flaps.\n\tactions, err = circuitMap.CommitCircuits(circuit)\n\trequire.NoError(t, err, \"failed to commit circuits\")\n\tif len(actions.Adds) > 0 {\n\t\tt.Fatalf(\"duplicate circuit should not have been added to circuit map\")\n\t}\n\tif len(actions.Fails) > 0 {\n\t\tt.Fatalf(\"duplicate circuit should not have failed\")\n\t}\n\tif len(actions.Drops) != 1 {\n\t\tt.Fatalf(\"only one circuit should have been dropped, found %d\",\n\t\t\tlen(actions.Drops))\n\t}\n\n\t// Finally, restart the circuit map, which will cause the added circuit\n\t// to be loaded from disk. Since the keystone was never set, subsequent\n\t// attempts to commit the circuit should cause the circuit map to\n\t// indicate that the HTLC should be failed back.\n\t_, circuitMap = restartCircuitMap(t, cfg)\n\n\tactions, err = circuitMap.CommitCircuits(circuit)\n\trequire.NoError(t, err, \"failed to commit circuits\")\n\tif len(actions.Adds) > 0 {\n\t\tt.Fatalf(\"duplicate circuit with incomplete forwarding \" +\n\t\t\t\"decision should not have been added to circuit map\")\n\t}\n\tif len(actions.Drops) > 0 {\n\t\tt.Fatalf(\"duplicate circuit with incomplete forwarding \" +\n\t\t\t\"decision should not have been dropped by circuit map\")\n\t}\n\tif len(actions.Fails) != 1 {\n\t\tt.Fatalf(\"only one duplicate circuit with incomplete \"+\n\t\t\t\"forwarding decision should have been failed, found: \"+\n\t\t\t\"%d\", len(actions.Fails))\n\t}\n\n\t// Lookup the committed circuit again, it should be identical apart from\n\t// the loaded from disk flag.\n\tcircuit2 = circuitMap.LookupCircuit(circuit.Incoming)\n\tif !equalIgnoreLFD(circuit, circuit2) {\n\t\tt.Fatalf(\"unexpected committed circuit: got %v, want %v\",\n\t\t\tcircuit2, circuit)\n\t}\n}\n\n// TestCircuitMapOpenCircuits checks that circuits are properly opened, and that\n// duplicate attempts to open a circuit will result in an error.",
      "length": 2804,
      "tokens": 384,
      "embedding": []
    },
    {
      "slug": "func TestCircuitMapOpenCircuits(t *testing.T) {",
      "content": "func TestCircuitMapOpenCircuits(t *testing.T) {\n\tt.Parallel()\n\n\tvar (\n\t\tchan1      = lnwire.NewShortChanIDFromInt(1)\n\t\tchan2      = lnwire.NewShortChanIDFromInt(2)\n\t\tcircuitMap htlcswitch.CircuitMap\n\t\terr        error\n\t)\n\n\tcfg, circuitMap := newCircuitMap(t, false)\n\n\tcircuit := &htlcswitch.PaymentCircuit{\n\t\tIncoming: htlcswitch.CircuitKey{\n\t\t\tChanID: chan1,\n\t\t\tHtlcID: 3,\n\t\t},\n\t\tErrorEncrypter: testExtracter,\n\t}\n\n\t// First we will try to add an new circuit to the circuit map, this\n\t// should succeed.\n\t_, err = circuitMap.CommitCircuits(circuit)\n\trequire.NoError(t, err, \"failed to commit circuits\")\n\n\tkeystone := htlcswitch.Keystone{\n\t\tInKey: circuit.Incoming,\n\t\tOutKey: htlcswitch.CircuitKey{\n\t\t\tChanID: chan2,\n\t\t\tHtlcID: 2,\n\t\t},\n\t}\n\n\t// Open the circuit for the first time.\n\terr = circuitMap.OpenCircuits(keystone)\n\trequire.NoError(t, err, \"failed to open circuits\")\n\n\t// Check that we can retrieve the open circuit if the circuit map before\n\t// the circuit map is restarted.\n\tcircuit2 := circuitMap.LookupOpenCircuit(keystone.OutKey)\n\tif !reflect.DeepEqual(circuit, circuit2) {\n\t\tt.Fatalf(\"unexpected open circuit: got %v, want %v\",\n\t\t\tcircuit2, circuit)\n\t}\n\n\tif !circuit2.HasKeystone() {\n\t\tt.Fatalf(\"open circuit should have keystone\")\n\t}\n\tif !reflect.DeepEqual(&keystone.OutKey, circuit2.Outgoing) {\n\t\tt.Fatalf(\"expected open circuit to have outgoing key: %v, found %v\",\n\t\t\t&keystone.OutKey, circuit2.Outgoing)\n\t}\n\n\t// Open the circuit for a second time, which should fail due to a\n\t// duplicate keystone\n\terr = circuitMap.OpenCircuits(keystone)\n\tif err != htlcswitch.ErrDuplicateKeystone {\n\t\tt.Fatalf(\"failed to open circuits: %v\", err)\n\t}\n\n\t// Then we will try to readd the same circuit again, this should result\n\t// in the circuit being dropped. This can happen if the incoming link\n\t// flaps OR the switch is entirely restarted and the outgoing link has\n\t// not received a response.\n\tactions, err := circuitMap.CommitCircuits(circuit)\n\trequire.NoError(t, err, \"failed to commit circuits\")\n\tif len(actions.Adds) > 0 {\n\t\tt.Fatalf(\"duplicate circuit should not have been added to circuit map\")\n\t}\n\tif len(actions.Fails) > 0 {\n\t\tt.Fatalf(\"duplicate circuit should not have failed\")\n\t}\n\tif len(actions.Drops) != 1 {\n\t\tt.Fatalf(\"only one circuit should have been dropped, found %d\",\n\t\t\tlen(actions.Drops))\n\t}\n\n\t// Now, restart the circuit map, which will cause the opened circuit to\n\t// be loaded from disk. Since we set the keystone on this circuit, it\n\t// should be restored as such in memory.\n\t//\n\t// NOTE: The channel db doesn't have any channel data, so no keystones\n\t// will be trimmed.\n\t_, circuitMap = restartCircuitMap(t, cfg)\n\n\t// Check that we can still query for the open circuit.\n\tcircuit2 = circuitMap.LookupOpenCircuit(keystone.OutKey)\n\tif !equalIgnoreLFD(circuit, circuit2) {\n\t\tt.Fatalf(\"unexpected open circuit: got %v, want %v\",\n\t\t\tcircuit2, circuit)\n\t}\n\n\t// Try to open the circuit again, we expect this to fail since the open\n\t// circuit was restored.\n\terr = circuitMap.OpenCircuits(keystone)\n\tif err != htlcswitch.ErrDuplicateKeystone {\n\t\tt.Fatalf(\"failed to open circuits: %v\", err)\n\t}\n\n\t// Lastly, with the circuit map restarted, try one more time to recommit\n\t// the open circuit. This should be dropped, and is expected to happen\n\t// if the incoming link flaps OR the switch is entirely restarted and\n\t// the outgoing link has not received a response.\n\tactions, err = circuitMap.CommitCircuits(circuit)\n\trequire.NoError(t, err, \"failed to commit circuits\")\n\tif len(actions.Adds) > 0 {\n\t\tt.Fatalf(\"duplicate circuit should not have been added to circuit map\")\n\t}\n\tif len(actions.Fails) > 0 {\n\t\tt.Fatalf(\"duplicate circuit should not have failed\")\n\t}\n\tif len(actions.Drops) != 1 {\n\t\tt.Fatalf(\"only one circuit should have been dropped, found %d\",\n\t\t\tlen(actions.Drops))\n\t}\n}\n",
      "length": 3643,
      "tokens": 507,
      "embedding": []
    },
    {
      "slug": "func assertCircuitsOpenedPreRestart(t *testing.T,",
      "content": "func assertCircuitsOpenedPreRestart(t *testing.T,\n\tcircuitMap htlcswitch.CircuitMap,\n\tcircuits []*htlcswitch.PaymentCircuit,\n\tkeystones []htlcswitch.Keystone) {\n\n\tfor i, circuit := range circuits {\n\t\tkeystone := keystones[i]\n\n\t\topenCircuit := circuitMap.LookupOpenCircuit(keystone.OutKey)\n\t\tif !reflect.DeepEqual(circuit, openCircuit) {\n\t\t\tt.Fatalf(\"unexpected open circuit %d: got %v, want %v\",\n\t\t\t\ti, openCircuit, circuit)\n\t\t}\n\n\t\tif !openCircuit.HasKeystone() {\n\t\t\tt.Fatalf(\"open circuit %d should have keystone\", i)\n\t\t}\n\t\tif !reflect.DeepEqual(&keystone.OutKey, openCircuit.Outgoing) {\n\t\t\tt.Fatalf(\"expected open circuit %d to have outgoing \"+\n\t\t\t\t\"key: %v, found %v\", i,\n\t\t\t\t&keystone.OutKey, openCircuit.Outgoing)\n\t\t}\n\t}\n}\n",
      "length": 655,
      "tokens": 69,
      "embedding": []
    },
    {
      "slug": "func assertCircuitsOpenedPostRestart(t *testing.T,",
      "content": "func assertCircuitsOpenedPostRestart(t *testing.T,\n\tcircuitMap htlcswitch.CircuitMap,\n\tcircuits []*htlcswitch.PaymentCircuit,\n\tkeystones []htlcswitch.Keystone) {\n\n\tfor i, circuit := range circuits {\n\t\tkeystone := keystones[i]\n\n\t\topenCircuit := circuitMap.LookupOpenCircuit(keystone.OutKey)\n\t\tif !equalIgnoreLFD(circuit, openCircuit) {\n\t\t\tt.Fatalf(\"unexpected open circuit %d: got %v, want %v\",\n\t\t\t\ti, openCircuit, circuit)\n\t\t}\n\n\t\tif !openCircuit.HasKeystone() {\n\t\t\tt.Fatalf(\"open circuit %d should have keystone\", i)\n\t\t}\n\t\tif !reflect.DeepEqual(&keystone.OutKey, openCircuit.Outgoing) {\n\t\t\tt.Fatalf(\"expected open circuit %d to have outgoing \"+\n\t\t\t\t\"key: %v, found %v\", i,\n\t\t\t\t&keystone.OutKey, openCircuit.Outgoing)\n\t\t}\n\t}\n}\n",
      "length": 652,
      "tokens": 69,
      "embedding": []
    },
    {
      "slug": "func assertCircuitsNotOpenedPreRestart(t *testing.T,",
      "content": "func assertCircuitsNotOpenedPreRestart(t *testing.T,\n\tcircuitMap htlcswitch.CircuitMap,\n\tcircuits []*htlcswitch.PaymentCircuit,\n\tkeystones []htlcswitch.Keystone,\n\toffset int) {\n\n\tfor i := range circuits {\n\t\tkeystone := keystones[i]\n\n\t\topenCircuit := circuitMap.LookupOpenCircuit(keystone.OutKey)\n\t\tif openCircuit != nil {\n\t\t\tt.Fatalf(\"expected circuit %d not to be open\",\n\t\t\t\toffset+i)\n\t\t}\n\n\t\tcircuit := circuitMap.LookupCircuit(keystone.InKey)\n\t\tif circuit == nil {\n\t\t\tt.Fatalf(\"expected to find unopened circuit %d\",\n\t\t\t\toffset+i)\n\t\t}\n\t\tif circuit.HasKeystone() {\n\t\t\tt.Fatalf(\"circuit %d should not have keystone\",\n\t\t\t\toffset+i)\n\t\t}\n\t}\n}\n\n// TestCircuitMapTrimOpenCircuits verifies that the circuit map properly removes\n// circuits from disk and the in-memory state when TrimOpenCircuits is used.\n// This test checks that a successful trim survives a restart, and that circuits\n// added before the restart can also be trimmed.",
      "length": 846,
      "tokens": 108,
      "embedding": []
    },
    {
      "slug": "func TestCircuitMapTrimOpenCircuits(t *testing.T) {",
      "content": "func TestCircuitMapTrimOpenCircuits(t *testing.T) {\n\tt.Parallel()\n\n\tvar (\n\t\tchan1      = lnwire.NewShortChanIDFromInt(1)\n\t\tchan2      = lnwire.NewShortChanIDFromInt(2)\n\t\tcircuitMap htlcswitch.CircuitMap\n\t\terr        error\n\t)\n\n\tcfg, circuitMap := newCircuitMap(t, false)\n\n\tconst nCircuits = 10\n\tconst firstTrimIndex = 7\n\tconst secondTrimIndex = 3\n\n\t// Create a list of all circuits that will be committed in the circuit\n\t// map. The incoming HtlcIDs are chosen so that there is overlap with\n\t// the outgoing HtlcIDs, but ensures that the test is not dependent on\n\t// them being equal.\n\tcircuits := make([]*htlcswitch.PaymentCircuit, nCircuits)\n\tfor i := range circuits {\n\t\tcircuits[i] = &htlcswitch.PaymentCircuit{\n\t\t\tIncoming: htlcswitch.CircuitKey{\n\t\t\t\tChanID: chan1,\n\t\t\t\tHtlcID: uint64(i + 3),\n\t\t\t},\n\t\t\tErrorEncrypter: htlcswitch.NewMockObfuscator(),\n\t\t}\n\t}\n\n\t// First we will try to add an new circuit to the circuit map, this\n\t// should succeed.\n\t_, err = circuitMap.CommitCircuits(circuits...)\n\trequire.NoError(t, err, \"failed to commit circuits\")\n\n\t// Now create a list of the keystones that we will use to preemptively\n\t// open the circuits. We set the index as the outgoing HtlcID to i\n\t// simplify the indexing logic of the test.\n\tkeystones := make([]htlcswitch.Keystone, nCircuits)\n\tfor i := range keystones {\n\t\tkeystones[i] = htlcswitch.Keystone{\n\t\t\tInKey: circuits[i].Incoming,\n\t\t\tOutKey: htlcswitch.CircuitKey{\n\t\t\t\tChanID: chan2,\n\t\t\t\tHtlcID: uint64(i),\n\t\t\t},\n\t\t}\n\t}\n\n\t// Open the circuits for the first time.\n\terr = circuitMap.OpenCircuits(keystones...)\n\trequire.NoError(t, err, \"failed to open circuits\")\n\n\t// Check that all circuits are marked open.\n\tassertCircuitsOpenedPreRestart(t, circuitMap, circuits, keystones)\n\n\t// Now trim up above outgoing htlcid `firstTrimIndex` (7). This should\n\t// leave the first 7 circuits open, and the rest should be reverted to\n\t// an unopened state.\n\terr = circuitMap.TrimOpenCircuits(chan2, firstTrimIndex)\n\tif err != nil {\n\t\tt.Fatalf(\"unable to trim circuits\")\n\t}\n\n\tassertCircuitsOpenedPreRestart(t,\n\t\tcircuitMap,\n\t\tcircuits[:firstTrimIndex],\n\t\tkeystones[:firstTrimIndex],\n\t)\n\n\tassertCircuitsNotOpenedPreRestart(\n\t\tt,\n\t\tcircuitMap,\n\t\tcircuits[firstTrimIndex:],\n\t\tkeystones[firstTrimIndex:],\n\t\tfirstTrimIndex,\n\t)\n\n\t// Restart the circuit map, verify that the trim is reflected on\n\t// startup.\n\tcfg, circuitMap = restartCircuitMap(t, cfg)\n\n\tassertCircuitsOpenedPostRestart(\n\t\tt,\n\t\tcircuitMap,\n\t\tcircuits[:firstTrimIndex],\n\t\tkeystones[:firstTrimIndex],\n\t)\n\n\tassertCircuitsNotOpenedPreRestart(\n\t\tt,\n\t\tcircuitMap,\n\t\tcircuits[firstTrimIndex:],\n\t\tkeystones[firstTrimIndex:],\n\t\tfirstTrimIndex,\n\t)\n\n\t// Now, trim above outgoing htlcid `secondTrimIndex` (3). Only the first\n\t// three circuits should be open, with any others being reverted back to\n\t// unopened.\n\terr = circuitMap.TrimOpenCircuits(chan2, secondTrimIndex)\n\tif err != nil {\n\t\tt.Fatalf(\"unable to trim circuits\")\n\t}\n\n\tassertCircuitsOpenedPostRestart(\n\t\tt,\n\t\tcircuitMap,\n\t\tcircuits[:secondTrimIndex],\n\t\tkeystones[:secondTrimIndex],\n\t)\n\n\tassertCircuitsNotOpenedPreRestart(\n\t\tt,\n\t\tcircuitMap,\n\t\tcircuits[secondTrimIndex:],\n\t\tkeystones[secondTrimIndex:],\n\t\tsecondTrimIndex,\n\t)\n\n\t// Restart the circuit map one last time to make sure the changes are\n\t// persisted.\n\t_, circuitMap = restartCircuitMap(t, cfg)\n\n\tassertCircuitsOpenedPostRestart(\n\t\tt,\n\t\tcircuitMap,\n\t\tcircuits[:secondTrimIndex],\n\t\tkeystones[:secondTrimIndex],\n\t)\n\n\tassertCircuitsNotOpenedPreRestart(\n\t\tt,\n\t\tcircuitMap,\n\t\tcircuits[secondTrimIndex:],\n\t\tkeystones[secondTrimIndex:],\n\t\tsecondTrimIndex,\n\t)\n}\n\n// TestCircuitMapCloseOpenCircuits asserts that the circuit map can properly\n// close open circuits, and that it allows at most one response to do so\n// successfully. It also checks that a circuit is reopened if the close was not\n// persisted via DeleteCircuits, and can again be closed.",
      "length": 3661,
      "tokens": 441,
      "embedding": []
    },
    {
      "slug": "func TestCircuitMapCloseOpenCircuits(t *testing.T) {",
      "content": "func TestCircuitMapCloseOpenCircuits(t *testing.T) {\n\tt.Parallel()\n\n\tvar (\n\t\tchan1      = lnwire.NewShortChanIDFromInt(1)\n\t\tchan2      = lnwire.NewShortChanIDFromInt(2)\n\t\tcircuitMap htlcswitch.CircuitMap\n\t\terr        error\n\t)\n\n\tcfg, circuitMap := newCircuitMap(t, false)\n\n\tcircuit := &htlcswitch.PaymentCircuit{\n\t\tIncoming: htlcswitch.CircuitKey{\n\t\t\tChanID: chan1,\n\t\t\tHtlcID: 3,\n\t\t},\n\t\tErrorEncrypter: &hop.SphinxErrorEncrypter{\n\t\t\tEphemeralKey: testEphemeralKey,\n\t\t},\n\t}\n\n\t// First we will try to add an new circuit to the circuit map, this\n\t// should succeed.\n\t_, err = circuitMap.CommitCircuits(circuit)\n\trequire.NoError(t, err, \"failed to commit circuits\")\n\n\tkeystone := htlcswitch.Keystone{\n\t\tInKey: circuit.Incoming,\n\t\tOutKey: htlcswitch.CircuitKey{\n\t\t\tChanID: chan2,\n\t\t\tHtlcID: 2,\n\t\t},\n\t}\n\n\t// Open the circuit for the first time.\n\terr = circuitMap.OpenCircuits(keystone)\n\trequire.NoError(t, err, \"failed to open circuits\")\n\n\t// Check that we can retrieve the open circuit if the circuit map before\n\t// the circuit map is restarted.\n\tcircuit2 := circuitMap.LookupOpenCircuit(keystone.OutKey)\n\tif !reflect.DeepEqual(circuit, circuit2) {\n\t\tt.Fatalf(\"unexpected open circuit: got %v, want %v\",\n\t\t\tcircuit2, circuit)\n\t}\n\n\t// Open the circuit for a second time, which should fail due to a\n\t// duplicate keystone\n\terr = circuitMap.OpenCircuits(keystone)\n\tif err != htlcswitch.ErrDuplicateKeystone {\n\t\tt.Fatalf(\"failed to open circuits: %v\", err)\n\t}\n\n\t// Close the open circuit for the first time, which should succeed.\n\t_, err = circuitMap.FailCircuit(circuit.Incoming)\n\tif err != nil {\n\t\tt.Fatalf(\"unable to close unopened circuit\")\n\t}\n\n\t// Closing the circuit a second time should result in a failure.\n\t_, err = circuitMap.FailCircuit(circuit.Incoming)\n\tif err != htlcswitch.ErrCircuitClosing {\n\t\tt.Fatalf(\"unable to close unopened circuit\")\n\t}\n\n\t// Now, restart the circuit map, which will cause the opened circuit to\n\t// be loaded from disk. Since we set the keystone on this circuit, it\n\t// should be restored as such in memory.\n\t//\n\t// NOTE: The channel db doesn't have any channel data, so no keystones\n\t// will be trimmed.\n\t_, circuitMap = restartCircuitMap(t, cfg)\n\n\t// Close the open circuit for the first time, which should succeed.\n\t_, err = circuitMap.FailCircuit(circuit.Incoming)\n\tif err != nil {\n\t\tt.Fatalf(\"unable to close unopened circuit\")\n\t}\n\n\t// Closing the circuit a second time should result in a failure.\n\t_, err = circuitMap.FailCircuit(circuit.Incoming)\n\tif err != htlcswitch.ErrCircuitClosing {\n\t\tt.Fatalf(\"unable to close unopened circuit\")\n\t}\n}\n\n// TestCircuitMapCloseUnopenedCircuit tests that closing an unopened circuit\n// allows at most semantics, and that the close is not persisted across\n// restarts.",
      "length": 2596,
      "tokens": 352,
      "embedding": []
    },
    {
      "slug": "func TestCircuitMapCloseUnopenedCircuit(t *testing.T) {",
      "content": "func TestCircuitMapCloseUnopenedCircuit(t *testing.T) {\n\tt.Parallel()\n\n\tvar (\n\t\tchan1      = lnwire.NewShortChanIDFromInt(1)\n\t\tcircuitMap htlcswitch.CircuitMap\n\t\terr        error\n\t)\n\n\tcfg, circuitMap := newCircuitMap(t, false)\n\n\tcircuit := &htlcswitch.PaymentCircuit{\n\t\tIncoming: htlcswitch.CircuitKey{\n\t\t\tChanID: chan1,\n\t\t\tHtlcID: 3,\n\t\t},\n\t\tErrorEncrypter: testExtracter,\n\t}\n\n\t// First we will try to add an new circuit to the circuit map, this\n\t// should succeed.\n\t_, err = circuitMap.CommitCircuits(circuit)\n\trequire.NoError(t, err, \"failed to commit circuits\")\n\n\t// Close the open circuit for the first time, which should succeed.\n\t_, err = circuitMap.FailCircuit(circuit.Incoming)\n\tif err != nil {\n\t\tt.Fatalf(\"unable to close unopened circuit\")\n\t}\n\n\t// Closing the circuit a second time should result in a failure.\n\t_, err = circuitMap.FailCircuit(circuit.Incoming)\n\tif err != htlcswitch.ErrCircuitClosing {\n\t\tt.Fatalf(\"unable to close unopened circuit\")\n\t}\n\n\t// Now, restart the circuit map, which will result in the circuit being\n\t// reopened, since no attempt to delete the circuit was made.\n\t_, circuitMap = restartCircuitMap(t, cfg)\n\n\t// Close the open circuit for the first time, which should succeed.\n\t_, err = circuitMap.FailCircuit(circuit.Incoming)\n\tif err != nil {\n\t\tt.Fatalf(\"unable to close unopened circuit\")\n\t}\n\n\t// Closing the circuit a second time should result in a failure.\n\t_, err = circuitMap.FailCircuit(circuit.Incoming)\n\tif err != htlcswitch.ErrCircuitClosing {\n\t\tt.Fatalf(\"unable to close unopened circuit\")\n\t}\n}\n\n// TestCircuitMapDeleteUnopenedCircuit checks that an unopened circuit can be\n// removed persistently from the circuit map.",
      "length": 1558,
      "tokens": 211,
      "embedding": []
    },
    {
      "slug": "func TestCircuitMapDeleteUnopenedCircuit(t *testing.T) {",
      "content": "func TestCircuitMapDeleteUnopenedCircuit(t *testing.T) {\n\tt.Parallel()\n\n\tvar (\n\t\tchan1      = lnwire.NewShortChanIDFromInt(1)\n\t\tcircuitMap htlcswitch.CircuitMap\n\t\terr        error\n\t)\n\n\tcfg, circuitMap := newCircuitMap(t, false)\n\n\tcircuit := &htlcswitch.PaymentCircuit{\n\t\tIncoming: htlcswitch.CircuitKey{\n\t\t\tChanID: chan1,\n\t\t\tHtlcID: 3,\n\t\t},\n\t\tErrorEncrypter: testExtracter,\n\t}\n\n\t// First we will try to add an new circuit to the circuit map, this\n\t// should succeed.\n\t_, err = circuitMap.CommitCircuits(circuit)\n\trequire.NoError(t, err, \"failed to commit circuits\")\n\n\t// Close the open circuit for the first time, which should succeed.\n\t_, err = circuitMap.FailCircuit(circuit.Incoming)\n\tif err != nil {\n\t\tt.Fatalf(\"unable to close unopened circuit\")\n\t}\n\n\terr = circuitMap.DeleteCircuits(circuit.Incoming)\n\tif err != nil {\n\t\tt.Fatalf(\"unable to close unopened circuit\")\n\t}\n\n\t// Check that we can retrieve the open circuit if the circuit map before\n\t// the circuit map is restarted.\n\tcircuit2 := circuitMap.LookupCircuit(circuit.Incoming)\n\tif circuit2 != nil {\n\t\tt.Fatalf(\"unexpected open circuit: got %v, want %v\",\n\t\t\tcircuit2, nil)\n\t}\n\n\t// Now, restart the circuit map, and check that the deletion survived\n\t// the restart.\n\t_, circuitMap = restartCircuitMap(t, cfg)\n\n\tcircuit2 = circuitMap.LookupCircuit(circuit.Incoming)\n\tif circuit2 != nil {\n\t\tt.Fatalf(\"unexpected open circuit: got %v, want %v\",\n\t\t\tcircuit2, nil)\n\t}\n}\n\n// TestCircuitMapDeleteOpenCircuit checks that an open circuit can be removed\n// persistently from the circuit map.",
      "length": 1429,
      "tokens": 191,
      "embedding": []
    },
    {
      "slug": "func TestCircuitMapDeleteOpenCircuit(t *testing.T) {",
      "content": "func TestCircuitMapDeleteOpenCircuit(t *testing.T) {\n\tt.Parallel()\n\n\tvar (\n\t\tchan1      = lnwire.NewShortChanIDFromInt(1)\n\t\tchan2      = lnwire.NewShortChanIDFromInt(2)\n\t\tcircuitMap htlcswitch.CircuitMap\n\t\terr        error\n\t)\n\n\tcfg, circuitMap := newCircuitMap(t, false)\n\n\tcircuit := &htlcswitch.PaymentCircuit{\n\t\tIncoming: htlcswitch.CircuitKey{\n\t\t\tChanID: chan1,\n\t\t\tHtlcID: 3,\n\t\t},\n\t\tErrorEncrypter: testExtracter,\n\t}\n\n\t// First we will try to add an new circuit to the circuit map, this\n\t// should succeed.\n\t_, err = circuitMap.CommitCircuits(circuit)\n\trequire.NoError(t, err, \"failed to commit circuits\")\n\n\tkeystone := htlcswitch.Keystone{\n\t\tInKey: circuit.Incoming,\n\t\tOutKey: htlcswitch.CircuitKey{\n\t\t\tChanID: chan2,\n\t\t\tHtlcID: 2,\n\t\t},\n\t}\n\n\t// Open the circuit for the first time.\n\terr = circuitMap.OpenCircuits(keystone)\n\trequire.NoError(t, err, \"failed to open circuits\")\n\n\t// Close the open circuit for the first time, which should succeed.\n\t_, err = circuitMap.FailCircuit(circuit.Incoming)\n\tif err != nil {\n\t\tt.Fatalf(\"unable to close unopened circuit\")\n\t}\n\n\t// Persistently remove the circuit identified by incoming chan id.\n\terr = circuitMap.DeleteCircuits(circuit.Incoming)\n\tif err != nil {\n\t\tt.Fatalf(\"unable to close unopened circuit\")\n\t}\n\n\t// Check that we can no longer retrieve the open circuit.\n\tcircuit2 := circuitMap.LookupOpenCircuit(keystone.OutKey)\n\tif circuit2 != nil {\n\t\tt.Fatalf(\"unexpected open circuit: got %v, want %v\",\n\t\t\tcircuit2, nil)\n\t}\n\n\t// Now, restart the circuit map, and check that the deletion survived\n\t// the restart.\n\t_, circuitMap = restartCircuitMap(t, cfg)\n\n\tcircuit2 = circuitMap.LookupOpenCircuit(keystone.OutKey)\n\tif circuit2 != nil {\n\t\tt.Fatalf(\"unexpected open circuit: got %v, want %v\",\n\t\t\tcircuit2, nil)\n\t}\n}\n",
      "length": 1644,
      "tokens": 209,
      "embedding": []
    }
  ]
}