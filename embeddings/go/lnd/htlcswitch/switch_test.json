{
  "filepath": "../implementations/go/lnd/htlcswitch/switch_test.go",
  "package": "htlcswitch",
  "sections": [
    {
      "slug": "func genPreimage() ([32]byte, error) {",
      "content": "func genPreimage() ([32]byte, error) {\n\tvar preimage [32]byte\n\tif _, err := io.ReadFull(rand.Reader, preimage[:]); err != nil {\n\t\treturn preimage, err\n\t}\n\treturn preimage, nil\n}\n\n// TestSwitchAddDuplicateLink tests that the switch will reject duplicate links\n// for live links. It also tests that we can successfully add a link after\n// having removed it.",
      "length": 307,
      "tokens": 50,
      "embedding": []
    },
    {
      "slug": "func TestSwitchAddDuplicateLink(t *testing.T) {",
      "content": "func TestSwitchAddDuplicateLink(t *testing.T) {\n\tt.Parallel()\n\n\talicePeer, err := newMockServer(\n\t\tt, \"alice\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err, \"unable to create alice server\")\n\n\ts, err := initSwitchWithTempDB(t, testStartingHeight)\n\trequire.NoError(t, err, \"unable to init switch\")\n\tif err := s.Start(); err != nil {\n\t\tt.Fatalf(\"unable to start switch: %v\", err)\n\t}\n\tdefer s.Stop()\n\n\tchanID1, aliceScid := genID()\n\n\taliceChannelLink := newMockChannelLink(\n\t\ts, chanID1, aliceScid, emptyScid, alicePeer, false, false,\n\t\tfalse, false,\n\t)\n\tif err := s.AddLink(aliceChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add alice link: %v\", err)\n\t}\n\n\t// Alice should have a live link, adding again should fail.\n\tif err := s.AddLink(aliceChannelLink); err == nil {\n\t\tt.Fatalf(\"adding duplicate link should have failed\")\n\t}\n\n\t// Remove the live link to ensure the indexes are cleared.\n\ts.RemoveLink(chanID1)\n\n\t// Alice has no links, adding should succeed.\n\tif err := s.AddLink(aliceChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add alice link: %v\", err)\n\t}\n}\n\n// TestSwitchHasActiveLink tests the behavior of HasActiveLink, and asserts that\n// it only returns true if a link's short channel id has confirmed (meaning the\n// channel is no longer pending) and it's EligibleToForward method returns true,\n// i.e. it has received FundingLocked from the remote peer.",
      "length": 1303,
      "tokens": 189,
      "embedding": []
    },
    {
      "slug": "func TestSwitchHasActiveLink(t *testing.T) {",
      "content": "func TestSwitchHasActiveLink(t *testing.T) {\n\tt.Parallel()\n\n\talicePeer, err := newMockServer(\n\t\tt, \"alice\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err, \"unable to create alice server\")\n\n\ts, err := initSwitchWithTempDB(t, testStartingHeight)\n\trequire.NoError(t, err, \"unable to init switch\")\n\tif err := s.Start(); err != nil {\n\t\tt.Fatalf(\"unable to start switch: %v\", err)\n\t}\n\tdefer s.Stop()\n\n\tchanID1, aliceScid := genID()\n\n\taliceChannelLink := newMockChannelLink(\n\t\ts, chanID1, aliceScid, emptyScid, alicePeer, false, false,\n\t\tfalse, false,\n\t)\n\tif err := s.AddLink(aliceChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add alice link: %v\", err)\n\t}\n\n\t// The link has been added, but it's still pending. HasActiveLink should\n\t// return false since the link has not been added to the linkIndex\n\t// containing live links.\n\tif s.HasActiveLink(chanID1) {\n\t\tt.Fatalf(\"link should not be active yet, still pending\")\n\t}\n\n\t// Finally, simulate the link receiving funding locked by setting its\n\t// eligibility to true.\n\taliceChannelLink.eligible = true\n\n\t// The link should now be reported as active, since EligibleToForward\n\t// returns true and the link is in the linkIndex.\n\tif !s.HasActiveLink(chanID1) {\n\t\tt.Fatalf(\"link should not be active now\")\n\t}\n}\n\n// TestSwitchSendPending checks the inability of htlc switch to forward adds\n// over pending links.",
      "length": 1286,
      "tokens": 185,
      "embedding": []
    },
    {
      "slug": "func TestSwitchSendPending(t *testing.T) {",
      "content": "func TestSwitchSendPending(t *testing.T) {\n\tt.Parallel()\n\n\talicePeer, err := newMockServer(\n\t\tt, \"alice\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err, \"unable to create alice server\")\n\n\tbobPeer, err := newMockServer(\n\t\tt, \"bob\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err, \"unable to create bob server\")\n\n\ts, err := initSwitchWithTempDB(t, testStartingHeight)\n\trequire.NoError(t, err, \"unable to init switch\")\n\tif err := s.Start(); err != nil {\n\t\tt.Fatalf(\"unable to start switch: %v\", err)\n\t}\n\tdefer s.Stop()\n\n\tchanID1, chanID2, aliceChanID, bobChanID := genIDs()\n\n\tpendingChanID := lnwire.ShortChannelID{}\n\n\taliceChannelLink := newMockChannelLink(\n\t\ts, chanID1, pendingChanID, emptyScid, alicePeer, false, false,\n\t\tfalse, false,\n\t)\n\tif err := s.AddLink(aliceChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add alice link: %v\", err)\n\t}\n\n\tbobChannelLink := newMockChannelLink(\n\t\ts, chanID2, bobChanID, emptyScid, bobPeer, true, false, false,\n\t\tfalse,\n\t)\n\tif err := s.AddLink(bobChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add bob link: %v\", err)\n\t}\n\n\t// Create request which should is being forwarded from Bob channel\n\t// link to Alice channel link.\n\tpreimage, err := genPreimage()\n\trequire.NoError(t, err, \"unable to generate preimage\")\n\trhash := sha256.Sum256(preimage[:])\n\tpacket := &htlcPacket{\n\t\tincomingChanID: bobChanID,\n\t\tincomingHTLCID: 0,\n\t\toutgoingChanID: aliceChanID,\n\t\tobfuscator:     NewMockObfuscator(),\n\t\thtlc: &lnwire.UpdateAddHTLC{\n\t\t\tPaymentHash: rhash,\n\t\t\tAmount:      1,\n\t\t},\n\t}\n\n\t// Send the ADD packet, this should not be forwarded out to the link\n\t// since there are no eligible links.\n\tif err = s.ForwardPackets(nil, packet); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tselect {\n\tcase p := <-bobChannelLink.packets:\n\t\tif p.linkFailure != nil {\n\t\t\terr = p.linkFailure\n\t\t}\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"no timely reply from switch\")\n\t}\n\tlinkErr, ok := err.(*LinkError)\n\tif !ok {\n\t\tt.Fatalf(\"expected link error, got: %T\", err)\n\t}\n\tif linkErr.WireMessage().Code() != lnwire.CodeUnknownNextPeer {\n\t\tt.Fatalf(\"expected fail unknown next peer, got: %T\",\n\t\t\tlinkErr.WireMessage().Code())\n\t}\n\n\t// No message should be sent, since the packet was failed.\n\tselect {\n\tcase <-aliceChannelLink.packets:\n\t\tt.Fatal(\"expected not to receive message\")\n\tcase <-time.After(time.Second):\n\t}\n\n\t// Since the packet should have been failed, there should be no active\n\t// circuits.\n\tif s.circuits.NumOpen() != 0 {\n\t\tt.Fatal(\"wrong amount of circuits\")\n\t}\n}\n\n// TestSwitchForwardMapping checks that the Switch properly consults its maps\n// when forwarding packets.",
      "length": 2489,
      "tokens": 325,
      "embedding": []
    },
    {
      "slug": "func TestSwitchForwardMapping(t *testing.T) {",
      "content": "func TestSwitchForwardMapping(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\n\t\t// If this is true, then Alice's channel will be private.\n\t\talicePrivate bool\n\n\t\t// If this is true, then Alice's channel will be a zero-conf\n\t\t// channel.\n\t\tzeroConf bool\n\n\t\t// If this is true, then Alice's channel will be an\n\t\t// option-scid-alias feature-bit, non-zero-conf channel.\n\t\toptionScid bool\n\n\t\t// If this is true, then an alias will be used for forwarding.\n\t\tuseAlias bool\n\n\t\t// This is Alice's channel alias. This may not be set if this\n\t\t// is not an option_scid_alias channel (feature bit).\n\t\taliceAlias lnwire.ShortChannelID\n\n\t\t// This is Alice's confirmed SCID. This may not be set if this\n\t\t// is a zero-conf channel before confirmation.\n\t\taliceReal lnwire.ShortChannelID\n\n\t\t// If this is set, we expect Bob forwarding to Alice to fail.\n\t\texpectErr bool\n\t}{\n\t\t{\n\t\t\tname:         \"private unconfirmed zero-conf\",\n\t\t\talicePrivate: true,\n\t\t\tzeroConf:     true,\n\t\t\tuseAlias:     true,\n\t\t\taliceAlias: lnwire.ShortChannelID{\n\t\t\t\tBlockHeight: 16_000_002,\n\t\t\t\tTxIndex:     2,\n\t\t\t\tTxPosition:  2,\n\t\t\t},\n\t\t\taliceReal: lnwire.ShortChannelID{},\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:         \"private confirmed zero-conf\",\n\t\t\talicePrivate: true,\n\t\t\tzeroConf:     true,\n\t\t\tuseAlias:     true,\n\t\t\taliceAlias: lnwire.ShortChannelID{\n\t\t\t\tBlockHeight: 16_000_003,\n\t\t\t\tTxIndex:     3,\n\t\t\t\tTxPosition:  3,\n\t\t\t},\n\t\t\taliceReal: lnwire.ShortChannelID{\n\t\t\t\tBlockHeight: 300000,\n\t\t\t\tTxIndex:     3,\n\t\t\t\tTxPosition:  3,\n\t\t\t},\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:         \"private confirmed zero-conf failure\",\n\t\t\talicePrivate: true,\n\t\t\tzeroConf:     true,\n\t\t\tuseAlias:     false,\n\t\t\taliceAlias: lnwire.ShortChannelID{\n\t\t\t\tBlockHeight: 16_000_004,\n\t\t\t\tTxIndex:     4,\n\t\t\t\tTxPosition:  4,\n\t\t\t},\n\t\t\taliceReal: lnwire.ShortChannelID{\n\t\t\t\tBlockHeight: 300002,\n\t\t\t\tTxIndex:     4,\n\t\t\t\tTxPosition:  4,\n\t\t\t},\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname:         \"public unconfirmed zero-conf\",\n\t\t\talicePrivate: false,\n\t\t\tzeroConf:     true,\n\t\t\tuseAlias:     true,\n\t\t\taliceAlias: lnwire.ShortChannelID{\n\t\t\t\tBlockHeight: 16_000_005,\n\t\t\t\tTxIndex:     5,\n\t\t\t\tTxPosition:  5,\n\t\t\t},\n\t\t\taliceReal: lnwire.ShortChannelID{},\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:         \"public confirmed zero-conf w/ alias\",\n\t\t\talicePrivate: false,\n\t\t\tzeroConf:     true,\n\t\t\tuseAlias:     true,\n\t\t\taliceAlias: lnwire.ShortChannelID{\n\t\t\t\tBlockHeight: 16_000_006,\n\t\t\t\tTxIndex:     6,\n\t\t\t\tTxPosition:  6,\n\t\t\t},\n\t\t\taliceReal: lnwire.ShortChannelID{\n\t\t\t\tBlockHeight: 500000,\n\t\t\t\tTxIndex:     6,\n\t\t\t\tTxPosition:  6,\n\t\t\t},\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:         \"public confirmed zero-conf w/ real\",\n\t\t\talicePrivate: false,\n\t\t\tzeroConf:     true,\n\t\t\tuseAlias:     false,\n\t\t\taliceAlias: lnwire.ShortChannelID{\n\t\t\t\tBlockHeight: 16_000_007,\n\t\t\t\tTxIndex:     7,\n\t\t\t\tTxPosition:  7,\n\t\t\t},\n\t\t\taliceReal: lnwire.ShortChannelID{\n\t\t\t\tBlockHeight: 502000,\n\t\t\t\tTxIndex:     7,\n\t\t\t\tTxPosition:  7,\n\t\t\t},\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:         \"private non-option channel\",\n\t\t\talicePrivate: true,\n\t\t\taliceAlias:   lnwire.ShortChannelID{},\n\t\t\taliceReal: lnwire.ShortChannelID{\n\t\t\t\tBlockHeight: 505000,\n\t\t\t\tTxIndex:     8,\n\t\t\t\tTxPosition:  8,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:         \"private option channel w/ alias\",\n\t\t\talicePrivate: true,\n\t\t\toptionScid:   true,\n\t\t\tuseAlias:     true,\n\t\t\taliceAlias: lnwire.ShortChannelID{\n\t\t\t\tBlockHeight: 16_000_015,\n\t\t\t\tTxIndex:     9,\n\t\t\t\tTxPosition:  9,\n\t\t\t},\n\t\t\taliceReal: lnwire.ShortChannelID{\n\t\t\t\tBlockHeight: 506000,\n\t\t\t\tTxIndex:     10,\n\t\t\t\tTxPosition:  10,\n\t\t\t},\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:         \"private option channel failure\",\n\t\t\talicePrivate: true,\n\t\t\toptionScid:   true,\n\t\t\tuseAlias:     false,\n\t\t\taliceAlias: lnwire.ShortChannelID{\n\t\t\t\tBlockHeight: 16_000_016,\n\t\t\t\tTxIndex:     16,\n\t\t\t\tTxPosition:  16,\n\t\t\t},\n\t\t\taliceReal: lnwire.ShortChannelID{\n\t\t\t\tBlockHeight: 507000,\n\t\t\t\tTxIndex:     17,\n\t\t\t\tTxPosition:  17,\n\t\t\t},\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname:         \"public non-option channel\",\n\t\t\talicePrivate: false,\n\t\t\tuseAlias:     false,\n\t\t\taliceAlias:   lnwire.ShortChannelID{},\n\t\t\taliceReal: lnwire.ShortChannelID{\n\t\t\t\tBlockHeight: 508000,\n\t\t\t\tTxIndex:     17,\n\t\t\t\tTxPosition:  17,\n\t\t\t},\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:         \"public option channel w/ alias\",\n\t\t\talicePrivate: false,\n\t\t\toptionScid:   true,\n\t\t\tuseAlias:     true,\n\t\t\taliceAlias: lnwire.ShortChannelID{\n\t\t\t\tBlockHeight: 16_000_018,\n\t\t\t\tTxIndex:     18,\n\t\t\t\tTxPosition:  18,\n\t\t\t},\n\t\t\taliceReal: lnwire.ShortChannelID{\n\t\t\t\tBlockHeight: 509000,\n\t\t\t\tTxIndex:     19,\n\t\t\t\tTxPosition:  19,\n\t\t\t},\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:         \"public option channel w/ real\",\n\t\t\talicePrivate: false,\n\t\t\toptionScid:   true,\n\t\t\tuseAlias:     false,\n\t\t\taliceAlias: lnwire.ShortChannelID{\n\t\t\t\tBlockHeight: 16_000_019,\n\t\t\t\tTxIndex:     19,\n\t\t\t\tTxPosition:  19,\n\t\t\t},\n\t\t\taliceReal: lnwire.ShortChannelID{\n\t\t\t\tBlockHeight: 510000,\n\t\t\t\tTxIndex:     20,\n\t\t\t\tTxPosition:  20,\n\t\t\t},\n\t\t\texpectErr: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\ttestSwitchForwardMapping(\n\t\t\t\tt, test.alicePrivate, test.zeroConf,\n\t\t\t\ttest.useAlias, test.optionScid,\n\t\t\t\ttest.aliceAlias, test.aliceReal,\n\t\t\t\ttest.expectErr,\n\t\t\t)\n\t\t})\n\t}\n}\n",
      "length": 4977,
      "tokens": 518,
      "embedding": []
    },
    {
      "slug": "func testSwitchForwardMapping(t *testing.T, alicePrivate, aliceZeroConf,",
      "content": "func testSwitchForwardMapping(t *testing.T, alicePrivate, aliceZeroConf,\n\tuseAlias, optionScid bool, aliceAlias, aliceReal lnwire.ShortChannelID,\n\texpectErr bool) {\n\n\talicePeer, err := newMockServer(\n\t\tt, \"alice\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err)\n\n\tbobPeer, err := newMockServer(\n\t\tt, \"bob\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err)\n\n\ts, err := initSwitchWithTempDB(t, testStartingHeight)\n\trequire.NoError(t, err)\n\terr = s.Start()\n\trequire.NoError(t, err)\n\tdefer func() { _ = s.Stop() }()\n\n\t// Create the lnwire.ChannelIDs that we'll use.\n\tchanID1, chanID2, _, _ := genIDs()\n\n\tvar aliceChannelLink *mockChannelLink\n\n\tif aliceZeroConf {\n\t\taliceChannelLink = newMockChannelLink(\n\t\t\ts, chanID1, aliceAlias, aliceReal, alicePeer, true,\n\t\t\talicePrivate, true, false,\n\t\t)\n\t} else {\n\t\taliceChannelLink = newMockChannelLink(\n\t\t\ts, chanID1, aliceReal, emptyScid, alicePeer, true,\n\t\t\talicePrivate, false, optionScid,\n\t\t)\n\n\t\tif optionScid {\n\t\t\taliceChannelLink.addAlias(aliceAlias)\n\t\t}\n\t}\n\n\terr = s.AddLink(aliceChannelLink)\n\trequire.NoError(t, err)\n\n\t// Bob will just have a non-option_scid_alias channel so no mapping is\n\t// necessary.\n\tbobScid := lnwire.ShortChannelID{\n\t\tBlockHeight: 501000,\n\t\tTxIndex:     200,\n\t\tTxPosition:  2,\n\t}\n\n\tbobChannelLink := newMockChannelLink(\n\t\ts, chanID2, bobScid, emptyScid, bobPeer, true, false, false,\n\t\tfalse,\n\t)\n\terr = s.AddLink(bobChannelLink)\n\trequire.NoError(t, err)\n\n\t// Generate preimage.\n\tpreimage, err := genPreimage()\n\trequire.NoError(t, err, \"unable to generate preimage\")\n\trhash := sha256.Sum256(preimage[:])\n\n\t// Determine the outgoing SCID to use.\n\toutgoingSCID := aliceReal\n\tif useAlias {\n\t\toutgoingSCID = aliceAlias\n\t}\n\n\tpacket := &htlcPacket{\n\t\tincomingChanID: bobScid,\n\t\tincomingHTLCID: 0,\n\t\toutgoingChanID: outgoingSCID,\n\t\tobfuscator:     NewMockObfuscator(),\n\t\thtlc: &lnwire.UpdateAddHTLC{\n\t\t\tPaymentHash: rhash,\n\t\t\tAmount:      1,\n\t\t},\n\t}\n\terr = s.ForwardPackets(nil, packet)\n\trequire.NoError(t, err)\n\n\t// If we expect a forwarding error, then assert that we receive one.\n\t// option_scid_alias forwards may fail if forwarding would be a privacy\n\t// leak.\n\tif expectErr {\n\t\tselect {\n\t\tcase <-bobChannelLink.packets:\n\t\tcase <-time.After(time.Second * 5):\n\t\t\tt.Fatal(\"expected a forwarding error\")\n\t\t}\n\n\t\tselect {\n\t\tcase <-aliceChannelLink.packets:\n\t\t\tt.Fatal(\"did not expect a packet\")\n\t\tcase <-time.After(time.Second * 5):\n\t\t}\n\t} else {\n\t\tselect {\n\t\tcase <-bobChannelLink.packets:\n\t\t\tt.Fatal(\"did not expect a forwarding error\")\n\t\tcase <-time.After(time.Second * 5):\n\t\t}\n\n\t\tselect {\n\t\tcase <-aliceChannelLink.packets:\n\t\tcase <-time.After(time.Second * 5):\n\t\t\tt.Fatal(\"expected alice to receive packet\")\n\t\t}\n\t}\n}\n\n// TestSwitchSendHTLCMapping tests that SendHTLC will properly route packets to\n// zero-conf or option-scid-alias (feature-bit) channels if the confirmed SCID\n// is used. It also tests that nothing breaks with the mapping change.",
      "length": 2770,
      "tokens": 334,
      "embedding": []
    },
    {
      "slug": "func TestSwitchSendHTLCMapping(t *testing.T) {",
      "content": "func TestSwitchSendHTLCMapping(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\n\t\t// If this is true, the channel will be zero-conf.\n\t\tzeroConf bool\n\n\t\t// Denotes whether the channel is option-scid-alias, non\n\t\t// zero-conf feature bit.\n\t\toptionFeature bool\n\n\t\t// If this is true, then the alias will be used in the packet.\n\t\tuseAlias bool\n\n\t\t// This will be the channel alias if there is a mapping.\n\t\talias lnwire.ShortChannelID\n\n\t\t// This will be the confirmed SCID if the channel is confirmed.\n\t\treal lnwire.ShortChannelID\n\t}{\n\t\t{\n\t\t\tname:          \"non-zero-conf real scid w/ option\",\n\t\t\tzeroConf:      false,\n\t\t\toptionFeature: true,\n\t\t\tuseAlias:      false,\n\t\t\talias: lnwire.ShortChannelID{\n\t\t\t\tBlockHeight: 10010,\n\t\t\t\tTxIndex:     10,\n\t\t\t\tTxPosition:  10,\n\t\t\t},\n\t\t\treal: lnwire.ShortChannelID{\n\t\t\t\tBlockHeight: 500000,\n\t\t\t\tTxIndex:     50,\n\t\t\t\tTxPosition:  50,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:     \"non-zero-conf real scid no option\",\n\t\t\tzeroConf: false,\n\t\t\tuseAlias: false,\n\t\t\talias:    lnwire.ShortChannelID{},\n\t\t\treal: lnwire.ShortChannelID{\n\t\t\t\tBlockHeight: 400000,\n\t\t\t\tTxIndex:     50,\n\t\t\t\tTxPosition:  50,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:     \"zero-conf alias scid w/ conf\",\n\t\t\tzeroConf: true,\n\t\t\tuseAlias: true,\n\t\t\talias: lnwire.ShortChannelID{\n\t\t\t\tBlockHeight: 10020,\n\t\t\t\tTxIndex:     20,\n\t\t\t\tTxPosition:  20,\n\t\t\t},\n\t\t\treal: lnwire.ShortChannelID{\n\t\t\t\tBlockHeight: 450000,\n\t\t\t\tTxIndex:     50,\n\t\t\t\tTxPosition:  50,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:     \"zero-conf alias scid no conf\",\n\t\t\tzeroConf: true,\n\t\t\tuseAlias: true,\n\t\t\talias: lnwire.ShortChannelID{\n\t\t\t\tBlockHeight: 10015,\n\t\t\t\tTxIndex:     25,\n\t\t\t\tTxPosition:  35,\n\t\t\t},\n\t\t\treal: lnwire.ShortChannelID{},\n\t\t},\n\t\t{\n\t\t\tname:     \"zero-conf real scid\",\n\t\t\tzeroConf: true,\n\t\t\tuseAlias: false,\n\t\t\talias: lnwire.ShortChannelID{\n\t\t\t\tBlockHeight: 10035,\n\t\t\t\tTxIndex:     35,\n\t\t\t\tTxPosition:  35,\n\t\t\t},\n\t\t\treal: lnwire.ShortChannelID{\n\t\t\t\tBlockHeight: 470000,\n\t\t\t\tTxIndex:     35,\n\t\t\t\tTxPosition:  45,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\ttestSwitchSendHtlcMapping(\n\t\t\t\tt, test.zeroConf, test.useAlias, test.alias,\n\t\t\t\ttest.real, test.optionFeature,\n\t\t\t)\n\t\t})\n\t}\n}\n",
      "length": 2037,
      "tokens": 240,
      "embedding": []
    },
    {
      "slug": "func testSwitchSendHtlcMapping(t *testing.T, zeroConf, useAlias bool, alias,",
      "content": "func testSwitchSendHtlcMapping(t *testing.T, zeroConf, useAlias bool, alias,\n\trealScid lnwire.ShortChannelID, optionFeature bool) {\n\n\tpeer, err := newMockServer(\n\t\tt, \"alice\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err)\n\n\ts, err := initSwitchWithTempDB(t, testStartingHeight)\n\trequire.NoError(t, err)\n\terr = s.Start()\n\trequire.NoError(t, err)\n\tdefer func() { _ = s.Stop() }()\n\n\t// Create the lnwire.ChannelID that we'll use.\n\tchanID, _ := genID()\n\n\tvar link *mockChannelLink\n\n\tif zeroConf {\n\t\tlink = newMockChannelLink(\n\t\t\ts, chanID, alias, realScid, peer, true, false, true,\n\t\t\tfalse,\n\t\t)\n\t} else {\n\t\tlink = newMockChannelLink(\n\t\t\ts, chanID, realScid, emptyScid, peer, true, false,\n\t\t\tfalse, true,\n\t\t)\n\n\t\tif optionFeature {\n\t\t\tlink.addAlias(alias)\n\t\t}\n\t}\n\n\terr = s.AddLink(link)\n\trequire.NoError(t, err)\n\n\t// Generate preimage.\n\tpreimage, err := genPreimage()\n\trequire.NoError(t, err)\n\trhash := sha256.Sum256(preimage[:])\n\n\t// Determine the outgoing SCID to use.\n\toutgoingSCID := realScid\n\tif useAlias {\n\t\toutgoingSCID = alias\n\t}\n\n\t// Send the HTLC and assert that we don't get an error.\n\thtlc := &lnwire.UpdateAddHTLC{\n\t\tPaymentHash: rhash,\n\t\tAmount:      1,\n\t}\n\n\terr = s.SendHTLC(outgoingSCID, 0, htlc)\n\trequire.NoError(t, err)\n}\n\n// TestSwitchUpdateScid verifies that zero-conf and non-zero-conf\n// option-scid-alias (feature bit) channels will have the expected entries in\n// the aliasToReal and baseIndex maps.",
      "length": 1306,
      "tokens": 174,
      "embedding": []
    },
    {
      "slug": "func TestSwitchUpdateScid(t *testing.T) {",
      "content": "func TestSwitchUpdateScid(t *testing.T) {\n\tt.Parallel()\n\n\tpeer, err := newMockServer(\n\t\tt, \"alice\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err, \"unable to create alice server\")\n\n\ts, err := initSwitchWithTempDB(t, testStartingHeight)\n\trequire.NoError(t, err)\n\terr = s.Start()\n\trequire.NoError(t, err)\n\tdefer func() { _ = s.Stop() }()\n\n\t// Create the IDs that we'll use.\n\tchanID, chanID2, _, _ := genIDs()\n\n\talias := lnwire.ShortChannelID{\n\t\tBlockHeight: 16_000_000,\n\t\tTxIndex:     0,\n\t\tTxPosition:  0,\n\t}\n\talias2 := alias\n\talias2.TxPosition = 1\n\n\trealScid := lnwire.ShortChannelID{\n\t\tBlockHeight: 500000,\n\t\tTxIndex:     0,\n\t\tTxPosition:  0,\n\t}\n\n\tlink := newMockChannelLink(\n\t\ts, chanID, alias, emptyScid, peer, true, false, true, false,\n\t)\n\tlink.addAlias(alias2)\n\n\terr = s.AddLink(link)\n\trequire.NoError(t, err)\n\n\t// Assert that the zero-conf link does not have entries in the\n\t// aliasToReal map.\n\ts.indexMtx.RLock()\n\t_, ok := s.aliasToReal[alias]\n\trequire.False(t, ok)\n\t_, ok = s.aliasToReal[alias2]\n\trequire.False(t, ok)\n\n\t// Assert that both aliases point to the \"base\" SCID, which is actually\n\t// just the first alias.\n\tbaseScid, ok := s.baseIndex[alias]\n\trequire.True(t, ok)\n\trequire.Equal(t, alias, baseScid)\n\n\tbaseScid, ok = s.baseIndex[alias2]\n\trequire.True(t, ok)\n\trequire.Equal(t, alias, baseScid)\n\n\ts.indexMtx.RUnlock()\n\n\t// We'll set the mock link's confirmed SCID so that UpdateShortChanID\n\t// populates aliasToReal and adds an entry to baseIndex.\n\tlink.realScid = realScid\n\tlink.confirmedZC = true\n\n\terr = s.UpdateShortChanID(chanID)\n\trequire.NoError(t, err)\n\n\t// Assert that aliasToReal is populated and there is an entry in\n\t// baseIndex for realScid.\n\ts.indexMtx.RLock()\n\trealMapping, ok := s.aliasToReal[alias]\n\trequire.True(t, ok)\n\trequire.Equal(t, realScid, realMapping)\n\n\trealMapping, ok = s.aliasToReal[alias2]\n\trequire.True(t, ok)\n\trequire.Equal(t, realScid, realMapping)\n\n\tbaseScid, ok = s.baseIndex[realScid]\n\trequire.True(t, ok)\n\trequire.Equal(t, alias, baseScid)\n\n\ts.indexMtx.RUnlock()\n\n\t// Now we'll perform the same checks with a non-zero-conf\n\t// option-scid-alias channel (feature-bit).\n\toptionReal := lnwire.ShortChannelID{\n\t\tBlockHeight: 600000,\n\t\tTxIndex:     0,\n\t\tTxPosition:  0,\n\t}\n\toptionAlias := lnwire.ShortChannelID{\n\t\tBlockHeight: 12000,\n\t\tTxIndex:     0,\n\t\tTxPosition:  0,\n\t}\n\toptionAlias2 := optionAlias\n\toptionAlias2.TxPosition = 1\n\tlink2 := newMockChannelLink(\n\t\ts, chanID2, optionReal, emptyScid, peer, true, false, false,\n\t\ttrue,\n\t)\n\tlink2.addAlias(optionAlias)\n\tlink2.addAlias(optionAlias2)\n\n\terr = s.AddLink(link2)\n\trequire.NoError(t, err)\n\n\t// Assert that the option-scid-alias link does have entries in the\n\t// aliasToReal and baseIndex maps.\n\ts.indexMtx.RLock()\n\trealMapping, ok = s.aliasToReal[optionAlias]\n\trequire.True(t, ok)\n\trequire.Equal(t, optionReal, realMapping)\n\n\trealMapping, ok = s.aliasToReal[optionAlias2]\n\trequire.True(t, ok)\n\trequire.Equal(t, optionReal, realMapping)\n\n\tbaseScid, ok = s.baseIndex[optionReal]\n\trequire.True(t, ok)\n\trequire.Equal(t, optionReal, baseScid)\n\n\tbaseScid, ok = s.baseIndex[optionAlias]\n\trequire.True(t, ok)\n\trequire.Equal(t, optionReal, baseScid)\n\n\tbaseScid, ok = s.baseIndex[optionAlias2]\n\trequire.True(t, ok)\n\trequire.Equal(t, optionReal, baseScid)\n\n\ts.indexMtx.RUnlock()\n}\n\n// TestSwitchForward checks the ability of htlc switch to forward add/settle\n// requests.",
      "length": 3211,
      "tokens": 373,
      "embedding": []
    },
    {
      "slug": "func TestSwitchForward(t *testing.T) {",
      "content": "func TestSwitchForward(t *testing.T) {\n\tt.Parallel()\n\n\talicePeer, err := newMockServer(\n\t\tt, \"alice\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\tif err != nil {\n\t\tt.Fatalf(\"unable to create alice server: %v\", err)\n\t}\n\tbobPeer, err := newMockServer(\n\t\tt, \"bob\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\tif err != nil {\n\t\tt.Fatalf(\"unable to create bob server: %v\", err)\n\t}\n\n\ts, err := initSwitchWithTempDB(t, testStartingHeight)\n\tif err != nil {\n\t\tt.Fatalf(\"unable to init switch: %v\", err)\n\t}\n\tif err := s.Start(); err != nil {\n\t\tt.Fatalf(\"unable to start switch: %v\", err)\n\t}\n\tdefer s.Stop()\n\n\tchanID1, chanID2, aliceChanID, bobChanID := genIDs()\n\n\taliceChannelLink := newMockChannelLink(\n\t\ts, chanID1, aliceChanID, emptyScid, alicePeer, true, false,\n\t\tfalse, false,\n\t)\n\tbobChannelLink := newMockChannelLink(\n\t\ts, chanID2, bobChanID, emptyScid, bobPeer, true, false, false,\n\t\tfalse,\n\t)\n\tif err := s.AddLink(aliceChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add alice link: %v\", err)\n\t}\n\tif err := s.AddLink(bobChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add bob link: %v\", err)\n\t}\n\n\t// Create request which should be forwarded from Alice channel link to\n\t// bob channel link.\n\tpreimage, err := genPreimage()\n\tif err != nil {\n\t\tt.Fatalf(\"unable to generate preimage: %v\", err)\n\t}\n\trhash := sha256.Sum256(preimage[:])\n\tpacket := &htlcPacket{\n\t\tincomingChanID: aliceChannelLink.ShortChanID(),\n\t\tincomingHTLCID: 0,\n\t\toutgoingChanID: bobChannelLink.ShortChanID(),\n\t\tobfuscator:     NewMockObfuscator(),\n\t\thtlc: &lnwire.UpdateAddHTLC{\n\t\t\tPaymentHash: rhash,\n\t\t\tAmount:      1,\n\t\t},\n\t}\n\n\t// Handle the request and checks that bob channel link received it.\n\tif err := s.ForwardPackets(nil, packet); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tselect {\n\tcase <-bobChannelLink.packets:\n\t\tif err := bobChannelLink.completeCircuit(packet); err != nil {\n\t\t\tt.Fatalf(\"unable to complete payment circuit: %v\", err)\n\t\t}\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"request was not propagated to destination\")\n\t}\n\n\tif s.circuits.NumOpen() != 1 {\n\t\tt.Fatal(\"wrong amount of circuits\")\n\t}\n\n\tif !s.IsForwardedHTLC(bobChannelLink.ShortChanID(), 0) {\n\t\tt.Fatal(\"htlc should be identified as forwarded\")\n\t}\n\n\t// Create settle request pretending that bob link handled the add htlc\n\t// request and sent the htlc settle request back. This request should\n\t// be forwarder back to Alice link.\n\tpacket = &htlcPacket{\n\t\toutgoingChanID: bobChannelLink.ShortChanID(),\n\t\toutgoingHTLCID: 0,\n\t\tamount:         1,\n\t\thtlc: &lnwire.UpdateFulfillHTLC{\n\t\t\tPaymentPreimage: preimage,\n\t\t},\n\t}\n\n\t// Handle the request and checks that payment circuit works properly.\n\tif err := s.ForwardPackets(nil, packet); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tselect {\n\tcase pkt := <-aliceChannelLink.packets:\n\t\tif err := aliceChannelLink.deleteCircuit(pkt); err != nil {\n\t\t\tt.Fatalf(\"unable to remove circuit: %v\", err)\n\t\t}\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"request was not propagated to channelPoint\")\n\t}\n\n\tif s.circuits.NumOpen() != 0 {\n\t\tt.Fatal(\"wrong amount of circuits\")\n\t}\n}\n",
      "length": 2889,
      "tokens": 381,
      "embedding": []
    },
    {
      "slug": "func TestSwitchForwardFailAfterFullAdd(t *testing.T) {",
      "content": "func TestSwitchForwardFailAfterFullAdd(t *testing.T) {\n\tt.Parallel()\n\n\tchanID1, chanID2, aliceChanID, bobChanID := genIDs()\n\n\talicePeer, err := newMockServer(\n\t\tt, \"alice\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\tif err != nil {\n\t\tt.Fatalf(\"unable to create alice server: %v\", err)\n\t}\n\tbobPeer, err := newMockServer(\n\t\tt, \"bob\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err, \"unable to create bob server\")\n\n\ttempPath := t.TempDir()\n\n\tcdb, err := channeldb.Open(tempPath)\n\trequire.NoError(t, err, \"unable to open channeldb\")\n\tt.Cleanup(func() { cdb.Close() })\n\n\ts, err := initSwitchWithDB(testStartingHeight, cdb)\n\trequire.NoError(t, err, \"unable to init switch\")\n\tif err := s.Start(); err != nil {\n\t\tt.Fatalf(\"unable to start switch: %v\", err)\n\t}\n\n\t// Even though we intend to Stop s later in the test, it is safe to\n\t// defer this Stop since its execution it is protected by an atomic\n\t// guard, guaranteeing it executes at most once.\n\tdefer s.Stop()\n\n\taliceChannelLink := newMockChannelLink(\n\t\ts, chanID1, aliceChanID, emptyScid, alicePeer, true, false,\n\t\tfalse, false,\n\t)\n\tbobChannelLink := newMockChannelLink(\n\t\ts, chanID2, bobChanID, emptyScid, bobPeer, true, false, false,\n\t\tfalse,\n\t)\n\tif err := s.AddLink(aliceChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add alice link: %v\", err)\n\t}\n\tif err := s.AddLink(bobChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add bob link: %v\", err)\n\t}\n\n\t// Create request which should be forwarded from Alice channel link to\n\t// bob channel link.\n\tpreimage := [sha256.Size]byte{1}\n\trhash := sha256.Sum256(preimage[:])\n\togPacket := &htlcPacket{\n\t\tincomingChanID: aliceChannelLink.ShortChanID(),\n\t\tincomingHTLCID: 0,\n\t\toutgoingChanID: bobChannelLink.ShortChanID(),\n\t\tobfuscator:     NewMockObfuscator(),\n\t\thtlc: &lnwire.UpdateAddHTLC{\n\t\t\tPaymentHash: rhash,\n\t\t\tAmount:      1,\n\t\t},\n\t}\n\n\tif s.circuits.NumPending() != 0 {\n\t\tt.Fatalf(\"wrong amount of half circuits\")\n\t}\n\tif s.circuits.NumOpen() != 0 {\n\t\tt.Fatalf(\"wrong amount of circuits\")\n\t}\n\n\t// Handle the request and checks that bob channel link received it.\n\tif err := s.ForwardPackets(nil, ogPacket); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif s.circuits.NumPending() != 1 {\n\t\tt.Fatalf(\"wrong amount of half circuits\")\n\t}\n\tif s.circuits.NumOpen() != 0 {\n\t\tt.Fatalf(\"wrong amount of circuits\")\n\t}\n\n\t// Pull packet from bob's link, but do not perform a full add.\n\tselect {\n\tcase packet := <-bobChannelLink.packets:\n\t\t// Complete the payment circuit and assign the outgoing htlc id\n\t\t// before restarting.\n\t\tif err := bobChannelLink.completeCircuit(packet); err != nil {\n\t\t\tt.Fatalf(\"unable to complete payment circuit: %v\", err)\n\t\t}\n\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"request was not propagated to destination\")\n\t}\n\n\tif s.circuits.NumPending() != 1 {\n\t\tt.Fatalf(\"wrong amount of half circuits\")\n\t}\n\tif s.circuits.NumOpen() != 1 {\n\t\tt.Fatalf(\"wrong amount of circuits\")\n\t}\n\n\t// Now we will restart bob, leaving the forwarding decision for this\n\t// htlc is in the half-added state.\n\tif err := s.Stop(); err != nil {\n\t\tt.Fatalf(err.Error())\n\t}\n\n\tif err := cdb.Close(); err != nil {\n\t\tt.Fatalf(err.Error())\n\t}\n\n\tcdb2, err := channeldb.Open(tempPath)\n\trequire.NoError(t, err, \"unable to reopen channeldb\")\n\tt.Cleanup(func() { cdb2.Close() })\n\n\ts2, err := initSwitchWithDB(testStartingHeight, cdb2)\n\trequire.NoError(t, err, \"unable reinit switch\")\n\tif err := s2.Start(); err != nil {\n\t\tt.Fatalf(\"unable to restart switch: %v\", err)\n\t}\n\n\t// Even though we intend to Stop s2 later in the test, it is safe to\n\t// defer this Stop since its execution it is protected by an atomic\n\t// guard, guaranteeing it executes at most once.\n\tdefer s2.Stop()\n\n\taliceChannelLink = newMockChannelLink(\n\t\ts2, chanID1, aliceChanID, emptyScid, alicePeer, true, false,\n\t\tfalse, false,\n\t)\n\tbobChannelLink = newMockChannelLink(\n\t\ts2, chanID2, bobChanID, emptyScid, bobPeer, true, false, false,\n\t\tfalse,\n\t)\n\tif err := s2.AddLink(aliceChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add alice link: %v\", err)\n\t}\n\tif err := s2.AddLink(bobChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add bob link: %v\", err)\n\t}\n\n\tif s2.circuits.NumPending() != 1 {\n\t\tt.Fatalf(\"wrong amount of half circuits\")\n\t}\n\tif s2.circuits.NumOpen() != 1 {\n\t\tt.Fatalf(\"wrong amount of circuits\")\n\t}\n\n\t// Craft a failure message from the remote peer.\n\tfail := &htlcPacket{\n\t\toutgoingChanID: bobChannelLink.ShortChanID(),\n\t\toutgoingHTLCID: 0,\n\t\tamount:         1,\n\t\thtlc:           &lnwire.UpdateFailHTLC{},\n\t}\n\n\t// Send the fail packet from the remote peer through the switch.\n\tif err := s2.ForwardPackets(nil, fail); err != nil {\n\t\tt.Fatalf(err.Error())\n\t}\n\n\t// Pull packet from alice's link, as it should have gone through\n\t// successfully.\n\tselect {\n\tcase pkt := <-aliceChannelLink.packets:\n\t\tif err := aliceChannelLink.completeCircuit(pkt); err != nil {\n\t\t\tt.Fatalf(\"unable to remove circuit: %v\", err)\n\t\t}\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"request was not propagated to destination\")\n\t}\n\n\t// Circuit map should be empty now.\n\tif s2.circuits.NumPending() != 0 {\n\t\tt.Fatalf(\"wrong amount of half circuits\")\n\t}\n\tif s2.circuits.NumOpen() != 0 {\n\t\tt.Fatalf(\"wrong amount of circuits\")\n\t}\n\n\t// Send the fail packet from the remote peer through the switch.\n\tif err := s.ForwardPackets(nil, fail); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tselect {\n\tcase <-aliceChannelLink.packets:\n\t\tt.Fatalf(\"expected duplicate fail to not arrive at the destination\")\n\tcase <-time.After(time.Second):\n\t}\n}\n",
      "length": 5213,
      "tokens": 724,
      "embedding": []
    },
    {
      "slug": "func TestSwitchForwardSettleAfterFullAdd(t *testing.T) {",
      "content": "func TestSwitchForwardSettleAfterFullAdd(t *testing.T) {\n\tt.Parallel()\n\n\tchanID1, chanID2, aliceChanID, bobChanID := genIDs()\n\n\talicePeer, err := newMockServer(\n\t\tt, \"alice\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err, \"unable to create alice server\")\n\tbobPeer, err := newMockServer(\n\t\tt, \"bob\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err, \"unable to create bob server\")\n\n\ttempPath := t.TempDir()\n\n\tcdb, err := channeldb.Open(tempPath)\n\trequire.NoError(t, err, \"unable to open channeldb\")\n\tt.Cleanup(func() { cdb.Close() })\n\n\ts, err := initSwitchWithDB(testStartingHeight, cdb)\n\trequire.NoError(t, err, \"unable to init switch\")\n\tif err := s.Start(); err != nil {\n\t\tt.Fatalf(\"unable to start switch: %v\", err)\n\t}\n\n\t// Even though we intend to Stop s later in the test, it is safe to\n\t// defer this Stop since its execution it is protected by an atomic\n\t// guard, guaranteeing it executes at most once.\n\tdefer s.Stop()\n\n\taliceChannelLink := newMockChannelLink(\n\t\ts, chanID1, aliceChanID, emptyScid, alicePeer, true, false,\n\t\tfalse, false,\n\t)\n\tbobChannelLink := newMockChannelLink(\n\t\ts, chanID2, bobChanID, emptyScid, bobPeer, true, false, false,\n\t\tfalse,\n\t)\n\tif err := s.AddLink(aliceChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add alice link: %v\", err)\n\t}\n\tif err := s.AddLink(bobChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add bob link: %v\", err)\n\t}\n\n\t// Create request which should be forwarded from Alice channel link to\n\t// bob channel link.\n\tpreimage := [sha256.Size]byte{1}\n\trhash := sha256.Sum256(preimage[:])\n\togPacket := &htlcPacket{\n\t\tincomingChanID: aliceChannelLink.ShortChanID(),\n\t\tincomingHTLCID: 0,\n\t\toutgoingChanID: bobChannelLink.ShortChanID(),\n\t\tobfuscator:     NewMockObfuscator(),\n\t\thtlc: &lnwire.UpdateAddHTLC{\n\t\t\tPaymentHash: rhash,\n\t\t\tAmount:      1,\n\t\t},\n\t}\n\n\tif s.circuits.NumPending() != 0 {\n\t\tt.Fatalf(\"wrong amount of half circuits\")\n\t}\n\tif s.circuits.NumOpen() != 0 {\n\t\tt.Fatalf(\"wrong amount of circuits\")\n\t}\n\n\t// Handle the request and checks that bob channel link received it.\n\tif err := s.ForwardPackets(nil, ogPacket); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif s.circuits.NumPending() != 1 {\n\t\tt.Fatalf(\"wrong amount of half circuits\")\n\t}\n\tif s.circuits.NumOpen() != 0 {\n\t\tt.Fatalf(\"wrong amount of circuits\")\n\t}\n\n\t// Pull packet from bob's link, but do not perform a full add.\n\tselect {\n\tcase packet := <-bobChannelLink.packets:\n\t\t// Complete the payment circuit and assign the outgoing htlc id\n\t\t// before restarting.\n\t\tif err := bobChannelLink.completeCircuit(packet); err != nil {\n\t\t\tt.Fatalf(\"unable to complete payment circuit: %v\", err)\n\t\t}\n\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"request was not propagated to destination\")\n\t}\n\n\tif s.circuits.NumPending() != 1 {\n\t\tt.Fatalf(\"wrong amount of half circuits\")\n\t}\n\tif s.circuits.NumOpen() != 1 {\n\t\tt.Fatalf(\"wrong amount of circuits\")\n\t}\n\n\t// Now we will restart bob, leaving the forwarding decision for this\n\t// htlc is in the half-added state.\n\tif err := s.Stop(); err != nil {\n\t\tt.Fatalf(err.Error())\n\t}\n\n\tif err := cdb.Close(); err != nil {\n\t\tt.Fatalf(err.Error())\n\t}\n\n\tcdb2, err := channeldb.Open(tempPath)\n\trequire.NoError(t, err, \"unable to reopen channeldb\")\n\tt.Cleanup(func() { cdb2.Close() })\n\n\ts2, err := initSwitchWithDB(testStartingHeight, cdb2)\n\trequire.NoError(t, err, \"unable reinit switch\")\n\tif err := s2.Start(); err != nil {\n\t\tt.Fatalf(\"unable to restart switch: %v\", err)\n\t}\n\n\t// Even though we intend to Stop s2 later in the test, it is safe to\n\t// defer this Stop since its execution it is protected by an atomic\n\t// guard, guaranteeing it executes at most once.\n\tdefer s2.Stop()\n\n\taliceChannelLink = newMockChannelLink(\n\t\ts2, chanID1, aliceChanID, emptyScid, alicePeer, true, false,\n\t\tfalse, false,\n\t)\n\tbobChannelLink = newMockChannelLink(\n\t\ts2, chanID2, bobChanID, emptyScid, bobPeer, true, false, false,\n\t\tfalse,\n\t)\n\tif err := s2.AddLink(aliceChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add alice link: %v\", err)\n\t}\n\tif err := s2.AddLink(bobChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add bob link: %v\", err)\n\t}\n\n\tif s2.circuits.NumPending() != 1 {\n\t\tt.Fatalf(\"wrong amount of half circuits\")\n\t}\n\tif s2.circuits.NumOpen() != 1 {\n\t\tt.Fatalf(\"wrong amount of circuits\")\n\t}\n\n\t// Craft a settle message from the remote peer.\n\tsettle := &htlcPacket{\n\t\toutgoingChanID: bobChannelLink.ShortChanID(),\n\t\toutgoingHTLCID: 0,\n\t\tamount:         1,\n\t\thtlc: &lnwire.UpdateFulfillHTLC{\n\t\t\tPaymentPreimage: preimage,\n\t\t},\n\t}\n\n\t// Send the settle packet from the remote peer through the switch.\n\tif err := s2.ForwardPackets(nil, settle); err != nil {\n\t\tt.Fatalf(err.Error())\n\t}\n\n\t// Pull packet from alice's link, as it should have gone through\n\t// successfully.\n\tselect {\n\tcase packet := <-aliceChannelLink.packets:\n\t\tif err := aliceChannelLink.completeCircuit(packet); err != nil {\n\t\t\tt.Fatalf(\"unable to complete circuit with in key=%s: %v\",\n\t\t\t\tpacket.inKey(), err)\n\t\t}\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"request was not propagated to destination\")\n\t}\n\n\t// Circuit map should be empty now.\n\tif s2.circuits.NumPending() != 0 {\n\t\tt.Fatalf(\"wrong amount of half circuits\")\n\t}\n\tif s2.circuits.NumOpen() != 0 {\n\t\tt.Fatalf(\"wrong amount of circuits\")\n\t}\n\n\t// Send the settle packet again, which not arrive at destination.\n\tif err := s2.ForwardPackets(nil, settle); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tselect {\n\tcase <-bobChannelLink.packets:\n\t\tt.Fatalf(\"expected duplicate fail to not arrive at the destination\")\n\tcase <-time.After(time.Second):\n\t}\n}\n",
      "length": 5273,
      "tokens": 724,
      "embedding": []
    },
    {
      "slug": "func TestSwitchForwardDropAfterFullAdd(t *testing.T) {",
      "content": "func TestSwitchForwardDropAfterFullAdd(t *testing.T) {\n\tt.Parallel()\n\n\tchanID1, chanID2, aliceChanID, bobChanID := genIDs()\n\n\talicePeer, err := newMockServer(\n\t\tt, \"alice\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err, \"unable to create alice server\")\n\tbobPeer, err := newMockServer(\n\t\tt, \"bob\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err, \"unable to create bob server\")\n\n\ttempPath := t.TempDir()\n\n\tcdb, err := channeldb.Open(tempPath)\n\trequire.NoError(t, err, \"unable to open channeldb\")\n\tt.Cleanup(func() { cdb.Close() })\n\n\ts, err := initSwitchWithDB(testStartingHeight, cdb)\n\trequire.NoError(t, err, \"unable to init switch\")\n\tif err := s.Start(); err != nil {\n\t\tt.Fatalf(\"unable to start switch: %v\", err)\n\t}\n\n\t// Even though we intend to Stop s later in the test, it is safe to\n\t// defer this Stop since its execution it is protected by an atomic\n\t// guard, guaranteeing it executes at most once.\n\tdefer s.Stop()\n\n\taliceChannelLink := newMockChannelLink(\n\t\ts, chanID1, aliceChanID, emptyScid, alicePeer, true, false,\n\t\tfalse, false,\n\t)\n\tbobChannelLink := newMockChannelLink(\n\t\ts, chanID2, bobChanID, emptyScid, bobPeer, true, false, false,\n\t\tfalse,\n\t)\n\tif err := s.AddLink(aliceChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add alice link: %v\", err)\n\t}\n\tif err := s.AddLink(bobChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add bob link: %v\", err)\n\t}\n\n\t// Create request which should be forwarded from Alice channel link to\n\t// bob channel link.\n\tpreimage := [sha256.Size]byte{1}\n\trhash := sha256.Sum256(preimage[:])\n\togPacket := &htlcPacket{\n\t\tincomingChanID: aliceChannelLink.ShortChanID(),\n\t\tincomingHTLCID: 0,\n\t\toutgoingChanID: bobChannelLink.ShortChanID(),\n\t\tobfuscator:     NewMockObfuscator(),\n\t\thtlc: &lnwire.UpdateAddHTLC{\n\t\t\tPaymentHash: rhash,\n\t\t\tAmount:      1,\n\t\t},\n\t}\n\n\tif s.circuits.NumPending() != 0 {\n\t\tt.Fatalf(\"wrong amount of half circuits\")\n\t}\n\tif s.circuits.NumOpen() != 0 {\n\t\tt.Fatalf(\"wrong amount of circuits\")\n\t}\n\n\t// Handle the request and checks that bob channel link received it.\n\tif err := s.ForwardPackets(nil, ogPacket); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif s.circuits.NumPending() != 1 {\n\t\tt.Fatalf(\"wrong amount of half circuits\")\n\t}\n\tif s.circuits.NumOpen() != 0 {\n\t\tt.Fatalf(\"wrong amount of half circuits\")\n\t}\n\n\t// Pull packet from bob's link, but do not perform a full add.\n\tselect {\n\tcase packet := <-bobChannelLink.packets:\n\t\t// Complete the payment circuit and assign the outgoing htlc id\n\t\t// before restarting.\n\t\tif err := bobChannelLink.completeCircuit(packet); err != nil {\n\t\t\tt.Fatalf(\"unable to complete payment circuit: %v\", err)\n\t\t}\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"request was not propagated to destination\")\n\t}\n\n\t// Now we will restart bob, leaving the forwarding decision for this\n\t// htlc is in the half-added state.\n\tif err := s.Stop(); err != nil {\n\t\tt.Fatalf(err.Error())\n\t}\n\n\tif err := cdb.Close(); err != nil {\n\t\tt.Fatalf(err.Error())\n\t}\n\n\tcdb2, err := channeldb.Open(tempPath)\n\trequire.NoError(t, err, \"unable to reopen channeldb\")\n\tt.Cleanup(func() { cdb2.Close() })\n\n\ts2, err := initSwitchWithDB(testStartingHeight, cdb2)\n\trequire.NoError(t, err, \"unable reinit switch\")\n\tif err := s2.Start(); err != nil {\n\t\tt.Fatalf(\"unable to restart switch: %v\", err)\n\t}\n\n\t// Even though we intend to Stop s2 later in the test, it is safe to\n\t// defer this Stop since its execution it is protected by an atomic\n\t// guard, guaranteeing it executes at most once.\n\tdefer s2.Stop()\n\n\taliceChannelLink = newMockChannelLink(\n\t\ts2, chanID1, aliceChanID, emptyScid, alicePeer, true, false,\n\t\tfalse, false,\n\t)\n\tbobChannelLink = newMockChannelLink(\n\t\ts2, chanID2, bobChanID, emptyScid, bobPeer, true, false, false,\n\t\tfalse,\n\t)\n\tif err := s2.AddLink(aliceChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add alice link: %v\", err)\n\t}\n\tif err := s2.AddLink(bobChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add bob link: %v\", err)\n\t}\n\n\tif s2.circuits.NumPending() != 1 {\n\t\tt.Fatalf(\"wrong amount of half circuits\")\n\t}\n\tif s2.circuits.NumOpen() != 1 {\n\t\tt.Fatalf(\"wrong amount of half circuits\")\n\t}\n\n\t// Resend the failed htlc. The packet will be dropped silently since the\n\t// switch will detect that it has been half added previously.\n\tif err := s2.ForwardPackets(nil, ogPacket); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// After detecting an incomplete forward, the fail packet should have\n\t// been returned to the sender.\n\tselect {\n\tcase <-aliceChannelLink.packets:\n\t\tt.Fatal(\"request should not have returned to source\")\n\tcase <-bobChannelLink.packets:\n\t\tt.Fatal(\"request should not have forwarded to destination\")\n\tcase <-time.After(time.Second):\n\t}\n}\n",
      "length": 4448,
      "tokens": 619,
      "embedding": []
    },
    {
      "slug": "func TestSwitchForwardFailAfterHalfAdd(t *testing.T) {",
      "content": "func TestSwitchForwardFailAfterHalfAdd(t *testing.T) {\n\tt.Parallel()\n\n\tchanID1, chanID2, aliceChanID, bobChanID := genIDs()\n\n\talicePeer, err := newMockServer(\n\t\tt, \"alice\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err, \"unable to create alice server\")\n\tbobPeer, err := newMockServer(\n\t\tt, \"bob\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err, \"unable to create bob server\")\n\n\ttempPath := t.TempDir()\n\n\tcdb, err := channeldb.Open(tempPath)\n\trequire.NoError(t, err, \"unable to open channeldb\")\n\tt.Cleanup(func() { cdb.Close() })\n\n\ts, err := initSwitchWithDB(testStartingHeight, cdb)\n\trequire.NoError(t, err, \"unable to init switch\")\n\tif err := s.Start(); err != nil {\n\t\tt.Fatalf(\"unable to start switch: %v\", err)\n\t}\n\n\t// Even though we intend to Stop s later in the test, it is safe to\n\t// defer this Stop since its execution it is protected by an atomic\n\t// guard, guaranteeing it executes at most once.\n\tdefer s.Stop()\n\n\taliceChannelLink := newMockChannelLink(\n\t\ts, chanID1, aliceChanID, emptyScid, alicePeer, true, false,\n\t\tfalse, false,\n\t)\n\tbobChannelLink := newMockChannelLink(\n\t\ts, chanID2, bobChanID, emptyScid, bobPeer, true, false, false,\n\t\tfalse,\n\t)\n\tif err := s.AddLink(aliceChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add alice link: %v\", err)\n\t}\n\tif err := s.AddLink(bobChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add bob link: %v\", err)\n\t}\n\n\t// Create request which should be forwarded from Alice channel link to\n\t// bob channel link.\n\tpreimage := [sha256.Size]byte{1}\n\trhash := sha256.Sum256(preimage[:])\n\togPacket := &htlcPacket{\n\t\tincomingChanID: aliceChannelLink.ShortChanID(),\n\t\tincomingHTLCID: 0,\n\t\toutgoingChanID: bobChannelLink.ShortChanID(),\n\t\tobfuscator:     NewMockObfuscator(),\n\t\thtlc: &lnwire.UpdateAddHTLC{\n\t\t\tPaymentHash: rhash,\n\t\t\tAmount:      1,\n\t\t},\n\t}\n\n\tif s.circuits.NumPending() != 0 {\n\t\tt.Fatalf(\"wrong amount of half circuits\")\n\t}\n\tif s.circuits.NumOpen() != 0 {\n\t\tt.Fatalf(\"wrong amount of circuits\")\n\t}\n\n\t// Handle the request and checks that bob channel link received it.\n\tif err := s.ForwardPackets(nil, ogPacket); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif s.circuits.NumPending() != 1 {\n\t\tt.Fatalf(\"wrong amount of half circuits\")\n\t}\n\tif s.circuits.NumOpen() != 0 {\n\t\tt.Fatalf(\"wrong amount of half circuits\")\n\t}\n\n\t// Pull packet from bob's link, but do not perform a full add.\n\tselect {\n\tcase <-bobChannelLink.packets:\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"request was not propagated to destination\")\n\t}\n\n\t// Now we will restart bob, leaving the forwarding decision for this\n\t// htlc is in the half-added state.\n\tif err := s.Stop(); err != nil {\n\t\tt.Fatalf(err.Error())\n\t}\n\n\tif err := cdb.Close(); err != nil {\n\t\tt.Fatalf(err.Error())\n\t}\n\n\tcdb2, err := channeldb.Open(tempPath)\n\trequire.NoError(t, err, \"unable to reopen channeldb\")\n\tt.Cleanup(func() { cdb2.Close() })\n\n\ts2, err := initSwitchWithDB(testStartingHeight, cdb2)\n\trequire.NoError(t, err, \"unable reinit switch\")\n\tif err := s2.Start(); err != nil {\n\t\tt.Fatalf(\"unable to restart switch: %v\", err)\n\t}\n\n\t// Even though we intend to Stop s2 later in the test, it is safe to\n\t// defer this Stop since its execution it is protected by an atomic\n\t// guard, guaranteeing it executes at most once.\n\tdefer s2.Stop()\n\n\taliceChannelLink = newMockChannelLink(\n\t\ts2, chanID1, aliceChanID, emptyScid, alicePeer, true, false,\n\t\tfalse, false,\n\t)\n\tbobChannelLink = newMockChannelLink(\n\t\ts2, chanID2, bobChanID, emptyScid, bobPeer, true, false, false,\n\t\tfalse,\n\t)\n\tif err := s2.AddLink(aliceChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add alice link: %v\", err)\n\t}\n\tif err := s2.AddLink(bobChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add bob link: %v\", err)\n\t}\n\n\tif s2.circuits.NumPending() != 1 {\n\t\tt.Fatalf(\"wrong amount of half circuits\")\n\t}\n\tif s2.circuits.NumOpen() != 0 {\n\t\tt.Fatalf(\"wrong amount of half circuits\")\n\t}\n\n\t// Resend the failed htlc, it should be returned to alice since the\n\t// switch will detect that it has been half added previously.\n\terr = s2.ForwardPackets(nil, ogPacket)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// After detecting an incomplete forward, the fail packet should have\n\t// been returned to the sender.\n\tselect {\n\tcase pkt := <-aliceChannelLink.packets:\n\t\tlinkErr := pkt.linkFailure\n\t\tif linkErr.FailureDetail != OutgoingFailureIncompleteForward {\n\t\t\tt.Fatalf(\"expected incomplete forward, got: %v\",\n\t\t\t\tlinkErr.FailureDetail)\n\t\t}\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"request was not propagated to destination\")\n\t}\n}\n\n// TestSwitchForwardCircuitPersistence checks the ability of htlc switch to\n// maintain the proper entries in the circuit map in the face of restarts.",
      "length": 4453,
      "tokens": 617,
      "embedding": []
    },
    {
      "slug": "func TestSwitchForwardCircuitPersistence(t *testing.T) {",
      "content": "func TestSwitchForwardCircuitPersistence(t *testing.T) {\n\tt.Parallel()\n\n\tchanID1, chanID2, aliceChanID, bobChanID := genIDs()\n\n\talicePeer, err := newMockServer(\n\t\tt, \"alice\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err, \"unable to create alice server\")\n\tbobPeer, err := newMockServer(\n\t\tt, \"bob\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err, \"unable to create bob server\")\n\n\ttempPath := t.TempDir()\n\n\tcdb, err := channeldb.Open(tempPath)\n\trequire.NoError(t, err, \"unable to open channeldb\")\n\tt.Cleanup(func() { cdb.Close() })\n\n\ts, err := initSwitchWithDB(testStartingHeight, cdb)\n\trequire.NoError(t, err, \"unable to init switch\")\n\tif err := s.Start(); err != nil {\n\t\tt.Fatalf(\"unable to start switch: %v\", err)\n\t}\n\n\t// Even though we intend to Stop s later in the test, it is safe to\n\t// defer this Stop since its execution it is protected by an atomic\n\t// guard, guaranteeing it executes at most once.\n\tdefer s.Stop()\n\n\taliceChannelLink := newMockChannelLink(\n\t\ts, chanID1, aliceChanID, emptyScid, alicePeer, true, false,\n\t\tfalse, false,\n\t)\n\tbobChannelLink := newMockChannelLink(\n\t\ts, chanID2, bobChanID, emptyScid, bobPeer, true, false, false,\n\t\tfalse,\n\t)\n\tif err := s.AddLink(aliceChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add alice link: %v\", err)\n\t}\n\tif err := s.AddLink(bobChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add bob link: %v\", err)\n\t}\n\n\t// Create request which should be forwarded from Alice channel link to\n\t// bob channel link.\n\tpreimage := [sha256.Size]byte{1}\n\trhash := sha256.Sum256(preimage[:])\n\togPacket := &htlcPacket{\n\t\tincomingChanID: aliceChannelLink.ShortChanID(),\n\t\tincomingHTLCID: 0,\n\t\toutgoingChanID: bobChannelLink.ShortChanID(),\n\t\tobfuscator:     NewMockObfuscator(),\n\t\thtlc: &lnwire.UpdateAddHTLC{\n\t\t\tPaymentHash: rhash,\n\t\t\tAmount:      1,\n\t\t},\n\t}\n\n\tif s.circuits.NumPending() != 0 {\n\t\tt.Fatalf(\"wrong amount of half circuits\")\n\t}\n\tif s.circuits.NumOpen() != 0 {\n\t\tt.Fatalf(\"wrong amount of circuits\")\n\t}\n\n\t// Handle the request and checks that bob channel link received it.\n\tif err := s.ForwardPackets(nil, ogPacket); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif s.circuits.NumPending() != 1 {\n\t\tt.Fatalf(\"wrong amount of half circuits\")\n\t}\n\tif s.circuits.NumOpen() != 0 {\n\t\tt.Fatalf(\"wrong amount of circuits\")\n\t}\n\n\t// Retrieve packet from outgoing link and cache until after restart.\n\tvar packet *htlcPacket\n\tselect {\n\tcase packet = <-bobChannelLink.packets:\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"request was not propagated to destination\")\n\t}\n\n\tif err := s.Stop(); err != nil {\n\t\tt.Fatalf(err.Error())\n\t}\n\n\tif err := cdb.Close(); err != nil {\n\t\tt.Fatalf(err.Error())\n\t}\n\n\tcdb2, err := channeldb.Open(tempPath)\n\trequire.NoError(t, err, \"unable to reopen channeldb\")\n\tt.Cleanup(func() { cdb2.Close() })\n\n\ts2, err := initSwitchWithDB(testStartingHeight, cdb2)\n\trequire.NoError(t, err, \"unable reinit switch\")\n\tif err := s2.Start(); err != nil {\n\t\tt.Fatalf(\"unable to restart switch: %v\", err)\n\t}\n\n\t// Even though we intend to Stop s2 later in the test, it is safe to\n\t// defer this Stop since its execution it is protected by an atomic\n\t// guard, guaranteeing it executes at most once.\n\tdefer s2.Stop()\n\n\taliceChannelLink = newMockChannelLink(\n\t\ts2, chanID1, aliceChanID, emptyScid, alicePeer, true, false,\n\t\tfalse, false,\n\t)\n\tbobChannelLink = newMockChannelLink(\n\t\ts2, chanID2, bobChanID, emptyScid, bobPeer, true, false, false,\n\t\tfalse,\n\t)\n\tif err := s2.AddLink(aliceChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add alice link: %v\", err)\n\t}\n\tif err := s2.AddLink(bobChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add bob link: %v\", err)\n\t}\n\n\tif s2.circuits.NumPending() != 1 {\n\t\tt.Fatalf(\"wrong amount of half circuits\")\n\t}\n\tif s2.circuits.NumOpen() != 0 {\n\t\tt.Fatalf(\"wrong amount of half circuits\")\n\t}\n\n\t// Now that the switch has restarted, complete the payment circuit.\n\tif err := bobChannelLink.completeCircuit(packet); err != nil {\n\t\tt.Fatalf(\"unable to complete payment circuit: %v\", err)\n\t}\n\n\tif s2.circuits.NumPending() != 1 {\n\t\tt.Fatalf(\"wrong amount of half circuits\")\n\t}\n\tif s2.circuits.NumOpen() != 1 {\n\t\tt.Fatal(\"wrong amount of circuits\")\n\t}\n\n\t// Create settle request pretending that bob link handled the add htlc\n\t// request and sent the htlc settle request back. This request should\n\t// be forwarder back to Alice link.\n\togPacket = &htlcPacket{\n\t\toutgoingChanID: bobChannelLink.ShortChanID(),\n\t\toutgoingHTLCID: 0,\n\t\tamount:         1,\n\t\thtlc: &lnwire.UpdateFulfillHTLC{\n\t\t\tPaymentPreimage: preimage,\n\t\t},\n\t}\n\n\t// Handle the request and checks that payment circuit works properly.\n\tif err := s2.ForwardPackets(nil, ogPacket); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tselect {\n\tcase packet = <-aliceChannelLink.packets:\n\t\tif err := aliceChannelLink.completeCircuit(packet); err != nil {\n\t\t\tt.Fatalf(\"unable to complete circuit with in key=%s: %v\",\n\t\t\t\tpacket.inKey(), err)\n\t\t}\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"request was not propagated to channelPoint\")\n\t}\n\n\tif s2.circuits.NumPending() != 0 {\n\t\tt.Fatalf(\"wrong amount of half circuits, want 1, got %d\",\n\t\t\ts2.circuits.NumPending())\n\t}\n\tif s2.circuits.NumOpen() != 0 {\n\t\tt.Fatal(\"wrong amount of circuits\")\n\t}\n\n\tif err := s2.Stop(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := cdb2.Close(); err != nil {\n\t\tt.Fatalf(err.Error())\n\t}\n\n\tcdb3, err := channeldb.Open(tempPath)\n\trequire.NoError(t, err, \"unable to reopen channeldb\")\n\tt.Cleanup(func() { cdb3.Close() })\n\n\ts3, err := initSwitchWithDB(testStartingHeight, cdb3)\n\trequire.NoError(t, err, \"unable reinit switch\")\n\tif err := s3.Start(); err != nil {\n\t\tt.Fatalf(\"unable to restart switch: %v\", err)\n\t}\n\tdefer s3.Stop()\n\n\taliceChannelLink = newMockChannelLink(\n\t\ts3, chanID1, aliceChanID, emptyScid, alicePeer, true, false,\n\t\tfalse, false,\n\t)\n\tbobChannelLink = newMockChannelLink(\n\t\ts3, chanID2, bobChanID, emptyScid, bobPeer, true, false, false,\n\t\tfalse,\n\t)\n\tif err := s3.AddLink(aliceChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add alice link: %v\", err)\n\t}\n\tif err := s3.AddLink(bobChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add bob link: %v\", err)\n\t}\n\n\tif s3.circuits.NumPending() != 0 {\n\t\tt.Fatalf(\"wrong amount of half circuits\")\n\t}\n\tif s3.circuits.NumOpen() != 0 {\n\t\tt.Fatalf(\"wrong amount of circuits\")\n\t}\n}\n",
      "length": 5972,
      "tokens": 811,
      "embedding": []
    },
    {
      "slug": "type multiHopFwdTest struct {",
      "content": "type multiHopFwdTest struct {\n\tname                 string\n\teligible1, eligible2 bool\n\tfailure1, failure2   *LinkError\n\texpectedReply        lnwire.FailCode\n}\n\n// TestCircularForwards tests the allowing/disallowing of circular payments\n// through the same channel in the case where the switch is configured to allow\n// and disallow same channel circular forwards.",
      "length": 325,
      "tokens": 41,
      "embedding": []
    },
    {
      "slug": "func TestCircularForwards(t *testing.T) {",
      "content": "func TestCircularForwards(t *testing.T) {\n\tchanID1, aliceChanID := genID()\n\tpreimage := [sha256.Size]byte{1}\n\thash := sha256.Sum256(preimage[:])\n\n\ttests := []struct {\n\t\tname                 string\n\t\tallowCircularPayment bool\n\t\texpectedErr          error\n\t}{\n\t\t{\n\t\t\tname:                 \"circular payment allowed\",\n\t\t\tallowCircularPayment: true,\n\t\t\texpectedErr:          nil,\n\t\t},\n\t\t{\n\t\t\tname:                 \"circular payment disallowed\",\n\t\t\tallowCircularPayment: false,\n\t\t\texpectedErr: NewDetailedLinkError(\n\t\t\t\tlnwire.NewTemporaryChannelFailure(nil),\n\t\t\t\tOutgoingFailureCircularRoute,\n\t\t\t),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\talicePeer, err := newMockServer(\n\t\t\t\tt, \"alice\", testStartingHeight, nil,\n\t\t\t\ttestDefaultDelta,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to create alice server: %v\",\n\t\t\t\t\terr)\n\t\t\t}\n\n\t\t\ts, err := initSwitchWithTempDB(t, testStartingHeight)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to init switch: %v\", err)\n\t\t\t}\n\t\t\tif err := s.Start(); err != nil {\n\t\t\t\tt.Fatalf(\"unable to start switch: %v\", err)\n\t\t\t}\n\t\t\tdefer func() { _ = s.Stop() }()\n\n\t\t\t// Set the switch to allow or disallow circular routes\n\t\t\t// according to the test's requirements.\n\t\t\ts.cfg.AllowCircularRoute = test.allowCircularPayment\n\n\t\t\taliceChannelLink := newMockChannelLink(\n\t\t\t\ts, chanID1, aliceChanID, emptyScid, alicePeer,\n\t\t\t\ttrue, false, false, false,\n\t\t\t)\n\n\t\t\tif err := s.AddLink(aliceChannelLink); err != nil {\n\t\t\t\tt.Fatalf(\"unable to add alice link: %v\", err)\n\t\t\t}\n\n\t\t\t// Create a new packet that loops through alice's link\n\t\t\t// in a circle.\n\t\t\tobfuscator := NewMockObfuscator()\n\t\t\tpacket := &htlcPacket{\n\t\t\t\tincomingChanID: aliceChannelLink.ShortChanID(),\n\t\t\t\toutgoingChanID: aliceChannelLink.ShortChanID(),\n\t\t\t\thtlc: &lnwire.UpdateAddHTLC{\n\t\t\t\t\tPaymentHash: hash,\n\t\t\t\t\tAmount:      1,\n\t\t\t\t},\n\t\t\t\tobfuscator: obfuscator,\n\t\t\t}\n\n\t\t\t// Attempt to forward the packet and check for the expected\n\t\t\t// error.\n\t\t\tif err = s.ForwardPackets(nil, packet); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tselect {\n\t\t\tcase p := <-aliceChannelLink.packets:\n\t\t\t\tif p.linkFailure != nil {\n\t\t\t\t\terr = p.linkFailure\n\t\t\t\t}\n\t\t\tcase <-time.After(time.Second):\n\t\t\t\tt.Fatal(\"no timely reply from switch\")\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(err, test.expectedErr) {\n\t\t\t\tt.Fatalf(\"expected: %v, got: %v\",\n\t\t\t\t\ttest.expectedErr, err)\n\t\t\t}\n\n\t\t\t// Ensure that no circuits were opened.\n\t\t\tif s.circuits.NumOpen() > 0 {\n\t\t\t\tt.Fatal(\"do not expect any open circuits\")\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestCheckCircularForward tests the error returned by checkCircularForward\n// in cases where we allow and disallow same channel circular forwards.",
      "length": 2531,
      "tokens": 304,
      "embedding": []
    },
    {
      "slug": "func TestCheckCircularForward(t *testing.T) {",
      "content": "func TestCheckCircularForward(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\n\t\t// aliasMapping determines whether the test should add an alias\n\t\t// mapping to Switch alias maps before checkCircularForward.\n\t\taliasMapping bool\n\n\t\t// allowCircular determines whether we should allow circular\n\t\t// forwards.\n\t\tallowCircular bool\n\n\t\t// incomingLink is the link that the htlc arrived on.\n\t\tincomingLink lnwire.ShortChannelID\n\n\t\t// outgoingLink is the link that the htlc forward\n\t\t// is destined to leave on.\n\t\toutgoingLink lnwire.ShortChannelID\n\n\t\t// expectedErr is the error we expect to be returned.\n\t\texpectedErr *LinkError\n\t}{\n\t\t{\n\t\t\tname:          \"not circular, allowed in config\",\n\t\t\taliasMapping:  false,\n\t\t\tallowCircular: true,\n\t\t\tincomingLink:  lnwire.NewShortChanIDFromInt(123),\n\t\t\toutgoingLink:  lnwire.NewShortChanIDFromInt(321),\n\t\t\texpectedErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:          \"not circular, not allowed in config\",\n\t\t\taliasMapping:  false,\n\t\t\tallowCircular: false,\n\t\t\tincomingLink:  lnwire.NewShortChanIDFromInt(123),\n\t\t\toutgoingLink:  lnwire.NewShortChanIDFromInt(321),\n\t\t\texpectedErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:          \"circular, allowed in config\",\n\t\t\taliasMapping:  false,\n\t\t\tallowCircular: true,\n\t\t\tincomingLink:  lnwire.NewShortChanIDFromInt(123),\n\t\t\toutgoingLink:  lnwire.NewShortChanIDFromInt(123),\n\t\t\texpectedErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:          \"circular, not allowed in config\",\n\t\t\taliasMapping:  false,\n\t\t\tallowCircular: false,\n\t\t\tincomingLink:  lnwire.NewShortChanIDFromInt(123),\n\t\t\toutgoingLink:  lnwire.NewShortChanIDFromInt(123),\n\t\t\texpectedErr: NewDetailedLinkError(\n\t\t\t\tlnwire.NewTemporaryChannelFailure(nil),\n\t\t\t\tOutgoingFailureCircularRoute,\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname:          \"circular with map, not allowed\",\n\t\t\taliasMapping:  true,\n\t\t\tallowCircular: false,\n\t\t\tincomingLink:  lnwire.NewShortChanIDFromInt(1 << 60),\n\t\t\toutgoingLink:  lnwire.NewShortChanIDFromInt(1 << 55),\n\t\t\texpectedErr: NewDetailedLinkError(\n\t\t\t\tlnwire.NewTemporaryChannelFailure(nil),\n\t\t\t\tOutgoingFailureCircularRoute,\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname:          \"circular with map, not allowed 2\",\n\t\t\taliasMapping:  true,\n\t\t\tallowCircular: false,\n\t\t\tincomingLink:  lnwire.NewShortChanIDFromInt(1 << 55),\n\t\t\toutgoingLink:  lnwire.NewShortChanIDFromInt(1 << 60),\n\t\t\texpectedErr: NewDetailedLinkError(\n\t\t\t\tlnwire.NewTemporaryChannelFailure(nil),\n\t\t\t\tOutgoingFailureCircularRoute,\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname:          \"circular with map, allowed\",\n\t\t\taliasMapping:  true,\n\t\t\tallowCircular: true,\n\t\t\tincomingLink:  lnwire.NewShortChanIDFromInt(1 << 60),\n\t\t\toutgoingLink:  lnwire.NewShortChanIDFromInt(1 << 55),\n\t\t\texpectedErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:          \"circular with map, allowed 2\",\n\t\t\taliasMapping:  true,\n\t\t\tallowCircular: true,\n\t\t\tincomingLink:  lnwire.NewShortChanIDFromInt(1 << 55),\n\t\t\toutgoingLink:  lnwire.NewShortChanIDFromInt(1 << 61),\n\t\t\texpectedErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:          \"not circular, both confirmed SCID\",\n\t\t\taliasMapping:  false,\n\t\t\tallowCircular: false,\n\t\t\tincomingLink:  lnwire.NewShortChanIDFromInt(1 << 60),\n\t\t\toutgoingLink:  lnwire.NewShortChanIDFromInt(1 << 61),\n\t\t\texpectedErr:   nil,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\ts, err := initSwitchWithTempDB(t, testStartingHeight)\n\t\t\trequire.NoError(t, err)\n\t\t\terr = s.Start()\n\t\t\trequire.NoError(t, err)\n\t\t\tdefer func() { _ = s.Stop() }()\n\n\t\t\tif test.aliasMapping {\n\t\t\t\t// Make the incoming and outgoing point to the\n\t\t\t\t// same base SCID.\n\t\t\t\tinScid := test.incomingLink\n\t\t\t\toutScid := test.outgoingLink\n\t\t\t\ts.indexMtx.Lock()\n\t\t\t\ts.baseIndex[inScid] = outScid\n\t\t\t\ts.baseIndex[outScid] = outScid\n\t\t\t\ts.indexMtx.Unlock()\n\t\t\t}\n\n\t\t\t// Check for a circular forward, the hash passed can\n\t\t\t// be nil because it is only used for logging.\n\t\t\terr = s.checkCircularForward(\n\t\t\t\ttest.incomingLink, test.outgoingLink,\n\t\t\t\ttest.allowCircular, lntypes.Hash{},\n\t\t\t)\n\t\t\tif !reflect.DeepEqual(err, test.expectedErr) {\n\t\t\t\tt.Fatalf(\"expected: %v, got: %v\",\n\t\t\t\t\ttest.expectedErr, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestSkipIneligibleLinksMultiHopForward tests that if a multi-hop HTLC comes\n// along, then we won't attempt to forward it down al ink that isn't yet able\n// to forward any HTLC's.",
      "length": 4033,
      "tokens": 409,
      "embedding": []
    },
    {
      "slug": "func TestSkipIneligibleLinksMultiHopForward(t *testing.T) {",
      "content": "func TestSkipIneligibleLinksMultiHopForward(t *testing.T) {\n\ttests := []multiHopFwdTest{\n\t\t// None of the channels is eligible.\n\t\t{\n\t\t\tname:          \"not eligible\",\n\t\t\texpectedReply: lnwire.CodeUnknownNextPeer,\n\t\t},\n\n\t\t// Channel one has a policy failure and the other channel isn't\n\t\t// available.\n\t\t{\n\t\t\tname:      \"policy fail\",\n\t\t\teligible1: true,\n\t\t\tfailure1: NewLinkError(\n\t\t\t\tlnwire.NewFinalIncorrectCltvExpiry(0),\n\t\t\t),\n\t\t\texpectedReply: lnwire.CodeFinalIncorrectCltvExpiry,\n\t\t},\n\n\t\t// The requested channel is not eligible, but the packet is\n\t\t// forwarded through the other channel.\n\t\t{\n\t\t\tname:          \"non-strict success\",\n\t\t\teligible2:     true,\n\t\t\texpectedReply: lnwire.CodeNone,\n\t\t},\n\n\t\t// The requested channel has insufficient bandwidth and the\n\t\t// other channel's policy isn't satisfied.\n\t\t{\n\t\t\tname:      \"non-strict policy fail\",\n\t\t\teligible1: true,\n\t\t\tfailure1: NewDetailedLinkError(\n\t\t\t\tlnwire.NewTemporaryChannelFailure(nil),\n\t\t\t\tOutgoingFailureInsufficientBalance,\n\t\t\t),\n\t\t\teligible2: true,\n\t\t\tfailure2: NewLinkError(\n\t\t\t\tlnwire.NewFinalIncorrectCltvExpiry(0),\n\t\t\t),\n\t\t\texpectedReply: lnwire.CodeTemporaryChannelFailure,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\ttestSkipIneligibleLinksMultiHopForward(t, &test)\n\t\t})\n\t}\n}\n\n// testSkipIneligibleLinksMultiHopForward tests that if a multi-hop HTLC comes\n// along, then we won't attempt to forward it down al ink that isn't yet able\n// to forward any HTLC's.",
      "length": 1375,
      "tokens": 156,
      "embedding": []
    },
    {
      "slug": "func testSkipIneligibleLinksMultiHopForward(t *testing.T,",
      "content": "func testSkipIneligibleLinksMultiHopForward(t *testing.T,\n\ttestCase *multiHopFwdTest) {\n\n\tt.Parallel()\n\n\tvar packet *htlcPacket\n\n\talicePeer, err := newMockServer(\n\t\tt, \"alice\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err, \"unable to create alice server\")\n\tbobPeer, err := newMockServer(\n\t\tt, \"bob\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err, \"unable to create bob server\")\n\n\ts, err := initSwitchWithTempDB(t, testStartingHeight)\n\trequire.NoError(t, err, \"unable to init switch\")\n\tif err := s.Start(); err != nil {\n\t\tt.Fatalf(\"unable to start switch: %v\", err)\n\t}\n\tdefer s.Stop()\n\n\tchanID1, aliceChanID := genID()\n\taliceChannelLink := newMockChannelLink(\n\t\ts, chanID1, aliceChanID, emptyScid, alicePeer, true, false,\n\t\tfalse, false,\n\t)\n\n\t// We'll create a link for Bob, but mark the link as unable to forward\n\t// any new outgoing HTLC's.\n\tchanID2, bobChanID2 := genID()\n\tbobChannelLink1 := newMockChannelLink(\n\t\ts, chanID2, bobChanID2, emptyScid, bobPeer, testCase.eligible1,\n\t\tfalse, false, false,\n\t)\n\tbobChannelLink1.checkHtlcForwardResult = testCase.failure1\n\n\tchanID3, bobChanID3 := genID()\n\tbobChannelLink2 := newMockChannelLink(\n\t\ts, chanID3, bobChanID3, emptyScid, bobPeer, testCase.eligible2,\n\t\tfalse, false, false,\n\t)\n\tbobChannelLink2.checkHtlcForwardResult = testCase.failure2\n\n\tif err := s.AddLink(aliceChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add alice link: %v\", err)\n\t}\n\tif err := s.AddLink(bobChannelLink1); err != nil {\n\t\tt.Fatalf(\"unable to add bob link: %v\", err)\n\t}\n\tif err := s.AddLink(bobChannelLink2); err != nil {\n\t\tt.Fatalf(\"unable to add bob link: %v\", err)\n\t}\n\n\t// Create a new packet that's destined for Bob as an incoming HTLC from\n\t// Alice.\n\tpreimage := [sha256.Size]byte{1}\n\trhash := sha256.Sum256(preimage[:])\n\tobfuscator := NewMockObfuscator()\n\tpacket = &htlcPacket{\n\t\tincomingChanID: aliceChannelLink.ShortChanID(),\n\t\tincomingHTLCID: 0,\n\t\toutgoingChanID: bobChannelLink1.ShortChanID(),\n\t\thtlc: &lnwire.UpdateAddHTLC{\n\t\t\tPaymentHash: rhash,\n\t\t\tAmount:      1,\n\t\t},\n\t\tobfuscator: obfuscator,\n\t}\n\n\t// The request to forward should fail as\n\tif err := s.ForwardPackets(nil, packet); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// We select from all links and extract the error if exists.\n\t// The packet must be selected but we don't always expect a link error.\n\tvar linkError *LinkError\n\tselect {\n\tcase p := <-aliceChannelLink.packets:\n\t\tlinkError = p.linkFailure\n\tcase p := <-bobChannelLink1.packets:\n\t\tlinkError = p.linkFailure\n\tcase p := <-bobChannelLink2.packets:\n\t\tlinkError = p.linkFailure\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"no timely reply from switch\")\n\t}\n\tfailure := obfuscator.(*mockObfuscator).failure\n\tif testCase.expectedReply == lnwire.CodeNone {\n\t\tif linkError != nil {\n\t\t\tt.Fatalf(\"forwarding should have succeeded\")\n\t\t}\n\t\tif failure != nil {\n\t\t\tt.Fatalf(\"unexpected failure %T\", failure)\n\t\t}\n\t} else {\n\t\tif linkError == nil {\n\t\t\tt.Fatalf(\"forwarding should have failed due to \" +\n\t\t\t\t\"inactive link\")\n\t\t}\n\t\tif failure.Code() != testCase.expectedReply {\n\t\t\tt.Fatalf(\"unexpected failure %T\", failure)\n\t\t}\n\t}\n\n\tif s.circuits.NumOpen() != 0 {\n\t\tt.Fatal(\"wrong amount of circuits\")\n\t}\n}\n\n// TestSkipIneligibleLinksLocalForward ensures that the switch will not attempt\n// to forward any HTLC's down a link that isn't yet eligible for forwarding.",
      "length": 3174,
      "tokens": 409,
      "embedding": []
    },
    {
      "slug": "func TestSkipIneligibleLinksLocalForward(t *testing.T) {",
      "content": "func TestSkipIneligibleLinksLocalForward(t *testing.T) {\n\tt.Parallel()\n\n\ttestSkipLinkLocalForward(t, false, nil)\n}\n\n// TestSkipPolicyUnsatisfiedLinkLocalForward ensures that the switch will not\n// attempt to send locally initiated HTLCs that would violate the channel policy\n// down a link.",
      "length": 226,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func TestSkipPolicyUnsatisfiedLinkLocalForward(t *testing.T) {",
      "content": "func TestSkipPolicyUnsatisfiedLinkLocalForward(t *testing.T) {\n\tt.Parallel()\n\n\ttestSkipLinkLocalForward(t, true, lnwire.NewTemporaryChannelFailure(nil))\n}\n",
      "length": 88,
      "tokens": 5,
      "embedding": []
    },
    {
      "slug": "func testSkipLinkLocalForward(t *testing.T, eligible bool,",
      "content": "func testSkipLinkLocalForward(t *testing.T, eligible bool,\n\tpolicyResult lnwire.FailureMessage) {\n\n\t// We'll create a single link for this test, marking it as being unable\n\t// to forward form the get go.\n\talicePeer, err := newMockServer(\n\t\tt, \"alice\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err, \"unable to create alice server\")\n\n\ts, err := initSwitchWithTempDB(t, testStartingHeight)\n\trequire.NoError(t, err, \"unable to init switch\")\n\tif err := s.Start(); err != nil {\n\t\tt.Fatalf(\"unable to start switch: %v\", err)\n\t}\n\tdefer s.Stop()\n\n\tchanID1, _, aliceChanID, _ := genIDs()\n\n\taliceChannelLink := newMockChannelLink(\n\t\ts, chanID1, aliceChanID, emptyScid, alicePeer, eligible, false,\n\t\tfalse, false,\n\t)\n\taliceChannelLink.checkHtlcTransitResult = NewLinkError(\n\t\tpolicyResult,\n\t)\n\tif err := s.AddLink(aliceChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add alice link: %v\", err)\n\t}\n\n\tpreimage, err := genPreimage()\n\trequire.NoError(t, err, \"unable to generate preimage\")\n\trhash := sha256.Sum256(preimage[:])\n\taddMsg := &lnwire.UpdateAddHTLC{\n\t\tPaymentHash: rhash,\n\t\tAmount:      1,\n\t}\n\n\t// We'll attempt to send out a new HTLC that has Alice as the first\n\t// outgoing link. This should fail as Alice isn't yet able to forward\n\t// any active HTLC's.\n\terr = s.SendHTLC(aliceChannelLink.ShortChanID(), 0, addMsg)\n\tif err == nil {\n\t\tt.Fatalf(\"local forward should fail due to inactive link\")\n\t}\n\n\tif s.circuits.NumOpen() != 0 {\n\t\tt.Fatal(\"wrong amount of circuits\")\n\t}\n}\n\n// TestSwitchCancel checks that if htlc was rejected we remove unused\n// circuits.",
      "length": 1468,
      "tokens": 205,
      "embedding": []
    },
    {
      "slug": "func TestSwitchCancel(t *testing.T) {",
      "content": "func TestSwitchCancel(t *testing.T) {\n\tt.Parallel()\n\n\talicePeer, err := newMockServer(\n\t\tt, \"alice\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err, \"unable to create alice server\")\n\tbobPeer, err := newMockServer(\n\t\tt, \"bob\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err, \"unable to create bob server\")\n\n\ts, err := initSwitchWithTempDB(t, testStartingHeight)\n\trequire.NoError(t, err, \"unable to init switch\")\n\tif err := s.Start(); err != nil {\n\t\tt.Fatalf(\"unable to start switch: %v\", err)\n\t}\n\tdefer s.Stop()\n\n\tchanID1, chanID2, aliceChanID, bobChanID := genIDs()\n\n\taliceChannelLink := newMockChannelLink(\n\t\ts, chanID1, aliceChanID, emptyScid, alicePeer, true, false,\n\t\tfalse, false,\n\t)\n\tbobChannelLink := newMockChannelLink(\n\t\ts, chanID2, bobChanID, emptyScid, bobPeer, true, false, false,\n\t\tfalse,\n\t)\n\tif err := s.AddLink(aliceChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add alice link: %v\", err)\n\t}\n\tif err := s.AddLink(bobChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add bob link: %v\", err)\n\t}\n\n\t// Create request which should be forwarder from alice channel link\n\t// to bob channel link.\n\tpreimage, err := genPreimage()\n\trequire.NoError(t, err, \"unable to generate preimage\")\n\trhash := sha256.Sum256(preimage[:])\n\trequest := &htlcPacket{\n\t\tincomingChanID: aliceChannelLink.ShortChanID(),\n\t\tincomingHTLCID: 0,\n\t\toutgoingChanID: bobChannelLink.ShortChanID(),\n\t\tobfuscator:     NewMockObfuscator(),\n\t\thtlc: &lnwire.UpdateAddHTLC{\n\t\t\tPaymentHash: rhash,\n\t\t\tAmount:      1,\n\t\t},\n\t}\n\n\t// Handle the request and checks that bob channel link received it.\n\tif err := s.ForwardPackets(nil, request); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tselect {\n\tcase packet := <-bobChannelLink.packets:\n\t\tif err := bobChannelLink.completeCircuit(packet); err != nil {\n\t\t\tt.Fatalf(\"unable to complete payment circuit: %v\", err)\n\t\t}\n\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"request was not propagated to destination\")\n\t}\n\n\tif s.circuits.NumPending() != 1 {\n\t\tt.Fatalf(\"wrong amount of half circuits\")\n\t}\n\tif s.circuits.NumOpen() != 1 {\n\t\tt.Fatal(\"wrong amount of circuits\")\n\t}\n\n\t// Create settle request pretending that bob channel link handled\n\t// the add htlc request and sent the htlc settle request back. This\n\t// request should be forwarder back to alice channel link.\n\trequest = &htlcPacket{\n\t\toutgoingChanID: bobChannelLink.ShortChanID(),\n\t\toutgoingHTLCID: 0,\n\t\tamount:         1,\n\t\thtlc:           &lnwire.UpdateFailHTLC{},\n\t}\n\n\t// Handle the request and checks that payment circuit works properly.\n\tif err := s.ForwardPackets(nil, request); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tselect {\n\tcase pkt := <-aliceChannelLink.packets:\n\t\tif err := aliceChannelLink.completeCircuit(pkt); err != nil {\n\t\t\tt.Fatalf(\"unable to remove circuit: %v\", err)\n\t\t}\n\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"request was not propagated to channelPoint\")\n\t}\n\n\tif s.circuits.NumPending() != 0 {\n\t\tt.Fatal(\"wrong amount of circuits\")\n\t}\n\tif s.circuits.NumOpen() != 0 {\n\t\tt.Fatal(\"wrong amount of circuits\")\n\t}\n}\n\n// TestSwitchAddSamePayment tests that we send the payment with the same\n// payment hash.",
      "length": 2975,
      "tokens": 382,
      "embedding": []
    },
    {
      "slug": "func TestSwitchAddSamePayment(t *testing.T) {",
      "content": "func TestSwitchAddSamePayment(t *testing.T) {\n\tt.Parallel()\n\n\tchanID1, chanID2, aliceChanID, bobChanID := genIDs()\n\n\talicePeer, err := newMockServer(\n\t\tt, \"alice\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err, \"unable to create alice server\")\n\tbobPeer, err := newMockServer(\n\t\tt, \"bob\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err, \"unable to create bob server\")\n\n\ts, err := initSwitchWithTempDB(t, testStartingHeight)\n\trequire.NoError(t, err, \"unable to init switch\")\n\tif err := s.Start(); err != nil {\n\t\tt.Fatalf(\"unable to start switch: %v\", err)\n\t}\n\tdefer s.Stop()\n\n\taliceChannelLink := newMockChannelLink(\n\t\ts, chanID1, aliceChanID, emptyScid, alicePeer, true, false,\n\t\tfalse, false,\n\t)\n\tbobChannelLink := newMockChannelLink(\n\t\ts, chanID2, bobChanID, emptyScid, bobPeer, true, false, false,\n\t\tfalse,\n\t)\n\tif err := s.AddLink(aliceChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add alice link: %v\", err)\n\t}\n\tif err := s.AddLink(bobChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add bob link: %v\", err)\n\t}\n\n\t// Create request which should be forwarder from alice channel link\n\t// to bob channel link.\n\tpreimage, err := genPreimage()\n\trequire.NoError(t, err, \"unable to generate preimage\")\n\trhash := sha256.Sum256(preimage[:])\n\trequest := &htlcPacket{\n\t\tincomingChanID: aliceChannelLink.ShortChanID(),\n\t\tincomingHTLCID: 0,\n\t\toutgoingChanID: bobChannelLink.ShortChanID(),\n\t\tobfuscator:     NewMockObfuscator(),\n\t\thtlc: &lnwire.UpdateAddHTLC{\n\t\t\tPaymentHash: rhash,\n\t\t\tAmount:      1,\n\t\t},\n\t}\n\n\t// Handle the request and checks that bob channel link received it.\n\tif err := s.ForwardPackets(nil, request); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tselect {\n\tcase packet := <-bobChannelLink.packets:\n\t\tif err := bobChannelLink.completeCircuit(packet); err != nil {\n\t\t\tt.Fatalf(\"unable to complete payment circuit: %v\", err)\n\t\t}\n\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"request was not propagated to destination\")\n\t}\n\n\tif s.circuits.NumOpen() != 1 {\n\t\tt.Fatal(\"wrong amount of circuits\")\n\t}\n\n\trequest = &htlcPacket{\n\t\tincomingChanID: aliceChannelLink.ShortChanID(),\n\t\tincomingHTLCID: 1,\n\t\toutgoingChanID: bobChannelLink.ShortChanID(),\n\t\tobfuscator:     NewMockObfuscator(),\n\t\thtlc: &lnwire.UpdateAddHTLC{\n\t\t\tPaymentHash: rhash,\n\t\t\tAmount:      1,\n\t\t},\n\t}\n\n\t// Handle the request and checks that bob channel link received it.\n\tif err := s.ForwardPackets(nil, request); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tselect {\n\tcase packet := <-bobChannelLink.packets:\n\t\tif err := bobChannelLink.completeCircuit(packet); err != nil {\n\t\t\tt.Fatalf(\"unable to complete payment circuit: %v\", err)\n\t\t}\n\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"request was not propagated to destination\")\n\t}\n\n\tif s.circuits.NumOpen() != 2 {\n\t\tt.Fatal(\"wrong amount of circuits\")\n\t}\n\n\t// Create settle request pretending that bob channel link handled\n\t// the add htlc request and sent the htlc settle request back. This\n\t// request should be forwarder back to alice channel link.\n\trequest = &htlcPacket{\n\t\toutgoingChanID: bobChannelLink.ShortChanID(),\n\t\toutgoingHTLCID: 0,\n\t\tamount:         1,\n\t\thtlc:           &lnwire.UpdateFailHTLC{},\n\t}\n\n\t// Handle the request and checks that payment circuit works properly.\n\tif err := s.ForwardPackets(nil, request); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tselect {\n\tcase pkt := <-aliceChannelLink.packets:\n\t\tif err := aliceChannelLink.completeCircuit(pkt); err != nil {\n\t\t\tt.Fatalf(\"unable to remove circuit: %v\", err)\n\t\t}\n\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"request was not propagated to channelPoint\")\n\t}\n\n\tif s.circuits.NumOpen() != 1 {\n\t\tt.Fatal(\"wrong amount of circuits\")\n\t}\n\n\trequest = &htlcPacket{\n\t\toutgoingChanID: bobChannelLink.ShortChanID(),\n\t\toutgoingHTLCID: 1,\n\t\tamount:         1,\n\t\thtlc:           &lnwire.UpdateFailHTLC{},\n\t}\n\n\t// Handle the request and checks that payment circuit works properly.\n\tif err := s.ForwardPackets(nil, request); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tselect {\n\tcase pkt := <-aliceChannelLink.packets:\n\t\tif err := aliceChannelLink.completeCircuit(pkt); err != nil {\n\t\t\tt.Fatalf(\"unable to remove circuit: %v\", err)\n\t\t}\n\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"request was not propagated to channelPoint\")\n\t}\n\n\tif s.circuits.NumOpen() != 0 {\n\t\tt.Fatal(\"wrong amount of circuits\")\n\t}\n}\n\n// TestSwitchSendPayment tests ability of htlc switch to respond to the\n// users when response is came back from channel link.",
      "length": 4203,
      "tokens": 525,
      "embedding": []
    },
    {
      "slug": "func TestSwitchSendPayment(t *testing.T) {",
      "content": "func TestSwitchSendPayment(t *testing.T) {\n\tt.Parallel()\n\n\talicePeer, err := newMockServer(\n\t\tt, \"alice\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err, \"unable to create alice server\")\n\n\ts, err := initSwitchWithTempDB(t, testStartingHeight)\n\trequire.NoError(t, err, \"unable to init switch\")\n\tif err := s.Start(); err != nil {\n\t\tt.Fatalf(\"unable to start switch: %v\", err)\n\t}\n\tdefer s.Stop()\n\n\tchanID1, _, aliceChanID, _ := genIDs()\n\n\taliceChannelLink := newMockChannelLink(\n\t\ts, chanID1, aliceChanID, emptyScid, alicePeer, true, false,\n\t\tfalse, false,\n\t)\n\tif err := s.AddLink(aliceChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add link: %v\", err)\n\t}\n\n\t// Create request which should be forwarder from alice channel link\n\t// to bob channel link.\n\tpreimage, err := genPreimage()\n\trequire.NoError(t, err, \"unable to generate preimage\")\n\trhash := sha256.Sum256(preimage[:])\n\tupdate := &lnwire.UpdateAddHTLC{\n\t\tPaymentHash: rhash,\n\t\tAmount:      1,\n\t}\n\tpaymentID := uint64(123)\n\n\t// First check that the switch will correctly respond that this payment\n\t// ID is unknown.\n\t_, err = s.GetAttemptResult(\n\t\tpaymentID, rhash, newMockDeobfuscator(),\n\t)\n\tif err != ErrPaymentIDNotFound {\n\t\tt.Fatalf(\"expected ErrPaymentIDNotFound, got %v\", err)\n\t}\n\n\t// Handle the request and checks that bob channel link received it.\n\terrChan := make(chan error)\n\tgo func() {\n\t\terr := s.SendHTLC(\n\t\t\taliceChannelLink.ShortChanID(), paymentID, update,\n\t\t)\n\t\tif err != nil {\n\t\t\terrChan <- err\n\t\t\treturn\n\t\t}\n\n\t\tresultChan, err := s.GetAttemptResult(\n\t\t\tpaymentID, rhash, newMockDeobfuscator(),\n\t\t)\n\t\tif err != nil {\n\t\t\terrChan <- err\n\t\t\treturn\n\t\t}\n\n\t\tresult, ok := <-resultChan\n\t\tif !ok {\n\t\t\terrChan <- fmt.Errorf(\"shutting down\")\n\t\t}\n\n\t\tif result.Error != nil {\n\t\t\terrChan <- result.Error\n\t\t\treturn\n\t\t}\n\n\t\terrChan <- nil\n\t}()\n\n\tselect {\n\tcase packet := <-aliceChannelLink.packets:\n\t\tif err := aliceChannelLink.completeCircuit(packet); err != nil {\n\t\t\tt.Fatalf(\"unable to complete payment circuit: %v\", err)\n\t\t}\n\n\tcase err := <-errChan:\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to send payment: %v\", err)\n\t\t}\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"request was not propagated to destination\")\n\t}\n\n\tif s.circuits.NumOpen() != 1 {\n\t\tt.Fatal(\"wrong amount of circuits\")\n\t}\n\n\t// Create fail request pretending that bob channel link handled\n\t// the add htlc request with error and sent the htlc fail request\n\t// back. This request should be forwarded back to alice channel link.\n\tobfuscator := NewMockObfuscator()\n\tfailure := lnwire.NewFailIncorrectDetails(update.Amount, 100)\n\treason, err := obfuscator.EncryptFirstHop(failure)\n\trequire.NoError(t, err, \"unable obfuscate failure\")\n\n\tif s.IsForwardedHTLC(aliceChannelLink.ShortChanID(), update.ID) {\n\t\tt.Fatal(\"htlc should be identified as not forwarded\")\n\t}\n\tpacket := &htlcPacket{\n\t\toutgoingChanID: aliceChannelLink.ShortChanID(),\n\t\toutgoingHTLCID: 0,\n\t\tamount:         1,\n\t\thtlc: &lnwire.UpdateFailHTLC{\n\t\t\tReason: reason,\n\t\t},\n\t}\n\n\tif err := s.ForwardPackets(nil, packet); err != nil {\n\t\tt.Fatalf(\"can't forward htlc packet: %v\", err)\n\t}\n\n\tselect {\n\tcase err := <-errChan:\n\t\tassertFailureCode(\n\t\t\tt, err, lnwire.CodeIncorrectOrUnknownPaymentDetails,\n\t\t)\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"err wasn't received\")\n\t}\n}\n\n// TestLocalPaymentNoForwardingEvents tests that if we send a series of locally\n// initiated payments, then they aren't reflected in the forwarding log.",
      "length": 3253,
      "tokens": 426,
      "embedding": []
    },
    {
      "slug": "func TestLocalPaymentNoForwardingEvents(t *testing.T) {",
      "content": "func TestLocalPaymentNoForwardingEvents(t *testing.T) {\n\tt.Parallel()\n\n\t// First, we'll create our traditional three hop network. We'll only be\n\t// interacting with and asserting the state of the first end point for\n\t// this test.\n\tchannels, _, err := createClusterChannels(\n\t\tt, btcutil.SatoshiPerBitcoin*3, btcutil.SatoshiPerBitcoin*5,\n\t)\n\trequire.NoError(t, err, \"unable to create channel\")\n\n\tn := newThreeHopNetwork(t, channels.aliceToBob, channels.bobToAlice,\n\t\tchannels.bobToCarol, channels.carolToBob, testStartingHeight)\n\tif err := n.start(); err != nil {\n\t\tt.Fatalf(\"unable to start three hop network: %v\", err)\n\t}\n\n\t// We'll now craft and send a payment from Alice to Bob.\n\tamount := lnwire.NewMSatFromSatoshis(btcutil.SatoshiPerBitcoin)\n\thtlcAmt, totalTimelock, hops := generateHops(\n\t\tamount, testStartingHeight, n.firstBobChannelLink,\n\t)\n\n\t// With the payment crafted, we'll send it from Alice to Bob. We'll\n\t// wait for Alice to receive the preimage for the payment before\n\t// proceeding.\n\treceiver := n.bobServer\n\tfirstHop := n.firstBobChannelLink.ShortChanID()\n\t_, err = makePayment(\n\t\tn.aliceServer, receiver, firstHop, hops, amount, htlcAmt,\n\t\ttotalTimelock,\n\t).Wait(30 * time.Second)\n\trequire.NoError(t, err, \"unable to make the payment\")\n\n\t// At this point, we'll forcibly stop the three hop network. Doing\n\t// this will cause any pending forwarding events to be flushed by the\n\t// various switches in the network.\n\tn.stop()\n\n\t// With all the switches stopped, we'll fetch Alice's mock forwarding\n\t// event log.\n\tlog, ok := n.aliceServer.htlcSwitch.cfg.FwdingLog.(*mockForwardingLog)\n\tif !ok {\n\t\tt.Fatalf(\"mockForwardingLog assertion failed\")\n\t}\n\tlog.Lock()\n\tdefer log.Unlock()\n\n\t// If we examine the memory of the forwarding log, then it should be\n\t// blank.\n\tif len(log.events) != 0 {\n\t\tt.Fatalf(\"log should have no events, instead has: %v\",\n\t\t\tspew.Sdump(log.events))\n\t}\n}\n\n// TestMultiHopPaymentForwardingEvents tests that if we send a series of\n// multi-hop payments via Alice->Bob->Carol. Then Bob properly logs forwarding\n// events, while Alice and Carol don't.",
      "length": 1975,
      "tokens": 266,
      "embedding": []
    },
    {
      "slug": "func TestMultiHopPaymentForwardingEvents(t *testing.T) {",
      "content": "func TestMultiHopPaymentForwardingEvents(t *testing.T) {\n\tt.Parallel()\n\n\t// First, we'll create our traditional three hop network.\n\tchannels, _, err := createClusterChannels(\n\t\tt, btcutil.SatoshiPerBitcoin*3, btcutil.SatoshiPerBitcoin*5,\n\t)\n\trequire.NoError(t, err, \"unable to create channel\")\n\n\tn := newThreeHopNetwork(t, channels.aliceToBob, channels.bobToAlice,\n\t\tchannels.bobToCarol, channels.carolToBob, testStartingHeight)\n\tif err := n.start(); err != nil {\n\t\tt.Fatalf(\"unable to start three hop network: %v\", err)\n\t}\n\n\t// We'll make now 10 payments, of 100k satoshis each from Alice to\n\t// Carol via Bob.\n\tconst numPayments = 10\n\tfinalAmt := lnwire.NewMSatFromSatoshis(100000)\n\thtlcAmt, totalTimelock, hops := generateHops(\n\t\tfinalAmt, testStartingHeight, n.firstBobChannelLink,\n\t\tn.carolChannelLink,\n\t)\n\tfirstHop := n.firstBobChannelLink.ShortChanID()\n\tfor i := 0; i < numPayments/2; i++ {\n\t\t_, err := makePayment(\n\t\t\tn.aliceServer, n.carolServer, firstHop, hops, finalAmt,\n\t\t\thtlcAmt, totalTimelock,\n\t\t).Wait(30 * time.Second)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to send payment: %v\", err)\n\t\t}\n\t}\n\n\tbobLog, ok := n.bobServer.htlcSwitch.cfg.FwdingLog.(*mockForwardingLog)\n\tif !ok {\n\t\tt.Fatalf(\"mockForwardingLog assertion failed\")\n\t}\n\n\t// After sending 5 of the payments, trigger the forwarding ticker, to\n\t// make sure the events are properly flushed.\n\tbobTicker, ok := n.bobServer.htlcSwitch.cfg.FwdEventTicker.(*ticker.Force)\n\tif !ok {\n\t\tt.Fatalf(\"mockTicker assertion failed\")\n\t}\n\n\t// We'll trigger the ticker, and wait for the events to appear in Bob's\n\t// forwarding log.\n\ttimeout := time.After(15 * time.Second)\n\tfor {\n\t\tselect {\n\t\tcase bobTicker.Force <- time.Now():\n\t\tcase <-time.After(1 * time.Second):\n\t\t\tt.Fatalf(\"unable to force tick\")\n\t\t}\n\n\t\t// If all 5 events is found in Bob's log, we can break out and\n\t\t// continue the test.\n\t\tbobLog.Lock()\n\t\tif len(bobLog.events) == 5 {\n\t\t\tbobLog.Unlock()\n\t\t\tbreak\n\t\t}\n\t\tbobLog.Unlock()\n\n\t\t// Otherwise wait a little bit before checking again.\n\t\tselect {\n\t\tcase <-time.After(50 * time.Millisecond):\n\t\tcase <-timeout:\n\t\t\tbobLog.Lock()\n\t\t\tdefer bobLog.Unlock()\n\t\t\tt.Fatalf(\"expected 5 events in event log, instead \"+\n\t\t\t\t\"found: %v\", spew.Sdump(bobLog.events))\n\t\t}\n\t}\n\n\t// Send the remaining payments.\n\tfor i := numPayments / 2; i < numPayments; i++ {\n\t\t_, err := makePayment(\n\t\t\tn.aliceServer, n.carolServer, firstHop, hops, finalAmt,\n\t\t\thtlcAmt, totalTimelock,\n\t\t).Wait(30 * time.Second)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to send payment: %v\", err)\n\t\t}\n\t}\n\n\t// With all 10 payments sent. We'll now manually stop each of the\n\t// switches so we can examine their end state.\n\tn.stop()\n\n\t// Alice and Carol shouldn't have any recorded forwarding events, as\n\t// they were the source and the sink for these payment flows.\n\taliceLog, ok := n.aliceServer.htlcSwitch.cfg.FwdingLog.(*mockForwardingLog)\n\tif !ok {\n\t\tt.Fatalf(\"mockForwardingLog assertion failed\")\n\t}\n\taliceLog.Lock()\n\tdefer aliceLog.Unlock()\n\tif len(aliceLog.events) != 0 {\n\t\tt.Fatalf(\"log should have no events, instead has: %v\",\n\t\t\tspew.Sdump(aliceLog.events))\n\t}\n\n\tcarolLog, ok := n.carolServer.htlcSwitch.cfg.FwdingLog.(*mockForwardingLog)\n\tif !ok {\n\t\tt.Fatalf(\"mockForwardingLog assertion failed\")\n\t}\n\tcarolLog.Lock()\n\tdefer carolLog.Unlock()\n\tif len(carolLog.events) != 0 {\n\t\tt.Fatalf(\"log should have no events, instead has: %v\",\n\t\t\tspew.Sdump(carolLog.events))\n\t}\n\n\t// Bob on the other hand, should have 10 events.\n\tbobLog.Lock()\n\tdefer bobLog.Unlock()\n\tif len(bobLog.events) != 10 {\n\t\tt.Fatalf(\"log should have 10 events, instead has: %v\",\n\t\t\tspew.Sdump(bobLog.events))\n\t}\n\n\t// Each of the 10 events should have had all fields set properly.\n\tfor _, event := range bobLog.events {\n\t\t// The incoming and outgoing channels should properly be set for\n\t\t// the event.\n\t\tif event.IncomingChanID != n.aliceChannelLink.ShortChanID() {\n\t\t\tt.Fatalf(\"chan id mismatch: expected %v, got %v\",\n\t\t\t\tevent.IncomingChanID,\n\t\t\t\tn.aliceChannelLink.ShortChanID())\n\t\t}\n\t\tif event.OutgoingChanID != n.carolChannelLink.ShortChanID() {\n\t\t\tt.Fatalf(\"chan id mismatch: expected %v, got %v\",\n\t\t\t\tevent.OutgoingChanID,\n\t\t\t\tn.carolChannelLink.ShortChanID())\n\t\t}\n\n\t\t// Additionally, the incoming and outgoing amounts should also\n\t\t// be properly set.\n\t\tif event.AmtIn != htlcAmt {\n\t\t\tt.Fatalf(\"incoming amt mismatch: expected %v, got %v\",\n\t\t\t\tevent.AmtIn, htlcAmt)\n\t\t}\n\t\tif event.AmtOut != finalAmt {\n\t\t\tt.Fatalf(\"outgoing amt mismatch: expected %v, got %v\",\n\t\t\t\tevent.AmtOut, finalAmt)\n\t\t}\n\t}\n}\n\n// TestUpdateFailMalformedHTLCErrorConversion tests that we're able to properly\n// convert malformed HTLC errors that originate at the direct link, as well as\n// during multi-hop HTLC forwarding.",
      "length": 4484,
      "tokens": 577,
      "embedding": []
    },
    {
      "slug": "func TestUpdateFailMalformedHTLCErrorConversion(t *testing.T) {",
      "content": "func TestUpdateFailMalformedHTLCErrorConversion(t *testing.T) {\n\tt.Parallel()\n\n\t// First, we'll create our traditional three hop network.\n\tchannels, _, err := createClusterChannels(\n\t\tt, btcutil.SatoshiPerBitcoin*3, btcutil.SatoshiPerBitcoin*5,\n\t)\n\trequire.NoError(t, err, \"unable to create channel\")\n\n\tn := newThreeHopNetwork(\n\t\tt, channels.aliceToBob, channels.bobToAlice,\n\t\tchannels.bobToCarol, channels.carolToBob, testStartingHeight,\n\t)\n\tif err := n.start(); err != nil {\n\t\tt.Fatalf(\"unable to start three hop network: %v\", err)\n\t}\n\n\tassertPaymentFailure := func(t *testing.T) {\n\t\t// With the decoder modified, we'll now attempt to send a\n\t\t// payment from Alice to carol.\n\t\tfinalAmt := lnwire.NewMSatFromSatoshis(100000)\n\t\thtlcAmt, totalTimelock, hops := generateHops(\n\t\t\tfinalAmt, testStartingHeight, n.firstBobChannelLink,\n\t\t\tn.carolChannelLink,\n\t\t)\n\t\tfirstHop := n.firstBobChannelLink.ShortChanID()\n\t\t_, err = makePayment(\n\t\t\tn.aliceServer, n.carolServer, firstHop, hops, finalAmt,\n\t\t\thtlcAmt, totalTimelock,\n\t\t).Wait(30 * time.Second)\n\n\t\t// The payment should fail as Carol is unable to decode the\n\t\t// onion blob sent to her.\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"unable to send payment: %v\", err)\n\t\t}\n\n\t\troutingErr := err.(ClearTextError)\n\t\tfailureMsg := routingErr.WireMessage()\n\t\tif _, ok := failureMsg.(*lnwire.FailInvalidOnionKey); !ok {\n\t\t\tt.Fatalf(\"expected onion failure instead got: %v\",\n\t\t\t\troutingErr.WireMessage())\n\t\t}\n\t}\n\n\tt.Run(\"multi-hop error conversion\", func(t *testing.T) {\n\t\t// Now that we have our network up, we'll modify the hop\n\t\t// iterator for the Bob <-> Carol channel to fail to decode in\n\t\t// order to simulate either a replay attack or an issue\n\t\t// decoding the onion.\n\t\tn.carolOnionDecoder.decodeFail = true\n\n\t\tassertPaymentFailure(t)\n\t})\n\n\tt.Run(\"direct channel error conversion\", func(t *testing.T) {\n\t\t// Similar to the above test case, we'll now make the Alice <->\n\t\t// Bob link always fail to decode an onion. This differs from\n\t\t// the above test case in that there's no encryption on the\n\t\t// error at all since Alice will directly receive a\n\t\t// UpdateFailMalformedHTLC message.\n\t\tn.bobOnionDecoder.decodeFail = true\n\n\t\tassertPaymentFailure(t)\n\t})\n}\n\n// TestSwitchGetAttemptResult tests that the switch interacts as expected with\n// the circuit map and network result store when looking up the result of a\n// payment ID. This is important for not to lose results under concurrent\n// lookup and receiving results.",
      "length": 2323,
      "tokens": 313,
      "embedding": []
    },
    {
      "slug": "func TestSwitchGetAttemptResult(t *testing.T) {",
      "content": "func TestSwitchGetAttemptResult(t *testing.T) {\n\tt.Parallel()\n\n\tconst paymentID = 123\n\tvar preimg lntypes.Preimage\n\tpreimg[0] = 3\n\n\ts, err := initSwitchWithTempDB(t, testStartingHeight)\n\trequire.NoError(t, err, \"unable to init switch\")\n\tif err := s.Start(); err != nil {\n\t\tt.Fatalf(\"unable to start switch: %v\", err)\n\t}\n\tdefer s.Stop()\n\n\tlookup := make(chan *PaymentCircuit, 1)\n\ts.circuits = &mockCircuitMap{\n\t\tlookup: lookup,\n\t}\n\n\t// If the payment circuit is not found in the circuit map, the payment\n\t// result must be found in the store if available. Since we haven't\n\t// added anything to the store yet, ErrPaymentIDNotFound should be\n\t// returned.\n\tlookup <- nil\n\t_, err = s.GetAttemptResult(\n\t\tpaymentID, lntypes.Hash{}, newMockDeobfuscator(),\n\t)\n\tif err != ErrPaymentIDNotFound {\n\t\tt.Fatalf(\"expected ErrPaymentIDNotFound, got %v\", err)\n\t}\n\n\t// Next let the lookup find the circuit in the circuit map. It should\n\t// subscribe to payment results, and return the result when available.\n\tlookup <- &PaymentCircuit{}\n\tresultChan, err := s.GetAttemptResult(\n\t\tpaymentID, lntypes.Hash{}, newMockDeobfuscator(),\n\t)\n\trequire.NoError(t, err, \"unable to get payment result\")\n\n\t// Add the result to the store.\n\tn := &networkResult{\n\t\tmsg: &lnwire.UpdateFulfillHTLC{\n\t\t\tPaymentPreimage: preimg,\n\t\t},\n\t\tunencrypted:  true,\n\t\tisResolution: true,\n\t}\n\n\terr = s.networkResults.storeResult(paymentID, n)\n\trequire.NoError(t, err, \"unable to store result\")\n\n\t// The result should be available.\n\tselect {\n\tcase res, ok := <-resultChan:\n\t\tif !ok {\n\t\t\tt.Fatalf(\"channel was closed\")\n\t\t}\n\n\t\tif res.Error != nil {\n\t\t\tt.Fatalf(\"got unexpected error result\")\n\t\t}\n\n\t\tif res.Preimage != preimg {\n\t\t\tt.Fatalf(\"expected preimg %v, got %v\",\n\t\t\t\tpreimg, res.Preimage)\n\t\t}\n\n\tcase <-time.After(1 * time.Second):\n\t\tt.Fatalf(\"result not received\")\n\t}\n\n\t// As a final test, try to get the result again. Now that is no longer\n\t// in the circuit map, it should be immediately available from the\n\t// store.\n\tlookup <- nil\n\tresultChan, err = s.GetAttemptResult(\n\t\tpaymentID, lntypes.Hash{}, newMockDeobfuscator(),\n\t)\n\trequire.NoError(t, err, \"unable to get payment result\")\n\n\tselect {\n\tcase res, ok := <-resultChan:\n\t\tif !ok {\n\t\t\tt.Fatalf(\"channel was closed\")\n\t\t}\n\n\t\tif res.Error != nil {\n\t\t\tt.Fatalf(\"got unexpected error result\")\n\t\t}\n\n\t\tif res.Preimage != preimg {\n\t\t\tt.Fatalf(\"expected preimg %v, got %v\",\n\t\t\t\tpreimg, res.Preimage)\n\t\t}\n\n\tcase <-time.After(1 * time.Second):\n\t\tt.Fatalf(\"result not received\")\n\t}\n}\n\n// TestInvalidFailure tests that the switch returns an unreadable failure error\n// if the failure cannot be decrypted.",
      "length": 2454,
      "tokens": 347,
      "embedding": []
    },
    {
      "slug": "func TestInvalidFailure(t *testing.T) {",
      "content": "func TestInvalidFailure(t *testing.T) {\n\tt.Parallel()\n\n\talicePeer, err := newMockServer(\n\t\tt, \"alice\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err, \"unable to create alice server\")\n\n\ts, err := initSwitchWithTempDB(t, testStartingHeight)\n\trequire.NoError(t, err, \"unable to init switch\")\n\tif err := s.Start(); err != nil {\n\t\tt.Fatalf(\"unable to start switch: %v\", err)\n\t}\n\tdefer s.Stop()\n\n\tchanID1, _, aliceChanID, _ := genIDs()\n\n\t// Set up a mock channel link.\n\taliceChannelLink := newMockChannelLink(\n\t\ts, chanID1, aliceChanID, emptyScid, alicePeer, true, false,\n\t\tfalse, false,\n\t)\n\tif err := s.AddLink(aliceChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add link: %v\", err)\n\t}\n\n\t// Create a request which should be forwarded to the mock channel link.\n\tpreimage, err := genPreimage()\n\trequire.NoError(t, err, \"unable to generate preimage\")\n\trhash := sha256.Sum256(preimage[:])\n\tupdate := &lnwire.UpdateAddHTLC{\n\t\tPaymentHash: rhash,\n\t\tAmount:      1,\n\t}\n\n\tpaymentID := uint64(123)\n\n\t// Send the request.\n\terr = s.SendHTLC(\n\t\taliceChannelLink.ShortChanID(), paymentID, update,\n\t)\n\trequire.NoError(t, err, \"unable to send payment\")\n\n\t// Catch the packet and complete the circuit so that the switch is ready\n\t// for a response.\n\tselect {\n\tcase packet := <-aliceChannelLink.packets:\n\t\tif err := aliceChannelLink.completeCircuit(packet); err != nil {\n\t\t\tt.Fatalf(\"unable to complete payment circuit: %v\", err)\n\t\t}\n\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"request was not propagated to destination\")\n\t}\n\n\t// Send response packet with an unreadable failure message to the\n\t// switch. The reason failed is not relevant, because we mock the\n\t// decryption.\n\tpacket := &htlcPacket{\n\t\toutgoingChanID: aliceChannelLink.ShortChanID(),\n\t\toutgoingHTLCID: 0,\n\t\tamount:         1,\n\t\thtlc: &lnwire.UpdateFailHTLC{\n\t\t\tReason: []byte{1, 2, 3},\n\t\t},\n\t}\n\n\tif err := s.ForwardPackets(nil, packet); err != nil {\n\t\tt.Fatalf(\"can't forward htlc packet: %v\", err)\n\t}\n\n\t// Get payment result from switch. We expect an unreadable failure\n\t// message error.\n\tdeobfuscator := SphinxErrorDecrypter{\n\t\tOnionErrorDecrypter: &mockOnionErrorDecryptor{\n\t\t\terr: ErrUnreadableFailureMessage,\n\t\t},\n\t}\n\n\tresultChan, err := s.GetAttemptResult(\n\t\tpaymentID, rhash, &deobfuscator,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tselect {\n\tcase result := <-resultChan:\n\t\tif result.Error != ErrUnreadableFailureMessage {\n\t\t\tt.Fatal(\"expected unreadable failure message\")\n\t\t}\n\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"err wasn't received\")\n\t}\n\n\t// Modify the decryption to simulate that decryption went alright, but\n\t// the failure cannot be decoded.\n\tdeobfuscator = SphinxErrorDecrypter{\n\t\tOnionErrorDecrypter: &mockOnionErrorDecryptor{\n\t\t\tsourceIdx: 2,\n\t\t\tmessage:   []byte{200},\n\t\t},\n\t}\n\n\tresultChan, err = s.GetAttemptResult(\n\t\tpaymentID, rhash, &deobfuscator,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tselect {\n\tcase result := <-resultChan:\n\t\trtErr, ok := result.Error.(ClearTextError)\n\t\tif !ok {\n\t\t\tt.Fatal(\"expected ClearTextError\")\n\t\t}\n\t\tsource, ok := rtErr.(*ForwardingError)\n\t\tif !ok {\n\t\t\tt.Fatalf(\"expected forwarding error, got: %T\", rtErr)\n\t\t}\n\t\tif source.FailureSourceIdx != 2 {\n\t\t\tt.Fatal(\"unexpected error source index\")\n\t\t}\n\t\tif rtErr.WireMessage() != nil {\n\t\t\tt.Fatal(\"expected empty failure message\")\n\t\t}\n\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"err wasn't received\")\n\t}\n}\n\n// htlcNotifierEvents is a function that generates a set of expected htlc\n// notifier evetns for each node in a three hop network with the dynamic\n// values provided. These functions take dynamic values so that changes to\n// external systems (such as our default timelock delta) do not break\n// these tests.",
      "length": 3506,
      "tokens": 461,
      "embedding": []
    },
    {
      "slug": "type htlcNotifierEvents func(channels *clusterChannels, htlcID uint64,",
      "content": "type htlcNotifierEvents func(channels *clusterChannels, htlcID uint64,\n\tts time.Time, htlc *lnwire.UpdateAddHTLC,\n\thops []*hop.Payload,\n\tpreimage *lntypes.Preimage) ([]interface{}, []interface{}, []interface{})\n\n// TestHtlcNotifier tests the notifying of htlc events that are routed over a\n// three hop network. It sets up an Alice -> Bob -> Carol network and routes\n// payments from Alice -> Carol to test events from the perspective of a\n// sending (Alice), forwarding (Bob) and receiving (Carol) node. Test cases\n// are present for saduccessful and failed payments.",
      "length": 489,
      "tokens": 73,
      "embedding": []
    },
    {
      "slug": "func TestHtlcNotifier(t *testing.T) {",
      "content": "func TestHtlcNotifier(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\n\t\t// Options is a set of options to apply to the three hop\n\t\t// network's servers.\n\t\toptions []serverOption\n\n\t\t// expectedEvents is a function which returns an expected set\n\t\t// of events for the test.\n\t\texpectedEvents htlcNotifierEvents\n\n\t\t// iterations is the number of times we will send a payment,\n\t\t// this is used to send more than one payment to force non-\n\t\t// zero htlc indexes to make sure we aren't just checking\n\t\t// default values.\n\t\titerations int\n\t}{\n\t\t{\n\t\t\tname:    \"successful three hop payment\",\n\t\t\toptions: nil,\n\t\t\texpectedEvents: func(channels *clusterChannels,\n\t\t\t\thtlcID uint64, ts time.Time,\n\t\t\t\thtlc *lnwire.UpdateAddHTLC,\n\t\t\t\thops []*hop.Payload,\n\t\t\t\tpreimage *lntypes.Preimage) ([]interface{},\n\t\t\t\t[]interface{}, []interface{}) {\n\n\t\t\t\treturn getThreeHopEvents(\n\t\t\t\t\tchannels, htlcID, ts, htlc, hops, nil, preimage,\n\t\t\t\t)\n\t\t\t},\n\t\t\titerations: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"failed at forwarding link\",\n\t\t\t// Set a functional option which disables bob as a\n\t\t\t// forwarding node to force a payment error.\n\t\t\toptions: []serverOption{\n\t\t\t\tserverOptionRejectHtlc(false, true, false),\n\t\t\t},\n\t\t\texpectedEvents: func(channels *clusterChannels,\n\t\t\t\thtlcID uint64, ts time.Time,\n\t\t\t\thtlc *lnwire.UpdateAddHTLC,\n\t\t\t\thops []*hop.Payload,\n\t\t\t\tpreimage *lntypes.Preimage) ([]interface{},\n\t\t\t\t[]interface{}, []interface{}) {\n\n\t\t\t\treturn getThreeHopEvents(\n\t\t\t\t\tchannels, htlcID, ts, htlc, hops,\n\t\t\t\t\t&LinkError{\n\t\t\t\t\t\tmsg:           &lnwire.FailChannelDisabled{},\n\t\t\t\t\t\tFailureDetail: OutgoingFailureForwardsDisabled,\n\t\t\t\t\t},\n\t\t\t\t\tpreimage,\n\t\t\t\t)\n\t\t\t},\n\t\t\titerations: 1,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\ttestHtcNotifier(\n\t\t\t\tt, test.options, test.iterations,\n\t\t\t\ttest.expectedEvents,\n\t\t\t)\n\t\t})\n\t}\n}\n\n// testHtcNotifier runs a htlc notifier test.",
      "length": 1776,
      "tokens": 220,
      "embedding": []
    },
    {
      "slug": "func testHtcNotifier(t *testing.T, testOpts []serverOption, iterations int,",
      "content": "func testHtcNotifier(t *testing.T, testOpts []serverOption, iterations int,\n\tgetEvents htlcNotifierEvents) {\n\n\tt.Parallel()\n\n\t// First, we'll create our traditional three hop\n\t// network.\n\tchannels, _, err := createClusterChannels(\n\t\tt, btcutil.SatoshiPerBitcoin*3, btcutil.SatoshiPerBitcoin*5,\n\t)\n\trequire.NoError(t, err, \"unable to create channel\")\n\n\t// Mock time so that all events are reported with a static timestamp.\n\tnow := time.Now()\n\tmockTime := func() time.Time {\n\t\treturn now\n\t}\n\n\t// Create htlc notifiers for each server in the three hop network and\n\t// start them.\n\taliceNotifier := NewHtlcNotifier(mockTime)\n\tif err := aliceNotifier.Start(); err != nil {\n\t\tt.Fatalf(\"could not start alice notifier\")\n\t}\n\tt.Cleanup(func() {\n\t\tif err := aliceNotifier.Stop(); err != nil {\n\t\t\tt.Fatalf(\"failed to stop alice notifier: %v\", err)\n\t\t}\n\t})\n\n\tbobNotifier := NewHtlcNotifier(mockTime)\n\tif err := bobNotifier.Start(); err != nil {\n\t\tt.Fatalf(\"could not start bob notifier\")\n\t}\n\tt.Cleanup(func() {\n\t\tif err := bobNotifier.Stop(); err != nil {\n\t\t\tt.Fatalf(\"failed to stop bob notifier: %v\", err)\n\t\t}\n\t})\n\n\tcarolNotifier := NewHtlcNotifier(mockTime)\n\tif err := carolNotifier.Start(); err != nil {\n\t\tt.Fatalf(\"could not start carol notifier\")\n\t}\n\tt.Cleanup(func() {\n\t\tif err := carolNotifier.Stop(); err != nil {\n\t\t\tt.Fatalf(\"failed to stop carol notifier: %v\", err)\n\t\t}\n\t})\n\n\t// Create a notifier server option which will set our htlc notifiers\n\t// for the three hop network.\n\tnotifierOption := serverOptionWithHtlcNotifier(\n\t\taliceNotifier, bobNotifier, carolNotifier,\n\t)\n\n\t// Add the htlcNotifier option to any other options\n\t// set in the test.\n\toptions := append(testOpts, notifierOption) // nolint:gocritic\n\n\tn := newThreeHopNetwork(\n\t\tt, channels.aliceToBob,\n\t\tchannels.bobToAlice, channels.bobToCarol,\n\t\tchannels.carolToBob, testStartingHeight,\n\t\toptions...,\n\t)\n\tif err := n.start(); err != nil {\n\t\tt.Fatalf(\"unable to start three hop \"+\n\t\t\t\"network: %v\", err)\n\t}\n\tt.Cleanup(n.stop)\n\n\t// Before we forward anything, subscribe to htlc events\n\t// from each notifier.\n\taliceEvents, err := aliceNotifier.SubscribeHtlcEvents()\n\tif err != nil {\n\t\tt.Fatalf(\"could not subscribe to alice's\"+\n\t\t\t\" events: %v\", err)\n\t}\n\tt.Cleanup(aliceEvents.Cancel)\n\n\tbobEvents, err := bobNotifier.SubscribeHtlcEvents()\n\tif err != nil {\n\t\tt.Fatalf(\"could not subscribe to bob's\"+\n\t\t\t\" events: %v\", err)\n\t}\n\tt.Cleanup(bobEvents.Cancel)\n\n\tcarolEvents, err := carolNotifier.SubscribeHtlcEvents()\n\tif err != nil {\n\t\tt.Fatalf(\"could not subscribe to carol's\"+\n\t\t\t\" events: %v\", err)\n\t}\n\tt.Cleanup(carolEvents.Cancel)\n\n\t// Send multiple payments, as specified by the test to test incrementing\n\t// of htlc ids.\n\tfor i := 0; i < iterations; i++ {\n\t\t// We'll start off by making a payment from\n\t\t// Alice -> Bob -> Carol. The preimage, generated\n\t\t// by Carol's Invoice is expected in the Settle events\n\t\thtlc, hops, preimage := n.sendThreeHopPayment(t)\n\n\t\talice, bob, carol := getEvents(\n\t\t\tchannels, uint64(i), now, htlc, hops, preimage,\n\t\t)\n\n\t\tcheckHtlcEvents(t, aliceEvents.Updates(), alice)\n\t\tcheckHtlcEvents(t, bobEvents.Updates(), bob)\n\t\tcheckHtlcEvents(t, carolEvents.Updates(), carol)\n\t}\n}\n\n// checkHtlcEvents checks that a subscription has the set of htlc events\n// we expect it to have.",
      "length": 3081,
      "tokens": 424,
      "embedding": []
    },
    {
      "slug": "func checkHtlcEvents(t *testing.T, events <-chan interface{},",
      "content": "func checkHtlcEvents(t *testing.T, events <-chan interface{},\n\texpectedEvents []interface{}) {\n\n\tt.Helper()\n\n\tfor _, expected := range expectedEvents {\n\t\tselect {\n\t\tcase event := <-events:\n\t\t\tif !reflect.DeepEqual(event, expected) {\n\t\t\t\tt.Fatalf(\"expected %v, got: %v\", expected,\n\t\t\t\t\tevent)\n\t\t\t}\n\n\t\tcase <-time.After(5 * time.Second):\n\t\t\tt.Fatalf(\"expected event: %v\", expected)\n\t\t}\n\t}\n\n\t// Check that there are no unexpected events following.\n\tselect {\n\tcase event := <-events:\n\t\tt.Fatalf(\"unexpected event: %v\", event)\n\tdefault:\n\t}\n}\n\n// sendThreeHopPayment is a helper function which sends a payment over\n// Alice -> Bob -> Carol in a three hop network and returns Alice's first htlc\n// and the remainder of the hops.",
      "length": 632,
      "tokens": 94,
      "embedding": []
    },
    {
      "slug": "func (n *threeHopNetwork) sendThreeHopPayment(t *testing.T) (*lnwire.UpdateAddHTLC,",
      "content": "func (n *threeHopNetwork) sendThreeHopPayment(t *testing.T) (*lnwire.UpdateAddHTLC,\n\t[]*hop.Payload, *lntypes.Preimage) {\n\n\tamount := lnwire.NewMSatFromSatoshis(btcutil.SatoshiPerBitcoin)\n\n\thtlcAmt, totalTimelock, hops := generateHops(amount, testStartingHeight,\n\t\tn.firstBobChannelLink, n.carolChannelLink)\n\tblob, err := generateRoute(hops...)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tinvoice, htlc, pid, err := generatePayment(\n\t\tamount, htlcAmt, totalTimelock, blob,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = n.carolServer.registry.AddInvoice(*invoice, htlc.PaymentHash)\n\trequire.NoError(t, err, \"unable to add invoice in carol registry\")\n\n\tif err := n.aliceServer.htlcSwitch.SendHTLC(\n\t\tn.firstBobChannelLink.ShortChanID(), pid, htlc,\n\t); err != nil {\n\t\tt.Fatalf(\"could not send htlc\")\n\t}\n\n\treturn htlc, hops, invoice.Terms.PaymentPreimage\n}\n\n// getThreeHopEvents gets the set of htlc events that we expect for a payment\n// from Alice -> Bob -> Carol. If a non-nil link error is provided, the set\n// of events will fail on Bob's outgoing link.",
      "length": 931,
      "tokens": 117,
      "embedding": []
    },
    {
      "slug": "func getThreeHopEvents(channels *clusterChannels, htlcID uint64,",
      "content": "func getThreeHopEvents(channels *clusterChannels, htlcID uint64,\n\tts time.Time, htlc *lnwire.UpdateAddHTLC, hops []*hop.Payload,\n\tlinkError *LinkError,\n\tpreimage *lntypes.Preimage) ([]interface{}, []interface{}, []interface{}) {\n\n\taliceKey := HtlcKey{\n\t\tIncomingCircuit: zeroCircuit,\n\t\tOutgoingCircuit: models.CircuitKey{\n\t\t\tChanID: channels.aliceToBob.ShortChanID(),\n\t\t\tHtlcID: htlcID,\n\t\t},\n\t}\n\n\t// Alice always needs a forwarding event because she initiates the\n\t// send.\n\taliceEvents := []interface{}{\n\t\t&ForwardingEvent{\n\t\t\tHtlcKey: aliceKey,\n\t\t\tHtlcInfo: HtlcInfo{\n\t\t\t\tOutgoingTimeLock: htlc.Expiry,\n\t\t\t\tOutgoingAmt:      htlc.Amount,\n\t\t\t},\n\t\t\tHtlcEventType: HtlcEventTypeSend,\n\t\t\tTimestamp:     ts,\n\t\t},\n\t}\n\n\tbobKey := HtlcKey{\n\t\tIncomingCircuit: models.CircuitKey{\n\t\t\tChanID: channels.bobToAlice.ShortChanID(),\n\t\t\tHtlcID: htlcID,\n\t\t},\n\t\tOutgoingCircuit: models.CircuitKey{\n\t\t\tChanID: channels.bobToCarol.ShortChanID(),\n\t\t\tHtlcID: htlcID,\n\t\t},\n\t}\n\n\tbobInfo := HtlcInfo{\n\t\tIncomingTimeLock: htlc.Expiry,\n\t\tIncomingAmt:      htlc.Amount,\n\t\tOutgoingTimeLock: hops[1].FwdInfo.OutgoingCTLV,\n\t\tOutgoingAmt:      hops[1].FwdInfo.AmountToForward,\n\t}\n\n\t// If we expect the payment to fail, we add failures for alice and\n\t// bob, and no events for carol because the payment never reaches her.\n\tif linkError != nil {\n\t\taliceEvents = append(aliceEvents,\n\t\t\t&ForwardingFailEvent{\n\t\t\t\tHtlcKey:       aliceKey,\n\t\t\t\tHtlcEventType: HtlcEventTypeSend,\n\t\t\t\tTimestamp:     ts,\n\t\t\t},\n\t\t)\n\n\t\tbobEvents := []interface{}{\n\t\t\t&LinkFailEvent{\n\t\t\t\tHtlcKey:       bobKey,\n\t\t\t\tHtlcInfo:      bobInfo,\n\t\t\t\tHtlcEventType: HtlcEventTypeForward,\n\t\t\t\tLinkError:     linkError,\n\t\t\t\tIncoming:      false,\n\t\t\t\tTimestamp:     ts,\n\t\t\t},\n\t\t\t&FinalHtlcEvent{\n\t\t\t\tCircuitKey: bobKey.IncomingCircuit,\n\t\t\t\tSettled:    false,\n\t\t\t\tOffchain:   true,\n\t\t\t\tTimestamp:  ts,\n\t\t\t},\n\t\t}\n\n\t\treturn aliceEvents, bobEvents, nil\n\t}\n\n\t// If we want to get events for a successful payment, we add a settle\n\t// for alice, a forward and settle for bob and a receive settle for\n\t// carol.\n\taliceEvents = append(\n\t\taliceEvents,\n\t\t&SettleEvent{\n\t\t\tHtlcKey:       aliceKey,\n\t\t\tPreimage:      *preimage,\n\t\t\tHtlcEventType: HtlcEventTypeSend,\n\t\t\tTimestamp:     ts,\n\t\t},\n\t)\n\n\tbobEvents := []interface{}{\n\t\t&ForwardingEvent{\n\t\t\tHtlcKey:       bobKey,\n\t\t\tHtlcInfo:      bobInfo,\n\t\t\tHtlcEventType: HtlcEventTypeForward,\n\t\t\tTimestamp:     ts,\n\t\t},\n\t\t&SettleEvent{\n\t\t\tHtlcKey:       bobKey,\n\t\t\tPreimage:      *preimage,\n\t\t\tHtlcEventType: HtlcEventTypeForward,\n\t\t\tTimestamp:     ts,\n\t\t},\n\t\t&FinalHtlcEvent{\n\t\t\tCircuitKey: bobKey.IncomingCircuit,\n\t\t\tSettled:    true,\n\t\t\tOffchain:   true,\n\t\t\tTimestamp:  ts,\n\t\t},\n\t}\n\n\tcarolEvents := []interface{}{\n\t\t&SettleEvent{\n\t\t\tHtlcKey: HtlcKey{\n\t\t\t\tIncomingCircuit: models.CircuitKey{\n\t\t\t\t\tChanID: channels.carolToBob.ShortChanID(),\n\t\t\t\t\tHtlcID: htlcID,\n\t\t\t\t},\n\t\t\t\tOutgoingCircuit: zeroCircuit,\n\t\t\t},\n\t\t\tPreimage:      *preimage,\n\t\t\tHtlcEventType: HtlcEventTypeReceive,\n\t\t\tTimestamp:     ts,\n\t\t}, &FinalHtlcEvent{\n\t\t\tCircuitKey: models.CircuitKey{\n\t\t\t\tChanID: channels.carolToBob.ShortChanID(),\n\t\t\t\tHtlcID: htlcID,\n\t\t\t},\n\t\t\tSettled:   true,\n\t\t\tOffchain:  true,\n\t\t\tTimestamp: ts,\n\t\t},\n\t}\n\n\treturn aliceEvents, bobEvents, carolEvents\n}\n",
      "length": 3004,
      "tokens": 290,
      "embedding": []
    },
    {
      "slug": "type mockForwardInterceptor struct {",
      "content": "type mockForwardInterceptor struct {\n\tt *testing.T\n\n\tinterceptedChan chan InterceptedPacket\n}\n",
      "length": 53,
      "tokens": 6,
      "embedding": []
    },
    {
      "slug": "func (m *mockForwardInterceptor) InterceptForwardHtlc(",
      "content": "func (m *mockForwardInterceptor) InterceptForwardHtlc(\n\tintercepted InterceptedPacket) error {\n\n\tm.interceptedChan <- intercepted\n\n\treturn nil\n}\n",
      "length": 84,
      "tokens": 10,
      "embedding": []
    },
    {
      "slug": "func (m *mockForwardInterceptor) getIntercepted() InterceptedPacket {",
      "content": "func (m *mockForwardInterceptor) getIntercepted() InterceptedPacket {\n\tm.t.Helper()\n\n\tselect {\n\tcase p := <-m.interceptedChan:\n\t\treturn p\n\n\tcase <-time.After(time.Second):\n\t\trequire.Fail(m.t, \"timeout\")\n\n\t\treturn InterceptedPacket{}\n\t}\n}\n",
      "length": 156,
      "tokens": 17,
      "embedding": []
    },
    {
      "slug": "func assertNumCircuits(t *testing.T, s *Switch, pending, opened int) {",
      "content": "func assertNumCircuits(t *testing.T, s *Switch, pending, opened int) {\n\tif s.circuits.NumPending() != pending {\n\t\tt.Fatalf(\"wrong amount of half circuits, expected %v but \"+\n\t\t\t\"got %v\", pending, s.circuits.NumPending())\n\t}\n\tif s.circuits.NumOpen() != opened {\n\t\tt.Fatalf(\"wrong amount of circuits, expected %v but got %v\",\n\t\t\topened, s.circuits.NumOpen())\n\t}\n}\n",
      "length": 282,
      "tokens": 37,
      "embedding": []
    },
    {
      "slug": "func assertOutgoingLinkReceive(t *testing.T, targetLink *mockChannelLink,",
      "content": "func assertOutgoingLinkReceive(t *testing.T, targetLink *mockChannelLink,\n\texpectReceive bool) *htlcPacket {\n\n\t// Pull packet from targetLink link.\n\tselect {\n\tcase packet := <-targetLink.packets:\n\t\tif !expectReceive {\n\t\t\tt.Fatal(\"forward was intercepted, shouldn't land at bob link\")\n\t\t} else if err := targetLink.completeCircuit(packet); err != nil {\n\t\t\tt.Fatalf(\"unable to complete payment circuit: %v\", err)\n\t\t}\n\n\t\treturn packet\n\n\tcase <-time.After(time.Second):\n\t\tif expectReceive {\n\t\t\tt.Fatal(\"request was not propagated to destination\")\n\t\t}\n\t}\n\n\treturn nil\n}\n",
      "length": 470,
      "tokens": 63,
      "embedding": []
    },
    {
      "slug": "func assertOutgoingLinkReceiveIntercepted(t *testing.T,",
      "content": "func assertOutgoingLinkReceiveIntercepted(t *testing.T,\n\ttargetLink *mockChannelLink) {\n\n\tt.Helper()\n\n\tselect {\n\tcase <-targetLink.packets:\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"request was not propagated to destination\")\n\t}\n}\n",
      "length": 167,
      "tokens": 18,
      "embedding": []
    },
    {
      "slug": "type interceptableSwitchTestContext struct {",
      "content": "type interceptableSwitchTestContext struct {\n\tt *testing.T\n\n\tpreimage           [sha256.Size]byte\n\trhash              [32]byte\n\tonionBlob          [1366]byte\n\tincomingHtlcID     uint64\n\tcltvRejectDelta    uint32\n\tcltvInterceptDelta uint32\n\n\tforwardInterceptor *mockForwardInterceptor\n\taliceChannelLink   *mockChannelLink\n\tbobChannelLink     *mockChannelLink\n\ts                  *Switch\n}\n",
      "length": 329,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func newInterceptableSwitchTestContext(",
      "content": "func newInterceptableSwitchTestContext(\n\tt *testing.T) *interceptableSwitchTestContext {\n\n\tchanID1, chanID2, aliceChanID, bobChanID := genIDs()\n\n\talicePeer, err := newMockServer(\n\t\tt, \"alice\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err, \"unable to create alice server\")\n\tbobPeer, err := newMockServer(\n\t\tt, \"bob\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err, \"unable to create bob server\")\n\n\ttempPath := t.TempDir()\n\n\tcdb, err := channeldb.Open(tempPath)\n\trequire.NoError(t, err, \"unable to open channeldb\")\n\tt.Cleanup(func() { cdb.Close() })\n\n\ts, err := initSwitchWithDB(testStartingHeight, cdb)\n\trequire.NoError(t, err, \"unable to init switch\")\n\tif err := s.Start(); err != nil {\n\t\tt.Fatalf(\"unable to start switch: %v\", err)\n\t}\n\n\taliceChannelLink := newMockChannelLink(\n\t\ts, chanID1, aliceChanID, emptyScid, alicePeer, true, false,\n\t\tfalse, false,\n\t)\n\tbobChannelLink := newMockChannelLink(\n\t\ts, chanID2, bobChanID, emptyScid, bobPeer, true, false, false,\n\t\tfalse,\n\t)\n\tif err := s.AddLink(aliceChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add alice link: %v\", err)\n\t}\n\tif err := s.AddLink(bobChannelLink); err != nil {\n\t\tt.Fatalf(\"unable to add bob link: %v\", err)\n\t}\n\n\tpreimage := [sha256.Size]byte{1}\n\n\tctx := &interceptableSwitchTestContext{\n\t\tt:                  t,\n\t\tpreimage:           preimage,\n\t\trhash:              sha256.Sum256(preimage[:]),\n\t\tonionBlob:          [1366]byte{4, 5, 6},\n\t\tincomingHtlcID:     uint64(0),\n\t\tcltvRejectDelta:    10,\n\t\tcltvInterceptDelta: 13,\n\t\tforwardInterceptor: &mockForwardInterceptor{\n\t\t\tt:               t,\n\t\t\tinterceptedChan: make(chan InterceptedPacket),\n\t\t},\n\t\taliceChannelLink: aliceChannelLink,\n\t\tbobChannelLink:   bobChannelLink,\n\t\ts:                s,\n\t}\n\n\treturn ctx\n}\n",
      "length": 1678,
      "tokens": 185,
      "embedding": []
    },
    {
      "slug": "func (c *interceptableSwitchTestContext) createTestPacket() *htlcPacket {",
      "content": "func (c *interceptableSwitchTestContext) createTestPacket() *htlcPacket {\n\tc.incomingHtlcID++\n\n\treturn &htlcPacket{\n\t\tincomingChanID:  c.aliceChannelLink.ShortChanID(),\n\t\tincomingHTLCID:  c.incomingHtlcID,\n\t\tincomingTimeout: testStartingHeight + c.cltvInterceptDelta + 1,\n\t\toutgoingChanID:  c.bobChannelLink.ShortChanID(),\n\t\tobfuscator:      NewMockObfuscator(),\n\t\thtlc: &lnwire.UpdateAddHTLC{\n\t\t\tPaymentHash: c.rhash,\n\t\t\tAmount:      1,\n\t\t\tOnionBlob:   c.onionBlob,\n\t\t},\n\t}\n}\n",
      "length": 388,
      "tokens": 28,
      "embedding": []
    },
    {
      "slug": "func (c *interceptableSwitchTestContext) finish() {",
      "content": "func (c *interceptableSwitchTestContext) finish() {\n\tif err := c.s.Stop(); err != nil {\n\t\tc.t.Fatalf(err.Error())\n\t}\n}\n",
      "length": 63,
      "tokens": 11,
      "embedding": []
    },
    {
      "slug": "func (c *interceptableSwitchTestContext) createSettlePacket(",
      "content": "func (c *interceptableSwitchTestContext) createSettlePacket(\n\toutgoingHTLCID uint64) *htlcPacket {\n\n\treturn &htlcPacket{\n\t\toutgoingChanID: c.bobChannelLink.ShortChanID(),\n\t\toutgoingHTLCID: outgoingHTLCID,\n\t\tamount:         1,\n\t\thtlc: &lnwire.UpdateFulfillHTLC{\n\t\t\tPaymentPreimage: c.preimage,\n\t\t},\n\t}\n}\n",
      "length": 231,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func TestSwitchHoldForward(t *testing.T) {",
      "content": "func TestSwitchHoldForward(t *testing.T) {\n\tt.Parallel()\n\n\tc := newInterceptableSwitchTestContext(t)\n\tdefer c.finish()\n\n\tnotifier := &mock.ChainNotifier{\n\t\tEpochChan: make(chan *chainntnfs.BlockEpoch, 1),\n\t}\n\tnotifier.EpochChan <- &chainntnfs.BlockEpoch{Height: testStartingHeight}\n\n\tswitchForwardInterceptor, err := NewInterceptableSwitch(\n\t\t&InterceptableSwitchConfig{\n\t\t\tSwitch:             c.s,\n\t\t\tCltvRejectDelta:    c.cltvRejectDelta,\n\t\t\tCltvInterceptDelta: c.cltvInterceptDelta,\n\t\t\tNotifier:           notifier,\n\t\t},\n\t)\n\trequire.NoError(t, err)\n\trequire.NoError(t, switchForwardInterceptor.Start())\n\n\tswitchForwardInterceptor.SetInterceptor(c.forwardInterceptor.InterceptForwardHtlc)\n\tlinkQuit := make(chan struct{})\n\n\t// Test a forward that expires too soon.\n\tpacket := c.createTestPacket()\n\tpacket.incomingTimeout = testStartingHeight + c.cltvRejectDelta - 1\n\n\terr = switchForwardInterceptor.ForwardPackets(linkQuit, false, packet)\n\trequire.NoError(t, err, \"can't forward htlc packet\")\n\tassertOutgoingLinkReceive(t, c.bobChannelLink, false)\n\tassertOutgoingLinkReceiveIntercepted(t, c.aliceChannelLink)\n\tassertNumCircuits(t, c.s, 0, 0)\n\n\t// Test a forward that expires too soon and can't be failed.\n\tpacket = c.createTestPacket()\n\tpacket.incomingTimeout = testStartingHeight + c.cltvRejectDelta - 1\n\n\t// Simulate an error during the composition of the failure message.\n\tcurrentCallback := c.s.cfg.FetchLastChannelUpdate\n\tc.s.cfg.FetchLastChannelUpdate = func(\n\t\tlnwire.ShortChannelID) (*lnwire.ChannelUpdate, error) {\n\n\t\treturn nil, errors.New(\"cannot fetch update\")\n\t}\n\n\terr = switchForwardInterceptor.ForwardPackets(linkQuit, false, packet)\n\trequire.NoError(t, err, \"can't forward htlc packet\")\n\treceivedPkt := assertOutgoingLinkReceive(t, c.bobChannelLink, true)\n\tassertNumCircuits(t, c.s, 1, 1)\n\n\trequire.NoError(t, switchForwardInterceptor.ForwardPackets(\n\t\tlinkQuit, false,\n\t\tc.createSettlePacket(receivedPkt.outgoingHTLCID),\n\t))\n\n\tassertOutgoingLinkReceive(t, c.aliceChannelLink, true)\n\tassertNumCircuits(t, c.s, 0, 0)\n\n\tc.s.cfg.FetchLastChannelUpdate = currentCallback\n\n\t// Test resume a hold forward.\n\tassertNumCircuits(t, c.s, 0, 0)\n\terr = switchForwardInterceptor.ForwardPackets(\n\t\tlinkQuit, false, c.createTestPacket(),\n\t)\n\trequire.NoError(t, err)\n\n\tassertNumCircuits(t, c.s, 0, 0)\n\tassertOutgoingLinkReceive(t, c.bobChannelLink, false)\n\n\trequire.NoError(t, switchForwardInterceptor.Resolve(&FwdResolution{\n\t\tAction: FwdActionResume,\n\t\tKey:    c.forwardInterceptor.getIntercepted().IncomingCircuit,\n\t}))\n\treceivedPkt = assertOutgoingLinkReceive(t, c.bobChannelLink, true)\n\tassertNumCircuits(t, c.s, 1, 1)\n\n\t// settling the htlc to close the circuit.\n\terr = switchForwardInterceptor.ForwardPackets(\n\t\tlinkQuit, false,\n\t\tc.createSettlePacket(receivedPkt.outgoingHTLCID),\n\t)\n\trequire.NoError(t, err)\n\n\tassertOutgoingLinkReceive(t, c.aliceChannelLink, true)\n\tassertNumCircuits(t, c.s, 0, 0)\n\n\t// Test resume a hold forward after disconnection.\n\trequire.NoError(t, switchForwardInterceptor.ForwardPackets(\n\t\tlinkQuit, false, c.createTestPacket(),\n\t))\n\n\t// Wait until the packet is offered to the interceptor.\n\t_ = c.forwardInterceptor.getIntercepted()\n\n\t// No forward expected yet.\n\tassertNumCircuits(t, c.s, 0, 0)\n\tassertOutgoingLinkReceive(t, c.bobChannelLink, false)\n\n\t// Disconnect should resume the forwarding.\n\tswitchForwardInterceptor.SetInterceptor(nil)\n\n\treceivedPkt = assertOutgoingLinkReceive(t, c.bobChannelLink, true)\n\tassertNumCircuits(t, c.s, 1, 1)\n\n\t// Settle the htlc to close the circuit.\n\trequire.NoError(t, switchForwardInterceptor.ForwardPackets(\n\t\tlinkQuit, false,\n\t\tc.createSettlePacket(receivedPkt.outgoingHTLCID),\n\t))\n\n\tassertOutgoingLinkReceive(t, c.aliceChannelLink, true)\n\tassertNumCircuits(t, c.s, 0, 0)\n\n\t// Test failing a hold forward\n\tswitchForwardInterceptor.SetInterceptor(\n\t\tc.forwardInterceptor.InterceptForwardHtlc,\n\t)\n\n\trequire.NoError(t, switchForwardInterceptor.ForwardPackets(\n\t\tlinkQuit, false, c.createTestPacket(),\n\t))\n\tassertNumCircuits(t, c.s, 0, 0)\n\tassertOutgoingLinkReceive(t, c.bobChannelLink, false)\n\n\trequire.NoError(t, switchForwardInterceptor.Resolve(&FwdResolution{\n\t\tAction:      FwdActionFail,\n\t\tKey:         c.forwardInterceptor.getIntercepted().IncomingCircuit,\n\t\tFailureCode: lnwire.CodeTemporaryChannelFailure,\n\t}))\n\tassertOutgoingLinkReceive(t, c.bobChannelLink, false)\n\tassertOutgoingLinkReceive(t, c.aliceChannelLink, true)\n\tassertNumCircuits(t, c.s, 0, 0)\n\n\t// Test failing a hold forward with a failure message.\n\trequire.NoError(t,\n\t\tswitchForwardInterceptor.ForwardPackets(\n\t\t\tlinkQuit, false, c.createTestPacket(),\n\t\t),\n\t)\n\tassertNumCircuits(t, c.s, 0, 0)\n\tassertOutgoingLinkReceive(t, c.bobChannelLink, false)\n\n\treason := lnwire.OpaqueReason([]byte{1, 2, 3})\n\trequire.NoError(t, switchForwardInterceptor.Resolve(&FwdResolution{\n\t\tAction:         FwdActionFail,\n\t\tKey:            c.forwardInterceptor.getIntercepted().IncomingCircuit,\n\t\tFailureMessage: reason,\n\t}))\n\n\tassertOutgoingLinkReceive(t, c.bobChannelLink, false)\n\tpacket = assertOutgoingLinkReceive(t, c.aliceChannelLink, true)\n\n\trequire.Equal(t, reason, packet.htlc.(*lnwire.UpdateFailHTLC).Reason)\n\n\tassertNumCircuits(t, c.s, 0, 0)\n\n\t// Test failing a hold forward with a malformed htlc failure.\n\terr = switchForwardInterceptor.ForwardPackets(\n\t\tlinkQuit, false, c.createTestPacket(),\n\t)\n\trequire.NoError(t, err)\n\n\tassertNumCircuits(t, c.s, 0, 0)\n\tassertOutgoingLinkReceive(t, c.bobChannelLink, false)\n\n\tcode := lnwire.CodeInvalidOnionKey\n\trequire.NoError(t, switchForwardInterceptor.Resolve(&FwdResolution{\n\t\tAction:      FwdActionFail,\n\t\tKey:         c.forwardInterceptor.getIntercepted().IncomingCircuit,\n\t\tFailureCode: code,\n\t}))\n\n\tassertOutgoingLinkReceive(t, c.bobChannelLink, false)\n\tpacket = assertOutgoingLinkReceive(t, c.aliceChannelLink, true)\n\tfailPacket := packet.htlc.(*lnwire.UpdateFailHTLC)\n\n\tshaOnionBlob := sha256.Sum256(c.onionBlob[:])\n\texpectedFailure := &lnwire.FailInvalidOnionKey{\n\t\tOnionSHA256: shaOnionBlob,\n\t}\n\n\tfwdErr, err := newMockDeobfuscator().DecryptError(failPacket.Reason)\n\trequire.NoError(t, err)\n\trequire.Equal(t, expectedFailure, fwdErr.WireMessage())\n\n\tassertNumCircuits(t, c.s, 0, 0)\n\n\t// Test settling a hold forward\n\trequire.NoError(t, switchForwardInterceptor.ForwardPackets(\n\t\tlinkQuit, false, c.createTestPacket(),\n\t))\n\tassertNumCircuits(t, c.s, 0, 0)\n\tassertOutgoingLinkReceive(t, c.bobChannelLink, false)\n\n\trequire.NoError(t, switchForwardInterceptor.Resolve(&FwdResolution{\n\t\tKey:      c.forwardInterceptor.getIntercepted().IncomingCircuit,\n\t\tAction:   FwdActionSettle,\n\t\tPreimage: c.preimage,\n\t}))\n\tassertOutgoingLinkReceive(t, c.bobChannelLink, false)\n\tassertOutgoingLinkReceive(t, c.aliceChannelLink, true)\n\tassertNumCircuits(t, c.s, 0, 0)\n\n\trequire.NoError(t, switchForwardInterceptor.Stop())\n\n\t// Test always-on interception.\n\tnotifier = &mock.ChainNotifier{\n\t\tEpochChan: make(chan *chainntnfs.BlockEpoch, 1),\n\t}\n\tnotifier.EpochChan <- &chainntnfs.BlockEpoch{Height: testStartingHeight}\n\n\tswitchForwardInterceptor, err = NewInterceptableSwitch(\n\t\t&InterceptableSwitchConfig{\n\t\t\tSwitch:             c.s,\n\t\t\tCltvRejectDelta:    c.cltvRejectDelta,\n\t\t\tCltvInterceptDelta: c.cltvInterceptDelta,\n\t\t\tRequireInterceptor: true,\n\t\t\tNotifier:           notifier,\n\t\t},\n\t)\n\trequire.NoError(t, err)\n\trequire.NoError(t, switchForwardInterceptor.Start())\n\n\t// Forward a fresh packet. It is expected to be failed immediately,\n\t// because there is no interceptor registered.\n\trequire.NoError(t, switchForwardInterceptor.ForwardPackets(\n\t\tlinkQuit, false, c.createTestPacket(),\n\t))\n\n\tassertOutgoingLinkReceive(t, c.bobChannelLink, false)\n\tassertOutgoingLinkReceive(t, c.aliceChannelLink, true)\n\tassertNumCircuits(t, c.s, 0, 0)\n\n\t// Forward a replayed packet. It is expected to be held until the\n\t// interceptor connects. To continue the test, it needs to be ran in a\n\t// goroutine.\n\terrChan := make(chan error)\n\tgo func() {\n\t\terrChan <- switchForwardInterceptor.ForwardPackets(\n\t\t\tlinkQuit, true, c.createTestPacket(),\n\t\t)\n\t}()\n\n\t// Assert that nothing is forward to the switch.\n\tassertOutgoingLinkReceive(t, c.bobChannelLink, false)\n\tassertNumCircuits(t, c.s, 0, 0)\n\n\t// Register an interceptor.\n\tswitchForwardInterceptor.SetInterceptor(\n\t\tc.forwardInterceptor.InterceptForwardHtlc,\n\t)\n\n\t// Expect the ForwardPackets call to unblock.\n\trequire.NoError(t, <-errChan)\n\n\t// Now expect the queued packet to come through.\n\tc.forwardInterceptor.getIntercepted()\n\n\t// Disconnect and reconnect interceptor.\n\tswitchForwardInterceptor.SetInterceptor(nil)\n\tswitchForwardInterceptor.SetInterceptor(\n\t\tc.forwardInterceptor.InterceptForwardHtlc,\n\t)\n\n\t// A replay of the held packet is expected.\n\tintercepted := c.forwardInterceptor.getIntercepted()\n\n\t// Settle the packet.\n\trequire.NoError(t, switchForwardInterceptor.Resolve(&FwdResolution{\n\t\tKey:      intercepted.IncomingCircuit,\n\t\tAction:   FwdActionSettle,\n\t\tPreimage: c.preimage,\n\t}))\n\tassertOutgoingLinkReceive(t, c.bobChannelLink, false)\n\tassertOutgoingLinkReceive(t, c.aliceChannelLink, true)\n\tassertNumCircuits(t, c.s, 0, 0)\n\n\trequire.NoError(t, switchForwardInterceptor.Stop())\n\n\tselect {\n\tcase <-c.forwardInterceptor.interceptedChan:\n\t\trequire.Fail(t, \"unexpected interception\")\n\n\tdefault:\n\t}\n}\n",
      "length": 8889,
      "tokens": 727,
      "embedding": []
    },
    {
      "slug": "func TestInterceptableSwitchWatchDog(t *testing.T) {",
      "content": "func TestInterceptableSwitchWatchDog(t *testing.T) {\n\tt.Parallel()\n\n\tc := newInterceptableSwitchTestContext(t)\n\tdefer c.finish()\n\n\t// Start interceptable switch.\n\tnotifier := &mock.ChainNotifier{\n\t\tEpochChan: make(chan *chainntnfs.BlockEpoch, 1),\n\t}\n\tnotifier.EpochChan <- &chainntnfs.BlockEpoch{Height: testStartingHeight}\n\n\tswitchForwardInterceptor, err := NewInterceptableSwitch(\n\t\t&InterceptableSwitchConfig{\n\t\t\tSwitch:             c.s,\n\t\t\tCltvRejectDelta:    c.cltvRejectDelta,\n\t\t\tCltvInterceptDelta: c.cltvInterceptDelta,\n\t\t\tNotifier:           notifier,\n\t\t},\n\t)\n\trequire.NoError(t, err)\n\trequire.NoError(t, switchForwardInterceptor.Start())\n\n\t// Set interceptor.\n\tswitchForwardInterceptor.SetInterceptor(\n\t\tc.forwardInterceptor.InterceptForwardHtlc,\n\t)\n\n\t// Receive a packet.\n\tlinkQuit := make(chan struct{})\n\n\tpacket := c.createTestPacket()\n\n\terr = switchForwardInterceptor.ForwardPackets(linkQuit, false, packet)\n\trequire.NoError(t, err, \"can't forward htlc packet\")\n\n\t// Intercept the packet.\n\tintercepted := c.forwardInterceptor.getIntercepted()\n\n\trequire.Equal(t,\n\t\tint32(packet.incomingTimeout-c.cltvRejectDelta),\n\t\tintercepted.AutoFailHeight,\n\t)\n\n\t// Htlc expires before a resolution from the interceptor.\n\tnotifier.EpochChan <- &chainntnfs.BlockEpoch{\n\t\tHeight: int32(packet.incomingTimeout) -\n\t\t\tint32(c.cltvRejectDelta),\n\t}\n\n\t// Expect the htlc to be failed back.\n\tassertOutgoingLinkReceive(t, c.aliceChannelLink, true)\n\n\t// It is too late now to resolve. Expect an error.\n\trequire.Error(t, switchForwardInterceptor.Resolve(&FwdResolution{\n\t\tAction:   FwdActionSettle,\n\t\tKey:      intercepted.IncomingCircuit,\n\t\tPreimage: c.preimage,\n\t}))\n}\n\n// TestSwitchDustForwarding tests that the switch properly fails HTLC's which\n// have incoming or outgoing links that breach their dust thresholds.",
      "length": 1692,
      "tokens": 150,
      "embedding": []
    },
    {
      "slug": "func TestSwitchDustForwarding(t *testing.T) {",
      "content": "func TestSwitchDustForwarding(t *testing.T) {\n\tt.Parallel()\n\n\t// We'll create a three-hop network:\n\t// - Alice has a dust limit of 200sats with Bob\n\t// - Bob has a dust limit of 800sats with Alice\n\t// - Bob has a dust limit of 200sats with Carol\n\t// - Carol has a dust limit of 800sats with Bob\n\tchannels, _, err := createClusterChannels(\n\t\tt, btcutil.SatoshiPerBitcoin, btcutil.SatoshiPerBitcoin,\n\t)\n\trequire.NoError(t, err)\n\n\tn := newThreeHopNetwork(\n\t\tt, channels.aliceToBob, channels.bobToAlice,\n\t\tchannels.bobToCarol, channels.carolToBob, testStartingHeight,\n\t)\n\terr = n.start()\n\trequire.NoError(t, err)\n\n\t// We'll also put Alice and Bob into hodl.ExitSettle mode, such that\n\t// they won't settle incoming exit-hop HTLC's automatically.\n\tn.aliceChannelLink.cfg.HodlMask = hodl.ExitSettle.Mask()\n\tn.firstBobChannelLink.cfg.HodlMask = hodl.ExitSettle.Mask()\n\n\t// We'll test that once the default threshold is exceeded on the\n\t// Alice -> Bob channel, either side's calls to SendHTLC will fail.\n\t//\n\t// Alice will send 357 HTLC's of 700sats. Bob will also send 357 HTLC's\n\t// of 700sats. If either side attempts to send a dust HTLC, it will\n\t// fail so amounts below 800sats will breach the dust threshold.\n\tamt := lnwire.NewMSatFromSatoshis(700)\n\taliceBobFirstHop := n.aliceChannelLink.ShortChanID()\n\n\tsendDustHtlcs(t, n, true, amt, aliceBobFirstHop)\n\tsendDustHtlcs(t, n, false, amt, aliceBobFirstHop)\n\n\t// Generate the parameters needed for Bob to send another dust HTLC.\n\t_, timelock, hops := generateHops(\n\t\tamt, testStartingHeight, n.aliceChannelLink,\n\t)\n\n\tblob, err := generateRoute(hops...)\n\trequire.NoError(t, err)\n\n\t// Assert that if Bob sends a dust HTLC it will fail.\n\tfailingPreimage := lntypes.Preimage{0, 0, 3}\n\tfailingHash := failingPreimage.Hash()\n\tfailingHtlc := &lnwire.UpdateAddHTLC{\n\t\tPaymentHash: failingHash,\n\t\tAmount:      amt,\n\t\tExpiry:      timelock,\n\t\tOnionBlob:   blob,\n\t}\n\n\tcheckAlmostDust := func(link *channelLink, mbox MailBox,\n\t\tremote bool) bool {\n\n\t\ttimeout := time.After(15 * time.Second)\n\t\tpollInterval := 300 * time.Millisecond\n\t\texpectedDust := 357 * 2 * amt\n\n\t\tfor {\n\t\t\t<-time.After(pollInterval)\n\n\t\t\tselect {\n\t\t\tcase <-timeout:\n\t\t\t\treturn false\n\t\t\tdefault:\n\t\t\t}\n\n\t\t\tlinkDust := link.getDustSum(remote)\n\t\t\tlocalMailDust, remoteMailDust := mbox.DustPackets()\n\n\t\t\ttotalDust := linkDust\n\t\t\tif remote {\n\t\t\t\ttotalDust += remoteMailDust\n\t\t\t} else {\n\t\t\t\ttotalDust += localMailDust\n\t\t\t}\n\n\t\t\tif totalDust == expectedDust {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\treturn true\n\t}\n\n\t// Wait until Bob is almost at the dust threshold.\n\tbobMbox := n.bobServer.htlcSwitch.mailOrchestrator.GetOrCreateMailBox(\n\t\tn.firstBobChannelLink.ChanID(),\n\t\tn.firstBobChannelLink.ShortChanID(),\n\t)\n\trequire.True(t, checkAlmostDust(n.firstBobChannelLink, bobMbox, false))\n\n\t// Assert that the HTLC is failed due to the dust threshold.\n\terr = n.bobServer.htlcSwitch.SendHTLC(\n\t\taliceBobFirstHop, uint64(357), failingHtlc,\n\t)\n\trequire.ErrorIs(t, err, errDustThresholdExceeded)\n\n\t// Generate the parameters needed for bob to send a non-dust HTLC.\n\tnondustAmt := lnwire.NewMSatFromSatoshis(10_000)\n\t_, _, hops = generateHops(\n\t\tnondustAmt, testStartingHeight, n.aliceChannelLink,\n\t)\n\n\tblob, err = generateRoute(hops...)\n\trequire.NoError(t, err)\n\n\t// Now attempt to send an HTLC above Bob's dust limit. It should\n\t// succeed.\n\tnondustPreimage := lntypes.Preimage{0, 0, 4}\n\tnondustHash := nondustPreimage.Hash()\n\tnondustHtlc := &lnwire.UpdateAddHTLC{\n\t\tPaymentHash: nondustHash,\n\t\tAmount:      nondustAmt,\n\t\tExpiry:      timelock,\n\t\tOnionBlob:   blob,\n\t}\n\n\t// Assert that SendHTLC succeeds and evaluateDustThreshold returns\n\t// false.\n\terr = n.bobServer.htlcSwitch.SendHTLC(\n\t\taliceBobFirstHop, uint64(358), nondustHtlc,\n\t)\n\trequire.NoError(t, err)\n\n\t// Introduce Carol into the mix and assert that sending a multi-hop\n\t// dust HTLC to Alice will fail. Bob should fail back the HTLC with a\n\t// temporary channel failure.\n\tcarolAmt, carolTimelock, carolHops := generateHops(\n\t\tamt, testStartingHeight, n.secondBobChannelLink,\n\t\tn.aliceChannelLink,\n\t)\n\n\tcarolBlob, err := generateRoute(carolHops...)\n\trequire.NoError(t, err)\n\n\tcarolPreimage := lntypes.Preimage{0, 0, 5}\n\tcarolHash := carolPreimage.Hash()\n\tcarolHtlc := &lnwire.UpdateAddHTLC{\n\t\tPaymentHash: carolHash,\n\t\tAmount:      carolAmt,\n\t\tExpiry:      carolTimelock,\n\t\tOnionBlob:   carolBlob,\n\t}\n\n\t// Initialize Carol's attempt ID.\n\tcarolAttemptID := 0\n\n\terr = n.carolServer.htlcSwitch.SendHTLC(\n\t\tn.carolChannelLink.ShortChanID(), uint64(carolAttemptID),\n\t\tcarolHtlc,\n\t)\n\trequire.NoError(t, err)\n\tcarolAttemptID++\n\n\tcarolResultChan, err := n.carolServer.htlcSwitch.GetAttemptResult(\n\t\tuint64(carolAttemptID-1), carolHash, newMockDeobfuscator(),\n\t)\n\trequire.NoError(t, err)\n\n\tresult, ok := <-carolResultChan\n\trequire.True(t, ok)\n\tassertFailureCode(\n\t\tt, result.Error, lnwire.CodeTemporaryChannelFailure,\n\t)\n\n\t// Send an HTLC from Alice to Carol and assert that it is failed at the\n\t// call to SendHTLC.\n\thtlcAmt, totalTimelock, aliceHops := generateHops(\n\t\tamt, testStartingHeight, n.firstBobChannelLink,\n\t\tn.carolChannelLink,\n\t)\n\n\tblob, err = generateRoute(aliceHops...)\n\trequire.NoError(t, err)\n\n\taliceMultihopPreimage := lntypes.Preimage{0, 0, 6}\n\taliceMultihopHash := aliceMultihopPreimage.Hash()\n\taliceMultihopHtlc := &lnwire.UpdateAddHTLC{\n\t\tPaymentHash: aliceMultihopHash,\n\t\tAmount:      htlcAmt,\n\t\tExpiry:      totalTimelock,\n\t\tOnionBlob:   blob,\n\t}\n\n\t// Wait until Alice's expected dust for the remote commitment is just\n\t// under the dust threshold.\n\taliceOrch := n.aliceServer.htlcSwitch.mailOrchestrator\n\taliceMbox := aliceOrch.GetOrCreateMailBox(\n\t\tn.aliceChannelLink.ChanID(), n.aliceChannelLink.ShortChanID(),\n\t)\n\trequire.True(t, checkAlmostDust(n.aliceChannelLink, aliceMbox, true))\n\n\terr = n.aliceServer.htlcSwitch.SendHTLC(\n\t\tn.aliceChannelLink.ShortChanID(), uint64(357),\n\t\taliceMultihopHtlc,\n\t)\n\trequire.ErrorIs(t, err, errDustThresholdExceeded)\n}\n\n// sendDustHtlcs is a helper function used to send many dust HTLC's to test the\n// Switch's dust-threshold logic. It takes a boolean denoting whether or not\n// Alice is the sender.",
      "length": 5840,
      "tokens": 675,
      "embedding": []
    },
    {
      "slug": "func sendDustHtlcs(t *testing.T, n *threeHopNetwork, alice bool,",
      "content": "func sendDustHtlcs(t *testing.T, n *threeHopNetwork, alice bool,\n\tamt lnwire.MilliSatoshi, sid lnwire.ShortChannelID) {\n\n\tt.Helper()\n\n\t// The number of dust HTLC's we'll send for both Alice and Bob.\n\tnumHTLCs := 357\n\n\t// Extract the destination into a variable. If alice is the sender, the\n\t// destination is Bob.\n\tdestLink := n.aliceChannelLink\n\tif alice {\n\t\tdestLink = n.firstBobChannelLink\n\t}\n\n\t// Create hops that will be used in the onion payload.\n\thtlcAmt, totalTimelock, hops := generateHops(\n\t\tamt, testStartingHeight, destLink,\n\t)\n\n\t// Convert the hops to a blob that will be put in the Add message.\n\tblob, err := generateRoute(hops...)\n\trequire.NoError(t, err)\n\n\t// Create a slice to store the preimages.\n\tpreimages := make([]lntypes.Preimage, numHTLCs)\n\n\t// Initialize the attempt ID used in SendHTLC calls.\n\tattemptID := uint64(0)\n\n\t// Deterministically generate preimages. Avoid the all-zeroes preimage\n\t// because that will be rejected by the database. We'll use a different\n\t// third byte for Alice and Bob.\n\tendByte := byte(2)\n\tif alice {\n\t\tendByte = byte(3)\n\t}\n\n\tfor i := 0; i < numHTLCs; i++ {\n\t\tpreimages[i] = lntypes.Preimage{byte(i >> 8), byte(i), endByte}\n\t}\n\n\tsendingSwitch := n.bobServer.htlcSwitch\n\tif alice {\n\t\tsendingSwitch = n.aliceServer.htlcSwitch\n\t}\n\n\t// Call SendHTLC in a loop for numHTLCs.\n\tfor i := 0; i < numHTLCs; i++ {\n\t\t// Construct the htlc packet.\n\t\thash := preimages[i].Hash()\n\n\t\thtlc := &lnwire.UpdateAddHTLC{\n\t\t\tPaymentHash: hash,\n\t\t\tAmount:      htlcAmt,\n\t\t\tExpiry:      totalTimelock,\n\t\t\tOnionBlob:   blob,\n\t\t}\n\n\t\tfor {\n\t\t\t// It may be the case that the dust threshold is hit\n\t\t\t// before all 357*2 HTLC's are sent due to double\n\t\t\t// counting. Get around this by continuing to send\n\t\t\t// until successful.\n\t\t\terr = sendingSwitch.SendHTLC(sid, attemptID, htlc)\n\t\t\tif err == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tattemptID++\n\t}\n}\n\n// TestSwitchMailboxDust tests that the switch takes into account the mailbox\n// dust when evaluating the dust threshold. The mockChannelLink does not have\n// channel state, so this only tests the switch-mailbox interaction.",
      "length": 1950,
      "tokens": 301,
      "embedding": []
    },
    {
      "slug": "func TestSwitchMailboxDust(t *testing.T) {",
      "content": "func TestSwitchMailboxDust(t *testing.T) {\n\tt.Parallel()\n\n\talicePeer, err := newMockServer(\n\t\tt, \"alice\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err)\n\n\tbobPeer, err := newMockServer(\n\t\tt, \"bob\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err)\n\n\tcarolPeer, err := newMockServer(\n\t\tt, \"carol\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err)\n\n\ts, err := initSwitchWithTempDB(t, testStartingHeight)\n\trequire.NoError(t, err)\n\terr = s.Start()\n\trequire.NoError(t, err)\n\tdefer func() {\n\t\t_ = s.Stop()\n\t}()\n\n\tchanID1, chanID2, aliceChanID, bobChanID := genIDs()\n\n\tchanID3, carolChanID := genID()\n\n\taliceLink := newMockChannelLink(\n\t\ts, chanID1, aliceChanID, emptyScid, alicePeer, true, false,\n\t\tfalse, false,\n\t)\n\terr = s.AddLink(aliceLink)\n\trequire.NoError(t, err)\n\n\tbobLink := newMockChannelLink(\n\t\ts, chanID2, bobChanID, emptyScid, bobPeer, true, false, false,\n\t\tfalse,\n\t)\n\terr = s.AddLink(bobLink)\n\trequire.NoError(t, err)\n\n\tcarolLink := newMockChannelLink(\n\t\ts, chanID3, carolChanID, emptyScid, carolPeer, true, false,\n\t\tfalse, false,\n\t)\n\terr = s.AddLink(carolLink)\n\trequire.NoError(t, err)\n\n\t// mockChannelLink sets the local and remote dust limits of the mailbox\n\t// to 400 satoshis and the feerate to 0. We'll fill the mailbox up with\n\t// dust packets and assert that calls to SendHTLC will fail.\n\tpreimage, err := genPreimage()\n\trequire.NoError(t, err)\n\trhash := sha256.Sum256(preimage[:])\n\tamt := lnwire.NewMSatFromSatoshis(350)\n\taddMsg := &lnwire.UpdateAddHTLC{\n\t\tPaymentHash: rhash,\n\t\tAmount:      amt,\n\t\tChanID:      chanID1,\n\t}\n\n\t// Initialize the carolHTLCID.\n\tvar carolHTLCID uint64\n\n\t// It will take aliceCount HTLC's of 350sats to fill up Alice's mailbox\n\t// to the point where another would put Alice over the dust threshold.\n\taliceCount := 1428\n\n\tmailbox := s.mailOrchestrator.GetOrCreateMailBox(chanID1, aliceChanID)\n\n\tfor i := 0; i < aliceCount; i++ {\n\t\talicePkt := &htlcPacket{\n\t\t\tincomingChanID: carolChanID,\n\t\t\tincomingHTLCID: carolHTLCID,\n\t\t\toutgoingChanID: aliceChanID,\n\t\t\tobfuscator:     NewMockObfuscator(),\n\t\t\tincomingAmount: amt,\n\t\t\tamount:         amt,\n\t\t\thtlc:           addMsg,\n\t\t}\n\n\t\terr = mailbox.AddPacket(alicePkt)\n\t\trequire.NoError(t, err)\n\n\t\tcarolHTLCID++\n\t}\n\n\t// Sending one more HTLC to Alice should result in the dust threshold\n\t// being breached.\n\terr = s.SendHTLC(aliceChanID, 0, addMsg)\n\trequire.ErrorIs(t, err, errDustThresholdExceeded)\n\n\t// We'll now call ForwardPackets from Bob to ensure that the mailbox\n\t// sum is also accounted for in the forwarding case.\n\tpacket := &htlcPacket{\n\t\tincomingChanID: bobChanID,\n\t\tincomingHTLCID: 0,\n\t\toutgoingChanID: aliceChanID,\n\t\tobfuscator:     NewMockObfuscator(),\n\t\tincomingAmount: amt,\n\t\tamount:         amt,\n\t\thtlc: &lnwire.UpdateAddHTLC{\n\t\t\tPaymentHash: rhash,\n\t\t\tAmount:      amt,\n\t\t\tChanID:      chanID1,\n\t\t},\n\t}\n\n\terr = s.ForwardPackets(nil, packet)\n\trequire.NoError(t, err)\n\n\t// Bob should receive a failure from the switch.\n\tselect {\n\tcase p := <-bobLink.packets:\n\t\trequire.NotEmpty(t, p.linkFailure)\n\t\tassertFailureCode(\n\t\t\tt, p.linkFailure, lnwire.CodeTemporaryChannelFailure,\n\t\t)\n\n\tcase <-time.After(5 * time.Second):\n\t\tt.Fatal(\"no timely reply from switch\")\n\t}\n}\n\n// TestSwitchResolution checks the ability of the switch to persist and handle\n// resolution messages.",
      "length": 3161,
      "tokens": 379,
      "embedding": []
    },
    {
      "slug": "func TestSwitchResolution(t *testing.T) {",
      "content": "func TestSwitchResolution(t *testing.T) {\n\tt.Parallel()\n\n\talicePeer, err := newMockServer(\n\t\tt, \"alice\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err)\n\n\tbobPeer, err := newMockServer(\n\t\tt, \"bob\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err)\n\n\ts, err := initSwitchWithTempDB(t, testStartingHeight)\n\trequire.NoError(t, err)\n\n\t// Even though we intend to Stop s later in the test, it is safe to\n\t// defer this Stop since its execution it is protected by an atomic\n\t// guard, guaranteeing it executes at most once.\n\tt.Cleanup(func() { var _ = s.Stop() })\n\n\terr = s.Start()\n\trequire.NoError(t, err)\n\n\tchanID1, chanID2, aliceChanID, bobChanID := genIDs()\n\n\taliceChannelLink := newMockChannelLink(\n\t\ts, chanID1, aliceChanID, emptyScid, alicePeer, true, false,\n\t\tfalse, false,\n\t)\n\tbobChannelLink := newMockChannelLink(\n\t\ts, chanID2, bobChanID, emptyScid, bobPeer, true, false, false,\n\t\tfalse,\n\t)\n\terr = s.AddLink(aliceChannelLink)\n\trequire.NoError(t, err)\n\terr = s.AddLink(bobChannelLink)\n\trequire.NoError(t, err)\n\n\t// Create an add htlcPacket that Alice will send to Bob.\n\tpreimage, err := genPreimage()\n\trequire.NoError(t, err)\n\n\trhash := sha256.Sum256(preimage[:])\n\tpacket := &htlcPacket{\n\t\tincomingChanID: aliceChannelLink.ShortChanID(),\n\t\tincomingHTLCID: 0,\n\t\toutgoingChanID: bobChannelLink.ShortChanID(),\n\t\tobfuscator:     NewMockObfuscator(),\n\t\thtlc: &lnwire.UpdateAddHTLC{\n\t\t\tPaymentHash: rhash,\n\t\t\tAmount:      1,\n\t\t},\n\t}\n\n\terr = s.ForwardPackets(nil, packet)\n\trequire.NoError(t, err)\n\n\t// Bob will receive the packet and open the circuit.\n\tselect {\n\tcase <-bobChannelLink.packets:\n\t\terr = bobChannelLink.completeCircuit(packet)\n\t\trequire.NoError(t, err)\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"request was not propagated to destination\")\n\t}\n\n\t// Check that only one circuit is open.\n\trequire.Equal(t, 1, s.circuits.NumOpen())\n\n\t// We'll send a settle resolution to Switch that should go to Alice.\n\tsettleResMsg := contractcourt.ResolutionMsg{\n\t\tSourceChan: bobChanID,\n\t\tHtlcIndex:  0,\n\t\tPreImage:   &preimage,\n\t}\n\n\t// Before the resolution is sent, remove alice's link so we can assert\n\t// that the resolution is actually stored. Otherwise, it would be\n\t// deleted shortly after being sent.\n\ts.RemoveLink(chanID1)\n\n\t// Send the resolution message.\n\terr = s.ProcessContractResolution(settleResMsg)\n\trequire.NoError(t, err)\n\n\t// Assert that the resolution store contains the settle reoslution.\n\tresMsgs, err := s.resMsgStore.fetchAllResolutionMsg()\n\trequire.NoError(t, err)\n\n\trequire.Equal(t, 1, len(resMsgs))\n\trequire.Equal(t, settleResMsg.SourceChan, resMsgs[0].SourceChan)\n\trequire.Equal(t, settleResMsg.HtlcIndex, resMsgs[0].HtlcIndex)\n\trequire.Nil(t, resMsgs[0].Failure)\n\trequire.Equal(t, preimage, *resMsgs[0].PreImage)\n\n\t// Now we'll restart Alice's link and delete the circuit.\n\terr = s.AddLink(aliceChannelLink)\n\trequire.NoError(t, err)\n\n\t// Alice will receive the packet and open the circuit.\n\tselect {\n\tcase alicePkt := <-aliceChannelLink.packets:\n\t\terr = aliceChannelLink.completeCircuit(alicePkt)\n\t\trequire.NoError(t, err)\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"request was not propagated to destination\")\n\t}\n\n\t// Assert that there are no more circuits.\n\trequire.Equal(t, 0, s.circuits.NumOpen())\n\n\t// We'll restart the Switch and assert that Alice does not receive\n\t// another packet.\n\tswitchDB := s.cfg.DB.(*channeldb.DB)\n\terr = s.Stop()\n\trequire.NoError(t, err)\n\n\ts, err = initSwitchWithDB(testStartingHeight, switchDB)\n\trequire.NoError(t, err)\n\n\terr = s.Start()\n\trequire.NoError(t, err)\n\tdefer func() {\n\t\t_ = s.Stop()\n\t}()\n\n\terr = s.AddLink(aliceChannelLink)\n\trequire.NoError(t, err)\n\terr = s.AddLink(bobChannelLink)\n\trequire.NoError(t, err)\n\n\t// Alice should not receive a packet since the Switch should have\n\t// deleted the resolution message since the circuit was closed.\n\tselect {\n\tcase alicePkt := <-aliceChannelLink.packets:\n\t\tt.Fatalf(\"received erroneous packet: %v\", alicePkt)\n\tcase <-time.After(time.Second * 5):\n\t}\n\n\t// Check that the resolution message no longer exists in the store.\n\tresMsgs, err = s.resMsgStore.fetchAllResolutionMsg()\n\trequire.NoError(t, err)\n\trequire.Equal(t, 0, len(resMsgs))\n}\n\n// TestSwitchForwardFailAlias tests that if ForwardPackets returns a failure\n// before actually forwarding, the ChannelUpdate uses the SCID from the\n// incoming channel and does not leak private information like the UTXO.",
      "length": 4221,
      "tokens": 501,
      "embedding": []
    },
    {
      "slug": "func TestSwitchForwardFailAlias(t *testing.T) {",
      "content": "func TestSwitchForwardFailAlias(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\n\t\t// Whether or not Alice will be a zero-conf channel or an\n\t\t// option-scid-alias channel (feature-bit).\n\t\tzeroConf bool\n\t}{\n\t\t{\n\t\t\tname:     \"option-scid-alias forwarding failure\",\n\t\t\tzeroConf: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"zero-conf forwarding failure\",\n\t\t\tzeroConf: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\ttestSwitchForwardFailAlias(t, test.zeroConf)\n\t\t})\n\t}\n}\n",
      "length": 440,
      "tokens": 61,
      "embedding": []
    },
    {
      "slug": "func testSwitchForwardFailAlias(t *testing.T, zeroConf bool) {",
      "content": "func testSwitchForwardFailAlias(t *testing.T, zeroConf bool) {\n\tt.Parallel()\n\n\tchanID1, chanID2, aliceChanID, bobChanID := genIDs()\n\n\talicePeer, err := newMockServer(\n\t\tt, \"alice\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err)\n\n\tbobPeer, err := newMockServer(\n\t\tt, \"bob\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err)\n\n\ttempPath := t.TempDir()\n\n\tcdb, err := channeldb.Open(tempPath)\n\trequire.NoError(t, err)\n\tt.Cleanup(func() { cdb.Close() })\n\n\ts, err := initSwitchWithDB(testStartingHeight, cdb)\n\trequire.NoError(t, err)\n\n\terr = s.Start()\n\trequire.NoError(t, err)\n\n\t// Make Alice's channel zero-conf or option-scid-alias (feature bit).\n\taliceAlias := lnwire.ShortChannelID{\n\t\tBlockHeight: 16_000_000,\n\t\tTxIndex:     5,\n\t\tTxPosition:  5,\n\t}\n\n\tvar aliceLink *mockChannelLink\n\tif zeroConf {\n\t\taliceLink = newMockChannelLink(\n\t\t\ts, chanID1, aliceAlias, aliceChanID, alicePeer, true,\n\t\t\ttrue, true, false,\n\t\t)\n\t} else {\n\t\taliceLink = newMockChannelLink(\n\t\t\ts, chanID1, aliceChanID, emptyScid, alicePeer, true,\n\t\t\ttrue, false, true,\n\t\t)\n\t\taliceLink.addAlias(aliceAlias)\n\t}\n\terr = s.AddLink(aliceLink)\n\trequire.NoError(t, err)\n\n\tbobLink := newMockChannelLink(\n\t\ts, chanID2, bobChanID, emptyScid, bobPeer, true, false, false,\n\t\tfalse,\n\t)\n\terr = s.AddLink(bobLink)\n\trequire.NoError(t, err)\n\n\t// Create a packet that will be sent from Alice to Bob via the switch.\n\tpreimage := [sha256.Size]byte{1}\n\trhash := sha256.Sum256(preimage[:])\n\togPacket := &htlcPacket{\n\t\tincomingChanID: aliceLink.ShortChanID(),\n\t\tincomingHTLCID: 0,\n\t\toutgoingChanID: bobLink.ShortChanID(),\n\t\tobfuscator:     NewMockObfuscator(),\n\t\thtlc: &lnwire.UpdateAddHTLC{\n\t\t\tPaymentHash: rhash,\n\t\t\tAmount:      1,\n\t\t},\n\t}\n\n\t// Forward the packet and check that Bob's channel link received it.\n\terr = s.ForwardPackets(nil, ogPacket)\n\trequire.NoError(t, err)\n\n\t// Assert that the circuits are in the expected state.\n\trequire.Equal(t, 1, s.circuits.NumPending())\n\trequire.Equal(t, 0, s.circuits.NumOpen())\n\n\t// Pull packet from Bob's link, and do nothing with it.\n\tselect {\n\tcase <-bobLink.packets:\n\tcase <-s.quit:\n\t\tt.Fatal(\"switch shutting down, failed to forward packet\")\n\t}\n\n\t// Now we will restart the Switch to trigger the LoadedFromDisk logic.\n\terr = s.Stop()\n\trequire.NoError(t, err)\n\n\terr = cdb.Close()\n\trequire.NoError(t, err)\n\n\tcdb2, err := channeldb.Open(tempPath)\n\trequire.NoError(t, err)\n\tt.Cleanup(func() { cdb2.Close() })\n\n\ts2, err := initSwitchWithDB(testStartingHeight, cdb2)\n\trequire.NoError(t, err)\n\n\terr = s2.Start()\n\trequire.NoError(t, err)\n\n\tdefer func() {\n\t\t_ = s2.Stop()\n\t}()\n\n\tvar aliceLink2 *mockChannelLink\n\tif zeroConf {\n\t\taliceLink2 = newMockChannelLink(\n\t\t\ts2, chanID1, aliceAlias, aliceChanID, alicePeer, true,\n\t\t\ttrue, true, false,\n\t\t)\n\t} else {\n\t\taliceLink2 = newMockChannelLink(\n\t\t\ts2, chanID1, aliceChanID, emptyScid, alicePeer, true,\n\t\t\ttrue, false, true,\n\t\t)\n\t\taliceLink2.addAlias(aliceAlias)\n\t}\n\terr = s2.AddLink(aliceLink2)\n\trequire.NoError(t, err)\n\n\tbobLink2 := newMockChannelLink(\n\t\ts2, chanID2, bobChanID, emptyScid, bobPeer, true, false, false,\n\t\tfalse,\n\t)\n\terr = s2.AddLink(bobLink2)\n\trequire.NoError(t, err)\n\n\t// Reforward the ogPacket and wait for Alice to receive a failure\n\t// packet.\n\terr = s2.ForwardPackets(nil, ogPacket)\n\trequire.NoError(t, err)\n\n\tselect {\n\tcase failPacket := <-aliceLink2.packets:\n\t\t// Assert that the failPacket does not leak UTXO information.\n\t\t// This means checking that aliceChanID was not returned.\n\t\tmsg := failPacket.linkFailure.msg\n\t\tfailMsg, ok := msg.(*lnwire.FailTemporaryChannelFailure)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, aliceAlias, failMsg.Update.ShortChannelID)\n\tcase <-s2.quit:\n\t\tt.Fatal(\"switch shutting down, failed to forward packet\")\n\t}\n}\n\n// TestSwitchAliasFailAdd tests that the mailbox does not leak UTXO information\n// when failing back an HTLC due to the 5-second timeout. This is tested in the\n// switch rather than the mailbox because the mailbox tests do not have the\n// proper context (e.g. the Switch's failAliasUpdate function). The caveat here\n// is that if the private UTXO is already known, it is fine to send a failure\n// back. This tests option-scid-alias (feature-bit) and zero-conf channels.",
      "length": 3994,
      "tokens": 491,
      "embedding": []
    },
    {
      "slug": "func TestSwitchAliasFailAdd(t *testing.T) {",
      "content": "func TestSwitchAliasFailAdd(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\n\t\t// Denotes whether the opened channel will be zero-conf.\n\t\tzeroConf bool\n\n\t\t// Denotes whether the opened channel will be private.\n\t\tprivate bool\n\n\t\t// Denotes whether an alias was used during forwarding.\n\t\tuseAlias bool\n\t}{\n\t\t{\n\t\t\tname:     \"public zero-conf using alias\",\n\t\t\tzeroConf: true,\n\t\t\tprivate:  false,\n\t\t\tuseAlias: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"public zero-conf using real\",\n\t\t\tzeroConf: true,\n\t\t\tprivate:  false,\n\t\t\tuseAlias: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"private zero-conf using alias\",\n\t\t\tzeroConf: true,\n\t\t\tprivate:  true,\n\t\t\tuseAlias: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"public option-scid-alias using alias\",\n\t\t\tzeroConf: false,\n\t\t\tprivate:  false,\n\t\t\tuseAlias: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"public option-scid-alias using real\",\n\t\t\tzeroConf: false,\n\t\t\tprivate:  false,\n\t\t\tuseAlias: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"private option-scid-alias using alias\",\n\t\t\tzeroConf: false,\n\t\t\tprivate:  true,\n\t\t\tuseAlias: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\ttestSwitchAliasFailAdd(\n\t\t\t\tt, test.zeroConf, test.private, test.useAlias,\n\t\t\t)\n\t\t})\n\t}\n}\n",
      "length": 1084,
      "tokens": 142,
      "embedding": []
    },
    {
      "slug": "func testSwitchAliasFailAdd(t *testing.T, zeroConf, private, useAlias bool) {",
      "content": "func testSwitchAliasFailAdd(t *testing.T, zeroConf, private, useAlias bool) {\n\tt.Parallel()\n\n\tchanID1, chanID2, aliceChanID, bobChanID := genIDs()\n\n\talicePeer, err := newMockServer(\n\t\tt, \"alice\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err)\n\n\tbobPeer, err := newMockServer(\n\t\tt, \"bob\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err)\n\n\ttempPath := t.TempDir()\n\n\tcdb, err := channeldb.Open(tempPath)\n\trequire.NoError(t, err)\n\tdefer cdb.Close()\n\n\ts, err := initSwitchWithDB(testStartingHeight, cdb)\n\trequire.NoError(t, err)\n\n\t// Change the mailOrchestrator's expiry to a second.\n\ts.mailOrchestrator.cfg.expiry = time.Second\n\n\terr = s.Start()\n\trequire.NoError(t, err)\n\n\tdefer func() {\n\t\t_ = s.Stop()\n\t}()\n\n\t// Make Alice's channel zero-conf or option-scid-alias (feature bit).\n\taliceAlias := lnwire.ShortChannelID{\n\t\tBlockHeight: 16_000_000,\n\t\tTxIndex:     5,\n\t\tTxPosition:  5,\n\t}\n\taliceAlias2 := aliceAlias\n\taliceAlias2.TxPosition = 6\n\n\tvar aliceLink *mockChannelLink\n\tif zeroConf {\n\t\taliceLink = newMockChannelLink(\n\t\t\ts, chanID1, aliceAlias, aliceChanID, alicePeer, true,\n\t\t\tprivate, true, false,\n\t\t)\n\t\taliceLink.addAlias(aliceAlias2)\n\t} else {\n\t\taliceLink = newMockChannelLink(\n\t\t\ts, chanID1, aliceChanID, emptyScid, alicePeer, true,\n\t\t\tprivate, false, true,\n\t\t)\n\t\taliceLink.addAlias(aliceAlias)\n\t\taliceLink.addAlias(aliceAlias2)\n\t}\n\terr = s.AddLink(aliceLink)\n\trequire.NoError(t, err)\n\n\tbobLink := newMockChannelLink(\n\t\ts, chanID2, bobChanID, emptyScid, bobPeer, true, true, false,\n\t\tfalse,\n\t)\n\terr = s.AddLink(bobLink)\n\trequire.NoError(t, err)\n\n\t// Create a packet that Bob will send to Alice via ForwardPackets.\n\tpreimage := [sha256.Size]byte{1}\n\trhash := sha256.Sum256(preimage[:])\n\togPacket := &htlcPacket{\n\t\tincomingChanID: bobLink.ShortChanID(),\n\t\tincomingHTLCID: 0,\n\t\tobfuscator:     NewMockObfuscator(),\n\t\thtlc: &lnwire.UpdateAddHTLC{\n\t\t\tPaymentHash: rhash,\n\t\t\tAmount:      1,\n\t\t},\n\t}\n\n\t// Determine which outgoingChanID to set based on the useAlias boolean.\n\toutgoingChanID := aliceChanID\n\tif useAlias {\n\t\t// Choose randomly from the 2 possible aliases.\n\t\taliases := aliceLink.getAliases()\n\t\tidx := mrand.Intn(len(aliases))\n\n\t\toutgoingChanID = aliases[idx]\n\t}\n\n\togPacket.outgoingChanID = outgoingChanID\n\n\t// Forward the packet so Alice's mailbox fails it backwards.\n\terr = s.ForwardPackets(nil, ogPacket)\n\trequire.NoError(t, err)\n\n\t// Assert that the circuits are in the expected state.\n\trequire.Equal(t, 1, s.circuits.NumPending())\n\trequire.Equal(t, 0, s.circuits.NumOpen())\n\n\t// Wait to receive the packet from Bob's mailbox.\n\tselect {\n\tcase failPacket := <-bobLink.packets:\n\t\t// Assert that failPacket returns the expected SCID in the\n\t\t// ChannelUpdate.\n\t\tmsg := failPacket.linkFailure.msg\n\t\tfailMsg, ok := msg.(*lnwire.FailTemporaryChannelFailure)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, outgoingChanID, failMsg.Update.ShortChannelID)\n\tcase <-s.quit:\n\t\tt.Fatal(\"switch shutting down, failed to receive fail packet\")\n\t}\n}\n\n// TestSwitchHandlePacketForwardAlias checks that handlePacketForward (which\n// calls CheckHtlcForward) does not leak the UTXO in a failure message for\n// alias channels. This test requires us to have a REAL link, which we also\n// must modify in order to test it properly (e.g. making it a private channel).\n// This doesn't lead to good code, but short of refactoring the link-generation\n// code there is not a good alternative.",
      "length": 3219,
      "tokens": 385,
      "embedding": []
    },
    {
      "slug": "func TestSwitchHandlePacketForward(t *testing.T) {",
      "content": "func TestSwitchHandlePacketForward(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\n\t\t// Denotes whether or not the channel will be zero-conf.\n\t\tzeroConf bool\n\n\t\t// Denotes whether or not the channel will have negotiated the\n\t\t// option-scid-alias feature-bit and is not zero-conf.\n\t\toptionFeature bool\n\n\t\t// Denotes whether or not the channel will be private.\n\t\tprivate bool\n\n\t\t// Denotes whether or not the alias will be used for\n\t\t// forwarding.\n\t\tuseAlias bool\n\t}{\n\t\t{\n\t\t\tname:     \"public zero-conf using alias\",\n\t\t\tzeroConf: true,\n\t\t\tprivate:  false,\n\t\t\tuseAlias: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"public zero-conf using real\",\n\t\t\tzeroConf: true,\n\t\t\tprivate:  false,\n\t\t\tuseAlias: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"private zero-conf using alias\",\n\t\t\tzeroConf: true,\n\t\t\tprivate:  true,\n\t\t\tuseAlias: true,\n\t\t},\n\t\t{\n\t\t\tname:          \"public option-scid-alias using alias\",\n\t\t\tzeroConf:      false,\n\t\t\toptionFeature: true,\n\t\t\tprivate:       false,\n\t\t\tuseAlias:      true,\n\t\t},\n\t\t{\n\t\t\tname:          \"public option-scid-alias using real\",\n\t\t\tzeroConf:      false,\n\t\t\toptionFeature: true,\n\t\t\tprivate:       false,\n\t\t\tuseAlias:      false,\n\t\t},\n\t\t{\n\t\t\tname:          \"private option-scid-alias using alias\",\n\t\t\tzeroConf:      false,\n\t\t\toptionFeature: true,\n\t\t\tprivate:       true,\n\t\t\tuseAlias:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\ttestSwitchHandlePacketForward(\n\t\t\t\tt, test.zeroConf, test.private, test.useAlias,\n\t\t\t\ttest.optionFeature,\n\t\t\t)\n\t\t})\n\t}\n}\n",
      "length": 1397,
      "tokens": 175,
      "embedding": []
    },
    {
      "slug": "func testSwitchHandlePacketForward(t *testing.T, zeroConf, private,",
      "content": "func testSwitchHandlePacketForward(t *testing.T, zeroConf, private,\n\tuseAlias, optionFeature bool) {\n\n\tt.Parallel()\n\n\t// Create a link for Alice that we'll add to the switch.\n\taliceLink, _, _, _, _, err :=\n\t\tnewSingleLinkTestHarness(t, btcutil.SatoshiPerBitcoin, 0)\n\trequire.NoError(t, err)\n\n\ts, err := initSwitchWithTempDB(t, testStartingHeight)\n\tif err != nil {\n\t\tt.Fatalf(\"unable to init switch: %v\", err)\n\t}\n\tif err := s.Start(); err != nil {\n\t\tt.Fatalf(\"unable to start switch: %v\", err)\n\t}\n\tdefer func() {\n\t\t_ = s.Stop()\n\t}()\n\n\t// Change Alice's ShortChanID and OtherShortChanID here.\n\taliceAlias := lnwire.ShortChannelID{\n\t\tBlockHeight: 16_000_000,\n\t\tTxIndex:     5,\n\t\tTxPosition:  5,\n\t}\n\taliceAlias2 := aliceAlias\n\taliceAlias2.TxPosition = 6\n\n\taliceChannelLink := aliceLink.(*channelLink)\n\taliceChannelState := aliceChannelLink.channel.State()\n\n\t// Set the link's GetAliases function.\n\taliceChannelLink.cfg.GetAliases = func(\n\t\tbase lnwire.ShortChannelID) []lnwire.ShortChannelID {\n\n\t\treturn []lnwire.ShortChannelID{aliceAlias, aliceAlias2}\n\t}\n\n\tif !private {\n\t\t// Change the channel to public depending on the test.\n\t\taliceChannelState.ChannelFlags = lnwire.FFAnnounceChannel\n\t}\n\n\t// If this is an option-scid-alias feature-bit non-zero-conf channel,\n\t// we'll mark the channel as such.\n\tif optionFeature {\n\t\taliceChannelState.ChanType |= channeldb.ScidAliasFeatureBit\n\t}\n\n\t// This is the ShortChannelID field in the OpenChannel struct.\n\taliceScid := aliceLink.ShortChanID()\n\tif zeroConf {\n\t\t// Store the alias in the shortChanID field and mark the real\n\t\t// scid in the database.\n\t\taliceChannelLink.shortChanID = aliceAlias\n\t\terr = aliceChannelState.MarkRealScid(aliceScid)\n\t\trequire.NoError(t, err)\n\n\t\taliceChannelState.ChanType |= channeldb.ZeroConfBit\n\t}\n\n\terr = s.AddLink(aliceLink)\n\trequire.NoError(t, err)\n\n\t// Add a mockChannelLink for Bob.\n\tbobChanID, bobScid := genID()\n\tbobPeer, err := newMockServer(\n\t\tt, \"bob\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err)\n\n\tbobLink := newMockChannelLink(\n\t\ts, bobChanID, bobScid, emptyScid, bobPeer, true, false, false,\n\t\tfalse,\n\t)\n\terr = s.AddLink(bobLink)\n\trequire.NoError(t, err)\n\n\tpreimage := [sha256.Size]byte{1}\n\trhash := sha256.Sum256(preimage[:])\n\togPacket := &htlcPacket{\n\t\tincomingChanID: bobLink.ShortChanID(),\n\t\tincomingHTLCID: 0,\n\t\tobfuscator:     NewMockObfuscator(),\n\t\thtlc: &lnwire.UpdateAddHTLC{\n\t\t\tPaymentHash: rhash,\n\t\t\tAmount:      1,\n\t\t},\n\t}\n\n\t// Determine which outgoingChanID to set based on the useAlias bool.\n\toutgoingChanID := aliceScid\n\tif useAlias {\n\t\t// Choose from the possible aliases.\n\t\taliases := aliceLink.getAliases()\n\t\tidx := mrand.Intn(len(aliases))\n\n\t\toutgoingChanID = aliases[idx]\n\t}\n\n\togPacket.outgoingChanID = outgoingChanID\n\n\t// Forward the packet to Alice and she should fail it back with an\n\t// AmountBelowMinimum FailureMessage.\n\terr = s.ForwardPackets(nil, ogPacket)\n\trequire.NoError(t, err)\n\n\tselect {\n\tcase failPacket := <-bobLink.packets:\n\t\t// Assert that failPacket returns the expected ChannelUpdate.\n\t\tmsg := failPacket.linkFailure.msg\n\t\tfailMsg, ok := msg.(*lnwire.FailAmountBelowMinimum)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, outgoingChanID, failMsg.Update.ShortChannelID)\n\tcase <-s.quit:\n\t\tt.Fatal(\"switch shutting down, failed to receive failure\")\n\t}\n}\n\n// TestSwitchAliasInterceptFail tests that when the InterceptableSwitch fails\n// an incoming HTLC, it does not leak the on-chain UTXO for option-scid-alias\n// (feature bit) or zero-conf channels.",
      "length": 3300,
      "tokens": 390,
      "embedding": []
    },
    {
      "slug": "func TestSwitchAliasInterceptFail(t *testing.T) {",
      "content": "func TestSwitchAliasInterceptFail(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\n\t\t// Denotes whether or not the incoming channel is a zero-conf\n\t\t// channel or an option-scid-alias channel instead (feature\n\t\t// bit).\n\t\tzeroConf bool\n\t}{\n\t\t{\n\t\t\tname:     \"option-scid-alias\",\n\t\t\tzeroConf: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"zero-conf\",\n\t\t\tzeroConf: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\ttestSwitchAliasInterceptFail(t, test.zeroConf)\n\t\t})\n\t}\n}\n",
      "length": 434,
      "tokens": 62,
      "embedding": []
    },
    {
      "slug": "func testSwitchAliasInterceptFail(t *testing.T, zeroConf bool) {",
      "content": "func testSwitchAliasInterceptFail(t *testing.T, zeroConf bool) {\n\tt.Parallel()\n\n\tchanID, aliceScid := genID()\n\n\talicePeer, err := newMockServer(\n\t\tt, \"alice\", testStartingHeight, nil, testDefaultDelta,\n\t)\n\trequire.NoError(t, err)\n\n\ttempPath := t.TempDir()\n\n\tcdb, err := channeldb.Open(tempPath)\n\trequire.NoError(t, err)\n\tt.Cleanup(func() { cdb.Close() })\n\n\ts, err := initSwitchWithDB(testStartingHeight, cdb)\n\trequire.NoError(t, err)\n\n\terr = s.Start()\n\trequire.NoError(t, err)\n\n\tdefer func() {\n\t\t_ = s.Stop()\n\t}()\n\n\t// Make Alice's alias here.\n\taliceAlias := lnwire.ShortChannelID{\n\t\tBlockHeight: 16_000_000,\n\t\tTxIndex:     5,\n\t\tTxPosition:  5,\n\t}\n\taliceAlias2 := aliceAlias\n\taliceAlias2.TxPosition = 6\n\n\tvar aliceLink *mockChannelLink\n\tif zeroConf {\n\t\taliceLink = newMockChannelLink(\n\t\t\ts, chanID, aliceAlias, aliceScid, alicePeer, true,\n\t\t\ttrue, true, false,\n\t\t)\n\t\taliceLink.addAlias(aliceAlias2)\n\t} else {\n\t\taliceLink = newMockChannelLink(\n\t\t\ts, chanID, aliceScid, emptyScid, alicePeer, true,\n\t\t\ttrue, false, true,\n\t\t)\n\t\taliceLink.addAlias(aliceAlias)\n\t\taliceLink.addAlias(aliceAlias2)\n\t}\n\terr = s.AddLink(aliceLink)\n\trequire.NoError(t, err)\n\n\t// Now we'll create the packet that will be sent from the Alice link.\n\tpreimage := [sha256.Size]byte{1}\n\trhash := sha256.Sum256(preimage[:])\n\togPacket := &htlcPacket{\n\t\tincomingChanID:  aliceLink.ShortChanID(),\n\t\tincomingTimeout: 1000,\n\t\tincomingHTLCID:  0,\n\t\toutgoingChanID:  lnwire.ShortChannelID{},\n\t\tobfuscator:      NewMockObfuscator(),\n\t\thtlc: &lnwire.UpdateAddHTLC{\n\t\t\tPaymentHash: rhash,\n\t\t\tAmount:      1,\n\t\t},\n\t}\n\n\t// Now setup the interceptable switch so that we can reject this\n\t// packet.\n\tforwardInterceptor := &mockForwardInterceptor{\n\t\tt:               t,\n\t\tinterceptedChan: make(chan InterceptedPacket),\n\t}\n\n\tnotifier := &mock.ChainNotifier{\n\t\tEpochChan: make(chan *chainntnfs.BlockEpoch, 1),\n\t}\n\tnotifier.EpochChan <- &chainntnfs.BlockEpoch{Height: testStartingHeight}\n\n\tinterceptSwitch, err := NewInterceptableSwitch(\n\t\t&InterceptableSwitchConfig{\n\t\t\tSwitch:             s,\n\t\t\tNotifier:           notifier,\n\t\t\tCltvRejectDelta:    10,\n\t\t\tCltvInterceptDelta: 13,\n\t\t},\n\t)\n\trequire.NoError(t, err)\n\trequire.NoError(t, interceptSwitch.Start())\n\tinterceptSwitch.SetInterceptor(forwardInterceptor.InterceptForwardHtlc)\n\n\terr = interceptSwitch.ForwardPackets(nil, false, ogPacket)\n\trequire.NoError(t, err)\n\n\tinCircuit := forwardInterceptor.getIntercepted().IncomingCircuit\n\trequire.NoError(t, interceptSwitch.resolve(&FwdResolution{\n\t\tAction:      FwdActionFail,\n\t\tKey:         inCircuit,\n\t\tFailureCode: lnwire.CodeTemporaryChannelFailure,\n\t}))\n\n\tselect {\n\tcase failPacket := <-aliceLink.packets:\n\t\t// Assert that failPacket returns the expected ChannelUpdate.\n\t\tfailHtlc, ok := failPacket.htlc.(*lnwire.UpdateFailHTLC)\n\t\trequire.True(t, ok)\n\n\t\tfwdErr, err := newMockDeobfuscator().DecryptError(\n\t\t\tfailHtlc.Reason,\n\t\t)\n\t\trequire.NoError(t, err)\n\n\t\tfailure := fwdErr.WireMessage()\n\n\t\tfailureMsg, ok := failure.(*lnwire.FailTemporaryChannelFailure)\n\t\trequire.True(t, ok)\n\n\t\tfailScid := failureMsg.Update.ShortChannelID\n\t\tisAlias := failScid == aliceAlias || failScid == aliceAlias2\n\t\trequire.True(t, isAlias)\n\n\tcase <-s.quit:\n\t\tt.Fatalf(\"switch shutting down, failed to receive failure\")\n\t}\n\n\trequire.NoError(t, interceptSwitch.Stop())\n}\n",
      "length": 3103,
      "tokens": 293,
      "embedding": []
    }
  ]
}