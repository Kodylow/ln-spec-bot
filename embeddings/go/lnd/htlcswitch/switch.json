{
  "filepath": "../implementations/go/lnd/htlcswitch/switch.go",
  "package": "htlcswitch",
  "sections": [
    {
      "slug": "type plexPacket struct {",
      "content": "type plexPacket struct {\n\tpkt *htlcPacket\n\terr chan error\n}\n\n// ChanClose represents a request which close a particular channel specified by\n// its id.",
      "length": 121,
      "tokens": 21,
      "embedding": []
    },
    {
      "slug": "type ChanClose struct {",
      "content": "type ChanClose struct {\n\t// CloseType is a variable which signals the type of channel closure the\n\t// peer should execute.\n\tCloseType contractcourt.ChannelCloseType\n\n\t// ChanPoint represent the id of the channel which should be closed.\n\tChanPoint *wire.OutPoint\n\n\t// TargetFeePerKw is the ideal fee that was specified by the caller.\n\t// This value is only utilized if the closure type is CloseRegular.\n\t// This will be the starting offered fee when the fee negotiation\n\t// process for the cooperative closure transaction kicks off.\n\tTargetFeePerKw chainfee.SatPerKWeight\n\n\t// MaxFee is the highest fee the caller is willing to pay.\n\t//\n\t// NOTE: This field is only respected if the caller is the initiator of\n\t// the channel.\n\tMaxFee chainfee.SatPerKWeight\n\n\t// DeliveryScript is an optional delivery script to pay funds out to.\n\tDeliveryScript lnwire.DeliveryAddress\n\n\t// Updates is used by request creator to receive the notifications about\n\t// execution of the close channel request.\n\tUpdates chan interface{}\n\n\t// Err is used by request creator to receive request execution error.\n\tErr chan error\n}\n\n// Config defines the configuration for the service. ALL elements within the\n// configuration MUST be non-nil for the service to carry out its duties.",
      "length": 1199,
      "tokens": 189,
      "embedding": []
    },
    {
      "slug": "type Config struct {",
      "content": "type Config struct {\n\t// FwdingLog is an interface that will be used by the switch to log\n\t// forwarding events. A forwarding event happens each time a payment\n\t// circuit is successfully completed. So when we forward an HTLC, and a\n\t// settle is eventually received.\n\tFwdingLog ForwardingLog\n\n\t// LocalChannelClose kicks-off the workflow to execute a cooperative or\n\t// forced unilateral closure of the channel initiated by a local\n\t// subsystem.\n\tLocalChannelClose func(pubKey []byte, request *ChanClose)\n\n\t// DB is the database backend that will be used to back the switch's\n\t// persistent circuit map.\n\tDB kvdb.Backend\n\n\t// FetchAllOpenChannels is a function that fetches all currently open\n\t// channels from the channel database.\n\tFetchAllOpenChannels func() ([]*channeldb.OpenChannel, error)\n\n\t// FetchAllChannels is a function that fetches all pending open, open,\n\t// and waiting close channels from the database.\n\tFetchAllChannels func() ([]*channeldb.OpenChannel, error)\n\n\t// FetchClosedChannels is a function that fetches all closed channels\n\t// from the channel database.\n\tFetchClosedChannels func(\n\t\tpendingOnly bool) ([]*channeldb.ChannelCloseSummary, error)\n\n\t// SwitchPackager provides access to the forwarding packages of all\n\t// active channels. This gives the switch the ability to read arbitrary\n\t// forwarding packages, and ack settles and fails contained within them.\n\tSwitchPackager channeldb.FwdOperator\n\n\t// ExtractErrorEncrypter is an interface allowing switch to reextract\n\t// error encrypters stored in the circuit map on restarts, since they\n\t// are not stored directly within the database.\n\tExtractErrorEncrypter hop.ErrorEncrypterExtracter\n\n\t// FetchLastChannelUpdate retrieves the latest routing policy for a\n\t// target channel. This channel will typically be the outgoing channel\n\t// specified when we receive an incoming HTLC.  This will be used to\n\t// provide payment senders our latest policy when sending encrypted\n\t// error messages.\n\tFetchLastChannelUpdate func(lnwire.ShortChannelID) (*lnwire.ChannelUpdate, error)\n\n\t// Notifier is an instance of a chain notifier that we'll use to signal\n\t// the switch when a new block has arrived.\n\tNotifier chainntnfs.ChainNotifier\n\n\t// HtlcNotifier is an instance of a htlcNotifier which we will pipe htlc\n\t// events through.\n\tHtlcNotifier htlcNotifier\n\n\t// FwdEventTicker is a signal that instructs the htlcswitch to flush any\n\t// pending forwarding events.\n\tFwdEventTicker ticker.Ticker\n\n\t// LogEventTicker is a signal instructing the htlcswitch to log\n\t// aggregate stats about it's forwarding during the last interval.\n\tLogEventTicker ticker.Ticker\n\n\t// AckEventTicker is a signal instructing the htlcswitch to ack any settle\n\t// fails in forwarding packages.\n\tAckEventTicker ticker.Ticker\n\n\t// AllowCircularRoute is true if the user has configured their node to\n\t// allow forwards that arrive and depart our node over the same channel.\n\tAllowCircularRoute bool\n\n\t// RejectHTLC is a flag that instructs the htlcswitch to reject any\n\t// HTLCs that are not from the source hop.\n\tRejectHTLC bool\n\n\t// Clock is a time source for the switch.\n\tClock clock.Clock\n\n\t// MailboxDeliveryTimeout is the interval after which Adds will be\n\t// cancelled if they have not been yet been delivered to a link. The\n\t// computed deadline will expiry this long after the Adds are added to\n\t// a mailbox via AddPacket.\n\tMailboxDeliveryTimeout time.Duration\n\n\t// DustThreshold is the threshold in milli-satoshis after which we'll\n\t// fail incoming or outgoing dust payments for a particular channel.\n\tDustThreshold lnwire.MilliSatoshi\n\n\t// SignAliasUpdate is used when sending FailureMessages backwards for\n\t// option_scid_alias channels. This avoids a potential privacy leak by\n\t// replacing the public, confirmed SCID with the alias in the\n\t// ChannelUpdate.\n\tSignAliasUpdate func(u *lnwire.ChannelUpdate) (*ecdsa.Signature,\n\t\terror)\n\n\t// IsAlias returns whether or not a given SCID is an alias.\n\tIsAlias func(scid lnwire.ShortChannelID) bool\n}\n\n// Switch is the central messaging bus for all incoming/outgoing HTLCs.\n// Connected peers with active channels are treated as named interfaces which\n// refer to active channels as links. A link is the switch's message\n// communication point with the goroutine that manages an active channel. New\n// links are registered each time a channel is created, and unregistered once\n// the channel is closed. The switch manages the hand-off process for multi-hop\n// HTLCs, forwarding HTLCs initiated from within the daemon, and finally\n// notifies users local-systems concerning their outstanding payment requests.",
      "length": 4486,
      "tokens": 651,
      "embedding": []
    },
    {
      "slug": "type Switch struct {",
      "content": "type Switch struct {\n\tstarted  int32 // To be used atomically.\n\tshutdown int32 // To be used atomically.\n\n\t// bestHeight is the best known height of the main chain. The links will\n\t// be used this information to govern decisions based on HTLC timeouts.\n\t// This will be retrieved by the registered links atomically.\n\tbestHeight uint32\n\n\twg   sync.WaitGroup\n\tquit chan struct{}\n\n\t// cfg is a copy of the configuration struct that the htlc switch\n\t// service was initialized with.\n\tcfg *Config\n\n\t// networkResults stores the results of payments initiated by the user.\n\t// The store is used to later look up the payments and notify the\n\t// user of the result when they are complete. Each payment attempt\n\t// should be given a unique integer ID when it is created, otherwise\n\t// results might be overwritten.\n\tnetworkResults *networkResultStore\n\n\t// circuits is storage for payment circuits which are used to\n\t// forward the settle/fail htlc updates back to the add htlc initiator.\n\tcircuits CircuitMap\n\n\t// mailOrchestrator manages the lifecycle of mailboxes used throughout\n\t// the switch, and facilitates delayed delivery of packets to links that\n\t// later come online.\n\tmailOrchestrator *mailOrchestrator\n\n\t// indexMtx is a read/write mutex that protects the set of indexes\n\t// below.\n\tindexMtx sync.RWMutex\n\n\t// pendingLinkIndex holds links that have not had their final, live\n\t// short_chan_id assigned.\n\tpendingLinkIndex map[lnwire.ChannelID]ChannelLink\n\n\t// links is a map of channel id and channel link which manages\n\t// this channel.\n\tlinkIndex map[lnwire.ChannelID]ChannelLink\n\n\t// forwardingIndex is an index which is consulted by the switch when it\n\t// needs to locate the next hop to forward an incoming/outgoing HTLC\n\t// update to/from.\n\t//\n\t// TODO(roasbeef): eventually add a NetworkHop mapping before the\n\t// ChannelLink\n\tforwardingIndex map[lnwire.ShortChannelID]ChannelLink\n\n\t// interfaceIndex maps the compressed public key of a peer to all the\n\t// channels that the switch maintains with that peer.\n\tinterfaceIndex map[[33]byte]map[lnwire.ChannelID]ChannelLink\n\n\t// linkStopIndex stores the currently stopping ChannelLinks,\n\t// represented by their ChannelID. The key is the link's ChannelID and\n\t// the value is a chan that is closed when the link has fully stopped.\n\t// This map is only added to if RemoveLink is called and is not added\n\t// to when the Switch is shutting down and calls Stop() on each link.\n\t//\n\t// MUST be used with the indexMtx.\n\tlinkStopIndex map[lnwire.ChannelID]chan struct{}\n\n\t// htlcPlex is the channel which all connected links use to coordinate\n\t// the setup/teardown of Sphinx (onion routing) payment circuits.\n\t// Active links forward any add/settle messages over this channel each\n\t// state transition, sending new adds/settles which are fully locked\n\t// in.\n\thtlcPlex chan *plexPacket\n\n\t// chanCloseRequests is used to transfer the channel close request to\n\t// the channel close handler.\n\tchanCloseRequests chan *ChanClose\n\n\t// resolutionMsgs is the channel that all external contract resolution\n\t// messages will be sent over.\n\tresolutionMsgs chan *resolutionMsg\n\n\t// pendingFwdingEvents is the set of forwarding events which have been\n\t// collected during the current interval, but hasn't yet been written\n\t// to the forwarding log.\n\tfwdEventMtx         sync.Mutex\n\tpendingFwdingEvents []channeldb.ForwardingEvent\n\n\t// blockEpochStream is an active block epoch event stream backed by an\n\t// active ChainNotifier instance. This will be used to retrieve the\n\t// latest height of the chain.\n\tblockEpochStream *chainntnfs.BlockEpochEvent\n\n\t// pendingSettleFails is the set of settle/fail entries that we need to\n\t// ack in the forwarding package of the outgoing link. This was added to\n\t// make pipelining settles more efficient.\n\tpendingSettleFails []channeldb.SettleFailRef\n\n\t// resMsgStore is used to store the set of ResolutionMsg that come from\n\t// contractcourt. This is used so the Switch can properly forward them,\n\t// even on restarts.\n\tresMsgStore *resolutionStore\n\n\t// aliasToReal is a map used for option-scid-alias feature-bit links.\n\t// The alias SCID is the key and the real, confirmed SCID is the value.\n\t// If the channel is unconfirmed, there will not be a mapping for it.\n\t// Since channels can have multiple aliases, this map is essentially a\n\t// N->1 mapping for a channel. This MUST be accessed with the indexMtx.\n\taliasToReal map[lnwire.ShortChannelID]lnwire.ShortChannelID\n\n\t// baseIndex is a map used for option-scid-alias feature-bit links.\n\t// The value is the SCID of the link's ShortChannelID. This value may\n\t// be an alias for zero-conf channels or a confirmed SCID for\n\t// non-zero-conf channels with the option-scid-alias feature-bit. The\n\t// key includes the value itself and also any other aliases. This MUST\n\t// be accessed with the indexMtx.\n\tbaseIndex map[lnwire.ShortChannelID]lnwire.ShortChannelID\n}\n\n// New creates the new instance of htlc switch.",
      "length": 4799,
      "tokens": 728,
      "embedding": []
    },
    {
      "slug": "func New(cfg Config, currentHeight uint32) (*Switch, error) {",
      "content": "func New(cfg Config, currentHeight uint32) (*Switch, error) {\n\tresStore := newResolutionStore(cfg.DB)\n\n\tcircuitMap, err := NewCircuitMap(&CircuitMapConfig{\n\t\tDB:                    cfg.DB,\n\t\tFetchAllOpenChannels:  cfg.FetchAllOpenChannels,\n\t\tFetchClosedChannels:   cfg.FetchClosedChannels,\n\t\tExtractErrorEncrypter: cfg.ExtractErrorEncrypter,\n\t\tCheckResolutionMsg:    resStore.checkResolutionMsg,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ts := &Switch{\n\t\tbestHeight:        currentHeight,\n\t\tcfg:               &cfg,\n\t\tcircuits:          circuitMap,\n\t\tlinkIndex:         make(map[lnwire.ChannelID]ChannelLink),\n\t\tforwardingIndex:   make(map[lnwire.ShortChannelID]ChannelLink),\n\t\tinterfaceIndex:    make(map[[33]byte]map[lnwire.ChannelID]ChannelLink),\n\t\tpendingLinkIndex:  make(map[lnwire.ChannelID]ChannelLink),\n\t\tlinkStopIndex:     make(map[lnwire.ChannelID]chan struct{}),\n\t\tnetworkResults:    newNetworkResultStore(cfg.DB),\n\t\thtlcPlex:          make(chan *plexPacket),\n\t\tchanCloseRequests: make(chan *ChanClose),\n\t\tresolutionMsgs:    make(chan *resolutionMsg),\n\t\tresMsgStore:       resStore,\n\t\tquit:              make(chan struct{}),\n\t}\n\n\ts.aliasToReal = make(map[lnwire.ShortChannelID]lnwire.ShortChannelID)\n\ts.baseIndex = make(map[lnwire.ShortChannelID]lnwire.ShortChannelID)\n\n\ts.mailOrchestrator = newMailOrchestrator(&mailOrchConfig{\n\t\tforwardPackets:    s.ForwardPackets,\n\t\tclock:             s.cfg.Clock,\n\t\texpiry:            s.cfg.MailboxDeliveryTimeout,\n\t\tfailMailboxUpdate: s.failMailboxUpdate,\n\t})\n\n\treturn s, nil\n}\n\n// resolutionMsg is a struct that wraps an existing ResolutionMsg with a done\n// channel. We'll use this channel to synchronize delivery of the message with\n// the caller.",
      "length": 1594,
      "tokens": 115,
      "embedding": []
    },
    {
      "slug": "type resolutionMsg struct {",
      "content": "type resolutionMsg struct {\n\tcontractcourt.ResolutionMsg\n\n\terrChan chan error\n}\n\n// ProcessContractResolution is called by active contract resolvers once a\n// contract they are watching over has been fully resolved. The message carries\n// an external signal that *would* have been sent if the outgoing channel\n// didn't need to go to the chain in order to fulfill a contract. We'll process\n// this message just as if it came from an active outgoing channel.",
      "length": 420,
      "tokens": 70,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) ProcessContractResolution(msg contractcourt.ResolutionMsg) error {",
      "content": "func (s *Switch) ProcessContractResolution(msg contractcourt.ResolutionMsg) error {\n\terrChan := make(chan error, 1)\n\n\tselect {\n\tcase s.resolutionMsgs <- &resolutionMsg{\n\t\tResolutionMsg: msg,\n\t\terrChan:       errChan,\n\t}:\n\tcase <-s.quit:\n\t\treturn ErrSwitchExiting\n\t}\n\n\tselect {\n\tcase err := <-errChan:\n\t\treturn err\n\tcase <-s.quit:\n\t\treturn ErrSwitchExiting\n\t}\n}\n\n// GetAttemptResult returns the result of the payment attempt with the given\n// attemptID. The paymentHash should be set to the payment's overall hash, or\n// in case of AMP payments the payment's unique identifier.\n//\n// The method returns a channel where the payment result will be sent when\n// available, or an error is encountered during forwarding. When a result is\n// received on the channel, the HTLC is guaranteed to no longer be in flight.\n// The switch shutting down is signaled by closing the channel. If the\n// attemptID is unknown, ErrPaymentIDNotFound will be returned.",
      "length": 833,
      "tokens": 134,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) GetAttemptResult(attemptID uint64, paymentHash lntypes.Hash,",
      "content": "func (s *Switch) GetAttemptResult(attemptID uint64, paymentHash lntypes.Hash,\n\tdeobfuscator ErrorDecrypter) (<-chan *PaymentResult, error) {\n\n\tvar (\n\t\tnChan <-chan *networkResult\n\t\terr   error\n\t\tinKey = CircuitKey{\n\t\t\tChanID: hop.Source,\n\t\t\tHtlcID: attemptID,\n\t\t}\n\t)\n\n\t// If the payment is not found in the circuit map, check whether a\n\t// result is already available.\n\t// Assumption: no one will add this payment ID other than the caller.\n\tif s.circuits.LookupCircuit(inKey) == nil {\n\t\tres, err := s.networkResults.getResult(attemptID)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tc := make(chan *networkResult, 1)\n\t\tc <- res\n\t\tnChan = c\n\t} else {\n\t\t// The payment was committed to the circuits, subscribe for a\n\t\t// result.\n\t\tnChan, err = s.networkResults.subscribeResult(attemptID)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tresultChan := make(chan *PaymentResult, 1)\n\n\t// Since the payment was known, we can start a goroutine that can\n\t// extract the result when it is available, and pass it on to the\n\t// caller.\n\ts.wg.Add(1)\n\tgo func() {\n\t\tdefer s.wg.Done()\n\n\t\tvar n *networkResult\n\t\tselect {\n\t\tcase n = <-nChan:\n\t\tcase <-s.quit:\n\t\t\t// We close the result channel to signal a shutdown. We\n\t\t\t// don't send any result in this case since the HTLC is\n\t\t\t// still in flight.\n\t\t\tclose(resultChan)\n\t\t\treturn\n\t\t}\n\n\t\tlog.Debugf(\"Received network result %T for attemptID=%v\", n.msg,\n\t\t\tattemptID)\n\n\t\t// Extract the result and pass it to the result channel.\n\t\tresult, err := s.extractResult(\n\t\t\tdeobfuscator, n, attemptID, paymentHash,\n\t\t)\n\t\tif err != nil {\n\t\t\te := fmt.Errorf(\"unable to extract result: %v\", err)\n\t\t\tlog.Error(e)\n\t\t\tresultChan <- &PaymentResult{\n\t\t\t\tError: e,\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tresultChan <- result\n\t}()\n\n\treturn resultChan, nil\n}\n\n// CleanStore calls the underlying result store, telling it is safe to delete\n// all entries except the ones in the keepPids map. This should be called\n// preiodically to let the switch clean up payment results that we have\n// handled.",
      "length": 1831,
      "tokens": 294,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) CleanStore(keepPids map[uint64]struct{}) error {",
      "content": "func (s *Switch) CleanStore(keepPids map[uint64]struct{}) error {\n\treturn s.networkResults.cleanStore(keepPids)\n}\n\n// SendHTLC is used by other subsystems which aren't belong to htlc switch\n// package in order to send the htlc update. The attemptID used MUST be unique\n// for this HTLC, and MUST be used only once, otherwise the switch might reject\n// it.",
      "length": 283,
      "tokens": 48,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) SendHTLC(firstHop lnwire.ShortChannelID, attemptID uint64,",
      "content": "func (s *Switch) SendHTLC(firstHop lnwire.ShortChannelID, attemptID uint64,\n\thtlc *lnwire.UpdateAddHTLC) error {\n\n\t// Generate and send new update packet, if error will be received on\n\t// this stage it means that packet haven't left boundaries of our\n\t// system and something wrong happened.\n\tpacket := &htlcPacket{\n\t\tincomingChanID: hop.Source,\n\t\tincomingHTLCID: attemptID,\n\t\toutgoingChanID: firstHop,\n\t\thtlc:           htlc,\n\t\tamount:         htlc.Amount,\n\t}\n\n\t// Attempt to fetch the target link before creating a circuit so that\n\t// we don't leave dangling circuits. The getLocalLink method does not\n\t// require the circuit variable to be set on the *htlcPacket.\n\tlink, linkErr := s.getLocalLink(packet, htlc)\n\tif linkErr != nil {\n\t\t// Notify the htlc notifier of a link failure on our outgoing\n\t\t// link. Incoming timelock/amount values are not set because\n\t\t// they are not present for local sends.\n\t\ts.cfg.HtlcNotifier.NotifyLinkFailEvent(\n\t\t\tnewHtlcKey(packet),\n\t\t\tHtlcInfo{\n\t\t\t\tOutgoingTimeLock: htlc.Expiry,\n\t\t\t\tOutgoingAmt:      htlc.Amount,\n\t\t\t},\n\t\t\tHtlcEventTypeSend,\n\t\t\tlinkErr,\n\t\t\tfalse,\n\t\t)\n\n\t\treturn linkErr\n\t}\n\n\t// Evaluate whether this HTLC would increase our exposure to dust. If\n\t// it does, don't send it out and instead return an error.\n\tif s.evaluateDustThreshold(link, htlc.Amount, false) {\n\t\t// Notify the htlc notifier of a link failure on our outgoing\n\t\t// link. We use the FailTemporaryChannelFailure in place of a\n\t\t// more descriptive error message.\n\t\tlinkErr := NewLinkError(\n\t\t\t&lnwire.FailTemporaryChannelFailure{},\n\t\t)\n\t\ts.cfg.HtlcNotifier.NotifyLinkFailEvent(\n\t\t\tnewHtlcKey(packet),\n\t\t\tHtlcInfo{\n\t\t\t\tOutgoingTimeLock: htlc.Expiry,\n\t\t\t\tOutgoingAmt:      htlc.Amount,\n\t\t\t},\n\t\t\tHtlcEventTypeSend,\n\t\t\tlinkErr,\n\t\t\tfalse,\n\t\t)\n\n\t\treturn errDustThresholdExceeded\n\t}\n\n\tcircuit := newPaymentCircuit(&htlc.PaymentHash, packet)\n\tactions, err := s.circuits.CommitCircuits(circuit)\n\tif err != nil {\n\t\tlog.Errorf(\"unable to commit circuit in switch: %v\", err)\n\t\treturn err\n\t}\n\n\t// Drop duplicate packet if it has already been seen.\n\tswitch {\n\tcase len(actions.Drops) == 1:\n\t\treturn ErrDuplicateAdd\n\n\tcase len(actions.Fails) == 1:\n\t\treturn ErrLocalAddFailed\n\t}\n\n\t// Give the packet to the link's mailbox so that HTLC's are properly\n\t// canceled back if the mailbox timeout elapses.\n\tpacket.circuit = circuit\n\n\treturn link.handleSwitchPacket(packet)\n}\n\n// UpdateForwardingPolicies sends a message to the switch to update the\n// forwarding policies for the set of target channels, keyed in chanPolicies.\n//\n// NOTE: This function is synchronous and will block until either the\n// forwarding policies for all links have been updated, or the switch shuts\n// down.",
      "length": 2517,
      "tokens": 341,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) UpdateForwardingPolicies(",
      "content": "func (s *Switch) UpdateForwardingPolicies(\n\tchanPolicies map[wire.OutPoint]ForwardingPolicy) {\n\n\tlog.Tracef(\"Updating link policies: %v\", newLogClosure(func() string {\n\t\treturn spew.Sdump(chanPolicies)\n\t}))\n\n\ts.indexMtx.RLock()\n\n\t// Update each link in chanPolicies.\n\tfor targetLink, policy := range chanPolicies {\n\t\tcid := lnwire.NewChanIDFromOutPoint(&targetLink)\n\n\t\tlink, ok := s.linkIndex[cid]\n\t\tif !ok {\n\t\t\tlog.Debugf(\"Unable to find ChannelPoint(%v) to update \"+\n\t\t\t\t\"link policy\", targetLink)\n\t\t\tcontinue\n\t\t}\n\n\t\tlink.UpdateForwardingPolicy(policy)\n\t}\n\n\ts.indexMtx.RUnlock()\n}\n\n// IsForwardedHTLC checks for a given channel and htlc index if it is related\n// to an opened circuit that represents a forwarded payment.",
      "length": 653,
      "tokens": 77,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) IsForwardedHTLC(chanID lnwire.ShortChannelID,",
      "content": "func (s *Switch) IsForwardedHTLC(chanID lnwire.ShortChannelID,\n\thtlcIndex uint64) bool {\n\n\tcircuit := s.circuits.LookupOpenCircuit(models.CircuitKey{\n\t\tChanID: chanID,\n\t\tHtlcID: htlcIndex,\n\t})\n\treturn circuit != nil && circuit.Incoming.ChanID != hop.Source\n}\n\n// ForwardPackets adds a list of packets to the switch for processing. Fails\n// and settles are added on a first past, simultaneously constructing circuits\n// for any adds. After persisting the circuits, another pass of the adds is\n// given to forward them through the router. The sending link's quit channel is\n// used to prevent deadlocks when the switch stops a link in the midst of\n// forwarding.",
      "length": 583,
      "tokens": 91,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) ForwardPackets(linkQuit chan struct{},",
      "content": "func (s *Switch) ForwardPackets(linkQuit chan struct{},\n\tpackets ...*htlcPacket) error {\n\n\tvar (\n\t\t// fwdChan is a buffered channel used to receive err msgs from\n\t\t// the htlcPlex when forwarding this batch.\n\t\tfwdChan = make(chan error, len(packets))\n\n\t\t// numSent keeps a running count of how many packets are\n\t\t// forwarded to the switch, which determines how many responses\n\t\t// we will wait for on the fwdChan..\n\t\tnumSent int\n\t)\n\n\t// No packets, nothing to do.\n\tif len(packets) == 0 {\n\t\treturn nil\n\t}\n\n\t// Setup a barrier to prevent the background tasks from processing\n\t// responses until this function returns to the user.\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\tdefer wg.Done()\n\n\t// Before spawning the following goroutine to proxy our error responses,\n\t// check to see if we have already been issued a shutdown request. If\n\t// so, we exit early to avoid incrementing the switch's waitgroup while\n\t// it is already in the process of shutting down.\n\tselect {\n\tcase <-linkQuit:\n\t\treturn nil\n\tcase <-s.quit:\n\t\treturn nil\n\tdefault:\n\t\t// Spawn a goroutine to log the errors returned from failed packets.\n\t\ts.wg.Add(1)\n\t\tgo s.logFwdErrs(&numSent, &wg, fwdChan)\n\t}\n\n\t// Make a first pass over the packets, forwarding any settles or fails.\n\t// As adds are found, we create a circuit and append it to our set of\n\t// circuits to be written to disk.\n\tvar circuits []*PaymentCircuit\n\tvar addBatch []*htlcPacket\n\tfor _, packet := range packets {\n\t\tswitch htlc := packet.htlc.(type) {\n\t\tcase *lnwire.UpdateAddHTLC:\n\t\t\tcircuit := newPaymentCircuit(&htlc.PaymentHash, packet)\n\t\t\tpacket.circuit = circuit\n\t\t\tcircuits = append(circuits, circuit)\n\t\t\taddBatch = append(addBatch, packet)\n\t\tdefault:\n\t\t\terr := s.routeAsync(packet, fwdChan, linkQuit)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to forward packet %v\", err)\n\t\t\t}\n\t\t\tnumSent++\n\t\t}\n\t}\n\n\t// If this batch did not contain any circuits to commit, we can return\n\t// early.\n\tif len(circuits) == 0 {\n\t\treturn nil\n\t}\n\n\t// Write any circuits that we found to disk.\n\tactions, err := s.circuits.CommitCircuits(circuits...)\n\tif err != nil {\n\t\tlog.Errorf(\"unable to commit circuits in switch: %v\", err)\n\t}\n\n\t// Split the htlc packets by comparing an in-order seek to the head of\n\t// the added, dropped, or failed circuits.\n\t//\n\t// NOTE: This assumes each list is guaranteed to be a subsequence of the\n\t// circuits, and that the union of the sets results in the original set\n\t// of circuits.\n\tvar addedPackets, failedPackets []*htlcPacket\n\tfor _, packet := range addBatch {\n\t\tswitch {\n\t\tcase len(actions.Adds) > 0 && packet.circuit == actions.Adds[0]:\n\t\t\taddedPackets = append(addedPackets, packet)\n\t\t\tactions.Adds = actions.Adds[1:]\n\n\t\tcase len(actions.Drops) > 0 && packet.circuit == actions.Drops[0]:\n\t\t\tactions.Drops = actions.Drops[1:]\n\n\t\tcase len(actions.Fails) > 0 && packet.circuit == actions.Fails[0]:\n\t\t\tfailedPackets = append(failedPackets, packet)\n\t\t\tactions.Fails = actions.Fails[1:]\n\t\t}\n\t}\n\n\t// Now, forward any packets for circuits that were successfully added to\n\t// the switch's circuit map.\n\tfor _, packet := range addedPackets {\n\t\terr := s.routeAsync(packet, fwdChan, linkQuit)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to forward packet %v\", err)\n\t\t}\n\t\tnumSent++\n\t}\n\n\t// Lastly, for any packets that failed, this implies that they were\n\t// left in a half added state, which can happen when recovering from\n\t// failures.\n\tif len(failedPackets) > 0 {\n\t\tvar failure lnwire.FailureMessage\n\t\tincomingID := failedPackets[0].incomingChanID\n\n\t\t// If the incoming channel is an option_scid_alias channel,\n\t\t// then we'll need to replace the SCID in the ChannelUpdate.\n\t\tupdate := s.failAliasUpdate(incomingID, true)\n\t\tif update == nil {\n\t\t\t// Fallback to the original non-option behavior.\n\t\t\tupdate, err := s.cfg.FetchLastChannelUpdate(\n\t\t\t\tincomingID,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tfailure = &lnwire.FailTemporaryNodeFailure{}\n\t\t\t} else {\n\t\t\t\tfailure = lnwire.NewTemporaryChannelFailure(\n\t\t\t\t\tupdate,\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\t// This is an option_scid_alias channel.\n\t\t\tfailure = lnwire.NewTemporaryChannelFailure(update)\n\t\t}\n\n\t\tlinkError := NewDetailedLinkError(\n\t\t\tfailure, OutgoingFailureIncompleteForward,\n\t\t)\n\n\t\tfor _, packet := range failedPackets {\n\t\t\t// We don't handle the error here since this method\n\t\t\t// always returns an error.\n\t\t\t_ = s.failAddPacket(packet, linkError)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// logFwdErrs logs any errors received on `fwdChan`.",
      "length": 4207,
      "tokens": 630,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) logFwdErrs(num *int, wg *sync.WaitGroup, fwdChan chan error) {",
      "content": "func (s *Switch) logFwdErrs(num *int, wg *sync.WaitGroup, fwdChan chan error) {\n\tdefer s.wg.Done()\n\n\t// Wait here until the outer function has finished persisting\n\t// and routing the packets. This guarantees we don't read from num until\n\t// the value is accurate.\n\twg.Wait()\n\n\tnumSent := *num\n\tfor i := 0; i < numSent; i++ {\n\t\tselect {\n\t\tcase err := <-fwdChan:\n\t\t\tif err != nil {\n\t\t\t\tlog.Errorf(\"Unhandled error while reforwarding htlc \"+\n\t\t\t\t\t\"settle/fail over htlcswitch: %v\", err)\n\t\t\t}\n\t\tcase <-s.quit:\n\t\t\tlog.Errorf(\"unable to forward htlc packet \" +\n\t\t\t\t\"htlc switch was stopped\")\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// routeAsync sends a packet through the htlc switch, using the provided err\n// chan to propagate errors back to the caller. The link's quit channel is\n// provided so that the send can be canceled if either the link or the switch\n// receive a shutdown requuest. This method does not wait for a response from\n// the htlcForwarder before returning.",
      "length": 845,
      "tokens": 145,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) routeAsync(packet *htlcPacket, errChan chan error,",
      "content": "func (s *Switch) routeAsync(packet *htlcPacket, errChan chan error,\n\tlinkQuit chan struct{}) error {\n\n\tcommand := &plexPacket{\n\t\tpkt: packet,\n\t\terr: errChan,\n\t}\n\n\tselect {\n\tcase s.htlcPlex <- command:\n\t\treturn nil\n\tcase <-linkQuit:\n\t\treturn ErrLinkShuttingDown\n\tcase <-s.quit:\n\t\treturn errors.New(\"htlc switch was stopped\")\n\t}\n}\n\n// getLocalLink handles the addition of a htlc for a send that originates from\n// our node. It returns the link that the htlc should be forwarded outwards on,\n// and a link error if the htlc cannot be forwarded.",
      "length": 454,
      "tokens": 74,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) getLocalLink(pkt *htlcPacket, htlc *lnwire.UpdateAddHTLC) (",
      "content": "func (s *Switch) getLocalLink(pkt *htlcPacket, htlc *lnwire.UpdateAddHTLC) (\n\tChannelLink, *LinkError) {\n\n\t// Try to find links by node destination.\n\ts.indexMtx.RLock()\n\tlink, err := s.getLinkByShortID(pkt.outgoingChanID)\n\tdefer s.indexMtx.RUnlock()\n\tif err != nil {\n\t\t// If the link was not found for the outgoingChanID, an outside\n\t\t// subsystem may be using the confirmed SCID of a zero-conf\n\t\t// channel. In this case, we'll consult the Switch maps to see\n\t\t// if an alias exists and use the alias to lookup the link.\n\t\t// This extra step is a consequence of not updating the Switch\n\t\t// forwardingIndex when a zero-conf channel is confirmed. We\n\t\t// don't need to change the outgoingChanID since the link will\n\t\t// do that upon receiving the packet.\n\t\tbaseScid, ok := s.baseIndex[pkt.outgoingChanID]\n\t\tif !ok {\n\t\t\tlog.Errorf(\"Link %v not found\", pkt.outgoingChanID)\n\t\t\treturn nil, NewLinkError(&lnwire.FailUnknownNextPeer{})\n\t\t}\n\n\t\t// The base SCID was found, so we'll use that to fetch the\n\t\t// link.\n\t\tlink, err = s.getLinkByShortID(baseScid)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Link %v not found\", baseScid)\n\t\t\treturn nil, NewLinkError(&lnwire.FailUnknownNextPeer{})\n\t\t}\n\t}\n\n\tif !link.EligibleToForward() {\n\t\tlog.Errorf(\"Link %v is not available to forward\",\n\t\t\tpkt.outgoingChanID)\n\n\t\t// The update does not need to be populated as the error\n\t\t// will be returned back to the router.\n\t\treturn nil, NewDetailedLinkError(\n\t\t\tlnwire.NewTemporaryChannelFailure(nil),\n\t\t\tOutgoingFailureLinkNotEligible,\n\t\t)\n\t}\n\n\t// Ensure that the htlc satisfies the outgoing channel policy.\n\tcurrentHeight := atomic.LoadUint32(&s.bestHeight)\n\thtlcErr := link.CheckHtlcTransit(\n\t\thtlc.PaymentHash, htlc.Amount, htlc.Expiry, currentHeight,\n\t)\n\tif htlcErr != nil {\n\t\tlog.Errorf(\"Link %v policy for local forward not \"+\n\t\t\t\"satisfied\", pkt.outgoingChanID)\n\t\treturn nil, htlcErr\n\t}\n\treturn link, nil\n}\n\n// handleLocalResponse processes a Settle or Fail responding to a\n// locally-initiated payment. This is handled asynchronously to avoid blocking\n// the main event loop within the switch, as these operations can require\n// multiple db transactions. The guarantees of the circuit map are stringent\n// enough such that we are able to tolerate reordering of these operations\n// without side effects. The primary operations handled are:\n//  1. Save the payment result to the pending payment store.\n//  2. Notify subscribers about the payment result.\n//  3. Ack settle/fail references, to avoid resending this response internally\n//  4. Teardown the closing circuit in the circuit map\n//\n// NOTE: This method MUST be spawned as a goroutine.",
      "length": 2473,
      "tokens": 360,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) handleLocalResponse(pkt *htlcPacket) {",
      "content": "func (s *Switch) handleLocalResponse(pkt *htlcPacket) {\n\tdefer s.wg.Done()\n\n\tattemptID := pkt.incomingHTLCID\n\n\t// The error reason will be unencypted in case this a local\n\t// failure or a converted error.\n\tunencrypted := pkt.localFailure || pkt.convertedError\n\tn := &networkResult{\n\t\tmsg:          pkt.htlc,\n\t\tunencrypted:  unencrypted,\n\t\tisResolution: pkt.isResolution,\n\t}\n\n\t// Store the result to the db. This will also notify subscribers about\n\t// the result.\n\tif err := s.networkResults.storeResult(attemptID, n); err != nil {\n\t\tlog.Errorf(\"Unable to complete payment for pid=%v: %v\",\n\t\t\tattemptID, err)\n\t\treturn\n\t}\n\n\t// First, we'll clean up any fwdpkg references, circuit entries, and\n\t// mark in our db that the payment for this payment hash has either\n\t// succeeded or failed.\n\t//\n\t// If this response is contained in a forwarding package, we'll start by\n\t// acking the settle/fail so that we don't continue to retransmit the\n\t// HTLC internally.\n\tif pkt.destRef != nil {\n\t\tif err := s.ackSettleFail(*pkt.destRef); err != nil {\n\t\t\tlog.Warnf(\"Unable to ack settle/fail reference: %s: %v\",\n\t\t\t\t*pkt.destRef, err)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Next, we'll remove the circuit since we are about to complete an\n\t// fulfill/fail of this HTLC. Since we've already removed the\n\t// settle/fail fwdpkg reference, the response from the peer cannot be\n\t// replayed internally if this step fails. If this happens, this logic\n\t// will be executed when a provided resolution message comes through.\n\t// This can only happen if the circuit is still open, which is why this\n\t// ordering is chosen.\n\tif err := s.teardownCircuit(pkt); err != nil {\n\t\tlog.Warnf(\"Unable to teardown circuit %s: %v\",\n\t\t\tpkt.inKey(), err)\n\t\treturn\n\t}\n\n\t// Finally, notify on the htlc failure or success that has been handled.\n\tkey := newHtlcKey(pkt)\n\teventType := getEventType(pkt)\n\n\tswitch htlc := pkt.htlc.(type) {\n\tcase *lnwire.UpdateFulfillHTLC:\n\t\ts.cfg.HtlcNotifier.NotifySettleEvent(key, htlc.PaymentPreimage,\n\t\t\teventType)\n\n\tcase *lnwire.UpdateFailHTLC:\n\t\ts.cfg.HtlcNotifier.NotifyForwardingFailEvent(key, eventType)\n\t}\n}\n\n// extractResult uses the given deobfuscator to extract the payment result from\n// the given network message.",
      "length": 2078,
      "tokens": 303,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) extractResult(deobfuscator ErrorDecrypter, n *networkResult,",
      "content": "func (s *Switch) extractResult(deobfuscator ErrorDecrypter, n *networkResult,\n\tattemptID uint64, paymentHash lntypes.Hash) (*PaymentResult, error) {\n\n\tswitch htlc := n.msg.(type) {\n\n\t// We've received a settle update which means we can finalize the user\n\t// payment and return successful response.\n\tcase *lnwire.UpdateFulfillHTLC:\n\t\treturn &PaymentResult{\n\t\t\tPreimage: htlc.PaymentPreimage,\n\t\t}, nil\n\n\t// We've received a fail update which means we can finalize the\n\t// user payment and return fail response.\n\tcase *lnwire.UpdateFailHTLC:\n\t\tpaymentErr := s.parseFailedPayment(\n\t\t\tdeobfuscator, attemptID, paymentHash, n.unencrypted,\n\t\t\tn.isResolution, htlc,\n\t\t)\n\n\t\treturn &PaymentResult{\n\t\t\tError: paymentErr,\n\t\t}, nil\n\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"received unknown response type: %T\",\n\t\t\thtlc)\n\t}\n}\n\n// parseFailedPayment determines the appropriate failure message to return to\n// a user initiated payment. The three cases handled are:\n//  1. An unencrypted failure, which should already plaintext.\n//  2. A resolution from the chain arbitrator, which possibly has no failure\n//     reason attached.\n//  3. A failure from the remote party, which will need to be decrypted using\n//     the payment deobfuscator.",
      "length": 1105,
      "tokens": 151,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) parseFailedPayment(deobfuscator ErrorDecrypter,",
      "content": "func (s *Switch) parseFailedPayment(deobfuscator ErrorDecrypter,\n\tattemptID uint64, paymentHash lntypes.Hash, unencrypted,\n\tisResolution bool, htlc *lnwire.UpdateFailHTLC) error {\n\n\tswitch {\n\n\t// The payment never cleared the link, so we don't need to\n\t// decrypt the error, simply decode it them report back to the\n\t// user.\n\tcase unencrypted:\n\t\tr := bytes.NewReader(htlc.Reason)\n\t\tfailureMsg, err := lnwire.DecodeFailure(r, 0)\n\t\tif err != nil {\n\t\t\t// If we could not decode the failure reason, return a link\n\t\t\t// error indicating that we failed to decode the onion.\n\t\t\tlinkError := NewDetailedLinkError(\n\t\t\t\t// As this didn't even clear the link, we don't\n\t\t\t\t// need to apply an update here since it goes\n\t\t\t\t// directly to the router.\n\t\t\t\tlnwire.NewTemporaryChannelFailure(nil),\n\t\t\t\tOutgoingFailureDecodeError,\n\t\t\t)\n\n\t\t\tlog.Errorf(\"%v: (hash=%v, pid=%d): %v\",\n\t\t\t\tlinkError.FailureDetail.FailureString(),\n\t\t\t\tpaymentHash, attemptID, err)\n\n\t\t\treturn linkError\n\t\t}\n\n\t\t// If we successfully decoded the failure reason, return it.\n\t\treturn NewLinkError(failureMsg)\n\n\t// A payment had to be timed out on chain before it got past\n\t// the first hop. In this case, we'll report a permanent\n\t// channel failure as this means us, or the remote party had to\n\t// go on chain.\n\tcase isResolution && htlc.Reason == nil:\n\t\tlinkError := NewDetailedLinkError(\n\t\t\t&lnwire.FailPermanentChannelFailure{},\n\t\t\tOutgoingFailureOnChainTimeout,\n\t\t)\n\n\t\tlog.Infof(\"%v: hash=%v, pid=%d\",\n\t\t\tlinkError.FailureDetail.FailureString(),\n\t\t\tpaymentHash, attemptID)\n\n\t\treturn linkError\n\n\t// A regular multi-hop payment error that we'll need to\n\t// decrypt.\n\tdefault:\n\t\t// We'll attempt to fully decrypt the onion encrypted\n\t\t// error. If we're unable to then we'll bail early.\n\t\tfailure, err := deobfuscator.DecryptError(htlc.Reason)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"unable to de-obfuscate onion failure \"+\n\t\t\t\t\"(hash=%v, pid=%d): %v\",\n\t\t\t\tpaymentHash, attemptID, err)\n\n\t\t\treturn ErrUnreadableFailureMessage\n\t\t}\n\n\t\treturn failure\n\t}\n}\n\n// handlePacketForward is used in cases when we need forward the htlc update\n// from one channel link to another and be able to propagate the settle/fail\n// updates back. This behaviour is achieved by creation of payment circuits.",
      "length": 2102,
      "tokens": 291,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) handlePacketForward(packet *htlcPacket) error {",
      "content": "func (s *Switch) handlePacketForward(packet *htlcPacket) error {\n\tswitch htlc := packet.htlc.(type) {\n\n\t// Channel link forwarded us a new htlc, therefore we initiate the\n\t// payment circuit within our internal state so we can properly forward\n\t// the ultimate settle message back latter.\n\tcase *lnwire.UpdateAddHTLC:\n\t\t// Check if the node is set to reject all onward HTLCs and also make\n\t\t// sure that HTLC is not from the source node.\n\t\tif s.cfg.RejectHTLC {\n\t\t\tfailure := NewDetailedLinkError(\n\t\t\t\t&lnwire.FailChannelDisabled{},\n\t\t\t\tOutgoingFailureForwardsDisabled,\n\t\t\t)\n\n\t\t\treturn s.failAddPacket(packet, failure)\n\t\t}\n\n\t\t// Before we attempt to find a non-strict forwarding path for\n\t\t// this htlc, check whether the htlc is being routed over the\n\t\t// same incoming and outgoing channel. If our node does not\n\t\t// allow forwards of this nature, we fail the htlc early. This\n\t\t// check is in place to disallow inefficiently routed htlcs from\n\t\t// locking up our balance. With channels where the\n\t\t// option-scid-alias feature was negotiated, we also have to be\n\t\t// sure that the IDs aren't the same since one or both could be\n\t\t// an alias.\n\t\tlinkErr := s.checkCircularForward(\n\t\t\tpacket.incomingChanID, packet.outgoingChanID,\n\t\t\ts.cfg.AllowCircularRoute, htlc.PaymentHash,\n\t\t)\n\t\tif linkErr != nil {\n\t\t\treturn s.failAddPacket(packet, linkErr)\n\t\t}\n\n\t\ts.indexMtx.RLock()\n\t\ttargetLink, err := s.getLinkByMapping(packet)\n\t\tif err != nil {\n\t\t\ts.indexMtx.RUnlock()\n\n\t\t\tlog.Debugf(\"unable to find link with \"+\n\t\t\t\t\"destination %v\", packet.outgoingChanID)\n\n\t\t\t// If packet was forwarded from another channel link\n\t\t\t// than we should notify this link that some error\n\t\t\t// occurred.\n\t\t\tlinkError := NewLinkError(\n\t\t\t\t&lnwire.FailUnknownNextPeer{},\n\t\t\t)\n\n\t\t\treturn s.failAddPacket(packet, linkError)\n\t\t}\n\t\ttargetPeerKey := targetLink.Peer().PubKey()\n\t\tinterfaceLinks, _ := s.getLinks(targetPeerKey)\n\t\ts.indexMtx.RUnlock()\n\n\t\t// We'll keep track of any HTLC failures during the link\n\t\t// selection process. This way we can return the error for\n\t\t// precise link that the sender selected, while optimistically\n\t\t// trying all links to utilize our available bandwidth.\n\t\tlinkErrs := make(map[lnwire.ShortChannelID]*LinkError)\n\n\t\t// Find all destination channel links with appropriate\n\t\t// bandwidth.\n\t\tvar destinations []ChannelLink\n\t\tfor _, link := range interfaceLinks {\n\t\t\tvar failure *LinkError\n\n\t\t\t// We'll skip any links that aren't yet eligible for\n\t\t\t// forwarding.\n\t\t\tif !link.EligibleToForward() {\n\t\t\t\tfailure = NewDetailedLinkError(\n\t\t\t\t\t&lnwire.FailUnknownNextPeer{},\n\t\t\t\t\tOutgoingFailureLinkNotEligible,\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\t// We'll ensure that the HTLC satisfies the\n\t\t\t\t// current forwarding conditions of this target\n\t\t\t\t// link.\n\t\t\t\tcurrentHeight := atomic.LoadUint32(&s.bestHeight)\n\t\t\t\tfailure = link.CheckHtlcForward(\n\t\t\t\t\thtlc.PaymentHash, packet.incomingAmount,\n\t\t\t\t\tpacket.amount, packet.incomingTimeout,\n\t\t\t\t\tpacket.outgoingTimeout, currentHeight,\n\t\t\t\t\tpacket.originalOutgoingChanID,\n\t\t\t\t)\n\t\t\t}\n\n\t\t\t// If this link can forward the htlc, add it to the set\n\t\t\t// of destinations.\n\t\t\tif failure == nil {\n\t\t\t\tdestinations = append(destinations, link)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tlinkErrs[link.ShortChanID()] = failure\n\t\t}\n\n\t\t// If we had a forwarding failure due to the HTLC not\n\t\t// satisfying the current policy, then we'll send back an\n\t\t// error, but ensure we send back the error sourced at the\n\t\t// *target* link.\n\t\tif len(destinations) == 0 {\n\t\t\t// At this point, some or all of the links rejected the\n\t\t\t// HTLC so we couldn't forward it. So we'll try to look\n\t\t\t// up the error that came from the source.\n\t\t\tlinkErr, ok := linkErrs[packet.outgoingChanID]\n\t\t\tif !ok {\n\t\t\t\t// If we can't find the error of the source,\n\t\t\t\t// then we'll return an unknown next peer,\n\t\t\t\t// though this should never happen.\n\t\t\t\tlinkErr = NewLinkError(\n\t\t\t\t\t&lnwire.FailUnknownNextPeer{},\n\t\t\t\t)\n\t\t\t\tlog.Warnf(\"unable to find err source for \"+\n\t\t\t\t\t\"outgoing_link=%v, errors=%v\",\n\t\t\t\t\tpacket.outgoingChanID, newLogClosure(func() string {\n\t\t\t\t\t\treturn spew.Sdump(linkErrs)\n\t\t\t\t\t}))\n\t\t\t}\n\n\t\t\tlog.Tracef(\"incoming HTLC(%x) violated \"+\n\t\t\t\t\"target outgoing link (id=%v) policy: %v\",\n\t\t\t\thtlc.PaymentHash[:], packet.outgoingChanID,\n\t\t\t\tlinkErr)\n\n\t\t\treturn s.failAddPacket(packet, linkErr)\n\t\t}\n\n\t\t// Choose a random link out of the set of links that can forward\n\t\t// this htlc. The reason for randomization is to evenly\n\t\t// distribute the htlc load without making assumptions about\n\t\t// what the best channel is.\n\t\tdestination := destinations[rand.Intn(len(destinations))] // nolint:gosec\n\n\t\t// Retrieve the incoming link by its ShortChannelID. Note that\n\t\t// the incomingChanID is never set to hop.Source here.\n\t\ts.indexMtx.RLock()\n\t\tincomingLink, err := s.getLinkByShortID(packet.incomingChanID)\n\t\ts.indexMtx.RUnlock()\n\t\tif err != nil {\n\t\t\t// If we couldn't find the incoming link, we can't\n\t\t\t// evaluate the incoming's exposure to dust, so we just\n\t\t\t// fail the HTLC back.\n\t\t\tlinkErr := NewLinkError(\n\t\t\t\t&lnwire.FailTemporaryChannelFailure{},\n\t\t\t)\n\n\t\t\treturn s.failAddPacket(packet, linkErr)\n\t\t}\n\n\t\t// Evaluate whether this HTLC would increase our exposure to\n\t\t// dust on the incoming link. If it does, fail it backwards.\n\t\tif s.evaluateDustThreshold(\n\t\t\tincomingLink, packet.incomingAmount, true,\n\t\t) {\n\t\t\t// The incoming dust exceeds the threshold, so we fail\n\t\t\t// the add back.\n\t\t\tlinkErr := NewLinkError(\n\t\t\t\t&lnwire.FailTemporaryChannelFailure{},\n\t\t\t)\n\n\t\t\treturn s.failAddPacket(packet, linkErr)\n\t\t}\n\n\t\t// Also evaluate whether this HTLC would increase our exposure\n\t\t// to dust on the destination link. If it does, fail it back.\n\t\tif s.evaluateDustThreshold(\n\t\t\tdestination, packet.amount, false,\n\t\t) {\n\t\t\t// The outgoing dust exceeds the threshold, so we fail\n\t\t\t// the add back.\n\t\t\tlinkErr := NewLinkError(\n\t\t\t\t&lnwire.FailTemporaryChannelFailure{},\n\t\t\t)\n\n\t\t\treturn s.failAddPacket(packet, linkErr)\n\t\t}\n\n\t\t// Send the packet to the destination channel link which\n\t\t// manages the channel.\n\t\tpacket.outgoingChanID = destination.ShortChanID()\n\t\treturn destination.handleSwitchPacket(packet)\n\n\tcase *lnwire.UpdateFailHTLC, *lnwire.UpdateFulfillHTLC:\n\t\t// If the source of this packet has not been set, use the\n\t\t// circuit map to lookup the origin.\n\t\tcircuit, err := s.closeCircuit(packet)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// closeCircuit returns a nil circuit when a settle packet returns an\n\t\t// ErrUnknownCircuit error upon the inner call to CloseCircuit.\n\t\tif circuit == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\tfail, isFail := htlc.(*lnwire.UpdateFailHTLC)\n\t\tif isFail && !packet.hasSource {\n\t\t\tswitch {\n\t\t\t// No message to encrypt, locally sourced payment.\n\t\t\tcase circuit.ErrorEncrypter == nil:\n\n\t\t\t// If this is a resolution message, then we'll need to\n\t\t\t// encrypt it as it's actually internally sourced.\n\t\t\tcase packet.isResolution:\n\t\t\t\tvar err error\n\t\t\t\t// TODO(roasbeef): don't need to pass actually?\n\t\t\t\tfailure := &lnwire.FailPermanentChannelFailure{}\n\t\t\t\tfail.Reason, err = circuit.ErrorEncrypter.EncryptFirstHop(\n\t\t\t\t\tfailure,\n\t\t\t\t)\n\t\t\t\tif err != nil {\n\t\t\t\t\terr = fmt.Errorf(\"unable to obfuscate \"+\n\t\t\t\t\t\t\"error: %v\", err)\n\t\t\t\t\tlog.Error(err)\n\t\t\t\t}\n\n\t\t\t// Alternatively, if the remote party send us an\n\t\t\t// UpdateFailMalformedHTLC, then we'll need to convert\n\t\t\t// this into a proper well formatted onion error as\n\t\t\t// there's no HMAC currently.\n\t\t\tcase packet.convertedError:\n\t\t\t\tlog.Infof(\"Converting malformed HTLC error \"+\n\t\t\t\t\t\"for circuit for Circuit(%x: \"+\n\t\t\t\t\t\"(%s, %d) <-> (%s, %d))\", packet.circuit.PaymentHash,\n\t\t\t\t\tpacket.incomingChanID, packet.incomingHTLCID,\n\t\t\t\t\tpacket.outgoingChanID, packet.outgoingHTLCID)\n\n\t\t\t\tfail.Reason = circuit.ErrorEncrypter.EncryptMalformedError(\n\t\t\t\t\tfail.Reason,\n\t\t\t\t)\n\n\t\t\tdefault:\n\t\t\t\t// Otherwise, it's a forwarded error, so we'll perform a\n\t\t\t\t// wrapper encryption as normal.\n\t\t\t\tfail.Reason = circuit.ErrorEncrypter.IntermediateEncrypt(\n\t\t\t\t\tfail.Reason,\n\t\t\t\t)\n\t\t\t}\n\t\t} else if !isFail && circuit.Outgoing != nil {\n\t\t\t// If this is an HTLC settle, and it wasn't from a\n\t\t\t// locally initiated HTLC, then we'll log a forwarding\n\t\t\t// event so we can flush it to disk later.\n\t\t\t//\n\t\t\t// TODO(roasbeef): only do this once link actually\n\t\t\t// fully settles?\n\t\t\tlocalHTLC := packet.incomingChanID == hop.Source\n\t\t\tif !localHTLC {\n\t\t\t\tlog.Infof(\"Forwarded HTLC(%x) of %v (fee: %v) \"+\n\t\t\t\t\t\"from IncomingChanID(%v) to OutgoingChanID(%v)\",\n\t\t\t\t\tcircuit.PaymentHash[:], circuit.OutgoingAmount,\n\t\t\t\t\tcircuit.IncomingAmount-circuit.OutgoingAmount,\n\t\t\t\t\tcircuit.Incoming.ChanID, circuit.Outgoing.ChanID)\n\t\t\t\ts.fwdEventMtx.Lock()\n\t\t\t\ts.pendingFwdingEvents = append(\n\t\t\t\t\ts.pendingFwdingEvents,\n\t\t\t\t\tchanneldb.ForwardingEvent{\n\t\t\t\t\t\tTimestamp:      time.Now(),\n\t\t\t\t\t\tIncomingChanID: circuit.Incoming.ChanID,\n\t\t\t\t\t\tOutgoingChanID: circuit.Outgoing.ChanID,\n\t\t\t\t\t\tAmtIn:          circuit.IncomingAmount,\n\t\t\t\t\t\tAmtOut:         circuit.OutgoingAmount,\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t\ts.fwdEventMtx.Unlock()\n\t\t\t}\n\t\t}\n\n\t\t// A blank IncomingChanID in a circuit indicates that it is a pending\n\t\t// user-initiated payment.\n\t\tif packet.incomingChanID == hop.Source {\n\t\t\ts.wg.Add(1)\n\t\t\tgo s.handleLocalResponse(packet)\n\t\t\treturn nil\n\t\t}\n\n\t\t// Check to see that the source link is online before removing\n\t\t// the circuit.\n\t\treturn s.mailOrchestrator.Deliver(packet.incomingChanID, packet)\n\n\tdefault:\n\t\treturn errors.New(\"wrong update type\")\n\t}\n}\n\n// checkCircularForward checks whether a forward is circular (arrives and\n// departs on the same link) and returns a link error if the switch is\n// configured to disallow this behaviour.",
      "length": 9202,
      "tokens": 1177,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) checkCircularForward(incoming, outgoing lnwire.ShortChannelID,",
      "content": "func (s *Switch) checkCircularForward(incoming, outgoing lnwire.ShortChannelID,\n\tallowCircular bool, paymentHash lntypes.Hash) *LinkError {\n\n\t// If they are equal, we can skip the alias mapping checks.\n\tif incoming == outgoing {\n\t\t// The switch may be configured to allow circular routes, so\n\t\t// just log and return nil.\n\t\tif allowCircular {\n\t\t\tlog.Debugf(\"allowing circular route over link: %v \"+\n\t\t\t\t\"(payment hash: %x)\", incoming, paymentHash)\n\t\t\treturn nil\n\t\t}\n\n\t\t// Otherwise, we'll return a temporary channel failure.\n\t\treturn NewDetailedLinkError(\n\t\t\tlnwire.NewTemporaryChannelFailure(nil),\n\t\t\tOutgoingFailureCircularRoute,\n\t\t)\n\t}\n\n\t// We'll fetch the \"base\" SCID from the baseIndex for the incoming and\n\t// outgoing SCIDs. If either one does not have a base SCID, then the\n\t// two channels are not equal since one will be a channel that does not\n\t// need a mapping and SCID equality was checked above. If the \"base\"\n\t// SCIDs are equal, then this is a circular route. Otherwise, it isn't.\n\ts.indexMtx.RLock()\n\tincomingBaseScid, ok := s.baseIndex[incoming]\n\tif !ok {\n\t\t// This channel does not use baseIndex, bail out.\n\t\ts.indexMtx.RUnlock()\n\t\treturn nil\n\t}\n\n\toutgoingBaseScid, ok := s.baseIndex[outgoing]\n\tif !ok {\n\t\t// This channel does not use baseIndex, bail out.\n\t\ts.indexMtx.RUnlock()\n\t\treturn nil\n\t}\n\ts.indexMtx.RUnlock()\n\n\t// Check base SCID equality.\n\tif incomingBaseScid != outgoingBaseScid {\n\t\t// The base SCIDs are not equal so these are not the same\n\t\t// channel.\n\t\treturn nil\n\t}\n\n\t// If the incoming and outgoing link are equal, the htlc is part of a\n\t// circular route which may be used to lock up our liquidity. If the\n\t// switch is configured to allow circular routes, log that we are\n\t// allowing the route then return nil.\n\tif allowCircular {\n\t\tlog.Debugf(\"allowing circular route over link: %v \"+\n\t\t\t\"(payment hash: %x)\", incoming, paymentHash)\n\t\treturn nil\n\t}\n\n\t// If our node disallows circular routes, return a temporary channel\n\t// failure. There is nothing wrong with the policy used by the remote\n\t// node, so we do not include a channel update.\n\treturn NewDetailedLinkError(\n\t\tlnwire.NewTemporaryChannelFailure(nil),\n\t\tOutgoingFailureCircularRoute,\n\t)\n}\n\n// failAddPacket encrypts a fail packet back to an add packet's source.\n// The ciphertext will be derived from the failure message proivded by context.\n// This method returns the failErr if all other steps complete successfully.",
      "length": 2270,
      "tokens": 353,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) failAddPacket(packet *htlcPacket, failure *LinkError) error {",
      "content": "func (s *Switch) failAddPacket(packet *htlcPacket, failure *LinkError) error {\n\t// Encrypt the failure so that the sender will be able to read the error\n\t// message. Since we failed this packet, we use EncryptFirstHop to\n\t// obfuscate the failure for their eyes only.\n\treason, err := packet.obfuscator.EncryptFirstHop(failure.WireMessage())\n\tif err != nil {\n\t\terr := fmt.Errorf(\"unable to obfuscate \"+\n\t\t\t\"error: %v\", err)\n\t\tlog.Error(err)\n\t\treturn err\n\t}\n\n\tlog.Error(failure.Error())\n\n\t// Create a failure packet for this htlc. The the full set of\n\t// information about the htlc failure is included so that they can\n\t// be included in link failure notifications.\n\tfailPkt := &htlcPacket{\n\t\tsourceRef:       packet.sourceRef,\n\t\tincomingChanID:  packet.incomingChanID,\n\t\tincomingHTLCID:  packet.incomingHTLCID,\n\t\toutgoingChanID:  packet.outgoingChanID,\n\t\toutgoingHTLCID:  packet.outgoingHTLCID,\n\t\tincomingAmount:  packet.incomingAmount,\n\t\tamount:          packet.amount,\n\t\tincomingTimeout: packet.incomingTimeout,\n\t\toutgoingTimeout: packet.outgoingTimeout,\n\t\tcircuit:         packet.circuit,\n\t\tlinkFailure:     failure,\n\t\thtlc: &lnwire.UpdateFailHTLC{\n\t\t\tReason: reason,\n\t\t},\n\t}\n\n\t// Route a fail packet back to the source link.\n\terr = s.mailOrchestrator.Deliver(failPkt.incomingChanID, failPkt)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"source chanid=%v unable to \"+\n\t\t\t\"handle switch packet: %v\",\n\t\t\tpacket.incomingChanID, err)\n\t\tlog.Error(err)\n\t\treturn err\n\t}\n\n\treturn failure\n}\n\n// closeCircuit accepts a settle or fail htlc and the associated htlc packet and\n// attempts to determine the source that forwarded this htlc. This method will\n// set the incoming chan and htlc ID of the given packet if the source was\n// found, and will properly [re]encrypt any failure messages.",
      "length": 1645,
      "tokens": 211,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) closeCircuit(pkt *htlcPacket) (*PaymentCircuit, error) {",
      "content": "func (s *Switch) closeCircuit(pkt *htlcPacket) (*PaymentCircuit, error) {\n\t// If the packet has its source, that means it was failed locally by\n\t// the outgoing link. We fail it here to make sure only one response\n\t// makes it through the switch.\n\tif pkt.hasSource {\n\t\tcircuit, err := s.circuits.FailCircuit(pkt.inKey())\n\t\tswitch err {\n\n\t\t// Circuit successfully closed.\n\t\tcase nil:\n\t\t\treturn circuit, nil\n\n\t\t// Circuit was previously closed, but has not been deleted.\n\t\t// We'll just drop this response until the circuit has been\n\t\t// fully removed.\n\t\tcase ErrCircuitClosing:\n\t\t\treturn nil, err\n\n\t\t// Failed to close circuit because it does not exist. This is\n\t\t// likely because the circuit was already successfully closed.\n\t\t// Since this packet failed locally, there is no forwarding\n\t\t// package entry to acknowledge.\n\t\tcase ErrUnknownCircuit:\n\t\t\treturn nil, err\n\n\t\t// Unexpected error.\n\t\tdefault:\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Otherwise, this is packet was received from the remote party.  Use\n\t// circuit map to find the incoming link to receive the settle/fail.\n\tcircuit, err := s.circuits.CloseCircuit(pkt.outKey())\n\tswitch err {\n\n\t// Open circuit successfully closed.\n\tcase nil:\n\t\tpkt.incomingChanID = circuit.Incoming.ChanID\n\t\tpkt.incomingHTLCID = circuit.Incoming.HtlcID\n\t\tpkt.circuit = circuit\n\t\tpkt.sourceRef = &circuit.AddRef\n\n\t\tpktType := \"SETTLE\"\n\t\tif _, ok := pkt.htlc.(*lnwire.UpdateFailHTLC); ok {\n\t\t\tpktType = \"FAIL\"\n\t\t}\n\n\t\tlog.Debugf(\"Closed completed %s circuit for %x: \"+\n\t\t\t\"(%s, %d) <-> (%s, %d)\", pktType, pkt.circuit.PaymentHash,\n\t\t\tpkt.incomingChanID, pkt.incomingHTLCID,\n\t\t\tpkt.outgoingChanID, pkt.outgoingHTLCID)\n\n\t\treturn circuit, nil\n\n\t// Circuit was previously closed, but has not been deleted. We'll just\n\t// drop this response until the circuit has been removed.\n\tcase ErrCircuitClosing:\n\t\treturn nil, err\n\n\t// Failed to close circuit because it does not exist. This is likely\n\t// because the circuit was already successfully closed.\n\tcase ErrUnknownCircuit:\n\t\tif pkt.destRef != nil {\n\t\t\t// Add this SettleFailRef to the set of pending settle/fail entries\n\t\t\t// awaiting acknowledgement.\n\t\t\ts.pendingSettleFails = append(s.pendingSettleFails, *pkt.destRef)\n\t\t}\n\n\t\t// If this is a settle, we will not log an error message as settles\n\t\t// are expected to hit the ErrUnknownCircuit case. The only way fails\n\t\t// can hit this case if the link restarts after having just sent a fail\n\t\t// to the switch.\n\t\t_, isSettle := pkt.htlc.(*lnwire.UpdateFulfillHTLC)\n\t\tif !isSettle {\n\t\t\terr := fmt.Errorf(\"unable to find target channel \"+\n\t\t\t\t\"for HTLC fail: channel ID = %s, \"+\n\t\t\t\t\"HTLC ID = %d\", pkt.outgoingChanID,\n\t\t\t\tpkt.outgoingHTLCID)\n\t\t\tlog.Error(err)\n\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn nil, nil\n\n\t// Unexpected error.\n\tdefault:\n\t\treturn nil, err\n\t}\n}\n\n// ackSettleFail is used by the switch to ACK any settle/fail entries in the\n// forwarding package of the outgoing link for a payment circuit. We do this if\n// we're the originator of the payment, so the link stops attempting to\n// re-broadcast.",
      "length": 2860,
      "tokens": 427,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) ackSettleFail(settleFailRefs ...channeldb.SettleFailRef) error {",
      "content": "func (s *Switch) ackSettleFail(settleFailRefs ...channeldb.SettleFailRef) error {\n\treturn kvdb.Batch(s.cfg.DB, func(tx kvdb.RwTx) error {\n\t\treturn s.cfg.SwitchPackager.AckSettleFails(tx, settleFailRefs...)\n\t})\n}\n\n// teardownCircuit removes a pending or open circuit from the switch's circuit\n// map and prints useful logging statements regarding the outcome.",
      "length": 270,
      "tokens": 33,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) teardownCircuit(pkt *htlcPacket) error {",
      "content": "func (s *Switch) teardownCircuit(pkt *htlcPacket) error {\n\tvar pktType string\n\tswitch htlc := pkt.htlc.(type) {\n\tcase *lnwire.UpdateFulfillHTLC:\n\t\tpktType = \"SETTLE\"\n\tcase *lnwire.UpdateFailHTLC:\n\t\tpktType = \"FAIL\"\n\tdefault:\n\t\terr := fmt.Errorf(\"cannot tear down packet of type: %T\", htlc)\n\t\tlog.Errorf(err.Error())\n\t\treturn err\n\t}\n\n\tswitch {\n\tcase pkt.circuit.HasKeystone():\n\t\tlog.Debugf(\"Tearing down open circuit with %s pkt, removing circuit=%v \"+\n\t\t\t\"with keystone=%v\", pktType, pkt.inKey(), pkt.outKey())\n\n\t\terr := s.circuits.DeleteCircuits(pkt.inKey())\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"Failed to tear down open circuit (%s, %d) <-> (%s, %d) \"+\n\t\t\t\t\"with payment_hash-%v using %s pkt\",\n\t\t\t\tpkt.incomingChanID, pkt.incomingHTLCID,\n\t\t\t\tpkt.outgoingChanID, pkt.outgoingHTLCID,\n\t\t\t\tpkt.circuit.PaymentHash, pktType)\n\t\t\treturn err\n\t\t}\n\n\t\tlog.Debugf(\"Closed completed %s circuit for %x: \"+\n\t\t\t\"(%s, %d) <-> (%s, %d)\", pktType, pkt.circuit.PaymentHash,\n\t\t\tpkt.incomingChanID, pkt.incomingHTLCID,\n\t\t\tpkt.outgoingChanID, pkt.outgoingHTLCID)\n\n\tdefault:\n\t\tlog.Debugf(\"Tearing down incomplete circuit with %s for inkey=%v\",\n\t\t\tpktType, pkt.inKey())\n\n\t\terr := s.circuits.DeleteCircuits(pkt.inKey())\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"Failed to tear down pending %s circuit for %x: \"+\n\t\t\t\t\"(%s, %d)\", pktType, pkt.circuit.PaymentHash,\n\t\t\t\tpkt.incomingChanID, pkt.incomingHTLCID)\n\t\t\treturn err\n\t\t}\n\n\t\tlog.Debugf(\"Removed pending onion circuit for %x: \"+\n\t\t\t\"(%s, %d)\", pkt.circuit.PaymentHash,\n\t\t\tpkt.incomingChanID, pkt.incomingHTLCID)\n\t}\n\n\treturn nil\n}\n\n// CloseLink creates and sends the close channel command to the target link\n// directing the specified closure type. If the closure type is CloseRegular,\n// targetFeePerKw parameter should be the ideal fee-per-kw that will be used as\n// a starting point for close negotiation. The deliveryScript parameter is an\n// optional parameter which sets a user specified script to close out to.",
      "length": 1814,
      "tokens": 221,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) CloseLink(chanPoint *wire.OutPoint,",
      "content": "func (s *Switch) CloseLink(chanPoint *wire.OutPoint,\n\tcloseType contractcourt.ChannelCloseType,\n\ttargetFeePerKw, maxFee chainfee.SatPerKWeight,\n\tdeliveryScript lnwire.DeliveryAddress) (chan interface{}, chan error) {\n\n\t// TODO(roasbeef) abstract out the close updates.\n\tupdateChan := make(chan interface{}, 2)\n\terrChan := make(chan error, 1)\n\n\tcommand := &ChanClose{\n\t\tCloseType:      closeType,\n\t\tChanPoint:      chanPoint,\n\t\tUpdates:        updateChan,\n\t\tTargetFeePerKw: targetFeePerKw,\n\t\tMaxFee:         maxFee,\n\t\tDeliveryScript: deliveryScript,\n\t\tErr:            errChan,\n\t}\n\n\tselect {\n\tcase s.chanCloseRequests <- command:\n\t\treturn updateChan, errChan\n\n\tcase <-s.quit:\n\t\terrChan <- ErrSwitchExiting\n\t\tclose(updateChan)\n\t\treturn updateChan, errChan\n\t}\n}\n\n// htlcForwarder is responsible for optimally forwarding (and possibly\n// fragmenting) incoming/outgoing HTLCs amongst all active interfaces and their\n// links. The duties of the forwarder are similar to that of a network switch,\n// in that it facilitates multi-hop payments by acting as a central messaging\n// bus. The switch communicates will active links to create, manage, and tear\n// down active onion routed payments. Each active channel is modeled as\n// networked device with metadata such as the available payment bandwidth, and\n// total link capacity.\n//\n// NOTE: This MUST be run as a goroutine.",
      "length": 1273,
      "tokens": 165,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) htlcForwarder() {",
      "content": "func (s *Switch) htlcForwarder() {\n\tdefer s.wg.Done()\n\n\tdefer func() {\n\t\ts.blockEpochStream.Cancel()\n\n\t\t// Remove all links once we've been signalled for shutdown.\n\t\tvar linksToStop []ChannelLink\n\t\ts.indexMtx.Lock()\n\t\tfor _, link := range s.linkIndex {\n\t\t\tactiveLink := s.removeLink(link.ChanID())\n\t\t\tif activeLink == nil {\n\t\t\t\tlog.Errorf(\"unable to remove ChannelLink(%v) \"+\n\t\t\t\t\t\"on stop\", link.ChanID())\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tlinksToStop = append(linksToStop, activeLink)\n\t\t}\n\t\tfor _, link := range s.pendingLinkIndex {\n\t\t\tpendingLink := s.removeLink(link.ChanID())\n\t\t\tif pendingLink == nil {\n\t\t\t\tlog.Errorf(\"unable to remove ChannelLink(%v) \"+\n\t\t\t\t\t\"on stop\", link.ChanID())\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tlinksToStop = append(linksToStop, pendingLink)\n\t\t}\n\t\ts.indexMtx.Unlock()\n\n\t\t// Now that all pending and live links have been removed from\n\t\t// the forwarding indexes, stop each one before shutting down.\n\t\t// We'll shut them down in parallel to make exiting as fast as\n\t\t// possible.\n\t\tvar wg sync.WaitGroup\n\t\tfor _, link := range linksToStop {\n\t\t\twg.Add(1)\n\t\t\tgo func(l ChannelLink) {\n\t\t\t\tdefer wg.Done()\n\n\t\t\t\tl.Stop()\n\t\t\t}(link)\n\t\t}\n\t\twg.Wait()\n\n\t\t// Before we exit fully, we'll attempt to flush out any\n\t\t// forwarding events that may still be lingering since the last\n\t\t// batch flush.\n\t\tif err := s.FlushForwardingEvents(); err != nil {\n\t\t\tlog.Errorf(\"unable to flush forwarding events: %v\", err)\n\t\t}\n\t}()\n\n\t// TODO(roasbeef): cleared vs settled distinction\n\tvar (\n\t\ttotalNumUpdates uint64\n\t\ttotalSatSent    btcutil.Amount\n\t\ttotalSatRecv    btcutil.Amount\n\t)\n\ts.cfg.LogEventTicker.Resume()\n\tdefer s.cfg.LogEventTicker.Stop()\n\n\t// Every 15 seconds, we'll flush out the forwarding events that\n\t// occurred during that period.\n\ts.cfg.FwdEventTicker.Resume()\n\tdefer s.cfg.FwdEventTicker.Stop()\n\n\tdefer s.cfg.AckEventTicker.Stop()\n\nout:\n\tfor {\n\n\t\t// If the set of pending settle/fail entries is non-zero,\n\t\t// reinstate the ack ticker so we can batch ack them.\n\t\tif len(s.pendingSettleFails) > 0 {\n\t\t\ts.cfg.AckEventTicker.Resume()\n\t\t}\n\n\t\tselect {\n\t\tcase blockEpoch, ok := <-s.blockEpochStream.Epochs:\n\t\t\tif !ok {\n\t\t\t\tbreak out\n\t\t\t}\n\n\t\t\tatomic.StoreUint32(&s.bestHeight, uint32(blockEpoch.Height))\n\n\t\t// A local close request has arrived, we'll forward this to the\n\t\t// relevant link (if it exists) so the channel can be\n\t\t// cooperatively closed (if possible).\n\t\tcase req := <-s.chanCloseRequests:\n\t\t\tchanID := lnwire.NewChanIDFromOutPoint(req.ChanPoint)\n\n\t\t\ts.indexMtx.RLock()\n\t\t\tlink, ok := s.linkIndex[chanID]\n\t\t\tif !ok {\n\t\t\t\ts.indexMtx.RUnlock()\n\n\t\t\t\treq.Err <- fmt.Errorf(\"no peer for channel with \"+\n\t\t\t\t\t\"chan_id=%x\", chanID[:])\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ts.indexMtx.RUnlock()\n\n\t\t\tpeerPub := link.Peer().PubKey()\n\t\t\tlog.Debugf(\"Requesting local channel close: peer=%v, \"+\n\t\t\t\t\"chan_id=%x\", link.Peer(), chanID[:])\n\n\t\t\tgo s.cfg.LocalChannelClose(peerPub[:], req)\n\n\t\tcase resolutionMsg := <-s.resolutionMsgs:\n\t\t\t// We'll persist the resolution message to the Switch's\n\t\t\t// resolution store.\n\t\t\tresMsg := resolutionMsg.ResolutionMsg\n\t\t\terr := s.resMsgStore.addResolutionMsg(&resMsg)\n\t\t\tif err != nil {\n\t\t\t\t// This will only fail if there is a database\n\t\t\t\t// error or a serialization error. Sending the\n\t\t\t\t// error prevents the contractcourt from being\n\t\t\t\t// in a state where it believes the send was\n\t\t\t\t// successful, when it wasn't.\n\t\t\t\tlog.Errorf(\"unable to add resolution msg: %v\",\n\t\t\t\t\terr)\n\t\t\t\tresolutionMsg.errChan <- err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// At this point, the resolution message has been\n\t\t\t// persisted. It is safe to signal success by sending\n\t\t\t// a nil error since the Switch will re-deliver the\n\t\t\t// resolution message on restart.\n\t\t\tresolutionMsg.errChan <- nil\n\n\t\t\tpkt := &htlcPacket{\n\t\t\t\toutgoingChanID: resolutionMsg.SourceChan,\n\t\t\t\toutgoingHTLCID: resolutionMsg.HtlcIndex,\n\t\t\t\tisResolution:   true,\n\t\t\t}\n\n\t\t\t// Resolution messages will either be cancelling\n\t\t\t// backwards an existing HTLC, or settling a previously\n\t\t\t// outgoing HTLC. Based on this, we'll map the message\n\t\t\t// to the proper htlcPacket.\n\t\t\tif resolutionMsg.Failure != nil {\n\t\t\t\tpkt.htlc = &lnwire.UpdateFailHTLC{}\n\t\t\t} else {\n\t\t\t\tpkt.htlc = &lnwire.UpdateFulfillHTLC{\n\t\t\t\t\tPaymentPreimage: *resolutionMsg.PreImage,\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlog.Infof(\"Received outside contract resolution, \"+\n\t\t\t\t\"mapping to: %v\", spew.Sdump(pkt))\n\n\t\t\t// We don't check the error, as the only failure we can\n\t\t\t// encounter is due to the circuit already being\n\t\t\t// closed. This is fine, as processing this message is\n\t\t\t// meant to be idempotent.\n\t\t\terr = s.handlePacketForward(pkt)\n\t\t\tif err != nil {\n\t\t\t\tlog.Errorf(\"Unable to forward resolution msg: %v\", err)\n\t\t\t}\n\n\t\t// A new packet has arrived for forwarding, we'll interpret the\n\t\t// packet concretely, then either forward it along, or\n\t\t// interpret a return packet to a locally initialized one.\n\t\tcase cmd := <-s.htlcPlex:\n\t\t\tcmd.err <- s.handlePacketForward(cmd.pkt)\n\n\t\t// When this time ticks, then it indicates that we should\n\t\t// collect all the forwarding events since the last internal,\n\t\t// and write them out to our log.\n\t\tcase <-s.cfg.FwdEventTicker.Ticks():\n\t\t\ts.wg.Add(1)\n\t\t\tgo func() {\n\t\t\t\tdefer s.wg.Done()\n\n\t\t\t\tif err := s.FlushForwardingEvents(); err != nil {\n\t\t\t\t\tlog.Errorf(\"unable to flush \"+\n\t\t\t\t\t\t\"forwarding events: %v\", err)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t// The log ticker has fired, so we'll calculate some forwarding\n\t\t// stats for the last 10 seconds to display within the logs to\n\t\t// users.\n\t\tcase <-s.cfg.LogEventTicker.Ticks():\n\t\t\t// First, we'll collate the current running tally of\n\t\t\t// our forwarding stats.\n\t\t\tprevSatSent := totalSatSent\n\t\t\tprevSatRecv := totalSatRecv\n\t\t\tprevNumUpdates := totalNumUpdates\n\n\t\t\tvar (\n\t\t\t\tnewNumUpdates uint64\n\t\t\t\tnewSatSent    btcutil.Amount\n\t\t\t\tnewSatRecv    btcutil.Amount\n\t\t\t)\n\n\t\t\t// Next, we'll run through all the registered links and\n\t\t\t// compute their up-to-date forwarding stats.\n\t\t\ts.indexMtx.RLock()\n\t\t\tfor _, link := range s.linkIndex {\n\t\t\t\t// TODO(roasbeef): when links first registered\n\t\t\t\t// stats printed.\n\t\t\t\tupdates, sent, recv := link.Stats()\n\t\t\t\tnewNumUpdates += updates\n\t\t\t\tnewSatSent += sent.ToSatoshis()\n\t\t\t\tnewSatRecv += recv.ToSatoshis()\n\t\t\t}\n\t\t\ts.indexMtx.RUnlock()\n\n\t\t\tvar (\n\t\t\t\tdiffNumUpdates uint64\n\t\t\t\tdiffSatSent    btcutil.Amount\n\t\t\t\tdiffSatRecv    btcutil.Amount\n\t\t\t)\n\n\t\t\t// If this is the first time we're computing these\n\t\t\t// stats, then the diff is just the new value. We do\n\t\t\t// this in order to avoid integer underflow issues.\n\t\t\tif prevNumUpdates == 0 {\n\t\t\t\tdiffNumUpdates = newNumUpdates\n\t\t\t\tdiffSatSent = newSatSent\n\t\t\t\tdiffSatRecv = newSatRecv\n\t\t\t} else {\n\t\t\t\tdiffNumUpdates = newNumUpdates - prevNumUpdates\n\t\t\t\tdiffSatSent = newSatSent - prevSatSent\n\t\t\t\tdiffSatRecv = newSatRecv - prevSatRecv\n\t\t\t}\n\n\t\t\t// If the diff of num updates is zero, then we haven't\n\t\t\t// forwarded anything in the last 10 seconds, so we can\n\t\t\t// skip this update.\n\t\t\tif diffNumUpdates == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// If the diff of num updates is negative, then some\n\t\t\t// links may have been unregistered from the switch, so\n\t\t\t// we'll update our stats to only include our registered\n\t\t\t// links.\n\t\t\tif int64(diffNumUpdates) < 0 {\n\t\t\t\ttotalNumUpdates = newNumUpdates\n\t\t\t\ttotalSatSent = newSatSent\n\t\t\t\ttotalSatRecv = newSatRecv\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Otherwise, we'll log this diff, then accumulate the\n\t\t\t// new stats into the running total.\n\t\t\tlog.Debugf(\"Sent %d satoshis and received %d satoshis \"+\n\t\t\t\t\"in the last 10 seconds (%f tx/sec)\",\n\t\t\t\tdiffSatSent, diffSatRecv,\n\t\t\t\tfloat64(diffNumUpdates)/10)\n\n\t\t\ttotalNumUpdates += diffNumUpdates\n\t\t\ttotalSatSent += diffSatSent\n\t\t\ttotalSatRecv += diffSatRecv\n\n\t\t// The ack ticker has fired so if we have any settle/fail entries\n\t\t// for a forwarding package to ack, we will do so here in a batch\n\t\t// db call.\n\t\tcase <-s.cfg.AckEventTicker.Ticks():\n\t\t\t// If the current set is empty, pause the ticker.\n\t\t\tif len(s.pendingSettleFails) == 0 {\n\t\t\t\ts.cfg.AckEventTicker.Pause()\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Batch ack the settle/fail entries.\n\t\t\tif err := s.ackSettleFail(s.pendingSettleFails...); err != nil {\n\t\t\t\tlog.Errorf(\"Unable to ack batch of settle/fails: %v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tlog.Tracef(\"Acked %d settle fails: %v\", len(s.pendingSettleFails),\n\t\t\t\tnewLogClosure(func() string {\n\t\t\t\t\treturn spew.Sdump(s.pendingSettleFails)\n\t\t\t\t}))\n\n\t\t\t// Reset the pendingSettleFails buffer while keeping acquired\n\t\t\t// memory.\n\t\t\ts.pendingSettleFails = s.pendingSettleFails[:0]\n\n\t\tcase <-s.quit:\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// Start starts all helper goroutines required for the operation of the switch.",
      "length": 8214,
      "tokens": 1092,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) Start() error {",
      "content": "func (s *Switch) Start() error {\n\tif !atomic.CompareAndSwapInt32(&s.started, 0, 1) {\n\t\tlog.Warn(\"Htlc Switch already started\")\n\t\treturn errors.New(\"htlc switch already started\")\n\t}\n\n\tlog.Infof(\"HTLC Switch starting\")\n\n\tblockEpochStream, err := s.cfg.Notifier.RegisterBlockEpochNtfn(nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.blockEpochStream = blockEpochStream\n\n\ts.wg.Add(1)\n\tgo s.htlcForwarder()\n\n\tif err := s.reforwardResponses(); err != nil {\n\t\ts.Stop()\n\t\tlog.Errorf(\"unable to reforward responses: %v\", err)\n\t\treturn err\n\t}\n\n\tif err := s.reforwardResolutions(); err != nil {\n\t\t// We are already stopping so we can ignore the error.\n\t\t_ = s.Stop()\n\t\tlog.Errorf(\"unable to reforward resolutions: %v\", err)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// reforwardResolutions fetches the set of resolution messages stored on-disk\n// and reforwards them if their circuits are still open. If the circuits have\n// been deleted, then we will delete the resolution message from the database.",
      "length": 905,
      "tokens": 125,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) reforwardResolutions() error {",
      "content": "func (s *Switch) reforwardResolutions() error {\n\t// Fetch all stored resolution messages, deleting the ones that are\n\t// resolved.\n\tresMsgs, err := s.resMsgStore.fetchAllResolutionMsg()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tswitchPackets := make([]*htlcPacket, 0, len(resMsgs))\n\tfor _, resMsg := range resMsgs {\n\t\t// If the open circuit no longer exists, then we can remove the\n\t\t// message from the store.\n\t\toutKey := CircuitKey{\n\t\t\tChanID: resMsg.SourceChan,\n\t\t\tHtlcID: resMsg.HtlcIndex,\n\t\t}\n\n\t\tif s.circuits.LookupOpenCircuit(outKey) == nil {\n\t\t\t// The open circuit doesn't exist.\n\t\t\terr := s.resMsgStore.deleteResolutionMsg(&outKey)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tcontinue\n\t\t}\n\n\t\t// The circuit is still open, so we can assume that the link or\n\t\t// switch (if we are the source) hasn't cleaned it up yet.\n\t\tresPkt := &htlcPacket{\n\t\t\toutgoingChanID: resMsg.SourceChan,\n\t\t\toutgoingHTLCID: resMsg.HtlcIndex,\n\t\t\tisResolution:   true,\n\t\t}\n\n\t\tif resMsg.Failure != nil {\n\t\t\tresPkt.htlc = &lnwire.UpdateFailHTLC{}\n\t\t} else {\n\t\t\tresPkt.htlc = &lnwire.UpdateFulfillHTLC{\n\t\t\t\tPaymentPreimage: *resMsg.PreImage,\n\t\t\t}\n\t\t}\n\n\t\tswitchPackets = append(switchPackets, resPkt)\n\t}\n\n\t// We'll now dispatch the set of resolution messages to the proper\n\t// destination. An error is only encountered here if the switch is\n\t// shutting down.\n\tif err := s.ForwardPackets(nil, switchPackets...); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// reforwardResponses for every known, non-pending channel, loads all associated\n// forwarding packages and reforwards any Settle or Fail HTLCs found. This is\n// used to resurrect the switch's mailboxes after a restart. This also runs for\n// waiting close channels since there may be settles or fails that need to be\n// reforwarded before they completely close.",
      "length": 1681,
      "tokens": 246,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) reforwardResponses() error {",
      "content": "func (s *Switch) reforwardResponses() error {\n\topenChannels, err := s.cfg.FetchAllChannels()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, openChannel := range openChannels {\n\t\tshortChanID := openChannel.ShortChanID()\n\n\t\t// Locally-initiated payments never need reforwarding.\n\t\tif shortChanID == hop.Source {\n\t\t\tcontinue\n\t\t}\n\n\t\t// If the channel is pending, it should have no forwarding\n\t\t// packages, and nothing to reforward.\n\t\tif openChannel.IsPending {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Channels in open or waiting-close may still have responses in\n\t\t// their forwarding packages. We will continue to reattempt\n\t\t// forwarding on startup until the channel is fully-closed.\n\t\t//\n\t\t// Load this channel's forwarding packages, and deliver them to\n\t\t// the switch.\n\t\tfwdPkgs, err := s.loadChannelFwdPkgs(shortChanID)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"unable to load forwarding \"+\n\t\t\t\t\"packages for %v: %v\", shortChanID, err)\n\t\t\treturn err\n\t\t}\n\n\t\ts.reforwardSettleFails(fwdPkgs)\n\t}\n\n\treturn nil\n}\n\n// loadChannelFwdPkgs loads all forwarding packages owned by the `source` short\n// channel identifier.",
      "length": 997,
      "tokens": 142,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) loadChannelFwdPkgs(source lnwire.ShortChannelID) ([]*channeldb.FwdPkg, error) {",
      "content": "func (s *Switch) loadChannelFwdPkgs(source lnwire.ShortChannelID) ([]*channeldb.FwdPkg, error) {\n\n\tvar fwdPkgs []*channeldb.FwdPkg\n\tif err := kvdb.View(s.cfg.DB, func(tx kvdb.RTx) error {\n\t\tvar err error\n\t\tfwdPkgs, err = s.cfg.SwitchPackager.LoadChannelFwdPkgs(\n\t\t\ttx, source,\n\t\t)\n\t\treturn err\n\t}, func() {\n\t\tfwdPkgs = nil\n\t}); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn fwdPkgs, nil\n}\n\n// reforwardSettleFails parses the Settle and Fail HTLCs from the list of\n// forwarding packages, and reforwards those that have not been acknowledged.\n// This is intended to occur on startup, in order to recover the switch's\n// mailboxes, and to ensure that responses can be propagated in case the\n// outgoing link never comes back online.\n//\n// NOTE: This should mimic the behavior processRemoteSettleFails.",
      "length": 676,
      "tokens": 108,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) reforwardSettleFails(fwdPkgs []*channeldb.FwdPkg) {",
      "content": "func (s *Switch) reforwardSettleFails(fwdPkgs []*channeldb.FwdPkg) {\n\tfor _, fwdPkg := range fwdPkgs {\n\t\tsettleFails, err := lnwallet.PayDescsFromRemoteLogUpdates(\n\t\t\tfwdPkg.Source, fwdPkg.Height, fwdPkg.SettleFails,\n\t\t)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Unable to process remote log updates: %v\",\n\t\t\t\terr)\n\t\t\tcontinue\n\t\t}\n\n\t\tswitchPackets := make([]*htlcPacket, 0, len(settleFails))\n\t\tfor i, pd := range settleFails {\n\n\t\t\t// Skip any settles or fails that have already been\n\t\t\t// acknowledged by the incoming link that originated the\n\t\t\t// forwarded Add.\n\t\t\tif fwdPkg.SettleFailFilter.Contains(uint16(i)) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tswitch pd.EntryType {\n\n\t\t\t// A settle for an HTLC we previously forwarded HTLC has\n\t\t\t// been received. So we'll forward the HTLC to the\n\t\t\t// switch which will handle propagating the settle to\n\t\t\t// the prior hop.\n\t\t\tcase lnwallet.Settle:\n\t\t\t\tsettlePacket := &htlcPacket{\n\t\t\t\t\toutgoingChanID: fwdPkg.Source,\n\t\t\t\t\toutgoingHTLCID: pd.ParentIndex,\n\t\t\t\t\tdestRef:        pd.DestRef,\n\t\t\t\t\thtlc: &lnwire.UpdateFulfillHTLC{\n\t\t\t\t\t\tPaymentPreimage: pd.RPreimage,\n\t\t\t\t\t},\n\t\t\t\t}\n\n\t\t\t\t// Add the packet to the batch to be forwarded, and\n\t\t\t\t// notify the overflow queue that a spare spot has been\n\t\t\t\t// freed up within the commitment state.\n\t\t\t\tswitchPackets = append(switchPackets, settlePacket)\n\n\t\t\t// A failureCode message for a previously forwarded HTLC has been\n\t\t\t// received. As a result a new slot will be freed up in our\n\t\t\t// commitment state, so we'll forward this to the switch so the\n\t\t\t// backwards undo can continue.\n\t\t\tcase lnwallet.Fail:\n\t\t\t\t// Fetch the reason the HTLC was canceled so\n\t\t\t\t// we can continue to propagate it. This\n\t\t\t\t// failure originated from another node, so\n\t\t\t\t// the linkFailure field is not set on this\n\t\t\t\t// packet.\n\t\t\t\tfailPacket := &htlcPacket{\n\t\t\t\t\toutgoingChanID: fwdPkg.Source,\n\t\t\t\t\toutgoingHTLCID: pd.ParentIndex,\n\t\t\t\t\tdestRef:        pd.DestRef,\n\t\t\t\t\thtlc: &lnwire.UpdateFailHTLC{\n\t\t\t\t\t\tReason: lnwire.OpaqueReason(pd.FailReason),\n\t\t\t\t\t},\n\t\t\t\t}\n\n\t\t\t\t// Add the packet to the batch to be forwarded, and\n\t\t\t\t// notify the overflow queue that a spare spot has been\n\t\t\t\t// freed up within the commitment state.\n\t\t\t\tswitchPackets = append(switchPackets, failPacket)\n\t\t\t}\n\t\t}\n\n\t\t// Since this send isn't tied to a specific link, we pass a nil\n\t\t// link quit channel, meaning the send will fail only if the\n\t\t// switch receives a shutdown request.\n\t\tif err := s.ForwardPackets(nil, switchPackets...); err != nil {\n\t\t\tlog.Errorf(\"Unhandled error while reforwarding packets \"+\n\t\t\t\t\"settle/fail over htlcswitch: %v\", err)\n\t\t}\n\t}\n}\n\n// Stop gracefully stops all active helper goroutines, then waits until they've\n// exited.",
      "length": 2534,
      "tokens": 354,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) Stop() error {",
      "content": "func (s *Switch) Stop() error {\n\tif !atomic.CompareAndSwapInt32(&s.shutdown, 0, 1) {\n\t\tlog.Warn(\"Htlc Switch already stopped\")\n\t\treturn errors.New(\"htlc switch already shutdown\")\n\t}\n\n\tlog.Info(\"HTLC Switch shutting down\")\n\n\tclose(s.quit)\n\n\ts.wg.Wait()\n\n\t// Wait until all active goroutines have finished exiting before\n\t// stopping the mailboxes, otherwise the mailbox map could still be\n\t// accessed and modified.\n\ts.mailOrchestrator.Stop()\n\n\treturn nil\n}\n\n// CreateAndAddLink will create a link and then add it to the internal maps\n// when given a ChannelLinkConfig and LightningChannel.",
      "length": 537,
      "tokens": 71,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) CreateAndAddLink(linkCfg ChannelLinkConfig,",
      "content": "func (s *Switch) CreateAndAddLink(linkCfg ChannelLinkConfig,\n\tlnChan *lnwallet.LightningChannel) error {\n\n\tlink := NewChannelLink(linkCfg, lnChan)\n\treturn s.AddLink(link)\n}\n\n// AddLink is used to initiate the handling of the add link command. The\n// request will be propagated and handled in the main goroutine.",
      "length": 243,
      "tokens": 36,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) AddLink(link ChannelLink) error {",
      "content": "func (s *Switch) AddLink(link ChannelLink) error {\n\ts.indexMtx.Lock()\n\tdefer s.indexMtx.Unlock()\n\n\tchanID := link.ChanID()\n\n\t// First, ensure that this link is not already active in the switch.\n\t_, err := s.getLink(chanID)\n\tif err == nil {\n\t\treturn fmt.Errorf(\"unable to add ChannelLink(%v), already \"+\n\t\t\t\"active\", chanID)\n\t}\n\n\t// Get and attach the mailbox for this link, which buffers packets in\n\t// case there packets that we tried to deliver while this link was\n\t// offline.\n\tshortChanID := link.ShortChanID()\n\tmailbox := s.mailOrchestrator.GetOrCreateMailBox(chanID, shortChanID)\n\tlink.AttachMailBox(mailbox)\n\n\t// Attach the Switch's failAliasUpdate function to the link.\n\tlink.attachFailAliasUpdate(s.failAliasUpdate)\n\n\tif err := link.Start(); err != nil {\n\t\tlog.Errorf(\"AddLink failed to start link with chanID=%v: %v\",\n\t\t\tchanID, err)\n\t\ts.removeLink(chanID)\n\t\treturn err\n\t}\n\n\tif shortChanID == hop.Source {\n\t\tlog.Infof(\"Adding pending link chan_id=%v, short_chan_id=%v\",\n\t\t\tchanID, shortChanID)\n\n\t\ts.pendingLinkIndex[chanID] = link\n\t} else {\n\t\tlog.Infof(\"Adding live link chan_id=%v, short_chan_id=%v\",\n\t\t\tchanID, shortChanID)\n\n\t\ts.addLiveLink(link)\n\t\ts.mailOrchestrator.BindLiveShortChanID(\n\t\t\tmailbox, chanID, shortChanID,\n\t\t)\n\t}\n\n\treturn nil\n}\n\n// addLiveLink adds a link to all associated forwarding index, this makes it a\n// candidate for forwarding HTLCs.",
      "length": 1271,
      "tokens": 160,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) addLiveLink(link ChannelLink) {",
      "content": "func (s *Switch) addLiveLink(link ChannelLink) {\n\tlinkScid := link.ShortChanID()\n\n\t// We'll add the link to the linkIndex which lets us quickly\n\t// look up a channel when we need to close or register it, and\n\t// the forwarding index which'll be used when forwarding HTLC's\n\t// in the multi-hop setting.\n\ts.linkIndex[link.ChanID()] = link\n\ts.forwardingIndex[linkScid] = link\n\n\t// Next we'll add the link to the interface index so we can\n\t// quickly look up all the channels for a particular node.\n\tpeerPub := link.Peer().PubKey()\n\tif _, ok := s.interfaceIndex[peerPub]; !ok {\n\t\ts.interfaceIndex[peerPub] = make(map[lnwire.ChannelID]ChannelLink)\n\t}\n\ts.interfaceIndex[peerPub][link.ChanID()] = link\n\n\taliases := link.getAliases()\n\tif link.isZeroConf() {\n\t\tif link.zeroConfConfirmed() {\n\t\t\t// Since the zero-conf channel has confirmed, we can\n\t\t\t// populate the aliasToReal mapping.\n\t\t\tconfirmedScid := link.confirmedScid()\n\n\t\t\tfor _, alias := range aliases {\n\t\t\t\ts.aliasToReal[alias] = confirmedScid\n\t\t\t}\n\n\t\t\t// Add the confirmed SCID as a key in the baseIndex.\n\t\t\ts.baseIndex[confirmedScid] = linkScid\n\t\t}\n\n\t\t// Now we populate the baseIndex which will be used to fetch\n\t\t// the link given any of the channel's alias SCIDs or the real\n\t\t// SCID. The link's SCID is an alias, so we don't need to\n\t\t// special-case it like the option-scid-alias feature-bit case\n\t\t// further down.\n\t\tfor _, alias := range aliases {\n\t\t\ts.baseIndex[alias] = linkScid\n\t\t}\n\t} else if link.negotiatedAliasFeature() {\n\t\t// The link's SCID is the confirmed SCID for non-zero-conf\n\t\t// option-scid-alias feature bit channels.\n\t\tfor _, alias := range aliases {\n\t\t\ts.aliasToReal[alias] = linkScid\n\t\t\ts.baseIndex[alias] = linkScid\n\t\t}\n\n\t\t// Since the link's SCID is confirmed, it was not included in\n\t\t// the baseIndex above as a key. Add it now.\n\t\ts.baseIndex[linkScid] = linkScid\n\t}\n}\n\n// GetLink is used to initiate the handling of the get link command. The\n// request will be propagated/handled to/in the main goroutine.",
      "length": 1888,
      "tokens": 287,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) GetLink(chanID lnwire.ChannelID) (ChannelUpdateHandler,",
      "content": "func (s *Switch) GetLink(chanID lnwire.ChannelID) (ChannelUpdateHandler,\n\terror) {\n\n\ts.indexMtx.RLock()\n\tdefer s.indexMtx.RUnlock()\n\n\treturn s.getLink(chanID)\n}\n\n// getLink returns the link stored in either the pending index or the live\n// lindex.",
      "length": 165,
      "tokens": 24,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) getLink(chanID lnwire.ChannelID) (ChannelLink, error) {",
      "content": "func (s *Switch) getLink(chanID lnwire.ChannelID) (ChannelLink, error) {\n\tlink, ok := s.linkIndex[chanID]\n\tif !ok {\n\t\tlink, ok = s.pendingLinkIndex[chanID]\n\t\tif !ok {\n\t\t\treturn nil, ErrChannelLinkNotFound\n\t\t}\n\t}\n\n\treturn link, nil\n}\n\n// GetLinkByShortID attempts to return the link which possesses the target short\n// channel ID.",
      "length": 244,
      "tokens": 38,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) GetLinkByShortID(chanID lnwire.ShortChannelID) (ChannelLink,",
      "content": "func (s *Switch) GetLinkByShortID(chanID lnwire.ShortChannelID) (ChannelLink,\n\terror) {\n\n\ts.indexMtx.RLock()\n\tdefer s.indexMtx.RUnlock()\n\n\tlink, err := s.getLinkByShortID(chanID)\n\tif err != nil {\n\t\t// If we failed to find the link under the passed-in SCID, we\n\t\t// consult the Switch's baseIndex map to see if the confirmed\n\t\t// SCID was used for a zero-conf channel.\n\t\taliasID, ok := s.baseIndex[chanID]\n\t\tif !ok {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// An alias was found, use it to lookup if a link exists.\n\t\treturn s.getLinkByShortID(aliasID)\n\t}\n\n\treturn link, nil\n}\n\n// getLinkByShortID attempts to return the link which possesses the target\n// short channel ID.\n//\n// NOTE: This MUST be called with the indexMtx held.",
      "length": 610,
      "tokens": 103,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) getLinkByShortID(chanID lnwire.ShortChannelID) (ChannelLink, error) {",
      "content": "func (s *Switch) getLinkByShortID(chanID lnwire.ShortChannelID) (ChannelLink, error) {\n\tlink, ok := s.forwardingIndex[chanID]\n\tif !ok {\n\t\treturn nil, ErrChannelLinkNotFound\n\t}\n\n\treturn link, nil\n}\n\n// getLinkByMapping attempts to fetch the link via the htlcPacket's\n// outgoingChanID, possibly using a mapping. If it finds the link via mapping,\n// the outgoingChanID will be changed so that an error can be properly\n// attributed when looping over linkErrs in handlePacketForward.\n//\n// * If the outgoingChanID is an alias, we'll fetch the link regardless if it's\n// public or not.\n//\n// * If the outgoingChanID is a confirmed SCID, we'll need to do more checks.\n//   - If there is no entry found in baseIndex, fetch the link. This channel\n//     did not have the option-scid-alias feature negotiated (which includes\n//     zero-conf and option-scid-alias channel-types).\n//   - If there is an entry found, fetch the link from forwardingIndex and\n//     fail if this is a private link.\n//\n// NOTE: This MUST be called with the indexMtx read lock held.",
      "length": 941,
      "tokens": 160,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) getLinkByMapping(pkt *htlcPacket) (ChannelLink, error) {",
      "content": "func (s *Switch) getLinkByMapping(pkt *htlcPacket) (ChannelLink, error) {\n\t// Determine if this ShortChannelID is an alias or a confirmed SCID.\n\tchanID := pkt.outgoingChanID\n\taliasID := s.cfg.IsAlias(chanID)\n\n\t// Set the originalOutgoingChanID so the proper channel_update can be\n\t// sent back if the option-scid-alias feature bit was negotiated.\n\tpkt.originalOutgoingChanID = chanID\n\n\tif aliasID {\n\t\t// Since outgoingChanID is an alias, we'll fetch the link via\n\t\t// baseIndex.\n\t\tbaseScid, ok := s.baseIndex[chanID]\n\t\tif !ok {\n\t\t\t// No mapping exists, bail.\n\t\t\treturn nil, ErrChannelLinkNotFound\n\t\t}\n\n\t\t// A mapping exists, so use baseScid to find the link in the\n\t\t// forwardingIndex.\n\t\tlink, ok := s.forwardingIndex[baseScid]\n\t\tif !ok {\n\t\t\t// Link not found, bail.\n\t\t\treturn nil, ErrChannelLinkNotFound\n\t\t}\n\n\t\t// Change the packet's outgoingChanID field so that errors are\n\t\t// properly attributed.\n\t\tpkt.outgoingChanID = baseScid\n\n\t\t// Return the link without checking if it's private or not.\n\t\treturn link, nil\n\t}\n\n\t// The outgoingChanID is a confirmed SCID. Attempt to fetch the base\n\t// SCID from baseIndex.\n\tbaseScid, ok := s.baseIndex[chanID]\n\tif !ok {\n\t\t// outgoingChanID is not a key in base index meaning this\n\t\t// channel did not have the option-scid-alias feature bit\n\t\t// negotiated. We'll fetch the link and return it.\n\t\tlink, ok := s.forwardingIndex[chanID]\n\t\tif !ok {\n\t\t\t// The link wasn't found, bail out.\n\t\t\treturn nil, ErrChannelLinkNotFound\n\t\t}\n\n\t\treturn link, nil\n\t}\n\n\t// Fetch the link whose internal SCID is baseScid.\n\tlink, ok := s.forwardingIndex[baseScid]\n\tif !ok {\n\t\t// Link wasn't found, bail out.\n\t\treturn nil, ErrChannelLinkNotFound\n\t}\n\n\t// If the link is unadvertised, we fail since the real SCID was used to\n\t// forward over it and this is a channel where the option-scid-alias\n\t// feature bit was negotiated.\n\tif link.IsUnadvertised() {\n\t\treturn nil, ErrChannelLinkNotFound\n\t}\n\n\t// The link is public so the confirmed SCID can be used to forward over\n\t// it. We'll also replace pkt's outgoingChanID field so errors can\n\t// properly be attributed in the calling function.\n\tpkt.outgoingChanID = baseScid\n\treturn link, nil\n}\n\n// HasActiveLink returns true if the given channel ID has a link in the link\n// index AND the link is eligible to forward.",
      "length": 2135,
      "tokens": 339,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) HasActiveLink(chanID lnwire.ChannelID) bool {",
      "content": "func (s *Switch) HasActiveLink(chanID lnwire.ChannelID) bool {\n\ts.indexMtx.RLock()\n\tdefer s.indexMtx.RUnlock()\n\n\tif link, ok := s.linkIndex[chanID]; ok {\n\t\treturn link.EligibleToForward()\n\t}\n\n\treturn false\n}\n\n// RemoveLink purges the switch of any link associated with chanID. If a pending\n// or active link is not found, this method does nothing. Otherwise, the method\n// returns after the link has been completely shutdown.",
      "length": 350,
      "tokens": 53,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) RemoveLink(chanID lnwire.ChannelID) {",
      "content": "func (s *Switch) RemoveLink(chanID lnwire.ChannelID) {\n\ts.indexMtx.Lock()\n\tlink, err := s.getLink(chanID)\n\tif err != nil {\n\t\t// If err is non-nil, this means that link is also nil. The\n\t\t// link variable cannot be nil without err being non-nil.\n\t\ts.indexMtx.Unlock()\n\t\tlog.Tracef(\"Unable to remove link for ChannelID(%v): %v\",\n\t\t\tchanID, err)\n\t\treturn\n\t}\n\n\t// Check if the link is already stopping and grab the stop chan if it\n\t// is.\n\tstopChan, ok := s.linkStopIndex[chanID]\n\tif !ok {\n\t\t// If the link is non-nil, it is not currently stopping, so\n\t\t// we'll add a stop chan to the linkStopIndex.\n\t\tstopChan = make(chan struct{})\n\t\ts.linkStopIndex[chanID] = stopChan\n\t}\n\ts.indexMtx.Unlock()\n\n\tif ok {\n\t\t// If the stop chan exists, we will wait for it to be closed.\n\t\t// Once it is closed, we will exit.\n\t\tselect {\n\t\tcase <-stopChan:\n\t\t\treturn\n\t\tcase <-s.quit:\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Stop the link before removing it from the maps.\n\tlink.Stop()\n\n\ts.indexMtx.Lock()\n\t_ = s.removeLink(chanID)\n\n\t// Close stopChan and remove this link from the linkStopIndex.\n\t// Deleting from the index and removing from the link must be done\n\t// in the same block while the mutex is held.\n\tclose(stopChan)\n\tdelete(s.linkStopIndex, chanID)\n\ts.indexMtx.Unlock()\n}\n\n// removeLink is used to remove and stop the channel link.\n//\n// NOTE: This MUST be called with the indexMtx held.",
      "length": 1253,
      "tokens": 209,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) removeLink(chanID lnwire.ChannelID) ChannelLink {",
      "content": "func (s *Switch) removeLink(chanID lnwire.ChannelID) ChannelLink {\n\tlog.Infof(\"Removing channel link with ChannelID(%v)\", chanID)\n\n\tlink, err := s.getLink(chanID)\n\tif err != nil {\n\t\treturn nil\n\t}\n\n\t// Remove the channel from live link indexes.\n\tdelete(s.pendingLinkIndex, link.ChanID())\n\tdelete(s.linkIndex, link.ChanID())\n\tdelete(s.forwardingIndex, link.ShortChanID())\n\n\t// If the link has been added to the peer index, then we'll move to\n\t// delete the entry within the index.\n\tpeerPub := link.Peer().PubKey()\n\tif peerIndex, ok := s.interfaceIndex[peerPub]; ok {\n\t\tdelete(peerIndex, link.ChanID())\n\n\t\t// If after deletion, there are no longer any links, then we'll\n\t\t// remove the interface map all together.\n\t\tif len(peerIndex) == 0 {\n\t\t\tdelete(s.interfaceIndex, peerPub)\n\t\t}\n\t}\n\n\treturn link\n}\n\n// UpdateShortChanID locates the link with the passed-in chanID and updates the\n// underlying channel state. This is only used in zero-conf channels to allow\n// the confirmed SCID to be updated.",
      "length": 896,
      "tokens": 129,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) UpdateShortChanID(chanID lnwire.ChannelID) error {",
      "content": "func (s *Switch) UpdateShortChanID(chanID lnwire.ChannelID) error {\n\ts.indexMtx.Lock()\n\tdefer s.indexMtx.Unlock()\n\n\t// Locate the target link in the link index. If no such link exists,\n\t// then we will ignore the request.\n\tlink, ok := s.linkIndex[chanID]\n\tif !ok {\n\t\treturn fmt.Errorf(\"link %v not found\", chanID)\n\t}\n\n\t// Try to update the link's underlying channel state, returning early\n\t// if this update failed.\n\t_, err := link.UpdateShortChanID()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Since the zero-conf channel is confirmed, we should populate the\n\t// aliasToReal map and update the baseIndex.\n\taliases := link.getAliases()\n\n\tconfirmedScid := link.confirmedScid()\n\n\tfor _, alias := range aliases {\n\t\ts.aliasToReal[alias] = confirmedScid\n\t}\n\n\ts.baseIndex[confirmedScid] = link.ShortChanID()\n\n\treturn nil\n}\n\n// GetLinksByInterface fetches all the links connected to a particular node\n// identified by the serialized compressed form of its public key.",
      "length": 854,
      "tokens": 129,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) GetLinksByInterface(hop [33]byte) ([]ChannelUpdateHandler,",
      "content": "func (s *Switch) GetLinksByInterface(hop [33]byte) ([]ChannelUpdateHandler,\n\terror) {\n\n\ts.indexMtx.RLock()\n\tdefer s.indexMtx.RUnlock()\n\n\tvar handlers []ChannelUpdateHandler\n\n\tlinks, err := s.getLinks(hop)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Range over the returned []ChannelLink to convert them into\n\t// []ChannelUpdateHandler.\n\tfor _, link := range links {\n\t\thandlers = append(handlers, link)\n\t}\n\n\treturn handlers, nil\n}\n\n// getLinks is function which returns the channel links of the peer by hop\n// destination id.\n//\n// NOTE: This MUST be called with the indexMtx held.",
      "length": 479,
      "tokens": 77,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) getLinks(destination [33]byte) ([]ChannelLink, error) {",
      "content": "func (s *Switch) getLinks(destination [33]byte) ([]ChannelLink, error) {\n\tlinks, ok := s.interfaceIndex[destination]\n\tif !ok {\n\t\treturn nil, ErrNoLinksFound\n\t}\n\n\tchannelLinks := make([]ChannelLink, 0, len(links))\n\tfor _, link := range links {\n\t\tchannelLinks = append(channelLinks, link)\n\t}\n\n\treturn channelLinks, nil\n}\n\n// CircuitModifier returns a reference to subset of the interfaces provided by\n// the circuit map, to allow links to open and close circuits.",
      "length": 374,
      "tokens": 56,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) CircuitModifier() CircuitModifier {",
      "content": "func (s *Switch) CircuitModifier() CircuitModifier {\n\treturn s.circuits\n}\n\n// CircuitLookup returns a reference to subset of the interfaces provided by the\n// circuit map, to allow looking up circuits.",
      "length": 144,
      "tokens": 24,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) CircuitLookup() CircuitLookup {",
      "content": "func (s *Switch) CircuitLookup() CircuitLookup {\n\treturn s.circuits\n}\n\n// commitCircuits persistently adds a circuit to the switch's circuit map.",
      "length": 93,
      "tokens": 14,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) commitCircuits(circuits ...*PaymentCircuit) (",
      "content": "func (s *Switch) commitCircuits(circuits ...*PaymentCircuit) (\n\t*CircuitFwdActions, error) {\n\n\treturn s.circuits.CommitCircuits(circuits...)\n}\n\n// FlushForwardingEvents flushes out the set of pending forwarding events to\n// the persistent log. This will be used by the switch to periodically flush\n// out the set of forwarding events to disk. External callers can also use this\n// method to ensure all data is flushed to dis before querying the log.",
      "length": 378,
      "tokens": 60,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) FlushForwardingEvents() error {",
      "content": "func (s *Switch) FlushForwardingEvents() error {\n\t// First, we'll obtain a copy of the current set of pending forwarding\n\t// events.\n\ts.fwdEventMtx.Lock()\n\n\t// If we won't have any forwarding events, then we can exit early.\n\tif len(s.pendingFwdingEvents) == 0 {\n\t\ts.fwdEventMtx.Unlock()\n\t\treturn nil\n\t}\n\n\tevents := make([]channeldb.ForwardingEvent, len(s.pendingFwdingEvents))\n\tcopy(events[:], s.pendingFwdingEvents[:])\n\n\t// With the copy obtained, we can now clear out the header pointer of\n\t// the current slice. This way, we can re-use the underlying storage\n\t// allocated for the slice.\n\ts.pendingFwdingEvents = s.pendingFwdingEvents[:0]\n\ts.fwdEventMtx.Unlock()\n\n\t// Finally, we'll write out the copied events to the persistent\n\t// forwarding log.\n\treturn s.cfg.FwdingLog.AddForwardingEvents(events)\n}\n\n// BestHeight returns the best height known to the switch.",
      "length": 792,
      "tokens": 106,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) BestHeight() uint32 {",
      "content": "func (s *Switch) BestHeight() uint32 {\n\treturn atomic.LoadUint32(&s.bestHeight)\n}\n\n// evaluateDustThreshold takes in a ChannelLink, HTLC amount, and a boolean to\n// determine whether the default dust threshold has been exceeded. This\n// heuristic takes into account the trimmed-to-dust mechanism. The sum of the\n// commitment's dust with the mailbox's dust with the amount is checked against\n// the default threshold. If incoming is true, then the amount is not included\n// in the sum as it was already included in the commitment's dust. A boolean is\n// returned telling the caller whether the HTLC should be failed back.",
      "length": 573,
      "tokens": 93,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) evaluateDustThreshold(link ChannelLink,",
      "content": "func (s *Switch) evaluateDustThreshold(link ChannelLink,\n\tamount lnwire.MilliSatoshi, incoming bool) bool {\n\n\t// Retrieve the link's current commitment feerate and dustClosure.\n\tfeeRate := link.getFeeRate()\n\tisDust := link.getDustClosure()\n\n\t// Evaluate if the HTLC is dust on either sides' commitment.\n\tisLocalDust := isDust(feeRate, incoming, true, amount.ToSatoshis())\n\tisRemoteDust := isDust(feeRate, incoming, false, amount.ToSatoshis())\n\n\tif !(isLocalDust || isRemoteDust) {\n\t\t// If the HTLC is not dust on either commitment, it's fine to\n\t\t// forward.\n\t\treturn false\n\t}\n\n\t// Fetch the dust sums currently in the mailbox for this link.\n\tcid := link.ChanID()\n\tsid := link.ShortChanID()\n\tmailbox := s.mailOrchestrator.GetOrCreateMailBox(cid, sid)\n\tlocalMailDust, remoteMailDust := mailbox.DustPackets()\n\n\t// If the htlc is dust on the local commitment, we'll obtain the dust\n\t// sum for it.\n\tif isLocalDust {\n\t\tlocalSum := link.getDustSum(false)\n\t\tlocalSum += localMailDust\n\n\t\t// Optionally include the HTLC amount only for outgoing\n\t\t// HTLCs.\n\t\tif !incoming {\n\t\t\tlocalSum += amount\n\t\t}\n\n\t\t// Finally check against the defined dust threshold.\n\t\tif localSum > s.cfg.DustThreshold {\n\t\t\treturn true\n\t\t}\n\t}\n\n\t// Also check if the htlc is dust on the remote commitment, if we've\n\t// reached this point.\n\tif isRemoteDust {\n\t\tremoteSum := link.getDustSum(true)\n\t\tremoteSum += remoteMailDust\n\n\t\t// Optionally include the HTLC amount only for outgoing\n\t\t// HTLCs.\n\t\tif !incoming {\n\t\t\tremoteSum += amount\n\t\t}\n\n\t\t// Finally check against the defined dust threshold.\n\t\tif remoteSum > s.cfg.DustThreshold {\n\t\t\treturn true\n\t\t}\n\t}\n\n\t// If we reached this point, this HTLC is fine to forward.\n\treturn false\n}\n\n// failMailboxUpdate is passed to the mailbox orchestrator which in turn passes\n// it to individual mailboxes. It allows the mailboxes to construct a\n// FailureMessage when failing back HTLC's due to expiry and may include an\n// alias in the ShortChannelID field. The outgoingScid is the SCID originally\n// used in the onion. The mailboxScid is the SCID that the mailbox and link\n// use. The mailboxScid is only used in the non-alias case, so it is always\n// the confirmed SCID.",
      "length": 2052,
      "tokens": 315,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) failMailboxUpdate(outgoingScid,",
      "content": "func (s *Switch) failMailboxUpdate(outgoingScid,\n\tmailboxScid lnwire.ShortChannelID) lnwire.FailureMessage {\n\n\t// Try to use the failAliasUpdate function in case this is a channel\n\t// that uses aliases. If it returns nil, we'll fallback to the original\n\t// pre-alias behavior.\n\tupdate := s.failAliasUpdate(outgoingScid, false)\n\tif update == nil {\n\t\t// Execute the fallback behavior.\n\t\tvar err error\n\t\tupdate, err = s.cfg.FetchLastChannelUpdate(mailboxScid)\n\t\tif err != nil {\n\t\t\treturn &lnwire.FailTemporaryNodeFailure{}\n\t\t}\n\t}\n\n\treturn lnwire.NewTemporaryChannelFailure(update)\n}\n\n// failAliasUpdate prepares a ChannelUpdate for a failed incoming or outgoing\n// HTLC on a channel where the option-scid-alias feature bit was negotiated. If\n// the associated channel is not one of these, this function will return nil\n// and the caller is expected to handle this properly. In this case, a return\n// to the original non-alias behavior is expected.",
      "length": 873,
      "tokens": 127,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) failAliasUpdate(scid lnwire.ShortChannelID,",
      "content": "func (s *Switch) failAliasUpdate(scid lnwire.ShortChannelID,\n\tincoming bool) *lnwire.ChannelUpdate {\n\n\t// This function does not defer the unlocking because of the database\n\t// lookups for ChannelUpdate.\n\ts.indexMtx.RLock()\n\n\tif s.cfg.IsAlias(scid) {\n\t\t// The alias SCID was used. In the incoming case this means\n\t\t// the channel is zero-conf as the link sets the scid. In the\n\t\t// outgoing case, the sender set the scid to use and may be\n\t\t// either the alias or the confirmed one, if it exists.\n\t\trealScid, ok := s.aliasToReal[scid]\n\t\tif !ok {\n\t\t\t// The real, confirmed SCID does not exist yet. Find\n\t\t\t// the \"base\" SCID that the link uses via the\n\t\t\t// baseIndex. If we can't find it, return nil. This\n\t\t\t// means the channel is zero-conf.\n\t\t\tbaseScid, ok := s.baseIndex[scid]\n\t\t\ts.indexMtx.RUnlock()\n\t\t\tif !ok {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tupdate, err := s.cfg.FetchLastChannelUpdate(baseScid)\n\t\t\tif err != nil {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Replace the baseScid with the passed-in alias.\n\t\t\tupdate.ShortChannelID = scid\n\t\t\tsig, err := s.cfg.SignAliasUpdate(update)\n\t\t\tif err != nil {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tupdate.Signature, err = lnwire.NewSigFromSignature(sig)\n\t\t\tif err != nil {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\treturn update\n\t\t}\n\n\t\ts.indexMtx.RUnlock()\n\n\t\t// Fetch the SCID via the confirmed SCID and replace it with\n\t\t// the alias.\n\t\tupdate, err := s.cfg.FetchLastChannelUpdate(realScid)\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\n\t\t// In the incoming case, we want to ensure that we don't leak\n\t\t// the UTXO in case the channel is private. In the outgoing\n\t\t// case, since the alias was used, we do the same thing.\n\t\tupdate.ShortChannelID = scid\n\t\tsig, err := s.cfg.SignAliasUpdate(update)\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\n\t\tupdate.Signature, err = lnwire.NewSigFromSignature(sig)\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn update\n\t}\n\n\t// If the confirmed SCID is not in baseIndex, this is not an\n\t// option-scid-alias or zero-conf channel.\n\tbaseScid, ok := s.baseIndex[scid]\n\tif !ok {\n\t\ts.indexMtx.RUnlock()\n\t\treturn nil\n\t}\n\n\t// Fetch the link so we can get an alias to use in the ShortChannelID\n\t// of the ChannelUpdate.\n\tlink, ok := s.forwardingIndex[baseScid]\n\ts.indexMtx.RUnlock()\n\tif !ok {\n\t\t// This should never happen, but if it does for some reason,\n\t\t// fallback to the old behavior.\n\t\treturn nil\n\t}\n\n\taliases := link.getAliases()\n\tif len(aliases) == 0 {\n\t\t// This should never happen, but if it does, fallback.\n\t\treturn nil\n\t}\n\n\t// Fetch the ChannelUpdate via the real, confirmed SCID.\n\tupdate, err := s.cfg.FetchLastChannelUpdate(scid)\n\tif err != nil {\n\t\treturn nil\n\t}\n\n\t// The incoming case will replace the ShortChannelID in the retrieved\n\t// ChannelUpdate with the alias to ensure no privacy leak occurs. This\n\t// would happen if a private non-zero-conf option-scid-alias\n\t// feature-bit channel leaked its UTXO here rather than supplying an\n\t// alias. In the outgoing case, the confirmed SCID was actually used\n\t// for forwarding in the onion, so no replacement is necessary as the\n\t// sender knows the scid.\n\tif incoming {\n\t\t// We will replace and sign the update with the first alias.\n\t\t// Since this happens on the incoming side, it's not actually\n\t\t// possible to know what the sender used in the onion.\n\t\tupdate.ShortChannelID = aliases[0]\n\t\tsig, err := s.cfg.SignAliasUpdate(update)\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\n\t\tupdate.Signature, err = lnwire.NewSigFromSignature(sig)\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn update\n}\n\n// AddAliasForLink instructs the Switch to update its in-memory maps to reflect\n// that a link has a new alias.",
      "length": 3381,
      "tokens": 551,
      "embedding": []
    },
    {
      "slug": "func (s *Switch) AddAliasForLink(chanID lnwire.ChannelID,",
      "content": "func (s *Switch) AddAliasForLink(chanID lnwire.ChannelID,\n\talias lnwire.ShortChannelID) error {\n\n\t// Fetch the link so that we can update the underlying channel's set of\n\t// aliases.\n\ts.indexMtx.RLock()\n\tlink, err := s.getLink(chanID)\n\ts.indexMtx.RUnlock()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// If the link is a channel where the option-scid-alias feature bit was\n\t// not negotiated, we'll return an error.\n\tif !link.negotiatedAliasFeature() {\n\t\treturn fmt.Errorf(\"attempted to update non-alias channel\")\n\t}\n\n\tlinkScid := link.ShortChanID()\n\n\t// We'll update the maps so the Switch includes this alias in its\n\t// forwarding decisions.\n\tif link.isZeroConf() {\n\t\tif link.zeroConfConfirmed() {\n\t\t\t// If the channel has confirmed on-chain, we'll\n\t\t\t// add this alias to the aliasToReal map.\n\t\t\tconfirmedScid := link.confirmedScid()\n\n\t\t\ts.aliasToReal[alias] = confirmedScid\n\t\t}\n\n\t\t// Add this alias to the baseIndex mapping.\n\t\ts.baseIndex[alias] = linkScid\n\t} else if link.negotiatedAliasFeature() {\n\t\t// The channel is confirmed, so we'll populate the aliasToReal\n\t\t// and baseIndex maps.\n\t\ts.aliasToReal[alias] = linkScid\n\t\ts.baseIndex[alias] = linkScid\n\t}\n\n\treturn nil\n}\n",
      "length": 1070,
      "tokens": 152,
      "embedding": []
    }
  ]
}