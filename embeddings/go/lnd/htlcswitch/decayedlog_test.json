{
  "filepath": "../implementations/go/lnd/htlcswitch/decayedlog_test.go",
  "package": "htlcswitch",
  "sections": [
    {
      "slug": "func startup(dbPath string, notifier bool) (sphinx.ReplayLog,",
      "content": "func startup(dbPath string, notifier bool) (sphinx.ReplayLog,\n\t*mock.ChainNotifier, *sphinx.HashPrefix, func(), error) {\n\n\tcfg := &kvdb.BoltConfig{\n\t\tDBTimeout: time.Second,\n\t}\n\tbackend, err := NewBoltBackendCreator(dbPath, \"sphinxreplay.db\")(cfg)\n\tif err != nil {\n\t\treturn nil, nil, nil, nil, fmt.Errorf(\"unable to create temporary \"+\n\t\t\t\"decayed log db: %v\", err)\n\t}\n\n\tvar log sphinx.ReplayLog\n\tvar chainNotifier *mock.ChainNotifier\n\tif notifier {\n\n\t\t// Create the MockNotifier which triggers the garbage collector\n\t\tchainNotifier = &mock.ChainNotifier{\n\t\t\tSpendChan: make(chan *chainntnfs.SpendDetail),\n\t\t\tEpochChan: make(chan *chainntnfs.BlockEpoch, 1),\n\t\t\tConfChan:  make(chan *chainntnfs.TxConfirmation),\n\t\t}\n\n\t\t// Initialize the DecayedLog object\n\t\tlog = NewDecayedLog(backend, chainNotifier)\n\t} else {\n\t\t// Initialize the DecayedLog object\n\t\tlog = NewDecayedLog(backend, nil)\n\t}\n\n\t// Open the channeldb (start the garbage collector)\n\terr = log.Start()\n\tif err != nil {\n\t\treturn nil, nil, nil, nil, err\n\t}\n\n\t// Create a HashPrefix identifier for a packet. Instead of actually\n\t// generating an ECDH secret and hashing it, simulate with random bytes.\n\t// This is used as a key to retrieve the cltv value.\n\tvar hashedSecret sphinx.HashPrefix\n\t_, err = rand.Read(hashedSecret[:])\n\tif err != nil {\n\t\treturn nil, nil, nil, nil, err\n\t}\n\n\tstop := func() {\n\t\t_ = log.Stop()\n\t\tbackend.Close()\n\t}\n\n\treturn log, chainNotifier, &hashedSecret, stop, nil\n}\n\n// TestDecayedLogGarbageCollector tests the ability of the garbage collector\n// to delete expired cltv values every time a block is received. Expired cltv\n// values are cltv values that are < current block height.",
      "length": 1548,
      "tokens": 218,
      "embedding": []
    },
    {
      "slug": "func TestDecayedLogGarbageCollector(t *testing.T) {",
      "content": "func TestDecayedLogGarbageCollector(t *testing.T) {\n\tt.Parallel()\n\n\tdbPath := t.TempDir()\n\n\td, notifier, hashedSecret, _, err := startup(dbPath, true)\n\trequire.NoError(t, err, \"Unable to start up DecayedLog\")\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, d.Stop())\n\t})\n\n\t// Store <hashedSecret, cltv> in the sharedHashBucket.\n\terr = d.Put(hashedSecret, cltv)\n\trequire.NoError(t, err, \"Unable to store in channeldb\")\n\n\t// Wait for database write (GC is in a goroutine)\n\ttime.Sleep(500 * time.Millisecond)\n\n\t// Send block notifications to garbage collector. The garbage collector\n\t// should remove the entry by block 100001.\n\n\t// Send block 100000\n\tnotifier.EpochChan <- &chainntnfs.BlockEpoch{\n\t\tHeight: 100000,\n\t}\n\n\t// Assert that hashedSecret is still in the sharedHashBucket\n\tval, err := d.Get(hashedSecret)\n\trequire.NoError(t, err, \"Get failed - received an error upon Get\")\n\n\tif val != cltv {\n\t\tt.Fatalf(\"GC incorrectly deleted CLTV\")\n\t}\n\n\t// Send block 100001 (expiry block)\n\tnotifier.EpochChan <- &chainntnfs.BlockEpoch{\n\t\tHeight: 100001,\n\t}\n\n\t// Wait for database write (GC is in a goroutine)\n\ttime.Sleep(500 * time.Millisecond)\n\n\t// Assert that hashedSecret is not in the sharedHashBucket\n\t_, err = d.Get(hashedSecret)\n\tif err == nil {\n\t\tt.Fatalf(\"CLTV was not deleted\")\n\t}\n\tif err != sphinx.ErrLogEntryNotFound {\n\t\tt.Fatalf(\"Get failed - received unexpected error upon Get: %v\", err)\n\t}\n}\n\n// TestDecayedLogPersistentGarbageCollector tests the persistence property of\n// the garbage collector. The garbage collector will be restarted immediately and\n// a block that expires the stored CLTV value will be sent to the ChainNotifier.\n// We test that this causes the <hashedSecret, CLTV> pair to be deleted even\n// on GC restarts.",
      "length": 1623,
      "tokens": 233,
      "embedding": []
    },
    {
      "slug": "func TestDecayedLogPersistentGarbageCollector(t *testing.T) {",
      "content": "func TestDecayedLogPersistentGarbageCollector(t *testing.T) {\n\tt.Parallel()\n\n\tdbPath := t.TempDir()\n\n\td, _, hashedSecret, stop, err := startup(dbPath, true)\n\trequire.NoError(t, err, \"Unable to start up DecayedLog\")\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, d.Stop())\n\t})\n\n\t// Store <hashedSecret, cltv> in the sharedHashBucket\n\tif err = d.Put(hashedSecret, cltv); err != nil {\n\t\tt.Fatalf(\"Unable to store in channeldb: %v\", err)\n\t}\n\n\t// The hash prefix should be retrievable from the decayed log.\n\t_, err = d.Get(hashedSecret)\n\tif err != nil {\n\t\tt.Fatalf(\"Get failed - received unexpected error upon Get: %v\", err)\n\t}\n\n\t// Shut down DecayedLog and the garbage collector along with it.\n\tstop()\n\n\td2, notifier2, _, _, err := startup(dbPath, true)\n\trequire.NoError(t, err, \"Unable to restart DecayedLog\")\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, d2.Stop())\n\t})\n\n\t// Check that the hash prefix still exists in the new db instance.\n\t_, err = d2.Get(hashedSecret)\n\tif err != nil {\n\t\tt.Fatalf(\"Get failed - received unexpected error upon Get: %v\", err)\n\t}\n\n\t// Send a block notification to the garbage collector that expires\n\t// the stored CLTV.\n\tnotifier2.EpochChan <- &chainntnfs.BlockEpoch{\n\t\tHeight: int32(100001),\n\t}\n\n\t// Wait for database write (GC is in a goroutine)\n\ttime.Sleep(500 * time.Millisecond)\n\n\t// Assert that hashedSecret is not in the sharedHashBucket\n\t_, err = d2.Get(hashedSecret)\n\tif err != sphinx.ErrLogEntryNotFound {\n\t\tt.Fatalf(\"Get failed - received unexpected error upon Get: %v\", err)\n\t}\n}\n\n// TestDecayedLogInsertionAndRetrieval inserts a cltv value into the\n// sharedHashBucket and then deletes it and finally asserts that we can no\n// longer retrieve it.",
      "length": 1561,
      "tokens": 232,
      "embedding": []
    },
    {
      "slug": "func TestDecayedLogInsertionAndDeletion(t *testing.T) {",
      "content": "func TestDecayedLogInsertionAndDeletion(t *testing.T) {\n\tt.Parallel()\n\n\tdbPath := t.TempDir()\n\n\td, _, hashedSecret, _, err := startup(dbPath, false)\n\trequire.NoError(t, err, \"Unable to start up DecayedLog\")\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, d.Stop())\n\t})\n\n\t// Store <hashedSecret, cltv> in the sharedHashBucket.\n\terr = d.Put(hashedSecret, cltv)\n\trequire.NoError(t, err, \"Unable to store in channeldb\")\n\n\t// Delete hashedSecret from the sharedHashBucket.\n\terr = d.Delete(hashedSecret)\n\trequire.NoError(t, err, \"Unable to delete from channeldb\")\n\n\t// Assert that hashedSecret is not in the sharedHashBucket\n\t_, err = d.Get(hashedSecret)\n\tif err == nil {\n\t\tt.Fatalf(\"CLTV was not deleted\")\n\t}\n\tif err != sphinx.ErrLogEntryNotFound {\n\t\tt.Fatalf(\"Get failed - received unexpected error upon Get: %v\", err)\n\t}\n}\n\n// TestDecayedLogStartAndStop tests for persistence. The DecayedLog is started,\n// a cltv value is stored in the sharedHashBucket, and then it the DecayedLog\n// is stopped. The DecayedLog is then started up again and we test that the\n// cltv value is indeed still stored in the sharedHashBucket. We then delete\n// the cltv value and check that it persists upon startup.",
      "length": 1095,
      "tokens": 160,
      "embedding": []
    },
    {
      "slug": "func TestDecayedLogStartAndStop(t *testing.T) {",
      "content": "func TestDecayedLogStartAndStop(t *testing.T) {\n\tt.Parallel()\n\n\tdbPath := t.TempDir()\n\n\td, _, hashedSecret, stop, err := startup(dbPath, false)\n\trequire.NoError(t, err, \"Unable to start up DecayedLog\")\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, d.Stop())\n\t})\n\n\t// Store <hashedSecret, cltv> in the sharedHashBucket.\n\terr = d.Put(hashedSecret, cltv)\n\trequire.NoError(t, err, \"Unable to store in channeldb\")\n\n\t// Shutdown the DecayedLog's channeldb\n\tstop()\n\n\td2, _, hashedSecret2, stop, err := startup(dbPath, false)\n\trequire.NoError(t, err, \"Unable to restart DecayedLog\")\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, d2.Stop())\n\t})\n\n\t// Retrieve the stored cltv value given the hashedSecret key.\n\tvalue, err := d2.Get(hashedSecret)\n\trequire.NoError(t, err, \"Unable to retrieve from channeldb\")\n\n\t// Check that the original cltv value matches the retrieved cltv\n\t// value.\n\tif cltv != value {\n\t\tt.Fatalf(\"Value retrieved doesn't match value stored\")\n\t}\n\n\t// Delete hashedSecret from sharedHashBucket\n\terr = d2.Delete(hashedSecret2)\n\trequire.NoError(t, err, \"Unable to delete from channeldb\")\n\n\t// Shutdown the DecayedLog's channeldb\n\tstop()\n\n\td3, _, hashedSecret3, _, err := startup(dbPath, false)\n\trequire.NoError(t, err, \"Unable to restart DecayedLog\")\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, d3.Stop())\n\t})\n\n\t// Assert that hashedSecret is not in the sharedHashBucket\n\t_, err = d3.Get(hashedSecret3)\n\tif err == nil {\n\t\tt.Fatalf(\"CLTV was not deleted\")\n\t}\n\tif err != sphinx.ErrLogEntryNotFound {\n\t\tt.Fatalf(\"Get failed - received unexpected error upon Get: %v\", err)\n\t}\n}\n\n// TestDecayedLogStorageAndRetrieval stores a cltv value and then retrieves it\n// via the nested sharedHashBucket and finally asserts that the original stored\n// and retrieved cltv values are equal.",
      "length": 1661,
      "tokens": 222,
      "embedding": []
    },
    {
      "slug": "func TestDecayedLogStorageAndRetrieval(t *testing.T) {",
      "content": "func TestDecayedLogStorageAndRetrieval(t *testing.T) {\n\tt.Parallel()\n\n\tdbPath := t.TempDir()\n\n\td, _, hashedSecret, _, err := startup(dbPath, false)\n\trequire.NoError(t, err, \"Unable to start up DecayedLog\")\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, d.Stop())\n\t})\n\n\t// Store <hashedSecret, cltv> in the sharedHashBucket\n\terr = d.Put(hashedSecret, cltv)\n\trequire.NoError(t, err, \"Unable to store in channeldb\")\n\n\t// Retrieve the stored cltv value given the hashedSecret key.\n\tvalue, err := d.Get(hashedSecret)\n\trequire.NoError(t, err, \"Unable to retrieve from channeldb\")\n\n\t// If the original cltv value does not match the value retrieved,\n\t// then the test failed.\n\tif cltv != value {\n\t\tt.Fatalf(\"Value retrieved doesn't match value stored\")\n\t}\n}\n",
      "length": 665,
      "tokens": 93,
      "embedding": []
    }
  ]
}