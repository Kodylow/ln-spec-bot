{
  "filepath": "../implementations/go/lnd/htlcswitch/hop/iterator.go",
  "package": "hop",
  "sections": [
    {
      "slug": "type Iterator interface {",
      "content": "type Iterator interface {\n\t// HopPayload returns the set of fields that detail exactly _how_ this\n\t// hop should forward the HTLC to the next hop.  Additionally, the\n\t// information encoded within the returned ForwardingInfo is to be used\n\t// by each hop to authenticate the information given to it by the prior\n\t// hop. The payload will also contain any additional TLV fields provided\n\t// by the sender.\n\tHopPayload() (*Payload, error)\n\n\t// EncodeNextHop encodes the onion packet destined for the next hop\n\t// into the passed io.Writer.\n\tEncodeNextHop(w io.Writer) error\n\n\t// ExtractErrorEncrypter returns the ErrorEncrypter needed for this hop,\n\t// along with a failure code to signal if the decoding was successful.\n\tExtractErrorEncrypter(ErrorEncrypterExtracter) (ErrorEncrypter,\n\t\tlnwire.FailCode)\n}\n\n// sphinxHopIterator is the Sphinx implementation of hop iterator which uses\n// onion routing to encode the payment route  in such a way so that node might\n// see only the next hop in the route..",
      "length": 955,
      "tokens": 149,
      "embedding": []
    },
    {
      "slug": "type sphinxHopIterator struct {",
      "content": "type sphinxHopIterator struct {\n\t// ogPacket is the original packet from which the processed packet is\n\t// derived.\n\togPacket *sphinx.OnionPacket\n\n\t// processedPacket is the outcome of processing an onion packet. It\n\t// includes the information required to properly forward the packet to\n\t// the next hop.\n\tprocessedPacket *sphinx.ProcessedPacket\n}\n\n// makeSphinxHopIterator converts a processed packet returned from a sphinx\n// router and converts it into an hop iterator for usage in the link.",
      "length": 452,
      "tokens": 69,
      "embedding": []
    },
    {
      "slug": "func makeSphinxHopIterator(ogPacket *sphinx.OnionPacket,",
      "content": "func makeSphinxHopIterator(ogPacket *sphinx.OnionPacket,\n\tpacket *sphinx.ProcessedPacket) *sphinxHopIterator {\n\n\treturn &sphinxHopIterator{\n\t\togPacket:        ogPacket,\n\t\tprocessedPacket: packet,\n\t}\n}\n\n// A compile time check to ensure sphinxHopIterator implements the HopIterator\n// interface.\nvar _ Iterator = (*sphinxHopIterator)(nil)\n\n// Encode encodes iterator and writes it to the writer.\n//\n// NOTE: Part of the HopIterator interface.",
      "length": 370,
      "tokens": 48,
      "embedding": []
    },
    {
      "slug": "func (r *sphinxHopIterator) EncodeNextHop(w io.Writer) error {",
      "content": "func (r *sphinxHopIterator) EncodeNextHop(w io.Writer) error {\n\treturn r.processedPacket.NextPacket.Encode(w)\n}\n\n// HopPayload returns the set of fields that detail exactly _how_ this hop\n// should forward the HTLC to the next hop.  Additionally, the information\n// encoded within the returned ForwardingInfo is to be used by each hop to\n// authenticate the information given to it by the prior hop. The payload will\n// also contain any additional TLV fields provided by the sender.\n//\n// NOTE: Part of the HopIterator interface.",
      "length": 457,
      "tokens": 75,
      "embedding": []
    },
    {
      "slug": "func (r *sphinxHopIterator) HopPayload() (*Payload, error) {",
      "content": "func (r *sphinxHopIterator) HopPayload() (*Payload, error) {\n\tswitch r.processedPacket.Payload.Type {\n\n\t// If this is the legacy payload, then we'll extract the information\n\t// directly from the pre-populated ForwardingInstructions field.\n\tcase sphinx.PayloadLegacy:\n\t\tfwdInst := r.processedPacket.ForwardingInstructions\n\t\treturn NewLegacyPayload(fwdInst), nil\n\n\t// Otherwise, if this is the TLV payload, then we'll make a new stream\n\t// to decode only what we need to make routing decisions.\n\tcase sphinx.PayloadTLV:\n\t\treturn NewPayloadFromReader(bytes.NewReader(\n\t\t\tr.processedPacket.Payload.Payload,\n\t\t))\n\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unknown sphinx payload type: %v\",\n\t\t\tr.processedPacket.Payload.Type)\n\t}\n}\n\n// ExtractErrorEncrypter decodes and returns the ErrorEncrypter for this hop,\n// along with a failure code to signal if the decoding was successful. The\n// ErrorEncrypter is used to encrypt errors back to the sender in the event that\n// a payment fails.\n//\n// NOTE: Part of the HopIterator interface.",
      "length": 933,
      "tokens": 123,
      "embedding": []
    },
    {
      "slug": "func (r *sphinxHopIterator) ExtractErrorEncrypter(",
      "content": "func (r *sphinxHopIterator) ExtractErrorEncrypter(\n\textracter ErrorEncrypterExtracter) (ErrorEncrypter, lnwire.FailCode) {\n\n\treturn extracter(r.ogPacket.EphemeralKey)\n}\n\n// OnionProcessor is responsible for keeping all sphinx dependent parts inside\n// and expose only decoding function. With such approach we give freedom for\n// subsystems which wants to decode sphinx path to not be dependable from\n// sphinx at all.\n//\n// NOTE: The reason for keeping decoder separated from hop iterator is too\n// maintain the hop iterator abstraction. Without it the structures which using\n// the hop iterator should contain sphinx router which makes their creations in\n// tests dependent from the sphinx internal parts.",
      "length": 642,
      "tokens": 96,
      "embedding": []
    },
    {
      "slug": "type OnionProcessor struct {",
      "content": "type OnionProcessor struct {\n\trouter *sphinx.Router\n}\n\n// NewOnionProcessor creates new instance of decoder.",
      "length": 76,
      "tokens": 10,
      "embedding": []
    },
    {
      "slug": "func NewOnionProcessor(router *sphinx.Router) *OnionProcessor {",
      "content": "func NewOnionProcessor(router *sphinx.Router) *OnionProcessor {\n\treturn &OnionProcessor{router}\n}\n\n// Start spins up the onion processor's sphinx router.",
      "length": 86,
      "tokens": 12,
      "embedding": []
    },
    {
      "slug": "func (p *OnionProcessor) Start() error {",
      "content": "func (p *OnionProcessor) Start() error {\n\tlog.Info(\"Onion processor starting\")\n\treturn p.router.Start()\n}\n\n// Stop shutsdown the onion processor's sphinx router.",
      "length": 116,
      "tokens": 14,
      "embedding": []
    },
    {
      "slug": "func (p *OnionProcessor) Stop() error {",
      "content": "func (p *OnionProcessor) Stop() error {\n\n\tlog.Info(\"Onion processor shutting down\")\n\n\tp.router.Stop()\n\treturn nil\n}\n\n// DecodeHopIterator attempts to decode a valid sphinx packet from the passed io.Reader\n// instance using the rHash as the associated data when checking the relevant\n// MACs during the decoding process.",
      "length": 270,
      "tokens": 40,
      "embedding": []
    },
    {
      "slug": "func (p *OnionProcessor) DecodeHopIterator(r io.Reader, rHash []byte,",
      "content": "func (p *OnionProcessor) DecodeHopIterator(r io.Reader, rHash []byte,\n\tincomingCltv uint32) (Iterator, lnwire.FailCode) {\n\n\tonionPkt := &sphinx.OnionPacket{}\n\tif err := onionPkt.Decode(r); err != nil {\n\t\tswitch err {\n\t\tcase sphinx.ErrInvalidOnionVersion:\n\t\t\treturn nil, lnwire.CodeInvalidOnionVersion\n\t\tcase sphinx.ErrInvalidOnionKey:\n\t\t\treturn nil, lnwire.CodeInvalidOnionKey\n\t\tdefault:\n\t\t\tlog.Errorf(\"unable to decode onion packet: %v\", err)\n\t\t\treturn nil, lnwire.CodeInvalidOnionKey\n\t\t}\n\t}\n\n\t// Attempt to process the Sphinx packet. We include the payment hash of\n\t// the HTLC as it's authenticated within the Sphinx packet itself as\n\t// associated data in order to thwart attempts a replay attacks. In the\n\t// case of a replay, an attacker is *forced* to use the same payment\n\t// hash twice, thereby losing their money entirely.\n\tsphinxPacket, err := p.router.ProcessOnionPacket(\n\t\tonionPkt, rHash, incomingCltv,\n\t)\n\tif err != nil {\n\t\tswitch err {\n\t\tcase sphinx.ErrInvalidOnionVersion:\n\t\t\treturn nil, lnwire.CodeInvalidOnionVersion\n\t\tcase sphinx.ErrInvalidOnionHMAC:\n\t\t\treturn nil, lnwire.CodeInvalidOnionHmac\n\t\tcase sphinx.ErrInvalidOnionKey:\n\t\t\treturn nil, lnwire.CodeInvalidOnionKey\n\t\tdefault:\n\t\t\tlog.Errorf(\"unable to process onion packet: %v\", err)\n\t\t\treturn nil, lnwire.CodeInvalidOnionKey\n\t\t}\n\t}\n\n\treturn makeSphinxHopIterator(onionPkt, sphinxPacket), lnwire.CodeNone\n}\n\n// ReconstructHopIterator attempts to decode a valid sphinx packet from the passed io.Reader\n// instance using the rHash as the associated data when checking the relevant\n// MACs during the decoding process.",
      "length": 1477,
      "tokens": 183,
      "embedding": []
    },
    {
      "slug": "func (p *OnionProcessor) ReconstructHopIterator(r io.Reader, rHash []byte) (",
      "content": "func (p *OnionProcessor) ReconstructHopIterator(r io.Reader, rHash []byte) (\n\tIterator, error) {\n\n\tonionPkt := &sphinx.OnionPacket{}\n\tif err := onionPkt.Decode(r); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Attempt to process the Sphinx packet. We include the payment hash of\n\t// the HTLC as it's authenticated within the Sphinx packet itself as\n\t// associated data in order to thwart attempts a replay attacks. In the\n\t// case of a replay, an attacker is *forced* to use the same payment\n\t// hash twice, thereby losing their money entirely.\n\tsphinxPacket, err := p.router.ReconstructOnionPacket(onionPkt, rHash)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn makeSphinxHopIterator(onionPkt, sphinxPacket), nil\n}\n\n// DecodeHopIteratorRequest encapsulates all date necessary to process an onion\n// packet, perform sphinx replay detection, and schedule the entry for garbage\n// collection.",
      "length": 784,
      "tokens": 121,
      "embedding": []
    },
    {
      "slug": "type DecodeHopIteratorRequest struct {",
      "content": "type DecodeHopIteratorRequest struct {\n\tOnionReader  io.Reader\n\tRHash        []byte\n\tIncomingCltv uint32\n}\n\n// DecodeHopIteratorResponse encapsulates the outcome of a batched sphinx onion\n// processing.",
      "length": 157,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "type DecodeHopIteratorResponse struct {",
      "content": "type DecodeHopIteratorResponse struct {\n\tHopIterator Iterator\n\tFailCode    lnwire.FailCode\n}\n\n// Result returns the (HopIterator, lnwire.FailCode) tuple, which should\n// correspond to the index of a particular DecodeHopIteratorRequest.\n//\n// NOTE: The HopIterator should be considered invalid if the fail code is\n// anything but lnwire.CodeNone.",
      "length": 297,
      "tokens": 41,
      "embedding": []
    },
    {
      "slug": "func (r *DecodeHopIteratorResponse) Result() (Iterator, lnwire.FailCode) {",
      "content": "func (r *DecodeHopIteratorResponse) Result() (Iterator, lnwire.FailCode) {\n\treturn r.HopIterator, r.FailCode\n}\n\n// DecodeHopIterators performs batched decoding and validation of incoming\n// sphinx packets. For the same `id`, this method will return the same iterators\n// and failcodes upon subsequent invocations.\n//\n// NOTE: In order for the responses to be valid, the caller must guarantee that\n// the presented readers and rhashes *NEVER* deviate across invocations for the\n// same id.",
      "length": 404,
      "tokens": 64,
      "embedding": []
    },
    {
      "slug": "func (p *OnionProcessor) DecodeHopIterators(id []byte,",
      "content": "func (p *OnionProcessor) DecodeHopIterators(id []byte,\n\treqs []DecodeHopIteratorRequest) ([]DecodeHopIteratorResponse, error) {\n\n\tvar (\n\t\tbatchSize = len(reqs)\n\t\tonionPkts = make([]sphinx.OnionPacket, batchSize)\n\t\tresps     = make([]DecodeHopIteratorResponse, batchSize)\n\t)\n\n\ttx := p.router.BeginTxn(id, batchSize)\n\n\tdecode := func(seqNum uint16, onionPkt *sphinx.OnionPacket,\n\t\treq DecodeHopIteratorRequest) lnwire.FailCode {\n\n\t\terr := onionPkt.Decode(req.OnionReader)\n\t\tswitch err {\n\t\tcase nil:\n\t\t\t// success\n\n\t\tcase sphinx.ErrInvalidOnionVersion:\n\t\t\treturn lnwire.CodeInvalidOnionVersion\n\n\t\tcase sphinx.ErrInvalidOnionKey:\n\t\t\treturn lnwire.CodeInvalidOnionKey\n\n\t\tdefault:\n\t\t\tlog.Errorf(\"unable to decode onion packet: %v\", err)\n\t\t\treturn lnwire.CodeInvalidOnionKey\n\t\t}\n\n\t\terr = tx.ProcessOnionPacket(\n\t\t\tseqNum, onionPkt, req.RHash, req.IncomingCltv,\n\t\t)\n\t\tswitch err {\n\t\tcase nil:\n\t\t\t// success\n\t\t\treturn lnwire.CodeNone\n\n\t\tcase sphinx.ErrInvalidOnionVersion:\n\t\t\treturn lnwire.CodeInvalidOnionVersion\n\n\t\tcase sphinx.ErrInvalidOnionHMAC:\n\t\t\treturn lnwire.CodeInvalidOnionHmac\n\n\t\tcase sphinx.ErrInvalidOnionKey:\n\t\t\treturn lnwire.CodeInvalidOnionKey\n\n\t\tdefault:\n\t\t\tlog.Errorf(\"unable to process onion packet: %v\", err)\n\t\t\treturn lnwire.CodeInvalidOnionKey\n\t\t}\n\t}\n\n\t// Execute cpu-heavy onion decoding in parallel.\n\tvar wg sync.WaitGroup\n\tfor i := range reqs {\n\t\twg.Add(1)\n\t\tgo func(seqNum uint16) {\n\t\t\tdefer wg.Done()\n\n\t\t\tonionPkt := &onionPkts[seqNum]\n\n\t\t\tresps[seqNum].FailCode = decode(\n\t\t\t\tseqNum, onionPkt, reqs[seqNum],\n\t\t\t)\n\t\t}(uint16(i))\n\t}\n\twg.Wait()\n\n\t// With that batch created, we will now attempt to write the shared\n\t// secrets to disk. This operation will returns the set of indices that\n\t// were detected as replays, and the computed sphinx packets for all\n\t// indices that did not fail the above loop. Only indices that are not\n\t// in the replay set should be considered valid, as they are\n\t// opportunistically computed.\n\tpackets, replays, err := tx.Commit()\n\tif err != nil {\n\t\tlog.Errorf(\"unable to process onion packet batch %x: %v\",\n\t\t\tid, err)\n\n\t\t// If we failed to commit the batch to the secret share log, we\n\t\t// will mark all not-yet-failed channels with a temporary\n\t\t// channel failure and exit since we cannot proceed.\n\t\tfor i := range resps {\n\t\t\tresp := &resps[i]\n\n\t\t\t// Skip any indexes that already failed onion decoding.\n\t\t\tif resp.FailCode != lnwire.CodeNone {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tlog.Errorf(\"unable to process onion packet %x-%v\",\n\t\t\t\tid, i)\n\t\t\tresp.FailCode = lnwire.CodeTemporaryChannelFailure\n\t\t}\n\n\t\t// TODO(conner): return real errors to caller so link can fail?\n\t\treturn resps, err\n\t}\n\n\t// Otherwise, the commit was successful. Now we will post process any\n\t// remaining packets, additionally failing any that were included in the\n\t// replay set.\n\tfor i := range resps {\n\t\tresp := &resps[i]\n\n\t\t// Skip any indexes that already failed onion decoding.\n\t\tif resp.FailCode != lnwire.CodeNone {\n\t\t\tcontinue\n\t\t}\n\n\t\t// If this index is contained in the replay set, mark it with a\n\t\t// temporary channel failure error code. We infer that the\n\t\t// offending error was due to a replayed packet because this\n\t\t// index was found in the replay set.\n\t\tif replays.Contains(uint16(i)) {\n\t\t\tlog.Errorf(\"unable to process onion packet: %v\",\n\t\t\t\tsphinx.ErrReplayedPacket)\n\t\t\tresp.FailCode = lnwire.CodeTemporaryChannelFailure\n\t\t\tcontinue\n\t\t}\n\n\t\t// Finally, construct a hop iterator from our processed sphinx\n\t\t// packet, simultaneously caching the original onion packet.\n\t\tresp.HopIterator = makeSphinxHopIterator(&onionPkts[i], &packets[i])\n\t}\n\n\treturn resps, nil\n}\n\n// ExtractErrorEncrypter takes an io.Reader which should contain the onion\n// packet as original received by a forwarding node and creates an\n// ErrorEncrypter instance using the derived shared secret. In the case that en\n// error occurs, a lnwire failure code detailing the parsing failure will be\n// returned.",
      "length": 3716,
      "tokens": 496,
      "embedding": []
    },
    {
      "slug": "func (p *OnionProcessor) ExtractErrorEncrypter(ephemeralKey *btcec.PublicKey) (",
      "content": "func (p *OnionProcessor) ExtractErrorEncrypter(ephemeralKey *btcec.PublicKey) (\n\tErrorEncrypter, lnwire.FailCode) {\n\n\tonionObfuscator, err := sphinx.NewOnionErrorEncrypter(\n\t\tp.router, ephemeralKey,\n\t)\n\tif err != nil {\n\t\tswitch err {\n\t\tcase sphinx.ErrInvalidOnionVersion:\n\t\t\treturn nil, lnwire.CodeInvalidOnionVersion\n\t\tcase sphinx.ErrInvalidOnionHMAC:\n\t\t\treturn nil, lnwire.CodeInvalidOnionHmac\n\t\tcase sphinx.ErrInvalidOnionKey:\n\t\t\treturn nil, lnwire.CodeInvalidOnionKey\n\t\tdefault:\n\t\t\tlog.Errorf(\"unable to process onion packet: %v\", err)\n\t\t\treturn nil, lnwire.CodeInvalidOnionKey\n\t\t}\n\t}\n\n\treturn &SphinxErrorEncrypter{\n\t\tOnionErrorEncrypter: onionObfuscator,\n\t\tEphemeralKey:        ephemeralKey,\n\t}, lnwire.CodeNone\n}\n",
      "length": 616,
      "tokens": 55,
      "embedding": []
    }
  ]
}