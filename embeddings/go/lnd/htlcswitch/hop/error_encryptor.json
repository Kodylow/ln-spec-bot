{
  "filepath": "../implementations/go/lnd/htlcswitch/hop/error_encryptor.go",
  "package": "hop",
  "sections": [
    {
      "slug": "type EncrypterType byte",
      "content": "type EncrypterType byte\n\nconst (\n\t// EncrypterTypeNone signals that no error encyrpter is present, this\n\t// can happen if the htlc is originates in the switch.\n\tEncrypterTypeNone EncrypterType = 0\n\n\t// EncrypterTypeSphinx is used to identify a sphinx onion error\n\t// encrypter instance.\n\tEncrypterTypeSphinx = 1\n\n\t// EncrypterTypeMock is used to identify a mock obfuscator instance.\n\tEncrypterTypeMock = 2\n)\n\n// ErrorEncrypterExtracter defines a function signature that extracts an\n// ErrorEncrypter from an sphinx OnionPacket.",
      "length": 488,
      "tokens": 72,
      "embedding": []
    },
    {
      "slug": "type ErrorEncrypterExtracter func(*btcec.PublicKey) (ErrorEncrypter,",
      "content": "type ErrorEncrypterExtracter func(*btcec.PublicKey) (ErrorEncrypter,\n\tlnwire.FailCode)\n\n// ErrorEncrypter is an interface that is used to encrypt HTLC related errors\n// at the source of the error, and also at each intermediate hop all the way\n// back to the source of the payment.",
      "length": 207,
      "tokens": 38,
      "embedding": []
    },
    {
      "slug": "type ErrorEncrypter interface {",
      "content": "type ErrorEncrypter interface {\n\t// EncryptFirstHop transforms a concrete failure message into an\n\t// encrypted opaque failure reason. This method will be used at the\n\t// source that the error occurs. It differs from IntermediateEncrypt\n\t// slightly, in that it computes a proper MAC over the error.\n\tEncryptFirstHop(lnwire.FailureMessage) (lnwire.OpaqueReason, error)\n\n\t// EncryptMalformedError is similar to EncryptFirstHop (it adds the\n\t// MAC), but it accepts an opaque failure reason rather than a failure\n\t// message. This method is used when we receive an\n\t// UpdateFailMalformedHTLC from the remote peer and then need to\n\t// convert that into a proper error from only the raw bytes.\n\tEncryptMalformedError(lnwire.OpaqueReason) lnwire.OpaqueReason\n\n\t// IntermediateEncrypt wraps an already encrypted opaque reason error\n\t// in an additional layer of onion encryption. This process repeats\n\t// until the error arrives at the source of the payment.\n\tIntermediateEncrypt(lnwire.OpaqueReason) lnwire.OpaqueReason\n\n\t// Type returns an enum indicating the underlying concrete instance\n\t// backing this interface.\n\tType() EncrypterType\n\n\t// Encode serializes the encrypter's ephemeral public key to the given\n\t// io.Writer.\n\tEncode(io.Writer) error\n\n\t// Decode deserializes the encrypter' ephemeral public key from the\n\t// given io.Reader.\n\tDecode(io.Reader) error\n\n\t// Reextract rederives the encrypter using the extracter, performing an\n\t// ECDH with the sphinx router's key and the ephemeral public key.\n\t//\n\t// NOTE: This should be called shortly after Decode to properly\n\t// reinitialize the error encrypter.\n\tReextract(ErrorEncrypterExtracter) error\n}\n\n// SphinxErrorEncrypter is a concrete implementation of both the ErrorEncrypter\n// interface backed by an implementation of the Sphinx packet format. As a\n// result, all errors handled are themselves wrapped in layers of onion\n// encryption and must be treated as such accordingly.",
      "length": 1867,
      "tokens": 267,
      "embedding": []
    },
    {
      "slug": "type SphinxErrorEncrypter struct {",
      "content": "type SphinxErrorEncrypter struct {\n\t*sphinx.OnionErrorEncrypter\n\n\tEphemeralKey *btcec.PublicKey\n}\n\n// NewSphinxErrorEncrypter initializes a blank sphinx error encrypter, that\n// should be used to deserialize an encoded SphinxErrorEncrypter. Since the\n// actual encrypter is not stored in plaintext while at rest, reconstructing the\n// error encrypter requires:\n//  1. Decode: to deserialize the ephemeral public key.\n//  2. Reextract: to \"unlock\" the actual error encrypter using an active\n//     OnionProcessor.",
      "length": 466,
      "tokens": 64,
      "embedding": []
    },
    {
      "slug": "func NewSphinxErrorEncrypter() *SphinxErrorEncrypter {",
      "content": "func NewSphinxErrorEncrypter() *SphinxErrorEncrypter {\n\treturn &SphinxErrorEncrypter{\n\t\tOnionErrorEncrypter: nil,\n\t\tEphemeralKey:        &btcec.PublicKey{},\n\t}\n}\n\n// EncryptFirstHop transforms a concrete failure message into an encrypted\n// opaque failure reason. This method will be used at the source that the error\n// occurs. It differs from BackwardObfuscate slightly, in that it computes a\n// proper MAC over the error.\n//\n// NOTE: Part of the ErrorEncrypter interface.",
      "length": 408,
      "tokens": 59,
      "embedding": []
    },
    {
      "slug": "func (s *SphinxErrorEncrypter) EncryptFirstHop(",
      "content": "func (s *SphinxErrorEncrypter) EncryptFirstHop(\n\tfailure lnwire.FailureMessage) (lnwire.OpaqueReason, error) {\n\n\tvar b bytes.Buffer\n\tif err := lnwire.EncodeFailure(&b, failure, 0); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// We pass a true as the first parameter to indicate that a MAC should\n\t// be added.\n\treturn s.EncryptError(true, b.Bytes()), nil\n}\n\n// EncryptMalformedError is similar to EncryptFirstHop (it adds the MAC), but\n// it accepts an opaque failure reason rather than a failure message. This\n// method is used when we receive an UpdateFailMalformedHTLC from the remote\n// peer and then need to convert that into an proper error from only the raw\n// bytes.\n//\n// NOTE: Part of the ErrorEncrypter interface.",
      "length": 650,
      "tokens": 107,
      "embedding": []
    },
    {
      "slug": "func (s *SphinxErrorEncrypter) EncryptMalformedError(",
      "content": "func (s *SphinxErrorEncrypter) EncryptMalformedError(\n\treason lnwire.OpaqueReason) lnwire.OpaqueReason {\n\n\treturn s.EncryptError(true, reason)\n}\n\n// IntermediateEncrypt wraps an already encrypted opaque reason error in an\n// additional layer of onion encryption. This process repeats until the error\n// arrives at the source of the payment. We re-encrypt the message on the\n// backwards path to ensure that the error is indistinguishable from any other\n// error seen.\n//\n// NOTE: Part of the ErrorEncrypter interface.",
      "length": 452,
      "tokens": 69,
      "embedding": []
    },
    {
      "slug": "func (s *SphinxErrorEncrypter) IntermediateEncrypt(",
      "content": "func (s *SphinxErrorEncrypter) IntermediateEncrypt(\n\treason lnwire.OpaqueReason) lnwire.OpaqueReason {\n\n\treturn s.EncryptError(false, reason)\n}\n\n// Type returns the identifier for a sphinx error encrypter.",
      "length": 148,
      "tokens": 18,
      "embedding": []
    },
    {
      "slug": "func (s *SphinxErrorEncrypter) Type() EncrypterType {",
      "content": "func (s *SphinxErrorEncrypter) Type() EncrypterType {\n\treturn EncrypterTypeSphinx\n}\n\n// Encode serializes the error encrypter' ephemeral public key to the provided\n// io.Writer.",
      "length": 119,
      "tokens": 17,
      "embedding": []
    },
    {
      "slug": "func (s *SphinxErrorEncrypter) Encode(w io.Writer) error {",
      "content": "func (s *SphinxErrorEncrypter) Encode(w io.Writer) error {\n\tephemeral := s.EphemeralKey.SerializeCompressed()\n\t_, err := w.Write(ephemeral)\n\treturn err\n}\n\n// Decode reconstructs the error encrypter's ephemeral public key from the\n// provided io.Reader.",
      "length": 187,
      "tokens": 24,
      "embedding": []
    },
    {
      "slug": "func (s *SphinxErrorEncrypter) Decode(r io.Reader) error {",
      "content": "func (s *SphinxErrorEncrypter) Decode(r io.Reader) error {\n\tvar ephemeral [33]byte\n\tif _, err := io.ReadFull(r, ephemeral[:]); err != nil {\n\t\treturn err\n\t}\n\n\tvar err error\n\ts.EphemeralKey, err = btcec.ParsePubKey(ephemeral[:])\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Reextract rederives the error encrypter from the currently held EphemeralKey.\n// This intended to be used shortly after Decode, to fully initialize a\n// SphinxErrorEncrypter.",
      "length": 378,
      "tokens": 60,
      "embedding": []
    },
    {
      "slug": "func (s *SphinxErrorEncrypter) Reextract(",
      "content": "func (s *SphinxErrorEncrypter) Reextract(\n\textract ErrorEncrypterExtracter) error {\n\n\tobfuscator, failcode := extract(s.EphemeralKey)\n\tif failcode != lnwire.CodeNone {\n\t\t// This should never happen, since we already validated that\n\t\t// this obfuscator can be extracted when it was received in the\n\t\t// link.\n\t\treturn fmt.Errorf(\"unable to reconstruct onion \"+\n\t\t\t\"obfuscator, got failcode: %d\", failcode)\n\t}\n\n\tsphinxEncrypter, ok := obfuscator.(*SphinxErrorEncrypter)\n\tif !ok {\n\t\treturn fmt.Errorf(\"incorrect onion error extracter\")\n\t}\n\n\t// Copy the freshly extracted encrypter.\n\ts.OnionErrorEncrypter = sphinxEncrypter.OnionErrorEncrypter\n\n\treturn nil\n\n}\n\n// A compile time check to ensure SphinxErrorEncrypter implements the\n// ErrorEncrypter interface.\nvar _ ErrorEncrypter = (*SphinxErrorEncrypter)(nil)\n",
      "length": 740,
      "tokens": 92,
      "embedding": []
    }
  ]
}