{
  "filepath": "../implementations/go/lnd/htlcswitch/hop/payload.go",
  "package": "hop",
  "sections": [
    {
      "slug": "type PayloadViolation byte",
      "content": "type PayloadViolation byte\n\nconst (\n\t// OmittedViolation indicates that a type was expected to be found the\n\t// payload but was absent.\n\tOmittedViolation PayloadViolation = iota\n\n\t// IncludedViolation indicates that a type was expected to be omitted\n\t// from the payload but was present.\n\tIncludedViolation\n\n\t// RequiredViolation indicates that an unknown even type was found in\n\t// the payload that we could not process.\n\tRequiredViolation\n)\n\n// String returns a human-readable description of the violation as a verb.",
      "length": 476,
      "tokens": 75,
      "embedding": []
    },
    {
      "slug": "func (v PayloadViolation) String() string {",
      "content": "func (v PayloadViolation) String() string {\n\tswitch v {\n\tcase OmittedViolation:\n\t\treturn \"omitted\"\n\n\tcase IncludedViolation:\n\t\treturn \"included\"\n\n\tcase RequiredViolation:\n\t\treturn \"required\"\n\n\tdefault:\n\t\treturn \"unknown violation\"\n\t}\n}\n\n// ErrInvalidPayload is an error returned when a parsed onion payload either\n// included or omitted incorrect records for a particular hop type.",
      "length": 321,
      "tokens": 44,
      "embedding": []
    },
    {
      "slug": "type ErrInvalidPayload struct {",
      "content": "type ErrInvalidPayload struct {\n\t// Type the record's type that cause the violation.\n\tType tlv.Type\n\n\t// Violation is an enum indicating the type of violation detected in\n\t// processing Type.\n\tViolation PayloadViolation\n\n\t// FinalHop if true, indicates that the violation is for the final hop\n\t// in the route (identified by next hop id), otherwise the violation is\n\t// for an intermediate hop.\n\tFinalHop bool\n}\n\n// Error returns a human-readable description of the invalid payload error.",
      "length": 443,
      "tokens": 73,
      "embedding": []
    },
    {
      "slug": "func (e ErrInvalidPayload) Error() string {",
      "content": "func (e ErrInvalidPayload) Error() string {\n\thopType := \"intermediate\"\n\tif e.FinalHop {\n\t\thopType = \"final\"\n\t}\n\n\treturn fmt.Sprintf(\"onion payload for %s hop %v record with type %d\",\n\t\thopType, e.Violation, e.Type)\n}\n\n// Payload encapsulates all information delivered to a hop in an onion payload.\n// A Hop can represent either a TLV or legacy payload. The primary forwarding\n// instruction can be accessed via ForwardingInfo, and additional records can be\n// accessed by other member functions.",
      "length": 439,
      "tokens": 70,
      "embedding": []
    },
    {
      "slug": "type Payload struct {",
      "content": "type Payload struct {\n\t// FwdInfo holds the basic parameters required for HTLC forwarding, e.g.\n\t// amount, cltv, and next hop.\n\tFwdInfo ForwardingInfo\n\n\t// MPP holds the info provided in an option_mpp record when parsed from\n\t// a TLV onion payload.\n\tMPP *record.MPP\n\n\t// AMP holds the info provided in an option_amp record when parsed from\n\t// a TLV onion payload.\n\tAMP *record.AMP\n\n\t// customRecords are user-defined records in the custom type range that\n\t// were included in the payload.\n\tcustomRecords record.CustomSet\n\n\t// metadata is additional data that is sent along with the payment to\n\t// the payee.\n\tmetadata []byte\n}\n\n// NewLegacyPayload builds a Payload from the amount, cltv, and next hop\n// parameters provided by leegacy onion payloads.",
      "length": 709,
      "tokens": 116,
      "embedding": []
    },
    {
      "slug": "func NewLegacyPayload(f *sphinx.HopData) *Payload {",
      "content": "func NewLegacyPayload(f *sphinx.HopData) *Payload {\n\tnextHop := binary.BigEndian.Uint64(f.NextAddress[:])\n\n\treturn &Payload{\n\t\tFwdInfo: ForwardingInfo{\n\t\t\tNetwork:         BitcoinNetwork,\n\t\t\tNextHop:         lnwire.NewShortChanIDFromInt(nextHop),\n\t\t\tAmountToForward: lnwire.MilliSatoshi(f.ForwardAmount),\n\t\t\tOutgoingCTLV:    f.OutgoingCltv,\n\t\t},\n\t\tcustomRecords: make(record.CustomSet),\n\t}\n}\n\n// NewPayloadFromReader builds a new Hop from the passed io.Reader. The reader\n// should correspond to the bytes encapsulated in a TLV onion payload.",
      "length": 476,
      "tokens": 44,
      "embedding": []
    },
    {
      "slug": "func NewPayloadFromReader(r io.Reader) (*Payload, error) {",
      "content": "func NewPayloadFromReader(r io.Reader) (*Payload, error) {\n\tvar (\n\t\tcid      uint64\n\t\tamt      uint64\n\t\tcltv     uint32\n\t\tmpp      = &record.MPP{}\n\t\tamp      = &record.AMP{}\n\t\tmetadata []byte\n\t)\n\n\ttlvStream, err := tlv.NewStream(\n\t\trecord.NewAmtToFwdRecord(&amt),\n\t\trecord.NewLockTimeRecord(&cltv),\n\t\trecord.NewNextHopIDRecord(&cid),\n\t\tmpp.Record(),\n\t\tamp.Record(),\n\t\trecord.NewMetadataRecord(&metadata),\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Since this data is provided by a potentially malicious peer, pass it\n\t// into the P2P decoding variant.\n\tparsedTypes, err := tlvStream.DecodeWithParsedTypesP2P(r)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Validate whether the sender properly included or omitted tlv records\n\t// in accordance with BOLT 04.\n\tnextHop := lnwire.NewShortChanIDFromInt(cid)\n\terr = ValidateParsedPayloadTypes(parsedTypes, nextHop)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check for violation of the rules for mandatory fields.\n\tviolatingType := getMinRequiredViolation(parsedTypes)\n\tif violatingType != nil {\n\t\treturn nil, ErrInvalidPayload{\n\t\t\tType:      *violatingType,\n\t\t\tViolation: RequiredViolation,\n\t\t\tFinalHop:  nextHop == Exit,\n\t\t}\n\t}\n\n\t// If no MPP field was parsed, set the MPP field on the resulting\n\t// payload to nil.\n\tif _, ok := parsedTypes[record.MPPOnionType]; !ok {\n\t\tmpp = nil\n\t}\n\n\t// If no AMP field was parsed, set the MPP field on the resulting\n\t// payload to nil.\n\tif _, ok := parsedTypes[record.AMPOnionType]; !ok {\n\t\tamp = nil\n\t}\n\n\t// If no metadata field was parsed, set the metadata field on the\n\t// resulting payload to nil.\n\tif _, ok := parsedTypes[record.MetadataOnionType]; !ok {\n\t\tmetadata = nil\n\t}\n\n\t// Filter out the custom records.\n\tcustomRecords := NewCustomRecords(parsedTypes)\n\n\treturn &Payload{\n\t\tFwdInfo: ForwardingInfo{\n\t\t\tNetwork:         BitcoinNetwork,\n\t\t\tNextHop:         nextHop,\n\t\t\tAmountToForward: lnwire.MilliSatoshi(amt),\n\t\t\tOutgoingCTLV:    cltv,\n\t\t},\n\t\tMPP:           mpp,\n\t\tAMP:           amp,\n\t\tmetadata:      metadata,\n\t\tcustomRecords: customRecords,\n\t}, nil\n}\n\n// ForwardingInfo returns the basic parameters required for HTLC forwarding,\n// e.g. amount, cltv, and next hop.",
      "length": 2019,
      "tokens": 270,
      "embedding": []
    },
    {
      "slug": "func (h *Payload) ForwardingInfo() ForwardingInfo {",
      "content": "func (h *Payload) ForwardingInfo() ForwardingInfo {\n\treturn h.FwdInfo\n}\n\n// NewCustomRecords filters the types parsed from the tlv stream for custom\n// records.",
      "length": 104,
      "tokens": 17,
      "embedding": []
    },
    {
      "slug": "func NewCustomRecords(parsedTypes tlv.TypeMap) record.CustomSet {",
      "content": "func NewCustomRecords(parsedTypes tlv.TypeMap) record.CustomSet {\n\tcustomRecords := make(record.CustomSet)\n\tfor t, parseResult := range parsedTypes {\n\t\tif parseResult == nil || t < record.CustomTypeStart {\n\t\t\tcontinue\n\t\t}\n\t\tcustomRecords[uint64(t)] = parseResult\n\t}\n\treturn customRecords\n}\n\n// ValidateParsedPayloadTypes checks the types parsed from a hop payload to\n// ensure that the proper fields are either included or omitted. The finalHop\n// boolean should be true if the payload was parsed for an exit hop. The\n// requirements for this method are described in BOLT 04.",
      "length": 496,
      "tokens": 77,
      "embedding": []
    },
    {
      "slug": "func ValidateParsedPayloadTypes(parsedTypes tlv.TypeMap,",
      "content": "func ValidateParsedPayloadTypes(parsedTypes tlv.TypeMap,\n\tnextHop lnwire.ShortChannelID) error {\n\n\tisFinalHop := nextHop == Exit\n\n\t_, hasAmt := parsedTypes[record.AmtOnionType]\n\t_, hasLockTime := parsedTypes[record.LockTimeOnionType]\n\t_, hasNextHop := parsedTypes[record.NextHopOnionType]\n\t_, hasMPP := parsedTypes[record.MPPOnionType]\n\t_, hasAMP := parsedTypes[record.AMPOnionType]\n\n\tswitch {\n\n\t// All hops must include an amount to forward.\n\tcase !hasAmt:\n\t\treturn ErrInvalidPayload{\n\t\t\tType:      record.AmtOnionType,\n\t\t\tViolation: OmittedViolation,\n\t\t\tFinalHop:  isFinalHop,\n\t\t}\n\n\t// All hops must include a cltv expiry.\n\tcase !hasLockTime:\n\t\treturn ErrInvalidPayload{\n\t\t\tType:      record.LockTimeOnionType,\n\t\t\tViolation: OmittedViolation,\n\t\t\tFinalHop:  isFinalHop,\n\t\t}\n\n\t// The exit hop should omit the next hop id. If nextHop != Exit, the\n\t// sender must have included a record, so we don't need to test for its\n\t// inclusion at intermediate hops directly.\n\tcase isFinalHop && hasNextHop:\n\t\treturn ErrInvalidPayload{\n\t\t\tType:      record.NextHopOnionType,\n\t\t\tViolation: IncludedViolation,\n\t\t\tFinalHop:  true,\n\t\t}\n\n\t// Intermediate nodes should never receive MPP fields.\n\tcase !isFinalHop && hasMPP:\n\t\treturn ErrInvalidPayload{\n\t\t\tType:      record.MPPOnionType,\n\t\t\tViolation: IncludedViolation,\n\t\t\tFinalHop:  isFinalHop,\n\t\t}\n\n\t// Intermediate nodes should never receive AMP fields.\n\tcase !isFinalHop && hasAMP:\n\t\treturn ErrInvalidPayload{\n\t\t\tType:      record.AMPOnionType,\n\t\t\tViolation: IncludedViolation,\n\t\t\tFinalHop:  isFinalHop,\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// MultiPath returns the record corresponding the option_mpp parsed from the\n// onion payload.",
      "length": 1541,
      "tokens": 179,
      "embedding": []
    },
    {
      "slug": "func (h *Payload) MultiPath() *record.MPP {",
      "content": "func (h *Payload) MultiPath() *record.MPP {\n\treturn h.MPP\n}\n\n// AMPRecord returns the record corresponding with option_amp parsed from the\n// onion payload.",
      "length": 108,
      "tokens": 17,
      "embedding": []
    },
    {
      "slug": "func (h *Payload) AMPRecord() *record.AMP {",
      "content": "func (h *Payload) AMPRecord() *record.AMP {\n\treturn h.AMP\n}\n\n// CustomRecords returns the custom tlv type records that were parsed from the\n// payload.",
      "length": 103,
      "tokens": 18,
      "embedding": []
    },
    {
      "slug": "func (h *Payload) CustomRecords() record.CustomSet {",
      "content": "func (h *Payload) CustomRecords() record.CustomSet {\n\treturn h.customRecords\n}\n\n// Metadata returns the additional data that is sent along with the\n// payment to the payee.",
      "length": 115,
      "tokens": 20,
      "embedding": []
    },
    {
      "slug": "func (h *Payload) Metadata() []byte {",
      "content": "func (h *Payload) Metadata() []byte {\n\treturn h.metadata\n}\n\n// getMinRequiredViolation checks for unrecognized required (even) fields in the\n// standard range and returns the lowest required type. Always returning the\n// lowest required type allows a failure message to be deterministic.",
      "length": 244,
      "tokens": 36,
      "embedding": []
    },
    {
      "slug": "func getMinRequiredViolation(set tlv.TypeMap) *tlv.Type {",
      "content": "func getMinRequiredViolation(set tlv.TypeMap) *tlv.Type {\n\tvar (\n\t\trequiredViolation        bool\n\t\tminRequiredViolationType tlv.Type\n\t)\n\tfor t, parseResult := range set {\n\t\t// If a type is even but not known to us, we cannot process the\n\t\t// payload. We are required to understand a field that we don't\n\t\t// support.\n\t\t//\n\t\t// We always accept custom fields, because a higher level\n\t\t// application may understand them.\n\t\tif parseResult == nil || t%2 != 0 ||\n\t\t\tt >= record.CustomTypeStart {\n\n\t\t\tcontinue\n\t\t}\n\n\t\tif !requiredViolation || t < minRequiredViolationType {\n\t\t\tminRequiredViolationType = t\n\t\t}\n\t\trequiredViolation = true\n\t}\n\n\tif requiredViolation {\n\t\treturn &minRequiredViolationType\n\t}\n\n\treturn nil\n}\n",
      "length": 625,
      "tokens": 98,
      "embedding": []
    }
  ]
}