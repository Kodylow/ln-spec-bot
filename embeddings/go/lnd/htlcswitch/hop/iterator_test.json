{
  "filepath": "../implementations/go/lnd/htlcswitch/hop/iterator_test.go",
  "package": "hop",
  "sections": [
    {
      "slug": "func TestSphinxHopIteratorForwardingInstructions(t *testing.T) {",
      "content": "func TestSphinxHopIteratorForwardingInstructions(t *testing.T) {\n\tt.Parallel()\n\n\t// First, we'll make the hop data that the sender would create to send\n\t// an HTLC through our imaginary route.\n\thopData := sphinx.HopData{\n\t\tForwardAmount: 100000,\n\t\tOutgoingCltv:  4343,\n\t}\n\tcopy(hopData.NextAddress[:], bytes.Repeat([]byte(\"a\"), 8))\n\n\t// Next, we'll make the hop forwarding information that we should\n\t// extract each type, no matter the payload type.\n\tnextAddrInt := binary.BigEndian.Uint64(hopData.NextAddress[:])\n\texpectedFwdInfo := ForwardingInfo{\n\t\tNextHop:         lnwire.NewShortChanIDFromInt(nextAddrInt),\n\t\tAmountToForward: lnwire.MilliSatoshi(hopData.ForwardAmount),\n\t\tOutgoingCTLV:    hopData.OutgoingCltv,\n\t}\n\n\t// For our TLV payload, we'll serialize the hop into into a TLV stream\n\t// as we would normally in the routing network.\n\tvar b bytes.Buffer\n\ttlvRecords := []tlv.Record{\n\t\trecord.NewAmtToFwdRecord(&hopData.ForwardAmount),\n\t\trecord.NewLockTimeRecord(&hopData.OutgoingCltv),\n\t\trecord.NewNextHopIDRecord(&nextAddrInt),\n\t}\n\ttlvStream, err := tlv.NewStream(tlvRecords...)\n\trequire.NoError(t, err, \"unable to create stream\")\n\tif err := tlvStream.Encode(&b); err != nil {\n\t\tt.Fatalf(\"unable to encode stream: %v\", err)\n\t}\n\n\tvar testCases = []struct {\n\t\tsphinxPacket    *sphinx.ProcessedPacket\n\t\texpectedFwdInfo ForwardingInfo\n\t}{\n\t\t// A regular legacy payload that signals more hops.\n\t\t{\n\t\t\tsphinxPacket: &sphinx.ProcessedPacket{\n\t\t\t\tPayload: sphinx.HopPayload{\n\t\t\t\t\tType: sphinx.PayloadLegacy,\n\t\t\t\t},\n\t\t\t\tAction:                 sphinx.MoreHops,\n\t\t\t\tForwardingInstructions: &hopData,\n\t\t\t},\n\t\t\texpectedFwdInfo: expectedFwdInfo,\n\t\t},\n\t\t// A TLV payload, we can leave off the action as we'll always\n\t\t// read the cid encoded.\n\t\t{\n\t\t\tsphinxPacket: &sphinx.ProcessedPacket{\n\t\t\t\tPayload: sphinx.HopPayload{\n\t\t\t\t\tType:    sphinx.PayloadTLV,\n\t\t\t\t\tPayload: b.Bytes(),\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedFwdInfo: expectedFwdInfo,\n\t\t},\n\t}\n\n\t// Finally, we'll test that we get the same set of\n\t// ForwardingInstructions for each payload type.\n\titerator := sphinxHopIterator{}\n\tfor i, testCase := range testCases {\n\t\titerator.processedPacket = testCase.sphinxPacket\n\n\t\tpld, err := iterator.HopPayload()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"#%v: unable to extract forwarding \"+\n\t\t\t\t\"instructions: %v\", i, err)\n\t\t}\n\n\t\tfwdInfo := pld.ForwardingInfo()\n\t\tif fwdInfo != testCase.expectedFwdInfo {\n\t\t\tt.Fatalf(\"#%v: wrong fwding info: expected %v, got %v\",\n\t\t\t\ti, spew.Sdump(testCase.expectedFwdInfo),\n\t\t\t\tspew.Sdump(fwdInfo))\n\t\t}\n\t}\n}\n",
      "length": 2368,
      "tokens": 264,
      "embedding": []
    }
  ]
}