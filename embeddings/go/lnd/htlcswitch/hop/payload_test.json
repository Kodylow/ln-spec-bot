{
  "filepath": "../implementations/go/lnd/htlcswitch/hop/payload_test.go",
  "package": "hop_test",
  "sections": [
    {
      "slug": "type decodePayloadTest struct {",
      "content": "type decodePayloadTest struct {\n\tname               string\n\tpayload            []byte\n\texpErr             error\n\texpCustomRecords   map[uint64][]byte\n\tshouldHaveMPP      bool\n\tshouldHaveAMP      bool\n\tshouldHaveMetadata bool\n}\n\nvar decodePayloadTests = []decodePayloadTest{\n\t{\n\t\tname:    \"final hop valid\",\n\t\tpayload: []byte{0x02, 0x00, 0x04, 0x00},\n\t},\n\t{\n\t\tname: \"intermediate hop valid\",\n\t\tpayload: []byte{0x02, 0x00, 0x04, 0x00, 0x06, 0x08, 0x01, 0x00,\n\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t},\n\t},\n\t{\n\t\tname:    \"final hop no amount\",\n\t\tpayload: []byte{0x04, 0x00},\n\t\texpErr: hop.ErrInvalidPayload{\n\t\t\tType:      record.AmtOnionType,\n\t\t\tViolation: hop.OmittedViolation,\n\t\t\tFinalHop:  true,\n\t\t},\n\t},\n\t{\n\t\tname: \"intermediate hop no amount\",\n\t\tpayload: []byte{0x04, 0x00, 0x06, 0x08, 0x01, 0x00, 0x00, 0x00,\n\t\t\t0x00, 0x00, 0x00, 0x00,\n\t\t},\n\t\texpErr: hop.ErrInvalidPayload{\n\t\t\tType:      record.AmtOnionType,\n\t\t\tViolation: hop.OmittedViolation,\n\t\t\tFinalHop:  false,\n\t\t},\n\t},\n\t{\n\t\tname:    \"final hop no expiry\",\n\t\tpayload: []byte{0x02, 0x00},\n\t\texpErr: hop.ErrInvalidPayload{\n\t\t\tType:      record.LockTimeOnionType,\n\t\t\tViolation: hop.OmittedViolation,\n\t\t\tFinalHop:  true,\n\t\t},\n\t},\n\t{\n\t\tname: \"intermediate hop no expiry\",\n\t\tpayload: []byte{0x02, 0x00, 0x06, 0x08, 0x01, 0x00, 0x00, 0x00,\n\t\t\t0x00, 0x00, 0x00, 0x00,\n\t\t},\n\t\texpErr: hop.ErrInvalidPayload{\n\t\t\tType:      record.LockTimeOnionType,\n\t\t\tViolation: hop.OmittedViolation,\n\t\t\tFinalHop:  false,\n\t\t},\n\t},\n\t{\n\t\tname: \"final hop next sid present\",\n\t\tpayload: []byte{0x02, 0x00, 0x04, 0x00, 0x06, 0x08, 0x00, 0x00,\n\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t},\n\t\texpErr: hop.ErrInvalidPayload{\n\t\t\tType:      record.NextHopOnionType,\n\t\t\tViolation: hop.IncludedViolation,\n\t\t\tFinalHop:  true,\n\t\t},\n\t},\n\t{\n\t\tname: \"required type after omitted hop id\",\n\t\tpayload: []byte{\n\t\t\t0x02, 0x00, 0x04, 0x00,\n\t\t\ttestUnknownRequiredType, 0x00,\n\t\t},\n\t\texpErr: hop.ErrInvalidPayload{\n\t\t\tType:      testUnknownRequiredType,\n\t\t\tViolation: hop.RequiredViolation,\n\t\t\tFinalHop:  true,\n\t\t},\n\t},\n\t{\n\t\tname: \"required type after included hop id\",\n\t\tpayload: []byte{\n\t\t\t0x02, 0x00, 0x04, 0x00, 0x06, 0x08, 0x01, 0x00, 0x00,\n\t\t\t0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\ttestUnknownRequiredType, 0x00,\n\t\t},\n\t\texpErr: hop.ErrInvalidPayload{\n\t\t\tType:      testUnknownRequiredType,\n\t\t\tViolation: hop.RequiredViolation,\n\t\t\tFinalHop:  false,\n\t\t},\n\t},\n\t{\n\t\tname:    \"required type zero final hop\",\n\t\tpayload: []byte{0x00, 0x00, 0x02, 0x00, 0x04, 0x00},\n\t\texpErr: hop.ErrInvalidPayload{\n\t\t\tType:      0,\n\t\t\tViolation: hop.RequiredViolation,\n\t\t\tFinalHop:  true,\n\t\t},\n\t},\n\t{\n\t\tname: \"required type zero final hop zero sid\",\n\t\tpayload: []byte{0x00, 0x00, 0x02, 0x00, 0x04, 0x00, 0x06, 0x08,\n\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t},\n\t\texpErr: hop.ErrInvalidPayload{\n\t\t\tType:      record.NextHopOnionType,\n\t\t\tViolation: hop.IncludedViolation,\n\t\t\tFinalHop:  true,\n\t\t},\n\t},\n\t{\n\t\tname: \"required type zero intermediate hop\",\n\t\tpayload: []byte{0x00, 0x00, 0x02, 0x00, 0x04, 0x00, 0x06, 0x08,\n\t\t\t0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t},\n\t\texpErr: hop.ErrInvalidPayload{\n\t\t\tType:      0,\n\t\t\tViolation: hop.RequiredViolation,\n\t\t\tFinalHop:  false,\n\t\t},\n\t},\n\t{\n\t\tname: \"required type in custom range\",\n\t\tpayload: []byte{0x02, 0x00, 0x04, 0x00,\n\t\t\t0xfe, 0x00, 0x01, 0x00, 0x00, 0x02, 0x10, 0x11,\n\t\t},\n\t\texpCustomRecords: map[uint64][]byte{\n\t\t\t65536: {0x10, 0x11},\n\t\t},\n\t},\n\t{\n\t\tname: \"valid intermediate hop\",\n\t\tpayload: []byte{0x02, 0x00, 0x04, 0x00, 0x06, 0x08, 0x01, 0x00,\n\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t},\n\t\texpErr: nil,\n\t},\n\t{\n\t\tname:    \"valid final hop\",\n\t\tpayload: []byte{0x02, 0x00, 0x04, 0x00},\n\t\texpErr:  nil,\n\t},\n\t{\n\t\tname: \"intermediate hop with mpp\",\n\t\tpayload: []byte{\n\t\t\t// amount\n\t\t\t0x02, 0x00,\n\t\t\t// cltv\n\t\t\t0x04, 0x00,\n\t\t\t// next hop id\n\t\t\t0x06, 0x08,\n\t\t\t0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t// mpp\n\t\t\t0x08, 0x21,\n\t\t\t0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,\n\t\t\t0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,\n\t\t\t0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,\n\t\t\t0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,\n\t\t\t0x08,\n\t\t},\n\t\texpErr: hop.ErrInvalidPayload{\n\t\t\tType:      record.MPPOnionType,\n\t\t\tViolation: hop.IncludedViolation,\n\t\t\tFinalHop:  false,\n\t\t},\n\t},\n\t{\n\t\tname: \"intermediate hop with amp\",\n\t\tpayload: []byte{\n\t\t\t// amount\n\t\t\t0x02, 0x00,\n\t\t\t// cltv\n\t\t\t0x04, 0x00,\n\t\t\t// next hop id\n\t\t\t0x06, 0x08,\n\t\t\t0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t// amp\n\t\t\t0x0e, 0x41,\n\t\t\t// amp.root_share\n\t\t\t0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,\n\t\t\t0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,\n\t\t\t0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,\n\t\t\t0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,\n\t\t\t// amp.set_id\n\t\t\t0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13,\n\t\t\t0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13,\n\t\t\t0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13,\n\t\t\t0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13,\n\t\t\t// amp.child_index\n\t\t\t0x09,\n\t\t},\n\t\texpErr: hop.ErrInvalidPayload{\n\t\t\tType:      record.AMPOnionType,\n\t\t\tViolation: hop.IncludedViolation,\n\t\t\tFinalHop:  false,\n\t\t},\n\t},\n\t{\n\t\tname: \"final hop with mpp\",\n\t\tpayload: []byte{\n\t\t\t// amount\n\t\t\t0x02, 0x00,\n\t\t\t// cltv\n\t\t\t0x04, 0x00,\n\t\t\t// mpp\n\t\t\t0x08, 0x21,\n\t\t\t0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,\n\t\t\t0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,\n\t\t\t0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,\n\t\t\t0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,\n\t\t\t0x08,\n\t\t},\n\t\texpErr:        nil,\n\t\tshouldHaveMPP: true,\n\t},\n\t{\n\t\tname: \"final hop with amp\",\n\t\tpayload: []byte{\n\t\t\t// amount\n\t\t\t0x02, 0x00,\n\t\t\t// cltv\n\t\t\t0x04, 0x00,\n\t\t\t// amp\n\t\t\t0x0e, 0x41,\n\t\t\t// amp.root_share\n\t\t\t0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,\n\t\t\t0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,\n\t\t\t0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,\n\t\t\t0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,\n\t\t\t// amp.set_id\n\t\t\t0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13,\n\t\t\t0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13,\n\t\t\t0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13,\n\t\t\t0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13,\n\t\t\t// amp.child_index\n\t\t\t0x09,\n\t\t},\n\t\tshouldHaveAMP: true,\n\t},\n\t{\n\t\tname: \"final hop with metadata\",\n\t\tpayload: []byte{\n\t\t\t// amount\n\t\t\t0x02, 0x00,\n\t\t\t// cltv\n\t\t\t0x04, 0x00,\n\t\t\t// metadata\n\t\t\t0x10, 0x03, 0x01, 0x02, 0x03,\n\t\t},\n\t\tshouldHaveMetadata: true,\n\t},\n}\n\n// TestDecodeHopPayloadRecordValidation asserts that parsing the payloads in the\n// tests yields the expected errors depending on whether the proper fields were\n// included or omitted.",
      "length": 6197,
      "tokens": 810,
      "embedding": []
    },
    {
      "slug": "func TestDecodeHopPayloadRecordValidation(t *testing.T) {",
      "content": "func TestDecodeHopPayloadRecordValidation(t *testing.T) {\n\tfor _, test := range decodePayloadTests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\ttestDecodeHopPayloadValidation(t, test)\n\t\t})\n\t}\n}\n",
      "length": 130,
      "tokens": 16,
      "embedding": []
    },
    {
      "slug": "func testDecodeHopPayloadValidation(t *testing.T, test decodePayloadTest) {",
      "content": "func testDecodeHopPayloadValidation(t *testing.T, test decodePayloadTest) {\n\tvar (\n\t\ttestTotalMsat = lnwire.MilliSatoshi(8)\n\t\ttestAddr      = [32]byte{\n\t\t\t0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,\n\t\t\t0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,\n\t\t\t0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,\n\t\t\t0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,\n\t\t}\n\n\t\ttestRootShare = [32]byte{\n\t\t\t0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,\n\t\t\t0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,\n\t\t\t0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,\n\t\t\t0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,\n\t\t}\n\t\ttestSetID = [32]byte{\n\t\t\t0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13,\n\t\t\t0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13,\n\t\t\t0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13,\n\t\t\t0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13,\n\t\t}\n\t\ttestMetadata   = []byte{1, 2, 3}\n\t\ttestChildIndex = uint32(9)\n\t)\n\n\tp, err := hop.NewPayloadFromReader(bytes.NewReader(test.payload))\n\tif !reflect.DeepEqual(test.expErr, err) {\n\t\tt.Fatalf(\"expected error mismatch, want: %v, got: %v\",\n\t\t\ttest.expErr, err)\n\t}\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// Assert MPP fields if we expect them.\n\tif test.shouldHaveMPP {\n\t\tif p.MPP == nil {\n\t\t\tt.Fatalf(\"payload should have MPP record\")\n\t\t}\n\t\tif p.MPP.TotalMsat() != testTotalMsat {\n\t\t\tt.Fatalf(\"invalid total msat\")\n\t\t}\n\t\tif p.MPP.PaymentAddr() != testAddr {\n\t\t\tt.Fatalf(\"invalid payment addr\")\n\t\t}\n\t} else if p.MPP != nil {\n\t\tt.Fatalf(\"unexpected MPP payload\")\n\t}\n\n\tif test.shouldHaveAMP {\n\t\tif p.AMP == nil {\n\t\t\tt.Fatalf(\"payload should have AMP record\")\n\t\t}\n\t\trequire.Equal(t, testRootShare, p.AMP.RootShare())\n\t\trequire.Equal(t, testSetID, p.AMP.SetID())\n\t\trequire.Equal(t, testChildIndex, p.AMP.ChildIndex())\n\t} else if p.AMP != nil {\n\t\tt.Fatalf(\"unexpected AMP payload\")\n\t}\n\n\tif test.shouldHaveMetadata {\n\t\tif p.Metadata() == nil {\n\t\t\tt.Fatalf(\"payload should have metadata\")\n\t\t}\n\t\trequire.Equal(t, testMetadata, p.Metadata())\n\t} else if p.Metadata() != nil {\n\t\tt.Fatalf(\"unexpected metadata\")\n\t}\n\n\t// Convert expected nil map to empty map, because we always expect an\n\t// initiated map from the payload.\n\texpCustomRecords := make(record.CustomSet)\n\tif test.expCustomRecords != nil {\n\t\texpCustomRecords = test.expCustomRecords\n\t}\n\tif !reflect.DeepEqual(expCustomRecords, p.CustomRecords()) {\n\t\tt.Fatalf(\"invalid custom records\")\n\t}\n}\n",
      "length": 2199,
      "tokens": 298,
      "embedding": []
    }
  ]
}