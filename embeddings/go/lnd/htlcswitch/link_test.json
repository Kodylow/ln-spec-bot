{
  "filepath": "../implementations/go/lnd/htlcswitch/link_test.go",
  "package": "htlcswitch",
  "sections": [
    {
      "slug": "type concurrentTester struct {",
      "content": "type concurrentTester struct {\n\tmtx sync.Mutex\n\t*testing.T\n}\n",
      "length": 27,
      "tokens": 4,
      "embedding": []
    },
    {
      "slug": "func newConcurrentTester(t *testing.T) *concurrentTester {",
      "content": "func newConcurrentTester(t *testing.T) *concurrentTester {\n\treturn &concurrentTester{\n\t\tT: t,\n\t}\n}\n",
      "length": 36,
      "tokens": 6,
      "embedding": []
    },
    {
      "slug": "func (c *concurrentTester) Fatalf(format string, args ...interface{}) {",
      "content": "func (c *concurrentTester) Fatalf(format string, args ...interface{}) {\n\tc.T.Helper()\n\n\tc.mtx.Lock()\n\tdefer c.mtx.Unlock()\n\n\tc.T.Fatalf(format, args...)\n}\n\n// messageToString is used to produce less spammy log messages in trace mode by\n// setting the 'Curve\" parameter to nil. Doing this avoids printing out each of\n// the field elements in the curve parameters for secp256k1.",
      "length": 294,
      "tokens": 45,
      "embedding": []
    },
    {
      "slug": "func messageToString(msg lnwire.Message) string {",
      "content": "func messageToString(msg lnwire.Message) string {\n\treturn spew.Sdump(msg)\n}\n\n// expectedMessage struct holds the message which travels from one peer to\n// another, and additional information like, should this message we skipped for\n// handling.",
      "length": 189,
      "tokens": 29,
      "embedding": []
    },
    {
      "slug": "type expectedMessage struct {",
      "content": "type expectedMessage struct {\n\tfrom    string\n\tto      string\n\tmessage lnwire.Message\n\tskip    bool\n}\n\n// createLogFunc is a helper function which returns the function which will be\n// used for logging message are received from another peer.",
      "length": 204,
      "tokens": 32,
      "embedding": []
    },
    {
      "slug": "func createLogFunc(name string, channelID lnwire.ChannelID) messageInterceptor {",
      "content": "func createLogFunc(name string, channelID lnwire.ChannelID) messageInterceptor {\n\treturn func(m lnwire.Message) (bool, error) {\n\t\tchanID, err := getChanID(m)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\n\t\tif chanID == channelID {\n\t\t\tfmt.Printf(\"---------------------- \\n %v received: \"+\n\t\t\t\t\"%v\", name, messageToString(m))\n\t\t}\n\t\treturn false, nil\n\t}\n}\n\n// createInterceptorFunc creates the function by the given set of messages\n// which, checks the order of the messages and skip the ones which were\n// indicated to be intercepted.",
      "length": 433,
      "tokens": 68,
      "embedding": []
    },
    {
      "slug": "func createInterceptorFunc(prefix, receiver string, messages []expectedMessage,",
      "content": "func createInterceptorFunc(prefix, receiver string, messages []expectedMessage,\n\tchanID lnwire.ChannelID, debug bool) messageInterceptor {\n\n\t// Filter message which should be received with given peer name.\n\tvar expectToReceive []expectedMessage\n\tfor _, message := range messages {\n\t\tif message.to == receiver {\n\t\t\texpectToReceive = append(expectToReceive, message)\n\t\t}\n\t}\n\n\t// Return function which checks the message order and skip the\n\t// messages.\n\treturn func(m lnwire.Message) (bool, error) {\n\t\tmessageChanID, err := getChanID(m)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\n\t\tif messageChanID == chanID {\n\t\t\tif len(expectToReceive) == 0 {\n\t\t\t\treturn false, errors.Errorf(\"%v received \"+\n\t\t\t\t\t\"unexpected message out of range: %v\",\n\t\t\t\t\treceiver, m.MsgType())\n\t\t\t}\n\n\t\t\texpectedMessage := expectToReceive[0]\n\t\t\texpectToReceive = expectToReceive[1:]\n\n\t\t\tif expectedMessage.message.MsgType() != m.MsgType() {\n\t\t\t\treturn false, errors.Errorf(\"%v received wrong message: \\n\"+\n\t\t\t\t\t\"real: %v\\nexpected: %v\", receiver, m.MsgType(),\n\t\t\t\t\texpectedMessage.message.MsgType())\n\t\t\t}\n\n\t\t\tif debug {\n\t\t\t\tvar postfix string\n\t\t\t\tif revocation, ok := m.(*lnwire.RevokeAndAck); ok {\n\t\t\t\t\tvar zeroHash chainhash.Hash\n\t\t\t\t\tif bytes.Equal(zeroHash[:], revocation.Revocation[:]) {\n\t\t\t\t\t\tpostfix = \"- empty revocation\"\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif expectedMessage.skip {\n\t\t\t\t\tfmt.Printf(\"skipped: %v: %v %v \\n\", prefix,\n\t\t\t\t\t\tm.MsgType(), postfix)\n\t\t\t\t} else {\n\t\t\t\t\tfmt.Printf(\"%v: %v %v \\n\", prefix, m.MsgType(), postfix)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn expectedMessage.skip, nil\n\t\t}\n\t\treturn false, nil\n\t}\n}\n\n// TestChannelLinkRevThenSig tests that if a link owes both a revocation and a\n// signature to the counterparty (in this order), that they are sent as rev and\n// then sig.\n//\n// Specifically, this tests the following scenario:\n//\n// A               B\n//\n//\t<----add-----\n//\t-----add---->\n//\t<----sig-----\n//\t-----rev----x\n//\t-----sig----x",
      "length": 1762,
      "tokens": 232,
      "embedding": []
    },
    {
      "slug": "func TestChannelLinkRevThenSig(t *testing.T) {",
      "content": "func TestChannelLinkRevThenSig(t *testing.T) {\n\tt.Parallel()\n\n\tconst chanAmt = btcutil.SatoshiPerBitcoin * 5\n\tconst chanReserve = btcutil.SatoshiPerBitcoin * 1\n\taliceLink, bobChannel, batchTicker, start, restore, err :=\n\t\tnewSingleLinkTestHarness(t, chanAmt, chanReserve)\n\trequire.NoError(t, err)\n\n\terr = start()\n\trequire.NoError(t, err)\n\tdefer aliceLink.Stop()\n\n\talice := newPersistentLinkHarness(\n\t\tt, aliceLink, batchTicker, restore,\n\t)\n\n\tvar (\n\t\tcoreLink  = aliceLink.(*channelLink)\n\t\taliceMsgs = coreLink.cfg.Peer.(*mockPeer).sentMsgs\n\t)\n\n\tctx := linkTestContext{\n\t\tt:          t,\n\t\taliceLink:  aliceLink,\n\t\taliceMsgs:  aliceMsgs,\n\t\tbobChannel: bobChannel,\n\t}\n\n\tbobHtlc1 := generateHtlc(t, coreLink, 0)\n\n\t// <-----add-----\n\t// Send an htlc from Bob to Alice.\n\tctx.sendHtlcBobToAlice(bobHtlc1)\n\n\taliceHtlc1, _ := generateHtlcAndInvoice(t, 0)\n\n\t// ------add---->\n\tctx.sendHtlcAliceToBob(0, aliceHtlc1)\n\tctx.receiveHtlcAliceToBob()\n\n\t// <-----sig-----\n\tctx.sendCommitSigBobToAlice(1)\n\n\t// ------rev----x\n\tvar msg lnwire.Message\n\tselect {\n\tcase msg = <-aliceMsgs:\n\tcase <-time.After(15 * time.Second):\n\t\tt.Fatalf(\"did not receive message\")\n\t}\n\n\t_, ok := msg.(*lnwire.RevokeAndAck)\n\trequire.True(t, ok)\n\n\t// ------sig----x\n\t// Trigger a commitsig from Alice->Bob.\n\tselect {\n\tcase batchTicker <- time.Now():\n\tcase <-time.After(5 * time.Second):\n\t\tt.Fatalf(\"could not force commit sig\")\n\t}\n\n\tselect {\n\tcase msg = <-aliceMsgs:\n\tcase <-time.After(15 * time.Second):\n\t\tt.Fatalf(\"did not receive message\")\n\t}\n\n\tcomSig, ok := msg.(*lnwire.CommitSig)\n\trequire.True(t, ok)\n\n\tif len(comSig.HtlcSigs) != 2 {\n\t\tt.Fatalf(\"expected 2 htlc sigs, got %d\", len(comSig.HtlcSigs))\n\t}\n\n\t// Restart Alice so she sends and accepts ChannelReestablish.\n\talice.restart(false, true)\n\n\tctx.aliceLink = alice.link\n\tctx.aliceMsgs = alice.msgs\n\n\t// Restart Bob as well by calling NewLightningChannel.\n\tbobSigner := bobChannel.Signer\n\tbobPool := lnwallet.NewSigPool(runtime.NumCPU(), bobSigner)\n\tbobChannel, err = lnwallet.NewLightningChannel(\n\t\tbobSigner, bobChannel.State(), bobPool,\n\t)\n\trequire.NoError(t, err)\n\terr = bobPool.Start()\n\trequire.NoError(t, err)\n\n\tctx.bobChannel = bobChannel\n\n\t// --reestablish->\n\tselect {\n\tcase msg = <-ctx.aliceMsgs:\n\tcase <-time.After(15 * time.Second):\n\t\tt.Fatalf(\"did not receive message\")\n\t}\n\n\t_, ok = msg.(*lnwire.ChannelReestablish)\n\trequire.True(t, ok)\n\n\t// <-reestablish--\n\tbobReest, err := bobChannel.State().ChanSyncMsg()\n\trequire.NoError(t, err)\n\tctx.aliceLink.HandleChannelUpdate(bobReest)\n\n\t// ------rev---->\n\tctx.receiveRevAndAckAliceToBob()\n\n\t// ------add---->\n\tctx.receiveHtlcAliceToBob()\n\n\t// ------sig---->\n\tctx.receiveCommitSigAliceToBob(2)\n}\n\n// TestChannelLinkSigThenRev tests that if a link owes both a signature and a\n// revocation to the counterparty (in this order), that they are sent as sig\n// and then rev.\n//\n// Specifically, this tests the following scenario:\n//\n// A               B\n//\n//\t<----add-----\n//\t-----add---->\n//\t-----sig----x\n//\t<----sig-----\n//\t-----rev----x",
      "length": 2828,
      "tokens": 320,
      "embedding": []
    },
    {
      "slug": "func TestChannelLinkSigThenRev(t *testing.T) {",
      "content": "func TestChannelLinkSigThenRev(t *testing.T) {\n\tt.Parallel()\n\n\tconst chanAmt = btcutil.SatoshiPerBitcoin * 5\n\tconst chanReserve = btcutil.SatoshiPerBitcoin * 1\n\taliceLink, bobChannel, batchTicker, start, restore, err :=\n\t\tnewSingleLinkTestHarness(t, chanAmt, chanReserve)\n\trequire.NoError(t, err)\n\n\terr = start()\n\trequire.NoError(t, err)\n\tdefer aliceLink.Stop()\n\n\talice := newPersistentLinkHarness(\n\t\tt, aliceLink, batchTicker, restore,\n\t)\n\n\tvar (\n\t\tcoreLink  = aliceLink.(*channelLink)\n\t\taliceMsgs = coreLink.cfg.Peer.(*mockPeer).sentMsgs\n\t)\n\n\tctx := linkTestContext{\n\t\tt:          t,\n\t\taliceLink:  aliceLink,\n\t\taliceMsgs:  aliceMsgs,\n\t\tbobChannel: bobChannel,\n\t}\n\n\tbobHtlc1 := generateHtlc(t, coreLink, 0)\n\n\t// <-----add-----\n\t// Send an htlc from Bob to Alice.\n\tctx.sendHtlcBobToAlice(bobHtlc1)\n\n\taliceHtlc1, _ := generateHtlcAndInvoice(t, 0)\n\n\t// ------add---->\n\tctx.sendHtlcAliceToBob(0, aliceHtlc1)\n\tctx.receiveHtlcAliceToBob()\n\n\t// ------sig----x\n\t// Trigger a commitsig from Alice->Bob.\n\tselect {\n\tcase batchTicker <- time.Now():\n\tcase <-time.After(5 * time.Second):\n\t\tt.Fatalf(\"could not force commit sig\")\n\t}\n\n\tvar msg lnwire.Message\n\tselect {\n\tcase msg = <-aliceMsgs:\n\tcase <-time.After(15 * time.Second):\n\t\tt.Fatalf(\"did not receive message\")\n\t}\n\n\tcomSig, ok := msg.(*lnwire.CommitSig)\n\trequire.True(t, ok)\n\n\tif len(comSig.HtlcSigs) != 1 {\n\t\tt.Fatalf(\"expected 1 htlc sig, got %d\", len(comSig.HtlcSigs))\n\t}\n\n\t// <-----sig-----\n\tctx.sendCommitSigBobToAlice(1)\n\n\t// ------rev----x\n\tselect {\n\tcase msg = <-aliceMsgs:\n\tcase <-time.After(15 * time.Second):\n\t\tt.Fatalf(\"did not receive message\")\n\t}\n\n\t_, ok = msg.(*lnwire.RevokeAndAck)\n\trequire.True(t, ok)\n\n\t// Restart Alice so she sends and accepts ChannelReestablish.\n\talice.restart(false, true)\n\n\tctx.aliceLink = alice.link\n\tctx.aliceMsgs = alice.msgs\n\n\t// Restart Bob as well by calling NewLightningChannel.\n\tbobSigner := bobChannel.Signer\n\tbobPool := lnwallet.NewSigPool(runtime.NumCPU(), bobSigner)\n\tbobChannel, err = lnwallet.NewLightningChannel(\n\t\tbobSigner, bobChannel.State(), bobPool,\n\t)\n\trequire.NoError(t, err)\n\terr = bobPool.Start()\n\trequire.NoError(t, err)\n\n\tctx.bobChannel = bobChannel\n\n\t// --reestablish->\n\tselect {\n\tcase msg = <-ctx.aliceMsgs:\n\tcase <-time.After(15 * time.Second):\n\t\tt.Fatalf(\"did not receive message\")\n\t}\n\n\t_, ok = msg.(*lnwire.ChannelReestablish)\n\trequire.True(t, ok)\n\n\t// <-reestablish--\n\tbobReest, err := bobChannel.State().ChanSyncMsg()\n\trequire.NoError(t, err)\n\tctx.aliceLink.HandleChannelUpdate(bobReest)\n\n\t// ------add---->\n\tctx.receiveHtlcAliceToBob()\n\n\t// ------sig---->\n\tctx.receiveCommitSigAliceToBob(1)\n\n\t// ------rev---->\n\tctx.receiveRevAndAckAliceToBob()\n}\n\n// TestChannelLinkSingleHopPayment in this test we checks the interaction\n// between Alice and Bob within scope of one channel.",
      "length": 2626,
      "tokens": 285,
      "embedding": []
    },
    {
      "slug": "func TestChannelLinkSingleHopPayment(t *testing.T) {",
      "content": "func TestChannelLinkSingleHopPayment(t *testing.T) {\n\tt.Parallel()\n\n\t// Setup a alice-bob network.\n\talice, bob, err := createTwoClusterChannels(\n\t\tt, btcutil.SatoshiPerBitcoin*3, btcutil.SatoshiPerBitcoin*5,\n\t)\n\trequire.NoError(t, err, \"unable to create channel\")\n\n\tn := newTwoHopNetwork(t, alice.channel, bob.channel, testStartingHeight)\n\n\taliceBandwidthBefore := n.aliceChannelLink.Bandwidth()\n\tbobBandwidthBefore := n.bobChannelLink.Bandwidth()\n\n\tdebug := false\n\tif debug {\n\t\t// Log message that alice receives.\n\t\tn.aliceServer.intersect(createLogFunc(\"alice\",\n\t\t\tn.aliceChannelLink.ChanID()))\n\n\t\t// Log message that bob receives.\n\t\tn.bobServer.intersect(createLogFunc(\"bob\",\n\t\t\tn.bobChannelLink.ChanID()))\n\t}\n\n\tamount := lnwire.NewMSatFromSatoshis(btcutil.SatoshiPerBitcoin)\n\thtlcAmt, totalTimelock, hops := generateHops(amount, testStartingHeight,\n\t\tn.bobChannelLink)\n\n\t// Wait for:\n\t// * HTLC add request to be sent to bob.\n\t// * alice<->bob commitment state to be updated.\n\t// * settle request to be sent back from bob to alice.\n\t// * alice<->bob commitment state to be updated.\n\t// * user notification to be sent.\n\treceiver := n.bobServer\n\tfirstHop := n.bobChannelLink.ShortChanID()\n\trhash, err := makePayment(\n\t\tn.aliceServer, receiver, firstHop, hops, amount, htlcAmt,\n\t\ttotalTimelock,\n\t).Wait(30 * time.Second)\n\trequire.NoError(t, err, \"unable to make the payment\")\n\n\t// Wait for Alice to receive the revocation.\n\t//\n\t// TODO(roasbeef); replace with select over returned err chan\n\ttime.Sleep(2 * time.Second)\n\n\t// Check that alice invoice was settled and bandwidth of HTLC\n\t// links was changed.\n\tinvoice, err := receiver.registry.LookupInvoice(rhash)\n\trequire.NoError(t, err, \"unable to get invoice\")\n\tif invoice.State != invpkg.ContractSettled {\n\t\tt.Fatal(\"alice invoice wasn't settled\")\n\t}\n\n\tif aliceBandwidthBefore-amount != n.aliceChannelLink.Bandwidth() {\n\t\tt.Fatal(\"alice bandwidth should have decrease on payment \" +\n\t\t\t\"amount\")\n\t}\n\n\tif bobBandwidthBefore+amount != n.bobChannelLink.Bandwidth() {\n\t\tt.Fatalf(\"bob bandwidth isn't match: expected %v, got %v\",\n\t\t\tbobBandwidthBefore+amount,\n\t\t\tn.bobChannelLink.Bandwidth())\n\t}\n}\n\n// TestChannelLinkMultiHopPayment checks the ability to send payment over two\n// hops. In this test we send the payment from Carol to Alice over Bob peer.\n// (Carol -> Bob -> Alice) and checking that HTLC was settled properly and\n// balances were changed in two channels.\n//\n// The test is executed with two different OutgoingCltvRejectDelta values for\n// bob. In addition to a normal positive value, we also test the zero case\n// because this is currently the configured value in lnd\n// (defaultOutgoingCltvRejectDelta).",
      "length": 2540,
      "tokens": 316,
      "embedding": []
    },
    {
      "slug": "func TestChannelLinkMultiHopPayment(t *testing.T) {",
      "content": "func TestChannelLinkMultiHopPayment(t *testing.T) {\n\tt.Run(\n\t\t\"bobOutgoingCltvRejectDelta 3\",\n\t\tfunc(t *testing.T) {\n\t\t\ttestChannelLinkMultiHopPayment(t, 3)\n\t\t},\n\t)\n\tt.Run(\n\t\t\"bobOutgoingCltvRejectDelta 0\",\n\t\tfunc(t *testing.T) {\n\t\t\ttestChannelLinkMultiHopPayment(t, 0)\n\t\t},\n\t)\n}\n",
      "length": 215,
      "tokens": 21,
      "embedding": []
    },
    {
      "slug": "func testChannelLinkMultiHopPayment(t *testing.T,",
      "content": "func testChannelLinkMultiHopPayment(t *testing.T,\n\tbobOutgoingCltvRejectDelta uint32) {\n\n\tt.Parallel()\n\n\tchannels, _, err := createClusterChannels(\n\t\tt, btcutil.SatoshiPerBitcoin*3, btcutil.SatoshiPerBitcoin*5,\n\t)\n\trequire.NoError(t, err, \"unable to create channel\")\n\n\tn := newThreeHopNetwork(t, channels.aliceToBob, channels.bobToAlice,\n\t\tchannels.bobToCarol, channels.carolToBob, testStartingHeight)\n\n\tn.firstBobChannelLink.cfg.OutgoingCltvRejectDelta =\n\t\tbobOutgoingCltvRejectDelta\n\n\tn.secondBobChannelLink.cfg.OutgoingCltvRejectDelta =\n\t\tbobOutgoingCltvRejectDelta\n\n\tif err := n.start(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Cleanup(n.stop)\n\n\tcarolBandwidthBefore := n.carolChannelLink.Bandwidth()\n\tfirstBobBandwidthBefore := n.firstBobChannelLink.Bandwidth()\n\tsecondBobBandwidthBefore := n.secondBobChannelLink.Bandwidth()\n\taliceBandwidthBefore := n.aliceChannelLink.Bandwidth()\n\n\tdebug := false\n\tif debug {\n\t\t// Log messages that alice receives from bob.\n\t\tn.aliceServer.intersect(createLogFunc(\"[alice]<-bob<-carol: \",\n\t\t\tn.aliceChannelLink.ChanID()))\n\n\t\t// Log messages that bob receives from alice.\n\t\tn.bobServer.intersect(createLogFunc(\"alice->[bob]->carol: \",\n\t\t\tn.firstBobChannelLink.ChanID()))\n\n\t\t// Log messages that bob receives from carol.\n\t\tn.bobServer.intersect(createLogFunc(\"alice<-[bob]<-carol: \",\n\t\t\tn.secondBobChannelLink.ChanID()))\n\n\t\t// Log messages that carol receives from bob.\n\t\tn.carolServer.intersect(createLogFunc(\"alice->bob->[carol]\",\n\t\t\tn.carolChannelLink.ChanID()))\n\t}\n\n\tamount := lnwire.NewMSatFromSatoshis(btcutil.SatoshiPerBitcoin)\n\thtlcAmt, totalTimelock, hops := generateHops(amount,\n\t\ttestStartingHeight,\n\t\tn.firstBobChannelLink, n.carolChannelLink)\n\n\t// Wait for:\n\t// * HTLC add request to be sent from Alice to Bob.\n\t// * Alice<->Bob commitment states to be updated.\n\t// * HTLC add request to be propagated to Carol.\n\t// * Bob<->Carol commitment state to be updated.\n\t// * settle request to be sent back from Carol to Bob.\n\t// * Alice<->Bob commitment state to be updated.\n\t// * settle request to be sent back from Bob to Alice.\n\t// * Alice<->Bob commitment states to be updated.\n\t// * user notification to be sent.\n\treceiver := n.carolServer\n\tfirstHop := n.firstBobChannelLink.ShortChanID()\n\trhash, err := makePayment(\n\t\tn.aliceServer, n.carolServer, firstHop, hops, amount, htlcAmt,\n\t\ttotalTimelock,\n\t).Wait(30 * time.Second)\n\trequire.NoError(t, err, \"unable to send payment\")\n\n\t// Wait for Alice and Bob's second link to receive the revocation.\n\ttime.Sleep(2 * time.Second)\n\n\t// Check that Carol invoice was settled and bandwidth of HTLC\n\t// links were changed.\n\tinvoice, err := receiver.registry.LookupInvoice(rhash)\n\trequire.NoError(t, err, \"unable to get invoice\")\n\tif invoice.State != invpkg.ContractSettled {\n\t\tt.Fatal(\"carol invoice haven't been settled\")\n\t}\n\n\texpectedAliceBandwidth := aliceBandwidthBefore - htlcAmt\n\tif expectedAliceBandwidth != n.aliceChannelLink.Bandwidth() {\n\t\tt.Fatalf(\"channel bandwidth incorrect: expected %v, got %v\",\n\t\t\texpectedAliceBandwidth, n.aliceChannelLink.Bandwidth())\n\t}\n\n\texpectedBobBandwidth1 := firstBobBandwidthBefore + htlcAmt\n\tif expectedBobBandwidth1 != n.firstBobChannelLink.Bandwidth() {\n\t\tt.Fatalf(\"channel bandwidth incorrect: expected %v, got %v\",\n\t\t\texpectedBobBandwidth1, n.firstBobChannelLink.Bandwidth())\n\t}\n\n\texpectedBobBandwidth2 := secondBobBandwidthBefore - amount\n\tif expectedBobBandwidth2 != n.secondBobChannelLink.Bandwidth() {\n\t\tt.Fatalf(\"channel bandwidth incorrect: expected %v, got %v\",\n\t\t\texpectedBobBandwidth2, n.secondBobChannelLink.Bandwidth())\n\t}\n\n\texpectedCarolBandwidth := carolBandwidthBefore + amount\n\tif expectedCarolBandwidth != n.carolChannelLink.Bandwidth() {\n\t\tt.Fatalf(\"channel bandwidth incorrect: expected %v, got %v\",\n\t\t\texpectedCarolBandwidth, n.carolChannelLink.Bandwidth())\n\t}\n}\n\n// TestChannelLinkCancelFullCommitment tests the ability for links to cancel\n// forwarded HTLCs once all of their commitment slots are full.",
      "length": 3795,
      "tokens": 383,
      "embedding": []
    },
    {
      "slug": "func TestChannelLinkCancelFullCommitment(t *testing.T) {",
      "content": "func TestChannelLinkCancelFullCommitment(t *testing.T) {\n\tt.Parallel()\n\n\tchannels, _, err := createClusterChannels(\n\t\tt, btcutil.SatoshiPerBitcoin*3, btcutil.SatoshiPerBitcoin*5,\n\t)\n\trequire.NoError(t, err, \"unable to create channel\")\n\n\tn := newTwoHopNetwork(\n\t\tt, channels.aliceToBob, channels.bobToAlice, testStartingHeight,\n\t)\n\n\t// Fill up the commitment from Alice's side with 20 sat payments.\n\tcount := (input.MaxHTLCNumber / 2)\n\tamt := lnwire.NewMSatFromSatoshis(20000)\n\n\thtlcAmt, totalTimelock, hopsForwards := generateHops(amt,\n\t\ttestStartingHeight, n.bobChannelLink)\n\n\tfirstHop := n.aliceChannelLink.ShortChanID()\n\n\t// Create channels to buffer the preimage and error channels used in\n\t// making the preliminary payments.\n\tpreimages := make([]lntypes.Preimage, count)\n\taliceErrChan := make(chan chan error, count)\n\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < count; i++ {\n\t\t// Deterministically generate preimages. Avoid the all-zeroes\n\t\t// preimage because that will be rejected by the database.\n\t\tpreimages[i] = lntypes.Preimage{byte(i >> 8), byte(i), 1}\n\n\t\twg.Add(1)\n\t\tgo func(i int) {\n\t\t\tdefer wg.Done()\n\n\t\t\terrChan := n.makeHoldPayment(\n\t\t\t\tn.aliceServer, n.bobServer, firstHop,\n\t\t\t\thopsForwards, amt, htlcAmt, totalTimelock,\n\t\t\t\tpreimages[i],\n\t\t\t)\n\t\t\taliceErrChan <- errChan\n\t\t}(i)\n\t}\n\n\t// Wait for Alice to finish filling her commitment.\n\twg.Wait()\n\tclose(aliceErrChan)\n\n\t// Now make an additional payment from Alice to Bob, this should be\n\t// canceled because the commitment in this direction is full.\n\terr = <-makePayment(\n\t\tn.aliceServer, n.bobServer, firstHop, hopsForwards, amt,\n\t\thtlcAmt, totalTimelock,\n\t).err\n\tif err == nil {\n\t\tt.Fatalf(\"overflow payment should have failed\")\n\t}\n\tlerr, ok := err.(*LinkError)\n\tif !ok {\n\t\tt.Fatalf(\"expected LinkError, got: %T\", err)\n\t}\n\n\tmsg := lerr.WireMessage()\n\tif _, ok := msg.(*lnwire.FailTemporaryChannelFailure); !ok {\n\t\tt.Fatalf(\"expected TemporaryChannelFailure, got: %T\", msg)\n\t}\n\n\t// Now, settle all htlcs held by bob and clear the commitment of htlcs.\n\tfor _, preimage := range preimages {\n\t\tpreimage := preimage\n\n\t\t// It's possible that the HTLCs have not been delivered to the\n\t\t// invoice registry at this point, so we poll until we are able\n\t\t// to settle.\n\t\terr = wait.NoError(func() error {\n\t\t\treturn n.bobServer.registry.SettleHodlInvoice(preimage)\n\t\t}, time.Minute)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\t// Ensure that all of the payments sent by alice eventually succeed.\n\tfor errChan := range aliceErrChan {\n\t\terr := <-errChan\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"alice payment failed: %v\", err)\n\t\t}\n\t}\n}\n\n// TestExitNodeTimelockPayloadMismatch tests that when an exit node receives an\n// incoming HTLC, if the time lock encoded in the payload of the forwarded HTLC\n// doesn't match the expected payment value, then the HTLC will be rejected\n// with the appropriate error.",
      "length": 2695,
      "tokens": 372,
      "embedding": []
    },
    {
      "slug": "func TestExitNodeTimelockPayloadMismatch(t *testing.T) {",
      "content": "func TestExitNodeTimelockPayloadMismatch(t *testing.T) {\n\tt.Parallel()\n\n\tchannels, _, err := createClusterChannels(\n\t\tt, btcutil.SatoshiPerBitcoin*5, btcutil.SatoshiPerBitcoin*5,\n\t)\n\trequire.NoError(t, err, \"unable to create channel\")\n\n\tn := newThreeHopNetwork(t, channels.aliceToBob, channels.bobToAlice,\n\t\tchannels.bobToCarol, channels.carolToBob, testStartingHeight)\n\tif err := n.start(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Cleanup(n.stop)\n\n\tconst amount = btcutil.SatoshiPerBitcoin\n\thtlcAmt, htlcExpiry, hops := generateHops(amount,\n\t\ttestStartingHeight, n.firstBobChannelLink)\n\n\t// In order to exercise this case, we'll now _manually_ modify the\n\t// per-hop payload for outgoing time lock to be the incorrect value.\n\t// The proper value of the outgoing CLTV should be the policy set by\n\t// the receiving node, instead we set it to be a random value.\n\thops[0].FwdInfo.OutgoingCTLV = 500\n\tfirstHop := n.firstBobChannelLink.ShortChanID()\n\t_, err = makePayment(\n\t\tn.aliceServer, n.bobServer, firstHop, hops, amount, htlcAmt,\n\t\thtlcExpiry,\n\t).Wait(30 * time.Second)\n\tif err == nil {\n\t\tt.Fatalf(\"payment should have failed but didn't\")\n\t}\n\n\trtErr, ok := err.(ClearTextError)\n\tif !ok {\n\t\tt.Fatalf(\"expected a ClearTextError, instead got: %T\", err)\n\t}\n\n\tswitch rtErr.WireMessage().(type) {\n\tcase *lnwire.FailFinalIncorrectCltvExpiry:\n\tdefault:\n\t\tt.Fatalf(\"incorrect error, expected incorrect cltv expiry, \"+\n\t\t\t\"instead have: %v\", err)\n\t}\n}\n\n// TestExitNodeAmountPayloadMismatch tests that when an exit node receives an\n// incoming HTLC, if the amount encoded in the onion payload of the forwarded\n// HTLC doesn't match the expected payment value, then the HTLC will be\n// rejected.",
      "length": 1573,
      "tokens": 202,
      "embedding": []
    },
    {
      "slug": "func TestExitNodeAmountPayloadMismatch(t *testing.T) {",
      "content": "func TestExitNodeAmountPayloadMismatch(t *testing.T) {\n\tt.Parallel()\n\n\tchannels, _, err := createClusterChannels(\n\t\tt, btcutil.SatoshiPerBitcoin*5, btcutil.SatoshiPerBitcoin*5,\n\t)\n\trequire.NoError(t, err, \"unable to create channel\")\n\n\tn := newThreeHopNetwork(t, channels.aliceToBob, channels.bobToAlice,\n\t\tchannels.bobToCarol, channels.carolToBob, testStartingHeight)\n\tif err := n.start(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Cleanup(n.stop)\n\n\tconst amount = btcutil.SatoshiPerBitcoin\n\thtlcAmt, htlcExpiry, hops := generateHops(amount, testStartingHeight,\n\t\tn.firstBobChannelLink)\n\n\t// In order to exercise this case, we'll now _manually_ modify the\n\t// per-hop payload for amount to be the incorrect value.  The proper\n\t// value of the amount to forward should be the amount that the\n\t// receiving node expects to receive.\n\thops[0].FwdInfo.AmountToForward = 1\n\tfirstHop := n.firstBobChannelLink.ShortChanID()\n\t_, err = makePayment(\n\t\tn.aliceServer, n.bobServer, firstHop, hops, amount, htlcAmt,\n\t\thtlcExpiry,\n\t).Wait(30 * time.Second)\n\tif err == nil {\n\t\tt.Fatalf(\"payment should have failed but didn't\")\n\t}\n\tassertFailureCode(t, err, lnwire.CodeFinalIncorrectHtlcAmount)\n}\n\n// TestLinkForwardTimelockPolicyMismatch tests that if a node is an\n// intermediate node in a multi-hop payment, and receives an HTLC which\n// violates its specified multi-hop policy, then the HTLC is rejected.",
      "length": 1292,
      "tokens": 157,
      "embedding": []
    },
    {
      "slug": "func TestLinkForwardTimelockPolicyMismatch(t *testing.T) {",
      "content": "func TestLinkForwardTimelockPolicyMismatch(t *testing.T) {\n\tt.Parallel()\n\n\tchannels, _, err := createClusterChannels(\n\t\tt, btcutil.SatoshiPerBitcoin*5, btcutil.SatoshiPerBitcoin*5,\n\t)\n\trequire.NoError(t, err, \"unable to create channel\")\n\n\tn := newThreeHopNetwork(t, channels.aliceToBob, channels.bobToAlice,\n\t\tchannels.bobToCarol, channels.carolToBob, testStartingHeight)\n\tif err := n.start(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Cleanup(n.stop)\n\n\t// We'll be sending 1 BTC over a 2-hop (3 vertex) route.\n\tamount := lnwire.NewMSatFromSatoshis(btcutil.SatoshiPerBitcoin)\n\n\t// Generate the route over two hops, ignoring the total time lock that\n\t// we'll need to use for the first HTLC in order to have a sufficient\n\t// time-lock value to account for the decrements over the entire route.\n\thtlcAmt, htlcExpiry, hops := generateHops(amount, testStartingHeight,\n\t\tn.firstBobChannelLink, n.carolChannelLink)\n\thtlcExpiry -= 2\n\n\t// Next, we'll make the payment which'll send an HTLC with our\n\t// specified parameters to the first hop in the route.\n\tfirstHop := n.firstBobChannelLink.ShortChanID()\n\t_, err = makePayment(\n\t\tn.aliceServer, n.carolServer, firstHop, hops, amount, htlcAmt,\n\t\thtlcExpiry,\n\t).Wait(30 * time.Second)\n\n\t// We should get an error, and that error should indicate that the HTLC\n\t// should be rejected due to a policy violation.\n\tif err == nil {\n\t\tt.Fatalf(\"payment should have failed but didn't\")\n\t}\n\n\trtErr, ok := err.(ClearTextError)\n\tif !ok {\n\t\tt.Fatalf(\"expected a ClearTextError, instead got: %T\", err)\n\t}\n\n\tswitch rtErr.WireMessage().(type) {\n\tcase *lnwire.FailIncorrectCltvExpiry:\n\tdefault:\n\t\tt.Fatalf(\"incorrect error, expected incorrect cltv expiry, \"+\n\t\t\t\"instead have: %v\", err)\n\t}\n}\n\n// TestLinkForwardFeePolicyMismatch tests that if a node is an intermediate\n// node in a multi-hop payment and receives an HTLC that violates its current\n// fee policy, then the HTLC is rejected with the proper error.",
      "length": 1813,
      "tokens": 245,
      "embedding": []
    },
    {
      "slug": "func TestLinkForwardFeePolicyMismatch(t *testing.T) {",
      "content": "func TestLinkForwardFeePolicyMismatch(t *testing.T) {\n\tt.Parallel()\n\n\tchannels, _, err := createClusterChannels(\n\t\tt, btcutil.SatoshiPerBitcoin*3, btcutil.SatoshiPerBitcoin*5,\n\t)\n\trequire.NoError(t, err, \"unable to create channel\")\n\n\tn := newThreeHopNetwork(t, channels.aliceToBob, channels.bobToAlice,\n\t\tchannels.bobToCarol, channels.carolToBob, testStartingHeight)\n\tif err := n.start(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Cleanup(n.stop)\n\n\t// We'll be sending 1 BTC over a 2-hop (3 vertex) route. Given the\n\t// current default fee of 1 SAT, if we just send a single BTC over in\n\t// an HTLC, it should be rejected.\n\tamountNoFee := lnwire.NewMSatFromSatoshis(btcutil.SatoshiPerBitcoin)\n\n\t// Generate the route over two hops, ignoring the amount we _should_\n\t// actually send in order to be able to cover fees.\n\t_, htlcExpiry, hops := generateHops(amountNoFee, testStartingHeight,\n\t\tn.firstBobChannelLink, n.carolChannelLink)\n\n\t// Next, we'll make the payment which'll send an HTLC with our\n\t// specified parameters to the first hop in the route.\n\tfirstHop := n.firstBobChannelLink.ShortChanID()\n\t_, err = makePayment(\n\t\tn.aliceServer, n.bobServer, firstHop, hops, amountNoFee,\n\t\tamountNoFee, htlcExpiry,\n\t).Wait(30 * time.Second)\n\n\t// We should get an error, and that error should indicate that the HTLC\n\t// should be rejected due to a policy violation.\n\tif err == nil {\n\t\tt.Fatalf(\"payment should have failed but didn't\")\n\t}\n\n\trtErr, ok := err.(ClearTextError)\n\tif !ok {\n\t\tt.Fatalf(\"expected a ClearTextError, instead got: %T\", err)\n\t}\n\n\tswitch rtErr.WireMessage().(type) {\n\tcase *lnwire.FailFeeInsufficient:\n\tdefault:\n\t\tt.Fatalf(\"incorrect error, expected fee insufficient, \"+\n\t\t\t\"instead have: %T\", err)\n\t}\n}\n\n// TestLinkForwardFeePolicyMismatch tests that if a node is an intermediate\n// node and receives an HTLC which is _below_ its min HTLC policy, then the\n// HTLC will be rejected.",
      "length": 1782,
      "tokens": 243,
      "embedding": []
    },
    {
      "slug": "func TestLinkForwardMinHTLCPolicyMismatch(t *testing.T) {",
      "content": "func TestLinkForwardMinHTLCPolicyMismatch(t *testing.T) {\n\tt.Parallel()\n\n\tchannels, _, err := createClusterChannels(\n\t\tt, btcutil.SatoshiPerBitcoin*5, btcutil.SatoshiPerBitcoin*5,\n\t)\n\trequire.NoError(t, err, \"unable to create channel\")\n\n\tn := newThreeHopNetwork(t, channels.aliceToBob, channels.bobToAlice,\n\t\tchannels.bobToCarol, channels.carolToBob, testStartingHeight)\n\tif err := n.start(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Cleanup(n.stop)\n\n\t// The current default global min HTLC policy set in the default config\n\t// for the three-hop-network is 5 SAT. So in order to trigger this\n\t// failure mode, we'll create an HTLC with 1 satoshi.\n\tamountNoFee := lnwire.NewMSatFromSatoshis(1)\n\n\t// With the amount set, we'll generate a route over 2 hops within the\n\t// network that attempts to pay out our specified amount.\n\thtlcAmt, htlcExpiry, hops := generateHops(amountNoFee, testStartingHeight,\n\t\tn.firstBobChannelLink, n.carolChannelLink)\n\n\t// Next, we'll make the payment which'll send an HTLC with our\n\t// specified parameters to the first hop in the route.\n\tfirstHop := n.firstBobChannelLink.ShortChanID()\n\t_, err = makePayment(\n\t\tn.aliceServer, n.bobServer, firstHop, hops, amountNoFee,\n\t\thtlcAmt, htlcExpiry,\n\t).Wait(30 * time.Second)\n\n\t// We should get an error, and that error should indicate that the HTLC\n\t// should be rejected due to a policy violation (below min HTLC).\n\tif err == nil {\n\t\tt.Fatalf(\"payment should have failed but didn't\")\n\t}\n\n\trtErr, ok := err.(ClearTextError)\n\tif !ok {\n\t\tt.Fatalf(\"expected a ClearTextError, instead got: %T\", err)\n\t}\n\n\tswitch rtErr.WireMessage().(type) {\n\tcase *lnwire.FailAmountBelowMinimum:\n\tdefault:\n\t\tt.Fatalf(\"incorrect error, expected amount below minimum, \"+\n\t\t\t\"instead have: %v\", err)\n\t}\n}\n\n// TestLinkForwardMaxHTLCPolicyMismatch tests that if a node is an intermediate\n// node and receives an HTLC which is _above_ its max HTLC policy then the\n// HTLC will be rejected.",
      "length": 1815,
      "tokens": 247,
      "embedding": []
    },
    {
      "slug": "func TestLinkForwardMaxHTLCPolicyMismatch(t *testing.T) {",
      "content": "func TestLinkForwardMaxHTLCPolicyMismatch(t *testing.T) {\n\tt.Parallel()\n\n\tchannels, _, err := createClusterChannels(\n\t\tt, btcutil.SatoshiPerBitcoin*5, btcutil.SatoshiPerBitcoin*5,\n\t)\n\trequire.NoError(t, err, \"unable to create channel\")\n\n\tn := newThreeHopNetwork(\n\t\tt, channels.aliceToBob, channels.bobToAlice, channels.bobToCarol,\n\t\tchannels.carolToBob, testStartingHeight,\n\t)\n\tif err := n.start(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Cleanup(n.stop)\n\n\t// In order to trigger this failure mode, we'll update our policy to have\n\t// a new max HTLC of 10 satoshis.\n\tmaxHtlc := lnwire.NewMSatFromSatoshis(10)\n\n\t// First we'll generate a route over 2 hops within the network that\n\t// attempts to pay out an amount greater than the max HTLC we're about to\n\t// set.\n\tamountNoFee := maxHtlc + 1\n\thtlcAmt, htlcExpiry, hops := generateHops(\n\t\tamountNoFee, testStartingHeight, n.firstBobChannelLink,\n\t\tn.carolChannelLink,\n\t)\n\n\t// We'll now update Bob's policy to set the max HTLC we chose earlier.\n\tn.secondBobChannelLink.cfg.FwrdingPolicy.MaxHTLC = maxHtlc\n\n\t// Finally, we'll make the payment which'll send an HTLC with our\n\t// specified parameters.\n\tfirstHop := n.firstBobChannelLink.ShortChanID()\n\t_, err = makePayment(\n\t\tn.aliceServer, n.carolServer, firstHop, hops, amountNoFee,\n\t\thtlcAmt, htlcExpiry,\n\t).Wait(30 * time.Second)\n\n\t// We should get an error indicating a temporary channel failure, The\n\t// failure is temporary because this payment would be allowed if Bob\n\t// updated his policy to increase the max HTLC.\n\tif err == nil {\n\t\tt.Fatalf(\"payment should have failed but didn't\")\n\t}\n\n\trtErr, ok := err.(ClearTextError)\n\tif !ok {\n\t\tt.Fatalf(\"expected a ClearTextError, instead got: %T\", err)\n\t}\n\n\tswitch rtErr.WireMessage().(type) {\n\tcase *lnwire.FailTemporaryChannelFailure:\n\tdefault:\n\t\tt.Fatalf(\"incorrect error, expected temporary channel failure, \"+\n\t\t\t\"instead have: %v\", err)\n\t}\n}\n\n// TestUpdateForwardingPolicy tests that the forwarding policy for a link is\n// able to be updated properly. We'll first create an HTLC that meets the\n// specified policy, assert that it succeeds, update the policy (to invalidate\n// the prior HTLC), and then ensure that the HTLC is rejected.",
      "length": 2059,
      "tokens": 284,
      "embedding": []
    },
    {
      "slug": "func TestUpdateForwardingPolicy(t *testing.T) {",
      "content": "func TestUpdateForwardingPolicy(t *testing.T) {\n\tt.Parallel()\n\n\tchannels, _, err := createClusterChannels(\n\t\tt, btcutil.SatoshiPerBitcoin*5, btcutil.SatoshiPerBitcoin*5,\n\t)\n\trequire.NoError(t, err, \"unable to create channel\")\n\n\tn := newThreeHopNetwork(t, channels.aliceToBob, channels.bobToAlice,\n\t\tchannels.bobToCarol, channels.carolToBob, testStartingHeight)\n\tif err := n.start(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Cleanup(n.stop)\n\n\tcarolBandwidthBefore := n.carolChannelLink.Bandwidth()\n\tfirstBobBandwidthBefore := n.firstBobChannelLink.Bandwidth()\n\tsecondBobBandwidthBefore := n.secondBobChannelLink.Bandwidth()\n\taliceBandwidthBefore := n.aliceChannelLink.Bandwidth()\n\n\tamountNoFee := lnwire.NewMSatFromSatoshis(10)\n\thtlcAmt, htlcExpiry, hops := generateHops(amountNoFee,\n\t\ttestStartingHeight,\n\t\tn.firstBobChannelLink, n.carolChannelLink)\n\n\t// First, send this 10 mSAT payment over the three hops, the payment\n\t// should succeed, and all balances should be updated accordingly.\n\tfirstHop := n.firstBobChannelLink.ShortChanID()\n\tpayResp, err := makePayment(\n\t\tn.aliceServer, n.carolServer, firstHop, hops, amountNoFee,\n\t\thtlcAmt, htlcExpiry,\n\t).Wait(30 * time.Second)\n\trequire.NoError(t, err, \"unable to send payment\")\n\n\t// Carol's invoice should now be shown as settled as the payment\n\t// succeeded.\n\tinvoice, err := n.carolServer.registry.LookupInvoice(payResp)\n\trequire.NoError(t, err, \"unable to get invoice\")\n\tif invoice.State != invpkg.ContractSettled {\n\t\tt.Fatal(\"carol invoice haven't been settled\")\n\t}\n\n\texpectedAliceBandwidth := aliceBandwidthBefore - htlcAmt\n\tif expectedAliceBandwidth != n.aliceChannelLink.Bandwidth() {\n\t\tt.Fatalf(\"channel bandwidth incorrect: expected %v, got %v\",\n\t\t\texpectedAliceBandwidth, n.aliceChannelLink.Bandwidth())\n\t}\n\texpectedBobBandwidth1 := firstBobBandwidthBefore + htlcAmt\n\tif expectedBobBandwidth1 != n.firstBobChannelLink.Bandwidth() {\n\t\tt.Fatalf(\"channel bandwidth incorrect: expected %v, got %v\",\n\t\t\texpectedBobBandwidth1, n.firstBobChannelLink.Bandwidth())\n\t}\n\texpectedBobBandwidth2 := secondBobBandwidthBefore - amountNoFee\n\tif expectedBobBandwidth2 != n.secondBobChannelLink.Bandwidth() {\n\t\tt.Fatalf(\"channel bandwidth incorrect: expected %v, got %v\",\n\t\t\texpectedBobBandwidth2, n.secondBobChannelLink.Bandwidth())\n\t}\n\texpectedCarolBandwidth := carolBandwidthBefore + amountNoFee\n\tif expectedCarolBandwidth != n.carolChannelLink.Bandwidth() {\n\t\tt.Fatalf(\"channel bandwidth incorrect: expected %v, got %v\",\n\t\t\texpectedCarolBandwidth, n.carolChannelLink.Bandwidth())\n\t}\n\n\t// Now we'll update Bob's policy to jack up his free rate to an extent\n\t// that'll cause him to reject the same HTLC that we just sent.\n\t//\n\t// TODO(roasbeef): should implement grace period within link policy\n\t// update logic\n\tnewPolicy := n.globalPolicy\n\tnewPolicy.BaseFee = lnwire.NewMSatFromSatoshis(1000)\n\tn.secondBobChannelLink.UpdateForwardingPolicy(newPolicy)\n\n\t// Next, we'll send the payment again, using the exact same per-hop\n\t// payload for each node. This payment should fail as it won't factor\n\t// in Bob's new fee policy.\n\t_, err = makePayment(\n\t\tn.aliceServer, n.carolServer, firstHop, hops, amountNoFee,\n\t\thtlcAmt, htlcExpiry,\n\t).Wait(30 * time.Second)\n\tif err == nil {\n\t\tt.Fatalf(\"payment should've been rejected\")\n\t}\n\n\trtErr, ok := err.(ClearTextError)\n\tif !ok {\n\t\tt.Fatalf(\"expected a ClearTextError, instead got (%T): %v\", err, err)\n\t}\n\n\tswitch rtErr.WireMessage().(type) {\n\tcase *lnwire.FailFeeInsufficient:\n\tdefault:\n\t\tt.Fatalf(\"expected FailFeeInsufficient instead got: %v\", err)\n\t}\n\n\t// Reset the policy so we can then test updating the max HTLC policy.\n\tn.secondBobChannelLink.UpdateForwardingPolicy(n.globalPolicy)\n\n\t// As a sanity check, ensure the original payment now succeeds again.\n\t_, err = makePayment(\n\t\tn.aliceServer, n.carolServer, firstHop, hops, amountNoFee,\n\t\thtlcAmt, htlcExpiry,\n\t).Wait(30 * time.Second)\n\trequire.NoError(t, err, \"unable to send payment\")\n\n\t// Now we'll update Bob's policy to lower his max HTLC to an extent\n\t// that'll cause him to reject the same HTLC that we just sent.\n\tnewPolicy = n.globalPolicy\n\tnewPolicy.MaxHTLC = amountNoFee - 1\n\tn.secondBobChannelLink.UpdateForwardingPolicy(newPolicy)\n\n\t// Next, we'll send the payment again, using the exact same per-hop\n\t// payload for each node. This payment should fail as it won't factor\n\t// in Bob's new max HTLC policy.\n\t_, err = makePayment(\n\t\tn.aliceServer, n.carolServer, firstHop, hops, amountNoFee,\n\t\thtlcAmt, htlcExpiry,\n\t).Wait(30 * time.Second)\n\tif err == nil {\n\t\tt.Fatalf(\"payment should've been rejected\")\n\t}\n\n\trtErr, ok = err.(ClearTextError)\n\tif !ok {\n\t\tt.Fatalf(\"expected a ClearTextError, instead got (%T): %v\",\n\t\t\terr, err)\n\t}\n\n\tswitch rtErr.WireMessage().(type) {\n\tcase *lnwire.FailTemporaryChannelFailure:\n\tdefault:\n\t\tt.Fatalf(\"expected TemporaryChannelFailure, instead got: %v\",\n\t\t\terr)\n\t}\n}\n\n// TestChannelLinkMultiHopInsufficientPayment checks that we receive error if\n// bob<->alice channel has insufficient BTC capacity/bandwidth. In this test we\n// send the payment from Carol to Alice over Bob peer. (Carol -> Bob -> Alice)",
      "length": 4898,
      "tokens": 557,
      "embedding": []
    },
    {
      "slug": "func TestChannelLinkMultiHopInsufficientPayment(t *testing.T) {",
      "content": "func TestChannelLinkMultiHopInsufficientPayment(t *testing.T) {\n\tt.Parallel()\n\n\tchannels, _, err := createClusterChannels(\n\t\tt, btcutil.SatoshiPerBitcoin*3, btcutil.SatoshiPerBitcoin*5,\n\t)\n\trequire.NoError(t, err, \"unable to create channel\")\n\n\tn := newThreeHopNetwork(t, channels.aliceToBob, channels.bobToAlice,\n\t\tchannels.bobToCarol, channels.carolToBob, testStartingHeight)\n\tif err := n.start(); err != nil {\n\t\tt.Fatalf(\"unable to start three hop network: %v\", err)\n\t}\n\tt.Cleanup(n.stop)\n\n\tcarolBandwidthBefore := n.carolChannelLink.Bandwidth()\n\tfirstBobBandwidthBefore := n.firstBobChannelLink.Bandwidth()\n\tsecondBobBandwidthBefore := n.secondBobChannelLink.Bandwidth()\n\taliceBandwidthBefore := n.aliceChannelLink.Bandwidth()\n\n\t// We'll attempt to send 4 BTC although the alice-to-bob channel only\n\t// has 3 BTC total capacity. As a result, this payment should be\n\t// rejected.\n\tamount := lnwire.NewMSatFromSatoshis(4 * btcutil.SatoshiPerBitcoin)\n\thtlcAmt, totalTimelock, hops := generateHops(amount, testStartingHeight,\n\t\tn.firstBobChannelLink, n.carolChannelLink)\n\n\t// Wait for:\n\t// * HTLC add request to be sent to from Alice to Bob.\n\t// * Alice<->Bob commitment states to be updated.\n\t// * Bob trying to add HTLC add request in Bob<->Carol channel.\n\t// * Cancel HTLC request to be sent back from Bob to Alice.\n\t// * user notification to be sent.\n\n\treceiver := n.carolServer\n\tfirstHop := n.firstBobChannelLink.ShortChanID()\n\trhash, err := makePayment(\n\t\tn.aliceServer, n.carolServer, firstHop, hops, amount, htlcAmt,\n\t\ttotalTimelock,\n\t).Wait(30 * time.Second)\n\tif err == nil {\n\t\tt.Fatal(\"error haven't been received\")\n\t}\n\tassertFailureCode(t, err, lnwire.CodeTemporaryChannelFailure)\n\n\t// Wait for Alice to receive the revocation.\n\t//\n\t// TODO(roasbeef): add in ntfn hook for state transition completion\n\ttime.Sleep(100 * time.Millisecond)\n\n\t// Check that alice invoice wasn't settled and bandwidth of htlc\n\t// links hasn't been changed.\n\tinvoice, err := receiver.registry.LookupInvoice(rhash)\n\trequire.NoError(t, err, \"unable to get invoice\")\n\tif invoice.State == invpkg.ContractSettled {\n\t\tt.Fatal(\"carol invoice have been settled\")\n\t}\n\n\tif n.aliceChannelLink.Bandwidth() != aliceBandwidthBefore {\n\t\tt.Fatal(\"the bandwidth of alice channel link which handles \" +\n\t\t\t\"alice->bob channel should be the same\")\n\t}\n\n\tif n.firstBobChannelLink.Bandwidth() != firstBobBandwidthBefore {\n\t\tt.Fatal(\"the bandwidth of bob channel link which handles \" +\n\t\t\t\"alice->bob channel should be the same\")\n\t}\n\n\tif n.secondBobChannelLink.Bandwidth() != secondBobBandwidthBefore {\n\t\tt.Fatal(\"the bandwidth of bob channel link which handles \" +\n\t\t\t\"bob->carol channel should be the same\")\n\t}\n\n\tif n.carolChannelLink.Bandwidth() != carolBandwidthBefore {\n\t\tt.Fatal(\"the bandwidth of carol channel link which handles \" +\n\t\t\t\"bob->carol channel should be the same\")\n\t}\n}\n\n// TestChannelLinkMultiHopUnknownPaymentHash checks that we receive remote error\n// from Alice if she received not suitable payment hash for htlc.",
      "length": 2857,
      "tokens": 351,
      "embedding": []
    },
    {
      "slug": "func TestChannelLinkMultiHopUnknownPaymentHash(t *testing.T) {",
      "content": "func TestChannelLinkMultiHopUnknownPaymentHash(t *testing.T) {\n\tt.Parallel()\n\n\tchannels, _, err := createClusterChannels(\n\t\tt, btcutil.SatoshiPerBitcoin*5, btcutil.SatoshiPerBitcoin*5,\n\t)\n\trequire.NoError(t, err, \"unable to create channel\")\n\n\tn := newThreeHopNetwork(t, channels.aliceToBob, channels.bobToAlice,\n\t\tchannels.bobToCarol, channels.carolToBob, testStartingHeight)\n\tif err := n.start(); err != nil {\n\t\tt.Fatalf(\"unable to start three hop network: %v\", err)\n\t}\n\tt.Cleanup(n.stop)\n\n\tcarolBandwidthBefore := n.carolChannelLink.Bandwidth()\n\tfirstBobBandwidthBefore := n.firstBobChannelLink.Bandwidth()\n\tsecondBobBandwidthBefore := n.secondBobChannelLink.Bandwidth()\n\taliceBandwidthBefore := n.aliceChannelLink.Bandwidth()\n\n\tamount := lnwire.NewMSatFromSatoshis(btcutil.SatoshiPerBitcoin)\n\n\thtlcAmt, totalTimelock, hops := generateHops(amount, testStartingHeight,\n\t\tn.firstBobChannelLink, n.carolChannelLink)\n\tblob, err := generateRoute(hops...)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Generate payment invoice and htlc, but don't add this invoice to the\n\t// receiver registry. This should trigger an unknown payment hash\n\t// failure.\n\t_, htlc, pid, err := generatePayment(\n\t\tamount, htlcAmt, totalTimelock, blob,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Send payment and expose err channel.\n\terr = n.aliceServer.htlcSwitch.SendHTLC(\n\t\tn.firstBobChannelLink.ShortChanID(), pid, htlc,\n\t)\n\trequire.NoError(t, err, \"unable to get send payment\")\n\n\tresultChan, err := n.aliceServer.htlcSwitch.GetAttemptResult(\n\t\tpid, htlc.PaymentHash, newMockDeobfuscator(),\n\t)\n\trequire.NoError(t, err, \"unable to get payment result\")\n\n\tvar result *PaymentResult\n\tvar ok bool\n\tselect {\n\n\tcase result, ok = <-resultChan:\n\t\tif !ok {\n\t\t\tt.Fatalf(\"unexpected shutdown\")\n\t\t}\n\tcase <-time.After(10 * time.Second):\n\t\tt.Fatalf(\"no result arrive\")\n\t}\n\n\tassertFailureCode(\n\t\tt, result.Error, lnwire.CodeIncorrectOrUnknownPaymentDetails,\n\t)\n\n\t// Wait for Alice to receive the revocation.\n\trequire.Eventually(t, func() bool {\n\t\tif n.aliceChannelLink.Bandwidth() != aliceBandwidthBefore {\n\t\t\treturn false\n\t\t}\n\n\t\tif n.firstBobChannelLink.Bandwidth() != firstBobBandwidthBefore {\n\t\t\treturn false\n\t\t}\n\n\t\tif n.secondBobChannelLink.Bandwidth() != secondBobBandwidthBefore {\n\t\t\treturn false\n\t\t}\n\n\t\tif n.carolChannelLink.Bandwidth() != carolBandwidthBefore {\n\t\t\treturn false\n\t\t}\n\n\t\treturn true\n\t}, 10*time.Second, 100*time.Millisecond)\n}\n\n// TestChannelLinkMultiHopUnknownNextHop construct the chain of hops\n// Carol<->Bob<->Alice and checks that we receive remote error from Bob if he\n// has no idea about next hop (hop might goes down and routing info not updated\n// yet).",
      "length": 2488,
      "tokens": 275,
      "embedding": []
    },
    {
      "slug": "func TestChannelLinkMultiHopUnknownNextHop(t *testing.T) {",
      "content": "func TestChannelLinkMultiHopUnknownNextHop(t *testing.T) {\n\tt.Parallel()\n\n\tchannels, _, err := createClusterChannels(\n\t\tt, btcutil.SatoshiPerBitcoin*5, btcutil.SatoshiPerBitcoin*5,\n\t)\n\trequire.NoError(t, err, \"unable to create channel\")\n\n\tn := newThreeHopNetwork(t, channels.aliceToBob, channels.bobToAlice,\n\t\tchannels.bobToCarol, channels.carolToBob, testStartingHeight)\n\tif err := n.start(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Cleanup(n.stop)\n\n\tcarolBandwidthBefore := n.carolChannelLink.Bandwidth()\n\tfirstBobBandwidthBefore := n.firstBobChannelLink.Bandwidth()\n\tsecondBobBandwidthBefore := n.secondBobChannelLink.Bandwidth()\n\taliceBandwidthBefore := n.aliceChannelLink.Bandwidth()\n\n\tamount := lnwire.NewMSatFromSatoshis(btcutil.SatoshiPerBitcoin)\n\thtlcAmt, totalTimelock, hops := generateHops(amount, testStartingHeight,\n\t\tn.firstBobChannelLink, n.carolChannelLink)\n\n\t// Remove bob's outgoing link with Carol. This will cause him to fail\n\t// back the payment to Alice since he is unaware of Carol when the\n\t// payment comes across.\n\tbobChanID := lnwire.NewChanIDFromOutPoint(\n\t\t&channels.bobToCarol.State().FundingOutpoint,\n\t)\n\tn.bobServer.htlcSwitch.RemoveLink(bobChanID)\n\n\tfirstHop := n.firstBobChannelLink.ShortChanID()\n\treceiver := n.carolServer\n\trhash, err := makePayment(\n\t\tn.aliceServer, receiver, firstHop, hops, amount, htlcAmt,\n\t\ttotalTimelock).Wait(30 * time.Second)\n\tif err == nil {\n\t\tt.Fatal(\"error haven't been received\")\n\t}\n\trtErr, ok := err.(ClearTextError)\n\tif !ok {\n\t\tt.Fatalf(\"expected ClearTextError\")\n\t}\n\n\tif _, ok = rtErr.WireMessage().(*lnwire.FailUnknownNextPeer); !ok {\n\t\tt.Fatalf(\"wrong error has been received: %T\",\n\t\t\trtErr.WireMessage())\n\t}\n\n\t// Wait for Alice to receive the revocation.\n\t//\n\t// TODO(roasbeef): add in ntfn hook for state transition completion\n\ttime.Sleep(100 * time.Millisecond)\n\n\t// Check that alice invoice wasn't settled and bandwidth of htlc\n\t// links hasn't been changed.\n\tinvoice, err := receiver.registry.LookupInvoice(rhash)\n\trequire.NoError(t, err, \"unable to get invoice\")\n\tif invoice.State == invpkg.ContractSettled {\n\t\tt.Fatal(\"carol invoice have been settled\")\n\t}\n\n\tif n.aliceChannelLink.Bandwidth() != aliceBandwidthBefore {\n\t\tt.Fatal(\"the bandwidth of alice channel link which handles \" +\n\t\t\t\"alice->bob channel should be the same\")\n\t}\n\n\tif n.firstBobChannelLink.Bandwidth() != firstBobBandwidthBefore {\n\t\tt.Fatal(\"the bandwidth of bob channel link which handles \" +\n\t\t\t\"alice->bob channel should be the same\")\n\t}\n\n\tif n.secondBobChannelLink.Bandwidth() != secondBobBandwidthBefore {\n\t\tt.Fatal(\"the bandwidth of bob channel link which handles \" +\n\t\t\t\"bob->carol channel should be the same\")\n\t}\n\n\tif n.carolChannelLink.Bandwidth() != carolBandwidthBefore {\n\t\tt.Fatal(\"the bandwidth of carol channel link which handles \" +\n\t\t\t\"bob->carol channel should be the same\")\n\t}\n\n\t// Load the forwarding packages for Bob's incoming link. The payment\n\t// should have been rejected by the switch, and the AddRef in this link\n\t// should be acked by the failed payment.\n\tbobInFwdPkgs, err := channels.bobToAlice.State().LoadFwdPkgs()\n\trequire.NoError(t, err, \"unable to load bob's fwd pkgs\")\n\n\t// There should be exactly two forward packages, as a full state\n\t// transition requires two commitment dances.\n\tif len(bobInFwdPkgs) != 2 {\n\t\tt.Fatalf(\"bob should have exactly 2 fwdpkgs, has %d\",\n\t\t\tlen(bobInFwdPkgs))\n\t}\n\n\t// Only one of the forwarding package should have an Add in it, the\n\t// other will be empty. Either way, both AckFilters should be fully\n\t// acked.\n\tfor _, fwdPkg := range bobInFwdPkgs {\n\t\tif !fwdPkg.AckFilter.IsFull() {\n\t\t\tt.Fatalf(\"fwdpkg chanid=%v height=%d AckFilter is not \"+\n\t\t\t\t\"fully acked\", fwdPkg.Source, fwdPkg.Height)\n\t\t}\n\t}\n}\n\n// TestChannelLinkMultiHopDecodeError checks that we send HTLC cancel if\n// decoding of onion blob failed.",
      "length": 3647,
      "tokens": 441,
      "embedding": []
    },
    {
      "slug": "func TestChannelLinkMultiHopDecodeError(t *testing.T) {",
      "content": "func TestChannelLinkMultiHopDecodeError(t *testing.T) {\n\tt.Parallel()\n\n\tchannels, _, err := createClusterChannels(\n\t\tt, btcutil.SatoshiPerBitcoin*3, btcutil.SatoshiPerBitcoin*5,\n\t)\n\trequire.NoError(t, err, \"unable to create channel\")\n\n\tn := newThreeHopNetwork(t, channels.aliceToBob, channels.bobToAlice,\n\t\tchannels.bobToCarol, channels.carolToBob, testStartingHeight)\n\tif err := n.start(); err != nil {\n\t\tt.Fatalf(\"unable to start three hop network: %v\", err)\n\t}\n\tt.Cleanup(n.stop)\n\n\t// Replace decode function with another which throws an error.\n\tn.carolChannelLink.cfg.ExtractErrorEncrypter = func(\n\t\t*btcec.PublicKey) (hop.ErrorEncrypter, lnwire.FailCode) {\n\t\treturn nil, lnwire.CodeInvalidOnionVersion\n\t}\n\n\tcarolBandwidthBefore := n.carolChannelLink.Bandwidth()\n\tfirstBobBandwidthBefore := n.firstBobChannelLink.Bandwidth()\n\tsecondBobBandwidthBefore := n.secondBobChannelLink.Bandwidth()\n\taliceBandwidthBefore := n.aliceChannelLink.Bandwidth()\n\n\tamount := lnwire.NewMSatFromSatoshis(btcutil.SatoshiPerBitcoin)\n\thtlcAmt, totalTimelock, hops := generateHops(amount, testStartingHeight,\n\t\tn.firstBobChannelLink, n.carolChannelLink)\n\n\treceiver := n.carolServer\n\tfirstHop := n.firstBobChannelLink.ShortChanID()\n\trhash, err := makePayment(\n\t\tn.aliceServer, n.carolServer, firstHop, hops, amount, htlcAmt,\n\t\ttotalTimelock,\n\t).Wait(30 * time.Second)\n\tif err == nil {\n\t\tt.Fatal(\"error haven't been received\")\n\t}\n\n\trtErr, ok := err.(ClearTextError)\n\tif !ok {\n\t\tt.Fatalf(\"expected a ClearTextError, instead got: %T\", err)\n\t}\n\n\tswitch rtErr.WireMessage().(type) {\n\tcase *lnwire.FailInvalidOnionVersion:\n\tdefault:\n\t\tt.Fatalf(\"wrong error have been received: %v\", err)\n\t}\n\n\t// Wait for Bob to receive the revocation.\n\ttime.Sleep(100 * time.Millisecond)\n\n\t// Check that alice invoice wasn't settled and bandwidth of htlc\n\t// links hasn't been changed.\n\tinvoice, err := receiver.registry.LookupInvoice(rhash)\n\trequire.NoError(t, err, \"unable to get invoice\")\n\tif invoice.State == invpkg.ContractSettled {\n\t\tt.Fatal(\"carol invoice have been settled\")\n\t}\n\n\tif n.aliceChannelLink.Bandwidth() != aliceBandwidthBefore {\n\t\tt.Fatal(\"the bandwidth of alice channel link which handles \" +\n\t\t\t\"alice->bob channel should be the same\")\n\t}\n\n\tif n.firstBobChannelLink.Bandwidth() != firstBobBandwidthBefore {\n\t\tt.Fatal(\"the bandwidth of bob channel link which handles \" +\n\t\t\t\"alice->bob channel should be the same\")\n\t}\n\n\tif n.secondBobChannelLink.Bandwidth() != secondBobBandwidthBefore {\n\t\tt.Fatal(\"the bandwidth of bob channel link which handles \" +\n\t\t\t\"bob->carol channel should be the same\")\n\t}\n\n\tif n.carolChannelLink.Bandwidth() != carolBandwidthBefore {\n\t\tt.Fatal(\"the bandwidth of carol channel link which handles \" +\n\t\t\t\"bob->carol channel should be the same\")\n\t}\n}\n\n// TestChannelLinkExpiryTooSoonExitNode tests that if we send an HTLC to a node\n// with an expiry that is already expired, or too close to the current block\n// height, then it will cancel the HTLC.",
      "length": 2808,
      "tokens": 317,
      "embedding": []
    },
    {
      "slug": "func TestChannelLinkExpiryTooSoonExitNode(t *testing.T) {",
      "content": "func TestChannelLinkExpiryTooSoonExitNode(t *testing.T) {\n\tt.Parallel()\n\n\t// The starting height for this test will be 200. So we'll base all\n\t// HTLC starting points off of that.\n\tchannels, _, err := createClusterChannels(\n\t\tt, btcutil.SatoshiPerBitcoin*3, btcutil.SatoshiPerBitcoin*5,\n\t)\n\trequire.NoError(t, err, \"unable to create channel\")\n\n\tconst startingHeight = 200\n\tn := newThreeHopNetwork(t, channels.aliceToBob, channels.bobToAlice,\n\t\tchannels.bobToCarol, channels.carolToBob, startingHeight)\n\tif err := n.start(); err != nil {\n\t\tt.Fatalf(\"unable to start three hop network: %v\", err)\n\t}\n\tt.Cleanup(n.stop)\n\n\tamount := lnwire.NewMSatFromSatoshis(btcutil.SatoshiPerBitcoin)\n\n\t// We'll craft an HTLC packet, but set the final hop CLTV to 5 blocks\n\t// after the current true height. This is less than the test invoice\n\t// cltv delta of 6, so we expect the incoming htlc to be failed by the\n\t// exit hop.\n\thtlcAmt, totalTimelock, hops := generateHops(amount,\n\t\tstartingHeight-1, n.firstBobChannelLink)\n\n\t// Now we'll send out the payment from Alice to Bob.\n\tfirstHop := n.firstBobChannelLink.ShortChanID()\n\t_, err = makePayment(\n\t\tn.aliceServer, n.bobServer, firstHop, hops, amount, htlcAmt,\n\t\ttotalTimelock,\n\t).Wait(30 * time.Second)\n\n\t// The payment should've failed as the time lock value was in the\n\t// _past_.\n\tif err == nil {\n\t\tt.Fatalf(\"payment should have failed due to a too early \" +\n\t\t\t\"time lock value\")\n\t}\n\n\trtErr, ok := err.(ClearTextError)\n\tif !ok {\n\t\tt.Fatalf(\"expected a ClearTextError, instead got: %T %v\",\n\t\t\trtErr, err)\n\t}\n\n\tswitch rtErr.WireMessage().(type) {\n\tcase *lnwire.FailIncorrectDetails:\n\tdefault:\n\t\tt.Fatalf(\"expected incorrect_or_unknown_payment_details, \"+\n\t\t\t\"instead have: %v\", err)\n\t}\n}\n\n// TestChannelLinkExpiryTooSoonExitNode tests that if we send a multi-hop HTLC,\n// and the time lock is too early for an intermediate node, then they cancel\n// the HTLC back to the sender.",
      "length": 1802,
      "tokens": 251,
      "embedding": []
    },
    {
      "slug": "func TestChannelLinkExpiryTooSoonMidNode(t *testing.T) {",
      "content": "func TestChannelLinkExpiryTooSoonMidNode(t *testing.T) {\n\tt.Parallel()\n\n\t// The starting height for this test will be 200. So we'll base all\n\t// HTLC starting points off of that.\n\tchannels, _, err := createClusterChannels(\n\t\tt, btcutil.SatoshiPerBitcoin*3, btcutil.SatoshiPerBitcoin*5,\n\t)\n\trequire.NoError(t, err, \"unable to create channel\")\n\n\tconst startingHeight = 200\n\tn := newThreeHopNetwork(t, channels.aliceToBob, channels.bobToAlice,\n\t\tchannels.bobToCarol, channels.carolToBob, startingHeight)\n\tif err := n.start(); err != nil {\n\t\tt.Fatalf(\"unable to start three hop network: %v\", err)\n\t}\n\tt.Cleanup(n.stop)\n\n\tamount := lnwire.NewMSatFromSatoshis(btcutil.SatoshiPerBitcoin)\n\n\t// We'll craft an HTLC packet, but set the starting height to 3 blocks\n\t// before the current true height. This means that the outgoing time\n\t// lock of the middle hop will be at starting height + 3 blocks (channel\n\t// policy time lock delta is 6 blocks). There is an expiry grace delta\n\t// of 3 blocks relative to the current height, meaning that htlc will\n\t// not be sent out by the middle hop.\n\thtlcAmt, totalTimelock, hops := generateHops(amount,\n\t\tstartingHeight-3, n.firstBobChannelLink, n.carolChannelLink)\n\n\t// Now we'll send out the payment from Alice to Bob.\n\tfirstHop := n.firstBobChannelLink.ShortChanID()\n\t_, err = makePayment(\n\t\tn.aliceServer, n.bobServer, firstHop, hops, amount, htlcAmt,\n\t\ttotalTimelock,\n\t).Wait(30 * time.Second)\n\n\t// The payment should've failed as the time lock value was in the\n\t// _past_.\n\tif err == nil {\n\t\tt.Fatalf(\"payment should have failed due to a too early \" +\n\t\t\t\"time lock value\")\n\t}\n\n\trtErr, ok := err.(ClearTextError)\n\tif !ok {\n\t\tt.Fatalf(\"expected a ClearTextError, instead got: %T: %v\",\n\t\t\trtErr, err)\n\t}\n\n\tswitch rtErr.WireMessage().(type) {\n\tcase *lnwire.FailExpiryTooSoon:\n\tdefault:\n\t\tt.Fatalf(\"incorrect error, expected final time lock too \"+\n\t\t\t\"early, instead have: %v\", err)\n\t}\n}\n\n// TestChannelLinkSingleHopMessageOrdering test checks ordering of message which\n// flying around between Alice and Bob are correct when Bob sends payments to\n// Alice.",
      "length": 1975,
      "tokens": 280,
      "embedding": []
    },
    {
      "slug": "func TestChannelLinkSingleHopMessageOrdering(t *testing.T) {",
      "content": "func TestChannelLinkSingleHopMessageOrdering(t *testing.T) {\n\tt.Parallel()\n\n\tchannels, _, err := createClusterChannels(\n\t\tt, btcutil.SatoshiPerBitcoin*3, btcutil.SatoshiPerBitcoin*5,\n\t)\n\trequire.NoError(t, err, \"unable to create channel\")\n\n\tn := newThreeHopNetwork(t, channels.aliceToBob, channels.bobToAlice,\n\t\tchannels.bobToCarol, channels.carolToBob, testStartingHeight)\n\n\tchanID := n.aliceChannelLink.ChanID()\n\n\tmessages := []expectedMessage{\n\t\t{\"alice\", \"bob\", &lnwire.ChannelReestablish{}, false},\n\t\t{\"bob\", \"alice\", &lnwire.ChannelReestablish{}, false},\n\n\t\t{\"alice\", \"bob\", &lnwire.FundingLocked{}, false},\n\t\t{\"bob\", \"alice\", &lnwire.FundingLocked{}, false},\n\n\t\t{\"alice\", \"bob\", &lnwire.UpdateAddHTLC{}, false},\n\t\t{\"alice\", \"bob\", &lnwire.CommitSig{}, false},\n\t\t{\"bob\", \"alice\", &lnwire.RevokeAndAck{}, false},\n\t\t{\"bob\", \"alice\", &lnwire.CommitSig{}, false},\n\t\t{\"alice\", \"bob\", &lnwire.RevokeAndAck{}, false},\n\n\t\t{\"bob\", \"alice\", &lnwire.UpdateFulfillHTLC{}, false},\n\t\t{\"bob\", \"alice\", &lnwire.CommitSig{}, false},\n\t\t{\"alice\", \"bob\", &lnwire.RevokeAndAck{}, false},\n\t\t{\"alice\", \"bob\", &lnwire.CommitSig{}, false},\n\t\t{\"bob\", \"alice\", &lnwire.RevokeAndAck{}, false},\n\t}\n\n\tdebug := false\n\tif debug {\n\t\t// Log message that alice receives.\n\t\tn.aliceServer.intersect(createLogFunc(\"alice\",\n\t\t\tn.aliceChannelLink.ChanID()))\n\n\t\t// Log message that bob receives.\n\t\tn.bobServer.intersect(createLogFunc(\"bob\",\n\t\t\tn.firstBobChannelLink.ChanID()))\n\t}\n\n\t// Check that alice receives messages in right order.\n\tn.aliceServer.intersect(createInterceptorFunc(\"[alice] <-- [bob]\",\n\t\t\"alice\", messages, chanID, false))\n\n\t// Check that bob receives messages in right order.\n\tn.bobServer.intersect(createInterceptorFunc(\"[alice] --> [bob]\",\n\t\t\"bob\", messages, chanID, false))\n\n\tif err := n.start(); err != nil {\n\t\tt.Fatalf(\"unable to start three hop network: %v\", err)\n\t}\n\tt.Cleanup(n.stop)\n\n\tamount := lnwire.NewMSatFromSatoshis(btcutil.SatoshiPerBitcoin)\n\thtlcAmt, totalTimelock, hops := generateHops(amount, testStartingHeight,\n\t\tn.firstBobChannelLink)\n\n\t// Wait for:\n\t// * HTLC add request to be sent to bob.\n\t// * alice<->bob commitment state to be updated.\n\t// * settle request to be sent back from bob to alice.\n\t// * alice<->bob commitment state to be updated.\n\t// * user notification to be sent.\n\tfirstHop := n.firstBobChannelLink.ShortChanID()\n\t_, err = makePayment(\n\t\tn.aliceServer, n.bobServer, firstHop, hops, amount, htlcAmt,\n\t\ttotalTimelock,\n\t).Wait(30 * time.Second)\n\trequire.NoError(t, err, \"unable to make the payment\")\n}\n",
      "length": 2391,
      "tokens": 243,
      "embedding": []
    },
    {
      "slug": "type mockPeer struct {",
      "content": "type mockPeer struct {\n\tsync.Mutex\n\tdisconnected bool\n\tsentMsgs     chan lnwire.Message\n\tquit         chan struct{}\n}\n",
      "length": 90,
      "tokens": 10,
      "embedding": []
    },
    {
      "slug": "func (m *mockPeer) QuitSignal() <-chan struct{} {",
      "content": "func (m *mockPeer) QuitSignal() <-chan struct{} {\n\treturn m.quit\n}\n\nvar _ lnpeer.Peer = (*mockPeer)(nil)\n",
      "length": 51,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (m *mockPeer) SendMessage(sync bool, msgs ...lnwire.Message) error {",
      "content": "func (m *mockPeer) SendMessage(sync bool, msgs ...lnwire.Message) error {\n\tif m.disconnected {\n\t\treturn fmt.Errorf(\"disconnected\")\n\t}\n\n\tselect {\n\tcase m.sentMsgs <- msgs[0]:\n\tcase <-m.quit:\n\t\treturn fmt.Errorf(\"mockPeer shutting down\")\n\t}\n\treturn nil\n}",
      "length": 168,
      "tokens": 22,
      "embedding": []
    },
    {
      "slug": "func (m *mockPeer) SendMessageLazy(sync bool, msgs ...lnwire.Message) error {",
      "content": "func (m *mockPeer) SendMessageLazy(sync bool, msgs ...lnwire.Message) error {\n\treturn m.SendMessage(sync, msgs...)\n}",
      "length": 37,
      "tokens": 4,
      "embedding": []
    },
    {
      "slug": "func (m *mockPeer) AddNewChannel(_ *channeldb.OpenChannel,",
      "content": "func (m *mockPeer) AddNewChannel(_ *channeldb.OpenChannel,\n\t_ <-chan struct{}) error {\n\treturn nil\n}",
      "length": 39,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (m *mockPeer) WipeChannel(*wire.OutPoint) {}",
      "content": "func (m *mockPeer) WipeChannel(*wire.OutPoint) {}",
      "length": 0,
      "tokens": 0,
      "embedding": []
    },
    {
      "slug": "func (m *mockPeer) PubKey() [33]byte {",
      "content": "func (m *mockPeer) PubKey() [33]byte {\n\treturn [33]byte{}\n}",
      "length": 19,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (m *mockPeer) IdentityKey() *btcec.PublicKey {",
      "content": "func (m *mockPeer) IdentityKey() *btcec.PublicKey {\n\treturn nil\n}",
      "length": 12,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (m *mockPeer) Address() net.Addr {",
      "content": "func (m *mockPeer) Address() net.Addr {\n\treturn nil\n}",
      "length": 12,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (m *mockPeer) LocalFeatures() *lnwire.FeatureVector {",
      "content": "func (m *mockPeer) LocalFeatures() *lnwire.FeatureVector {\n\treturn nil\n}",
      "length": 12,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (m *mockPeer) RemoteFeatures() *lnwire.FeatureVector {",
      "content": "func (m *mockPeer) RemoteFeatures() *lnwire.FeatureVector {\n\treturn nil\n}\n",
      "length": 12,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func newSingleLinkTestHarness(t *testing.T, chanAmt, chanReserve btcutil.Amount) (",
      "content": "func newSingleLinkTestHarness(t *testing.T, chanAmt, chanReserve btcutil.Amount) (\n\tChannelLink, *lnwallet.LightningChannel, chan time.Time, func() error,\n\tfunc() (*lnwallet.LightningChannel, error), error) {\n\n\tvar chanIDBytes [8]byte\n\tif _, err := io.ReadFull(rand.Reader, chanIDBytes[:]); err != nil {\n\t\treturn nil, nil, nil, nil, nil, err\n\t}\n\n\tchanID := lnwire.NewShortChanIDFromInt(\n\t\tbinary.BigEndian.Uint64(chanIDBytes[:]))\n\n\taliceLc, bobLc, err := createTestChannel(\n\t\tt, alicePrivKey, bobPrivKey, chanAmt, chanAmt,\n\t\tchanReserve, chanReserve, chanID,\n\t)\n\tif err != nil {\n\t\treturn nil, nil, nil, nil, nil, err\n\t}\n\n\tvar (\n\t\tdecoder    = newMockIteratorDecoder()\n\t\tobfuscator = NewMockObfuscator()\n\t\talicePeer  = &mockPeer{\n\t\t\tsentMsgs: make(chan lnwire.Message, 2000),\n\t\t\tquit:     make(chan struct{}),\n\t\t}\n\t\tglobalPolicy = ForwardingPolicy{\n\t\t\tMinHTLCOut:    lnwire.NewMSatFromSatoshis(5),\n\t\t\tMaxHTLC:       lnwire.NewMSatFromSatoshis(chanAmt),\n\t\t\tBaseFee:       lnwire.NewMSatFromSatoshis(1),\n\t\t\tTimeLockDelta: 6,\n\t\t}\n\t\tinvoiceRegistry = newMockRegistry(globalPolicy.TimeLockDelta)\n\t)\n\n\tpCache := newMockPreimageCache()\n\n\taliceDb := aliceLc.channel.State().Db.GetParentDB()\n\taliceSwitch, err := initSwitchWithDB(testStartingHeight, aliceDb)\n\tif err != nil {\n\t\treturn nil, nil, nil, nil, nil, err\n\t}\n\n\tnotifyUpdateChan := make(chan *contractcourt.ContractUpdate)\n\tdoneChan := make(chan struct{})\n\tnotifyContractUpdate := func(u *contractcourt.ContractUpdate) error {\n\t\tselect {\n\t\tcase notifyUpdateChan <- u:\n\t\tcase <-doneChan:\n\t\t}\n\n\t\treturn nil\n\t}\n\n\tgetAliases := func(\n\t\tbase lnwire.ShortChannelID) []lnwire.ShortChannelID {\n\n\t\treturn nil\n\t}\n\n\t// Instantiate with a long interval, so that we can precisely control\n\t// the firing via force feeding.\n\tbticker := ticker.NewForce(time.Hour)\n\taliceCfg := ChannelLinkConfig{\n\t\tFwrdingPolicy: globalPolicy,\n\t\tPeer:          alicePeer,\n\t\tSwitch:        aliceSwitch,\n\t\tBestHeight:    aliceSwitch.BestHeight,\n\t\tCircuits:      aliceSwitch.CircuitModifier(),\n\t\tForwardPackets: func(linkQuit chan struct{}, _ bool, packets ...*htlcPacket) error {\n\t\t\treturn aliceSwitch.ForwardPackets(linkQuit, packets...)\n\t\t},\n\t\tDecodeHopIterators: decoder.DecodeHopIterators,\n\t\tExtractErrorEncrypter: func(*btcec.PublicKey) (\n\t\t\thop.ErrorEncrypter, lnwire.FailCode) {\n\t\t\treturn obfuscator, lnwire.CodeNone\n\t\t},\n\t\tFetchLastChannelUpdate: mockGetChanUpdateMessage,\n\t\tPreimageCache:          pCache,\n\t\tOnChannelFailure: func(lnwire.ChannelID,\n\t\t\tlnwire.ShortChannelID, LinkFailureError) {\n\t\t},\n\t\tUpdateContractSignals: func(*contractcourt.ContractSignals) error {\n\t\t\treturn nil\n\t\t},\n\t\tNotifyContractUpdate: notifyContractUpdate,\n\t\tRegistry:             invoiceRegistry,\n\t\tFeeEstimator:         newMockFeeEstimator(),\n\t\tChainEvents:          &contractcourt.ChainEventSubscription{},\n\t\tBatchTicker:          bticker,\n\t\tFwdPkgGCTicker:       ticker.NewForce(15 * time.Second),\n\t\tPendingCommitTicker:  ticker.New(time.Minute),\n\t\t// Make the BatchSize and Min/MaxFeeUpdateTimeout large enough\n\t\t// to not trigger commit updates automatically during tests.\n\t\tBatchSize:               10000,\n\t\tMinFeeUpdateTimeout:     30 * time.Minute,\n\t\tMaxFeeUpdateTimeout:     40 * time.Minute,\n\t\tMaxOutgoingCltvExpiry:   DefaultMaxOutgoingCltvExpiry,\n\t\tMaxFeeAllocation:        DefaultMaxLinkFeeAllocation,\n\t\tNotifyActiveLink:        func(wire.OutPoint) {},\n\t\tNotifyActiveChannel:     func(wire.OutPoint) {},\n\t\tNotifyInactiveChannel:   func(wire.OutPoint) {},\n\t\tNotifyInactiveLinkEvent: func(wire.OutPoint) {},\n\t\tHtlcNotifier:            aliceSwitch.cfg.HtlcNotifier,\n\t\tGetAliases:              getAliases,\n\t}\n\n\taliceLink := NewChannelLink(aliceCfg, aliceLc.channel)\n\tstart := func() error {\n\t\treturn aliceSwitch.AddLink(aliceLink)\n\t}\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-notifyUpdateChan:\n\t\t\tcase <-aliceLink.(*channelLink).quit:\n\t\t\t\tclose(doneChan)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tt.Cleanup(func() {\n\t\tclose(alicePeer.quit)\n\t\tinvoiceRegistry.cleanup()\n\t})\n\n\treturn aliceLink, bobLc.channel, bticker.Force, start,\n\t\taliceLc.restore, nil\n}\n",
      "length": 3836,
      "tokens": 340,
      "embedding": []
    },
    {
      "slug": "func assertLinkBandwidth(t *testing.T, link ChannelLink,",
      "content": "func assertLinkBandwidth(t *testing.T, link ChannelLink,\n\texpected lnwire.MilliSatoshi) {\n\n\tcurrentBandwidth := link.Bandwidth()\n\t_, _, line, _ := runtime.Caller(1)\n\tif currentBandwidth != expected {\n\t\tt.Fatalf(\"line %v: alice's link bandwidth is incorrect: \"+\n\t\t\t\"expected %v, got %v\", line, expected, currentBandwidth)\n\t}\n}\n\n// handleStateUpdate handles the messages sent from the link after\n// the batch ticker has triggered a state update.",
      "length": 375,
      "tokens": 53,
      "embedding": []
    },
    {
      "slug": "func handleStateUpdate(link *channelLink,",
      "content": "func handleStateUpdate(link *channelLink,\n\tremoteChannel *lnwallet.LightningChannel) error {\n\tsentMsgs := link.cfg.Peer.(*mockPeer).sentMsgs\n\tvar msg lnwire.Message\n\tselect {\n\tcase msg = <-sentMsgs:\n\tcase <-time.After(60 * time.Second):\n\t\treturn fmt.Errorf(\"did not receive CommitSig from Alice\")\n\t}\n\n\t// The link should be sending a commit sig at this point.\n\tcommitSig, ok := msg.(*lnwire.CommitSig)\n\tif !ok {\n\t\treturn fmt.Errorf(\"expected CommitSig, got %T\", msg)\n\t}\n\n\t// Let the remote channel receive the commit sig, and\n\t// respond with a revocation + commitsig.\n\terr := remoteChannel.ReceiveNewCommitment(\n\t\tcommitSig.CommitSig, commitSig.HtlcSigs)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tremoteRev, _, _, err := remoteChannel.RevokeCurrentCommitment()\n\tif err != nil {\n\t\treturn err\n\t}\n\tlink.HandleChannelUpdate(remoteRev)\n\n\tremoteSig, remoteHtlcSigs, _, err := remoteChannel.SignNextCommitment()\n\tif err != nil {\n\t\treturn err\n\t}\n\tcommitSig = &lnwire.CommitSig{\n\t\tCommitSig: remoteSig,\n\t\tHtlcSigs:  remoteHtlcSigs,\n\t}\n\tlink.HandleChannelUpdate(commitSig)\n\n\t// This should make the link respond with a revocation.\n\tselect {\n\tcase msg = <-sentMsgs:\n\tcase <-time.After(60 * time.Second):\n\t\treturn fmt.Errorf(\"did not receive RevokeAndAck from Alice\")\n\t}\n\n\trevoke, ok := msg.(*lnwire.RevokeAndAck)\n\tif !ok {\n\t\treturn fmt.Errorf(\"expected RevokeAndAck got %T\", msg)\n\t}\n\t_, _, _, _, err = remoteChannel.ReceiveRevocation(revoke)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to receive \"+\n\t\t\t\"revocation: %v\", err)\n\t}\n\n\treturn nil\n}\n\n// updateState is used exchange the messages necessary to do a full state\n// transition. If initiateUpdate=true, then this call will make the link\n// trigger an update by sending on the batchTick channel, if not, it will\n// make the remoteChannel initiate the state update.",
      "length": 1698,
      "tokens": 234,
      "embedding": []
    },
    {
      "slug": "func updateState(batchTick chan time.Time, link *channelLink,",
      "content": "func updateState(batchTick chan time.Time, link *channelLink,\n\tremoteChannel *lnwallet.LightningChannel,\n\tinitiateUpdate bool) error {\n\tsentMsgs := link.cfg.Peer.(*mockPeer).sentMsgs\n\n\tif initiateUpdate {\n\t\t// Trigger update by ticking the batchTicker.\n\t\tselect {\n\t\tcase batchTick <- time.Now():\n\t\tcase <-link.quit:\n\t\t\treturn fmt.Errorf(\"link shutting down\")\n\t\t}\n\t\treturn handleStateUpdate(link, remoteChannel)\n\t}\n\n\t// The remote is triggering the state update, emulate this by\n\t// signing and sending CommitSig to the link.\n\tremoteSig, remoteHtlcSigs, _, err := remoteChannel.SignNextCommitment()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcommitSig := &lnwire.CommitSig{\n\t\tCommitSig: remoteSig,\n\t\tHtlcSigs:  remoteHtlcSigs,\n\t}\n\tlink.HandleChannelUpdate(commitSig)\n\n\t// The link should respond with a revocation + commit sig.\n\tvar msg lnwire.Message\n\tselect {\n\tcase msg = <-sentMsgs:\n\tcase <-time.After(60 * time.Second):\n\t\treturn fmt.Errorf(\"did not receive RevokeAndAck from Alice\")\n\t}\n\n\trevoke, ok := msg.(*lnwire.RevokeAndAck)\n\tif !ok {\n\t\treturn fmt.Errorf(\"expected RevokeAndAck got %T\",\n\t\t\tmsg)\n\t}\n\t_, _, _, _, err = remoteChannel.ReceiveRevocation(revoke)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to receive \"+\n\t\t\t\"revocation: %v\", err)\n\t}\n\tselect {\n\tcase msg = <-sentMsgs:\n\tcase <-time.After(60 * time.Second):\n\t\treturn fmt.Errorf(\"did not receive CommitSig from Alice\")\n\t}\n\n\tcommitSig, ok = msg.(*lnwire.CommitSig)\n\tif !ok {\n\t\treturn fmt.Errorf(\"expected CommitSig, got %T\", msg)\n\t}\n\n\terr = remoteChannel.ReceiveNewCommitment(\n\t\tcommitSig.CommitSig, commitSig.HtlcSigs)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Lastly, send a revocation back to the link.\n\tremoteRev, _, _, err := remoteChannel.RevokeCurrentCommitment()\n\tif err != nil {\n\t\treturn err\n\t}\n\tlink.HandleChannelUpdate(remoteRev)\n\n\t// Sleep to make sure Alice has handled the remote revocation.\n\ttime.Sleep(500 * time.Millisecond)\n\n\treturn nil\n}\n\n// TestChannelLinkBandwidthConsistency ensures that the reported bandwidth of a\n// given ChannelLink is properly updated in response to downstream messages\n// from the switch, and upstream messages from its channel peer.\n//\n// TODO(roasbeef): add sync hook into packet processing so can eliminate all\n// sleep in this test and the one below",
      "length": 2108,
      "tokens": 284,
      "embedding": []
    },
    {
      "slug": "func TestChannelLinkBandwidthConsistency(t *testing.T) {",
      "content": "func TestChannelLinkBandwidthConsistency(t *testing.T) {\n\tif !build.IsDevBuild() {\n\t\tt.Fatalf(\"htlcswitch tests must be run with '-tags dev\")\n\t}\n\tt.Parallel()\n\n\t// TODO(roasbeef): replace manual bit twiddling with concept of\n\t// resource cost for packets?\n\t//  * or also able to consult link\n\n\t// We'll start the test by creating a single instance of\n\tconst chanAmt = btcutil.SatoshiPerBitcoin * 5\n\n\taliceLink, bobChannel, tmr, start, _, err :=\n\t\tnewSingleLinkTestHarness(t, chanAmt, 0)\n\trequire.NoError(t, err, \"unable to create link\")\n\n\tif err := start(); err != nil {\n\t\tt.Fatalf(\"unable to start test harness: %v\", err)\n\t}\n\n\tvar (\n\t\tcarolChanID            = lnwire.NewShortChanIDFromInt(3)\n\t\tmockBlob               [lnwire.OnionPacketSize]byte\n\t\tcoreChan               = aliceLink.(*channelLink).channel\n\t\tcoreLink               = aliceLink.(*channelLink)\n\t\tdefaultCommitFee       = coreChan.StateSnapshot().CommitFee\n\t\taliceStartingBandwidth = aliceLink.Bandwidth()\n\t\taliceMsgs              = coreLink.cfg.Peer.(*mockPeer).sentMsgs\n\t)\n\n\t// We put Alice into hodl.ExitSettle mode, such that she won't settle\n\t// incoming HTLCs automatically.\n\tcoreLink.cfg.HodlMask = hodl.MaskFromFlags(hodl.ExitSettle)\n\n\testimator := chainfee.NewStaticEstimator(6000, 0)\n\tfeePerKw, err := estimator.EstimateFeePerKW(1)\n\trequire.NoError(t, err, \"unable to query fee estimator\")\n\thtlcFee := lnwire.NewMSatFromSatoshis(\n\t\tfeePerKw.FeeForWeight(input.HTLCWeight),\n\t)\n\n\t// The starting bandwidth of the channel should be exactly the amount\n\t// that we created the channel between her and Bob, minus the\n\t// commitment fee and fee for adding an additional HTLC.\n\texpectedBandwidth := lnwire.NewMSatFromSatoshis(\n\t\tchanAmt-defaultCommitFee,\n\t) - htlcFee\n\tassertLinkBandwidth(t, aliceLink, expectedBandwidth)\n\n\t// Next, we'll create an HTLC worth 1 BTC, and send it into the link as\n\t// a switch initiated payment.  The resulting bandwidth should\n\t// now be decremented to reflect the new HTLC.\n\thtlcAmt := lnwire.NewMSatFromSatoshis(btcutil.SatoshiPerBitcoin)\n\tinvoice, htlc, _, err := generatePayment(\n\t\thtlcAmt, htlcAmt, 5, mockBlob,\n\t)\n\trequire.NoError(t, err, \"unable to create payment\")\n\taddPkt := htlcPacket{\n\t\thtlc:           htlc,\n\t\tincomingChanID: hop.Source,\n\t\tincomingHTLCID: 0,\n\t\tobfuscator:     NewMockObfuscator(),\n\t}\n\n\tcircuit := makePaymentCircuit(&htlc.PaymentHash, &addPkt)\n\t_, err = coreLink.cfg.Switch.commitCircuits(&circuit)\n\trequire.NoError(t, err, \"unable to commit circuit\")\n\n\taddPkt.circuit = &circuit\n\tif err := aliceLink.handleSwitchPacket(&addPkt); err != nil {\n\t\tt.Fatalf(\"unable to handle switch packet: %v\", err)\n\t}\n\ttime.Sleep(time.Millisecond * 500)\n\n\t// The resulting bandwidth should reflect that Alice is paying the\n\t// htlc amount in addition to the htlc fee.\n\tassertLinkBandwidth(t, aliceLink, aliceStartingBandwidth-htlcAmt-htlcFee)\n\n\t// Alice should send the HTLC to Bob.\n\tvar msg lnwire.Message\n\tselect {\n\tcase msg = <-aliceMsgs:\n\tcase <-time.After(15 * time.Second):\n\t\tt.Fatalf(\"did not receive message\")\n\t}\n\n\taddHtlc, ok := msg.(*lnwire.UpdateAddHTLC)\n\tif !ok {\n\t\tt.Fatalf(\"expected UpdateAddHTLC, got %T\", msg)\n\t}\n\n\tbobIndex, err := bobChannel.ReceiveHTLC(addHtlc)\n\trequire.NoError(t, err, \"bob failed receiving htlc\")\n\n\t// Lock in the HTLC.\n\tif err := updateState(tmr, coreLink, bobChannel, true); err != nil {\n\t\tt.Fatalf(\"unable to update state: %v\", err)\n\t}\n\t// Locking in the HTLC should not change Alice's bandwidth.\n\tassertLinkBandwidth(t, aliceLink, aliceStartingBandwidth-htlcAmt-htlcFee)\n\n\t// If we now send in a valid HTLC settle for the prior HTLC we added,\n\t// then the bandwidth should remain unchanged as the remote party will\n\t// gain additional channel balance.\n\terr = bobChannel.SettleHTLC(*invoice.Terms.PaymentPreimage, bobIndex, nil, nil, nil)\n\trequire.NoError(t, err, \"unable to settle htlc\")\n\thtlcSettle := &lnwire.UpdateFulfillHTLC{\n\t\tID:              0,\n\t\tPaymentPreimage: *invoice.Terms.PaymentPreimage,\n\t}\n\taliceLink.HandleChannelUpdate(htlcSettle)\n\ttime.Sleep(time.Millisecond * 500)\n\n\t// Since the settle is not locked in yet, Alice's bandwidth should still\n\t// reflect that she has to pay the fee.\n\tassertLinkBandwidth(t, aliceLink, aliceStartingBandwidth-htlcAmt-htlcFee)\n\n\t// Lock in the settle.\n\tif err := updateState(tmr, coreLink, bobChannel, false); err != nil {\n\t\tt.Fatalf(\"unable to update state: %v\", err)\n\t}\n\n\t// Now that it is settled, Alice should have gotten the htlc fee back.\n\tassertLinkBandwidth(t, aliceLink, aliceStartingBandwidth-htlcAmt)\n\n\t// Next, we'll add another HTLC initiated by the switch (of the same\n\t// amount as the prior one).\n\t_, htlc, _, err = generatePayment(htlcAmt, htlcAmt, 5, mockBlob)\n\trequire.NoError(t, err, \"unable to create payment\")\n\taddPkt = htlcPacket{\n\t\thtlc:           htlc,\n\t\tincomingChanID: hop.Source,\n\t\tincomingHTLCID: 1,\n\t\tobfuscator:     NewMockObfuscator(),\n\t}\n\n\tcircuit = makePaymentCircuit(&htlc.PaymentHash, &addPkt)\n\t_, err = coreLink.cfg.Switch.commitCircuits(&circuit)\n\trequire.NoError(t, err, \"unable to commit circuit\")\n\n\taddPkt.circuit = &circuit\n\tif err := aliceLink.handleSwitchPacket(&addPkt); err != nil {\n\t\tt.Fatalf(\"unable to handle switch packet: %v\", err)\n\t}\n\ttime.Sleep(time.Millisecond * 500)\n\n\t// Again, Alice's bandwidth decreases by htlcAmt+htlcFee.\n\tassertLinkBandwidth(t, aliceLink, aliceStartingBandwidth-2*htlcAmt-htlcFee)\n\n\t// Alice will send the HTLC to Bob.\n\tselect {\n\tcase msg = <-aliceMsgs:\n\tcase <-time.After(15 * time.Second):\n\t\tt.Fatalf(\"did not receive message\")\n\t}\n\n\taddHtlc, ok = msg.(*lnwire.UpdateAddHTLC)\n\tif !ok {\n\t\tt.Fatalf(\"expected UpdateAddHTLC, got %T\", msg)\n\t}\n\n\tbobIndex, err = bobChannel.ReceiveHTLC(addHtlc)\n\trequire.NoError(t, err, \"bob failed receiving htlc\")\n\n\t// Lock in the HTLC, which should not affect the bandwidth.\n\tif err := updateState(tmr, coreLink, bobChannel, true); err != nil {\n\t\tt.Fatalf(\"unable to update state: %v\", err)\n\t}\n\n\tassertLinkBandwidth(t, aliceLink, aliceStartingBandwidth-htlcAmt*2-htlcFee)\n\n\t// With that processed, we'll now generate an HTLC fail (sent by the\n\t// remote peer) to cancel the HTLC we just added. This should return us\n\t// back to the bandwidth of the link right before the HTLC was sent.\n\treason := make([]byte, 292)\n\tcopy(reason, []byte(\"nop\"))\n\n\terr = bobChannel.FailHTLC(bobIndex, reason, nil, nil, nil)\n\trequire.NoError(t, err, \"unable to fail htlc\")\n\tfailMsg := &lnwire.UpdateFailHTLC{\n\t\tID:     1,\n\t\tReason: lnwire.OpaqueReason(reason),\n\t}\n\n\taliceLink.HandleChannelUpdate(failMsg)\n\ttime.Sleep(time.Millisecond * 500)\n\n\t// Before the Fail gets locked in, the bandwidth should remain unchanged.\n\tassertLinkBandwidth(t, aliceLink, aliceStartingBandwidth-htlcAmt*2-htlcFee)\n\n\t// Lock in the Fail.\n\tif err := updateState(tmr, coreLink, bobChannel, false); err != nil {\n\t\tt.Fatalf(\"unable to update state: %v\", err)\n\t}\n\n\t// Now the bandwidth should reflect the failed HTLC.\n\tassertLinkBandwidth(t, aliceLink, aliceStartingBandwidth-htlcAmt)\n\n\t// Moving along, we'll now receive a new HTLC from the remote peer,\n\t// with an ID of 0 as this is their first HTLC. The bandwidth should\n\t// remain unchanged (but Alice will need to pay the fee for the extra\n\t// HTLC).\n\thtlcAmt, totalTimelock, hops := generateHops(htlcAmt, testStartingHeight,\n\t\tcoreLink)\n\tblob, err := generateRoute(hops...)\n\trequire.NoError(t, err, \"unable to gen route\")\n\tinvoice, htlc, _, err = generatePayment(\n\t\thtlcAmt, htlcAmt, totalTimelock, blob,\n\t)\n\trequire.NoError(t, err, \"unable to create payment\")\n\n\t// We must add the invoice to the registry, such that Alice expects\n\t// this payment.\n\terr = coreLink.cfg.Registry.(*mockInvoiceRegistry).AddInvoice(\n\t\t*invoice, htlc.PaymentHash,\n\t)\n\trequire.NoError(t, err, \"unable to add invoice to registry\")\n\n\thtlc.ID = 0\n\t_, err = bobChannel.AddHTLC(htlc, nil)\n\trequire.NoError(t, err, \"unable to add htlc\")\n\taliceLink.HandleChannelUpdate(htlc)\n\n\t// Alice's balance remains unchanged until this HTLC is locked in.\n\tassertLinkBandwidth(t, aliceLink, aliceStartingBandwidth-htlcAmt)\n\n\t// Lock in the HTLC.\n\tif err := updateState(tmr, coreLink, bobChannel, false); err != nil {\n\t\tt.Fatalf(\"unable to update state: %v\", err)\n\t}\n\n\t// Since Bob is adding this HTLC, Alice only needs to pay the fee.\n\tassertLinkBandwidth(t, aliceLink, aliceStartingBandwidth-htlcAmt-htlcFee)\n\ttime.Sleep(time.Millisecond * 500)\n\n\taddPkt = htlcPacket{\n\t\thtlc:           htlc,\n\t\tincomingChanID: aliceLink.ShortChanID(),\n\t\tincomingHTLCID: 0,\n\t\tobfuscator:     NewMockObfuscator(),\n\t}\n\n\tcircuit = makePaymentCircuit(&htlc.PaymentHash, &addPkt)\n\t_, err = coreLink.cfg.Switch.commitCircuits(&circuit)\n\trequire.NoError(t, err, \"unable to commit circuit\")\n\n\taddPkt.outgoingChanID = carolChanID\n\taddPkt.outgoingHTLCID = 0\n\n\terr = coreLink.cfg.Circuits.OpenCircuits(addPkt.keystone())\n\trequire.NoError(t, err, \"unable to set keystone\")\n\n\t// Next, we'll settle the HTLC with our knowledge of the pre-image that\n\t// we eventually learn (simulating a multi-hop payment). The bandwidth\n\t// of the channel should now be re-balanced to the starting point.\n\tsettlePkt := htlcPacket{\n\t\tincomingChanID: aliceLink.ShortChanID(),\n\t\tincomingHTLCID: 0,\n\t\tcircuit:        &circuit,\n\t\toutgoingChanID: addPkt.outgoingChanID,\n\t\toutgoingHTLCID: addPkt.outgoingHTLCID,\n\t\thtlc: &lnwire.UpdateFulfillHTLC{\n\t\t\tID:              0,\n\t\t\tPaymentPreimage: *invoice.Terms.PaymentPreimage,\n\t\t},\n\t\tobfuscator: NewMockObfuscator(),\n\t}\n\n\tif err := aliceLink.handleSwitchPacket(&settlePkt); err != nil {\n\t\tt.Fatalf(\"unable to handle switch packet: %v\", err)\n\t}\n\ttime.Sleep(time.Millisecond * 500)\n\n\t// Settling this HTLC gives Alice all her original bandwidth back.\n\tassertLinkBandwidth(t, aliceLink, aliceStartingBandwidth)\n\n\tselect {\n\tcase msg = <-aliceMsgs:\n\tcase <-time.After(15 * time.Second):\n\t\tt.Fatalf(\"did not receive message\")\n\t}\n\n\tsettleMsg, ok := msg.(*lnwire.UpdateFulfillHTLC)\n\tif !ok {\n\t\tt.Fatalf(\"expected UpdateFulfillHTLC, got %T\", msg)\n\t}\n\terr = bobChannel.ReceiveHTLCSettle(settleMsg.PaymentPreimage, settleMsg.ID)\n\trequire.NoError(t, err, \"failed receiving fail htlc\")\n\n\t// After failing an HTLC, the link will automatically trigger\n\t// a state update.\n\tif err := handleStateUpdate(coreLink, bobChannel); err != nil {\n\t\tt.Fatalf(\"unable to update state: %v\", err)\n\t}\n\n\t// Finally, we'll test the scenario of failing an HTLC received by the\n\t// remote node. This should result in no perceived bandwidth changes.\n\thtlcAmt, totalTimelock, hops = generateHops(htlcAmt, testStartingHeight,\n\t\tcoreLink)\n\tblob, err = generateRoute(hops...)\n\trequire.NoError(t, err, \"unable to gen route\")\n\tinvoice, htlc, _, err = generatePayment(\n\t\thtlcAmt, htlcAmt, totalTimelock, blob,\n\t)\n\trequire.NoError(t, err, \"unable to create payment\")\n\terr = coreLink.cfg.Registry.(*mockInvoiceRegistry).AddInvoice(\n\t\t*invoice, htlc.PaymentHash,\n\t)\n\trequire.NoError(t, err, \"unable to add invoice to registry\")\n\n\t// Since we are not using the link to handle HTLC IDs for the\n\t// remote channel, we must set this manually. This is the second\n\t// HTLC we add, hence it should have an ID of 1 (Alice's channel\n\t// link will set this automatically for her side).\n\thtlc.ID = 1\n\t_, err = bobChannel.AddHTLC(htlc, nil)\n\trequire.NoError(t, err, \"unable to add htlc\")\n\taliceLink.HandleChannelUpdate(htlc)\n\ttime.Sleep(time.Millisecond * 500)\n\n\t// No changes before the HTLC is locked in.\n\tassertLinkBandwidth(t, aliceLink, aliceStartingBandwidth)\n\tif err := updateState(tmr, coreLink, bobChannel, false); err != nil {\n\t\tt.Fatalf(\"unable to update state: %v\", err)\n\t}\n\n\t// After lock-in, Alice will have to pay the htlc fee.\n\tassertLinkBandwidth(t, aliceLink, aliceStartingBandwidth-htlcFee)\n\n\taddPkt = htlcPacket{\n\t\thtlc:           htlc,\n\t\tincomingChanID: aliceLink.ShortChanID(),\n\t\tincomingHTLCID: 1,\n\t\tobfuscator:     NewMockObfuscator(),\n\t}\n\n\tcircuit = makePaymentCircuit(&htlc.PaymentHash, &addPkt)\n\t_, err = coreLink.cfg.Switch.commitCircuits(&circuit)\n\trequire.NoError(t, err, \"unable to commit circuit\")\n\n\taddPkt.outgoingChanID = carolChanID\n\taddPkt.outgoingHTLCID = 1\n\n\terr = coreLink.cfg.Circuits.OpenCircuits(addPkt.keystone())\n\trequire.NoError(t, err, \"unable to set keystone\")\n\n\tfailPkt := htlcPacket{\n\t\tincomingChanID: aliceLink.ShortChanID(),\n\t\tincomingHTLCID: 1,\n\t\tcircuit:        &circuit,\n\t\toutgoingChanID: addPkt.outgoingChanID,\n\t\toutgoingHTLCID: addPkt.outgoingHTLCID,\n\t\thtlc: &lnwire.UpdateFailHTLC{\n\t\t\tID:     1,\n\t\t\tReason: reason,\n\t\t},\n\t\tobfuscator: NewMockObfuscator(),\n\t}\n\n\tif err := aliceLink.handleSwitchPacket(&failPkt); err != nil {\n\t\tt.Fatalf(\"unable to handle switch packet: %v\", err)\n\t}\n\ttime.Sleep(time.Millisecond * 500)\n\n\t// Alice should get all her bandwidth back.\n\tassertLinkBandwidth(t, aliceLink, aliceStartingBandwidth)\n\n\t// Message should be sent to Bob.\n\tselect {\n\tcase msg = <-aliceMsgs:\n\tcase <-time.After(15 * time.Second):\n\t\tt.Fatalf(\"did not receive message\")\n\t}\n\tfailMsg, ok = msg.(*lnwire.UpdateFailHTLC)\n\tif !ok {\n\t\tt.Fatalf(\"expected UpdateFailHTLC, got %T\", msg)\n\t}\n\terr = bobChannel.ReceiveFailHTLC(failMsg.ID, []byte(\"fail\"))\n\trequire.NoError(t, err, \"failed receiving fail htlc\")\n\n\t// After failing an HTLC, the link will automatically trigger\n\t// a state update.\n\tif err := handleStateUpdate(coreLink, bobChannel); err != nil {\n\t\tt.Fatalf(\"unable to update state: %v\", err)\n\t}\n\tassertLinkBandwidth(t, aliceLink, aliceStartingBandwidth)\n}\n\n// genAddsAndCircuits creates `numHtlcs` sequential ADD packets and there\n// corresponding circuits. The provided `htlc` is used in all test packets.",
      "length": 13029,
      "tokens": 1572,
      "embedding": []
    },
    {
      "slug": "func genAddsAndCircuits(numHtlcs int, htlc *lnwire.UpdateAddHTLC) (",
      "content": "func genAddsAndCircuits(numHtlcs int, htlc *lnwire.UpdateAddHTLC) (\n\t[]*htlcPacket, []*PaymentCircuit) {\n\n\taddPkts := make([]*htlcPacket, 0, numHtlcs)\n\tcircuits := make([]*PaymentCircuit, 0, numHtlcs)\n\tfor i := 0; i < numHtlcs; i++ {\n\t\taddPkt := htlcPacket{\n\t\t\thtlc:           htlc,\n\t\t\tincomingChanID: hop.Source,\n\t\t\tincomingHTLCID: uint64(i),\n\t\t\tobfuscator:     NewMockObfuscator(),\n\t\t}\n\n\t\tcircuit := makePaymentCircuit(&htlc.PaymentHash, &addPkt)\n\t\taddPkt.circuit = &circuit\n\n\t\taddPkts = append(addPkts, &addPkt)\n\t\tcircuits = append(circuits, &circuit)\n\t}\n\n\treturn addPkts, circuits\n}\n\n// TestChannelLinkTrimCircuitsPending checks that the switch and link properly\n// trim circuits if there are open circuits corresponding to ADDs on a pending\n// commmitment transaction.",
      "length": 681,
      "tokens": 80,
      "embedding": []
    },
    {
      "slug": "func TestChannelLinkTrimCircuitsPending(t *testing.T) {",
      "content": "func TestChannelLinkTrimCircuitsPending(t *testing.T) {\n\tt.Parallel()\n\n\tconst (\n\t\tchanAmt   = btcutil.SatoshiPerBitcoin * 5\n\t\tnumHtlcs  = 4\n\t\thalfHtlcs = numHtlcs / 2\n\t)\n\n\t// We'll start by creating a new link with our chanAmt (5 BTC). We will\n\t// only be testing Alice's behavior, so the reference to Bob's channel\n\t// state is unnecessary.\n\taliceLink, _, batchTicker, start, restore, err :=\n\t\tnewSingleLinkTestHarness(t, chanAmt, 0)\n\trequire.NoError(t, err, \"unable to create link\")\n\n\tif err := start(); err != nil {\n\t\tt.Fatalf(\"unable to start test harness: %v\", err)\n\t}\n\n\talice := newPersistentLinkHarness(\n\t\tt, aliceLink, batchTicker, restore,\n\t)\n\n\t// Compute the static fees that will be used to determine the\n\t// correctness of Alice's bandwidth when forwarding HTLCs.\n\testimator := chainfee.NewStaticEstimator(6000, 0)\n\tfeePerKw, err := estimator.EstimateFeePerKW(1)\n\trequire.NoError(t, err, \"unable to query fee estimator\")\n\n\tdefaultCommitFee := alice.channel.StateSnapshot().CommitFee\n\thtlcFee := lnwire.NewMSatFromSatoshis(\n\t\tfeePerKw.FeeForWeight(input.HTLCWeight),\n\t)\n\n\t// The starting bandwidth of the channel should be exactly the amount\n\t// that we created the channel between her and Bob, minus the commitment\n\t// fee and fee of adding an HTLC.\n\texpectedBandwidth := lnwire.NewMSatFromSatoshis(\n\t\tchanAmt-defaultCommitFee,\n\t) - htlcFee\n\tassertLinkBandwidth(t, alice.link, expectedBandwidth)\n\n\t// Capture Alice's starting bandwidth to perform later, relative\n\t// bandwidth assertions.\n\taliceStartingBandwidth := alice.link.Bandwidth()\n\n\t// Next, we'll create an HTLC worth 1 BTC that will be used as a dummy\n\t// message for the test.\n\tvar mockBlob [lnwire.OnionPacketSize]byte\n\thtlcAmt := lnwire.NewMSatFromSatoshis(btcutil.SatoshiPerBitcoin)\n\t_, htlc, _, err := generatePayment(htlcAmt, htlcAmt, 5, mockBlob)\n\trequire.NoError(t, err, \"unable to create payment\")\n\n\t// Create `numHtlc` htlcPackets and payment circuits that will be used\n\t// to drive the test. All of the packets will use the same dummy HTLC.\n\taddPkts, circuits := genAddsAndCircuits(numHtlcs, htlc)\n\n\t// To begin the test, start by committing the circuits belong to our\n\t// first two HTLCs.\n\tfwdActions := alice.commitCircuits(circuits[:halfHtlcs])\n\n\t// Both of these circuits should have successfully added, as this is the\n\t// first attempt to send them.\n\tif len(fwdActions.Adds) != halfHtlcs {\n\t\tt.Fatalf(\"expected %d circuits to be added\", halfHtlcs)\n\t}\n\talice.assertNumPendingNumOpenCircuits(2, 0)\n\n\t// Since both were committed successfully, we will now deliver them to\n\t// Alice's link.\n\tfor _, addPkt := range addPkts[:halfHtlcs] {\n\t\tif err := alice.link.handleSwitchPacket(addPkt); err != nil {\n\t\t\tt.Fatalf(\"unable to handle switch packet: %v\", err)\n\t\t}\n\t}\n\n\t// Wait until Alice's link has sent both HTLCs via the peer.\n\talice.checkSent(addPkts[:halfHtlcs])\n\n\t// The resulting bandwidth should reflect that Alice is paying both\n\t// htlc amounts, in addition to both htlc fees.\n\tassertLinkBandwidth(t, alice.link,\n\t\taliceStartingBandwidth-halfHtlcs*(htlcAmt+htlcFee),\n\t)\n\n\t// Now, initiate a state transition by Alice so that the pending HTLCs\n\t// are locked in. This will *not* involve any participation by Bob,\n\t// which ensures the commitment will remain in a pending state.\n\talice.trySignNextCommitment()\n\talice.assertNumPendingNumOpenCircuits(2, 2)\n\n\t// Restart Alice's link, which simulates a disconnection with the remote\n\t// peer.\n\talice.restart(false, false)\n\n\talice.assertNumPendingNumOpenCircuits(2, 2)\n\n\t// Make a second attempt to commit the first two circuits. This can\n\t// happen if the incoming link flaps, but also allows us to verify that\n\t// the circuits were trimmed properly.\n\tfwdActions = alice.commitCircuits(circuits[:halfHtlcs])\n\n\t// Since Alice has a pending commitment with the first two HTLCs, the\n\t// restart should not have trimmed them from the circuit map.\n\t// Therefore, we expect both of these circuits to be dropped by the\n\t// switch, as keystones should still be set.\n\tif len(fwdActions.Drops) != halfHtlcs {\n\t\tt.Fatalf(\"expected %d packets to be dropped\", halfHtlcs)\n\t}\n\n\t// The resulting bandwidth should remain unchanged from before,\n\t// reflecting that Alice is paying both htlc amounts, in addition to\n\t// both htlc fees.\n\tassertLinkBandwidth(t, alice.link,\n\t\taliceStartingBandwidth-halfHtlcs*(htlcAmt+htlcFee),\n\t)\n\n\t// Now, restart Alice's link *and* the entire switch. This will ensure\n\t// that entire circuit map is reloaded from disk, and we can now test\n\t// against the behavioral differences of committing circuits that\n\t// conflict with duplicate circuits after a restart.\n\talice.restart(true, false)\n\n\talice.assertNumPendingNumOpenCircuits(2, 2)\n\n\t// Alice should not send out any messages. Even though Alice has a\n\t// pending commitment transaction, channel reestablishment is not\n\t// enabled in this test.\n\tselect {\n\tcase <-alice.msgs:\n\t\tt.Fatalf(\"message should not have been sent by Alice\")\n\tcase <-time.After(time.Second):\n\t}\n\n\t// We will now try to commit the circuits for all of our HTLCs. The\n\t// first two are already on the pending commitment transaction, the\n\t// latter two are new HTLCs.\n\tfwdActions = alice.commitCircuits(circuits)\n\n\t// The first two circuits should have been dropped, as they are still on\n\t// the pending commitment transaction, and the restart should not have\n\t// trimmed the circuits for these valid HTLCs.\n\tif len(fwdActions.Drops) != halfHtlcs {\n\t\tt.Fatalf(\"expected %d packets to be dropped\", halfHtlcs)\n\t}\n\t// The latter two circuits are unknown the circuit map, and should\n\t// report being added.\n\tif len(fwdActions.Adds) != halfHtlcs {\n\t\tt.Fatalf(\"expected %d packets to be added\", halfHtlcs)\n\t}\n\n\t// Deliver the latter two HTLCs to Alice's links so that they can be\n\t// processed and added to the in-memory commitment state.\n\tfor _, addPkt := range addPkts[halfHtlcs:] {\n\t\tif err := alice.link.handleSwitchPacket(addPkt); err != nil {\n\t\t\tt.Fatalf(\"unable to handle switch packet: %v\", err)\n\t\t}\n\t}\n\n\t// Wait for Alice to send the two latter HTLCs via the peer.\n\talice.checkSent(addPkts[halfHtlcs:])\n\n\t// With two HTLCs on the pending commit, and two added to the in-memory\n\t// commitment state, the resulting bandwidth should reflect that Alice\n\t// is paying the all htlc amounts in addition to all htlc fees.\n\tassertLinkBandwidth(t, alice.link,\n\t\taliceStartingBandwidth-numHtlcs*(htlcAmt+htlcFee),\n\t)\n\n\t// We will try to initiate a state transition for Alice, which will\n\t// ensure the circuits for the two in-memory HTLCs are opened. However,\n\t// since we have a pending commitment, these HTLCs will not actually be\n\t// included in a commitment.\n\talice.trySignNextCommitment()\n\talice.assertNumPendingNumOpenCircuits(4, 4)\n\n\t// Restart Alice's link to simulate a disconnect. Since the switch\n\t// remains up throughout, the two latter HTLCs will remain in the link's\n\t// mailbox, and will reprocessed upon being reattached to the link.\n\talice.restart(false, false)\n\n\talice.assertNumPendingNumOpenCircuits(4, 2)\n\n\t// Again, try to recommit all of our circuits.\n\tfwdActions = alice.commitCircuits(circuits)\n\n\t// It is expected that all of these will get dropped by the switch.\n\t// The first two circuits are still open as a result of being on the\n\t// commitment transaction. The latter two should have had their open\n\t// circuits trimmed, *but* since the HTLCs are still in Alice's mailbox,\n\t// the switch knows not to fail them as a result of the latter two\n\t// circuits never having been loaded from disk.\n\tif len(fwdActions.Drops) != numHtlcs {\n\t\tt.Fatalf(\"expected %d packets to be dropped\", numHtlcs)\n\t}\n\n\t// Wait for the latter two htlcs to be pulled from the mailbox, added to\n\t// the in-memory channel state, and sent out via the peer.\n\talice.checkSent(addPkts[halfHtlcs:])\n\n\t// This should result in reconstructing the same bandwidth as our last\n\t// assertion. There are two HTLCs on the pending commit, and two added\n\t// to the in-memory commitment state, the resulting bandwidth should\n\t// reflect that Alice is paying the all htlc amounts in addition to all\n\t// htlc fees.\n\tassertLinkBandwidth(t, alice.link,\n\t\taliceStartingBandwidth-numHtlcs*(htlcAmt+htlcFee),\n\t)\n\n\t// Again, we will try to initiate a state transition for Alice, which\n\t// will ensure the circuits for the two in-memory HTLCs are opened.\n\t// As before, these HTLCs will not actually be included in a commitment\n\t// since we have a pending commitment.\n\talice.trySignNextCommitment()\n\talice.assertNumPendingNumOpenCircuits(4, 4)\n\n\t// As a final persistence check, we will restart the link and switch,\n\t// wiping the latter two HTLCs from memory, and forcing their circuits\n\t// to be reloaded from disk.\n\talice.restart(true, false)\n\n\talice.assertNumPendingNumOpenCircuits(4, 2)\n\n\t// Alice's mailbox will be empty after the restart, and no channel\n\t// reestablishment is configured, so no messages will be sent upon\n\t// restart.\n\tselect {\n\tcase <-alice.msgs:\n\t\tt.Fatalf(\"message should not have been sent by Alice\")\n\tcase <-time.After(time.Second):\n\t}\n\n\t// Finally, make one last attempt to commit all circuits.\n\tfwdActions = alice.commitCircuits(circuits)\n\n\t// The first two HTLCs should still be dropped by the htlcswitch. Their\n\t// existence on the pending commitment transaction should prevent their\n\t// open circuits from being trimmed.\n\tif len(fwdActions.Drops) != halfHtlcs {\n\t\tt.Fatalf(\"expected %d packets to be dropped\", halfHtlcs)\n\t}\n\t// The latter two HTLCs should now be failed by the switch. These will\n\t// have been trimmed by the link or switch restarting, and since the\n\t// HTLCs are known to be lost from memory (since their circuits were\n\t// loaded from disk), it is safe fail them back as they won't ever be\n\t// delivered to the outgoing link.\n\tif len(fwdActions.Fails) != halfHtlcs {\n\t\tt.Fatalf(\"expected %d packets to be dropped\", halfHtlcs)\n\t}\n\n\t// Since the latter two HTLCs have been completely dropped from memory,\n\t// only the first two HTLCs we added should still be reflected in the\n\t// channel bandwidth.\n\tassertLinkBandwidth(t, alice.link,\n\t\taliceStartingBandwidth-halfHtlcs*(htlcAmt+htlcFee),\n\t)\n}\n\n// TestChannelLinkTrimCircuitsNoCommit checks that the switch and link properly trim\n// circuits if the ADDs corresponding to open circuits are never committed.",
      "length": 9927,
      "tokens": 1447,
      "embedding": []
    },
    {
      "slug": "func TestChannelLinkTrimCircuitsNoCommit(t *testing.T) {",
      "content": "func TestChannelLinkTrimCircuitsNoCommit(t *testing.T) {\n\tif !build.IsDevBuild() {\n\t\tt.Fatalf(\"htlcswitch tests must be run with '-tags dev\")\n\t}\n\n\tt.Parallel()\n\n\tconst (\n\t\tchanAmt   = btcutil.SatoshiPerBitcoin * 5\n\t\tnumHtlcs  = 4\n\t\thalfHtlcs = numHtlcs / 2\n\t)\n\n\t// We'll start by creating a new link with our chanAmt (5 BTC). We will\n\t// only be testing Alice's behavior, so the reference to Bob's channel\n\t// state is unnecessary.\n\taliceLink, _, batchTicker, start, restore, err :=\n\t\tnewSingleLinkTestHarness(t, chanAmt, 0)\n\trequire.NoError(t, err, \"unable to create link\")\n\n\tif err := start(); err != nil {\n\t\tt.Fatalf(\"unable to start test harness: %v\", err)\n\t}\n\n\talice := newPersistentLinkHarness(\n\t\tt, aliceLink, batchTicker, restore,\n\t)\n\n\t// We'll put Alice into hodl.Commit mode, such that the circuits for any\n\t// outgoing ADDs are opened, but the changes are not committed in the\n\t// channel state.\n\talice.coreLink.cfg.HodlMask = hodl.Commit.Mask()\n\n\t// Compute the static fees that will be used to determine the\n\t// correctness of Alice's bandwidth when forwarding HTLCs.\n\testimator := chainfee.NewStaticEstimator(6000, 0)\n\tfeePerKw, err := estimator.EstimateFeePerKW(1)\n\trequire.NoError(t, err, \"unable to query fee estimator\")\n\n\tdefaultCommitFee := alice.channel.StateSnapshot().CommitFee\n\thtlcFee := lnwire.NewMSatFromSatoshis(\n\t\tfeePerKw.FeeForWeight(input.HTLCWeight),\n\t)\n\n\t// The starting bandwidth of the channel should be exactly the amount\n\t// that we created the channel between her and Bob, minus the commitment\n\t// fee and fee for adding an additional HTLC.\n\texpectedBandwidth := lnwire.NewMSatFromSatoshis(\n\t\tchanAmt-defaultCommitFee,\n\t) - htlcFee\n\tassertLinkBandwidth(t, alice.link, expectedBandwidth)\n\n\t// Capture Alice's starting bandwidth to perform later, relative\n\t// bandwidth assertions.\n\taliceStartingBandwidth := alice.link.Bandwidth()\n\n\t// Next, we'll create an HTLC worth 1 BTC that will be used as a dummy\n\t// message for the test.\n\tvar mockBlob [lnwire.OnionPacketSize]byte\n\thtlcAmt := lnwire.NewMSatFromSatoshis(btcutil.SatoshiPerBitcoin)\n\t_, htlc, _, err := generatePayment(htlcAmt, htlcAmt, 5, mockBlob)\n\trequire.NoError(t, err, \"unable to create payment\")\n\n\t// Create `numHtlc` htlcPackets and payment circuits that will be used\n\t// to drive the test. All of the packets will use the same dummy HTLC.\n\taddPkts, circuits := genAddsAndCircuits(numHtlcs, htlc)\n\n\t// To begin the test, start by committing the circuits belong to our\n\t// first two HTLCs.\n\tfwdActions := alice.commitCircuits(circuits[:halfHtlcs])\n\n\t// Both of these circuits should have successfully added, as this is the\n\t// first attempt to send them.\n\tif len(fwdActions.Adds) != halfHtlcs {\n\t\tt.Fatalf(\"expected %d circuits to be added\", halfHtlcs)\n\t}\n\n\t// Since both were committed successfully, we will now deliver them to\n\t// Alice's link.\n\tfor _, addPkt := range addPkts[:halfHtlcs] {\n\t\tif err := alice.link.handleSwitchPacket(addPkt); err != nil {\n\t\t\tt.Fatalf(\"unable to handle switch packet: %v\", err)\n\t\t}\n\t}\n\n\t// Wait until Alice's link has sent both HTLCs via the peer.\n\talice.checkSent(addPkts[:halfHtlcs])\n\n\t// The resulting bandwidth should reflect that Alice is paying both\n\t// htlc amounts, in addition to both htlc fees.\n\tassertLinkBandwidth(t, alice.link,\n\t\taliceStartingBandwidth-halfHtlcs*(htlcAmt+htlcFee),\n\t)\n\n\talice.assertNumPendingNumOpenCircuits(2, 0)\n\n\t// Now, init a state transition by Alice to try and commit the HTLCs.\n\t// Since she is in hodl.Commit mode, this will fail, but the circuits\n\t// will be opened persistently.\n\talice.trySignNextCommitment()\n\n\talice.assertNumPendingNumOpenCircuits(2, 2)\n\n\t// Restart Alice's link, which simulates a disconnection with the remote\n\t// peer. Alice's link and switch should trim the circuits that were\n\t// opened but not committed.\n\talice.restart(false, false, hodl.Commit)\n\n\talice.assertNumPendingNumOpenCircuits(2, 0)\n\n\t// The first two HTLCs should have been reset in Alice's mailbox since\n\t// the switch was not shutdown. Knowing this the switch should drop the\n\t// two circuits, even if the circuits were trimmed.\n\tfwdActions = alice.commitCircuits(circuits[:halfHtlcs])\n\tif len(fwdActions.Drops) != halfHtlcs {\n\t\tt.Fatalf(\"expected %d packets to be dropped since \"+\n\t\t\t\"the switch has not been restarted\", halfHtlcs)\n\t}\n\n\t// Wait for alice to process the first two HTLCs resend them via the\n\t// peer.\n\talice.checkSent(addPkts[:halfHtlcs])\n\n\t// The resulting bandwidth should reflect that Alice is paying both htlc\n\t// amounts, in addition to both htlc fees.\n\tassertLinkBandwidth(t, alice.link,\n\t\taliceStartingBandwidth-halfHtlcs*(htlcAmt+htlcFee),\n\t)\n\n\t// Again, initiate another state transition by Alice to try and commit\n\t// the HTLCs.  Since she is in hodl.Commit mode, this will fail, but the\n\t// circuits will be opened persistently.\n\talice.trySignNextCommitment()\n\talice.assertNumPendingNumOpenCircuits(2, 2)\n\n\t// Now, we we will do a full restart of the link and switch, configuring\n\t// Alice again in hodl.Commit mode. Since none of the HTLCs were\n\t// actually committed, the previously opened circuits should be trimmed\n\t// by both the link and switch.\n\talice.restart(true, false, hodl.Commit)\n\n\talice.assertNumPendingNumOpenCircuits(2, 0)\n\n\t// Attempt another commit of our first two circuits. Both should fail,\n\t// as the opened circuits should have been trimmed, and circuit map\n\t// recognizes that these HTLCs were lost during the restart.\n\tfwdActions = alice.commitCircuits(circuits[:halfHtlcs])\n\tif len(fwdActions.Fails) != halfHtlcs {\n\t\tt.Fatalf(\"expected %d packets to be failed\", halfHtlcs)\n\t}\n\n\t// Bob should not receive any HTLCs from Alice, since Alice's mailbox is\n\t// empty and there is no pending commitment.\n\tselect {\n\tcase <-alice.msgs:\n\t\tt.Fatalf(\"received unexpected message from Alice\")\n\tcase <-time.After(time.Second):\n\t}\n\n\t// Alice's bandwidth should have reverted back to her starting value.\n\tassertLinkBandwidth(t, alice.link, aliceStartingBandwidth)\n\n\t// Now, try to commit the last two payment circuits, which are unused\n\t// thus far. These should succeed without hesitation.\n\tfwdActions = alice.commitCircuits(circuits[halfHtlcs:])\n\tif len(fwdActions.Adds) != halfHtlcs {\n\t\tt.Fatalf(\"expected %d packets to be added\", halfHtlcs)\n\t}\n\n\t// Deliver the last two HTLCs to the link via Alice's mailbox.\n\tfor _, addPkt := range addPkts[halfHtlcs:] {\n\t\tif err := alice.link.handleSwitchPacket(addPkt); err != nil {\n\t\t\tt.Fatalf(\"unable to handle switch packet: %v\", err)\n\t\t}\n\t}\n\n\t// Verify that Alice processed and sent out the ADD packets via the\n\t// peer.\n\talice.checkSent(addPkts[halfHtlcs:])\n\n\t// The resulting bandwidth should reflect that Alice is paying both htlc\n\t// amounts, in addition to both htlc fees.\n\tassertLinkBandwidth(t, alice.link,\n\t\taliceStartingBandwidth-halfHtlcs*(htlcAmt+htlcFee),\n\t)\n\n\t// Now, initiate a state transition for Alice. Since we are hodl.Commit\n\t// mode, this will only open the circuits that were added to the\n\t// in-memory channel state.\n\talice.trySignNextCommitment()\n\talice.assertNumPendingNumOpenCircuits(4, 2)\n\n\t// Restart Alice's link, and place her back in hodl.Commit mode. On\n\t// restart, all previously opened circuits should be trimmed by both the\n\t// link and the switch.\n\talice.restart(false, false, hodl.Commit)\n\n\talice.assertNumPendingNumOpenCircuits(4, 0)\n\n\t// Now, try to commit all of known circuits.\n\tfwdActions = alice.commitCircuits(circuits)\n\n\t// The first two HTLCs will fail to commit for the same reason as\n\t// before, the circuits have been trimmed.\n\tif len(fwdActions.Fails) != halfHtlcs {\n\t\tt.Fatalf(\"expected %d packet to be failed\", halfHtlcs)\n\t}\n\n\t// The last two HTLCs will be dropped, as thought the circuits are\n\t// trimmed, the switch is aware that the HTLCs are still in Alice's\n\t// mailbox.\n\tif len(fwdActions.Drops) != halfHtlcs {\n\t\tt.Fatalf(\"expected %d packet to be dropped\", halfHtlcs)\n\t}\n\n\t// Wait until Alice reprocesses the last two HTLCs and sends them via\n\t// the peer.\n\talice.checkSent(addPkts[halfHtlcs:])\n\n\t// Her bandwidth should now reflect having sent only those two HTLCs.\n\tassertLinkBandwidth(t, alice.link,\n\t\taliceStartingBandwidth-halfHtlcs*(htlcAmt+htlcFee),\n\t)\n\n\t// Now, initiate a state transition for Alice. Since we are hodl.Commit\n\t// mode, this will only open the circuits that were added to the\n\t// in-memory channel state.\n\talice.trySignNextCommitment()\n\talice.assertNumPendingNumOpenCircuits(4, 2)\n\n\t// Finally, do one last restart of both the link and switch. This will\n\t// flush the HTLCs from the mailbox. The circuits should now be trimmed\n\t// for all of the HTLCs.\n\talice.restart(true, false, hodl.Commit)\n\n\talice.assertNumPendingNumOpenCircuits(4, 0)\n\n\t// Bob should not receive any HTLCs from Alice, as none of the HTLCs are\n\t// in Alice's mailbox, and channel reestablishment is disabled.\n\tselect {\n\tcase <-alice.msgs:\n\t\tt.Fatalf(\"received unexpected message from Alice\")\n\tcase <-time.After(time.Second):\n\t}\n\n\t// Attempt to commit the last two circuits, both should now fail since\n\t// though they were opened before shutting down, the circuits have been\n\t// properly trimmed.\n\tfwdActions = alice.commitCircuits(circuits[halfHtlcs:])\n\tif len(fwdActions.Fails) != halfHtlcs {\n\t\tt.Fatalf(\"expected %d packet to be failed\", halfHtlcs)\n\t}\n\n\t// Alice balance should not have changed since the start.\n\tassertLinkBandwidth(t, alice.link, aliceStartingBandwidth)\n}\n\n// TestChannelLinkTrimCircuitsRemoteCommit checks that the switch and link\n// don't trim circuits if the ADD is locked in on the remote commitment but\n// not on our local commitment.",
      "length": 9243,
      "tokens": 1278,
      "embedding": []
    },
    {
      "slug": "func TestChannelLinkTrimCircuitsRemoteCommit(t *testing.T) {",
      "content": "func TestChannelLinkTrimCircuitsRemoteCommit(t *testing.T) {\n\tt.Parallel()\n\n\tconst (\n\t\tchanAmt  = btcutil.SatoshiPerBitcoin * 5\n\t\tnumHtlcs = 2\n\t)\n\n\t// We'll start by creating a new link with our chanAmt (5 BTC).\n\taliceLink, bobChan, batchTicker, start, restore, err :=\n\t\tnewSingleLinkTestHarness(t, chanAmt, 0)\n\trequire.NoError(t, err, \"unable to create link\")\n\n\tif err := start(); err != nil {\n\t\tt.Fatalf(\"unable to start test harness: %v\", err)\n\t}\n\n\talice := newPersistentLinkHarness(\n\t\tt, aliceLink, batchTicker, restore,\n\t)\n\n\t// Compute the static fees that will be used to determine the\n\t// correctness of Alice's bandwidth when forwarding HTLCs.\n\testimator := chainfee.NewStaticEstimator(6000, 0)\n\tfeePerKw, err := estimator.EstimateFeePerKW(1)\n\trequire.NoError(t, err, \"unable to query fee estimator\")\n\n\tdefaultCommitFee := alice.channel.StateSnapshot().CommitFee\n\thtlcFee := lnwire.NewMSatFromSatoshis(\n\t\tfeePerKw.FeeForWeight(input.HTLCWeight),\n\t)\n\n\t// The starting bandwidth of the channel should be exactly the amount\n\t// that we created the channel between her and Bob, minus the commitment\n\t// fee and fee of adding an HTLC.\n\texpectedBandwidth := lnwire.NewMSatFromSatoshis(\n\t\tchanAmt-defaultCommitFee,\n\t) - htlcFee\n\tassertLinkBandwidth(t, alice.link, expectedBandwidth)\n\n\t// Capture Alice's starting bandwidth to perform later, relative\n\t// bandwidth assertions.\n\taliceStartingBandwidth := alice.link.Bandwidth()\n\n\t// Next, we'll create an HTLC worth 1 BTC that will be used as a dummy\n\t// message for the test.\n\tvar mockBlob [lnwire.OnionPacketSize]byte\n\thtlcAmt := lnwire.NewMSatFromSatoshis(btcutil.SatoshiPerBitcoin)\n\t_, htlc, _, err := generatePayment(htlcAmt, htlcAmt, 5, mockBlob)\n\trequire.NoError(t, err, \"unable to create payment\")\n\n\t// Create `numHtlc` htlcPackets and payment circuits that will be used\n\t// to drive the test. All of the packets will use the same dummy HTLC.\n\taddPkts, circuits := genAddsAndCircuits(numHtlcs, htlc)\n\n\t// To begin the test, start by committing the circuits for our first two\n\t// HTLCs.\n\tfwdActions := alice.commitCircuits(circuits)\n\n\t// Both of these circuits should have successfully added, as this is the\n\t// first attempt to send them.\n\tif len(fwdActions.Adds) != numHtlcs {\n\t\tt.Fatalf(\"expected %d circuits to be added\", numHtlcs)\n\t}\n\talice.assertNumPendingNumOpenCircuits(2, 0)\n\n\t// Since both were committed successfully, we will now deliver them to\n\t// Alice's link.\n\tfor _, addPkt := range addPkts {\n\t\tif err := alice.link.handleSwitchPacket(addPkt); err != nil {\n\t\t\tt.Fatalf(\"unable to handle switch packet: %v\", err)\n\t\t}\n\t}\n\n\t// Wait until Alice's link has sent both HTLCs via the peer.\n\talice.checkSent(addPkts)\n\n\t// Pass both of the htlcs to Bob.\n\tfor i, addPkt := range addPkts {\n\t\tpkt, ok := addPkt.htlc.(*lnwire.UpdateAddHTLC)\n\t\tif !ok {\n\t\t\tt.Fatalf(\"unable to add packet\")\n\t\t}\n\n\t\tpkt.ID = uint64(i)\n\n\t\t_, err := bobChan.ReceiveHTLC(pkt)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to receive htlc: %v\", err)\n\t\t}\n\t}\n\n\t// The resulting bandwidth should reflect that Alice is paying both\n\t// htlc amounts, in addition to both htlc fees.\n\tassertLinkBandwidth(t, alice.link,\n\t\taliceStartingBandwidth-numHtlcs*(htlcAmt+htlcFee),\n\t)\n\n\t// Now, initiate a state transition by Alice so that the pending HTLCs\n\t// are locked in.\n\talice.trySignNextCommitment()\n\talice.assertNumPendingNumOpenCircuits(2, 2)\n\n\tselect {\n\tcase aliceMsg := <-alice.msgs:\n\t\t// Pass the commitment signature to Bob.\n\t\tsig, ok := aliceMsg.(*lnwire.CommitSig)\n\t\tif !ok {\n\t\t\tt.Fatalf(\"alice did not send commitment signature\")\n\t\t}\n\n\t\terr := bobChan.ReceiveNewCommitment(sig.CommitSig, sig.HtlcSigs)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to receive new commitment: %v\", err)\n\t\t}\n\tcase <-time.After(time.Second):\n\t}\n\n\t// Next, revoke Bob's current commitment and send it to Alice so that we\n\t// can test that Alice's circuits aren't trimmed.\n\trev, _, _, err := bobChan.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"unable to revoke current commitment\")\n\n\t_, _, _, _, err = alice.channel.ReceiveRevocation(rev)\n\trequire.NoError(t, err, \"unable to receive revocation\")\n\n\t// Restart Alice's link, which simulates a disconnection with the remote\n\t// peer.\n\talice.restart(false, false)\n\n\talice.assertNumPendingNumOpenCircuits(2, 2)\n\n\t// Restart the link + switch and check that the number of open circuits\n\t// doesn't change.\n\talice.restart(true, false)\n\n\talice.assertNumPendingNumOpenCircuits(2, 2)\n}\n\n// TestChannelLinkBandwidthChanReserve checks that the bandwidth available\n// on the channel link reflects the channel reserve that must be kept\n// at all times.",
      "length": 4390,
      "tokens": 593,
      "embedding": []
    },
    {
      "slug": "func TestChannelLinkBandwidthChanReserve(t *testing.T) {",
      "content": "func TestChannelLinkBandwidthChanReserve(t *testing.T) {\n\tt.Parallel()\n\n\t// First start a link that has a balance greater than it's\n\t// channel reserve.\n\tconst chanAmt = btcutil.SatoshiPerBitcoin * 5\n\tconst chanReserve = btcutil.SatoshiPerBitcoin * 1\n\taliceLink, bobChannel, batchTimer, start, _, err :=\n\t\tnewSingleLinkTestHarness(t, chanAmt, chanReserve)\n\trequire.NoError(t, err, \"unable to create link\")\n\n\tif err := start(); err != nil {\n\t\tt.Fatalf(\"unable to start test harness: %v\", err)\n\t}\n\n\tvar (\n\t\tmockBlob               [lnwire.OnionPacketSize]byte\n\t\tcoreLink               = aliceLink.(*channelLink)\n\t\tcoreChan               = coreLink.channel\n\t\tdefaultCommitFee       = coreChan.StateSnapshot().CommitFee\n\t\taliceStartingBandwidth = aliceLink.Bandwidth()\n\t\taliceMsgs              = coreLink.cfg.Peer.(*mockPeer).sentMsgs\n\t)\n\n\testimator := chainfee.NewStaticEstimator(6000, 0)\n\tfeePerKw, err := estimator.EstimateFeePerKW(1)\n\trequire.NoError(t, err, \"unable to query fee estimator\")\n\thtlcFee := lnwire.NewMSatFromSatoshis(\n\t\tfeePerKw.FeeForWeight(input.HTLCWeight),\n\t)\n\n\t// The starting bandwidth of the channel should be exactly the amount\n\t// that we created the channel between her and Bob, minus the channel\n\t// reserve, commitment fee and fee for adding an additional HTLC.\n\texpectedBandwidth := lnwire.NewMSatFromSatoshis(\n\t\tchanAmt-defaultCommitFee-chanReserve) - htlcFee\n\tassertLinkBandwidth(t, aliceLink, expectedBandwidth)\n\n\t// Next, we'll create an HTLC worth 3 BTC, and send it into the link as\n\t// a switch initiated payment.  The resulting bandwidth should\n\t// now be decremented to reflect the new HTLC.\n\thtlcAmt := lnwire.NewMSatFromSatoshis(3 * btcutil.SatoshiPerBitcoin)\n\tinvoice, htlc, _, err := generatePayment(htlcAmt, htlcAmt, 5, mockBlob)\n\trequire.NoError(t, err, \"unable to create payment\")\n\n\taddPkt := &htlcPacket{\n\t\thtlc:       htlc,\n\t\tobfuscator: NewMockObfuscator(),\n\t}\n\tcircuit := makePaymentCircuit(&htlc.PaymentHash, addPkt)\n\t_, err = coreLink.cfg.Switch.commitCircuits(&circuit)\n\trequire.NoError(t, err, \"unable to commit circuit\")\n\n\t_ = aliceLink.handleSwitchPacket(addPkt)\n\ttime.Sleep(time.Millisecond * 100)\n\tassertLinkBandwidth(t, aliceLink, aliceStartingBandwidth-htlcAmt-htlcFee)\n\n\t// Alice should send the HTLC to Bob.\n\tvar msg lnwire.Message\n\tselect {\n\tcase msg = <-aliceMsgs:\n\tcase <-time.After(15 * time.Second):\n\t\tt.Fatalf(\"did not receive message\")\n\t}\n\n\taddHtlc, ok := msg.(*lnwire.UpdateAddHTLC)\n\tif !ok {\n\t\tt.Fatalf(\"expected UpdateAddHTLC, got %T\", msg)\n\t}\n\n\tbobIndex, err := bobChannel.ReceiveHTLC(addHtlc)\n\trequire.NoError(t, err, \"bob failed receiving htlc\")\n\n\t// Lock in the HTLC.\n\tif err := updateState(batchTimer, coreLink, bobChannel, true); err != nil {\n\t\tt.Fatalf(\"unable to update state: %v\", err)\n\t}\n\n\tassertLinkBandwidth(t, aliceLink, aliceStartingBandwidth-htlcAmt-htlcFee)\n\n\t// If we now send in a valid HTLC settle for the prior HTLC we added,\n\t// then the bandwidth should remain unchanged as the remote party will\n\t// gain additional channel balance.\n\terr = bobChannel.SettleHTLC(*invoice.Terms.PaymentPreimage, bobIndex, nil, nil, nil)\n\trequire.NoError(t, err, \"unable to settle htlc\")\n\thtlcSettle := &lnwire.UpdateFulfillHTLC{\n\t\tID:              bobIndex,\n\t\tPaymentPreimage: *invoice.Terms.PaymentPreimage,\n\t}\n\taliceLink.HandleChannelUpdate(htlcSettle)\n\ttime.Sleep(time.Millisecond * 500)\n\n\t// Since the settle is not locked in yet, Alice's bandwidth should still\n\t// reflect that she has to pay the fee.\n\tassertLinkBandwidth(t, aliceLink, aliceStartingBandwidth-htlcAmt-htlcFee)\n\n\t// Lock in the settle.\n\tif err := updateState(batchTimer, coreLink, bobChannel, false); err != nil {\n\t\tt.Fatalf(\"unable to update state: %v\", err)\n\t}\n\n\ttime.Sleep(time.Millisecond * 100)\n\tassertLinkBandwidth(t, aliceLink, aliceStartingBandwidth-htlcAmt)\n\n\t// Now we create a channel that has a channel reserve that is\n\t// greater than it's balance. In these case only payments can\n\t// be received on this channel, not sent. The available bandwidth\n\t// should therefore be 0.\n\tconst bobChanAmt = btcutil.SatoshiPerBitcoin * 1\n\tconst bobChanReserve = btcutil.SatoshiPerBitcoin * 1.5\n\tbobLink, _, _, start, _, err :=\n\t\tnewSingleLinkTestHarness(t, bobChanAmt, bobChanReserve)\n\trequire.NoError(t, err, \"unable to create link\")\n\n\tif err := start(); err != nil {\n\t\tt.Fatalf(\"unable to start test harness: %v\", err)\n\t}\n\n\t// Make sure bandwidth is reported as 0.\n\tassertLinkBandwidth(t, bobLink, 0)\n}\n\n// TestChannelRetransmission tests the ability of the channel links to\n// synchronize theirs states after abrupt disconnect.",
      "length": 4394,
      "tokens": 530,
      "embedding": []
    },
    {
      "slug": "func TestChannelRetransmission(t *testing.T) {",
      "content": "func TestChannelRetransmission(t *testing.T) {\n\tt.Parallel()\n\n\tretransmissionTests := []struct {\n\t\tname     string\n\t\tmessages []expectedMessage\n\t}{\n\t\t{\n\t\t\t// Tests the ability of the channel links states to be\n\t\t\t// synchronized after remote node haven't receive\n\t\t\t// revoke and ack message.\n\t\t\tname: \"intercept last alice revoke_and_ack\",\n\t\t\tmessages: []expectedMessage{\n\t\t\t\t// First initialization of the channel.\n\t\t\t\t{\"alice\", \"bob\", &lnwire.ChannelReestablish{}, false},\n\t\t\t\t{\"bob\", \"alice\", &lnwire.ChannelReestablish{}, false},\n\n\t\t\t\t{\"alice\", \"bob\", &lnwire.FundingLocked{}, false},\n\t\t\t\t{\"bob\", \"alice\", &lnwire.FundingLocked{}, false},\n\n\t\t\t\t// Send payment from Alice to Bob and intercept\n\t\t\t\t// the last revocation message, in this case\n\t\t\t\t// Bob should not proceed the payment farther.\n\t\t\t\t{\"alice\", \"bob\", &lnwire.UpdateAddHTLC{}, false},\n\t\t\t\t{\"alice\", \"bob\", &lnwire.CommitSig{}, false},\n\t\t\t\t{\"bob\", \"alice\", &lnwire.RevokeAndAck{}, false},\n\t\t\t\t{\"bob\", \"alice\", &lnwire.CommitSig{}, false},\n\t\t\t\t{\"alice\", \"bob\", &lnwire.RevokeAndAck{}, true},\n\n\t\t\t\t// Reestablish messages exchange on nodes restart.\n\t\t\t\t{\"alice\", \"bob\", &lnwire.ChannelReestablish{}, false},\n\t\t\t\t{\"bob\", \"alice\", &lnwire.ChannelReestablish{}, false},\n\n\t\t\t\t// Alice should resend the revoke_and_ack\n\t\t\t\t// message to Bob because Bob claimed it in the\n\t\t\t\t// re-establish message.\n\t\t\t\t{\"alice\", \"bob\", &lnwire.RevokeAndAck{}, false},\n\n\t\t\t\t// Proceed the payment farther by sending the\n\t\t\t\t// fulfillment message and trigger the state\n\t\t\t\t// update.\n\t\t\t\t{\"bob\", \"alice\", &lnwire.UpdateFulfillHTLC{}, false},\n\t\t\t\t{\"bob\", \"alice\", &lnwire.CommitSig{}, false},\n\t\t\t\t{\"alice\", \"bob\", &lnwire.RevokeAndAck{}, false},\n\t\t\t\t{\"alice\", \"bob\", &lnwire.CommitSig{}, false},\n\t\t\t\t{\"bob\", \"alice\", &lnwire.RevokeAndAck{}, false},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t// Tests the ability of the channel links states to be\n\t\t\t// synchronized after remote node haven't receive\n\t\t\t// revoke and ack message.\n\t\t\tname: \"intercept bob revoke_and_ack commit_sig messages\",\n\t\t\tmessages: []expectedMessage{\n\t\t\t\t{\"alice\", \"bob\", &lnwire.ChannelReestablish{}, false},\n\t\t\t\t{\"bob\", \"alice\", &lnwire.ChannelReestablish{}, false},\n\n\t\t\t\t{\"alice\", \"bob\", &lnwire.FundingLocked{}, false},\n\t\t\t\t{\"bob\", \"alice\", &lnwire.FundingLocked{}, false},\n\n\t\t\t\t// Send payment from Alice to Bob and intercept\n\t\t\t\t// the last revocation message, in this case\n\t\t\t\t// Bob should not proceed the payment farther.\n\t\t\t\t{\"alice\", \"bob\", &lnwire.UpdateAddHTLC{}, false},\n\t\t\t\t{\"alice\", \"bob\", &lnwire.CommitSig{}, false},\n\n\t\t\t\t// Intercept bob commit sig and revoke and ack\n\t\t\t\t// messages.\n\t\t\t\t{\"bob\", \"alice\", &lnwire.RevokeAndAck{}, true},\n\t\t\t\t{\"bob\", \"alice\", &lnwire.CommitSig{}, true},\n\n\t\t\t\t// Reestablish messages exchange on nodes restart.\n\t\t\t\t{\"alice\", \"bob\", &lnwire.ChannelReestablish{}, false},\n\t\t\t\t{\"bob\", \"alice\", &lnwire.ChannelReestablish{}, false},\n\n\t\t\t\t// Bob should resend previously intercepted messages.\n\t\t\t\t{\"bob\", \"alice\", &lnwire.RevokeAndAck{}, false},\n\t\t\t\t{\"bob\", \"alice\", &lnwire.CommitSig{}, false},\n\n\t\t\t\t// Proceed the payment farther by sending the\n\t\t\t\t// fulfillment message and trigger the state\n\t\t\t\t// update.\n\t\t\t\t{\"alice\", \"bob\", &lnwire.RevokeAndAck{}, false},\n\t\t\t\t{\"bob\", \"alice\", &lnwire.UpdateFulfillHTLC{}, false},\n\t\t\t\t{\"bob\", \"alice\", &lnwire.CommitSig{}, false},\n\t\t\t\t{\"alice\", \"bob\", &lnwire.RevokeAndAck{}, false},\n\t\t\t\t{\"alice\", \"bob\", &lnwire.CommitSig{}, false},\n\t\t\t\t{\"bob\", \"alice\", &lnwire.RevokeAndAck{}, false},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t// Tests the ability of the channel links states to be\n\t\t\t// synchronized after remote node haven't receive\n\t\t\t// update and commit sig messages.\n\t\t\tname: \"intercept update add htlc and commit sig messages\",\n\t\t\tmessages: []expectedMessage{\n\t\t\t\t{\"alice\", \"bob\", &lnwire.ChannelReestablish{}, false},\n\t\t\t\t{\"bob\", \"alice\", &lnwire.ChannelReestablish{}, false},\n\n\t\t\t\t{\"alice\", \"bob\", &lnwire.FundingLocked{}, false},\n\t\t\t\t{\"bob\", \"alice\", &lnwire.FundingLocked{}, false},\n\n\t\t\t\t// Attempt make a payment from Alice to Bob,\n\t\t\t\t// which is intercepted, emulating the Bob\n\t\t\t\t// server abrupt stop.\n\t\t\t\t{\"alice\", \"bob\", &lnwire.UpdateAddHTLC{}, true},\n\t\t\t\t{\"alice\", \"bob\", &lnwire.CommitSig{}, true},\n\n\t\t\t\t// Restart of the nodes, and after that nodes\n\t\t\t\t// should exchange the reestablish messages.\n\t\t\t\t{\"alice\", \"bob\", &lnwire.ChannelReestablish{}, false},\n\t\t\t\t{\"bob\", \"alice\", &lnwire.ChannelReestablish{}, false},\n\n\t\t\t\t{\"alice\", \"bob\", &lnwire.FundingLocked{}, false},\n\t\t\t\t{\"bob\", \"alice\", &lnwire.FundingLocked{}, false},\n\n\t\t\t\t// After Bob has notified Alice that he didn't\n\t\t\t\t// receive updates Alice should re-send them.\n\t\t\t\t{\"alice\", \"bob\", &lnwire.UpdateAddHTLC{}, false},\n\t\t\t\t{\"alice\", \"bob\", &lnwire.CommitSig{}, false},\n\n\t\t\t\t{\"bob\", \"alice\", &lnwire.RevokeAndAck{}, false},\n\t\t\t\t{\"bob\", \"alice\", &lnwire.CommitSig{}, false},\n\t\t\t\t{\"alice\", \"bob\", &lnwire.RevokeAndAck{}, false},\n\n\t\t\t\t{\"bob\", \"alice\", &lnwire.UpdateFulfillHTLC{}, false},\n\t\t\t\t{\"bob\", \"alice\", &lnwire.CommitSig{}, false},\n\t\t\t\t{\"alice\", \"bob\", &lnwire.RevokeAndAck{}, false},\n\t\t\t\t{\"alice\", \"bob\", &lnwire.CommitSig{}, false},\n\t\t\t\t{\"bob\", \"alice\", &lnwire.RevokeAndAck{}, false},\n\t\t\t},\n\t\t},\n\t}\n\tpaymentWithRestart := func(t *testing.T, messages []expectedMessage) {\n\t\tchannels, restoreChannelsFromDb, err := createClusterChannels(\n\t\t\tt, btcutil.SatoshiPerBitcoin*5, btcutil.SatoshiPerBitcoin*5,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to create channel: %v\", err)\n\t\t}\n\n\t\tchanID := lnwire.NewChanIDFromOutPoint(channels.aliceToBob.ChannelPoint())\n\t\tserverErr := make(chan error, 4)\n\n\t\taliceInterceptor := createInterceptorFunc(\"[alice] <-- [bob]\",\n\t\t\t\"alice\", messages, chanID, false)\n\t\tbobInterceptor := createInterceptorFunc(\"[alice] --> [bob]\",\n\t\t\t\"bob\", messages, chanID, false)\n\n\t\tct := newConcurrentTester(t)\n\n\t\t// Add interceptor to check the order of Bob and Alice\n\t\t// messages.\n\t\tn := newThreeHopNetwork(ct,\n\t\t\tchannels.aliceToBob, channels.bobToAlice,\n\t\t\tchannels.bobToCarol, channels.carolToBob,\n\t\t\ttestStartingHeight,\n\t\t)\n\t\tn.aliceServer.intersect(aliceInterceptor)\n\t\tn.bobServer.intersect(bobInterceptor)\n\t\tif err := n.start(); err != nil {\n\t\t\tct.Fatalf(\"unable to start three hop network: %v\", err)\n\t\t}\n\t\tt.Cleanup(n.stop)\n\n\t\tbobBandwidthBefore := n.firstBobChannelLink.Bandwidth()\n\t\taliceBandwidthBefore := n.aliceChannelLink.Bandwidth()\n\n\t\tamount := lnwire.NewMSatFromSatoshis(btcutil.SatoshiPerBitcoin)\n\t\thtlcAmt, totalTimelock, hops := generateHops(amount, testStartingHeight,\n\t\t\tn.firstBobChannelLink)\n\n\t\t// Send payment which should fail because we intercept the\n\t\t// update and commit messages.\n\t\t//\n\t\t// TODO(roasbeef); increase timeout?\n\t\treceiver := n.bobServer\n\t\tfirstHop := n.firstBobChannelLink.ShortChanID()\n\t\trhash, err := makePayment(\n\t\t\tn.aliceServer, receiver, firstHop, hops, amount,\n\t\t\thtlcAmt, totalTimelock,\n\t\t).Wait(time.Second * 5)\n\t\tif err == nil {\n\t\t\tct.Fatalf(\"payment shouldn't haven been finished\")\n\t\t}\n\n\t\t// Stop network cluster and create new one, with the old\n\t\t// channels states. Also do the *hack* - save the payment\n\t\t// receiver to pass it in new channel link, otherwise payment\n\t\t// will be failed because of the unknown payment hash. Hack\n\t\t// will be removed with sphinx payment.\n\t\tbobRegistry := n.bobServer.registry\n\t\tn.stop()\n\n\t\tchannels, err = restoreChannelsFromDb()\n\t\tif err != nil {\n\t\t\tct.Fatalf(\"unable to restore channels from database: %v\", err)\n\t\t}\n\n\t\tn = newThreeHopNetwork(ct, channels.aliceToBob, channels.bobToAlice,\n\t\t\tchannels.bobToCarol, channels.carolToBob, testStartingHeight)\n\t\tn.firstBobChannelLink.cfg.Registry = bobRegistry\n\t\tn.aliceServer.intersect(aliceInterceptor)\n\t\tn.bobServer.intersect(bobInterceptor)\n\n\t\tif err := n.start(); err != nil {\n\t\t\tct.Fatalf(\"unable to start three hop network: %v\", err)\n\t\t}\n\t\tt.Cleanup(n.stop)\n\n\t\t// Wait for reestablishment to be proceeded and invoice to be settled.\n\t\t// TODO(andrew.shvv) Will be removed if we move the notification center\n\t\t// to the channel link itself.\n\n\t\tvar invoice invpkg.Invoice\n\t\tfor i := 0; i < 20; i++ {\n\t\t\tselect {\n\t\t\tcase <-time.After(time.Millisecond * 200):\n\t\t\tcase serverErr := <-serverErr:\n\t\t\t\tct.Fatalf(\"server error: %v\", serverErr)\n\t\t\t}\n\n\t\t\t// Check that alice invoice wasn't settled and\n\t\t\t// bandwidth of htlc links hasn't been changed.\n\t\t\tinvoice, err = receiver.registry.LookupInvoice(rhash)\n\t\t\tif err != nil {\n\t\t\t\terr = errors.Errorf(\"unable to get invoice: %v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif invoice.State != invpkg.ContractSettled {\n\t\t\t\terr = errors.Errorf(\"alice invoice haven't been settled\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\taliceExpectedBandwidth := aliceBandwidthBefore - htlcAmt\n\t\t\tif aliceExpectedBandwidth != n.aliceChannelLink.Bandwidth() {\n\t\t\t\terr = errors.Errorf(\"expected alice to have %v, instead has %v\",\n\t\t\t\t\taliceExpectedBandwidth, n.aliceChannelLink.Bandwidth())\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tbobExpectedBandwidth := bobBandwidthBefore + htlcAmt\n\t\t\tif bobExpectedBandwidth != n.firstBobChannelLink.Bandwidth() {\n\t\t\t\terr = errors.Errorf(\"expected bob to have %v, instead has %v\",\n\t\t\t\t\tbobExpectedBandwidth, n.firstBobChannelLink.Bandwidth())\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tbreak\n\t\t}\n\n\t\tif err != nil {\n\t\t\tct.Fatal(err)\n\t\t}\n\t}\n\n\tfor _, test := range retransmissionTests {\n\t\tpassed := t.Run(test.name, func(t *testing.T) {\n\t\t\tpaymentWithRestart(t, test.messages)\n\t\t})\n\n\t\tif !passed {\n\t\t\tbreak\n\t\t}\n\t}\n\n}\n\n// TestShouldAdjustCommitFee tests the shouldAdjustCommitFee pivot function to\n// ensure that ie behaves properly. We should only update the fee if it\n// deviates from our current fee by more 10% or more.",
      "length": 9183,
      "tokens": 1017,
      "embedding": []
    },
    {
      "slug": "func TestShouldAdjustCommitFee(t *testing.T) {",
      "content": "func TestShouldAdjustCommitFee(t *testing.T) {\n\ttests := []struct {\n\t\tnetFee       chainfee.SatPerKWeight\n\t\tchanFee      chainfee.SatPerKWeight\n\t\tminRelayFee  chainfee.SatPerKWeight\n\t\tshouldAdjust bool\n\t}{\n\n\t\t// The network fee is 3x lower than the current commitment\n\t\t// transaction. As a result, we should adjust our fee to match\n\t\t// it.\n\t\t{\n\t\t\tnetFee:       100,\n\t\t\tchanFee:      3000,\n\t\t\tshouldAdjust: true,\n\t\t},\n\n\t\t// The network fee is lower than the current commitment fee,\n\t\t// but only slightly so, so we won't update the commitment fee.\n\t\t{\n\t\t\tnetFee:       2999,\n\t\t\tchanFee:      3000,\n\t\t\tshouldAdjust: false,\n\t\t},\n\n\t\t// The network fee is lower than the commitment fee, but only\n\t\t// right before it crosses our current threshold.\n\t\t{\n\t\t\tnetFee:       1000,\n\t\t\tchanFee:      1099,\n\t\t\tshouldAdjust: false,\n\t\t},\n\n\t\t// The network fee is lower than the commitment fee, and within\n\t\t// our range of adjustment, so we should adjust.\n\t\t{\n\t\t\tnetFee:       1000,\n\t\t\tchanFee:      1100,\n\t\t\tshouldAdjust: true,\n\t\t},\n\n\t\t// The network fee is 2x higher than our commitment fee, so we\n\t\t// should adjust upwards.\n\t\t{\n\t\t\tnetFee:       2000,\n\t\t\tchanFee:      1000,\n\t\t\tshouldAdjust: true,\n\t\t},\n\n\t\t// The network fee is higher than our commitment fee, but only\n\t\t// slightly so, so we won't update.\n\t\t{\n\t\t\tnetFee:       1001,\n\t\t\tchanFee:      1000,\n\t\t\tshouldAdjust: false,\n\t\t},\n\n\t\t// The network fee is higher than our commitment fee, but\n\t\t// hasn't yet crossed our activation threshold.\n\t\t{\n\t\t\tnetFee:       1100,\n\t\t\tchanFee:      1099,\n\t\t\tshouldAdjust: false,\n\t\t},\n\n\t\t// The network fee is higher than our commitment fee, and\n\t\t// within our activation threshold, so we should update our\n\t\t// fee.\n\t\t{\n\t\t\tnetFee:       1100,\n\t\t\tchanFee:      1000,\n\t\t\tshouldAdjust: true,\n\t\t},\n\n\t\t// Our fees match exactly, so we shouldn't update it at all.\n\t\t{\n\t\t\tnetFee:       1000,\n\t\t\tchanFee:      1000,\n\t\t\tshouldAdjust: false,\n\t\t},\n\n\t\t// The network fee is higher than our commitment fee,\n\t\t// hasn't yet crossed our activation threshold, but the\n\t\t// current commitment fee is below the minimum relay fee and\n\t\t// so the fee should be updated.\n\t\t{\n\t\t\tnetFee:       1100,\n\t\t\tchanFee:      1098,\n\t\t\tminRelayFee:  1099,\n\t\t\tshouldAdjust: true,\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\tadjustedFee := shouldAdjustCommitFee(\n\t\t\ttest.netFee, test.chanFee, test.minRelayFee,\n\t\t)\n\n\t\tif adjustedFee && !test.shouldAdjust {\n\t\t\tt.Fatalf(\"test #%v failed: net_fee=%v, \"+\n\t\t\t\t\"chan_fee=%v, adjust_expect=%v, adjust_returned=%v\",\n\t\t\t\ti, test.netFee, test.chanFee, test.shouldAdjust,\n\t\t\t\tadjustedFee)\n\t\t}\n\t}\n}\n\n// TestChannelLinkShutdownDuringForward asserts that a link can be fully\n// stopped when it is trying to send synchronously through the switch. The\n// specific case this can occur is when a link forwards incoming Adds. We test\n// this by forcing the switch into a state where it will not accept new packets,\n// and then killing the link, which can only succeed if forwarding can be\n// canceled by a call to Stop.",
      "length": 2837,
      "tokens": 420,
      "embedding": []
    },
    {
      "slug": "func TestChannelLinkShutdownDuringForward(t *testing.T) {",
      "content": "func TestChannelLinkShutdownDuringForward(t *testing.T) {\n\tt.Parallel()\n\n\t// First, we'll create our traditional three hop network. We're\n\t// interested in testing the ability to stop the link when it is\n\t// synchronously forwarding to the switch, which happens when an\n\t// incoming link forwards Adds. Thus, the test will be performed\n\t// against Bob's first link.\n\tchannels, _, err := createClusterChannels(\n\t\tt, btcutil.SatoshiPerBitcoin*3, btcutil.SatoshiPerBitcoin*5,\n\t)\n\trequire.NoError(t, err, \"unable to create channel\")\n\n\tn := newThreeHopNetwork(t, channels.aliceToBob, channels.bobToAlice,\n\t\tchannels.bobToCarol, channels.carolToBob, testStartingHeight)\n\n\tif err := n.start(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Cleanup(n.stop)\n\tdefer n.feeEstimator.Stop()\n\n\t// Define a helper method that strobes the switch's log ticker, and\n\t// unblocks after nothing has been pulled for two seconds.\n\twaitForBobsSwitchToBlock := func() {\n\t\tbobSwitch := n.firstBobChannelLink.cfg.Switch\n\t\tticker := bobSwitch.cfg.LogEventTicker.(*ticker.Force)\n\t\ttimeout := time.After(15 * time.Second)\n\t\tfor {\n\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t\tselect {\n\t\t\tcase ticker.Force <- time.Now():\n\n\t\t\tcase <-time.After(2 * time.Second):\n\t\t\t\treturn\n\n\t\t\tcase <-timeout:\n\t\t\t\tt.Fatalf(\"switch did not block\")\n\t\t\t}\n\t\t}\n\t}\n\n\t// Define a helper method that strobes the link's batch ticker, and\n\t// unblocks after nothing has been pulled for two seconds.\n\twaitForBobsIncomingLinkToBlock := func() {\n\t\tticker := n.firstBobChannelLink.cfg.BatchTicker.(*ticker.Force)\n\t\ttimeout := time.After(15 * time.Second)\n\t\tfor {\n\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t\tselect {\n\t\t\tcase ticker.Force <- time.Now():\n\n\t\t\tcase <-time.After(2 * time.Second):\n\t\t\t\t// We'll give a little extra time here, to\n\t\t\t\t// ensure that the packet is being pressed\n\t\t\t\t// against the htlcPlex.\n\t\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t\t\treturn\n\n\t\t\tcase <-timeout:\n\t\t\t\tt.Fatalf(\"link did not block\")\n\t\t\t}\n\t\t}\n\t}\n\n\t// To test that the cancellation is happening properly, we will set the\n\t// switch's htlcPlex to nil, so that calls to routeAsync block, and can\n\t// only exit if the link (or switch) is exiting. We will only be testing\n\t// the link here.\n\t//\n\t// In order to avoid data races, we need to ensure the switch isn't\n\t// selecting on that channel in the meantime. We'll prevent this by\n\t// first acquiring the index mutex and forcing a log event so that the\n\t// htlcForwarder is blocked inside the logTicker case, which also needs\n\t// the indexMtx.\n\tn.firstBobChannelLink.cfg.Switch.indexMtx.Lock()\n\n\t// Strobe the log ticker, and wait for switch to stop accepting any more\n\t// log ticks.\n\twaitForBobsSwitchToBlock()\n\n\t// While the htlcForwarder is blocked, swap out the htlcPlex with a nil\n\t// channel, and unlock the indexMtx to allow return to the\n\t// htlcForwarder's main select. After this, any attempt to forward\n\t// through the switch will block.\n\tn.firstBobChannelLink.cfg.Switch.htlcPlex = nil\n\tn.firstBobChannelLink.cfg.Switch.indexMtx.Unlock()\n\n\t// Now, make a payment from Alice to Carol, which should cause Bob's\n\t// incoming link to block when it tries to submit the packet to the nil\n\t// htlcPlex.\n\tamount := lnwire.NewMSatFromSatoshis(btcutil.SatoshiPerBitcoin)\n\thtlcAmt, totalTimelock, hops := generateHops(\n\t\tamount, testStartingHeight,\n\t\tn.firstBobChannelLink, n.carolChannelLink,\n\t)\n\n\tfirstHop := n.firstBobChannelLink.ShortChanID()\n\tmakePayment(\n\t\tn.aliceServer, n.carolServer, firstHop, hops, amount, htlcAmt,\n\t\ttotalTimelock,\n\t)\n\n\t// Strobe the batch ticker of Bob's incoming link, waiting for it to\n\t// become fully blocked.\n\twaitForBobsIncomingLinkToBlock()\n\n\t// Finally, stop the link to test that it can exit while synchronously\n\t// forwarding Adds to the switch.\n\tdone := make(chan struct{})\n\tgo func() {\n\t\tn.firstBobChannelLink.Stop()\n\t\tclose(done)\n\t}()\n\n\tselect {\n\tcase <-time.After(3 * time.Second):\n\t\tt.Fatalf(\"unable to shutdown link while fwding incoming Adds\")\n\tcase <-done:\n\t}\n}\n\n// TestChannelLinkUpdateCommitFee tests that when a new block comes in, the\n// channel link properly checks to see if it should update the commitment fee.",
      "length": 3934,
      "tokens": 539,
      "embedding": []
    },
    {
      "slug": "func TestChannelLinkUpdateCommitFee(t *testing.T) {",
      "content": "func TestChannelLinkUpdateCommitFee(t *testing.T) {\n\tt.Parallel()\n\n\t// First, we'll create our traditional three hop network. We'll only be\n\t// interacting with and asserting the state of two of the end points\n\t// for this test.\n\tconst aliceInitialBalance = btcutil.SatoshiPerBitcoin * 3\n\tchannels, _, err := createClusterChannels(\n\t\tt, aliceInitialBalance, btcutil.SatoshiPerBitcoin*5,\n\t)\n\trequire.NoError(t, err, \"unable to create channel\")\n\n\tn := newThreeHopNetwork(t, channels.aliceToBob, channels.bobToAlice,\n\t\tchannels.bobToCarol, channels.carolToBob, testStartingHeight)\n\n\t// First, we'll set up some message interceptors to ensure that the\n\t// proper messages are sent when updating fees.\n\tchanID := n.aliceChannelLink.ChanID()\n\tmessages := []expectedMessage{\n\t\t{\"alice\", \"bob\", &lnwire.ChannelReestablish{}, false},\n\t\t{\"bob\", \"alice\", &lnwire.ChannelReestablish{}, false},\n\n\t\t{\"alice\", \"bob\", &lnwire.FundingLocked{}, false},\n\t\t{\"bob\", \"alice\", &lnwire.FundingLocked{}, false},\n\n\t\t// First fee update.\n\t\t{\"alice\", \"bob\", &lnwire.UpdateFee{}, false},\n\t\t{\"alice\", \"bob\", &lnwire.CommitSig{}, false},\n\t\t{\"bob\", \"alice\", &lnwire.RevokeAndAck{}, false},\n\t\t{\"bob\", \"alice\", &lnwire.CommitSig{}, false},\n\t\t{\"alice\", \"bob\", &lnwire.RevokeAndAck{}, false},\n\n\t\t// Second fee update.\n\t\t{\"alice\", \"bob\", &lnwire.UpdateFee{}, false},\n\t\t{\"alice\", \"bob\", &lnwire.CommitSig{}, false},\n\t\t{\"bob\", \"alice\", &lnwire.RevokeAndAck{}, false},\n\t\t{\"bob\", \"alice\", &lnwire.CommitSig{}, false},\n\t\t{\"alice\", \"bob\", &lnwire.RevokeAndAck{}, false},\n\n\t\t// Third fee update.\n\t\t{\"alice\", \"bob\", &lnwire.UpdateFee{}, false},\n\t\t{\"alice\", \"bob\", &lnwire.CommitSig{}, false},\n\t\t{\"bob\", \"alice\", &lnwire.RevokeAndAck{}, false},\n\t\t{\"bob\", \"alice\", &lnwire.CommitSig{}, false},\n\t\t{\"alice\", \"bob\", &lnwire.RevokeAndAck{}, false},\n\t}\n\tn.aliceServer.intersect(createInterceptorFunc(\"[alice] <-- [bob]\",\n\t\t\"alice\", messages, chanID, false))\n\tn.bobServer.intersect(createInterceptorFunc(\"[alice] --> [bob]\",\n\t\t\"bob\", messages, chanID, false))\n\n\tif err := n.start(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Cleanup(n.stop)\n\tdefer n.feeEstimator.Stop()\n\n\tstartingFeeRate := channels.aliceToBob.CommitFeeRate()\n\n\t// triggerFeeUpdate is a helper closure to determine whether a fee\n\t// update was triggered and completed properly.\n\ttriggerFeeUpdate := func(feeEstimate, minRelayFee,\n\t\tnewFeeRate chainfee.SatPerKWeight, shouldUpdate bool) {\n\n\t\tt.Helper()\n\n\t\t// Record the fee rates before the links process the fee update\n\t\t// to test the case where a fee update isn't triggered.\n\t\taliceBefore := channels.aliceToBob.CommitFeeRate()\n\t\tbobBefore := channels.bobToAlice.CommitFeeRate()\n\n\t\t// For the sake of this test, we'll reset the timer so that\n\t\t// Alice's link queries for a new network fee.\n\t\tn.aliceChannelLink.updateFeeTimer.Reset(time.Millisecond)\n\n\t\t// Next, we'll send the first fee rate response to Alice.\n\t\tselect {\n\t\tcase n.feeEstimator.byteFeeIn <- feeEstimate:\n\t\tcase <-time.After(time.Second * 5):\n\t\t\tt.Fatalf(\"alice didn't query for the new network fee\")\n\t\t}\n\n\t\t// We also send the min relay fee response to Alice.\n\t\tselect {\n\t\tcase n.feeEstimator.relayFee <- minRelayFee:\n\t\tcase <-time.After(time.Second * 5):\n\t\t\tt.Fatalf(\"alice didn't query for the min relay fee\")\n\t\t}\n\n\t\t// Record the fee rates after the links have processed the fee\n\t\t// update and ensure they are correct based on whether a fee\n\t\t// update should have been triggered.\n\t\trequire.Eventually(t, func() bool {\n\t\t\taliceAfter := channels.aliceToBob.CommitFeeRate()\n\t\t\tbobAfter := channels.bobToAlice.CommitFeeRate()\n\n\t\t\tswitch {\n\t\t\tcase shouldUpdate && aliceAfter != newFeeRate:\n\t\t\t\treturn false\n\n\t\t\tcase shouldUpdate && bobAfter != newFeeRate:\n\t\t\t\treturn false\n\n\t\t\tcase !shouldUpdate && aliceAfter != aliceBefore:\n\t\t\t\treturn false\n\n\t\t\tcase !shouldUpdate && bobAfter != bobBefore:\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\treturn true\n\t\t}, 10*time.Second, time.Second)\n\t}\n\n\tminRelayFee := startingFeeRate / 3\n\n\t// Triggering the link to update the fee of the channel with the same\n\t// fee rate should not send a fee update.\n\ttriggerFeeUpdate(startingFeeRate, minRelayFee, startingFeeRate, false)\n\n\t// Triggering the link to update the fee of the channel with a much\n\t// larger fee rate _should_ send a fee update.\n\tnewFeeRate := startingFeeRate * 3\n\ttriggerFeeUpdate(newFeeRate, minRelayFee, newFeeRate, true)\n\n\t// Triggering the link to update the fee of the channel with a fee rate\n\t// that exceeds its maximum fee allocation should result in a fee rate\n\t// corresponding to the maximum fee allocation.\n\tconst maxFeeRate chainfee.SatPerKWeight = 207180182\n\ttriggerFeeUpdate(maxFeeRate+1, minRelayFee, maxFeeRate, true)\n\n\t// Triggering the link to update the fee of the channel with a fee rate\n\t// that is below the current min relay fee rate should result in a fee\n\t// rate corresponding to the minimum relay fee.\n\tnewFeeRate = minRelayFee / 2\n\ttriggerFeeUpdate(newFeeRate, minRelayFee, minRelayFee, true)\n}\n\n// TestChannelLinkAcceptDuplicatePayment tests that if a link receives an\n// incoming HTLC for a payment we have already settled, then it accepts the\n// HTLC. We do this to simplify the processing of settles after restarts or\n// failures, reducing ambiguity when a batch is only partially processed.",
      "length": 5038,
      "tokens": 629,
      "embedding": []
    },
    {
      "slug": "func TestChannelLinkAcceptDuplicatePayment(t *testing.T) {",
      "content": "func TestChannelLinkAcceptDuplicatePayment(t *testing.T) {\n\tt.Parallel()\n\n\t// First, we'll create our traditional three hop network. We'll only be\n\t// interacting with and asserting the state of two of the end points\n\t// for this test.\n\tchannels, _, err := createClusterChannels(\n\t\tt, btcutil.SatoshiPerBitcoin*3, btcutil.SatoshiPerBitcoin*5,\n\t)\n\trequire.NoError(t, err, \"unable to create channel\")\n\n\tn := newThreeHopNetwork(t, channels.aliceToBob, channels.bobToAlice,\n\t\tchannels.bobToCarol, channels.carolToBob, testStartingHeight)\n\tif err := n.start(); err != nil {\n\t\tt.Fatalf(\"unable to start three hop network: %v\", err)\n\t}\n\tt.Cleanup(n.stop)\n\n\tamount := lnwire.NewMSatFromSatoshis(btcutil.SatoshiPerBitcoin)\n\n\t// We'll start off by making a payment from Alice to Carol. We'll\n\t// manually generate this request so we can control all the parameters.\n\thtlcAmt, totalTimelock, hops := generateHops(amount, testStartingHeight,\n\t\tn.firstBobChannelLink, n.carolChannelLink)\n\tblob, err := generateRoute(hops...)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tinvoice, htlc, pid, err := generatePayment(\n\t\tamount, htlcAmt, totalTimelock, blob,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = n.carolServer.registry.AddInvoice(*invoice, htlc.PaymentHash)\n\trequire.NoError(t, err, \"unable to add invoice in carol registry\")\n\n\t// With the invoice now added to Carol's registry, we'll send the\n\t// payment.\n\terr = n.aliceServer.htlcSwitch.SendHTLC(\n\t\tn.firstBobChannelLink.ShortChanID(), pid, htlc,\n\t)\n\trequire.NoError(t, err, \"unable to send payment to carol\")\n\n\tresultChan, err := n.aliceServer.htlcSwitch.GetAttemptResult(\n\t\tpid, htlc.PaymentHash, newMockDeobfuscator(),\n\t)\n\trequire.NoError(t, err, \"unable to get payment result\")\n\n\t// Now, if we attempt to send the payment *again* it should be rejected\n\t// as it's a duplicate request.\n\terr = n.aliceServer.htlcSwitch.SendHTLC(\n\t\tn.firstBobChannelLink.ShortChanID(), pid, htlc,\n\t)\n\tif err != ErrDuplicateAdd {\n\t\tt.Fatalf(\"ErrDuplicateAdd should have been \"+\n\t\t\t\"received got: %v\", err)\n\t}\n\n\tselect {\n\tcase result, ok := <-resultChan:\n\t\tif !ok {\n\t\t\tt.Fatalf(\"unexpected shutdown\")\n\t\t}\n\n\t\tif result.Error != nil {\n\t\t\tt.Fatalf(\"payment failed: %v\", result.Error)\n\t\t}\n\tcase <-time.After(5 * time.Second):\n\t\tt.Fatalf(\"payment result did not arrive\")\n\t}\n}\n\n// TestChannelLinkAcceptOverpay tests that if we create an invoice for sender,\n// and the sender sends *more* than specified in the invoice, then we'll still\n// accept it and settle as normal.",
      "length": 2345,
      "tokens": 301,
      "embedding": []
    },
    {
      "slug": "func TestChannelLinkAcceptOverpay(t *testing.T) {",
      "content": "func TestChannelLinkAcceptOverpay(t *testing.T) {\n\tt.Parallel()\n\n\t// First, we'll create our traditional three hop network. We'll only be\n\t// interacting with and asserting the state of two of the end points\n\t// for this test.\n\tchannels, _, err := createClusterChannels(\n\t\tt, btcutil.SatoshiPerBitcoin*3, btcutil.SatoshiPerBitcoin*5,\n\t)\n\trequire.NoError(t, err, \"unable to create channel\")\n\n\tn := newThreeHopNetwork(t, channels.aliceToBob, channels.bobToAlice,\n\t\tchannels.bobToCarol, channels.carolToBob, testStartingHeight)\n\tif err := n.start(); err != nil {\n\t\tt.Fatalf(\"unable to start three hop network: %v\", err)\n\t}\n\tt.Cleanup(n.stop)\n\n\tcarolBandwidthBefore := n.carolChannelLink.Bandwidth()\n\tfirstBobBandwidthBefore := n.firstBobChannelLink.Bandwidth()\n\tsecondBobBandwidthBefore := n.secondBobChannelLink.Bandwidth()\n\taliceBandwidthBefore := n.aliceChannelLink.Bandwidth()\n\n\t// We'll request a route to send 10k satoshis via Alice -> Bob ->\n\t// Carol.\n\tamount := lnwire.NewMSatFromSatoshis(btcutil.SatoshiPerBitcoin)\n\thtlcAmt, totalTimelock, hops := generateHops(\n\t\tamount, testStartingHeight,\n\t\tn.firstBobChannelLink, n.carolChannelLink,\n\t)\n\n\t// When we actually go to send the payment, we'll actually create an\n\t// invoice at Carol for only half of this amount.\n\treceiver := n.carolServer\n\tfirstHop := n.firstBobChannelLink.ShortChanID()\n\trhash, err := makePayment(\n\t\tn.aliceServer, n.carolServer, firstHop, hops, amount/2, htlcAmt,\n\t\ttotalTimelock,\n\t).Wait(30 * time.Second)\n\trequire.NoError(t, err, \"unable to send payment\")\n\n\t// Wait for Alice and Bob's second link to receive the revocation.\n\ttime.Sleep(2 * time.Second)\n\n\t// Even though we sent 2x what was asked for, Carol should still have\n\t// accepted the payment and marked it as settled.\n\tinvoice, err := receiver.registry.LookupInvoice(rhash)\n\trequire.NoError(t, err, \"unable to get invoice\")\n\tif invoice.State != invpkg.ContractSettled {\n\t\tt.Fatal(\"carol invoice haven't been settled\")\n\t}\n\n\texpectedAliceBandwidth := aliceBandwidthBefore - htlcAmt\n\tif expectedAliceBandwidth != n.aliceChannelLink.Bandwidth() {\n\t\tt.Fatalf(\"channel bandwidth incorrect: expected %v, got %v\",\n\t\t\texpectedAliceBandwidth, n.aliceChannelLink.Bandwidth())\n\t}\n\n\texpectedBobBandwidth1 := firstBobBandwidthBefore + htlcAmt\n\tif expectedBobBandwidth1 != n.firstBobChannelLink.Bandwidth() {\n\t\tt.Fatalf(\"channel bandwidth incorrect: expected %v, got %v\",\n\t\t\texpectedBobBandwidth1, n.firstBobChannelLink.Bandwidth())\n\t}\n\n\texpectedBobBandwidth2 := secondBobBandwidthBefore - amount\n\tif expectedBobBandwidth2 != n.secondBobChannelLink.Bandwidth() {\n\t\tt.Fatalf(\"channel bandwidth incorrect: expected %v, got %v\",\n\t\t\texpectedBobBandwidth2, n.secondBobChannelLink.Bandwidth())\n\t}\n\n\texpectedCarolBandwidth := carolBandwidthBefore + amount\n\tif expectedCarolBandwidth != n.carolChannelLink.Bandwidth() {\n\t\tt.Fatalf(\"channel bandwidth incorrect: expected %v, got %v\",\n\t\t\texpectedCarolBandwidth, n.carolChannelLink.Bandwidth())\n\t}\n\n\t// Finally, we'll ensure that the amount we paid is properly reflected\n\t// in the stored invoice.\n\tif invoice.AmtPaid != amount {\n\t\tt.Fatalf(\"expected amt paid to be %v, is instead %v\", amount,\n\t\t\tinvoice.AmtPaid)\n\t}\n}\n\n// persistentLinkHarness is used to control the lifecylce of a link and the\n// switch that operates it. It supports the ability to restart either the link\n// or both the link and the switch.",
      "length": 3236,
      "tokens": 370,
      "embedding": []
    },
    {
      "slug": "type persistentLinkHarness struct {",
      "content": "type persistentLinkHarness struct {\n\tt *testing.T\n\n\tlink     ChannelLink\n\tcoreLink *channelLink\n\tchannel  *lnwallet.LightningChannel\n\n\tbatchTicker chan time.Time\n\tmsgs        chan lnwire.Message\n\n\trestoreChan func() (*lnwallet.LightningChannel, error)\n}\n\n// newPersistentLinkHarness initializes a new persistentLinkHarness and derives\n// the supporting references from the active link.",
      "length": 336,
      "tokens": 35,
      "embedding": []
    },
    {
      "slug": "func newPersistentLinkHarness(t *testing.T, link ChannelLink,",
      "content": "func newPersistentLinkHarness(t *testing.T, link ChannelLink,\n\tbatchTicker chan time.Time,\n\trestore func() (*lnwallet.LightningChannel,\n\t\terror)) *persistentLinkHarness {\n\n\tcoreLink := link.(*channelLink)\n\n\treturn &persistentLinkHarness{\n\t\tt:           t,\n\t\tlink:        link,\n\t\tcoreLink:    coreLink,\n\t\tchannel:     coreLink.channel,\n\t\tbatchTicker: batchTicker,\n\t\tmsgs:        coreLink.cfg.Peer.(*mockPeer).sentMsgs,\n\t\trestoreChan: restore,\n\t}\n}\n\n// restart facilitates a shutdown and restart of the link maintained by the\n// harness. The primary purpose of this method is to ensure the consistency of\n// the supporting references is maintained across restarts.\n//\n// If `restartSwitch` is set, the entire switch will also be restarted,\n// and will be reinitialized with the contents of the channeldb backing Alice's\n// channel.\n//\n// Any number of hodl flags can be passed as additional arguments to this\n// method. If none are provided, the mask will be extracted as hodl.MaskNone.",
      "length": 896,
      "tokens": 121,
      "embedding": []
    },
    {
      "slug": "func (h *persistentLinkHarness) restart(restartSwitch, syncStates bool,",
      "content": "func (h *persistentLinkHarness) restart(restartSwitch, syncStates bool,\n\thodlFlags ...hodl.Flag) {\n\n\t// First, remove the link from the switch.\n\th.coreLink.cfg.Switch.RemoveLink(h.link.ChanID())\n\n\tif restartSwitch {\n\t\t// If a switch restart is requested, we will stop it. It will be\n\t\t// reinstantiated in restartLink.\n\t\th.coreLink.cfg.Switch.Stop()\n\t}\n\n\t// Since our in-memory state may have diverged from our persistent\n\t// state, we will restore the persisted state to ensure we always start\n\t// the link in a consistent state.\n\tvar err error\n\th.channel, err = h.restoreChan()\n\tif err != nil {\n\t\th.t.Fatalf(\"unable to restore channels: %v\", err)\n\t}\n\n\t// Now, restart the link using the channel state. This will take care of\n\t// adding the link to an existing switch, or creating a new one using\n\t// the database owned by the link.\n\th.link, h.batchTicker, err = h.restartLink(\n\t\th.t, h.channel, restartSwitch, syncStates, hodlFlags,\n\t)\n\tif err != nil {\n\t\th.t.Fatalf(\"unable to restart alicelink: %v\", err)\n\t}\n\n\t// Repopulate the remaining fields in the harness.\n\th.coreLink = h.link.(*channelLink)\n\th.msgs = h.coreLink.cfg.Peer.(*mockPeer).sentMsgs\n}\n\n// checkSent reads the links message stream and verify that the messages are\n// dequeued in the same order as provided by `pkts`.",
      "length": 1175,
      "tokens": 181,
      "embedding": []
    },
    {
      "slug": "func (h *persistentLinkHarness) checkSent(pkts []*htlcPacket) {",
      "content": "func (h *persistentLinkHarness) checkSent(pkts []*htlcPacket) {\n\tfor _, pkt := range pkts {\n\t\tvar msg lnwire.Message\n\t\tselect {\n\t\tcase msg = <-h.msgs:\n\t\tcase <-time.After(15 * time.Second):\n\t\t\th.t.Fatalf(\"did not receive message\")\n\t\t}\n\n\t\tif !reflect.DeepEqual(msg, pkt.htlc) {\n\t\t\th.t.Fatalf(\"unexpected packet, want %v, got %v\",\n\t\t\t\tpkt.htlc, msg)\n\t\t}\n\t}\n}\n\n// commitCircuits accepts a list of circuits and tries to commit them to the\n// switch's circuit map. The forwarding actions are returned if there was no\n// failure.",
      "length": 442,
      "tokens": 69,
      "embedding": []
    },
    {
      "slug": "func (h *persistentLinkHarness) commitCircuits(circuits []*PaymentCircuit) *CircuitFwdActions {",
      "content": "func (h *persistentLinkHarness) commitCircuits(circuits []*PaymentCircuit) *CircuitFwdActions {\n\tfwdActions, err := h.coreLink.cfg.Switch.commitCircuits(circuits...)\n\tif err != nil {\n\t\th.t.Fatalf(\"unable to commit circuit: %v\", err)\n\t}\n\n\treturn fwdActions\n}\n",
      "length": 155,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func (h *persistentLinkHarness) assertNumPendingNumOpenCircuits(",
      "content": "func (h *persistentLinkHarness) assertNumPendingNumOpenCircuits(\n\twantPending, wantOpen int) {\n\n\t_, _, line, _ := runtime.Caller(1)\n\n\tnumPending := h.coreLink.cfg.Switch.circuits.NumPending()\n\tif numPending != wantPending {\n\t\th.t.Fatalf(\"line: %d: wrong number of pending circuits: \"+\n\t\t\t\"want %d, got %d\", line, wantPending, numPending)\n\t}\n\tnumOpen := h.coreLink.cfg.Switch.circuits.NumOpen()\n\tif numOpen != wantOpen {\n\t\th.t.Fatalf(\"line: %d: wrong number of open circuits: \"+\n\t\t\t\"want %d, got %d\", line, wantOpen, numOpen)\n\t}\n}\n\n// trySignNextCommitment signals the batch ticker so that the link will try to\n// update its commitment transaction.",
      "length": 565,
      "tokens": 77,
      "embedding": []
    },
    {
      "slug": "func (h *persistentLinkHarness) trySignNextCommitment() {",
      "content": "func (h *persistentLinkHarness) trySignNextCommitment() {\n\tselect {\n\tcase h.batchTicker <- time.Now():\n\t\t// Give the link enough time to process the request.\n\t\ttime.Sleep(time.Millisecond * 500)\n\n\tcase <-time.After(15 * time.Second):\n\t\th.t.Fatalf(\"did not initiate state transition\")\n\t}\n}\n\n// restartLink creates a new channel link from the given channel state, and adds\n// to an htlcswitch. If none is provided by the caller, a new one will be\n// created using Alice's database.",
      "length": 409,
      "tokens": 65,
      "embedding": []
    },
    {
      "slug": "func (h *persistentLinkHarness) restartLink(",
      "content": "func (h *persistentLinkHarness) restartLink(\n\tt *testing.T, aliceChannel *lnwallet.LightningChannel, restartSwitch,\n\tsyncStates bool, hodlFlags []hodl.Flag) (\n\tChannelLink, chan time.Time, error) {\n\n\tvar (\n\t\tdecoder    = newMockIteratorDecoder()\n\t\tobfuscator = NewMockObfuscator()\n\t\talicePeer  = &mockPeer{\n\t\t\tsentMsgs: make(chan lnwire.Message, 2000),\n\t\t\tquit:     make(chan struct{}),\n\t\t}\n\n\t\tglobalPolicy = ForwardingPolicy{\n\t\t\tMinHTLCOut:    lnwire.NewMSatFromSatoshis(5),\n\t\t\tBaseFee:       lnwire.NewMSatFromSatoshis(1),\n\t\t\tTimeLockDelta: 6,\n\t\t}\n\n\t\tpCache = newMockPreimageCache()\n\t)\n\n\taliceDb := aliceChannel.State().Db.GetParentDB()\n\taliceSwitch := h.coreLink.cfg.Switch\n\tif restartSwitch {\n\t\tvar err error\n\t\taliceSwitch, err = initSwitchWithDB(testStartingHeight, aliceDb)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t}\n\n\tnotifyUpdateChan := make(chan *contractcourt.ContractUpdate)\n\tdoneChan := make(chan struct{})\n\tnotifyContractUpdate := func(u *contractcourt.ContractUpdate) error {\n\t\tselect {\n\t\tcase notifyUpdateChan <- u:\n\t\tcase <-doneChan:\n\t\t}\n\n\t\treturn nil\n\t}\n\n\tgetAliases := func(\n\t\tbase lnwire.ShortChannelID) []lnwire.ShortChannelID {\n\n\t\treturn nil\n\t}\n\n\t// Instantiate with a long interval, so that we can precisely control\n\t// the firing via force feeding.\n\tbticker := ticker.NewForce(time.Hour)\n\taliceCfg := ChannelLinkConfig{\n\t\tFwrdingPolicy: globalPolicy,\n\t\tPeer:          alicePeer,\n\t\tSwitch:        aliceSwitch,\n\t\tBestHeight:    aliceSwitch.BestHeight,\n\t\tCircuits:      aliceSwitch.CircuitModifier(),\n\t\tForwardPackets: func(linkQuit chan struct{}, _ bool, packets ...*htlcPacket) error {\n\t\t\treturn aliceSwitch.ForwardPackets(linkQuit, packets...)\n\t\t},\n\t\tDecodeHopIterators: decoder.DecodeHopIterators,\n\t\tExtractErrorEncrypter: func(*btcec.PublicKey) (\n\t\t\thop.ErrorEncrypter, lnwire.FailCode) {\n\n\t\t\treturn obfuscator, lnwire.CodeNone\n\t\t},\n\t\tFetchLastChannelUpdate: mockGetChanUpdateMessage,\n\t\tPreimageCache:          pCache,\n\t\tOnChannelFailure: func(lnwire.ChannelID,\n\t\t\tlnwire.ShortChannelID, LinkFailureError) { // nolint:whitespace\n\t\t},\n\t\tUpdateContractSignals: func(*contractcourt.ContractSignals) error {\n\t\t\treturn nil\n\t\t},\n\t\tNotifyContractUpdate: notifyContractUpdate,\n\t\tRegistry:             h.coreLink.cfg.Registry,\n\t\tFeeEstimator:         newMockFeeEstimator(),\n\t\tChainEvents:          &contractcourt.ChainEventSubscription{},\n\t\tBatchTicker:          bticker,\n\t\tFwdPkgGCTicker:       ticker.New(5 * time.Second),\n\t\tPendingCommitTicker:  ticker.New(time.Minute),\n\t\t// Make the BatchSize and Min/MaxFeeUpdateTimeout large enough\n\t\t// to not trigger commit updates automatically during tests.\n\t\tBatchSize:           10000,\n\t\tMinFeeUpdateTimeout: 30 * time.Minute,\n\t\tMaxFeeUpdateTimeout: 40 * time.Minute,\n\t\t// Set any hodl flags requested for the new link.\n\t\tHodlMask:                hodl.MaskFromFlags(hodlFlags...),\n\t\tMaxOutgoingCltvExpiry:   DefaultMaxOutgoingCltvExpiry,\n\t\tMaxFeeAllocation:        DefaultMaxLinkFeeAllocation,\n\t\tNotifyActiveLink:        func(wire.OutPoint) {},\n\t\tNotifyActiveChannel:     func(wire.OutPoint) {},\n\t\tNotifyInactiveChannel:   func(wire.OutPoint) {},\n\t\tNotifyInactiveLinkEvent: func(wire.OutPoint) {},\n\t\tHtlcNotifier:            aliceSwitch.cfg.HtlcNotifier,\n\t\tSyncStates:              syncStates,\n\t\tGetAliases:              getAliases,\n\t}\n\n\taliceLink := NewChannelLink(aliceCfg, aliceChannel)\n\tif err := aliceSwitch.AddLink(aliceLink); err != nil {\n\t\treturn nil, nil, err\n\t}\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-notifyUpdateChan:\n\t\t\tcase <-aliceLink.(*channelLink).quit:\n\t\t\t\tclose(doneChan)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tt.Cleanup(func() {\n\t\tclose(alicePeer.quit)\n\t\taliceLink.Stop()\n\t})\n\n\treturn aliceLink, bticker.Force, nil\n}\n\n// gnerateHtlc generates a simple payment from Bob to Alice.",
      "length": 3590,
      "tokens": 322,
      "embedding": []
    },
    {
      "slug": "func generateHtlc(t *testing.T, coreLink *channelLink,",
      "content": "func generateHtlc(t *testing.T, coreLink *channelLink,\n\tid uint64) *lnwire.UpdateAddHTLC {\n\n\tt.Helper()\n\n\thtlc, invoice := generateHtlcAndInvoice(t, id)\n\n\t// We must add the invoice to the registry, such that Alice\n\t// expects this payment.\n\terr := coreLink.cfg.Registry.(*mockInvoiceRegistry).AddInvoice(\n\t\t*invoice, htlc.PaymentHash,\n\t)\n\trequire.NoError(t, err, \"unable to add invoice to registry\")\n\n\treturn htlc\n}\n\n// generateHtlcAndInvoice generates an invoice and a single hop htlc to send to\n// the receiver.",
      "length": 442,
      "tokens": 59,
      "embedding": []
    },
    {
      "slug": "func generateHtlcAndInvoice(t *testing.T,",
      "content": "func generateHtlcAndInvoice(t *testing.T,\n\tid uint64) (*lnwire.UpdateAddHTLC, *invpkg.Invoice) {\n\n\tt.Helper()\n\n\thtlcAmt := lnwire.NewMSatFromSatoshis(10000)\n\thtlcExpiry := testStartingHeight + testInvoiceCltvExpiry\n\thops := []*hop.Payload{\n\t\thop.NewLegacyPayload(&sphinx.HopData{\n\t\t\tRealm:         [1]byte{}, // hop.BitcoinNetwork\n\t\t\tNextAddress:   [8]byte{}, // hop.Exit,\n\t\t\tForwardAmount: uint64(htlcAmt),\n\t\t\tOutgoingCltv:  uint32(htlcExpiry),\n\t\t}),\n\t}\n\tblob, err := generateRoute(hops...)\n\trequire.NoError(t, err, \"unable to generate route\")\n\n\tinvoice, htlc, _, err := generatePayment(\n\t\thtlcAmt, htlcAmt, uint32(htlcExpiry), blob,\n\t)\n\trequire.NoError(t, err, \"unable to create payment\")\n\n\thtlc.ID = id\n\n\treturn htlc, invoice\n}\n\n// TestChannelLinkNoMoreUpdates tests that we won't send a new commitment\n// when there are no new updates to sign.",
      "length": 777,
      "tokens": 85,
      "embedding": []
    },
    {
      "slug": "func TestChannelLinkNoMoreUpdates(t *testing.T) {",
      "content": "func TestChannelLinkNoMoreUpdates(t *testing.T) {\n\tt.Parallel()\n\n\tconst chanAmt = btcutil.SatoshiPerBitcoin * 5\n\tconst chanReserve = btcutil.SatoshiPerBitcoin * 1\n\taliceLink, bobChannel, _, start, _, err :=\n\t\tnewSingleLinkTestHarness(t, chanAmt, chanReserve)\n\trequire.NoError(t, err, \"unable to create link\")\n\n\tif err := start(); err != nil {\n\t\tt.Fatalf(\"unable to start test harness: %v\", err)\n\t}\n\n\tvar (\n\t\tcoreLink  = aliceLink.(*channelLink)\n\t\taliceMsgs = coreLink.cfg.Peer.(*mockPeer).sentMsgs\n\t)\n\n\t// Add two HTLCs to Alice's registry, that Bob can pay.\n\thtlc1 := generateHtlc(t, coreLink, 0)\n\thtlc2 := generateHtlc(t, coreLink, 1)\n\n\tctx := linkTestContext{\n\t\tt:          t,\n\t\taliceLink:  aliceLink,\n\t\taliceMsgs:  aliceMsgs,\n\t\tbobChannel: bobChannel,\n\t}\n\n\t// We now play out the following scanario:\n\t//\n\t// (1) Alice receives htlc1 from Bob.\n\t// (2) Bob sends signature covering htlc1.\n\t// (3) Alice receives htlc2 from Bob.\n\t// (4) Since Bob has sent a new commitment signature, Alice should\n\t// first respond with a revocation.\n\t// (5) Alice should also send a commitment signature for the new state,\n\t// covering htlc1.\n\t// (6) Bob sends a new commitment signature, covering htlc2 that he sent\n\t// earlier. This signature should cover hltc1 + htlc2.\n\t// (7) Alice should revoke the old commitment. This ACKs htlc2.\n\t// (8) Bob can now revoke his old commitment in response to the\n\t// signature Alice sent covering htlc1.\n\t// (9) htlc1 is now locked in on Bob's commitment, and we expect Alice\n\t// to settle it.\n\t// (10) Alice should send a signature covering this settle to Bob. Only\n\t// htlc2 should now be covered by this signature.\n\t// (11) Bob can revoke his last state, which will also ACK the settle\n\t// of htlc1.\n\t// (12) Bob sends a new commitment signature. This signature should\n\t// cover htlc2.\n\t// (13) Alice will send a settle for htlc2.\n\t// (14) Alice will also send a signature covering the settle.\n\t// (15) Alice should send a revocation in response to the signature Bob\n\t// sent earlier.\n\t// (16) Bob will revoke his commitment in response to the commitment\n\t// Alice sent.\n\t// (17) Send a signature for the empty state. No HTLCs are left.\n\t// (18) Alice will revoke her previous state.\n\t//                                   Alice                Bob\n\t//                                     |                   |\n\t//                                     |        ...        |\n\t//                                     |                   | <--- idle (no htlc on either side)\n\t//                                     |                   |\n\tctx.sendHtlcBobToAlice(htlc1)     //   |<----- add-1 ------| (1)\n\tctx.sendCommitSigBobToAlice(1)    //   |<------ sig -------| (2)\n\tctx.sendHtlcBobToAlice(htlc2)     //   |<----- add-2 ------| (3)\n\tctx.receiveRevAndAckAliceToBob()  //   |------- rev ------>| (4) <--- Alice acks add-1\n\tctx.receiveCommitSigAliceToBob(1) //   |------- sig ------>| (5) <--- Alice signs add-1\n\tctx.sendCommitSigBobToAlice(2)    //   |<------ sig -------| (6)\n\tctx.receiveRevAndAckAliceToBob()  //   |------- rev ------>| (7) <--- Alice acks add-2\n\tctx.sendRevAndAckBobToAlice()     //   |<------ rev -------| (8)\n\tctx.receiveSettleAliceToBob()     //   |------ ful-1 ----->| (9)\n\tctx.receiveCommitSigAliceToBob(1) //   |------- sig ------>| (10) <--- Alice signs add-1 + add-2 + ful-1 = add-2\n\tctx.sendRevAndAckBobToAlice()     //   |<------ rev -------| (11)\n\tctx.sendCommitSigBobToAlice(1)    //   |<------ sig -------| (12)\n\tctx.receiveSettleAliceToBob()     //   |------ ful-2 ----->| (13)\n\tctx.receiveCommitSigAliceToBob(0) //   |------- sig ------>| (14) <--- Alice signs add-2 + ful-2 = no htlcs\n\tctx.receiveRevAndAckAliceToBob()  //   |------- rev ------>| (15)\n\tctx.sendRevAndAckBobToAlice()     //   |<------ rev -------| (16) <--- Bob acks that there are no more htlcs\n\tctx.sendCommitSigBobToAlice(0)    //   |<------ sig -------| (17)\n\tctx.receiveRevAndAckAliceToBob()  //   |------- rev ------>| (18) <--- Alice acks that there are no htlcs on Alice's side\n\n\t// No there are no more changes to ACK or sign, make sure Alice doesn't\n\t// attempt to send any more messages.\n\tvar msg lnwire.Message\n\tselect {\n\tcase msg = <-aliceMsgs:\n\t\tt.Fatalf(\"did not expect message %T\", msg)\n\tcase <-time.After(100 * time.Millisecond):\n\t}\n}\n\n// checkHasPreimages inspects Alice's preimage cache, and asserts whether the\n// preimages for the provided HTLCs are known and unknown, and that all of them\n// match the expected status of expOk.",
      "length": 4329,
      "tokens": 603,
      "embedding": []
    },
    {
      "slug": "func checkHasPreimages(t *testing.T, coreLink *channelLink,",
      "content": "func checkHasPreimages(t *testing.T, coreLink *channelLink,\n\thtlcs []*lnwire.UpdateAddHTLC, expOk bool) {\n\n\tt.Helper()\n\n\terr := wait.NoError(func() error {\n\t\tfor i := range htlcs {\n\t\t\t_, ok := coreLink.cfg.PreimageCache.LookupPreimage(\n\t\t\t\thtlcs[i].PaymentHash,\n\t\t\t)\n\t\t\tif ok == expOk {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\treturn fmt.Errorf(\"expected to find witness: %v, \"+\n\t\t\t\t\"got %v for hash=%x\", expOk, ok,\n\t\t\t\thtlcs[i].PaymentHash)\n\t\t}\n\n\t\treturn nil\n\t}, 5*time.Second)\n\trequire.NoError(t, err, \"unable to find preimages\")\n}\n\n// TestChannelLinkWaitForRevocation tests that we will keep accepting updates\n// to our commitment transaction, even when we are waiting for a revocation\n// from the remote node.",
      "length": 610,
      "tokens": 83,
      "embedding": []
    },
    {
      "slug": "func TestChannelLinkWaitForRevocation(t *testing.T) {",
      "content": "func TestChannelLinkWaitForRevocation(t *testing.T) {\n\tt.Parallel()\n\n\tconst chanAmt = btcutil.SatoshiPerBitcoin * 5\n\tconst chanReserve = btcutil.SatoshiPerBitcoin * 1\n\taliceLink, bobChannel, _, start, _, err :=\n\t\tnewSingleLinkTestHarness(t, chanAmt, chanReserve)\n\trequire.NoError(t, err, \"unable to create link\")\n\n\tif err := start(); err != nil {\n\t\tt.Fatalf(\"unable to start test harness: %v\", err)\n\t}\n\n\tvar (\n\t\tcoreLink  = aliceLink.(*channelLink)\n\t\taliceMsgs = coreLink.cfg.Peer.(*mockPeer).sentMsgs\n\t)\n\n\t// We will send 10 HTLCs in total, from Bob to Alice.\n\tnumHtlcs := 10\n\tvar htlcs []*lnwire.UpdateAddHTLC\n\tfor i := 0; i < numHtlcs; i++ {\n\t\thtlc := generateHtlc(t, coreLink, uint64(i))\n\t\thtlcs = append(htlcs, htlc)\n\t}\n\n\tctx := linkTestContext{\n\t\tt:          t,\n\t\taliceLink:  aliceLink,\n\t\taliceMsgs:  aliceMsgs,\n\t\tbobChannel: bobChannel,\n\t}\n\n\tassertNoMsgFromAlice := func() {\n\t\tselect {\n\t\tcase <-aliceMsgs:\n\t\t\tt.Fatalf(\"did not expect message from Alice\")\n\t\tcase <-time.After(50 * time.Millisecond):\n\t\t}\n\t}\n\n\t// We play out the following scenario:\n\t//\n\t// (1) Add the first HTLC.\n\t// (2) Bob sends signature covering the htlc.\n\t// (3) Since Bob has sent a new commitment signature, Alice should first\n\t// respond with a revocation. This revocation will ACK the first htlc.\n\t// (4) Alice should also send a commitment signature for the new state,\n\t// locking in the HTLC on Bob's commitment. Note that we don't\n\t// immediately let Bob respond with a revocation in this case.\n\t// (5.i) Now we send the rest of the HTLCs from Bob to Alice.\n\t// (6.i) Bob sends a new commitment signature, covering all HTLCs up\n\t// to this point.\n\t// (7.i) Alice should respond to Bob's state updates with revocations,\n\t// but cannot send any new signatures for Bob's state because her\n\t// revocation window is exhausted.\n\t// (8) Now let Bob finally send his revocation.\n\t// (9) We expect Alice to settle her first HTLC, since it was already\n\t// locked in.\n\t// (10) Now Alice should send a signature covering this settle + lock\n\t// in the rest of the HTLCs on Bob's commitment.\n\t// (11) Bob receives the new signature for his commitment, and can\n\t// revoke his old state, ACKing the settle.\n\t// (12.i) Now Alice can settle all the HTLCs, since they are locked in\n\t// on both parties' commitments.\n\t// (13) Bob can send a signature covering the first settle Alice sent.\n\t// Bob's signature should cover all the remaining HTLCs as well, since\n\t// he hasn't ACKed the last settles yet. Alice receives the signature\n\t// from Bob. Alice's commitment now has the first HTLC settled, and all\n\t// the other HTLCs locked in.\n\t// (14) Alice will send a signature for all the settles she just sent.\n\t// (15) Bob can revoke his previous state, in response to Alice's\n\t// signature.\n\t// (16) In response to the signature Bob sent, Alice can\n\t// revoke her previous state.\n\t// (17) Bob still hasn't sent a commitment covering all settles, so do\n\t// that now. Since Bob ACKed all settles, no HTLCs should be left on\n\t// the commitment.\n\t// (18) Alice will revoke her previous state.\n\t//                                            Alice                Bob\n\t//                                              |                   |\n\t//                                              |        ...        |\n\t//                                              |                   | <--- idle (no htlc on either side)\n\t//                                              |                   |\n\tctx.sendHtlcBobToAlice(htlcs[0])  //            |<----- add-1 ------| (1)\n\tctx.sendCommitSigBobToAlice(1)    //            |<------ sig -------| (2)\n\tctx.receiveRevAndAckAliceToBob()  //            |------- rev ------>| (3) <--- Alice acks add-1\n\tctx.receiveCommitSigAliceToBob(1) //            |------- sig ------>| (4) <--- Alice signs add-1\n\tfor i := 1; i < numHtlcs; i++ {   //            |                   |\n\t\tctx.sendHtlcBobToAlice(htlcs[i])   //   |<----- add-i ------| (5.i)\n\t\tctx.sendCommitSigBobToAlice(i + 1) //   |<------ sig -------| (6.i)\n\t\tctx.receiveRevAndAckAliceToBob()   //   |------- rev ------>| (7.i) <--- Alice acks add-i\n\t\tassertNoMsgFromAlice()             //   |                   |\n\t\t//                                      |                   | Alice should not send a sig for\n\t\t//                                      |                   | Bob's last state, since she is\n\t\t//                                      |                   | still waiting for a revocation\n\t\t//                                      |                   | for the previous one.\n\t} //                                            |                   |\n\tctx.sendRevAndAckBobToAlice()                // |<------ rev -------| (8) Finally let Bob send rev\n\tctx.receiveSettleAliceToBob()                // |------ ful-1 ----->| (9)\n\tctx.receiveCommitSigAliceToBob(numHtlcs - 1) // |------- sig ------>| (10) <--- Alice signs add-i\n\tctx.sendRevAndAckBobToAlice()                // |<------ rev -------| (11)\n\tfor i := 1; i < numHtlcs; i++ {              // |                   |\n\t\tctx.receiveSettleAliceToBob() //        |------ ful-1 ----->| (12.i)\n\t} //                                            |                   |\n\tctx.sendCommitSigBobToAlice(numHtlcs - 1) //    |<------ sig -------| (13)\n\tctx.receiveCommitSigAliceToBob(0)         //    |------- sig ------>| (14)\n\tctx.sendRevAndAckBobToAlice()             //    |<------ rev -------| (15)\n\tctx.receiveRevAndAckAliceToBob()          //    |------- rev ------>| (16)\n\tctx.sendCommitSigBobToAlice(0)            //    |<------ sig -------| (17)\n\tctx.receiveRevAndAckAliceToBob()          //    |------- rev ------>| (18)\n\n\t// Both side's state is now updated, no more messages should be sent.\n\tassertNoMsgFromAlice()\n}\n\n// TestChannelLinkNoEmptySig asserts that no empty commit sig message is sent\n// when the commitment txes are out of sync.",
      "length": 5669,
      "tokens": 753,
      "embedding": []
    },
    {
      "slug": "func TestChannelLinkNoEmptySig(t *testing.T) {",
      "content": "func TestChannelLinkNoEmptySig(t *testing.T) {\n\tt.Parallel()\n\n\tconst chanAmt = btcutil.SatoshiPerBitcoin * 5\n\tconst chanReserve = btcutil.SatoshiPerBitcoin * 1\n\taliceLink, bobChannel, batchTicker, start, _, err :=\n\t\tnewSingleLinkTestHarness(t, chanAmt, chanReserve)\n\trequire.NoError(t, err, \"unable to create link\")\n\n\tif err := start(); err != nil {\n\t\tt.Fatalf(\"unable to start test harness: %v\", err)\n\t}\n\tt.Cleanup(aliceLink.Stop)\n\n\tvar (\n\t\tcoreLink  = aliceLink.(*channelLink)\n\t\taliceMsgs = coreLink.cfg.Peer.(*mockPeer).sentMsgs\n\t)\n\n\tctx := linkTestContext{\n\t\tt:          t,\n\t\taliceLink:  aliceLink,\n\t\taliceMsgs:  aliceMsgs,\n\t\tbobChannel: bobChannel,\n\t}\n\n\t// Send htlc 1 from Alice to Bob.\n\thtlc1, _ := generateHtlcAndInvoice(t, 0)\n\tctx.sendHtlcAliceToBob(0, htlc1)\n\tctx.receiveHtlcAliceToBob()\n\n\t// Tick the batch ticker to trigger a commitsig from Alice->Bob.\n\tselect {\n\tcase batchTicker <- time.Now():\n\tcase <-time.After(5 * time.Second):\n\t\tt.Fatalf(\"could not force commit sig\")\n\t}\n\n\t// Receive a CommitSig from Alice covering the Add from above.\n\tctx.receiveCommitSigAliceToBob(1)\n\n\t// Bob revokes previous commitment tx.\n\tctx.sendRevAndAckBobToAlice()\n\n\t// Alice sends htlc 2 to Bob.\n\thtlc2, _ := generateHtlcAndInvoice(t, 0)\n\tctx.sendHtlcAliceToBob(1, htlc2)\n\tctx.receiveHtlcAliceToBob()\n\n\t// Tick the batch ticker to trigger a commitsig from Alice->Bob.\n\tselect {\n\tcase batchTicker <- time.Now():\n\tcase <-time.After(5 * time.Second):\n\t\tt.Fatalf(\"could not force commit sig\")\n\t}\n\n\t// Get the commit sig from Alice, but don't send it to Bob yet.\n\tcommitSigAlice := ctx.receiveCommitSigAlice(2)\n\n\t// Bob adds htlc 1 to its remote commit tx.\n\tctx.sendCommitSigBobToAlice(1)\n\n\t// Now send Bob the signature from Alice covering both htlcs.\n\terr = bobChannel.ReceiveNewCommitment(\n\t\tcommitSigAlice.CommitSig, commitSigAlice.HtlcSigs,\n\t)\n\trequire.NoError(t, err, \"bob failed receiving commitment\")\n\n\t// Both Alice and Bob revoke their previous commitment txes.\n\tctx.receiveRevAndAckAliceToBob()\n\tctx.sendRevAndAckBobToAlice()\n\n\t// The commit txes are not in sync, but it is Bob's turn to send a new\n\t// signature. We don't expect Alice to send out any message. This check\n\t// allows some time for the log commit ticker to trigger for Alice.\n\tctx.assertNoMsgFromAlice(time.Second)\n}\n\n// TestChannelLinkBatchPreimageWrite asserts that a link will batch preimage\n// writes when just as it receives a CommitSig to lock in any Settles, and also\n// if the link is aware of any uncommitted preimages if the link is stopped,\n// i.e. due to a disconnection or shutdown.",
      "length": 2436,
      "tokens": 327,
      "embedding": []
    },
    {
      "slug": "func TestChannelLinkBatchPreimageWrite(t *testing.T) {",
      "content": "func TestChannelLinkBatchPreimageWrite(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tname       string\n\t\tdisconnect bool\n\t}{\n\t\t{\n\t\t\tname:       \"flush on commit sig\",\n\t\t\tdisconnect: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"flush on disconnect\",\n\t\t\tdisconnect: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\ttestChannelLinkBatchPreimageWrite(t, test.disconnect)\n\t\t})\n\t}\n}\n",
      "length": 334,
      "tokens": 44,
      "embedding": []
    },
    {
      "slug": "func testChannelLinkBatchPreimageWrite(t *testing.T, disconnect bool) {",
      "content": "func testChannelLinkBatchPreimageWrite(t *testing.T, disconnect bool) {\n\tconst chanAmt = btcutil.SatoshiPerBitcoin * 5\n\tconst chanReserve = btcutil.SatoshiPerBitcoin * 1\n\taliceLink, bobChannel, batchTicker, startUp, _, err :=\n\t\tnewSingleLinkTestHarness(t, chanAmt, chanReserve)\n\trequire.NoError(t, err, \"unable to create link\")\n\n\tif err := startUp(); err != nil {\n\t\tt.Fatalf(\"unable to start test harness: %v\", err)\n\t}\n\n\tvar (\n\t\tcoreLink  = aliceLink.(*channelLink)\n\t\taliceMsgs = coreLink.cfg.Peer.(*mockPeer).sentMsgs\n\t)\n\n\t// We will send 10 HTLCs in total, from Bob to Alice.\n\tnumHtlcs := 10\n\tvar htlcs []*lnwire.UpdateAddHTLC\n\tvar invoices []*invpkg.Invoice\n\tfor i := 0; i < numHtlcs; i++ {\n\t\thtlc, invoice := generateHtlcAndInvoice(t, uint64(i))\n\t\thtlcs = append(htlcs, htlc)\n\t\tinvoices = append(invoices, invoice)\n\t}\n\n\tctx := linkTestContext{\n\t\tt:          t,\n\t\taliceLink:  aliceLink,\n\t\taliceMsgs:  aliceMsgs,\n\t\tbobChannel: bobChannel,\n\t}\n\n\t// First, send a batch of Adds from Alice to Bob.\n\tfor i, htlc := range htlcs {\n\t\tctx.sendHtlcAliceToBob(i, htlc)\n\t\tctx.receiveHtlcAliceToBob()\n\t}\n\n\t// Assert that no preimages exist for these htlcs in Alice's cache.\n\tcheckHasPreimages(t, coreLink, htlcs, false)\n\n\t// Force alice's link to sign a commitment covering the htlcs sent thus\n\t// far.\n\tselect {\n\tcase batchTicker <- time.Now():\n\tcase <-time.After(15 * time.Second):\n\t\tt.Fatalf(\"could not force commit sig\")\n\t}\n\n\t// Do a commitment dance to lock in the Adds, we expect numHtlcs htlcs\n\t// to be on each party's commitment transactions.\n\tctx.receiveCommitSigAliceToBob(numHtlcs)\n\tctx.sendRevAndAckBobToAlice()\n\tctx.sendCommitSigBobToAlice(numHtlcs)\n\tctx.receiveRevAndAckAliceToBob()\n\n\t// Check again that no preimages exist for these htlcs in Alice's cache.\n\tcheckHasPreimages(t, coreLink, htlcs, false)\n\n\t// Now, have Bob settle the HTLCs back to Alice using the preimages in\n\t// the invoice corresponding to each of the HTLCs.\n\tfor i, invoice := range invoices {\n\t\tctx.sendSettleBobToAlice(\n\t\t\tuint64(i),\n\t\t\t*invoice.Terms.PaymentPreimage,\n\t\t)\n\t}\n\n\t// Assert that Alice has not yet written the preimages, even though she\n\t// has received them in the UpdateFulfillHTLC messages.\n\tcheckHasPreimages(t, coreLink, htlcs, false)\n\n\t// If this is the disconnect run, we will having Bob send Alice his\n\t// CommitSig, and simply stop Alice's link. As she exits, we should\n\t// detect that she has uncommitted preimages and write them to disk.\n\tif disconnect {\n\t\taliceLink.Stop()\n\t\tcheckHasPreimages(t, coreLink, htlcs, true)\n\t\treturn\n\t}\n\n\t// Otherwise, we are testing that Alice commits the preimages after\n\t// receiving a CommitSig from Bob. Bob's commitment should now have 0\n\t// HTLCs.\n\tctx.sendCommitSigBobToAlice(0)\n\n\t// Since Alice will process the CommitSig asynchronously, we wait until\n\t// she replies with her RevokeAndAck to ensure the tests reliably\n\t// inspect her cache after advancing her state.\n\tselect {\n\n\t// Received Alice's RevokeAndAck, assert that she has written all of the\n\t// uncommitted preimages learned in this commitment.\n\tcase <-aliceMsgs:\n\t\tcheckHasPreimages(t, coreLink, htlcs, true)\n\n\t// Alice didn't send her RevokeAndAck, something is wrong.\n\tcase <-time.After(15 * time.Second):\n\t\tt.Fatalf(\"alice did not send her revocation\")\n\t}\n}\n\n// TestChannelLinkCleanupSpuriousResponses tests that we properly cleanup\n// references in the event that internal retransmission continues as a result of\n// not properly cleaning up Add/SettleFailRefs.",
      "length": 3290,
      "tokens": 459,
      "embedding": []
    },
    {
      "slug": "func TestChannelLinkCleanupSpuriousResponses(t *testing.T) {",
      "content": "func TestChannelLinkCleanupSpuriousResponses(t *testing.T) {\n\tt.Parallel()\n\n\tconst chanAmt = btcutil.SatoshiPerBitcoin * 5\n\tconst chanReserve = btcutil.SatoshiPerBitcoin * 1\n\taliceLink, bobChannel, _, start, _, err :=\n\t\tnewSingleLinkTestHarness(t, chanAmt, chanReserve)\n\trequire.NoError(t, err, \"unable to create link\")\n\n\tif err := start(); err != nil {\n\t\tt.Fatalf(\"unable to start test harness: %v\", err)\n\t}\n\n\tvar (\n\t\tcoreLink  = aliceLink.(*channelLink)\n\t\taliceMsgs = coreLink.cfg.Peer.(*mockPeer).sentMsgs\n\t)\n\n\t// Settle Alice in hodl ExitSettle mode so that she won't respond\n\t// immediately to the htlc's meant for her. This allows us to control\n\t// the responses she gives back to Bob.\n\tcoreLink.cfg.HodlMask = hodl.ExitSettle.Mask()\n\n\t// Add two HTLCs to Alice's registry, that Bob can pay.\n\thtlc1 := generateHtlc(t, coreLink, 0)\n\thtlc2 := generateHtlc(t, coreLink, 1)\n\n\tctx := linkTestContext{\n\t\tt:          t,\n\t\taliceLink:  aliceLink,\n\t\taliceMsgs:  aliceMsgs,\n\t\tbobChannel: bobChannel,\n\t}\n\n\t// We start with he following scenario: Bob sends Alice two HTLCs, and a\n\t// commitment dance ensures, leaving two HTLCs that Alice can respond\n\t// to. Since Alice is in ExitSettle mode, we will then take over and\n\t// provide targeted fail messages to test the link's ability to cleanup\n\t// spurious responses.\n\t//\n\t//  Bob               Alice\n\t//   |------ add-1 ----->|\n\t//   |------ add-2 ----->|\n\t//   |------  sig  ----->| commits add-1 + add-2\n\t//   |<-----  rev  ------|\n\t//   |<-----  sig  ------| commits add-1 + add-2\n\t//   |------  rev  ----->|\n\tctx.sendHtlcBobToAlice(htlc1)\n\tctx.sendHtlcBobToAlice(htlc2)\n\tctx.sendCommitSigBobToAlice(2)\n\tctx.receiveRevAndAckAliceToBob()\n\tctx.receiveCommitSigAliceToBob(2)\n\tctx.sendRevAndAckBobToAlice()\n\n\t// Give Alice to time to process the revocation.\n\ttime.Sleep(time.Second)\n\n\taliceFwdPkgs, err := coreLink.channel.LoadFwdPkgs()\n\trequire.NoError(t, err, \"unable to load alice's fwdpkgs\")\n\n\t// Alice should have exactly one forwarding package.\n\tif len(aliceFwdPkgs) != 1 {\n\t\tt.Fatalf(\"alice should have 1 fwd pkgs, has %d instead\",\n\t\t\tlen(aliceFwdPkgs))\n\t}\n\n\t// We'll stash the height of these AddRefs, so that we can reconstruct\n\t// the proper references later.\n\taddHeight := aliceFwdPkgs[0].Height\n\n\t// The first fwdpkg should have exactly 2 entries, one for each Add that\n\t// was added during the last dance.\n\tif aliceFwdPkgs[0].AckFilter.Count() != 2 {\n\t\tt.Fatalf(\"alice fwdpkg should have 2 Adds, has %d instead\",\n\t\t\taliceFwdPkgs[0].AckFilter.Count())\n\t}\n\n\t// Both of the entries in the FwdFilter should be unacked.\n\tfor i := 0; i < 2; i++ {\n\t\tif aliceFwdPkgs[0].AckFilter.Contains(uint16(i)) {\n\t\t\tt.Fatalf(\"alice fwdpkg index %d should not \"+\n\t\t\t\t\"have ack\", i)\n\t\t}\n\t}\n\n\t// Now, construct a Fail packet for Bob settling the first HTLC. This\n\t// packet will NOT include a sourceRef, meaning the AddRef on disk will\n\t// not be acked after committing this response.\n\tfail0 := &htlcPacket{\n\t\tincomingChanID: bobChannel.ShortChanID(),\n\t\tincomingHTLCID: 0,\n\t\tobfuscator:     NewMockObfuscator(),\n\t\thtlc:           &lnwire.UpdateFailHTLC{},\n\t}\n\t_ = aliceLink.handleSwitchPacket(fail0)\n\n\t//  Bob               Alice\n\t//   |<----- fal-1 ------|\n\t//   |<-----  sig  ------| commits fal-1\n\tctx.receiveFailAliceToBob()\n\tctx.receiveCommitSigAliceToBob(1)\n\n\taliceFwdPkgs, err = coreLink.channel.LoadFwdPkgs()\n\trequire.NoError(t, err, \"unable to load alice's fwdpkgs\")\n\n\t// Alice should still only have one fwdpkg, as she hasn't yet received\n\t// another revocation from Bob.\n\tif len(aliceFwdPkgs) != 1 {\n\t\tt.Fatalf(\"alice should have 1 fwd pkgs, has %d instead\",\n\t\t\tlen(aliceFwdPkgs))\n\t}\n\n\t// Assert the fwdpkg still has 2 entries for the original Adds.\n\tif aliceFwdPkgs[0].AckFilter.Count() != 2 {\n\t\tt.Fatalf(\"alice fwdpkg should have 2 Adds, has %d instead\",\n\t\t\taliceFwdPkgs[0].AckFilter.Count())\n\t}\n\n\t// Since the fail packet was missing the AddRef, the forward filter for\n\t// either HTLC should not have been modified.\n\tfor i := 0; i < 2; i++ {\n\t\tif aliceFwdPkgs[0].AckFilter.Contains(uint16(i)) {\n\t\t\tt.Fatalf(\"alice fwdpkg index %d should not \"+\n\t\t\t\t\"have ack\", i)\n\t\t}\n\t}\n\n\t// Complete the rest of the commitment dance, now that the forwarding\n\t// packages have been verified.\n\t//\n\t//  Bob                Alice\n\t//   |------  rev  ----->|\n\t//   |------  sig  ----->|\n\t//   |<-----  rev  ------|\n\tctx.sendRevAndAckBobToAlice()\n\tctx.sendCommitSigBobToAlice(1)\n\tctx.receiveRevAndAckAliceToBob()\n\n\t// Next, we'll construct a fail packet for add-2 (index 1), which we'll\n\t// send to Bob and lock in. Since the AddRef is set on this instance, we\n\t// should see the second HTLCs AddRef update the forward filter for the\n\t// first fwd pkg.\n\tfail1 := &htlcPacket{\n\t\tsourceRef: &channeldb.AddRef{\n\t\t\tHeight: addHeight,\n\t\t\tIndex:  1,\n\t\t},\n\t\tincomingChanID: bobChannel.ShortChanID(),\n\t\tincomingHTLCID: 1,\n\t\tobfuscator:     NewMockObfuscator(),\n\t\thtlc:           &lnwire.UpdateFailHTLC{},\n\t}\n\t_ = aliceLink.handleSwitchPacket(fail1)\n\n\t//  Bob               Alice\n\t//   |<----- fal-1 ------|\n\t//   |<-----  sig  ------| commits fal-1\n\tctx.receiveFailAliceToBob()\n\tctx.receiveCommitSigAliceToBob(0)\n\n\taliceFwdPkgs, err = coreLink.channel.LoadFwdPkgs()\n\trequire.NoError(t, err, \"unable to load alice's fwdpkgs\")\n\n\t// Now that another commitment dance has completed, Alice should have 2\n\t// forwarding packages.\n\tif len(aliceFwdPkgs) != 2 {\n\t\tt.Fatalf(\"alice should have 2 fwd pkgs, has %d instead\",\n\t\t\tlen(aliceFwdPkgs))\n\t}\n\n\t// The most recent package should have no new HTLCs, so it should be\n\t// empty.\n\tif aliceFwdPkgs[1].AckFilter.Count() != 0 {\n\t\tt.Fatalf(\"alice fwdpkg height=%d should have 0 Adds, \"+\n\t\t\t\"has %d instead\", aliceFwdPkgs[1].Height,\n\t\t\taliceFwdPkgs[1].AckFilter.Count())\n\t}\n\n\t// The index for the first AddRef should still be unacked, as the\n\t// sourceRef was missing on the htlcPacket.\n\tif aliceFwdPkgs[0].AckFilter.Contains(0) {\n\t\tt.Fatalf(\"alice fwdpkg height=%d index=0 should not \"+\n\t\t\t\"have an ack\", aliceFwdPkgs[0].Height)\n\t}\n\n\t// The index for the second AddRef should now be acked, as it was\n\t// properly constructed and committed in Alice's last commit sig.\n\tif !aliceFwdPkgs[0].AckFilter.Contains(1) {\n\t\tt.Fatalf(\"alice fwdpkg height=%d index=1 should have \"+\n\t\t\t\"an ack\", aliceFwdPkgs[0].Height)\n\t}\n\n\t// Complete the rest of the commitment dance.\n\t//\n\t//  Bob                Alice\n\t//   |------  rev  ----->|\n\t//   |------  sig  ----->|\n\t//   |<-----  rev  ------|\n\tctx.sendRevAndAckBobToAlice()\n\tctx.sendCommitSigBobToAlice(0)\n\tctx.receiveRevAndAckAliceToBob()\n\n\t// We'll do a quick sanity check, and blindly send the same fail packet\n\t// for the first HTLC. Since this HTLC index has already been settled,\n\t// this should trigger an attempt to cleanup the spurious response.\n\t// However, we expect it to result in a NOP since it is still missing\n\t// its sourceRef.\n\t_ = aliceLink.handleSwitchPacket(fail0)\n\n\t// Allow the link enough time to process and reject the duplicate\n\t// packet, we'll also check that this doesn't trigger Alice to send the\n\t// fail to Bob.\n\tselect {\n\tcase <-aliceMsgs:\n\t\tt.Fatalf(\"message sent for duplicate fail\")\n\tcase <-time.After(time.Second):\n\t}\n\n\taliceFwdPkgs, err = coreLink.channel.LoadFwdPkgs()\n\trequire.NoError(t, err, \"unable to load alice's fwdpkgs\")\n\n\t// Alice should now have 3 forwarding packages, and the latest should be\n\t// empty.\n\tif len(aliceFwdPkgs) != 3 {\n\t\tt.Fatalf(\"alice should have 3 fwd pkgs, has %d instead\",\n\t\t\tlen(aliceFwdPkgs))\n\t}\n\tif aliceFwdPkgs[2].AckFilter.Count() != 0 {\n\t\tt.Fatalf(\"alice fwdpkg height=%d should have 0 Adds, \"+\n\t\t\t\"has %d instead\", aliceFwdPkgs[2].Height,\n\t\t\taliceFwdPkgs[2].AckFilter.Count())\n\t}\n\n\t// The state of the forwarding packages should be unmodified from the\n\t// prior assertion, since the duplicate Fail for index 0 should have\n\t// been ignored.\n\tif aliceFwdPkgs[0].AckFilter.Contains(0) {\n\t\tt.Fatalf(\"alice fwdpkg height=%d index=0 should not \"+\n\t\t\t\"have an ack\", aliceFwdPkgs[0].Height)\n\t}\n\tif !aliceFwdPkgs[0].AckFilter.Contains(1) {\n\t\tt.Fatalf(\"alice fwdpkg height=%d index=1 should have \"+\n\t\t\t\"an ack\", aliceFwdPkgs[0].Height)\n\t}\n\n\t// Finally, construct a new Fail packet for the first HTLC, this time\n\t// with the sourceRef properly constructed. When the link handles this\n\t// duplicate, it should clean up the remaining AddRef state maintained\n\t// in Alice's link, but it should not result in anything being sent to\n\t// Bob.\n\tfail0 = &htlcPacket{\n\t\tsourceRef: &channeldb.AddRef{\n\t\t\tHeight: addHeight,\n\t\t\tIndex:  0,\n\t\t},\n\t\tincomingChanID: bobChannel.ShortChanID(),\n\t\tincomingHTLCID: 0,\n\t\tobfuscator:     NewMockObfuscator(),\n\t\thtlc:           &lnwire.UpdateFailHTLC{},\n\t}\n\t_ = aliceLink.handleSwitchPacket(fail0)\n\n\t// Allow the link enough time to process and reject the duplicate\n\t// packet, we'll also check that this doesn't trigger Alice to send the\n\t// fail to Bob.\n\tselect {\n\tcase <-aliceMsgs:\n\t\tt.Fatalf(\"message sent for duplicate fail\")\n\tcase <-time.After(time.Second):\n\t}\n\n\taliceFwdPkgs, err = coreLink.channel.LoadFwdPkgs()\n\trequire.NoError(t, err, \"unable to load alice's fwdpkgs\")\n\n\t// Since no state transitions have been performed for the duplicate\n\t// packets, Alice should still have the same 3 forwarding packages.\n\tif len(aliceFwdPkgs) != 3 {\n\t\tt.Fatalf(\"alice should have 3 fwd pkgs, has %d instead\",\n\t\t\tlen(aliceFwdPkgs))\n\t}\n\n\t// Assert that all indices in our original forwarded have now been acked\n\t// as a result of our spurious cleanup logic.\n\tfor i := 0; i < 2; i++ {\n\t\tif !aliceFwdPkgs[0].AckFilter.Contains(uint16(i)) {\n\t\t\tt.Fatalf(\"alice fwdpkg height=%d index=%d \"+\n\t\t\t\t\"should have ack\", aliceFwdPkgs[0].Height, i)\n\t\t}\n\t}\n}\n",
      "length": 9265,
      "tokens": 1262,
      "embedding": []
    },
    {
      "slug": "type mockPackager struct {",
      "content": "type mockPackager struct {\n\tfailLoadFwdPkgs bool\n}\n",
      "length": 22,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (*mockPackager) AddFwdPkg(tx kvdb.RwTx, fwdPkg *channeldb.FwdPkg) error {",
      "content": "func (*mockPackager) AddFwdPkg(tx kvdb.RwTx, fwdPkg *channeldb.FwdPkg) error {\n\treturn nil\n}\n",
      "length": 12,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (*mockPackager) SetFwdFilter(tx kvdb.RwTx, height uint64,",
      "content": "func (*mockPackager) SetFwdFilter(tx kvdb.RwTx, height uint64,\n\tfwdFilter *channeldb.PkgFilter) error {\n\treturn nil\n}\n",
      "length": 52,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "func (*mockPackager) AckAddHtlcs(tx kvdb.RwTx,",
      "content": "func (*mockPackager) AckAddHtlcs(tx kvdb.RwTx,\n\taddRefs ...channeldb.AddRef) error {\n\treturn nil\n}\n",
      "length": 49,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "func (m *mockPackager) LoadFwdPkgs(tx kvdb.RTx) ([]*channeldb.FwdPkg, error) {",
      "content": "func (m *mockPackager) LoadFwdPkgs(tx kvdb.RTx) ([]*channeldb.FwdPkg, error) {\n\tif m.failLoadFwdPkgs {\n\t\treturn nil, fmt.Errorf(\"failing LoadFwdPkgs\")\n\t}\n\treturn nil, nil\n}\n",
      "length": 89,
      "tokens": 12,
      "embedding": []
    },
    {
      "slug": "func (*mockPackager) RemovePkg(tx kvdb.RwTx, height uint64) error {",
      "content": "func (*mockPackager) RemovePkg(tx kvdb.RwTx, height uint64) error {\n\treturn nil\n}\n",
      "length": 12,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (*mockPackager) Wipe(tx kvdb.RwTx) error {",
      "content": "func (*mockPackager) Wipe(tx kvdb.RwTx) error {\n\treturn nil\n}\n",
      "length": 12,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (*mockPackager) AckSettleFails(tx kvdb.RwTx,",
      "content": "func (*mockPackager) AckSettleFails(tx kvdb.RwTx,\n\tsettleFailRefs ...channeldb.SettleFailRef) error {\n\treturn nil\n}\n\n// TestChannelLinkFail tests that we will fail the channel, and force close the\n// channel in certain situations.",
      "length": 175,
      "tokens": 25,
      "embedding": []
    },
    {
      "slug": "func TestChannelLinkFail(t *testing.T) {",
      "content": "func TestChannelLinkFail(t *testing.T) {\n\tt.Parallel()\n\n\ttestCases := []struct {\n\t\t// name is the description for this test case.\n\t\tname string\n\n\t\t// options is used to set up mocks and configure the link\n\t\t// before it is started.\n\t\toptions func(*channelLink)\n\n\t\t// link test is used to execute the given test on the channel\n\t\t// link after it is started.\n\t\tlinkTest func(*testing.T, *channelLink,\n\t\t\t*lnwallet.LightningChannel)\n\n\t\t// shouldFail indicates whether or not the link should fail\n\t\t// during this test case.\n\t\tshouldFail bool\n\n\t\t// shouldForceClose indicates whether we expect the link to\n\t\t// force close the channel in response to the actions performed\n\t\t// during the linkTest.\n\t\tshouldForceClose bool\n\n\t\t// permanentFailure indicates whether we expect the link to\n\t\t// consider the failure permanent in response to the actions\n\t\t// performed during the linkTest.\n\t\tpermanentFailure bool\n\t}{\n\t\t{\n\t\t\t\"don't fail the channel if we receive a warning \" +\n\t\t\t\t\"message\",\n\t\t\tfunc(c *channelLink) {\n\t\t\t},\n\t\t\tfunc(_ *testing.T, c *channelLink,\n\t\t\t\t_ *lnwallet.LightningChannel) {\n\n\t\t\t\twarningMsg := &lnwire.Warning{\n\t\t\t\t\tData: []byte(\"random warning\"),\n\t\t\t\t}\n\t\t\t\tc.HandleChannelUpdate(warningMsg)\n\t\t\t},\n\t\t\tfalse,\n\t\t\tfalse,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"don't force close if syncing states fails at startup\",\n\t\t\tfunc(c *channelLink) {\n\t\t\t\tc.cfg.SyncStates = true\n\n\t\t\t\t// Make the syncChanStateCall fail by making\n\t\t\t\t// the SendMessage call fail.\n\t\t\t\tc.cfg.Peer.(*mockPeer).disconnected = true\n\t\t\t},\n\t\t\tfunc(*testing.T, *channelLink,\n\t\t\t\t*lnwallet.LightningChannel) { //nolint:whitespace,lll\n\n\t\t\t\t// Should fail at startup.\n\t\t\t},\n\t\t\ttrue,\n\t\t\tfalse,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"we don't force closes the channel if resolving \" +\n\t\t\t\t\"forward packages fails at startup\",\n\t\t\tfunc(c *channelLink) {\n\t\t\t\t// We make the call to resolveFwdPkgs fail by\n\t\t\t\t// making the underlying forwarder fail.\n\t\t\t\tpkg := &mockPackager{\n\t\t\t\t\tfailLoadFwdPkgs: true,\n\t\t\t\t}\n\t\t\t\tc.channel.State().Packager = pkg\n\t\t\t},\n\t\t\tfunc(*testing.T, *channelLink,\n\t\t\t\t*lnwallet.LightningChannel) { //nolint:whitespace,lll\n\n\t\t\t\t// Should fail at startup.\n\t\t\t},\n\t\t\ttrue,\n\t\t\tfalse,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"don't force close the channel if we receive an \" +\n\t\t\t\t\"invalid Settle message\",\n\t\t\tfunc(c *channelLink) {\n\t\t\t},\n\t\t\tfunc(_ *testing.T, c *channelLink,\n\t\t\t\t_ *lnwallet.LightningChannel) {\n\n\t\t\t\t// Recevive an htlc settle for an htlc that was\n\t\t\t\t// never added.\n\t\t\t\thtlcSettle := &lnwire.UpdateFulfillHTLC{\n\t\t\t\t\tID:              0,\n\t\t\t\t\tPaymentPreimage: [32]byte{},\n\t\t\t\t}\n\t\t\t\tc.HandleChannelUpdate(htlcSettle)\n\t\t\t},\n\t\t\ttrue,\n\t\t\tfalse,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"force close the channel if we receive an invalid \" +\n\t\t\t\t\"CommitSig, not containing enough HTLC sigs\",\n\t\t\tfunc(c *channelLink) {\n\t\t\t},\n\t\t\tfunc(_ *testing.T, c *channelLink,\n\t\t\t\tremoteChannel *lnwallet.LightningChannel) {\n\n\t\t\t\t// Generate an HTLC and send to the link.\n\t\t\t\thtlc1 := generateHtlc(t, c, 0)\n\t\t\t\tctx := linkTestContext{\n\t\t\t\t\tt:          t,\n\t\t\t\t\taliceLink:  c,\n\t\t\t\t\tbobChannel: remoteChannel,\n\t\t\t\t}\n\t\t\t\tctx.sendHtlcBobToAlice(htlc1)\n\n\t\t\t\t// Sign a commitment that will include\n\t\t\t\t// signature for the HTLC just sent.\n\t\t\t\tsig, htlcSigs, _, err :=\n\t\t\t\t\tremoteChannel.SignNextCommitment()\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"error signing commitment: %v\",\n\t\t\t\t\t\terr)\n\t\t\t\t}\n\n\t\t\t\t// Remove the HTLC sig, such that the commit\n\t\t\t\t// sig will be invalid.\n\t\t\t\tcommitSig := &lnwire.CommitSig{\n\t\t\t\t\tCommitSig: sig,\n\t\t\t\t\tHtlcSigs:  htlcSigs[1:],\n\t\t\t\t}\n\n\t\t\t\tc.HandleChannelUpdate(commitSig)\n\t\t\t},\n\t\t\ttrue,\n\t\t\ttrue,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"force close the channel if we receive an invalid \" +\n\t\t\t\t\"CommitSig, where the sig itself is corrupted\",\n\t\t\tfunc(c *channelLink) {\n\t\t\t},\n\t\t\tfunc(t *testing.T, c *channelLink,\n\t\t\t\tremoteChannel *lnwallet.LightningChannel) {\n\n\t\t\t\tt.Helper()\n\n\t\t\t\t// Generate an HTLC and send to the link.\n\t\t\t\thtlc1 := generateHtlc(t, c, 0)\n\t\t\t\tctx := linkTestContext{\n\t\t\t\t\tt:          t,\n\t\t\t\t\taliceLink:  c,\n\t\t\t\t\tbobChannel: remoteChannel,\n\t\t\t\t}\n\n\t\t\t\tctx.sendHtlcBobToAlice(htlc1)\n\n\t\t\t\t// Sign a commitment that will include\n\t\t\t\t// signature for the HTLC just sent.\n\t\t\t\tsig, htlcSigs, _, err :=\n\t\t\t\t\tremoteChannel.SignNextCommitment()\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"error signing commitment: %v\",\n\t\t\t\t\t\terr)\n\t\t\t\t}\n\n\t\t\t\t// Flip a bit on the signature, rendering it\n\t\t\t\t// invalid.\n\t\t\t\tsig[19] ^= 1\n\t\t\t\tcommitSig := &lnwire.CommitSig{\n\t\t\t\t\tCommitSig: sig,\n\t\t\t\t\tHtlcSigs:  htlcSigs,\n\t\t\t\t}\n\n\t\t\t\tc.HandleChannelUpdate(commitSig)\n\t\t\t},\n\t\t\ttrue,\n\t\t\ttrue,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"consider the failure permanent if we receive a link \" +\n\t\t\t\t\"error from the remote\",\n\t\t\tfunc(c *channelLink) {\n\t\t\t},\n\t\t\tfunc(_ *testing.T, c *channelLink,\n\t\t\t\tremoteChannel *lnwallet.LightningChannel) {\n\n\t\t\t\terr := &lnwire.Error{}\n\t\t\t\tc.HandleChannelUpdate(err)\n\t\t\t},\n\t\t\ttrue,\n\t\t\tfalse,\n\t\t\t// TODO(halseth) For compatibility with CL we currently\n\t\t\t// don't treat Errors as permanent errors.\n\t\t\tfalse,\n\t\t},\n\t}\n\n\tconst chanAmt = btcutil.SatoshiPerBitcoin * 5\n\n\t// Execute each test case.\n\tfor _, test := range testCases {\n\t\tlink, remoteChannel, _, start, _, err :=\n\t\t\tnewSingleLinkTestHarness(t, chanAmt, 0)\n\t\trequire.NoError(t, err, test.name)\n\n\t\tcoreLink := link.(*channelLink)\n\n\t\t// Set up a channel used to check whether the link error\n\t\t// force closed the channel.\n\t\tlinkErrors := make(chan LinkFailureError, 1)\n\t\tcoreLink.cfg.OnChannelFailure = func(_ lnwire.ChannelID,\n\t\t\t_ lnwire.ShortChannelID, linkErr LinkFailureError) {\n\n\t\t\tlinkErrors <- linkErr\n\t\t}\n\n\t\t// Set up the link before starting it.\n\t\ttest.options(coreLink)\n\t\terr = start()\n\t\trequire.NoError(t, err, test.name)\n\n\t\t// Execute the test case.\n\t\ttest.linkTest(t, coreLink, remoteChannel)\n\n\t\t// Currently we expect all test cases to lead to link error.\n\t\tvar linkErr LinkFailureError\n\t\terrReceived := false\n\t\tselect {\n\t\tcase linkErr = <-linkErrors:\n\t\t\terrReceived = true\n\n\t\tcase <-time.After(10 * time.Second):\n\t\t\t// If we do not receive a link error in 10s we assume\n\t\t\t// that we won't receive any.\n\t\t}\n\n\t\trequire.Equal(t, test.shouldFail, errReceived, test.name)\n\n\t\t// Check that the link is up and return.\n\t\tif !test.shouldFail {\n\t\t\trequire.False(t, coreLink.failed)\n\t\t\treturn\n\t\t}\n\n\t\trequire.True(t, coreLink.failed)\n\n\t\t// If we expect the link to force close the channel in this\n\t\t// case, check that it happens. If not, make sure it does not\n\t\t// happen.\n\t\trequire.Equal(\n\t\t\tt, test.shouldForceClose, linkErr.ForceClose, test.name,\n\t\t)\n\t\trequire.Equal(\n\t\t\tt, test.permanentFailure, linkErr.PermanentFailure,\n\t\t\ttest.name,\n\t\t)\n\t}\n}\n\n// TestExpectedFee tests calculation of ExpectedFee returns expected fee, given\n// a baseFee, a feeRate, and an htlc amount.",
      "length": 6327,
      "tokens": 830,
      "embedding": []
    },
    {
      "slug": "func TestExpectedFee(t *testing.T) {",
      "content": "func TestExpectedFee(t *testing.T) {\n\ttestCases := []struct {\n\t\tbaseFee  lnwire.MilliSatoshi\n\t\tfeeRate  lnwire.MilliSatoshi\n\t\thtlcAmt  lnwire.MilliSatoshi\n\t\texpected lnwire.MilliSatoshi\n\t}{\n\t\t{\n\t\t\tlnwire.MilliSatoshi(0),\n\t\t\tlnwire.MilliSatoshi(0),\n\t\t\tlnwire.MilliSatoshi(0),\n\t\t\tlnwire.MilliSatoshi(0),\n\t\t},\n\t\t{\n\t\t\tlnwire.MilliSatoshi(0),\n\t\t\tlnwire.MilliSatoshi(1),\n\t\t\tlnwire.MilliSatoshi(999999),\n\t\t\tlnwire.MilliSatoshi(0),\n\t\t},\n\t\t{\n\t\t\tlnwire.MilliSatoshi(0),\n\t\t\tlnwire.MilliSatoshi(1),\n\t\t\tlnwire.MilliSatoshi(1000000),\n\t\t\tlnwire.MilliSatoshi(1),\n\t\t},\n\t\t{\n\t\t\tlnwire.MilliSatoshi(0),\n\t\t\tlnwire.MilliSatoshi(1),\n\t\t\tlnwire.MilliSatoshi(1000001),\n\t\t\tlnwire.MilliSatoshi(1),\n\t\t},\n\t\t{\n\t\t\tlnwire.MilliSatoshi(1),\n\t\t\tlnwire.MilliSatoshi(1),\n\t\t\tlnwire.MilliSatoshi(1000000),\n\t\t\tlnwire.MilliSatoshi(2),\n\t\t},\n\t}\n\n\tfor _, test := range testCases {\n\t\tf := ForwardingPolicy{\n\t\t\tBaseFee: test.baseFee,\n\t\t\tFeeRate: test.feeRate,\n\t\t}\n\t\tfee := ExpectedFee(f, test.htlcAmt)\n\t\tif fee != test.expected {\n\t\t\tt.Errorf(\"expected fee to be (%v), instead got (%v)\", test.expected,\n\t\t\t\tfee)\n\t\t}\n\t}\n}\n\n// TestForwardingAsymmetricTimeLockPolicies tests that each link is able to\n// properly handle forwarding HTLCs when their outgoing channels have\n// asymmetric policies w.r.t what they require for time locks.",
      "length": 1192,
      "tokens": 110,
      "embedding": []
    },
    {
      "slug": "func TestForwardingAsymmetricTimeLockPolicies(t *testing.T) {",
      "content": "func TestForwardingAsymmetricTimeLockPolicies(t *testing.T) {\n\tt.Parallel()\n\n\t// First, we'll create our traditional three hop network. Bob\n\t// interacting with and asserting the state of two of the end points\n\t// for this test.\n\tchannels, _, err := createClusterChannels(\n\t\tt, btcutil.SatoshiPerBitcoin*3, btcutil.SatoshiPerBitcoin*5,\n\t)\n\trequire.NoError(t, err, \"unable to create channel\")\n\n\tn := newThreeHopNetwork(\n\t\tt, channels.aliceToBob, channels.bobToAlice, channels.bobToCarol,\n\t\tchannels.carolToBob, testStartingHeight,\n\t)\n\tif err := n.start(); err != nil {\n\t\tt.Fatalf(\"unable to start three hop network: %v\", err)\n\t}\n\tt.Cleanup(n.stop)\n\n\t// Now that each of the links are up, we'll modify the link from Alice\n\t// -> Bob to have a greater time lock delta than that of the link of\n\t// Bob -> Carol.\n\tnewPolicy := n.firstBobChannelLink.cfg.FwrdingPolicy\n\tnewPolicy.TimeLockDelta = 7\n\tn.firstBobChannelLink.UpdateForwardingPolicy(newPolicy)\n\n\t// Now that the Alice -> Bob link has been updated, we'll craft and\n\t// send a payment from Alice -> Carol. This should succeed as normal,\n\t// even though Bob has asymmetric time lock policies.\n\tamount := lnwire.NewMSatFromSatoshis(btcutil.SatoshiPerBitcoin)\n\thtlcAmt, totalTimelock, hops := generateHops(\n\t\tamount, testStartingHeight, n.firstBobChannelLink,\n\t\tn.carolChannelLink,\n\t)\n\n\tfirstHop := n.firstBobChannelLink.ShortChanID()\n\t_, err = makePayment(\n\t\tn.aliceServer, n.carolServer, firstHop, hops, amount, htlcAmt,\n\t\ttotalTimelock,\n\t).Wait(30 * time.Second)\n\trequire.NoError(t, err, \"unable to send payment\")\n}\n\n// TestCheckHtlcForward tests that a link is properly enforcing the HTLC\n// forwarding policy.",
      "length": 1557,
      "tokens": 200,
      "embedding": []
    },
    {
      "slug": "func TestCheckHtlcForward(t *testing.T) {",
      "content": "func TestCheckHtlcForward(t *testing.T) {\n\tfetchLastChannelUpdate := func(lnwire.ShortChannelID) (\n\t\t*lnwire.ChannelUpdate, error) {\n\n\t\treturn &lnwire.ChannelUpdate{}, nil\n\t}\n\n\tfailAliasUpdate := func(sid lnwire.ShortChannelID,\n\t\tincoming bool) *lnwire.ChannelUpdate {\n\n\t\treturn nil\n\t}\n\n\ttestChannel, _, err := createTestChannel(\n\t\tt, alicePrivKey, bobPrivKey, 100000, 100000,\n\t\t1000, 1000, lnwire.ShortChannelID{},\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink := channelLink{\n\t\tcfg: ChannelLinkConfig{\n\t\t\tFwrdingPolicy: ForwardingPolicy{\n\t\t\t\tTimeLockDelta: 20,\n\t\t\t\tMinHTLCOut:    500,\n\t\t\t\tMaxHTLC:       1000,\n\t\t\t\tBaseFee:       10,\n\t\t\t},\n\t\t\tFetchLastChannelUpdate: fetchLastChannelUpdate,\n\t\t\tMaxOutgoingCltvExpiry:  DefaultMaxOutgoingCltvExpiry,\n\t\t\tHtlcNotifier:           &mockHTLCNotifier{},\n\t\t},\n\t\tlog:     log,\n\t\tchannel: testChannel.channel,\n\t}\n\n\tlink.attachFailAliasUpdate(failAliasUpdate)\n\n\tvar hash [32]byte\n\n\tt.Run(\"satisfied\", func(t *testing.T) {\n\t\tresult := link.CheckHtlcForward(hash, 1500, 1000,\n\t\t\t200, 150, 0, lnwire.ShortChannelID{})\n\t\tif result != nil {\n\t\t\tt.Fatalf(\"expected policy to be satisfied\")\n\t\t}\n\t})\n\n\tt.Run(\"below minhtlc\", func(t *testing.T) {\n\t\tresult := link.CheckHtlcForward(hash, 100, 50,\n\t\t\t200, 150, 0, lnwire.ShortChannelID{})\n\t\tif _, ok := result.WireMessage().(*lnwire.FailAmountBelowMinimum); !ok {\n\t\t\tt.Fatalf(\"expected FailAmountBelowMinimum failure code\")\n\t\t}\n\t})\n\n\tt.Run(\"above maxhtlc\", func(t *testing.T) {\n\t\tresult := link.CheckHtlcForward(hash, 1500, 1200,\n\t\t\t200, 150, 0, lnwire.ShortChannelID{})\n\t\tif _, ok := result.WireMessage().(*lnwire.FailTemporaryChannelFailure); !ok {\n\t\t\tt.Fatalf(\"expected FailTemporaryChannelFailure failure code\")\n\t\t}\n\t})\n\n\tt.Run(\"insufficient fee\", func(t *testing.T) {\n\t\tresult := link.CheckHtlcForward(hash, 1005, 1000,\n\t\t\t200, 150, 0, lnwire.ShortChannelID{})\n\t\tif _, ok := result.WireMessage().(*lnwire.FailFeeInsufficient); !ok {\n\t\t\tt.Fatalf(\"expected FailFeeInsufficient failure code\")\n\t\t}\n\t})\n\n\tt.Run(\"expiry too soon\", func(t *testing.T) {\n\t\tresult := link.CheckHtlcForward(hash, 1500, 1000,\n\t\t\t200, 150, 190, lnwire.ShortChannelID{})\n\t\tif _, ok := result.WireMessage().(*lnwire.FailExpiryTooSoon); !ok {\n\t\t\tt.Fatalf(\"expected FailExpiryTooSoon failure code\")\n\t\t}\n\t})\n\n\tt.Run(\"incorrect cltv expiry\", func(t *testing.T) {\n\t\tresult := link.CheckHtlcForward(hash, 1500, 1000,\n\t\t\t200, 190, 0, lnwire.ShortChannelID{})\n\t\tif _, ok := result.WireMessage().(*lnwire.FailIncorrectCltvExpiry); !ok {\n\t\t\tt.Fatalf(\"expected FailIncorrectCltvExpiry failure code\")\n\t\t}\n\n\t})\n\n\tt.Run(\"cltv expiry too far in the future\", func(t *testing.T) {\n\t\t// Check that expiry isn't too far in the future.\n\t\tresult := link.CheckHtlcForward(hash, 1500, 1000,\n\t\t\t10200, 10100, 0, lnwire.ShortChannelID{})\n\t\tif _, ok := result.WireMessage().(*lnwire.FailExpiryTooFar); !ok {\n\t\t\tt.Fatalf(\"expected FailExpiryTooFar failure code\")\n\t\t}\n\t})\n}\n\n// TestChannelLinkCanceledInvoice in this test checks the interaction\n// between Alice and Bob for a canceled invoice.",
      "length": 2873,
      "tokens": 297,
      "embedding": []
    },
    {
      "slug": "func TestChannelLinkCanceledInvoice(t *testing.T) {",
      "content": "func TestChannelLinkCanceledInvoice(t *testing.T) {\n\tt.Parallel()\n\n\t// Setup a alice-bob network.\n\talice, bob, err := createTwoClusterChannels(\n\t\tt, btcutil.SatoshiPerBitcoin*3, btcutil.SatoshiPerBitcoin*5,\n\t)\n\trequire.NoError(t, err, \"unable to create channel\")\n\n\tn := newTwoHopNetwork(t, alice.channel, bob.channel, testStartingHeight)\n\n\t// Prepare an alice -> bob payment.\n\tamount := lnwire.NewMSatFromSatoshis(btcutil.SatoshiPerBitcoin)\n\thtlcAmt, totalTimelock, hops := generateHops(amount, testStartingHeight,\n\t\tn.bobChannelLink)\n\n\tfirstHop := n.bobChannelLink.ShortChanID()\n\n\tinvoice, payFunc, err := preparePayment(\n\t\tn.aliceServer, n.bobServer, firstHop, hops, amount, htlcAmt,\n\t\ttotalTimelock,\n\t)\n\trequire.NoError(t, err, \"unable to prepare the payment\")\n\n\t// Cancel the invoice at bob's end.\n\thash := invoice.Terms.PaymentPreimage.Hash()\n\terr = n.bobServer.registry.CancelInvoice(hash)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Have Alice fire the payment.\n\terr = waitForPayFuncResult(payFunc, 30*time.Second)\n\n\t// Because the invoice is canceled, we expect an unknown payment hash\n\t// result.\n\trtErr, ok := err.(ClearTextError)\n\tif !ok {\n\t\tt.Fatalf(\"expected ClearTextError, but got %v\", err)\n\t}\n\t_, ok = rtErr.WireMessage().(*lnwire.FailIncorrectDetails)\n\tif !ok {\n\t\tt.Fatalf(\"expected unknown payment hash, but got %v\", err)\n\t}\n}\n",
      "length": 1245,
      "tokens": 142,
      "embedding": []
    },
    {
      "slug": "type hodlInvoiceTestCtx struct {",
      "content": "type hodlInvoiceTestCtx struct {\n\tn                   *twoHopNetwork\n\tstartBandwidthAlice lnwire.MilliSatoshi\n\tstartBandwidthBob   lnwire.MilliSatoshi\n\thash                lntypes.Hash\n\tpreimage            lntypes.Preimage\n\tamount              lnwire.MilliSatoshi\n\terrChan             chan error\n\n\trestoreBob func() (*lnwallet.LightningChannel, error)\n}\n",
      "length": 311,
      "tokens": 20,
      "embedding": []
    },
    {
      "slug": "func newHodlInvoiceTestCtx(t *testing.T) (*hodlInvoiceTestCtx, error) {",
      "content": "func newHodlInvoiceTestCtx(t *testing.T) (*hodlInvoiceTestCtx, error) {\n\t// Setup a alice-bob network.\n\talice, bob, err := createTwoClusterChannels(\n\t\tt, btcutil.SatoshiPerBitcoin*3, btcutil.SatoshiPerBitcoin*5,\n\t)\n\trequire.NoError(t, err, \"unable to create channel\")\n\n\tn := newTwoHopNetwork(t, alice.channel, bob.channel, testStartingHeight)\n\n\taliceBandwidthBefore := n.aliceChannelLink.Bandwidth()\n\tbobBandwidthBefore := n.bobChannelLink.Bandwidth()\n\n\tdebug := false\n\tif debug {\n\t\t// Log message that alice receives.\n\t\tn.aliceServer.intersect(\n\t\t\tcreateLogFunc(\"alice\", n.aliceChannelLink.ChanID()),\n\t\t)\n\n\t\t// Log message that bob receives.\n\t\tn.bobServer.intersect(\n\t\t\tcreateLogFunc(\"bob\", n.bobChannelLink.ChanID()),\n\t\t)\n\t}\n\n\tamount := lnwire.NewMSatFromSatoshis(btcutil.SatoshiPerBitcoin)\n\thtlcAmt, totalTimelock, hops := generateHops(\n\t\tamount, testStartingHeight, n.bobChannelLink,\n\t)\n\n\t// Generate hold invoice preimage.\n\tr, err := generateRandomBytes(sha256.Size)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpreimage, err := lntypes.MakePreimage(r)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\thash := preimage.Hash()\n\n\t// Have alice pay the hodl invoice, wait for bob's commitment state to\n\t// be updated and the invoice state to be updated.\n\treceiver := n.bobServer\n\treceiver.registry.settleChan = make(chan lntypes.Hash)\n\tfirstHop := n.bobChannelLink.ShortChanID()\n\terrChan := n.makeHoldPayment(\n\t\tn.aliceServer, receiver, firstHop, hops, amount, htlcAmt,\n\t\ttotalTimelock, preimage,\n\t)\n\n\tselect {\n\tcase err := <-errChan:\n\t\tt.Fatalf(\"no payment result expected: %v\", err)\n\tcase <-time.After(5 * time.Second):\n\t\tt.Fatal(\"timeout\")\n\tcase h := <-receiver.registry.settleChan:\n\t\tif hash != h {\n\t\t\tt.Fatal(\"unexpected invoice settled\")\n\t\t}\n\t}\n\n\treturn &hodlInvoiceTestCtx{\n\t\tn:                   n,\n\t\tstartBandwidthAlice: aliceBandwidthBefore,\n\t\tstartBandwidthBob:   bobBandwidthBefore,\n\t\tpreimage:            preimage,\n\t\thash:                hash,\n\t\tamount:              amount,\n\t\terrChan:             errChan,\n\t\trestoreBob:          bob.restore,\n\t}, nil\n}\n\n// TestChannelLinkHoldInvoiceSettle asserts that a hodl invoice can be settled.",
      "length": 1981,
      "tokens": 208,
      "embedding": []
    },
    {
      "slug": "func TestChannelLinkHoldInvoiceSettle(t *testing.T) {",
      "content": "func TestChannelLinkHoldInvoiceSettle(t *testing.T) {\n\tt.Parallel()\n\n\tdefer timeout()()\n\n\tctx, err := newHodlInvoiceTestCtx(t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = ctx.n.bobServer.registry.SettleHodlInvoice(ctx.preimage)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Wait for payment to succeed.\n\terr = <-ctx.errChan\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Wait for Alice to receive the revocation. This is needed\n\t// because the settles are pipelined to the switch and otherwise\n\t// the bandwidth won't be updated by the time Alice receives a\n\t// response here.\n\ttime.Sleep(2 * time.Second)\n\n\tif ctx.startBandwidthAlice-ctx.amount !=\n\t\tctx.n.aliceChannelLink.Bandwidth() {\n\n\t\tt.Fatal(\"alice bandwidth should have decrease on payment \" +\n\t\t\t\"amount\")\n\t}\n\n\tif ctx.startBandwidthBob+ctx.amount !=\n\t\tctx.n.bobChannelLink.Bandwidth() {\n\n\t\tt.Fatalf(\"bob bandwidth isn't match: expected %v, got %v\",\n\t\t\tctx.startBandwidthBob+ctx.amount,\n\t\t\tctx.n.bobChannelLink.Bandwidth())\n\t}\n}\n\n// TestChannelLinkHoldInvoiceSettle asserts that a hodl invoice can be canceled.",
      "length": 958,
      "tokens": 123,
      "embedding": []
    },
    {
      "slug": "func TestChannelLinkHoldInvoiceCancel(t *testing.T) {",
      "content": "func TestChannelLinkHoldInvoiceCancel(t *testing.T) {\n\tt.Parallel()\n\n\tdefer timeout()()\n\n\tctx, err := newHodlInvoiceTestCtx(t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = ctx.n.bobServer.registry.CancelInvoice(ctx.hash)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Wait for payment to succeed.\n\terr = <-ctx.errChan\n\tassertFailureCode(t, err, lnwire.CodeIncorrectOrUnknownPaymentDetails)\n}\n\n// TestChannelLinkHoldInvoiceRestart asserts hodl htlcs are held after blocks\n// are mined and the link is restarted. The initial expiry checks should not\n// apply to hodl htlcs after restart.",
      "length": 501,
      "tokens": 67,
      "embedding": []
    },
    {
      "slug": "func TestChannelLinkHoldInvoiceRestart(t *testing.T) {",
      "content": "func TestChannelLinkHoldInvoiceRestart(t *testing.T) {\n\tt.Parallel()\n\n\tdefer timeout()()\n\n\tconst (\n\t\tchanAmt = btcutil.SatoshiPerBitcoin * 5\n\t)\n\n\t// We'll start by creating a new link with our chanAmt (5 BTC). We will\n\t// only be testing Alice's behavior, so the reference to Bob's channel\n\t// state is unnecessary.\n\taliceLink, bobChannel, _, start, restore, err :=\n\t\tnewSingleLinkTestHarness(t, chanAmt, 0)\n\trequire.NoError(t, err, \"unable to create link\")\n\n\talice := newPersistentLinkHarness(\n\t\tt, aliceLink, nil, restore,\n\t)\n\n\tif err := start(); err != nil {\n\t\tt.Fatalf(\"unable to start test harness: %v\", err)\n\t}\n\n\tvar (\n\t\tcoreLink = alice.coreLink\n\t\tregistry = coreLink.cfg.Registry.(*mockInvoiceRegistry)\n\t)\n\n\tregistry.settleChan = make(chan lntypes.Hash)\n\n\thtlc, invoice := generateHtlcAndInvoice(t, 0)\n\n\t// Convert into a hodl invoice and save the preimage for later.\n\tpreimage := invoice.Terms.PaymentPreimage\n\tinvoice.Terms.PaymentPreimage = nil\n\tinvoice.HodlInvoice = true\n\n\t// We must add the invoice to the registry, such that Alice\n\t// expects this payment.\n\terr = registry.AddInvoice(\n\t\t*invoice, htlc.PaymentHash,\n\t)\n\trequire.NoError(t, err, \"unable to add invoice to registry\")\n\n\tctx := linkTestContext{\n\t\tt:          t,\n\t\taliceLink:  alice.link,\n\t\taliceMsgs:  alice.msgs,\n\t\tbobChannel: bobChannel,\n\t}\n\n\t// Lock in htlc paying the hodl invoice.\n\tctx.sendHtlcBobToAlice(htlc)\n\tctx.sendCommitSigBobToAlice(1)\n\tctx.receiveRevAndAckAliceToBob()\n\tctx.receiveCommitSigAliceToBob(1)\n\tctx.sendRevAndAckBobToAlice()\n\n\t// We expect a call to the invoice registry to notify the arrival of the\n\t// htlc.\n\t<-registry.settleChan\n\n\t// Increase block height. This height will be retrieved by the link\n\t// after restart.\n\tcoreLink.cfg.Switch.bestHeight++\n\n\t// Restart link.\n\talice.restart(false, false)\n\tctx.aliceLink = alice.link\n\tctx.aliceMsgs = alice.msgs\n\n\t// Expect htlc to be reprocessed.\n\t<-registry.settleChan\n\n\t// Settle the invoice with the preimage.\n\terr = registry.SettleHodlInvoice(*preimage)\n\trequire.NoError(t, err, \"settle hodl invoice\")\n\n\t// Expect alice to send a settle and commitsig message to bob.\n\tctx.receiveSettleAliceToBob()\n\tctx.receiveCommitSigAliceToBob(0)\n\n\t// Stop the link\n\talice.link.Stop()\n\n\t// Check that no unexpected messages were sent.\n\tselect {\n\tcase msg := <-alice.msgs:\n\t\tt.Fatalf(\"did not expect message %T\", msg)\n\tdefault:\n\t}\n}\n\n// TestChannelLinkRevocationWindowRegular asserts that htlcs paying to a regular\n// invoice are settled even if the revocation window gets exhausted.",
      "length": 2371,
      "tokens": 305,
      "embedding": []
    },
    {
      "slug": "func TestChannelLinkRevocationWindowRegular(t *testing.T) {",
      "content": "func TestChannelLinkRevocationWindowRegular(t *testing.T) {\n\tt.Parallel()\n\n\tconst (\n\t\tchanAmt = btcutil.SatoshiPerBitcoin * 5\n\t)\n\n\t// We'll start by creating a new link with our chanAmt (5 BTC). We will\n\t// only be testing Alice's behavior, so the reference to Bob's channel\n\t// state is unnecessary.\n\taliceLink, bobChannel, _, start, _, err :=\n\t\tnewSingleLinkTestHarness(t, chanAmt, 0)\n\trequire.NoError(t, err, \"unable to create link\")\n\n\tif err := start(); err != nil {\n\t\tt.Fatalf(\"unable to start test harness: %v\", err)\n\t}\n\tt.Cleanup(aliceLink.Stop)\n\n\tvar (\n\t\tcoreLink  = aliceLink.(*channelLink)\n\t\tregistry  = coreLink.cfg.Registry.(*mockInvoiceRegistry)\n\t\taliceMsgs = coreLink.cfg.Peer.(*mockPeer).sentMsgs\n\t)\n\n\tctx := linkTestContext{\n\t\tt:          t,\n\t\taliceLink:  aliceLink,\n\t\taliceMsgs:  aliceMsgs,\n\t\tbobChannel: bobChannel,\n\t}\n\n\tregistry.settleChan = make(chan lntypes.Hash)\n\n\thtlc1, invoice1 := generateHtlcAndInvoice(t, 0)\n\thtlc2, invoice2 := generateHtlcAndInvoice(t, 1)\n\n\t// We must add the invoice to the registry, such that Alice\n\t// expects this payment.\n\terr = registry.AddInvoice(*invoice1, htlc1.PaymentHash)\n\trequire.NoError(t, err, \"unable to add invoice to registry\")\n\terr = registry.AddInvoice(*invoice2, htlc2.PaymentHash)\n\trequire.NoError(t, err, \"unable to add invoice to registry\")\n\n\t// Lock in htlc 1 on both sides.\n\tctx.sendHtlcBobToAlice(htlc1)\n\tctx.sendCommitSigBobToAlice(1)\n\tctx.receiveRevAndAckAliceToBob()\n\tctx.receiveCommitSigAliceToBob(1)\n\tctx.sendRevAndAckBobToAlice()\n\n\t// We expect a call to the invoice registry to notify the arrival of the\n\t// htlc.\n\tselect {\n\tcase <-registry.settleChan:\n\tcase <-time.After(5 * time.Second):\n\t\tt.Fatal(\"expected invoice to be settled\")\n\t}\n\n\t// Expect alice to send a settle and commitsig message to bob. Bob does\n\t// not yet send the revocation.\n\tctx.receiveSettleAliceToBob()\n\tctx.receiveCommitSigAliceToBob(0)\n\n\t// Pay invoice 2.\n\tctx.sendHtlcBobToAlice(htlc2)\n\tctx.sendCommitSigBobToAlice(2)\n\tctx.receiveRevAndAckAliceToBob()\n\n\t// At this point, Alice cannot send a new commit sig to bob because the\n\t// revocation window is exhausted.\n\n\t// Bob sends revocation and signs commit with htlc1 settled.\n\tctx.sendRevAndAckBobToAlice()\n\n\t// After the revocation, it is again possible for Alice to send a commit\n\t// sig with htlc2.\n\tctx.receiveCommitSigAliceToBob(1)\n}\n\n// TestChannelLinkRevocationWindowHodl asserts that htlcs paying to a hodl\n// invoice are settled even if the revocation window gets exhausted.",
      "length": 2346,
      "tokens": 295,
      "embedding": []
    },
    {
      "slug": "func TestChannelLinkRevocationWindowHodl(t *testing.T) {",
      "content": "func TestChannelLinkRevocationWindowHodl(t *testing.T) {\n\tt.Parallel()\n\n\tconst (\n\t\tchanAmt = btcutil.SatoshiPerBitcoin * 5\n\t)\n\n\t// We'll start by creating a new link with our chanAmt (5 BTC). We will\n\t// only be testing Alice's behavior, so the reference to Bob's channel\n\t// state is unnecessary.\n\taliceLink, bobChannel, batchTicker, start, _, err :=\n\t\tnewSingleLinkTestHarness(t, chanAmt, 0)\n\trequire.NoError(t, err, \"unable to create link\")\n\n\tif err := start(); err != nil {\n\t\tt.Fatalf(\"unable to start test harness: %v\", err)\n\t}\n\n\tvar (\n\t\tcoreLink  = aliceLink.(*channelLink)\n\t\tregistry  = coreLink.cfg.Registry.(*mockInvoiceRegistry)\n\t\taliceMsgs = coreLink.cfg.Peer.(*mockPeer).sentMsgs\n\t)\n\n\tregistry.settleChan = make(chan lntypes.Hash)\n\n\t// Generate two invoice-htlc pairs.\n\thtlc1, invoice1 := generateHtlcAndInvoice(t, 0)\n\thtlc2, invoice2 := generateHtlcAndInvoice(t, 1)\n\n\t// Convert into hodl invoices and save the preimages for later.\n\tpreimage1 := invoice1.Terms.PaymentPreimage\n\tinvoice1.Terms.PaymentPreimage = nil\n\tinvoice1.HodlInvoice = true\n\n\tpreimage2 := invoice2.Terms.PaymentPreimage\n\tinvoice2.Terms.PaymentPreimage = nil\n\tinvoice2.HodlInvoice = true\n\n\t// We must add the invoices to the registry, such that Alice\n\t// expects the payments.\n\terr = registry.AddInvoice(*invoice1, htlc1.PaymentHash)\n\trequire.NoError(t, err, \"unable to add invoice to registry\")\n\terr = registry.AddInvoice(*invoice2, htlc2.PaymentHash)\n\trequire.NoError(t, err, \"unable to add invoice to registry\")\n\n\tctx := linkTestContext{\n\t\tt:          t,\n\t\taliceLink:  aliceLink,\n\t\taliceMsgs:  aliceMsgs,\n\t\tbobChannel: bobChannel,\n\t}\n\n\t// Lock in htlc 1 on both sides.\n\tctx.sendHtlcBobToAlice(htlc1)\n\tctx.sendCommitSigBobToAlice(1)\n\tctx.receiveRevAndAckAliceToBob()\n\tctx.receiveCommitSigAliceToBob(1)\n\tctx.sendRevAndAckBobToAlice()\n\n\t// We expect a call to the invoice registry to notify the arrival of\n\t// htlc 1.\n\tselect {\n\tcase <-registry.settleChan:\n\tcase <-time.After(15 * time.Second):\n\t\tt.Fatal(\"exit hop notification not received\")\n\t}\n\n\t// Lock in htlc 2 on both sides.\n\tctx.sendHtlcBobToAlice(htlc2)\n\tctx.sendCommitSigBobToAlice(2)\n\tctx.receiveRevAndAckAliceToBob()\n\tctx.receiveCommitSigAliceToBob(2)\n\tctx.sendRevAndAckBobToAlice()\n\n\tselect {\n\tcase <-registry.settleChan:\n\tcase <-time.After(15 * time.Second):\n\t\tt.Fatal(\"exit hop notification not received\")\n\t}\n\n\t// Settle invoice 1 with the preimage.\n\terr = registry.SettleHodlInvoice(*preimage1)\n\trequire.NoError(t, err, \"settle hodl invoice\")\n\n\t// Expect alice to send a settle and commitsig message to bob. Bob does\n\t// not yet send the revocation.\n\tctx.receiveSettleAliceToBob()\n\tctx.receiveCommitSigAliceToBob(1)\n\n\t// Settle invoice 2 with the preimage.\n\terr = registry.SettleHodlInvoice(*preimage2)\n\trequire.NoError(t, err, \"settle hodl invoice\")\n\n\t// Expect alice to send a settle for htlc 2.\n\tctx.receiveSettleAliceToBob()\n\n\t// At this point, Alice cannot send a new commit sig to bob because the\n\t// revocation window is exhausted.\n\n\t// Sleep to let timer(s) expire.\n\ttime.Sleep(time.Second)\n\n\t// We don't expect a commitSig from Alice.\n\tselect {\n\tcase msg := <-aliceMsgs:\n\t\tt.Fatalf(\"did not expect message %T\", msg)\n\tdefault:\n\t}\n\n\t// Bob sends revocation and signs commit with htlc 1 settled.\n\tctx.sendRevAndAckBobToAlice()\n\n\t// Allow some time for it to be processed by the link.\n\ttime.Sleep(time.Second)\n\n\t// Trigger the batch timer as this may trigger Alice to send a commit\n\t// sig.\n\tbatchTicker <- time.Time{}\n\n\t// After the revocation, it is again possible for Alice to send a commit\n\t// sig no more htlcs. Bob acks the update.\n\tctx.receiveCommitSigAliceToBob(0)\n\tctx.sendRevAndAckBobToAlice()\n\n\t// Bob updates his remote commit tx.\n\tctx.sendCommitSigBobToAlice(0)\n\tctx.receiveRevAndAckAliceToBob()\n\n\t// Stop the link\n\taliceLink.Stop()\n\n\t// Check that no unexpected messages were sent.\n\tselect {\n\tcase msg := <-aliceMsgs:\n\t\tt.Fatalf(\"did not expect message %T\", msg)\n\tdefault:\n\t}\n}\n\n// TestChannelLinkReceiveEmptySig tests the response of the link to receiving an\n// empty commit sig. This should be tolerated, but we shouldn't send out an\n// empty sig ourselves.",
      "length": 3927,
      "tokens": 502,
      "embedding": []
    },
    {
      "slug": "func TestChannelLinkReceiveEmptySig(t *testing.T) {",
      "content": "func TestChannelLinkReceiveEmptySig(t *testing.T) {\n\tt.Parallel()\n\n\tconst chanAmt = btcutil.SatoshiPerBitcoin * 5\n\tconst chanReserve = btcutil.SatoshiPerBitcoin * 1\n\taliceLink, bobChannel, batchTicker, start, _, err :=\n\t\tnewSingleLinkTestHarness(t, chanAmt, chanReserve)\n\trequire.NoError(t, err, \"unable to create link\")\n\n\tif err := start(); err != nil {\n\t\tt.Fatalf(\"unable to start test harness: %v\", err)\n\t}\n\n\tvar (\n\t\tcoreLink  = aliceLink.(*channelLink)\n\t\taliceMsgs = coreLink.cfg.Peer.(*mockPeer).sentMsgs\n\t)\n\n\tctx := linkTestContext{\n\t\tt:          t,\n\t\taliceLink:  aliceLink,\n\t\taliceMsgs:  aliceMsgs,\n\t\tbobChannel: bobChannel,\n\t}\n\n\thtlc, _ := generateHtlcAndInvoice(t, 0)\n\n\t// First, send an Add from Alice to Bob.\n\tctx.sendHtlcAliceToBob(0, htlc)\n\tctx.receiveHtlcAliceToBob()\n\n\t// Tick the batch ticker to trigger a commitsig from Alice->Bob.\n\tselect {\n\tcase batchTicker <- time.Now():\n\tcase <-time.After(5 * time.Second):\n\t\tt.Fatalf(\"could not force commit sig\")\n\t}\n\n\t// Make Bob send a CommitSig. Since Bob hasn't received Alice's sig, he\n\t// cannot add the htlc to his remote tx yet. The commit sig that we\n\t// force Bob to send will be empty. Note that this normally does not\n\t// happen, because the link (which is not present for Bob in this test)\n\t// check whether Bob actually owes a sig first.\n\tctx.sendCommitSigBobToAlice(0)\n\n\t// Receive a CommitSig from Alice covering the htlc from above.\n\tctx.receiveCommitSigAliceToBob(1)\n\n\t// Wait for RevokeAndAck Alice->Bob. Even though Bob sent an empty\n\t// commit sig, Alice still needs to revoke the previous commitment tx.\n\tctx.receiveRevAndAckAliceToBob()\n\n\t// Send RevokeAndAck Bob->Alice to ack the added htlc.\n\tctx.sendRevAndAckBobToAlice()\n\n\t// We received an empty commit sig, we accepted it, but there is nothing\n\t// new to sign for us.\n\n\t// No other messages are expected.\n\tctx.assertNoMsgFromAlice(time.Second)\n\n\t// Stop the link\n\taliceLink.Stop()\n}\n\n// TestPendingCommitTicker tests that a link will fail itself after a timeout if\n// the commitment dance stalls out.",
      "length": 1918,
      "tokens": 274,
      "embedding": []
    },
    {
      "slug": "func TestPendingCommitTicker(t *testing.T) {",
      "content": "func TestPendingCommitTicker(t *testing.T) {\n\tt.Parallel()\n\n\tconst chanAmt = btcutil.SatoshiPerBitcoin * 5\n\tconst chanReserve = btcutil.SatoshiPerBitcoin * 1\n\taliceLink, bobChannel, batchTicker, start, _, err :=\n\t\tnewSingleLinkTestHarness(t, chanAmt, chanReserve)\n\trequire.NoError(t, err, \"unable to create link\")\n\n\tvar (\n\t\tcoreLink  = aliceLink.(*channelLink)\n\t\taliceMsgs = coreLink.cfg.Peer.(*mockPeer).sentMsgs\n\t)\n\n\tcoreLink.cfg.PendingCommitTicker = ticker.NewForce(time.Millisecond)\n\n\tlinkErrs := make(chan LinkFailureError)\n\tcoreLink.cfg.OnChannelFailure = func(_ lnwire.ChannelID,\n\t\t_ lnwire.ShortChannelID, linkErr LinkFailureError) {\n\n\t\tlinkErrs <- linkErr\n\t}\n\n\tif err := start(); err != nil {\n\t\tt.Fatalf(\"unable to start test harness: %v\", err)\n\t}\n\n\tctx := linkTestContext{\n\t\tt:          t,\n\t\taliceLink:  aliceLink,\n\t\tbobChannel: bobChannel,\n\t\taliceMsgs:  aliceMsgs,\n\t}\n\n\t// Send an HTLC from Alice to Bob, and signal the batch ticker to signa\n\t// a commitment.\n\thtlc, _ := generateHtlcAndInvoice(t, 0)\n\tctx.sendHtlcAliceToBob(0, htlc)\n\tctx.receiveHtlcAliceToBob()\n\tbatchTicker <- time.Now()\n\n\tselect {\n\tcase msg := <-aliceMsgs:\n\t\tif _, ok := msg.(*lnwire.CommitSig); !ok {\n\t\t\tt.Fatalf(\"expected CommitSig, got: %T\", msg)\n\t\t}\n\tcase <-time.After(time.Second):\n\t\tt.Fatalf(\"alice did not send commit sig\")\n\t}\n\n\t// Check that Alice hasn't failed.\n\tselect {\n\tcase linkErr := <-linkErrs:\n\t\tt.Fatalf(\"link failed unexpectedly: %v\", linkErr)\n\tcase <-time.After(50 * time.Millisecond):\n\t}\n\n\t// Without completing the dance, send another HTLC from Alice to Bob.\n\t// Since the revocation window has been exhausted, we should see the\n\t// link fail itself immediately due to the low pending commit timeout.\n\t// In production this would be much longer, e.g. a minute.\n\thtlc, _ = generateHtlcAndInvoice(t, 1)\n\tctx.sendHtlcAliceToBob(1, htlc)\n\tctx.receiveHtlcAliceToBob()\n\tbatchTicker <- time.Now()\n\n\t// Assert that we get the expected link failure from Alice.\n\tselect {\n\tcase linkErr := <-linkErrs:\n\t\tif linkErr.code != ErrRemoteUnresponsive {\n\t\t\tt.Fatalf(\"error code mismatch, \"+\n\t\t\t\t\"want: ErrRemoteUnresponsive, got: %v\",\n\t\t\t\tlinkErr.code)\n\t\t}\n\n\tcase <-time.After(time.Second):\n\t\tt.Fatalf(\"did not receive failure\")\n\t}\n}\n\n// TestShutdownIfChannelClean tests that a link will exit the htlcManager loop\n// if and only if the underlying channel state is clean.",
      "length": 2230,
      "tokens": 285,
      "embedding": []
    },
    {
      "slug": "func TestShutdownIfChannelClean(t *testing.T) {",
      "content": "func TestShutdownIfChannelClean(t *testing.T) {\n\tt.Parallel()\n\n\tconst chanAmt = btcutil.SatoshiPerBitcoin * 5\n\tconst chanReserve = btcutil.SatoshiPerBitcoin * 1\n\taliceLink, bobChannel, batchTicker, start, _, err :=\n\t\tnewSingleLinkTestHarness(t, chanAmt, chanReserve)\n\trequire.NoError(t, err)\n\n\tvar (\n\t\tcoreLink  = aliceLink.(*channelLink)\n\t\taliceMsgs = coreLink.cfg.Peer.(*mockPeer).sentMsgs\n\t)\n\n\tshutdownAssert := func(expectedErr error) {\n\t\terr = aliceLink.ShutdownIfChannelClean()\n\t\tif expectedErr != nil {\n\t\t\trequire.Error(t, err, expectedErr)\n\t\t} else {\n\t\t\trequire.NoError(t, err)\n\t\t}\n\t}\n\n\terr = start()\n\trequire.NoError(t, err)\n\n\tctx := linkTestContext{\n\t\tt:          t,\n\t\taliceLink:  aliceLink,\n\t\tbobChannel: bobChannel,\n\t\taliceMsgs:  aliceMsgs,\n\t}\n\n\t// First send an HTLC from Bob to Alice and assert that the link can't\n\t// be shutdown while the update is outstanding.\n\thtlc := generateHtlc(t, coreLink, 0)\n\n\t// <---add-----\n\tctx.sendHtlcBobToAlice(htlc)\n\t// <---sig-----\n\tctx.sendCommitSigBobToAlice(1)\n\t// ----rev---->\n\tctx.receiveRevAndAckAliceToBob()\n\tshutdownAssert(ErrLinkFailedShutdown)\n\n\t// ----sig---->\n\tctx.receiveCommitSigAliceToBob(1)\n\tshutdownAssert(ErrLinkFailedShutdown)\n\n\t// <---rev-----\n\tctx.sendRevAndAckBobToAlice()\n\tshutdownAssert(ErrLinkFailedShutdown)\n\n\t// ---settle-->\n\tctx.receiveSettleAliceToBob()\n\tshutdownAssert(ErrLinkFailedShutdown)\n\n\t// ----sig---->\n\tctx.receiveCommitSigAliceToBob(0)\n\tshutdownAssert(ErrLinkFailedShutdown)\n\n\t// <---rev-----\n\tctx.sendRevAndAckBobToAlice()\n\tshutdownAssert(ErrLinkFailedShutdown)\n\n\t// There is currently no controllable breakpoint between Alice\n\t// receiving the CommitSig and her sending out the RevokeAndAck. As\n\t// soon as the RevokeAndAck is generated, the channel becomes clean.\n\t// This can happen right after the CommitSig is received, so there is\n\t// no shutdown assertion here.\n\t// <---sig-----\n\tctx.sendCommitSigBobToAlice(0)\n\n\t// ----rev---->\n\tctx.receiveRevAndAckAliceToBob()\n\tshutdownAssert(nil)\n\n\t// Now that the link has exited the htlcManager loop, attempt to\n\t// trigger the batch ticker. It should not be possible.\n\tselect {\n\tcase batchTicker <- time.Now():\n\t\tt.Fatalf(\"expected batch ticker to be inactive\")\n\tcase <-time.After(5 * time.Second):\n\t}\n}\n\n// TestPipelineSettle tests that a link should only pipeline a settle if the\n// related add is fully locked-in meaning it is on both sides' commitment txns.",
      "length": 2263,
      "tokens": 255,
      "embedding": []
    },
    {
      "slug": "func TestPipelineSettle(t *testing.T) {",
      "content": "func TestPipelineSettle(t *testing.T) {\n\tt.Parallel()\n\n\tconst chanAmt = btcutil.SatoshiPerBitcoin * 5\n\tconst chanReserve = btcutil.SatoshiPerBitcoin * 1\n\taliceLink, bobChannel, _, start, restore, err :=\n\t\tnewSingleLinkTestHarness(t, chanAmt, chanReserve)\n\trequire.NoError(t, err)\n\n\talice := newPersistentLinkHarness(\n\t\tt, aliceLink, nil, restore,\n\t)\n\n\tlinkErrors := make(chan LinkFailureError, 1)\n\n\t// Modify OnChannelFailure so we are notified when the link is failed.\n\talice.coreLink.cfg.OnChannelFailure = func(_ lnwire.ChannelID,\n\t\t_ lnwire.ShortChannelID, linkErr LinkFailureError) {\n\n\t\tlinkErrors <- linkErr\n\t}\n\n\t// Modify ForwardPackets so we are notified if a settle packet is\n\t// erroneously forwarded. If the forwardChan is closed before the last\n\t// step, then the test will fail.\n\tforwardChan := make(chan struct{})\n\tfwdPkts := func(c chan struct{}, _ bool, hp ...*htlcPacket) error {\n\t\tclose(forwardChan)\n\t\treturn nil\n\t}\n\talice.coreLink.cfg.ForwardPackets = fwdPkts\n\n\t// Put Alice in ExitSettle mode, so we can simulate a multi-hop route\n\t// without actually doing so. This allows us to test the locked-in add\n\t// logic without having the add being removed by Alice sending a\n\t// settle.\n\talice.coreLink.cfg.HodlMask = hodl.Mask(hodl.ExitSettle)\n\n\terr = start()\n\trequire.NoError(t, err)\n\n\tctx := linkTestContext{\n\t\tt:          t,\n\t\taliceLink:  alice.link,\n\t\tbobChannel: bobChannel,\n\t\taliceMsgs:  alice.msgs,\n\t}\n\n\t// First lock in an HTLC from Bob to Alice.\n\thtlc1, invoice1 := generateHtlcAndInvoice(t, 0)\n\tpreimage1 := invoice1.Terms.PaymentPreimage\n\n\t// Add the invoice to Alice's registry so she expects it.\n\taliceReg := alice.coreLink.cfg.Registry.(*mockInvoiceRegistry)\n\terr = aliceReg.AddInvoice(*invoice1, htlc1.PaymentHash)\n\trequire.NoError(t, err)\n\n\t// <---add-----\n\tctx.sendHtlcBobToAlice(htlc1)\n\t// <---sig-----\n\tctx.sendCommitSigBobToAlice(1)\n\t// ----rev---->\n\tctx.receiveRevAndAckAliceToBob()\n\t// ----sig---->\n\tctx.receiveCommitSigAliceToBob(1)\n\t// <---rev-----\n\tctx.sendRevAndAckBobToAlice()\n\n\t// Bob will send the preimage for the HTLC he just sent. This will test\n\t// the check that the HTLC is locked-in. The channel should not be\n\t// force closed if everything is working correctly.\n\tsettle1 := &lnwire.UpdateFulfillHTLC{\n\t\tID:              0,\n\t\tPaymentPreimage: *preimage1,\n\t}\n\tctx.aliceLink.HandleChannelUpdate(settle1)\n\n\t// ForceClose should be false.\n\tselect {\n\tcase linkErr := <-linkErrors:\n\t\trequire.False(t, linkErr.ForceClose)\n\tcase <-forwardChan:\n\t\tt.Fatal(\"packet was erroneously forwarded\")\n\t}\n\n\t// Restart Alice's link with the hodl.ExitSettle and hodl.Commit flags.\n\talice.restart(false, false, hodl.ExitSettle, hodl.Commit)\n\tctx.aliceLink = alice.link\n\tctx.aliceMsgs = alice.msgs\n\n\talice.coreLink.cfg.OnChannelFailure = func(_ lnwire.ChannelID,\n\t\t_ lnwire.ShortChannelID, linkErr LinkFailureError) {\n\n\t\tlinkErrors <- linkErr\n\t}\n\talice.coreLink.cfg.ForwardPackets = fwdPkts\n\n\t// Alice will now send an HTLC to Bob, but won't sign a commitment for\n\t// it. This HTLC will have the same payment hash as the one above.\n\thtlc2 := htlc1\n\n\t// ----add--->\n\tctx.sendHtlcAliceToBob(0, htlc2)\n\tctx.receiveHtlcAliceToBob()\n\n\t// Now Bob will send a settle backwards before the HTLC is locked in\n\t// and the link should be failed again.\n\tsettle2 := &lnwire.UpdateFulfillHTLC{\n\t\tID:              0,\n\t\tPaymentPreimage: *preimage1,\n\t}\n\tctx.aliceLink.HandleChannelUpdate(settle2)\n\n\t// ForceClose should be false.\n\tselect {\n\tcase linkErr := <-linkErrors:\n\t\trequire.False(t, linkErr.ForceClose)\n\tcase <-forwardChan:\n\t\tt.Fatal(\"packet was erroneously forwarded\")\n\t}\n\n\t// Restart Alice's link without the hodl.Commit flag.\n\talice.restart(false, false, hodl.ExitSettle)\n\tctx.aliceLink = alice.link\n\tctx.aliceMsgs = alice.msgs\n\n\talice.coreLink.cfg.OnChannelFailure = func(_ lnwire.ChannelID,\n\t\t_ lnwire.ShortChannelID, linkErr LinkFailureError) {\n\n\t\tlinkErrors <- linkErr\n\t}\n\talice.coreLink.cfg.ForwardPackets = fwdPkts\n\n\t// Alice's mailbox should give the link the HTLC to send again.\n\tselect {\n\tcase msg := <-ctx.aliceMsgs:\n\t\t_, ok := msg.(*lnwire.UpdateAddHTLC)\n\t\trequire.True(t, ok)\n\tcase <-time.After(5 * time.Second):\n\t\tt.Fatal(\"did not receive htlc from alice\")\n\t}\n\n\t// Trigger the BatchTicker.\n\tselect {\n\tcase alice.batchTicker <- time.Now():\n\tcase <-time.After(5 * time.Second):\n\t\tt.Fatalf(\"could not force commit sig\")\n\t}\n\n\t// ----sig--->\n\tctx.receiveCommitSigAliceToBob(2)\n\t// <---rev----\n\tctx.sendRevAndAckBobToAlice()\n\t// <---sig----\n\tctx.sendCommitSigBobToAlice(2)\n\t// ----rev--->\n\tctx.receiveRevAndAckAliceToBob()\n\n\t// Bob should now be able to send the settle to Alice without making\n\t// the link fail.\n\tctx.aliceLink.HandleChannelUpdate(settle2)\n\n\tselect {\n\tcase <-linkErrors:\n\t\tt.Fatal(\"should not have received a link error\")\n\tcase <-forwardChan:\n\t\t// success\n\t}\n}\n\n// assertFailureCode asserts that an error is of type ClearTextError and that\n// the failure code is as expected.",
      "length": 4708,
      "tokens": 572,
      "embedding": []
    },
    {
      "slug": "func assertFailureCode(t *testing.T, err error, code lnwire.FailCode) {",
      "content": "func assertFailureCode(t *testing.T, err error, code lnwire.FailCode) {\n\trtErr, ok := err.(ClearTextError)\n\tif !ok {\n\t\tt.Fatalf(\"expected ClearTextError but got %T\", err)\n\t}\n\n\tif rtErr.WireMessage().Code() != code {\n\t\tt.Fatalf(\"expected %v but got %v\",\n\t\t\tcode, rtErr.WireMessage().Code())\n\t}\n}\n\n// TestChannelLinkShortFailureRelay tests that failure reasons that are too\n// short are replaced by a spec-compliant length failure message and relayed\n// back.",
      "length": 372,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func TestChannelLinkShortFailureRelay(t *testing.T) {",
      "content": "func TestChannelLinkShortFailureRelay(t *testing.T) {\n\tt.Parallel()\n\n\tdefer timeout()()\n\n\tconst chanAmt = btcutil.SatoshiPerBitcoin * 5\n\n\taliceLink, bobChannel, batchTicker, start, _, err :=\n\t\tnewSingleLinkTestHarness(t, chanAmt, 0)\n\trequire.NoError(t, err, \"unable to create link\")\n\n\trequire.NoError(t, start())\n\n\tcoreLink, ok := aliceLink.(*channelLink)\n\trequire.True(t, ok)\n\n\tmockPeer, ok := coreLink.cfg.Peer.(*mockPeer)\n\trequire.True(t, ok)\n\n\taliceMsgs := mockPeer.sentMsgs\n\tswitchChan := make(chan *htlcPacket)\n\n\tcoreLink.cfg.ForwardPackets = func(linkQuit chan struct{}, _ bool,\n\t\tpackets ...*htlcPacket) error {\n\n\t\tfor _, p := range packets {\n\t\t\tswitchChan <- p\n\t\t}\n\n\t\treturn nil\n\t}\n\n\tctx := linkTestContext{\n\t\tt:          t,\n\t\taliceLink:  aliceLink,\n\t\taliceMsgs:  aliceMsgs,\n\t\tbobChannel: bobChannel,\n\t}\n\n\t// Send and lock in htlc from Alice to Bob.\n\tconst htlcID = 0\n\n\thtlc, _ := generateHtlcAndInvoice(t, htlcID)\n\tctx.sendHtlcAliceToBob(htlcID, htlc)\n\tctx.receiveHtlcAliceToBob()\n\n\tbatchTicker <- time.Now()\n\n\tctx.receiveCommitSigAliceToBob(1)\n\tctx.sendRevAndAckBobToAlice()\n\n\tctx.sendCommitSigBobToAlice(1)\n\tctx.receiveRevAndAckAliceToBob()\n\n\t// Return a short htlc failure from Bob to Alice and lock in.\n\tshortReason := make([]byte, 260)\n\n\terr = bobChannel.FailHTLC(0, shortReason, nil, nil, nil)\n\trequire.NoError(t, err)\n\n\taliceLink.HandleChannelUpdate(&lnwire.UpdateFailHTLC{\n\t\tID:     htlcID,\n\t\tReason: shortReason,\n\t})\n\n\tctx.sendCommitSigBobToAlice(0)\n\tctx.receiveRevAndAckAliceToBob()\n\tctx.receiveCommitSigAliceToBob(0)\n\tctx.sendRevAndAckBobToAlice()\n\n\t// Assert that switch gets the fail message.\n\tmsg := <-switchChan\n\n\thtlcFailMsg, ok := msg.htlc.(*lnwire.UpdateFailHTLC)\n\trequire.True(t, ok)\n\n\t// Assert that it is not a converted error.\n\trequire.False(t, msg.convertedError)\n\n\t// Assert that the length is corrected to the spec-compliant length of\n\t// 256 bytes plus overhead.\n\trequire.Len(t, htlcFailMsg.Reason, 292)\n\n\t// Stop the link\n\taliceLink.Stop()\n\n\t// Check that no unexpected messages were sent.\n\tselect {\n\tcase msg := <-aliceMsgs:\n\t\trequire.Fail(t, \"did not expect message %T\", msg)\n\n\tcase msg := <-switchChan:\n\t\trequire.Fail(t, \"did not expect switch message %T\", msg)\n\n\tdefault:\n\t}\n}\n",
      "length": 2068,
      "tokens": 237,
      "embedding": []
    }
  ]
}