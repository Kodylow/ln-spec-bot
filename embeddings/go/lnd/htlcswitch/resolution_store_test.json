{
  "filepath": "../implementations/go/lnd/htlcswitch/resolution_store_test.go",
  "package": "htlcswitch",
  "sections": [
    {
      "slug": "func TestInsertAndDelete(t *testing.T) {",
      "content": "func TestInsertAndDelete(t *testing.T) {\n\tt.Parallel()\n\n\tscid := lnwire.NewShortChanIDFromInt(1)\n\n\tfailResMsg := &contractcourt.ResolutionMsg{\n\t\tSourceChan: scid,\n\t\tHtlcIndex:  2,\n\t\tFailure:    &lnwire.FailTemporaryChannelFailure{},\n\t}\n\n\tsettleBytes := [32]byte{\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n\t}\n\n\tsettleResMsg := &contractcourt.ResolutionMsg{\n\t\tSourceChan: scid,\n\t\tHtlcIndex:  3,\n\t\tPreImage:   &settleBytes,\n\t}\n\n\t// Create the backend database and use it to create the resolution\n\t// store.\n\tdbPath := filepath.Join(t.TempDir(), \"testdb\")\n\tdb, err := kvdb.Create(\n\t\tkvdb.BoltBackendName, dbPath, true, kvdb.DefaultDBTimeout,\n\t)\n\trequire.NoError(t, err)\n\tt.Cleanup(func() {\n\t\tdb.Close()\n\t})\n\n\tresStore := newResolutionStore(db)\n\n\t// We'll add the failure resolution message first, then check that it\n\t// exists in the store.\n\terr = resStore.addResolutionMsg(failResMsg)\n\trequire.NoError(t, err)\n\n\t// Assert that checkResolutionMsg returns nil, signalling that the\n\t// resolution message was properly stored.\n\toutKey := &CircuitKey{\n\t\tChanID: failResMsg.SourceChan,\n\t\tHtlcID: failResMsg.HtlcIndex,\n\t}\n\terr = resStore.checkResolutionMsg(outKey)\n\trequire.NoError(t, err)\n\n\tresMsgs, err := resStore.fetchAllResolutionMsg()\n\trequire.NoError(t, err)\n\trequire.Equal(t, 1, len(resMsgs))\n\n\t// It should match failResMsg above.\n\trequire.Equal(t, failResMsg.SourceChan, resMsgs[0].SourceChan)\n\trequire.Equal(t, failResMsg.HtlcIndex, resMsgs[0].HtlcIndex)\n\trequire.NotNil(t, resMsgs[0].Failure)\n\trequire.Nil(t, resMsgs[0].PreImage)\n\n\t// We'll add the settleResMsg now.\n\terr = resStore.addResolutionMsg(settleResMsg)\n\trequire.NoError(t, err)\n\n\t// Check that checkResolutionMsg returns nil for the settle CircuitKey.\n\toutKey.ChanID = settleResMsg.SourceChan\n\toutKey.HtlcID = settleResMsg.HtlcIndex\n\terr = resStore.checkResolutionMsg(outKey)\n\trequire.NoError(t, err)\n\n\t// We should have two resolution messages in the store, one failure and\n\t// one success.\n\tresMsgs, err = resStore.fetchAllResolutionMsg()\n\trequire.NoError(t, err)\n\trequire.Equal(t, 2, len(resMsgs))\n\n\t// The first resolution message should be the failure.\n\trequire.Equal(t, failResMsg.SourceChan, resMsgs[0].SourceChan)\n\trequire.Equal(t, failResMsg.HtlcIndex, resMsgs[0].HtlcIndex)\n\trequire.NotNil(t, resMsgs[0].Failure)\n\trequire.Nil(t, resMsgs[0].PreImage)\n\n\t// The second resolution message should be the success.\n\trequire.Equal(t, settleResMsg.SourceChan, resMsgs[1].SourceChan)\n\trequire.Equal(t, settleResMsg.HtlcIndex, resMsgs[1].HtlcIndex)\n\trequire.Nil(t, resMsgs[1].Failure)\n\trequire.Equal(t, settleBytes, *resMsgs[1].PreImage)\n\n\t// We'll now delete the failure resolution message and assert that only\n\t// the success is left.\n\tfailKey := &CircuitKey{\n\t\tChanID: scid,\n\t\tHtlcID: failResMsg.HtlcIndex,\n\t}\n\n\terr = resStore.deleteResolutionMsg(failKey)\n\trequire.NoError(t, err)\n\n\t// Assert that checkResolutionMsg returns errResMsgNotFound.\n\terr = resStore.checkResolutionMsg(failKey)\n\trequire.ErrorIs(t, err, errResMsgNotFound)\n\n\tresMsgs, err = resStore.fetchAllResolutionMsg()\n\trequire.NoError(t, err)\n\trequire.Equal(t, 1, len(resMsgs))\n\n\t// Assert that the success is left.\n\trequire.Equal(t, settleResMsg.SourceChan, resMsgs[0].SourceChan)\n\trequire.Equal(t, settleResMsg.HtlcIndex, resMsgs[0].HtlcIndex)\n\trequire.Nil(t, resMsgs[0].Failure)\n\trequire.Equal(t, settleBytes, *resMsgs[0].PreImage)\n\n\t// Now we'll delete the settle resolution message and assert that the\n\t// store is empty.\n\tsettleKey := &CircuitKey{\n\t\tChanID: scid,\n\t\tHtlcID: settleResMsg.HtlcIndex,\n\t}\n\n\terr = resStore.deleteResolutionMsg(settleKey)\n\trequire.NoError(t, err)\n\n\t// Assert that checkResolutionMsg returns errResMsgNotFound for the\n\t// settle key.\n\terr = resStore.checkResolutionMsg(settleKey)\n\trequire.ErrorIs(t, err, errResMsgNotFound)\n\n\tresMsgs, err = resStore.fetchAllResolutionMsg()\n\trequire.NoError(t, err)\n\trequire.Equal(t, 0, len(resMsgs))\n}\n",
      "length": 3883,
      "tokens": 392,
      "embedding": []
    }
  ]
}