{
  "filepath": "../implementations/go/lnd/htlcswitch/mailbox_test.go",
  "package": "htlcswitch",
  "sections": [
    {
      "slug": "func TestMailBoxCouriers(t *testing.T) {",
      "content": "func TestMailBoxCouriers(t *testing.T) {\n\tt.Parallel()\n\n\t// First, we'll create new instance of the current default mailbox\n\t// type.\n\tctx := newMailboxContext(t, time.Now(), testExpiry)\n\n\t// We'll be adding 10 message of both types to the mailbox.\n\tconst numPackets = 10\n\tconst halfPackets = numPackets / 2\n\n\t// We'll add a set of random packets to the mailbox.\n\tsentPackets := make([]*htlcPacket, numPackets)\n\tfor i := 0; i < numPackets; i++ {\n\t\tpkt := &htlcPacket{\n\t\t\toutgoingChanID: lnwire.NewShortChanIDFromInt(uint64(prand.Int63())),\n\t\t\tincomingChanID: lnwire.NewShortChanIDFromInt(uint64(prand.Int63())),\n\t\t\tamount:         lnwire.MilliSatoshi(prand.Int63()),\n\t\t\thtlc: &lnwire.UpdateAddHTLC{\n\t\t\t\tID: uint64(i),\n\t\t\t},\n\t\t}\n\t\tsentPackets[i] = pkt\n\n\t\terr := ctx.mailbox.AddPacket(pkt)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to add packet: %v\", err)\n\t\t}\n\t}\n\n\t// Next, we'll do the same, but this time adding wire messages.\n\tsentMessages := make([]lnwire.Message, numPackets)\n\tfor i := 0; i < numPackets; i++ {\n\t\tmsg := &lnwire.UpdateAddHTLC{\n\t\t\tID:     uint64(prand.Int63()),\n\t\t\tAmount: lnwire.MilliSatoshi(prand.Int63()),\n\t\t}\n\t\tsentMessages[i] = msg\n\n\t\terr := ctx.mailbox.AddMessage(msg)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to add message: %v\", err)\n\t\t}\n\t}\n\n\t// Now we'll attempt to read back the packets/messages we added to the\n\t// mailbox. We'll alternative reading from the message outbox vs the\n\t// packet outbox to ensure that they work concurrently properly.\n\trecvdPackets := make([]*htlcPacket, 0, numPackets)\n\trecvdMessages := make([]lnwire.Message, 0, numPackets)\n\tfor i := 0; i < numPackets*2; i++ {\n\t\ttimeout := time.After(time.Second * 5)\n\t\tif i%2 == 0 {\n\t\t\tselect {\n\t\t\tcase <-timeout:\n\t\t\t\tt.Fatalf(\"didn't recv pkt after timeout\")\n\t\t\tcase pkt := <-ctx.mailbox.PacketOutBox():\n\t\t\t\trecvdPackets = append(recvdPackets, pkt)\n\t\t\t}\n\t\t} else {\n\t\t\tselect {\n\t\t\tcase <-timeout:\n\t\t\t\tt.Fatalf(\"didn't recv message after timeout\")\n\t\t\tcase msg := <-ctx.mailbox.MessageOutBox():\n\t\t\t\trecvdMessages = append(recvdMessages, msg)\n\t\t\t}\n\t\t}\n\t}\n\n\t// The number of messages/packets we sent, and the number we received\n\t// should match exactly.\n\tif len(sentPackets) != len(recvdPackets) {\n\t\tt.Fatalf(\"expected %v packets instead got %v\", len(sentPackets),\n\t\t\tlen(recvdPackets))\n\t}\n\tif len(sentMessages) != len(recvdMessages) {\n\t\tt.Fatalf(\"expected %v messages instead got %v\", len(sentMessages),\n\t\t\tlen(recvdMessages))\n\t}\n\n\t// Additionally, the set of packets should match exactly, as we should\n\t// have received the packets in the exact same ordering that we added.\n\tif !reflect.DeepEqual(sentPackets, recvdPackets) {\n\t\tt.Fatalf(\"recvd packets mismatched: expected %v, got %v\",\n\t\t\tspew.Sdump(sentPackets), spew.Sdump(recvdPackets))\n\t}\n\tif !reflect.DeepEqual(recvdMessages, recvdMessages) {\n\t\tt.Fatalf(\"recvd messages mismatched: expected %v, got %v\",\n\t\t\tspew.Sdump(sentMessages), spew.Sdump(recvdMessages))\n\t}\n\n\t// Now that we've received all of the intended msgs/pkts, ack back half\n\t// of the packets.\n\tfor _, recvdPkt := range recvdPackets[:halfPackets] {\n\t\tctx.mailbox.AckPacket(recvdPkt.inKey())\n\t}\n\n\t// With the packets drained and partially acked,  we reset the mailbox,\n\t// simulating a link shutting down and then coming back up.\n\terr := ctx.mailbox.ResetMessages()\n\trequire.NoError(t, err, \"unable to reset messages\")\n\terr = ctx.mailbox.ResetPackets()\n\trequire.NoError(t, err, \"unable to reset packets\")\n\n\t// Now, we'll use the same alternating strategy to read from our\n\t// mailbox. All wire messages are dropped on startup, but any unacked\n\t// packets will be replayed in the same order they were delivered\n\t// initially.\n\trecvdPackets2 := make([]*htlcPacket, 0, halfPackets)\n\tfor i := 0; i < 2*halfPackets; i++ {\n\t\ttimeout := time.After(time.Second * 5)\n\t\tif i%2 == 0 {\n\t\t\tselect {\n\t\t\tcase <-timeout:\n\t\t\t\tt.Fatalf(\"didn't recv pkt after timeout\")\n\t\t\tcase pkt := <-ctx.mailbox.PacketOutBox():\n\t\t\t\trecvdPackets2 = append(recvdPackets2, pkt)\n\t\t\t}\n\t\t} else {\n\t\t\tselect {\n\t\t\tcase <-ctx.mailbox.MessageOutBox():\n\t\t\t\tt.Fatalf(\"should not receive wire msg after reset\")\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t}\n\n\t// The number of packets we received should match the number of unacked\n\t// packets left in the mailbox.\n\tif halfPackets != len(recvdPackets2) {\n\t\tt.Fatalf(\"expected %v packets instead got %v\", halfPackets,\n\t\t\tlen(recvdPackets))\n\t}\n\n\t// Additionally, the set of packets should match exactly with the\n\t// unacked packets, and we should have received the packets in the exact\n\t// same ordering that we added.\n\tif !reflect.DeepEqual(recvdPackets[halfPackets:], recvdPackets2) {\n\t\tt.Fatalf(\"recvd packets mismatched: expected %v, got %v\",\n\t\t\tspew.Sdump(sentPackets), spew.Sdump(recvdPackets))\n\t}\n}\n\n// TestMailBoxResetAfterShutdown tests that ResetMessages and ResetPackets\n// return ErrMailBoxShuttingDown after the mailbox has been stopped.",
      "length": 4650,
      "tokens": 611,
      "embedding": []
    },
    {
      "slug": "func TestMailBoxResetAfterShutdown(t *testing.T) {",
      "content": "func TestMailBoxResetAfterShutdown(t *testing.T) {\n\tt.Parallel()\n\n\tctx := newMailboxContext(t, time.Now(), time.Second)\n\n\t// Stop the mailbox, then try to reset the message and packet couriers.\n\tctx.mailbox.Stop()\n\n\terr := ctx.mailbox.ResetMessages()\n\tif err != ErrMailBoxShuttingDown {\n\t\tt.Fatalf(\"expected ErrMailBoxShuttingDown, got: %v\", err)\n\t}\n\n\terr = ctx.mailbox.ResetPackets()\n\tif err != ErrMailBoxShuttingDown {\n\t\tt.Fatalf(\"expected ErrMailBoxShuttingDown, got: %v\", err)\n\t}\n}\n",
      "length": 418,
      "tokens": 49,
      "embedding": []
    },
    {
      "slug": "type mailboxContext struct {",
      "content": "type mailboxContext struct {\n\tt        *testing.T\n\tmailbox  MailBox\n\tclock    *clock.TestClock\n\tforwards chan *htlcPacket\n}\n\n// newMailboxContextWithClock creates a new mailbox context with the given\n// mocked clock.\n//\n// TODO(yy): replace all usage of `newMailboxContext` with this method.",
      "length": 253,
      "tokens": 34,
      "embedding": []
    },
    {
      "slug": "func newMailboxContextWithClock(t *testing.T,",
      "content": "func newMailboxContextWithClock(t *testing.T,\n\tclock clock.Clock) *mailboxContext {\n\n\tctx := &mailboxContext{\n\t\tt:        t,\n\t\tforwards: make(chan *htlcPacket, 1),\n\t}\n\n\tfailMailboxUpdate := func(outScid,\n\t\tmboxScid lnwire.ShortChannelID) lnwire.FailureMessage {\n\n\t\treturn &lnwire.FailTemporaryNodeFailure{}\n\t}\n\n\tctx.mailbox = newMemoryMailBox(&mailBoxConfig{\n\t\tfailMailboxUpdate: failMailboxUpdate,\n\t\tforwardPackets:    ctx.forward,\n\t\tclock:             clock,\n\t})\n\tctx.mailbox.Start()\n\tt.Cleanup(ctx.mailbox.Stop)\n\n\treturn ctx\n}\n",
      "length": 461,
      "tokens": 39,
      "embedding": []
    },
    {
      "slug": "func newMailboxContext(t *testing.T, startTime time.Time,",
      "content": "func newMailboxContext(t *testing.T, startTime time.Time,\n\texpiry time.Duration) *mailboxContext {\n\n\tctx := &mailboxContext{\n\t\tt:        t,\n\t\tclock:    clock.NewTestClock(startTime),\n\t\tforwards: make(chan *htlcPacket, 1),\n\t}\n\n\tfailMailboxUpdate := func(outScid,\n\t\tmboxScid lnwire.ShortChannelID) lnwire.FailureMessage {\n\n\t\treturn &lnwire.FailTemporaryNodeFailure{}\n\t}\n\n\tctx.mailbox = newMemoryMailBox(&mailBoxConfig{\n\t\tfailMailboxUpdate: failMailboxUpdate,\n\t\tforwardPackets:    ctx.forward,\n\t\tclock:             ctx.clock,\n\t\texpiry:            expiry,\n\t})\n\tctx.mailbox.Start()\n\tt.Cleanup(ctx.mailbox.Stop)\n\n\treturn ctx\n}\n",
      "length": 538,
      "tokens": 43,
      "embedding": []
    },
    {
      "slug": "func (c *mailboxContext) forward(_ chan struct{},",
      "content": "func (c *mailboxContext) forward(_ chan struct{},\n\tpkts ...*htlcPacket) error {\n\n\tfor _, pkt := range pkts {\n\t\tc.forwards <- pkt\n\t}\n\n\treturn nil\n}\n",
      "length": 89,
      "tokens": 18,
      "embedding": []
    },
    {
      "slug": "func (c *mailboxContext) sendAdds(start, num int) []*htlcPacket {",
      "content": "func (c *mailboxContext) sendAdds(start, num int) []*htlcPacket {\n\tc.t.Helper()\n\n\tsentPackets := make([]*htlcPacket, num)\n\tfor i := 0; i < num; i++ {\n\t\tpkt := &htlcPacket{\n\t\t\toutgoingChanID: lnwire.NewShortChanIDFromInt(\n\t\t\t\tuint64(prand.Int63())),\n\t\t\tincomingChanID: lnwire.NewShortChanIDFromInt(\n\t\t\t\tuint64(prand.Int63())),\n\t\t\tincomingHTLCID: uint64(start + i),\n\t\t\tamount:         lnwire.MilliSatoshi(prand.Int63()),\n\t\t\thtlc: &lnwire.UpdateAddHTLC{\n\t\t\t\tID: uint64(start + i),\n\t\t\t},\n\t\t}\n\t\tsentPackets[i] = pkt\n\n\t\terr := c.mailbox.AddPacket(pkt)\n\t\tif err != nil {\n\t\t\tc.t.Fatalf(\"unable to add packet: %v\", err)\n\t\t}\n\t}\n\n\treturn sentPackets\n}\n",
      "length": 550,
      "tokens": 59,
      "embedding": []
    },
    {
      "slug": "func (c *mailboxContext) receivePkts(pkts []*htlcPacket) {",
      "content": "func (c *mailboxContext) receivePkts(pkts []*htlcPacket) {\n\tc.t.Helper()\n\n\tfor i, expPkt := range pkts {\n\t\tselect {\n\t\tcase pkt := <-c.mailbox.PacketOutBox():\n\t\t\tif reflect.DeepEqual(expPkt, pkt) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tc.t.Fatalf(\"inkey mismatch #%d, want: %v vs \"+\n\t\t\t\t\"got: %v\", i, expPkt.inKey(), pkt.inKey())\n\n\t\tcase <-time.After(50 * time.Millisecond):\n\t\t\tc.t.Fatalf(\"did not receive fail for index %d\", i)\n\t\t}\n\t}\n}\n",
      "length": 345,
      "tokens": 47,
      "embedding": []
    },
    {
      "slug": "func (c *mailboxContext) checkFails(adds []*htlcPacket) {",
      "content": "func (c *mailboxContext) checkFails(adds []*htlcPacket) {\n\tc.t.Helper()\n\n\tfor i, add := range adds {\n\t\tselect {\n\t\tcase fail := <-c.forwards:\n\t\t\tif add.inKey() == fail.inKey() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tc.t.Fatalf(\"inkey mismatch #%d, add: %v vs fail: %v\",\n\t\t\t\ti, add.inKey(), fail.inKey())\n\n\t\tcase <-time.After(50 * time.Millisecond):\n\t\t\tc.t.Fatalf(\"did not receive fail for index %d\", i)\n\t\t}\n\t}\n\n\tselect {\n\tcase pkt := <-c.forwards:\n\t\tc.t.Fatalf(\"unexpected forward: %v\", pkt.keystone())\n\tcase <-time.After(50 * time.Millisecond):\n\t}\n}\n\n// TestMailBoxFailAdd asserts that FailAdd returns a response to the switch\n// under various interleavings with other operations on the mailbox.",
      "length": 596,
      "tokens": 83,
      "embedding": []
    },
    {
      "slug": "func TestMailBoxFailAdd(t *testing.T) {",
      "content": "func TestMailBoxFailAdd(t *testing.T) {\n\tvar (\n\t\tbatchDelay       = time.Second\n\t\texpiry           = time.Minute\n\t\tfirstBatchStart  = time.Now()\n\t\tsecondBatchStart = time.Now().Add(batchDelay)\n\t\tthirdBatchStart  = time.Now().Add(2 * batchDelay)\n\t\tthirdBatchExpiry = thirdBatchStart.Add(expiry)\n\t)\n\tctx := newMailboxContext(t, firstBatchStart, expiry)\n\n\tfailAdds := func(adds []*htlcPacket) {\n\t\tfor _, add := range adds {\n\t\t\tctx.mailbox.FailAdd(add)\n\t\t}\n\t}\n\n\tconst numBatchPackets = 5\n\n\t// Send  10 adds, and pull them from the mailbox.\n\tfirstBatch := ctx.sendAdds(0, numBatchPackets)\n\tctx.receivePkts(firstBatch)\n\n\t// Fail all of these adds, simulating an error adding the HTLCs to the\n\t// commitment. We should see a failure message for each.\n\tgo failAdds(firstBatch)\n\tctx.checkFails(firstBatch)\n\n\t// As a sanity check, Fail all of them again and assert that no\n\t// duplicate fails are sent.\n\tgo failAdds(firstBatch)\n\tctx.checkFails(nil)\n\n\t// Now, send a second batch of adds after a short delay and deliver them\n\t// to the link.\n\tctx.clock.SetTime(secondBatchStart)\n\tsecondBatch := ctx.sendAdds(numBatchPackets, numBatchPackets)\n\tctx.receivePkts(secondBatch)\n\n\t// Reset the packet queue w/o changing the current time. This simulates\n\t// the link flapping and coming back up before the second batch's\n\t// expiries have elapsed. We should see no failures sent back.\n\terr := ctx.mailbox.ResetPackets()\n\trequire.NoError(t, err, \"unable to reset packets\")\n\tctx.checkFails(nil)\n\n\t// Redeliver the second batch to the link and hold them there.\n\tctx.receivePkts(secondBatch)\n\n\t// Send a third batch of adds shortly after the second batch.\n\tctx.clock.SetTime(thirdBatchStart)\n\tthirdBatch := ctx.sendAdds(2*numBatchPackets, numBatchPackets)\n\n\t// Advance the clock so that the third batch expires. We expect to only\n\t// see fails for the third batch, since the second batch is still being\n\t// held by the link.\n\tctx.clock.SetTime(thirdBatchExpiry)\n\tctx.checkFails(thirdBatch)\n\n\t// Finally, reset the link which should cause the second batch to be\n\t// cancelled immediately.\n\terr = ctx.mailbox.ResetPackets()\n\trequire.NoError(t, err, \"unable to reset packets\")\n\tctx.checkFails(secondBatch)\n}\n\n// TestMailBoxPacketPrioritization asserts that the mailbox will prioritize\n// delivering Settle and Fail packets over Adds if both are available for\n// delivery at the same time.",
      "length": 2255,
      "tokens": 300,
      "embedding": []
    },
    {
      "slug": "func TestMailBoxPacketPrioritization(t *testing.T) {",
      "content": "func TestMailBoxPacketPrioritization(t *testing.T) {\n\tt.Parallel()\n\n\t// First, we'll create new instance of the current default mailbox\n\t// type.\n\tctx := newMailboxContext(t, time.Now(), testExpiry)\n\n\tconst numPackets = 5\n\n\t_, _, aliceChanID, bobChanID := genIDs()\n\n\t// Next we'll send the following sequence of packets:\n\t//  - Settle1\n\t//  - Add1\n\t//  - Add2\n\t//  - Fail\n\t//  - Settle2\n\tsentPackets := make([]*htlcPacket, numPackets)\n\tfor i := 0; i < numPackets; i++ {\n\t\tpkt := &htlcPacket{\n\t\t\toutgoingChanID: aliceChanID,\n\t\t\toutgoingHTLCID: uint64(i),\n\t\t\tincomingChanID: bobChanID,\n\t\t\tincomingHTLCID: uint64(i),\n\t\t\tamount:         lnwire.MilliSatoshi(prand.Int63()),\n\t\t}\n\n\t\tswitch i {\n\t\tcase 0, 4:\n\t\t\t// First and last packets are a Settle. A non-Add is\n\t\t\t// sent first to make the test deterministic w/o needing\n\t\t\t// to sleep.\n\t\t\tpkt.htlc = &lnwire.UpdateFulfillHTLC{ID: uint64(i)}\n\t\tcase 1, 2:\n\t\t\t// Next two packets are Adds.\n\t\t\tpkt.htlc = &lnwire.UpdateAddHTLC{ID: uint64(i)}\n\t\tcase 3:\n\t\t\t// Last packet is a Fail.\n\t\t\tpkt.htlc = &lnwire.UpdateFailHTLC{ID: uint64(i)}\n\t\t}\n\n\t\tsentPackets[i] = pkt\n\n\t\terr := ctx.mailbox.AddPacket(pkt)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to add packet: %v\", err)\n\t\t}\n\t}\n\n\t// When dequeueing the packets, we expect the following sequence:\n\t//  - Settle1\n\t//  - Fail\n\t//  - Settle2\n\t//  - Add1\n\t//  - Add2\n\t//\n\t// We expect to see Fail and Settle2 to be delivered before either Add1\n\t// or Add2 due to the prioritization between the split queue.\n\tfor i := 0; i < numPackets; i++ {\n\t\tselect {\n\t\tcase pkt := <-ctx.mailbox.PacketOutBox():\n\t\t\tvar expPkt *htlcPacket\n\t\t\tswitch i {\n\t\t\tcase 0:\n\t\t\t\t// First packet should be Settle1.\n\t\t\t\texpPkt = sentPackets[0]\n\t\t\tcase 1:\n\t\t\t\t// Second packet should be Fail.\n\t\t\t\texpPkt = sentPackets[3]\n\t\t\tcase 2:\n\t\t\t\t// Third packet should be Settle2.\n\t\t\t\texpPkt = sentPackets[4]\n\t\t\tcase 3:\n\t\t\t\t// Fourth packet should be Add1.\n\t\t\t\texpPkt = sentPackets[1]\n\t\t\tcase 4:\n\t\t\t\t// Last packet should be Add2.\n\t\t\t\texpPkt = sentPackets[2]\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(expPkt, pkt) {\n\t\t\t\tt.Fatalf(\"recvd packet mismatch %d, want: %v, got: %v\",\n\t\t\t\t\ti, spew.Sdump(expPkt), spew.Sdump(pkt))\n\t\t\t}\n\n\t\tcase <-time.After(50 * time.Millisecond):\n\t\t\tt.Fatalf(\"didn't receive packet %d before timeout\", i)\n\t\t}\n\t}\n}\n\n// TestMailBoxAddExpiry asserts that the mailbox will cancel back Adds that\n// have reached their expiry time.",
      "length": 2231,
      "tokens": 334,
      "embedding": []
    },
    {
      "slug": "func TestMailBoxAddExpiry(t *testing.T) {",
      "content": "func TestMailBoxAddExpiry(t *testing.T) {\n\t// Each batch will consist of 10 messages.\n\tconst numBatchPackets = 10\n\n\t// deadline is the returned value from the `pktWithExpiry.deadline`.\n\tdeadline := make(chan time.Time, numBatchPackets*2)\n\n\t// Create a mock clock and mock the methods.\n\tmockClock := &lnmock.MockClock{}\n\tmockClock.On(\"Now\").Return(time.Now())\n\n\t// Mock TickAfter, which mounts the above `deadline` channel to the\n\t// returned value from `pktWithExpiry.deadline`.\n\tmockClock.On(\"TickAfter\", mock.Anything).Return(deadline)\n\n\t// Create a test mailbox context.\n\tctx := newMailboxContextWithClock(t, mockClock)\n\n\t// Send 10 packets and assert no failures are sent back.\n\tfirstBatch := ctx.sendAdds(0, numBatchPackets)\n\tctx.checkFails(nil)\n\n\t// Send another 10 packets and assert no failures are sent back.\n\tsecondBatch := ctx.sendAdds(numBatchPackets, numBatchPackets)\n\tctx.checkFails(nil)\n\n\t// Tick 10 times and we should see the first batch expired.\n\tfor i := 0; i < numBatchPackets; i++ {\n\t\tdeadline <- time.Now()\n\t}\n\tctx.checkFails(firstBatch)\n\n\t// Tick another 10 times and we should see the second batch expired.\n\tfor i := 0; i < numBatchPackets; i++ {\n\t\tdeadline <- time.Now()\n\t}\n\tctx.checkFails(secondBatch)\n}\n\n// TestMailBoxDuplicateAddPacket asserts that the mailbox returns an\n// ErrPacketAlreadyExists failure when two htlcPackets are added with identical\n// incoming circuit keys.",
      "length": 1323,
      "tokens": 176,
      "embedding": []
    },
    {
      "slug": "func TestMailBoxDuplicateAddPacket(t *testing.T) {",
      "content": "func TestMailBoxDuplicateAddPacket(t *testing.T) {\n\tt.Parallel()\n\n\tctx := newMailboxContext(t, time.Now(), testExpiry)\n\tctx.mailbox.Start()\n\n\taddTwice := func(t *testing.T, pkt *htlcPacket) {\n\t\t// The first add should succeed.\n\t\terr := ctx.mailbox.AddPacket(pkt)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to add packet: %v\", err)\n\t\t}\n\n\t\t// Adding again with the same incoming circuit key should fail.\n\t\terr = ctx.mailbox.AddPacket(pkt)\n\t\tif err != ErrPacketAlreadyExists {\n\t\t\tt.Fatalf(\"expected ErrPacketAlreadyExists, got: %v\", err)\n\t\t}\n\t}\n\n\t// Assert duplicate AddPacket calls fail for all types of HTLCs.\n\taddTwice(t, &htlcPacket{\n\t\tincomingHTLCID: 0,\n\t\thtlc:           &lnwire.UpdateAddHTLC{},\n\t})\n\taddTwice(t, &htlcPacket{\n\t\tincomingHTLCID: 1,\n\t\thtlc:           &lnwire.UpdateFulfillHTLC{},\n\t})\n\taddTwice(t, &htlcPacket{\n\t\tincomingHTLCID: 2,\n\t\thtlc:           &lnwire.UpdateFailHTLC{},\n\t})\n}\n\n// TestMailBoxDustHandling tests that DustPackets returns the expected values\n// for the local and remote dust sum after calling SetFeeRate and\n// SetDustClosure.",
      "length": 969,
      "tokens": 117,
      "embedding": []
    },
    {
      "slug": "func TestMailBoxDustHandling(t *testing.T) {",
      "content": "func TestMailBoxDustHandling(t *testing.T) {\n\tt.Run(\"tweakless mailbox dust\", func(t *testing.T) {\n\t\ttestMailBoxDust(t, channeldb.SingleFunderTweaklessBit)\n\t})\n\tt.Run(\"zero htlc fee anchors mailbox dust\", func(t *testing.T) {\n\t\ttestMailBoxDust(t, channeldb.SingleFunderTweaklessBit|\n\t\t\tchanneldb.AnchorOutputsBit|\n\t\t\tchanneldb.ZeroHtlcTxFeeBit,\n\t\t)\n\t})\n}\n",
      "length": 300,
      "tokens": 25,
      "embedding": []
    },
    {
      "slug": "func testMailBoxDust(t *testing.T, chantype channeldb.ChannelType) {",
      "content": "func testMailBoxDust(t *testing.T, chantype channeldb.ChannelType) {\n\tt.Parallel()\n\n\tctx := newMailboxContext(t, time.Now(), testExpiry)\n\n\t_, _, aliceID, bobID := genIDs()\n\n\t// It should not be the case that the MailBox has packets before the\n\t// feeRate or dustClosure is set. This is because the mailbox is always\n\t// created *with* its associated link and attached via AttachMailbox,\n\t// where these parameters will be set. Even though the lifetime is\n\t// longer than the link, the setting will persist across multiple link\n\t// creations.\n\tctx.mailbox.SetFeeRate(chainfee.SatPerKWeight(253))\n\n\tlocalDustLimit := btcutil.Amount(400)\n\tremoteDustLimit := btcutil.Amount(500)\n\tisDust := dustHelper(chantype, localDustLimit, remoteDustLimit)\n\tctx.mailbox.SetDustClosure(isDust)\n\n\t// The first packet will be dust according to the remote dust limit,\n\t// but not the local. We set a different amount if this is a zero fee\n\t// htlc channel type.\n\tfirstAmt := lnwire.MilliSatoshi(600_000)\n\n\tif chantype.ZeroHtlcTxFee() {\n\t\tfirstAmt = lnwire.MilliSatoshi(450_000)\n\t}\n\n\tfirstPkt := &htlcPacket{\n\t\toutgoingChanID: aliceID,\n\t\toutgoingHTLCID: 0,\n\t\tincomingChanID: bobID,\n\t\tincomingHTLCID: 0,\n\t\tamount:         firstAmt,\n\t\thtlc: &lnwire.UpdateAddHTLC{\n\t\t\tID: uint64(0),\n\t\t},\n\t}\n\n\terr := ctx.mailbox.AddPacket(firstPkt)\n\trequire.NoError(t, err)\n\n\t// Assert that the local sum is 0, and the remote sum accounts for this\n\t// added packet.\n\tlocalSum, remoteSum := ctx.mailbox.DustPackets()\n\trequire.Equal(t, lnwire.MilliSatoshi(0), localSum)\n\trequire.Equal(t, firstAmt, remoteSum)\n\n\t// The next packet will be dust according to both limits.\n\tsecondAmt := lnwire.MilliSatoshi(300_000)\n\tsecondPkt := &htlcPacket{\n\t\toutgoingChanID: aliceID,\n\t\toutgoingHTLCID: 1,\n\t\tincomingChanID: bobID,\n\t\tincomingHTLCID: 1,\n\t\tamount:         secondAmt,\n\t\thtlc: &lnwire.UpdateAddHTLC{\n\t\t\tID: uint64(1),\n\t\t},\n\t}\n\n\terr = ctx.mailbox.AddPacket(secondPkt)\n\trequire.NoError(t, err)\n\n\t// Assert that both the local and remote sums have increased by the\n\t// second amount.\n\tlocalSum, remoteSum = ctx.mailbox.DustPackets()\n\trequire.Equal(t, secondAmt, localSum)\n\trequire.Equal(t, firstAmt+secondAmt, remoteSum)\n\n\t// Now we pull both packets off of the queue.\n\tfor i := 0; i < 2; i++ {\n\t\tselect {\n\t\tcase <-ctx.mailbox.PacketOutBox():\n\t\tcase <-time.After(50 * time.Millisecond):\n\t\t\tctx.t.Fatalf(\"did not receive packet in time\")\n\t\t}\n\t}\n\n\t// Assert that the sums haven't changed.\n\tlocalSum, remoteSum = ctx.mailbox.DustPackets()\n\trequire.Equal(t, secondAmt, localSum)\n\trequire.Equal(t, firstAmt+secondAmt, remoteSum)\n\n\t// Remove the first packet from the mailbox.\n\tremoved := ctx.mailbox.AckPacket(firstPkt.inKey())\n\trequire.True(t, removed)\n\n\t// Assert that the remote sum does not include the firstAmt.\n\tlocalSum, remoteSum = ctx.mailbox.DustPackets()\n\trequire.Equal(t, secondAmt, localSum)\n\trequire.Equal(t, secondAmt, remoteSum)\n\n\t// Remove the second packet from the mailbox.\n\tremoved = ctx.mailbox.AckPacket(secondPkt.inKey())\n\trequire.True(t, removed)\n\n\t// Assert that both sums are equal to 0.\n\tlocalSum, remoteSum = ctx.mailbox.DustPackets()\n\trequire.Equal(t, lnwire.MilliSatoshi(0), localSum)\n\trequire.Equal(t, lnwire.MilliSatoshi(0), remoteSum)\n}\n\n// TestMailOrchestrator asserts that the orchestrator properly buffers packets\n// for channels that haven't been made live, such that they are delivered\n// immediately after BindLiveShortChanID. It also tests that packets are delivered\n// readily to mailboxes for channels that are already in the live state.",
      "length": 3345,
      "tokens": 412,
      "embedding": []
    },
    {
      "slug": "func TestMailOrchestrator(t *testing.T) {",
      "content": "func TestMailOrchestrator(t *testing.T) {\n\tt.Parallel()\n\n\tfailMailboxUpdate := func(outScid,\n\t\tmboxScid lnwire.ShortChannelID) lnwire.FailureMessage {\n\n\t\treturn &lnwire.FailTemporaryNodeFailure{}\n\t}\n\n\t// First, we'll create a new instance of our orchestrator.\n\tmo := newMailOrchestrator(&mailOrchConfig{\n\t\tfailMailboxUpdate: failMailboxUpdate,\n\t\tforwardPackets: func(_ chan struct{},\n\t\t\tpkts ...*htlcPacket) error {\n\n\t\t\treturn nil\n\t\t},\n\t\tclock:  clock.NewTestClock(time.Now()),\n\t\texpiry: testExpiry,\n\t})\n\tdefer mo.Stop()\n\n\t// We'll be delivering 10 htlc packets via the orchestrator.\n\tconst numPackets = 10\n\tconst halfPackets = numPackets / 2\n\n\t// Before any mailbox is created or made live, we will deliver half of\n\t// the htlcs via the orchestrator.\n\tchanID1, chanID2, aliceChanID, bobChanID := genIDs()\n\tsentPackets := make([]*htlcPacket, halfPackets)\n\tfor i := 0; i < halfPackets; i++ {\n\t\tpkt := &htlcPacket{\n\t\t\toutgoingChanID: aliceChanID,\n\t\t\toutgoingHTLCID: uint64(i),\n\t\t\tincomingChanID: bobChanID,\n\t\t\tincomingHTLCID: uint64(i),\n\t\t\tamount:         lnwire.MilliSatoshi(prand.Int63()),\n\t\t\thtlc: &lnwire.UpdateAddHTLC{\n\t\t\t\tID: uint64(i),\n\t\t\t},\n\t\t}\n\t\tsentPackets[i] = pkt\n\n\t\tmo.Deliver(pkt.outgoingChanID, pkt)\n\t}\n\n\t// Now, initialize a new mailbox for Alice's chanid.\n\tmailbox := mo.GetOrCreateMailBox(chanID1, aliceChanID)\n\n\t// Verify that no messages are received, since Alice's mailbox has not\n\t// been made live.\n\tfor i := 0; i < halfPackets; i++ {\n\t\ttimeout := time.After(50 * time.Millisecond)\n\t\tselect {\n\t\tcase <-mailbox.MessageOutBox():\n\t\t\tt.Fatalf(\"should not receive wire msg after reset\")\n\t\tcase <-timeout:\n\t\t}\n\t}\n\n\t// Assign a short chan id to the existing mailbox, make it available for\n\t// capturing incoming HTLCs. The HTLCs added above should be delivered\n\t// immediately.\n\tmo.BindLiveShortChanID(mailbox, chanID1, aliceChanID)\n\n\t// Verify that all of the packets are queued and delivered to Alice's\n\t// mailbox.\n\trecvdPackets := make([]*htlcPacket, 0, len(sentPackets))\n\tfor i := 0; i < halfPackets; i++ {\n\t\ttimeout := time.After(5 * time.Second)\n\t\tselect {\n\t\tcase <-timeout:\n\t\t\tt.Fatalf(\"didn't recv pkt %d after timeout\", i)\n\t\tcase pkt := <-mailbox.PacketOutBox():\n\t\t\trecvdPackets = append(recvdPackets, pkt)\n\t\t}\n\t}\n\n\t// We should have received half of the total number of packets.\n\tif len(recvdPackets) != halfPackets {\n\t\tt.Fatalf(\"expected %v packets instead got %v\",\n\t\t\thalfPackets, len(recvdPackets))\n\t}\n\n\t// Check that the received packets are equal to the sent packets.\n\tif !reflect.DeepEqual(recvdPackets, sentPackets) {\n\t\tt.Fatalf(\"recvd packets mismatched: expected %v, got %v\",\n\t\t\tspew.Sdump(sentPackets), spew.Sdump(recvdPackets))\n\t}\n\n\t// For the second half of the test, create a new mailbox for Bob and\n\t// immediately make it live with an assigned short chan id.\n\tmailbox = mo.GetOrCreateMailBox(chanID2, bobChanID)\n\tmo.BindLiveShortChanID(mailbox, chanID2, bobChanID)\n\n\t// Create the second half of our htlcs, and deliver them via the\n\t// orchestrator. We should be able to receive each of these in order.\n\trecvdPackets = make([]*htlcPacket, 0, len(sentPackets))\n\tfor i := 0; i < halfPackets; i++ {\n\t\tpkt := &htlcPacket{\n\t\t\toutgoingChanID: aliceChanID,\n\t\t\toutgoingHTLCID: uint64(halfPackets + i),\n\t\t\tincomingChanID: bobChanID,\n\t\t\tincomingHTLCID: uint64(halfPackets + i),\n\t\t\tamount:         lnwire.MilliSatoshi(prand.Int63()),\n\t\t\thtlc: &lnwire.UpdateAddHTLC{\n\t\t\t\tID: uint64(halfPackets + i),\n\t\t\t},\n\t\t}\n\t\tsentPackets[i] = pkt\n\n\t\tmo.Deliver(pkt.incomingChanID, pkt)\n\n\t\ttimeout := time.After(50 * time.Millisecond)\n\t\tselect {\n\t\tcase <-timeout:\n\t\t\tt.Fatalf(\"didn't recv pkt %d after timeout\", halfPackets+i)\n\t\tcase pkt := <-mailbox.PacketOutBox():\n\t\t\trecvdPackets = append(recvdPackets, pkt)\n\t\t}\n\t}\n\n\t// Again, we should have received half of the total number of packets.\n\tif len(recvdPackets) != halfPackets {\n\t\tt.Fatalf(\"expected %v packets instead got %v\",\n\t\t\thalfPackets, len(recvdPackets))\n\t}\n\n\t// Check that the received packets are equal to the sent packets.\n\tif !reflect.DeepEqual(recvdPackets, sentPackets) {\n\t\tt.Fatalf(\"recvd packets mismatched: expected %v, got %v\",\n\t\t\tspew.Sdump(sentPackets), spew.Sdump(recvdPackets))\n\t}\n}\n",
      "length": 3994,
      "tokens": 506,
      "embedding": []
    }
  ]
}