{
  "filepath": "../implementations/go/lnd/htlcswitch/circuit_map.go",
  "package": "htlcswitch",
  "sections": [
    {
      "slug": "type CircuitModifier interface {",
      "content": "type CircuitModifier interface {\n\t// OpenCircuits preemptively records a batch keystones that will mark\n\t// currently pending circuits as open. These changes can be rolled back\n\t// on restart if the outgoing Adds do not make it into a commitment\n\t// txn.\n\tOpenCircuits(...Keystone) error\n\n\t// TrimOpenCircuits removes a channel's open channels with htlc indexes\n\t// above `start`.\n\tTrimOpenCircuits(chanID lnwire.ShortChannelID, start uint64) error\n\n\t// DeleteCircuits removes the incoming circuit key to remove all\n\t// persistent references to a circuit. Returns a ErrUnknownCircuit if\n\t// any of the incoming keys are not known.\n\tDeleteCircuits(inKeys ...CircuitKey) error\n}\n\n// CircuitLookup is a common interface used to lookup information that is stored\n// in the circuit map.",
      "length": 731,
      "tokens": 109,
      "embedding": []
    },
    {
      "slug": "type CircuitLookup interface {",
      "content": "type CircuitLookup interface {\n\t// LookupCircuit queries the circuit map for the circuit identified by\n\t// inKey.\n\tLookupCircuit(inKey CircuitKey) *PaymentCircuit\n\n\t// LookupOpenCircuit queries the circuit map for a circuit identified\n\t// by its outgoing circuit key.\n\tLookupOpenCircuit(outKey CircuitKey) *PaymentCircuit\n}\n\n// CircuitFwdActions represents the forwarding decision made by the circuit\n// map, and is returned from CommitCircuits. The sequence of circuits provided\n// to CommitCircuits is split into three sub-sequences, allowing the caller to\n// do an in-order scan, comparing the head of each subsequence, to determine\n// the decision made by the circuit map.",
      "length": 632,
      "tokens": 91,
      "embedding": []
    },
    {
      "slug": "type CircuitFwdActions struct {",
      "content": "type CircuitFwdActions struct {\n\t// Adds is the subsequence of circuits that were successfully committed\n\t// in the circuit map.\n\tAdds []*PaymentCircuit\n\n\t// Drops is the subsequence of circuits for which no action should be\n\t// done.\n\tDrops []*PaymentCircuit\n\n\t// Fails is the subsequence of circuits that should be failed back by\n\t// the calling link.\n\tFails []*PaymentCircuit\n}\n\n// CircuitMap is an interface for managing the construction and teardown of\n// payment circuits used by the switch.",
      "length": 451,
      "tokens": 74,
      "embedding": []
    },
    {
      "slug": "type CircuitMap interface {",
      "content": "type CircuitMap interface {\n\tCircuitModifier\n\n\tCircuitLookup\n\n\t// CommitCircuits attempts to add the given circuits to the circuit\n\t// map. The list of circuits is split into three distinct\n\t// sub-sequences, corresponding to adds, drops, and fails. Adds should\n\t// be forwarded to the switch, while fails should be failed back\n\t// locally within the calling link.\n\tCommitCircuits(circuit ...*PaymentCircuit) (*CircuitFwdActions, error)\n\n\t// CloseCircuit marks the circuit identified by `outKey` as closing\n\t// in-memory, which prevents duplicate settles/fails from completing an\n\t// open circuit twice.\n\tCloseCircuit(outKey CircuitKey) (*PaymentCircuit, error)\n\n\t// FailCircuit is used by locally failed HTLCs to mark the circuit\n\t// identified by `inKey` as closing in-memory, which prevents duplicate\n\t// settles/fails from being accepted for the same circuit.\n\tFailCircuit(inKey CircuitKey) (*PaymentCircuit, error)\n\n\t// LookupByPaymentHash queries the circuit map and returns all open\n\t// circuits that use the given payment hash.\n\tLookupByPaymentHash(hash [32]byte) []*PaymentCircuit\n\n\t// NumPending returns the total number of active circuits added by\n\t// CommitCircuits.\n\tNumPending() int\n\n\t// NumOpen returns the number of circuits with HTLCs that have been\n\t// forwarded via an outgoing link.\n\tNumOpen() int\n}\n\nvar (\n\t// circuitAddKey is the key used to retrieve the bucket containing\n\t// payment circuits. A circuit records information about how to return\n\t// a packet to the source link, potentially including an error\n\t// encrypter for applying this hop's encryption to the payload in the\n\t// reverse direction.\n\t//\n\t// Bucket hierarchy:\n\t//\n\t// circuitAddKey(root-bucket)\n\t//     \t|\n\t//     \t|-- <incoming-circuit-key>: <encoded bytes of PaymentCircuit>\n\t//     \t|-- <incoming-circuit-key>: <encoded bytes of PaymentCircuit>\n\t//     \t|\n\t//     \t...\n\t//\n\tcircuitAddKey = []byte(\"circuit-adds\")\n\n\t// circuitKeystoneKey is used to retrieve the bucket containing circuit\n\t// keystones, which are set in place once a forwarded packet is\n\t// assigned an index on an outgoing commitment txn.\n\t//\n\t// Bucket hierarchy:\n\t//\n\t// circuitKeystoneKey(root-bucket)\n\t//     \t|\n\t//     \t|-- <outgoing-circuit-key>: <incoming-circuit-key>\n\t//     \t|-- <outgoing-circuit-key>: <incoming-circuit-key>\n\t//     \t|\n\t//     \t...\n\t//\n\tcircuitKeystoneKey = []byte(\"circuit-keystones\")\n)\n\n// circuitMap is a data structure that implements thread safe, persistent\n// storage of circuit routing information. The switch consults a circuit map to\n// determine where to forward returning HTLC update messages. Circuits are\n// always identifiable by their incoming CircuitKey, in addition to their\n// outgoing CircuitKey if the circuit is fully-opened.",
      "length": 2634,
      "tokens": 367,
      "embedding": []
    },
    {
      "slug": "type circuitMap struct {",
      "content": "type circuitMap struct {\n\tcfg *CircuitMapConfig\n\n\tmtx sync.RWMutex\n\n\t// pending is an in-memory mapping of all half payment circuits, and is\n\t// kept in sync with the on-disk contents of the circuit map.\n\tpending map[CircuitKey]*PaymentCircuit\n\n\t// opened is an in-memory mapping of all full payment circuits, which\n\t// is also synchronized with the persistent state of the circuit map.\n\topened map[CircuitKey]*PaymentCircuit\n\n\t// closed is an in-memory set of circuits for which the switch has\n\t// received a settle or fail. This precedes the actual deletion of a\n\t// circuit from disk.\n\tclosed map[CircuitKey]struct{}\n\n\t// hashIndex is a volatile index that facilitates fast queries by\n\t// payment hash against the contents of circuits. This index can be\n\t// reconstructed entirely from the set of persisted full circuits on\n\t// startup.\n\thashIndex map[[32]byte]map[CircuitKey]struct{}\n}\n\n// CircuitMapConfig houses the critical interfaces and references necessary to\n// parameterize an instance of circuitMap.",
      "length": 962,
      "tokens": 144,
      "embedding": []
    },
    {
      "slug": "type CircuitMapConfig struct {",
      "content": "type CircuitMapConfig struct {\n\t// DB provides the persistent storage engine for the circuit map.\n\tDB kvdb.Backend\n\n\t// FetchAllOpenChannels is a function that fetches all currently open\n\t// channels from the channel database.\n\tFetchAllOpenChannels func() ([]*channeldb.OpenChannel, error)\n\n\t// FetchClosedChannels is a function that fetches all closed channels\n\t// from the channel database.\n\tFetchClosedChannels func(\n\t\tpendingOnly bool) ([]*channeldb.ChannelCloseSummary, error)\n\n\t// ExtractErrorEncrypter derives the shared secret used to encrypt\n\t// errors from the obfuscator's ephemeral public key.\n\tExtractErrorEncrypter hop.ErrorEncrypterExtracter\n\n\t// CheckResolutionMsg checks whether a given resolution message exists\n\t// for the passed CircuitKey.\n\tCheckResolutionMsg func(outKey *CircuitKey) error\n}\n\n// NewCircuitMap creates a new instance of the circuitMap.",
      "length": 821,
      "tokens": 101,
      "embedding": []
    },
    {
      "slug": "func NewCircuitMap(cfg *CircuitMapConfig) (CircuitMap, error) {",
      "content": "func NewCircuitMap(cfg *CircuitMapConfig) (CircuitMap, error) {\n\tcm := &circuitMap{\n\t\tcfg: cfg,\n\t}\n\n\t// Initialize the on-disk buckets used by the circuit map.\n\tif err := cm.initBuckets(); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Delete old circuits and keystones of closed channels.\n\tif err := cm.cleanClosedChannels(); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Load any previously persisted circuit into back into memory.\n\tif err := cm.restoreMemState(); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Trim any keystones that were not committed in an outgoing commit txn.\n\t//\n\t// NOTE: This operation will be applied to the persistent state of all\n\t// active channels. Therefore, it must be called before any links are\n\t// created to avoid interfering with normal operation.\n\tif err := cm.trimAllOpenCircuits(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn cm, nil\n}\n\n// initBuckets ensures that the primary buckets used by the circuit are\n// initialized so that we can assume their existence after startup.",
      "length": 898,
      "tokens": 157,
      "embedding": []
    },
    {
      "slug": "func (cm *circuitMap) initBuckets() error {",
      "content": "func (cm *circuitMap) initBuckets() error {\n\treturn kvdb.Update(cm.cfg.DB, func(tx kvdb.RwTx) error {\n\t\t_, err := tx.CreateTopLevelBucket(circuitKeystoneKey)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t_, err = tx.CreateTopLevelBucket(circuitAddKey)\n\t\treturn err\n\t}, func() {})\n}\n\n// cleanClosedChannels deletes all circuits and keystones related to closed\n// channels. It first reads all the closed channels and caches the ShortChanIDs\n// into a map for fast lookup. Then it iterates the circuit bucket and keystone\n// bucket and deletes items whose ChanID matches the ShortChanID.\n//\n// NOTE: this operation can also be built into restoreMemState since the latter\n// already opens and iterates the two root buckets, circuitAddKey and\n// circuitKeystoneKey. Depending on the size of the buckets, this marginal gain\n// may be worth investigating. Atm, for clarity, this operation is wrapped into\n// its own function.",
      "length": 847,
      "tokens": 130,
      "embedding": []
    },
    {
      "slug": "func (cm *circuitMap) cleanClosedChannels() error {",
      "content": "func (cm *circuitMap) cleanClosedChannels() error {\n\tlog.Infof(\"Cleaning circuits from disk for closed channels\")\n\n\t// closedChanIDSet stores the short channel IDs for closed channels.\n\tclosedChanIDSet := make(map[lnwire.ShortChannelID]struct{})\n\n\t// circuitKeySet stores the incoming circuit keys of the payment\n\t// circuits that need to be deleted.\n\tcircuitKeySet := make(map[CircuitKey]struct{})\n\n\t// keystoneKeySet stores the outgoing keys of the keystones that need\n\t// to be deleted.\n\tkeystoneKeySet := make(map[CircuitKey]struct{})\n\n\t// isClosedChannel is a helper closure that returns a bool indicating\n\t// the chanID belongs to a closed channel.\n\tisClosedChannel := func(chanID lnwire.ShortChannelID) bool {\n\t\t// Skip if the channel ID is zero value. This has the effect\n\t\t// that a zero value incoming or outgoing key will never be\n\t\t// matched and its corresponding circuits or keystones are not\n\t\t// deleted.\n\t\tif chanID.ToUint64() == 0 {\n\t\t\treturn false\n\t\t}\n\n\t\t_, ok := closedChanIDSet[chanID]\n\t\treturn ok\n\t}\n\n\t// Find closed channels and cache their ShortChannelIDs into a map.\n\t// This map will be used for looking up relative circuits and keystones.\n\tclosedChannels, err := cm.cfg.FetchClosedChannels(false)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, closedChannel := range closedChannels {\n\t\t// Skip if the channel close is pending.\n\t\tif closedChannel.IsPending {\n\t\t\tcontinue\n\t\t}\n\n\t\tclosedChanIDSet[closedChannel.ShortChanID] = struct{}{}\n\t}\n\n\tlog.Debugf(\"Found %v closed channels\", len(closedChanIDSet))\n\n\t// Exit early if there are no closed channels.\n\tif len(closedChanIDSet) == 0 {\n\t\tlog.Infof(\"Finished cleaning: no closed channels found, \" +\n\t\t\t\"no actions taken.\",\n\t\t)\n\t\treturn nil\n\t}\n\n\t// Find the payment circuits and keystones that need to be deleted.\n\tif err := kvdb.View(cm.cfg.DB, func(tx kvdb.RTx) error {\n\t\tcircuitBkt := tx.ReadBucket(circuitAddKey)\n\t\tif circuitBkt == nil {\n\t\t\treturn ErrCorruptedCircuitMap\n\t\t}\n\t\tkeystoneBkt := tx.ReadBucket(circuitKeystoneKey)\n\t\tif keystoneBkt == nil {\n\t\t\treturn ErrCorruptedCircuitMap\n\t\t}\n\n\t\t// If a circuit's incoming/outgoing key prefix matches the\n\t\t// ShortChanID, it will be deleted. However, if the ShortChanID\n\t\t// of the incoming key is zero, the circuit will be kept as it\n\t\t// indicates a locally initiated payment.\n\t\tif err := circuitBkt.ForEach(func(_, v []byte) error {\n\t\t\tcircuit, err := cm.decodeCircuit(v)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Check if the incoming channel ID can be found in the\n\t\t\t// closed channel ID map.\n\t\t\tif !isClosedChannel(circuit.Incoming.ChanID) {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tcircuitKeySet[circuit.Incoming] = struct{}{}\n\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// If a keystone's InKey or OutKey matches the short channel id\n\t\t// in the closed channel ID map, it will be deleted.\n\t\terr := keystoneBkt.ForEach(func(k, v []byte) error {\n\t\t\tvar (\n\t\t\t\tinKey  CircuitKey\n\t\t\t\toutKey CircuitKey\n\t\t\t)\n\n\t\t\t// Decode the incoming and outgoing circuit keys.\n\t\t\tif err := inKey.SetBytes(v); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := outKey.SetBytes(k); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Check if the incoming channel ID can be found in the\n\t\t\t// closed channel ID map.\n\t\t\tif isClosedChannel(inKey.ChanID) {\n\t\t\t\t// If the incoming channel is closed, we can\n\t\t\t\t// skip checking on outgoing channel ID because\n\t\t\t\t// this keystone will be deleted.\n\t\t\t\tkeystoneKeySet[outKey] = struct{}{}\n\n\t\t\t\t// Technically the incoming keys found in\n\t\t\t\t// keystone bucket should be a subset of\n\t\t\t\t// circuit bucket. So a previous loop should\n\t\t\t\t// have this inKey put inside circuitAddKey map\n\t\t\t\t// already. We do this again to be sure the\n\t\t\t\t// circuits are properly cleaned. Even this\n\t\t\t\t// inKey doesn't exist in circuit bucket, we\n\t\t\t\t// are fine as db deletion is a noop.\n\t\t\t\tcircuitKeySet[inKey] = struct{}{}\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Check if the outgoing channel ID can be found in the\n\t\t\t// closed channel ID map. Notice that we need to store\n\t\t\t// the outgoing key because it's used for db query.\n\t\t\t//\n\t\t\t// NOTE: We skip this if a resolution message can be\n\t\t\t// found under the outKey. This means that there is an\n\t\t\t// existing resolution message(s) that need to get to\n\t\t\t// the incoming links.\n\t\t\tif isClosedChannel(outKey.ChanID) {\n\t\t\t\t// Check the resolution message store. A return\n\t\t\t\t// value of nil means we need to skip deleting\n\t\t\t\t// these circuits.\n\t\t\t\tif cm.cfg.CheckResolutionMsg(&outKey) == nil {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\n\t\t\t\tkeystoneKeySet[outKey] = struct{}{}\n\n\t\t\t\t// Also update circuitKeySet to mark the\n\t\t\t\t// payment circuit needs to be deleted.\n\t\t\t\tcircuitKeySet[inKey] = struct{}{}\n\t\t\t}\n\n\t\t\treturn nil\n\t\t})\n\t\treturn err\n\t}, func() {\n\t\t// Reset the sets.\n\t\tcircuitKeySet = make(map[CircuitKey]struct{})\n\t\tkeystoneKeySet = make(map[CircuitKey]struct{})\n\t}); err != nil {\n\t\treturn err\n\t}\n\n\tlog.Debugf(\"To be deleted: num_circuits=%v, num_keystones=%v\",\n\t\tlen(circuitKeySet), len(keystoneKeySet),\n\t)\n\n\tnumCircuitsDeleted := 0\n\tnumKeystonesDeleted := 0\n\n\t// Delete all the circuits and keystones for closed channels.\n\tif err := kvdb.Update(cm.cfg.DB, func(tx kvdb.RwTx) error {\n\t\tcircuitBkt := tx.ReadWriteBucket(circuitAddKey)\n\t\tif circuitBkt == nil {\n\t\t\treturn ErrCorruptedCircuitMap\n\t\t}\n\t\tkeystoneBkt := tx.ReadWriteBucket(circuitKeystoneKey)\n\t\tif keystoneBkt == nil {\n\t\t\treturn ErrCorruptedCircuitMap\n\t\t}\n\n\t\t// Delete the circuit.\n\t\tfor inKey := range circuitKeySet {\n\t\t\tif err := circuitBkt.Delete(inKey.Bytes()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tnumCircuitsDeleted++\n\t\t}\n\n\t\t// Delete the keystone using the outgoing key.\n\t\tfor outKey := range keystoneKeySet {\n\t\t\terr := keystoneBkt.Delete(outKey.Bytes())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tnumKeystonesDeleted++\n\t\t}\n\n\t\treturn nil\n\t}, func() {}); err != nil {\n\t\tnumCircuitsDeleted = 0\n\t\tnumKeystonesDeleted = 0\n\t\treturn err\n\t}\n\n\tlog.Infof(\"Finished cleaning: num_closed_channel=%v, \"+\n\t\t\"num_circuits=%v, num_keystone=%v\",\n\t\tlen(closedChannels), numCircuitsDeleted, numKeystonesDeleted,\n\t)\n\n\treturn nil\n}\n\n// restoreMemState loads the contents of the half circuit and full circuit\n// buckets from disk and reconstructs the in-memory representation of the\n// circuit map. Afterwards, the state of the hash index is reconstructed using\n// the recovered set of full circuits. This method will also remove any stray\n// keystones, which are those that appear fully-opened, but have no pending\n// circuit related to the intended incoming link.",
      "length": 6186,
      "tokens": 903,
      "embedding": []
    },
    {
      "slug": "func (cm *circuitMap) restoreMemState() error {",
      "content": "func (cm *circuitMap) restoreMemState() error {\n\tlog.Infof(\"Restoring in-memory circuit state from disk\")\n\n\tvar (\n\t\topened  map[CircuitKey]*PaymentCircuit\n\t\tpending map[CircuitKey]*PaymentCircuit\n\t)\n\n\tif err := kvdb.Update(cm.cfg.DB, func(tx kvdb.RwTx) error {\n\t\t// Restore any of the circuits persisted in the circuit bucket\n\t\t// back into memory.\n\t\tcircuitBkt := tx.ReadWriteBucket(circuitAddKey)\n\t\tif circuitBkt == nil {\n\t\t\treturn ErrCorruptedCircuitMap\n\t\t}\n\n\t\tif err := circuitBkt.ForEach(func(_, v []byte) error {\n\t\t\tcircuit, err := cm.decodeCircuit(v)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tcircuit.LoadedFromDisk = true\n\t\t\tpending[circuit.Incoming] = circuit\n\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Furthermore, load the keystone bucket and resurrect the\n\t\t// keystones used in any open circuits.\n\t\tkeystoneBkt := tx.ReadWriteBucket(circuitKeystoneKey)\n\t\tif keystoneBkt == nil {\n\t\t\treturn ErrCorruptedCircuitMap\n\t\t}\n\n\t\tvar strayKeystones []Keystone\n\t\tif err := keystoneBkt.ForEach(func(k, v []byte) error {\n\t\t\tvar (\n\t\t\t\tinKey  CircuitKey\n\t\t\t\toutKey = &CircuitKey{}\n\t\t\t)\n\n\t\t\t// Decode the incoming and outgoing circuit keys.\n\t\t\tif err := inKey.SetBytes(v); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := outKey.SetBytes(k); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Retrieve the pending circuit, set its keystone, then\n\t\t\t// add it to the opened map.\n\t\t\tcircuit, ok := pending[inKey]\n\t\t\tif ok {\n\t\t\t\tcircuit.Outgoing = outKey\n\t\t\t\topened[*outKey] = circuit\n\t\t\t} else {\n\t\t\t\tstrayKeystones = append(strayKeystones, Keystone{\n\t\t\t\t\tInKey:  inKey,\n\t\t\t\t\tOutKey: *outKey,\n\t\t\t\t})\n\t\t\t}\n\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// If any stray keystones were found, we'll proceed to prune\n\t\t// them from the circuit map's persistent storage. This may\n\t\t// manifest on older nodes that had updated channels before\n\t\t// their short channel id was set properly. We believe this\n\t\t// issue has been fixed, though this will allow older nodes to\n\t\t// recover without additional intervention.\n\t\tfor _, strayKeystone := range strayKeystones {\n\t\t\t// As a precaution, we will only cleanup keystones\n\t\t\t// related to locally-initiated payments. If a\n\t\t\t// documented case of stray keystones emerges for\n\t\t\t// forwarded payments, this check should be removed, but\n\t\t\t// with extreme caution.\n\t\t\tif strayKeystone.OutKey.ChanID != hop.Source {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tlog.Infof(\"Removing stray keystone: %v\", strayKeystone)\n\t\t\terr := keystoneBkt.Delete(strayKeystone.OutKey.Bytes())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\n\t}, func() {\n\t\topened = make(map[CircuitKey]*PaymentCircuit)\n\t\tpending = make(map[CircuitKey]*PaymentCircuit)\n\t}); err != nil {\n\t\treturn err\n\t}\n\n\tcm.pending = pending\n\tcm.opened = opened\n\tcm.closed = make(map[CircuitKey]struct{})\n\n\tlog.Infof(\"Payment circuits loaded: num_pending=%v, num_open=%v\",\n\t\tlen(pending), len(opened))\n\n\t// Finally, reconstruct the hash index by running through our set of\n\t// open circuits.\n\tcm.hashIndex = make(map[[32]byte]map[CircuitKey]struct{})\n\tfor _, circuit := range opened {\n\t\tcm.addCircuitToHashIndex(circuit)\n\t}\n\n\treturn nil\n}\n\n// decodeCircuit reconstructs an in-memory payment circuit from a byte slice.\n// The byte slice is assumed to have been generated by the circuit's Encode\n// method. If the decoding is successful, the onion obfuscator will be\n// reextracted, since it is not stored in plaintext on disk.",
      "length": 3233,
      "tokens": 451,
      "embedding": []
    },
    {
      "slug": "func (cm *circuitMap) decodeCircuit(v []byte) (*PaymentCircuit, error) {",
      "content": "func (cm *circuitMap) decodeCircuit(v []byte) (*PaymentCircuit, error) {\n\tvar circuit = &PaymentCircuit{}\n\n\tcircuitReader := bytes.NewReader(v)\n\tif err := circuit.Decode(circuitReader); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// If the error encrypter is nil, this is locally-source payment so\n\t// there is no encrypter.\n\tif circuit.ErrorEncrypter == nil {\n\t\treturn circuit, nil\n\t}\n\n\t// Otherwise, we need to reextract the encrypter, so that the shared\n\t// secret is rederived from what was decoded.\n\terr := circuit.ErrorEncrypter.Reextract(\n\t\tcm.cfg.ExtractErrorEncrypter,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn circuit, nil\n}\n\n// trimAllOpenCircuits reads the set of active channels from disk and trims\n// keystones for any non-pending channels using the next unallocated htlc index.\n// This method is intended to be called on startup. Each link will also trim\n// it's own circuits upon startup.\n//\n// NOTE: This operation will be applied to the persistent state of all active\n// channels. Therefore, it must be called before any links are created to avoid\n// interfering with normal operation.",
      "length": 998,
      "tokens": 162,
      "embedding": []
    },
    {
      "slug": "func (cm *circuitMap) trimAllOpenCircuits() error {",
      "content": "func (cm *circuitMap) trimAllOpenCircuits() error {\n\tactiveChannels, err := cm.cfg.FetchAllOpenChannels()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, activeChannel := range activeChannels {\n\t\tif activeChannel.IsPending {\n\t\t\tcontinue\n\t\t}\n\n\t\t// First, skip any channels that have not been assigned their\n\t\t// final channel identifier, otherwise we would try to trim\n\t\t// htlcs belonging to the all-zero, hop.Source ID.\n\t\tchanID := activeChannel.ShortChanID()\n\t\tif chanID == hop.Source {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Next, retrieve the next unallocated htlc index, which bounds\n\t\t// the cutoff of confirmed htlc indexes.\n\t\tstart, err := activeChannel.NextLocalHtlcIndex()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Finally, remove all pending circuits above at or above the\n\t\t// next unallocated local htlc indexes. This has the effect of\n\t\t// reverting any circuits that have either not been locked in,\n\t\t// or had not been included in a pending commitment.\n\t\terr = cm.TrimOpenCircuits(chanID, start)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// TrimOpenCircuits removes a channel's keystones above the short chan id's\n// highest committed htlc index. This has the effect of returning those\n// circuits to a half-open state. Since opening of circuits is done in advance\n// of actually committing the Add htlcs into a commitment txn, this allows\n// circuits to be opened preemptively, since we can roll them back after any\n// failures.",
      "length": 1340,
      "tokens": 217,
      "embedding": []
    },
    {
      "slug": "func (cm *circuitMap) TrimOpenCircuits(chanID lnwire.ShortChannelID,",
      "content": "func (cm *circuitMap) TrimOpenCircuits(chanID lnwire.ShortChannelID,\n\tstart uint64) error {\n\n\tlog.Infof(\"Trimming open circuits for chan_id=%v, start_htlc_id=%v\",\n\t\tchanID, start)\n\n\tvar trimmedOutKeys []CircuitKey\n\n\t// Scan forward from the last unacked htlc id, stopping as soon as we\n\t// don't find any more. Outgoing htlc id's must be assigned in order,\n\t// so there should never be disjoint segments of keystones to trim.\n\tcm.mtx.Lock()\n\tfor i := start; ; i++ {\n\t\toutKey := CircuitKey{\n\t\t\tChanID: chanID,\n\t\t\tHtlcID: i,\n\t\t}\n\n\t\tcircuit, ok := cm.opened[outKey]\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\n\t\tcircuit.Outgoing = nil\n\t\tdelete(cm.opened, outKey)\n\t\ttrimmedOutKeys = append(trimmedOutKeys, outKey)\n\t\tcm.removeCircuitFromHashIndex(circuit)\n\t}\n\tcm.mtx.Unlock()\n\n\tif len(trimmedOutKeys) == 0 {\n\t\treturn nil\n\t}\n\n\treturn kvdb.Update(cm.cfg.DB, func(tx kvdb.RwTx) error {\n\t\tkeystoneBkt := tx.ReadWriteBucket(circuitKeystoneKey)\n\t\tif keystoneBkt == nil {\n\t\t\treturn ErrCorruptedCircuitMap\n\t\t}\n\n\t\tfor _, outKey := range trimmedOutKeys {\n\t\t\terr := keystoneBkt.Delete(outKey.Bytes())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}, func() {})\n}\n\n// LookupCircuit queries the circuit map for the circuit identified by its\n// incoming circuit key. Returns nil if there is no such circuit.",
      "length": 1161,
      "tokens": 165,
      "embedding": []
    },
    {
      "slug": "func (cm *circuitMap) LookupCircuit(inKey CircuitKey) *PaymentCircuit {",
      "content": "func (cm *circuitMap) LookupCircuit(inKey CircuitKey) *PaymentCircuit {\n\tcm.mtx.RLock()\n\tdefer cm.mtx.RUnlock()\n\n\treturn cm.pending[inKey]\n}\n\n// LookupOpenCircuit searches for the circuit identified by its outgoing circuit\n// key.",
      "length": 151,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func (cm *circuitMap) LookupOpenCircuit(outKey CircuitKey) *PaymentCircuit {",
      "content": "func (cm *circuitMap) LookupOpenCircuit(outKey CircuitKey) *PaymentCircuit {\n\tcm.mtx.RLock()\n\tdefer cm.mtx.RUnlock()\n\n\treturn cm.opened[outKey]\n}\n\n// LookupByPaymentHash looks up and returns any payment circuits with a given\n// payment hash.",
      "length": 157,
      "tokens": 21,
      "embedding": []
    },
    {
      "slug": "func (cm *circuitMap) LookupByPaymentHash(hash [32]byte) []*PaymentCircuit {",
      "content": "func (cm *circuitMap) LookupByPaymentHash(hash [32]byte) []*PaymentCircuit {\n\tcm.mtx.RLock()\n\tdefer cm.mtx.RUnlock()\n\n\tvar circuits []*PaymentCircuit\n\tif circuitSet, ok := cm.hashIndex[hash]; ok {\n\t\t// Iterate over the outgoing circuit keys found with this hash,\n\t\t// and retrieve the circuit from the opened map.\n\t\tcircuits = make([]*PaymentCircuit, 0, len(circuitSet))\n\t\tfor key := range circuitSet {\n\t\t\tif circuit, ok := cm.opened[key]; ok {\n\t\t\t\tcircuits = append(circuits, circuit)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn circuits\n}\n\n// CommitCircuits accepts any number of circuits and persistently adds them to\n// the switch's circuit map. The method returns a list of circuits that had not\n// been seen prior by the switch. A link should only forward HTLCs corresponding\n// to the returned circuits to the switch.\n//\n// NOTE: This method uses batched writes to improve performance, gains will only\n// be realized if it is called concurrently from separate goroutines.",
      "length": 854,
      "tokens": 135,
      "embedding": []
    },
    {
      "slug": "func (cm *circuitMap) CommitCircuits(circuits ...*PaymentCircuit) (",
      "content": "func (cm *circuitMap) CommitCircuits(circuits ...*PaymentCircuit) (\n\t*CircuitFwdActions, error) {\n\n\tinKeys := make([]CircuitKey, 0, len(circuits))\n\tfor _, circuit := range circuits {\n\t\tinKeys = append(inKeys, circuit.Incoming)\n\t}\n\n\tlog.Tracef(\"Committing fresh circuits: %v\", newLogClosure(func() string {\n\t\treturn spew.Sdump(inKeys)\n\t}))\n\n\tactions := &CircuitFwdActions{}\n\n\t// If an empty list was passed, return early to avoid grabbing the lock.\n\tif len(circuits) == 0 {\n\t\treturn actions, nil\n\t}\n\n\t// First, we reconcile the provided circuits with our set of pending\n\t// circuits to construct a set of new circuits that need to be written\n\t// to disk. The circuit's pointer is stored so that we only permit this\n\t// exact circuit to be forwarded through the switch. If a circuit is\n\t// already pending, the htlc will be reforwarded by the switch.\n\t//\n\t// NOTE: We track an additional addFails subsequence, which permits us\n\t// to fail back all packets that weren't dropped if we encounter an\n\t// error when committing the circuits.\n\tcm.mtx.Lock()\n\tvar adds, drops, fails, addFails []*PaymentCircuit\n\tfor _, circuit := range circuits {\n\t\tinKey := circuit.InKey()\n\t\tif foundCircuit, ok := cm.pending[inKey]; ok {\n\t\t\tswitch {\n\n\t\t\t// This circuit has a keystone, it's waiting for a\n\t\t\t// response from the remote peer on the outgoing link.\n\t\t\t// Drop it like it's hot, ensure duplicates get caught.\n\t\t\tcase foundCircuit.HasKeystone():\n\t\t\t\tdrops = append(drops, circuit)\n\n\t\t\t// If no keystone is set and the switch has not been\n\t\t\t// restarted, the corresponding packet should still be\n\t\t\t// in the outgoing link's mailbox. It will be delivered\n\t\t\t// if it comes online before the switch goes down.\n\t\t\t//\n\t\t\t// NOTE: Dropping here prevents a flapping, incoming\n\t\t\t// link from failing a duplicate add while it is still\n\t\t\t// in the server's memory mailboxes.\n\t\t\tcase !foundCircuit.LoadedFromDisk:\n\t\t\t\tdrops = append(drops, circuit)\n\n\t\t\t// Otherwise, the in-mem packet has been lost due to a\n\t\t\t// restart. It is now safe to send back a failure along\n\t\t\t// the incoming link. The incoming link should be able\n\t\t\t// detect and ignore duplicate packets of this type.\n\t\t\tdefault:\n\t\t\t\tfails = append(fails, circuit)\n\t\t\t\taddFails = append(addFails, circuit)\n\t\t\t}\n\n\t\t\tcontinue\n\t\t}\n\n\t\tcm.pending[inKey] = circuit\n\t\tadds = append(adds, circuit)\n\t\taddFails = append(addFails, circuit)\n\t}\n\tcm.mtx.Unlock()\n\n\t// If all circuits are dropped or failed, we are done.\n\tif len(adds) == 0 {\n\t\tactions.Drops = drops\n\t\tactions.Fails = fails\n\t\treturn actions, nil\n\t}\n\n\t// Now, optimistically serialize the circuits to add.\n\tvar bs = make([]bytes.Buffer, len(adds))\n\tfor i, circuit := range adds {\n\t\tif err := circuit.Encode(&bs[i]); err != nil {\n\t\t\tactions.Drops = drops\n\t\t\tactions.Fails = addFails\n\t\t\treturn actions, err\n\t\t}\n\t}\n\n\t// Write the entire batch of circuits to the persistent circuit bucket\n\t// using bolt's Batch write. This method must be called from multiple,\n\t// distinct goroutines to have any impact on performance.\n\terr := kvdb.Batch(cm.cfg.DB, func(tx kvdb.RwTx) error {\n\t\tcircuitBkt := tx.ReadWriteBucket(circuitAddKey)\n\t\tif circuitBkt == nil {\n\t\t\treturn ErrCorruptedCircuitMap\n\t\t}\n\n\t\tfor i, circuit := range adds {\n\t\t\tinKeyBytes := circuit.InKey().Bytes()\n\t\t\tcircuitBytes := bs[i].Bytes()\n\n\t\t\terr := circuitBkt.Put(inKeyBytes, circuitBytes)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t})\n\n\t// Return if the write succeeded.\n\tif err == nil {\n\t\tactions.Adds = adds\n\t\tactions.Drops = drops\n\t\tactions.Fails = fails\n\t\treturn actions, nil\n\t}\n\n\t// Otherwise, rollback the circuits added to the pending set if the\n\t// write failed.\n\tcm.mtx.Lock()\n\tfor _, circuit := range adds {\n\t\tdelete(cm.pending, circuit.InKey())\n\t}\n\tcm.mtx.Unlock()\n\n\t// Since our write failed, we will return the dropped packets and mark\n\t// all other circuits as failed.\n\tactions.Drops = drops\n\tactions.Fails = addFails\n\n\treturn actions, err\n}\n\n// Keystone is a tuple binding an incoming and outgoing CircuitKey. Keystones\n// are preemptively written by an outgoing link before signing a new commitment\n// state, and cements which HTLCs we are awaiting a response from a remote\n// peer.",
      "length": 3959,
      "tokens": 618,
      "embedding": []
    },
    {
      "slug": "type Keystone struct {",
      "content": "type Keystone struct {\n\tInKey  CircuitKey\n\tOutKey CircuitKey\n}\n\n// String returns a human readable description of the Keystone.",
      "length": 100,
      "tokens": 15,
      "embedding": []
    },
    {
      "slug": "func (k Keystone) String() string {",
      "content": "func (k Keystone) String() string {\n\treturn fmt.Sprintf(\"%s --> %s\", k.InKey, k.OutKey)\n}\n\n// OpenCircuits sets the outgoing circuit key for the circuit identified by\n// inKey, persistently marking the circuit as opened. After the changes have\n// been persisted, the circuit map's in-memory indexes are updated so that this\n// circuit can be queried using LookupByKeystone or LookupByPaymentHash.",
      "length": 354,
      "tokens": 53,
      "embedding": []
    },
    {
      "slug": "func (cm *circuitMap) OpenCircuits(keystones ...Keystone) error {",
      "content": "func (cm *circuitMap) OpenCircuits(keystones ...Keystone) error {\n\tif len(keystones) == 0 {\n\t\treturn nil\n\t}\n\n\tlog.Tracef(\"Opening finalized circuits: %v\", newLogClosure(func() string {\n\t\treturn spew.Sdump(keystones)\n\t}))\n\n\t// Check that all keystones correspond to committed-but-unopened\n\t// circuits.\n\tcm.mtx.RLock()\n\topenedCircuits := make([]*PaymentCircuit, 0, len(keystones))\n\tfor _, ks := range keystones {\n\t\tif _, ok := cm.opened[ks.OutKey]; ok {\n\t\t\tcm.mtx.RUnlock()\n\t\t\treturn ErrDuplicateKeystone\n\t\t}\n\n\t\tcircuit, ok := cm.pending[ks.InKey]\n\t\tif !ok {\n\t\t\tcm.mtx.RUnlock()\n\t\t\treturn ErrUnknownCircuit\n\t\t}\n\n\t\topenedCircuits = append(openedCircuits, circuit)\n\t}\n\tcm.mtx.RUnlock()\n\n\terr := kvdb.Update(cm.cfg.DB, func(tx kvdb.RwTx) error {\n\t\t// Now, load the circuit bucket to which we will write the\n\t\t// already serialized circuit.\n\t\tkeystoneBkt := tx.ReadWriteBucket(circuitKeystoneKey)\n\t\tif keystoneBkt == nil {\n\t\t\treturn ErrCorruptedCircuitMap\n\t\t}\n\n\t\tfor _, ks := range keystones {\n\t\t\toutBytes := ks.OutKey.Bytes()\n\t\t\tinBytes := ks.InKey.Bytes()\n\t\t\terr := keystoneBkt.Put(outBytes, inBytes)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}, func() {})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcm.mtx.Lock()\n\tfor i, circuit := range openedCircuits {\n\t\tks := keystones[i]\n\n\t\t// Since our persistent operation was successful, we can now\n\t\t// modify the in memory representations. Set the outgoing\n\t\t// circuit key on our pending circuit, add the same circuit to\n\t\t// set of opened circuits, and add this circuit to the hash\n\t\t// index.\n\t\tcircuit.Outgoing = &CircuitKey{}\n\t\t*circuit.Outgoing = ks.OutKey\n\n\t\tcm.opened[ks.OutKey] = circuit\n\t\tcm.addCircuitToHashIndex(circuit)\n\t}\n\tcm.mtx.Unlock()\n\n\treturn nil\n}\n\n// addCirciutToHashIndex inserts a circuit into the circuit map's hash index, so\n// that it can be queried using LookupByPaymentHash.",
      "length": 1713,
      "tokens": 233,
      "embedding": []
    },
    {
      "slug": "func (cm *circuitMap) addCircuitToHashIndex(c *PaymentCircuit) {",
      "content": "func (cm *circuitMap) addCircuitToHashIndex(c *PaymentCircuit) {\n\tif _, ok := cm.hashIndex[c.PaymentHash]; !ok {\n\t\tcm.hashIndex[c.PaymentHash] = make(map[CircuitKey]struct{})\n\t}\n\tcm.hashIndex[c.PaymentHash][c.OutKey()] = struct{}{}\n}\n\n// FailCircuit marks the circuit identified by `inKey` as closing in-memory,\n// which prevents duplicate settles/fails from completing an open circuit twice.",
      "length": 320,
      "tokens": 37,
      "embedding": []
    },
    {
      "slug": "func (cm *circuitMap) FailCircuit(inKey CircuitKey) (*PaymentCircuit, error) {",
      "content": "func (cm *circuitMap) FailCircuit(inKey CircuitKey) (*PaymentCircuit, error) {\n\n\tcm.mtx.Lock()\n\tdefer cm.mtx.Unlock()\n\n\tcircuit, ok := cm.pending[inKey]\n\tif !ok {\n\t\treturn nil, ErrUnknownCircuit\n\t}\n\n\t_, ok = cm.closed[inKey]\n\tif ok {\n\t\treturn nil, ErrCircuitClosing\n\t}\n\n\tcm.closed[inKey] = struct{}{}\n\n\treturn circuit, nil\n}\n\n// CloseCircuit marks the circuit identified by `outKey` as closing in-memory,\n// which prevents duplicate settles/fails from completing an open\n// circuit twice.",
      "length": 388,
      "tokens": 55,
      "embedding": []
    },
    {
      "slug": "func (cm *circuitMap) CloseCircuit(outKey CircuitKey) (*PaymentCircuit, error) {",
      "content": "func (cm *circuitMap) CloseCircuit(outKey CircuitKey) (*PaymentCircuit, error) {\n\n\tcm.mtx.Lock()\n\tdefer cm.mtx.Unlock()\n\n\tcircuit, ok := cm.opened[outKey]\n\tif !ok {\n\t\treturn nil, ErrUnknownCircuit\n\t}\n\n\t_, ok = cm.closed[circuit.Incoming]\n\tif ok {\n\t\treturn nil, ErrCircuitClosing\n\t}\n\n\tcm.closed[circuit.Incoming] = struct{}{}\n\n\treturn circuit, nil\n}\n\n// DeleteCircuits destroys the target circuits by removing them from the circuit\n// map, additionally removing the circuits' keystones if any HTLCs were\n// forwarded through an outgoing link. The circuits should be identified by its\n// incoming circuit key. If a given circuit is not found in the circuit map, it\n// will be ignored from the query. This would typically indicate that the\n// circuit was already cleaned up at a different point in time.",
      "length": 695,
      "tokens": 109,
      "embedding": []
    },
    {
      "slug": "func (cm *circuitMap) DeleteCircuits(inKeys ...CircuitKey) error {",
      "content": "func (cm *circuitMap) DeleteCircuits(inKeys ...CircuitKey) error {\n\n\tlog.Tracef(\"Deleting resolved circuits: %v\", newLogClosure(func() string {\n\t\treturn spew.Sdump(inKeys)\n\t}))\n\n\tvar (\n\t\tclosingCircuits = make(map[CircuitKey]struct{})\n\t\tremovedCircuits = make(map[CircuitKey]*PaymentCircuit)\n\t)\n\n\tcm.mtx.Lock()\n\t// Remove any references to the circuits from memory, keeping track of\n\t// which circuits were removed, and which ones had been marked closed.\n\t// This can be used to restore these entries later if the persistent\n\t// removal fails.\n\tfor _, inKey := range inKeys {\n\t\tcircuit, ok := cm.pending[inKey]\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tdelete(cm.pending, inKey)\n\n\t\tif _, ok := cm.closed[inKey]; ok {\n\t\t\tclosingCircuits[inKey] = struct{}{}\n\t\t\tdelete(cm.closed, inKey)\n\t\t}\n\n\t\tif circuit.HasKeystone() {\n\t\t\tdelete(cm.opened, circuit.OutKey())\n\t\t\tcm.removeCircuitFromHashIndex(circuit)\n\t\t}\n\n\t\tremovedCircuits[inKey] = circuit\n\t}\n\tcm.mtx.Unlock()\n\n\terr := kvdb.Batch(cm.cfg.DB, func(tx kvdb.RwTx) error {\n\t\tfor _, circuit := range removedCircuits {\n\t\t\t// If this htlc made it to an outgoing link, load the\n\t\t\t// keystone bucket from which we will remove the\n\t\t\t// outgoing circuit key.\n\t\t\tif circuit.HasKeystone() {\n\t\t\t\tkeystoneBkt := tx.ReadWriteBucket(circuitKeystoneKey)\n\t\t\t\tif keystoneBkt == nil {\n\t\t\t\t\treturn ErrCorruptedCircuitMap\n\t\t\t\t}\n\n\t\t\t\toutKey := circuit.OutKey()\n\n\t\t\t\terr := keystoneBkt.Delete(outKey.Bytes())\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove the circuit itself based on the incoming\n\t\t\t// circuit key.\n\t\t\tcircuitBkt := tx.ReadWriteBucket(circuitAddKey)\n\t\t\tif circuitBkt == nil {\n\t\t\t\treturn ErrCorruptedCircuitMap\n\t\t\t}\n\n\t\t\tinKey := circuit.InKey()\n\t\t\tif err := circuitBkt.Delete(inKey.Bytes()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t})\n\n\t// Return if the write succeeded.\n\tif err == nil {\n\t\treturn nil\n\t}\n\n\t// If the persistent changes failed, restore the circuit map to it's\n\t// previous state.\n\tcm.mtx.Lock()\n\tfor inKey, circuit := range removedCircuits {\n\t\tcm.pending[inKey] = circuit\n\n\t\tif _, ok := closingCircuits[inKey]; ok {\n\t\t\tcm.closed[inKey] = struct{}{}\n\t\t}\n\n\t\tif circuit.HasKeystone() {\n\t\t\tcm.opened[circuit.OutKey()] = circuit\n\t\t\tcm.addCircuitToHashIndex(circuit)\n\t\t}\n\t}\n\tcm.mtx.Unlock()\n\n\treturn err\n}\n\n// removeCircuitFromHashIndex removes the given circuit from the hash index,\n// pruning any unnecessary memory optimistically.",
      "length": 2232,
      "tokens": 292,
      "embedding": []
    },
    {
      "slug": "func (cm *circuitMap) removeCircuitFromHashIndex(c *PaymentCircuit) {",
      "content": "func (cm *circuitMap) removeCircuitFromHashIndex(c *PaymentCircuit) {\n\t// Locate bucket containing this circuit's payment hashes.\n\tcircuitsWithHash, ok := cm.hashIndex[c.PaymentHash]\n\tif !ok {\n\t\treturn\n\t}\n\n\toutKey := c.OutKey()\n\n\t// Remove this circuit from the set of circuitsWithHash.\n\tdelete(circuitsWithHash, outKey)\n\n\t// Prune the payment hash bucket if no other entries remain.\n\tif len(circuitsWithHash) == 0 {\n\t\tdelete(cm.hashIndex, c.PaymentHash)\n\t}\n}\n\n// NumPending returns the number of active circuits added to the circuit map.",
      "length": 451,
      "tokens": 64,
      "embedding": []
    },
    {
      "slug": "func (cm *circuitMap) NumPending() int {",
      "content": "func (cm *circuitMap) NumPending() int {\n\tcm.mtx.RLock()\n\tdefer cm.mtx.RUnlock()\n\n\treturn len(cm.pending)\n}\n\n// NumOpen returns the number of circuits that have been opened by way of\n// setting their keystones. This is the number of HTLCs that are waiting for a\n// settle/fail response from a remote peer.",
      "length": 256,
      "tokens": 42,
      "embedding": []
    },
    {
      "slug": "func (cm *circuitMap) NumOpen() int {",
      "content": "func (cm *circuitMap) NumOpen() int {\n\tcm.mtx.RLock()\n\tdefer cm.mtx.RUnlock()\n\n\treturn len(cm.opened)\n}\n",
      "length": 61,
      "tokens": 6,
      "embedding": []
    }
  ]
}