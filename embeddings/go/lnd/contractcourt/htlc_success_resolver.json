{
  "filepath": "../implementations/go/lnd/contractcourt/htlc_success_resolver.go",
  "package": "contractcourt",
  "sections": [
    {
      "slug": "type htlcSuccessResolver struct {",
      "content": "type htlcSuccessResolver struct {\n\t// htlcResolution is the incoming HTLC resolution for this HTLC. It\n\t// contains everything we need to properly resolve this HTLC.\n\thtlcResolution lnwallet.IncomingHtlcResolution\n\n\t// outputIncubating returns true if we've sent the output to the output\n\t// incubator (utxo nursery). In case the htlcResolution has non-nil\n\t// SignDetails, it means we will let the Sweeper handle broadcasting\n\t// the secondd-level transaction, and sweeping its output. In this case\n\t// we let this field indicate whether we need to broadcast the\n\t// second-level tx (false) or if it has confirmed and we must sweep the\n\t// second-level output (true).\n\toutputIncubating bool\n\n\t// resolved reflects if the contract has been fully resolved or not.\n\tresolved bool\n\n\t// broadcastHeight is the height that the original contract was\n\t// broadcast to the main-chain at. We'll use this value to bound any\n\t// historical queries to the chain for spends/confirmations.\n\tbroadcastHeight uint32\n\n\t// sweepTx will be non-nil if we've already crafted a transaction to\n\t// sweep a direct HTLC output. This is only a concern if we're sweeping\n\t// from the commitment transaction of the remote party.\n\t//\n\t// TODO(roasbeef): send off to utxobundler\n\tsweepTx *wire.MsgTx\n\n\t// htlc contains information on the htlc that we are resolving on-chain.\n\thtlc channeldb.HTLC\n\n\t// currentReport stores the current state of the resolver for reporting\n\t// over the rpc interface. This should only be reported in case we have\n\t// a non-nil SignDetails on the htlcResolution, otherwise the nursery\n\t// will produce reports.\n\tcurrentReport ContractReport\n\n\t// reportLock prevents concurrent access to the resolver report.\n\treportLock sync.Mutex\n\n\tcontractResolverKit\n\n\thtlcLeaseResolver\n}\n\n// newSuccessResolver instanties a new htlc success resolver.",
      "length": 1757,
      "tokens": 267,
      "embedding": []
    },
    {
      "slug": "func newSuccessResolver(res lnwallet.IncomingHtlcResolution,",
      "content": "func newSuccessResolver(res lnwallet.IncomingHtlcResolution,\n\tbroadcastHeight uint32, htlc channeldb.HTLC,\n\tresCfg ResolverConfig) *htlcSuccessResolver {\n\n\th := &htlcSuccessResolver{\n\t\tcontractResolverKit: *newContractResolverKit(resCfg),\n\t\thtlcResolution:      res,\n\t\tbroadcastHeight:     broadcastHeight,\n\t\thtlc:                htlc,\n\t}\n\n\th.initReport()\n\n\treturn h\n}\n\n// ResolverKey returns an identifier which should be globally unique for this\n// particular resolver within the chain the original contract resides within.\n//\n// NOTE: Part of the ContractResolver interface.",
      "length": 498,
      "tokens": 55,
      "embedding": []
    },
    {
      "slug": "func (h *htlcSuccessResolver) ResolverKey() []byte {",
      "content": "func (h *htlcSuccessResolver) ResolverKey() []byte {\n\t// The primary key for this resolver will be the outpoint of the HTLC\n\t// on the commitment transaction itself. If this is our commitment,\n\t// then the output can be found within the signed success tx,\n\t// otherwise, it's just the ClaimOutpoint.\n\tvar op wire.OutPoint\n\tif h.htlcResolution.SignedSuccessTx != nil {\n\t\top = h.htlcResolution.SignedSuccessTx.TxIn[0].PreviousOutPoint\n\t} else {\n\t\top = h.htlcResolution.ClaimOutpoint\n\t}\n\n\tkey := newResolverID(op)\n\treturn key[:]\n}\n\n// Resolve attempts to resolve an unresolved incoming HTLC that we know the\n// preimage to. If the HTLC is on the commitment of the remote party, then we'll\n// simply sweep it directly. Otherwise, we'll hand this off to the utxo nursery\n// to do its duty. There is no need to make a call to the invoice registry\n// anymore. Every HTLC has already passed through the incoming contest resolver\n// and in there the invoice was already marked as settled.\n//\n// TODO(roasbeef): create multi to batch\n//\n// NOTE: Part of the ContractResolver interface.",
      "length": 998,
      "tokens": 165,
      "embedding": []
    },
    {
      "slug": "func (h *htlcSuccessResolver) Resolve() (ContractResolver, error) {",
      "content": "func (h *htlcSuccessResolver) Resolve() (ContractResolver, error) {\n\t// If we're already resolved, then we can exit early.\n\tif h.resolved {\n\t\treturn nil, nil\n\t}\n\n\t// If we don't have a success transaction, then this means that this is\n\t// an output on the remote party's commitment transaction.\n\tif h.htlcResolution.SignedSuccessTx == nil {\n\t\treturn h.resolveRemoteCommitOutput()\n\t}\n\n\t// Otherwise this an output on our own commitment, and we must start by\n\t// broadcasting the second-level success transaction.\n\tsecondLevelOutpoint, err := h.broadcastSuccessTx()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// To wrap this up, we'll wait until the second-level transaction has\n\t// been spent, then fully resolve the contract.\n\tlog.Infof(\"%T(%x): waiting for second-level HTLC output to be spent \"+\n\t\t\"after csv_delay=%v\", h, h.htlc.RHash[:], h.htlcResolution.CsvDelay)\n\n\tspend, err := waitForSpend(\n\t\tsecondLevelOutpoint,\n\t\th.htlcResolution.SweepSignDesc.Output.PkScript,\n\t\th.broadcastHeight, h.Notifier, h.quit,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\th.reportLock.Lock()\n\th.currentReport.RecoveredBalance = h.currentReport.LimboBalance\n\th.currentReport.LimboBalance = 0\n\th.reportLock.Unlock()\n\n\th.resolved = true\n\treturn nil, h.checkpointClaim(\n\t\tspend.SpenderTxHash, channeldb.ResolverOutcomeClaimed,\n\t)\n}\n\n// broadcastSuccessTx handles an HTLC output on our local commitment by\n// broadcasting the second-level success transaction. It returns the ultimate\n// outpoint of the second-level tx, that we must wait to be spent for the\n// resolver to be fully resolved.",
      "length": 1453,
      "tokens": 195,
      "embedding": []
    },
    {
      "slug": "func (h *htlcSuccessResolver) broadcastSuccessTx() (*wire.OutPoint, error) {",
      "content": "func (h *htlcSuccessResolver) broadcastSuccessTx() (*wire.OutPoint, error) {\n\t// If we have non-nil SignDetails, this means that have a 2nd level\n\t// HTLC transaction that is signed using sighash SINGLE|ANYONECANPAY\n\t// (the case for anchor type channels). In this case we can re-sign it\n\t// and attach fees at will. We let the sweeper handle this job.\n\t// We use the checkpointed outputIncubating field to determine if we\n\t// already swept the HTLC output into the second level transaction.\n\tif h.htlcResolution.SignDetails != nil {\n\t\treturn h.broadcastReSignedSuccessTx()\n\t}\n\n\t// Otherwise we'll publish the second-level transaction directly and\n\t// offer the resolution to the nursery to handle.\n\tlog.Infof(\"%T(%x): broadcasting second-layer transition tx: %v\",\n\t\th, h.htlc.RHash[:], spew.Sdump(h.htlcResolution.SignedSuccessTx))\n\n\t// We'll now broadcast the second layer transaction so we can kick off\n\t// the claiming process.\n\t//\n\t// TODO(roasbeef): after changing sighashes send to tx bundler\n\tlabel := labels.MakeLabel(\n\t\tlabels.LabelTypeChannelClose, &h.ShortChanID,\n\t)\n\terr := h.PublishTx(h.htlcResolution.SignedSuccessTx, label)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Otherwise, this is an output on our commitment transaction. In this\n\t// case, we'll send it to the incubator, but only if we haven't already\n\t// done so.\n\tif !h.outputIncubating {\n\t\tlog.Infof(\"%T(%x): incubating incoming htlc output\",\n\t\t\th, h.htlc.RHash[:])\n\n\t\terr := h.IncubateOutputs(\n\t\t\th.ChanPoint, nil, &h.htlcResolution,\n\t\t\th.broadcastHeight,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\th.outputIncubating = true\n\n\t\tif err := h.Checkpoint(h); err != nil {\n\t\t\tlog.Errorf(\"unable to Checkpoint: %v\", err)\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn &h.htlcResolution.ClaimOutpoint, nil\n}\n\n// broadcastReSignedSuccessTx handles the case where we have non-nil\n// SignDetails, and offers the second level transaction to the Sweeper, that\n// will re-sign it and attach fees at will.",
      "length": 1828,
      "tokens": 263,
      "embedding": []
    },
    {
      "slug": "func (h *htlcSuccessResolver) broadcastReSignedSuccessTx() (",
      "content": "func (h *htlcSuccessResolver) broadcastReSignedSuccessTx() (\n\t*wire.OutPoint, error) {\n\n\t// Keep track of the tx spending the HTLC output on the commitment, as\n\t// this will be the confirmed second-level tx we'll ultimately sweep.\n\tvar commitSpend *chainntnfs.SpendDetail\n\n\t// We will have to let the sweeper re-sign the success tx and wait for\n\t// it to confirm, if we haven't already.\n\tif !h.outputIncubating {\n\t\tlog.Infof(\"%T(%x): offering second-layer transition tx to \"+\n\t\t\t\"sweeper: %v\", h, h.htlc.RHash[:],\n\t\t\tspew.Sdump(h.htlcResolution.SignedSuccessTx))\n\n\t\tsecondLevelInput := input.MakeHtlcSecondLevelSuccessAnchorInput(\n\t\t\th.htlcResolution.SignedSuccessTx,\n\t\t\th.htlcResolution.SignDetails, h.htlcResolution.Preimage,\n\t\t\th.broadcastHeight,\n\t\t)\n\t\t_, err := h.Sweeper.SweepInput(\n\t\t\t&secondLevelInput,\n\t\t\tsweep.Params{\n\t\t\t\tFee: sweep.FeePreference{\n\t\t\t\t\tConfTarget: secondLevelConfTarget,\n\t\t\t\t},\n\t\t\t},\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tlog.Infof(\"%T(%x): waiting for second-level HTLC success \"+\n\t\t\t\"transaction to confirm\", h, h.htlc.RHash[:])\n\n\t\t// Wait for the second level transaction to confirm.\n\t\tcommitSpend, err = waitForSpend(\n\t\t\t&h.htlcResolution.SignedSuccessTx.TxIn[0].PreviousOutPoint,\n\t\t\th.htlcResolution.SignDetails.SignDesc.Output.PkScript,\n\t\t\th.broadcastHeight, h.Notifier, h.quit,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Now that the second-level transaction has confirmed, we\n\t\t// checkpoint the state so we'll go to the next stage in case\n\t\t// of restarts.\n\t\th.outputIncubating = true\n\t\tif err := h.Checkpoint(h); err != nil {\n\t\t\tlog.Errorf(\"unable to Checkpoint: %v\", err)\n\t\t\treturn nil, err\n\t\t}\n\n\t\tlog.Infof(\"%T(%x): second-level HTLC success transaction \"+\n\t\t\t\"confirmed!\", h, h.htlc.RHash[:])\n\t}\n\n\t// If we ended up here after a restart, we must again get the\n\t// spend notification.\n\tif commitSpend == nil {\n\t\tvar err error\n\t\tcommitSpend, err = waitForSpend(\n\t\t\t&h.htlcResolution.SignedSuccessTx.TxIn[0].PreviousOutPoint,\n\t\t\th.htlcResolution.SignDetails.SignDesc.Output.PkScript,\n\t\t\th.broadcastHeight, h.Notifier, h.quit,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// The HTLC success tx has a CSV lock that we must wait for, and if\n\t// this is a lease enforced channel and we're the imitator, we may need\n\t// to wait for longer.\n\twaitHeight := h.deriveWaitHeight(\n\t\th.htlcResolution.CsvDelay, commitSpend,\n\t)\n\n\t// Now that the sweeper has broadcasted the second-level transaction,\n\t// it has confirmed, and we have checkpointed our state, we'll sweep\n\t// the second level output. We report the resolver has moved the next\n\t// stage.\n\th.reportLock.Lock()\n\th.currentReport.Stage = 2\n\th.currentReport.MaturityHeight = waitHeight\n\th.reportLock.Unlock()\n\n\tif h.hasCLTV() {\n\t\tlog.Infof(\"%T(%x): waiting for CSV and CLTV lock to \"+\n\t\t\t\"expire at height %v\", h, h.htlc.RHash[:],\n\t\t\twaitHeight)\n\t} else {\n\t\tlog.Infof(\"%T(%x): waiting for CSV lock to expire at \"+\n\t\t\t\"height %v\", h, h.htlc.RHash[:], waitHeight)\n\t}\n\n\terr := waitForHeight(waitHeight, h.Notifier, h.quit)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// We'll use this input index to determine the second-level output\n\t// index on the transaction, as the signatures requires the indexes to\n\t// be the same. We don't look for the second-level output script\n\t// directly, as there might be more than one HTLC output to the same\n\t// pkScript.\n\top := &wire.OutPoint{\n\t\tHash:  *commitSpend.SpenderTxHash,\n\t\tIndex: commitSpend.SpenderInputIndex,\n\t}\n\n\t// Finally, let the sweeper sweep the second-level output.\n\tlog.Infof(\"%T(%x): CSV lock expired, offering second-layer \"+\n\t\t\"output to sweeper: %v\", h, h.htlc.RHash[:], op)\n\n\t// Let the sweeper sweep the second-level output now that the\n\t// CSV/CLTV locks have expired.\n\tinp := h.makeSweepInput(\n\t\top, input.HtlcAcceptedSuccessSecondLevel,\n\t\tinput.LeaseHtlcAcceptedSuccessSecondLevel,\n\t\t&h.htlcResolution.SweepSignDesc,\n\t\th.htlcResolution.CsvDelay, h.broadcastHeight,\n\t\th.htlc.RHash,\n\t)\n\t_, err = h.Sweeper.SweepInput(\n\t\tinp,\n\t\tsweep.Params{\n\t\t\tFee: sweep.FeePreference{\n\t\t\t\tConfTarget: sweepConfTarget,\n\t\t\t},\n\t\t},\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Will return this outpoint, when this is spent the resolver is fully\n\t// resolved.\n\treturn op, nil\n}\n\n// resolveRemoteCommitOutput handles sweeping an HTLC output on the remote\n// commitment with the preimage. In this case we can sweep the output directly,\n// and don't have to broadcast a second-level transaction.",
      "length": 4232,
      "tokens": 559,
      "embedding": []
    },
    {
      "slug": "func (h *htlcSuccessResolver) resolveRemoteCommitOutput() (",
      "content": "func (h *htlcSuccessResolver) resolveRemoteCommitOutput() (\n\tContractResolver, error) {\n\n\t// If we don't already have the sweep transaction constructed, we'll do\n\t// so and broadcast it.\n\tif h.sweepTx == nil {\n\t\tlog.Infof(\"%T(%x): crafting sweep tx for incoming+remote \"+\n\t\t\t\"htlc confirmed\", h, h.htlc.RHash[:])\n\n\t\t// Before we can craft out sweeping transaction, we need to\n\t\t// create an input which contains all the items required to add\n\t\t// this input to a sweeping transaction, and generate a\n\t\t// witness.\n\t\tinp := input.MakeHtlcSucceedInput(\n\t\t\t&h.htlcResolution.ClaimOutpoint,\n\t\t\t&h.htlcResolution.SweepSignDesc,\n\t\t\th.htlcResolution.Preimage[:],\n\t\t\th.broadcastHeight,\n\t\t\th.htlcResolution.CsvDelay,\n\t\t)\n\n\t\t// With the input created, we can now generate the full sweep\n\t\t// transaction, that we'll use to move these coins back into\n\t\t// the backing wallet.\n\t\t//\n\t\t// TODO: Set tx lock time to current block height instead of\n\t\t// zero. Will be taken care of once sweeper implementation is\n\t\t// complete.\n\t\t//\n\t\t// TODO: Use time-based sweeper and result chan.\n\t\tvar err error\n\t\th.sweepTx, err = h.Sweeper.CreateSweepTx(\n\t\t\t[]input.Input{&inp},\n\t\t\tsweep.FeePreference{\n\t\t\t\tConfTarget: sweepConfTarget,\n\t\t\t}, 0,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tlog.Infof(\"%T(%x): crafted sweep tx=%v\", h,\n\t\t\th.htlc.RHash[:], spew.Sdump(h.sweepTx))\n\n\t\t// TODO(halseth): should checkpoint sweep tx to DB? Since after\n\t\t// a restart we might create a different tx, that will conflict\n\t\t// with the published one.\n\t}\n\n\t// Regardless of whether an existing transaction was found or newly\n\t// constructed, we'll broadcast the sweep transaction to the network.\n\tlabel := labels.MakeLabel(\n\t\tlabels.LabelTypeChannelClose, &h.ShortChanID,\n\t)\n\terr := h.PublishTx(h.sweepTx, label)\n\tif err != nil {\n\t\tlog.Infof(\"%T(%x): unable to publish tx: %v\",\n\t\t\th, h.htlc.RHash[:], err)\n\t\treturn nil, err\n\t}\n\n\t// With the sweep transaction broadcast, we'll wait for its\n\t// confirmation.\n\tsweepTXID := h.sweepTx.TxHash()\n\tsweepScript := h.sweepTx.TxOut[0].PkScript\n\tconfNtfn, err := h.Notifier.RegisterConfirmationsNtfn(\n\t\t&sweepTXID, sweepScript, 1, h.broadcastHeight,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tlog.Infof(\"%T(%x): waiting for sweep tx (txid=%v) to be \"+\n\t\t\"confirmed\", h, h.htlc.RHash[:], sweepTXID)\n\n\tselect {\n\tcase _, ok := <-confNtfn.Confirmed:\n\t\tif !ok {\n\t\t\treturn nil, errResolverShuttingDown\n\t\t}\n\n\tcase <-h.quit:\n\t\treturn nil, errResolverShuttingDown\n\t}\n\n\t// Once the transaction has received a sufficient number of\n\t// confirmations, we'll mark ourselves as fully resolved and exit.\n\th.resolved = true\n\n\t// Checkpoint the resolver, and write the outcome to disk.\n\treturn nil, h.checkpointClaim(\n\t\t&sweepTXID,\n\t\tchanneldb.ResolverOutcomeClaimed,\n\t)\n}\n\n// checkpointClaim checkpoints the success resolver with the reports it needs.\n// If this htlc was claimed two stages, it will write reports for both stages,\n// otherwise it will just write for the single htlc claim.",
      "length": 2817,
      "tokens": 395,
      "embedding": []
    },
    {
      "slug": "func (h *htlcSuccessResolver) checkpointClaim(spendTx *chainhash.Hash,",
      "content": "func (h *htlcSuccessResolver) checkpointClaim(spendTx *chainhash.Hash,\n\toutcome channeldb.ResolverOutcome) error {\n\n\t// Mark the htlc as final settled.\n\terr := h.ChainArbitratorConfig.PutFinalHtlcOutcome(\n\t\th.ChannelArbitratorConfig.ShortChanID, h.htlc.HtlcIndex, true,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Send notification.\n\th.ChainArbitratorConfig.HtlcNotifier.NotifyFinalHtlcEvent(\n\t\tmodels.CircuitKey{\n\t\t\tChanID: h.ShortChanID,\n\t\t\tHtlcID: h.htlc.HtlcIndex,\n\t\t},\n\t\tchanneldb.FinalHtlcInfo{\n\t\t\tSettled:  true,\n\t\t\tOffchain: false,\n\t\t},\n\t)\n\n\t// Create a resolver report for claiming of the htlc itself.\n\tamt := btcutil.Amount(h.htlcResolution.SweepSignDesc.Output.Value)\n\treports := []*channeldb.ResolverReport{\n\t\t{\n\t\t\tOutPoint:        h.htlcResolution.ClaimOutpoint,\n\t\t\tAmount:          amt,\n\t\t\tResolverType:    channeldb.ResolverTypeIncomingHtlc,\n\t\t\tResolverOutcome: outcome,\n\t\t\tSpendTxID:       spendTx,\n\t\t},\n\t}\n\n\t// If we have a success tx, we append a report to represent our first\n\t// stage claim.\n\tif h.htlcResolution.SignedSuccessTx != nil {\n\t\t// If the SignedSuccessTx is not nil, we are claiming the htlc\n\t\t// in two stages, so we need to create a report for the first\n\t\t// stage transaction as well.\n\t\tspendTx := h.htlcResolution.SignedSuccessTx\n\t\tspendTxID := spendTx.TxHash()\n\n\t\treport := &channeldb.ResolverReport{\n\t\t\tOutPoint:        spendTx.TxIn[0].PreviousOutPoint,\n\t\t\tAmount:          h.htlc.Amt.ToSatoshis(),\n\t\t\tResolverType:    channeldb.ResolverTypeIncomingHtlc,\n\t\t\tResolverOutcome: channeldb.ResolverOutcomeFirstStage,\n\t\t\tSpendTxID:       &spendTxID,\n\t\t}\n\t\treports = append(reports, report)\n\t}\n\n\t// Finally, we checkpoint the resolver with our report(s).\n\treturn h.Checkpoint(h, reports...)\n}\n\n// Stop signals the resolver to cancel any current resolution processes, and\n// suspend.\n//\n// NOTE: Part of the ContractResolver interface.",
      "length": 1730,
      "tokens": 187,
      "embedding": []
    },
    {
      "slug": "func (h *htlcSuccessResolver) Stop() {",
      "content": "func (h *htlcSuccessResolver) Stop() {\n\tclose(h.quit)\n}\n\n// IsResolved returns true if the stored state in the resolve is fully\n// resolved. In this case the target output can be forgotten.\n//\n// NOTE: Part of the ContractResolver interface.",
      "length": 196,
      "tokens": 34,
      "embedding": []
    },
    {
      "slug": "func (h *htlcSuccessResolver) IsResolved() bool {",
      "content": "func (h *htlcSuccessResolver) IsResolved() bool {\n\treturn h.resolved\n}\n\n// report returns a report on the resolution state of the contract.",
      "length": 86,
      "tokens": 15,
      "embedding": []
    },
    {
      "slug": "func (h *htlcSuccessResolver) report() *ContractReport {",
      "content": "func (h *htlcSuccessResolver) report() *ContractReport {\n\t// If the sign details are nil, the report will be created by handled\n\t// by the nursery.\n\tif h.htlcResolution.SignDetails == nil {\n\t\treturn nil\n\t}\n\n\th.reportLock.Lock()\n\tdefer h.reportLock.Unlock()\n\tcpy := h.currentReport\n\treturn &cpy\n}\n",
      "length": 228,
      "tokens": 35,
      "embedding": []
    },
    {
      "slug": "func (h *htlcSuccessResolver) initReport() {",
      "content": "func (h *htlcSuccessResolver) initReport() {\n\t// We create the initial report. This will only be reported for\n\t// resolvers not handled by the nursery.\n\tfinalAmt := h.htlc.Amt.ToSatoshis()\n\tif h.htlcResolution.SignedSuccessTx != nil {\n\t\tfinalAmt = btcutil.Amount(\n\t\t\th.htlcResolution.SignedSuccessTx.TxOut[0].Value,\n\t\t)\n\t}\n\n\th.currentReport = ContractReport{\n\t\tOutpoint:       h.htlcResolution.ClaimOutpoint,\n\t\tType:           ReportOutputIncomingHtlc,\n\t\tAmount:         finalAmt,\n\t\tMaturityHeight: h.htlcResolution.CsvDelay,\n\t\tLimboBalance:   finalAmt,\n\t\tStage:          1,\n\t}\n}\n\n// Encode writes an encoded version of the ContractResolver into the passed\n// Writer.\n//\n// NOTE: Part of the ContractResolver interface.",
      "length": 652,
      "tokens": 72,
      "embedding": []
    },
    {
      "slug": "func (h *htlcSuccessResolver) Encode(w io.Writer) error {",
      "content": "func (h *htlcSuccessResolver) Encode(w io.Writer) error {\n\t// First we'll encode our inner HTLC resolution.\n\tif err := encodeIncomingResolution(w, &h.htlcResolution); err != nil {\n\t\treturn err\n\t}\n\n\t// Next, we'll write out the fields that are specified to the contract\n\t// resolver.\n\tif err := binary.Write(w, endian, h.outputIncubating); err != nil {\n\t\treturn err\n\t}\n\tif err := binary.Write(w, endian, h.resolved); err != nil {\n\t\treturn err\n\t}\n\tif err := binary.Write(w, endian, h.broadcastHeight); err != nil {\n\t\treturn err\n\t}\n\tif _, err := w.Write(h.htlc.RHash[:]); err != nil {\n\t\treturn err\n\t}\n\n\t// We encode the sign details last for backwards compatibility.\n\terr := encodeSignDetails(w, h.htlcResolution.SignDetails)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// newSuccessResolverFromReader attempts to decode an encoded ContractResolver\n// from the passed Reader instance, returning an active ContractResolver\n// instance.",
      "length": 847,
      "tokens": 131,
      "embedding": []
    },
    {
      "slug": "func newSuccessResolverFromReader(r io.Reader, resCfg ResolverConfig) (",
      "content": "func newSuccessResolverFromReader(r io.Reader, resCfg ResolverConfig) (\n\t*htlcSuccessResolver, error) {\n\n\th := &htlcSuccessResolver{\n\t\tcontractResolverKit: *newContractResolverKit(resCfg),\n\t}\n\n\t// First we'll decode our inner HTLC resolution.\n\tif err := decodeIncomingResolution(r, &h.htlcResolution); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Next, we'll read all the fields that are specified to the contract\n\t// resolver.\n\tif err := binary.Read(r, endian, &h.outputIncubating); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := binary.Read(r, endian, &h.resolved); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := binary.Read(r, endian, &h.broadcastHeight); err != nil {\n\t\treturn nil, err\n\t}\n\tif _, err := io.ReadFull(r, h.htlc.RHash[:]); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Sign details is a new field that was added to the htlc resolution,\n\t// so it is serialized last for backwards compatibility. We try to read\n\t// it, but don't error out if there are not bytes left.\n\tsignDetails, err := decodeSignDetails(r)\n\tif err == nil {\n\t\th.htlcResolution.SignDetails = signDetails\n\t} else if err != io.EOF && err != io.ErrUnexpectedEOF {\n\t\treturn nil, err\n\t}\n\n\th.initReport()\n\n\treturn h, nil\n}\n\n// Supplement adds additional information to the resolver that is required\n// before Resolve() is called.\n//\n// NOTE: Part of the htlcContractResolver interface.",
      "length": 1229,
      "tokens": 196,
      "embedding": []
    },
    {
      "slug": "func (h *htlcSuccessResolver) Supplement(htlc channeldb.HTLC) {",
      "content": "func (h *htlcSuccessResolver) Supplement(htlc channeldb.HTLC) {\n\th.htlc = htlc\n}\n\n// HtlcPoint returns the htlc's outpoint on the commitment tx.\n//\n// NOTE: Part of the htlcContractResolver interface.",
      "length": 131,
      "tokens": 22,
      "embedding": []
    },
    {
      "slug": "func (h *htlcSuccessResolver) HtlcPoint() wire.OutPoint {",
      "content": "func (h *htlcSuccessResolver) HtlcPoint() wire.OutPoint {\n\treturn h.htlcResolution.HtlcPoint()\n}\n\n// A compile time assertion to ensure htlcSuccessResolver meets the\n// ContractResolver interface.\nvar _ htlcContractResolver = (*htlcSuccessResolver)(nil)\n",
      "length": 190,
      "tokens": 21,
      "embedding": []
    }
  ]
}