{
  "filepath": "../implementations/go/lnd/contractcourt/htlc_timeout_resolver.go",
  "package": "contractcourt",
  "sections": [
    {
      "slug": "type htlcTimeoutResolver struct {",
      "content": "type htlcTimeoutResolver struct {\n\t// htlcResolution contains all the information required to properly\n\t// resolve this outgoing HTLC.\n\thtlcResolution lnwallet.OutgoingHtlcResolution\n\n\t// outputIncubating returns true if we've sent the output to the output\n\t// incubator (utxo nursery).\n\toutputIncubating bool\n\n\t// resolved reflects if the contract has been fully resolved or not.\n\tresolved bool\n\n\t// broadcastHeight is the height that the original contract was\n\t// broadcast to the main-chain at. We'll use this value to bound any\n\t// historical queries to the chain for spends/confirmations.\n\t//\n\t// TODO(roasbeef): wrap above into definite resolution embedding?\n\tbroadcastHeight uint32\n\n\t// htlc contains information on the htlc that we are resolving on-chain.\n\thtlc channeldb.HTLC\n\n\t// currentReport stores the current state of the resolver for reporting\n\t// over the rpc interface. This should only be reported in case we have\n\t// a non-nil SignDetails on the htlcResolution, otherwise the nursery\n\t// will produce reports.\n\tcurrentReport ContractReport\n\n\t// reportLock prevents concurrent access to the resolver report.\n\treportLock sync.Mutex\n\n\tcontractResolverKit\n\n\thtlcLeaseResolver\n}\n\n// newTimeoutResolver instantiates a new timeout htlc resolver.",
      "length": 1188,
      "tokens": 167,
      "embedding": []
    },
    {
      "slug": "func newTimeoutResolver(res lnwallet.OutgoingHtlcResolution,",
      "content": "func newTimeoutResolver(res lnwallet.OutgoingHtlcResolution,\n\tbroadcastHeight uint32, htlc channeldb.HTLC,\n\tresCfg ResolverConfig) *htlcTimeoutResolver {\n\n\th := &htlcTimeoutResolver{\n\t\tcontractResolverKit: *newContractResolverKit(resCfg),\n\t\thtlcResolution:      res,\n\t\tbroadcastHeight:     broadcastHeight,\n\t\thtlc:                htlc,\n\t}\n\n\th.initReport()\n\n\treturn h\n}\n\n// ResolverKey returns an identifier which should be globally unique for this\n// particular resolver within the chain the original contract resides within.\n//\n// NOTE: Part of the ContractResolver interface.",
      "length": 498,
      "tokens": 55,
      "embedding": []
    },
    {
      "slug": "func (h *htlcTimeoutResolver) ResolverKey() []byte {",
      "content": "func (h *htlcTimeoutResolver) ResolverKey() []byte {\n\t// The primary key for this resolver will be the outpoint of the HTLC\n\t// on the commitment transaction itself. If this is our commitment,\n\t// then the output can be found within the signed timeout tx,\n\t// otherwise, it's just the ClaimOutpoint.\n\tvar op wire.OutPoint\n\tif h.htlcResolution.SignedTimeoutTx != nil {\n\t\top = h.htlcResolution.SignedTimeoutTx.TxIn[0].PreviousOutPoint\n\t} else {\n\t\top = h.htlcResolution.ClaimOutpoint\n\t}\n\n\tkey := newResolverID(op)\n\treturn key[:]\n}\n\nconst (\n\t// expectedRemoteWitnessSuccessSize is the expected size of the witness\n\t// on the remote commitment transaction for an outgoing HTLC that is\n\t// swept on-chain by them with pre-image.\n\texpectedRemoteWitnessSuccessSize = 5\n\n\t// remotePreimageIndex index within the witness on the remote\n\t// commitment transaction that will hold they pre-image if they go to\n\t// sweep it on chain.\n\tremotePreimageIndex = 3\n\n\t// localPreimageIndex is the index within the witness on the local\n\t// commitment transaction for an outgoing HTLC that will hold the\n\t// pre-image if the remote party sweeps it.\n\tlocalPreimageIndex = 1\n)\n\n// claimCleanUp is a helper method that's called once the HTLC output is spent\n// by the remote party. It'll extract the preimage, add it to the global cache,\n// and finally send the appropriate clean up message.",
      "length": 1277,
      "tokens": 201,
      "embedding": []
    },
    {
      "slug": "func (h *htlcTimeoutResolver) claimCleanUp(",
      "content": "func (h *htlcTimeoutResolver) claimCleanUp(\n\tcommitSpend *chainntnfs.SpendDetail) (ContractResolver, error) {\n\n\t// Depending on if this is our commitment or not, then we'll be looking\n\t// for a different witness pattern.\n\tspenderIndex := commitSpend.SpenderInputIndex\n\tspendingInput := commitSpend.SpendingTx.TxIn[spenderIndex]\n\n\tlog.Infof(\"%T(%v): extracting preimage! remote party spent \"+\n\t\t\"HTLC with tx=%v\", h, h.htlcResolution.ClaimOutpoint,\n\t\tspew.Sdump(commitSpend.SpendingTx))\n\n\t// If this is the remote party's commitment, then we'll be looking for\n\t// them to spend using the second-level success transaction.\n\tvar preimageBytes []byte\n\tif h.htlcResolution.SignedTimeoutTx == nil {\n\t\t// The witness stack when the remote party sweeps the output to\n\t\t// them looks like:\n\t\t//\n\t\t//  * <0> <sender sig> <recvr sig> <preimage> <witness script>\n\t\tpreimageBytes = spendingInput.Witness[remotePreimageIndex]\n\t} else {\n\t\t// Otherwise, they'll be spending directly from our commitment\n\t\t// output. In which case the witness stack looks like:\n\t\t//\n\t\t//  * <sig> <preimage> <witness script>\n\t\tpreimageBytes = spendingInput.Witness[localPreimageIndex]\n\t}\n\n\tpreimage, err := lntypes.MakePreimage(preimageBytes)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to create pre-image from \"+\n\t\t\t\"witness: %v\", err)\n\t}\n\n\tlog.Infof(\"%T(%v): extracting preimage=%v from on-chain \"+\n\t\t\"spend!\", h, h.htlcResolution.ClaimOutpoint, preimage)\n\n\t// With the preimage obtained, we can now add it to the global cache.\n\tif err := h.PreimageDB.AddPreimages(preimage); err != nil {\n\t\tlog.Errorf(\"%T(%v): unable to add witness to cache\",\n\t\t\th, h.htlcResolution.ClaimOutpoint)\n\t}\n\n\tvar pre [32]byte\n\tcopy(pre[:], preimage[:])\n\n\t// Finally, we'll send the clean up message, mark ourselves as\n\t// resolved, then exit.\n\tif err := h.DeliverResolutionMsg(ResolutionMsg{\n\t\tSourceChan: h.ShortChanID,\n\t\tHtlcIndex:  h.htlc.HtlcIndex,\n\t\tPreImage:   &pre,\n\t}); err != nil {\n\t\treturn nil, err\n\t}\n\th.resolved = true\n\n\t// Checkpoint our resolver with a report which reflects the preimage\n\t// claim by the remote party.\n\tamt := btcutil.Amount(h.htlcResolution.SweepSignDesc.Output.Value)\n\treport := &channeldb.ResolverReport{\n\t\tOutPoint:        h.htlcResolution.ClaimOutpoint,\n\t\tAmount:          amt,\n\t\tResolverType:    channeldb.ResolverTypeOutgoingHtlc,\n\t\tResolverOutcome: channeldb.ResolverOutcomeClaimed,\n\t\tSpendTxID:       commitSpend.SpenderTxHash,\n\t}\n\n\treturn nil, h.Checkpoint(h, report)\n}\n\n// chainDetailsToWatch returns the output and script which we use to watch for\n// spends from the direct HTLC output on the commitment transaction.\n//\n// TODO(joostjager): output already set properly in\n// lnwallet.newOutgoingHtlcResolution? And script too?",
      "length": 2603,
      "tokens": 318,
      "embedding": []
    },
    {
      "slug": "func (h *htlcTimeoutResolver) chainDetailsToWatch() (*wire.OutPoint, []byte, error) {",
      "content": "func (h *htlcTimeoutResolver) chainDetailsToWatch() (*wire.OutPoint, []byte, error) {\n\t// If there's no timeout transaction, then the claim output is the\n\t// output directly on the commitment transaction, so we'll just use\n\t// that.\n\tif h.htlcResolution.SignedTimeoutTx == nil {\n\t\toutPointToWatch := h.htlcResolution.ClaimOutpoint\n\t\tscriptToWatch := h.htlcResolution.SweepSignDesc.Output.PkScript\n\n\t\treturn &outPointToWatch, scriptToWatch, nil\n\t}\n\n\t// If this is the remote party's commitment, then we'll need to grab\n\t// watch the output that our timeout transaction points to. We can\n\t// directly grab the outpoint, then also extract the witness script\n\t// (the last element of the witness stack) to re-construct the pkScript\n\t// we need to watch.\n\toutPointToWatch := h.htlcResolution.SignedTimeoutTx.TxIn[0].PreviousOutPoint\n\twitness := h.htlcResolution.SignedTimeoutTx.TxIn[0].Witness\n\tscriptToWatch, err := input.WitnessScriptHash(witness[len(witness)-1])\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn &outPointToWatch, scriptToWatch, nil\n}\n\n// isSuccessSpend returns true if the passed spend on the specified commitment\n// is a success spend that reveals the pre-image or not.",
      "length": 1076,
      "tokens": 142,
      "embedding": []
    },
    {
      "slug": "func isSuccessSpend(spend *chainntnfs.SpendDetail, localCommit bool) bool {",
      "content": "func isSuccessSpend(spend *chainntnfs.SpendDetail, localCommit bool) bool {\n\t// Based on the spending input index and transaction, obtain the\n\t// witness that tells us what type of spend this is.\n\tspenderIndex := spend.SpenderInputIndex\n\tspendingInput := spend.SpendingTx.TxIn[spenderIndex]\n\tspendingWitness := spendingInput.Witness\n\n\t// If this is the remote commitment then the only possible spends for\n\t// outgoing HTLCs are:\n\t//\n\t//  RECVR: <0> <sender sig> <recvr sig> <preimage> (2nd level success spend)\n\t//  REVOK: <sig> <key>\n\t//  SENDR: <sig> 0\n\t//\n\t// In this case, if 5 witness elements are present (factoring the\n\t// witness script), and the 3rd element is the size of the pre-image,\n\t// then this is a remote spend. If not, then we swept it ourselves, or\n\t// revoked their output.\n\tif !localCommit {\n\t\treturn len(spendingWitness) == expectedRemoteWitnessSuccessSize &&\n\t\t\tlen(spendingWitness[remotePreimageIndex]) == lntypes.HashSize\n\t}\n\n\t// Otherwise, for our commitment, the only possible spends for an\n\t// outgoing HTLC are:\n\t//\n\t//  SENDR: <0> <sendr sig>  <recvr sig> <0> (2nd level timeout)\n\t//  RECVR: <recvr sig>  <preimage>\n\t//  REVOK: <revoke sig> <revoke key>\n\t//\n\t// So the only success case has the pre-image as the 2nd (index 1)\n\t// element in the witness.\n\treturn len(spendingWitness[localPreimageIndex]) == lntypes.HashSize\n}\n\n// Resolve kicks off full resolution of an outgoing HTLC output. If it's our\n// commitment, it isn't resolved until we see the second level HTLC txn\n// confirmed. If it's the remote party's commitment, we don't resolve until we\n// see a direct sweep via the timeout clause.\n//\n// NOTE: Part of the ContractResolver interface.",
      "length": 1567,
      "tokens": 246,
      "embedding": []
    },
    {
      "slug": "func (h *htlcTimeoutResolver) Resolve() (ContractResolver, error) {",
      "content": "func (h *htlcTimeoutResolver) Resolve() (ContractResolver, error) {\n\t// If we're already resolved, then we can exit early.\n\tif h.resolved {\n\t\treturn nil, nil\n\t}\n\n\t// Start by spending the HTLC output, either by broadcasting the\n\t// second-level timeout transaction, or directly if this is the remote\n\t// commitment.\n\tcommitSpend, err := h.spendHtlcOutput()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// If the spend reveals the pre-image, then we'll enter the clean up\n\t// workflow to pass the pre-image back to the incoming link, add it to\n\t// the witness cache, and exit.\n\tif isSuccessSpend(commitSpend, h.htlcResolution.SignedTimeoutTx != nil) {\n\t\tlog.Infof(\"%T(%v): HTLC has been swept with pre-image by \"+\n\t\t\t\"remote party during timeout flow! Adding pre-image to \"+\n\t\t\t\"witness cache\", h.htlcResolution.ClaimOutpoint)\n\n\t\treturn h.claimCleanUp(commitSpend)\n\t}\n\n\tlog.Infof(\"%T(%v): resolving htlc with incoming fail msg, fully \"+\n\t\t\"confirmed\", h, h.htlcResolution.ClaimOutpoint)\n\n\t// At this point, the second-level transaction is sufficiently\n\t// confirmed, or a transaction directly spending the output is.\n\t// Therefore, we can now send back our clean up message, failing the\n\t// HTLC on the incoming link.\n\tfailureMsg := &lnwire.FailPermanentChannelFailure{}\n\tif err := h.DeliverResolutionMsg(ResolutionMsg{\n\t\tSourceChan: h.ShortChanID,\n\t\tHtlcIndex:  h.htlc.HtlcIndex,\n\t\tFailure:    failureMsg,\n\t}); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Depending on whether this was a local or remote commit, we must\n\t// handle the spending transaction accordingly.\n\treturn h.handleCommitSpend(commitSpend)\n}\n\n// spendHtlcOutput handles the initial spend of an HTLC output via the timeout\n// clause. If this is our local commitment, the second-level timeout TX will be\n// used to spend the output into the next stage. If this is the remote\n// commitment, the output will be swept directly without the timeout\n// transaction.",
      "length": 1799,
      "tokens": 266,
      "embedding": []
    },
    {
      "slug": "func (h *htlcTimeoutResolver) spendHtlcOutput() (*chainntnfs.SpendDetail, error) {",
      "content": "func (h *htlcTimeoutResolver) spendHtlcOutput() (*chainntnfs.SpendDetail, error) {\n\tswitch {\n\t// If we have non-nil SignDetails, this means that have a 2nd level\n\t// HTLC transaction that is signed using sighash SINGLE|ANYONECANPAY\n\t// (the case for anchor type channels). In this case we can re-sign it\n\t// and attach fees at will. We let the sweeper handle this job.\n\tcase h.htlcResolution.SignDetails != nil && !h.outputIncubating:\n\t\tlog.Infof(\"%T(%x): offering second-layer timeout tx to \"+\n\t\t\t\"sweeper: %v\", h, h.htlc.RHash[:],\n\t\t\tspew.Sdump(h.htlcResolution.SignedTimeoutTx))\n\n\t\tinp := input.MakeHtlcSecondLevelTimeoutAnchorInput(\n\t\t\th.htlcResolution.SignedTimeoutTx,\n\t\t\th.htlcResolution.SignDetails,\n\t\t\th.broadcastHeight,\n\t\t)\n\t\t_, err := h.Sweeper.SweepInput(\n\t\t\t&inp,\n\t\t\tsweep.Params{\n\t\t\t\tFee: sweep.FeePreference{\n\t\t\t\t\tConfTarget: secondLevelConfTarget,\n\t\t\t\t},\n\t\t\t},\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t// If we have no SignDetails, and we haven't already sent the output to\n\t// the utxo nursery, then we'll do so now.\n\tcase h.htlcResolution.SignDetails == nil && !h.outputIncubating:\n\t\tlog.Debugf(\"%T(%v): incubating htlc output\", h,\n\t\t\th.htlcResolution.ClaimOutpoint)\n\n\t\terr := h.IncubateOutputs(\n\t\t\th.ChanPoint, &h.htlcResolution, nil,\n\t\t\th.broadcastHeight,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\th.outputIncubating = true\n\n\t\tif err := h.Checkpoint(h); err != nil {\n\t\t\tlog.Errorf(\"unable to Checkpoint: %v\", err)\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Now that we've handed off the HTLC to the nursery or sweeper, we'll\n\t// watch for a spend of the output, and make our next move off of that.\n\t// Depending on if this is our commitment, or the remote party's\n\t// commitment, we'll be watching a different outpoint and script.\n\toutpointToWatch, scriptToWatch, err := h.chainDetailsToWatch()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tlog.Infof(\"%T(%v): waiting for spent of HTLC output %v to be \"+\n\t\t\"fully confirmed\", h, h.htlcResolution.ClaimOutpoint,\n\t\toutpointToWatch)\n\n\t// We'll block here until either we exit, or the HTLC output on the\n\t// commitment transaction has been spent.\n\tspend, err := waitForSpend(\n\t\toutpointToWatch, scriptToWatch, h.broadcastHeight,\n\t\th.Notifier, h.quit,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// If this was the second level transaction published by the sweeper,\n\t// we can checkpoint the resolver now that it's confirmed.\n\tif h.htlcResolution.SignDetails != nil && !h.outputIncubating {\n\t\th.outputIncubating = true\n\t\tif err := h.Checkpoint(h); err != nil {\n\t\t\tlog.Errorf(\"unable to Checkpoint: %v\", err)\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn spend, err\n}\n\n// handleCommitSpend handles the spend of the HTLC output on the commitment\n// transaction. If this was our local commitment, the spend will be he\n// confirmed second-level timeout transaction, and we'll sweep that into our\n// wallet. If the was a remote commitment, the resolver will resolve\n// immetiately.",
      "length": 2750,
      "tokens": 396,
      "embedding": []
    },
    {
      "slug": "func (h *htlcTimeoutResolver) handleCommitSpend(",
      "content": "func (h *htlcTimeoutResolver) handleCommitSpend(\n\tcommitSpend *chainntnfs.SpendDetail) (ContractResolver, error) {\n\n\tvar (\n\t\t// claimOutpoint will be the outpoint of the second level\n\t\t// transaction, or on the remote commitment directly. It will\n\t\t// start out as set in the resolution, but we'll update it if\n\t\t// the second-level goes through the sweeper and changes its\n\t\t// txid.\n\t\tclaimOutpoint = h.htlcResolution.ClaimOutpoint\n\n\t\t// spendTxID will be the ultimate spend of the claimOutpoint.\n\t\t// We set it to the commit spend for now, as this is the\n\t\t// ultimate spend in case this is a remote commitment. If we go\n\t\t// through the second-level transaction, we'll update this\n\t\t// accordingly.\n\t\tspendTxID = commitSpend.SpenderTxHash\n\n\t\treports []*channeldb.ResolverReport\n\t)\n\n\tswitch {\n\t// If the sweeper is handling the second level transaction, wait for\n\t// the CSV and possible CLTV lock to expire, before sweeping the output\n\t// on the second-level.\n\tcase h.htlcResolution.SignDetails != nil:\n\t\twaitHeight := h.deriveWaitHeight(\n\t\t\th.htlcResolution.CsvDelay, commitSpend,\n\t\t)\n\n\t\th.reportLock.Lock()\n\t\th.currentReport.Stage = 2\n\t\th.currentReport.MaturityHeight = waitHeight\n\t\th.reportLock.Unlock()\n\n\t\tif h.hasCLTV() {\n\t\t\tlog.Infof(\"%T(%x): waiting for CSV and CLTV lock to \"+\n\t\t\t\t\"expire at height %v\", h, h.htlc.RHash[:],\n\t\t\t\twaitHeight)\n\t\t} else {\n\t\t\tlog.Infof(\"%T(%x): waiting for CSV lock to expire at \"+\n\t\t\t\t\"height %v\", h, h.htlc.RHash[:], waitHeight)\n\t\t}\n\n\t\terr := waitForHeight(waitHeight, h.Notifier, h.quit)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// We'll use this input index to determine the second-level\n\t\t// output index on the transaction, as the signatures requires\n\t\t// the indexes to be the same. We don't look for the\n\t\t// second-level output script directly, as there might be more\n\t\t// than one HTLC output to the same pkScript.\n\t\top := &wire.OutPoint{\n\t\t\tHash:  *commitSpend.SpenderTxHash,\n\t\t\tIndex: commitSpend.SpenderInputIndex,\n\t\t}\n\n\t\t// Let the sweeper sweep the second-level output now that the\n\t\t// CSV/CLTV locks have expired.\n\t\tinp := h.makeSweepInput(\n\t\t\top, input.HtlcOfferedTimeoutSecondLevel,\n\t\t\tinput.LeaseHtlcOfferedTimeoutSecondLevel,\n\t\t\t&h.htlcResolution.SweepSignDesc,\n\t\t\th.htlcResolution.CsvDelay, h.broadcastHeight,\n\t\t\th.htlc.RHash,\n\t\t)\n\t\t_, err = h.Sweeper.SweepInput(\n\t\t\tinp,\n\t\t\tsweep.Params{\n\t\t\t\tFee: sweep.FeePreference{\n\t\t\t\t\tConfTarget: sweepConfTarget,\n\t\t\t\t},\n\t\t\t},\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Update the claim outpoint to point to the second-level\n\t\t// transaction created by the sweeper.\n\t\tclaimOutpoint = *op\n\t\tfallthrough\n\n\t// Finally, if this was an output on our commitment transaction, we'll\n\t// wait for the second-level HTLC output to be spent, and for that\n\t// transaction itself to confirm.\n\tcase h.htlcResolution.SignedTimeoutTx != nil:\n\t\tlog.Infof(\"%T(%v): waiting for nursery/sweeper to spend CSV \"+\n\t\t\t\"delayed output\", h, claimOutpoint)\n\t\tsweepTx, err := waitForSpend(\n\t\t\t&claimOutpoint,\n\t\t\th.htlcResolution.SweepSignDesc.Output.PkScript,\n\t\t\th.broadcastHeight, h.Notifier, h.quit,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Update the spend txid to the hash of the sweep transaction.\n\t\tspendTxID = sweepTx.SpenderTxHash\n\n\t\t// Once our sweep of the timeout tx has confirmed, we add a\n\t\t// resolution for our timeoutTx tx first stage transaction.\n\t\ttimeoutTx := commitSpend.SpendingTx\n\t\tindex := commitSpend.SpenderInputIndex\n\t\tspendHash := commitSpend.SpenderTxHash\n\n\t\treports = append(reports, &channeldb.ResolverReport{\n\t\t\tOutPoint:        timeoutTx.TxIn[index].PreviousOutPoint,\n\t\t\tAmount:          h.htlc.Amt.ToSatoshis(),\n\t\t\tResolverType:    channeldb.ResolverTypeOutgoingHtlc,\n\t\t\tResolverOutcome: channeldb.ResolverOutcomeFirstStage,\n\t\t\tSpendTxID:       spendHash,\n\t\t})\n\t}\n\n\t// With the clean up message sent, we'll now mark the contract\n\t// resolved, update the recovered balance, record the timeout and the\n\t// sweep txid on disk, and wait.\n\th.resolved = true\n\th.reportLock.Lock()\n\th.currentReport.RecoveredBalance = h.currentReport.LimboBalance\n\th.currentReport.LimboBalance = 0\n\th.reportLock.Unlock()\n\n\tamt := btcutil.Amount(h.htlcResolution.SweepSignDesc.Output.Value)\n\treports = append(reports, &channeldb.ResolverReport{\n\t\tOutPoint:        claimOutpoint,\n\t\tAmount:          amt,\n\t\tResolverType:    channeldb.ResolverTypeOutgoingHtlc,\n\t\tResolverOutcome: channeldb.ResolverOutcomeTimeout,\n\t\tSpendTxID:       spendTxID,\n\t})\n\n\treturn nil, h.Checkpoint(h, reports...)\n}\n\n// Stop signals the resolver to cancel any current resolution processes, and\n// suspend.\n//\n// NOTE: Part of the ContractResolver interface.",
      "length": 4440,
      "tokens": 549,
      "embedding": []
    },
    {
      "slug": "func (h *htlcTimeoutResolver) Stop() {",
      "content": "func (h *htlcTimeoutResolver) Stop() {\n\tclose(h.quit)\n}\n\n// IsResolved returns true if the stored state in the resolve is fully\n// resolved. In this case the target output can be forgotten.\n//\n// NOTE: Part of the ContractResolver interface.",
      "length": 196,
      "tokens": 34,
      "embedding": []
    },
    {
      "slug": "func (h *htlcTimeoutResolver) IsResolved() bool {",
      "content": "func (h *htlcTimeoutResolver) IsResolved() bool {\n\treturn h.resolved\n}\n\n// report returns a report on the resolution state of the contract.",
      "length": 86,
      "tokens": 15,
      "embedding": []
    },
    {
      "slug": "func (h *htlcTimeoutResolver) report() *ContractReport {",
      "content": "func (h *htlcTimeoutResolver) report() *ContractReport {\n\t// If the sign details are nil, the report will be created by handled\n\t// by the nursery.\n\tif h.htlcResolution.SignDetails == nil {\n\t\treturn nil\n\t}\n\n\th.reportLock.Lock()\n\tdefer h.reportLock.Unlock()\n\tcpy := h.currentReport\n\treturn &cpy\n}\n",
      "length": 228,
      "tokens": 35,
      "embedding": []
    },
    {
      "slug": "func (h *htlcTimeoutResolver) initReport() {",
      "content": "func (h *htlcTimeoutResolver) initReport() {\n\t// We create the initial report. This will only be reported for\n\t// resolvers not handled by the nursery.\n\tfinalAmt := h.htlc.Amt.ToSatoshis()\n\tif h.htlcResolution.SignedTimeoutTx != nil {\n\t\tfinalAmt = btcutil.Amount(\n\t\t\th.htlcResolution.SignedTimeoutTx.TxOut[0].Value,\n\t\t)\n\t}\n\n\th.currentReport = ContractReport{\n\t\tOutpoint:       h.htlcResolution.ClaimOutpoint,\n\t\tType:           ReportOutputOutgoingHtlc,\n\t\tAmount:         finalAmt,\n\t\tMaturityHeight: h.htlcResolution.Expiry,\n\t\tLimboBalance:   finalAmt,\n\t\tStage:          1,\n\t}\n}\n\n// Encode writes an encoded version of the ContractResolver into the passed\n// Writer.\n//\n// NOTE: Part of the ContractResolver interface.",
      "length": 650,
      "tokens": 72,
      "embedding": []
    },
    {
      "slug": "func (h *htlcTimeoutResolver) Encode(w io.Writer) error {",
      "content": "func (h *htlcTimeoutResolver) Encode(w io.Writer) error {\n\t// First, we'll write out the relevant fields of the\n\t// OutgoingHtlcResolution to the writer.\n\tif err := encodeOutgoingResolution(w, &h.htlcResolution); err != nil {\n\t\treturn err\n\t}\n\n\t// With that portion written, we can now write out the fields specific\n\t// to the resolver itself.\n\tif err := binary.Write(w, endian, h.outputIncubating); err != nil {\n\t\treturn err\n\t}\n\tif err := binary.Write(w, endian, h.resolved); err != nil {\n\t\treturn err\n\t}\n\tif err := binary.Write(w, endian, h.broadcastHeight); err != nil {\n\t\treturn err\n\t}\n\n\tif err := binary.Write(w, endian, h.htlc.HtlcIndex); err != nil {\n\t\treturn err\n\t}\n\n\t// We encode the sign details last for backwards compatibility.\n\terr := encodeSignDetails(w, h.htlcResolution.SignDetails)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// newTimeoutResolverFromReader attempts to decode an encoded ContractResolver\n// from the passed Reader instance, returning an active ContractResolver\n// instance.",
      "length": 920,
      "tokens": 142,
      "embedding": []
    },
    {
      "slug": "func newTimeoutResolverFromReader(r io.Reader, resCfg ResolverConfig) (",
      "content": "func newTimeoutResolverFromReader(r io.Reader, resCfg ResolverConfig) (\n\t*htlcTimeoutResolver, error) {\n\n\th := &htlcTimeoutResolver{\n\t\tcontractResolverKit: *newContractResolverKit(resCfg),\n\t}\n\n\t// First, we'll read out all the mandatory fields of the\n\t// OutgoingHtlcResolution that we store.\n\tif err := decodeOutgoingResolution(r, &h.htlcResolution); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// With those fields read, we can now read back the fields that are\n\t// specific to the resolver itself.\n\tif err := binary.Read(r, endian, &h.outputIncubating); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := binary.Read(r, endian, &h.resolved); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := binary.Read(r, endian, &h.broadcastHeight); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := binary.Read(r, endian, &h.htlc.HtlcIndex); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Sign details is a new field that was added to the htlc resolution,\n\t// so it is serialized last for backwards compatibility. We try to read\n\t// it, but don't error out if there are not bytes left.\n\tsignDetails, err := decodeSignDetails(r)\n\tif err == nil {\n\t\th.htlcResolution.SignDetails = signDetails\n\t} else if err != io.EOF && err != io.ErrUnexpectedEOF {\n\t\treturn nil, err\n\t}\n\n\th.initReport()\n\n\treturn h, nil\n}\n\n// Supplement adds additional information to the resolver that is required\n// before Resolve() is called.\n//\n// NOTE: Part of the htlcContractResolver interface.",
      "length": 1306,
      "tokens": 209,
      "embedding": []
    },
    {
      "slug": "func (h *htlcTimeoutResolver) Supplement(htlc channeldb.HTLC) {",
      "content": "func (h *htlcTimeoutResolver) Supplement(htlc channeldb.HTLC) {\n\th.htlc = htlc\n}\n\n// HtlcPoint returns the htlc's outpoint on the commitment tx.\n//\n// NOTE: Part of the htlcContractResolver interface.",
      "length": 131,
      "tokens": 22,
      "embedding": []
    },
    {
      "slug": "func (h *htlcTimeoutResolver) HtlcPoint() wire.OutPoint {",
      "content": "func (h *htlcTimeoutResolver) HtlcPoint() wire.OutPoint {\n\treturn h.htlcResolution.HtlcPoint()\n}\n\n// A compile time assertion to ensure htlcTimeoutResolver meets the\n// ContractResolver interface.\nvar _ htlcContractResolver = (*htlcTimeoutResolver)(nil)\n",
      "length": 190,
      "tokens": 21,
      "embedding": []
    }
  ]
}