{
  "filepath": "../implementations/go/lnd/contractcourt/nursery_store.go",
  "package": "contractcourt",
  "sections": [
    {
      "slug": "type NurseryStorer interface {",
      "content": "type NurseryStorer interface {\n\t// Incubate registers a set of CSV delayed outputs (incoming HTLC's on\n\t// our commitment transaction, or a commitment output), and a slice of\n\t// outgoing htlc outputs to be swept back into the user's wallet. The\n\t// event is persisted to disk, such that the nursery can resume the\n\t// incubation process after a potential crash.\n\tIncubate([]kidOutput, []babyOutput) error\n\n\t// CribToKinder atomically moves a babyOutput in the crib bucket to the\n\t// kindergarten bucket. Baby outputs are outgoing HTLC's which require\n\t// us to go to the second-layer to claim. The now mature kidOutput\n\t// contained in the babyOutput will be stored as it waits out the\n\t// kidOutput's CSV delay.\n\tCribToKinder(*babyOutput) error\n\n\t// PreschoolToKinder atomically moves a kidOutput from the preschool\n\t// bucket to the kindergarten bucket. This transition should be executed\n\t// after receiving confirmation of the preschool output. Incoming HTLC's\n\t// we need to go to the second-layer to claim, and also our commitment\n\t// outputs fall into this class.\n\t//\n\t// An additional parameter specifies the last graduated height. This is\n\t// used in case of late registration. It schedules the output for sweep\n\t// at the next epoch even though it has already expired earlier.\n\tPreschoolToKinder(kid *kidOutput, lastGradHeight uint32) error\n\n\t// GraduateKinder atomically moves an output at the provided height into\n\t// the graduated status. This involves removing the kindergarten entries\n\t// from both the height and channel indexes. The height bucket will be\n\t// opportunistically pruned from the height index as outputs are\n\t// removed.\n\tGraduateKinder(height uint32, output *kidOutput) error\n\n\t// FetchPreschools returns a list of all outputs currently stored in\n\t// the preschool bucket.\n\tFetchPreschools() ([]kidOutput, error)\n\n\t// FetchClass returns a list of kindergarten and crib outputs whose\n\t// timelocks expire at the given height.\n\tFetchClass(height uint32) ([]kidOutput, []babyOutput, error)\n\n\t// HeightsBelowOrEqual returns the lowest non-empty heights in the\n\t// height index, that exist at or below the provided upper bound.\n\tHeightsBelowOrEqual(height uint32) ([]uint32, error)\n\n\t// ForChanOutputs iterates over all outputs being incubated for a\n\t// particular channel point. This method accepts a callback that allows\n\t// the caller to process each key-value pair. The key will be a prefixed\n\t// outpoint, and the value will be the serialized bytes for an output,\n\t// whose type should be inferred from the key's prefix.\n\tForChanOutputs(*wire.OutPoint, func([]byte, []byte) error, func()) error\n\n\t// ListChannels returns all channels the nursery is currently tracking.\n\tListChannels() ([]wire.OutPoint, error)\n\n\t// IsMatureChannel determines the whether or not all of the outputs in a\n\t// particular channel bucket have been marked as graduated.\n\tIsMatureChannel(*wire.OutPoint) (bool, error)\n\n\t// RemoveChannel channel erases all entries from the channel bucket for\n\t// the provided channel point, this method should only be called if\n\t// IsMatureChannel indicates the channel is ready for removal.\n\tRemoveChannel(*wire.OutPoint) error\n}\n\nvar (\n\t// utxnChainPrefix is used to prefix a particular chain hash and create\n\t// the root-level, chain-segmented bucket for each nursery store.\n\tutxnChainPrefix = []byte(\"utxn\")\n\n\t// channelIndexKey is a static key used to lookup the bucket containing\n\t// all of the nursery's active channels.\n\tchannelIndexKey = []byte(\"channel-index\")\n\n\t// channelIndexKey is a static key used to retrieve a directory\n\t// containing all heights for which the nursery will need to take\n\t// action.\n\theightIndexKey = []byte(\"height-index\")\n)\n\n// Defines the state prefixes that will be used to persistently track an\n// output's progress through the nursery.\n// NOTE: Each state prefix MUST be exactly 4 bytes in length, the nursery logic\n// depends on the ability to create keys for a different state by overwriting\n// an existing state prefix.\nvar (\n\t// cribPrefix is the state prefix given to htlc outputs waiting for\n\t// their first-stage, absolute locktime to elapse.\n\tcribPrefix = []byte(\"crib\")\n\n\t// psclPrefix is the state prefix given to commitment outputs awaiting\n\t// the confirmation of the commitment transaction, as this solidifies\n\t// the absolute height at which they can be spent.\n\tpsclPrefix = []byte(\"pscl\")\n\n\t// kndrPrefix is the state prefix given to all CSV delayed outputs,\n\t// either from the commitment transaction, or a stage-one htlc\n\t// transaction, whose maturity height has solidified. Outputs marked in\n\t// this state are in their final stage of incubation within the nursery,\n\t// and will be swept into the wallet after waiting out the relative\n\t// timelock.\n\tkndrPrefix = []byte(\"kndr\")\n\n\t// gradPrefix is the state prefix given to all outputs that have been\n\t// completely incubated. Once all outputs have been marked as graduated,\n\t// this serves as a persistent marker that the nursery should mark the\n\t// channel fully closed in the channeldb.\n\tgradPrefix = []byte(\"grad\")\n)\n\n// prefixChainKey creates the root level keys for the nursery store. The keys\n// are comprised of a nursery-specific prefix and the intended chain hash that\n// this nursery store will be used for. This allows multiple nursery stores to\n// isolate their state when operating on multiple chains or forks.",
      "length": 5228,
      "tokens": 810,
      "embedding": []
    },
    {
      "slug": "func prefixChainKey(sysPrefix []byte, hash *chainhash.Hash) ([]byte, error) {",
      "content": "func prefixChainKey(sysPrefix []byte, hash *chainhash.Hash) ([]byte, error) {\n\t// Create a buffer to which we will write the system prefix, e.g.\n\t// \"utxn\", followed by the provided chain hash.\n\tvar pfxChainBuffer bytes.Buffer\n\tif _, err := pfxChainBuffer.Write(sysPrefix); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif _, err := pfxChainBuffer.Write(hash[:]); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn pfxChainBuffer.Bytes(), nil\n}\n\n// prefixOutputKey creates a serialized key that prefixes the serialized\n// outpoint with the provided state prefix. The returned bytes will be of the\n// form <prefix><outpoint>.",
      "length": 512,
      "tokens": 81,
      "embedding": []
    },
    {
      "slug": "func prefixOutputKey(statePrefix []byte,",
      "content": "func prefixOutputKey(statePrefix []byte,\n\toutpoint *wire.OutPoint) ([]byte, error) {\n\n\t// Create a buffer to which we will first write the state prefix,\n\t// followed by the outpoint.\n\tvar pfxOutputBuffer bytes.Buffer\n\tif _, err := pfxOutputBuffer.Write(statePrefix); err != nil {\n\t\treturn nil, err\n\t}\n\n\terr := writeOutpoint(&pfxOutputBuffer, outpoint)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn pfxOutputBuffer.Bytes(), nil\n}\n\n// NurseryStore is a concrete instantiation of a NurseryStore that is backed by\n// a channeldb.DB instance.",
      "length": 479,
      "tokens": 73,
      "embedding": []
    },
    {
      "slug": "type NurseryStore struct {",
      "content": "type NurseryStore struct {\n\tchainHash chainhash.Hash\n\tdb        *channeldb.DB\n\n\tpfxChainKey []byte\n}\n\n// NewNurseryStore accepts a chain hash and a channeldb.DB instance, returning\n// an instance of NurseryStore who's database is properly segmented for the\n// given chain.",
      "length": 237,
      "tokens": 33,
      "embedding": []
    },
    {
      "slug": "func NewNurseryStore(chainHash *chainhash.Hash,",
      "content": "func NewNurseryStore(chainHash *chainhash.Hash,\n\tdb *channeldb.DB) (*NurseryStore, error) {\n\n\t// Prefix the provided chain hash with \"utxn\" to create the key for the\n\t// nursery store's root bucket, ensuring each one has proper chain\n\t// segmentation.\n\tpfxChainKey, err := prefixChainKey(utxnChainPrefix, chainHash)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &NurseryStore{\n\t\tchainHash:   *chainHash,\n\t\tdb:          db,\n\t\tpfxChainKey: pfxChainKey,\n\t}, nil\n}\n\n// Incubate persists the beginning of the incubation process for the\n// CSV-delayed outputs (commitment and incoming HTLC's), commitment output and\n// a list of outgoing two-stage htlc outputs.",
      "length": 589,
      "tokens": 86,
      "embedding": []
    },
    {
      "slug": "func (ns *NurseryStore) Incubate(kids []kidOutput, babies []babyOutput) error {",
      "content": "func (ns *NurseryStore) Incubate(kids []kidOutput, babies []babyOutput) error {\n\treturn kvdb.Update(ns.db, func(tx kvdb.RwTx) error {\n\t\t// If we have any kid outputs to incubate, then we'll attempt\n\t\t// to add each of them to the nursery store. Any duplicate\n\t\t// outputs will be ignored.\n\t\tfor _, kid := range kids {\n\t\t\tif err := ns.enterPreschool(tx, &kid); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\t// Next, we'll Add all htlc outputs to the crib bucket.\n\t\t// Similarly, we'll ignore any outputs that have already been\n\t\t// inserted.\n\t\tfor _, baby := range babies {\n\t\t\tif err := ns.enterCrib(tx, &baby); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}, func() {})\n}\n\n// CribToKinder atomically moves a babyOutput in the crib bucket to the\n// kindergarten bucket. The now mature kidOutput contained in the babyOutput\n// will be stored as it waits out the kidOutput's CSV delay.",
      "length": 778,
      "tokens": 139,
      "embedding": []
    },
    {
      "slug": "func (ns *NurseryStore) CribToKinder(bby *babyOutput) error {",
      "content": "func (ns *NurseryStore) CribToKinder(bby *babyOutput) error {\n\treturn kvdb.Update(ns.db, func(tx kvdb.RwTx) error {\n\t\t// First, retrieve or create the channel bucket corresponding to\n\t\t// the baby output's origin channel point.\n\t\tchanPoint := bby.OriginChanPoint()\n\t\tchanBucket, err := ns.createChannelBucket(tx, chanPoint)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// The babyOutput should currently be stored in the crib bucket.\n\t\t// So, we create a key that prefixes the babyOutput's outpoint\n\t\t// with the crib prefix, allowing us to reference it in the\n\t\t// store.\n\t\tpfxOutputKey, err := prefixOutputKey(cribPrefix, bby.OutPoint())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Since the babyOutput is being moved to the kindergarten\n\t\t// bucket, we remove the entry from the channel bucket under the\n\t\t// crib-prefixed outpoint key.\n\t\tif err := chanBucket.Delete(pfxOutputKey); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Remove the crib output's entry in the height index.\n\t\terr = ns.removeOutputFromHeight(tx, bby.expiry, chanPoint,\n\t\t\tpfxOutputKey)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Since we are moving this output from the crib bucket to the\n\t\t// kindergarten bucket, we overwrite the existing prefix of this\n\t\t// key with the kindergarten prefix.\n\t\tcopy(pfxOutputKey, kndrPrefix)\n\n\t\t// Now, serialize babyOutput's encapsulated kidOutput such that\n\t\t// it can be written to the channel bucket under the new\n\t\t// kindergarten-prefixed key.\n\t\tvar kidBuffer bytes.Buffer\n\t\tif err := bby.kidOutput.Encode(&kidBuffer); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tkidBytes := kidBuffer.Bytes()\n\n\t\t// Persist the serialized kidOutput under the\n\t\t// kindergarten-prefixed outpoint key.\n\t\tif err := chanBucket.Put(pfxOutputKey, kidBytes); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Now, compute the height at which this kidOutput's CSV delay\n\t\t// will expire.  This is done by adding the required delay to\n\t\t// the block height at which the output was confirmed.\n\t\tmaturityHeight := bby.ConfHeight() + bby.BlocksToMaturity()\n\n\t\t// Retrieve or create a height-channel bucket corresponding to\n\t\t// the kidOutput's maturity height.\n\t\thghtChanBucketCsv, err := ns.createHeightChanBucket(tx,\n\t\t\tmaturityHeight, chanPoint)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tutxnLog.Tracef(\"Transitioning (crib -> baby) output for \"+\n\t\t\t\"chan_point=%v at height_index=%v\", chanPoint,\n\t\t\tmaturityHeight)\n\n\t\t// Register the kindergarten output's prefixed output key in the\n\t\t// height-channel bucket corresponding to its maturity height.\n\t\t// This informs the utxo nursery that it should attempt to spend\n\t\t// this output when the blockchain reaches the maturity height.\n\t\treturn hghtChanBucketCsv.Put(pfxOutputKey, []byte{})\n\t}, func() {})\n}\n\n// PreschoolToKinder atomically moves a kidOutput from the preschool bucket to\n// the kindergarten bucket. This transition should be executed after receiving\n// confirmation of the preschool output's commitment transaction.",
      "length": 2783,
      "tokens": 398,
      "embedding": []
    },
    {
      "slug": "func (ns *NurseryStore) PreschoolToKinder(kid *kidOutput,",
      "content": "func (ns *NurseryStore) PreschoolToKinder(kid *kidOutput,\n\tlastGradHeight uint32) error {\n\n\treturn kvdb.Update(ns.db, func(tx kvdb.RwTx) error {\n\t\t// Create or retrieve the channel bucket corresponding to the\n\t\t// kid output's origin channel point.\n\t\tchanPoint := kid.OriginChanPoint()\n\t\tchanBucket, err := ns.createChannelBucket(tx, chanPoint)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// First, we will attempt to remove the existing serialized\n\t\t// output from the channel bucket, where the kid's outpoint will\n\t\t// be prefixed by a preschool prefix.\n\n\t\t// Generate the key of existing serialized kid output by\n\t\t// prefixing its outpoint with the preschool prefix...\n\t\tpfxOutputKey, err := prefixOutputKey(psclPrefix, kid.OutPoint())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// And remove the old serialized output from the database.\n\t\tif err := chanBucket.Delete(pfxOutputKey); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Next, we will write the provided kid outpoint to the channel\n\t\t// bucket, using a key prefixed by the kindergarten prefix.\n\n\t\t// Convert the preschool prefix key into a kindergarten key for\n\t\t// the same outpoint.\n\t\tcopy(pfxOutputKey, kndrPrefix)\n\n\t\t// Reserialize the kid here to capture any differences in the\n\t\t// new and old kid output, such as the confirmation height.\n\t\tvar kidBuffer bytes.Buffer\n\t\tif err := kid.Encode(&kidBuffer); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tkidBytes := kidBuffer.Bytes()\n\n\t\t// And store the kid output in its channel bucket using the\n\t\t// kindergarten prefixed key.\n\t\tif err := chanBucket.Put(pfxOutputKey, kidBytes); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// If this output has an absolute time lock, then we'll set the\n\t\t// maturity height directly.\n\t\tvar maturityHeight uint32\n\t\tif kid.BlocksToMaturity() == 0 {\n\t\t\tmaturityHeight = kid.absoluteMaturity\n\t\t} else {\n\t\t\t// Otherwise, since the CSV delay on the kid output has\n\t\t\t// now begun ticking, we must insert a record of in the\n\t\t\t// height index to remind us to revisit this output\n\t\t\t// once it has fully matured.\n\t\t\t//\n\t\t\t// Compute the maturity height, by adding the output's\n\t\t\t// CSV delay to its confirmation height.\n\t\t\tmaturityHeight = kid.ConfHeight() + kid.BlocksToMaturity()\n\t\t}\n\n\t\tif maturityHeight <= lastGradHeight {\n\t\t\tutxnLog.Debugf(\"Late Registration for kid output=%v \"+\n\t\t\t\t\"detected: class_height=%v, \"+\n\t\t\t\t\"last_graduated_height=%v\", kid.OutPoint(),\n\t\t\t\tmaturityHeight, lastGradHeight)\n\n\t\t\tmaturityHeight = lastGradHeight + 1\n\t\t}\n\n\t\tutxnLog.Infof(\"Transitioning (crib -> kid) output for \"+\n\t\t\t\"chan_point=%v at height_index=%v\", chanPoint,\n\t\t\tmaturityHeight)\n\n\t\t// Create or retrieve the height-channel bucket for this\n\t\t// channel. This method will first create a height bucket for\n\t\t// the given maturity height if none exists.\n\t\thghtChanBucket, err := ns.createHeightChanBucket(tx,\n\t\t\tmaturityHeight, chanPoint)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Finally, we touch a key in the height-channel created above.\n\t\t// The key is named using a kindergarten prefixed key, signaling\n\t\t// that this CSV delayed output will be ready to broadcast at\n\t\t// the maturity height, after a brief period of incubation.\n\t\treturn hghtChanBucket.Put(pfxOutputKey, []byte{})\n\t}, func() {})\n}\n\n// GraduateKinder atomically moves an output at the provided height into the\n// graduated status. This involves removing the kindergarten entries from both\n// the height and channel indexes. The height bucket will be opportunistically\n// pruned from the height index as outputs are removed.",
      "length": 3336,
      "tokens": 495,
      "embedding": []
    },
    {
      "slug": "func (ns *NurseryStore) GraduateKinder(height uint32, kid *kidOutput) error {",
      "content": "func (ns *NurseryStore) GraduateKinder(height uint32, kid *kidOutput) error {\n\treturn kvdb.Update(ns.db, func(tx kvdb.RwTx) error {\n\t\thghtBucket := ns.getHeightBucket(tx, height)\n\t\tif hghtBucket == nil {\n\t\t\t// Nothing to delete, bucket has already been removed.\n\t\t\treturn nil\n\t\t}\n\n\t\t// For the kindergarten output, delete its entry from the\n\t\t// height and channel index, and create a new grad output in the\n\t\t// channel index.\n\t\toutpoint := kid.OutPoint()\n\t\tchanPoint := kid.OriginChanPoint()\n\n\t\t// Construct the key under which the output is\n\t\t// currently stored height and channel indexes.\n\t\tpfxOutputKey, err := prefixOutputKey(kndrPrefix,\n\t\t\toutpoint)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Remove the grad output's entry in the height\n\t\t// index.\n\t\terr = ns.removeOutputFromHeight(tx, height,\n\t\t\tchanPoint, pfxOutputKey)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tchanBucket := ns.getChannelBucketWrite(tx, chanPoint)\n\t\tif chanBucket == nil {\n\t\t\treturn ErrContractNotFound\n\t\t}\n\n\t\t// Remove previous output with kindergarten\n\t\t// prefix.\n\t\terr = chanBucket.Delete(pfxOutputKey)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Convert kindergarten key to graduate key.\n\t\tcopy(pfxOutputKey, gradPrefix)\n\n\t\tvar gradBuffer bytes.Buffer\n\t\tif err := kid.Encode(&gradBuffer); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Insert serialized output into channel bucket\n\t\t// using graduate-prefixed key.\n\t\treturn chanBucket.Put(pfxOutputKey,\n\t\t\tgradBuffer.Bytes())\n\t}, func() {})\n}\n\n// FetchClass returns a list of babyOutputs in the crib bucket whose CLTV\n// delay expires at the provided block height.\n// FetchClass returns a list of the kindergarten and crib outputs whose timeouts\n// are expiring",
      "length": 1543,
      "tokens": 222,
      "embedding": []
    },
    {
      "slug": "func (ns *NurseryStore) FetchClass(",
      "content": "func (ns *NurseryStore) FetchClass(\n\theight uint32) ([]kidOutput, []babyOutput, error) { // nolint:revive\n\n\t// Construct list of all crib and kindergarten outputs that need to be\n\t// processed at the provided block height.\n\tvar kids []kidOutput\n\tvar babies []babyOutput\n\tif err := kvdb.View(ns.db, func(tx kvdb.RTx) error {\n\t\t// Append each crib output to our list of babyOutputs.\n\t\tif err := ns.forEachHeightPrefix(tx, cribPrefix, height,\n\t\t\tfunc(buf []byte) error {\n\n\t\t\t\t// We will attempt to deserialize all outputs\n\t\t\t\t// stored with the crib prefix into babyOutputs,\n\t\t\t\t// since this is the expected type that would\n\t\t\t\t// have been serialized previously.\n\t\t\t\tvar baby babyOutput\n\t\t\t\tbabyReader := bytes.NewReader(buf)\n\t\t\t\tif err := baby.Decode(babyReader); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tbabies = append(babies, baby)\n\n\t\t\t\treturn nil\n\n\t\t\t},\n\t\t); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Append each kindergarten output to our list of kidOutputs.\n\t\treturn ns.forEachHeightPrefix(tx, kndrPrefix, height,\n\t\t\tfunc(buf []byte) error {\n\t\t\t\t// We will attempt to deserialize all outputs\n\t\t\t\t// stored with the kindergarten prefix into\n\t\t\t\t// kidOutputs, since this is the expected type\n\t\t\t\t// that would have been serialized previously.\n\t\t\t\tvar kid kidOutput\n\t\t\t\tkidReader := bytes.NewReader(buf)\n\t\t\t\tif err := kid.Decode(kidReader); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tkids = append(kids, kid)\n\n\t\t\t\treturn nil\n\n\t\t\t})\n\n\t}, func() {\n\t\tkids = nil\n\t\tbabies = nil\n\t}); err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn kids, babies, nil\n}\n\n// FetchPreschools returns a list of all outputs currently stored in the\n// preschool bucket.",
      "length": 1540,
      "tokens": 235,
      "embedding": []
    },
    {
      "slug": "func (ns *NurseryStore) FetchPreschools() ([]kidOutput, error) { // nolint:revive",
      "content": "func (ns *NurseryStore) FetchPreschools() ([]kidOutput, error) { // nolint:revive\n\tvar kids []kidOutput\n\tif err := kvdb.View(ns.db, func(tx kvdb.RTx) error {\n\t\t// Retrieve the existing chain bucket for this nursery store.\n\t\tchainBucket := tx.ReadBucket(ns.pfxChainKey)\n\t\tif chainBucket == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Load the existing channel index from the chain bucket.\n\t\tchanIndex := chainBucket.NestedReadBucket(channelIndexKey)\n\t\tif chanIndex == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Construct a list of all channels in the channel index that\n\t\t// are currently being tracked by the nursery store.\n\t\tvar activeChannels [][]byte\n\t\tif err := chanIndex.ForEach(func(chanBytes, _ []byte) error {\n\t\t\tactiveChannels = append(activeChannels, chanBytes)\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Iterate over all of the accumulated channels, and do a prefix\n\t\t// scan inside of each channel bucket. Each output found that\n\t\t// has a preschool prefix will be deserialized into a kidOutput,\n\t\t// and added to our list of preschool outputs to return to the\n\t\t// caller.\n\t\tfor _, chanBytes := range activeChannels {\n\t\t\t// Retrieve the channel bucket associated with this\n\t\t\t// channel.\n\t\t\tchanBucket := chanIndex.NestedReadBucket(chanBytes)\n\t\t\tif chanBucket == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// All of the outputs of interest will start with the\n\t\t\t// \"pscl\" prefix. So, we will perform a prefix scan of\n\t\t\t// the channel bucket to efficiently enumerate all the\n\t\t\t// desired outputs.\n\t\t\tc := chanBucket.ReadCursor()\n\t\t\tfor k, v := c.Seek(psclPrefix); bytes.HasPrefix(\n\t\t\t\tk, psclPrefix); k, v = c.Next() {\n\n\t\t\t\t// Deserialize each output as a kidOutput, since\n\t\t\t\t// this should have been the type that was\n\t\t\t\t// serialized when it was written to disk.\n\t\t\t\tvar psclOutput kidOutput\n\t\t\t\tpsclReader := bytes.NewReader(v)\n\t\t\t\terr := psclOutput.Decode(psclReader)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\t// Add the deserialized output to our list of\n\t\t\t\t// preschool outputs.\n\t\t\t\tkids = append(kids, psclOutput)\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}, func() {\n\t\tkids = nil\n\t}); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn kids, nil\n}\n\n// HeightsBelowOrEqual returns a slice of all non-empty heights in the height\n// index at or below the provided upper bound.",
      "length": 2096,
      "tokens": 327,
      "embedding": []
    },
    {
      "slug": "func (ns *NurseryStore) HeightsBelowOrEqual(height uint32) ([]uint32, error) {",
      "content": "func (ns *NurseryStore) HeightsBelowOrEqual(height uint32) ([]uint32, error) {\n\tvar activeHeights []uint32\n\terr := kvdb.View(ns.db, func(tx kvdb.RTx) error {\n\t\t// Ensure that the chain bucket for this nursery store exists.\n\t\tchainBucket := tx.ReadBucket(ns.pfxChainKey)\n\t\tif chainBucket == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Ensure that the height index has been properly initialized for this\n\t\t// chain.\n\t\thghtIndex := chainBucket.NestedReadBucket(heightIndexKey)\n\t\tif hghtIndex == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Serialize the provided height, as this will form the name of the\n\t\t// bucket.\n\t\tvar lower, upper [4]byte\n\t\tbyteOrder.PutUint32(upper[:], height)\n\n\t\tc := hghtIndex.ReadCursor()\n\t\tfor k, _ := c.Seek(lower[:]); bytes.Compare(k, upper[:]) <= 0 &&\n\t\t\tlen(k) == 4; k, _ = c.Next() {\n\n\t\t\tactiveHeights = append(activeHeights, byteOrder.Uint32(k))\n\t\t}\n\n\t\treturn nil\n\t}, func() {\n\t\tactiveHeights = nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn activeHeights, nil\n}\n\n// ForChanOutputs iterates over all outputs being incubated for a particular\n// channel point. This method accepts a callback that allows the caller to\n// process each key-value pair. The key will be a prefixed outpoint, and the\n// value will be the serialized bytes for an output, whose type should be\n// inferred from the key's prefix.\n// NOTE: The callback should not modify the provided byte slices and is\n// preferably non-blocking.",
      "length": 1288,
      "tokens": 200,
      "embedding": []
    },
    {
      "slug": "func (ns *NurseryStore) ForChanOutputs(chanPoint *wire.OutPoint,",
      "content": "func (ns *NurseryStore) ForChanOutputs(chanPoint *wire.OutPoint,\n\tcallback func([]byte, []byte) error, reset func()) error {\n\n\treturn kvdb.View(ns.db, func(tx kvdb.RTx) error {\n\t\treturn ns.forChanOutputs(tx, chanPoint, callback)\n\t}, reset)\n}\n\n// ListChannels returns all channels the nursery is currently tracking.",
      "length": 242,
      "tokens": 31,
      "embedding": []
    },
    {
      "slug": "func (ns *NurseryStore) ListChannels() ([]wire.OutPoint, error) {",
      "content": "func (ns *NurseryStore) ListChannels() ([]wire.OutPoint, error) {\n\tvar activeChannels []wire.OutPoint\n\tif err := kvdb.View(ns.db, func(tx kvdb.RTx) error {\n\t\t// Retrieve the existing chain bucket for this nursery store.\n\t\tchainBucket := tx.ReadBucket(ns.pfxChainKey)\n\t\tif chainBucket == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Retrieve the existing channel index.\n\t\tchanIndex := chainBucket.NestedReadBucket(channelIndexKey)\n\t\tif chanIndex == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn chanIndex.ForEach(func(chanBytes, _ []byte) error {\n\t\t\tvar chanPoint wire.OutPoint\n\t\t\terr := readOutpoint(bytes.NewReader(chanBytes), &chanPoint)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tactiveChannels = append(activeChannels, chanPoint)\n\n\t\t\treturn nil\n\t\t})\n\t}, func() {\n\t\tactiveChannels = nil\n\t}); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn activeChannels, nil\n}\n\n// IsMatureChannel determines the whether or not all of the outputs in a\n// particular channel bucket have been marked as graduated.",
      "length": 865,
      "tokens": 118,
      "embedding": []
    },
    {
      "slug": "func (ns *NurseryStore) IsMatureChannel(chanPoint *wire.OutPoint) (bool, error) {",
      "content": "func (ns *NurseryStore) IsMatureChannel(chanPoint *wire.OutPoint) (bool, error) {\n\terr := kvdb.View(ns.db, func(tx kvdb.RTx) error {\n\t\t// Iterate over the contents of the channel bucket, computing\n\t\t// both total number of outputs, and those that have the grad\n\t\t// prefix.\n\t\treturn ns.forChanOutputs(tx, chanPoint,\n\t\t\tfunc(pfxKey, _ []byte) error {\n\t\t\t\tif !bytes.HasPrefix(pfxKey, gradPrefix) {\n\t\t\t\t\treturn ErrImmatureChannel\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t})\n\n\t}, func() {})\n\tif err != nil && err != ErrImmatureChannel {\n\t\treturn false, err\n\t}\n\n\treturn err == nil, nil\n}\n\n// ErrImmatureChannel signals a channel cannot be removed because not all of its\n// outputs have graduated.\nvar ErrImmatureChannel = errors.New(\"cannot remove immature channel, \" +\n\t\"still has ungraduated outputs\")\n\n// RemoveChannel channel erases all entries from the channel bucket for the\n// provided channel point.\n// NOTE: The channel's entries in the height index are assumed to be removed.",
      "length": 854,
      "tokens": 131,
      "embedding": []
    },
    {
      "slug": "func (ns *NurseryStore) RemoveChannel(chanPoint *wire.OutPoint) error {",
      "content": "func (ns *NurseryStore) RemoveChannel(chanPoint *wire.OutPoint) error {\n\treturn kvdb.Update(ns.db, func(tx kvdb.RwTx) error {\n\t\t// Retrieve the existing chain bucket for this nursery store.\n\t\tchainBucket := tx.ReadWriteBucket(ns.pfxChainKey)\n\t\tif chainBucket == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Retrieve the channel index stored in the chain bucket.\n\t\tchanIndex := chainBucket.NestedReadWriteBucket(channelIndexKey)\n\t\tif chanIndex == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Serialize the provided channel point, such that we can delete\n\t\t// the mature channel bucket.\n\t\tvar chanBuffer bytes.Buffer\n\t\tif err := writeOutpoint(&chanBuffer, chanPoint); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tchanBytes := chanBuffer.Bytes()\n\n\t\terr := ns.forChanOutputs(tx, chanPoint, func(k, v []byte) error {\n\t\t\tif !bytes.HasPrefix(k, gradPrefix) {\n\t\t\t\treturn ErrImmatureChannel\n\t\t\t}\n\n\t\t\t// Construct a kindergarten prefixed key, since this\n\t\t\t// would have been the preceding state for a grad\n\t\t\t// output.\n\t\t\tkndrKey := make([]byte, len(k))\n\t\t\tcopy(kndrKey, k)\n\t\t\tcopy(kndrKey[:4], kndrPrefix)\n\n\t\t\t// Decode each to retrieve the output's maturity height.\n\t\t\tvar kid kidOutput\n\t\t\tif err := kid.Decode(bytes.NewReader(v)); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tmaturityHeight := kid.ConfHeight() + kid.BlocksToMaturity()\n\n\t\t\thghtBucket := ns.getHeightBucketWrite(tx, maturityHeight)\n\t\t\tif hghtBucket == nil {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\treturn removeBucketIfExists(hghtBucket, chanBytes)\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn removeBucketIfExists(chanIndex, chanBytes)\n\t}, func() {})\n}\n\n// Helper Methods\n\n// enterCrib accepts a new htlc output that the nursery will incubate through\n// its two-stage process of sweeping funds back to the user's wallet. These\n// outputs are persisted in the nursery store in the crib state, and will be\n// revisited after the first-stage output's CLTV has expired.",
      "length": 1734,
      "tokens": 238,
      "embedding": []
    },
    {
      "slug": "func (ns *NurseryStore) enterCrib(tx kvdb.RwTx, baby *babyOutput) error {",
      "content": "func (ns *NurseryStore) enterCrib(tx kvdb.RwTx, baby *babyOutput) error {\n\t// First, retrieve or create the channel bucket corresponding to the\n\t// baby output's origin channel point.\n\tchanPoint := baby.OriginChanPoint()\n\tchanBucket, err := ns.createChannelBucket(tx, chanPoint)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Since we are inserting this output into the crib bucket, we create a\n\t// key that prefixes the baby output's outpoint with the crib prefix.\n\tpfxOutputKey, err := prefixOutputKey(cribPrefix, baby.OutPoint())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// We'll first check that we don't already have an entry for this\n\t// output. If we do, then we can exit early.\n\tif rawBytes := chanBucket.Get(pfxOutputKey); rawBytes != nil {\n\t\treturn nil\n\t}\n\n\t// Next, retrieve or create the height-channel bucket located in the\n\t// height bucket corresponding to the baby output's CLTV expiry height.\n\n\t// TODO: Handle late registration.\n\thghtChanBucket, err := ns.createHeightChanBucket(tx,\n\t\tbaby.expiry, chanPoint)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Serialize the baby output so that it can be written to the\n\t// underlying key-value store.\n\tvar babyBuffer bytes.Buffer\n\tif err := baby.Encode(&babyBuffer); err != nil {\n\t\treturn err\n\t}\n\tbabyBytes := babyBuffer.Bytes()\n\n\t// Now, insert the serialized output into its channel bucket under the\n\t// prefixed key created above.\n\tif err := chanBucket.Put(pfxOutputKey, babyBytes); err != nil {\n\t\treturn err\n\t}\n\n\t// Finally, create a corresponding bucket in the height-channel bucket\n\t// for this crib output. The existence of this bucket indicates that\n\t// the serialized output can be retrieved from the channel bucket using\n\t// the same prefix key.\n\treturn hghtChanBucket.Put(pfxOutputKey, []byte{})\n}\n\n// enterPreschool accepts a new commitment output that the nursery will incubate\n// through a single stage before sweeping. Outputs are stored in the preschool\n// bucket until the commitment transaction has been confirmed, at which point\n// they will be moved to the kindergarten bucket.",
      "length": 1908,
      "tokens": 299,
      "embedding": []
    },
    {
      "slug": "func (ns *NurseryStore) enterPreschool(tx kvdb.RwTx, kid *kidOutput) error {",
      "content": "func (ns *NurseryStore) enterPreschool(tx kvdb.RwTx, kid *kidOutput) error {\n\t// First, retrieve or create the channel bucket corresponding to the\n\t// baby output's origin channel point.\n\tchanPoint := kid.OriginChanPoint()\n\tchanBucket, err := ns.createChannelBucket(tx, chanPoint)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Since the kidOutput is being inserted into the preschool bucket, we\n\t// create a key that prefixes its outpoint with the preschool prefix.\n\tpfxOutputKey, err := prefixOutputKey(psclPrefix, kid.OutPoint())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// We'll first check if an entry for this key is already stored. If so,\n\t// then we'll ignore this request, and return a nil error.\n\tif rawBytes := chanBucket.Get(pfxOutputKey); rawBytes != nil {\n\t\treturn nil\n\t}\n\n\t// Serialize the kidOutput and insert it into the channel bucket.\n\tvar kidBuffer bytes.Buffer\n\tif err := kid.Encode(&kidBuffer); err != nil {\n\t\treturn err\n\t}\n\n\treturn chanBucket.Put(pfxOutputKey, kidBuffer.Bytes())\n}\n\n// createChannelBucket creates or retrieves a channel bucket for the provided\n// channel point.",
      "length": 978,
      "tokens": 150,
      "embedding": []
    },
    {
      "slug": "func (ns *NurseryStore) createChannelBucket(tx kvdb.RwTx,",
      "content": "func (ns *NurseryStore) createChannelBucket(tx kvdb.RwTx,\n\tchanPoint *wire.OutPoint) (kvdb.RwBucket, error) {\n\n\t// Ensure that the chain bucket for this nursery store exists.\n\tchainBucket, err := tx.CreateTopLevelBucket(ns.pfxChainKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Ensure that the channel index has been properly initialized for this\n\t// chain.\n\tchanIndex, err := chainBucket.CreateBucketIfNotExists(channelIndexKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Serialize the provided channel point, as this provides the name of\n\t// the channel bucket of interest.\n\tvar chanBuffer bytes.Buffer\n\tif err := writeOutpoint(&chanBuffer, chanPoint); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Finally, create or retrieve the channel bucket using the serialized\n\t// key.\n\treturn chanIndex.CreateBucketIfNotExists(chanBuffer.Bytes())\n}\n\n// getChannelBucket retrieves an existing channel bucket from the nursery store,\n// using the given channel point.  If the bucket does not exist, or any bucket\n// along its path does not exist, a nil value is returned.",
      "length": 968,
      "tokens": 144,
      "embedding": []
    },
    {
      "slug": "func (ns *NurseryStore) getChannelBucket(tx kvdb.RTx,",
      "content": "func (ns *NurseryStore) getChannelBucket(tx kvdb.RTx,\n\tchanPoint *wire.OutPoint) kvdb.RBucket {\n\n\t// Retrieve the existing chain bucket for this nursery store.\n\tchainBucket := tx.ReadBucket(ns.pfxChainKey)\n\tif chainBucket == nil {\n\t\treturn nil\n\t}\n\n\t// Retrieve the existing channel index.\n\tchanIndex := chainBucket.NestedReadBucket(channelIndexKey)\n\tif chanIndex == nil {\n\t\treturn nil\n\t}\n\n\t// Serialize the provided channel point and return the bucket matching\n\t// the serialized key.\n\tvar chanBuffer bytes.Buffer\n\tif err := writeOutpoint(&chanBuffer, chanPoint); err != nil {\n\t\treturn nil\n\t}\n\n\treturn chanIndex.NestedReadBucket(chanBuffer.Bytes())\n}\n\n// getChannelBucketWrite retrieves an existing channel bucket from the nursery store,\n// using the given channel point.  If the bucket does not exist, or any bucket\n// along its path does not exist, a nil value is returned.",
      "length": 795,
      "tokens": 113,
      "embedding": []
    },
    {
      "slug": "func (ns *NurseryStore) getChannelBucketWrite(tx kvdb.RwTx,",
      "content": "func (ns *NurseryStore) getChannelBucketWrite(tx kvdb.RwTx,\n\tchanPoint *wire.OutPoint) kvdb.RwBucket {\n\n\t// Retrieve the existing chain bucket for this nursery store.\n\tchainBucket := tx.ReadWriteBucket(ns.pfxChainKey)\n\tif chainBucket == nil {\n\t\treturn nil\n\t}\n\n\t// Retrieve the existing channel index.\n\tchanIndex := chainBucket.NestedReadWriteBucket(channelIndexKey)\n\tif chanIndex == nil {\n\t\treturn nil\n\t}\n\n\t// Serialize the provided channel point and return the bucket matching\n\t// the serialized key.\n\tvar chanBuffer bytes.Buffer\n\tif err := writeOutpoint(&chanBuffer, chanPoint); err != nil {\n\t\treturn nil\n\t}\n\n\treturn chanIndex.NestedReadWriteBucket(chanBuffer.Bytes())\n}\n\n// createHeightBucket creates or retrieves an existing bucket from the height\n// index, corresponding to the provided height.",
      "length": 714,
      "tokens": 93,
      "embedding": []
    },
    {
      "slug": "func (ns *NurseryStore) createHeightBucket(tx kvdb.RwTx,",
      "content": "func (ns *NurseryStore) createHeightBucket(tx kvdb.RwTx,\n\theight uint32) (kvdb.RwBucket, error) {\n\n\t// Ensure that the chain bucket for this nursery store exists.\n\tchainBucket, err := tx.CreateTopLevelBucket(ns.pfxChainKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Ensure that the height index has been properly initialized for this\n\t// chain.\n\thghtIndex, err := chainBucket.CreateBucketIfNotExists(heightIndexKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Serialize the provided height, as this will form the name of the\n\t// bucket.\n\tvar heightBytes [4]byte\n\tbyteOrder.PutUint32(heightBytes[:], height)\n\n\t// Finally, create or retrieve the bucket in question.\n\treturn hghtIndex.CreateBucketIfNotExists(heightBytes[:])\n}\n\n// getHeightBucketPath retrieves an existing height bucket from the nursery\n// store, using the provided block height. If the bucket does not exist, or any\n// bucket along its path does not exist, a nil value is returned.",
      "length": 863,
      "tokens": 126,
      "embedding": []
    },
    {
      "slug": "func (ns *NurseryStore) getHeightBucketPath(tx kvdb.RTx,",
      "content": "func (ns *NurseryStore) getHeightBucketPath(tx kvdb.RTx,\n\theight uint32) (kvdb.RBucket, kvdb.RBucket) {\n\n\t// Retrieve the existing chain bucket for this nursery store.\n\tchainBucket := tx.ReadBucket(ns.pfxChainKey)\n\tif chainBucket == nil {\n\t\treturn nil, nil\n\t}\n\n\t// Retrieve the existing channel index.\n\thghtIndex := chainBucket.NestedReadBucket(heightIndexKey)\n\tif hghtIndex == nil {\n\t\treturn nil, nil\n\t}\n\n\t// Serialize the provided block height and return the bucket matching\n\t// the serialized key.\n\tvar heightBytes [4]byte\n\tbyteOrder.PutUint32(heightBytes[:], height)\n\n\treturn chainBucket, hghtIndex.NestedReadBucket(heightBytes[:])\n}\n\n// getHeightBucketPathWrite retrieves an existing height bucket from the nursery\n// store, using the provided block height. If the bucket does not exist, or any\n// bucket along its path does not exist, a nil value is returned.",
      "length": 784,
      "tokens": 107,
      "embedding": []
    },
    {
      "slug": "func (ns *NurseryStore) getHeightBucketPathWrite(tx kvdb.RwTx,",
      "content": "func (ns *NurseryStore) getHeightBucketPathWrite(tx kvdb.RwTx,\n\theight uint32) (kvdb.RwBucket, kvdb.RwBucket) {\n\n\t// Retrieve the existing chain bucket for this nursery store.\n\tchainBucket := tx.ReadWriteBucket(ns.pfxChainKey)\n\tif chainBucket == nil {\n\t\treturn nil, nil\n\t}\n\n\t// Retrieve the existing channel index.\n\thghtIndex := chainBucket.NestedReadWriteBucket(heightIndexKey)\n\tif hghtIndex == nil {\n\t\treturn nil, nil\n\t}\n\n\t// Serialize the provided block height and return the bucket matching\n\t// the serialized key.\n\tvar heightBytes [4]byte\n\tbyteOrder.PutUint32(heightBytes[:], height)\n\n\treturn hghtIndex, hghtIndex.NestedReadWriteBucket(\n\t\theightBytes[:],\n\t)\n}\n\n// getHeightBucket retrieves an existing height bucket from the nursery store,\n// using the provided block height. If the bucket does not exist, or any bucket\n// along its path does not exist, a nil value is returned.",
      "length": 794,
      "tokens": 109,
      "embedding": []
    },
    {
      "slug": "func (ns *NurseryStore) getHeightBucket(tx kvdb.RTx,",
      "content": "func (ns *NurseryStore) getHeightBucket(tx kvdb.RTx,\n\theight uint32) kvdb.RBucket {\n\n\t_, hghtBucket := ns.getHeightBucketPath(tx, height)\n\n\treturn hghtBucket\n}\n\n// getHeightBucketWrite retrieves an existing height bucket from the nursery store,\n// using the provided block height. If the bucket does not exist, or any bucket\n// along its path does not exist, a nil value is returned.",
      "length": 321,
      "tokens": 50,
      "embedding": []
    },
    {
      "slug": "func (ns *NurseryStore) getHeightBucketWrite(tx kvdb.RwTx,",
      "content": "func (ns *NurseryStore) getHeightBucketWrite(tx kvdb.RwTx,\n\theight uint32) kvdb.RwBucket {\n\n\t_, hghtBucket := ns.getHeightBucketPathWrite(tx, height)\n\n\treturn hghtBucket\n}\n\n// createHeightChanBucket creates or retrieves an existing height-channel bucket\n// for the provided block height and channel point. This method will attempt to\n// instantiate all buckets along the path if required.",
      "length": 320,
      "tokens": 44,
      "embedding": []
    },
    {
      "slug": "func (ns *NurseryStore) createHeightChanBucket(tx kvdb.RwTx,",
      "content": "func (ns *NurseryStore) createHeightChanBucket(tx kvdb.RwTx,\n\theight uint32, chanPoint *wire.OutPoint) (kvdb.RwBucket, error) {\n\n\t// Ensure that the height bucket for this nursery store exists.\n\thghtBucket, err := ns.createHeightBucket(tx, height)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Serialize the provided channel point, as this generates the name of\n\t// the subdirectory corresponding to the channel of interest.\n\tvar chanBuffer bytes.Buffer\n\tif err := writeOutpoint(&chanBuffer, chanPoint); err != nil {\n\t\treturn nil, err\n\t}\n\tchanBytes := chanBuffer.Bytes()\n\n\t// Finally, create or retrieve an existing height-channel bucket for\n\t// this channel point.\n\treturn hghtBucket.CreateBucketIfNotExists(chanBytes)\n}\n\n// getHeightChanBucketWrite retrieves an existing height-channel bucket from the\n// nursery store, using the provided block height and channel point. if the\n// bucket does not exist, or any bucket along its path does not exist, a nil\n// value is returned.",
      "length": 890,
      "tokens": 131,
      "embedding": []
    },
    {
      "slug": "func (ns *NurseryStore) getHeightChanBucketWrite(tx kvdb.RwTx,",
      "content": "func (ns *NurseryStore) getHeightChanBucketWrite(tx kvdb.RwTx,\n\theight uint32, chanPoint *wire.OutPoint) kvdb.RwBucket {\n\n\t// Retrieve the existing height bucket from this nursery store.\n\thghtBucket := ns.getHeightBucketWrite(tx, height)\n\tif hghtBucket == nil {\n\t\treturn nil\n\t}\n\n\t// Serialize the provided channel point, which generates the key for\n\t// looking up the proper height-channel bucket inside the height bucket.\n\tvar chanBuffer bytes.Buffer\n\tif err := writeOutpoint(&chanBuffer, chanPoint); err != nil {\n\t\treturn nil\n\t}\n\tchanBytes := chanBuffer.Bytes()\n\n\t// Finally, return the height bucket specified by the serialized channel\n\t// point.\n\treturn hghtBucket.NestedReadWriteBucket(chanBytes)\n}\n\n// forEachHeightPrefix enumerates all outputs at the given height whose state\n// prefix matches that which is provided. This is used as a subroutine to help\n// enumerate crib and kindergarten outputs at a particular height. The callback\n// is invoked with serialized bytes retrieved for each output of interest,\n// allowing the caller to deserialize them into the appropriate type.",
      "length": 998,
      "tokens": 145,
      "embedding": []
    },
    {
      "slug": "func (ns *NurseryStore) forEachHeightPrefix(tx kvdb.RTx, prefix []byte,",
      "content": "func (ns *NurseryStore) forEachHeightPrefix(tx kvdb.RTx, prefix []byte,\n\theight uint32, callback func([]byte) error) error {\n\n\t// Start by retrieving the height bucket corresponding to the provided\n\t// block height.\n\tchainBucket, hghtBucket := ns.getHeightBucketPath(tx, height)\n\tif hghtBucket == nil {\n\t\treturn nil\n\t}\n\n\t// Using the height bucket as a starting point, we will traverse its\n\t// entire two-tier directory structure, and filter for outputs that have\n\t// the provided prefix. The first layer of the height bucket contains\n\t// buckets identified by a channel point, thus we first create list of\n\t// channels contained in this height bucket.\n\tvar channelsAtHeight [][]byte\n\tif err := hghtBucket.ForEach(func(chanBytes, v []byte) error {\n\t\tif v == nil {\n\t\t\tchannelsAtHeight = append(channelsAtHeight, chanBytes)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\treturn err\n\t}\n\n\t// Additionally, grab the chain index, which we will facilitate queries\n\t// for each of the channel buckets of each of the channels in the list\n\t// we assembled above.\n\tchanIndex := chainBucket.NestedReadBucket(channelIndexKey)\n\tif chanIndex == nil {\n\t\treturn errors.New(\"unable to retrieve channel index\")\n\t}\n\n\t// Now, we are ready to enumerate all outputs with the desired prefix at\n\t// this block height. We do so by iterating over our list of channels at\n\t// this height, filtering for outputs in each height-channel bucket that\n\t// begin with the given prefix, and then retrieving the serialized\n\t// outputs from the appropriate channel bucket.\n\tfor _, chanBytes := range channelsAtHeight {\n\t\t// Retrieve the height-channel bucket for this channel, which\n\t\t// holds a sub-bucket for all outputs maturing at this height.\n\t\thghtChanBucket := hghtBucket.NestedReadBucket(chanBytes)\n\t\tif hghtChanBucket == nil {\n\t\t\treturn fmt.Errorf(\"unable to retrieve height-channel \"+\n\t\t\t\t\"bucket at height %d for %x\", height, chanBytes)\n\t\t}\n\n\t\t// Load the appropriate channel bucket from the channel index,\n\t\t// this will allow us to retrieve the individual serialized\n\t\t// outputs.\n\t\tchanBucket := chanIndex.NestedReadBucket(chanBytes)\n\t\tif chanBucket == nil {\n\t\t\treturn fmt.Errorf(\"unable to retrieve channel \"+\n\t\t\t\t\"bucket: '%x'\", chanBytes)\n\t\t}\n\n\t\t// Since all of the outputs of interest will start with the same\n\t\t// prefix, we will perform a prefix scan of the buckets\n\t\t// contained in the height-channel bucket, efficiently\n\t\t// enumerating the desired outputs.\n\t\tc := hghtChanBucket.ReadCursor()\n\t\tfor k, _ := c.Seek(prefix); bytes.HasPrefix(\n\t\t\tk, prefix); k, _ = c.Next() {\n\n\t\t\t// Use the prefix output key emitted from our scan to\n\t\t\t// load the serialized babyOutput from the appropriate\n\t\t\t// channel bucket.\n\t\t\toutputBytes := chanBucket.Get(k)\n\t\t\tif outputBytes == nil {\n\t\t\t\treturn errors.New(\"unable to retrieve output\")\n\t\t\t}\n\n\t\t\t// Present the serialized bytes to our call back\n\t\t\t// function, which is responsible for deserializing the\n\t\t\t// bytes into the appropriate type.\n\t\t\tif err := callback(outputBytes); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// forChanOutputs enumerates the outputs contained in a channel bucket to the\n// provided callback. The callback accepts a key-value pair of byte slices\n// corresponding to the prefixed-output key and the serialized output,\n// respectively.",
      "length": 3130,
      "tokens": 477,
      "embedding": []
    },
    {
      "slug": "func (ns *NurseryStore) forChanOutputs(tx kvdb.RTx, chanPoint *wire.OutPoint,",
      "content": "func (ns *NurseryStore) forChanOutputs(tx kvdb.RTx, chanPoint *wire.OutPoint,\n\tcallback func([]byte, []byte) error) error {\n\n\tchanBucket := ns.getChannelBucket(tx, chanPoint)\n\tif chanBucket == nil {\n\t\treturn ErrContractNotFound\n\t}\n\n\treturn chanBucket.ForEach(callback)\n}\n\n// errBucketNotEmpty signals that an attempt to prune a particular\n// bucket failed because it still has active outputs.\nvar errBucketNotEmpty = errors.New(\"bucket is not empty, cannot be pruned\")\n\n// removeOutputFromHeight will delete the given output from the specified\n// height-channel bucket, and attempt to prune the upstream directories if they\n// are empty.",
      "length": 543,
      "tokens": 75,
      "embedding": []
    },
    {
      "slug": "func (ns *NurseryStore) removeOutputFromHeight(tx kvdb.RwTx, height uint32,",
      "content": "func (ns *NurseryStore) removeOutputFromHeight(tx kvdb.RwTx, height uint32,\n\tchanPoint *wire.OutPoint, pfxKey []byte) error {\n\n\t// Retrieve the height-channel bucket and delete the prefixed output.\n\thghtChanBucket := ns.getHeightChanBucketWrite(tx, height, chanPoint)\n\tif hghtChanBucket == nil {\n\t\t// Height-channel bucket already removed.\n\t\treturn nil\n\t}\n\n\t// Try to delete the prefixed output from the target height-channel\n\t// bucket.\n\tif err := hghtChanBucket.Delete(pfxKey); err != nil {\n\t\treturn err\n\t}\n\n\t// Retrieve the height bucket that contains the height-channel bucket.\n\thghtBucket := ns.getHeightBucketWrite(tx, height)\n\tif hghtBucket == nil {\n\t\treturn errors.New(\"height bucket not found\")\n\t}\n\n\tvar chanBuffer bytes.Buffer\n\tif err := writeOutpoint(&chanBuffer, chanPoint); err != nil {\n\t\treturn err\n\t}\n\n\t// Try to remove the channel-height bucket if it this was the last\n\t// output in the bucket.\n\terr := removeBucketIfEmpty(hghtBucket, chanBuffer.Bytes())\n\tif err != nil && err != errBucketNotEmpty {\n\t\treturn err\n\t} else if err == errBucketNotEmpty {\n\t\treturn nil\n\t}\n\n\t// Attempt to prune the height bucket matching the kid output's\n\t// confirmation height in case that was the last height-chan bucket.\n\tpruned, err := ns.pruneHeight(tx, height)\n\tif err != nil && err != errBucketNotEmpty {\n\t\treturn err\n\t} else if err == nil && pruned {\n\t\tutxnLog.Infof(\"Height bucket %d pruned\", height)\n\t}\n\n\treturn nil\n}\n\n// pruneHeight removes the height bucket at the provided height if and only if\n// all active outputs at this height have been removed from their respective\n// height-channel buckets. The returned boolean value indicated whether or not\n// this invocation successfully pruned the height bucket.",
      "length": 1590,
      "tokens": 243,
      "embedding": []
    },
    {
      "slug": "func (ns *NurseryStore) pruneHeight(tx kvdb.RwTx, height uint32) (bool, error) {",
      "content": "func (ns *NurseryStore) pruneHeight(tx kvdb.RwTx, height uint32) (bool, error) {\n\t// Fetch the existing height index and height bucket.\n\thghtIndex, hghtBucket := ns.getHeightBucketPathWrite(tx, height)\n\tif hghtBucket == nil {\n\t\treturn false, nil\n\t}\n\n\t// Iterate over all channels stored at this block height. We will\n\t// attempt to remove each one if they are empty, keeping track of the\n\t// number of height-channel buckets that still have active outputs.\n\tif err := hghtBucket.ForEach(func(chanBytes, v []byte) error {\n\t\t// Skip the finalized txn key if it still exists from a previous\n\t\t// db version.\n\t\tif v != nil {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Attempt to each height-channel bucket from the height bucket\n\t\t// located above.\n\t\thghtChanBucket := hghtBucket.NestedReadWriteBucket(chanBytes)\n\t\tif hghtChanBucket == nil {\n\t\t\treturn errors.New(\"unable to find height-channel bucket\")\n\t\t}\n\n\t\treturn isBucketEmpty(hghtChanBucket)\n\n\t}); err != nil {\n\t\treturn false, err\n\t}\n\n\t// Serialize the provided block height, such that it can be used as the\n\t// key to delete desired height bucket.\n\tvar heightBytes [4]byte\n\tbyteOrder.PutUint32(heightBytes[:], height)\n\n\t// All of the height-channel buckets are empty or have been previously\n\t// removed, proceed by removing the height bucket\n\t// altogether.\n\tif err := removeBucketIfExists(hghtIndex, heightBytes[:]); err != nil {\n\t\treturn false, err\n\t}\n\n\treturn true, nil\n}\n\n// removeBucketIfEmpty attempts to delete a bucket specified by name from the\n// provided parent bucket.",
      "length": 1387,
      "tokens": 211,
      "embedding": []
    },
    {
      "slug": "func removeBucketIfEmpty(parent kvdb.RwBucket, bktName []byte) error {",
      "content": "func removeBucketIfEmpty(parent kvdb.RwBucket, bktName []byte) error {\n\t// Attempt to fetch the named bucket from its parent.\n\tbkt := parent.NestedReadWriteBucket(bktName)\n\tif bkt == nil {\n\t\t// No bucket was found, already removed?\n\t\treturn nil\n\t}\n\n\t// The bucket exists, fail if it still has children.\n\tif err := isBucketEmpty(bkt); err != nil {\n\t\treturn err\n\t}\n\n\treturn parent.DeleteNestedBucket(bktName)\n}\n\n// removeBucketIfExists safely deletes the named bucket by first checking\n// that it exists in the parent bucket.",
      "length": 436,
      "tokens": 70,
      "embedding": []
    },
    {
      "slug": "func removeBucketIfExists(parent kvdb.RwBucket, bktName []byte) error {",
      "content": "func removeBucketIfExists(parent kvdb.RwBucket, bktName []byte) error {\n\t// Attempt to fetch the named bucket from its parent.\n\tbkt := parent.NestedReadWriteBucket(bktName)\n\tif bkt == nil {\n\t\t// No bucket was found, already removed?\n\t\treturn nil\n\t}\n\n\treturn parent.DeleteNestedBucket(bktName)\n}\n\n// isBucketEmpty returns errBucketNotEmpty if the bucket has a non-zero number\n// of children.",
      "length": 307,
      "tokens": 45,
      "embedding": []
    },
    {
      "slug": "func isBucketEmpty(parent kvdb.RBucket) error {",
      "content": "func isBucketEmpty(parent kvdb.RBucket) error {\n\treturn parent.ForEach(func(_, _ []byte) error {\n\t\treturn errBucketNotEmpty\n\t})\n}\n\n// Compile-time constraint to ensure NurseryStore implements NurseryStorer.\nvar _ NurseryStorer = (*NurseryStore)(nil)\n",
      "length": 195,
      "tokens": 23,
      "embedding": []
    }
  ]
}