{
  "filepath": "../implementations/go/lnd/contractcourt/chain_arbitrator_test.go",
  "package": "contractcourt",
  "sections": [
    {
      "slug": "func TestChainArbitratorRepublishCloses(t *testing.T) {",
      "content": "func TestChainArbitratorRepublishCloses(t *testing.T) {\n\tt.Parallel()\n\n\tdb, err := channeldb.Open(t.TempDir())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, db.Close())\n\t})\n\n\t// Create 10 test channels and sync them to the database.\n\tconst numChans = 10\n\tvar channels []*channeldb.OpenChannel\n\tfor i := 0; i < numChans; i++ {\n\t\tlChannel, _, err := lnwallet.CreateTestChannels(\n\t\t\tt, channeldb.SingleFunderTweaklessBit,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tchannel := lChannel.State()\n\n\t\t// We manually set the db here to make sure all channels are\n\t\t// synced to the same db.\n\t\tchannel.Db = db.ChannelStateDB()\n\n\t\taddr := &net.TCPAddr{\n\t\t\tIP:   net.ParseIP(\"127.0.0.1\"),\n\t\t\tPort: 18556,\n\t\t}\n\t\tif err := channel.SyncPending(addr, 101); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tchannels = append(channels, channel)\n\t}\n\n\t// Mark half of the channels as commitment broadcasted.\n\tfor i := 0; i < numChans/2; i++ {\n\t\tcloseTx := channels[i].FundingTxn.Copy()\n\t\tcloseTx.TxIn[0].PreviousOutPoint = channels[i].FundingOutpoint\n\t\terr := channels[i].MarkCommitmentBroadcasted(closeTx, true)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\terr = channels[i].MarkCoopBroadcasted(closeTx, true)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\t// We keep track of the transactions published by the ChainArbitrator\n\t// at startup.\n\tpublished := make(map[chainhash.Hash]int)\n\n\tchainArbCfg := ChainArbitratorConfig{\n\t\tChainIO: &mock.ChainIO{},\n\t\tNotifier: &mock.ChainNotifier{\n\t\t\tSpendChan: make(chan *chainntnfs.SpendDetail),\n\t\t\tEpochChan: make(chan *chainntnfs.BlockEpoch),\n\t\t\tConfChan:  make(chan *chainntnfs.TxConfirmation),\n\t\t},\n\t\tPublishTx: func(tx *wire.MsgTx, _ string) error {\n\t\t\tpublished[tx.TxHash()]++\n\t\t\treturn nil\n\t\t},\n\t\tClock: clock.NewDefaultClock(),\n\t}\n\tchainArb := NewChainArbitrator(\n\t\tchainArbCfg, db,\n\t)\n\n\tif err := chainArb.Start(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, chainArb.Stop())\n\t})\n\n\t// Half of the channels should have had their closing tx re-published.\n\tif len(published) != numChans/2 {\n\t\tt.Fatalf(\"expected %d re-published transactions, got %d\",\n\t\t\tnumChans/2, len(published))\n\t}\n\n\t// And make sure the published transactions are correct, and unique.\n\tfor i := 0; i < numChans/2; i++ {\n\t\tcloseTx := channels[i].FundingTxn.Copy()\n\t\tcloseTx.TxIn[0].PreviousOutPoint = channels[i].FundingOutpoint\n\n\t\tcount, ok := published[closeTx.TxHash()]\n\t\tif !ok {\n\t\t\tt.Fatalf(\"closing tx not re-published\")\n\t\t}\n\n\t\t// We expect one coop close and one force close.\n\t\tif count != 2 {\n\t\t\tt.Fatalf(\"expected 2 closing txns, only got %d\", count)\n\t\t}\n\n\t\tdelete(published, closeTx.TxHash())\n\t}\n\n\tif len(published) != 0 {\n\t\tt.Fatalf(\"unexpected tx published\")\n\t}\n}\n\n// TestResolveContract tests that if we have an active channel being watched by\n// the chain arb, then a call to ResolveContract will mark the channel as fully\n// closed in the database, and also clean up all arbitrator state.",
      "length": 2772,
      "tokens": 365,
      "embedding": []
    },
    {
      "slug": "func TestResolveContract(t *testing.T) {",
      "content": "func TestResolveContract(t *testing.T) {\n\tt.Parallel()\n\n\tdb, err := channeldb.Open(t.TempDir())\n\trequire.NoError(t, err, \"unable to open db\")\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, db.Close())\n\t})\n\n\t// With the DB created, we'll make a new channel, and mark it as\n\t// pending open within the database.\n\tnewChannel, _, err := lnwallet.CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to make new test channel\")\n\tchannel := newChannel.State()\n\tchannel.Db = db.ChannelStateDB()\n\taddr := &net.TCPAddr{\n\t\tIP:   net.ParseIP(\"127.0.0.1\"),\n\t\tPort: 18556,\n\t}\n\tif err := channel.SyncPending(addr, 101); err != nil {\n\t\tt.Fatalf(\"unable to write channel to db: %v\", err)\n\t}\n\n\t// With the channel inserted into the database, we'll now create a new\n\t// chain arbitrator that should pick up these new channels and launch\n\t// resolver for them.\n\tchainArbCfg := ChainArbitratorConfig{\n\t\tChainIO: &mock.ChainIO{},\n\t\tNotifier: &mock.ChainNotifier{\n\t\t\tSpendChan: make(chan *chainntnfs.SpendDetail),\n\t\t\tEpochChan: make(chan *chainntnfs.BlockEpoch),\n\t\t\tConfChan:  make(chan *chainntnfs.TxConfirmation),\n\t\t},\n\t\tPublishTx: func(tx *wire.MsgTx, _ string) error {\n\t\t\treturn nil\n\t\t},\n\t\tClock: clock.NewDefaultClock(),\n\t}\n\tchainArb := NewChainArbitrator(\n\t\tchainArbCfg, db,\n\t)\n\tif err := chainArb.Start(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, chainArb.Stop())\n\t})\n\n\tchannelArb := chainArb.activeChannels[channel.FundingOutpoint]\n\n\t// While the resolver are active, we'll now remove the channel from the\n\t// database (mark is as closed).\n\terr = db.ChannelStateDB().AbandonChannel(&channel.FundingOutpoint, 4)\n\trequire.NoError(t, err, \"unable to remove channel\")\n\n\t// With the channel removed, we'll now manually call ResolveContract.\n\t// This stimulates needing to remove a channel from the chain arb due\n\t// to any possible external consistency issues.\n\terr = chainArb.ResolveContract(channel.FundingOutpoint)\n\trequire.NoError(t, err, \"unable to resolve contract\")\n\n\t// The shouldn't be an active chain watcher or channel arb for this\n\t// channel.\n\tif len(chainArb.activeChannels) != 0 {\n\t\tt.Fatalf(\"expected zero active channels, instead have %v\",\n\t\t\tlen(chainArb.activeChannels))\n\t}\n\tif len(chainArb.activeWatchers) != 0 {\n\t\tt.Fatalf(\"expected zero active watchers, instead have %v\",\n\t\t\tlen(chainArb.activeWatchers))\n\t}\n\n\t// At this point, the channel's arbitrator log should also be empty as\n\t// well.\n\t_, err = channelArb.log.FetchContractResolutions()\n\tif err != errScopeBucketNoExist {\n\t\tt.Fatalf(\"channel arb log state should have been \"+\n\t\t\t\"removed: %v\", err)\n\t}\n\n\t// If we attempt to call this method again, then we should get a nil\n\t// error, as there is no more state to be cleaned up.\n\terr = chainArb.ResolveContract(channel.FundingOutpoint)\n\trequire.NoError(t, err, \"second resolve call shouldn't fail\")\n}\n",
      "length": 2750,
      "tokens": 352,
      "embedding": []
    }
  ]
}