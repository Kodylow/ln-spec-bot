{
  "filepath": "../implementations/go/lnd/contractcourt/htlc_success_resolver_test.go",
  "package": "contractcourt",
  "sections": [
    {
      "slug": "type htlcResolverTestContext struct {",
      "content": "type htlcResolverTestContext struct {\n\tresolver ContractResolver\n\n\tcheckpoint func(_ ContractResolver,\n\t\t_ ...*channeldb.ResolverReport) error\n\n\tnotifier           *mock.ChainNotifier\n\tresolverResultChan chan resolveResult\n\tresolutionChan     chan ResolutionMsg\n\n\tfinalHtlcOutcomeStored bool\n\n\tt *testing.T\n}\n",
      "length": 258,
      "tokens": 21,
      "embedding": []
    },
    {
      "slug": "func newHtlcResolverTestContext(t *testing.T,",
      "content": "func newHtlcResolverTestContext(t *testing.T,\n\tnewResolver func(htlc channeldb.HTLC,\n\t\tcfg ResolverConfig) ContractResolver) *htlcResolverTestContext {\n\n\tnotifier := &mock.ChainNotifier{\n\t\tEpochChan: make(chan *chainntnfs.BlockEpoch, 1),\n\t\tSpendChan: make(chan *chainntnfs.SpendDetail, 1),\n\t\tConfChan:  make(chan *chainntnfs.TxConfirmation, 1),\n\t}\n\n\ttestCtx := &htlcResolverTestContext{\n\t\tcheckpoint:     nil,\n\t\tnotifier:       notifier,\n\t\tresolutionChan: make(chan ResolutionMsg, 1),\n\t\tt:              t,\n\t}\n\n\thtlcNotifier := &mockHTLCNotifier{}\n\n\twitnessBeacon := newMockWitnessBeacon()\n\tchainCfg := ChannelArbitratorConfig{\n\t\tChainArbitratorConfig: ChainArbitratorConfig{\n\t\t\tNotifier:   notifier,\n\t\t\tPreimageDB: witnessBeacon,\n\t\t\tPublishTx: func(_ *wire.MsgTx, _ string) error {\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\tSweeper: newMockSweeper(),\n\t\t\tIncubateOutputs: func(wire.OutPoint, *lnwallet.OutgoingHtlcResolution,\n\t\t\t\t*lnwallet.IncomingHtlcResolution, uint32) error {\n\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\tDeliverResolutionMsg: func(msgs ...ResolutionMsg) error {\n\t\t\t\tif len(msgs) != 1 {\n\t\t\t\t\treturn fmt.Errorf(\"expected 1 \"+\n\t\t\t\t\t\t\"resolution msg, instead got %v\",\n\t\t\t\t\t\tlen(msgs))\n\t\t\t\t}\n\n\t\t\t\ttestCtx.resolutionChan <- msgs[0]\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\tPutFinalHtlcOutcome: func(chanId lnwire.ShortChannelID,\n\t\t\t\thtlcId uint64, settled bool) error {\n\n\t\t\t\ttestCtx.finalHtlcOutcomeStored = true\n\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\tHtlcNotifier: htlcNotifier,\n\t\t},\n\t\tPutResolverReport: func(_ kvdb.RwTx,\n\t\t\treport *channeldb.ResolverReport) error {\n\n\t\t\treturn nil\n\t\t},\n\t}\n\t// Since we want to replace this checkpoint method later in the test,\n\t// we wrap the call to it in a closure. The linter will complain about\n\t// this so set nolint directive.\n\tcheckpointFunc := func(c ContractResolver, // nolint\n\t\tr ...*channeldb.ResolverReport) error {\n\n\t\treturn testCtx.checkpoint(c, r...)\n\t}\n\n\tcfg := ResolverConfig{\n\t\tChannelArbitratorConfig: chainCfg,\n\t\tCheckpoint:              checkpointFunc,\n\t}\n\n\thtlc := channeldb.HTLC{\n\t\tRHash:     testResHash,\n\t\tOnionBlob: testOnionBlob,\n\t\tAmt:       testHtlcAmt,\n\t}\n\n\ttestCtx.resolver = newResolver(htlc, cfg)\n\n\treturn testCtx\n}\n",
      "length": 2004,
      "tokens": 204,
      "embedding": []
    },
    {
      "slug": "func (i *htlcResolverTestContext) resolve() {",
      "content": "func (i *htlcResolverTestContext) resolve() {\n\t// Start resolver.\n\ti.resolverResultChan = make(chan resolveResult, 1)\n\tgo func() {\n\t\tnextResolver, err := i.resolver.Resolve()\n\t\ti.resolverResultChan <- resolveResult{\n\t\t\tnextResolver: nextResolver,\n\t\t\terr:          err,\n\t\t}\n\t}()\n}\n",
      "length": 224,
      "tokens": 25,
      "embedding": []
    },
    {
      "slug": "func (i *htlcResolverTestContext) waitForResult() {",
      "content": "func (i *htlcResolverTestContext) waitForResult() {\n\ti.t.Helper()\n\n\tresult := <-i.resolverResultChan\n\tif result.err != nil {\n\t\ti.t.Fatal(result.err)\n\t}\n\n\tif result.nextResolver != nil {\n\t\ti.t.Fatal(\"expected no next resolver\")\n\t}\n}\n\n// TestHtlcSuccessSingleStage tests successful sweep of a single stage htlc\n// claim.",
      "length": 253,
      "tokens": 34,
      "embedding": []
    },
    {
      "slug": "func TestHtlcSuccessSingleStage(t *testing.T) {",
      "content": "func TestHtlcSuccessSingleStage(t *testing.T) {\n\thtlcOutpoint := wire.OutPoint{Index: 3}\n\n\tsweepTx := &wire.MsgTx{\n\t\tTxIn:  []*wire.TxIn{{}},\n\t\tTxOut: []*wire.TxOut{{}},\n\t}\n\n\t// singleStageResolution is a resolution for a htlc on the remote\n\t// party's commitment.\n\tsingleStageResolution := lnwallet.IncomingHtlcResolution{\n\t\tSweepSignDesc: testSignDesc,\n\t\tClaimOutpoint: htlcOutpoint,\n\t}\n\n\tsweepTxid := sweepTx.TxHash()\n\tclaim := &channeldb.ResolverReport{\n\t\tOutPoint:        htlcOutpoint,\n\t\tAmount:          btcutil.Amount(testSignDesc.Output.Value),\n\t\tResolverType:    channeldb.ResolverTypeIncomingHtlc,\n\t\tResolverOutcome: channeldb.ResolverOutcomeClaimed,\n\t\tSpendTxID:       &sweepTxid,\n\t}\n\n\tcheckpoints := []checkpoint{\n\t\t{\n\t\t\t// We send a confirmation for our sweep tx to indicate\n\t\t\t// that our sweep succeeded.\n\t\t\tpreCheckpoint: func(ctx *htlcResolverTestContext,\n\t\t\t\t_ bool) error {\n\t\t\t\t// The resolver will create and publish a sweep\n\t\t\t\t// tx.\n\t\t\t\tresolver := ctx.resolver.(*htlcSuccessResolver)\n\t\t\t\tresolver.Sweeper.(*mockSweeper).\n\t\t\t\t\tcreateSweepTxChan <- sweepTx\n\n\t\t\t\t// Confirm the sweep, which should resolve it.\n\t\t\t\tctx.notifier.ConfChan <- &chainntnfs.TxConfirmation{\n\t\t\t\t\tTx:          sweepTx,\n\t\t\t\t\tBlockHeight: testInitialBlockHeight - 1,\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t},\n\n\t\t\t// After the sweep has confirmed, we expect the\n\t\t\t// checkpoint to be resolved, and with the above\n\t\t\t// report.\n\t\t\tresolved: true,\n\t\t\treports: []*channeldb.ResolverReport{\n\t\t\t\tclaim,\n\t\t\t},\n\t\t\tfinalHtlcStored: true,\n\t\t},\n\t}\n\n\ttestHtlcSuccess(\n\t\tt, singleStageResolution, checkpoints,\n\t)\n}\n\n// TestSecondStageResolution tests successful sweep of a second stage htlc\n// claim, going through the Nursery.",
      "length": 1586,
      "tokens": 169,
      "embedding": []
    },
    {
      "slug": "func TestHtlcSuccessSecondStageResolution(t *testing.T) {",
      "content": "func TestHtlcSuccessSecondStageResolution(t *testing.T) {\n\tcommitOutpoint := wire.OutPoint{Index: 2}\n\thtlcOutpoint := wire.OutPoint{Index: 3}\n\n\tsweepTx := &wire.MsgTx{\n\t\tTxIn:  []*wire.TxIn{{}},\n\t\tTxOut: []*wire.TxOut{{}},\n\t}\n\tsweepHash := sweepTx.TxHash()\n\n\t// twoStageResolution is a resolution for htlc on our own commitment\n\t// which is spent from the signed success tx.\n\ttwoStageResolution := lnwallet.IncomingHtlcResolution{\n\t\tPreimage: [32]byte{},\n\t\tSignedSuccessTx: &wire.MsgTx{\n\t\t\tTxIn: []*wire.TxIn{\n\t\t\t\t{\n\t\t\t\t\tPreviousOutPoint: commitOutpoint,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTxOut: []*wire.TxOut{\n\t\t\t\t{\n\t\t\t\t\tValue:    111,\n\t\t\t\t\tPkScript: []byte{0xaa, 0xaa},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tClaimOutpoint: htlcOutpoint,\n\t\tSweepSignDesc: testSignDesc,\n\t}\n\n\tsuccessTx := twoStageResolution.SignedSuccessTx.TxHash()\n\tfirstStage := &channeldb.ResolverReport{\n\t\tOutPoint:        commitOutpoint,\n\t\tAmount:          testHtlcAmt.ToSatoshis(),\n\t\tResolverType:    channeldb.ResolverTypeIncomingHtlc,\n\t\tResolverOutcome: channeldb.ResolverOutcomeFirstStage,\n\t\tSpendTxID:       &successTx,\n\t}\n\n\tsecondStage := &channeldb.ResolverReport{\n\t\tOutPoint:        htlcOutpoint,\n\t\tAmount:          btcutil.Amount(testSignDesc.Output.Value),\n\t\tResolverType:    channeldb.ResolverTypeIncomingHtlc,\n\t\tResolverOutcome: channeldb.ResolverOutcomeClaimed,\n\t\tSpendTxID:       &sweepHash,\n\t}\n\n\tcheckpoints := []checkpoint{\n\t\t{\n\t\t\t// The resolver will send the output to the Nursery.\n\t\t\tincubating: true,\n\t\t},\n\t\t{\n\t\t\t// It will then wait for the Nursery to spend the\n\t\t\t// output. We send a spend notification for our output\n\t\t\t// to resolve our htlc.\n\t\t\tpreCheckpoint: func(ctx *htlcResolverTestContext,\n\t\t\t\t_ bool) error {\n\n\t\t\t\tctx.notifier.SpendChan <- &chainntnfs.SpendDetail{\n\t\t\t\t\tSpendingTx:    sweepTx,\n\t\t\t\t\tSpenderTxHash: &sweepHash,\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\tincubating: true,\n\t\t\tresolved:   true,\n\t\t\treports: []*channeldb.ResolverReport{\n\t\t\t\tsecondStage,\n\t\t\t\tfirstStage,\n\t\t\t},\n\t\t\tfinalHtlcStored: true,\n\t\t},\n\t}\n\n\ttestHtlcSuccess(\n\t\tt, twoStageResolution, checkpoints,\n\t)\n}\n\n// TestHtlcSuccessSecondStageResolutionSweeper test that a resolver with\n// non-nil SignDetails will offer the second-level transaction to the sweeper\n// for re-signing.",
      "length": 2068,
      "tokens": 202,
      "embedding": []
    },
    {
      "slug": "func TestHtlcSuccessSecondStageResolutionSweeper(t *testing.T) {",
      "content": "func TestHtlcSuccessSecondStageResolutionSweeper(t *testing.T) {\n\tcommitOutpoint := wire.OutPoint{Index: 2}\n\thtlcOutpoint := wire.OutPoint{Index: 3}\n\n\tsuccessTx := &wire.MsgTx{\n\t\tTxIn: []*wire.TxIn{\n\t\t\t{\n\t\t\t\tPreviousOutPoint: commitOutpoint,\n\t\t\t},\n\t\t},\n\t\tTxOut: []*wire.TxOut{\n\t\t\t{\n\t\t\t\tValue:    123,\n\t\t\t\tPkScript: []byte{0xff, 0xff},\n\t\t\t},\n\t\t},\n\t}\n\n\treSignedSuccessTx := &wire.MsgTx{\n\t\tTxIn: []*wire.TxIn{\n\t\t\t{\n\t\t\t\tPreviousOutPoint: wire.OutPoint{\n\t\t\t\t\tHash:  chainhash.Hash{0xaa, 0xbb},\n\t\t\t\t\tIndex: 0,\n\t\t\t\t},\n\t\t\t},\n\t\t\tsuccessTx.TxIn[0],\n\t\t\t{\n\t\t\t\tPreviousOutPoint: wire.OutPoint{\n\t\t\t\t\tHash:  chainhash.Hash{0xaa, 0xbb},\n\t\t\t\t\tIndex: 2,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\n\t\tTxOut: []*wire.TxOut{\n\t\t\t{\n\t\t\t\tValue:    111,\n\t\t\t\tPkScript: []byte{0xaa, 0xaa},\n\t\t\t},\n\t\t\tsuccessTx.TxOut[0],\n\t\t},\n\t}\n\treSignedHash := successTx.TxHash()\n\n\tsweepTx := &wire.MsgTx{\n\t\tTxIn: []*wire.TxIn{\n\n\t\t\t{\n\t\t\t\tPreviousOutPoint: wire.OutPoint{\n\t\t\t\t\tHash:  reSignedHash,\n\t\t\t\t\tIndex: 1,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTxOut: []*wire.TxOut{{}},\n\t}\n\tsweepHash := sweepTx.TxHash()\n\n\t// twoStageResolution is a resolution for htlc on our own commitment\n\t// which is spent from the signed success tx.\n\ttwoStageResolution := lnwallet.IncomingHtlcResolution{\n\t\tPreimage:        [32]byte{},\n\t\tCsvDelay:        4,\n\t\tSignedSuccessTx: successTx,\n\t\tSignDetails: &input.SignDetails{\n\t\t\tSignDesc: testSignDesc,\n\t\t\tPeerSig:  testSig,\n\t\t},\n\t\tClaimOutpoint: htlcOutpoint,\n\t\tSweepSignDesc: testSignDesc,\n\t}\n\n\tfirstStage := &channeldb.ResolverReport{\n\t\tOutPoint:        commitOutpoint,\n\t\tAmount:          testHtlcAmt.ToSatoshis(),\n\t\tResolverType:    channeldb.ResolverTypeIncomingHtlc,\n\t\tResolverOutcome: channeldb.ResolverOutcomeFirstStage,\n\t\tSpendTxID:       &reSignedHash,\n\t}\n\n\tsecondStage := &channeldb.ResolverReport{\n\t\tOutPoint:        htlcOutpoint,\n\t\tAmount:          btcutil.Amount(testSignDesc.Output.Value),\n\t\tResolverType:    channeldb.ResolverTypeIncomingHtlc,\n\t\tResolverOutcome: channeldb.ResolverOutcomeClaimed,\n\t\tSpendTxID:       &sweepHash,\n\t}\n\n\tcheckpoints := []checkpoint{\n\t\t{\n\t\t\t// The HTLC output on the commitment should be offered\n\t\t\t// to the sweeper. We'll notify that it gets spent.\n\t\t\tpreCheckpoint: func(ctx *htlcResolverTestContext,\n\t\t\t\t_ bool) error {\n\n\t\t\t\tresolver := ctx.resolver.(*htlcSuccessResolver)\n\t\t\t\tinp := <-resolver.Sweeper.(*mockSweeper).sweptInputs\n\t\t\t\top := inp.OutPoint()\n\t\t\t\tif *op != commitOutpoint {\n\t\t\t\t\treturn fmt.Errorf(\"outpoint %v swept, \"+\n\t\t\t\t\t\t\"expected %v\", op,\n\t\t\t\t\t\tcommitOutpoint)\n\t\t\t\t}\n\n\t\t\t\tctx.notifier.SpendChan <- &chainntnfs.SpendDetail{\n\t\t\t\t\tSpendingTx:        reSignedSuccessTx,\n\t\t\t\t\tSpenderTxHash:     &reSignedHash,\n\t\t\t\t\tSpenderInputIndex: 1,\n\t\t\t\t\tSpendingHeight:    10,\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\t// incubating=true is used to signal that the\n\t\t\t// second-level transaction was confirmed.\n\t\t\tincubating: true,\n\t\t},\n\t\t{\n\t\t\t// The resolver will wait for the second-level's CSV\n\t\t\t// lock to expire.\n\t\t\tpreCheckpoint: func(ctx *htlcResolverTestContext,\n\t\t\t\tresumed bool) error {\n\n\t\t\t\t// If we are resuming from a checkpoint, we\n\t\t\t\t// expect the resolver to re-subscribe to a\n\t\t\t\t// spend, hence we must resend it.\n\t\t\t\tif resumed {\n\t\t\t\t\tctx.notifier.SpendChan <- &chainntnfs.SpendDetail{\n\t\t\t\t\t\tSpendingTx:        reSignedSuccessTx,\n\t\t\t\t\t\tSpenderTxHash:     &reSignedHash,\n\t\t\t\t\t\tSpenderInputIndex: 1,\n\t\t\t\t\t\tSpendingHeight:    10,\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tctx.notifier.EpochChan <- &chainntnfs.BlockEpoch{\n\t\t\t\t\tHeight: 13,\n\t\t\t\t}\n\n\t\t\t\t// We expect it to sweep the second-level\n\t\t\t\t// transaction we notfied about above.\n\t\t\t\tresolver := ctx.resolver.(*htlcSuccessResolver)\n\t\t\t\tinp := <-resolver.Sweeper.(*mockSweeper).sweptInputs\n\t\t\t\top := inp.OutPoint()\n\t\t\t\texp := wire.OutPoint{\n\t\t\t\t\tHash:  reSignedHash,\n\t\t\t\t\tIndex: 1,\n\t\t\t\t}\n\t\t\t\tif *op != exp {\n\t\t\t\t\treturn fmt.Errorf(\"swept outpoint %v, expected %v\",\n\t\t\t\t\t\top, exp)\n\t\t\t\t}\n\n\t\t\t\t// Notify about the spend, which should resolve\n\t\t\t\t// the resolver.\n\t\t\t\tctx.notifier.SpendChan <- &chainntnfs.SpendDetail{\n\t\t\t\t\tSpendingTx:     sweepTx,\n\t\t\t\t\tSpenderTxHash:  &sweepHash,\n\t\t\t\t\tSpendingHeight: 14,\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t},\n\n\t\t\tincubating: true,\n\t\t\tresolved:   true,\n\t\t\treports: []*channeldb.ResolverReport{\n\t\t\t\tsecondStage,\n\t\t\t\tfirstStage,\n\t\t\t},\n\t\t\tfinalHtlcStored: true,\n\t\t},\n\t}\n\n\ttestHtlcSuccess(t, twoStageResolution, checkpoints)\n}\n\n// checkpoint holds expected data we expect the resolver to checkpoint itself\n// to the DB next.",
      "length": 4122,
      "tokens": 417,
      "embedding": []
    },
    {
      "slug": "type checkpoint struct {",
      "content": "type checkpoint struct {\n\t// preCheckpoint is a method that will be called before we reach the\n\t// checkpoint, to carry out any needed operations to drive the resolver\n\t// in this stage.\n\tpreCheckpoint func(*htlcResolverTestContext, bool) error\n\n\t// data we expect the resolver to be checkpointed with next.\n\tincubating      bool\n\tresolved        bool\n\treports         []*channeldb.ResolverReport\n\tfinalHtlcStored bool\n}\n\n// testHtlcSuccess tests resolution of a success resolver. It takes a a list of\n// checkpoints that it expects the resolver to go through. And will run the\n// resolver all the way through these checkpoints, and also attempt to resume\n// the resolver from every checkpoint.",
      "length": 654,
      "tokens": 100,
      "embedding": []
    },
    {
      "slug": "func testHtlcSuccess(t *testing.T, resolution lnwallet.IncomingHtlcResolution,",
      "content": "func testHtlcSuccess(t *testing.T, resolution lnwallet.IncomingHtlcResolution,\n\tcheckpoints []checkpoint) {\n\n\tdefer timeout()()\n\n\t// We first run the resolver from start to finish, ensuring it gets\n\t// checkpointed at every expected stage. We store the checkpointed data\n\t// for the next portion of the test.\n\tctx := newHtlcResolverTestContext(t,\n\t\tfunc(htlc channeldb.HTLC, cfg ResolverConfig) ContractResolver {\n\t\t\treturn &htlcSuccessResolver{\n\t\t\t\tcontractResolverKit: *newContractResolverKit(cfg),\n\t\t\t\thtlc:                htlc,\n\t\t\t\thtlcResolution:      resolution,\n\t\t\t}\n\t\t},\n\t)\n\n\tcheckpointedState := runFromCheckpoint(t, ctx, checkpoints)\n\n\t// Now, from every checkpoint created, we re-create the resolver, and\n\t// run the test from that checkpoint.\n\tfor i := range checkpointedState {\n\t\tcp := bytes.NewReader(checkpointedState[i])\n\t\tctx := newHtlcResolverTestContext(t,\n\t\t\tfunc(htlc channeldb.HTLC, cfg ResolverConfig) ContractResolver {\n\t\t\t\tresolver, err := newSuccessResolverFromReader(cp, cfg)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\n\t\t\t\tresolver.Supplement(htlc)\n\t\t\t\tresolver.htlcResolution = resolution\n\t\t\t\treturn resolver\n\t\t\t},\n\t\t)\n\n\t\t// Run from the given checkpoint, ensuring we'll hit the rest.\n\t\t_ = runFromCheckpoint(t, ctx, checkpoints[i+1:])\n\t}\n}\n\n// runFromCheckpoint executes the Resolve method on the success resolver, and\n// asserts that it checkpoints itself according to the expected checkpoints.",
      "length": 1305,
      "tokens": 158,
      "embedding": []
    },
    {
      "slug": "func runFromCheckpoint(t *testing.T, ctx *htlcResolverTestContext,",
      "content": "func runFromCheckpoint(t *testing.T, ctx *htlcResolverTestContext,\n\texpectedCheckpoints []checkpoint) [][]byte {\n\n\tdefer timeout()()\n\n\tvar checkpointedState [][]byte\n\n\t// Replace our checkpoint method with one which we'll use to assert the\n\t// checkpointed state and reports are equal to what we expect.\n\tnextCheckpoint := 0\n\tcheckpointChan := make(chan struct{})\n\tctx.checkpoint = func(resolver ContractResolver,\n\t\treports ...*channeldb.ResolverReport) error {\n\n\t\tif nextCheckpoint >= len(expectedCheckpoints) {\n\t\t\tt.Fatal(\"did not expect more checkpoints\")\n\t\t}\n\n\t\tvar resolved, incubating bool\n\t\tif h, ok := resolver.(*htlcSuccessResolver); ok {\n\t\t\tresolved = h.resolved\n\t\t\tincubating = h.outputIncubating\n\t\t}\n\t\tif h, ok := resolver.(*htlcTimeoutResolver); ok {\n\t\t\tresolved = h.resolved\n\t\t\tincubating = h.outputIncubating\n\t\t}\n\n\t\tcp := expectedCheckpoints[nextCheckpoint]\n\n\t\tif resolved != cp.resolved {\n\t\t\tt.Fatalf(\"expected checkpoint to be resolve=%v, had %v\",\n\t\t\t\tcp.resolved, resolved)\n\t\t}\n\n\t\tif !reflect.DeepEqual(incubating, cp.incubating) {\n\t\t\tt.Fatalf(\"expected checkpoint to be have \"+\n\t\t\t\t\"incubating=%v, had %v\", cp.incubating,\n\t\t\t\tincubating)\n\t\t}\n\n\t\t// Check we go the expected reports.\n\t\tif len(reports) != len(cp.reports) {\n\t\t\tt.Fatalf(\"unexpected number of reports. Expected %v \"+\n\t\t\t\t\"got %v\", len(cp.reports), len(reports))\n\t\t}\n\n\t\tfor i, report := range reports {\n\t\t\tif !reflect.DeepEqual(report, cp.reports[i]) {\n\t\t\t\tt.Fatalf(\"expected: %v, got: %v\",\n\t\t\t\t\tspew.Sdump(cp.reports[i]),\n\t\t\t\t\tspew.Sdump(report))\n\t\t\t}\n\t\t}\n\n\t\t// Check that the final htlc outcome is stored.\n\t\tif cp.finalHtlcStored != ctx.finalHtlcOutcomeStored {\n\t\t\tt.Fatal(\"final htlc store expectation failed\")\n\t\t}\n\n\t\t// Finally encode the resolver, and store it for later use.\n\t\tb := bytes.Buffer{}\n\t\tif err := resolver.Encode(&b); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tcheckpointedState = append(checkpointedState, b.Bytes())\n\t\tnextCheckpoint++\n\t\tcheckpointChan <- struct{}{}\n\t\treturn nil\n\t}\n\n\t// Start the htlc success resolver.\n\tctx.resolve()\n\n\t// Go through our list of expected checkpoints, so we can run the\n\t// preCheckpoint logic if needed.\n\tresumed := true\n\tfor i, cp := range expectedCheckpoints {\n\t\tif cp.preCheckpoint != nil {\n\t\t\tif err := cp.preCheckpoint(ctx, resumed); err != nil {\n\t\t\t\tt.Fatalf(\"failure at stage %d: %v\", i, err)\n\t\t\t}\n\t\t}\n\t\tresumed = false\n\n\t\t// Wait for the resolver to have checkpointed its state.\n\t\t<-checkpointChan\n\t}\n\n\t// Wait for the resolver to fully complete.\n\tctx.waitForResult()\n\n\tif nextCheckpoint < len(expectedCheckpoints) {\n\t\tt.Fatalf(\"not all checkpoints hit\")\n\t}\n\n\treturn checkpointedState\n}\n",
      "length": 2457,
      "tokens": 318,
      "embedding": []
    }
  ]
}