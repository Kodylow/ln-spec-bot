{
  "filepath": "../implementations/go/lnd/contractcourt/chain_watcher_test.go",
  "package": "contractcourt",
  "sections": [
    {
      "slug": "func TestChainWatcherRemoteUnilateralClose(t *testing.T) {",
      "content": "func TestChainWatcherRemoteUnilateralClose(t *testing.T) {\n\tt.Parallel()\n\n\t// First, we'll create two channels which already have established a\n\t// commitment contract between themselves.\n\taliceChannel, bobChannel, err := lnwallet.CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// With the channels created, we'll now create a chain watcher instance\n\t// which will be watching for any closes of Alice's channel.\n\taliceNotifier := &mock.ChainNotifier{\n\t\tSpendChan: make(chan *chainntnfs.SpendDetail),\n\t\tEpochChan: make(chan *chainntnfs.BlockEpoch),\n\t\tConfChan:  make(chan *chainntnfs.TxConfirmation),\n\t}\n\taliceChainWatcher, err := newChainWatcher(chainWatcherConfig{\n\t\tchanState:           aliceChannel.State(),\n\t\tnotifier:            aliceNotifier,\n\t\tsigner:              aliceChannel.Signer,\n\t\textractStateNumHint: lnwallet.GetStateNumHint,\n\t})\n\trequire.NoError(t, err, \"unable to create chain watcher\")\n\terr = aliceChainWatcher.Start()\n\trequire.NoError(t, err, \"unable to start chain watcher\")\n\tdefer aliceChainWatcher.Stop()\n\n\t// We'll request a new channel event subscription from Alice's chain\n\t// watcher.\n\tchanEvents := aliceChainWatcher.SubscribeChannelEvents()\n\n\t// If we simulate an immediate broadcast of the current commitment by\n\t// Bob, then the chain watcher should detect this case.\n\tbobCommit := bobChannel.State().LocalCommitment.CommitTx\n\tbobTxHash := bobCommit.TxHash()\n\tbobSpend := &chainntnfs.SpendDetail{\n\t\tSpenderTxHash: &bobTxHash,\n\t\tSpendingTx:    bobCommit,\n\t}\n\taliceNotifier.SpendChan <- bobSpend\n\n\t// We should get a new spend event over the remote unilateral close\n\t// event channel.\n\tvar uniClose *RemoteUnilateralCloseInfo\n\tselect {\n\tcase uniClose = <-chanEvents.RemoteUnilateralClosure:\n\tcase <-time.After(time.Second * 15):\n\t\tt.Fatalf(\"didn't receive unilateral close event\")\n\t}\n\n\t// The unilateral close should have properly located Alice's output in\n\t// the commitment transaction.\n\tif uniClose.CommitResolution == nil {\n\t\tt.Fatalf(\"unable to find alice's commit resolution\")\n\t}\n}\n",
      "length": 1980,
      "tokens": 218,
      "embedding": []
    },
    {
      "slug": "func addFakeHTLC(t *testing.T, htlcAmount lnwire.MilliSatoshi, id uint64,",
      "content": "func addFakeHTLC(t *testing.T, htlcAmount lnwire.MilliSatoshi, id uint64,\n\taliceChannel, bobChannel *lnwallet.LightningChannel) {\n\n\tpreimage := bytes.Repeat([]byte{byte(id)}, 32)\n\tpaymentHash := sha256.Sum256(preimage)\n\tvar returnPreimage [32]byte\n\tcopy(returnPreimage[:], preimage)\n\thtlc := &lnwire.UpdateAddHTLC{\n\t\tID:          uint64(id),\n\t\tPaymentHash: paymentHash,\n\t\tAmount:      htlcAmount,\n\t\tExpiry:      uint32(5),\n\t}\n\n\tif _, err := aliceChannel.AddHTLC(htlc, nil); err != nil {\n\t\tt.Fatalf(\"alice unable to add htlc: %v\", err)\n\t}\n\tif _, err := bobChannel.ReceiveHTLC(htlc); err != nil {\n\t\tt.Fatalf(\"bob unable to recv add htlc: %v\", err)\n\t}\n}\n\n// TestChainWatcherRemoteUnilateralClosePendingCommit tests that the chain\n// watcher is able to properly detect a unilateral close wherein the remote\n// node broadcasts their newly received commitment, without first revoking the\n// old one.",
      "length": 795,
      "tokens": 98,
      "embedding": []
    },
    {
      "slug": "func TestChainWatcherRemoteUnilateralClosePendingCommit(t *testing.T) {",
      "content": "func TestChainWatcherRemoteUnilateralClosePendingCommit(t *testing.T) {\n\tt.Parallel()\n\n\t// First, we'll create two channels which already have established a\n\t// commitment contract between themselves.\n\taliceChannel, bobChannel, err := lnwallet.CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// With the channels created, we'll now create a chain watcher instance\n\t// which will be watching for any closes of Alice's channel.\n\taliceNotifier := &mock.ChainNotifier{\n\t\tSpendChan: make(chan *chainntnfs.SpendDetail),\n\t\tEpochChan: make(chan *chainntnfs.BlockEpoch),\n\t\tConfChan:  make(chan *chainntnfs.TxConfirmation),\n\t}\n\taliceChainWatcher, err := newChainWatcher(chainWatcherConfig{\n\t\tchanState:           aliceChannel.State(),\n\t\tnotifier:            aliceNotifier,\n\t\tsigner:              aliceChannel.Signer,\n\t\textractStateNumHint: lnwallet.GetStateNumHint,\n\t})\n\trequire.NoError(t, err, \"unable to create chain watcher\")\n\tif err := aliceChainWatcher.Start(); err != nil {\n\t\tt.Fatalf(\"unable to start chain watcher: %v\", err)\n\t}\n\tdefer aliceChainWatcher.Stop()\n\n\t// We'll request a new channel event subscription from Alice's chain\n\t// watcher.\n\tchanEvents := aliceChainWatcher.SubscribeChannelEvents()\n\n\t// Next, we'll create a fake HTLC just so we can advance Alice's\n\t// channel state to a new pending commitment on her remote commit chain\n\t// for Bob.\n\thtlcAmount := lnwire.NewMSatFromSatoshis(20000)\n\taddFakeHTLC(t, htlcAmount, 0, aliceChannel, bobChannel)\n\n\t// With the HTLC added, we'll now manually initiate a state transition\n\t// from Alice to Bob.\n\t_, _, _, err = aliceChannel.SignNextCommitment()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// At this point, we'll now Bob broadcasting this new pending unrevoked\n\t// commitment.\n\tbobPendingCommit, err := aliceChannel.State().RemoteCommitChainTip()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// We'll craft a fake spend notification with Bob's actual commitment.\n\t// The chain watcher should be able to detect that this is a pending\n\t// commit broadcast based on the state hints in the commitment.\n\tbobCommit := bobPendingCommit.Commitment.CommitTx\n\tbobTxHash := bobCommit.TxHash()\n\tbobSpend := &chainntnfs.SpendDetail{\n\t\tSpenderTxHash: &bobTxHash,\n\t\tSpendingTx:    bobCommit,\n\t}\n\taliceNotifier.SpendChan <- bobSpend\n\n\t// We should get a new spend event over the remote unilateral close\n\t// event channel.\n\tvar uniClose *RemoteUnilateralCloseInfo\n\tselect {\n\tcase uniClose = <-chanEvents.RemoteUnilateralClosure:\n\tcase <-time.After(time.Second * 15):\n\t\tt.Fatalf(\"didn't receive unilateral close event\")\n\t}\n\n\t// The unilateral close should have properly located Alice's output in\n\t// the commitment transaction.\n\tif uniClose.CommitResolution == nil {\n\t\tt.Fatalf(\"unable to find alice's commit resolution\")\n\t}\n}\n\n// dlpTestCase is a special struct that we'll use to generate randomized test\n// cases for the main TestChainWatcherDataLossProtect test. This struct has a\n// special Generate method that will generate a random state number, and a\n// broadcast state number which is greater than that state number.",
      "length": 2975,
      "tokens": 378,
      "embedding": []
    },
    {
      "slug": "type dlpTestCase struct {",
      "content": "type dlpTestCase struct {\n\tBroadcastStateNum uint8\n\tNumUpdates        uint8\n}\n\n// executeStateTransitions execute the given number of state transitions.\n// Copies of Alice's channel state before each transition (including initial\n// state) are returned.",
      "length": 221,
      "tokens": 29,
      "embedding": []
    },
    {
      "slug": "func executeStateTransitions(t *testing.T, htlcAmount lnwire.MilliSatoshi,",
      "content": "func executeStateTransitions(t *testing.T, htlcAmount lnwire.MilliSatoshi,\n\taliceChannel, bobChannel *lnwallet.LightningChannel,\n\tnumUpdates uint8) ([]*channeldb.OpenChannel, error) {\n\n\t// We'll make a copy of the channel state before each transition.\n\tvar (\n\t\tchanStates []*channeldb.OpenChannel\n\t)\n\n\tstate, err := copyChannelState(t, aliceChannel.State())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tchanStates = append(chanStates, state)\n\n\tfor i := 0; i < int(numUpdates); i++ {\n\t\taddFakeHTLC(\n\t\t\tt, htlcAmount, uint64(i), aliceChannel, bobChannel,\n\t\t)\n\n\t\terr := lnwallet.ForceStateTransition(aliceChannel, bobChannel)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tstate, err := copyChannelState(t, aliceChannel.State())\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tchanStates = append(chanStates, state)\n\t}\n\n\treturn chanStates, nil\n}\n\n// TestChainWatcherDataLossProtect tests that if we've lost data (and are\n// behind the remote node), then we'll properly detect this case and dispatch a\n// remote force close using the obtained data loss commitment point.",
      "length": 941,
      "tokens": 130,
      "embedding": []
    },
    {
      "slug": "func TestChainWatcherDataLossProtect(t *testing.T) {",
      "content": "func TestChainWatcherDataLossProtect(t *testing.T) {\n\tt.Parallel()\n\n\t// dlpScenario is our primary quick check testing function for this\n\t// test as whole. It ensures that if the remote party broadcasts a\n\t// commitment that is beyond our best known commitment for them, and\n\t// they don't have a pending commitment (one we sent but which hasn't\n\t// been revoked), then we'll properly detect this case, and execute the\n\t// DLP protocol on our end.\n\t//\n\t// broadcastStateNum is the number that we'll trick Alice into thinking\n\t// was broadcast, while numUpdates is the actual number of updates\n\t// we'll execute. Both of these will be random 8-bit values generated\n\t// by testing/quick.\n\tdlpScenario := func(t *testing.T, testCase dlpTestCase) bool {\n\t\t// First, we'll create two channels which already have\n\t\t// established a commitment contract between themselves.\n\t\taliceChannel, bobChannel, err := lnwallet.CreateTestChannels(\n\t\t\tt, channeldb.SingleFunderBit,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to create test channels: %v\", err)\n\t\t}\n\n\t\t// Based on the number of random updates for this state, make a\n\t\t// new HTLC to add to the commitment, and then lock in a state\n\t\t// transition.\n\t\tconst htlcAmt = 1000\n\t\tstates, err := executeStateTransitions(\n\t\t\tt, htlcAmt, aliceChannel, bobChannel,\n\t\t\ttestCase.BroadcastStateNum,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"unable to trigger state \"+\n\t\t\t\t\"transition: %v\", err)\n\t\t\treturn false\n\t\t}\n\n\t\t// We'll use the state this test case wants Alice to start at.\n\t\taliceChanState := states[testCase.NumUpdates]\n\n\t\t// With the channels created, we'll now create a chain watcher\n\t\t// instance which will be watching for any closes of Alice's\n\t\t// channel.\n\t\taliceNotifier := &mock.ChainNotifier{\n\t\t\tSpendChan: make(chan *chainntnfs.SpendDetail),\n\t\t\tEpochChan: make(chan *chainntnfs.BlockEpoch),\n\t\t\tConfChan:  make(chan *chainntnfs.TxConfirmation),\n\t\t}\n\t\taliceChainWatcher, err := newChainWatcher(chainWatcherConfig{\n\t\t\tchanState: aliceChanState,\n\t\t\tnotifier:  aliceNotifier,\n\t\t\tsigner:    aliceChannel.Signer,\n\t\t\textractStateNumHint: func(*wire.MsgTx,\n\t\t\t\t[lnwallet.StateHintSize]byte) uint64 {\n\n\t\t\t\t// We'll return the \"fake\" broadcast commitment\n\t\t\t\t// number so we can simulate broadcast of an\n\t\t\t\t// arbitrary state.\n\t\t\t\treturn uint64(testCase.BroadcastStateNum)\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to create chain watcher: %v\", err)\n\t\t}\n\t\tif err := aliceChainWatcher.Start(); err != nil {\n\t\t\tt.Fatalf(\"unable to start chain watcher: %v\", err)\n\t\t}\n\t\tdefer aliceChainWatcher.Stop()\n\n\t\t// We'll request a new channel event subscription from Alice's\n\t\t// chain watcher so we can be notified of our fake close below.\n\t\tchanEvents := aliceChainWatcher.SubscribeChannelEvents()\n\n\t\t// Otherwise, we'll feed in this new state number as a response\n\t\t// to the query, and insert the expected DLP commit point.\n\t\tdlpPoint := aliceChannel.State().RemoteCurrentRevocation\n\t\terr = aliceChanState.MarkDataLoss(dlpPoint)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"unable to insert dlp point: %v\", err)\n\t\t\treturn false\n\t\t}\n\n\t\t// Now we'll trigger the channel close event to trigger the\n\t\t// scenario.\n\t\tbobCommit := bobChannel.State().LocalCommitment.CommitTx\n\t\tbobTxHash := bobCommit.TxHash()\n\t\tbobSpend := &chainntnfs.SpendDetail{\n\t\t\tSpenderTxHash: &bobTxHash,\n\t\t\tSpendingTx:    bobCommit,\n\t\t}\n\t\taliceNotifier.SpendChan <- bobSpend\n\n\t\t// We should get a new uni close resolution that indicates we\n\t\t// processed the DLP scenario.\n\t\tvar uniClose *RemoteUnilateralCloseInfo\n\t\tselect {\n\t\tcase uniClose = <-chanEvents.RemoteUnilateralClosure:\n\t\t\t// If we processed this as a DLP case, then the remote\n\t\t\t// party's commitment should be blank, as we don't have\n\t\t\t// this up to date state.\n\t\t\tblankCommit := channeldb.ChannelCommitment{}\n\t\t\tif uniClose.RemoteCommit.FeePerKw != blankCommit.FeePerKw {\n\t\t\t\tt.Errorf(\"DLP path not executed\")\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\t// The resolution should have also read the DLP point\n\t\t\t// we stored above, and used that to derive their sweep\n\t\t\t// key for this output.\n\t\t\tsweepTweak := input.SingleTweakBytes(\n\t\t\t\tdlpPoint,\n\t\t\t\taliceChannel.State().LocalChanCfg.PaymentBasePoint.PubKey,\n\t\t\t)\n\t\t\tcommitResolution := uniClose.CommitResolution\n\t\t\tresolutionTweak := commitResolution.SelfOutputSignDesc.SingleTweak\n\t\t\tif !bytes.Equal(sweepTweak, resolutionTweak) {\n\t\t\t\tt.Errorf(\"sweep key mismatch: expected %x got %x\",\n\t\t\t\t\tsweepTweak, resolutionTweak)\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\treturn true\n\n\t\tcase <-time.After(time.Second * 5):\n\t\t\tt.Errorf(\"didn't receive unilateral close event\")\n\t\t\treturn false\n\t\t}\n\t}\n\n\ttestCases := []dlpTestCase{\n\t\t// For our first scenario, we'll ensure that if we're on state 1,\n\t\t// and the remote party broadcasts state 2 and we don't have a\n\t\t// pending commit for them, then we'll properly detect this as a\n\t\t// DLP scenario.\n\t\t{\n\t\t\tBroadcastStateNum: 2,\n\t\t\tNumUpdates:        1,\n\t\t},\n\n\t\t// We've completed a single update, but the remote party broadcasts\n\t\t// a state that's 5 states byeond our best known state. We've lost\n\t\t// data, but only partially, so we should enter a DLP secnario.\n\t\t{\n\t\t\tBroadcastStateNum: 6,\n\t\t\tNumUpdates:        1,\n\t\t},\n\n\t\t// Similar to the case above, but we've done more than one\n\t\t// update.\n\t\t{\n\t\t\tBroadcastStateNum: 6,\n\t\t\tNumUpdates:        3,\n\t\t},\n\n\t\t// We've done zero updates, but our channel peer broadcasts a\n\t\t// state beyond our knowledge.\n\t\t{\n\t\t\tBroadcastStateNum: 10,\n\t\t\tNumUpdates:        0,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\ttestName := fmt.Sprintf(\"num_updates=%v,broadcast_state_num=%v\",\n\t\t\ttestCase.NumUpdates, testCase.BroadcastStateNum)\n\n\t\ttestCase := testCase\n\t\tt.Run(testName, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tif !dlpScenario(t, testCase) {\n\t\t\t\tt.Fatalf(\"test %v failed\", testName)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestChainWatcherLocalForceCloseDetect tests we're able to always detect our\n// commitment output based on only the outputs present on the transaction.",
      "length": 5683,
      "tokens": 758,
      "embedding": []
    },
    {
      "slug": "func TestChainWatcherLocalForceCloseDetect(t *testing.T) {",
      "content": "func TestChainWatcherLocalForceCloseDetect(t *testing.T) {\n\tt.Parallel()\n\n\t// localForceCloseScenario is the primary test we'll use to execute our\n\t// table driven tests. We'll assert that for any number of state\n\t// updates, and if the commitment transaction has our output or not,\n\t// we're able to properly detect a local force close.\n\tlocalForceCloseScenario := func(t *testing.T, numUpdates, localState uint8,\n\t\tremoteOutputOnly, localOutputOnly bool) bool {\n\n\t\t// First, we'll create two channels which already have\n\t\t// established a commitment contract between themselves.\n\t\taliceChannel, bobChannel, err := lnwallet.CreateTestChannels(\n\t\t\tt, channeldb.SingleFunderBit,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to create test channels: %v\", err)\n\t\t}\n\n\t\t// We'll execute a number of state transitions based on the\n\t\t// randomly selected number from testing/quick. We do this to\n\t\t// get more coverage of various state hint encodings beyond 0\n\t\t// and 1.\n\t\tconst htlcAmt = 1000\n\t\tstates, err := executeStateTransitions(\n\t\t\tt, htlcAmt, aliceChannel, bobChannel, numUpdates,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"unable to trigger state \"+\n\t\t\t\t\"transition: %v\", err)\n\t\t\treturn false\n\t\t}\n\n\t\t// We'll use the state this test case wants Alice to start at.\n\t\taliceChanState := states[localState]\n\n\t\t// With the channels created, we'll now create a chain watcher\n\t\t// instance which will be watching for any closes of Alice's\n\t\t// channel.\n\t\taliceNotifier := &mock.ChainNotifier{\n\t\t\tSpendChan: make(chan *chainntnfs.SpendDetail),\n\t\t\tEpochChan: make(chan *chainntnfs.BlockEpoch),\n\t\t\tConfChan:  make(chan *chainntnfs.TxConfirmation),\n\t\t}\n\t\taliceChainWatcher, err := newChainWatcher(chainWatcherConfig{\n\t\t\tchanState:           aliceChanState,\n\t\t\tnotifier:            aliceNotifier,\n\t\t\tsigner:              aliceChannel.Signer,\n\t\t\textractStateNumHint: lnwallet.GetStateNumHint,\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to create chain watcher: %v\", err)\n\t\t}\n\t\tif err := aliceChainWatcher.Start(); err != nil {\n\t\t\tt.Fatalf(\"unable to start chain watcher: %v\", err)\n\t\t}\n\t\tdefer aliceChainWatcher.Stop()\n\n\t\t// We'll request a new channel event subscription from Alice's\n\t\t// chain watcher so we can be notified of our fake close below.\n\t\tchanEvents := aliceChainWatcher.SubscribeChannelEvents()\n\n\t\t// Next, we'll obtain Alice's commitment transaction and\n\t\t// trigger a force close. This should cause her to detect a\n\t\t// local force close, and dispatch a local close event.\n\t\taliceCommit := aliceChannel.State().LocalCommitment.CommitTx\n\n\t\t// Since this is Alice's commitment, her output is always first\n\t\t// since she's the one creating the HTLCs (lower balance). In\n\t\t// order to simulate the commitment only having the remote\n\t\t// party's output, we'll remove Alice's output.\n\t\tif remoteOutputOnly {\n\t\t\taliceCommit.TxOut = aliceCommit.TxOut[1:]\n\t\t}\n\t\tif localOutputOnly {\n\t\t\taliceCommit.TxOut = aliceCommit.TxOut[:1]\n\t\t}\n\n\t\taliceTxHash := aliceCommit.TxHash()\n\t\taliceSpend := &chainntnfs.SpendDetail{\n\t\t\tSpenderTxHash: &aliceTxHash,\n\t\t\tSpendingTx:    aliceCommit,\n\t\t}\n\t\taliceNotifier.SpendChan <- aliceSpend\n\n\t\t// We should get a local force close event from Alice as she\n\t\t// should be able to detect the close based on the commitment\n\t\t// outputs.\n\t\tselect {\n\t\tcase summary := <-chanEvents.LocalUnilateralClosure:\n\t\t\t// Make sure we correctly extracted the commit\n\t\t\t// resolution if we had a local output.\n\t\t\tif remoteOutputOnly {\n\t\t\t\tif summary.CommitResolution != nil {\n\t\t\t\t\tt.Fatalf(\"expected no commit resolution\")\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif summary.CommitResolution == nil {\n\t\t\t\t\tt.Fatalf(\"expected commit resolution\")\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true\n\n\t\tcase <-time.After(time.Second * 5):\n\t\t\tt.Errorf(\"didn't get local for close for state #%v\",\n\t\t\t\tnumUpdates)\n\t\t\treturn false\n\t\t}\n\t}\n\n\t// For our test cases, we'll ensure that we test having a remote output\n\t// present and absent with non or some number of updates in the channel.\n\ttestCases := []struct {\n\t\tnumUpdates       uint8\n\t\tlocalState       uint8\n\t\tremoteOutputOnly bool\n\t\tlocalOutputOnly  bool\n\t}{\n\t\t{\n\t\t\tnumUpdates:       0,\n\t\t\tlocalState:       0,\n\t\t\tremoteOutputOnly: true,\n\t\t},\n\t\t{\n\t\t\tnumUpdates:       0,\n\t\t\tlocalState:       0,\n\t\t\tremoteOutputOnly: false,\n\t\t},\n\t\t{\n\t\t\tnumUpdates:      0,\n\t\t\tlocalState:      0,\n\t\t\tlocalOutputOnly: true,\n\t\t},\n\t\t{\n\t\t\tnumUpdates:       20,\n\t\t\tlocalState:       20,\n\t\t\tremoteOutputOnly: false,\n\t\t},\n\t\t{\n\t\t\tnumUpdates:       20,\n\t\t\tlocalState:       20,\n\t\t\tremoteOutputOnly: true,\n\t\t},\n\t\t{\n\t\t\tnumUpdates:      20,\n\t\t\tlocalState:      20,\n\t\t\tlocalOutputOnly: true,\n\t\t},\n\t\t{\n\t\t\tnumUpdates:       20,\n\t\t\tlocalState:       5,\n\t\t\tremoteOutputOnly: false,\n\t\t},\n\t\t{\n\t\t\tnumUpdates:       20,\n\t\t\tlocalState:       5,\n\t\t\tremoteOutputOnly: true,\n\t\t},\n\t\t{\n\t\t\tnumUpdates:      20,\n\t\t\tlocalState:      5,\n\t\t\tlocalOutputOnly: true,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\ttestName := fmt.Sprintf(\n\t\t\t\"num_updates=%v,remote_output=%v,local_output=%v\",\n\t\t\ttestCase.numUpdates, testCase.remoteOutputOnly,\n\t\t\ttestCase.localOutputOnly,\n\t\t)\n\n\t\ttestCase := testCase\n\t\tt.Run(testName, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tlocalForceCloseScenario(\n\t\t\t\tt, testCase.numUpdates, testCase.localState,\n\t\t\t\ttestCase.remoteOutputOnly,\n\t\t\t\ttestCase.localOutputOnly,\n\t\t\t)\n\t\t})\n\t}\n}\n",
      "length": 5013,
      "tokens": 624,
      "embedding": []
    }
  ]
}