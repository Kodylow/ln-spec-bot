{
  "filepath": "../implementations/go/lnd/contractcourt/breacharbiter.go",
  "package": "contractcourt",
  "sections": [
    {
      "slug": "type ContractBreachEvent struct {",
      "content": "type ContractBreachEvent struct {\n\t// ChanPoint is the channel point of the breached channel.\n\tChanPoint wire.OutPoint\n\n\t// ProcessACK is an closure that should be called with a nil error iff\n\t// the breach retribution info is safely stored in the retribution\n\t// store. In case storing the information to the store fails, a non-nil\n\t// error should be used. When this closure returns, it means that the\n\t// contract court has marked the channel pending close in the DB, and\n\t// it is safe for the BreachArbiter to carry on its duty.\n\tProcessACK func(error)\n\n\t// BreachRetribution is the information needed to act on this contract\n\t// breach.\n\tBreachRetribution *lnwallet.BreachRetribution\n}\n\n// ChannelCloseType is an enum which signals the type of channel closure the\n// peer should execute.",
      "length": 742,
      "tokens": 123,
      "embedding": []
    },
    {
      "slug": "type ChannelCloseType uint8",
      "content": "type ChannelCloseType uint8\n\nconst (\n\t// CloseRegular indicates a regular cooperative channel closure\n\t// should be attempted.\n\tCloseRegular ChannelCloseType = iota\n\n\t// CloseBreach indicates that a channel breach has been detected, and\n\t// the link should immediately be marked as unavailable.\n\tCloseBreach\n)\n\n// RetributionStorer provides an interface for managing a persistent map from\n// wire.OutPoint -> retributionInfo. Upon learning of a breach, a BreachArbiter\n// should record the retributionInfo for the breached channel, which serves a\n// checkpoint in the event that retribution needs to be resumed after failure.\n// A RetributionStore provides an interface for managing the persisted set, as\n// well as mapping user defined functions over the entire on-disk contents.\n//\n// Calls to RetributionStore may occur concurrently. A concrete instance of\n// RetributionStore should use appropriate synchronization primitives, or\n// be otherwise safe for concurrent access.",
      "length": 929,
      "tokens": 138,
      "embedding": []
    },
    {
      "slug": "type RetributionStorer interface {",
      "content": "type RetributionStorer interface {\n\t// Add persists the retributionInfo to disk, using the information's\n\t// chanPoint as the key. This method should overwrite any existing\n\t// entries found under the same key, and an error should be raised if\n\t// the addition fails.\n\tAdd(retInfo *retributionInfo) error\n\n\t// IsBreached queries the retribution store to see if the breach arbiter\n\t// is aware of any breaches for the provided channel point.\n\tIsBreached(chanPoint *wire.OutPoint) (bool, error)\n\n\t// Remove deletes the retributionInfo from disk, if any exists, under\n\t// the given key. An error should be re raised if the removal fails.\n\tRemove(key *wire.OutPoint) error\n\n\t// ForAll iterates over the existing on-disk contents and applies a\n\t// chosen, read-only callback to each. This method should ensure that it\n\t// immediately propagate any errors generated by the callback.\n\tForAll(cb func(*retributionInfo) error, reset func()) error\n}\n\n// BreachConfig bundles the required subsystems used by the breach arbiter. An\n// instance of BreachConfig is passed to newBreachArbiter during instantiation.",
      "length": 1043,
      "tokens": 158,
      "embedding": []
    },
    {
      "slug": "type BreachConfig struct {",
      "content": "type BreachConfig struct {\n\t// CloseLink allows the breach arbiter to shutdown any channel links for\n\t// which it detects a breach, ensuring now further activity will\n\t// continue across the link. The method accepts link's channel point and\n\t// a close type to be included in the channel close summary.\n\tCloseLink func(*wire.OutPoint, ChannelCloseType)\n\n\t// DB provides access to the user's channels, allowing the breach\n\t// arbiter to determine the current state of a user's channels, and how\n\t// it should respond to channel closure.\n\tDB *channeldb.ChannelStateDB\n\n\t// Estimator is used by the breach arbiter to determine an appropriate\n\t// fee level when generating, signing, and broadcasting sweep\n\t// transactions.\n\tEstimator chainfee.Estimator\n\n\t// GenSweepScript generates the receiving scripts for swept outputs.\n\tGenSweepScript func() ([]byte, error)\n\n\t// Notifier provides a publish/subscribe interface for event driven\n\t// notifications regarding the confirmation of txids.\n\tNotifier chainntnfs.ChainNotifier\n\n\t// PublishTransaction facilitates the process of broadcasting a\n\t// transaction to the network.\n\tPublishTransaction func(*wire.MsgTx, string) error\n\n\t// ContractBreaches is a channel where the BreachArbiter will receive\n\t// notifications in the event of a contract breach being observed. A\n\t// ContractBreachEvent must be ACKed by the BreachArbiter, such that\n\t// the sending subsystem knows that the event is properly handed off.\n\tContractBreaches <-chan *ContractBreachEvent\n\n\t// Signer is used by the breach arbiter to generate sweep transactions,\n\t// which move coins from previously open channels back to the user's\n\t// wallet.\n\tSigner input.Signer\n\n\t// Store is a persistent resource that maintains information regarding\n\t// breached channels. This is used in conjunction with DB to recover\n\t// from crashes, restarts, or other failures.\n\tStore RetributionStorer\n}\n\n// BreachArbiter is a special subsystem which is responsible for watching and\n// acting on the detection of any attempted uncooperative channel breaches by\n// channel counterparties. This file essentially acts as deterrence code for\n// those attempting to launch attacks against the daemon. In practice it's\n// expected that the logic in this file never gets executed, but it is\n// important to have it in place just in case we encounter cheating channel\n// counterparties.\n// TODO(roasbeef): closures in config for subsystem pointers to decouple?",
      "length": 2363,
      "tokens": 350,
      "embedding": []
    },
    {
      "slug": "type BreachArbiter struct {",
      "content": "type BreachArbiter struct {\n\tstarted sync.Once\n\tstopped sync.Once\n\n\tcfg *BreachConfig\n\n\tsubscriptions map[wire.OutPoint]chan struct{}\n\n\tquit chan struct{}\n\twg   sync.WaitGroup\n\tsync.Mutex\n}\n\n// NewBreachArbiter creates a new instance of a BreachArbiter initialized with\n// its dependent objects.",
      "length": 254,
      "tokens": 31,
      "embedding": []
    },
    {
      "slug": "func NewBreachArbiter(cfg *BreachConfig) *BreachArbiter {",
      "content": "func NewBreachArbiter(cfg *BreachConfig) *BreachArbiter {\n\treturn &BreachArbiter{\n\t\tcfg:           cfg,\n\t\tsubscriptions: make(map[wire.OutPoint]chan struct{}),\n\t\tquit:          make(chan struct{}),\n\t}\n}\n\n// Start is an idempotent method that officially starts the BreachArbiter along\n// with all other goroutines it needs to perform its functions.",
      "length": 281,
      "tokens": 35,
      "embedding": []
    },
    {
      "slug": "func (b *BreachArbiter) Start() error {",
      "content": "func (b *BreachArbiter) Start() error {\n\tvar err error\n\tb.started.Do(func() {\n\t\tbrarLog.Info(\"Breach arbiter starting\")\n\t\terr = b.start()\n\t})\n\treturn err\n}\n",
      "length": 109,
      "tokens": 15,
      "embedding": []
    },
    {
      "slug": "func (b *BreachArbiter) start() error {",
      "content": "func (b *BreachArbiter) start() error {\n\t// Load all retributions currently persisted in the retribution store.\n\tvar breachRetInfos map[wire.OutPoint]retributionInfo\n\tif err := b.cfg.Store.ForAll(func(ret *retributionInfo) error {\n\t\tbreachRetInfos[ret.chanPoint] = *ret\n\t\treturn nil\n\t}, func() {\n\t\tbreachRetInfos = make(map[wire.OutPoint]retributionInfo)\n\t}); err != nil {\n\t\tbrarLog.Errorf(\"Unable to create retribution info: %v\", err)\n\t\treturn err\n\t}\n\n\t// Load all currently closed channels from disk, we will use the\n\t// channels that have been marked fully closed to filter the retribution\n\t// information loaded from disk. This is necessary in the event that the\n\t// channel was marked fully closed, but was not removed from the\n\t// retribution store.\n\tclosedChans, err := b.cfg.DB.FetchClosedChannels(false)\n\tif err != nil {\n\t\tbrarLog.Errorf(\"Unable to fetch closing channels: %v\", err)\n\t\treturn err\n\t}\n\n\tbrarLog.Debugf(\"Found %v closing channels, %v retribution records\",\n\t\tlen(closedChans), len(breachRetInfos))\n\n\t// Using the set of non-pending, closed channels, reconcile any\n\t// discrepancies between the channeldb and the retribution store by\n\t// removing any retribution information for which we have already\n\t// finished our responsibilities. If the removal is successful, we also\n\t// remove the entry from our in-memory map, to avoid any further action\n\t// for this channel.\n\t// TODO(halseth): no need continue on IsPending once closed channels\n\t// actually means close transaction is confirmed.\n\tfor _, chanSummary := range closedChans {\n\t\tbrarLog.Debugf(\"Working on close channel: %v, is_pending: %v\",\n\t\t\tchanSummary.ChanPoint, chanSummary.IsPending)\n\n\t\tif chanSummary.IsPending {\n\t\t\tcontinue\n\t\t}\n\n\t\tchanPoint := &chanSummary.ChanPoint\n\t\tif _, ok := breachRetInfos[*chanPoint]; ok {\n\t\t\tif err := b.cfg.Store.Remove(chanPoint); err != nil {\n\t\t\t\tbrarLog.Errorf(\"Unable to remove closed \"+\n\t\t\t\t\t\"chanid=%v from breach arbiter: %v\",\n\t\t\t\t\tchanPoint, err)\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdelete(breachRetInfos, *chanPoint)\n\n\t\t\tbrarLog.Debugf(\"Skipped closed channel: %v\",\n\t\t\t\tchanSummary.ChanPoint)\n\t\t}\n\t}\n\n\t// Spawn the exactRetribution tasks to monitor and resolve any breaches\n\t// that were loaded from the retribution store.\n\tfor chanPoint := range breachRetInfos {\n\t\tretInfo := breachRetInfos[chanPoint]\n\n\t\tbrarLog.Debugf(\"Handling breach handoff on startup \"+\n\t\t\t\"for ChannelPoint(%v)\", chanPoint)\n\n\t\t// Register for a notification when the breach transaction is\n\t\t// confirmed on chain.\n\t\tbreachTXID := retInfo.commitHash\n\t\tbreachScript := retInfo.breachedOutputs[0].signDesc.Output.PkScript\n\t\tconfChan, err := b.cfg.Notifier.RegisterConfirmationsNtfn(\n\t\t\t&breachTXID, breachScript, 1, retInfo.breachHeight,\n\t\t)\n\t\tif err != nil {\n\t\t\tbrarLog.Errorf(\"Unable to register for conf updates \"+\n\t\t\t\t\"for txid: %v, err: %v\", breachTXID, err)\n\t\t\treturn err\n\t\t}\n\n\t\t// Launch a new goroutine which to finalize the channel\n\t\t// retribution after the breach transaction confirms.\n\t\tb.wg.Add(1)\n\t\tgo b.exactRetribution(confChan, &retInfo)\n\t}\n\n\t// Start watching the remaining active channels!\n\tb.wg.Add(1)\n\tgo b.contractObserver()\n\n\treturn nil\n}\n\n// Stop is an idempotent method that signals the BreachArbiter to execute a\n// graceful shutdown. This function will block until all goroutines spawned by\n// the BreachArbiter have gracefully exited.",
      "length": 3207,
      "tokens": 418,
      "embedding": []
    },
    {
      "slug": "func (b *BreachArbiter) Stop() error {",
      "content": "func (b *BreachArbiter) Stop() error {\n\tb.stopped.Do(func() {\n\t\tbrarLog.Infof(\"Breach arbiter shutting down\")\n\n\t\tclose(b.quit)\n\t\tb.wg.Wait()\n\t})\n\treturn nil\n}\n\n// IsBreached queries the breach arbiter's retribution store to see if it is\n// aware of any channel breaches for a particular channel point.",
      "length": 252,
      "tokens": 36,
      "embedding": []
    },
    {
      "slug": "func (b *BreachArbiter) IsBreached(chanPoint *wire.OutPoint) (bool, error) {",
      "content": "func (b *BreachArbiter) IsBreached(chanPoint *wire.OutPoint) (bool, error) {\n\treturn b.cfg.Store.IsBreached(chanPoint)\n}\n\n// SubscribeBreachComplete is used by outside subsystems to be notified of a\n// successful breach resolution.",
      "length": 150,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func (b *BreachArbiter) SubscribeBreachComplete(chanPoint *wire.OutPoint,",
      "content": "func (b *BreachArbiter) SubscribeBreachComplete(chanPoint *wire.OutPoint,\n\tc chan struct{}) (bool, error) {\n\n\tbreached, err := b.cfg.Store.IsBreached(chanPoint)\n\tif err != nil {\n\t\t// If an error occurs, no subscription will be registered.\n\t\treturn false, err\n\t}\n\n\tif !breached {\n\t\t// If chanPoint no longer exists in the Store, then the breach\n\t\t// was cleaned up successfully. Any subscription that occurs\n\t\t// happens after the breach information was persisted to the\n\t\t// underlying store.\n\t\treturn true, nil\n\t}\n\n\t// Otherwise since the channel point is not resolved, add a\n\t// subscription. There can only be one subscription per channel point.\n\tb.Lock()\n\tdefer b.Unlock()\n\tb.subscriptions[*chanPoint] = c\n\n\treturn false, nil\n}\n\n// notifyBreachComplete is used by the BreachArbiter to notify outside\n// subsystems that the breach resolution process is complete.",
      "length": 765,
      "tokens": 121,
      "embedding": []
    },
    {
      "slug": "func (b *BreachArbiter) notifyBreachComplete(chanPoint *wire.OutPoint) {",
      "content": "func (b *BreachArbiter) notifyBreachComplete(chanPoint *wire.OutPoint) {\n\tb.Lock()\n\tdefer b.Unlock()\n\tif c, ok := b.subscriptions[*chanPoint]; ok {\n\t\tclose(c)\n\t}\n\n\t// Remove the subscription.\n\tdelete(b.subscriptions, *chanPoint)\n}\n\n// contractObserver is the primary goroutine for the BreachArbiter. This\n// goroutine is responsible for handling breach events coming from the\n// contractcourt on the ContractBreaches channel. If a channel breach is\n// detected, then the contractObserver will execute the retribution logic\n// required to sweep ALL outputs from a contested channel into the daemon's\n// wallet.\n//\n// NOTE: This MUST be run as a goroutine.",
      "length": 564,
      "tokens": 86,
      "embedding": []
    },
    {
      "slug": "func (b *BreachArbiter) contractObserver() {",
      "content": "func (b *BreachArbiter) contractObserver() {\n\tdefer b.wg.Done()\n\n\tbrarLog.Infof(\"Starting contract observer, watching for breaches.\")\n\n\tfor {\n\t\tselect {\n\t\tcase breachEvent := <-b.cfg.ContractBreaches:\n\t\t\t// We have been notified about a contract breach!\n\t\t\t// Handle the handoff, making sure we ACK the event\n\t\t\t// after we have safely added it to the retribution\n\t\t\t// store.\n\t\t\tb.wg.Add(1)\n\t\t\tgo b.handleBreachHandoff(breachEvent)\n\n\t\tcase <-b.quit:\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// spend is used to wrap the index of the retributionInfo output that gets\n// spent together with the spend details.",
      "length": 521,
      "tokens": 77,
      "embedding": []
    },
    {
      "slug": "type spend struct {",
      "content": "type spend struct {\n\tindex  int\n\tdetail *chainntnfs.SpendDetail\n}\n\n// waitForSpendEvent waits for any of the breached outputs to get spent, and\n// returns the spend details for those outputs. The spendNtfns map is a cache\n// used to store registered spend subscriptions, in case we must call this\n// method multiple times.",
      "length": 295,
      "tokens": 49,
      "embedding": []
    },
    {
      "slug": "func (b *BreachArbiter) waitForSpendEvent(breachInfo *retributionInfo,",
      "content": "func (b *BreachArbiter) waitForSpendEvent(breachInfo *retributionInfo,\n\tspendNtfns map[wire.OutPoint]*chainntnfs.SpendEvent) ([]spend, error) {\n\n\tinputs := breachInfo.breachedOutputs\n\n\t// We create a channel the first goroutine that gets a spend event can\n\t// signal. We make it buffered in case multiple spend events come in at\n\t// the same time.\n\tanySpend := make(chan struct{}, len(inputs))\n\n\t// The allSpends channel will be used to pass spend events from all the\n\t// goroutines that detects a spend before they are signalled to exit.\n\tallSpends := make(chan spend, len(inputs))\n\n\t// exit will be used to signal the goroutines that they can exit.\n\texit := make(chan struct{})\n\tvar wg sync.WaitGroup\n\n\t// We'll now launch a goroutine for each of the HTLC outputs, that will\n\t// signal the moment they detect a spend event.\n\tfor i := range inputs {\n\t\tbreachedOutput := &inputs[i]\n\n\t\tbrarLog.Infof(\"Checking spend from %v(%v) for ChannelPoint(%v)\",\n\t\t\tbreachedOutput.witnessType, breachedOutput.outpoint,\n\t\t\tbreachInfo.chanPoint)\n\n\t\t// If we have already registered for a notification for this\n\t\t// output, we'll reuse it.\n\t\tspendNtfn, ok := spendNtfns[breachedOutput.outpoint]\n\t\tif !ok {\n\t\t\tvar err error\n\t\t\tspendNtfn, err = b.cfg.Notifier.RegisterSpendNtfn(\n\t\t\t\t&breachedOutput.outpoint,\n\t\t\t\tbreachedOutput.signDesc.Output.PkScript,\n\t\t\t\tbreachInfo.breachHeight,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tbrarLog.Errorf(\"Unable to check for spentness \"+\n\t\t\t\t\t\"of outpoint=%v: %v\",\n\t\t\t\t\tbreachedOutput.outpoint, err)\n\n\t\t\t\t// Registration may have failed if we've been\n\t\t\t\t// instructed to shutdown. If so, return here\n\t\t\t\t// to avoid entering an infinite loop.\n\t\t\t\tselect {\n\t\t\t\tcase <-b.quit:\n\t\t\t\t\treturn nil, errBrarShuttingDown\n\t\t\t\tdefault:\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t\tspendNtfns[breachedOutput.outpoint] = spendNtfn\n\t\t}\n\n\t\t// Launch a goroutine waiting for a spend event.\n\t\tb.wg.Add(1)\n\t\twg.Add(1)\n\t\tgo func(index int, spendEv *chainntnfs.SpendEvent) {\n\t\t\tdefer b.wg.Done()\n\t\t\tdefer wg.Done()\n\n\t\t\tselect {\n\t\t\t// The output has been taken to the second level!\n\t\t\tcase sp, ok := <-spendEv.Spend:\n\t\t\t\tif !ok {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tbrarLog.Infof(\"Detected spend on %s(%v) by \"+\n\t\t\t\t\t\"txid(%v) for ChannelPoint(%v)\",\n\t\t\t\t\tinputs[index].witnessType,\n\t\t\t\t\tinputs[index].outpoint,\n\t\t\t\t\tsp.SpenderTxHash,\n\t\t\t\t\tbreachInfo.chanPoint)\n\n\t\t\t\t// First we send the spend event on the\n\t\t\t\t// allSpends channel, such that it can be\n\t\t\t\t// handled after all go routines have exited.\n\t\t\t\tallSpends <- spend{index, sp}\n\n\t\t\t\t// Finally we'll signal the anySpend channel\n\t\t\t\t// that a spend was detected, such that the\n\t\t\t\t// other goroutines can be shut down.\n\t\t\t\tanySpend <- struct{}{}\n\t\t\tcase <-exit:\n\t\t\t\treturn\n\t\t\tcase <-b.quit:\n\t\t\t\treturn\n\t\t\t}\n\t\t}(i, spendNtfn)\n\t}\n\n\t// We'll wait for any of the outputs to be spent, or that we are\n\t// signalled to exit.\n\tselect {\n\t// A goroutine have signalled that a spend occurred.\n\tcase <-anySpend:\n\t\t// Signal for the remaining goroutines to exit.\n\t\tclose(exit)\n\t\twg.Wait()\n\n\t\t// At this point all goroutines that can send on the allSpends\n\t\t// channel have exited. We can therefore safely close the\n\t\t// channel before ranging over its content.\n\t\tclose(allSpends)\n\n\t\t// Gather all detected spends and return them.\n\t\tvar spends []spend\n\t\tfor s := range allSpends {\n\t\t\tbreachedOutput := &inputs[s.index]\n\t\t\tdelete(spendNtfns, breachedOutput.outpoint)\n\n\t\t\tspends = append(spends, s)\n\t\t}\n\n\t\treturn spends, nil\n\n\tcase <-b.quit:\n\t\treturn nil, errBrarShuttingDown\n\t}\n}\n\n// convertToSecondLevelRevoke takes a breached output, and a transaction that\n// spends it to the second level, and mutates the breach output into one that\n// is able to properly sweep that second level output. We'll use this function\n// when we go to sweep a breached commitment transaction, but the cheating\n// party has already attempted to take it to the second level.",
      "length": 3652,
      "tokens": 519,
      "embedding": []
    },
    {
      "slug": "func convertToSecondLevelRevoke(bo *breachedOutput, breachInfo *retributionInfo,",
      "content": "func convertToSecondLevelRevoke(bo *breachedOutput, breachInfo *retributionInfo,\n\tspendDetails *chainntnfs.SpendDetail) {\n\n\t// In this case, we'll modify the witness type of this output to\n\t// actually prepare for a second level revoke.\n\tbo.witnessType = input.HtlcSecondLevelRevoke\n\n\t// We'll also redirect the outpoint to this second level output, so the\n\t// spending transaction updates it inputs accordingly.\n\tspendingTx := spendDetails.SpendingTx\n\tspendInputIndex := spendDetails.SpenderInputIndex\n\toldOp := bo.outpoint\n\tbo.outpoint = wire.OutPoint{\n\t\tHash:  spendingTx.TxHash(),\n\t\tIndex: spendInputIndex,\n\t}\n\n\t// Next, we need to update the amount so we can do fee estimation\n\t// properly, and also so we can generate a valid signature as we need\n\t// to know the new input value (the second level transactions shaves\n\t// off some funds to fees).\n\tnewAmt := spendingTx.TxOut[spendInputIndex].Value\n\tbo.amt = btcutil.Amount(newAmt)\n\tbo.signDesc.Output.Value = newAmt\n\tbo.signDesc.Output.PkScript = spendingTx.TxOut[spendInputIndex].PkScript\n\n\t// Finally, we'll need to adjust the witness program in the\n\t// SignDescriptor.\n\tbo.signDesc.WitnessScript = bo.secondLevelWitnessScript\n\n\tbrarLog.Warnf(\"HTLC(%v) for ChannelPoint(%v) has been spent to the \"+\n\t\t\"second-level, adjusting -> %v\", oldOp, breachInfo.chanPoint,\n\t\tbo.outpoint)\n}\n\n// updateBreachInfo mutates the passed breachInfo by removing or converting any\n// outputs among the spends. It also counts the total and revoked funds swept\n// by our justice spends.",
      "length": 1404,
      "tokens": 185,
      "embedding": []
    },
    {
      "slug": "func updateBreachInfo(breachInfo *retributionInfo, spends []spend) (",
      "content": "func updateBreachInfo(breachInfo *retributionInfo, spends []spend) (\n\tbtcutil.Amount, btcutil.Amount) {\n\n\tinputs := breachInfo.breachedOutputs\n\tdoneOutputs := make(map[int]struct{})\n\n\tvar totalFunds, revokedFunds btcutil.Amount\n\tfor _, s := range spends {\n\t\tbreachedOutput := &inputs[s.index]\n\t\ttxIn := s.detail.SpendingTx.TxIn[s.detail.SpenderInputIndex]\n\n\t\tswitch breachedOutput.witnessType {\n\t\tcase input.HtlcAcceptedRevoke:\n\t\t\tfallthrough\n\t\tcase input.HtlcOfferedRevoke:\n\t\t\t// If the HTLC output was spent using the revocation\n\t\t\t// key, it is our own spend, and we can forget the\n\t\t\t// output. Otherwise it has been taken to the second\n\t\t\t// level.\n\t\t\tsignDesc := &breachedOutput.signDesc\n\t\t\tok, err := input.IsHtlcSpendRevoke(txIn, signDesc)\n\t\t\tif err != nil {\n\t\t\t\tbrarLog.Errorf(\"Unable to determine if \"+\n\t\t\t\t\t\"revoke spend: %v\", err)\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tif ok {\n\t\t\t\tbrarLog.Debugf(\"HTLC spend was our own \" +\n\t\t\t\t\t\"revocation spend\")\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tbrarLog.Infof(\"Spend on second-level \"+\n\t\t\t\t\"%s(%v) for ChannelPoint(%v) \"+\n\t\t\t\t\"transitions to second-level output\",\n\t\t\t\tbreachedOutput.witnessType,\n\t\t\t\tbreachedOutput.outpoint, breachInfo.chanPoint)\n\n\t\t\t// In this case we'll morph our initial revoke\n\t\t\t// spend to instead point to the second level\n\t\t\t// output, and update the sign descriptor in the\n\t\t\t// process.\n\t\t\tconvertToSecondLevelRevoke(\n\t\t\t\tbreachedOutput, breachInfo, s.detail,\n\t\t\t)\n\n\t\t\tcontinue\n\t\t}\n\n\t\t// Now that we have determined the spend is done by us, we\n\t\t// count the total and revoked funds swept depending on the\n\t\t// input type.\n\t\tswitch breachedOutput.witnessType {\n\t\t// If the output being revoked is the remote commitment\n\t\t// output or an offered HTLC output, it's amount\n\t\t// contributes to the value of funds being revoked from\n\t\t// the counter party.\n\t\tcase input.CommitmentRevoke, input.HtlcSecondLevelRevoke,\n\t\t\tinput.HtlcOfferedRevoke:\n\n\t\t\trevokedFunds += breachedOutput.Amount()\n\t\t}\n\n\t\ttotalFunds += breachedOutput.Amount()\n\t\tbrarLog.Infof(\"Spend on %s(%v) for ChannelPoint(%v) \"+\n\t\t\t\"transitions output to terminal state, \"+\n\t\t\t\"removing input from justice transaction\",\n\t\t\tbreachedOutput.witnessType,\n\t\t\tbreachedOutput.outpoint, breachInfo.chanPoint)\n\n\t\tdoneOutputs[s.index] = struct{}{}\n\t}\n\n\t// Filter the inputs for which we can no longer proceed.\n\tvar nextIndex int\n\tfor i := range inputs {\n\t\tif _, ok := doneOutputs[i]; ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tinputs[nextIndex] = inputs[i]\n\t\tnextIndex++\n\t}\n\n\t// Update our remaining set of outputs before continuing with\n\t// another attempt at publication.\n\tbreachInfo.breachedOutputs = inputs[:nextIndex]\n\treturn totalFunds, revokedFunds\n}\n\n// exactRetribution is a goroutine which is executed once a contract breach has\n// been detected by a breachObserver. This function is responsible for\n// punishing a counterparty for violating the channel contract by sweeping ALL\n// the lingering funds within the channel into the daemon's wallet.\n//\n// NOTE: This MUST be run as a goroutine.",
      "length": 2807,
      "tokens": 368,
      "embedding": []
    },
    {
      "slug": "func (b *BreachArbiter) exactRetribution(confChan *chainntnfs.ConfirmationEvent,",
      "content": "func (b *BreachArbiter) exactRetribution(confChan *chainntnfs.ConfirmationEvent,\n\tbreachInfo *retributionInfo) {\n\n\tdefer b.wg.Done()\n\n\t// TODO(roasbeef): state needs to be checkpointed here\n\tselect {\n\tcase _, ok := <-confChan.Confirmed:\n\t\t// If the second value is !ok, then the channel has been closed\n\t\t// signifying a daemon shutdown, so we exit.\n\t\tif !ok {\n\t\t\treturn\n\t\t}\n\n\t\t// Otherwise, if this is a real confirmation notification, then\n\t\t// we fall through to complete our duty.\n\tcase <-b.quit:\n\t\treturn\n\t}\n\n\tbrarLog.Debugf(\"Breach transaction %v has been confirmed, sweeping \"+\n\t\t\"revoked funds\", breachInfo.commitHash)\n\n\t// We may have to wait for some of the HTLC outputs to be spent to the\n\t// second level before broadcasting the justice tx. We'll store the\n\t// SpendEvents between each attempt to not re-register unnecessarily.\n\tspendNtfns := make(map[wire.OutPoint]*chainntnfs.SpendEvent)\n\n\t// Compute both the total value of funds being swept and the\n\t// amount of funds that were revoked from the counter party.\n\tvar totalFunds, revokedFunds btcutil.Amount\n\njusticeTxBroadcast:\n\t// With the breach transaction confirmed, we now create the\n\t// justice tx which will claim ALL the funds within the\n\t// channel.\n\tjusticeTxs, err := b.createJusticeTx(breachInfo.breachedOutputs)\n\tif err != nil {\n\t\tbrarLog.Errorf(\"Unable to create justice tx: %v\", err)\n\t\treturn\n\t}\n\tfinalTx := justiceTxs.spendAll\n\n\tbrarLog.Debugf(\"Broadcasting justice tx: %v\", newLogClosure(func() string {\n\t\treturn spew.Sdump(finalTx)\n\t}))\n\n\t// We'll now attempt to broadcast the transaction which finalized the\n\t// channel's retribution against the cheating counter party.\n\tlabel := labels.MakeLabel(labels.LabelTypeJusticeTransaction, nil)\n\terr = b.cfg.PublishTransaction(finalTx, label)\n\tif err != nil {\n\t\tbrarLog.Errorf(\"Unable to broadcast justice tx: %v\", err)\n\t}\n\n\t// Regardless of publication succeeded or not, we now wait for any of\n\t// the inputs to be spent. If any input got spent by the remote, we\n\t// must recreate our justice transaction.\n\tvar (\n\t\tspendChan = make(chan []spend, 1)\n\t\terrChan   = make(chan error, 1)\n\t\twg        sync.WaitGroup\n\t)\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\n\t\tspends, err := b.waitForSpendEvent(breachInfo, spendNtfns)\n\t\tif err != nil {\n\t\t\terrChan <- err\n\t\t\treturn\n\t\t}\n\t\tspendChan <- spends\n\t}()\n\n\t// We'll also register for block notifications, such that in case our\n\t// justice tx doesn't confirm within a reasonable timeframe, we can\n\t// start to more aggressively sweep the time sensitive outputs.\n\tnewBlockChan, err := b.cfg.Notifier.RegisterBlockEpochNtfn(nil)\n\tif err != nil {\n\t\tbrarLog.Errorf(\"Unable to register for block notifications: %v\",\n\t\t\terr)\n\t\treturn\n\t}\n\tdefer newBlockChan.Cancel()\n\nLoop:\n\tfor {\n\t\tselect {\n\t\tcase spends := <-spendChan:\n\t\t\t// Update the breach info with the new spends.\n\t\t\tt, r := updateBreachInfo(breachInfo, spends)\n\t\t\ttotalFunds += t\n\t\t\trevokedFunds += r\n\n\t\t\tbrarLog.Infof(\"%v spends from breach tx for \"+\n\t\t\t\t\"ChannelPoint(%v) has been detected, %v \"+\n\t\t\t\t\"revoked funds (%v total) have been claimed\",\n\t\t\t\tlen(spends), breachInfo.chanPoint,\n\t\t\t\trevokedFunds, totalFunds)\n\n\t\t\tif len(breachInfo.breachedOutputs) == 0 {\n\t\t\t\tbrarLog.Infof(\"Justice for ChannelPoint(%v) \"+\n\t\t\t\t\t\"has been served, %v revoked funds \"+\n\t\t\t\t\t\"(%v total) have been claimed. No \"+\n\t\t\t\t\t\"more outputs to sweep, marking fully \"+\n\t\t\t\t\t\"resolved\", breachInfo.chanPoint,\n\t\t\t\t\trevokedFunds, totalFunds)\n\n\t\t\t\terr = b.cleanupBreach(&breachInfo.chanPoint)\n\t\t\t\tif err != nil {\n\t\t\t\t\tbrarLog.Errorf(\"Failed to cleanup \"+\n\t\t\t\t\t\t\"breached ChannelPoint(%v): %v\",\n\t\t\t\t\t\tbreachInfo.chanPoint, err)\n\t\t\t\t}\n\n\t\t\t\t// TODO(roasbeef): add peer to blacklist?\n\n\t\t\t\t// TODO(roasbeef): close other active channels\n\t\t\t\t// with offending peer\n\t\t\t\tbreak Loop\n\t\t\t}\n\n\t\t\tbrarLog.Infof(\"Attempting another justice tx \"+\n\t\t\t\t\"with %d inputs\",\n\t\t\t\tlen(breachInfo.breachedOutputs))\n\n\t\t\twg.Wait()\n\t\t\tgoto justiceTxBroadcast\n\n\t\t// On every new block, we check whether we should republish the\n\t\t// transactions.\n\t\tcase epoch, ok := <-newBlockChan.Epochs:\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// If less than four blocks have passed since the\n\t\t\t// breach confirmed, we'll continue waiting. It was\n\t\t\t// published with a 2-block fee estimate, so it's not\n\t\t\t// unexpected that four blocks without confirmation can\n\t\t\t// pass.\n\t\t\tsplitHeight := breachInfo.breachHeight +\n\t\t\t\tblocksPassedSplitPublish\n\t\t\tif uint32(epoch.Height) < splitHeight {\n\t\t\t\tcontinue Loop\n\t\t\t}\n\n\t\t\tbrarLog.Warnf(\"Block height %v arrived without \"+\n\t\t\t\t\"justice tx confirming (breached at \"+\n\t\t\t\t\"height %v), splitting justice tx.\",\n\t\t\t\tepoch.Height, breachInfo.breachHeight)\n\n\t\t\t// Otherwise we'll attempt to publish the two separate\n\t\t\t// justice transactions that sweeps the commitment\n\t\t\t// outputs and the HTLC outputs separately. This is to\n\t\t\t// mitigate the case where our \"spend all\" justice TX\n\t\t\t// doesn't propagate because the HTLC outputs have been\n\t\t\t// pinned by low fee HTLC txs.\n\t\t\tlabel := labels.MakeLabel(\n\t\t\t\tlabels.LabelTypeJusticeTransaction, nil,\n\t\t\t)\n\t\t\tif justiceTxs.spendCommitOuts != nil {\n\t\t\t\ttx := justiceTxs.spendCommitOuts\n\n\t\t\t\tbrarLog.Debugf(\"Broadcasting justice tx \"+\n\t\t\t\t\t\"spending commitment outs: %v\",\n\t\t\t\t\tnewLogClosure(func() string {\n\t\t\t\t\t\treturn spew.Sdump(tx)\n\t\t\t\t\t}))\n\n\t\t\t\terr = b.cfg.PublishTransaction(tx, label)\n\t\t\t\tif err != nil {\n\t\t\t\t\tbrarLog.Warnf(\"Unable to broadcast \"+\n\t\t\t\t\t\t\"commit out spending justice \"+\n\t\t\t\t\t\t\"tx: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif justiceTxs.spendHTLCs != nil {\n\t\t\t\ttx := justiceTxs.spendHTLCs\n\n\t\t\t\tbrarLog.Debugf(\"Broadcasting justice tx \"+\n\t\t\t\t\t\"spending HTLC outs: %v\",\n\t\t\t\t\tnewLogClosure(func() string {\n\t\t\t\t\t\treturn spew.Sdump(tx)\n\t\t\t\t\t}))\n\n\t\t\t\terr = b.cfg.PublishTransaction(tx, label)\n\t\t\t\tif err != nil {\n\t\t\t\t\tbrarLog.Warnf(\"Unable to broadcast \"+\n\t\t\t\t\t\t\"HTLC out spending justice \"+\n\t\t\t\t\t\t\"tx: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\n\t\tcase err := <-errChan:\n\t\t\tif err != errBrarShuttingDown {\n\t\t\t\tbrarLog.Errorf(\"error waiting for \"+\n\t\t\t\t\t\"spend event: %v\", err)\n\t\t\t}\n\t\t\tbreak Loop\n\n\t\tcase <-b.quit:\n\t\t\tbreak Loop\n\t\t}\n\t}\n\n\t// Wait for our go routine to exit.\n\twg.Wait()\n}\n\n// cleanupBreach marks the given channel point as fully resolved and removes the\n// retribution for that the channel from the retribution store.",
      "length": 5944,
      "tokens": 806,
      "embedding": []
    },
    {
      "slug": "func (b *BreachArbiter) cleanupBreach(chanPoint *wire.OutPoint) error {",
      "content": "func (b *BreachArbiter) cleanupBreach(chanPoint *wire.OutPoint) error {\n\t// With the channel closed, mark it in the database as such.\n\terr := b.cfg.DB.MarkChanFullyClosed(chanPoint)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to mark chan as closed: %v\", err)\n\t}\n\n\t// Justice has been carried out; we can safely delete the retribution\n\t// info from the database.\n\terr = b.cfg.Store.Remove(chanPoint)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to remove retribution from db: %v\",\n\t\t\terr)\n\t}\n\n\t// This is after the Remove call so that the chan passed in via\n\t// SubscribeBreachComplete is always notified, no matter when it is\n\t// called. Otherwise, if notifyBreachComplete was before Remove, a\n\t// very rare edge case could occur in which SubscribeBreachComplete\n\t// is called after notifyBreachComplete and before Remove, meaning the\n\t// caller would never be notified.\n\tb.notifyBreachComplete(chanPoint)\n\n\treturn nil\n}\n\n// handleBreachHandoff handles a new breach event, by writing it to disk, then\n// notifies the BreachArbiter contract observer goroutine that a channel's\n// contract has been breached by the prior counterparty. Once notified the\n// BreachArbiter will attempt to sweep ALL funds within the channel using the\n// information provided within the BreachRetribution generated due to the\n// breach of channel contract. The funds will be swept only after the breaching\n// transaction receives a necessary number of confirmations.\n//\n// NOTE: This MUST be run as a goroutine.",
      "length": 1385,
      "tokens": 218,
      "embedding": []
    },
    {
      "slug": "func (b *BreachArbiter) handleBreachHandoff(breachEvent *ContractBreachEvent) {",
      "content": "func (b *BreachArbiter) handleBreachHandoff(breachEvent *ContractBreachEvent) {\n\tdefer b.wg.Done()\n\n\tchanPoint := breachEvent.ChanPoint\n\tbrarLog.Debugf(\"Handling breach handoff for ChannelPoint(%v)\",\n\t\tchanPoint)\n\n\t// A read from this channel indicates that a channel breach has been\n\t// detected! So we notify the main coordination goroutine with the\n\t// information needed to bring the counterparty to justice.\n\tbreachInfo := breachEvent.BreachRetribution\n\tbrarLog.Warnf(\"REVOKED STATE #%v FOR ChannelPoint(%v) \"+\n\t\t\"broadcast, REMOTE PEER IS DOING SOMETHING \"+\n\t\t\"SKETCHY!!!\", breachInfo.RevokedStateNum,\n\t\tchanPoint)\n\n\t// Immediately notify the HTLC switch that this link has been\n\t// breached in order to ensure any incoming or outgoing\n\t// multi-hop HTLCs aren't sent over this link, nor any other\n\t// links associated with this peer.\n\tb.cfg.CloseLink(&chanPoint, CloseBreach)\n\n\t// TODO(roasbeef): need to handle case of remote broadcast\n\t// mid-local initiated state-transition, possible\n\t// false-positive?\n\n\t// Acquire the mutex to ensure consistency between the call to\n\t// IsBreached and Add below.\n\tb.Lock()\n\n\t// We first check if this breach info is already added to the\n\t// retribution store.\n\tbreached, err := b.cfg.Store.IsBreached(&chanPoint)\n\tif err != nil {\n\t\tb.Unlock()\n\t\tbrarLog.Errorf(\"Unable to check breach info in DB: %v\", err)\n\n\t\t// Notify about the failed lookup and return.\n\t\tbreachEvent.ProcessACK(err)\n\t\treturn\n\t}\n\n\t// If this channel is already marked as breached in the retribution\n\t// store, we already have handled the handoff for this breach. In this\n\t// case we can safely ACK the handoff, and return.\n\tif breached {\n\t\tb.Unlock()\n\t\tbreachEvent.ProcessACK(nil)\n\t\treturn\n\t}\n\n\t// Using the breach information provided by the wallet and the\n\t// channel snapshot, construct the retribution information that\n\t// will be persisted to disk.\n\tretInfo := newRetributionInfo(&chanPoint, breachInfo)\n\n\t// Persist the pending retribution state to disk.\n\terr = b.cfg.Store.Add(retInfo)\n\tb.Unlock()\n\tif err != nil {\n\t\tbrarLog.Errorf(\"Unable to persist retribution \"+\n\t\t\t\"info to db: %v\", err)\n\t}\n\n\t// Now that the breach has been persisted, try to send an\n\t// acknowledgment back to the close observer with the error. If\n\t// the ack is successful, the close observer will mark the\n\t// channel as pending-closed in the channeldb.\n\tbreachEvent.ProcessACK(err)\n\n\t// Bail if we failed to persist retribution info.\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// Now that a new channel contract has been added to the retribution\n\t// store, we first register for a notification to be dispatched once\n\t// the breach transaction (the revoked commitment transaction) has been\n\t// confirmed in the chain to ensure we're not dealing with a moving\n\t// target.\n\tbreachTXID := &retInfo.commitHash\n\tbreachScript := retInfo.breachedOutputs[0].signDesc.Output.PkScript\n\tcfChan, err := b.cfg.Notifier.RegisterConfirmationsNtfn(\n\t\tbreachTXID, breachScript, 1, retInfo.breachHeight,\n\t)\n\tif err != nil {\n\t\tbrarLog.Errorf(\"Unable to register for conf updates for \"+\n\t\t\t\"txid: %v, err: %v\", breachTXID, err)\n\t\treturn\n\t}\n\n\tbrarLog.Warnf(\"A channel has been breached with txid: %v. Waiting \"+\n\t\t\"for confirmation, then justice will be served!\", breachTXID)\n\n\t// With the retribution state persisted, channel close persisted, and\n\t// notification registered, we launch a new goroutine which will\n\t// finalize the channel retribution after the breach transaction has\n\t// been confirmed.\n\tb.wg.Add(1)\n\tgo b.exactRetribution(cfChan, retInfo)\n}\n\n// breachedOutput contains all the information needed to sweep a breached\n// output. A breached output is an output that we are now entitled to due to a\n// revoked commitment transaction being broadcast.",
      "length": 3543,
      "tokens": 515,
      "embedding": []
    },
    {
      "slug": "type breachedOutput struct {",
      "content": "type breachedOutput struct {\n\tamt         btcutil.Amount\n\toutpoint    wire.OutPoint\n\twitnessType input.StandardWitnessType\n\tsignDesc    input.SignDescriptor\n\tconfHeight  uint32\n\n\tsecondLevelWitnessScript []byte\n\n\twitnessFunc input.WitnessGenerator\n}\n\n// makeBreachedOutput assembles a new breachedOutput that can be used by the\n// breach arbiter to construct a justice or sweep transaction.",
      "length": 349,
      "tokens": 37,
      "embedding": []
    },
    {
      "slug": "func makeBreachedOutput(outpoint *wire.OutPoint,",
      "content": "func makeBreachedOutput(outpoint *wire.OutPoint,\n\twitnessType input.StandardWitnessType,\n\tsecondLevelScript []byte,\n\tsignDescriptor *input.SignDescriptor,\n\tconfHeight uint32) breachedOutput {\n\n\tamount := signDescriptor.Output.Value\n\n\treturn breachedOutput{\n\t\tamt:                      btcutil.Amount(amount),\n\t\toutpoint:                 *outpoint,\n\t\tsecondLevelWitnessScript: secondLevelScript,\n\t\twitnessType:              witnessType,\n\t\tsignDesc:                 *signDescriptor,\n\t\tconfHeight:               confHeight,\n\t}\n}\n\n// Amount returns the number of satoshis contained in the breached output.",
      "length": 535,
      "tokens": 41,
      "embedding": []
    },
    {
      "slug": "func (bo *breachedOutput) Amount() btcutil.Amount {",
      "content": "func (bo *breachedOutput) Amount() btcutil.Amount {\n\treturn bo.amt\n}\n\n// OutPoint returns the breached output's identifier that is to be included as a\n// transaction input.",
      "length": 116,
      "tokens": 20,
      "embedding": []
    },
    {
      "slug": "func (bo *breachedOutput) OutPoint() *wire.OutPoint {",
      "content": "func (bo *breachedOutput) OutPoint() *wire.OutPoint {\n\treturn &bo.outpoint\n}\n\n// RequiredTxOut returns a non-nil TxOut if input commits to a certain\n// transaction output. This is used in the SINGLE|ANYONECANPAY case to make\n// sure any presigned input is still valid by including the output.",
      "length": 233,
      "tokens": 39,
      "embedding": []
    },
    {
      "slug": "func (bo *breachedOutput) RequiredTxOut() *wire.TxOut {",
      "content": "func (bo *breachedOutput) RequiredTxOut() *wire.TxOut {\n\treturn nil\n}\n\n// RequiredLockTime returns whether this input commits to a tx locktime that\n// must be used in the transaction including it.",
      "length": 136,
      "tokens": 24,
      "embedding": []
    },
    {
      "slug": "func (bo *breachedOutput) RequiredLockTime() (uint32, bool) {",
      "content": "func (bo *breachedOutput) RequiredLockTime() (uint32, bool) {\n\treturn 0, false\n}\n\n// WitnessType returns the type of witness that must be generated to spend the\n// breached output.",
      "length": 114,
      "tokens": 21,
      "embedding": []
    },
    {
      "slug": "func (bo *breachedOutput) WitnessType() input.WitnessType {",
      "content": "func (bo *breachedOutput) WitnessType() input.WitnessType {\n\treturn bo.witnessType\n}\n\n// SignDesc returns the breached output's SignDescriptor, which is used during\n// signing to compute the witness.",
      "length": 135,
      "tokens": 20,
      "embedding": []
    },
    {
      "slug": "func (bo *breachedOutput) SignDesc() *input.SignDescriptor {",
      "content": "func (bo *breachedOutput) SignDesc() *input.SignDescriptor {\n\treturn &bo.signDesc\n}\n\n// CraftInputScript computes a valid witness that allows us to spend from the\n// breached output. It does so by first generating and memoizing the witness\n// generation function, which parameterized primarily by the witness type and\n// sign descriptor. The method then returns the witness computed by invoking\n// this function on the first and subsequent calls.",
      "length": 378,
      "tokens": 61,
      "embedding": []
    },
    {
      "slug": "func (bo *breachedOutput) CraftInputScript(signer input.Signer, txn *wire.MsgTx,",
      "content": "func (bo *breachedOutput) CraftInputScript(signer input.Signer, txn *wire.MsgTx,\n\thashCache *txscript.TxSigHashes,\n\tprevOutputFetcher txscript.PrevOutputFetcher,\n\ttxinIdx int) (*input.Script, error) {\n\n\t// First, we ensure that the witness generation function has been\n\t// initialized for this breached output.\n\tsignDesc := bo.SignDesc()\n\tsignDesc.PrevOutputFetcher = prevOutputFetcher\n\tbo.witnessFunc = bo.witnessType.WitnessGenerator(signer, signDesc)\n\n\t// Now that we have ensured that the witness generation function has\n\t// been initialized, we can proceed to execute it and generate the\n\t// witness for this particular breached output.\n\treturn bo.witnessFunc(txn, hashCache, txinIdx)\n}\n\n// BlocksToMaturity returns the relative timelock, as a number of blocks, that\n// must be built on top of the confirmation height before the output can be\n// spent.",
      "length": 758,
      "tokens": 101,
      "embedding": []
    },
    {
      "slug": "func (bo *breachedOutput) BlocksToMaturity() uint32 {",
      "content": "func (bo *breachedOutput) BlocksToMaturity() uint32 {\n\t// If the output is a to_remote output we can claim, and it's of the\n\t// confirmed type, we must wait one block before claiming it.\n\tif bo.witnessType == input.CommitmentToRemoteConfirmed {\n\t\treturn 1\n\t}\n\n\t// All other breached outputs have no CSV delay.\n\treturn 0\n}\n\n// HeightHint returns the minimum height at which a confirmed spending tx can\n// occur.",
      "length": 345,
      "tokens": 61,
      "embedding": []
    },
    {
      "slug": "func (bo *breachedOutput) HeightHint() uint32 {",
      "content": "func (bo *breachedOutput) HeightHint() uint32 {\n\treturn bo.confHeight\n}\n\n// UnconfParent returns information about a possibly unconfirmed parent tx.",
      "length": 97,
      "tokens": 13,
      "embedding": []
    },
    {
      "slug": "func (bo *breachedOutput) UnconfParent() *input.TxInfo {",
      "content": "func (bo *breachedOutput) UnconfParent() *input.TxInfo {\n\treturn nil\n}\n\n// Add compile-time constraint ensuring breachedOutput implements the Input\n// interface.\nvar _ input.Input = (*breachedOutput)(nil)\n\n// retributionInfo encapsulates all the data needed to sweep all the contested\n// funds within a channel whose contract has been breached by the prior\n// counterparty. This struct is used to create the justice transaction which\n// spends all outputs of the commitment transaction into an output controlled\n// by the wallet.",
      "length": 461,
      "tokens": 72,
      "embedding": []
    },
    {
      "slug": "type retributionInfo struct {",
      "content": "type retributionInfo struct {\n\tcommitHash   chainhash.Hash\n\tchanPoint    wire.OutPoint\n\tchainHash    chainhash.Hash\n\tbreachHeight uint32\n\n\tbreachedOutputs []breachedOutput\n}\n\n// newRetributionInfo constructs a retributionInfo containing all the\n// information required by the breach arbiter to recover funds from breached\n// channels.  The information is primarily populated using the BreachRetribution\n// delivered by the wallet when it detects a channel breach.",
      "length": 422,
      "tokens": 52,
      "embedding": []
    },
    {
      "slug": "func newRetributionInfo(chanPoint *wire.OutPoint,",
      "content": "func newRetributionInfo(chanPoint *wire.OutPoint,\n\tbreachInfo *lnwallet.BreachRetribution) *retributionInfo {\n\n\t// Determine the number of second layer HTLCs we will attempt to sweep.\n\tnHtlcs := len(breachInfo.HtlcRetributions)\n\n\t// Initialize a slice to hold the outputs we will attempt to sweep. The\n\t// maximum capacity of the slice is set to 2+nHtlcs to handle the case\n\t// where the local, remote, and all HTLCs are not dust outputs.  All\n\t// HTLC outputs provided by the wallet are guaranteed to be non-dust,\n\t// though the commitment outputs are conditionally added depending on\n\t// the nil-ness of their sign descriptors.\n\tbreachedOutputs := make([]breachedOutput, 0, nHtlcs+2)\n\n\t// First, record the breach information for the local channel point if\n\t// it is not considered dust, which is signaled by a non-nil sign\n\t// descriptor. Here we use CommitmentNoDelay (or\n\t// CommitmentNoDelayTweakless for newer commitments) since this output\n\t// belongs to us and has no time-based constraints on spending.\n\tif breachInfo.LocalOutputSignDesc != nil {\n\t\twitnessType := input.CommitmentNoDelay\n\t\tif breachInfo.LocalOutputSignDesc.SingleTweak == nil {\n\t\t\twitnessType = input.CommitSpendNoDelayTweakless\n\t\t}\n\n\t\t// If the local delay is non-zero, it means this output is of\n\t\t// the confirmed to_remote type.\n\t\tif breachInfo.LocalDelay != 0 {\n\t\t\twitnessType = input.CommitmentToRemoteConfirmed\n\t\t}\n\n\t\tlocalOutput := makeBreachedOutput(\n\t\t\t&breachInfo.LocalOutpoint,\n\t\t\twitnessType,\n\t\t\t// No second level script as this is a commitment\n\t\t\t// output.\n\t\t\tnil,\n\t\t\tbreachInfo.LocalOutputSignDesc,\n\t\t\tbreachInfo.BreachHeight,\n\t\t)\n\n\t\tbreachedOutputs = append(breachedOutputs, localOutput)\n\t}\n\n\t// Second, record the same information regarding the remote outpoint,\n\t// again if it is not dust, which belongs to the party who tried to\n\t// steal our money! Here we set witnessType of the breachedOutput to\n\t// CommitmentRevoke, since we will be using a revoke key, withdrawing\n\t// the funds from the commitment transaction immediately.\n\tif breachInfo.RemoteOutputSignDesc != nil {\n\t\tremoteOutput := makeBreachedOutput(\n\t\t\t&breachInfo.RemoteOutpoint,\n\t\t\tinput.CommitmentRevoke,\n\t\t\t// No second level script as this is a commitment\n\t\t\t// output.\n\t\t\tnil,\n\t\t\tbreachInfo.RemoteOutputSignDesc,\n\t\t\tbreachInfo.BreachHeight,\n\t\t)\n\n\t\tbreachedOutputs = append(breachedOutputs, remoteOutput)\n\t}\n\n\t// Lastly, for each of the breached HTLC outputs, record each as a\n\t// breached output with the appropriate witness type based on its\n\t// directionality. All HTLC outputs provided by the wallet are assumed\n\t// to be non-dust.\n\tfor i, breachedHtlc := range breachInfo.HtlcRetributions {\n\t\t// Using the breachedHtlc's incoming flag, determine the\n\t\t// appropriate witness type that needs to be generated in order\n\t\t// to sweep the HTLC output.\n\t\tvar htlcWitnessType input.StandardWitnessType\n\t\tif breachedHtlc.IsIncoming {\n\t\t\thtlcWitnessType = input.HtlcAcceptedRevoke\n\t\t} else {\n\t\t\thtlcWitnessType = input.HtlcOfferedRevoke\n\t\t}\n\n\t\thtlcOutput := makeBreachedOutput(\n\t\t\t&breachInfo.HtlcRetributions[i].OutPoint,\n\t\t\thtlcWitnessType,\n\t\t\tbreachInfo.HtlcRetributions[i].SecondLevelWitnessScript,\n\t\t\t&breachInfo.HtlcRetributions[i].SignDesc,\n\t\t\tbreachInfo.BreachHeight)\n\n\t\tbreachedOutputs = append(breachedOutputs, htlcOutput)\n\t}\n\n\treturn &retributionInfo{\n\t\tcommitHash:      breachInfo.BreachTxHash,\n\t\tchainHash:       breachInfo.ChainHash,\n\t\tchanPoint:       *chanPoint,\n\t\tbreachedOutputs: breachedOutputs,\n\t\tbreachHeight:    breachInfo.BreachHeight,\n\t}\n}\n\n// justiceTxVariants is a struct that holds transactions which exacts \"justice\"\n// by sweeping ALL the funds within the channel which we are now entitled to\n// due to a breach of the channel's contract by the counterparty. There are\n// three variants of the justice transaction:\n//\n// 1. The \"normal\" justice tx that spends all breached outputs\n// 2. A tx that spends only the breached to_local output and to_remote output\n// (can be nil if none of these exist)\n// 3. A tx that spends all the breached HTLC outputs, and second-level HTLC\n// outputs (can be nil if no HTLC outputs exist).\n//\n// The reason we create these three variants, is that in certain cases (like\n// with the anchor output HTLC malleability), the channel counter party can pin\n// the HTLC outputs with low fee children, hindering our normal justice tx that\n// attempts to spend these outputs from propagating. In this case we want to\n// spend the to_local output separately, before the CSV lock expires.",
      "length": 4339,
      "tokens": 590,
      "embedding": []
    },
    {
      "slug": "type justiceTxVariants struct {",
      "content": "type justiceTxVariants struct {\n\tspendAll        *wire.MsgTx\n\tspendCommitOuts *wire.MsgTx\n\tspendHTLCs      *wire.MsgTx\n}\n\n// createJusticeTx creates transactions which exacts \"justice\" by sweeping ALL\n// the funds within the channel which we are now entitled to due to a breach of\n// the channel's contract by the counterparty. This function returns a *fully*\n// signed transaction with the witness for each input fully in place.",
      "length": 389,
      "tokens": 58,
      "embedding": []
    },
    {
      "slug": "func (b *BreachArbiter) createJusticeTx(",
      "content": "func (b *BreachArbiter) createJusticeTx(\n\tbreachedOutputs []breachedOutput) (*justiceTxVariants, error) {\n\n\tvar (\n\t\tallInputs    []input.Input\n\t\tcommitInputs []input.Input\n\t\thtlcInputs   []input.Input\n\t)\n\n\tfor i := range breachedOutputs {\n\t\t// Grab locally scoped reference to breached output.\n\t\tinp := &breachedOutputs[i]\n\t\tallInputs = append(allInputs, inp)\n\n\t\t// Check if the input is from an HTLC or a commitment output.\n\t\tif inp.WitnessType() == input.HtlcAcceptedRevoke ||\n\t\t\tinp.WitnessType() == input.HtlcOfferedRevoke ||\n\t\t\tinp.WitnessType() == input.HtlcSecondLevelRevoke {\n\n\t\t\thtlcInputs = append(htlcInputs, inp)\n\t\t} else {\n\t\t\tcommitInputs = append(commitInputs, inp)\n\t\t}\n\t}\n\n\tvar (\n\t\ttxs = &justiceTxVariants{}\n\t\terr error\n\t)\n\n\t// For each group of inputs, create a tx that spends them.\n\ttxs.spendAll, err = b.createSweepTx(allInputs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ttxs.spendCommitOuts, err = b.createSweepTx(commitInputs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ttxs.spendHTLCs, err = b.createSweepTx(htlcInputs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn txs, nil\n}\n\n// createSweepTx creates a tx that sweeps the passed inputs back to our wallet.",
      "length": 1084,
      "tokens": 151,
      "embedding": []
    },
    {
      "slug": "func (b *BreachArbiter) createSweepTx(inputs []input.Input) (*wire.MsgTx,",
      "content": "func (b *BreachArbiter) createSweepTx(inputs []input.Input) (*wire.MsgTx,\n\terror) {\n\n\tif len(inputs) == 0 {\n\t\treturn nil, nil\n\t}\n\n\t// We will assemble the breached outputs into a slice of spendable\n\t// outputs, while simultaneously computing the estimated weight of the\n\t// transaction.\n\tvar (\n\t\tspendableOutputs []input.Input\n\t\tweightEstimate   input.TxWeightEstimator\n\t)\n\n\t// Allocate enough space to potentially hold each of the breached\n\t// outputs in the retribution info.\n\tspendableOutputs = make([]input.Input, 0, len(inputs))\n\n\t// The justice transaction we construct will be a segwit transaction\n\t// that pays to a p2tr output. Components such as the version,\n\t// nLockTime, and output are already included in the TxWeightEstimator.\n\tweightEstimate.AddP2TROutput()\n\n\t// Next, we iterate over the breached outputs contained in the\n\t// retribution info.  For each, we switch over the witness type such\n\t// that we contribute the appropriate weight for each input and\n\t// witness, finally adding to our list of spendable outputs.\n\tfor i := range inputs {\n\t\t// Grab locally scoped reference to breached output.\n\t\tinp := inputs[i]\n\n\t\t// First, determine the appropriate estimated witness weight\n\t\t// for the give witness type of this breached output. If the\n\t\t// witness weight cannot be estimated, we will omit it from the\n\t\t// transaction.\n\t\twitnessWeight, _, err := inp.WitnessType().SizeUpperBound()\n\t\tif err != nil {\n\t\t\tbrarLog.Warnf(\"could not determine witness weight \"+\n\t\t\t\t\"for breached output in retribution info: %v\",\n\t\t\t\terr)\n\t\t\tcontinue\n\t\t}\n\t\tweightEstimate.AddWitnessInput(witnessWeight)\n\n\t\t// Finally, append this input to our list of spendable outputs.\n\t\tspendableOutputs = append(spendableOutputs, inp)\n\t}\n\n\ttxWeight := int64(weightEstimate.Weight())\n\treturn b.sweepSpendableOutputsTxn(txWeight, spendableOutputs...)\n}\n\n// sweepSpendableOutputsTxn creates a signed transaction from a sequence of\n// spendable outputs by sweeping the funds into a single p2wkh output.",
      "length": 1860,
      "tokens": 265,
      "embedding": []
    },
    {
      "slug": "func (b *BreachArbiter) sweepSpendableOutputsTxn(txWeight int64,",
      "content": "func (b *BreachArbiter) sweepSpendableOutputsTxn(txWeight int64,\n\tinputs ...input.Input) (*wire.MsgTx, error) {\n\n\t// First, we obtain a new public key script from the wallet which we'll\n\t// sweep the funds to.\n\t// TODO(roasbeef): possibly create many outputs to minimize change in\n\t// the future?\n\tpkScript, err := b.cfg.GenSweepScript()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Compute the total amount contained in the inputs.\n\tvar totalAmt btcutil.Amount\n\tfor _, inp := range inputs {\n\t\ttotalAmt += btcutil.Amount(inp.SignDesc().Output.Value)\n\t}\n\n\t// We'll actually attempt to target inclusion within the next two\n\t// blocks as we'd like to sweep these funds back into our wallet ASAP.\n\tfeePerKw, err := b.cfg.Estimator.EstimateFeePerKW(justiceTxConfTarget)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttxFee := feePerKw.FeeForWeight(txWeight)\n\n\t// TODO(roasbeef): already start to siphon their funds into fees\n\tsweepAmt := int64(totalAmt - txFee)\n\n\t// With the fee calculated, we can now create the transaction using the\n\t// information gathered above and the provided retribution information.\n\ttxn := wire.NewMsgTx(2)\n\n\t// We begin by adding the output to which our funds will be deposited.\n\ttxn.AddTxOut(&wire.TxOut{\n\t\tPkScript: pkScript,\n\t\tValue:    sweepAmt,\n\t})\n\n\t// Next, we add all of the spendable outputs as inputs to the\n\t// transaction.\n\tfor _, inp := range inputs {\n\t\ttxn.AddTxIn(&wire.TxIn{\n\t\t\tPreviousOutPoint: *inp.OutPoint(),\n\t\t\tSequence:         inp.BlocksToMaturity(),\n\t\t})\n\t}\n\n\t// Before signing the transaction, check to ensure that it meets some\n\t// basic validity requirements.\n\tbtx := btcutil.NewTx(txn)\n\tif err := blockchain.CheckTransactionSanity(btx); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a sighash cache to improve the performance of hashing and\n\t// signing SigHashAll inputs.\n\tprevOutputFetcher, err := input.MultiPrevOutFetcher(inputs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\thashCache := txscript.NewTxSigHashes(txn, prevOutputFetcher)\n\n\t// Create a closure that encapsulates the process of initializing a\n\t// particular output's witness generation function, computing the\n\t// witness, and attaching it to the transaction. This function accepts\n\t// an integer index representing the intended txin index, and the\n\t// breached output from which it will spend.\n\taddWitness := func(idx int, so input.Input) error {\n\t\t// First, we construct a valid witness for this outpoint and\n\t\t// transaction using the SpendableOutput's witness generation\n\t\t// function.\n\t\tinputScript, err := so.CraftInputScript(\n\t\t\tb.cfg.Signer, txn, hashCache, prevOutputFetcher, idx,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Then, we add the witness to the transaction at the\n\t\t// appropriate txin index.\n\t\ttxn.TxIn[idx].Witness = inputScript.Witness\n\n\t\treturn nil\n\t}\n\n\t// Finally, generate a witness for each output and attach it to the\n\t// transaction.\n\tfor i, inp := range inputs {\n\t\tif err := addWitness(i, inp); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn txn, nil\n}\n\n// RetributionStore handles persistence of retribution states to disk and is\n// backed by a boltdb bucket. The primary responsibility of the retribution\n// store is to ensure that we can recover from a restart in the middle of a\n// breached contract retribution.",
      "length": 3087,
      "tokens": 467,
      "embedding": []
    },
    {
      "slug": "type RetributionStore struct {",
      "content": "type RetributionStore struct {\n\tdb kvdb.Backend\n}\n\n// NewRetributionStore creates a new instance of a RetributionStore.",
      "length": 85,
      "tokens": 12,
      "embedding": []
    },
    {
      "slug": "func NewRetributionStore(db kvdb.Backend) *RetributionStore {",
      "content": "func NewRetributionStore(db kvdb.Backend) *RetributionStore {\n\treturn &RetributionStore{\n\t\tdb: db,\n\t}\n}\n\n// Add adds a retribution state to the RetributionStore, which is then persisted\n// to disk.",
      "length": 129,
      "tokens": 22,
      "embedding": []
    },
    {
      "slug": "func (rs *RetributionStore) Add(ret *retributionInfo) error {",
      "content": "func (rs *RetributionStore) Add(ret *retributionInfo) error {\n\treturn kvdb.Update(rs.db, func(tx kvdb.RwTx) error {\n\t\t// If this is our first contract breach, the retributionBucket\n\t\t// won't exist, in which case, we just create a new bucket.\n\t\tretBucket, err := tx.CreateTopLevelBucket(retributionBucket)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvar outBuf bytes.Buffer\n\t\tif err := writeOutpoint(&outBuf, &ret.chanPoint); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvar retBuf bytes.Buffer\n\t\tif err := ret.Encode(&retBuf); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn retBucket.Put(outBuf.Bytes(), retBuf.Bytes())\n\t}, func() {})\n}\n\n// IsBreached queries the retribution store to discern if this channel was\n// previously breached. This is used when connecting to a peer to determine if\n// it is safe to add a link to the htlcswitch, as we should never add a channel\n// that has already been breached.",
      "length": 798,
      "tokens": 126,
      "embedding": []
    },
    {
      "slug": "func (rs *RetributionStore) IsBreached(chanPoint *wire.OutPoint) (bool, error) {",
      "content": "func (rs *RetributionStore) IsBreached(chanPoint *wire.OutPoint) (bool, error) {\n\tvar found bool\n\terr := kvdb.View(rs.db, func(tx kvdb.RTx) error {\n\t\tretBucket := tx.ReadBucket(retributionBucket)\n\t\tif retBucket == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\tvar chanBuf bytes.Buffer\n\t\tif err := writeOutpoint(&chanBuf, chanPoint); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tretInfo := retBucket.Get(chanBuf.Bytes())\n\t\tif retInfo != nil {\n\t\t\tfound = true\n\t\t}\n\n\t\treturn nil\n\t}, func() {\n\t\tfound = false\n\t})\n\n\treturn found, err\n}\n\n// Remove removes a retribution state and finalized justice transaction by\n// channel point  from the retribution store.",
      "length": 515,
      "tokens": 79,
      "embedding": []
    },
    {
      "slug": "func (rs *RetributionStore) Remove(chanPoint *wire.OutPoint) error {",
      "content": "func (rs *RetributionStore) Remove(chanPoint *wire.OutPoint) error {\n\treturn kvdb.Update(rs.db, func(tx kvdb.RwTx) error {\n\t\tretBucket := tx.ReadWriteBucket(retributionBucket)\n\n\t\t// We return an error if the bucket is not already created,\n\t\t// since normal operation of the breach arbiter should never try\n\t\t// to remove a finalized retribution state that is not already\n\t\t// stored in the db.\n\t\tif retBucket == nil {\n\t\t\treturn errors.New(\"unable to remove retribution \" +\n\t\t\t\t\"because the retribution bucket doesn't exist\")\n\t\t}\n\n\t\t// Serialize the channel point we are intending to remove.\n\t\tvar chanBuf bytes.Buffer\n\t\tif err := writeOutpoint(&chanBuf, chanPoint); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tchanBytes := chanBuf.Bytes()\n\n\t\t// Remove the persisted retribution info and finalized justice\n\t\t// transaction.\n\t\treturn retBucket.Delete(chanBytes)\n\t}, func() {})\n}\n\n// ForAll iterates through all stored retributions and executes the passed\n// callback function on each retribution.",
      "length": 888,
      "tokens": 129,
      "embedding": []
    },
    {
      "slug": "func (rs *RetributionStore) ForAll(cb func(*retributionInfo) error,",
      "content": "func (rs *RetributionStore) ForAll(cb func(*retributionInfo) error,\n\treset func()) error {\n\n\treturn kvdb.View(rs.db, func(tx kvdb.RTx) error {\n\t\t// If the bucket does not exist, then there are no pending\n\t\t// retributions.\n\t\tretBucket := tx.ReadBucket(retributionBucket)\n\t\tif retBucket == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Otherwise, we fetch each serialized retribution info,\n\t\t// deserialize it, and execute the passed in callback function\n\t\t// on it.\n\t\treturn retBucket.ForEach(func(_, retBytes []byte) error {\n\t\t\tret := &retributionInfo{}\n\t\t\terr := ret.Decode(bytes.NewBuffer(retBytes))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\treturn cb(ret)\n\t\t})\n\t}, reset)\n}\n\n// Encode serializes the retribution into the passed byte stream.",
      "length": 636,
      "tokens": 92,
      "embedding": []
    },
    {
      "slug": "func (ret *retributionInfo) Encode(w io.Writer) error {",
      "content": "func (ret *retributionInfo) Encode(w io.Writer) error {\n\tvar scratch [4]byte\n\n\tif _, err := w.Write(ret.commitHash[:]); err != nil {\n\t\treturn err\n\t}\n\n\tif err := writeOutpoint(w, &ret.chanPoint); err != nil {\n\t\treturn err\n\t}\n\n\tif _, err := w.Write(ret.chainHash[:]); err != nil {\n\t\treturn err\n\t}\n\n\tbinary.BigEndian.PutUint32(scratch[:], ret.breachHeight)\n\tif _, err := w.Write(scratch[:]); err != nil {\n\t\treturn err\n\t}\n\n\tnOutputs := len(ret.breachedOutputs)\n\tif err := wire.WriteVarInt(w, 0, uint64(nOutputs)); err != nil {\n\t\treturn err\n\t}\n\n\tfor _, output := range ret.breachedOutputs {\n\t\tif err := output.Encode(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Decode deserializes a retribution from the passed byte stream.",
      "length": 642,
      "tokens": 101,
      "embedding": []
    },
    {
      "slug": "func (ret *retributionInfo) Decode(r io.Reader) error {",
      "content": "func (ret *retributionInfo) Decode(r io.Reader) error {\n\tvar scratch [32]byte\n\n\tif _, err := io.ReadFull(r, scratch[:]); err != nil {\n\t\treturn err\n\t}\n\thash, err := chainhash.NewHash(scratch[:])\n\tif err != nil {\n\t\treturn err\n\t}\n\tret.commitHash = *hash\n\n\tif err := readOutpoint(r, &ret.chanPoint); err != nil {\n\t\treturn err\n\t}\n\n\tif _, err := io.ReadFull(r, scratch[:]); err != nil {\n\t\treturn err\n\t}\n\tchainHash, err := chainhash.NewHash(scratch[:])\n\tif err != nil {\n\t\treturn err\n\t}\n\tret.chainHash = *chainHash\n\n\tif _, err := io.ReadFull(r, scratch[:4]); err != nil {\n\t\treturn err\n\t}\n\tret.breachHeight = binary.BigEndian.Uint32(scratch[:4])\n\n\tnOutputsU64, err := wire.ReadVarInt(r, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\tnOutputs := int(nOutputsU64)\n\n\tret.breachedOutputs = make([]breachedOutput, nOutputs)\n\tfor i := range ret.breachedOutputs {\n\t\tif err := ret.breachedOutputs[i].Decode(r); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Encode serializes a breachedOutput into the passed byte stream.",
      "length": 900,
      "tokens": 138,
      "embedding": []
    },
    {
      "slug": "func (bo *breachedOutput) Encode(w io.Writer) error {",
      "content": "func (bo *breachedOutput) Encode(w io.Writer) error {\n\tvar scratch [8]byte\n\n\tbinary.BigEndian.PutUint64(scratch[:8], uint64(bo.amt))\n\tif _, err := w.Write(scratch[:8]); err != nil {\n\t\treturn err\n\t}\n\n\tif err := writeOutpoint(w, &bo.outpoint); err != nil {\n\t\treturn err\n\t}\n\n\terr := input.WriteSignDescriptor(w, &bo.signDesc)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = wire.WriteVarBytes(w, 0, bo.secondLevelWitnessScript)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tbinary.BigEndian.PutUint16(scratch[:2], uint16(bo.witnessType))\n\tif _, err := w.Write(scratch[:2]); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Decode deserializes a breachedOutput from the passed byte stream.",
      "length": 583,
      "tokens": 81,
      "embedding": []
    },
    {
      "slug": "func (bo *breachedOutput) Decode(r io.Reader) error {",
      "content": "func (bo *breachedOutput) Decode(r io.Reader) error {\n\tvar scratch [8]byte\n\n\tif _, err := io.ReadFull(r, scratch[:8]); err != nil {\n\t\treturn err\n\t}\n\tbo.amt = btcutil.Amount(binary.BigEndian.Uint64(scratch[:8]))\n\n\tif err := readOutpoint(r, &bo.outpoint); err != nil {\n\t\treturn err\n\t}\n\n\tif err := input.ReadSignDescriptor(r, &bo.signDesc); err != nil {\n\t\treturn err\n\t}\n\n\twScript, err := wire.ReadVarBytes(r, 0, 1000, \"witness script\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tbo.secondLevelWitnessScript = wScript\n\n\tif _, err := io.ReadFull(r, scratch[:2]); err != nil {\n\t\treturn err\n\t}\n\tbo.witnessType = input.StandardWitnessType(\n\t\tbinary.BigEndian.Uint16(scratch[:2]),\n\t)\n\n\treturn nil\n}\n",
      "length": 597,
      "tokens": 83,
      "embedding": []
    }
  ]
}