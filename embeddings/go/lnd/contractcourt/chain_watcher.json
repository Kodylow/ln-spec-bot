{
  "filepath": "../implementations/go/lnd/contractcourt/chain_watcher.go",
  "package": "contractcourt",
  "sections": [
    {
      "slug": "type LocalUnilateralCloseInfo struct {",
      "content": "type LocalUnilateralCloseInfo struct {\n\t*chainntnfs.SpendDetail\n\t*lnwallet.LocalForceCloseSummary\n\t*channeldb.ChannelCloseSummary\n\n\t// CommitSet is the set of known valid commitments at the time the\n\t// remote party's commitment hit the chain.\n\tCommitSet CommitSet\n}\n\n// CooperativeCloseInfo encapsulates all the information we need to act on a\n// cooperative close that gets confirmed.",
      "length": 337,
      "tokens": 44,
      "embedding": []
    },
    {
      "slug": "type CooperativeCloseInfo struct {",
      "content": "type CooperativeCloseInfo struct {\n\t*channeldb.ChannelCloseSummary\n}\n\n// RemoteUnilateralCloseInfo wraps the normal UnilateralCloseSummary to couple\n// the CommitSet at the time of channel closure.",
      "length": 158,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "type RemoteUnilateralCloseInfo struct {",
      "content": "type RemoteUnilateralCloseInfo struct {\n\t*lnwallet.UnilateralCloseSummary\n\n\t// CommitSet is the set of known valid commitments at the time the\n\t// remote party's commitment hit the chain.\n\tCommitSet CommitSet\n}\n\n// BreachResolution wraps the outpoint of the breached channel.",
      "length": 228,
      "tokens": 33,
      "embedding": []
    },
    {
      "slug": "type BreachResolution struct {",
      "content": "type BreachResolution struct {\n\tFundingOutPoint wire.OutPoint\n}\n\n// BreachCloseInfo wraps the BreachResolution with a CommitSet for the latest,\n// non-breached state, with the AnchorResolution for the breached state.",
      "length": 181,
      "tokens": 24,
      "embedding": []
    },
    {
      "slug": "type BreachCloseInfo struct {",
      "content": "type BreachCloseInfo struct {\n\t*BreachResolution\n\t*lnwallet.AnchorResolution\n\n\t// CommitHash is the hash of the commitment transaction.\n\tCommitHash chainhash.Hash\n\n\t// CommitSet is the set of known valid commitments at the time the\n\t// breach occurred on-chain.\n\tCommitSet CommitSet\n\n\t// CloseSummary gives the recipient of the BreachCloseInfo information\n\t// to mark the channel closed in the database.\n\tCloseSummary channeldb.ChannelCloseSummary\n}\n\n// CommitSet is a collection of the set of known valid commitments at a given\n// instant. If ConfCommitKey is set, then the commitment identified by the\n// HtlcSetKey has hit the chain. This struct will be used to examine all live\n// HTLCs to determine if any additional actions need to be made based on the\n// remote party's commitments.",
      "length": 740,
      "tokens": 114,
      "embedding": []
    },
    {
      "slug": "type CommitSet struct {",
      "content": "type CommitSet struct {\n\t// ConfCommitKey if non-nil, identifies the commitment that was\n\t// confirmed in the chain.\n\tConfCommitKey *HtlcSetKey\n\n\t// HtlcSets stores the set of all known active HTLC for each active\n\t// commitment at the time of channel closure.\n\tHtlcSets map[HtlcSetKey][]channeldb.HTLC\n}\n\n// IsEmpty returns true if there are no HTLCs at all within all commitments\n// that are a part of this commitment diff.",
      "length": 391,
      "tokens": 63,
      "embedding": []
    },
    {
      "slug": "func (c *CommitSet) IsEmpty() bool {",
      "content": "func (c *CommitSet) IsEmpty() bool {\n\tif c == nil {\n\t\treturn true\n\t}\n\n\tfor _, htlcs := range c.HtlcSets {\n\t\tif len(htlcs) != 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\n// toActiveHTLCSets returns the set of all active HTLCs across all commitment\n// transactions.",
      "length": 212,
      "tokens": 41,
      "embedding": []
    },
    {
      "slug": "func (c *CommitSet) toActiveHTLCSets() map[HtlcSetKey]htlcSet {",
      "content": "func (c *CommitSet) toActiveHTLCSets() map[HtlcSetKey]htlcSet {\n\thtlcSets := make(map[HtlcSetKey]htlcSet)\n\n\tfor htlcSetKey, htlcs := range c.HtlcSets {\n\t\thtlcSets[htlcSetKey] = newHtlcSet(htlcs)\n\t}\n\n\treturn htlcSets\n}\n\n// ChainEventSubscription is a struct that houses a subscription to be notified\n// for any on-chain events related to a channel. There are three types of\n// possible on-chain events: a cooperative channel closure, a unilateral\n// channel closure, and a channel breach. The fourth type: a force close is\n// locally initiated, so we don't provide any event stream for said event.",
      "length": 519,
      "tokens": 80,
      "embedding": []
    },
    {
      "slug": "type ChainEventSubscription struct {",
      "content": "type ChainEventSubscription struct {\n\t// ChanPoint is that channel that chain events will be dispatched for.\n\tChanPoint wire.OutPoint\n\n\t// RemoteUnilateralClosure is a channel that will be sent upon in the\n\t// event that the remote party's commitment transaction is confirmed.\n\tRemoteUnilateralClosure chan *RemoteUnilateralCloseInfo\n\n\t// LocalUnilateralClosure is a channel that will be sent upon in the\n\t// event that our commitment transaction is confirmed.\n\tLocalUnilateralClosure chan *LocalUnilateralCloseInfo\n\n\t// CooperativeClosure is a signal that will be sent upon once a\n\t// cooperative channel closure has been detected confirmed.\n\tCooperativeClosure chan *CooperativeCloseInfo\n\n\t// ContractBreach is a channel that will be sent upon if we detect a\n\t// contract breach. The struct sent across the channel contains all the\n\t// material required to bring the cheating channel peer to justice.\n\tContractBreach chan *BreachCloseInfo\n\n\t// Cancel cancels the subscription to the event stream for a particular\n\t// channel. This method should be called once the caller no longer needs to\n\t// be notified of any on-chain events for a particular channel.\n\tCancel func()\n}\n\n// chainWatcherConfig encapsulates all the necessary functions and interfaces\n// needed to watch and act on on-chain events for a particular channel.",
      "length": 1260,
      "tokens": 187,
      "embedding": []
    },
    {
      "slug": "type chainWatcherConfig struct {",
      "content": "type chainWatcherConfig struct {\n\t// chanState is a snapshot of the persistent state of the channel that\n\t// we're watching. In the event of an on-chain event, we'll query the\n\t// database to ensure that we act using the most up to date state.\n\tchanState *channeldb.OpenChannel\n\n\t// notifier is a reference to the channel notifier that we'll use to be\n\t// notified of output spends and when transactions are confirmed.\n\tnotifier chainntnfs.ChainNotifier\n\n\t// signer is the main signer instances that will be responsible for\n\t// signing any HTLC and commitment transaction generated by the state\n\t// machine.\n\tsigner input.Signer\n\n\t// contractBreach is a method that will be called by the watcher if it\n\t// detects that a contract breach transaction has been confirmed. It\n\t// will only return a non-nil error when the breachArbiter has\n\t// preserved the necessary breach info for this channel point.\n\tcontractBreach func(*lnwallet.BreachRetribution) error\n\n\t// isOurAddr is a function that returns true if the passed address is\n\t// known to us.\n\tisOurAddr func(btcutil.Address) bool\n\n\t// extractStateNumHint extracts the encoded state hint using the passed\n\t// obfuscater. This is used by the chain watcher to identify which\n\t// state was broadcast and confirmed on-chain.\n\textractStateNumHint func(*wire.MsgTx, [lnwallet.StateHintSize]byte) uint64\n}\n\n// chainWatcher is a system that's assigned to every active channel. The duty\n// of this system is to watch the chain for spends of the channels chan point.\n// If a spend is detected then with chain watcher will notify all subscribers\n// that the channel has been closed, and also give them the materials necessary\n// to sweep the funds of the channel on chain eventually.",
      "length": 1657,
      "tokens": 266,
      "embedding": []
    },
    {
      "slug": "type chainWatcher struct {",
      "content": "type chainWatcher struct {\n\tstarted int32 // To be used atomically.\n\tstopped int32 // To be used atomically.\n\n\tquit chan struct{}\n\twg   sync.WaitGroup\n\n\tcfg chainWatcherConfig\n\n\t// stateHintObfuscator is a 48-bit state hint that's used to obfuscate\n\t// the current state number on the commitment transactions.\n\tstateHintObfuscator [lnwallet.StateHintSize]byte\n\n\t// All the fields below are protected by this mutex.\n\tsync.Mutex\n\n\t// clientID is an ephemeral counter used to keep track of each\n\t// individual client subscription.\n\tclientID uint64\n\n\t// clientSubscriptions is a map that keeps track of all the active\n\t// client subscriptions for events related to this channel.\n\tclientSubscriptions map[uint64]*ChainEventSubscription\n}\n\n// newChainWatcher returns a new instance of a chainWatcher for a channel given\n// the chan point to watch, and also a notifier instance that will allow us to\n// detect on chain events.",
      "length": 866,
      "tokens": 130,
      "embedding": []
    },
    {
      "slug": "func newChainWatcher(cfg chainWatcherConfig) (*chainWatcher, error) {",
      "content": "func newChainWatcher(cfg chainWatcherConfig) (*chainWatcher, error) {\n\t// In order to be able to detect the nature of a potential channel\n\t// closure we'll need to reconstruct the state hint bytes used to\n\t// obfuscate the commitment state number encoded in the lock time and\n\t// sequence fields.\n\tvar stateHint [lnwallet.StateHintSize]byte\n\tchanState := cfg.chanState\n\tif chanState.IsInitiator {\n\t\tstateHint = lnwallet.DeriveStateHintObfuscator(\n\t\t\tchanState.LocalChanCfg.PaymentBasePoint.PubKey,\n\t\t\tchanState.RemoteChanCfg.PaymentBasePoint.PubKey,\n\t\t)\n\t} else {\n\t\tstateHint = lnwallet.DeriveStateHintObfuscator(\n\t\t\tchanState.RemoteChanCfg.PaymentBasePoint.PubKey,\n\t\t\tchanState.LocalChanCfg.PaymentBasePoint.PubKey,\n\t\t)\n\t}\n\n\treturn &chainWatcher{\n\t\tcfg:                 cfg,\n\t\tstateHintObfuscator: stateHint,\n\t\tquit:                make(chan struct{}),\n\t\tclientSubscriptions: make(map[uint64]*ChainEventSubscription),\n\t}, nil\n}\n\n// Start starts all goroutines that the chainWatcher needs to perform its\n// duties.",
      "length": 917,
      "tokens": 94,
      "embedding": []
    },
    {
      "slug": "func (c *chainWatcher) Start() error {",
      "content": "func (c *chainWatcher) Start() error {\n\tif !atomic.CompareAndSwapInt32(&c.started, 0, 1) {\n\t\treturn nil\n\t}\n\n\tchanState := c.cfg.chanState\n\tlog.Debugf(\"Starting chain watcher for ChannelPoint(%v)\",\n\t\tchanState.FundingOutpoint)\n\n\t// First, we'll register for a notification to be dispatched if the\n\t// funding output is spent.\n\tfundingOut := &chanState.FundingOutpoint\n\n\t// As a height hint, we'll try to use the opening height, but if the\n\t// channel isn't yet open, then we'll use the height it was broadcast\n\t// at. This may be an unconfirmed zero-conf channel.\n\theightHint := c.cfg.chanState.ShortChanID().BlockHeight\n\tif heightHint == 0 {\n\t\theightHint = chanState.BroadcastHeight()\n\t}\n\n\t// Since no zero-conf state is stored in a channel backup, the below\n\t// logic will not be triggered for restored, zero-conf channels. Set\n\t// the height hint for zero-conf channels.\n\tif chanState.IsZeroConf() {\n\t\tif chanState.ZeroConfConfirmed() {\n\t\t\t// If the zero-conf channel is confirmed, we'll use the\n\t\t\t// confirmed SCID's block height.\n\t\t\theightHint = chanState.ZeroConfRealScid().BlockHeight\n\t\t} else {\n\t\t\t// The zero-conf channel is unconfirmed. We'll need to\n\t\t\t// use the FundingBroadcastHeight.\n\t\t\theightHint = chanState.BroadcastHeight()\n\t\t}\n\t}\n\n\tlocalKey := chanState.LocalChanCfg.MultiSigKey.PubKey.SerializeCompressed()\n\tremoteKey := chanState.RemoteChanCfg.MultiSigKey.PubKey.SerializeCompressed()\n\tmultiSigScript, err := input.GenMultiSigScript(\n\t\tlocalKey, remoteKey,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\tpkScript, err := input.WitnessScriptHash(multiSigScript)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tspendNtfn, err := c.cfg.notifier.RegisterSpendNtfn(\n\t\tfundingOut, pkScript, heightHint,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// With the spend notification obtained, we'll now dispatch the\n\t// closeObserver which will properly react to any changes.\n\tc.wg.Add(1)\n\tgo c.closeObserver(spendNtfn)\n\n\treturn nil\n}\n\n// Stop signals the close observer to gracefully exit.",
      "length": 1870,
      "tokens": 245,
      "embedding": []
    },
    {
      "slug": "func (c *chainWatcher) Stop() error {",
      "content": "func (c *chainWatcher) Stop() error {\n\tif !atomic.CompareAndSwapInt32(&c.stopped, 0, 1) {\n\t\treturn nil\n\t}\n\n\tclose(c.quit)\n\n\tc.wg.Wait()\n\n\treturn nil\n}\n\n// SubscribeChannelEvents returns an active subscription to the set of channel\n// events for the channel watched by this chain watcher. Once clients no longer\n// require the subscription, they should call the Cancel() method to allow the\n// watcher to regain those committed resources.",
      "length": 385,
      "tokens": 58,
      "embedding": []
    },
    {
      "slug": "func (c *chainWatcher) SubscribeChannelEvents() *ChainEventSubscription {",
      "content": "func (c *chainWatcher) SubscribeChannelEvents() *ChainEventSubscription {\n\n\tc.Lock()\n\tclientID := c.clientID\n\tc.clientID++\n\tc.Unlock()\n\n\tlog.Debugf(\"New ChainEventSubscription(id=%v) for ChannelPoint(%v)\",\n\t\tclientID, c.cfg.chanState.FundingOutpoint)\n\n\tsub := &ChainEventSubscription{\n\t\tChanPoint:               c.cfg.chanState.FundingOutpoint,\n\t\tRemoteUnilateralClosure: make(chan *RemoteUnilateralCloseInfo, 1),\n\t\tLocalUnilateralClosure:  make(chan *LocalUnilateralCloseInfo, 1),\n\t\tCooperativeClosure:      make(chan *CooperativeCloseInfo, 1),\n\t\tContractBreach:          make(chan *BreachCloseInfo, 1),\n\t\tCancel: func() {\n\t\t\tc.Lock()\n\t\t\tdelete(c.clientSubscriptions, clientID)\n\t\t\tc.Unlock()\n\t\t},\n\t}\n\n\tc.Lock()\n\tc.clientSubscriptions[clientID] = sub\n\tc.Unlock()\n\n\treturn sub\n}\n\n// handleUnknownLocalState checks whether the passed spend _could_ be a local\n// state that for some reason is unknown to us. This could be a state published\n// by us before we lost state, which we will try to sweep. Or it could be one\n// of our revoked states that somehow made it to the chain. If that's the case\n// we cannot really hope that we'll be able to get our money back, but we'll\n// try to sweep it anyway. If this is not an unknown local state, false is\n// returned.",
      "length": 1149,
      "tokens": 145,
      "embedding": []
    },
    {
      "slug": "func (c *chainWatcher) handleUnknownLocalState(",
      "content": "func (c *chainWatcher) handleUnknownLocalState(\n\tcommitSpend *chainntnfs.SpendDetail, broadcastStateNum uint64,\n\tchainSet *chainSet) (bool, error) {\n\n\t// If the spend was a local commitment, at this point it must either be\n\t// a past state (we breached!) or a future state (we lost state!). In\n\t// either case, the only thing we can do is to attempt to sweep what is\n\t// there.\n\n\t// First, we'll re-derive our commitment point for this state since\n\t// this is what we use to randomize each of the keys for this state.\n\tcommitSecret, err := c.cfg.chanState.RevocationProducer.AtIndex(\n\t\tbroadcastStateNum,\n\t)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tcommitPoint := input.ComputeCommitmentPoint(commitSecret[:])\n\n\t// Now that we have the commit point, we'll derive the tweaked local\n\t// and remote keys for this state. We use our point as only we can\n\t// revoke our own commitment.\n\tcommitKeyRing := lnwallet.DeriveCommitmentKeys(\n\t\tcommitPoint, true, c.cfg.chanState.ChanType,\n\t\t&c.cfg.chanState.LocalChanCfg, &c.cfg.chanState.RemoteChanCfg,\n\t)\n\n\t// With the keys derived, we'll construct the remote script that'll be\n\t// present if they have a non-dust balance on the commitment.\n\tvar leaseExpiry uint32\n\tif c.cfg.chanState.ChanType.HasLeaseExpiration() {\n\t\tleaseExpiry = c.cfg.chanState.ThawHeight\n\t}\n\tremoteScript, _, err := lnwallet.CommitScriptToRemote(\n\t\tc.cfg.chanState.ChanType, c.cfg.chanState.IsInitiator,\n\t\tcommitKeyRing.ToRemoteKey, leaseExpiry,\n\t)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\t// Next, we'll derive our script that includes the revocation base for\n\t// the remote party allowing them to claim this output before the CSV\n\t// delay if we breach.\n\tlocalScript, err := lnwallet.CommitScriptToSelf(\n\t\tc.cfg.chanState.ChanType, c.cfg.chanState.IsInitiator,\n\t\tcommitKeyRing.ToLocalKey, commitKeyRing.RevocationKey,\n\t\tuint32(c.cfg.chanState.LocalChanCfg.CsvDelay), leaseExpiry,\n\t)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\t// With all our scripts assembled, we'll examine the outputs of the\n\t// commitment transaction to determine if this is a local force close\n\t// or not.\n\tourCommit := false\n\tfor _, output := range commitSpend.SpendingTx.TxOut {\n\t\tpkScript := output.PkScript\n\n\t\tswitch {\n\t\tcase bytes.Equal(localScript.PkScript, pkScript):\n\t\t\tourCommit = true\n\n\t\tcase bytes.Equal(remoteScript.PkScript, pkScript):\n\t\t\tourCommit = true\n\t\t}\n\t}\n\n\t// If the script is not present, this cannot be our commit.\n\tif !ourCommit {\n\t\treturn false, nil\n\t}\n\n\tlog.Warnf(\"Detected local unilateral close of unknown state %v \"+\n\t\t\"(our state=%v)\", broadcastStateNum,\n\t\tchainSet.localCommit.CommitHeight)\n\n\t// If this is our commitment transaction, then we try to act even\n\t// though we won't be able to sweep HTLCs.\n\tchainSet.commitSet.ConfCommitKey = &LocalHtlcSet\n\tif err := c.dispatchLocalForceClose(\n\t\tcommitSpend, broadcastStateNum, chainSet.commitSet,\n\t); err != nil {\n\t\treturn false, fmt.Errorf(\"unable to handle local\"+\n\t\t\t\"close for chan_point=%v: %v\",\n\t\t\tc.cfg.chanState.FundingOutpoint, err)\n\t}\n\n\treturn true, nil\n}\n\n// chainSet includes all the information we need to dispatch a channel close\n// event to any subscribers.",
      "length": 2995,
      "tokens": 404,
      "embedding": []
    },
    {
      "slug": "type chainSet struct {",
      "content": "type chainSet struct {\n\t// remoteStateNum is the commitment number of the lowest valid\n\t// commitment the remote party holds from our PoV. This value is used\n\t// to determine if the remote party is playing a state that's behind,\n\t// in line, or ahead of the latest state we know for it.\n\tremoteStateNum uint64\n\n\t// commitSet includes information pertaining to the set of active HTLCs\n\t// on each commitment.\n\tcommitSet CommitSet\n\n\t// remoteCommit is the current commitment of the remote party.\n\tremoteCommit channeldb.ChannelCommitment\n\n\t// localCommit is our current commitment.\n\tlocalCommit channeldb.ChannelCommitment\n\n\t// remotePendingCommit points to the dangling commitment of the remote\n\t// party, if it exists. If there's no dangling commitment, then this\n\t// pointer will be nil.\n\tremotePendingCommit *channeldb.ChannelCommitment\n}\n\n// newChainSet creates a new chainSet given the current up to date channel\n// state.",
      "length": 880,
      "tokens": 133,
      "embedding": []
    },
    {
      "slug": "func newChainSet(chanState *channeldb.OpenChannel) (*chainSet, error) {",
      "content": "func newChainSet(chanState *channeldb.OpenChannel) (*chainSet, error) {\n\t// First, we'll grab the current unrevoked commitments for ourselves\n\t// and the remote party.\n\tlocalCommit, remoteCommit, err := chanState.LatestCommitments()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to fetch channel state for \"+\n\t\t\t\"chan_point=%v\", chanState.FundingOutpoint)\n\t}\n\n\tlog.Tracef(\"ChannelPoint(%v): local_commit_type=%v, local_commit=%v\",\n\t\tchanState.FundingOutpoint, chanState.ChanType,\n\t\tspew.Sdump(localCommit))\n\tlog.Tracef(\"ChannelPoint(%v): remote_commit_type=%v, remote_commit=%v\",\n\t\tchanState.FundingOutpoint, chanState.ChanType,\n\t\tspew.Sdump(remoteCommit))\n\n\t// Fetch the current known commit height for the remote party, and\n\t// their pending commitment chain tip if it exists.\n\tremoteStateNum := remoteCommit.CommitHeight\n\tremoteChainTip, err := chanState.RemoteCommitChainTip()\n\tif err != nil && err != channeldb.ErrNoPendingCommit {\n\t\treturn nil, fmt.Errorf(\"unable to obtain chain tip for \"+\n\t\t\t\"ChannelPoint(%v): %v\",\n\t\t\tchanState.FundingOutpoint, err)\n\t}\n\n\t// Now that we have all the possible valid commitments, we'll make the\n\t// CommitSet the ChannelArbitrator will need in order to carry out its\n\t// duty.\n\tcommitSet := CommitSet{\n\t\tHtlcSets: map[HtlcSetKey][]channeldb.HTLC{\n\t\t\tLocalHtlcSet:  localCommit.Htlcs,\n\t\t\tRemoteHtlcSet: remoteCommit.Htlcs,\n\t\t},\n\t}\n\n\tvar remotePendingCommit *channeldb.ChannelCommitment\n\tif remoteChainTip != nil {\n\t\tremotePendingCommit = &remoteChainTip.Commitment\n\t\tlog.Tracef(\"ChannelPoint(%v): remote_pending_commit_type=%v, \"+\n\t\t\t\"remote_pending_commit=%v\", chanState.FundingOutpoint,\n\t\t\tchanState.ChanType,\n\t\t\tspew.Sdump(remoteChainTip.Commitment))\n\n\t\thtlcs := remoteChainTip.Commitment.Htlcs\n\t\tcommitSet.HtlcSets[RemotePendingHtlcSet] = htlcs\n\t}\n\n\t// We'll now retrieve the latest state of the revocation store so we\n\t// can populate the revocation information within the channel state\n\t// object that we have.\n\t//\n\t// TODO(roasbeef): mutation is bad mkay\n\t_, err = chanState.RemoteRevocationStore()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to fetch revocation state for \"+\n\t\t\t\"chan_point=%v\", chanState.FundingOutpoint)\n\t}\n\n\treturn &chainSet{\n\t\tremoteStateNum:      remoteStateNum,\n\t\tcommitSet:           commitSet,\n\t\tlocalCommit:         *localCommit,\n\t\tremoteCommit:        *remoteCommit,\n\t\tremotePendingCommit: remotePendingCommit,\n\t}, nil\n}\n\n// closeObserver is a dedicated goroutine that will watch for any closes of the\n// channel that it's watching on chain. In the event of an on-chain event, the\n// close observer will assembled the proper materials required to claim the\n// funds of the channel on-chain (if required), then dispatch these as\n// notifications to all subscribers.",
      "length": 2604,
      "tokens": 292,
      "embedding": []
    },
    {
      "slug": "func (c *chainWatcher) closeObserver(spendNtfn *chainntnfs.SpendEvent) {",
      "content": "func (c *chainWatcher) closeObserver(spendNtfn *chainntnfs.SpendEvent) {\n\tdefer c.wg.Done()\n\n\tlog.Infof(\"Close observer for ChannelPoint(%v) active\",\n\t\tc.cfg.chanState.FundingOutpoint)\n\n\tselect {\n\t// We've detected a spend of the channel onchain! Depending on the type\n\t// of spend, we'll act accordingly, so we'll examine the spending\n\t// transaction to determine what we should do.\n\t//\n\t// TODO(Roasbeef): need to be able to ensure this only triggers\n\t// on confirmation, to ensure if multiple txns are broadcast, we\n\t// act on the one that's timestamped\n\tcase commitSpend, ok := <-spendNtfn.Spend:\n\t\t// If the channel was closed, then this means that the notifier\n\t\t// exited, so we will as well.\n\t\tif !ok {\n\t\t\treturn\n\t\t}\n\n\t\t// Otherwise, the remote party might have broadcast a prior\n\t\t// revoked state...!!!\n\t\tcommitTxBroadcast := commitSpend.SpendingTx\n\n\t\t// First, we'll construct the chainset which includes all the\n\t\t// data we need to dispatch an event to our subscribers about\n\t\t// this possible channel close event.\n\t\tchainSet, err := newChainSet(c.cfg.chanState)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"unable to create commit set: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\t// Decode the state hint encoded within the commitment\n\t\t// transaction to determine if this is a revoked state or not.\n\t\tobfuscator := c.stateHintObfuscator\n\t\tbroadcastStateNum := c.cfg.extractStateNumHint(\n\t\t\tcommitTxBroadcast, obfuscator,\n\t\t)\n\n\t\t// We'll go on to check whether it could be our own commitment\n\t\t// that was published and know is confirmed.\n\t\tok, err = c.handleKnownLocalState(\n\t\t\tcommitSpend, broadcastStateNum, chainSet,\n\t\t)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Unable to handle known local state: %v\",\n\t\t\t\terr)\n\t\t\treturn\n\t\t}\n\n\t\tif ok {\n\t\t\treturn\n\t\t}\n\n\t\t// Now that we know it is neither a non-cooperative closure nor\n\t\t// a local close with the latest state, we check if it is the\n\t\t// remote that closed with any prior or current state.\n\t\tok, err = c.handleKnownRemoteState(\n\t\t\tcommitSpend, broadcastStateNum, chainSet,\n\t\t)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Unable to handle known remote state: %v\",\n\t\t\t\terr)\n\t\t\treturn\n\t\t}\n\n\t\tif ok {\n\t\t\treturn\n\t\t}\n\n\t\t// Next, we'll check to see if this is a cooperative channel\n\t\t// closure or not. This is characterized by having an input\n\t\t// sequence number that's finalized. This won't happen with\n\t\t// regular commitment transactions due to the state hint\n\t\t// encoding scheme.\n\t\tif commitTxBroadcast.TxIn[0].Sequence == wire.MaxTxInSequenceNum {\n\t\t\t// TODO(roasbeef): rare but possible, need itest case\n\t\t\t// for\n\t\t\terr := c.dispatchCooperativeClose(commitSpend)\n\t\t\tif err != nil {\n\t\t\t\tlog.Errorf(\"unable to handle co op close: %v\", err)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tlog.Warnf(\"Unknown commitment broadcast for \"+\n\t\t\t\"ChannelPoint(%v) \", c.cfg.chanState.FundingOutpoint)\n\n\t\t// We'll try to recover as best as possible from losing state.\n\t\t// We first check if this was a local unknown state. This could\n\t\t// happen if we force close, then lose state or attempt\n\t\t// recovery before the commitment confirms.\n\t\tok, err = c.handleUnknownLocalState(\n\t\t\tcommitSpend, broadcastStateNum, chainSet,\n\t\t)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Unable to handle known local state: %v\",\n\t\t\t\terr)\n\t\t\treturn\n\t\t}\n\n\t\tif ok {\n\t\t\treturn\n\t\t}\n\n\t\t// Since it was neither a known remote state, nor a local state\n\t\t// that was published, it most likely mean we lost state and\n\t\t// the remote node closed. In this case we must start the DLP\n\t\t// protocol in hope of getting our money back.\n\t\tok, err = c.handleUnknownRemoteState(\n\t\t\tcommitSpend, broadcastStateNum, chainSet,\n\t\t)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Unable to handle unknown remote state: %v\",\n\t\t\t\terr)\n\t\t\treturn\n\t\t}\n\n\t\tif ok {\n\t\t\treturn\n\t\t}\n\n\t\tlog.Warnf(\"Unable to handle spending tx %v of channel point %v\",\n\t\t\tcommitTxBroadcast.TxHash(), c.cfg.chanState.FundingOutpoint)\n\t\treturn\n\n\t// The chainWatcher has been signalled to exit, so we'll do so now.\n\tcase <-c.quit:\n\t\treturn\n\t}\n}\n\n// handleKnownLocalState checks whether the passed spend is a local state that\n// is known to us (the current state). If so we will act on this state using\n// the passed chainSet. If this is not a known local state, false is returned.",
      "length": 3957,
      "tokens": 612,
      "embedding": []
    },
    {
      "slug": "func (c *chainWatcher) handleKnownLocalState(",
      "content": "func (c *chainWatcher) handleKnownLocalState(\n\tcommitSpend *chainntnfs.SpendDetail, broadcastStateNum uint64,\n\tchainSet *chainSet) (bool, error) {\n\n\t// If the channel is recovered, we won't have a local commit to check\n\t// against, so immediately return.\n\tif c.cfg.chanState.HasChanStatus(channeldb.ChanStatusRestored) {\n\t\treturn false, nil\n\t}\n\n\tcommitTxBroadcast := commitSpend.SpendingTx\n\tcommitHash := commitTxBroadcast.TxHash()\n\n\t// Check whether our latest local state hit the chain.\n\tif chainSet.localCommit.CommitTx.TxHash() != commitHash {\n\t\treturn false, nil\n\t}\n\n\tchainSet.commitSet.ConfCommitKey = &LocalHtlcSet\n\tif err := c.dispatchLocalForceClose(\n\t\tcommitSpend, broadcastStateNum, chainSet.commitSet,\n\t); err != nil {\n\t\treturn false, fmt.Errorf(\"unable to handle local\"+\n\t\t\t\"close for chan_point=%v: %v\",\n\t\t\tc.cfg.chanState.FundingOutpoint, err)\n\t}\n\n\treturn true, nil\n}\n\n// handleKnownRemoteState checks whether the passed spend is a remote state\n// that is known to us (a revoked, current or pending state). If so we will act\n// on this state using the passed chainSet. If this is not a known remote\n// state, false is returned.",
      "length": 1064,
      "tokens": 140,
      "embedding": []
    },
    {
      "slug": "func (c *chainWatcher) handleKnownRemoteState(",
      "content": "func (c *chainWatcher) handleKnownRemoteState(\n\tcommitSpend *chainntnfs.SpendDetail, broadcastStateNum uint64,\n\tchainSet *chainSet) (bool, error) {\n\n\t// If the channel is recovered, we won't have any remote commit to\n\t// check against, so imemdiately return.\n\tif c.cfg.chanState.HasChanStatus(channeldb.ChanStatusRestored) {\n\t\treturn false, nil\n\t}\n\n\tcommitTxBroadcast := commitSpend.SpendingTx\n\tcommitHash := commitTxBroadcast.TxHash()\n\n\tswitch {\n\t// If the spending transaction matches the current latest state, then\n\t// they've initiated a unilateral close. So we'll trigger the\n\t// unilateral close signal so subscribers can clean up the state as\n\t// necessary.\n\tcase chainSet.remoteCommit.CommitTx.TxHash() == commitHash:\n\t\tlog.Infof(\"Remote party broadcast base set, \"+\n\t\t\t\"commit_num=%v\", chainSet.remoteStateNum)\n\n\t\tchainSet.commitSet.ConfCommitKey = &RemoteHtlcSet\n\t\terr := c.dispatchRemoteForceClose(\n\t\t\tcommitSpend, chainSet.remoteCommit,\n\t\t\tchainSet.commitSet,\n\t\t\tc.cfg.chanState.RemoteCurrentRevocation,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn false, fmt.Errorf(\"unable to handle remote \"+\n\t\t\t\t\"close for chan_point=%v: %v\",\n\t\t\t\tc.cfg.chanState.FundingOutpoint, err)\n\t\t}\n\n\t\treturn true, nil\n\n\t// We'll also handle the case of the remote party broadcasting\n\t// their commitment transaction which is one height above ours.\n\t// This case can arise when we initiate a state transition, but\n\t// the remote party has a fail crash _after_ accepting the new\n\t// state, but _before_ sending their signature to us.\n\tcase chainSet.remotePendingCommit != nil &&\n\t\tchainSet.remotePendingCommit.CommitTx.TxHash() == commitHash:\n\n\t\tlog.Infof(\"Remote party broadcast pending set, \"+\n\t\t\t\"commit_num=%v\", chainSet.remoteStateNum+1)\n\n\t\tchainSet.commitSet.ConfCommitKey = &RemotePendingHtlcSet\n\t\terr := c.dispatchRemoteForceClose(\n\t\t\tcommitSpend, *chainSet.remotePendingCommit,\n\t\t\tchainSet.commitSet,\n\t\t\tc.cfg.chanState.RemoteNextRevocation,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn false, fmt.Errorf(\"unable to handle remote \"+\n\t\t\t\t\"close for chan_point=%v: %v\",\n\t\t\t\tc.cfg.chanState.FundingOutpoint, err)\n\t\t}\n\n\t\treturn true, nil\n\t}\n\n\t// This is neither a remote force close or a \"future\" commitment, we\n\t// now check whether it's a remote breach and properly handle it.\n\treturn c.handlePossibleBreach(commitSpend, broadcastStateNum, chainSet)\n}\n\n// handlePossibleBreach checks whether the remote has breached and dispatches a\n// breach resolution to claim funds.",
      "length": 2324,
      "tokens": 274,
      "embedding": []
    },
    {
      "slug": "func (c *chainWatcher) handlePossibleBreach(commitSpend *chainntnfs.SpendDetail,",
      "content": "func (c *chainWatcher) handlePossibleBreach(commitSpend *chainntnfs.SpendDetail,\n\tbroadcastStateNum uint64, chainSet *chainSet) (bool, error) {\n\n\t// We check if we have a revoked state at this state num that matches\n\t// the spend transaction.\n\tspendHeight := uint32(commitSpend.SpendingHeight)\n\tretribution, err := lnwallet.NewBreachRetribution(\n\t\tc.cfg.chanState, broadcastStateNum, spendHeight,\n\t\tcommitSpend.SpendingTx,\n\t)\n\n\tswitch {\n\t// If we had no log entry at this height, this was not a revoked state.\n\tcase err == channeldb.ErrLogEntryNotFound:\n\t\treturn false, nil\n\tcase err == channeldb.ErrNoPastDeltas:\n\t\treturn false, nil\n\n\tcase err != nil:\n\t\treturn false, fmt.Errorf(\"unable to create breach \"+\n\t\t\t\"retribution: %v\", err)\n\t}\n\n\t// We found a revoked state at this height, but it could still be our\n\t// own broadcasted state we are looking at. Therefore check that the\n\t// commit matches before assuming it was a breach.\n\tcommitHash := commitSpend.SpendingTx.TxHash()\n\tif retribution.BreachTxHash != commitHash {\n\t\treturn false, nil\n\t}\n\n\t// Create an AnchorResolution for the breached state.\n\tanchorRes, err := lnwallet.NewAnchorResolution(\n\t\tc.cfg.chanState, commitSpend.SpendingTx,\n\t)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"unable to create anchor \"+\n\t\t\t\"resolution: %v\", err)\n\t}\n\n\t// We'll set the ConfCommitKey here as the remote htlc set. This is\n\t// only used to ensure a nil-pointer-dereference doesn't occur and is\n\t// not used otherwise. The HTLC's may not exist for the\n\t// RemotePendingHtlcSet.\n\tchainSet.commitSet.ConfCommitKey = &RemoteHtlcSet\n\n\t// THEY'RE ATTEMPTING TO VIOLATE THE CONTRACT LAID OUT WITHIN THE\n\t// PAYMENT CHANNEL. Therefore we close the signal indicating a revoked\n\t// broadcast to allow subscribers to swiftly dispatch justice!!!\n\terr = c.dispatchContractBreach(\n\t\tcommitSpend, chainSet, broadcastStateNum, retribution,\n\t\tanchorRes,\n\t)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"unable to handle channel \"+\n\t\t\t\"breach for chan_point=%v: %v\",\n\t\t\tc.cfg.chanState.FundingOutpoint, err)\n\t}\n\n\treturn true, nil\n}\n\n// handleUnknownRemoteState is the last attempt we make at reclaiming funds\n// from the closed channel, by checkin whether the passed spend _could_ be a\n// remote spend that is unknown to us (we lost state). We will try to initiate\n// Data Loss Protection in order to restore our commit point and reclaim our\n// funds from the channel. If we are not able to act on it, false is returned.",
      "length": 2301,
      "tokens": 339,
      "embedding": []
    },
    {
      "slug": "func (c *chainWatcher) handleUnknownRemoteState(",
      "content": "func (c *chainWatcher) handleUnknownRemoteState(\n\tcommitSpend *chainntnfs.SpendDetail, broadcastStateNum uint64,\n\tchainSet *chainSet) (bool, error) {\n\n\tlog.Warnf(\"Remote node broadcast state #%v, \"+\n\t\t\"which is more than 1 beyond best known \"+\n\t\t\"state #%v!!! Attempting recovery...\",\n\t\tbroadcastStateNum, chainSet.remoteStateNum)\n\n\t// If this isn't a tweakless commitment, then we'll need to wait for\n\t// the remote party's latest unrevoked commitment point to be presented\n\t// to us as we need this to sweep. Otherwise, we can dispatch the\n\t// remote close and sweep immediately using a fake commitPoint as it\n\t// isn't actually needed for recovery anymore.\n\tcommitPoint := c.cfg.chanState.RemoteCurrentRevocation\n\ttweaklessCommit := c.cfg.chanState.ChanType.IsTweakless()\n\tif !tweaklessCommit {\n\t\tcommitPoint = c.waitForCommitmentPoint()\n\t\tif commitPoint == nil {\n\t\t\treturn false, fmt.Errorf(\"unable to get commit point\")\n\t\t}\n\n\t\tlog.Infof(\"Recovered commit point(%x) for \"+\n\t\t\t\"channel(%v)! Now attempting to use it to \"+\n\t\t\t\"sweep our funds...\",\n\t\t\tcommitPoint.SerializeCompressed(),\n\t\t\tc.cfg.chanState.FundingOutpoint)\n\t} else {\n\t\tlog.Infof(\"ChannelPoint(%v) is tweakless, \"+\n\t\t\t\"moving to sweep directly on chain\",\n\t\t\tc.cfg.chanState.FundingOutpoint)\n\t}\n\n\t// Since we don't have the commitment stored for this state, we'll just\n\t// pass an empty commitment within the commitment set. Note that this\n\t// means we won't be able to recover any HTLC funds.\n\t//\n\t// TODO(halseth): can we try to recover some HTLCs?\n\tchainSet.commitSet.ConfCommitKey = &RemoteHtlcSet\n\terr := c.dispatchRemoteForceClose(\n\t\tcommitSpend, channeldb.ChannelCommitment{},\n\t\tchainSet.commitSet, commitPoint,\n\t)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"unable to handle remote \"+\n\t\t\t\"close for chan_point=%v: %v\",\n\t\t\tc.cfg.chanState.FundingOutpoint, err)\n\t}\n\n\treturn true, nil\n}\n\n// toSelfAmount takes a transaction and returns the sum of all outputs that pay\n// to a script that the wallet controls. If no outputs pay to us, then we\n// return zero. This is possible as our output may have been trimmed due to\n// being dust.",
      "length": 2000,
      "tokens": 273,
      "embedding": []
    },
    {
      "slug": "func (c *chainWatcher) toSelfAmount(tx *wire.MsgTx) btcutil.Amount {",
      "content": "func (c *chainWatcher) toSelfAmount(tx *wire.MsgTx) btcutil.Amount {\n\tvar selfAmt btcutil.Amount\n\tfor _, txOut := range tx.TxOut {\n\t\t_, addrs, _, err := txscript.ExtractPkScriptAddrs(\n\t\t\t// Doesn't matter what net we actually pass in.\n\t\t\ttxOut.PkScript, &chaincfg.TestNet3Params,\n\t\t)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, addr := range addrs {\n\t\t\tif c.cfg.isOurAddr(addr) {\n\t\t\t\tselfAmt += btcutil.Amount(txOut.Value)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn selfAmt\n}\n\n// dispatchCooperativeClose processed a detect cooperative channel closure.\n// We'll use the spending transaction to locate our output within the\n// transaction, then clean up the database state. We'll also dispatch a\n// notification to all subscribers that the channel has been closed in this\n// manner.",
      "length": 666,
      "tokens": 101,
      "embedding": []
    },
    {
      "slug": "func (c *chainWatcher) dispatchCooperativeClose(commitSpend *chainntnfs.SpendDetail) error {",
      "content": "func (c *chainWatcher) dispatchCooperativeClose(commitSpend *chainntnfs.SpendDetail) error {\n\tbroadcastTx := commitSpend.SpendingTx\n\n\tlog.Infof(\"Cooperative closure for ChannelPoint(%v): %v\",\n\t\tc.cfg.chanState.FundingOutpoint, spew.Sdump(broadcastTx))\n\n\t// If the input *is* final, then we'll check to see which output is\n\t// ours.\n\tlocalAmt := c.toSelfAmount(broadcastTx)\n\n\t// Once this is known, we'll mark the state as fully closed in the\n\t// database. We can do this as a cooperatively closed channel has all\n\t// its outputs resolved after only one confirmation.\n\tcloseSummary := &channeldb.ChannelCloseSummary{\n\t\tChanPoint:               c.cfg.chanState.FundingOutpoint,\n\t\tChainHash:               c.cfg.chanState.ChainHash,\n\t\tClosingTXID:             *commitSpend.SpenderTxHash,\n\t\tRemotePub:               c.cfg.chanState.IdentityPub,\n\t\tCapacity:                c.cfg.chanState.Capacity,\n\t\tCloseHeight:             uint32(commitSpend.SpendingHeight),\n\t\tSettledBalance:          localAmt,\n\t\tCloseType:               channeldb.CooperativeClose,\n\t\tShortChanID:             c.cfg.chanState.ShortChanID(),\n\t\tIsPending:               true,\n\t\tRemoteCurrentRevocation: c.cfg.chanState.RemoteCurrentRevocation,\n\t\tRemoteNextRevocation:    c.cfg.chanState.RemoteNextRevocation,\n\t\tLocalChanConfig:         c.cfg.chanState.LocalChanCfg,\n\t}\n\n\t// Attempt to add a channel sync message to the close summary.\n\tchanSync, err := c.cfg.chanState.ChanSyncMsg()\n\tif err != nil {\n\t\tlog.Errorf(\"ChannelPoint(%v): unable to create channel sync \"+\n\t\t\t\"message: %v\", c.cfg.chanState.FundingOutpoint, err)\n\t} else {\n\t\tcloseSummary.LastChanSyncMsg = chanSync\n\t}\n\n\t// Create a summary of all the information needed to handle the\n\t// cooperative closure.\n\tcloseInfo := &CooperativeCloseInfo{\n\t\tChannelCloseSummary: closeSummary,\n\t}\n\n\t// With the event processed, we'll now notify all subscribers of the\n\t// event.\n\tc.Lock()\n\tfor _, sub := range c.clientSubscriptions {\n\t\tselect {\n\t\tcase sub.CooperativeClosure <- closeInfo:\n\t\tcase <-c.quit:\n\t\t\tc.Unlock()\n\t\t\treturn fmt.Errorf(\"exiting\")\n\t\t}\n\t}\n\tc.Unlock()\n\n\treturn nil\n}\n\n// dispatchLocalForceClose processes a unilateral close by us being confirmed.",
      "length": 2023,
      "tokens": 203,
      "embedding": []
    },
    {
      "slug": "func (c *chainWatcher) dispatchLocalForceClose(",
      "content": "func (c *chainWatcher) dispatchLocalForceClose(\n\tcommitSpend *chainntnfs.SpendDetail,\n\tstateNum uint64, commitSet CommitSet) error {\n\n\tlog.Infof(\"Local unilateral close of ChannelPoint(%v) \"+\n\t\t\"detected\", c.cfg.chanState.FundingOutpoint)\n\n\tforceClose, err := lnwallet.NewLocalForceCloseSummary(\n\t\tc.cfg.chanState, c.cfg.signer,\n\t\tcommitSpend.SpendingTx, stateNum,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// As we've detected that the channel has been closed, immediately\n\t// creating a close summary for future usage by related sub-systems.\n\tchanSnapshot := forceClose.ChanSnapshot\n\tcloseSummary := &channeldb.ChannelCloseSummary{\n\t\tChanPoint:               chanSnapshot.ChannelPoint,\n\t\tChainHash:               chanSnapshot.ChainHash,\n\t\tClosingTXID:             forceClose.CloseTx.TxHash(),\n\t\tRemotePub:               &chanSnapshot.RemoteIdentity,\n\t\tCapacity:                chanSnapshot.Capacity,\n\t\tCloseType:               channeldb.LocalForceClose,\n\t\tIsPending:               true,\n\t\tShortChanID:             c.cfg.chanState.ShortChanID(),\n\t\tCloseHeight:             uint32(commitSpend.SpendingHeight),\n\t\tRemoteCurrentRevocation: c.cfg.chanState.RemoteCurrentRevocation,\n\t\tRemoteNextRevocation:    c.cfg.chanState.RemoteNextRevocation,\n\t\tLocalChanConfig:         c.cfg.chanState.LocalChanCfg,\n\t}\n\n\t// If our commitment output isn't dust or we have active HTLC's on the\n\t// commitment transaction, then we'll populate the balances on the\n\t// close channel summary.\n\tif forceClose.CommitResolution != nil {\n\t\tcloseSummary.SettledBalance = chanSnapshot.LocalBalance.ToSatoshis()\n\t\tcloseSummary.TimeLockedBalance = chanSnapshot.LocalBalance.ToSatoshis()\n\t}\n\tfor _, htlc := range forceClose.HtlcResolutions.OutgoingHTLCs {\n\t\thtlcValue := btcutil.Amount(htlc.SweepSignDesc.Output.Value)\n\t\tcloseSummary.TimeLockedBalance += htlcValue\n\t}\n\n\t// Attempt to add a channel sync message to the close summary.\n\tchanSync, err := c.cfg.chanState.ChanSyncMsg()\n\tif err != nil {\n\t\tlog.Errorf(\"ChannelPoint(%v): unable to create channel sync \"+\n\t\t\t\"message: %v\", c.cfg.chanState.FundingOutpoint, err)\n\t} else {\n\t\tcloseSummary.LastChanSyncMsg = chanSync\n\t}\n\n\t// With the event processed, we'll now notify all subscribers of the\n\t// event.\n\tcloseInfo := &LocalUnilateralCloseInfo{\n\t\tSpendDetail:            commitSpend,\n\t\tLocalForceCloseSummary: forceClose,\n\t\tChannelCloseSummary:    closeSummary,\n\t\tCommitSet:              commitSet,\n\t}\n\tc.Lock()\n\tfor _, sub := range c.clientSubscriptions {\n\t\tselect {\n\t\tcase sub.LocalUnilateralClosure <- closeInfo:\n\t\tcase <-c.quit:\n\t\t\tc.Unlock()\n\t\t\treturn fmt.Errorf(\"exiting\")\n\t\t}\n\t}\n\tc.Unlock()\n\n\treturn nil\n}\n\n// dispatchRemoteForceClose processes a detected unilateral channel closure by\n// the remote party. This function will prepare a UnilateralCloseSummary which\n// will then be sent to any subscribers allowing them to resolve all our funds\n// in the channel on chain. Once this close summary is prepared, all registered\n// subscribers will receive a notification of this event. The commitPoint\n// argument should be set to the per_commitment_point corresponding to the\n// spending commitment.\n//\n// NOTE: The remoteCommit argument should be set to the stored commitment for\n// this particular state. If we don't have the commitment stored (should only\n// happen in case we have lost state) it should be set to an empty struct, in\n// which case we will attempt to sweep the non-HTLC output using the passed\n// commitPoint.",
      "length": 3314,
      "tokens": 364,
      "embedding": []
    },
    {
      "slug": "func (c *chainWatcher) dispatchRemoteForceClose(",
      "content": "func (c *chainWatcher) dispatchRemoteForceClose(\n\tcommitSpend *chainntnfs.SpendDetail,\n\tremoteCommit channeldb.ChannelCommitment,\n\tcommitSet CommitSet, commitPoint *btcec.PublicKey) error {\n\n\tlog.Infof(\"Unilateral close of ChannelPoint(%v) \"+\n\t\t\"detected\", c.cfg.chanState.FundingOutpoint)\n\n\t// First, we'll create a closure summary that contains all the\n\t// materials required to let each subscriber sweep the funds in the\n\t// channel on-chain.\n\tuniClose, err := lnwallet.NewUnilateralCloseSummary(\n\t\tc.cfg.chanState, c.cfg.signer, commitSpend,\n\t\tremoteCommit, commitPoint,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// With the event processed, we'll now notify all subscribers of the\n\t// event.\n\tc.Lock()\n\tfor _, sub := range c.clientSubscriptions {\n\t\tselect {\n\t\tcase sub.RemoteUnilateralClosure <- &RemoteUnilateralCloseInfo{\n\t\t\tUnilateralCloseSummary: uniClose,\n\t\t\tCommitSet:              commitSet,\n\t\t}:\n\t\tcase <-c.quit:\n\t\t\tc.Unlock()\n\t\t\treturn fmt.Errorf(\"exiting\")\n\t\t}\n\t}\n\tc.Unlock()\n\n\treturn nil\n}\n\n// dispatchContractBreach processes a detected contract breached by the remote\n// party. This method is to be called once we detect that the remote party has\n// broadcast a prior revoked commitment state. This method well prepare all the\n// materials required to bring the cheater to justice, then notify all\n// registered subscribers of this event.",
      "length": 1262,
      "tokens": 162,
      "embedding": []
    },
    {
      "slug": "func (c *chainWatcher) dispatchContractBreach(spendEvent *chainntnfs.SpendDetail,",
      "content": "func (c *chainWatcher) dispatchContractBreach(spendEvent *chainntnfs.SpendDetail,\n\tchainSet *chainSet, broadcastStateNum uint64,\n\tretribution *lnwallet.BreachRetribution,\n\tanchorRes *lnwallet.AnchorResolution) error {\n\n\tlog.Warnf(\"Remote peer has breached the channel contract for \"+\n\t\t\"ChannelPoint(%v). Revoked state #%v was broadcast!!!\",\n\t\tc.cfg.chanState.FundingOutpoint, broadcastStateNum)\n\n\tif err := c.cfg.chanState.MarkBorked(); err != nil {\n\t\treturn fmt.Errorf(\"unable to mark channel as borked: %v\", err)\n\t}\n\n\tspendHeight := uint32(spendEvent.SpendingHeight)\n\n\tlog.Debugf(\"Punishment breach retribution created: %v\",\n\t\tnewLogClosure(func() string {\n\t\t\tretribution.KeyRing.LocalHtlcKey = nil\n\t\t\tretribution.KeyRing.RemoteHtlcKey = nil\n\t\t\tretribution.KeyRing.ToLocalKey = nil\n\t\t\tretribution.KeyRing.ToRemoteKey = nil\n\t\t\tretribution.KeyRing.RevocationKey = nil\n\t\t\treturn spew.Sdump(retribution)\n\t\t}))\n\n\tsettledBalance := chainSet.remoteCommit.LocalBalance.ToSatoshis()\n\tcloseSummary := channeldb.ChannelCloseSummary{\n\t\tChanPoint:               c.cfg.chanState.FundingOutpoint,\n\t\tChainHash:               c.cfg.chanState.ChainHash,\n\t\tClosingTXID:             *spendEvent.SpenderTxHash,\n\t\tCloseHeight:             spendHeight,\n\t\tRemotePub:               c.cfg.chanState.IdentityPub,\n\t\tCapacity:                c.cfg.chanState.Capacity,\n\t\tSettledBalance:          settledBalance,\n\t\tCloseType:               channeldb.BreachClose,\n\t\tIsPending:               true,\n\t\tShortChanID:             c.cfg.chanState.ShortChanID(),\n\t\tRemoteCurrentRevocation: c.cfg.chanState.RemoteCurrentRevocation,\n\t\tRemoteNextRevocation:    c.cfg.chanState.RemoteNextRevocation,\n\t\tLocalChanConfig:         c.cfg.chanState.LocalChanCfg,\n\t}\n\n\t// Attempt to add a channel sync message to the close summary.\n\tchanSync, err := c.cfg.chanState.ChanSyncMsg()\n\tif err != nil {\n\t\tlog.Errorf(\"ChannelPoint(%v): unable to create channel sync \"+\n\t\t\t\"message: %v\", c.cfg.chanState.FundingOutpoint, err)\n\t} else {\n\t\tcloseSummary.LastChanSyncMsg = chanSync\n\t}\n\n\t// Hand the retribution info over to the breach arbiter. This function\n\t// will wait for a response from the breach arbiter and then proceed to\n\t// send a BreachCloseInfo to the channel arbitrator. The channel arb\n\t// will then mark the channel as closed after resolutions and the\n\t// commit set are logged in the arbitrator log.\n\tif err := c.cfg.contractBreach(retribution); err != nil {\n\t\tlog.Errorf(\"unable to hand breached contract off to \"+\n\t\t\t\"breachArbiter: %v\", err)\n\t\treturn err\n\t}\n\n\tbreachRes := &BreachResolution{\n\t\tFundingOutPoint: c.cfg.chanState.FundingOutpoint,\n\t}\n\n\tbreachInfo := &BreachCloseInfo{\n\t\tCommitHash:       spendEvent.SpendingTx.TxHash(),\n\t\tBreachResolution: breachRes,\n\t\tAnchorResolution: anchorRes,\n\t\tCommitSet:        chainSet.commitSet,\n\t\tCloseSummary:     closeSummary,\n\t}\n\n\t// With the event processed and channel closed, we'll now notify all\n\t// subscribers of the event.\n\tc.Lock()\n\tfor _, sub := range c.clientSubscriptions {\n\t\tselect {\n\t\tcase sub.ContractBreach <- breachInfo:\n\t\tcase <-c.quit:\n\t\t\tc.Unlock()\n\t\t\treturn fmt.Errorf(\"quitting\")\n\t\t}\n\t}\n\tc.Unlock()\n\n\treturn nil\n}\n\n// waitForCommitmentPoint waits for the commitment point to be inserted into\n// the local database. We'll use this method in the DLP case, to wait for the\n// remote party to send us their point, as we can't proceed until we have that.",
      "length": 3200,
      "tokens": 331,
      "embedding": []
    },
    {
      "slug": "func (c *chainWatcher) waitForCommitmentPoint() *btcec.PublicKey {",
      "content": "func (c *chainWatcher) waitForCommitmentPoint() *btcec.PublicKey {\n\t// If we are lucky, the remote peer sent us the correct commitment\n\t// point during channel sync, such that we can sweep our funds. If we\n\t// cannot find the commit point, there's not much we can do other than\n\t// wait for us to retrieve it. We will attempt to retrieve it from the\n\t// peer each time we connect to it.\n\t//\n\t// TODO(halseth): actively initiate re-connection to the peer?\n\tbackoff := minCommitPointPollTimeout\n\tfor {\n\t\tcommitPoint, err := c.cfg.chanState.DataLossCommitPoint()\n\t\tif err == nil {\n\t\t\treturn commitPoint\n\t\t}\n\n\t\tlog.Errorf(\"Unable to retrieve commitment point for \"+\n\t\t\t\"channel(%v) with lost state: %v. Retrying in %v.\",\n\t\t\tc.cfg.chanState.FundingOutpoint, err, backoff)\n\n\t\tselect {\n\t\t// Wait before retrying, with an exponential backoff.\n\t\tcase <-time.After(backoff):\n\t\t\tbackoff = 2 * backoff\n\t\t\tif backoff > maxCommitPointPollTimeout {\n\t\t\t\tbackoff = maxCommitPointPollTimeout\n\t\t\t}\n\n\t\tcase <-c.quit:\n\t\t\treturn nil\n\t\t}\n\t}\n}\n",
      "length": 922,
      "tokens": 141,
      "embedding": []
    }
  ]
}