{
  "filepath": "../implementations/go/lnd/contractcourt/htlc_incoming_contest_resolver.go",
  "package": "contractcourt",
  "sections": [
    {
      "slug": "type htlcIncomingContestResolver struct {",
      "content": "type htlcIncomingContestResolver struct {\n\t// htlcExpiry is the absolute expiry of this incoming HTLC. We use this\n\t// value to determine if we can exit early as if the HTLC times out,\n\t// before we learn of the preimage then we can't claim it on chain\n\t// successfully.\n\thtlcExpiry uint32\n\n\t// htlcSuccessResolver is the inner resolver that may be utilized if we\n\t// learn of the preimage.\n\t*htlcSuccessResolver\n}\n\n// newIncomingContestResolver instantiates a new incoming htlc contest resolver.",
      "length": 443,
      "tokens": 74,
      "embedding": []
    },
    {
      "slug": "func newIncomingContestResolver(",
      "content": "func newIncomingContestResolver(\n\tres lnwallet.IncomingHtlcResolution, broadcastHeight uint32,\n\thtlc channeldb.HTLC, resCfg ResolverConfig) *htlcIncomingContestResolver {\n\n\tsuccess := newSuccessResolver(\n\t\tres, broadcastHeight, htlc, resCfg,\n\t)\n\n\treturn &htlcIncomingContestResolver{\n\t\thtlcExpiry:          htlc.RefundTimeout,\n\t\thtlcSuccessResolver: success,\n\t}\n}\n",
      "length": 319,
      "tokens": 26,
      "embedding": []
    },
    {
      "slug": "func (h *htlcIncomingContestResolver) processFinalHtlcFail() error {",
      "content": "func (h *htlcIncomingContestResolver) processFinalHtlcFail() error {\n\t// Mark the htlc as final failed.\n\terr := h.ChainArbitratorConfig.PutFinalHtlcOutcome(\n\t\th.ChannelArbitratorConfig.ShortChanID, h.htlc.HtlcIndex, false,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Send notification.\n\th.ChainArbitratorConfig.HtlcNotifier.NotifyFinalHtlcEvent(\n\t\tmodels.CircuitKey{\n\t\t\tChanID: h.ShortChanID,\n\t\t\tHtlcID: h.htlc.HtlcIndex,\n\t\t},\n\t\tchanneldb.FinalHtlcInfo{\n\t\t\tSettled:  false,\n\t\t\tOffchain: false,\n\t\t},\n\t)\n\n\treturn nil\n}\n\n// Resolve attempts to resolve this contract. As we don't yet know of the\n// preimage for the contract, we'll wait for one of two things to happen:\n//\n//  1. We learn of the preimage! In this case, we can sweep the HTLC incoming\n//     and ensure that if this was a multi-hop HTLC we are made whole. In this\n//     case, an additional ContractResolver will be returned to finish the\n//     job.\n//\n//  2. The HTLC expires. If this happens, then the contract is fully resolved\n//     as we have no remaining actions left at our disposal.\n//\n// NOTE: Part of the ContractResolver interface.",
      "length": 1000,
      "tokens": 150,
      "embedding": []
    },
    {
      "slug": "func (h *htlcIncomingContestResolver) Resolve() (ContractResolver, error) {",
      "content": "func (h *htlcIncomingContestResolver) Resolve() (ContractResolver, error) {\n\t// If we're already full resolved, then we don't have anything further\n\t// to do.\n\tif h.resolved {\n\t\treturn nil, nil\n\t}\n\n\t// First try to parse the payload. If that fails, we can stop resolution\n\t// now.\n\tpayload, nextHopOnionBlob, err := h.decodePayload()\n\tif err != nil {\n\t\tlog.Debugf(\"ChannelArbitrator(%v): cannot decode payload of \"+\n\t\t\t\"htlc %v\", h.ChanPoint, h.HtlcPoint())\n\n\t\t// If we've locked in an htlc with an invalid payload on our\n\t\t// commitment tx, we don't need to resolve it. The other party\n\t\t// will time it out and get their funds back. This situation can\n\t\t// present itself when we crash before processRemoteAdds in the\n\t\t// link has ran.\n\t\th.resolved = true\n\n\t\tif err := h.processFinalHtlcFail(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// We write a report to disk that indicates we could not decode\n\t\t// the htlc.\n\t\tresReport := h.report().resolverReport(\n\t\t\tnil, channeldb.ResolverTypeIncomingHtlc,\n\t\t\tchanneldb.ResolverOutcomeAbandoned,\n\t\t)\n\t\treturn nil, h.PutResolverReport(nil, resReport)\n\t}\n\n\t// Register for block epochs. After registration, the current height\n\t// will be sent on the channel immediately.\n\tblockEpochs, err := h.Notifier.RegisterBlockEpochNtfn(nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer blockEpochs.Cancel()\n\n\tvar currentHeight int32\n\tselect {\n\tcase newBlock, ok := <-blockEpochs.Epochs:\n\t\tif !ok {\n\t\t\treturn nil, errResolverShuttingDown\n\t\t}\n\t\tcurrentHeight = newBlock.Height\n\tcase <-h.quit:\n\t\treturn nil, errResolverShuttingDown\n\t}\n\n\t// We'll first check if this HTLC has been timed out, if so, we can\n\t// return now and mark ourselves as resolved. If we're past the point of\n\t// expiry of the HTLC, then at this point the sender can sweep it, so\n\t// we'll end our lifetime. Here we deliberately forego the chance that\n\t// the sender doesn't sweep and we already have or will learn the\n\t// preimage. Otherwise the resolver could potentially stay active\n\t// indefinitely and the channel will never close properly.\n\tif uint32(currentHeight) >= h.htlcExpiry {\n\t\t// TODO(roasbeef): should also somehow check if outgoing is\n\t\t// resolved or not\n\t\t//  * may need to hook into the circuit map\n\t\t//  * can't timeout before the outgoing has been\n\n\t\tlog.Infof(\"%T(%v): HTLC has timed out (expiry=%v, height=%v), \"+\n\t\t\t\"abandoning\", h, h.htlcResolution.ClaimOutpoint,\n\t\t\th.htlcExpiry, currentHeight)\n\t\th.resolved = true\n\n\t\tif err := h.processFinalHtlcFail(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Finally, get our report and checkpoint our resolver with a\n\t\t// timeout outcome report.\n\t\treport := h.report().resolverReport(\n\t\t\tnil, channeldb.ResolverTypeIncomingHtlc,\n\t\t\tchanneldb.ResolverOutcomeTimeout,\n\t\t)\n\t\treturn nil, h.Checkpoint(h, report)\n\t}\n\n\t// applyPreimage is a helper function that will populate our internal\n\t// resolver with the preimage we learn of. This should be called once\n\t// the preimage is revealed so the inner resolver can properly complete\n\t// its duties. The error return value indicates whether the preimage\n\t// was properly applied.\n\tapplyPreimage := func(preimage lntypes.Preimage) error {\n\t\t// Sanity check to see if this preimage matches our htlc. At\n\t\t// this point it should never happen that it does not match.\n\t\tif !preimage.Matches(h.htlc.RHash) {\n\t\t\treturn errors.New(\"preimage does not match hash\")\n\t\t}\n\n\t\t// Update htlcResolution with the matching preimage.\n\t\th.htlcResolution.Preimage = preimage\n\n\t\tlog.Infof(\"%T(%v): applied preimage=%v\", h,\n\t\t\th.htlcResolution.ClaimOutpoint, preimage)\n\n\t\t// If this is our commitment transaction, then we'll need to\n\t\t// populate the witness for the second-level HTLC transaction.\n\t\tif h.htlcResolution.SignedSuccessTx != nil {\n\t\t\t// Within the witness for the success transaction, the\n\t\t\t// preimage is the 4th element as it looks like:\n\t\t\t//\n\t\t\t//  * <sender sig> <recvr sig> <preimage> <witness script>\n\t\t\t//\n\t\t\t// We'll populate it within the witness, as since this\n\t\t\t// was a \"contest\" resolver, we didn't yet know of the\n\t\t\t// preimage.\n\t\t\th.htlcResolution.SignedSuccessTx.TxIn[0].Witness[3] = preimage[:]\n\t\t}\n\n\t\treturn nil\n\t}\n\n\t// Define a closure to process htlc resolutions either directly or\n\t// triggered by future notifications.\n\tprocessHtlcResolution := func(e invoices.HtlcResolution) (\n\t\tContractResolver, error) {\n\n\t\t// Take action based on the type of resolution we have\n\t\t// received.\n\t\tswitch resolution := e.(type) {\n\t\t// If the htlc resolution was a settle, apply the\n\t\t// preimage and return a success resolver.\n\t\tcase *invoices.HtlcSettleResolution:\n\t\t\terr := applyPreimage(resolution.Preimage)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn h.htlcSuccessResolver, nil\n\n\t\t// If the htlc was failed, mark the htlc as\n\t\t// resolved.\n\t\tcase *invoices.HtlcFailResolution:\n\t\t\tlog.Infof(\"%T(%v): Exit hop HTLC canceled \"+\n\t\t\t\t\"(expiry=%v, height=%v), abandoning\", h,\n\t\t\t\th.htlcResolution.ClaimOutpoint,\n\t\t\t\th.htlcExpiry, currentHeight)\n\n\t\t\th.resolved = true\n\n\t\t\tif err := h.processFinalHtlcFail(); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\t// Checkpoint our resolver with an abandoned outcome\n\t\t\t// because we take no further action on this htlc.\n\t\t\treport := h.report().resolverReport(\n\t\t\t\tnil, channeldb.ResolverTypeIncomingHtlc,\n\t\t\t\tchanneldb.ResolverOutcomeAbandoned,\n\t\t\t)\n\t\t\treturn nil, h.Checkpoint(h, report)\n\n\t\t// Error if the resolution type is unknown, we are only\n\t\t// expecting settles and fails.\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"unknown resolution\"+\n\t\t\t\t\" type: %v\", e)\n\t\t}\n\t}\n\n\tvar (\n\t\thodlChan       chan interface{}\n\t\twitnessUpdates <-chan lntypes.Preimage\n\t)\n\tif payload.FwdInfo.NextHop == hop.Exit {\n\t\t// Create a buffered hodl chan to prevent deadlock.\n\t\thodlChan = make(chan interface{}, 1)\n\n\t\t// Notify registry that we are potentially resolving as an exit\n\t\t// hop on-chain. If this HTLC indeed pays to an existing\n\t\t// invoice, the invoice registry will tell us what to do with\n\t\t// the HTLC. This is identical to HTLC resolution in the link.\n\t\tcircuitKey := models.CircuitKey{\n\t\t\tChanID: h.ShortChanID,\n\t\t\tHtlcID: h.htlc.HtlcIndex,\n\t\t}\n\n\t\tresolution, err := h.Registry.NotifyExitHopHtlc(\n\t\t\th.htlc.RHash, h.htlc.Amt, h.htlcExpiry, currentHeight,\n\t\t\tcircuitKey, hodlChan, payload,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tdefer h.Registry.HodlUnsubscribeAll(hodlChan)\n\n\t\t// Take action based on the resolution we received. If the htlc\n\t\t// was settled, or a htlc for a known invoice failed we can\n\t\t// resolve it directly. If the resolution is nil, the htlc was\n\t\t// neither accepted nor failed, so we cannot take action yet.\n\t\tswitch res := resolution.(type) {\n\t\tcase *invoices.HtlcFailResolution:\n\t\t\t// In the case where the htlc failed, but the invoice\n\t\t\t// was known to the registry, we can directly resolve\n\t\t\t// the htlc.\n\t\t\tif res.Outcome != invoices.ResultInvoiceNotFound {\n\t\t\t\treturn processHtlcResolution(resolution)\n\t\t\t}\n\n\t\t// If we settled the htlc, we can resolve it.\n\t\tcase *invoices.HtlcSettleResolution:\n\t\t\treturn processHtlcResolution(resolution)\n\n\t\t// If the resolution is nil, the htlc was neither settled nor\n\t\t// failed so we cannot take action at present.\n\t\tcase nil:\n\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"unknown htlc resolution type: %T\",\n\t\t\t\tresolution)\n\t\t}\n\t} else {\n\t\t// If the HTLC hasn't expired yet, then we may still be able to\n\t\t// claim it if we learn of the pre-image, so we'll subscribe to\n\t\t// the preimage database to see if it turns up, or the HTLC\n\t\t// times out.\n\t\t//\n\t\t// NOTE: This is done BEFORE opportunistically querying the db,\n\t\t// to ensure the preimage can't be delivered between querying\n\t\t// and registering for the preimage subscription.\n\t\tpreimageSubscription, err := h.PreimageDB.SubscribeUpdates(\n\t\t\th.htlcSuccessResolver.ShortChanID, &h.htlc,\n\t\t\tpayload, nextHopOnionBlob,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdefer preimageSubscription.CancelSubscription()\n\n\t\t// With the epochs and preimage subscriptions initialized, we'll\n\t\t// query to see if we already know the preimage.\n\t\tpreimage, ok := h.PreimageDB.LookupPreimage(h.htlc.RHash)\n\t\tif ok {\n\t\t\t// If we do, then this means we can claim the HTLC!\n\t\t\t// However, we don't know how to ourselves, so we'll\n\t\t\t// return our inner resolver which has the knowledge to\n\t\t\t// do so.\n\t\t\tif err := applyPreimage(preimage); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn h.htlcSuccessResolver, nil\n\t\t}\n\n\t\twitnessUpdates = preimageSubscription.WitnessUpdates\n\t}\n\n\tfor {\n\t\tselect {\n\t\tcase preimage := <-witnessUpdates:\n\t\t\t// We received a new preimage, but we need to ignore\n\t\t\t// all except the preimage we are waiting for.\n\t\t\tif !preimage.Matches(h.htlc.RHash) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif err := applyPreimage(preimage); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\t// We've learned of the preimage and this information\n\t\t\t// has been added to our inner resolver. We return it so\n\t\t\t// it can continue contract resolution.\n\t\t\treturn h.htlcSuccessResolver, nil\n\n\t\tcase hodlItem := <-hodlChan:\n\t\t\thtlcResolution := hodlItem.(invoices.HtlcResolution)\n\t\t\treturn processHtlcResolution(htlcResolution)\n\n\t\tcase newBlock, ok := <-blockEpochs.Epochs:\n\t\t\tif !ok {\n\t\t\t\treturn nil, errResolverShuttingDown\n\t\t\t}\n\n\t\t\t// If this new height expires the HTLC, then this means\n\t\t\t// we never found out the preimage, so we can mark\n\t\t\t// resolved and exit.\n\t\t\tnewHeight := uint32(newBlock.Height)\n\t\t\tif newHeight >= h.htlcExpiry {\n\t\t\t\tlog.Infof(\"%T(%v): HTLC has timed out \"+\n\t\t\t\t\t\"(expiry=%v, height=%v), abandoning\", h,\n\t\t\t\t\th.htlcResolution.ClaimOutpoint,\n\t\t\t\t\th.htlcExpiry, currentHeight)\n\t\t\t\th.resolved = true\n\n\t\t\t\tif err := h.processFinalHtlcFail(); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\treport := h.report().resolverReport(\n\t\t\t\t\tnil,\n\t\t\t\t\tchanneldb.ResolverTypeIncomingHtlc,\n\t\t\t\t\tchanneldb.ResolverOutcomeTimeout,\n\t\t\t\t)\n\t\t\t\treturn nil, h.Checkpoint(h, report)\n\t\t\t}\n\n\t\tcase <-h.quit:\n\t\t\treturn nil, errResolverShuttingDown\n\t\t}\n\t}\n}\n\n// report returns a report on the resolution state of the contract.",
      "length": 9582,
      "tokens": 1361,
      "embedding": []
    },
    {
      "slug": "func (h *htlcIncomingContestResolver) report() *ContractReport {",
      "content": "func (h *htlcIncomingContestResolver) report() *ContractReport {\n\t// No locking needed as these values are read-only.\n\n\tfinalAmt := h.htlc.Amt.ToSatoshis()\n\tif h.htlcResolution.SignedSuccessTx != nil {\n\t\tfinalAmt = btcutil.Amount(\n\t\t\th.htlcResolution.SignedSuccessTx.TxOut[0].Value,\n\t\t)\n\t}\n\n\treturn &ContractReport{\n\t\tOutpoint:       h.htlcResolution.ClaimOutpoint,\n\t\tType:           ReportOutputIncomingHtlc,\n\t\tAmount:         finalAmt,\n\t\tMaturityHeight: h.htlcExpiry,\n\t\tLimboBalance:   finalAmt,\n\t\tStage:          1,\n\t}\n}\n\n// Stop signals the resolver to cancel any current resolution processes, and\n// suspend.\n//\n// NOTE: Part of the ContractResolver interface.",
      "length": 578,
      "tokens": 61,
      "embedding": []
    },
    {
      "slug": "func (h *htlcIncomingContestResolver) Stop() {",
      "content": "func (h *htlcIncomingContestResolver) Stop() {\n\tclose(h.quit)\n}\n\n// IsResolved returns true if the stored state in the resolve is fully\n// resolved. In this case the target output can be forgotten.\n//\n// NOTE: Part of the ContractResolver interface.",
      "length": 196,
      "tokens": 34,
      "embedding": []
    },
    {
      "slug": "func (h *htlcIncomingContestResolver) IsResolved() bool {",
      "content": "func (h *htlcIncomingContestResolver) IsResolved() bool {\n\treturn h.resolved\n}\n\n// Encode writes an encoded version of the ContractResolver into the passed\n// Writer.\n//\n// NOTE: Part of the ContractResolver interface.",
      "length": 154,
      "tokens": 25,
      "embedding": []
    },
    {
      "slug": "func (h *htlcIncomingContestResolver) Encode(w io.Writer) error {",
      "content": "func (h *htlcIncomingContestResolver) Encode(w io.Writer) error {\n\t// We'll first write out the one field unique to this resolver.\n\tif err := binary.Write(w, endian, h.htlcExpiry); err != nil {\n\t\treturn err\n\t}\n\n\t// Then we'll write out our internal resolver.\n\treturn h.htlcSuccessResolver.Encode(w)\n}\n\n// newIncomingContestResolverFromReader attempts to decode an encoded ContractResolver\n// from the passed Reader instance, returning an active ContractResolver\n// instance.",
      "length": 397,
      "tokens": 56,
      "embedding": []
    },
    {
      "slug": "func newIncomingContestResolverFromReader(r io.Reader, resCfg ResolverConfig) (",
      "content": "func newIncomingContestResolverFromReader(r io.Reader, resCfg ResolverConfig) (\n\t*htlcIncomingContestResolver, error) {\n\n\th := &htlcIncomingContestResolver{}\n\n\t// We'll first read the one field unique to this resolver.\n\tif err := binary.Read(r, endian, &h.htlcExpiry); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Then we'll decode our internal resolver.\n\tsuccessResolver, err := newSuccessResolverFromReader(r, resCfg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\th.htlcSuccessResolver = successResolver\n\n\treturn h, nil\n}\n\n// Supplement adds additional information to the resolver that is required\n// before Resolve() is called.\n//\n// NOTE: Part of the htlcContractResolver interface.",
      "length": 571,
      "tokens": 83,
      "embedding": []
    },
    {
      "slug": "func (h *htlcIncomingContestResolver) Supplement(htlc channeldb.HTLC) {",
      "content": "func (h *htlcIncomingContestResolver) Supplement(htlc channeldb.HTLC) {\n\th.htlc = htlc\n}\n\n// decodePayload (re)decodes the hop payload of a received htlc.",
      "length": 79,
      "tokens": 14,
      "embedding": []
    },
    {
      "slug": "func (h *htlcIncomingContestResolver) decodePayload() (*hop.Payload,",
      "content": "func (h *htlcIncomingContestResolver) decodePayload() (*hop.Payload,\n\t[]byte, error) {\n\n\tonionReader := bytes.NewReader(h.htlc.OnionBlob)\n\titerator, err := h.OnionProcessor.ReconstructHopIterator(\n\t\tonionReader, h.htlc.RHash[:],\n\t)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpayload, err := iterator.HopPayload()\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// Transform onion blob for the next hop.\n\tvar onionBlob [lnwire.OnionPacketSize]byte\n\tbuf := bytes.NewBuffer(onionBlob[0:0])\n\terr = iterator.EncodeNextHop(buf)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn payload, onionBlob[:], nil\n}\n\n// A compile time assertion to ensure htlcIncomingContestResolver meets the\n// ContractResolver interface.\nvar _ htlcContractResolver = (*htlcIncomingContestResolver)(nil)\n",
      "length": 677,
      "tokens": 87,
      "embedding": []
    }
  ]
}