{
  "filepath": "../implementations/go/lnd/contractcourt/htlc_timeout_resolver_test.go",
  "package": "contractcourt",
  "sections": [
    {
      "slug": "type mockWitnessBeacon struct {",
      "content": "type mockWitnessBeacon struct {\n\tpreImageUpdates chan lntypes.Preimage\n\tnewPreimages    chan []lntypes.Preimage\n\tlookupPreimage  map[lntypes.Hash]lntypes.Preimage\n}\n",
      "length": 129,
      "tokens": 9,
      "embedding": []
    },
    {
      "slug": "func newMockWitnessBeacon() *mockWitnessBeacon {",
      "content": "func newMockWitnessBeacon() *mockWitnessBeacon {\n\treturn &mockWitnessBeacon{\n\t\tpreImageUpdates: make(chan lntypes.Preimage, 1),\n\t\tnewPreimages:    make(chan []lntypes.Preimage),\n\t\tlookupPreimage:  make(map[lntypes.Hash]lntypes.Preimage),\n\t}\n}\n",
      "length": 188,
      "tokens": 13,
      "embedding": []
    },
    {
      "slug": "func (m *mockWitnessBeacon) SubscribeUpdates(",
      "content": "func (m *mockWitnessBeacon) SubscribeUpdates(\n\tchanID lnwire.ShortChannelID, htlc *channeldb.HTLC,\n\tpayload *hop.Payload,\n\tnextHopOnionBlob []byte) (*WitnessSubscription, error) {\n\n\treturn &WitnessSubscription{\n\t\tWitnessUpdates:     m.preImageUpdates,\n\t\tCancelSubscription: func() {},\n\t}, nil\n}\n",
      "length": 240,
      "tokens": 21,
      "embedding": []
    },
    {
      "slug": "func (m *mockWitnessBeacon) LookupPreimage(payhash lntypes.Hash) (lntypes.Preimage, bool) {",
      "content": "func (m *mockWitnessBeacon) LookupPreimage(payhash lntypes.Hash) (lntypes.Preimage, bool) {\n\tpreimage, ok := m.lookupPreimage[payhash]\n\tif !ok {\n\t\treturn lntypes.Preimage{}, false\n\t}\n\treturn preimage, true\n}\n",
      "length": 110,
      "tokens": 15,
      "embedding": []
    },
    {
      "slug": "func (m *mockWitnessBeacon) AddPreimages(preimages ...lntypes.Preimage) error {",
      "content": "func (m *mockWitnessBeacon) AddPreimages(preimages ...lntypes.Preimage) error {\n\tm.newPreimages <- preimages\n\treturn nil\n}\n\n// TestHtlcTimeoutResolver tests that the timeout resolver properly handles all\n// variations of possible local+remote spends.",
      "length": 165,
      "tokens": 22,
      "embedding": []
    },
    {
      "slug": "func TestHtlcTimeoutResolver(t *testing.T) {",
      "content": "func TestHtlcTimeoutResolver(t *testing.T) {\n\tt.Parallel()\n\n\tfakePreimageBytes := bytes.Repeat([]byte{1}, lntypes.HashSize)\n\n\tvar (\n\t\thtlcOutpoint wire.OutPoint\n\t\tfakePreimage lntypes.Preimage\n\t)\n\tfakeSignDesc := &input.SignDescriptor{\n\t\tOutput: &wire.TxOut{},\n\t}\n\n\tcopy(fakePreimage[:], fakePreimageBytes)\n\n\tsigner := &mock.DummySigner{}\n\tsweepTx := &wire.MsgTx{\n\t\tTxIn: []*wire.TxIn{\n\t\t\t{\n\t\t\t\tPreviousOutPoint: htlcOutpoint,\n\t\t\t\tWitness:          [][]byte{{0x01}},\n\t\t\t},\n\t\t},\n\t}\n\tfakeTimeout := int32(5)\n\n\ttemplateTx := &wire.MsgTx{\n\t\tTxIn: []*wire.TxIn{\n\t\t\t{\n\t\t\t\tPreviousOutPoint: htlcOutpoint,\n\t\t\t},\n\t\t},\n\t}\n\n\ttestCases := []struct {\n\t\t// name is a human readable description of the test case.\n\t\tname string\n\n\t\t// remoteCommit denotes if the commitment broadcast was the\n\t\t// remote commitment or not.\n\t\tremoteCommit bool\n\n\t\t// timeout denotes if the HTLC should be let timeout, or if the\n\t\t// \"remote\" party should sweep it on-chain. This also affects\n\t\t// what type of resolution message we expect.\n\t\ttimeout bool\n\n\t\t// txToBroadcast is a function closure that should generate the\n\t\t// transaction that should spend the HTLC output. Test authors\n\t\t// can use this to customize the witness used when spending to\n\t\t// trigger various redemption cases.\n\t\ttxToBroadcast func() (*wire.MsgTx, error)\n\n\t\t// outcome is the resolver outcome that we expect to be reported\n\t\t// once the contract is fully resolved.\n\t\toutcome channeldb.ResolverOutcome\n\t}{\n\t\t// Remote commitment is broadcast, we time out the HTLC on\n\t\t// chain, and should expect a fail HTLC resolution.\n\t\t{\n\t\t\tname:         \"timeout remote tx\",\n\t\t\tremoteCommit: true,\n\t\t\ttimeout:      true,\n\t\t\ttxToBroadcast: func() (*wire.MsgTx, error) {\n\t\t\t\twitness, err := input.ReceiverHtlcSpendTimeout(\n\t\t\t\t\tsigner, fakeSignDesc, sweepTx,\n\t\t\t\t\tfakeTimeout,\n\t\t\t\t)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\t// To avoid triggering the race detector by\n\t\t\t\t// setting the witness the second time this\n\t\t\t\t// method is called during tests, we return\n\t\t\t\t// immediately if the witness is already set\n\t\t\t\t// correctly.\n\t\t\t\tif reflect.DeepEqual(\n\t\t\t\t\ttemplateTx.TxIn[0].Witness, witness,\n\t\t\t\t) {\n\n\t\t\t\t\treturn templateTx, nil\n\t\t\t\t}\n\t\t\t\ttemplateTx.TxIn[0].Witness = witness\n\t\t\t\treturn templateTx, nil\n\t\t\t},\n\t\t\toutcome: channeldb.ResolverOutcomeTimeout,\n\t\t},\n\n\t\t// Our local commitment is broadcast, we timeout the HTLC and\n\t\t// still expect an HTLC fail resolution.\n\t\t{\n\t\t\tname:         \"timeout local tx\",\n\t\t\tremoteCommit: false,\n\t\t\ttimeout:      true,\n\t\t\ttxToBroadcast: func() (*wire.MsgTx, error) {\n\t\t\t\twitness, err := input.SenderHtlcSpendTimeout(\n\t\t\t\t\t&mock.DummySignature{}, txscript.SigHashAll,\n\t\t\t\t\tsigner, fakeSignDesc, sweepTx,\n\t\t\t\t)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\t// To avoid triggering the race detector by\n\t\t\t\t// setting the witness the second time this\n\t\t\t\t// method is called during tests, we return\n\t\t\t\t// immediately if the witness is already set\n\t\t\t\t// correctly.\n\t\t\t\tif reflect.DeepEqual(\n\t\t\t\t\ttemplateTx.TxIn[0].Witness, witness,\n\t\t\t\t) {\n\n\t\t\t\t\treturn templateTx, nil\n\t\t\t\t}\n\n\t\t\t\ttemplateTx.TxIn[0].Witness = witness\n\n\t\t\t\t// Set the outpoint to be on our commitment, since\n\t\t\t\t// we need to claim in two stages.\n\t\t\t\ttemplateTx.TxIn[0].PreviousOutPoint = testChanPoint1\n\t\t\t\treturn templateTx, nil\n\t\t\t},\n\t\t\toutcome: channeldb.ResolverOutcomeTimeout,\n\t\t},\n\n\t\t// The remote commitment is broadcast, they sweep with the\n\t\t// pre-image, we should get a settle HTLC resolution.\n\t\t{\n\t\t\tname:         \"success remote tx\",\n\t\t\tremoteCommit: true,\n\t\t\ttimeout:      false,\n\t\t\ttxToBroadcast: func() (*wire.MsgTx, error) {\n\t\t\t\twitness, err := input.ReceiverHtlcSpendRedeem(\n\t\t\t\t\t&mock.DummySignature{}, txscript.SigHashAll,\n\t\t\t\t\tfakePreimageBytes, signer, fakeSignDesc,\n\t\t\t\t\tsweepTx,\n\t\t\t\t)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\t// To avoid triggering the race detector by\n\t\t\t\t// setting the witness the second time this\n\t\t\t\t// method is called during tests, we return\n\t\t\t\t// immediately if the witness is already set\n\t\t\t\t// correctly.\n\t\t\t\tif reflect.DeepEqual(\n\t\t\t\t\ttemplateTx.TxIn[0].Witness, witness,\n\t\t\t\t) {\n\n\t\t\t\t\treturn templateTx, nil\n\t\t\t\t}\n\n\t\t\t\ttemplateTx.TxIn[0].Witness = witness\n\t\t\t\treturn templateTx, nil\n\t\t\t},\n\t\t\toutcome: channeldb.ResolverOutcomeClaimed,\n\t\t},\n\n\t\t// The local commitment is broadcast, they sweep it with a\n\t\t// timeout from the output, and we should still get the HTLC\n\t\t// settle resolution back.\n\t\t{\n\t\t\tname:         \"success local tx\",\n\t\t\tremoteCommit: false,\n\t\t\ttimeout:      false,\n\t\t\ttxToBroadcast: func() (*wire.MsgTx, error) {\n\t\t\t\twitness, err := input.SenderHtlcSpendRedeem(\n\t\t\t\t\tsigner, fakeSignDesc, sweepTx,\n\t\t\t\t\tfakePreimageBytes,\n\t\t\t\t)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\t// To avoid triggering the race detector by\n\t\t\t\t// setting the witness the second time this\n\t\t\t\t// method is called during tests, we return\n\t\t\t\t// immediately if the witness is already set\n\t\t\t\t// correctly.\n\t\t\t\tif reflect.DeepEqual(\n\t\t\t\t\ttemplateTx.TxIn[0].Witness, witness,\n\t\t\t\t) {\n\n\t\t\t\t\treturn templateTx, nil\n\t\t\t\t}\n\n\t\t\t\ttemplateTx.TxIn[0].Witness = witness\n\t\t\t\treturn templateTx, nil\n\t\t\t},\n\t\t\toutcome: channeldb.ResolverOutcomeClaimed,\n\t\t},\n\t}\n\n\tnotifier := &mock.ChainNotifier{\n\t\tEpochChan: make(chan *chainntnfs.BlockEpoch),\n\t\tSpendChan: make(chan *chainntnfs.SpendDetail),\n\t\tConfChan:  make(chan *chainntnfs.TxConfirmation),\n\t}\n\twitnessBeacon := newMockWitnessBeacon()\n\n\tfor _, testCase := range testCases {\n\t\tt.Logf(\"Running test case: %v\", testCase.name)\n\n\t\tcheckPointChan := make(chan struct{}, 1)\n\t\tincubateChan := make(chan struct{}, 1)\n\t\tresolutionChan := make(chan ResolutionMsg, 1)\n\t\treportChan := make(chan *channeldb.ResolverReport)\n\n\t\tchainCfg := ChannelArbitratorConfig{\n\t\t\tChainArbitratorConfig: ChainArbitratorConfig{\n\t\t\t\tNotifier:   notifier,\n\t\t\t\tPreimageDB: witnessBeacon,\n\t\t\t\tIncubateOutputs: func(wire.OutPoint,\n\t\t\t\t\t*lnwallet.OutgoingHtlcResolution,\n\t\t\t\t\t*lnwallet.IncomingHtlcResolution,\n\t\t\t\t\tuint32) error {\n\n\t\t\t\t\tincubateChan <- struct{}{}\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t\tDeliverResolutionMsg: func(msgs ...ResolutionMsg) error {\n\t\t\t\t\tif len(msgs) != 1 {\n\t\t\t\t\t\treturn fmt.Errorf(\"expected 1 \"+\n\t\t\t\t\t\t\t\"resolution msg, instead got %v\",\n\t\t\t\t\t\t\tlen(msgs))\n\t\t\t\t\t}\n\n\t\t\t\t\tresolutionChan <- msgs[0]\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t\tPutResolverReport: func(_ kvdb.RwTx,\n\t\t\t\t_ *channeldb.ResolverReport) error {\n\n\t\t\t\treturn nil\n\t\t\t},\n\t\t}\n\n\t\tcfg := ResolverConfig{\n\t\t\tChannelArbitratorConfig: chainCfg,\n\t\t\tCheckpoint: func(_ ContractResolver,\n\t\t\t\treports ...*channeldb.ResolverReport) error {\n\n\t\t\t\tcheckPointChan <- struct{}{}\n\n\t\t\t\t// Send all of our reports into the channel.\n\t\t\t\tfor _, report := range reports {\n\t\t\t\t\treportChan <- report\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t},\n\t\t}\n\t\tresolver := &htlcTimeoutResolver{\n\t\t\thtlcResolution: lnwallet.OutgoingHtlcResolution{\n\t\t\t\tClaimOutpoint: testChanPoint2,\n\t\t\t\tSweepSignDesc: *fakeSignDesc,\n\t\t\t},\n\t\t\tcontractResolverKit: *newContractResolverKit(\n\t\t\t\tcfg,\n\t\t\t),\n\t\t\thtlc: channeldb.HTLC{\n\t\t\t\tAmt: testHtlcAmt,\n\t\t\t},\n\t\t}\n\n\t\tvar reports []*channeldb.ResolverReport\n\n\t\t// If the test case needs the remote commitment to be\n\t\t// broadcast, then we'll set the timeout commit to a fake\n\t\t// transaction to force the code path.\n\t\tif !testCase.remoteCommit {\n\t\t\ttimeoutTx, err := testCase.txToBroadcast()\n\t\t\trequire.NoError(t, err)\n\n\t\t\tresolver.htlcResolution.SignedTimeoutTx = timeoutTx\n\n\t\t\tif testCase.timeout {\n\t\t\t\ttimeoutTxID := timeoutTx.TxHash()\n\t\t\t\treports = append(reports, &channeldb.ResolverReport{\n\t\t\t\t\tOutPoint:        timeoutTx.TxIn[0].PreviousOutPoint,\n\t\t\t\t\tAmount:          testHtlcAmt.ToSatoshis(),\n\t\t\t\t\tResolverType:    channeldb.ResolverTypeOutgoingHtlc,\n\t\t\t\t\tResolverOutcome: channeldb.ResolverOutcomeFirstStage,\n\t\t\t\t\tSpendTxID:       &timeoutTxID,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\t// With all the setup above complete, we can initiate the\n\t\t// resolution process, and the bulk of our test.\n\t\tvar wg sync.WaitGroup\n\t\tresolveErr := make(chan error, 1)\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\n\t\t\t_, err := resolver.Resolve()\n\t\t\tif err != nil {\n\t\t\t\tresolveErr <- err\n\t\t\t}\n\t\t}()\n\n\t\t// At the output isn't yet in the nursery, we expect that we\n\t\t// should receive an incubation request.\n\t\tselect {\n\t\tcase <-incubateChan:\n\t\tcase err := <-resolveErr:\n\t\t\tt.Fatalf(\"unable to resolve HTLC: %v\", err)\n\t\tcase <-time.After(time.Second * 5):\n\t\t\tt.Fatalf(\"failed to receive incubation request\")\n\t\t}\n\n\t\t// Next, the resolver should request a spend notification for\n\t\t// the direct HTLC output. We'll use the txToBroadcast closure\n\t\t// for the test case to generate the transaction that we'll\n\t\t// send to the resolver.\n\t\tspendingTx, err := testCase.txToBroadcast()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to generate tx: %v\", err)\n\t\t}\n\t\tspendTxHash := spendingTx.TxHash()\n\n\t\tselect {\n\t\tcase notifier.SpendChan <- &chainntnfs.SpendDetail{\n\t\t\tSpendingTx:    spendingTx,\n\t\t\tSpenderTxHash: &spendTxHash,\n\t\t}:\n\t\tcase <-time.After(time.Second * 5):\n\t\t\tt.Fatalf(\"failed to request spend ntfn\")\n\t\t}\n\n\t\tif !testCase.timeout {\n\t\t\t// If the resolver should settle now, then we'll\n\t\t\t// extract the pre-image to be extracted and the\n\t\t\t// resolution message sent.\n\t\t\tselect {\n\t\t\tcase newPreimage := <-witnessBeacon.newPreimages:\n\t\t\t\tif newPreimage[0] != fakePreimage {\n\t\t\t\t\tt.Fatalf(\"wrong pre-image: \"+\n\t\t\t\t\t\t\"expected %v, got %v\",\n\t\t\t\t\t\tfakePreimage, newPreimage)\n\t\t\t\t}\n\n\t\t\tcase <-time.After(time.Second * 5):\n\t\t\t\tt.Fatalf(\"pre-image not added\")\n\t\t\t}\n\n\t\t\t// Finally, we should get a resolution message with the\n\t\t\t// pre-image set within the message.\n\t\t\tselect {\n\t\t\tcase resolutionMsg := <-resolutionChan:\n\t\t\t\t// Once again, the pre-images should match up.\n\t\t\t\tif *resolutionMsg.PreImage != fakePreimage {\n\t\t\t\t\tt.Fatalf(\"wrong pre-image: \"+\n\t\t\t\t\t\t\"expected %v, got %v\",\n\t\t\t\t\t\tfakePreimage, resolutionMsg.PreImage)\n\t\t\t\t}\n\t\t\tcase <-time.After(time.Second * 5):\n\t\t\t\tt.Fatalf(\"resolution not sent\")\n\t\t\t}\n\t\t} else {\n\n\t\t\t// Otherwise, the HTLC should now timeout.  First, we\n\t\t\t// should get a resolution message with a populated\n\t\t\t// failure message.\n\t\t\tselect {\n\t\t\tcase resolutionMsg := <-resolutionChan:\n\t\t\t\tif resolutionMsg.Failure == nil {\n\t\t\t\t\tt.Fatalf(\"expected failure resolution msg\")\n\t\t\t\t}\n\t\t\tcase <-time.After(time.Second * 5):\n\t\t\t\tt.Fatalf(\"resolution not sent\")\n\t\t\t}\n\n\t\t\t// We should also get another request for the spend\n\t\t\t// notification of the second-level transaction to\n\t\t\t// indicate that it's been swept by the nursery, but\n\t\t\t// only if this is a local commitment transaction.\n\t\t\tif !testCase.remoteCommit {\n\t\t\t\tselect {\n\t\t\t\tcase notifier.SpendChan <- &chainntnfs.SpendDetail{\n\t\t\t\t\tSpendingTx:    spendingTx,\n\t\t\t\t\tSpenderTxHash: &spendTxHash,\n\t\t\t\t}:\n\t\t\t\tcase <-time.After(time.Second * 5):\n\t\t\t\t\tt.Fatalf(\"failed to request spend ntfn\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// In any case, before the resolver exits, it should checkpoint\n\t\t// its final state.\n\t\tselect {\n\t\tcase <-checkPointChan:\n\t\tcase err := <-resolveErr:\n\t\t\tt.Fatalf(\"unable to resolve HTLC: %v\", err)\n\t\tcase <-time.After(time.Second * 5):\n\t\t\tt.Fatalf(\"check point not received\")\n\t\t}\n\n\t\t// Add a report to our set of expected reports with the outcome\n\t\t// that the test specifies (either success or timeout).\n\t\tspendTxID := spendingTx.TxHash()\n\t\tamt := btcutil.Amount(fakeSignDesc.Output.Value)\n\n\t\treports = append(reports, &channeldb.ResolverReport{\n\t\t\tOutPoint:        testChanPoint2,\n\t\t\tAmount:          amt,\n\t\t\tResolverType:    channeldb.ResolverTypeOutgoingHtlc,\n\t\t\tResolverOutcome: testCase.outcome,\n\t\t\tSpendTxID:       &spendTxID,\n\t\t})\n\n\t\tfor _, report := range reports {\n\t\t\tassertResolverReport(t, reportChan, report)\n\t\t}\n\n\t\twg.Wait()\n\n\t\t// Finally, the resolver should be marked as resolved.\n\t\tif !resolver.resolved {\n\t\t\tt.Fatalf(\"resolver should be marked as resolved\")\n\t\t}\n\t}\n}\n\n// NOTE: the following tests essentially checks many of the same scenarios as\n// the test above, but they expand on it by checking resuming from checkpoints\n// at every stage.\n\n// TestHtlcTimeoutSingleStage tests a remote commitment confirming, and the\n// local node sweeping the HTLC output directly after timeout.",
      "length": 11536,
      "tokens": 1414,
      "embedding": []
    },
    {
      "slug": "func TestHtlcTimeoutSingleStage(t *testing.T) {",
      "content": "func TestHtlcTimeoutSingleStage(t *testing.T) {\n\tcommitOutpoint := wire.OutPoint{Index: 3}\n\n\tsweepTx := &wire.MsgTx{\n\t\tTxIn:  []*wire.TxIn{{}},\n\t\tTxOut: []*wire.TxOut{{}},\n\t}\n\n\t// singleStageResolution is a resolution for a htlc on the remote\n\t// party's commitment.\n\tsingleStageResolution := lnwallet.OutgoingHtlcResolution{\n\t\tClaimOutpoint: commitOutpoint,\n\t\tSweepSignDesc: testSignDesc,\n\t}\n\n\tsweepTxid := sweepTx.TxHash()\n\tclaim := &channeldb.ResolverReport{\n\t\tOutPoint:        commitOutpoint,\n\t\tAmount:          btcutil.Amount(testSignDesc.Output.Value),\n\t\tResolverType:    channeldb.ResolverTypeOutgoingHtlc,\n\t\tResolverOutcome: channeldb.ResolverOutcomeTimeout,\n\t\tSpendTxID:       &sweepTxid,\n\t}\n\n\tcheckpoints := []checkpoint{\n\t\t{\n\t\t\t// Output should be handed off to the nursery.\n\t\t\tincubating: true,\n\t\t},\n\t\t{\n\t\t\t// We send a confirmation the sweep tx from published\n\t\t\t// by the nursery.\n\t\t\tpreCheckpoint: func(ctx *htlcResolverTestContext,\n\t\t\t\t_ bool) error {\n\t\t\t\t// The nursery will create and publish a sweep\n\t\t\t\t// tx.\n\t\t\t\tctx.notifier.SpendChan <- &chainntnfs.SpendDetail{\n\t\t\t\t\tSpendingTx:    sweepTx,\n\t\t\t\t\tSpenderTxHash: &sweepTxid,\n\t\t\t\t}\n\n\t\t\t\t// The resolver should deliver a failure\n\t\t\t\t// resolition message (indicating we\n\t\t\t\t// successfully timed out the HTLC).\n\t\t\t\tselect {\n\t\t\t\tcase resolutionMsg := <-ctx.resolutionChan:\n\t\t\t\t\tif resolutionMsg.Failure == nil {\n\t\t\t\t\t\tt.Fatalf(\"expected failure resolution msg\")\n\t\t\t\t\t}\n\t\t\t\tcase <-time.After(time.Second * 5):\n\t\t\t\t\tt.Fatalf(\"resolution not sent\")\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t},\n\n\t\t\t// After the sweep has confirmed, we expect the\n\t\t\t// checkpoint to be resolved, and with the above\n\t\t\t// report.\n\t\t\tincubating: true,\n\t\t\tresolved:   true,\n\t\t\treports: []*channeldb.ResolverReport{\n\t\t\t\tclaim,\n\t\t\t},\n\t\t},\n\t}\n\n\ttestHtlcTimeout(\n\t\tt, singleStageResolution, checkpoints,\n\t)\n}\n\n// TestHtlcTimeoutSecondStage tests a local commitment being confirmed, and the\n// local node claiming the HTLC output using the second-level timeout tx.",
      "length": 1867,
      "tokens": 211,
      "embedding": []
    },
    {
      "slug": "func TestHtlcTimeoutSecondStage(t *testing.T) {",
      "content": "func TestHtlcTimeoutSecondStage(t *testing.T) {\n\tcommitOutpoint := wire.OutPoint{Index: 2}\n\thtlcOutpoint := wire.OutPoint{Index: 3}\n\n\tsweepTx := &wire.MsgTx{\n\t\tTxIn:  []*wire.TxIn{{}},\n\t\tTxOut: []*wire.TxOut{{}},\n\t}\n\tsweepHash := sweepTx.TxHash()\n\n\ttimeoutTx := &wire.MsgTx{\n\t\tTxIn: []*wire.TxIn{\n\t\t\t{\n\t\t\t\tPreviousOutPoint: commitOutpoint,\n\t\t\t},\n\t\t},\n\t\tTxOut: []*wire.TxOut{\n\t\t\t{\n\t\t\t\tValue:    111,\n\t\t\t\tPkScript: []byte{0xaa, 0xaa},\n\t\t\t},\n\t\t},\n\t}\n\n\tsigner := &mock.DummySigner{}\n\twitness, err := input.SenderHtlcSpendTimeout(\n\t\t&mock.DummySignature{}, txscript.SigHashAll,\n\t\tsigner, &testSignDesc, timeoutTx,\n\t)\n\trequire.NoError(t, err)\n\ttimeoutTx.TxIn[0].Witness = witness\n\n\ttimeoutTxid := timeoutTx.TxHash()\n\n\t// twoStageResolution is a resolution for a htlc on the local\n\t// party's commitment.\n\ttwoStageResolution := lnwallet.OutgoingHtlcResolution{\n\t\tClaimOutpoint:   htlcOutpoint,\n\t\tSignedTimeoutTx: timeoutTx,\n\t\tSweepSignDesc:   testSignDesc,\n\t}\n\n\tfirstStage := &channeldb.ResolverReport{\n\t\tOutPoint:        commitOutpoint,\n\t\tAmount:          testHtlcAmt.ToSatoshis(),\n\t\tResolverType:    channeldb.ResolverTypeOutgoingHtlc,\n\t\tResolverOutcome: channeldb.ResolverOutcomeFirstStage,\n\t\tSpendTxID:       &timeoutTxid,\n\t}\n\n\tsecondState := &channeldb.ResolverReport{\n\t\tOutPoint:        htlcOutpoint,\n\t\tAmount:          btcutil.Amount(testSignDesc.Output.Value),\n\t\tResolverType:    channeldb.ResolverTypeOutgoingHtlc,\n\t\tResolverOutcome: channeldb.ResolverOutcomeTimeout,\n\t\tSpendTxID:       &sweepHash,\n\t}\n\n\tcheckpoints := []checkpoint{\n\t\t{\n\t\t\t// Output should be handed off to the nursery.\n\t\t\tincubating: true,\n\t\t},\n\t\t{\n\t\t\t// We send a confirmation for our sweep tx to indicate\n\t\t\t// that our sweep succeeded.\n\t\t\tpreCheckpoint: func(ctx *htlcResolverTestContext,\n\t\t\t\t_ bool) error {\n\t\t\t\t// The nursery will publish the timeout tx.\n\t\t\t\tctx.notifier.SpendChan <- &chainntnfs.SpendDetail{\n\t\t\t\t\tSpendingTx:    timeoutTx,\n\t\t\t\t\tSpenderTxHash: &timeoutTxid,\n\t\t\t\t}\n\n\t\t\t\t// The resolver should deliver a failure\n\t\t\t\t// resolution message (indicating we\n\t\t\t\t// successfully timed out the HTLC).\n\t\t\t\tselect {\n\t\t\t\tcase resolutionMsg := <-ctx.resolutionChan:\n\t\t\t\t\tif resolutionMsg.Failure == nil {\n\t\t\t\t\t\tt.Fatalf(\"expected failure resolution msg\")\n\t\t\t\t\t}\n\t\t\t\tcase <-time.After(time.Second * 1):\n\t\t\t\t\tt.Fatalf(\"resolution not sent\")\n\t\t\t\t}\n\n\t\t\t\t// Deliver spend of timeout tx.\n\t\t\t\tctx.notifier.SpendChan <- &chainntnfs.SpendDetail{\n\t\t\t\t\tSpendingTx:    sweepTx,\n\t\t\t\t\tSpenderTxHash: &sweepHash,\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t},\n\n\t\t\t// After the sweep has confirmed, we expect the\n\t\t\t// checkpoint to be resolved, and with the above\n\t\t\t// reports.\n\t\t\tincubating: true,\n\t\t\tresolved:   true,\n\t\t\treports: []*channeldb.ResolverReport{\n\t\t\t\tfirstStage, secondState,\n\t\t\t},\n\t\t},\n\t}\n\n\ttestHtlcTimeout(\n\t\tt, twoStageResolution, checkpoints,\n\t)\n}\n\n// TestHtlcTimeoutSingleStageRemoteSpend tests that when a local commitment\n// confirms, and the remote spends the HTLC output directly, we detect this and\n// extract the preimage.",
      "length": 2833,
      "tokens": 291,
      "embedding": []
    },
    {
      "slug": "func TestHtlcTimeoutSingleStageRemoteSpend(t *testing.T) {",
      "content": "func TestHtlcTimeoutSingleStageRemoteSpend(t *testing.T) {\n\tcommitOutpoint := wire.OutPoint{Index: 2}\n\thtlcOutpoint := wire.OutPoint{Index: 3}\n\n\tspendTx := &wire.MsgTx{\n\t\tTxIn:  []*wire.TxIn{{}},\n\t\tTxOut: []*wire.TxOut{{}},\n\t}\n\n\tfakePreimageBytes := bytes.Repeat([]byte{1}, lntypes.HashSize)\n\tvar fakePreimage lntypes.Preimage\n\tcopy(fakePreimage[:], fakePreimageBytes)\n\n\tsigner := &mock.DummySigner{}\n\twitness, err := input.SenderHtlcSpendRedeem(\n\t\tsigner, &testSignDesc, spendTx,\n\t\tfakePreimageBytes,\n\t)\n\trequire.NoError(t, err)\n\tspendTx.TxIn[0].Witness = witness\n\n\tspendTxHash := spendTx.TxHash()\n\n\ttimeoutTx := &wire.MsgTx{\n\t\tTxIn: []*wire.TxIn{\n\t\t\t{\n\t\t\t\tPreviousOutPoint: commitOutpoint,\n\t\t\t},\n\t\t},\n\t\tTxOut: []*wire.TxOut{\n\t\t\t{\n\t\t\t\tValue:    123,\n\t\t\t\tPkScript: []byte{0xff, 0xff},\n\t\t\t},\n\t\t},\n\t}\n\n\ttimeoutWitness, err := input.SenderHtlcSpendTimeout(\n\t\t&mock.DummySignature{}, txscript.SigHashAll,\n\t\tsigner, &testSignDesc, timeoutTx,\n\t)\n\trequire.NoError(t, err)\n\ttimeoutTx.TxIn[0].Witness = timeoutWitness\n\n\t// twoStageResolution is a resolution for a htlc on the local\n\t// party's commitment.\n\ttwoStageResolution := lnwallet.OutgoingHtlcResolution{\n\t\tClaimOutpoint:   htlcOutpoint,\n\t\tSignedTimeoutTx: timeoutTx,\n\t\tSweepSignDesc:   testSignDesc,\n\t}\n\n\tclaim := &channeldb.ResolverReport{\n\t\tOutPoint:        htlcOutpoint,\n\t\tAmount:          btcutil.Amount(testSignDesc.Output.Value),\n\t\tResolverType:    channeldb.ResolverTypeOutgoingHtlc,\n\t\tResolverOutcome: channeldb.ResolverOutcomeClaimed,\n\t\tSpendTxID:       &spendTxHash,\n\t}\n\n\tcheckpoints := []checkpoint{\n\t\t{\n\t\t\t// Output should be handed off to the nursery.\n\t\t\tincubating: true,\n\t\t},\n\t\t{\n\t\t\t// We send a spend notification for a remote spend with\n\t\t\t// the preimage.\n\t\t\tpreCheckpoint: func(ctx *htlcResolverTestContext,\n\t\t\t\t_ bool) error {\n\n\t\t\t\twitnessBeacon := ctx.resolver.(*htlcTimeoutResolver).PreimageDB.(*mockWitnessBeacon)\n\n\t\t\t\t// The remote spends the output directly with\n\t\t\t\t// the preimage.\n\t\t\t\tctx.notifier.SpendChan <- &chainntnfs.SpendDetail{\n\t\t\t\t\tSpendingTx:    spendTx,\n\t\t\t\t\tSpenderTxHash: &spendTxHash,\n\t\t\t\t}\n\n\t\t\t\t// We should extract the preimage.\n\t\t\t\tselect {\n\t\t\t\tcase newPreimage := <-witnessBeacon.newPreimages:\n\t\t\t\t\tif newPreimage[0] != fakePreimage {\n\t\t\t\t\t\tt.Fatalf(\"wrong pre-image: \"+\n\t\t\t\t\t\t\t\"expected %v, got %v\",\n\t\t\t\t\t\t\tfakePreimage, newPreimage)\n\t\t\t\t\t}\n\n\t\t\t\tcase <-time.After(time.Second * 5):\n\t\t\t\t\tt.Fatalf(\"pre-image not added\")\n\t\t\t\t}\n\n\t\t\t\t// Finally, we should get a resolution message\n\t\t\t\t// with the pre-image set within the message.\n\t\t\t\tselect {\n\t\t\t\tcase resolutionMsg := <-ctx.resolutionChan:\n\t\t\t\t\tif *resolutionMsg.PreImage != fakePreimage {\n\t\t\t\t\t\tt.Fatalf(\"wrong pre-image: \"+\n\t\t\t\t\t\t\t\"expected %v, got %v\",\n\t\t\t\t\t\t\tfakePreimage, resolutionMsg.PreImage)\n\t\t\t\t\t}\n\t\t\t\tcase <-time.After(time.Second * 5):\n\t\t\t\t\tt.Fatalf(\"resolution not sent\")\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t},\n\n\t\t\t// After the success tx has confirmed, we expect the\n\t\t\t// checkpoint to be resolved, and with the above\n\t\t\t// report.\n\t\t\tincubating: true,\n\t\t\tresolved:   true,\n\t\t\treports: []*channeldb.ResolverReport{\n\t\t\t\tclaim,\n\t\t\t},\n\t\t},\n\t}\n\n\ttestHtlcTimeout(\n\t\tt, twoStageResolution, checkpoints,\n\t)\n}\n\n// TestHtlcTimeoutSecondStageRemoteSpend tests that when a remite commitment\n// confirms, and the remote spends the output using the success tx, we\n// properly detect this and extract the preimage.",
      "length": 3163,
      "tokens": 328,
      "embedding": []
    },
    {
      "slug": "func TestHtlcTimeoutSecondStageRemoteSpend(t *testing.T) {",
      "content": "func TestHtlcTimeoutSecondStageRemoteSpend(t *testing.T) {\n\tcommitOutpoint := wire.OutPoint{Index: 2}\n\n\tremoteSuccessTx := &wire.MsgTx{\n\t\tTxIn: []*wire.TxIn{\n\t\t\t{\n\t\t\t\tPreviousOutPoint: commitOutpoint,\n\t\t\t},\n\t\t},\n\t\tTxOut: []*wire.TxOut{},\n\t}\n\n\tfakePreimageBytes := bytes.Repeat([]byte{1}, lntypes.HashSize)\n\tvar fakePreimage lntypes.Preimage\n\tcopy(fakePreimage[:], fakePreimageBytes)\n\n\tsigner := &mock.DummySigner{}\n\twitness, err := input.ReceiverHtlcSpendRedeem(\n\t\t&mock.DummySignature{}, txscript.SigHashAll,\n\t\tfakePreimageBytes, signer,\n\t\t&testSignDesc, remoteSuccessTx,\n\t)\n\trequire.NoError(t, err)\n\n\tremoteSuccessTx.TxIn[0].Witness = witness\n\tsuccessTxid := remoteSuccessTx.TxHash()\n\n\t// singleStageResolution allwoing the local node to sweep HTLC output\n\t// directly from the remote commitment after timeout.\n\tsingleStageResolution := lnwallet.OutgoingHtlcResolution{\n\t\tClaimOutpoint: commitOutpoint,\n\t\tSweepSignDesc: testSignDesc,\n\t}\n\n\tclaim := &channeldb.ResolverReport{\n\t\tOutPoint:        commitOutpoint,\n\t\tAmount:          btcutil.Amount(testSignDesc.Output.Value),\n\t\tResolverType:    channeldb.ResolverTypeOutgoingHtlc,\n\t\tResolverOutcome: channeldb.ResolverOutcomeClaimed,\n\t\tSpendTxID:       &successTxid,\n\t}\n\n\tcheckpoints := []checkpoint{\n\t\t{\n\t\t\t// Output should be handed off to the nursery.\n\t\t\tincubating: true,\n\t\t},\n\t\t{\n\t\t\t// We send a confirmation for the remote's second layer\n\t\t\t// success transcation.\n\t\t\tpreCheckpoint: func(ctx *htlcResolverTestContext,\n\t\t\t\t_ bool) error {\n\n\t\t\t\tctx.notifier.SpendChan <- &chainntnfs.SpendDetail{\n\t\t\t\t\tSpendingTx:    remoteSuccessTx,\n\t\t\t\t\tSpenderTxHash: &successTxid,\n\t\t\t\t}\n\n\t\t\t\twitnessBeacon := ctx.resolver.(*htlcTimeoutResolver).PreimageDB.(*mockWitnessBeacon)\n\n\t\t\t\t// We expect the preimage to be extracted,\n\t\t\t\tselect {\n\t\t\t\tcase newPreimage := <-witnessBeacon.newPreimages:\n\t\t\t\t\tif newPreimage[0] != fakePreimage {\n\t\t\t\t\t\tt.Fatalf(\"wrong pre-image: \"+\n\t\t\t\t\t\t\t\"expected %v, got %v\",\n\t\t\t\t\t\t\tfakePreimage, newPreimage)\n\t\t\t\t\t}\n\n\t\t\t\tcase <-time.After(time.Second * 5):\n\t\t\t\t\tt.Fatalf(\"pre-image not added\")\n\t\t\t\t}\n\n\t\t\t\t// Finally, we should get a resolution message with the\n\t\t\t\t// pre-image set within the message.\n\t\t\t\tselect {\n\t\t\t\tcase resolutionMsg := <-ctx.resolutionChan:\n\t\t\t\t\tif *resolutionMsg.PreImage != fakePreimage {\n\t\t\t\t\t\tt.Fatalf(\"wrong pre-image: \"+\n\t\t\t\t\t\t\t\"expected %v, got %v\",\n\t\t\t\t\t\t\tfakePreimage, resolutionMsg.PreImage)\n\t\t\t\t\t}\n\t\t\t\tcase <-time.After(time.Second * 5):\n\t\t\t\t\tt.Fatalf(\"resolution not sent\")\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t},\n\n\t\t\t// After the sweep has confirmed, we expect the\n\t\t\t// checkpoint to be resolved, and with the above\n\t\t\t// report.\n\t\t\tincubating: true,\n\t\t\tresolved:   true,\n\t\t\treports: []*channeldb.ResolverReport{\n\t\t\t\tclaim,\n\t\t\t},\n\t\t},\n\t}\n\n\ttestHtlcTimeout(\n\t\tt, singleStageResolution, checkpoints,\n\t)\n}\n\n// TestHtlcTimeoutSecondStageSweeper tests that for anchor channels, when a\n// local commitment confirms, the timeout tx is handed to the sweeper to claim\n// the HTLC output.",
      "length": 2799,
      "tokens": 284,
      "embedding": []
    },
    {
      "slug": "func TestHtlcTimeoutSecondStageSweeper(t *testing.T) {",
      "content": "func TestHtlcTimeoutSecondStageSweeper(t *testing.T) {\n\tcommitOutpoint := wire.OutPoint{Index: 2}\n\thtlcOutpoint := wire.OutPoint{Index: 3}\n\n\tsweepTx := &wire.MsgTx{\n\t\tTxIn:  []*wire.TxIn{{}},\n\t\tTxOut: []*wire.TxOut{{}},\n\t}\n\tsweepHash := sweepTx.TxHash()\n\n\ttimeoutTx := &wire.MsgTx{\n\t\tTxIn: []*wire.TxIn{\n\t\t\t{\n\t\t\t\tPreviousOutPoint: commitOutpoint,\n\t\t\t},\n\t\t},\n\t\tTxOut: []*wire.TxOut{\n\t\t\t{\n\t\t\t\tValue:    123,\n\t\t\t\tPkScript: []byte{0xff, 0xff},\n\t\t\t},\n\t\t},\n\t}\n\n\t// We set the timeout witness since the script is used when subscribing\n\t// to spends.\n\tsigner := &mock.DummySigner{}\n\ttimeoutWitness, err := input.SenderHtlcSpendTimeout(\n\t\t&mock.DummySignature{}, txscript.SigHashAll,\n\t\tsigner, &testSignDesc, timeoutTx,\n\t)\n\trequire.NoError(t, err)\n\ttimeoutTx.TxIn[0].Witness = timeoutWitness\n\n\treSignedTimeoutTx := &wire.MsgTx{\n\t\tTxIn: []*wire.TxIn{\n\t\t\t{\n\t\t\t\tPreviousOutPoint: wire.OutPoint{\n\t\t\t\t\tHash:  chainhash.Hash{0xaa, 0xbb},\n\t\t\t\t\tIndex: 0,\n\t\t\t\t},\n\t\t\t},\n\t\t\ttimeoutTx.TxIn[0],\n\t\t\t{\n\t\t\t\tPreviousOutPoint: wire.OutPoint{\n\t\t\t\t\tHash:  chainhash.Hash{0xaa, 0xbb},\n\t\t\t\t\tIndex: 2,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\n\t\tTxOut: []*wire.TxOut{\n\t\t\t{\n\t\t\t\tValue:    111,\n\t\t\t\tPkScript: []byte{0xaa, 0xaa},\n\t\t\t},\n\t\t\ttimeoutTx.TxOut[0],\n\t\t},\n\t}\n\treSignedHash := reSignedTimeoutTx.TxHash()\n\treSignedOutPoint := wire.OutPoint{\n\t\tHash:  reSignedHash,\n\t\tIndex: 1,\n\t}\n\n\t// twoStageResolution is a resolution for a htlc on the local\n\t// party's commitment, where the timeout tx can be re-signed.\n\ttwoStageResolution := lnwallet.OutgoingHtlcResolution{\n\t\tClaimOutpoint:   htlcOutpoint,\n\t\tSignedTimeoutTx: timeoutTx,\n\t\tSignDetails: &input.SignDetails{\n\t\t\tSignDesc: testSignDesc,\n\t\t\tPeerSig:  testSig,\n\t\t},\n\t\tSweepSignDesc: testSignDesc,\n\t}\n\n\tfirstStage := &channeldb.ResolverReport{\n\t\tOutPoint:        commitOutpoint,\n\t\tAmount:          testHtlcAmt.ToSatoshis(),\n\t\tResolverType:    channeldb.ResolverTypeOutgoingHtlc,\n\t\tResolverOutcome: channeldb.ResolverOutcomeFirstStage,\n\t\tSpendTxID:       &reSignedHash,\n\t}\n\n\tsecondState := &channeldb.ResolverReport{\n\t\tOutPoint:        reSignedOutPoint,\n\t\tAmount:          btcutil.Amount(testSignDesc.Output.Value),\n\t\tResolverType:    channeldb.ResolverTypeOutgoingHtlc,\n\t\tResolverOutcome: channeldb.ResolverOutcomeTimeout,\n\t\tSpendTxID:       &sweepHash,\n\t}\n\n\tcheckpoints := []checkpoint{\n\t\t{\n\t\t\t// The output should be given to the sweeper.\n\t\t\tpreCheckpoint: func(ctx *htlcResolverTestContext,\n\t\t\t\t_ bool) error {\n\n\t\t\t\tresolver := ctx.resolver.(*htlcTimeoutResolver)\n\t\t\t\tinp := <-resolver.Sweeper.(*mockSweeper).sweptInputs\n\t\t\t\top := inp.OutPoint()\n\t\t\t\tif *op != commitOutpoint {\n\t\t\t\t\treturn fmt.Errorf(\"outpoint %v swept, \"+\n\t\t\t\t\t\t\"expected %v\", op,\n\t\t\t\t\t\tcommitOutpoint)\n\t\t\t\t}\n\n\t\t\t\t// Emulat the sweeper spending using the\n\t\t\t\t// re-signed timeout tx.\n\t\t\t\tctx.notifier.SpendChan <- &chainntnfs.SpendDetail{\n\t\t\t\t\tSpendingTx:        reSignedTimeoutTx,\n\t\t\t\t\tSpenderInputIndex: 1,\n\t\t\t\t\tSpenderTxHash:     &reSignedHash,\n\t\t\t\t\tSpendingHeight:    10,\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\t// incubating=true is used to signal that the\n\t\t\t// second-level transaction was confirmed.\n\t\t\tincubating: true,\n\t\t},\n\t\t{\n\t\t\t// We send a confirmation for our sweep tx to indicate\n\t\t\t// that our sweep succeeded.\n\t\t\tpreCheckpoint: func(ctx *htlcResolverTestContext,\n\t\t\t\tresumed bool) error {\n\n\t\t\t\t// If we are resuming from a checkpoint, we\n\t\t\t\t// expect the resolver to re-subscribe to a\n\t\t\t\t// spend, hence we must resend it.\n\t\t\t\tif resumed {\n\t\t\t\t\tctx.notifier.SpendChan <- &chainntnfs.SpendDetail{\n\t\t\t\t\t\tSpendingTx:        reSignedTimeoutTx,\n\t\t\t\t\t\tSpenderInputIndex: 1,\n\t\t\t\t\t\tSpenderTxHash:     &reSignedHash,\n\t\t\t\t\t\tSpendingHeight:    10,\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// The resolver should deliver a failure\n\t\t\t\t// resolution message (indicating we\n\t\t\t\t// successfully timed out the HTLC).\n\t\t\t\tselect {\n\t\t\t\tcase resolutionMsg := <-ctx.resolutionChan:\n\t\t\t\t\tif resolutionMsg.Failure == nil {\n\t\t\t\t\t\tt.Fatalf(\"expected failure resolution msg\")\n\t\t\t\t\t}\n\t\t\t\tcase <-time.After(time.Second * 1):\n\t\t\t\t\tt.Fatalf(\"resolution not sent\")\n\t\t\t\t}\n\n\t\t\t\t// Mimic CSV lock expiring.\n\t\t\t\tctx.notifier.EpochChan <- &chainntnfs.BlockEpoch{\n\t\t\t\t\tHeight: 13,\n\t\t\t\t}\n\n\t\t\t\t// The timeout tx output should now be given to\n\t\t\t\t// the sweeper.\n\t\t\t\tresolver := ctx.resolver.(*htlcTimeoutResolver)\n\t\t\t\tinp := <-resolver.Sweeper.(*mockSweeper).sweptInputs\n\t\t\t\top := inp.OutPoint()\n\t\t\t\texp := wire.OutPoint{\n\t\t\t\t\tHash:  reSignedHash,\n\t\t\t\t\tIndex: 1,\n\t\t\t\t}\n\t\t\t\tif *op != exp {\n\t\t\t\t\treturn fmt.Errorf(\"wrong outpoint swept\")\n\t\t\t\t}\n\n\t\t\t\t// Notify about the spend, which should resolve\n\t\t\t\t// the resolver.\n\t\t\t\tctx.notifier.SpendChan <- &chainntnfs.SpendDetail{\n\t\t\t\t\tSpendingTx:     sweepTx,\n\t\t\t\t\tSpenderTxHash:  &sweepHash,\n\t\t\t\t\tSpendingHeight: 14,\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t},\n\n\t\t\t// After the sweep has confirmed, we expect the\n\t\t\t// checkpoint to be resolved, and with the above\n\t\t\t// reports.\n\t\t\tincubating: true,\n\t\t\tresolved:   true,\n\t\t\treports: []*channeldb.ResolverReport{\n\t\t\t\tfirstStage,\n\t\t\t\tsecondState,\n\t\t\t},\n\t\t},\n\t}\n\n\ttestHtlcTimeout(\n\t\tt, twoStageResolution, checkpoints,\n\t)\n}\n\n// TestHtlcTimeoutSecondStageSweeperRemoteSpend tests that if a local timeout\n// tx is offered to the sweeper, but the output is swept by the remote node, we\n// properly detect this and extract the preimage.",
      "length": 4965,
      "tokens": 527,
      "embedding": []
    },
    {
      "slug": "func TestHtlcTimeoutSecondStageSweeperRemoteSpend(t *testing.T) {",
      "content": "func TestHtlcTimeoutSecondStageSweeperRemoteSpend(t *testing.T) {\n\tcommitOutpoint := wire.OutPoint{Index: 2}\n\thtlcOutpoint := wire.OutPoint{Index: 3}\n\n\ttimeoutTx := &wire.MsgTx{\n\t\tTxIn: []*wire.TxIn{\n\t\t\t{\n\t\t\t\tPreviousOutPoint: commitOutpoint,\n\t\t\t},\n\t\t},\n\t\tTxOut: []*wire.TxOut{\n\t\t\t{\n\t\t\t\tValue:    123,\n\t\t\t\tPkScript: []byte{0xff, 0xff},\n\t\t\t},\n\t\t},\n\t}\n\n\t// We set the timeout witness since the script is used when subscribing\n\t// to spends.\n\tsigner := &mock.DummySigner{}\n\ttimeoutWitness, err := input.SenderHtlcSpendTimeout(\n\t\t&mock.DummySignature{}, txscript.SigHashAll,\n\t\tsigner, &testSignDesc, timeoutTx,\n\t)\n\trequire.NoError(t, err)\n\ttimeoutTx.TxIn[0].Witness = timeoutWitness\n\n\tspendTx := &wire.MsgTx{\n\t\tTxIn:  []*wire.TxIn{{}},\n\t\tTxOut: []*wire.TxOut{{}},\n\t}\n\n\tfakePreimageBytes := bytes.Repeat([]byte{1}, lntypes.HashSize)\n\tvar fakePreimage lntypes.Preimage\n\tcopy(fakePreimage[:], fakePreimageBytes)\n\n\twitness, err := input.SenderHtlcSpendRedeem(\n\t\tsigner, &testSignDesc, spendTx,\n\t\tfakePreimageBytes,\n\t)\n\trequire.NoError(t, err)\n\tspendTx.TxIn[0].Witness = witness\n\n\tspendTxHash := spendTx.TxHash()\n\n\t// twoStageResolution is a resolution for a htlc on the local\n\t// party's commitment, where the timeout tx can be re-signed.\n\ttwoStageResolution := lnwallet.OutgoingHtlcResolution{\n\t\tClaimOutpoint:   htlcOutpoint,\n\t\tSignedTimeoutTx: timeoutTx,\n\t\tSignDetails: &input.SignDetails{\n\t\t\tSignDesc: testSignDesc,\n\t\t\tPeerSig:  testSig,\n\t\t},\n\t\tSweepSignDesc: testSignDesc,\n\t}\n\n\tclaim := &channeldb.ResolverReport{\n\t\tOutPoint:        htlcOutpoint,\n\t\tAmount:          btcutil.Amount(testSignDesc.Output.Value),\n\t\tResolverType:    channeldb.ResolverTypeOutgoingHtlc,\n\t\tResolverOutcome: channeldb.ResolverOutcomeClaimed,\n\t\tSpendTxID:       &spendTxHash,\n\t}\n\n\tcheckpoints := []checkpoint{\n\t\t{\n\t\t\t// The output should be given to the sweeper.\n\t\t\tpreCheckpoint: func(ctx *htlcResolverTestContext,\n\t\t\t\t_ bool) error {\n\n\t\t\t\tresolver := ctx.resolver.(*htlcTimeoutResolver)\n\t\t\t\tinp := <-resolver.Sweeper.(*mockSweeper).sweptInputs\n\t\t\t\top := inp.OutPoint()\n\t\t\t\tif *op != commitOutpoint {\n\t\t\t\t\treturn fmt.Errorf(\"outpoint %v swept, \"+\n\t\t\t\t\t\t\"expected %v\", op,\n\t\t\t\t\t\tcommitOutpoint)\n\t\t\t\t}\n\n\t\t\t\t// Emulate the remote sweeping the output with the preimage.\n\t\t\t\t// re-signed timeout tx.\n\t\t\t\tctx.notifier.SpendChan <- &chainntnfs.SpendDetail{\n\t\t\t\t\tSpendingTx:    spendTx,\n\t\t\t\t\tSpenderTxHash: &spendTxHash,\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\t// incubating=true is used to signal that the\n\t\t\t// second-level transaction was confirmed.\n\t\t\tincubating: true,\n\t\t},\n\t\t{\n\t\t\t// We send a confirmation for our sweep tx to indicate\n\t\t\t// that our sweep succeeded.\n\t\t\tpreCheckpoint: func(ctx *htlcResolverTestContext,\n\t\t\t\tresumed bool) error {\n\n\t\t\t\t// If we are resuming from a checkpoint, we\n\t\t\t\t// expect the resolver to re-subscribe to a\n\t\t\t\t// spend, hence we must resend it.\n\t\t\t\tif resumed {\n\t\t\t\t\tt.Logf(\"resumed\")\n\t\t\t\t\tctx.notifier.SpendChan <- &chainntnfs.SpendDetail{\n\t\t\t\t\t\tSpendingTx:    spendTx,\n\t\t\t\t\t\tSpenderTxHash: &spendTxHash,\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twitnessBeacon := ctx.resolver.(*htlcTimeoutResolver).PreimageDB.(*mockWitnessBeacon)\n\n\t\t\t\t// We should extract the preimage.\n\t\t\t\tselect {\n\t\t\t\tcase newPreimage := <-witnessBeacon.newPreimages:\n\t\t\t\t\tif newPreimage[0] != fakePreimage {\n\t\t\t\t\t\tt.Fatalf(\"wrong pre-image: \"+\n\t\t\t\t\t\t\t\"expected %v, got %v\",\n\t\t\t\t\t\t\tfakePreimage, newPreimage)\n\t\t\t\t\t}\n\n\t\t\t\tcase <-time.After(time.Second * 5):\n\t\t\t\t\tt.Fatalf(\"pre-image not added\")\n\t\t\t\t}\n\n\t\t\t\t// Finally, we should get a resolution message\n\t\t\t\t// with the pre-image set within the message.\n\t\t\t\tselect {\n\t\t\t\tcase resolutionMsg := <-ctx.resolutionChan:\n\t\t\t\t\tif *resolutionMsg.PreImage != fakePreimage {\n\t\t\t\t\t\tt.Fatalf(\"wrong pre-image: \"+\n\t\t\t\t\t\t\t\"expected %v, got %v\",\n\t\t\t\t\t\t\tfakePreimage, resolutionMsg.PreImage)\n\t\t\t\t\t}\n\t\t\t\tcase <-time.After(time.Second * 5):\n\t\t\t\t\tt.Fatalf(\"resolution not sent\")\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t},\n\n\t\t\t// After the sweep has confirmed, we expect the\n\t\t\t// checkpoint to be resolved, and with the above\n\t\t\t// reports.\n\t\t\tincubating: true,\n\t\t\tresolved:   true,\n\t\t\treports: []*channeldb.ResolverReport{\n\t\t\t\tclaim,\n\t\t\t},\n\t\t},\n\t}\n\n\ttestHtlcTimeout(\n\t\tt, twoStageResolution, checkpoints,\n\t)\n}\n",
      "length": 3949,
      "tokens": 417,
      "embedding": []
    },
    {
      "slug": "func testHtlcTimeout(t *testing.T, resolution lnwallet.OutgoingHtlcResolution,",
      "content": "func testHtlcTimeout(t *testing.T, resolution lnwallet.OutgoingHtlcResolution,\n\tcheckpoints []checkpoint) {\n\n\tdefer timeout()()\n\n\t// We first run the resolver from start to finish, ensuring it gets\n\t// checkpointed at every expected stage. We store the checkpointed data\n\t// for the next portion of the test.\n\tctx := newHtlcResolverTestContext(t,\n\t\tfunc(htlc channeldb.HTLC, cfg ResolverConfig) ContractResolver {\n\t\t\treturn &htlcTimeoutResolver{\n\t\t\t\tcontractResolverKit: *newContractResolverKit(cfg),\n\t\t\t\thtlc:                htlc,\n\t\t\t\thtlcResolution:      resolution,\n\t\t\t}\n\t\t},\n\t)\n\n\tcheckpointedState := runFromCheckpoint(t, ctx, checkpoints)\n\n\t// Now, from every checkpoint created, we re-create the resolver, and\n\t// run the test from that checkpoint.\n\tfor i := range checkpointedState {\n\t\tcp := bytes.NewReader(checkpointedState[i])\n\t\tctx := newHtlcResolverTestContext(t,\n\t\t\tfunc(htlc channeldb.HTLC, cfg ResolverConfig) ContractResolver {\n\t\t\t\tresolver, err := newTimeoutResolverFromReader(cp, cfg)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\n\t\t\t\tresolver.Supplement(htlc)\n\t\t\t\tresolver.htlcResolution = resolution\n\t\t\t\treturn resolver\n\t\t\t},\n\t\t)\n\n\t\t// Run from the given checkpoint, ensuring we'll hit the rest.\n\t\t_ = runFromCheckpoint(t, ctx, checkpoints[i+1:])\n\t}\n}\n",
      "length": 1152,
      "tokens": 136,
      "embedding": []
    }
  ]
}