{
  "filepath": "../implementations/go/lnd/contractcourt/briefcase_test.go",
  "package": "contractcourt",
  "sections": [
    {
      "slug": "func makeTestDB(t *testing.T) (kvdb.Backend, error) {",
      "content": "func makeTestDB(t *testing.T) (kvdb.Backend, error) {\n\tdb, err := kvdb.Create(\n\t\tkvdb.BoltBackendName, t.TempDir()+\"/test.db\", true,\n\t\tkvdb.DefaultDBTimeout,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tt.Cleanup(func() {\n\t\tdb.Close()\n\t})\n\n\treturn db, nil\n}\n",
      "length": 188,
      "tokens": 26,
      "embedding": []
    },
    {
      "slug": "func newTestBoltArbLog(t *testing.T, chainhash chainhash.Hash,",
      "content": "func newTestBoltArbLog(t *testing.T, chainhash chainhash.Hash,\n\top wire.OutPoint) (ArbitratorLog, error) {\n\n\ttestDB, err := makeTestDB(t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ttestArbCfg := ChannelArbitratorConfig{\n\t\tPutResolverReport: func(_ kvdb.RwTx,\n\t\t\t_ *channeldb.ResolverReport) error {\n\n\t\t\treturn nil\n\t\t},\n\t}\n\ttestLog, err := newBoltArbitratorLog(testDB, testArbCfg, chainhash, op)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn testLog, err\n}\n",
      "length": 370,
      "tokens": 52,
      "embedding": []
    },
    {
      "slug": "func randOutPoint() wire.OutPoint {",
      "content": "func randOutPoint() wire.OutPoint {\n\tvar op wire.OutPoint\n\trand.Read(op.Hash[:])\n\top.Index = prand.Uint32()\n\n\treturn op\n}\n",
      "length": 80,
      "tokens": 10,
      "embedding": []
    },
    {
      "slug": "func assertResolversEqual(t *testing.T, originalResolver ContractResolver,",
      "content": "func assertResolversEqual(t *testing.T, originalResolver ContractResolver,\n\tdiskResolver ContractResolver) {\n\n\tassertTimeoutResEqual := func(ogRes, diskRes *htlcTimeoutResolver) {\n\t\tif !reflect.DeepEqual(ogRes.htlcResolution, diskRes.htlcResolution) {\n\t\t\tt.Fatalf(\"resolution mismatch: expected %#v, got %v#\",\n\t\t\t\togRes.htlcResolution, diskRes.htlcResolution)\n\t\t}\n\t\tif ogRes.outputIncubating != diskRes.outputIncubating {\n\t\t\tt.Fatalf(\"expected %v, got %v\",\n\t\t\t\togRes.outputIncubating, diskRes.outputIncubating)\n\t\t}\n\t\tif ogRes.resolved != diskRes.resolved {\n\t\t\tt.Fatalf(\"expected %v, got %v\", ogRes.resolved,\n\t\t\t\tdiskRes.resolved)\n\t\t}\n\t\tif ogRes.broadcastHeight != diskRes.broadcastHeight {\n\t\t\tt.Fatalf(\"expected %v, got %v\",\n\t\t\t\togRes.broadcastHeight, diskRes.broadcastHeight)\n\t\t}\n\t\tif ogRes.htlc.HtlcIndex != diskRes.htlc.HtlcIndex {\n\t\t\tt.Fatalf(\"expected %v, got %v\", ogRes.htlc.HtlcIndex,\n\t\t\t\tdiskRes.htlc.HtlcIndex)\n\t\t}\n\t}\n\n\tassertSuccessResEqual := func(ogRes, diskRes *htlcSuccessResolver) {\n\t\tif !reflect.DeepEqual(ogRes.htlcResolution, diskRes.htlcResolution) {\n\t\t\tt.Fatalf(\"resolution mismatch: expected %#v, got %v#\",\n\t\t\t\togRes.htlcResolution, diskRes.htlcResolution)\n\t\t}\n\t\tif ogRes.outputIncubating != diskRes.outputIncubating {\n\t\t\tt.Fatalf(\"expected %v, got %v\",\n\t\t\t\togRes.outputIncubating, diskRes.outputIncubating)\n\t\t}\n\t\tif ogRes.resolved != diskRes.resolved {\n\t\t\tt.Fatalf(\"expected %v, got %v\", ogRes.resolved,\n\t\t\t\tdiskRes.resolved)\n\t\t}\n\t\tif ogRes.broadcastHeight != diskRes.broadcastHeight {\n\t\t\tt.Fatalf(\"expected %v, got %v\",\n\t\t\t\togRes.broadcastHeight, diskRes.broadcastHeight)\n\t\t}\n\t\tif ogRes.htlc.RHash != diskRes.htlc.RHash {\n\t\t\tt.Fatalf(\"expected %v, got %v\", ogRes.htlc.RHash,\n\t\t\t\tdiskRes.htlc.RHash)\n\t\t}\n\t}\n\n\tswitch ogRes := originalResolver.(type) {\n\tcase *htlcTimeoutResolver:\n\t\tdiskRes := diskResolver.(*htlcTimeoutResolver)\n\t\tassertTimeoutResEqual(ogRes, diskRes)\n\n\tcase *htlcSuccessResolver:\n\t\tdiskRes := diskResolver.(*htlcSuccessResolver)\n\t\tassertSuccessResEqual(ogRes, diskRes)\n\n\tcase *htlcOutgoingContestResolver:\n\t\tdiskRes := diskResolver.(*htlcOutgoingContestResolver)\n\t\tassertTimeoutResEqual(\n\t\t\togRes.htlcTimeoutResolver, diskRes.htlcTimeoutResolver,\n\t\t)\n\n\tcase *htlcIncomingContestResolver:\n\t\tdiskRes := diskResolver.(*htlcIncomingContestResolver)\n\t\tassertSuccessResEqual(\n\t\t\togRes.htlcSuccessResolver, diskRes.htlcSuccessResolver,\n\t\t)\n\n\t\tif ogRes.htlcExpiry != diskRes.htlcExpiry {\n\t\t\tt.Fatalf(\"expected %v, got %v\", ogRes.htlcExpiry,\n\t\t\t\tdiskRes.htlcExpiry)\n\t\t}\n\n\tcase *commitSweepResolver:\n\t\tdiskRes := diskResolver.(*commitSweepResolver)\n\t\tif !reflect.DeepEqual(ogRes.commitResolution, diskRes.commitResolution) {\n\t\t\tt.Fatalf(\"resolution mismatch: expected %v, got %v\",\n\t\t\t\togRes.commitResolution, diskRes.commitResolution)\n\t\t}\n\t\tif ogRes.resolved != diskRes.resolved {\n\t\t\tt.Fatalf(\"expected %v, got %v\", ogRes.resolved,\n\t\t\t\tdiskRes.resolved)\n\t\t}\n\t\tif ogRes.broadcastHeight != diskRes.broadcastHeight {\n\t\t\tt.Fatalf(\"expected %v, got %v\",\n\t\t\t\togRes.broadcastHeight, diskRes.broadcastHeight)\n\t\t}\n\t\tif ogRes.chanPoint != diskRes.chanPoint {\n\t\t\tt.Fatalf(\"expected %v, got %v\", ogRes.chanPoint,\n\t\t\t\tdiskRes.chanPoint)\n\t\t}\n\t}\n}\n\n// TestContractInsertionRetrieval tests that were able to insert a set of\n// unresolved contracts into the log, and retrieve the same set properly.",
      "length": 3139,
      "tokens": 267,
      "embedding": []
    },
    {
      "slug": "func TestContractInsertionRetrieval(t *testing.T) {",
      "content": "func TestContractInsertionRetrieval(t *testing.T) {\n\tt.Parallel()\n\n\t// First, we'll create a test instance of the ArbitratorLog\n\t// implementation backed by boltdb.\n\ttestLog, err := newTestBoltArbLog(\n\t\tt, testChainHash, testChanPoint1,\n\t)\n\trequire.NoError(t, err, \"unable to create test log\")\n\n\t// The log created, we'll create a series of resolvers, each properly\n\t// implementing the ContractResolver interface.\n\ttimeoutResolver := htlcTimeoutResolver{\n\t\thtlcResolution: lnwallet.OutgoingHtlcResolution{\n\t\t\tExpiry:          99,\n\t\t\tSignedTimeoutTx: nil,\n\t\t\tCsvDelay:        99,\n\t\t\tClaimOutpoint:   randOutPoint(),\n\t\t\tSweepSignDesc:   testSignDesc,\n\t\t},\n\t\toutputIncubating: true,\n\t\tresolved:         true,\n\t\tbroadcastHeight:  102,\n\t\thtlc: channeldb.HTLC{\n\t\t\tHtlcIndex: 12,\n\t\t},\n\t}\n\tsuccessResolver := htlcSuccessResolver{\n\t\thtlcResolution: lnwallet.IncomingHtlcResolution{\n\t\t\tPreimage:        testPreimage,\n\t\t\tSignedSuccessTx: nil,\n\t\t\tCsvDelay:        900,\n\t\t\tClaimOutpoint:   randOutPoint(),\n\t\t\tSweepSignDesc:   testSignDesc,\n\t\t},\n\t\toutputIncubating: true,\n\t\tresolved:         true,\n\t\tbroadcastHeight:  109,\n\t\thtlc: channeldb.HTLC{\n\t\t\tRHash: testPreimage,\n\t\t},\n\t\tsweepTx: nil,\n\t}\n\tresolvers := []ContractResolver{\n\t\t&timeoutResolver,\n\t\t&successResolver,\n\t\t&commitSweepResolver{\n\t\t\tcommitResolution: lnwallet.CommitOutputResolution{\n\t\t\t\tSelfOutPoint:       testChanPoint2,\n\t\t\t\tSelfOutputSignDesc: testSignDesc,\n\t\t\t\tMaturityDelay:      99,\n\t\t\t},\n\t\t\tresolved:        false,\n\t\t\tbroadcastHeight: 109,\n\t\t\tchanPoint:       testChanPoint1,\n\t\t},\n\t}\n\n\t// All resolvers require a unique ResolverKey() output. To achieve this\n\t// for the composite resolvers, we'll mutate the underlying resolver\n\t// with a new outpoint.\n\tcontestTimeout := timeoutResolver\n\tcontestTimeout.htlcResolution.ClaimOutpoint = randOutPoint()\n\tresolvers = append(resolvers, &htlcOutgoingContestResolver{\n\t\thtlcTimeoutResolver: &contestTimeout,\n\t})\n\tcontestSuccess := successResolver\n\tcontestSuccess.htlcResolution.ClaimOutpoint = randOutPoint()\n\tresolvers = append(resolvers, &htlcIncomingContestResolver{\n\t\thtlcExpiry:          100,\n\t\thtlcSuccessResolver: &contestSuccess,\n\t})\n\n\t// For quick lookup during the test, we'll create this map which allow\n\t// us to lookup a resolver according to its unique resolver key.\n\tresolverMap := make(map[string]ContractResolver)\n\tresolverMap[string(timeoutResolver.ResolverKey())] = resolvers[0]\n\tresolverMap[string(successResolver.ResolverKey())] = resolvers[1]\n\tresolverMap[string(resolvers[2].ResolverKey())] = resolvers[2]\n\tresolverMap[string(resolvers[3].ResolverKey())] = resolvers[3]\n\tresolverMap[string(resolvers[4].ResolverKey())] = resolvers[4]\n\n\t// Now, we'll insert the resolver into the log, we do not need to apply\n\t// any closures, so we will pass in nil.\n\terr = testLog.InsertUnresolvedContracts(nil, resolvers...)\n\trequire.NoError(t, err, \"unable to insert resolvers\")\n\n\t// With the resolvers inserted, we'll now attempt to retrieve them from\n\t// the database, so we can compare them to the versions we created\n\t// above.\n\tdiskResolvers, err := testLog.FetchUnresolvedContracts()\n\trequire.NoError(t, err, \"unable to retrieve resolvers\")\n\n\tif len(diskResolvers) != len(resolvers) {\n\t\tt.Fatalf(\"expected %v got resolvers, instead got %v: %#v\",\n\t\t\tlen(resolvers), len(diskResolvers),\n\t\t\tdiskResolvers)\n\t}\n\n\t// Now we'll run through each of the resolvers, and ensure that it maps\n\t// to a resolver perfectly that we inserted previously.\n\tfor _, diskResolver := range diskResolvers {\n\t\tresKey := string(diskResolver.ResolverKey())\n\t\toriginalResolver, ok := resolverMap[resKey]\n\t\tif !ok {\n\t\t\tt.Fatalf(\"unable to find resolver match for %T: %v\",\n\t\t\t\tdiskResolver, resKey)\n\t\t}\n\n\t\tassertResolversEqual(t, originalResolver, diskResolver)\n\t}\n\n\t// We'll now delete the state, then attempt to retrieve the set of\n\t// resolvers, no resolvers should be found.\n\tif err := testLog.WipeHistory(); err != nil {\n\t\tt.Fatalf(\"unable to wipe log: %v\", err)\n\t}\n\tdiskResolvers, err = testLog.FetchUnresolvedContracts()\n\trequire.NoError(t, err, \"unable to fetch unresolved contracts\")\n\tif len(diskResolvers) != 0 {\n\t\tt.Fatalf(\"no resolvers should be found, instead %v were\",\n\t\t\tlen(diskResolvers))\n\t}\n}\n\n// TestContractResolution tests that once we mark a contract as resolved, it's\n// properly removed from the database.",
      "length": 4138,
      "tokens": 449,
      "embedding": []
    },
    {
      "slug": "func TestContractResolution(t *testing.T) {",
      "content": "func TestContractResolution(t *testing.T) {\n\tt.Parallel()\n\n\t// First, we'll create a test instance of the ArbitratorLog\n\t// implementation backed by boltdb.\n\ttestLog, err := newTestBoltArbLog(\n\t\tt, testChainHash, testChanPoint1,\n\t)\n\trequire.NoError(t, err, \"unable to create test log\")\n\n\t// We'll now create a timeout resolver that we'll be using for the\n\t// duration of this test.\n\ttimeoutResolver := &htlcTimeoutResolver{\n\t\thtlcResolution: lnwallet.OutgoingHtlcResolution{\n\t\t\tExpiry:          991,\n\t\t\tSignedTimeoutTx: nil,\n\t\t\tCsvDelay:        992,\n\t\t\tClaimOutpoint:   randOutPoint(),\n\t\t\tSweepSignDesc:   testSignDesc,\n\t\t},\n\t\toutputIncubating: true,\n\t\tresolved:         true,\n\t\tbroadcastHeight:  192,\n\t\thtlc: channeldb.HTLC{\n\t\t\tHtlcIndex: 9912,\n\t\t},\n\t}\n\n\t// First, we'll insert the resolver into the database and ensure that\n\t// we get the same resolver out the other side. We do not need to apply\n\t// any closures.\n\terr = testLog.InsertUnresolvedContracts(nil, timeoutResolver)\n\trequire.NoError(t, err, \"unable to insert contract into db\")\n\tdbContracts, err := testLog.FetchUnresolvedContracts()\n\trequire.NoError(t, err, \"unable to fetch contracts from db\")\n\tassertResolversEqual(t, timeoutResolver, dbContracts[0])\n\n\t// Now, we'll mark the contract as resolved within the database.\n\tif err := testLog.ResolveContract(timeoutResolver); err != nil {\n\t\tt.Fatalf(\"unable to resolve contract: %v\", err)\n\t}\n\n\t// At this point, no contracts should exist within the log.\n\tdbContracts, err = testLog.FetchUnresolvedContracts()\n\trequire.NoError(t, err, \"unable to fetch contracts from db\")\n\tif len(dbContracts) != 0 {\n\t\tt.Fatalf(\"no contract should be from in the db, instead %v \"+\n\t\t\t\"were\", len(dbContracts))\n\t}\n}\n\n// TestContractSwapping ensures that callers are able to atomically swap to\n// distinct contracts for one another.",
      "length": 1729,
      "tokens": 221,
      "embedding": []
    },
    {
      "slug": "func TestContractSwapping(t *testing.T) {",
      "content": "func TestContractSwapping(t *testing.T) {\n\tt.Parallel()\n\n\t// First, we'll create a test instance of the ArbitratorLog\n\t// implementation backed by boltdb.\n\ttestLog, err := newTestBoltArbLog(\n\t\tt, testChainHash, testChanPoint1,\n\t)\n\trequire.NoError(t, err, \"unable to create test log\")\n\n\t// We'll create two resolvers, a regular timeout resolver, and the\n\t// contest resolver that eventually turns into the timeout resolver.\n\ttimeoutResolver := &htlcTimeoutResolver{\n\t\thtlcResolution: lnwallet.OutgoingHtlcResolution{\n\t\t\tExpiry:          99,\n\t\t\tSignedTimeoutTx: nil,\n\t\t\tCsvDelay:        99,\n\t\t\tClaimOutpoint:   randOutPoint(),\n\t\t\tSweepSignDesc:   testSignDesc,\n\t\t},\n\t\toutputIncubating: true,\n\t\tresolved:         true,\n\t\tbroadcastHeight:  102,\n\t\thtlc: channeldb.HTLC{\n\t\t\tHtlcIndex: 12,\n\t\t},\n\t}\n\tcontestResolver := &htlcOutgoingContestResolver{\n\t\thtlcTimeoutResolver: timeoutResolver,\n\t}\n\n\t// We'll first insert the contest resolver into the log with no\n\t// additional updates.\n\terr = testLog.InsertUnresolvedContracts(nil, contestResolver)\n\trequire.NoError(t, err, \"unable to insert contract into db\")\n\n\t// With the resolver inserted, we'll now attempt to atomically swap it\n\t// for its underlying timeout resolver.\n\terr = testLog.SwapContract(contestResolver, timeoutResolver)\n\trequire.NoError(t, err, \"unable to swap contracts\")\n\n\t// At this point, there should now only be a single contract in the\n\t// database.\n\tdbContracts, err := testLog.FetchUnresolvedContracts()\n\trequire.NoError(t, err, \"unable to fetch contracts from db\")\n\tif len(dbContracts) != 1 {\n\t\tt.Fatalf(\"one contract should be from in the db, instead %v \"+\n\t\t\t\"were\", len(dbContracts))\n\t}\n\n\t// That single contract should be the underlying timeout resolver.\n\tassertResolversEqual(t, timeoutResolver, dbContracts[0])\n}\n\n// TestContractResolutionsStorage tests that we're able to properly store and\n// retrieve contract resolutions written to disk.",
      "length": 1816,
      "tokens": 219,
      "embedding": []
    },
    {
      "slug": "func TestContractResolutionsStorage(t *testing.T) {",
      "content": "func TestContractResolutionsStorage(t *testing.T) {\n\tt.Parallel()\n\n\t// First, we'll create a test instance of the ArbitratorLog\n\t// implementation backed by boltdb.\n\ttestLog, err := newTestBoltArbLog(\n\t\tt, testChainHash, testChanPoint1,\n\t)\n\trequire.NoError(t, err, \"unable to create test log\")\n\n\t// With the test log created, we'll now craft a contact resolution that\n\t// will be using for the duration of this test.\n\tres := ContractResolutions{\n\t\tCommitHash: testChainHash,\n\t\tCommitResolution: &lnwallet.CommitOutputResolution{\n\t\t\tSelfOutPoint:       testChanPoint2,\n\t\t\tSelfOutputSignDesc: testSignDesc,\n\t\t\tMaturityDelay:      101,\n\t\t},\n\t\tHtlcResolutions: lnwallet.HtlcResolutions{\n\t\t\tIncomingHTLCs: []lnwallet.IncomingHtlcResolution{\n\t\t\t\t{\n\t\t\t\t\tPreimage:        testPreimage,\n\t\t\t\t\tSignedSuccessTx: nil,\n\t\t\t\t\tCsvDelay:        900,\n\t\t\t\t\tClaimOutpoint:   randOutPoint(),\n\t\t\t\t\tSweepSignDesc:   testSignDesc,\n\t\t\t\t},\n\n\t\t\t\t// We add a resolution with SignDetails.\n\t\t\t\t{\n\t\t\t\t\tPreimage:        testPreimage,\n\t\t\t\t\tSignedSuccessTx: testTx,\n\t\t\t\t\tSignDetails:     testSignDetails,\n\t\t\t\t\tCsvDelay:        900,\n\t\t\t\t\tClaimOutpoint:   randOutPoint(),\n\t\t\t\t\tSweepSignDesc:   testSignDesc,\n\t\t\t\t},\n\n\t\t\t\t// We add a resolution with a signed tx, but no\n\t\t\t\t// SignDetails.\n\t\t\t\t{\n\t\t\t\t\tPreimage:        testPreimage,\n\t\t\t\t\tSignedSuccessTx: testTx,\n\t\t\t\t\tCsvDelay:        900,\n\t\t\t\t\tClaimOutpoint:   randOutPoint(),\n\t\t\t\t\tSweepSignDesc:   testSignDesc,\n\t\t\t\t},\n\t\t\t},\n\t\t\tOutgoingHTLCs: []lnwallet.OutgoingHtlcResolution{\n\t\t\t\t// We add a resolution with a signed tx, but no\n\t\t\t\t// SignDetails.\n\t\t\t\t{\n\t\t\t\t\tExpiry:          103,\n\t\t\t\t\tSignedTimeoutTx: testTx,\n\t\t\t\t\tCsvDelay:        923923,\n\t\t\t\t\tClaimOutpoint:   randOutPoint(),\n\t\t\t\t\tSweepSignDesc:   testSignDesc,\n\t\t\t\t},\n\t\t\t\t// Resolution without signed tx.\n\t\t\t\t{\n\t\t\t\t\tExpiry:          103,\n\t\t\t\t\tSignedTimeoutTx: nil,\n\t\t\t\t\tCsvDelay:        923923,\n\t\t\t\t\tClaimOutpoint:   randOutPoint(),\n\t\t\t\t\tSweepSignDesc:   testSignDesc,\n\t\t\t\t},\n\t\t\t\t// Resolution with SignDetails.\n\t\t\t\t{\n\t\t\t\t\tExpiry:          103,\n\t\t\t\t\tSignedTimeoutTx: testTx,\n\t\t\t\t\tSignDetails:     testSignDetails,\n\t\t\t\t\tCsvDelay:        923923,\n\t\t\t\t\tClaimOutpoint:   randOutPoint(),\n\t\t\t\t\tSweepSignDesc:   testSignDesc,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tAnchorResolution: &lnwallet.AnchorResolution{\n\t\t\tCommitAnchor:         testChanPoint3,\n\t\t\tAnchorSignDescriptor: testSignDesc,\n\t\t},\n\t}\n\n\t// First make sure that fetching unlogged contract resolutions will\n\t// fail.\n\t_, err = testLog.FetchContractResolutions()\n\tif err == nil {\n\t\tt.Fatalf(\"expected reading unlogged resolution from db to fail\")\n\t}\n\n\t// Insert the resolution into the database, then immediately retrieve\n\t// them so we can compare equality against the original version.\n\tif err := testLog.LogContractResolutions(&res); err != nil {\n\t\tt.Fatalf(\"unable to insert resolutions into db: %v\", err)\n\t}\n\tdiskRes, err := testLog.FetchContractResolutions()\n\trequire.NoError(t, err, \"unable to read resolution from db\")\n\n\tif !reflect.DeepEqual(&res, diskRes) {\n\t\tt.Fatalf(\"resolution mismatch: expected %v\\n, got %v\",\n\t\t\tspew.Sdump(&res), spew.Sdump(diskRes))\n\t}\n\n\t// We'll now delete the state, then attempt to retrieve the set of\n\t// resolvers, no resolutions should be found.\n\tif err := testLog.WipeHistory(); err != nil {\n\t\tt.Fatalf(\"unable to wipe log: %v\", err)\n\t}\n\t_, err = testLog.FetchContractResolutions()\n\tif err != errScopeBucketNoExist {\n\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t}\n}\n\n// TestStateMutation tests that we're able to properly mutate the state of the\n// log, then retrieve that same mutated state from disk.",
      "length": 3374,
      "tokens": 369,
      "embedding": []
    },
    {
      "slug": "func TestStateMutation(t *testing.T) {",
      "content": "func TestStateMutation(t *testing.T) {\n\tt.Parallel()\n\n\ttestLog, err := newTestBoltArbLog(\n\t\tt, testChainHash, testChanPoint1,\n\t)\n\trequire.NoError(t, err, \"unable to create test log\")\n\n\t// The default state of an arbitrator should be StateDefault.\n\tarbState, err := testLog.CurrentState(nil)\n\trequire.NoError(t, err, \"unable to read arb state\")\n\tif arbState != StateDefault {\n\t\tt.Fatalf(\"state mismatch: expected %v, got %v\", StateDefault,\n\t\t\tarbState)\n\t}\n\n\t// We should now be able to mutate the state to an arbitrary one of our\n\t// choosing, then read that same state back from disk.\n\tif err := testLog.CommitState(StateFullyResolved); err != nil {\n\t\tt.Fatalf(\"unable to write state: %v\", err)\n\t}\n\tarbState, err = testLog.CurrentState(nil)\n\trequire.NoError(t, err, \"unable to read arb state\")\n\tif arbState != StateFullyResolved {\n\t\tt.Fatalf(\"state mismatch: expected %v, got %v\", StateFullyResolved,\n\t\t\tarbState)\n\t}\n\n\t// Next, we'll wipe our state and ensure that if we try to query for\n\t// the current state, we get the proper error.\n\terr = testLog.WipeHistory()\n\trequire.NoError(t, err, \"unable to wipe history\")\n\n\t// If we try to query for the state again, we should get the default\n\t// state again.\n\tarbState, err = testLog.CurrentState(nil)\n\trequire.NoError(t, err, \"unable to query current state\")\n\tif arbState != StateDefault {\n\t\tt.Fatalf(\"state mismatch: expected %v, got %v\", StateDefault,\n\t\t\tarbState)\n\t}\n}\n\n// TestScopeIsolation tests the two distinct ArbitratorLog instances with two\n// distinct scopes, don't over write the state of one another.",
      "length": 1477,
      "tokens": 215,
      "embedding": []
    },
    {
      "slug": "func TestScopeIsolation(t *testing.T) {",
      "content": "func TestScopeIsolation(t *testing.T) {\n\tt.Parallel()\n\n\t// We'll create two distinct test logs. Each log will have a unique\n\t// scope key, and therefore should be isolated from the other on disk.\n\ttestLog1, err := newTestBoltArbLog(\n\t\tt, testChainHash, testChanPoint1,\n\t)\n\trequire.NoError(t, err, \"unable to create test log\")\n\n\ttestLog2, err := newTestBoltArbLog(\n\t\tt, testChainHash, testChanPoint2,\n\t)\n\trequire.NoError(t, err, \"unable to create test log\")\n\n\t// We'll now update the current state of both the logs to a unique\n\t// state.\n\tif err := testLog1.CommitState(StateWaitingFullResolution); err != nil {\n\t\tt.Fatalf(\"unable to write state: %v\", err)\n\t}\n\tif err := testLog2.CommitState(StateContractClosed); err != nil {\n\t\tt.Fatalf(\"unable to write state: %v\", err)\n\t}\n\n\t// Querying each log, the states should be the prior one we set, and be\n\t// disjoint.\n\tlog1State, err := testLog1.CurrentState(nil)\n\trequire.NoError(t, err, \"unable to read arb state\")\n\tlog2State, err := testLog2.CurrentState(nil)\n\trequire.NoError(t, err, \"unable to read arb state\")\n\n\tif log1State == log2State {\n\t\tt.Fatalf(\"log states are the same: %v\", log1State)\n\t}\n\n\tif log1State != StateWaitingFullResolution {\n\t\tt.Fatalf(\"state mismatch: expected %v, got %v\",\n\t\t\tStateWaitingFullResolution, log1State)\n\t}\n\tif log2State != StateContractClosed {\n\t\tt.Fatalf(\"state mismatch: expected %v, got %v\",\n\t\t\tStateContractClosed, log2State)\n\t}\n}\n\n// TestCommitSetStorage tests that we're able to properly read/write active\n// commitment sets.",
      "length": 1428,
      "tokens": 197,
      "embedding": []
    },
    {
      "slug": "func TestCommitSetStorage(t *testing.T) {",
      "content": "func TestCommitSetStorage(t *testing.T) {\n\tt.Parallel()\n\n\ttestLog, err := newTestBoltArbLog(\n\t\tt, testChainHash, testChanPoint1,\n\t)\n\trequire.NoError(t, err, \"unable to create test log\")\n\n\tactiveHTLCs := []channeldb.HTLC{\n\t\t{\n\t\t\tAmt:       1000,\n\t\t\tOnionBlob: make([]byte, 0),\n\t\t\tSignature: make([]byte, 0),\n\t\t},\n\t}\n\n\tconfTypes := []HtlcSetKey{\n\t\tLocalHtlcSet, RemoteHtlcSet, RemotePendingHtlcSet,\n\t}\n\tfor _, pendingRemote := range []bool{true, false} {\n\t\tfor _, confType := range confTypes {\n\t\t\tcommitSet := &CommitSet{\n\t\t\t\tConfCommitKey: &confType,\n\t\t\t\tHtlcSets:      make(map[HtlcSetKey][]channeldb.HTLC),\n\t\t\t}\n\t\t\tcommitSet.HtlcSets[LocalHtlcSet] = activeHTLCs\n\t\t\tcommitSet.HtlcSets[RemoteHtlcSet] = activeHTLCs\n\n\t\t\tif pendingRemote {\n\t\t\t\tcommitSet.HtlcSets[RemotePendingHtlcSet] = activeHTLCs\n\t\t\t}\n\n\t\t\terr := testLog.InsertConfirmedCommitSet(commitSet)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to write commit set: %v\", err)\n\t\t\t}\n\n\t\t\tdiskCommitSet, err := testLog.FetchConfirmedCommitSet(nil)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to read commit set: %v\", err)\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(commitSet, diskCommitSet) {\n\t\t\t\tt.Fatalf(\"commit set mismatch: expected %v, got %v\",\n\t\t\t\t\tspew.Sdump(commitSet), spew.Sdump(diskCommitSet))\n\t\t\t}\n\t\t}\n\t}\n\n}\n",
      "length": 1160,
      "tokens": 123,
      "embedding": []
    },
    {
      "slug": "func init() {",
      "content": "func init() {\n\ttestSignDesc.KeyDesc.PubKey, _ = btcec.ParsePubKey(key1)\n\n\tprand.Seed(time.Now().Unix())\n}\n",
      "length": 88,
      "tokens": 6,
      "embedding": []
    }
  ]
}