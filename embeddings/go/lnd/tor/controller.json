{
  "filepath": "../implementations/go/lnd/tor/controller.go",
  "package": "tor",
  "sections": [
    {
      "slug": "type Controller struct {",
      "content": "type Controller struct {\n\t// started is used atomically in order to prevent multiple calls to\n\t// Start.\n\tstarted int32\n\n\t// stopped is used atomically in order to prevent multiple calls to\n\t// Stop.\n\tstopped int32\n\n\t// conn is the underlying connection between the controller and the\n\t// Tor server. It provides read and write methods to simplify the\n\t// text-based messages within the connection.\n\tconn *textproto.Conn\n\n\t// controlAddr is the host:port the Tor server is listening locally for\n\t// controller connections on.\n\tcontrolAddr string\n\n\t// password, if non-empty, signals that the controller should attempt to\n\t// authenticate itself with the backing Tor daemon through the\n\t// HASHEDPASSWORD authentication method with this value.\n\tpassword string\n\n\t// version is the current version of the Tor server.\n\tversion string\n\n\t// targetIPAddress is the IP address which we tell the Tor server to use\n\t// to connect to the LND node.  This is required when the Tor server\n\t// runs on another host, otherwise the service will not be reachable.\n\ttargetIPAddress string\n\n\t// activeServiceID is the Onion ServiceID created by ADD_ONION.\n\tactiveServiceID string\n}\n\n// NewController returns a new Tor controller that will be able to interact with\n// a Tor server.",
      "length": 1201,
      "tokens": 195,
      "embedding": []
    },
    {
      "slug": "func NewController(controlAddr string, targetIPAddress string,",
      "content": "func NewController(controlAddr string, targetIPAddress string,\n\tpassword string) *Controller {\n\n\treturn &Controller{\n\t\tcontrolAddr:     controlAddr,\n\t\ttargetIPAddress: targetIPAddress,\n\t\tpassword:        password,\n\t}\n}\n\n// Start establishes and authenticates the connection between the controller\n// and a Tor server. Once done, the controller will be able to send commands\n// and expect responses.",
      "length": 324,
      "tokens": 43,
      "embedding": []
    },
    {
      "slug": "func (c *Controller) Start() error {",
      "content": "func (c *Controller) Start() error {\n\tif !atomic.CompareAndSwapInt32(&c.started, 0, 1) {\n\t\treturn nil\n\t}\n\n\tlog.Info(\"Starting tor controller\")\n\n\tconn, err := textproto.Dial(\"tcp\", c.controlAddr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to connect to Tor server: %v\", err)\n\t}\n\n\tc.conn = conn\n\n\treturn c.authenticate()\n}\n\n// Stop closes the connection between the controller and the Tor server.",
      "length": 343,
      "tokens": 49,
      "embedding": []
    },
    {
      "slug": "func (c *Controller) Stop() error {",
      "content": "func (c *Controller) Stop() error {\n\tif !atomic.CompareAndSwapInt32(&c.stopped, 0, 1) {\n\t\treturn nil\n\t}\n\n\tlog.Info(\"Stopping tor controller\")\n\n\t// Remove the onion service.\n\tif err := c.DelOnion(c.activeServiceID); err != nil {\n\t\tlog.Errorf(\"DEL_ONION got error: %v\", err)\n\t\treturn err\n\t}\n\n\t// Reset service ID.\n\tc.activeServiceID = \"\"\n\n\treturn c.conn.Close()\n}\n\n// Reconnect makes a new socket connection between the tor controller and\n// daemon. It will attempt to close the old connection, make a new connection\n// and authenticate, and finally reset the activeServiceID that the controller\n// is aware of.\n//\n// NOTE: Any old onion services will be removed once this function is called.\n// In the case of a Tor daemon restart, previously created onion services will\n// no longer be there. If the function is called without a Tor daemon restart,\n// because the control connection is reset, all the onion services belonging to\n// the old connection will be removed.",
      "length": 904,
      "tokens": 147,
      "embedding": []
    },
    {
      "slug": "func (c *Controller) Reconnect() error {",
      "content": "func (c *Controller) Reconnect() error {\n\t// Require the tor controller to be running when we want to reconnect.\n\t// This means the started flag must be 1 and the stopped flag must be\n\t// 0.\n\tif c.started != 1 {\n\t\treturn errTCNotStarted\n\t}\n\tif c.stopped != 0 {\n\t\treturn errTCStopped\n\t}\n\n\tlog.Info(\"Re-connectting tor controller\")\n\n\t// If we have an old connection, try to close it. We might receive an\n\t// error if the connection has already been closed by Tor daemon(ie,\n\t// daemon restarted), so we ignore the error here.\n\tif c.conn != nil {\n\t\tif err := c.conn.Close(); err != nil {\n\t\t\tlog.Debugf(\"closing old conn got err: %v\", err)\n\t\t}\n\t}\n\n\t// Make a new connection and authenticate.\n\tconn, err := textproto.Dial(\"tcp\", c.controlAddr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to connect to Tor server: %w\", err)\n\t}\n\n\tc.conn = conn\n\n\t// Authenticate the connection between the controller and Tor daemon.\n\tif err := c.authenticate(); err != nil {\n\t\treturn err\n\t}\n\n\t// Reset the activeServiceID. This value would only be set if a\n\t// previous onion service was created. Because the old connection has\n\t// been closed at this point, the old onion service is no longer\n\t// active.\n\tc.activeServiceID = \"\"\n\n\treturn nil\n}\n\n// sendCommand sends a command to the Tor server and returns its response, as a\n// single space-delimited string, and code.",
      "length": 1262,
      "tokens": 223,
      "embedding": []
    },
    {
      "slug": "func (c *Controller) sendCommand(command string) (int, string, error) {",
      "content": "func (c *Controller) sendCommand(command string) (int, string, error) {\n\tid, err := c.conn.Cmd(command)\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\t// Make sure our reader only process the response returned from the\n\t// above command.\n\tc.conn.StartResponse(id)\n\tdefer c.conn.EndResponse(id)\n\n\tcode, reply, err := c.readResponse(success)\n\tif err != nil {\n\t\tlog.Debugf(\"sendCommand:%s got err:%v, reply:%v\",\n\t\t\tcommand, err, reply)\n\t\treturn code, reply, err\n\t}\n\n\treturn code, reply, nil\n}\n\n// readResponse reads the replies from Tor to the controller. The reply has the\n// following format,\n//\n//\tReply = SyncReply / AsyncReply\n//\tSyncReply = *(MidReplyLine / DataReplyLine) EndReplyLine\n//\tAsyncReply = *(MidReplyLine / DataReplyLine) EndReplyLine\n//\n//\tMidReplyLine = StatusCode \"-\" ReplyLine\n//\tDataReplyLine = StatusCode \"+\" ReplyLine CmdData\n//\tEndReplyLine = StatusCode SP ReplyLine\n//\tReplyLine = [ReplyText] CRLF\n//\tReplyText = XXXX\n//\tStatusCode = 3DIGIT\n//\n// Unless specified otherwise, multiple lines in a single reply from Tor daemon\n// to the controller are guaranteed to share the same status code. Read more on\n// this topic:\n//\n//\thttps://gitweb.torproject.org/torspec.git/tree/control-spec.txt#n158\n//\n// NOTE: this code is influenced by https://github.com/Yawning/bulb.",
      "length": 1172,
      "tokens": 174,
      "embedding": []
    },
    {
      "slug": "func (c *Controller) readResponse(expected int) (int, string, error) {",
      "content": "func (c *Controller) readResponse(expected int) (int, string, error) {\n\t// Clean the buffer inside the conn. This is needed when we encountered\n\t// an error while reading the response, the remaining lines need to be\n\t// cleaned before next read.\n\tdefer func() {\n\t\tif _, err := c.conn.R.Discard(c.conn.R.Buffered()); err != nil {\n\t\t\tlog.Errorf(\"clean read buffer failed: %v\", err)\n\t\t}\n\t}()\n\n\treply, code := \"\", 0\n\thasMoreLines := true\n\n\tfor hasMoreLines {\n\t\tline, err := c.conn.Reader.ReadLine()\n\t\tif err != nil {\n\t\t\treturn 0, reply, err\n\t\t}\n\t\tlog.Tracef(\"Reading line: %v\", line)\n\n\t\t// Line being shortter than 4 is not allowed.\n\t\tif len(line) < 4 {\n\t\t\terr = textproto.ProtocolError(\"short line: \" + line)\n\t\t\treturn 0, reply, err\n\t\t}\n\n\t\t// Parse the status code.\n\t\tcode, err = strconv.Atoi(line[0:3])\n\t\tif err != nil {\n\t\t\treturn code, reply, err\n\t\t}\n\n\t\tswitch line[3] {\n\t\t// EndReplyLine = StatusCode SP ReplyLine.\n\t\t// Example: 250 OK\n\t\t// This is the end of the response, so we mark hasMoreLines to\n\t\t// be false to exit the loop.\n\t\tcase ' ':\n\t\t\treply += line[4:]\n\t\t\thasMoreLines = false\n\n\t\t// MidReplyLine = StatusCode \"-\" ReplyLine.\n\t\t// Example: 250-version=...\n\t\t// This is a continued response, so we keep reading the next\n\t\t// line.\n\t\tcase '-':\n\t\t\treply += line[4:]\n\n\t\t// DataReplyLine = StatusCode \"+\" ReplyLine CmdData.\n\t\t// Example: 250+config-text=\n\t\t//\t    line1\n\t\t//\t    line2\n\t\t//          more lines...\n\t\t//          .\n\t\t// This is a data response, meaning the following multiple\n\t\t// lines are the actual data, and a dot(.) in the end means the\n\t\t// end of the data response. The response will be formatted as,\n\t\t// \tkey=line1,line2,...\n\t\t// The above example will then be,\n\t\t// \tconfig-text=line1,line2,...\n\t\tcase '+':\n\t\t\t// Add the key(config-text=)\n\t\t\treply += line[4:]\n\n\t\t\t// Add the values.\n\t\t\tresp, err := c.conn.Reader.ReadDotLines()\n\t\t\tif err != nil {\n\t\t\t\treturn code, reply, err\n\t\t\t}\n\t\t\treply += strings.Join(resp, \",\")\n\n\t\t// Invalid line separator found.\n\t\tdefault:\n\t\t\terr = textproto.ProtocolError(\"invalid line: \" + line)\n\t\t\treturn code, reply, err\n\t\t}\n\n\t\t// We check the code here so that the error message is parsed\n\t\t// from the line.\n\t\tif code != expected {\n\t\t\treturn code, reply, errCodeNotMatch\n\t\t}\n\n\t\t// Separate each line using \"\\n\".\n\t\tif hasMoreLines {\n\t\t\treply += \"\\n\"\n\t\t}\n\t}\n\n\tlog.Tracef(\"Parsed reply: %v\", reply)\n\treturn code, reply, nil\n}\n\n// unescapeValue removes escape codes from the value in the Tor reply. A\n// backslash followed by any character represents that character, so we remove\n// any backslash not preceded by another backslash.",
      "length": 2421,
      "tokens": 393,
      "embedding": []
    },
    {
      "slug": "func unescapeValue(value string) string {",
      "content": "func unescapeValue(value string) string {\n\tnewString := \"\"\n\tjustRemovedBackslash := false\n\n\tfor _, char := range value {\n\t\tif char == '\\\\' && !justRemovedBackslash {\n\t\t\tjustRemovedBackslash = true\n\t\t\tcontinue\n\t\t}\n\n\t\tnewString += string(char)\n\t\tjustRemovedBackslash = false\n\t}\n\n\treturn newString\n}\n\n// parseTorReply parses the reply from the Tor server after receiving a command\n// from a controller. This will parse the relevant reply parameters into a map\n// of keys and values.",
      "length": 419,
      "tokens": 67,
      "embedding": []
    },
    {
      "slug": "func parseTorReply(reply string) map[string]string {",
      "content": "func parseTorReply(reply string) map[string]string {\n\tparams := make(map[string]string)\n\n\t// Find all fields of a reply. The -1 indicates that we want this to\n\t// find all instances of the regexp.\n\tcontents := replyFieldRegexp.FindAllString(reply, -1)\n\tfor _, content := range contents {\n\t\t// Each parameter within the reply should be of the form\n\t\t// KEY=VALUE or KEY=\"VALUE\".\n\t\tkeyValue := strings.SplitN(content, \"=\", 2)\n\t\tkey := keyValue[0]\n\t\tvalue := keyValue[1]\n\n\t\t// Quoted strings need extra processing.\n\t\tif strings.HasPrefix(value, `\"`) {\n\t\t\t// Remove quotes around the value.\n\t\t\tvalue = value[1 : len(value)-1]\n\n\t\t\t// Unescape the value.\n\t\t\tvalue = unescapeValue(value)\n\t\t}\n\n\t\tparams[key] = value\n\t}\n\n\treturn params\n}\n\n// authenticate authenticates the connection between the controller and the\n// Tor server using either of the following supported authentication methods\n// depending on its configuration: SAFECOOKIE, HASHEDPASSWORD, and NULL.",
      "length": 873,
      "tokens": 128,
      "embedding": []
    },
    {
      "slug": "func (c *Controller) authenticate() error {",
      "content": "func (c *Controller) authenticate() error {\n\tprotocolInfo, err := c.protocolInfo()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlog.Debugf(\"received protocol info: %v\", protocolInfo)\n\n\t// With the version retrieved, we'll cache it now in case it needs to be\n\t// used later on.\n\tc.version = protocolInfo.version()\n\n\tswitch {\n\t// If a password was provided, then we should attempt to use the\n\t// HASHEDPASSWORD authentication method.\n\tcase c.password != \"\":\n\t\tif !protocolInfo.supportsAuthMethod(authHashedPassword) {\n\t\t\treturn fmt.Errorf(\"%v authentication method not \"+\n\t\t\t\t\"supported\", authHashedPassword)\n\t\t}\n\n\t\treturn c.authenticateViaHashedPassword()\n\n\t// Otherwise, attempt to authentication via the SAFECOOKIE method as it\n\t// provides the most security.\n\tcase protocolInfo.supportsAuthMethod(authSafeCookie):\n\t\treturn c.authenticateViaSafeCookie(protocolInfo)\n\n\t// Fallback to the NULL method if any others aren't supported.\n\tcase protocolInfo.supportsAuthMethod(authNull):\n\t\treturn c.authenticateViaNull()\n\n\t// No supported authentication methods, fail.\n\tdefault:\n\t\treturn errors.New(\"the Tor server must be configured with \" +\n\t\t\t\"NULL, SAFECOOKIE, or HASHEDPASSWORD authentication\")\n\t}\n}\n\n// authenticateViaNull authenticates the controller with the Tor server using\n// the NULL authentication method.",
      "length": 1218,
      "tokens": 150,
      "embedding": []
    },
    {
      "slug": "func (c *Controller) authenticateViaNull() error {",
      "content": "func (c *Controller) authenticateViaNull() error {\n\t_, _, err := c.sendCommand(\"AUTHENTICATE\")\n\treturn err\n}\n\n// authenticateViaHashedPassword authenticates the controller with the Tor\n// server using the HASHEDPASSWORD authentication method.",
      "length": 186,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *Controller) authenticateViaHashedPassword() error {",
      "content": "func (c *Controller) authenticateViaHashedPassword() error {\n\tcmd := fmt.Sprintf(\"AUTHENTICATE \\\"%s\\\"\", c.password)\n\t_, _, err := c.sendCommand(cmd)\n\treturn err\n}\n\n// authenticateViaSafeCookie authenticates the controller with the Tor server\n// using the SAFECOOKIE authentication method.",
      "length": 221,
      "tokens": 28,
      "embedding": []
    },
    {
      "slug": "func (c *Controller) authenticateViaSafeCookie(info protocolInfo) error {",
      "content": "func (c *Controller) authenticateViaSafeCookie(info protocolInfo) error {\n\t// Before proceeding to authenticate the connection, we'll retrieve\n\t// the authentication cookie of the Tor server. This will be used\n\t// throughout the authentication routine. We do this before as once the\n\t// authentication routine has begun, it is not possible to retrieve it\n\t// mid-way.\n\tcookie, err := c.getAuthCookie(info)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to retrieve authentication cookie: \"+\n\t\t\t\"%v\", err)\n\t}\n\n\t// Authenticating using the SAFECOOKIE authentication method is a two\n\t// step process. We'll kick off the authentication routine by sending\n\t// the AUTHCHALLENGE command followed by a hex-encoded 32-byte nonce.\n\tclientNonce := make([]byte, nonceLen)\n\tif _, err := rand.Read(clientNonce); err != nil {\n\t\treturn fmt.Errorf(\"unable to generate client nonce: %v\", err)\n\t}\n\n\tcmd := fmt.Sprintf(\"AUTHCHALLENGE SAFECOOKIE %x\", clientNonce)\n\t_, reply, err := c.sendCommand(cmd)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// If successful, the reply from the server should be of the following\n\t// format:\n\t//\n\t//\t\"250 AUTHCHALLENGE\"\n\t//\t\tSP \"SERVERHASH=\" ServerHash\n\t//\t\tSP \"SERVERNONCE=\" ServerNonce\n\t//\t\tCRLF\n\t//\n\t// We're interested in retrieving the SERVERHASH and SERVERNONCE\n\t// parameters, so we'll parse our reply to do so.\n\treplyParams := parseTorReply(reply)\n\n\t// Once retrieved, we'll ensure these values are of proper length when\n\t// decoded.\n\tserverHash, ok := replyParams[\"SERVERHASH\"]\n\tif !ok {\n\t\treturn errors.New(\"server hash not found in reply\")\n\t}\n\tdecodedServerHash, err := hex.DecodeString(serverHash)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to decode server hash: %v\", err)\n\t}\n\tif len(decodedServerHash) != sha256.Size {\n\t\treturn errors.New(\"invalid server hash length\")\n\t}\n\n\tserverNonce, ok := replyParams[\"SERVERNONCE\"]\n\tif !ok {\n\t\treturn errors.New(\"server nonce not found in reply\")\n\t}\n\tdecodedServerNonce, err := hex.DecodeString(serverNonce)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to decode server nonce: %v\", err)\n\t}\n\tif len(decodedServerNonce) != nonceLen {\n\t\treturn errors.New(\"invalid server nonce length\")\n\t}\n\n\t// The server hash above was constructed by computing the HMAC-SHA256\n\t// of the message composed of the cookie, client nonce, and server\n\t// nonce. We'll redo this computation ourselves to ensure the integrity\n\t// and authentication of the message.\n\thmacMessage := bytes.Join(\n\t\t[][]byte{cookie, clientNonce, decodedServerNonce}, []byte{},\n\t)\n\tcomputedServerHash := computeHMAC256(serverKey, hmacMessage)\n\tif !hmac.Equal(computedServerHash, decodedServerHash) {\n\t\treturn fmt.Errorf(\"expected server hash %x, got %x\",\n\t\t\tdecodedServerHash, computedServerHash)\n\t}\n\n\t// If the MAC check was successful, we'll proceed with the last step of\n\t// the authentication routine. We'll now send the AUTHENTICATE command\n\t// followed by a hex-encoded client hash constructed by computing the\n\t// HMAC-SHA256 of the same message, but this time using the controller's\n\t// key.\n\tclientHash := computeHMAC256(controllerKey, hmacMessage)\n\tif len(clientHash) != sha256.Size {\n\t\treturn errors.New(\"invalid client hash length\")\n\t}\n\n\tcmd = fmt.Sprintf(\"AUTHENTICATE %x\", clientHash)\n\tif _, _, err := c.sendCommand(cmd); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// getAuthCookie retrieves the authentication cookie in bytes from the Tor\n// server. Cookie authentication must be enabled for this to work.",
      "length": 3263,
      "tokens": 465,
      "embedding": []
    },
    {
      "slug": "func (c *Controller) getAuthCookie(info protocolInfo) ([]byte, error) {",
      "content": "func (c *Controller) getAuthCookie(info protocolInfo) ([]byte, error) {\n\t// Retrieve the cookie file path from the PROTOCOLINFO reply.\n\tcookieFilePath, ok := info[\"COOKIEFILE\"]\n\tif !ok {\n\t\treturn nil, errors.New(\"COOKIEFILE not found in PROTOCOLINFO \" +\n\t\t\t\"reply\")\n\t}\n\tcookieFilePath = strings.Trim(cookieFilePath, \"\\\"\")\n\n\t// Read the cookie from the file and ensure it has the correct length.\n\tcookie, err := ioutil.ReadFile(cookieFilePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(cookie) != cookieLen {\n\t\treturn nil, errors.New(\"invalid authentication cookie length\")\n\t}\n\n\treturn cookie, nil\n}\n\n// computeHMAC256 computes the HMAC-SHA256 of a key and message.",
      "length": 576,
      "tokens": 85,
      "embedding": []
    },
    {
      "slug": "func computeHMAC256(key, message []byte) []byte {",
      "content": "func computeHMAC256(key, message []byte) []byte {\n\tmac := hmac.New(sha256.New, key)\n\tmac.Write(message)\n\treturn mac.Sum(nil)\n}\n\n// supportsV3 is a helper function that parses the current version of the Tor\n// server and determines whether it supports creating v3 onion services through\n// Tor's control port. The version string should be of the format:\n//\n//\tmajor.minor.revision.build",
      "length": 326,
      "tokens": 49,
      "embedding": []
    },
    {
      "slug": "func supportsV3(version string) error {",
      "content": "func supportsV3(version string) error {\n\t// We'll split the minimum Tor version that's supported and the given\n\t// version in order to individually compare each number.\n\tparts := strings.Split(version, \".\")\n\tif len(parts) != 4 {\n\t\treturn errors.New(\"version string is not of the format \" +\n\t\t\t\"major.minor.revision.build\")\n\t}\n\n\t// It's possible that the build number (the last part of the version\n\t// string) includes a pre-release string, e.g. rc, beta, etc., so we'll\n\t// parse that as well.\n\tbuild := strings.Split(parts[len(parts)-1], \"-\")\n\tparts[len(parts)-1] = build[0]\n\n\t// Ensure that each part of the version string corresponds to a number.\n\tfor _, part := range parts {\n\t\tif _, err := strconv.Atoi(part); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Once we've determined we have a proper version string of the format\n\t// major.minor.revision.build, we can just do a string comparison to\n\t// determine if it satisfies the minimum version supported.\n\tif version < MinTorVersion {\n\t\treturn fmt.Errorf(\"version %v below minimum version supported \"+\n\t\t\t\"%v\", version, MinTorVersion)\n\t}\n\n\treturn nil\n}\n\n// protocolInfo is encompasses the details of a response to a PROTOCOLINFO\n// command.",
      "length": 1115,
      "tokens": 178,
      "embedding": []
    },
    {
      "slug": "type protocolInfo map[string]string",
      "content": "type protocolInfo map[string]string\n\n// version returns the Tor version as reported by the server.",
      "length": 61,
      "tokens": 11,
      "embedding": []
    },
    {
      "slug": "func (i protocolInfo) version() string {",
      "content": "func (i protocolInfo) version() string {\n\tversion := i[\"Tor\"]\n\treturn strings.Trim(version, \"\\\"\")\n}\n\n// supportsAuthMethod determines whether the Tor server supports the given\n// authentication method.",
      "length": 155,
      "tokens": 20,
      "embedding": []
    },
    {
      "slug": "func (i protocolInfo) supportsAuthMethod(method string) bool {",
      "content": "func (i protocolInfo) supportsAuthMethod(method string) bool {\n\tmethods, ok := i[\"METHODS\"]\n\tif !ok {\n\t\treturn false\n\t}\n\treturn strings.Contains(methods, method)\n}\n\n// protocolInfo sends a \"PROTOCOLINFO\" command to the Tor server and returns its\n// response.",
      "length": 187,
      "tokens": 29,
      "embedding": []
    },
    {
      "slug": "func (c *Controller) protocolInfo() (protocolInfo, error) {",
      "content": "func (c *Controller) protocolInfo() (protocolInfo, error) {\n\tcmd := fmt.Sprintf(\"PROTOCOLINFO %d\", ProtocolInfoVersion)\n\t_, reply, err := c.sendCommand(cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn protocolInfo(parseTorReply(reply)), nil\n}\n",
      "length": 178,
      "tokens": 23,
      "embedding": []
    }
  ]
}