{
  "filepath": "../implementations/go/lnd/tor/controller_test.go",
  "package": "tor",
  "sections": [
    {
      "slug": "func TestParseTorVersion(t *testing.T) {",
      "content": "func TestParseTorVersion(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tversion string\n\t\tvalid   bool\n\t}{\n\t\t{\n\t\t\tversion: \"0.3.3.6\",\n\t\t\tvalid:   true,\n\t\t},\n\t\t{\n\t\t\tversion: \"0.3.3.7\",\n\t\t\tvalid:   true,\n\t\t},\n\t\t{\n\t\t\tversion: \"0.3.4.6\",\n\t\t\tvalid:   true,\n\t\t},\n\t\t{\n\t\t\tversion: \"0.4.3.6\",\n\t\t\tvalid:   true,\n\t\t},\n\t\t{\n\t\t\tversion: \"0.4.0.5\",\n\t\t\tvalid:   true,\n\t\t},\n\t\t{\n\t\t\tversion: \"1.3.3.6\",\n\t\t\tvalid:   true,\n\t\t},\n\t\t{\n\t\t\tversion: \"0.3.3.6-rc\",\n\t\t\tvalid:   true,\n\t\t},\n\t\t{\n\t\t\tversion: \"0.3.3.7-rc\",\n\t\t\tvalid:   true,\n\t\t},\n\t\t{\n\t\t\tversion: \"0.3.3.5-rc\",\n\t\t\tvalid:   false,\n\t\t},\n\t\t{\n\t\t\tversion: \"0.3.3.5\",\n\t\t\tvalid:   false,\n\t\t},\n\t\t{\n\t\t\tversion: \"0.3.2.6\",\n\t\t\tvalid:   false,\n\t\t},\n\t\t{\n\t\t\tversion: \"0.1.3.6\",\n\t\t\tvalid:   false,\n\t\t},\n\t\t{\n\t\t\tversion: \"0.0.6.3\",\n\t\t\tvalid:   false,\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\terr := supportsV3(test.version)\n\t\tif test.valid != (err == nil) {\n\t\t\tt.Fatalf(\"test %d with version string %v failed: %v\", i,\n\t\t\t\ttest.version, err)\n\t\t}\n\t}\n}\n\n// testProxy emulates a Tor daemon and contains the info used for the tor\n// controller to make connections.",
      "length": 969,
      "tokens": 139,
      "embedding": []
    },
    {
      "slug": "type testProxy struct {",
      "content": "type testProxy struct {\n\t// server is the proxy listener.\n\tserver net.Listener\n\n\t// serverConn is the established connection from the server side.\n\tserverConn net.Conn\n\n\t// serverAddr is the tcp address the proxy is listening on.\n\tserverAddr string\n\n\t// clientConn is the established connection from the client side.\n\tclientConn *textproto.Conn\n}\n\n// cleanUp is used after each test to properly close the ports/connections.",
      "length": 386,
      "tokens": 58,
      "embedding": []
    },
    {
      "slug": "func (tp *testProxy) cleanUp() {",
      "content": "func (tp *testProxy) cleanUp() {\n\t// Don't bother cleaning if there's no a server created.\n\tif tp.server == nil {\n\t\treturn\n\t}\n\n\tif err := tp.clientConn.Close(); err != nil {\n\t\tlog.Errorf(\"closing client conn got err: %v\", err)\n\t}\n\tif err := tp.server.Close(); err != nil {\n\t\tlog.Errorf(\"closing proxy server got err: %v\", err)\n\t}\n}\n\n// createTestProxy creates a proxy server to listen on a random address,\n// creates a server and a client connection, and initializes a testProxy using\n// these params.",
      "length": 453,
      "tokens": 78,
      "embedding": []
    },
    {
      "slug": "func createTestProxy(t *testing.T) *testProxy {",
      "content": "func createTestProxy(t *testing.T) *testProxy {\n\t// Set up the proxy to listen on given port.\n\t//\n\t// NOTE: we use a port 0 here to indicate we want a free port selected\n\t// by the system.\n\tproxy, err := net.Listen(\"tcp\", \":0\")\n\trequire.NoError(t, err, \"failed to create proxy\")\n\n\tt.Logf(\"created proxy server to listen on address: %v\", proxy.Addr())\n\n\t// Accept the connection inside a goroutine.\n\tserverChan := make(chan net.Conn, 1)\n\tgo func(result chan net.Conn) {\n\t\tconn, err := proxy.Accept()\n\t\trequire.NoError(t, err, \"failed to accept\")\n\n\t\tresult <- conn\n\t}(serverChan)\n\n\t// Create the connection using tor controller.\n\tclient, err := textproto.Dial(\"tcp\", proxy.Addr().String())\n\trequire.NoError(t, err, \"failed to create connection\")\n\n\ttc := &testProxy{\n\t\tserver:     proxy,\n\t\tserverConn: <-serverChan,\n\t\tserverAddr: proxy.Addr().String(),\n\t\tclientConn: client,\n\t}\n\n\treturn tc\n}\n\n// TestReadResponse constructs a series of possible responses returned by Tor\n// and asserts the readResponse can handle them correctly.",
      "length": 945,
      "tokens": 134,
      "embedding": []
    },
    {
      "slug": "func TestReadResponse(t *testing.T) {",
      "content": "func TestReadResponse(t *testing.T) {\n\t// Create mock server and client connection.\n\tproxy := createTestProxy(t)\n\tt.Cleanup(proxy.cleanUp)\n\tserver := proxy.serverConn\n\n\t// Create a dummy tor controller.\n\tc := &Controller{conn: proxy.clientConn}\n\n\ttestCase := []struct {\n\t\tname       string\n\t\tserverResp string\n\n\t\t// expectedReply is the reply we expect the readResponse to\n\t\t// return.\n\t\texpectedReply string\n\n\t\t// expectedCode is the code we expect the server to return.\n\t\texpectedCode int\n\n\t\t// returnedCode is the code we expect the readResponse to\n\t\t// return.\n\t\treturnedCode int\n\n\t\t// expectedErr is the error we expect the readResponse to\n\t\t// return.\n\t\texpectedErr error\n\t}{\n\t\t{\n\t\t\t// Test a simple response.\n\t\t\tname:          \"succeed on 250\",\n\t\t\tserverResp:    \"250 OK\\n\",\n\t\t\texpectedReply: \"OK\",\n\t\t\texpectedCode:  250,\n\t\t\treturnedCode:  250,\n\t\t\texpectedErr:   nil,\n\t\t},\n\t\t{\n\t\t\t// Test a mid reply(-) response.\n\t\t\tname: \"succeed on mid reply line\",\n\t\t\tserverResp: \"250-field=value\\n\" +\n\t\t\t\t\"250 OK\\n\",\n\t\t\texpectedReply: \"field=value\\nOK\",\n\t\t\texpectedCode:  250,\n\t\t\treturnedCode:  250,\n\t\t\texpectedErr:   nil,\n\t\t},\n\t\t{\n\t\t\t// Test a data reply(+) response.\n\t\t\tname: \"succeed on data reply line\",\n\t\t\tserverResp: \"250+field=\\n\" +\n\t\t\t\t\"line1\\n\" +\n\t\t\t\t\"line2\\n\" +\n\t\t\t\t\".\\n\" +\n\t\t\t\t\"250 OK\\n\",\n\t\t\texpectedReply: \"field=line1,line2\\nOK\",\n\t\t\texpectedCode:  250,\n\t\t\treturnedCode:  250,\n\t\t\texpectedErr:   nil,\n\t\t},\n\t\t{\n\t\t\t// Test a mixed reply response.\n\t\t\tname: \"succeed on mixed reply line\",\n\t\t\tserverResp: \"250-field=value\\n\" +\n\t\t\t\t\"250+field=\\n\" +\n\t\t\t\t\"line1\\n\" +\n\t\t\t\t\"line2\\n\" +\n\t\t\t\t\".\\n\" +\n\t\t\t\t\"250 OK\\n\",\n\t\t\texpectedReply: \"field=value\\nfield=line1,line2\\nOK\",\n\t\t\texpectedCode:  250,\n\t\t\treturnedCode:  250,\n\t\t\texpectedErr:   nil,\n\t\t},\n\t\t{\n\t\t\t// Test unexpected code.\n\t\t\tname:          \"fail on codes not matched\",\n\t\t\tserverResp:    \"250 ERR\\n\",\n\t\t\texpectedReply: \"ERR\",\n\t\t\texpectedCode:  500,\n\t\t\treturnedCode:  250,\n\t\t\texpectedErr:   errCodeNotMatch,\n\t\t},\n\t\t{\n\t\t\t// Test short response error.\n\t\t\tname:          \"fail on short response\",\n\t\t\tserverResp:    \"123\\n250 OK\\n\",\n\t\t\texpectedReply: \"\",\n\t\t\texpectedCode:  250,\n\t\t\treturnedCode:  0,\n\t\t\texpectedErr: textproto.ProtocolError(\n\t\t\t\t\"short line: 123\"),\n\t\t},\n\t\t{\n\t\t\t// Test short response error.\n\t\t\tname:          \"fail on invalid response\",\n\t\t\tserverResp:    \"250?OK\\n\",\n\t\t\texpectedReply: \"\",\n\t\t\texpectedCode:  250,\n\t\t\treturnedCode:  250,\n\t\t\texpectedErr: textproto.ProtocolError(\n\t\t\t\t\"invalid line: 250?OK\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCase {\n\t\ttc := tc\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Let the server mocks a given response.\n\t\t\t_, err := server.Write([]byte(tc.serverResp))\n\t\t\trequire.NoError(t, err, \"server failed to write\")\n\n\t\t\t// Read the response and checks all expectations\n\t\t\t// satisfied.\n\t\t\tcode, reply, err := c.readResponse(tc.expectedCode)\n\t\t\trequire.Equal(t, tc.expectedErr, err)\n\t\t\trequire.Equal(t, tc.returnedCode, code)\n\t\t\trequire.Equal(t, tc.expectedReply, reply)\n\n\t\t\t// Check that the read buffer is cleaned.\n\t\t\trequire.Zero(t, c.conn.R.Buffered(),\n\t\t\t\t\"read buffer not empty\")\n\t\t})\n\t}\n}\n\n// TestReconnectTCMustBeRunning checks that the tor controller must be running\n// while calling Reconnect.",
      "length": 3020,
      "tokens": 367,
      "embedding": []
    },
    {
      "slug": "func TestReconnectTCMustBeRunning(t *testing.T) {",
      "content": "func TestReconnectTCMustBeRunning(t *testing.T) {\n\t// Create a dummy controller.\n\tc := &Controller{}\n\n\t// Reconnect should fail because the TC is not started.\n\trequire.Equal(t, errTCNotStarted, c.Reconnect())\n\n\t// Set the started flag.\n\tc.started = 1\n\n\t// Set the stopped flag so the TC is stopped.\n\tc.stopped = 1\n\n\t// Reconnect should fail because the TC is stopped.\n\trequire.Equal(t, errTCStopped, c.Reconnect())\n}\n\n// TestReconnectSucceed tests a reconnection will succeed when the tor\n// controller is up and running.",
      "length": 454,
      "tokens": 71,
      "embedding": []
    },
    {
      "slug": "func TestReconnectSucceed(t *testing.T) {",
      "content": "func TestReconnectSucceed(t *testing.T) {\n\t// Create mock server and client connection.\n\tproxy := createTestProxy(t)\n\tt.Cleanup(proxy.cleanUp)\n\n\t// Create a tor controller and mark the controller as started.\n\tc := &Controller{\n\t\tconn:        proxy.clientConn,\n\t\tstarted:     1,\n\t\tcontrolAddr: proxy.serverAddr,\n\t}\n\n\t// Accept the connection inside a goroutine. We will also write some\n\t// data so that the reconnection can succeed. We will mock three writes\n\t// and two reads inside our proxy server,\n\t//   - write protocol info\n\t//   - read auth info\n\t//   - write auth challenge\n\t//   - read auth challenge\n\t//   - write OK\n\tgo func() {\n\t\t// Accept the new connection.\n\t\tserver, err := proxy.server.Accept()\n\t\trequire.NoError(t, err, \"failed to accept\")\n\n\t\t// Write the protocol info.\n\t\tresp := \"250-PROTOCOLINFO 1\\n\" +\n\t\t\t\"250-AUTH METHODS=NULL\\n\" +\n\t\t\t\"250 OK\\n\"\n\t\t_, err = server.Write([]byte(resp))\n\t\trequire.NoErrorf(t, err, \"failed to write protocol info\")\n\n\t\t// Read the auth info from the client.\n\t\tbuf := make([]byte, 65535)\n\t\t_, err = server.Read(buf)\n\t\trequire.NoError(t, err)\n\n\t\t// Write the auth challenge.\n\t\tresp = \"250 AUTHCHALLENGE SERVERHASH=fake\\n\"\n\t\t_, err = server.Write([]byte(resp))\n\t\trequire.NoErrorf(t, err, \"failed to write auth challenge\")\n\n\t\t// Read the auth challenge resp from the client.\n\t\t_, err = server.Read(buf)\n\t\trequire.NoError(t, err)\n\n\t\t// Write OK resp.\n\t\tresp = \"250 OK\\n\"\n\t\t_, err = server.Write([]byte(resp))\n\t\trequire.NoErrorf(t, err, \"failed to write response auth\")\n\t}()\n\n\t// Reconnect should succeed.\n\trequire.NoError(t, c.Reconnect())\n\n\t// Check that the old connection is closed.\n\t_, err := proxy.clientConn.ReadLine()\n\trequire.Contains(t, err.Error(), \"use of closed network connection\")\n\n\t// Check that the connection has been updated.\n\trequire.NotEqual(t, proxy.clientConn, c.conn)\n}\n\n// TestParseTorReply tests that Tor replies are parsed correctly.",
      "length": 1799,
      "tokens": 252,
      "embedding": []
    },
    {
      "slug": "func TestParseTorReply(t *testing.T) {",
      "content": "func TestParseTorReply(t *testing.T) {\n\ttestCase := []struct {\n\t\treply          string\n\t\texpectedParams map[string]string\n\t}{\n\t\t{\n\t\t\t// Test a regular reply.\n\t\t\treply: `VERSION Tor=\"0.4.7.8\"`,\n\t\t\texpectedParams: map[string]string{\n\t\t\t\t\"Tor\": \"0.4.7.8\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t// Test a reply with multiple values, one of them\n\t\t\t// containing spaces.\n\t\t\treply: `AUTH METHODS=COOKIE,SAFECOOKIE,HASHEDPASSWORD` +\n\t\t\t\t` COOKIEFILE=\"/path/with/spaces/Tor Browser/c` +\n\t\t\t\t`ontrol_auth_cookie\"`,\n\t\t\texpectedParams: map[string]string{\n\t\t\t\t\"METHODS\": \"COOKIE,SAFECOOKIE,HASHEDPASSWORD\",\n\t\t\t\t\"COOKIEFILE\": \"/path/with/spaces/Tor Browser/\" +\n\t\t\t\t\t\"control_auth_cookie\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t// Test a multiline reply.\n\t\t\treply:          \"ServiceID=id\\r\\nOK\",\n\t\t\texpectedParams: map[string]string{\"ServiceID\": \"id\"},\n\t\t},\n\t\t{\n\t\t\t// Test a reply with invalid parameters.\n\t\t\treply:          \"AUTH =invalid\",\n\t\t\texpectedParams: map[string]string{},\n\t\t},\n\t\t{\n\t\t\t// Test escaping arbitrary characters.\n\t\t\treply: `PARAM=\"esca\\ped \\\"doub\\lequotes\\\"\"`,\n\t\t\texpectedParams: map[string]string{\n\t\t\t\t`PARAM`: `escaped \"doublequotes\"`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t// Test escaping backslashes. Each single backslash\n\t\t\t// should be removed, each double backslash replaced\n\t\t\t// with a single one. Note that the single backslash\n\t\t\t// before the space escapes the space character, so\n\t\t\t// there's two spaces in a row.\n\t\t\treply: `PARAM=\"escaped \\\\ \\ \\\\\\\\\"`,\n\t\t\texpectedParams: map[string]string{\n\t\t\t\t`PARAM`: `escaped \\  \\\\`,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range testCase {\n\t\tparams := parseTorReply(tc.reply)\n\t\trequire.Equal(t, tc.expectedParams, params)\n\t}\n}\n",
      "length": 1519,
      "tokens": 171,
      "embedding": []
    }
  ]
}