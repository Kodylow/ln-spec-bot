{
  "filepath": "../implementations/go/lnd/watchtower/wtclient/backup_task.go",
  "package": "wtclient",
  "sections": [
    {
      "slug": "type backupTask struct {",
      "content": "type backupTask struct {\n\tid         wtdb.BackupID\n\tbreachInfo *lnwallet.BreachRetribution\n\tchanType   channeldb.ChannelType\n\n\t// state-dependent variables\n\n\ttoLocalInput  input.Input\n\ttoRemoteInput input.Input\n\ttotalAmt      btcutil.Amount\n\tsweepPkScript []byte\n\n\t// session-dependent variables\n\n\tblobType blob.Type\n\toutputs  []*wire.TxOut\n}\n\n// newBackupTask initializes a new backupTask and populates all state-dependent\n// variables.",
      "length": 394,
      "tokens": 37,
      "embedding": []
    },
    {
      "slug": "func newBackupTask(chanID *lnwire.ChannelID,",
      "content": "func newBackupTask(chanID *lnwire.ChannelID,\n\tbreachInfo *lnwallet.BreachRetribution,\n\tsweepPkScript []byte, chanType channeldb.ChannelType) *backupTask {\n\n\t// Parse the non-dust outputs from the breach transaction,\n\t// simultaneously computing the total amount contained in the inputs\n\t// present. We can't compute the exact output values at this time\n\t// since the task has not been assigned to a session, at which point\n\t// parameters such as fee rate, number of outputs, and reward rate will\n\t// be finalized.\n\tvar (\n\t\ttotalAmt      int64\n\t\ttoLocalInput  input.Input\n\t\ttoRemoteInput input.Input\n\t)\n\n\t// Add the sign descriptors and outputs corresponding to the to-local\n\t// and to-remote outputs, respectively, if either input amount is\n\t// non-dust. Note that the naming here seems reversed, but both are\n\t// correct. For example, the to-remote output on the remote party's\n\t// commitment is an output that pays to us. Hence the retribution refers\n\t// to that output as local, though relative to their commitment, it is\n\t// paying to-the-remote party (which is us).\n\tif breachInfo.RemoteOutputSignDesc != nil {\n\t\ttoLocalInput = input.NewBaseInput(\n\t\t\t&breachInfo.RemoteOutpoint,\n\t\t\tinput.CommitmentRevoke,\n\t\t\tbreachInfo.RemoteOutputSignDesc,\n\t\t\t0,\n\t\t)\n\t\ttotalAmt += breachInfo.RemoteOutputSignDesc.Output.Value\n\t}\n\tif breachInfo.LocalOutputSignDesc != nil {\n\t\tvar witnessType input.WitnessType\n\t\tswitch {\n\t\tcase chanType.HasAnchors():\n\t\t\twitnessType = input.CommitmentToRemoteConfirmed\n\t\tcase chanType.IsTweakless():\n\t\t\twitnessType = input.CommitSpendNoDelayTweakless\n\t\tdefault:\n\t\t\twitnessType = input.CommitmentNoDelay\n\t\t}\n\n\t\t// Anchor channels have a CSV-encumbered to-remote output. We'll\n\t\t// construct a CSV input in that case and assign the proper CSV\n\t\t// delay of 1, otherwise we fallback to the a regular P2WKH\n\t\t// to-remote output for tweaked or tweakless channels.\n\t\tif chanType.HasAnchors() {\n\t\t\ttoRemoteInput = input.NewCsvInput(\n\t\t\t\t&breachInfo.LocalOutpoint,\n\t\t\t\twitnessType,\n\t\t\t\tbreachInfo.LocalOutputSignDesc,\n\t\t\t\t0, 1,\n\t\t\t)\n\t\t} else {\n\t\t\ttoRemoteInput = input.NewBaseInput(\n\t\t\t\t&breachInfo.LocalOutpoint,\n\t\t\t\twitnessType,\n\t\t\t\tbreachInfo.LocalOutputSignDesc,\n\t\t\t\t0,\n\t\t\t)\n\t\t}\n\n\t\ttotalAmt += breachInfo.LocalOutputSignDesc.Output.Value\n\t}\n\n\treturn &backupTask{\n\t\tid: wtdb.BackupID{\n\t\t\tChanID:       *chanID,\n\t\t\tCommitHeight: breachInfo.RevokedStateNum,\n\t\t},\n\t\tbreachInfo:    breachInfo,\n\t\tchanType:      chanType,\n\t\ttoLocalInput:  toLocalInput,\n\t\ttoRemoteInput: toRemoteInput,\n\t\ttotalAmt:      btcutil.Amount(totalAmt),\n\t\tsweepPkScript: sweepPkScript,\n\t}\n}\n\n// inputs returns all non-dust inputs that we will attempt to spend from.\n//\n// NOTE: Ordering of the inputs is not critical as we sort the transaction with\n// BIP69.",
      "length": 2618,
      "tokens": 321,
      "embedding": []
    },
    {
      "slug": "func (t *backupTask) inputs() map[wire.OutPoint]input.Input {",
      "content": "func (t *backupTask) inputs() map[wire.OutPoint]input.Input {\n\tinputs := make(map[wire.OutPoint]input.Input)\n\tif t.toLocalInput != nil {\n\t\tinputs[*t.toLocalInput.OutPoint()] = t.toLocalInput\n\t}\n\tif t.toRemoteInput != nil {\n\t\tinputs[*t.toRemoteInput.OutPoint()] = t.toRemoteInput\n\t}\n\treturn inputs\n}\n\n// addrType returns the type of an address after parsing it and matching it to\n// the set of known script templates.",
      "length": 343,
      "tokens": 46,
      "embedding": []
    },
    {
      "slug": "func addrType(pkScript []byte) txscript.ScriptClass {",
      "content": "func addrType(pkScript []byte) txscript.ScriptClass {\n\t// We pass in a set of dummy chain params here as they're only needed\n\t// to make the address struct, which we're ignoring anyway (scripts are\n\t// always the same, it's addresses that change across chains).\n\tscriptClass, _, _, _ := txscript.ExtractPkScriptAddrs(\n\t\tpkScript, &chaincfg.MainNetParams,\n\t)\n\n\treturn scriptClass\n}\n\n// addScriptWeight parses the passed pkScript and adds the computed weight cost\n// were the script to be added to the justice transaction.",
      "length": 455,
      "tokens": 72,
      "embedding": []
    },
    {
      "slug": "func addScriptWeight(weightEstimate *input.TxWeightEstimator,",
      "content": "func addScriptWeight(weightEstimate *input.TxWeightEstimator,\n\tpkScript []byte) error {\n\n\tswitch addrType(pkScript) { //nolint: whitespace\n\n\tcase txscript.WitnessV0PubKeyHashTy:\n\t\tweightEstimate.AddP2WKHOutput()\n\n\tcase txscript.WitnessV0ScriptHashTy:\n\t\tweightEstimate.AddP2WSHOutput()\n\n\tcase txscript.WitnessV1TaprootTy:\n\t\tweightEstimate.AddP2TROutput()\n\n\tdefault:\n\t\treturn fmt.Errorf(\"invalid addr type: %v\", addrType(pkScript))\n\t}\n\n\treturn nil\n}\n\n// bindSession determines if the backupTask is compatible with the passed\n// SessionInfo's policy. If no error is returned, the task has been bound to the\n// session and can be queued to upload to the tower. Otherwise, the bind failed\n// and should be rescheduled with a different session.",
      "length": 653,
      "tokens": 79,
      "embedding": []
    },
    {
      "slug": "func (t *backupTask) bindSession(session *wtdb.ClientSessionBody) error {",
      "content": "func (t *backupTask) bindSession(session *wtdb.ClientSessionBody) error {\n\t// First we'll begin by deriving a weight estimate for the justice\n\t// transaction. The final weight can be different depending on whether\n\t// the watchtower is taking a reward.\n\tvar weightEstimate input.TxWeightEstimator\n\n\t// Next, add the contribution from the inputs that are present on this\n\t// breach transaction.\n\tif t.toLocalInput != nil {\n\t\t// An older ToLocalPenaltyWitnessSize constant used to\n\t\t// underestimate the size by one byte. The diferrence in weight\n\t\t// can cause different output values on the sweep transaction,\n\t\t// so we mimic the original bug and create signatures using the\n\t\t// original weight estimate. For anchor channels we'll go ahead\n\t\t// an use the correct penalty witness when signing our justice\n\t\t// transactions.\n\t\tif t.chanType.HasAnchors() {\n\t\t\tweightEstimate.AddWitnessInput(\n\t\t\t\tinput.ToLocalPenaltyWitnessSize,\n\t\t\t)\n\t\t} else {\n\t\t\tweightEstimate.AddWitnessInput(\n\t\t\t\tinput.ToLocalPenaltyWitnessSize - 1,\n\t\t\t)\n\t\t}\n\t}\n\tif t.toRemoteInput != nil {\n\t\t// Legacy channels (both tweaked and non-tweaked) spend from\n\t\t// P2WKH output. Anchor channels spend a to-remote confirmed\n\t\t// P2WSH  output.\n\t\tif t.chanType.HasAnchors() {\n\t\t\tweightEstimate.AddWitnessInput(input.ToRemoteConfirmedWitnessSize)\n\t\t} else {\n\t\t\tweightEstimate.AddWitnessInput(input.P2WKHWitnessSize)\n\t\t}\n\t}\n\n\t// All justice transactions will either use segwit v0 (p2wkh + p2wsh)\n\t// or segwit v1 (p2tr).\n\tif err := addScriptWeight(&weightEstimate, t.sweepPkScript); err != nil {\n\t\treturn err\n\t}\n\n\t// If the justice transaction has a reward output, add the output's\n\t// contribution to the weight estimate.\n\tif session.Policy.BlobType.Has(blob.FlagReward) {\n\t\terr := addScriptWeight(&weightEstimate, session.RewardPkScript)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif t.chanType.HasAnchors() != session.Policy.IsAnchorChannel() {\n\t\tlog.Criticalf(\"Invalid task (has_anchors=%t) for session \"+\n\t\t\t\"(has_anchors=%t)\", t.chanType.HasAnchors(),\n\t\t\tsession.Policy.IsAnchorChannel())\n\t}\n\n\t// Now, compute the output values depending on whether FlagReward is set\n\t// in the current session's policy.\n\toutputs, err := session.Policy.ComputeJusticeTxOuts(\n\t\tt.totalAmt, int64(weightEstimate.Weight()),\n\t\tt.sweepPkScript, session.RewardPkScript,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tt.blobType = session.Policy.BlobType\n\tt.outputs = outputs\n\n\treturn nil\n}\n\n// craftSessionPayload is the final stage for a backupTask, and generates the\n// encrypted payload and breach hint that should be sent to the tower. This\n// method computes the final justice transaction using the bound\n// session-dependent variables, and signs the resulting transaction. The\n// required pieces from signatures, witness scripts, etc are then packaged into\n// a JusticeKit and encrypted using the breach transaction's key.",
      "length": 2709,
      "tokens": 358,
      "embedding": []
    },
    {
      "slug": "func (t *backupTask) craftSessionPayload(",
      "content": "func (t *backupTask) craftSessionPayload(\n\tsigner input.Signer) (blob.BreachHint, []byte, error) {\n\n\tvar hint blob.BreachHint\n\n\t// First, copy over the sweep pkscript, the pubkeys used to derive the\n\t// to-local script, and the remote CSV delay.\n\tkeyRing := t.breachInfo.KeyRing\n\tjusticeKit := &blob.JusticeKit{\n\t\tBlobType:         t.blobType,\n\t\tSweepAddress:     t.sweepPkScript,\n\t\tRevocationPubKey: toBlobPubKey(keyRing.RevocationKey),\n\t\tLocalDelayPubKey: toBlobPubKey(keyRing.ToLocalKey),\n\t\tCSVDelay:         t.breachInfo.RemoteDelay,\n\t}\n\n\t// If this commitment has an output that pays to us, copy the to-remote\n\t// pubkey into the justice kit. This serves as the indicator to the\n\t// tower that we expect the breaching transaction to have a non-dust\n\t// output to spend from.\n\tif t.toRemoteInput != nil {\n\t\tjusticeKit.CommitToRemotePubKey = toBlobPubKey(\n\t\t\tkeyRing.ToRemoteKey,\n\t\t)\n\t}\n\n\t// Now, begin construction of the justice transaction. We'll start with\n\t// a version 2 transaction.\n\tjusticeTxn := wire.NewMsgTx(2)\n\n\t// Next, add the non-dust inputs that were derived from the breach\n\t// information. This will either be contain both the to-local and\n\t// to-remote outputs, or only be the to-local output.\n\tinputs := t.inputs()\n\tprevOutputFetcher := txscript.NewMultiPrevOutFetcher(nil)\n\tfor prevOutPoint, inp := range inputs {\n\t\tprevOutputFetcher.AddPrevOut(\n\t\t\tprevOutPoint, inp.SignDesc().Output,\n\t\t)\n\t\tjusticeTxn.AddTxIn(&wire.TxIn{\n\t\t\tPreviousOutPoint: prevOutPoint,\n\t\t\tSequence:         inp.BlocksToMaturity(),\n\t\t})\n\t}\n\n\t// Add the sweep output paying directly to the user and possibly a\n\t// reward output, using the outputs computed when the task was bound.\n\tjusticeTxn.TxOut = t.outputs\n\n\t// Sort the justice transaction according to BIP69.\n\ttxsort.InPlaceSort(justiceTxn)\n\n\t// Check that the justice transaction meets basic validity requirements\n\t// before attempting to attach the witnesses.\n\tbtx := btcutil.NewTx(justiceTxn)\n\tif err := blockchain.CheckTransactionSanity(btx); err != nil {\n\t\treturn hint, nil, err\n\t}\n\n\t// Construct a sighash cache to improve signing performance.\n\thashCache := txscript.NewTxSigHashes(justiceTxn, prevOutputFetcher)\n\n\t// Since the transaction inputs could have been reordered as a result of\n\t// the BIP69 sort, create an index mapping each prevout to it's new\n\t// index.\n\tinputIndex := make(map[wire.OutPoint]int)\n\tfor i, txIn := range justiceTxn.TxIn {\n\t\tinputIndex[txIn.PreviousOutPoint] = i\n\t}\n\n\t// Now, iterate through the list of inputs that were initially added to\n\t// the transaction and store the computed witness within the justice\n\t// kit.\n\tfor _, inp := range inputs {\n\t\t// Lookup the input's new post-sort position.\n\t\ti := inputIndex[*inp.OutPoint()]\n\n\t\t// Construct the full witness required to spend this input.\n\t\tinputScript, err := inp.CraftInputScript(\n\t\t\tsigner, justiceTxn, hashCache, prevOutputFetcher, i,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn hint, nil, err\n\t\t}\n\n\t\t// Parse the DER-encoded signature from the first position of\n\t\t// the resulting witness. We trim an extra byte to remove the\n\t\t// sighash flag.\n\t\twitness := inputScript.Witness\n\t\trawSignature := witness[0][:len(witness[0])-1]\n\n\t\t// Re-encode the DER signature into a fixed-size 64 byte\n\t\t// signature.\n\t\tsignature, err := lnwire.NewSigFromRawSignature(rawSignature)\n\t\tif err != nil {\n\t\t\treturn hint, nil, err\n\t\t}\n\n\t\t// Finally, copy the serialized signature into the justice kit,\n\t\t// using the input's witness type to select the appropriate\n\t\t// field.\n\t\tswitch inp.WitnessType() {\n\t\tcase input.CommitmentRevoke:\n\t\t\tcopy(justiceKit.CommitToLocalSig[:], signature[:])\n\n\t\tcase input.CommitSpendNoDelayTweakless:\n\t\t\tfallthrough\n\t\tcase input.CommitmentNoDelay:\n\t\t\tfallthrough\n\t\tcase input.CommitmentToRemoteConfirmed:\n\t\t\tcopy(justiceKit.CommitToRemoteSig[:], signature[:])\n\t\tdefault:\n\t\t\treturn hint, nil, fmt.Errorf(\"invalid witness type: %v\",\n\t\t\t\tinp.WitnessType())\n\t\t}\n\t}\n\n\tbreachTxID := t.breachInfo.BreachTxHash\n\n\t// Compute the breach key as SHA256(txid).\n\thint, key := blob.NewBreachHintAndKeyFromHash(&breachTxID)\n\n\t// Then, we'll encrypt the computed justice kit using the full breach\n\t// transaction id, which will allow the tower to recover the contents\n\t// after the transaction is seen in the chain or mempool.\n\tencBlob, err := justiceKit.Encrypt(key)\n\tif err != nil {\n\t\treturn hint, nil, err\n\t}\n\n\treturn hint, encBlob, nil\n}\n\n// toBlobPubKey serializes the given pubkey into a blob.PubKey that can be set\n// as a field on a blob.JusticeKit.",
      "length": 4309,
      "tokens": 570,
      "embedding": []
    },
    {
      "slug": "func toBlobPubKey(pubKey *btcec.PublicKey) blob.PubKey {",
      "content": "func toBlobPubKey(pubKey *btcec.PublicKey) blob.PubKey {\n\tvar blobPubKey blob.PubKey\n\tcopy(blobPubKey[:], pubKey.SerializeCompressed())\n\treturn blobPubKey\n}\n",
      "length": 96,
      "tokens": 8,
      "embedding": []
    }
  ]
}