{
  "filepath": "../implementations/go/lnd/watchtower/wtclient/backup_task_internal_test.go",
  "package": "wtclient",
  "sections": [
    {
      "slug": "type backupTaskTest struct {",
      "content": "type backupTaskTest struct {\n\tname             string\n\tchanID           lnwire.ChannelID\n\tbreachInfo       *lnwallet.BreachRetribution\n\texpToLocalInput  input.Input\n\texpToRemoteInput input.Input\n\texpTotalAmt      btcutil.Amount\n\texpSweepAmt      int64\n\texpRewardAmt     int64\n\texpRewardScript  []byte\n\tsession          *wtdb.ClientSessionBody\n\tbindErr          error\n\texpSweepScript   []byte\n\tsigner           input.Signer\n\tchanType         channeldb.ChannelType\n}\n\n// genTaskTest creates a instance of a backupTaskTest using the passed\n// parameters. This method handles generating a breach transaction and its\n// corresponding BreachInfo, as well as setting the wtpolicy.Policy of the given\n// session.",
      "length": 656,
      "tokens": 65,
      "embedding": []
    },
    {
      "slug": "func genTaskTest(",
      "content": "func genTaskTest(\n\tname string,\n\tstateNum uint64,\n\ttoLocalAmt int64,\n\ttoRemoteAmt int64,\n\tblobType blob.Type,\n\tsweepFeeRate chainfee.SatPerKWeight,\n\trewardScript []byte,\n\texpSweepAmt int64,\n\texpRewardAmt int64,\n\tbindErr error,\n\tchanType channeldb.ChannelType) backupTaskTest {\n\n\t// Set the anchor flag in the blob type if the session needs to support\n\t// anchor channels.\n\tif chanType.HasAnchors() {\n\t\tblobType |= blob.Type(blob.FlagAnchorChannel)\n\t}\n\n\t// Parse the key pairs for all keys used in the test.\n\trevSK, revPK := btcec.PrivKeyFromBytes(\n\t\trevPrivBytes,\n\t)\n\t_, toLocalPK := btcec.PrivKeyFromBytes(\n\t\ttoLocalPrivBytes,\n\t)\n\ttoRemoteSK, toRemotePK := btcec.PrivKeyFromBytes(\n\t\ttoRemotePrivBytes,\n\t)\n\n\t// Create the signer, and add the revocation and to-remote privkeys.\n\tsigner := wtmock.NewMockSigner()\n\tvar (\n\t\trevKeyLoc      = signer.AddPrivKey(revSK)\n\t\ttoRemoteKeyLoc = signer.AddPrivKey(toRemoteSK)\n\t)\n\n\t// First, we'll initialize a new breach transaction and the\n\t// corresponding breach retribution. The retribution stores a pointer to\n\t// the breach transaction, which we will continue to modify.\n\tbreachTxn := wire.NewMsgTx(2)\n\tbreachInfo := &lnwallet.BreachRetribution{\n\t\tRevokedStateNum: stateNum,\n\t\tBreachTxHash:    breachTxn.TxHash(),\n\t\tKeyRing: &lnwallet.CommitmentKeyRing{\n\t\t\tRevocationKey: revPK,\n\t\t\tToLocalKey:    toLocalPK,\n\t\t\tToRemoteKey:   toRemotePK,\n\t\t},\n\t\tRemoteDelay: csvDelay,\n\t}\n\n\t// Add the sign descriptors and outputs corresponding to the to-local\n\t// and to-remote outputs, respectively, if either input amount is\n\t// non-zero. Note that the naming here seems reversed, but both are\n\t// correct. For example, the to-remote output on the remote party's\n\t// commitment is an output that pays to us. Hence the retribution refers\n\t// to that output as local, though relative to their commitment, it is\n\t// paying to-the-remote party (which is us).\n\tif toLocalAmt > 0 {\n\t\ttoLocalSignDesc := &input.SignDescriptor{\n\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\tKeyLocator: revKeyLoc,\n\t\t\t\tPubKey:     revPK,\n\t\t\t},\n\t\t\tOutput: &wire.TxOut{\n\t\t\t\tValue: toLocalAmt,\n\t\t\t},\n\t\t\tHashType: txscript.SigHashAll,\n\t\t}\n\t\tbreachInfo.RemoteOutputSignDesc = toLocalSignDesc\n\t\tbreachTxn.AddTxOut(toLocalSignDesc.Output)\n\t}\n\tif toRemoteAmt > 0 {\n\t\ttoRemoteSignDesc := &input.SignDescriptor{\n\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\tKeyLocator: toRemoteKeyLoc,\n\t\t\t\tPubKey:     toRemotePK,\n\t\t\t},\n\t\t\tOutput: &wire.TxOut{\n\t\t\t\tValue: toRemoteAmt,\n\t\t\t},\n\t\t\tHashType: txscript.SigHashAll,\n\t\t}\n\t\tbreachInfo.LocalOutputSignDesc = toRemoteSignDesc\n\t\tbreachTxn.AddTxOut(toRemoteSignDesc.Output)\n\t}\n\n\tvar (\n\t\ttoLocalInput  input.Input\n\t\ttoRemoteInput input.Input\n\t)\n\n\t// Now that the breach transaction has all its outputs, we can compute\n\t// its txid and inputs spending from it. We also generate the\n\t// input.Inputs that should be derived by the backup task.\n\ttxid := breachTxn.TxHash()\n\tvar index uint32\n\tif toLocalAmt > 0 {\n\t\tbreachInfo.RemoteOutpoint = wire.OutPoint{\n\t\t\tHash:  txid,\n\t\t\tIndex: index,\n\t\t}\n\t\ttoLocalInput = input.NewBaseInput(\n\t\t\t&breachInfo.RemoteOutpoint,\n\t\t\tinput.CommitmentRevoke,\n\t\t\tbreachInfo.RemoteOutputSignDesc,\n\t\t\t0,\n\t\t)\n\t\tindex++\n\t}\n\tif toRemoteAmt > 0 {\n\t\tbreachInfo.LocalOutpoint = wire.OutPoint{\n\t\t\tHash:  txid,\n\t\t\tIndex: index,\n\t\t}\n\n\t\tvar witnessType input.WitnessType\n\t\tswitch {\n\t\tcase chanType.HasAnchors():\n\t\t\twitnessType = input.CommitmentToRemoteConfirmed\n\t\tcase chanType.IsTweakless():\n\t\t\twitnessType = input.CommitSpendNoDelayTweakless\n\t\tdefault:\n\t\t\twitnessType = input.CommitmentNoDelay\n\t\t}\n\n\t\tif chanType.HasAnchors() {\n\t\t\ttoRemoteInput = input.NewCsvInput(\n\t\t\t\t&breachInfo.LocalOutpoint,\n\t\t\t\twitnessType,\n\t\t\t\tbreachInfo.LocalOutputSignDesc,\n\t\t\t\t0, 1,\n\t\t\t)\n\t\t} else {\n\t\t\ttoRemoteInput = input.NewBaseInput(\n\t\t\t\t&breachInfo.LocalOutpoint,\n\t\t\t\twitnessType,\n\t\t\t\tbreachInfo.LocalOutputSignDesc,\n\t\t\t\t0,\n\t\t\t)\n\t\t}\n\t}\n\n\treturn backupTaskTest{\n\t\tname:             name,\n\t\tbreachInfo:       breachInfo,\n\t\texpToLocalInput:  toLocalInput,\n\t\texpToRemoteInput: toRemoteInput,\n\t\texpTotalAmt:      btcutil.Amount(toLocalAmt + toRemoteAmt),\n\t\texpSweepAmt:      expSweepAmt,\n\t\texpRewardAmt:     expRewardAmt,\n\t\texpRewardScript:  rewardScript,\n\t\tsession: &wtdb.ClientSessionBody{\n\t\t\tPolicy: wtpolicy.Policy{\n\t\t\t\tTxPolicy: wtpolicy.TxPolicy{\n\t\t\t\t\tBlobType:     blobType,\n\t\t\t\t\tSweepFeeRate: sweepFeeRate,\n\t\t\t\t\tRewardRate:   10000,\n\t\t\t\t},\n\t\t\t},\n\t\t\tRewardPkScript: rewardScript,\n\t\t},\n\t\tbindErr:        bindErr,\n\t\texpSweepScript: sweepAddr,\n\t\tsigner:         signer,\n\t\tchanType:       chanType,\n\t}\n}\n\nvar (\n\tblobTypeCommitNoReward = blob.FlagCommitOutputs.Type()\n\n\tblobTypeCommitReward = (blob.FlagCommitOutputs | blob.FlagReward).Type()\n\n\taddr, _ = btcutil.DecodeAddress(\n\t\t\"tb1pw8gzj8clt3v5lxykpgacpju5n8xteskt7gxhmudu6pa70nwfhe6s3unsyk\",\n\t\t&chaincfg.TestNet3Params,\n\t)\n\n\taddrScript, _ = txscript.PayToAddrScript(addr)\n\n\tsweepAddrScript, _ = btcutil.DecodeAddress(\n\t\t\"tb1qs3jyc9sf5kak3x0w99cav9u605aeu3t600xxx0\",\n\t\t&chaincfg.TestNet3Params,\n\t)\n\n\tsweepAddr, _ = txscript.PayToAddrScript(sweepAddrScript)\n)\n\n// TestBackupTaskBind tests the initialization and binding of a backupTask to a\n// ClientSession. After a successful bind, all parameters of the justice\n// transaction should be solidified, so we assert there correctness. In an\n// unsuccessful bind, the session-dependent parameters should be unmodified so\n// that the backup task can be rescheduled if necessary. Finally, we assert that\n// the backup task is able to encrypt a valid justice kit, and that we can\n// decrypt it using the breach txid.",
      "length": 5307,
      "tokens": 578,
      "embedding": []
    },
    {
      "slug": "func TestBackupTask(t *testing.T) {",
      "content": "func TestBackupTask(t *testing.T) {\n\tt.Parallel()\n\n\tchanTypes := []channeldb.ChannelType{\n\t\tchanneldb.SingleFunderBit,\n\t\tchanneldb.SingleFunderTweaklessBit,\n\t\tchanneldb.AnchorOutputsBit,\n\t}\n\n\tvar backupTaskTests []backupTaskTest\n\tfor _, chanType := range chanTypes {\n\t\t// Depending on whether the test is for anchor channels or\n\t\t// legacy (tweaked and non-tweaked) channels, adjust the\n\t\t// expected sweep amount to accommodate. These are different for\n\t\t// several reasons:\n\t\t//   - anchor to-remote outputs require a P2WSH sweep rather\n\t\t//     than a P2WKH sweep.\n\t\t//   - the to-local weight estimate fixes an off-by-one.\n\t\t// In tests related to the dust threshold, the size difference\n\t\t// between the channel types makes it so that the threshold fee\n\t\t// rate is slightly lower (since the transactions are heavier).\n\t\tvar (\n\t\t\texpSweepCommitNoRewardBoth     int64                  = 299241\n\t\t\texpSweepCommitNoRewardLocal    int64                  = 199514\n\t\t\texpSweepCommitNoRewardRemote   int64                  = 99561\n\t\t\texpSweepCommitRewardBoth       int64                  = 296069\n\t\t\texpSweepCommitRewardLocal      int64                  = 197342\n\t\t\texpSweepCommitRewardRemote     int64                  = 98389\n\t\t\tsweepFeeRateNoRewardRemoteDust chainfee.SatPerKWeight = 227500\n\t\t\tsweepFeeRateRewardRemoteDust   chainfee.SatPerKWeight = 175350\n\t\t)\n\t\tif chanType.HasAnchors() {\n\t\t\texpSweepCommitNoRewardBoth = 299236\n\t\t\texpSweepCommitNoRewardLocal = 199513\n\t\t\texpSweepCommitNoRewardRemote = 99557\n\t\t\texpSweepCommitRewardBoth = 296064\n\t\t\texpSweepCommitRewardLocal = 197341\n\t\t\texpSweepCommitRewardRemote = 98385\n\t\t\tsweepFeeRateNoRewardRemoteDust = 225400\n\t\t\tsweepFeeRateRewardRemoteDust = 174100\n\t\t}\n\n\t\tbackupTaskTests = append(backupTaskTests, []backupTaskTest{\n\t\t\tgenTaskTest(\n\t\t\t\t\"commit no-reward, both outputs\",\n\t\t\t\t100,                        // stateNum\n\t\t\t\t200000,                     // toLocalAmt\n\t\t\t\t100000,                     // toRemoteAmt\n\t\t\t\tblobTypeCommitNoReward,     // blobType\n\t\t\t\t1000,                       // sweepFeeRate\n\t\t\t\tnil,                        // rewardScript\n\t\t\t\texpSweepCommitNoRewardBoth, // expSweepAmt\n\t\t\t\t0,                          // expRewardAmt\n\t\t\t\tnil,                        // bindErr\n\t\t\t\tchanType,\n\t\t\t),\n\t\t\tgenTaskTest(\n\t\t\t\t\"commit no-reward, to-local output only\",\n\t\t\t\t1000,                        // stateNum\n\t\t\t\t200000,                      // toLocalAmt\n\t\t\t\t0,                           // toRemoteAmt\n\t\t\t\tblobTypeCommitNoReward,      // blobType\n\t\t\t\t1000,                        // sweepFeeRate\n\t\t\t\tnil,                         // rewardScript\n\t\t\t\texpSweepCommitNoRewardLocal, // expSweepAmt\n\t\t\t\t0,                           // expRewardAmt\n\t\t\t\tnil,                         // bindErr\n\t\t\t\tchanType,\n\t\t\t),\n\t\t\tgenTaskTest(\n\t\t\t\t\"commit no-reward, to-remote output only\",\n\t\t\t\t1,                            // stateNum\n\t\t\t\t0,                            // toLocalAmt\n\t\t\t\t100000,                       // toRemoteAmt\n\t\t\t\tblobTypeCommitNoReward,       // blobType\n\t\t\t\t1000,                         // sweepFeeRate\n\t\t\t\tnil,                          // rewardScript\n\t\t\t\texpSweepCommitNoRewardRemote, // expSweepAmt\n\t\t\t\t0,                            // expRewardAmt\n\t\t\t\tnil,                          // bindErr\n\t\t\t\tchanType,\n\t\t\t),\n\t\t\tgenTaskTest(\n\t\t\t\t\"commit no-reward, to-remote output only, creates dust\",\n\t\t\t\t1,                              // stateNum\n\t\t\t\t0,                              // toLocalAmt\n\t\t\t\t100000,                         // toRemoteAmt\n\t\t\t\tblobTypeCommitNoReward,         // blobType\n\t\t\t\tsweepFeeRateNoRewardRemoteDust, // sweepFeeRate\n\t\t\t\tnil,                            // rewardScript\n\t\t\t\t0,                              // expSweepAmt\n\t\t\t\t0,                              // expRewardAmt\n\t\t\t\twtpolicy.ErrCreatesDust,        // bindErr\n\t\t\t\tchanType,\n\t\t\t),\n\t\t\tgenTaskTest(\n\t\t\t\t\"commit no-reward, no outputs, fee rate exceeds inputs\",\n\t\t\t\t300,                          // stateNum\n\t\t\t\t0,                            // toLocalAmt\n\t\t\t\t0,                            // toRemoteAmt\n\t\t\t\tblobTypeCommitNoReward,       // blobType\n\t\t\t\t1000,                         // sweepFeeRate\n\t\t\t\tnil,                          // rewardScript\n\t\t\t\t0,                            // expSweepAmt\n\t\t\t\t0,                            // expRewardAmt\n\t\t\t\twtpolicy.ErrFeeExceedsInputs, // bindErr\n\t\t\t\tchanType,\n\t\t\t),\n\t\t\tgenTaskTest(\n\t\t\t\t\"commit no-reward, no outputs, fee rate of 0 creates dust\",\n\t\t\t\t300,                     // stateNum\n\t\t\t\t0,                       // toLocalAmt\n\t\t\t\t0,                       // toRemoteAmt\n\t\t\t\tblobTypeCommitNoReward,  // blobType\n\t\t\t\t0,                       // sweepFeeRate\n\t\t\t\tnil,                     // rewardScript\n\t\t\t\t0,                       // expSweepAmt\n\t\t\t\t0,                       // expRewardAmt\n\t\t\t\twtpolicy.ErrCreatesDust, // bindErr\n\t\t\t\tchanType,\n\t\t\t),\n\t\t\tgenTaskTest(\n\t\t\t\t\"commit reward, both outputs\",\n\t\t\t\t100,                      // stateNum\n\t\t\t\t200000,                   // toLocalAmt\n\t\t\t\t100000,                   // toRemoteAmt\n\t\t\t\tblobTypeCommitReward,     // blobType\n\t\t\t\t1000,                     // sweepFeeRate\n\t\t\t\taddrScript,               // rewardScript\n\t\t\t\texpSweepCommitRewardBoth, // expSweepAmt\n\t\t\t\t3000,                     // expRewardAmt\n\t\t\t\tnil,                      // bindErr\n\t\t\t\tchanType,\n\t\t\t),\n\t\t\tgenTaskTest(\n\t\t\t\t\"commit reward, to-local output only\",\n\t\t\t\t1000,                      // stateNum\n\t\t\t\t200000,                    // toLocalAmt\n\t\t\t\t0,                         // toRemoteAmt\n\t\t\t\tblobTypeCommitReward,      // blobType\n\t\t\t\t1000,                      // sweepFeeRate\n\t\t\t\taddrScript,                // rewardScript\n\t\t\t\texpSweepCommitRewardLocal, // expSweepAmt\n\t\t\t\t2000,                      // expRewardAmt\n\t\t\t\tnil,                       // bindErr\n\t\t\t\tchanType,\n\t\t\t),\n\t\t\tgenTaskTest(\n\t\t\t\t\"commit reward, to-remote output only\",\n\t\t\t\t1,                          // stateNum\n\t\t\t\t0,                          // toLocalAmt\n\t\t\t\t100000,                     // toRemoteAmt\n\t\t\t\tblobTypeCommitReward,       // blobType\n\t\t\t\t1000,                       // sweepFeeRate\n\t\t\t\taddrScript,                 // rewardScript\n\t\t\t\texpSweepCommitRewardRemote, // expSweepAmt\n\t\t\t\t1000,                       // expRewardAmt\n\t\t\t\tnil,                        // bindErr\n\t\t\t\tchanType,\n\t\t\t),\n\t\t\tgenTaskTest(\n\t\t\t\t\"commit reward, to-remote output only, creates dust\",\n\t\t\t\t1,                            // stateNum\n\t\t\t\t0,                            // toLocalAmt\n\t\t\t\t108221,                       // toRemoteAmt\n\t\t\t\tblobTypeCommitReward,         // blobType\n\t\t\t\tsweepFeeRateRewardRemoteDust, // sweepFeeRate\n\t\t\t\taddrScript,                   // rewardScript\n\t\t\t\t0,                            // expSweepAmt\n\t\t\t\t0,                            // expRewardAmt\n\t\t\t\twtpolicy.ErrCreatesDust,      // bindErr\n\t\t\t\tchanType,\n\t\t\t),\n\t\t\tgenTaskTest(\n\t\t\t\t\"commit reward, no outputs, fee rate exceeds inputs\",\n\t\t\t\t300,                          // stateNum\n\t\t\t\t0,                            // toLocalAmt\n\t\t\t\t0,                            // toRemoteAmt\n\t\t\t\tblobTypeCommitReward,         // blobType\n\t\t\t\t1000,                         // sweepFeeRate\n\t\t\t\taddrScript,                   // rewardScript\n\t\t\t\t0,                            // expSweepAmt\n\t\t\t\t0,                            // expRewardAmt\n\t\t\t\twtpolicy.ErrFeeExceedsInputs, // bindErr\n\t\t\t\tchanType,\n\t\t\t),\n\t\t\tgenTaskTest(\n\t\t\t\t\"commit reward, no outputs, fee rate of 0 creates dust\",\n\t\t\t\t300,                     // stateNum\n\t\t\t\t0,                       // toLocalAmt\n\t\t\t\t0,                       // toRemoteAmt\n\t\t\t\tblobTypeCommitReward,    // blobType\n\t\t\t\t0,                       // sweepFeeRate\n\t\t\t\taddrScript,              // rewardScript\n\t\t\t\t0,                       // expSweepAmt\n\t\t\t\t0,                       // expRewardAmt\n\t\t\t\twtpolicy.ErrCreatesDust, // bindErr\n\t\t\t\tchanType,\n\t\t\t),\n\t\t}...)\n\t}\n\n\tfor _, test := range backupTaskTests {\n\t\ttest := test\n\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\ttestBackupTask(t, test)\n\t\t})\n\t}\n}\n",
      "length": 7753,
      "tokens": 634,
      "embedding": []
    },
    {
      "slug": "func testBackupTask(t *testing.T, test backupTaskTest) {",
      "content": "func testBackupTask(t *testing.T, test backupTaskTest) {\n\t// Create a new backupTask from the channel id and breach info.\n\ttask := newBackupTask(\n\t\t&test.chanID, test.breachInfo, test.expSweepScript,\n\t\ttest.chanType,\n\t)\n\n\t// Assert that all parameters set during initialization are properly\n\t// populated.\n\trequire.Equal(t, test.chanID, task.id.ChanID)\n\trequire.Equal(t, test.breachInfo.RevokedStateNum, task.id.CommitHeight)\n\trequire.Equal(t, test.expTotalAmt, task.totalAmt)\n\trequire.Equal(t, test.breachInfo, task.breachInfo)\n\trequire.Equal(t, test.expToLocalInput, task.toLocalInput)\n\trequire.Equal(t, test.expToRemoteInput, task.toRemoteInput)\n\n\t// Reconstruct the expected input.Inputs that will be returned by the\n\t// task's inputs() method.\n\texpInputs := make(map[wire.OutPoint]input.Input)\n\tif task.toLocalInput != nil {\n\t\texpInputs[*task.toLocalInput.OutPoint()] = task.toLocalInput\n\t}\n\tif task.toRemoteInput != nil {\n\t\texpInputs[*task.toRemoteInput.OutPoint()] = task.toRemoteInput\n\t}\n\n\t// Assert that the inputs method returns the correct slice of\n\t// input.Inputs.\n\tinputs := task.inputs()\n\trequire.Equal(t, expInputs, inputs)\n\n\t// Now, bind the session to the task. If successful, this locks in the\n\t// session's negotiated parameters and allows the backup task to derive\n\t// the final free variables in the justice transaction.\n\terr := task.bindSession(test.session)\n\trequire.ErrorIs(t, err, test.bindErr)\n\n\t// Exit early if the bind was supposed to fail. But first, we check that\n\t// all fields set during a bind are still unset. This ensure that a\n\t// failed bind doesn't have side-effects if the task is retried with a\n\t// different session.\n\tif test.bindErr != nil {\n\t\trequire.Zerof(t, task.blobType, \"blob type should not be set \"+\n\t\t\t\"on failed bind, found: %s\", task.blobType)\n\n\t\trequire.Nilf(t, task.outputs, \"justice outputs should not be \"+\n\t\t\t\" set on failed bind, found: %v\", task.outputs)\n\n\t\treturn\n\t}\n\n\t// Otherwise, the binding succeeded. Assert that all values set during\n\t// the bind are properly populated.\n\tpolicy := test.session.Policy\n\trequire.Equal(t, policy.BlobType, task.blobType)\n\n\t// Compute the expected outputs on the justice transaction.\n\tvar expOutputs = []*wire.TxOut{\n\t\t{\n\t\t\tPkScript: test.expSweepScript,\n\t\t\tValue:    test.expSweepAmt,\n\t\t},\n\t}\n\n\t// If the policy specifies a reward output, add it to the expected list\n\t// of outputs.\n\tif test.session.Policy.BlobType.Has(blob.FlagReward) {\n\t\texpOutputs = append(expOutputs, &wire.TxOut{\n\t\t\tPkScript: test.expRewardScript,\n\t\t\tValue:    test.expRewardAmt,\n\t\t})\n\t}\n\n\t// Assert that the computed outputs match our expected outputs.\n\trequire.Equal(t, expOutputs, task.outputs)\n\n\t// Now, we'll construct, sign, and encrypt the blob containing the parts\n\t// needed to reconstruct the justice transaction.\n\thint, encBlob, err := task.craftSessionPayload(test.signer)\n\trequire.NoError(t, err, \"unable to craft session payload\")\n\n\t// Verify that the breach hint matches the breach txid's prefix.\n\tbreachTxID := test.breachInfo.BreachTxHash\n\texpHint := blob.NewBreachHintFromHash(&breachTxID)\n\trequire.Equal(t, expHint, hint)\n\n\t// Decrypt the return blob to obtain the JusticeKit containing its\n\t// contents.\n\tkey := blob.NewBreachKeyFromHash(&breachTxID)\n\tjKit, err := blob.Decrypt(key, encBlob, policy.BlobType)\n\trequire.NoError(t, err, \"unable to decrypt blob\")\n\n\tkeyRing := test.breachInfo.KeyRing\n\texpToLocalPK := keyRing.ToLocalKey.SerializeCompressed()\n\texpRevPK := keyRing.RevocationKey.SerializeCompressed()\n\texpToRemotePK := keyRing.ToRemoteKey.SerializeCompressed()\n\n\t// Assert that the blob contained the serialized revocation and to-local\n\t// pubkeys.\n\trequire.Equal(t, expRevPK, jKit.RevocationPubKey[:])\n\trequire.Equal(t, expToLocalPK, jKit.LocalDelayPubKey[:])\n\n\t// Determine if the breach transaction has a to-remote output and/or\n\t// to-local output to spend from. Note the seemingly-reversed\n\t// nomenclature.\n\thasToRemote := test.breachInfo.LocalOutputSignDesc != nil\n\thasToLocal := test.breachInfo.RemoteOutputSignDesc != nil\n\n\t// If the to-remote output is present, assert that the to-remote public\n\t// key was included in the blob. Otherwise assert that a blank public\n\t// key was inserted.\n\tif hasToRemote {\n\t\trequire.Equal(t, expToRemotePK, jKit.CommitToRemotePubKey[:])\n\t} else {\n\t\trequire.Equal(t, zeroPK[:], jKit.CommitToRemotePubKey[:])\n\t}\n\n\t// Assert that the CSV is encoded in the blob.\n\trequire.Equal(t, test.breachInfo.RemoteDelay, jKit.CSVDelay)\n\n\t// Assert that the sweep pkscript is included.\n\trequire.Equal(t, test.expSweepScript, jKit.SweepAddress)\n\n\t// Finally, verify that the signatures are encoded in the justice kit.\n\t// We don't validate the actual signatures produced here, since at the\n\t// moment, it is tested indirectly by other packages and integration\n\t// tests.\n\t// TODO(conner): include signature validation checks\n\n\temptyToLocalSig := bytes.Equal(jKit.CommitToLocalSig[:], zeroSig[:])\n\tif hasToLocal {\n\t\trequire.False(t, emptyToLocalSig, \"to-local signature should \"+\n\t\t\t\"not be empty\")\n\t} else {\n\t\trequire.True(t, emptyToLocalSig, \"to-local signature should \"+\n\t\t\t\"be empty\")\n\t}\n\n\temptyToRemoteSig := bytes.Equal(jKit.CommitToRemoteSig[:], zeroSig[:])\n\tif hasToRemote {\n\t\trequire.False(t, emptyToRemoteSig, \"to-remote signature \"+\n\t\t\t\"should not be empty\")\n\t} else {\n\t\trequire.True(t, emptyToRemoteSig, \"to-remote signature \"+\n\t\t\t\"should be empty\")\n\t}\n}\n",
      "length": 5193,
      "tokens": 622,
      "embedding": []
    }
  ]
}