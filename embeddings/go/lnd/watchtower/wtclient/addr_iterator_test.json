{
  "filepath": "../implementations/go/lnd/watchtower/wtclient/addr_iterator_test.go",
  "package": "wtclient",
  "sections": [
    {
      "slug": "func TestAddrIterator(t *testing.T) {",
      "content": "func TestAddrIterator(t *testing.T) {\n\t// Assert that an iterator can't be initialised with an empty address\n\t// list.\n\t_, err := newAddressIterator()\n\trequire.ErrorContains(t, err, \"must have at least one address\")\n\n\taddr1, err := net.ResolveTCPAddr(\"tcp\", \"1.2.3.4:8000\")\n\trequire.NoError(t, err)\n\n\t// Initialise the iterator with addr1.\n\titer, err := newAddressIterator(addr1)\n\trequire.NoError(t, err)\n\n\t// Attempting to remove addr1 should fail now since it is the only\n\t// address in the iterator.\n\titer.Add(addr1)\n\terr = iter.Remove(addr1)\n\trequire.ErrorIs(t, err, wtdb.ErrLastTowerAddr)\n\n\t// Adding a duplicate of addr1 and then calling Remove should still\n\t// return an error.\n\terr = iter.Remove(addr1)\n\trequire.ErrorIs(t, err, wtdb.ErrLastTowerAddr)\n\n\taddr2, err := net.ResolveTCPAddr(\"tcp\", \"1.2.3.4:8001\")\n\trequire.NoError(t, err)\n\n\t// Add addr2 to the iterator.\n\titer.Add(addr2)\n\n\t// Check that peek returns addr1.\n\ta1 := iter.Peek()\n\trequire.NoError(t, err)\n\trequire.Equal(t, addr1, a1)\n\n\t// Calling peek multiple times should return the same result.\n\ta1 = iter.Peek()\n\trequire.Equal(t, addr1, a1)\n\n\t// Calling Next should now return addr2.\n\ta2, err := iter.Next()\n\trequire.NoError(t, err)\n\trequire.Equal(t, addr2, a2)\n\n\t// Assert that Peek now returns addr2.\n\ta2 = iter.Peek()\n\trequire.NoError(t, err)\n\trequire.Equal(t, addr2, a2)\n\n\t// Calling Next should result in reaching the end of th list.\n\t_, err = iter.Next()\n\trequire.ErrorIs(t, err, ErrAddressesExhausted)\n\n\t// Calling Peek now should reset the queue and return addr1.\n\ta1 = iter.Peek()\n\trequire.Equal(t, addr1, a1)\n\n\t// Wind the list to the end again so that we can test the Reset func.\n\t_, err = iter.Next()\n\trequire.NoError(t, err)\n\n\t_, err = iter.Next()\n\trequire.ErrorIs(t, err, ErrAddressesExhausted)\n\n\titer.Reset()\n\n\t// Now Next should return addr 2.\n\ta2, err = iter.Next()\n\trequire.NoError(t, err)\n\trequire.Equal(t, addr2, a2)\n\n\taddr3, err := net.ResolveTCPAddr(\"tcp\", \"1.2.3.4:8002\")\n\trequire.NoError(t, err)\n\n\t// Add addr3 now to ensure that the iteration works even if we are\n\t// midway through the queue.\n\titer.Add(addr3)\n\n\t// Now Next should return addr 3.\n\ta3, err := iter.Next()\n\trequire.NoError(t, err)\n\trequire.Equal(t, addr3, a3)\n\n\t// Quickly test that GetAll correctly returns a copy of all the\n\t// addresses in the iterator.\n\taddrList := iter.GetAll()\n\trequire.ElementsMatch(t, addrList, []net.Addr{addr1, addr2, addr3})\n\n\t// Let's now remove addr3.\n\terr = iter.Remove(addr3)\n\trequire.NoError(t, err)\n\n\t// Since addr3 is gone, Peek should return addr1.\n\ta1 = iter.Peek()\n\trequire.Equal(t, addr1, a1)\n\n\t// Lastly, we will test the \"locking\" of addresses.\n\n\t// First we test the locking of an address via the PeekAndLock function.\n\ta1 = iter.PeekAndLock()\n\trequire.Equal(t, addr1, a1)\n\trequire.True(t, iter.HasLocked())\n\n\t// Assert that we can't remove addr1 if there is a lock on it.\n\terr = iter.Remove(addr1)\n\trequire.ErrorIs(t, err, ErrAddrInUse)\n\n\t// Now release the lock on addr1.\n\titer.ReleaseLock(addr1)\n\trequire.False(t, iter.HasLocked())\n\n\t// Since the lock has been released, we should now be able to remove\n\t// addr1.\n\terr = iter.Remove(addr1)\n\trequire.NoError(t, err)\n\n\t// Now we test the locking of an address via the NextAndLock function.\n\t// To do this, we first re-add addr3.\n\titer.Add(addr3)\n\n\ta2, err = iter.NextAndLock()\n\trequire.NoError(t, err)\n\trequire.Equal(t, addr2, a2)\n\trequire.True(t, iter.HasLocked())\n\n\t// Assert that we can't remove addr2 if there is a lock on it.\n\terr = iter.Remove(addr2)\n\trequire.ErrorIs(t, err, ErrAddrInUse)\n\n\t// Now release the lock on addr2.\n\titer.ReleaseLock(addr2)\n\trequire.False(t, iter.HasLocked())\n\n\t// Since the lock has been released, we should now be able to remove\n\t// addr1.\n\terr = iter.Remove(addr2)\n\trequire.NoError(t, err)\n\n\t// Only addr3 should still be left in the iterator.\n\taddrList = iter.GetAll()\n\trequire.Len(t, addrList, 1)\n\trequire.Contains(t, addrList, addr3)\n\n\t// Ensure that HasLocked acts correctly in the case where more than one\n\t// address is being locked and unlock as well as the case where the same\n\t// address is locked more than once.\n\n\trequire.False(t, iter.HasLocked())\n\n\ta3 = iter.PeekAndLock()\n\trequire.Equal(t, addr3, a3)\n\trequire.True(t, iter.HasLocked())\n\n\ta3 = iter.PeekAndLock()\n\trequire.Equal(t, addr3, a3)\n\trequire.True(t, iter.HasLocked())\n\n\titer.Add(addr2)\n\ta2, err = iter.NextAndLock()\n\trequire.NoError(t, err)\n\trequire.Equal(t, addr2, a2)\n\trequire.True(t, iter.HasLocked())\n\n\t// Now release addr2 and asset that HasLock is still true.\n\titer.ReleaseLock(addr2)\n\trequire.True(t, iter.HasLocked())\n\n\t// Releasing one of the locks on addr3 now should still result in\n\t// HasLocked returning true.\n\titer.ReleaseLock(addr3)\n\trequire.True(t, iter.HasLocked())\n\n\t// Releasing it again should now result in should still result in\n\t// HasLocked returning false.\n\titer.ReleaseLock(addr3)\n\trequire.False(t, iter.HasLocked())\n}\n",
      "length": 4693,
      "tokens": 645,
      "embedding": []
    }
  ]
}