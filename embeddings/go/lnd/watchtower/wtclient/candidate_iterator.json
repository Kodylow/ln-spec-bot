{
  "filepath": "../implementations/go/lnd/watchtower/wtclient/candidate_iterator.go",
  "package": "wtclient",
  "sections": [
    {
      "slug": "type TowerCandidateIterator interface {",
      "content": "type TowerCandidateIterator interface {\n\t// AddCandidate adds a new candidate tower to the iterator. If the\n\t// candidate already exists, then any new addresses are added to it.\n\tAddCandidate(*Tower)\n\n\t// RemoveCandidate removes an existing candidate tower from the\n\t// iterator. An optional address can be provided to indicate a stale\n\t// tower address to remove it. If it isn't provided, then the tower is\n\t// completely removed from the iterator.\n\tRemoveCandidate(wtdb.TowerID, net.Addr) error\n\n\t// IsActive determines whether a given tower is exists within the\n\t// iterator.\n\tIsActive(wtdb.TowerID) bool\n\n\t// Reset clears any internal iterator state, making previously taken\n\t// candidates available as long as they remain in the set.\n\tReset() error\n\n\t// Next returns the next candidate tower. The iterator is not required\n\t// to return results in any particular order.  If no more candidates are\n\t// available, ErrTowerCandidatesExhausted is returned.\n\tNext() (*Tower, error)\n}\n\n// towerListIterator is a linked-list backed TowerCandidateIterator.",
      "length": 988,
      "tokens": 148,
      "embedding": []
    },
    {
      "slug": "type towerListIterator struct {",
      "content": "type towerListIterator struct {\n\tmu            sync.Mutex\n\tqueue         *list.List\n\tnextCandidate *list.Element\n\tcandidates    map[wtdb.TowerID]*Tower\n}\n\n// Compile-time constraint to ensure *towerListIterator implements the\n// TowerCandidateIterator interface.\nvar _ TowerCandidateIterator = (*towerListIterator)(nil)\n\n// newTowerListIterator initializes a new towerListIterator from a variadic list\n// of lnwire.NetAddresses.",
      "length": 385,
      "tokens": 38,
      "embedding": []
    },
    {
      "slug": "func newTowerListIterator(candidates ...*Tower) *towerListIterator {",
      "content": "func newTowerListIterator(candidates ...*Tower) *towerListIterator {\n\titer := &towerListIterator{\n\t\tqueue:      list.New(),\n\t\tcandidates: make(map[wtdb.TowerID]*Tower),\n\t}\n\n\tfor _, candidate := range candidates {\n\t\titer.queue.PushBack(candidate.ID)\n\t\titer.candidates[candidate.ID] = candidate\n\t}\n\titer.Reset()\n\n\treturn iter\n}\n\n// Reset clears the iterators state, and makes the address at the front of the\n// list the next item to be returned..",
      "length": 360,
      "tokens": 47,
      "embedding": []
    },
    {
      "slug": "func (t *towerListIterator) Reset() error {",
      "content": "func (t *towerListIterator) Reset() error {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\n\t// Reset the next candidate to the front of the linked-list.\n\tt.nextCandidate = t.queue.Front()\n\n\treturn nil\n}\n\n// Next returns the next candidate tower. This iterator will always return\n// candidates in the order given when the iterator was instantiated.  If no more\n// candidates are available, ErrTowerCandidatesExhausted is returned.",
      "length": 362,
      "tokens": 53,
      "embedding": []
    },
    {
      "slug": "func (t *towerListIterator) Next() (*Tower, error) {",
      "content": "func (t *towerListIterator) Next() (*Tower, error) {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\n\tfor t.nextCandidate != nil {\n\t\t// Propose the tower at the front of the list.\n\t\ttowerID := t.nextCandidate.Value.(wtdb.TowerID)\n\n\t\t// Check whether this tower is still considered a candidate. If\n\t\t// it's not, we'll proceed to the next.\n\t\ttower, ok := t.candidates[towerID]\n\t\tif !ok {\n\t\t\tnextCandidate := t.nextCandidate.Next()\n\t\t\tt.queue.Remove(t.nextCandidate)\n\t\t\tt.nextCandidate = nextCandidate\n\t\t\tcontinue\n\t\t}\n\n\t\t// Set the next candidate to the subsequent element.\n\t\tt.nextCandidate = t.nextCandidate.Next()\n\t\treturn tower, nil\n\t}\n\n\treturn nil, ErrTowerCandidatesExhausted\n}\n\n// AddCandidate adds a new candidate tower to the iterator. If the candidate\n// already exists, then any new addresses are added to it.",
      "length": 726,
      "tokens": 100,
      "embedding": []
    },
    {
      "slug": "func (t *towerListIterator) AddCandidate(candidate *Tower) {",
      "content": "func (t *towerListIterator) AddCandidate(candidate *Tower) {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\n\tif tower, ok := t.candidates[candidate.ID]; !ok {\n\t\tt.queue.PushBack(candidate.ID)\n\t\tt.candidates[candidate.ID] = candidate\n\n\t\t// If we've reached the end of our queue, then this candidate\n\t\t// will become the next.\n\t\tif t.nextCandidate == nil {\n\t\t\tt.nextCandidate = t.queue.Back()\n\t\t}\n\t} else {\n\t\tcandidate.Addresses.Reset()\n\t\tfirstAddr := candidate.Addresses.Peek()\n\t\ttower.Addresses.Add(firstAddr)\n\t\tfor {\n\t\t\tnext, err := candidate.Addresses.Next()\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\ttower.Addresses.Add(next)\n\t\t}\n\t}\n}\n\n// RemoveCandidate removes an existing candidate tower from the iterator. An\n// optional address can be provided to indicate a stale tower address to remove\n// it. If it isn't provided, then the tower is completely removed from the\n// iterator.",
      "length": 776,
      "tokens": 106,
      "embedding": []
    },
    {
      "slug": "func (t *towerListIterator) RemoveCandidate(candidate wtdb.TowerID,",
      "content": "func (t *towerListIterator) RemoveCandidate(candidate wtdb.TowerID,\n\taddr net.Addr) error {\n\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\n\ttower, ok := t.candidates[candidate]\n\tif !ok {\n\t\treturn nil\n\t}\n\tif addr != nil {\n\t\terr := tower.Addresses.Remove(addr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif tower.Addresses.HasLocked() {\n\t\t\treturn ErrAddrInUse\n\t\t}\n\n\t\tdelete(t.candidates, candidate)\n\t}\n\n\treturn nil\n}\n\n// IsActive determines whether a given tower is exists within the iterator.",
      "length": 392,
      "tokens": 60,
      "embedding": []
    },
    {
      "slug": "func (t *towerListIterator) IsActive(tower wtdb.TowerID) bool {",
      "content": "func (t *towerListIterator) IsActive(tower wtdb.TowerID) bool {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\n\t_, ok := t.candidates[tower]\n\treturn ok\n}\n\n// TODO(conner): implement graph-backed candidate iterator for public towers.\n",
      "length": 149,
      "tokens": 19,
      "embedding": []
    }
  ]
}