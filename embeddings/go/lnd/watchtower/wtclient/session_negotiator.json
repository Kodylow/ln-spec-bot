{
  "filepath": "../implementations/go/lnd/watchtower/wtclient/session_negotiator.go",
  "package": "wtclient",
  "sections": [
    {
      "slug": "type SessionNegotiator interface {",
      "content": "type SessionNegotiator interface {\n\t// RequestSession signals to the session negotiator that the client\n\t// needs another session. Once the session is negotiated, it should be\n\t// returned via NewSessions.\n\tRequestSession()\n\n\t// NewSessions is a read-only channel where newly negotiated sessions\n\t// will be delivered.\n\tNewSessions() <-chan *ClientSession\n\n\t// Start safely initializes the session negotiator.\n\tStart() error\n\n\t// Stop safely shuts down the session negotiator.\n\tStop() error\n}\n\n// NegotiatorConfig provides access to the resources required by a\n// SessionNegotiator to faithfully carry out its duties. All nil-able field must\n// be initialized.",
      "length": 607,
      "tokens": 89,
      "embedding": []
    },
    {
      "slug": "type NegotiatorConfig struct {",
      "content": "type NegotiatorConfig struct {\n\t// DB provides access to a persistent storage medium used by the tower\n\t// to properly allocate session ephemeral keys and record successfully\n\t// negotiated sessions.\n\tDB DB\n\n\t// SecretKeyRing allows the client to derive new session private keys\n\t// when attempting to negotiate session with a tower.\n\tSecretKeyRing ECDHKeyRing\n\n\t// Candidates is an abstract set of tower candidates that the negotiator\n\t// will traverse serially when attempting to negotiate a new session.\n\tCandidates TowerCandidateIterator\n\n\t// Policy defines the session policy that will be proposed to towers\n\t// when attempting to negotiate a new session. This policy will be used\n\t// across all negotiation proposals for the lifetime of the negotiator.\n\tPolicy wtpolicy.Policy\n\n\t// Dial initiates an outbound brontide connection to the given address\n\t// using a specified private key. The peer is returned in the event of a\n\t// successful connection.\n\tDial func(keychain.SingleKeyECDH, *lnwire.NetAddress) (wtserver.Peer,\n\t\terror)\n\n\t// SendMessage writes a wtwire message to remote peer.\n\tSendMessage func(wtserver.Peer, wtwire.Message) error\n\n\t// ReadMessage reads a message from a remote peer and returns the\n\t// decoded wtwire message.\n\tReadMessage func(wtserver.Peer) (wtwire.Message, error)\n\n\t// ChainHash the genesis hash identifying the chain for any negotiated\n\t// sessions. Any state updates sent to that session should also\n\t// originate from this chain.\n\tChainHash chainhash.Hash\n\n\t// MinBackoff defines the initial backoff applied by the session\n\t// negotiator after all tower candidates have been exhausted and\n\t// reattempting negotiation with the same set of candidates. Subsequent\n\t// backoff durations will grow exponentially.\n\tMinBackoff time.Duration\n\n\t// MaxBackoff defines the maximum backoff applied by the session\n\t// negotiator after all tower candidates have been exhausted and\n\t// reattempting negotiation with the same set of candidates. If the\n\t// exponential backoff produces a timeout greater than this value, the\n\t// backoff duration will be clamped to MaxBackoff.\n\tMaxBackoff time.Duration\n\n\t// Log specifies the desired log output, which should be prefixed by the\n\t// client type, e.g. anchor or legacy.\n\tLog btclog.Logger\n}\n\n// sessionNegotiator is concrete SessionNegotiator that is able to request new\n// sessions from a set of candidate towers asynchronously and return successful\n// sessions to the primary client.",
      "length": 2371,
      "tokens": 351,
      "embedding": []
    },
    {
      "slug": "type sessionNegotiator struct {",
      "content": "type sessionNegotiator struct {\n\tstarted sync.Once\n\tstopped sync.Once\n\n\tlocalInit *wtwire.Init\n\n\tcfg *NegotiatorConfig\n\tlog btclog.Logger\n\n\tdispatcher             chan struct{}\n\tnewSessions            chan *ClientSession\n\tsuccessfulNegotiations chan *ClientSession\n\n\twg   sync.WaitGroup\n\tquit chan struct{}\n}\n\n// Compile-time constraint to ensure a *sessionNegotiator implements the\n// SessionNegotiator interface.\nvar _ SessionNegotiator = (*sessionNegotiator)(nil)\n\n// newSessionNegotiator initializes a fresh sessionNegotiator instance.",
      "length": 487,
      "tokens": 49,
      "embedding": []
    },
    {
      "slug": "func newSessionNegotiator(cfg *NegotiatorConfig) *sessionNegotiator {",
      "content": "func newSessionNegotiator(cfg *NegotiatorConfig) *sessionNegotiator {\n\t// Generate the set of features the negotiator will present to the tower\n\t// upon connection. For anchor channels, we'll conditionally signal that\n\t// we require support for anchor channels depending on the requested\n\t// policy.\n\tfeatures := []lnwire.FeatureBit{\n\t\twtwire.AltruistSessionsRequired,\n\t}\n\tif cfg.Policy.IsAnchorChannel() {\n\t\tfeatures = append(features, wtwire.AnchorCommitRequired)\n\t}\n\n\tlocalInit := wtwire.NewInitMessage(\n\t\tlnwire.NewRawFeatureVector(features...),\n\t\tcfg.ChainHash,\n\t)\n\n\treturn &sessionNegotiator{\n\t\tcfg:                    cfg,\n\t\tlog:                    cfg.Log,\n\t\tlocalInit:              localInit,\n\t\tdispatcher:             make(chan struct{}, 1),\n\t\tnewSessions:            make(chan *ClientSession),\n\t\tsuccessfulNegotiations: make(chan *ClientSession),\n\t\tquit:                   make(chan struct{}),\n\t}\n}\n\n// Start safely starts up the sessionNegotiator.",
      "length": 862,
      "tokens": 85,
      "embedding": []
    },
    {
      "slug": "func (n *sessionNegotiator) Start() error {",
      "content": "func (n *sessionNegotiator) Start() error {\n\tn.started.Do(func() {\n\t\tn.log.Debugf(\"Starting session negotiator\")\n\n\t\tn.wg.Add(1)\n\t\tgo n.negotiationDispatcher()\n\t})\n\n\treturn nil\n}\n\n// Stop safely shutsdown the sessionNegotiator.",
      "length": 172,
      "tokens": 18,
      "embedding": []
    },
    {
      "slug": "func (n *sessionNegotiator) Stop() error {",
      "content": "func (n *sessionNegotiator) Stop() error {\n\tn.stopped.Do(func() {\n\t\tn.log.Debugf(\"Stopping session negotiator\")\n\n\t\tclose(n.quit)\n\t\tn.wg.Wait()\n\t})\n\n\treturn nil\n}\n\n// NewSessions returns a receive-only channel from which newly negotiated\n// sessions will be returned.",
      "length": 212,
      "tokens": 26,
      "embedding": []
    },
    {
      "slug": "func (n *sessionNegotiator) NewSessions() <-chan *ClientSession {",
      "content": "func (n *sessionNegotiator) NewSessions() <-chan *ClientSession {\n\treturn n.newSessions\n}\n\n// RequestSession sends a request to the sessionNegotiator to begin requesting a\n// new session. If one is already in the process of being negotiated, the\n// request will be ignored.",
      "length": 202,
      "tokens": 34,
      "embedding": []
    },
    {
      "slug": "func (n *sessionNegotiator) RequestSession() {",
      "content": "func (n *sessionNegotiator) RequestSession() {\n\tselect {\n\tcase n.dispatcher <- struct{}{}:\n\tdefault:\n\t}\n}\n\n// negotiationDispatcher acts as the primary event loop for the\n// sessionNegotiator, coordinating requests for more sessions and dispatching\n// attempts to negotiate them from a list of candidates.",
      "length": 250,
      "tokens": 38,
      "embedding": []
    },
    {
      "slug": "func (n *sessionNegotiator) negotiationDispatcher() {",
      "content": "func (n *sessionNegotiator) negotiationDispatcher() {\n\tdefer n.wg.Done()\n\n\tvar pendingNegotiations int\n\tfor {\n\t\tselect {\n\t\tcase <-n.dispatcher:\n\t\t\tpendingNegotiations++\n\n\t\t\tif pendingNegotiations > 1 {\n\t\t\t\tn.log.Debugf(\"Already negotiating session, \" +\n\t\t\t\t\t\"waiting for existing negotiation to \" +\n\t\t\t\t\t\"complete\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// TODO(conner): consider reusing good towers\n\n\t\t\tn.log.Debugf(\"Dispatching session negotiation\")\n\n\t\t\tn.wg.Add(1)\n\t\t\tgo n.negotiate()\n\n\t\tcase session := <-n.successfulNegotiations:\n\t\t\tselect {\n\t\t\tcase n.newSessions <- session:\n\t\t\t\tpendingNegotiations--\n\t\t\tcase <-n.quit:\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif pendingNegotiations > 0 {\n\t\t\t\tn.log.Debugf(\"Dispatching pending session \" +\n\t\t\t\t\t\"negotiation\")\n\n\t\t\t\tn.wg.Add(1)\n\t\t\t\tgo n.negotiate()\n\t\t\t}\n\n\t\tcase <-n.quit:\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// negotiate handles the process of iterating through potential tower candidates\n// and attempting to negotiate a new session until a successful negotiation\n// occurs. If the candidate iterator becomes exhausted because none were\n// successful, this method will back off exponentially up to the configured max\n// backoff. This method will continue trying until a negotiation is successful\n// before returning the negotiated session to the dispatcher via the succeed\n// channel.\n//\n// NOTE: This method MUST be run as a goroutine.",
      "length": 1232,
      "tokens": 164,
      "embedding": []
    },
    {
      "slug": "func (n *sessionNegotiator) negotiate() {",
      "content": "func (n *sessionNegotiator) negotiate() {\n\tdefer n.wg.Done()\n\n\t// On the first pass, initialize the backoff to our configured min\n\t// backoff.\n\tvar backoff time.Duration\n\n\t// Create a closure to update the backoff upon failure such that it\n\t// stays within our min and max backoff parameters.\n\tupdateBackoff := func() {\n\t\tif backoff == 0 {\n\t\t\tbackoff = n.cfg.MinBackoff\n\t\t} else {\n\t\t\tbackoff *= 2\n\t\t\tif backoff > n.cfg.MaxBackoff {\n\t\t\t\tbackoff = n.cfg.MaxBackoff\n\t\t\t}\n\t\t}\n\t}\n\nretryWithBackoff:\n\t// If we are retrying, wait out the delay before continuing.\n\tif backoff > 0 {\n\t\tselect {\n\t\tcase <-time.After(backoff):\n\t\tcase <-n.quit:\n\t\t\treturn\n\t\t}\n\t}\n\n\tfor {\n\t\tselect {\n\t\tcase <-n.quit:\n\t\t\treturn\n\t\tdefault:\n\t\t}\n\n\t\t// Pull the next candidate from our list of addresses.\n\t\ttower, err := n.cfg.Candidates.Next()\n\t\tif err != nil {\n\t\t\t// We've run out of addresses, update our backoff.\n\t\t\tupdateBackoff()\n\n\t\t\tn.log.Debugf(\"Unable to get new tower candidate, \"+\n\t\t\t\t\"retrying after %v -- reason: %v\", backoff, err)\n\n\t\t\t// Only reset the iterator once we've exhausted all\n\t\t\t// candidates. Doing so allows us to load balance\n\t\t\t// sessions better amongst all of the tower candidates.\n\t\t\tif err == ErrTowerCandidatesExhausted {\n\t\t\t\tn.cfg.Candidates.Reset()\n\t\t\t}\n\n\t\t\tgoto retryWithBackoff\n\t\t}\n\n\t\ttowerPub := tower.IdentityKey.SerializeCompressed()\n\t\tn.log.Debugf(\"Attempting session negotiation with tower=%x\",\n\t\t\ttowerPub)\n\n\t\t// Before proceeding, we will reserve a session key index to use\n\t\t// with this specific tower. If one is already reserved, the\n\t\t// existing index will be returned.\n\t\tkeyIndex, err := n.cfg.DB.NextSessionKeyIndex(\n\t\t\ttower.ID, n.cfg.Policy.BlobType,\n\t\t)\n\t\tif err != nil {\n\t\t\tn.log.Debugf(\"Unable to reserve session key index \"+\n\t\t\t\t\"for tower=%x: %v\", towerPub, err)\n\t\t\tcontinue\n\t\t}\n\n\t\t// We'll now attempt the CreateSession dance with the tower to\n\t\t// get a new session, trying all addresses if necessary.\n\t\terr = n.createSession(tower, keyIndex)\n\t\tif err != nil {\n\t\t\t// An unexpected error occurred, updpate our backoff.\n\t\t\tupdateBackoff()\n\n\t\t\tn.log.Debugf(\"Session negotiation with tower=%x \"+\n\t\t\t\t\"failed, trying again -- reason: %v\",\n\t\t\t\ttower.IdentityKey.SerializeCompressed(), err)\n\n\t\t\tgoto retryWithBackoff\n\t\t}\n\n\t\t// Success.\n\t\treturn\n\t}\n}\n\n// createSession takes a tower and attempts to negotiate a session using any of\n// its stored addresses. This method returns after the first successful\n// negotiation, or after all addresses have failed with ErrFailedNegotiation.",
      "length": 2363,
      "tokens": 345,
      "embedding": []
    },
    {
      "slug": "func (n *sessionNegotiator) createSession(tower *Tower, keyIndex uint32) error {",
      "content": "func (n *sessionNegotiator) createSession(tower *Tower, keyIndex uint32) error {\n\tsessionKeyDesc, err := n.cfg.SecretKeyRing.DeriveKey(\n\t\tkeychain.KeyLocator{\n\t\t\tFamily: keychain.KeyFamilyTowerSession,\n\t\t\tIndex:  keyIndex,\n\t\t},\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\tsessionKey := keychain.NewPubKeyECDH(\n\t\tsessionKeyDesc, n.cfg.SecretKeyRing,\n\t)\n\n\taddr := tower.Addresses.PeekAndLock()\n\tfor {\n\t\tlnAddr := &lnwire.NetAddress{\n\t\t\tIdentityKey: tower.IdentityKey,\n\t\t\tAddress:     addr,\n\t\t}\n\n\t\terr = n.tryAddress(sessionKey, keyIndex, tower, lnAddr)\n\t\ttower.Addresses.ReleaseLock(addr)\n\t\tswitch {\n\t\tcase err == ErrPermanentTowerFailure:\n\t\t\t// TODO(conner): report to iterator? can then be reset\n\t\t\t// with restart\n\t\t\tfallthrough\n\n\t\tcase err != nil:\n\t\t\tn.log.Debugf(\"Request for session negotiation with \"+\n\t\t\t\t\"tower=%s failed, trying again -- reason: \"+\n\t\t\t\t\"%v\", lnAddr, err)\n\n\t\t\t// Get the next tower address if there is one.\n\t\t\taddr, err = tower.Addresses.NextAndLock()\n\t\t\tif err == ErrAddressesExhausted {\n\t\t\t\ttower.Addresses.Reset()\n\n\t\t\t\treturn ErrFailedNegotiation\n\t\t\t}\n\n\t\t\tcontinue\n\n\t\tdefault:\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn ErrFailedNegotiation\n}\n\n// tryAddress executes a single create session dance using the given address.\n// The address should belong to the tower's set of addresses. This method only\n// returns true if all steps succeed and the new session has been persisted, and\n// fails otherwise.",
      "length": 1272,
      "tokens": 160,
      "embedding": []
    },
    {
      "slug": "func (n *sessionNegotiator) tryAddress(sessionKey keychain.SingleKeyECDH,",
      "content": "func (n *sessionNegotiator) tryAddress(sessionKey keychain.SingleKeyECDH,\n\tkeyIndex uint32, tower *Tower, lnAddr *lnwire.NetAddress) error {\n\n\t// Connect to the tower address using our generated session key.\n\tconn, err := n.cfg.Dial(sessionKey, lnAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Send local Init message.\n\terr = n.cfg.SendMessage(conn, n.localInit)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to send Init: %v\", err)\n\t}\n\n\t// Receive remote Init message.\n\tremoteMsg, err := n.cfg.ReadMessage(conn)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to read Init: %v\", err)\n\t}\n\n\t// Check that returned message is wtwire.Init.\n\tremoteInit, ok := remoteMsg.(*wtwire.Init)\n\tif !ok {\n\t\treturn fmt.Errorf(\"expected Init, got %T in reply\", remoteMsg)\n\t}\n\n\t// Verify the watchtower's remote Init message against our own.\n\terr = n.localInit.CheckRemoteInit(remoteInit, wtwire.FeatureNames)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpolicy := n.cfg.Policy\n\tcreateSession := &wtwire.CreateSession{\n\t\tBlobType:     policy.BlobType,\n\t\tMaxUpdates:   policy.MaxUpdates,\n\t\tRewardBase:   policy.RewardBase,\n\t\tRewardRate:   policy.RewardRate,\n\t\tSweepFeeRate: policy.SweepFeeRate,\n\t}\n\n\t// Send CreateSession message.\n\terr = n.cfg.SendMessage(conn, createSession)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to send CreateSession: %v\", err)\n\t}\n\n\t// Receive CreateSessionReply message.\n\tremoteMsg, err = n.cfg.ReadMessage(conn)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to read CreateSessionReply: %v\", err)\n\t}\n\n\t// Check that returned message is wtwire.CreateSessionReply.\n\tcreateSessionReply, ok := remoteMsg.(*wtwire.CreateSessionReply)\n\tif !ok {\n\t\treturn fmt.Errorf(\"expected CreateSessionReply, got %T in \"+\n\t\t\t\"reply\", remoteMsg)\n\t}\n\n\tswitch createSessionReply.Code {\n\tcase wtwire.CodeOK, wtwire.CreateSessionCodeAlreadyExists:\n\n\t\t// TODO(conner): add last-applied to create session reply to\n\t\t// handle case where we lose state, session already exists, and\n\t\t// we want to possibly resume using the session\n\n\t\t// TODO(conner): validate reward address\n\t\trewardPkScript := createSessionReply.Data\n\n\t\tsessionID := wtdb.NewSessionIDFromPubKey(sessionKey.PubKey())\n\t\tdbClientSession := &wtdb.ClientSession{\n\t\t\tClientSessionBody: wtdb.ClientSessionBody{\n\t\t\t\tTowerID:        tower.ID,\n\t\t\t\tKeyIndex:       keyIndex,\n\t\t\t\tPolicy:         n.cfg.Policy,\n\t\t\t\tRewardPkScript: rewardPkScript,\n\t\t\t},\n\t\t\tID: sessionID,\n\t\t}\n\n\t\terr = n.cfg.DB.CreateClientSession(dbClientSession)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to persist ClientSession: %v\",\n\t\t\t\terr)\n\t\t}\n\n\t\tn.log.Debugf(\"New session negotiated with %s, policy: %s\",\n\t\t\tlnAddr, dbClientSession.Policy)\n\n\t\tclientSession := &ClientSession{\n\t\t\tID:                sessionID,\n\t\t\tClientSessionBody: dbClientSession.ClientSessionBody,\n\t\t\tTower:             tower,\n\t\t\tSessionKeyECDH:    sessionKey,\n\t\t}\n\n\t\t// We have a newly negotiated session, return it to the\n\t\t// dispatcher so that it can update how many outstanding\n\t\t// negotiation requests we have.\n\t\tselect {\n\t\tcase n.successfulNegotiations <- clientSession:\n\t\t\treturn nil\n\t\tcase <-n.quit:\n\t\t\treturn ErrNegotiatorExiting\n\t\t}\n\n\t// TODO(conner): handle error codes properly\n\tcase wtwire.CreateSessionCodeRejectBlobType:\n\t\treturn fmt.Errorf(\"tower rejected blob type: %v\",\n\t\t\tpolicy.BlobType)\n\n\tcase wtwire.CreateSessionCodeRejectMaxUpdates:\n\t\treturn fmt.Errorf(\"tower rejected max updates: %v\",\n\t\t\tpolicy.MaxUpdates)\n\n\tcase wtwire.CreateSessionCodeRejectRewardRate:\n\t\t// The tower rejected the session because of the reward rate. If\n\t\t// we didn't request a reward session, we'll treat this as a\n\t\t// permanent tower failure.\n\t\tif !policy.BlobType.Has(blob.FlagReward) {\n\t\t\treturn ErrPermanentTowerFailure\n\t\t}\n\n\t\treturn fmt.Errorf(\"tower rejected reward rate: %v\",\n\t\t\tpolicy.RewardRate)\n\n\tcase wtwire.CreateSessionCodeRejectSweepFeeRate:\n\t\treturn fmt.Errorf(\"tower rejected sweep fee rate: %v\",\n\t\t\tpolicy.SweepFeeRate)\n\n\tdefault:\n\t\treturn fmt.Errorf(\"received unhandled error code: %v\",\n\t\t\tcreateSessionReply.Code)\n\t}\n}\n",
      "length": 3793,
      "tokens": 430,
      "embedding": []
    }
  ]
}