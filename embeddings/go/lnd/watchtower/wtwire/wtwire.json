{
  "filepath": "../implementations/go/lnd/watchtower/wtwire/wtwire.go",
  "package": "wtwire",
  "sections": [
    {
      "slug": "func WriteElement(w io.Writer, element interface{}) error {",
      "content": "func WriteElement(w io.Writer, element interface{}) error {\n\tswitch e := element.(type) {\n\tcase uint8:\n\t\tvar b [1]byte\n\t\tb[0] = e\n\t\tif _, err := w.Write(b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase uint16:\n\t\tvar b [2]byte\n\t\tbinary.BigEndian.PutUint16(b[:], e)\n\t\tif _, err := w.Write(b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase blob.Type:\n\t\tvar b [2]byte\n\t\tbinary.BigEndian.PutUint16(b[:], uint16(e))\n\t\tif _, err := w.Write(b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase uint32:\n\t\tvar b [4]byte\n\t\tbinary.BigEndian.PutUint32(b[:], e)\n\t\tif _, err := w.Write(b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase uint64:\n\t\tvar b [8]byte\n\t\tbinary.BigEndian.PutUint64(b[:], e)\n\t\tif _, err := w.Write(b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase [16]byte:\n\t\tif _, err := w.Write(e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase [32]byte:\n\t\tif _, err := w.Write(e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase [33]byte:\n\t\tif _, err := w.Write(e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase []byte:\n\t\tif err := wire.WriteVarBytes(w, 0, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase chainfee.SatPerKWeight:\n\t\tvar b [8]byte\n\t\tbinary.BigEndian.PutUint64(b[:], uint64(e))\n\t\tif _, err := w.Write(b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase ErrorCode:\n\t\tvar b [2]byte\n\t\tbinary.BigEndian.PutUint16(b[:], uint16(e))\n\t\tif _, err := w.Write(b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase chainhash.Hash:\n\t\tif _, err := w.Write(e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *lnwire.RawFeatureVector:\n\t\tif e == nil {\n\t\t\treturn fmt.Errorf(\"cannot write nil feature vector\")\n\t\t}\n\n\t\tif err := e.Encode(w); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *btcec.PublicKey:\n\t\tif e == nil {\n\t\t\treturn fmt.Errorf(\"cannot write nil pubkey\")\n\t\t}\n\n\t\tvar b [33]byte\n\t\tserializedPubkey := e.SerializeCompressed()\n\t\tcopy(b[:], serializedPubkey)\n\t\tif _, err := w.Write(b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tdefault:\n\t\treturn fmt.Errorf(\"Unknown type in WriteElement: %T\", e)\n\t}\n\n\treturn nil\n}\n\n// WriteElements is writes each element in the elements slice to the passed\n// io.Writer using WriteElement.",
      "length": 1870,
      "tokens": 297,
      "embedding": []
    },
    {
      "slug": "func WriteElements(w io.Writer, elements ...interface{}) error {",
      "content": "func WriteElements(w io.Writer, elements ...interface{}) error {\n\tfor _, element := range elements {\n\t\terr := WriteElement(w, element)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// ReadElement is a one-stop utility function to deserialize any datastructure\n// encoded using the serialization format of lnwire.",
      "length": 245,
      "tokens": 42,
      "embedding": []
    },
    {
      "slug": "func ReadElement(r io.Reader, element interface{}) error {",
      "content": "func ReadElement(r io.Reader, element interface{}) error {\n\tswitch e := element.(type) {\n\tcase *uint8:\n\t\tvar b [1]uint8\n\t\tif _, err := r.Read(b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*e = b[0]\n\n\tcase *uint16:\n\t\tvar b [2]byte\n\t\tif _, err := io.ReadFull(r, b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*e = binary.BigEndian.Uint16(b[:])\n\n\tcase *blob.Type:\n\t\tvar b [2]byte\n\t\tif _, err := io.ReadFull(r, b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*e = blob.Type(binary.BigEndian.Uint16(b[:]))\n\n\tcase *uint32:\n\t\tvar b [4]byte\n\t\tif _, err := io.ReadFull(r, b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*e = binary.BigEndian.Uint32(b[:])\n\n\tcase *uint64:\n\t\tvar b [8]byte\n\t\tif _, err := io.ReadFull(r, b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*e = binary.BigEndian.Uint64(b[:])\n\n\tcase *[16]byte:\n\t\tif _, err := io.ReadFull(r, e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *[32]byte:\n\t\tif _, err := io.ReadFull(r, e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *[33]byte:\n\t\tif _, err := io.ReadFull(r, e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *[]byte:\n\t\tbytes, err := wire.ReadVarBytes(r, 0, 66000, \"[]byte\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*e = bytes\n\n\tcase *chainfee.SatPerKWeight:\n\t\tvar b [8]byte\n\t\tif _, err := io.ReadFull(r, b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*e = chainfee.SatPerKWeight(binary.BigEndian.Uint64(b[:]))\n\n\tcase *ErrorCode:\n\t\tvar b [2]byte\n\t\tif _, err := io.ReadFull(r, b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*e = ErrorCode(binary.BigEndian.Uint16(b[:]))\n\n\tcase *chainhash.Hash:\n\t\tif _, err := io.ReadFull(r, e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase **lnwire.RawFeatureVector:\n\t\tf := lnwire.NewRawFeatureVector()\n\t\terr := f.Decode(r)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t*e = f\n\n\tcase **btcec.PublicKey:\n\t\tvar b [btcec.PubKeyBytesLenCompressed]byte\n\t\tif _, err := io.ReadFull(r, b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tpubKey, err := btcec.ParsePubKey(b[:])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*e = pubKey\n\n\tdefault:\n\t\treturn fmt.Errorf(\"Unknown type in ReadElement: %T\", e)\n\t}\n\n\treturn nil\n}\n\n// ReadElements deserializes a variable number of elements into the passed\n// io.Reader, with each element being deserialized according to the ReadElement\n// function.",
      "length": 2011,
      "tokens": 319,
      "embedding": []
    },
    {
      "slug": "func ReadElements(r io.Reader, elements ...interface{}) error {",
      "content": "func ReadElements(r io.Reader, elements ...interface{}) error {\n\tfor _, element := range elements {\n\t\terr := ReadElement(r, element)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n",
      "length": 114,
      "tokens": 23,
      "embedding": []
    }
  ]
}