{
  "filepath": "../implementations/go/lnd/watchtower/wtdb/range_index_test.go",
  "package": "wtdb",
  "sections": [
    {
      "slug": "func TestRangeIndex(t *testing.T) {",
      "content": "func TestRangeIndex(t *testing.T) {\n\tt.Parallel()\n\n\tassertRanges := func(index *RangeIndex, kvStore *mockKVStore,\n\t\tv map[uint64]uint64) {\n\n\t\trequire.EqualValues(t, v, index.GetAllRanges())\n\t\trequire.EqualValues(t, v, kvStore.kv)\n\t}\n\n\tt.Run(\"test zero value height\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tkvStore := newMockKVStore(nil)\n\t\tindex, err := NewRangeIndex(nil)\n\t\trequire.NoError(t, err)\n\n\t\t// Since zero values are tricky, assert that the empty index\n\t\t// does not include zero.\n\t\trequire.False(t, index.IsInIndex(0))\n\n\t\t// Now add zero to the index.\n\t\t_ = index.Add(0, kvStore)\n\t\tassertRanges(index, kvStore, map[uint64]uint64{0: 0})\n\t\trequire.True(t, index.IsInIndex(0))\n\t})\n\n\tt.Run(\"add duplicates\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tkvStore := newMockKVStore(nil)\n\t\tindex, err := NewRangeIndex(nil)\n\t\trequire.NoError(t, err)\n\n\t\trequire.False(t, index.IsInIndex(1))\n\n\t\t// Add 1 to the range.\n\t\terr = index.Add(1, kvStore)\n\t\trequire.NoError(t, err)\n\n\t\tassertRanges(index, kvStore, map[uint64]uint64{1: 1})\n\t\trequire.EqualValues(t, 1, index.MaxHeight())\n\t\trequire.True(t, index.IsInIndex(1))\n\n\t\t// Add 1 again and assert that nothing has changed.\n\t\terr = index.Add(1, kvStore)\n\t\trequire.NoError(t, err)\n\n\t\tassertRanges(index, kvStore, map[uint64]uint64{1: 1})\n\t\trequire.EqualValues(t, 1, index.MaxHeight())\n\t\trequire.True(t, index.IsInIndex(1))\n\t})\n\n\tt.Run(\"extend an existing range\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tkvStore := newMockKVStore(nil)\n\t\tindex, err := NewRangeIndex(nil)\n\t\trequire.NoError(t, err)\n\n\t\tassertRanges(index, kvStore, map[uint64]uint64{})\n\n\t\t// Add 2.\n\t\t_ = index.Add(2, kvStore)\n\t\tassertRanges(index, kvStore, map[uint64]uint64{\n\t\t\t2: 2,\n\t\t})\n\n\t\t// Add 3, 4 and 5 and assert that these just extend the existing\n\t\t// range by incrementing its end value.\n\t\t_ = index.Add(3, kvStore)\n\t\t_ = index.Add(4, kvStore)\n\t\t_ = index.Add(5, kvStore)\n\t\tassertRanges(index, kvStore, map[uint64]uint64{\n\t\t\t2: 5,\n\t\t})\n\n\t\t// Now add 1 and 0 and assert that these just extend the\n\t\t// existing range by decrementing its start value.\n\t\t_ = index.Add(1, kvStore)\n\t\t_ = index.Add(0, kvStore)\n\t\tassertRanges(index, kvStore, map[uint64]uint64{\n\t\t\t0: 5,\n\t\t})\n\n\t\t// Assert various other properties of the current range.\n\t\trequire.True(t, index.IsInIndex(3))\n\t\trequire.EqualValues(t, 5, index.MaxHeight())\n\t})\n\n\tt.Run(\"add new ranges above and below\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\t// Initialise the index with an initial range.\n\t\tinitialState := map[uint64]uint64{\n\t\t\t4: 10,\n\t\t}\n\n\t\tkvStore := newMockKVStore(initialState)\n\t\tindex, err := NewRangeIndex(initialState)\n\t\trequire.NoError(t, err)\n\n\t\t// Add 2 and 12. This should create two new ranges in the index.\n\t\t_ = index.Add(12, kvStore)\n\t\t_ = index.Add(2, kvStore)\n\t\tassertRanges(index, kvStore, map[uint64]uint64{\n\t\t\t2:  2,\n\t\t\t4:  10,\n\t\t\t12: 12,\n\t\t})\n\n\t\t// Assert various other properties of the current range.\n\t\trequire.EqualValues(t, 12, index.MaxHeight())\n\t\trequire.False(t, index.IsInIndex(3))\n\t\trequire.False(t, index.IsInIndex(11))\n\t\trequire.True(t, index.IsInIndex(2))\n\t\trequire.True(t, index.IsInIndex(5))\n\t\trequire.True(t, index.IsInIndex(12))\n\t})\n\n\tt.Run(\"merging two ranges\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\t// Initialise the index with an initial set of ranges.\n\t\tinitialState := map[uint64]uint64{\n\t\t\t2:  2,\n\t\t\t4:  10,\n\t\t\t12: 12,\n\t\t}\n\n\t\tkvStore := newMockKVStore(initialState)\n\t\tindex, err := NewRangeIndex(initialState)\n\t\trequire.NoError(t, err)\n\n\t\t// Adding 3 should merge the first and second ranges.\n\t\t_ = index.Add(3, kvStore)\n\t\tassertRanges(index, kvStore, map[uint64]uint64{\n\t\t\t2:  10,\n\t\t\t12: 12,\n\t\t})\n\n\t\t// Adding 11 should merge the first and second ranges.\n\t\t_ = index.Add(11, kvStore)\n\t\tassertRanges(index, kvStore, map[uint64]uint64{\n\t\t\t2: 12,\n\t\t})\n\n\t\t// Assert various other properties of the current range.\n\t\trequire.EqualValues(t, 12, index.MaxHeight())\n\t\trequire.True(t, index.IsInIndex(2))\n\t\trequire.True(t, index.IsInIndex(5))\n\t\trequire.True(t, index.IsInIndex(12))\n\t\trequire.False(t, index.IsInIndex(1))\n\t})\n\n\tt.Run(\"failure applying KV store updates\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tkvStore := newMockKVStore(nil)\n\t\tindex, err := NewRangeIndex(nil)\n\t\trequire.NoError(t, err)\n\n\t\tassertRanges(index, kvStore, map[uint64]uint64{})\n\n\t\t// Ensure that the kv store will return an error when its\n\t\t// methods are called.\n\t\tkvStore.setError(fmt.Errorf(\"db error\"))\n\n\t\t// Now attempt to add a new item to the range.\n\t\terr = index.Add(20, kvStore)\n\t\trequire.Error(t, err)\n\n\t\t// Assert that the update failed for both the kv store and the\n\t\t// array store.\n\t\tassertRanges(index, kvStore, map[uint64]uint64{})\n\n\t\t// Now let the kv store again not return an error.\n\t\tkvStore.setError(nil)\n\n\t\t// Again attempt to add a new item to the range.\n\t\terr = index.Add(20, kvStore)\n\t\trequire.NoError(t, err)\n\n\t\t// It should now succeed.\n\t\tassertRanges(index, kvStore, map[uint64]uint64{\n\t\t\t20: 20,\n\t\t})\n\t})\n\n\tt.Run(\"initialising with different ranges\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttests := []struct {\n\t\t\tname          string\n\t\t\tinput         map[uint64]uint64\n\t\t\texpectErr     bool\n\t\t\texpectedIndex map[uint64]uint64\n\t\t}{\n\t\t\t{\n\t\t\t\tname: \"invalid ranges\",\n\t\t\t\tinput: map[uint64]uint64{\n\t\t\t\t\t1: 5,\n\t\t\t\t\t6: 4,\n\t\t\t\t},\n\t\t\t\texpectErr: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"non-overlapping ranges\",\n\t\t\t\tinput: map[uint64]uint64{\n\t\t\t\t\t1: 2,\n\t\t\t\t\t4: 6,\n\t\t\t\t\t8: 20,\n\t\t\t\t},\n\t\t\t\texpectedIndex: map[uint64]uint64{\n\t\t\t\t\t1: 2,\n\t\t\t\t\t4: 6,\n\t\t\t\t\t8: 20,\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"merge-able ranges\",\n\t\t\t\tinput: map[uint64]uint64{\n\t\t\t\t\t1: 2,\n\t\t\t\t\t3: 6,\n\t\t\t\t\t7: 20,\n\t\t\t\t},\n\t\t\t\texpectedIndex: map[uint64]uint64{\n\t\t\t\t\t1: 20,\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"overlapping ranges\",\n\t\t\t\tinput: map[uint64]uint64{\n\t\t\t\t\t1: 4,\n\t\t\t\t\t3: 7,\n\t\t\t\t\t6: 20,\n\t\t\t\t},\n\t\t\t\texpectedIndex: map[uint64]uint64{\n\t\t\t\t\t1: 20,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tfor _, test := range tests {\n\t\t\tindex, err := NewRangeIndex(test.input)\n\t\t\tif test.expectErr {\n\t\t\t\trequire.Error(t, err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\trequire.NoError(t, err)\n\n\t\t\trequire.EqualValues(\n\t\t\t\tt, test.expectedIndex, index.GetAllRanges(),\n\t\t\t)\n\t\t}\n\t})\n\n\tt.Run(\"test large number of random inserts\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tsize := 10000\n\n\t\t// Construct an array with values from 0 to size.\n\t\tarr := make([]uint64, size)\n\t\tfor i := 0; i < size; i++ {\n\t\t\tarr[i] = uint64(i)\n\t\t}\n\n\t\t// Shuffle the array so that the values are not added in order.\n\t\trand.Seed(time.Now().UnixNano())\n\t\trand.Shuffle(len(arr), func(i, j int) {\n\t\t\tarr[i], arr[j] = arr[j], arr[i]\n\t\t})\n\n\t\tkvStore := newMockKVStore(nil)\n\t\tindex, err := NewRangeIndex(nil)\n\t\trequire.NoError(t, err)\n\n\t\t// Now add each item in the array to the index.\n\t\tfor _, n := range arr {\n\t\t\t_ = index.Add(n, kvStore)\n\t\t}\n\n\t\t// Assert that in the end, there is only a single range.\n\t\tassertRanges(index, kvStore, map[uint64]uint64{\n\t\t\t0: uint64(size - 1),\n\t\t})\n\n\t\trequire.EqualValues(t, uint64(size-1), index.MaxHeight())\n\t})\n}\n",
      "length": 6567,
      "tokens": 805,
      "embedding": []
    },
    {
      "slug": "type mockKVStore struct {",
      "content": "type mockKVStore struct {\n\tkv map[uint64]uint64\n\n\terr error\n}\n",
      "length": 32,
      "tokens": 5,
      "embedding": []
    },
    {
      "slug": "func newMockKVStore(initialRanges map[uint64]uint64) *mockKVStore {",
      "content": "func newMockKVStore(initialRanges map[uint64]uint64) *mockKVStore {\n\tif initialRanges != nil {\n\t\treturn &mockKVStore{\n\t\t\tkv: initialRanges,\n\t\t}\n\t}\n\n\treturn &mockKVStore{\n\t\tkv: make(map[uint64]uint64),\n\t}\n}\n",
      "length": 128,
      "tokens": 17,
      "embedding": []
    },
    {
      "slug": "func (m *mockKVStore) setError(err error) {",
      "content": "func (m *mockKVStore) setError(err error) {\n\tm.err = err\n}\n",
      "length": 13,
      "tokens": 4,
      "embedding": []
    },
    {
      "slug": "func (m *mockKVStore) Put(key, value []byte) error {",
      "content": "func (m *mockKVStore) Put(key, value []byte) error {\n\tif m.err != nil {\n\t\treturn m.err\n\t}\n\n\tk := byteOrder.Uint64(key)\n\tv := byteOrder.Uint64(value)\n\n\tm.kv[k] = v\n\n\treturn nil\n}\n",
      "length": 114,
      "tokens": 20,
      "embedding": []
    },
    {
      "slug": "func (m *mockKVStore) Delete(key []byte) error {",
      "content": "func (m *mockKVStore) Delete(key []byte) error {\n\tif m.err != nil {\n\t\treturn m.err\n\t}\n\n\tk := byteOrder.Uint64(key)\n\tdelete(m.kv, k)\n\n\treturn nil\n}\n",
      "length": 89,
      "tokens": 16,
      "embedding": []
    }
  ]
}