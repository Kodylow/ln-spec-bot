{
  "filepath": "../implementations/go/lnd/watchtower/wtdb/migration3/client_db_test.go",
  "package": "migration3",
  "sections": [
    {
      "slug": "func TestMigrateChannelIDIndex(t *testing.T) {",
      "content": "func TestMigrateChannelIDIndex(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tname        string\n\t\tshouldFail  bool\n\t\tpre         map[string]interface{}\n\t\tpostDetails map[string]interface{}\n\t\tpostIndex   map[string]interface{}\n\t}{\n\t\t{\n\t\t\tname:        \"migration ok\",\n\t\t\tshouldFail:  false,\n\t\t\tpre:         pre,\n\t\t\tpostDetails: postDetails,\n\t\t\tpostIndex:   postIndex,\n\t\t},\n\t\t{\n\t\t\tname:       \"fail due to corrupt db\",\n\t\t\tshouldFail: true,\n\t\t\tpre:        preFailCorruptDB,\n\t\t},\n\t\t{\n\t\t\tname:        \"no channel details\",\n\t\t\tshouldFail:  false,\n\t\t\tpre:         nil,\n\t\t\tpostDetails: nil,\n\t\t\tpostIndex:   nil,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\t// Before the migration we have a details bucket.\n\t\t\tbefore := func(tx kvdb.RwTx) error {\n\t\t\t\treturn migtest.RestoreDB(\n\t\t\t\t\ttx, cChanDetailsBkt, test.pre,\n\t\t\t\t)\n\t\t\t}\n\n\t\t\t// After the migration, we should have an untouched\n\t\t\t// summary bucket and a new index bucket.\n\t\t\tafter := func(tx kvdb.RwTx) error {\n\t\t\t\t// If the migration fails, the details bucket\n\t\t\t\t// should be untouched.\n\t\t\t\tif test.shouldFail {\n\t\t\t\t\tif err := migtest.VerifyDB(\n\t\t\t\t\t\ttx, cChanDetailsBkt, test.pre,\n\t\t\t\t\t); err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\n\t\t\t\t// Else, we expect an updated summary bucket\n\t\t\t\t// and a new index bucket.\n\t\t\t\terr := migtest.VerifyDB(\n\t\t\t\t\ttx, cChanDetailsBkt, test.postDetails,\n\t\t\t\t)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\treturn migtest.VerifyDB(\n\t\t\t\t\ttx, cChanIDIndexBkt, test.postIndex,\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tmigtest.ApplyMigration(\n\t\t\t\tt, before, after, MigrateChannelIDIndex,\n\t\t\t\ttest.shouldFail,\n\t\t\t)\n\t\t})\n\t}\n}\n",
      "length": 1542,
      "tokens": 195,
      "embedding": []
    },
    {
      "slug": "func indexToString(id uint64) string {",
      "content": "func indexToString(id uint64) string {\n\tvar newIndex bytes.Buffer\n\terr := tlv.WriteVarInt(&newIndex, id, &[8]byte{})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn newIndex.String()\n}\n",
      "length": 132,
      "tokens": 18,
      "embedding": []
    },
    {
      "slug": "func channelIDString(id uint64) string {",
      "content": "func channelIDString(id uint64) string {\n\tvar chanID ChannelID\n\tbyteOrder.PutUint64(chanID[:], id)\n\treturn chanID.String()\n}\n",
      "length": 80,
      "tokens": 8,
      "embedding": []
    }
  ]
}