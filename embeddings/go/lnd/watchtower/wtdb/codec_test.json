{
  "filepath": "../implementations/go/lnd/watchtower/wtdb/codec_test.go",
  "package": "wtdb_test",
  "sections": [
    {
      "slug": "func randPubKey() (*btcec.PublicKey, error) {",
      "content": "func randPubKey() (*btcec.PublicKey, error) {\n\tpriv, err := btcec.NewPrivateKey()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn priv.PubKey(), nil\n}\n",
      "length": 97,
      "tokens": 17,
      "embedding": []
    },
    {
      "slug": "func randTCP4Addr(r *rand.Rand) (*net.TCPAddr, error) {",
      "content": "func randTCP4Addr(r *rand.Rand) (*net.TCPAddr, error) {\n\tvar ip [4]byte\n\tif _, err := r.Read(ip[:]); err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar port [2]byte\n\tif _, err := r.Read(port[:]); err != nil {\n\t\treturn nil, err\n\t}\n\n\taddrIP := net.IP(ip[:])\n\taddrPort := int(binary.BigEndian.Uint16(port[:]))\n\n\treturn &net.TCPAddr{IP: addrIP, Port: addrPort}, nil\n}\n",
      "length": 282,
      "tokens": 45,
      "embedding": []
    },
    {
      "slug": "func randTCP6Addr(r *rand.Rand) (*net.TCPAddr, error) {",
      "content": "func randTCP6Addr(r *rand.Rand) (*net.TCPAddr, error) {\n\tvar ip [16]byte\n\tif _, err := r.Read(ip[:]); err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar port [2]byte\n\tif _, err := r.Read(port[:]); err != nil {\n\t\treturn nil, err\n\t}\n\n\taddrIP := net.IP(ip[:])\n\taddrPort := int(binary.BigEndian.Uint16(port[:]))\n\n\treturn &net.TCPAddr{IP: addrIP, Port: addrPort}, nil\n}\n",
      "length": 283,
      "tokens": 45,
      "embedding": []
    },
    {
      "slug": "func randV2OnionAddr(r *rand.Rand) (*tor.OnionAddr, error) {",
      "content": "func randV2OnionAddr(r *rand.Rand) (*tor.OnionAddr, error) {\n\tvar serviceID [tor.V2DecodedLen]byte\n\tif _, err := r.Read(serviceID[:]); err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar port [2]byte\n\tif _, err := r.Read(port[:]); err != nil {\n\t\treturn nil, err\n\t}\n\n\tonionService := tor.Base32Encoding.EncodeToString(serviceID[:])\n\tonionService += tor.OnionSuffix\n\taddrPort := int(binary.BigEndian.Uint16(port[:]))\n\n\treturn &tor.OnionAddr{OnionService: onionService, Port: addrPort}, nil\n}\n",
      "length": 401,
      "tokens": 48,
      "embedding": []
    },
    {
      "slug": "func randV3OnionAddr(r *rand.Rand) (*tor.OnionAddr, error) {",
      "content": "func randV3OnionAddr(r *rand.Rand) (*tor.OnionAddr, error) {\n\tvar serviceID [tor.V3DecodedLen]byte\n\tif _, err := r.Read(serviceID[:]); err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar port [2]byte\n\tif _, err := r.Read(port[:]); err != nil {\n\t\treturn nil, err\n\t}\n\n\tonionService := tor.Base32Encoding.EncodeToString(serviceID[:])\n\tonionService += tor.OnionSuffix\n\taddrPort := int(binary.BigEndian.Uint16(port[:]))\n\n\treturn &tor.OnionAddr{OnionService: onionService, Port: addrPort}, nil\n}\n",
      "length": 401,
      "tokens": 48,
      "embedding": []
    },
    {
      "slug": "func randAddrs(r *rand.Rand) ([]net.Addr, error) {",
      "content": "func randAddrs(r *rand.Rand) ([]net.Addr, error) {\n\ttcp4Addr, err := randTCP4Addr(r)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ttcp6Addr, err := randTCP6Addr(r)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tv2OnionAddr, err := randV2OnionAddr(r)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tv3OnionAddr, err := randV3OnionAddr(r)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn []net.Addr{tcp4Addr, tcp6Addr, v2OnionAddr, v3OnionAddr}, nil\n}\n\n// dbObject is abstract object support encoding and decoding.",
      "length": 415,
      "tokens": 68,
      "embedding": []
    },
    {
      "slug": "type dbObject interface {",
      "content": "type dbObject interface {\n\tEncode(io.Writer) error\n\tDecode(io.Reader) error\n}\n\n// TestCodec serializes and deserializes wtdb objects in order to test that the\n// codec understands all of the required field types. The test also asserts that\n// decoding an object into another results in an equivalent object.",
      "length": 275,
      "tokens": 43,
      "embedding": []
    },
    {
      "slug": "func TestCodec(tt *testing.T) {",
      "content": "func TestCodec(tt *testing.T) {\n\n\tvar t *testing.T\n\tmainScenario := func(obj dbObject) bool {\n\t\t// Ensure encoding the object succeeds.\n\t\tvar b bytes.Buffer\n\t\terr := obj.Encode(&b)\n\t\trequire.NoError(t, err)\n\n\t\tvar obj2 dbObject\n\t\tswitch obj.(type) {\n\t\tcase *wtdb.SessionInfo:\n\t\t\tobj2 = &wtdb.SessionInfo{}\n\t\tcase *wtdb.SessionStateUpdate:\n\t\t\tobj2 = &wtdb.SessionStateUpdate{}\n\t\tcase *wtdb.ClientSessionBody:\n\t\t\tobj2 = &wtdb.ClientSessionBody{}\n\t\tcase *wtdb.CommittedUpdateBody:\n\t\t\tobj2 = &wtdb.CommittedUpdateBody{}\n\t\tcase *wtdb.BackupID:\n\t\t\tobj2 = &wtdb.BackupID{}\n\t\tcase *wtdb.Tower:\n\t\t\tobj2 = &wtdb.Tower{}\n\t\tcase *wtdb.ClientChanSummary:\n\t\t\tobj2 = &wtdb.ClientChanSummary{}\n\t\tdefault:\n\t\t\tt.Fatalf(\"unknown type: %T\", obj)\n\t\t\treturn false\n\t\t}\n\n\t\t// Ensure decoding the object succeeds.\n\t\terr = obj2.Decode(bytes.NewReader(b.Bytes()))\n\t\trequire.NoError(t, err)\n\n\t\t// Assert the original and decoded object match.\n\t\trequire.Equal(t, obj, obj2)\n\n\t\treturn true\n\t}\n\n\tcustomTypeGen := map[string]func([]reflect.Value, *rand.Rand){\n\t\t\"Tower\": func(v []reflect.Value, r *rand.Rand) {\n\t\t\tpk, err := randPubKey()\n\t\t\trequire.NoError(t, err)\n\n\t\t\taddrs, err := randAddrs(r)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tobj := wtdb.Tower{\n\t\t\t\tIdentityKey: pk,\n\t\t\t\tAddresses:   addrs,\n\t\t\t}\n\n\t\t\tv[0] = reflect.ValueOf(obj)\n\t\t},\n\t}\n\n\ttests := []struct {\n\t\tname     string\n\t\tscenario interface{}\n\t}{\n\t\t{\n\t\t\tname: \"SessionInfo\",\n\t\t\tscenario: func(obj wtdb.SessionInfo) bool {\n\t\t\t\treturn mainScenario(&obj)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"SessionStateUpdate\",\n\t\t\tscenario: func(obj wtdb.SessionStateUpdate) bool {\n\t\t\t\treturn mainScenario(&obj)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ClientSessionBody\",\n\t\t\tscenario: func(obj wtdb.ClientSessionBody) bool {\n\t\t\t\treturn mainScenario(&obj)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"CommittedUpdateBody\",\n\t\t\tscenario: func(obj wtdb.CommittedUpdateBody) bool {\n\t\t\t\treturn mainScenario(&obj)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"BackupID\",\n\t\t\tscenario: func(obj wtdb.BackupID) bool {\n\t\t\t\treturn mainScenario(&obj)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Tower\",\n\t\t\tscenario: func(obj wtdb.Tower) bool {\n\t\t\t\treturn mainScenario(&obj)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ClientChanSummary\",\n\t\t\tscenario: func(obj wtdb.ClientChanSummary) bool {\n\t\t\t\treturn mainScenario(&obj)\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttt.Run(test.name, func(h *testing.T) {\n\t\t\tt = h\n\n\t\t\tvar config *quick.Config\n\t\t\tif valueGen, ok := customTypeGen[test.name]; ok {\n\t\t\t\tconfig = &quick.Config{\n\t\t\t\t\tValues: valueGen,\n\t\t\t\t}\n\t\t\t}\n\n\t\t\terr := quick.Check(test.scenario, config)\n\t\t\trequire.NoError(h, err)\n\t\t})\n\t}\n}\n",
      "length": 2378,
      "tokens": 266,
      "embedding": []
    }
  ]
}