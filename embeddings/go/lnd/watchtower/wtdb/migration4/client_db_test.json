{
  "filepath": "../implementations/go/lnd/watchtower/wtdb/migration4/client_db_test.go",
  "package": "migration4",
  "sections": [
    {
      "slug": "func TestMigrateAckedUpdates(t *testing.T) {",
      "content": "func TestMigrateAckedUpdates(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tname       string\n\t\tshouldFail bool\n\t\tpre        map[string]interface{}\n\t\tpost       map[string]interface{}\n\t}{\n\t\t{\n\t\t\tname:       \"migration ok\",\n\t\t\tshouldFail: false,\n\t\t\tpre:        preSessions,\n\t\t\tpost:       postSessions,\n\t\t},\n\t\t{\n\t\t\tname:       \"migration ok after re-starting\",\n\t\t\tshouldFail: false,\n\t\t\tpre:        preMidStateDB,\n\t\t\tpost:       postSessions,\n\t\t},\n\t\t{\n\t\t\tname:       \"fail due to corrupt db\",\n\t\t\tshouldFail: true,\n\t\t\tpre:        preFailCorruptDB,\n\t\t},\n\t\t{\n\t\t\tname:       \"no sessions details\",\n\t\t\tshouldFail: false,\n\t\t\tpre:        nil,\n\t\t\tpost:       nil,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tbefore := before(test.pre)\n\n\t\t\t// After the migration, we should have an untouched\n\t\t\t// summary bucket and a new index bucket.\n\t\t\tafter := after(test.shouldFail, test.pre, test.post)\n\n\t\t\tmigtest.ApplyMigrationWithDB(\n\t\t\t\tt, before, after, MigrateAckedUpdates(2),\n\t\t\t\ttest.shouldFail,\n\t\t\t)\n\t\t})\n\t}\n}\n\n// before returns a call-back function that can be used to set up a db's\n// cChanDetailsBkt along with the cSessionBkt using the passed preMigDB\n// structure.",
      "length": 1135,
      "tokens": 140,
      "embedding": []
    },
    {
      "slug": "func before(preMigDB map[string]interface{}) func(backend kvdb.Backend) error {",
      "content": "func before(preMigDB map[string]interface{}) func(backend kvdb.Backend) error {\n\treturn func(db kvdb.Backend) error {\n\t\treturn db.Update(func(tx walletdb.ReadWriteTx) error {\n\t\t\terr := migtest.RestoreDB(\n\t\t\t\ttx, cChanDetailsBkt, details,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\treturn migtest.RestoreDB(\n\t\t\t\ttx, cSessionBkt, preMigDB,\n\t\t\t)\n\t\t}, func() {})\n\t}\n}\n\n// after returns a call-back function that can be used to verify the state of\n// a db post migration.",
      "length": 374,
      "tokens": 56,
      "embedding": []
    },
    {
      "slug": "func after(shouldFail bool, preMigDB,",
      "content": "func after(shouldFail bool, preMigDB,\n\tpostMigDB map[string]interface{}) func(backend kvdb.Backend) error {\n\n\treturn func(db kvdb.Backend) error {\n\t\treturn db.Update(func(tx walletdb.ReadWriteTx) error {\n\t\t\t// The channel details bucket should remain untouched.\n\t\t\terr := migtest.VerifyDB(tx, cChanDetailsBkt, details)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// If the migration fails, the sessions bucket should be\n\t\t\t// untouched.\n\t\t\tif shouldFail {\n\t\t\t\tif err := migtest.VerifyDB(\n\t\t\t\t\ttx, cSessionBkt, preMigDB,\n\t\t\t\t); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\treturn migtest.VerifyDB(tx, cSessionBkt, postMigDB)\n\t\t}, func() {})\n\t}\n}\n",
      "length": 595,
      "tokens": 79,
      "embedding": []
    },
    {
      "slug": "func sessionIDString(id string) string {",
      "content": "func sessionIDString(id string) string {\n\tvar sessID SessionID\n\tcopy(sessID[:], id)\n\treturn sessID.String()\n}\n",
      "length": 65,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func intToChannelID(id uint64) ChannelID {",
      "content": "func intToChannelID(id uint64) ChannelID {\n\tvar chanID ChannelID\n\tbyteOrder.PutUint64(chanID[:], id)\n\treturn chanID\n}\n",
      "length": 71,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func channelIDString(id uint64) string {",
      "content": "func channelIDString(id uint64) string {\n\tvar chanID ChannelID\n\tbyteOrder.PutUint64(chanID[:], id)\n\treturn string(chanID[:])\n}\n",
      "length": 82,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func uint64ToStr(id uint64) string {",
      "content": "func uint64ToStr(id uint64) string {\n\tb, err := writeBigSize(id)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn string(b)\n}\n",
      "length": 75,
      "tokens": 14,
      "embedding": []
    },
    {
      "slug": "func backupIDToString(backup *BackupID) string {",
      "content": "func backupIDToString(backup *BackupID) string {\n\tvar b bytes.Buffer\n\t_ = backup.Encode(&b)\n\treturn b.String()\n}\n",
      "length": 60,
      "tokens": 9,
      "embedding": []
    }
  ]
}