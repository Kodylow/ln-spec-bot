{
  "filepath": "../implementations/go/lnd/watchtower/wtdb/migration1/codec.go",
  "package": "migration1",
  "sections": [
    {
      "slug": "type UnknownElementType = channeldb.UnknownElementType",
      "content": "type UnknownElementType = channeldb.UnknownElementType\n\n// SessionID is created from the remote public key of a client, and serves as a\n// unique identifier and authentication for sending state updates.",
      "length": 145,
      "tokens": 25,
      "embedding": []
    },
    {
      "slug": "type SessionID [SessionIDSize]byte",
      "content": "type SessionID [SessionIDSize]byte\n\n// TowerID is a unique 64-bit identifier allocated to each unique watchtower.\n// This allows the client to conserve on-disk space by not needing to always\n// reference towers by their pubkey.",
      "length": 189,
      "tokens": 32,
      "embedding": []
    },
    {
      "slug": "type TowerID uint64",
      "content": "type TowerID uint64\n\n// Bytes encodes a TowerID into an 8-byte slice in big-endian byte order.",
      "length": 73,
      "tokens": 13,
      "embedding": []
    },
    {
      "slug": "func (id TowerID) Bytes() []byte {",
      "content": "func (id TowerID) Bytes() []byte {\n\tvar buf [8]byte\n\tbinary.BigEndian.PutUint64(buf[:], uint64(id))\n\treturn buf[:]\n}\n\n// ClientSession encapsulates a SessionInfo returned from a successful\n// session negotiation, and also records the tower and ephemeral secret used for\n// communicating with the tower.",
      "length": 260,
      "tokens": 35,
      "embedding": []
    },
    {
      "slug": "type ClientSession struct {",
      "content": "type ClientSession struct {\n\t// ID is the client's public key used when authenticating with the\n\t// tower.\n\tID SessionID\n\tClientSessionBody\n}\n\n// CSessionStatus is a bit-field representing the possible statuses of\n// ClientSessions.",
      "length": 197,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "type CSessionStatus uint8",
      "content": "type CSessionStatus uint8\n",
      "length": 0,
      "tokens": 0,
      "embedding": []
    },
    {
      "slug": "type ClientSessionBody struct {",
      "content": "type ClientSessionBody struct {\n\t// SeqNum is the next unallocated sequence number that can be sent to\n\t// the tower.\n\tSeqNum uint16\n\n\t// TowerLastApplied the last last-applied the tower has echoed back.\n\tTowerLastApplied uint16\n\n\t// TowerID is the unique, db-assigned identifier that references the\n\t// Tower with which the session is negotiated.\n\tTowerID TowerID\n\n\t// KeyIndex is the index of key locator used to derive the client's\n\t// session key so that it can authenticate with the tower to update its\n\t// session. In order to rederive the private key, the key locator should\n\t// use the keychain.KeyFamilyTowerSession key family.\n\tKeyIndex uint32\n\n\t// Policy holds the negotiated session parameters.\n\tPolicy wtpolicy.Policy\n\n\t// Status indicates the current state of the ClientSession.\n\tStatus CSessionStatus\n\n\t// RewardPkScript is the pkscript that the tower's reward will be\n\t// deposited to if a sweep transaction confirms and the sessions\n\t// specifies a reward output.\n\tRewardPkScript []byte\n}\n\n// Encode writes a ClientSessionBody to the passed io.Writer.",
      "length": 1007,
      "tokens": 157,
      "embedding": []
    },
    {
      "slug": "func (s *ClientSessionBody) Encode(w io.Writer) error {",
      "content": "func (s *ClientSessionBody) Encode(w io.Writer) error {\n\treturn WriteElements(w,\n\t\ts.SeqNum,\n\t\ts.TowerLastApplied,\n\t\tuint64(s.TowerID),\n\t\ts.KeyIndex,\n\t\tuint8(s.Status),\n\t\ts.Policy,\n\t\ts.RewardPkScript,\n\t)\n}\n\n// Decode reads a ClientSessionBody from the passed io.Reader.",
      "length": 202,
      "tokens": 20,
      "embedding": []
    },
    {
      "slug": "func (s *ClientSessionBody) Decode(r io.Reader) error {",
      "content": "func (s *ClientSessionBody) Decode(r io.Reader) error {\n\tvar (\n\t\ttowerID uint64\n\t\tstatus  uint8\n\t)\n\terr := ReadElements(r,\n\t\t&s.SeqNum,\n\t\t&s.TowerLastApplied,\n\t\t&towerID,\n\t\t&s.KeyIndex,\n\t\t&status,\n\t\t&s.Policy,\n\t\t&s.RewardPkScript,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.TowerID = TowerID(towerID)\n\ts.Status = CSessionStatus(status)\n\n\treturn nil\n}\n\n// WriteElements serializes a variadic list of elements into the given\n// io.Writer.",
      "length": 353,
      "tokens": 48,
      "embedding": []
    },
    {
      "slug": "func WriteElements(w io.Writer, elements ...interface{}) error {",
      "content": "func WriteElements(w io.Writer, elements ...interface{}) error {\n\tfor _, element := range elements {\n\t\tif err := WriteElement(w, element); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// WriteElement serializes a single element into the provided io.Writer.",
      "length": 187,
      "tokens": 33,
      "embedding": []
    },
    {
      "slug": "func WriteElement(w io.Writer, element interface{}) error {",
      "content": "func WriteElement(w io.Writer, element interface{}) error {\n\terr := channeldb.WriteElement(w, element)\n\tswitch {\n\t// Known to channeldb codec.\n\tcase err == nil:\n\t\treturn nil\n\n\t// Fail if error is not UnknownElementType.\n\tdefault:\n\t\tif _, ok := err.(UnknownElementType); !ok {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Process any wtdb-specific extensions to the codec.\n\tswitch e := element.(type) {\n\tcase SessionID:\n\t\tif _, err := w.Write(e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase blob.BreachHint:\n\t\tif _, err := w.Write(e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase wtpolicy.Policy:\n\t\treturn channeldb.WriteElements(w,\n\t\t\tuint16(e.BlobType),\n\t\t\te.MaxUpdates,\n\t\t\te.RewardBase,\n\t\t\te.RewardRate,\n\t\t\tuint64(e.SweepFeeRate),\n\t\t)\n\n\t// Type is still unknown to wtdb extensions, fail.\n\tdefault:\n\t\treturn channeldb.NewUnknownElementType(\n\t\t\t\"WriteElement\", element,\n\t\t)\n\t}\n\n\treturn nil\n}\n\n// ReadElements deserializes the provided io.Reader into a variadic list of\n// target elements.",
      "length": 857,
      "tokens": 120,
      "embedding": []
    },
    {
      "slug": "func ReadElements(r io.Reader, elements ...interface{}) error {",
      "content": "func ReadElements(r io.Reader, elements ...interface{}) error {\n\tfor _, element := range elements {\n\t\tif err := ReadElement(r, element); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// ReadElement deserializes a single element from the provided io.Reader.",
      "length": 187,
      "tokens": 33,
      "embedding": []
    },
    {
      "slug": "func ReadElement(r io.Reader, element interface{}) error {",
      "content": "func ReadElement(r io.Reader, element interface{}) error {\n\terr := channeldb.ReadElement(r, element)\n\tswitch {\n\t// Known to channeldb codec.\n\tcase err == nil:\n\t\treturn nil\n\n\t// Fail if error is not UnknownElementType.\n\tdefault:\n\t\tif _, ok := err.(UnknownElementType); !ok {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Process any wtdb-specific extensions to the codec.\n\tswitch e := element.(type) {\n\tcase *SessionID:\n\t\tif _, err := io.ReadFull(r, e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *blob.BreachHint:\n\t\tif _, err := io.ReadFull(r, e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *wtpolicy.Policy:\n\t\tvar (\n\t\t\tblobType     uint16\n\t\t\tsweepFeeRate uint64\n\t\t)\n\t\terr := channeldb.ReadElements(r,\n\t\t\t&blobType,\n\t\t\t&e.MaxUpdates,\n\t\t\t&e.RewardBase,\n\t\t\t&e.RewardRate,\n\t\t\t&sweepFeeRate,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\te.BlobType = blob.Type(blobType)\n\t\te.SweepFeeRate = chainfee.SatPerKWeight(sweepFeeRate)\n\n\t// Type is still unknown to wtdb extensions, fail.\n\tdefault:\n\t\treturn channeldb.NewUnknownElementType(\n\t\t\t\"ReadElement\", element,\n\t\t)\n\t}\n\n\treturn nil\n}\n",
      "length": 938,
      "tokens": 130,
      "embedding": []
    }
  ]
}