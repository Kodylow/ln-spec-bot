{
  "filepath": "../implementations/go/lnd/watchtower/wtserver/server_test.go",
  "package": "wtserver_test",
  "sections": [
    {
      "slug": "func randPubKey(t *testing.T) *btcec.PublicKey {",
      "content": "func randPubKey(t *testing.T) *btcec.PublicKey {\n\tt.Helper()\n\n\tsk, err := btcec.NewPrivateKey()\n\trequire.NoError(t, err, \"unable to generate pubkey\")\n\n\treturn sk.PubKey()\n}\n\n// initServer creates and starts a new server using the server.DB and timeout.\n// If the provided database is nil, a mock db will be used.",
      "length": 254,
      "tokens": 40,
      "embedding": []
    },
    {
      "slug": "func initServer(t *testing.T, db wtserver.DB,",
      "content": "func initServer(t *testing.T, db wtserver.DB,\n\ttimeout time.Duration) wtserver.Interface {\n\n\tt.Helper()\n\n\tif db == nil {\n\t\tdb = wtmock.NewTowerDB()\n\t}\n\n\ts, err := wtserver.New(&wtserver.Config{\n\t\tDB:           db,\n\t\tReadTimeout:  timeout,\n\t\tWriteTimeout: timeout,\n\t\tNewAddress: func() (btcutil.Address, error) {\n\t\t\treturn addr, nil\n\t\t},\n\t\tChainHash: testnetChainHash,\n\t})\n\trequire.NoError(t, err, \"unable to create server\")\n\n\tif err = s.Start(); err != nil {\n\t\tt.Fatalf(\"unable to start server: %v\", err)\n\t}\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, s.Stop())\n\t})\n\n\treturn s\n}\n\n// TestServerOnlyAcceptOnePeer checks that the server will reject duplicate\n// peers with the same session id by disconnecting them. This is accomplished by\n// connecting two distinct peers with the same session id, and trying to send\n// messages on both connections. Since one should be rejected, we verify that\n// only one of the connections is able to send messages.",
      "length": 867,
      "tokens": 126,
      "embedding": []
    },
    {
      "slug": "func TestServerOnlyAcceptOnePeer(t *testing.T) {",
      "content": "func TestServerOnlyAcceptOnePeer(t *testing.T) {\n\tt.Parallel()\n\n\tconst timeoutDuration = 500 * time.Millisecond\n\n\ts := initServer(t, nil, timeoutDuration)\n\n\tlocalPub := randPubKey(t)\n\n\t// Create two peers using the same session id.\n\tpeerPub := randPubKey(t)\n\tpeer1 := wtmock.NewMockPeer(localPub, peerPub, nil, 0)\n\tpeer2 := wtmock.NewMockPeer(localPub, peerPub, nil, 0)\n\n\t// Serialize a Init message to be sent by both peers.\n\tinit := wtwire.NewInitMessage(\n\t\tlnwire.NewRawFeatureVector(), testnetChainHash,\n\t)\n\n\tvar b bytes.Buffer\n\t_, err := wtwire.WriteMessage(&b, init, 0)\n\trequire.NoError(t, err, \"unable to write message\")\n\n\tmsg := b.Bytes()\n\n\t// Connect both peers to the server simultaneously.\n\ts.InboundPeerConnected(peer1)\n\ts.InboundPeerConnected(peer2)\n\n\t// Use a timeout of twice the server's timeouts, to ensure the server\n\t// has time to process the messages.\n\ttimeout := time.After(2 * timeoutDuration)\n\n\t// Try to send a message on either peer, and record the opposite peer as\n\t// the one we assume to be rejected.\n\tvar (\n\t\trejectedPeer *wtmock.MockPeer\n\t\tacceptedPeer *wtmock.MockPeer\n\t)\n\tselect {\n\tcase peer1.IncomingMsgs <- msg:\n\t\tacceptedPeer = peer1\n\t\trejectedPeer = peer2\n\tcase peer2.IncomingMsgs <- msg:\n\t\tacceptedPeer = peer2\n\t\trejectedPeer = peer1\n\tcase <-timeout:\n\t\tt.Fatalf(\"unable to send message via either peer\")\n\t}\n\n\t// Try again to send a message, this time only via the assumed-rejected\n\t// peer. We expect our conservative timeout to expire, as the server\n\t// isn't reading from this peer. Before the timeout, the accepted peer\n\t// should also receive a reply to its Init message.\n\tselect {\n\tcase <-acceptedPeer.OutgoingMsgs:\n\t\tselect {\n\t\tcase rejectedPeer.IncomingMsgs <- msg:\n\t\t\tt.Fatalf(\"rejected peer should not have received message\")\n\t\tcase <-timeout:\n\t\t\t// Accepted peer got reply, rejected peer go nothing.\n\t\t}\n\tcase rejectedPeer.IncomingMsgs <- msg:\n\t\tt.Fatalf(\"rejected peer should not have received message\")\n\tcase <-timeout:\n\t\tt.Fatalf(\"accepted peer should have received init message\")\n\t}\n}\n",
      "length": 1921,
      "tokens": 269,
      "embedding": []
    },
    {
      "slug": "type createSessionTestCase struct {",
      "content": "type createSessionTestCase struct {\n\tname            string\n\tinitMsg         *wtwire.Init\n\tcreateMsg       *wtwire.CreateSession\n\texpReply        *wtwire.CreateSessionReply\n\texpDupReply     *wtwire.CreateSessionReply\n\tsendStateUpdate bool\n}\n\nvar createSessionTests = []createSessionTestCase{\n\t{\n\t\tname: \"duplicate session create altruist anchor commit\",\n\t\tinitMsg: wtwire.NewInitMessage(\n\t\t\tlnwire.NewRawFeatureVector(),\n\t\t\ttestnetChainHash,\n\t\t),\n\t\tcreateMsg: &wtwire.CreateSession{\n\t\t\tBlobType:     blob.TypeAltruistAnchorCommit,\n\t\t\tMaxUpdates:   1000,\n\t\t\tRewardBase:   0,\n\t\t\tRewardRate:   0,\n\t\t\tSweepFeeRate: 10000,\n\t\t},\n\t\texpReply: &wtwire.CreateSessionReply{\n\t\t\tCode: wtwire.CodeOK,\n\t\t\tData: []byte{},\n\t\t},\n\t\texpDupReply: &wtwire.CreateSessionReply{\n\t\t\tCode: wtwire.CodeOK,\n\t\t\tData: []byte{},\n\t\t},\n\t},\n\t{\n\t\tname: \"duplicate session create\",\n\t\tinitMsg: wtwire.NewInitMessage(\n\t\t\tlnwire.NewRawFeatureVector(),\n\t\t\ttestnetChainHash,\n\t\t),\n\t\tcreateMsg: &wtwire.CreateSession{\n\t\t\tBlobType:     blob.TypeAltruistCommit,\n\t\t\tMaxUpdates:   1000,\n\t\t\tRewardBase:   0,\n\t\t\tRewardRate:   0,\n\t\t\tSweepFeeRate: 10000,\n\t\t},\n\t\texpReply: &wtwire.CreateSessionReply{\n\t\t\tCode: wtwire.CodeOK,\n\t\t\tData: []byte{},\n\t\t},\n\t\texpDupReply: &wtwire.CreateSessionReply{\n\t\t\tCode: wtwire.CodeOK,\n\t\t\tData: []byte{},\n\t\t},\n\t},\n\t{\n\t\tname: \"duplicate session create after use\",\n\t\tinitMsg: wtwire.NewInitMessage(\n\t\t\tlnwire.NewRawFeatureVector(),\n\t\t\ttestnetChainHash,\n\t\t),\n\t\tcreateMsg: &wtwire.CreateSession{\n\t\t\tBlobType:     blob.TypeAltruistCommit,\n\t\t\tMaxUpdates:   1000,\n\t\t\tRewardBase:   0,\n\t\t\tRewardRate:   0,\n\t\t\tSweepFeeRate: 10000,\n\t\t},\n\t\texpReply: &wtwire.CreateSessionReply{\n\t\t\tCode: wtwire.CodeOK,\n\t\t\tData: []byte{},\n\t\t},\n\t\texpDupReply: &wtwire.CreateSessionReply{\n\t\t\tCode:        wtwire.CreateSessionCodeAlreadyExists,\n\t\t\tLastApplied: 1,\n\t\t\tData:        []byte{},\n\t\t},\n\t\tsendStateUpdate: true,\n\t},\n\t{\n\t\tname: \"duplicate session create reward\",\n\t\tinitMsg: wtwire.NewInitMessage(\n\t\t\tlnwire.NewRawFeatureVector(),\n\t\t\ttestnetChainHash,\n\t\t),\n\t\tcreateMsg: &wtwire.CreateSession{\n\t\t\tBlobType:     blob.TypeRewardCommit,\n\t\t\tMaxUpdates:   1000,\n\t\t\tRewardBase:   0,\n\t\t\tRewardRate:   0,\n\t\t\tSweepFeeRate: 10000,\n\t\t},\n\t\texpReply: &wtwire.CreateSessionReply{\n\t\t\tCode: wtwire.CodeOK,\n\t\t\tData: addrScript,\n\t\t},\n\t\texpDupReply: &wtwire.CreateSessionReply{\n\t\t\tCode: wtwire.CodeOK,\n\t\t\tData: addrScript,\n\t\t},\n\t},\n\t{\n\t\tname: \"reject unsupported blob type\",\n\t\tinitMsg: wtwire.NewInitMessage(\n\t\t\tlnwire.NewRawFeatureVector(),\n\t\t\ttestnetChainHash,\n\t\t),\n\t\tcreateMsg: &wtwire.CreateSession{\n\t\t\tBlobType:     0,\n\t\t\tMaxUpdates:   1000,\n\t\t\tRewardBase:   0,\n\t\t\tRewardRate:   0,\n\t\t\tSweepFeeRate: 10000,\n\t\t},\n\t\texpReply: &wtwire.CreateSessionReply{\n\t\t\tCode: wtwire.CreateSessionCodeRejectBlobType,\n\t\t\tData: []byte{},\n\t\t},\n\t},\n\t// TODO(conner): add policy rejection tests\n}\n\n// TestServerCreateSession checks the server's behavior in response to a\n// table-driven set of CreateSession messages.",
      "length": 2773,
      "tokens": 234,
      "embedding": []
    },
    {
      "slug": "func TestServerCreateSession(t *testing.T) {",
      "content": "func TestServerCreateSession(t *testing.T) {\n\tt.Parallel()\n\n\tfor i, test := range createSessionTests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\ttestServerCreateSession(t, i, test)\n\t\t})\n\t}\n}\n",
      "length": 139,
      "tokens": 18,
      "embedding": []
    },
    {
      "slug": "func testServerCreateSession(t *testing.T, i int, test createSessionTestCase) {",
      "content": "func testServerCreateSession(t *testing.T, i int, test createSessionTestCase) {\n\tconst timeoutDuration = 500 * time.Millisecond\n\n\ts := initServer(t, nil, timeoutDuration)\n\n\tlocalPub := randPubKey(t)\n\n\t// Create a new client and connect to server.\n\tpeerPub := randPubKey(t)\n\tpeer := wtmock.NewMockPeer(localPub, peerPub, nil, 0)\n\tconnect(t, s, peer, test.initMsg, timeoutDuration)\n\n\t// Send the CreateSession message, and wait for a reply.\n\tsendMsg(t, test.createMsg, peer, timeoutDuration)\n\n\treply := recvReply(\n\t\tt, \"MsgCreateSessionReply\", peer, timeoutDuration,\n\t).(*wtwire.CreateSessionReply)\n\n\t// Verify that the server's response matches our expectation.\n\tif !reflect.DeepEqual(reply, test.expReply) {\n\t\tt.Fatalf(\"[test %d] expected reply %v, got %d\",\n\t\t\ti, test.expReply, reply)\n\t}\n\n\t// Assert that the server closes the connection after processing the\n\t// CreateSession.\n\tassertConnClosed(t, peer, 2*timeoutDuration)\n\n\t// If this test did not request sending a duplicate CreateSession, we can\n\t// continue to the next test.\n\tif test.expDupReply == nil {\n\t\treturn\n\t}\n\n\tif test.sendStateUpdate {\n\t\tpeer = wtmock.NewMockPeer(localPub, peerPub, nil, 0)\n\t\tconnect(t, s, peer, test.initMsg, timeoutDuration)\n\t\tupdate := &wtwire.StateUpdate{\n\t\t\tSeqNum:        1,\n\t\t\tIsComplete:    1,\n\t\t\tEncryptedBlob: testBlob,\n\t\t}\n\t\tsendMsg(t, update, peer, timeoutDuration)\n\n\t\tassertConnClosed(t, peer, 2*timeoutDuration)\n\t}\n\n\t// Simulate a peer with the same session id connection to the server\n\t// again.\n\tpeer = wtmock.NewMockPeer(localPub, peerPub, nil, 0)\n\tconnect(t, s, peer, test.initMsg, timeoutDuration)\n\n\t// Send the _same_ CreateSession message as the first attempt.\n\tsendMsg(t, test.createMsg, peer, timeoutDuration)\n\n\treply = recvReply(\n\t\tt, \"MsgCreateSessionReply\", peer, timeoutDuration,\n\t).(*wtwire.CreateSessionReply)\n\n\t// Ensure that the server's reply matches our expected response for a\n\t// duplicate send.\n\tif !reflect.DeepEqual(reply, test.expDupReply) {\n\t\tt.Fatalf(\"[test %d] expected reply %v, got %v\",\n\t\t\ti, test.expDupReply, reply)\n\t}\n\n\t// Finally, check that the server tore down the connection.\n\tassertConnClosed(t, peer, 2*timeoutDuration)\n}\n",
      "length": 2009,
      "tokens": 249,
      "embedding": []
    },
    {
      "slug": "type stateUpdateTestCase struct {",
      "content": "type stateUpdateTestCase struct {\n\tname      string\n\tinitMsg   *wtwire.Init\n\tcreateMsg *wtwire.CreateSession\n\tupdates   []*wtwire.StateUpdate\n\treplies   []*wtwire.StateUpdateReply\n}\n\nvar stateUpdateTests = []stateUpdateTestCase{\n\t// Valid update sequence, send seqnum == lastapplied as last update.\n\t{\n\t\tname: \"perm fail after sending seqnum equal lastapplied\",\n\t\tinitMsg: wtwire.NewInitMessage(\n\t\t\tlnwire.NewRawFeatureVector(),\n\t\t\ttestnetChainHash,\n\t\t),\n\t\tcreateMsg: &wtwire.CreateSession{\n\t\t\tBlobType:     blob.TypeAltruistCommit,\n\t\t\tMaxUpdates:   3,\n\t\t\tRewardBase:   0,\n\t\t\tRewardRate:   0,\n\t\t\tSweepFeeRate: 10000,\n\t\t},\n\t\tupdates: []*wtwire.StateUpdate{\n\t\t\t{SeqNum: 1, LastApplied: 0, EncryptedBlob: testBlob},\n\t\t\t{SeqNum: 2, LastApplied: 1, EncryptedBlob: testBlob},\n\t\t\t{SeqNum: 3, LastApplied: 2, EncryptedBlob: testBlob},\n\t\t\t{SeqNum: 3, LastApplied: 3, EncryptedBlob: testBlob},\n\t\t},\n\t\treplies: []*wtwire.StateUpdateReply{\n\t\t\t{Code: wtwire.CodeOK, LastApplied: 1},\n\t\t\t{Code: wtwire.CodeOK, LastApplied: 2},\n\t\t\t{Code: wtwire.CodeOK, LastApplied: 3},\n\t\t\t{\n\t\t\t\tCode:        wtwire.CodePermanentFailure,\n\t\t\t\tLastApplied: 3,\n\t\t\t},\n\t\t},\n\t},\n\t// Send update that skips next expected sequence number.\n\t{\n\t\tname: \"skip sequence number\",\n\t\tinitMsg: wtwire.NewInitMessage(\n\t\t\tlnwire.NewRawFeatureVector(),\n\t\t\ttestnetChainHash,\n\t\t),\n\t\tcreateMsg: &wtwire.CreateSession{\n\t\t\tBlobType:     blob.TypeAltruistCommit,\n\t\t\tMaxUpdates:   4,\n\t\t\tRewardBase:   0,\n\t\t\tRewardRate:   0,\n\t\t\tSweepFeeRate: 10000,\n\t\t},\n\t\tupdates: []*wtwire.StateUpdate{\n\t\t\t{SeqNum: 2, LastApplied: 0, EncryptedBlob: testBlob},\n\t\t},\n\t\treplies: []*wtwire.StateUpdateReply{\n\t\t\t{\n\t\t\t\tCode:        wtwire.StateUpdateCodeSeqNumOutOfOrder,\n\t\t\t\tLastApplied: 0,\n\t\t\t},\n\t\t},\n\t},\n\t// Send update that reverts to older sequence number.\n\t{\n\t\tname: \"revert to older seqnum\",\n\t\tinitMsg: wtwire.NewInitMessage(\n\t\t\tlnwire.NewRawFeatureVector(),\n\t\t\ttestnetChainHash,\n\t\t),\n\t\tcreateMsg: &wtwire.CreateSession{\n\t\t\tBlobType:     blob.TypeAltruistCommit,\n\t\t\tMaxUpdates:   4,\n\t\t\tRewardBase:   0,\n\t\t\tRewardRate:   0,\n\t\t\tSweepFeeRate: 10000,\n\t\t},\n\t\tupdates: []*wtwire.StateUpdate{\n\t\t\t{SeqNum: 1, LastApplied: 0, EncryptedBlob: testBlob},\n\t\t\t{SeqNum: 2, LastApplied: 0, EncryptedBlob: testBlob},\n\t\t\t{SeqNum: 1, LastApplied: 0, EncryptedBlob: testBlob},\n\t\t},\n\t\treplies: []*wtwire.StateUpdateReply{\n\t\t\t{Code: wtwire.CodeOK, LastApplied: 1},\n\t\t\t{Code: wtwire.CodeOK, LastApplied: 2},\n\t\t\t{\n\t\t\t\tCode:        wtwire.StateUpdateCodeSeqNumOutOfOrder,\n\t\t\t\tLastApplied: 2,\n\t\t\t},\n\t\t},\n\t},\n\t// Send update echoing a last applied that is lower than previous value.\n\t{\n\t\tname: \"revert to older lastapplied\",\n\t\tinitMsg: wtwire.NewInitMessage(\n\t\t\tlnwire.NewRawFeatureVector(),\n\t\t\ttestnetChainHash,\n\t\t),\n\t\tcreateMsg: &wtwire.CreateSession{\n\t\t\tBlobType:     blob.TypeAltruistCommit,\n\t\t\tMaxUpdates:   4,\n\t\t\tRewardBase:   0,\n\t\t\tRewardRate:   0,\n\t\t\tSweepFeeRate: 10000,\n\t\t},\n\t\tupdates: []*wtwire.StateUpdate{\n\t\t\t{SeqNum: 1, LastApplied: 0, EncryptedBlob: testBlob},\n\t\t\t{SeqNum: 2, LastApplied: 1, EncryptedBlob: testBlob},\n\t\t\t{SeqNum: 3, LastApplied: 2, EncryptedBlob: testBlob},\n\t\t\t{SeqNum: 4, LastApplied: 1, EncryptedBlob: testBlob},\n\t\t},\n\t\treplies: []*wtwire.StateUpdateReply{\n\t\t\t{Code: wtwire.CodeOK, LastApplied: 1},\n\t\t\t{Code: wtwire.CodeOK, LastApplied: 2},\n\t\t\t{Code: wtwire.CodeOK, LastApplied: 3},\n\t\t\t{Code: wtwire.StateUpdateCodeClientBehind, LastApplied: 3},\n\t\t},\n\t},\n\t// Valid update sequence with disconnection, ensure resumes resume.\n\t// Client echos last applied as they are received.\n\t{\n\t\tname: \"resume after disconnect\",\n\t\tinitMsg: wtwire.NewInitMessage(\n\t\t\tlnwire.NewRawFeatureVector(),\n\t\t\ttestnetChainHash,\n\t\t),\n\t\tcreateMsg: &wtwire.CreateSession{\n\t\t\tBlobType:     blob.TypeAltruistCommit,\n\t\t\tMaxUpdates:   4,\n\t\t\tRewardBase:   0,\n\t\t\tRewardRate:   0,\n\t\t\tSweepFeeRate: 10000,\n\t\t},\n\t\tupdates: []*wtwire.StateUpdate{\n\t\t\t{SeqNum: 1, LastApplied: 0, EncryptedBlob: testBlob},\n\t\t\t{SeqNum: 2, LastApplied: 1, EncryptedBlob: testBlob},\n\t\t\tnil, // Wait for read timeout to drop conn, then reconnect.\n\t\t\t{SeqNum: 3, LastApplied: 2, EncryptedBlob: testBlob},\n\t\t\t{SeqNum: 4, LastApplied: 3, EncryptedBlob: testBlob},\n\t\t},\n\t\treplies: []*wtwire.StateUpdateReply{\n\t\t\t{Code: wtwire.CodeOK, LastApplied: 1},\n\t\t\t{Code: wtwire.CodeOK, LastApplied: 2},\n\t\t\tnil,\n\t\t\t{Code: wtwire.CodeOK, LastApplied: 3},\n\t\t\t{Code: wtwire.CodeOK, LastApplied: 4},\n\t\t},\n\t},\n\t// Valid update sequence with disconnection, resume next update. Client\n\t// doesn't echo last applied until last message.\n\t{\n\t\tname: \"resume after disconnect lagging lastapplied\",\n\t\tinitMsg: wtwire.NewInitMessage(\n\t\t\tlnwire.NewRawFeatureVector(),\n\t\t\ttestnetChainHash,\n\t\t),\n\t\tcreateMsg: &wtwire.CreateSession{\n\t\t\tBlobType:     blob.TypeAltruistCommit,\n\t\t\tMaxUpdates:   4,\n\t\t\tRewardBase:   0,\n\t\t\tRewardRate:   0,\n\t\t\tSweepFeeRate: 10000,\n\t\t},\n\t\tupdates: []*wtwire.StateUpdate{\n\t\t\t{SeqNum: 1, LastApplied: 0, EncryptedBlob: testBlob},\n\t\t\t{SeqNum: 2, LastApplied: 0, EncryptedBlob: testBlob},\n\t\t\tnil, // Wait for read timeout to drop conn, then reconnect.\n\t\t\t{SeqNum: 3, LastApplied: 0, EncryptedBlob: testBlob},\n\t\t\t{SeqNum: 4, LastApplied: 3, EncryptedBlob: testBlob},\n\t\t},\n\t\treplies: []*wtwire.StateUpdateReply{\n\t\t\t{Code: wtwire.CodeOK, LastApplied: 1},\n\t\t\t{Code: wtwire.CodeOK, LastApplied: 2},\n\t\t\tnil,\n\t\t\t{Code: wtwire.CodeOK, LastApplied: 3},\n\t\t\t{Code: wtwire.CodeOK, LastApplied: 4},\n\t\t},\n\t},\n\t// Valid update sequence with disconnection, resume last update.  Client\n\t// doesn't echo last applied until last message.\n\t{\n\t\tname: \"resume after disconnect lagging lastapplied\",\n\t\tinitMsg: wtwire.NewInitMessage(\n\t\t\tlnwire.NewRawFeatureVector(),\n\t\t\ttestnetChainHash,\n\t\t),\n\t\tcreateMsg: &wtwire.CreateSession{\n\t\t\tBlobType:     blob.TypeAltruistCommit,\n\t\t\tMaxUpdates:   4,\n\t\t\tRewardBase:   0,\n\t\t\tRewardRate:   0,\n\t\t\tSweepFeeRate: 10000,\n\t\t},\n\t\tupdates: []*wtwire.StateUpdate{\n\t\t\t{SeqNum: 1, LastApplied: 0, EncryptedBlob: testBlob},\n\t\t\t{SeqNum: 2, LastApplied: 0, EncryptedBlob: testBlob},\n\t\t\tnil, // Wait for read timeout to drop conn, then reconnect.\n\t\t\t{SeqNum: 2, LastApplied: 0, EncryptedBlob: testBlob},\n\t\t\t{SeqNum: 3, LastApplied: 0, EncryptedBlob: testBlob},\n\t\t\t{SeqNum: 4, LastApplied: 3, EncryptedBlob: testBlob},\n\t\t},\n\t\treplies: []*wtwire.StateUpdateReply{\n\t\t\t{Code: wtwire.CodeOK, LastApplied: 1},\n\t\t\t{Code: wtwire.CodeOK, LastApplied: 2},\n\t\t\tnil,\n\t\t\t{Code: wtwire.CodeOK, LastApplied: 2},\n\t\t\t{Code: wtwire.CodeOK, LastApplied: 3},\n\t\t\t{Code: wtwire.CodeOK, LastApplied: 4},\n\t\t},\n\t},\n\t// Send update with sequence number that exceeds MaxUpdates.\n\t{\n\t\tname: \"seqnum exceed maxupdates\",\n\t\tinitMsg: wtwire.NewInitMessage(\n\t\t\tlnwire.NewRawFeatureVector(),\n\t\t\ttestnetChainHash,\n\t\t),\n\t\tcreateMsg: &wtwire.CreateSession{\n\t\t\tBlobType:     blob.TypeAltruistCommit,\n\t\t\tMaxUpdates:   3,\n\t\t\tRewardBase:   0,\n\t\t\tRewardRate:   0,\n\t\t\tSweepFeeRate: 10000,\n\t\t},\n\t\tupdates: []*wtwire.StateUpdate{\n\t\t\t{SeqNum: 1, LastApplied: 0, EncryptedBlob: testBlob},\n\t\t\t{SeqNum: 2, LastApplied: 1, EncryptedBlob: testBlob},\n\t\t\t{SeqNum: 3, LastApplied: 2, EncryptedBlob: testBlob},\n\t\t\t{SeqNum: 4, LastApplied: 3, EncryptedBlob: testBlob},\n\t\t},\n\t\treplies: []*wtwire.StateUpdateReply{\n\t\t\t{Code: wtwire.CodeOK, LastApplied: 1},\n\t\t\t{Code: wtwire.CodeOK, LastApplied: 2},\n\t\t\t{Code: wtwire.CodeOK, LastApplied: 3},\n\t\t\t{\n\t\t\t\tCode:        wtwire.StateUpdateCodeMaxUpdatesExceeded,\n\t\t\t\tLastApplied: 3,\n\t\t\t},\n\t\t},\n\t},\n\t// Ensure sequence number 0 causes permanent failure.\n\t{\n\t\tname: \"perm fail after seqnum 0\",\n\t\tinitMsg: wtwire.NewInitMessage(\n\t\t\tlnwire.NewRawFeatureVector(),\n\t\t\ttestnetChainHash,\n\t\t),\n\t\tcreateMsg: &wtwire.CreateSession{\n\t\t\tBlobType:     blob.TypeAltruistCommit,\n\t\t\tMaxUpdates:   3,\n\t\t\tRewardBase:   0,\n\t\t\tRewardRate:   0,\n\t\t\tSweepFeeRate: 10000,\n\t\t},\n\t\tupdates: []*wtwire.StateUpdate{\n\t\t\t{SeqNum: 0, LastApplied: 0, EncryptedBlob: testBlob},\n\t\t},\n\t\treplies: []*wtwire.StateUpdateReply{\n\t\t\t{\n\t\t\t\tCode:        wtwire.CodePermanentFailure,\n\t\t\t\tLastApplied: 0,\n\t\t\t},\n\t\t},\n\t},\n}\n\n// TestServerStateUpdates tests the behavior of the server in response to\n// watchtower clients sending StateUpdate messages, after having already\n// established an open session. The test asserts that the server responds\n// with the appropriate failure codes in a number of failure conditions where\n// the server and client desynchronize. It also checks the ability of the client\n// to disconnect, connect, and continue updating from the last successful state\n// update.",
      "length": 8085,
      "tokens": 830,
      "embedding": []
    },
    {
      "slug": "func TestServerStateUpdates(t *testing.T) {",
      "content": "func TestServerStateUpdates(t *testing.T) {\n\tt.Parallel()\n\n\tfor _, test := range stateUpdateTests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\ttestServerStateUpdates(t, test)\n\t\t})\n\t}\n}\n",
      "length": 133,
      "tokens": 17,
      "embedding": []
    },
    {
      "slug": "func testServerStateUpdates(t *testing.T, test stateUpdateTestCase) {",
      "content": "func testServerStateUpdates(t *testing.T, test stateUpdateTestCase) {\n\tconst timeoutDuration = 100 * time.Millisecond\n\n\ts := initServer(t, nil, timeoutDuration)\n\n\tlocalPub := randPubKey(t)\n\n\t// Create a new client and connect to the server.\n\tpeerPub := randPubKey(t)\n\tpeer := wtmock.NewMockPeer(localPub, peerPub, nil, 0)\n\tconnect(t, s, peer, test.initMsg, timeoutDuration)\n\n\t// Register a session for this client to use in the subsequent tests.\n\tsendMsg(t, test.createMsg, peer, timeoutDuration)\n\tinitReply := recvReply(\n\t\tt, \"MsgCreateSessionReply\", peer, timeoutDuration,\n\t).(*wtwire.CreateSessionReply)\n\n\t// Fail if the server rejected our proposed CreateSession message.\n\tif initReply.Code != wtwire.CodeOK {\n\t\tt.Fatalf(\"server rejected session init\")\n\t}\n\n\t// Check that the server closed the connection used to register the\n\t// session.\n\tassertConnClosed(t, peer, 2*timeoutDuration)\n\n\t// Now that the original connection has been closed, connect a new\n\t// client with the same session id.\n\tpeer = wtmock.NewMockPeer(localPub, peerPub, nil, 0)\n\tconnect(t, s, peer, test.initMsg, timeoutDuration)\n\n\t// Send the intended StateUpdate messages in series.\n\tfor j, update := range test.updates {\n\t\t// A nil update signals that we should wait for the prior\n\t\t// connection to die, before re-register with the same session\n\t\t// identifier.\n\t\tif update == nil {\n\t\t\tassertConnClosed(t, peer, 2*timeoutDuration)\n\n\t\t\tpeer = wtmock.NewMockPeer(localPub, peerPub, nil, 0)\n\t\t\tconnect(t, s, peer, test.initMsg, timeoutDuration)\n\n\t\t\tcontinue\n\t\t}\n\n\t\t// Send the state update and verify it against our expected\n\t\t// response.\n\t\tsendMsg(t, update, peer, timeoutDuration)\n\t\treply := recvReply(\n\t\t\tt, \"MsgStateUpdateReply\", peer, timeoutDuration,\n\t\t).(*wtwire.StateUpdateReply)\n\n\t\tif !reflect.DeepEqual(reply, test.replies[j]) {\n\t\t\tt.Fatalf(\"[update %d] expected reply \"+\n\t\t\t\t\"%v, got %d\", j,\n\t\t\t\ttest.replies[j], reply)\n\t\t}\n\t}\n\n\t// Check that the final connection is properly cleaned up by the server.\n\tassertConnClosed(t, peer, 2*timeoutDuration)\n}\n\n// TestServerDeleteSession asserts the response to a DeleteSession request, and\n// checking that the proper error is returned when the session doesn't exist and\n// that a successful deletion does not disrupt other sessions.",
      "length": 2123,
      "tokens": 283,
      "embedding": []
    },
    {
      "slug": "func TestServerDeleteSession(t *testing.T) {",
      "content": "func TestServerDeleteSession(t *testing.T) {\n\tdb := wtmock.NewTowerDB()\n\n\tlocalPub := randPubKey(t)\n\n\t// Initialize two distinct peers with different session ids.\n\tpeerPub1 := randPubKey(t)\n\tpeerPub2 := randPubKey(t)\n\n\tid1 := wtdb.NewSessionIDFromPubKey(peerPub1)\n\tid2 := wtdb.NewSessionIDFromPubKey(peerPub2)\n\n\t// Create closure to simplify assertions on session existence with the\n\t// server's database.\n\thasSession := func(t *testing.T, id *wtdb.SessionID, shouldHave bool) {\n\t\tt.Helper()\n\n\t\t_, err := db.GetSessionInfo(id)\n\t\tswitch {\n\t\tcase shouldHave && err != nil:\n\t\t\tt.Fatalf(\"expected server to have session %s, got: %v\",\n\t\t\t\tid, err)\n\t\tcase !shouldHave && err != wtdb.ErrSessionNotFound:\n\t\t\tt.Fatalf(\"expected ErrSessionNotFound for session %s, \"+\n\t\t\t\t\"got: %v\", id, err)\n\t\t}\n\t}\n\n\tinitMsg := wtwire.NewInitMessage(\n\t\tlnwire.NewRawFeatureVector(),\n\t\ttestnetChainHash,\n\t)\n\n\tcreateSession := &wtwire.CreateSession{\n\t\tBlobType:     blob.TypeAltruistCommit,\n\t\tMaxUpdates:   1000,\n\t\tRewardBase:   0,\n\t\tRewardRate:   0,\n\t\tSweepFeeRate: 10000,\n\t}\n\n\tconst timeoutDuration = 100 * time.Millisecond\n\n\ts := initServer(t, db, timeoutDuration)\n\n\t// Create a session for peer2 so that the server's db isn't completely\n\t// empty.\n\tpeer2 := wtmock.NewMockPeer(localPub, peerPub2, nil, 0)\n\tconnect(t, s, peer2, initMsg, timeoutDuration)\n\tsendMsg(t, createSession, peer2, timeoutDuration)\n\tassertConnClosed(t, peer2, 2*timeoutDuration)\n\n\t// Our initial assertions are that peer2 has a valid session, but peer1\n\t// has not created one.\n\thasSession(t, &id1, false)\n\thasSession(t, &id2, true)\n\n\tpeer1Msgs := []struct {\n\t\tsend   wtwire.Message\n\t\trecv   wtwire.Message\n\t\tassert func(t *testing.T)\n\t}{\n\t\t{\n\t\t\t// Deleting unknown session should fail.\n\t\t\tsend: &wtwire.DeleteSession{},\n\t\t\trecv: &wtwire.DeleteSessionReply{\n\t\t\t\tCode: wtwire.DeleteSessionCodeNotFound,\n\t\t\t},\n\t\t\tassert: func(t *testing.T) {\n\t\t\t\t// Peer2 should still be only session.\n\t\t\t\thasSession(t, &id1, false)\n\t\t\t\thasSession(t, &id2, true)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t// Create session for peer1.\n\t\t\tsend: createSession,\n\t\t\trecv: &wtwire.CreateSessionReply{\n\t\t\t\tCode: wtwire.CodeOK,\n\t\t\t\tData: []byte{},\n\t\t\t},\n\t\t\tassert: func(t *testing.T) {\n\t\t\t\t// Both peers should have sessions.\n\t\t\t\thasSession(t, &id1, true)\n\t\t\t\thasSession(t, &id2, true)\n\t\t\t},\n\t\t},\n\n\t\t{\n\t\t\t// Delete peer1's session.\n\t\t\tsend: &wtwire.DeleteSession{},\n\t\t\trecv: &wtwire.DeleteSessionReply{\n\t\t\t\tCode: wtwire.CodeOK,\n\t\t\t},\n\t\t\tassert: func(t *testing.T) {\n\t\t\t\t// Peer1's session should have been removed.\n\t\t\t\thasSession(t, &id1, false)\n\t\t\t\thasSession(t, &id2, true)\n\t\t\t},\n\t\t},\n\t}\n\n\t// Now as peer1, process the canned messages defined above. This will:\n\t// 1. Try to delete an unknown session and get a not found error code.\n\t// 2. Create a new session using the same parameters as peer2.\n\t// 3. Delete the newly created session and get an OK.\n\tfor _, msg := range peer1Msgs {\n\t\tpeer1 := wtmock.NewMockPeer(localPub, peerPub1, nil, 0)\n\t\tconnect(t, s, peer1, initMsg, timeoutDuration)\n\t\tsendMsg(t, msg.send, peer1, timeoutDuration)\n\t\treply := recvReply(\n\t\t\tt, msg.recv.MsgType().String(), peer1, timeoutDuration,\n\t\t)\n\n\t\tif !reflect.DeepEqual(reply, msg.recv) {\n\t\t\tt.Fatalf(\"expected reply: %v, got: %v\", msg.recv, reply)\n\t\t}\n\n\t\tassertConnClosed(t, peer1, 2*timeoutDuration)\n\n\t\t// Invoke assertions after completing the request/response\n\t\t// dance.\n\t\tmsg.assert(t)\n\t}\n}\n",
      "length": 3205,
      "tokens": 396,
      "embedding": []
    },
    {
      "slug": "func connect(t *testing.T, s wtserver.Interface, peer *wtmock.MockPeer,",
      "content": "func connect(t *testing.T, s wtserver.Interface, peer *wtmock.MockPeer,\n\tinitMsg *wtwire.Init, timeout time.Duration) {\n\n\tt.Helper()\n\n\ts.InboundPeerConnected(peer)\n\tsendMsg(t, initMsg, peer, timeout)\n\trecvReply(t, \"MsgInit\", peer, timeout)\n}\n\n// sendMsg sends a wtwire.Message message via a wtmock.MockPeer.",
      "length": 226,
      "tokens": 25,
      "embedding": []
    },
    {
      "slug": "func sendMsg(t *testing.T, msg wtwire.Message,",
      "content": "func sendMsg(t *testing.T, msg wtwire.Message,\n\tpeer *wtmock.MockPeer, timeout time.Duration) {\n\n\tt.Helper()\n\n\tvar b bytes.Buffer\n\t_, err := wtwire.WriteMessage(&b, msg, 0)\n\tif err != nil {\n\t\tt.Fatalf(\"unable to encode %T message: %v\",\n\t\t\tmsg, err)\n\t}\n\n\tselect {\n\tcase peer.IncomingMsgs <- b.Bytes():\n\tcase <-time.After(2 * timeout):\n\t\tt.Fatalf(\"unable to send %T message\", msg)\n\t}\n}\n\n// recvReply receives a message from the server, and parses it according to\n// expected reply type. The supported replies are CreateSessionReply and\n// StateUpdateReply.",
      "length": 487,
      "tokens": 72,
      "embedding": []
    },
    {
      "slug": "func recvReply(t *testing.T, name string, peer *wtmock.MockPeer,",
      "content": "func recvReply(t *testing.T, name string, peer *wtmock.MockPeer,\n\ttimeout time.Duration) wtwire.Message {\n\n\tt.Helper()\n\n\tvar (\n\t\tmsg wtwire.Message\n\t\terr error\n\t)\n\n\tselect {\n\tcase b := <-peer.OutgoingMsgs:\n\t\tmsg, err = wtwire.ReadMessage(bytes.NewReader(b), 0)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to decode server \"+\n\t\t\t\t\"reply: %v\", err)\n\t\t}\n\n\tcase <-time.After(2 * timeout):\n\t\tt.Fatalf(\"server did not reply\")\n\t}\n\n\tswitch name {\n\tcase \"MsgInit\":\n\t\tif _, ok := msg.(*wtwire.Init); !ok {\n\t\t\tt.Fatalf(\"expected %s reply message, \"+\n\t\t\t\t\"got %T\", name, msg)\n\t\t}\n\tcase \"MsgCreateSessionReply\":\n\t\tif _, ok := msg.(*wtwire.CreateSessionReply); !ok {\n\t\t\tt.Fatalf(\"expected %s reply message, \"+\n\t\t\t\t\"got %T\", name, msg)\n\t\t}\n\tcase \"MsgStateUpdateReply\":\n\t\tif _, ok := msg.(*wtwire.StateUpdateReply); !ok {\n\t\t\tt.Fatalf(\"expected %s reply message, \"+\n\t\t\t\t\"got %T\", name, msg)\n\t\t}\n\tcase \"MsgDeleteSessionReply\":\n\t\tif _, ok := msg.(*wtwire.DeleteSessionReply); !ok {\n\t\t\tt.Fatalf(\"expected %s reply message, \"+\n\t\t\t\t\"got %T\", name, msg)\n\t\t}\n\t}\n\n\treturn msg\n}\n\n// assertConnClosed checks that the peer's connection is closed before the\n// timeout expires.",
      "length": 1029,
      "tokens": 143,
      "embedding": []
    },
    {
      "slug": "func assertConnClosed(t *testing.T, peer *wtmock.MockPeer, duration time.Duration) {",
      "content": "func assertConnClosed(t *testing.T, peer *wtmock.MockPeer, duration time.Duration) {\n\tt.Helper()\n\n\tselect {\n\tcase <-peer.Quit:\n\tcase <-time.After(duration):\n\t\tt.Fatalf(\"expected connection to be closed\")\n\t}\n}\n",
      "length": 116,
      "tokens": 14,
      "embedding": []
    }
  ]
}