{
  "filepath": "../implementations/go/lnd/watchtower/wtserver/create_session.go",
  "package": "wtserver",
  "sections": [
    {
      "slug": "func (s *Server) handleCreateSession(peer Peer, id *wtdb.SessionID,",
      "content": "func (s *Server) handleCreateSession(peer Peer, id *wtdb.SessionID,\n\treq *wtwire.CreateSession) error {\n\n\t// TODO(conner): validate accept against policy\n\n\t// Query the db for session info belonging to the client's session id.\n\texistingInfo, err := s.cfg.DB.GetSessionInfo(id)\n\tswitch {\n\n\t// We already have a session, though it is currently unused. We'll allow\n\t// the client to recommit the session if it wanted to change the policy.\n\tcase err == nil && existingInfo.LastApplied == 0:\n\n\t// We already have a session corresponding to this session id, return an\n\t// error signaling that it already exists in our database. We return the\n\t// reward address to the client in case they were not able to process\n\t// our reply earlier.\n\tcase err == nil && existingInfo.LastApplied > 0:\n\t\tlog.Debugf(\"Already have session for %s\", id)\n\t\treturn s.replyCreateSession(\n\t\t\tpeer, id, wtwire.CreateSessionCodeAlreadyExists,\n\t\t\texistingInfo.LastApplied, existingInfo.RewardAddress,\n\t\t)\n\n\t// Some other database error occurred, return a temporary failure.\n\tcase err != wtdb.ErrSessionNotFound:\n\t\tlog.Errorf(\"unable to load session info for %s\", id)\n\t\treturn s.replyCreateSession(\n\t\t\tpeer, id, wtwire.CodeTemporaryFailure, 0, nil,\n\t\t)\n\t}\n\n\t// Ensure that the requested blob type is supported by our tower.\n\tif !blob.IsSupportedType(req.BlobType) {\n\t\tlog.Debugf(\"Rejecting CreateSession from %s, unsupported blob \"+\n\t\t\t\"type %s\", id, req.BlobType)\n\t\treturn s.replyCreateSession(\n\t\t\tpeer, id, wtwire.CreateSessionCodeRejectBlobType, 0,\n\t\t\tnil,\n\t\t)\n\t}\n\n\t// If the request asks for a reward session and the tower has them\n\t// disabled, we will reject the request.\n\tif s.cfg.DisableReward && req.BlobType.Has(blob.FlagReward) {\n\t\tlog.Debugf(\"Rejecting CreateSession from %s, reward \"+\n\t\t\t\"sessions disabled\", id)\n\t\treturn s.replyCreateSession(\n\t\t\tpeer, id, wtwire.CreateSessionCodeRejectBlobType, 0,\n\t\t\tnil,\n\t\t)\n\t}\n\n\t// Now that we've established that this session does not exist in the\n\t// database, retrieve the sweep address that will be given to the\n\t// client. This address is to be included by the client when signing\n\t// sweep transactions destined for this tower, if its negotiated output\n\t// is not dust.\n\tvar rewardScript []byte\n\tif req.BlobType.Has(blob.FlagReward) {\n\t\trewardAddress, err := s.cfg.NewAddress()\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Unable to generate reward addr for %s: %v\",\n\t\t\t\tid, err)\n\t\t\treturn s.replyCreateSession(\n\t\t\t\tpeer, id, wtwire.CodeTemporaryFailure, 0, nil,\n\t\t\t)\n\t\t}\n\n\t\t// Construct the pkscript the client should pay to when signing\n\t\t// justice transactions for this session.\n\t\trewardScript, err = txscript.PayToAddrScript(rewardAddress)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Unable to generate reward script for \"+\n\t\t\t\t\"%s: %v\", id, err)\n\t\t\treturn s.replyCreateSession(\n\t\t\t\tpeer, id, wtwire.CodeTemporaryFailure, 0, nil,\n\t\t\t)\n\t\t}\n\t}\n\n\t// TODO(conner): create invoice for upfront payment\n\n\t// Assemble the session info using the agreed upon parameters, reward\n\t// address, and session id.\n\tinfo := wtdb.SessionInfo{\n\t\tID: *id,\n\t\tPolicy: wtpolicy.Policy{\n\t\t\tTxPolicy: wtpolicy.TxPolicy{\n\t\t\t\tBlobType:     req.BlobType,\n\t\t\t\tRewardBase:   req.RewardBase,\n\t\t\t\tRewardRate:   req.RewardRate,\n\t\t\t\tSweepFeeRate: req.SweepFeeRate,\n\t\t\t},\n\t\t\tMaxUpdates: req.MaxUpdates,\n\t\t},\n\t\tRewardAddress: rewardScript,\n\t}\n\n\t// Insert the session info into the watchtower's database. If\n\t// successful, the session will now be ready for use.\n\terr = s.cfg.DB.InsertSessionInfo(&info)\n\tif err != nil {\n\t\tlog.Errorf(\"Unable to create session for %s: %v\", id, err)\n\t\treturn s.replyCreateSession(\n\t\t\tpeer, id, wtwire.CodeTemporaryFailure, 0, nil,\n\t\t)\n\t}\n\n\tlog.Infof(\"Accepted session for %s\", id)\n\n\treturn s.replyCreateSession(\n\t\tpeer, id, wtwire.CodeOK, 0, rewardScript,\n\t)\n}\n\n// replyCreateSession sends a response to a CreateSession from a client. If the\n// status code in the reply is OK, the error from the write will be bubbled up.\n// Otherwise, this method returns a connection error to ensure we don't continue\n// communication with the client.",
      "length": 3849,
      "tokens": 529,
      "embedding": []
    },
    {
      "slug": "func (s *Server) replyCreateSession(peer Peer, id *wtdb.SessionID,",
      "content": "func (s *Server) replyCreateSession(peer Peer, id *wtdb.SessionID,\n\tcode wtwire.ErrorCode, lastApplied uint16, data []byte) error {\n\n\tif s.cfg.NoAckCreateSession {\n\t\treturn &connFailure{\n\t\t\tID:   *id,\n\t\t\tCode: code,\n\t\t}\n\t}\n\n\tmsg := &wtwire.CreateSessionReply{\n\t\tCode:        code,\n\t\tLastApplied: lastApplied,\n\t\tData:        data,\n\t}\n\n\terr := s.sendMessage(peer, msg)\n\tif err != nil {\n\t\tlog.Errorf(\"unable to send CreateSessionReply to %s\", id)\n\t}\n\n\t// Return the write error if the request succeeded.\n\tif code == wtwire.CodeOK {\n\t\treturn err\n\t}\n\n\t// Otherwise the request failed, return a connection failure to\n\t// disconnect the client.\n\treturn &connFailure{\n\t\tID:   *id,\n\t\tCode: code,\n\t}\n}\n",
      "length": 593,
      "tokens": 85,
      "embedding": []
    }
  ]
}