{
  "filepath": "../implementations/go/lnd/watchtower/lookout/justice_descriptor_test.go",
  "package": "lookout_test",
  "sections": [
    {
      "slug": "func TestJusticeDescriptor(t *testing.T) {",
      "content": "func TestJusticeDescriptor(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tblobType blob.Type\n\t}{\n\t\t{\n\t\t\tname:     \"reward and commit type\",\n\t\t\tblobType: rewardCommitType,\n\t\t},\n\t\t{\n\t\t\tname:     \"altruist and commit type\",\n\t\t\tblobType: altruistCommitType,\n\t\t},\n\t\t{\n\t\t\tname:     \"altruist anchor commit type\",\n\t\t\tblobType: altruistAnchorCommitType,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\ttestJusticeDescriptor(t, test.blobType)\n\t\t})\n\t}\n}\n",
      "length": 421,
      "tokens": 53,
      "embedding": []
    },
    {
      "slug": "func testJusticeDescriptor(t *testing.T, blobType blob.Type) {",
      "content": "func testJusticeDescriptor(t *testing.T, blobType blob.Type) {\n\tisAnchorChannel := blobType.IsAnchorChannel()\n\n\tconst (\n\t\tlocalAmount  = btcutil.Amount(100000)\n\t\tremoteAmount = btcutil.Amount(200000)\n\t\ttotalAmount  = localAmount + remoteAmount\n\t)\n\n\t// Parse the key pairs for all keys used in the test.\n\trevSK, revPK := btcec.PrivKeyFromBytes(\n\t\trevPrivBytes,\n\t)\n\t_, toLocalPK := btcec.PrivKeyFromBytes(\n\t\ttoLocalPrivBytes,\n\t)\n\ttoRemoteSK, toRemotePK := btcec.PrivKeyFromBytes(\n\t\ttoRemotePrivBytes,\n\t)\n\n\t// Create the signer, and add the revocation and to-remote privkeys.\n\tsigner := wtmock.NewMockSigner()\n\tvar (\n\t\trevKeyLoc      = signer.AddPrivKey(revSK)\n\t\ttoRemoteKeyLoc = signer.AddPrivKey(toRemoteSK)\n\t)\n\n\t// Construct the to-local witness script.\n\ttoLocalScript, err := input.CommitScriptToSelf(\n\t\tcsvDelay, toLocalPK, revPK,\n\t)\n\trequire.Nil(t, err)\n\n\t// Compute the to-local witness script hash.\n\ttoLocalScriptHash, err := input.WitnessScriptHash(toLocalScript)\n\trequire.Nil(t, err)\n\n\t// Compute the to-remote redeem script, witness script hash, and\n\t// sequence numbers.\n\t//\n\t// NOTE: This is pretty subtle.\n\t//\n\t// The actual redeem script for a p2wkh output is just the pubkey, but\n\t// the witness sighash calculation injects the classic p2kh script:\n\t// OP_DUP OP_HASH160 <pubkey-hash160> OP_EQUALVERIFY OP_CHECKSIG. When\n\t// signing for p2wkh we don't pass the raw pubkey as the witness script\n\t// to the sign descriptor (since that's also not a valid script).\n\t// Instead we give it the _pkscript_ of the form OP_0 <pubkey-hash160>\n\t// from which pubkey-hash160 is extracted during sighash calculation.\n\t//\n\t// On the other hand, signing for the anchor p2wsh to-remote outputs\n\t// requires the sign descriptor to contain the redeem script ver batim.\n\t// This difference in behavior forces us to use a distinct\n\t// toRemoteSigningScript to handle both cases.\n\tvar (\n\t\ttoRemoteSequence      uint32\n\t\ttoRemoteRedeemScript  []byte\n\t\ttoRemoteScriptHash    []byte\n\t\ttoRemoteSigningScript []byte\n\t)\n\tif isAnchorChannel {\n\t\ttoRemoteSequence = 1\n\t\ttoRemoteRedeemScript, err = input.CommitScriptToRemoteConfirmed(\n\t\t\ttoRemotePK,\n\t\t)\n\t\trequire.Nil(t, err)\n\n\t\ttoRemoteScriptHash, err = input.WitnessScriptHash(\n\t\t\ttoRemoteRedeemScript,\n\t\t)\n\t\trequire.Nil(t, err)\n\n\t\t// As it should be.\n\t\ttoRemoteSigningScript = toRemoteRedeemScript\n\t} else {\n\t\ttoRemoteRedeemScript = toRemotePK.SerializeCompressed()\n\t\ttoRemoteScriptHash, err = input.CommitScriptUnencumbered(\n\t\t\ttoRemotePK,\n\t\t)\n\t\trequire.Nil(t, err)\n\n\t\t// NOTE: This is the _pkscript_.\n\t\ttoRemoteSigningScript = toRemoteScriptHash\n\t}\n\n\t// Construct the breaching commitment txn, containing the to-local and\n\t// to-remote outputs. We don't need any inputs for this test.\n\tbreachTxn := &wire.MsgTx{\n\t\tVersion: 2,\n\t\tTxIn:    []*wire.TxIn{},\n\t\tTxOut: []*wire.TxOut{\n\t\t\t{\n\t\t\t\tValue:    int64(localAmount),\n\t\t\t\tPkScript: toLocalScriptHash,\n\t\t\t},\n\t\t\t{\n\t\t\t\tValue:    int64(remoteAmount),\n\t\t\t\tPkScript: toRemoteScriptHash,\n\t\t\t},\n\t\t},\n\t}\n\tbreachTxID := breachTxn.TxHash()\n\n\t// Compute the weight estimate for our justice transaction.\n\tvar weightEstimate input.TxWeightEstimator\n\n\t// An older ToLocalPenaltyWitnessSize constant used to underestimate the\n\t// size by one byte. The diferrence in weight can cause different output\n\t// values on the sweep transaction, so we mimic the original bug and\n\t// create signatures using the original weight estimate. For anchor\n\t// channels we fix this and use the correct witness size.\n\tif isAnchorChannel {\n\t\tweightEstimate.AddWitnessInput(input.ToLocalPenaltyWitnessSize)\n\t} else {\n\t\tweightEstimate.AddWitnessInput(input.ToLocalPenaltyWitnessSize - 1)\n\t}\n\n\tif isAnchorChannel {\n\t\tweightEstimate.AddWitnessInput(input.ToRemoteConfirmedWitnessSize)\n\t} else {\n\t\tweightEstimate.AddWitnessInput(input.P2WKHWitnessSize)\n\t}\n\tweightEstimate.AddP2WKHOutput()\n\tif blobType.Has(blob.FlagReward) {\n\t\tweightEstimate.AddP2WKHOutput()\n\t}\n\ttxWeight := weightEstimate.Weight()\n\n\t// Create a session info so that simulate agreement of the sweep\n\t// parameters that should be used in constructing the justice\n\t// transaction.\n\tpolicy := wtpolicy.Policy{\n\t\tTxPolicy: wtpolicy.TxPolicy{\n\t\t\tBlobType:     blobType,\n\t\t\tSweepFeeRate: 2000,\n\t\t\tRewardRate:   900000,\n\t\t},\n\t}\n\tsessionInfo := &wtdb.SessionInfo{\n\t\tPolicy:        policy,\n\t\tRewardAddress: makeAddrSlice(22),\n\t}\n\n\t// Begin to assemble the justice kit, starting with the sweep address,\n\t// pubkeys, and csv delay.\n\tjusticeKit := &blob.JusticeKit{\n\t\tBlobType:     blobType,\n\t\tSweepAddress: makeAddrSlice(22),\n\t\tCSVDelay:     csvDelay,\n\t}\n\tcopy(justiceKit.RevocationPubKey[:], revPK.SerializeCompressed())\n\tcopy(justiceKit.LocalDelayPubKey[:], toLocalPK.SerializeCompressed())\n\tcopy(justiceKit.CommitToRemotePubKey[:], toRemotePK.SerializeCompressed())\n\n\t// Create a transaction spending from the outputs of the breach\n\t// transaction created earlier. The inputs are always ordered w/\n\t// to-local and then to-remote. The outputs are always added as the\n\t// sweep address then reward address.\n\tjusticeTxn := &wire.MsgTx{\n\t\tVersion: 2,\n\t\tTxIn: []*wire.TxIn{\n\t\t\t{\n\t\t\t\tPreviousOutPoint: wire.OutPoint{\n\t\t\t\t\tHash:  breachTxID,\n\t\t\t\t\tIndex: 0,\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tPreviousOutPoint: wire.OutPoint{\n\t\t\t\t\tHash:  breachTxID,\n\t\t\t\t\tIndex: 1,\n\t\t\t\t},\n\t\t\t\tSequence: toRemoteSequence,\n\t\t\t},\n\t\t},\n\t}\n\n\toutputs, err := policy.ComputeJusticeTxOuts(\n\t\ttotalAmount, int64(txWeight), justiceKit.SweepAddress,\n\t\tsessionInfo.RewardAddress,\n\t)\n\trequire.Nil(t, err)\n\n\t// Attach the txouts and BIP69 sort the resulting transaction.\n\tjusticeTxn.TxOut = outputs\n\ttxsort.InPlaceSort(justiceTxn)\n\n\thashCache := input.NewTxSigHashesV0Only(justiceTxn)\n\n\t// Create the sign descriptor used to sign for the to-local input.\n\ttoLocalSignDesc := &input.SignDescriptor{\n\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\tKeyLocator: revKeyLoc,\n\t\t},\n\t\tWitnessScript: toLocalScript,\n\t\tOutput:        breachTxn.TxOut[0],\n\t\tSigHashes:     hashCache,\n\t\tInputIndex:    0,\n\t\tHashType:      txscript.SigHashAll,\n\t}\n\n\t// Create the sign descriptor used to sign for the to-remote input.\n\ttoRemoteSignDesc := &input.SignDescriptor{\n\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\tKeyLocator: toRemoteKeyLoc,\n\t\t\tPubKey:     toRemotePK,\n\t\t},\n\t\tWitnessScript: toRemoteSigningScript,\n\t\tOutput:        breachTxn.TxOut[1],\n\t\tSigHashes:     hashCache,\n\t\tInputIndex:    1,\n\t\tHashType:      txscript.SigHashAll,\n\t}\n\n\t// Verify that our test justice transaction is sane.\n\tbtx := btcutil.NewTx(justiceTxn)\n\terr = blockchain.CheckTransactionSanity(btx)\n\trequire.Nil(t, err)\n\n\t// Compute a DER-encoded signature for the to-local input.\n\ttoLocalSigRaw, err := signer.SignOutputRaw(justiceTxn, toLocalSignDesc)\n\trequire.Nil(t, err)\n\n\t// Compute the witness for the to-remote input. The first element is a\n\t// DER-encoded signature under the to-remote pubkey. The sighash flag is\n\t// also present, so we trim it.\n\ttoRemoteSigRaw, err := signer.SignOutputRaw(justiceTxn, toRemoteSignDesc)\n\trequire.Nil(t, err)\n\n\t// Convert the DER to-local sig into a fixed-size signature.\n\ttoLocalSig, err := lnwire.NewSigFromSignature(toLocalSigRaw)\n\trequire.Nil(t, err)\n\n\t// Convert the DER to-remote sig into a fixed-size signature.\n\ttoRemoteSig, err := lnwire.NewSigFromSignature(toRemoteSigRaw)\n\trequire.Nil(t, err)\n\n\t// Complete our justice kit by copying the signatures into the payload.\n\tcopy(justiceKit.CommitToLocalSig[:], toLocalSig[:])\n\tcopy(justiceKit.CommitToRemoteSig[:], toRemoteSig[:])\n\n\tjusticeDesc := &lookout.JusticeDescriptor{\n\t\tBreachedCommitTx: breachTxn,\n\t\tSessionInfo:      sessionInfo,\n\t\tJusticeKit:       justiceKit,\n\t}\n\n\t// Construct a breach punisher that will feed published transactions\n\t// over the buffered channel.\n\tpublications := make(chan *wire.MsgTx, 1)\n\tpunisher := lookout.NewBreachPunisher(&lookout.PunisherConfig{\n\t\tPublishTx: func(tx *wire.MsgTx, _ string) error {\n\t\t\tpublications <- tx\n\t\t\treturn nil\n\t\t},\n\t})\n\n\t// Exact retribution on the offender. If no error is returned, we expect\n\t// the justice transaction to be published via the channel.\n\terr = punisher.Punish(justiceDesc, nil)\n\trequire.Nil(t, err)\n\n\t// Retrieve the published justice transaction.\n\tvar wtJusticeTxn *wire.MsgTx\n\tselect {\n\tcase wtJusticeTxn = <-publications:\n\tcase <-time.After(50 * time.Millisecond):\n\t\tt.Fatalf(\"punisher did not publish justice txn\")\n\t}\n\n\t// Construct the test's to-local witness.\n\tjusticeTxn.TxIn[0].Witness = make([][]byte, 3)\n\tjusticeTxn.TxIn[0].Witness[0] = append(toLocalSigRaw.Serialize(),\n\t\tbyte(txscript.SigHashAll))\n\tjusticeTxn.TxIn[0].Witness[1] = []byte{1}\n\tjusticeTxn.TxIn[0].Witness[2] = toLocalScript\n\n\t// Construct the test's to-remote witness.\n\tjusticeTxn.TxIn[1].Witness = make([][]byte, 2)\n\tjusticeTxn.TxIn[1].Witness[0] = append(toRemoteSigRaw.Serialize(),\n\t\tbyte(txscript.SigHashAll))\n\tjusticeTxn.TxIn[1].Witness[1] = toRemoteRedeemScript\n\n\t// Assert that the watchtower derives the same justice txn.\n\trequire.Equal(t, justiceTxn, wtJusticeTxn)\n}\n",
      "length": 8569,
      "tokens": 959,
      "embedding": []
    }
  ]
}