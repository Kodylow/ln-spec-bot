{
  "filepath": "../implementations/go/lnd/netann/host_ann_test.go",
  "package": "netann",
  "sections": [
    {
      "slug": "func TestHostAnnouncerUpdates(t *testing.T) {",
      "content": "func TestHostAnnouncerUpdates(t *testing.T) {\n\tt.Parallel()\n\n\thosts := []string{\"test.com\", \"example.com\"}\n\tstartingAddrs := []net.Addr{\n\t\t&net.TCPAddr{\n\t\t\tIP: net.ParseIP(\"1.1.1.1\"),\n\t\t},\n\t\t&net.TCPAddr{\n\t\t\tIP: net.ParseIP(\"8.8.8.8\"),\n\t\t},\n\t}\n\n\tticker := ticker.NewForce(time.Hour * 24)\n\n\ttestTimeout := time.Millisecond * 200\n\n\ttype annReq struct {\n\t\tnewAddrs     []net.Addr\n\t\tremovedAddrs map[string]struct{}\n\t}\n\n\ttestCases := []struct {\n\t\tpreAdvertisedIPs map[string]struct{}\n\t\tstartingAddrs    []net.Addr\n\n\t\tpreTickHosts  map[string]net.Addr\n\t\tpostTickHosts map[string]net.Addr\n\n\t\tupdateTriggered bool\n\n\t\tnewAddrs     []net.Addr\n\t\tremovedAddrs map[string]struct{}\n\t}{\n\t\t// The set of addresses are the same before and after a tick we\n\t\t// expect no change.\n\t\t{\n\t\t\tpreTickHosts: map[string]net.Addr{\n\t\t\t\t\"test.com\": &net.TCPAddr{\n\t\t\t\t\tIP: net.ParseIP(\"1.1.1.1\"),\n\t\t\t\t},\n\t\t\t\t\"example.com\": &net.TCPAddr{\n\t\t\t\t\tIP: net.ParseIP(\"8.8.8.8\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tstartingAddrs: startingAddrs,\n\n\t\t\tpostTickHosts: map[string]net.Addr{\n\t\t\t\t\"test.com\": &net.TCPAddr{\n\t\t\t\t\tIP: net.ParseIP(\"1.1.1.1\"),\n\t\t\t\t},\n\t\t\t\t\"example.com\": &net.TCPAddr{\n\t\t\t\t\tIP: net.ParseIP(\"8.8.8.8\"),\n\t\t\t\t},\n\t\t\t},\n\n\t\t\tupdateTriggered: false,\n\t\t},\n\n\t\t// Half of the addresses are changed out, the new one should be\n\t\t// added with the old one forgotten.\n\t\t{\n\t\t\tpreTickHosts: map[string]net.Addr{\n\t\t\t\t\"test.com\": &net.TCPAddr{\n\t\t\t\t\tIP: net.ParseIP(\"1.1.1.1\"),\n\t\t\t\t},\n\t\t\t\t\"example.com\": &net.TCPAddr{\n\t\t\t\t\tIP: net.ParseIP(\"8.8.8.8\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tstartingAddrs: startingAddrs,\n\n\t\t\tpostTickHosts: map[string]net.Addr{\n\t\t\t\t\"test.com\": &net.TCPAddr{\n\t\t\t\t\tIP: net.ParseIP(\"1.1.1.1\"),\n\t\t\t\t},\n\t\t\t\t\"example.com\": &net.TCPAddr{\n\t\t\t\t\tIP: net.ParseIP(\"9.9.9.9\"),\n\t\t\t\t},\n\t\t\t},\n\n\t\t\tupdateTriggered: true,\n\t\t\tnewAddrs: []net.Addr{\n\t\t\t\t&net.TCPAddr{\n\t\t\t\t\tIP: net.ParseIP(\"9.9.9.9\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tremovedAddrs: map[string]struct{}{\n\t\t\t\t\"8.8.8.8:0\": {},\n\t\t\t},\n\t\t},\n\n\t\t// All addresses change, they should all be refreshed.\n\t\t{\n\t\t\tpreTickHosts: map[string]net.Addr{\n\t\t\t\t\"test.com\": &net.TCPAddr{\n\t\t\t\t\tIP: net.ParseIP(\"1.1.1.1\"),\n\t\t\t\t},\n\t\t\t\t\"example.com\": &net.TCPAddr{\n\t\t\t\t\tIP: net.ParseIP(\"8.8.8.8\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tstartingAddrs: startingAddrs,\n\n\t\t\tpostTickHosts: map[string]net.Addr{\n\t\t\t\t\"test.com\": &net.TCPAddr{\n\t\t\t\t\tIP: net.ParseIP(\"2.2.2.2\"),\n\t\t\t\t},\n\t\t\t\t\"example.com\": &net.TCPAddr{\n\t\t\t\t\tIP: net.ParseIP(\"9.9.9.9\"),\n\t\t\t\t},\n\t\t\t},\n\n\t\t\tupdateTriggered: true,\n\t\t\tnewAddrs: []net.Addr{\n\t\t\t\t&net.TCPAddr{\n\t\t\t\t\tIP: net.ParseIP(\"2.2.2.2\"),\n\t\t\t\t},\n\t\t\t\t&net.TCPAddr{\n\t\t\t\t\tIP: net.ParseIP(\"9.9.9.9\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tremovedAddrs: map[string]struct{}{\n\t\t\t\t\"8.8.8.8:0\": {},\n\t\t\t\t\"1.1.1.1:0\": {},\n\t\t\t},\n\t\t},\n\n\t\t// Two addresses, one has already been advertised on start up,\n\t\t// so we only expect one of them to be announced again. After\n\t\t// the tick we don't expect an update trigger since nothing.\n\t\t// changed.\n\t\t{\n\t\t\tpreAdvertisedIPs: map[string]struct{}{\n\t\t\t\t\"1.1.1.1:0\": {},\n\t\t\t},\n\t\t\tstartingAddrs: []net.Addr{\n\t\t\t\t&net.TCPAddr{\n\t\t\t\t\tIP: net.ParseIP(\"8.8.8.8\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tpreTickHosts: map[string]net.Addr{\n\t\t\t\t\"test.com\": &net.TCPAddr{\n\t\t\t\t\tIP: net.ParseIP(\"1.1.1.1\"),\n\t\t\t\t},\n\t\t\t\t\"example.com\": &net.TCPAddr{\n\t\t\t\t\tIP: net.ParseIP(\"8.8.8.8\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tpostTickHosts: map[string]net.Addr{\n\t\t\t\t\"test.com\": &net.TCPAddr{\n\t\t\t\t\tIP: net.ParseIP(\"1.1.1.1\"),\n\t\t\t\t},\n\t\t\t\t\"example.com\": &net.TCPAddr{\n\t\t\t\t\tIP: net.ParseIP(\"8.8.8.8\"),\n\t\t\t\t},\n\t\t\t},\n\n\t\t\tupdateTriggered: false,\n\t\t},\n\t}\n\tfor idx, testCase := range testCases {\n\t\thostResps := make(chan net.Addr)\n\t\tannReqs := make(chan annReq)\n\t\thostAnncer := NewHostAnnouncer(HostAnnouncerConfig{\n\t\t\tHosts:         hosts,\n\t\t\tAdvertisedIPs: testCase.preAdvertisedIPs,\n\t\t\tRefreshTicker: ticker,\n\t\t\tLookupHost: func(str string) (net.Addr, error) {\n\t\t\t\treturn <-hostResps, nil\n\t\t\t},\n\t\t\tAnnounceNewIPs: func(newAddrs []net.Addr,\n\t\t\t\tremoveAddrs map[string]struct{}) error {\n\n\t\t\t\tannReqs <- annReq{\n\t\t\t\t\tnewAddrs:     newAddrs,\n\t\t\t\t\tremovedAddrs: removeAddrs,\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t},\n\t\t})\n\t\tif err := hostAnncer.Start(); err != nil {\n\t\t\tt.Fatalf(\"unable to start announcer: %v\", err)\n\t\t}\n\n\t\t// As soon as the announcer starts, it'll try to query for the\n\t\t// state of the hosts. We'll return the preTick state for all\n\t\t// hosts.\n\t\tfor i := 0; i < len(hosts); i++ {\n\t\t\thostResps <- testCase.preTickHosts[hosts[i]]\n\t\t}\n\n\t\t// Since this is the first time the announcer is starting up,\n\t\t// we expect it to advertise the hosts as they exist before any\n\t\t// updates.\n\t\tselect {\n\t\tcase addrUpdate := <-annReqs:\n\t\t\tassert.Equal(\n\t\t\t\tt, testCase.startingAddrs, addrUpdate.newAddrs,\n\t\t\t\t\"addresses should match\",\n\t\t\t)\n\t\t\tassert.Empty(\n\t\t\t\tt, addrUpdate.removedAddrs,\n\t\t\t\t\"removed addrs should match\",\n\t\t\t)\n\n\t\tcase <-time.After(testTimeout):\n\t\t\tt.Fatalf(\"#%v: no addr update sent\", idx)\n\t\t}\n\n\t\t// We'll now force a tick which'll force another query. This\n\t\t// time we'll respond with the set of the hosts as they should\n\t\t// be post-tick.\n\t\tticker.Force <- time.Time{}\n\n\t\tfor i := 0; i < len(hosts); i++ {\n\t\t\thostResps <- testCase.postTickHosts[hosts[i]]\n\t\t}\n\n\t\t// If we expect an update, then we'll assert that we received\n\t\t// the proper set of modified addresses.\n\t\tif testCase.updateTriggered {\n\t\t\tselect {\n\t\t\t// The receive update should match exactly what the\n\t\t\t// test case dictates.\n\t\t\tcase addrUpdate := <-annReqs:\n\t\t\t\trequire.Equal(\n\t\t\t\t\tt, testCase.newAddrs, addrUpdate.newAddrs,\n\t\t\t\t\t\"addresses should match\",\n\t\t\t\t)\n\n\t\t\t\trequire.Equal(\n\t\t\t\t\tt, testCase.removedAddrs, addrUpdate.removedAddrs,\n\t\t\t\t\t\"removed addrs should match\",\n\t\t\t\t)\n\n\t\t\tcase <-time.After(testTimeout):\n\t\t\t\tt.Fatalf(\"#%v: no addr update set\", idx)\n\t\t\t}\n\n\t\t\tif err := hostAnncer.Stop(); err != nil {\n\t\t\t\tt.Fatalf(\"unable to stop announcer: %v\", err)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\t// Otherwise, no updates should be sent since nothing changed.\n\t\tselect {\n\t\tcase <-annReqs:\n\t\t\tt.Fatalf(\"#%v: expected no call to AnnounceNewIPs\", idx)\n\n\t\tcase <-time.After(testTimeout):\n\t\t}\n\n\t\tif err := hostAnncer.Stop(); err != nil {\n\t\t\tt.Fatalf(\"unable to stop announcer: %v\", err)\n\t\t}\n\t}\n}\n",
      "length": 5727,
      "tokens": 642,
      "embedding": []
    }
  ]
}