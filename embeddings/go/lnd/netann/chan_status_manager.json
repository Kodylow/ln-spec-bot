{
  "filepath": "../implementations/go/lnd/netann/chan_status_manager.go",
  "package": "netann",
  "sections": [
    {
      "slug": "type ChanStatusConfig struct {",
      "content": "type ChanStatusConfig struct {\n\t// OurPubKey is the public key identifying this node on the network.\n\tOurPubKey *btcec.PublicKey\n\n\t// OurKeyLoc is the locator for the public key identifying this node on\n\t// the network.\n\tOurKeyLoc keychain.KeyLocator\n\n\t// MessageSigner signs messages that validate under OurPubKey.\n\tMessageSigner lnwallet.MessageSigner\n\n\t// IsChannelActive checks whether the channel identified by the provided\n\t// ChannelID is considered active. This should only return true if the\n\t// channel has been sufficiently confirmed, the channel has received\n\t// FundingLocked, and the remote peer is online.\n\tIsChannelActive func(lnwire.ChannelID) bool\n\n\t// ApplyChannelUpdate processes new ChannelUpdates signed by our node by\n\t// updating our local routing table and broadcasting the update to our\n\t// peers.\n\tApplyChannelUpdate func(*lnwire.ChannelUpdate, *wire.OutPoint,\n\t\tbool) error\n\n\t// DB stores the set of channels that are to be monitored.\n\tDB DB\n\n\t// Graph stores the channel info and policies for channels in DB.\n\tGraph ChannelGraph\n\n\t// ChanEnableTimeout is the duration a peer's connect must remain stable\n\t// before attempting to re-enable the channel.\n\t//\n\t// NOTE: This value is only used to verify that the relation between\n\t// itself, ChanDisableTimeout, and ChanStatusSampleInterval is correct.\n\t// The user is still responsible for ensuring that the same duration\n\t// elapses before attempting to re-enable a channel.\n\tChanEnableTimeout time.Duration\n\n\t// ChanDisableTimeout is the duration the manager will wait after\n\t// detecting that a channel has become inactive before broadcasting an\n\t// update to disable the channel.\n\tChanDisableTimeout time.Duration\n\n\t// ChanStatusSampleInterval is the long-polling interval used by the\n\t// manager to check if the channels being monitored have become\n\t// inactive.\n\tChanStatusSampleInterval time.Duration\n}\n\n// ChanStatusManager facilitates requests to enable or disable a channel via a\n// network announcement that sets the disable bit on the ChannelUpdate\n// accordingly. The manager will periodically sample to detect cases where a\n// link has become inactive, and facilitate the process of disabling the channel\n// passively. The ChanStatusManager state machine is designed to reduce the\n// likelihood of spamming the network with updates for flapping peers.",
      "length": 2257,
      "tokens": 327,
      "embedding": []
    },
    {
      "slug": "type ChanStatusManager struct {",
      "content": "type ChanStatusManager struct {\n\tstarted sync.Once\n\tstopped sync.Once\n\n\tcfg *ChanStatusConfig\n\n\t// ourPubKeyBytes is the serialized compressed pubkey of our node.\n\tourPubKeyBytes []byte\n\n\t// chanStates contains the set of channels being monitored for status\n\t// updates. Access to the map is serialized by the statusManager's event\n\t// loop.\n\tchanStates channelStates\n\n\t// enableRequests pipes external requests to enable a channel into the\n\t// primary event loop.\n\tenableRequests chan statusRequest\n\n\t// disableRequests pipes external requests to disable a channel into the\n\t// primary event loop.\n\tdisableRequests chan statusRequest\n\n\t// autoRequests pipes external requests to restore automatic channel\n\t// state management into the primary event loop.\n\tautoRequests chan statusRequest\n\n\t// statusSampleTicker fires at the interval prescribed by\n\t// ChanStatusSampleInterval to check if channels in chanStates have\n\t// become inactive.\n\tstatusSampleTicker *time.Ticker\n\n\twg   sync.WaitGroup\n\tquit chan struct{}\n}\n\n// NewChanStatusManager initializes a new ChanStatusManager using the given\n// configuration. An error is returned if the timeouts and sample interval fail\n// to meet do not satisfy the equation:\n//\n//\tChanEnableTimeout + ChanStatusSampleInterval > ChanDisableTimeout.",
      "length": 1215,
      "tokens": 166,
      "embedding": []
    },
    {
      "slug": "func NewChanStatusManager(cfg *ChanStatusConfig) (*ChanStatusManager, error) {",
      "content": "func NewChanStatusManager(cfg *ChanStatusConfig) (*ChanStatusManager, error) {\n\t// Assert that the config timeouts are properly formed. We require the\n\t// enable_timeout + sample_interval to be less than or equal to the\n\t// disable_timeout and that all are positive values. A peer that\n\t// disconnects and reconnects quickly may cause a disable update to be\n\t// sent, shortly followed by a re-enable. Ensuring a healthy separation\n\t// helps dampen the possibility of spamming updates that toggle the\n\t// disable bit for such events.\n\tif cfg.ChanStatusSampleInterval <= 0 {\n\t\treturn nil, ErrInvalidTimeoutConstraints\n\t}\n\tif cfg.ChanEnableTimeout <= 0 {\n\t\treturn nil, ErrInvalidTimeoutConstraints\n\t}\n\tif cfg.ChanDisableTimeout <= 0 {\n\t\treturn nil, ErrInvalidTimeoutConstraints\n\t}\n\tif cfg.ChanEnableTimeout+cfg.ChanStatusSampleInterval >\n\t\tcfg.ChanDisableTimeout {\n\t\treturn nil, ErrInvalidTimeoutConstraints\n\n\t}\n\n\treturn &ChanStatusManager{\n\t\tcfg:                cfg,\n\t\tourPubKeyBytes:     cfg.OurPubKey.SerializeCompressed(),\n\t\tchanStates:         make(channelStates),\n\t\tstatusSampleTicker: time.NewTicker(cfg.ChanStatusSampleInterval),\n\t\tenableRequests:     make(chan statusRequest),\n\t\tdisableRequests:    make(chan statusRequest),\n\t\tautoRequests:       make(chan statusRequest),\n\t\tquit:               make(chan struct{}),\n\t}, nil\n}\n\n// Start safely starts the ChanStatusManager.",
      "length": 1265,
      "tokens": 142,
      "embedding": []
    },
    {
      "slug": "func (m *ChanStatusManager) Start() error {",
      "content": "func (m *ChanStatusManager) Start() error {\n\tvar err error\n\tm.started.Do(func() {\n\t\tlog.Info(\"Channel Status Manager starting\")\n\t\terr = m.start()\n\t})\n\treturn err\n}\n",
      "length": 113,
      "tokens": 16,
      "embedding": []
    },
    {
      "slug": "func (m *ChanStatusManager) start() error {",
      "content": "func (m *ChanStatusManager) start() error {\n\tchannels, err := m.fetchChannels()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Populate the initial states of all confirmed, public channels.\n\tfor _, c := range channels {\n\t\t_, err := m.getOrInitChanStatus(c.FundingOutpoint)\n\t\tswitch {\n\n\t\t// If we can't retrieve the edge info for this channel, it may\n\t\t// have been pruned from the channel graph but not yet from our\n\t\t// set of channels. We'll skip it as we can't determine its\n\t\t// initial state.\n\t\tcase err == channeldb.ErrEdgeNotFound:\n\t\t\tlog.Warnf(\"Unable to find channel policies for %v, \"+\n\t\t\t\t\"skipping. This is typical if the channel is \"+\n\t\t\t\t\"in the process of closing.\", c.FundingOutpoint)\n\t\t\tcontinue\n\n\t\t// If we are in the process of opening a channel, the funding\n\t\t// manager might not have added the ChannelUpdate to the graph\n\t\t// yet. We'll ignore the channel for now.\n\t\tcase err == ErrUnableToExtractChanUpdate:\n\t\t\tlog.Warnf(\"Unable to find channel policies for %v, \"+\n\t\t\t\t\"skipping. This is typical if the channel is \"+\n\t\t\t\t\"in the process of being opened.\",\n\t\t\t\tc.FundingOutpoint)\n\t\t\tcontinue\n\n\t\tcase err != nil:\n\t\t\treturn err\n\t\t}\n\t}\n\n\tm.wg.Add(1)\n\tgo m.statusManager()\n\n\treturn nil\n}\n\n// Stop safely shuts down the ChanStatusManager.",
      "length": 1161,
      "tokens": 186,
      "embedding": []
    },
    {
      "slug": "func (m *ChanStatusManager) Stop() error {",
      "content": "func (m *ChanStatusManager) Stop() error {\n\tm.stopped.Do(func() {\n\t\tlog.Info(\"Channel Status Manager shutting down\")\n\t\tclose(m.quit)\n\t\tm.wg.Wait()\n\t})\n\treturn nil\n}\n\n// RequestEnable submits a request to immediately enable a channel identified by\n// the provided outpoint. If the channel is already enabled, no action will be\n// taken. If the channel is marked pending-disable the channel will be returned\n// to an active status as the scheduled disable was never sent. Otherwise if the\n// channel is found to be disabled, a new announcement will be signed with the\n// disabled bit cleared and broadcast to the network.\n//\n// If the channel was manually disabled and RequestEnable is called with\n// manual = false, then the request will be ignored.\n//\n// NOTE: RequestEnable should only be called after a stable connection with the\n// channel's peer has lasted at least the ChanEnableTimeout. Failure to do so\n// may result in behavior that deviates from the expected behavior of the state\n// machine.",
      "length": 937,
      "tokens": 157,
      "embedding": []
    },
    {
      "slug": "func (m *ChanStatusManager) RequestEnable(outpoint wire.OutPoint,",
      "content": "func (m *ChanStatusManager) RequestEnable(outpoint wire.OutPoint,\n\tmanual bool) error {\n\n\treturn m.submitRequest(m.enableRequests, outpoint, manual)\n}\n\n// RequestDisable submits a request to immediately disable a channel identified\n// by the provided outpoint. If the channel is already disabled, no action will\n// be taken. Otherwise, a new announcement will be signed with the disabled bit\n// set and broadcast to the network.\n//\n// The channel state will be changed to either ChanStatusDisabled or\n// ChanStatusManuallyDisabled, depending on the passed-in value of manual. In\n// particular, note the following state transitions:\n//\n//\tcurrent state    | manual | new state\n//\t---------------------------------------------------\n//\tDisabled         | false  | Disabled\n//\tManuallyDisabled | false  | ManuallyDisabled (*)\n//\tDisabled         | true   | ManuallyDisabled\n//\tManuallyDisabled | true   | ManuallyDisabled\n//\n// (*) If a channel was manually disabled, subsequent automatic / background\n//\n//\trequests to disable the channel do not change the fact that the channel\n//\twas manually disabled.",
      "length": 1012,
      "tokens": 152,
      "embedding": []
    },
    {
      "slug": "func (m *ChanStatusManager) RequestDisable(outpoint wire.OutPoint,",
      "content": "func (m *ChanStatusManager) RequestDisable(outpoint wire.OutPoint,\n\tmanual bool) error {\n\n\treturn m.submitRequest(m.disableRequests, outpoint, manual)\n}\n\n// RequestAuto submits a request to restore automatic channel state management.\n// If the channel is in the state ChanStatusManuallyDisabled, it will be moved\n// back to the state ChanStatusDisabled. Otherwise, no action will be taken.",
      "length": 315,
      "tokens": 45,
      "embedding": []
    },
    {
      "slug": "func (m *ChanStatusManager) RequestAuto(outpoint wire.OutPoint) error {",
      "content": "func (m *ChanStatusManager) RequestAuto(outpoint wire.OutPoint) error {\n\treturn m.submitRequest(m.autoRequests, outpoint, true)\n}\n\n// statusRequest is passed to the statusManager to request a change in status\n// for a particular channel point.  The exact action is governed by passing the\n// request through one of the enableRequests or disableRequests channels.",
      "length": 285,
      "tokens": 42,
      "embedding": []
    },
    {
      "slug": "type statusRequest struct {",
      "content": "type statusRequest struct {\n\toutpoint wire.OutPoint\n\tmanual   bool\n\terrChan  chan error\n}\n\n// submitRequest sends a request for either enabling or disabling a particular\n// outpoint and awaits an error response. The request type is dictated by the\n// reqChan passed in, which can be either of the enableRequests or\n// disableRequests channels.",
      "length": 307,
      "tokens": 49,
      "embedding": []
    },
    {
      "slug": "func (m *ChanStatusManager) submitRequest(reqChan chan statusRequest,",
      "content": "func (m *ChanStatusManager) submitRequest(reqChan chan statusRequest,\n\toutpoint wire.OutPoint, manual bool) error {\n\n\treq := statusRequest{\n\t\toutpoint: outpoint,\n\t\tmanual:   manual,\n\t\terrChan:  make(chan error, 1),\n\t}\n\n\tselect {\n\tcase reqChan <- req:\n\tcase <-m.quit:\n\t\treturn ErrChanStatusManagerExiting\n\t}\n\n\tselect {\n\tcase err := <-req.errChan:\n\t\treturn err\n\tcase <-m.quit:\n\t\treturn ErrChanStatusManagerExiting\n\t}\n}\n\n// statusManager is the primary event loop for the ChanStatusManager, providing\n// the necessary synchronization primitive to protect access to the chanStates\n// map. All requests to explicitly enable or disable a channel are processed\n// within this method. The statusManager will also periodically poll the active\n// status of channels within the htlcswitch to see if a disable announcement\n// should be scheduled or broadcast.\n//\n// NOTE: This method MUST be run as a goroutine.",
      "length": 800,
      "tokens": 120,
      "embedding": []
    },
    {
      "slug": "func (m *ChanStatusManager) statusManager() {",
      "content": "func (m *ChanStatusManager) statusManager() {\n\tdefer m.wg.Done()\n\n\tfor {\n\t\tselect {\n\n\t\t// Process any requests to mark channel as enabled.\n\t\tcase req := <-m.enableRequests:\n\t\t\treq.errChan <- m.processEnableRequest(req.outpoint, req.manual)\n\n\t\t// Process any requests to mark channel as disabled.\n\t\tcase req := <-m.disableRequests:\n\t\t\treq.errChan <- m.processDisableRequest(req.outpoint, req.manual)\n\n\t\t// Process any requests to restore automatic channel state management.\n\t\tcase req := <-m.autoRequests:\n\t\t\treq.errChan <- m.processAutoRequest(req.outpoint)\n\n\t\t// Use long-polling to detect when channels become inactive.\n\t\tcase <-m.statusSampleTicker.C:\n\t\t\t// First, do a sweep and mark any ChanStatusEnabled\n\t\t\t// channels that are not active within the htlcswitch as\n\t\t\t// ChanStatusPendingDisabled. The channel will then be\n\t\t\t// disabled if no request to enable is received before\n\t\t\t// the ChanDisableTimeout expires.\n\t\t\tm.markPendingInactiveChannels()\n\n\t\t\t// Now, do another sweep to disable any channels that\n\t\t\t// were marked in a prior iteration as pending inactive\n\t\t\t// if the inactive chan timeout has elapsed.\n\t\t\tm.disableInactiveChannels()\n\n\t\tcase <-m.quit:\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// processEnableRequest attempts to enable the given outpoint.\n//\n//   - If the channel is not active at the time of the request,\n//     ErrEnableInactiveChan will be returned.\n//   - If the channel was in the ManuallyDisabled state and manual = false,\n//     the request will be ignored and ErrEnableManuallyDisabledChan will be\n//     returned.\n//   - Otherwise, the status of the channel in chanStates will be\n//     ChanStatusEnabled and the method will return nil.\n//\n// An update will be broadcast only if the channel is currently disabled,\n// otherwise no update will be sent on the network.",
      "length": 1697,
      "tokens": 242,
      "embedding": []
    },
    {
      "slug": "func (m *ChanStatusManager) processEnableRequest(outpoint wire.OutPoint,",
      "content": "func (m *ChanStatusManager) processEnableRequest(outpoint wire.OutPoint,\n\tmanual bool) error {\n\n\tcurState, err := m.getOrInitChanStatus(outpoint)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Quickly check to see if the requested channel is active within the\n\t// htlcswitch and return an error if it isn't.\n\tchanID := lnwire.NewChanIDFromOutPoint(&outpoint)\n\tif !m.cfg.IsChannelActive(chanID) {\n\t\treturn ErrEnableInactiveChan\n\t}\n\n\tswitch curState.Status {\n\n\t// Channel is already enabled, nothing to do.\n\tcase ChanStatusEnabled:\n\t\tlog.Debugf(\"Channel(%v) already enabled, skipped announcement\")\n\t\treturn nil\n\n\t// The channel is enabled, though we are now canceling the scheduled\n\t// disable.\n\tcase ChanStatusPendingDisabled:\n\t\tlog.Debugf(\"Channel(%v) already enabled, canceling scheduled \"+\n\t\t\t\"disable\", outpoint)\n\n\t// We'll sign a new update if the channel is still disabled.\n\tcase ChanStatusManuallyDisabled:\n\t\tif !manual {\n\t\t\treturn ErrEnableManuallyDisabledChan\n\t\t}\n\t\tfallthrough\n\n\tcase ChanStatusDisabled:\n\t\tlog.Infof(\"Announcing channel(%v) enabled\", outpoint)\n\n\t\terr := m.signAndSendNextUpdate(outpoint, false)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tm.chanStates.markEnabled(outpoint)\n\n\treturn nil\n}\n\n// processDisableRequest attempts to disable the given outpoint. If the method\n// returns nil, the status of the channel in chanStates will be either\n// ChanStatusDisabled or ChanStatusManuallyDisabled, depending on the\n// passed-in value of manual.\n//\n// An update will only be sent if the channel has a status other than\n// ChanStatusEnabled, otherwise no update will be sent on the network.",
      "length": 1469,
      "tokens": 198,
      "embedding": []
    },
    {
      "slug": "func (m *ChanStatusManager) processDisableRequest(outpoint wire.OutPoint,",
      "content": "func (m *ChanStatusManager) processDisableRequest(outpoint wire.OutPoint,\n\tmanual bool) error {\n\n\tcurState, err := m.getOrInitChanStatus(outpoint)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tstatus := curState.Status\n\tif status == ChanStatusEnabled || status == ChanStatusPendingDisabled {\n\t\tlog.Infof(\"Announcing channel(%v) disabled [requested]\",\n\t\t\toutpoint)\n\n\t\terr := m.signAndSendNextUpdate(outpoint, true)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Typically, a request to disable a channel via the manager's public\n\t// interface signals that the channel is being closed.\n\t//\n\t// If we don't need to keep track of a manual request to disable the\n\t// channel, then we can remove the outpoint to free up space in the map\n\t// of channel states. If for some reason the channel isn't closed, the\n\t// state will be repopulated on subsequent calls to the manager's public\n\t// interface via a db lookup, or on startup.\n\tif manual {\n\t\tm.chanStates.markManuallyDisabled(outpoint)\n\t} else if status != ChanStatusManuallyDisabled {\n\t\tdelete(m.chanStates, outpoint)\n\t}\n\n\treturn nil\n}\n\n// processAutoRequest attempts to restore automatic channel state management\n// for the given outpoint. If the method returns nil, the state of the channel\n// will no longer be ChanStatusManuallyDisabled (currently the only state in\n// which automatic / background requests are ignored).\n//\n// No update will be sent on the network.",
      "length": 1288,
      "tokens": 202,
      "embedding": []
    },
    {
      "slug": "func (m *ChanStatusManager) processAutoRequest(outpoint wire.OutPoint) error {",
      "content": "func (m *ChanStatusManager) processAutoRequest(outpoint wire.OutPoint) error {\n\tcurState, err := m.getOrInitChanStatus(outpoint)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif curState.Status == ChanStatusManuallyDisabled {\n\t\tlog.Debugf(\"Restoring automatic control for manually disabled \"+\n\t\t\t\"channel(%v)\", outpoint)\n\n\t\tm.chanStates.markDisabled(outpoint)\n\t}\n\treturn nil\n}\n\n// markPendingInactiveChannels performs a sweep of the database's active\n// channels and determines which, if any, should have a disable announcement\n// scheduled. Once an active channel is determined to be pending-inactive, one\n// of two transitions can follow. Either the channel is disabled because no\n// request to enable is received before the scheduled disable is broadcast, or\n// the channel is successfully re-enabled and channel is returned to an active\n// state from the POV of the ChanStatusManager.",
      "length": 778,
      "tokens": 111,
      "embedding": []
    },
    {
      "slug": "func (m *ChanStatusManager) markPendingInactiveChannels() {",
      "content": "func (m *ChanStatusManager) markPendingInactiveChannels() {\n\tchannels, err := m.fetchChannels()\n\tif err != nil {\n\t\tlog.Errorf(\"Unable to load active channels: %v\", err)\n\t\treturn\n\t}\n\n\tfor _, c := range channels {\n\t\t// Determine the initial status of the active channel, and\n\t\t// populate the entry in the chanStates map.\n\t\tcurState, err := m.getOrInitChanStatus(c.FundingOutpoint)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Unable to retrieve chan status for \"+\n\t\t\t\t\"Channel(%v): %v\", c.FundingOutpoint, err)\n\t\t\tcontinue\n\t\t}\n\n\t\t// If the channel's status is not ChanStatusEnabled, we are\n\t\t// done.  Either it is already disabled, or it has been marked\n\t\t// ChanStatusPendingDisable meaning that we have already\n\t\t// scheduled the time at which it will be disabled.\n\t\tif curState.Status != ChanStatusEnabled {\n\t\t\tcontinue\n\t\t}\n\n\t\t// If our bookkeeping shows the channel as active, sample the\n\t\t// htlcswitch to see if it believes the link is also active. If\n\t\t// so, we will skip marking it as ChanStatusPendingDisabled.\n\t\tchanID := lnwire.NewChanIDFromOutPoint(&c.FundingOutpoint)\n\t\tif m.cfg.IsChannelActive(chanID) {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Otherwise, we discovered that this link was inactive within\n\t\t// the switch. Compute the time at which we will send out a\n\t\t// disable if the peer is unable to reestablish a stable\n\t\t// connection.\n\t\tdisableTime := time.Now().Add(m.cfg.ChanDisableTimeout)\n\n\t\tlog.Debugf(\"Marking channel(%v) pending-inactive\",\n\t\t\tc.FundingOutpoint)\n\n\t\tm.chanStates.markPendingDisabled(c.FundingOutpoint, disableTime)\n\t}\n}\n\n// disableInactiveChannels scans through the set of monitored channels, and\n// broadcast a disable update for any pending inactive channels whose\n// SendDisableTime has been superseded by the current time.",
      "length": 1633,
      "tokens": 229,
      "embedding": []
    },
    {
      "slug": "func (m *ChanStatusManager) disableInactiveChannels() {",
      "content": "func (m *ChanStatusManager) disableInactiveChannels() {\n\t// Now, disable any channels whose inactive chan timeout has elapsed.\n\tnow := time.Now()\n\tfor outpoint, state := range m.chanStates {\n\t\t// Ignore statuses that are not in the pending-inactive state.\n\t\tif state.Status != ChanStatusPendingDisabled {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Ignore statuses for which the disable timeout has not\n\t\t// expired.\n\t\tif state.SendDisableTime.After(now) {\n\t\t\tcontinue\n\t\t}\n\n\t\tlog.Infof(\"Announcing channel(%v) disabled \"+\n\t\t\t\"[detected]\", outpoint)\n\n\t\t// Sign an update disabling the channel.\n\t\terr := m.signAndSendNextUpdate(outpoint, true)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Unable to sign update disabling \"+\n\t\t\t\t\"channel(%v): %v\", outpoint, err)\n\n\t\t\t// If the edge was not found, this is a likely indicator\n\t\t\t// that the channel has been closed. Thus we remove the\n\t\t\t// outpoint from the set of tracked outpoints to prevent\n\t\t\t// further attempts.\n\t\t\tif err == channeldb.ErrEdgeNotFound {\n\t\t\t\tlog.Debugf(\"Removing channel(%v) from \"+\n\t\t\t\t\t\"consideration for passive disabling\",\n\t\t\t\t\toutpoint)\n\t\t\t\tdelete(m.chanStates, outpoint)\n\t\t\t}\n\n\t\t\tcontinue\n\t\t}\n\n\t\t// Record that the channel has now been disabled.\n\t\tm.chanStates.markDisabled(outpoint)\n\t}\n}\n\n// fetchChannels returns the working set of channels managed by the\n// ChanStatusManager. The returned channels are filtered to only contain public\n// channels.",
      "length": 1289,
      "tokens": 178,
      "embedding": []
    },
    {
      "slug": "func (m *ChanStatusManager) fetchChannels() ([]*channeldb.OpenChannel, error) {",
      "content": "func (m *ChanStatusManager) fetchChannels() ([]*channeldb.OpenChannel, error) {\n\tallChannels, err := m.cfg.DB.FetchAllOpenChannels()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Filter out private channels.\n\tvar channels []*channeldb.OpenChannel\n\tfor _, c := range allChannels {\n\t\t// We'll skip any private channels, as they aren't used for\n\t\t// routing within the network by other nodes.\n\t\tif c.ChannelFlags&lnwire.FFAnnounceChannel == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tchannels = append(channels, c)\n\t}\n\n\treturn channels, nil\n}\n\n// signAndSendNextUpdate computes and signs a valid update for the passed\n// outpoint, with the ability to toggle the disabled bit. The new update will\n// use the current time as the update's timestamp, or increment the old\n// timestamp by 1 to ensure the update can propagate. If signing is successful,\n// the new update will be sent out on the network.",
      "length": 768,
      "tokens": 126,
      "embedding": []
    },
    {
      "slug": "func (m *ChanStatusManager) signAndSendNextUpdate(outpoint wire.OutPoint,",
      "content": "func (m *ChanStatusManager) signAndSendNextUpdate(outpoint wire.OutPoint,\n\tdisabled bool) error {\n\n\t// Retrieve the latest update for this channel. We'll use this\n\t// as our starting point to send the new update.\n\tchanUpdate, private, err := m.fetchLastChanUpdateByOutPoint(outpoint)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = SignChannelUpdate(\n\t\tm.cfg.MessageSigner, m.cfg.OurKeyLoc, chanUpdate,\n\t\tChanUpdSetDisable(disabled), ChanUpdSetTimestamp,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn m.cfg.ApplyChannelUpdate(chanUpdate, &outpoint, private)\n}\n\n// fetchLastChanUpdateByOutPoint fetches the latest policy for our direction of\n// a channel, and crafts a new ChannelUpdate with this policy. Returns an error\n// in case our ChannelEdgePolicy is not found in the database. Also returns if\n// the channel is private by checking AuthProof for nil.",
      "length": 751,
      "tokens": 108,
      "embedding": []
    },
    {
      "slug": "func (m *ChanStatusManager) fetchLastChanUpdateByOutPoint(op wire.OutPoint) (",
      "content": "func (m *ChanStatusManager) fetchLastChanUpdateByOutPoint(op wire.OutPoint) (\n\t*lnwire.ChannelUpdate, bool, error) {\n\n\t// Get the edge info and policies for this channel from the graph.\n\tinfo, edge1, edge2, err := m.cfg.Graph.FetchChannelEdgesByOutpoint(&op)\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\n\tupdate, err := ExtractChannelUpdate(\n\t\tm.ourPubKeyBytes, info, edge1, edge2,\n\t)\n\treturn update, info.AuthProof == nil, err\n}\n\n// loadInitialChanState determines the initial ChannelState for a particular\n// outpoint. The initial ChanStatus for a given outpoint will either be\n// ChanStatusEnabled or ChanStatusDisabled, determined by inspecting the bits on\n// the most recent announcement. An error is returned if the latest update could\n// not be retrieved.",
      "length": 667,
      "tokens": 98,
      "embedding": []
    },
    {
      "slug": "func (m *ChanStatusManager) loadInitialChanState(",
      "content": "func (m *ChanStatusManager) loadInitialChanState(\n\toutpoint *wire.OutPoint) (ChannelState, error) {\n\n\tlastUpdate, _, err := m.fetchLastChanUpdateByOutPoint(*outpoint)\n\tif err != nil {\n\t\treturn ChannelState{}, err\n\t}\n\n\t// Determine the channel's starting status by inspecting the disable bit\n\t// on last announcement we sent out.\n\tvar initialStatus ChanStatus\n\tif lastUpdate.ChannelFlags&lnwire.ChanUpdateDisabled == 0 {\n\t\tinitialStatus = ChanStatusEnabled\n\t} else {\n\t\tinitialStatus = ChanStatusDisabled\n\t}\n\n\treturn ChannelState{\n\t\tStatus: initialStatus,\n\t}, nil\n}\n\n// getOrInitChanStatus retrieves the current ChannelState for a particular\n// outpoint. If the chanStates map already contains an entry for the outpoint,\n// the value in the map is returned. Otherwise, the outpoint's initial status is\n// computed and updated in the chanStates map before being returned.",
      "length": 794,
      "tokens": 109,
      "embedding": []
    },
    {
      "slug": "func (m *ChanStatusManager) getOrInitChanStatus(",
      "content": "func (m *ChanStatusManager) getOrInitChanStatus(\n\toutpoint wire.OutPoint) (ChannelState, error) {\n\n\t// Return the current ChannelState from the chanStates map if it is\n\t// already known to the ChanStatusManager.\n\tif curState, ok := m.chanStates[outpoint]; ok {\n\t\treturn curState, nil\n\t}\n\n\t// Otherwise, determine the initial state based on the last update we\n\t// sent for the outpoint.\n\tinitialState, err := m.loadInitialChanState(&outpoint)\n\tif err != nil {\n\t\treturn ChannelState{}, err\n\t}\n\n\t// Finally, store the initial state in the chanStates map. This will\n\t// serve as are up-to-date view of the outpoint's current status, in\n\t// addition to making the channel eligible for detecting inactivity.\n\tm.chanStates[outpoint] = initialState\n\n\treturn initialState, nil\n}\n",
      "length": 699,
      "tokens": 105,
      "embedding": []
    }
  ]
}