{
  "filepath": "../implementations/go/lnd/routing/missioncontrol_state.go",
  "package": "routing",
  "sections": [
    {
      "slug": "type missionControlState struct {",
      "content": "type missionControlState struct {\n\t// lastPairResult tracks the last payment result (on a pair basis) for\n\t// each transited node. This is a multi-layer map that allows us to look\n\t// up the failure history of all connected channels (node pairs) for a\n\t// particular node.\n\tlastPairResult map[route.Vertex]NodeResults\n\n\t// lastSecondChance tracks the last time a second chance was granted for\n\t// a directed node pair.\n\tlastSecondChance map[DirectedNodePair]time.Time\n\n\t// minFailureRelaxInterval is the minimum time that must have passed\n\t// since the previously recorded failure before the failure amount may\n\t// be raised.\n\tminFailureRelaxInterval time.Duration\n}\n\n// newMissionControlState instantiates a new mission control state object.",
      "length": 692,
      "tokens": 99,
      "embedding": []
    },
    {
      "slug": "func newMissionControlState(",
      "content": "func newMissionControlState(\n\tminFailureRelaxInterval time.Duration) *missionControlState {\n\n\treturn &missionControlState{\n\t\tlastPairResult:          make(map[route.Vertex]NodeResults),\n\t\tlastSecondChance:        make(map[DirectedNodePair]time.Time),\n\t\tminFailureRelaxInterval: minFailureRelaxInterval,\n\t}\n}\n\n// getLastPairResult returns the current state for connections to the given node.",
      "length": 352,
      "tokens": 26,
      "embedding": []
    },
    {
      "slug": "func (m *missionControlState) getLastPairResult(node route.Vertex) (NodeResults,",
      "content": "func (m *missionControlState) getLastPairResult(node route.Vertex) (NodeResults,\n\tbool) {\n\n\tresult, ok := m.lastPairResult[node]\n\treturn result, ok\n}\n\n// ResetHistory resets the history of MissionControl returning it to a state as\n// if no payment attempts have been made.",
      "length": 184,
      "tokens": 31,
      "embedding": []
    },
    {
      "slug": "func (m *missionControlState) resetHistory() {",
      "content": "func (m *missionControlState) resetHistory() {\n\tm.lastPairResult = make(map[route.Vertex]NodeResults)\n\tm.lastSecondChance = make(map[DirectedNodePair]time.Time)\n}\n\n// setLastPairResult stores a result for a node pair.",
      "length": 166,
      "tokens": 16,
      "embedding": []
    },
    {
      "slug": "func (m *missionControlState) setLastPairResult(fromNode, toNode route.Vertex,",
      "content": "func (m *missionControlState) setLastPairResult(fromNode, toNode route.Vertex,\n\ttimestamp time.Time, result *pairResult, force bool) {\n\n\tnodePairs, ok := m.lastPairResult[fromNode]\n\tif !ok {\n\t\tnodePairs = make(NodeResults)\n\t\tm.lastPairResult[fromNode] = nodePairs\n\t}\n\n\tcurrent := nodePairs[toNode]\n\n\t// Apply the new result to the existing data for this pair. If there is\n\t// no existing data, apply it to the default values for TimedPairResult.\n\tif result.success {\n\t\tsuccessAmt := result.amt\n\t\tcurrent.SuccessTime = timestamp\n\n\t\t// Only update the success amount if this amount is higher. This\n\t\t// prevents the success range from shrinking when there is no\n\t\t// reason to do so. For example: small amount probes shouldn't\n\t\t// affect a previous success for a much larger amount.\n\t\tif force || successAmt > current.SuccessAmt {\n\t\t\tcurrent.SuccessAmt = successAmt\n\t\t}\n\n\t\t// If the success amount goes into the failure range, move the\n\t\t// failure range up. Future attempts up to the success amount\n\t\t// are likely to succeed. We don't want to clear the failure\n\t\t// completely, because we haven't learnt much for amounts above\n\t\t// the current success amount.\n\t\tif force || (!current.FailTime.IsZero() &&\n\t\t\tsuccessAmt >= current.FailAmt) {\n\n\t\t\tcurrent.FailAmt = successAmt + 1\n\t\t}\n\t} else {\n\t\t// For failures we always want to update both the amount and the\n\t\t// time. Those need to relate to the same result, because the\n\t\t// time is used to gradually diminish the penalty for that\n\t\t// specific result. Updating the timestamp but not the amount\n\t\t// could cause a failure for a lower amount (a more severe\n\t\t// condition) to be revived as if it just happened.\n\t\tfailAmt := result.amt\n\n\t\t// Drop result if it would increase the failure amount too soon\n\t\t// after a previous failure. This can happen if htlc results\n\t\t// come in out of order. This check makes it easier for payment\n\t\t// processes to converge to a final state.\n\t\tfailInterval := timestamp.Sub(current.FailTime)\n\t\tif !force && failAmt > current.FailAmt &&\n\t\t\tfailInterval < m.minFailureRelaxInterval {\n\n\t\t\tlog.Debugf(\"Ignoring higher amount failure within min \"+\n\t\t\t\t\"failure relaxation interval: prev_fail_amt=%v, \"+\n\t\t\t\t\"fail_amt=%v, interval=%v\",\n\t\t\t\tcurrent.FailAmt, failAmt, failInterval)\n\n\t\t\treturn\n\t\t}\n\n\t\tcurrent.FailTime = timestamp\n\t\tcurrent.FailAmt = failAmt\n\n\t\tswitch {\n\t\t// The failure amount is set to zero when the failure is\n\t\t// amount-independent, meaning that the attempt would have\n\t\t// failed regardless of the amount. This should also reset the\n\t\t// success amount to zero.\n\t\tcase failAmt == 0:\n\t\t\tcurrent.SuccessAmt = 0\n\n\t\t// If the failure range goes into the success range, move the\n\t\t// success range down.\n\t\tcase failAmt <= current.SuccessAmt:\n\t\t\tcurrent.SuccessAmt = failAmt - 1\n\t\t}\n\t}\n\n\tlog.Debugf(\"Setting %v->%v range to [%v-%v]\",\n\t\tfromNode, toNode, current.SuccessAmt, current.FailAmt)\n\n\tnodePairs[toNode] = current\n}\n\n// setAllFail stores a fail result for all known connections to and from the\n// given node.",
      "length": 2846,
      "tokens": 439,
      "embedding": []
    },
    {
      "slug": "func (m *missionControlState) setAllFail(node route.Vertex,",
      "content": "func (m *missionControlState) setAllFail(node route.Vertex,\n\ttimestamp time.Time) {\n\n\tfor fromNode, nodePairs := range m.lastPairResult {\n\t\tfor toNode := range nodePairs {\n\t\t\tif fromNode == node || toNode == node {\n\t\t\t\tnodePairs[toNode] = TimedPairResult{\n\t\t\t\t\tFailTime: timestamp,\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// requestSecondChance checks whether the node fromNode can have a second chance\n// at providing a channel update for its channel with toNode.",
      "length": 371,
      "tokens": 58,
      "embedding": []
    },
    {
      "slug": "func (m *missionControlState) requestSecondChance(timestamp time.Time,",
      "content": "func (m *missionControlState) requestSecondChance(timestamp time.Time,\n\tfromNode, toNode route.Vertex) bool {\n\n\t// Look up previous second chance time.\n\tpair := DirectedNodePair{\n\t\tFrom: fromNode,\n\t\tTo:   toNode,\n\t}\n\tlastSecondChance, ok := m.lastSecondChance[pair]\n\n\t// If the channel hasn't already be given a second chance or its last\n\t// second chance was long ago, we give it another chance.\n\tif !ok || timestamp.Sub(lastSecondChance) > minSecondChanceInterval {\n\t\tm.lastSecondChance[pair] = timestamp\n\n\t\tlog.Debugf(\"Second chance granted for %v->%v\", fromNode, toNode)\n\n\t\treturn true\n\t}\n\n\t// Otherwise penalize the channel, because we don't allow channel\n\t// updates that are that frequent. This is to prevent nodes from keeping\n\t// us busy by continuously sending new channel updates.\n\tlog.Debugf(\"Second chance denied for %v->%v, remaining interval: %v\",\n\t\tfromNode, toNode, timestamp.Sub(lastSecondChance))\n\n\treturn false\n}\n\n// GetHistorySnapshot takes a snapshot from the current mission control state\n// and actual probability estimates.",
      "length": 948,
      "tokens": 131,
      "embedding": []
    },
    {
      "slug": "func (m *missionControlState) getSnapshot() *MissionControlSnapshot {",
      "content": "func (m *missionControlState) getSnapshot() *MissionControlSnapshot {\n\tlog.Debugf(\"Requesting history snapshot from mission control: \"+\n\t\t\"pair_result_count=%v\", len(m.lastPairResult))\n\n\tpairs := make([]MissionControlPairSnapshot, 0, len(m.lastPairResult))\n\n\tfor fromNode, fromPairs := range m.lastPairResult {\n\t\tfor toNode, result := range fromPairs {\n\t\t\tpair := NewDirectedNodePair(fromNode, toNode)\n\n\t\t\tpairSnapshot := MissionControlPairSnapshot{\n\t\t\t\tPair:            pair,\n\t\t\t\tTimedPairResult: result,\n\t\t\t}\n\n\t\t\tpairs = append(pairs, pairSnapshot)\n\t\t}\n\t}\n\n\tsnapshot := MissionControlSnapshot{\n\t\tPairs: pairs,\n\t}\n\n\treturn &snapshot\n}\n\n// importSnapshot takes an existing snapshot and merges it with our current\n// state if the result provided are fresher than our current results. It returns\n// the number of pairs that were used.",
      "length": 735,
      "tokens": 89,
      "embedding": []
    },
    {
      "slug": "func (m *missionControlState) importSnapshot(snapshot *MissionControlSnapshot,",
      "content": "func (m *missionControlState) importSnapshot(snapshot *MissionControlSnapshot,\n\tforce bool) int {\n\n\tvar imported int\n\n\tfor _, pair := range snapshot.Pairs {\n\t\tfromNode := pair.Pair.From\n\t\ttoNode := pair.Pair.To\n\n\t\tresults, found := m.getLastPairResult(fromNode)\n\t\tif !found {\n\t\t\tresults = make(map[route.Vertex]TimedPairResult)\n\t\t}\n\n\t\tlastResult := results[toNode]\n\n\t\tfailResult := failPairResult(pair.FailAmt)\n\t\timported += m.importResult(\n\t\t\tlastResult.FailTime, pair.FailTime, failResult,\n\t\t\tfromNode, toNode, force,\n\t\t)\n\n\t\tsuccessResult := successPairResult(pair.SuccessAmt)\n\t\timported += m.importResult(\n\t\t\tlastResult.SuccessTime, pair.SuccessTime, successResult,\n\t\t\tfromNode, toNode, force,\n\t\t)\n\t}\n\n\treturn imported\n}\n",
      "length": 615,
      "tokens": 64,
      "embedding": []
    },
    {
      "slug": "func (m *missionControlState) importResult(currentTs, importedTs time.Time,",
      "content": "func (m *missionControlState) importResult(currentTs, importedTs time.Time,\n\timportedResult pairResult, fromNode, toNode route.Vertex,\n\tforce bool) int {\n\n\tif !force && currentTs.After(importedTs) {\n\t\tlog.Debugf(\"Not setting pair result for %v->%v (%v) \"+\n\t\t\t\"success=%v, timestamp %v older than last result %v\",\n\t\t\tfromNode, toNode, importedResult.amt,\n\t\t\timportedResult.success, importedTs, currentTs)\n\n\t\treturn 0\n\t}\n\n\tm.setLastPairResult(\n\t\tfromNode, toNode, importedTs, &importedResult, force,\n\t)\n\n\treturn 1\n}\n",
      "length": 420,
      "tokens": 49,
      "embedding": []
    }
  ]
}