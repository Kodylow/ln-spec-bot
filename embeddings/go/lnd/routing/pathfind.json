{
  "filepath": "../implementations/go/lnd/routing/pathfind.go",
  "package": "routing",
  "sections": [
    {
      "slug": "type pathFinder = func(g *graphParams, r *RestrictParams,",
      "content": "type pathFinder = func(g *graphParams, r *RestrictParams,\n\tcfg *PathFindingConfig, source, target route.Vertex,\n\tamt lnwire.MilliSatoshi, timePref float64, finalHtlcExpiry int32) (\n\t[]*channeldb.CachedEdgePolicy, float64, error)\n\nvar (\n\t// DefaultEstimator is the default estimator used for computing\n\t// probabilities in pathfinding.\n\tDefaultEstimator = AprioriEstimatorName\n\n\t// DefaultAttemptCost is the default fixed virtual cost in path finding\n\t// of a failed payment attempt. It is used to trade off potentially\n\t// better routes against their probability of succeeding.\n\tDefaultAttemptCost = lnwire.NewMSatFromSatoshis(100)\n\n\t// DefaultAttemptCostPPM is the default proportional virtual cost in\n\t// path finding weight units of executing a payment attempt that fails.\n\t// It is used to trade off potentially better routes against their\n\t// probability of succeeding. This parameter is expressed in parts per\n\t// million of the payment amount.\n\t//\n\t// It is impossible to pick a perfect default value. The current value\n\t// of 0.1% is based on the idea that a transaction fee of 1% is within\n\t// reasonable territory and that a payment shouldn't need more than 10\n\t// attempts.\n\tDefaultAttemptCostPPM = int64(1000)\n\n\t// DefaultMinRouteProbability is the default minimum probability for routes\n\t// returned from findPath.\n\tDefaultMinRouteProbability = float64(0.01)\n\n\t// DefaultAprioriHopProbability is the default a priori probability for\n\t// a hop.\n\tDefaultAprioriHopProbability = float64(0.6)\n)\n\n// edgePolicyWithSource is a helper struct to keep track of the source node\n// of a channel edge. ChannelEdgePolicy only contains to destination node\n// of the edge.",
      "length": 1575,
      "tokens": 225,
      "embedding": []
    },
    {
      "slug": "type edgePolicyWithSource struct {",
      "content": "type edgePolicyWithSource struct {\n\tsourceNode route.Vertex\n\tedge       *channeldb.CachedEdgePolicy\n}\n\n// finalHopParams encapsulates various parameters for route construction that\n// apply to the final hop in a route. These features include basic payment data\n// such as amounts and cltvs, as well as more complex features like destination\n// custom records and payment address.",
      "length": 337,
      "tokens": 49,
      "embedding": []
    },
    {
      "slug": "type finalHopParams struct {",
      "content": "type finalHopParams struct {\n\tamt         lnwire.MilliSatoshi\n\ttotalAmt    lnwire.MilliSatoshi\n\tcltvDelta   uint16\n\trecords     record.CustomSet\n\tpaymentAddr *[32]byte\n\n\t// metadata is additional data that is sent along with the payment to\n\t// the payee.\n\tmetadata []byte\n}\n\n// newRoute constructs a route using the provided path and final hop constraints.\n// Any destination specific fields from the final hop params  will be attached\n// assuming the destination's feature vector signals support, otherwise this\n// method will fail.  If the route is too long, or the selected path cannot\n// support the fully payment including fees, then a non-nil error is returned.\n//\n// NOTE: The passed slice of ChannelHops MUST be sorted in forward order: from\n// the source to the target node of the path finding attempt. It is assumed that\n// any feature vectors on all hops have been validated for transitive\n// dependencies.",
      "length": 868,
      "tokens": 138,
      "embedding": []
    },
    {
      "slug": "func newRoute(sourceVertex route.Vertex,",
      "content": "func newRoute(sourceVertex route.Vertex,\n\tpathEdges []*channeldb.CachedEdgePolicy, currentHeight uint32,\n\tfinalHop finalHopParams) (*route.Route, error) {\n\n\tvar (\n\t\thops []*route.Hop\n\n\t\t// totalTimeLock will accumulate the cumulative time lock\n\t\t// across the entire route. This value represents how long the\n\t\t// sender will need to wait in the *worst* case.\n\t\ttotalTimeLock = currentHeight\n\n\t\t// nextIncomingAmount is the amount that will need to flow into\n\t\t// the *next* hop. Since we're going to be walking the route\n\t\t// backwards below, this next hop gets closer and closer to the\n\t\t// sender of the payment.\n\t\tnextIncomingAmount lnwire.MilliSatoshi\n\t)\n\n\tpathLength := len(pathEdges)\n\tfor i := pathLength - 1; i >= 0; i-- {\n\t\t// Now we'll start to calculate the items within the per-hop\n\t\t// payload for the hop this edge is leading to.\n\t\tedge := pathEdges[i]\n\n\t\t// We'll calculate the amounts, timelocks, and fees for each hop\n\t\t// in the route. The base case is the final hop which includes\n\t\t// their amount and timelocks. These values will accumulate\n\t\t// contributions from the preceding hops back to the sender as\n\t\t// we compute the route in reverse.\n\t\tvar (\n\t\t\tamtToForward     lnwire.MilliSatoshi\n\t\t\tfee              lnwire.MilliSatoshi\n\t\t\toutgoingTimeLock uint32\n\t\t\ttlvPayload       bool\n\t\t\tcustomRecords    record.CustomSet\n\t\t\tmpp              *record.MPP\n\t\t\tmetadata         []byte\n\t\t)\n\n\t\t// Define a helper function that checks this edge's feature\n\t\t// vector for support for a given feature. We assume at this\n\t\t// point that the feature vectors transitive dependencies have\n\t\t// been validated.\n\t\tsupports := func(feature lnwire.FeatureBit) bool {\n\t\t\t// If this edge comes from router hints, the features\n\t\t\t// could be nil.\n\t\t\tif edge.ToNodeFeatures == nil {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\treturn edge.ToNodeFeatures.HasFeature(feature)\n\t\t}\n\n\t\t// We start by assuming the node doesn't support TLV. We'll now\n\t\t// inspect the node's feature vector to see if we can promote\n\t\t// the hop. We assume already that the feature vector's\n\t\t// transitive dependencies have already been validated by path\n\t\t// finding or some other means.\n\t\ttlvPayload = supports(lnwire.TLVOnionPayloadOptional)\n\n\t\tif i == len(pathEdges)-1 {\n\t\t\t// If this is the last hop, then the hop payload will\n\t\t\t// contain the exact amount. In BOLT #4: Onion Routing\n\t\t\t// Protocol / \"Payload for the Last Node\", this is\n\t\t\t// detailed.\n\t\t\tamtToForward = finalHop.amt\n\n\t\t\t// Fee is not part of the hop payload, but only used for\n\t\t\t// reporting through RPC. Set to zero for the final hop.\n\t\t\tfee = lnwire.MilliSatoshi(0)\n\n\t\t\t// As this is the last hop, we'll use the specified\n\t\t\t// final CLTV delta value instead of the value from the\n\t\t\t// last link in the route.\n\t\t\ttotalTimeLock += uint32(finalHop.cltvDelta)\n\t\t\toutgoingTimeLock = totalTimeLock\n\n\t\t\t// Attach any custom records to the final hop if the\n\t\t\t// receiver supports TLV.\n\t\t\tif !tlvPayload && finalHop.records != nil {\n\t\t\t\treturn nil, errors.New(\"cannot attach \" +\n\t\t\t\t\t\"custom records\")\n\t\t\t}\n\t\t\tcustomRecords = finalHop.records\n\n\t\t\t// If we're attaching a payment addr but the receiver\n\t\t\t// doesn't support both TLV and payment addrs, fail.\n\t\t\tpayAddr := supports(lnwire.PaymentAddrOptional)\n\t\t\tif !payAddr && finalHop.paymentAddr != nil {\n\t\t\t\treturn nil, errors.New(\"cannot attach \" +\n\t\t\t\t\t\"payment addr\")\n\t\t\t}\n\n\t\t\t// Otherwise attach the mpp record if it exists.\n\t\t\t// TODO(halseth): move this to payment life cycle,\n\t\t\t// where AMP options are set.\n\t\t\tif finalHop.paymentAddr != nil {\n\t\t\t\tmpp = record.NewMPP(\n\t\t\t\t\tfinalHop.totalAmt,\n\t\t\t\t\t*finalHop.paymentAddr,\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tmetadata = finalHop.metadata\n\t\t} else {\n\t\t\t// The amount that the current hop needs to forward is\n\t\t\t// equal to the incoming amount of the next hop.\n\t\t\tamtToForward = nextIncomingAmount\n\n\t\t\t// The fee that needs to be paid to the current hop is\n\t\t\t// based on the amount that this hop needs to forward\n\t\t\t// and its policy for the outgoing channel. This policy\n\t\t\t// is stored as part of the incoming channel of\n\t\t\t// the next hop.\n\t\t\tfee = pathEdges[i+1].ComputeFee(amtToForward)\n\n\t\t\t// We'll take the total timelock of the preceding hop as\n\t\t\t// the outgoing timelock or this hop. Then we'll\n\t\t\t// increment the total timelock incurred by this hop.\n\t\t\toutgoingTimeLock = totalTimeLock\n\t\t\ttotalTimeLock += uint32(pathEdges[i+1].TimeLockDelta)\n\t\t}\n\n\t\t// Since we're traversing the path backwards atm, we prepend\n\t\t// each new hop such that, the final slice of hops will be in\n\t\t// the forwards order.\n\t\tcurrentHop := &route.Hop{\n\t\t\tPubKeyBytes:      edge.ToNodePubKey(),\n\t\t\tChannelID:        edge.ChannelID,\n\t\t\tAmtToForward:     amtToForward,\n\t\t\tOutgoingTimeLock: outgoingTimeLock,\n\t\t\tLegacyPayload:    !tlvPayload,\n\t\t\tCustomRecords:    customRecords,\n\t\t\tMPP:              mpp,\n\t\t\tMetadata:         metadata,\n\t\t}\n\n\t\thops = append([]*route.Hop{currentHop}, hops...)\n\n\t\t// Finally, we update the amount that needs to flow into the\n\t\t// *next* hop, which is the amount this hop needs to forward,\n\t\t// accounting for the fee that it takes.\n\t\tnextIncomingAmount = amtToForward + fee\n\t}\n\n\t// With the base routing data expressed as hops, build the full route\n\tnewRoute, err := route.NewRouteFromHops(\n\t\tnextIncomingAmount, totalTimeLock, route.Vertex(sourceVertex),\n\t\thops,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn newRoute, nil\n}\n\n// edgeWeight computes the weight of an edge. This value is used when searching\n// for the shortest path within the channel graph between two nodes. Weight is\n// is the fee itself plus a time lock penalty added to it. This benefits\n// channels with shorter time lock deltas and shorter (hops) routes in general.\n// RiskFactor controls the influence of time lock on route selection. This is\n// currently a fixed value, but might be configurable in the future.",
      "length": 5617,
      "tokens": 844,
      "embedding": []
    },
    {
      "slug": "func edgeWeight(lockedAmt lnwire.MilliSatoshi, fee lnwire.MilliSatoshi,",
      "content": "func edgeWeight(lockedAmt lnwire.MilliSatoshi, fee lnwire.MilliSatoshi,\n\ttimeLockDelta uint16) int64 {\n\t// timeLockPenalty is the penalty for the time lock delta of this channel.\n\t// It is controlled by RiskFactorBillionths and scales proportional\n\t// to the amount that will pass through channel. Rationale is that it if\n\t// a twice as large amount gets locked up, it is twice as bad.\n\ttimeLockPenalty := int64(lockedAmt) * int64(timeLockDelta) *\n\t\tRiskFactorBillionths / 1000000000\n\n\treturn int64(fee) + timeLockPenalty\n}\n\n// graphParams wraps the set of graph parameters passed to findPath.",
      "length": 510,
      "tokens": 79,
      "embedding": []
    },
    {
      "slug": "type graphParams struct {",
      "content": "type graphParams struct {\n\t// graph is the ChannelGraph to be used during path finding.\n\tgraph routingGraph\n\n\t// additionalEdges is an optional set of edges that should be\n\t// considered during path finding, that is not already found in the\n\t// channel graph.\n\tadditionalEdges map[route.Vertex][]*channeldb.CachedEdgePolicy\n\n\t// bandwidthHints is an interface that provides bandwidth hints that\n\t// can provide a better estimate of the current channel bandwidth than\n\t// what is found in the graph. It will override the capacities and\n\t// disabled flags found in the graph for local channels when doing\n\t// path finding if it has updated values for that channel. In\n\t// particular, it should be set to the current available sending\n\t// bandwidth for active local channels, and 0 for inactive channels.\n\tbandwidthHints bandwidthHints\n}\n\n// RestrictParams wraps the set of restrictions passed to findPath that the\n// found path must adhere to.",
      "length": 896,
      "tokens": 143,
      "embedding": []
    },
    {
      "slug": "type RestrictParams struct {",
      "content": "type RestrictParams struct {\n\t// ProbabilitySource is a callback that is expected to return the\n\t// success probability of traversing the channel from the node.\n\tProbabilitySource func(route.Vertex, route.Vertex,\n\t\tlnwire.MilliSatoshi, btcutil.Amount) float64\n\n\t// FeeLimit is a maximum fee amount allowed to be used on the path from\n\t// the source to the target.\n\tFeeLimit lnwire.MilliSatoshi\n\n\t// OutgoingChannelIDs is the list of channels that are allowed for the\n\t// first hop. If nil, any channel may be used.\n\tOutgoingChannelIDs []uint64\n\n\t// LastHop is the pubkey of the last node before the final destination\n\t// is reached. If nil, any node may be used.\n\tLastHop *route.Vertex\n\n\t// CltvLimit is the maximum time lock of the route excluding the final\n\t// ctlv. After path finding is complete, the caller needs to increase\n\t// all cltv expiry heights with the required final cltv delta.\n\tCltvLimit uint32\n\n\t// DestCustomRecords contains the custom records to drop off at the\n\t// final hop, if any.\n\tDestCustomRecords record.CustomSet\n\n\t// DestFeatures is a feature vector describing what the final hop\n\t// supports. If none are provided, pathfinding will try to inspect any\n\t// features on the node announcement instead.\n\tDestFeatures *lnwire.FeatureVector\n\n\t// PaymentAddr is a random 32-byte value generated by the receiver to\n\t// mitigate probing vectors and payment sniping attacks on overpaid\n\t// invoices.\n\tPaymentAddr *[32]byte\n\n\t// Metadata is additional data that is sent along with the payment to\n\t// the payee.\n\tMetadata []byte\n}\n\n// PathFindingConfig defines global parameters that control the trade-off in\n// path finding between fees and probabiity.",
      "length": 1599,
      "tokens": 249,
      "embedding": []
    },
    {
      "slug": "type PathFindingConfig struct {",
      "content": "type PathFindingConfig struct {\n\t// AttemptCost is the fixed virtual cost in path finding of a failed\n\t// payment attempt. It is used to trade off potentially better routes\n\t// against their probability of succeeding.\n\tAttemptCost lnwire.MilliSatoshi\n\n\t// AttemptCostPPM is the proportional virtual cost in path finding of a\n\t// failed payment attempt. It is used to trade off potentially better\n\t// routes against their probability of succeeding. This parameter is\n\t// expressed in parts per million of the total payment amount.\n\tAttemptCostPPM int64\n\n\t// MinProbability defines the minimum success probability of the\n\t// returned route.\n\tMinProbability float64\n}\n\n// getOutgoingBalance returns the maximum available balance in any of the\n// channels of the given node. The second return parameters is the total\n// available balance.",
      "length": 784,
      "tokens": 122,
      "embedding": []
    },
    {
      "slug": "func getOutgoingBalance(node route.Vertex, outgoingChans map[uint64]struct{},",
      "content": "func getOutgoingBalance(node route.Vertex, outgoingChans map[uint64]struct{},\n\tbandwidthHints bandwidthHints,\n\tg routingGraph) (lnwire.MilliSatoshi, lnwire.MilliSatoshi, error) {\n\n\tvar max, total lnwire.MilliSatoshi\n\tcb := func(channel *channeldb.DirectedChannel) error {\n\t\tif !channel.OutPolicySet {\n\t\t\treturn nil\n\t\t}\n\n\t\tchanID := channel.ChannelID\n\n\t\t// Enforce outgoing channel restriction.\n\t\tif outgoingChans != nil {\n\t\t\tif _, ok := outgoingChans[chanID]; !ok {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\n\t\tbandwidth, ok := bandwidthHints.availableChanBandwidth(\n\t\t\tchanID, 0,\n\t\t)\n\n\t\t// If the bandwidth is not available, use the channel capacity.\n\t\t// This can happen when a channel is added to the graph after\n\t\t// we've already queried the bandwidth hints.\n\t\tif !ok {\n\t\t\tbandwidth = lnwire.NewMSatFromSatoshis(channel.Capacity)\n\t\t}\n\n\t\tif bandwidth > max {\n\t\t\tmax = bandwidth\n\t\t}\n\n\t\ttotal += bandwidth\n\n\t\treturn nil\n\t}\n\n\t// Iterate over all channels of the to node.\n\terr := g.forEachNodeChannel(node, cb)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\treturn max, total, err\n}\n\n// findPath attempts to find a path from the source node within the ChannelGraph\n// to the target node that's capable of supporting a payment of `amt` value. The\n// current approach implemented is modified version of Dijkstra's algorithm to\n// find a single shortest path between the source node and the destination. The\n// distance metric used for edges is related to the time-lock+fee costs along a\n// particular edge. If a path is found, this function returns a slice of\n// ChannelHop structs which encoded the chosen path from the target to the\n// source. The search is performed backwards from destination node back to\n// source. This is to properly accumulate fees that need to be paid along the\n// path and accurately check the amount to forward at every node against the\n// available bandwidth.",
      "length": 1727,
      "tokens": 275,
      "embedding": []
    },
    {
      "slug": "func findPath(g *graphParams, r *RestrictParams, cfg *PathFindingConfig,",
      "content": "func findPath(g *graphParams, r *RestrictParams, cfg *PathFindingConfig,\n\tsource, target route.Vertex, amt lnwire.MilliSatoshi, timePref float64,\n\tfinalHtlcExpiry int32) ([]*channeldb.CachedEdgePolicy, float64, error) {\n\n\t// Pathfinding can be a significant portion of the total payment\n\t// latency, especially on low-powered devices. Log several metrics to\n\t// aid in the analysis performance problems in this area.\n\tstart := time.Now()\n\tnodesVisited := 0\n\tedgesExpanded := 0\n\tdefer func() {\n\t\ttimeElapsed := time.Since(start)\n\t\tlog.Debugf(\"Pathfinding perf metrics: nodes=%v, edges=%v, \"+\n\t\t\t\"time=%v\", nodesVisited, edgesExpanded, timeElapsed)\n\t}()\n\n\t// If no destination features are provided, we will load what features\n\t// we have for the target node from our graph.\n\tfeatures := r.DestFeatures\n\tif features == nil {\n\t\tvar err error\n\t\tfeatures, err = g.graph.fetchNodeFeatures(target)\n\t\tif err != nil {\n\t\t\treturn nil, 0, err\n\t\t}\n\t}\n\n\t// Ensure that the destination's features don't include unknown\n\t// required features.\n\terr := feature.ValidateRequired(features)\n\tif err != nil {\n\t\tlog.Warnf(\"Pathfinding destination node features: %v\", err)\n\t\treturn nil, 0, errUnknownRequiredFeature\n\t}\n\n\t// Ensure that all transitive dependencies are set.\n\terr = feature.ValidateDeps(features)\n\tif err != nil {\n\t\tlog.Warnf(\"Pathfinding destination node features: %v\", err)\n\t\treturn nil, 0, errMissingDependentFeature\n\t}\n\n\t// Now that we know the feature vector is well formed, we'll proceed in\n\t// checking that it supports the features we need, given our\n\t// restrictions on the final hop.\n\n\t// If the caller needs to send custom records, check that our\n\t// destination feature vector supports TLV.\n\tif len(r.DestCustomRecords) > 0 &&\n\t\t!features.HasFeature(lnwire.TLVOnionPayloadOptional) {\n\n\t\treturn nil, 0, errNoTlvPayload\n\t}\n\n\t// If the caller has a payment address to attach, check that our\n\t// destination feature vector supports them.\n\tif r.PaymentAddr != nil &&\n\t\t!features.HasFeature(lnwire.PaymentAddrOptional) {\n\n\t\treturn nil, 0, errNoPaymentAddr\n\t}\n\n\t// If the caller needs to send custom records, check that our\n\t// destination feature vector supports TLV.\n\tif r.Metadata != nil &&\n\t\t!features.HasFeature(lnwire.TLVOnionPayloadOptional) {\n\n\t\treturn nil, 0, errNoTlvPayload\n\t}\n\n\t// Set up outgoing channel map for quicker access.\n\tvar outgoingChanMap map[uint64]struct{}\n\tif len(r.OutgoingChannelIDs) > 0 {\n\t\toutgoingChanMap = make(map[uint64]struct{})\n\t\tfor _, outChan := range r.OutgoingChannelIDs {\n\t\t\toutgoingChanMap[outChan] = struct{}{}\n\t\t}\n\t}\n\n\t// If we are routing from ourselves, check that we have enough local\n\t// balance available.\n\tself := g.graph.sourceNode()\n\n\tif source == self {\n\t\tmax, total, err := getOutgoingBalance(\n\t\t\tself, outgoingChanMap, g.bandwidthHints, g.graph,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, 0, err\n\t\t}\n\n\t\t// If the total outgoing balance isn't sufficient, it will be\n\t\t// impossible to complete the payment.\n\t\tif total < amt {\n\t\t\treturn nil, 0, errInsufficientBalance\n\t\t}\n\n\t\t// If there is only not enough capacity on a single route, it\n\t\t// may still be possible to complete the payment by splitting.\n\t\tif max < amt {\n\t\t\treturn nil, 0, errNoPathFound\n\t\t}\n\t}\n\n\t// First we'll initialize an empty heap which'll help us to quickly\n\t// locate the next edge we should visit next during our graph\n\t// traversal.\n\tnodeHeap := newDistanceHeap(estimatedNodeCount)\n\n\t// Holds the current best distance for a given node.\n\tdistance := make(map[route.Vertex]*nodeWithDist, estimatedNodeCount)\n\n\tadditionalEdgesWithSrc := make(map[route.Vertex][]*edgePolicyWithSource)\n\tfor vertex, outgoingEdgePolicies := range g.additionalEdges {\n\t\t// Edges connected to self are always included in the graph,\n\t\t// therefore can be skipped. This prevents us from trying\n\t\t// routes to malformed hop hints.\n\t\tif vertex == self {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Build reverse lookup to find incoming edges. Needed because\n\t\t// search is taken place from target to source.\n\t\tfor _, outgoingEdgePolicy := range outgoingEdgePolicies {\n\t\t\ttoVertex := outgoingEdgePolicy.ToNodePubKey()\n\n\t\t\tincomingEdgePolicy := &edgePolicyWithSource{\n\t\t\t\tsourceNode: vertex,\n\t\t\t\tedge:       outgoingEdgePolicy,\n\t\t\t}\n\n\t\t\tadditionalEdgesWithSrc[toVertex] =\n\t\t\t\tappend(additionalEdgesWithSrc[toVertex],\n\t\t\t\t\tincomingEdgePolicy)\n\t\t}\n\t}\n\n\t// Build a preliminary destination hop structure to obtain the payload\n\t// size.\n\tvar mpp *record.MPP\n\tif r.PaymentAddr != nil {\n\t\tmpp = record.NewMPP(amt, *r.PaymentAddr)\n\t}\n\n\tfinalHop := route.Hop{\n\t\tAmtToForward:     amt,\n\t\tOutgoingTimeLock: uint32(finalHtlcExpiry),\n\t\tCustomRecords:    r.DestCustomRecords,\n\t\tLegacyPayload: !features.HasFeature(\n\t\t\tlnwire.TLVOnionPayloadOptional,\n\t\t),\n\t\tMPP:      mpp,\n\t\tMetadata: r.Metadata,\n\t}\n\n\t// We can't always assume that the end destination is publicly\n\t// advertised to the network so we'll manually include the target node.\n\t// The target node charges no fee. Distance is set to 0, because this is\n\t// the starting point of the graph traversal. We are searching backwards\n\t// to get the fees first time right and correctly match channel\n\t// bandwidth.\n\t//\n\t// Don't record the initial partial path in the distance map and reserve\n\t// that key for the source key in the case we route to ourselves.\n\tpartialPath := &nodeWithDist{\n\t\tdist:            0,\n\t\tweight:          0,\n\t\tnode:            target,\n\t\tamountToReceive: amt,\n\t\tincomingCltv:    finalHtlcExpiry,\n\t\tprobability:     1,\n\t\troutingInfoSize: finalHop.PayloadSize(0),\n\t}\n\n\t// Calculate the absolute cltv limit. Use uint64 to prevent an overflow\n\t// if the cltv limit is MaxUint32.\n\tabsoluteCltvLimit := uint64(r.CltvLimit) + uint64(finalHtlcExpiry)\n\n\t// Calculate the default attempt cost as configured globally.\n\tdefaultAttemptCost := float64(\n\t\tcfg.AttemptCost +\n\t\t\tamt*lnwire.MilliSatoshi(cfg.AttemptCostPPM)/1000000,\n\t)\n\n\t// Validate time preference value.\n\tif math.Abs(timePref) > 1 {\n\t\treturn nil, 0, fmt.Errorf(\"time preference %v out of range \"+\n\t\t\t\"[-1, 1]\", timePref)\n\t}\n\n\t// Scale to avoid the extremes -1 and 1 which run into infinity issues.\n\ttimePref *= 0.9\n\n\t// Apply time preference. At 0, the default attempt cost will\n\t// be used.\n\tabsoluteAttemptCost := defaultAttemptCost * (1/(0.5-timePref/2) - 1)\n\n\tlog.Debugf(\"Pathfinding absolute attempt cost: %v sats\",\n\t\tabsoluteAttemptCost/1000)\n\n\t// processEdge is a helper closure that will be used to make sure edges\n\t// satisfy our specific requirements.\n\tprocessEdge := func(fromVertex route.Vertex,\n\t\tfromFeatures *lnwire.FeatureVector,\n\t\tedge *unifiedEdge, toNodeDist *nodeWithDist) {\n\n\t\tedgesExpanded++\n\n\t\t// Calculate amount that the candidate node would have to send\n\t\t// out.\n\t\tamountToSend := toNodeDist.amountToReceive\n\n\t\t// Request the success probability for this edge.\n\t\tedgeProbability := r.ProbabilitySource(\n\t\t\tfromVertex, toNodeDist.node, amountToSend,\n\t\t\tedge.capacity,\n\t\t)\n\n\t\tlog.Trace(newLogClosure(func() string {\n\t\t\treturn fmt.Sprintf(\"path finding probability: fromnode=%v,\"+\n\t\t\t\t\" tonode=%v, amt=%v, cap=%v, probability=%v\",\n\t\t\t\tfromVertex, toNodeDist.node, amountToSend,\n\t\t\t\tedge.capacity, edgeProbability)\n\t\t}))\n\n\t\t// If the probability is zero, there is no point in trying.\n\t\tif edgeProbability == 0 {\n\t\t\treturn\n\t\t}\n\n\t\t// Compute fee that fromVertex is charging. It is based on the\n\t\t// amount that needs to be sent to the next node in the route.\n\t\t//\n\t\t// Source node has no predecessor to pay a fee. Therefore set\n\t\t// fee to zero, because it should not be included in the fee\n\t\t// limit check and edge weight.\n\t\t//\n\t\t// Also determine the time lock delta that will be added to the\n\t\t// route if fromVertex is selected. If fromVertex is the source\n\t\t// node, no additional timelock is required.\n\t\tvar fee lnwire.MilliSatoshi\n\t\tvar timeLockDelta uint16\n\t\tif fromVertex != source {\n\t\t\tfee = edge.policy.ComputeFee(amountToSend)\n\t\t\ttimeLockDelta = edge.policy.TimeLockDelta\n\t\t}\n\n\t\tincomingCltv := toNodeDist.incomingCltv + int32(timeLockDelta)\n\n\t\t// Check that we are within our CLTV limit.\n\t\tif uint64(incomingCltv) > absoluteCltvLimit {\n\t\t\treturn\n\t\t}\n\n\t\t// amountToReceive is the amount that the node that is added to\n\t\t// the distance map needs to receive from a (to be found)\n\t\t// previous node in the route. That previous node will need to\n\t\t// pay the amount that this node forwards plus the fee it\n\t\t// charges.\n\t\tamountToReceive := amountToSend + fee\n\n\t\t// Check if accumulated fees would exceed fee limit when this\n\t\t// node would be added to the path.\n\t\ttotalFee := amountToReceive - amt\n\t\tif totalFee > r.FeeLimit {\n\t\t\treturn\n\t\t}\n\n\t\t// Calculate total probability of successfully reaching target\n\t\t// by multiplying the probabilities. Both this edge and the rest\n\t\t// of the route must succeed.\n\t\tprobability := toNodeDist.probability * edgeProbability\n\n\t\t// If the probability is below the specified lower bound, we can\n\t\t// abandon this direction. Adding further nodes can only lower\n\t\t// the probability more.\n\t\tif probability < cfg.MinProbability {\n\t\t\treturn\n\t\t}\n\n\t\t// By adding fromVertex in the route, there will be an extra\n\t\t// weight composed of the fee that this node will charge and\n\t\t// the amount that will be locked for timeLockDelta blocks in\n\t\t// the HTLC that is handed out to fromVertex.\n\t\tweight := edgeWeight(amountToReceive, fee, timeLockDelta)\n\n\t\t// Compute the tentative weight to this new channel/edge\n\t\t// which is the weight from our toNode to the target node\n\t\t// plus the weight of this edge.\n\t\ttempWeight := toNodeDist.weight + weight\n\n\t\t// Add an extra factor to the weight to take into account the\n\t\t// probability.\n\t\ttempDist := getProbabilityBasedDist(\n\t\t\ttempWeight, probability,\n\t\t\tabsoluteAttemptCost,\n\t\t)\n\n\t\t// If there is already a best route stored, compare this\n\t\t// candidate route with the best route so far.\n\t\tcurrent, ok := distance[fromVertex]\n\t\tif ok {\n\t\t\t// If this route is worse than what we already found,\n\t\t\t// skip this route.\n\t\t\tif tempDist > current.dist {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// If the route is equally good and the probability\n\t\t\t// isn't better, skip this route. It is important to\n\t\t\t// also return if both cost and probability are equal,\n\t\t\t// because otherwise the algorithm could run into an\n\t\t\t// endless loop.\n\t\t\tprobNotBetter := probability <= current.probability\n\t\t\tif tempDist == current.dist && probNotBetter {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\t// Every edge should have a positive time lock delta. If we\n\t\t// encounter a zero delta, log a warning line.\n\t\tif edge.policy.TimeLockDelta == 0 {\n\t\t\tlog.Warnf(\"Channel %v has zero cltv delta\",\n\t\t\t\tedge.policy.ChannelID)\n\t\t}\n\n\t\t// Calculate the total routing info size if this hop were to be\n\t\t// included. If we are coming from the source hop, the payload\n\t\t// size is zero, because the original htlc isn't in the onion\n\t\t// blob.\n\t\tvar payloadSize uint64\n\t\tif fromVertex != source {\n\t\t\tsupportsTlv := fromFeatures.HasFeature(\n\t\t\t\tlnwire.TLVOnionPayloadOptional,\n\t\t\t)\n\n\t\t\thop := route.Hop{\n\t\t\t\tAmtToForward: amountToSend,\n\t\t\t\tOutgoingTimeLock: uint32(\n\t\t\t\t\ttoNodeDist.incomingCltv,\n\t\t\t\t),\n\t\t\t\tLegacyPayload: !supportsTlv,\n\t\t\t}\n\n\t\t\tpayloadSize = hop.PayloadSize(edge.policy.ChannelID)\n\t\t}\n\n\t\troutingInfoSize := toNodeDist.routingInfoSize + payloadSize\n\n\t\t// Skip paths that would exceed the maximum routing info size.\n\t\tif routingInfoSize > sphinx.MaxPayloadSize {\n\t\t\treturn\n\t\t}\n\n\t\t// All conditions are met and this new tentative distance is\n\t\t// better than the current best known distance to this node.\n\t\t// The new better distance is recorded, and also our \"next hop\"\n\t\t// map is populated with this edge.\n\t\twithDist := &nodeWithDist{\n\t\t\tdist:            tempDist,\n\t\t\tweight:          tempWeight,\n\t\t\tnode:            fromVertex,\n\t\t\tamountToReceive: amountToReceive,\n\t\t\tincomingCltv:    incomingCltv,\n\t\t\tprobability:     probability,\n\t\t\tnextHop:         edge.policy,\n\t\t\troutingInfoSize: routingInfoSize,\n\t\t}\n\t\tdistance[fromVertex] = withDist\n\n\t\t// Either push withDist onto the heap if the node\n\t\t// represented by fromVertex is not already on the heap OR adjust\n\t\t// its position within the heap via heap.Fix.\n\t\tnodeHeap.PushOrFix(withDist)\n\t}\n\n\t// TODO(roasbeef): also add path caching\n\t//  * similar to route caching, but doesn't factor in the amount\n\n\t// Cache features because we visit nodes multiple times.\n\tfeatureCache := make(map[route.Vertex]*lnwire.FeatureVector)\n\n\t// getGraphFeatures returns (cached) node features from the graph.\n\tgetGraphFeatures := func(node route.Vertex) (*lnwire.FeatureVector,\n\t\terror) {\n\n\t\t// Check cache for features of the fromNode.\n\t\tfromFeatures, ok := featureCache[node]\n\t\tif ok {\n\t\t\treturn fromFeatures, nil\n\t\t}\n\n\t\t// Fetch node features fresh from the graph.\n\t\tfromFeatures, err := g.graph.fetchNodeFeatures(node)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Don't route through nodes that contain unknown required\n\t\t// features and mark as nil in the cache.\n\t\terr = feature.ValidateRequired(fromFeatures)\n\t\tif err != nil {\n\t\t\tfeatureCache[node] = nil\n\t\t\treturn nil, nil\n\t\t}\n\n\t\t// Don't route through nodes that don't properly set all\n\t\t// transitive feature dependencies and mark as nil in the cache.\n\t\terr = feature.ValidateDeps(fromFeatures)\n\t\tif err != nil {\n\t\t\tfeatureCache[node] = nil\n\t\t\treturn nil, nil\n\t\t}\n\n\t\t// Update cache.\n\t\tfeatureCache[node] = fromFeatures\n\n\t\treturn fromFeatures, nil\n\t}\n\n\trouteToSelf := source == target\n\tfor {\n\t\tnodesVisited++\n\n\t\tpivot := partialPath.node\n\n\t\t// Create unified edges for all incoming connections.\n\t\tu := newNodeEdgeUnifier(self, pivot, outgoingChanMap)\n\n\t\terr := u.addGraphPolicies(g.graph)\n\t\tif err != nil {\n\t\t\treturn nil, 0, err\n\t\t}\n\n\t\tfor _, reverseEdge := range additionalEdgesWithSrc[pivot] {\n\t\t\tu.addPolicy(reverseEdge.sourceNode, reverseEdge.edge, 0)\n\t\t}\n\n\t\tamtToSend := partialPath.amountToReceive\n\n\t\t// Expand all connections using the optimal policy for each\n\t\t// connection.\n\t\tfor fromNode, edgeUnifier := range u.edgeUnifiers {\n\t\t\t// The target node is not recorded in the distance map.\n\t\t\t// Therefore we need to have this check to prevent\n\t\t\t// creating a cycle. Only when we intend to route to\n\t\t\t// self, we allow this cycle to form. In that case we'll\n\t\t\t// also break out of the search loop below.\n\t\t\tif !routeToSelf && fromNode == target {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Apply last hop restriction if set.\n\t\t\tif r.LastHop != nil &&\n\t\t\t\tpivot == target && fromNode != *r.LastHop {\n\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tedge := edgeUnifier.getEdge(\n\t\t\t\tamtToSend, g.bandwidthHints,\n\t\t\t)\n\n\t\t\tif edge == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Get feature vector for fromNode.\n\t\t\tfromFeatures, err := getGraphFeatures(fromNode)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, 0, err\n\t\t\t}\n\n\t\t\t// If there are no valid features, skip this node.\n\t\t\tif fromFeatures == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Check if this candidate node is better than what we\n\t\t\t// already have.\n\t\t\tprocessEdge(fromNode, fromFeatures, edge, partialPath)\n\t\t}\n\n\t\tif nodeHeap.Len() == 0 {\n\t\t\tbreak\n\t\t}\n\n\t\t// Fetch the node within the smallest distance from our source\n\t\t// from the heap.\n\t\tpartialPath = heap.Pop(&nodeHeap).(*nodeWithDist)\n\n\t\t// If we've reached our source (or we don't have any incoming\n\t\t// edges), then we're done here and can exit the graph\n\t\t// traversal early.\n\t\tif partialPath.node == source {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Use the distance map to unravel the forward path from source to\n\t// target.\n\tvar pathEdges []*channeldb.CachedEdgePolicy\n\tcurrentNode := source\n\tfor {\n\t\t// Determine the next hop forward using the next map.\n\t\tcurrentNodeWithDist, ok := distance[currentNode]\n\t\tif !ok {\n\t\t\t// If the node doesn't have a next hop it means we\n\t\t\t// didn't find a path.\n\t\t\treturn nil, 0, errNoPathFound\n\t\t}\n\n\t\t// Add the next hop to the list of path edges.\n\t\tpathEdges = append(pathEdges, currentNodeWithDist.nextHop)\n\n\t\t// Advance current node.\n\t\tcurrentNode = currentNodeWithDist.nextHop.ToNodePubKey()\n\n\t\t// Check stop condition at the end of this loop. This prevents\n\t\t// breaking out too soon for self-payments that have target set\n\t\t// to source.\n\t\tif currentNode == target {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// For the final hop, we'll set the node features to those determined\n\t// above. These are either taken from the destination features, e.g.\n\t// virtual or invoice features, or loaded as a fallback from the graph.\n\t// The transitive dependencies were already validated above, so no need\n\t// to do so now.\n\t//\n\t// NOTE: This may overwrite features loaded from the graph if\n\t// destination features were provided. This is fine though, since our\n\t// route construction does not care where the features are actually\n\t// taken from. In the future we may wish to do route construction within\n\t// findPath, and avoid using ChannelEdgePolicy altogether.\n\tpathEdges[len(pathEdges)-1].ToNodeFeatures = features\n\n\tlog.Debugf(\"Found route: probability=%v, hops=%v, fee=%v\",\n\t\tdistance[source].probability, len(pathEdges),\n\t\tdistance[source].amountToReceive-amt)\n\n\treturn pathEdges, distance[source].probability, nil\n}\n\n// getProbabilityBasedDist converts a weight into a distance that takes into\n// account the success probability and the (virtual) cost of a failed payment\n// attempt.\n//\n// Derivation:\n//\n// Suppose there are two routes A and B with fees Fa and Fb and success\n// probabilities Pa and Pb.\n//\n// Is the expected cost of trying route A first and then B lower than trying the\n// other way around?\n//\n// The expected cost of A-then-B is: Pa*Fa + (1-Pa)*Pb*(c+Fb)\n//\n// The expected cost of B-then-A is: Pb*Fb + (1-Pb)*Pa*(c+Fa)\n//\n// In these equations, the term representing the case where both A and B fail is\n// left out because its value would be the same in both cases.\n//\n// Pa*Fa + (1-Pa)*Pb*(c+Fb) < Pb*Fb + (1-Pb)*Pa*(c+Fa)\n//\n// Pa*Fa + Pb*c + Pb*Fb - Pa*Pb*c - Pa*Pb*Fb < Pb*Fb + Pa*c + Pa*Fa - Pa*Pb*c - Pa*Pb*Fa\n//\n// Removing terms that cancel out:\n// Pb*c - Pa*Pb*Fb < Pa*c - Pa*Pb*Fa\n//\n// Divide by Pa*Pb:\n// c/Pa - Fb < c/Pb - Fa\n//\n// Move terms around:\n// Fa + c/Pa < Fb + c/Pb\n//\n// So the value of F + c/P can be used to compare routes.",
      "length": 17286,
      "tokens": 2539,
      "embedding": []
    },
    {
      "slug": "func getProbabilityBasedDist(weight int64, probability float64,",
      "content": "func getProbabilityBasedDist(weight int64, probability float64,\n\tpenalty float64) int64 {\n\n\t// Prevent divide by zero by returning early.\n\tif probability == 0 {\n\t\treturn infinity\n\t}\n\n\t// Calculate distance.\n\tdist := float64(weight) + penalty/probability\n\n\t// Avoid cast if an overflow would occur. The maxFloat constant is\n\t// chosen to stay well below the maximum float64 value that is still\n\t// convertable to int64.\n\tconst maxFloat = 9000000000000000000\n\tif dist > maxFloat {\n\t\treturn infinity\n\t}\n\n\treturn int64(dist)\n}\n",
      "length": 439,
      "tokens": 72,
      "embedding": []
    }
  ]
}