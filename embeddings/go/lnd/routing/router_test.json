{
  "filepath": "../implementations/go/lnd/routing/router_test.go",
  "package": "routing",
  "sections": [
    {
      "slug": "type testCtx struct {",
      "content": "type testCtx struct {\n\trouter *ChannelRouter\n\n\tgraph *channeldb.ChannelGraph\n\n\taliases map[string]route.Vertex\n\n\tprivKeys map[string]*btcec.PrivateKey\n\n\tchannelIDs map[route.Vertex]map[route.Vertex]uint64\n\n\tchain *mockChain\n\n\tchainView *mockChainView\n\n\tnotifier *lnmock.ChainNotifier\n}\n",
      "length": 248,
      "tokens": 17,
      "embedding": []
    },
    {
      "slug": "func (c *testCtx) getChannelIDFromAlias(t *testing.T, a, b string) uint64 {",
      "content": "func (c *testCtx) getChannelIDFromAlias(t *testing.T, a, b string) uint64 {\n\tvertexA, ok := c.aliases[a]\n\trequire.True(t, ok, \"cannot find aliases for %s\", a)\n\n\tvertexB, ok := c.aliases[b]\n\trequire.True(t, ok, \"cannot find aliases for %s\", b)\n\n\tchannelIDMap, ok := c.channelIDs[vertexA]\n\trequire.True(t, ok, \"cannot find channelID map %s(%s)\", vertexA, a)\n\n\tchannelID, ok := channelIDMap[vertexB]\n\trequire.True(t, ok, \"cannot find channelID using %s(%s)\", vertexB, b)\n\n\treturn channelID\n}\n",
      "length": 399,
      "tokens": 53,
      "embedding": []
    },
    {
      "slug": "func (c *testCtx) RestartRouter(t *testing.T) {",
      "content": "func (c *testCtx) RestartRouter(t *testing.T) {\n\t// First, we'll reset the chainView's state as it doesn't persist the\n\t// filter between restarts.\n\tc.chainView.Reset()\n\n\t// With the chainView reset, we'll now re-create the router itself, and\n\t// start it.\n\trouter, err := New(Config{\n\t\tGraph:              c.graph,\n\t\tChain:              c.chain,\n\t\tChainView:          c.chainView,\n\t\tPayer:              &mockPaymentAttemptDispatcherOld{},\n\t\tControl:            makeMockControlTower(),\n\t\tChannelPruneExpiry: time.Hour * 24,\n\t\tGraphPruneInterval: time.Hour * 2,\n\t\tIsAlias: func(scid lnwire.ShortChannelID) bool {\n\t\t\treturn false\n\t\t},\n\t})\n\trequire.NoError(t, err, \"unable to create router\")\n\trequire.NoError(t, router.Start(), \"unable to start router\")\n\n\t// Finally, we'll swap out the pointer in the testCtx with this fresh\n\t// instance of the router.\n\tc.router = router\n}\n",
      "length": 799,
      "tokens": 97,
      "embedding": []
    },
    {
      "slug": "func createTestCtxFromGraphInstance(t *testing.T,",
      "content": "func createTestCtxFromGraphInstance(t *testing.T,\n\tstartingHeight uint32, graphInstance *testGraphInstance,\n\tstrictPruning bool) *testCtx {\n\n\treturn createTestCtxFromGraphInstanceAssumeValid(\n\t\tt, startingHeight, graphInstance, false, strictPruning,\n\t)\n}\n",
      "length": 198,
      "tokens": 17,
      "embedding": []
    },
    {
      "slug": "func createTestCtxFromGraphInstanceAssumeValid(t *testing.T,",
      "content": "func createTestCtxFromGraphInstanceAssumeValid(t *testing.T,\n\tstartingHeight uint32, graphInstance *testGraphInstance,\n\tassumeValid bool, strictPruning bool) *testCtx {\n\n\t// We'll initialize an instance of the channel router with mock\n\t// versions of the chain and channel notifier. As we don't need to test\n\t// any p2p functionality, the peer send and switch send messages won't\n\t// be populated.\n\tchain := newMockChain(startingHeight)\n\tchainView := newMockChainView(chain)\n\n\tpathFindingConfig := PathFindingConfig{\n\t\tMinProbability: 0.01,\n\t\tAttemptCost:    100,\n\t}\n\n\taCfg := AprioriConfig{\n\t\tPenaltyHalfLife:       time.Hour,\n\t\tAprioriHopProbability: 0.9,\n\t\tAprioriWeight:         0.5,\n\t\tCapacityFraction:      testCapacityFraction,\n\t}\n\testimator, err := NewAprioriEstimator(aCfg)\n\trequire.NoError(t, err)\n\n\tmcConfig := &MissionControlConfig{Estimator: estimator}\n\n\tmc, err := NewMissionControl(\n\t\tgraphInstance.graphBackend, route.Vertex{}, mcConfig,\n\t)\n\trequire.NoError(t, err, \"failed to create missioncontrol\")\n\n\tsourceNode, err := graphInstance.graph.SourceNode()\n\trequire.NoError(t, err)\n\tsessionSource := &SessionSource{\n\t\tGraph:             graphInstance.graph,\n\t\tSourceNode:        sourceNode,\n\t\tGetLink:           graphInstance.getLink,\n\t\tPathFindingConfig: pathFindingConfig,\n\t\tMissionControl:    mc,\n\t}\n\n\tnotifier := &lnmock.ChainNotifier{\n\t\tEpochChan: make(chan *chainntnfs.BlockEpoch),\n\t\tSpendChan: make(chan *chainntnfs.SpendDetail),\n\t\tConfChan:  make(chan *chainntnfs.TxConfirmation),\n\t}\n\n\trouter, err := New(Config{\n\t\tGraph:              graphInstance.graph,\n\t\tChain:              chain,\n\t\tChainView:          chainView,\n\t\tPayer:              &mockPaymentAttemptDispatcherOld{},\n\t\tNotifier:           notifier,\n\t\tControl:            makeMockControlTower(),\n\t\tMissionControl:     mc,\n\t\tSessionSource:      sessionSource,\n\t\tChannelPruneExpiry: time.Hour * 24,\n\t\tGraphPruneInterval: time.Hour * 2,\n\t\tGetLink:            graphInstance.getLink,\n\t\tNextPaymentID: func() (uint64, error) {\n\t\t\tnext := atomic.AddUint64(&uniquePaymentID, 1)\n\t\t\treturn next, nil\n\t\t},\n\t\tPathFindingConfig:   pathFindingConfig,\n\t\tClock:               clock.NewTestClock(time.Unix(1, 0)),\n\t\tAssumeChannelValid:  assumeValid,\n\t\tStrictZombiePruning: strictPruning,\n\t\tIsAlias: func(scid lnwire.ShortChannelID) bool {\n\t\t\treturn false\n\t\t},\n\t})\n\trequire.NoError(t, err, \"unable to create router\")\n\trequire.NoError(t, router.Start(), \"unable to start router\")\n\n\tctx := &testCtx{\n\t\trouter:     router,\n\t\tgraph:      graphInstance.graph,\n\t\taliases:    graphInstance.aliasMap,\n\t\tprivKeys:   graphInstance.privKeyMap,\n\t\tchannelIDs: graphInstance.channelIDs,\n\t\tchain:      chain,\n\t\tchainView:  chainView,\n\t\tnotifier:   notifier,\n\t}\n\n\tt.Cleanup(func() {\n\t\tctx.router.Stop()\n\t})\n\n\treturn ctx\n}\n",
      "length": 2616,
      "tokens": 233,
      "embedding": []
    },
    {
      "slug": "func createTestCtxSingleNode(t *testing.T,",
      "content": "func createTestCtxSingleNode(t *testing.T,\n\tstartingHeight uint32) *testCtx {\n\n\tgraph, graphBackend, err := makeTestGraph(t, true)\n\trequire.NoError(t, err, \"failed to make test graph\")\n\n\tsourceNode, err := createTestNode()\n\trequire.NoError(t, err, \"failed to create test node\")\n\n\trequire.NoError(t,\n\t\tgraph.SetSourceNode(sourceNode), \"failed to set source node\",\n\t)\n\n\tgraphInstance := &testGraphInstance{\n\t\tgraph:        graph,\n\t\tgraphBackend: graphBackend,\n\t}\n\n\treturn createTestCtxFromGraphInstance(\n\t\tt, startingHeight, graphInstance, false,\n\t)\n}\n",
      "length": 486,
      "tokens": 52,
      "embedding": []
    },
    {
      "slug": "func createTestCtxFromFile(t *testing.T,",
      "content": "func createTestCtxFromFile(t *testing.T,\n\tstartingHeight uint32, testGraph string) *testCtx {\n\n\t// We'll attempt to locate and parse out the file\n\t// that encodes the graph that our tests should be run against.\n\tgraphInstance, err := parseTestGraph(t, true, testGraph)\n\trequire.NoError(t, err, \"unable to create test graph\")\n\n\treturn createTestCtxFromGraphInstance(\n\t\tt, startingHeight, graphInstance, false,\n\t)\n}\n\n// Add valid signature to channel update simulated as error received from the\n// network.",
      "length": 450,
      "tokens": 64,
      "embedding": []
    },
    {
      "slug": "func signErrChanUpdate(t *testing.T, key *btcec.PrivateKey,",
      "content": "func signErrChanUpdate(t *testing.T, key *btcec.PrivateKey,\n\terrChanUpdate *lnwire.ChannelUpdate) {\n\n\tchanUpdateMsg, err := errChanUpdate.DataToSign()\n\trequire.NoError(t, err, \"failed to retrieve data to sign\")\n\n\tdigest := chainhash.DoubleHashB(chanUpdateMsg)\n\tsig := ecdsa.Sign(key, digest)\n\n\terrChanUpdate.Signature, err = lnwire.NewSigFromSignature(sig)\n\trequire.NoError(t, err, \"failed to create new signature\")\n}\n\n// TestFindRoutesWithFeeLimit asserts that routes found by the FindRoutes method\n// within the channel router contain a total fee less than or equal to the fee\n// limit.",
      "length": 514,
      "tokens": 62,
      "embedding": []
    },
    {
      "slug": "func TestFindRoutesWithFeeLimit(t *testing.T) {",
      "content": "func TestFindRoutesWithFeeLimit(t *testing.T) {\n\tt.Parallel()\n\n\tconst startingBlockHeight = 101\n\tctx := createTestCtxFromFile(t, startingBlockHeight, basicGraphFilePath)\n\n\t// This test will attempt to find routes from roasbeef to sophon for 100\n\t// satoshis with a fee limit of 10 satoshis. There are two routes from\n\t// roasbeef to sophon:\n\t//\t1. roasbeef -> songoku -> sophon\n\t//\t2. roasbeef -> phamnuwen -> sophon\n\t// The second route violates our fee limit, so we should only expect to\n\t// see the first route.\n\ttarget := ctx.aliases[\"sophon\"]\n\tpaymentAmt := lnwire.NewMSatFromSatoshis(100)\n\trestrictions := &RestrictParams{\n\t\tFeeLimit:          lnwire.NewMSatFromSatoshis(10),\n\t\tProbabilitySource: noProbabilitySource,\n\t\tCltvLimit:         math.MaxUint32,\n\t}\n\n\troute, _, err := ctx.router.FindRoute(\n\t\tctx.router.selfNode.PubKeyBytes,\n\t\ttarget, paymentAmt, 0, restrictions, nil, nil,\n\t\tMinCLTVDelta,\n\t)\n\trequire.NoError(t, err, \"unable to find any routes\")\n\n\trequire.Falsef(t,\n\t\troute.TotalFees() > restrictions.FeeLimit,\n\t\t\"route exceeded fee limit: %v\", spew.Sdump(route),\n\t)\n\n\thops := route.Hops\n\trequire.Equal(t, 2, len(hops), \"expected 2 hops\")\n\n\trequire.Equalf(t,\n\t\tctx.aliases[\"songoku\"], hops[0].PubKeyBytes,\n\t\t\"expected first hop through songoku, got %s\",\n\t\tgetAliasFromPubKey(hops[0].PubKeyBytes, ctx.aliases),\n\t)\n}\n\n// TestSendPaymentRouteFailureFallback tests that when sending a payment, if\n// one of the target routes is seen as unavailable, then the next route in the\n// queue is used instead. This process should continue until either a payment\n// succeeds, or all routes have been exhausted.",
      "length": 1520,
      "tokens": 192,
      "embedding": []
    },
    {
      "slug": "func TestSendPaymentRouteFailureFallback(t *testing.T) {",
      "content": "func TestSendPaymentRouteFailureFallback(t *testing.T) {\n\tt.Parallel()\n\n\tconst startingBlockHeight = 101\n\tctx := createTestCtxFromFile(t, startingBlockHeight, basicGraphFilePath)\n\n\t// Craft a LightningPayment struct that'll send a payment from roasbeef\n\t// to luo ji for 1000 satoshis, with a maximum of 1000 satoshis in fees.\n\tvar payHash lntypes.Hash\n\tpaymentAmt := lnwire.NewMSatFromSatoshis(1000)\n\tpayment := LightningPayment{\n\t\tTarget:      ctx.aliases[\"sophon\"],\n\t\tAmount:      paymentAmt,\n\t\tFeeLimit:    noFeeLimit,\n\t\tpaymentHash: &payHash,\n\t}\n\n\tvar preImage [32]byte\n\tcopy(preImage[:], bytes.Repeat([]byte{9}, 32))\n\n\t// Get the channel ID.\n\troasbeefSongoku := lnwire.NewShortChanIDFromInt(\n\t\tctx.getChannelIDFromAlias(t, \"roasbeef\", \"songoku\"),\n\t)\n\n\t// We'll modify the SendToSwitch method that's been set within the\n\t// router's configuration to ignore the path that has son goku as the\n\t// first hop. This should force the router to instead take the\n\t// the more costly path (through pham nuwen).\n\tctx.router.cfg.Payer.(*mockPaymentAttemptDispatcherOld).setPaymentResult(\n\t\tfunc(firstHop lnwire.ShortChannelID) ([32]byte, error) {\n\n\t\t\tif firstHop == roasbeefSongoku {\n\t\t\t\treturn [32]byte{}, htlcswitch.NewForwardingError(\n\t\t\t\t\t// TODO(roasbeef): temp node failure\n\t\t\t\t\t//  should be?\n\t\t\t\t\t&lnwire.FailTemporaryChannelFailure{},\n\t\t\t\t\t1,\n\t\t\t\t)\n\t\t\t}\n\n\t\t\treturn preImage, nil\n\t\t})\n\n\t// Send off the payment request to the router, route through pham nuwen\n\t// should've been selected as a fall back and succeeded correctly.\n\tpaymentPreImage, route, err := ctx.router.SendPayment(&payment)\n\trequire.NoError(t, err, \"unable to send payment\")\n\n\t// The route selected should have two hops\n\trequire.Equal(t, 2, len(route.Hops), \"incorrect route length\")\n\n\t// The preimage should match up with the once created above.\n\tif !bytes.Equal(paymentPreImage[:], preImage[:]) {\n\t\tt.Fatalf(\"incorrect preimage used: expected %x got %x\",\n\t\t\tpreImage[:], paymentPreImage[:])\n\t}\n\n\t// The route should have pham nuwen as the first hop.\n\trequire.Equalf(t,\n\t\tctx.aliases[\"phamnuwen\"], route.Hops[0].PubKeyBytes,\n\t\t\"route should go through phamnuwen as first hop, instead \"+\n\t\t\t\"passes through: %v\",\n\t\tgetAliasFromPubKey(route.Hops[0].PubKeyBytes, ctx.aliases),\n\t)\n}\n\n// TestSendPaymentRouteInfiniteLoopWithBadHopHint tests that when sending\n// a payment with a malformed hop hint in the first hop, the hint is ignored\n// and the payment succeeds without an infinite loop of retries.",
      "length": 2341,
      "tokens": 284,
      "embedding": []
    },
    {
      "slug": "func TestSendPaymentRouteInfiniteLoopWithBadHopHint(t *testing.T) {",
      "content": "func TestSendPaymentRouteInfiniteLoopWithBadHopHint(t *testing.T) {\n\tt.Parallel()\n\n\tconst startingBlockHeight = 101\n\tctx := createTestCtxFromFile(t, startingBlockHeight, basicGraphFilePath)\n\n\tsource := ctx.aliases[\"roasbeef\"]\n\tsourceNodeID, err := btcec.ParsePubKey(source[:])\n\trequire.NoError(t, err)\n\n\tactualChannelID := ctx.getChannelIDFromAlias(t, \"roasbeef\", \"songoku\")\n\tbadChannelID := uint64(66666)\n\n\t// Craft a LightningPayment struct that'll send a payment from roasbeef\n\t// to songoku for 1000 satoshis.\n\tvar payHash lntypes.Hash\n\tpaymentAmt := lnwire.NewMSatFromSatoshis(1000)\n\tpayment := LightningPayment{\n\t\tTarget:      ctx.aliases[\"songoku\"],\n\t\tAmount:      paymentAmt,\n\t\tFeeLimit:    noFeeLimit,\n\t\tpaymentHash: &payHash,\n\t\tRouteHints: [][]zpay32.HopHint{{\n\t\t\tzpay32.HopHint{\n\t\t\t\tNodeID:          sourceNodeID,\n\t\t\t\tChannelID:       badChannelID,\n\t\t\t\tFeeBaseMSat:     uint32(50),\n\t\t\t\tCLTVExpiryDelta: uint16(200),\n\t\t\t},\n\t\t}},\n\t}\n\n\tvar preImage [32]byte\n\tcopy(preImage[:], bytes.Repeat([]byte{9}, 32))\n\n\t// Mock a payment result that always fails with FailUnknownNextPeer when\n\t// the bad channel is the first hop.\n\tbadShortChanID := lnwire.NewShortChanIDFromInt(badChannelID)\n\tnewFwdError := htlcswitch.NewForwardingError(\n\t\t&lnwire.FailUnknownNextPeer{}, 0,\n\t)\n\n\tpayer, ok := ctx.router.cfg.Payer.(*mockPaymentAttemptDispatcherOld)\n\trequire.Equal(t, ok, true, \"failed Payer cast\")\n\n\tpayer.setPaymentResult(\n\t\tfunc(firstHop lnwire.ShortChannelID) ([32]byte, error) {\n\t\t\t// Returns a FailUnknownNextPeer if it's trying\n\t\t\t// to pay an invalid channel.\n\t\t\tif firstHop == badShortChanID {\n\t\t\t\treturn [32]byte{}, newFwdError\n\t\t\t}\n\n\t\t\treturn preImage, nil\n\t\t})\n\n\t// Send off the payment request to the router, should succeed\n\t// ignoring the bad channel id hint.\n\tpaymentPreImage, route, paymentErr := ctx.router.SendPayment(&payment)\n\trequire.NoError(t, paymentErr, \"payment returned an error\")\n\n\t// The preimage should match up with the one created above.\n\trequire.Equal(t, preImage[:], paymentPreImage[:], \"incorrect preimage\")\n\n\t// The route should have songoku as the first hop.\n\trequire.Equal(t, actualChannelID, route.Hops[0].ChannelID,\n\t\t\"route should go through the correct channel id\",\n\t)\n}\n\n// TestChannelUpdateValidation tests that a failed payment with an associated\n// channel update will only be applied to the graph when the update contains a\n// valid signature.",
      "length": 2247,
      "tokens": 247,
      "embedding": []
    },
    {
      "slug": "func TestChannelUpdateValidation(t *testing.T) {",
      "content": "func TestChannelUpdateValidation(t *testing.T) {\n\tt.Parallel()\n\n\t// Setup a three node network.\n\tchanCapSat := btcutil.Amount(100000)\n\tfeeRate := lnwire.MilliSatoshi(400)\n\ttestChannels := []*testChannel{\n\t\tsymmetricTestChannel(\"a\", \"b\", chanCapSat, &testChannelPolicy{\n\t\t\tExpiry:  144,\n\t\t\tFeeRate: feeRate,\n\t\t\tMinHTLC: 1,\n\t\t\tMaxHTLC: lnwire.NewMSatFromSatoshis(chanCapSat),\n\t\t}, 1),\n\t\tsymmetricTestChannel(\"b\", \"c\", chanCapSat, &testChannelPolicy{\n\t\t\tExpiry:  144,\n\t\t\tFeeRate: feeRate,\n\t\t\tMinHTLC: 1,\n\t\t\tMaxHTLC: lnwire.NewMSatFromSatoshis(chanCapSat),\n\t\t}, 2),\n\t}\n\n\ttestGraph, err := createTestGraphFromChannels(\n\t\tt, true, testChannels, \"a\",\n\t)\n\trequire.NoError(t, err, \"unable to create graph\")\n\n\tconst startingBlockHeight = 101\n\tctx := createTestCtxFromGraphInstance(\n\t\tt, startingBlockHeight, testGraph, true,\n\t)\n\n\t// Assert that the initially configured fee is retrieved correctly.\n\t_, e1, e2, err := ctx.router.GetChannelByID(\n\t\tlnwire.NewShortChanIDFromInt(1),\n\t)\n\trequire.NoError(t, err, \"cannot retrieve channel\")\n\n\trequire.Equal(t, feeRate, e1.FeeProportionalMillionths, \"invalid fee\")\n\trequire.Equal(t, feeRate, e2.FeeProportionalMillionths, \"invalid fee\")\n\n\t// Setup a route from source a to destination c. The route will be used\n\t// in a call to SendToRoute. SendToRoute also applies channel updates,\n\t// but it saves us from including RequestRoute in the test scope too.\n\thop1 := ctx.aliases[\"b\"]\n\thop2 := ctx.aliases[\"c\"]\n\thops := []*route.Hop{\n\t\t{\n\t\t\tChannelID:     1,\n\t\t\tPubKeyBytes:   hop1,\n\t\t\tLegacyPayload: true,\n\t\t},\n\t\t{\n\t\t\tChannelID:     2,\n\t\t\tPubKeyBytes:   hop2,\n\t\t\tLegacyPayload: true,\n\t\t},\n\t}\n\n\trt, err := route.NewRouteFromHops(\n\t\tlnwire.MilliSatoshi(10000), 100,\n\t\tctx.aliases[\"a\"], hops,\n\t)\n\trequire.NoError(t, err, \"unable to create route\")\n\n\t// Set up a channel update message with an invalid signature to be\n\t// returned to the sender.\n\tvar invalidSignature [64]byte\n\terrChanUpdate := lnwire.ChannelUpdate{\n\t\tSignature:       invalidSignature,\n\t\tFeeRate:         500,\n\t\tShortChannelID:  lnwire.NewShortChanIDFromInt(1),\n\t\tTimestamp:       uint32(testTime.Add(time.Minute).Unix()),\n\t\tMessageFlags:    e2.MessageFlags,\n\t\tChannelFlags:    e2.ChannelFlags,\n\t\tHtlcMaximumMsat: e2.MaxHTLC,\n\t}\n\n\t// We'll modify the SendToSwitch method so that it simulates a failed\n\t// payment with an error originating from the first hop of the route.\n\t// The unsigned channel update is attached to the failure message.\n\tctx.router.cfg.Payer.(*mockPaymentAttemptDispatcherOld).setPaymentResult(\n\t\tfunc(firstHop lnwire.ShortChannelID) ([32]byte, error) {\n\t\t\treturn [32]byte{}, htlcswitch.NewForwardingError(\n\t\t\t\t&lnwire.FailFeeInsufficient{\n\t\t\t\t\tUpdate: errChanUpdate,\n\t\t\t\t},\n\t\t\t\t1,\n\t\t\t)\n\t\t})\n\n\t// The payment parameter is mostly redundant in SendToRoute. Can be left\n\t// empty for this test.\n\tvar payment lntypes.Hash\n\n\t// Send off the payment request to the router. The specified route\n\t// should be attempted and the channel update should be received by\n\t// router and ignored because it is missing a valid signature.\n\t_, err = ctx.router.SendToRoute(payment, rt)\n\trequire.Error(t, err, \"expected route to fail with channel update\")\n\n\t_, e1, e2, err = ctx.router.GetChannelByID(\n\t\tlnwire.NewShortChanIDFromInt(1),\n\t)\n\trequire.NoError(t, err, \"cannot retrieve channel\")\n\n\trequire.Equal(t, feeRate, e1.FeeProportionalMillionths,\n\t\t\"fee updated without valid signature\")\n\trequire.Equal(t, feeRate, e2.FeeProportionalMillionths,\n\t\t\"fee updated without valid signature\")\n\n\t// Next, add a signature to the channel update.\n\tsignErrChanUpdate(t, testGraph.privKeyMap[\"b\"], &errChanUpdate)\n\n\t// Retry the payment using the same route as before.\n\t_, err = ctx.router.SendToRoute(payment, rt)\n\trequire.Error(t, err, \"expected route to fail with channel update\")\n\n\t// This time a valid signature was supplied and the policy change should\n\t// have been applied to the graph.\n\t_, e1, e2, err = ctx.router.GetChannelByID(\n\t\tlnwire.NewShortChanIDFromInt(1),\n\t)\n\trequire.NoError(t, err, \"cannot retrieve channel\")\n\n\trequire.Equal(t, feeRate, e1.FeeProportionalMillionths,\n\t\t\"fee should not be updated\")\n\trequire.EqualValues(t, 500, int(e2.FeeProportionalMillionths),\n\t\t\"fee not updated even though signature is valid\")\n}\n\n// TestSendPaymentErrorRepeatedFeeInsufficient tests that if we receive\n// multiple fee related errors from a channel that we're attempting to route\n// through, then we'll prune the channel after the second attempt.",
      "length": 4253,
      "tokens": 494,
      "embedding": []
    },
    {
      "slug": "func TestSendPaymentErrorRepeatedFeeInsufficient(t *testing.T) {",
      "content": "func TestSendPaymentErrorRepeatedFeeInsufficient(t *testing.T) {\n\tt.Parallel()\n\n\tconst startingBlockHeight = 101\n\tctx := createTestCtxFromFile(t, startingBlockHeight, basicGraphFilePath)\n\n\t// Get the channel ID.\n\troasbeefSongokuChanID := ctx.getChannelIDFromAlias(\n\t\tt, \"roasbeef\", \"songoku\",\n\t)\n\tsongokuSophonChanID := ctx.getChannelIDFromAlias(\n\t\tt, \"songoku\", \"sophon\",\n\t)\n\n\t// Craft a LightningPayment struct that'll send a payment from roasbeef\n\t// to sophon for 1000 satoshis.\n\tvar payHash lntypes.Hash\n\tamt := lnwire.NewMSatFromSatoshis(1000)\n\tpayment := LightningPayment{\n\t\tTarget:      ctx.aliases[\"sophon\"],\n\t\tAmount:      amt,\n\t\tFeeLimit:    noFeeLimit,\n\t\tpaymentHash: &payHash,\n\t}\n\n\tvar preImage [32]byte\n\tcopy(preImage[:], bytes.Repeat([]byte{9}, 32))\n\n\t// We'll also fetch the first outgoing channel edge from son goku\n\t// to sophon. We'll obtain this as we'll need to to generate the\n\t// FeeInsufficient error that we'll send back.\n\t_, _, edgeUpdateToFail, err := ctx.graph.FetchChannelEdgesByID(\n\t\tsongokuSophonChanID,\n\t)\n\trequire.NoError(t, err, \"unable to fetch chan id\")\n\n\terrChanUpdate := lnwire.ChannelUpdate{\n\t\tShortChannelID: lnwire.NewShortChanIDFromInt(\n\t\t\tsongokuSophonChanID,\n\t\t),\n\t\tTimestamp:       uint32(edgeUpdateToFail.LastUpdate.Unix()),\n\t\tMessageFlags:    edgeUpdateToFail.MessageFlags,\n\t\tChannelFlags:    edgeUpdateToFail.ChannelFlags,\n\t\tTimeLockDelta:   edgeUpdateToFail.TimeLockDelta,\n\t\tHtlcMinimumMsat: edgeUpdateToFail.MinHTLC,\n\t\tHtlcMaximumMsat: edgeUpdateToFail.MaxHTLC,\n\t\tBaseFee:         uint32(edgeUpdateToFail.FeeBaseMSat),\n\t\tFeeRate:         uint32(edgeUpdateToFail.FeeProportionalMillionths),\n\t}\n\n\tsignErrChanUpdate(t, ctx.privKeys[\"songoku\"], &errChanUpdate)\n\n\t// We'll now modify the SendToSwitch method to return an error for the\n\t// outgoing channel to Son goku. This will be a fee related error, so\n\t// it should only cause the edge to be pruned after the second attempt.\n\tctx.router.cfg.Payer.(*mockPaymentAttemptDispatcherOld).setPaymentResult(\n\t\tfunc(firstHop lnwire.ShortChannelID) ([32]byte, error) {\n\n\t\t\troasbeefSongoku := lnwire.NewShortChanIDFromInt(\n\t\t\t\troasbeefSongokuChanID,\n\t\t\t)\n\t\t\tif firstHop == roasbeefSongoku {\n\t\t\t\treturn [32]byte{}, htlcswitch.NewForwardingError(\n\t\t\t\t\t// Within our error, we'll add a\n\t\t\t\t\t// channel update which is meant to\n\t\t\t\t\t// reflect the new fee schedule for the\n\t\t\t\t\t// node/channel.\n\t\t\t\t\t&lnwire.FailFeeInsufficient{\n\t\t\t\t\t\tUpdate: errChanUpdate,\n\t\t\t\t\t}, 1,\n\t\t\t\t)\n\t\t\t}\n\n\t\t\treturn preImage, nil\n\t\t})\n\n\t// Send off the payment request to the router, route through phamnuwen\n\t// should've been selected as a fall back and succeeded correctly.\n\tpaymentPreImage, route, err := ctx.router.SendPayment(&payment)\n\trequire.NoError(t, err, \"unable to send payment\")\n\n\t// The route selected should have two hops\n\trequire.Equal(t, 2, len(route.Hops), \"incorrect route length\")\n\n\t// The preimage should match up with the once created above.\n\trequire.Equal(t, preImage[:], paymentPreImage[:], \"incorrect preimage\")\n\n\t// The route should have pham nuwen as the first hop.\n\trequire.Equalf(t,\n\t\tctx.aliases[\"phamnuwen\"], route.Hops[0].PubKeyBytes,\n\t\t\"route should go through pham nuwen as first hop, \"+\n\t\t\t\"instead passes through: %v\",\n\t\tgetAliasFromPubKey(route.Hops[0].PubKeyBytes, ctx.aliases),\n\t)\n}\n\n// TestSendPaymentErrorFeeInsufficientPrivateEdge tests that if we receive\n// a fee related error from a private channel that we're attempting to route\n// through, then we'll update the fees in the route hints and successfully\n// route through the private channel in the second attempt.\n//\n// The test will send a payment from roasbeef to elst, available paths are,\n// path1: roasbeef -> songoku -> sophon -> elst, total fee: 210k\n// path2: roasbeef -> phamnuwen -> sophon -> elst, total fee: 220k\n// path3: roasbeef -> songoku ->(private channel) elst\n// We will setup the path3 to have the lowest fee so it's always the preferred\n// path.",
      "length": 3752,
      "tokens": 444,
      "embedding": []
    },
    {
      "slug": "func TestSendPaymentErrorFeeInsufficientPrivateEdge(t *testing.T) {",
      "content": "func TestSendPaymentErrorFeeInsufficientPrivateEdge(t *testing.T) {\n\tt.Parallel()\n\n\tconst startingBlockHeight = 101\n\tctx := createTestCtxFromFile(t, startingBlockHeight, basicGraphFilePath)\n\n\t// Get the channel ID.\n\troasbeefSongoku := lnwire.NewShortChanIDFromInt(\n\t\tctx.getChannelIDFromAlias(t, \"roasbeef\", \"songoku\"),\n\t)\n\n\tvar (\n\t\tpayHash          lntypes.Hash\n\t\tpreImage         [32]byte\n\t\tamt              = lnwire.NewMSatFromSatoshis(1000)\n\t\tprivateChannelID = uint64(55555)\n\t\tfeeBaseMSat      = uint32(15)\n\t\texpiryDelta      = uint16(32)\n\t\tsgNode           = ctx.aliases[\"songoku\"]\n\t)\n\n\tsgNodeID, err := btcec.ParsePubKey(sgNode[:])\n\trequire.NoError(t, err)\n\n\t// Craft a LightningPayment struct that'll send a payment from roasbeef\n\t// to elst, through a private channel between songoku and elst for\n\t// 1000 satoshis. This route has lowest fees compared with the rest.\n\t// This also holds when the private channel fee is updated to a higher\n\t// value.\n\tpayment := LightningPayment{\n\t\tTarget:      ctx.aliases[\"elst\"],\n\t\tAmount:      amt,\n\t\tFeeLimit:    noFeeLimit,\n\t\tpaymentHash: &payHash,\n\t\tRouteHints: [][]zpay32.HopHint{{\n\t\t\t// Add a private channel between songoku and elst.\n\t\t\tzpay32.HopHint{\n\t\t\t\tNodeID:          sgNodeID,\n\t\t\t\tChannelID:       privateChannelID,\n\t\t\t\tFeeBaseMSat:     feeBaseMSat,\n\t\t\t\tCLTVExpiryDelta: expiryDelta,\n\t\t\t},\n\t\t}},\n\t}\n\n\t// Prepare an error update for the private channel, with twice the\n\t// original fee.\n\tupdatedFeeBaseMSat := feeBaseMSat * 2\n\terrChanUpdate := lnwire.ChannelUpdate{\n\t\tShortChannelID: lnwire.NewShortChanIDFromInt(privateChannelID),\n\t\tTimestamp:      uint32(testTime.Add(time.Minute).Unix()),\n\t\tBaseFee:        updatedFeeBaseMSat,\n\t\tTimeLockDelta:  expiryDelta,\n\t}\n\tsignErrChanUpdate(t, ctx.privKeys[\"songoku\"], &errChanUpdate)\n\n\t// We'll now modify the SendHTLC method to return an error for the\n\t// outgoing channel to songoku.\n\terrorReturned := false\n\tcopy(preImage[:], bytes.Repeat([]byte{9}, 32))\n\tctx.router.cfg.Payer.(*mockPaymentAttemptDispatcherOld).setPaymentResult(\n\t\tfunc(firstHop lnwire.ShortChannelID) ([32]byte, error) {\n\t\t\tif firstHop != roasbeefSongoku || errorReturned {\n\t\t\t\treturn preImage, nil\n\t\t\t}\n\n\t\t\terrorReturned = true\n\t\t\treturn [32]byte{}, htlcswitch.NewForwardingError(\n\t\t\t\t// Within our error, we'll add a\n\t\t\t\t// channel update which is meant to\n\t\t\t\t// reflect the new fee schedule for the\n\t\t\t\t// node/channel.\n\t\t\t\t&lnwire.FailFeeInsufficient{\n\t\t\t\t\tUpdate: errChanUpdate,\n\t\t\t\t}, 1,\n\t\t\t)\n\t\t},\n\t)\n\n\t// Send off the payment request to the router, route through son\n\t// goku and then across the private channel to elst.\n\tpaymentPreImage, route, err := ctx.router.SendPayment(&payment)\n\trequire.NoError(t, err, \"unable to send payment\")\n\n\trequire.True(t, errorReturned,\n\t\t\"failed to simulate error in the first payment attempt\",\n\t)\n\n\t// The route selected should have two hops. Make sure that,\n\t//   path: roasbeef -> son goku -> sophon -> elst\n\t//   path: roasbeef -> pham nuwen -> sophon -> elst\n\t// are not selected instead.\n\trequire.Equal(t, 2, len(route.Hops), \"incorrect route length\")\n\n\t// The preimage should match up with the one created above.\n\trequire.Equal(t,\n\t\tpaymentPreImage[:], preImage[:], \"incorrect preimage used\",\n\t)\n\n\t// The route should have son goku as the first hop.\n\trequire.Equal(t, route.Hops[0].PubKeyBytes, ctx.aliases[\"songoku\"],\n\t\t\"route should go through son goku as first hop\",\n\t)\n\n\t// The route should pass via the private channel.\n\trequire.Equal(t,\n\t\tprivateChannelID, route.FinalHop().ChannelID,\n\t\t\"route did not pass through private channel \"+\n\t\t\t\"between pham nuwen and elst\",\n\t)\n\n\t// The route should have the updated fee.\n\trequire.Equal(t,\n\t\tlnwire.MilliSatoshi(updatedFeeBaseMSat).String(),\n\t\troute.HopFee(0).String(),\n\t\t\"fee to forward to the private channel not matched\",\n\t)\n}\n\n// TestSendPaymentPrivateEdgeUpdateFeeExceedsLimit tests that upon receiving a\n// ChannelUpdate in a fee related error from the private channel, we won't\n// choose the route in our second attempt if the updated fee exceeds our fee\n// limit specified in the payment.\n//\n// The test will send a payment from roasbeef to elst, available paths are,\n// path1: roasbeef -> songoku -> sophon -> elst, total fee: 210k\n// path2: roasbeef -> phamnuwen -> sophon -> elst, total fee: 220k\n// path3: roasbeef -> songoku ->(private channel) elst\n// We will setup the path3 to have the lowest fee and then update it with a fee\n// exceeds our fee limit, thus this route won't be chosen.",
      "length": 4275,
      "tokens": 543,
      "embedding": []
    },
    {
      "slug": "func TestSendPaymentPrivateEdgeUpdateFeeExceedsLimit(t *testing.T) {",
      "content": "func TestSendPaymentPrivateEdgeUpdateFeeExceedsLimit(t *testing.T) {\n\tt.Parallel()\n\n\tconst startingBlockHeight = 101\n\tctx := createTestCtxFromFile(t, startingBlockHeight, basicGraphFilePath)\n\n\t// Get the channel ID.\n\troasbeefSongoku := lnwire.NewShortChanIDFromInt(\n\t\tctx.getChannelIDFromAlias(t, \"roasbeef\", \"songoku\"),\n\t)\n\n\tvar (\n\t\tpayHash          lntypes.Hash\n\t\tpreImage         [32]byte\n\t\tamt              = lnwire.NewMSatFromSatoshis(1000)\n\t\tprivateChannelID = uint64(55555)\n\t\tfeeBaseMSat      = uint32(15)\n\t\texpiryDelta      = uint16(32)\n\t\tsgNode           = ctx.aliases[\"songoku\"]\n\t\tfeeLimit         = lnwire.MilliSatoshi(500000)\n\t)\n\n\tsgNodeID, err := btcec.ParsePubKey(sgNode[:])\n\trequire.NoError(t, err)\n\n\t// Craft a LightningPayment struct that'll send a payment from roasbeef\n\t// to elst, through a private channel between songoku and elst for\n\t// 1000 satoshis. This route has lowest fees compared with the rest.\n\tpayment := LightningPayment{\n\t\tTarget:      ctx.aliases[\"elst\"],\n\t\tAmount:      amt,\n\t\tFeeLimit:    feeLimit,\n\t\tpaymentHash: &payHash,\n\t\tRouteHints: [][]zpay32.HopHint{{\n\t\t\t// Add a private channel between songoku and elst.\n\t\t\tzpay32.HopHint{\n\t\t\t\tNodeID:          sgNodeID,\n\t\t\t\tChannelID:       privateChannelID,\n\t\t\t\tFeeBaseMSat:     feeBaseMSat,\n\t\t\t\tCLTVExpiryDelta: expiryDelta,\n\t\t\t},\n\t\t}},\n\t}\n\n\t// Prepare an error update for the private channel. The updated fee\n\t// will exceeds the feeLimit.\n\tupdatedFeeBaseMSat := feeBaseMSat + uint32(feeLimit)\n\terrChanUpdate := lnwire.ChannelUpdate{\n\t\tShortChannelID: lnwire.NewShortChanIDFromInt(privateChannelID),\n\t\tTimestamp:      uint32(testTime.Add(time.Minute).Unix()),\n\t\tBaseFee:        updatedFeeBaseMSat,\n\t\tTimeLockDelta:  expiryDelta,\n\t}\n\tsignErrChanUpdate(t, ctx.privKeys[\"songoku\"], &errChanUpdate)\n\n\t// We'll now modify the SendHTLC method to return an error for the\n\t// outgoing channel to songoku.\n\terrorReturned := false\n\tcopy(preImage[:], bytes.Repeat([]byte{9}, 32))\n\tctx.router.cfg.Payer.(*mockPaymentAttemptDispatcherOld).setPaymentResult(\n\t\tfunc(firstHop lnwire.ShortChannelID) ([32]byte, error) {\n\t\t\tif firstHop != roasbeefSongoku || errorReturned {\n\t\t\t\treturn preImage, nil\n\t\t\t}\n\n\t\t\terrorReturned = true\n\t\t\treturn [32]byte{}, htlcswitch.NewForwardingError(\n\t\t\t\t// Within our error, we'll add a\n\t\t\t\t// channel update which is meant to\n\t\t\t\t// reflect the new fee schedule for the\n\t\t\t\t// node/channel.\n\t\t\t\t&lnwire.FailFeeInsufficient{\n\t\t\t\t\tUpdate: errChanUpdate,\n\t\t\t\t}, 1,\n\t\t\t)\n\t\t},\n\t)\n\n\t// Send off the payment request to the router, route through son\n\t// goku and then across the private channel to elst.\n\tpaymentPreImage, route, err := ctx.router.SendPayment(&payment)\n\trequire.NoError(t, err, \"unable to send payment\")\n\n\trequire.True(t, errorReturned,\n\t\t\"failed to simulate error in the first payment attempt\",\n\t)\n\n\t// The route selected should have three hops. Make sure that,\n\t//   path1: roasbeef -> son goku -> sophon -> elst\n\t//   path2: roasbeef -> pham nuwen -> sophon -> elst\n\t//   path3: roasbeef -> sophon -> (private channel) else\n\t// path1 is selected.\n\trequire.Equal(t, 3, len(route.Hops), \"incorrect route length\")\n\n\t// The preimage should match up with the one created above.\n\trequire.Equal(t,\n\t\tpaymentPreImage[:], preImage[:], \"incorrect preimage used\",\n\t)\n\n\t// The route should have son goku as the first hop.\n\trequire.Equal(t, route.Hops[0].PubKeyBytes, ctx.aliases[\"songoku\"],\n\t\t\"route should go through son goku as the first hop\",\n\t)\n\n\t// The route should have sophon as the first hop.\n\trequire.Equal(t, route.Hops[1].PubKeyBytes, ctx.aliases[\"sophon\"],\n\t\t\"route should go through sophon as the second hop\",\n\t)\n\t// The route should pass via the public channel.\n\trequire.Equal(t, route.FinalHop().PubKeyBytes, ctx.aliases[\"elst\"],\n\t\t\"route should go through elst as the final hop\",\n\t)\n}\n\n// TestSendPaymentErrorNonFinalTimeLockErrors tests that if we receive either\n// an ExpiryTooSoon or a IncorrectCltvExpiry error from a node, then we prune\n// that node from the available graph within a mission control session. This\n// test ensures that we'll route around errors due to nodes not knowing the\n// current block height.",
      "length": 3947,
      "tokens": 474,
      "embedding": []
    },
    {
      "slug": "func TestSendPaymentErrorNonFinalTimeLockErrors(t *testing.T) {",
      "content": "func TestSendPaymentErrorNonFinalTimeLockErrors(t *testing.T) {\n\tt.Parallel()\n\n\tconst startingBlockHeight = 101\n\tctx := createTestCtxFromFile(\n\t\tt, startingBlockHeight, basicGraphFilePath,\n\t)\n\n\t// Craft a LightningPayment struct that'll send a payment from roasbeef\n\t// to sophon for 1k satoshis.\n\tvar payHash lntypes.Hash\n\tamt := lnwire.NewMSatFromSatoshis(1000)\n\tpayment := LightningPayment{\n\t\tTarget:      ctx.aliases[\"sophon\"],\n\t\tAmount:      amt,\n\t\tFeeLimit:    noFeeLimit,\n\t\tpaymentHash: &payHash,\n\t}\n\n\tvar preImage [32]byte\n\tcopy(preImage[:], bytes.Repeat([]byte{9}, 32))\n\n\t// We'll also fetch the first outgoing channel edge from roasbeef to\n\t// son goku. This edge will be included in the time lock related expiry\n\t// errors that we'll get back due to disagrements in what the current\n\t// block height is.\n\tchanID := ctx.getChannelIDFromAlias(t, \"roasbeef\", \"songoku\")\n\troasbeefSongoku := lnwire.NewShortChanIDFromInt(chanID)\n\n\t_, _, edgeUpdateToFail, err := ctx.graph.FetchChannelEdgesByID(chanID)\n\trequire.NoError(t, err, \"unable to fetch chan id\")\n\n\terrChanUpdate := lnwire.ChannelUpdate{\n\t\tShortChannelID:  lnwire.NewShortChanIDFromInt(chanID),\n\t\tTimestamp:       uint32(edgeUpdateToFail.LastUpdate.Unix()),\n\t\tMessageFlags:    edgeUpdateToFail.MessageFlags,\n\t\tChannelFlags:    edgeUpdateToFail.ChannelFlags,\n\t\tTimeLockDelta:   edgeUpdateToFail.TimeLockDelta,\n\t\tHtlcMinimumMsat: edgeUpdateToFail.MinHTLC,\n\t\tHtlcMaximumMsat: edgeUpdateToFail.MaxHTLC,\n\t\tBaseFee:         uint32(edgeUpdateToFail.FeeBaseMSat),\n\t\tFeeRate:         uint32(edgeUpdateToFail.FeeProportionalMillionths),\n\t}\n\n\t// We'll now modify the SendToSwitch method to return an error for the\n\t// outgoing channel to son goku. Since this is a time lock related\n\t// error, we should fail the payment flow all together, as Goku is the\n\t// only channel to Sophon.\n\tctx.router.cfg.Payer.(*mockPaymentAttemptDispatcherOld).setPaymentResult(\n\t\tfunc(firstHop lnwire.ShortChannelID) ([32]byte, error) {\n\t\t\tif firstHop == roasbeefSongoku {\n\t\t\t\treturn [32]byte{}, htlcswitch.NewForwardingError(\n\t\t\t\t\t&lnwire.FailExpiryTooSoon{\n\t\t\t\t\t\tUpdate: errChanUpdate,\n\t\t\t\t\t}, 1,\n\t\t\t\t)\n\t\t\t}\n\n\t\t\treturn preImage, nil\n\t\t})\n\n\t// assertExpectedPath is a helper function that asserts the returned\n\t// route properly routes around the failure we've introduced in the\n\t// graph.\n\tassertExpectedPath := func(retPreImage [32]byte, route *route.Route) {\n\t\t// The route selected should have two hops\n\t\trequire.Equal(t, 2, len(route.Hops), \"incorrect route length\")\n\n\t\t// The preimage should match up with the once created above.\n\t\trequire.Equal(t,\n\t\t\tpreImage[:], retPreImage[:], \"incorrect preimage used\",\n\t\t)\n\n\t\t// The route should have satoshi as the first hop.\n\t\trequire.Equalf(t,\n\t\t\tctx.aliases[\"phamnuwen\"], route.Hops[0].PubKeyBytes,\n\t\t\t\"route should go through phamnuwen as first hop, \"+\n\t\t\t\t\"instead passes through: %v\",\n\t\t\tgetAliasFromPubKey(\n\t\t\t\troute.Hops[0].PubKeyBytes, ctx.aliases,\n\t\t\t),\n\t\t)\n\t}\n\n\t// Send off the payment request to the router, this payment should\n\t// succeed as we should actually go through Pham Nuwen in order to get\n\t// to Sophon, even though he has higher fees.\n\tpaymentPreImage, rt, err := ctx.router.SendPayment(&payment)\n\trequire.NoError(t, err, \"unable to send payment\")\n\n\tassertExpectedPath(paymentPreImage, rt)\n\n\t// We'll now modify the error return an IncorrectCltvExpiry error\n\t// instead, this should result in the same behavior of roasbeef routing\n\t// around the faulty Son Goku node.\n\tctx.router.cfg.Payer.(*mockPaymentAttemptDispatcherOld).setPaymentResult(\n\t\tfunc(firstHop lnwire.ShortChannelID) ([32]byte, error) {\n\t\t\tif firstHop == roasbeefSongoku {\n\t\t\t\treturn [32]byte{}, htlcswitch.NewForwardingError(\n\t\t\t\t\t&lnwire.FailIncorrectCltvExpiry{\n\t\t\t\t\t\tUpdate: errChanUpdate,\n\t\t\t\t\t}, 1,\n\t\t\t\t)\n\t\t\t}\n\n\t\t\treturn preImage, nil\n\t\t})\n\n\t// Once again, Roasbeef should route around Goku since they disagree\n\t// w.r.t to the block height, and instead go through Pham Nuwen. We\n\t// flip a bit in the payment hash to allow resending this payment.\n\tpayment.paymentHash[1] ^= 1\n\tpaymentPreImage, rt, err = ctx.router.SendPayment(&payment)\n\trequire.NoError(t, err, \"unable to send payment\")\n\n\tassertExpectedPath(paymentPreImage, rt)\n}\n\n// TestSendPaymentErrorPathPruning tests that the send of candidate routes\n// properly gets pruned in response to ForwardingError response from the\n// underlying SendToSwitch function.",
      "length": 4208,
      "tokens": 483,
      "embedding": []
    },
    {
      "slug": "func TestSendPaymentErrorPathPruning(t *testing.T) {",
      "content": "func TestSendPaymentErrorPathPruning(t *testing.T) {\n\tt.Parallel()\n\n\tconst startingBlockHeight = 101\n\tctx := createTestCtxFromFile(t, startingBlockHeight, basicGraphFilePath)\n\n\t// Craft a LightningPayment struct that'll send a payment from roasbeef\n\t// to luo ji for 1000 satoshis, with a maximum of 1000 satoshis in fees.\n\tvar payHash lntypes.Hash\n\tpaymentAmt := lnwire.NewMSatFromSatoshis(1000)\n\tpayment := LightningPayment{\n\t\tTarget:      ctx.aliases[\"sophon\"],\n\t\tAmount:      paymentAmt,\n\t\tFeeLimit:    noFeeLimit,\n\t\tpaymentHash: &payHash,\n\t}\n\n\tvar preImage [32]byte\n\tcopy(preImage[:], bytes.Repeat([]byte{9}, 32))\n\n\troasbeefSongoku := lnwire.NewShortChanIDFromInt(\n\t\tctx.getChannelIDFromAlias(t, \"roasbeef\", \"songoku\"),\n\t)\n\troasbeefPhanNuwen := lnwire.NewShortChanIDFromInt(\n\t\tctx.getChannelIDFromAlias(t, \"roasbeef\", \"phamnuwen\"),\n\t)\n\n\t// First, we'll modify the SendToSwitch method to return an error\n\t// indicating that the channel from roasbeef to son goku is not operable\n\t// with an UnknownNextPeer.\n\tctx.router.cfg.Payer.(*mockPaymentAttemptDispatcherOld).setPaymentResult(\n\t\tfunc(firstHop lnwire.ShortChannelID) ([32]byte, error) {\n\n\t\t\tif firstHop == roasbeefSongoku {\n\t\t\t\t// We'll first simulate an error from the first\n\t\t\t\t// hop to simulate the channel from songoku to\n\t\t\t\t// sophon not having enough capacity.\n\t\t\t\treturn [32]byte{}, htlcswitch.NewForwardingError(\n\t\t\t\t\t&lnwire.FailTemporaryChannelFailure{},\n\t\t\t\t\t1,\n\t\t\t\t)\n\t\t\t}\n\n\t\t\t// Next, we'll create an error from phan nuwen to\n\t\t\t// indicate that the sophon node is not longer online,\n\t\t\t// which should prune out the rest of the routes.\n\t\t\tif firstHop == roasbeefPhanNuwen {\n\t\t\t\treturn [32]byte{}, htlcswitch.NewForwardingError(\n\t\t\t\t\t&lnwire.FailUnknownNextPeer{}, 1,\n\t\t\t\t)\n\t\t\t}\n\n\t\t\treturn preImage, nil\n\t\t})\n\n\tctx.router.cfg.MissionControl.(*MissionControl).ResetHistory()\n\n\t// When we try to dispatch that payment, we should receive an error as\n\t// both attempts should fail and cause both routes to be pruned.\n\t_, _, err := ctx.router.SendPayment(&payment)\n\trequire.Error(t, err, \"payment didn't return error\")\n\n\t// The final error returned should also indicate that the peer wasn't\n\t// online (the last error we returned).\n\trequire.Equal(t, channeldb.FailureReasonNoRoute, err)\n\n\t// Inspect the two attempts that were made before the payment failed.\n\tp, err := ctx.router.cfg.Control.FetchPayment(payHash)\n\trequire.NoError(t, err)\n\n\trequire.Equal(t, 2, len(p.HTLCs), \"expected two attempts\")\n\n\t// We expect the first attempt to have failed with a\n\t// TemporaryChannelFailure, the second with UnknownNextPeer.\n\tmsg := p.HTLCs[0].Failure.Message\n\t_, ok := msg.(*lnwire.FailTemporaryChannelFailure)\n\trequire.True(t, ok, \"unexpected fail message\")\n\n\tmsg = p.HTLCs[1].Failure.Message\n\t_, ok = msg.(*lnwire.FailUnknownNextPeer)\n\trequire.True(t, ok, \"unexpected fail message\")\n\n\terr = ctx.router.cfg.MissionControl.(*MissionControl).ResetHistory()\n\trequire.NoError(t, err, \"reset history failed\")\n\n\t// Next, we'll modify the SendToSwitch method to indicate that the\n\t// connection between songoku and isn't up.\n\tctx.router.cfg.Payer.(*mockPaymentAttemptDispatcherOld).setPaymentResult(\n\t\tfunc(firstHop lnwire.ShortChannelID) ([32]byte, error) {\n\n\t\t\tif firstHop == roasbeefSongoku {\n\t\t\t\tfailure := htlcswitch.NewForwardingError(\n\t\t\t\t\t&lnwire.FailUnknownNextPeer{}, 1,\n\t\t\t\t)\n\t\t\t\treturn [32]byte{}, failure\n\t\t\t}\n\n\t\t\treturn preImage, nil\n\t\t})\n\n\t// This shouldn't return an error, as we'll make a payment attempt via\n\t// the pham nuwen channel based on the assumption that there might be an\n\t// intermittent issue with the songoku <-> sophon channel.\n\tpaymentPreImage, rt, err := ctx.router.SendPayment(&payment)\n\trequire.NoError(t, err, \"unable send payment\")\n\n\t// This path should go: roasbeef -> pham nuwen -> sophon\n\trequire.Equal(t, 2, len(rt.Hops), \"incorrect route length\")\n\trequire.Equal(t, preImage[:], paymentPreImage[:], \"incorrect preimage\")\n\trequire.Equalf(t,\n\t\tctx.aliases[\"phamnuwen\"], rt.Hops[0].PubKeyBytes,\n\t\t\"route should go through phamnuwen as first hop, \"+\n\t\t\t\"instead passes through: %v\",\n\t\tgetAliasFromPubKey(rt.Hops[0].PubKeyBytes, ctx.aliases),\n\t)\n\n\tctx.router.cfg.MissionControl.(*MissionControl).ResetHistory()\n\n\t// Finally, we'll modify the SendToSwitch function to indicate that the\n\t// roasbeef -> luoji channel has insufficient capacity. This should\n\t// again cause us to instead go via the satoshi route.\n\tctx.router.cfg.Payer.(*mockPaymentAttemptDispatcherOld).setPaymentResult(\n\t\tfunc(firstHop lnwire.ShortChannelID) ([32]byte, error) {\n\n\t\t\tif firstHop == roasbeefSongoku {\n\t\t\t\t// We'll first simulate an error from the first\n\t\t\t\t// outgoing link to simulate the channel from luo ji to\n\t\t\t\t// roasbeef not having enough capacity.\n\t\t\t\treturn [32]byte{}, htlcswitch.NewForwardingError(\n\t\t\t\t\t&lnwire.FailTemporaryChannelFailure{},\n\t\t\t\t\t1,\n\t\t\t\t)\n\t\t\t}\n\t\t\treturn preImage, nil\n\t\t})\n\n\t// We flip a bit in the payment hash to allow resending this payment.\n\tpayment.paymentHash[1] ^= 1\n\tpaymentPreImage, rt, err = ctx.router.SendPayment(&payment)\n\trequire.NoError(t, err, \"unable send payment\")\n\n\t// This should succeed finally.  The route selected should have two\n\t// hops.\n\trequire.Equal(t, 2, len(rt.Hops), \"incorrect route length\")\n\n\t// The preimage should match up with the once created above.\n\trequire.Equal(t, preImage[:], paymentPreImage[:], \"incorrect preimage\")\n\n\t// The route should have satoshi as the first hop.\n\trequire.Equalf(t,\n\t\tctx.aliases[\"phamnuwen\"], rt.Hops[0].PubKeyBytes,\n\t\t\"route should go through phamnuwen as first hop, \"+\n\t\t\t\"instead passes through: %v\",\n\t\tgetAliasFromPubKey(rt.Hops[0].PubKeyBytes, ctx.aliases),\n\t)\n}\n\n// TestAddProof checks that we can update the channel proof after channel\n// info was added to the database.",
      "length": 5536,
      "tokens": 645,
      "embedding": []
    },
    {
      "slug": "func TestAddProof(t *testing.T) {",
      "content": "func TestAddProof(t *testing.T) {\n\tt.Parallel()\n\n\tctx := createTestCtxSingleNode(t, 0)\n\n\t// Before creating out edge, we'll create two new nodes within the\n\t// network that the channel will connect.\n\tnode1, err := createTestNode()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tnode2, err := createTestNode()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// In order to be able to add the edge we should have a valid funding\n\t// UTXO within the blockchain.\n\tfundingTx, _, chanID, err := createChannelEdge(ctx,\n\t\tbitcoinKey1.SerializeCompressed(), bitcoinKey2.SerializeCompressed(),\n\t\t100, 0)\n\trequire.NoError(t, err, \"unable create channel edge\")\n\tfundingBlock := &wire.MsgBlock{\n\t\tTransactions: []*wire.MsgTx{fundingTx},\n\t}\n\tctx.chain.addBlock(fundingBlock, chanID.BlockHeight, chanID.BlockHeight)\n\n\t// After utxo was recreated adding the edge without the proof.\n\tedge := &channeldb.ChannelEdgeInfo{\n\t\tChannelID:     chanID.ToUint64(),\n\t\tNodeKey1Bytes: node1.PubKeyBytes,\n\t\tNodeKey2Bytes: node2.PubKeyBytes,\n\t\tAuthProof:     nil,\n\t}\n\tcopy(edge.BitcoinKey1Bytes[:], bitcoinKey1.SerializeCompressed())\n\tcopy(edge.BitcoinKey2Bytes[:], bitcoinKey2.SerializeCompressed())\n\n\tif err := ctx.router.AddEdge(edge); err != nil {\n\t\tt.Fatalf(\"unable to add edge: %v\", err)\n\t}\n\n\t// Now we'll attempt to update the proof and check that it has been\n\t// properly updated.\n\tif err := ctx.router.AddProof(*chanID, &testAuthProof); err != nil {\n\t\tt.Fatalf(\"unable to add proof: %v\", err)\n\t}\n\n\tinfo, _, _, err := ctx.router.GetChannelByID(*chanID)\n\trequire.NoError(t, err, \"unable to get channel\")\n\tif info.AuthProof == nil {\n\t\tt.Fatal(\"proof have been updated\")\n\t}\n}\n\n// TestIgnoreNodeAnnouncement tests that adding a node to the router that is\n// not known from any channel announcement, leads to the announcement being\n// ignored.",
      "length": 1704,
      "tokens": 216,
      "embedding": []
    },
    {
      "slug": "func TestIgnoreNodeAnnouncement(t *testing.T) {",
      "content": "func TestIgnoreNodeAnnouncement(t *testing.T) {\n\tt.Parallel()\n\n\tconst startingBlockHeight = 101\n\tctx := createTestCtxFromFile(t, startingBlockHeight, basicGraphFilePath)\n\n\tpub := priv1.PubKey()\n\tnode := &channeldb.LightningNode{\n\t\tHaveNodeAnnouncement: true,\n\t\tLastUpdate:           time.Unix(123, 0),\n\t\tAddresses:            testAddrs,\n\t\tColor:                color.RGBA{1, 2, 3, 0},\n\t\tAlias:                \"node11\",\n\t\tAuthSigBytes:         testSig.Serialize(),\n\t\tFeatures:             testFeatures,\n\t}\n\tcopy(node.PubKeyBytes[:], pub.SerializeCompressed())\n\n\terr := ctx.router.AddNode(node)\n\tif !IsError(err, ErrIgnored) {\n\t\tt.Fatalf(\"expected to get ErrIgnore, instead got: %v\", err)\n\t}\n}\n\n// TestIgnoreChannelEdgePolicyForUnknownChannel checks that a router will\n// ignore a channel policy for a channel not in the graph.",
      "length": 753,
      "tokens": 73,
      "embedding": []
    },
    {
      "slug": "func TestIgnoreChannelEdgePolicyForUnknownChannel(t *testing.T) {",
      "content": "func TestIgnoreChannelEdgePolicyForUnknownChannel(t *testing.T) {\n\tt.Parallel()\n\n\tconst startingBlockHeight = 101\n\n\t// Setup an initially empty network.\n\ttestChannels := []*testChannel{}\n\ttestGraph, err := createTestGraphFromChannels(\n\t\tt, true, testChannels, \"roasbeef\",\n\t)\n\trequire.NoError(t, err, \"unable to create graph\")\n\n\tctx := createTestCtxFromGraphInstance(\n\t\tt, startingBlockHeight, testGraph, false,\n\t)\n\n\tvar pub1 [33]byte\n\tcopy(pub1[:], priv1.PubKey().SerializeCompressed())\n\n\tvar pub2 [33]byte\n\tcopy(pub2[:], priv2.PubKey().SerializeCompressed())\n\n\t// Add the edge between the two unknown nodes to the graph, and check\n\t// that the nodes are found after the fact.\n\tfundingTx, _, chanID, err := createChannelEdge(\n\t\tctx, bitcoinKey1.SerializeCompressed(),\n\t\tbitcoinKey2.SerializeCompressed(), 10000, 500,\n\t)\n\trequire.NoError(t, err, \"unable to create channel edge\")\n\tfundingBlock := &wire.MsgBlock{\n\t\tTransactions: []*wire.MsgTx{fundingTx},\n\t}\n\tctx.chain.addBlock(fundingBlock, chanID.BlockHeight, chanID.BlockHeight)\n\n\tedge := &channeldb.ChannelEdgeInfo{\n\t\tChannelID:        chanID.ToUint64(),\n\t\tNodeKey1Bytes:    pub1,\n\t\tNodeKey2Bytes:    pub2,\n\t\tBitcoinKey1Bytes: pub1,\n\t\tBitcoinKey2Bytes: pub2,\n\t\tAuthProof:        nil,\n\t}\n\tedgePolicy := &channeldb.ChannelEdgePolicy{\n\t\tSigBytes:                  testSig.Serialize(),\n\t\tChannelID:                 edge.ChannelID,\n\t\tLastUpdate:                testTime,\n\t\tTimeLockDelta:             10,\n\t\tMinHTLC:                   1,\n\t\tFeeBaseMSat:               10,\n\t\tFeeProportionalMillionths: 10000,\n\t}\n\n\t// Attempt to update the edge. This should be ignored, since the edge\n\t// is not yet added to the router.\n\terr = ctx.router.UpdateEdge(edgePolicy)\n\tif !IsError(err, ErrIgnored) {\n\t\tt.Fatalf(\"expected to get ErrIgnore, instead got: %v\", err)\n\t}\n\n\t// Add the edge.\n\tif err := ctx.router.AddEdge(edge); err != nil {\n\t\tt.Fatalf(\"expected to be able to add edge to the channel graph,\"+\n\t\t\t\" even though the vertexes were unknown: %v.\", err)\n\t}\n\n\t// Now updating the edge policy should succeed.\n\tif err := ctx.router.UpdateEdge(edgePolicy); err != nil {\n\t\tt.Fatalf(\"unable to update edge policy: %v\", err)\n\t}\n}\n\n// TestAddEdgeUnknownVertexes tests that if an edge is added that contains two\n// vertexes which we don't know of, the edge should be available for use\n// regardless. This is due to the fact that we don't actually need node\n// announcements for the channel vertexes to be able to use the channel.",
      "length": 2320,
      "tokens": 280,
      "embedding": []
    },
    {
      "slug": "func TestAddEdgeUnknownVertexes(t *testing.T) {",
      "content": "func TestAddEdgeUnknownVertexes(t *testing.T) {\n\tt.Parallel()\n\n\tconst startingBlockHeight = 101\n\tctx := createTestCtxFromFile(t, startingBlockHeight, basicGraphFilePath)\n\n\tvar pub1 [33]byte\n\tcopy(pub1[:], priv1.PubKey().SerializeCompressed())\n\n\tvar pub2 [33]byte\n\tcopy(pub2[:], priv2.PubKey().SerializeCompressed())\n\n\t// The two nodes we are about to add should not exist yet.\n\t_, exists1, err := ctx.graph.HasLightningNode(pub1)\n\trequire.NoError(t, err, \"unable to query graph\")\n\tif exists1 {\n\t\tt.Fatalf(\"node already existed\")\n\t}\n\t_, exists2, err := ctx.graph.HasLightningNode(pub2)\n\trequire.NoError(t, err, \"unable to query graph\")\n\tif exists2 {\n\t\tt.Fatalf(\"node already existed\")\n\t}\n\n\t// Add the edge between the two unknown nodes to the graph, and check\n\t// that the nodes are found after the fact.\n\tfundingTx, _, chanID, err := createChannelEdge(ctx,\n\t\tbitcoinKey1.SerializeCompressed(),\n\t\tbitcoinKey2.SerializeCompressed(),\n\t\t10000, 500,\n\t)\n\trequire.NoError(t, err, \"unable to create channel edge\")\n\tfundingBlock := &wire.MsgBlock{\n\t\tTransactions: []*wire.MsgTx{fundingTx},\n\t}\n\tctx.chain.addBlock(fundingBlock, chanID.BlockHeight, chanID.BlockHeight)\n\n\tedge := &channeldb.ChannelEdgeInfo{\n\t\tChannelID:        chanID.ToUint64(),\n\t\tNodeKey1Bytes:    pub1,\n\t\tNodeKey2Bytes:    pub2,\n\t\tBitcoinKey1Bytes: pub1,\n\t\tBitcoinKey2Bytes: pub2,\n\t\tAuthProof:        nil,\n\t}\n\tif err := ctx.router.AddEdge(edge); err != nil {\n\t\tt.Fatalf(\"expected to be able to add edge to the channel graph,\"+\n\t\t\t\" even though the vertexes were unknown: %v.\", err)\n\t}\n\n\t// We must add the edge policy to be able to use the edge for route\n\t// finding.\n\tedgePolicy := &channeldb.ChannelEdgePolicy{\n\t\tSigBytes:                  testSig.Serialize(),\n\t\tChannelID:                 edge.ChannelID,\n\t\tLastUpdate:                testTime,\n\t\tTimeLockDelta:             10,\n\t\tMinHTLC:                   1,\n\t\tFeeBaseMSat:               10,\n\t\tFeeProportionalMillionths: 10000,\n\t\tNode: &channeldb.LightningNode{\n\t\t\tPubKeyBytes: edge.NodeKey2Bytes,\n\t\t},\n\t}\n\tedgePolicy.ChannelFlags = 0\n\n\tif err := ctx.router.UpdateEdge(edgePolicy); err != nil {\n\t\tt.Fatalf(\"unable to update edge policy: %v\", err)\n\t}\n\n\t// Create edge in the other direction as well.\n\tedgePolicy = &channeldb.ChannelEdgePolicy{\n\t\tSigBytes:                  testSig.Serialize(),\n\t\tChannelID:                 edge.ChannelID,\n\t\tLastUpdate:                testTime,\n\t\tTimeLockDelta:             10,\n\t\tMinHTLC:                   1,\n\t\tFeeBaseMSat:               10,\n\t\tFeeProportionalMillionths: 10000,\n\t\tNode: &channeldb.LightningNode{\n\t\t\tPubKeyBytes: edge.NodeKey1Bytes,\n\t\t},\n\t}\n\tedgePolicy.ChannelFlags = 1\n\n\tif err := ctx.router.UpdateEdge(edgePolicy); err != nil {\n\t\tt.Fatalf(\"unable to update edge policy: %v\", err)\n\t}\n\n\t// After adding the edge between the two previously unknown nodes, they\n\t// should have been added to the graph.\n\t_, exists1, err = ctx.graph.HasLightningNode(pub1)\n\trequire.NoError(t, err, \"unable to query graph\")\n\tif !exists1 {\n\t\tt.Fatalf(\"node1 was not added to the graph\")\n\t}\n\t_, exists2, err = ctx.graph.HasLightningNode(pub2)\n\trequire.NoError(t, err, \"unable to query graph\")\n\tif !exists2 {\n\t\tt.Fatalf(\"node2 was not added to the graph\")\n\t}\n\n\t// We will connect node1 to the rest of the test graph, and make sure\n\t// we can find a route to node2, which will use the just added channel\n\t// edge.\n\n\t// We will connect node 1 to \"sophon\"\n\tconnectNode := ctx.aliases[\"sophon\"]\n\tconnectNodeKey, err := btcec.ParsePubKey(connectNode[:])\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar (\n\t\tpubKey1 *btcec.PublicKey\n\t\tpubKey2 *btcec.PublicKey\n\t)\n\tnode1Bytes := priv1.PubKey().SerializeCompressed()\n\tnode2Bytes := connectNode\n\tif bytes.Compare(node1Bytes[:], node2Bytes[:]) == -1 {\n\t\tpubKey1 = priv1.PubKey()\n\t\tpubKey2 = connectNodeKey\n\t} else {\n\t\tpubKey1 = connectNodeKey\n\t\tpubKey2 = priv1.PubKey()\n\t}\n\n\tfundingTx, _, chanID, err = createChannelEdge(ctx,\n\t\tpubKey1.SerializeCompressed(), pubKey2.SerializeCompressed(),\n\t\t10000, 510)\n\trequire.NoError(t, err, \"unable to create channel edge\")\n\tfundingBlock = &wire.MsgBlock{\n\t\tTransactions: []*wire.MsgTx{fundingTx},\n\t}\n\tctx.chain.addBlock(fundingBlock, chanID.BlockHeight, chanID.BlockHeight)\n\n\tedge = &channeldb.ChannelEdgeInfo{\n\t\tChannelID: chanID.ToUint64(),\n\t\tAuthProof: nil,\n\t}\n\tcopy(edge.NodeKey1Bytes[:], node1Bytes)\n\tedge.NodeKey2Bytes = node2Bytes\n\tcopy(edge.BitcoinKey1Bytes[:], node1Bytes)\n\tedge.BitcoinKey2Bytes = node2Bytes\n\n\tif err := ctx.router.AddEdge(edge); err != nil {\n\t\tt.Fatalf(\"unable to add edge to the channel graph: %v.\", err)\n\t}\n\n\tedgePolicy = &channeldb.ChannelEdgePolicy{\n\t\tSigBytes:                  testSig.Serialize(),\n\t\tChannelID:                 edge.ChannelID,\n\t\tLastUpdate:                testTime,\n\t\tTimeLockDelta:             10,\n\t\tMinHTLC:                   1,\n\t\tFeeBaseMSat:               10,\n\t\tFeeProportionalMillionths: 10000,\n\t\tNode: &channeldb.LightningNode{\n\t\t\tPubKeyBytes: edge.NodeKey2Bytes,\n\t\t},\n\t}\n\tedgePolicy.ChannelFlags = 0\n\n\tif err := ctx.router.UpdateEdge(edgePolicy); err != nil {\n\t\tt.Fatalf(\"unable to update edge policy: %v\", err)\n\t}\n\n\tedgePolicy = &channeldb.ChannelEdgePolicy{\n\t\tSigBytes:                  testSig.Serialize(),\n\t\tChannelID:                 edge.ChannelID,\n\t\tLastUpdate:                testTime,\n\t\tTimeLockDelta:             10,\n\t\tMinHTLC:                   1,\n\t\tFeeBaseMSat:               10,\n\t\tFeeProportionalMillionths: 10000,\n\t\tNode: &channeldb.LightningNode{\n\t\t\tPubKeyBytes: edge.NodeKey1Bytes,\n\t\t},\n\t}\n\tedgePolicy.ChannelFlags = 1\n\n\tif err := ctx.router.UpdateEdge(edgePolicy); err != nil {\n\t\tt.Fatalf(\"unable to update edge policy: %v\", err)\n\t}\n\n\t// We should now be able to find a route to node 2.\n\tpaymentAmt := lnwire.NewMSatFromSatoshis(100)\n\ttargetNode := priv2.PubKey()\n\tvar targetPubKeyBytes route.Vertex\n\tcopy(targetPubKeyBytes[:], targetNode.SerializeCompressed())\n\t_, _, err = ctx.router.FindRoute(\n\t\tctx.router.selfNode.PubKeyBytes,\n\t\ttargetPubKeyBytes, paymentAmt, 0, noRestrictions, nil, nil,\n\t\tMinCLTVDelta,\n\t)\n\trequire.NoError(t, err, \"unable to find any routes\")\n\n\t// Now check that we can update the node info for the partial node\n\t// without messing up the channel graph.\n\tn1 := &channeldb.LightningNode{\n\t\tHaveNodeAnnouncement: true,\n\t\tLastUpdate:           time.Unix(123, 0),\n\t\tAddresses:            testAddrs,\n\t\tColor:                color.RGBA{1, 2, 3, 0},\n\t\tAlias:                \"node11\",\n\t\tAuthSigBytes:         testSig.Serialize(),\n\t\tFeatures:             testFeatures,\n\t}\n\tcopy(n1.PubKeyBytes[:], priv1.PubKey().SerializeCompressed())\n\n\tif err := ctx.router.AddNode(n1); err != nil {\n\t\tt.Fatalf(\"could not add node: %v\", err)\n\t}\n\n\tn2 := &channeldb.LightningNode{\n\t\tHaveNodeAnnouncement: true,\n\t\tLastUpdate:           time.Unix(123, 0),\n\t\tAddresses:            testAddrs,\n\t\tColor:                color.RGBA{1, 2, 3, 0},\n\t\tAlias:                \"node22\",\n\t\tAuthSigBytes:         testSig.Serialize(),\n\t\tFeatures:             testFeatures,\n\t}\n\tcopy(n2.PubKeyBytes[:], priv2.PubKey().SerializeCompressed())\n\n\tif err := ctx.router.AddNode(n2); err != nil {\n\t\tt.Fatalf(\"could not add node: %v\", err)\n\t}\n\n\t// Should still be able to find the route, and the info should be\n\t// updated.\n\t_, _, err = ctx.router.FindRoute(\n\t\tctx.router.selfNode.PubKeyBytes,\n\t\ttargetPubKeyBytes, paymentAmt, 0, noRestrictions, nil, nil,\n\t\tMinCLTVDelta,\n\t)\n\trequire.NoError(t, err, \"unable to find any routes\")\n\n\tcopy1, err := ctx.graph.FetchLightningNode(pub1)\n\trequire.NoError(t, err, \"unable to fetch node\")\n\n\tif copy1.Alias != n1.Alias {\n\t\tt.Fatalf(\"fetched node not equal to original\")\n\t}\n\n\tcopy2, err := ctx.graph.FetchLightningNode(pub2)\n\trequire.NoError(t, err, \"unable to fetch node\")\n\n\tif copy2.Alias != n2.Alias {\n\t\tt.Fatalf(\"fetched node not equal to original\")\n\t}\n}\n\n// TestWakeUpOnStaleBranch tests that upon startup of the ChannelRouter, if the\n// the chain previously reflected in the channel graph is stale (overtaken by a\n// longer chain), the channel router will prune the graph for any channels\n// confirmed on the stale chain, and resync to the main chain.",
      "length": 7738,
      "tokens": 851,
      "embedding": []
    },
    {
      "slug": "func TestWakeUpOnStaleBranch(t *testing.T) {",
      "content": "func TestWakeUpOnStaleBranch(t *testing.T) {\n\tt.Parallel()\n\n\tconst startingBlockHeight = 101\n\tctx := createTestCtxSingleNode(t, startingBlockHeight)\n\n\tconst chanValue = 10000\n\n\t// chanID1 will not be reorged out.\n\tvar chanID1 uint64\n\n\t// chanID2 will be reorged out.\n\tvar chanID2 uint64\n\n\t// Create 10 common blocks, confirming chanID1.\n\tfor i := uint32(1); i <= 10; i++ {\n\t\tblock := &wire.MsgBlock{\n\t\t\tTransactions: []*wire.MsgTx{},\n\t\t}\n\t\theight := startingBlockHeight + i\n\t\tif i == 5 {\n\t\t\tfundingTx, _, chanID, err := createChannelEdge(ctx,\n\t\t\t\tbitcoinKey1.SerializeCompressed(),\n\t\t\t\tbitcoinKey2.SerializeCompressed(),\n\t\t\t\tchanValue, height)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable create channel edge: %v\", err)\n\t\t\t}\n\t\t\tblock.Transactions = append(block.Transactions,\n\t\t\t\tfundingTx)\n\t\t\tchanID1 = chanID.ToUint64()\n\n\t\t}\n\t\tctx.chain.addBlock(block, height, rand.Uint32())\n\t\tctx.chain.setBestBlock(int32(height))\n\t\tctx.chainView.notifyBlock(block.BlockHash(), height,\n\t\t\t[]*wire.MsgTx{}, t)\n\t}\n\n\t// Give time to process new blocks\n\ttime.Sleep(time.Millisecond * 500)\n\n\t_, forkHeight, err := ctx.chain.GetBestBlock()\n\trequire.NoError(t, err, \"unable to ge best block\")\n\n\t// Create 10 blocks on the minority chain, confirming chanID2.\n\tfor i := uint32(1); i <= 10; i++ {\n\t\tblock := &wire.MsgBlock{\n\t\t\tTransactions: []*wire.MsgTx{},\n\t\t}\n\t\theight := uint32(forkHeight) + i\n\t\tif i == 5 {\n\t\t\tfundingTx, _, chanID, err := createChannelEdge(ctx,\n\t\t\t\tbitcoinKey1.SerializeCompressed(),\n\t\t\t\tbitcoinKey2.SerializeCompressed(),\n\t\t\t\tchanValue, height)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable create channel edge: %v\", err)\n\t\t\t}\n\t\t\tblock.Transactions = append(block.Transactions,\n\t\t\t\tfundingTx)\n\t\t\tchanID2 = chanID.ToUint64()\n\t\t}\n\t\tctx.chain.addBlock(block, height, rand.Uint32())\n\t\tctx.chain.setBestBlock(int32(height))\n\t\tctx.chainView.notifyBlock(block.BlockHash(), height,\n\t\t\t[]*wire.MsgTx{}, t)\n\t}\n\t// Give time to process new blocks\n\ttime.Sleep(time.Millisecond * 500)\n\n\t// Now add the two edges to the channel graph, and check that they\n\t// correctly show up in the database.\n\tnode1, err := createTestNode()\n\trequire.NoError(t, err, \"unable to create test node\")\n\tnode2, err := createTestNode()\n\trequire.NoError(t, err, \"unable to create test node\")\n\n\tedge1 := &channeldb.ChannelEdgeInfo{\n\t\tChannelID:     chanID1,\n\t\tNodeKey1Bytes: node1.PubKeyBytes,\n\t\tNodeKey2Bytes: node2.PubKeyBytes,\n\t\tAuthProof: &channeldb.ChannelAuthProof{\n\t\t\tNodeSig1Bytes:    testSig.Serialize(),\n\t\t\tNodeSig2Bytes:    testSig.Serialize(),\n\t\t\tBitcoinSig1Bytes: testSig.Serialize(),\n\t\t\tBitcoinSig2Bytes: testSig.Serialize(),\n\t\t},\n\t}\n\tcopy(edge1.BitcoinKey1Bytes[:], bitcoinKey1.SerializeCompressed())\n\tcopy(edge1.BitcoinKey2Bytes[:], bitcoinKey2.SerializeCompressed())\n\n\tif err := ctx.router.AddEdge(edge1); err != nil {\n\t\tt.Fatalf(\"unable to add edge: %v\", err)\n\t}\n\n\tedge2 := &channeldb.ChannelEdgeInfo{\n\t\tChannelID:     chanID2,\n\t\tNodeKey1Bytes: node1.PubKeyBytes,\n\t\tNodeKey2Bytes: node2.PubKeyBytes,\n\t\tAuthProof: &channeldb.ChannelAuthProof{\n\t\t\tNodeSig1Bytes:    testSig.Serialize(),\n\t\t\tNodeSig2Bytes:    testSig.Serialize(),\n\t\t\tBitcoinSig1Bytes: testSig.Serialize(),\n\t\t\tBitcoinSig2Bytes: testSig.Serialize(),\n\t\t},\n\t}\n\tcopy(edge2.BitcoinKey1Bytes[:], bitcoinKey1.SerializeCompressed())\n\tcopy(edge2.BitcoinKey2Bytes[:], bitcoinKey2.SerializeCompressed())\n\n\tif err := ctx.router.AddEdge(edge2); err != nil {\n\t\tt.Fatalf(\"unable to add edge: %v\", err)\n\t}\n\n\t// Check that the fundingTxs are in the graph db.\n\t_, _, has, isZombie, err := ctx.graph.HasChannelEdge(chanID1)\n\tif err != nil {\n\t\tt.Fatalf(\"error looking for edge: %v\", chanID1)\n\t}\n\tif !has {\n\t\tt.Fatalf(\"could not find edge in graph\")\n\t}\n\tif isZombie {\n\t\tt.Fatal(\"edge was marked as zombie\")\n\t}\n\n\t_, _, has, isZombie, err = ctx.graph.HasChannelEdge(chanID2)\n\tif err != nil {\n\t\tt.Fatalf(\"error looking for edge: %v\", chanID2)\n\t}\n\tif !has {\n\t\tt.Fatalf(\"could not find edge in graph\")\n\t}\n\tif isZombie {\n\t\tt.Fatal(\"edge was marked as zombie\")\n\t}\n\n\t// Stop the router, so we can reorg the chain while its offline.\n\tif err := ctx.router.Stop(); err != nil {\n\t\tt.Fatalf(\"unable to stop router: %v\", err)\n\t}\n\n\t// Create a 15 block fork.\n\tfor i := uint32(1); i <= 15; i++ {\n\t\tblock := &wire.MsgBlock{\n\t\t\tTransactions: []*wire.MsgTx{},\n\t\t}\n\t\theight := uint32(forkHeight) + i\n\t\tctx.chain.addBlock(block, height, rand.Uint32())\n\t\tctx.chain.setBestBlock(int32(height))\n\t}\n\n\t// Give time to process new blocks.\n\ttime.Sleep(time.Millisecond * 500)\n\n\t// Create new router with same graph database.\n\trouter, err := New(Config{\n\t\tGraph:              ctx.graph,\n\t\tChain:              ctx.chain,\n\t\tChainView:          ctx.chainView,\n\t\tPayer:              &mockPaymentAttemptDispatcherOld{},\n\t\tControl:            makeMockControlTower(),\n\t\tChannelPruneExpiry: time.Hour * 24,\n\t\tGraphPruneInterval: time.Hour * 2,\n\n\t\t// We'll set the delay to zero to prune immediately.\n\t\tFirstTimePruneDelay: 0,\n\n\t\tIsAlias: func(scid lnwire.ShortChannelID) bool {\n\t\t\treturn false\n\t\t},\n\t})\n\tif err != nil {\n\t\tt.Fatalf(\"unable to create router %v\", err)\n\t}\n\n\t// It should resync to the longer chain on startup.\n\tif err := router.Start(); err != nil {\n\t\tt.Fatalf(\"unable to start router: %v\", err)\n\t}\n\n\t// The channel with chanID2 should not be in the database anymore,\n\t// since it is not confirmed on the longest chain. chanID1 should\n\t// still be.\n\t_, _, has, isZombie, err = ctx.graph.HasChannelEdge(chanID1)\n\tif err != nil {\n\t\tt.Fatalf(\"error looking for edge: %v\", chanID1)\n\t}\n\tif !has {\n\t\tt.Fatalf(\"did not find edge in graph\")\n\t}\n\tif isZombie {\n\t\tt.Fatal(\"edge was marked as zombie\")\n\t}\n\n\t_, _, has, isZombie, err = ctx.graph.HasChannelEdge(chanID2)\n\tif err != nil {\n\t\tt.Fatalf(\"error looking for edge: %v\", chanID2)\n\t}\n\tif has {\n\t\tt.Fatalf(\"found edge in graph\")\n\t}\n\tif isZombie {\n\t\tt.Fatal(\"reorged edge should not be marked as zombie\")\n\t}\n}\n\n// TestDisconnectedBlocks checks that the router handles a reorg happening when\n// it is active.",
      "length": 5678,
      "tokens": 695,
      "embedding": []
    },
    {
      "slug": "func TestDisconnectedBlocks(t *testing.T) {",
      "content": "func TestDisconnectedBlocks(t *testing.T) {\n\tt.Parallel()\n\n\tconst startingBlockHeight = 101\n\tctx := createTestCtxSingleNode(t, startingBlockHeight)\n\n\tconst chanValue = 10000\n\n\t// chanID1 will not be reorged out, while chanID2 will be reorged out.\n\tvar chanID1, chanID2 uint64\n\n\t// Create 10 common blocks, confirming chanID1.\n\tfor i := uint32(1); i <= 10; i++ {\n\t\tblock := &wire.MsgBlock{\n\t\t\tTransactions: []*wire.MsgTx{},\n\t\t}\n\t\theight := startingBlockHeight + i\n\t\tif i == 5 {\n\t\t\tfundingTx, _, chanID, err := createChannelEdge(ctx,\n\t\t\t\tbitcoinKey1.SerializeCompressed(),\n\t\t\t\tbitcoinKey2.SerializeCompressed(),\n\t\t\t\tchanValue, height)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable create channel edge: %v\", err)\n\t\t\t}\n\t\t\tblock.Transactions = append(block.Transactions,\n\t\t\t\tfundingTx)\n\t\t\tchanID1 = chanID.ToUint64()\n\n\t\t}\n\t\tctx.chain.addBlock(block, height, rand.Uint32())\n\t\tctx.chain.setBestBlock(int32(height))\n\t\tctx.chainView.notifyBlock(block.BlockHash(), height,\n\t\t\t[]*wire.MsgTx{}, t)\n\t}\n\n\t// Give time to process new blocks\n\ttime.Sleep(time.Millisecond * 500)\n\n\t_, forkHeight, err := ctx.chain.GetBestBlock()\n\trequire.NoError(t, err, \"unable to get best block\")\n\n\t// Create 10 blocks on the minority chain, confirming chanID2.\n\tvar minorityChain []*wire.MsgBlock\n\tfor i := uint32(1); i <= 10; i++ {\n\t\tblock := &wire.MsgBlock{\n\t\t\tTransactions: []*wire.MsgTx{},\n\t\t}\n\t\theight := uint32(forkHeight) + i\n\t\tif i == 5 {\n\t\t\tfundingTx, _, chanID, err := createChannelEdge(ctx,\n\t\t\t\tbitcoinKey1.SerializeCompressed(),\n\t\t\t\tbitcoinKey2.SerializeCompressed(),\n\t\t\t\tchanValue, height)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable create channel edge: %v\", err)\n\t\t\t}\n\t\t\tblock.Transactions = append(block.Transactions,\n\t\t\t\tfundingTx)\n\t\t\tchanID2 = chanID.ToUint64()\n\t\t}\n\t\tminorityChain = append(minorityChain, block)\n\t\tctx.chain.addBlock(block, height, rand.Uint32())\n\t\tctx.chain.setBestBlock(int32(height))\n\t\tctx.chainView.notifyBlock(block.BlockHash(), height,\n\t\t\t[]*wire.MsgTx{}, t)\n\t}\n\t// Give time to process new blocks\n\ttime.Sleep(time.Millisecond * 500)\n\n\t// Now add the two edges to the channel graph, and check that they\n\t// correctly show up in the database.\n\tnode1, err := createTestNode()\n\trequire.NoError(t, err, \"unable to create test node\")\n\tnode2, err := createTestNode()\n\trequire.NoError(t, err, \"unable to create test node\")\n\n\tedge1 := &channeldb.ChannelEdgeInfo{\n\t\tChannelID:        chanID1,\n\t\tNodeKey1Bytes:    node1.PubKeyBytes,\n\t\tNodeKey2Bytes:    node2.PubKeyBytes,\n\t\tBitcoinKey1Bytes: node1.PubKeyBytes,\n\t\tBitcoinKey2Bytes: node2.PubKeyBytes,\n\t\tAuthProof: &channeldb.ChannelAuthProof{\n\t\t\tNodeSig1Bytes:    testSig.Serialize(),\n\t\t\tNodeSig2Bytes:    testSig.Serialize(),\n\t\t\tBitcoinSig1Bytes: testSig.Serialize(),\n\t\t\tBitcoinSig2Bytes: testSig.Serialize(),\n\t\t},\n\t}\n\tcopy(edge1.BitcoinKey1Bytes[:], bitcoinKey1.SerializeCompressed())\n\tcopy(edge1.BitcoinKey2Bytes[:], bitcoinKey2.SerializeCompressed())\n\n\tif err := ctx.router.AddEdge(edge1); err != nil {\n\t\tt.Fatalf(\"unable to add edge: %v\", err)\n\t}\n\n\tedge2 := &channeldb.ChannelEdgeInfo{\n\t\tChannelID:        chanID2,\n\t\tNodeKey1Bytes:    node1.PubKeyBytes,\n\t\tNodeKey2Bytes:    node2.PubKeyBytes,\n\t\tBitcoinKey1Bytes: node1.PubKeyBytes,\n\t\tBitcoinKey2Bytes: node2.PubKeyBytes,\n\t\tAuthProof: &channeldb.ChannelAuthProof{\n\t\t\tNodeSig1Bytes:    testSig.Serialize(),\n\t\t\tNodeSig2Bytes:    testSig.Serialize(),\n\t\t\tBitcoinSig1Bytes: testSig.Serialize(),\n\t\t\tBitcoinSig2Bytes: testSig.Serialize(),\n\t\t},\n\t}\n\tcopy(edge2.BitcoinKey1Bytes[:], bitcoinKey1.SerializeCompressed())\n\tcopy(edge2.BitcoinKey2Bytes[:], bitcoinKey2.SerializeCompressed())\n\n\tif err := ctx.router.AddEdge(edge2); err != nil {\n\t\tt.Fatalf(\"unable to add edge: %v\", err)\n\t}\n\n\t// Check that the fundingTxs are in the graph db.\n\t_, _, has, isZombie, err := ctx.graph.HasChannelEdge(chanID1)\n\tif err != nil {\n\t\tt.Fatalf(\"error looking for edge: %v\", chanID1)\n\t}\n\tif !has {\n\t\tt.Fatalf(\"could not find edge in graph\")\n\t}\n\tif isZombie {\n\t\tt.Fatal(\"edge was marked as zombie\")\n\t}\n\n\t_, _, has, isZombie, err = ctx.graph.HasChannelEdge(chanID2)\n\tif err != nil {\n\t\tt.Fatalf(\"error looking for edge: %v\", chanID2)\n\t}\n\tif !has {\n\t\tt.Fatalf(\"could not find edge in graph\")\n\t}\n\tif isZombie {\n\t\tt.Fatal(\"edge was marked as zombie\")\n\t}\n\n\t// Create a 15 block fork. We first let the chainView notify the router\n\t// about stale blocks, before sending the now connected blocks. We do\n\t// this because we expect this order from the chainview.\n\tctx.chainView.notifyStaleBlockAck = make(chan struct{}, 1)\n\tfor i := len(minorityChain) - 1; i >= 0; i-- {\n\t\tblock := minorityChain[i]\n\t\theight := uint32(forkHeight) + uint32(i) + 1\n\t\tctx.chainView.notifyStaleBlock(block.BlockHash(), height,\n\t\t\tblock.Transactions, t)\n\t\t<-ctx.chainView.notifyStaleBlockAck\n\t}\n\n\ttime.Sleep(time.Second * 2)\n\n\tctx.chainView.notifyBlockAck = make(chan struct{}, 1)\n\tfor i := uint32(1); i <= 15; i++ {\n\t\tblock := &wire.MsgBlock{\n\t\t\tTransactions: []*wire.MsgTx{},\n\t\t}\n\t\theight := uint32(forkHeight) + i\n\t\tctx.chain.addBlock(block, height, rand.Uint32())\n\t\tctx.chain.setBestBlock(int32(height))\n\t\tctx.chainView.notifyBlock(block.BlockHash(), height,\n\t\t\tblock.Transactions, t)\n\t\t<-ctx.chainView.notifyBlockAck\n\t}\n\n\ttime.Sleep(time.Millisecond * 500)\n\n\t// chanID2 should not be in the database anymore, since it is not\n\t// confirmed on the longest chain. chanID1 should still be.\n\t_, _, has, isZombie, err = ctx.graph.HasChannelEdge(chanID1)\n\tif err != nil {\n\t\tt.Fatalf(\"error looking for edge: %v\", chanID1)\n\t}\n\tif !has {\n\t\tt.Fatalf(\"did not find edge in graph\")\n\t}\n\tif isZombie {\n\t\tt.Fatal(\"edge was marked as zombie\")\n\t}\n\n\t_, _, has, isZombie, err = ctx.graph.HasChannelEdge(chanID2)\n\tif err != nil {\n\t\tt.Fatalf(\"error looking for edge: %v\", chanID2)\n\t}\n\tif has {\n\t\tt.Fatalf(\"found edge in graph\")\n\t}\n\tif isZombie {\n\t\tt.Fatal(\"reorged edge should not be marked as zombie\")\n\t}\n}\n\n// TestChansClosedOfflinePruneGraph tests that if channels we know of are\n// closed while we're offline, then once we resume operation of the\n// ChannelRouter, then the channels are properly pruned.",
      "length": 5781,
      "tokens": 671,
      "embedding": []
    },
    {
      "slug": "func TestRouterChansClosedOfflinePruneGraph(t *testing.T) {",
      "content": "func TestRouterChansClosedOfflinePruneGraph(t *testing.T) {\n\tt.Parallel()\n\n\tconst startingBlockHeight = 101\n\tctx := createTestCtxSingleNode(t, startingBlockHeight)\n\n\tconst chanValue = 10000\n\n\t// First, we'll create a channel, to be mined shortly at height 102.\n\tblock102 := &wire.MsgBlock{\n\t\tTransactions: []*wire.MsgTx{},\n\t}\n\tnextHeight := startingBlockHeight + 1\n\tfundingTx1, chanUTXO, chanID1, err := createChannelEdge(ctx,\n\t\tbitcoinKey1.SerializeCompressed(),\n\t\tbitcoinKey2.SerializeCompressed(),\n\t\tchanValue, uint32(nextHeight))\n\trequire.NoError(t, err, \"unable create channel edge\")\n\tblock102.Transactions = append(block102.Transactions, fundingTx1)\n\tctx.chain.addBlock(block102, uint32(nextHeight), rand.Uint32())\n\tctx.chain.setBestBlock(int32(nextHeight))\n\tctx.chainView.notifyBlock(block102.BlockHash(), uint32(nextHeight),\n\t\t[]*wire.MsgTx{}, t)\n\n\t// We'll now create the edges and nodes within the database required\n\t// for the ChannelRouter to properly recognize the channel we added\n\t// above.\n\tnode1, err := createTestNode()\n\trequire.NoError(t, err, \"unable to create test node\")\n\tnode2, err := createTestNode()\n\trequire.NoError(t, err, \"unable to create test node\")\n\tedge1 := &channeldb.ChannelEdgeInfo{\n\t\tChannelID:     chanID1.ToUint64(),\n\t\tNodeKey1Bytes: node1.PubKeyBytes,\n\t\tNodeKey2Bytes: node2.PubKeyBytes,\n\t\tAuthProof: &channeldb.ChannelAuthProof{\n\t\t\tNodeSig1Bytes:    testSig.Serialize(),\n\t\t\tNodeSig2Bytes:    testSig.Serialize(),\n\t\t\tBitcoinSig1Bytes: testSig.Serialize(),\n\t\t\tBitcoinSig2Bytes: testSig.Serialize(),\n\t\t},\n\t}\n\tcopy(edge1.BitcoinKey1Bytes[:], bitcoinKey1.SerializeCompressed())\n\tcopy(edge1.BitcoinKey2Bytes[:], bitcoinKey2.SerializeCompressed())\n\tif err := ctx.router.AddEdge(edge1); err != nil {\n\t\tt.Fatalf(\"unable to add edge: %v\", err)\n\t}\n\n\t// The router should now be aware of the channel we created above.\n\t_, _, hasChan, isZombie, err := ctx.graph.HasChannelEdge(chanID1.ToUint64())\n\tif err != nil {\n\t\tt.Fatalf(\"error looking for edge: %v\", chanID1)\n\t}\n\tif !hasChan {\n\t\tt.Fatalf(\"could not find edge in graph\")\n\t}\n\tif isZombie {\n\t\tt.Fatal(\"edge was marked as zombie\")\n\t}\n\n\t// With the transaction included, and the router's database state\n\t// updated, we'll now mine 5 additional blocks on top of it.\n\tfor i := 0; i < 5; i++ {\n\t\tnextHeight++\n\n\t\tblock := &wire.MsgBlock{\n\t\t\tTransactions: []*wire.MsgTx{},\n\t\t}\n\t\tctx.chain.addBlock(block, uint32(nextHeight), rand.Uint32())\n\t\tctx.chain.setBestBlock(int32(nextHeight))\n\t\tctx.chainView.notifyBlock(block.BlockHash(), uint32(nextHeight),\n\t\t\t[]*wire.MsgTx{}, t)\n\t}\n\n\t// At this point, our starting height should be 107.\n\t_, chainHeight, err := ctx.chain.GetBestBlock()\n\trequire.NoError(t, err, \"unable to get best block\")\n\tif chainHeight != 107 {\n\t\tt.Fatalf(\"incorrect chain height: expected %v, got %v\",\n\t\t\t107, chainHeight)\n\t}\n\n\t// Next, we'll \"shut down\" the router in order to simulate downtime.\n\tif err := ctx.router.Stop(); err != nil {\n\t\tt.Fatalf(\"unable to shutdown router: %v\", err)\n\t}\n\n\t// While the router is \"offline\" we'll mine 5 additional blocks, with\n\t// the second block closing the channel we created above.\n\tfor i := 0; i < 5; i++ {\n\t\tnextHeight++\n\n\t\tblock := &wire.MsgBlock{\n\t\t\tTransactions: []*wire.MsgTx{},\n\t\t}\n\n\t\tif i == 2 {\n\t\t\t// For the second block, we'll add a transaction that\n\t\t\t// closes the channel we created above by spending the\n\t\t\t// output.\n\t\t\tclosingTx := wire.NewMsgTx(2)\n\t\t\tclosingTx.AddTxIn(&wire.TxIn{\n\t\t\t\tPreviousOutPoint: *chanUTXO,\n\t\t\t})\n\t\t\tblock.Transactions = append(block.Transactions,\n\t\t\t\tclosingTx)\n\t\t}\n\n\t\tctx.chain.addBlock(block, uint32(nextHeight), rand.Uint32())\n\t\tctx.chain.setBestBlock(int32(nextHeight))\n\t\tctx.chainView.notifyBlock(block.BlockHash(), uint32(nextHeight),\n\t\t\t[]*wire.MsgTx{}, t)\n\t}\n\n\t// At this point, our starting height should be 112.\n\t_, chainHeight, err = ctx.chain.GetBestBlock()\n\trequire.NoError(t, err, \"unable to get best block\")\n\tif chainHeight != 112 {\n\t\tt.Fatalf(\"incorrect chain height: expected %v, got %v\",\n\t\t\t112, chainHeight)\n\t}\n\n\t// Now we'll re-start the ChannelRouter. It should recognize that it's\n\t// behind the main chain and prune all the blocks that it missed while\n\t// it was down.\n\tctx.RestartRouter(t)\n\n\t// At this point, the channel that was pruned should no longer be known\n\t// by the router.\n\t_, _, hasChan, isZombie, err = ctx.graph.HasChannelEdge(chanID1.ToUint64())\n\tif err != nil {\n\t\tt.Fatalf(\"error looking for edge: %v\", chanID1)\n\t}\n\tif hasChan {\n\t\tt.Fatalf(\"channel was found in graph but shouldn't have been\")\n\t}\n\tif isZombie {\n\t\tt.Fatal(\"closed channel should not be marked as zombie\")\n\t}\n}\n\n// TestPruneChannelGraphStaleEdges ensures that we properly prune stale edges\n// from the channel graph.",
      "length": 4489,
      "tokens": 544,
      "embedding": []
    },
    {
      "slug": "func TestPruneChannelGraphStaleEdges(t *testing.T) {",
      "content": "func TestPruneChannelGraphStaleEdges(t *testing.T) {\n\tt.Parallel()\n\n\tfreshTimestamp := time.Now()\n\tstaleTimestamp := time.Unix(0, 0)\n\n\t// We'll create the following test graph so that two of the channels\n\t// are pruned.\n\ttestChannels := []*testChannel{\n\t\t// No edges.\n\t\t{\n\t\t\tNode1:     &testChannelEnd{Alias: \"a\"},\n\t\t\tNode2:     &testChannelEnd{Alias: \"b\"},\n\t\t\tCapacity:  100000,\n\t\t\tChannelID: 1,\n\t\t},\n\n\t\t// Only one edge with a stale timestamp.\n\t\t{\n\t\t\tNode1: &testChannelEnd{\n\t\t\t\tAlias: \"d\",\n\t\t\t\ttestChannelPolicy: &testChannelPolicy{\n\t\t\t\t\tLastUpdate: staleTimestamp,\n\t\t\t\t},\n\t\t\t},\n\t\t\tNode2:     &testChannelEnd{Alias: \"b\"},\n\t\t\tCapacity:  100000,\n\t\t\tChannelID: 2,\n\t\t},\n\n\t\t// Only one edge with a stale timestamp, but it's the source\n\t\t// node so it won't get pruned.\n\t\t{\n\t\t\tNode1: &testChannelEnd{\n\t\t\t\tAlias: \"a\",\n\t\t\t\ttestChannelPolicy: &testChannelPolicy{\n\t\t\t\t\tLastUpdate: staleTimestamp,\n\t\t\t\t},\n\t\t\t},\n\t\t\tNode2:     &testChannelEnd{Alias: \"b\"},\n\t\t\tCapacity:  100000,\n\t\t\tChannelID: 3,\n\t\t},\n\n\t\t// Only one edge with a fresh timestamp.\n\t\t{\n\t\t\tNode1: &testChannelEnd{\n\t\t\t\tAlias: \"a\",\n\t\t\t\ttestChannelPolicy: &testChannelPolicy{\n\t\t\t\t\tLastUpdate: freshTimestamp,\n\t\t\t\t},\n\t\t\t},\n\t\t\tNode2:     &testChannelEnd{Alias: \"b\"},\n\t\t\tCapacity:  100000,\n\t\t\tChannelID: 4,\n\t\t},\n\n\t\t// One edge fresh, one edge stale. This will be pruned with\n\t\t// strict pruning activated.\n\t\t{\n\t\t\tNode1: &testChannelEnd{\n\t\t\t\tAlias: \"c\",\n\t\t\t\ttestChannelPolicy: &testChannelPolicy{\n\t\t\t\t\tLastUpdate: freshTimestamp,\n\t\t\t\t},\n\t\t\t},\n\t\t\tNode2: &testChannelEnd{\n\t\t\t\tAlias: \"d\",\n\t\t\t\ttestChannelPolicy: &testChannelPolicy{\n\t\t\t\t\tLastUpdate: staleTimestamp,\n\t\t\t\t},\n\t\t\t},\n\t\t\tCapacity:  100000,\n\t\t\tChannelID: 5,\n\t\t},\n\n\t\t// Both edges fresh.\n\t\tsymmetricTestChannel(\"g\", \"h\", 100000, &testChannelPolicy{\n\t\t\tLastUpdate: freshTimestamp,\n\t\t}, 6),\n\n\t\t// Both edges stale, only one pruned. This should be pruned for\n\t\t// both normal and strict pruning.\n\t\tsymmetricTestChannel(\"e\", \"f\", 100000, &testChannelPolicy{\n\t\t\tLastUpdate: staleTimestamp,\n\t\t}, 7),\n\t}\n\n\tfor _, strictPruning := range []bool{true, false} {\n\t\t// We'll create our test graph and router backed with these test\n\t\t// channels we've created.\n\t\ttestGraph, err := createTestGraphFromChannels(\n\t\t\tt, true, testChannels, \"a\",\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to create test graph: %v\", err)\n\t\t}\n\n\t\tconst startingHeight = 100\n\t\tctx := createTestCtxFromGraphInstance(\n\t\t\tt, startingHeight, testGraph, strictPruning,\n\t\t)\n\n\t\t// All of the channels should exist before pruning them.\n\t\tassertChannelsPruned(t, ctx.graph, testChannels)\n\n\t\t// Proceed to prune the channels - only the last one should be pruned.\n\t\tif err := ctx.router.pruneZombieChans(); err != nil {\n\t\t\tt.Fatalf(\"unable to prune zombie channels: %v\", err)\n\t\t}\n\n\t\t// We expect channels that have either both edges stale, or one edge\n\t\t// stale with both known.\n\t\tvar prunedChannels []uint64\n\t\tif strictPruning {\n\t\t\tprunedChannels = []uint64{2, 5, 7}\n\t\t} else {\n\t\t\tprunedChannels = []uint64{2, 7}\n\t\t}\n\t\tassertChannelsPruned(t, ctx.graph, testChannels, prunedChannels...)\n\t}\n}\n\n// TestPruneChannelGraphDoubleDisabled test that we can properly prune channels\n// with both edges disabled from our channel graph.",
      "length": 2998,
      "tokens": 377,
      "embedding": []
    },
    {
      "slug": "func TestPruneChannelGraphDoubleDisabled(t *testing.T) {",
      "content": "func TestPruneChannelGraphDoubleDisabled(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"no_assumechannelvalid\", func(t *testing.T) {\n\t\ttestPruneChannelGraphDoubleDisabled(t, false)\n\t})\n\tt.Run(\"assumechannelvalid\", func(t *testing.T) {\n\t\ttestPruneChannelGraphDoubleDisabled(t, true)\n\t})\n}\n",
      "length": 214,
      "tokens": 16,
      "embedding": []
    },
    {
      "slug": "func testPruneChannelGraphDoubleDisabled(t *testing.T, assumeValid bool) {",
      "content": "func testPruneChannelGraphDoubleDisabled(t *testing.T, assumeValid bool) {\n\t// We'll create the following test graph so that only the last channel\n\t// is pruned. We'll use a fresh timestamp to ensure they're not pruned\n\t// according to that heuristic.\n\ttimestamp := time.Now()\n\ttestChannels := []*testChannel{\n\t\t// Channel from self shouldn't be pruned.\n\t\tsymmetricTestChannel(\n\t\t\t\"self\", \"a\", 100000, &testChannelPolicy{\n\t\t\t\tLastUpdate: timestamp,\n\t\t\t\tDisabled:   true,\n\t\t\t}, 99,\n\t\t),\n\n\t\t// No edges.\n\t\t{\n\t\t\tNode1:     &testChannelEnd{Alias: \"a\"},\n\t\t\tNode2:     &testChannelEnd{Alias: \"b\"},\n\t\t\tCapacity:  100000,\n\t\t\tChannelID: 1,\n\t\t},\n\n\t\t// Only one edge disabled.\n\t\t{\n\t\t\tNode1: &testChannelEnd{\n\t\t\t\tAlias: \"a\",\n\t\t\t\ttestChannelPolicy: &testChannelPolicy{\n\t\t\t\t\tLastUpdate: timestamp,\n\t\t\t\t\tDisabled:   true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tNode2:     &testChannelEnd{Alias: \"b\"},\n\t\t\tCapacity:  100000,\n\t\t\tChannelID: 2,\n\t\t},\n\n\t\t// Only one edge enabled.\n\t\t{\n\t\t\tNode1: &testChannelEnd{\n\t\t\t\tAlias: \"a\",\n\t\t\t\ttestChannelPolicy: &testChannelPolicy{\n\t\t\t\t\tLastUpdate: timestamp,\n\t\t\t\t\tDisabled:   false,\n\t\t\t\t},\n\t\t\t},\n\t\t\tNode2:     &testChannelEnd{Alias: \"b\"},\n\t\t\tCapacity:  100000,\n\t\t\tChannelID: 3,\n\t\t},\n\n\t\t// One edge disabled, one edge enabled.\n\t\t{\n\t\t\tNode1: &testChannelEnd{\n\t\t\t\tAlias: \"a\",\n\t\t\t\ttestChannelPolicy: &testChannelPolicy{\n\t\t\t\t\tLastUpdate: timestamp,\n\t\t\t\t\tDisabled:   true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tNode2: &testChannelEnd{\n\t\t\t\tAlias: \"b\",\n\t\t\t\ttestChannelPolicy: &testChannelPolicy{\n\t\t\t\t\tLastUpdate: timestamp,\n\t\t\t\t\tDisabled:   false,\n\t\t\t\t},\n\t\t\t},\n\t\t\tCapacity:  100000,\n\t\t\tChannelID: 1,\n\t\t},\n\n\t\t// Both edges enabled.\n\t\tsymmetricTestChannel(\"c\", \"d\", 100000, &testChannelPolicy{\n\t\t\tLastUpdate: timestamp,\n\t\t\tDisabled:   false,\n\t\t}, 2),\n\n\t\t// Both edges disabled, only one pruned.\n\t\tsymmetricTestChannel(\"e\", \"f\", 100000, &testChannelPolicy{\n\t\t\tLastUpdate: timestamp,\n\t\t\tDisabled:   true,\n\t\t}, 3),\n\t}\n\n\t// We'll create our test graph and router backed with these test\n\t// channels we've created.\n\ttestGraph, err := createTestGraphFromChannels(\n\t\tt, true, testChannels, \"self\",\n\t)\n\trequire.NoError(t, err, \"unable to create test graph\")\n\n\tconst startingHeight = 100\n\tctx := createTestCtxFromGraphInstanceAssumeValid(\n\t\tt, startingHeight, testGraph, assumeValid, false,\n\t)\n\n\t// All the channels should exist within the graph before pruning them\n\t// when not using AssumeChannelValid, otherwise we should have pruned\n\t// the last channel on startup.\n\tif !assumeValid {\n\t\tassertChannelsPruned(t, ctx.graph, testChannels)\n\t} else {\n\t\t// Sleep to allow the pruning to finish.\n\t\ttime.Sleep(200 * time.Millisecond)\n\n\t\tprunedChannel := testChannels[len(testChannels)-1].ChannelID\n\t\tassertChannelsPruned(t, ctx.graph, testChannels, prunedChannel)\n\t}\n\n\tif err := ctx.router.pruneZombieChans(); err != nil {\n\t\tt.Fatalf(\"unable to prune zombie channels: %v\", err)\n\t}\n\n\t// If we attempted to prune them without AssumeChannelValid being set,\n\t// none should be pruned. Otherwise the last channel should still be\n\t// pruned.\n\tif !assumeValid {\n\t\tassertChannelsPruned(t, ctx.graph, testChannels)\n\t} else {\n\t\tprunedChannel := testChannels[len(testChannels)-1].ChannelID\n\t\tassertChannelsPruned(t, ctx.graph, testChannels, prunedChannel)\n\t}\n}\n\n// TestFindPathFeeWeighting tests that the findPath method will properly prefer\n// routes with lower fees over routes with lower time lock values. This is\n// meant to exercise the fact that the internal findPath method ranks edges\n// with the square of the total fee in order bias towards lower fees.",
      "length": 3301,
      "tokens": 403,
      "embedding": []
    },
    {
      "slug": "func TestFindPathFeeWeighting(t *testing.T) {",
      "content": "func TestFindPathFeeWeighting(t *testing.T) {\n\tt.Parallel()\n\n\tconst startingBlockHeight = 101\n\tctx := createTestCtxFromFile(t, startingBlockHeight, basicGraphFilePath)\n\n\tvar preImage [32]byte\n\tcopy(preImage[:], bytes.Repeat([]byte{9}, 32))\n\n\tsourceNode, err := ctx.graph.SourceNode()\n\trequire.NoError(t, err, \"unable to fetch source node\")\n\n\tamt := lnwire.MilliSatoshi(100)\n\n\ttarget := ctx.aliases[\"luoji\"]\n\n\t// We'll now attempt a path finding attempt using this set up. Due to\n\t// the edge weighting, we should select the direct path over the 2 hop\n\t// path even though the direct path has a higher potential time lock.\n\tpath, err := dbFindPath(\n\t\tctx.graph, nil, &mockBandwidthHints{},\n\t\tnoRestrictions,\n\t\ttestPathFindingConfig,\n\t\tsourceNode.PubKeyBytes, target, amt, 0, 0,\n\t)\n\trequire.NoError(t, err, \"unable to find path\")\n\n\t// The route that was chosen should be exactly one hop, and should be\n\t// directly to luoji.\n\tif len(path) != 1 {\n\t\tt.Fatalf(\"expected path length of 1, instead was: %v\", len(path))\n\t}\n\tif path[0].ToNodePubKey() != ctx.aliases[\"luoji\"] {\n\t\tt.Fatalf(\"wrong node: %v\", path[0].ToNodePubKey())\n\t}\n}\n\n// TestIsStaleNode tests that the IsStaleNode method properly detects stale\n// node announcements.",
      "length": 1142,
      "tokens": 152,
      "embedding": []
    },
    {
      "slug": "func TestIsStaleNode(t *testing.T) {",
      "content": "func TestIsStaleNode(t *testing.T) {\n\tt.Parallel()\n\n\tconst startingBlockHeight = 101\n\tctx := createTestCtxSingleNode(t, startingBlockHeight)\n\n\t// Before we can insert a node in to the database, we need to create a\n\t// channel that it's linked to.\n\tvar (\n\t\tpub1 [33]byte\n\t\tpub2 [33]byte\n\t)\n\tcopy(pub1[:], priv1.PubKey().SerializeCompressed())\n\tcopy(pub2[:], priv2.PubKey().SerializeCompressed())\n\n\tfundingTx, _, chanID, err := createChannelEdge(ctx,\n\t\tbitcoinKey1.SerializeCompressed(),\n\t\tbitcoinKey2.SerializeCompressed(),\n\t\t10000, 500)\n\trequire.NoError(t, err, \"unable to create channel edge\")\n\tfundingBlock := &wire.MsgBlock{\n\t\tTransactions: []*wire.MsgTx{fundingTx},\n\t}\n\tctx.chain.addBlock(fundingBlock, chanID.BlockHeight, chanID.BlockHeight)\n\n\tedge := &channeldb.ChannelEdgeInfo{\n\t\tChannelID:        chanID.ToUint64(),\n\t\tNodeKey1Bytes:    pub1,\n\t\tNodeKey2Bytes:    pub2,\n\t\tBitcoinKey1Bytes: pub1,\n\t\tBitcoinKey2Bytes: pub2,\n\t\tAuthProof:        nil,\n\t}\n\tif err := ctx.router.AddEdge(edge); err != nil {\n\t\tt.Fatalf(\"unable to add edge: %v\", err)\n\t}\n\n\t// Before we add the node, if we query for staleness, we should get\n\t// false, as we haven't added the full node.\n\tupdateTimeStamp := time.Unix(123, 0)\n\tif ctx.router.IsStaleNode(pub1, updateTimeStamp) {\n\t\tt.Fatalf(\"incorrectly detected node as stale\")\n\t}\n\n\t// With the node stub in the database, we'll add the fully node\n\t// announcement to the database.\n\tn1 := &channeldb.LightningNode{\n\t\tHaveNodeAnnouncement: true,\n\t\tLastUpdate:           updateTimeStamp,\n\t\tAddresses:            testAddrs,\n\t\tColor:                color.RGBA{1, 2, 3, 0},\n\t\tAlias:                \"node11\",\n\t\tAuthSigBytes:         testSig.Serialize(),\n\t\tFeatures:             testFeatures,\n\t}\n\tcopy(n1.PubKeyBytes[:], priv1.PubKey().SerializeCompressed())\n\tif err := ctx.router.AddNode(n1); err != nil {\n\t\tt.Fatalf(\"could not add node: %v\", err)\n\t}\n\n\t// If we use the same timestamp and query for staleness, we should get\n\t// true.\n\tif !ctx.router.IsStaleNode(pub1, updateTimeStamp) {\n\t\tt.Fatalf(\"failure to detect stale node update\")\n\t}\n\n\t// If we update the timestamp and once again query for staleness, it\n\t// should report false.\n\tnewTimeStamp := time.Unix(1234, 0)\n\tif ctx.router.IsStaleNode(pub1, newTimeStamp) {\n\t\tt.Fatalf(\"incorrectly detected node as stale\")\n\t}\n}\n\n// TestIsKnownEdge tests that the IsKnownEdge method properly detects stale\n// channel announcements.",
      "length": 2287,
      "tokens": 264,
      "embedding": []
    },
    {
      "slug": "func TestIsKnownEdge(t *testing.T) {",
      "content": "func TestIsKnownEdge(t *testing.T) {\n\tt.Parallel()\n\n\tconst startingBlockHeight = 101\n\tctx := createTestCtxSingleNode(t, startingBlockHeight)\n\n\t// First, we'll create a new channel edge (just the info) and insert it\n\t// into the database.\n\tvar (\n\t\tpub1 [33]byte\n\t\tpub2 [33]byte\n\t)\n\tcopy(pub1[:], priv1.PubKey().SerializeCompressed())\n\tcopy(pub2[:], priv2.PubKey().SerializeCompressed())\n\n\tfundingTx, _, chanID, err := createChannelEdge(ctx,\n\t\tbitcoinKey1.SerializeCompressed(),\n\t\tbitcoinKey2.SerializeCompressed(),\n\t\t10000, 500)\n\trequire.NoError(t, err, \"unable to create channel edge\")\n\tfundingBlock := &wire.MsgBlock{\n\t\tTransactions: []*wire.MsgTx{fundingTx},\n\t}\n\tctx.chain.addBlock(fundingBlock, chanID.BlockHeight, chanID.BlockHeight)\n\n\tedge := &channeldb.ChannelEdgeInfo{\n\t\tChannelID:        chanID.ToUint64(),\n\t\tNodeKey1Bytes:    pub1,\n\t\tNodeKey2Bytes:    pub2,\n\t\tBitcoinKey1Bytes: pub1,\n\t\tBitcoinKey2Bytes: pub2,\n\t\tAuthProof:        nil,\n\t}\n\tif err := ctx.router.AddEdge(edge); err != nil {\n\t\tt.Fatalf(\"unable to add edge: %v\", err)\n\t}\n\n\t// Now that the edge has been inserted, query is the router already\n\t// knows of the edge should return true.\n\tif !ctx.router.IsKnownEdge(*chanID) {\n\t\tt.Fatalf(\"router should detect edge as known\")\n\t}\n}\n\n// TestIsStaleEdgePolicy tests that the IsStaleEdgePolicy properly detects\n// stale channel edge update announcements.",
      "length": 1285,
      "tokens": 141,
      "embedding": []
    },
    {
      "slug": "func TestIsStaleEdgePolicy(t *testing.T) {",
      "content": "func TestIsStaleEdgePolicy(t *testing.T) {\n\tt.Parallel()\n\n\tconst startingBlockHeight = 101\n\tctx := createTestCtxFromFile(t, startingBlockHeight, basicGraphFilePath)\n\n\t// First, we'll create a new channel edge (just the info) and insert it\n\t// into the database.\n\tvar (\n\t\tpub1 [33]byte\n\t\tpub2 [33]byte\n\t)\n\tcopy(pub1[:], priv1.PubKey().SerializeCompressed())\n\tcopy(pub2[:], priv2.PubKey().SerializeCompressed())\n\n\tfundingTx, _, chanID, err := createChannelEdge(ctx,\n\t\tbitcoinKey1.SerializeCompressed(),\n\t\tbitcoinKey2.SerializeCompressed(),\n\t\t10000, 500)\n\trequire.NoError(t, err, \"unable to create channel edge\")\n\tfundingBlock := &wire.MsgBlock{\n\t\tTransactions: []*wire.MsgTx{fundingTx},\n\t}\n\tctx.chain.addBlock(fundingBlock, chanID.BlockHeight, chanID.BlockHeight)\n\n\t// If we query for staleness before adding the edge, we should get\n\t// false.\n\tupdateTimeStamp := time.Unix(123, 0)\n\tif ctx.router.IsStaleEdgePolicy(*chanID, updateTimeStamp, 0) {\n\t\tt.Fatalf(\"router failed to detect fresh edge policy\")\n\t}\n\tif ctx.router.IsStaleEdgePolicy(*chanID, updateTimeStamp, 1) {\n\t\tt.Fatalf(\"router failed to detect fresh edge policy\")\n\t}\n\n\tedge := &channeldb.ChannelEdgeInfo{\n\t\tChannelID:        chanID.ToUint64(),\n\t\tNodeKey1Bytes:    pub1,\n\t\tNodeKey2Bytes:    pub2,\n\t\tBitcoinKey1Bytes: pub1,\n\t\tBitcoinKey2Bytes: pub2,\n\t\tAuthProof:        nil,\n\t}\n\tif err := ctx.router.AddEdge(edge); err != nil {\n\t\tt.Fatalf(\"unable to add edge: %v\", err)\n\t}\n\n\t// We'll also add two edge policies, one for each direction.\n\tedgePolicy := &channeldb.ChannelEdgePolicy{\n\t\tSigBytes:                  testSig.Serialize(),\n\t\tChannelID:                 edge.ChannelID,\n\t\tLastUpdate:                updateTimeStamp,\n\t\tTimeLockDelta:             10,\n\t\tMinHTLC:                   1,\n\t\tFeeBaseMSat:               10,\n\t\tFeeProportionalMillionths: 10000,\n\t}\n\tedgePolicy.ChannelFlags = 0\n\tif err := ctx.router.UpdateEdge(edgePolicy); err != nil {\n\t\tt.Fatalf(\"unable to update edge policy: %v\", err)\n\t}\n\n\tedgePolicy = &channeldb.ChannelEdgePolicy{\n\t\tSigBytes:                  testSig.Serialize(),\n\t\tChannelID:                 edge.ChannelID,\n\t\tLastUpdate:                updateTimeStamp,\n\t\tTimeLockDelta:             10,\n\t\tMinHTLC:                   1,\n\t\tFeeBaseMSat:               10,\n\t\tFeeProportionalMillionths: 10000,\n\t}\n\tedgePolicy.ChannelFlags = 1\n\tif err := ctx.router.UpdateEdge(edgePolicy); err != nil {\n\t\tt.Fatalf(\"unable to update edge policy: %v\", err)\n\t}\n\n\t// Now that the edges have been added, an identical (chanID, flag,\n\t// timestamp) tuple for each edge should be detected as a stale edge.\n\tif !ctx.router.IsStaleEdgePolicy(*chanID, updateTimeStamp, 0) {\n\t\tt.Fatalf(\"router failed to detect stale edge policy\")\n\t}\n\tif !ctx.router.IsStaleEdgePolicy(*chanID, updateTimeStamp, 1) {\n\t\tt.Fatalf(\"router failed to detect stale edge policy\")\n\t}\n\n\t// If we now update the timestamp for both edges, the router should\n\t// detect that this tuple represents a fresh edge.\n\tupdateTimeStamp = time.Unix(9999, 0)\n\tif ctx.router.IsStaleEdgePolicy(*chanID, updateTimeStamp, 0) {\n\t\tt.Fatalf(\"router failed to detect fresh edge policy\")\n\t}\n\tif ctx.router.IsStaleEdgePolicy(*chanID, updateTimeStamp, 1) {\n\t\tt.Fatalf(\"router failed to detect fresh edge policy\")\n\t}\n}\n\n// TestEmptyRoutesGenerateSphinxPacket tests that the generateSphinxPacket\n// function is able to gracefully handle being passed a nil set of hops for the\n// route by the caller.",
      "length": 3260,
      "tokens": 357,
      "embedding": []
    },
    {
      "slug": "func TestEmptyRoutesGenerateSphinxPacket(t *testing.T) {",
      "content": "func TestEmptyRoutesGenerateSphinxPacket(t *testing.T) {\n\tt.Parallel()\n\n\tsessionKey, _ := btcec.NewPrivateKey()\n\temptyRoute := &route.Route{}\n\t_, _, err := generateSphinxPacket(emptyRoute, testHash[:], sessionKey)\n\tif err != route.ErrNoRouteHopsProvided {\n\t\tt.Fatalf(\"expected empty hops error: instead got: %v\", err)\n\t}\n}\n\n// TestUnknownErrorSource tests that if the source of an error is unknown, all\n// edges along the route will be pruned.",
      "length": 375,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func TestUnknownErrorSource(t *testing.T) {",
      "content": "func TestUnknownErrorSource(t *testing.T) {\n\tt.Parallel()\n\n\t// Setup a network. It contains two paths to c: a->b->c and an\n\t// alternative a->d->c.\n\tchanCapSat := btcutil.Amount(100000)\n\ttestChannels := []*testChannel{\n\t\tsymmetricTestChannel(\"a\", \"b\", chanCapSat, &testChannelPolicy{\n\t\t\tExpiry:  144,\n\t\t\tFeeRate: 400,\n\t\t\tMinHTLC: 1,\n\t\t\tMaxHTLC: lnwire.NewMSatFromSatoshis(chanCapSat),\n\t\t}, 1),\n\t\tsymmetricTestChannel(\"b\", \"c\", chanCapSat, &testChannelPolicy{\n\t\t\tExpiry:  144,\n\t\t\tFeeRate: 400,\n\t\t\tMinHTLC: 1,\n\t\t\tMaxHTLC: lnwire.NewMSatFromSatoshis(chanCapSat),\n\t\t}, 3),\n\t\tsymmetricTestChannel(\"a\", \"d\", chanCapSat, &testChannelPolicy{\n\t\t\tExpiry:      144,\n\t\t\tFeeRate:     400,\n\t\t\tFeeBaseMsat: 100000,\n\t\t\tMinHTLC:     1,\n\t\t\tMaxHTLC:     lnwire.NewMSatFromSatoshis(chanCapSat),\n\t\t}, 2),\n\t\tsymmetricTestChannel(\"d\", \"c\", chanCapSat, &testChannelPolicy{\n\t\t\tExpiry:      144,\n\t\t\tFeeRate:     400,\n\t\t\tFeeBaseMsat: 100000,\n\t\t\tMinHTLC:     1,\n\t\t\tMaxHTLC:     lnwire.NewMSatFromSatoshis(chanCapSat),\n\t\t}, 4),\n\t}\n\n\ttestGraph, err := createTestGraphFromChannels(t, true, testChannels, \"a\")\n\trequire.NoError(t, err, \"unable to create graph\")\n\n\tconst startingBlockHeight = 101\n\tctx := createTestCtxFromGraphInstance(\n\t\tt, startingBlockHeight, testGraph, false,\n\t)\n\n\t// Create a payment to node c.\n\tvar payHash lntypes.Hash\n\tpayment := LightningPayment{\n\t\tTarget:      ctx.aliases[\"c\"],\n\t\tAmount:      lnwire.NewMSatFromSatoshis(1000),\n\t\tFeeLimit:    noFeeLimit,\n\t\tpaymentHash: &payHash,\n\t}\n\n\t// We'll modify the SendToSwitch method so that it simulates hop b as a\n\t// node that returns an unparsable failure if approached via the a->b\n\t// channel.\n\tctx.router.cfg.Payer.(*mockPaymentAttemptDispatcherOld).setPaymentResult(\n\t\tfunc(firstHop lnwire.ShortChannelID) ([32]byte, error) {\n\n\t\t\t// If channel a->b is used, return an error without\n\t\t\t// source and message. The sender won't know the origin\n\t\t\t// of the error.\n\t\t\tif firstHop.ToUint64() == 1 {\n\t\t\t\treturn [32]byte{},\n\t\t\t\t\thtlcswitch.ErrUnreadableFailureMessage\n\t\t\t}\n\n\t\t\t// Otherwise the payment succeeds.\n\t\t\treturn lntypes.Preimage{}, nil\n\t\t})\n\n\t// Send off the payment request to the router. The expectation is that\n\t// the route a->b->c is tried first. An unreadable faiure is returned\n\t// which should pruning the channel a->b. We expect the payment to\n\t// succeed via a->d.\n\t_, _, err = ctx.router.SendPayment(&payment)\n\trequire.NoError(t, err, \"expected payment to succeed, but got\")\n\n\t// Next we modify payment result to return an unknown failure.\n\tctx.router.cfg.Payer.(*mockPaymentAttemptDispatcherOld).setPaymentResult(\n\t\tfunc(firstHop lnwire.ShortChannelID) ([32]byte, error) {\n\n\t\t\t// If channel a->b is used, simulate that the failure\n\t\t\t// couldn't be decoded (FailureMessage is nil).\n\t\t\tif firstHop.ToUint64() == 2 {\n\t\t\t\treturn [32]byte{},\n\t\t\t\t\thtlcswitch.NewUnknownForwardingError(1)\n\t\t\t}\n\n\t\t\t// Otherwise the payment succeeds.\n\t\t\treturn lntypes.Preimage{}, nil\n\t\t})\n\n\t// Send off the payment request to the router. We expect the payment to\n\t// fail because both routes have been pruned.\n\tpayHash = lntypes.Hash{1}\n\tpayment.paymentHash = &payHash\n\t_, _, err = ctx.router.SendPayment(&payment)\n\tif err == nil {\n\t\tt.Fatalf(\"expected payment to fail\")\n\t}\n}\n\n// assertChannelsPruned ensures that only the given channels are pruned from the\n// graph out of the set of all channels.",
      "length": 3186,
      "tokens": 378,
      "embedding": []
    },
    {
      "slug": "func assertChannelsPruned(t *testing.T, graph *channeldb.ChannelGraph,",
      "content": "func assertChannelsPruned(t *testing.T, graph *channeldb.ChannelGraph,\n\tchannels []*testChannel, prunedChanIDs ...uint64) {\n\n\tt.Helper()\n\n\tpruned := make(map[uint64]struct{}, len(channels))\n\tfor _, chanID := range prunedChanIDs {\n\t\tpruned[chanID] = struct{}{}\n\t}\n\n\tfor _, channel := range channels {\n\t\t_, shouldPrune := pruned[channel.ChannelID]\n\t\t_, _, exists, isZombie, err := graph.HasChannelEdge(\n\t\t\tchannel.ChannelID,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to determine existence of \"+\n\t\t\t\t\"channel=%v in the graph: %v\",\n\t\t\t\tchannel.ChannelID, err)\n\t\t}\n\t\tif !shouldPrune && !exists {\n\t\t\tt.Fatalf(\"expected channel=%v to exist within \"+\n\t\t\t\t\"the graph\", channel.ChannelID)\n\t\t}\n\t\tif shouldPrune && exists {\n\t\t\tt.Fatalf(\"expected channel=%v to not exist \"+\n\t\t\t\t\"within the graph\", channel.ChannelID)\n\t\t}\n\t\tif !shouldPrune && isZombie {\n\t\t\tt.Fatalf(\"expected channel=%v to not be marked \"+\n\t\t\t\t\"as zombie\", channel.ChannelID)\n\t\t}\n\t\tif shouldPrune && !isZombie {\n\t\t\tt.Fatalf(\"expected channel=%v to be marked as \"+\n\t\t\t\t\"zombie\", channel.ChannelID)\n\t\t}\n\t}\n}\n\n// TestSendToRouteStructuredError asserts that SendToRoute returns a structured\n// error.",
      "length": 1040,
      "tokens": 134,
      "embedding": []
    },
    {
      "slug": "func TestSendToRouteStructuredError(t *testing.T) {",
      "content": "func TestSendToRouteStructuredError(t *testing.T) {\n\tt.Parallel()\n\n\t// Setup a three node network.\n\tchanCapSat := btcutil.Amount(100000)\n\ttestChannels := []*testChannel{\n\t\tsymmetricTestChannel(\"a\", \"b\", chanCapSat, &testChannelPolicy{\n\t\t\tExpiry:  144,\n\t\t\tFeeRate: 400,\n\t\t\tMinHTLC: 1,\n\t\t\tMaxHTLC: lnwire.NewMSatFromSatoshis(chanCapSat),\n\t\t}, 1),\n\t\tsymmetricTestChannel(\"b\", \"c\", chanCapSat, &testChannelPolicy{\n\t\t\tExpiry:  144,\n\t\t\tFeeRate: 400,\n\t\t\tMinHTLC: 1,\n\t\t\tMaxHTLC: lnwire.NewMSatFromSatoshis(chanCapSat),\n\t\t}, 2),\n\t}\n\n\ttestGraph, err := createTestGraphFromChannels(t, true, testChannels, \"a\")\n\trequire.NoError(t, err, \"unable to create graph\")\n\n\tconst startingBlockHeight = 101\n\tctx := createTestCtxFromGraphInstance(\n\t\tt, startingBlockHeight, testGraph, false,\n\t)\n\n\t// Set up an init channel for the control tower, such that we can make\n\t// sure the payment is initiated correctly.\n\tinit := make(chan initArgs, 1)\n\tctx.router.cfg.Control.(*mockControlTowerOld).init = init\n\n\t// Setup a route from source a to destination c. The route will be used\n\t// in a call to SendToRoute. SendToRoute also applies channel updates,\n\t// but it saves us from including RequestRoute in the test scope too.\n\tconst payAmt = lnwire.MilliSatoshi(10000)\n\thop1 := ctx.aliases[\"b\"]\n\thop2 := ctx.aliases[\"c\"]\n\thops := []*route.Hop{\n\t\t{\n\t\t\tChannelID:     1,\n\t\t\tPubKeyBytes:   hop1,\n\t\t\tAmtToForward:  payAmt,\n\t\t\tLegacyPayload: true,\n\t\t},\n\t\t{\n\t\t\tChannelID:     2,\n\t\t\tPubKeyBytes:   hop2,\n\t\t\tAmtToForward:  payAmt,\n\t\t\tLegacyPayload: true,\n\t\t},\n\t}\n\n\trt, err := route.NewRouteFromHops(payAmt, 100, ctx.aliases[\"a\"], hops)\n\trequire.NoError(t, err, \"unable to create route\")\n\n\tfinalHopIndex := len(hops)\n\ttestCases := map[int]lnwire.FailureMessage{\n\t\tfinalHopIndex: lnwire.NewFailIncorrectDetails(payAmt, 100),\n\t\t1: &lnwire.FailFeeInsufficient{\n\t\t\tUpdate: lnwire.ChannelUpdate{},\n\t\t},\n\t}\n\n\tfor failIndex, errorType := range testCases {\n\t\tfailIndex := failIndex\n\t\terrorType := errorType\n\n\t\tt.Run(fmt.Sprintf(\"%T\", errorType), func(t *testing.T) {\n\t\t\t// We'll modify the SendToSwitch method so that it\n\t\t\t// simulates a failed payment with an error originating\n\t\t\t// from the final hop in the route.\n\t\t\tctx.router.cfg.Payer.(*mockPaymentAttemptDispatcherOld).setPaymentResult(\n\t\t\t\tfunc(firstHop lnwire.ShortChannelID) ([32]byte, error) {\n\t\t\t\t\treturn [32]byte{}, htlcswitch.NewForwardingError(\n\t\t\t\t\t\terrorType, failIndex,\n\t\t\t\t\t)\n\t\t\t\t},\n\t\t\t)\n\n\t\t\t// The payment parameter is mostly redundant in\n\t\t\t// SendToRoute.  Can be left empty for this test.\n\t\t\tvar payment lntypes.Hash\n\n\t\t\t// Send off the payment request to the router. The\n\t\t\t// specified route should be attempted and the channel\n\t\t\t// update should be received by router and ignored\n\t\t\t// because it is missing a valid\n\t\t\t// signature.\n\t\t\t_, err = ctx.router.SendToRoute(payment, rt)\n\n\t\t\tfErr, ok := err.(*htlcswitch.ForwardingError)\n\t\t\trequire.True(\n\t\t\t\tt, ok, \"expected forwarding error, got: %T\", err,\n\t\t\t)\n\n\t\t\trequire.IsType(\n\t\t\t\tt, errorType, fErr.WireMessage(),\n\t\t\t\t\"expected type %T got %T\", errorType,\n\t\t\t\tfErr.WireMessage(),\n\t\t\t)\n\n\t\t\t// Check that the correct values were used when\n\t\t\t// initiating the payment.\n\t\t\tselect {\n\t\t\tcase initVal := <-init:\n\t\t\t\tif initVal.c.Value != payAmt {\n\t\t\t\t\tt.Fatalf(\"expected %v, got %v\", payAmt,\n\t\t\t\t\t\tinitVal.c.Value)\n\t\t\t\t}\n\t\t\tcase <-time.After(100 * time.Millisecond):\n\t\t\t\tt.Fatalf(\"initPayment not called\")\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestSendToRouteMaxHops asserts that SendToRoute fails when using a route that\n// exceeds the maximum number of hops.",
      "length": 3349,
      "tokens": 404,
      "embedding": []
    },
    {
      "slug": "func TestSendToRouteMaxHops(t *testing.T) {",
      "content": "func TestSendToRouteMaxHops(t *testing.T) {\n\tt.Parallel()\n\n\t// Setup a two node network.\n\tchanCapSat := btcutil.Amount(100000)\n\ttestChannels := []*testChannel{\n\t\tsymmetricTestChannel(\"a\", \"b\", chanCapSat, &testChannelPolicy{\n\t\t\tExpiry:  144,\n\t\t\tFeeRate: 400,\n\t\t\tMinHTLC: 1,\n\t\t\tMaxHTLC: lnwire.NewMSatFromSatoshis(chanCapSat),\n\t\t}, 1),\n\t}\n\n\ttestGraph, err := createTestGraphFromChannels(t, true, testChannels, \"a\")\n\trequire.NoError(t, err, \"unable to create graph\")\n\n\tconst startingBlockHeight = 101\n\n\tctx := createTestCtxFromGraphInstance(\n\t\tt, startingBlockHeight, testGraph, false,\n\t)\n\n\t// Create a 30 hop route that exceeds the maximum hop limit.\n\tconst payAmt = lnwire.MilliSatoshi(10000)\n\thopA := ctx.aliases[\"a\"]\n\thopB := ctx.aliases[\"b\"]\n\n\tvar hops []*route.Hop\n\tfor i := 0; i < 15; i++ {\n\t\thops = append(hops, &route.Hop{\n\t\t\tChannelID:     1,\n\t\t\tPubKeyBytes:   hopB,\n\t\t\tAmtToForward:  payAmt,\n\t\t\tLegacyPayload: true,\n\t\t})\n\n\t\thops = append(hops, &route.Hop{\n\t\t\tChannelID:     1,\n\t\t\tPubKeyBytes:   hopA,\n\t\t\tAmtToForward:  payAmt,\n\t\t\tLegacyPayload: true,\n\t\t})\n\t}\n\n\trt, err := route.NewRouteFromHops(payAmt, 100, ctx.aliases[\"a\"], hops)\n\trequire.NoError(t, err, \"unable to create route\")\n\n\t// Send off the payment request to the router. We expect an error back\n\t// indicating that the route is too long.\n\tvar payment lntypes.Hash\n\t_, err = ctx.router.SendToRoute(payment, rt)\n\tif err != route.ErrMaxRouteHopsExceeded {\n\t\tt.Fatalf(\"expected ErrMaxRouteHopsExceeded, but got %v\", err)\n\t}\n}\n\n// TestBuildRoute tests whether correct routes are built.",
      "length": 1450,
      "tokens": 178,
      "embedding": []
    },
    {
      "slug": "func TestBuildRoute(t *testing.T) {",
      "content": "func TestBuildRoute(t *testing.T) {\n\t// Setup a three node network.\n\tchanCapSat := btcutil.Amount(100000)\n\tpaymentAddrFeatures := lnwire.NewFeatureVector(\n\t\tlnwire.NewRawFeatureVector(lnwire.PaymentAddrOptional),\n\t\tlnwire.Features,\n\t)\n\ttestChannels := []*testChannel{\n\t\t// Create two local channels from a. The bandwidth is estimated\n\t\t// in this test as the channel capacity. For building routes, we\n\t\t// expected the channel with the largest estimated bandwidth to\n\t\t// be selected.\n\t\tsymmetricTestChannel(\"a\", \"b\", chanCapSat, &testChannelPolicy{\n\t\t\tExpiry:  144,\n\t\t\tFeeRate: 20000,\n\t\t\tMinHTLC: lnwire.NewMSatFromSatoshis(5),\n\t\t\tMaxHTLC: lnwire.NewMSatFromSatoshis(chanCapSat),\n\t\t}, 1),\n\t\tsymmetricTestChannel(\"a\", \"b\", chanCapSat/2, &testChannelPolicy{\n\t\t\tExpiry:  144,\n\t\t\tFeeRate: 20000,\n\t\t\tMinHTLC: lnwire.NewMSatFromSatoshis(5),\n\t\t\tMaxHTLC: lnwire.NewMSatFromSatoshis(chanCapSat / 2),\n\t\t}, 6),\n\n\t\t// Create two channels from b to c. For building routes, we\n\t\t// expect the lowest cost channel to be selected. Note that this\n\t\t// isn't a situation that we are expecting in reality. Routing\n\t\t// nodes are recommended to keep their channel policies towards\n\t\t// the same peer identical.\n\t\tsymmetricTestChannel(\"b\", \"c\", chanCapSat, &testChannelPolicy{\n\t\t\tExpiry:   144,\n\t\t\tFeeRate:  50000,\n\t\t\tMinHTLC:  lnwire.NewMSatFromSatoshis(20),\n\t\t\tMaxHTLC:  lnwire.NewMSatFromSatoshis(120),\n\t\t\tFeatures: paymentAddrFeatures,\n\t\t}, 2),\n\t\tsymmetricTestChannel(\"b\", \"c\", chanCapSat, &testChannelPolicy{\n\t\t\tExpiry:   144,\n\t\t\tFeeRate:  60000,\n\t\t\tMinHTLC:  lnwire.NewMSatFromSatoshis(20),\n\t\t\tMaxHTLC:  lnwire.NewMSatFromSatoshis(120),\n\t\t\tFeatures: paymentAddrFeatures,\n\t\t}, 7),\n\n\t\tsymmetricTestChannel(\"a\", \"e\", chanCapSat, &testChannelPolicy{\n\t\t\tExpiry:   144,\n\t\t\tFeeRate:  80000,\n\t\t\tMinHTLC:  lnwire.NewMSatFromSatoshis(5),\n\t\t\tMaxHTLC:  lnwire.NewMSatFromSatoshis(10),\n\t\t\tFeatures: paymentAddrFeatures,\n\t\t}, 5),\n\t\tsymmetricTestChannel(\"e\", \"c\", chanCapSat, &testChannelPolicy{\n\t\t\tExpiry:   144,\n\t\t\tFeeRate:  100000,\n\t\t\tMinHTLC:  lnwire.NewMSatFromSatoshis(20),\n\t\t\tMaxHTLC:  lnwire.NewMSatFromSatoshis(chanCapSat),\n\t\t\tFeatures: paymentAddrFeatures,\n\t\t}, 4),\n\t}\n\n\ttestGraph, err := createTestGraphFromChannels(t, true, testChannels, \"a\")\n\trequire.NoError(t, err, \"unable to create graph\")\n\n\tconst startingBlockHeight = 101\n\n\tctx := createTestCtxFromGraphInstance(\n\t\tt, startingBlockHeight, testGraph, false,\n\t)\n\n\tcheckHops := func(rt *route.Route, expected []uint64,\n\t\tpayAddr [32]byte) {\n\n\t\tt.Helper()\n\n\t\tif len(rt.Hops) != len(expected) {\n\t\t\tt.Fatal(\"hop count mismatch\")\n\t\t}\n\t\tfor i, hop := range rt.Hops {\n\t\t\tif hop.ChannelID != expected[i] {\n\t\t\t\tt.Fatalf(\"expected channel %v at pos %v, but \"+\n\t\t\t\t\t\"got channel %v\",\n\t\t\t\t\texpected[i], i, hop.ChannelID)\n\t\t\t}\n\t\t}\n\n\t\tlastHop := rt.Hops[len(rt.Hops)-1]\n\t\trequire.NotNil(t, lastHop.MPP)\n\t\trequire.Equal(t, lastHop.MPP.PaymentAddr(), payAddr)\n\t}\n\n\tvar payAddr [32]byte\n\t_, err = rand.Read(payAddr[:])\n\trequire.NoError(t, err)\n\n\t// Create hop list from the route node pubkeys.\n\thops := []route.Vertex{\n\t\tctx.aliases[\"b\"], ctx.aliases[\"c\"],\n\t}\n\tamt := lnwire.NewMSatFromSatoshis(100)\n\n\t// Build the route for the given amount.\n\trt, err := ctx.router.BuildRoute(\n\t\t&amt, hops, nil, 40, &payAddr,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Check that we get the expected route back. The total amount should be\n\t// the amount to deliver to hop c (100 sats) plus the max fee for the\n\t// connection b->c (6 sats).\n\tcheckHops(rt, []uint64{1, 7}, payAddr)\n\tif rt.TotalAmount != 106000 {\n\t\tt.Fatalf(\"unexpected total amount %v\", rt.TotalAmount)\n\t}\n\n\t// Build the route for the minimum amount.\n\trt, err = ctx.router.BuildRoute(\n\t\tnil, hops, nil, 40, &payAddr,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Check that we get the expected route back. The minimum that we can\n\t// send from b to c is 20 sats. Hop b charges 1200 msat for the\n\t// forwarding. The channel between hop a and b can carry amounts in the\n\t// range [5, 100], so 21200 msats is the minimum amount for this route.\n\tcheckHops(rt, []uint64{1, 7}, payAddr)\n\tif rt.TotalAmount != 21200 {\n\t\tt.Fatalf(\"unexpected total amount %v\", rt.TotalAmount)\n\t}\n\n\t// Test a route that contains incompatible channel htlc constraints.\n\t// There is no amount that can pass through both channel 5 and 4.\n\thops = []route.Vertex{\n\t\tctx.aliases[\"e\"], ctx.aliases[\"c\"],\n\t}\n\t_, err = ctx.router.BuildRoute(\n\t\tnil, hops, nil, 40, nil,\n\t)\n\terrNoChannel, ok := err.(ErrNoChannel)\n\tif !ok {\n\t\tt.Fatalf(\"expected incompatible policies error, but got %v\",\n\t\t\terr)\n\t}\n\tif errNoChannel.position != 0 {\n\t\tt.Fatalf(\"unexpected no channel error position\")\n\t}\n\tif errNoChannel.fromNode != ctx.aliases[\"a\"] {\n\t\tt.Fatalf(\"unexpected no channel error node\")\n\t}\n}\n\n// edgeCreationModifier is an enum-like type used to modify steps that are\n// skipped when creating a channel in the test context.",
      "length": 4655,
      "tokens": 581,
      "embedding": []
    },
    {
      "slug": "type edgeCreationModifier uint8",
      "content": "type edgeCreationModifier uint8\n\nconst (\n\t// edgeCreationNoFundingTx is used to skip adding the funding\n\t// transaction of an edge to the chain.\n\tedgeCreationNoFundingTx edgeCreationModifier = iota\n\n\t// edgeCreationNoUTXO is used to skip adding the UTXO of a channel to\n\t// the UTXO set.\n\tedgeCreationNoUTXO\n\n\t// edgeCreationBadScript is used to create the edge, but use the wrong\n\t// scrip which should cause it to fail output validation.\n\tedgeCreationBadScript\n)\n\n// newChannelEdgeInfo is a helper function used to create a new channel edge,\n// possibly skipping adding it to parts of the chain/state as well.",
      "length": 563,
      "tokens": 90,
      "embedding": []
    },
    {
      "slug": "func newChannelEdgeInfo(ctx *testCtx, fundingHeight uint32,",
      "content": "func newChannelEdgeInfo(ctx *testCtx, fundingHeight uint32,\n\tecm edgeCreationModifier) (*channeldb.ChannelEdgeInfo, error) {\n\n\tnode1, err := createTestNode()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tnode2, err := createTestNode()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfundingTx, _, chanID, err := createChannelEdge(\n\t\tctx, bitcoinKey1.SerializeCompressed(),\n\t\tbitcoinKey2.SerializeCompressed(), 100, fundingHeight,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to create edge: %w\", err)\n\t}\n\n\tedge := &channeldb.ChannelEdgeInfo{\n\t\tChannelID:     chanID.ToUint64(),\n\t\tNodeKey1Bytes: node1.PubKeyBytes,\n\t\tNodeKey2Bytes: node2.PubKeyBytes,\n\t}\n\tcopy(edge.BitcoinKey1Bytes[:], bitcoinKey1.SerializeCompressed())\n\tcopy(edge.BitcoinKey2Bytes[:], bitcoinKey2.SerializeCompressed())\n\n\tif ecm == edgeCreationNoFundingTx {\n\t\treturn edge, nil\n\t}\n\n\tfundingBlock := &wire.MsgBlock{\n\t\tTransactions: []*wire.MsgTx{fundingTx},\n\t}\n\tctx.chain.addBlock(fundingBlock, chanID.BlockHeight, chanID.BlockHeight)\n\n\tif ecm == edgeCreationNoUTXO {\n\t\tctx.chain.delUtxo(wire.OutPoint{\n\t\t\tHash: fundingTx.TxHash(),\n\t\t})\n\t}\n\n\tif ecm == edgeCreationBadScript {\n\t\tfundingTx.TxOut[0].PkScript[0] ^= 1\n\t}\n\n\treturn edge, nil\n}\n",
      "length": 1088,
      "tokens": 112,
      "embedding": []
    },
    {
      "slug": "func assertChanChainRejection(t *testing.T, ctx *testCtx,",
      "content": "func assertChanChainRejection(t *testing.T, ctx *testCtx,\n\tedge *channeldb.ChannelEdgeInfo, failCode errorCode) {\n\n\tt.Helper()\n\n\terr := ctx.router.AddEdge(edge)\n\tif !IsError(err, failCode) {\n\t\tt.Fatalf(\"validation should have failed: %v\", err)\n\t}\n\n\t// This channel should now be present in the zombie channel index.\n\t_, _, _, isZombie, err := ctx.graph.HasChannelEdge(\n\t\tedge.ChannelID,\n\t)\n\trequire.Nil(t, err)\n\trequire.True(t, isZombie, \"edge should be marked as zombie\")\n}\n\n// TestChannelOnChainRejectionZombie tests that if we fail validating a channel\n// due to some sort of on-chain rejection (no funding transaction, or invalid\n// UTXO), then we'll mark the channel as a zombie.",
      "length": 607,
      "tokens": 85,
      "embedding": []
    },
    {
      "slug": "func TestChannelOnChainRejectionZombie(t *testing.T) {",
      "content": "func TestChannelOnChainRejectionZombie(t *testing.T) {\n\tt.Parallel()\n\n\tctx := createTestCtxSingleNode(t, 0)\n\n\t// To start,  we'll make an edge for the channel, but we won't add the\n\t// funding transaction to the mock blockchain, which should cause the\n\t// validation to fail below.\n\tedge, err := newChannelEdgeInfo(ctx, 1, edgeCreationNoFundingTx)\n\trequire.Nil(t, err)\n\n\t// We expect this to fail as the transaction isn't present in the\n\t// chain (nor the block).\n\tassertChanChainRejection(t, ctx, edge, ErrNoFundingTransaction)\n\n\t// Next, we'll make another channel edge, but actually add it to the\n\t// graph this time.\n\tedge, err = newChannelEdgeInfo(ctx, 2, edgeCreationNoUTXO)\n\trequire.Nil(t, err)\n\n\t// Instead now, we'll remove it from the set of UTXOs which should\n\t// cause the spentness validation to fail.\n\tassertChanChainRejection(t, ctx, edge, ErrChannelSpent)\n\n\t// If we cause the funding transaction the chain to fail validation, we\n\t// should see similar behavior.\n\tedge, err = newChannelEdgeInfo(ctx, 3, edgeCreationBadScript)\n\trequire.Nil(t, err)\n\tassertChanChainRejection(t, ctx, edge, ErrInvalidFundingOutput)\n}\n",
      "length": 1046,
      "tokens": 146,
      "embedding": []
    },
    {
      "slug": "func createDummyTestGraph(t *testing.T) *testGraphInstance {",
      "content": "func createDummyTestGraph(t *testing.T) *testGraphInstance {\n\t// Setup two simple channels such that we can mock sending along this\n\t// route.\n\tchanCapSat := btcutil.Amount(100000)\n\ttestChannels := []*testChannel{\n\t\tsymmetricTestChannel(\"a\", \"b\", chanCapSat, &testChannelPolicy{\n\t\t\tExpiry:  144,\n\t\t\tFeeRate: 400,\n\t\t\tMinHTLC: 1,\n\t\t\tMaxHTLC: lnwire.NewMSatFromSatoshis(chanCapSat),\n\t\t}, 1),\n\t\tsymmetricTestChannel(\"b\", \"c\", chanCapSat, &testChannelPolicy{\n\t\t\tExpiry:  144,\n\t\t\tFeeRate: 400,\n\t\t\tMinHTLC: 1,\n\t\t\tMaxHTLC: lnwire.NewMSatFromSatoshis(chanCapSat),\n\t\t}, 2),\n\t}\n\n\ttestGraph, err := createTestGraphFromChannels(t, true, testChannels, \"a\")\n\trequire.NoError(t, err, \"failed to create graph\")\n\treturn testGraph\n}\n",
      "length": 631,
      "tokens": 66,
      "embedding": []
    },
    {
      "slug": "func createDummyLightningPayment(t *testing.T,",
      "content": "func createDummyLightningPayment(t *testing.T,\n\ttarget route.Vertex, amt lnwire.MilliSatoshi) *LightningPayment {\n\n\tvar preImage lntypes.Preimage\n\t_, err := rand.Read(preImage[:])\n\trequire.NoError(t, err, \"unable to generate preimage\")\n\n\tpayHash := preImage.Hash()\n\n\treturn &LightningPayment{\n\t\tTarget:      target,\n\t\tAmount:      amt,\n\t\tFeeLimit:    noFeeLimit,\n\t\tpaymentHash: &payHash,\n\t}\n}\n\n// TestSendMPPaymentSucceed tests that we can successfully send a MPPayment via\n// router.SendPayment. This test mainly focuses on testing the logic of the\n// method resumePayment is implemented as expected.",
      "length": 536,
      "tokens": 64,
      "embedding": []
    },
    {
      "slug": "func TestSendMPPaymentSucceed(t *testing.T) {",
      "content": "func TestSendMPPaymentSucceed(t *testing.T) {\n\tconst startingBlockHeight = 101\n\n\t// Create mockers to initialize the router.\n\tcontrolTower := &mockControlTower{}\n\tsessionSource := &mockPaymentSessionSource{}\n\tmissionControl := &mockMissionControl{}\n\tpayer := &mockPaymentAttemptDispatcher{}\n\tchain := newMockChain(startingBlockHeight)\n\tchainView := newMockChainView(chain)\n\ttestGraph := createDummyTestGraph(t)\n\n\t// Define the behavior of the mockers to the point where we can\n\t// successfully start the router.\n\tcontrolTower.On(\"FetchInFlightPayments\").Return(\n\t\t[]*channeldb.MPPayment{}, nil,\n\t)\n\tpayer.On(\"CleanStore\", mock.Anything).Return(nil)\n\n\t// Create and start the router.\n\trouter, err := New(Config{\n\t\tControl:        controlTower,\n\t\tSessionSource:  sessionSource,\n\t\tMissionControl: missionControl,\n\t\tPayer:          payer,\n\n\t\t// TODO(yy): create new mocks for the chain and chainview.\n\t\tChain:     chain,\n\t\tChainView: chainView,\n\n\t\t// TODO(yy): mock the graph once it's changed into interface.\n\t\tGraph: testGraph.graph,\n\n\t\tClock:              clock.NewTestClock(time.Unix(1, 0)),\n\t\tGraphPruneInterval: time.Hour * 2,\n\t\tNextPaymentID: func() (uint64, error) {\n\t\t\tnext := atomic.AddUint64(&uniquePaymentID, 1)\n\t\t\treturn next, nil\n\t\t},\n\n\t\tIsAlias: func(scid lnwire.ShortChannelID) bool {\n\t\t\treturn false\n\t\t},\n\t})\n\trequire.NoError(t, err, \"failed to create router\")\n\n\t// Make sure the router can start and stop without error.\n\trequire.NoError(t, router.Start(), \"router failed to start\")\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, router.Stop(), \"router failed to stop\")\n\t})\n\n\t// Once the router is started, check that the mocked methods are called\n\t// as expected.\n\tcontrolTower.AssertExpectations(t)\n\tpayer.AssertExpectations(t)\n\n\t// Mock the methods to the point where we are inside the function\n\t// resumePayment.\n\tpaymentAmt := lnwire.MilliSatoshi(10000)\n\treq := createDummyLightningPayment(\n\t\tt, testGraph.aliasMap[\"c\"], paymentAmt,\n\t)\n\tidentifier := lntypes.Hash(req.Identifier())\n\tsession := &mockPaymentSession{}\n\tsessionSource.On(\"NewPaymentSession\", req).Return(session, nil)\n\tcontrolTower.On(\"InitPayment\", identifier, mock.Anything).Return(nil)\n\n\t// The following mocked methods are called inside resumePayment. Note\n\t// that the payment object below will determine the state of the\n\t// paymentLifecycle.\n\tpayment := &channeldb.MPPayment{\n\t\tInfo: &channeldb.PaymentCreationInfo{Value: paymentAmt},\n\t}\n\tcontrolTower.On(\"FetchPayment\", identifier).Return(payment, nil)\n\n\t// Create a route that can send 1/4 of the total amount. This value\n\t// will be returned by calling RequestRoute.\n\tshard, err := createTestRoute(paymentAmt/4, testGraph.aliasMap)\n\trequire.NoError(t, err, \"failed to create route\")\n\tsession.On(\"RequestRoute\",\n\t\tmock.Anything, mock.Anything, mock.Anything, mock.Anything,\n\t).Return(shard, nil)\n\n\t// Make a new htlc attempt with zero fee and append it to the payment's\n\t// HTLCs when calling RegisterAttempt.\n\tactiveAttempt := makeActiveAttempt(int(paymentAmt/4), 0)\n\tcontrolTower.On(\"RegisterAttempt\",\n\t\tidentifier, mock.Anything,\n\t).Return(nil).Run(func(args mock.Arguments) {\n\t\tpayment.HTLCs = append(payment.HTLCs, activeAttempt)\n\t})\n\n\t// Create a buffered chan and it will be returned by GetAttemptResult.\n\tpayer.resultChan = make(chan *htlcswitch.PaymentResult, 10)\n\tpayer.On(\"GetAttemptResult\",\n\t\tmock.Anything, identifier, mock.Anything,\n\t).Run(func(args mock.Arguments) {\n\t\t// Before the mock method is returned, we send the result to\n\t\t// the read-only chan.\n\t\tpayer.resultChan <- &htlcswitch.PaymentResult{}\n\t})\n\n\t// Simple mocking the rest.\n\tpayer.On(\"SendHTLC\",\n\t\tmock.Anything, mock.Anything, mock.Anything,\n\t).Return(nil)\n\tmissionControl.On(\"ReportPaymentSuccess\",\n\t\tmock.Anything, mock.Anything,\n\t).Return(nil)\n\n\t// Mock SettleAttempt by changing one of the HTLCs to be settled.\n\tpreimage := lntypes.Preimage{1, 2, 3}\n\tsettledAttempt := makeSettledAttempt(\n\t\tint(paymentAmt/4), 0, preimage,\n\t)\n\tcontrolTower.On(\"SettleAttempt\",\n\t\tidentifier, mock.Anything, mock.Anything,\n\t).Return(&settledAttempt, nil).Run(func(args mock.Arguments) {\n\t\t// Whenever this method is invoked, we will mark the first\n\t\t// active attempt settled and exit.\n\t\tfor i, attempt := range payment.HTLCs {\n\t\t\tif attempt.Settle == nil {\n\t\t\t\tattempt.Settle = &channeldb.HTLCSettleInfo{\n\t\t\t\t\tPreimage: preimage,\n\t\t\t\t}\n\t\t\t\tpayment.HTLCs[i] = attempt\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t})\n\tcontrolTower.On(\"DeleteFailedAttempts\", identifier).Return(nil)\n\n\t// Call the actual method SendPayment on router. This is place inside a\n\t// goroutine so we can set a timeout for the whole test, in case\n\t// anything goes wrong and the test never finishes.\n\tdone := make(chan struct{})\n\tvar p lntypes.Hash\n\tgo func() {\n\t\tp, _, err = router.SendPayment(req)\n\t\tclose(done)\n\t}()\n\n\tselect {\n\tcase <-done:\n\tcase <-time.After(testTimeout):\n\t\tt.Fatalf(\"SendPayment didn't exit\")\n\t}\n\n\t// Finally, validate the returned values and check that the mock\n\t// methods are called as expected.\n\trequire.NoError(t, err, \"send payment failed\")\n\trequire.EqualValues(t, preimage, p, \"preimage not match\")\n\n\t// Note that we also implicitly check the methods such as FailAttempt,\n\t// ReportPaymentFail, etc, are not called because we never mocked them\n\t// in this test. If any of the unexpected methods was called, the test\n\t// would fail.\n\tcontrolTower.AssertExpectations(t)\n\tpayer.AssertExpectations(t)\n\tsessionSource.AssertExpectations(t)\n\tsession.AssertExpectations(t)\n\tmissionControl.AssertExpectations(t)\n}\n\n// TestSendMPPaymentSucceedOnExtraShards tests that we need extra attempts if\n// there are failed ones,so that a payment is successfully sent. This test\n// mainly focuses on testing the logic of the method resumePayment is\n// implemented as expected.",
      "length": 5522,
      "tokens": 633,
      "embedding": []
    },
    {
      "slug": "func TestSendMPPaymentSucceedOnExtraShards(t *testing.T) {",
      "content": "func TestSendMPPaymentSucceedOnExtraShards(t *testing.T) {\n\tconst startingBlockHeight = 101\n\n\t// Create mockers to initialize the router.\n\tcontrolTower := &mockControlTower{}\n\tsessionSource := &mockPaymentSessionSource{}\n\tmissionControl := &mockMissionControl{}\n\tpayer := &mockPaymentAttemptDispatcher{}\n\tchain := newMockChain(startingBlockHeight)\n\tchainView := newMockChainView(chain)\n\ttestGraph := createDummyTestGraph(t)\n\n\t// Define the behavior of the mockers to the point where we can\n\t// successfully start the router.\n\tcontrolTower.On(\"FetchInFlightPayments\").Return(\n\t\t[]*channeldb.MPPayment{}, nil,\n\t)\n\tpayer.On(\"CleanStore\", mock.Anything).Return(nil)\n\n\t// Create and start the router.\n\trouter, err := New(Config{\n\t\tControl:        controlTower,\n\t\tSessionSource:  sessionSource,\n\t\tMissionControl: missionControl,\n\t\tPayer:          payer,\n\n\t\t// TODO(yy): create new mocks for the chain and chainview.\n\t\tChain:     chain,\n\t\tChainView: chainView,\n\n\t\t// TODO(yy): mock the graph once it's changed into interface.\n\t\tGraph: testGraph.graph,\n\n\t\tClock:              clock.NewTestClock(time.Unix(1, 0)),\n\t\tGraphPruneInterval: time.Hour * 2,\n\t\tNextPaymentID: func() (uint64, error) {\n\t\t\tnext := atomic.AddUint64(&uniquePaymentID, 1)\n\t\t\treturn next, nil\n\t\t},\n\n\t\tIsAlias: func(scid lnwire.ShortChannelID) bool {\n\t\t\treturn false\n\t\t},\n\t})\n\trequire.NoError(t, err, \"failed to create router\")\n\n\t// Make sure the router can start and stop without error.\n\trequire.NoError(t, router.Start(), \"router failed to start\")\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, router.Stop(), \"router failed to stop\")\n\t})\n\n\t// Once the router is started, check that the mocked methods are called\n\t// as expected.\n\tcontrolTower.AssertExpectations(t)\n\tpayer.AssertExpectations(t)\n\n\t// Mock the methods to the point where we are inside the function\n\t// resumePayment.\n\tpaymentAmt := lnwire.MilliSatoshi(20000)\n\treq := createDummyLightningPayment(\n\t\tt, testGraph.aliasMap[\"c\"], paymentAmt,\n\t)\n\tidentifier := lntypes.Hash(req.Identifier())\n\tsession := &mockPaymentSession{}\n\tsessionSource.On(\"NewPaymentSession\", req).Return(session, nil)\n\tcontrolTower.On(\"InitPayment\", identifier, mock.Anything).Return(nil)\n\n\t// The following mocked methods are called inside resumePayment. Note\n\t// that the payment object below will determine the state of the\n\t// paymentLifecycle.\n\tpayment := &channeldb.MPPayment{\n\t\tInfo: &channeldb.PaymentCreationInfo{Value: paymentAmt},\n\t}\n\tcontrolTower.On(\"FetchPayment\", identifier).Return(payment, nil)\n\n\t// Create a route that can send 1/4 of the total amount. This value\n\t// will be returned by calling RequestRoute.\n\tshard, err := createTestRoute(paymentAmt/4, testGraph.aliasMap)\n\trequire.NoError(t, err, \"failed to create route\")\n\tsession.On(\"RequestRoute\",\n\t\tmock.Anything, mock.Anything, mock.Anything, mock.Anything,\n\t).Return(shard, nil)\n\n\t// Make a new htlc attempt with zero fee and append it to the payment's\n\t// HTLCs when calling RegisterAttempt.\n\tactiveAttempt := makeActiveAttempt(int(paymentAmt/4), 0)\n\tcontrolTower.On(\"RegisterAttempt\",\n\t\tidentifier, mock.Anything,\n\t).Return(nil).Run(func(args mock.Arguments) {\n\t\tpayment.HTLCs = append(payment.HTLCs, activeAttempt)\n\t})\n\n\t// Create a buffered chan and it will be returned by GetAttemptResult.\n\tpayer.resultChan = make(chan *htlcswitch.PaymentResult, 10)\n\n\t// We use the failAttemptCount to track how many attempts we want to\n\t// fail. Each time the following mock method is called, the count gets\n\t// updated.\n\tfailAttemptCount := 0\n\tpayer.On(\"GetAttemptResult\",\n\t\tmock.Anything, identifier, mock.Anything,\n\t).Run(func(args mock.Arguments) {\n\t\t// Before the mock method is returned, we send the result to\n\t\t// the read-only chan.\n\n\t\t// Update the counter.\n\t\tfailAttemptCount++\n\n\t\t// We will make the first two attempts failed with temporary\n\t\t// error.\n\t\tif failAttemptCount <= 2 {\n\t\t\tpayer.resultChan <- &htlcswitch.PaymentResult{\n\t\t\t\tError: htlcswitch.NewForwardingError(\n\t\t\t\t\t&lnwire.FailTemporaryChannelFailure{},\n\t\t\t\t\t1,\n\t\t\t\t),\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\t// Otherwise we will mark the attempt succeeded.\n\t\tpayer.resultChan <- &htlcswitch.PaymentResult{}\n\t})\n\n\t// Mock the FailAttempt method to fail one of the attempts.\n\tvar failedAttempt channeldb.HTLCAttempt\n\tcontrolTower.On(\"FailAttempt\",\n\t\tidentifier, mock.Anything, mock.Anything,\n\t).Return(&failedAttempt, nil).Run(func(args mock.Arguments) {\n\t\t// Whenever this method is invoked, we will mark the first\n\t\t// active attempt as failed and exit.\n\t\tfor i, attempt := range payment.HTLCs {\n\t\t\tif attempt.Settle != nil || attempt.Failure != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tattempt.Failure = &channeldb.HTLCFailInfo{}\n\t\t\tfailedAttempt = attempt\n\t\t\tpayment.HTLCs[i] = attempt\n\t\t\treturn\n\t\t}\n\t})\n\n\t// Setup ReportPaymentFail to return nil reason and error so the\n\t// payment won't fail.\n\tmissionControl.On(\"ReportPaymentFail\",\n\t\tmock.Anything, mock.Anything, mock.Anything, mock.Anything,\n\t).Return(nil, nil)\n\n\t// Simple mocking the rest.\n\tpayer.On(\"SendHTLC\",\n\t\tmock.Anything, mock.Anything, mock.Anything,\n\t).Return(nil)\n\tmissionControl.On(\"ReportPaymentSuccess\",\n\t\tmock.Anything, mock.Anything,\n\t).Return(nil)\n\n\t// Mock SettleAttempt by changing one of the HTLCs to be settled.\n\tpreimage := lntypes.Preimage{1, 2, 3}\n\tsettledAttempt := makeSettledAttempt(\n\t\tint(paymentAmt/4), 0, preimage,\n\t)\n\tcontrolTower.On(\"SettleAttempt\",\n\t\tidentifier, mock.Anything, mock.Anything,\n\t).Return(&settledAttempt, nil).Run(func(args mock.Arguments) {\n\t\t// Whenever this method is invoked, we will mark the first\n\t\t// active attempt settled and exit.\n\t\tfor i, attempt := range payment.HTLCs {\n\t\t\tif attempt.Settle != nil || attempt.Failure != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tattempt.Settle = &channeldb.HTLCSettleInfo{\n\t\t\t\tPreimage: preimage,\n\t\t\t}\n\t\t\tpayment.HTLCs[i] = attempt\n\t\t\treturn\n\t\t}\n\t})\n\tcontrolTower.On(\"DeleteFailedAttempts\", identifier).Return(nil)\n\n\t// Call the actual method SendPayment on router. This is place inside a\n\t// goroutine so we can set a timeout for the whole test, in case\n\t// anything goes wrong and the test never finishes.\n\tdone := make(chan struct{})\n\tvar p lntypes.Hash\n\tgo func() {\n\t\tp, _, err = router.SendPayment(req)\n\t\tclose(done)\n\t}()\n\n\tselect {\n\tcase <-done:\n\tcase <-time.After(testTimeout):\n\t\tt.Fatalf(\"SendPayment didn't exit\")\n\t}\n\n\t// Finally, validate the returned values and check that the mock\n\t// methods are called as expected.\n\trequire.NoError(t, err, \"send payment failed\")\n\trequire.EqualValues(t, preimage, p, \"preimage not match\")\n\n\tcontrolTower.AssertExpectations(t)\n\tpayer.AssertExpectations(t)\n\tsessionSource.AssertExpectations(t)\n\tsession.AssertExpectations(t)\n\tmissionControl.AssertExpectations(t)\n}\n\n// TestSendMPPaymentFailed tests that when one of the shard fails with a\n// terminal error, the router will stop attempting and the payment will fail.\n// This test mainly focuses on testing the logic of the method resumePayment\n// is implemented as expected.",
      "length": 6636,
      "tokens": 768,
      "embedding": []
    },
    {
      "slug": "func TestSendMPPaymentFailed(t *testing.T) {",
      "content": "func TestSendMPPaymentFailed(t *testing.T) {\n\tconst startingBlockHeight = 101\n\n\t// Create mockers to initialize the router.\n\tcontrolTower := &mockControlTower{}\n\tsessionSource := &mockPaymentSessionSource{}\n\tmissionControl := &mockMissionControl{}\n\tpayer := &mockPaymentAttemptDispatcher{}\n\tchain := newMockChain(startingBlockHeight)\n\tchainView := newMockChainView(chain)\n\ttestGraph := createDummyTestGraph(t)\n\n\t// Define the behavior of the mockers to the point where we can\n\t// successfully start the router.\n\tcontrolTower.On(\"FetchInFlightPayments\").Return(\n\t\t[]*channeldb.MPPayment{}, nil,\n\t)\n\tpayer.On(\"CleanStore\", mock.Anything).Return(nil)\n\n\t// Create and start the router.\n\trouter, err := New(Config{\n\t\tControl:        controlTower,\n\t\tSessionSource:  sessionSource,\n\t\tMissionControl: missionControl,\n\t\tPayer:          payer,\n\n\t\t// TODO(yy): create new mocks for the chain and chainview.\n\t\tChain:     chain,\n\t\tChainView: chainView,\n\n\t\t// TODO(yy): mock the graph once it's changed into interface.\n\t\tGraph: testGraph.graph,\n\n\t\tClock:              clock.NewTestClock(time.Unix(1, 0)),\n\t\tGraphPruneInterval: time.Hour * 2,\n\t\tNextPaymentID: func() (uint64, error) {\n\t\t\tnext := atomic.AddUint64(&uniquePaymentID, 1)\n\t\t\treturn next, nil\n\t\t},\n\n\t\tIsAlias: func(scid lnwire.ShortChannelID) bool {\n\t\t\treturn false\n\t\t},\n\t})\n\trequire.NoError(t, err, \"failed to create router\")\n\n\t// Make sure the router can start and stop without error.\n\trequire.NoError(t, router.Start(), \"router failed to start\")\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, router.Stop(), \"router failed to stop\")\n\t})\n\n\t// Once the router is started, check that the mocked methods are called\n\t// as expected.\n\tcontrolTower.AssertExpectations(t)\n\tpayer.AssertExpectations(t)\n\n\t// Mock the methods to the point where we are inside the function\n\t// resumePayment.\n\tpaymentAmt := lnwire.MilliSatoshi(10000)\n\treq := createDummyLightningPayment(\n\t\tt, testGraph.aliasMap[\"c\"], paymentAmt,\n\t)\n\tidentifier := lntypes.Hash(req.Identifier())\n\tsession := &mockPaymentSession{}\n\tsessionSource.On(\"NewPaymentSession\", req).Return(session, nil)\n\tcontrolTower.On(\"InitPayment\", identifier, mock.Anything).Return(nil)\n\n\t// The following mocked methods are called inside resumePayment. Note\n\t// that the payment object below will determine the state of the\n\t// paymentLifecycle.\n\tpayment := &channeldb.MPPayment{\n\t\tInfo: &channeldb.PaymentCreationInfo{Value: paymentAmt},\n\t}\n\tcontrolTower.On(\"FetchPayment\", identifier).Return(payment, nil)\n\n\t// Create a route that can send 1/4 of the total amount. This value\n\t// will be returned by calling RequestRoute.\n\tshard, err := createTestRoute(paymentAmt/4, testGraph.aliasMap)\n\trequire.NoError(t, err, \"failed to create route\")\n\tsession.On(\"RequestRoute\",\n\t\tmock.Anything, mock.Anything, mock.Anything, mock.Anything,\n\t).Return(shard, nil)\n\n\t// Make a new htlc attempt with zero fee and append it to the payment's\n\t// HTLCs when calling RegisterAttempt.\n\tactiveAttempt := makeActiveAttempt(int(paymentAmt/4), 0)\n\tcontrolTower.On(\"RegisterAttempt\",\n\t\tidentifier, mock.Anything,\n\t).Return(nil).Run(func(args mock.Arguments) {\n\t\tpayment.HTLCs = append(payment.HTLCs, activeAttempt)\n\t})\n\n\t// Create a buffered chan and it will be returned by GetAttemptResult.\n\tpayer.resultChan = make(chan *htlcswitch.PaymentResult, 10)\n\n\t// We use the failAttemptCount to track how many attempts we want to\n\t// fail. Each time the following mock method is called, the count gets\n\t// updated.\n\tfailAttemptCount := 0\n\tpayer.On(\"GetAttemptResult\",\n\t\tmock.Anything, identifier, mock.Anything,\n\t).Run(func(args mock.Arguments) {\n\t\t// Before the mock method is returned, we send the result to\n\t\t// the read-only chan.\n\n\t\t// Update the counter.\n\t\tfailAttemptCount++\n\n\t\t// We fail the first attempt with terminal error.\n\t\tif failAttemptCount == 1 {\n\t\t\tpayer.resultChan <- &htlcswitch.PaymentResult{\n\t\t\t\tError: htlcswitch.NewForwardingError(\n\t\t\t\t\t&lnwire.FailIncorrectDetails{},\n\t\t\t\t\t1,\n\t\t\t\t),\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\t// We will make the rest attempts failed with temporary error.\n\t\tpayer.resultChan <- &htlcswitch.PaymentResult{\n\t\t\tError: htlcswitch.NewForwardingError(\n\t\t\t\t&lnwire.FailTemporaryChannelFailure{},\n\t\t\t\t1,\n\t\t\t),\n\t\t}\n\t})\n\n\t// Mock the FailAttempt method to fail one of the attempts.\n\tvar failedAttempt channeldb.HTLCAttempt\n\tcontrolTower.On(\"FailAttempt\",\n\t\tidentifier, mock.Anything, mock.Anything,\n\t).Return(&failedAttempt, nil).Run(func(args mock.Arguments) {\n\t\t// Whenever this method is invoked, we will mark the first\n\t\t// active attempt as failed and exit.\n\t\tfor i, attempt := range payment.HTLCs {\n\t\t\tif attempt.Settle != nil || attempt.Failure != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tattempt.Failure = &channeldb.HTLCFailInfo{}\n\t\t\tfailedAttempt = attempt\n\t\t\tpayment.HTLCs[i] = attempt\n\t\t\treturn\n\t\t}\n\t})\n\n\t// Setup ReportPaymentFail to return nil reason and error so the\n\t// payment won't fail.\n\tvar called bool\n\tfailureReason := channeldb.FailureReasonPaymentDetails\n\tmissionControl.On(\"ReportPaymentFail\",\n\t\tmock.Anything, mock.Anything, mock.Anything, mock.Anything,\n\t).Return(&failureReason, nil).Run(func(args mock.Arguments) {\n\t\t// We only return the terminal error once, thus when the method\n\t\t// is called, we will return it with a nil error.\n\t\tif called {\n\t\t\targs[0] = nil\n\t\t\treturn\n\t\t}\n\n\t\t// If it's the first time calling this method, we will return a\n\t\t// terminal error.\n\t\tpayment.FailureReason = &failureReason\n\t\tcalled = true\n\t})\n\n\t// Simple mocking the rest.\n\tcontrolTower.On(\"FailPayment\", identifier, failureReason).Return(nil)\n\tpayer.On(\"SendHTLC\",\n\t\tmock.Anything, mock.Anything, mock.Anything,\n\t).Return(nil)\n\n\t// Call the actual method SendPayment on router. This is place inside a\n\t// goroutine so we can set a timeout for the whole test, in case\n\t// anything goes wrong and the test never finishes.\n\tdone := make(chan struct{})\n\tvar p lntypes.Hash\n\tgo func() {\n\t\tp, _, err = router.SendPayment(req)\n\t\tclose(done)\n\t}()\n\n\tselect {\n\tcase <-done:\n\tcase <-time.After(testTimeout):\n\t\tt.Fatalf(\"SendPayment didn't exit\")\n\t}\n\n\t// Finally, validate the returned values and check that the mock\n\t// methods are called as expected.\n\trequire.Error(t, err, \"expected send payment error\")\n\trequire.EqualValues(t, [32]byte{}, p, \"preimage not match\")\n\n\tcontrolTower.AssertExpectations(t)\n\tpayer.AssertExpectations(t)\n\tsessionSource.AssertExpectations(t)\n\tsession.AssertExpectations(t)\n\tmissionControl.AssertExpectations(t)\n}\n\n// TestSendMPPaymentFailedWithShardsInFlight tests that when the payment is in\n// terminal state, even if we have shards in flight, we still fail the payment\n// and exit. This test mainly focuses on testing the logic of the method\n// resumePayment is implemented as expected.",
      "length": 6432,
      "tokens": 755,
      "embedding": []
    },
    {
      "slug": "func TestSendMPPaymentFailedWithShardsInFlight(t *testing.T) {",
      "content": "func TestSendMPPaymentFailedWithShardsInFlight(t *testing.T) {\n\tconst startingBlockHeight = 101\n\n\t// Create mockers to initialize the router.\n\tcontrolTower := &mockControlTower{}\n\tsessionSource := &mockPaymentSessionSource{}\n\tmissionControl := &mockMissionControl{}\n\tpayer := &mockPaymentAttemptDispatcher{}\n\tchain := newMockChain(startingBlockHeight)\n\tchainView := newMockChainView(chain)\n\ttestGraph := createDummyTestGraph(t)\n\n\t// Define the behavior of the mockers to the point where we can\n\t// successfully start the router.\n\tcontrolTower.On(\"FetchInFlightPayments\").Return(\n\t\t[]*channeldb.MPPayment{}, nil,\n\t)\n\tpayer.On(\"CleanStore\", mock.Anything).Return(nil)\n\n\t// Create and start the router.\n\trouter, err := New(Config{\n\t\tControl:        controlTower,\n\t\tSessionSource:  sessionSource,\n\t\tMissionControl: missionControl,\n\t\tPayer:          payer,\n\n\t\t// TODO(yy): create new mocks for the chain and chainview.\n\t\tChain:     chain,\n\t\tChainView: chainView,\n\n\t\t// TODO(yy): mock the graph once it's changed into interface.\n\t\tGraph: testGraph.graph,\n\n\t\tClock:              clock.NewTestClock(time.Unix(1, 0)),\n\t\tGraphPruneInterval: time.Hour * 2,\n\t\tNextPaymentID: func() (uint64, error) {\n\t\t\tnext := atomic.AddUint64(&uniquePaymentID, 1)\n\t\t\treturn next, nil\n\t\t},\n\n\t\tIsAlias: func(scid lnwire.ShortChannelID) bool {\n\t\t\treturn false\n\t\t},\n\t})\n\trequire.NoError(t, err, \"failed to create router\")\n\n\t// Make sure the router can start and stop without error.\n\trequire.NoError(t, router.Start(), \"router failed to start\")\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, router.Stop(), \"router failed to stop\")\n\t})\n\n\t// Once the router is started, check that the mocked methods are called\n\t// as expected.\n\tcontrolTower.AssertExpectations(t)\n\tpayer.AssertExpectations(t)\n\n\t// Mock the methods to the point where we are inside the function\n\t// resumePayment.\n\tpaymentAmt := lnwire.MilliSatoshi(10000)\n\treq := createDummyLightningPayment(\n\t\tt, testGraph.aliasMap[\"c\"], paymentAmt,\n\t)\n\tidentifier := lntypes.Hash(req.Identifier())\n\tsession := &mockPaymentSession{}\n\tsessionSource.On(\"NewPaymentSession\", req).Return(session, nil)\n\tcontrolTower.On(\"InitPayment\", identifier, mock.Anything).Return(nil)\n\n\t// The following mocked methods are called inside resumePayment. Note\n\t// that the payment object below will determine the state of the\n\t// paymentLifecycle.\n\tpayment := &channeldb.MPPayment{\n\t\tInfo: &channeldb.PaymentCreationInfo{Value: paymentAmt},\n\t}\n\tcontrolTower.On(\"FetchPayment\", identifier).Return(payment, nil)\n\n\t// Create a route that can send 1/4 of the total amount. This value\n\t// will be returned by calling RequestRoute.\n\tshard, err := createTestRoute(paymentAmt/4, testGraph.aliasMap)\n\trequire.NoError(t, err, \"failed to create route\")\n\tsession.On(\"RequestRoute\",\n\t\tmock.Anything, mock.Anything, mock.Anything, mock.Anything,\n\t).Return(shard, nil)\n\n\t// Make a new htlc attempt with zero fee and append it to the payment's\n\t// HTLCs when calling RegisterAttempt.\n\tactiveAttempt := makeActiveAttempt(int(paymentAmt/4), 0)\n\tcontrolTower.On(\"RegisterAttempt\",\n\t\tidentifier, mock.Anything,\n\t).Return(nil).Run(func(args mock.Arguments) {\n\t\tpayment.HTLCs = append(payment.HTLCs, activeAttempt)\n\t})\n\n\t// Create a buffered chan and it will be returned by GetAttemptResult.\n\tpayer.resultChan = make(chan *htlcswitch.PaymentResult, 10)\n\n\t// We use the getPaymentResultCnt to track how many times we called\n\t// GetAttemptResult. As shard launch is sequential, and we fail the\n\t// first shard that calls GetAttemptResult, we may end up with different\n\t// counts since the lifecycle itself is asynchronous. To avoid flakes\n\t// due to this undeterminsitic behavior, we'll compare the final\n\t// getPaymentResultCnt with other counters to create a final test\n\t// expectation.\n\tgetPaymentResultCnt := 0\n\tpayer.On(\"GetAttemptResult\",\n\t\tmock.Anything, identifier, mock.Anything,\n\t).Run(func(args mock.Arguments) {\n\t\t// Before the mock method is returned, we send the result to\n\t\t// the read-only chan.\n\n\t\t// Update the counter.\n\t\tgetPaymentResultCnt++\n\n\t\t// We fail the first attempt with terminal error.\n\t\tif getPaymentResultCnt == 1 {\n\t\t\tpayer.resultChan <- &htlcswitch.PaymentResult{\n\t\t\t\tError: htlcswitch.NewForwardingError(\n\t\t\t\t\t&lnwire.FailIncorrectDetails{},\n\t\t\t\t\t1,\n\t\t\t\t),\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\t// For the rest of the attempts we'll simulate that a network\n\t\t// result update_fail_htlc has been received. This way the\n\t\t// payment will fail cleanly.\n\t\tpayer.resultChan <- &htlcswitch.PaymentResult{\n\t\t\tError: htlcswitch.NewForwardingError(\n\t\t\t\t&lnwire.FailTemporaryChannelFailure{},\n\t\t\t\t1,\n\t\t\t),\n\t\t}\n\t})\n\n\t// Mock the FailAttempt method to fail (at least once).\n\tvar failedAttempt channeldb.HTLCAttempt\n\tcontrolTower.On(\"FailAttempt\",\n\t\tidentifier, mock.Anything, mock.Anything,\n\t).Return(&failedAttempt, nil).Run(func(args mock.Arguments) {\n\t\t// Whenever this method is invoked, we will mark the first\n\t\t// active attempt as failed and exit.\n\t\tfailedAttempt = payment.HTLCs[0]\n\t\tfailedAttempt.Failure = &channeldb.HTLCFailInfo{}\n\t\tpayment.HTLCs[0] = failedAttempt\n\t})\n\n\t// Setup ReportPaymentFail to return nil reason and error so the\n\t// payment won't fail.\n\tfailureReason := channeldb.FailureReasonPaymentDetails\n\tcntReportPaymentFail := 0\n\tmissionControl.On(\"ReportPaymentFail\",\n\t\tmock.Anything, mock.Anything, mock.Anything, mock.Anything,\n\t).Return(&failureReason, nil).Run(func(args mock.Arguments) {\n\t\tpayment.FailureReason = &failureReason\n\t\tcntReportPaymentFail++\n\t})\n\n\t// Simple mocking the rest.\n\tcntFail := 0\n\tcontrolTower.On(\"FailPayment\", identifier, failureReason).Return(nil)\n\tpayer.On(\"SendHTLC\",\n\t\tmock.Anything, mock.Anything, mock.Anything,\n\t).Return(nil).Run(func(args mock.Arguments) {\n\t\tcntFail++\n\t})\n\n\t// Call the actual method SendPayment on router. This is place inside a\n\t// goroutine so we can set a timeout for the whole test, in case\n\t// anything goes wrong and the test never finishes.\n\tdone := make(chan struct{})\n\tvar p lntypes.Hash\n\tgo func() {\n\t\tp, _, err = router.SendPayment(req)\n\t\tclose(done)\n\t}()\n\n\tselect {\n\tcase <-done:\n\tcase <-time.After(testTimeout):\n\t\tt.Fatalf(\"SendPayment didn't exit\")\n\t}\n\n\t// Finally, validate the returned values and check that the mock\n\t// methods are called as expected.\n\trequire.Error(t, err, \"expected send payment error\")\n\trequire.EqualValues(t, [32]byte{}, p, \"preimage not match\")\n\trequire.GreaterOrEqual(t, getPaymentResultCnt, 1)\n\trequire.Equal(t, getPaymentResultCnt, cntReportPaymentFail)\n\trequire.Equal(t, getPaymentResultCnt, cntFail)\n\n\tcontrolTower.AssertExpectations(t)\n\tpayer.AssertExpectations(t)\n\tsessionSource.AssertExpectations(t)\n\tsession.AssertExpectations(t)\n\tmissionControl.AssertExpectations(t)\n}\n\n// TestBlockDifferenceFix tests if when the router is behind on blocks, the\n// router catches up to the best block head.",
      "length": 6535,
      "tokens": 733,
      "embedding": []
    },
    {
      "slug": "func TestBlockDifferenceFix(t *testing.T) {",
      "content": "func TestBlockDifferenceFix(t *testing.T) {\n\tt.Parallel()\n\n\tinitialBlockHeight := uint32(0)\n\n\t// Starting height here is set to 0, which is behind where we want to be.\n\tctx := createTestCtxSingleNode(t, initialBlockHeight)\n\n\t// Add initial block to our mini blockchain.\n\tblock := &wire.MsgBlock{\n\t\tTransactions: []*wire.MsgTx{},\n\t}\n\tctx.chain.addBlock(block, initialBlockHeight, rand.Uint32())\n\n\t// Let's generate a new block of height 5, 5 above where our node is at.\n\tnewBlock := &wire.MsgBlock{\n\t\tTransactions: []*wire.MsgTx{},\n\t}\n\tnewBlockHeight := uint32(5)\n\n\tblockDifference := newBlockHeight - initialBlockHeight\n\n\tctx.chainView.notifyBlockAck = make(chan struct{}, 1)\n\n\tctx.chain.addBlock(newBlock, newBlockHeight, rand.Uint32())\n\tctx.chain.setBestBlock(int32(newBlockHeight))\n\tctx.chainView.notifyBlock(block.BlockHash(), newBlockHeight,\n\t\t[]*wire.MsgTx{}, t)\n\n\t<-ctx.chainView.notifyBlockAck\n\n\t// At this point, the chain notifier should have noticed that we're\n\t// behind on blocks, and will send the n missing blocks that we\n\t// need to the client's epochs channel. Let's replicate this\n\t// functionality.\n\tfor i := 0; i < int(blockDifference); i++ {\n\t\tcurrBlockHeight := int32(i + 1)\n\n\t\tnonce := rand.Uint32()\n\n\t\tnewBlock := &wire.MsgBlock{\n\t\t\tTransactions: []*wire.MsgTx{},\n\t\t\tHeader:       wire.BlockHeader{Nonce: nonce},\n\t\t}\n\t\tctx.chain.addBlock(newBlock, uint32(currBlockHeight), nonce)\n\t\tcurrHash := newBlock.Header.BlockHash()\n\n\t\tnewEpoch := &chainntnfs.BlockEpoch{\n\t\t\tHeight: currBlockHeight,\n\t\t\tHash:   &currHash,\n\t\t}\n\n\t\tctx.notifier.EpochChan <- newEpoch\n\n\t\tctx.chainView.notifyBlock(currHash,\n\t\t\tuint32(currBlockHeight), block.Transactions, t)\n\n\t\t<-ctx.chainView.notifyBlockAck\n\t}\n\n\terr := wait.NoError(func() error {\n\t\t// Then router height should be updated to the latest block.\n\t\tif atomic.LoadUint32(&ctx.router.bestHeight) != newBlockHeight {\n\t\t\treturn fmt.Errorf(\"height should have been updated \"+\n\t\t\t\t\"to %v, instead got %v\", newBlockHeight,\n\t\t\t\tctx.router.bestHeight)\n\t\t}\n\n\t\treturn nil\n\t}, testTimeout)\n\trequire.NoError(t, err, \"block height wasn't updated\")\n}\n\n// TestSendToRouteSkipTempErrSuccess validates a successful payment send.",
      "length": 2051,
      "tokens": 225,
      "embedding": []
    },
    {
      "slug": "func TestSendToRouteSkipTempErrSuccess(t *testing.T) {",
      "content": "func TestSendToRouteSkipTempErrSuccess(t *testing.T) {\n\tvar (\n\t\tpayHash     lntypes.Hash\n\t\tpayAmt      = lnwire.MilliSatoshi(10000)\n\t\ttestAttempt = &channeldb.HTLCAttempt{}\n\t)\n\n\tnode, err := createTestNode()\n\trequire.NoError(t, err)\n\n\t// Create a simple 1-hop route.\n\thops := []*route.Hop{\n\t\t{\n\t\t\tChannelID:    1,\n\t\t\tPubKeyBytes:  node.PubKeyBytes,\n\t\t\tAmtToForward: payAmt,\n\t\t\tMPP:          record.NewMPP(payAmt, [32]byte{}),\n\t\t},\n\t}\n\trt, err := route.NewRouteFromHops(payAmt, 100, node.PubKeyBytes, hops)\n\trequire.NoError(t, err)\n\n\t// Create mockers.\n\tcontrolTower := &mockControlTower{}\n\tpayer := &mockPaymentAttemptDispatcher{}\n\tmissionControl := &mockMissionControl{}\n\n\t// Create the router.\n\trouter := &ChannelRouter{cfg: &Config{\n\t\tControl:        controlTower,\n\t\tPayer:          payer,\n\t\tMissionControl: missionControl,\n\t\tClock:          clock.NewTestClock(time.Unix(1, 0)),\n\t\tNextPaymentID: func() (uint64, error) {\n\t\t\treturn 0, nil\n\t\t},\n\t}}\n\n\t// Register mockers with the expected method calls.\n\tcontrolTower.On(\"InitPayment\", payHash, mock.Anything).Return(nil)\n\tcontrolTower.On(\"RegisterAttempt\", payHash, mock.Anything).Return(nil)\n\tcontrolTower.On(\"SettleAttempt\",\n\t\tpayHash, mock.Anything, mock.Anything,\n\t).Return(testAttempt, nil)\n\n\tpayer.On(\"SendHTLC\",\n\t\tmock.Anything, mock.Anything, mock.Anything,\n\t).Return(nil)\n\n\t// Create a buffered chan and it will be returned by GetAttemptResult.\n\tpayer.resultChan = make(chan *htlcswitch.PaymentResult, 1)\n\tpayer.On(\"GetAttemptResult\",\n\t\tmock.Anything, mock.Anything, mock.Anything,\n\t).Run(func(_ mock.Arguments) {\n\t\t// Send a successful payment result.\n\t\tpayer.resultChan <- &htlcswitch.PaymentResult{}\n\t})\n\n\tmissionControl.On(\"ReportPaymentSuccess\",\n\t\tmock.Anything, rt,\n\t).Return(nil)\n\n\t// Expect a successful send to route.\n\tattempt, err := router.SendToRouteSkipTempErr(payHash, rt)\n\trequire.NoError(t, err)\n\trequire.Equal(t, testAttempt, attempt)\n\n\t// Assert the above methods are called as expected.\n\tcontrolTower.AssertExpectations(t)\n\tpayer.AssertExpectations(t)\n\tmissionControl.AssertExpectations(t)\n}\n\n// TestSendToRouteSkipTempErrTempFailure validates a temporary failure won't\n// cause the payment to be failed.",
      "length": 2055,
      "tokens": 193,
      "embedding": []
    },
    {
      "slug": "func TestSendToRouteSkipTempErrTempFailure(t *testing.T) {",
      "content": "func TestSendToRouteSkipTempErrTempFailure(t *testing.T) {\n\tvar (\n\t\tpayHash     lntypes.Hash\n\t\tpayAmt      = lnwire.MilliSatoshi(10000)\n\t\ttestAttempt = &channeldb.HTLCAttempt{}\n\t)\n\n\tnode, err := createTestNode()\n\trequire.NoError(t, err)\n\n\t// Create a simple 1-hop route.\n\thops := []*route.Hop{\n\t\t{\n\t\t\tChannelID:    1,\n\t\t\tPubKeyBytes:  node.PubKeyBytes,\n\t\t\tAmtToForward: payAmt,\n\t\t\tMPP:          record.NewMPP(payAmt, [32]byte{}),\n\t\t},\n\t}\n\trt, err := route.NewRouteFromHops(payAmt, 100, node.PubKeyBytes, hops)\n\trequire.NoError(t, err)\n\n\t// Create mockers.\n\tcontrolTower := &mockControlTower{}\n\tpayer := &mockPaymentAttemptDispatcher{}\n\tmissionControl := &mockMissionControl{}\n\n\t// Create the router.\n\trouter := &ChannelRouter{cfg: &Config{\n\t\tControl:        controlTower,\n\t\tPayer:          payer,\n\t\tMissionControl: missionControl,\n\t\tClock:          clock.NewTestClock(time.Unix(1, 0)),\n\t\tNextPaymentID: func() (uint64, error) {\n\t\t\treturn 0, nil\n\t\t},\n\t}}\n\n\t// Register mockers with the expected method calls.\n\tcontrolTower.On(\"InitPayment\", payHash, mock.Anything).Return(nil)\n\tcontrolTower.On(\"RegisterAttempt\", payHash, mock.Anything).Return(nil)\n\tcontrolTower.On(\"FailAttempt\",\n\t\tpayHash, mock.Anything, mock.Anything,\n\t).Return(testAttempt, nil)\n\n\tpayer.On(\"SendHTLC\",\n\t\tmock.Anything, mock.Anything, mock.Anything,\n\t).Return(nil)\n\n\t// Create a buffered chan and it will be returned by GetAttemptResult.\n\tpayer.resultChan = make(chan *htlcswitch.PaymentResult, 1)\n\n\t// Create the error to be returned.\n\ttempErr := htlcswitch.NewForwardingError(\n\t\t&lnwire.FailTemporaryChannelFailure{},\n\t\t1,\n\t)\n\n\t// Mock GetAttemptResult to return a failure.\n\tpayer.On(\"GetAttemptResult\",\n\t\tmock.Anything, mock.Anything, mock.Anything,\n\t).Run(func(_ mock.Arguments) {\n\t\t// Send an attempt failure.\n\t\tpayer.resultChan <- &htlcswitch.PaymentResult{\n\t\t\tError: tempErr,\n\t\t}\n\t})\n\n\t// Return a nil reason to mock a temporary failure.\n\tmissionControl.On(\"ReportPaymentFail\",\n\t\tmock.Anything, rt, mock.Anything, mock.Anything,\n\t).Return(nil, nil)\n\n\t// Expect a failed send to route.\n\tattempt, err := router.SendToRouteSkipTempErr(payHash, rt)\n\trequire.Equal(t, tempErr, err)\n\trequire.Equal(t, testAttempt, attempt)\n\n\t// Assert the above methods are called as expected.\n\tcontrolTower.AssertExpectations(t)\n\tpayer.AssertExpectations(t)\n\tmissionControl.AssertExpectations(t)\n}\n\n// TestSendToRouteSkipTempErrPermanentFailure validates a permanent failure\n// will fail the payment.",
      "length": 2311,
      "tokens": 226,
      "embedding": []
    },
    {
      "slug": "func TestSendToRouteSkipTempErrPermanentFailure(t *testing.T) {",
      "content": "func TestSendToRouteSkipTempErrPermanentFailure(t *testing.T) {\n\tvar (\n\t\tpayHash     lntypes.Hash\n\t\tpayAmt      = lnwire.MilliSatoshi(10000)\n\t\ttestAttempt = &channeldb.HTLCAttempt{}\n\t)\n\n\tnode, err := createTestNode()\n\trequire.NoError(t, err)\n\n\t// Create a simple 1-hop route.\n\thops := []*route.Hop{\n\t\t{\n\t\t\tChannelID:    1,\n\t\t\tPubKeyBytes:  node.PubKeyBytes,\n\t\t\tAmtToForward: payAmt,\n\t\t\tMPP:          record.NewMPP(payAmt, [32]byte{}),\n\t\t},\n\t}\n\trt, err := route.NewRouteFromHops(payAmt, 100, node.PubKeyBytes, hops)\n\trequire.NoError(t, err)\n\n\t// Create mockers.\n\tcontrolTower := &mockControlTower{}\n\tpayer := &mockPaymentAttemptDispatcher{}\n\tmissionControl := &mockMissionControl{}\n\n\t// Create the router.\n\trouter := &ChannelRouter{cfg: &Config{\n\t\tControl:        controlTower,\n\t\tPayer:          payer,\n\t\tMissionControl: missionControl,\n\t\tClock:          clock.NewTestClock(time.Unix(1, 0)),\n\t\tNextPaymentID: func() (uint64, error) {\n\t\t\treturn 0, nil\n\t\t},\n\t}}\n\n\t// Register mockers with the expected method calls.\n\tcontrolTower.On(\"InitPayment\", payHash, mock.Anything).Return(nil)\n\tcontrolTower.On(\"RegisterAttempt\", payHash, mock.Anything).Return(nil)\n\tcontrolTower.On(\"FailAttempt\",\n\t\tpayHash, mock.Anything, mock.Anything,\n\t).Return(testAttempt, nil)\n\n\t// Expect the payment to be failed.\n\tcontrolTower.On(\"FailPayment\", payHash, mock.Anything).Return(nil)\n\n\tpayer.On(\"SendHTLC\",\n\t\tmock.Anything, mock.Anything, mock.Anything,\n\t).Return(nil)\n\n\t// Create a buffered chan and it will be returned by GetAttemptResult.\n\tpayer.resultChan = make(chan *htlcswitch.PaymentResult, 1)\n\n\t// Create the error to be returned.\n\tpermErr := htlcswitch.NewForwardingError(\n\t\t&lnwire.FailIncorrectDetails{}, 1,\n\t)\n\n\t// Mock GetAttemptResult to return a failure.\n\tpayer.On(\"GetAttemptResult\",\n\t\tmock.Anything, mock.Anything, mock.Anything,\n\t).Run(func(_ mock.Arguments) {\n\t\t// Send a permanent failure.\n\t\tpayer.resultChan <- &htlcswitch.PaymentResult{\n\t\t\tError: permErr,\n\t\t}\n\t})\n\n\t// Return a reason to mock a permanent failure.\n\tfailureReason := channeldb.FailureReasonPaymentDetails\n\tmissionControl.On(\"ReportPaymentFail\",\n\t\tmock.Anything, rt, mock.Anything, mock.Anything,\n\t).Return(&failureReason, nil)\n\n\t// Expect a failed send to route.\n\tattempt, err := router.SendToRouteSkipTempErr(payHash, rt)\n\trequire.Equal(t, permErr, err)\n\trequire.Equal(t, testAttempt, attempt)\n\n\t// Assert the above methods are called as expected.\n\tcontrolTower.AssertExpectations(t)\n\tpayer.AssertExpectations(t)\n\tmissionControl.AssertExpectations(t)\n}\n\n// TestSendToRouteTempFailure validates a temporary failure will cause the\n// payment to be failed.",
      "length": 2467,
      "tokens": 241,
      "embedding": []
    },
    {
      "slug": "func TestSendToRouteTempFailure(t *testing.T) {",
      "content": "func TestSendToRouteTempFailure(t *testing.T) {\n\tvar (\n\t\tpayHash     lntypes.Hash\n\t\tpayAmt      = lnwire.MilliSatoshi(10000)\n\t\ttestAttempt = &channeldb.HTLCAttempt{}\n\t)\n\n\tnode, err := createTestNode()\n\trequire.NoError(t, err)\n\n\t// Create a simple 1-hop route.\n\thops := []*route.Hop{\n\t\t{\n\t\t\tChannelID:    1,\n\t\t\tPubKeyBytes:  node.PubKeyBytes,\n\t\t\tAmtToForward: payAmt,\n\t\t\tMPP:          record.NewMPP(payAmt, [32]byte{}),\n\t\t},\n\t}\n\trt, err := route.NewRouteFromHops(payAmt, 100, node.PubKeyBytes, hops)\n\trequire.NoError(t, err)\n\n\t// Create mockers.\n\tcontrolTower := &mockControlTower{}\n\tpayer := &mockPaymentAttemptDispatcher{}\n\tmissionControl := &mockMissionControl{}\n\n\t// Create the router.\n\trouter := &ChannelRouter{cfg: &Config{\n\t\tControl:        controlTower,\n\t\tPayer:          payer,\n\t\tMissionControl: missionControl,\n\t\tClock:          clock.NewTestClock(time.Unix(1, 0)),\n\t\tNextPaymentID: func() (uint64, error) {\n\t\t\treturn 0, nil\n\t\t},\n\t}}\n\n\t// Register mockers with the expected method calls.\n\tcontrolTower.On(\"InitPayment\", payHash, mock.Anything).Return(nil)\n\tcontrolTower.On(\"RegisterAttempt\", payHash, mock.Anything).Return(nil)\n\tcontrolTower.On(\"FailAttempt\",\n\t\tpayHash, mock.Anything, mock.Anything,\n\t).Return(testAttempt, nil)\n\n\t// Expect the payment to be failed.\n\tcontrolTower.On(\"FailPayment\", payHash, mock.Anything).Return(nil)\n\n\tpayer.On(\"SendHTLC\",\n\t\tmock.Anything, mock.Anything, mock.Anything,\n\t).Return(nil)\n\n\t// Create a buffered chan and it will be returned by GetAttemptResult.\n\tpayer.resultChan = make(chan *htlcswitch.PaymentResult, 1)\n\n\t// Create the error to be returned.\n\ttempErr := htlcswitch.NewForwardingError(\n\t\t&lnwire.FailTemporaryChannelFailure{},\n\t\t1,\n\t)\n\n\t// Mock GetAttemptResult to return a failure.\n\tpayer.On(\"GetAttemptResult\",\n\t\tmock.Anything, mock.Anything, mock.Anything,\n\t).Run(func(_ mock.Arguments) {\n\t\t// Send an attempt failure.\n\t\tpayer.resultChan <- &htlcswitch.PaymentResult{\n\t\t\tError: tempErr,\n\t\t}\n\t})\n\n\t// Return a nil reason to mock a temporary failure.\n\tmissionControl.On(\"ReportPaymentFail\",\n\t\tmock.Anything, rt, mock.Anything, mock.Anything,\n\t).Return(nil, nil)\n\n\t// Expect a failed send to route.\n\tattempt, err := router.SendToRoute(payHash, rt)\n\trequire.Equal(t, tempErr, err)\n\trequire.Equal(t, testAttempt, attempt)\n\n\t// Assert the above methods are called as expected.\n\tcontrolTower.AssertExpectations(t)\n\tpayer.AssertExpectations(t)\n\tmissionControl.AssertExpectations(t)\n}\n",
      "length": 2303,
      "tokens": 225,
      "embedding": []
    }
  ]
}