{
  "filepath": "../implementations/go/lnd/routing/ann_validation.go",
  "package": "routing",
  "sections": [
    {
      "slug": "func ValidateChannelAnn(a *lnwire.ChannelAnnouncement) error {",
      "content": "func ValidateChannelAnn(a *lnwire.ChannelAnnouncement) error {\n\t// First, we'll compute the digest (h) which is to be signed by each of\n\t// the keys included within the node announcement message. This hash\n\t// digest includes all the keys, so the (up to 4 signatures) will\n\t// attest to the validity of each of the keys.\n\tdata, err := a.DataToSign()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdataHash := chainhash.DoubleHashB(data)\n\n\t// First we'll verify that the passed bitcoin key signature is indeed a\n\t// signature over the computed hash digest.\n\tbitcoinSig1, err := a.BitcoinSig1.ToSignature()\n\tif err != nil {\n\t\treturn err\n\t}\n\tbitcoinKey1, err := btcec.ParsePubKey(a.BitcoinKey1[:])\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !bitcoinSig1.Verify(dataHash, bitcoinKey1) {\n\t\treturn errors.New(\"can't verify first bitcoin signature\")\n\t}\n\n\t// If that checks out, then we'll verify that the second bitcoin\n\t// signature is a valid signature of the bitcoin public key over hash\n\t// digest as well.\n\tbitcoinSig2, err := a.BitcoinSig2.ToSignature()\n\tif err != nil {\n\t\treturn err\n\t}\n\tbitcoinKey2, err := btcec.ParsePubKey(a.BitcoinKey2[:])\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !bitcoinSig2.Verify(dataHash, bitcoinKey2) {\n\t\treturn errors.New(\"can't verify second bitcoin signature\")\n\t}\n\n\t// Both node signatures attached should indeed be a valid signature\n\t// over the selected digest of the channel announcement signature.\n\tnodeSig1, err := a.NodeSig1.ToSignature()\n\tif err != nil {\n\t\treturn err\n\t}\n\tnodeKey1, err := btcec.ParsePubKey(a.NodeID1[:])\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !nodeSig1.Verify(dataHash, nodeKey1) {\n\t\treturn errors.New(\"can't verify data in first node signature\")\n\t}\n\n\tnodeSig2, err := a.NodeSig2.ToSignature()\n\tif err != nil {\n\t\treturn err\n\t}\n\tnodeKey2, err := btcec.ParsePubKey(a.NodeID2[:])\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !nodeSig2.Verify(dataHash, nodeKey2) {\n\t\treturn errors.New(\"can't verify data in second node signature\")\n\t}\n\n\treturn nil\n\n}\n\n// ValidateNodeAnn validates the node announcement by ensuring that the\n// attached signature is needed a signature of the node announcement under the\n// specified node public key.",
      "length": 2013,
      "tokens": 309,
      "embedding": []
    },
    {
      "slug": "func ValidateNodeAnn(a *lnwire.NodeAnnouncement) error {",
      "content": "func ValidateNodeAnn(a *lnwire.NodeAnnouncement) error {\n\t// Reconstruct the data of announcement which should be covered by the\n\t// signature so we can verify the signature shortly below\n\tdata, err := a.DataToSign()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tnodeSig, err := a.Signature.ToSignature()\n\tif err != nil {\n\t\treturn err\n\t}\n\tnodeKey, err := btcec.ParsePubKey(a.NodeID[:])\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Finally ensure that the passed signature is valid, if not we'll\n\t// return an error so this node announcement can be rejected.\n\tdataHash := chainhash.DoubleHashB(data)\n\tif !nodeSig.Verify(dataHash, nodeKey) {\n\t\tvar msgBuf bytes.Buffer\n\t\tif _, err := lnwire.WriteMessage(&msgBuf, a, 0); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn errors.Errorf(\"signature on NodeAnnouncement(%x) is \"+\n\t\t\t\"invalid: %x\", nodeKey.SerializeCompressed(),\n\t\t\tmsgBuf.Bytes())\n\t}\n\n\treturn nil\n}\n\n// ValidateChannelUpdateAnn validates the channel update announcement by\n// checking (1) that the included signature covers the announcement and has been\n// signed by the node's private key, and (2) that the announcement's message\n// flags and optional fields are sane.",
      "length": 1058,
      "tokens": 160,
      "embedding": []
    },
    {
      "slug": "func ValidateChannelUpdateAnn(pubKey *btcec.PublicKey, capacity btcutil.Amount,",
      "content": "func ValidateChannelUpdateAnn(pubKey *btcec.PublicKey, capacity btcutil.Amount,\n\ta *lnwire.ChannelUpdate) error {\n\n\tif err := ValidateChannelUpdateFields(capacity, a); err != nil {\n\t\treturn err\n\t}\n\n\treturn VerifyChannelUpdateSignature(a, pubKey)\n}\n\n// VerifyChannelUpdateSignature verifies that the channel update message was\n// signed by the party with the given node public key.",
      "length": 290,
      "tokens": 40,
      "embedding": []
    },
    {
      "slug": "func VerifyChannelUpdateSignature(msg *lnwire.ChannelUpdate,",
      "content": "func VerifyChannelUpdateSignature(msg *lnwire.ChannelUpdate,\n\tpubKey *btcec.PublicKey) error {\n\n\tdata, err := msg.DataToSign()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to reconstruct message data: %v\", err)\n\t}\n\tdataHash := chainhash.DoubleHashB(data)\n\n\tnodeSig, err := msg.Signature.ToSignature()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !nodeSig.Verify(dataHash, pubKey) {\n\t\treturn fmt.Errorf(\"invalid signature for channel update %v\",\n\t\t\tspew.Sdump(msg))\n\t}\n\n\treturn nil\n}\n\n// ValidateChannelUpdateFields validates a channel update's message flags and\n// corresponding update fields.",
      "length": 503,
      "tokens": 66,
      "embedding": []
    },
    {
      "slug": "func ValidateChannelUpdateFields(capacity btcutil.Amount,",
      "content": "func ValidateChannelUpdateFields(capacity btcutil.Amount,\n\tmsg *lnwire.ChannelUpdate) error {\n\n\t// The maxHTLC flag is mandatory.\n\tif !msg.MessageFlags.HasMaxHtlc() {\n\t\treturn errors.Errorf(\"max htlc flag not set for channel \"+\n\t\t\t\"update %v\", spew.Sdump(msg))\n\t}\n\n\tmaxHtlc := msg.HtlcMaximumMsat\n\tif maxHtlc == 0 || maxHtlc < msg.HtlcMinimumMsat {\n\t\treturn errors.Errorf(\"invalid max htlc for channel \"+\n\t\t\t\"update %v\", spew.Sdump(msg))\n\t}\n\n\t// For light clients, the capacity will not be set so we'll skip\n\t// checking whether the MaxHTLC value respects the channel's\n\t// capacity.\n\tcapacityMsat := lnwire.NewMSatFromSatoshis(capacity)\n\tif capacityMsat != 0 && maxHtlc > capacityMsat {\n\t\treturn errors.Errorf(\"max_htlc (%v) for channel update \"+\n\t\t\t\"greater than capacity (%v)\", maxHtlc, capacityMsat)\n\t}\n\n\treturn nil\n}\n",
      "length": 739,
      "tokens": 102,
      "embedding": []
    }
  ]
}