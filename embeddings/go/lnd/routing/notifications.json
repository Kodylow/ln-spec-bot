{
  "filepath": "../implementations/go/lnd/routing/notifications.go",
  "package": "routing",
  "sections": [
    {
      "slug": "type TopologyClient struct {",
      "content": "type TopologyClient struct {\n\t// TopologyChanges is a receive only channel that new channel graph\n\t// updates will be sent over.\n\t//\n\t// TODO(roasbeef): chan for each update type instead?\n\tTopologyChanges <-chan *TopologyChange\n\n\t// Cancel is a function closure that should be executed when the client\n\t// wishes to cancel their notification intent. Doing so allows the\n\t// ChannelRouter to free up resources.\n\tCancel func()\n}\n\n// topologyClientUpdate is a message sent to the channel router to either\n// register a new topology client or re-register an existing client.",
      "length": 528,
      "tokens": 85,
      "embedding": []
    },
    {
      "slug": "type topologyClientUpdate struct {",
      "content": "type topologyClientUpdate struct {\n\t// cancel indicates if the update to the client is cancelling an\n\t// existing client's notifications. If not then this update will be to\n\t// register a new set of notifications.\n\tcancel bool\n\n\t// clientID is the unique identifier for this client. Any further\n\t// updates (deleting or adding) to this notification client will be\n\t// dispatched according to the target clientID.\n\tclientID uint64\n\n\t// ntfnChan is a *send-only* channel in which notifications should be\n\t// sent over from router -> client.\n\tntfnChan chan<- *TopologyChange\n}\n\n// SubscribeTopology returns a new topology client which can be used by the\n// caller to receive notifications whenever a change in the channel graph\n// topology occurs. Changes that will be sent at notifications include: new\n// nodes appearing, node updating their attributes, new channels, channels\n// closing, and updates in the routing policies of a channel's directed edges.",
      "length": 900,
      "tokens": 146,
      "embedding": []
    },
    {
      "slug": "func (r *ChannelRouter) SubscribeTopology() (*TopologyClient, error) {",
      "content": "func (r *ChannelRouter) SubscribeTopology() (*TopologyClient, error) {\n\t// If the router is not yet started, return an error to avoid a\n\t// deadlock waiting for it to handle the subscription request.\n\tif atomic.LoadUint32(&r.started) == 0 {\n\t\treturn nil, fmt.Errorf(\"router not started\")\n\t}\n\n\t// We'll first atomically obtain the next ID for this client from the\n\t// incrementing client ID counter.\n\tclientID := atomic.AddUint64(&r.ntfnClientCounter, 1)\n\n\tlog.Debugf(\"New graph topology client subscription, client %v\",\n\t\tclientID)\n\n\tntfnChan := make(chan *TopologyChange, 10)\n\n\tselect {\n\tcase r.ntfnClientUpdates <- &topologyClientUpdate{\n\t\tcancel:   false,\n\t\tclientID: clientID,\n\t\tntfnChan: ntfnChan,\n\t}:\n\tcase <-r.quit:\n\t\treturn nil, errors.New(\"ChannelRouter shutting down\")\n\t}\n\n\treturn &TopologyClient{\n\t\tTopologyChanges: ntfnChan,\n\t\tCancel: func() {\n\t\t\tselect {\n\t\t\tcase r.ntfnClientUpdates <- &topologyClientUpdate{\n\t\t\t\tcancel:   true,\n\t\t\t\tclientID: clientID,\n\t\t\t}:\n\t\t\tcase <-r.quit:\n\t\t\t\treturn\n\t\t\t}\n\t\t},\n\t}, nil\n}\n\n// topologyClient is a data-structure use by the channel router to couple the\n// client's notification channel along with a special \"exit\" channel that can\n// be used to cancel all lingering goroutines blocked on a send to the\n// notification channel.",
      "length": 1159,
      "tokens": 159,
      "embedding": []
    },
    {
      "slug": "type topologyClient struct {",
      "content": "type topologyClient struct {\n\t// ntfnChan is a send-only channel that's used to propagate\n\t// notification s from the channel router to an instance of a\n\t// topologyClient client.\n\tntfnChan chan<- *TopologyChange\n\n\t// exit is a channel that is used internally by the channel router to\n\t// cancel any active un-consumed goroutine notifications.\n\texit chan struct{}\n\n\twg sync.WaitGroup\n}\n\n// notifyTopologyChange notifies all registered clients of a new change in\n// graph topology in a non-blocking.",
      "length": 456,
      "tokens": 72,
      "embedding": []
    },
    {
      "slug": "func (r *ChannelRouter) notifyTopologyChange(topologyDiff *TopologyChange) {",
      "content": "func (r *ChannelRouter) notifyTopologyChange(topologyDiff *TopologyChange) {\n\n\t// notifyClient is a helper closure that will send topology updates to\n\t// the given client.\n\tnotifyClient := func(clientID uint64, client *topologyClient) bool {\n\t\tclient.wg.Add(1)\n\n\t\tlog.Tracef(\"Sending topology notification to client=%v, \"+\n\t\t\t\"NodeUpdates=%v, ChannelEdgeUpdates=%v, \"+\n\t\t\t\"ClosedChannels=%v\", clientID,\n\t\t\tlen(topologyDiff.NodeUpdates),\n\t\t\tlen(topologyDiff.ChannelEdgeUpdates),\n\t\t\tlen(topologyDiff.ClosedChannels))\n\n\t\tgo func(c *topologyClient) {\n\t\t\tdefer c.wg.Done()\n\n\t\t\tselect {\n\n\t\t\t// In this case we'll try to send the notification\n\t\t\t// directly to the upstream client consumer.\n\t\t\tcase c.ntfnChan <- topologyDiff:\n\n\t\t\t// If the client cancels the notifications, then we'll\n\t\t\t// exit early.\n\t\t\tcase <-c.exit:\n\n\t\t\t// Similarly, if the ChannelRouter itself exists early,\n\t\t\t// then we'll also exit ourselves.\n\t\t\tcase <-r.quit:\n\n\t\t\t}\n\t\t}(client)\n\n\t\t// Always return true here so the following Range will iterate\n\t\t// all clients.\n\t\treturn true\n\t}\n\n\t// Range over the set of active clients, and attempt to send the\n\t// topology updates.\n\tr.topologyClients.Range(notifyClient)\n}\n\n// TopologyChange represents a new set of modifications to the channel graph.\n// Topology changes will be dispatched in real-time as the ChannelGraph\n// validates and process modifications to the authenticated channel graph.",
      "length": 1283,
      "tokens": 168,
      "embedding": []
    },
    {
      "slug": "type TopologyChange struct {",
      "content": "type TopologyChange struct {\n\t// NodeUpdates is a slice of nodes which are either new to the channel\n\t// graph, or have had their attributes updated in an authenticated\n\t// manner.\n\tNodeUpdates []*NetworkNodeUpdate\n\n\t// ChanelEdgeUpdates is a slice of channel edges which are either newly\n\t// opened and authenticated, or have had their routing policies\n\t// updated.\n\tChannelEdgeUpdates []*ChannelEdgeUpdate\n\n\t// ClosedChannels contains a slice of close channel summaries which\n\t// described which block a channel was closed at, and also carry\n\t// supplemental information such as the capacity of the former channel.\n\tClosedChannels []*ClosedChanSummary\n}\n\n// isEmpty returns true if the TopologyChange is empty. A TopologyChange is\n// considered empty, if it contains no *new* updates of any type.",
      "length": 752,
      "tokens": 115,
      "embedding": []
    },
    {
      "slug": "func (t *TopologyChange) isEmpty() bool {",
      "content": "func (t *TopologyChange) isEmpty() bool {\n\treturn len(t.NodeUpdates) == 0 && len(t.ChannelEdgeUpdates) == 0 &&\n\t\tlen(t.ClosedChannels) == 0\n}\n\n// ClosedChanSummary is a summary of a channel that was detected as being\n// closed by monitoring the blockchain. Once a channel's funding point has been\n// spent, the channel will automatically be marked as closed by the\n// ChainNotifier.\n//\n// TODO(roasbeef): add nodes involved?",
      "length": 373,
      "tokens": 59,
      "embedding": []
    },
    {
      "slug": "type ClosedChanSummary struct {",
      "content": "type ClosedChanSummary struct {\n\t// ChanID is the short-channel ID which uniquely identifies the\n\t// channel.\n\tChanID uint64\n\n\t// Capacity was the total capacity of the channel before it was closed.\n\tCapacity btcutil.Amount\n\n\t// ClosedHeight is the height in the chain that the channel was closed\n\t// at.\n\tClosedHeight uint32\n\n\t// ChanPoint is the funding point, or the multi-sig utxo which\n\t// previously represented the channel.\n\tChanPoint wire.OutPoint\n}\n\n// createCloseSummaries takes in a slice of channels closed at the target block\n// height and creates a slice of summaries which of each channel closure.",
      "length": 563,
      "tokens": 91,
      "embedding": []
    },
    {
      "slug": "func createCloseSummaries(blockHeight uint32,",
      "content": "func createCloseSummaries(blockHeight uint32,\n\tclosedChans ...*channeldb.ChannelEdgeInfo) []*ClosedChanSummary {\n\n\tcloseSummaries := make([]*ClosedChanSummary, len(closedChans))\n\tfor i, closedChan := range closedChans {\n\t\tcloseSummaries[i] = &ClosedChanSummary{\n\t\t\tChanID:       closedChan.ChannelID,\n\t\t\tCapacity:     closedChan.Capacity,\n\t\t\tClosedHeight: blockHeight,\n\t\t\tChanPoint:    closedChan.ChannelPoint,\n\t\t}\n\t}\n\n\treturn closeSummaries\n}\n\n// NetworkNodeUpdate is an update for a  node within the Lightning Network. A\n// NetworkNodeUpdate is sent out either when a new node joins the network, or a\n// node broadcasts a new update with a newer time stamp that supersedes its\n// old update. All updates are properly authenticated.",
      "length": 669,
      "tokens": 81,
      "embedding": []
    },
    {
      "slug": "type NetworkNodeUpdate struct {",
      "content": "type NetworkNodeUpdate struct {\n\t// Addresses is a slice of all the node's known addresses.\n\tAddresses []net.Addr\n\n\t// IdentityKey is the identity public key of the target node. This is\n\t// used to encrypt onion blobs as well as to authenticate any new\n\t// updates.\n\tIdentityKey *btcec.PublicKey\n\n\t// Alias is the alias or nick name of the node.\n\tAlias string\n\n\t// Color is the node's color in hex code format.\n\tColor string\n\n\t// Features holds the set of features the node supports.\n\tFeatures *lnwire.FeatureVector\n}\n\n// ChannelEdgeUpdate is an update for a new channel within the ChannelGraph.\n// This update is sent out once a new authenticated channel edge is discovered\n// within the network. These updates are directional, so if a channel is fully\n// public, then there will be two updates sent out: one for each direction\n// within the channel. Each update will carry that particular routing edge\n// policy for the channel direction.\n//\n// An edge is a channel in the direction of AdvertisingNode -> ConnectingNode.",
      "length": 965,
      "tokens": 167,
      "embedding": []
    },
    {
      "slug": "type ChannelEdgeUpdate struct {",
      "content": "type ChannelEdgeUpdate struct {\n\t// ChanID is the unique short channel ID for the channel. This encodes\n\t// where in the blockchain the channel's funding transaction was\n\t// originally confirmed.\n\tChanID uint64\n\n\t// ChanPoint is the outpoint which represents the multi-sig funding\n\t// output for the channel.\n\tChanPoint wire.OutPoint\n\n\t// Capacity is the capacity of the newly created channel.\n\tCapacity btcutil.Amount\n\n\t// MinHTLC is the minimum HTLC amount that this channel will forward.\n\tMinHTLC lnwire.MilliSatoshi\n\n\t// MaxHTLC is the maximum HTLC amount that this channel will forward.\n\tMaxHTLC lnwire.MilliSatoshi\n\n\t// BaseFee is the base fee that will charged for all HTLC's forwarded\n\t// across the this channel direction.\n\tBaseFee lnwire.MilliSatoshi\n\n\t// FeeRate is the fee rate that will be shared for all HTLC's forwarded\n\t// across this channel direction.\n\tFeeRate lnwire.MilliSatoshi\n\n\t// TimeLockDelta is the time-lock expressed in blocks that will be\n\t// added to outgoing HTLC's from incoming HTLC's. This value is the\n\t// difference of the incoming and outgoing HTLC's time-locks routed\n\t// through this hop.\n\tTimeLockDelta uint16\n\n\t// AdvertisingNode is the node that's advertising this edge.\n\tAdvertisingNode *btcec.PublicKey\n\n\t// ConnectingNode is the node that the advertising node connects to.\n\tConnectingNode *btcec.PublicKey\n\n\t// Disabled, if true, signals that the channel is unavailable to relay\n\t// payments.\n\tDisabled bool\n}\n\n// appendTopologyChange appends the passed update message to the passed\n// TopologyChange, properly identifying which type of update the message\n// constitutes. This function will also fetch any required auxiliary\n// information required to create the topology change update from the graph\n// database.",
      "length": 1679,
      "tokens": 251,
      "embedding": []
    },
    {
      "slug": "func addToTopologyChange(graph *channeldb.ChannelGraph, update *TopologyChange,",
      "content": "func addToTopologyChange(graph *channeldb.ChannelGraph, update *TopologyChange,\n\tmsg interface{}) error {\n\n\tswitch m := msg.(type) {\n\n\t// Any node announcement maps directly to a NetworkNodeUpdate struct.\n\t// No further data munging or db queries are required.\n\tcase *channeldb.LightningNode:\n\t\tpubKey, err := m.PubKey()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tnodeUpdate := &NetworkNodeUpdate{\n\t\t\tAddresses:   m.Addresses,\n\t\t\tIdentityKey: pubKey,\n\t\t\tAlias:       m.Alias,\n\t\t\tColor:       EncodeHexColor(m.Color),\n\t\t\tFeatures:    m.Features.Clone(),\n\t\t}\n\n\t\tupdate.NodeUpdates = append(update.NodeUpdates, nodeUpdate)\n\t\treturn nil\n\n\t// We ignore initial channel announcements as we'll only send out\n\t// updates once the individual edges themselves have been updated.\n\tcase *channeldb.ChannelEdgeInfo:\n\t\treturn nil\n\n\t// Any new ChannelUpdateAnnouncements will generate a corresponding\n\t// ChannelEdgeUpdate notification.\n\tcase *channeldb.ChannelEdgePolicy:\n\t\t// We'll need to fetch the edge's information from the database\n\t\t// in order to get the information concerning which nodes are\n\t\t// being connected.\n\t\tedgeInfo, _, _, err := graph.FetchChannelEdgesByID(m.ChannelID)\n\t\tif err != nil {\n\t\t\treturn errors.Errorf(\"unable fetch channel edge: %v\",\n\t\t\t\terr)\n\t\t}\n\n\t\t// If the flag is one, then the advertising node is actually\n\t\t// the second node.\n\t\tsourceNode := edgeInfo.NodeKey1\n\t\tconnectingNode := edgeInfo.NodeKey2\n\t\tif m.ChannelFlags&lnwire.ChanUpdateDirection == 1 {\n\t\t\tsourceNode = edgeInfo.NodeKey2\n\t\t\tconnectingNode = edgeInfo.NodeKey1\n\t\t}\n\n\t\taNode, err := sourceNode()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcNode, err := connectingNode()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tedgeUpdate := &ChannelEdgeUpdate{\n\t\t\tChanID:          m.ChannelID,\n\t\t\tChanPoint:       edgeInfo.ChannelPoint,\n\t\t\tTimeLockDelta:   m.TimeLockDelta,\n\t\t\tCapacity:        edgeInfo.Capacity,\n\t\t\tMinHTLC:         m.MinHTLC,\n\t\t\tMaxHTLC:         m.MaxHTLC,\n\t\t\tBaseFee:         m.FeeBaseMSat,\n\t\t\tFeeRate:         m.FeeProportionalMillionths,\n\t\t\tAdvertisingNode: aNode,\n\t\t\tConnectingNode:  cNode,\n\t\t\tDisabled:        m.ChannelFlags&lnwire.ChanUpdateDisabled != 0,\n\t\t}\n\n\t\t// TODO(roasbeef): add bit to toggle\n\t\tupdate.ChannelEdgeUpdates = append(update.ChannelEdgeUpdates,\n\t\t\tedgeUpdate)\n\t\treturn nil\n\n\tdefault:\n\t\treturn fmt.Errorf(\"unable to add to topology change, \"+\n\t\t\t\"unknown message type %T\", msg)\n\t}\n}\n\n// EncodeHexColor takes a color and returns it in hex code format.",
      "length": 2288,
      "tokens": 271,
      "embedding": []
    },
    {
      "slug": "func EncodeHexColor(color color.RGBA) string {",
      "content": "func EncodeHexColor(color color.RGBA) string {\n\treturn fmt.Sprintf(\"#%02x%02x%02x\", color.R, color.G, color.B)\n}\n",
      "length": 64,
      "tokens": 6,
      "embedding": []
    }
  ]
}