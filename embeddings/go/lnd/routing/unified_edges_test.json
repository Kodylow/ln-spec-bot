{
  "filepath": "../implementations/go/lnd/routing/unified_edges_test.go",
  "package": "routing",
  "sections": [
    {
      "slug": "func TestNodeEdgeUnifier(t *testing.T) {",
      "content": "func TestNodeEdgeUnifier(t *testing.T) {\n\tt.Parallel()\n\n\tsource := route.Vertex{1}\n\ttoNode := route.Vertex{2}\n\tfromNode := route.Vertex{3}\n\tbandwidthHints := &mockBandwidthHints{}\n\n\t// Add two channels between the pair of nodes.\n\tp1 := channeldb.CachedEdgePolicy{\n\t\tFeeProportionalMillionths: 100000,\n\t\tFeeBaseMSat:               30,\n\t\tTimeLockDelta:             60,\n\t\tMessageFlags:              lnwire.ChanUpdateRequiredMaxHtlc,\n\t\tMaxHTLC:                   5000,\n\t\tMinHTLC:                   100,\n\t}\n\tp2 := channeldb.CachedEdgePolicy{\n\t\tFeeProportionalMillionths: 190000,\n\t\tFeeBaseMSat:               10,\n\t\tTimeLockDelta:             40,\n\t\tMessageFlags:              lnwire.ChanUpdateRequiredMaxHtlc,\n\t\tMaxHTLC:                   4000,\n\t\tMinHTLC:                   100,\n\t}\n\tc1 := btcutil.Amount(7)\n\tc2 := btcutil.Amount(8)\n\n\tunifierFilled := newNodeEdgeUnifier(source, toNode, nil)\n\tunifierFilled.addPolicy(fromNode, &p1, c1)\n\tunifierFilled.addPolicy(fromNode, &p2, c2)\n\n\tunifierNoCapacity := newNodeEdgeUnifier(source, toNode, nil)\n\tunifierNoCapacity.addPolicy(fromNode, &p1, 0)\n\tunifierNoCapacity.addPolicy(fromNode, &p2, 0)\n\n\tunifierNoInfo := newNodeEdgeUnifier(source, toNode, nil)\n\tunifierNoInfo.addPolicy(fromNode, &channeldb.CachedEdgePolicy{}, 0)\n\n\ttests := []struct {\n\t\tname             string\n\t\tunifier          *nodeEdgeUnifier\n\t\tamount           lnwire.MilliSatoshi\n\t\texpectedFeeBase  lnwire.MilliSatoshi\n\t\texpectedFeeRate  lnwire.MilliSatoshi\n\t\texpectedTimeLock uint16\n\t\texpectNoPolicy   bool\n\t\texpectedCapacity btcutil.Amount\n\t}{\n\t\t{\n\t\t\tname:           \"amount below min htlc\",\n\t\t\tunifier:        unifierFilled,\n\t\t\tamount:         50,\n\t\t\texpectNoPolicy: true,\n\t\t},\n\t\t{\n\t\t\tname:           \"amount above max htlc\",\n\t\t\tunifier:        unifierFilled,\n\t\t\tamount:         5500,\n\t\t\texpectNoPolicy: true,\n\t\t},\n\t\t// For 200 msat, p1 yields the highest fee. Use that policy to\n\t\t// forward, because it will also match p2 in case p1 does not\n\t\t// have enough balance.\n\t\t{\n\t\t\tname:             \"use p1 with highest fee\",\n\t\t\tunifier:          unifierFilled,\n\t\t\tamount:           200,\n\t\t\texpectedFeeBase:  p1.FeeBaseMSat,\n\t\t\texpectedFeeRate:  p1.FeeProportionalMillionths,\n\t\t\texpectedTimeLock: p1.TimeLockDelta,\n\t\t\texpectedCapacity: c2,\n\t\t},\n\t\t// For 400 sat, p2 yields the highest fee. Use that policy to\n\t\t// forward, because it will also match p1 in case p2 does not\n\t\t// have enough balance. In order to match p1, it needs to have\n\t\t// p1's time lock delta.\n\t\t{\n\t\t\tname:             \"use p2 with highest fee\",\n\t\t\tunifier:          unifierFilled,\n\t\t\tamount:           400,\n\t\t\texpectedFeeBase:  p2.FeeBaseMSat,\n\t\t\texpectedFeeRate:  p2.FeeProportionalMillionths,\n\t\t\texpectedTimeLock: p1.TimeLockDelta,\n\t\t\texpectedCapacity: c2,\n\t\t},\n\t\t// If there's no capacity info present, we fall back to the max\n\t\t// maxHTLC value.\n\t\t{\n\t\t\tname:             \"no capacity info\",\n\t\t\tunifier:          unifierNoCapacity,\n\t\t\tamount:           400,\n\t\t\texpectedFeeBase:  p2.FeeBaseMSat,\n\t\t\texpectedFeeRate:  p2.FeeProportionalMillionths,\n\t\t\texpectedTimeLock: p1.TimeLockDelta,\n\t\t\texpectedCapacity: p1.MaxHTLC.ToSatoshis(),\n\t\t},\n\t\t{\n\t\t\tname:             \"no info\",\n\t\t\tunifier:          unifierNoInfo,\n\t\t\texpectedCapacity: 0,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tedge := test.unifier.edgeUnifiers[fromNode].getEdge(\n\t\t\t\ttest.amount, bandwidthHints,\n\t\t\t)\n\n\t\t\tif test.expectNoPolicy {\n\t\t\t\trequire.Nil(t, edge, \"expected no policy\")\n\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tpolicy := edge.policy\n\t\t\trequire.Equal(t, test.expectedFeeBase,\n\t\t\t\tpolicy.FeeBaseMSat, \"base fee\")\n\t\t\trequire.Equal(t, test.expectedFeeRate,\n\t\t\t\tpolicy.FeeProportionalMillionths, \"fee rate\")\n\t\t\trequire.Equal(t, test.expectedTimeLock,\n\t\t\t\tpolicy.TimeLockDelta, \"timelock\")\n\t\t\trequire.Equal(t, test.expectedCapacity, edge.capacity,\n\t\t\t\t\"capacity\")\n\t\t})\n\t}\n}\n",
      "length": 3694,
      "tokens": 350,
      "embedding": []
    }
  ]
}