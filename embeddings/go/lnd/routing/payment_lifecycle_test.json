{
  "filepath": "../implementations/go/lnd/routing/payment_lifecycle_test.go",
  "package": "routing",
  "sections": [
    {
      "slug": "func createTestRoute(amt lnwire.MilliSatoshi,",
      "content": "func createTestRoute(amt lnwire.MilliSatoshi,\n\taliasMap map[string]route.Vertex) (*route.Route, error) {\n\n\thopFee := lnwire.NewMSatFromSatoshis(3)\n\thop1 := aliasMap[\"b\"]\n\thop2 := aliasMap[\"c\"]\n\thops := []*route.Hop{\n\t\t{\n\t\t\tChannelID:     1,\n\t\t\tPubKeyBytes:   hop1,\n\t\t\tLegacyPayload: true,\n\t\t\tAmtToForward:  amt + hopFee,\n\t\t},\n\t\t{\n\t\t\tChannelID:     2,\n\t\t\tPubKeyBytes:   hop2,\n\t\t\tLegacyPayload: true,\n\t\t\tAmtToForward:  amt,\n\t\t},\n\t}\n\n\t// We create a simple route that we will supply every time the router\n\t// requests one.\n\treturn route.NewRouteFromHops(\n\t\tamt+2*hopFee, 100, aliasMap[\"a\"], hops,\n\t)\n}\n\n// paymentLifecycleTestCase contains the steps that we expect for a payment\n// lifecycle test, and the routes that pathfinding should deliver.",
      "length": 668,
      "tokens": 86,
      "embedding": []
    },
    {
      "slug": "type paymentLifecycleTestCase struct {",
      "content": "type paymentLifecycleTestCase struct {\n\tname string\n\n\t// steps is a list of steps to perform during the testcase.\n\tsteps []string\n\n\t// routes is the sequence of routes we will provide to the\n\t// router when it requests a new route.\n\troutes []*route.Route\n\n\t// paymentErr is the error we expect our payment to fail with. This\n\t// should be nil for tests with paymentSuccess steps and non-nil for\n\t// payments with paymentError steps.\n\tpaymentErr error\n}\n\nconst (\n\t// routerInitPayment is a test step where we expect the router\n\t// to call the InitPayment method on the control tower.\n\trouterInitPayment = \"Router:init-payment\"\n\n\t// routerRegisterAttempt is a test step where we expect the\n\t// router to call the RegisterAttempt method on the control\n\t// tower.\n\trouterRegisterAttempt = \"Router:register-attempt\"\n\n\t// routerSettleAttempt is a test step where we expect the\n\t// router to call the SettleAttempt method on the control\n\t// tower.\n\trouterSettleAttempt = \"Router:settle-attempt\"\n\n\t// routerFailAttempt is a test step where we expect the router\n\t// to call the FailAttempt method on the control tower.\n\trouterFailAttempt = \"Router:fail-attempt\"\n\n\t// routerFailPayment is a test step where we expect the router\n\t// to call the Fail method on the control tower.\n\trouterFailPayment = \"Router:fail-payment\"\n\n\t// routeRelease is a test step where we unblock pathfinding and\n\t// allow it to respond to our test with a route.\n\trouteRelease = \"PaymentSession:release\"\n\n\t// sendToSwitchSuccess is a step where we expect the router to\n\t// call send the payment attempt to the switch, and we will\n\t// respond with a non-error, indicating that the payment\n\t// attempt was successfully forwarded.\n\tsendToSwitchSuccess = \"SendToSwitch:success\"\n\n\t// sendToSwitchResultFailure is a step where we expect the\n\t// router to send the payment attempt to the switch, and we\n\t// will respond with a forwarding error. This can happen when\n\t// forwarding fail on our local links.\n\tsendToSwitchResultFailure = \"SendToSwitch:failure\"\n\n\t// getPaymentResultSuccess is a test step where we expect the\n\t// router to call the GetAttemptResult method, and we will\n\t// respond with a successful payment result.\n\tgetPaymentResultSuccess = \"GetAttemptResult:success\"\n\n\t// getPaymentResultTempFailure is a test step where we expect the\n\t// router to call the GetAttemptResult method, and we will\n\t// respond with a forwarding error, expecting the router to retry.\n\tgetPaymentResultTempFailure = \"GetAttemptResult:temp-failure\"\n\n\t// getPaymentResultTerminalFailure is a test step where we\n\t// expect the router to call the GetAttemptResult method, and\n\t// we will respond with a terminal error, expecting the router\n\t// to stop making payment attempts.\n\tgetPaymentResultTerminalFailure = \"GetAttemptResult:terminal-failure\"\n\n\t// resendPayment is a test step where we manually try to resend\n\t// the same payment, making sure the router responds with an\n\t// error indicating that it is already in flight.\n\tresendPayment = \"ResendPayment\"\n\n\t// startRouter is a step where we manually start the router,\n\t// used to test that it automatically will resume payments at\n\t// startup.\n\tstartRouter = \"StartRouter\"\n\n\t// stopRouter is a test step where we manually make the router\n\t// shut down.\n\tstopRouter = \"StopRouter\"\n\n\t// paymentSuccess is a step where assert that we receive a\n\t// successful result for the original payment made.\n\tpaymentSuccess = \"PaymentSuccess\"\n\n\t// paymentError is a step where assert that we receive an error\n\t// for the original payment made.\n\tpaymentError = \"PaymentError\"\n\n\t// resentPaymentSuccess is a step where assert that we receive\n\t// a successful result for a payment that was resent.\n\tresentPaymentSuccess = \"ResentPaymentSuccess\"\n\n\t// resentPaymentError is a step where assert that we receive an\n\t// error for a payment that was resent.\n\tresentPaymentError = \"ResentPaymentError\"\n)\n\n// TestRouterPaymentStateMachine tests that the router interacts as expected\n// with the ControlTower during a payment lifecycle, such that it payment\n// attempts are not sent twice to the switch, and results are handled after a\n// restart.",
      "length": 3979,
      "tokens": 611,
      "embedding": []
    },
    {
      "slug": "func TestRouterPaymentStateMachine(t *testing.T) {",
      "content": "func TestRouterPaymentStateMachine(t *testing.T) {\n\tt.Parallel()\n\n\tconst startingBlockHeight = 101\n\n\t// Setup two simple channels such that we can mock sending along this\n\t// route.\n\tchanCapSat := btcutil.Amount(100000)\n\ttestChannels := []*testChannel{\n\t\tsymmetricTestChannel(\"a\", \"b\", chanCapSat, &testChannelPolicy{\n\t\t\tExpiry:  144,\n\t\t\tFeeRate: 400,\n\t\t\tMinHTLC: 1,\n\t\t\tMaxHTLC: lnwire.NewMSatFromSatoshis(chanCapSat),\n\t\t}, 1),\n\t\tsymmetricTestChannel(\"b\", \"c\", chanCapSat, &testChannelPolicy{\n\t\t\tExpiry:  144,\n\t\t\tFeeRate: 400,\n\t\t\tMinHTLC: 1,\n\t\t\tMaxHTLC: lnwire.NewMSatFromSatoshis(chanCapSat),\n\t\t}, 2),\n\t}\n\n\ttestGraph, err := createTestGraphFromChannels(t, true, testChannels, \"a\")\n\trequire.NoError(t, err, \"unable to create graph\")\n\n\tpaymentAmt := lnwire.NewMSatFromSatoshis(1000)\n\n\t// We create a simple route that we will supply every time the router\n\t// requests one.\n\trt, err := createTestRoute(paymentAmt, testGraph.aliasMap)\n\trequire.NoError(t, err, \"unable to create route\")\n\n\ttests := []paymentLifecycleTestCase{\n\t\t{\n\t\t\t// Tests a normal payment flow that succeeds.\n\t\t\tname: \"single shot success\",\n\n\t\t\tsteps: []string{\n\t\t\t\trouterInitPayment,\n\t\t\t\trouteRelease,\n\t\t\t\trouterRegisterAttempt,\n\t\t\t\tsendToSwitchSuccess,\n\t\t\t\tgetPaymentResultSuccess,\n\t\t\t\trouterSettleAttempt,\n\t\t\t\tpaymentSuccess,\n\t\t\t},\n\t\t\troutes: []*route.Route{rt},\n\t\t},\n\t\t{\n\t\t\t// A payment flow with a failure on the first attempt,\n\t\t\t// but that succeeds on the second attempt.\n\t\t\tname: \"single shot retry\",\n\n\t\t\tsteps: []string{\n\t\t\t\trouterInitPayment,\n\t\t\t\trouteRelease,\n\t\t\t\trouterRegisterAttempt,\n\t\t\t\tsendToSwitchSuccess,\n\n\t\t\t\t// Make the first sent attempt fail.\n\t\t\t\tgetPaymentResultTempFailure,\n\t\t\t\trouterFailAttempt,\n\n\t\t\t\t// The router should retry.\n\t\t\t\trouteRelease,\n\t\t\t\trouterRegisterAttempt,\n\t\t\t\tsendToSwitchSuccess,\n\n\t\t\t\t// Make the second sent attempt succeed.\n\t\t\t\tgetPaymentResultSuccess,\n\t\t\t\trouterSettleAttempt,\n\t\t\t\tpaymentSuccess,\n\t\t\t},\n\t\t\troutes: []*route.Route{rt, rt},\n\t\t},\n\t\t{\n\t\t\t// A payment flow with a forwarding failure first time\n\t\t\t// sending to the switch, but that succeeds on the\n\t\t\t// second attempt.\n\t\t\tname: \"single shot switch failure\",\n\n\t\t\tsteps: []string{\n\t\t\t\trouterInitPayment,\n\t\t\t\trouteRelease,\n\t\t\t\trouterRegisterAttempt,\n\n\t\t\t\t// Make the first sent attempt fail.\n\t\t\t\tsendToSwitchResultFailure,\n\t\t\t\trouterFailAttempt,\n\n\t\t\t\t// The router should retry.\n\t\t\t\trouteRelease,\n\t\t\t\trouterRegisterAttempt,\n\t\t\t\tsendToSwitchSuccess,\n\n\t\t\t\t// Make the second sent attempt succeed.\n\t\t\t\tgetPaymentResultSuccess,\n\t\t\t\trouterSettleAttempt,\n\t\t\t\tpaymentSuccess,\n\t\t\t},\n\t\t\troutes: []*route.Route{rt, rt},\n\t\t},\n\t\t{\n\t\t\t// A payment that fails on the first attempt, and has\n\t\t\t// only one route available to try. It will therefore\n\t\t\t// fail permanently.\n\t\t\tname: \"single shot route fails\",\n\n\t\t\tsteps: []string{\n\t\t\t\trouterInitPayment,\n\t\t\t\trouteRelease,\n\t\t\t\trouterRegisterAttempt,\n\t\t\t\tsendToSwitchSuccess,\n\n\t\t\t\t// Make the first sent attempt fail.\n\t\t\t\tgetPaymentResultTempFailure,\n\t\t\t\trouterFailAttempt,\n\n\t\t\t\trouteRelease,\n\n\t\t\t\t// Since there are no more routes to try, the\n\t\t\t\t// payment should fail.\n\t\t\t\trouterFailPayment,\n\t\t\t\tpaymentError,\n\t\t\t},\n\t\t\troutes:     []*route.Route{rt},\n\t\t\tpaymentErr: channeldb.FailureReasonNoRoute,\n\t\t},\n\t\t{\n\t\t\t// We expect the payment to fail immediately if we have\n\t\t\t// no routes to try.\n\t\t\tname: \"single shot no route\",\n\n\t\t\tsteps: []string{\n\t\t\t\trouterInitPayment,\n\t\t\t\trouteRelease,\n\t\t\t\trouterFailPayment,\n\t\t\t\tpaymentError,\n\t\t\t},\n\t\t\troutes:     []*route.Route{},\n\t\t\tpaymentErr: channeldb.FailureReasonNoRoute,\n\t\t},\n\t\t{\n\t\t\t// A normal payment flow, where we attempt to resend\n\t\t\t// the same payment after each step. This ensures that\n\t\t\t// the router don't attempt to resend a payment already\n\t\t\t// in flight.\n\t\t\tname: \"single shot resend\",\n\n\t\t\tsteps: []string{\n\t\t\t\trouterInitPayment,\n\t\t\t\trouteRelease,\n\t\t\t\trouterRegisterAttempt,\n\n\t\t\t\t// Manually resend the payment, the router\n\t\t\t\t// should attempt to init with the control\n\t\t\t\t// tower, but fail since it is already in\n\t\t\t\t// flight.\n\t\t\t\tresendPayment,\n\t\t\t\trouterInitPayment,\n\t\t\t\tresentPaymentError,\n\n\t\t\t\t// The original payment should proceed as\n\t\t\t\t// normal.\n\t\t\t\tsendToSwitchSuccess,\n\n\t\t\t\t// Again resend the payment and assert it's not\n\t\t\t\t// allowed.\n\t\t\t\tresendPayment,\n\t\t\t\trouterInitPayment,\n\t\t\t\tresentPaymentError,\n\n\t\t\t\t// Notify about a success for the original\n\t\t\t\t// payment.\n\t\t\t\tgetPaymentResultSuccess,\n\t\t\t\trouterSettleAttempt,\n\n\t\t\t\t// Now that the original payment finished,\n\t\t\t\t// resend it again to ensure this is not\n\t\t\t\t// allowed.\n\t\t\t\tresendPayment,\n\t\t\t\trouterInitPayment,\n\t\t\t\tresentPaymentError,\n\t\t\t\tpaymentSuccess,\n\t\t\t},\n\t\t\troutes: []*route.Route{rt},\n\t\t},\n\t\t{\n\t\t\t// Tests that the router is able to handle the\n\t\t\t// received payment result after a restart.\n\t\t\tname: \"single shot restart\",\n\n\t\t\tsteps: []string{\n\t\t\t\trouterInitPayment,\n\t\t\t\trouteRelease,\n\t\t\t\trouterRegisterAttempt,\n\t\t\t\tsendToSwitchSuccess,\n\n\t\t\t\t// Shut down the router. The original caller\n\t\t\t\t// should get notified about this.\n\t\t\t\tstopRouter,\n\t\t\t\tpaymentError,\n\n\t\t\t\t// Start the router again, and ensure the\n\t\t\t\t// router registers the success with the\n\t\t\t\t// control tower.\n\t\t\t\tstartRouter,\n\t\t\t\tgetPaymentResultSuccess,\n\t\t\t\trouterSettleAttempt,\n\t\t\t},\n\t\t\troutes:     []*route.Route{rt},\n\t\t\tpaymentErr: ErrRouterShuttingDown,\n\t\t},\n\t\t{\n\t\t\t// Tests that we are allowed to resend a payment after\n\t\t\t// it has permanently failed.\n\t\t\tname: \"single shot resend fail\",\n\n\t\t\tsteps: []string{\n\t\t\t\trouterInitPayment,\n\t\t\t\trouteRelease,\n\t\t\t\trouterRegisterAttempt,\n\t\t\t\tsendToSwitchSuccess,\n\n\t\t\t\t// Resending the payment at this stage should\n\t\t\t\t// not be allowed.\n\t\t\t\tresendPayment,\n\t\t\t\trouterInitPayment,\n\t\t\t\tresentPaymentError,\n\n\t\t\t\t// Make the first attempt fail.\n\t\t\t\tgetPaymentResultTempFailure,\n\t\t\t\trouterFailAttempt,\n\n\t\t\t\t// Since we have no more routes to try, the\n\t\t\t\t// original payment should fail.\n\t\t\t\trouteRelease,\n\t\t\t\trouterFailPayment,\n\t\t\t\tpaymentError,\n\n\t\t\t\t// Now resend the payment again. This should be\n\t\t\t\t// allowed, since the payment has failed.\n\t\t\t\tresendPayment,\n\t\t\t\trouterInitPayment,\n\t\t\t\trouteRelease,\n\t\t\t\trouterRegisterAttempt,\n\t\t\t\tsendToSwitchSuccess,\n\t\t\t\tgetPaymentResultSuccess,\n\t\t\t\trouterSettleAttempt,\n\t\t\t\tresentPaymentSuccess,\n\t\t\t},\n\t\t\troutes:     []*route.Route{rt},\n\t\t\tpaymentErr: channeldb.FailureReasonNoRoute,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\ttestPaymentLifecycle(\n\t\t\t\tt, test, paymentAmt, startingBlockHeight,\n\t\t\t\ttestGraph,\n\t\t\t)\n\t\t})\n\t}\n}\n",
      "length": 6156,
      "tokens": 687,
      "embedding": []
    },
    {
      "slug": "func testPaymentLifecycle(t *testing.T, test paymentLifecycleTestCase,",
      "content": "func testPaymentLifecycle(t *testing.T, test paymentLifecycleTestCase,\n\tpaymentAmt lnwire.MilliSatoshi, startingBlockHeight uint32,\n\ttestGraph *testGraphInstance) {\n\n\t// Create a mock control tower with channels set up, that we use to\n\t// synchronize and listen for events.\n\tcontrol := makeMockControlTower()\n\tcontrol.init = make(chan initArgs)\n\tcontrol.registerAttempt = make(chan registerAttemptArgs)\n\tcontrol.settleAttempt = make(chan settleAttemptArgs)\n\tcontrol.failAttempt = make(chan failAttemptArgs)\n\tcontrol.failPayment = make(chan failPaymentArgs)\n\tcontrol.fetchInFlight = make(chan struct{})\n\n\t// setupRouter is a helper method that creates and starts the router in\n\t// the desired configuration for this test.\n\tsetupRouter := func() (*ChannelRouter, chan error,\n\t\tchan *htlcswitch.PaymentResult) {\n\n\t\tchain := newMockChain(startingBlockHeight)\n\t\tchainView := newMockChainView(chain)\n\n\t\t// We set uo the use the following channels and a mock Payer to\n\t\t// synchronize with the interaction to the Switch.\n\t\tsendResult := make(chan error)\n\t\tpaymentResult := make(chan *htlcswitch.PaymentResult)\n\n\t\tpayer := &mockPayerOld{\n\t\t\tsendResult:    sendResult,\n\t\t\tpaymentResult: paymentResult,\n\t\t}\n\n\t\trouter, err := New(Config{\n\t\t\tGraph:              testGraph.graph,\n\t\t\tChain:              chain,\n\t\t\tChainView:          chainView,\n\t\t\tControl:            control,\n\t\t\tSessionSource:      &mockPaymentSessionSourceOld{},\n\t\t\tMissionControl:     &mockMissionControlOld{},\n\t\t\tPayer:              payer,\n\t\t\tChannelPruneExpiry: time.Hour * 24,\n\t\t\tGraphPruneInterval: time.Hour * 2,\n\t\t\tNextPaymentID: func() (uint64, error) {\n\t\t\t\tnext := atomic.AddUint64(&uniquePaymentID, 1)\n\t\t\t\treturn next, nil\n\t\t\t},\n\t\t\tClock: clock.NewTestClock(time.Unix(1, 0)),\n\t\t\tIsAlias: func(scid lnwire.ShortChannelID) bool {\n\t\t\t\treturn false\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to create router %v\", err)\n\t\t}\n\n\t\t// On startup, the router should fetch all pending payments\n\t\t// from the ControlTower, so assert that here.\n\t\terrCh := make(chan error)\n\t\tgo func() {\n\t\t\tclose(errCh)\n\t\t\tselect {\n\t\t\tcase <-control.fetchInFlight:\n\t\t\t\treturn\n\t\t\tcase <-time.After(1 * time.Second):\n\t\t\t\terrCh <- errors.New(\"router did not fetch in flight \" +\n\t\t\t\t\t\"payments\")\n\t\t\t}\n\t\t}()\n\n\t\tif err := router.Start(); err != nil {\n\t\t\tt.Fatalf(\"unable to start router: %v\", err)\n\t\t}\n\n\t\tselect {\n\t\tcase err := <-errCh:\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"error in anonymous goroutine: %s\", err)\n\t\t\t}\n\t\tcase <-time.After(1 * time.Second):\n\t\t\tt.Fatalf(\"did not fetch in flight payments at startup\")\n\t\t}\n\n\t\treturn router, sendResult, paymentResult\n\t}\n\n\trouter, sendResult, getPaymentResult := setupRouter()\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, router.Stop())\n\t})\n\n\t// Craft a LightningPayment struct.\n\tvar preImage lntypes.Preimage\n\tif _, err := rand.Read(preImage[:]); err != nil {\n\t\tt.Fatalf(\"unable to generate preimage\")\n\t}\n\n\tpayHash := preImage.Hash()\n\n\tpayment := LightningPayment{\n\t\tTarget:      testGraph.aliasMap[\"c\"],\n\t\tAmount:      paymentAmt,\n\t\tFeeLimit:    noFeeLimit,\n\t\tpaymentHash: &payHash,\n\t}\n\n\t// Setup our payment session source to block on release of\n\t// routes.\n\trouteChan := make(chan struct{})\n\trouter.cfg.SessionSource = &mockPaymentSessionSourceOld{\n\t\troutes:       test.routes,\n\t\trouteRelease: routeChan,\n\t}\n\n\trouter.cfg.MissionControl = &mockMissionControlOld{}\n\n\t// Send the payment. Since this is new payment hash, the\n\t// information should be registered with the ControlTower.\n\tpaymentResult := make(chan error)\n\tdone := make(chan struct{})\n\tgo func() {\n\t\t_, _, err := router.SendPayment(&payment)\n\t\tpaymentResult <- err\n\t\tclose(done)\n\t}()\n\n\tvar resendResult chan error\n\tfor i, step := range test.steps {\n\t\ti, step := i, step\n\n\t\t// fatal is a helper closure that wraps the step info.\n\t\tfatal := func(err string, args ...interface{}) {\n\t\t\tif args != nil {\n\t\t\t\terr = fmt.Sprintf(err, args)\n\t\t\t}\n\t\t\tt.Fatalf(\n\t\t\t\t\"test case: %s failed on step [%v:%s], err: %s\",\n\t\t\t\ttest.name, i, step, err,\n\t\t\t)\n\t\t}\n\n\t\tswitch step {\n\t\tcase routerInitPayment:\n\t\t\tvar args initArgs\n\t\t\tselect {\n\t\t\tcase args = <-control.init:\n\t\t\tcase <-time.After(stepTimeout):\n\t\t\t\tfatal(\"no init payment with control\")\n\t\t\t}\n\n\t\t\tif args.c == nil {\n\t\t\t\tfatal(\"expected non-nil CreationInfo\")\n\t\t\t}\n\n\t\tcase routeRelease:\n\t\t\tselect {\n\t\t\tcase <-routeChan:\n\t\t\tcase <-time.After(stepTimeout):\n\t\t\t\tfatal(\"no route requested\")\n\t\t\t}\n\n\t\t// In this step we expect the router to make a call to\n\t\t// register a new attempt with the ControlTower.\n\t\tcase routerRegisterAttempt:\n\t\t\tvar args registerAttemptArgs\n\t\t\tselect {\n\t\t\tcase args = <-control.registerAttempt:\n\t\t\tcase <-time.After(stepTimeout):\n\t\t\t\tfatal(\"attempt not registered with control\")\n\t\t\t}\n\n\t\t\tif args.a == nil {\n\t\t\t\tfatal(\"expected non-nil AttemptInfo\")\n\t\t\t}\n\n\t\t// In this step we expect the router to call the\n\t\t// ControlTower's SettleAttempt method with the preimage.\n\t\tcase routerSettleAttempt:\n\t\t\tselect {\n\t\t\tcase <-control.settleAttempt:\n\t\t\tcase <-time.After(stepTimeout):\n\t\t\t\tfatal(\"attempt settle not \" +\n\t\t\t\t\t\"registered with control\")\n\t\t\t}\n\n\t\t// In this step we expect the router to call the\n\t\t// ControlTower's FailAttempt method with a HTLC fail\n\t\t// info.\n\t\tcase routerFailAttempt:\n\t\t\tselect {\n\t\t\tcase <-control.failAttempt:\n\t\t\tcase <-time.After(stepTimeout):\n\t\t\t\tfatal(\"attempt fail not \" +\n\t\t\t\t\t\"registered with control\")\n\t\t\t}\n\n\t\t// In this step we expect the router to call the\n\t\t// ControlTower's Fail method, to indicate that the\n\t\t// payment failed.\n\t\tcase routerFailPayment:\n\t\t\tselect {\n\t\t\tcase <-control.failPayment:\n\t\t\tcase <-time.After(stepTimeout):\n\t\t\t\tfatal(\"payment fail not \" +\n\t\t\t\t\t\"registered with control\")\n\t\t\t}\n\n\t\t// In this step we expect the SendToSwitch method to be\n\t\t// called, and we respond with a nil-error.\n\t\tcase sendToSwitchSuccess:\n\t\t\tselect {\n\t\t\tcase sendResult <- nil:\n\t\t\tcase <-time.After(stepTimeout):\n\t\t\t\tfatal(\"unable to send result\")\n\t\t\t}\n\n\t\t// In this step we expect the SendToSwitch method to be\n\t\t// called, and we respond with a forwarding error\n\t\tcase sendToSwitchResultFailure:\n\t\t\tselect {\n\t\t\tcase sendResult <- htlcswitch.NewForwardingError(\n\t\t\t\t&lnwire.FailTemporaryChannelFailure{},\n\t\t\t\t1,\n\t\t\t):\n\t\t\tcase <-time.After(stepTimeout):\n\t\t\t\tfatal(\"unable to send result\")\n\t\t\t}\n\n\t\t// In this step we expect the GetAttemptResult method\n\t\t// to be called, and we respond with the preimage to\n\t\t// complete the payment.\n\t\tcase getPaymentResultSuccess:\n\t\t\tselect {\n\t\t\tcase getPaymentResult <- &htlcswitch.PaymentResult{\n\t\t\t\tPreimage: preImage,\n\t\t\t}:\n\t\t\tcase <-time.After(stepTimeout):\n\t\t\t\tfatal(\"unable to send result\")\n\t\t\t}\n\n\t\t// In this state we expect the GetAttemptResult method\n\t\t// to be called, and we respond with a forwarding\n\t\t// error, indicating that the router should retry.\n\t\tcase getPaymentResultTempFailure:\n\t\t\tfailure := htlcswitch.NewForwardingError(\n\t\t\t\t&lnwire.FailTemporaryChannelFailure{},\n\t\t\t\t1,\n\t\t\t)\n\n\t\t\tselect {\n\t\t\tcase getPaymentResult <- &htlcswitch.PaymentResult{\n\t\t\t\tError: failure,\n\t\t\t}:\n\t\t\tcase <-time.After(stepTimeout):\n\t\t\t\tfatal(\"unable to get result\")\n\t\t\t}\n\n\t\t// In this state we expect the router to call the\n\t\t// GetAttemptResult method, and we will respond with a\n\t\t// terminal error, indicating the router should stop\n\t\t// making payment attempts.\n\t\tcase getPaymentResultTerminalFailure:\n\t\t\tfailure := htlcswitch.NewForwardingError(\n\t\t\t\t&lnwire.FailIncorrectDetails{},\n\t\t\t\t1,\n\t\t\t)\n\n\t\t\tselect {\n\t\t\tcase getPaymentResult <- &htlcswitch.PaymentResult{\n\t\t\t\tError: failure,\n\t\t\t}:\n\t\t\tcase <-time.After(stepTimeout):\n\t\t\t\tfatal(\"unable to get result\")\n\t\t\t}\n\n\t\t// In this step we manually try to resend the same\n\t\t// payment, making sure the router responds with an\n\t\t// error indicating that it is already in flight.\n\t\tcase resendPayment:\n\t\t\tresendResult = make(chan error)\n\t\t\tgo func() {\n\t\t\t\t_, _, err := router.SendPayment(&payment)\n\t\t\t\tresendResult <- err\n\t\t\t}()\n\n\t\t// In this step we manually stop the router.\n\t\tcase stopRouter:\n\t\t\t// On shutdown, the switch closes our result channel.\n\t\t\t// Mimic this behavior in our mock.\n\t\t\tclose(getPaymentResult)\n\n\t\t\tif err := router.Stop(); err != nil {\n\t\t\t\tfatal(\"unable to restart: %v\", err)\n\t\t\t}\n\n\t\t// In this step we manually start the router.\n\t\tcase startRouter:\n\t\t\trouter, sendResult, getPaymentResult = setupRouter()\n\n\t\t// In this state we expect to receive an error for the\n\t\t// original payment made.\n\t\tcase paymentError:\n\t\t\trequire.Error(t, test.paymentErr,\n\t\t\t\t\"paymentError not set\")\n\n\t\t\tselect {\n\t\t\tcase err := <-paymentResult:\n\t\t\t\trequire.Equal(t, test.paymentErr, err)\n\n\t\t\tcase <-time.After(stepTimeout):\n\t\t\t\tfatal(\"got no payment result\")\n\t\t\t}\n\n\t\t// In this state we expect the original payment to\n\t\t// succeed.\n\t\tcase paymentSuccess:\n\t\t\trequire.Nil(t, test.paymentErr)\n\n\t\t\tselect {\n\t\t\tcase err := <-paymentResult:\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"did not expect \"+\n\t\t\t\t\t\t\"error %v\", err)\n\t\t\t\t}\n\n\t\t\tcase <-time.After(stepTimeout):\n\t\t\t\tfatal(\"got no payment result\")\n\t\t\t}\n\n\t\t// In this state we expect to receive an error for the\n\t\t// resent payment made.\n\t\tcase resentPaymentError:\n\t\t\tselect {\n\t\t\tcase err := <-resendResult:\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Fatalf(\"expected error\")\n\t\t\t\t}\n\n\t\t\tcase <-time.After(stepTimeout):\n\t\t\t\tfatal(\"got no payment result\")\n\t\t\t}\n\n\t\t// In this state we expect the resent payment to\n\t\t// succeed.\n\t\tcase resentPaymentSuccess:\n\t\t\tselect {\n\t\t\tcase err := <-resendResult:\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"did not expect error %v\", err)\n\t\t\t\t}\n\n\t\t\tcase <-time.After(stepTimeout):\n\t\t\t\tfatal(\"got no payment result\")\n\t\t\t}\n\n\t\tdefault:\n\t\t\tfatal(\"unknown step %v\", step)\n\t\t}\n\t}\n\n\tselect {\n\tcase <-done:\n\tcase <-time.After(testTimeout):\n\t\tt.Fatalf(\"SendPayment didn't exit\")\n\t}\n}\n\n// TestPaymentState tests that the logics implemented on paymentState struct\n// are as expected. In particular, that the method terminated and\n// needWaitForShards return the right values.",
      "length": 9381,
      "tokens": 1198,
      "embedding": []
    },
    {
      "slug": "func TestPaymentState(t *testing.T) {",
      "content": "func TestPaymentState(t *testing.T) {\n\tt.Parallel()\n\n\ttestCases := []struct {\n\t\tname string\n\n\t\t// Use the following three params, each is equivalent to a bool\n\t\t// statement, to construct 8 test cases so that we can\n\t\t// exhaustively catch all possible states.\n\t\tnumShardsInFlight int\n\t\tremainingAmt      lnwire.MilliSatoshi\n\t\tterminate         bool\n\n\t\texpectedTerminated        bool\n\t\texpectedNeedWaitForShards bool\n\t}{\n\t\t{\n\t\t\t// If we have active shards and terminate is marked\n\t\t\t// false, the state is not terminated. Since the\n\t\t\t// remaining amount is zero, we need to wait for shards\n\t\t\t// to be finished and launch no more shards.\n\t\t\tname:                      \"state 100\",\n\t\t\tnumShardsInFlight:         1,\n\t\t\tremainingAmt:              lnwire.MilliSatoshi(0),\n\t\t\tterminate:                 false,\n\t\t\texpectedTerminated:        false,\n\t\t\texpectedNeedWaitForShards: true,\n\t\t},\n\t\t{\n\t\t\t// If we have active shards while terminate is marked\n\t\t\t// true, the state is not terminated, and we need to\n\t\t\t// wait for shards to be finished and launch no more\n\t\t\t// shards.\n\t\t\tname:                      \"state 101\",\n\t\t\tnumShardsInFlight:         1,\n\t\t\tremainingAmt:              lnwire.MilliSatoshi(0),\n\t\t\tterminate:                 true,\n\t\t\texpectedTerminated:        false,\n\t\t\texpectedNeedWaitForShards: true,\n\t\t},\n\n\t\t{\n\t\t\t// If we have active shards and terminate is marked\n\t\t\t// false, the state is not terminated. Since the\n\t\t\t// remaining amount is not zero, we don't need to wait\n\t\t\t// for shards outcomes and should launch more shards.\n\t\t\tname:                      \"state 110\",\n\t\t\tnumShardsInFlight:         1,\n\t\t\tremainingAmt:              lnwire.MilliSatoshi(1),\n\t\t\tterminate:                 false,\n\t\t\texpectedTerminated:        false,\n\t\t\texpectedNeedWaitForShards: false,\n\t\t},\n\t\t{\n\t\t\t// If we have active shards and terminate is marked\n\t\t\t// true, the state is not terminated. Even the\n\t\t\t// remaining amount is not zero, we need to wait for\n\t\t\t// shards outcomes because state is terminated.\n\t\t\tname:                      \"state 111\",\n\t\t\tnumShardsInFlight:         1,\n\t\t\tremainingAmt:              lnwire.MilliSatoshi(1),\n\t\t\tterminate:                 true,\n\t\t\texpectedTerminated:        false,\n\t\t\texpectedNeedWaitForShards: true,\n\t\t},\n\t\t{\n\t\t\t// If we have no active shards while terminate is marked\n\t\t\t// false, the state is not terminated, and we don't\n\t\t\t// need to wait for more shard outcomes because there\n\t\t\t// are no active shards.\n\t\t\tname:                      \"state 000\",\n\t\t\tnumShardsInFlight:         0,\n\t\t\tremainingAmt:              lnwire.MilliSatoshi(0),\n\t\t\tterminate:                 false,\n\t\t\texpectedTerminated:        false,\n\t\t\texpectedNeedWaitForShards: false,\n\t\t},\n\t\t{\n\t\t\t// If we have no active shards while terminate is marked\n\t\t\t// true, the state is terminated, and we don't need to\n\t\t\t// wait for shards to be finished.\n\t\t\tname:                      \"state 001\",\n\t\t\tnumShardsInFlight:         0,\n\t\t\tremainingAmt:              lnwire.MilliSatoshi(0),\n\t\t\tterminate:                 true,\n\t\t\texpectedTerminated:        true,\n\t\t\texpectedNeedWaitForShards: false,\n\t\t},\n\t\t{\n\t\t\t// If we have no active shards while terminate is marked\n\t\t\t// false, the state is not terminated. Since the\n\t\t\t// remaining amount is not zero, we don't need to wait\n\t\t\t// for shards outcomes and should launch more shards.\n\t\t\tname:                      \"state 010\",\n\t\t\tnumShardsInFlight:         0,\n\t\t\tremainingAmt:              lnwire.MilliSatoshi(1),\n\t\t\tterminate:                 false,\n\t\t\texpectedTerminated:        false,\n\t\t\texpectedNeedWaitForShards: false,\n\t\t},\n\t\t{\n\t\t\t// If we have no active shards while terminate is marked\n\t\t\t// true, the state is terminated, and we don't need to\n\t\t\t// wait for shards outcomes.\n\t\t\tname:                      \"state 011\",\n\t\t\tnumShardsInFlight:         0,\n\t\t\tremainingAmt:              lnwire.MilliSatoshi(1),\n\t\t\tterminate:                 true,\n\t\t\texpectedTerminated:        true,\n\t\t\texpectedNeedWaitForShards: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tps := &paymentState{\n\t\t\t\tnumShardsInFlight: tc.numShardsInFlight,\n\t\t\t\tremainingAmt:      tc.remainingAmt,\n\t\t\t\tterminate:         tc.terminate,\n\t\t\t}\n\n\t\t\trequire.Equal(\n\t\t\t\tt, tc.expectedTerminated, ps.terminated(),\n\t\t\t\t\"terminated returned wrong value\",\n\t\t\t)\n\t\t\trequire.Equal(\n\t\t\t\tt, tc.expectedNeedWaitForShards,\n\t\t\t\tps.needWaitForShards(),\n\t\t\t\t\"needWaitForShards returned wrong value\",\n\t\t\t)\n\t\t})\n\t}\n}\n\n// TestUpdatePaymentState checks that the method updatePaymentState updates the\n// paymentState as expected.",
      "length": 4418,
      "tokens": 508,
      "embedding": []
    },
    {
      "slug": "func TestUpdatePaymentState(t *testing.T) {",
      "content": "func TestUpdatePaymentState(t *testing.T) {\n\tt.Parallel()\n\n\t// paymentHash is the identifier on paymentLifecycle.\n\tpaymentHash := lntypes.Hash{}\n\tpreimage := lntypes.Preimage{}\n\tfailureReasonError := channeldb.FailureReasonError\n\n\t// TODO(yy): make MPPayment into an interface so we can mock it. The\n\t// current design implicitly tests the methods SendAmt, TerminalInfo,\n\t// and InFlightHTLCs on channeldb.MPPayment, which is not good. Once\n\t// MPPayment becomes an interface, we can then mock these methods here.\n\n\ttestCases := []struct {\n\t\tname     string\n\t\tpayment  *channeldb.MPPayment\n\t\ttotalAmt int\n\t\tfeeLimit int\n\n\t\texpectedState     *paymentState\n\t\tshouldReturnError bool\n\t}{\n\t\t{\n\t\t\t// Test that the error returned from FetchPayment is\n\t\t\t// handled properly. We use a nil payment to indicate\n\t\t\t// we want to return an error.\n\t\t\tname:              \"fetch payment error\",\n\t\t\tpayment:           nil,\n\t\t\tshouldReturnError: true,\n\t\t},\n\t\t{\n\t\t\t// Test that when the sentAmt exceeds totalAmount, the\n\t\t\t// error is returned.\n\t\t\tname: \"amount exceeded error\",\n\t\t\t// SentAmt returns 90, 10\n\t\t\t// TerminalInfo returns non-nil, nil\n\t\t\t// InFlightHTLCs returns 0\n\t\t\tpayment: &channeldb.MPPayment{\n\t\t\t\tHTLCs: []channeldb.HTLCAttempt{\n\t\t\t\t\tmakeSettledAttempt(100, 10, preimage),\n\t\t\t\t},\n\t\t\t},\n\t\t\ttotalAmt:          1,\n\t\t\tshouldReturnError: true,\n\t\t},\n\t\t{\n\t\t\t// Test that when the fee budget is reached, the\n\t\t\t// remaining fee should be zero.\n\t\t\tname: \"fee budget reached\",\n\t\t\tpayment: &channeldb.MPPayment{\n\t\t\t\t// SentAmt returns 90, 10\n\t\t\t\t// TerminalInfo returns nil, nil\n\t\t\t\t// InFlightHTLCs returns 1\n\t\t\t\tHTLCs: []channeldb.HTLCAttempt{\n\t\t\t\t\tmakeActiveAttempt(100, 10),\n\t\t\t\t\tmakeFailedAttempt(100, 10),\n\t\t\t\t},\n\t\t\t},\n\t\t\ttotalAmt: 1000,\n\t\t\tfeeLimit: 1,\n\t\t\texpectedState: &paymentState{\n\t\t\t\tnumShardsInFlight: 1,\n\t\t\t\tremainingAmt:      1000 - 90,\n\t\t\t\tremainingFees:     0,\n\t\t\t\tterminate:         false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t// Test when the payment is settled, the state should\n\t\t\t// be marked as terminated.\n\t\t\tname: \"payment settled\",\n\t\t\t// SentAmt returns 90, 10\n\t\t\t// TerminalInfo returns non-nil, nil\n\t\t\t// InFlightHTLCs returns 0\n\t\t\tpayment: &channeldb.MPPayment{\n\t\t\t\tHTLCs: []channeldb.HTLCAttempt{\n\t\t\t\t\tmakeSettledAttempt(100, 10, preimage),\n\t\t\t\t},\n\t\t\t},\n\t\t\ttotalAmt: 1000,\n\t\t\tfeeLimit: 100,\n\t\t\texpectedState: &paymentState{\n\t\t\t\tnumShardsInFlight: 0,\n\t\t\t\tremainingAmt:      1000 - 90,\n\t\t\t\tremainingFees:     100 - 10,\n\t\t\t\tterminate:         true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t// Test when the payment is failed, the state should be\n\t\t\t// marked as terminated.\n\t\t\tname: \"payment failed\",\n\t\t\t// SentAmt returns 0, 0\n\t\t\t// TerminalInfo returns nil, non-nil\n\t\t\t// InFlightHTLCs returns 0\n\t\t\tpayment: &channeldb.MPPayment{\n\t\t\t\tFailureReason: &failureReasonError,\n\t\t\t},\n\t\t\ttotalAmt: 1000,\n\t\t\tfeeLimit: 100,\n\t\t\texpectedState: &paymentState{\n\t\t\t\tnumShardsInFlight: 0,\n\t\t\t\tremainingAmt:      1000,\n\t\t\t\tremainingFees:     100,\n\t\t\t\tterminate:         true,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\t// Create mock control tower and assign it to router.\n\t\t\t// We will then use the router and the paymentHash\n\t\t\t// above to create our paymentLifecycle for this test.\n\t\t\tct := &mockControlTower{}\n\t\t\trt := &ChannelRouter{cfg: &Config{Control: ct}}\n\t\t\tpl := &paymentLifecycle{\n\t\t\t\trouter:     rt,\n\t\t\t\tidentifier: paymentHash,\n\t\t\t\tfeeLimit:   lnwire.MilliSatoshi(tc.feeLimit),\n\t\t\t}\n\n\t\t\tif tc.payment == nil {\n\t\t\t\t// A nil payment indicates we want to test an\n\t\t\t\t// error returned from FetchPayment.\n\t\t\t\tdummyErr := errors.New(\"dummy\")\n\t\t\t\tct.On(\"FetchPayment\", paymentHash).Return(\n\t\t\t\t\tnil, dummyErr,\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\t// Attach the payment info.\n\t\t\t\tinfo := &channeldb.PaymentCreationInfo{\n\t\t\t\t\tValue: lnwire.MilliSatoshi(tc.totalAmt),\n\t\t\t\t}\n\t\t\t\ttc.payment.Info = info\n\n\t\t\t\t// Otherwise we will return the payment.\n\t\t\t\tct.On(\"FetchPayment\", paymentHash).Return(\n\t\t\t\t\ttc.payment, nil,\n\t\t\t\t)\n\t\t\t}\n\n\t\t\t// Call the method that updates the payment state.\n\t\t\t_, state, err := pl.fetchPaymentState()\n\n\t\t\t// Assert that the mock method is called as\n\t\t\t// intended.\n\t\t\tct.AssertExpectations(t)\n\n\t\t\tif tc.shouldReturnError {\n\t\t\t\trequire.Error(t, err, \"expect an error\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\trequire.NoError(t, err, \"unexpected error\")\n\t\t\trequire.Equal(\n\t\t\t\tt, tc.expectedState, state,\n\t\t\t\t\"state not updated as expected\",\n\t\t\t)\n\t\t})\n\t}\n}\n",
      "length": 4173,
      "tokens": 513,
      "embedding": []
    },
    {
      "slug": "func makeActiveAttempt(total, fee int) channeldb.HTLCAttempt {",
      "content": "func makeActiveAttempt(total, fee int) channeldb.HTLCAttempt {\n\treturn channeldb.HTLCAttempt{\n\t\tHTLCAttemptInfo: makeAttemptInfo(total, total-fee),\n\t}\n}\n",
      "length": 86,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "func makeSettledAttempt(total, fee int,",
      "content": "func makeSettledAttempt(total, fee int,\n\tpreimage lntypes.Preimage) channeldb.HTLCAttempt {\n\n\treturn channeldb.HTLCAttempt{\n\t\tHTLCAttemptInfo: makeAttemptInfo(total, total-fee),\n\t\tSettle:          &channeldb.HTLCSettleInfo{Preimage: preimage},\n\t}\n}\n",
      "length": 202,
      "tokens": 14,
      "embedding": []
    },
    {
      "slug": "func makeFailedAttempt(total, fee int) channeldb.HTLCAttempt {",
      "content": "func makeFailedAttempt(total, fee int) channeldb.HTLCAttempt {\n\treturn channeldb.HTLCAttempt{\n\t\tHTLCAttemptInfo: makeAttemptInfo(total, total-fee),\n\t\tFailure: &channeldb.HTLCFailInfo{\n\t\t\tReason: channeldb.HTLCFailInternal,\n\t\t},\n\t}\n}\n",
      "length": 163,
      "tokens": 12,
      "embedding": []
    },
    {
      "slug": "func makeAttemptInfo(total, amtForwarded int) channeldb.HTLCAttemptInfo {",
      "content": "func makeAttemptInfo(total, amtForwarded int) channeldb.HTLCAttemptInfo {\n\thop := &route.Hop{AmtToForward: lnwire.MilliSatoshi(amtForwarded)}\n\treturn channeldb.HTLCAttemptInfo{\n\t\tRoute: route.Route{\n\t\t\tTotalAmount: lnwire.MilliSatoshi(total),\n\t\t\tHops:        []*route.Hop{hop},\n\t\t},\n\t}\n}\n",
      "length": 206,
      "tokens": 15,
      "embedding": []
    }
  ]
}