{
  "filepath": "../implementations/go/lnd/routing/control_tower.go",
  "package": "routing",
  "sections": [
    {
      "slug": "type ControlTower interface {",
      "content": "type ControlTower interface {\n\t// This method checks that no succeeded payment exist for this payment\n\t// hash.\n\tInitPayment(lntypes.Hash, *channeldb.PaymentCreationInfo) error\n\n\t// DeleteFailedAttempts removes all failed HTLCs from the db. It should\n\t// be called for a given payment whenever all inflight htlcs are\n\t// completed, and the payment has reached a final settled state.\n\tDeleteFailedAttempts(lntypes.Hash) error\n\n\t// RegisterAttempt atomically records the provided HTLCAttemptInfo.\n\tRegisterAttempt(lntypes.Hash, *channeldb.HTLCAttemptInfo) error\n\n\t// SettleAttempt marks the given attempt settled with the preimage. If\n\t// this is a multi shard payment, this might implicitly mean the the\n\t// full payment succeeded.\n\t//\n\t// After invoking this method, InitPayment should always return an\n\t// error to prevent us from making duplicate payments to the same\n\t// payment hash. The provided preimage is atomically saved to the DB\n\t// for record keeping.\n\tSettleAttempt(lntypes.Hash, uint64, *channeldb.HTLCSettleInfo) (\n\t\t*channeldb.HTLCAttempt, error)\n\n\t// FailAttempt marks the given payment attempt failed.\n\tFailAttempt(lntypes.Hash, uint64, *channeldb.HTLCFailInfo) (\n\t\t*channeldb.HTLCAttempt, error)\n\n\t// FetchPayment fetches the payment corresponding to the given payment\n\t// hash.\n\tFetchPayment(paymentHash lntypes.Hash) (*channeldb.MPPayment, error)\n\n\t// FailPayment transitions a payment into the Failed state, and records\n\t// the ultimate reason the payment failed. Note that this should only\n\t// be called when all active attempts are already failed. After\n\t// invoking this method, InitPayment should return nil on its next call\n\t// for this payment hash, allowing the user to make a subsequent\n\t// payment.\n\tFailPayment(lntypes.Hash, channeldb.FailureReason) error\n\n\t// FetchInFlightPayments returns all payments with status InFlight.\n\tFetchInFlightPayments() ([]*channeldb.MPPayment, error)\n\n\t// SubscribePayment subscribes to updates for the payment with the given\n\t// hash. A first update with the current state of the payment is always\n\t// sent out immediately.\n\tSubscribePayment(paymentHash lntypes.Hash) (ControlTowerSubscriber,\n\t\terror)\n\n\t// SubscribeAllPayments subscribes to updates for all payments. A first\n\t// update with the current state of every inflight payment is always\n\t// sent out immediately.\n\tSubscribeAllPayments() (ControlTowerSubscriber, error)\n}\n\n// ControlTowerSubscriber contains the state for a payment update subscriber.",
      "length": 2389,
      "tokens": 313,
      "embedding": []
    },
    {
      "slug": "type ControlTowerSubscriber interface {",
      "content": "type ControlTowerSubscriber interface {\n\t// Updates is the channel over which *channeldb.MPPayment updates can be\n\t// received.\n\tUpdates() <-chan interface{}\n\n\t// Close signals that the subscriber is no longer interested in updates.\n\tClose()\n}\n\n// ControlTowerSubscriberImpl contains the state for a payment update\n// subscriber.",
      "length": 280,
      "tokens": 41,
      "embedding": []
    },
    {
      "slug": "type controlTowerSubscriberImpl struct {",
      "content": "type controlTowerSubscriberImpl struct {\n\tupdates <-chan interface{}\n\tqueue   *queue.ConcurrentQueue\n\tquit    chan struct{}\n}\n\n// newControlTowerSubscriber instantiates a new subscriber state object.",
      "length": 153,
      "tokens": 17,
      "embedding": []
    },
    {
      "slug": "func newControlTowerSubscriber() *controlTowerSubscriberImpl {",
      "content": "func newControlTowerSubscriber() *controlTowerSubscriberImpl {\n\t// Create a queue for payment updates.\n\tqueue := queue.NewConcurrentQueue(20)\n\tqueue.Start()\n\n\treturn &controlTowerSubscriberImpl{\n\t\tupdates: queue.ChanOut(),\n\t\tqueue:   queue,\n\t\tquit:    make(chan struct{}),\n\t}\n}\n\n// Close signals that the subscriber is no longer interested in updates.",
      "length": 277,
      "tokens": 34,
      "embedding": []
    },
    {
      "slug": "func (s *controlTowerSubscriberImpl) Close() {",
      "content": "func (s *controlTowerSubscriberImpl) Close() {\n\t// Close quit channel so that any pending writes to the queue are\n\t// cancelled.\n\tclose(s.quit)\n\n\t// Stop the queue goroutine so that it won't leak.\n\ts.queue.Stop()\n}\n\n// Updates is the channel over which *channeldb.MPPayment updates can be\n// received.",
      "length": 245,
      "tokens": 41,
      "embedding": []
    },
    {
      "slug": "func (s *controlTowerSubscriberImpl) Updates() <-chan interface{} {",
      "content": "func (s *controlTowerSubscriberImpl) Updates() <-chan interface{} {\n\treturn s.updates\n}\n\n// controlTower is persistent implementation of ControlTower to restrict\n// double payment sending.",
      "length": 116,
      "tokens": 16,
      "embedding": []
    },
    {
      "slug": "type controlTower struct {",
      "content": "type controlTower struct {\n\tdb *channeldb.PaymentControl\n\n\t// subscriberIndex is used to provide a unique id for each subscriber\n\t// to all payments. This is used to easily remove the subscriber when\n\t// necessary.\n\tsubscriberIndex        uint64\n\tsubscribersAllPayments map[uint64]*controlTowerSubscriberImpl\n\tsubscribers            map[lntypes.Hash][]*controlTowerSubscriberImpl\n\tsubscribersMtx         sync.Mutex\n\n\t// paymentsMtx provides synchronization on the payment level to ensure\n\t// that no race conditions occur in between updating the database and\n\t// sending a notification.\n\tpaymentsMtx *multimutex.HashMutex\n}\n\n// NewControlTower creates a new instance of the controlTower.",
      "length": 644,
      "tokens": 75,
      "embedding": []
    },
    {
      "slug": "func NewControlTower(db *channeldb.PaymentControl) ControlTower {",
      "content": "func NewControlTower(db *channeldb.PaymentControl) ControlTower {\n\treturn &controlTower{\n\t\tdb: db,\n\t\tsubscribersAllPayments: make(\n\t\t\tmap[uint64]*controlTowerSubscriberImpl,\n\t\t),\n\t\tsubscribers: make(map[lntypes.Hash][]*controlTowerSubscriberImpl),\n\t\tpaymentsMtx: multimutex.NewHashMutex(),\n\t}\n}\n\n// InitPayment checks or records the given PaymentCreationInfo with the DB,\n// making sure it does not already exist as an in-flight payment. Then this\n// method returns successfully, the payment is guaranteed to be in the InFlight\n// state.",
      "length": 458,
      "tokens": 54,
      "embedding": []
    },
    {
      "slug": "func (p *controlTower) InitPayment(paymentHash lntypes.Hash,",
      "content": "func (p *controlTower) InitPayment(paymentHash lntypes.Hash,\n\tinfo *channeldb.PaymentCreationInfo) error {\n\n\treturn p.db.InitPayment(paymentHash, info)\n}\n\n// DeleteFailedAttempts deletes all failed htlcs if the payment was\n// successfully settled.",
      "length": 180,
      "tokens": 21,
      "embedding": []
    },
    {
      "slug": "func (p *controlTower) DeleteFailedAttempts(paymentHash lntypes.Hash) error {",
      "content": "func (p *controlTower) DeleteFailedAttempts(paymentHash lntypes.Hash) error {\n\treturn p.db.DeleteFailedAttempts(paymentHash)\n}\n\n// RegisterAttempt atomically records the provided HTLCAttemptInfo to the\n// DB.",
      "length": 126,
      "tokens": 14,
      "embedding": []
    },
    {
      "slug": "func (p *controlTower) RegisterAttempt(paymentHash lntypes.Hash,",
      "content": "func (p *controlTower) RegisterAttempt(paymentHash lntypes.Hash,\n\tattempt *channeldb.HTLCAttemptInfo) error {\n\n\tp.paymentsMtx.Lock(paymentHash)\n\tdefer p.paymentsMtx.Unlock(paymentHash)\n\n\tpayment, err := p.db.RegisterAttempt(paymentHash, attempt)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Notify subscribers of the attempt registration.\n\tp.notifySubscribers(paymentHash, payment)\n\n\treturn nil\n}\n\n// SettleAttempt marks the given attempt settled with the preimage. If\n// this is a multi shard payment, this might implicitly mean the the\n// full payment succeeded.",
      "length": 474,
      "tokens": 60,
      "embedding": []
    },
    {
      "slug": "func (p *controlTower) SettleAttempt(paymentHash lntypes.Hash,",
      "content": "func (p *controlTower) SettleAttempt(paymentHash lntypes.Hash,\n\tattemptID uint64, settleInfo *channeldb.HTLCSettleInfo) (\n\t*channeldb.HTLCAttempt, error) {\n\n\tp.paymentsMtx.Lock(paymentHash)\n\tdefer p.paymentsMtx.Unlock(paymentHash)\n\n\tpayment, err := p.db.SettleAttempt(paymentHash, attemptID, settleInfo)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Notify subscribers of success event.\n\tp.notifySubscribers(paymentHash, payment)\n\n\treturn payment.GetAttempt(attemptID)\n}\n\n// FailAttempt marks the given payment attempt failed.",
      "length": 443,
      "tokens": 45,
      "embedding": []
    },
    {
      "slug": "func (p *controlTower) FailAttempt(paymentHash lntypes.Hash,",
      "content": "func (p *controlTower) FailAttempt(paymentHash lntypes.Hash,\n\tattemptID uint64, failInfo *channeldb.HTLCFailInfo) (\n\t*channeldb.HTLCAttempt, error) {\n\n\tp.paymentsMtx.Lock(paymentHash)\n\tdefer p.paymentsMtx.Unlock(paymentHash)\n\n\tpayment, err := p.db.FailAttempt(paymentHash, attemptID, failInfo)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Notify subscribers of failed attempt.\n\tp.notifySubscribers(paymentHash, payment)\n\n\treturn payment.GetAttempt(attemptID)\n}\n\n// FetchPayment fetches the payment corresponding to the given payment hash.",
      "length": 458,
      "tokens": 48,
      "embedding": []
    },
    {
      "slug": "func (p *controlTower) FetchPayment(paymentHash lntypes.Hash) (",
      "content": "func (p *controlTower) FetchPayment(paymentHash lntypes.Hash) (\n\t*channeldb.MPPayment, error) {\n\n\treturn p.db.FetchPayment(paymentHash)\n}\n\n// FailPayment transitions a payment into the Failed state, and records the\n// reason the payment failed. After invoking this method, InitPayment should\n// return nil on its next call for this payment hash, allowing the switch to\n// make a subsequent payment.",
      "length": 326,
      "tokens": 49,
      "embedding": []
    },
    {
      "slug": "func (p *controlTower) FailPayment(paymentHash lntypes.Hash,",
      "content": "func (p *controlTower) FailPayment(paymentHash lntypes.Hash,\n\treason channeldb.FailureReason) error {\n\n\tp.paymentsMtx.Lock(paymentHash)\n\tdefer p.paymentsMtx.Unlock(paymentHash)\n\n\tpayment, err := p.db.Fail(paymentHash, reason)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Notify subscribers of fail event.\n\tp.notifySubscribers(paymentHash, payment)\n\n\treturn nil\n}\n\n// FetchInFlightPayments returns all payments with status InFlight.",
      "length": 347,
      "tokens": 39,
      "embedding": []
    },
    {
      "slug": "func (p *controlTower) FetchInFlightPayments() ([]*channeldb.MPPayment, error) {",
      "content": "func (p *controlTower) FetchInFlightPayments() ([]*channeldb.MPPayment, error) {\n\treturn p.db.FetchInFlightPayments()\n}\n\n// SubscribePayment subscribes to updates for the payment with the given hash. A\n// first update with the current state of the payment is always sent out\n// immediately.",
      "length": 204,
      "tokens": 32,
      "embedding": []
    },
    {
      "slug": "func (p *controlTower) SubscribePayment(paymentHash lntypes.Hash) (",
      "content": "func (p *controlTower) SubscribePayment(paymentHash lntypes.Hash) (\n\tControlTowerSubscriber, error) {\n\n\t// Take lock before querying the db to prevent missing or duplicating an\n\t// update.\n\tp.paymentsMtx.Lock(paymentHash)\n\tdefer p.paymentsMtx.Unlock(paymentHash)\n\n\tpayment, err := p.db.FetchPayment(paymentHash)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsubscriber := newControlTowerSubscriber()\n\n\t// Always write current payment state to the channel.\n\tsubscriber.queue.ChanIn() <- payment\n\n\t// Payment is currently in flight. Register this subscriber for further\n\t// updates. Otherwise this update is the final update and the incoming\n\t// channel can be closed. This will close the queue's outgoing channel\n\t// when all updates have been written.\n\tif payment.Status == channeldb.StatusInFlight {\n\t\tp.subscribersMtx.Lock()\n\t\tp.subscribers[paymentHash] = append(\n\t\t\tp.subscribers[paymentHash], subscriber,\n\t\t)\n\t\tp.subscribersMtx.Unlock()\n\t} else {\n\t\tclose(subscriber.queue.ChanIn())\n\t}\n\n\treturn subscriber, nil\n}\n\n// SubscribeAllPayments subscribes to updates for all inflight payments. A first\n// update with the current state of every inflight payment is always sent out\n// immediately.\n// Note: If payments are in-flight while starting a new subscription, the start\n// of the payment stream could produce out-of-order and/or duplicate events. In\n// order to get updates for every in-flight payment attempt make sure to\n// subscribe to this method before initiating any payments.",
      "length": 1370,
      "tokens": 187,
      "embedding": []
    },
    {
      "slug": "func (p *controlTower) SubscribeAllPayments() (ControlTowerSubscriber, error) {",
      "content": "func (p *controlTower) SubscribeAllPayments() (ControlTowerSubscriber, error) {\n\tsubscriber := newControlTowerSubscriber()\n\n\t// Add the subscriber to the list before fetching in-flight payments, so\n\t// no events are missed. If a payment attempt update occurs after\n\t// appending and before fetching in-flight payments, an out-of-order\n\t// duplicate may be produced, because it is then fetched in below call\n\t// and notified through the subscription.\n\tp.subscribersMtx.Lock()\n\tp.subscribersAllPayments[p.subscriberIndex] = subscriber\n\tp.subscriberIndex++\n\tp.subscribersMtx.Unlock()\n\n\tinflightPayments, err := p.db.FetchInFlightPayments()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor index := range inflightPayments {\n\t\t// Always write current payment state to the channel.\n\t\tsubscriber.queue.ChanIn() <- inflightPayments[index]\n\t}\n\n\treturn subscriber, nil\n}\n\n// notifySubscribers sends a final payment event to all subscribers of this\n// payment. The channel will be closed after this. Note that this function must\n// be executed atomically (by means of a lock) with the database update to\n// guarantee consistency of the notifications.",
      "length": 1026,
      "tokens": 143,
      "embedding": []
    },
    {
      "slug": "func (p *controlTower) notifySubscribers(paymentHash lntypes.Hash,",
      "content": "func (p *controlTower) notifySubscribers(paymentHash lntypes.Hash,\n\tevent *channeldb.MPPayment) {\n\n\t// Get all subscribers for this payment.\n\tp.subscribersMtx.Lock()\n\n\tsubscribersPaymentHash, ok := p.subscribers[paymentHash]\n\tif !ok && len(p.subscribersAllPayments) == 0 {\n\t\tp.subscribersMtx.Unlock()\n\t\treturn\n\t}\n\n\t// If the payment reached a terminal state, the subscriber list can be\n\t// cleared. There won't be any more updates.\n\tterminal := event.Status != channeldb.StatusInFlight\n\tif terminal {\n\t\tdelete(p.subscribers, paymentHash)\n\t}\n\n\t// Copy subscribers to all payments locally while holding the lock in\n\t// order to avoid concurrency issues while reading/writing the map.\n\tsubscribersAllPayments := make(map[uint64]*controlTowerSubscriberImpl)\n\tfor k, v := range p.subscribersAllPayments {\n\t\tsubscribersAllPayments[k] = v\n\t}\n\tp.subscribersMtx.Unlock()\n\n\t// Notify all subscribers that subscribed to the current payment hash.\n\tfor _, subscriber := range subscribersPaymentHash {\n\t\tselect {\n\t\tcase subscriber.queue.ChanIn() <- event:\n\t\t\t// If this event is the last, close the incoming channel\n\t\t\t// of the queue. This will signal the subscriber that\n\t\t\t// there won't be any more updates.\n\t\t\tif terminal {\n\t\t\t\tclose(subscriber.queue.ChanIn())\n\t\t\t}\n\n\t\t// If subscriber disappeared, skip notification. For further\n\t\t// notifications, we'll keep skipping over this subscriber.\n\t\tcase <-subscriber.quit:\n\t\t}\n\t}\n\n\t// Notify all subscribers that subscribed to all payments.\n\tfor key, subscriber := range subscribersAllPayments {\n\t\tselect {\n\t\tcase subscriber.queue.ChanIn() <- event:\n\n\t\t// If subscriber disappeared, remove it from the subscribers\n\t\t// list.\n\t\tcase <-subscriber.quit:\n\t\t\tp.subscribersMtx.Lock()\n\t\t\tdelete(p.subscribersAllPayments, key)\n\t\t\tp.subscribersMtx.Unlock()\n\t\t}\n\t}\n}\n",
      "length": 1669,
      "tokens": 213,
      "embedding": []
    }
  ]
}