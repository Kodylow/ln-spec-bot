{
  "filepath": "../implementations/go/lnd/routing/chainview/interface_test.go",
  "package": "chainview",
  "sections": [
    {
      "slug": "func getFreePort() int {",
      "content": "func getFreePort() int {\n\tport := atomic.AddUint32(&lastPort, 1)\n\tfor port < 65535 {\n\t\t// If there are no errors while attempting to listen on this\n\t\t// port, close the socket and return it as available.\n\t\taddr := fmt.Sprintf(\"127.0.0.1:%d\", port)\n\t\tl, err := net.Listen(\"tcp4\", addr)\n\t\tif err == nil {\n\t\t\terr := l.Close()\n\t\t\tif err == nil {\n\t\t\t\treturn int(port)\n\t\t\t}\n\t\t}\n\t\tport = atomic.AddUint32(&lastPort, 1)\n\t}\n\n\t// No ports available? Must be a mistake.\n\tpanic(\"no ports available for listening\")\n}\n",
      "length": 461,
      "tokens": 76,
      "embedding": []
    },
    {
      "slug": "func waitForMempoolTx(r *rpctest.Harness, txid *chainhash.Hash) error {",
      "content": "func waitForMempoolTx(r *rpctest.Harness, txid *chainhash.Hash) error {\n\tvar found bool\n\tvar tx *btcutil.Tx\n\tvar err error\n\ttimeout := time.After(10 * time.Second)\n\tfor !found {\n\t\t// Do a short wait\n\t\tselect {\n\t\tcase <-timeout:\n\t\t\treturn fmt.Errorf(\"timeout after 10s\")\n\t\tdefault:\n\t\t}\n\t\ttime.Sleep(100 * time.Millisecond)\n\n\t\t// Check for the harness' knowledge of the txid\n\t\ttx, err = r.Client.GetRawTransaction(txid)\n\t\tif err != nil {\n\t\t\tswitch e := err.(type) {\n\t\t\tcase *btcjson.RPCError:\n\t\t\t\tif e.Code == btcjson.ErrRPCNoTxInfo {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tif tx != nil && tx.MsgTx().TxHash() == *txid {\n\t\t\tfound = true\n\t\t}\n\t}\n\treturn nil\n}\n",
      "length": 571,
      "tokens": 89,
      "embedding": []
    },
    {
      "slug": "func getTestTXID(miner *rpctest.Harness) (*chainhash.Hash, error) {",
      "content": "func getTestTXID(miner *rpctest.Harness) (*chainhash.Hash, error) {\n\tscript, err := txscript.PayToAddrScript(testAddr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\toutputs := []*wire.TxOut{\n\t\t{\n\t\t\tValue:    2e8,\n\t\t\tPkScript: script,\n\t\t},\n\t}\n\treturn miner.SendOutputs(outputs, 2500)\n}\n",
      "length": 198,
      "tokens": 27,
      "embedding": []
    },
    {
      "slug": "func locateOutput(tx *wire.MsgTx, script []byte) (*wire.OutPoint, *wire.TxOut, error) {",
      "content": "func locateOutput(tx *wire.MsgTx, script []byte) (*wire.OutPoint, *wire.TxOut, error) {\n\tfor i, txOut := range tx.TxOut {\n\t\tif bytes.Equal(txOut.PkScript, script) {\n\t\t\treturn &wire.OutPoint{\n\t\t\t\tHash:  tx.TxHash(),\n\t\t\t\tIndex: uint32(i),\n\t\t\t}, txOut, nil\n\t\t}\n\t}\n\n\treturn nil, nil, fmt.Errorf(\"unable to find output\")\n}\n",
      "length": 219,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func craftSpendTransaction(outpoint wire.OutPoint, payScript []byte) (*wire.MsgTx, error) {",
      "content": "func craftSpendTransaction(outpoint wire.OutPoint, payScript []byte) (*wire.MsgTx, error) {\n\tspendingTx := wire.NewMsgTx(1)\n\tspendingTx.AddTxIn(&wire.TxIn{\n\t\tPreviousOutPoint: outpoint,\n\t})\n\tspendingTx.AddTxOut(&wire.TxOut{\n\t\tValue:    1e8,\n\t\tPkScript: payScript,\n\t})\n\tsigScript, err := txscript.SignatureScript(spendingTx, 0, payScript,\n\t\ttxscript.SigHashAll, privKey, true)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tspendingTx.TxIn[0].SignatureScript = sigScript\n\n\treturn spendingTx, nil\n}\n",
      "length": 380,
      "tokens": 38,
      "embedding": []
    },
    {
      "slug": "func assertFilteredBlock(t *testing.T, fb *FilteredBlock, expectedHeight int32,",
      "content": "func assertFilteredBlock(t *testing.T, fb *FilteredBlock, expectedHeight int32,\n\texpectedHash *chainhash.Hash, txns []*chainhash.Hash) {\n\n\t_, _, line, _ := runtime.Caller(1)\n\n\tif fb.Height != uint32(expectedHeight) {\n\t\tt.Fatalf(\"line %v: block height mismatch: expected %v, got %v\",\n\t\t\tline, expectedHeight, fb.Height)\n\t}\n\tif !bytes.Equal(fb.Hash[:], expectedHash[:]) {\n\t\tt.Fatalf(\"line %v: block hash mismatch: expected %v, got %v\",\n\t\t\tline, expectedHash, fb.Hash)\n\t}\n\tif len(fb.Transactions) != len(txns) {\n\t\tt.Fatalf(\"line %v: expected %v transaction in filtered block, instead \"+\n\t\t\t\"have %v\", line, len(txns), len(fb.Transactions))\n\t}\n\n\texpectedTxids := make(map[chainhash.Hash]struct{})\n\tfor _, txn := range txns {\n\t\texpectedTxids[*txn] = struct{}{}\n\t}\n\n\tfor _, tx := range fb.Transactions {\n\t\ttxid := tx.TxHash()\n\t\tdelete(expectedTxids, txid)\n\t}\n\n\tif len(expectedTxids) != 0 {\n\t\tt.Fatalf(\"line %v: missing txids: %v\", line, expectedTxids)\n\t}\n\n}\n",
      "length": 840,
      "tokens": 108,
      "embedding": []
    },
    {
      "slug": "func testFilterBlockNotifications(node *rpctest.Harness,",
      "content": "func testFilterBlockNotifications(node *rpctest.Harness,\n\tchainView FilteredChainView, chainViewInit chainViewInitFunc,\n\tt *testing.T) {\n\n\t// To start the test, we'll create to fresh outputs paying to the\n\t// private key that we generated above.\n\ttxid1, err := getTestTXID(node)\n\trequire.NoError(t, err, \"unable to get test txid\")\n\terr = waitForMempoolTx(node, txid1)\n\trequire.NoError(t, err, \"unable to get test txid in mempool\")\n\ttxid2, err := getTestTXID(node)\n\trequire.NoError(t, err, \"unable to get test txid\")\n\terr = waitForMempoolTx(node, txid2)\n\trequire.NoError(t, err, \"unable to get test txid in mempool\")\n\n\tblockChan := chainView.FilteredBlocks()\n\n\t// Next we'll mine a block confirming the output generated above.\n\tnewBlockHashes, err := node.Client.Generate(1)\n\trequire.NoError(t, err, \"unable to generate block\")\n\n\t_, currentHeight, err := node.Client.GetBestBlock()\n\trequire.NoError(t, err, \"unable to get current height\")\n\n\t// We should get an update, however it shouldn't yet contain any\n\t// filtered transaction as the filter hasn't been update.\n\tselect {\n\tcase filteredBlock := <-blockChan:\n\t\tassertFilteredBlock(t, filteredBlock, currentHeight,\n\t\t\tnewBlockHashes[0], []*chainhash.Hash{})\n\tcase <-time.After(time.Second * 20):\n\t\tt.Fatalf(\"filtered block notification didn't arrive\")\n\t}\n\n\t// Now that the block has been mined, we'll fetch the two transactions\n\t// so we can add them to the filter, and also craft transaction\n\t// spending the outputs we created.\n\ttx1, err := node.Client.GetRawTransaction(txid1)\n\trequire.NoError(t, err, \"unable to fetch transaction\")\n\ttx2, err := node.Client.GetRawTransaction(txid2)\n\trequire.NoError(t, err, \"unable to fetch transaction\")\n\n\ttargetScript, err := txscript.PayToAddrScript(testAddr)\n\trequire.NoError(t, err, \"unable to create target output\")\n\n\t// Next, we'll locate the two outputs generated above that pay to use\n\t// so we can properly add them to the filter.\n\toutPoint1, _, err := locateOutput(tx1.MsgTx(), targetScript)\n\trequire.NoError(t, err, \"unable to find output\")\n\toutPoint2, _, err := locateOutput(tx2.MsgTx(), targetScript)\n\trequire.NoError(t, err, \"unable to find output\")\n\n\t_, currentHeight, err = node.Client.GetBestBlock()\n\trequire.NoError(t, err, \"unable to get current height\")\n\n\t// Now we'll add both outpoints to the current filter.\n\tfilter := []channeldb.EdgePoint{\n\t\t{FundingPkScript: targetScript, OutPoint: *outPoint1},\n\t\t{FundingPkScript: targetScript, OutPoint: *outPoint2},\n\t}\n\terr = chainView.UpdateFilter(filter, uint32(currentHeight))\n\trequire.NoError(t, err, \"unable to update filter\")\n\n\t// With the filter updated, we'll now create two transaction spending\n\t// the outputs we created.\n\tspendingTx1, err := craftSpendTransaction(*outPoint1, targetScript)\n\trequire.NoError(t, err, \"unable to create spending tx\")\n\tspendingTx2, err := craftSpendTransaction(*outPoint2, targetScript)\n\trequire.NoError(t, err, \"unable to create spending tx\")\n\n\t// Now we'll broadcast the first spending transaction and also mine a\n\t// block which should include it.\n\tspendTxid1, err := node.Client.SendRawTransaction(spendingTx1, true)\n\trequire.NoError(t, err, \"unable to broadcast transaction\")\n\terr = waitForMempoolTx(node, spendTxid1)\n\trequire.NoError(t, err, \"unable to get spending txid in mempool\")\n\tnewBlockHashes, err = node.Client.Generate(1)\n\trequire.NoError(t, err, \"unable to generate block\")\n\n\t// We should receive a notification over the channel. The notification\n\t// should correspond to the current block height and have that single\n\t// filtered transaction.\n\tselect {\n\tcase filteredBlock := <-blockChan:\n\t\tassertFilteredBlock(t, filteredBlock, currentHeight+1,\n\t\t\tnewBlockHashes[0], []*chainhash.Hash{spendTxid1})\n\tcase <-time.After(time.Second * 20):\n\t\tt.Fatalf(\"filtered block notification didn't arrive\")\n\t}\n\n\t// Next, mine the second transaction which spends the second output.\n\t// This should also generate a notification.\n\tspendTxid2, err := node.Client.SendRawTransaction(spendingTx2, true)\n\trequire.NoError(t, err, \"unable to broadcast transaction\")\n\terr = waitForMempoolTx(node, spendTxid2)\n\trequire.NoError(t, err, \"unable to get spending txid in mempool\")\n\tnewBlockHashes, err = node.Client.Generate(1)\n\trequire.NoError(t, err, \"unable to generate block\")\n\n\tselect {\n\tcase filteredBlock := <-blockChan:\n\t\tassertFilteredBlock(t, filteredBlock, currentHeight+2,\n\t\t\tnewBlockHashes[0], []*chainhash.Hash{spendTxid2})\n\tcase <-time.After(time.Second * 20):\n\t\tt.Fatalf(\"filtered block notification didn't arrive\")\n\t}\n}\n",
      "length": 4353,
      "tokens": 520,
      "embedding": []
    },
    {
      "slug": "func testUpdateFilterBackTrack(node *rpctest.Harness,",
      "content": "func testUpdateFilterBackTrack(node *rpctest.Harness,\n\tchainView FilteredChainView, chainViewInit chainViewInitFunc,\n\tt *testing.T) {\n\n\t// To start, we'll create a fresh output paying to the height generated\n\t// above.\n\ttxid, err := getTestTXID(node)\n\tif err != nil {\n\t\tt.Fatalf(\"unable to get test txid\")\n\t}\n\terr = waitForMempoolTx(node, txid)\n\trequire.NoError(t, err, \"unable to get test txid in mempool\")\n\n\t// Next we'll mine a block confirming the output generated above.\n\tinitBlockHashes, err := node.Client.Generate(1)\n\trequire.NoError(t, err, \"unable to generate block\")\n\n\tblockChan := chainView.FilteredBlocks()\n\n\t_, currentHeight, err := node.Client.GetBestBlock()\n\trequire.NoError(t, err, \"unable to get current height\")\n\n\t// Consume the notification sent which contains an empty filtered\n\t// block.\n\tselect {\n\tcase filteredBlock := <-blockChan:\n\t\tassertFilteredBlock(t, filteredBlock, currentHeight,\n\t\t\tinitBlockHashes[0], []*chainhash.Hash{})\n\tcase <-time.After(time.Second * 20):\n\t\tt.Fatalf(\"filtered block notification didn't arrive\")\n\t}\n\n\t// Next, create a transaction which spends the output created above,\n\t// mining the spend into a block.\n\ttx, err := node.Client.GetRawTransaction(txid)\n\trequire.NoError(t, err, \"unable to fetch transaction\")\n\toutPoint, _, err := locateOutput(tx.MsgTx(), testScript)\n\trequire.NoError(t, err, \"unable to find output\")\n\tspendingTx, err := craftSpendTransaction(*outPoint, testScript)\n\trequire.NoError(t, err, \"unable to create spending tx\")\n\tspendTxid, err := node.Client.SendRawTransaction(spendingTx, true)\n\trequire.NoError(t, err, \"unable to broadcast transaction\")\n\terr = waitForMempoolTx(node, spendTxid)\n\trequire.NoError(t, err, \"unable to get spending txid in mempool\")\n\tnewBlockHashes, err := node.Client.Generate(1)\n\trequire.NoError(t, err, \"unable to generate block\")\n\n\t// We should have received another empty filtered block notification.\n\tselect {\n\tcase filteredBlock := <-blockChan:\n\t\tassertFilteredBlock(t, filteredBlock, currentHeight+1,\n\t\t\tnewBlockHashes[0], []*chainhash.Hash{})\n\tcase <-time.After(time.Second * 20):\n\t\tt.Fatalf(\"filtered block notification didn't arrive\")\n\t}\n\n\t// After the block has been mined+notified we'll update the filter with\n\t// a _prior_ height so a \"rewind\" occurs.\n\tfilter := []channeldb.EdgePoint{\n\t\t{FundingPkScript: testScript, OutPoint: *outPoint},\n\t}\n\terr = chainView.UpdateFilter(filter, uint32(currentHeight))\n\trequire.NoError(t, err, \"unable to update filter\")\n\n\t// We should now receive a fresh filtered block notification that\n\t// includes the transaction spend we included above.\n\tselect {\n\tcase filteredBlock := <-blockChan:\n\t\tassertFilteredBlock(t, filteredBlock, currentHeight+1,\n\t\t\tnewBlockHashes[0], []*chainhash.Hash{spendTxid})\n\tcase <-time.After(time.Second * 20):\n\t\tt.Fatalf(\"filtered block notification didn't arrive\")\n\t}\n}\n",
      "length": 2714,
      "tokens": 315,
      "embedding": []
    },
    {
      "slug": "func testFilterSingleBlock(node *rpctest.Harness, chainView FilteredChainView,",
      "content": "func testFilterSingleBlock(node *rpctest.Harness, chainView FilteredChainView,\n\tchainViewInit chainViewInitFunc, t *testing.T) {\n\n\t// In this test, we'll test the manual filtration of blocks, which can\n\t// be used by clients to manually rescan their sub-set of the UTXO set.\n\n\t// First, we'll create a block that includes two outputs that we're\n\t// able to spend with the private key generated above.\n\ttxid1, err := getTestTXID(node)\n\tif err != nil {\n\t\tt.Fatalf(\"unable to get test txid\")\n\t}\n\terr = waitForMempoolTx(node, txid1)\n\trequire.NoError(t, err, \"unable to get test txid in mempool\")\n\ttxid2, err := getTestTXID(node)\n\tif err != nil {\n\t\tt.Fatalf(\"unable to get test txid\")\n\t}\n\terr = waitForMempoolTx(node, txid2)\n\trequire.NoError(t, err, \"unable to get test txid in mempool\")\n\n\tblockChan := chainView.FilteredBlocks()\n\n\t// Next we'll mine a block confirming the output generated above.\n\tnewBlockHashes, err := node.Client.Generate(1)\n\trequire.NoError(t, err, \"unable to generate block\")\n\n\t_, currentHeight, err := node.Client.GetBestBlock()\n\trequire.NoError(t, err, \"unable to get current height\")\n\n\t// We should get an update, however it shouldn't yet contain any\n\t// filtered transaction as the filter hasn't been updated.\n\tselect {\n\tcase filteredBlock := <-blockChan:\n\t\tassertFilteredBlock(t, filteredBlock, currentHeight,\n\t\t\tnewBlockHashes[0], []*chainhash.Hash{})\n\tcase <-time.After(time.Second * 20):\n\t\tt.Fatalf(\"filtered block notification didn't arrive\")\n\t}\n\n\ttx1, err := node.Client.GetRawTransaction(txid1)\n\trequire.NoError(t, err, \"unable to fetch transaction\")\n\ttx2, err := node.Client.GetRawTransaction(txid2)\n\trequire.NoError(t, err, \"unable to fetch transaction\")\n\n\t// Next, we'll create a block that includes two transactions, each\n\t// which spend one of the outputs created.\n\toutPoint1, _, err := locateOutput(tx1.MsgTx(), testScript)\n\trequire.NoError(t, err, \"unable to find output\")\n\toutPoint2, _, err := locateOutput(tx2.MsgTx(), testScript)\n\trequire.NoError(t, err, \"unable to find output\")\n\tspendingTx1, err := craftSpendTransaction(*outPoint1, testScript)\n\trequire.NoError(t, err, \"unable to create spending tx\")\n\tspendingTx2, err := craftSpendTransaction(*outPoint2, testScript)\n\trequire.NoError(t, err, \"unable to create spending tx\")\n\ttxns := []*btcutil.Tx{btcutil.NewTx(spendingTx1), btcutil.NewTx(spendingTx2)}\n\tblock, err := node.GenerateAndSubmitBlock(txns, 11, time.Time{})\n\trequire.NoError(t, err, \"unable to generate block\")\n\n\tselect {\n\tcase filteredBlock := <-blockChan:\n\t\tassertFilteredBlock(t, filteredBlock, currentHeight+1,\n\t\t\tblock.Hash(), []*chainhash.Hash{})\n\tcase <-time.After(time.Second * 20):\n\t\tt.Fatalf(\"filtered block notification didn't arrive\")\n\t}\n\n\t_, currentHeight, err = node.Client.GetBestBlock()\n\trequire.NoError(t, err, \"unable to get current height\")\n\n\t// Now we'll manually trigger filtering the block generated above.\n\t// First, we'll add the two outpoints to our filter.\n\tfilter := []channeldb.EdgePoint{\n\t\t{FundingPkScript: testScript, OutPoint: *outPoint1},\n\t\t{FundingPkScript: testScript, OutPoint: *outPoint2},\n\t}\n\terr = chainView.UpdateFilter(filter, uint32(currentHeight))\n\trequire.NoError(t, err, \"unable to update filter\")\n\n\t// We set the filter with the current height, so we shouldn't get any\n\t// notifications.\n\tselect {\n\tcase <-blockChan:\n\t\tt.Fatalf(\"got filter notification, but shouldn't have\")\n\tdefault:\n\t}\n\n\t// Now we'll manually rescan that past block. This should include two\n\t// filtered transactions, the spending transactions we created above.\n\tfilteredBlock, err := chainView.FilterBlock(block.Hash())\n\trequire.NoError(t, err, \"unable to filter block\")\n\ttxn1, txn2 := spendingTx1.TxHash(), spendingTx2.TxHash()\n\texpectedTxns := []*chainhash.Hash{&txn1, &txn2}\n\tassertFilteredBlock(t, filteredBlock, currentHeight, block.Hash(),\n\t\texpectedTxns)\n}\n\n// testFilterBlockDisconnected triggers a reorg all the way back to genesis,\n// and a small 5 block reorg, ensuring the chainView notifies about\n// disconnected and connected blocks in the order we expect.",
      "length": 3863,
      "tokens": 473,
      "embedding": []
    },
    {
      "slug": "func testFilterBlockDisconnected(node *rpctest.Harness,",
      "content": "func testFilterBlockDisconnected(node *rpctest.Harness,\n\tchainView FilteredChainView, chainViewInit chainViewInitFunc,\n\tt *testing.T) {\n\n\t// Create a node that has a shorter chain than the main chain, so we\n\t// can trigger a reorg.\n\treorgNode, err := rpctest.New(netParams, nil, []string{\"--txindex\"}, \"\")\n\trequire.NoError(t, err, \"unable to create mining node\")\n\tdefer reorgNode.TearDown()\n\n\t// We want to overwrite some of the connection settings to make the\n\t// tests more robust. We might need to restart the backend while there\n\t// are already blocks present, which will take a bit longer than the\n\t// 1 second the default settings amount to. Doubling both values will\n\t// give us retries up to 4 seconds.\n\treorgNode.MaxConnRetries = rpctest.DefaultMaxConnectionRetries * 2\n\treorgNode.ConnectionRetryTimeout = rpctest.DefaultConnectionRetryTimeout * 2\n\n\t// This node's chain will be 105 blocks.\n\tif err := reorgNode.SetUp(true, 5); err != nil {\n\t\tt.Fatalf(\"unable to set up mining node: %v\", err)\n\t}\n\n\t_, bestHeight, err := reorgNode.Client.GetBestBlock()\n\trequire.NoError(t, err, \"error getting best block\")\n\n\t// Init a chain view that has this node as its block source.\n\treorgView, err := chainViewInit(\n\t\tt, reorgNode.RPCConfig(), reorgNode.P2PAddress(), bestHeight,\n\t)\n\trequire.NoError(t, err, \"unable to create chain view\")\n\n\tif err = reorgView.Start(); err != nil {\n\t\tt.Fatalf(\"unable to start btcd chain view: %v\", err)\n\t}\n\tdefer reorgView.Stop()\n\n\tnewBlocks := reorgView.FilteredBlocks()\n\tdisconnectedBlocks := reorgView.DisconnectedBlocks()\n\n\t// If this the neutrino backend, then we'll give it some time to catch\n\t// up, as it's a bit slower to consume new blocks compared to the RPC\n\t// backends.\n\tif _, ok := reorgView.(*CfFilteredChainView); ok {\n\t\ttime.Sleep(time.Second * 3)\n\t}\n\n\t_, oldHeight, err := reorgNode.Client.GetBestBlock()\n\trequire.NoError(t, err, \"unable to get current height\")\n\n\t// Now connect the node with the short chain to the main node, and wait\n\t// for their chains to synchronize. The short chain will be reorged all\n\t// the way back to genesis.\n\tif err := rpctest.ConnectNode(reorgNode, node); err != nil {\n\t\tt.Fatalf(\"unable to connect harnesses: %v\", err)\n\t}\n\tnodeSlice := []*rpctest.Harness{node, reorgNode}\n\tif err := rpctest.JoinNodes(nodeSlice, rpctest.Blocks); err != nil {\n\t\tt.Fatalf(\"unable to join node on blocks: %v\", err)\n\t}\n\n\t_, newHeight, err := reorgNode.Client.GetBestBlock()\n\trequire.NoError(t, err, \"unable to get current height\")\n\n\t// We should be getting oldHeight number of blocks marked as\n\t// stale/disconnected. We expect to first get all stale blocks,\n\t// then the new blocks. We also ensure a strict ordering.\n\tfor i := int32(0); i < oldHeight+newHeight; i++ {\n\t\tselect {\n\t\tcase block := <-newBlocks:\n\t\t\tif i < oldHeight {\n\t\t\t\tt.Fatalf(\"did not expect to get new block \"+\n\t\t\t\t\t\"in iteration %d, old height: %v\", i,\n\t\t\t\t\toldHeight)\n\t\t\t}\n\t\t\texpectedHeight := uint32(i - oldHeight + 1)\n\t\t\tif block.Height != expectedHeight {\n\t\t\t\tt.Fatalf(\"expected to receive connected \"+\n\t\t\t\t\t\"block at height %d, instead got at %d\",\n\t\t\t\t\texpectedHeight, block.Height)\n\t\t\t}\n\t\tcase block := <-disconnectedBlocks:\n\t\t\tif i >= oldHeight {\n\t\t\t\tt.Fatalf(\"did not expect to get stale block \"+\n\t\t\t\t\t\"in iteration %d\", i)\n\t\t\t}\n\t\t\texpectedHeight := uint32(oldHeight - i)\n\t\t\tif block.Height != expectedHeight {\n\t\t\t\tt.Fatalf(\"expected to receive disconnected \"+\n\t\t\t\t\t\"block at height %d, instead got at %d\",\n\t\t\t\t\texpectedHeight, block.Height)\n\t\t\t}\n\t\tcase <-time.After(10 * time.Second):\n\t\t\tt.Fatalf(\"timeout waiting for block\")\n\t\t}\n\t}\n\n\t// Now we trigger a small reorg, by disconnecting the nodes, mining\n\t// a few blocks on each, then connecting them again.\n\tpeers, err := reorgNode.Client.GetPeerInfo()\n\trequire.NoError(t, err, \"unable to get peer info\")\n\tnumPeers := len(peers)\n\n\t// Disconnect the nodes.\n\terr = reorgNode.Client.AddNode(node.P2PAddress(), rpcclient.ANRemove)\n\trequire.NoError(t, err, \"unable to disconnect mining nodes\")\n\n\t// Wait for disconnection\n\tfor {\n\t\tpeers, err = reorgNode.Client.GetPeerInfo()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to get peer info: %v\", err)\n\t\t}\n\t\tif len(peers) < numPeers {\n\t\t\tbreak\n\t\t}\n\t\ttime.Sleep(100 * time.Millisecond)\n\t}\n\n\t// Mine 10 blocks on the main chain, 5 on the chain that will be\n\t// reorged out,\n\tif _, err := node.Client.Generate(10); err != nil {\n\t\tt.Fatalf(\"unable to generate blocks on main chain: %v\", err)\n\t}\n\tif _, err := reorgNode.Client.Generate(5); err != nil {\n\t\tt.Fatalf(\"unable to generate blocks on reorged chain: %v\", err)\n\t}\n\n\t// 5 new blocks should get notified.\n\tfor i := uint32(0); i < 5; i++ {\n\t\tselect {\n\t\tcase block := <-newBlocks:\n\t\t\texpectedHeight := uint32(newHeight) + i + 1\n\t\t\tif block.Height != expectedHeight {\n\t\t\t\tt.Fatalf(\"expected to receive connected \"+\n\t\t\t\t\t\"block at height %d, instead got at %d\",\n\t\t\t\t\texpectedHeight, block.Height)\n\t\t\t}\n\t\tcase <-disconnectedBlocks:\n\t\t\tt.Fatalf(\"did not expect to get stale block \"+\n\t\t\t\t\"in iteration %d\", i)\n\t\tcase <-time.After(10 * time.Second):\n\t\t\tt.Fatalf(\"did not get connected block\")\n\t\t}\n\t}\n\n\t_, oldHeight, err = reorgNode.Client.GetBestBlock()\n\trequire.NoError(t, err, \"unable to get current height\")\n\n\t// Now connect the two nodes, and wait for their chains to sync up.\n\tif err := rpctest.ConnectNode(reorgNode, node); err != nil {\n\t\tt.Fatalf(\"unable to connect harnesses: %v\", err)\n\t}\n\tif err := rpctest.JoinNodes(nodeSlice, rpctest.Blocks); err != nil {\n\t\tt.Fatalf(\"unable to join node on blocks: %v\", err)\n\t}\n\n\tif _, _, err := reorgNode.Client.GetBestBlock(); err != nil {\n\t\tt.Fatalf(\"unable to get current height: %v\", err)\n\t}\n\n\t// We should get 5 disconnected, 10 connected blocks.\n\tfor i := uint32(0); i < 15; i++ {\n\t\tselect {\n\t\tcase block := <-newBlocks:\n\t\t\tif i < 5 {\n\t\t\t\tt.Fatalf(\"did not expect to get new block \"+\n\t\t\t\t\t\"in iteration %d\", i)\n\t\t\t}\n\t\t\t// The expected height for the connected block will be\n\t\t\t// oldHeight - 5 (the 5 disconnected blocks) + (i-5)\n\t\t\t// (subtract 5 since the 5 first iterations consumed\n\t\t\t// disconnected blocks) + 1\n\t\t\texpectedHeight := uint32(oldHeight) - 9 + i\n\t\t\tif block.Height != expectedHeight {\n\t\t\t\tt.Fatalf(\"expected to receive connected \"+\n\t\t\t\t\t\"block at height %d, instead got at %d\",\n\t\t\t\t\texpectedHeight, block.Height)\n\t\t\t}\n\t\tcase block := <-disconnectedBlocks:\n\t\t\tif i >= 5 {\n\t\t\t\tt.Fatalf(\"did not expect to get stale block \"+\n\t\t\t\t\t\"in iteration %d\", i)\n\t\t\t}\n\t\t\texpectedHeight := uint32(oldHeight) - i\n\t\t\tif block.Height != expectedHeight {\n\t\t\t\tt.Fatalf(\"expected to receive disconnected \"+\n\t\t\t\t\t\"block at height %d, instead got at %d\",\n\t\t\t\t\texpectedHeight, block.Height)\n\t\t\t}\n\t\tcase <-time.After(10 * time.Second):\n\t\t\tt.Fatalf(\"did not get disconnected block\")\n\t\t}\n\t}\n\n\t// Time for db access to finish between testcases.\n\ttime.Sleep(time.Millisecond * 500)\n}\n",
      "length": 6537,
      "tokens": 966,
      "embedding": []
    },
    {
      "slug": "type chainViewInitFunc func(t *testing.T, rpcInfo rpcclient.ConnConfig,",
      "content": "type chainViewInitFunc func(t *testing.T, rpcInfo rpcclient.ConnConfig,\n\tp2pAddr string, bestHeight int32) (FilteredChainView, error)\n",
      "length": 61,
      "tokens": 6,
      "embedding": []
    },
    {
      "slug": "type testCase struct {",
      "content": "type testCase struct {\n\tname string\n\ttest func(*rpctest.Harness, FilteredChainView, chainViewInitFunc,\n\t\t*testing.T)\n}\n\nvar chainViewTests = []testCase{\n\t{\n\t\tname: \"filtered block ntfns\",\n\t\ttest: testFilterBlockNotifications,\n\t},\n\t{\n\t\tname: \"update filter back track\",\n\t\ttest: testUpdateFilterBackTrack,\n\t},\n\t{\n\t\tname: \"filter single block\",\n\t\ttest: testFilterSingleBlock,\n\t},\n\t{\n\t\tname: \"filter block disconnected\",\n\t\ttest: testFilterBlockDisconnected,\n\t},\n}\n\nvar interfaceImpls = []struct {\n\tname          string\n\tchainViewInit chainViewInitFunc\n}{\n\t{\n\t\tname: \"bitcoind_zmq\",\n\t\tchainViewInit: func(t *testing.T, _ rpcclient.ConnConfig,\n\t\t\tp2pAddr string, bestHeight int32) (FilteredChainView, error) {\n\n\t\t\t// Start a bitcoind instance.\n\t\t\ttempBitcoindDir := t.TempDir()\n\t\t\tzmqBlockHost := \"ipc:///\" + tempBitcoindDir + \"/blocks.socket\"\n\t\t\tzmqTxHost := \"ipc:///\" + tempBitcoindDir + \"/tx.socket\"\n\n\t\t\trpcPort := getFreePort()\n\t\t\tbitcoind := exec.Command(\n\t\t\t\t\"bitcoind\",\n\t\t\t\t\"-datadir=\"+tempBitcoindDir,\n\t\t\t\t\"-regtest\",\n\t\t\t\t\"-connect=\"+p2pAddr,\n\t\t\t\t\"-txindex\",\n\t\t\t\t\"-rpcauth=weks:469e9bb14ab2360f8e226efed5ca6f\"+\n\t\t\t\t\t\"d$507c670e800a95284294edb5773b05544b\"+\n\t\t\t\t\t\"220110063096c221be9933c82d38e1\",\n\t\t\t\tfmt.Sprintf(\"-rpcport=%d\", rpcPort),\n\t\t\t\t\"-disablewallet\",\n\t\t\t\t\"-zmqpubrawblock=\"+zmqBlockHost,\n\t\t\t\t\"-zmqpubrawtx=\"+zmqTxHost,\n\t\t\t)\n\t\t\terr := bitcoind.Start()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\t// Sanity check to ensure that the process did in fact\n\t\t\t// start.\n\t\t\tif bitcoind.Process == nil {\n\t\t\t\treturn nil, fmt.Errorf(\"bitcoind cmd \" +\n\t\t\t\t\t\"Process is not set after Start\")\n\t\t\t}\n\n\t\t\tt.Cleanup(func() {\n\t\t\t\t_ = bitcoind.Process.Kill()\n\t\t\t\t_ = bitcoind.Wait()\n\t\t\t})\n\n\t\t\thost := fmt.Sprintf(\"127.0.0.1:%d\", rpcPort)\n\t\t\tcfg := &chain.BitcoindConfig{\n\t\t\t\tChainParams: &chaincfg.RegressionNetParams,\n\t\t\t\tHost:        host,\n\t\t\t\tUser:        \"weks\",\n\t\t\t\tPass:        \"weks\",\n\t\t\t\tZMQConfig: &chain.ZMQConfig{\n\t\t\t\t\tZMQBlockHost:    zmqBlockHost,\n\t\t\t\t\tZMQTxHost:       zmqTxHost,\n\t\t\t\t\tZMQReadDeadline: 5 * time.Second,\n\t\t\t\t},\n\t\t\t\t// Fields only required for pruned nodes, not\n\t\t\t\t// needed for these tests.\n\t\t\t\tDialer:             nil,\n\t\t\t\tPrunedModeMaxPeers: 0,\n\t\t\t}\n\n\t\t\tvar chainConn *chain.BitcoindConn\n\t\t\terr = wait.NoError(func() error {\n\t\t\t\tchainConn, err = chain.NewBitcoindConn(cfg)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\terr = chainConn.Start()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tclient := chainConn.NewBitcoindClient()\n\t\t\t\t_, currentHeight, err := client.GetBestBlock()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tif currentHeight < bestHeight {\n\t\t\t\t\treturn fmt.Errorf(\"not synced yet\")\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t}, 10*time.Second)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"unable to \"+\n\t\t\t\t\t\"establish connection to bitcoind: %v\",\n\t\t\t\t\terr)\n\t\t\t}\n\t\t\tt.Cleanup(func() {\n\t\t\t\tchainConn.Stop()\n\t\t\t})\n\n\t\t\tblockCache := blockcache.NewBlockCache(10000)\n\n\t\t\tchainView := NewBitcoindFilteredChainView(\n\t\t\t\tchainConn, blockCache,\n\t\t\t)\n\n\t\t\treturn chainView, nil\n\t\t},\n\t},\n\t{\n\t\tname: \"bitcoind_polling\",\n\t\tchainViewInit: func(t *testing.T, _ rpcclient.ConnConfig,\n\t\t\tp2pAddr string, bestHeight int32) (FilteredChainView, error) {\n\n\t\t\t// Start a bitcoind instance.\n\t\t\ttempBitcoindDir := t.TempDir()\n\n\t\t\trpcPort := getFreePort()\n\t\t\tbitcoind := exec.Command(\n\t\t\t\t\"bitcoind\",\n\t\t\t\t\"-datadir=\"+tempBitcoindDir,\n\t\t\t\t\"-regtest\",\n\t\t\t\t\"-connect=\"+p2pAddr,\n\t\t\t\t\"-txindex\",\n\t\t\t\t\"-rpcauth=weks:469e9bb14ab2360f8e226efed5ca6f\"+\n\t\t\t\t\t\"d$507c670e800a95284294edb5773b05544b\"+\n\t\t\t\t\t\"220110063096c221be9933c82d38e1\",\n\t\t\t\tfmt.Sprintf(\"-rpcport=%d\", rpcPort),\n\t\t\t\t\"-disablewallet\",\n\t\t\t)\n\t\t\terr := bitcoind.Start()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\t// Sanity check to ensure that the process did in fact\n\t\t\t// start.\n\t\t\tif bitcoind.Process == nil {\n\t\t\t\treturn nil, fmt.Errorf(\"bitcoind cmd \" +\n\t\t\t\t\t\"Process is not set after Start\")\n\t\t\t}\n\n\t\t\tt.Cleanup(func() {\n\t\t\t\t_ = bitcoind.Process.Kill()\n\t\t\t\t_ = bitcoind.Wait()\n\t\t\t})\n\n\t\t\thost := fmt.Sprintf(\"127.0.0.1:%d\", rpcPort)\n\t\t\tcfg := &chain.BitcoindConfig{\n\t\t\t\tChainParams: &chaincfg.RegressionNetParams,\n\t\t\t\tHost:        host,\n\t\t\t\tUser:        \"weks\",\n\t\t\t\tPass:        \"weks\",\n\t\t\t\tPollingConfig: &chain.PollingConfig{\n\t\t\t\t\tBlockPollingInterval: time.Millisecond * 100,\n\t\t\t\t\tTxPollingInterval:    time.Millisecond * 100,\n\t\t\t\t},\n\t\t\t\t// Fields only required for pruned nodes, not\n\t\t\t\t// needed for these tests.\n\t\t\t\tDialer:             nil,\n\t\t\t\tPrunedModeMaxPeers: 0,\n\t\t\t}\n\n\t\t\t// Wait for the bitcoind instance to start up.\n\t\t\tvar chainConn *chain.BitcoindConn\n\t\t\terr = wait.NoError(func() error {\n\t\t\t\tchainConn, err = chain.NewBitcoindConn(cfg)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\terr = chainConn.Start()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tclient := chainConn.NewBitcoindClient()\n\t\t\t\t_, currentHeight, err := client.GetBestBlock()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tif currentHeight < bestHeight {\n\t\t\t\t\treturn fmt.Errorf(\"not synced yet\")\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t}, 10*time.Second)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"unable to \"+\n\t\t\t\t\t\"establish connection to bitcoind: %v\",\n\t\t\t\t\terr)\n\t\t\t}\n\t\t\tt.Cleanup(func() {\n\t\t\t\tchainConn.Stop()\n\t\t\t})\n\n\t\t\tblockCache := blockcache.NewBlockCache(10000)\n\n\t\t\tchainView := NewBitcoindFilteredChainView(\n\t\t\t\tchainConn, blockCache,\n\t\t\t)\n\n\t\t\treturn chainView, nil\n\t\t},\n\t},\n\t{\n\t\tname: \"p2p_neutrino\",\n\t\tchainViewInit: func(t *testing.T, _ rpcclient.ConnConfig,\n\t\t\tp2pAddr string, bestHeight int32) (FilteredChainView, error) {\n\n\t\t\tspvDir := t.TempDir()\n\n\t\t\tdbName := filepath.Join(spvDir, \"neutrino.db\")\n\t\t\tspvDatabase, err := walletdb.Create(\n\t\t\t\t\"bdb\", dbName, true, kvdb.DefaultDBTimeout,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tspvConfig := neutrino.Config{\n\t\t\t\tDataDir:      spvDir,\n\t\t\t\tDatabase:     spvDatabase,\n\t\t\t\tChainParams:  *netParams,\n\t\t\t\tConnectPeers: []string{p2pAddr},\n\t\t\t}\n\n\t\t\tspvNode, err := neutrino.NewChainService(spvConfig)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\t// Wait until the node has fully synced up to the local\n\t\t\t// btcd node.\n\t\t\terr = wait.NoError(func() error {\n\t\t\t\terr := spvNode.Start()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tbestBlock, err := spvNode.BestBlock()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tif bestBlock.Height < bestHeight {\n\t\t\t\t\treturn fmt.Errorf(\"not synced yet\")\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t}, 10*time.Second)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"unable to \"+\n\t\t\t\t\t\"establish connection to bitcoind: %v\",\n\t\t\t\t\terr)\n\t\t\t}\n\n\t\t\tt.Cleanup(func() {\n\t\t\t\tspvDatabase.Close()\n\t\t\t\tspvNode.Stop()\n\t\t\t})\n\n\t\t\tblockCache := blockcache.NewBlockCache(10000)\n\n\t\t\tchainView, err := NewCfFilteredChainView(\n\t\t\t\tspvNode, blockCache,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn chainView, nil\n\t\t},\n\t},\n\t{\n\t\tname: \"btcd_websockets\",\n\t\tchainViewInit: func(_ *testing.T, config rpcclient.ConnConfig,\n\t\t\tp2pAddr string, bestHeight int32) (FilteredChainView, error) {\n\n\t\t\tblockCache := blockcache.NewBlockCache(10000)\n\t\t\tchainView, err := NewBtcdFilteredChainView(\n\t\t\t\tconfig, blockCache,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn chainView, err\n\t\t},\n\t},\n}\n",
      "length": 6773,
      "tokens": 755,
      "embedding": []
    },
    {
      "slug": "func TestFilteredChainView(t *testing.T) {",
      "content": "func TestFilteredChainView(t *testing.T) {\n\t// Initialize the harness around a btcd node which will serve as our\n\t// dedicated miner to generate blocks, cause re-orgs, etc. We'll set up\n\t// this node with a chain length of 125, so we have plenty of BTC to\n\t// play around with.\n\tminer, err := rpctest.New(netParams, nil, []string{\"--txindex\"}, \"\")\n\trequire.NoError(t, err, \"unable to create mining node\")\n\tdefer miner.TearDown()\n\tif err := miner.SetUp(true, 25); err != nil {\n\t\tt.Fatalf(\"unable to set up mining node: %v\", err)\n\t}\n\n\trpcConfig := miner.RPCConfig()\n\tp2pAddr := miner.P2PAddress()\n\n\tfor _, chainViewImpl := range interfaceImpls {\n\t\tt.Logf(\"Testing '%v' implementation of FilteredChainView\",\n\t\t\tchainViewImpl.name)\n\n\t\t_, bestHeight, err := miner.Client.GetBestBlock()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"error getting best block: %v\", err)\n\t\t}\n\n\t\tchainView, err := chainViewImpl.chainViewInit(\n\t\t\tt, rpcConfig, p2pAddr, bestHeight,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to make chain view: %v\", err)\n\t\t}\n\t\tif err := chainView.Start(); err != nil {\n\t\t\tt.Fatalf(\"unable to start chain view: %v\", err)\n\t\t}\n\t\tfor _, chainViewTest := range chainViewTests {\n\t\t\ttestName := fmt.Sprintf(\"%v: %v\", chainViewImpl.name,\n\t\t\t\tchainViewTest.name)\n\t\t\tsuccess := t.Run(testName, func(t *testing.T) {\n\t\t\t\tchainViewTest.test(\n\t\t\t\t\tminer, chainView,\n\t\t\t\t\tchainViewImpl.chainViewInit, t,\n\t\t\t\t)\n\t\t\t})\n\n\t\t\tif !success {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif err := chainView.Stop(); err != nil {\n\t\t\tt.Fatalf(\"unable to stop chain view: %v\", err)\n\t\t}\n\t}\n}\n",
      "length": 1437,
      "tokens": 203,
      "embedding": []
    }
  ]
}