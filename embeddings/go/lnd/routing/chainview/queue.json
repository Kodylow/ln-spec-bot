{
  "filepath": "../implementations/go/lnd/routing/chainview/queue.go",
  "package": "chainview",
  "sections": [
    {
      "slug": "type blockEventType uint8",
      "content": "type blockEventType uint8\n\nconst (\n\t// connected is the type of a blockEvent representing a block\n\t// that was connected to our current chain.\n\tconnected blockEventType = iota\n\n\t// disconnected is the type of a blockEvent representing a\n\t// block that is stale/disconnected from our current chain.\n\tdisconnected\n)\n\n// blockEvent represent a block that was either connected\n// or disconnected from the current chain.",
      "length": 377,
      "tokens": 62,
      "embedding": []
    },
    {
      "slug": "type blockEvent struct {",
      "content": "type blockEvent struct {\n\teventType blockEventType\n\tblock     *FilteredBlock\n}\n\n// blockEventQueue is an ordered queue for block events sent from a\n// FilteredChainView. The two types of possible block events are\n// connected/new blocks, and disconnected/stale blocks. The\n// blockEventQueue keeps the order of these events intact, while\n// still being non-blocking. This is important in order for the\n// chainView's call to onBlockConnected/onBlockDisconnected to not\n// get blocked, and for the consumer of the block events to always\n// get the events in the correct order.",
      "length": 539,
      "tokens": 83,
      "embedding": []
    },
    {
      "slug": "type blockEventQueue struct {",
      "content": "type blockEventQueue struct {\n\tqueueCond *sync.Cond\n\tqueueMtx  sync.Mutex\n\tqueue     []*blockEvent\n\n\t// newBlocks is the channel where the consumer of the queue\n\t// will receive connected/new blocks from the FilteredChainView.\n\tnewBlocks chan *FilteredBlock\n\n\t// staleBlocks is the channel where the consumer of the queue will\n\t// receive disconnected/stale blocks from the FilteredChainView.\n\tstaleBlocks chan *FilteredBlock\n\n\twg   sync.WaitGroup\n\tquit chan struct{}\n}\n\n// newBlockEventQueue creates a new blockEventQueue.",
      "length": 477,
      "tokens": 62,
      "embedding": []
    },
    {
      "slug": "func newBlockEventQueue() *blockEventQueue {",
      "content": "func newBlockEventQueue() *blockEventQueue {\n\tb := &blockEventQueue{\n\t\tnewBlocks:   make(chan *FilteredBlock),\n\t\tstaleBlocks: make(chan *FilteredBlock),\n\t\tquit:        make(chan struct{}),\n\t}\n\tb.queueCond = sync.NewCond(&b.queueMtx)\n\n\treturn b\n}\n\n// Start starts the blockEventQueue coordinator such that it can start handling\n// events.",
      "length": 281,
      "tokens": 33,
      "embedding": []
    },
    {
      "slug": "func (b *blockEventQueue) Start() {",
      "content": "func (b *blockEventQueue) Start() {\n\tb.wg.Add(1)\n\tgo b.queueCoordinator()\n}\n\n// Stop signals the queue coordinator to stop, such that the queue can be\n// shut down.",
      "length": 123,
      "tokens": 21,
      "embedding": []
    },
    {
      "slug": "func (b *blockEventQueue) Stop() {",
      "content": "func (b *blockEventQueue) Stop() {\n\tclose(b.quit)\n\n\tb.queueCond.Signal()\n}\n\n// queueCoordinator is the queue's main loop, handling incoming block events\n// and handing them off to the correct output channel.\n//\n// NB: MUST be run as a goroutine from the Start() method.",
      "length": 226,
      "tokens": 37,
      "embedding": []
    },
    {
      "slug": "func (b *blockEventQueue) queueCoordinator() {",
      "content": "func (b *blockEventQueue) queueCoordinator() {\n\tdefer b.wg.Done()\n\n\tfor {\n\t\t// First, we'll check our condition. If the queue of events is\n\t\t// empty, then we'll wait until a new item is added.\n\t\tb.queueCond.L.Lock()\n\t\tfor len(b.queue) == 0 {\n\t\t\tb.queueCond.Wait()\n\n\t\t\t// If we were woke up in order to exit, then we'll do\n\t\t\t// so. Otherwise, we'll check the queue for any new\n\t\t\t// items.\n\t\t\tselect {\n\t\t\tcase <-b.quit:\n\t\t\t\tb.queueCond.L.Unlock()\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\n\t\t// Grab the first element in the queue, and nil the index to\n\t\t// avoid gc leak.\n\t\tevent := b.queue[0]\n\t\tb.queue[0] = nil\n\t\tb.queue = b.queue[1:]\n\t\tb.queueCond.L.Unlock()\n\n\t\t// In the case this is a connected block, we'll send it on the\n\t\t// newBlocks channel. In case it is a disconnected block, we'll\n\t\t// send it on the staleBlocks channel. This send will block\n\t\t// until it is received by the consumer on the other end, making\n\t\t// sure we won't try to send any other block event before the\n\t\t// consumer is aware of this one.\n\t\tswitch event.eventType {\n\t\tcase connected:\n\t\t\tselect {\n\t\t\tcase b.newBlocks <- event.block:\n\t\t\tcase <-b.quit:\n\t\t\t\treturn\n\t\t\t}\n\t\tcase disconnected:\n\t\t\tselect {\n\t\t\tcase b.staleBlocks <- event.block:\n\t\t\tcase <-b.quit:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Add puts the provided blockEvent at the end of the event queue, making sure\n// it will first be received after all previous events. This method is\n// non-blocking, in the sense that it will never wait for the consumer of the\n// queue to read form the other end, making it safe to call from the\n// FilteredChainView's onBlockConnected/onBlockDisconnected.",
      "length": 1513,
      "tokens": 255,
      "embedding": []
    },
    {
      "slug": "func (b *blockEventQueue) Add(event *blockEvent) {",
      "content": "func (b *blockEventQueue) Add(event *blockEvent) {\n\n\t// Lock the condition, and add the event to the end of queue.\n\tb.queueCond.L.Lock()\n\tb.queue = append(b.queue, event)\n\tb.queueCond.L.Unlock()\n\n\t// With the event added, we signal to the queueCoordinator that\n\t// there are new events to handle.\n\tb.queueCond.Signal()\n}\n",
      "length": 260,
      "tokens": 39,
      "embedding": []
    }
  ]
}