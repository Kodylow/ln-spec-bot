{
  "filepath": "../implementations/go/lnd/routing/chainview/neutrino.go",
  "package": "chainview",
  "sections": [
    {
      "slug": "type CfFilteredChainView struct {",
      "content": "type CfFilteredChainView struct {\n\tstarted int32 // To be used atomically.\n\tstopped int32 // To be used atomically.\n\n\t// p2pNode is a pointer to the running GCS-filter supported Bitcoin\n\t// light clientl\n\tp2pNode *neutrino.ChainService\n\n\t// chainView is the active rescan which only watches our specified\n\t// sub-set of the UTXO set.\n\tchainView *neutrino.Rescan\n\n\t// rescanErrChan is the channel that any errors encountered during the\n\t// rescan will be sent over.\n\trescanErrChan <-chan error\n\n\t// blockEventQueue is the ordered queue used to keep the order\n\t// of connected and disconnected blocks sent to the reader of the\n\t// chainView.\n\tblockQueue *blockEventQueue\n\n\t// blockCache is an LRU block cache.\n\tblockCache *blockcache.BlockCache\n\n\t// chainFilter is the\n\tfilterMtx   sync.RWMutex\n\tchainFilter map[wire.OutPoint][]byte\n\n\tquit chan struct{}\n\twg   sync.WaitGroup\n}\n\n// A compile time check to ensure CfFilteredChainView implements the\n// chainview.FilteredChainView.\nvar _ FilteredChainView = (*CfFilteredChainView)(nil)\n\n// NewCfFilteredChainView creates a new instance of the CfFilteredChainView\n// which is connected to an active neutrino node.\n//\n// NOTE: The node should already be running and syncing before being passed into\n// this function.",
      "length": 1186,
      "tokens": 172,
      "embedding": []
    },
    {
      "slug": "func NewCfFilteredChainView(node *neutrino.ChainService,",
      "content": "func NewCfFilteredChainView(node *neutrino.ChainService,\n\tblockCache *blockcache.BlockCache) (*CfFilteredChainView, error) {\n\n\treturn &CfFilteredChainView{\n\t\tblockQueue:    newBlockEventQueue(),\n\t\tquit:          make(chan struct{}),\n\t\trescanErrChan: make(chan error),\n\t\tchainFilter:   make(map[wire.OutPoint][]byte),\n\t\tp2pNode:       node,\n\t\tblockCache:    blockCache,\n\t}, nil\n}\n\n// Start kicks off the FilteredChainView implementation. This function must be\n// called before any calls to UpdateFilter can be processed.\n//\n// NOTE: This is part of the FilteredChainView interface.",
      "length": 508,
      "tokens": 55,
      "embedding": []
    },
    {
      "slug": "func (c *CfFilteredChainView) Start() error {",
      "content": "func (c *CfFilteredChainView) Start() error {\n\t// Already started?\n\tif atomic.AddInt32(&c.started, 1) != 1 {\n\t\treturn nil\n\t}\n\n\tlog.Infof(\"FilteredChainView starting\")\n\n\t// First, we'll obtain the latest block height of the p2p node. We'll\n\t// start the auto-rescan from this point. Once a caller actually wishes\n\t// to register a chain view, the rescan state will be rewound\n\t// accordingly.\n\tstartingPoint, err := c.p2pNode.BestBlock()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Next, we'll create our set of rescan options. Currently it's\n\t// required that an user MUST set a addr/outpoint/txid when creating a\n\t// rescan. To get around this, we'll add a \"zero\" outpoint, that won't\n\t// actually be matched.\n\tvar zeroPoint neutrino.InputWithScript\n\trescanOptions := []neutrino.RescanOption{\n\t\tneutrino.StartBlock(startingPoint),\n\t\tneutrino.QuitChan(c.quit),\n\t\tneutrino.NotificationHandlers(\n\t\t\trpcclient.NotificationHandlers{\n\t\t\t\tOnFilteredBlockConnected:    c.onFilteredBlockConnected,\n\t\t\t\tOnFilteredBlockDisconnected: c.onFilteredBlockDisconnected,\n\t\t\t},\n\t\t),\n\t\tneutrino.WatchInputs(zeroPoint),\n\t}\n\n\t// Finally, we'll create our rescan struct, start it, and launch all\n\t// the goroutines we need to operate this FilteredChainView instance.\n\tc.chainView = neutrino.NewRescan(\n\t\t&neutrino.RescanChainSource{\n\t\t\tChainService: c.p2pNode,\n\t\t},\n\t\trescanOptions...,\n\t)\n\tc.rescanErrChan = c.chainView.Start()\n\n\tc.blockQueue.Start()\n\n\tc.wg.Add(1)\n\tgo c.chainFilterer()\n\n\treturn nil\n}\n\n// Stop signals all active goroutines for a graceful shutdown.\n//\n// NOTE: This is part of the FilteredChainView interface.",
      "length": 1499,
      "tokens": 184,
      "embedding": []
    },
    {
      "slug": "func (c *CfFilteredChainView) Stop() error {",
      "content": "func (c *CfFilteredChainView) Stop() error {\n\t// Already shutting down?\n\tif atomic.AddInt32(&c.stopped, 1) != 1 {\n\t\treturn nil\n\t}\n\n\tlog.Infof(\"FilteredChainView stopping\")\n\n\tclose(c.quit)\n\tc.blockQueue.Stop()\n\tc.wg.Wait()\n\n\treturn nil\n}\n\n// onFilteredBlockConnected is called for each block that's connected to the\n// end of the main chain. Based on our current chain filter, the block may or\n// may not include any relevant transactions.",
      "length": 377,
      "tokens": 55,
      "embedding": []
    },
    {
      "slug": "func (c *CfFilteredChainView) onFilteredBlockConnected(height int32,",
      "content": "func (c *CfFilteredChainView) onFilteredBlockConnected(height int32,\n\theader *wire.BlockHeader, txns []*btcutil.Tx) {\n\n\tmtxs := make([]*wire.MsgTx, len(txns))\n\tfor i, tx := range txns {\n\t\tmtx := tx.MsgTx()\n\t\tmtxs[i] = mtx\n\n\t\tfor _, txIn := range mtx.TxIn {\n\t\t\tc.filterMtx.Lock()\n\t\t\tdelete(c.chainFilter, txIn.PreviousOutPoint)\n\t\t\tc.filterMtx.Unlock()\n\t\t}\n\n\t}\n\n\tblock := &FilteredBlock{\n\t\tHash:         header.BlockHash(),\n\t\tHeight:       uint32(height),\n\t\tTransactions: mtxs,\n\t}\n\n\tc.blockQueue.Add(&blockEvent{\n\t\teventType: connected,\n\t\tblock:     block,\n\t})\n}\n\n// onFilteredBlockDisconnected is a callback which is executed once a block is\n// disconnected from the end of the main chain.",
      "length": 591,
      "tokens": 73,
      "embedding": []
    },
    {
      "slug": "func (c *CfFilteredChainView) onFilteredBlockDisconnected(height int32,",
      "content": "func (c *CfFilteredChainView) onFilteredBlockDisconnected(height int32,\n\theader *wire.BlockHeader) {\n\n\tlog.Debugf(\"got disconnected block at height %d: %v\", height,\n\t\theader.BlockHash())\n\n\tfilteredBlock := &FilteredBlock{\n\t\tHash:   header.BlockHash(),\n\t\tHeight: uint32(height),\n\t}\n\n\tc.blockQueue.Add(&blockEvent{\n\t\teventType: disconnected,\n\t\tblock:     filteredBlock,\n\t})\n}\n\n// chainFilterer is the primary coordination goroutine within the\n// CfFilteredChainView. This goroutine handles errors from the running rescan.",
      "length": 430,
      "tokens": 46,
      "embedding": []
    },
    {
      "slug": "func (c *CfFilteredChainView) chainFilterer() {",
      "content": "func (c *CfFilteredChainView) chainFilterer() {\n\tdefer c.wg.Done()\n\n\tfor {\n\t\tselect {\n\t\tcase err := <-c.rescanErrChan:\n\t\t\tlog.Errorf(\"Error encountered during rescan: %v\", err)\n\t\tcase <-c.quit:\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// FilterBlock takes a block hash, and returns a FilteredBlocks which is the\n// result of applying the current registered UTXO sub-set on the block\n// corresponding to that block hash. If any watched UTXO's are spent by the\n// selected lock, then the internal chainFilter will also be updated.\n//\n// NOTE: This is part of the FilteredChainView interface.",
      "length": 503,
      "tokens": 82,
      "embedding": []
    },
    {
      "slug": "func (c *CfFilteredChainView) FilterBlock(blockHash *chainhash.Hash) (*FilteredBlock, error) {",
      "content": "func (c *CfFilteredChainView) FilterBlock(blockHash *chainhash.Hash) (*FilteredBlock, error) {\n\t// First, we'll fetch the block header itself so we can obtain the\n\t// height which is part of our return value.\n\tblockHeight, err := c.p2pNode.GetBlockHeight(blockHash)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfilteredBlock := &FilteredBlock{\n\t\tHash:   *blockHash,\n\t\tHeight: uint32(blockHeight),\n\t}\n\n\t// If we don't have any items within our current chain filter, then we\n\t// can exit early as we don't need to fetch the filter.\n\tc.filterMtx.RLock()\n\tif len(c.chainFilter) == 0 {\n\t\tc.filterMtx.RUnlock()\n\t\treturn filteredBlock, nil\n\t}\n\tc.filterMtx.RUnlock()\n\n\t// Next, using the block, hash, we'll fetch the compact filter for this\n\t// block. We only require the regular filter as we're just looking for\n\t// outpoint that have been spent.\n\tfilter, err := c.p2pNode.GetCFilter(*blockHash, wire.GCSFilterRegular)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to fetch filter: %v\", err)\n\t}\n\n\t// Before we can match the filter, we'll need to map each item in our\n\t// chain filter to the representation that included in the compact\n\t// filters.\n\tc.filterMtx.RLock()\n\trelevantPoints := make([][]byte, 0, len(c.chainFilter))\n\tfor _, filterEntry := range c.chainFilter {\n\t\trelevantPoints = append(relevantPoints, filterEntry)\n\t}\n\tc.filterMtx.RUnlock()\n\n\t// With our relevant points constructed, we can finally match against\n\t// the retrieved filter.\n\tmatched, err := filter.MatchAny(builder.DeriveKey(blockHash),\n\t\trelevantPoints)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// If there wasn't a match, then we'll return the filtered block as is\n\t// (void of any transactions).\n\tif !matched {\n\t\treturn filteredBlock, nil\n\t}\n\n\t// If we reach this point, then there was a match, so we'll need to\n\t// fetch the block itself so we can scan it for any actual matches (as\n\t// there's a fp rate).\n\tblock, err := c.GetBlock(*blockHash)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Finally, we'll step through the block, input by input, to see if any\n\t// transactions spend any outputs from our watched sub-set of the UTXO\n\t// set.\n\tfor _, tx := range block.Transactions() {\n\t\tfor _, txIn := range tx.MsgTx().TxIn {\n\t\t\tprevOp := txIn.PreviousOutPoint\n\n\t\t\tc.filterMtx.RLock()\n\t\t\t_, ok := c.chainFilter[prevOp]\n\t\t\tc.filterMtx.RUnlock()\n\n\t\t\tif ok {\n\t\t\t\tfilteredBlock.Transactions = append(\n\t\t\t\t\tfilteredBlock.Transactions,\n\t\t\t\t\ttx.MsgTx(),\n\t\t\t\t)\n\n\t\t\t\tc.filterMtx.Lock()\n\t\t\t\tdelete(c.chainFilter, prevOp)\n\t\t\t\tc.filterMtx.Unlock()\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn filteredBlock, nil\n}\n\n// UpdateFilter updates the UTXO filter which is to be consulted when creating\n// FilteredBlocks to be sent to subscribed clients. This method is cumulative\n// meaning repeated calls to this method should _expand_ the size of the UTXO\n// sub-set currently being watched.  If the set updateHeight is _lower_ than\n// the best known height of the implementation, then the state should be\n// rewound to ensure all relevant notifications are dispatched.\n//\n// NOTE: This is part of the FilteredChainView interface.",
      "length": 2874,
      "tokens": 437,
      "embedding": []
    },
    {
      "slug": "func (c *CfFilteredChainView) UpdateFilter(ops []channeldb.EdgePoint,",
      "content": "func (c *CfFilteredChainView) UpdateFilter(ops []channeldb.EdgePoint,\n\tupdateHeight uint32) error {\n\n\tlog.Tracef(\"Updating chain filter with new UTXO's: %v\", ops)\n\n\t// First, we'll update the current chain view, by adding any new\n\t// UTXO's, ignoring duplicates in the process.\n\tc.filterMtx.Lock()\n\tfor _, op := range ops {\n\t\tc.chainFilter[op.OutPoint] = op.FundingPkScript\n\t}\n\tc.filterMtx.Unlock()\n\n\tinputs := make([]neutrino.InputWithScript, len(ops))\n\tfor i, op := range ops {\n\t\tinputs[i] = neutrino.InputWithScript{\n\t\t\tPkScript: op.FundingPkScript,\n\t\t\tOutPoint: op.OutPoint,\n\t\t}\n\t}\n\n\t// With our internal chain view update, we'll craft a new update to the\n\t// chainView which includes our new UTXO's, and current update height.\n\trescanUpdate := []neutrino.UpdateOption{\n\t\tneutrino.AddInputs(inputs...),\n\t\tneutrino.Rewind(updateHeight),\n\t\tneutrino.DisableDisconnectedNtfns(true),\n\t}\n\terr := c.chainView.Update(rescanUpdate...)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to update rescan: %v\", err)\n\t}\n\treturn nil\n}\n\n// FilteredBlocks returns the channel that filtered blocks are to be sent over.\n// Each time a block is connected to the end of a main chain, and appropriate\n// FilteredBlock which contains the transactions which mutate our watched UTXO\n// set is to be returned.\n//\n// NOTE: This is part of the FilteredChainView interface.",
      "length": 1235,
      "tokens": 171,
      "embedding": []
    },
    {
      "slug": "func (c *CfFilteredChainView) FilteredBlocks() <-chan *FilteredBlock {",
      "content": "func (c *CfFilteredChainView) FilteredBlocks() <-chan *FilteredBlock {\n\treturn c.blockQueue.newBlocks\n}\n\n// DisconnectedBlocks returns a receive only channel which will be sent upon\n// with the empty filtered blocks of blocks which are disconnected from the\n// main chain in the case of a re-org.\n//\n// NOTE: This is part of the FilteredChainView interface.",
      "length": 279,
      "tokens": 47,
      "embedding": []
    },
    {
      "slug": "func (c *CfFilteredChainView) DisconnectedBlocks() <-chan *FilteredBlock {",
      "content": "func (c *CfFilteredChainView) DisconnectedBlocks() <-chan *FilteredBlock {\n\treturn c.blockQueue.staleBlocks\n}\n\n// GetBlock is used to retrieve the block with the given hash. Since the block\n// cache used by neutrino will be the same as that used by LND (since it is\n// passed to neutrino on initialisation), the neutrino GetBlock method can be\n// called directly since it already uses the block cache. However, neutrino\n// does not lock the block cache mutex for the given block hash and so that is\n// done here.",
      "length": 429,
      "tokens": 79,
      "embedding": []
    },
    {
      "slug": "func (c *CfFilteredChainView) GetBlock(hash chainhash.Hash) (",
      "content": "func (c *CfFilteredChainView) GetBlock(hash chainhash.Hash) (\n\t*btcutil.Block, error) {\n\n\tc.blockCache.HashMutex.Lock(lntypes.Hash(hash))\n\tdefer c.blockCache.HashMutex.Unlock(lntypes.Hash(hash))\n\n\treturn c.p2pNode.GetBlock(hash)\n}\n",
      "length": 162,
      "tokens": 9,
      "embedding": []
    }
  ]
}