{
  "filepath": "../implementations/go/lnd/routing/payment_lifecycle.go",
  "package": "routing",
  "sections": [
    {
      "slug": "type paymentLifecycle struct {",
      "content": "type paymentLifecycle struct {\n\trouter        *ChannelRouter\n\tfeeLimit      lnwire.MilliSatoshi\n\tidentifier    lntypes.Hash\n\tpaySession    PaymentSession\n\tshardTracker  shards.ShardTracker\n\ttimeoutChan   <-chan time.Time\n\tcurrentHeight int32\n}\n\n// payemntState holds a number of key insights learned from a given MPPayment\n// that we use to determine what to do on each payment loop iteration.",
      "length": 352,
      "tokens": 43,
      "embedding": []
    },
    {
      "slug": "type paymentState struct {",
      "content": "type paymentState struct {\n\tnumShardsInFlight int\n\tremainingAmt      lnwire.MilliSatoshi\n\tremainingFees     lnwire.MilliSatoshi\n\n\t// terminate indicates the payment is in its final stage and no more\n\t// shards should be launched. This value is true if we have an HTLC\n\t// settled or the payment has an error.\n\tterminate bool\n}\n\n// terminated returns a bool to indicate there are no further actions needed\n// and we should return what we have, either the payment preimage or the\n// payment error.",
      "length": 456,
      "tokens": 74,
      "embedding": []
    },
    {
      "slug": "func (ps paymentState) terminated() bool {",
      "content": "func (ps paymentState) terminated() bool {\n\t// If the payment is in final stage and we have no in flight shards to\n\t// wait result for, we consider the whole action terminated.\n\treturn ps.terminate && ps.numShardsInFlight == 0\n}\n\n// needWaitForShards returns a bool to specify whether we need to wait for the\n// outcome of the shardHandler.",
      "length": 291,
      "tokens": 52,
      "embedding": []
    },
    {
      "slug": "func (ps paymentState) needWaitForShards() bool {",
      "content": "func (ps paymentState) needWaitForShards() bool {\n\t// If we have in flight shards and the payment is in final stage, we\n\t// need to wait for the outcomes from the shards. Or if we have no more\n\t// money to be sent, we need to wait for the already launched shards.\n\tif ps.numShardsInFlight == 0 {\n\t\treturn false\n\t}\n\treturn ps.terminate || ps.remainingAmt == 0\n}\n\n// fetchPaymentState will query the db for the latest payment state\n// information we need to act on every iteration of the payment loop and update\n// the paymentState.",
      "length": 469,
      "tokens": 89,
      "embedding": []
    },
    {
      "slug": "func (p *paymentLifecycle) fetchPaymentState() (*channeldb.MPPayment,",
      "content": "func (p *paymentLifecycle) fetchPaymentState() (*channeldb.MPPayment,\n\t*paymentState, error) {\n\n\t// Fetch the latest payment from db.\n\tpayment, err := p.router.cfg.Control.FetchPayment(p.identifier)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// Fetch the total amount and fees that has already been sent in\n\t// settled and still in-flight shards.\n\tsentAmt, fees := payment.SentAmt()\n\n\t// Sanity check we haven't sent a value larger than the payment amount.\n\ttotalAmt := payment.Info.Value\n\tif sentAmt > totalAmt {\n\t\treturn nil, nil, fmt.Errorf(\"amount sent %v exceeds \"+\n\t\t\t\"total amount %v\", sentAmt, totalAmt)\n\t}\n\n\t// We'll subtract the used fee from our fee budget, but allow the fees\n\t// of the already sent shards to exceed our budget (can happen after\n\t// restarts).\n\tfeeBudget := p.feeLimit\n\tif fees <= feeBudget {\n\t\tfeeBudget -= fees\n\t} else {\n\t\tfeeBudget = 0\n\t}\n\n\t// Get any terminal info for this payment.\n\tsettle, failure := payment.TerminalInfo()\n\n\t// If either an HTLC settled, or the payment has a payment level\n\t// failure recorded, it means we should terminate the moment all shards\n\t// have returned with a result.\n\tterminate := settle != nil || failure != nil\n\n\t// Update the payment state.\n\tstate := &paymentState{\n\t\tnumShardsInFlight: len(payment.InFlightHTLCs()),\n\t\tremainingAmt:      totalAmt - sentAmt,\n\t\tremainingFees:     feeBudget,\n\t\tterminate:         terminate,\n\t}\n\n\treturn payment, state, nil\n}\n\n// resumePayment resumes the paymentLifecycle from the current state.",
      "length": 1378,
      "tokens": 214,
      "embedding": []
    },
    {
      "slug": "func (p *paymentLifecycle) resumePayment() ([32]byte, *route.Route, error) {",
      "content": "func (p *paymentLifecycle) resumePayment() ([32]byte, *route.Route, error) {\n\tshardHandler := &shardHandler{\n\t\trouter:       p.router,\n\t\tidentifier:   p.identifier,\n\t\tshardTracker: p.shardTracker,\n\t\tshardErrors:  make(chan error),\n\t\tquit:         make(chan struct{}),\n\t\tpaySession:   p.paySession,\n\t}\n\n\t// When the payment lifecycle loop exits, we make sure to signal any\n\t// sub goroutine of the shardHandler to exit, then wait for them to\n\t// return.\n\tdefer shardHandler.stop()\n\n\t// If we had any existing attempts outstanding, we'll start by spinning\n\t// up goroutines that'll collect their results and deliver them to the\n\t// lifecycle loop below.\n\tpayment, _, err := p.fetchPaymentState()\n\tif err != nil {\n\t\treturn [32]byte{}, nil, err\n\t}\n\n\tfor _, a := range payment.InFlightHTLCs() {\n\t\ta := a\n\n\t\tlog.Infof(\"Resuming payment shard %v for payment %v\",\n\t\t\ta.AttemptID, p.identifier)\n\n\t\tshardHandler.collectResultAsync(&a.HTLCAttemptInfo)\n\t}\n\n\t// We'll continue until either our payment succeeds, or we encounter a\n\t// critical error during path finding.\nlifecycle:\n\tfor {\n\t\t// Start by quickly checking if there are any outcomes already\n\t\t// available to handle before we reevaluate our state.\n\t\tif err := shardHandler.checkShards(); err != nil {\n\t\t\treturn [32]byte{}, nil, err\n\t\t}\n\n\t\t// We update the payment state on every iteration. Since the\n\t\t// payment state is affected by multiple goroutines (ie,\n\t\t// collectResultAsync), it is NOT guaranteed that we always\n\t\t// have the latest state here. This is fine as long as the\n\t\t// state is consistent as a whole.\n\t\tpayment, currentState, err := p.fetchPaymentState()\n\t\tif err != nil {\n\t\t\treturn [32]byte{}, nil, err\n\t\t}\n\n\t\tlog.Debugf(\"Payment %v in state terminate=%v, \"+\n\t\t\t\"active_shards=%v, rem_value=%v, fee_limit=%v\",\n\t\t\tp.identifier, currentState.terminate,\n\t\t\tcurrentState.numShardsInFlight,\n\t\t\tcurrentState.remainingAmt, currentState.remainingFees,\n\t\t)\n\n\t\t// TODO(yy): sanity check all the states to make sure\n\t\t// everything is expected.\n\t\tswitch {\n\t\t// We have a terminal condition and no active shards, we are\n\t\t// ready to exit.\n\t\tcase currentState.terminated():\n\t\t\t// Find the first successful shard and return\n\t\t\t// the preimage and route.\n\t\t\tfor _, a := range payment.HTLCs {\n\t\t\t\tif a.Settle == nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\terr := p.router.cfg.Control.DeleteFailedAttempts(\n\t\t\t\t\tp.identifier,\n\t\t\t\t)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Errorf(\"Error deleting failed \"+\n\t\t\t\t\t\t\"payment attempts for \"+\n\t\t\t\t\t\t\"payment %v: %v\", p.identifier,\n\t\t\t\t\t\terr)\n\t\t\t\t}\n\n\t\t\t\treturn a.Settle.Preimage, &a.Route, nil\n\t\t\t}\n\n\t\t\t// Payment failed.\n\t\t\treturn [32]byte{}, nil, *payment.FailureReason\n\n\t\t// If we either reached a terminal error condition (but had\n\t\t// active shards still) or there is no remaining value to send,\n\t\t// we'll wait for a shard outcome.\n\t\tcase currentState.needWaitForShards():\n\t\t\t// We still have outstanding shards, so wait for a new\n\t\t\t// outcome to be available before re-evaluating our\n\t\t\t// state.\n\t\t\tif err := shardHandler.waitForShard(); err != nil {\n\t\t\t\treturn [32]byte{}, nil, err\n\t\t\t}\n\t\t\tcontinue lifecycle\n\t\t}\n\n\t\t// Before we attempt any new shard, we'll check to see if\n\t\t// either we've gone past the payment attempt timeout, or the\n\t\t// router is exiting. In either case, we'll stop this payment\n\t\t// attempt short. If a timeout is not applicable, timeoutChan\n\t\t// will be nil.\n\t\tselect {\n\t\tcase <-p.timeoutChan:\n\t\t\tlog.Warnf(\"payment attempt not completed before \" +\n\t\t\t\t\"timeout\")\n\n\t\t\t// By marking the payment failed with the control\n\t\t\t// tower, no further shards will be launched and we'll\n\t\t\t// return with an error the moment all active shards\n\t\t\t// have finished.\n\t\t\tsaveErr := p.router.cfg.Control.FailPayment(\n\t\t\t\tp.identifier, channeldb.FailureReasonTimeout,\n\t\t\t)\n\t\t\tif saveErr != nil {\n\t\t\t\treturn [32]byte{}, nil, saveErr\n\t\t\t}\n\n\t\t\tcontinue lifecycle\n\n\t\tcase <-p.router.quit:\n\t\t\treturn [32]byte{}, nil, ErrRouterShuttingDown\n\n\t\t// Fall through if we haven't hit our time limit.\n\t\tdefault:\n\t\t}\n\n\t\t// Create a new payment attempt from the given payment session.\n\t\trt, err := p.paySession.RequestRoute(\n\t\t\tcurrentState.remainingAmt, currentState.remainingFees,\n\t\t\tuint32(currentState.numShardsInFlight),\n\t\t\tuint32(p.currentHeight),\n\t\t)\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"Failed to find route for payment %v: %v\",\n\t\t\t\tp.identifier, err)\n\n\t\t\trouteErr, ok := err.(noRouteError)\n\t\t\tif !ok {\n\t\t\t\treturn [32]byte{}, nil, err\n\t\t\t}\n\n\t\t\t// There is no route to try, and we have no active\n\t\t\t// shards. This means that there is no way for us to\n\t\t\t// send the payment, so mark it failed with no route.\n\t\t\tif currentState.numShardsInFlight == 0 {\n\t\t\t\tfailureCode := routeErr.FailureReason()\n\t\t\t\tlog.Debugf(\"Marking payment %v permanently \"+\n\t\t\t\t\t\"failed with no route: %v\",\n\t\t\t\t\tp.identifier, failureCode)\n\n\t\t\t\tsaveErr := p.router.cfg.Control.FailPayment(\n\t\t\t\t\tp.identifier, failureCode,\n\t\t\t\t)\n\t\t\t\tif saveErr != nil {\n\t\t\t\t\treturn [32]byte{}, nil, saveErr\n\t\t\t\t}\n\n\t\t\t\tcontinue lifecycle\n\t\t\t}\n\n\t\t\t// We still have active shards, we'll wait for an\n\t\t\t// outcome to be available before retrying.\n\t\t\tif err := shardHandler.waitForShard(); err != nil {\n\t\t\t\treturn [32]byte{}, nil, err\n\t\t\t}\n\t\t\tcontinue lifecycle\n\t\t}\n\n\t\tlog.Tracef(\"Found route: %s\", spew.Sdump(rt.Hops))\n\n\t\t// If this route will consume the last remaining amount to send\n\t\t// to the receiver, this will be our last shard (for now).\n\t\tlastShard := rt.ReceiverAmt() == currentState.remainingAmt\n\n\t\t// We found a route to try, launch a new shard.\n\t\tattempt, outcome, err := shardHandler.launchShard(rt, lastShard)\n\t\tswitch {\n\t\t// We may get a terminal error if we've processed a shard with\n\t\t// a terminal state (settled or permanent failure), while we\n\t\t// were pathfinding. We know we're in a terminal state here,\n\t\t// so we can continue and wait for our last shards to return.\n\t\tcase err == channeldb.ErrPaymentTerminal:\n\t\t\tlog.Infof(\"Payment %v in terminal state, abandoning \"+\n\t\t\t\t\"shard\", p.identifier)\n\n\t\t\tcontinue lifecycle\n\n\t\tcase err != nil:\n\t\t\treturn [32]byte{}, nil, err\n\t\t}\n\n\t\t// If we encountered a non-critical error when launching the\n\t\t// shard, handle it.\n\t\tif outcome.err != nil {\n\t\t\tlog.Warnf(\"Failed to launch shard %v for \"+\n\t\t\t\t\"payment %v: %v\", attempt.AttemptID,\n\t\t\t\tp.identifier, outcome.err)\n\n\t\t\t// We must inspect the error to know whether it was\n\t\t\t// critical or not, to decide whether we should\n\t\t\t// continue trying.\n\t\t\terr := shardHandler.handleSendError(\n\t\t\t\tattempt, outcome.err,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn [32]byte{}, nil, err\n\t\t\t}\n\n\t\t\t// Error was handled successfully, continue to make a\n\t\t\t// new attempt.\n\t\t\tcontinue lifecycle\n\t\t}\n\n\t\t// Now that the shard was successfully sent, launch a go\n\t\t// routine that will handle its result when its back.\n\t\tshardHandler.collectResultAsync(attempt)\n\t}\n}\n\n// shardHandler holds what is necessary to send and collect the result of\n// shards.",
      "length": 6563,
      "tokens": 941,
      "embedding": []
    },
    {
      "slug": "type shardHandler struct {",
      "content": "type shardHandler struct {\n\tidentifier   lntypes.Hash\n\trouter       *ChannelRouter\n\tshardTracker shards.ShardTracker\n\tpaySession   PaymentSession\n\n\t// shardErrors is a channel where errors collected by calling\n\t// collectResultAsync will be delivered. These results are meant to be\n\t// inspected by calling waitForShard or checkShards, and the channel\n\t// doesn't need to be initiated if the caller is using the sync\n\t// collectResult directly.\n\tshardErrors chan error\n\n\t// quit is closed to signal the sub goroutines of the payment lifecycle\n\t// to stop.\n\tquit chan struct{}\n\twg   sync.WaitGroup\n}\n\n// stop signals any active shard goroutine to exit and waits for them to exit.",
      "length": 633,
      "tokens": 95,
      "embedding": []
    },
    {
      "slug": "func (p *shardHandler) stop() {",
      "content": "func (p *shardHandler) stop() {\n\tclose(p.quit)\n\tp.wg.Wait()\n}\n\n// waitForShard blocks until any of the outstanding shards return.",
      "length": 93,
      "tokens": 13,
      "embedding": []
    },
    {
      "slug": "func (p *shardHandler) waitForShard() error {",
      "content": "func (p *shardHandler) waitForShard() error {\n\tselect {\n\tcase err := <-p.shardErrors:\n\t\treturn err\n\n\tcase <-p.quit:\n\t\treturn errShardHandlerExiting\n\n\tcase <-p.router.quit:\n\t\treturn ErrRouterShuttingDown\n\t}\n}\n\n// checkShards is a non-blocking method that check if any shards has finished\n// their execution.",
      "length": 247,
      "tokens": 34,
      "embedding": []
    },
    {
      "slug": "func (p *shardHandler) checkShards() error {",
      "content": "func (p *shardHandler) checkShards() error {\n\tfor {\n\t\tselect {\n\t\tcase err := <-p.shardErrors:\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase <-p.quit:\n\t\t\treturn errShardHandlerExiting\n\n\t\tcase <-p.router.quit:\n\t\t\treturn ErrRouterShuttingDown\n\n\t\tdefault:\n\t\t\treturn nil\n\t\t}\n\t}\n}\n\n// launchOutcome is a type returned from launchShard that indicates whether the\n// shard was successfully send onto the network.",
      "length": 340,
      "tokens": 50,
      "embedding": []
    },
    {
      "slug": "type launchOutcome struct {",
      "content": "type launchOutcome struct {\n\t// err is non-nil if a non-critical error was encountered when trying\n\t// to send the shard, and we successfully updated the control tower to\n\t// reflect this error. This can be errors like not enough local\n\t// balance for the given route etc.\n\terr error\n\n\t// attempt is the attempt structure as recorded in the database.\n\tattempt *channeldb.HTLCAttempt\n}\n\n// launchShard creates and sends an HTLC attempt along the given route,\n// registering it with the control tower before sending it. The lastShard\n// argument should be true if this shard will consume the remainder of the\n// amount to send. It returns the HTLCAttemptInfo that was created for the\n// shard, along with a launchOutcome.  The launchOutcome is used to indicate\n// whether the attempt was successfully sent. If the launchOutcome wraps a\n// non-nil error, it means that the attempt was not sent onto the network, so\n// no result will be available in the future for it.",
      "length": 919,
      "tokens": 161,
      "embedding": []
    },
    {
      "slug": "func (p *shardHandler) launchShard(rt *route.Route,",
      "content": "func (p *shardHandler) launchShard(rt *route.Route,\n\tlastShard bool) (*channeldb.HTLCAttemptInfo, *launchOutcome, error) {\n\n\t// Using the route received from the payment session, create a new\n\t// shard to send.\n\tfirstHop, htlcAdd, attempt, err := p.createNewPaymentAttempt(\n\t\trt, lastShard,\n\t)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// Before sending this HTLC to the switch, we checkpoint the fresh\n\t// paymentID and route to the DB. This lets us know on startup the ID\n\t// of the payment that we attempted to send, such that we can query the\n\t// Switch for its whereabouts. The route is needed to handle the result\n\t// when it eventually comes back.\n\terr = p.router.cfg.Control.RegisterAttempt(p.identifier, attempt)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// Now that the attempt is created and checkpointed to the DB, we send\n\t// it.\n\tsendErr := p.sendPaymentAttempt(attempt, firstHop, htlcAdd)\n\tif sendErr != nil {\n\t\t// TODO(joostjager): Distinguish unexpected internal errors\n\t\t// from real send errors.\n\t\thtlcAttempt, err := p.failAttempt(attempt, sendErr)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\n\t\t// Return a launchOutcome indicating the shard failed.\n\t\treturn attempt, &launchOutcome{\n\t\t\tattempt: htlcAttempt,\n\t\t\terr:     sendErr,\n\t\t}, nil\n\t}\n\n\treturn attempt, &launchOutcome{}, nil\n}\n\n// shardResult holds the resulting outcome of a shard sent.",
      "length": 1279,
      "tokens": 201,
      "embedding": []
    },
    {
      "slug": "type shardResult struct {",
      "content": "type shardResult struct {\n\t// attempt is the attempt structure as recorded in the database.\n\tattempt *channeldb.HTLCAttempt\n\n\t// err indicates that the shard failed.\n\terr error\n}\n\n// collectResultAsync launches a goroutine that will wait for the result of the\n// given HTLC attempt to be available then handle its result. It will fail the\n// payment with the control tower if a terminal error is encountered.",
      "length": 373,
      "tokens": 63,
      "embedding": []
    },
    {
      "slug": "func (p *shardHandler) collectResultAsync(attempt *channeldb.HTLCAttemptInfo) {",
      "content": "func (p *shardHandler) collectResultAsync(attempt *channeldb.HTLCAttemptInfo) {\n\t// errToSend is the error to be sent to sh.shardErrors.\n\tvar errToSend error\n\n\t// handleResultErr is a function closure must be called using defer. It\n\t// finishes collecting result by updating the payment state and send\n\t// the error (or nil) to sh.shardErrors.\n\thandleResultErr := func() {\n\t\t// Send the error or quit.\n\t\tselect {\n\t\tcase p.shardErrors <- errToSend:\n\t\tcase <-p.router.quit:\n\t\tcase <-p.quit:\n\t\t}\n\n\t\tp.wg.Done()\n\t}\n\n\tp.wg.Add(1)\n\tgo func() {\n\t\tdefer handleResultErr()\n\n\t\t// Block until the result is available.\n\t\tresult, err := p.collectResult(attempt)\n\t\tif err != nil {\n\t\t\tif err != ErrRouterShuttingDown &&\n\t\t\t\terr != htlcswitch.ErrSwitchExiting &&\n\t\t\t\terr != errShardHandlerExiting {\n\n\t\t\t\tlog.Errorf(\"Error collecting result for \"+\n\t\t\t\t\t\"shard %v for payment %v: %v\",\n\t\t\t\t\tattempt.AttemptID, p.identifier, err)\n\t\t\t}\n\n\t\t\t// Overwrite the param errToSend and return so that the\n\t\t\t// defer function will use the param to proceed.\n\t\t\terrToSend = err\n\t\t\treturn\n\t\t}\n\n\t\t// If a non-critical error was encountered handle it and mark\n\t\t// the payment failed if the failure was terminal.\n\t\tif result.err != nil {\n\t\t\t// Overwrite the param errToSend and return so that the\n\t\t\t// defer function will use the param to proceed. Notice\n\t\t\t// that the errToSend could be nil here.\n\t\t\terrToSend = p.handleSendError(attempt, result.err)\n\t\t\treturn\n\t\t}\n\t}()\n}\n\n// collectResult waits for the result for the given attempt to be available\n// from the Switch, then records the attempt outcome with the control tower. A\n// shardResult is returned, indicating the final outcome of this HTLC attempt.",
      "length": 1541,
      "tokens": 240,
      "embedding": []
    },
    {
      "slug": "func (p *shardHandler) collectResult(attempt *channeldb.HTLCAttemptInfo) (",
      "content": "func (p *shardHandler) collectResult(attempt *channeldb.HTLCAttemptInfo) (\n\t*shardResult, error) {\n\n\t// We'll retrieve the hash specific to this shard from the\n\t// shardTracker, since it will be needed to regenerate the circuit\n\t// below.\n\thash, err := p.shardTracker.GetHash(attempt.AttemptID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Regenerate the circuit for this attempt.\n\t_, circuit, err := generateSphinxPacket(\n\t\t&attempt.Route, hash[:], attempt.SessionKey(),\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Using the created circuit, initialize the error decrypter so we can\n\t// parse+decode any failures incurred by this payment within the\n\t// switch.\n\terrorDecryptor := &htlcswitch.SphinxErrorDecrypter{\n\t\tOnionErrorDecrypter: sphinx.NewOnionErrorDecrypter(circuit),\n\t}\n\n\t// Now ask the switch to return the result of the payment when\n\t// available.\n\tresultChan, err := p.router.cfg.Payer.GetAttemptResult(\n\t\tattempt.AttemptID, p.identifier, errorDecryptor,\n\t)\n\tswitch {\n\t// If this attempt ID is unknown to the Switch, it means it was never\n\t// checkpointed and forwarded by the switch before a restart. In this\n\t// case we can safely send a new payment attempt, and wait for its\n\t// result to be available.\n\tcase err == htlcswitch.ErrPaymentIDNotFound:\n\t\tlog.Debugf(\"Attempt ID %v for payment %v not found in \"+\n\t\t\t\"the Switch, retrying.\", attempt.AttemptID,\n\t\t\tp.identifier)\n\n\t\tattempt, cErr := p.failAttempt(attempt, err)\n\t\tif cErr != nil {\n\t\t\treturn nil, cErr\n\t\t}\n\n\t\treturn &shardResult{\n\t\t\tattempt: attempt,\n\t\t\terr:     err,\n\t\t}, nil\n\n\t// A critical, unexpected error was encountered.\n\tcase err != nil:\n\t\tlog.Errorf(\"Failed getting result for attemptID %d \"+\n\t\t\t\"from switch: %v\", attempt.AttemptID, err)\n\n\t\treturn nil, err\n\t}\n\n\t// The switch knows about this payment, we'll wait for a result to be\n\t// available.\n\tvar (\n\t\tresult *htlcswitch.PaymentResult\n\t\tok     bool\n\t)\n\n\tselect {\n\tcase result, ok = <-resultChan:\n\t\tif !ok {\n\t\t\treturn nil, htlcswitch.ErrSwitchExiting\n\t\t}\n\n\tcase <-p.router.quit:\n\t\treturn nil, ErrRouterShuttingDown\n\t}\n\n\t// In case of a payment failure, fail the attempt with the control\n\t// tower and return.\n\tif result.Error != nil {\n\t\tattempt, err := p.failAttempt(attempt, result.Error)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn &shardResult{\n\t\t\tattempt: attempt,\n\t\t\terr:     result.Error,\n\t\t}, nil\n\t}\n\n\t// We successfully got a payment result back from the switch.\n\tlog.Debugf(\"Payment %v succeeded with pid=%v\",\n\t\tp.identifier, attempt.AttemptID)\n\n\t// Report success to mission control.\n\terr = p.router.cfg.MissionControl.ReportPaymentSuccess(\n\t\tattempt.AttemptID, &attempt.Route,\n\t)\n\tif err != nil {\n\t\tlog.Errorf(\"Error reporting payment success to mc: %v\",\n\t\t\terr)\n\t}\n\n\t// In case of success we atomically store settle result to the DB move\n\t// the shard to the settled state.\n\thtlcAttempt, err := p.router.cfg.Control.SettleAttempt(\n\t\tp.identifier, attempt.AttemptID,\n\t\t&channeldb.HTLCSettleInfo{\n\t\t\tPreimage:   result.Preimage,\n\t\t\tSettleTime: p.router.cfg.Clock.Now(),\n\t\t},\n\t)\n\tif err != nil {\n\t\tlog.Errorf(\"Unable to succeed payment attempt: %v\", err)\n\t\treturn nil, err\n\t}\n\n\treturn &shardResult{\n\t\tattempt: htlcAttempt,\n\t}, nil\n}\n\n// createNewPaymentAttempt creates a new payment attempt from the given route.",
      "length": 3069,
      "tokens": 434,
      "embedding": []
    },
    {
      "slug": "func (p *shardHandler) createNewPaymentAttempt(rt *route.Route, lastShard bool) (",
      "content": "func (p *shardHandler) createNewPaymentAttempt(rt *route.Route, lastShard bool) (\n\tlnwire.ShortChannelID, *lnwire.UpdateAddHTLC,\n\t*channeldb.HTLCAttemptInfo, error) {\n\n\t// Generate a new key to be used for this attempt.\n\tsessionKey, err := generateNewSessionKey()\n\tif err != nil {\n\t\treturn lnwire.ShortChannelID{}, nil, nil, err\n\t}\n\n\t// We generate a new, unique payment ID that we will use for\n\t// this HTLC.\n\tattemptID, err := p.router.cfg.NextPaymentID()\n\tif err != nil {\n\t\treturn lnwire.ShortChannelID{}, nil, nil, err\n\t}\n\n\t// Request a new shard from the ShardTracker. If this is an AMP\n\t// payment, and this is the last shard, the outstanding shards together\n\t// with this one will be enough for the receiver to derive all HTLC\n\t// preimages. If this a non-AMP payment, the ShardTracker will return a\n\t// simple shard with the payment's static payment hash.\n\tshard, err := p.shardTracker.NewShard(attemptID, lastShard)\n\tif err != nil {\n\t\treturn lnwire.ShortChannelID{}, nil, nil, err\n\t}\n\n\t// It this shard carries MPP or AMP options, add them to the last hop\n\t// on the route.\n\thop := rt.Hops[len(rt.Hops)-1]\n\tif shard.MPP() != nil {\n\t\thop.MPP = shard.MPP()\n\t}\n\n\tif shard.AMP() != nil {\n\t\thop.AMP = shard.AMP()\n\t}\n\n\t// Generate the raw encoded sphinx packet to be included along\n\t// with the htlcAdd message that we send directly to the\n\t// switch.\n\thash := shard.Hash()\n\tonionBlob, _, err := generateSphinxPacket(rt, hash[:], sessionKey)\n\tif err != nil {\n\t\treturn lnwire.ShortChannelID{}, nil, nil, err\n\t}\n\n\t// Craft an HTLC packet to send to the layer 2 switch. The\n\t// metadata within this packet will be used to route the\n\t// payment through the network, starting with the first-hop.\n\thtlcAdd := &lnwire.UpdateAddHTLC{\n\t\tAmount:      rt.TotalAmount,\n\t\tExpiry:      rt.TotalTimeLock,\n\t\tPaymentHash: hash,\n\t}\n\tcopy(htlcAdd.OnionBlob[:], onionBlob)\n\n\t// Attempt to send this payment through the network to complete\n\t// the payment. If this attempt fails, then we'll continue on\n\t// to the next available route.\n\tfirstHop := lnwire.NewShortChanIDFromInt(\n\t\trt.Hops[0].ChannelID,\n\t)\n\n\t// We now have all the information needed to populate the current\n\t// attempt information.\n\tattempt := channeldb.NewHtlcAttemptInfo(\n\t\tattemptID, sessionKey, *rt, p.router.cfg.Clock.Now(), &hash,\n\t)\n\n\treturn firstHop, htlcAdd, attempt, nil\n}\n\n// sendPaymentAttempt attempts to send the current attempt to the switch.",
      "length": 2252,
      "tokens": 342,
      "embedding": []
    },
    {
      "slug": "func (p *shardHandler) sendPaymentAttempt(",
      "content": "func (p *shardHandler) sendPaymentAttempt(\n\tattempt *channeldb.HTLCAttemptInfo, firstHop lnwire.ShortChannelID,\n\thtlcAdd *lnwire.UpdateAddHTLC) error {\n\n\tlog.Tracef(\"Attempting to send payment %v (pid=%v), \"+\n\t\t\"using route: %v\", p.identifier, attempt.AttemptID,\n\t\tnewLogClosure(func() string {\n\t\t\treturn spew.Sdump(attempt.Route)\n\t\t}),\n\t)\n\n\t// Send it to the Switch. When this method returns we assume\n\t// the Switch successfully has persisted the payment attempt,\n\t// such that we can resume waiting for the result after a\n\t// restart.\n\terr := p.router.cfg.Payer.SendHTLC(\n\t\tfirstHop, attempt.AttemptID, htlcAdd,\n\t)\n\tif err != nil {\n\t\tlog.Errorf(\"Failed sending attempt %d for payment \"+\n\t\t\t\"%v to switch: %v\", attempt.AttemptID,\n\t\t\tp.identifier, err)\n\t\treturn err\n\t}\n\n\tlog.Debugf(\"Payment %v (pid=%v) successfully sent to switch, route: %v\",\n\t\tp.identifier, attempt.AttemptID, &attempt.Route)\n\n\treturn nil\n}\n\n// handleSendError inspects the given error from the Switch and determines\n// whether we should make another payment attempt, or if it should be\n// considered a terminal error. Terminal errors will be recorded with the\n// control tower. It analyzes the sendErr for the payment attempt received from\n// the switch and updates mission control and/or channel policies. Depending on\n// the error type, the error is either the final outcome of the payment or we\n// need to continue with an alternative route. A final outcome is indicated by\n// a non-nil reason value.",
      "length": 1394,
      "tokens": 202,
      "embedding": []
    },
    {
      "slug": "func (p *shardHandler) handleSendError(attempt *channeldb.HTLCAttemptInfo,",
      "content": "func (p *shardHandler) handleSendError(attempt *channeldb.HTLCAttemptInfo,\n\tsendErr error) error {\n\n\tinternalErrorReason := channeldb.FailureReasonError\n\n\t// failPayment is a helper closure that fails the payment via the\n\t// router's control tower, which marks the payment as failed in db.\n\tfailPayment := func(reason *channeldb.FailureReason,\n\t\tsendErr error) error {\n\n\t\tlog.Infof(\"Payment %v failed: final_outcome=%v, raw_err=%v\",\n\t\t\tp.identifier, *reason, sendErr)\n\n\t\t// Fail the payment via control tower.\n\t\tif err := p.router.cfg.Control.FailPayment(\n\t\t\tp.identifier, *reason,\n\t\t); err != nil {\n\t\t\tlog.Errorf(\"unable to report failure to control \"+\n\t\t\t\t\"tower: %v\", err)\n\n\t\t\treturn &internalErrorReason\n\t\t}\n\n\t\treturn reason\n\t}\n\n\t// reportFail is a helper closure that reports the failure to the\n\t// mission control, which helps us to decide whether we want to retry\n\t// the payment or not. If a non nil reason is returned from mission\n\t// control, it will further fail the payment via control tower.\n\treportFail := func(srcIdx *int, msg lnwire.FailureMessage) error {\n\t\t// Report outcome to mission control.\n\t\treason, err := p.router.cfg.MissionControl.ReportPaymentFail(\n\t\t\tattempt.AttemptID, &attempt.Route, srcIdx, msg,\n\t\t)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Error reporting payment result to mc: %v\",\n\t\t\t\terr)\n\n\t\t\treason = &internalErrorReason\n\t\t}\n\n\t\t// Exit early if there's no reason.\n\t\tif reason == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn failPayment(reason, sendErr)\n\t}\n\n\tif sendErr == htlcswitch.ErrUnreadableFailureMessage {\n\t\tlog.Tracef(\"Unreadable failure when sending htlc\")\n\n\t\treturn reportFail(nil, nil)\n\t}\n\n\t// If the error is a ClearTextError, we have received a valid wire\n\t// failure message, either from our own outgoing link or from a node\n\t// down the route. If the error is not related to the propagation of\n\t// our payment, we can stop trying because an internal error has\n\t// occurred.\n\trtErr, ok := sendErr.(htlcswitch.ClearTextError)\n\tif !ok {\n\t\treturn failPayment(&internalErrorReason, sendErr)\n\t}\n\n\t// failureSourceIdx is the index of the node that the failure occurred\n\t// at. If the ClearTextError received is not a ForwardingError the\n\t// payment error occurred at our node, so we leave this value as 0\n\t// to indicate that the failure occurred locally. If the error is a\n\t// ForwardingError, it did not originate at our node, so we set\n\t// failureSourceIdx to the index of the node where the failure occurred.\n\tfailureSourceIdx := 0\n\tsource, ok := rtErr.(*htlcswitch.ForwardingError)\n\tif ok {\n\t\tfailureSourceIdx = source.FailureSourceIdx\n\t}\n\n\t// Extract the wire failure and apply channel update if it contains one.\n\t// If we received an unknown failure message from a node along the\n\t// route, the failure message will be nil.\n\tfailureMessage := rtErr.WireMessage()\n\terr := p.handleFailureMessage(\n\t\t&attempt.Route, failureSourceIdx, failureMessage,\n\t)\n\tif err != nil {\n\t\treturn failPayment(&internalErrorReason, sendErr)\n\t}\n\n\tlog.Tracef(\"Node=%v reported failure when sending htlc\",\n\t\tfailureSourceIdx)\n\n\treturn reportFail(&failureSourceIdx, failureMessage)\n}\n\n// handleFailureMessage tries to apply a channel update present in the failure\n// message if any.",
      "length": 3020,
      "tokens": 437,
      "embedding": []
    },
    {
      "slug": "func (p *shardHandler) handleFailureMessage(rt *route.Route,",
      "content": "func (p *shardHandler) handleFailureMessage(rt *route.Route,\n\terrorSourceIdx int, failure lnwire.FailureMessage) error {\n\n\tif failure == nil {\n\t\treturn nil\n\t}\n\n\t// It makes no sense to apply our own channel updates.\n\tif errorSourceIdx == 0 {\n\t\tlog.Errorf(\"Channel update of ourselves received\")\n\n\t\treturn nil\n\t}\n\n\t// Extract channel update if the error contains one.\n\tupdate := p.router.extractChannelUpdate(failure)\n\tif update == nil {\n\t\treturn nil\n\t}\n\n\t// Parse pubkey to allow validation of the channel update. This should\n\t// always succeed, otherwise there is something wrong in our\n\t// implementation. Therefore return an error.\n\terrVertex := rt.Hops[errorSourceIdx-1].PubKeyBytes\n\terrSource, err := btcec.ParsePubKey(errVertex[:])\n\tif err != nil {\n\t\tlog.Errorf(\"Cannot parse pubkey: idx=%v, pubkey=%v\",\n\t\t\terrorSourceIdx, errVertex)\n\n\t\treturn err\n\t}\n\n\tvar (\n\t\tisAdditionalEdge bool\n\t\tpolicy           *channeldb.CachedEdgePolicy\n\t)\n\n\t// Before we apply the channel update, we need to decide whether the\n\t// update is for additional (ephemeral) edge or normal edge stored in\n\t// db.\n\t//\n\t// Note: the p.paySession might be nil here if it's called inside\n\t// SendToRoute where there's no payment lifecycle.\n\tif p.paySession != nil {\n\t\tpolicy = p.paySession.GetAdditionalEdgePolicy(\n\t\t\terrSource, update.ShortChannelID.ToUint64(),\n\t\t)\n\t\tif policy != nil {\n\t\t\tisAdditionalEdge = true\n\t\t}\n\t}\n\n\t// Apply channel update to additional edge policy.\n\tif isAdditionalEdge {\n\t\tif !p.paySession.UpdateAdditionalEdge(\n\t\t\tupdate, errSource, policy) {\n\n\t\t\tlog.Debugf(\"Invalid channel update received: node=%v\",\n\t\t\t\terrVertex)\n\t\t}\n\t\treturn nil\n\t}\n\n\t// Apply channel update to the channel edge policy in our db.\n\tif !p.router.applyChannelUpdate(update) {\n\t\tlog.Debugf(\"Invalid channel update received: node=%v\",\n\t\t\terrVertex)\n\t}\n\treturn nil\n}\n\n// failAttempt calls control tower to fail the current payment attempt.",
      "length": 1773,
      "tokens": 246,
      "embedding": []
    },
    {
      "slug": "func (p *shardHandler) failAttempt(attempt *channeldb.HTLCAttemptInfo,",
      "content": "func (p *shardHandler) failAttempt(attempt *channeldb.HTLCAttemptInfo,\n\tsendError error) (*channeldb.HTLCAttempt, error) {\n\n\tlog.Warnf(\"Attempt %v for payment %v failed: %v\", attempt.AttemptID,\n\t\tp.identifier, sendError)\n\n\tfailInfo := marshallError(\n\t\tsendError,\n\t\tp.router.cfg.Clock.Now(),\n\t)\n\n\t// Now that we are failing this payment attempt, cancel the shard with\n\t// the ShardTracker such that it can derive the correct hash for the\n\t// next attempt.\n\tif err := p.shardTracker.CancelShard(attempt.AttemptID); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn p.router.cfg.Control.FailAttempt(\n\t\tp.identifier, attempt.AttemptID,\n\t\tfailInfo,\n\t)\n}\n\n// marshallError marshall an error as received from the switch to a structure\n// that is suitable for database storage.",
      "length": 667,
      "tokens": 89,
      "embedding": []
    },
    {
      "slug": "func marshallError(sendError error, time time.Time) *channeldb.HTLCFailInfo {",
      "content": "func marshallError(sendError error, time time.Time) *channeldb.HTLCFailInfo {\n\tresponse := &channeldb.HTLCFailInfo{\n\t\tFailTime: time,\n\t}\n\n\tswitch sendError {\n\tcase htlcswitch.ErrPaymentIDNotFound:\n\t\tresponse.Reason = channeldb.HTLCFailInternal\n\t\treturn response\n\n\tcase htlcswitch.ErrUnreadableFailureMessage:\n\t\tresponse.Reason = channeldb.HTLCFailUnreadable\n\t\treturn response\n\t}\n\n\trtErr, ok := sendError.(htlcswitch.ClearTextError)\n\tif !ok {\n\t\tresponse.Reason = channeldb.HTLCFailInternal\n\t\treturn response\n\t}\n\n\tmessage := rtErr.WireMessage()\n\tif message != nil {\n\t\tresponse.Reason = channeldb.HTLCFailMessage\n\t\tresponse.Message = message\n\t} else {\n\t\tresponse.Reason = channeldb.HTLCFailUnknown\n\t}\n\n\t// If the ClearTextError received is a ForwardingError, the error\n\t// originated from a node along the route, not locally on our outgoing\n\t// link. We set failureSourceIdx to the index of the node where the\n\t// failure occurred. If the error is not a ForwardingError, the failure\n\t// occurred at our node, so we leave the index as 0 to indicate that\n\t// we failed locally.\n\tfErr, ok := rtErr.(*htlcswitch.ForwardingError)\n\tif ok {\n\t\tresponse.FailureSourceIndex = uint32(fErr.FailureSourceIdx)\n\t}\n\n\treturn response\n}\n",
      "length": 1097,
      "tokens": 139,
      "embedding": []
    }
  ]
}