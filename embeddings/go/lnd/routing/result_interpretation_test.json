{
  "filepath": "../implementations/go/lnd/routing/result_interpretation_test.go",
  "package": "routing",
  "sections": [
    {
      "slug": "func getTestPair(from, to int) DirectedNodePair {",
      "content": "func getTestPair(from, to int) DirectedNodePair {\n\treturn NewDirectedNodePair(hops[from], hops[to])\n}\n",
      "length": 50,
      "tokens": 4,
      "embedding": []
    },
    {
      "slug": "func getPolicyFailure(from, to int) *DirectedNodePair {",
      "content": "func getPolicyFailure(from, to int) *DirectedNodePair {\n\tpair := getTestPair(from, to)\n\treturn &pair\n}\n",
      "length": 44,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "type resultTestCase struct {",
      "content": "type resultTestCase struct {\n\tname          string\n\troute         *route.Route\n\tsuccess       bool\n\tfailureSrcIdx int\n\tfailure       lnwire.FailureMessage\n\n\texpectedResult *interpretedResult\n}\n\nvar resultTestCases = []resultTestCase{\n\t// Tests that a temporary channel failure result is properly\n\t// interpreted.\n\t{\n\t\tname:          \"fail\",\n\t\troute:         &routeTwoHop,\n\t\tfailureSrcIdx: 1,\n\t\tfailure:       lnwire.NewTemporaryChannelFailure(nil),\n\n\t\texpectedResult: &interpretedResult{\n\t\t\tpairResults: map[DirectedNodePair]pairResult{\n\t\t\t\tgetTestPair(0, 1): successPairResult(100),\n\t\t\t\tgetTestPair(1, 2): failPairResult(99),\n\t\t\t},\n\t\t},\n\t},\n\n\t// Tests that a expiry too soon failure result is properly interpreted.\n\t{\n\t\tname:          \"fail expiry too soon\",\n\t\troute:         &routeFourHop,\n\t\tfailureSrcIdx: 3,\n\t\tfailure:       lnwire.NewExpiryTooSoon(lnwire.ChannelUpdate{}),\n\n\t\texpectedResult: &interpretedResult{\n\t\t\tpairResults: map[DirectedNodePair]pairResult{\n\t\t\t\tgetTestPair(0, 1): failPairResult(0),\n\t\t\t\tgetTestPair(1, 0): failPairResult(0),\n\t\t\t\tgetTestPair(1, 2): failPairResult(0),\n\t\t\t\tgetTestPair(2, 1): failPairResult(0),\n\t\t\t\tgetTestPair(2, 3): failPairResult(0),\n\t\t\t\tgetTestPair(3, 2): failPairResult(0),\n\t\t\t},\n\t\t},\n\t},\n\n\t// Tests an incorrect payment details result. This should be a final\n\t// failure, but mark all pairs along the route as successful.\n\t{\n\t\tname:          \"fail incorrect details\",\n\t\troute:         &routeTwoHop,\n\t\tfailureSrcIdx: 2,\n\t\tfailure:       lnwire.NewFailIncorrectDetails(97, 0),\n\n\t\texpectedResult: &interpretedResult{\n\t\t\tpairResults: map[DirectedNodePair]pairResult{\n\t\t\t\tgetTestPair(0, 1): successPairResult(100),\n\t\t\t\tgetTestPair(1, 2): successPairResult(99),\n\t\t\t},\n\t\t\tfinalFailureReason: &reasonIncorrectDetails,\n\t\t},\n\t},\n\n\t// Tests a successful direct payment.\n\t{\n\t\tname:    \"success direct\",\n\t\troute:   &routeOneHop,\n\t\tsuccess: true,\n\n\t\texpectedResult: &interpretedResult{\n\t\t\tpairResults: map[DirectedNodePair]pairResult{\n\t\t\t\tgetTestPair(0, 1): successPairResult(100),\n\t\t\t},\n\t\t},\n\t},\n\n\t// Tests a successful two hop payment.\n\t{\n\t\tname:    \"success\",\n\t\troute:   &routeTwoHop,\n\t\tsuccess: true,\n\n\t\texpectedResult: &interpretedResult{\n\t\t\tpairResults: map[DirectedNodePair]pairResult{\n\t\t\t\tgetTestPair(0, 1): successPairResult(100),\n\t\t\t\tgetTestPair(1, 2): successPairResult(99),\n\t\t\t},\n\t\t},\n\t},\n\n\t// Tests a malformed htlc from a direct peer.\n\t{\n\t\tname:          \"fail malformed htlc from direct peer\",\n\t\troute:         &routeTwoHop,\n\t\tfailureSrcIdx: 0,\n\t\tfailure:       lnwire.NewInvalidOnionKey(nil),\n\n\t\texpectedResult: &interpretedResult{\n\t\t\tnodeFailure: &hops[1],\n\t\t\tpairResults: map[DirectedNodePair]pairResult{\n\t\t\t\tgetTestPair(1, 0): failPairResult(0),\n\t\t\t\tgetTestPair(1, 2): failPairResult(0),\n\t\t\t\tgetTestPair(0, 1): failPairResult(0),\n\t\t\t\tgetTestPair(2, 1): failPairResult(0),\n\t\t\t},\n\t\t},\n\t},\n\n\t// Tests a malformed htlc from a direct peer that is also the final\n\t// destination.\n\t{\n\t\tname:          \"fail malformed htlc from direct final peer\",\n\t\troute:         &routeOneHop,\n\t\tfailureSrcIdx: 0,\n\t\tfailure:       lnwire.NewInvalidOnionKey(nil),\n\n\t\texpectedResult: &interpretedResult{\n\t\t\tfinalFailureReason: &reasonError,\n\t\t\tnodeFailure:        &hops[1],\n\t\t\tpairResults: map[DirectedNodePair]pairResult{\n\t\t\t\tgetTestPair(1, 0): failPairResult(0),\n\t\t\t\tgetTestPair(0, 1): failPairResult(0),\n\t\t\t},\n\t\t},\n\t},\n\n\t// Tests that a fee insufficient failure to an intermediate hop with\n\t// index 2 results in the first hop marked as success, and then a\n\t// bidirectional failure for the incoming channel. It should also result\n\t// in a policy failure for the outgoing hop.\n\t{\n\t\tname:          \"fail fee insufficient intermediate\",\n\t\troute:         &routeFourHop,\n\t\tfailureSrcIdx: 2,\n\t\tfailure:       lnwire.NewFeeInsufficient(0, lnwire.ChannelUpdate{}),\n\n\t\texpectedResult: &interpretedResult{\n\t\t\tpairResults: map[DirectedNodePair]pairResult{\n\t\t\t\tgetTestPair(0, 1): {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tamt:     100,\n\t\t\t\t},\n\t\t\t\tgetTestPair(1, 2): {},\n\t\t\t\tgetTestPair(2, 1): {},\n\t\t\t},\n\t\t\tpolicyFailure: getPolicyFailure(2, 3),\n\t\t},\n\t},\n\n\t// Tests an invalid onion payload from a final hop. The final hop should\n\t// be failed while the proceeding hops are reproed as successes. The\n\t// failure is terminal since the receiver can't process our onion.\n\t{\n\t\tname:          \"fail invalid onion payload final hop four\",\n\t\troute:         &routeFourHop,\n\t\tfailureSrcIdx: 4,\n\t\tfailure:       lnwire.NewInvalidOnionPayload(0, 0),\n\n\t\texpectedResult: &interpretedResult{\n\t\t\tpairResults: map[DirectedNodePair]pairResult{\n\t\t\t\tgetTestPair(0, 1): {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tamt:     100,\n\t\t\t\t},\n\t\t\t\tgetTestPair(1, 2): {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tamt:     99,\n\t\t\t\t},\n\t\t\t\tgetTestPair(2, 3): {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tamt:     97,\n\t\t\t\t},\n\t\t\t\tgetTestPair(4, 3): {},\n\t\t\t\tgetTestPair(3, 4): {},\n\t\t\t},\n\t\t\tfinalFailureReason: &reasonError,\n\t\t\tnodeFailure:        &hops[4],\n\t\t},\n\t},\n\n\t// Tests an invalid onion payload from a final hop on a three hop route.\n\t{\n\t\tname:          \"fail invalid onion payload final hop three\",\n\t\troute:         &routeThreeHop,\n\t\tfailureSrcIdx: 3,\n\t\tfailure:       lnwire.NewInvalidOnionPayload(0, 0),\n\n\t\texpectedResult: &interpretedResult{\n\t\t\tpairResults: map[DirectedNodePair]pairResult{\n\t\t\t\tgetTestPair(0, 1): {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tamt:     100,\n\t\t\t\t},\n\t\t\t\tgetTestPair(1, 2): {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tamt:     99,\n\t\t\t\t},\n\t\t\t\tgetTestPair(3, 2): {},\n\t\t\t\tgetTestPair(2, 3): {},\n\t\t\t},\n\t\t\tfinalFailureReason: &reasonError,\n\t\t\tnodeFailure:        &hops[3],\n\t\t},\n\t},\n\n\t// Tests an invalid onion payload from an intermediate hop. Only the\n\t// reporting node should be failed. The failure is non-terminal since we\n\t// can still try other paths.\n\t{\n\t\tname:          \"fail invalid onion payload intermediate\",\n\t\troute:         &routeFourHop,\n\t\tfailureSrcIdx: 3,\n\t\tfailure:       lnwire.NewInvalidOnionPayload(0, 0),\n\n\t\texpectedResult: &interpretedResult{\n\t\t\tpairResults: map[DirectedNodePair]pairResult{\n\t\t\t\tgetTestPair(0, 1): {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tamt:     100,\n\t\t\t\t},\n\t\t\t\tgetTestPair(1, 2): {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tamt:     99,\n\t\t\t\t},\n\t\t\t\tgetTestPair(3, 2): {},\n\t\t\t\tgetTestPair(3, 4): {},\n\t\t\t\tgetTestPair(2, 3): {},\n\t\t\t\tgetTestPair(4, 3): {},\n\t\t\t},\n\t\t\tnodeFailure: &hops[3],\n\t\t},\n\t},\n\n\t// Tests an invalid onion payload in a direct peer that is also the\n\t// final hop. The final node should be failed and the error is terminal\n\t// since the remote node can't process our onion.\n\t{\n\t\tname:          \"fail invalid onion payload direct\",\n\t\troute:         &routeOneHop,\n\t\tfailureSrcIdx: 1,\n\t\tfailure:       lnwire.NewInvalidOnionPayload(0, 0),\n\n\t\texpectedResult: &interpretedResult{\n\t\t\tpairResults: map[DirectedNodePair]pairResult{\n\t\t\t\tgetTestPair(1, 0): {},\n\t\t\t\tgetTestPair(0, 1): {},\n\t\t\t},\n\t\t\tfinalFailureReason: &reasonError,\n\t\t\tnodeFailure:        &hops[1],\n\t\t},\n\t},\n\n\t// Tests a single hop mpp timeout. Test that final node is not\n\t// penalized. This is a temporary measure while we decide how to\n\t// penalize mpp timeouts.\n\t{\n\t\tname:          \"one hop mpp timeout\",\n\t\troute:         &routeOneHop,\n\t\tfailureSrcIdx: 1,\n\t\tfailure:       &lnwire.FailMPPTimeout{},\n\n\t\texpectedResult: &interpretedResult{\n\t\t\tpairResults: map[DirectedNodePair]pairResult{\n\t\t\t\tgetTestPair(0, 1): successPairResult(100),\n\t\t\t},\n\t\t\tnodeFailure: nil,\n\t\t},\n\t},\n\n\t// Tests a two hop mpp timeout. Test that final node is not penalized\n\t// and the intermediate hop is attributed the success. This is a\n\t// temporary measure while we decide how to penalize mpp timeouts.\n\t{\n\t\tname:          \"two hop mpp timeout\",\n\t\troute:         &routeTwoHop,\n\t\tfailureSrcIdx: 2,\n\t\tfailure:       &lnwire.FailMPPTimeout{},\n\n\t\texpectedResult: &interpretedResult{\n\t\t\tpairResults: map[DirectedNodePair]pairResult{\n\t\t\t\tgetTestPair(0, 1): successPairResult(100),\n\t\t\t\tgetTestPair(1, 2): successPairResult(99),\n\t\t\t},\n\t\t\tnodeFailure: nil,\n\t\t},\n\t},\n\n\t// Test a channel disabled failure from the final hop in two hops. Only the\n\t// disabled channel should be penalized for any amount.\n\t{\n\t\tname:          \"two hop channel disabled\",\n\t\troute:         &routeTwoHop,\n\t\tfailureSrcIdx: 1,\n\t\tfailure:       &lnwire.FailChannelDisabled{},\n\n\t\texpectedResult: &interpretedResult{\n\t\t\tpairResults: map[DirectedNodePair]pairResult{\n\t\t\t\tgetTestPair(1, 2): failPairResult(0),\n\t\t\t\tgetTestPair(2, 1): failPairResult(0),\n\t\t\t\tgetTestPair(0, 1): successPairResult(100),\n\t\t\t},\n\t\t\tpolicyFailure: getPolicyFailure(1, 2),\n\t\t},\n\t},\n}\n\n// TestResultInterpretation executes a list of test cases that test the result\n// interpretation logic.",
      "length": 8155,
      "tokens": 871,
      "embedding": []
    },
    {
      "slug": "func TestResultInterpretation(t *testing.T) {",
      "content": "func TestResultInterpretation(t *testing.T) {\n\temptyResults := make(map[DirectedNodePair]pairResult)\n\n\tfor _, testCase := range resultTestCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\ti := interpretResult(\n\t\t\t\ttestCase.route, testCase.success,\n\t\t\t\t&testCase.failureSrcIdx, testCase.failure,\n\t\t\t)\n\n\t\t\texpected := testCase.expectedResult\n\n\t\t\t// Replace nil pairResults with empty map to satisfy\n\t\t\t// DeepEqual.\n\t\t\tif expected.pairResults == nil {\n\t\t\t\texpected.pairResults = emptyResults\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(i, expected) {\n\t\t\t\tt.Fatalf(\"unexpected result\\nwant: %v\\ngot: %v\",\n\t\t\t\t\tspew.Sdump(expected), spew.Sdump(i))\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "length": 581,
      "tokens": 59,
      "embedding": []
    }
  ]
}