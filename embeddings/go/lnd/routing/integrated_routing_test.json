{
  "filepath": "../implementations/go/lnd/routing/integrated_routing_test.go",
  "package": "routing",
  "sections": [
    {
      "slug": "func TestProbabilityExtrapolation(t *testing.T) {",
      "content": "func TestProbabilityExtrapolation(t *testing.T) {\n\tctx := newIntegratedRoutingContext(t)\n\n\t// Create the following network of nodes:\n\t// source -> expensiveNode (charges routing fee) -> target\n\t// source -> intermediate1 (free routing) -> intermediate(1-10) (free routing) -> target\n\tg := ctx.graph\n\n\tconst expensiveNodeID = 3\n\texpensiveNode := newMockNode(expensiveNodeID)\n\texpensiveNode.baseFee = 10000\n\tg.addNode(expensiveNode)\n\n\tg.addChannel(100, sourceNodeID, expensiveNodeID, 100000)\n\tg.addChannel(101, targetNodeID, expensiveNodeID, 100000)\n\n\tconst intermediate1NodeID = 4\n\tintermediate1 := newMockNode(intermediate1NodeID)\n\tg.addNode(intermediate1)\n\tg.addChannel(102, sourceNodeID, intermediate1NodeID, 100000)\n\n\tfor i := 0; i < 10; i++ {\n\t\timNodeID := byte(10 + i)\n\t\timNode := newMockNode(imNodeID)\n\t\tg.addNode(imNode)\n\t\tg.addChannel(uint64(200+i), imNodeID, targetNodeID, 100000)\n\t\tg.addChannel(uint64(300+i), imNodeID, intermediate1NodeID, 100000)\n\n\t\t// The channels from intermediate1 all have insufficient balance.\n\t\tg.nodes[intermediate1.pubkey].channels[imNode.pubkey].balance = 0\n\t}\n\n\t// It is expected that pathfinding will try to explore the routes via\n\t// intermediate1 first, because those are free. But as failures happen,\n\t// the node probability of intermediate1 will go down in favor of the\n\t// paid route via expensiveNode.\n\t//\n\t// The exact number of attempts required is dependent on mission control\n\t// config. For this test, it would have been enough to only assert that\n\t// we are not trying all routes via intermediate1. However, we do assert\n\t// a specific number of attempts to safe-guard against accidental\n\t// modifications anywhere in the chain of components that is involved in\n\t// this test.\n\tattempts, err := ctx.testPayment(1)\n\trequire.NoError(t, err, \"payment failed\")\n\tif len(attempts) != 5 {\n\t\tt.Fatalf(\"expected 5 attempts, but needed %v\", len(attempts))\n\t}\n\n\t// If we use a static value for the node probability (no extrapolation\n\t// of data from other channels), all ten bad channels will be tried\n\t// first before switching to the paid channel.\n\testimator, ok := ctx.mcCfg.Estimator.(*AprioriEstimator)\n\tif ok {\n\t\testimator.AprioriWeight = 1\n\t}\n\tattempts, err = ctx.testPayment(1)\n\trequire.NoError(t, err, \"payment failed\")\n\tif len(attempts) != 11 {\n\t\tt.Fatalf(\"expected 11 attempts, but needed %v\", len(attempts))\n\t}\n}\n",
      "length": 2256,
      "tokens": 299,
      "embedding": []
    },
    {
      "slug": "type mppSendTestCase struct {",
      "content": "type mppSendTestCase struct {\n\tname             string\n\tamt              btcutil.Amount\n\texpectedAttempts int\n\n\t// expectedSuccesses is a list of htlcs that made it to the receiver,\n\t// regardless of whether the final set became complete or not.\n\texpectedSuccesses []expectedHtlcSuccess\n\n\tgraph           func(g *mockGraph)\n\texpectedFailure bool\n\tmaxParts        uint32\n\tmaxShardSize    btcutil.Amount\n}\n\nconst (\n\tchanSourceIm1 = 13\n\tchanIm1Target = 32\n\tchanSourceIm2 = 14\n\tchanIm2Target = 42\n)\n",
      "length": 445,
      "tokens": 57,
      "embedding": []
    },
    {
      "slug": "func onePathGraph(g *mockGraph) {",
      "content": "func onePathGraph(g *mockGraph) {\n\t// Create the following network of nodes:\n\t// source -> intermediate1 -> target\n\n\tconst im1NodeID = 3\n\tintermediate1 := newMockNode(im1NodeID)\n\tg.addNode(intermediate1)\n\n\tg.addChannel(chanSourceIm1, sourceNodeID, im1NodeID, 200000)\n\tg.addChannel(chanIm1Target, targetNodeID, im1NodeID, 100000)\n}\n",
      "length": 287,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func twoPathGraph(g *mockGraph, capacityOut, capacityIn btcutil.Amount) {",
      "content": "func twoPathGraph(g *mockGraph, capacityOut, capacityIn btcutil.Amount) {\n\t// Create the following network of nodes:\n\t// source -> intermediate1 -> target\n\t// source -> intermediate2 -> target\n\n\tconst im1NodeID = 3\n\tintermediate1 := newMockNode(im1NodeID)\n\tg.addNode(intermediate1)\n\n\tconst im2NodeID = 4\n\tintermediate2 := newMockNode(im2NodeID)\n\tg.addNode(intermediate2)\n\n\tg.addChannel(chanSourceIm1, sourceNodeID, im1NodeID, capacityOut)\n\tg.addChannel(chanSourceIm2, sourceNodeID, im2NodeID, capacityOut)\n\tg.addChannel(chanIm1Target, targetNodeID, im1NodeID, capacityIn)\n\tg.addChannel(chanIm2Target, targetNodeID, im2NodeID, capacityIn)\n}\n\nvar mppTestCases = []mppSendTestCase{\n\t// Test a two-path graph with sufficient liquidity. It is expected that\n\t// pathfinding will try first try to send the full amount via the two\n\t// available routes. When that fails, it will half the amount to 35k sat\n\t// and retry. That attempt reaches the target successfully. Then the\n\t// same route is tried again. Because the channel only had 50k sat, it\n\t// will fail. Finally the second route is tried for 35k and it succeeds\n\t// too. Mpp payment complete.\n\t{\n\n\t\tname: \"sufficient inbound\",\n\t\tgraph: func(g *mockGraph) {\n\t\t\ttwoPathGraph(g, 200000, 100000)\n\t\t},\n\t\tamt:              70000,\n\t\texpectedAttempts: 5,\n\t\texpectedSuccesses: []expectedHtlcSuccess{\n\t\t\t{\n\t\t\t\tamt:   35000,\n\t\t\t\tchans: []uint64{chanSourceIm1, chanIm1Target},\n\t\t\t},\n\t\t\t{\n\t\t\t\tamt:   35000,\n\t\t\t\tchans: []uint64{chanSourceIm2, chanIm2Target},\n\t\t\t},\n\t\t},\n\t\tmaxParts: 1000,\n\t},\n\n\t// Test that a cap on the max htlcs makes it impossible to pay.\n\t{\n\t\tname: \"no splitting\",\n\t\tgraph: func(g *mockGraph) {\n\t\t\ttwoPathGraph(g, 200000, 100000)\n\t\t},\n\t\tamt:               70000,\n\t\texpectedAttempts:  2,\n\t\texpectedSuccesses: []expectedHtlcSuccess{},\n\t\texpectedFailure:   true,\n\t\tmaxParts:          1,\n\t},\n\n\t// Test that an attempt is made to split the payment in multiple parts\n\t// that all use the same route if the full amount cannot be sent in a\n\t// single htlc. The sender is effectively probing the receiver's\n\t// incoming channel to see if it has sufficient balance. In this test\n\t// case, the endeavour fails.\n\t{\n\n\t\tname:             \"one path split\",\n\t\tgraph:            onePathGraph,\n\t\tamt:              70000,\n\t\texpectedAttempts: 7,\n\t\texpectedSuccesses: []expectedHtlcSuccess{\n\t\t\t{\n\t\t\t\tamt:   35000,\n\t\t\t\tchans: []uint64{chanSourceIm1, chanIm1Target},\n\t\t\t},\n\t\t\t{\n\t\t\t\tamt:   8750,\n\t\t\t\tchans: []uint64{chanSourceIm1, chanIm1Target},\n\t\t\t},\n\t\t},\n\t\texpectedFailure: true,\n\t\tmaxParts:        1000,\n\t},\n\n\t// Test that no attempts are made if the total local balance is\n\t// insufficient.\n\t{\n\t\tname: \"insufficient total balance\",\n\t\tgraph: func(g *mockGraph) {\n\t\t\ttwoPathGraph(g, 100000, 500000)\n\t\t},\n\t\tamt:              300000,\n\t\texpectedAttempts: 0,\n\t\texpectedFailure:  true,\n\t\tmaxParts:         10,\n\t},\n\n\t// Test that if maxShardSize is set, then all attempts are below the\n\t// max shard size, yet still sum up to the total payment amount. A\n\t// payment of 30k satoshis with a max shard size of 10k satoshis should\n\t// produce 3 payments of 10k sats each.\n\t{\n\t\tname:             \"max shard size clamping\",\n\t\tgraph:            onePathGraph,\n\t\tamt:              30_000,\n\t\texpectedAttempts: 3,\n\t\texpectedSuccesses: []expectedHtlcSuccess{\n\t\t\t{\n\t\t\t\tamt:   10_000,\n\t\t\t\tchans: []uint64{chanSourceIm1, chanIm1Target},\n\t\t\t},\n\t\t\t{\n\t\t\t\tamt:   10_000,\n\t\t\t\tchans: []uint64{chanSourceIm1, chanIm1Target},\n\t\t\t},\n\t\t\t{\n\t\t\t\tamt:   10_000,\n\t\t\t\tchans: []uint64{chanSourceIm1, chanIm1Target},\n\t\t\t},\n\t\t},\n\t\tmaxParts:     1000,\n\t\tmaxShardSize: 10_000,\n\t},\n}\n\n// TestBadFirstHopHint tests that a payment with a first hop hint with an\n// invalid channel id still works since the node already knows its channel and\n// doesn't need hints.",
      "length": 3550,
      "tokens": 463,
      "embedding": []
    },
    {
      "slug": "func TestBadFirstHopHint(t *testing.T) {",
      "content": "func TestBadFirstHopHint(t *testing.T) {\n\tt.Parallel()\n\n\tctx := newIntegratedRoutingContext(t)\n\n\tonePathGraph(ctx.graph)\n\n\tsourcePubKey, _ := btcec.ParsePubKey(ctx.source.pubkey[:])\n\n\thopHint := zpay32.HopHint{\n\t\tNodeID:                    sourcePubKey,\n\t\tChannelID:                 66,\n\t\tFeeBaseMSat:               0,\n\t\tFeeProportionalMillionths: 0,\n\t\tCLTVExpiryDelta:           100,\n\t}\n\n\tctx.routeHints = [][]zpay32.HopHint{{hopHint}}\n\n\tctx.amt = lnwire.NewMSatFromSatoshis(100)\n\t_, err := ctx.testPayment(1)\n\n\trequire.NoError(t, err, \"payment failed\")\n}\n\n// TestMppSend tests that a payment can be completed using multiple shards.",
      "length": 568,
      "tokens": 50,
      "embedding": []
    },
    {
      "slug": "func TestMppSend(t *testing.T) {",
      "content": "func TestMppSend(t *testing.T) {\n\tfor _, testCase := range mppTestCases {\n\t\ttestCase := testCase\n\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\ttestMppSend(t, &testCase)\n\t\t})\n\t}\n}\n",
      "length": 140,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func testMppSend(t *testing.T, testCase *mppSendTestCase) {",
      "content": "func testMppSend(t *testing.T, testCase *mppSendTestCase) {\n\tctx := newIntegratedRoutingContext(t)\n\n\tg := ctx.graph\n\ttestCase.graph(g)\n\n\tctx.amt = lnwire.NewMSatFromSatoshis(testCase.amt)\n\n\tif testCase.maxShardSize != 0 {\n\t\tshardAmt := lnwire.NewMSatFromSatoshis(testCase.maxShardSize)\n\t\tctx.maxShardAmt = &shardAmt\n\t}\n\n\tattempts, err := ctx.testPayment(testCase.maxParts)\n\tswitch {\n\tcase err == nil && testCase.expectedFailure:\n\t\tt.Fatal(\"expected payment to fail\")\n\tcase err != nil && !testCase.expectedFailure:\n\t\tt.Fatal(\"expected payment to succeed\")\n\t}\n\n\tif len(attempts) != testCase.expectedAttempts {\n\t\tt.Fatalf(\"expected %v attempts, but needed %v\",\n\t\t\ttestCase.expectedAttempts, len(attempts),\n\t\t)\n\t}\n\n\tassertSuccessAttempts(t, attempts, testCase.expectedSuccesses)\n}\n\n// expectedHtlcSuccess describes an expected successful htlc attempt.",
      "length": 758,
      "tokens": 76,
      "embedding": []
    },
    {
      "slug": "type expectedHtlcSuccess struct {",
      "content": "type expectedHtlcSuccess struct {\n\tamt   btcutil.Amount\n\tchans []uint64\n}\n\n// equals matches the expectation with an actual attempt.",
      "length": 94,
      "tokens": 14,
      "embedding": []
    },
    {
      "slug": "func (e *expectedHtlcSuccess) equals(a htlcAttempt) bool {",
      "content": "func (e *expectedHtlcSuccess) equals(a htlcAttempt) bool {\n\tif a.route.TotalAmount !=\n\t\tlnwire.NewMSatFromSatoshis(e.amt) {\n\n\t\treturn false\n\t}\n\n\tif len(a.route.Hops) != len(e.chans) {\n\t\treturn false\n\t}\n\n\tfor i, h := range a.route.Hops {\n\t\tif h.ChannelID != e.chans[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\n// assertSuccessAttempts asserts that the set of successful htlc attempts\n// matches the given expectation.",
      "length": 338,
      "tokens": 50,
      "embedding": []
    },
    {
      "slug": "func assertSuccessAttempts(t *testing.T, attempts []htlcAttempt,",
      "content": "func assertSuccessAttempts(t *testing.T, attempts []htlcAttempt,\n\texpected []expectedHtlcSuccess) {\n\n\tsuccessCount := 0\nloop:\n\tfor _, a := range attempts {\n\t\tif !a.success {\n\t\t\tcontinue\n\t\t}\n\n\t\tsuccessCount++\n\n\t\tfor _, exp := range expected {\n\t\t\tif exp.equals(a) {\n\t\t\t\tcontinue loop\n\t\t\t}\n\t\t}\n\n\t\tt.Fatalf(\"htlc success %v not found\", a)\n\t}\n\n\tif successCount != len(expected) {\n\t\tt.Fatalf(\"expected %v successful htlcs, but got %v\",\n\t\t\texpected, successCount)\n\t}\n}\n\n// TestPaymentAddrOnlyNoSplit tests that if the dest of a payment only has the\n// payment addr feature bit set, then we won't attempt to split payments.",
      "length": 523,
      "tokens": 83,
      "embedding": []
    },
    {
      "slug": "func TestPaymentAddrOnlyNoSplit(t *testing.T) {",
      "content": "func TestPaymentAddrOnlyNoSplit(t *testing.T) {\n\tt.Parallel()\n\n\t// First, we'll create the routing context, then create a simple two\n\t// path graph where the sender has two paths to the destination.\n\tctx := newIntegratedRoutingContext(t)\n\n\t// We'll have a basic graph with 2 mil sats of capacity, with 1 mil\n\t// sats available on either end.\n\tconst chanSize = 2_000_000\n\ttwoPathGraph(ctx.graph, chanSize, chanSize)\n\n\tpayAddrOnlyFeatures := []lnwire.FeatureBit{\n\t\tlnwire.TLVOnionPayloadOptional,\n\t\tlnwire.PaymentAddrOptional,\n\t}\n\n\t// We'll make a payment of 1.5 mil satoshis our single chan sizes,\n\t// which should cause a split attempt _if_ we had MPP bits activated.\n\t// However, we only have the payment addr on, so we shouldn't split at\n\t// all.\n\t//\n\t// We'll set a non-zero value for max parts as well, which should be\n\t// ignored.\n\tconst maxParts = 5\n\tctx.amt = lnwire.NewMSatFromSatoshis(1_500_000)\n\n\tattempts, err := ctx.testPayment(maxParts, payAddrOnlyFeatures...)\n\trequire.NotNil(\n\t\tt,\n\t\terr,\n\t\tfmt.Sprintf(\"expected path finding to fail instead made \"+\n\t\t\t\"attempts: %v\", spew.Sdump(attempts)),\n\t)\n\n\t// The payment should have failed since we need to split in order to\n\t// route a payment to the destination, but they don't actually support\n\t// MPP.\n\trequire.Equal(t, err.Error(), errNoPathFound.Error())\n}\n",
      "length": 1231,
      "tokens": 180,
      "embedding": []
    }
  ]
}