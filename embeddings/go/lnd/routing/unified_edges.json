{
  "filepath": "../implementations/go/lnd/routing/unified_edges.go",
  "package": "routing",
  "sections": [
    {
      "slug": "type nodeEdgeUnifier struct {",
      "content": "type nodeEdgeUnifier struct {\n\t// edgeUnifiers contains an edge unifier for every from node.\n\tedgeUnifiers map[route.Vertex]*edgeUnifier\n\n\t// sourceNode is the sender of a payment. The rules to pick the final\n\t// policy are different for local channels.\n\tsourceNode route.Vertex\n\n\t// toNode is the node for which the edge unifiers are instantiated.\n\ttoNode route.Vertex\n\n\t// outChanRestr is an optional outgoing channel restriction for the\n\t// local channel to use.\n\toutChanRestr map[uint64]struct{}\n}\n\n// newNodeEdgeUnifier instantiates a new nodeEdgeUnifier object. Channel\n// policies can be added to this object.",
      "length": 570,
      "tokens": 83,
      "embedding": []
    },
    {
      "slug": "func newNodeEdgeUnifier(sourceNode, toNode route.Vertex,",
      "content": "func newNodeEdgeUnifier(sourceNode, toNode route.Vertex,\n\toutChanRestr map[uint64]struct{}) *nodeEdgeUnifier {\n\n\treturn &nodeEdgeUnifier{\n\t\tedgeUnifiers: make(map[route.Vertex]*edgeUnifier),\n\t\ttoNode:       toNode,\n\t\tsourceNode:   sourceNode,\n\t\toutChanRestr: outChanRestr,\n\t}\n}\n\n// addPolicy adds a single channel policy. Capacity may be zero if unknown\n// (light clients).",
      "length": 305,
      "tokens": 32,
      "embedding": []
    },
    {
      "slug": "func (u *nodeEdgeUnifier) addPolicy(fromNode route.Vertex,",
      "content": "func (u *nodeEdgeUnifier) addPolicy(fromNode route.Vertex,\n\tedge *channeldb.CachedEdgePolicy, capacity btcutil.Amount) {\n\n\tlocalChan := fromNode == u.sourceNode\n\n\t// Skip channels if there is an outgoing channel restriction.\n\tif localChan && u.outChanRestr != nil {\n\t\tif _, ok := u.outChanRestr[edge.ChannelID]; !ok {\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Update the edgeUnifiers map.\n\tunifier, ok := u.edgeUnifiers[fromNode]\n\tif !ok {\n\t\tunifier = &edgeUnifier{\n\t\t\tlocalChan: localChan,\n\t\t}\n\t\tu.edgeUnifiers[fromNode] = unifier\n\t}\n\n\tunifier.edges = append(unifier.edges, &unifiedEdge{\n\t\tpolicy:   edge,\n\t\tcapacity: capacity,\n\t})\n}\n\n// addGraphPolicies adds all policies that are known for the toNode in the\n// graph.",
      "length": 614,
      "tokens": 84,
      "embedding": []
    },
    {
      "slug": "func (u *nodeEdgeUnifier) addGraphPolicies(g routingGraph) error {",
      "content": "func (u *nodeEdgeUnifier) addGraphPolicies(g routingGraph) error {\n\tcb := func(channel *channeldb.DirectedChannel) error {\n\t\t// If there is no edge policy for this candidate node, skip.\n\t\t// Note that we are searching backwards so this node would have\n\t\t// come prior to the pivot node in the route.\n\t\tif channel.InPolicy == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Add this policy to the corresponding edgeUnifier.\n\t\tu.addPolicy(\n\t\t\tchannel.OtherNode, channel.InPolicy, channel.Capacity,\n\t\t)\n\n\t\treturn nil\n\t}\n\n\t// Iterate over all channels of the to node.\n\treturn g.forEachNodeChannel(u.toNode, cb)\n}\n\n// unifiedEdge is the individual channel data that is kept inside an edgeUnifier\n// object.",
      "length": 595,
      "tokens": 92,
      "embedding": []
    },
    {
      "slug": "type unifiedEdge struct {",
      "content": "type unifiedEdge struct {\n\tpolicy   *channeldb.CachedEdgePolicy\n\tcapacity btcutil.Amount\n}\n\n// amtInRange checks whether an amount falls within the valid range for a\n// channel.",
      "length": 146,
      "tokens": 20,
      "embedding": []
    },
    {
      "slug": "func (u *unifiedEdge) amtInRange(amt lnwire.MilliSatoshi) bool {",
      "content": "func (u *unifiedEdge) amtInRange(amt lnwire.MilliSatoshi) bool {\n\t// If the capacity is available (non-light clients), skip channels that\n\t// are too small.\n\tif u.capacity > 0 &&\n\t\tamt > lnwire.NewMSatFromSatoshis(u.capacity) {\n\n\t\tlog.Tracef(\"Not enough capacity: amt=%v, capacity=%v\",\n\t\t\tamt, u.capacity)\n\t\treturn false\n\t}\n\n\t// Skip channels for which this htlc is too large.\n\tif u.policy.MessageFlags.HasMaxHtlc() &&\n\t\tamt > u.policy.MaxHTLC {\n\n\t\tlog.Tracef(\"Exceeds policy's MaxHTLC: amt=%v, MaxHTLC=%v\",\n\t\t\tamt, u.policy.MaxHTLC)\n\t\treturn false\n\t}\n\n\t// Skip channels for which this htlc is too small.\n\tif amt < u.policy.MinHTLC {\n\t\tlog.Tracef(\"below policy's MinHTLC: amt=%v, MinHTLC=%v\",\n\t\t\tamt, u.policy.MinHTLC)\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// edgeUnifier is an object that covers all channels between a pair of nodes.",
      "length": 737,
      "tokens": 103,
      "embedding": []
    },
    {
      "slug": "type edgeUnifier struct {",
      "content": "type edgeUnifier struct {\n\tedges     []*unifiedEdge\n\tlocalChan bool\n}\n\n// getEdge returns the optimal unified edge to use for this connection given a\n// specific amount to send. It differentiates between local and network\n// channels.",
      "length": 202,
      "tokens": 32,
      "embedding": []
    },
    {
      "slug": "func (u *edgeUnifier) getEdge(amt lnwire.MilliSatoshi,",
      "content": "func (u *edgeUnifier) getEdge(amt lnwire.MilliSatoshi,\n\tbandwidthHints bandwidthHints) *unifiedEdge {\n\n\tif u.localChan {\n\t\treturn u.getEdgeLocal(amt, bandwidthHints)\n\t}\n\n\treturn u.getEdgeNetwork(amt)\n}\n\n// getEdgeLocal returns the optimal unified edge to use for this local\n// connection given a specific amount to send.",
      "length": 255,
      "tokens": 34,
      "embedding": []
    },
    {
      "slug": "func (u *edgeUnifier) getEdgeLocal(amt lnwire.MilliSatoshi,",
      "content": "func (u *edgeUnifier) getEdgeLocal(amt lnwire.MilliSatoshi,\n\tbandwidthHints bandwidthHints) *unifiedEdge {\n\n\tvar (\n\t\tbestEdge     *unifiedEdge\n\t\tmaxBandwidth lnwire.MilliSatoshi\n\t)\n\n\tfor _, edge := range u.edges {\n\t\t// Check valid amount range for the channel.\n\t\tif !edge.amtInRange(amt) {\n\t\t\tlog.Debugf(\"Amount %v not in range for edge %v\",\n\t\t\t\tamt, edge.policy.ChannelID)\n\t\t\tcontinue\n\t\t}\n\n\t\t// For local channels, there is no fee to pay or an extra time\n\t\t// lock. We only consider the currently available bandwidth for\n\t\t// channel selection. The disabled flag is ignored for local\n\t\t// channels.\n\n\t\t// Retrieve bandwidth for this local channel. If not\n\t\t// available, assume this channel has enough bandwidth.\n\t\t//\n\t\t// TODO(joostjager): Possibly change to skipping this\n\t\t// channel. The bandwidth hint is expected to be\n\t\t// available.\n\t\tbandwidth, ok := bandwidthHints.availableChanBandwidth(\n\t\t\tedge.policy.ChannelID, amt,\n\t\t)\n\t\tif !ok {\n\t\t\tlog.Debugf(\"Cannot get bandwidth for edge %v, use max \"+\n\t\t\t\t\"instead\", edge.policy.ChannelID)\n\t\t\tbandwidth = lnwire.MaxMilliSatoshi\n\t\t}\n\n\t\t// TODO(yy): if the above `!ok` is chosen, we'd have\n\t\t// `bandwidth` to be the max value, which will end up having\n\t\t// the `maxBandwidth` to be have the largest value and this\n\t\t// edge will be the chosen one. This is wrong in two ways,\n\t\t// 1. we need to understand why `availableChanBandwidth` cannot\n\t\t// find bandwidth for this edge as something is wrong with this\n\t\t// channel, and,\n\t\t// 2. this edge is likely NOT the local channel with the\n\t\t// highest available bandwidth.\n\t\t//\n\t\t// Skip channels that can't carry the payment.\n\t\tif amt > bandwidth {\n\t\t\tlog.Debugf(\"Skipped edge %v: not enough bandwidth, \"+\n\t\t\t\t\"bandwidth=%v, amt=%v\", edge.policy.ChannelID,\n\t\t\t\tbandwidth, amt)\n\t\t\tcontinue\n\t\t}\n\n\t\t// We pick the local channel with the highest available\n\t\t// bandwidth, to maximize the success probability. It\n\t\t// can be that the channel state changes between\n\t\t// querying the bandwidth hints and sending out the\n\t\t// htlc.\n\t\tif bandwidth < maxBandwidth {\n\t\t\tlog.Debugf(\"Skipped edge %v: not max bandwidth, \"+\n\t\t\t\t\"bandwidth=%v, maxBandwidth=%v\",\n\t\t\t\tbandwidth, maxBandwidth)\n\t\t\tcontinue\n\t\t}\n\t\tmaxBandwidth = bandwidth\n\n\t\t// Update best edge.\n\t\tbestEdge = &unifiedEdge{policy: edge.policy}\n\t}\n\n\treturn bestEdge\n}\n\n// getEdgeNetwork returns the optimal unified edge to use for this connection\n// given a specific amount to send. The goal is to return a unified edge with a\n// policy that maximizes the probability of a successful forward in a non-strict\n// forwarding context.",
      "length": 2439,
      "tokens": 368,
      "embedding": []
    },
    {
      "slug": "func (u *edgeUnifier) getEdgeNetwork(amt lnwire.MilliSatoshi) *unifiedEdge {",
      "content": "func (u *edgeUnifier) getEdgeNetwork(amt lnwire.MilliSatoshi) *unifiedEdge {\n\tvar (\n\t\tbestPolicy  *channeldb.CachedEdgePolicy\n\t\tmaxFee      lnwire.MilliSatoshi\n\t\tmaxTimelock uint16\n\t\tmaxCapMsat  lnwire.MilliSatoshi\n\t)\n\n\tfor _, edge := range u.edges {\n\t\t// Check valid amount range for the channel.\n\t\tif !edge.amtInRange(amt) {\n\t\t\tlog.Debugf(\"Amount %v not in range for edge %v\",\n\t\t\t\tamt, edge.policy.ChannelID)\n\t\t\tcontinue\n\t\t}\n\n\t\t// For network channels, skip the disabled ones.\n\t\tedgeFlags := edge.policy.ChannelFlags\n\t\tisDisabled := edgeFlags&lnwire.ChanUpdateDisabled != 0\n\t\tif isDisabled {\n\t\t\tlog.Debugf(\"Skipped edge %v due to it being disabled\",\n\t\t\t\tedge.policy.ChannelID)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Track the maximal capacity for usable channels. If we don't\n\t\t// know the capacity, we fall back to MaxHTLC.\n\t\tcapMsat := lnwire.NewMSatFromSatoshis(edge.capacity)\n\t\tif capMsat == 0 && edge.policy.MessageFlags.HasMaxHtlc() {\n\t\t\tlog.Tracef(\"No capacity available for channel %v, \"+\n\t\t\t\t\"using MaxHtlcMsat (%v) as a fallback.\",\n\t\t\t\tedge.policy.ChannelID, edge.policy.MaxHTLC)\n\n\t\t\tcapMsat = edge.policy.MaxHTLC\n\t\t}\n\t\tmaxCapMsat = lntypes.Max(capMsat, maxCapMsat)\n\n\t\t// Track the maximum time lock of all channels that are\n\t\t// candidate for non-strict forwarding at the routing node.\n\t\tmaxTimelock = lntypes.Max(\n\t\t\tmaxTimelock, edge.policy.TimeLockDelta,\n\t\t)\n\n\t\t// Use the policy that results in the highest fee for this\n\t\t// specific amount.\n\t\tfee := edge.policy.ComputeFee(amt)\n\t\tif fee < maxFee {\n\t\t\tlog.Debugf(\"Skipped edge %v due to it produces less \"+\n\t\t\t\t\"fee: fee=%v, maxFee=%v\",\n\t\t\t\tedge.policy.ChannelID, fee, maxFee)\n\t\t\tcontinue\n\t\t}\n\t\tmaxFee = fee\n\n\t\tbestPolicy = edge.policy\n\t}\n\n\t// Return early if no channel matches.\n\tif bestPolicy == nil {\n\t\treturn nil\n\t}\n\n\t// We have already picked the highest fee that could be required for\n\t// non-strict forwarding. To also cover the case where a lower fee\n\t// channel requires a longer time lock, we modify the policy by setting\n\t// the maximum encountered time lock. Note that this results in a\n\t// synthetic policy that is not actually present on the routing node.\n\t//\n\t// The reason we do this, is that we try to maximize the chance that we\n\t// get forwarded. Because we penalize pair-wise, there won't be a second\n\t// chance for this node pair. But this is all only needed for nodes that\n\t// have distinct policies for channels to the same peer.\n\tpolicyCopy := *bestPolicy\n\tmodifiedEdge := unifiedEdge{policy: &policyCopy}\n\tmodifiedEdge.policy.TimeLockDelta = maxTimelock\n\tmodifiedEdge.capacity = maxCapMsat.ToSatoshis()\n\n\treturn &modifiedEdge\n}\n\n// minAmt returns the minimum amount that can be forwarded on this connection.",
      "length": 2526,
      "tokens": 357,
      "embedding": []
    },
    {
      "slug": "func (u *edgeUnifier) minAmt() lnwire.MilliSatoshi {",
      "content": "func (u *edgeUnifier) minAmt() lnwire.MilliSatoshi {\n\tmin := lnwire.MaxMilliSatoshi\n\tfor _, edge := range u.edges {\n\t\tmin = lntypes.Min(min, edge.policy.MinHTLC)\n\t}\n\n\treturn min\n}\n",
      "length": 120,
      "tokens": 18,
      "embedding": []
    }
  ]
}