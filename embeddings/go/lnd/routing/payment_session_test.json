{
  "filepath": "../implementations/go/lnd/routing/payment_session_test.go",
  "package": "routing",
  "sections": [
    {
      "slug": "func TestValidateCLTVLimit(t *testing.T) {",
      "content": "func TestValidateCLTVLimit(t *testing.T) {\n\tt.Parallel()\n\n\ttestCases := []struct {\n\t\tname           string\n\t\tcltvLimit      uint32\n\t\tfinalCltvDelta uint16\n\t\tincludePadding bool\n\t\texpectError    bool\n\t}{\n\t\t{\n\t\t\tname:           \"bad limit with padding\",\n\t\t\tcltvLimit:      uint32(103),\n\t\t\tfinalCltvDelta: uint16(100),\n\t\t\tincludePadding: true,\n\t\t\texpectError:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"good limit with padding\",\n\t\t\tcltvLimit:      uint32(104),\n\t\t\tfinalCltvDelta: uint16(100),\n\t\t\tincludePadding: true,\n\t\t\texpectError:    false,\n\t\t},\n\t\t{\n\t\t\tname:           \"bad limit no padding\",\n\t\t\tcltvLimit:      uint32(100),\n\t\t\tfinalCltvDelta: uint16(100),\n\t\t\tincludePadding: false,\n\t\t\texpectError:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"good limit no padding\",\n\t\t\tcltvLimit:      uint32(101),\n\t\t\tfinalCltvDelta: uint16(100),\n\t\t\tincludePadding: false,\n\t\t\texpectError:    false,\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\ttestCase := testCase\n\n\t\tsuccess := t.Run(testCase.name, func(t *testing.T) {\n\t\t\terr := ValidateCLTVLimit(\n\t\t\t\ttestCase.cltvLimit, testCase.finalCltvDelta,\n\t\t\t\ttestCase.includePadding,\n\t\t\t)\n\n\t\t\tif testCase.expectError {\n\t\t\t\trequire.NotEmpty(t, err)\n\t\t\t} else {\n\t\t\t\trequire.NoError(t, err)\n\t\t\t}\n\t\t})\n\t\tif !success {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\n// TestUpdateAdditionalEdge checks that we can update the additional edges as\n// expected.",
      "length": 1240,
      "tokens": 132,
      "embedding": []
    },
    {
      "slug": "func TestUpdateAdditionalEdge(t *testing.T) {",
      "content": "func TestUpdateAdditionalEdge(t *testing.T) {\n\tvar (\n\t\ttestChannelID  = uint64(12345)\n\t\toldFeeBaseMSat = uint32(1000)\n\t\tnewFeeBaseMSat = uint32(1100)\n\t\toldExpiryDelta = uint16(100)\n\t\tnewExpiryDelta = uint16(120)\n\n\t\tpayHash lntypes.Hash\n\t)\n\n\t// Create a minimal test node using the private key priv1.\n\tpub := priv1.PubKey().SerializeCompressed()\n\ttestNode := &channeldb.LightningNode{}\n\tcopy(testNode.PubKeyBytes[:], pub)\n\n\tnodeID, err := testNode.PubKey()\n\trequire.NoError(t, err, \"failed to get node id\")\n\n\t// Create a payment with a route hint.\n\tpayment := &LightningPayment{\n\t\tTarget: testNode.PubKeyBytes,\n\t\tAmount: 1000,\n\t\tRouteHints: [][]zpay32.HopHint{{\n\t\t\tzpay32.HopHint{\n\t\t\t\t// The nodeID is actually the target itself. It\n\t\t\t\t// doesn't matter as we are not doing routing\n\t\t\t\t// in this test.\n\t\t\t\tNodeID:          nodeID,\n\t\t\t\tChannelID:       testChannelID,\n\t\t\t\tFeeBaseMSat:     oldFeeBaseMSat,\n\t\t\t\tCLTVExpiryDelta: oldExpiryDelta,\n\t\t\t},\n\t\t}},\n\t\tpaymentHash: &payHash,\n\t}\n\n\t// Create the paymentsession.\n\tsession, err := newPaymentSession(\n\t\tpayment,\n\t\tfunc(routingGraph) (bandwidthHints, error) {\n\t\t\treturn &mockBandwidthHints{}, nil\n\t\t},\n\t\tfunc() (routingGraph, func(), error) {\n\t\t\treturn &sessionGraph{}, func() {}, nil\n\t\t},\n\t\t&MissionControl{},\n\t\tPathFindingConfig{},\n\t)\n\trequire.NoError(t, err, \"failed to create payment session\")\n\n\t// We should have 1 additional edge.\n\trequire.Equal(t, 1, len(session.additionalEdges))\n\n\t// The edge should use nodeID as key, and its value should have 1 edge\n\t// policy.\n\tvertex := route.NewVertex(nodeID)\n\tpolicies, ok := session.additionalEdges[vertex]\n\trequire.True(t, ok, \"cannot find policy\")\n\trequire.Equal(t, 1, len(policies), \"should have 1 edge policy\")\n\n\t// Check that the policy has been created as expected.\n\tpolicy := policies[0]\n\trequire.Equal(t, testChannelID, policy.ChannelID, \"channel ID mismatch\")\n\trequire.Equal(t,\n\t\toldExpiryDelta, policy.TimeLockDelta, \"timelock delta mismatch\",\n\t)\n\trequire.Equal(t,\n\t\tlnwire.MilliSatoshi(oldFeeBaseMSat),\n\t\tpolicy.FeeBaseMSat, \"fee base msat mismatch\",\n\t)\n\n\t// Create the channel update message and sign.\n\tmsg := &lnwire.ChannelUpdate{\n\t\tShortChannelID: lnwire.NewShortChanIDFromInt(testChannelID),\n\t\tTimestamp:      uint32(time.Now().Unix()),\n\t\tBaseFee:        newFeeBaseMSat,\n\t\tTimeLockDelta:  newExpiryDelta,\n\t}\n\tsignErrChanUpdate(t, priv1, msg)\n\n\t// Apply the update.\n\trequire.True(t,\n\t\tsession.UpdateAdditionalEdge(msg, nodeID, policy),\n\t\t\"failed to update additional edge\",\n\t)\n\n\t// Check that the policy has been updated as expected.\n\trequire.Equal(t, testChannelID, policy.ChannelID, \"channel ID mismatch\")\n\trequire.Equal(t,\n\t\tnewExpiryDelta, policy.TimeLockDelta, \"timelock delta mismatch\",\n\t)\n\trequire.Equal(t,\n\t\tlnwire.MilliSatoshi(newFeeBaseMSat),\n\t\tpolicy.FeeBaseMSat, \"fee base msat mismatch\",\n\t)\n}\n",
      "length": 2677,
      "tokens": 291,
      "embedding": []
    },
    {
      "slug": "func TestRequestRoute(t *testing.T) {",
      "content": "func TestRequestRoute(t *testing.T) {\n\tconst (\n\t\theight = 10\n\t)\n\n\tcltvLimit := uint32(30)\n\tfinalCltvDelta := uint16(8)\n\n\tpayment := &LightningPayment{\n\t\tCltvLimit:      cltvLimit,\n\t\tFinalCLTVDelta: finalCltvDelta,\n\t\tAmount:         1000,\n\t\tFeeLimit:       1000,\n\t}\n\n\tvar paymentHash [32]byte\n\tif err := payment.SetPaymentHash(paymentHash); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tsession, err := newPaymentSession(\n\t\tpayment,\n\t\tfunc(routingGraph) (bandwidthHints, error) {\n\t\t\treturn &mockBandwidthHints{}, nil\n\t\t},\n\t\tfunc() (routingGraph, func(), error) {\n\t\t\treturn &sessionGraph{}, func() {}, nil\n\t\t},\n\t\t&MissionControl{},\n\t\tPathFindingConfig{},\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Override pathfinder with a mock.\n\tsession.pathFinder = func(_ *graphParams, r *RestrictParams,\n\t\t_ *PathFindingConfig, _, _ route.Vertex, _ lnwire.MilliSatoshi,\n\t\t_ float64, _ int32) ([]*channeldb.CachedEdgePolicy, float64,\n\t\terror) {\n\n\t\t// We expect find path to receive a cltv limit excluding the\n\t\t// final cltv delta (including the block padding).\n\t\tif r.CltvLimit != 22-uint32(BlockPadding) {\n\t\t\tt.Fatal(\"wrong cltv limit\")\n\t\t}\n\n\t\tpath := []*channeldb.CachedEdgePolicy{\n\t\t\t{\n\t\t\t\tToNodePubKey: func() route.Vertex {\n\t\t\t\t\treturn route.Vertex{}\n\t\t\t\t},\n\t\t\t\tToNodeFeatures: lnwire.NewFeatureVector(\n\t\t\t\t\tnil, nil,\n\t\t\t\t),\n\t\t\t},\n\t\t}\n\n\t\treturn path, 1.0, nil\n\t}\n\n\troute, err := session.RequestRoute(\n\t\tpayment.Amount, payment.FeeLimit, 0, height,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// We expect an absolute route lock value of height + finalCltvDelta\n\t// + BlockPadding.\n\tif route.TotalTimeLock != 18+uint32(BlockPadding) {\n\t\tt.Fatalf(\"unexpected total time lock of %v\",\n\t\t\troute.TotalTimeLock)\n\t}\n}\n",
      "length": 1573,
      "tokens": 195,
      "embedding": []
    },
    {
      "slug": "type sessionGraph struct {",
      "content": "type sessionGraph struct {\n\troutingGraph\n}\n",
      "length": 14,
      "tokens": 2,
      "embedding": []
    },
    {
      "slug": "func (g *sessionGraph) sourceNode() route.Vertex {",
      "content": "func (g *sessionGraph) sourceNode() route.Vertex {\n\treturn route.Vertex{}\n}\n",
      "length": 23,
      "tokens": 3,
      "embedding": []
    }
  ]
}