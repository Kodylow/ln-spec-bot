{
  "filepath": "../implementations/go/lnd/routing/missioncontrol_test.go",
  "package": "routing",
  "sections": [
    {
      "slug": "type mcTestContext struct {",
      "content": "type mcTestContext struct {\n\tt   *testing.T\n\tmc  *MissionControl\n\tnow time.Time\n\n\tdb     kvdb.Backend\n\tdbPath string\n\n\tpid uint64\n}\n",
      "length": 95,
      "tokens": 13,
      "embedding": []
    },
    {
      "slug": "func createMcTestContext(t *testing.T) *mcTestContext {",
      "content": "func createMcTestContext(t *testing.T) *mcTestContext {\n\tctx := &mcTestContext{\n\t\tt:   t,\n\t\tnow: mcTestTime,\n\t}\n\n\tfile, err := os.CreateTemp(\"\", \"*.db\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, file.Close())\n\t\trequire.NoError(t, os.Remove(file.Name()))\n\t})\n\n\tctx.dbPath = file.Name()\n\n\tctx.db, err = kvdb.Open(\n\t\tkvdb.BoltBackendName, ctx.dbPath, true, kvdb.DefaultDBTimeout,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, ctx.db.Close())\n\t})\n\n\tctx.restartMc()\n\n\treturn ctx\n}\n\n// restartMc creates a new instances of mission control on the same database.",
      "length": 534,
      "tokens": 68,
      "embedding": []
    },
    {
      "slug": "func (ctx *mcTestContext) restartMc() {",
      "content": "func (ctx *mcTestContext) restartMc() {\n\t// Since we don't run a timer to store results in unit tests, we store\n\t// them here before fetching back everything in NewMissionControl.\n\tif ctx.mc != nil {\n\t\trequire.NoError(ctx.t, ctx.mc.store.storeResults())\n\t}\n\n\taCfg := AprioriConfig{\n\t\tPenaltyHalfLife:       testPenaltyHalfLife,\n\t\tAprioriHopProbability: testAprioriHopProbability,\n\t\tAprioriWeight:         testAprioriWeight,\n\t\tCapacityFraction:      testCapacityFraction,\n\t}\n\testimator, err := NewAprioriEstimator(aCfg)\n\trequire.NoError(ctx.t, err)\n\n\tmc, err := NewMissionControl(\n\t\tctx.db, mcTestSelf,\n\t\t&MissionControlConfig{Estimator: estimator},\n\t)\n\tif err != nil {\n\t\tctx.t.Fatal(err)\n\t}\n\n\tmc.now = func() time.Time { return ctx.now }\n\tctx.mc = mc\n}\n\n// Assert that mission control returns a probability for an edge.",
      "length": 752,
      "tokens": 89,
      "embedding": []
    },
    {
      "slug": "func (ctx *mcTestContext) expectP(amt lnwire.MilliSatoshi, expected float64) {",
      "content": "func (ctx *mcTestContext) expectP(amt lnwire.MilliSatoshi, expected float64) {\n\tctx.t.Helper()\n\n\tp := ctx.mc.GetProbability(mcTestNode1, mcTestNode2, amt, testCapacity)\n\n\t// We relax the accuracy for the probability check because of the\n\t// capacity cutoff factor.\n\trequire.InDelta(\n\t\tctx.t, expected, p, 0.001, \"probability does not match\",\n\t)\n}\n\n// reportFailure reports a failure by using a test route.",
      "length": 315,
      "tokens": 44,
      "embedding": []
    },
    {
      "slug": "func (ctx *mcTestContext) reportFailure(amt lnwire.MilliSatoshi,",
      "content": "func (ctx *mcTestContext) reportFailure(amt lnwire.MilliSatoshi,\n\tfailure lnwire.FailureMessage) {\n\n\tmcTestRoute.Hops[0].AmtToForward = amt\n\n\terrorSourceIdx := 1\n\tctx.mc.ReportPaymentFail(\n\t\tctx.pid, mcTestRoute, &errorSourceIdx, failure,\n\t)\n}\n\n// reportSuccess reports a success by using a test route.",
      "length": 227,
      "tokens": 26,
      "embedding": []
    },
    {
      "slug": "func (ctx *mcTestContext) reportSuccess() {",
      "content": "func (ctx *mcTestContext) reportSuccess() {\n\terr := ctx.mc.ReportPaymentSuccess(ctx.pid, mcTestRoute)\n\tif err != nil {\n\t\tctx.t.Fatal(err)\n\t}\n\n\tctx.pid++\n}\n\n// TestMissionControl tests mission control probability estimation.",
      "length": 171,
      "tokens": 20,
      "embedding": []
    },
    {
      "slug": "func TestMissionControl(t *testing.T) {",
      "content": "func TestMissionControl(t *testing.T) {\n\tctx := createMcTestContext(t)\n\n\tctx.now = testTime\n\n\ttestTime := time.Date(2018, time.January, 9, 14, 00, 00, 0, time.UTC)\n\n\t// For local channels, we expect a higher probability than our apriori\n\t// test probability.\n\tselfP := ctx.mc.GetProbability(\n\t\tmcTestSelf, mcTestNode1, 100, testCapacity,\n\t)\n\tif selfP != prevSuccessProbability {\n\t\tt.Fatalf(\"expected prev success prob for untried local chans\")\n\t}\n\n\t// Initial probability is expected to be the a priori.\n\tctx.expectP(1000, testAprioriHopProbability)\n\n\t// Expect probability to be zero after reporting the edge as failed.\n\tctx.reportFailure(1000, lnwire.NewTemporaryChannelFailure(nil))\n\tctx.expectP(1000, 0)\n\n\t// As we reported with a min penalization amt, a lower amt than reported\n\t// should return the node probability, which is the a priori\n\t// probability.\n\tctx.expectP(500, testAprioriHopProbability)\n\n\t// Edge decay started. The node probability weighted average should now\n\t// have shifted from 1:1 to 1:0.5 -> 60%. The connection probability is\n\t// half way through the recovery, so we expect 30% here.\n\tctx.now = testTime.Add(30 * time.Minute)\n\tctx.expectP(1000, 0.3)\n\n\t// Edge fails again, this time without a min penalization amt. The edge\n\t// should be penalized regardless of amount.\n\tctx.reportFailure(0, lnwire.NewTemporaryChannelFailure(nil))\n\tctx.expectP(1000, 0)\n\tctx.expectP(500, 0)\n\n\t// Edge decay started.\n\tctx.now = testTime.Add(60 * time.Minute)\n\tctx.expectP(1000, 0.3)\n\n\t// Restart mission control to test persistence.\n\tctx.restartMc()\n\tctx.expectP(1000, 0.3)\n\n\t// A node level failure should bring probability of all known channels\n\t// back to zero.\n\tctx.reportFailure(0, lnwire.NewExpiryTooSoon(lnwire.ChannelUpdate{}))\n\tctx.expectP(1000, 0)\n\n\t// Check whether history snapshot looks sane.\n\thistory := ctx.mc.GetHistorySnapshot()\n\n\tif len(history.Pairs) != 4 {\n\t\tt.Fatalf(\"expected 4 pairs, but got %v\", len(history.Pairs))\n\t}\n\n\t// Test reporting a success.\n\tctx.reportSuccess()\n}\n\n// TestMissionControlChannelUpdate tests that the first channel update is not\n// penalizing the channel yet.",
      "length": 2013,
      "tokens": 264,
      "embedding": []
    },
    {
      "slug": "func TestMissionControlChannelUpdate(t *testing.T) {",
      "content": "func TestMissionControlChannelUpdate(t *testing.T) {\n\tctx := createMcTestContext(t)\n\n\t// Report a policy related failure. Because it is the first, we don't\n\t// expect a penalty.\n\tctx.reportFailure(\n\t\t0, lnwire.NewFeeInsufficient(0, lnwire.ChannelUpdate{}),\n\t)\n\tctx.expectP(100, testAprioriHopProbability)\n\n\t// Report another failure for the same channel. We expect it to be\n\t// pruned.\n\tctx.reportFailure(\n\t\t0, lnwire.NewFeeInsufficient(0, lnwire.ChannelUpdate{}),\n\t)\n\tctx.expectP(100, 0)\n}\n",
      "length": 422,
      "tokens": 50,
      "embedding": []
    }
  ]
}