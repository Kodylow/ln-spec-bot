{
  "filepath": "../implementations/go/lnd/routing/validation_barrier.go",
  "package": "routing",
  "sections": [
    {
      "slug": "type validationSignals struct {",
      "content": "type validationSignals struct {\n\t// allow is the signal used to allow a dependent to be processed.\n\tallow chan struct{}\n\n\t// deny is the signal used to prevent a dependent from being processed.\n\tdeny chan struct{}\n}\n\n// ValidationBarrier is a barrier used to ensure proper validation order while\n// concurrently validating new announcements for channel edges, and the\n// attributes of channel edges.  It uses this set of maps (protected by this\n// mutex) to track validation dependencies. For a given channel our\n// dependencies look like this: chanAnn <- chanUp <- nodeAnn. That is we must\n// validate the item on the left of the arrow before that on the right.",
      "length": 618,
      "tokens": 109,
      "embedding": []
    },
    {
      "slug": "type ValidationBarrier struct {",
      "content": "type ValidationBarrier struct {\n\t// validationSemaphore is a channel of structs which is used as a\n\t// semaphore. Initially we'll fill this with a buffered channel of the\n\t// size of the number of active requests. Each new job will consume\n\t// from this channel, then restore the value upon completion.\n\tvalidationSemaphore chan struct{}\n\n\t// chanAnnFinSignal is map that keep track of all the pending\n\t// ChannelAnnouncement like validation job going on. Once the job has\n\t// been completed, the channel will be closed unblocking any\n\t// dependants.\n\tchanAnnFinSignal map[lnwire.ShortChannelID]*validationSignals\n\n\t// chanEdgeDependencies tracks any channel edge updates which should\n\t// wait until the completion of the ChannelAnnouncement before\n\t// proceeding. This is a dependency, as we can't validate the update\n\t// before we validate the announcement which creates the channel\n\t// itself.\n\tchanEdgeDependencies map[lnwire.ShortChannelID]*validationSignals\n\n\t// nodeAnnDependencies tracks any pending NodeAnnouncement validation\n\t// jobs which should wait until the completion of the\n\t// ChannelAnnouncement before proceeding.\n\tnodeAnnDependencies map[route.Vertex]*validationSignals\n\n\tquit chan struct{}\n\tsync.Mutex\n}\n\n// NewValidationBarrier creates a new instance of a validation barrier given\n// the total number of active requests, and a quit channel which will be used\n// to know when to kill pending, but unfilled jobs.",
      "length": 1371,
      "tokens": 194,
      "embedding": []
    },
    {
      "slug": "func NewValidationBarrier(numActiveReqs int,",
      "content": "func NewValidationBarrier(numActiveReqs int,\n\tquitChan chan struct{}) *ValidationBarrier {\n\n\tv := &ValidationBarrier{\n\t\tchanAnnFinSignal:     make(map[lnwire.ShortChannelID]*validationSignals),\n\t\tchanEdgeDependencies: make(map[lnwire.ShortChannelID]*validationSignals),\n\t\tnodeAnnDependencies:  make(map[route.Vertex]*validationSignals),\n\t\tquit:                 quitChan,\n\t}\n\n\t// We'll first initialize a set of semaphores to limit our concurrency\n\t// when validating incoming requests in parallel.\n\tv.validationSemaphore = make(chan struct{}, numActiveReqs)\n\tfor i := 0; i < numActiveReqs; i++ {\n\t\tv.validationSemaphore <- struct{}{}\n\t}\n\n\treturn v\n}\n\n// InitJobDependencies will wait for a new job slot to become open, and then\n// sets up any dependent signals/trigger for the new job",
      "length": 719,
      "tokens": 81,
      "embedding": []
    },
    {
      "slug": "func (v *ValidationBarrier) InitJobDependencies(job interface{}) {",
      "content": "func (v *ValidationBarrier) InitJobDependencies(job interface{}) {\n\t// We'll wait for either a new slot to become open, or for the quit\n\t// channel to be closed.\n\tselect {\n\tcase <-v.validationSemaphore:\n\tcase <-v.quit:\n\t}\n\n\tv.Lock()\n\tdefer v.Unlock()\n\n\t// Once a slot is open, we'll examine the message of the job, to see if\n\t// there need to be any dependent barriers set up.\n\tswitch msg := job.(type) {\n\n\t// If this is a channel announcement, then we'll need to set up den\n\t// tenancies, as we'll need to verify this before we verify any\n\t// ChannelUpdates for the same channel, or NodeAnnouncements of nodes\n\t// that are involved in this channel. This goes for both the wire\n\t// type,s and also the types that we use within the database.\n\tcase *lnwire.ChannelAnnouncement:\n\n\t\t// We ensure that we only create a new announcement signal iff,\n\t\t// one doesn't already exist, as there may be duplicate\n\t\t// announcements.  We'll close this signal once the\n\t\t// ChannelAnnouncement has been validated. This will result in\n\t\t// all the dependent jobs being unlocked so they can finish\n\t\t// execution themselves.\n\t\tif _, ok := v.chanAnnFinSignal[msg.ShortChannelID]; !ok {\n\t\t\t// We'll create the channel that we close after we\n\t\t\t// validate this announcement. All dependants will\n\t\t\t// point to this same channel, so they'll be unblocked\n\t\t\t// at the same time.\n\t\t\tsignals := &validationSignals{\n\t\t\t\tallow: make(chan struct{}),\n\t\t\t\tdeny:  make(chan struct{}),\n\t\t\t}\n\n\t\t\tv.chanAnnFinSignal[msg.ShortChannelID] = signals\n\t\t\tv.chanEdgeDependencies[msg.ShortChannelID] = signals\n\n\t\t\tv.nodeAnnDependencies[route.Vertex(msg.NodeID1)] = signals\n\t\t\tv.nodeAnnDependencies[route.Vertex(msg.NodeID2)] = signals\n\t\t}\n\tcase *channeldb.ChannelEdgeInfo:\n\n\t\tshortID := lnwire.NewShortChanIDFromInt(msg.ChannelID)\n\t\tif _, ok := v.chanAnnFinSignal[shortID]; !ok {\n\t\t\tsignals := &validationSignals{\n\t\t\t\tallow: make(chan struct{}),\n\t\t\t\tdeny:  make(chan struct{}),\n\t\t\t}\n\n\t\t\tv.chanAnnFinSignal[shortID] = signals\n\t\t\tv.chanEdgeDependencies[shortID] = signals\n\n\t\t\tv.nodeAnnDependencies[route.Vertex(msg.NodeKey1Bytes)] = signals\n\t\t\tv.nodeAnnDependencies[route.Vertex(msg.NodeKey2Bytes)] = signals\n\t\t}\n\n\t// These other types don't have any dependants, so no further\n\t// initialization needs to be done beyond just occupying a job slot.\n\tcase *channeldb.ChannelEdgePolicy:\n\t\treturn\n\tcase *lnwire.ChannelUpdate:\n\t\treturn\n\tcase *lnwire.NodeAnnouncement:\n\t\t// TODO(roasbeef): node ann needs to wait on existing channel updates\n\t\treturn\n\tcase *channeldb.LightningNode:\n\t\treturn\n\tcase *lnwire.AnnounceSignatures:\n\t\t// TODO(roasbeef): need to wait on chan ann?\n\t\treturn\n\t}\n}\n\n// CompleteJob returns a free slot to the set of available job slots. This\n// should be called once a job has been fully completed. Otherwise, slots may\n// not be returned to the internal scheduling, causing a deadlock when a new\n// overflow job is attempted.",
      "length": 2752,
      "tokens": 380,
      "embedding": []
    },
    {
      "slug": "func (v *ValidationBarrier) CompleteJob() {",
      "content": "func (v *ValidationBarrier) CompleteJob() {\n\tselect {\n\tcase v.validationSemaphore <- struct{}{}:\n\tcase <-v.quit:\n\t}\n}\n\n// WaitForDependants will block until any jobs that this job dependants on have\n// finished executing. This allows us a graceful way to schedule goroutines\n// based on any pending uncompleted dependent jobs. If this job doesn't have an\n// active dependent, then this function will return immediately.",
      "length": 366,
      "tokens": 58,
      "embedding": []
    },
    {
      "slug": "func (v *ValidationBarrier) WaitForDependants(job interface{}) error {",
      "content": "func (v *ValidationBarrier) WaitForDependants(job interface{}) error {\n\n\tvar (\n\t\tsignals *validationSignals\n\t\tok      bool\n\t\tjobDesc string\n\t)\n\n\t// Acquire a lock to read ValidationBarrier.\n\tv.Lock()\n\n\tswitch msg := job.(type) {\n\t// Any ChannelUpdate or NodeAnnouncement jobs will need to wait on the\n\t// completion of any active ChannelAnnouncement jobs related to them.\n\tcase *channeldb.ChannelEdgePolicy:\n\t\tshortID := lnwire.NewShortChanIDFromInt(msg.ChannelID)\n\t\tsignals, ok = v.chanEdgeDependencies[shortID]\n\n\t\tjobDesc = fmt.Sprintf(\"job=lnwire.ChannelEdgePolicy, scid=%v\",\n\t\t\tmsg.ChannelID)\n\n\tcase *channeldb.LightningNode:\n\t\tvertex := route.Vertex(msg.PubKeyBytes)\n\t\tsignals, ok = v.nodeAnnDependencies[vertex]\n\n\t\tjobDesc = fmt.Sprintf(\"job=channeldb.LightningNode, pub=%s\",\n\t\t\tvertex)\n\n\tcase *lnwire.ChannelUpdate:\n\t\tsignals, ok = v.chanEdgeDependencies[msg.ShortChannelID]\n\n\t\tjobDesc = fmt.Sprintf(\"job=lnwire.ChannelUpdate, scid=%v\",\n\t\t\tmsg.ShortChannelID.ToUint64())\n\n\tcase *lnwire.NodeAnnouncement:\n\t\tvertex := route.Vertex(msg.NodeID)\n\t\tsignals, ok = v.nodeAnnDependencies[vertex]\n\t\tjobDesc = fmt.Sprintf(\"job=lnwire.NodeAnnouncement, pub=%s\",\n\t\t\tvertex)\n\n\t// Other types of jobs can be executed immediately, so we'll just\n\t// return directly.\n\tcase *lnwire.AnnounceSignatures:\n\t\t// TODO(roasbeef): need to wait on chan ann?\n\tcase *channeldb.ChannelEdgeInfo:\n\tcase *lnwire.ChannelAnnouncement:\n\t}\n\n\t// Release the lock once the above read is finished.\n\tv.Unlock()\n\n\t// If it's not ok, it means either the job is not a dependent type, or\n\t// it doesn't have a dependency signal. Either way, we can return\n\t// early.\n\tif !ok {\n\t\treturn nil\n\t}\n\n\tlog.Debugf(\"Waiting for dependent on %s\", jobDesc)\n\n\t// If we do have an active job, then we'll wait until either the signal\n\t// is closed, or the set of jobs exits.\n\tselect {\n\tcase <-v.quit:\n\t\treturn newErrf(ErrVBarrierShuttingDown,\n\t\t\t\"validation barrier shutting down\")\n\n\tcase <-signals.deny:\n\t\tlog.Debugf(\"Signal deny for %s\", jobDesc)\n\t\treturn newErrf(ErrParentValidationFailed,\n\t\t\t\"parent validation failed\")\n\n\tcase <-signals.allow:\n\t\tlog.Tracef(\"Signal allow for %s\", jobDesc)\n\t\treturn nil\n\t}\n}\n\n// SignalDependants will allow/deny any jobs that are dependent on this job that\n// they can continue execution. If the job doesn't have any dependants, then\n// this function sill exit immediately.",
      "length": 2206,
      "tokens": 269,
      "embedding": []
    },
    {
      "slug": "func (v *ValidationBarrier) SignalDependants(job interface{}, allow bool) {",
      "content": "func (v *ValidationBarrier) SignalDependants(job interface{}, allow bool) {\n\tv.Lock()\n\tdefer v.Unlock()\n\n\tswitch msg := job.(type) {\n\n\t// If we've just finished executing a ChannelAnnouncement, then we'll\n\t// close out the signal, and remove the signal from the map of active\n\t// ones. This will allow/deny any dependent jobs to continue execution.\n\tcase *channeldb.ChannelEdgeInfo:\n\t\tshortID := lnwire.NewShortChanIDFromInt(msg.ChannelID)\n\t\tfinSignals, ok := v.chanAnnFinSignal[shortID]\n\t\tif ok {\n\t\t\tif allow {\n\t\t\t\tclose(finSignals.allow)\n\t\t\t} else {\n\t\t\t\tclose(finSignals.deny)\n\t\t\t}\n\t\t\tdelete(v.chanAnnFinSignal, shortID)\n\t\t}\n\tcase *lnwire.ChannelAnnouncement:\n\t\tfinSignals, ok := v.chanAnnFinSignal[msg.ShortChannelID]\n\t\tif ok {\n\t\t\tif allow {\n\t\t\t\tclose(finSignals.allow)\n\t\t\t} else {\n\t\t\t\tclose(finSignals.deny)\n\t\t\t}\n\t\t\tdelete(v.chanAnnFinSignal, msg.ShortChannelID)\n\t\t}\n\n\t\tdelete(v.chanEdgeDependencies, msg.ShortChannelID)\n\n\t// For all other job types, we'll delete the tracking entries from the\n\t// map, as if we reach this point, then all dependants have already\n\t// finished executing and we can proceed.\n\tcase *channeldb.LightningNode:\n\t\tdelete(v.nodeAnnDependencies, route.Vertex(msg.PubKeyBytes))\n\tcase *lnwire.NodeAnnouncement:\n\t\tdelete(v.nodeAnnDependencies, route.Vertex(msg.NodeID))\n\tcase *lnwire.ChannelUpdate:\n\t\tdelete(v.chanEdgeDependencies, msg.ShortChannelID)\n\tcase *channeldb.ChannelEdgePolicy:\n\t\tshortID := lnwire.NewShortChanIDFromInt(msg.ChannelID)\n\t\tdelete(v.chanEdgeDependencies, shortID)\n\n\tcase *lnwire.AnnounceSignatures:\n\t\treturn\n\t}\n}\n",
      "length": 1436,
      "tokens": 147,
      "embedding": []
    }
  ]
}