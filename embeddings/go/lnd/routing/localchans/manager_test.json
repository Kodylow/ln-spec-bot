{
  "filepath": "../implementations/go/lnd/routing/localchans/manager_test.go",
  "package": "localchans",
  "sections": [
    {
      "slug": "func TestManager(t *testing.T) {",
      "content": "func TestManager(t *testing.T) {\n\tt.Parallel()\n\n\ttype channel struct {\n\t\tedgeInfo *channeldb.ChannelEdgeInfo\n\t}\n\n\tvar (\n\t\tchanPointValid     = wire.OutPoint{Hash: chainhash.Hash{1}, Index: 2}\n\t\tchanCap            = btcutil.Amount(1000)\n\t\tchanPointMissing   = wire.OutPoint{Hash: chainhash.Hash{2}, Index: 2}\n\t\tmaxPendingAmount   = lnwire.MilliSatoshi(999000)\n\t\tminHTLC            = lnwire.MilliSatoshi(2000)\n\t\texpectedNumUpdates int\n\t\tchannelSet         []channel\n\t)\n\n\tnewPolicy := routing.ChannelPolicy{\n\t\tFeeSchema: routing.FeeSchema{\n\t\t\tBaseFee: 100,\n\t\t\tFeeRate: 200,\n\t\t},\n\t\tTimeLockDelta: 80,\n\t\tMaxHTLC:       5000,\n\t}\n\n\tcurrentPolicy := channeldb.ChannelEdgePolicy{\n\t\tMinHTLC:      minHTLC,\n\t\tMessageFlags: lnwire.ChanUpdateRequiredMaxHtlc,\n\t}\n\n\tupdateForwardingPolicies := func(\n\t\tchanPolicies map[wire.OutPoint]htlcswitch.ForwardingPolicy) {\n\n\t\tif len(chanPolicies) == 0 {\n\t\t\treturn\n\t\t}\n\n\t\tif len(chanPolicies) != 1 {\n\t\t\tt.Fatal(\"unexpected number of policies to apply\")\n\t\t}\n\n\t\tpolicy := chanPolicies[chanPointValid]\n\t\tif policy.TimeLockDelta != newPolicy.TimeLockDelta {\n\t\t\tt.Fatal(\"unexpected time lock delta\")\n\t\t}\n\t\tif policy.BaseFee != newPolicy.BaseFee {\n\t\t\tt.Fatal(\"unexpected base fee\")\n\t\t}\n\t\tif uint32(policy.FeeRate) != newPolicy.FeeRate {\n\t\t\tt.Fatal(\"unexpected base fee\")\n\t\t}\n\t\tif policy.MaxHTLC != newPolicy.MaxHTLC {\n\t\t\tt.Fatal(\"unexpected max htlc\")\n\t\t}\n\t}\n\n\tpropagateChanPolicyUpdate := func(\n\t\tedgesToUpdate []discovery.EdgeWithInfo) error {\n\n\t\tif len(edgesToUpdate) != expectedNumUpdates {\n\t\t\tt.Fatalf(\"unexpected number of updates,\"+\n\t\t\t\t\" expected %d got %d\", expectedNumUpdates,\n\t\t\t\tlen(edgesToUpdate))\n\t\t}\n\n\t\tfor _, edge := range edgesToUpdate {\n\t\t\tpolicy := edge.Edge\n\t\t\tif !policy.MessageFlags.HasMaxHtlc() {\n\t\t\t\tt.Fatal(\"expected max htlc flag\")\n\t\t\t}\n\t\t\tif policy.TimeLockDelta != uint16(newPolicy.TimeLockDelta) {\n\t\t\t\tt.Fatal(\"unexpected time lock delta\")\n\t\t\t}\n\t\t\tif policy.FeeBaseMSat != newPolicy.BaseFee {\n\t\t\t\tt.Fatal(\"unexpected base fee\")\n\t\t\t}\n\t\t\tif uint32(policy.FeeProportionalMillionths) != newPolicy.FeeRate {\n\t\t\t\tt.Fatal(\"unexpected base fee\")\n\t\t\t}\n\t\t\tif policy.MaxHTLC != newPolicy.MaxHTLC {\n\t\t\t\tt.Fatal(\"unexpected max htlc\")\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}\n\n\tforAllOutgoingChannels := func(cb func(kvdb.RTx,\n\t\t*channeldb.ChannelEdgeInfo,\n\t\t*channeldb.ChannelEdgePolicy) error) error {\n\n\t\tfor _, c := range channelSet {\n\t\t\tif err := cb(nil, c.edgeInfo, &currentPolicy); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\n\tfetchChannel := func(tx kvdb.RTx, chanPoint wire.OutPoint) (\n\t\t*channeldb.OpenChannel, error) {\n\n\t\tif chanPoint == chanPointMissing {\n\t\t\treturn &channeldb.OpenChannel{}, channeldb.ErrChannelNotFound\n\t\t}\n\n\t\tconstraints := channeldb.ChannelConstraints{\n\t\t\tMaxPendingAmount: maxPendingAmount,\n\t\t\tMinHTLC:          minHTLC,\n\t\t}\n\n\t\treturn &channeldb.OpenChannel{\n\t\t\tLocalChanCfg: channeldb.ChannelConfig{\n\t\t\t\tChannelConstraints: constraints,\n\t\t\t},\n\t\t}, nil\n\t}\n\n\tmanager := Manager{\n\t\tUpdateForwardingPolicies:  updateForwardingPolicies,\n\t\tPropagateChanPolicyUpdate: propagateChanPolicyUpdate,\n\t\tForAllOutgoingChannels:    forAllOutgoingChannels,\n\t\tFetchChannel:              fetchChannel,\n\t}\n\n\t// Policy with no max htlc value.\n\tMaxHTLCPolicy := currentPolicy\n\tMaxHTLCPolicy.MaxHTLC = newPolicy.MaxHTLC\n\tnoMaxHtlcPolicy := newPolicy\n\tnoMaxHtlcPolicy.MaxHTLC = 0\n\n\ttests := []struct {\n\t\tname                   string\n\t\tcurrentPolicy          channeldb.ChannelEdgePolicy\n\t\tnewPolicy              routing.ChannelPolicy\n\t\tchannelSet             []channel\n\t\tspecifiedChanPoints    []wire.OutPoint\n\t\texpectedNumUpdates     int\n\t\texpectedUpdateFailures []lnrpc.UpdateFailure\n\t\texpectErr              error\n\t}{\n\t\t{\n\t\t\tname:          \"valid channel\",\n\t\t\tcurrentPolicy: currentPolicy,\n\t\t\tnewPolicy:     newPolicy,\n\t\t\tchannelSet: []channel{\n\t\t\t\t{\n\t\t\t\t\tedgeInfo: &channeldb.ChannelEdgeInfo{\n\t\t\t\t\t\tCapacity:     chanCap,\n\t\t\t\t\t\tChannelPoint: chanPointValid,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tspecifiedChanPoints:    []wire.OutPoint{chanPointValid},\n\t\t\texpectedNumUpdates:     1,\n\t\t\texpectedUpdateFailures: []lnrpc.UpdateFailure{},\n\t\t\texpectErr:              nil,\n\t\t},\n\t\t{\n\t\t\tname:          \"all channels\",\n\t\t\tcurrentPolicy: currentPolicy,\n\t\t\tnewPolicy:     newPolicy,\n\t\t\tchannelSet: []channel{\n\t\t\t\t{\n\t\t\t\t\tedgeInfo: &channeldb.ChannelEdgeInfo{\n\t\t\t\t\t\tCapacity:     chanCap,\n\t\t\t\t\t\tChannelPoint: chanPointValid,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tspecifiedChanPoints:    []wire.OutPoint{},\n\t\t\texpectedNumUpdates:     1,\n\t\t\texpectedUpdateFailures: []lnrpc.UpdateFailure{},\n\t\t\texpectErr:              nil,\n\t\t},\n\t\t{\n\t\t\tname:          \"missing channel\",\n\t\t\tcurrentPolicy: currentPolicy,\n\t\t\tnewPolicy:     newPolicy,\n\t\t\tchannelSet: []channel{\n\t\t\t\t{\n\t\t\t\t\tedgeInfo: &channeldb.ChannelEdgeInfo{\n\t\t\t\t\t\tCapacity:     chanCap,\n\t\t\t\t\t\tChannelPoint: chanPointValid,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tspecifiedChanPoints: []wire.OutPoint{chanPointMissing},\n\t\t\texpectedNumUpdates:  0,\n\t\t\texpectedUpdateFailures: []lnrpc.UpdateFailure{\n\t\t\t\tlnrpc.UpdateFailure_UPDATE_FAILURE_NOT_FOUND,\n\t\t\t},\n\t\t\texpectErr: nil,\n\t\t},\n\t\t{\n\t\t\t// Here, no max htlc is specified, the max htlc value\n\t\t\t// should be kept unchanged.\n\t\t\tname:          \"no max htlc specified\",\n\t\t\tcurrentPolicy: MaxHTLCPolicy,\n\t\t\tnewPolicy:     noMaxHtlcPolicy,\n\t\t\tchannelSet: []channel{\n\t\t\t\t{\n\t\t\t\t\tedgeInfo: &channeldb.ChannelEdgeInfo{\n\t\t\t\t\t\tCapacity:     chanCap,\n\t\t\t\t\t\tChannelPoint: chanPointValid,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tspecifiedChanPoints:    []wire.OutPoint{chanPointValid},\n\t\t\texpectedNumUpdates:     1,\n\t\t\texpectedUpdateFailures: []lnrpc.UpdateFailure{},\n\t\t\texpectErr:              nil,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tcurrentPolicy = test.currentPolicy\n\t\t\tchannelSet = test.channelSet\n\t\t\texpectedNumUpdates = test.expectedNumUpdates\n\n\t\t\tfailedUpdates, err := manager.UpdatePolicy(test.newPolicy,\n\t\t\t\ttest.specifiedChanPoints...)\n\n\t\t\tif len(failedUpdates) != len(test.expectedUpdateFailures) {\n\t\t\t\tt.Fatalf(\"wrong number of failed policy updates\")\n\t\t\t}\n\n\t\t\tif len(test.expectedUpdateFailures) > 0 {\n\t\t\t\tif failedUpdates[0].Reason != test.expectedUpdateFailures[0] {\n\t\t\t\t\tt.Fatalf(\"wrong expected policy update failure\")\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trequire.Equal(t, test.expectErr, err)\n\t\t})\n\t}\n}\n",
      "length": 5936,
      "tokens": 530,
      "embedding": []
    }
  ]
}