{
  "filepath": "../implementations/go/lnd/routing/localchans/manager.go",
  "package": "localchans",
  "sections": [
    {
      "slug": "type Manager struct {",
      "content": "type Manager struct {\n\t// UpdateForwardingPolicies is used by the manager to update active\n\t// links with a new policy.\n\tUpdateForwardingPolicies func(\n\t\tchanPolicies map[wire.OutPoint]htlcswitch.ForwardingPolicy)\n\n\t// PropagateChanPolicyUpdate is called to persist a new policy to disk\n\t// and broadcast it to the network.\n\tPropagateChanPolicyUpdate func(\n\t\tedgesToUpdate []discovery.EdgeWithInfo) error\n\n\t// ForAllOutgoingChannels is required to iterate over all our local\n\t// channels.\n\tForAllOutgoingChannels func(cb func(kvdb.RTx,\n\t\t*channeldb.ChannelEdgeInfo,\n\t\t*channeldb.ChannelEdgePolicy) error) error\n\n\t// FetchChannel is used to query local channel parameters. Optionally an\n\t// existing db tx can be supplied.\n\tFetchChannel func(tx kvdb.RTx, chanPoint wire.OutPoint) (\n\t\t*channeldb.OpenChannel, error)\n\n\t// policyUpdateLock ensures that the database and the link do not fall\n\t// out of sync if there are concurrent fee update calls. Without it,\n\t// there is a chance that policy A updates the database, then policy B\n\t// updates the database, then policy B updates the link, then policy A\n\t// updates the link.\n\tpolicyUpdateLock sync.Mutex\n}\n\n// UpdatePolicy updates the policy for the specified channels on disk and in\n// the active links.",
      "length": 1200,
      "tokens": 164,
      "embedding": []
    },
    {
      "slug": "func (r *Manager) UpdatePolicy(newSchema routing.ChannelPolicy,",
      "content": "func (r *Manager) UpdatePolicy(newSchema routing.ChannelPolicy,\n\tchanPoints ...wire.OutPoint) ([]*lnrpc.FailedUpdate, error) {\n\n\tr.policyUpdateLock.Lock()\n\tdefer r.policyUpdateLock.Unlock()\n\n\t// First, we'll construct a set of all the channels that we are\n\t// trying to update.\n\tunprocessedChans := make(map[wire.OutPoint]struct{})\n\tfor _, chanPoint := range chanPoints {\n\t\tunprocessedChans[chanPoint] = struct{}{}\n\t}\n\n\thaveChanFilter := len(unprocessedChans) != 0\n\n\tvar failedUpdates []*lnrpc.FailedUpdate\n\tvar edgesToUpdate []discovery.EdgeWithInfo\n\tpoliciesToUpdate := make(map[wire.OutPoint]htlcswitch.ForwardingPolicy)\n\n\t// Next, we'll loop over all the outgoing channels the router knows of.\n\t// If we have a filter then we'll only collected those channels,\n\t// otherwise we'll collect them all.\n\terr := r.ForAllOutgoingChannels(func(\n\t\ttx kvdb.RTx,\n\t\tinfo *channeldb.ChannelEdgeInfo,\n\t\tedge *channeldb.ChannelEdgePolicy) error {\n\n\t\t// If we have a channel filter, and this channel isn't a part\n\t\t// of it, then we'll skip it.\n\t\t_, ok := unprocessedChans[info.ChannelPoint]\n\t\tif !ok && haveChanFilter {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Mark this channel as found by removing it. unprocessedChans\n\t\t// will be used to report invalid channels later on.\n\t\tdelete(unprocessedChans, info.ChannelPoint)\n\n\t\t// Apply the new policy to the edge.\n\t\terr := r.updateEdge(tx, info.ChannelPoint, edge, newSchema)\n\t\tif err != nil {\n\t\t\tfailedUpdates = append(failedUpdates,\n\t\t\t\tmakeFailureItem(info.ChannelPoint,\n\t\t\t\t\tlnrpc.UpdateFailure_UPDATE_FAILURE_INVALID_PARAMETER,\n\t\t\t\t\terr.Error(),\n\t\t\t\t))\n\n\t\t\treturn nil\n\t\t}\n\n\t\t// Add updated edge to list of edges to send to gossiper.\n\t\tedgesToUpdate = append(edgesToUpdate, discovery.EdgeWithInfo{\n\t\t\tInfo: info,\n\t\t\tEdge: edge,\n\t\t})\n\n\t\t// Add updated policy to list of policies to send to switch.\n\t\tpoliciesToUpdate[info.ChannelPoint] = htlcswitch.ForwardingPolicy{\n\t\t\tBaseFee:       edge.FeeBaseMSat,\n\t\t\tFeeRate:       edge.FeeProportionalMillionths,\n\t\t\tTimeLockDelta: uint32(edge.TimeLockDelta),\n\t\t\tMinHTLCOut:    edge.MinHTLC,\n\t\t\tMaxHTLC:       edge.MaxHTLC,\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Construct a list of failed policy updates.\n\tfor chanPoint := range unprocessedChans {\n\t\tchannel, err := r.FetchChannel(nil, chanPoint)\n\t\tswitch {\n\t\tcase errors.Is(err, channeldb.ErrChannelNotFound):\n\t\t\tfailedUpdates = append(failedUpdates,\n\t\t\t\tmakeFailureItem(chanPoint,\n\t\t\t\t\tlnrpc.UpdateFailure_UPDATE_FAILURE_NOT_FOUND,\n\t\t\t\t\t\"not found\",\n\t\t\t\t))\n\n\t\tcase err != nil:\n\t\t\tfailedUpdates = append(failedUpdates,\n\t\t\t\tmakeFailureItem(chanPoint,\n\t\t\t\t\tlnrpc.UpdateFailure_UPDATE_FAILURE_INTERNAL_ERR,\n\t\t\t\t\terr.Error(),\n\t\t\t\t))\n\n\t\tcase channel.IsPending:\n\t\t\tfailedUpdates = append(failedUpdates,\n\t\t\t\tmakeFailureItem(chanPoint,\n\t\t\t\t\tlnrpc.UpdateFailure_UPDATE_FAILURE_PENDING,\n\t\t\t\t\t\"not yet confirmed\",\n\t\t\t\t))\n\n\t\tdefault:\n\t\t\tfailedUpdates = append(failedUpdates,\n\t\t\t\tmakeFailureItem(chanPoint,\n\t\t\t\t\tlnrpc.UpdateFailure_UPDATE_FAILURE_UNKNOWN,\n\t\t\t\t\t\"could not update policies\",\n\t\t\t\t))\n\t\t}\n\t}\n\n\t// Commit the policy updates to disk and broadcast to the network. We\n\t// validated the new policy above, so we expect no validation errors. If\n\t// this would happen because of a bug, the link policy will be\n\t// desynchronized. It is currently not possible to atomically commit\n\t// multiple edge updates.\n\terr = r.PropagateChanPolicyUpdate(edgesToUpdate)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Update active links.\n\tr.UpdateForwardingPolicies(policiesToUpdate)\n\n\treturn failedUpdates, nil\n}\n\n// updateEdge updates the given edge with the new schema.",
      "length": 3402,
      "tokens": 388,
      "embedding": []
    },
    {
      "slug": "func (r *Manager) updateEdge(tx kvdb.RTx, chanPoint wire.OutPoint,",
      "content": "func (r *Manager) updateEdge(tx kvdb.RTx, chanPoint wire.OutPoint,\n\tedge *channeldb.ChannelEdgePolicy,\n\tnewSchema routing.ChannelPolicy) error {\n\n\t// Update forwarding fee scheme and required time lock delta.\n\tedge.FeeBaseMSat = newSchema.BaseFee\n\tedge.FeeProportionalMillionths = lnwire.MilliSatoshi(\n\t\tnewSchema.FeeRate,\n\t)\n\tedge.TimeLockDelta = uint16(newSchema.TimeLockDelta)\n\n\t// Retrieve negotiated channel htlc amt limits.\n\tamtMin, amtMax, err := r.getHtlcAmtLimits(tx, chanPoint)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// We now update the edge max htlc value.\n\tswitch {\n\t// If a non-zero max htlc was specified, use it to update the edge.\n\t// Otherwise keep the value unchanged.\n\tcase newSchema.MaxHTLC != 0:\n\t\tedge.MaxHTLC = newSchema.MaxHTLC\n\n\t// If this edge still doesn't have a max htlc set, set it to the max.\n\t// This is an on-the-fly migration.\n\tcase !edge.MessageFlags.HasMaxHtlc():\n\t\tedge.MaxHTLC = amtMax\n\n\t// If this edge has a max htlc that exceeds what the channel can\n\t// actually carry, correct it now. This can happen, because we\n\t// previously set the max htlc to the channel capacity.\n\tcase edge.MaxHTLC > amtMax:\n\t\tedge.MaxHTLC = amtMax\n\t}\n\n\t// If a new min htlc is specified, update the edge.\n\tif newSchema.MinHTLC != nil {\n\t\tedge.MinHTLC = *newSchema.MinHTLC\n\t}\n\n\t// If the MaxHtlc flag wasn't already set, we can set it now.\n\tedge.MessageFlags |= lnwire.ChanUpdateRequiredMaxHtlc\n\n\t// Validate htlc amount constraints.\n\tswitch {\n\tcase edge.MinHTLC < amtMin:\n\t\treturn fmt.Errorf(\n\t\t\t\"min htlc amount of %v is below min htlc parameter of %v\",\n\t\t\tedge.MinHTLC, amtMin,\n\t\t)\n\n\tcase edge.MaxHTLC > amtMax:\n\t\treturn fmt.Errorf(\n\t\t\t\"max htlc size of %v is above max pending amount of %v\",\n\t\t\tedge.MaxHTLC, amtMax,\n\t\t)\n\n\tcase edge.MinHTLC > edge.MaxHTLC:\n\t\treturn fmt.Errorf(\n\t\t\t\"min_htlc %v greater than max_htlc %v\",\n\t\t\tedge.MinHTLC, edge.MaxHTLC,\n\t\t)\n\t}\n\n\t// Clear signature to help prevent usage of the previous signature.\n\tedge.SetSigBytes(nil)\n\n\treturn nil\n}\n\n// getHtlcAmtLimits retrieves the negotiated channel min and max htlc amount\n// constraints.",
      "length": 1939,
      "tokens": 285,
      "embedding": []
    },
    {
      "slug": "func (r *Manager) getHtlcAmtLimits(tx kvdb.RTx, chanPoint wire.OutPoint) (",
      "content": "func (r *Manager) getHtlcAmtLimits(tx kvdb.RTx, chanPoint wire.OutPoint) (\n\tlnwire.MilliSatoshi, lnwire.MilliSatoshi, error) {\n\n\tch, err := r.FetchChannel(tx, chanPoint)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\t// The max htlc policy field must be less than or equal to the channel\n\t// capacity AND less than or equal to the max in-flight HTLC value.\n\t// Since the latter is always less than or equal to the former, just\n\t// return the max in-flight value.\n\tmaxAmt := ch.LocalChanCfg.ChannelConstraints.MaxPendingAmount\n\n\treturn ch.LocalChanCfg.MinHTLC, maxAmt, nil\n}\n\n// makeFailureItem creates a lnrpc.FailedUpdate object.",
      "length": 533,
      "tokens": 81,
      "embedding": []
    },
    {
      "slug": "func makeFailureItem(outPoint wire.OutPoint, updateFailure lnrpc.UpdateFailure,",
      "content": "func makeFailureItem(outPoint wire.OutPoint, updateFailure lnrpc.UpdateFailure,\n\terrStr string) *lnrpc.FailedUpdate {\n\n\toutpoint := &lnrpc.OutPoint{\n\t\tTxidBytes:   outPoint.Hash[:],\n\t\tTxidStr:     outPoint.Hash.String(),\n\t\tOutputIndex: outPoint.Index,\n\t}\n\n\treturn &lnrpc.FailedUpdate{\n\t\tOutpoint:    outpoint,\n\t\tReason:      updateFailure,\n\t\tUpdateError: errStr,\n\t}\n}\n",
      "length": 274,
      "tokens": 24,
      "embedding": []
    }
  ]
}