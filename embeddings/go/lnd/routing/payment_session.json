{
  "filepath": "../implementations/go/lnd/routing/payment_session.go",
  "package": "routing",
  "sections": [
    {
      "slug": "func ValidateCLTVLimit(limit uint32, delta uint16, includePad bool) error {",
      "content": "func ValidateCLTVLimit(limit uint32, delta uint16, includePad bool) error {\n\tif includePad {\n\t\tdelta += BlockPadding\n\t}\n\n\tif limit <= uint32(delta) {\n\t\treturn fmt.Errorf(\"cltv limit %v should be greater than %v\",\n\t\t\tlimit, delta)\n\t}\n\n\treturn nil\n}\n\n// noRouteError encodes a non-critical error encountered during path finding.",
      "length": 238,
      "tokens": 37,
      "embedding": []
    },
    {
      "slug": "type noRouteError uint8",
      "content": "type noRouteError uint8\n\nconst (\n\t// errNoTlvPayload is returned when the destination hop does not support\n\t// a tlv payload.\n\terrNoTlvPayload noRouteError = iota\n\n\t// errNoPaymentAddr is returned when the destination hop does not\n\t// support payment addresses.\n\terrNoPaymentAddr\n\n\t// errNoPathFound is returned when a path to the target destination does\n\t// not exist in the graph.\n\terrNoPathFound\n\n\t// errInsufficientLocalBalance is returned when none of the local\n\t// channels have enough balance for the payment.\n\terrInsufficientBalance\n\n\t// errEmptyPaySession is returned when the empty payment session is\n\t// queried for a route.\n\terrEmptyPaySession\n\n\t// errUnknownRequiredFeature is returned when the destination node\n\t// requires an unknown feature.\n\terrUnknownRequiredFeature\n\n\t// errMissingDependentFeature is returned when the destination node\n\t// misses a feature that a feature that we require depends on.\n\terrMissingDependentFeature\n)\n\nvar (\n\t// DefaultShardMinAmt is the default amount beyond which we won't try to\n\t// further split the payment if no route is found. It is the minimum\n\t// amount that we use as the shard size when splitting.\n\tDefaultShardMinAmt = lnwire.NewMSatFromSatoshis(10000)\n)\n\n// Error returns the string representation of the noRouteError.",
      "length": 1217,
      "tokens": 177,
      "embedding": []
    },
    {
      "slug": "func (e noRouteError) Error() string {",
      "content": "func (e noRouteError) Error() string {\n\tswitch e {\n\tcase errNoTlvPayload:\n\t\treturn \"destination hop doesn't understand new TLV payloads\"\n\n\tcase errNoPaymentAddr:\n\t\treturn \"destination hop doesn't understand payment addresses\"\n\n\tcase errNoPathFound:\n\t\treturn \"unable to find a path to destination\"\n\n\tcase errEmptyPaySession:\n\t\treturn \"empty payment session\"\n\n\tcase errInsufficientBalance:\n\t\treturn \"insufficient local balance\"\n\n\tcase errUnknownRequiredFeature:\n\t\treturn \"unknown required feature\"\n\n\tcase errMissingDependentFeature:\n\t\treturn \"missing dependent feature\"\n\n\tdefault:\n\t\treturn \"unknown no-route error\"\n\t}\n}\n\n// FailureReason converts a path finding error into a payment-level failure.",
      "length": 629,
      "tokens": 74,
      "embedding": []
    },
    {
      "slug": "func (e noRouteError) FailureReason() channeldb.FailureReason {",
      "content": "func (e noRouteError) FailureReason() channeldb.FailureReason {\n\tswitch e {\n\tcase\n\t\terrNoTlvPayload,\n\t\terrNoPaymentAddr,\n\t\terrNoPathFound,\n\t\terrEmptyPaySession,\n\t\terrUnknownRequiredFeature,\n\t\terrMissingDependentFeature:\n\n\t\treturn channeldb.FailureReasonNoRoute\n\n\tcase errInsufficientBalance:\n\t\treturn channeldb.FailureReasonInsufficientBalance\n\n\tdefault:\n\t\treturn channeldb.FailureReasonError\n\t}\n}\n\n// PaymentSession is used during SendPayment attempts to provide routes to\n// attempt. It also defines methods to give the PaymentSession additional\n// information learned during the previous attempts.",
      "length": 515,
      "tokens": 50,
      "embedding": []
    },
    {
      "slug": "type PaymentSession interface {",
      "content": "type PaymentSession interface {\n\t// RequestRoute returns the next route to attempt for routing the\n\t// specified HTLC payment to the target node. The returned route should\n\t// carry at most maxAmt to the target node, and pay at most feeLimit in\n\t// fees. It can carry less if the payment is MPP. The activeShards\n\t// argument should be set to instruct the payment session about the\n\t// number of in flight HTLCS for the payment, such that it can choose\n\t// splitting strategy accordingly.\n\t//\n\t// A noRouteError is returned if a non-critical error is encountered\n\t// during path finding.\n\tRequestRoute(maxAmt, feeLimit lnwire.MilliSatoshi,\n\t\tactiveShards, height uint32) (*route.Route, error)\n\n\t// UpdateAdditionalEdge takes an additional channel edge policy\n\t// (private channels) and applies the update from the message. Returns\n\t// a boolean to indicate whether the update has been applied without\n\t// error.\n\tUpdateAdditionalEdge(msg *lnwire.ChannelUpdate, pubKey *btcec.PublicKey,\n\t\tpolicy *channeldb.CachedEdgePolicy) bool\n\n\t// GetAdditionalEdgePolicy uses the public key and channel ID to query\n\t// the ephemeral channel edge policy for additional edges. Returns a nil\n\t// if nothing found.\n\tGetAdditionalEdgePolicy(pubKey *btcec.PublicKey,\n\t\tchannelID uint64) *channeldb.CachedEdgePolicy\n}\n\n// paymentSession is used during an HTLC routings session to prune the local\n// chain view in response to failures, and also report those failures back to\n// MissionControl. The snapshot copied for this session will only ever grow,\n// and will now be pruned after a decay like the main view within mission\n// control. We do this as we want to avoid the case where we continually try a\n// bad edge or route multiple times in a session. This can lead to an infinite\n// loop if payment attempts take long enough. An additional set of edges can\n// also be provided to assist in reaching the payment's destination.",
      "length": 1842,
      "tokens": 290,
      "embedding": []
    },
    {
      "slug": "type paymentSession struct {",
      "content": "type paymentSession struct {\n\tadditionalEdges map[route.Vertex][]*channeldb.CachedEdgePolicy\n\n\tgetBandwidthHints func(routingGraph) (bandwidthHints, error)\n\n\tpayment *LightningPayment\n\n\tempty bool\n\n\tpathFinder pathFinder\n\n\tgetRoutingGraph func() (routingGraph, func(), error)\n\n\t// pathFindingConfig defines global parameters that control the\n\t// trade-off in path finding between fees and probabiity.\n\tpathFindingConfig PathFindingConfig\n\n\tmissionControl MissionController\n\n\t// minShardAmt is the amount beyond which we won't try to further split\n\t// the payment if no route is found. If the maximum number of htlcs\n\t// specified in the payment is one, under no circumstances splitting\n\t// will happen and this value remains unused.\n\tminShardAmt lnwire.MilliSatoshi\n\n\t// log is a payment session-specific logger.\n\tlog btclog.Logger\n}\n\n// newPaymentSession instantiates a new payment session.",
      "length": 834,
      "tokens": 103,
      "embedding": []
    },
    {
      "slug": "func newPaymentSession(p *LightningPayment,",
      "content": "func newPaymentSession(p *LightningPayment,\n\tgetBandwidthHints func(routingGraph) (bandwidthHints, error),\n\tgetRoutingGraph func() (routingGraph, func(), error),\n\tmissionControl MissionController, pathFindingConfig PathFindingConfig) (\n\t*paymentSession, error) {\n\n\tedges, err := RouteHintsToEdges(p.RouteHints, p.Target)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tlogPrefix := fmt.Sprintf(\"PaymentSession(%x):\", p.Identifier())\n\n\treturn &paymentSession{\n\t\tadditionalEdges:   edges,\n\t\tgetBandwidthHints: getBandwidthHints,\n\t\tpayment:           p,\n\t\tpathFinder:        findPath,\n\t\tgetRoutingGraph:   getRoutingGraph,\n\t\tpathFindingConfig: pathFindingConfig,\n\t\tmissionControl:    missionControl,\n\t\tminShardAmt:       DefaultShardMinAmt,\n\t\tlog:               build.NewPrefixLog(logPrefix, log),\n\t}, nil\n}\n\n// RequestRoute returns a route which is likely to be capable for successfully\n// routing the specified HTLC payment to the target node. Initially the first\n// set of paths returned from this method may encounter routing failure along\n// the way, however as more payments are sent, mission control will start to\n// build an up to date view of the network itself. With each payment a new area\n// will be explored, which feeds into the recommendations made for routing.\n//\n// NOTE: This function is safe for concurrent access.\n// NOTE: Part of the PaymentSession interface.",
      "length": 1292,
      "tokens": 158,
      "embedding": []
    },
    {
      "slug": "func (p *paymentSession) RequestRoute(maxAmt, feeLimit lnwire.MilliSatoshi,",
      "content": "func (p *paymentSession) RequestRoute(maxAmt, feeLimit lnwire.MilliSatoshi,\n\tactiveShards, height uint32) (*route.Route, error) {\n\n\tif p.empty {\n\t\treturn nil, errEmptyPaySession\n\t}\n\n\t// Add BlockPadding to the finalCltvDelta so that the receiving node\n\t// does not reject the HTLC if some blocks are mined while it's in-flight.\n\tfinalCltvDelta := p.payment.FinalCLTVDelta\n\tfinalCltvDelta += BlockPadding\n\n\t// We need to subtract the final delta before passing it into path\n\t// finding. The optimal path is independent of the final cltv delta and\n\t// the path finding algorithm is unaware of this value.\n\tcltvLimit := p.payment.CltvLimit - uint32(finalCltvDelta)\n\n\t// TODO(roasbeef): sync logic amongst dist sys\n\n\t// Taking into account this prune view, we'll attempt to locate a path\n\t// to our destination, respecting the recommendations from\n\t// MissionControl.\n\trestrictions := &RestrictParams{\n\t\tProbabilitySource:  p.missionControl.GetProbability,\n\t\tFeeLimit:           feeLimit,\n\t\tOutgoingChannelIDs: p.payment.OutgoingChannelIDs,\n\t\tLastHop:            p.payment.LastHop,\n\t\tCltvLimit:          cltvLimit,\n\t\tDestCustomRecords:  p.payment.DestCustomRecords,\n\t\tDestFeatures:       p.payment.DestFeatures,\n\t\tPaymentAddr:        p.payment.PaymentAddr,\n\t\tMetadata:           p.payment.Metadata,\n\t}\n\n\tfinalHtlcExpiry := int32(height) + int32(finalCltvDelta)\n\n\t// Before we enter the loop below, we'll make sure to respect the max\n\t// payment shard size (if it's set), which is effectively our\n\t// client-side MTU that we'll attempt to respect at all times.\n\tmaxShardActive := p.payment.MaxShardAmt != nil\n\tif maxShardActive && maxAmt > *p.payment.MaxShardAmt {\n\t\tp.log.Debug(\"Clamping payment attempt from %v to %v due to \"+\n\t\t\t\"max shard size of %v\", maxAmt,\n\t\t\t*p.payment.MaxShardAmt, maxAmt)\n\n\t\tmaxAmt = *p.payment.MaxShardAmt\n\t}\n\n\tfor {\n\t\t// Get a routing graph.\n\t\troutingGraph, cleanup, err := p.getRoutingGraph()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// We'll also obtain a set of bandwidthHints from the lower\n\t\t// layer for each of our outbound channels. This will allow the\n\t\t// path finding to skip any links that aren't active or just\n\t\t// don't have enough bandwidth to carry the payment. New\n\t\t// bandwidth hints are queried for every new path finding\n\t\t// attempt, because concurrent payments may change balances.\n\t\tbandwidthHints, err := p.getBandwidthHints(routingGraph)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tp.log.Debugf(\"pathfinding for amt=%v\", maxAmt)\n\n\t\tsourceVertex := routingGraph.sourceNode()\n\n\t\t// Find a route for the current amount.\n\t\tpath, _, err := p.pathFinder(\n\t\t\t&graphParams{\n\t\t\t\tadditionalEdges: p.additionalEdges,\n\t\t\t\tbandwidthHints:  bandwidthHints,\n\t\t\t\tgraph:           routingGraph,\n\t\t\t},\n\t\t\trestrictions, &p.pathFindingConfig,\n\t\t\tsourceVertex, p.payment.Target,\n\t\t\tmaxAmt, p.payment.TimePref, finalHtlcExpiry,\n\t\t)\n\n\t\t// Close routing graph.\n\t\tcleanup()\n\n\t\tswitch {\n\t\tcase err == errNoPathFound:\n\t\t\t// Don't split if this is a legacy payment without mpp\n\t\t\t// record.\n\t\t\tif p.payment.PaymentAddr == nil {\n\t\t\t\tp.log.Debugf(\"not splitting because payment \" +\n\t\t\t\t\t\"address is unspecified\")\n\n\t\t\t\treturn nil, errNoPathFound\n\t\t\t}\n\n\t\t\tif p.payment.DestFeatures == nil {\n\t\t\t\tp.log.Debug(\"Not splitting because \" +\n\t\t\t\t\t\"destination DestFeatures is nil\")\n\t\t\t\treturn nil, errNoPathFound\n\t\t\t}\n\n\t\t\tdestFeatures := p.payment.DestFeatures\n\t\t\tif !destFeatures.HasFeature(lnwire.MPPOptional) &&\n\t\t\t\t!destFeatures.HasFeature(lnwire.AMPOptional) {\n\n\t\t\t\tp.log.Debug(\"not splitting because \" +\n\t\t\t\t\t\"destination doesn't declare MPP or AMP\")\n\n\t\t\t\treturn nil, errNoPathFound\n\t\t\t}\n\n\t\t\t// No splitting if this is the last shard.\n\t\t\tisLastShard := activeShards+1 >= p.payment.MaxParts\n\t\t\tif isLastShard {\n\t\t\t\tp.log.Debugf(\"not splitting because shard \"+\n\t\t\t\t\t\"limit %v has been reached\",\n\t\t\t\t\tp.payment.MaxParts)\n\n\t\t\t\treturn nil, errNoPathFound\n\t\t\t}\n\n\t\t\t// This is where the magic happens. If we can't find a\n\t\t\t// route, try it for half the amount.\n\t\t\tmaxAmt /= 2\n\n\t\t\t// Put a lower bound on the minimum shard size.\n\t\t\tif maxAmt < p.minShardAmt {\n\t\t\t\tp.log.Debugf(\"not splitting because minimum \"+\n\t\t\t\t\t\"shard amount %v has been reached\",\n\t\t\t\t\tp.minShardAmt)\n\n\t\t\t\treturn nil, errNoPathFound\n\t\t\t}\n\n\t\t\t// Go pathfinding.\n\t\t\tcontinue\n\n\t\t// If there isn't enough local bandwidth, there is no point in\n\t\t// splitting. It won't be possible to create a complete set in\n\t\t// any case, but the sent out partial payments would be held by\n\t\t// the receiver until the mpp timeout.\n\t\tcase err == errInsufficientBalance:\n\t\t\tp.log.Debug(\"not splitting because local balance \" +\n\t\t\t\t\"is insufficient\")\n\n\t\t\treturn nil, err\n\n\t\tcase err != nil:\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// With the next candidate path found, we'll attempt to turn\n\t\t// this into a route by applying the time-lock and fee\n\t\t// requirements.\n\t\troute, err := newRoute(\n\t\t\tsourceVertex, path, height,\n\t\t\tfinalHopParams{\n\t\t\t\tamt:         maxAmt,\n\t\t\t\ttotalAmt:    p.payment.Amount,\n\t\t\t\tcltvDelta:   finalCltvDelta,\n\t\t\t\trecords:     p.payment.DestCustomRecords,\n\t\t\t\tpaymentAddr: p.payment.PaymentAddr,\n\t\t\t\tmetadata:    p.payment.Metadata,\n\t\t\t},\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn route, err\n\t}\n}\n\n// UpdateAdditionalEdge updates the channel edge policy for a private edge. It\n// validates the message signature and checks it's up to date, then applies the\n// updates to the supplied policy. It returns a boolean to indicate whether\n// there's an error when applying the updates.",
      "length": 5214,
      "tokens": 693,
      "embedding": []
    },
    {
      "slug": "func (p *paymentSession) UpdateAdditionalEdge(msg *lnwire.ChannelUpdate,",
      "content": "func (p *paymentSession) UpdateAdditionalEdge(msg *lnwire.ChannelUpdate,\n\tpubKey *btcec.PublicKey, policy *channeldb.CachedEdgePolicy) bool {\n\n\t// Validate the message signature.\n\tif err := VerifyChannelUpdateSignature(msg, pubKey); err != nil {\n\t\tlog.Errorf(\n\t\t\t\"Unable to validate channel update signature: %v\", err,\n\t\t)\n\t\treturn false\n\t}\n\n\t// Update channel policy for the additional edge.\n\tpolicy.TimeLockDelta = msg.TimeLockDelta\n\tpolicy.FeeBaseMSat = lnwire.MilliSatoshi(msg.BaseFee)\n\tpolicy.FeeProportionalMillionths = lnwire.MilliSatoshi(msg.FeeRate)\n\n\tlog.Debugf(\"New private channel update applied: %v\",\n\t\tnewLogClosure(func() string { return spew.Sdump(msg) }))\n\n\treturn true\n}\n\n// GetAdditionalEdgePolicy uses the public key and channel ID to query the\n// ephemeral channel edge policy for additional edges. Returns a nil if nothing\n// found.",
      "length": 758,
      "tokens": 92,
      "embedding": []
    },
    {
      "slug": "func (p *paymentSession) GetAdditionalEdgePolicy(pubKey *btcec.PublicKey,",
      "content": "func (p *paymentSession) GetAdditionalEdgePolicy(pubKey *btcec.PublicKey,\n\tchannelID uint64) *channeldb.CachedEdgePolicy {\n\n\ttarget := route.NewVertex(pubKey)\n\n\tedges, ok := p.additionalEdges[target]\n\tif !ok {\n\t\treturn nil\n\t}\n\n\tfor _, edge := range edges {\n\t\tif edge.ChannelID != channelID {\n\t\t\tcontinue\n\t\t}\n\n\t\treturn edge\n\t}\n\n\treturn nil\n}\n",
      "length": 248,
      "tokens": 37,
      "embedding": []
    }
  ]
}