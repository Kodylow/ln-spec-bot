{
  "filepath": "../implementations/go/lnd/routing/pathfind_test.go",
  "package": "routing",
  "sections": [
    {
      "slug": "func noProbabilitySource(route.Vertex, route.Vertex, lnwire.MilliSatoshi,",
      "content": "func noProbabilitySource(route.Vertex, route.Vertex, lnwire.MilliSatoshi,\n\tbtcutil.Amount) float64 {\n\n\treturn 1\n}\n\n// testGraph is the struct which corresponds to the JSON format used to encode\n// graphs within the files in the testdata directory.\n//\n// TODO(roasbeef): add test graph auto-generator",
      "length": 217,
      "tokens": 36,
      "embedding": []
    },
    {
      "slug": "type testGraph struct {",
      "content": "type testGraph struct {\n\tInfo  []string   `json:\"info\"`\n\tNodes []testNode `json:\"nodes\"`\n\tEdges []testChan `json:\"edges\"`\n}\n\n// testNode represents a node within the test graph above. We skip certain\n// information such as the node's IP address as that information isn't needed\n// for our tests. Private keys are optional. If set, they should be consistent\n// with the public key. The private key is used to sign error messages\n// sent from the node.",
      "length": 417,
      "tokens": 69,
      "embedding": []
    },
    {
      "slug": "type testNode struct {",
      "content": "type testNode struct {\n\tSource  bool   `json:\"source\"`\n\tPubKey  string `json:\"pubkey\"`\n\tPrivKey string `json:\"privkey\"`\n\tAlias   string `json:\"alias\"`\n}\n\n// testChan represents the JSON version of a payment channel. This struct\n// matches the Json that's encoded under the \"edges\" key within the test graph.",
      "length": 277,
      "tokens": 39,
      "embedding": []
    },
    {
      "slug": "type testChan struct {",
      "content": "type testChan struct {\n\tNode1        string `json:\"node_1\"`\n\tNode2        string `json:\"node_2\"`\n\tChannelID    uint64 `json:\"channel_id\"`\n\tChannelPoint string `json:\"channel_point\"`\n\tChannelFlags uint8  `json:\"channel_flags\"`\n\tMessageFlags uint8  `json:\"message_flags\"`\n\tExpiry       uint16 `json:\"expiry\"`\n\tMinHTLC      int64  `json:\"min_htlc\"`\n\tMaxHTLC      int64  `json:\"max_htlc\"`\n\tFeeBaseMsat  int64  `json:\"fee_base_msat\"`\n\tFeeRate      int64  `json:\"fee_rate\"`\n\tCapacity     int64  `json:\"capacity\"`\n}\n\n// makeTestGraph creates a new instance of a channeldb.ChannelGraph for testing\n// purposes.",
      "length": 564,
      "tokens": 50,
      "embedding": []
    },
    {
      "slug": "func makeTestGraph(t *testing.T, useCache bool) (*channeldb.ChannelGraph,",
      "content": "func makeTestGraph(t *testing.T, useCache bool) (*channeldb.ChannelGraph,\n\tkvdb.Backend, error) {\n\n\t// Create channelgraph for the first time.\n\tbackend, backendCleanup, err := kvdb.GetTestBackend(t.TempDir(), \"cgr\")\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tt.Cleanup(backendCleanup)\n\n\topts := channeldb.DefaultOptions()\n\tgraph, err := channeldb.NewChannelGraph(\n\t\tbackend, opts.RejectCacheSize, opts.ChannelCacheSize,\n\t\topts.BatchCommitInterval, opts.PreAllocCacheNumNodes,\n\t\tuseCache, false,\n\t)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn graph, backend, nil\n}\n\n// parseTestGraph returns a fully populated ChannelGraph given a path to a JSON\n// file which encodes a test graph.",
      "length": 592,
      "tokens": 77,
      "embedding": []
    },
    {
      "slug": "func parseTestGraph(t *testing.T, useCache bool, path string) (",
      "content": "func parseTestGraph(t *testing.T, useCache bool, path string) (\n\t*testGraphInstance, error) {\n\n\tgraphJSON, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// First unmarshal the JSON graph into an instance of the testGraph\n\t// struct. Using the struct tags created above in the struct, the JSON\n\t// will be properly parsed into the struct above.\n\tvar g testGraph\n\tif err := json.Unmarshal(graphJSON, &g); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// We'll use this fake address for the IP address of all the nodes in\n\t// our tests. This value isn't needed for path finding so it doesn't\n\t// need to be unique.\n\tvar testAddrs []net.Addr\n\ttestAddr, err := net.ResolveTCPAddr(\"tcp\", \"192.0.0.1:8888\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttestAddrs = append(testAddrs, testAddr)\n\n\t// Next, create a temporary graph database for usage within the test.\n\tgraph, graphBackend, err := makeTestGraph(t, useCache)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\taliasMap := make(map[string]route.Vertex)\n\tprivKeyMap := make(map[string]*btcec.PrivateKey)\n\tchannelIDs := make(map[route.Vertex]map[route.Vertex]uint64)\n\tlinks := make(map[lnwire.ShortChannelID]htlcswitch.ChannelLink)\n\tvar source *channeldb.LightningNode\n\n\t// First we insert all the nodes within the graph as vertexes.\n\tfor _, node := range g.Nodes {\n\t\tpubBytes, err := hex.DecodeString(node.PubKey)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tdbNode := &channeldb.LightningNode{\n\t\t\tHaveNodeAnnouncement: true,\n\t\t\tAuthSigBytes:         testSig.Serialize(),\n\t\t\tLastUpdate:           testTime,\n\t\t\tAddresses:            testAddrs,\n\t\t\tAlias:                node.Alias,\n\t\t\tFeatures:             testFeatures,\n\t\t}\n\t\tcopy(dbNode.PubKeyBytes[:], pubBytes)\n\n\t\t// We require all aliases within the graph to be unique for our\n\t\t// tests.\n\t\tif _, ok := aliasMap[node.Alias]; ok {\n\t\t\treturn nil, errors.New(\"aliases for nodes \" +\n\t\t\t\t\"must be unique!\")\n\t\t}\n\n\t\t// If the alias is unique, then add the node to the\n\t\t// alias map for easy lookup.\n\t\taliasMap[node.Alias] = dbNode.PubKeyBytes\n\n\t\t// private keys are needed for signing error messages. If set\n\t\t// check the consistency with the public key.\n\t\tprivBytes, err := hex.DecodeString(node.PrivKey)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif len(privBytes) > 0 {\n\t\t\tkey, derivedPub := btcec.PrivKeyFromBytes(\n\t\t\t\tprivBytes,\n\t\t\t)\n\n\t\t\tif !bytes.Equal(\n\t\t\t\tpubBytes, derivedPub.SerializeCompressed(),\n\t\t\t) {\n\n\t\t\t\treturn nil, fmt.Errorf(\"%s public key and \"+\n\t\t\t\t\t\"private key are inconsistent\\n\"+\n\t\t\t\t\t\"got  %x\\nwant %x\\n\",\n\t\t\t\t\tnode.Alias,\n\t\t\t\t\tderivedPub.SerializeCompressed(),\n\t\t\t\t\tpubBytes,\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tprivKeyMap[node.Alias] = key\n\t\t}\n\n\t\t// If the node is tagged as the source, then we create a\n\t\t// pointer to is so we can mark the source in the graph\n\t\t// properly.\n\t\tif node.Source {\n\t\t\t// If we come across a node that's marked as the\n\t\t\t// source, and we've already set the source in a prior\n\t\t\t// iteration, then the JSON has an error as only ONE\n\t\t\t// node can be the source in the graph.\n\t\t\tif source != nil {\n\t\t\t\treturn nil, errors.New(\"JSON is invalid \" +\n\t\t\t\t\t\"multiple nodes are tagged as the \" +\n\t\t\t\t\t\"source\")\n\t\t\t}\n\n\t\t\tsource = dbNode\n\t\t}\n\n\t\t// With the node fully parsed, add it as a vertex within the\n\t\t// graph.\n\t\tif err := graph.AddLightningNode(dbNode); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif source != nil {\n\t\t// Set the selected source node\n\t\tif err := graph.SetSourceNode(source); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\taliasForNode := func(node route.Vertex) string {\n\t\tfor alias, pubKey := range aliasMap {\n\t\t\tif pubKey == node {\n\t\t\t\treturn alias\n\t\t\t}\n\t\t}\n\n\t\treturn \"\"\n\t}\n\n\t// With all the vertexes inserted, we can now insert the edges into the\n\t// test graph.\n\tfor _, edge := range g.Edges {\n\t\tnode1Bytes, err := hex.DecodeString(edge.Node1)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tnode2Bytes, err := hex.DecodeString(edge.Node2)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif bytes.Compare(node1Bytes, node2Bytes) == 1 {\n\t\t\treturn nil, fmt.Errorf(\n\t\t\t\t\"channel %v node order incorrect\",\n\t\t\t\tedge.ChannelID,\n\t\t\t)\n\t\t}\n\n\t\tfundingTXID := strings.Split(edge.ChannelPoint, \":\")[0]\n\t\ttxidBytes, err := chainhash.NewHashFromStr(fundingTXID)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfundingPoint := wire.OutPoint{\n\t\t\tHash:  *txidBytes,\n\t\t\tIndex: 0,\n\t\t}\n\n\t\t// We first insert the existence of the edge between the two\n\t\t// nodes.\n\t\tedgeInfo := channeldb.ChannelEdgeInfo{\n\t\t\tChannelID:    edge.ChannelID,\n\t\t\tAuthProof:    &testAuthProof,\n\t\t\tChannelPoint: fundingPoint,\n\t\t\tCapacity:     btcutil.Amount(edge.Capacity),\n\t\t}\n\n\t\tcopy(edgeInfo.NodeKey1Bytes[:], node1Bytes)\n\t\tcopy(edgeInfo.NodeKey2Bytes[:], node2Bytes)\n\t\tcopy(edgeInfo.BitcoinKey1Bytes[:], node1Bytes)\n\t\tcopy(edgeInfo.BitcoinKey2Bytes[:], node2Bytes)\n\n\t\tshortID := lnwire.NewShortChanIDFromInt(edge.ChannelID)\n\t\tlinks[shortID] = &mockLink{\n\t\t\tbandwidth: lnwire.MilliSatoshi(\n\t\t\t\tedgeInfo.Capacity * 1000,\n\t\t\t),\n\t\t}\n\n\t\terr = graph.AddChannelEdge(&edgeInfo)\n\t\tif err != nil && err != channeldb.ErrEdgeAlreadyExist {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tchannelFlags := lnwire.ChanUpdateChanFlags(edge.ChannelFlags)\n\t\tisUpdate1 := channelFlags&lnwire.ChanUpdateDirection == 0\n\t\ttargetNode := edgeInfo.NodeKey1Bytes\n\t\tif isUpdate1 {\n\t\t\ttargetNode = edgeInfo.NodeKey2Bytes\n\t\t}\n\n\t\tedgePolicy := &channeldb.ChannelEdgePolicy{\n\t\t\tSigBytes:                  testSig.Serialize(),\n\t\t\tMessageFlags:              lnwire.ChanUpdateMsgFlags(edge.MessageFlags),\n\t\t\tChannelFlags:              channelFlags,\n\t\t\tChannelID:                 edge.ChannelID,\n\t\t\tLastUpdate:                testTime,\n\t\t\tTimeLockDelta:             edge.Expiry,\n\t\t\tMinHTLC:                   lnwire.MilliSatoshi(edge.MinHTLC),\n\t\t\tMaxHTLC:                   lnwire.MilliSatoshi(edge.MaxHTLC),\n\t\t\tFeeBaseMSat:               lnwire.MilliSatoshi(edge.FeeBaseMsat),\n\t\t\tFeeProportionalMillionths: lnwire.MilliSatoshi(edge.FeeRate),\n\t\t\tNode: &channeldb.LightningNode{\n\t\t\t\tAlias:       aliasForNode(targetNode),\n\t\t\t\tPubKeyBytes: targetNode,\n\t\t\t},\n\t\t}\n\t\tif err := graph.UpdateEdgePolicy(edgePolicy); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// We also store the channel IDs info for each of the node.\n\t\tnode1Vertex, err := route.NewVertexFromBytes(node1Bytes)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tnode2Vertex, err := route.NewVertexFromBytes(node2Bytes)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif _, ok := channelIDs[node1Vertex]; !ok {\n\t\t\tchannelIDs[node1Vertex] = map[route.Vertex]uint64{}\n\t\t}\n\t\tchannelIDs[node1Vertex][node2Vertex] = edge.ChannelID\n\n\t\tif _, ok := channelIDs[node2Vertex]; !ok {\n\t\t\tchannelIDs[node2Vertex] = map[route.Vertex]uint64{}\n\t\t}\n\t\tchannelIDs[node2Vertex][node1Vertex] = edge.ChannelID\n\t}\n\n\treturn &testGraphInstance{\n\t\tgraph:        graph,\n\t\tgraphBackend: graphBackend,\n\t\taliasMap:     aliasMap,\n\t\tprivKeyMap:   privKeyMap,\n\t\tchannelIDs:   channelIDs,\n\t\tlinks:        links,\n\t}, nil\n}\n",
      "length": 6548,
      "tokens": 815,
      "embedding": []
    },
    {
      "slug": "type testChannelPolicy struct {",
      "content": "type testChannelPolicy struct {\n\tExpiry      uint16\n\tMinHTLC     lnwire.MilliSatoshi\n\tMaxHTLC     lnwire.MilliSatoshi\n\tFeeBaseMsat lnwire.MilliSatoshi\n\tFeeRate     lnwire.MilliSatoshi\n\tLastUpdate  time.Time\n\tDisabled    bool\n\tFeatures    *lnwire.FeatureVector\n}\n",
      "length": 221,
      "tokens": 17,
      "embedding": []
    },
    {
      "slug": "type testChannelEnd struct {",
      "content": "type testChannelEnd struct {\n\tAlias string\n\t*testChannelPolicy\n}\n",
      "length": 33,
      "tokens": 4,
      "embedding": []
    },
    {
      "slug": "func symmetricTestChannel(alias1, alias2 string, capacity btcutil.Amount,",
      "content": "func symmetricTestChannel(alias1, alias2 string, capacity btcutil.Amount,\n\tpolicy *testChannelPolicy, chanID ...uint64) *testChannel {\n\n\t// Leaving id zero will result in auto-generation of a channel id during\n\t// graph construction.\n\tvar id uint64\n\tif len(chanID) > 0 {\n\t\tid = chanID[0]\n\t}\n\n\tpolicy2 := *policy\n\n\treturn asymmetricTestChannel(\n\t\talias1, alias2, capacity, policy, &policy2, id,\n\t)\n}\n",
      "length": 310,
      "tokens": 47,
      "embedding": []
    },
    {
      "slug": "func asymmetricTestChannel(alias1, alias2 string, capacity btcutil.Amount,",
      "content": "func asymmetricTestChannel(alias1, alias2 string, capacity btcutil.Amount,\n\tpolicy1, policy2 *testChannelPolicy, id uint64) *testChannel {\n\n\treturn &testChannel{\n\t\tCapacity: capacity,\n\t\tNode1: &testChannelEnd{\n\t\t\tAlias:             alias1,\n\t\t\ttestChannelPolicy: policy1,\n\t\t},\n\t\tNode2: &testChannelEnd{\n\t\t\tAlias:             alias2,\n\t\t\ttestChannelPolicy: policy2,\n\t\t},\n\t\tChannelID: id,\n\t}\n}\n",
      "length": 300,
      "tokens": 29,
      "embedding": []
    },
    {
      "slug": "type testChannel struct {",
      "content": "type testChannel struct {\n\tNode1     *testChannelEnd\n\tNode2     *testChannelEnd\n\tCapacity  btcutil.Amount\n\tChannelID uint64\n}\n",
      "length": 95,
      "tokens": 9,
      "embedding": []
    },
    {
      "slug": "type testGraphInstance struct {",
      "content": "type testGraphInstance struct {\n\tgraph        *channeldb.ChannelGraph\n\tgraphBackend kvdb.Backend\n\n\t// aliasMap is a map from a node's alias to its public key. This type is\n\t// provided in order to allow easily look up from the human memorable alias\n\t// to an exact node's public key.\n\taliasMap map[string]route.Vertex\n\n\t// privKeyMap maps a node alias to its private key. This is used to be\n\t// able to mock a remote node's signing behaviour.\n\tprivKeyMap map[string]*btcec.PrivateKey\n\n\t// channelIDs stores the channel ID for each node.\n\tchannelIDs map[route.Vertex]map[route.Vertex]uint64\n\n\t// links maps channel ids to a mock channel update handler.\n\tlinks map[lnwire.ShortChannelID]htlcswitch.ChannelLink\n}\n\n// getLink is a mocked link lookup function which looks up links in our test\n// graph.",
      "length": 745,
      "tokens": 111,
      "embedding": []
    },
    {
      "slug": "func (g *testGraphInstance) getLink(chanID lnwire.ShortChannelID) (",
      "content": "func (g *testGraphInstance) getLink(chanID lnwire.ShortChannelID) (\n\thtlcswitch.ChannelLink, error) {\n\n\tlink, ok := g.links[chanID]\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"link not found in mock: %v\", chanID)\n\t}\n\n\treturn link, nil\n}\n\n// createTestGraphFromChannels returns a fully populated ChannelGraph based on a set of\n// test channels. Additional required information like keys are derived in\n// a deterministical way and added to the channel graph. A list of nodes is\n// not required and derived from the channel data. The goal is to keep\n// instantiating a test channel graph as light weight as possible.",
      "length": 524,
      "tokens": 87,
      "embedding": []
    },
    {
      "slug": "func createTestGraphFromChannels(t *testing.T, useCache bool,",
      "content": "func createTestGraphFromChannels(t *testing.T, useCache bool,\n\ttestChannels []*testChannel, source string) (*testGraphInstance, error) {\n\n\t// We'll use this fake address for the IP address of all the nodes in\n\t// our tests. This value isn't needed for path finding so it doesn't\n\t// need to be unique.\n\tvar testAddrs []net.Addr\n\ttestAddr, err := net.ResolveTCPAddr(\"tcp\", \"192.0.0.1:8888\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttestAddrs = append(testAddrs, testAddr)\n\n\t// Next, create a temporary graph database for usage within the test.\n\tgraph, graphBackend, err := makeTestGraph(t, useCache)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\taliasMap := make(map[string]route.Vertex)\n\tprivKeyMap := make(map[string]*btcec.PrivateKey)\n\n\tnodeIndex := byte(0)\n\taddNodeWithAlias := func(alias string, features *lnwire.FeatureVector) (\n\t\t*channeldb.LightningNode, error) {\n\n\t\tkeyBytes := []byte{\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, nodeIndex + 1,\n\t\t}\n\n\t\tprivKey, pubKey := btcec.PrivKeyFromBytes(keyBytes)\n\n\t\tif features == nil {\n\t\t\tfeatures = lnwire.EmptyFeatureVector()\n\t\t}\n\n\t\tdbNode := &channeldb.LightningNode{\n\t\t\tHaveNodeAnnouncement: true,\n\t\t\tAuthSigBytes:         testSig.Serialize(),\n\t\t\tLastUpdate:           testTime,\n\t\t\tAddresses:            testAddrs,\n\t\t\tAlias:                alias,\n\t\t\tFeatures:             features,\n\t\t}\n\n\t\tcopy(dbNode.PubKeyBytes[:], pubKey.SerializeCompressed())\n\n\t\tprivKeyMap[alias] = privKey\n\n\t\t// With the node fully parsed, add it as a vertex within the\n\t\t// graph.\n\t\tif err := graph.AddLightningNode(dbNode); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\taliasMap[alias] = dbNode.PubKeyBytes\n\t\tnodeIndex++\n\n\t\treturn dbNode, nil\n\t}\n\n\t// Add the source node.\n\tdbNode, err := addNodeWithAlias(source, lnwire.EmptyFeatureVector())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err = graph.SetSourceNode(dbNode); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Initialize variable that keeps track of the next channel id to assign\n\t// if none is specified.\n\tnextUnassignedChannelID := uint64(100000)\n\n\tlinks := make(map[lnwire.ShortChannelID]htlcswitch.ChannelLink)\n\n\tfor _, testChannel := range testChannels {\n\t\tfor _, node := range []*testChannelEnd{\n\t\t\ttestChannel.Node1, testChannel.Node2,\n\t\t} {\n\t\t\t_, exists := aliasMap[node.Alias]\n\t\t\tif !exists {\n\t\t\t\tvar features *lnwire.FeatureVector\n\t\t\t\tif node.testChannelPolicy != nil {\n\t\t\t\t\tfeatures =\n\t\t\t\t\t\tnode.testChannelPolicy.Features\n\t\t\t\t}\n\t\t\t\t_, err := addNodeWithAlias(\n\t\t\t\t\tnode.Alias, features,\n\t\t\t\t)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tchannelID := testChannel.ChannelID\n\n\t\t// If no channel id is specified, generate an id.\n\t\tif channelID == 0 {\n\t\t\tchannelID = nextUnassignedChannelID\n\t\t\tnextUnassignedChannelID++\n\t\t}\n\n\t\tvar hash [sha256.Size]byte\n\t\thash[len(hash)-1] = byte(channelID)\n\n\t\tfundingPoint := &wire.OutPoint{\n\t\t\tHash:  chainhash.Hash(hash),\n\t\t\tIndex: 0,\n\t\t}\n\n\t\tcapacity := lnwire.MilliSatoshi(testChannel.Capacity * 1000)\n\t\tshortID := lnwire.NewShortChanIDFromInt(channelID)\n\t\tlinks[shortID] = &mockLink{\n\t\t\tbandwidth: capacity,\n\t\t}\n\n\t\t// Sort nodes\n\t\tnode1 := testChannel.Node1\n\t\tnode2 := testChannel.Node2\n\t\tnode1Vertex := aliasMap[node1.Alias]\n\t\tnode2Vertex := aliasMap[node2.Alias]\n\t\tif bytes.Compare(node1Vertex[:], node2Vertex[:]) == 1 {\n\t\t\tnode1, node2 = node2, node1\n\t\t\tnode1Vertex, node2Vertex = node2Vertex, node1Vertex\n\t\t}\n\n\t\t// We first insert the existence of the edge between the two\n\t\t// nodes.\n\t\tedgeInfo := channeldb.ChannelEdgeInfo{\n\t\t\tChannelID:    channelID,\n\t\t\tAuthProof:    &testAuthProof,\n\t\t\tChannelPoint: *fundingPoint,\n\t\t\tCapacity:     testChannel.Capacity,\n\n\t\t\tNodeKey1Bytes:    node1Vertex,\n\t\t\tBitcoinKey1Bytes: node1Vertex,\n\t\t\tNodeKey2Bytes:    node2Vertex,\n\t\t\tBitcoinKey2Bytes: node2Vertex,\n\t\t}\n\n\t\terr = graph.AddChannelEdge(&edgeInfo)\n\t\tif err != nil && err != channeldb.ErrEdgeAlreadyExist {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif node1.testChannelPolicy != nil {\n\t\t\tvar msgFlags lnwire.ChanUpdateMsgFlags\n\t\t\tif node1.MaxHTLC != 0 {\n\t\t\t\tmsgFlags |= lnwire.ChanUpdateRequiredMaxHtlc\n\t\t\t}\n\t\t\tvar channelFlags lnwire.ChanUpdateChanFlags\n\t\t\tif node1.Disabled {\n\t\t\t\tchannelFlags |= lnwire.ChanUpdateDisabled\n\t\t\t}\n\n\t\t\tnode2Features := lnwire.EmptyFeatureVector()\n\t\t\tif node2.testChannelPolicy != nil {\n\t\t\t\tnode2Features = node2.Features\n\t\t\t}\n\n\t\t\tedgePolicy := &channeldb.ChannelEdgePolicy{\n\t\t\t\tSigBytes:                  testSig.Serialize(),\n\t\t\t\tMessageFlags:              msgFlags,\n\t\t\t\tChannelFlags:              channelFlags,\n\t\t\t\tChannelID:                 channelID,\n\t\t\t\tLastUpdate:                node1.LastUpdate,\n\t\t\t\tTimeLockDelta:             node1.Expiry,\n\t\t\t\tMinHTLC:                   node1.MinHTLC,\n\t\t\t\tMaxHTLC:                   node1.MaxHTLC,\n\t\t\t\tFeeBaseMSat:               node1.FeeBaseMsat,\n\t\t\t\tFeeProportionalMillionths: node1.FeeRate,\n\t\t\t\tNode: &channeldb.LightningNode{\n\t\t\t\t\tAlias:       node2.Alias,\n\t\t\t\t\tPubKeyBytes: node2Vertex,\n\t\t\t\t\tFeatures:    node2Features,\n\t\t\t\t},\n\t\t\t}\n\t\t\tif err := graph.UpdateEdgePolicy(edgePolicy); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\tif node2.testChannelPolicy != nil {\n\t\t\tvar msgFlags lnwire.ChanUpdateMsgFlags\n\t\t\tif node2.MaxHTLC != 0 {\n\t\t\t\tmsgFlags |= lnwire.ChanUpdateRequiredMaxHtlc\n\t\t\t}\n\t\t\tvar channelFlags lnwire.ChanUpdateChanFlags\n\t\t\tif node2.Disabled {\n\t\t\t\tchannelFlags |= lnwire.ChanUpdateDisabled\n\t\t\t}\n\t\t\tchannelFlags |= lnwire.ChanUpdateDirection\n\n\t\t\tnode1Features := lnwire.EmptyFeatureVector()\n\t\t\tif node1.testChannelPolicy != nil {\n\t\t\t\tnode1Features = node1.Features\n\t\t\t}\n\n\t\t\tedgePolicy := &channeldb.ChannelEdgePolicy{\n\t\t\t\tSigBytes:                  testSig.Serialize(),\n\t\t\t\tMessageFlags:              msgFlags,\n\t\t\t\tChannelFlags:              channelFlags,\n\t\t\t\tChannelID:                 channelID,\n\t\t\t\tLastUpdate:                node2.LastUpdate,\n\t\t\t\tTimeLockDelta:             node2.Expiry,\n\t\t\t\tMinHTLC:                   node2.MinHTLC,\n\t\t\t\tMaxHTLC:                   node2.MaxHTLC,\n\t\t\t\tFeeBaseMSat:               node2.FeeBaseMsat,\n\t\t\t\tFeeProportionalMillionths: node2.FeeRate,\n\t\t\t\tNode: &channeldb.LightningNode{\n\t\t\t\t\tAlias:       node1.Alias,\n\t\t\t\t\tPubKeyBytes: node1Vertex,\n\t\t\t\t\tFeatures:    node1Features,\n\t\t\t\t},\n\t\t\t}\n\t\t\tif err := graph.UpdateEdgePolicy(edgePolicy); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\tchannelID++\n\t}\n\n\treturn &testGraphInstance{\n\t\tgraph:        graph,\n\t\tgraphBackend: graphBackend,\n\t\taliasMap:     aliasMap,\n\t\tprivKeyMap:   privKeyMap,\n\t\tlinks:        links,\n\t}, nil\n}\n\n// TestPathFinding tests all path finding related cases both with the in-memory\n// graph cached turned on and off.",
      "length": 6267,
      "tokens": 665,
      "embedding": []
    },
    {
      "slug": "func TestPathFinding(t *testing.T) {",
      "content": "func TestPathFinding(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tfn   func(t *testing.T, useCache bool)\n\t}{{\n\t\tname: \"lowest fee path\",\n\t\tfn:   runFindLowestFeePath,\n\t}, {\n\t\tname: \"basic graph path finding\",\n\t\tfn:   runBasicGraphPathFinding,\n\t}, {\n\t\tname: \"path finding with additional edges\",\n\t\tfn:   runPathFindingWithAdditionalEdges,\n\t}, {\n\t\tname: \"path finding with redundant additional edges\",\n\t\tfn:   runPathFindingWithRedundantAdditionalEdges,\n\t}, {\n\t\tname: \"new route path too long\",\n\t\tfn:   runNewRoutePathTooLong,\n\t}, {\n\t\tname: \"path not available\",\n\t\tfn:   runPathNotAvailable,\n\t}, {\n\t\tname: \"destination tlv graph fallback\",\n\t\tfn:   runDestTLVGraphFallback,\n\t}, {\n\t\tname: \"missing feature dependency\",\n\t\tfn:   runMissingFeatureDep,\n\t}, {\n\t\tname: \"unknown required features\",\n\t\tfn:   runUnknownRequiredFeatures,\n\t}, {\n\t\tname: \"destination payment address\",\n\t\tfn:   runDestPaymentAddr,\n\t}, {\n\t\tname: \"path insufficient capacity\",\n\t\tfn:   runPathInsufficientCapacity,\n\t}, {\n\t\tname: \"route fail min HTLC\",\n\t\tfn:   runRouteFailMinHTLC,\n\t}, {\n\t\tname: \"route fail max HTLC\",\n\t\tfn:   runRouteFailMaxHTLC,\n\t}, {\n\t\tname: \"route fail disabled edge\",\n\t\tfn:   runRouteFailDisabledEdge,\n\t}, {\n\t\tname: \"path source edges bandwidth\",\n\t\tfn:   runPathSourceEdgesBandwidth,\n\t}, {\n\t\tname: \"restrict outgoing channel\",\n\t\tfn:   runRestrictOutgoingChannel,\n\t}, {\n\t\tname: \"restrict last hop\",\n\t\tfn:   runRestrictLastHop,\n\t}, {\n\t\tname: \"CLTV limit\",\n\t\tfn:   runCltvLimit,\n\t}, {\n\t\tname: \"probability routing\",\n\t\tfn:   runProbabilityRouting,\n\t}, {\n\t\tname: \"equal cost route selection\",\n\t\tfn:   runEqualCostRouteSelection,\n\t}, {\n\t\tname: \"no cycle\",\n\t\tfn:   runNoCycle,\n\t}, {\n\t\tname: \"route to self\",\n\t\tfn:   runRouteToSelf,\n\t}, {\n\t\tname: \"with metadata\",\n\t\tfn:   runFindPathWithMetadata,\n\t}}\n\n\t// Run with graph cache enabled.\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\n\t\tt.Run(\"cache=true/\"+tc.name, func(tt *testing.T) {\n\t\t\ttt.Parallel()\n\n\t\t\ttc.fn(tt, true)\n\t\t})\n\t}\n\n\t// And with the DB fallback to make sure everything works the same\n\t// still.\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\n\t\tt.Run(\"cache=false/\"+tc.name, func(tt *testing.T) {\n\t\t\ttt.Parallel()\n\n\t\t\ttc.fn(tt, false)\n\t\t})\n\t}\n}\n\n// runFindPathWithMetadata tests that metadata is taken into account during\n// pathfinding.",
      "length": 2148,
      "tokens": 277,
      "embedding": []
    },
    {
      "slug": "func runFindPathWithMetadata(t *testing.T, useCache bool) {",
      "content": "func runFindPathWithMetadata(t *testing.T, useCache bool) {\n\ttestChannels := []*testChannel{\n\t\tsymmetricTestChannel(\"alice\", \"bob\", 100000, &testChannelPolicy{\n\t\t\tExpiry:  144,\n\t\t\tFeeRate: 400,\n\t\t\tMinHTLC: 1,\n\t\t\tMaxHTLC: 100000000,\n\t\t}),\n\t}\n\n\tctx := newPathFindingTestContext(t, useCache, testChannels, \"alice\")\n\n\tpaymentAmt := lnwire.NewMSatFromSatoshis(100)\n\ttarget := ctx.keyFromAlias(\"bob\")\n\n\t// Assert that a path is found when metadata is specified.\n\tctx.restrictParams.Metadata = []byte{1, 2, 3}\n\tctx.restrictParams.DestFeatures = tlvFeatures\n\n\tpath, err := ctx.findPath(target, paymentAmt)\n\trequire.NoError(t, err)\n\trequire.Len(t, path, 1)\n\n\t// Assert that no path is found when metadata is too large.\n\tctx.restrictParams.Metadata = make([]byte, 2000)\n\n\t_, err = ctx.findPath(target, paymentAmt)\n\trequire.ErrorIs(t, errNoPathFound, err)\n\n\t// Assert that tlv payload support takes precedence over metadata\n\t// issues.\n\tctx.restrictParams.DestFeatures = lnwire.EmptyFeatureVector()\n\n\t_, err = ctx.findPath(target, paymentAmt)\n\trequire.ErrorIs(t, errNoTlvPayload, err)\n}\n\n// runFindLowestFeePath tests that out of two routes with identical total\n// time lock values, the route with the lowest total fee should be returned.\n// The fee rates are chosen such that the test failed on the previous edge\n// weight function where one of the terms was fee squared.",
      "length": 1262,
      "tokens": 157,
      "embedding": []
    },
    {
      "slug": "func runFindLowestFeePath(t *testing.T, useCache bool) {",
      "content": "func runFindLowestFeePath(t *testing.T, useCache bool) {\n\t// Set up a test graph with two paths from roasbeef to target. Both\n\t// paths have equal total time locks, but the path through b has lower\n\t// fees (700 compared to 800 for the path through a).\n\ttestChannels := []*testChannel{\n\t\tsymmetricTestChannel(\"roasbeef\", \"first\", 100000, &testChannelPolicy{\n\t\t\tExpiry:  144,\n\t\t\tFeeRate: 400,\n\t\t\tMinHTLC: 1,\n\t\t\tMaxHTLC: 100000000,\n\t\t}),\n\t\tsymmetricTestChannel(\"first\", \"a\", 100000, &testChannelPolicy{\n\t\t\tExpiry:  144,\n\t\t\tFeeRate: 400,\n\t\t\tMinHTLC: 1,\n\t\t\tMaxHTLC: 100000000,\n\t\t}),\n\t\tsymmetricTestChannel(\"a\", \"target\", 100000, &testChannelPolicy{\n\t\t\tExpiry:  144,\n\t\t\tFeeRate: 400,\n\t\t\tMinHTLC: 1,\n\t\t\tMaxHTLC: 100000000,\n\t\t}),\n\t\tsymmetricTestChannel(\"first\", \"b\", 100000, &testChannelPolicy{\n\t\t\tExpiry:  144,\n\t\t\tFeeRate: 100,\n\t\t\tMinHTLC: 1,\n\t\t\tMaxHTLC: 100000000,\n\t\t}),\n\t\tsymmetricTestChannel(\"b\", \"target\", 100000, &testChannelPolicy{\n\t\t\tExpiry:  144,\n\t\t\tFeeRate: 600,\n\t\t\tMinHTLC: 1,\n\t\t\tMaxHTLC: 100000000,\n\t\t}),\n\t}\n\n\tctx := newPathFindingTestContext(t, useCache, testChannels, \"roasbeef\")\n\n\tconst (\n\t\tstartingHeight = 100\n\t\tfinalHopCLTV   = 1\n\t)\n\n\tpaymentAmt := lnwire.NewMSatFromSatoshis(100)\n\ttarget := ctx.keyFromAlias(\"target\")\n\tpath, err := ctx.findPath(target, paymentAmt)\n\trequire.NoError(t, err, \"unable to find path\")\n\troute, err := newRoute(\n\t\tctx.source, path, startingHeight,\n\t\tfinalHopParams{\n\t\t\tamt:       paymentAmt,\n\t\t\tcltvDelta: finalHopCLTV,\n\t\t\trecords:   nil,\n\t\t},\n\t)\n\trequire.NoError(t, err, \"unable to create path\")\n\n\t// Assert that the lowest fee route is returned.\n\tif route.Hops[1].PubKeyBytes != ctx.keyFromAlias(\"b\") {\n\t\tt.Fatalf(\"expected route to pass through b, \"+\n\t\t\t\"but got a route through %v\",\n\t\t\tctx.aliasFromKey(route.Hops[1].PubKeyBytes))\n\t}\n}\n",
      "length": 1657,
      "tokens": 192,
      "embedding": []
    },
    {
      "slug": "func getAliasFromPubKey(pubKey route.Vertex,",
      "content": "func getAliasFromPubKey(pubKey route.Vertex,\n\taliases map[string]route.Vertex) string {\n\n\tfor alias, key := range aliases {\n\t\tif key == pubKey {\n\t\t\treturn alias\n\t\t}\n\t}\n\treturn \"\"\n}\n",
      "length": 127,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "type expectedHop struct {",
      "content": "type expectedHop struct {\n\talias     string\n\tfee       lnwire.MilliSatoshi\n\tfwdAmount lnwire.MilliSatoshi\n\ttimeLock  uint32\n}\n",
      "length": 95,
      "tokens": 9,
      "embedding": []
    },
    {
      "slug": "type basicGraphPathFindingTestCase struct {",
      "content": "type basicGraphPathFindingTestCase struct {\n\ttarget                string\n\tpaymentAmt            btcutil.Amount\n\tfeeLimit              lnwire.MilliSatoshi\n\texpectedTotalAmt      lnwire.MilliSatoshi\n\texpectedTotalTimeLock uint32\n\texpectedHops          []expectedHop\n\texpectFailureNoPath   bool\n}\n\nvar basicGraphPathFindingTests = []basicGraphPathFindingTestCase{\n\t// Basic route with one intermediate hop.\n\t{target: \"sophon\", paymentAmt: 100, feeLimit: noFeeLimit,\n\t\texpectedTotalTimeLock: 102, expectedTotalAmt: 100110,\n\t\texpectedHops: []expectedHop{\n\t\t\t{alias: \"songoku\", fwdAmount: 100000, fee: 110, timeLock: 101},\n\t\t\t{alias: \"sophon\", fwdAmount: 100000, fee: 0, timeLock: 101},\n\t\t}},\n\n\t// Basic direct (one hop) route.\n\t{target: \"luoji\", paymentAmt: 100, feeLimit: noFeeLimit,\n\t\texpectedTotalTimeLock: 101, expectedTotalAmt: 100000,\n\t\texpectedHops: []expectedHop{\n\t\t\t{alias: \"luoji\", fwdAmount: 100000, fee: 0, timeLock: 101},\n\t\t}},\n\n\t// Three hop route where fees need to be added in to the forwarding amount.\n\t// The high fee hop phamnewun should be avoided.\n\t{target: \"elst\", paymentAmt: 50000, feeLimit: noFeeLimit,\n\t\texpectedTotalTimeLock: 103, expectedTotalAmt: 50050210,\n\t\texpectedHops: []expectedHop{\n\t\t\t{alias: \"songoku\", fwdAmount: 50000200, fee: 50010, timeLock: 102},\n\t\t\t{alias: \"sophon\", fwdAmount: 50000000, fee: 200, timeLock: 101},\n\t\t\t{alias: \"elst\", fwdAmount: 50000000, fee: 0, timeLock: 101},\n\t\t}},\n\t// Three hop route where fees need to be added in to the forwarding amount.\n\t// However this time the fwdAmount becomes too large for the roasbeef <->\n\t// songoku channel. Then there is no other option than to choose the\n\t// expensive phamnuwen channel. This test case was failing before\n\t// the route search was executed backwards.\n\t{target: \"elst\", paymentAmt: 100000, feeLimit: noFeeLimit,\n\t\texpectedTotalTimeLock: 103, expectedTotalAmt: 110010220,\n\t\texpectedHops: []expectedHop{\n\t\t\t{alias: \"phamnuwen\", fwdAmount: 100000200, fee: 10010020, timeLock: 102},\n\t\t\t{alias: \"sophon\", fwdAmount: 100000000, fee: 200, timeLock: 101},\n\t\t\t{alias: \"elst\", fwdAmount: 100000000, fee: 0, timeLock: 101},\n\t\t}},\n\n\t// Basic route with fee limit.\n\t{target: \"sophon\", paymentAmt: 100, feeLimit: 50,\n\t\texpectFailureNoPath: true,\n\t}}\n",
      "length": 2145,
      "tokens": 253,
      "embedding": []
    },
    {
      "slug": "func runBasicGraphPathFinding(t *testing.T, useCache bool) {",
      "content": "func runBasicGraphPathFinding(t *testing.T, useCache bool) {\n\ttestGraphInstance, err := parseTestGraph(t, useCache, basicGraphFilePath)\n\trequire.NoError(t, err, \"unable to create graph\")\n\n\t// With the test graph loaded, we'll test some basic path finding using\n\t// the pre-generated graph. Consult the testdata/basic_graph.json file\n\t// to follow along with the assumptions we'll use to test the path\n\t// finding.\n\n\tfor _, testCase := range basicGraphPathFindingTests {\n\t\tt.Run(testCase.target, func(subT *testing.T) {\n\t\t\ttestBasicGraphPathFindingCase(subT, testGraphInstance, &testCase)\n\t\t})\n\t}\n}\n",
      "length": 523,
      "tokens": 65,
      "embedding": []
    },
    {
      "slug": "func testBasicGraphPathFindingCase(t *testing.T, graphInstance *testGraphInstance,",
      "content": "func testBasicGraphPathFindingCase(t *testing.T, graphInstance *testGraphInstance,\n\ttest *basicGraphPathFindingTestCase) {\n\n\taliases := graphInstance.aliasMap\n\texpectedHops := test.expectedHops\n\texpectedHopCount := len(expectedHops)\n\n\tsourceNode, err := graphInstance.graph.SourceNode()\n\trequire.NoError(t, err, \"unable to fetch source node\")\n\tsourceVertex := route.Vertex(sourceNode.PubKeyBytes)\n\n\tconst (\n\t\tstartingHeight = 100\n\t\tfinalHopCLTV   = 1\n\t)\n\n\tpaymentAmt := lnwire.NewMSatFromSatoshis(test.paymentAmt)\n\ttarget := graphInstance.aliasMap[test.target]\n\tpath, err := dbFindPath(\n\t\tgraphInstance.graph, nil, &mockBandwidthHints{},\n\t\t&RestrictParams{\n\t\t\tFeeLimit:          test.feeLimit,\n\t\t\tProbabilitySource: noProbabilitySource,\n\t\t\tCltvLimit:         math.MaxUint32,\n\t\t},\n\t\ttestPathFindingConfig,\n\t\tsourceNode.PubKeyBytes, target, paymentAmt, 0,\n\t\tstartingHeight+finalHopCLTV,\n\t)\n\tif test.expectFailureNoPath {\n\t\tif err == nil {\n\t\t\tt.Fatal(\"expected no path to be found\")\n\t\t}\n\t\treturn\n\t}\n\trequire.NoError(t, err, \"unable to find path\")\n\n\troute, err := newRoute(\n\t\tsourceVertex, path, startingHeight,\n\t\tfinalHopParams{\n\t\t\tamt:       paymentAmt,\n\t\t\tcltvDelta: finalHopCLTV,\n\t\t\trecords:   nil,\n\t\t},\n\t)\n\trequire.NoError(t, err, \"unable to create path\")\n\n\tif len(route.Hops) != len(expectedHops) {\n\t\tt.Fatalf(\"route is of incorrect length, expected %v got %v\",\n\t\t\texpectedHopCount, len(route.Hops))\n\t}\n\n\t// Check hop nodes\n\tfor i := 0; i < len(expectedHops); i++ {\n\t\tif route.Hops[i].PubKeyBytes != aliases[expectedHops[i].alias] {\n\n\t\t\tt.Fatalf(\"%v-th hop should be %v, is instead: %v\",\n\t\t\t\ti, expectedHops[i],\n\t\t\t\tgetAliasFromPubKey(route.Hops[i].PubKeyBytes,\n\t\t\t\t\taliases))\n\t\t}\n\t}\n\n\t// Next, we'll assert that the \"next hop\" field in each route payload\n\t// properly points to the channel ID that the HTLC should be forwarded\n\t// along.\n\tsphinxPath, err := route.ToSphinxPath()\n\trequire.NoError(t, err, \"unable to make sphinx path\")\n\tif sphinxPath.TrueRouteLength() != expectedHopCount {\n\t\tt.Fatalf(\"incorrect number of hop payloads: expected %v, got %v\",\n\t\t\texpectedHopCount, sphinxPath.TrueRouteLength())\n\t}\n\n\t// Hops should point to the next hop\n\tfor i := 0; i < len(expectedHops)-1; i++ {\n\t\tvar expectedHop [8]byte\n\t\tbinary.BigEndian.PutUint64(expectedHop[:], route.Hops[i+1].ChannelID)\n\n\t\thopData, err := sphinxPath[i].HopPayload.HopData()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to make hop data: %v\", err)\n\t\t}\n\n\t\tif !bytes.Equal(hopData.NextAddress[:], expectedHop[:]) {\n\t\t\tt.Fatalf(\"first hop has incorrect next hop: expected %x, got %x\",\n\t\t\t\texpectedHop[:], hopData.NextAddress[:])\n\t\t}\n\t}\n\n\t// The final hop should have a next hop value of all zeroes in order\n\t// to indicate it's the exit hop.\n\tvar exitHop [8]byte\n\tlastHopIndex := len(expectedHops) - 1\n\n\thopData, err := sphinxPath[lastHopIndex].HopPayload.HopData()\n\trequire.NoError(t, err, \"unable to create hop data\")\n\n\tif !bytes.Equal(hopData.NextAddress[:], exitHop[:]) {\n\t\tt.Fatalf(\"first hop has incorrect next hop: expected %x, got %x\",\n\t\t\texitHop[:], hopData.NextAddress)\n\t}\n\n\tvar expectedTotalFee lnwire.MilliSatoshi\n\tfor i := 0; i < expectedHopCount; i++ {\n\t\t// We'll ensure that the amount to forward, and fees\n\t\t// computed for each hop are correct.\n\n\t\tfee := route.HopFee(i)\n\t\tif fee != expectedHops[i].fee {\n\t\t\tt.Fatalf(\"fee incorrect for hop %v: expected %v, got %v\",\n\t\t\t\ti, expectedHops[i].fee, fee)\n\t\t}\n\n\t\tif route.Hops[i].AmtToForward != expectedHops[i].fwdAmount {\n\t\t\tt.Fatalf(\"forwarding amount for hop %v incorrect: \"+\n\t\t\t\t\"expected %v, got %v\",\n\t\t\t\ti, expectedHops[i].fwdAmount,\n\t\t\t\troute.Hops[i].AmtToForward)\n\t\t}\n\n\t\t// We'll also assert that the outgoing CLTV value for each\n\t\t// hop was set accordingly.\n\t\tif route.Hops[i].OutgoingTimeLock != expectedHops[i].timeLock {\n\t\t\tt.Fatalf(\"outgoing time-lock for hop %v is incorrect: \"+\n\t\t\t\t\"expected %v, got %v\", i,\n\t\t\t\texpectedHops[i].timeLock,\n\t\t\t\troute.Hops[i].OutgoingTimeLock)\n\t\t}\n\n\t\texpectedTotalFee += expectedHops[i].fee\n\t}\n\n\tif route.TotalAmount != test.expectedTotalAmt {\n\t\tt.Fatalf(\"total amount incorrect: \"+\n\t\t\t\"expected %v, got %v\",\n\t\t\ttest.expectedTotalAmt, route.TotalAmount)\n\t}\n\n\tif route.TotalTimeLock != test.expectedTotalTimeLock {\n\t\tt.Fatalf(\"expected time lock of %v, instead have %v\", 2,\n\t\t\troute.TotalTimeLock)\n\t}\n}\n\n// runPathFindingWithAdditionalEdges asserts that we are able to find paths to\n// nodes that do not exist in the graph by way of hop hints. We also test that\n// the path can support custom TLV records for the receiver under the\n// appropriate circumstances.",
      "length": 4302,
      "tokens": 517,
      "embedding": []
    },
    {
      "slug": "func runPathFindingWithAdditionalEdges(t *testing.T, useCache bool) {",
      "content": "func runPathFindingWithAdditionalEdges(t *testing.T, useCache bool) {\n\tgraph, err := parseTestGraph(t, useCache, basicGraphFilePath)\n\trequire.NoError(t, err, \"unable to create graph\")\n\n\tsourceNode, err := graph.graph.SourceNode()\n\trequire.NoError(t, err, \"unable to fetch source node\")\n\n\tpaymentAmt := lnwire.NewMSatFromSatoshis(100)\n\n\t// In this test, we'll test that we're able to find paths through\n\t// private channels when providing them as additional edges in our path\n\t// finding algorithm. To do so, we'll create a new node, doge, and\n\t// create a private channel between it and songoku. We'll then attempt\n\t// to find a path from our source node, roasbeef, to doge.\n\tdogePubKeyHex := \"03dd46ff29a6941b4a2607525b043ec9b020b3f318a1bf281536fd7011ec59c882\"\n\tdogePubKeyBytes, err := hex.DecodeString(dogePubKeyHex)\n\trequire.NoError(t, err, \"unable to decode public key\")\n\tdogePubKey, err := btcec.ParsePubKey(dogePubKeyBytes)\n\trequire.NoError(t, err, \"unable to parse public key from bytes\")\n\n\tdoge := &channeldb.LightningNode{}\n\tdoge.AddPubKey(dogePubKey)\n\tdoge.Alias = \"doge\"\n\tcopy(doge.PubKeyBytes[:], dogePubKeyBytes)\n\tgraph.aliasMap[\"doge\"] = doge.PubKeyBytes\n\n\t// Create the channel edge going from songoku to doge and include it in\n\t// our map of additional edges.\n\tsongokuToDoge := &channeldb.CachedEdgePolicy{\n\t\tToNodePubKey: func() route.Vertex {\n\t\t\treturn doge.PubKeyBytes\n\t\t},\n\t\tToNodeFeatures:            lnwire.EmptyFeatureVector(),\n\t\tChannelID:                 1337,\n\t\tFeeBaseMSat:               1,\n\t\tFeeProportionalMillionths: 1000,\n\t\tTimeLockDelta:             9,\n\t}\n\n\tadditionalEdges := map[route.Vertex][]*channeldb.CachedEdgePolicy{\n\t\tgraph.aliasMap[\"songoku\"]: {songokuToDoge},\n\t}\n\n\tfind := func(r *RestrictParams) (\n\t\t[]*channeldb.CachedEdgePolicy, error) {\n\n\t\treturn dbFindPath(\n\t\t\tgraph.graph, additionalEdges, &mockBandwidthHints{},\n\t\t\tr, testPathFindingConfig,\n\t\t\tsourceNode.PubKeyBytes, doge.PubKeyBytes, paymentAmt,\n\t\t\t0, 0,\n\t\t)\n\t}\n\n\t// We should now be able to find a path from roasbeef to doge.\n\tpath, err := find(noRestrictions)\n\trequire.NoError(t, err, \"unable to find private path to doge\")\n\n\t// The path should represent the following hops:\n\t//\troasbeef -> songoku -> doge\n\tassertExpectedPath(t, graph.aliasMap, path, \"songoku\", \"doge\")\n\n\t// Now, set custom records for the final hop. This should fail since no\n\t// dest features are set, and we won't have a node ann to fall back on.\n\trestrictions := *noRestrictions\n\trestrictions.DestCustomRecords = record.CustomSet{70000: []byte{}}\n\n\t_, err = find(&restrictions)\n\tif err != errNoTlvPayload {\n\t\tt.Fatalf(\"path shouldn't have been found: %v\", err)\n\t}\n\n\t// Set empty dest features so we don't try the fallback. We should still\n\t// fail since the tlv feature isn't set.\n\trestrictions.DestFeatures = lnwire.EmptyFeatureVector()\n\n\t_, err = find(&restrictions)\n\tif err != errNoTlvPayload {\n\t\tt.Fatalf(\"path shouldn't have been found: %v\", err)\n\t}\n\n\t// Finally, set the tlv feature in the payload and assert we found the\n\t// same path as before.\n\trestrictions.DestFeatures = tlvFeatures\n\n\tpath, err = find(&restrictions)\n\trequire.NoError(t, err, \"path should have been found\")\n\tassertExpectedPath(t, graph.aliasMap, path, \"songoku\", \"doge\")\n}\n\n// runPathFindingWithRedundantAdditionalEdges asserts that we are able to find\n// paths to nodes ignoring additional edges that are already known by self node.",
      "length": 3226,
      "tokens": 400,
      "embedding": []
    },
    {
      "slug": "func runPathFindingWithRedundantAdditionalEdges(t *testing.T, useCache bool) {",
      "content": "func runPathFindingWithRedundantAdditionalEdges(t *testing.T, useCache bool) {\n\tt.Helper()\n\n\tvar realChannelID uint64 = 3145\n\tvar hintChannelID uint64 = 1618\n\n\ttestChannels := []*testChannel{\n\t\tsymmetricTestChannel(\"alice\", \"bob\", 100000, &testChannelPolicy{\n\t\t\tExpiry:  144,\n\t\t\tFeeRate: 400,\n\t\t\tMinHTLC: 1,\n\t\t\tMaxHTLC: 100000000,\n\t\t}, realChannelID),\n\t}\n\n\tctx := newPathFindingTestContext(t, useCache, testChannels, \"alice\")\n\n\ttarget := ctx.keyFromAlias(\"bob\")\n\tpaymentAmt := lnwire.NewMSatFromSatoshis(100)\n\n\t// Create the channel edge going from alice to bob and include it in\n\t// our map of additional edges.\n\taliceToBob := &channeldb.CachedEdgePolicy{\n\t\tToNodePubKey: func() route.Vertex {\n\t\t\treturn target\n\t\t},\n\t\tToNodeFeatures:            lnwire.EmptyFeatureVector(),\n\t\tChannelID:                 hintChannelID,\n\t\tFeeBaseMSat:               1,\n\t\tFeeProportionalMillionths: 1000,\n\t\tTimeLockDelta:             9,\n\t}\n\n\tadditionalEdges := map[route.Vertex][]*channeldb.CachedEdgePolicy{\n\t\tctx.source: {aliceToBob},\n\t}\n\n\tpath, err := dbFindPath(\n\t\tctx.graph, additionalEdges, ctx.bandwidthHints,\n\t\t&ctx.restrictParams, &ctx.pathFindingConfig, ctx.source, target,\n\t\tpaymentAmt, ctx.timePref, 0,\n\t)\n\n\trequire.NoError(t, err, \"unable to find path to bob\")\n\trequire.Len(t, path, 1)\n\n\trequire.Equal(t, realChannelID, path[0].ChannelID,\n\t\t\"additional edge for known edge wasn't ignored\")\n}\n\n// TestNewRoute tests whether the construction of hop payloads by newRoute\n// is executed correctly.",
      "length": 1358,
      "tokens": 140,
      "embedding": []
    },
    {
      "slug": "func TestNewRoute(t *testing.T) {",
      "content": "func TestNewRoute(t *testing.T) {\n\n\tvar sourceKey [33]byte\n\tsourceVertex := route.Vertex(sourceKey)\n\n\ttestPaymentAddr := [32]byte{0x01, 0x02, 0x03}\n\n\tconst (\n\t\tstartingHeight = 100\n\t\tfinalHopCLTV   = 1\n\t)\n\n\tcreateHop := func(baseFee lnwire.MilliSatoshi,\n\t\tfeeRate lnwire.MilliSatoshi,\n\t\tbandwidth lnwire.MilliSatoshi,\n\t\ttimeLockDelta uint16) *channeldb.CachedEdgePolicy {\n\n\t\treturn &channeldb.CachedEdgePolicy{\n\t\t\tToNodePubKey: func() route.Vertex {\n\t\t\t\treturn route.Vertex{}\n\t\t\t},\n\t\t\tToNodeFeatures:            lnwire.NewFeatureVector(nil, nil),\n\t\t\tFeeProportionalMillionths: feeRate,\n\t\t\tFeeBaseMSat:               baseFee,\n\t\t\tTimeLockDelta:             timeLockDelta,\n\t\t}\n\t}\n\n\ttestCases := []struct {\n\t\t// name identifies the test case in the test output.\n\t\tname string\n\n\t\t// hops is the list of hops (the route) that gets passed into\n\t\t// the call to newRoute.\n\t\thops []*channeldb.CachedEdgePolicy\n\n\t\t// paymentAmount is the amount that is send into the route\n\t\t// indicated by hops.\n\t\tpaymentAmount lnwire.MilliSatoshi\n\n\t\t// destFeatures is a feature vector, that if non-nil, will\n\t\t// overwrite the final hop's feature vector in the graph.\n\t\tdestFeatures *lnwire.FeatureVector\n\n\t\tpaymentAddr *[32]byte\n\n\t\t// metadata is the payment metadata to attach to the route.\n\t\tmetadata []byte\n\n\t\t// expectedFees is a list of fees that every hop is expected\n\t\t// to charge for forwarding.\n\t\texpectedFees []lnwire.MilliSatoshi\n\n\t\t// expectedTimeLocks is a list of time lock values that every\n\t\t// hop is expected to specify in its outgoing HTLC. The time\n\t\t// lock values in this list are relative to the current block\n\t\t// height.\n\t\texpectedTimeLocks []uint32\n\n\t\t// expectedTotalAmount is the total amount that is expected to\n\t\t// be returned from newRoute. This amount should include all\n\t\t// the fees to be paid to intermediate hops.\n\t\texpectedTotalAmount lnwire.MilliSatoshi\n\n\t\t// expectedTotalTimeLock is the time lock that is expected to\n\t\t// be returned from newRoute. This is the time lock that should\n\t\t// be specified in the HTLC that is sent by the source node.\n\t\t// expectedTotalTimeLock is relative to the current block height.\n\t\texpectedTotalTimeLock uint32\n\n\t\t// expectError indicates whether the newRoute call is expected\n\t\t// to fail or succeed.\n\t\texpectError bool\n\n\t\t// expectedErrorCode indicates the expected error code when\n\t\t// expectError is true.\n\t\texpectedErrorCode errorCode\n\n\t\texpectedTLVPayload bool\n\n\t\texpectedMPP *record.MPP\n\t}{\n\t\t{\n\t\t\t// For a single hop payment, no fees are expected to be paid.\n\t\t\tname:          \"single hop\",\n\t\t\tpaymentAmount: 100000,\n\t\t\thops: []*channeldb.CachedEdgePolicy{\n\t\t\t\tcreateHop(100, 1000, 1000000, 10),\n\t\t\t},\n\t\t\tmetadata:              []byte{1, 2, 3},\n\t\t\texpectedFees:          []lnwire.MilliSatoshi{0},\n\t\t\texpectedTimeLocks:     []uint32{1},\n\t\t\texpectedTotalAmount:   100000,\n\t\t\texpectedTotalTimeLock: 1,\n\t\t}, {\n\t\t\t// For a two hop payment, only the fee for the first hop\n\t\t\t// needs to be paid. The destination hop does not require\n\t\t\t// a fee to receive the payment.\n\t\t\tname:          \"two hop\",\n\t\t\tpaymentAmount: 100000,\n\t\t\thops: []*channeldb.CachedEdgePolicy{\n\t\t\t\tcreateHop(0, 1000, 1000000, 10),\n\t\t\t\tcreateHop(30, 1000, 1000000, 5),\n\t\t\t},\n\t\t\texpectedFees:          []lnwire.MilliSatoshi{130, 0},\n\t\t\texpectedTimeLocks:     []uint32{1, 1},\n\t\t\texpectedTotalAmount:   100130,\n\t\t\texpectedTotalTimeLock: 6,\n\t\t}, {\n\t\t\t// For a two hop payment, only the fee for the first hop\n\t\t\t// needs to be paid. The destination hop does not require\n\t\t\t// a fee to receive the payment.\n\t\t\tname:          \"two hop tlv onion feature\",\n\t\t\tdestFeatures:  tlvFeatures,\n\t\t\tpaymentAmount: 100000,\n\t\t\thops: []*channeldb.CachedEdgePolicy{\n\t\t\t\tcreateHop(0, 1000, 1000000, 10),\n\t\t\t\tcreateHop(30, 1000, 1000000, 5),\n\t\t\t},\n\t\t\texpectedFees:          []lnwire.MilliSatoshi{130, 0},\n\t\t\texpectedTimeLocks:     []uint32{1, 1},\n\t\t\texpectedTotalAmount:   100130,\n\t\t\texpectedTotalTimeLock: 6,\n\t\t\texpectedTLVPayload:    true,\n\t\t}, {\n\t\t\t// For a two hop payment, only the fee for the first hop\n\t\t\t// needs to be paid. The destination hop does not require\n\t\t\t// a fee to receive the payment.\n\t\t\tname:          \"two hop single shot mpp\",\n\t\t\tdestFeatures:  tlvPayAddrFeatures,\n\t\t\tpaymentAddr:   &testPaymentAddr,\n\t\t\tpaymentAmount: 100000,\n\t\t\thops: []*channeldb.CachedEdgePolicy{\n\t\t\t\tcreateHop(0, 1000, 1000000, 10),\n\t\t\t\tcreateHop(30, 1000, 1000000, 5),\n\t\t\t},\n\t\t\texpectedFees:          []lnwire.MilliSatoshi{130, 0},\n\t\t\texpectedTimeLocks:     []uint32{1, 1},\n\t\t\texpectedTotalAmount:   100130,\n\t\t\texpectedTotalTimeLock: 6,\n\t\t\texpectedTLVPayload:    true,\n\t\t\texpectedMPP: record.NewMPP(\n\t\t\t\t100000, testPaymentAddr,\n\t\t\t),\n\t\t}, {\n\t\t\t// A three hop payment where the first and second hop\n\t\t\t// will both charge 1 msat. The fee for the first hop\n\t\t\t// is actually slightly higher than 1, because the amount\n\t\t\t// to forward also includes the fee for the second hop. This\n\t\t\t// gets rounded down to 1.\n\t\t\tname:          \"three hop\",\n\t\t\tpaymentAmount: 100000,\n\t\t\thops: []*channeldb.CachedEdgePolicy{\n\t\t\t\tcreateHop(0, 10, 1000000, 10),\n\t\t\t\tcreateHop(0, 10, 1000000, 5),\n\t\t\t\tcreateHop(0, 10, 1000000, 3),\n\t\t\t},\n\t\t\texpectedFees:          []lnwire.MilliSatoshi{1, 1, 0},\n\t\t\texpectedTotalAmount:   100002,\n\t\t\texpectedTimeLocks:     []uint32{4, 1, 1},\n\t\t\texpectedTotalTimeLock: 9,\n\t\t}, {\n\t\t\t// A three hop payment where the fee of the first hop\n\t\t\t// is slightly higher (11) than the fee at the second hop,\n\t\t\t// because of the increase amount to forward.\n\t\t\tname:          \"three hop with fee carry over\",\n\t\t\tpaymentAmount: 100000,\n\t\t\thops: []*channeldb.CachedEdgePolicy{\n\t\t\t\tcreateHop(0, 10000, 1000000, 10),\n\t\t\t\tcreateHop(0, 10000, 1000000, 5),\n\t\t\t\tcreateHop(0, 10000, 1000000, 3),\n\t\t\t},\n\t\t\texpectedFees:          []lnwire.MilliSatoshi{1010, 1000, 0},\n\t\t\texpectedTotalAmount:   102010,\n\t\t\texpectedTimeLocks:     []uint32{4, 1, 1},\n\t\t\texpectedTotalTimeLock: 9,\n\t\t}, {\n\t\t\t// A three hop payment where the fee policies of the first and\n\t\t\t// second hop are just high enough to show the fee carry over\n\t\t\t// effect.\n\t\t\tname:          \"three hop with minimal fees for carry over\",\n\t\t\tpaymentAmount: 100000,\n\t\t\thops: []*channeldb.CachedEdgePolicy{\n\t\t\t\tcreateHop(0, 10000, 1000000, 10),\n\n\t\t\t\t// First hop charges 0.1% so the second hop fee\n\t\t\t\t// should show up in the first hop fee as 1 msat\n\t\t\t\t// extra.\n\t\t\t\tcreateHop(0, 1000, 1000000, 5),\n\n\t\t\t\t// Second hop charges a fixed 1000 msat.\n\t\t\t\tcreateHop(1000, 0, 1000000, 3),\n\t\t\t},\n\t\t\texpectedFees:          []lnwire.MilliSatoshi{101, 1000, 0},\n\t\t\texpectedTotalAmount:   101101,\n\t\t\texpectedTimeLocks:     []uint32{4, 1, 1},\n\t\t\texpectedTotalTimeLock: 9,\n\t\t}}\n\n\tfor _, testCase := range testCases {\n\t\ttestCase := testCase\n\n\t\t// Overwrite the final hop's features if the test requires a\n\t\t// custom feature vector.\n\t\tif testCase.destFeatures != nil {\n\t\t\tfinalHop := testCase.hops[len(testCase.hops)-1]\n\t\t\tfinalHop.ToNodeFeatures = testCase.destFeatures\n\t\t}\n\n\t\tassertRoute := func(t *testing.T, route *route.Route) {\n\t\t\tif route.TotalAmount != testCase.expectedTotalAmount {\n\t\t\t\tt.Errorf(\"Expected total amount is be %v\"+\n\t\t\t\t\t\", but got %v instead\",\n\t\t\t\t\ttestCase.expectedTotalAmount,\n\t\t\t\t\troute.TotalAmount)\n\t\t\t}\n\n\t\t\tfor i := 0; i < len(testCase.expectedFees); i++ {\n\t\t\t\tfee := route.HopFee(i)\n\t\t\t\tif testCase.expectedFees[i] != fee {\n\n\t\t\t\t\tt.Errorf(\"Expected fee for hop %v to \"+\n\t\t\t\t\t\t\"be %v, but got %v instead\",\n\t\t\t\t\t\ti, testCase.expectedFees[i],\n\t\t\t\t\t\tfee)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\texpectedTimeLockHeight := startingHeight +\n\t\t\t\ttestCase.expectedTotalTimeLock\n\n\t\t\tif route.TotalTimeLock != expectedTimeLockHeight {\n\n\t\t\t\tt.Errorf(\"Expected total time lock to be %v\"+\n\t\t\t\t\t\", but got %v instead\",\n\t\t\t\t\texpectedTimeLockHeight,\n\t\t\t\t\troute.TotalTimeLock)\n\t\t\t}\n\n\t\t\tfor i := 0; i < len(testCase.expectedTimeLocks); i++ {\n\t\t\t\texpectedTimeLockHeight := startingHeight +\n\t\t\t\t\ttestCase.expectedTimeLocks[i]\n\n\t\t\t\tif expectedTimeLockHeight !=\n\t\t\t\t\troute.Hops[i].OutgoingTimeLock {\n\n\t\t\t\t\tt.Errorf(\"Expected time lock for hop \"+\n\t\t\t\t\t\t\"%v to be %v, but got %v instead\",\n\t\t\t\t\t\ti, expectedTimeLockHeight,\n\t\t\t\t\t\troute.Hops[i].OutgoingTimeLock)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinalHop := route.Hops[len(route.Hops)-1]\n\t\t\tif !finalHop.LegacyPayload !=\n\t\t\t\ttestCase.expectedTLVPayload {\n\n\t\t\t\tt.Errorf(\"Expected final hop tlv payload: %t, \"+\n\t\t\t\t\t\"but got: %t instead\",\n\t\t\t\t\ttestCase.expectedTLVPayload,\n\t\t\t\t\t!finalHop.LegacyPayload)\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(\n\t\t\t\tfinalHop.MPP, testCase.expectedMPP,\n\t\t\t) {\n\n\t\t\t\tt.Errorf(\"Expected final hop mpp field: %v, \"+\n\t\t\t\t\t\" but got: %v instead\",\n\t\t\t\t\ttestCase.expectedMPP, finalHop.MPP)\n\t\t\t}\n\n\t\t\tif !bytes.Equal(finalHop.Metadata, testCase.metadata) {\n\t\t\t\tt.Errorf(\"Expected final metadata field: %v, \"+\n\t\t\t\t\t\" but got: %v instead\",\n\t\t\t\t\ttestCase.metadata, finalHop.Metadata)\n\t\t\t}\n\t\t}\n\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\troute, err := newRoute(\n\t\t\t\tsourceVertex, testCase.hops, startingHeight,\n\t\t\t\tfinalHopParams{\n\t\t\t\t\tamt:         testCase.paymentAmount,\n\t\t\t\t\ttotalAmt:    testCase.paymentAmount,\n\t\t\t\t\tcltvDelta:   finalHopCLTV,\n\t\t\t\t\trecords:     nil,\n\t\t\t\t\tpaymentAddr: testCase.paymentAddr,\n\t\t\t\t\tmetadata:    testCase.metadata,\n\t\t\t\t},\n\t\t\t)\n\n\t\t\tif testCase.expectError {\n\t\t\t\texpectedCode := testCase.expectedErrorCode\n\t\t\t\tif err == nil || !IsError(err, expectedCode) {\n\t\t\t\t\tt.Fatalf(\"expected newRoute to fail \"+\n\t\t\t\t\t\t\"with error code %v but got \"+\n\t\t\t\t\t\t\"%v instead\",\n\t\t\t\t\t\texpectedCode, err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"unable to create path: %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tassertRoute(t, route)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "length": 9158,
      "tokens": 1106,
      "embedding": []
    },
    {
      "slug": "func runNewRoutePathTooLong(t *testing.T, useCache bool) {",
      "content": "func runNewRoutePathTooLong(t *testing.T, useCache bool) {\n\tvar testChannels []*testChannel\n\n\t// Setup a linear network of 21 hops.\n\tfromNode := \"start\"\n\tfor i := 0; i < 21; i++ {\n\t\ttoNode := fmt.Sprintf(\"node-%v\", i+1)\n\t\tc := symmetricTestChannel(fromNode, toNode, 100000, &testChannelPolicy{\n\t\t\tExpiry:  144,\n\t\t\tFeeRate: 400,\n\t\t\tMinHTLC: 1,\n\t\t\tMaxHTLC: 100000001,\n\t\t})\n\t\ttestChannels = append(testChannels, c)\n\n\t\tfromNode = toNode\n\t}\n\n\tctx := newPathFindingTestContext(t, useCache, testChannels, \"start\")\n\n\t// Assert that we can find 20 hop routes.\n\tnode20 := ctx.keyFromAlias(\"node-20\")\n\tpayAmt := lnwire.MilliSatoshi(100001)\n\t_, err := ctx.findPath(node20, payAmt)\n\trequire.NoError(t, err, \"unexpected pathfinding failure\")\n\n\t// Assert that finding a 21 hop route fails.\n\tnode21 := ctx.keyFromAlias(\"node-21\")\n\t_, err = ctx.findPath(node21, payAmt)\n\tif err != errNoPathFound {\n\t\tt.Fatalf(\"not route error expected, but got %v\", err)\n\t}\n\n\t// Assert that we can't find a 20 hop route if custom records make it\n\t// exceed the maximum payload size.\n\tctx.restrictParams.DestFeatures = tlvFeatures\n\tctx.restrictParams.DestCustomRecords = map[uint64][]byte{\n\t\t100000: bytes.Repeat([]byte{1}, 100),\n\t}\n\t_, err = ctx.findPath(node20, payAmt)\n\tif err != errNoPathFound {\n\t\tt.Fatalf(\"not route error expected, but got %v\", err)\n\t}\n}\n",
      "length": 1224,
      "tokens": 163,
      "embedding": []
    },
    {
      "slug": "func runPathNotAvailable(t *testing.T, useCache bool) {",
      "content": "func runPathNotAvailable(t *testing.T, useCache bool) {\n\tgraph, err := parseTestGraph(t, useCache, basicGraphFilePath)\n\trequire.NoError(t, err, \"unable to create graph\")\n\n\tsourceNode, err := graph.graph.SourceNode()\n\trequire.NoError(t, err, \"unable to fetch source node\")\n\n\t// With the test graph loaded, we'll test that queries for target that\n\t// are either unreachable within the graph, or unknown result in an\n\t// error.\n\tunknownNodeStr := \"03dd46ff29a6941b4a2607525b043ec9b020b3f318a1bf281536fd7011ec59c882\"\n\tunknownNodeBytes, err := hex.DecodeString(unknownNodeStr)\n\trequire.NoError(t, err, \"unable to parse bytes\")\n\tvar unknownNode route.Vertex\n\tcopy(unknownNode[:], unknownNodeBytes)\n\n\t_, err = dbFindPath(\n\t\tgraph.graph, nil, &mockBandwidthHints{},\n\t\tnoRestrictions, testPathFindingConfig,\n\t\tsourceNode.PubKeyBytes, unknownNode, 100, 0, 0,\n\t)\n\tif err != errNoPathFound {\n\t\tt.Fatalf(\"path shouldn't have been found: %v\", err)\n\t}\n}\n\n// runDestTLVGraphFallback asserts that we properly detect when we can send TLV\n// records to a receiver, and also that we fallback to the receiver's node\n// announcement if we don't have an invoice features.",
      "length": 1065,
      "tokens": 132,
      "embedding": []
    },
    {
      "slug": "func runDestTLVGraphFallback(t *testing.T, useCache bool) {",
      "content": "func runDestTLVGraphFallback(t *testing.T, useCache bool) {\n\ttestChannels := []*testChannel{\n\t\tasymmetricTestChannel(\"roasbeef\", \"luoji\", 100000,\n\t\t\t&testChannelPolicy{\n\t\t\t\tExpiry:  144,\n\t\t\t\tFeeRate: 400,\n\t\t\t\tMinHTLC: 1,\n\t\t\t\tMaxHTLC: 100000000,\n\t\t\t}, &testChannelPolicy{\n\t\t\t\tExpiry:  144,\n\t\t\t\tFeeRate: 400,\n\t\t\t\tMinHTLC: 1,\n\t\t\t\tMaxHTLC: 100000000,\n\t\t\t}, 0),\n\t\tasymmetricTestChannel(\"roasbeef\", \"satoshi\", 100000,\n\t\t\t&testChannelPolicy{\n\t\t\t\tExpiry:  144,\n\t\t\t\tFeeRate: 400,\n\t\t\t\tMinHTLC: 1,\n\t\t\t\tMaxHTLC: 100000000,\n\t\t\t}, &testChannelPolicy{\n\t\t\t\tExpiry:   144,\n\t\t\t\tFeeRate:  400,\n\t\t\t\tMinHTLC:  1,\n\t\t\t\tMaxHTLC:  100000000,\n\t\t\t\tFeatures: tlvFeatures,\n\t\t\t}, 0),\n\t}\n\n\tctx := newPathFindingTestContext(t, useCache, testChannels, \"roasbeef\")\n\n\tsourceNode, err := ctx.graph.SourceNode()\n\trequire.NoError(t, err, \"unable to fetch source node\")\n\n\tfind := func(r *RestrictParams,\n\t\ttarget route.Vertex) ([]*channeldb.CachedEdgePolicy, error) {\n\n\t\treturn dbFindPath(\n\t\t\tctx.graph, nil, &mockBandwidthHints{},\n\t\t\tr, testPathFindingConfig,\n\t\t\tsourceNode.PubKeyBytes, target, 100, 0, 0,\n\t\t)\n\t}\n\n\t// Luoji's node ann has an empty feature vector.\n\tluoji := ctx.testGraphInstance.aliasMap[\"luoji\"]\n\n\t// Satoshi's node ann supports TLV.\n\tsatoshi := ctx.testGraphInstance.aliasMap[\"satoshi\"]\n\n\trestrictions := *noRestrictions\n\n\t// Add custom records w/o any dest features.\n\trestrictions.DestCustomRecords = record.CustomSet{70000: []byte{}}\n\n\t// Path to luoji should fail because his node ann features are empty.\n\t_, err = find(&restrictions, luoji)\n\tif err != errNoTlvPayload {\n\t\tt.Fatalf(\"path shouldn't have been found: %v\", err)\n\t}\n\n\t// However, path to satoshi should succeed via the fallback because his\n\t// node ann features have the TLV bit.\n\tpath, err := find(&restrictions, satoshi)\n\trequire.NoError(t, err, \"path should have been found\")\n\tassertExpectedPath(t, ctx.testGraphInstance.aliasMap, path, \"satoshi\")\n\n\t// Add empty destination features. This should cause both paths to fail,\n\t// since this override anything in the graph.\n\trestrictions.DestFeatures = lnwire.EmptyFeatureVector()\n\n\t_, err = find(&restrictions, luoji)\n\tif err != errNoTlvPayload {\n\t\tt.Fatalf(\"path shouldn't have been found: %v\", err)\n\t}\n\t_, err = find(&restrictions, satoshi)\n\tif err != errNoTlvPayload {\n\t\tt.Fatalf(\"path shouldn't have been found: %v\", err)\n\t}\n\n\t// Finally, set the TLV dest feature. We should succeed in finding a\n\t// path to luoji.\n\trestrictions.DestFeatures = tlvFeatures\n\n\tpath, err = find(&restrictions, luoji)\n\trequire.NoError(t, err, \"path should have been found\")\n\tassertExpectedPath(t, ctx.testGraphInstance.aliasMap, path, \"luoji\")\n}\n\n// runMissingFeatureDep asserts that we fail path finding when the\n// destination's features are broken, in that the feature vector doesn't signal\n// all transitive dependencies.",
      "length": 2654,
      "tokens": 319,
      "embedding": []
    },
    {
      "slug": "func runMissingFeatureDep(t *testing.T, useCache bool) {",
      "content": "func runMissingFeatureDep(t *testing.T, useCache bool) {\n\ttestChannels := []*testChannel{\n\t\tasymmetricTestChannel(\"roasbeef\", \"conner\", 100000,\n\t\t\t&testChannelPolicy{\n\t\t\t\tExpiry:  144,\n\t\t\t\tFeeRate: 400,\n\t\t\t\tMinHTLC: 1,\n\t\t\t\tMaxHTLC: 100000000,\n\t\t\t},\n\t\t\t&testChannelPolicy{\n\t\t\t\tExpiry:   144,\n\t\t\t\tFeeRate:  400,\n\t\t\t\tMinHTLC:  1,\n\t\t\t\tMaxHTLC:  100000000,\n\t\t\t\tFeatures: payAddrFeatures,\n\t\t\t}, 0,\n\t\t),\n\t\tasymmetricTestChannel(\"conner\", \"joost\", 100000,\n\t\t\t&testChannelPolicy{\n\t\t\t\tExpiry:   144,\n\t\t\t\tFeeRate:  400,\n\t\t\t\tMinHTLC:  1,\n\t\t\t\tMaxHTLC:  100000000,\n\t\t\t\tFeatures: payAddrFeatures,\n\t\t\t},\n\t\t\t&testChannelPolicy{\n\t\t\t\tExpiry:  144,\n\t\t\t\tFeeRate: 400,\n\t\t\t\tMinHTLC: 1,\n\t\t\t\tMaxHTLC: 100000000,\n\t\t\t}, 0,\n\t\t),\n\t}\n\n\tctx := newPathFindingTestContext(t, useCache, testChannels, \"roasbeef\")\n\n\t// Conner's node in the graph has a broken feature vector, since it\n\t// signals payment addresses without signaling tlv onions. Pathfinding\n\t// should fail since we validate transitive feature dependencies for the\n\t// final node.\n\tconner := ctx.keyFromAlias(\"conner\")\n\tjoost := ctx.keyFromAlias(\"joost\")\n\n\t_, err := ctx.findPath(conner, 100)\n\tif err != errMissingDependentFeature {\n\t\tt.Fatalf(\"path shouldn't have been found: %v\", err)\n\t}\n\n\t// Now, set the TLV and payment addresses features to override the\n\t// broken features found in the graph. We should succeed in finding a\n\t// path to conner.\n\tctx.restrictParams.DestFeatures = tlvPayAddrFeatures\n\n\tpath, err := ctx.findPath(conner, 100)\n\trequire.NoError(t, err, \"path should have been found\")\n\tassertExpectedPath(t, ctx.testGraphInstance.aliasMap, path, \"conner\")\n\n\t// Finally, try to find a route to joost through conner. The\n\t// destination features are set properly from the previous assertions,\n\t// but conner's feature vector in the graph is still broken. We expect\n\t// errNoPathFound and not the missing feature dep err above since\n\t// intermediate hops are simply skipped if they have invalid feature\n\t// vectors, leaving no possible route to joost.\n\t_, err = ctx.findPath(joost, 100)\n\tif err != errNoPathFound {\n\t\tt.Fatalf(\"path shouldn't have been found: %v\", err)\n\t}\n}\n\n// runUnknownRequiredFeatures asserts that we fail path finding when the\n// destination requires an unknown required feature, and that we skip\n// intermediaries that signal unknown required features.",
      "length": 2189,
      "tokens": 284,
      "embedding": []
    },
    {
      "slug": "func runUnknownRequiredFeatures(t *testing.T, useCache bool) {",
      "content": "func runUnknownRequiredFeatures(t *testing.T, useCache bool) {\n\ttestChannels := []*testChannel{\n\t\tasymmetricTestChannel(\"roasbeef\", \"conner\", 100000,\n\t\t\t&testChannelPolicy{\n\t\t\t\tExpiry:  144,\n\t\t\t\tFeeRate: 400,\n\t\t\t\tMinHTLC: 1,\n\t\t\t\tMaxHTLC: 100000000,\n\t\t\t},\n\t\t\t&testChannelPolicy{\n\t\t\t\tExpiry:   144,\n\t\t\t\tFeeRate:  400,\n\t\t\t\tMinHTLC:  1,\n\t\t\t\tMaxHTLC:  100000000,\n\t\t\t\tFeatures: unknownRequiredFeatures,\n\t\t\t}, 0,\n\t\t),\n\t\tasymmetricTestChannel(\"conner\", \"joost\", 100000,\n\t\t\t&testChannelPolicy{\n\t\t\t\tExpiry:   144,\n\t\t\t\tFeeRate:  400,\n\t\t\t\tMinHTLC:  1,\n\t\t\t\tMaxHTLC:  100000000,\n\t\t\t\tFeatures: unknownRequiredFeatures,\n\t\t\t},\n\t\t\t&testChannelPolicy{\n\t\t\t\tExpiry:  144,\n\t\t\t\tFeeRate: 400,\n\t\t\t\tMinHTLC: 1,\n\t\t\t\tMaxHTLC: 100000000,\n\t\t\t}, 0,\n\t\t),\n\t}\n\n\tctx := newPathFindingTestContext(t, useCache, testChannels, \"roasbeef\")\n\n\tconner := ctx.keyFromAlias(\"conner\")\n\tjoost := ctx.keyFromAlias(\"joost\")\n\n\t// Conner's node in the graph has an unknown required feature (100).\n\t// Pathfinding should fail since we check the destination's features for\n\t// unknown required features before beginning pathfinding.\n\t_, err := ctx.findPath(conner, 100)\n\tif !reflect.DeepEqual(err, errUnknownRequiredFeature) {\n\t\tt.Fatalf(\"path shouldn't have been found: %v\", err)\n\t}\n\n\t// Now, try to find a route to joost through conner. The destination\n\t// features are valid, but conner's feature vector in the graph still\n\t// requires feature 100. We expect errNoPathFound and not the error\n\t// above since intermediate hops are simply skipped if they have invalid\n\t// feature vectors, leaving no possible route to joost. This asserts\n\t// that we don't try to route _through_ nodes with unknown required\n\t// features.\n\t_, err = ctx.findPath(joost, 100)\n\tif err != errNoPathFound {\n\t\tt.Fatalf(\"path shouldn't have been found: %v\", err)\n\t}\n}\n\n// runDestPaymentAddr asserts that we properly detect when we can send a\n// payment address to a receiver, and also that we fallback to the receiver's\n// node announcement if we don't have an invoice features.",
      "length": 1877,
      "tokens": 245,
      "embedding": []
    },
    {
      "slug": "func runDestPaymentAddr(t *testing.T, useCache bool) {",
      "content": "func runDestPaymentAddr(t *testing.T, useCache bool) {\n\ttestChannels := []*testChannel{\n\t\tsymmetricTestChannel(\"roasbeef\", \"luoji\", 100000,\n\t\t\t&testChannelPolicy{\n\t\t\t\tExpiry:  144,\n\t\t\t\tFeeRate: 400,\n\t\t\t\tMinHTLC: 1,\n\t\t\t\tMaxHTLC: 100000000,\n\t\t\t},\n\t\t),\n\t}\n\n\tctx := newPathFindingTestContext(t, useCache, testChannels, \"roasbeef\")\n\n\tluoji := ctx.keyFromAlias(\"luoji\")\n\n\t// Add payment address w/o any invoice features.\n\tctx.restrictParams.PaymentAddr = &[32]byte{1}\n\n\t// Add empty destination features. This should cause us to fail, since\n\t// this overrides anything in the graph.\n\tctx.restrictParams.DestFeatures = lnwire.EmptyFeatureVector()\n\n\t_, err := ctx.findPath(luoji, 100)\n\tif err != errNoPaymentAddr {\n\t\tt.Fatalf(\"path shouldn't have been found: %v\", err)\n\t}\n\n\t// Now, set the TLV and payment address features for the destination. We\n\t// should succeed in finding a path to luoji.\n\tctx.restrictParams.DestFeatures = tlvPayAddrFeatures\n\n\tpath, err := ctx.findPath(luoji, 100)\n\trequire.NoError(t, err, \"path should have been found\")\n\tassertExpectedPath(t, ctx.testGraphInstance.aliasMap, path, \"luoji\")\n}\n",
      "length": 1018,
      "tokens": 120,
      "embedding": []
    },
    {
      "slug": "func runPathInsufficientCapacity(t *testing.T, useCache bool) {",
      "content": "func runPathInsufficientCapacity(t *testing.T, useCache bool) {\n\tgraph, err := parseTestGraph(t, useCache, basicGraphFilePath)\n\trequire.NoError(t, err, \"unable to create graph\")\n\n\tsourceNode, err := graph.graph.SourceNode()\n\trequire.NoError(t, err, \"unable to fetch source node\")\n\n\t// Next, test that attempting to find a path in which the current\n\t// channel graph cannot support due to insufficient capacity triggers\n\t// an error.\n\n\t// To test his we'll attempt to make a payment of 1 BTC, or 100 million\n\t// satoshis. The largest channel in the basic graph is of size 100k\n\t// satoshis, so we shouldn't be able to find a path to sophon even\n\t// though we have a 2-hop link.\n\ttarget := graph.aliasMap[\"sophon\"]\n\n\tpayAmt := lnwire.NewMSatFromSatoshis(btcutil.SatoshiPerBitcoin)\n\t_, err = dbFindPath(\n\t\tgraph.graph, nil, &mockBandwidthHints{},\n\t\tnoRestrictions, testPathFindingConfig,\n\t\tsourceNode.PubKeyBytes, target, payAmt, 0, 0,\n\t)\n\tif err != errInsufficientBalance {\n\t\tt.Fatalf(\"graph shouldn't be able to support payment: %v\", err)\n\t}\n}\n\n// runRouteFailMinHTLC tests that if we attempt to route an HTLC which is\n// smaller than the advertised minHTLC of an edge, then path finding fails.",
      "length": 1101,
      "tokens": 162,
      "embedding": []
    },
    {
      "slug": "func runRouteFailMinHTLC(t *testing.T, useCache bool) {",
      "content": "func runRouteFailMinHTLC(t *testing.T, useCache bool) {\n\tgraph, err := parseTestGraph(t, useCache, basicGraphFilePath)\n\trequire.NoError(t, err, \"unable to create graph\")\n\n\tsourceNode, err := graph.graph.SourceNode()\n\trequire.NoError(t, err, \"unable to fetch source node\")\n\n\t// We'll not attempt to route an HTLC of 10 SAT from roasbeef to Son\n\t// Goku. However, the min HTLC of Son Goku is 1k SAT, as a result, this\n\t// attempt should fail.\n\ttarget := graph.aliasMap[\"songoku\"]\n\tpayAmt := lnwire.MilliSatoshi(10)\n\t_, err = dbFindPath(\n\t\tgraph.graph, nil, &mockBandwidthHints{},\n\t\tnoRestrictions, testPathFindingConfig,\n\t\tsourceNode.PubKeyBytes, target, payAmt, 0, 0,\n\t)\n\tif err != errNoPathFound {\n\t\tt.Fatalf(\"graph shouldn't be able to support payment: %v\", err)\n\t}\n}\n\n// runRouteFailMaxHTLC tests that if we attempt to route an HTLC which is\n// larger than the advertised max HTLC of an edge, then path finding fails.",
      "length": 841,
      "tokens": 122,
      "embedding": []
    },
    {
      "slug": "func runRouteFailMaxHTLC(t *testing.T, useCache bool) {",
      "content": "func runRouteFailMaxHTLC(t *testing.T, useCache bool) {\n\t// Set up a test graph:\n\t// roasbeef <--> firstHop <--> secondHop <--> target\n\t// We will be adjusting the max HTLC of the edge between the first and\n\t// second hops.\n\tvar firstToSecondID uint64 = 1\n\ttestChannels := []*testChannel{\n\t\tsymmetricTestChannel(\"roasbeef\", \"first\", 100000, &testChannelPolicy{\n\t\t\tExpiry:  144,\n\t\t\tFeeRate: 400,\n\t\t\tMinHTLC: 1,\n\t\t\tMaxHTLC: 100000001,\n\t\t}),\n\t\tsymmetricTestChannel(\"first\", \"second\", 100000, &testChannelPolicy{\n\t\t\tExpiry:  144,\n\t\t\tFeeRate: 400,\n\t\t\tMinHTLC: 1,\n\t\t\tMaxHTLC: 100000002,\n\t\t}, firstToSecondID),\n\t\tsymmetricTestChannel(\"second\", \"target\", 100000, &testChannelPolicy{\n\t\t\tExpiry:  144,\n\t\t\tFeeRate: 400,\n\t\t\tMinHTLC: 1,\n\t\t\tMaxHTLC: 100000003,\n\t\t}),\n\t}\n\n\tctx := newPathFindingTestContext(t, useCache, testChannels, \"roasbeef\")\n\n\t// First, attempt to send a payment greater than the max HTLC we are\n\t// about to set, which should succeed.\n\ttarget := ctx.keyFromAlias(\"target\")\n\tpayAmt := lnwire.MilliSatoshi(100001)\n\t_, err := ctx.findPath(target, payAmt)\n\trequire.NoError(t, err, \"graph should've been able to support payment\")\n\n\t// Next, update the middle edge policy to only allow payments up to 100k\n\t// msat.\n\tgraph := ctx.testGraphInstance.graph\n\t_, midEdge, _, err := graph.FetchChannelEdgesByID(firstToSecondID)\n\trequire.NoError(t, err, \"unable to fetch channel edges by ID\")\n\tmidEdge.MessageFlags = 1\n\tmidEdge.MaxHTLC = payAmt - 1\n\tif err := graph.UpdateEdgePolicy(midEdge); err != nil {\n\t\tt.Fatalf(\"unable to update edge: %v\", err)\n\t}\n\n\t// We'll now attempt to route through that edge with a payment above\n\t// 100k msat, which should fail.\n\t_, err = ctx.findPath(target, payAmt)\n\tif err != errNoPathFound {\n\t\tt.Fatalf(\"graph shouldn't be able to support payment: %v\", err)\n\t}\n}\n\n// runRouteFailDisabledEdge tests that if we attempt to route to an edge\n// that's disabled, then that edge is disqualified, and the routing attempt\n// will fail. We also test that this is true only for non-local edges, as we'll\n// ignore the disable flags, with the assumption that the correct bandwidth is\n// found among the bandwidth hints.",
      "length": 2020,
      "tokens": 284,
      "embedding": []
    },
    {
      "slug": "func runRouteFailDisabledEdge(t *testing.T, useCache bool) {",
      "content": "func runRouteFailDisabledEdge(t *testing.T, useCache bool) {\n\tgraph, err := parseTestGraph(t, useCache, basicGraphFilePath)\n\trequire.NoError(t, err, \"unable to create graph\")\n\n\tsourceNode, err := graph.graph.SourceNode()\n\trequire.NoError(t, err, \"unable to fetch source node\")\n\n\t// First, we'll try to route from roasbeef -> sophon. This should\n\t// succeed without issue, and return a single path via phamnuwen\n\ttarget := graph.aliasMap[\"sophon\"]\n\tpayAmt := lnwire.NewMSatFromSatoshis(105000)\n\t_, err = dbFindPath(\n\t\tgraph.graph, nil, &mockBandwidthHints{},\n\t\tnoRestrictions, testPathFindingConfig,\n\t\tsourceNode.PubKeyBytes, target, payAmt, 0, 0,\n\t)\n\trequire.NoError(t, err, \"unable to find path\")\n\n\t// Disable the edge roasbeef->phamnuwen. This should not impact the\n\t// path finding, as we don't consider the disable flag for local\n\t// channels (and roasbeef is the source).\n\troasToPham := uint64(999991)\n\t_, e1, e2, err := graph.graph.FetchChannelEdgesByID(roasToPham)\n\trequire.NoError(t, err, \"unable to fetch edge\")\n\te1.ChannelFlags |= lnwire.ChanUpdateDisabled\n\tif err := graph.graph.UpdateEdgePolicy(e1); err != nil {\n\t\tt.Fatalf(\"unable to update edge: %v\", err)\n\t}\n\te2.ChannelFlags |= lnwire.ChanUpdateDisabled\n\tif err := graph.graph.UpdateEdgePolicy(e2); err != nil {\n\t\tt.Fatalf(\"unable to update edge: %v\", err)\n\t}\n\n\t_, err = dbFindPath(\n\t\tgraph.graph, nil, &mockBandwidthHints{},\n\t\tnoRestrictions, testPathFindingConfig,\n\t\tsourceNode.PubKeyBytes, target, payAmt, 0, 0,\n\t)\n\trequire.NoError(t, err, \"unable to find path\")\n\n\t// Now, we'll modify the edge from phamnuwen -> sophon, to read that\n\t// it's disabled.\n\tphamToSophon := uint64(99999)\n\t_, e, _, err := graph.graph.FetchChannelEdgesByID(phamToSophon)\n\trequire.NoError(t, err, \"unable to fetch edge\")\n\te.ChannelFlags |= lnwire.ChanUpdateDisabled\n\tif err := graph.graph.UpdateEdgePolicy(e); err != nil {\n\t\tt.Fatalf(\"unable to update edge: %v\", err)\n\t}\n\n\t// If we attempt to route through that edge, we should get a failure as\n\t// it is no longer eligible.\n\t_, err = dbFindPath(\n\t\tgraph.graph, nil, &mockBandwidthHints{},\n\t\tnoRestrictions, testPathFindingConfig,\n\t\tsourceNode.PubKeyBytes, target, payAmt, 0, 0,\n\t)\n\tif err != errNoPathFound {\n\t\tt.Fatalf(\"graph shouldn't be able to support payment: %v\", err)\n\t}\n}\n\n// runPathSourceEdgesBandwidth tests that explicitly passing in a set of\n// bandwidth hints is used by the path finding algorithm to consider whether to\n// use a local channel.",
      "length": 2329,
      "tokens": 304,
      "embedding": []
    },
    {
      "slug": "func runPathSourceEdgesBandwidth(t *testing.T, useCache bool) {",
      "content": "func runPathSourceEdgesBandwidth(t *testing.T, useCache bool) {\n\tgraph, err := parseTestGraph(t, useCache, basicGraphFilePath)\n\trequire.NoError(t, err, \"unable to create graph\")\n\n\tsourceNode, err := graph.graph.SourceNode()\n\trequire.NoError(t, err, \"unable to fetch source node\")\n\n\t// First, we'll try to route from roasbeef -> sophon. This should\n\t// succeed without issue, and return a path via songoku, as that's the\n\t// cheapest path.\n\ttarget := graph.aliasMap[\"sophon\"]\n\tpayAmt := lnwire.NewMSatFromSatoshis(50000)\n\tpath, err := dbFindPath(\n\t\tgraph.graph, nil, &mockBandwidthHints{},\n\t\tnoRestrictions, testPathFindingConfig,\n\t\tsourceNode.PubKeyBytes, target, payAmt, 0, 0,\n\t)\n\trequire.NoError(t, err, \"unable to find path\")\n\tassertExpectedPath(t, graph.aliasMap, path, \"songoku\", \"sophon\")\n\n\t// Now we'll set the bandwidth of the edge roasbeef->songoku and\n\t// roasbeef->phamnuwen to 0.\n\troasToSongoku := uint64(12345)\n\troasToPham := uint64(999991)\n\tbandwidths := &mockBandwidthHints{\n\t\thints: map[uint64]lnwire.MilliSatoshi{\n\t\t\troasToSongoku: 0,\n\t\t\troasToPham:    0,\n\t\t},\n\t}\n\n\t// Since both these edges has a bandwidth of zero, no path should be\n\t// found.\n\t_, err = dbFindPath(\n\t\tgraph.graph, nil, bandwidths,\n\t\tnoRestrictions, testPathFindingConfig,\n\t\tsourceNode.PubKeyBytes, target, payAmt, 0, 0,\n\t)\n\tif err != errNoPathFound {\n\t\tt.Fatalf(\"graph shouldn't be able to support payment: %v\", err)\n\t}\n\n\t// Set the bandwidth of roasbeef->phamnuwen high enough to carry the\n\t// payment.\n\tbandwidths.hints[roasToPham] = 2 * payAmt\n\n\t// Now, if we attempt to route again, we should find the path via\n\t// phamnuven, as the other source edge won't be considered.\n\tpath, err = dbFindPath(\n\t\tgraph.graph, nil, bandwidths,\n\t\tnoRestrictions, testPathFindingConfig,\n\t\tsourceNode.PubKeyBytes, target, payAmt, 0, 0,\n\t)\n\trequire.NoError(t, err, \"unable to find path\")\n\tassertExpectedPath(t, graph.aliasMap, path, \"phamnuwen\", \"sophon\")\n\n\t// Finally, set the roasbeef->songoku bandwidth, but also set its\n\t// disable flag.\n\tbandwidths.hints[roasToSongoku] = 2 * payAmt\n\t_, e1, e2, err := graph.graph.FetchChannelEdgesByID(roasToSongoku)\n\trequire.NoError(t, err, \"unable to fetch edge\")\n\te1.ChannelFlags |= lnwire.ChanUpdateDisabled\n\tif err := graph.graph.UpdateEdgePolicy(e1); err != nil {\n\t\tt.Fatalf(\"unable to update edge: %v\", err)\n\t}\n\te2.ChannelFlags |= lnwire.ChanUpdateDisabled\n\tif err := graph.graph.UpdateEdgePolicy(e2); err != nil {\n\t\tt.Fatalf(\"unable to update edge: %v\", err)\n\t}\n\n\t// Since we ignore disable flags for local channels, a path should\n\t// still be found.\n\tpath, err = dbFindPath(\n\t\tgraph.graph, nil, bandwidths,\n\t\tnoRestrictions, testPathFindingConfig,\n\t\tsourceNode.PubKeyBytes, target, payAmt, 0, 0,\n\t)\n\trequire.NoError(t, err, \"unable to find path\")\n\tassertExpectedPath(t, graph.aliasMap, path, \"songoku\", \"sophon\")\n}\n",
      "length": 2691,
      "tokens": 338,
      "embedding": []
    },
    {
      "slug": "func TestPathInsufficientCapacityWithFee(t *testing.T) {",
      "content": "func TestPathInsufficientCapacityWithFee(t *testing.T) {\n\tt.Parallel()\n\n\t// TODO(roasbeef): encode live graph to json\n\n\t// TODO(roasbeef): need to add a case, or modify the fee ratio for one\n\t// to ensure that has going forward, but when fees are applied doesn't\n\t// work\n}\n",
      "length": 209,
      "tokens": 38,
      "embedding": []
    },
    {
      "slug": "func TestPathFindSpecExample(t *testing.T) {",
      "content": "func TestPathFindSpecExample(t *testing.T) {\n\tt.Parallel()\n\n\t// All our path finding tests will assume a starting height of 100, so\n\t// we'll pass that in to ensure that the router uses 100 as the current\n\t// height.\n\tconst startingHeight = 100\n\tctx := createTestCtxFromFile(t, startingHeight, specExampleFilePath)\n\n\t// We'll first exercise the scenario of a direct payment from Bob to\n\t// Carol, so we set \"B\" as the source node so path finding starts from\n\t// Bob.\n\tbob := ctx.aliases[\"B\"]\n\tbobNode, err := ctx.graph.FetchLightningNode(bob)\n\trequire.NoError(t, err, \"unable to find bob\")\n\tif err := ctx.graph.SetSourceNode(bobNode); err != nil {\n\t\tt.Fatalf(\"unable to set source node: %v\", err)\n\t}\n\n\t// Query for a route of 4,999,999 mSAT to carol.\n\tcarol := ctx.aliases[\"C\"]\n\tconst amt lnwire.MilliSatoshi = 4999999\n\troute, _, err := ctx.router.FindRoute(\n\t\tbobNode.PubKeyBytes, carol, amt, 0, noRestrictions, nil, nil,\n\t\tMinCLTVDelta,\n\t)\n\trequire.NoError(t, err, \"unable to find route\")\n\n\t// Now we'll examine the route returned for correctness.\n\t//\n\t// It should be sending the exact payment amount as there are no\n\t// additional hops.\n\tif route.TotalAmount != amt {\n\t\tt.Fatalf(\"wrong total amount: got %v, expected %v\",\n\t\t\troute.TotalAmount, amt)\n\t}\n\tif route.Hops[0].AmtToForward != amt {\n\t\tt.Fatalf(\"wrong forward amount: got %v, expected %v\",\n\t\t\troute.Hops[0].AmtToForward, amt)\n\t}\n\n\tfee := route.HopFee(0)\n\tif fee != 0 {\n\t\tt.Fatalf(\"wrong hop fee: got %v, expected %v\", fee, 0)\n\t}\n\n\t// The CLTV expiry should be the current height plus 18 (the expiry for\n\t// the B -> C channel.\n\tif route.TotalTimeLock !=\n\t\tstartingHeight+MinCLTVDelta {\n\n\t\tt.Fatalf(\"wrong total time lock: got %v, expecting %v\",\n\t\t\troute.TotalTimeLock,\n\t\t\tstartingHeight+MinCLTVDelta)\n\t}\n\n\t// Next, we'll set A as the source node so we can assert that we create\n\t// the proper route for any queries starting with Alice.\n\talice := ctx.aliases[\"A\"]\n\taliceNode, err := ctx.graph.FetchLightningNode(alice)\n\trequire.NoError(t, err, \"unable to find alice\")\n\tif err := ctx.graph.SetSourceNode(aliceNode); err != nil {\n\t\tt.Fatalf(\"unable to set source node: %v\", err)\n\t}\n\tctx.router.selfNode = aliceNode\n\tsource, err := ctx.graph.SourceNode()\n\trequire.NoError(t, err, \"unable to retrieve source node\")\n\tif source.PubKeyBytes != alice {\n\t\tt.Fatalf(\"source node not set\")\n\t}\n\n\t// We'll now request a route from A -> B -> C.\n\troute, _, err = ctx.router.FindRoute(\n\t\tsource.PubKeyBytes, carol, amt, 0, noRestrictions, nil, nil,\n\t\tMinCLTVDelta,\n\t)\n\trequire.NoError(t, err, \"unable to find routes\")\n\n\t// The route should be two hops.\n\tif len(route.Hops) != 2 {\n\t\tt.Fatalf(\"route should be %v hops, is instead %v\", 2,\n\t\t\tlen(route.Hops))\n\t}\n\n\t// The total amount should factor in a fee of 10199 and also use a CLTV\n\t// delta total of 38 (20 + 18),\n\texpectedAmt := lnwire.MilliSatoshi(5010198)\n\tif route.TotalAmount != expectedAmt {\n\t\tt.Fatalf(\"wrong amount: got %v, expected %v\",\n\t\t\troute.TotalAmount, expectedAmt)\n\t}\n\texpectedDelta := uint32(20 + MinCLTVDelta)\n\tif route.TotalTimeLock != startingHeight+expectedDelta {\n\t\tt.Fatalf(\"wrong total time lock: got %v, expecting %v\",\n\t\t\troute.TotalTimeLock, startingHeight+expectedDelta)\n\t}\n\n\t// Ensure that the hops of the route are properly crafted.\n\t//\n\t// After taking the fee, Bob should be forwarding the remainder which\n\t// is the exact payment to Bob.\n\tif route.Hops[0].AmtToForward != amt {\n\t\tt.Fatalf(\"wrong forward amount: got %v, expected %v\",\n\t\t\troute.Hops[0].AmtToForward, amt)\n\t}\n\n\t// We shouldn't pay any fee for the first, hop, but the fee for the\n\t// second hop posted fee should be exactly:\n\n\t// The fee that we pay for the second hop will be \"applied to the first\n\t// hop, so we should get a fee of exactly:\n\t//\n\t//  * 200 + 4999999 * 2000 / 1000000 = 10199\n\n\tfee = route.HopFee(0)\n\tif fee != 10199 {\n\t\tt.Fatalf(\"wrong hop fee: got %v, expected %v\", fee, 10199)\n\t}\n\n\t// While for the final hop, as there's no additional hop afterwards, we\n\t// pay no fee.\n\tfee = route.HopFee(1)\n\tif fee != 0 {\n\t\tt.Fatalf(\"wrong hop fee: got %v, expected %v\", fee, 0)\n\t}\n\n\t// The outgoing CLTV value itself should be the current height plus 30\n\t// to meet Carol's requirements.\n\tif route.Hops[0].OutgoingTimeLock !=\n\t\tstartingHeight+MinCLTVDelta {\n\n\t\tt.Fatalf(\"wrong total time lock: got %v, expecting %v\",\n\t\t\troute.Hops[0].OutgoingTimeLock,\n\t\t\tstartingHeight+MinCLTVDelta)\n\t}\n\n\t// For B -> C, we assert that the final hop also has the proper\n\t// parameters.\n\tlastHop := route.Hops[1]\n\tif lastHop.AmtToForward != amt {\n\t\tt.Fatalf(\"wrong forward amount: got %v, expected %v\",\n\t\t\tlastHop.AmtToForward, amt)\n\t}\n\tif lastHop.OutgoingTimeLock !=\n\t\tstartingHeight+MinCLTVDelta {\n\n\t\tt.Fatalf(\"wrong total time lock: got %v, expecting %v\",\n\t\t\tlastHop.OutgoingTimeLock,\n\t\t\tstartingHeight+MinCLTVDelta)\n\t}\n}\n",
      "length": 4611,
      "tokens": 690,
      "embedding": []
    },
    {
      "slug": "func assertExpectedPath(t *testing.T, aliasMap map[string]route.Vertex,",
      "content": "func assertExpectedPath(t *testing.T, aliasMap map[string]route.Vertex,\n\tpath []*channeldb.CachedEdgePolicy, nodeAliases ...string) {\n\n\tif len(path) != len(nodeAliases) {\n\t\tt.Fatal(\"number of hops and number of aliases do not match\")\n\t}\n\n\tfor i, hop := range path {\n\t\tif hop.ToNodePubKey() != aliasMap[nodeAliases[i]] {\n\t\t\tt.Fatalf(\"expected %v to be pos #%v in hop, instead \"+\n\t\t\t\t\"%v was\", nodeAliases[i], i, hop.ToNodePubKey())\n\t\t}\n\t}\n}\n\n// TestNewRouteFromEmptyHops tests that the NewRouteFromHops function returns an\n// error when the hop list is empty.",
      "length": 471,
      "tokens": 68,
      "embedding": []
    },
    {
      "slug": "func TestNewRouteFromEmptyHops(t *testing.T) {",
      "content": "func TestNewRouteFromEmptyHops(t *testing.T) {\n\tt.Parallel()\n\n\tvar source route.Vertex\n\t_, err := route.NewRouteFromHops(0, 0, source, []*route.Hop{})\n\tif err != route.ErrNoRouteHopsProvided {\n\t\tt.Fatalf(\"expected empty hops error: instead got: %v\", err)\n\t}\n}\n\n// runRestrictOutgoingChannel asserts that a outgoing channel restriction is\n// obeyed by the path finding algorithm.",
      "length": 321,
      "tokens": 42,
      "embedding": []
    },
    {
      "slug": "func runRestrictOutgoingChannel(t *testing.T, useCache bool) {",
      "content": "func runRestrictOutgoingChannel(t *testing.T, useCache bool) {\n\t// Define channel id constants\n\tconst (\n\t\tchanSourceA      = 1\n\t\tchanATarget      = 4\n\t\tchanSourceB1     = 2\n\t\tchanSourceB2     = 3\n\t\tchanBTarget      = 5\n\t\tchanSourceTarget = 6\n\t)\n\n\t// Set up a test graph with three possible paths from roasbeef to\n\t// target. The path through chanSourceB1 is the highest cost path.\n\ttestChannels := []*testChannel{\n\t\tsymmetricTestChannel(\"roasbeef\", \"a\", 100000, &testChannelPolicy{\n\t\t\tExpiry: 144,\n\t\t}, chanSourceA),\n\t\tsymmetricTestChannel(\"a\", \"target\", 100000, &testChannelPolicy{\n\t\t\tExpiry:  144,\n\t\t\tFeeRate: 400,\n\t\t}, chanATarget),\n\t\tsymmetricTestChannel(\"roasbeef\", \"b\", 100000, &testChannelPolicy{\n\t\t\tExpiry: 144,\n\t\t}, chanSourceB1),\n\t\tsymmetricTestChannel(\"roasbeef\", \"b\", 100000, &testChannelPolicy{\n\t\t\tExpiry: 144,\n\t\t}, chanSourceB2),\n\t\tsymmetricTestChannel(\"b\", \"target\", 100000, &testChannelPolicy{\n\t\t\tExpiry:  144,\n\t\t\tFeeRate: 800,\n\t\t}, chanBTarget),\n\t\tsymmetricTestChannel(\"roasbeef\", \"target\", 100000, &testChannelPolicy{\n\t\t\tExpiry: 144,\n\t\t}, chanSourceTarget),\n\t}\n\n\tctx := newPathFindingTestContext(t, useCache, testChannels, \"roasbeef\")\n\n\tconst (\n\t\tstartingHeight = 100\n\t\tfinalHopCLTV   = 1\n\t)\n\n\tpaymentAmt := lnwire.NewMSatFromSatoshis(100)\n\ttarget := ctx.keyFromAlias(\"target\")\n\toutgoingChannelID := uint64(chanSourceB1)\n\n\t// Find the best path given the restriction to only use channel 2 as the\n\t// outgoing channel.\n\tctx.restrictParams.OutgoingChannelIDs = []uint64{outgoingChannelID}\n\tpath, err := ctx.findPath(target, paymentAmt)\n\trequire.NoError(t, err, \"unable to find path\")\n\n\t// Assert that the route starts with channel chanSourceB1, in line with\n\t// the specified restriction.\n\tif path[0].ChannelID != chanSourceB1 {\n\t\tt.Fatalf(\"expected route to pass through channel %v, \"+\n\t\t\t\"but channel %v was selected instead\", chanSourceB1,\n\t\t\tpath[0].ChannelID)\n\t}\n\n\t// If a direct channel to target is allowed as well, that channel is\n\t// expected to be selected because the routing fees are zero.\n\tctx.restrictParams.OutgoingChannelIDs = []uint64{\n\t\tchanSourceB1, chanSourceTarget,\n\t}\n\tpath, err = ctx.findPath(target, paymentAmt)\n\trequire.NoError(t, err, \"unable to find path\")\n\tif path[0].ChannelID != chanSourceTarget {\n\t\tt.Fatalf(\"expected route to pass through channel %v\",\n\t\t\tchanSourceTarget)\n\t}\n}\n\n// runRestrictLastHop asserts that a last hop restriction is obeyed by the path\n// finding algorithm.",
      "length": 2291,
      "tokens": 273,
      "embedding": []
    },
    {
      "slug": "func runRestrictLastHop(t *testing.T, useCache bool) {",
      "content": "func runRestrictLastHop(t *testing.T, useCache bool) {\n\t// Set up a test graph with three possible paths from roasbeef to\n\t// target. The path via channel 1 and 2 is the lowest cost path.\n\ttestChannels := []*testChannel{\n\t\tsymmetricTestChannel(\"source\", \"a\", 100000, &testChannelPolicy{\n\t\t\tExpiry: 144,\n\t\t}, 1),\n\t\tsymmetricTestChannel(\"a\", \"target\", 100000, &testChannelPolicy{\n\t\t\tExpiry:  144,\n\t\t\tFeeRate: 400,\n\t\t}, 2),\n\t\tsymmetricTestChannel(\"source\", \"b\", 100000, &testChannelPolicy{\n\t\t\tExpiry: 144,\n\t\t}, 3),\n\t\tsymmetricTestChannel(\"b\", \"target\", 100000, &testChannelPolicy{\n\t\t\tExpiry:  144,\n\t\t\tFeeRate: 800,\n\t\t}, 4),\n\t}\n\n\tctx := newPathFindingTestContext(t, useCache, testChannels, \"source\")\n\n\tpaymentAmt := lnwire.NewMSatFromSatoshis(100)\n\ttarget := ctx.keyFromAlias(\"target\")\n\tlastHop := ctx.keyFromAlias(\"b\")\n\n\t// Find the best path given the restriction to use b as the last hop.\n\t// This should force pathfinding to not take the lowest cost option.\n\tctx.restrictParams.LastHop = &lastHop\n\tpath, err := ctx.findPath(target, paymentAmt)\n\trequire.NoError(t, err, \"unable to find path\")\n\tif path[0].ChannelID != 3 {\n\t\tt.Fatalf(\"expected route to pass through channel 3, \"+\n\t\t\t\"but channel %v was selected instead\",\n\t\t\tpath[0].ChannelID)\n\t}\n}\n\n// runCltvLimit asserts that a cltv limit is obeyed by the path finding\n// algorithm.",
      "length": 1240,
      "tokens": 160,
      "embedding": []
    },
    {
      "slug": "func runCltvLimit(t *testing.T, useCache bool) {",
      "content": "func runCltvLimit(t *testing.T, useCache bool) {\n\tt.Run(\"no limit\", func(t *testing.T) {\n\t\ttestCltvLimit(t, useCache, 2016, 1)\n\t})\n\tt.Run(\"no path\", func(t *testing.T) {\n\t\ttestCltvLimit(t, useCache, 50, 0)\n\t})\n\tt.Run(\"force high cost\", func(t *testing.T) {\n\t\ttestCltvLimit(t, useCache, 80, 3)\n\t})\n}\n",
      "length": 240,
      "tokens": 32,
      "embedding": []
    },
    {
      "slug": "func testCltvLimit(t *testing.T, useCache bool, limit uint32,",
      "content": "func testCltvLimit(t *testing.T, useCache bool, limit uint32,\n\texpectedChannel uint64) {\n\n\tt.Parallel()\n\n\t// Set up a test graph with three possible paths to the target. The path\n\t// through a is the lowest cost with a high time lock (144). The path\n\t// through b has a higher cost but a lower time lock (100). That path\n\t// through c and d (two hops) has the same case as the path through b,\n\t// but the total time lock is lower (60).\n\ttestChannels := []*testChannel{\n\t\tsymmetricTestChannel(\"roasbeef\", \"a\", 100000, &testChannelPolicy{}, 1),\n\t\tsymmetricTestChannel(\"a\", \"target\", 100000, &testChannelPolicy{\n\t\t\tExpiry:      144,\n\t\t\tFeeBaseMsat: 10000,\n\t\t\tMinHTLC:     1,\n\t\t}),\n\t\tsymmetricTestChannel(\"roasbeef\", \"b\", 100000, &testChannelPolicy{}, 2),\n\t\tsymmetricTestChannel(\"b\", \"target\", 100000, &testChannelPolicy{\n\t\t\tExpiry:      100,\n\t\t\tFeeBaseMsat: 20000,\n\t\t\tMinHTLC:     1,\n\t\t}),\n\t\tsymmetricTestChannel(\"roasbeef\", \"c\", 100000, &testChannelPolicy{}, 3),\n\t\tsymmetricTestChannel(\"c\", \"d\", 100000, &testChannelPolicy{\n\t\t\tExpiry:      30,\n\t\t\tFeeBaseMsat: 10000,\n\t\t\tMinHTLC:     1,\n\t\t}),\n\t\tsymmetricTestChannel(\"d\", \"target\", 100000, &testChannelPolicy{\n\t\t\tExpiry:      30,\n\t\t\tFeeBaseMsat: 10000,\n\t\t\tMinHTLC:     1,\n\t\t}),\n\t}\n\n\tctx := newPathFindingTestContext(t, useCache, testChannels, \"roasbeef\")\n\n\tpaymentAmt := lnwire.NewMSatFromSatoshis(100)\n\ttarget := ctx.keyFromAlias(\"target\")\n\n\tctx.restrictParams.CltvLimit = limit\n\tpath, err := ctx.findPath(target, paymentAmt)\n\tif expectedChannel == 0 {\n\t\t// Finish test if we expect no route.\n\t\tif err == errNoPathFound {\n\t\t\treturn\n\t\t}\n\t\tt.Fatal(\"expected no path to be found\")\n\t}\n\trequire.NoError(t, err, \"unable to find path\")\n\n\tconst (\n\t\tstartingHeight = 100\n\t\tfinalHopCLTV   = 1\n\t)\n\troute, err := newRoute(\n\t\tctx.source, path, startingHeight,\n\t\tfinalHopParams{\n\t\t\tamt:       paymentAmt,\n\t\t\tcltvDelta: finalHopCLTV,\n\t\t\trecords:   nil,\n\t\t},\n\t)\n\trequire.NoError(t, err, \"unable to create path\")\n\n\t// Assert that the route starts with the expected channel.\n\tif route.Hops[0].ChannelID != expectedChannel {\n\t\tt.Fatalf(\"expected route to pass through channel %v, \"+\n\t\t\t\"but channel %v was selected instead\", expectedChannel,\n\t\t\troute.Hops[0].ChannelID)\n\t}\n}\n\n// runProbabilityRouting asserts that path finding not only takes into account\n// fees but also success probability.",
      "length": 2184,
      "tokens": 271,
      "embedding": []
    },
    {
      "slug": "func runProbabilityRouting(t *testing.T, useCache bool) {",
      "content": "func runProbabilityRouting(t *testing.T, useCache bool) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tp10, p11, p20  float64\n\t\tminProbability float64\n\t\texpectedChan   uint64\n\t\tamount         btcutil.Amount\n\t\ttimePref       float64\n\t}{\n\t\t// Test two variations with probabilities that should multiply\n\t\t// to the same total route probability. In both cases the three\n\t\t// hop route should be the best route. The three hop route has a\n\t\t// probability of 0.5 * 0.8 = 0.4. The fee is 5 (chan 10) + 8\n\t\t// (chan 11) = 13. The attempt cost is 9 + 1% * 100 = 10. Path\n\t\t// finding distance should work out to: 13 + 10 (attempt\n\t\t// penalty) / 0.4 = 38. The two hop route is 25 + 10 / 0.7 = 39.\n\t\t{\n\t\t\tname: \"three hop 1\",\n\t\t\tp10:  0.8, p11: 0.5, p20: 0.7,\n\t\t\tminProbability: 0.1,\n\t\t\texpectedChan:   10,\n\t\t\tamount:         100,\n\t\t},\n\t\t{\n\t\t\tname: \"three hop 2\",\n\t\t\tp10:  0.5, p11: 0.8, p20: 0.7,\n\t\t\tminProbability: 0.1,\n\t\t\texpectedChan:   10,\n\t\t\tamount:         100,\n\t\t},\n\n\t\t// If we increase the time preference, we expect the algorithm\n\t\t// to choose - with everything else being equal - the more\n\t\t// expensive, more reliable route.\n\t\t{\n\t\t\tname: \"three hop timepref\",\n\t\t\tp10:  0.5, p11: 0.8, p20: 0.7,\n\t\t\tminProbability: 0.1,\n\t\t\texpectedChan:   20,\n\t\t\tamount:         100,\n\t\t\ttimePref:       1,\n\t\t},\n\n\t\t// If a larger amount is sent, the effect of the proportional\n\t\t// attempt cost becomes more noticeable. This amount in this\n\t\t// test brings the attempt cost to 9 + 1% * 300 = 12 sat. The\n\t\t// three hop path finding distance should work out to: 13 + 12\n\t\t// (attempt penalty) / 0.4 = 43. The two hop route is 25 + 12 /\n\t\t// 0.7 = 42. For this higher amount, the two hop route is\n\t\t// expected to be selected.\n\t\t{\n\t\t\tname: \"two hop high amount\",\n\t\t\tp10:  0.8, p11: 0.5, p20: 0.7,\n\t\t\tminProbability: 0.1,\n\t\t\texpectedChan:   20,\n\t\t\tamount:         300,\n\t\t},\n\n\t\t// If the probability of the two hop route is increased, its\n\t\t// distance becomes 25 + 10 / 0.85 = 37. This is less than the\n\t\t// three hop route with its distance 38. So with an attempt\n\t\t// penalty of 10, the higher fee route is chosen because of the\n\t\t// compensation for success probability.\n\t\t{\n\t\t\tname: \"two hop higher cost\",\n\t\t\tp10:  0.5, p11: 0.8, p20: 0.85,\n\t\t\tminProbability: 0.1,\n\t\t\texpectedChan:   20,\n\t\t\tamount:         100,\n\t\t},\n\n\t\t// If the same probabilities are used with a probability lower bound of\n\t\t// 0.5, we expect the three hop route with probability 0.4 to be\n\t\t// excluded and the two hop route to be picked.\n\t\t{\n\t\t\tname: \"probability limit\",\n\t\t\tp10:  0.8, p11: 0.5, p20: 0.7,\n\t\t\tminProbability: 0.5,\n\t\t\texpectedChan:   20,\n\t\t\tamount:         100,\n\t\t},\n\n\t\t// With a probability limit above the probability of both routes, we\n\t\t// expect no route to be returned. This expectation is signaled by using\n\t\t// expected channel 0.\n\t\t{\n\t\t\tname: \"probability limit no routes\",\n\t\t\tp10:  0.8, p11: 0.5, p20: 0.7,\n\t\t\tminProbability: 0.8,\n\t\t\texpectedChan:   0,\n\t\t\tamount:         100,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\ttestProbabilityRouting(\n\t\t\t\tt, useCache, tc.amount, tc.timePref,\n\t\t\t\ttc.p10, tc.p11, tc.p20,\n\t\t\t\ttc.minProbability, tc.expectedChan,\n\t\t\t)\n\t\t})\n\t}\n}\n",
      "length": 3043,
      "tokens": 510,
      "embedding": []
    },
    {
      "slug": "func testProbabilityRouting(t *testing.T, useCache bool,",
      "content": "func testProbabilityRouting(t *testing.T, useCache bool,\n\tpaymentAmt btcutil.Amount, timePref float64,\n\tp10, p11, p20, minProbability float64,\n\texpectedChan uint64) {\n\n\tt.Parallel()\n\n\t// Set up a test graph with two possible paths to the target: a three\n\t// hop path (via channels 10 and 11) and a two hop path (via channel\n\t// 20).\n\ttestChannels := []*testChannel{\n\t\tsymmetricTestChannel(\"roasbeef\", \"a1\", 100000, &testChannelPolicy{}),\n\t\tsymmetricTestChannel(\"roasbeef\", \"b\", 100000, &testChannelPolicy{}),\n\t\tsymmetricTestChannel(\"a1\", \"a2\", 100000, &testChannelPolicy{\n\t\t\tExpiry:      144,\n\t\t\tFeeBaseMsat: lnwire.NewMSatFromSatoshis(5),\n\t\t\tMinHTLC:     1,\n\t\t}, 10),\n\t\tsymmetricTestChannel(\"a2\", \"target\", 100000, &testChannelPolicy{\n\t\t\tExpiry:      144,\n\t\t\tFeeBaseMsat: lnwire.NewMSatFromSatoshis(8),\n\t\t\tMinHTLC:     1,\n\t\t}, 11),\n\t\tsymmetricTestChannel(\"b\", \"target\", 100000, &testChannelPolicy{\n\t\t\tExpiry:      100,\n\t\t\tFeeBaseMsat: lnwire.NewMSatFromSatoshis(25),\n\t\t\tMinHTLC:     1,\n\t\t}, 20),\n\t}\n\n\tctx := newPathFindingTestContext(t, useCache, testChannels, \"roasbeef\")\n\n\talias := ctx.testGraphInstance.aliasMap\n\n\ttarget := ctx.testGraphInstance.aliasMap[\"target\"]\n\n\t// Configure a probability source with the test parameters.\n\tctx.restrictParams.ProbabilitySource = func(fromNode,\n\t\ttoNode route.Vertex, amt lnwire.MilliSatoshi,\n\t\tcapacity btcutil.Amount) float64 {\n\n\t\tif amt == 0 {\n\t\t\tt.Fatal(\"expected non-zero amount\")\n\t\t}\n\n\t\tswitch {\n\t\tcase fromNode == alias[\"a1\"] && toNode == alias[\"a2\"]:\n\t\t\treturn p10\n\t\tcase fromNode == alias[\"a2\"] && toNode == alias[\"target\"]:\n\t\t\treturn p11\n\t\tcase fromNode == alias[\"b\"] && toNode == alias[\"target\"]:\n\t\t\treturn p20\n\t\tdefault:\n\t\t\treturn 1\n\t\t}\n\t}\n\n\tctx.pathFindingConfig = PathFindingConfig{\n\t\tAttemptCost:    lnwire.NewMSatFromSatoshis(9),\n\t\tAttemptCostPPM: 10000,\n\t\tMinProbability: minProbability,\n\t}\n\n\tctx.timePref = timePref\n\n\tpath, err := ctx.findPath(\n\t\ttarget, lnwire.NewMSatFromSatoshis(paymentAmt),\n\t)\n\tif expectedChan == 0 {\n\t\tif err != errNoPathFound {\n\t\t\tt.Fatalf(\"expected no path found, but got %v\", err)\n\t\t}\n\t\treturn\n\t}\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Assert that the route passes through the expected channel.\n\tif path[1].ChannelID != expectedChan {\n\t\tt.Fatalf(\"expected route to pass through channel %v, \"+\n\t\t\t\"but channel %v was selected instead\", expectedChan,\n\t\t\tpath[1].ChannelID)\n\t}\n}\n\n// runEqualCostRouteSelection asserts that route probability will be used as a\n// tie breaker in case the path finding probabilities are equal.",
      "length": 2362,
      "tokens": 274,
      "embedding": []
    },
    {
      "slug": "func runEqualCostRouteSelection(t *testing.T, useCache bool) {",
      "content": "func runEqualCostRouteSelection(t *testing.T, useCache bool) {\n\t// Set up a test graph with two possible paths to the target: via a and\n\t// via b. The routing fees and probabilities are chosen such that the\n\t// algorithm will first explore target->a->source (backwards search).\n\t// This route has fee 6 and a penalty of 4 for the 25% success\n\t// probability. The algorithm will then proceed with evaluating\n\t// target->b->source, which has a fee of 8 and a penalty of 2 for the\n\t// 50% success probability. Both routes have the same path finding cost\n\t// of 10. It is expected that in that case, the highest probability\n\t// route (through b) is chosen.\n\ttestChannels := []*testChannel{\n\t\tsymmetricTestChannel(\"source\", \"a\", 100000, &testChannelPolicy{}),\n\t\tsymmetricTestChannel(\"source\", \"b\", 100000, &testChannelPolicy{}),\n\t\tsymmetricTestChannel(\"a\", \"target\", 100000, &testChannelPolicy{\n\t\t\tExpiry:      144,\n\t\t\tFeeBaseMsat: lnwire.NewMSatFromSatoshis(6),\n\t\t\tMinHTLC:     1,\n\t\t}, 1),\n\t\tsymmetricTestChannel(\"b\", \"target\", 100000, &testChannelPolicy{\n\t\t\tExpiry:      100,\n\t\t\tFeeBaseMsat: lnwire.NewMSatFromSatoshis(8),\n\t\t\tMinHTLC:     1,\n\t\t}, 2),\n\t}\n\n\tctx := newPathFindingTestContext(t, useCache, testChannels, \"source\")\n\n\talias := ctx.testGraphInstance.aliasMap\n\n\tpaymentAmt := lnwire.NewMSatFromSatoshis(100)\n\ttarget := ctx.testGraphInstance.aliasMap[\"target\"]\n\n\tctx.restrictParams.ProbabilitySource = func(fromNode,\n\t\ttoNode route.Vertex, amt lnwire.MilliSatoshi,\n\t\tcapacity btcutil.Amount) float64 {\n\n\t\tswitch {\n\t\tcase fromNode == alias[\"source\"] && toNode == alias[\"a\"]:\n\t\t\treturn 0.25\n\t\tcase fromNode == alias[\"source\"] && toNode == alias[\"b\"]:\n\t\t\treturn 0.5\n\t\tdefault:\n\t\t\treturn 1\n\t\t}\n\t}\n\n\tctx.pathFindingConfig = PathFindingConfig{\n\t\tAttemptCost: lnwire.NewMSatFromSatoshis(1),\n\t}\n\n\tpath, err := ctx.findPath(target, paymentAmt)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif path[1].ChannelID != 2 {\n\t\tt.Fatalf(\"expected route to pass through channel %v, \"+\n\t\t\t\"but channel %v was selected instead\", 2,\n\t\t\tpath[1].ChannelID)\n\t}\n}\n\n// runNoCycle tries to guide the path finding algorithm into reconstructing an\n// endless route. It asserts that the algorithm is able to handle this properly.",
      "length": 2069,
      "tokens": 263,
      "embedding": []
    },
    {
      "slug": "func runNoCycle(t *testing.T, useCache bool) {",
      "content": "func runNoCycle(t *testing.T, useCache bool) {\n\t// Set up a test graph with two paths: source->a->target and\n\t// source->b->c->target. The fees are setup such that, searching\n\t// backwards, the algorithm will evaluate the following end of the route\n\t// first: ->target->c->target. This does not make sense, because if\n\t// target is reached, there is no need to continue to c. A proper\n\t// implementation will then go on with alternative routes. It will then\n\t// consider ->a->target because its cost is lower than the alternative\n\t// ->b->c->target and finally find source->a->target as the best route.\n\ttestChannels := []*testChannel{\n\t\tsymmetricTestChannel(\"source\", \"a\", 100000, &testChannelPolicy{\n\t\t\tExpiry: 144,\n\t\t}, 1),\n\t\tsymmetricTestChannel(\"source\", \"b\", 100000, &testChannelPolicy{\n\t\t\tExpiry: 144,\n\t\t}, 2),\n\t\tsymmetricTestChannel(\"b\", \"c\", 100000, &testChannelPolicy{\n\t\t\tExpiry:      144,\n\t\t\tFeeBaseMsat: 2000,\n\t\t}, 3),\n\t\tsymmetricTestChannel(\"c\", \"target\", 100000, &testChannelPolicy{\n\t\t\tExpiry:      144,\n\t\t\tFeeBaseMsat: 0,\n\t\t}, 4),\n\t\tsymmetricTestChannel(\"a\", \"target\", 100000, &testChannelPolicy{\n\t\t\tExpiry:      144,\n\t\t\tFeeBaseMsat: 600,\n\t\t}, 5),\n\t}\n\n\tctx := newPathFindingTestContext(t, useCache, testChannels, \"source\")\n\n\tconst (\n\t\tstartingHeight = 100\n\t\tfinalHopCLTV   = 1\n\t)\n\n\tpaymentAmt := lnwire.NewMSatFromSatoshis(100)\n\ttarget := ctx.keyFromAlias(\"target\")\n\n\t// Find the best path given the restriction to only use channel 2 as the\n\t// outgoing channel.\n\tpath, err := ctx.findPath(target, paymentAmt)\n\trequire.NoError(t, err, \"unable to find path\")\n\troute, err := newRoute(\n\t\tctx.source, path, startingHeight,\n\t\tfinalHopParams{\n\t\t\tamt:       paymentAmt,\n\t\t\tcltvDelta: finalHopCLTV,\n\t\t\trecords:   nil,\n\t\t},\n\t)\n\trequire.NoError(t, err, \"unable to create path\")\n\n\tif len(route.Hops) != 2 {\n\t\tt.Fatalf(\"unexpected route\")\n\t}\n\tif route.Hops[0].ChannelID != 1 {\n\t\tt.Fatalf(\"unexpected first hop\")\n\t}\n\tif route.Hops[1].ChannelID != 5 {\n\t\tt.Fatalf(\"unexpected second hop\")\n\t}\n}\n\n// runRouteToSelf tests that it is possible to find a route to the self node.",
      "length": 1961,
      "tokens": 253,
      "embedding": []
    },
    {
      "slug": "func runRouteToSelf(t *testing.T, useCache bool) {",
      "content": "func runRouteToSelf(t *testing.T, useCache bool) {\n\ttestChannels := []*testChannel{\n\t\tsymmetricTestChannel(\"source\", \"a\", 100000, &testChannelPolicy{\n\t\t\tExpiry:      144,\n\t\t\tFeeBaseMsat: 500,\n\t\t}, 1),\n\t\tsymmetricTestChannel(\"source\", \"b\", 100000, &testChannelPolicy{\n\t\t\tExpiry:      144,\n\t\t\tFeeBaseMsat: 1000,\n\t\t}, 2),\n\t\tsymmetricTestChannel(\"a\", \"b\", 100000, &testChannelPolicy{\n\t\t\tExpiry:      144,\n\t\t\tFeeBaseMsat: 1000,\n\t\t}, 3),\n\t}\n\n\tctx := newPathFindingTestContext(t, useCache, testChannels, \"source\")\n\n\tpaymentAmt := lnwire.NewMSatFromSatoshis(100)\n\ttarget := ctx.source\n\n\t// Find the best path to self. We expect this to be source->a->source,\n\t// because a charges the lowest forwarding fee.\n\tpath, err := ctx.findPath(target, paymentAmt)\n\trequire.NoError(t, err, \"unable to find path\")\n\tctx.assertPath(path, []uint64{1, 1})\n\n\toutgoingChanID := uint64(1)\n\tlastHop := ctx.keyFromAlias(\"b\")\n\tctx.restrictParams.OutgoingChannelIDs = []uint64{outgoingChanID}\n\tctx.restrictParams.LastHop = &lastHop\n\n\t// Find the best path to self given that we want to go out via channel 1\n\t// and return through node b.\n\tpath, err = ctx.findPath(target, paymentAmt)\n\trequire.NoError(t, err, \"unable to find path\")\n\tctx.assertPath(path, []uint64{1, 3, 2})\n}\n",
      "length": 1156,
      "tokens": 132,
      "embedding": []
    },
    {
      "slug": "type pathFindingTestContext struct {",
      "content": "type pathFindingTestContext struct {\n\tt                 *testing.T\n\tgraph             *channeldb.ChannelGraph\n\trestrictParams    RestrictParams\n\tbandwidthHints    bandwidthHints\n\tpathFindingConfig PathFindingConfig\n\ttestGraphInstance *testGraphInstance\n\tsource            route.Vertex\n\ttimePref          float64\n}\n",
      "length": 268,
      "tokens": 17,
      "embedding": []
    },
    {
      "slug": "func newPathFindingTestContext(t *testing.T, useCache bool,",
      "content": "func newPathFindingTestContext(t *testing.T, useCache bool,\n\ttestChannels []*testChannel, source string) *pathFindingTestContext {\n\n\ttestGraphInstance, err := createTestGraphFromChannels(\n\t\tt, useCache, testChannels, source,\n\t)\n\trequire.NoError(t, err, \"unable to create graph\")\n\n\tsourceNode, err := testGraphInstance.graph.SourceNode()\n\trequire.NoError(t, err, \"unable to fetch source node\")\n\n\tctx := &pathFindingTestContext{\n\t\tt:                 t,\n\t\ttestGraphInstance: testGraphInstance,\n\t\tsource:            route.Vertex(sourceNode.PubKeyBytes),\n\t\tpathFindingConfig: *testPathFindingConfig,\n\t\tgraph:             testGraphInstance.graph,\n\t\trestrictParams:    *noRestrictions,\n\t\tbandwidthHints:    &mockBandwidthHints{},\n\t}\n\n\treturn ctx\n}\n",
      "length": 659,
      "tokens": 53,
      "embedding": []
    },
    {
      "slug": "func (c *pathFindingTestContext) keyFromAlias(alias string) route.Vertex {",
      "content": "func (c *pathFindingTestContext) keyFromAlias(alias string) route.Vertex {\n\treturn c.testGraphInstance.aliasMap[alias]\n}\n",
      "length": 44,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (c *pathFindingTestContext) aliasFromKey(pubKey route.Vertex) string {",
      "content": "func (c *pathFindingTestContext) aliasFromKey(pubKey route.Vertex) string {\n\tfor alias, key := range c.testGraphInstance.aliasMap {\n\t\tif key == pubKey {\n\t\t\treturn alias\n\t\t}\n\t}\n\treturn \"\"\n}\n",
      "length": 106,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func (c *pathFindingTestContext) findPath(target route.Vertex,",
      "content": "func (c *pathFindingTestContext) findPath(target route.Vertex,\n\tamt lnwire.MilliSatoshi) ([]*channeldb.CachedEdgePolicy,\n\terror) {\n\n\treturn dbFindPath(\n\t\tc.graph, nil, c.bandwidthHints, &c.restrictParams,\n\t\t&c.pathFindingConfig, c.source, target, amt, c.timePref, 0,\n\t)\n}\n",
      "length": 201,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func (c *pathFindingTestContext) assertPath(path []*channeldb.CachedEdgePolicy,",
      "content": "func (c *pathFindingTestContext) assertPath(path []*channeldb.CachedEdgePolicy,\n\texpected []uint64) {\n\n\tif len(path) != len(expected) {\n\t\tc.t.Fatalf(\"expected path of length %v, but got %v\",\n\t\t\tlen(expected), len(path))\n\t}\n\n\tfor i, edge := range path {\n\t\tif edge.ChannelID != expected[i] {\n\t\t\tc.t.Fatalf(\"expected hop %v to be channel %v, \"+\n\t\t\t\t\"but got %v\", i, expected[i], edge.ChannelID)\n\t\t}\n\t}\n}\n\n// dbFindPath calls findPath after getting a db transaction from the database\n// graph.",
      "length": 393,
      "tokens": 62,
      "embedding": []
    },
    {
      "slug": "func dbFindPath(graph *channeldb.ChannelGraph,",
      "content": "func dbFindPath(graph *channeldb.ChannelGraph,\n\tadditionalEdges map[route.Vertex][]*channeldb.CachedEdgePolicy,\n\tbandwidthHints bandwidthHints,\n\tr *RestrictParams, cfg *PathFindingConfig,\n\tsource, target route.Vertex, amt lnwire.MilliSatoshi, timePref float64,\n\tfinalHtlcExpiry int32) ([]*channeldb.CachedEdgePolicy, error) {\n\n\tsourceNode, err := graph.SourceNode()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\troutingGraph, err := NewCachedGraph(sourceNode, graph)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdefer func() {\n\t\tif err := routingGraph.Close(); err != nil {\n\t\t\tlog.Errorf(\"Error closing db tx: %v\", err)\n\t\t}\n\t}()\n\n\troute, _, err := findPath(\n\t\t&graphParams{\n\t\t\tadditionalEdges: additionalEdges,\n\t\t\tbandwidthHints:  bandwidthHints,\n\t\t\tgraph:           routingGraph,\n\t\t},\n\t\tr, cfg, source, target, amt, timePref, finalHtlcExpiry,\n\t)\n\n\treturn route, err\n}\n",
      "length": 778,
      "tokens": 91,
      "embedding": []
    }
  ]
}