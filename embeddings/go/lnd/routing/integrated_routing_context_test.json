{
  "filepath": "../implementations/go/lnd/routing/integrated_routing_context_test.go",
  "package": "routing",
  "sections": [
    {
      "slug": "type mockBandwidthHints struct {",
      "content": "type mockBandwidthHints struct {\n\thints map[uint64]lnwire.MilliSatoshi\n}\n",
      "length": 38,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (m *mockBandwidthHints) availableChanBandwidth(channelID uint64,",
      "content": "func (m *mockBandwidthHints) availableChanBandwidth(channelID uint64,\n\t_ lnwire.MilliSatoshi) (lnwire.MilliSatoshi, bool) {\n\n\tif m.hints == nil {\n\t\treturn 0, false\n\t}\n\n\tbalance, ok := m.hints[channelID]\n\treturn balance, ok\n}\n\n// integratedRoutingContext defines the context in which integrated routing\n// tests run.",
      "length": 234,
      "tokens": 34,
      "embedding": []
    },
    {
      "slug": "type integratedRoutingContext struct {",
      "content": "type integratedRoutingContext struct {\n\tgraph *mockGraph\n\tt     *testing.T\n\n\tsource *mockNode\n\ttarget *mockNode\n\n\tamt         lnwire.MilliSatoshi\n\tmaxShardAmt *lnwire.MilliSatoshi\n\tfinalExpiry int32\n\n\tmcCfg          MissionControlConfig\n\tpathFindingCfg PathFindingConfig\n\trouteHints     [][]zpay32.HopHint\n}\n\n// newIntegratedRoutingContext instantiates a new integrated routing test\n// context with a source and a target node.",
      "length": 371,
      "tokens": 38,
      "embedding": []
    },
    {
      "slug": "func newIntegratedRoutingContext(t *testing.T) *integratedRoutingContext {",
      "content": "func newIntegratedRoutingContext(t *testing.T) *integratedRoutingContext {\n\t// Instantiate a mock graph.\n\tsource := newMockNode(sourceNodeID)\n\ttarget := newMockNode(targetNodeID)\n\n\tgraph := newMockGraph(t)\n\tgraph.addNode(source)\n\tgraph.addNode(target)\n\tgraph.source = source\n\n\t// Initiate the test context with a set of default configuration values.\n\t// We don't use the lnd defaults here, because otherwise changing the\n\t// defaults would break the unit tests. The actual values picked aren't\n\t// critical to excite certain behavior, but do need to be aligned with\n\t// the test case assertions.\n\taCfg := AprioriConfig{\n\t\tPenaltyHalfLife:       30 * time.Minute,\n\t\tAprioriHopProbability: 0.6,\n\t\tAprioriWeight:         0.5,\n\t\tCapacityFraction:      testCapacityFraction,\n\t}\n\testimator, err := NewAprioriEstimator(aCfg)\n\trequire.NoError(t, err)\n\n\tctx := integratedRoutingContext{\n\t\tt:           t,\n\t\tgraph:       graph,\n\t\tamt:         100000,\n\t\tfinalExpiry: 40,\n\n\t\tmcCfg: MissionControlConfig{\n\t\t\tEstimator: estimator,\n\t\t},\n\n\t\tpathFindingCfg: PathFindingConfig{\n\t\t\tAttemptCost:    1000,\n\t\t\tMinProbability: 0.01,\n\t\t},\n\n\t\tsource: source,\n\t\ttarget: target,\n\t}\n\n\treturn &ctx\n}\n\n// htlcAttempt records the route and outcome of an attempted htlc.",
      "length": 1118,
      "tokens": 135,
      "embedding": []
    },
    {
      "slug": "type htlcAttempt struct {",
      "content": "type htlcAttempt struct {\n\troute   *route.Route\n\tsuccess bool\n}\n",
      "length": 35,
      "tokens": 5,
      "embedding": []
    },
    {
      "slug": "func (h htlcAttempt) String() string {",
      "content": "func (h htlcAttempt) String() string {\n\treturn fmt.Sprintf(\"success=%v, route=%v\", h.success, h.route)\n}\n\n// testPayment launches a test payment and asserts that it is completed after\n// the expected number of attempts.",
      "length": 176,
      "tokens": 25,
      "embedding": []
    },
    {
      "slug": "func (c *integratedRoutingContext) testPayment(maxParts uint32,",
      "content": "func (c *integratedRoutingContext) testPayment(maxParts uint32,\n\tdestFeatureBits ...lnwire.FeatureBit) ([]htlcAttempt, error) {\n\n\t// We start out with the base set of MPP feature bits. If the caller\n\t// overrides this set of bits, then we'll use their feature bits\n\t// entirely.\n\tbaseFeatureBits := mppFeatures\n\tif len(destFeatureBits) != 0 {\n\t\tbaseFeatureBits = lnwire.NewRawFeatureVector(destFeatureBits...)\n\t}\n\n\tvar (\n\t\tnextPid  uint64\n\t\tattempts []htlcAttempt\n\t)\n\n\t// Create temporary database for mission control.\n\tfile, err := os.CreateTemp(\"\", \"*.db\")\n\tif err != nil {\n\t\tc.t.Fatal(err)\n\t}\n\n\tdbPath := file.Name()\n\tc.t.Cleanup(func() {\n\t\tif err := file.Close(); err != nil {\n\t\t\tc.t.Fatal(err)\n\t\t}\n\t\tif err := os.Remove(dbPath); err != nil {\n\t\t\tc.t.Fatal(err)\n\t\t}\n\t})\n\n\tdb, err := kvdb.Open(\n\t\tkvdb.BoltBackendName, dbPath, true, kvdb.DefaultDBTimeout,\n\t)\n\tif err != nil {\n\t\tc.t.Fatal(err)\n\t}\n\tc.t.Cleanup(func() {\n\t\tif err := db.Close(); err != nil {\n\t\t\tc.t.Fatal(err)\n\t\t}\n\t})\n\n\t// Instantiate a new mission control with the current configuration\n\t// values.\n\tmc, err := NewMissionControl(db, c.source.pubkey, &c.mcCfg)\n\tif err != nil {\n\t\tc.t.Fatal(err)\n\t}\n\n\tgetBandwidthHints := func(_ routingGraph) (bandwidthHints, error) {\n\t\t// Create bandwidth hints based on local channel balances.\n\t\tbandwidthHints := map[uint64]lnwire.MilliSatoshi{}\n\t\tfor _, ch := range c.graph.nodes[c.source.pubkey].channels {\n\t\t\tbandwidthHints[ch.id] = ch.balance\n\t\t}\n\n\t\treturn &mockBandwidthHints{\n\t\t\thints: bandwidthHints,\n\t\t}, nil\n\t}\n\n\tvar paymentAddr [32]byte\n\tpayment := LightningPayment{\n\t\tFinalCLTVDelta: uint16(c.finalExpiry),\n\t\tFeeLimit:       lnwire.MaxMilliSatoshi,\n\t\tTarget:         c.target.pubkey,\n\t\tPaymentAddr:    &paymentAddr,\n\t\tDestFeatures:   lnwire.NewFeatureVector(baseFeatureBits, nil),\n\t\tAmount:         c.amt,\n\t\tCltvLimit:      math.MaxUint32,\n\t\tMaxParts:       maxParts,\n\t\tRouteHints:     c.routeHints,\n\t}\n\n\tvar paymentHash [32]byte\n\tif err := payment.SetPaymentHash(paymentHash); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif c.maxShardAmt != nil {\n\t\tpayment.MaxShardAmt = c.maxShardAmt\n\t}\n\n\tsession, err := newPaymentSession(\n\t\t&payment, getBandwidthHints,\n\t\tfunc() (routingGraph, func(), error) {\n\t\t\treturn c.graph, func() {}, nil\n\t\t},\n\t\tmc, c.pathFindingCfg,\n\t)\n\tif err != nil {\n\t\tc.t.Fatal(err)\n\t}\n\n\t// Override default minimum shard amount.\n\tsession.minShardAmt = lnwire.NewMSatFromSatoshis(5000)\n\n\t// Now the payment control loop starts. It will keep trying routes until\n\t// the payment succeeds.\n\tvar (\n\t\tamtRemaining  = payment.Amount\n\t\tinFlightHtlcs uint32\n\t)\n\tfor {\n\t\t// Create bandwidth hints based on local channel balances.\n\t\tbandwidthHints := map[uint64]lnwire.MilliSatoshi{}\n\t\tfor _, ch := range c.graph.nodes[c.source.pubkey].channels {\n\t\t\tbandwidthHints[ch.id] = ch.balance\n\t\t}\n\n\t\t// Find a route.\n\t\troute, err := session.RequestRoute(\n\t\t\tamtRemaining, lnwire.MaxMilliSatoshi, inFlightHtlcs, 0,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn attempts, err\n\t\t}\n\n\t\t// Send out the htlc on the mock graph.\n\t\tpid := nextPid\n\t\tnextPid++\n\t\thtlcResult, err := c.graph.sendHtlc(route)\n\t\tif err != nil {\n\t\t\tc.t.Fatal(err)\n\t\t}\n\n\t\tsuccess := htlcResult.failure == nil\n\t\tattempts = append(attempts, htlcAttempt{\n\t\t\troute:   route,\n\t\t\tsuccess: success,\n\t\t})\n\n\t\t// Process the result. In normal Lightning operations, the\n\t\t// sender doesn't get an acknowledgement from the recipient that\n\t\t// the htlc arrived. In integrated routing tests, this\n\t\t// acknowledgement is available. It is a simplification of\n\t\t// reality that still allows certain classes of tests to be\n\t\t// performed.\n\t\tif success {\n\t\t\tinFlightHtlcs++\n\n\t\t\terr := mc.ReportPaymentSuccess(pid, route)\n\t\t\tif err != nil {\n\t\t\t\tc.t.Fatal(err)\n\t\t\t}\n\n\t\t\tamtRemaining -= route.ReceiverAmt()\n\n\t\t\t// If the full amount has been paid, the payment is\n\t\t\t// successful and the control loop can be terminated.\n\t\t\tif amtRemaining == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t// Otherwise try to send the remaining amount.\n\t\t\tcontinue\n\t\t}\n\n\t\t// Failure, update mission control and retry.\n\t\tfinalResult, err := mc.ReportPaymentFail(\n\t\t\tpid, route,\n\t\t\tgetNodeIndex(route, htlcResult.failureSource),\n\t\t\thtlcResult.failure,\n\t\t)\n\t\tif err != nil {\n\t\t\tc.t.Fatal(err)\n\t\t}\n\n\t\tif finalResult != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn attempts, nil\n}\n\n// getNodeIndex returns the zero-based index of the given node in the route.",
      "length": 4089,
      "tokens": 539,
      "embedding": []
    },
    {
      "slug": "func getNodeIndex(route *route.Route, failureSource route.Vertex) *int {",
      "content": "func getNodeIndex(route *route.Route, failureSource route.Vertex) *int {\n\tif failureSource == route.SourcePubKey {\n\t\tidx := 0\n\t\treturn &idx\n\t}\n\n\tfor i, h := range route.Hops {\n\t\tif h.PubKeyBytes == failureSource {\n\t\t\tidx := i + 1\n\t\t\treturn &idx\n\t\t}\n\t}\n\treturn nil\n}\n",
      "length": 180,
      "tokens": 35,
      "embedding": []
    }
  ]
}