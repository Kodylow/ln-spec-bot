{
  "filepath": "../implementations/go/lnd/routing/mock_graph_test.go",
  "package": "routing",
  "sections": [
    {
      "slug": "func createPubkey(id byte) route.Vertex {",
      "content": "func createPubkey(id byte) route.Vertex {\n\t_, secpPub := btcec.PrivKeyFromBytes([]byte{id})\n\n\tvar bytes [33]byte\n\tcopy(bytes[:], secpPub.SerializeCompressed()[:33])\n\n\tpubkey := route.Vertex(bytes)\n\treturn pubkey\n}\n\n// mockChannel holds the channel state of a channel in the mock graph.",
      "length": 234,
      "tokens": 28,
      "embedding": []
    },
    {
      "slug": "type mockChannel struct {",
      "content": "type mockChannel struct {\n\tid       uint64\n\tcapacity btcutil.Amount\n\tbalance  lnwire.MilliSatoshi\n}\n\n// mockNode holds a set of mock channels and routing policies for a node in the\n// mock graph.",
      "length": 163,
      "tokens": 26,
      "embedding": []
    },
    {
      "slug": "type mockNode struct {",
      "content": "type mockNode struct {\n\tchannels map[route.Vertex]*mockChannel\n\tbaseFee  lnwire.MilliSatoshi\n\tpubkey   route.Vertex\n}\n\n// newMockNode instantiates a new mock node with a newly generated pubkey.",
      "length": 165,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func newMockNode(id byte) *mockNode {",
      "content": "func newMockNode(id byte) *mockNode {\n\tpubkey := createPubkey(id)\n\treturn &mockNode{\n\t\tchannels: make(map[route.Vertex]*mockChannel),\n\t\tpubkey:   pubkey,\n\t}\n}\n\n// fwd simulates an htlc forward through this node. If the from parameter is\n// nil, this node is considered to be the sender of the payment. The route\n// parameter describes the remaining route from this node onwards. If route.next\n// is nil, this node is the final hop.",
      "length": 383,
      "tokens": 61,
      "embedding": []
    },
    {
      "slug": "func (m *mockNode) fwd(from *mockNode, route *hop) (htlcResult, error) {",
      "content": "func (m *mockNode) fwd(from *mockNode, route *hop) (htlcResult, error) {\n\tnext := route.next\n\n\t// Get the incoming channel, if any.\n\tvar inChan *mockChannel\n\tif from != nil {\n\t\tinChan = m.channels[from.pubkey]\n\t}\n\n\t// If there is no next node, this is the final node and we can settle the htlc.\n\tif next == nil {\n\t\t// Update the incoming balance.\n\t\tinChan.balance += route.amtToFwd\n\n\t\treturn htlcResult{}, nil\n\t}\n\n\t// Check if the outgoing channel has enough balance.\n\toutChan, ok := m.channels[next.node.pubkey]\n\tif !ok {\n\t\treturn htlcResult{},\n\t\t\tfmt.Errorf(\"%v: unknown next %v\",\n\t\t\t\tm.pubkey, next.node.pubkey)\n\t}\n\tif outChan.balance < route.amtToFwd {\n\t\treturn htlcResult{\n\t\t\tfailureSource: m.pubkey,\n\t\t\tfailure:       lnwire.NewTemporaryChannelFailure(nil),\n\t\t}, nil\n\t}\n\n\t// Htlc can be forwarded, update channel balances.\n\toutChan.balance -= route.amtToFwd\n\tif inChan != nil {\n\t\tinChan.balance += route.amtToFwd\n\t}\n\n\t// Recursively forward down the given route.\n\tresult, err := next.node.fwd(m, route.next)\n\tif err != nil {\n\t\treturn htlcResult{}, err\n\t}\n\n\t// Revert balances when a failure occurs.\n\tif result.failure != nil {\n\t\toutChan.balance += route.amtToFwd\n\t\tif inChan != nil {\n\t\t\tinChan.balance -= route.amtToFwd\n\t\t}\n\t}\n\n\treturn result, nil\n}\n\n// mockGraph contains a set of nodes that together for a mocked graph.",
      "length": 1201,
      "tokens": 179,
      "embedding": []
    },
    {
      "slug": "type mockGraph struct {",
      "content": "type mockGraph struct {\n\tt      *testing.T\n\tnodes  map[route.Vertex]*mockNode\n\tsource *mockNode\n}\n\n// newMockGraph instantiates a new mock graph.",
      "length": 116,
      "tokens": 14,
      "embedding": []
    },
    {
      "slug": "func newMockGraph(t *testing.T) *mockGraph {",
      "content": "func newMockGraph(t *testing.T) *mockGraph {\n\treturn &mockGraph{\n\t\tnodes: make(map[route.Vertex]*mockNode),\n\t\tt:     t,\n\t}\n}\n\n// addNode adds the given mock node to the network.",
      "length": 126,
      "tokens": 18,
      "embedding": []
    },
    {
      "slug": "func (m *mockGraph) addNode(node *mockNode) {",
      "content": "func (m *mockGraph) addNode(node *mockNode) {\n\tm.t.Helper()\n\n\tif _, exists := m.nodes[node.pubkey]; exists {\n\t\tm.t.Fatal(\"node already exists\")\n\t}\n\tm.nodes[node.pubkey] = node\n}\n\n// addChannel adds a new channel between two existing nodes on the network. It\n// sets the channel balance to 50/50%.\n//\n// Ignore linter error because addChannel isn't yet called with different\n// capacities.\n// nolint:unparam",
      "length": 347,
      "tokens": 53,
      "embedding": []
    },
    {
      "slug": "func (m *mockGraph) addChannel(id uint64, node1id, node2id byte,",
      "content": "func (m *mockGraph) addChannel(id uint64, node1id, node2id byte,\n\tcapacity btcutil.Amount) {\n\n\tnode1pubkey := createPubkey(node1id)\n\tnode2pubkey := createPubkey(node2id)\n\n\tif _, exists := m.nodes[node1pubkey].channels[node2pubkey]; exists {\n\t\tm.t.Fatal(\"channel already exists\")\n\t}\n\tif _, exists := m.nodes[node2pubkey].channels[node1pubkey]; exists {\n\t\tm.t.Fatal(\"channel already exists\")\n\t}\n\n\tm.nodes[node1pubkey].channels[node2pubkey] = &mockChannel{\n\t\tcapacity: capacity,\n\t\tid:       id,\n\t\tbalance:  lnwire.NewMSatFromSatoshis(capacity / 2),\n\t}\n\tm.nodes[node2pubkey].channels[node1pubkey] = &mockChannel{\n\t\tcapacity: capacity,\n\t\tid:       id,\n\t\tbalance:  lnwire.NewMSatFromSatoshis(capacity / 2),\n\t}\n}\n\n// forEachNodeChannel calls the callback for every channel of the given node.\n//\n// NOTE: Part of the routingGraph interface.",
      "length": 741,
      "tokens": 76,
      "embedding": []
    },
    {
      "slug": "func (m *mockGraph) forEachNodeChannel(nodePub route.Vertex,",
      "content": "func (m *mockGraph) forEachNodeChannel(nodePub route.Vertex,\n\tcb func(channel *channeldb.DirectedChannel) error) error {\n\n\t// Look up the mock node.\n\tnode, ok := m.nodes[nodePub]\n\tif !ok {\n\t\treturn channeldb.ErrGraphNodeNotFound\n\t}\n\n\t// Iterate over all of its channels.\n\tfor peer, channel := range node.channels {\n\t\t// Lexicographically sort the pubkeys.\n\t\tvar node1 route.Vertex\n\t\tif bytes.Compare(nodePub[:], peer[:]) == -1 {\n\t\t\tnode1 = peer\n\t\t} else {\n\t\t\tnode1 = nodePub\n\t\t}\n\n\t\tpeerNode := m.nodes[peer]\n\n\t\t// Call the per channel callback.\n\t\terr := cb(\n\t\t\t&channeldb.DirectedChannel{\n\t\t\t\tChannelID:    channel.id,\n\t\t\t\tIsNode1:      nodePub == node1,\n\t\t\t\tOtherNode:    peer,\n\t\t\t\tCapacity:     channel.capacity,\n\t\t\t\tOutPolicySet: true,\n\t\t\t\tInPolicy: &channeldb.CachedEdgePolicy{\n\t\t\t\t\tChannelID: channel.id,\n\t\t\t\t\tToNodePubKey: func() route.Vertex {\n\t\t\t\t\t\treturn nodePub\n\t\t\t\t\t},\n\t\t\t\t\tToNodeFeatures: lnwire.EmptyFeatureVector(),\n\t\t\t\t\tFeeBaseMSat:    peerNode.baseFee,\n\t\t\t\t},\n\t\t\t},\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// sourceNode returns the source node of the graph.\n//\n// NOTE: Part of the routingGraph interface.",
      "length": 1031,
      "tokens": 132,
      "embedding": []
    },
    {
      "slug": "func (m *mockGraph) sourceNode() route.Vertex {",
      "content": "func (m *mockGraph) sourceNode() route.Vertex {\n\treturn m.source.pubkey\n}\n\n// fetchNodeFeatures returns the features of the given node.\n//\n// NOTE: Part of the routingGraph interface.",
      "length": 130,
      "tokens": 20,
      "embedding": []
    },
    {
      "slug": "func (m *mockGraph) fetchNodeFeatures(nodePub route.Vertex) (",
      "content": "func (m *mockGraph) fetchNodeFeatures(nodePub route.Vertex) (\n\t*lnwire.FeatureVector, error) {\n\n\treturn lnwire.EmptyFeatureVector(), nil\n}\n\n// FetchAmountPairCapacity returns the maximal capacity between nodes in the\n// graph.\n//\n// NOTE: Part of the routingGraph interface.",
      "length": 204,
      "tokens": 27,
      "embedding": []
    },
    {
      "slug": "func (m *mockGraph) FetchAmountPairCapacity(nodeFrom, nodeTo route.Vertex,",
      "content": "func (m *mockGraph) FetchAmountPairCapacity(nodeFrom, nodeTo route.Vertex,\n\tamount lnwire.MilliSatoshi) (btcutil.Amount, error) {\n\n\tvar capacity btcutil.Amount\n\n\tcb := func(channel *channeldb.DirectedChannel) error {\n\t\tif channel.OtherNode == nodeTo {\n\t\t\tcapacity = channel.Capacity\n\t\t}\n\n\t\treturn nil\n\t}\n\n\terr := m.forEachNodeChannel(nodeFrom, cb)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn capacity, nil\n}\n\n// htlcResult describes the resolution of an htlc. If failure is nil, the htlc\n// was settled.",
      "length": 408,
      "tokens": 60,
      "embedding": []
    },
    {
      "slug": "type htlcResult struct {",
      "content": "type htlcResult struct {\n\tfailureSource route.Vertex\n\tfailure       lnwire.FailureMessage\n}\n\n// hop describes one hop of a route.",
      "length": 100,
      "tokens": 13,
      "embedding": []
    },
    {
      "slug": "type hop struct {",
      "content": "type hop struct {\n\tnode     *mockNode\n\tamtToFwd lnwire.MilliSatoshi\n\tnext     *hop\n}\n\n// sendHtlc sends out an htlc on the mock network and synchronously returns the\n// final resolution of the htlc.",
      "length": 174,
      "tokens": 27,
      "embedding": []
    },
    {
      "slug": "func (m *mockGraph) sendHtlc(route *route.Route) (htlcResult, error) {",
      "content": "func (m *mockGraph) sendHtlc(route *route.Route) (htlcResult, error) {\n\tvar next *hop\n\n\t// Convert the route into a structure that is suitable for recursive\n\t// processing.\n\tfor i := len(route.Hops) - 1; i >= 0; i-- {\n\t\trouteHop := route.Hops[i]\n\t\tnode := m.nodes[routeHop.PubKeyBytes]\n\t\tnext = &hop{\n\t\t\tnode:     node,\n\t\t\tnext:     next,\n\t\t\tamtToFwd: routeHop.AmtToForward,\n\t\t}\n\t}\n\n\t// Create the starting hop instance.\n\tsource := m.nodes[route.SourcePubKey]\n\tnext = &hop{\n\t\tnode:     source,\n\t\tnext:     next,\n\t\tamtToFwd: route.TotalAmount,\n\t}\n\n\t// Recursively walk the path and obtain the htlc resolution.\n\treturn source.fwd(nil, next)\n}\n\n// Compile-time check for the routingGraph interface.\nvar _ routingGraph = &mockGraph{}\n",
      "length": 631,
      "tokens": 90,
      "embedding": []
    }
  ]
}