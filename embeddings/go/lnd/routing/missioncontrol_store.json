{
  "filepath": "../implementations/go/lnd/routing/missioncontrol_store.go",
  "package": "routing",
  "sections": [
    {
      "slug": "type missionControlStore struct {",
      "content": "type missionControlStore struct {\n\tdone    chan struct{}\n\twg      sync.WaitGroup\n\tdb      kvdb.Backend\n\tqueueMx sync.Mutex\n\n\t// queue stores all pending payment results not yet added to the store.\n\tqueue *list.List\n\n\t// keys holds the stored MC store item keys in the order of storage.\n\t// We use this list when adding/deleting items from the database to\n\t// avoid cursor use which may be slow in the remote DB case.\n\tkeys *list.List\n\n\t// keysMap holds the stored MC store item keys. We use this map to check\n\t// if a new payment result has already been stored.\n\tkeysMap map[string]struct{}\n\n\t// maxRecords is the maximum amount of records we will store in the db.\n\tmaxRecords int\n\n\t// flushInterval is the configured interval we use to store new results\n\t// and delete outdated ones from the db.\n\tflushInterval time.Duration\n}\n",
      "length": 770,
      "tokens": 131,
      "embedding": []
    },
    {
      "slug": "func newMissionControlStore(db kvdb.Backend, maxRecords int,",
      "content": "func newMissionControlStore(db kvdb.Backend, maxRecords int,\n\tflushInterval time.Duration) (*missionControlStore, error) {\n\n\tvar (\n\t\tkeys    *list.List\n\t\tkeysMap map[string]struct{}\n\t)\n\n\t// Create buckets if not yet existing.\n\terr := kvdb.Update(db, func(tx kvdb.RwTx) error {\n\t\tresultsBucket, err := tx.CreateTopLevelBucket(resultsKey)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"cannot create results bucket: %v\",\n\t\t\t\terr)\n\t\t}\n\n\t\t// Collect all keys to be able to quickly calculate the\n\t\t// difference when updating the DB state.\n\t\tc := resultsBucket.ReadCursor()\n\t\tfor k, _ := c.First(); k != nil; k, _ = c.Next() {\n\t\t\tkeys.PushBack(string(k))\n\t\t\tkeysMap[string(k)] = struct{}{}\n\t\t}\n\n\t\treturn nil\n\t}, func() {\n\t\tkeys = list.New()\n\t\tkeysMap = make(map[string]struct{})\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &missionControlStore{\n\t\tdone:          make(chan struct{}),\n\t\tdb:            db,\n\t\tqueue:         list.New(),\n\t\tkeys:          keys,\n\t\tkeysMap:       keysMap,\n\t\tmaxRecords:    maxRecords,\n\t\tflushInterval: flushInterval,\n\t}, nil\n}\n\n// clear removes all results from the db.",
      "length": 986,
      "tokens": 131,
      "embedding": []
    },
    {
      "slug": "func (b *missionControlStore) clear() error {",
      "content": "func (b *missionControlStore) clear() error {\n\tb.queueMx.Lock()\n\tdefer b.queueMx.Unlock()\n\n\terr := kvdb.Update(b.db, func(tx kvdb.RwTx) error {\n\t\tif err := tx.DeleteTopLevelBucket(resultsKey); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t_, err := tx.CreateTopLevelBucket(resultsKey)\n\t\treturn err\n\t}, func() {})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tb.queue = list.New()\n\treturn nil\n}\n\n// fetchAll returns all results currently stored in the database.",
      "length": 372,
      "tokens": 54,
      "embedding": []
    },
    {
      "slug": "func (b *missionControlStore) fetchAll() ([]*paymentResult, error) {",
      "content": "func (b *missionControlStore) fetchAll() ([]*paymentResult, error) {\n\tvar results []*paymentResult\n\n\terr := kvdb.View(b.db, func(tx kvdb.RTx) error {\n\t\tresultBucket := tx.ReadBucket(resultsKey)\n\t\tresults = make([]*paymentResult, 0)\n\n\t\treturn resultBucket.ForEach(func(k, v []byte) error {\n\t\t\tresult, err := deserializeResult(k, v)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tresults = append(results, result)\n\n\t\t\treturn nil\n\t\t})\n\n\t}, func() {\n\t\tresults = nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn results, nil\n}\n\n// serializeResult serializes a payment result and returns a key and value byte\n// slice to insert into the bucket.",
      "length": 543,
      "tokens": 83,
      "embedding": []
    },
    {
      "slug": "func serializeResult(rp *paymentResult) ([]byte, []byte, error) {",
      "content": "func serializeResult(rp *paymentResult) ([]byte, []byte, error) {\n\t// Write timestamps, success status, failure source index and route.\n\tvar b bytes.Buffer\n\n\tvar dbFailureSourceIdx int32\n\tif rp.failureSourceIdx == nil {\n\t\tdbFailureSourceIdx = unknownFailureSourceIdx\n\t} else {\n\t\tdbFailureSourceIdx = int32(*rp.failureSourceIdx)\n\t}\n\n\terr := channeldb.WriteElements(\n\t\t&b,\n\t\tuint64(rp.timeFwd.UnixNano()),\n\t\tuint64(rp.timeReply.UnixNano()),\n\t\trp.success, dbFailureSourceIdx,\n\t)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tif err := channeldb.SerializeRoute(&b, *rp.route); err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// Write failure. If there is no failure message, write an empty\n\t// byte slice.\n\tvar failureBytes bytes.Buffer\n\tif rp.failure != nil {\n\t\terr := lnwire.EncodeFailureMessage(&failureBytes, rp.failure, 0)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t}\n\terr = wire.WriteVarBytes(&b, 0, failureBytes.Bytes())\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// Compose key that identifies this result.\n\tkey := getResultKey(rp)\n\n\treturn key, b.Bytes(), nil\n}\n\n// deserializeResult deserializes a payment result.",
      "length": 1007,
      "tokens": 139,
      "embedding": []
    },
    {
      "slug": "func deserializeResult(k, v []byte) (*paymentResult, error) {",
      "content": "func deserializeResult(k, v []byte) (*paymentResult, error) {\n\t// Parse payment id.\n\tresult := paymentResult{\n\t\tid: byteOrder.Uint64(k[8:]),\n\t}\n\n\tr := bytes.NewReader(v)\n\n\t// Read timestamps, success status and failure source index.\n\tvar (\n\t\ttimeFwd, timeReply uint64\n\t\tdbFailureSourceIdx int32\n\t)\n\n\terr := channeldb.ReadElements(\n\t\tr, &timeFwd, &timeReply, &result.success, &dbFailureSourceIdx,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Convert time stamps to local time zone for consistent logging.\n\tresult.timeFwd = time.Unix(0, int64(timeFwd)).Local()\n\tresult.timeReply = time.Unix(0, int64(timeReply)).Local()\n\n\t// Convert from unknown index magic number to nil value.\n\tif dbFailureSourceIdx != unknownFailureSourceIdx {\n\t\tfailureSourceIdx := int(dbFailureSourceIdx)\n\t\tresult.failureSourceIdx = &failureSourceIdx\n\t}\n\n\t// Read route.\n\troute, err := channeldb.DeserializeRoute(r)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresult.route = &route\n\n\t// Read failure.\n\tfailureBytes, err := wire.ReadVarBytes(\n\t\tr, 0, math.MaxUint16, \"failure\",\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(failureBytes) > 0 {\n\t\tresult.failure, err = lnwire.DecodeFailureMessage(\n\t\t\tbytes.NewReader(failureBytes), 0,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn &result, nil\n}\n\n// AddResult adds a new result to the db.",
      "length": 1198,
      "tokens": 164,
      "embedding": []
    },
    {
      "slug": "func (b *missionControlStore) AddResult(rp *paymentResult) {",
      "content": "func (b *missionControlStore) AddResult(rp *paymentResult) {\n\tb.queueMx.Lock()\n\tdefer b.queueMx.Unlock()\n\tb.queue.PushBack(rp)\n}\n\n// stop stops the store ticker goroutine.",
      "length": 105,
      "tokens": 12,
      "embedding": []
    },
    {
      "slug": "func (b *missionControlStore) stop() {",
      "content": "func (b *missionControlStore) stop() {\n\tclose(b.done)\n\tb.wg.Wait()\n}\n\n// run runs the MC store ticker goroutine.",
      "length": 69,
      "tokens": 11,
      "embedding": []
    },
    {
      "slug": "func (b *missionControlStore) run() {",
      "content": "func (b *missionControlStore) run() {\n\tb.wg.Add(1)\n\n\tgo func() {\n\t\tticker := time.NewTicker(b.flushInterval)\n\t\tdefer ticker.Stop()\n\t\tdefer b.wg.Done()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ticker.C:\n\t\t\t\tif err := b.storeResults(); err != nil {\n\t\t\t\t\tlog.Errorf(\"Failed to update mission \"+\n\t\t\t\t\t\t\"control store: %v\", err)\n\t\t\t\t}\n\n\t\t\tcase <-b.done:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n}\n\n// storeResults stores all accumulated results.",
      "length": 354,
      "tokens": 48,
      "embedding": []
    },
    {
      "slug": "func (b *missionControlStore) storeResults() error {",
      "content": "func (b *missionControlStore) storeResults() error {\n\tb.queueMx.Lock()\n\tl := b.queue\n\tb.queue = list.New()\n\tb.queueMx.Unlock()\n\n\tvar (\n\t\tkeys    *list.List\n\t\tkeysMap map[string]struct{}\n\t)\n\n\terr := kvdb.Update(b.db, func(tx kvdb.RwTx) error {\n\t\tbucket := tx.ReadWriteBucket(resultsKey)\n\n\t\tfor e := l.Front(); e != nil; e = e.Next() {\n\t\t\tpr := e.Value.(*paymentResult)\n\t\t\t// Serialize result into key and value byte slices.\n\t\t\tk, v, err := serializeResult(pr)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// The store is assumed to be idempotent. It could be\n\t\t\t// that the same result is added twice and in that case\n\t\t\t// we don't need to put the value again.\n\t\t\tif _, ok := keysMap[string(k)]; ok {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Put into results bucket.\n\t\t\tif err := bucket.Put(k, v); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tkeys.PushBack(string(k))\n\t\t\tkeysMap[string(k)] = struct{}{}\n\t\t}\n\n\t\t// Prune oldest entries.\n\t\tfor {\n\t\t\tif b.maxRecords == 0 || keys.Len() <= b.maxRecords {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tfront := keys.Front()\n\t\t\tkey := front.Value.(string)\n\n\t\t\tif err := bucket.Delete([]byte(key)); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tkeys.Remove(front)\n\t\t\tdelete(keysMap, key)\n\t\t}\n\n\t\treturn nil\n\t}, func() {\n\t\tkeys = list.New()\n\t\tkeys.PushBackList(b.keys)\n\n\t\tkeysMap = make(map[string]struct{})\n\t\tfor k := range b.keysMap {\n\t\t\tkeysMap[k] = struct{}{}\n\t\t}\n\t})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tb.keys = keys\n\tb.keysMap = keysMap\n\n\treturn nil\n}\n\n// getResultKey returns a byte slice representing a unique key for this payment\n// result.",
      "length": 1397,
      "tokens": 217,
      "embedding": []
    },
    {
      "slug": "func getResultKey(rp *paymentResult) []byte {",
      "content": "func getResultKey(rp *paymentResult) []byte {\n\tvar keyBytes [8 + 8 + 33]byte\n\n\t// Identify records by a combination of time, payment id and sender pub\n\t// key. This allows importing mission control data from an external\n\t// source without key collisions and keeps the records sorted\n\t// chronologically.\n\tbyteOrder.PutUint64(keyBytes[:], uint64(rp.timeReply.UnixNano()))\n\tbyteOrder.PutUint64(keyBytes[8:], rp.id)\n\tcopy(keyBytes[16:], rp.route.SourcePubKey[:])\n\n\treturn keyBytes[:]\n}\n",
      "length": 425,
      "tokens": 52,
      "embedding": []
    }
  ]
}