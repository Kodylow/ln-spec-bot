{
  "filepath": "../implementations/go/lnd/routing/control_tower_test.go",
  "package": "routing",
  "sections": [
    {
      "slug": "func TestControlTowerSubscribeUnknown(t *testing.T) {",
      "content": "func TestControlTowerSubscribeUnknown(t *testing.T) {\n\tt.Parallel()\n\n\tdb, err := initDB(t, false)\n\trequire.NoError(t, err, \"unable to init db\")\n\n\tpControl := NewControlTower(channeldb.NewPaymentControl(db))\n\n\t// Subscription should fail when the payment is not known.\n\t_, err = pControl.SubscribePayment(lntypes.Hash{1})\n\tif err != channeldb.ErrPaymentNotInitiated {\n\t\tt.Fatal(\"expected subscribe to fail for unknown payment\")\n\t}\n}\n\n// TestControlTowerSubscribeSuccess tests that payment updates for a\n// successful payment are properly sent to subscribers.",
      "length": 488,
      "tokens": 59,
      "embedding": []
    },
    {
      "slug": "func TestControlTowerSubscribeSuccess(t *testing.T) {",
      "content": "func TestControlTowerSubscribeSuccess(t *testing.T) {\n\tt.Parallel()\n\n\tdb, err := initDB(t, false)\n\trequire.NoError(t, err, \"unable to init db\")\n\n\tpControl := NewControlTower(channeldb.NewPaymentControl(db))\n\n\t// Initiate a payment.\n\tinfo, attempt, preimg, err := genInfo()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = pControl.InitPayment(info.PaymentIdentifier, info)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Subscription should succeed and immediately report the InFlight\n\t// status.\n\tsubscriber1, err := pControl.SubscribePayment(info.PaymentIdentifier)\n\trequire.NoError(t, err, \"expected subscribe to succeed, but got\")\n\n\t// Register an attempt.\n\terr = pControl.RegisterAttempt(info.PaymentIdentifier, attempt)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Register a second subscriber after the first attempt has started.\n\tsubscriber2, err := pControl.SubscribePayment(info.PaymentIdentifier)\n\trequire.NoError(t, err, \"expected subscribe to succeed, but got\")\n\n\t// Mark the payment as successful.\n\tsettleInfo := channeldb.HTLCSettleInfo{\n\t\tPreimage: preimg,\n\t}\n\thtlcAttempt, err := pControl.SettleAttempt(\n\t\tinfo.PaymentIdentifier, attempt.AttemptID, &settleInfo,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif *htlcAttempt.Settle != settleInfo {\n\t\tt.Fatalf(\"unexpected settle info returned\")\n\t}\n\n\t// Register a third subscriber after the payment succeeded.\n\tsubscriber3, err := pControl.SubscribePayment(info.PaymentIdentifier)\n\trequire.NoError(t, err, \"expected subscribe to succeed, but got\")\n\n\t// We expect all subscribers to now report the final outcome followed by\n\t// no other events.\n\tsubscribers := []ControlTowerSubscriber{\n\t\tsubscriber1, subscriber2, subscriber3,\n\t}\n\n\tfor _, s := range subscribers {\n\t\tvar result *channeldb.MPPayment\n\t\tfor result == nil || result.Status == channeldb.StatusInFlight {\n\t\t\tselect {\n\t\t\tcase item := <-s.Updates():\n\t\t\t\tresult = item.(*channeldb.MPPayment)\n\t\t\tcase <-time.After(testTimeout):\n\t\t\t\tt.Fatal(\"timeout waiting for payment result\")\n\t\t\t}\n\t\t}\n\n\t\tif result.Status != channeldb.StatusSucceeded {\n\t\t\tt.Fatal(\"unexpected payment state\")\n\t\t}\n\t\tsettle, _ := result.TerminalInfo()\n\t\tif settle.Preimage != preimg {\n\t\t\tt.Fatal(\"unexpected preimage\")\n\t\t}\n\t\tif len(result.HTLCs) != 1 {\n\t\t\tt.Fatalf(\"expected one htlc, got %d\", len(result.HTLCs))\n\t\t}\n\t\thtlc := result.HTLCs[0]\n\t\tif !reflect.DeepEqual(htlc.Route, attempt.Route) {\n\t\t\tt.Fatalf(\"unexpected htlc route: %v vs %v\",\n\t\t\t\tspew.Sdump(htlc.Route),\n\t\t\t\tspew.Sdump(attempt.Route))\n\t\t}\n\n\t\t// After the final event, we expect the channel to be closed.\n\t\tselect {\n\t\tcase _, ok := <-s.Updates():\n\t\t\tif ok {\n\t\t\t\tt.Fatal(\"expected channel to be closed\")\n\t\t\t}\n\t\tcase <-time.After(testTimeout):\n\t\t\tt.Fatal(\"timeout waiting for result channel close\")\n\t\t}\n\t}\n}\n\n// TestPaymentControlSubscribeFail tests that payment updates for a\n// failed payment are properly sent to subscribers.",
      "length": 2701,
      "tokens": 327,
      "embedding": []
    },
    {
      "slug": "func TestPaymentControlSubscribeFail(t *testing.T) {",
      "content": "func TestPaymentControlSubscribeFail(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"register attempt, keep failed payments\", func(t *testing.T) {\n\t\ttestPaymentControlSubscribeFail(t, true, true)\n\t})\n\tt.Run(\"register attempt, delete failed payments\", func(t *testing.T) {\n\t\ttestPaymentControlSubscribeFail(t, true, false)\n\t})\n\tt.Run(\"no register attempt, keep failed payments\", func(t *testing.T) {\n\t\ttestPaymentControlSubscribeFail(t, false, true)\n\t})\n\tt.Run(\"no register attempt, delete failed payments\", func(t *testing.T) {\n\t\ttestPaymentControlSubscribeFail(t, false, false)\n\t})\n}\n\n// TestPaymentControlSubscribeAllSuccess tests that multiple payments are\n// properly sent to subscribers of TrackPayments.",
      "length": 630,
      "tokens": 66,
      "embedding": []
    },
    {
      "slug": "func TestPaymentControlSubscribeAllSuccess(t *testing.T) {",
      "content": "func TestPaymentControlSubscribeAllSuccess(t *testing.T) {\n\tt.Parallel()\n\n\tdb, err := initDB(t, true)\n\trequire.NoError(t, err, \"unable to init db: %v\")\n\n\tpControl := NewControlTower(channeldb.NewPaymentControl(db))\n\n\t// Initiate a payment.\n\tinfo1, attempt1, preimg1, err := genInfo()\n\trequire.NoError(t, err)\n\n\terr = pControl.InitPayment(info1.PaymentIdentifier, info1)\n\trequire.NoError(t, err)\n\n\t// Subscription should succeed and immediately report the InFlight\n\t// status.\n\tsubscription, err := pControl.SubscribeAllPayments()\n\trequire.NoError(t, err, \"expected subscribe to succeed, but got: %v\")\n\n\t// Register an attempt.\n\terr = pControl.RegisterAttempt(info1.PaymentIdentifier, attempt1)\n\trequire.NoError(t, err)\n\n\t// Initiate a second payment after the subscription is already active.\n\tinfo2, attempt2, preimg2, err := genInfo()\n\trequire.NoError(t, err)\n\n\terr = pControl.InitPayment(info2.PaymentIdentifier, info2)\n\trequire.NoError(t, err)\n\n\t// Register an attempt on the second payment.\n\terr = pControl.RegisterAttempt(info2.PaymentIdentifier, attempt2)\n\trequire.NoError(t, err)\n\n\t// Mark the first payment as successful.\n\tsettleInfo1 := channeldb.HTLCSettleInfo{\n\t\tPreimage: preimg1,\n\t}\n\thtlcAttempt1, err := pControl.SettleAttempt(\n\t\tinfo1.PaymentIdentifier, attempt1.AttemptID, &settleInfo1,\n\t)\n\trequire.NoError(t, err)\n\trequire.Equal(\n\t\tt, settleInfo1, *htlcAttempt1.Settle,\n\t\t\"unexpected settle info returned\",\n\t)\n\n\t// Mark the second payment as successful.\n\tsettleInfo2 := channeldb.HTLCSettleInfo{\n\t\tPreimage: preimg2,\n\t}\n\thtlcAttempt2, err := pControl.SettleAttempt(\n\t\tinfo2.PaymentIdentifier, attempt2.AttemptID, &settleInfo2,\n\t)\n\trequire.NoError(t, err)\n\trequire.Equal(\n\t\tt, settleInfo2, *htlcAttempt2.Settle,\n\t\t\"unexpected fail info returned\",\n\t)\n\n\t// The two payments will be asserted individually, store the last update\n\t// for each payment.\n\tresults := make(map[lntypes.Hash]*channeldb.MPPayment)\n\n\t// After exactly 5 updates both payments will/should have completed.\n\tfor i := 0; i < 5; i++ {\n\t\tselect {\n\t\tcase item := <-subscription.Updates():\n\t\t\tid := item.(*channeldb.MPPayment).Info.PaymentIdentifier\n\t\t\tresults[id] = item.(*channeldb.MPPayment)\n\t\tcase <-time.After(testTimeout):\n\t\t\trequire.Fail(t, \"timeout waiting for payment result\")\n\t\t}\n\t}\n\n\tresult1 := results[info1.PaymentIdentifier]\n\trequire.Equal(\n\t\tt, channeldb.StatusSucceeded, result1.Status,\n\t\t\"unexpected payment state payment 1\",\n\t)\n\n\tsettle1, _ := result1.TerminalInfo()\n\trequire.Equal(\n\t\tt, preimg1, settle1.Preimage, \"unexpected preimage payment 1\",\n\t)\n\n\trequire.Len(\n\t\tt, result1.HTLCs, 1, \"expect 1 htlc for payment 1, got %d\",\n\t\tlen(result1.HTLCs),\n\t)\n\n\thtlc1 := result1.HTLCs[0]\n\trequire.Equal(t, attempt1.Route, htlc1.Route, \"unexpected htlc route.\")\n\n\tresult2 := results[info2.PaymentIdentifier]\n\trequire.Equal(\n\t\tt, channeldb.StatusSucceeded, result2.Status,\n\t\t\"unexpected payment state payment 2\",\n\t)\n\n\tsettle2, _ := result2.TerminalInfo()\n\trequire.Equal(\n\t\tt, preimg2, settle2.Preimage, \"unexpected preimage payment 2\",\n\t)\n\trequire.Len(\n\t\tt, result2.HTLCs, 1, \"expect 1 htlc for payment 2, got %d\",\n\t\tlen(result2.HTLCs),\n\t)\n\n\thtlc2 := result2.HTLCs[0]\n\trequire.Equal(t, attempt2.Route, htlc2.Route, \"unexpected htlc route.\")\n}\n\n// TestPaymentControlSubscribeAllImmediate tests whether already inflight\n// payments are reported at the start of the SubscribeAllPayments subscription.",
      "length": 3211,
      "tokens": 347,
      "embedding": []
    },
    {
      "slug": "func TestPaymentControlSubscribeAllImmediate(t *testing.T) {",
      "content": "func TestPaymentControlSubscribeAllImmediate(t *testing.T) {\n\tt.Parallel()\n\n\tdb, err := initDB(t, true)\n\trequire.NoError(t, err, \"unable to init db: %v\")\n\n\tpControl := NewControlTower(channeldb.NewPaymentControl(db))\n\n\t// Initiate a payment.\n\tinfo, attempt, _, err := genInfo()\n\trequire.NoError(t, err)\n\n\terr = pControl.InitPayment(info.PaymentIdentifier, info)\n\trequire.NoError(t, err)\n\n\t// Register a payment update.\n\terr = pControl.RegisterAttempt(info.PaymentIdentifier, attempt)\n\trequire.NoError(t, err)\n\n\tsubscription, err := pControl.SubscribeAllPayments()\n\trequire.NoError(t, err, \"expected subscribe to succeed, but got: %v\")\n\n\t// Assert the new subscription receives the old update.\n\tselect {\n\tcase update := <-subscription.Updates():\n\t\trequire.NotNil(t, update)\n\t\trequire.Equal(\n\t\t\tt, info.PaymentIdentifier,\n\t\t\tupdate.(*channeldb.MPPayment).Info.PaymentIdentifier,\n\t\t)\n\t\trequire.Len(t, subscription.Updates(), 0)\n\tcase <-time.After(testTimeout):\n\t\trequire.Fail(t, \"timeout waiting for payment result\")\n\t}\n}\n\n// TestPaymentControlUnsubscribeSuccess tests that when unsubscribed, there are\n// no more notifications to that specific subscription.",
      "length": 1058,
      "tokens": 109,
      "embedding": []
    },
    {
      "slug": "func TestPaymentControlUnsubscribeSuccess(t *testing.T) {",
      "content": "func TestPaymentControlUnsubscribeSuccess(t *testing.T) {\n\tt.Parallel()\n\n\tdb, err := initDB(t, true)\n\trequire.NoError(t, err, \"unable to init db: %v\")\n\n\tpControl := NewControlTower(channeldb.NewPaymentControl(db))\n\n\tsubscription1, err := pControl.SubscribeAllPayments()\n\trequire.NoError(t, err, \"expected subscribe to succeed, but got: %v\")\n\n\tsubscription2, err := pControl.SubscribeAllPayments()\n\trequire.NoError(t, err, \"expected subscribe to succeed, but got: %v\")\n\n\t// Initiate a payment.\n\tinfo, attempt, _, err := genInfo()\n\trequire.NoError(t, err)\n\n\terr = pControl.InitPayment(info.PaymentIdentifier, info)\n\trequire.NoError(t, err)\n\n\t// Register a payment update.\n\terr = pControl.RegisterAttempt(info.PaymentIdentifier, attempt)\n\trequire.NoError(t, err)\n\n\t// Assert all subscriptions receive the update.\n\tselect {\n\tcase update1 := <-subscription1.Updates():\n\t\trequire.NotNil(t, update1)\n\tcase <-time.After(testTimeout):\n\t\trequire.Fail(t, \"timeout waiting for payment result\")\n\t}\n\n\tselect {\n\tcase update2 := <-subscription2.Updates():\n\t\trequire.NotNil(t, update2)\n\tcase <-time.After(testTimeout):\n\t\trequire.Fail(t, \"timeout waiting for payment result\")\n\t}\n\n\t// Close the first subscription.\n\tsubscription1.Close()\n\n\t// Register another update.\n\tfailInfo := channeldb.HTLCFailInfo{\n\t\tReason: channeldb.HTLCFailInternal,\n\t}\n\t_, err = pControl.FailAttempt(\n\t\tinfo.PaymentIdentifier, attempt.AttemptID, &failInfo,\n\t)\n\trequire.NoError(t, err, \"unable to fail htlc\")\n\n\t// Assert only subscription 2 receives the update.\n\tselect {\n\tcase update2 := <-subscription2.Updates():\n\t\trequire.NotNil(t, update2)\n\tcase <-time.After(testTimeout):\n\t\trequire.Fail(t, \"timeout waiting for payment result\")\n\t}\n\n\trequire.Len(t, subscription1.Updates(), 0)\n\n\t// Close the second subscription.\n\tsubscription2.Close()\n\n\t// Register a last update.\n\terr = pControl.RegisterAttempt(info.PaymentIdentifier, attempt)\n\trequire.NoError(t, err)\n\n\t// Assert no subscriptions receive the update.\n\trequire.Len(t, subscription1.Updates(), 0)\n\trequire.Len(t, subscription2.Updates(), 0)\n}\n",
      "length": 1926,
      "tokens": 201,
      "embedding": []
    },
    {
      "slug": "func testPaymentControlSubscribeFail(t *testing.T, registerAttempt,",
      "content": "func testPaymentControlSubscribeFail(t *testing.T, registerAttempt,\n\tkeepFailedPaymentAttempts bool) {\n\n\tdb, err := initDB(t, keepFailedPaymentAttempts)\n\trequire.NoError(t, err, \"unable to init db\")\n\n\tpControl := NewControlTower(channeldb.NewPaymentControl(db))\n\n\t// Initiate a payment.\n\tinfo, attempt, _, err := genInfo()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = pControl.InitPayment(info.PaymentIdentifier, info)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Subscription should succeed.\n\tsubscriber1, err := pControl.SubscribePayment(info.PaymentIdentifier)\n\trequire.NoError(t, err, \"expected subscribe to succeed, but got\")\n\n\t// Conditionally register the attempt based on the test type. This\n\t// allows us to simulate failing after attempting with an htlc or before\n\t// making any attempts at all.\n\tif registerAttempt {\n\t\t// Register an attempt.\n\t\terr = pControl.RegisterAttempt(info.PaymentIdentifier, attempt)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// Fail the payment attempt.\n\t\tfailInfo := channeldb.HTLCFailInfo{\n\t\t\tReason: channeldb.HTLCFailInternal,\n\t\t}\n\t\thtlcAttempt, err := pControl.FailAttempt(\n\t\t\tinfo.PaymentIdentifier, attempt.AttemptID, &failInfo,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to fail htlc: %v\", err)\n\t\t}\n\t\tif *htlcAttempt.Failure != failInfo {\n\t\t\tt.Fatalf(\"unexpected fail info returned\")\n\t\t}\n\t}\n\n\t// Mark the payment as failed.\n\terr = pControl.FailPayment(\n\t\tinfo.PaymentIdentifier, channeldb.FailureReasonTimeout,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Register a second subscriber after the payment failed.\n\tsubscriber2, err := pControl.SubscribePayment(info.PaymentIdentifier)\n\trequire.NoError(t, err, \"expected subscribe to succeed, but got\")\n\n\t// We expect both subscribers to now report the final outcome followed\n\t// by no other events.\n\tsubscribers := []ControlTowerSubscriber{\n\t\tsubscriber1, subscriber2,\n\t}\n\n\tfor _, s := range subscribers {\n\t\tvar result *channeldb.MPPayment\n\t\tfor result == nil || result.Status == channeldb.StatusInFlight {\n\t\t\tselect {\n\t\t\tcase item := <-s.Updates():\n\t\t\t\tresult = item.(*channeldb.MPPayment)\n\t\t\tcase <-time.After(testTimeout):\n\t\t\t\tt.Fatal(\"timeout waiting for payment result\")\n\t\t\t}\n\t\t}\n\n\t\tif result.Status == channeldb.StatusSucceeded {\n\t\t\tt.Fatal(\"unexpected payment state\")\n\t\t}\n\n\t\t// There will either be one or zero htlcs depending on whether\n\t\t// or not the attempt was registered. Assert the correct number\n\t\t// is present, and the route taken if the attempt was\n\t\t// registered.\n\t\tif registerAttempt {\n\t\t\tif len(result.HTLCs) != 1 {\n\t\t\t\tt.Fatalf(\"expected 1 htlc, got: %d\",\n\t\t\t\t\tlen(result.HTLCs))\n\t\t\t}\n\n\t\t\thtlc := result.HTLCs[0]\n\t\t\tif !reflect.DeepEqual(htlc.Route, testRoute) {\n\t\t\t\tt.Fatalf(\"unexpected htlc route: %v vs %v\",\n\t\t\t\t\tspew.Sdump(htlc.Route),\n\t\t\t\t\tspew.Sdump(testRoute))\n\t\t\t}\n\t\t} else if len(result.HTLCs) != 0 {\n\t\t\tt.Fatalf(\"expected 0 htlcs, got: %d\",\n\t\t\t\tlen(result.HTLCs))\n\t\t}\n\n\t\tif *result.FailureReason != channeldb.FailureReasonTimeout {\n\t\t\tt.Fatal(\"unexpected failure reason\")\n\t\t}\n\n\t\t// After the final event, we expect the channel to be closed.\n\t\tselect {\n\t\tcase _, ok := <-s.Updates():\n\t\t\tif ok {\n\t\t\t\tt.Fatal(\"expected channel to be closed\")\n\t\t\t}\n\t\tcase <-time.After(testTimeout):\n\t\t\tt.Fatal(\"timeout waiting for result channel close\")\n\t\t}\n\t}\n}\n",
      "length": 3072,
      "tokens": 389,
      "embedding": []
    },
    {
      "slug": "func initDB(t *testing.T, keepFailedPaymentAttempts bool) (*channeldb.DB, error) {",
      "content": "func initDB(t *testing.T, keepFailedPaymentAttempts bool) (*channeldb.DB, error) {\n\tdb, err := channeldb.Open(\n\t\tt.TempDir(), channeldb.OptionKeepFailedPaymentAttempts(\n\t\t\tkeepFailedPaymentAttempts,\n\t\t),\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn db, err\n}\n",
      "length": 170,
      "tokens": 22,
      "embedding": []
    },
    {
      "slug": "func genInfo() (*channeldb.PaymentCreationInfo, *channeldb.HTLCAttemptInfo,",
      "content": "func genInfo() (*channeldb.PaymentCreationInfo, *channeldb.HTLCAttemptInfo,\n\tlntypes.Preimage, error) {\n\n\tpreimage, err := genPreimage()\n\tif err != nil {\n\t\treturn nil, nil, preimage, fmt.Errorf(\"unable to \"+\n\t\t\t\"generate preimage: %v\", err)\n\t}\n\n\trhash := sha256.Sum256(preimage[:])\n\treturn &channeldb.PaymentCreationInfo{\n\t\t\tPaymentIdentifier: rhash,\n\t\t\tValue:             testRoute.ReceiverAmt(),\n\t\t\tCreationTime:      time.Unix(time.Now().Unix(), 0),\n\t\t\tPaymentRequest:    []byte(\"hola\"),\n\t\t},\n\t\tchanneldb.NewHtlcAttemptInfo(\n\t\t\t1, priv, testRoute, time.Time{}, nil,\n\t\t), preimage, nil\n}\n",
      "length": 495,
      "tokens": 49,
      "embedding": []
    },
    {
      "slug": "func genPreimage() ([32]byte, error) {",
      "content": "func genPreimage() ([32]byte, error) {\n\tvar preimage [32]byte\n\tif _, err := io.ReadFull(rand.Reader, preimage[:]); err != nil {\n\t\treturn preimage, err\n\t}\n\treturn preimage, nil\n}\n",
      "length": 133,
      "tokens": 21,
      "embedding": []
    }
  ]
}