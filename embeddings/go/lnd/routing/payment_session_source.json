{
  "filepath": "../implementations/go/lnd/routing/payment_session_source.go",
  "package": "routing",
  "sections": [
    {
      "slug": "type SessionSource struct {",
      "content": "type SessionSource struct {\n\t// Graph is the channel graph that will be used to gather metrics from\n\t// and also to carry out path finding queries.\n\tGraph *channeldb.ChannelGraph\n\n\t// SourceNode is the graph's source node.\n\tSourceNode *channeldb.LightningNode\n\n\t// GetLink is a method that allows querying the lower link layer\n\t// to determine the up to date available bandwidth at a prospective link\n\t// to be traversed. If the link isn't available, then a value of zero\n\t// should be returned. Otherwise, the current up to date knowledge of\n\t// the available bandwidth of the link should be returned.\n\tGetLink getLinkQuery\n\n\t// MissionControl is a shared memory of sorts that executions of payment\n\t// path finding use in order to remember which vertexes/edges were\n\t// pruned from prior attempts. During payment execution, errors sent by\n\t// nodes are mapped into a vertex or edge to be pruned. Each run will\n\t// then take into account this set of pruned vertexes/edges to reduce\n\t// route failure and pass on graph information gained to the next\n\t// execution.\n\tMissionControl MissionController\n\n\t// PathFindingConfig defines global parameters that control the\n\t// trade-off in path finding between fees and probabiity.\n\tPathFindingConfig PathFindingConfig\n}\n\n// getRoutingGraph returns a routing graph and a clean-up function for\n// pathfinding.",
      "length": 1293,
      "tokens": 207,
      "embedding": []
    },
    {
      "slug": "func (m *SessionSource) getRoutingGraph() (routingGraph, func(), error) {",
      "content": "func (m *SessionSource) getRoutingGraph() (routingGraph, func(), error) {\n\troutingTx, err := NewCachedGraph(m.SourceNode, m.Graph)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\treturn routingTx, func() {\n\t\terr := routingTx.Close()\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Error closing db tx: %v\", err)\n\t\t}\n\t}, nil\n}\n\n// NewPaymentSession creates a new payment session backed by the latest prune\n// view from Mission Control. An optional set of routing hints can be provided\n// in order to populate additional edges to explore when finding a path to the\n// payment's destination.",
      "length": 480,
      "tokens": 81,
      "embedding": []
    },
    {
      "slug": "func (m *SessionSource) NewPaymentSession(p *LightningPayment) (",
      "content": "func (m *SessionSource) NewPaymentSession(p *LightningPayment) (\n\tPaymentSession, error) {\n\n\tgetBandwidthHints := func(graph routingGraph) (bandwidthHints, error) {\n\t\treturn newBandwidthManager(\n\t\t\tgraph, m.SourceNode.PubKeyBytes, m.GetLink,\n\t\t)\n\t}\n\n\tsession, err := newPaymentSession(\n\t\tp, getBandwidthHints, m.getRoutingGraph,\n\t\tm.MissionControl, m.PathFindingConfig,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn session, nil\n}\n\n// NewPaymentSessionEmpty creates a new paymentSession instance that is empty,\n// and will be exhausted immediately. Used for failure reporting to\n// missioncontrol for resumed payment we don't want to make more attempts for.",
      "length": 575,
      "tokens": 74,
      "embedding": []
    },
    {
      "slug": "func (m *SessionSource) NewPaymentSessionEmpty() PaymentSession {",
      "content": "func (m *SessionSource) NewPaymentSessionEmpty() PaymentSession {\n\treturn &paymentSession{\n\t\tempty: true,\n\t}\n}\n\n// RouteHintsToEdges converts a list of invoice route hints to an edge map that\n// can be passed into pathfinding.",
      "length": 154,
      "tokens": 26,
      "embedding": []
    },
    {
      "slug": "func RouteHintsToEdges(routeHints [][]zpay32.HopHint, target route.Vertex) (",
      "content": "func RouteHintsToEdges(routeHints [][]zpay32.HopHint, target route.Vertex) (\n\tmap[route.Vertex][]*channeldb.CachedEdgePolicy, error) {\n\n\tedges := make(map[route.Vertex][]*channeldb.CachedEdgePolicy)\n\n\t// Traverse through all of the available hop hints and include them in\n\t// our edges map, indexed by the public key of the channel's starting\n\t// node.\n\tfor _, routeHint := range routeHints {\n\t\t// If multiple hop hints are provided within a single route\n\t\t// hint, we'll assume they must be chained together and sorted\n\t\t// in forward order in order to reach the target successfully.\n\t\tfor i, hopHint := range routeHint {\n\t\t\t// In order to determine the end node of this hint,\n\t\t\t// we'll need to look at the next hint's start node. If\n\t\t\t// we've reached the end of the hints list, we can\n\t\t\t// assume we've reached the destination.\n\t\t\tendNode := &channeldb.LightningNode{}\n\t\t\tif i != len(routeHint)-1 {\n\t\t\t\tendNode.AddPubKey(routeHint[i+1].NodeID)\n\t\t\t} else {\n\t\t\t\ttargetPubKey, err := btcec.ParsePubKey(\n\t\t\t\t\ttarget[:],\n\t\t\t\t)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tendNode.AddPubKey(targetPubKey)\n\t\t\t}\n\n\t\t\t// Finally, create the channel edge from the hop hint\n\t\t\t// and add it to list of edges corresponding to the node\n\t\t\t// at the start of the channel.\n\t\t\tedge := &channeldb.CachedEdgePolicy{\n\t\t\t\tToNodePubKey: func() route.Vertex {\n\t\t\t\t\treturn endNode.PubKeyBytes\n\t\t\t\t},\n\t\t\t\tToNodeFeatures: lnwire.EmptyFeatureVector(),\n\t\t\t\tChannelID:      hopHint.ChannelID,\n\t\t\t\tFeeBaseMSat: lnwire.MilliSatoshi(\n\t\t\t\t\thopHint.FeeBaseMSat,\n\t\t\t\t),\n\t\t\t\tFeeProportionalMillionths: lnwire.MilliSatoshi(\n\t\t\t\t\thopHint.FeeProportionalMillionths,\n\t\t\t\t),\n\t\t\t\tTimeLockDelta: hopHint.CLTVExpiryDelta,\n\t\t\t}\n\n\t\t\tv := route.NewVertex(hopHint.NodeID)\n\t\t\tedges[v] = append(edges[v], edge)\n\t\t}\n\t}\n\n\treturn edges, nil\n}\n",
      "length": 1672,
      "tokens": 217,
      "embedding": []
    }
  ]
}