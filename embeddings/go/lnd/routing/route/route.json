{
  "filepath": "../implementations/go/lnd/routing/route/route.go",
  "package": "route",
  "sections": [
    {
      "slug": "type Vertex [VertexSize]byte",
      "content": "type Vertex [VertexSize]byte\n\n// NewVertex returns a new Vertex given a public key.",
      "length": 53,
      "tokens": 10,
      "embedding": []
    },
    {
      "slug": "func NewVertex(pub *btcec.PublicKey) Vertex {",
      "content": "func NewVertex(pub *btcec.PublicKey) Vertex {\n\tvar v Vertex\n\tcopy(v[:], pub.SerializeCompressed())\n\treturn v\n}\n\n// NewVertexFromBytes returns a new Vertex based on a serialized pubkey in a\n// byte slice.",
      "length": 151,
      "tokens": 24,
      "embedding": []
    },
    {
      "slug": "func NewVertexFromBytes(b []byte) (Vertex, error) {",
      "content": "func NewVertexFromBytes(b []byte) (Vertex, error) {\n\tvertexLen := len(b)\n\tif vertexLen != VertexSize {\n\t\treturn Vertex{}, fmt.Errorf(\"invalid vertex length of %v, \"+\n\t\t\t\"want %v\", vertexLen, VertexSize)\n\t}\n\n\tvar v Vertex\n\tcopy(v[:], b)\n\treturn v, nil\n}\n\n// NewVertexFromStr returns a new Vertex given its hex-encoded string format.",
      "length": 268,
      "tokens": 41,
      "embedding": []
    },
    {
      "slug": "func NewVertexFromStr(v string) (Vertex, error) {",
      "content": "func NewVertexFromStr(v string) (Vertex, error) {\n\t// Return error if hex string is of incorrect length.\n\tif len(v) != VertexSize*2 {\n\t\treturn Vertex{}, fmt.Errorf(\"invalid vertex string length of \"+\n\t\t\t\"%v, want %v\", len(v), VertexSize*2)\n\t}\n\n\tvertex, err := hex.DecodeString(v)\n\tif err != nil {\n\t\treturn Vertex{}, err\n\t}\n\n\treturn NewVertexFromBytes(vertex)\n}\n\n// String returns a human readable version of the Vertex which is the\n// hex-encoding of the serialized compressed public key.",
      "length": 423,
      "tokens": 66,
      "embedding": []
    },
    {
      "slug": "func (v Vertex) String() string {",
      "content": "func (v Vertex) String() string {\n\treturn fmt.Sprintf(\"%x\", v[:])\n}\n\n// Hop represents an intermediate or final node of the route. This naming\n// is in line with the definition given in BOLT #4: Onion Routing Protocol.\n// The struct houses the channel along which this hop can be reached and\n// the values necessary to create the HTLC that needs to be sent to the\n// next hop. It is also used to encode the per-hop payload included within\n// the Sphinx packet.",
      "length": 418,
      "tokens": 78,
      "embedding": []
    },
    {
      "slug": "type Hop struct {",
      "content": "type Hop struct {\n\t// PubKeyBytes is the raw bytes of the public key of the target node.\n\tPubKeyBytes Vertex\n\n\t// ChannelID is the unique channel ID for the channel. The first 3\n\t// bytes are the block height, the next 3 the index within the block,\n\t// and the last 2 bytes are the output index for the channel.\n\tChannelID uint64\n\n\t// OutgoingTimeLock is the timelock value that should be used when\n\t// crafting the _outgoing_ HTLC from this hop.\n\tOutgoingTimeLock uint32\n\n\t// AmtToForward is the amount that this hop will forward to the next\n\t// hop. This value is less than the value that the incoming HTLC\n\t// carries as a fee will be subtracted by the hop.\n\tAmtToForward lnwire.MilliSatoshi\n\n\t// MPP encapsulates the data required for option_mpp. This field should\n\t// only be set for the final hop.\n\tMPP *record.MPP\n\n\t// AMP encapsulates the data required for option_amp. This field should\n\t// only be set for the final hop.\n\tAMP *record.AMP\n\n\t// CustomRecords if non-nil are a set of additional TLV records that\n\t// should be included in the forwarding instructions for this node.\n\tCustomRecords record.CustomSet\n\n\t// LegacyPayload if true, then this signals that this node doesn't\n\t// understand the new TLV payload, so we must instead use the legacy\n\t// payload.\n\tLegacyPayload bool\n\n\t// Metadata is additional data that is sent along with the payment to\n\t// the payee.\n\tMetadata []byte\n}\n\n// Copy returns a deep copy of the Hop.",
      "length": 1380,
      "tokens": 241,
      "embedding": []
    },
    {
      "slug": "func (h *Hop) Copy() *Hop {",
      "content": "func (h *Hop) Copy() *Hop {\n\tc := *h\n\n\tif h.MPP != nil {\n\t\tm := *h.MPP\n\t\tc.MPP = &m\n\t}\n\n\tif h.AMP != nil {\n\t\ta := *h.AMP\n\t\tc.AMP = &a\n\t}\n\n\treturn &c\n}\n\n// PackHopPayload writes to the passed io.Writer, the series of byes that can\n// be placed directly into the per-hop payload (EOB) for this hop. This will\n// include the required routing fields, as well as serializing any of the\n// passed optional TLVRecords.  nextChanID is the unique channel ID that\n// references the _outgoing_ channel ID that follows this hop. This field\n// follows the same semantics as the NextAddress field in the onion: it should\n// be set to zero to indicate the terminal hop.",
      "length": 605,
      "tokens": 117,
      "embedding": []
    },
    {
      "slug": "func (h *Hop) PackHopPayload(w io.Writer, nextChanID uint64) error {",
      "content": "func (h *Hop) PackHopPayload(w io.Writer, nextChanID uint64) error {\n\t// If this is a legacy payload, then we'll exit here as this method\n\t// shouldn't be called.\n\tif h.LegacyPayload == true {\n\t\treturn fmt.Errorf(\"cannot pack hop payloads for legacy \" +\n\t\t\t\"payloads\")\n\t}\n\n\t// Otherwise, we'll need to make a new stream that includes our\n\t// required routing fields, as well as these optional values.\n\tvar records []tlv.Record\n\n\t// Every hop must have an amount to forward and CLTV expiry.\n\tamt := uint64(h.AmtToForward)\n\trecords = append(records,\n\t\trecord.NewAmtToFwdRecord(&amt),\n\t\trecord.NewLockTimeRecord(&h.OutgoingTimeLock),\n\t)\n\n\t// BOLT 04 says the next_hop_id should be omitted for the final hop,\n\t// but present for all others.\n\t//\n\t// TODO(conner): test using hop.Exit once available\n\tif nextChanID != 0 {\n\t\trecords = append(records,\n\t\t\trecord.NewNextHopIDRecord(&nextChanID),\n\t\t)\n\t}\n\n\t// If an MPP record is destined for this hop, ensure that we only ever\n\t// attach it to the final hop. Otherwise the route was constructed\n\t// incorrectly.\n\tif h.MPP != nil {\n\t\tif nextChanID == 0 {\n\t\t\trecords = append(records, h.MPP.Record())\n\t\t} else {\n\t\t\treturn ErrIntermediateMPPHop\n\t\t}\n\t}\n\n\t// If an AMP record is destined for this hop, ensure that we only ever\n\t// attach it if we also have an MPP record. We can infer that this is\n\t// already a final hop if MPP is non-nil otherwise we would have exited\n\t// above.\n\tif h.AMP != nil {\n\t\tif h.MPP != nil {\n\t\t\trecords = append(records, h.AMP.Record())\n\t\t} else {\n\t\t\treturn ErrAMPMissingMPP\n\t\t}\n\t}\n\n\t// If metadata is specified, generate a tlv record for it.\n\tif h.Metadata != nil {\n\t\trecords = append(records,\n\t\t\trecord.NewMetadataRecord(&h.Metadata),\n\t\t)\n\t}\n\n\t// Append any custom types destined for this hop.\n\ttlvRecords := tlv.MapToRecords(h.CustomRecords)\n\trecords = append(records, tlvRecords...)\n\n\t// To ensure we produce a canonical stream, we'll sort the records\n\t// before encoding them as a stream in the hop payload.\n\ttlv.SortRecords(records)\n\n\ttlvStream, err := tlv.NewStream(records...)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn tlvStream.Encode(w)\n}\n\n// Size returns the total size this hop's payload would take up in the onion\n// packet.",
      "length": 2057,
      "tokens": 330,
      "embedding": []
    },
    {
      "slug": "func (h *Hop) PayloadSize(nextChanID uint64) uint64 {",
      "content": "func (h *Hop) PayloadSize(nextChanID uint64) uint64 {\n\tif h.LegacyPayload {\n\t\treturn sphinx.LegacyHopDataSize\n\t}\n\n\tvar payloadSize uint64\n\n\taddRecord := func(tlvType tlv.Type, length uint64) {\n\t\tpayloadSize += tlv.VarIntSize(uint64(tlvType)) +\n\t\t\ttlv.VarIntSize(length) + length\n\t}\n\n\t// Add amount size.\n\taddRecord(record.AmtOnionType, tlv.SizeTUint64(uint64(h.AmtToForward)))\n\n\t// Add lock time size.\n\taddRecord(\n\t\trecord.LockTimeOnionType,\n\t\ttlv.SizeTUint64(uint64(h.OutgoingTimeLock)),\n\t)\n\n\t// Add next hop if present.\n\tif nextChanID != 0 {\n\t\taddRecord(record.NextHopOnionType, 8)\n\t}\n\n\t// Add mpp if present.\n\tif h.MPP != nil {\n\t\taddRecord(record.MPPOnionType, h.MPP.PayloadSize())\n\t}\n\n\t// Add amp if present.\n\tif h.AMP != nil {\n\t\taddRecord(record.AMPOnionType, h.AMP.PayloadSize())\n\t}\n\n\t// Add metadata if present.\n\tif h.Metadata != nil {\n\t\taddRecord(record.MetadataOnionType, uint64(len(h.Metadata)))\n\t}\n\n\t// Add custom records.\n\tfor k, v := range h.CustomRecords {\n\t\taddRecord(tlv.Type(k), uint64(len(v)))\n\t}\n\n\t// Add the size required to encode the payload length.\n\tpayloadSize += tlv.VarIntSize(payloadSize)\n\n\t// Add HMAC.\n\tpayloadSize += sphinx.HMACSize\n\n\treturn payloadSize\n}\n\n// Route represents a path through the channel graph which runs over one or\n// more channels in succession. This struct carries all the information\n// required to craft the Sphinx onion packet, and send the payment along the\n// first hop in the path. A route is only selected as valid if all the channels\n// have sufficient capacity to carry the initial payment amount after fees are\n// accounted for.",
      "length": 1475,
      "tokens": 200,
      "embedding": []
    },
    {
      "slug": "type Route struct {",
      "content": "type Route struct {\n\t// TotalTimeLock is the cumulative (final) time lock across the entire\n\t// route. This is the CLTV value that should be extended to the first\n\t// hop in the route. All other hops will decrement the time-lock as\n\t// advertised, leaving enough time for all hops to wait for or present\n\t// the payment preimage to complete the payment.\n\tTotalTimeLock uint32\n\n\t// TotalAmount is the total amount of funds required to complete a\n\t// payment over this route. This value includes the cumulative fees at\n\t// each hop. As a result, the HTLC extended to the first-hop in the\n\t// route will need to have at least this many satoshis, otherwise the\n\t// route will fail at an intermediate node due to an insufficient\n\t// amount of fees.\n\tTotalAmount lnwire.MilliSatoshi\n\n\t// SourcePubKey is the pubkey of the node where this route originates\n\t// from.\n\tSourcePubKey Vertex\n\n\t// Hops contains details concerning the specific forwarding details at\n\t// each hop.\n\tHops []*Hop\n}\n\n// Copy returns a deep copy of the Route.",
      "length": 980,
      "tokens": 171,
      "embedding": []
    },
    {
      "slug": "func (r *Route) Copy() *Route {",
      "content": "func (r *Route) Copy() *Route {\n\tc := *r\n\n\tc.Hops = make([]*Hop, len(r.Hops))\n\tfor i := range r.Hops {\n\t\tc.Hops[i] = r.Hops[i].Copy()\n\t}\n\n\treturn &c\n}\n\n// HopFee returns the fee charged by the route hop indicated by hopIndex.",
      "length": 183,
      "tokens": 33,
      "embedding": []
    },
    {
      "slug": "func (r *Route) HopFee(hopIndex int) lnwire.MilliSatoshi {",
      "content": "func (r *Route) HopFee(hopIndex int) lnwire.MilliSatoshi {\n\tvar incomingAmt lnwire.MilliSatoshi\n\tif hopIndex == 0 {\n\t\tincomingAmt = r.TotalAmount\n\t} else {\n\t\tincomingAmt = r.Hops[hopIndex-1].AmtToForward\n\t}\n\n\t// Fee is calculated as difference between incoming and outgoing amount.\n\treturn incomingAmt - r.Hops[hopIndex].AmtToForward\n}\n\n// TotalFees is the sum of the fees paid at each hop within the final route. In\n// the case of a one-hop payment, this value will be zero as we don't need to\n// pay a fee to ourself.",
      "length": 447,
      "tokens": 74,
      "embedding": []
    },
    {
      "slug": "func (r *Route) TotalFees() lnwire.MilliSatoshi {",
      "content": "func (r *Route) TotalFees() lnwire.MilliSatoshi {\n\tif len(r.Hops) == 0 {\n\t\treturn 0\n\t}\n\n\treturn r.TotalAmount - r.ReceiverAmt()\n}\n\n// ReceiverAmt is the amount received by the final hop of this route.",
      "length": 143,
      "tokens": 26,
      "embedding": []
    },
    {
      "slug": "func (r *Route) ReceiverAmt() lnwire.MilliSatoshi {",
      "content": "func (r *Route) ReceiverAmt() lnwire.MilliSatoshi {\n\tif len(r.Hops) == 0 {\n\t\treturn 0\n\t}\n\n\treturn r.Hops[len(r.Hops)-1].AmtToForward\n}\n\n// FinalHop returns the last hop of the route, or nil if the route is empty.",
      "length": 153,
      "tokens": 27,
      "embedding": []
    },
    {
      "slug": "func (r *Route) FinalHop() *Hop {",
      "content": "func (r *Route) FinalHop() *Hop {\n\tif len(r.Hops) == 0 {\n\t\treturn nil\n\t}\n\n\treturn r.Hops[len(r.Hops)-1]\n}\n\n// NewRouteFromHops creates a new Route structure from the minimally required\n// information to perform the payment. It infers fee amounts and populates the\n// node, chan and prev/next hop maps.",
      "length": 258,
      "tokens": 42,
      "embedding": []
    },
    {
      "slug": "func NewRouteFromHops(amtToSend lnwire.MilliSatoshi, timeLock uint32,",
      "content": "func NewRouteFromHops(amtToSend lnwire.MilliSatoshi, timeLock uint32,\n\tsourceVertex Vertex, hops []*Hop) (*Route, error) {\n\n\tif len(hops) == 0 {\n\t\treturn nil, ErrNoRouteHopsProvided\n\t}\n\n\t// First, we'll create a route struct and populate it with the fields\n\t// for which the values are provided as arguments of this function.\n\t// TotalFees is determined based on the difference between the amount\n\t// that is send from the source and the final amount that is received\n\t// by the destination.\n\troute := &Route{\n\t\tSourcePubKey:  sourceVertex,\n\t\tHops:          hops,\n\t\tTotalTimeLock: timeLock,\n\t\tTotalAmount:   amtToSend,\n\t}\n\n\treturn route, nil\n}\n\n// ToSphinxPath converts a complete route into a sphinx PaymentPath that\n// contains the per-hop paylods used to encoding the HTLC routing data for each\n// hop in the route. This method also accepts an optional EOB payload for the\n// final hop.",
      "length": 795,
      "tokens": 129,
      "embedding": []
    },
    {
      "slug": "func (r *Route) ToSphinxPath() (*sphinx.PaymentPath, error) {",
      "content": "func (r *Route) ToSphinxPath() (*sphinx.PaymentPath, error) {\n\tvar path sphinx.PaymentPath\n\n\t// We can only construct a route if there are hops provided.\n\tif len(r.Hops) == 0 {\n\t\treturn nil, ErrNoRouteHopsProvided\n\t}\n\n\t// Check maximum route length.\n\tif len(r.Hops) > sphinx.NumMaxHops {\n\t\treturn nil, ErrMaxRouteHopsExceeded\n\t}\n\n\t// For each hop encoded within the route, we'll convert the hop struct\n\t// to an OnionHop with matching per-hop payload within the path as used\n\t// by the sphinx package.\n\tfor i, hop := range r.Hops {\n\t\tpub, err := btcec.ParsePubKey(hop.PubKeyBytes[:])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// As a base case, the next hop is set to all zeroes in order\n\t\t// to indicate that the \"last hop\" as no further hops after it.\n\t\tnextHop := uint64(0)\n\n\t\t// If we aren't on the last hop, then we set the \"next address\"\n\t\t// field to be the channel that directly follows it.\n\t\tif i != len(r.Hops)-1 {\n\t\t\tnextHop = r.Hops[i+1].ChannelID\n\t\t}\n\n\t\tvar payload sphinx.HopPayload\n\n\t\t// If this is the legacy payload, then we can just include the\n\t\t// hop data as normal.\n\t\tif hop.LegacyPayload {\n\t\t\t// Before we encode this value, we'll pack the next hop\n\t\t\t// into the NextAddress field of the hop info to ensure\n\t\t\t// we point to the right now.\n\t\t\thopData := sphinx.HopData{\n\t\t\t\tForwardAmount: uint64(hop.AmtToForward),\n\t\t\t\tOutgoingCltv:  hop.OutgoingTimeLock,\n\t\t\t}\n\t\t\tbinary.BigEndian.PutUint64(\n\t\t\t\thopData.NextAddress[:], nextHop,\n\t\t\t)\n\n\t\t\tpayload, err = sphinx.NewHopPayload(&hopData, nil)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\t// For non-legacy payloads, we'll need to pack the\n\t\t\t// routing information, along with any extra TLV\n\t\t\t// information into the new per-hop payload format.\n\t\t\t// We'll also pass in the chan ID of the hop this\n\t\t\t// channel should be forwarded to so we can construct a\n\t\t\t// valid payload.\n\t\t\tvar b bytes.Buffer\n\t\t\terr := hop.PackHopPayload(&b, nextHop)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\t// TODO(roasbeef): make better API for NewHopPayload?\n\t\t\tpayload, err = sphinx.NewHopPayload(nil, b.Bytes())\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\tpath[i] = sphinx.OnionHop{\n\t\t\tNodePub:    *pub,\n\t\t\tHopPayload: payload,\n\t\t}\n\t}\n\n\treturn &path, nil\n}\n\n// String returns a human readable representation of the route.",
      "length": 2159,
      "tokens": 347,
      "embedding": []
    },
    {
      "slug": "func (r *Route) String() string {",
      "content": "func (r *Route) String() string {\n\tvar b strings.Builder\n\n\tamt := r.TotalAmount\n\tfor i, hop := range r.Hops {\n\t\tif i > 0 {\n\t\t\tb.WriteString(\" -> \")\n\t\t}\n\t\tb.WriteString(fmt.Sprintf(\"%v (%v)\",\n\t\t\tstrconv.FormatUint(hop.ChannelID, 10),\n\t\t\tamt,\n\t\t))\n\t\tamt = hop.AmtToForward\n\t}\n\n\treturn fmt.Sprintf(\"%v, cltv %v\",\n\t\tb.String(), r.TotalTimeLock,\n\t)\n}\n",
      "length": 294,
      "tokens": 40,
      "embedding": []
    }
  ]
}