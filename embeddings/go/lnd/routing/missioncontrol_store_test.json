{
  "filepath": "../implementations/go/lnd/routing/missioncontrol_store_test.go",
  "package": "routing",
  "sections": [
    {
      "slug": "func TestMissionControlStore(t *testing.T) {",
      "content": "func TestMissionControlStore(t *testing.T) {\n\t// Set time zone explicitly to keep test deterministic.\n\ttime.Local = time.UTC\n\n\tfile, err := os.CreateTemp(\"\", \"*.db\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdbPath := file.Name()\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, file.Close())\n\t\trequire.NoError(t, os.Remove(dbPath))\n\t})\n\n\tdb, err := kvdb.Create(\n\t\tkvdb.BoltBackendName, dbPath, true, kvdb.DefaultDBTimeout,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, db.Close())\n\t})\n\n\tstore, err := newMissionControlStore(db, testMaxRecords, time.Second)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tresults, err := store.fetchAll()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(results) != 0 {\n\t\tt.Fatal(\"expected no results\")\n\t}\n\n\ttestRoute := route.Route{\n\t\tSourcePubKey: route.Vertex{1},\n\t\tHops: []*route.Hop{\n\t\t\t{\n\t\t\t\tPubKeyBytes:   route.Vertex{2},\n\t\t\t\tLegacyPayload: true,\n\t\t\t},\n\t\t},\n\t}\n\n\tfailureSourceIdx := 1\n\n\tresult1 := paymentResult{\n\t\troute:            &testRoute,\n\t\tfailure:          lnwire.NewFailIncorrectDetails(100, 1000),\n\t\tfailureSourceIdx: &failureSourceIdx,\n\t\tid:               99,\n\t\ttimeReply:        testTime,\n\t\ttimeFwd:          testTime.Add(-time.Minute),\n\t}\n\n\tresult2 := result1\n\tresult2.timeReply = result1.timeReply.Add(time.Hour)\n\tresult2.timeFwd = result1.timeReply.Add(time.Hour)\n\tresult2.id = 2\n\n\t// Store result.\n\tstore.AddResult(&result2)\n\n\t// Store again to test idempotency.\n\tstore.AddResult(&result2)\n\n\t// Store second result which has an earlier timestamp.\n\tstore.AddResult(&result1)\n\trequire.NoError(t, store.storeResults())\n\n\tresults, err = store.fetchAll()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\trequire.Equal(t, 2, len(results))\n\n\tif len(results) != 2 {\n\t\tt.Fatal(\"expected two results\")\n\t}\n\n\t// Check that results are stored in chronological order.\n\tif !reflect.DeepEqual(&result1, results[0]) {\n\t\tt.Fatalf(\"the results differ: %v vs %v\", spew.Sdump(&result1),\n\t\t\tspew.Sdump(results[0]))\n\t}\n\tif !reflect.DeepEqual(&result2, results[1]) {\n\t\tt.Fatalf(\"the results differ: %v vs %v\", spew.Sdump(&result2),\n\t\t\tspew.Sdump(results[1]))\n\t}\n\n\t// Recreate store to test pruning.\n\tstore, err = newMissionControlStore(db, testMaxRecords, time.Second)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Add a newer result which failed due to mpp timeout.\n\tresult3 := result1\n\tresult3.timeReply = result1.timeReply.Add(2 * time.Hour)\n\tresult3.timeFwd = result1.timeReply.Add(2 * time.Hour)\n\tresult3.id = 3\n\tresult3.failure = &lnwire.FailMPPTimeout{}\n\n\tstore.AddResult(&result3)\n\trequire.NoError(t, store.storeResults())\n\n\t// Check that results are pruned.\n\tresults, err = store.fetchAll()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\trequire.Equal(t, 2, len(results))\n\tif len(results) != 2 {\n\t\tt.Fatal(\"expected two results\")\n\t}\n\n\tif !reflect.DeepEqual(&result2, results[0]) {\n\t\tt.Fatalf(\"the results differ: %v vs %v\", spew.Sdump(&result2),\n\t\t\tspew.Sdump(results[0]))\n\t}\n\tif !reflect.DeepEqual(&result3, results[1]) {\n\t\tt.Fatalf(\"the results differ: %v vs %v\", spew.Sdump(&result3),\n\t\t\tspew.Sdump(results[1]))\n\t}\n}\n",
      "length": 2863,
      "tokens": 324,
      "embedding": []
    }
  ]
}