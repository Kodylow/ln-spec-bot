{
  "filepath": "../implementations/go/lnd/aliasmgr/aliasmgr.go",
  "package": "aliasmgr",
  "sections": [
    {
      "slug": "type Manager struct {",
      "content": "type Manager struct {\n\tbackend kvdb.Backend\n\n\t// baseToSet is a mapping from the \"base\" SCID to the set of aliases\n\t// for this channel. This mapping includes all channels that\n\t// negotiated the option-scid-alias feature bit.\n\tbaseToSet map[lnwire.ShortChannelID][]lnwire.ShortChannelID\n\n\t// aliasToBase is a mapping that maps all aliases for a given channel\n\t// to its base SCID. This is only used for channels that have\n\t// negotiated option-scid-alias feature bit.\n\taliasToBase map[lnwire.ShortChannelID]lnwire.ShortChannelID\n\n\t// peerAlias is a cache for the alias SCIDs that our peers send us in\n\t// the funding_locked TLV. The keys are the ChannelID generated from\n\t// the FundingOutpoint and the values are the remote peer's alias SCID.\n\t// The values should match the ones stored in the \"invoice-alias-bucket\"\n\t// bucket.\n\tpeerAlias map[lnwire.ChannelID]lnwire.ShortChannelID\n\n\tsync.RWMutex\n}\n\n// NewManager initializes an alias Manager from the passed database backend.",
      "length": 935,
      "tokens": 133,
      "embedding": []
    },
    {
      "slug": "func NewManager(db kvdb.Backend) (*Manager, error) {",
      "content": "func NewManager(db kvdb.Backend) (*Manager, error) {\n\tm := &Manager{backend: db}\n\tm.baseToSet = make(map[lnwire.ShortChannelID][]lnwire.ShortChannelID)\n\tm.aliasToBase = make(map[lnwire.ShortChannelID]lnwire.ShortChannelID)\n\tm.peerAlias = make(map[lnwire.ChannelID]lnwire.ShortChannelID)\n\n\terr := m.populateMaps()\n\treturn m, err\n}\n\n// populateMaps reads the database state and populates the maps.",
      "length": 333,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func (m *Manager) populateMaps() error {",
      "content": "func (m *Manager) populateMaps() error {\n\t// This map tracks the base SCIDs that are confirmed and don't need to\n\t// have entries in the *ToBase mappings as they won't be used in the\n\t// gossiper.\n\tbaseConfMap := make(map[lnwire.ShortChannelID]struct{})\n\n\t// This map caches what is found in the database and is used to\n\t// populate the Manager's actual maps.\n\taliasMap := make(map[lnwire.ShortChannelID]lnwire.ShortChannelID)\n\n\t// This map caches the ChannelID/alias SCIDs stored in the database and\n\t// is used to populate the Manager's cache.\n\tpeerAliasMap := make(map[lnwire.ChannelID]lnwire.ShortChannelID)\n\n\terr := kvdb.Update(m.backend, func(tx kvdb.RwTx) error {\n\t\tbaseConfBucket, err := tx.CreateTopLevelBucket(confirmedBucket)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = baseConfBucket.ForEach(func(k, v []byte) error {\n\t\t\t// The key will the base SCID and the value will be\n\t\t\t// empty. Existence in the bucket means the SCID is\n\t\t\t// confirmed.\n\t\t\tbaseScid := lnwire.NewShortChanIDFromInt(\n\t\t\t\tbyteOrder.Uint64(k),\n\t\t\t)\n\t\t\tbaseConfMap[baseScid] = struct{}{}\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\taliasToBaseBucket, err := tx.CreateTopLevelBucket(aliasBucket)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = aliasToBaseBucket.ForEach(func(k, v []byte) error {\n\t\t\t// The key will be the alias SCID and the value will be\n\t\t\t// the base SCID.\n\t\t\taliasScid := lnwire.NewShortChanIDFromInt(\n\t\t\t\tbyteOrder.Uint64(k),\n\t\t\t)\n\t\t\tbaseScid := lnwire.NewShortChanIDFromInt(\n\t\t\t\tbyteOrder.Uint64(v),\n\t\t\t)\n\t\t\taliasMap[aliasScid] = baseScid\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tinvAliasBucket, err := tx.CreateTopLevelBucket(\n\t\t\tinvoiceAliasBucket,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = invAliasBucket.ForEach(func(k, v []byte) error {\n\t\t\tvar chanID lnwire.ChannelID\n\t\t\tcopy(chanID[:], k)\n\t\t\talias := lnwire.NewShortChanIDFromInt(\n\t\t\t\tbyteOrder.Uint64(v),\n\t\t\t)\n\n\t\t\tpeerAliasMap[chanID] = alias\n\n\t\t\treturn nil\n\t\t})\n\n\t\treturn err\n\t}, func() {\n\t\tbaseConfMap = make(map[lnwire.ShortChannelID]struct{})\n\t\taliasMap = make(map[lnwire.ShortChannelID]lnwire.ShortChannelID)\n\t\tpeerAliasMap = make(map[lnwire.ChannelID]lnwire.ShortChannelID)\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Populate the baseToSet map regardless if the baseSCID is marked as\n\t// public with 6 confirmations.\n\tfor aliasSCID, baseSCID := range aliasMap {\n\t\tm.baseToSet[baseSCID] = append(m.baseToSet[baseSCID], aliasSCID)\n\n\t\t// Skip if baseSCID is in the baseConfMap.\n\t\tif _, ok := baseConfMap[baseSCID]; ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tm.aliasToBase[aliasSCID] = baseSCID\n\t}\n\n\t// Populate the peer alias cache.\n\tm.peerAlias = peerAliasMap\n\n\treturn nil\n}\n\n// AddLocalAlias adds a database mapping from the passed alias to the passed\n// base SCID. The gossip boolean marks whether or not to create a mapping\n// that the gossiper will use. It is set to false for the upgrade path where\n// the feature-bit is toggled on and there are existing channels.",
      "length": 2803,
      "tokens": 383,
      "embedding": []
    },
    {
      "slug": "func (m *Manager) AddLocalAlias(alias, baseScid lnwire.ShortChannelID,",
      "content": "func (m *Manager) AddLocalAlias(alias, baseScid lnwire.ShortChannelID,\n\tgossip bool) error {\n\n\tm.Lock()\n\tdefer m.Unlock()\n\n\terr := kvdb.Update(m.backend, func(tx kvdb.RwTx) error {\n\t\t// If the caller does not want to allow the alias to be used\n\t\t// for a channel update, we'll mark it in the baseConfBucket.\n\t\tif !gossip {\n\t\t\tvar baseGossipBytes [8]byte\n\t\t\tbyteOrder.PutUint64(\n\t\t\t\tbaseGossipBytes[:], baseScid.ToUint64(),\n\t\t\t)\n\n\t\t\tconfBucket, err := tx.CreateTopLevelBucket(\n\t\t\t\tconfirmedBucket,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\terr = confBucket.Put(baseGossipBytes[:], []byte{})\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\taliasToBaseBucket, err := tx.CreateTopLevelBucket(aliasBucket)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvar (\n\t\t\taliasBytes [8]byte\n\t\t\tbaseBytes  [8]byte\n\t\t)\n\n\t\tbyteOrder.PutUint64(aliasBytes[:], alias.ToUint64())\n\t\tbyteOrder.PutUint64(baseBytes[:], baseScid.ToUint64())\n\t\treturn aliasToBaseBucket.Put(aliasBytes[:], baseBytes[:])\n\t}, func() {})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Update the aliasToBase and baseToSet maps.\n\tm.baseToSet[baseScid] = append(m.baseToSet[baseScid], alias)\n\n\t// Only store the gossiper map if gossip is true.\n\tif gossip {\n\t\tm.aliasToBase[alias] = baseScid\n\t}\n\n\treturn nil\n}\n\n// GetAliases fetches the set of aliases stored under a given base SCID from\n// write-through caches.",
      "length": 1220,
      "tokens": 161,
      "embedding": []
    },
    {
      "slug": "func (m *Manager) GetAliases(",
      "content": "func (m *Manager) GetAliases(\n\tbase lnwire.ShortChannelID) []lnwire.ShortChannelID {\n\n\tm.RLock()\n\tdefer m.RUnlock()\n\n\taliasSet, ok := m.baseToSet[base]\n\tif ok {\n\t\t// Copy the found alias slice.\n\t\tsetCopy := make([]lnwire.ShortChannelID, len(aliasSet))\n\t\tcopy(setCopy, aliasSet)\n\t\treturn setCopy\n\t}\n\n\treturn nil\n}\n\n// FindBaseSCID finds the base SCID for a given alias. This is used in the\n// gossiper to find the correct SCID to lookup in the graph database.",
      "length": 411,
      "tokens": 60,
      "embedding": []
    },
    {
      "slug": "func (m *Manager) FindBaseSCID(",
      "content": "func (m *Manager) FindBaseSCID(\n\talias lnwire.ShortChannelID) (lnwire.ShortChannelID, error) {\n\n\tm.RLock()\n\tdefer m.RUnlock()\n\n\tbase, ok := m.aliasToBase[alias]\n\tif ok {\n\t\treturn base, nil\n\t}\n\n\treturn lnwire.ShortChannelID{}, errNoBase\n}\n\n// DeleteSixConfs removes a mapping for the gossiper once six confirmations\n// have been reached and the channel is public. At this point, only the\n// confirmed SCID should be used.",
      "length": 373,
      "tokens": 54,
      "embedding": []
    },
    {
      "slug": "func (m *Manager) DeleteSixConfs(baseScid lnwire.ShortChannelID) error {",
      "content": "func (m *Manager) DeleteSixConfs(baseScid lnwire.ShortChannelID) error {\n\tm.Lock()\n\tdefer m.Unlock()\n\n\terr := kvdb.Update(m.backend, func(tx kvdb.RwTx) error {\n\t\tbaseConfBucket, err := tx.CreateTopLevelBucket(confirmedBucket)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvar baseBytes [8]byte\n\t\tbyteOrder.PutUint64(baseBytes[:], baseScid.ToUint64())\n\t\treturn baseConfBucket.Put(baseBytes[:], []byte{})\n\t}, func() {})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Now that the database state has been updated, we'll delete all of\n\t// the aliasToBase mappings for this SCID.\n\tfor alias, base := range m.aliasToBase {\n\t\tif base.ToUint64() == baseScid.ToUint64() {\n\t\t\tdelete(m.aliasToBase, alias)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// PutPeerAlias stores the peer's alias SCID once we learn of it in the\n// funding_locked message.",
      "length": 698,
      "tokens": 97,
      "embedding": []
    },
    {
      "slug": "func (m *Manager) PutPeerAlias(chanID lnwire.ChannelID,",
      "content": "func (m *Manager) PutPeerAlias(chanID lnwire.ChannelID,\n\talias lnwire.ShortChannelID) error {\n\n\tm.Lock()\n\tdefer m.Unlock()\n\n\terr := kvdb.Update(m.backend, func(tx kvdb.RwTx) error {\n\t\tbucket, err := tx.CreateTopLevelBucket(invoiceAliasBucket)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvar scratch [8]byte\n\t\tbyteOrder.PutUint64(scratch[:], alias.ToUint64())\n\t\treturn bucket.Put(chanID[:], scratch[:])\n\t}, func() {})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Now that the database state has been updated, we can update it in\n\t// our cache.\n\tm.peerAlias[chanID] = alias\n\n\treturn nil\n}\n\n// GetPeerAlias retrieves a peer's alias SCID by the channel's ChanID.",
      "length": 564,
      "tokens": 79,
      "embedding": []
    },
    {
      "slug": "func (m *Manager) GetPeerAlias(chanID lnwire.ChannelID) (lnwire.ShortChannelID,",
      "content": "func (m *Manager) GetPeerAlias(chanID lnwire.ChannelID) (lnwire.ShortChannelID,\n\terror) {\n\n\tm.RLock()\n\tdefer m.RUnlock()\n\n\talias, ok := m.peerAlias[chanID]\n\tif !ok || alias == hop.Source {\n\t\treturn lnwire.ShortChannelID{}, errNoPeerAlias\n\t}\n\n\treturn alias, nil\n}\n\n// RequestAlias returns a new ALIAS ShortChannelID to the caller by allocating\n// the next un-allocated ShortChannelID. The starting ShortChannelID is\n// 16000000:0:0 and the ending ShortChannelID is 16250000:16777215:65535. This\n// gives roughly 2^58 possible ALIAS ShortChannelIDs which ensures this space\n// won't get exhausted.",
      "length": 498,
      "tokens": 69,
      "embedding": []
    },
    {
      "slug": "func (m *Manager) RequestAlias() (lnwire.ShortChannelID, error) {",
      "content": "func (m *Manager) RequestAlias() (lnwire.ShortChannelID, error) {\n\tvar nextAlias lnwire.ShortChannelID\n\n\terr := kvdb.Update(m.backend, func(tx kvdb.RwTx) error {\n\t\tbucket, err := tx.CreateTopLevelBucket(aliasAllocBucket)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tlastBytes := bucket.Get(lastAliasKey)\n\t\tif lastBytes == nil {\n\t\t\t// If the key does not exist, then we can write the\n\t\t\t// StartingAlias to it.\n\t\t\tnextAlias = StartingAlias\n\n\t\t\tvar scratch [8]byte\n\t\t\tbyteOrder.PutUint64(scratch[:], nextAlias.ToUint64())\n\t\t\treturn bucket.Put(lastAliasKey, scratch[:])\n\t\t}\n\n\t\t// Otherwise the key does exist so we can convert the retrieved\n\t\t// lastAlias to a ShortChannelID and use it to assign the next\n\t\t// ShortChannelID. This next ShortChannelID will then be\n\t\t// persisted in the database.\n\t\tlastScid := lnwire.NewShortChanIDFromInt(\n\t\t\tbyteOrder.Uint64(lastBytes),\n\t\t)\n\t\tnextAlias = getNextScid(lastScid)\n\n\t\tvar scratch [8]byte\n\t\tbyteOrder.PutUint64(scratch[:], nextAlias.ToUint64())\n\t\treturn bucket.Put(lastAliasKey, scratch[:])\n\t}, func() {\n\t\tnextAlias = lnwire.ShortChannelID{}\n\t})\n\tif err != nil {\n\t\treturn nextAlias, err\n\t}\n\n\treturn nextAlias, nil\n}\n\n// ListAliases returns a carbon copy of baseToSet. This is used by the rpc\n// layer.",
      "length": 1131,
      "tokens": 147,
      "embedding": []
    },
    {
      "slug": "func (m *Manager) ListAliases() map[lnwire.ShortChannelID][]lnwire.ShortChannelID {",
      "content": "func (m *Manager) ListAliases() map[lnwire.ShortChannelID][]lnwire.ShortChannelID {\n\tm.RLock()\n\tdefer m.RUnlock()\n\n\tbaseCopy := make(map[lnwire.ShortChannelID][]lnwire.ShortChannelID)\n\n\tfor k, v := range m.baseToSet {\n\t\tsetCopy := make([]lnwire.ShortChannelID, len(v))\n\t\tcopy(setCopy, v)\n\t\tbaseCopy[k] = setCopy\n\t}\n\n\treturn baseCopy\n}\n\n// getNextScid is a utility function that returns the next SCID for a given\n// alias SCID. The BlockHeight ranges from [16000000, 16250000], the TxIndex\n// ranges from [1, 16777215], and the TxPosition ranges from [1, 65535].",
      "length": 461,
      "tokens": 63,
      "embedding": []
    },
    {
      "slug": "func getNextScid(last lnwire.ShortChannelID) lnwire.ShortChannelID {",
      "content": "func getNextScid(last lnwire.ShortChannelID) lnwire.ShortChannelID {\n\tvar (\n\t\tnext            lnwire.ShortChannelID\n\t\tincrementIdx    bool\n\t\tincrementHeight bool\n\t)\n\n\t// If the TxPosition is 65535, then it goes to 0 and we need to\n\t// increment the TxIndex.\n\tif last.TxPosition == 65535 {\n\t\tincrementIdx = true\n\t}\n\n\t// If the TxIndex is 16777215 and we need to increment it, then it goes\n\t// to 0 and we need to increment the BlockHeight.\n\tif last.TxIndex == 16777215 && incrementIdx {\n\t\tincrementIdx = false\n\t\tincrementHeight = true\n\t}\n\n\tswitch {\n\t// If we increment the TxIndex, then TxPosition goes to 0.\n\tcase incrementIdx:\n\t\tnext.BlockHeight = last.BlockHeight\n\t\tnext.TxIndex = last.TxIndex + 1\n\t\tnext.TxPosition = 0\n\n\t// If we increment the BlockHeight, then the Tx fields go to 0.\n\tcase incrementHeight:\n\t\tnext.BlockHeight = last.BlockHeight + 1\n\t\tnext.TxIndex = 0\n\t\tnext.TxPosition = 0\n\n\t// Otherwise, we only need to increment the TxPosition.\n\tdefault:\n\t\tnext.BlockHeight = last.BlockHeight\n\t\tnext.TxIndex = last.TxIndex\n\t\tnext.TxPosition = last.TxPosition + 1\n\t}\n\n\treturn next\n}\n\n// IsAlias returns true if the passed SCID is an alias. The function determines\n// this by looking at the BlockHeight. If the BlockHeight is greater than\n// startingBlockHeight and less than endBlockHeight, then it is an alias\n// assigned by RequestAlias. These bounds only apply to aliases we generate.\n// Our peers are free to use any range they choose.",
      "length": 1330,
      "tokens": 214,
      "embedding": []
    },
    {
      "slug": "func IsAlias(scid lnwire.ShortChannelID) bool {",
      "content": "func IsAlias(scid lnwire.ShortChannelID) bool {\n\treturn scid.BlockHeight >= uint32(startingBlockHeight) &&\n\t\tscid.BlockHeight < uint32(endBlockHeight)\n}\n",
      "length": 102,
      "tokens": 9,
      "embedding": []
    }
  ]
}