{
  "filepath": "../implementations/go/lnd/pilot.go",
  "package": "lnd",
  "sections": [
    {
      "slug": "func validateAtplCfg(cfg *lncfg.AutoPilot) ([]*autopilot.WeightedHeuristic,",
      "content": "func validateAtplCfg(cfg *lncfg.AutoPilot) ([]*autopilot.WeightedHeuristic,\n\terror) {\n\n\tvar (\n\t\theuristicsStr string\n\t\tsum           float64\n\t\theuristics    []*autopilot.WeightedHeuristic\n\t)\n\n\t// Create a help text that we can return in case the config is not\n\t// correct.\n\tfor _, a := range autopilot.AvailableHeuristics {\n\t\theuristicsStr += fmt.Sprintf(\" '%v' \", a.Name())\n\t}\n\tavailStr := fmt.Sprintf(\"Available heuristics are: [%v]\", heuristicsStr)\n\n\t// We'll go through the config and make sure all the heuristics exists,\n\t// and that the sum of their weights is 1.0.\n\tfor name, weight := range cfg.Heuristic {\n\t\ta, ok := autopilot.AvailableHeuristics[name]\n\t\tif !ok {\n\t\t\t// No heuristic matching this config option was found.\n\t\t\treturn nil, fmt.Errorf(\"heuristic %v not available. %v\",\n\t\t\t\tname, availStr)\n\t\t}\n\n\t\t// If this heuristic was among the registered ones, we add it\n\t\t// to the list we'll give to the agent, and keep track of the\n\t\t// sum of weights.\n\t\theuristics = append(\n\t\t\theuristics,\n\t\t\t&autopilot.WeightedHeuristic{\n\t\t\t\tWeight:              weight,\n\t\t\t\tAttachmentHeuristic: a,\n\t\t\t},\n\t\t)\n\t\tsum += weight\n\t}\n\n\t// Check found heuristics. We must have at least one to operate.\n\tif len(heuristics) == 0 {\n\t\treturn nil, fmt.Errorf(\"no active heuristics: %v\", availStr)\n\t}\n\n\tif sum != 1.0 {\n\t\treturn nil, fmt.Errorf(\"heuristic weights must sum to 1.0\")\n\t}\n\treturn heuristics, nil\n}\n\n// chanController is an implementation of the autopilot.ChannelController\n// interface that's backed by a running lnd instance.",
      "length": 1397,
      "tokens": 210,
      "embedding": []
    },
    {
      "slug": "type chanController struct {",
      "content": "type chanController struct {\n\tserver        *server\n\tprivate       bool\n\tminConfs      int32\n\tconfTarget    uint32\n\tchanMinHtlcIn lnwire.MilliSatoshi\n\tnetParams     chainreg.BitcoinNetParams\n}\n\n// OpenChannel opens a channel to a target peer, with a capacity of the\n// specified amount. This function should un-block immediately after the\n// funding transaction that marks the channel open has been broadcast.",
      "length": 370,
      "tokens": 48,
      "embedding": []
    },
    {
      "slug": "func (c *chanController) OpenChannel(target *btcec.PublicKey,",
      "content": "func (c *chanController) OpenChannel(target *btcec.PublicKey,\n\tamt btcutil.Amount) error {\n\n\t// With the connection established, we'll now establish our connection\n\t// to the target peer, waiting for the first update before we exit.\n\tfeePerKw, err := c.server.cc.FeeEstimator.EstimateFeePerKW(\n\t\tc.confTarget,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Construct the open channel request and send it to the server to begin\n\t// the funding workflow.\n\treq := &funding.InitFundingMsg{\n\t\tTargetPubkey:     target,\n\t\tChainHash:        *c.netParams.GenesisHash,\n\t\tSubtractFees:     true,\n\t\tLocalFundingAmt:  amt,\n\t\tPushAmt:          0,\n\t\tMinHtlcIn:        c.chanMinHtlcIn,\n\t\tFundingFeePerKw:  feePerKw,\n\t\tPrivate:          c.private,\n\t\tRemoteCsvDelay:   0,\n\t\tMinConfs:         c.minConfs,\n\t\tMaxValueInFlight: 0,\n\t}\n\n\tupdateStream, errChan := c.server.OpenChannel(req)\n\tselect {\n\tcase err := <-errChan:\n\t\treturn err\n\tcase <-updateStream:\n\t\treturn nil\n\tcase <-c.server.quit:\n\t\treturn nil\n\t}\n}\n",
      "length": 884,
      "tokens": 107,
      "embedding": []
    },
    {
      "slug": "func (c *chanController) CloseChannel(chanPoint *wire.OutPoint) error {",
      "content": "func (c *chanController) CloseChannel(chanPoint *wire.OutPoint) error {\n\treturn nil\n}\n\n// A compile time assertion to ensure chanController meets the\n// autopilot.ChannelController interface.\nvar _ autopilot.ChannelController = (*chanController)(nil)\n\n// initAutoPilot initializes a new autopilot.ManagerCfg to manage an autopilot.\n// Agent instance based on the passed configuration structs. The agent and all\n// interfaces needed to drive it won't be launched before the Manager's\n// StartAgent method is called.",
      "length": 432,
      "tokens": 61,
      "embedding": []
    },
    {
      "slug": "func initAutoPilot(svr *server, cfg *lncfg.AutoPilot,",
      "content": "func initAutoPilot(svr *server, cfg *lncfg.AutoPilot,\n\tminHTLCIn lnwire.MilliSatoshi, netParams chainreg.BitcoinNetParams) (\n\t*autopilot.ManagerCfg, error) {\n\n\tatplLog.Infof(\"Instantiating autopilot with active=%v, \"+\n\t\t\"max_channels=%d, allocation=%f, min_chan_size=%d, \"+\n\t\t\"max_chan_size=%d, private=%t, min_confs=%d, conf_target=%d\",\n\t\tcfg.Active, cfg.MaxChannels, cfg.Allocation, cfg.MinChannelSize,\n\t\tcfg.MaxChannelSize, cfg.Private, cfg.MinConfs, cfg.ConfTarget)\n\n\t// Set up the constraints the autopilot heuristics must adhere to.\n\tatplConstraints := autopilot.NewConstraints(\n\t\tbtcutil.Amount(cfg.MinChannelSize),\n\t\tbtcutil.Amount(cfg.MaxChannelSize),\n\t\tuint16(cfg.MaxChannels),\n\t\t10,\n\t\tcfg.Allocation,\n\t)\n\theuristics, err := validateAtplCfg(cfg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tweightedAttachment, err := autopilot.NewWeightedCombAttachment(\n\t\theuristics...,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// With the heuristic itself created, we can now populate the remainder\n\t// of the items that the autopilot agent needs to perform its duties.\n\tself := svr.identityECDH.PubKey()\n\tpilotCfg := autopilot.Config{\n\t\tSelf:      self,\n\t\tHeuristic: weightedAttachment,\n\t\tChanController: &chanController{\n\t\t\tserver:        svr,\n\t\t\tprivate:       cfg.Private,\n\t\t\tminConfs:      cfg.MinConfs,\n\t\t\tconfTarget:    cfg.ConfTarget,\n\t\t\tchanMinHtlcIn: minHTLCIn,\n\t\t\tnetParams:     netParams,\n\t\t},\n\t\tWalletBalance: func() (btcutil.Amount, error) {\n\t\t\treturn svr.cc.Wallet.ConfirmedBalance(\n\t\t\t\tcfg.MinConfs, lnwallet.DefaultAccountName,\n\t\t\t)\n\t\t},\n\t\tGraph:       autopilot.ChannelGraphFromDatabase(svr.graphDB),\n\t\tConstraints: atplConstraints,\n\t\tConnectToPeer: func(target *btcec.PublicKey, addrs []net.Addr) (bool, error) {\n\t\t\t// First, we'll check if we're already connected to the\n\t\t\t// target peer. If we are, we can exit early. Otherwise,\n\t\t\t// we'll need to establish a connection.\n\t\t\tif _, err := svr.FindPeer(target); err == nil {\n\t\t\t\treturn true, nil\n\t\t\t}\n\n\t\t\t// We can't establish a channel if no addresses were\n\t\t\t// provided for the peer.\n\t\t\tif len(addrs) == 0 {\n\t\t\t\treturn false, errors.New(\"no addresses specified\")\n\t\t\t}\n\n\t\t\tatplLog.Tracef(\"Attempting to connect to %x\",\n\t\t\t\ttarget.SerializeCompressed())\n\n\t\t\tlnAddr := &lnwire.NetAddress{\n\t\t\t\tIdentityKey: target,\n\t\t\t\tChainNet:    netParams.Net,\n\t\t\t}\n\n\t\t\t// We'll attempt to successively connect to each of the\n\t\t\t// advertised IP addresses until we've either exhausted\n\t\t\t// the advertised IP addresses, or have made a\n\t\t\t// connection.\n\t\t\tvar connected bool\n\t\t\tfor _, addr := range addrs {\n\t\t\t\tswitch addr.(type) {\n\t\t\t\tcase *net.TCPAddr, *tor.OnionAddr:\n\t\t\t\t\tlnAddr.Address = addr\n\t\t\t\tdefault:\n\t\t\t\t\treturn false, fmt.Errorf(\"unknown \"+\n\t\t\t\t\t\t\"address type %T\", addr)\n\t\t\t\t}\n\n\t\t\t\terr := svr.ConnectToPeer(\n\t\t\t\t\tlnAddr, false, svr.cfg.ConnectionTimeout,\n\t\t\t\t)\n\t\t\t\tif err != nil {\n\t\t\t\t\t// If we weren't able to connect to the\n\t\t\t\t\t// peer at this address, then we'll move\n\t\t\t\t\t// onto the next.\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tconnected = true\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t// If we weren't able to establish a connection at all,\n\t\t\t// then we'll error out.\n\t\t\tif !connected {\n\t\t\t\treturn false, errors.New(\"exhausted all \" +\n\t\t\t\t\t\"advertised addresses\")\n\t\t\t}\n\n\t\t\treturn false, nil\n\t\t},\n\t\tDisconnectPeer: svr.DisconnectPeer,\n\t}\n\n\t// Create and return the autopilot.ManagerCfg that administrates this\n\t// agent-pilot instance.\n\treturn &autopilot.ManagerCfg{\n\t\tSelf:     self,\n\t\tPilotCfg: &pilotCfg,\n\t\tChannelState: func() ([]autopilot.LocalChannel, error) {\n\t\t\t// We'll fetch the current state of open\n\t\t\t// channels from the database to use as initial\n\t\t\t// state for the auto-pilot agent.\n\t\t\tactiveChannels, err := svr.chanStateDB.FetchAllChannels()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tchanState := make([]autopilot.LocalChannel,\n\t\t\t\tlen(activeChannels))\n\t\t\tfor i, channel := range activeChannels {\n\t\t\t\tlocalCommit := channel.LocalCommitment\n\t\t\t\tbalance := localCommit.LocalBalance.ToSatoshis()\n\n\t\t\t\tchanState[i] = autopilot.LocalChannel{\n\t\t\t\t\tChanID:  channel.ShortChanID(),\n\t\t\t\t\tBalance: balance,\n\t\t\t\t\tNode: autopilot.NewNodeID(\n\t\t\t\t\t\tchannel.IdentityPub,\n\t\t\t\t\t),\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn chanState, nil\n\t\t},\n\t\tChannelInfo: func(chanPoint wire.OutPoint) (\n\t\t\t*autopilot.LocalChannel, error) {\n\n\t\t\tchannel, err := svr.chanStateDB.FetchChannel(nil, chanPoint)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tlocalCommit := channel.LocalCommitment\n\t\t\treturn &autopilot.LocalChannel{\n\t\t\t\tChanID:  channel.ShortChanID(),\n\t\t\t\tBalance: localCommit.LocalBalance.ToSatoshis(),\n\t\t\t\tNode:    autopilot.NewNodeID(channel.IdentityPub),\n\t\t\t}, nil\n\t\t},\n\t\tSubscribeTransactions: svr.cc.Wallet.SubscribeTransactions,\n\t\tSubscribeTopology:     svr.chanRouter.SubscribeTopology,\n\t}, nil\n}\n",
      "length": 4508,
      "tokens": 499,
      "embedding": []
    }
  ]
}