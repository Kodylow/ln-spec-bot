{
  "filepath": "../implementations/go/lnd/cert/selfsigned.go",
  "package": "cert",
  "sections": [
    {
      "slug": "func ipAddresses(tlsExtraIPs []string, tlsDisableAutofill bool) ([]net.IP,",
      "content": "func ipAddresses(tlsExtraIPs []string, tlsDisableAutofill bool) ([]net.IP,\n\terror) {\n\n\t// Collect the host's IP addresses, including loopback, in a slice.\n\tipAddresses := []net.IP{net.ParseIP(\"127.0.0.1\"), net.ParseIP(\"::1\")}\n\n\t// addIP appends an IP address only if it isn't already in the slice.\n\taddIP := func(ipAddr net.IP) {\n\t\tfor _, ip := range ipAddresses {\n\t\t\tif ip.Equal(ipAddr) {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tipAddresses = append(ipAddresses, ipAddr)\n\t}\n\n\t// To protect their privacy, some users might not want to have all\n\t// their network addresses include in the certificate as this could\n\t// leak sensitive information.\n\tif !tlsDisableAutofill {\n\t\t// Add all the interface IPs that aren't already in the slice.\n\t\taddrs, err := net.InterfaceAddrs()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfor _, a := range addrs {\n\t\t\tipAddr, _, err := net.ParseCIDR(a.String())\n\t\t\tif err == nil {\n\t\t\t\taddIP(ipAddr)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Add extra IPs to the slice.\n\tfor _, ip := range tlsExtraIPs {\n\t\tipAddr := net.ParseIP(ip)\n\t\tif ipAddr != nil {\n\t\t\taddIP(ipAddr)\n\t\t}\n\t}\n\n\treturn ipAddresses, nil\n}\n\n// dnsNames returns the host and DNS names to use when creating the TLS\n// certificate.",
      "length": 1057,
      "tokens": 176,
      "embedding": []
    },
    {
      "slug": "func dnsNames(tlsExtraDomains []string, tlsDisableAutofill bool) (string,",
      "content": "func dnsNames(tlsExtraDomains []string, tlsDisableAutofill bool) (string,\n\t[]string) {\n\n\t// Collect the host's names into a slice.\n\thost, err := os.Hostname()\n\n\t// To further protect their privacy, some users might not want\n\t// to have their hostname include in the certificate as this could\n\t// leak sensitive information.\n\tif err != nil || tlsDisableAutofill {\n\t\t// Nothing much we can do here, other than falling back to\n\t\t// localhost as fallback. A hostname can still be provided with\n\t\t// the tlsExtraDomain parameter if the problem persists on a\n\t\t// system.\n\t\thost = \"localhost\"\n\t}\n\n\tdnsNames := []string{host}\n\tif host != \"localhost\" {\n\t\tdnsNames = append(dnsNames, \"localhost\")\n\t}\n\tdnsNames = append(dnsNames, tlsExtraDomains...)\n\n\t// Because we aren't including the hostname in the certificate when\n\t// tlsDisableAutofill is set, we will use the first extra domain\n\t// specified by the user, if it's set, as the Common Name.\n\tif tlsDisableAutofill && len(tlsExtraDomains) > 0 {\n\t\thost = tlsExtraDomains[0]\n\t}\n\n\t// Also add fake hostnames for unix sockets, otherwise hostname\n\t// verification will fail in the client.\n\tdnsNames = append(dnsNames, \"unix\", \"unixpacket\")\n\n\t// Also add hostnames for 'bufconn' which is the hostname used for the\n\t// in-memory connections used on mobile.\n\tdnsNames = append(dnsNames, \"bufconn\")\n\n\treturn host, dnsNames\n}\n\n// IsOutdated returns whether the given certificate is outdated w.r.t. the IPs\n// and domains given. The certificate is considered up to date if it was\n// created with _exactly_ the IPs and domains given.",
      "length": 1449,
      "tokens": 233,
      "embedding": []
    },
    {
      "slug": "func IsOutdated(cert *x509.Certificate, tlsExtraIPs,",
      "content": "func IsOutdated(cert *x509.Certificate, tlsExtraIPs,\n\ttlsExtraDomains []string, tlsDisableAutofill bool) (bool, error) {\n\n\t// Parse the slice of IP strings.\n\tips, err := ipAddresses(tlsExtraIPs, tlsDisableAutofill)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\t// To not consider the certificate outdated if it has duplicate IPs or\n\t// if only the order has changed, we create two maps from the slice of\n\t// IPs to compare.\n\tips1 := make(map[string]net.IP)\n\tfor _, ip := range ips {\n\t\tips1[ip.String()] = ip\n\t}\n\n\tips2 := make(map[string]net.IP)\n\tfor _, ip := range cert.IPAddresses {\n\t\tips2[ip.String()] = ip\n\t}\n\n\t// If the certificate has a different number of IP addresses, it is\n\t// definitely out of date.\n\tif len(ips1) != len(ips2) {\n\t\treturn true, nil\n\t}\n\n\t// Go through each IP address, and check that they are equal. We expect\n\t// both the string representation and the exact IP to match.\n\tfor s, ip1 := range ips1 {\n\t\t// Assert the IP string is found in both sets.\n\t\tip2, ok := ips2[s]\n\t\tif !ok {\n\t\t\treturn true, nil\n\t\t}\n\n\t\t// And that the IPs are considered equal.\n\t\tif !ip1.Equal(ip2) {\n\t\t\treturn true, nil\n\t\t}\n\t}\n\n\t// Get the full list of DNS names to use.\n\t_, dnsNames := dnsNames(tlsExtraDomains, tlsDisableAutofill)\n\n\t// We do the same kind of deduplication for the DNS names.\n\tdns1 := make(map[string]struct{})\n\tfor _, n := range cert.DNSNames {\n\t\tdns1[n] = struct{}{}\n\t}\n\n\tdns2 := make(map[string]struct{})\n\tfor _, n := range dnsNames {\n\t\tdns2[n] = struct{}{}\n\t}\n\n\t// If the number of domains are different, it is out of date.\n\tif len(dns1) != len(dns2) {\n\t\treturn true, nil\n\t}\n\n\t// Similarly, check that each DNS name matches what is found in the\n\t// certificate.\n\tfor k := range dns1 {\n\t\tif _, ok := dns2[k]; !ok {\n\t\t\treturn true, nil\n\t\t}\n\t}\n\n\t// Certificate was up-to-date.\n\treturn false, nil\n}\n\n// GenCertPair generates a key/cert pair and returns the pair in byte form.\n//\n// The auto-generated certificates should *not* be used in production for\n// public access as they're self-signed and don't necessarily contain all of the\n// desired hostnames for the service. For production/public use, consider a\n// real PKI.\n//\n// This function is adapted from https://github.com/btcsuite/btcd and\n// https://github.com/btcsuite/btcd/btcutil",
      "length": 2117,
      "tokens": 365,
      "embedding": []
    },
    {
      "slug": "func GenCertPair(org string, tlsExtraIPs, tlsExtraDomains []string,",
      "content": "func GenCertPair(org string, tlsExtraIPs, tlsExtraDomains []string,\n\ttlsDisableAutofill bool, certValidity time.Duration) (\n\t[]byte, []byte, error) {\n\n\tnow := time.Now()\n\tvalidUntil := now.Add(certValidity)\n\n\t// Check that the certificate validity isn't past the ASN.1 end of time.\n\tif validUntil.After(endOfTime) {\n\t\tvalidUntil = endOfTime\n\t}\n\n\t// Generate a serial number that's below the serialNumberLimit.\n\tserialNumber, err := rand.Int(rand.Reader, serialNumberLimit)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to generate serial \"+\n\t\t\t\"number: %s\", err)\n\t}\n\n\t// Get all DNS names and IP addresses to use when creating the\n\t// certificate.\n\thost, dnsNames := dnsNames(tlsExtraDomains, tlsDisableAutofill)\n\tipAddresses, err := ipAddresses(tlsExtraIPs, tlsDisableAutofill)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// Generate a private key for the certificate.\n\tpriv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// Construct the certificate template.\n\ttemplate := x509.Certificate{\n\t\tSerialNumber: serialNumber,\n\t\tSubject: pkix.Name{\n\t\t\tOrganization: []string{org},\n\t\t\tCommonName:   host,\n\t\t},\n\t\tNotBefore: now.Add(-time.Hour * 24),\n\t\tNotAfter:  validUntil,\n\n\t\tKeyUsage: x509.KeyUsageKeyEncipherment |\n\t\t\tx509.KeyUsageDigitalSignature |\n\t\t\tx509.KeyUsageCertSign,\n\t\tExtKeyUsage: []x509.ExtKeyUsage{\n\t\t\tx509.ExtKeyUsageServerAuth,\n\t\t},\n\t\tIsCA:                  true, // so can sign self.\n\t\tBasicConstraintsValid: true,\n\n\t\tDNSNames:    dnsNames,\n\t\tIPAddresses: ipAddresses,\n\t}\n\n\tderBytes, err := x509.CreateCertificate(\n\t\trand.Reader, &template,\n\t\t&template, &priv.PublicKey, priv,\n\t)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to create certificate: %v\",\n\t\t\terr)\n\t}\n\n\tcertBuf := &bytes.Buffer{}\n\terr = pem.Encode(\n\t\tcertBuf, &pem.Block{Type: \"CERTIFICATE\", Bytes: derBytes},\n\t)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to encode certificate: %v\",\n\t\t\terr)\n\t}\n\n\tkeybytes, err := x509.MarshalECPrivateKey(priv)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"unable to encode privkey: %v\",\n\t\t\terr)\n\t}\n\tkeyBuf := &bytes.Buffer{}\n\terr = pem.Encode(\n\t\tkeyBuf, &pem.Block{Type: \"EC PRIVATE KEY\", Bytes: keybytes},\n\t)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to encode private key: %v\",\n\t\t\terr)\n\t}\n\n\treturn certBuf.Bytes(), keyBuf.Bytes(), nil\n}\n\n// WriteCertPair writes certificate and key data to disk if a path is provided.",
      "length": 2273,
      "tokens": 291,
      "embedding": []
    },
    {
      "slug": "func WriteCertPair(certFile, keyFile string, certBytes, keyBytes []byte) error {",
      "content": "func WriteCertPair(certFile, keyFile string, certBytes, keyBytes []byte) error {\n\t// Write cert and key files.\n\tif certFile != \"\" {\n\t\terr := ioutil.WriteFile(certFile, certBytes, 0644)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif keyFile != \"\" {\n\t\terr := ioutil.WriteFile(keyFile, keyBytes, 0600)\n\t\tif err != nil {\n\t\t\tos.Remove(certFile)\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n",
      "length": 274,
      "tokens": 48,
      "embedding": []
    }
  ]
}