{
  "filepath": "../implementations/go/lnd/cert/selfsigned_test.go",
  "package": "cert_test",
  "sections": [
    {
      "slug": "func TestIsOutdatedCert(t *testing.T) {",
      "content": "func TestIsOutdatedCert(t *testing.T) {\n\ttempDir := t.TempDir()\n\n\tcertPath := tempDir + \"/tls.cert\"\n\tkeyPath := tempDir + \"/tls.key\"\n\n\t// Generate TLS files with two extra IPs and domains.\n\tcertBytes, keyBytes, err := cert.GenCertPair(\n\t\t\"lnd autogenerated cert\", extraIPs[:2], extraDomains[:2],\n\t\tfalse, testTLSCertDuration,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = cert.WriteCertPair(certPath, keyPath, certBytes, keyBytes)\n\trequire.NoError(t, err)\n\n\t// We'll attempt to check up-to-date status for all variants of 1-3\n\t// number of IPs and domains.\n\tfor numIPs := 1; numIPs <= len(extraIPs); numIPs++ {\n\t\tfor numDomains := 1; numDomains <= len(extraDomains); numDomains++ {\n\t\t\tcertBytes, err := ioutil.ReadFile(certPath)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tkeyBytes, err := ioutil.ReadFile(keyPath)\n\t\t\trequire.NoError(t, err)\n\n\t\t\t_, parsedCert, err := cert.LoadCertFromBytes(\n\t\t\t\tcertBytes, keyBytes,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\t// Using the test case's number of IPs and domains, get\n\t\t\t// the outdated status of the certificate we created\n\t\t\t// above.\n\t\t\toutdated, err := cert.IsOutdated(\n\t\t\t\tparsedCert, extraIPs[:numIPs],\n\t\t\t\textraDomains[:numDomains], false,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\t// We expect it to be considered outdated if the IPs or\n\t\t\t// domains don't match exactly what we created.\n\t\t\texpected := numIPs != 2 || numDomains != 2\n\t\t\tif outdated != expected {\n\t\t\t\tt.Fatalf(\"expected certificate to be \"+\n\t\t\t\t\t\"outdated=%v, got=%v\", expected,\n\t\t\t\t\toutdated)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// TestIsOutdatedPermutation tests that the order of listed IPs or DNS names,\n// nor dulicates in the lists, matter for whether we consider the certificate\n// outdated.",
      "length": 1602,
      "tokens": 226,
      "embedding": []
    },
    {
      "slug": "func TestIsOutdatedPermutation(t *testing.T) {",
      "content": "func TestIsOutdatedPermutation(t *testing.T) {\n\ttempDir := t.TempDir()\n\n\tcertPath := tempDir + \"/tls.cert\"\n\tkeyPath := tempDir + \"/tls.key\"\n\n\t// Generate TLS files from the IPs and domains.\n\tcertBytes, keyBytes, err := cert.GenCertPair(\n\t\t\"lnd autogenerated cert\", extraIPs[:], extraDomains[:],\n\t\tfalse, testTLSCertDuration,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = cert.WriteCertPair(certPath, keyPath, certBytes, keyBytes)\n\trequire.NoError(t, err)\n\n\tcertBytes, err = ioutil.ReadFile(certPath)\n\trequire.NoError(t, err)\n\n\tkeyBytes, err = ioutil.ReadFile(keyPath)\n\trequire.NoError(t, err)\n\n\t_, parsedCert, err := cert.LoadCertFromBytes(certBytes, keyBytes)\n\trequire.NoError(t, err)\n\n\t// If we have duplicate IPs or DNS names listed, that shouldn't matter.\n\tdupIPs := make([]string, len(extraIPs)*2)\n\tfor i := range dupIPs {\n\t\tdupIPs[i] = extraIPs[i/2]\n\t}\n\n\tdupDNS := make([]string, len(extraDomains)*2)\n\tfor i := range dupDNS {\n\t\tdupDNS[i] = extraDomains[i/2]\n\t}\n\n\toutdated, err := cert.IsOutdated(parsedCert, dupIPs, dupDNS, false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif outdated {\n\t\tt.Fatalf(\"did not expect duplicate IPs or DNS names be \" +\n\t\t\t\"considered outdated\")\n\t}\n\n\t// Similarly, the order of the lists shouldn't matter.\n\trevIPs := make([]string, len(extraIPs))\n\tfor i := range revIPs {\n\t\trevIPs[i] = extraIPs[len(extraIPs)-1-i]\n\t}\n\n\trevDNS := make([]string, len(extraDomains))\n\tfor i := range revDNS {\n\t\trevDNS[i] = extraDomains[len(extraDomains)-1-i]\n\t}\n\n\toutdated, err = cert.IsOutdated(parsedCert, revIPs, revDNS, false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif outdated {\n\t\tt.Fatalf(\"did not expect reversed IPs or DNS names be \" +\n\t\t\t\"considered outdated\")\n\t}\n}\n\n// TestTLSDisableAutofill checks that setting the --tlsdisableautofill flag\n// does not add interface ip addresses or hostnames to the cert.",
      "length": 1705,
      "tokens": 231,
      "embedding": []
    },
    {
      "slug": "func TestTLSDisableAutofill(t *testing.T) {",
      "content": "func TestTLSDisableAutofill(t *testing.T) {\n\ttempDir := t.TempDir()\n\n\tcertPath := tempDir + \"/tls.cert\"\n\tkeyPath := tempDir + \"/tls.key\"\n\n\t// Generate TLS files with two extra IPs and domains and no interface IPs.\n\tcertBytes, keyBytes, err := cert.GenCertPair(\n\t\t\"lnd autogenerated cert\", extraIPs[:2], extraDomains[:2],\n\t\ttrue, testTLSCertDuration,\n\t)\n\trequire.NoError(\n\t\tt, err,\n\t\t\"unable to generate tls certificate pair\",\n\t)\n\terr = cert.WriteCertPair(certPath, keyPath, certBytes, keyBytes)\n\trequire.NoError(t, err)\n\n\t// Read certs from disk.\n\tcertBytes, err = ioutil.ReadFile(certPath)\n\trequire.NoError(t, err)\n\n\tkeyBytes, err = ioutil.ReadFile(keyPath)\n\trequire.NoError(t, err)\n\n\t// Load the certificate.\n\t_, parsedCert, err := cert.LoadCertFromBytes(\n\t\tcertBytes, keyBytes,\n\t)\n\trequire.NoError(\n\t\tt, err,\n\t\t\"unable to load tls certificate pair\",\n\t)\n\n\t// Check if the TLS cert is outdated while still preventing\n\t// interface IPs from being used. Should not be outdated.\n\tshouldNotBeOutdated, err := cert.IsOutdated(\n\t\tparsedCert, extraIPs[:2],\n\t\textraDomains[:2], true,\n\t)\n\trequire.NoError(t, err)\n\n\trequire.Equal(\n\t\tt, false, shouldNotBeOutdated,\n\t\t\"TLS Certificate was marked as outdated when it should not be\",\n\t)\n\n\t// Check if the TLS cert is outdated while allowing for\n\t// interface IPs to be used. Should report as outdated.\n\tshouldBeOutdated, err := cert.IsOutdated(\n\t\tparsedCert, extraIPs[:2],\n\t\textraDomains[:2], false,\n\t)\n\trequire.NoError(t, err)\n\n\trequire.Equal(\n\t\tt, true, shouldBeOutdated,\n\t\t\"TLS Certificate was not marked as outdated when it should be\",\n\t)\n}\n\n// TestTLSConfig tests to ensure we can generate a TLS Config from\n// a tls cert and tls key.",
      "length": 1571,
      "tokens": 213,
      "embedding": []
    },
    {
      "slug": "func TestTLSConfig(t *testing.T) {",
      "content": "func TestTLSConfig(t *testing.T) {\n\ttempDir := t.TempDir()\n\tcertPath := filepath.Join(tempDir, \"/tls.cert\")\n\tkeyPath := filepath.Join(tempDir, \"/tls.key\")\n\n\t// Generate TLS files with an extra IP and domain.\n\tcertBytes, keyBytes, err := cert.GenCertPair(\n\t\t\"lnd autogenerated cert\", []string{extraIPs[0]},\n\t\t[]string{extraDomains[0]}, false, testTLSCertDuration,\n\t)\n\trequire.NoError(t, err)\n\n\terr = cert.WriteCertPair(certPath, keyPath, certBytes, keyBytes)\n\trequire.NoError(t, err)\n\n\tcertBytes, err = ioutil.ReadFile(certPath)\n\trequire.NoError(t, err)\n\n\tkeyBytes, err = ioutil.ReadFile(keyPath)\n\trequire.NoError(t, err)\n\n\t// Load the certificate.\n\tcertData, parsedCert, err := cert.LoadCertFromBytes(\n\t\tcertBytes, keyBytes,\n\t)\n\trequire.NoError(t, err)\n\n\t// Check to make sure the IP and domain are in the cert.\n\tvar foundIp bool\n\trequire.Contains(t, parsedCert.DNSNames, extraDomains[0])\n\tfor _, ip := range parsedCert.IPAddresses {\n\t\tif ip.String() == extraIPs[0] {\n\t\t\tfoundIp = true\n\t\t\tbreak\n\t\t}\n\t}\n\trequire.Equal(t, true, foundIp, \"Did not find required ip inside of \"+\n\t\t\"TLS Certificate.\")\n\n\t// Create TLS Config.\n\ttlsCfg := cert.TLSConfFromCert(certData)\n\n\trequire.Equal(t, 1, len(tlsCfg.Certificates))\n}\n",
      "length": 1134,
      "tokens": 131,
      "embedding": []
    }
  ]
}