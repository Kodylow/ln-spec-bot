{
  "filepath": "../implementations/go/lnd/lnwire/channel_id_test.go",
  "package": "lnwire",
  "sections": [
    {
      "slug": "func TestChannelIDOutPointConversion(t *testing.T) {",
      "content": "func TestChannelIDOutPointConversion(t *testing.T) {\n\tt.Parallel()\n\n\ttestChanPoint := *outpoint1\n\n\t// For a given OutPoint, we'll run through all the possible output\n\t// index values, mutating our test outpoint to match that output index.\n\tvar prevChanID ChannelID\n\tfor i := uint32(0); i < MaxFundingTxOutputs; i++ {\n\t\ttestChanPoint.Index = i\n\n\t\t// With the output index mutated, we'll convert it into a\n\t\t// ChannelID.\n\t\tcid := NewChanIDFromOutPoint(&testChanPoint)\n\n\t\t// Once the channel point has been converted to a channelID, it\n\t\t// should recognize its original outpoint.\n\t\tif !cid.IsChanPoint(&testChanPoint) {\n\t\t\tt.Fatalf(\"channelID not recognized as seed channel \"+\n\t\t\t\t\"point: cid=%v, op=%v\", cid, testChanPoint)\n\t\t}\n\n\t\t// We also ensure that the channel ID itself have changed\n\t\t// between iterations. This case is meant to catch an issue\n\t\t// where the transformation function itself is a no-op.\n\t\tif prevChanID == cid {\n\t\t\tt.Fatalf(\"#%v: channelID not modified: old=%v, new=%v\",\n\t\t\t\ti, prevChanID, cid)\n\t\t}\n\n\t\tprevChanID = cid\n\t}\n}\n\n// TestGenPossibleOutPoints ensures that the GenPossibleOutPoints generates a\n// valid set of outpoints for a channelID. A set of outpoints is valid iff, the\n// root outpoint (the outpoint that generated the ChannelID) is included in the\n// returned set of outpoints.",
      "length": 1225,
      "tokens": 186,
      "embedding": []
    },
    {
      "slug": "func TestGenPossibleOutPoints(t *testing.T) {",
      "content": "func TestGenPossibleOutPoints(t *testing.T) {\n\tt.Parallel()\n\n\t// We'll first convert out test outpoint into a ChannelID.\n\ttestChanPoint := *outpoint1\n\ttestChanPoint.Index = 24\n\tchanID := NewChanIDFromOutPoint(&testChanPoint)\n\n\t// With the chan ID created, we'll generate all possible root outpoints\n\t// given this channel ID.\n\tpossibleOutPoints := chanID.GenPossibleOutPoints()\n\n\t// If we run through the generated possible outpoints, the original\n\t// root outpoint MUST be found in this generated set.\n\tvar opFound bool\n\tfor _, op := range possibleOutPoints {\n\t\tif op == testChanPoint {\n\t\t\topFound = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// If we weren't able to locate the original outpoint in the set of\n\t// possible outpoints, then we'll fail the test.\n\tif !opFound {\n\t\tt.Fatalf(\"possible outpoints did not contain the root outpoint\")\n\t}\n}\n",
      "length": 756,
      "tokens": 117,
      "embedding": []
    }
  ]
}