{
  "filepath": "../implementations/go/lnd/lnwire/accept_channel.go",
  "package": "lnwire",
  "sections": [
    {
      "slug": "type AcceptChannel struct {",
      "content": "type AcceptChannel struct {\n\t// PendingChannelID serves to uniquely identify the future channel\n\t// created by the initiated single funder workflow.\n\tPendingChannelID [32]byte\n\n\t// DustLimit is the specific dust limit the sender of this message\n\t// would like enforced on their version of the commitment transaction.\n\t// Any output below this value will be \"trimmed\" from the commitment\n\t// transaction, with the amount of the HTLC going to dust.\n\tDustLimit btcutil.Amount\n\n\t// MaxValueInFlight represents the maximum amount of coins that can be\n\t// pending within the channel at any given time. If the amount of funds\n\t// in limbo exceeds this amount, then the channel will be failed.\n\tMaxValueInFlight MilliSatoshi\n\n\t// ChannelReserve is the amount of BTC that the receiving party MUST\n\t// maintain a balance above at all times. This is a safety mechanism to\n\t// ensure that both sides always have skin in the game during the\n\t// channel's lifetime.\n\tChannelReserve btcutil.Amount\n\n\t// HtlcMinimum is the smallest HTLC that the sender of this message\n\t// will accept.\n\tHtlcMinimum MilliSatoshi\n\n\t// MinAcceptDepth is the minimum depth that the initiator of the\n\t// channel should wait before considering the channel open.\n\tMinAcceptDepth uint32\n\n\t// CsvDelay is the number of blocks to use for the relative time lock\n\t// in the pay-to-self output of both commitment transactions.\n\tCsvDelay uint16\n\n\t// MaxAcceptedHTLCs is the total number of incoming HTLC's that the\n\t// sender of this channel will accept.\n\t//\n\t// TODO(roasbeef): acks the initiator's, same with max in flight?\n\tMaxAcceptedHTLCs uint16\n\n\t// FundingKey is the key that should be used on behalf of the sender\n\t// within the 2-of-2 multi-sig output that it contained within the\n\t// funding transaction.\n\tFundingKey *btcec.PublicKey\n\n\t// RevocationPoint is the base revocation point for the sending party.\n\t// Any commitment transaction belonging to the receiver of this message\n\t// should use this key and their per-commitment point to derive the\n\t// revocation key for the commitment transaction.\n\tRevocationPoint *btcec.PublicKey\n\n\t// PaymentPoint is the base payment point for the sending party. This\n\t// key should be combined with the per commitment point for a\n\t// particular commitment state in order to create the key that should\n\t// be used in any output that pays directly to the sending party, and\n\t// also within the HTLC covenant transactions.\n\tPaymentPoint *btcec.PublicKey\n\n\t// DelayedPaymentPoint is the delay point for the sending party. This\n\t// key should be combined with the per commitment point to derive the\n\t// keys that are used in outputs of the sender's commitment transaction\n\t// where they claim funds.\n\tDelayedPaymentPoint *btcec.PublicKey\n\n\t// HtlcPoint is the base point used to derive the set of keys for this\n\t// party that will be used within the HTLC public key scripts.  This\n\t// value is combined with the receiver's revocation base point in order\n\t// to derive the keys that are used within HTLC scripts.\n\tHtlcPoint *btcec.PublicKey\n\n\t// FirstCommitmentPoint is the first commitment point for the sending\n\t// party. This value should be combined with the receiver's revocation\n\t// base point in order to derive the revocation keys that are placed\n\t// within the commitment transaction of the sender.\n\tFirstCommitmentPoint *btcec.PublicKey\n\n\t// UpfrontShutdownScript is the script to which the channel funds should\n\t// be paid when mutually closing the channel. This field is optional, and\n\t// and has a length prefix, so a zero will be written if it is not set\n\t// and its length followed by the script will be written if it is set.\n\tUpfrontShutdownScript DeliveryAddress\n\n\t// ChannelType is the explicit channel type the initiator wishes to\n\t// open.\n\tChannelType *ChannelType\n\n\t// LeaseExpiry represents the absolute expiration height of a channel\n\t// lease. This is a custom TLV record that will only apply when a leased\n\t// channel is being opened using the script enforced lease commitment\n\t// type.\n\tLeaseExpiry *LeaseExpiry\n\n\t// ExtraData is the set of data that was appended to this message to\n\t// fill out the full maximum transport message size. These fields can\n\t// be used to specify optional data such as custom TLV fields.\n\t//\n\t// NOTE: Since the upfront shutdown script MUST be present (though can\n\t// be zero-length) if any TLV data is available, the script will be\n\t// extracted and removed from this blob when decoding. ExtraData will\n\t// contain all TLV records _except_ the DeliveryAddress record in that\n\t// case.\n\tExtraData ExtraOpaqueData\n}\n\n// A compile time check to ensure AcceptChannel implements the lnwire.Message\n// interface.\nvar _ Message = (*AcceptChannel)(nil)\n\n// Encode serializes the target AcceptChannel into the passed io.Writer\n// implementation. Serialization will observe the rules defined by the passed\n// protocol version.\n//\n// This is part of the lnwire.Message interface.",
      "length": 4784,
      "tokens": 772,
      "embedding": []
    },
    {
      "slug": "func (a *AcceptChannel) Encode(w *bytes.Buffer, pver uint32) error {",
      "content": "func (a *AcceptChannel) Encode(w *bytes.Buffer, pver uint32) error {\n\trecordProducers := []tlv.RecordProducer{&a.UpfrontShutdownScript}\n\tif a.ChannelType != nil {\n\t\trecordProducers = append(recordProducers, a.ChannelType)\n\t}\n\tif a.LeaseExpiry != nil {\n\t\trecordProducers = append(recordProducers, a.LeaseExpiry)\n\t}\n\terr := EncodeMessageExtraData(&a.ExtraData, recordProducers...)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := WriteBytes(w, a.PendingChannelID[:]); err != nil {\n\t\treturn err\n\t}\n\n\tif err := WriteSatoshi(w, a.DustLimit); err != nil {\n\t\treturn err\n\t}\n\n\tif err := WriteMilliSatoshi(w, a.MaxValueInFlight); err != nil {\n\t\treturn err\n\t}\n\n\tif err := WriteSatoshi(w, a.ChannelReserve); err != nil {\n\t\treturn err\n\t}\n\n\tif err := WriteMilliSatoshi(w, a.HtlcMinimum); err != nil {\n\t\treturn err\n\t}\n\n\tif err := WriteUint32(w, a.MinAcceptDepth); err != nil {\n\t\treturn err\n\t}\n\n\tif err := WriteUint16(w, a.CsvDelay); err != nil {\n\t\treturn err\n\t}\n\n\tif err := WriteUint16(w, a.MaxAcceptedHTLCs); err != nil {\n\t\treturn err\n\t}\n\n\tif err := WritePublicKey(w, a.FundingKey); err != nil {\n\t\treturn err\n\t}\n\n\tif err := WritePublicKey(w, a.RevocationPoint); err != nil {\n\t\treturn err\n\t}\n\n\tif err := WritePublicKey(w, a.PaymentPoint); err != nil {\n\t\treturn err\n\t}\n\n\tif err := WritePublicKey(w, a.DelayedPaymentPoint); err != nil {\n\t\treturn err\n\t}\n\n\tif err := WritePublicKey(w, a.HtlcPoint); err != nil {\n\t\treturn err\n\t}\n\n\tif err := WritePublicKey(w, a.FirstCommitmentPoint); err != nil {\n\t\treturn err\n\t}\n\n\treturn WriteBytes(w, a.ExtraData)\n}\n\n// Decode deserializes the serialized AcceptChannel stored in the passed\n// io.Reader into the target AcceptChannel using the deserialization rules\n// defined by the passed protocol version.\n//\n// This is part of the lnwire.Message interface.",
      "length": 1626,
      "tokens": 243,
      "embedding": []
    },
    {
      "slug": "func (a *AcceptChannel) Decode(r io.Reader, pver uint32) error {",
      "content": "func (a *AcceptChannel) Decode(r io.Reader, pver uint32) error {\n\t// Read all the mandatory fields in the accept message.\n\terr := ReadElements(r,\n\t\ta.PendingChannelID[:],\n\t\t&a.DustLimit,\n\t\t&a.MaxValueInFlight,\n\t\t&a.ChannelReserve,\n\t\t&a.HtlcMinimum,\n\t\t&a.MinAcceptDepth,\n\t\t&a.CsvDelay,\n\t\t&a.MaxAcceptedHTLCs,\n\t\t&a.FundingKey,\n\t\t&a.RevocationPoint,\n\t\t&a.PaymentPoint,\n\t\t&a.DelayedPaymentPoint,\n\t\t&a.HtlcPoint,\n\t\t&a.FirstCommitmentPoint,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// For backwards compatibility, the optional extra data blob for\n\t// AcceptChannel must contain an entry for the upfront shutdown script.\n\t// We'll read it out and attempt to parse it.\n\tvar tlvRecords ExtraOpaqueData\n\tif err := ReadElements(r, &tlvRecords); err != nil {\n\t\treturn err\n\t}\n\n\t// Next we'll parse out the set of known records, keeping the raw tlv\n\t// bytes untouched to ensure we don't drop any bytes erroneously.\n\tvar (\n\t\tchanType    ChannelType\n\t\tleaseExpiry LeaseExpiry\n\t)\n\ttypeMap, err := tlvRecords.ExtractRecords(\n\t\t&a.UpfrontShutdownScript, &chanType, &leaseExpiry,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Set the corresponding TLV types if they were included in the stream.\n\tif val, ok := typeMap[ChannelTypeRecordType]; ok && val == nil {\n\t\ta.ChannelType = &chanType\n\t}\n\tif val, ok := typeMap[LeaseExpiryRecordType]; ok && val == nil {\n\t\ta.LeaseExpiry = &leaseExpiry\n\t}\n\n\ta.ExtraData = tlvRecords\n\n\treturn nil\n}\n\n// MsgType returns the MessageType code which uniquely identifies this message\n// as an AcceptChannel on the wire.\n//\n// This is part of the lnwire.Message interface.",
      "length": 1451,
      "tokens": 206,
      "embedding": []
    },
    {
      "slug": "func (a *AcceptChannel) MsgType() MessageType {",
      "content": "func (a *AcceptChannel) MsgType() MessageType {\n\treturn MsgAcceptChannel\n}\n",
      "length": 25,
      "tokens": 3,
      "embedding": []
    }
  ]
}