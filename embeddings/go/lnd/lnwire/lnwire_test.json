{
  "filepath": "../implementations/go/lnd/lnwire/lnwire_test.go",
  "package": "lnwire",
  "sections": [
    {
      "slug": "func randAlias(r *rand.Rand) NodeAlias {",
      "content": "func randAlias(r *rand.Rand) NodeAlias {\n\tvar a NodeAlias\n\tfor i := range a {\n\t\ta[i] = letterBytes[r.Intn(len(letterBytes))]\n\t}\n\n\treturn a\n}\n",
      "length": 93,
      "tokens": 16,
      "embedding": []
    },
    {
      "slug": "func randPubKey() (*btcec.PublicKey, error) {",
      "content": "func randPubKey() (*btcec.PublicKey, error) {\n\tpriv, err := btcec.NewPrivateKey()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn priv.PubKey(), nil\n}\n",
      "length": 97,
      "tokens": 17,
      "embedding": []
    },
    {
      "slug": "func randRawKey() ([33]byte, error) {",
      "content": "func randRawKey() ([33]byte, error) {\n\tvar n [33]byte\n\n\tpriv, err := btcec.NewPrivateKey()\n\tif err != nil {\n\t\treturn n, err\n\t}\n\n\tcopy(n[:], priv.PubKey().SerializeCompressed())\n\n\treturn n, nil\n}\n",
      "length": 146,
      "tokens": 22,
      "embedding": []
    },
    {
      "slug": "func randDeliveryAddress(r *rand.Rand) (DeliveryAddress, error) {",
      "content": "func randDeliveryAddress(r *rand.Rand) (DeliveryAddress, error) {\n\t// Generate size minimum one. Empty scripts should be tested specifically.\n\tsize := r.Intn(deliveryAddressMaxSize) + 1\n\tda := DeliveryAddress(make([]byte, size))\n\n\t_, err := r.Read(da)\n\treturn da, err\n}\n",
      "length": 197,
      "tokens": 28,
      "embedding": []
    },
    {
      "slug": "func randRawFeatureVector(r *rand.Rand) *RawFeatureVector {",
      "content": "func randRawFeatureVector(r *rand.Rand) *RawFeatureVector {\n\tfeatureVec := NewRawFeatureVector()\n\tfor i := 0; i < 10000; i++ {\n\t\tif r.Int31n(2) == 0 {\n\t\t\tfeatureVec.Set(FeatureBit(i))\n\t\t}\n\t}\n\treturn featureVec\n}\n",
      "length": 144,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func randTCP4Addr(r *rand.Rand) (*net.TCPAddr, error) {",
      "content": "func randTCP4Addr(r *rand.Rand) (*net.TCPAddr, error) {\n\tvar ip [4]byte\n\tif _, err := r.Read(ip[:]); err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar port [2]byte\n\tif _, err := r.Read(port[:]); err != nil {\n\t\treturn nil, err\n\t}\n\n\taddrIP := net.IP(ip[:])\n\taddrPort := int(binary.BigEndian.Uint16(port[:]))\n\n\treturn &net.TCPAddr{IP: addrIP, Port: addrPort}, nil\n}\n",
      "length": 282,
      "tokens": 45,
      "embedding": []
    },
    {
      "slug": "func randTCP6Addr(r *rand.Rand) (*net.TCPAddr, error) {",
      "content": "func randTCP6Addr(r *rand.Rand) (*net.TCPAddr, error) {\n\tvar ip [16]byte\n\tif _, err := r.Read(ip[:]); err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar port [2]byte\n\tif _, err := r.Read(port[:]); err != nil {\n\t\treturn nil, err\n\t}\n\n\taddrIP := net.IP(ip[:])\n\taddrPort := int(binary.BigEndian.Uint16(port[:]))\n\n\treturn &net.TCPAddr{IP: addrIP, Port: addrPort}, nil\n}\n",
      "length": 283,
      "tokens": 45,
      "embedding": []
    },
    {
      "slug": "func randV2OnionAddr(r *rand.Rand) (*tor.OnionAddr, error) {",
      "content": "func randV2OnionAddr(r *rand.Rand) (*tor.OnionAddr, error) {\n\tvar serviceID [tor.V2DecodedLen]byte\n\tif _, err := r.Read(serviceID[:]); err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar port [2]byte\n\tif _, err := r.Read(port[:]); err != nil {\n\t\treturn nil, err\n\t}\n\n\tonionService := tor.Base32Encoding.EncodeToString(serviceID[:])\n\tonionService += tor.OnionSuffix\n\taddrPort := int(binary.BigEndian.Uint16(port[:]))\n\n\treturn &tor.OnionAddr{OnionService: onionService, Port: addrPort}, nil\n}\n",
      "length": 401,
      "tokens": 48,
      "embedding": []
    },
    {
      "slug": "func randV3OnionAddr(r *rand.Rand) (*tor.OnionAddr, error) {",
      "content": "func randV3OnionAddr(r *rand.Rand) (*tor.OnionAddr, error) {\n\tvar serviceID [tor.V3DecodedLen]byte\n\tif _, err := r.Read(serviceID[:]); err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar port [2]byte\n\tif _, err := r.Read(port[:]); err != nil {\n\t\treturn nil, err\n\t}\n\n\tonionService := tor.Base32Encoding.EncodeToString(serviceID[:])\n\tonionService += tor.OnionSuffix\n\taddrPort := int(binary.BigEndian.Uint16(port[:]))\n\n\treturn &tor.OnionAddr{OnionService: onionService, Port: addrPort}, nil\n}\n",
      "length": 401,
      "tokens": 48,
      "embedding": []
    },
    {
      "slug": "func randOpaqueAddr(r *rand.Rand) (*OpaqueAddrs, error) {",
      "content": "func randOpaqueAddr(r *rand.Rand) (*OpaqueAddrs, error) {\n\tpayloadLen := r.Int63n(64) + 1\n\tpayload := make([]byte, payloadLen)\n\n\t// The first byte is the address type. So set it to one that we\n\t// definitely don't know about.\n\tpayload[0] = math.MaxUint8\n\n\t// Generate random bytes for the rest of the payload.\n\tif _, err := r.Read(payload[1:]); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &OpaqueAddrs{Payload: payload}, nil\n}\n",
      "length": 354,
      "tokens": 60,
      "embedding": []
    },
    {
      "slug": "func randAddrs(r *rand.Rand) ([]net.Addr, error) {",
      "content": "func randAddrs(r *rand.Rand) ([]net.Addr, error) {\n\ttcp4Addr, err := randTCP4Addr(r)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ttcp6Addr, err := randTCP6Addr(r)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tv2OnionAddr, err := randV2OnionAddr(r)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tv3OnionAddr, err := randV3OnionAddr(r)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\topaqueAddrs, err := randOpaqueAddr(r)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn []net.Addr{\n\t\ttcp4Addr, tcp6Addr, v2OnionAddr, v3OnionAddr, opaqueAddrs,\n\t}, nil\n}\n\n// TestChanUpdateChanFlags ensures that converting the ChanUpdateChanFlags and\n// ChanUpdateMsgFlags bitfields to a string behaves as expected.",
      "length": 586,
      "tokens": 92,
      "embedding": []
    },
    {
      "slug": "func TestChanUpdateChanFlags(t *testing.T) {",
      "content": "func TestChanUpdateChanFlags(t *testing.T) {\n\tt.Parallel()\n\n\ttestCases := []struct {\n\t\tflags    uint8\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tflags:    0,\n\t\t\texpected: \"00000000\",\n\t\t},\n\t\t{\n\t\t\tflags:    1,\n\t\t\texpected: \"00000001\",\n\t\t},\n\t\t{\n\t\t\tflags:    3,\n\t\t\texpected: \"00000011\",\n\t\t},\n\t\t{\n\t\t\tflags:    255,\n\t\t\texpected: \"11111111\",\n\t\t},\n\t}\n\n\tfor _, test := range testCases {\n\t\tchanFlag := ChanUpdateChanFlags(test.flags)\n\t\ttoStr := chanFlag.String()\n\t\tif toStr != test.expected {\n\t\t\tt.Fatalf(\"expected %v, got %v\",\n\t\t\t\ttest.expected, toStr)\n\t\t}\n\n\t\tmsgFlag := ChanUpdateMsgFlags(test.flags)\n\t\ttoStr = msgFlag.String()\n\t\tif toStr != test.expected {\n\t\t\tt.Fatalf(\"expected %v, got %v\",\n\t\t\t\ttest.expected, toStr)\n\t\t}\n\t}\n}\n\n// TestDecodeUnknownAddressType shows that an unknown address type is currently\n// incorrectly dealt with.",
      "length": 726,
      "tokens": 94,
      "embedding": []
    },
    {
      "slug": "func TestDecodeUnknownAddressType(t *testing.T) {",
      "content": "func TestDecodeUnknownAddressType(t *testing.T) {\n\t// Add a normal, clearnet address.\n\ttcpAddr := &net.TCPAddr{\n\t\tIP:   net.IP{127, 0, 0, 1},\n\t\tPort: 8080,\n\t}\n\n\t// Add an onion address.\n\tonionAddr := &tor.OnionAddr{\n\t\tOnionService: \"abcdefghijklmnop.onion\",\n\t\tPort:         9065,\n\t}\n\n\t// Now add an address with an unknown type.\n\tvar newAddrType addressType = math.MaxUint8\n\tdata := make([]byte, 0, 16)\n\tdata = append(data, uint8(newAddrType))\n\topaqueAddrs := &OpaqueAddrs{\n\t\tPayload: data,\n\t}\n\n\tbuffer := bytes.NewBuffer(make([]byte, 0, MaxMsgBody))\n\terr := WriteNetAddrs(\n\t\tbuffer, []net.Addr{tcpAddr, onionAddr, opaqueAddrs},\n\t)\n\trequire.NoError(t, err)\n\n\t// Now we attempt to parse the bytes and assert that we get an error.\n\tvar addrs []net.Addr\n\terr = ReadElement(buffer, &addrs)\n\trequire.NoError(t, err)\n\trequire.Len(t, addrs, 3)\n\trequire.Equal(t, tcpAddr.String(), addrs[0].String())\n\trequire.Equal(t, onionAddr.String(), addrs[1].String())\n\trequire.Equal(t, hex.EncodeToString(data), addrs[2].String())\n}\n",
      "length": 929,
      "tokens": 111,
      "embedding": []
    },
    {
      "slug": "func TestMaxOutPointIndex(t *testing.T) {",
      "content": "func TestMaxOutPointIndex(t *testing.T) {\n\tt.Parallel()\n\n\top := wire.OutPoint{\n\t\tIndex: math.MaxUint32,\n\t}\n\n\tvar b bytes.Buffer\n\tif err := WriteOutPoint(&b, op); err == nil {\n\t\tt.Fatalf(\"write of outPoint should fail, index exceeds 16-bits\")\n\t}\n}\n",
      "length": 194,
      "tokens": 29,
      "embedding": []
    },
    {
      "slug": "func TestEmptyMessageUnknownType(t *testing.T) {",
      "content": "func TestEmptyMessageUnknownType(t *testing.T) {\n\tt.Parallel()\n\n\tfakeType := CustomTypeStart - 1\n\tif _, err := makeEmptyMessage(fakeType); err == nil {\n\t\tt.Fatalf(\"should not be able to make an empty message of an \" +\n\t\t\t\"unknown type\")\n\t}\n}\n\n// TestLightningWireProtocol uses the testing/quick package to create a series\n// of fuzz tests to attempt to break a primary scenario which is implemented as\n// property based testing scenario.",
      "length": 377,
      "tokens": 62,
      "embedding": []
    },
    {
      "slug": "func TestLightningWireProtocol(t *testing.T) {",
      "content": "func TestLightningWireProtocol(t *testing.T) {\n\tt.Parallel()\n\n\t// mainScenario is the primary test that will programmatically be\n\t// executed for all registered wire messages. The quick-checker within\n\t// testing/quick will attempt to find an input to this function, s.t\n\t// the function returns false, if so then we've found an input that\n\t// violates our model of the system.\n\tmainScenario := func(msg Message) bool {\n\t\t// Give a new message, we'll serialize the message into a new\n\t\t// bytes buffer.\n\t\tvar b bytes.Buffer\n\t\tif _, err := WriteMessage(&b, msg, 0); err != nil {\n\t\t\tt.Fatalf(\"unable to write msg: %v\", err)\n\t\t\treturn false\n\t\t}\n\n\t\t// Next, we'll ensure that the serialized payload (subtracting\n\t\t// the 2 bytes for the message type) is _below_ the specified\n\t\t// max payload size for this message.\n\t\tpayloadLen := uint32(b.Len()) - 2\n\t\tif payloadLen > MaxMsgBody {\n\t\t\tt.Fatalf(\"msg payload constraint violated: %v > %v\",\n\t\t\t\tpayloadLen, MaxMsgBody)\n\t\t\treturn false\n\t\t}\n\n\t\t// Finally, we'll deserialize the message from the written\n\t\t// buffer, and finally assert that the messages are equal.\n\t\tnewMsg, err := ReadMessage(&b, 0)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to read msg: %v\", err)\n\t\t\treturn false\n\t\t}\n\t\tif !assert.Equalf(t, msg, newMsg, \"message mismatch\") {\n\t\t\treturn false\n\t\t}\n\n\t\treturn true\n\t}\n\n\t// customTypeGen is a map of functions that are able to randomly\n\t// generate a given type. These functions are needed for types which\n\t// are too complex for the testing/quick package to automatically\n\t// generate.\n\tcustomTypeGen := map[MessageType]func([]reflect.Value, *rand.Rand){\n\t\tMsgInit: func(v []reflect.Value, r *rand.Rand) {\n\t\t\treq := NewInitMessage(\n\t\t\t\trandRawFeatureVector(r),\n\t\t\t\trandRawFeatureVector(r),\n\t\t\t)\n\n\t\t\tv[0] = reflect.ValueOf(*req)\n\t\t},\n\t\tMsgOpenChannel: func(v []reflect.Value, r *rand.Rand) {\n\t\t\treq := OpenChannel{\n\t\t\t\tFundingAmount:    btcutil.Amount(r.Int63()),\n\t\t\t\tPushAmount:       MilliSatoshi(r.Int63()),\n\t\t\t\tDustLimit:        btcutil.Amount(r.Int63()),\n\t\t\t\tMaxValueInFlight: MilliSatoshi(r.Int63()),\n\t\t\t\tChannelReserve:   btcutil.Amount(r.Int63()),\n\t\t\t\tHtlcMinimum:      MilliSatoshi(r.Int31()),\n\t\t\t\tFeePerKiloWeight: uint32(r.Int63()),\n\t\t\t\tCsvDelay:         uint16(r.Int31()),\n\t\t\t\tMaxAcceptedHTLCs: uint16(r.Int31()),\n\t\t\t\tChannelFlags:     FundingFlag(uint8(r.Int31())),\n\t\t\t}\n\n\t\t\tif _, err := r.Read(req.ChainHash[:]); err != nil {\n\t\t\t\tt.Fatalf(\"unable to generate chain hash: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif _, err := r.Read(req.PendingChannelID[:]); err != nil {\n\t\t\t\tt.Fatalf(\"unable to generate pending chan id: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tvar err error\n\t\t\treq.FundingKey, err = randPubKey()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to generate key: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\treq.RevocationPoint, err = randPubKey()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to generate key: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\treq.PaymentPoint, err = randPubKey()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to generate key: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\treq.DelayedPaymentPoint, err = randPubKey()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to generate key: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\treq.HtlcPoint, err = randPubKey()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to generate key: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\treq.FirstCommitmentPoint, err = randPubKey()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to generate key: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// 1/2 chance empty TLV records.\n\t\t\tif r.Intn(2) == 0 {\n\t\t\t\treq.UpfrontShutdownScript, err = randDeliveryAddress(r)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"unable to generate delivery address: %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\treq.ChannelType = new(ChannelType)\n\t\t\t\t*req.ChannelType = ChannelType(*randRawFeatureVector(r))\n\n\t\t\t\treq.LeaseExpiry = new(LeaseExpiry)\n\t\t\t\t*req.LeaseExpiry = LeaseExpiry(1337)\n\t\t\t} else {\n\t\t\t\treq.UpfrontShutdownScript = []byte{}\n\t\t\t}\n\n\t\t\t// 1/2 chance additional TLV data.\n\t\t\tif r.Intn(2) == 0 {\n\t\t\t\treq.ExtraData = []byte{0xfd, 0x00, 0xff, 0x00}\n\t\t\t}\n\n\t\t\tv[0] = reflect.ValueOf(req)\n\t\t},\n\t\tMsgAcceptChannel: func(v []reflect.Value, r *rand.Rand) {\n\t\t\treq := AcceptChannel{\n\t\t\t\tDustLimit:        btcutil.Amount(r.Int63()),\n\t\t\t\tMaxValueInFlight: MilliSatoshi(r.Int63()),\n\t\t\t\tChannelReserve:   btcutil.Amount(r.Int63()),\n\t\t\t\tMinAcceptDepth:   uint32(r.Int31()),\n\t\t\t\tHtlcMinimum:      MilliSatoshi(r.Int31()),\n\t\t\t\tCsvDelay:         uint16(r.Int31()),\n\t\t\t\tMaxAcceptedHTLCs: uint16(r.Int31()),\n\t\t\t}\n\n\t\t\tif _, err := r.Read(req.PendingChannelID[:]); err != nil {\n\t\t\t\tt.Fatalf(\"unable to generate pending chan id: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tvar err error\n\t\t\treq.FundingKey, err = randPubKey()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to generate key: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\treq.RevocationPoint, err = randPubKey()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to generate key: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\treq.PaymentPoint, err = randPubKey()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to generate key: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\treq.DelayedPaymentPoint, err = randPubKey()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to generate key: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\treq.HtlcPoint, err = randPubKey()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to generate key: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\treq.FirstCommitmentPoint, err = randPubKey()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to generate key: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// 1/2 chance empty TLV records.\n\t\t\tif r.Intn(2) == 0 {\n\t\t\t\treq.UpfrontShutdownScript, err = randDeliveryAddress(r)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"unable to generate delivery address: %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\treq.ChannelType = new(ChannelType)\n\t\t\t\t*req.ChannelType = ChannelType(*randRawFeatureVector(r))\n\n\t\t\t\treq.LeaseExpiry = new(LeaseExpiry)\n\t\t\t\t*req.LeaseExpiry = LeaseExpiry(1337)\n\t\t\t} else {\n\t\t\t\treq.UpfrontShutdownScript = []byte{}\n\t\t\t}\n\n\t\t\t// 1/2 chance additional TLV data.\n\t\t\tif r.Intn(2) == 0 {\n\t\t\t\treq.ExtraData = []byte{0xfd, 0x00, 0xff, 0x00}\n\t\t\t}\n\n\t\t\tv[0] = reflect.ValueOf(req)\n\t\t},\n\t\tMsgFundingCreated: func(v []reflect.Value, r *rand.Rand) {\n\t\t\treq := FundingCreated{\n\t\t\t\tExtraData: make([]byte, 0),\n\t\t\t}\n\n\t\t\tif _, err := r.Read(req.PendingChannelID[:]); err != nil {\n\t\t\t\tt.Fatalf(\"unable to generate pending chan id: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif _, err := r.Read(req.FundingPoint.Hash[:]); err != nil {\n\t\t\t\tt.Fatalf(\"unable to generate hash: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\treq.FundingPoint.Index = uint32(r.Int31()) % math.MaxUint16\n\n\t\t\tvar err error\n\t\t\treq.CommitSig, err = NewSigFromSignature(testSig)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to parse sig: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tv[0] = reflect.ValueOf(req)\n\t\t},\n\t\tMsgFundingSigned: func(v []reflect.Value, r *rand.Rand) {\n\t\t\tvar c [32]byte\n\t\t\t_, err := r.Read(c[:])\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to generate chan id: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\treq := FundingSigned{\n\t\t\t\tChanID:    ChannelID(c),\n\t\t\t\tExtraData: make([]byte, 0),\n\t\t\t}\n\t\t\treq.CommitSig, err = NewSigFromSignature(testSig)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to parse sig: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tv[0] = reflect.ValueOf(req)\n\t\t},\n\t\tMsgFundingLocked: func(v []reflect.Value, r *rand.Rand) {\n\n\t\t\tvar c [32]byte\n\t\t\tif _, err := r.Read(c[:]); err != nil {\n\t\t\t\tt.Fatalf(\"unable to generate chan id: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tpubKey, err := randPubKey()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to generate key: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\treq := NewFundingLocked(ChannelID(c), pubKey)\n\n\t\t\tv[0] = reflect.ValueOf(*req)\n\t\t},\n\t\tMsgClosingSigned: func(v []reflect.Value, r *rand.Rand) {\n\t\t\treq := ClosingSigned{\n\t\t\t\tFeeSatoshis: btcutil.Amount(r.Int63()),\n\t\t\t\tExtraData:   make([]byte, 0),\n\t\t\t}\n\t\t\tvar err error\n\t\t\treq.Signature, err = NewSigFromSignature(testSig)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to parse sig: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif _, err := r.Read(req.ChannelID[:]); err != nil {\n\t\t\t\tt.Fatalf(\"unable to generate chan id: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tv[0] = reflect.ValueOf(req)\n\t\t},\n\t\tMsgCommitSig: func(v []reflect.Value, r *rand.Rand) {\n\t\t\treq := NewCommitSig()\n\t\t\tif _, err := r.Read(req.ChanID[:]); err != nil {\n\t\t\t\tt.Fatalf(\"unable to generate chan id: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tvar err error\n\t\t\treq.CommitSig, err = NewSigFromSignature(testSig)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to parse sig: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Only create the slice if there will be any signatures\n\t\t\t// in it to prevent false positive test failures due to\n\t\t\t// an empty slice versus a nil slice.\n\t\t\tnumSigs := uint16(r.Int31n(1020))\n\t\t\tif numSigs > 0 {\n\t\t\t\treq.HtlcSigs = make([]Sig, numSigs)\n\t\t\t}\n\t\t\tfor i := 0; i < int(numSigs); i++ {\n\t\t\t\treq.HtlcSigs[i], err = NewSigFromSignature(testSig)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"unable to parse sig: %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tv[0] = reflect.ValueOf(*req)\n\t\t},\n\t\tMsgRevokeAndAck: func(v []reflect.Value, r *rand.Rand) {\n\t\t\treq := NewRevokeAndAck()\n\t\t\tif _, err := r.Read(req.ChanID[:]); err != nil {\n\t\t\t\tt.Fatalf(\"unable to generate chan id: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif _, err := r.Read(req.Revocation[:]); err != nil {\n\t\t\t\tt.Fatalf(\"unable to generate bytes: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar err error\n\t\t\treq.NextRevocationKey, err = randPubKey()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to generate key: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tv[0] = reflect.ValueOf(*req)\n\t\t},\n\t\tMsgChannelAnnouncement: func(v []reflect.Value, r *rand.Rand) {\n\t\t\tvar err error\n\t\t\treq := ChannelAnnouncement{\n\t\t\t\tShortChannelID:  NewShortChanIDFromInt(uint64(r.Int63())),\n\t\t\t\tFeatures:        randRawFeatureVector(r),\n\t\t\t\tExtraOpaqueData: make([]byte, 0),\n\t\t\t}\n\t\t\treq.NodeSig1, err = NewSigFromSignature(testSig)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to parse sig: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\treq.NodeSig2, err = NewSigFromSignature(testSig)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to parse sig: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\treq.BitcoinSig1, err = NewSigFromSignature(testSig)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to parse sig: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\treq.BitcoinSig2, err = NewSigFromSignature(testSig)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to parse sig: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\treq.NodeID1, err = randRawKey()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to generate key: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\treq.NodeID2, err = randRawKey()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to generate key: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\treq.BitcoinKey1, err = randRawKey()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to generate key: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\treq.BitcoinKey2, err = randRawKey()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to generate key: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif _, err := r.Read(req.ChainHash[:]); err != nil {\n\t\t\t\tt.Fatalf(\"unable to generate chain hash: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tnumExtraBytes := r.Int31n(1000)\n\t\t\tif numExtraBytes > 0 {\n\t\t\t\treq.ExtraOpaqueData = make([]byte, numExtraBytes)\n\t\t\t\t_, err := r.Read(req.ExtraOpaqueData[:])\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"unable to generate opaque \"+\n\t\t\t\t\t\t\"bytes: %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tv[0] = reflect.ValueOf(req)\n\t\t},\n\t\tMsgNodeAnnouncement: func(v []reflect.Value, r *rand.Rand) {\n\t\t\tvar err error\n\t\t\treq := NodeAnnouncement{\n\t\t\t\tFeatures:  randRawFeatureVector(r),\n\t\t\t\tTimestamp: uint32(r.Int31()),\n\t\t\t\tAlias:     randAlias(r),\n\t\t\t\tRGBColor: color.RGBA{\n\t\t\t\t\tR: uint8(r.Int31()),\n\t\t\t\t\tG: uint8(r.Int31()),\n\t\t\t\t\tB: uint8(r.Int31()),\n\t\t\t\t},\n\t\t\t\tExtraOpaqueData: make([]byte, 0),\n\t\t\t}\n\t\t\treq.Signature, err = NewSigFromSignature(testSig)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to parse sig: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\treq.NodeID, err = randRawKey()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to generate key: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\treq.Addresses, err = randAddrs(r)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to generate addresses: %v\", err)\n\t\t\t}\n\n\t\t\tnumExtraBytes := r.Int31n(1000)\n\t\t\tif numExtraBytes > 0 {\n\t\t\t\treq.ExtraOpaqueData = make([]byte, numExtraBytes)\n\t\t\t\t_, err := r.Read(req.ExtraOpaqueData[:])\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"unable to generate opaque \"+\n\t\t\t\t\t\t\"bytes: %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tv[0] = reflect.ValueOf(req)\n\t\t},\n\t\tMsgChannelUpdate: func(v []reflect.Value, r *rand.Rand) {\n\t\t\tvar err error\n\n\t\t\tmsgFlags := ChanUpdateMsgFlags(r.Int31())\n\t\t\tmaxHtlc := MilliSatoshi(r.Int63())\n\n\t\t\t// We make the max_htlc field zero if it is not flagged\n\t\t\t// as being part of the ChannelUpdate, to pass\n\t\t\t// serialization tests, as it will be ignored if the bit\n\t\t\t// is not set.\n\t\t\tif msgFlags&ChanUpdateRequiredMaxHtlc == 0 {\n\t\t\t\tmaxHtlc = 0\n\t\t\t}\n\n\t\t\treq := ChannelUpdate{\n\t\t\t\tShortChannelID:  NewShortChanIDFromInt(uint64(r.Int63())),\n\t\t\t\tTimestamp:       uint32(r.Int31()),\n\t\t\t\tMessageFlags:    msgFlags,\n\t\t\t\tChannelFlags:    ChanUpdateChanFlags(r.Int31()),\n\t\t\t\tTimeLockDelta:   uint16(r.Int31()),\n\t\t\t\tHtlcMinimumMsat: MilliSatoshi(r.Int63()),\n\t\t\t\tHtlcMaximumMsat: maxHtlc,\n\t\t\t\tBaseFee:         uint32(r.Int31()),\n\t\t\t\tFeeRate:         uint32(r.Int31()),\n\t\t\t\tExtraOpaqueData: make([]byte, 0),\n\t\t\t}\n\t\t\treq.Signature, err = NewSigFromSignature(testSig)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to parse sig: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif _, err := r.Read(req.ChainHash[:]); err != nil {\n\t\t\t\tt.Fatalf(\"unable to generate chain hash: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tnumExtraBytes := r.Int31n(1000)\n\t\t\tif numExtraBytes > 0 {\n\t\t\t\treq.ExtraOpaqueData = make([]byte, numExtraBytes)\n\t\t\t\t_, err := r.Read(req.ExtraOpaqueData[:])\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"unable to generate opaque \"+\n\t\t\t\t\t\t\"bytes: %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tv[0] = reflect.ValueOf(req)\n\t\t},\n\t\tMsgAnnounceSignatures: func(v []reflect.Value, r *rand.Rand) {\n\t\t\tvar err error\n\t\t\treq := AnnounceSignatures{\n\t\t\t\tShortChannelID:  NewShortChanIDFromInt(uint64(r.Int63())),\n\t\t\t\tExtraOpaqueData: make([]byte, 0),\n\t\t\t}\n\n\t\t\treq.NodeSignature, err = NewSigFromSignature(testSig)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to parse sig: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\treq.BitcoinSignature, err = NewSigFromSignature(testSig)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to parse sig: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif _, err := r.Read(req.ChannelID[:]); err != nil {\n\t\t\t\tt.Fatalf(\"unable to generate chan id: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tnumExtraBytes := r.Int31n(1000)\n\t\t\tif numExtraBytes > 0 {\n\t\t\t\treq.ExtraOpaqueData = make([]byte, numExtraBytes)\n\t\t\t\t_, err := r.Read(req.ExtraOpaqueData[:])\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"unable to generate opaque \"+\n\t\t\t\t\t\t\"bytes: %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tv[0] = reflect.ValueOf(req)\n\t\t},\n\t\tMsgChannelReestablish: func(v []reflect.Value, r *rand.Rand) {\n\t\t\treq := ChannelReestablish{\n\t\t\t\tNextLocalCommitHeight:  uint64(r.Int63()),\n\t\t\t\tRemoteCommitTailHeight: uint64(r.Int63()),\n\t\t\t\tExtraData:              make([]byte, 0),\n\t\t\t}\n\n\t\t\t// With a 50/50 probability, we'll include the\n\t\t\t// additional fields so we can test our ability to\n\t\t\t// properly parse, and write out the optional fields.\n\t\t\tif r.Int()%2 == 0 {\n\t\t\t\t_, err := r.Read(req.LastRemoteCommitSecret[:])\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"unable to read commit secret: %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\treq.LocalUnrevokedCommitPoint, err = randPubKey()\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"unable to generate key: %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tv[0] = reflect.ValueOf(req)\n\t\t},\n\t\tMsgQueryShortChanIDs: func(v []reflect.Value, r *rand.Rand) {\n\t\t\treq := QueryShortChanIDs{\n\t\t\t\tExtraData: make([]byte, 0),\n\t\t\t}\n\n\t\t\t// With a 50/50 change, we'll either use zlib encoding,\n\t\t\t// or regular encoding.\n\t\t\tif r.Int31()%2 == 0 {\n\t\t\t\treq.EncodingType = EncodingSortedZlib\n\t\t\t} else {\n\t\t\t\treq.EncodingType = EncodingSortedPlain\n\t\t\t}\n\n\t\t\tif _, err := rand.Read(req.ChainHash[:]); err != nil {\n\t\t\t\tt.Fatalf(\"unable to read chain hash: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tnumChanIDs := rand.Int31n(5000)\n\t\t\tfor i := int32(0); i < numChanIDs; i++ {\n\t\t\t\treq.ShortChanIDs = append(req.ShortChanIDs,\n\t\t\t\t\tNewShortChanIDFromInt(uint64(r.Int63())))\n\t\t\t}\n\n\t\t\tv[0] = reflect.ValueOf(req)\n\t\t},\n\t\tMsgReplyChannelRange: func(v []reflect.Value, r *rand.Rand) {\n\t\t\treq := ReplyChannelRange{\n\t\t\t\tFirstBlockHeight: uint32(r.Int31()),\n\t\t\t\tNumBlocks:        uint32(r.Int31()),\n\t\t\t\tExtraData:        make([]byte, 0),\n\t\t\t}\n\n\t\t\tif _, err := rand.Read(req.ChainHash[:]); err != nil {\n\t\t\t\tt.Fatalf(\"unable to read chain hash: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\treq.Complete = uint8(r.Int31n(2))\n\n\t\t\t// With a 50/50 change, we'll either use zlib encoding,\n\t\t\t// or regular encoding.\n\t\t\tif r.Int31()%2 == 0 {\n\t\t\t\treq.EncodingType = EncodingSortedZlib\n\t\t\t} else {\n\t\t\t\treq.EncodingType = EncodingSortedPlain\n\t\t\t}\n\n\t\t\tnumChanIDs := rand.Int31n(5000)\n\t\t\tfor i := int32(0); i < numChanIDs; i++ {\n\t\t\t\treq.ShortChanIDs = append(req.ShortChanIDs,\n\t\t\t\t\tNewShortChanIDFromInt(uint64(r.Int63())))\n\t\t\t}\n\n\t\t\tv[0] = reflect.ValueOf(req)\n\t\t},\n\t\tMsgPing: func(v []reflect.Value, r *rand.Rand) {\n\t\t\t// We use a special message generator here to ensure we\n\t\t\t// don't generate ping messages that are too large,\n\t\t\t// which'll cause the test to fail.\n\t\t\t//\n\t\t\t// We'll allow the test to generate padding bytes up to\n\t\t\t// the max message limit, factoring in the 2 bytes for\n\t\t\t// the num pong bytes.\n\t\t\tpaddingBytes := make([]byte, r.Intn(MaxMsgBody-1))\n\t\t\treq := Ping{\n\t\t\t\tNumPongBytes: uint16(r.Intn(MaxPongBytes + 1)),\n\t\t\t\tPaddingBytes: paddingBytes,\n\t\t\t}\n\n\t\t\tv[0] = reflect.ValueOf(req)\n\t\t},\n\t}\n\n\t// With the above types defined, we'll now generate a slice of\n\t// scenarios to feed into quick.Check. The function scans in input\n\t// space of the target function under test, so we'll need to create a\n\t// series of wrapper functions to force it to iterate over the target\n\t// types, but re-use the mainScenario defined above.\n\ttests := []struct {\n\t\tmsgType  MessageType\n\t\tscenario interface{}\n\t}{\n\t\t{\n\t\t\tmsgType: MsgInit,\n\t\t\tscenario: func(m Init) bool {\n\t\t\t\treturn mainScenario(&m)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tmsgType: MsgWarning,\n\t\t\tscenario: func(m Warning) bool {\n\t\t\t\treturn mainScenario(&m)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tmsgType: MsgError,\n\t\t\tscenario: func(m Error) bool {\n\t\t\t\treturn mainScenario(&m)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tmsgType: MsgPing,\n\t\t\tscenario: func(m Ping) bool {\n\t\t\t\treturn mainScenario(&m)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tmsgType: MsgPong,\n\t\t\tscenario: func(m Pong) bool {\n\t\t\t\treturn mainScenario(&m)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tmsgType: MsgOpenChannel,\n\t\t\tscenario: func(m OpenChannel) bool {\n\t\t\t\treturn mainScenario(&m)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tmsgType: MsgAcceptChannel,\n\t\t\tscenario: func(m AcceptChannel) bool {\n\t\t\t\treturn mainScenario(&m)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tmsgType: MsgFundingCreated,\n\t\t\tscenario: func(m FundingCreated) bool {\n\t\t\t\treturn mainScenario(&m)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tmsgType: MsgFundingSigned,\n\t\t\tscenario: func(m FundingSigned) bool {\n\t\t\t\treturn mainScenario(&m)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tmsgType: MsgFundingLocked,\n\t\t\tscenario: func(m FundingLocked) bool {\n\t\t\t\treturn mainScenario(&m)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tmsgType: MsgShutdown,\n\t\t\tscenario: func(m Shutdown) bool {\n\t\t\t\treturn mainScenario(&m)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tmsgType: MsgClosingSigned,\n\t\t\tscenario: func(m ClosingSigned) bool {\n\t\t\t\treturn mainScenario(&m)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tmsgType: MsgUpdateAddHTLC,\n\t\t\tscenario: func(m UpdateAddHTLC) bool {\n\t\t\t\treturn mainScenario(&m)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tmsgType: MsgUpdateFulfillHTLC,\n\t\t\tscenario: func(m UpdateFulfillHTLC) bool {\n\t\t\t\treturn mainScenario(&m)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tmsgType: MsgUpdateFailHTLC,\n\t\t\tscenario: func(m UpdateFailHTLC) bool {\n\t\t\t\treturn mainScenario(&m)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tmsgType: MsgCommitSig,\n\t\t\tscenario: func(m CommitSig) bool {\n\t\t\t\treturn mainScenario(&m)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tmsgType: MsgRevokeAndAck,\n\t\t\tscenario: func(m RevokeAndAck) bool {\n\t\t\t\treturn mainScenario(&m)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tmsgType: MsgUpdateFee,\n\t\t\tscenario: func(m UpdateFee) bool {\n\t\t\t\treturn mainScenario(&m)\n\t\t\t},\n\t\t},\n\t\t{\n\n\t\t\tmsgType: MsgUpdateFailMalformedHTLC,\n\t\t\tscenario: func(m UpdateFailMalformedHTLC) bool {\n\t\t\t\treturn mainScenario(&m)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tmsgType: MsgChannelReestablish,\n\t\t\tscenario: func(m ChannelReestablish) bool {\n\t\t\t\treturn mainScenario(&m)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tmsgType: MsgChannelAnnouncement,\n\t\t\tscenario: func(m ChannelAnnouncement) bool {\n\t\t\t\treturn mainScenario(&m)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tmsgType: MsgNodeAnnouncement,\n\t\t\tscenario: func(m NodeAnnouncement) bool {\n\t\t\t\treturn mainScenario(&m)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tmsgType: MsgChannelUpdate,\n\t\t\tscenario: func(m ChannelUpdate) bool {\n\t\t\t\treturn mainScenario(&m)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tmsgType: MsgAnnounceSignatures,\n\t\t\tscenario: func(m AnnounceSignatures) bool {\n\t\t\t\treturn mainScenario(&m)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tmsgType: MsgGossipTimestampRange,\n\t\t\tscenario: func(m GossipTimestampRange) bool {\n\t\t\t\treturn mainScenario(&m)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tmsgType: MsgQueryShortChanIDs,\n\t\t\tscenario: func(m QueryShortChanIDs) bool {\n\t\t\t\treturn mainScenario(&m)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tmsgType: MsgReplyShortChanIDsEnd,\n\t\t\tscenario: func(m ReplyShortChanIDsEnd) bool {\n\t\t\t\treturn mainScenario(&m)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tmsgType: MsgQueryChannelRange,\n\t\t\tscenario: func(m QueryChannelRange) bool {\n\t\t\t\treturn mainScenario(&m)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tmsgType: MsgReplyChannelRange,\n\t\t\tscenario: func(m ReplyChannelRange) bool {\n\t\t\t\treturn mainScenario(&m)\n\t\t\t},\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tvar config *quick.Config\n\n\t\t// If the type defined is within the custom type gen map above,\n\t\t// then we'll modify the default config to use this Value\n\t\t// function that knows how to generate the proper types.\n\t\tif valueGen, ok := customTypeGen[test.msgType]; ok {\n\t\t\tconfig = &quick.Config{\n\t\t\t\tValues: valueGen,\n\t\t\t}\n\t\t}\n\n\t\tt.Logf(\"Running fuzz tests for msgType=%v\", test.msgType)\n\t\tif err := quick.Check(test.scenario, config); err != nil {\n\t\t\tt.Fatalf(\"fuzz checks for msg=%v failed: %v\",\n\t\t\t\ttest.msgType, err)\n\t\t}\n\t}\n\n}\n",
      "length": 20583,
      "tokens": 2574,
      "embedding": []
    },
    {
      "slug": "func init() {",
      "content": "func init() {\n\trand.Seed(time.Now().Unix())\n}\n",
      "length": 30,
      "tokens": 2,
      "embedding": []
    }
  ]
}