{
  "filepath": "../implementations/go/lnd/lnwire/signature_test.go",
  "package": "lnwire",
  "sections": [
    {
      "slug": "func TestSignatureSerializeDeserialize(t *testing.T) {",
      "content": "func TestSignatureSerializeDeserialize(t *testing.T) {\n\tt.Parallel()\n\n\t// Local-scoped closure to serialize and deserialize a Signature and\n\t// check for errors as well as check if the results are correct.\n\tsignatureSerializeDeserialize := func(e *ecdsa.Signature) error {\n\t\tsig, err := NewSigFromSignature(e)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\te2, err := sig.ToSignature()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif !e.IsEqual(e2) {\n\t\t\treturn fmt.Errorf(\"pre/post-serialize sigs don't \" +\n\t\t\t\t\"match\")\n\t\t}\n\t\treturn nil\n\t}\n\n\t// Check R = N-1, S = 128.\n\tr := big.NewInt(1) // Allocate a big.Int before we call .Sub.\n\tr.Sub(btcec.S256().N, r)\n\trScalar := new(btcec.ModNScalar)\n\trScalar.SetByteSlice(r.Bytes())\n\n\tsig := ecdsa.NewSignature(rScalar, new(btcec.ModNScalar).SetInt(128))\n\terr := signatureSerializeDeserialize(sig)\n\tif err != nil {\n\t\tt.Fatalf(\"R = N-1, S = 128: %s\", err.Error())\n\t}\n\n\t// Check R = N-1, S = 127.\n\tsig = ecdsa.NewSignature(rScalar, new(btcec.ModNScalar).SetInt(127))\n\terr = signatureSerializeDeserialize(sig)\n\tif err != nil {\n\t\tt.Fatalf(\"R = N-1, S = 127: %s\", err.Error())\n\t}\n\n\t// Check R = N-1, S = N>>1.\n\ts := new(big.Int).Set(btcec.S256().N)\n\ts.Rsh(s, 1)\n\tsScalar := new(btcec.ModNScalar)\n\tsScalar.SetByteSlice(s.Bytes())\n\tsig = ecdsa.NewSignature(rScalar, sScalar)\n\terr = signatureSerializeDeserialize(sig)\n\tif err != nil {\n\t\tt.Fatalf(\"R = N-1, S = N>>1: %s\", err.Error())\n\t}\n\n\t// Check R = N-1, S = N.\n\ts = new(big.Int).Set(btcec.S256().N)\n\toverflow := sScalar.SetByteSlice(s.Bytes())\n\tif !overflow {\n\t\tt.Fatalf(\"Expect ModNScalar to overflow when setting N but \" +\n\t\t\t\"didn't\")\n\t}\n\tsig = ecdsa.NewSignature(rScalar, sScalar)\n\terr = signatureSerializeDeserialize(sig)\n\tif err.Error() != \"invalid signature: S is 0\" {\n\t\tt.Fatalf(\"R = N-1, S = N should become R = N-1, S = 0: %s\",\n\t\t\terr.Error())\n\t}\n\n\t// Check R = N-1, S = N-1.\n\ts = new(big.Int).Set(btcec.S256().N)\n\ts.Sub(s, big.NewInt(1))\n\tsScalar.SetByteSlice(s.Bytes())\n\tsig = ecdsa.NewSignature(rScalar, sScalar)\n\terr = signatureSerializeDeserialize(sig)\n\tif err.Error() != \"pre/post-serialize sigs don't match\" {\n\t\tt.Fatalf(\"R = N-1, S = N-1 should become R = N-1, S = 1: %s\",\n\t\t\terr.Error())\n\t}\n\n\t// Check R = 2N, S = 128\n\t// This cannot be tested anymore since the new ecdsa package creates\n\t// the signature from ModNScalar values which don't allow setting a\n\t// value larger than N (hence the name mod n).\n}\n\nvar (\n\t// signatures from bitcoin blockchain tx\n\t// 0437cd7f8525ceed2324359c2d0ba26006d92d85.\n\tnormalSig = []byte{\n\t\t0x30, 0x44, 0x02, 0x20,\n\t\t// r value\n\t\t0x4e, 0x45, 0xe1, 0x69, 0x32, 0xb8, 0xaf, 0x51,\n\t\t0x49, 0x61, 0xa1, 0xd3, 0xa1, 0xa2, 0x5f, 0xdf,\n\t\t0x3f, 0x4f, 0x77, 0x32, 0xe9, 0xd6, 0x24, 0xc6,\n\t\t0xc6, 0x15, 0x48, 0xab, 0x5f, 0xb8, 0xcd, 0x41,\n\n\t\t0x02, 0x20,\n\t\t// s value\n\t\t0x18, 0x15, 0x22, 0xec, 0x8e, 0xca, 0x07, 0xde,\n\t\t0x48, 0x60, 0xa4, 0xac, 0xdd, 0x12, 0x90, 0x9d,\n\t\t0x83, 0x1c, 0xc5, 0x6c, 0xbb, 0xac, 0x46, 0x22,\n\t\t0x08, 0x22, 0x21, 0xa8, 0x76, 0x8d, 0x1d, 0x09,\n\t}\n\n\t// minimal length with 1 byte r and 1 byte s.\n\tminSig = []byte{\n\t\t0x30, 0x06, 0x02, 0x01, 0x00, 0x02, 0x01, 0x00,\n\t}\n\n\t// sig length is below 6.\n\tsmallLenSig = []byte{\n\t\t0x30, 0x05, 0x02, 0x01, 0x00, 0x02, 0x01, 0x00,\n\t}\n\n\t// sig length is above 6.\n\tlargeLenSig = []byte{\n\t\t0x30, 0x07, 0x02, 0x01, 0x00, 0x02, 0x01, 0x00,\n\t}\n\n\t// r length is 2.\n\tlargeRSig = []byte{\n\t\t0x30, 0x06, 0x02, 0x02, 0x00, 0x02, 0x01, 0x00,\n\t}\n\n\t// r length is 0.\n\tsmallRSig = []byte{\n\t\t0x30, 0x06, 0x02, 0x00, 0x00, 0x02, 0x01, 0x00,\n\t}\n\n\t// s length is 2.\n\tlargeSSig = []byte{\n\t\t0x30, 0x06, 0x02, 0x01, 0x00, 0x02, 0x02, 0x00,\n\t}\n\n\t// s length is 0.\n\tsmallSSig = []byte{\n\t\t0x30, 0x06, 0x02, 0x01, 0x00, 0x02, 0x00, 0x00,\n\t}\n\n\t// r length is 33.\n\tmissPaddingRSig = []byte{\n\t\t0x30, 0x25, 0x02, 0x21,\n\t\t// r value with a wrong padding.\n\t\t0xff,\n\t\t0x4e, 0x45, 0xe1, 0x69, 0x32, 0xb8, 0xaf, 0x51,\n\t\t0x49, 0x61, 0xa1, 0xd3, 0xa1, 0xa2, 0x5f, 0xdf,\n\t\t0x3f, 0x4f, 0x77, 0x32, 0xe9, 0xd6, 0x24, 0xc6,\n\t\t0xc6, 0x15, 0x48, 0xab, 0x5f, 0xb8, 0xcd, 0x41,\n\t\t// s value is 0.\n\t\t0x02, 0x01, 0x00,\n\t}\n\n\t// s length is 33.\n\tmissPaddingSSig = []byte{\n\t\t// r value is 0.\n\t\t0x30, 0x25, 0x02, 0x01, 0x00,\n\t\t0x02, 0x21,\n\t\t// s value with a wrong padding.\n\t\t0xff,\n\t\t0x18, 0x15, 0x22, 0xec, 0x8e, 0xca, 0x07, 0xde,\n\t\t0x48, 0x60, 0xa4, 0xac, 0xdd, 0x12, 0x90, 0x9d,\n\t\t0x83, 0x1c, 0xc5, 0x6c, 0xbb, 0xac, 0x46, 0x22,\n\t\t0x08, 0x22, 0x21, 0xa8, 0x76, 0x8d, 0x1d, 0x09,\n\t}\n)\n",
      "length": 4190,
      "tokens": 671,
      "embedding": []
    },
    {
      "slug": "func TestNewSigFromRawSignature(t *testing.T) {",
      "content": "func TestNewSigFromRawSignature(t *testing.T) {\n\tt.Parallel()\n\ttestCases := []struct {\n\t\tname        string\n\t\trawSig      []byte\n\t\texpectedErr error\n\t\texpectedSig Sig\n\t}{\n\t\t{\n\t\t\tname:        \"valid signature\",\n\t\t\trawSig:      normalSig,\n\t\t\texpectedErr: nil,\n\t\t\texpectedSig: Sig{\n\t\t\t\t// r value\n\t\t\t\t0x4e, 0x45, 0xe1, 0x69, 0x32, 0xb8, 0xaf, 0x51,\n\t\t\t\t0x49, 0x61, 0xa1, 0xd3, 0xa1, 0xa2, 0x5f, 0xdf,\n\t\t\t\t0x3f, 0x4f, 0x77, 0x32, 0xe9, 0xd6, 0x24, 0xc6,\n\t\t\t\t0xc6, 0x15, 0x48, 0xab, 0x5f, 0xb8, 0xcd, 0x41,\n\t\t\t\t// s value\n\t\t\t\t0x18, 0x15, 0x22, 0xec, 0x8e, 0xca, 0x07, 0xde,\n\t\t\t\t0x48, 0x60, 0xa4, 0xac, 0xdd, 0x12, 0x90, 0x9d,\n\t\t\t\t0x83, 0x1c, 0xc5, 0x6c, 0xbb, 0xac, 0x46, 0x22,\n\t\t\t\t0x08, 0x22, 0x21, 0xa8, 0x76, 0x8d, 0x1d, 0x09,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:        \"minimal length signature\",\n\t\t\trawSig:      minSig,\n\t\t\texpectedErr: nil,\n\t\t\t// NOTE: r and s are both 0x00 here.\n\t\t\texpectedSig: Sig{},\n\t\t},\n\t\t{\n\t\t\tname:        \"signature length too short\",\n\t\t\trawSig:      []byte{0x30},\n\t\t\texpectedErr: errSigTooShort,\n\t\t\texpectedSig: Sig{},\n\t\t},\n\t\t{\n\t\t\tname:        \"sig length too large\",\n\t\t\trawSig:      largeLenSig,\n\t\t\texpectedErr: errBadLength,\n\t\t\texpectedSig: Sig{},\n\t\t},\n\t\t{\n\t\t\tname:        \"sig length too small\",\n\t\t\trawSig:      smallLenSig,\n\t\t\texpectedErr: errBadLength,\n\t\t\texpectedSig: Sig{},\n\t\t},\n\t\t{\n\t\t\tname:        \"r length too large\",\n\t\t\trawSig:      largeRSig,\n\t\t\texpectedErr: errBadRLength,\n\t\t\texpectedSig: Sig{},\n\t\t},\n\t\t{\n\t\t\tname:        \"r length too small\",\n\t\t\trawSig:      smallRSig,\n\t\t\texpectedErr: errBadRLength,\n\t\t\texpectedSig: Sig{},\n\t\t},\n\t\t{\n\t\t\tname:        \"s length too large\",\n\t\t\trawSig:      largeSSig,\n\t\t\texpectedErr: errBadSLength,\n\t\t\texpectedSig: Sig{},\n\t\t},\n\t\t{\n\t\t\tname:        \"s length too small\",\n\t\t\trawSig:      smallSSig,\n\t\t\texpectedErr: errBadSLength,\n\t\t\texpectedSig: Sig{},\n\t\t},\n\t\t{\n\t\t\tname:        \"missing padding in r\",\n\t\t\trawSig:      missPaddingRSig,\n\t\t\texpectedErr: errRTooLong,\n\t\t\texpectedSig: Sig{},\n\t\t},\n\t\t{\n\t\t\tname:        \"missing padding in s\",\n\t\t\trawSig:      missPaddingSSig,\n\t\t\texpectedErr: errSTooLong,\n\t\t\texpectedSig: Sig{},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult, err := NewSigFromRawSignature(tc.rawSig)\n\t\t\trequire.Equal(t, tc.expectedErr, err)\n\t\t\trequire.Equal(t, tc.expectedSig, result)\n\t\t})\n\t}\n}\n",
      "length": 2167,
      "tokens": 262,
      "embedding": []
    }
  ]
}