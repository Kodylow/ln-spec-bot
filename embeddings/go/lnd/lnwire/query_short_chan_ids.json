{
  "filepath": "../implementations/go/lnd/lnwire/query_short_chan_ids.go",
  "package": "lnwire",
  "sections": [
    {
      "slug": "type ShortChanIDEncoding uint8",
      "content": "type ShortChanIDEncoding uint8\n\nconst (\n\t// EncodingSortedPlain signals that the set of short channel ID's is\n\t// encoded using the regular encoding, in a sorted order.\n\tEncodingSortedPlain ShortChanIDEncoding = 0\n\n\t// EncodingSortedZlib signals that the set of short channel ID's is\n\t// encoded by first sorting the set of channel ID's, as then\n\t// compressing them using zlib.\n\tEncodingSortedZlib ShortChanIDEncoding = 1\n)\n\nconst (\n\t// maxZlibBufSize is the max number of bytes that we'll accept from a\n\t// zlib decoding instance. We do this in order to limit the total\n\t// amount of memory allocated during a decoding instance.\n\tmaxZlibBufSize = 67413630\n)\n\n// ErrUnsortedSIDs is returned when decoding a QueryShortChannelID request whose\n// items were not sorted.",
      "length": 716,
      "tokens": 116,
      "embedding": []
    },
    {
      "slug": "type ErrUnsortedSIDs struct {",
      "content": "type ErrUnsortedSIDs struct {\n\tprevSID ShortChannelID\n\tcurSID  ShortChannelID\n}\n\n// Error returns a human-readable description of the error.",
      "length": 106,
      "tokens": 14,
      "embedding": []
    },
    {
      "slug": "func (e ErrUnsortedSIDs) Error() string {",
      "content": "func (e ErrUnsortedSIDs) Error() string {\n\treturn fmt.Sprintf(\"current sid: %v isn't greater than last sid: %v\",\n\t\te.curSID, e.prevSID)\n}\n\n// zlibDecodeMtx is a package level mutex that we'll use in order to ensure\n// that we'll only attempt a single zlib decoding instance at a time. This\n// allows us to also further bound our memory usage.\nvar zlibDecodeMtx sync.Mutex\n\n// ErrUnknownShortChanIDEncoding is a parametrized error that indicates that we\n// came across an unknown short channel ID encoding, and therefore were unable\n// to continue parsing.",
      "length": 502,
      "tokens": 81,
      "embedding": []
    },
    {
      "slug": "func ErrUnknownShortChanIDEncoding(encoding ShortChanIDEncoding) error {",
      "content": "func ErrUnknownShortChanIDEncoding(encoding ShortChanIDEncoding) error {\n\treturn fmt.Errorf(\"unknown short chan id encoding: %v\", encoding)\n}\n\n// QueryShortChanIDs is a message that allows the sender to query a set of\n// channel announcement and channel update messages that correspond to the set\n// of encoded short channel ID's. The encoding of the short channel ID's is\n// detailed in the query message ensuring that the receiver knows how to\n// properly decode each encode short channel ID which may be encoded using a\n// compression format. The receiver should respond with a series of channel\n// announcement and channel updates, finally sending a ReplyShortChanIDsEnd\n// message.",
      "length": 603,
      "tokens": 99,
      "embedding": []
    },
    {
      "slug": "type QueryShortChanIDs struct {",
      "content": "type QueryShortChanIDs struct {\n\t// ChainHash denotes the target chain that we're querying for the\n\t// channel ID's of.\n\tChainHash chainhash.Hash\n\n\t// EncodingType is a signal to the receiver of the message that\n\t// indicates exactly how the set of short channel ID's that follow have\n\t// been encoded.\n\tEncodingType ShortChanIDEncoding\n\n\t// ShortChanIDs is a slice of decoded short channel ID's.\n\tShortChanIDs []ShortChannelID\n\n\t// ExtraData is the set of data that was appended to this message to\n\t// fill out the full maximum transport message size. These fields can\n\t// be used to specify optional data such as custom TLV fields.\n\tExtraData ExtraOpaqueData\n\n\t// noSort indicates whether or not to sort the short channel ids before\n\t// writing them out.\n\t//\n\t// NOTE: This should only be used during testing.\n\tnoSort bool\n}\n\n// NewQueryShortChanIDs creates a new QueryShortChanIDs message.",
      "length": 836,
      "tokens": 136,
      "embedding": []
    },
    {
      "slug": "func NewQueryShortChanIDs(h chainhash.Hash, e ShortChanIDEncoding,",
      "content": "func NewQueryShortChanIDs(h chainhash.Hash, e ShortChanIDEncoding,\n\ts []ShortChannelID) *QueryShortChanIDs {\n\n\treturn &QueryShortChanIDs{\n\t\tChainHash:    h,\n\t\tEncodingType: e,\n\t\tShortChanIDs: s,\n\t}\n}\n\n// A compile time check to ensure QueryShortChanIDs implements the\n// lnwire.Message interface.\nvar _ Message = (*QueryShortChanIDs)(nil)\n\n// Decode deserializes a serialized QueryShortChanIDs message stored in the\n// passed io.Reader observing the specified protocol version.\n//\n// This is part of the lnwire.Message interface.",
      "length": 446,
      "tokens": 59,
      "embedding": []
    },
    {
      "slug": "func (q *QueryShortChanIDs) Decode(r io.Reader, pver uint32) error {",
      "content": "func (q *QueryShortChanIDs) Decode(r io.Reader, pver uint32) error {\n\terr := ReadElements(r, q.ChainHash[:])\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tq.EncodingType, q.ShortChanIDs, err = decodeShortChanIDs(r)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn q.ExtraData.Decode(r)\n}\n\n// decodeShortChanIDs decodes a set of short channel ID's that have been\n// encoded. The first byte of the body details how the short chan ID's were\n// encoded. We'll use this type to govern exactly how we go about encoding the\n// set of short channel ID's.",
      "length": 443,
      "tokens": 76,
      "embedding": []
    },
    {
      "slug": "func decodeShortChanIDs(r io.Reader) (ShortChanIDEncoding, []ShortChannelID, error) {",
      "content": "func decodeShortChanIDs(r io.Reader) (ShortChanIDEncoding, []ShortChannelID, error) {\n\t// First, we'll attempt to read the number of bytes in the body of the\n\t// set of encoded short channel ID's.\n\tvar numBytesResp uint16\n\terr := ReadElements(r, &numBytesResp)\n\tif err != nil {\n\t\treturn 0, nil, err\n\t}\n\n\tif numBytesResp == 0 {\n\t\treturn 0, nil, nil\n\t}\n\n\tqueryBody := make([]byte, numBytesResp)\n\tif _, err := io.ReadFull(r, queryBody); err != nil {\n\t\treturn 0, nil, err\n\t}\n\n\t// The first byte is the encoding type, so we'll extract that so we can\n\t// continue our parsing.\n\tencodingType := ShortChanIDEncoding(queryBody[0])\n\n\t// Before continuing, we'll snip off the first byte of the query body\n\t// as that was just the encoding type.\n\tqueryBody = queryBody[1:]\n\n\t// Otherwise, depending on the encoding type, we'll decode the encode\n\t// short channel ID's in a different manner.\n\tswitch encodingType {\n\n\t// In this encoding, we'll simply read a sort array of encoded short\n\t// channel ID's from the buffer.\n\tcase EncodingSortedPlain:\n\t\t// If after extracting the encoding type, the number of\n\t\t// remaining bytes is not a whole multiple of the size of an\n\t\t// encoded short channel ID (8 bytes), then we'll return a\n\t\t// parsing error.\n\t\tif len(queryBody)%8 != 0 {\n\t\t\treturn 0, nil, fmt.Errorf(\"whole number of short \"+\n\t\t\t\t\"chan ID's cannot be encoded in len=%v\",\n\t\t\t\tlen(queryBody))\n\t\t}\n\n\t\t// As each short channel ID is encoded as 8 bytes, we can\n\t\t// compute the number of bytes encoded based on the size of the\n\t\t// query body.\n\t\tnumShortChanIDs := len(queryBody) / 8\n\t\tif numShortChanIDs == 0 {\n\t\t\treturn encodingType, nil, nil\n\t\t}\n\n\t\t// Finally, we'll read out the exact number of short channel\n\t\t// ID's to conclude our parsing.\n\t\tshortChanIDs := make([]ShortChannelID, numShortChanIDs)\n\t\tbodyReader := bytes.NewReader(queryBody)\n\t\tvar lastChanID ShortChannelID\n\t\tfor i := 0; i < numShortChanIDs; i++ {\n\t\t\tif err := ReadElements(bodyReader, &shortChanIDs[i]); err != nil {\n\t\t\t\treturn 0, nil, fmt.Errorf(\"unable to parse \"+\n\t\t\t\t\t\"short chan ID: %v\", err)\n\t\t\t}\n\n\t\t\t// We'll ensure that this short chan ID is greater than\n\t\t\t// the last one. This is a requirement within the\n\t\t\t// encoding, and if violated can aide us in detecting\n\t\t\t// malicious payloads. This can only be true starting\n\t\t\t// at the second chanID.\n\t\t\tcid := shortChanIDs[i]\n\t\t\tif i > 0 && cid.ToUint64() <= lastChanID.ToUint64() {\n\t\t\t\treturn 0, nil, ErrUnsortedSIDs{lastChanID, cid}\n\t\t\t}\n\t\t\tlastChanID = cid\n\t\t}\n\n\t\treturn encodingType, shortChanIDs, nil\n\n\t// In this encoding, we'll use zlib to decode the compressed payload.\n\t// However, we'll pay attention to ensure that we don't open our selves\n\t// up to a memory exhaustion attack.\n\tcase EncodingSortedZlib:\n\t\t// We'll obtain an ultimately release the zlib decode mutex.\n\t\t// This guards us against allocating too much memory to decode\n\t\t// each instance from concurrent peers.\n\t\tzlibDecodeMtx.Lock()\n\t\tdefer zlibDecodeMtx.Unlock()\n\n\t\t// At this point, if there's no body remaining, then only the encoding\n\t\t// type was specified, meaning that there're no further bytes to be\n\t\t// parsed.\n\t\tif len(queryBody) == 0 {\n\t\t\treturn encodingType, nil, nil\n\t\t}\n\n\t\t// Before we start to decode, we'll create a limit reader over\n\t\t// the current reader. This will ensure that we can control how\n\t\t// much memory we're allocating during the decoding process.\n\t\tlimitedDecompressor, err := zlib.NewReader(&io.LimitedReader{\n\t\t\tR: bytes.NewReader(queryBody),\n\t\t\tN: maxZlibBufSize,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn 0, nil, fmt.Errorf(\"unable to create zlib reader: %v\", err)\n\t\t}\n\n\t\tvar (\n\t\t\tshortChanIDs []ShortChannelID\n\t\t\tlastChanID   ShortChannelID\n\t\t\ti            int\n\t\t)\n\t\tfor {\n\t\t\t// We'll now attempt to read the next short channel ID\n\t\t\t// encoded in the payload.\n\t\t\tvar cid ShortChannelID\n\t\t\terr := ReadElements(limitedDecompressor, &cid)\n\n\t\t\tswitch {\n\t\t\t// If we get an EOF error, then that either means we've\n\t\t\t// read all that's contained in the buffer, or have hit\n\t\t\t// our limit on the number of bytes we'll read. In\n\t\t\t// either case, we'll return what we have so far.\n\t\t\tcase err == io.ErrUnexpectedEOF || err == io.EOF:\n\t\t\t\treturn encodingType, shortChanIDs, nil\n\n\t\t\t// Otherwise, we hit some other sort of error, possibly\n\t\t\t// an invalid payload, so we'll exit early with the\n\t\t\t// error.\n\t\t\tcase err != nil:\n\t\t\t\treturn 0, nil, fmt.Errorf(\"unable to \"+\n\t\t\t\t\t\"deflate next short chan \"+\n\t\t\t\t\t\"ID: %v\", err)\n\t\t\t}\n\n\t\t\t// We successfully read the next ID, so we'll collect\n\t\t\t// that in the set of final ID's to return.\n\t\t\tshortChanIDs = append(shortChanIDs, cid)\n\n\t\t\t// Finally, we'll ensure that this short chan ID is\n\t\t\t// greater than the last one. This is a requirement\n\t\t\t// within the encoding, and if violated can aide us in\n\t\t\t// detecting malicious payloads. This can only be true\n\t\t\t// starting at the second chanID.\n\t\t\tif i > 0 && cid.ToUint64() <= lastChanID.ToUint64() {\n\t\t\t\treturn 0, nil, ErrUnsortedSIDs{lastChanID, cid}\n\t\t\t}\n\n\t\t\tlastChanID = cid\n\t\t\ti++\n\t\t}\n\n\tdefault:\n\t\t// If we've been sent an encoding type that we don't know of,\n\t\t// then we'll return a parsing error as we can't continue if\n\t\t// we're unable to encode them.\n\t\treturn 0, nil, ErrUnknownShortChanIDEncoding(encodingType)\n\t}\n}\n\n// Encode serializes the target QueryShortChanIDs into the passed io.Writer\n// observing the protocol version specified.\n//\n// This is part of the lnwire.Message interface.",
      "length": 5172,
      "tokens": 834,
      "embedding": []
    },
    {
      "slug": "func (q *QueryShortChanIDs) Encode(w *bytes.Buffer, pver uint32) error {",
      "content": "func (q *QueryShortChanIDs) Encode(w *bytes.Buffer, pver uint32) error {\n\t// First, we'll write out the chain hash.\n\tif err := WriteBytes(w, q.ChainHash[:]); err != nil {\n\t\treturn err\n\t}\n\n\t// Base on our encoding type, we'll write out the set of short channel\n\t// ID's.\n\terr := encodeShortChanIDs(w, q.EncodingType, q.ShortChanIDs, q.noSort)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn WriteBytes(w, q.ExtraData)\n}\n\n// encodeShortChanIDs encodes the passed short channel ID's into the passed\n// io.Writer, respecting the specified encoding type.",
      "length": 454,
      "tokens": 72,
      "embedding": []
    },
    {
      "slug": "func encodeShortChanIDs(w *bytes.Buffer, encodingType ShortChanIDEncoding,",
      "content": "func encodeShortChanIDs(w *bytes.Buffer, encodingType ShortChanIDEncoding,\n\tshortChanIDs []ShortChannelID, noSort bool) error {\n\n\t// For both of the current encoding types, the channel ID's are to be\n\t// sorted in place, so we'll do that now. The sorting is applied unless\n\t// we were specifically requested not to for testing purposes.\n\tif !noSort {\n\t\tsort.Slice(shortChanIDs, func(i, j int) bool {\n\t\t\treturn shortChanIDs[i].ToUint64() <\n\t\t\t\tshortChanIDs[j].ToUint64()\n\t\t})\n\t}\n\n\tswitch encodingType {\n\n\t// In this encoding, we'll simply write a sorted array of encoded short\n\t// channel ID's from the buffer.\n\tcase EncodingSortedPlain:\n\t\t// First, we'll write out the number of bytes of the query\n\t\t// body. We add 1 as the response will have the encoding type\n\t\t// prepended to it.\n\t\tnumBytesBody := uint16(len(shortChanIDs)*8) + 1\n\t\tif err := WriteUint16(w, numBytesBody); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// We'll then write out the encoding that that follows the\n\t\t// actual encoded short channel ID's.\n\t\terr := WriteShortChanIDEncoding(w, encodingType)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Now that we know they're sorted, we can write out each short\n\t\t// channel ID to the buffer.\n\t\tfor _, chanID := range shortChanIDs {\n\t\t\tif err := WriteShortChannelID(w, chanID); err != nil {\n\t\t\t\treturn fmt.Errorf(\"unable to write short chan \"+\n\t\t\t\t\t\"ID: %v\", err)\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\n\t// For this encoding we'll first write out a serialized version of all\n\t// the channel ID's into a buffer, then zlib encode that. The final\n\t// payload is what we'll write out to the passed io.Writer.\n\t//\n\t// TODO(roasbeef): assumes the caller knows the proper chunk size to\n\t// pass to avoid bin-packing here\n\tcase EncodingSortedZlib:\n\t\t// If we don't have anything at all to write, then we'll write\n\t\t// an empty payload so we don't include things like the zlib\n\t\t// header when the remote party is expecting no actual short\n\t\t// channel IDs.\n\t\tvar compressedPayload []byte\n\t\tif len(shortChanIDs) > 0 {\n\t\t\t// We'll make a new write buffer to hold the bytes of\n\t\t\t// shortChanIDs.\n\t\t\tvar wb bytes.Buffer\n\n\t\t\t// Next, we'll write out all the channel ID's directly\n\t\t\t// into the zlib writer, which will do compressing on\n\t\t\t// the fly.\n\t\t\tfor _, chanID := range shortChanIDs {\n\t\t\t\terr := WriteShortChannelID(&wb, chanID)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\n\t\t\t\t\t\t\"unable to write short chan \"+\n\t\t\t\t\t\t\t\"ID: %v\", err,\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// With shortChanIDs written into wb, we'll create a\n\t\t\t// zlib writer and write all the compressed bytes.\n\t\t\tvar zlibBuffer bytes.Buffer\n\t\t\tzlibWriter := zlib.NewWriter(&zlibBuffer)\n\n\t\t\tif _, err := zlibWriter.Write(wb.Bytes()); err != nil {\n\t\t\t\treturn fmt.Errorf(\n\t\t\t\t\t\"unable to write compressed short chan\"+\n\t\t\t\t\t\t\"ID: %w\", err)\n\t\t\t}\n\n\t\t\t// Now that we've written all the elements, we'll\n\t\t\t// ensure the compressed stream is written to the\n\t\t\t// underlying buffer.\n\t\t\tif err := zlibWriter.Close(); err != nil {\n\t\t\t\treturn fmt.Errorf(\"unable to finalize \"+\n\t\t\t\t\t\"compression: %v\", err)\n\t\t\t}\n\n\t\t\tcompressedPayload = zlibBuffer.Bytes()\n\t\t}\n\n\t\t// Now that we have all the items compressed, we can compute\n\t\t// what the total payload size will be. We add one to account\n\t\t// for the byte to encode the type.\n\t\t//\n\t\t// If we don't have any actual bytes to write, then we'll end\n\t\t// up emitting one byte for the length, followed by the\n\t\t// encoding type, and nothing more. The spec isn't 100% clear\n\t\t// in this area, but we do this as this is what most of the\n\t\t// other implementations do.\n\t\tnumBytesBody := len(compressedPayload) + 1\n\n\t\t// Finally, we can write out the number of bytes, the\n\t\t// compression type, and finally the buffer itself.\n\t\tif err := WriteUint16(w, uint16(numBytesBody)); err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr := WriteShortChanIDEncoding(w, encodingType)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn WriteBytes(w, compressedPayload)\n\n\tdefault:\n\t\t// If we're trying to encode with an encoding type that we\n\t\t// don't know of, then we'll return a parsing error as we can't\n\t\t// continue if we're unable to encode them.\n\t\treturn ErrUnknownShortChanIDEncoding(encodingType)\n\t}\n}\n\n// MsgType returns the integer uniquely identifying this message type on the\n// wire.\n//\n// This is part of the lnwire.Message interface.",
      "length": 4071,
      "tokens": 668,
      "embedding": []
    },
    {
      "slug": "func (q *QueryShortChanIDs) MsgType() MessageType {",
      "content": "func (q *QueryShortChanIDs) MsgType() MessageType {\n\treturn MsgQueryShortChanIDs\n}\n",
      "length": 29,
      "tokens": 3,
      "embedding": []
    }
  ]
}