{
  "filepath": "../implementations/go/lnd/lnwire/message_test.go",
  "package": "lnwire_test",
  "sections": [
    {
      "slug": "type mockMsg struct {",
      "content": "type mockMsg struct {\n\tmock.Mock\n}\n",
      "length": 11,
      "tokens": 2,
      "embedding": []
    },
    {
      "slug": "func (m *mockMsg) Decode(r io.Reader, pver uint32) error {",
      "content": "func (m *mockMsg) Decode(r io.Reader, pver uint32) error {\n\targs := m.Called(r, pver)\n\treturn args.Error(0)\n}\n",
      "length": 48,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "func (m *mockMsg) Encode(w *bytes.Buffer, pver uint32) error {",
      "content": "func (m *mockMsg) Encode(w *bytes.Buffer, pver uint32) error {\n\targs := m.Called(w, pver)\n\treturn args.Error(0)\n}\n",
      "length": 48,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "func (m *mockMsg) MsgType() lnwire.MessageType {",
      "content": "func (m *mockMsg) MsgType() lnwire.MessageType {\n\targs := m.Called()\n\treturn lnwire.MessageType(args.Int(0))\n}\n\n// A compile time check to ensure mockMsg implements the lnwire.Message\n// interface.\nvar _ lnwire.Message = (*mockMsg)(nil)\n\n// TestWriteMessage tests the function lnwire.WriteMessage.",
      "length": 240,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func TestWriteMessage(t *testing.T) {",
      "content": "func TestWriteMessage(t *testing.T) {\n\tvar (\n\t\tbuf = new(bytes.Buffer)\n\n\t\t// encodeNormalSize specifies a message size that is normal.\n\t\tencodeNormalSize = 1000\n\n\t\t// encodeOversize specifies a message size that's too big.\n\t\tencodeOversize = lnwire.MaxMsgBody + 1\n\n\t\t// errDummy is returned by the msg.Encode when specified.\n\t\terrDummy = errors.New(\"test error\")\n\n\t\t// oneByte is a dummy byte used to fill up the buffer.\n\t\toneByte = [1]byte{}\n\t)\n\n\ttestCases := []struct {\n\t\tname string\n\n\t\t// encodeSize controls how many bytes are written to the buffer\n\t\t// by the method msg.Encode(buf, pver).\n\t\tencodeSize int\n\n\t\t// encodeErr determines the return value of the method\n\t\t// msg.Encode(buf, pver).\n\t\tencodeErr error\n\n\t\terrorExpected error\n\t}{\n\n\t\t{\n\t\t\tname:          \"successful write\",\n\t\t\tencodeSize:    encodeNormalSize,\n\t\t\tencodeErr:     nil,\n\t\t\terrorExpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:          \"failed to encode payload\",\n\t\t\tencodeSize:    encodeNormalSize,\n\t\t\tencodeErr:     errDummy,\n\t\t\terrorExpected: lnwire.ErrorEncodeMessage(errDummy),\n\t\t},\n\t\t{\n\t\t\tname:       \"exceeds MaxMsgBody\",\n\t\t\tencodeSize: encodeOversize,\n\t\t\tencodeErr:  nil,\n\t\t\terrorExpected: lnwire.ErrorPayloadTooLarge(\n\t\t\t\tencodeOversize,\n\t\t\t),\n\t\t},\n\t}\n\n\tfor _, test := range testCases {\n\t\ttc := test\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Start the test by creating a mock message and patch\n\t\t\t// the relevant methods.\n\t\t\tmsg := &mockMsg{}\n\n\t\t\t// Use message type Ping here since all types are\n\t\t\t// encoded using 2 bytes, it won't affect anything\n\t\t\t// here.\n\t\t\tmsg.On(\"MsgType\").Return(lnwire.MsgPing)\n\n\t\t\t// Encode will return the specified error (could be\n\t\t\t// nil) and has the side effect of filling up the\n\t\t\t// buffer by repeating the oneByte encodeSize times.\n\t\t\tmsg.On(\"Encode\", mock.Anything, mock.Anything).Return(\n\t\t\t\ttc.encodeErr,\n\t\t\t).Run(func(_ mock.Arguments) {\n\t\t\t\tfor i := 0; i < tc.encodeSize; i++ {\n\t\t\t\t\t_, err := buf.Write(oneByte[:])\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t}\n\t\t\t})\n\n\t\t\t// Record the initial state of the buffer and write the\n\t\t\t// message.\n\t\t\toldBytesSize := buf.Len()\n\t\t\tbytesWritten, err := lnwire.WriteMessage(\n\t\t\t\tbuf, msg, 1,\n\t\t\t)\n\n\t\t\t// Check that the returned error is expected.\n\t\t\trequire.Equal(\n\t\t\t\tt, tc.errorExpected, err, \"unexpected err\",\n\t\t\t)\n\n\t\t\t// If there's an error, no bytes should be written to\n\t\t\t// the buf.\n\t\t\tif tc.errorExpected != nil {\n\t\t\t\trequire.Equal(\n\t\t\t\t\tt, 0, bytesWritten,\n\t\t\t\t\t\"bytes written should be 0\",\n\t\t\t\t)\n\n\t\t\t\t// We also check that the old buf was not\n\t\t\t\t// affected.\n\t\t\t\trequire.Equal(\n\t\t\t\t\tt, oldBytesSize, buf.Len(),\n\t\t\t\t\t\"original buffer should not change\",\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\texpected := buf.Len() - oldBytesSize\n\t\t\t\trequire.Equal(\n\t\t\t\t\tt, expected, bytesWritten,\n\t\t\t\t\t\"bytes written not matched\",\n\t\t\t\t)\n\t\t\t}\n\n\t\t\t// Finally, check the mocked methods are called as\n\t\t\t// expected.\n\t\t\tmsg.AssertExpectations(t)\n\t\t})\n\t}\n}\n\n// BenchmarkWriteMessage benchmarks the performance of lnwire.WriteMessage. It\n// generates a test message for each of the lnwire.Message, calls the\n// WriteMessage method and benchmark it.",
      "length": 2908,
      "tokens": 395,
      "embedding": []
    },
    {
      "slug": "func BenchmarkWriteMessage(b *testing.B) {",
      "content": "func BenchmarkWriteMessage(b *testing.B) {\n\t// Create testing messages. We will use a constant seed to make sure\n\t// the benchmark uses the same data every time.\n\tr := rand.New(rand.NewSource(42))\n\n\tmsgAll := makeAllMessages(b, r)\n\n\t// Iterate all messages and write each once.\n\tfor _, msg := range msgAll {\n\t\tm := msg\n\t\t// Run each message as a sub benchmark test.\n\t\tb.Run(msg.MsgType().String(), func(b *testing.B) {\n\t\t\tb.ResetTimer()\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t// Fetch a buffer from the pool and reset it.\n\t\t\t\tbuf := bufPool.Get().(*bytes.Buffer)\n\t\t\t\tbuf.Reset()\n\n\t\t\t\t_, err := lnwire.WriteMessage(buf, m, 0)\n\t\t\t\trequire.NoError(b, err, \"unable to write msg\")\n\n\t\t\t\t// Put the buffer back when done.\n\t\t\t\tbufPool.Put(buf)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// BenchmarkReadMessage benchmarks the performance of lnwire.ReadMessage. It\n// first creates a test message for each of the lnwire.Message, writes it to\n// the buffer, then later reads it from the buffer.",
      "length": 880,
      "tokens": 140,
      "embedding": []
    },
    {
      "slug": "func BenchmarkReadMessage(b *testing.B) {",
      "content": "func BenchmarkReadMessage(b *testing.B) {\n\t// Create testing messages. We will use a constant seed to make sure\n\t// the benchmark uses the same data every time.\n\tr := rand.New(rand.NewSource(42))\n\tmsgAll := makeAllMessages(b, r)\n\n\t// Write all the messages to the buffer.\n\tfor _, msg := range msgAll {\n\t\t// Fetch a buffer from the pool and reset it.\n\t\tbuf := bufPool.Get().(*bytes.Buffer)\n\t\tbuf.Reset()\n\n\t\t_, err := lnwire.WriteMessage(buf, msg, 0)\n\t\trequire.NoError(b, err, \"unable to write msg\")\n\n\t\t// Run each message as a sub benchmark test.\n\t\tm := msg\n\t\tb.Run(m.MsgType().String(), func(b *testing.B) {\n\t\t\tb.ResetTimer()\n\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\tr := bytes.NewBuffer(buf.Bytes())\n\n\t\t\t\t// Read the message from the buffer.\n\t\t\t\t_, err := lnwire.ReadMessage(r, 0)\n\t\t\t\trequire.NoError(b, err, \"unable to read msg\")\n\t\t\t}\n\t\t})\n\n\t\t// Put the buffer back when done.\n\t\tbufPool.Put(buf)\n\t}\n}\n\n// makeAllMessages is used to create testing messages for each lnwire message\n// type.\n//\n// TODO(yy): the following testing messages are created somewhat arbitrary. We\n// should standardlize each of the testing messages so that a better baseline\n// can be used.",
      "length": 1080,
      "tokens": 172,
      "embedding": []
    },
    {
      "slug": "func makeAllMessages(t testing.TB, r *rand.Rand) []lnwire.Message {",
      "content": "func makeAllMessages(t testing.TB, r *rand.Rand) []lnwire.Message {\n\tmsgAll := []lnwire.Message{}\n\n\tmsgAll = append(msgAll, newMsgWarning(t, r))\n\tmsgAll = append(msgAll, newMsgInit(t, r))\n\tmsgAll = append(msgAll, newMsgError(t, r))\n\tmsgAll = append(msgAll, newMsgPing(t, r))\n\tmsgAll = append(msgAll, newMsgPong(t, r))\n\tmsgAll = append(msgAll, newMsgOpenChannel(t, r))\n\tmsgAll = append(msgAll, newMsgAcceptChannel(t, r))\n\tmsgAll = append(msgAll, newMsgFundingCreated(t, r))\n\tmsgAll = append(msgAll, newMsgFundingSigned(t, r))\n\tmsgAll = append(msgAll, newMsgFundingLocked(t, r))\n\tmsgAll = append(msgAll, newMsgShutdown(t, r))\n\tmsgAll = append(msgAll, newMsgClosingSigned(t, r))\n\tmsgAll = append(msgAll, newMsgUpdateAddHTLC(t, r))\n\tmsgAll = append(msgAll, newMsgUpdateFulfillHTLC(t, r))\n\tmsgAll = append(msgAll, newMsgUpdateFailHTLC(t, r))\n\tmsgAll = append(msgAll, newMsgCommitSig(t, r))\n\tmsgAll = append(msgAll, newMsgRevokeAndAck(t, r))\n\tmsgAll = append(msgAll, newMsgUpdateFee(t, r))\n\tmsgAll = append(msgAll, newMsgUpdateFailMalformedHTLC(t, r))\n\tmsgAll = append(msgAll, newMsgChannelReestablish(t, r))\n\tmsgAll = append(msgAll, newMsgChannelAnnouncement(t, r))\n\tmsgAll = append(msgAll, newMsgNodeAnnouncement(t, r))\n\tmsgAll = append(msgAll, newMsgChannelUpdate(t, r))\n\tmsgAll = append(msgAll, newMsgAnnounceSignatures(t, r))\n\tmsgAll = append(msgAll, newMsgQueryShortChanIDs(t, r))\n\tmsgAll = append(msgAll, newMsgReplyShortChanIDsEnd(t, r))\n\tmsgAll = append(msgAll, newMsgQueryChannelRange(t, r))\n\tmsgAll = append(msgAll, newMsgReplyChannelRange(t, r))\n\tmsgAll = append(msgAll, newMsgGossipTimestampRange(t, r))\n\tmsgAll = append(msgAll, newMsgQueryShortChanIDsZlib(t, r))\n\tmsgAll = append(msgAll, newMsgReplyChannelRangeZlib(t, r))\n\n\treturn msgAll\n}\n",
      "length": 1645,
      "tokens": 161,
      "embedding": []
    },
    {
      "slug": "func newMsgWarning(tb testing.TB, r io.Reader) *lnwire.Warning {",
      "content": "func newMsgWarning(tb testing.TB, r io.Reader) *lnwire.Warning {\n\ttb.Helper()\n\n\tmsg := lnwire.NewWarning()\n\n\t_, err := r.Read(msg.ChanID[:])\n\trequire.NoError(tb, err, \"unable to generate chan id\")\n\n\tmsg.Data = createExtraData(tb, r)\n\n\treturn msg\n}\n",
      "length": 172,
      "tokens": 22,
      "embedding": []
    },
    {
      "slug": "func newMsgInit(t testing.TB, r io.Reader) *lnwire.Init {",
      "content": "func newMsgInit(t testing.TB, r io.Reader) *lnwire.Init {\n\tt.Helper()\n\n\treturn &lnwire.Init{\n\t\tGlobalFeatures: rawFeatureVector(),\n\t\tFeatures:       rawFeatureVector(),\n\t\tExtraData:      createExtraData(t, r),\n\t}\n}\n\n// newMsgOpenChannel creates a testing OpenChannel message.",
      "length": 208,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func newMsgOpenChannel(t testing.TB, r *rand.Rand) *lnwire.OpenChannel {",
      "content": "func newMsgOpenChannel(t testing.TB, r *rand.Rand) *lnwire.OpenChannel {\n\tt.Helper()\n\n\tmsg := &lnwire.OpenChannel{\n\t\tFundingAmount:        btcutil.Amount(r.Int63()),\n\t\tPushAmount:           lnwire.MilliSatoshi(r.Int63()),\n\t\tDustLimit:            btcutil.Amount(r.Int63()),\n\t\tMaxValueInFlight:     lnwire.MilliSatoshi(r.Int63()),\n\t\tChannelReserve:       btcutil.Amount(r.Int63()),\n\t\tHtlcMinimum:          lnwire.MilliSatoshi(r.Int63()),\n\t\tFeePerKiloWeight:     uint32(r.Int31()),\n\t\tCsvDelay:             uint16(r.Intn(1 << 16)),\n\t\tMaxAcceptedHTLCs:     uint16(r.Intn(1 << 16)),\n\t\tChannelFlags:         lnwire.FundingFlag(uint8(r.Intn(1 << 8))),\n\t\tFundingKey:           randPubKey(t),\n\t\tRevocationPoint:      randPubKey(t),\n\t\tPaymentPoint:         randPubKey(t),\n\t\tDelayedPaymentPoint:  randPubKey(t),\n\t\tHtlcPoint:            randPubKey(t),\n\t\tFirstCommitmentPoint: randPubKey(t),\n\t\tExtraData:            createExtraData(t, r),\n\t}\n\n\t_, err := r.Read(msg.ChainHash[:])\n\trequire.NoError(t, err, \"unable to read bytes for ChainHash\")\n\n\t_, err = r.Read(msg.PendingChannelID[:])\n\trequire.NoError(t, err, \"unable to read bytes for PendingChannelID\")\n\n\treturn msg\n}\n",
      "length": 1053,
      "tokens": 73,
      "embedding": []
    },
    {
      "slug": "func newMsgAcceptChannel(t testing.TB, r *rand.Rand) *lnwire.AcceptChannel {",
      "content": "func newMsgAcceptChannel(t testing.TB, r *rand.Rand) *lnwire.AcceptChannel {\n\tt.Helper()\n\n\tmsg := &lnwire.AcceptChannel{\n\t\tDustLimit:             btcutil.Amount(r.Int63()),\n\t\tMaxValueInFlight:      lnwire.MilliSatoshi(r.Int63()),\n\t\tChannelReserve:        btcutil.Amount(r.Int63()),\n\t\tMinAcceptDepth:        uint32(r.Int31()),\n\t\tHtlcMinimum:           lnwire.MilliSatoshi(r.Int63()),\n\t\tCsvDelay:              uint16(r.Intn(1 << 16)),\n\t\tMaxAcceptedHTLCs:      uint16(r.Intn(1 << 16)),\n\t\tFundingKey:            randPubKey(t),\n\t\tRevocationPoint:       randPubKey(t),\n\t\tPaymentPoint:          randPubKey(t),\n\t\tDelayedPaymentPoint:   randPubKey(t),\n\t\tHtlcPoint:             randPubKey(t),\n\t\tFirstCommitmentPoint:  randPubKey(t),\n\t\tUpfrontShutdownScript: randDeliveryAddress(t, r),\n\t\tExtraData:             createExtraData(t, r),\n\t}\n\t_, err := r.Read(msg.PendingChannelID[:])\n\trequire.NoError(t, err, \"unable to generate pending chan id\")\n\n\treturn msg\n}\n",
      "length": 846,
      "tokens": 56,
      "embedding": []
    },
    {
      "slug": "func newMsgError(t testing.TB, r io.Reader) *lnwire.Error {",
      "content": "func newMsgError(t testing.TB, r io.Reader) *lnwire.Error {\n\tt.Helper()\n\n\tmsg := lnwire.NewError()\n\n\t_, err := r.Read(msg.ChanID[:])\n\trequire.NoError(t, err, \"unable to generate chan id\")\n\n\tmsg.Data = createExtraData(t, r)\n\n\treturn msg\n}\n",
      "length": 167,
      "tokens": 22,
      "embedding": []
    },
    {
      "slug": "func newMsgPing(t testing.TB, r *rand.Rand) *lnwire.Ping {",
      "content": "func newMsgPing(t testing.TB, r *rand.Rand) *lnwire.Ping {\n\tt.Helper()\n\n\treturn &lnwire.Ping{\n\t\tNumPongBytes: uint16(r.Intn(1 << 16)),\n\t\tPaddingBytes: createExtraData(t, r),\n\t}\n}\n",
      "length": 113,
      "tokens": 12,
      "embedding": []
    },
    {
      "slug": "func newMsgPong(t testing.TB, r io.Reader) *lnwire.Pong {",
      "content": "func newMsgPong(t testing.TB, r io.Reader) *lnwire.Pong {\n\tt.Helper()\n\n\treturn &lnwire.Pong{\n\t\tPongBytes: createExtraData(t, r),\n\t}\n}\n",
      "length": 70,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func newMsgFundingCreated(t testing.TB, r *rand.Rand) *lnwire.FundingCreated {",
      "content": "func newMsgFundingCreated(t testing.TB, r *rand.Rand) *lnwire.FundingCreated {\n\tt.Helper()\n\n\tmsg := &lnwire.FundingCreated{\n\t\tCommitSig: testNodeSig,\n\t\tExtraData: createExtraData(t, r),\n\t}\n\n\t_, err := r.Read(msg.PendingChannelID[:])\n\trequire.NoError(t, err, \"unable to generate pending chan id\")\n\n\t_, err = r.Read(msg.FundingPoint.Hash[:])\n\trequire.NoError(t, err, \"unable to generate hash\")\n\n\tmsg.FundingPoint.Index = uint32(r.Int31()) % math.MaxUint16\n\n\treturn msg\n}\n",
      "length": 373,
      "tokens": 40,
      "embedding": []
    },
    {
      "slug": "func newMsgFundingSigned(t testing.TB, r io.Reader) *lnwire.FundingSigned {",
      "content": "func newMsgFundingSigned(t testing.TB, r io.Reader) *lnwire.FundingSigned {\n\tt.Helper()\n\n\tvar c [32]byte\n\n\t_, err := r.Read(c[:])\n\trequire.NoError(t, err, \"unable to generate chan id\")\n\n\tmsg := &lnwire.FundingSigned{\n\t\tChanID:    lnwire.ChannelID(c),\n\t\tCommitSig: testNodeSig,\n\t\tExtraData: createExtraData(t, r),\n\t}\n\n\treturn msg\n}\n",
      "length": 240,
      "tokens": 29,
      "embedding": []
    },
    {
      "slug": "func newMsgFundingLocked(t testing.TB, r io.Reader) *lnwire.FundingLocked {",
      "content": "func newMsgFundingLocked(t testing.TB, r io.Reader) *lnwire.FundingLocked {\n\tt.Helper()\n\n\tvar c [32]byte\n\n\t_, err := r.Read(c[:])\n\trequire.NoError(t, err, \"unable to generate chan id\")\n\n\tpubKey := randPubKey(t)\n\n\tmsg := lnwire.NewFundingLocked(lnwire.ChannelID(c), pubKey)\n\tmsg.ExtraData = createExtraData(t, r)\n\n\treturn msg\n}\n",
      "length": 237,
      "tokens": 29,
      "embedding": []
    },
    {
      "slug": "func newMsgShutdown(t testing.TB, r *rand.Rand) *lnwire.Shutdown {",
      "content": "func newMsgShutdown(t testing.TB, r *rand.Rand) *lnwire.Shutdown {\n\tt.Helper()\n\n\tmsg := &lnwire.Shutdown{\n\t\tAddress:   randDeliveryAddress(t, r),\n\t\tExtraData: createExtraData(t, r),\n\t}\n\n\t_, err := r.Read(msg.ChannelID[:])\n\trequire.NoError(t, err, \"unable to generate channel id\")\n\n\treturn msg\n}\n",
      "length": 216,
      "tokens": 25,
      "embedding": []
    },
    {
      "slug": "func newMsgClosingSigned(t testing.TB, r *rand.Rand) *lnwire.ClosingSigned {",
      "content": "func newMsgClosingSigned(t testing.TB, r *rand.Rand) *lnwire.ClosingSigned {\n\tt.Helper()\n\n\tmsg := &lnwire.ClosingSigned{\n\t\tFeeSatoshis: btcutil.Amount(r.Int63()),\n\t\tSignature:   testNodeSig,\n\t\tExtraData:   createExtraData(t, r),\n\t}\n\n\t_, err := r.Read(msg.ChannelID[:])\n\trequire.NoError(t, err, \"unable to generate chan id\")\n\n\treturn msg\n}\n",
      "length": 249,
      "tokens": 26,
      "embedding": []
    },
    {
      "slug": "func newMsgUpdateAddHTLC(t testing.TB, r *rand.Rand) *lnwire.UpdateAddHTLC {",
      "content": "func newMsgUpdateAddHTLC(t testing.TB, r *rand.Rand) *lnwire.UpdateAddHTLC {\n\tt.Helper()\n\n\tmsg := &lnwire.UpdateAddHTLC{\n\t\tID:        r.Uint64(),\n\t\tAmount:    lnwire.MilliSatoshi(r.Int63()),\n\t\tExpiry:    r.Uint32(),\n\t\tExtraData: createExtraData(t, r),\n\t}\n\n\t_, err := r.Read(msg.ChanID[:])\n\trequire.NoError(t, err, \"unable to generate chan id\")\n\n\t_, err = r.Read(msg.PaymentHash[:])\n\trequire.NoError(t, err, \"unable to generate paymenthash\")\n\n\t_, err = r.Read(msg.OnionBlob[:])\n\trequire.NoError(t, err, \"unable to generate onion blob\")\n\n\treturn msg\n}\n",
      "length": 453,
      "tokens": 49,
      "embedding": []
    },
    {
      "slug": "func newMsgUpdateFulfillHTLC(t testing.TB,",
      "content": "func newMsgUpdateFulfillHTLC(t testing.TB,\n\tr *rand.Rand) *lnwire.UpdateFulfillHTLC {\n\n\tt.Helper()\n\n\tmsg := &lnwire.UpdateFulfillHTLC{\n\t\tID:        r.Uint64(),\n\t\tExtraData: createExtraData(t, r),\n\t}\n\n\t_, err := r.Read(msg.ChanID[:])\n\trequire.NoError(t, err, \"unable to generate chan id\")\n\n\t_, err = r.Read(msg.PaymentPreimage[:])\n\trequire.NoError(t, err, \"unable to generate payment preimage\")\n\n\treturn msg\n}\n",
      "length": 349,
      "tokens": 39,
      "embedding": []
    },
    {
      "slug": "func newMsgUpdateFailHTLC(t testing.TB, r *rand.Rand) *lnwire.UpdateFailHTLC {",
      "content": "func newMsgUpdateFailHTLC(t testing.TB, r *rand.Rand) *lnwire.UpdateFailHTLC {\n\tt.Helper()\n\n\tmsg := &lnwire.UpdateFailHTLC{\n\t\tID:        r.Uint64(),\n\t\tExtraData: createExtraData(t, r),\n\t}\n\n\t_, err := r.Read(msg.ChanID[:])\n\trequire.NoError(t, err, \"unable to generate chan id\")\n\n\treturn msg\n}\n",
      "length": 201,
      "tokens": 24,
      "embedding": []
    },
    {
      "slug": "func newMsgCommitSig(t testing.TB, r io.Reader) *lnwire.CommitSig {",
      "content": "func newMsgCommitSig(t testing.TB, r io.Reader) *lnwire.CommitSig {\n\tt.Helper()\n\n\tmsg := lnwire.NewCommitSig()\n\n\t_, err := r.Read(msg.ChanID[:])\n\trequire.NoError(t, err, \"unable to generate chan id\")\n\n\tmsg.CommitSig = testNodeSig\n\tmsg.ExtraData = createExtraData(t, r)\n\n\tmsg.HtlcSigs = make([]lnwire.Sig, testNumSigs)\n\tfor i := 0; i < testNumSigs; i++ {\n\t\tmsg.HtlcSigs[i] = testNodeSig\n\t}\n\n\treturn msg\n}\n",
      "length": 319,
      "tokens": 42,
      "embedding": []
    },
    {
      "slug": "func newMsgRevokeAndAck(t testing.TB, r io.Reader) *lnwire.RevokeAndAck {",
      "content": "func newMsgRevokeAndAck(t testing.TB, r io.Reader) *lnwire.RevokeAndAck {\n\tt.Helper()\n\n\tmsg := lnwire.NewRevokeAndAck()\n\n\t_, err := r.Read(msg.ChanID[:])\n\trequire.NoError(t, err, \"unable to generate chan id\")\n\n\t_, err = r.Read(msg.Revocation[:])\n\trequire.NoError(t, err, \"unable to generate bytes\")\n\n\tmsg.NextRevocationKey = randPubKey(t)\n\trequire.NoError(t, err, \"unable to generate key\")\n\n\tmsg.ExtraData = createExtraData(t, r)\n\n\treturn msg\n}\n",
      "length": 354,
      "tokens": 41,
      "embedding": []
    },
    {
      "slug": "func newMsgUpdateFee(t testing.TB, r *rand.Rand) *lnwire.UpdateFee {",
      "content": "func newMsgUpdateFee(t testing.TB, r *rand.Rand) *lnwire.UpdateFee {\n\tt.Helper()\n\n\tmsg := &lnwire.UpdateFee{\n\t\tFeePerKw:  uint32(r.Int31()),\n\t\tExtraData: createExtraData(t, r),\n\t}\n\n\t_, err := r.Read(msg.ChanID[:])\n\trequire.NoError(t, err, \"unable to generate chan id\")\n\n\treturn msg\n}\n",
      "length": 203,
      "tokens": 24,
      "embedding": []
    },
    {
      "slug": "func newMsgUpdateFailMalformedHTLC(t testing.TB,",
      "content": "func newMsgUpdateFailMalformedHTLC(t testing.TB,\n\tr *rand.Rand) *lnwire.UpdateFailMalformedHTLC {\n\n\tt.Helper()\n\n\tmsg := &lnwire.UpdateFailMalformedHTLC{\n\t\tID:          r.Uint64(),\n\t\tFailureCode: lnwire.FailCode(r.Intn(1 << 16)),\n\t\tExtraData:   createExtraData(t, r),\n\t}\n\n\t_, err := r.Read(msg.ChanID[:])\n\trequire.NoError(t, err, \"unable to generate chan id\")\n\n\t_, err = r.Read(msg.ShaOnionBlob[:])\n\trequire.NoError(t, err, \"unable to generate sha256 onion blob\")\n\n\treturn msg\n}\n",
      "length": 411,
      "tokens": 44,
      "embedding": []
    },
    {
      "slug": "func newMsgChannelReestablish(t testing.TB,",
      "content": "func newMsgChannelReestablish(t testing.TB,\n\tr *rand.Rand) *lnwire.ChannelReestablish {\n\n\tt.Helper()\n\n\tmsg := &lnwire.ChannelReestablish{\n\t\tNextLocalCommitHeight:     uint64(r.Int63()),\n\t\tRemoteCommitTailHeight:    uint64(r.Int63()),\n\t\tLocalUnrevokedCommitPoint: randPubKey(t),\n\t\tExtraData:                 createExtraData(t, r),\n\t}\n\n\t_, err := r.Read(msg.LastRemoteCommitSecret[:])\n\trequire.NoError(t, err, \"unable to read commit secret\")\n\n\treturn msg\n}\n",
      "length": 395,
      "tokens": 32,
      "embedding": []
    },
    {
      "slug": "func newMsgChannelAnnouncement(t testing.TB,",
      "content": "func newMsgChannelAnnouncement(t testing.TB,\n\tr *rand.Rand) *lnwire.ChannelAnnouncement {\n\n\tt.Helper()\n\n\tmsg := &lnwire.ChannelAnnouncement{\n\t\tShortChannelID:  lnwire.NewShortChanIDFromInt(uint64(r.Int63())),\n\t\tFeatures:        rawFeatureVector(),\n\t\tNodeID1:         randRawKey(t),\n\t\tNodeID2:         randRawKey(t),\n\t\tBitcoinKey1:     randRawKey(t),\n\t\tBitcoinKey2:     randRawKey(t),\n\t\tExtraOpaqueData: createExtraData(t, r),\n\t\tNodeSig1:        testNodeSig,\n\t\tNodeSig2:        testNodeSig,\n\t\tBitcoinSig1:     testNodeSig,\n\t\tBitcoinSig2:     testNodeSig,\n\t}\n\n\t_, err := r.Read(msg.ChainHash[:])\n\trequire.NoError(t, err, \"unable to generate chain hash\")\n\n\treturn msg\n}\n",
      "length": 599,
      "tokens": 46,
      "embedding": []
    },
    {
      "slug": "func newMsgNodeAnnouncement(t testing.TB,",
      "content": "func newMsgNodeAnnouncement(t testing.TB,\n\tr *rand.Rand) *lnwire.NodeAnnouncement {\n\n\tt.Helper()\n\n\tmsg := &lnwire.NodeAnnouncement{\n\t\tFeatures:  rawFeatureVector(),\n\t\tTimestamp: uint32(r.Int31()),\n\t\tAlias:     randAlias(r),\n\t\tRGBColor: color.RGBA{\n\t\t\tR: uint8(r.Intn(1 << 8)),\n\t\t\tG: uint8(r.Intn(1 << 8)),\n\t\t\tB: uint8(r.Intn(1 << 8)),\n\t\t},\n\t\tNodeID:          randRawKey(t),\n\t\tAddresses:       randAddrs(t, r),\n\t\tExtraOpaqueData: createExtraData(t, r),\n\t\tSignature:       testNodeSig,\n\t}\n\n\treturn msg\n}\n",
      "length": 439,
      "tokens": 43,
      "embedding": []
    },
    {
      "slug": "func newMsgChannelUpdate(t testing.TB, r *rand.Rand) *lnwire.ChannelUpdate {",
      "content": "func newMsgChannelUpdate(t testing.TB, r *rand.Rand) *lnwire.ChannelUpdate {\n\tt.Helper()\n\n\tmsgFlags := lnwire.ChanUpdateMsgFlags(r.Int31())\n\tmaxHtlc := lnwire.MilliSatoshi(r.Int63())\n\n\t// We make the max_htlc field zero if it is not flagged\n\t// as being part of the ChannelUpdate, to pass\n\t// serialization tests, as it will be ignored if the bit\n\t// is not set.\n\tif msgFlags&lnwire.ChanUpdateRequiredMaxHtlc == 0 {\n\t\tmaxHtlc = 0\n\t}\n\n\tmsg := &lnwire.ChannelUpdate{\n\t\tShortChannelID:  lnwire.NewShortChanIDFromInt(r.Uint64()),\n\t\tTimestamp:       uint32(r.Int31()),\n\t\tMessageFlags:    msgFlags,\n\t\tChannelFlags:    lnwire.ChanUpdateChanFlags(r.Int31()),\n\t\tTimeLockDelta:   uint16(r.Int31()),\n\t\tHtlcMinimumMsat: lnwire.MilliSatoshi(r.Int63()),\n\t\tHtlcMaximumMsat: maxHtlc,\n\t\tBaseFee:         uint32(r.Int31()),\n\t\tFeeRate:         uint32(r.Int31()),\n\t\tExtraOpaqueData: createExtraData(t, r),\n\t\tSignature:       testNodeSig,\n\t}\n\n\t_, err := r.Read(msg.ChainHash[:])\n\trequire.NoError(t, err, \"unable to generate chain hash\")\n\n\treturn msg\n}\n",
      "length": 922,
      "tokens": 93,
      "embedding": []
    },
    {
      "slug": "func newMsgAnnounceSignatures(t testing.TB,",
      "content": "func newMsgAnnounceSignatures(t testing.TB,\n\tr *rand.Rand) *lnwire.AnnounceSignatures {\n\n\tt.Helper()\n\n\tmsg := &lnwire.AnnounceSignatures{\n\t\tShortChannelID: lnwire.NewShortChanIDFromInt(\n\t\t\tuint64(r.Int63()),\n\t\t),\n\t\tExtraOpaqueData:  createExtraData(t, r),\n\t\tNodeSignature:    testNodeSig,\n\t\tBitcoinSignature: testNodeSig,\n\t}\n\n\t_, err := r.Read(msg.ChannelID[:])\n\trequire.NoError(t, err, \"unable to generate chan id\")\n\n\treturn msg\n}\n",
      "length": 370,
      "tokens": 34,
      "embedding": []
    },
    {
      "slug": "func newMsgQueryShortChanIDs(t testing.TB,",
      "content": "func newMsgQueryShortChanIDs(t testing.TB,\n\tr *rand.Rand) *lnwire.QueryShortChanIDs {\n\n\tt.Helper()\n\n\tmsg := &lnwire.QueryShortChanIDs{\n\t\tEncodingType: lnwire.EncodingSortedPlain,\n\t\tExtraData:    createExtraData(t, r),\n\t}\n\n\t_, err := rand.Read(msg.ChainHash[:])\n\trequire.NoError(t, err, \"unable to read chain hash\")\n\n\tfor i := 0; i < testNumChanIDs; i++ {\n\t\tmsg.ShortChanIDs = append(msg.ShortChanIDs,\n\t\t\tlnwire.NewShortChanIDFromInt(uint64(r.Int63())))\n\t}\n\n\treturn msg\n}\n",
      "length": 409,
      "tokens": 42,
      "embedding": []
    },
    {
      "slug": "func newMsgQueryShortChanIDsZlib(t testing.TB,",
      "content": "func newMsgQueryShortChanIDsZlib(t testing.TB,\n\tr *rand.Rand) *lnwire.QueryShortChanIDs {\n\n\tt.Helper()\n\n\tmsg := &lnwire.QueryShortChanIDs{\n\t\tEncodingType: lnwire.EncodingSortedZlib,\n\t\tExtraData:    createExtraData(t, r),\n\t}\n\n\t_, err := rand.Read(msg.ChainHash[:])\n\trequire.NoError(t, err, \"unable to read chain hash\")\n\n\tfor i := 0; i < testNumChanIDs; i++ {\n\t\tmsg.ShortChanIDs = append(msg.ShortChanIDs,\n\t\t\tlnwire.NewShortChanIDFromInt(uint64(r.Int63())))\n\t}\n\n\treturn msg\n}\n",
      "length": 408,
      "tokens": 42,
      "embedding": []
    },
    {
      "slug": "func newMsgReplyShortChanIDsEnd(t testing.TB,",
      "content": "func newMsgReplyShortChanIDsEnd(t testing.TB,\n\tr *rand.Rand) *lnwire.ReplyShortChanIDsEnd {\n\n\tt.Helper()\n\n\tmsg := lnwire.NewReplyShortChanIDsEnd()\n\n\t_, err := rand.Read(msg.ChainHash[:])\n\trequire.NoError(t, err, \"unable to read chain hash\")\n\n\tmsg.Complete = uint8(r.Int31n(2))\n\tmsg.ExtraData = createExtraData(t, r)\n\n\treturn msg\n}\n",
      "length": 271,
      "tokens": 29,
      "embedding": []
    },
    {
      "slug": "func newMsgQueryChannelRange(t testing.TB,",
      "content": "func newMsgQueryChannelRange(t testing.TB,\n\tr *rand.Rand) *lnwire.QueryChannelRange {\n\n\tt.Helper()\n\n\tmsg := lnwire.NewQueryChannelRange()\n\n\t_, err := rand.Read(msg.ChainHash[:])\n\trequire.NoError(t, err, \"unable to read chain hash\")\n\n\tmsg.FirstBlockHeight = r.Uint32()\n\tmsg.NumBlocks = r.Uint32()\n\tmsg.ExtraData = createExtraData(t, r)\n\n\treturn msg\n}\n",
      "length": 292,
      "tokens": 32,
      "embedding": []
    },
    {
      "slug": "func newMsgReplyChannelRange(t testing.TB,",
      "content": "func newMsgReplyChannelRange(t testing.TB,\n\tr *rand.Rand) *lnwire.ReplyChannelRange {\n\n\tt.Helper()\n\n\tmsg := &lnwire.ReplyChannelRange{\n\t\tEncodingType: lnwire.EncodingSortedPlain,\n\t\tExtraData:    createExtraData(t, r),\n\t}\n\n\t_, err := rand.Read(msg.ChainHash[:])\n\trequire.NoError(t, err, \"unable to read chain hash\")\n\n\tmsg.Complete = uint8(r.Int31n(2))\n\n\tfor i := 0; i < testNumChanIDs; i++ {\n\t\tmsg.ShortChanIDs = append(msg.ShortChanIDs,\n\t\t\tlnwire.NewShortChanIDFromInt(uint64(r.Int63())))\n\t}\n\n\treturn msg\n}\n",
      "length": 443,
      "tokens": 45,
      "embedding": []
    },
    {
      "slug": "func newMsgReplyChannelRangeZlib(t testing.TB,",
      "content": "func newMsgReplyChannelRangeZlib(t testing.TB,\n\tr *rand.Rand) *lnwire.ReplyChannelRange {\n\n\tt.Helper()\n\n\tmsg := &lnwire.ReplyChannelRange{\n\t\tEncodingType: lnwire.EncodingSortedZlib,\n\t\tExtraData:    createExtraData(t, r),\n\t}\n\n\t_, err := rand.Read(msg.ChainHash[:])\n\trequire.NoError(t, err, \"unable to read chain hash\")\n\n\tmsg.Complete = uint8(r.Int31n(2))\n\n\tfor i := 0; i < testNumChanIDs; i++ {\n\t\tmsg.ShortChanIDs = append(msg.ShortChanIDs,\n\t\t\tlnwire.NewShortChanIDFromInt(uint64(r.Int63())))\n\t}\n\n\treturn msg\n}\n",
      "length": 442,
      "tokens": 45,
      "embedding": []
    },
    {
      "slug": "func newMsgGossipTimestampRange(t testing.TB,",
      "content": "func newMsgGossipTimestampRange(t testing.TB,\n\tr *rand.Rand) *lnwire.GossipTimestampRange {\n\n\tt.Helper()\n\n\tmsg := lnwire.NewGossipTimestampRange()\n\tmsg.FirstTimestamp = r.Uint32()\n\tmsg.TimestampRange = r.Uint32()\n\tmsg.ExtraData = createExtraData(t, r)\n\n\t_, err := r.Read(msg.ChainHash[:])\n\trequire.NoError(t, err, \"unable to read chain hash\")\n\n\treturn msg\n}\n",
      "length": 298,
      "tokens": 32,
      "embedding": []
    },
    {
      "slug": "func randRawKey(t testing.TB) [33]byte {",
      "content": "func randRawKey(t testing.TB) [33]byte {\n\tt.Helper()\n\n\tvar n [33]byte\n\n\tpriv, err := btcec.NewPrivateKey()\n\trequire.NoError(t, err, \"failed to create privKey\")\n\n\tcopy(n[:], priv.PubKey().SerializeCompressed())\n\n\treturn n\n}\n",
      "length": 171,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func randPubKey(t testing.TB) *btcec.PublicKey {",
      "content": "func randPubKey(t testing.TB) *btcec.PublicKey {\n\tt.Helper()\n\n\tpriv, err := btcec.NewPrivateKey()\n\trequire.NoError(t, err, \"failed to create pubkey\")\n\n\treturn priv.PubKey()\n}\n",
      "length": 119,
      "tokens": 14,
      "embedding": []
    },
    {
      "slug": "func rawFeatureVector() *lnwire.RawFeatureVector {",
      "content": "func rawFeatureVector() *lnwire.RawFeatureVector {\n\t// Get a slice of known feature bits.\n\tfeatureBits := make([]lnwire.FeatureBit, 0, len(lnwire.Features))\n\tfor fb := range lnwire.Features {\n\t\tfeatureBits = append(featureBits, fb)\n\t}\n\n\tfeatureVec := lnwire.NewRawFeatureVector(featureBits...)\n\n\treturn featureVec\n}\n",
      "length": 255,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func randDeliveryAddress(t testing.TB, r *rand.Rand) lnwire.DeliveryAddress {",
      "content": "func randDeliveryAddress(t testing.TB, r *rand.Rand) lnwire.DeliveryAddress {\n\tt.Helper()\n\n\t// Generate a max sized address.\n\tsize := r.Intn(deliveryAddressMaxSize) + 1\n\tda := lnwire.DeliveryAddress(make([]byte, size))\n\n\t_, err := r.Read(da)\n\trequire.NoError(t, err, \"unable to read address\")\n\treturn da\n}\n",
      "length": 218,
      "tokens": 29,
      "embedding": []
    },
    {
      "slug": "func randTCP4Addr(t testing.TB, r *rand.Rand) *net.TCPAddr {",
      "content": "func randTCP4Addr(t testing.TB, r *rand.Rand) *net.TCPAddr {\n\tt.Helper()\n\n\tvar ip [4]byte\n\t_, err := r.Read(ip[:])\n\trequire.NoError(t, err, \"unable to read ip\")\n\n\tvar port [2]byte\n\t_, err = r.Read(port[:])\n\trequire.NoError(t, err, \"unable to read port\")\n\n\taddrIP := net.IP(ip[:])\n\taddrPort := int(binary.BigEndian.Uint16(port[:]))\n\n\treturn &net.TCPAddr{IP: addrIP, Port: addrPort}\n}\n",
      "length": 307,
      "tokens": 39,
      "embedding": []
    },
    {
      "slug": "func randTCP6Addr(t testing.TB, r *rand.Rand) *net.TCPAddr {",
      "content": "func randTCP6Addr(t testing.TB, r *rand.Rand) *net.TCPAddr {\n\tt.Helper()\n\n\tvar ip [16]byte\n\n\t_, err := r.Read(ip[:])\n\trequire.NoError(t, err, \"unable to read ip\")\n\n\tvar port [2]byte\n\t_, err = r.Read(port[:])\n\trequire.NoError(t, err, \"unable to read port\")\n\n\taddrIP := net.IP(ip[:])\n\taddrPort := int(binary.BigEndian.Uint16(port[:]))\n\n\treturn &net.TCPAddr{IP: addrIP, Port: addrPort}\n}\n",
      "length": 308,
      "tokens": 39,
      "embedding": []
    },
    {
      "slug": "func randV2OnionAddr(t testing.TB, r *rand.Rand) *tor.OnionAddr {",
      "content": "func randV2OnionAddr(t testing.TB, r *rand.Rand) *tor.OnionAddr {\n\tt.Helper()\n\n\tvar serviceID [tor.V2DecodedLen]byte\n\t_, err := r.Read(serviceID[:])\n\trequire.NoError(t, err, \"unable to read serviceID\")\n\n\tvar port [2]byte\n\t_, err = r.Read(port[:])\n\trequire.NoError(t, err, \"unable to read port\")\n\n\tonionService := tor.Base32Encoding.EncodeToString(serviceID[:])\n\tonionService += tor.OnionSuffix\n\taddrPort := int(binary.BigEndian.Uint16(port[:]))\n\n\treturn &tor.OnionAddr{OnionService: onionService, Port: addrPort}\n}\n",
      "length": 433,
      "tokens": 42,
      "embedding": []
    },
    {
      "slug": "func randV3OnionAddr(t testing.TB, r *rand.Rand) *tor.OnionAddr {",
      "content": "func randV3OnionAddr(t testing.TB, r *rand.Rand) *tor.OnionAddr {\n\tt.Helper()\n\n\tvar serviceID [tor.V3DecodedLen]byte\n\t_, err := r.Read(serviceID[:])\n\trequire.NoError(t, err, \"unable to read serviceID\")\n\n\tvar port [2]byte\n\t_, err = r.Read(port[:])\n\trequire.NoError(t, err, \"unable to read port\")\n\n\tonionService := tor.Base32Encoding.EncodeToString(serviceID[:])\n\tonionService += tor.OnionSuffix\n\taddrPort := int(binary.BigEndian.Uint16(port[:]))\n\n\treturn &tor.OnionAddr{OnionService: onionService, Port: addrPort}\n}\n",
      "length": 433,
      "tokens": 42,
      "embedding": []
    },
    {
      "slug": "func randAddrs(t testing.TB, r *rand.Rand) []net.Addr {",
      "content": "func randAddrs(t testing.TB, r *rand.Rand) []net.Addr {\n\ttcp4Addr := randTCP4Addr(t, r)\n\ttcp6Addr := randTCP6Addr(t, r)\n\tv2OnionAddr := randV2OnionAddr(t, r)\n\tv3OnionAddr := randV3OnionAddr(t, r)\n\n\treturn []net.Addr{tcp4Addr, tcp6Addr, v2OnionAddr, v3OnionAddr}\n}\n",
      "length": 201,
      "tokens": 22,
      "embedding": []
    },
    {
      "slug": "func randAlias(r *rand.Rand) lnwire.NodeAlias {",
      "content": "func randAlias(r *rand.Rand) lnwire.NodeAlias {\n\tvar a lnwire.NodeAlias\n\tfor i := range a {\n\t\ta[i] = letterBytes[r.Intn(len(letterBytes))]\n\t}\n\n\treturn a\n}\n",
      "length": 100,
      "tokens": 16,
      "embedding": []
    },
    {
      "slug": "func createExtraData(t testing.TB, r io.Reader) []byte {",
      "content": "func createExtraData(t testing.TB, r io.Reader) []byte {\n\tt.Helper()\n\n\t// Read random bytes.\n\textraData := make([]byte, testNumExtraBytes)\n\t_, err := r.Read(extraData)\n\trequire.NoError(t, err, \"unable to generate extra data\")\n\n\t// Encode the data length.\n\tbinary.BigEndian.PutUint16(extraData[:2], uint16(len(extraData[2:])))\n\n\treturn extraData\n}\n",
      "length": 278,
      "tokens": 30,
      "embedding": []
    }
  ]
}