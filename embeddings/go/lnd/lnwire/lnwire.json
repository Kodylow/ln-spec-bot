{
  "filepath": "../implementations/go/lnd/lnwire/lnwire.go",
  "package": "lnwire",
  "sections": [
    {
      "slug": "type PkScript []byte",
      "content": "type PkScript []byte\n\n// addressType specifies the network protocol and version that should be used\n// when connecting to a node at a particular address.",
      "length": 130,
      "tokens": 22,
      "embedding": []
    },
    {
      "slug": "type addressType uint8",
      "content": "type addressType uint8\n\nconst (\n\t// noAddr denotes a blank address. An address of this type indicates\n\t// that a node doesn't have any advertised addresses.\n\tnoAddr addressType = 0\n\n\t// tcp4Addr denotes an IPv4 TCP address.\n\ttcp4Addr addressType = 1\n\n\t// tcp6Addr denotes an IPv6 TCP address.\n\ttcp6Addr addressType = 2\n\n\t// v2OnionAddr denotes a version 2 Tor onion service address.\n\tv2OnionAddr addressType = 3\n\n\t// v3OnionAddr denotes a version 3 Tor (prop224) onion service address.\n\tv3OnionAddr addressType = 4\n)\n\n// AddrLen returns the number of bytes that it takes to encode the target\n// address.",
      "length": 560,
      "tokens": 95,
      "embedding": []
    },
    {
      "slug": "func (a addressType) AddrLen() uint16 {",
      "content": "func (a addressType) AddrLen() uint16 {\n\tswitch a {\n\tcase noAddr:\n\t\treturn 0\n\tcase tcp4Addr:\n\t\treturn 6\n\tcase tcp6Addr:\n\t\treturn 18\n\tcase v2OnionAddr:\n\t\treturn 12\n\tcase v3OnionAddr:\n\t\treturn 37\n\tdefault:\n\t\treturn 0\n\t}\n}\n\n// WriteElement is a one-stop shop to write the big endian representation of\n// any element which is to be serialized for the wire protocol.\n//\n// TODO(yy): rm this method once we finish dereferencing it from other\n// packages.",
      "length": 388,
      "tokens": 68,
      "embedding": []
    },
    {
      "slug": "func WriteElement(w *bytes.Buffer, element interface{}) error {",
      "content": "func WriteElement(w *bytes.Buffer, element interface{}) error {\n\tswitch e := element.(type) {\n\tcase NodeAlias:\n\t\tif _, err := w.Write(e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase ShortChanIDEncoding:\n\t\tvar b [1]byte\n\t\tb[0] = uint8(e)\n\t\tif _, err := w.Write(b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase uint8:\n\t\tvar b [1]byte\n\t\tb[0] = e\n\t\tif _, err := w.Write(b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase FundingFlag:\n\t\tvar b [1]byte\n\t\tb[0] = uint8(e)\n\t\tif _, err := w.Write(b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase uint16:\n\t\tvar b [2]byte\n\t\tbinary.BigEndian.PutUint16(b[:], e)\n\t\tif _, err := w.Write(b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase ChanUpdateMsgFlags:\n\t\tvar b [1]byte\n\t\tb[0] = uint8(e)\n\t\tif _, err := w.Write(b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase ChanUpdateChanFlags:\n\t\tvar b [1]byte\n\t\tb[0] = uint8(e)\n\t\tif _, err := w.Write(b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase MilliSatoshi:\n\t\tvar b [8]byte\n\t\tbinary.BigEndian.PutUint64(b[:], uint64(e))\n\t\tif _, err := w.Write(b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase btcutil.Amount:\n\t\tvar b [8]byte\n\t\tbinary.BigEndian.PutUint64(b[:], uint64(e))\n\t\tif _, err := w.Write(b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase uint32:\n\t\tvar b [4]byte\n\t\tbinary.BigEndian.PutUint32(b[:], e)\n\t\tif _, err := w.Write(b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase uint64:\n\t\tvar b [8]byte\n\t\tbinary.BigEndian.PutUint64(b[:], e)\n\t\tif _, err := w.Write(b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *btcec.PublicKey:\n\t\tif e == nil {\n\t\t\treturn fmt.Errorf(\"cannot write nil pubkey\")\n\t\t}\n\n\t\tvar b [33]byte\n\t\tserializedPubkey := e.SerializeCompressed()\n\t\tcopy(b[:], serializedPubkey)\n\t\tif _, err := w.Write(b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase []Sig:\n\t\tvar b [2]byte\n\t\tnumSigs := uint16(len(e))\n\t\tbinary.BigEndian.PutUint16(b[:], numSigs)\n\t\tif _, err := w.Write(b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfor _, sig := range e {\n\t\t\tif err := WriteElement(w, sig); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\tcase Sig:\n\t\t// Write buffer\n\t\tif _, err := w.Write(e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase PingPayload:\n\t\tvar l [2]byte\n\t\tbinary.BigEndian.PutUint16(l[:], uint16(len(e)))\n\t\tif _, err := w.Write(l[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif _, err := w.Write(e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase PongPayload:\n\t\tvar l [2]byte\n\t\tbinary.BigEndian.PutUint16(l[:], uint16(len(e)))\n\t\tif _, err := w.Write(l[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif _, err := w.Write(e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase WarningData:\n\t\tvar l [2]byte\n\t\tbinary.BigEndian.PutUint16(l[:], uint16(len(e)))\n\t\tif _, err := w.Write(l[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif _, err := w.Write(e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase ErrorData:\n\t\tvar l [2]byte\n\t\tbinary.BigEndian.PutUint16(l[:], uint16(len(e)))\n\t\tif _, err := w.Write(l[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif _, err := w.Write(e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase OpaqueReason:\n\t\tvar l [2]byte\n\t\tbinary.BigEndian.PutUint16(l[:], uint16(len(e)))\n\t\tif _, err := w.Write(l[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif _, err := w.Write(e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase [33]byte:\n\t\tif _, err := w.Write(e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase []byte:\n\t\tif _, err := w.Write(e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase PkScript:\n\t\t// The largest script we'll accept is a p2wsh which is exactly\n\t\t// 34 bytes long.\n\t\tscriptLength := len(e)\n\t\tif scriptLength > 34 {\n\t\t\treturn fmt.Errorf(\"'PkScript' too long\")\n\t\t}\n\n\t\tif err := wire.WriteVarBytes(w, 0, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *RawFeatureVector:\n\t\tif e == nil {\n\t\t\treturn fmt.Errorf(\"cannot write nil feature vector\")\n\t\t}\n\n\t\tif err := e.Encode(w); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase wire.OutPoint:\n\t\tvar h [32]byte\n\t\tcopy(h[:], e.Hash[:])\n\t\tif _, err := w.Write(h[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif e.Index > math.MaxUint16 {\n\t\t\treturn fmt.Errorf(\"index for outpoint (%v) is \"+\n\t\t\t\t\"greater than max index of %v\", e.Index,\n\t\t\t\tmath.MaxUint16)\n\t\t}\n\n\t\tvar idx [2]byte\n\t\tbinary.BigEndian.PutUint16(idx[:], uint16(e.Index))\n\t\tif _, err := w.Write(idx[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase ChannelID:\n\t\tif _, err := w.Write(e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase FailCode:\n\t\tif err := WriteElement(w, uint16(e)); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase ShortChannelID:\n\t\t// Check that field fit in 3 bytes and write the blockHeight\n\t\tif e.BlockHeight > ((1 << 24) - 1) {\n\t\t\treturn errors.New(\"block height should fit in 3 bytes\")\n\t\t}\n\n\t\tvar blockHeight [4]byte\n\t\tbinary.BigEndian.PutUint32(blockHeight[:], e.BlockHeight)\n\n\t\tif _, err := w.Write(blockHeight[1:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Check that field fit in 3 bytes and write the txIndex\n\t\tif e.TxIndex > ((1 << 24) - 1) {\n\t\t\treturn errors.New(\"tx index should fit in 3 bytes\")\n\t\t}\n\n\t\tvar txIndex [4]byte\n\t\tbinary.BigEndian.PutUint32(txIndex[:], e.TxIndex)\n\t\tif _, err := w.Write(txIndex[1:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Write the txPosition\n\t\tvar txPosition [2]byte\n\t\tbinary.BigEndian.PutUint16(txPosition[:], e.TxPosition)\n\t\tif _, err := w.Write(txPosition[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *net.TCPAddr:\n\t\tif e == nil {\n\t\t\treturn fmt.Errorf(\"cannot write nil TCPAddr\")\n\t\t}\n\n\t\tif e.IP.To4() != nil {\n\t\t\tvar descriptor [1]byte\n\t\t\tdescriptor[0] = uint8(tcp4Addr)\n\t\t\tif _, err := w.Write(descriptor[:]); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tvar ip [4]byte\n\t\t\tcopy(ip[:], e.IP.To4())\n\t\t\tif _, err := w.Write(ip[:]); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\tvar descriptor [1]byte\n\t\t\tdescriptor[0] = uint8(tcp6Addr)\n\t\t\tif _, err := w.Write(descriptor[:]); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tvar ip [16]byte\n\t\t\tcopy(ip[:], e.IP.To16())\n\t\t\tif _, err := w.Write(ip[:]); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tvar port [2]byte\n\t\tbinary.BigEndian.PutUint16(port[:], uint16(e.Port))\n\t\tif _, err := w.Write(port[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *tor.OnionAddr:\n\t\tif e == nil {\n\t\t\treturn errors.New(\"cannot write nil onion address\")\n\t\t}\n\n\t\tvar suffixIndex int\n\t\tswitch len(e.OnionService) {\n\t\tcase tor.V2Len:\n\t\t\tdescriptor := []byte{byte(v2OnionAddr)}\n\t\t\tif _, err := w.Write(descriptor); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tsuffixIndex = tor.V2Len - tor.OnionSuffixLen\n\t\tcase tor.V3Len:\n\t\t\tdescriptor := []byte{byte(v3OnionAddr)}\n\t\t\tif _, err := w.Write(descriptor); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tsuffixIndex = tor.V3Len - tor.OnionSuffixLen\n\t\tdefault:\n\t\t\treturn errors.New(\"unknown onion service length\")\n\t\t}\n\n\t\thost, err := tor.Base32Encoding.DecodeString(\n\t\t\te.OnionService[:suffixIndex],\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := w.Write(host); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvar port [2]byte\n\t\tbinary.BigEndian.PutUint16(port[:], uint16(e.Port))\n\t\tif _, err := w.Write(port[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase []net.Addr:\n\t\t// First, we'll encode all the addresses into an intermediate\n\t\t// buffer. We need to do this in order to compute the total\n\t\t// length of the addresses.\n\t\tvar addrBuf bytes.Buffer\n\t\tfor _, address := range e {\n\t\t\tif err := WriteElement(&addrBuf, address); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\t// With the addresses fully encoded, we can now write out the\n\t\t// number of bytes needed to encode them.\n\t\taddrLen := addrBuf.Len()\n\t\tif err := WriteElement(w, uint16(addrLen)); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Finally, we'll write out the raw addresses themselves, but\n\t\t// only if we have any bytes to write.\n\t\tif addrLen > 0 {\n\t\t\tif _, err := w.Write(addrBuf.Bytes()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\tcase color.RGBA:\n\t\tif err := WriteElements(w, e.R, e.G, e.B); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase DeliveryAddress:\n\t\tvar length [2]byte\n\t\tbinary.BigEndian.PutUint16(length[:], uint16(len(e)))\n\t\tif _, err := w.Write(length[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := w.Write(e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase bool:\n\t\tvar b [1]byte\n\t\tif e {\n\t\t\tb[0] = 1\n\t\t}\n\t\tif _, err := w.Write(b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase ExtraOpaqueData:\n\t\treturn e.Encode(w)\n\n\tdefault:\n\t\treturn fmt.Errorf(\"unknown type in WriteElement: %T\", e)\n\t}\n\n\treturn nil\n}\n\n// WriteElements is writes each element in the elements slice to the passed\n// buffer using WriteElement.\n//\n// TODO(yy): rm this method once we finish dereferencing it from other\n// packages.",
      "length": 7778,
      "tokens": 1227,
      "embedding": []
    },
    {
      "slug": "func WriteElements(buf *bytes.Buffer, elements ...interface{}) error {",
      "content": "func WriteElements(buf *bytes.Buffer, elements ...interface{}) error {\n\tfor _, element := range elements {\n\t\terr := WriteElement(buf, element)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// ReadElement is a one-stop utility function to deserialize any datastructure\n// encoded using the serialization format of lnwire.",
      "length": 247,
      "tokens": 42,
      "embedding": []
    },
    {
      "slug": "func ReadElement(r io.Reader, element interface{}) error {",
      "content": "func ReadElement(r io.Reader, element interface{}) error {\n\tvar err error\n\tswitch e := element.(type) {\n\tcase *bool:\n\t\tvar b [1]byte\n\t\tif _, err := io.ReadFull(r, b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif b[0] == 1 {\n\t\t\t*e = true\n\t\t}\n\n\tcase *NodeAlias:\n\t\tvar a [32]byte\n\t\tif _, err := io.ReadFull(r, a[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\talias, err := NewNodeAlias(string(a[:]))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*e = alias\n\n\tcase *ShortChanIDEncoding:\n\t\tvar b [1]uint8\n\t\tif _, err := r.Read(b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*e = ShortChanIDEncoding(b[0])\n\n\tcase *uint8:\n\t\tvar b [1]uint8\n\t\tif _, err := r.Read(b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*e = b[0]\n\n\tcase *FundingFlag:\n\t\tvar b [1]uint8\n\t\tif _, err := r.Read(b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*e = FundingFlag(b[0])\n\n\tcase *uint16:\n\t\tvar b [2]byte\n\t\tif _, err := io.ReadFull(r, b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*e = binary.BigEndian.Uint16(b[:])\n\n\tcase *ChanUpdateMsgFlags:\n\t\tvar b [1]uint8\n\t\tif _, err := r.Read(b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*e = ChanUpdateMsgFlags(b[0])\n\n\tcase *ChanUpdateChanFlags:\n\t\tvar b [1]uint8\n\t\tif _, err := r.Read(b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*e = ChanUpdateChanFlags(b[0])\n\n\tcase *uint32:\n\t\tvar b [4]byte\n\t\tif _, err := io.ReadFull(r, b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*e = binary.BigEndian.Uint32(b[:])\n\n\tcase *uint64:\n\t\tvar b [8]byte\n\t\tif _, err := io.ReadFull(r, b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*e = binary.BigEndian.Uint64(b[:])\n\n\tcase *MilliSatoshi:\n\t\tvar b [8]byte\n\t\tif _, err := io.ReadFull(r, b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*e = MilliSatoshi(int64(binary.BigEndian.Uint64(b[:])))\n\n\tcase *btcutil.Amount:\n\t\tvar b [8]byte\n\t\tif _, err := io.ReadFull(r, b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*e = btcutil.Amount(int64(binary.BigEndian.Uint64(b[:])))\n\n\tcase **btcec.PublicKey:\n\t\tvar b [btcec.PubKeyBytesLenCompressed]byte\n\t\tif _, err = io.ReadFull(r, b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tpubKey, err := btcec.ParsePubKey(b[:])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*e = pubKey\n\n\tcase **RawFeatureVector:\n\t\tf := NewRawFeatureVector()\n\t\terr = f.Decode(r)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*e = f\n\n\tcase *[]Sig:\n\t\tvar l [2]byte\n\t\tif _, err := io.ReadFull(r, l[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tnumSigs := binary.BigEndian.Uint16(l[:])\n\n\t\tvar sigs []Sig\n\t\tif numSigs > 0 {\n\t\t\tsigs = make([]Sig, numSigs)\n\t\t\tfor i := 0; i < int(numSigs); i++ {\n\t\t\t\tif err := ReadElement(r, &sigs[i]); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*e = sigs\n\n\tcase *Sig:\n\t\tif _, err := io.ReadFull(r, e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *OpaqueReason:\n\t\tvar l [2]byte\n\t\tif _, err := io.ReadFull(r, l[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treasonLen := binary.BigEndian.Uint16(l[:])\n\n\t\t*e = OpaqueReason(make([]byte, reasonLen))\n\t\tif _, err := io.ReadFull(r, *e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *WarningData:\n\t\tvar l [2]byte\n\t\tif _, err := io.ReadFull(r, l[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\terrorLen := binary.BigEndian.Uint16(l[:])\n\n\t\t*e = WarningData(make([]byte, errorLen))\n\t\tif _, err := io.ReadFull(r, *e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *ErrorData:\n\t\tvar l [2]byte\n\t\tif _, err := io.ReadFull(r, l[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\terrorLen := binary.BigEndian.Uint16(l[:])\n\n\t\t*e = ErrorData(make([]byte, errorLen))\n\t\tif _, err := io.ReadFull(r, *e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *PingPayload:\n\t\tvar l [2]byte\n\t\tif _, err := io.ReadFull(r, l[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpingLen := binary.BigEndian.Uint16(l[:])\n\n\t\t*e = PingPayload(make([]byte, pingLen))\n\t\tif _, err := io.ReadFull(r, *e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *PongPayload:\n\t\tvar l [2]byte\n\t\tif _, err := io.ReadFull(r, l[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpongLen := binary.BigEndian.Uint16(l[:])\n\n\t\t*e = PongPayload(make([]byte, pongLen))\n\t\tif _, err := io.ReadFull(r, *e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *[33]byte:\n\t\tif _, err := io.ReadFull(r, e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase []byte:\n\t\tif _, err := io.ReadFull(r, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *PkScript:\n\t\tpkScript, err := wire.ReadVarBytes(r, 0, 34, \"pkscript\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*e = pkScript\n\n\tcase *wire.OutPoint:\n\t\tvar h [32]byte\n\t\tif _, err = io.ReadFull(r, h[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\thash, err := chainhash.NewHash(h[:])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvar idxBytes [2]byte\n\t\t_, err = io.ReadFull(r, idxBytes[:])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tindex := binary.BigEndian.Uint16(idxBytes[:])\n\n\t\t*e = wire.OutPoint{\n\t\t\tHash:  *hash,\n\t\t\tIndex: uint32(index),\n\t\t}\n\n\tcase *FailCode:\n\t\tif err := ReadElement(r, (*uint16)(e)); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *ChannelID:\n\t\tif _, err := io.ReadFull(r, e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *ShortChannelID:\n\t\tvar blockHeight [4]byte\n\t\tif _, err = io.ReadFull(r, blockHeight[1:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvar txIndex [4]byte\n\t\tif _, err = io.ReadFull(r, txIndex[1:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvar txPosition [2]byte\n\t\tif _, err = io.ReadFull(r, txPosition[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t*e = ShortChannelID{\n\t\t\tBlockHeight: binary.BigEndian.Uint32(blockHeight[:]),\n\t\t\tTxIndex:     binary.BigEndian.Uint32(txIndex[:]),\n\t\t\tTxPosition:  binary.BigEndian.Uint16(txPosition[:]),\n\t\t}\n\n\tcase *[]net.Addr:\n\t\t// First, we'll read the number of total bytes that have been\n\t\t// used to encode the set of addresses.\n\t\tvar numAddrsBytes [2]byte\n\t\tif _, err = io.ReadFull(r, numAddrsBytes[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\taddrsLen := binary.BigEndian.Uint16(numAddrsBytes[:])\n\n\t\t// With the number of addresses, read, we'll now pull in the\n\t\t// buffer of the encoded addresses into memory.\n\t\taddrs := make([]byte, addrsLen)\n\t\tif _, err := io.ReadFull(r, addrs[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\taddrBuf := bytes.NewReader(addrs)\n\n\t\t// Finally, we'll parse the remaining address payload in\n\t\t// series, using the first byte to denote how to decode the\n\t\t// address itself.\n\t\tvar (\n\t\t\taddresses     []net.Addr\n\t\t\taddrBytesRead uint16\n\t\t)\n\n\t\tfor addrBytesRead < addrsLen {\n\t\t\tvar descriptor [1]byte\n\t\t\tif _, err = io.ReadFull(addrBuf, descriptor[:]); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\taddrBytesRead++\n\n\t\t\tvar address net.Addr\n\t\t\tswitch aType := addressType(descriptor[0]); aType {\n\t\t\tcase noAddr:\n\t\t\t\taddrBytesRead += aType.AddrLen()\n\t\t\t\tcontinue\n\n\t\t\tcase tcp4Addr:\n\t\t\t\tvar ip [4]byte\n\t\t\t\tif _, err := io.ReadFull(addrBuf, ip[:]); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tvar port [2]byte\n\t\t\t\tif _, err := io.ReadFull(addrBuf, port[:]); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\taddress = &net.TCPAddr{\n\t\t\t\t\tIP:   net.IP(ip[:]),\n\t\t\t\t\tPort: int(binary.BigEndian.Uint16(port[:])),\n\t\t\t\t}\n\t\t\t\taddrBytesRead += aType.AddrLen()\n\n\t\t\tcase tcp6Addr:\n\t\t\t\tvar ip [16]byte\n\t\t\t\tif _, err := io.ReadFull(addrBuf, ip[:]); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tvar port [2]byte\n\t\t\t\tif _, err := io.ReadFull(addrBuf, port[:]); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\taddress = &net.TCPAddr{\n\t\t\t\t\tIP:   net.IP(ip[:]),\n\t\t\t\t\tPort: int(binary.BigEndian.Uint16(port[:])),\n\t\t\t\t}\n\t\t\t\taddrBytesRead += aType.AddrLen()\n\n\t\t\tcase v2OnionAddr:\n\t\t\t\tvar h [tor.V2DecodedLen]byte\n\t\t\t\tif _, err := io.ReadFull(addrBuf, h[:]); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tvar p [2]byte\n\t\t\t\tif _, err := io.ReadFull(addrBuf, p[:]); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tonionService := tor.Base32Encoding.EncodeToString(h[:])\n\t\t\t\tonionService += tor.OnionSuffix\n\t\t\t\tport := int(binary.BigEndian.Uint16(p[:]))\n\n\t\t\t\taddress = &tor.OnionAddr{\n\t\t\t\t\tOnionService: onionService,\n\t\t\t\t\tPort:         port,\n\t\t\t\t}\n\t\t\t\taddrBytesRead += aType.AddrLen()\n\n\t\t\tcase v3OnionAddr:\n\t\t\t\tvar h [tor.V3DecodedLen]byte\n\t\t\t\tif _, err := io.ReadFull(addrBuf, h[:]); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tvar p [2]byte\n\t\t\t\tif _, err := io.ReadFull(addrBuf, p[:]); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tonionService := tor.Base32Encoding.EncodeToString(h[:])\n\t\t\t\tonionService += tor.OnionSuffix\n\t\t\t\tport := int(binary.BigEndian.Uint16(p[:]))\n\n\t\t\t\taddress = &tor.OnionAddr{\n\t\t\t\t\tOnionService: onionService,\n\t\t\t\t\tPort:         port,\n\t\t\t\t}\n\t\t\t\taddrBytesRead += aType.AddrLen()\n\n\t\t\tdefault:\n\t\t\t\t// If we don't understand this address type,\n\t\t\t\t// we just store it along with the remaining\n\t\t\t\t// address bytes as type OpaqueAddrs. We need\n\t\t\t\t// to hold onto the bytes so that we can still\n\t\t\t\t// write them back to the wire when we\n\t\t\t\t// propagate this message.\n\t\t\t\tpayloadLen := 1 + addrsLen - addrBytesRead\n\t\t\t\tpayload := make([]byte, payloadLen)\n\n\t\t\t\t// First write a byte for the address type that\n\t\t\t\t// we already read.\n\t\t\t\tpayload[0] = byte(aType)\n\n\t\t\t\t// Now append the rest of the address bytes.\n\t\t\t\t_, err := io.ReadFull(addrBuf, payload[1:])\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\taddress = &OpaqueAddrs{\n\t\t\t\t\tPayload: payload,\n\t\t\t\t}\n\t\t\t\taddrBytesRead = addrsLen\n\t\t\t}\n\n\t\t\taddresses = append(addresses, address)\n\t\t}\n\n\t\t*e = addresses\n\n\tcase *color.RGBA:\n\t\terr := ReadElements(r,\n\t\t\t&e.R,\n\t\t\t&e.G,\n\t\t\t&e.B,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *DeliveryAddress:\n\t\tvar addrLen [2]byte\n\t\tif _, err = io.ReadFull(r, addrLen[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tlength := binary.BigEndian.Uint16(addrLen[:])\n\n\t\tvar addrBytes [deliveryAddressMaxSize]byte\n\n\t\tif length > deliveryAddressMaxSize {\n\t\t\treturn fmt.Errorf(\n\t\t\t\t\"cannot read %d bytes into addrBytes\", length,\n\t\t\t)\n\t\t}\n\t\tif _, err = io.ReadFull(r, addrBytes[:length]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*e = addrBytes[:length]\n\n\tcase *ExtraOpaqueData:\n\t\treturn e.Decode(r)\n\n\tdefault:\n\t\treturn fmt.Errorf(\"unknown type in ReadElement: %T\", e)\n\t}\n\n\treturn nil\n}\n\n// ReadElements deserializes a variable number of elements into the passed\n// io.Reader, with each element being deserialized according to the ReadElement\n// function.",
      "length": 9224,
      "tokens": 1363,
      "embedding": []
    },
    {
      "slug": "func ReadElements(r io.Reader, elements ...interface{}) error {",
      "content": "func ReadElements(r io.Reader, elements ...interface{}) error {\n\tfor _, element := range elements {\n\t\terr := ReadElement(r, element)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n",
      "length": 114,
      "tokens": 23,
      "embedding": []
    }
  ]
}