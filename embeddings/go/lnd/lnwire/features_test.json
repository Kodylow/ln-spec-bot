{
  "filepath": "../implementations/go/lnd/lnwire/features_test.go",
  "package": "lnwire",
  "sections": [
    {
      "slug": "func TestFeatureVectorSetUnset(t *testing.T) {",
      "content": "func TestFeatureVectorSetUnset(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tbits             []FeatureBit\n\t\texpectedFeatures []bool\n\t}{\n\t\t// No features are enabled if no bits are set.\n\t\t{\n\t\t\tbits:             nil,\n\t\t\texpectedFeatures: []bool{false, false, false, false, false, false, false, false},\n\t\t},\n\t\t// Test setting an even bit for an even-only bit feature. The\n\t\t// corresponding odd bit should not be seen as set.\n\t\t{\n\t\t\tbits:             []FeatureBit{0},\n\t\t\texpectedFeatures: []bool{true, false, false, false, false, false, false, false},\n\t\t},\n\t\t// Test setting an odd bit for an even-only bit feature. The\n\t\t// corresponding even bit should not be seen as set.\n\t\t{\n\t\t\tbits:             []FeatureBit{1},\n\t\t\texpectedFeatures: []bool{false, true, false, false, false, false, false, false},\n\t\t},\n\t\t// Test setting an even bit for an odd-only bit feature. The bit should\n\t\t// be seen as set and the odd bit should not.\n\t\t{\n\t\t\tbits:             []FeatureBit{2},\n\t\t\texpectedFeatures: []bool{false, false, true, false, false, false, false, false},\n\t\t},\n\t\t// Test setting an odd bit for an odd-only bit feature. The bit should\n\t\t// be seen as set and the even bit should not.\n\t\t{\n\t\t\tbits:             []FeatureBit{3},\n\t\t\texpectedFeatures: []bool{false, false, false, true, false, false, false, false},\n\t\t},\n\t\t// Test setting an even bit for even-odd pair feature. Both bits in the\n\t\t// pair should be seen as set.\n\t\t{\n\t\t\tbits:             []FeatureBit{4},\n\t\t\texpectedFeatures: []bool{false, false, false, false, true, true, false, false},\n\t\t},\n\t\t// Test setting an odd bit for even-odd pair feature. Both bits in the\n\t\t// pair should be seen as set.\n\t\t{\n\t\t\tbits:             []FeatureBit{5},\n\t\t\texpectedFeatures: []bool{false, false, false, false, true, true, false, false},\n\t\t},\n\t\t// Test setting an even bit for an unknown feature. The bit should be\n\t\t// seen as set and the odd bit should not.\n\t\t{\n\t\t\tbits:             []FeatureBit{6},\n\t\t\texpectedFeatures: []bool{false, false, false, false, false, false, true, false},\n\t\t},\n\t\t// Test setting an odd bit for an unknown feature. The bit should be\n\t\t// seen as set and the odd bit should not.\n\t\t{\n\t\t\tbits:             []FeatureBit{7},\n\t\t\texpectedFeatures: []bool{false, false, false, false, false, false, false, true},\n\t\t},\n\t}\n\n\tfv := NewFeatureVector(nil, testFeatureNames)\n\tfor i, test := range tests {\n\t\tfor _, bit := range test.bits {\n\t\t\tfv.Set(bit)\n\t\t}\n\n\t\tfor j, expectedSet := range test.expectedFeatures {\n\t\t\tif fv.HasFeature(FeatureBit(j)) != expectedSet {\n\t\t\t\tt.Errorf(\"Expectation failed in case %d, bit %d\", i, j)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tfor _, bit := range test.bits {\n\t\t\tfv.Unset(bit)\n\t\t}\n\t}\n}\n\n// TestFeatureVectorRequiresFeature tests that if a feature vector only\n// includes a required feature bit (it's even), then the RequiresFeature method\n// will return true for both that bit as well as it's optional counter party.",
      "length": 2768,
      "tokens": 413,
      "embedding": []
    },
    {
      "slug": "func TestFeatureVectorRequiresFeature(t *testing.T) {",
      "content": "func TestFeatureVectorRequiresFeature(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a new feature vector with the features above, and set only\n\t// the set of required bits. These will be all the even features\n\t// referenced above.\n\tfv := NewFeatureVector(nil, testFeatureNames)\n\tfv.Set(0)\n\tfv.Set(4)\n\n\t// Next we'll query for those exact bits, these should show up as being\n\t// required.\n\trequire.True(t, fv.RequiresFeature(0))\n\trequire.True(t, fv.RequiresFeature(4))\n\n\t// If we query for the odd (optional) counter party to each of the\n\t// features, the method should still return that the backing feature\n\t// vector requires the feature to be set.\n\trequire.True(t, fv.RequiresFeature(1))\n\trequire.True(t, fv.RequiresFeature(5))\n}\n",
      "length": 654,
      "tokens": 94,
      "embedding": []
    },
    {
      "slug": "func TestFeatureVectorEncodeDecode(t *testing.T) {",
      "content": "func TestFeatureVectorEncodeDecode(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tbits            []FeatureBit\n\t\texpectedEncoded []byte\n\t}{\n\t\t{\n\t\t\tbits:            nil,\n\t\t\texpectedEncoded: []byte{0x00, 0x00},\n\t\t},\n\t\t{\n\t\t\tbits:            []FeatureBit{2, 3, 7},\n\t\t\texpectedEncoded: []byte{0x00, 0x01, 0x8C},\n\t\t},\n\t\t{\n\t\t\tbits:            []FeatureBit{2, 3, 8},\n\t\t\texpectedEncoded: []byte{0x00, 0x02, 0x01, 0x0C},\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\tfv := NewRawFeatureVector(test.bits...)\n\n\t\t// Test that Encode produces the correct serialization.\n\t\tbuffer := new(bytes.Buffer)\n\t\terr := fv.Encode(buffer)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Failed to encode feature vector in case %d: %v\", i, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tencoded := buffer.Bytes()\n\t\tif !bytes.Equal(encoded, test.expectedEncoded) {\n\t\t\tt.Errorf(\"Wrong encoding in case %d: got %v, expected %v\",\n\t\t\t\ti, encoded, test.expectedEncoded)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Test that decoding then re-encoding produces the same result.\n\t\tfv2 := NewRawFeatureVector()\n\t\terr = fv2.Decode(bytes.NewReader(encoded))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Failed to decode feature vector in case %d: %v\", i, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tbuffer2 := new(bytes.Buffer)\n\t\terr = fv2.Encode(buffer2)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Failed to re-encode feature vector in case %d: %v\",\n\t\t\t\ti, err)\n\t\t\tcontinue\n\t\t}\n\n\t\treencoded := buffer2.Bytes()\n\t\tif !bytes.Equal(reencoded, test.expectedEncoded) {\n\t\t\tt.Errorf(\"Wrong re-encoding in case %d: got %v, expected %v\",\n\t\t\t\ti, reencoded, test.expectedEncoded)\n\t\t}\n\t}\n}\n",
      "length": 1421,
      "tokens": 182,
      "embedding": []
    },
    {
      "slug": "func TestFeatureVectorUnknownFeatures(t *testing.T) {",
      "content": "func TestFeatureVectorUnknownFeatures(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tbits            []FeatureBit\n\t\texpectedUnknown []FeatureBit\n\t}{\n\t\t{\n\t\t\tbits:            nil,\n\t\t\texpectedUnknown: nil,\n\t\t},\n\t\t// Since bits {0, 3, 4, 5} are known, and only even bits are considered\n\t\t// required (according to the \"it's OK to be odd rule\"), that leaves\n\t\t// {2, 6} as both unknown and required.\n\t\t{\n\t\t\tbits:            []FeatureBit{0, 1, 2, 3, 4, 5, 6, 7},\n\t\t\texpectedUnknown: []FeatureBit{2, 6},\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\trawVector := NewRawFeatureVector(test.bits...)\n\t\tfv := NewFeatureVector(rawVector, testFeatureNames)\n\n\t\tunknown := fv.UnknownRequiredFeatures()\n\n\t\t// Sort to make comparison independent of order\n\t\tsort.Slice(unknown, func(i, j int) bool {\n\t\t\treturn unknown[i] < unknown[j]\n\t\t})\n\t\tif !reflect.DeepEqual(unknown, test.expectedUnknown) {\n\t\t\tt.Errorf(\"Wrong unknown features in case %d: got %v, expected %v\",\n\t\t\t\ti, unknown, test.expectedUnknown)\n\t\t}\n\t}\n}\n",
      "length": 908,
      "tokens": 123,
      "embedding": []
    },
    {
      "slug": "func TestFeatureNames(t *testing.T) {",
      "content": "func TestFeatureNames(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tbit           FeatureBit\n\t\texpectedName  string\n\t\texpectedKnown bool\n\t}{\n\t\t{\n\t\t\tbit:           0,\n\t\t\texpectedName:  \"feature1\",\n\t\t\texpectedKnown: true,\n\t\t},\n\t\t{\n\t\t\tbit:           1,\n\t\t\texpectedName:  \"unknown\",\n\t\t\texpectedKnown: false,\n\t\t},\n\t\t{\n\t\t\tbit:           2,\n\t\t\texpectedName:  \"unknown\",\n\t\t\texpectedKnown: false,\n\t\t},\n\t\t{\n\t\t\tbit:           3,\n\t\t\texpectedName:  \"feature2\",\n\t\t\texpectedKnown: true,\n\t\t},\n\t\t{\n\t\t\tbit:           4,\n\t\t\texpectedName:  \"feature3\",\n\t\t\texpectedKnown: true,\n\t\t},\n\t\t{\n\t\t\tbit:           5,\n\t\t\texpectedName:  \"feature3\",\n\t\t\texpectedKnown: true,\n\t\t},\n\t\t{\n\t\t\tbit:           6,\n\t\t\texpectedName:  \"unknown\",\n\t\t\texpectedKnown: false,\n\t\t},\n\t\t{\n\t\t\tbit:           7,\n\t\t\texpectedName:  \"unknown\",\n\t\t\texpectedKnown: false,\n\t\t},\n\t}\n\n\tfv := NewFeatureVector(nil, testFeatureNames)\n\tfor _, test := range tests {\n\t\tname := fv.Name(test.bit)\n\t\tif name != test.expectedName {\n\t\t\tt.Errorf(\"Name for feature bit %d is incorrect: \"+\n\t\t\t\t\"expected %s, got %s\", test.bit, name, test.expectedName)\n\t\t}\n\n\t\tknown := fv.IsKnown(test.bit)\n\t\tif known != test.expectedKnown {\n\t\t\tt.Errorf(\"IsKnown for feature bit %d is incorrect: \"+\n\t\t\t\t\"expected %v, got %v\", test.bit, known, test.expectedKnown)\n\t\t}\n\t}\n}\n\n// TestIsRequired asserts that feature bits properly return their IsRequired\n// status. We require that even features be required and odd features be\n// optional.",
      "length": 1339,
      "tokens": 163,
      "embedding": []
    },
    {
      "slug": "func TestIsRequired(t *testing.T) {",
      "content": "func TestIsRequired(t *testing.T) {\n\toptional := FeatureBit(1)\n\tif optional.IsRequired() {\n\t\tt.Fatalf(\"optional feature should not be required\")\n\t}\n\n\trequired := FeatureBit(0)\n\tif !required.IsRequired() {\n\t\tt.Fatalf(\"required feature should be required\")\n\t}\n}\n\n// TestFeatures asserts that the Features() method on a FeatureVector properly\n// returns the set of feature bits it stores internally.",
      "length": 348,
      "tokens": 47,
      "embedding": []
    },
    {
      "slug": "func TestFeatures(t *testing.T) {",
      "content": "func TestFeatures(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\texp  map[FeatureBit]struct{}\n\t}{\n\t\t{\n\t\t\tname: \"empty\",\n\t\t\texp:  map[FeatureBit]struct{}{},\n\t\t},\n\t\t{\n\t\t\tname: \"one\",\n\t\t\texp: map[FeatureBit]struct{}{\n\t\t\t\t5: {},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"several\",\n\t\t\texp: map[FeatureBit]struct{}{\n\t\t\t\t0:     {},\n\t\t\t\t5:     {},\n\t\t\t\t23948: {},\n\t\t\t},\n\t\t},\n\t}\n\n\ttoRawFV := func(set map[FeatureBit]struct{}) *RawFeatureVector {\n\t\tvar bits []FeatureBit\n\t\tfor bit := range set {\n\t\t\tbits = append(bits, bit)\n\t\t}\n\t\treturn NewRawFeatureVector(bits...)\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tfv := NewFeatureVector(\n\t\t\t\ttoRawFV(test.exp), Features,\n\t\t\t)\n\n\t\t\tif !reflect.DeepEqual(fv.Features(), test.exp) {\n\t\t\t\tt.Fatalf(\"feature mismatch, want: %v, got: %v\",\n\t\t\t\t\ttest.exp, fv.Features())\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "length": 768,
      "tokens": 97,
      "embedding": []
    },
    {
      "slug": "func TestRawFeatureVectorOnlyContains(t *testing.T) {",
      "content": "func TestRawFeatureVectorOnlyContains(t *testing.T) {\n\tt.Parallel()\n\n\tfeatures := []FeatureBit{\n\t\tStaticRemoteKeyOptional,\n\t\tAnchorsZeroFeeHtlcTxOptional,\n\t\tExplicitChannelTypeRequired,\n\t}\n\tfv := NewRawFeatureVector(features...)\n\trequire.True(t, fv.OnlyContains(features...))\n\trequire.False(t, fv.OnlyContains(features[:1]...))\n}\n",
      "length": 265,
      "tokens": 16,
      "embedding": []
    },
    {
      "slug": "func TestEqualRawFeatureVectors(t *testing.T) {",
      "content": "func TestEqualRawFeatureVectors(t *testing.T) {\n\tt.Parallel()\n\n\ta := NewRawFeatureVector(\n\t\tStaticRemoteKeyOptional,\n\t\tAnchorsZeroFeeHtlcTxOptional,\n\t\tExplicitChannelTypeRequired,\n\t)\n\tb := a.Clone()\n\trequire.True(t, a.Equals(b))\n\n\tb.Unset(ExplicitChannelTypeRequired)\n\trequire.False(t, a.Equals(b))\n\n\tb.Set(ExplicitChannelTypeOptional)\n\trequire.False(t, a.Equals(b))\n}\n",
      "length": 305,
      "tokens": 20,
      "embedding": []
    },
    {
      "slug": "func TestIsEmptyFeatureVector(t *testing.T) {",
      "content": "func TestIsEmptyFeatureVector(t *testing.T) {\n\tt.Parallel()\n\n\tfv := NewRawFeatureVector()\n\trequire.True(t, fv.IsEmpty())\n\n\tfv.Set(StaticRemoteKeyOptional)\n\trequire.False(t, fv.IsEmpty())\n\n\tfv.Unset(StaticRemoteKeyOptional)\n\trequire.True(t, fv.IsEmpty())\n}\n",
      "length": 199,
      "tokens": 13,
      "embedding": []
    }
  ]
}