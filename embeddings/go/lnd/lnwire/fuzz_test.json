{
  "filepath": "../implementations/go/lnd/lnwire/fuzz_test.go",
  "package": "lnwire",
  "sections": [
    {
      "slug": "func prefixWithMsgType(data []byte, prefix MessageType) []byte {",
      "content": "func prefixWithMsgType(data []byte, prefix MessageType) []byte {\n\tvar prefixBytes [2]byte\n\tbinary.BigEndian.PutUint16(prefixBytes[:], uint16(prefix))\n\tdata = append(prefixBytes[:], data...)\n\n\treturn data\n}\n\n// harness performs the actual fuzz testing of the appropriate wire message.\n// This function will check that the passed-in message passes wire length\n// checks, is a valid message once deserialized, and passes a sequence of\n// serialization and deserialization checks.",
      "length": 401,
      "tokens": 54,
      "embedding": []
    },
    {
      "slug": "func harness(t *testing.T, data []byte) {",
      "content": "func harness(t *testing.T, data []byte) {\n\tt.Helper()\n\n\t// Create a reader with the byte array.\n\tr := bytes.NewReader(data)\n\n\t// Check that the created message is not greater than the maximum\n\t// message size.\n\tif len(data) > MaxSliceLength {\n\t\treturn\n\t}\n\n\tmsg, err := ReadMessage(r, 0)\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// We will serialize the message into a new bytes buffer.\n\tvar b bytes.Buffer\n\tif _, err := WriteMessage(&b, msg, 0); err != nil {\n\t\t// Could not serialize message into bytes buffer, panic\n\t\tt.Fatal(err)\n\t}\n\n\t// Deserialize the message from the serialized bytes buffer, and then\n\t// assert that the original message is equal to the newly deserialized\n\t// message.\n\tnewMsg, err := ReadMessage(&b, 0)\n\tif err != nil {\n\t\t// Could not deserialize message from bytes buffer, panic\n\t\tt.Fatal(err)\n\t}\n\n\tif !reflect.DeepEqual(msg, newMsg) {\n\t\t// Deserialized message and original message are not deeply\n\t\t// equal.\n\t\tt.Fatal(\"original message and deserialized message are not \" +\n\t\t\t\"deeply equal\")\n\t}\n}\n",
      "length": 933,
      "tokens": 156,
      "embedding": []
    },
    {
      "slug": "func FuzzAcceptChannel(f *testing.F) {",
      "content": "func FuzzAcceptChannel(f *testing.F) {\n\tf.Fuzz(func(t *testing.T, data []byte) {\n\t\tdata = prefixWithMsgType(data, MsgAcceptChannel)\n\t\t// Create a reader with the byte array.\n\t\tr := bytes.NewReader(data)\n\n\t\t// Make sure byte array length (excluding 2 bytes for message\n\t\t// type) is less than max payload size for the wire message.\n\t\tpayloadLen := uint32(len(data)) - 2\n\t\tif payloadLen > MaxMsgBody {\n\t\t\treturn\n\t\t}\n\n\t\tmsg, err := ReadMessage(r, 0)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\t// We will serialize the message into a new bytes buffer.\n\t\tvar b bytes.Buffer\n\t\tif _, err := WriteMessage(&b, msg, 0); err != nil {\n\t\t\t// Could not serialize message into bytes buffer, panic\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// Deserialize the message from the serialized bytes buffer, and\n\t\t// then assert that the original message is equal to the newly\n\t\t// deserialized message.\n\t\tnewMsg, err := ReadMessage(&b, 0)\n\t\tif err != nil {\n\t\t\t// Could not deserialize message from bytes buffer,\n\t\t\t// panic\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// Now compare every field instead of using reflect.DeepEqual.\n\t\t// For UpfrontShutdownScript, we only compare bytes. This\n\t\t// probably takes up more branches than necessary, but that's\n\t\t// fine for now.\n\t\tvar shouldPanic bool\n\t\tfirst, ok := msg.(*AcceptChannel)\n\t\tif !ok {\n\t\t\tt.Fatal(\"message was not AcceptChannel\")\n\t\t}\n\t\tsecond, ok := newMsg.(*AcceptChannel)\n\t\tif !ok {\n\t\t\tt.Fatal(\"new message was not AcceptChannel\")\n\t\t}\n\n\t\tif !bytes.Equal(first.PendingChannelID[:],\n\t\t\tsecond.PendingChannelID[:]) {\n\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif first.DustLimit != second.DustLimit {\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif first.MaxValueInFlight != second.MaxValueInFlight {\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif first.ChannelReserve != second.ChannelReserve {\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif first.HtlcMinimum != second.HtlcMinimum {\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif first.MinAcceptDepth != second.MinAcceptDepth {\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif first.CsvDelay != second.CsvDelay {\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif first.MaxAcceptedHTLCs != second.MaxAcceptedHTLCs {\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif !first.FundingKey.IsEqual(second.FundingKey) {\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif !first.RevocationPoint.IsEqual(second.RevocationPoint) {\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif !first.PaymentPoint.IsEqual(second.PaymentPoint) {\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif !first.DelayedPaymentPoint.IsEqual(\n\t\t\tsecond.DelayedPaymentPoint) {\n\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif !first.HtlcPoint.IsEqual(second.HtlcPoint) {\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif !first.FirstCommitmentPoint.IsEqual(\n\t\t\tsecond.FirstCommitmentPoint) {\n\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif !bytes.Equal(first.UpfrontShutdownScript,\n\t\t\tsecond.UpfrontShutdownScript) {\n\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif shouldPanic {\n\t\t\tt.Fatal(\"original message and deseralized message \" +\n\t\t\t\t\"are not equal\")\n\t\t}\n\t})\n}\n",
      "length": 2662,
      "tokens": 348,
      "embedding": []
    },
    {
      "slug": "func FuzzAnnounceSignatures(f *testing.F) {",
      "content": "func FuzzAnnounceSignatures(f *testing.F) {\n\tf.Fuzz(func(t *testing.T, data []byte) {\n\t\t// Prefix with MsgAnnounceSignatures.\n\t\tdata = prefixWithMsgType(data, MsgAnnounceSignatures)\n\n\t\t// Pass the message into our general fuzz harness for wire\n\t\t// messages!\n\t\tharness(t, data)\n\t})\n}\n",
      "length": 231,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func FuzzChannelAnnouncement(f *testing.F) {",
      "content": "func FuzzChannelAnnouncement(f *testing.F) {\n\tf.Fuzz(func(t *testing.T, data []byte) {\n\t\t// Prefix with MsgChannelAnnouncement.\n\t\tdata = prefixWithMsgType(data, MsgChannelAnnouncement)\n\n\t\t// Pass the message into our general fuzz harness for wire\n\t\t// messages!\n\t\tharness(t, data)\n\t})\n}\n",
      "length": 233,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func FuzzChannelReestablish(f *testing.F) {",
      "content": "func FuzzChannelReestablish(f *testing.F) {\n\tf.Fuzz(func(t *testing.T, data []byte) {\n\t\t// Prefix with MsgChannelReestablish.\n\t\tdata = prefixWithMsgType(data, MsgChannelReestablish)\n\n\t\t// Pass the message into our general fuzz harness for wire\n\t\t// messages!\n\t\tharness(t, data)\n\t})\n}\n",
      "length": 231,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func FuzzChannelUpdate(f *testing.F) {",
      "content": "func FuzzChannelUpdate(f *testing.F) {\n\tf.Fuzz(func(t *testing.T, data []byte) {\n\t\t// Prefix with MsgChannelUpdate.\n\t\tdata = prefixWithMsgType(data, MsgChannelUpdate)\n\n\t\t// Pass the message into our general fuzz harness for wire\n\t\t// messages!\n\t\tharness(t, data)\n\t})\n}\n",
      "length": 221,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func FuzzClosingSigned(f *testing.F) {",
      "content": "func FuzzClosingSigned(f *testing.F) {\n\tf.Fuzz(func(t *testing.T, data []byte) {\n\t\t// Prefix with MsgClosingSigned.\n\t\tdata = prefixWithMsgType(data, MsgClosingSigned)\n\n\t\t// Pass the message into our general fuzz harness for wire\n\t\t// messages!\n\t\tharness(t, data)\n\t})\n}\n",
      "length": 221,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func FuzzCommitSig(f *testing.F) {",
      "content": "func FuzzCommitSig(f *testing.F) {\n\tf.Fuzz(func(t *testing.T, data []byte) {\n\t\t// Prefix with MsgCommitSig.\n\t\tdata = prefixWithMsgType(data, MsgCommitSig)\n\n\t\t// Pass the message into our general fuzz harness for wire\n\t\t// messages!\n\t\tharness(t, data)\n\t})\n}\n",
      "length": 213,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func FuzzError(f *testing.F) {",
      "content": "func FuzzError(f *testing.F) {\n\tf.Fuzz(func(t *testing.T, data []byte) {\n\t\t// Prefix with MsgError.\n\t\tdata = prefixWithMsgType(data, MsgError)\n\n\t\t// Pass the message into our general fuzz harness for wire\n\t\t// messages!\n\t\tharness(t, data)\n\t})\n}\n",
      "length": 205,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func FuzzWarning(f *testing.F) {",
      "content": "func FuzzWarning(f *testing.F) {\n\tf.Fuzz(func(t *testing.T, data []byte) {\n\t\t// Prefix with MsgWarning.\n\t\tdata = prefixWithMsgType(data, MsgWarning)\n\n\t\t// Pass the message into our general fuzz harness for wire\n\t\t// messages!\n\t\tharness(t, data)\n\t})\n}\n",
      "length": 209,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func FuzzFundingCreated(f *testing.F) {",
      "content": "func FuzzFundingCreated(f *testing.F) {\n\tf.Fuzz(func(t *testing.T, data []byte) {\n\t\t// Prefix with MsgFundingCreated.\n\t\tdata = prefixWithMsgType(data, MsgFundingCreated)\n\n\t\t// Pass the message into our general fuzz harness for wire\n\t\t// messages!\n\t\tharness(t, data)\n\t})\n}\n",
      "length": 223,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func FuzzFundingLocked(f *testing.F) {",
      "content": "func FuzzFundingLocked(f *testing.F) {\n\tf.Fuzz(func(t *testing.T, data []byte) {\n\t\t// Prefix with MsgFundingLocked.\n\t\tdata = prefixWithMsgType(data, MsgFundingLocked)\n\n\t\t// Pass the message into our general fuzz harness for wire\n\t\t// messages!\n\t\tharness(t, data)\n\t})\n}\n",
      "length": 221,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func FuzzFundingSigned(f *testing.F) {",
      "content": "func FuzzFundingSigned(f *testing.F) {\n\tf.Fuzz(func(t *testing.T, data []byte) {\n\t\t// Prefix with MsgFundingSigned.\n\t\tdata = prefixWithMsgType(data, MsgFundingSigned)\n\n\t\t// Pass the message into our general fuzz harness for wire\n\t\t// messages!\n\t\tharness(t, data)\n\t})\n}\n",
      "length": 221,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func FuzzGossipTimestampRange(f *testing.F) {",
      "content": "func FuzzGossipTimestampRange(f *testing.F) {\n\tf.Fuzz(func(t *testing.T, data []byte) {\n\t\t// Prefix with MsgGossipTimestampRange.\n\t\tdata = prefixWithMsgType(data, MsgGossipTimestampRange)\n\n\t\t// Pass the message into our general fuzz harness for wire\n\t\t// messages!\n\t\tharness(t, data)\n\t})\n}\n",
      "length": 235,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func FuzzInit(f *testing.F) {",
      "content": "func FuzzInit(f *testing.F) {\n\tf.Fuzz(func(t *testing.T, data []byte) {\n\t\t// Prefix with MsgInit.\n\t\tdata = prefixWithMsgType(data, MsgInit)\n\n\t\t// Pass the message into our general fuzz harness for wire\n\t\t// messages!\n\t\tharness(t, data)\n\t})\n}\n",
      "length": 203,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func FuzzNodeAnnouncement(f *testing.F) {",
      "content": "func FuzzNodeAnnouncement(f *testing.F) {\n\tf.Fuzz(func(t *testing.T, data []byte) {\n\t\t// Prefix with MsgNodeAnnouncement.\n\t\tdata = prefixWithMsgType(data, MsgNodeAnnouncement)\n\n\t\t// We have to do this here instead of in harness so that\n\t\t// reflect.DeepEqual isn't called. Address (de)serialization\n\t\t// messes up the fuzzing assertions.\n\n\t\t// Create a reader with the byte array.\n\t\tr := bytes.NewReader(data)\n\n\t\t// Make sure byte array length (excluding 2 bytes for message\n\t\t// type) is less than max payload size for the wire message.\n\t\tpayloadLen := uint32(len(data)) - 2\n\t\tif payloadLen > MaxMsgBody {\n\t\t\treturn\n\t\t}\n\n\t\tmsg, err := ReadMessage(r, 0)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\t// We will serialize the message into a new bytes buffer.\n\t\tvar b bytes.Buffer\n\t\tif _, err := WriteMessage(&b, msg, 0); err != nil {\n\t\t\t// Could not serialize message into bytes buffer, panic\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// Deserialize the message from the serialized bytes buffer, and\n\t\t// then assert that the original message is equal to the newly\n\t\t// deserialized message.\n\t\tnewMsg, err := ReadMessage(&b, 0)\n\t\tif err != nil {\n\t\t\t// Could not deserialize message from bytes buffer,\n\t\t\t// panic\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// Now compare every field instead of using reflect.DeepEqual\n\t\t// for the Addresses field.\n\t\tvar shouldPanic bool\n\t\tfirst, ok := msg.(*NodeAnnouncement)\n\t\tif !ok {\n\t\t\tt.Fatal(\"message was not NodeAnnouncement\")\n\t\t}\n\t\tsecond, ok := newMsg.(*NodeAnnouncement)\n\t\tif !ok {\n\t\t\tt.Fatal(\"new message was not NodeAnnouncement\")\n\t\t}\n\n\t\tif !bytes.Equal(first.Signature[:], second.Signature[:]) {\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif !reflect.DeepEqual(first.Features, second.Features) {\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif first.Timestamp != second.Timestamp {\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif !bytes.Equal(first.NodeID[:], second.NodeID[:]) {\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif !reflect.DeepEqual(first.RGBColor, second.RGBColor) {\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif !bytes.Equal(first.Alias[:], second.Alias[:]) {\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif len(first.Addresses) != len(second.Addresses) {\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tfor i := range first.Addresses {\n\t\t\tif first.Addresses[i].String() !=\n\t\t\t\tsecond.Addresses[i].String() {\n\n\t\t\t\tshouldPanic = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif !reflect.DeepEqual(first.ExtraOpaqueData,\n\t\t\tsecond.ExtraOpaqueData) {\n\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif shouldPanic {\n\t\t\tt.Fatal(\"original message and deserialized message \" +\n\t\t\t\t\"are not equal\")\n\t\t}\n\t})\n}\n",
      "length": 2323,
      "tokens": 320,
      "embedding": []
    },
    {
      "slug": "func FuzzOpenChannel(f *testing.F) {",
      "content": "func FuzzOpenChannel(f *testing.F) {\n\tf.Fuzz(func(t *testing.T, data []byte) {\n\t\t// Prefix with MsgOpenChannel.\n\t\tdata = prefixWithMsgType(data, MsgOpenChannel)\n\n\t\t// We have to do this here instead of in harness so that\n\t\t// reflect.DeepEqual isn't called. Because of the\n\t\t// UpfrontShutdownScript encoding, the first message and second\n\t\t// message aren't deeply equal since the first has a nil slice\n\t\t// and the other has an empty slice.\n\n\t\t// Create a reader with the byte array.\n\t\tr := bytes.NewReader(data)\n\n\t\t// Make sure byte array length (excluding 2 bytes for message\n\t\t// type) is less than max payload size for the wire message.\n\t\tpayloadLen := uint32(len(data)) - 2\n\t\tif payloadLen > MaxMsgBody {\n\t\t\treturn\n\t\t}\n\n\t\tmsg, err := ReadMessage(r, 0)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\t// We will serialize the message into a new bytes buffer.\n\t\tvar b bytes.Buffer\n\t\tif _, err := WriteMessage(&b, msg, 0); err != nil {\n\t\t\t// Could not serialize message into bytes buffer, panic\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// Deserialize the message from the serialized bytes buffer, and\n\t\t// then assert that the original message is equal to the newly\n\t\t// deserialized message.\n\t\tnewMsg, err := ReadMessage(&b, 0)\n\t\tif err != nil {\n\t\t\t// Could not deserialize message from bytes buffer,\n\t\t\t// panic\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// Now compare every field instead of using reflect.DeepEqual.\n\t\t// For UpfrontShutdownScript, we only compare bytes. This\n\t\t// probably takes up more branches than necessary, but that's\n\t\t// fine for now.\n\t\tvar shouldPanic bool\n\t\tfirst, ok := msg.(*OpenChannel)\n\t\tif !ok {\n\t\t\tt.Fatal(\"message was not OpenChannel\")\n\t\t}\n\t\tsecond, ok := newMsg.(*OpenChannel)\n\t\tif !ok {\n\t\t\tt.Fatal(\"new message was not OpenChannel\")\n\t\t}\n\n\t\tif !first.ChainHash.IsEqual(&second.ChainHash) {\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif !bytes.Equal(first.PendingChannelID[:],\n\t\t\tsecond.PendingChannelID[:]) {\n\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif first.FundingAmount != second.FundingAmount {\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif first.PushAmount != second.PushAmount {\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif first.DustLimit != second.DustLimit {\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif first.MaxValueInFlight != second.MaxValueInFlight {\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif first.ChannelReserve != second.ChannelReserve {\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif first.HtlcMinimum != second.HtlcMinimum {\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif first.FeePerKiloWeight != second.FeePerKiloWeight {\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif first.CsvDelay != second.CsvDelay {\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif first.MaxAcceptedHTLCs != second.MaxAcceptedHTLCs {\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif !first.FundingKey.IsEqual(second.FundingKey) {\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif !first.RevocationPoint.IsEqual(second.RevocationPoint) {\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif !first.PaymentPoint.IsEqual(second.PaymentPoint) {\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif !first.DelayedPaymentPoint.IsEqual(\n\t\t\tsecond.DelayedPaymentPoint) {\n\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif !first.HtlcPoint.IsEqual(second.HtlcPoint) {\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif !first.FirstCommitmentPoint.IsEqual(\n\t\t\tsecond.FirstCommitmentPoint) {\n\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif first.ChannelFlags != second.ChannelFlags {\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif !bytes.Equal(first.UpfrontShutdownScript,\n\t\t\tsecond.UpfrontShutdownScript) {\n\n\t\t\tshouldPanic = true\n\t\t}\n\n\t\tif shouldPanic {\n\t\t\tt.Fatal(\"original message and deserialized message \" +\n\t\t\t\t\"are not equal\")\n\t\t}\n\t})\n}\n",
      "length": 3253,
      "tokens": 434,
      "embedding": []
    },
    {
      "slug": "func FuzzPing(f *testing.F) {",
      "content": "func FuzzPing(f *testing.F) {\n\tf.Fuzz(func(t *testing.T, data []byte) {\n\t\t// Prefix with MsgPing.\n\t\tdata = prefixWithMsgType(data, MsgPing)\n\n\t\t// Pass the message into our general fuzz harness for wire\n\t\t// messages!\n\t\tharness(t, data)\n\t})\n}\n",
      "length": 203,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func FuzzPong(f *testing.F) {",
      "content": "func FuzzPong(f *testing.F) {\n\tf.Fuzz(func(t *testing.T, data []byte) {\n\t\t// Prefix with MsgPong.\n\t\tdata = prefixWithMsgType(data, MsgPong)\n\n\t\t// Pass the message into our general fuzz harness for wire\n\t\t// messages!\n\t\tharness(t, data)\n\t})\n}\n",
      "length": 203,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func FuzzQueryChannelRange(f *testing.F) {",
      "content": "func FuzzQueryChannelRange(f *testing.F) {\n\tf.Fuzz(func(t *testing.T, data []byte) {\n\t\t// Prefix with MsgQueryChannelRange.\n\t\tdata = prefixWithMsgType(data, MsgQueryChannelRange)\n\n\t\t// Pass the message into our general fuzz harness for wire\n\t\t// messages!\n\t\tharness(t, data)\n\t})\n}\n",
      "length": 229,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func FuzzZlibQueryShortChanIDs(f *testing.F) {",
      "content": "func FuzzZlibQueryShortChanIDs(f *testing.F) {\n\tf.Fuzz(func(t *testing.T, data []byte) {\n\t\tvar buf bytes.Buffer\n\t\tzlibWriter := zlib.NewWriter(&buf)\n\t\t_, err := zlibWriter.Write(data)\n\t\tif err != nil {\n\t\t\t// Zlib bug?\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif err := zlibWriter.Close(); err != nil {\n\t\t\t// Zlib bug?\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tcompressedPayload := buf.Bytes()\n\n\t\tchainhash := []byte(\"00000000000000000000000000000000\")\n\t\tnumBytesInBody := len(compressedPayload) + 1\n\t\tzlibByte := []byte(\"\\x01\")\n\n\t\tbodyBytes := make([]byte, 2)\n\t\tbinary.BigEndian.PutUint16(bodyBytes, uint16(numBytesInBody))\n\n\t\tpayload := chainhash\n\t\tpayload = append(payload, bodyBytes...)\n\t\tpayload = append(payload, zlibByte...)\n\t\tpayload = append(payload, compressedPayload...)\n\n\t\t// Prefix with MsgQueryShortChanIDs.\n\t\tpayload = prefixWithMsgType(payload, MsgQueryShortChanIDs)\n\n\t\t// Pass the message into our general fuzz harness for wire\n\t\t// messages!\n\t\tharness(t, payload)\n\t})\n}\n",
      "length": 867,
      "tokens": 98,
      "embedding": []
    },
    {
      "slug": "func FuzzQueryShortChanIDs(f *testing.F) {",
      "content": "func FuzzQueryShortChanIDs(f *testing.F) {\n\tf.Fuzz(func(t *testing.T, data []byte) {\n\t\t// Prefix with MsgQueryShortChanIDs.\n\t\tdata = prefixWithMsgType(data, MsgQueryShortChanIDs)\n\n\t\t// Pass the message into our general fuzz harness for wire\n\t\t// messages!\n\t\tharness(t, data)\n\t})\n}\n",
      "length": 229,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func FuzzZlibReplyChannelRange(f *testing.F) {",
      "content": "func FuzzZlibReplyChannelRange(f *testing.F) {\n\tf.Fuzz(func(t *testing.T, data []byte) {\n\t\tvar buf bytes.Buffer\n\t\tzlibWriter := zlib.NewWriter(&buf)\n\t\t_, err := zlibWriter.Write(data)\n\t\tif err != nil {\n\t\t\t// Zlib bug?\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif err := zlibWriter.Close(); err != nil {\n\t\t\t// Zlib bug?\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tcompressedPayload := buf.Bytes()\n\n\t\t// Initialize some []byte vars which will prefix our payload\n\t\tchainhash := []byte(\"00000000000000000000000000000000\")\n\t\tfirstBlockHeight := []byte(\"\\x00\\x00\\x00\\x00\")\n\t\tnumBlocks := []byte(\"\\x00\\x00\\x00\\x00\")\n\t\tcompleteByte := []byte(\"\\x00\")\n\n\t\tnumBytesInBody := len(compressedPayload) + 1\n\t\tzlibByte := []byte(\"\\x01\")\n\n\t\tbodyBytes := make([]byte, 2)\n\t\tbinary.BigEndian.PutUint16(bodyBytes, uint16(numBytesInBody))\n\n\t\tpayload := chainhash\n\t\tpayload = append(payload, firstBlockHeight...)\n\t\tpayload = append(payload, numBlocks...)\n\t\tpayload = append(payload, completeByte...)\n\t\tpayload = append(payload, bodyBytes...)\n\t\tpayload = append(payload, zlibByte...)\n\t\tpayload = append(payload, compressedPayload...)\n\n\t\t// Prefix with MsgReplyChannelRange.\n\t\tpayload = prefixWithMsgType(payload, MsgReplyChannelRange)\n\n\t\t// Pass the message into our general fuzz harness for wire\n\t\t// messages!\n\t\tharness(t, payload)\n\t})\n}\n",
      "length": 1183,
      "tokens": 129,
      "embedding": []
    },
    {
      "slug": "func FuzzReplyChannelRange(f *testing.F) {",
      "content": "func FuzzReplyChannelRange(f *testing.F) {\n\tf.Fuzz(func(t *testing.T, data []byte) {\n\t\t// Prefix with MsgReplyChannelRange.\n\t\tdata = prefixWithMsgType(data, MsgReplyChannelRange)\n\n\t\t// Pass the message into our general fuzz harness for wire\n\t\t// messages!\n\t\tharness(t, data)\n\t})\n}\n",
      "length": 229,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func FuzzReplyShortChanIDsEnd(f *testing.F) {",
      "content": "func FuzzReplyShortChanIDsEnd(f *testing.F) {\n\tf.Fuzz(func(t *testing.T, data []byte) {\n\t\t// Prefix with MsgReplyShortChanIDsEnd.\n\t\tdata = prefixWithMsgType(data, MsgReplyShortChanIDsEnd)\n\n\t\t// Pass the message into our general fuzz harness for wire\n\t\t// messages!\n\t\tharness(t, data)\n\t})\n}\n",
      "length": 235,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func FuzzRevokeAndAck(f *testing.F) {",
      "content": "func FuzzRevokeAndAck(f *testing.F) {\n\tf.Fuzz(func(t *testing.T, data []byte) {\n\t\t// Prefix with MsgRevokeAndAck.\n\t\tdata = prefixWithMsgType(data, MsgRevokeAndAck)\n\n\t\t// Pass the message into our general fuzz harness for wire\n\t\t// messages!\n\t\tharness(t, data)\n\t})\n}\n",
      "length": 219,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func FuzzShutdown(f *testing.F) {",
      "content": "func FuzzShutdown(f *testing.F) {\n\tf.Fuzz(func(t *testing.T, data []byte) {\n\t\t// Prefix with MsgShutdown.\n\t\tdata = prefixWithMsgType(data, MsgShutdown)\n\n\t\t// Pass the message into our general fuzz harness for wire\n\t\t// messages!\n\t\tharness(t, data)\n\t})\n}\n",
      "length": 211,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func FuzzUpdateAddHTLC(f *testing.F) {",
      "content": "func FuzzUpdateAddHTLC(f *testing.F) {\n\tf.Fuzz(func(t *testing.T, data []byte) {\n\t\t// Prefix with MsgUpdateAddHTLC.\n\t\tdata = prefixWithMsgType(data, MsgUpdateAddHTLC)\n\n\t\t// Pass the message into our general fuzz harness for wire\n\t\t// messages!\n\t\tharness(t, data)\n\t})\n}\n",
      "length": 221,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func FuzzUpdateFailHTLC(f *testing.F) {",
      "content": "func FuzzUpdateFailHTLC(f *testing.F) {\n\tf.Fuzz(func(t *testing.T, data []byte) {\n\t\t// Prefix with MsgUpdateFailHTLC.\n\t\tdata = prefixWithMsgType(data, MsgUpdateFailHTLC)\n\n\t\t// Pass the message into our general fuzz harness for wire\n\t\t// messages!\n\t\tharness(t, data)\n\t})\n}\n",
      "length": 223,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func FuzzUpdateFailMalformedHTLC(f *testing.F) {",
      "content": "func FuzzUpdateFailMalformedHTLC(f *testing.F) {\n\tf.Fuzz(func(t *testing.T, data []byte) {\n\t\t// Prefix with MsgUpdateFailMalformedHTLC.\n\t\tdata = prefixWithMsgType(data, MsgUpdateFailMalformedHTLC)\n\n\t\t// Pass the message into our general fuzz harness for wire\n\t\t// messages!\n\t\tharness(t, data)\n\t})\n}\n",
      "length": 241,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func FuzzUpdateFee(f *testing.F) {",
      "content": "func FuzzUpdateFee(f *testing.F) {\n\tf.Fuzz(func(t *testing.T, data []byte) {\n\t\t// Prefix with MsgUpdateFee.\n\t\tdata = prefixWithMsgType(data, MsgUpdateFee)\n\n\t\t// Pass the message into our general fuzz harness for wire\n\t\t// messages!\n\t\tharness(t, data)\n\t})\n}\n",
      "length": 213,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func FuzzUpdateFulfillHTLC(f *testing.F) {",
      "content": "func FuzzUpdateFulfillHTLC(f *testing.F) {\n\tf.Fuzz(func(t *testing.T, data []byte) {\n\t\t// Prefix with MsgUpdateFulFillHTLC.\n\t\tdata = prefixWithMsgType(data, MsgUpdateFulfillHTLC)\n\n\t\t// Pass the message into our general fuzz harness for wire\n\t\t// messages!\n\t\tharness(t, data)\n\t})\n}\n",
      "length": 229,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func FuzzCustomMessage(f *testing.F) {",
      "content": "func FuzzCustomMessage(f *testing.F) {\n\tf.Fuzz(func(t *testing.T, data []byte, customMessageType uint16) {\n\t\tif customMessageType < uint16(CustomTypeStart) {\n\t\t\tcustomMessageType += uint16(CustomTypeStart)\n\t\t}\n\n\t\t// Prefix with CustomMessage.\n\t\tdata = prefixWithMsgType(data, MessageType(customMessageType))\n\n\t\t// Pass the message into our general fuzz harness for wire\n\t\t// messages!\n\t\tharness(t, data)\n\t})\n}\n",
      "length": 358,
      "tokens": 41,
      "embedding": []
    }
  ]
}