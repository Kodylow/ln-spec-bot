{
  "filepath": "../implementations/go/lnd/lnwallet/channel_test.go",
  "package": "lnwallet",
  "sections": [
    {
      "slug": "func createHTLC(id int, amount lnwire.MilliSatoshi) (*lnwire.UpdateAddHTLC, [32]byte) {",
      "content": "func createHTLC(id int, amount lnwire.MilliSatoshi) (*lnwire.UpdateAddHTLC, [32]byte) {\n\tpreimage := bytes.Repeat([]byte{byte(id)}, 32)\n\tpaymentHash := sha256.Sum256(preimage)\n\n\tvar returnPreimage [32]byte\n\tcopy(returnPreimage[:], preimage)\n\n\treturn &lnwire.UpdateAddHTLC{\n\t\tID:          uint64(id),\n\t\tPaymentHash: paymentHash,\n\t\tAmount:      amount,\n\t\tExpiry:      uint32(5),\n\t}, returnPreimage\n}\n",
      "length": 297,
      "tokens": 25,
      "embedding": []
    },
    {
      "slug": "func assertOutputExistsByValue(t *testing.T, commitTx *wire.MsgTx,",
      "content": "func assertOutputExistsByValue(t *testing.T, commitTx *wire.MsgTx,\n\tvalue btcutil.Amount) {\n\n\tfor _, txOut := range commitTx.TxOut {\n\t\tif txOut.Value == int64(value) {\n\t\t\treturn\n\t\t}\n\t}\n\n\tt.Fatalf(\"unable to find output of value %v within tx %v\", value,\n\t\tspew.Sdump(commitTx))\n}\n\n// testAddSettleWorkflow tests a simple channel scenario where Alice and Bob\n// add, the settle an HTLC between themselves.",
      "length": 323,
      "tokens": 50,
      "embedding": []
    },
    {
      "slug": "func testAddSettleWorkflow(t *testing.T, tweakless,",
      "content": "func testAddSettleWorkflow(t *testing.T, tweakless,\n\tstoreFinalHtlcResolutions bool) {\n\n\t// Create a test channel which will be used for the duration of this\n\t// unittest. The channel will be funded evenly with Alice having 5 BTC,\n\t// and Bob having 5 BTC.\n\tchanType := channeldb.SingleFunderTweaklessBit\n\tif !tweakless {\n\t\tchanType = channeldb.SingleFunderBit\n\t}\n\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, chanType,\n\t\tchanneldb.OptionStoreFinalHtlcResolutions(\n\t\t\tstoreFinalHtlcResolutions,\n\t\t),\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\tpaymentPreimage := bytes.Repeat([]byte{1}, 32)\n\tpaymentHash := sha256.Sum256(paymentPreimage)\n\thtlcAmt := lnwire.NewMSatFromSatoshis(btcutil.SatoshiPerBitcoin)\n\thtlc := &lnwire.UpdateAddHTLC{\n\t\tPaymentHash: paymentHash,\n\t\tAmount:      htlcAmt,\n\t\tExpiry:      uint32(5),\n\t}\n\n\t// First Alice adds the outgoing HTLC to her local channel's state\n\t// update log. Then Alice sends this wire message over to Bob who adds\n\t// this htlc to his remote state update log.\n\taliceHtlcIndex, err := aliceChannel.AddHTLC(htlc, nil)\n\trequire.NoError(t, err, \"unable to add htlc\")\n\n\tbobHtlcIndex, err := bobChannel.ReceiveHTLC(htlc)\n\trequire.NoError(t, err, \"unable to recv htlc\")\n\n\t// Next alice commits this change by sending a signature message. Since\n\t// we expect the messages to be ordered, Bob will receive the HTLC we\n\t// just sent before he receives this signature, so the signature will\n\t// cover the HTLC.\n\taliceSig, aliceHtlcSigs, _, err := aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"alice unable to sign commitment\")\n\n\t// Bob receives this signature message, and checks that this covers the\n\t// state he has in his remote log. This includes the HTLC just sent\n\t// from Alice.\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\trequire.NoError(t, err, \"bob unable to process alice's new commitment\")\n\n\t// Bob revokes his prior commitment given to him by Alice, since he now\n\t// has a valid signature for a newer commitment.\n\tbobRevocation, _, _, err := bobChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"unable to generate bob revocation\")\n\n\t// Bob finally send a signature for Alice's commitment transaction.\n\t// This signature will cover the HTLC, since Bob will first send the\n\t// revocation just created. The revocation also acks every received\n\t// HTLC up to the point where Alice sent here signature.\n\tbobSig, bobHtlcSigs, _, err := bobChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"bob unable to sign alice's commitment\")\n\n\t// Alice then processes this revocation, sending her own revocation for\n\t// her prior commitment transaction. Alice shouldn't have any HTLCs to\n\t// forward since she's sending an outgoing HTLC.\n\tfwdPkg, _, _, _, err := aliceChannel.ReceiveRevocation(bobRevocation)\n\trequire.NoError(t, err, \"alice unable to process bob's revocation\")\n\tif len(fwdPkg.Adds) != 0 {\n\t\tt.Fatalf(\"alice forwards %v add htlcs, should forward none\",\n\t\t\tlen(fwdPkg.Adds))\n\t}\n\tif len(fwdPkg.SettleFails) != 0 {\n\t\tt.Fatalf(\"alice forwards %v settle/fail htlcs, \"+\n\t\t\t\"should forward none\", len(fwdPkg.SettleFails))\n\t}\n\n\t// Alice then processes bob's signature, and since she just received\n\t// the revocation, she expect this signature to cover everything up to\n\t// the point where she sent her signature, including the HTLC.\n\terr = aliceChannel.ReceiveNewCommitment(bobSig, bobHtlcSigs)\n\trequire.NoError(t, err, \"alice unable to process bob's new commitment\")\n\n\t// Alice then generates a revocation for bob.\n\taliceRevocation, _, _, err := aliceChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"unable to revoke alice channel\")\n\n\t// Finally Bob processes Alice's revocation, at this point the new HTLC\n\t// is fully locked in within both commitment transactions. Bob should\n\t// also be able to forward an HTLC now that the HTLC has been locked\n\t// into both commitment transactions.\n\tfwdPkg, _, _, _, err = bobChannel.ReceiveRevocation(aliceRevocation)\n\trequire.NoError(t, err, \"bob unable to process alice's revocation\")\n\tif len(fwdPkg.Adds) != 1 {\n\t\tt.Fatalf(\"bob forwards %v add htlcs, should only forward one\",\n\t\t\tlen(fwdPkg.Adds))\n\t}\n\tif len(fwdPkg.SettleFails) != 0 {\n\t\tt.Fatalf(\"bob forwards %v settle/fail htlcs, \"+\n\t\t\t\"should forward none\", len(fwdPkg.SettleFails))\n\t}\n\n\t// At this point, both sides should have the proper number of satoshis\n\t// sent, and commitment height updated within their local channel\n\t// state.\n\taliceSent := lnwire.MilliSatoshi(0)\n\tbobSent := lnwire.MilliSatoshi(0)\n\n\tif aliceChannel.channelState.TotalMSatSent != aliceSent {\n\t\tt.Fatalf(\"alice has incorrect milli-satoshis sent: %v vs %v\",\n\t\t\taliceChannel.channelState.TotalMSatSent, aliceSent)\n\t}\n\tif aliceChannel.channelState.TotalMSatReceived != bobSent {\n\t\tt.Fatalf(\"alice has incorrect milli-satoshis received %v vs %v\",\n\t\t\taliceChannel.channelState.TotalMSatReceived, bobSent)\n\t}\n\tif bobChannel.channelState.TotalMSatSent != bobSent {\n\t\tt.Fatalf(\"bob has incorrect milli-satoshis sent %v vs %v\",\n\t\t\tbobChannel.channelState.TotalMSatSent, bobSent)\n\t}\n\tif bobChannel.channelState.TotalMSatReceived != aliceSent {\n\t\tt.Fatalf(\"bob has incorrect milli-satoshis received %v vs %v\",\n\t\t\tbobChannel.channelState.TotalMSatReceived, aliceSent)\n\t}\n\tif bobChannel.currentHeight != 1 {\n\t\tt.Fatalf(\"bob has incorrect commitment height, %v vs %v\",\n\t\t\tbobChannel.currentHeight, 1)\n\t}\n\tif aliceChannel.currentHeight != 1 {\n\t\tt.Fatalf(\"alice has incorrect commitment height, %v vs %v\",\n\t\t\taliceChannel.currentHeight, 1)\n\t}\n\n\t// Both commitment transactions should have three outputs, and one of\n\t// them should be exactly the amount of the HTLC.\n\tif len(aliceChannel.channelState.LocalCommitment.CommitTx.TxOut) != 3 {\n\t\tt.Fatalf(\"alice should have three commitment outputs, instead \"+\n\t\t\t\"have %v\",\n\t\t\tlen(aliceChannel.channelState.LocalCommitment.CommitTx.TxOut))\n\t}\n\tif len(bobChannel.channelState.LocalCommitment.CommitTx.TxOut) != 3 {\n\t\tt.Fatalf(\"bob should have three commitment outputs, instead \"+\n\t\t\t\"have %v\",\n\t\t\tlen(bobChannel.channelState.LocalCommitment.CommitTx.TxOut))\n\t}\n\tassertOutputExistsByValue(t,\n\t\taliceChannel.channelState.LocalCommitment.CommitTx,\n\t\thtlcAmt.ToSatoshis())\n\tassertOutputExistsByValue(t,\n\t\tbobChannel.channelState.LocalCommitment.CommitTx,\n\t\thtlcAmt.ToSatoshis())\n\n\t// Now we'll repeat a similar exchange, this time with Bob settling the\n\t// HTLC once he learns of the preimage.\n\tvar preimage [32]byte\n\tcopy(preimage[:], paymentPreimage)\n\terr = bobChannel.SettleHTLC(preimage, bobHtlcIndex, nil, nil, nil)\n\trequire.NoError(t, err, \"bob unable to settle inbound htlc\")\n\n\terr = aliceChannel.ReceiveHTLCSettle(preimage, aliceHtlcIndex)\n\tif err != nil {\n\t\tt.Fatalf(\"alice unable to accept settle of outbound htlc: %v\", err)\n\t}\n\n\tbobSig2, bobHtlcSigs2, _, err := bobChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"bob unable to sign settle commitment\")\n\terr = aliceChannel.ReceiveNewCommitment(bobSig2, bobHtlcSigs2)\n\trequire.NoError(t, err, \"alice unable to process bob's new commitment\")\n\n\taliceRevocation2, _, _, err := aliceChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"alice unable to generate revocation\")\n\taliceSig2, aliceHtlcSigs2, _, err := aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"alice unable to sign new commitment\")\n\n\tfwdPkg, _, _, _, err = bobChannel.ReceiveRevocation(aliceRevocation2)\n\trequire.NoError(t, err, \"bob unable to process alice's revocation\")\n\tif len(fwdPkg.Adds) != 0 {\n\t\tt.Fatalf(\"bob forwards %v add htlcs, should forward none\",\n\t\t\tlen(fwdPkg.Adds))\n\t}\n\tif len(fwdPkg.SettleFails) != 0 {\n\t\tt.Fatalf(\"bob forwards %v settle/fail htlcs, \"+\n\t\t\t\"should forward none\", len(fwdPkg.SettleFails))\n\t}\n\n\terr = bobChannel.ReceiveNewCommitment(aliceSig2, aliceHtlcSigs2)\n\trequire.NoError(t, err, \"bob unable to process alice's new commitment\")\n\n\tbobRevocation2, _, finalHtlcs, err := bobChannel.\n\t\tRevokeCurrentCommitment()\n\trequire.NoError(t, err, \"bob unable to revoke commitment\")\n\n\t// Check finalHtlcs for the expected final resolution.\n\trequire.Len(t, finalHtlcs, 1, \"final htlc expected\")\n\tfor htlcID, settled := range finalHtlcs {\n\t\trequire.True(t, settled, \"final settle expected\")\n\n\t\t// Assert that final resolution was stored in Bob's database if\n\t\t// storage is enabled.\n\t\tfinalInfo, err := bobChannel.channelState.Db.LookupFinalHtlc(\n\t\t\tbobChannel.ShortChanID(), htlcID,\n\t\t)\n\t\tif storeFinalHtlcResolutions {\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.True(t, finalInfo.Offchain)\n\t\t\trequire.True(t, finalInfo.Settled)\n\t\t} else {\n\t\t\trequire.ErrorIs(t, err, channeldb.ErrHtlcUnknown)\n\t\t}\n\t}\n\n\tfwdPkg, _, _, _, err = aliceChannel.ReceiveRevocation(bobRevocation2)\n\trequire.NoError(t, err, \"alice unable to process bob's revocation\")\n\tif len(fwdPkg.Adds) != 0 {\n\t\t// Alice should now be able to forward the settlement HTLC to\n\t\t// any down stream peers.\n\t\tt.Fatalf(\"alice should be forwarding an add HTLC, \"+\n\t\t\t\"instead forwarding %v: %v\", len(fwdPkg.Adds),\n\t\t\tspew.Sdump(fwdPkg.Adds))\n\t}\n\tif len(fwdPkg.SettleFails) != 1 {\n\t\tt.Fatalf(\"alice should be forwarding one settle/fails HTLC, \"+\n\t\t\t\"instead forwarding: %v\", len(fwdPkg.SettleFails))\n\t}\n\n\t// At this point, Bob should have 6 BTC settled, with Alice still\n\t// having 4 BTC. Alice's channel should show 1 BTC sent and Bob's\n\t// channel should show 1 BTC received. They should also be at\n\t// commitment height two, with the revocation window extended by 1 (5).\n\tmSatTransferred := lnwire.NewMSatFromSatoshis(btcutil.SatoshiPerBitcoin)\n\tif aliceChannel.channelState.TotalMSatSent != mSatTransferred {\n\t\tt.Fatalf(\"alice satoshis sent incorrect %v vs %v expected\",\n\t\t\taliceChannel.channelState.TotalMSatSent,\n\t\t\tmSatTransferred)\n\t}\n\tif aliceChannel.channelState.TotalMSatReceived != 0 {\n\t\tt.Fatalf(\"alice satoshis received incorrect %v vs %v expected\",\n\t\t\taliceChannel.channelState.TotalMSatReceived, 0)\n\t}\n\tif bobChannel.channelState.TotalMSatReceived != mSatTransferred {\n\t\tt.Fatalf(\"bob satoshis received incorrect %v vs %v expected\",\n\t\t\tbobChannel.channelState.TotalMSatReceived,\n\t\t\tmSatTransferred)\n\t}\n\tif bobChannel.channelState.TotalMSatSent != 0 {\n\t\tt.Fatalf(\"bob satoshis sent incorrect %v vs %v expected\",\n\t\t\tbobChannel.channelState.TotalMSatSent, 0)\n\t}\n\tif bobChannel.currentHeight != 2 {\n\t\tt.Fatalf(\"bob has incorrect commitment height, %v vs %v\",\n\t\t\tbobChannel.currentHeight, 2)\n\t}\n\tif aliceChannel.currentHeight != 2 {\n\t\tt.Fatalf(\"alice has incorrect commitment height, %v vs %v\",\n\t\t\taliceChannel.currentHeight, 2)\n\t}\n\n\t// The logs of both sides should now be cleared since the entry adding\n\t// the HTLC should have been removed once both sides receive the\n\t// revocation.\n\tif aliceChannel.localUpdateLog.Len() != 0 {\n\t\tt.Fatalf(\"alice's local not updated, should be empty, has %v \"+\n\t\t\t\"entries instead\", aliceChannel.localUpdateLog.Len())\n\t}\n\tif aliceChannel.remoteUpdateLog.Len() != 0 {\n\t\tt.Fatalf(\"alice's remote not updated, should be empty, has %v \"+\n\t\t\t\"entries instead\", aliceChannel.remoteUpdateLog.Len())\n\t}\n\tif len(aliceChannel.localUpdateLog.updateIndex) != 0 {\n\t\tt.Fatalf(\"alice's local log index not cleared, should be empty but \"+\n\t\t\t\"has %v entries\", len(aliceChannel.localUpdateLog.updateIndex))\n\t}\n\tif len(aliceChannel.remoteUpdateLog.updateIndex) != 0 {\n\t\tt.Fatalf(\"alice's remote log index not cleared, should be empty but \"+\n\t\t\t\"has %v entries\", len(aliceChannel.remoteUpdateLog.updateIndex))\n\t}\n}\n\n// TestSimpleAddSettleWorkflow tests a simple channel scenario wherein the\n// local node (Alice in this case) creates a new outgoing HTLC to bob, commits\n// this change, then bob immediately commits a settlement of the HTLC after the\n// initial add is fully committed in both commit chains.\n//\n// TODO(roasbeef): write higher level framework to exercise various states of\n// the state machine\n//   - DSL language perhaps?\n//   - constructed via input/output files",
      "length": 11512,
      "tokens": 1409,
      "embedding": []
    },
    {
      "slug": "func TestSimpleAddSettleWorkflow(t *testing.T) {",
      "content": "func TestSimpleAddSettleWorkflow(t *testing.T) {\n\tt.Parallel()\n\n\tfor _, tweakless := range []bool{true, false} {\n\t\ttweakless := tweakless\n\t\tt.Run(fmt.Sprintf(\"tweakless=%v\", tweakless), func(t *testing.T) {\n\t\t\ttestAddSettleWorkflow(t, tweakless, false)\n\t\t})\n\t}\n\n\tt.Run(\"storeFinalHtlcResolutions=true\", func(t *testing.T) {\n\t\ttestAddSettleWorkflow(t, false, true)\n\t})\n}\n\n// TestChannelZeroAddLocalHeight tests that we properly set the addCommitHeightLocal\n// field during state log restoration.\n//\n// The full state transition of this test is:\n//\n// Alice                   Bob\n//\n//\t-----add------>\n//\t-----sig------>\n//\t<----rev-------\n//\t<----sig-------\n//\t-----rev------>\n//\t<---settle-----\n//\t<----sig-------\n//\t-----rev------>\n//\t  *alice dies*\n//\t<----add-------\n//\tx----sig-------\n//\n// The last sig will be rejected if addCommitHeightLocal is not set for the\n// initial add that Alice sent. This test checks that this behavior does\n// not occur and that we properly set the addCommitHeightLocal field.",
      "length": 926,
      "tokens": 123,
      "embedding": []
    },
    {
      "slug": "func TestChannelZeroAddLocalHeight(t *testing.T) {",
      "content": "func TestChannelZeroAddLocalHeight(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a test channel so that we can test the buggy behavior.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err)\n\n\t// First we create an HTLC that Alice sends to Bob.\n\thtlc, _ := createHTLC(0, lnwire.MilliSatoshi(500000))\n\n\t// -----add----->\n\t_, err = aliceChannel.AddHTLC(htlc, nil)\n\trequire.NoError(t, err)\n\t_, err = bobChannel.ReceiveHTLC(htlc)\n\trequire.NoError(t, err)\n\n\t// Force a state transition to lock in this add on both commitments.\n\t// -----sig----->\n\t// <----rev------\n\t// <----sig------\n\t// -----rev----->\n\terr = ForceStateTransition(aliceChannel, bobChannel)\n\trequire.NoError(t, err)\n\n\t// Now Bob should fail the htlc back to Alice.\n\t// <----fail-----\n\terr = bobChannel.FailHTLC(0, []byte(\"failreason\"), nil, nil, nil)\n\trequire.NoError(t, err)\n\terr = aliceChannel.ReceiveFailHTLC(0, []byte(\"bad\"))\n\trequire.NoError(t, err)\n\n\t// Bob should send a commitment signature to Alice.\n\t// <----sig------\n\tbobSig, bobHtlcSigs, _, err := bobChannel.SignNextCommitment()\n\trequire.NoError(t, err)\n\n\terr = aliceChannel.ReceiveNewCommitment(bobSig, bobHtlcSigs)\n\trequire.NoError(t, err)\n\n\t// Alice should reply with a revocation.\n\t// -----rev----->\n\taliceRevocation, _, _, err := aliceChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err)\n\n\t_, _, _, _, err = bobChannel.ReceiveRevocation(aliceRevocation)\n\trequire.NoError(t, err)\n\n\t// We now restore Alice's channel as this was the point at which\n\t// the addCommitHeightLocal field wouldn't be set, causing a force\n\t// close.\n\tnewAliceChannel, err := NewLightningChannel(\n\t\taliceChannel.Signer, aliceChannel.channelState,\n\t\taliceChannel.sigPool,\n\t)\n\trequire.NoError(t, err)\n\n\t// Bob now sends an htlc to Alice\n\thtlc2, _ := createHTLC(0, lnwire.MilliSatoshi(500000))\n\n\t// <----add-----\n\t_, err = bobChannel.AddHTLC(htlc2, nil)\n\trequire.NoError(t, err)\n\t_, err = newAliceChannel.ReceiveHTLC(htlc2)\n\trequire.NoError(t, err)\n\n\t// Bob should now send a commitment signature to Alice.\n\t// <----sig-----\n\tbobSig, bobHtlcSigs, _, err = bobChannel.SignNextCommitment()\n\trequire.NoError(t, err)\n\n\t// Alice should accept the commitment. Previously she would\n\t// force close here.\n\terr = newAliceChannel.ReceiveNewCommitment(bobSig, bobHtlcSigs)\n\trequire.NoError(t, err)\n}\n\n// TestCheckCommitTxSize checks that estimation size of commitment\n// transaction with some degree of error corresponds to the actual size.",
      "length": 2370,
      "tokens": 283,
      "embedding": []
    },
    {
      "slug": "func TestCheckCommitTxSize(t *testing.T) {",
      "content": "func TestCheckCommitTxSize(t *testing.T) {\n\tt.Parallel()\n\n\tcheckSize := func(channel *LightningChannel, count int) {\n\t\t// Due to variable size of the signatures (70-73) in\n\t\t// witness script actual size of commitment transaction might\n\t\t// be lower on 6 weight.\n\t\tBaseCommitmentTxSizeEstimationError := 6\n\n\t\tcommitTx, err := channel.getSignedCommitTx()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to initiate alice force close: %v\", err)\n\t\t}\n\n\t\tactualCost := blockchain.GetTransactionWeight(btcutil.NewTx(commitTx))\n\t\testimatedCost := input.EstimateCommitTxWeight(count, false)\n\n\t\tdiff := int(estimatedCost - actualCost)\n\t\tif 0 > diff || BaseCommitmentTxSizeEstimationError < diff {\n\t\t\tt.Fatalf(\"estimation is wrong, diff: %v\", diff)\n\t\t}\n\n\t}\n\n\t// Create a test channel which will be used for the duration of this\n\t// unittest. The channel will be funded evenly with Alice having 5 BTC,\n\t// and Bob having 5 BTC.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// Check that weight estimation of the commitment transaction without\n\t// HTLCs is right.\n\tcheckSize(aliceChannel, 0)\n\tcheckSize(bobChannel, 0)\n\n\t// Adding HTLCs and check that size stays in allowable estimation\n\t// error window.\n\tfor i := 0; i <= 10; i++ {\n\t\thtlc, _ := createHTLC(i, lnwire.MilliSatoshi(1e7))\n\n\t\tif _, err := aliceChannel.AddHTLC(htlc, nil); err != nil {\n\t\t\tt.Fatalf(\"alice unable to add htlc: %v\", err)\n\t\t}\n\t\tif _, err := bobChannel.ReceiveHTLC(htlc); err != nil {\n\t\t\tt.Fatalf(\"bob unable to receive htlc: %v\", err)\n\t\t}\n\n\t\tif err := ForceStateTransition(aliceChannel, bobChannel); err != nil {\n\t\t\tt.Fatalf(\"unable to complete state update: %v\", err)\n\t\t}\n\t\tcheckSize(aliceChannel, i+1)\n\t\tcheckSize(bobChannel, i+1)\n\t}\n\n\t// Settle HTLCs and check that estimation is counting cost of settle\n\t// HTLCs properly.\n\tfor i := 10; i >= 0; i-- {\n\t\t_, preimage := createHTLC(i, lnwire.MilliSatoshi(1e7))\n\n\t\terr := bobChannel.SettleHTLC(preimage, uint64(i), nil, nil, nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"bob unable to settle inbound htlc: %v\", err)\n\t\t}\n\n\t\terr = aliceChannel.ReceiveHTLCSettle(preimage, uint64(i))\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"alice unable to accept settle of outbound htlc: %v\", err)\n\t\t}\n\n\t\tif err := ForceStateTransition(bobChannel, aliceChannel); err != nil {\n\t\t\tt.Fatalf(\"unable to complete state update: %v\", err)\n\t\t}\n\t\tcheckSize(aliceChannel, i)\n\t\tcheckSize(bobChannel, i)\n\t}\n}\n\n// TestCommitHTLCSigTieBreak asserts that HTLC signatures are sent the proper\n// BIP69+CLTV sorting expected by BOLT 3 when multiple HTLCs have identical\n// payment hashes and amounts, but differing CLTVs. This is exercised by adding\n// the HTLCs in the descending order of their CLTVs, and asserting that their\n// order is reversed when signing.",
      "length": 2697,
      "tokens": 382,
      "embedding": []
    },
    {
      "slug": "func TestCommitHTLCSigTieBreak(t *testing.T) {",
      "content": "func TestCommitHTLCSigTieBreak(t *testing.T) {\n\tt.Run(\"no restart\", func(t *testing.T) {\n\t\ttestCommitHTLCSigTieBreak(t, false)\n\t})\n\tt.Run(\"restart\", func(t *testing.T) {\n\t\ttestCommitHTLCSigTieBreak(t, true)\n\t})\n}\n",
      "length": 159,
      "tokens": 16,
      "embedding": []
    },
    {
      "slug": "func testCommitHTLCSigTieBreak(t *testing.T, restart bool) {",
      "content": "func testCommitHTLCSigTieBreak(t *testing.T, restart bool) {\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\tif err != nil {\n\t\tt.Fatalf(\"unable to create test channels; %v\", err)\n\t}\n\n\tconst (\n\t\thtlcAmt  = lnwire.MilliSatoshi(20000000)\n\t\tnumHtlcs = 2\n\t)\n\n\t// Add HTLCs with identical payment hashes and amounts, but descending\n\t// CLTV values. We will expect the signatures to appear in the reverse\n\t// order that the HTLCs are added due to the commitment sorting.\n\tfor i := 0; i < numHtlcs; i++ {\n\t\tvar (\n\t\t\tpreimage lntypes.Preimage\n\t\t\thash     = preimage.Hash()\n\t\t)\n\n\t\thtlc := &lnwire.UpdateAddHTLC{\n\t\t\tID:          uint64(i),\n\t\t\tPaymentHash: hash,\n\t\t\tAmount:      htlcAmt,\n\t\t\tExpiry:      uint32(numHtlcs - i),\n\t\t}\n\n\t\tif _, err := aliceChannel.AddHTLC(htlc, nil); err != nil {\n\t\t\tt.Fatalf(\"alice unable to add htlc: %v\", err)\n\t\t}\n\t\tif _, err := bobChannel.ReceiveHTLC(htlc); err != nil {\n\t\t\tt.Fatalf(\"bob unable to receive htlc: %v\", err)\n\t\t}\n\t}\n\n\t// Have Alice initiate the first half of the commitment dance. The\n\t// tie-breaking for commitment sorting won't affect the commitment\n\t// signed by Alice because received HTLC scripts commit to the CLTV\n\t// directly, so the outputs will have different scriptPubkeys.\n\taliceSig, aliceHtlcSigs, _, err := aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"unable to sign alice's commitment\")\n\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\trequire.NoError(t, err, \"unable to receive alice's commitment\")\n\n\tbobRevocation, _, _, err := bobChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"unable to revoke bob's commitment\")\n\t_, _, _, _, err = aliceChannel.ReceiveRevocation(bobRevocation)\n\trequire.NoError(t, err, \"unable to receive bob's revocation\")\n\n\t// Now have Bob initiate the second half of the commitment dance. Here\n\t// the offered HTLC scripts he adds for Alice will need to have the\n\t// tie-breaking applied because the CLTV is not committed, but instead\n\t// implicit via the construction of the second-level transactions.\n\tbobSig, bobHtlcSigs, bobHtlcs, err := bobChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"unable to sign bob's commitment\")\n\n\tif len(bobHtlcs) != numHtlcs {\n\t\tt.Fatalf(\"expected %d htlcs, got: %v\", numHtlcs, len(bobHtlcs))\n\t}\n\n\t// Ensure that our HTLCs appear in the reverse order from which they\n\t// were added by inspecting each's outpoint index. We expect the output\n\t// indexes to be in descending order, i.e. the first HTLC added had the\n\t// highest CLTV and should end up last.\n\tlastIndex := bobHtlcs[0].OutputIndex\n\tfor i, htlc := range bobHtlcs[1:] {\n\t\tif htlc.OutputIndex >= lastIndex {\n\t\t\tt.Fatalf(\"htlc %d output index %d is not descending\",\n\t\t\t\ti, htlc.OutputIndex)\n\t\t}\n\n\t\tlastIndex = htlc.OutputIndex\n\t}\n\n\t// If requested, restart Alice so that we can test that the necessary\n\t// indexes can be reconstructed before needing to validate the\n\t// signatures from Bob.\n\tif restart {\n\t\taliceState := aliceChannel.channelState\n\t\taliceChannels, err := aliceState.Db.FetchOpenChannels(\n\t\t\taliceState.IdentityPub,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to fetch channel: %v\", err)\n\t\t}\n\n\t\taliceChannelNew, err := NewLightningChannel(\n\t\t\taliceChannel.Signer, aliceChannels[0],\n\t\t\taliceChannel.sigPool,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to create new channel: %v\", err)\n\t\t}\n\n\t\taliceChannel = aliceChannelNew\n\t}\n\n\t// Finally, have Alice validate the signatures to ensure that she is\n\t// expecting the signatures in the proper order.\n\terr = aliceChannel.ReceiveNewCommitment(bobSig, bobHtlcSigs)\n\trequire.NoError(t, err, \"unable to receive bob's commitment\")\n}\n\n// TestCooperativeChannelClosure checks that the coop close process finishes\n// with an agreement from both parties, and that the final balances of the\n// close tx check out.",
      "length": 3656,
      "tokens": 512,
      "embedding": []
    },
    {
      "slug": "func TestCooperativeChannelClosure(t *testing.T) {",
      "content": "func TestCooperativeChannelClosure(t *testing.T) {\n\tt.Run(\"tweakless\", func(t *testing.T) {\n\t\ttestCoopClose(t, &coopCloseTestCase{\n\t\t\tchanType: channeldb.SingleFunderTweaklessBit,\n\t\t})\n\t})\n\tt.Run(\"anchors\", func(t *testing.T) {\n\t\ttestCoopClose(t, &coopCloseTestCase{\n\t\t\tchanType: channeldb.SingleFunderTweaklessBit |\n\t\t\t\tchanneldb.AnchorOutputsBit,\n\t\t\tanchorAmt: anchorSize * 2,\n\t\t})\n\t})\n}\n",
      "length": 326,
      "tokens": 27,
      "embedding": []
    },
    {
      "slug": "type coopCloseTestCase struct {",
      "content": "type coopCloseTestCase struct {\n\tchanType  channeldb.ChannelType\n\tanchorAmt btcutil.Amount\n}\n",
      "length": 58,
      "tokens": 5,
      "embedding": []
    },
    {
      "slug": "func testCoopClose(t *testing.T, testCase *coopCloseTestCase) {",
      "content": "func testCoopClose(t *testing.T, testCase *coopCloseTestCase) {\n\tt.Parallel()\n\n\t// Create a test channel which will be used for the duration of this\n\t// unittest. The channel will be funded evenly with Alice having 5 BTC,\n\t// and Bob having 5 BTC.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, testCase.chanType,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\taliceDeliveryScript := bobsPrivKey[:]\n\tbobDeliveryScript := testHdSeed[:]\n\n\taliceFeeRate := chainfee.SatPerKWeight(\n\t\taliceChannel.channelState.LocalCommitment.FeePerKw,\n\t)\n\tbobFeeRate := chainfee.SatPerKWeight(\n\t\tbobChannel.channelState.LocalCommitment.FeePerKw,\n\t)\n\n\t// We'll start with both Alice and Bob creating a new close proposal\n\t// with the same fee.\n\taliceFee := aliceChannel.CalcFee(aliceFeeRate)\n\taliceSig, _, _, err := aliceChannel.CreateCloseProposal(\n\t\taliceFee, aliceDeliveryScript, bobDeliveryScript,\n\t)\n\trequire.NoError(t, err, \"unable to create alice coop close proposal\")\n\n\tbobFee := bobChannel.CalcFee(bobFeeRate)\n\tbobSig, _, _, err := bobChannel.CreateCloseProposal(\n\t\tbobFee, bobDeliveryScript, aliceDeliveryScript,\n\t)\n\trequire.NoError(t, err, \"unable to create bob coop close proposal\")\n\n\t// With the proposals created, both sides should be able to properly\n\t// process the other party's signature. This indicates that the\n\t// transaction is well formed, and the signatures verify.\n\taliceCloseTx, bobTxBalance, err := bobChannel.CompleteCooperativeClose(\n\t\tbobSig, aliceSig, bobDeliveryScript, aliceDeliveryScript,\n\t\tbobFee,\n\t)\n\trequire.NoError(t, err, \"unable to complete alice cooperative close\")\n\tbobCloseSha := aliceCloseTx.TxHash()\n\n\tbobCloseTx, aliceTxBalance, err := aliceChannel.CompleteCooperativeClose(\n\t\taliceSig, bobSig, aliceDeliveryScript, bobDeliveryScript,\n\t\taliceFee,\n\t)\n\trequire.NoError(t, err, \"unable to complete bob cooperative close\")\n\taliceCloseSha := bobCloseTx.TxHash()\n\n\tif bobCloseSha != aliceCloseSha {\n\t\tt.Fatalf(\"alice and bob close transactions don't match: %v\", err)\n\t}\n\n\t// Finally, make sure the final balances are correct from both's\n\t// perspective.\n\taliceBalance := aliceChannel.channelState.LocalCommitment.\n\t\tLocalBalance.ToSatoshis()\n\n\t// The commit balance have had the initiator's (Alice) commitfee and\n\t// any anchors subtracted, so add that back to the final expected\n\t// balance. Alice also pays the coop close fee, so that must be\n\t// subtracted.\n\tcommitFee := aliceChannel.channelState.LocalCommitment.CommitFee\n\texpBalanceAlice := aliceBalance + commitFee +\n\t\ttestCase.anchorAmt - bobFee\n\tif aliceTxBalance != expBalanceAlice {\n\t\tt.Fatalf(\"expected balance %v got %v\", expBalanceAlice,\n\t\t\taliceTxBalance)\n\t}\n\n\t// Bob is not the initiator, so his final balance should simply be\n\t// equal to the latest commitment balance.\n\texpBalanceBob := bobChannel.channelState.LocalCommitment.\n\t\tLocalBalance.ToSatoshis()\n\tif bobTxBalance != expBalanceBob {\n\t\tt.Fatalf(\"expected bob's balance to be %v got %v\",\n\t\t\texpBalanceBob, bobTxBalance)\n\t}\n}\n\n// TestForceClose checks that the resulting ForceCloseSummary is correct when a\n// peer is ForceClosing the channel. Will check outputs both above and below\n// the dust limit. Additionally, we'll ensure that the node which executed the\n// force close generates HTLC resolutions that are capable of sweeping both\n// incoming and outgoing HTLC's.",
      "length": 3192,
      "tokens": 392,
      "embedding": []
    },
    {
      "slug": "func TestForceClose(t *testing.T) {",
      "content": "func TestForceClose(t *testing.T) {\n\tt.Run(\"tweakless\", func(t *testing.T) {\n\t\ttestForceClose(t, &forceCloseTestCase{\n\t\t\tchanType:             channeldb.SingleFunderTweaklessBit,\n\t\t\texpectedCommitWeight: input.CommitWeight,\n\t\t})\n\t})\n\tt.Run(\"anchors\", func(t *testing.T) {\n\t\ttestForceClose(t, &forceCloseTestCase{\n\t\t\tchanType: channeldb.SingleFunderTweaklessBit |\n\t\t\t\tchanneldb.AnchorOutputsBit,\n\t\t\texpectedCommitWeight: input.AnchorCommitWeight,\n\t\t\tanchorAmt:            anchorSize * 2,\n\t\t})\n\t})\n}\n",
      "length": 447,
      "tokens": 31,
      "embedding": []
    },
    {
      "slug": "type forceCloseTestCase struct {",
      "content": "type forceCloseTestCase struct {\n\tchanType             channeldb.ChannelType\n\texpectedCommitWeight int64\n\tanchorAmt            btcutil.Amount\n}\n",
      "length": 107,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "func testForceClose(t *testing.T, testCase *forceCloseTestCase) {",
      "content": "func testForceClose(t *testing.T, testCase *forceCloseTestCase) {\n\tt.Parallel()\n\n\t// Create a test channel which will be used for the duration of this\n\t// unittest. The channel will be funded evenly with Alice having 5 BTC,\n\t// and Bob having 5 BTC.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, testCase.chanType,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\tbobAmount := bobChannel.channelState.LocalCommitment.LocalBalance\n\n\t// First, we'll add an outgoing HTLC from Alice to Bob, such that it\n\t// will still be present within the broadcast commitment transaction.\n\t// We'll ensure that the HTLC amount is above Alice's dust limit.\n\thtlcAmount := lnwire.NewMSatFromSatoshis(20000)\n\thtlcAlice, _ := createHTLC(0, htlcAmount)\n\tif _, err := aliceChannel.AddHTLC(htlcAlice, nil); err != nil {\n\t\tt.Fatalf(\"alice unable to add htlc: %v\", err)\n\t}\n\tif _, err := bobChannel.ReceiveHTLC(htlcAlice); err != nil {\n\t\tt.Fatalf(\"bob unable to recv add htlc: %v\", err)\n\t}\n\n\t// We'll also a distinct HTLC from Bob -> Alice. This way, Alice will\n\t// have both an incoming and outgoing HTLC on her commitment\n\t// transaction.\n\thtlcBob, preimageBob := createHTLC(0, htlcAmount)\n\tif _, err := bobChannel.AddHTLC(htlcBob, nil); err != nil {\n\t\tt.Fatalf(\"alice unable to add htlc: %v\", err)\n\t}\n\tif _, err := aliceChannel.ReceiveHTLC(htlcBob); err != nil {\n\t\tt.Fatalf(\"bob unable to recv add htlc: %v\", err)\n\t}\n\n\t// Next, we'll perform two state transitions to ensure that both HTLC's\n\t// get fully locked-in.\n\tif err := ForceStateTransition(aliceChannel, bobChannel); err != nil {\n\t\tt.Fatalf(\"Can't update the channel state: %v\", err)\n\t}\n\tif err := ForceStateTransition(bobChannel, aliceChannel); err != nil {\n\t\tt.Fatalf(\"Can't update the channel state: %v\", err)\n\t}\n\n\t// With the cache populated, we'll now attempt the force close\n\t// initiated by Alice.\n\tcloseSummary, err := aliceChannel.ForceClose()\n\trequire.NoError(t, err, \"unable to force close channel\")\n\n\t// Alice should detect that she can sweep the outgoing HTLC after a\n\t// timeout, but also that she's able to sweep in incoming HTLC Bob sent\n\t// her.\n\tif len(closeSummary.HtlcResolutions.OutgoingHTLCs) != 1 {\n\t\tt.Fatalf(\"alice out htlc resolutions not populated: expected %v \"+\n\t\t\t\"htlcs, got %v htlcs\",\n\t\t\t1, len(closeSummary.HtlcResolutions.OutgoingHTLCs))\n\t}\n\tif len(closeSummary.HtlcResolutions.IncomingHTLCs) != 1 {\n\t\tt.Fatalf(\"alice in htlc resolutions not populated: expected %v \"+\n\t\t\t\"htlcs, got %v htlcs\",\n\t\t\t1, len(closeSummary.HtlcResolutions.IncomingHTLCs))\n\t}\n\n\t// Verify the anchor resolutions for the anchor commitment format.\n\tif testCase.chanType.HasAnchors() {\n\t\t// Check the close summary resolution.\n\t\tanchorRes := closeSummary.AnchorResolution\n\t\tif anchorRes == nil {\n\t\t\tt.Fatal(\"expected anchor resolution\")\n\t\t}\n\t\tif anchorRes.CommitAnchor.Hash != closeSummary.CloseTx.TxHash() {\n\t\t\tt.Fatal(\"commit tx not referenced by anchor res\")\n\t\t}\n\t\tif anchorRes.AnchorSignDescriptor.Output.Value !=\n\t\t\tint64(anchorSize) {\n\n\t\t\tt.Fatal(\"unexpected anchor size\")\n\t\t}\n\t\tif anchorRes.AnchorSignDescriptor.WitnessScript == nil {\n\t\t\tt.Fatal(\"expected anchor witness script\")\n\t\t}\n\n\t\t// Check the pre-confirmation resolutions.\n\t\tres, err := aliceChannel.NewAnchorResolutions()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"pre-confirmation resolution error: %v\", err)\n\t\t}\n\n\t\t// Check we have the expected anchor resolutions.\n\t\trequire.NotNil(t, res.Local, \"expected local anchor resolution\")\n\t\trequire.NotNil(t,\n\t\t\tres.Remote, \"expected remote anchor resolution\",\n\t\t)\n\t\trequire.Nil(t,\n\t\t\tres.RemotePending, \"expected no anchor resolution\",\n\t\t)\n\t}\n\n\t// The SelfOutputSignDesc should be non-nil since the output to-self is\n\t// non-dust.\n\taliceCommitResolution := closeSummary.CommitResolution\n\tif aliceCommitResolution == nil {\n\t\tt.Fatalf(\"alice fails to include to-self output in \" +\n\t\t\t\"ForceCloseSummary\")\n\t}\n\n\t// The rest of the close summary should have been populated properly.\n\taliceDelayPoint := aliceChannel.channelState.LocalChanCfg.DelayBasePoint\n\tif !aliceCommitResolution.SelfOutputSignDesc.KeyDesc.PubKey.IsEqual(\n\t\taliceDelayPoint.PubKey,\n\t) {\n\t\tt.Fatalf(\"alice incorrect pubkey in SelfOutputSignDesc\")\n\t}\n\n\t// Factoring in the fee rate, Alice's amount should properly reflect\n\t// that we've added two additional HTLC to the commitment transaction.\n\ttotalCommitWeight := testCase.expectedCommitWeight +\n\t\t(input.HTLCWeight * 2)\n\tfeePerKw := chainfee.SatPerKWeight(\n\t\taliceChannel.channelState.LocalCommitment.FeePerKw,\n\t)\n\tcommitFee := feePerKw.FeeForWeight(totalCommitWeight)\n\n\texpectedAmount := (aliceChannel.Capacity / 2) -\n\t\thtlcAmount.ToSatoshis() - commitFee - testCase.anchorAmt\n\n\tif aliceCommitResolution.SelfOutputSignDesc.Output.Value != int64(expectedAmount) {\n\t\tt.Fatalf(\"alice incorrect output value in SelfOutputSignDesc, \"+\n\t\t\t\"expected %v, got %v\", int64(expectedAmount),\n\t\t\taliceCommitResolution.SelfOutputSignDesc.Output.Value)\n\t}\n\n\t// Alice's listed CSV delay should also match the delay that was\n\t// pre-committed to at channel opening.\n\tif aliceCommitResolution.MaturityDelay !=\n\t\tuint32(aliceChannel.channelState.LocalChanCfg.CsvDelay) {\n\n\t\tt.Fatalf(\"alice: incorrect local CSV delay in ForceCloseSummary, \"+\n\t\t\t\"expected %v, got %v\",\n\t\t\taliceChannel.channelState.LocalChanCfg.CsvDelay,\n\t\t\taliceCommitResolution.MaturityDelay)\n\t}\n\n\t// Next, we'll ensure that the second level HTLC transaction it itself\n\t// spendable, and also that the delivery output (with delay) itself has\n\t// a valid sign descriptor.\n\thtlcResolution := closeSummary.HtlcResolutions.OutgoingHTLCs[0]\n\toutHtlcIndex := htlcResolution.SignedTimeoutTx.TxIn[0].PreviousOutPoint.Index\n\tsenderHtlcPkScript := closeSummary.CloseTx.TxOut[outHtlcIndex].PkScript\n\n\t// First, verify that the second level transaction can properly spend\n\t// the multi-sig clause within the output on the commitment transaction\n\t// that produces this HTLC.\n\ttimeoutTx := htlcResolution.SignedTimeoutTx\n\tvm, err := txscript.NewEngine(\n\t\tsenderHtlcPkScript,\n\t\ttimeoutTx, 0, txscript.StandardVerifyFlags, nil,\n\t\tnil, int64(htlcAmount.ToSatoshis()),\n\t\ttxscript.NewCannedPrevOutputFetcher(\n\t\t\tsenderHtlcPkScript, int64(htlcAmount.ToSatoshis()),\n\t\t),\n\t)\n\trequire.NoError(t, err, \"unable to create engine\")\n\tif err := vm.Execute(); err != nil {\n\t\tt.Fatalf(\"htlc timeout spend is invalid: %v\", err)\n\t}\n\n\t// Next, we'll ensure that we can spend the output of the second level\n\t// transaction given a properly crafted sweep transaction.\n\tsweepTx := wire.NewMsgTx(2)\n\tsweepTx.AddTxIn(&wire.TxIn{\n\t\tPreviousOutPoint: wire.OutPoint{\n\t\t\tHash:  htlcResolution.SignedTimeoutTx.TxHash(),\n\t\t\tIndex: 0,\n\t\t},\n\t})\n\tsweepTx.AddTxOut(&wire.TxOut{\n\t\tPkScript: senderHtlcPkScript,\n\t\tValue:    htlcResolution.SweepSignDesc.Output.Value,\n\t})\n\thtlcResolution.SweepSignDesc.InputIndex = 0\n\tsweepTx.TxIn[0].Witness, err = input.HtlcSpendSuccess(aliceChannel.Signer,\n\t\t&htlcResolution.SweepSignDesc, sweepTx,\n\t\tuint32(aliceChannel.channelState.LocalChanCfg.CsvDelay))\n\trequire.NoError(t, err, \"unable to gen witness for timeout output\")\n\n\t// With the witness fully populated for the success spend from the\n\t// second-level transaction, we ensure that the scripts properly\n\t// validate given the information within the htlc resolution struct.\n\tvm, err = txscript.NewEngine(\n\t\thtlcResolution.SweepSignDesc.Output.PkScript,\n\t\tsweepTx, 0, txscript.StandardVerifyFlags, nil,\n\t\tnil, htlcResolution.SweepSignDesc.Output.Value,\n\t\ttxscript.NewCannedPrevOutputFetcher(\n\t\t\thtlcResolution.SweepSignDesc.Output.PkScript,\n\t\t\thtlcResolution.SweepSignDesc.Output.Value,\n\t\t),\n\t)\n\trequire.NoError(t, err, \"unable to create engine\")\n\tif err := vm.Execute(); err != nil {\n\t\tt.Fatalf(\"htlc timeout spend is invalid: %v\", err)\n\t}\n\n\t// Finally, the txid of the commitment transaction and the one returned\n\t// as the closing transaction should also match.\n\tcloseTxHash := closeSummary.CloseTx.TxHash()\n\tcommitTxHash := aliceChannel.channelState.LocalCommitment.CommitTx.TxHash()\n\tif !bytes.Equal(closeTxHash[:], commitTxHash[:]) {\n\t\tt.Fatalf(\"alice: incorrect close transaction txid\")\n\t}\n\n\t// We'll now perform similar set of checks to ensure that Alice is able\n\t// to sweep the output that Bob sent to her on-chain with knowledge of\n\t// the preimage.\n\tinHtlcResolution := closeSummary.HtlcResolutions.IncomingHTLCs[0]\n\tinHtlcIndex := inHtlcResolution.SignedSuccessTx.TxIn[0].PreviousOutPoint.Index\n\treceiverHtlcScript := closeSummary.CloseTx.TxOut[inHtlcIndex].PkScript\n\n\t// With the original pkscript located, we'll now verify that the second\n\t// level transaction can spend from the multi-sig out. Supply the\n\t// preimage manually. This is usually done by the contract resolver\n\t// before publication.\n\tsuccessTx := inHtlcResolution.SignedSuccessTx\n\tsuccessTx.TxIn[0].Witness[3] = preimageBob[:]\n\tvm, err = txscript.NewEngine(\n\t\treceiverHtlcScript,\n\t\tsuccessTx, 0, txscript.StandardVerifyFlags, nil,\n\t\tnil, int64(htlcAmount.ToSatoshis()),\n\t\ttxscript.NewCannedPrevOutputFetcher(\n\t\t\treceiverHtlcScript, int64(htlcAmount.ToSatoshis()),\n\t\t),\n\t)\n\trequire.NoError(t, err, \"unable to create engine\")\n\tif err := vm.Execute(); err != nil {\n\t\tt.Fatalf(\"htlc success spend is invalid: %v\", err)\n\t}\n\n\t// Finally, we'll construct a transaction to spend the produced\n\t// second-level output with the attached SignDescriptor.\n\tsweepTx = wire.NewMsgTx(2)\n\tsweepTx.AddTxIn(&wire.TxIn{\n\t\tPreviousOutPoint: inHtlcResolution.ClaimOutpoint,\n\t})\n\tsweepTx.AddTxOut(&wire.TxOut{\n\t\tPkScript: receiverHtlcScript,\n\t\tValue:    inHtlcResolution.SweepSignDesc.Output.Value,\n\t})\n\tinHtlcResolution.SweepSignDesc.InputIndex = 0\n\tsweepTx.TxIn[0].Witness, err = input.HtlcSpendSuccess(aliceChannel.Signer,\n\t\t&inHtlcResolution.SweepSignDesc, sweepTx,\n\t\tuint32(aliceChannel.channelState.LocalChanCfg.CsvDelay))\n\trequire.NoError(t, err, \"unable to gen witness for timeout output\")\n\n\t// The spend we create above spending the second level HTLC output\n\t// should validate without any issues.\n\tvm, err = txscript.NewEngine(\n\t\tinHtlcResolution.SweepSignDesc.Output.PkScript,\n\t\tsweepTx, 0, txscript.StandardVerifyFlags, nil,\n\t\tnil, inHtlcResolution.SweepSignDesc.Output.Value,\n\t\ttxscript.NewCannedPrevOutputFetcher(\n\t\t\tinHtlcResolution.SweepSignDesc.Output.PkScript,\n\t\t\tinHtlcResolution.SweepSignDesc.Output.Value,\n\t\t),\n\t)\n\trequire.NoError(t, err, \"unable to create engine\")\n\tif err := vm.Execute(); err != nil {\n\t\tt.Fatalf(\"htlc timeout spend is invalid: %v\", err)\n\t}\n\n\t// Check the same for Bob's ForceCloseSummary.\n\tcloseSummary, err = bobChannel.ForceClose()\n\trequire.NoError(t, err, \"unable to force close channel\")\n\tbobCommitResolution := closeSummary.CommitResolution\n\tif bobCommitResolution == nil {\n\t\tt.Fatalf(\"bob fails to include to-self output in ForceCloseSummary\")\n\t}\n\tbobDelayPoint := bobChannel.channelState.LocalChanCfg.DelayBasePoint\n\tif !bobCommitResolution.SelfOutputSignDesc.KeyDesc.PubKey.IsEqual(bobDelayPoint.PubKey) {\n\t\tt.Fatalf(\"bob incorrect pubkey in SelfOutputSignDesc\")\n\t}\n\tif bobCommitResolution.SelfOutputSignDesc.Output.Value !=\n\t\tint64(bobAmount.ToSatoshis()-htlcAmount.ToSatoshis()) {\n\n\t\tt.Fatalf(\"bob incorrect output value in SelfOutputSignDesc, \"+\n\t\t\t\"expected %v, got %v\",\n\t\t\tbobAmount.ToSatoshis(),\n\t\t\tint64(bobCommitResolution.SelfOutputSignDesc.Output.Value))\n\t}\n\tif bobCommitResolution.MaturityDelay !=\n\t\tuint32(bobChannel.channelState.LocalChanCfg.CsvDelay) {\n\n\t\tt.Fatalf(\"bob: incorrect local CSV delay in ForceCloseSummary, \"+\n\t\t\t\"expected %v, got %v\",\n\t\t\tbobChannel.channelState.LocalChanCfg.CsvDelay,\n\t\t\tbobCommitResolution.MaturityDelay)\n\t}\n\n\tcloseTxHash = closeSummary.CloseTx.TxHash()\n\tcommitTxHash = bobChannel.channelState.LocalCommitment.CommitTx.TxHash()\n\tif !bytes.Equal(closeTxHash[:], commitTxHash[:]) {\n\t\tt.Fatalf(\"bob: incorrect close transaction txid\")\n\t}\n\n\t// As we didn't add the preimage of Alice's HTLC to bob's preimage\n\t// cache, he should only detect that he can sweep only his outgoing\n\t// HTLC upon force close.\n\tif len(closeSummary.HtlcResolutions.OutgoingHTLCs) != 1 {\n\t\tt.Fatalf(\"alice out htlc resolutions not populated: expected %v \"+\n\t\t\t\"htlcs, got %v htlcs\",\n\t\t\t1, len(closeSummary.HtlcResolutions.OutgoingHTLCs))\n\t}\n\n\t// Bob should recognize that the incoming HTLC is there, but the\n\t// preimage should be empty as he doesn't have the knowledge required\n\t// to sweep it.\n\tif len(closeSummary.HtlcResolutions.IncomingHTLCs) != 1 {\n\t\tt.Fatalf(\"bob in htlc resolutions not populated: expected %v \"+\n\t\t\t\"htlcs, got %v htlcs\",\n\t\t\t1, len(closeSummary.HtlcResolutions.IncomingHTLCs))\n\t}\n}\n\n// TestForceCloseDustOutput tests that if either side force closes with an\n// active dust output (for only a single party due to asymmetric dust values),\n// then the force close summary is well crafted.",
      "length": 12315,
      "tokens": 1356,
      "embedding": []
    },
    {
      "slug": "func TestForceCloseDustOutput(t *testing.T) {",
      "content": "func TestForceCloseDustOutput(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a test channel which will be used for the duration of this\n\t// unittest. The channel will be funded evenly with Alice having 5 BTC,\n\t// and Bob having 5 BTC.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// We set both node's channel reserves to 0, to make sure\n\t// they can create small dust outputs without going under\n\t// their channel reserves.\n\taliceChannel.channelState.LocalChanCfg.ChanReserve = 0\n\tbobChannel.channelState.LocalChanCfg.ChanReserve = 0\n\taliceChannel.channelState.RemoteChanCfg.ChanReserve = 0\n\tbobChannel.channelState.RemoteChanCfg.ChanReserve = 0\n\n\thtlcAmount := lnwire.NewMSatFromSatoshis(500)\n\n\taliceAmount := aliceChannel.channelState.LocalCommitment.LocalBalance\n\tbobAmount := bobChannel.channelState.LocalCommitment.LocalBalance\n\n\t// Have Bobs' to-self output be below her dust limit and check\n\t// ForceCloseSummary again on both peers.\n\thtlc, preimage := createHTLC(0, bobAmount-htlcAmount)\n\tbobHtlcIndex, err := bobChannel.AddHTLC(htlc, nil)\n\trequire.NoError(t, err, \"alice unable to add htlc\")\n\taliceHtlcIndex, err := aliceChannel.ReceiveHTLC(htlc)\n\trequire.NoError(t, err, \"bob unable to receive htlc\")\n\tif err := ForceStateTransition(bobChannel, aliceChannel); err != nil {\n\t\tt.Fatalf(\"Can't update the channel state: %v\", err)\n\t}\n\n\t// Settle HTLC and sign new commitment.\n\terr = aliceChannel.SettleHTLC(preimage, aliceHtlcIndex, nil, nil, nil)\n\trequire.NoError(t, err, \"bob unable to settle inbound htlc\")\n\terr = bobChannel.ReceiveHTLCSettle(preimage, bobHtlcIndex)\n\tif err != nil {\n\t\tt.Fatalf(\"alice unable to accept settle of outbound htlc: %v\", err)\n\t}\n\tif err := ForceStateTransition(aliceChannel, bobChannel); err != nil {\n\t\tt.Fatalf(\"Can't update the channel state: %v\", err)\n\t}\n\n\taliceAmount = aliceChannel.channelState.LocalCommitment.LocalBalance\n\tbobAmount = bobChannel.channelState.LocalCommitment.RemoteBalance\n\n\tcloseSummary, err := aliceChannel.ForceClose()\n\trequire.NoError(t, err, \"unable to force close channel\")\n\n\t// Alice's to-self output should still be in the commitment\n\t// transaction.\n\tcommitResolution := closeSummary.CommitResolution\n\tif commitResolution == nil {\n\t\tt.Fatalf(\"alice fails to include to-self output in \" +\n\t\t\t\"ForceCloseSummary\")\n\t}\n\tif !commitResolution.SelfOutputSignDesc.KeyDesc.PubKey.IsEqual(\n\t\taliceChannel.channelState.LocalChanCfg.DelayBasePoint.PubKey,\n\t) {\n\t\tt.Fatalf(\"alice incorrect pubkey in SelfOutputSignDesc\")\n\t}\n\tif commitResolution.SelfOutputSignDesc.Output.Value !=\n\t\tint64(aliceAmount.ToSatoshis()) {\n\t\tt.Fatalf(\"alice incorrect output value in SelfOutputSignDesc, \"+\n\t\t\t\"expected %v, got %v\",\n\t\t\taliceChannel.channelState.LocalCommitment.LocalBalance.ToSatoshis(),\n\t\t\tcommitResolution.SelfOutputSignDesc.Output.Value)\n\t}\n\n\tif commitResolution.MaturityDelay !=\n\t\tuint32(aliceChannel.channelState.LocalChanCfg.CsvDelay) {\n\t\tt.Fatalf(\"alice: incorrect local CSV delay in ForceCloseSummary, \"+\n\t\t\t\"expected %v, got %v\",\n\t\t\taliceChannel.channelState.LocalChanCfg.CsvDelay,\n\t\t\tcommitResolution.MaturityDelay)\n\t}\n\n\tcloseTxHash := closeSummary.CloseTx.TxHash()\n\tcommitTxHash := aliceChannel.channelState.LocalCommitment.CommitTx.TxHash()\n\tif !bytes.Equal(closeTxHash[:], commitTxHash[:]) {\n\t\tt.Fatalf(\"alice: incorrect close transaction txid\")\n\t}\n\n\tcloseSummary, err = bobChannel.ForceClose()\n\trequire.NoError(t, err, \"unable to force close channel\")\n\n\t// Bob's to-self output is below Bob's dust value and should be\n\t// reflected in the ForceCloseSummary.\n\tcommitResolution = closeSummary.CommitResolution\n\tif commitResolution != nil {\n\t\tt.Fatalf(\"bob incorrectly includes to-self output in \" +\n\t\t\t\"ForceCloseSummary\")\n\t}\n\n\tcloseTxHash = closeSummary.CloseTx.TxHash()\n\tcommitTxHash = bobChannel.channelState.LocalCommitment.CommitTx.TxHash()\n\tif !bytes.Equal(closeTxHash[:], commitTxHash[:]) {\n\t\tt.Fatalf(\"bob: incorrect close transaction txid\")\n\t}\n}\n\n// TestDustHTLCFees checks that fees are calculated correctly when HTLCs fall\n// below the nodes' dust limit. In these cases, the amount of the dust HTLCs\n// should be applied to the commitment transaction fee.",
      "length": 4086,
      "tokens": 430,
      "embedding": []
    },
    {
      "slug": "func TestDustHTLCFees(t *testing.T) {",
      "content": "func TestDustHTLCFees(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a test channel which will be used for the duration of this\n\t// unittest. The channel will be funded evenly with Alice having 5 BTC,\n\t// and Bob having 5 BTC.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\taliceStartingBalance := aliceChannel.channelState.LocalCommitment.LocalBalance\n\n\t// This HTLC amount should be lower than the dust limits of both nodes.\n\thtlcAmount := lnwire.NewMSatFromSatoshis(100)\n\thtlc, _ := createHTLC(0, htlcAmount)\n\tif _, err := aliceChannel.AddHTLC(htlc, nil); err != nil {\n\t\tt.Fatalf(\"alice unable to add htlc: %v\", err)\n\t}\n\tif _, err := bobChannel.ReceiveHTLC(htlc); err != nil {\n\t\tt.Fatalf(\"bob unable to receive htlc: %v\", err)\n\t}\n\tif err := ForceStateTransition(aliceChannel, bobChannel); err != nil {\n\t\tt.Fatalf(\"Can't update the channel state: %v\", err)\n\t}\n\n\t// After the transition, we'll ensure that we performed fee accounting\n\t// properly. Namely, the local+remote+commitfee values should add up to\n\t// the total capacity of the channel. This same should hold for both\n\t// sides.\n\ttotalSatoshisAlice := (aliceChannel.channelState.LocalCommitment.LocalBalance +\n\t\taliceChannel.channelState.LocalCommitment.RemoteBalance +\n\t\tlnwire.NewMSatFromSatoshis(aliceChannel.channelState.LocalCommitment.CommitFee))\n\tif totalSatoshisAlice+htlcAmount != lnwire.NewMSatFromSatoshis(aliceChannel.Capacity) {\n\t\tt.Fatalf(\"alice's funds leaked: total satoshis are %v, but channel \"+\n\t\t\t\"capacity is %v\", int64(totalSatoshisAlice),\n\t\t\tint64(aliceChannel.Capacity))\n\t}\n\ttotalSatoshisBob := (bobChannel.channelState.LocalCommitment.LocalBalance +\n\t\tbobChannel.channelState.LocalCommitment.RemoteBalance +\n\t\tlnwire.NewMSatFromSatoshis(bobChannel.channelState.LocalCommitment.CommitFee))\n\tif totalSatoshisBob+htlcAmount != lnwire.NewMSatFromSatoshis(bobChannel.Capacity) {\n\t\tt.Fatalf(\"bob's funds leaked: total satoshis are %v, but channel \"+\n\t\t\t\"capacity is %v\", int64(totalSatoshisBob),\n\t\t\tint64(bobChannel.Capacity))\n\t}\n\n\t// The commitment fee paid should be the same, as there have been no\n\t// new material outputs added.\n\tdefaultFee := calcStaticFee(channeldb.SingleFunderTweaklessBit, 0)\n\tif aliceChannel.channelState.LocalCommitment.CommitFee != defaultFee {\n\t\tt.Fatalf(\"dust htlc amounts not subtracted from commitment fee \"+\n\t\t\t\"expected %v, got %v\", defaultFee,\n\t\t\taliceChannel.channelState.LocalCommitment.CommitFee)\n\t}\n\tif bobChannel.channelState.LocalCommitment.CommitFee != defaultFee {\n\t\tt.Fatalf(\"dust htlc amounts not subtracted from commitment fee \"+\n\t\t\t\"expected %v, got %v\", defaultFee,\n\t\t\tbobChannel.channelState.LocalCommitment.CommitFee)\n\t}\n\n\t// Alice's final balance should reflect the HTLC deficit even though\n\t// the HTLC was paid to fees as it was trimmed.\n\taliceEndBalance := aliceChannel.channelState.LocalCommitment.LocalBalance\n\taliceExpectedBalance := aliceStartingBalance - htlcAmount\n\tif aliceEndBalance != aliceExpectedBalance {\n\t\tt.Fatalf(\"alice not credited for dust: expected %v, got %v\",\n\t\t\taliceExpectedBalance, aliceEndBalance)\n\t}\n}\n\n// TestHTLCDustLimit checks the situation in which an HTLC is larger than one\n// channel participant's dust limit, but smaller than the other participant's\n// dust limit. In this case, the participants' commitment chains will diverge.\n// In one commitment chain, the HTLC will be added as normal, in the other\n// chain, the amount of the HTLC will contribute to the fees to be paid.",
      "length": 3438,
      "tokens": 397,
      "embedding": []
    },
    {
      "slug": "func TestHTLCDustLimit(t *testing.T) {",
      "content": "func TestHTLCDustLimit(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a test channel which will be used for the duration of this\n\t// unittest. The channel will be funded evenly with Alice having 5 BTC,\n\t// and Bob having 5 BTC.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// The amount of the HTLC should be above Alice's dust limit and below\n\t// Bob's dust limit.\n\thtlcSat := (btcutil.Amount(500) + HtlcTimeoutFee(\n\t\taliceChannel.channelState.ChanType,\n\t\tchainfee.SatPerKWeight(\n\t\t\taliceChannel.channelState.LocalCommitment.FeePerKw,\n\t\t),\n\t))\n\thtlcAmount := lnwire.NewMSatFromSatoshis(htlcSat)\n\n\thtlc, preimage := createHTLC(0, htlcAmount)\n\taliceHtlcIndex, err := aliceChannel.AddHTLC(htlc, nil)\n\trequire.NoError(t, err, \"alice unable to add htlc\")\n\tbobHtlcIndex, err := bobChannel.ReceiveHTLC(htlc)\n\trequire.NoError(t, err, \"bob unable to receive htlc\")\n\tif err := ForceStateTransition(aliceChannel, bobChannel); err != nil {\n\t\tt.Fatalf(\"Can't update the channel state: %v\", err)\n\t}\n\n\t// At this point, Alice's commitment transaction should have an HTLC,\n\t// while Bob's should not, because the value falls beneath his dust\n\t// limit. The amount of the HTLC should be applied to fees in Bob's\n\t// commitment transaction.\n\taliceCommitment := aliceChannel.localCommitChain.tip()\n\tif len(aliceCommitment.txn.TxOut) != 3 {\n\t\tt.Fatalf(\"incorrect # of outputs: expected %v, got %v\",\n\t\t\t3, len(aliceCommitment.txn.TxOut))\n\t}\n\tbobCommitment := bobChannel.localCommitChain.tip()\n\tif len(bobCommitment.txn.TxOut) != 2 {\n\t\tt.Fatalf(\"incorrect # of outputs: expected %v, got %v\",\n\t\t\t2, len(bobCommitment.txn.TxOut))\n\t}\n\tdefaultFee := calcStaticFee(channeldb.SingleFunderTweaklessBit, 0)\n\tif bobChannel.channelState.LocalCommitment.CommitFee != defaultFee {\n\t\tt.Fatalf(\"dust htlc amount was subtracted from commitment fee \"+\n\t\t\t\"expected %v, got %v\", defaultFee,\n\t\t\tbobChannel.channelState.LocalCommitment.CommitFee)\n\t}\n\n\t// Settle HTLC and create a new commitment state.\n\terr = bobChannel.SettleHTLC(preimage, bobHtlcIndex, nil, nil, nil)\n\trequire.NoError(t, err, \"bob unable to settle inbound htlc\")\n\terr = aliceChannel.ReceiveHTLCSettle(preimage, aliceHtlcIndex)\n\tif err != nil {\n\t\tt.Fatalf(\"alice unable to accept settle of outbound htlc: %v\", err)\n\t}\n\tif err := ForceStateTransition(bobChannel, aliceChannel); err != nil {\n\t\tt.Fatalf(\"state transition error: %v\", err)\n\t}\n\n\t// At this point, for Alice's commitment chains, the value of the HTLC\n\t// should have been added to Alice's balance and TotalSatoshisSent.\n\tcommitment := aliceChannel.localCommitChain.tip()\n\tif len(commitment.txn.TxOut) != 2 {\n\t\tt.Fatalf(\"incorrect # of outputs: expected %v, got %v\",\n\t\t\t2, len(commitment.txn.TxOut))\n\t}\n\tif aliceChannel.channelState.TotalMSatSent != htlcAmount {\n\t\tt.Fatalf(\"alice satoshis sent incorrect: expected %v, got %v\",\n\t\t\thtlcAmount, aliceChannel.channelState.TotalMSatSent)\n\t}\n}\n\n// TestHTLCSigNumber tests that a received commitment is only accepted if it\n// comes with the exact number of valid HTLC signatures.",
      "length": 3006,
      "tokens": 368,
      "embedding": []
    },
    {
      "slug": "func TestHTLCSigNumber(t *testing.T) {",
      "content": "func TestHTLCSigNumber(t *testing.T) {\n\tt.Parallel()\n\n\t// createChanWithHTLC is a helper method that sets ut two channels, and\n\t// adds HTLCs with the passed values to the channels.\n\tcreateChanWithHTLC := func(htlcValues ...btcutil.Amount) (\n\t\t*LightningChannel, *LightningChannel) {\n\n\t\t// Create a test channel funded evenly with Alice having 5 BTC,\n\t\t// and Bob having 5 BTC. Alice's dustlimit is 200 sat, while\n\t\t// Bob has 1300 sat.\n\t\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\t\tt, channeldb.SingleFunderTweaklessBit,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to create test channels: %v\", err)\n\t\t}\n\n\t\tfor i, htlcSat := range htlcValues {\n\t\t\thtlcMsat := lnwire.NewMSatFromSatoshis(htlcSat)\n\t\t\thtlc, _ := createHTLC(i, htlcMsat)\n\t\t\t_, err := aliceChannel.AddHTLC(htlc, nil)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"alice unable to add htlc: %v\", err)\n\t\t\t}\n\t\t\t_, err = bobChannel.ReceiveHTLC(htlc)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"bob unable to receive htlc: %v\", err)\n\t\t\t}\n\t\t}\n\n\t\treturn aliceChannel, bobChannel\n\t}\n\n\t// Calculate two values that will be below and above Bob's dust limit.\n\testimator := chainfee.NewStaticEstimator(6000, 0)\n\tfeePerKw, err := estimator.EstimateFeePerKW(1)\n\trequire.NoError(t, err, \"unable to get fee\")\n\n\tbelowDust := btcutil.Amount(500) + HtlcTimeoutFee(\n\t\tchanneldb.SingleFunderTweaklessBit, feePerKw,\n\t)\n\taboveDust := btcutil.Amount(1400) + HtlcSuccessFee(\n\t\tchanneldb.SingleFunderTweaklessBit, feePerKw,\n\t)\n\n\t// ===================================================================\n\t// Test that Bob will reject a commitment if Alice doesn't send enough\n\t// HTLC signatures.\n\t// ===================================================================\n\taliceChannel, bobChannel := createChanWithHTLC(aboveDust, aboveDust)\n\n\taliceSig, aliceHtlcSigs, _, err := aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"Error signing next commitment\")\n\n\tif len(aliceHtlcSigs) != 2 {\n\t\tt.Fatalf(\"expected 2 htlc sig, instead got %v\",\n\t\t\tlen(aliceHtlcSigs))\n\t}\n\n\t// Now discard one signature from the htlcSig slice. Bob should reject\n\t// the commitment because of this.\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs[1:])\n\tif err == nil {\n\t\tt.Fatalf(\"Expected Bob to reject signatures\")\n\t}\n\n\t// ===================================================================\n\t// Test that Bob will reject a commitment if Alice doesn't send any\n\t// HTLC signatures.\n\t// ===================================================================\n\taliceChannel, bobChannel = createChanWithHTLC(aboveDust)\n\n\taliceSig, aliceHtlcSigs, _, err = aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"Error signing next commitment\")\n\n\tif len(aliceHtlcSigs) != 1 {\n\t\tt.Fatalf(\"expected 1 htlc sig, instead got %v\",\n\t\t\tlen(aliceHtlcSigs))\n\t}\n\n\t// Now just give Bob an empty htlcSig slice. He should reject the\n\t// commitment because of this.\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, []lnwire.Sig{})\n\tif err == nil {\n\t\tt.Fatalf(\"Expected Bob to reject signatures\")\n\t}\n\n\t// ==============================================================\n\t// Test that sigs are not returned for HTLCs below dust limit.\n\t// ==============================================================\n\taliceChannel, bobChannel = createChanWithHTLC(belowDust)\n\n\taliceSig, aliceHtlcSigs, _, err = aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"Error signing next commitment\")\n\n\t// Since the HTLC is below Bob's dust limit, Alice won't need to send\n\t// any signatures for this HTLC.\n\tif len(aliceHtlcSigs) != 0 {\n\t\tt.Fatalf(\"expected no htlc sigs, instead got %v\",\n\t\t\tlen(aliceHtlcSigs))\n\t}\n\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\trequire.NoError(t, err, \"Bob failed receiving commitment\")\n\n\t// ================================================================\n\t// Test that sigs are correctly returned for HTLCs above dust limit.\n\t// ================================================================\n\taliceChannel, bobChannel = createChanWithHTLC(aboveDust)\n\n\taliceSig, aliceHtlcSigs, _, err = aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"Error signing next commitment\")\n\n\t// Since the HTLC is above Bob's dust limit, Alice should send a\n\t// signature for this HTLC.\n\tif len(aliceHtlcSigs) != 1 {\n\t\tt.Fatalf(\"expected 1 htlc sig, instead got %v\",\n\t\t\tlen(aliceHtlcSigs))\n\t}\n\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\trequire.NoError(t, err, \"Bob failed receiving commitment\")\n\n\t// ====================================================================\n\t// Test that Bob will not validate a received commitment if Alice sends\n\t// signatures for HTLCs below the dust limit.\n\t// ====================================================================\n\taliceChannel, bobChannel = createChanWithHTLC(belowDust, aboveDust)\n\n\t// Alice should produce only one signature, since one HTLC is below\n\t// dust.\n\taliceSig, aliceHtlcSigs, _, err = aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"Error signing next commitment\")\n\n\tif len(aliceHtlcSigs) != 1 {\n\t\tt.Fatalf(\"expected 1 htlc sig, instead got %v\",\n\t\t\tlen(aliceHtlcSigs))\n\t}\n\n\t// Add an extra signature.\n\taliceHtlcSigs = append(aliceHtlcSigs, aliceHtlcSigs[0])\n\n\t// Bob should reject these signatures since they don't match the number\n\t// of HTLCs above dust.\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\tif err == nil {\n\t\tt.Fatalf(\"Expected Bob to reject signatures\")\n\t}\n}\n\n// TestChannelBalanceDustLimit tests the condition when the remaining balance\n// for one of the channel participants is so small as to be considered dust. In\n// this case, the output for that participant is removed and all funds (minus\n// fees) in the commitment transaction are allocated to the remaining channel\n// participant.\n//\n// TODO(roasbeef): test needs to be fixed after reserve limits are done",
      "length": 5623,
      "tokens": 674,
      "embedding": []
    },
    {
      "slug": "func TestChannelBalanceDustLimit(t *testing.T) {",
      "content": "func TestChannelBalanceDustLimit(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a test channel which will be used for the duration of this\n\t// unittest. The channel will be funded evenly with Alice having 5 BTC,\n\t// and Bob having 5 BTC.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// To allow Alice's balance to get beneath her dust limit, set the\n\t// channel reserve to be 0.\n\taliceChannel.channelState.LocalChanCfg.ChanReserve = 0\n\tbobChannel.channelState.RemoteChanCfg.ChanReserve = 0\n\n\t// This amount should leave an amount larger than Alice's dust limit\n\t// once fees have been subtracted, but smaller than Bob's dust limit.\n\t// We account in fees for the HTLC we will be adding.\n\tdefaultFee := calcStaticFee(channeldb.SingleFunderTweaklessBit, 1)\n\taliceBalance := aliceChannel.channelState.LocalCommitment.LocalBalance.ToSatoshis()\n\thtlcSat := aliceBalance - defaultFee\n\thtlcSat += HtlcSuccessFee(\n\t\taliceChannel.channelState.ChanType,\n\t\tchainfee.SatPerKWeight(\n\t\t\taliceChannel.channelState.LocalCommitment.FeePerKw,\n\t\t),\n\t)\n\n\thtlcAmount := lnwire.NewMSatFromSatoshis(htlcSat)\n\n\thtlc, preimage := createHTLC(0, htlcAmount)\n\taliceHtlcIndex, err := aliceChannel.AddHTLC(htlc, nil)\n\trequire.NoError(t, err, \"alice unable to add htlc\")\n\tbobHtlcIndex, err := bobChannel.ReceiveHTLC(htlc)\n\trequire.NoError(t, err, \"bob unable to receive htlc\")\n\tif err := ForceStateTransition(aliceChannel, bobChannel); err != nil {\n\t\tt.Fatalf(\"state transition error: %v\", err)\n\t}\n\terr = bobChannel.SettleHTLC(preimage, bobHtlcIndex, nil, nil, nil)\n\trequire.NoError(t, err, \"bob unable to settle inbound htlc\")\n\terr = aliceChannel.ReceiveHTLCSettle(preimage, aliceHtlcIndex)\n\tif err != nil {\n\t\tt.Fatalf(\"alice unable to accept settle of outbound htlc: %v\", err)\n\t}\n\tif err := ForceStateTransition(bobChannel, aliceChannel); err != nil {\n\t\tt.Fatalf(\"state transition error: %v\", err)\n\t}\n\n\t// At the conclusion of this test, in Bob's commitment chains, the\n\t// output for Alice's balance should have been removed as dust, leaving\n\t// only a single output that will send the remaining funds in the\n\t// channel to Bob.\n\tcommitment := bobChannel.localCommitChain.tip()\n\tif len(commitment.txn.TxOut) != 1 {\n\t\tt.Fatalf(\"incorrect # of outputs: expected %v, got %v\",\n\t\t\t1, len(commitment.txn.TxOut))\n\t}\n\tif aliceChannel.channelState.TotalMSatSent != htlcAmount {\n\t\tt.Fatalf(\"alice satoshis sent incorrect: expected %v, got %v\",\n\t\t\thtlcAmount, aliceChannel.channelState.TotalMSatSent)\n\t}\n}\n",
      "length": 2465,
      "tokens": 303,
      "embedding": []
    },
    {
      "slug": "func TestStateUpdatePersistence(t *testing.T) {",
      "content": "func TestStateUpdatePersistence(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a test channel which will be used for the duration of this\n\t// unittest. The channel will be funded evenly with Alice having 5 BTC,\n\t// and Bob having 5 BTC.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\thtlcAmt := lnwire.NewMSatFromSatoshis(5000)\n\n\tvar fakeOnionBlob [lnwire.OnionPacketSize]byte\n\tcopy(fakeOnionBlob[:], bytes.Repeat([]byte{0x05}, lnwire.OnionPacketSize))\n\n\t// Alice adds 3 HTLCs to the update log, while Bob adds a single HTLC.\n\tvar alicePreimage [32]byte\n\tcopy(alicePreimage[:], bytes.Repeat([]byte{0xaa}, 32))\n\tvar bobPreimage [32]byte\n\tcopy(bobPreimage[:], bytes.Repeat([]byte{0xbb}, 32))\n\tfor i := 0; i < 3; i++ {\n\t\trHash := sha256.Sum256(alicePreimage[:])\n\t\th := &lnwire.UpdateAddHTLC{\n\t\t\tID:          uint64(i),\n\t\t\tPaymentHash: rHash,\n\t\t\tAmount:      htlcAmt,\n\t\t\tExpiry:      uint32(10),\n\t\t\tOnionBlob:   fakeOnionBlob,\n\t\t}\n\n\t\tif _, err := aliceChannel.AddHTLC(h, nil); err != nil {\n\t\t\tt.Fatalf(\"unable to add alice's htlc: %v\", err)\n\t\t}\n\t\tif _, err := bobChannel.ReceiveHTLC(h); err != nil {\n\t\t\tt.Fatalf(\"unable to recv alice's htlc: %v\", err)\n\t\t}\n\t}\n\trHash := sha256.Sum256(bobPreimage[:])\n\tbobh := &lnwire.UpdateAddHTLC{\n\t\tPaymentHash: rHash,\n\t\tAmount:      htlcAmt,\n\t\tExpiry:      uint32(10),\n\t\tOnionBlob:   fakeOnionBlob,\n\t}\n\tif _, err := bobChannel.AddHTLC(bobh, nil); err != nil {\n\t\tt.Fatalf(\"unable to add bob's htlc: %v\", err)\n\t}\n\tif _, err := aliceChannel.ReceiveHTLC(bobh); err != nil {\n\t\tt.Fatalf(\"unable to recv bob's htlc: %v\", err)\n\t}\n\n\t// Also add a fee update to the update logs.\n\tfee := chainfee.SatPerKWeight(333)\n\tif err := aliceChannel.UpdateFee(fee); err != nil {\n\t\tt.Fatalf(\"unable to send fee update\")\n\t}\n\tif err := bobChannel.ReceiveUpdateFee(fee); err != nil {\n\t\tt.Fatalf(\"unable to receive fee update\")\n\t}\n\n\t// Helper method that asserts the expected number of updates are found\n\t// in the update logs.\n\tassertNumLogUpdates := func(numAliceUpdates, numBobUpdates int) {\n\t\tif aliceChannel.localUpdateLog.Len() != numAliceUpdates {\n\t\t\tt.Fatalf(\"expected %d local updates, found %d\",\n\t\t\t\tnumAliceUpdates,\n\t\t\t\taliceChannel.localUpdateLog.Len())\n\t\t}\n\t\tif aliceChannel.remoteUpdateLog.Len() != numBobUpdates {\n\t\t\tt.Fatalf(\"expected %d remote updates, found %d\",\n\t\t\t\tnumBobUpdates,\n\t\t\t\taliceChannel.remoteUpdateLog.Len())\n\t\t}\n\n\t\tif bobChannel.localUpdateLog.Len() != numBobUpdates {\n\t\t\tt.Fatalf(\"expected %d local updates, found %d\",\n\t\t\t\tnumBobUpdates,\n\t\t\t\tbobChannel.localUpdateLog.Len())\n\t\t}\n\t\tif bobChannel.remoteUpdateLog.Len() != numAliceUpdates {\n\t\t\tt.Fatalf(\"expected %d remote updates, found %d\",\n\t\t\t\tnumAliceUpdates,\n\t\t\t\tbobChannel.remoteUpdateLog.Len())\n\t\t}\n\t}\n\n\t// Both nodes should now have Alice's 3 Adds and 1 FeeUpdate in the\n\t// log, and Bob's 1 Add.\n\tassertNumLogUpdates(4, 1)\n\n\t// Next, Alice initiates a state transition to include the HTLC's she\n\t// added above in a new commitment state.\n\tif err := ForceStateTransition(aliceChannel, bobChannel); err != nil {\n\t\tt.Fatalf(\"unable to complete alice's state transition: %v\", err)\n\t}\n\n\t// Since the HTLC Bob sent wasn't included in Bob's version of the\n\t// commitment transaction (but it was in Alice's, as he ACK'd her\n\t// changes before creating a new state), Bob needs to trigger another\n\t// state update in order to re-sync their states.\n\tif err := ForceStateTransition(bobChannel, aliceChannel); err != nil {\n\t\tt.Fatalf(\"unable to complete bob's state transition: %v\", err)\n\t}\n\n\t// After the state transition the fee update is fully locked in, and\n\t// should've been removed from both channels' update logs.\n\tif aliceChannel.localCommitChain.tail().feePerKw != fee {\n\t\tt.Fatalf(\"fee not locked in\")\n\t}\n\tif bobChannel.localCommitChain.tail().feePerKw != fee {\n\t\tt.Fatalf(\"fee not locked in\")\n\t}\n\tassertNumLogUpdates(3, 1)\n\n\t// The latest commitment from both sides should have all the HTLCs.\n\tnumAliceOutgoing := aliceChannel.localCommitChain.tail().outgoingHTLCs\n\tnumAliceIncoming := aliceChannel.localCommitChain.tail().incomingHTLCs\n\tif len(numAliceOutgoing) != 3 {\n\t\tt.Fatalf(\"expected %v htlcs, instead got %v\", 3, numAliceOutgoing)\n\t}\n\tif len(numAliceIncoming) != 1 {\n\t\tt.Fatalf(\"expected %v htlcs, instead got %v\", 1, numAliceIncoming)\n\t}\n\tnumBobOutgoing := bobChannel.localCommitChain.tail().outgoingHTLCs\n\tnumBobIncoming := bobChannel.localCommitChain.tail().incomingHTLCs\n\tif len(numBobOutgoing) != 1 {\n\t\tt.Fatalf(\"expected %v htlcs, instead got %v\", 1, numBobOutgoing)\n\t}\n\tif len(numBobIncoming) != 3 {\n\t\tt.Fatalf(\"expected %v htlcs, instead got %v\", 3, numBobIncoming)\n\t}\n\n\t// TODO(roasbeef): also ensure signatures were stored\n\t//  * ensure expiry matches\n\n\t// Now fetch both of the channels created above from disk to simulate a\n\t// node restart with persistence.\n\talicePub := aliceChannel.channelState.IdentityPub\n\taliceChannels, err := aliceChannel.channelState.Db.FetchOpenChannels(\n\t\talicePub,\n\t)\n\trequire.NoError(t, err, \"unable to fetch channel\")\n\tbobPub := bobChannel.channelState.IdentityPub\n\tbobChannels, err := bobChannel.channelState.Db.FetchOpenChannels(bobPub)\n\trequire.NoError(t, err, \"unable to fetch channel\")\n\n\taliceChannelNew, err := NewLightningChannel(\n\t\taliceChannel.Signer, aliceChannels[0], aliceChannel.sigPool,\n\t)\n\trequire.NoError(t, err, \"unable to create new channel\")\n\n\tbobChannelNew, err := NewLightningChannel(\n\t\tbobChannel.Signer, bobChannels[0], bobChannel.sigPool,\n\t)\n\trequire.NoError(t, err, \"unable to create new channel\")\n\n\t// The state update logs of the new channels and the old channels\n\t// should now be identical other than the height the HTLCs were added.\n\tif aliceChannel.localUpdateLog.logIndex !=\n\t\taliceChannelNew.localUpdateLog.logIndex {\n\t\tt.Fatalf(\"alice log counter: expected %v, got %v\",\n\t\t\taliceChannel.localUpdateLog.logIndex,\n\t\t\taliceChannelNew.localUpdateLog.logIndex)\n\t}\n\tif aliceChannel.remoteUpdateLog.logIndex !=\n\t\taliceChannelNew.remoteUpdateLog.logIndex {\n\t\tt.Fatalf(\"alice log counter: expected %v, got %v\",\n\t\t\taliceChannel.remoteUpdateLog.logIndex,\n\t\t\taliceChannelNew.remoteUpdateLog.logIndex)\n\t}\n\tif aliceChannel.localUpdateLog.Len() !=\n\t\taliceChannelNew.localUpdateLog.Len() {\n\t\tt.Fatalf(\"alice log len: expected %v, got %v\",\n\t\t\taliceChannel.localUpdateLog.Len(),\n\t\t\taliceChannelNew.localUpdateLog.Len())\n\t}\n\tif aliceChannel.remoteUpdateLog.Len() !=\n\t\taliceChannelNew.remoteUpdateLog.Len() {\n\t\tt.Fatalf(\"alice log len: expected %v, got %v\",\n\t\t\taliceChannel.remoteUpdateLog.Len(),\n\t\t\taliceChannelNew.remoteUpdateLog.Len())\n\t}\n\tif bobChannel.localUpdateLog.logIndex !=\n\t\tbobChannelNew.localUpdateLog.logIndex {\n\t\tt.Fatalf(\"bob log counter: expected %v, got %v\",\n\t\t\tbobChannel.localUpdateLog.logIndex,\n\t\t\tbobChannelNew.localUpdateLog.logIndex)\n\t}\n\tif bobChannel.remoteUpdateLog.logIndex !=\n\t\tbobChannelNew.remoteUpdateLog.logIndex {\n\t\tt.Fatalf(\"bob log counter: expected %v, got %v\",\n\t\t\tbobChannel.remoteUpdateLog.logIndex,\n\t\t\tbobChannelNew.remoteUpdateLog.logIndex)\n\t}\n\tif bobChannel.localUpdateLog.Len() !=\n\t\tbobChannelNew.localUpdateLog.Len() {\n\t\tt.Fatalf(\"bob log len: expected %v, got %v\",\n\t\t\tbobChannel.localUpdateLog.Len(),\n\t\t\tbobChannelNew.localUpdateLog.Len())\n\t}\n\tif bobChannel.remoteUpdateLog.Len() !=\n\t\tbobChannelNew.remoteUpdateLog.Len() {\n\t\tt.Fatalf(\"bob log len: expected %v, got %v\",\n\t\t\tbobChannel.remoteUpdateLog.Len(),\n\t\t\tbobChannelNew.remoteUpdateLog.Len())\n\t}\n\n\t// TODO(roasbeef): expand test to also ensure state revocation log has\n\t// proper pk scripts\n\n\t// Newly generated pkScripts for HTLCs should be the same as in the old channel.\n\tfor _, entry := range aliceChannel.localUpdateLog.htlcIndex {\n\t\thtlc := entry.Value.(*PaymentDescriptor)\n\t\trestoredHtlc := aliceChannelNew.localUpdateLog.lookupHtlc(htlc.HtlcIndex)\n\t\tif !bytes.Equal(htlc.ourPkScript, restoredHtlc.ourPkScript) {\n\t\t\tt.Fatalf(\"alice ourPkScript in ourLog: expected %X, got %X\",\n\t\t\t\thtlc.ourPkScript[:5], restoredHtlc.ourPkScript[:5])\n\t\t}\n\t\tif !bytes.Equal(htlc.theirPkScript, restoredHtlc.theirPkScript) {\n\t\t\tt.Fatalf(\"alice theirPkScript in ourLog: expected %X, got %X\",\n\t\t\t\thtlc.theirPkScript[:5], restoredHtlc.theirPkScript[:5])\n\t\t}\n\t}\n\tfor _, entry := range aliceChannel.remoteUpdateLog.htlcIndex {\n\t\thtlc := entry.Value.(*PaymentDescriptor)\n\t\trestoredHtlc := aliceChannelNew.remoteUpdateLog.lookupHtlc(htlc.HtlcIndex)\n\t\tif !bytes.Equal(htlc.ourPkScript, restoredHtlc.ourPkScript) {\n\t\t\tt.Fatalf(\"alice ourPkScript in theirLog: expected %X, got %X\",\n\t\t\t\thtlc.ourPkScript[:5], restoredHtlc.ourPkScript[:5])\n\t\t}\n\t\tif !bytes.Equal(htlc.theirPkScript, restoredHtlc.theirPkScript) {\n\t\t\tt.Fatalf(\"alice theirPkScript in theirLog: expected %X, got %X\",\n\t\t\t\thtlc.theirPkScript[:5], restoredHtlc.theirPkScript[:5])\n\t\t}\n\t}\n\tfor _, entry := range bobChannel.localUpdateLog.htlcIndex {\n\t\thtlc := entry.Value.(*PaymentDescriptor)\n\t\trestoredHtlc := bobChannelNew.localUpdateLog.lookupHtlc(htlc.HtlcIndex)\n\t\tif !bytes.Equal(htlc.ourPkScript, restoredHtlc.ourPkScript) {\n\t\t\tt.Fatalf(\"bob ourPkScript in ourLog: expected %X, got %X\",\n\t\t\t\thtlc.ourPkScript[:5], restoredHtlc.ourPkScript[:5])\n\t\t}\n\t\tif !bytes.Equal(htlc.theirPkScript, restoredHtlc.theirPkScript) {\n\t\t\tt.Fatalf(\"bob theirPkScript in ourLog: expected %X, got %X\",\n\t\t\t\thtlc.theirPkScript[:5], restoredHtlc.theirPkScript[:5])\n\t\t}\n\t}\n\tfor _, entry := range bobChannel.remoteUpdateLog.htlcIndex {\n\t\thtlc := entry.Value.(*PaymentDescriptor)\n\t\trestoredHtlc := bobChannelNew.remoteUpdateLog.lookupHtlc(htlc.HtlcIndex)\n\t\tif !bytes.Equal(htlc.ourPkScript, restoredHtlc.ourPkScript) {\n\t\t\tt.Fatalf(\"bob ourPkScript in theirLog: expected %X, got %X\",\n\t\t\t\thtlc.ourPkScript[:5], restoredHtlc.ourPkScript[:5])\n\t\t}\n\t\tif !bytes.Equal(htlc.theirPkScript, restoredHtlc.theirPkScript) {\n\t\t\tt.Fatalf(\"bob theirPkScript in theirLog: expected %X, got %X\",\n\t\t\t\thtlc.theirPkScript[:5], restoredHtlc.theirPkScript[:5])\n\t\t}\n\t}\n\n\t// Now settle all the HTLCs, then force a state update. The state\n\t// update should succeed as both sides have identical.\n\tfor i := 0; i < 3; i++ {\n\t\terr := bobChannelNew.SettleHTLC(alicePreimage, uint64(i), nil, nil, nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to settle htlc #%v: %v\", i, err)\n\t\t}\n\t\terr = aliceChannelNew.ReceiveHTLCSettle(alicePreimage, uint64(i))\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to settle htlc#%v: %v\", i, err)\n\t\t}\n\t}\n\terr = aliceChannelNew.SettleHTLC(bobPreimage, 0, nil, nil, nil)\n\trequire.NoError(t, err, \"unable to settle htlc\")\n\terr = bobChannelNew.ReceiveHTLCSettle(bobPreimage, 0)\n\trequire.NoError(t, err, \"unable to settle htlc\")\n\n\t// Similar to the two transitions above, as both Bob and Alice added\n\t// entries to the update log before a state transition was initiated by\n\t// either side, both sides are required to trigger an update in order\n\t// to lock in their changes.\n\tif err := ForceStateTransition(aliceChannelNew, bobChannelNew); err != nil {\n\t\tt.Fatalf(\"unable to update commitments: %v\", err)\n\t}\n\tif err := ForceStateTransition(bobChannelNew, aliceChannelNew); err != nil {\n\t\tt.Fatalf(\"unable to update commitments: %v\", err)\n\t}\n\n\t// The amounts transferred should been updated as per the amounts in\n\t// the HTLCs\n\tif aliceChannelNew.channelState.TotalMSatSent != htlcAmt*3 {\n\t\tt.Fatalf(\"expected %v alice satoshis sent, got %v\",\n\t\t\thtlcAmt*3, aliceChannelNew.channelState.TotalMSatSent)\n\t}\n\tif aliceChannelNew.channelState.TotalMSatReceived != htlcAmt {\n\t\tt.Fatalf(\"expected %v alice satoshis received, got %v\",\n\t\t\thtlcAmt, aliceChannelNew.channelState.TotalMSatReceived)\n\t}\n\tif bobChannelNew.channelState.TotalMSatSent != htlcAmt {\n\t\tt.Fatalf(\"expected %v bob satoshis sent, got %v\",\n\t\t\thtlcAmt, bobChannel.channelState.TotalMSatSent)\n\t}\n\tif bobChannelNew.channelState.TotalMSatReceived != htlcAmt*3 {\n\t\tt.Fatalf(\"expected %v bob satoshis sent, got %v\",\n\t\t\thtlcAmt*3, bobChannel.channelState.TotalMSatReceived)\n\t}\n\n\t// As a final test, we'll ensure that the HTLC counters for both sides\n\t// has been persisted properly. If we instruct Alice to add a new HTLC,\n\t// it should have an index of 3. If we instruct Bob to do the\n\t// same, it should have an index of 1.\n\taliceHtlcIndex, err := aliceChannel.AddHTLC(bobh, nil)\n\trequire.NoError(t, err, \"unable to add htlc\")\n\tif aliceHtlcIndex != 3 {\n\t\tt.Fatalf(\"wrong htlc index: expected %v, got %v\", 3, aliceHtlcIndex)\n\t}\n\tbobHtlcIndex, err := bobChannel.AddHTLC(bobh, nil)\n\trequire.NoError(t, err, \"unable to add htlc\")\n\tif bobHtlcIndex != 1 {\n\t\tt.Fatalf(\"wrong htlc index: expected %v, got %v\", 1, aliceHtlcIndex)\n\t}\n}\n",
      "length": 12159,
      "tokens": 1357,
      "embedding": []
    },
    {
      "slug": "func TestCancelHTLC(t *testing.T) {",
      "content": "func TestCancelHTLC(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a test channel which will be used for the duration of this\n\t// unittest. The channel will be funded evenly with Alice having 5 BTC,\n\t// and Bob having 5 BTC.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// Add a new HTLC from Alice to Bob, then trigger a new state\n\t// transition in order to include it in the latest state.\n\thtlcAmt := lnwire.NewMSatFromSatoshis(btcutil.SatoshiPerBitcoin)\n\n\tvar preImage [32]byte\n\tcopy(preImage[:], bytes.Repeat([]byte{0xaa}, 32))\n\thtlc := &lnwire.UpdateAddHTLC{\n\t\tPaymentHash: sha256.Sum256(preImage[:]),\n\t\tAmount:      htlcAmt,\n\t\tExpiry:      10,\n\t}\n\n\taliceHtlcIndex, err := aliceChannel.AddHTLC(htlc, nil)\n\trequire.NoError(t, err, \"unable to add alice htlc\")\n\tbobHtlcIndex, err := bobChannel.ReceiveHTLC(htlc)\n\trequire.NoError(t, err, \"unable to add bob htlc\")\n\tif err := ForceStateTransition(aliceChannel, bobChannel); err != nil {\n\t\tt.Fatalf(\"unable to create new commitment state: %v\", err)\n\t}\n\n\t// With the HTLC committed, Alice's balance should reflect the clearing\n\t// of the new HTLC.\n\taliceExpectedBalance := btcutil.Amount(btcutil.SatoshiPerBitcoin*4) -\n\t\tcalcStaticFee(channeldb.SingleFunderTweaklessBit, 1)\n\tif aliceChannel.channelState.LocalCommitment.LocalBalance.ToSatoshis() !=\n\t\taliceExpectedBalance {\n\t\tt.Fatalf(\"Alice's balance is wrong: expected %v, got %v\",\n\t\t\taliceExpectedBalance,\n\t\t\taliceChannel.channelState.LocalCommitment.LocalBalance.ToSatoshis())\n\t}\n\n\t// Now, with the HTLC committed on both sides, trigger a cancellation\n\t// from Bob to Alice, removing the HTLC.\n\terr = bobChannel.FailHTLC(bobHtlcIndex, []byte(\"failreason\"), nil, nil, nil)\n\trequire.NoError(t, err, \"unable to cancel HTLC\")\n\terr = aliceChannel.ReceiveFailHTLC(aliceHtlcIndex, []byte(\"bad\"))\n\trequire.NoError(t, err, \"unable to recv htlc cancel\")\n\n\t// Now trigger another state transition, the HTLC should now be removed\n\t// from both sides, with balances reflected.\n\tif err := ForceStateTransition(bobChannel, aliceChannel); err != nil {\n\t\tt.Fatalf(\"unable to create new commitment: %v\", err)\n\t}\n\n\t// Now HTLCs should be present on the commitment transaction for either\n\t// side.\n\tif len(aliceChannel.localCommitChain.tip().outgoingHTLCs) != 0 ||\n\t\tlen(aliceChannel.remoteCommitChain.tip().outgoingHTLCs) != 0 {\n\t\tt.Fatalf(\"htlc's still active from alice's POV\")\n\t}\n\tif len(aliceChannel.localCommitChain.tip().incomingHTLCs) != 0 ||\n\t\tlen(aliceChannel.remoteCommitChain.tip().incomingHTLCs) != 0 {\n\t\tt.Fatalf(\"htlc's still active from alice's POV\")\n\t}\n\tif len(bobChannel.localCommitChain.tip().outgoingHTLCs) != 0 ||\n\t\tlen(bobChannel.remoteCommitChain.tip().outgoingHTLCs) != 0 {\n\t\tt.Fatalf(\"htlc's still active from bob's POV\")\n\t}\n\tif len(bobChannel.localCommitChain.tip().incomingHTLCs) != 0 ||\n\t\tlen(bobChannel.remoteCommitChain.tip().incomingHTLCs) != 0 {\n\t\tt.Fatalf(\"htlc's still active from bob's POV\")\n\t}\n\n\texpectedBalance := btcutil.Amount(btcutil.SatoshiPerBitcoin * 5)\n\tstaticFee := calcStaticFee(channeldb.SingleFunderTweaklessBit, 0)\n\tif aliceChannel.channelState.LocalCommitment.LocalBalance.ToSatoshis() !=\n\t\texpectedBalance-staticFee {\n\n\t\tt.Fatalf(\"balance is wrong: expected %v, got %v\",\n\t\t\taliceChannel.channelState.LocalCommitment.LocalBalance.ToSatoshis(),\n\t\t\texpectedBalance-staticFee)\n\t}\n\tif aliceChannel.channelState.LocalCommitment.RemoteBalance.ToSatoshis() !=\n\t\texpectedBalance {\n\n\t\tt.Fatalf(\"balance is wrong: expected %v, got %v\",\n\t\t\taliceChannel.channelState.LocalCommitment.RemoteBalance.ToSatoshis(),\n\t\t\texpectedBalance)\n\t}\n\tif bobChannel.channelState.LocalCommitment.LocalBalance.ToSatoshis() !=\n\t\texpectedBalance {\n\n\t\tt.Fatalf(\"balance is wrong: expected %v, got %v\",\n\t\t\tbobChannel.channelState.LocalCommitment.LocalBalance.ToSatoshis(),\n\t\t\texpectedBalance)\n\t}\n\tif bobChannel.channelState.LocalCommitment.RemoteBalance.ToSatoshis() !=\n\t\texpectedBalance-staticFee {\n\n\t\tt.Fatalf(\"balance is wrong: expected %v, got %v\",\n\t\t\tbobChannel.channelState.LocalCommitment.RemoteBalance.ToSatoshis(),\n\t\t\texpectedBalance-staticFee)\n\t}\n}\n",
      "length": 4025,
      "tokens": 400,
      "embedding": []
    },
    {
      "slug": "func TestCooperativeCloseDustAdherence(t *testing.T) {",
      "content": "func TestCooperativeCloseDustAdherence(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a test channel which will be used for the duration of this\n\t// unittest. The channel will be funded evenly with Alice having 5 BTC,\n\t// and Bob having 5 BTC.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\taliceFeeRate := chainfee.SatPerKWeight(\n\t\taliceChannel.channelState.LocalCommitment.FeePerKw,\n\t)\n\tbobFeeRate := chainfee.SatPerKWeight(\n\t\tbobChannel.channelState.LocalCommitment.FeePerKw,\n\t)\n\n\tsetDustLimit := func(dustVal btcutil.Amount) {\n\t\taliceChannel.channelState.LocalChanCfg.DustLimit = dustVal\n\t\taliceChannel.channelState.RemoteChanCfg.DustLimit = dustVal\n\t\tbobChannel.channelState.LocalChanCfg.DustLimit = dustVal\n\t\tbobChannel.channelState.RemoteChanCfg.DustLimit = dustVal\n\t}\n\n\tresetChannelState := func() {\n\t\taliceChannel.status = channelOpen\n\t\tbobChannel.status = channelOpen\n\t}\n\n\tsetBalances := func(aliceBalance, bobBalance lnwire.MilliSatoshi) {\n\t\taliceChannel.channelState.LocalCommitment.LocalBalance = aliceBalance\n\t\taliceChannel.channelState.LocalCommitment.RemoteBalance = bobBalance\n\t\tbobChannel.channelState.LocalCommitment.LocalBalance = bobBalance\n\t\tbobChannel.channelState.LocalCommitment.RemoteBalance = aliceBalance\n\t}\n\n\taliceDeliveryScript := bobsPrivKey[:]\n\tbobDeliveryScript := testHdSeed[:]\n\n\t// We'll start be initializing the limit of both Alice and Bob to 10k\n\t// satoshis.\n\tdustLimit := btcutil.Amount(10000)\n\tsetDustLimit(dustLimit)\n\n\t// Both sides currently have over 1 BTC settled as part of their\n\t// balances. As a result, performing a cooperative closure now result\n\t// in both sides having an output within the closure transaction.\n\taliceFee := btcutil.Amount(aliceChannel.CalcFee(aliceFeeRate)) + 1000\n\taliceSig, _, _, err := aliceChannel.CreateCloseProposal(\n\t\taliceFee, aliceDeliveryScript, bobDeliveryScript,\n\t)\n\trequire.NoError(t, err, \"unable to close channel\")\n\n\tbobFee := btcutil.Amount(bobChannel.CalcFee(bobFeeRate)) + 1000\n\tbobSig, _, _, err := bobChannel.CreateCloseProposal(\n\t\tbobFee, bobDeliveryScript, aliceDeliveryScript,\n\t)\n\trequire.NoError(t, err, \"unable to close channel\")\n\n\tcloseTx, _, err := bobChannel.CompleteCooperativeClose(\n\t\tbobSig, aliceSig, bobDeliveryScript, aliceDeliveryScript,\n\t\tbobFee,\n\t)\n\trequire.NoError(t, err, \"unable to accept channel close\")\n\n\t// The closure transaction should have exactly two outputs.\n\tif len(closeTx.TxOut) != 2 {\n\t\tt.Fatalf(\"close tx has wrong number of outputs: expected %v \"+\n\t\t\t\"got %v\", 2, len(closeTx.TxOut))\n\t}\n\n\t// We'll reset the channel states before proceeding to our next test.\n\tresetChannelState()\n\n\t// Next we'll modify the current balances and dust limits such that\n\t// Bob's current balance is _below_ his dust limit.\n\taliceBal := lnwire.NewMSatFromSatoshis(btcutil.SatoshiPerBitcoin)\n\tbobBal := lnwire.NewMSatFromSatoshis(250)\n\tsetBalances(aliceBal, bobBal)\n\n\t// Attempt another cooperative channel closure. It should succeed\n\t// without any issues.\n\taliceSig, _, _, err = aliceChannel.CreateCloseProposal(\n\t\taliceFee, aliceDeliveryScript, bobDeliveryScript,\n\t)\n\trequire.NoError(t, err, \"unable to close channel\")\n\n\tbobSig, _, _, err = bobChannel.CreateCloseProposal(\n\t\tbobFee, bobDeliveryScript, aliceDeliveryScript,\n\t)\n\trequire.NoError(t, err, \"unable to close channel\")\n\n\tcloseTx, _, err = bobChannel.CompleteCooperativeClose(\n\t\tbobSig, aliceSig, bobDeliveryScript, aliceDeliveryScript,\n\t\tbobFee,\n\t)\n\trequire.NoError(t, err, \"unable to accept channel close\")\n\n\t// The closure transaction should only have a single output, and that\n\t// output should be Alice's balance.\n\tif len(closeTx.TxOut) != 1 {\n\t\tt.Fatalf(\"close tx has wrong number of outputs: expected %v \"+\n\t\t\t\"got %v\", 1, len(closeTx.TxOut))\n\t}\n\tcommitFee := aliceChannel.channelState.LocalCommitment.CommitFee\n\taliceExpectedBalance := aliceBal.ToSatoshis() - aliceFee + commitFee\n\tif closeTx.TxOut[0].Value != int64(aliceExpectedBalance) {\n\t\tt.Fatalf(\"alice's balance is incorrect: expected %v, got %v\",\n\t\t\taliceExpectedBalance,\n\t\t\tint64(closeTx.TxOut[0].Value))\n\t}\n\n\t// We'll modify the current balances and dust limits such that\n\t// Alice's current balance is too low to pay the proposed fee.\n\tsetBalances(bobBal, aliceBal)\n\tresetChannelState()\n\n\t// Attempting to close with this fee now should fail, since Alice\n\t// cannot afford it.\n\t_, _, _, err = aliceChannel.CreateCloseProposal(\n\t\taliceFee, aliceDeliveryScript, bobDeliveryScript,\n\t)\n\tif err == nil {\n\t\tt.Fatalf(\"expected error\")\n\t}\n\n\t// Finally, we'll modify the current balances and dust limits such that\n\t// Alice's balance after paying the coop fee is _below_ her dust limit.\n\tlowBalance := lnwire.NewMSatFromSatoshis(aliceFee) + 1000\n\tsetBalances(lowBalance, aliceBal)\n\tresetChannelState()\n\n\t// Our final attempt at another cooperative channel closure. It should\n\t// succeed without any issues.\n\taliceSig, _, _, err = aliceChannel.CreateCloseProposal(\n\t\taliceFee, aliceDeliveryScript, bobDeliveryScript,\n\t)\n\trequire.NoError(t, err, \"unable to close channel\")\n\n\tbobSig, _, _, err = bobChannel.CreateCloseProposal(\n\t\tbobFee, bobDeliveryScript, aliceDeliveryScript,\n\t)\n\trequire.NoError(t, err, \"unable to close channel\")\n\n\tcloseTx, _, err = bobChannel.CompleteCooperativeClose(\n\t\tbobSig, aliceSig, bobDeliveryScript, aliceDeliveryScript,\n\t\tbobFee,\n\t)\n\trequire.NoError(t, err, \"unable to accept channel close\")\n\n\t// The closure transaction should only have a single output, and that\n\t// output should be Bob's balance.\n\tif len(closeTx.TxOut) != 1 {\n\t\tt.Fatalf(\"close tx has wrong number of outputs: expected %v \"+\n\t\t\t\"got %v\", 1, len(closeTx.TxOut))\n\t}\n\tif closeTx.TxOut[0].Value != int64(aliceBal.ToSatoshis()) {\n\t\tt.Fatalf(\"bob's balance is incorrect: expected %v, got %v\",\n\t\t\taliceBal.ToSatoshis(), closeTx.TxOut[0].Value)\n\t}\n}\n\n// TestUpdateFeeAdjustments tests that the state machine is able to properly\n// accept valid fee changes, as well as reject any invalid fee updates.",
      "length": 5800,
      "tokens": 664,
      "embedding": []
    },
    {
      "slug": "func TestUpdateFeeAdjustments(t *testing.T) {",
      "content": "func TestUpdateFeeAdjustments(t *testing.T) {\n\tt.Parallel()\n\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// First, we'll grab the current base fee rate as we'll be using this\n\t// to make relative adjustments int he fee rate.\n\tbaseFeeRate := aliceChannel.channelState.LocalCommitment.FeePerKw\n\n\t// We'll first try to increase the fee rate 5x, this should be able to\n\t// be committed without any issue.\n\tnewFee := chainfee.SatPerKWeight(baseFeeRate * 5)\n\n\tif err := aliceChannel.UpdateFee(newFee); err != nil {\n\t\tt.Fatalf(\"unable to alice update fee: %v\", err)\n\t}\n\tif err := bobChannel.ReceiveUpdateFee(newFee); err != nil {\n\t\tt.Fatalf(\"unable to bob update fee: %v\", err)\n\t}\n\n\t// With the fee updates applied, we'll now initiate a state transition\n\t// to ensure the fee update is locked in.\n\tif err := ForceStateTransition(aliceChannel, bobChannel); err != nil {\n\t\tt.Fatalf(\"unable to create new commitment: %v\", err)\n\t}\n\n\t// We'll now attempt to increase the fee rate 1,000,000x of the base\n\t// fee.  This should result in an error as Alice won't be able to pay\n\t// this new fee rate.\n\tnewFee = chainfee.SatPerKWeight(baseFeeRate * 1000000)\n\tif err := aliceChannel.UpdateFee(newFee); err == nil {\n\t\tt.Fatalf(\"alice should reject the fee rate\")\n\t}\n\n\t// Finally, we'll attempt to adjust the fee down and use a fee which is\n\t// smaller than the initial base fee rate. The fee application and\n\t// state transition should proceed without issue.\n\tnewFee = chainfee.SatPerKWeight(baseFeeRate / 10)\n\tif err := aliceChannel.UpdateFee(newFee); err != nil {\n\t\tt.Fatalf(\"unable to alice update fee: %v\", err)\n\t}\n\tif err := bobChannel.ReceiveUpdateFee(newFee); err != nil {\n\t\tt.Fatalf(\"unable to bob update fee: %v\", err)\n\t}\n\tif err := ForceStateTransition(aliceChannel, bobChannel); err != nil {\n\t\tt.Fatalf(\"unable to create new commitment: %v\", err)\n\t}\n}\n\n// TestUpdateFeeFail tests that the signature verification will fail if they\n// fee updates are out of sync.",
      "length": 1970,
      "tokens": 298,
      "embedding": []
    },
    {
      "slug": "func TestUpdateFeeFail(t *testing.T) {",
      "content": "func TestUpdateFeeFail(t *testing.T) {\n\tt.Parallel()\n\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// Bob receives the update, that will apply to his commitment\n\t// transaction.\n\tif err := bobChannel.ReceiveUpdateFee(333); err != nil {\n\t\tt.Fatalf(\"unable to apply fee update: %v\", err)\n\t}\n\n\t// Alice sends signature for commitment that does not cover any fee\n\t// update.\n\taliceSig, aliceHtlcSigs, _, err := aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"alice unable to sign commitment\")\n\n\t// Bob verifies this commit, meaning that he checks that it is\n\t// consistent everything he has received. This should fail, since he got\n\t// the fee update, but Alice never sent it.\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\tif err == nil {\n\t\tt.Fatalf(\"expected bob to fail receiving alice's signature\")\n\t}\n\n}\n\n// TestUpdateFeeConcurrentSig tests that the channel can properly handle a fee\n// update that it receives concurrently with signing its next commitment.",
      "length": 1034,
      "tokens": 145,
      "embedding": []
    },
    {
      "slug": "func TestUpdateFeeConcurrentSig(t *testing.T) {",
      "content": "func TestUpdateFeeConcurrentSig(t *testing.T) {\n\tt.Parallel()\n\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\tpaymentPreimage := bytes.Repeat([]byte{1}, 32)\n\tpaymentHash := sha256.Sum256(paymentPreimage)\n\thtlc := &lnwire.UpdateAddHTLC{\n\t\tPaymentHash: paymentHash,\n\t\tAmount:      btcutil.SatoshiPerBitcoin,\n\t\tExpiry:      uint32(5),\n\t}\n\n\t// First Alice adds the outgoing HTLC to her local channel's state\n\t// update log. Then Alice sends this wire message over to Bob who\n\t// adds this htlc to his remote state update log.\n\tif _, err := aliceChannel.AddHTLC(htlc, nil); err != nil {\n\t\tt.Fatalf(\"unable to add htlc: %v\", err)\n\t}\n\tif _, err := bobChannel.ReceiveHTLC(htlc); err != nil {\n\t\tt.Fatalf(\"unable to recv htlc: %v\", err)\n\t}\n\n\t// Simulate Alice sending update fee message to bob.\n\tfee := chainfee.SatPerKWeight(333)\n\tif err := aliceChannel.UpdateFee(fee); err != nil {\n\t\tt.Fatalf(\"unable to send fee update\")\n\t}\n\n\t// Alice signs a commitment, and sends this to bob.\n\taliceSig, aliceHtlcSigs, _, err := aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"alice unable to sign commitment\")\n\n\t// At the same time, Bob signs a commitment.\n\tbobSig, bobHtlcSigs, _, err := bobChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"bob unable to sign alice's commitment\")\n\n\t// ...that Alice receives.\n\terr = aliceChannel.ReceiveNewCommitment(bobSig, bobHtlcSigs)\n\trequire.NoError(t, err, \"alice unable to process bob's new commitment\")\n\n\t// Now let Bob receive the fee update + commitment that Alice sent.\n\tif err := bobChannel.ReceiveUpdateFee(fee); err != nil {\n\t\tt.Fatalf(\"unable to receive fee update\")\n\t}\n\n\t// Bob receives this signature message, and verifies that it is\n\t// consistent with the state he had for Alice, including the received\n\t// HTLC and fee update.\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\trequire.NoError(t, err, \"bob unable to process alice's new commitment\")\n\n\tif chainfee.SatPerKWeight(bobChannel.channelState.LocalCommitment.FeePerKw) == fee {\n\t\tt.Fatalf(\"bob's feePerKw was unexpectedly locked in\")\n\t}\n\n\t// Bob can revoke the prior commitment he had. This should lock in the\n\t// fee update for him.\n\t_, _, _, err = bobChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"unable to generate bob revocation\")\n\n\tif chainfee.SatPerKWeight(bobChannel.channelState.LocalCommitment.FeePerKw) != fee {\n\t\tt.Fatalf(\"bob's feePerKw was not locked in\")\n\t}\n}\n\n// TestUpdateFeeSenderCommits verifies that the state machine progresses as\n// expected if we send a fee update, and then the sender of the fee update\n// sends a commitment signature.",
      "length": 2590,
      "tokens": 345,
      "embedding": []
    },
    {
      "slug": "func TestUpdateFeeSenderCommits(t *testing.T) {",
      "content": "func TestUpdateFeeSenderCommits(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a test channel which will be used for the duration of this\n\t// unittest. The channel will be funded evenly with Alice having 5 BTC,\n\t// and Bob having 5 BTC.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\tpaymentPreimage := bytes.Repeat([]byte{1}, 32)\n\tpaymentHash := sha256.Sum256(paymentPreimage)\n\thtlc := &lnwire.UpdateAddHTLC{\n\t\tPaymentHash: paymentHash,\n\t\tAmount:      btcutil.SatoshiPerBitcoin,\n\t\tExpiry:      uint32(5),\n\t}\n\n\t// First Alice adds the outgoing HTLC to her local channel's state\n\t// update log. Then Alice sends this wire message over to Bob who\n\t// adds this htlc to his remote state update log.\n\tif _, err := aliceChannel.AddHTLC(htlc, nil); err != nil {\n\t\tt.Fatalf(\"unable to add htlc: %v\", err)\n\t}\n\tif _, err := bobChannel.ReceiveHTLC(htlc); err != nil {\n\t\tt.Fatalf(\"unable to recv htlc: %v\", err)\n\t}\n\n\t// Simulate Alice sending update fee message to bob.\n\tfee := chainfee.SatPerKWeight(333)\n\taliceChannel.UpdateFee(fee)\n\tbobChannel.ReceiveUpdateFee(fee)\n\n\t// Alice signs a commitment, which will cover everything sent to Bob\n\t// (the HTLC and the fee update), and everything acked by Bob (nothing\n\t// so far).\n\taliceSig, aliceHtlcSigs, _, err := aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"alice unable to sign commitment\")\n\n\t// Bob receives this signature message, and verifies that it is\n\t// consistent with the state he had for Alice, including the received\n\t// HTLC and fee update.\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\trequire.NoError(t, err, \"bob unable to process alice's new commitment\")\n\n\tif chainfee.SatPerKWeight(\n\t\tbobChannel.channelState.LocalCommitment.FeePerKw,\n\t) == fee {\n\n\t\tt.Fatalf(\"bob's feePerKw was unexpectedly locked in\")\n\t}\n\n\t// Bob can revoke the prior commitment he had. This should lock in the\n\t// fee update for him.\n\tbobRevocation, _, _, err := bobChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"unable to generate bob revocation\")\n\n\tif chainfee.SatPerKWeight(\n\t\tbobChannel.channelState.LocalCommitment.FeePerKw,\n\t) != fee {\n\n\t\tt.Fatalf(\"bob's feePerKw was not locked in\")\n\t}\n\n\t// Bob commits to all updates he has received from Alice. This includes\n\t// the HTLC he received, and the fee update.\n\tbobSig, bobHtlcSigs, _, err := bobChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"bob unable to sign alice's commitment\")\n\n\t// Alice receives the revocation of the old one, and can now assume\n\t// that Bob's received everything up to the signature she sent,\n\t// including the HTLC and fee update.\n\t_, _, _, _, err = aliceChannel.ReceiveRevocation(bobRevocation)\n\trequire.NoError(t, err, \"alice unable to process bob's revocation\")\n\n\t// Alice receives new signature from Bob, and assumes this covers the\n\t// changes.\n\terr = aliceChannel.ReceiveNewCommitment(bobSig, bobHtlcSigs)\n\trequire.NoError(t, err, \"alice unable to process bob's new commitment\")\n\n\tif chainfee.SatPerKWeight(\n\t\taliceChannel.channelState.LocalCommitment.FeePerKw,\n\t) == fee {\n\n\t\tt.Fatalf(\"alice's feePerKw was unexpectedly locked in\")\n\t}\n\n\t// Alice can revoke the old commitment, which will lock in the fee\n\t// update.\n\taliceRevocation, _, _, err := aliceChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"unable to revoke alice channel\")\n\n\tif chainfee.SatPerKWeight(\n\t\taliceChannel.channelState.LocalCommitment.FeePerKw,\n\t) != fee {\n\n\t\tt.Fatalf(\"alice's feePerKw was not locked in\")\n\t}\n\n\t// Bob receives revocation from Alice.\n\t_, _, _, _, err = bobChannel.ReceiveRevocation(aliceRevocation)\n\trequire.NoError(t, err, \"bob unable to process alice's revocation\")\n\n}\n\n// TestUpdateFeeReceiverCommits tests that the state machine progresses as\n// expected if we send a fee update, and then the receiver of the fee update\n// sends a commitment signature.",
      "length": 3773,
      "tokens": 507,
      "embedding": []
    },
    {
      "slug": "func TestUpdateFeeReceiverCommits(t *testing.T) {",
      "content": "func TestUpdateFeeReceiverCommits(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a test channel which will be used for the duration of this\n\t// unittest. The channel will be funded evenly with Alice having 5 BTC,\n\t// and Bob having 5 BTC.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\tpaymentPreimage := bytes.Repeat([]byte{1}, 32)\n\tpaymentHash := sha256.Sum256(paymentPreimage)\n\thtlc := &lnwire.UpdateAddHTLC{\n\t\tPaymentHash: paymentHash,\n\t\tAmount:      btcutil.SatoshiPerBitcoin,\n\t\tExpiry:      uint32(5),\n\t}\n\n\t// First Alice adds the outgoing HTLC to her local channel's state\n\t// update log. Then Alice sends this wire message over to Bob who\n\t// adds this htlc to his remote state update log.\n\tif _, err := aliceChannel.AddHTLC(htlc, nil); err != nil {\n\t\tt.Fatalf(\"unable to add htlc: %v\", err)\n\t}\n\tif _, err := bobChannel.ReceiveHTLC(htlc); err != nil {\n\t\tt.Fatalf(\"unable to recv htlc: %v\", err)\n\t}\n\n\t// Simulate Alice sending update fee message to bob\n\tfee := chainfee.SatPerKWeight(333)\n\taliceChannel.UpdateFee(fee)\n\tbobChannel.ReceiveUpdateFee(fee)\n\n\t// Bob commits to every change he has sent since last time (none). He\n\t// does not commit to the received HTLC and fee update, since Alice\n\t// cannot know if he has received them.\n\tbobSig, bobHtlcSigs, _, err := bobChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"alice unable to sign commitment\")\n\n\t// Alice receives this signature message, and verifies that it is\n\t// consistent with the remote state, not including any of the updates.\n\terr = aliceChannel.ReceiveNewCommitment(bobSig, bobHtlcSigs)\n\trequire.NoError(t, err, \"bob unable to process alice's new commitment\")\n\n\t// Alice can revoke the prior commitment she had, this will ack\n\t// everything received before last commitment signature, but in this\n\t// case that is nothing.\n\taliceRevocation, _, _, err := aliceChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"unable to generate bob revocation\")\n\n\t// Bob receives the revocation of the old commitment\n\t_, _, _, _, err = bobChannel.ReceiveRevocation(aliceRevocation)\n\trequire.NoError(t, err, \"alice unable to process bob's revocation\")\n\n\t// Alice will sign next commitment. Since she sent the revocation, she\n\t// also ack'ed everything received, but in this case this is nothing.\n\t// Since she sent the two updates, this signature will cover those two.\n\taliceSig, aliceHtlcSigs, _, err := aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"bob unable to sign alice's commitment\")\n\n\t// Bob gets the signature for the new commitment from Alice. He assumes\n\t// this covers everything received from alice, including the two updates.\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\trequire.NoError(t, err, \"alice unable to process bob's new commitment\")\n\n\tif chainfee.SatPerKWeight(\n\t\tbobChannel.channelState.LocalCommitment.FeePerKw,\n\t) == fee {\n\n\t\tt.Fatalf(\"bob's feePerKw was unexpectedly locked in\")\n\t}\n\n\t// Bob can revoke the old commitment. This will ack what he has\n\t// received, including the HTLC and fee update. This will lock in the\n\t// fee update for bob.\n\tbobRevocation, _, _, err := bobChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"unable to revoke alice channel\")\n\n\tif chainfee.SatPerKWeight(\n\t\tbobChannel.channelState.LocalCommitment.FeePerKw,\n\t) != fee {\n\n\t\tt.Fatalf(\"bob's feePerKw was not locked in\")\n\t}\n\n\t// Bob will send a new signature, which will cover what he just acked:\n\t// the HTLC and fee update.\n\tbobSig, bobHtlcSigs, _, err = bobChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"alice unable to sign commitment\")\n\n\t// Alice receives revocation from Bob, and can now be sure that Bob\n\t// received the two updates, and they are considered locked in.\n\t_, _, _, _, err = aliceChannel.ReceiveRevocation(bobRevocation)\n\trequire.NoError(t, err, \"bob unable to process alice's revocation\")\n\n\t// Alice will receive the signature from Bob, which will cover what was\n\t// just acked by his revocation.\n\terr = aliceChannel.ReceiveNewCommitment(bobSig, bobHtlcSigs)\n\trequire.NoError(t, err, \"alice unable to process bob's new commitment\")\n\n\tif chainfee.SatPerKWeight(\n\t\taliceChannel.channelState.LocalCommitment.FeePerKw,\n\t) == fee {\n\n\t\tt.Fatalf(\"alice's feePerKw was unexpectedly locked in\")\n\t}\n\n\t// After Alice now revokes her old commitment, the fee update should\n\t// lock in.\n\taliceRevocation, _, _, err = aliceChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"unable to generate bob revocation\")\n\n\tif chainfee.SatPerKWeight(\n\t\taliceChannel.channelState.LocalCommitment.FeePerKw,\n\t) != fee {\n\n\t\tt.Fatalf(\"Alice's feePerKw was not locked in\")\n\t}\n\n\t// Bob receives revocation from Alice.\n\t_, _, _, _, err = bobChannel.ReceiveRevocation(aliceRevocation)\n\trequire.NoError(t, err, \"bob unable to process alice's revocation\")\n}\n\n// TestUpdateFeeReceiverSendsUpdate tests that receiving a fee update as channel\n// initiator fails, and that trying to initiate fee update as non-initiation\n// fails.",
      "length": 4878,
      "tokens": 662,
      "embedding": []
    },
    {
      "slug": "func TestUpdateFeeReceiverSendsUpdate(t *testing.T) {",
      "content": "func TestUpdateFeeReceiverSendsUpdate(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a test channel which will be used for the duration of this\n\t// unittest. The channel will be funded evenly with Alice having 5 BTC,\n\t// and Bob having 5 BTC.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// Since Alice is the channel initiator, she should fail when receiving\n\t// fee update\n\tfee := chainfee.SatPerKWeight(333)\n\terr = aliceChannel.ReceiveUpdateFee(fee)\n\tif err == nil {\n\t\tt.Fatalf(\"expected alice to fail receiving fee update\")\n\t}\n\n\t// Similarly, initiating fee update should fail for Bob.\n\terr = bobChannel.UpdateFee(fee)\n\tif err == nil {\n\t\tt.Fatalf(\"expected bob to fail initiating fee update\")\n\t}\n}\n\n// Test that if multiple update fee messages are sent consecutively, then the\n// last one is the one that is being committed to.",
      "length": 860,
      "tokens": 133,
      "embedding": []
    },
    {
      "slug": "func TestUpdateFeeMultipleUpdates(t *testing.T) {",
      "content": "func TestUpdateFeeMultipleUpdates(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a test channel which will be used for the duration of this\n\t// unittest. The channel will be funded evenly with Alice having 5 BTC,\n\t// and Bob having 5 BTC.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// Simulate Alice sending update fee message to bob.\n\tfee1 := chainfee.SatPerKWeight(333)\n\tfee2 := chainfee.SatPerKWeight(333)\n\tfee := chainfee.SatPerKWeight(333)\n\taliceChannel.UpdateFee(fee1)\n\taliceChannel.UpdateFee(fee2)\n\taliceChannel.UpdateFee(fee)\n\n\t// Alice signs a commitment, which will cover everything sent to Bob\n\t// (the HTLC and the fee update), and everything acked by Bob (nothing\n\t// so far).\n\taliceSig, aliceHtlcSigs, _, err := aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"alice unable to sign commitment\")\n\n\tbobChannel.ReceiveUpdateFee(fee1)\n\tbobChannel.ReceiveUpdateFee(fee2)\n\tbobChannel.ReceiveUpdateFee(fee)\n\n\t// Bob receives this signature message, and verifies that it is\n\t// consistent with the state he had for Alice, including the received\n\t// HTLC and fee update.\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\trequire.NoError(t, err, \"bob unable to process alice's new commitment\")\n\n\tif chainfee.SatPerKWeight(\n\t\tbobChannel.channelState.LocalCommitment.FeePerKw,\n\t) == fee {\n\n\t\tt.Fatalf(\"bob's feePerKw was unexpectedly locked in\")\n\t}\n\n\t// Alice sending more fee updates now should not mess up the old fee\n\t// they both committed to.\n\tfee3 := chainfee.SatPerKWeight(444)\n\tfee4 := chainfee.SatPerKWeight(555)\n\tfee5 := chainfee.SatPerKWeight(666)\n\taliceChannel.UpdateFee(fee3)\n\taliceChannel.UpdateFee(fee4)\n\taliceChannel.UpdateFee(fee5)\n\tbobChannel.ReceiveUpdateFee(fee3)\n\tbobChannel.ReceiveUpdateFee(fee4)\n\tbobChannel.ReceiveUpdateFee(fee5)\n\n\t// Bob can revoke the prior commitment he had. This should lock in the\n\t// fee update for him.\n\tbobRevocation, _, _, err := bobChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"unable to generate bob revocation\")\n\n\tif chainfee.SatPerKWeight(\n\t\tbobChannel.channelState.LocalCommitment.FeePerKw,\n\t) != fee {\n\n\t\tt.Fatalf(\"bob's feePerKw was not locked in\")\n\t}\n\n\t// Bob commits to all updates he has received from Alice. This includes\n\t// the HTLC he received, and the fee update.\n\tbobSig, bobHtlcSigs, _, err := bobChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"bob unable to sign alice's commitment\")\n\n\t// Alice receives the revocation of the old one, and can now assume that\n\t// Bob's received everything up to the signature she sent, including the\n\t// HTLC and fee update.\n\t_, _, _, _, err = aliceChannel.ReceiveRevocation(bobRevocation)\n\trequire.NoError(t, err, \"alice unable to process bob's revocation\")\n\n\t// Alice receives new signature from Bob, and assumes this covers the\n\t// changes.\n\tif err := aliceChannel.ReceiveNewCommitment(bobSig, bobHtlcSigs); err != nil {\n\t\tt.Fatalf(\"alice unable to process bob's new commitment: %v\", err)\n\t}\n\n\tif chainfee.SatPerKWeight(\n\t\taliceChannel.channelState.LocalCommitment.FeePerKw,\n\t) == fee {\n\n\t\tt.Fatalf(\"alice's feePerKw was unexpectedly locked in\")\n\t}\n\n\t// Alice can revoke the old commitment, which will lock in the fee\n\t// update.\n\taliceRevocation, _, _, err := aliceChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"unable to revoke alice channel\")\n\n\tif chainfee.SatPerKWeight(\n\t\taliceChannel.channelState.LocalCommitment.FeePerKw,\n\t) != fee {\n\n\t\tt.Fatalf(\"alice's feePerKw was not locked in\")\n\t}\n\n\t// Bob receives revocation from Alice.\n\t_, _, _, _, err = bobChannel.ReceiveRevocation(aliceRevocation)\n\trequire.NoError(t, err, \"bob unable to process alice's revocation\")\n}\n\n// TestAddHTLCNegativeBalance tests that if enough HTLC's are added to the\n// state machine to drive the balance to zero, then the next HTLC attempted to\n// be added will result in an error being returned.",
      "length": 3796,
      "tokens": 478,
      "embedding": []
    },
    {
      "slug": "func TestAddHTLCNegativeBalance(t *testing.T) {",
      "content": "func TestAddHTLCNegativeBalance(t *testing.T) {\n\tt.Parallel()\n\n\t// We'll kick off the test by creating our channels which both are\n\t// loaded with 5 BTC each.\n\taliceChannel, _, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// We set the channel reserve to 0, such that we can add HTLCs all the\n\t// way to a negative balance.\n\taliceChannel.channelState.LocalChanCfg.ChanReserve = 0\n\n\t// First, we'll add 3 HTLCs of 1 BTC each to Alice's commitment.\n\tconst numHTLCs = 3\n\thtlcAmt := lnwire.NewMSatFromSatoshis(btcutil.SatoshiPerBitcoin)\n\tfor i := 0; i < numHTLCs; i++ {\n\t\thtlc, _ := createHTLC(i, htlcAmt)\n\t\tif _, err := aliceChannel.AddHTLC(htlc, nil); err != nil {\n\t\t\tt.Fatalf(\"unable to add htlc: %v\", err)\n\t\t}\n\t}\n\n\t// Alice now has an available balance of 2 BTC. We'll add a new HTLC of\n\t// value 2 BTC, which should make Alice's balance negative (since she\n\t// has to pay a commitment fee).\n\thtlcAmt = lnwire.NewMSatFromSatoshis(2 * btcutil.SatoshiPerBitcoin)\n\thtlc, _ := createHTLC(numHTLCs+1, htlcAmt)\n\t_, err = aliceChannel.AddHTLC(htlc, nil)\n\trequire.ErrorIs(t, err, ErrBelowChanReserve)\n}\n\n// assertNoChanSyncNeeded is a helper function that asserts that upon restart,\n// two channels conclude that they're fully synchronized and don't need to\n// retransmit any new messages.",
      "length": 1286,
      "tokens": 194,
      "embedding": []
    },
    {
      "slug": "func assertNoChanSyncNeeded(t *testing.T, aliceChannel *LightningChannel,",
      "content": "func assertNoChanSyncNeeded(t *testing.T, aliceChannel *LightningChannel,\n\tbobChannel *LightningChannel) {\n\n\t_, _, line, _ := runtime.Caller(1)\n\n\taliceChanSyncMsg, err := aliceChannel.channelState.ChanSyncMsg()\n\tif err != nil {\n\t\tt.Fatalf(\"line #%v: unable to produce chan sync msg: %v\",\n\t\t\tline, err)\n\t}\n\tbobMsgsToSend, _, _, err := bobChannel.ProcessChanSyncMsg(aliceChanSyncMsg)\n\tif err != nil {\n\t\tt.Fatalf(\"line #%v: unable to process ChannelReestablish \"+\n\t\t\t\"msg: %v\", line, err)\n\t}\n\tif len(bobMsgsToSend) != 0 {\n\t\tt.Fatalf(\"line #%v: bob shouldn't have to send any messages, \"+\n\t\t\t\"instead wants to send: %v\", line, spew.Sdump(bobMsgsToSend))\n\t}\n\n\tbobChanSyncMsg, err := bobChannel.channelState.ChanSyncMsg()\n\tif err != nil {\n\t\tt.Fatalf(\"line #%v: unable to produce chan sync msg: %v\",\n\t\t\tline, err)\n\t}\n\taliceMsgsToSend, _, _, err := aliceChannel.ProcessChanSyncMsg(bobChanSyncMsg)\n\tif err != nil {\n\t\tt.Fatalf(\"line #%v: unable to process ChannelReestablish \"+\n\t\t\t\"msg: %v\", line, err)\n\t}\n\tif len(bobMsgsToSend) != 0 {\n\t\tt.Fatalf(\"line #%v: alice shouldn't have to send any \"+\n\t\t\t\"messages, instead wants to send: %v\", line,\n\t\t\tspew.Sdump(aliceMsgsToSend))\n\t}\n}\n\n// TestChanSyncFullySynced tests that after a successful commitment exchange,\n// and a forced restart, both nodes conclude that they're fully synchronized\n// and don't need to retransmit any messages.",
      "length": 1258,
      "tokens": 173,
      "embedding": []
    },
    {
      "slug": "func TestChanSyncFullySynced(t *testing.T) {",
      "content": "func TestChanSyncFullySynced(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a test channel which will be used for the duration of this\n\t// unittest. The channel will be funded evenly with Alice having 5 BTC,\n\t// and Bob having 5 BTC.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// If we exchange channel sync messages from the get-go , then both\n\t// sides should conclude that no further synchronization is needed.\n\tassertNoChanSyncNeeded(t, aliceChannel, bobChannel)\n\n\t// Next, we'll create an HTLC for Alice to extend to Bob.\n\tvar paymentPreimage [32]byte\n\tcopy(paymentPreimage[:], bytes.Repeat([]byte{1}, 32))\n\tpaymentHash := sha256.Sum256(paymentPreimage[:])\n\thtlcAmt := lnwire.NewMSatFromSatoshis(btcutil.SatoshiPerBitcoin)\n\thtlc := &lnwire.UpdateAddHTLC{\n\t\tPaymentHash: paymentHash,\n\t\tAmount:      htlcAmt,\n\t\tExpiry:      uint32(5),\n\t}\n\taliceHtlcIndex, err := aliceChannel.AddHTLC(htlc, nil)\n\trequire.NoError(t, err, \"unable to add htlc\")\n\tbobHtlcIndex, err := bobChannel.ReceiveHTLC(htlc)\n\trequire.NoError(t, err, \"unable to recv htlc\")\n\n\t// Then we'll initiate a state transition to lock in this new HTLC.\n\tif err := ForceStateTransition(aliceChannel, bobChannel); err != nil {\n\t\tt.Fatalf(\"unable to complete alice's state transition: %v\", err)\n\t}\n\n\t// At this point, if both sides generate a ChannelReestablish message,\n\t// they should both conclude that they're fully in sync.\n\tassertNoChanSyncNeeded(t, aliceChannel, bobChannel)\n\n\t// If bob settles the HTLC, and then initiates a state transition, they\n\t// should both still think that they're in sync.\n\terr = bobChannel.SettleHTLC(paymentPreimage, bobHtlcIndex, nil, nil, nil)\n\trequire.NoError(t, err, \"unable to settle htlc\")\n\terr = aliceChannel.ReceiveHTLCSettle(paymentPreimage, aliceHtlcIndex)\n\trequire.NoError(t, err, \"unable to settle htlc\")\n\n\t// Next, we'll complete Bob's state transition, and assert again that\n\t// they think they're fully synced.\n\tif err := ForceStateTransition(bobChannel, aliceChannel); err != nil {\n\t\tt.Fatalf(\"unable to complete bob's state transition: %v\", err)\n\t}\n\tassertNoChanSyncNeeded(t, aliceChannel, bobChannel)\n\n\t// Finally, if we simulate a restart on both sides, then both should\n\t// still conclude that they don't need to synchronize their state.\n\talicePub := aliceChannel.channelState.IdentityPub\n\taliceChannels, err := aliceChannel.channelState.Db.FetchOpenChannels(\n\t\talicePub,\n\t)\n\trequire.NoError(t, err, \"unable to fetch channel\")\n\tbobPub := bobChannel.channelState.IdentityPub\n\tbobChannels, err := bobChannel.channelState.Db.FetchOpenChannels(bobPub)\n\trequire.NoError(t, err, \"unable to fetch channel\")\n\n\taliceChannelNew, err := NewLightningChannel(\n\t\taliceChannel.Signer, aliceChannels[0], aliceChannel.sigPool,\n\t)\n\trequire.NoError(t, err, \"unable to create new channel\")\n\tbobChannelNew, err := NewLightningChannel(\n\t\tbobChannel.Signer, bobChannels[0], bobChannel.sigPool,\n\t)\n\trequire.NoError(t, err, \"unable to create new channel\")\n\n\tassertNoChanSyncNeeded(t, aliceChannelNew, bobChannelNew)\n}\n\n// restartChannel reads the passed channel from disk, and returns a newly\n// initialized instance. This simulates one party restarting and losing their\n// in memory state.",
      "length": 3166,
      "tokens": 381,
      "embedding": []
    },
    {
      "slug": "func restartChannel(channelOld *LightningChannel) (*LightningChannel, error) {",
      "content": "func restartChannel(channelOld *LightningChannel) (*LightningChannel, error) {\n\tnodePub := channelOld.channelState.IdentityPub\n\tnodeChannels, err := channelOld.channelState.Db.FetchOpenChannels(\n\t\tnodePub,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tchannelNew, err := NewLightningChannel(\n\t\tchannelOld.Signer, nodeChannels[0],\n\t\tchannelOld.sigPool,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn channelNew, nil\n}\n\n// TestChanSyncOweCommitment tests that if Bob restarts (and then Alice) before\n// he receives Alice's CommitSig message, then Alice concludes that she needs\n// to re-send the CommitDiff. After the diff has been sent, both nodes should\n// resynchronize and be able to complete the dangling commit.",
      "length": 614,
      "tokens": 86,
      "embedding": []
    },
    {
      "slug": "func TestChanSyncOweCommitment(t *testing.T) {",
      "content": "func TestChanSyncOweCommitment(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a test channel which will be used for the duration of this\n\t// unittest. The channel will be funded evenly with Alice having 5 BTC,\n\t// and Bob having 5 BTC.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\tvar fakeOnionBlob [lnwire.OnionPacketSize]byte\n\tcopy(fakeOnionBlob[:], bytes.Repeat([]byte{0x05}, lnwire.OnionPacketSize))\n\n\t// We'll start off the scenario with Bob sending 3 HTLC's to Alice in a\n\t// single state update.\n\thtlcAmt := lnwire.NewMSatFromSatoshis(20000)\n\tconst numBobHtlcs = 3\n\tvar bobPreimage [32]byte\n\tcopy(bobPreimage[:], bytes.Repeat([]byte{0xbb}, 32))\n\tfor i := 0; i < 3; i++ {\n\t\trHash := sha256.Sum256(bobPreimage[:])\n\t\th := &lnwire.UpdateAddHTLC{\n\t\t\tPaymentHash: rHash,\n\t\t\tAmount:      htlcAmt,\n\t\t\tExpiry:      uint32(10),\n\t\t\tOnionBlob:   fakeOnionBlob,\n\t\t\tExtraData:   make([]byte, 0),\n\t\t}\n\n\t\thtlcIndex, err := bobChannel.AddHTLC(h, nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to add bob's htlc: %v\", err)\n\t\t}\n\n\t\th.ID = htlcIndex\n\t\tif _, err := aliceChannel.ReceiveHTLC(h); err != nil {\n\t\t\tt.Fatalf(\"unable to recv bob's htlc: %v\", err)\n\t\t}\n\t}\n\n\tchanID := lnwire.NewChanIDFromOutPoint(\n\t\t&aliceChannel.channelState.FundingOutpoint,\n\t)\n\n\t// With the HTLC's applied to both update logs, we'll initiate a state\n\t// transition from Bob.\n\tif err := ForceStateTransition(bobChannel, aliceChannel); err != nil {\n\t\tt.Fatalf(\"unable to complete bob's state transition: %v\", err)\n\t}\n\n\t// Next, Alice's settles all 3 HTLC's from Bob, and also adds a new\n\t// HTLC of her own.\n\tfor i := 0; i < 3; i++ {\n\t\terr := aliceChannel.SettleHTLC(bobPreimage, uint64(i), nil, nil, nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to settle htlc: %v\", err)\n\t\t}\n\t\terr = bobChannel.ReceiveHTLCSettle(bobPreimage, uint64(i))\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to settle htlc: %v\", err)\n\t\t}\n\t}\n\tvar alicePreimage [32]byte\n\tcopy(alicePreimage[:], bytes.Repeat([]byte{0xaa}, 32))\n\trHash := sha256.Sum256(alicePreimage[:])\n\taliceHtlc := &lnwire.UpdateAddHTLC{\n\t\tChanID:      chanID,\n\t\tPaymentHash: rHash,\n\t\tAmount:      htlcAmt,\n\t\tExpiry:      uint32(10),\n\t\tOnionBlob:   fakeOnionBlob,\n\t\tExtraData:   make([]byte, 0),\n\t}\n\taliceHtlcIndex, err := aliceChannel.AddHTLC(aliceHtlc, nil)\n\trequire.NoError(t, err, \"unable to add alice's htlc\")\n\tbobHtlcIndex, err := bobChannel.ReceiveHTLC(aliceHtlc)\n\trequire.NoError(t, err, \"unable to recv alice's htlc\")\n\n\t// Now we'll begin the core of the test itself. Alice will extend a new\n\t// commitment to Bob, but the connection drops before Bob can process\n\t// it.\n\taliceSig, aliceHtlcSigs, _, err := aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"unable to sign commitment\")\n\n\t// Bob doesn't get this message so upon reconnection, they need to\n\t// synchronize. Alice should conclude that she owes Bob a commitment,\n\t// while Bob should think he's properly synchronized.\n\taliceSyncMsg, err := aliceChannel.channelState.ChanSyncMsg()\n\trequire.NoError(t, err, \"unable to produce chan sync msg\")\n\tbobSyncMsg, err := bobChannel.channelState.ChanSyncMsg()\n\trequire.NoError(t, err, \"unable to produce chan sync msg\")\n\n\t// This is a helper function that asserts Alice concludes that she\n\t// needs to retransmit the exact commitment that we failed to send\n\t// above.\n\tassertAliceCommitRetransmit := func() {\n\t\taliceMsgsToSend, _, _, err := aliceChannel.ProcessChanSyncMsg(\n\t\t\tbobSyncMsg,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to process chan sync msg: %v\", err)\n\t\t}\n\t\tif len(aliceMsgsToSend) != 5 {\n\t\t\tt.Fatalf(\"expected alice to send %v messages instead \"+\n\t\t\t\t\"will send %v: %v\", 5, len(aliceMsgsToSend),\n\t\t\t\tspew.Sdump(aliceMsgsToSend))\n\t\t}\n\n\t\t// Each of the settle messages that Alice sent should match her\n\t\t// original intent.\n\t\tfor i := 0; i < 3; i++ {\n\t\t\tsettleMsg, ok := aliceMsgsToSend[i].(*lnwire.UpdateFulfillHTLC)\n\t\t\tif !ok {\n\t\t\t\tt.Fatalf(\"expected an HTLC settle message, \"+\n\t\t\t\t\t\"instead have %v\", spew.Sdump(settleMsg))\n\t\t\t}\n\t\t\tif settleMsg.ID != uint64(i) {\n\t\t\t\tt.Fatalf(\"wrong ID in settle msg: expected %v, \"+\n\t\t\t\t\t\"got %v\", i, settleMsg.ID)\n\t\t\t}\n\t\t\tif settleMsg.ChanID != chanID {\n\t\t\t\tt.Fatalf(\"incorrect chan id: expected %v, got %v\",\n\t\t\t\t\tchanID, settleMsg.ChanID)\n\t\t\t}\n\t\t\tif settleMsg.PaymentPreimage != bobPreimage {\n\t\t\t\tt.Fatalf(\"wrong pre-image: expected %v, got %v\",\n\t\t\t\t\talicePreimage, settleMsg.PaymentPreimage)\n\t\t\t}\n\t\t}\n\n\t\t// The HTLC add message should be identical.\n\t\tif _, ok := aliceMsgsToSend[3].(*lnwire.UpdateAddHTLC); !ok {\n\t\t\tt.Fatalf(\"expected an HTLC add message, instead have %v\",\n\t\t\t\tspew.Sdump(aliceMsgsToSend[3]))\n\t\t}\n\t\tif !reflect.DeepEqual(aliceHtlc, aliceMsgsToSend[3]) {\n\t\t\tt.Fatalf(\"htlc msg doesn't match exactly: \"+\n\t\t\t\t\"expected %v got %v\", spew.Sdump(aliceHtlc),\n\t\t\t\tspew.Sdump(aliceMsgsToSend[3]))\n\t\t}\n\n\t\t// Next, we'll ensure that the CommitSig message exactly\n\t\t// matches what Alice originally intended to send.\n\t\tcommitSigMsg, ok := aliceMsgsToSend[4].(*lnwire.CommitSig)\n\t\tif !ok {\n\t\t\tt.Fatalf(\"expected a CommitSig message, instead have %v\",\n\t\t\t\tspew.Sdump(aliceMsgsToSend[4]))\n\t\t}\n\t\tif commitSigMsg.CommitSig != aliceSig {\n\t\t\tt.Fatalf(\"commit sig msgs don't match: expected %x got %x\",\n\t\t\t\taliceSig, commitSigMsg.CommitSig)\n\t\t}\n\t\tif len(commitSigMsg.HtlcSigs) != len(aliceHtlcSigs) {\n\t\t\tt.Fatalf(\"wrong number of htlc sigs: expected %v, got %v\",\n\t\t\t\tlen(aliceHtlcSigs), len(commitSigMsg.HtlcSigs))\n\t\t}\n\t\tfor i, htlcSig := range commitSigMsg.HtlcSigs {\n\t\t\tif htlcSig != aliceHtlcSigs[i] {\n\t\t\t\tt.Fatalf(\"htlc sig msgs don't match: \"+\n\t\t\t\t\t\"expected %x got %x\",\n\t\t\t\t\taliceHtlcSigs[i],\n\t\t\t\t\thtlcSig)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Alice should detect that she needs to re-send 5 messages: the 3\n\t// settles, her HTLC add, and finally her commit sig message.\n\tassertAliceCommitRetransmit()\n\n\t// From Bob's Pov he has nothing else to send, so he should conclude he\n\t// has no further action remaining.\n\tbobMsgsToSend, _, _, err := bobChannel.ProcessChanSyncMsg(aliceSyncMsg)\n\trequire.NoError(t, err, \"unable to process chan sync msg\")\n\tif len(bobMsgsToSend) != 0 {\n\t\tt.Fatalf(\"expected bob to send %v messages instead will \"+\n\t\t\t\"send %v: %v\", 5, len(bobMsgsToSend),\n\t\t\tspew.Sdump(bobMsgsToSend))\n\t}\n\n\t// If we restart Alice, she should still conclude that she needs to\n\t// send the exact same set of messages.\n\taliceChannel, err = restartChannel(aliceChannel)\n\trequire.NoError(t, err, \"unable to restart alice\")\n\tassertAliceCommitRetransmit()\n\n\t// TODO(roasbeef): restart bob as well???\n\n\t// At this point, we should be able to resume the prior state update\n\t// without any issues, resulting in Alice settling the 3 htlc's, and\n\t// adding one of her own.\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\trequire.NoError(t, err, \"bob unable to process alice's commitment\")\n\tbobRevocation, _, _, err := bobChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"unable to revoke bob commitment\")\n\tbobSig, bobHtlcSigs, _, err := bobChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"bob unable to sign commitment\")\n\t_, _, _, _, err = aliceChannel.ReceiveRevocation(bobRevocation)\n\trequire.NoError(t, err, \"alice unable to recv revocation\")\n\terr = aliceChannel.ReceiveNewCommitment(bobSig, bobHtlcSigs)\n\trequire.NoError(t, err, \"alice unable to rev bob's commitment\")\n\taliceRevocation, _, _, err := aliceChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"alice unable to revoke commitment\")\n\t_, _, _, _, err = bobChannel.ReceiveRevocation(aliceRevocation)\n\trequire.NoError(t, err, \"bob unable to recv revocation\")\n\n\t// At this point, we'll now assert that their log states are what we\n\t// expect.\n\t//\n\t// Alice's local log counter should be 4 and her HTLC index 3. She\n\t// should detect Bob's remote log counter as being 3 and his HTLC index\n\t// 3 as well.\n\tif aliceChannel.localUpdateLog.logIndex != 4 {\n\t\tt.Fatalf(\"incorrect log index: expected %v, got %v\", 4,\n\t\t\taliceChannel.localUpdateLog.logIndex)\n\t}\n\tif aliceChannel.localUpdateLog.htlcCounter != 1 {\n\t\tt.Fatalf(\"incorrect htlc index: expected %v, got %v\", 1,\n\t\t\taliceChannel.localUpdateLog.htlcCounter)\n\t}\n\tif aliceChannel.remoteUpdateLog.logIndex != 3 {\n\t\tt.Fatalf(\"incorrect log index: expected %v, got %v\", 3,\n\t\t\taliceChannel.localUpdateLog.logIndex)\n\t}\n\tif aliceChannel.remoteUpdateLog.htlcCounter != 3 {\n\t\tt.Fatalf(\"incorrect htlc index: expected %v, got %v\", 3,\n\t\t\taliceChannel.localUpdateLog.htlcCounter)\n\t}\n\n\t// Bob should also have the same state, but mirrored.\n\tif bobChannel.localUpdateLog.logIndex != 3 {\n\t\tt.Fatalf(\"incorrect log index: expected %v, got %v\", 3,\n\t\t\tbobChannel.localUpdateLog.logIndex)\n\t}\n\tif bobChannel.localUpdateLog.htlcCounter != 3 {\n\t\tt.Fatalf(\"incorrect htlc index: expected %v, got %v\", 3,\n\t\t\tbobChannel.localUpdateLog.htlcCounter)\n\t}\n\tif bobChannel.remoteUpdateLog.logIndex != 4 {\n\t\tt.Fatalf(\"incorrect log index: expected %v, got %v\", 4,\n\t\t\tbobChannel.localUpdateLog.logIndex)\n\t}\n\tif bobChannel.remoteUpdateLog.htlcCounter != 1 {\n\t\tt.Fatalf(\"incorrect htlc index: expected %v, got %v\", 1,\n\t\t\tbobChannel.localUpdateLog.htlcCounter)\n\t}\n\n\t// We'll conclude the test by having Bob settle Alice's HTLC, then\n\t// initiate a state transition.\n\terr = bobChannel.SettleHTLC(alicePreimage, bobHtlcIndex, nil, nil, nil)\n\trequire.NoError(t, err, \"unable to settle htlc\")\n\terr = aliceChannel.ReceiveHTLCSettle(alicePreimage, aliceHtlcIndex)\n\trequire.NoError(t, err, \"unable to settle htlc\")\n\tif err := ForceStateTransition(bobChannel, aliceChannel); err != nil {\n\t\tt.Fatalf(\"unable to complete bob's state transition: %v\", err)\n\t}\n\n\t// At this point, the final balances of both parties should properly\n\t// reflect the amount of HTLC's sent.\n\tbobMsatSent := numBobHtlcs * htlcAmt\n\tif aliceChannel.channelState.TotalMSatSent != htlcAmt {\n\t\tt.Fatalf(\"wrong value for msat sent: expected %v, got %v\",\n\t\t\thtlcAmt, aliceChannel.channelState.TotalMSatSent)\n\t}\n\tif aliceChannel.channelState.TotalMSatReceived != bobMsatSent {\n\t\tt.Fatalf(\"wrong value for msat recv: expected %v, got %v\",\n\t\t\tbobMsatSent, aliceChannel.channelState.TotalMSatReceived)\n\t}\n\tif bobChannel.channelState.TotalMSatSent != bobMsatSent {\n\t\tt.Fatalf(\"wrong value for msat sent: expected %v, got %v\",\n\t\t\tbobMsatSent, bobChannel.channelState.TotalMSatSent)\n\t}\n\tif bobChannel.channelState.TotalMSatReceived != htlcAmt {\n\t\tt.Fatalf(\"wrong value for msat recv: expected %v, got %v\",\n\t\t\thtlcAmt, bobChannel.channelState.TotalMSatReceived)\n\t}\n}\n\n// TestChanSyncOweCommitmentPendingRemote asserts that local updates are applied\n// to the remote commit across restarts.",
      "length": 10273,
      "tokens": 1288,
      "embedding": []
    },
    {
      "slug": "func TestChanSyncOweCommitmentPendingRemote(t *testing.T) {",
      "content": "func TestChanSyncOweCommitmentPendingRemote(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a test channel which will be used for the duration of this\n\t// unittest.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\tvar fakeOnionBlob [lnwire.OnionPacketSize]byte\n\tcopy(fakeOnionBlob[:], bytes.Repeat([]byte{0x05}, lnwire.OnionPacketSize))\n\n\t// We'll start off the scenario where Bob send two htlcs to Alice in a\n\t// single state update.\n\tvar preimages []lntypes.Preimage\n\tconst numHtlcs = 2\n\tfor id := byte(0); id < numHtlcs; id++ {\n\t\thtlcAmt := lnwire.NewMSatFromSatoshis(20000)\n\t\tvar bobPreimage [32]byte\n\t\tcopy(bobPreimage[:], bytes.Repeat([]byte{id}, 32))\n\t\trHash := sha256.Sum256(bobPreimage[:])\n\t\th := &lnwire.UpdateAddHTLC{\n\t\t\tPaymentHash: rHash,\n\t\t\tAmount:      htlcAmt,\n\t\t\tExpiry:      uint32(10),\n\t\t\tOnionBlob:   fakeOnionBlob,\n\t\t}\n\n\t\thtlcIndex, err := bobChannel.AddHTLC(h, nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to add bob's htlc: %v\", err)\n\t\t}\n\n\t\th.ID = htlcIndex\n\t\tif _, err := aliceChannel.ReceiveHTLC(h); err != nil {\n\t\t\tt.Fatalf(\"unable to recv bob's htlc: %v\", err)\n\t\t}\n\n\t\tpreimages = append(preimages, bobPreimage)\n\t}\n\n\t// With the HTLCs applied to both update logs, we'll initiate a state\n\t// transition from Bob.\n\tif err := ForceStateTransition(bobChannel, aliceChannel); err != nil {\n\t\tt.Fatalf(\"unable to complete bob's state transition: %v\", err)\n\t}\n\n\t// Next, Alice settles the HTLCs from Bob in distinct state updates.\n\tfor i := 0; i < numHtlcs; i++ {\n\t\terr = aliceChannel.SettleHTLC(preimages[i], uint64(i), nil, nil, nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to settle htlc: %v\", err)\n\t\t}\n\t\terr = bobChannel.ReceiveHTLCSettle(preimages[i], uint64(i))\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to settle htlc: %v\", err)\n\t\t}\n\n\t\taliceSig, aliceHtlcSigs, _, err := aliceChannel.SignNextCommitment()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to sign commitment: %v\", err)\n\t\t}\n\n\t\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to receive commitment: %v\", err)\n\t\t}\n\n\t\t// Bob revokes his current commitment. After this call\n\t\t// completes, the htlc is settled on the local commitment\n\t\t// transaction. Bob still owes Alice a signature to also settle\n\t\t// the htlc on her local commitment transaction.\n\t\tbobRevoke, _, _, err := bobChannel.RevokeCurrentCommitment()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to revoke commitment: %v\", err)\n\t\t}\n\n\t\t_, _, _, _, err = aliceChannel.ReceiveRevocation(bobRevoke)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to revoke commitment: %v\", err)\n\t\t}\n\t}\n\n\t// We restart Bob. This should have no impact on further message that\n\t// are generated.\n\tbobChannel, err = restartChannel(bobChannel)\n\trequire.NoError(t, err, \"unable to restart bob\")\n\n\t// Bob signs the commitment he owes.\n\tbobCommit, bobHtlcSigs, _, err := bobChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"unable to sign commitment\")\n\n\t// This commitment is expected to contain no htlcs anymore.\n\tif len(bobHtlcSigs) != 0 {\n\t\tt.Fatalf(\"no htlcs expected, but got %v\", len(bobHtlcSigs))\n\t}\n\n\t// Get Alice to revoke and trigger Bob to compact his logs.\n\terr = aliceChannel.ReceiveNewCommitment(bobCommit, bobHtlcSigs)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\taliceRevoke, _, _, err := aliceChannel.RevokeCurrentCommitment()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t_, _, _, _, err = bobChannel.ReceiveRevocation(aliceRevoke)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// TestChanSyncOweRevocation tests that if Bob restarts (and then Alice) before\n// he receiver's Alice's RevokeAndAck message, then Alice concludes that she\n// needs to re-send the RevokeAndAck. After the revocation has been sent, both\n// nodes should be able to successfully complete another state transition.",
      "length": 3650,
      "tokens": 506,
      "embedding": []
    },
    {
      "slug": "func TestChanSyncOweRevocation(t *testing.T) {",
      "content": "func TestChanSyncOweRevocation(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a test channel which will be used for the duration of this\n\t// unittest. The channel will be funded evenly with Alice having 5 BTC,\n\t// and Bob having 5 BTC.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\tchanID := lnwire.NewChanIDFromOutPoint(\n\t\t&aliceChannel.channelState.FundingOutpoint,\n\t)\n\n\t// We'll start the test with Bob extending a single HTLC to Alice, and\n\t// then initiating a state transition.\n\thtlcAmt := lnwire.NewMSatFromSatoshis(20000)\n\tvar bobPreimage [32]byte\n\tcopy(bobPreimage[:], bytes.Repeat([]byte{0xaa}, 32))\n\trHash := sha256.Sum256(bobPreimage[:])\n\tbobHtlc := &lnwire.UpdateAddHTLC{\n\t\tChanID:      chanID,\n\t\tPaymentHash: rHash,\n\t\tAmount:      htlcAmt,\n\t\tExpiry:      uint32(10),\n\t}\n\tbobHtlcIndex, err := bobChannel.AddHTLC(bobHtlc, nil)\n\trequire.NoError(t, err, \"unable to add bob's htlc\")\n\taliceHtlcIndex, err := aliceChannel.ReceiveHTLC(bobHtlc)\n\trequire.NoError(t, err, \"unable to recv bob's htlc\")\n\tif err := ForceStateTransition(bobChannel, aliceChannel); err != nil {\n\t\tt.Fatalf(\"unable to complete bob's state transition: %v\", err)\n\t}\n\n\t// Next, Alice will settle that single HTLC, the _begin_ the start of a\n\t// state transition.\n\terr = aliceChannel.SettleHTLC(bobPreimage, aliceHtlcIndex, nil, nil, nil)\n\trequire.NoError(t, err, \"unable to settle htlc\")\n\terr = bobChannel.ReceiveHTLCSettle(bobPreimage, bobHtlcIndex)\n\trequire.NoError(t, err, \"unable to settle htlc\")\n\n\t// We'll model the state transition right up until Alice needs to send\n\t// her revocation message to complete the state transition.\n\t//\n\t// Alice signs the next state, then Bob receives and sends his\n\t// revocation message.\n\taliceSig, aliceHtlcSigs, _, err := aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"unable to sign commitment\")\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\trequire.NoError(t, err, \"bob unable to process alice's commitment\")\n\n\tbobRevocation, _, _, err := bobChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"unable to revoke bob commitment\")\n\tbobSig, bobHtlcSigs, _, err := bobChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"bob unable to sign commitment\")\n\n\t_, _, _, _, err = aliceChannel.ReceiveRevocation(bobRevocation)\n\trequire.NoError(t, err, \"alice unable to recv revocation\")\n\terr = aliceChannel.ReceiveNewCommitment(bobSig, bobHtlcSigs)\n\trequire.NoError(t, err, \"alice unable to rev bob's commitment\")\n\n\t// At this point, we'll simulate the connection breaking down by Bob's\n\t// lack of knowledge of the revocation message that Alice just sent.\n\taliceRevocation, _, _, err := aliceChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"alice unable to revoke commitment\")\n\n\t// If we fetch the channel sync messages at this state, then Alice\n\t// should report that she owes Bob a revocation message, while Bob\n\t// thinks they're fully in sync.\n\taliceSyncMsg, err := aliceChannel.channelState.ChanSyncMsg()\n\trequire.NoError(t, err, \"unable to produce chan sync msg\")\n\tbobSyncMsg, err := bobChannel.channelState.ChanSyncMsg()\n\trequire.NoError(t, err, \"unable to produce chan sync msg\")\n\n\tassertAliceOwesRevoke := func() {\n\t\taliceMsgsToSend, _, _, err := aliceChannel.ProcessChanSyncMsg(bobSyncMsg)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to process chan sync msg: %v\", err)\n\t\t}\n\t\tif len(aliceMsgsToSend) != 1 {\n\t\t\tt.Fatalf(\"expected single message retransmission from Alice, \"+\n\t\t\t\t\"instead got %v\", spew.Sdump(aliceMsgsToSend))\n\t\t}\n\t\taliceReRevoke, ok := aliceMsgsToSend[0].(*lnwire.RevokeAndAck)\n\t\tif !ok {\n\t\t\tt.Fatalf(\"expected to retransmit revocation msg, instead \"+\n\t\t\t\t\"have: %v\", spew.Sdump(aliceMsgsToSend[0]))\n\t\t}\n\n\t\t// Alice should re-send the revocation message for her prior\n\t\t// state.\n\t\texpectedRevocation, err := aliceChannel.generateRevocation(\n\t\t\taliceChannel.currentHeight - 1,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to regenerate revocation: %v\", err)\n\t\t}\n\t\tif !reflect.DeepEqual(expectedRevocation, aliceReRevoke) {\n\t\t\tt.Fatalf(\"wrong re-revocation: expected %v, got %v\",\n\t\t\t\texpectedRevocation, aliceReRevoke)\n\t\t}\n\t}\n\n\t// From Bob's PoV he shouldn't think that he owes Alice any messages.\n\tbobMsgsToSend, _, _, err := bobChannel.ProcessChanSyncMsg(aliceSyncMsg)\n\trequire.NoError(t, err, \"unable to process chan sync msg\")\n\tif len(bobMsgsToSend) != 0 {\n\t\tt.Fatalf(\"expected bob to not retransmit, instead has: %v\",\n\t\t\tspew.Sdump(bobMsgsToSend))\n\t}\n\n\t// Alice should detect that she owes Bob a revocation message, and only\n\t// that single message.\n\tassertAliceOwesRevoke()\n\n\t// If we restart Alice, then she should still decide that she owes a\n\t// revocation message to Bob.\n\taliceChannel, err = restartChannel(aliceChannel)\n\trequire.NoError(t, err, \"unable to restart alice\")\n\tassertAliceOwesRevoke()\n\n\t// TODO(roasbeef): restart bob too???\n\n\t// We'll continue by then allowing bob to process Alice's revocation message.\n\t_, _, _, _, err = bobChannel.ReceiveRevocation(aliceRevocation)\n\trequire.NoError(t, err, \"bob unable to recv revocation\")\n\n\t// Finally, Alice will add an HTLC over her own such that we assert the\n\t// channel can continue to receive updates.\n\tvar alicePreimage [32]byte\n\tcopy(bobPreimage[:], bytes.Repeat([]byte{0xaa}, 32))\n\trHash = sha256.Sum256(alicePreimage[:])\n\taliceHtlc := &lnwire.UpdateAddHTLC{\n\t\tChanID:      chanID,\n\t\tPaymentHash: rHash,\n\t\tAmount:      htlcAmt,\n\t\tExpiry:      uint32(10),\n\t}\n\tif _, err := aliceChannel.AddHTLC(aliceHtlc, nil); err != nil {\n\t\tt.Fatalf(\"unable to add alice's htlc: %v\", err)\n\t}\n\tif _, err := bobChannel.ReceiveHTLC(aliceHtlc); err != nil {\n\t\tt.Fatalf(\"unable to recv alice's htlc: %v\", err)\n\t}\n\tif err := ForceStateTransition(aliceChannel, bobChannel); err != nil {\n\t\tt.Fatalf(\"unable to complete alice's state transition: %v\", err)\n\t}\n\n\t// At this point, both sides should detect that they're fully synced.\n\tassertNoChanSyncNeeded(t, aliceChannel, bobChannel)\n}\n\n// TestChanSyncOweRevocationAndCommit tests that if Alice initiates a state\n// transition with Bob and Bob sends both a RevokeAndAck and CommitSig message\n// but Alice doesn't receive them before the connection dies, then he'll\n// retransmit them both.",
      "length": 6069,
      "tokens": 761,
      "embedding": []
    },
    {
      "slug": "func TestChanSyncOweRevocationAndCommit(t *testing.T) {",
      "content": "func TestChanSyncOweRevocationAndCommit(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a test channel which will be used for the duration of this\n\t// unittest. The channel will be funded evenly with Alice having 5 BTC,\n\t// and Bob having 5 BTC.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\thtlcAmt := lnwire.NewMSatFromSatoshis(20000)\n\n\t// We'll kick off the test by having Bob send Alice an HTLC, then lock\n\t// it in with a state transition.\n\tvar bobPreimage [32]byte\n\tcopy(bobPreimage[:], bytes.Repeat([]byte{0xaa}, 32))\n\trHash := sha256.Sum256(bobPreimage[:])\n\tbobHtlc := &lnwire.UpdateAddHTLC{\n\t\tPaymentHash: rHash,\n\t\tAmount:      htlcAmt,\n\t\tExpiry:      uint32(10),\n\t}\n\tbobHtlcIndex, err := bobChannel.AddHTLC(bobHtlc, nil)\n\trequire.NoError(t, err, \"unable to add bob's htlc\")\n\taliceHtlcIndex, err := aliceChannel.ReceiveHTLC(bobHtlc)\n\trequire.NoError(t, err, \"unable to recv bob's htlc\")\n\tif err := ForceStateTransition(bobChannel, aliceChannel); err != nil {\n\t\tt.Fatalf(\"unable to complete bob's state transition: %v\", err)\n\t}\n\n\t// Next, Alice will settle that incoming HTLC, then we'll start the\n\t// core of the test itself.\n\terr = aliceChannel.SettleHTLC(bobPreimage, aliceHtlcIndex, nil, nil, nil)\n\trequire.NoError(t, err, \"unable to settle htlc\")\n\terr = bobChannel.ReceiveHTLCSettle(bobPreimage, bobHtlcIndex)\n\trequire.NoError(t, err, \"unable to settle htlc\")\n\n\t// Progressing the exchange: Alice will send her signature, Bob will\n\t// receive, send a revocation and also a signature for Alice's state.\n\taliceSig, aliceHtlcSigs, _, err := aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"unable to sign commitment\")\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\trequire.NoError(t, err, \"bob unable to process alice's commitment\")\n\n\t// Bob generates the revoke and sig message, but the messages don't\n\t// reach Alice before the connection dies.\n\tbobRevocation, _, _, err := bobChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"unable to revoke bob commitment\")\n\tbobSig, bobHtlcSigs, _, err := bobChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"bob unable to sign commitment\")\n\n\t// If we now attempt to resync, then Alice should conclude that she\n\t// doesn't need any further updates, while Bob concludes that he needs\n\t// to re-send both his revocation and commit sig message.\n\taliceSyncMsg, err := aliceChannel.channelState.ChanSyncMsg()\n\trequire.NoError(t, err, \"unable to produce chan sync msg\")\n\tbobSyncMsg, err := bobChannel.channelState.ChanSyncMsg()\n\trequire.NoError(t, err, \"unable to produce chan sync msg\")\n\n\taliceMsgsToSend, _, _, err := aliceChannel.ProcessChanSyncMsg(bobSyncMsg)\n\trequire.NoError(t, err, \"unable to process chan sync msg\")\n\tif len(aliceMsgsToSend) != 0 {\n\t\tt.Fatalf(\"expected alice to not retransmit, instead she's \"+\n\t\t\t\"sending: %v\", spew.Sdump(aliceMsgsToSend))\n\t}\n\n\tassertBobSendsRevokeAndCommit := func() {\n\t\tbobMsgsToSend, _, _, err := bobChannel.ProcessChanSyncMsg(aliceSyncMsg)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to process chan sync msg: %v\", err)\n\t\t}\n\t\tif len(bobMsgsToSend) != 2 {\n\t\t\tt.Fatalf(\"expected bob to send %v messages, instead \"+\n\t\t\t\t\"sends: %v\", 2, spew.Sdump(bobMsgsToSend))\n\t\t}\n\t\tbobReRevoke, ok := bobMsgsToSend[0].(*lnwire.RevokeAndAck)\n\t\tif !ok {\n\t\t\tt.Fatalf(\"expected bob to re-send revoke, instead sending: %v\",\n\t\t\t\tspew.Sdump(bobMsgsToSend[0]))\n\t\t}\n\t\tif !reflect.DeepEqual(bobReRevoke, bobRevocation) {\n\t\t\tt.Fatalf(\"revocation msgs don't match: expected %v, got %v\",\n\t\t\t\tbobRevocation, bobReRevoke)\n\t\t}\n\n\t\tbobReCommitSigMsg, ok := bobMsgsToSend[1].(*lnwire.CommitSig)\n\t\tif !ok {\n\t\t\tt.Fatalf(\"expected bob to re-send commit sig, instead sending: %v\",\n\t\t\t\tspew.Sdump(bobMsgsToSend[1]))\n\t\t}\n\t\tif bobReCommitSigMsg.CommitSig != bobSig {\n\t\t\tt.Fatalf(\"commit sig msgs don't match: expected %x got %x\",\n\t\t\t\tbobSig, bobReCommitSigMsg.CommitSig)\n\t\t}\n\t\tif len(bobReCommitSigMsg.HtlcSigs) != len(bobHtlcSigs) {\n\t\t\tt.Fatalf(\"wrong number of htlc sigs: expected %v, got %v\",\n\t\t\t\tlen(bobHtlcSigs), len(bobReCommitSigMsg.HtlcSigs))\n\t\t}\n\t\tfor i, htlcSig := range bobReCommitSigMsg.HtlcSigs {\n\t\t\tif htlcSig != aliceHtlcSigs[i] {\n\t\t\t\tt.Fatalf(\"htlc sig msgs don't match: \"+\n\t\t\t\t\t\"expected %x got %x\",\n\t\t\t\t\tbobHtlcSigs[i], htlcSig)\n\t\t\t}\n\t\t}\n\t}\n\n\t// We expect Bob to send exactly two messages: first his revocation\n\t// message to Alice, and second his original commit sig message.\n\tassertBobSendsRevokeAndCommit()\n\n\t// At this point we simulate the connection failing with a restart from\n\t// Bob. He should still re-send the exact same set of messages.\n\tbobChannel, err = restartChannel(bobChannel)\n\trequire.NoError(t, err, \"unable to restart channel\")\n\tassertBobSendsRevokeAndCommit()\n\n\t// We'll now finish the state transition by having Alice process both\n\t// messages, and send her final revocation.\n\t_, _, _, _, err = aliceChannel.ReceiveRevocation(bobRevocation)\n\trequire.NoError(t, err, \"alice unable to recv revocation\")\n\terr = aliceChannel.ReceiveNewCommitment(bobSig, bobHtlcSigs)\n\trequire.NoError(t, err, \"alice unable to rev bob's commitment\")\n\taliceRevocation, _, _, err := aliceChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"alice unable to revoke commitment\")\n\t_, _, _, _, err = bobChannel.ReceiveRevocation(aliceRevocation)\n\trequire.NoError(t, err, \"bob unable to recv revocation\")\n}\n\n// TestChanSyncOweRevocationAndCommitForceTransition tests that if Alice\n// initiates a state transition with Bob, but Alice fails to receive his\n// RevokeAndAck and the connection dies before Bob sends his CommitSig message,\n// then Bob will re-send her RevokeAndAck message. Bob will also send and\n// _identical_ CommitSig as he detects his commitment chain is ahead of\n// Alice's.",
      "length": 5613,
      "tokens": 701,
      "embedding": []
    },
    {
      "slug": "func TestChanSyncOweRevocationAndCommitForceTransition(t *testing.T) {",
      "content": "func TestChanSyncOweRevocationAndCommitForceTransition(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a test channel which will be used for the duration of this\n\t// unittest. The channel will be funded evenly with Alice having 5 BTC,\n\t// and Bob having 5 BTC.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\thtlcAmt := lnwire.NewMSatFromSatoshis(20000)\n\n\t// We'll kick off the test by having Bob send Alice an HTLC, then lock\n\t// it in with a state transition.\n\tvar bobPreimage [32]byte\n\tcopy(bobPreimage[:], bytes.Repeat([]byte{0xaa}, 32))\n\trHash := sha256.Sum256(bobPreimage[:])\n\tvar bobHtlc [2]*lnwire.UpdateAddHTLC\n\tbobHtlc[0] = &lnwire.UpdateAddHTLC{\n\t\tPaymentHash: rHash,\n\t\tAmount:      htlcAmt,\n\t\tExpiry:      uint32(10),\n\t}\n\tbobHtlcIndex, err := bobChannel.AddHTLC(bobHtlc[0], nil)\n\trequire.NoError(t, err, \"unable to add bob's htlc\")\n\taliceHtlcIndex, err := aliceChannel.ReceiveHTLC(bobHtlc[0])\n\trequire.NoError(t, err, \"unable to recv bob's htlc\")\n\tif err := ForceStateTransition(bobChannel, aliceChannel); err != nil {\n\t\tt.Fatalf(\"unable to complete bob's state transition: %v\", err)\n\t}\n\n\t// To ensure the channel sync logic handles the case where the two\n\t// commit chains are at different heights, we'll add another HTLC from\n\t// Bob to Alice, but let Alice skip the commitment for this state\n\t// update.\n\trHash = sha256.Sum256(bytes.Repeat([]byte{0xbb}, 32))\n\tbobHtlc[1] = &lnwire.UpdateAddHTLC{\n\t\tPaymentHash: rHash,\n\t\tAmount:      htlcAmt,\n\t\tExpiry:      uint32(10),\n\t\tID:          1,\n\t}\n\t_, err = bobChannel.AddHTLC(bobHtlc[1], nil)\n\trequire.NoError(t, err, \"unable to add bob's htlc\")\n\t_, err = aliceChannel.ReceiveHTLC(bobHtlc[1])\n\trequire.NoError(t, err, \"unable to recv bob's htlc\")\n\n\t// Bob signs the new state update, and sends the signature to Alice.\n\tbobSig, bobHtlcSigs, _, err := bobChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"bob unable to sign commitment\")\n\n\terr = aliceChannel.ReceiveNewCommitment(bobSig, bobHtlcSigs)\n\trequire.NoError(t, err, \"alice unable to rev bob's commitment\")\n\n\t// Alice revokes her current state, but doesn't immediately send a\n\t// signature for Bob's updated state. Instead she will issue a new\n\t// update before sending a new CommitSig. This will lead to Alice's\n\t// local commit chain getting height > remote commit chain.\n\taliceRevocation, _, _, err := aliceChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"alice unable to revoke commitment\")\n\t_, _, _, _, err = bobChannel.ReceiveRevocation(aliceRevocation)\n\trequire.NoError(t, err, \"bob unable to recv revocation\")\n\n\t// Next, Alice will settle that incoming HTLC, then we'll start the\n\t// core of the test itself.\n\terr = aliceChannel.SettleHTLC(bobPreimage, aliceHtlcIndex, nil, nil, nil)\n\trequire.NoError(t, err, \"unable to settle htlc\")\n\terr = bobChannel.ReceiveHTLCSettle(bobPreimage, bobHtlcIndex)\n\trequire.NoError(t, err, \"unable to settle htlc\")\n\n\t// Progressing the exchange: Alice will send her signature, with Bob\n\t// processing the new state locally.\n\taliceSig, aliceHtlcSigs, _, err := aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"unable to sign commitment\")\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\trequire.NoError(t, err, \"bob unable to process alice's commitment\")\n\n\t// Bob then sends his revocation message, but before Alice can process\n\t// it (and before he scan send his CommitSig message), then connection\n\t// dies.\n\tbobRevocation, _, _, err := bobChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"unable to revoke bob commitment\")\n\n\t// Now if we attempt to synchronize states at this point, Alice should\n\t// detect that she owes nothing, while Bob should re-send both his\n\t// RevokeAndAck as well as his commitment message.\n\taliceSyncMsg, err := aliceChannel.channelState.ChanSyncMsg()\n\trequire.NoError(t, err, \"unable to produce chan sync msg\")\n\tbobSyncMsg, err := bobChannel.channelState.ChanSyncMsg()\n\trequire.NoError(t, err, \"unable to produce chan sync msg\")\n\n\taliceMsgsToSend, _, _, err := aliceChannel.ProcessChanSyncMsg(bobSyncMsg)\n\trequire.NoError(t, err, \"unable to process chan sync msg\")\n\tif len(aliceMsgsToSend) != 0 {\n\t\tt.Fatalf(\"expected alice to not retransmit, instead she's \"+\n\t\t\t\"sending: %v\", spew.Sdump(aliceMsgsToSend))\n\t}\n\n\t// If we process Alice's sync message from Bob's PoV, then he should\n\t// send his RevokeAndAck message again. Additionally, the CommitSig\n\t// message that he sends should be sufficient to finalize the state\n\t// transition.\n\tbobMsgsToSend, _, _, err := bobChannel.ProcessChanSyncMsg(aliceSyncMsg)\n\trequire.NoError(t, err, \"unable to process chan sync msg\")\n\tif len(bobMsgsToSend) != 2 {\n\t\tt.Fatalf(\"expected bob to send %v messages, instead \"+\n\t\t\t\"sends: %v\", 2, spew.Sdump(bobMsgsToSend))\n\t}\n\tbobReRevoke, ok := bobMsgsToSend[0].(*lnwire.RevokeAndAck)\n\tif !ok {\n\t\tt.Fatalf(\"expected bob to re-send revoke, instead sending: %v\",\n\t\t\tspew.Sdump(bobMsgsToSend[0]))\n\t}\n\tif !reflect.DeepEqual(bobReRevoke, bobRevocation) {\n\t\tt.Fatalf(\"revocation msgs don't match: expected %v, got %v\",\n\t\t\tbobRevocation, bobReRevoke)\n\t}\n\n\t// The second message should be his CommitSig message that he never\n\t// sent, but will send in order to force both states to synchronize.\n\tbobReCommitSigMsg, ok := bobMsgsToSend[1].(*lnwire.CommitSig)\n\tif !ok {\n\t\tt.Fatalf(\"expected bob to re-send commit sig, instead sending: %v\",\n\t\t\tspew.Sdump(bobMsgsToSend[1]))\n\t}\n\n\t// At this point we simulate the connection failing with a restart from\n\t// Bob. He should still re-send the exact same set of messages.\n\tbobChannel, err = restartChannel(bobChannel)\n\trequire.NoError(t, err, \"unable to restart channel\")\n\tif len(bobMsgsToSend) != 2 {\n\t\tt.Fatalf(\"expected bob to send %v messages, instead \"+\n\t\t\t\"sends: %v\", 2, spew.Sdump(bobMsgsToSend))\n\t}\n\tbobReRevoke, ok = bobMsgsToSend[0].(*lnwire.RevokeAndAck)\n\tif !ok {\n\t\tt.Fatalf(\"expected bob to re-send revoke, instead sending: %v\",\n\t\t\tspew.Sdump(bobMsgsToSend[0]))\n\t}\n\tbobSigMsg, ok := bobMsgsToSend[1].(*lnwire.CommitSig)\n\tif !ok {\n\t\tt.Fatalf(\"expected bob to re-send commit sig, instead sending: %v\",\n\t\t\tspew.Sdump(bobMsgsToSend[1]))\n\t}\n\tif !reflect.DeepEqual(bobReRevoke, bobRevocation) {\n\t\tt.Fatalf(\"revocation msgs don't match: expected %v, got %v\",\n\t\t\tbobRevocation, bobReRevoke)\n\t}\n\tif bobReCommitSigMsg.CommitSig != bobSigMsg.CommitSig {\n\t\tt.Fatalf(\"commit sig msgs don't match: expected %x got %x\",\n\t\t\tbobSigMsg.CommitSig,\n\t\t\tbobReCommitSigMsg.CommitSig)\n\t}\n\tif len(bobReCommitSigMsg.HtlcSigs) != len(bobSigMsg.HtlcSigs) {\n\t\tt.Fatalf(\"wrong number of htlc sigs: expected %v, got %v\",\n\t\t\tlen(bobSigMsg.HtlcSigs), len(bobReCommitSigMsg.HtlcSigs))\n\t}\n\tfor i, htlcSig := range bobReCommitSigMsg.HtlcSigs {\n\t\tif htlcSig != bobSigMsg.HtlcSigs[i] {\n\t\t\tt.Fatalf(\"htlc sig msgs don't match: \"+\n\t\t\t\t\"expected %x got %x\",\n\t\t\t\tbobSigMsg.HtlcSigs[i], htlcSig)\n\t\t}\n\t}\n\n\t// Now, we'll continue the exchange, sending Bob's revocation and\n\t// signature message to Alice, ending with Alice sending her revocation\n\t// message to Bob.\n\t_, _, _, _, err = aliceChannel.ReceiveRevocation(bobRevocation)\n\trequire.NoError(t, err, \"alice unable to recv revocation\")\n\terr = aliceChannel.ReceiveNewCommitment(\n\t\tbobSigMsg.CommitSig, bobSigMsg.HtlcSigs,\n\t)\n\trequire.NoError(t, err, \"alice unable to rev bob's commitment\")\n\taliceRevocation, _, _, err = aliceChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"alice unable to revoke commitment\")\n\t_, _, _, _, err = bobChannel.ReceiveRevocation(aliceRevocation)\n\trequire.NoError(t, err, \"bob unable to recv revocation\")\n}\n\n// TestChanSyncFailure tests the various scenarios during channel sync where we\n// should be able to detect that the channels cannot be synced because of\n// invalid state.",
      "length": 7541,
      "tokens": 950,
      "embedding": []
    },
    {
      "slug": "func TestChanSyncFailure(t *testing.T) {",
      "content": "func TestChanSyncFailure(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a test channel which will be used for the duration of this\n\t// unittest. The channel will be funded evenly with Alice having 5 BTC,\n\t// and Bob having 5 BTC.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\thtlcAmt := lnwire.NewMSatFromSatoshis(20000)\n\tindex := byte(0)\n\n\t// advanceState is a helper method to fully advance the channel state\n\t// by one.\n\tadvanceState := func() {\n\t\tt.Helper()\n\n\t\t// We'll kick off the test by having Bob send Alice an HTLC,\n\t\t// then lock it in with a state transition.\n\t\tvar bobPreimage [32]byte\n\t\tcopy(bobPreimage[:], bytes.Repeat([]byte{0xaa - index}, 32))\n\t\trHash := sha256.Sum256(bobPreimage[:])\n\t\tbobHtlc := &lnwire.UpdateAddHTLC{\n\t\t\tPaymentHash: rHash,\n\t\t\tAmount:      htlcAmt,\n\t\t\tExpiry:      uint32(10),\n\t\t\tID:          uint64(index),\n\t\t}\n\t\tindex++\n\n\t\t_, err := bobChannel.AddHTLC(bobHtlc, nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to add bob's htlc: %v\", err)\n\t\t}\n\t\t_, err = aliceChannel.ReceiveHTLC(bobHtlc)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to recv bob's htlc: %v\", err)\n\t\t}\n\t\terr = ForceStateTransition(bobChannel, aliceChannel)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to complete bob's state \"+\n\t\t\t\t\"transition: %v\", err)\n\t\t}\n\t}\n\n\t// halfAdvance is a helper method that sends a new commitment signature\n\t// from Alice to Bob, but doesn't make Bob revoke his current state.\n\thalfAdvance := func() {\n\t\tt.Helper()\n\n\t\t// We'll kick off the test by having Bob send Alice an HTLC,\n\t\t// then lock it in with a state transition.\n\t\tvar bobPreimage [32]byte\n\t\tcopy(bobPreimage[:], bytes.Repeat([]byte{0xaa - index}, 32))\n\t\trHash := sha256.Sum256(bobPreimage[:])\n\t\tbobHtlc := &lnwire.UpdateAddHTLC{\n\t\t\tPaymentHash: rHash,\n\t\t\tAmount:      htlcAmt,\n\t\t\tExpiry:      uint32(10),\n\t\t\tID:          uint64(index),\n\t\t}\n\t\tindex++\n\n\t\t_, err := bobChannel.AddHTLC(bobHtlc, nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to add bob's htlc: %v\", err)\n\t\t}\n\t\t_, err = aliceChannel.ReceiveHTLC(bobHtlc)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to recv bob's htlc: %v\", err)\n\t\t}\n\n\t\taliceSig, aliceHtlcSigs, _, err := aliceChannel.SignNextCommitment()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to sign next commit: %v\", err)\n\t\t}\n\t\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to receive commit sig: %v\", err)\n\t\t}\n\t}\n\n\t// assertLocalDataLoss checks that aliceOld and bobChannel detects that\n\t// Alice has lost state during sync.\n\tassertLocalDataLoss := func(aliceOld *LightningChannel) {\n\t\tt.Helper()\n\n\t\taliceSyncMsg, err := aliceOld.channelState.ChanSyncMsg()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to produce chan sync msg: %v\", err)\n\t\t}\n\t\tbobSyncMsg, err := bobChannel.channelState.ChanSyncMsg()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to produce chan sync msg: %v\", err)\n\t\t}\n\n\t\t// Alice should detect from Bob's message that she lost state.\n\t\t_, _, _, err = aliceOld.ProcessChanSyncMsg(bobSyncMsg)\n\t\tif _, ok := err.(*ErrCommitSyncLocalDataLoss); !ok {\n\t\t\tt.Fatalf(\"wrong error, expected \"+\n\t\t\t\t\"ErrCommitSyncLocalDataLoss instead got: %v\",\n\t\t\t\terr)\n\t\t}\n\n\t\t// Bob should detect that Alice probably lost state.\n\t\t_, _, _, err = bobChannel.ProcessChanSyncMsg(aliceSyncMsg)\n\t\tif err != ErrCommitSyncRemoteDataLoss {\n\t\t\tt.Fatalf(\"wrong error, expected \"+\n\t\t\t\t\"ErrCommitSyncRemoteDataLoss instead got: %v\",\n\t\t\t\terr)\n\t\t}\n\t}\n\n\t// clearBorkedState is a method that allows us to clear the borked\n\t// state that will arise after the first chan message sync. We need to\n\t// do this in order to be able to continue to update the commitment\n\t// state for our test scenarios.\n\tclearBorkedState := func() {\n\t\terr = aliceChannel.channelState.ClearChanStatus(\n\t\t\tchanneldb.ChanStatusLocalDataLoss | channeldb.ChanStatusBorked,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to update channel state: %v\", err)\n\t\t}\n\t\terr = bobChannel.channelState.ClearChanStatus(\n\t\t\tchanneldb.ChanStatusLocalDataLoss | channeldb.ChanStatusBorked,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to update channel state: %v\", err)\n\t\t}\n\t}\n\n\t// Start by advancing the state.\n\tadvanceState()\n\n\t// They should be in sync.\n\tassertNoChanSyncNeeded(t, aliceChannel, bobChannel)\n\n\t// Make a copy of Alice's state from the database at this point.\n\taliceOld, err := restartChannel(aliceChannel)\n\trequire.NoError(t, err, \"unable to restart channel\")\n\n\t// Advance the states.\n\tadvanceState()\n\n\t// Trying to sync up the old version of Alice's channel should detect\n\t// that we are out of sync.\n\tassertLocalDataLoss(aliceOld)\n\n\t// Make sure the up-to-date channels still are in sync.\n\tassertNoChanSyncNeeded(t, aliceChannel, bobChannel)\n\n\t// Clear the borked state before we attempt to advance.\n\tclearBorkedState()\n\n\t// Advance the state again, and do the same check.\n\tadvanceState()\n\tassertNoChanSyncNeeded(t, aliceChannel, bobChannel)\n\tassertLocalDataLoss(aliceOld)\n\n\t// If we remove the recovery options from Bob's message, Alice cannot\n\t// tell if she lost state, since Bob might be lying. She still should\n\t// be able to detect that chains cannot be synced.\n\tbobSyncMsg, err := bobChannel.channelState.ChanSyncMsg()\n\trequire.NoError(t, err, \"unable to produce chan sync msg\")\n\tbobSyncMsg.LocalUnrevokedCommitPoint = nil\n\t_, _, _, err = aliceOld.ProcessChanSyncMsg(bobSyncMsg)\n\tif err != ErrCannotSyncCommitChains {\n\t\tt.Fatalf(\"wrong error, expected ErrCannotSyncCommitChains \"+\n\t\t\t\"instead got: %v\", err)\n\t}\n\n\t// If Bob lies about the NextLocalCommitHeight, making it greater than\n\t// what Alice expect, she cannot tell for sure whether she lost state,\n\t// but should detect the desync.\n\tbobSyncMsg, err = bobChannel.channelState.ChanSyncMsg()\n\trequire.NoError(t, err, \"unable to produce chan sync msg\")\n\tbobSyncMsg.NextLocalCommitHeight++\n\t_, _, _, err = aliceChannel.ProcessChanSyncMsg(bobSyncMsg)\n\tif err != ErrCannotSyncCommitChains {\n\t\tt.Fatalf(\"wrong error, expected ErrCannotSyncCommitChains \"+\n\t\t\t\"instead got: %v\", err)\n\t}\n\n\t// If Bob's NextLocalCommitHeight is lower than what Alice expects, Bob\n\t// probably lost state.\n\tbobSyncMsg, err = bobChannel.channelState.ChanSyncMsg()\n\trequire.NoError(t, err, \"unable to produce chan sync msg\")\n\tbobSyncMsg.NextLocalCommitHeight--\n\t_, _, _, err = aliceChannel.ProcessChanSyncMsg(bobSyncMsg)\n\tif err != ErrCommitSyncRemoteDataLoss {\n\t\tt.Fatalf(\"wrong error, expected ErrCommitSyncRemoteDataLoss \"+\n\t\t\t\"instead got: %v\", err)\n\t}\n\n\t// If Alice and Bob's states are in sync, but Bob is sending the wrong\n\t// LocalUnrevokedCommitPoint, Alice should detect this.\n\tbobSyncMsg, err = bobChannel.channelState.ChanSyncMsg()\n\trequire.NoError(t, err, \"unable to produce chan sync msg\")\n\tp := bobSyncMsg.LocalUnrevokedCommitPoint.SerializeCompressed()\n\tp[4] ^= 0x01\n\tmodCommitPoint, err := btcec.ParsePubKey(p)\n\trequire.NoError(t, err, \"unable to parse pubkey\")\n\n\tbobSyncMsg.LocalUnrevokedCommitPoint = modCommitPoint\n\t_, _, _, err = aliceChannel.ProcessChanSyncMsg(bobSyncMsg)\n\tif err != ErrInvalidLocalUnrevokedCommitPoint {\n\t\tt.Fatalf(\"wrong error, expected \"+\n\t\t\t\"ErrInvalidLocalUnrevokedCommitPoint instead got: %v\",\n\t\t\terr)\n\t}\n\n\t// Make sure the up-to-date channels still are good.\n\tassertNoChanSyncNeeded(t, aliceChannel, bobChannel)\n\n\t// Clear the borked state before we attempt to advance.\n\tclearBorkedState()\n\n\t// Finally check that Alice is also able to detect a wrong commit point\n\t// when there's a pending remote commit.\n\thalfAdvance()\n\n\tbobSyncMsg, err = bobChannel.channelState.ChanSyncMsg()\n\trequire.NoError(t, err, \"unable to produce chan sync msg\")\n\tbobSyncMsg.LocalUnrevokedCommitPoint = modCommitPoint\n\t_, _, _, err = aliceChannel.ProcessChanSyncMsg(bobSyncMsg)\n\tif err != ErrInvalidLocalUnrevokedCommitPoint {\n\t\tt.Fatalf(\"wrong error, expected \"+\n\t\t\t\"ErrInvalidLocalUnrevokedCommitPoint instead got: %v\",\n\t\t\terr)\n\t}\n}\n\n// TestFeeUpdateRejectInsaneFee tests that if the initiator tries to attach a\n// fee that would put them below their current reserve, then it's rejected by\n// the state machine.",
      "length": 7758,
      "tokens": 1011,
      "embedding": []
    },
    {
      "slug": "func TestFeeUpdateRejectInsaneFee(t *testing.T) {",
      "content": "func TestFeeUpdateRejectInsaneFee(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a test channel which will be used for the duration of this\n\t// unittest. The channel will be funded evenly with Alice having 5 BTC,\n\t// and Bob having 5 BTC.\n\taliceChannel, _, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// Next, we'll try to add a fee rate to Alice which is 1,000,000x her\n\t// starting fee rate.\n\tstartingFeeRate := chainfee.SatPerKWeight(\n\t\taliceChannel.channelState.LocalCommitment.FeePerKw,\n\t)\n\tnewFeeRate := startingFeeRate * 1000000\n\n\t// Both Alice and Bob should reject this new fee rate as it is far too\n\t// large.\n\tif err := aliceChannel.UpdateFee(newFeeRate); err == nil {\n\t\tt.Fatalf(\"alice should have rejected fee update\")\n\t}\n}\n\n// TestChannelRetransmissionFeeUpdate tests that the initiator will include any\n// pending fee updates if it needs to retransmit signatures.",
      "length": 886,
      "tokens": 131,
      "embedding": []
    },
    {
      "slug": "func TestChannelRetransmissionFeeUpdate(t *testing.T) {",
      "content": "func TestChannelRetransmissionFeeUpdate(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a test channel which will be used for the duration of this\n\t// unittest. The channel will be funded evenly with Alice having 5 BTC,\n\t// and Bob having 5 BTC.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// First, we'll fetch the current fee rate present within the\n\t// commitment transactions.\n\tstartingFeeRate := chainfee.SatPerKWeight(\n\t\taliceChannel.channelState.LocalCommitment.FeePerKw,\n\t)\n\n\t// Next, we'll start a commitment update, with Alice sending a new\n\t// update to double the fee rate of the commitment.\n\tnewFeeRate := startingFeeRate * 2\n\tif err := aliceChannel.UpdateFee(newFeeRate); err != nil {\n\t\tt.Fatalf(\"unable to update fee for Alice's channel: %v\", err)\n\t}\n\tif err := bobChannel.ReceiveUpdateFee(newFeeRate); err != nil {\n\t\tt.Fatalf(\"unable to update fee for Bob's channel: %v\", err)\n\t}\n\n\t// Now, Alice will send a new commitment to Bob, but we'll simulate a\n\t// connection failure, so Bob doesn't get her signature.\n\taliceSig, aliceHtlcSigs, _, err := aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"unable to sign commitment\")\n\n\t// Restart both channels to simulate a connection restart.\n\taliceChannel, err = restartChannel(aliceChannel)\n\trequire.NoError(t, err, \"unable to restart alice\")\n\tbobChannel, err = restartChannel(bobChannel)\n\trequire.NoError(t, err, \"unable to restart channel\")\n\n\t// Bob doesn't get this message so upon reconnection, they need to\n\t// synchronize. Alice should conclude that she owes Bob a commitment,\n\t// while Bob should think he's properly synchronized.\n\taliceSyncMsg, err := aliceChannel.channelState.ChanSyncMsg()\n\trequire.NoError(t, err, \"unable to produce chan sync msg\")\n\tbobSyncMsg, err := bobChannel.channelState.ChanSyncMsg()\n\trequire.NoError(t, err, \"unable to produce chan sync msg\")\n\n\t// Bob should detect that he doesn't need to send anything to Alice.\n\tbobMsgsToSend, _, _, err := bobChannel.ProcessChanSyncMsg(aliceSyncMsg)\n\trequire.NoError(t, err, \"unable to process chan sync msg\")\n\tif len(bobMsgsToSend) != 0 {\n\t\tt.Fatalf(\"expected bob to send %v messages instead \"+\n\t\t\t\"will send %v: %v\", 0, len(bobMsgsToSend),\n\t\t\tspew.Sdump(bobMsgsToSend))\n\t}\n\n\t// When Alice processes Bob's chan sync message, she should realize\n\t// that she needs to first send a new UpdateFee message, and also a\n\t// CommitSig.\n\taliceMsgsToSend, _, _, err := aliceChannel.ProcessChanSyncMsg(\n\t\tbobSyncMsg,\n\t)\n\trequire.NoError(t, err, \"unable to process chan sync msg\")\n\tif len(aliceMsgsToSend) != 2 {\n\t\tt.Fatalf(\"expected alice to send %v messages instead \"+\n\t\t\t\"will send %v: %v\", 2, len(aliceMsgsToSend),\n\t\t\tspew.Sdump(aliceMsgsToSend))\n\t}\n\n\t// The first message should be an UpdateFee message.\n\tretransFeeMsg, ok := aliceMsgsToSend[0].(*lnwire.UpdateFee)\n\tif !ok {\n\t\tt.Fatalf(\"expected UpdateFee message, instead have: %v\",\n\t\t\tspew.Sdump(aliceMsgsToSend[0]))\n\t}\n\n\t// The fee should match exactly the new fee update we applied above.\n\tif retransFeeMsg.FeePerKw != uint32(newFeeRate) {\n\t\tt.Fatalf(\"fee update doesn't match: expected %v, got %v\",\n\t\t\tuint32(newFeeRate), retransFeeMsg)\n\t}\n\n\t// The second, should be a CommitSig message, and be identical to the\n\t// sig message she sent prior.\n\tcommitSigMsg, ok := aliceMsgsToSend[1].(*lnwire.CommitSig)\n\tif !ok {\n\t\tt.Fatalf(\"expected a CommitSig message, instead have %v\",\n\t\t\tspew.Sdump(aliceMsgsToSend[1]))\n\t}\n\tif commitSigMsg.CommitSig != aliceSig {\n\t\tt.Fatalf(\"commit sig msgs don't match: expected %x got %x\",\n\t\t\taliceSig, commitSigMsg.CommitSig)\n\t}\n\tif len(commitSigMsg.HtlcSigs) != len(aliceHtlcSigs) {\n\t\tt.Fatalf(\"wrong number of htlc sigs: expected %v, got %v\",\n\t\t\tlen(aliceHtlcSigs), len(commitSigMsg.HtlcSigs))\n\t}\n\tfor i, htlcSig := range commitSigMsg.HtlcSigs {\n\t\tif htlcSig != aliceHtlcSigs[i] {\n\t\t\tt.Fatalf(\"htlc sig msgs don't match: \"+\n\t\t\t\t\"expected %x got %x\",\n\t\t\t\taliceHtlcSigs[i], htlcSig)\n\t\t}\n\t}\n\n\t// Now, we if re-apply the updates to Bob, we should be able to resume\n\t// the commitment update as normal.\n\tif err := bobChannel.ReceiveUpdateFee(newFeeRate); err != nil {\n\t\tt.Fatalf(\"unable to update fee for Bob's channel: %v\", err)\n\t}\n\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\trequire.NoError(t, err, \"bob unable to process alice's commitment\")\n\tbobRevocation, _, _, err := bobChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"unable to revoke bob commitment\")\n\tbobSig, bobHtlcSigs, _, err := bobChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"bob unable to sign commitment\")\n\t_, _, _, _, err = aliceChannel.ReceiveRevocation(bobRevocation)\n\trequire.NoError(t, err, \"alice unable to recv revocation\")\n\terr = aliceChannel.ReceiveNewCommitment(bobSig, bobHtlcSigs)\n\trequire.NoError(t, err, \"alice unable to rev bob's commitment\")\n\taliceRevocation, _, _, err := aliceChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"alice unable to revoke commitment\")\n\t_, _, _, _, err = bobChannel.ReceiveRevocation(aliceRevocation)\n\trequire.NoError(t, err, \"bob unable to recv revocation\")\n\n\t// Both parties should now have the latest fee rate locked-in.\n\tif chainfee.SatPerKWeight(\n\t\taliceChannel.channelState.LocalCommitment.FeePerKw,\n\t) != newFeeRate {\n\n\t\tt.Fatalf(\"alice's feePerKw was not locked in\")\n\t}\n\tif chainfee.SatPerKWeight(\n\t\tbobChannel.channelState.LocalCommitment.FeePerKw,\n\t) != newFeeRate {\n\n\t\tt.Fatalf(\"bob's feePerKw was not locked in\")\n\t}\n\n\t// Finally, we'll add with adding a new HTLC, then forcing a state\n\t// transition. This should also proceed as normal.\n\tvar bobPreimage [32]byte\n\tcopy(bobPreimage[:], bytes.Repeat([]byte{0xaa}, 32))\n\trHash := sha256.Sum256(bobPreimage[:])\n\tbobHtlc := &lnwire.UpdateAddHTLC{\n\t\tPaymentHash: rHash,\n\t\tAmount:      lnwire.NewMSatFromSatoshis(20000),\n\t\tExpiry:      uint32(10),\n\t}\n\tif _, err := bobChannel.AddHTLC(bobHtlc, nil); err != nil {\n\t\tt.Fatalf(\"unable to add bob's htlc: %v\", err)\n\t}\n\tif _, err := aliceChannel.ReceiveHTLC(bobHtlc); err != nil {\n\t\tt.Fatalf(\"unable to recv bob's htlc: %v\", err)\n\t}\n\tif err := ForceStateTransition(bobChannel, aliceChannel); err != nil {\n\t\tt.Fatalf(\"unable to complete bob's state transition: %v\", err)\n\t}\n}\n\n// TestFeeUpdateOldDiskFormat tests that we properly recover FeeUpdates written\n// to disk using the old format, where the logIndex was not written.",
      "length": 6193,
      "tokens": 795,
      "embedding": []
    },
    {
      "slug": "func TestFeeUpdateOldDiskFormat(t *testing.T) {",
      "content": "func TestFeeUpdateOldDiskFormat(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a test channel which will be used for the duration of this\n\t// unittest. The channel will be funded evenly with Alice having 5 BTC,\n\t// and Bob having 5 BTC.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// helper that counts the number of updates, and number of fee updates\n\t// in the given log.\n\tcountLog := func(log *updateLog) (int, int) {\n\t\tvar numUpdates, numFee int\n\t\tfor e := log.Front(); e != nil; e = e.Next() {\n\t\t\thtlc := e.Value.(*PaymentDescriptor)\n\t\t\tif htlc.EntryType == FeeUpdate {\n\t\t\t\tnumFee++\n\t\t\t}\n\t\t\tnumUpdates++\n\t\t}\n\t\treturn numUpdates, numFee\n\t}\n\n\t// helper that asserts that Alice's local log and Bob's remote log\n\t// contains the expected number of fee updates and adds.\n\tassertLogItems := func(expFee, expAdd int) {\n\t\tt.Helper()\n\n\t\texpUpd := expFee + expAdd\n\t\tupd, fees := countLog(aliceChannel.localUpdateLog)\n\t\tif upd != expUpd {\n\t\t\tt.Fatalf(\"expected %d updates, found %d in Alice's \"+\n\t\t\t\t\"log\", expUpd, upd)\n\t\t}\n\t\tif fees != expFee {\n\t\t\tt.Fatalf(\"expected %d fee updates, found %d in \"+\n\t\t\t\t\"Alice's log\", expFee, fees)\n\t\t}\n\t\tupd, fees = countLog(bobChannel.remoteUpdateLog)\n\t\tif upd != expUpd {\n\t\t\tt.Fatalf(\"expected %d updates, found %d in Bob's log\",\n\t\t\t\texpUpd, upd)\n\t\t}\n\t\tif fees != expFee {\n\t\t\tt.Fatalf(\"expected %d fee updates, found %d in Bob's \"+\n\t\t\t\t\"log\", expFee, fees)\n\t\t}\n\t}\n\n\t// First, we'll fetch the current fee rate present within the\n\t// commitment transactions.\n\tstartingFeeRate := chainfee.SatPerKWeight(\n\t\taliceChannel.channelState.LocalCommitment.FeePerKw,\n\t)\n\tnewFeeRate := startingFeeRate\n\n\t// We will send a few HTLCs and a fee update.\n\thtlcAmt := lnwire.NewMSatFromSatoshis(0.1 * btcutil.SatoshiPerBitcoin)\n\tconst numHTLCs = 30\n\tvar htlcs []*lnwire.UpdateAddHTLC\n\tfor i := 0; i < numHTLCs; i++ {\n\t\thtlc, _ := createHTLC(i, htlcAmt)\n\t\tif _, err := aliceChannel.AddHTLC(htlc, nil); err != nil {\n\t\t\tt.Fatalf(\"unable to add htlc: %v\", err)\n\t\t}\n\t\tif _, err := bobChannel.ReceiveHTLC(htlc); err != nil {\n\t\t\tt.Fatalf(\"unable to recv htlc: %v\", err)\n\t\t}\n\t\thtlcs = append(htlcs, htlc)\n\n\t\tif i%5 != 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// After every 5th HTLC, we'll also include a fee update.\n\t\tnewFeeRate += startingFeeRate\n\t\tif err := aliceChannel.UpdateFee(newFeeRate); err != nil {\n\t\t\tt.Fatalf(\"unable to update fee for Alice's channel: %v\",\n\t\t\t\terr)\n\t\t}\n\t\tif err := bobChannel.ReceiveUpdateFee(newFeeRate); err != nil {\n\t\t\tt.Fatalf(\"unable to update fee for Bob's channel: %v\",\n\t\t\t\terr)\n\t\t}\n\t}\n\t// Check that the expected number of items is found in the logs.\n\texpFee := numHTLCs / 5\n\tassertLogItems(expFee, numHTLCs)\n\n\t// Now, Alice will send a new commitment to Bob, but we'll simulate a\n\t// connection failure, so Bob doesn't get the signature.\n\taliceSig, aliceHtlcSigs, _, err := aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"unable to sign commitment\")\n\n\t// Before restarting Alice, to mimic the old format, we fetch the\n\t// pending remote commit from disk, set the UpdateFee message's\n\t// logIndex to 0, and re-write it.\n\tpendingRemoteCommitDiff, err := aliceChannel.channelState.RemoteCommitChainTip()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfor i, u := range pendingRemoteCommitDiff.LogUpdates {\n\t\tswitch u.UpdateMsg.(type) {\n\t\tcase *lnwire.UpdateFee:\n\t\t\tpendingRemoteCommitDiff.LogUpdates[i].LogIndex = 0\n\t\t}\n\t}\n\terr = aliceChannel.channelState.AppendRemoteCommitChain(\n\t\tpendingRemoteCommitDiff,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Restart both channels to simulate a connection restart. This will\n\t// trigger a update logs restoration.\n\taliceChannel, err = restartChannel(aliceChannel)\n\trequire.NoError(t, err, \"unable to restart alice\")\n\tbobChannel, err = restartChannel(bobChannel)\n\trequire.NoError(t, err, \"unable to restart channel\")\n\n\t// After a reconnection, Alice will resend the pending updates, that\n\t// was not ACKed by Bob, so we re-send the HTLCs and fee updates.\n\tnewFeeRate = startingFeeRate\n\tfor i := 0; i < numHTLCs; i++ {\n\t\thtlc := htlcs[i]\n\t\tif _, err := bobChannel.ReceiveHTLC(htlc); err != nil {\n\t\t\tt.Fatalf(\"unable to recv htlc: %v\", err)\n\t\t}\n\n\t\tif i%5 != 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tnewFeeRate += startingFeeRate\n\t\tif err := bobChannel.ReceiveUpdateFee(newFeeRate); err != nil {\n\t\t\tt.Fatalf(\"unable to update fee for Bob's channel: %v\",\n\t\t\t\terr)\n\t\t}\n\t}\n\tassertLogItems(expFee, numHTLCs)\n\n\t// We send Alice's commitment signatures, and finish the state\n\t// transition.\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\trequire.NoError(t, err, \"bob unable to process alice's commitment\")\n\tbobRevocation, _, _, err := bobChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"unable to revoke bob commitment\")\n\tbobSig, bobHtlcSigs, _, err := bobChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"bob unable to sign commitment\")\n\t_, _, _, _, err = aliceChannel.ReceiveRevocation(bobRevocation)\n\trequire.NoError(t, err, \"alice unable to recv revocation\")\n\terr = aliceChannel.ReceiveNewCommitment(bobSig, bobHtlcSigs)\n\trequire.NoError(t, err, \"alice unable to rev bob's commitment\")\n\taliceRevocation, _, _, err := aliceChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"alice unable to revoke commitment\")\n\t_, _, _, _, err = bobChannel.ReceiveRevocation(aliceRevocation)\n\trequire.NoError(t, err, \"bob unable to recv revocation\")\n\n\t// Both parties should now have the latest fee rate locked-in.\n\tif chainfee.SatPerKWeight(\n\t\taliceChannel.channelState.LocalCommitment.FeePerKw,\n\t) != newFeeRate {\n\n\t\tt.Fatalf(\"alice's feePerKw was not locked in\")\n\t}\n\tif chainfee.SatPerKWeight(\n\t\tbobChannel.channelState.LocalCommitment.FeePerKw,\n\t) != newFeeRate {\n\n\t\tt.Fatalf(\"bob's feePerKw was not locked in\")\n\t}\n\n\t// Finally, to trigger a compactLogs execution, we'll add a new HTLC,\n\t// then force a state transition.\n\thtlc, _ := createHTLC(numHTLCs, htlcAmt)\n\tif _, err := aliceChannel.AddHTLC(htlc, nil); err != nil {\n\t\tt.Fatalf(\"unable to add htlc: %v\", err)\n\t}\n\tif _, err := bobChannel.ReceiveHTLC(htlc); err != nil {\n\t\tt.Fatalf(\"unable to recv htlc: %v\", err)\n\t}\n\tif err := ForceStateTransition(aliceChannel, bobChannel); err != nil {\n\t\tt.Fatalf(\"unable to complete bob's state transition: %v\", err)\n\t}\n\n\t// Finally, check the logs to make sure all fee updates have been\n\t// removed...\n\tassertLogItems(0, numHTLCs+1)\n\n\t// ...and the final fee rate locked in.\n\tif chainfee.SatPerKWeight(\n\t\taliceChannel.channelState.LocalCommitment.FeePerKw,\n\t) != newFeeRate {\n\n\t\tt.Fatalf(\"alice's feePerKw was not locked in\")\n\t}\n\tif chainfee.SatPerKWeight(\n\t\tbobChannel.channelState.LocalCommitment.FeePerKw,\n\t) != newFeeRate {\n\n\t\tt.Fatalf(\"bob's feePerKw was not locked in\")\n\t}\n}\n\n// TestChanSyncUnableToSync tests that if Alice or Bob receive an invalid\n// ChannelReestablish messages,then they reject the message and declare the\n// channel un-continuable by returning ErrCannotSyncCommitChains.",
      "length": 6713,
      "tokens": 916,
      "embedding": []
    },
    {
      "slug": "func TestChanSyncUnableToSync(t *testing.T) {",
      "content": "func TestChanSyncUnableToSync(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a test channel which will be used for the duration of this\n\t// unittest. The channel will be funded evenly with Alice having 5 BTC,\n\t// and Bob having 5 BTC.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// If we immediately send both sides a \"bogus\" ChanSync message, then\n\t// they both should conclude that they're unable to synchronize the\n\t// state.\n\tbadChanSync := &lnwire.ChannelReestablish{\n\t\tChanID: lnwire.NewChanIDFromOutPoint(\n\t\t\t&aliceChannel.channelState.FundingOutpoint,\n\t\t),\n\t\tNextLocalCommitHeight:  1000,\n\t\tRemoteCommitTailHeight: 9000,\n\t}\n\t_, _, _, err = bobChannel.ProcessChanSyncMsg(badChanSync)\n\tif err != ErrCannotSyncCommitChains {\n\t\tt.Fatalf(\"expected error instead have: %v\", err)\n\t}\n\t_, _, _, err = aliceChannel.ProcessChanSyncMsg(badChanSync)\n\tif err != ErrCannotSyncCommitChains {\n\t\tt.Fatalf(\"expected error instead have: %v\", err)\n\t}\n}\n\n// TestChanSyncInvalidLastSecret ensures that if Alice and Bob have completed\n// state transitions in an existing channel, and then send a ChannelReestablish\n// message after a restart, the following holds: if Alice has lost data, so she\n// sends an invalid commit secret then both parties recognize this as possible\n// data loss.",
      "length": 1292,
      "tokens": 176,
      "embedding": []
    },
    {
      "slug": "func TestChanSyncInvalidLastSecret(t *testing.T) {",
      "content": "func TestChanSyncInvalidLastSecret(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a test channel which will be used for the duration of this\n\t// unittest. The channel will be funded evenly with Alice having 5 BTC,\n\t// and Bob having 5 BTC.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// We'll create a new instances of Alice before doing any state updates\n\t// such that we have the initial in memory state at the start of the\n\t// channel.\n\taliceOld, err := restartChannel(aliceChannel)\n\tif err != nil {\n\t\tt.Fatalf(\"unable to restart alice\")\n\t}\n\n\t// First, we'll add an HTLC, and then initiate a state transition\n\t// between the two parties such that we actually have a prior\n\t// revocation to send.\n\tvar paymentPreimage [32]byte\n\tcopy(paymentPreimage[:], bytes.Repeat([]byte{1}, 32))\n\tpaymentHash := sha256.Sum256(paymentPreimage[:])\n\thtlcAmt := lnwire.NewMSatFromSatoshis(btcutil.SatoshiPerBitcoin)\n\thtlc := &lnwire.UpdateAddHTLC{\n\t\tPaymentHash: paymentHash,\n\t\tAmount:      htlcAmt,\n\t\tExpiry:      uint32(5),\n\t}\n\tif _, err := aliceChannel.AddHTLC(htlc, nil); err != nil {\n\t\tt.Fatalf(\"unable to add htlc: %v\", err)\n\t}\n\tif _, err := bobChannel.ReceiveHTLC(htlc); err != nil {\n\t\tt.Fatalf(\"unable to recv htlc: %v\", err)\n\t}\n\n\t// Then we'll initiate a state transition to lock in this new HTLC.\n\tif err := ForceStateTransition(aliceChannel, bobChannel); err != nil {\n\t\tt.Fatalf(\"unable to complete alice's state transition: %v\", err)\n\t}\n\n\t// Next, we'll restart both parties in order to simulate a connection\n\t// re-establishment.\n\taliceChannel, err = restartChannel(aliceChannel)\n\trequire.NoError(t, err, \"unable to restart alice\")\n\tbobChannel, err = restartChannel(bobChannel)\n\trequire.NoError(t, err, \"unable to restart bob\")\n\n\t// Next, we'll produce the ChanSync messages for both parties.\n\taliceChanSync, err := aliceChannel.channelState.ChanSyncMsg()\n\trequire.NoError(t, err, \"unable to generate chan sync msg\")\n\tbobChanSync, err := bobChannel.channelState.ChanSyncMsg()\n\trequire.NoError(t, err, \"unable to generate chan sync msg\")\n\n\t// We'll modify Alice's sync message to have an invalid commitment\n\t// secret.\n\taliceChanSync.LastRemoteCommitSecret[4] ^= 0x01\n\n\t// Alice's former self should conclude that she possibly lost data as\n\t// Bob is sending a valid commit secret for the latest state.\n\t_, _, _, err = aliceOld.ProcessChanSyncMsg(bobChanSync)\n\tif _, ok := err.(*ErrCommitSyncLocalDataLoss); !ok {\n\t\tt.Fatalf(\"wrong error, expected ErrCommitSyncLocalDataLoss \"+\n\t\t\t\"instead got: %v\", err)\n\t}\n\n\t// Bob should conclude that he should force close the channel, as Alice\n\t// cannot continue operation.\n\t_, _, _, err = bobChannel.ProcessChanSyncMsg(aliceChanSync)\n\tif err != ErrInvalidLastCommitSecret {\n\t\tt.Fatalf(\"wrong error, expected ErrInvalidLastCommitSecret, \"+\n\t\t\t\"instead got: %v\", err)\n\t}\n}\n\n// TestChanAvailableBandwidth tests the accuracy of the AvailableBalance()\n// method. The value returned from this message should reflect the value\n// returned within the commitment state of a channel after the transition is\n// initiated.",
      "length": 3017,
      "tokens": 412,
      "embedding": []
    },
    {
      "slug": "func TestChanAvailableBandwidth(t *testing.T) {",
      "content": "func TestChanAvailableBandwidth(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a test channel which will be used for the duration of this\n\t// unittest. The channel will be funded evenly with Alice having 5 BTC,\n\t// and Bob having 5 BTC.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\taliceReserve := lnwire.NewMSatFromSatoshis(\n\t\taliceChannel.channelState.LocalChanCfg.ChanReserve,\n\t)\n\tfeeRate := chainfee.SatPerKWeight(\n\t\taliceChannel.channelState.LocalCommitment.FeePerKw,\n\t)\n\thtlcFee := lnwire.NewMSatFromSatoshis(\n\t\tfeeRate.FeeForWeight(input.HTLCWeight),\n\t)\n\n\tassertBandwidthEstimateCorrect := func(aliceInitiate bool) {\n\t\t// With the HTLC's added, we'll now query the AvailableBalance\n\t\t// method for the current available channel bandwidth from\n\t\t// Alice's PoV.\n\t\taliceAvailableBalance := aliceChannel.AvailableBalance()\n\n\t\t// With this balance obtained, we'll now trigger a state update\n\t\t// to actually determine what the current up to date balance\n\t\t// is.\n\t\tif aliceInitiate {\n\t\t\terr := ForceStateTransition(aliceChannel, bobChannel)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to complete alice's state \"+\n\t\t\t\t\t\"transition: %v\", err)\n\t\t\t}\n\t\t} else {\n\t\t\terr := ForceStateTransition(bobChannel, aliceChannel)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to complete alice's state \"+\n\t\t\t\t\t\"transition: %v\", err)\n\t\t\t}\n\t\t}\n\n\t\t// Now, we'll obtain the current available bandwidth in Alice's\n\t\t// latest commitment and compare that to the prior estimate.\n\t\taliceBalance := aliceChannel.channelState.LocalCommitment.LocalBalance\n\n\t\t// The balance we have available for new HTLCs should be the\n\t\t// current local commitment balance, minus the channel reserve\n\t\t// and the fee for adding an HTLC.\n\t\texpBalance := aliceBalance - aliceReserve - htlcFee\n\t\tif expBalance != aliceAvailableBalance {\n\t\t\t_, _, line, _ := runtime.Caller(1)\n\t\t\tt.Fatalf(\"line: %v, incorrect balance: expected %v, \"+\n\t\t\t\t\"got %v\", line, expBalance, aliceAvailableBalance)\n\t\t}\n\t}\n\n\t// First, we'll add 3 outgoing HTLC's from Alice to Bob.\n\tconst numHtlcs = 3\n\tvar htlcAmt lnwire.MilliSatoshi = 100000\n\talicePreimages := make([][32]byte, numHtlcs)\n\tfor i := 0; i < numHtlcs; i++ {\n\t\thtlc, preImage := createHTLC(i, htlcAmt)\n\t\tif _, err := aliceChannel.AddHTLC(htlc, nil); err != nil {\n\t\t\tt.Fatalf(\"unable to add htlc: %v\", err)\n\t\t}\n\t\tif _, err := bobChannel.ReceiveHTLC(htlc); err != nil {\n\t\t\tt.Fatalf(\"unable to recv htlc: %v\", err)\n\t\t}\n\n\t\talicePreimages[i] = preImage\n\t}\n\n\tassertBandwidthEstimateCorrect(true)\n\n\t// We'll repeat the same exercise, but with non-dust HTLCs. So we'll\n\t// crank up the value of the HTLC's we're adding to the commitment\n\t// transaction.\n\thtlcAmt = lnwire.NewMSatFromSatoshis(30000)\n\tfor i := 0; i < numHtlcs; i++ {\n\t\thtlc, preImage := createHTLC(numHtlcs+i, htlcAmt)\n\t\tif _, err := aliceChannel.AddHTLC(htlc, nil); err != nil {\n\t\t\tt.Fatalf(\"unable to add htlc: %v\", err)\n\t\t}\n\t\tif _, err := bobChannel.ReceiveHTLC(htlc); err != nil {\n\t\t\tt.Fatalf(\"unable to recv htlc: %v\", err)\n\t\t}\n\n\t\talicePreimages = append(alicePreimages, preImage)\n\t}\n\n\tassertBandwidthEstimateCorrect(true)\n\n\t// Next, we'll have Bob 5 of Alice's HTLC's, and cancel one of them (in\n\t// the update log).\n\tfor i := 0; i < (numHtlcs*2)-1; i++ {\n\t\tpreImage := alicePreimages[i]\n\t\terr := bobChannel.SettleHTLC(preImage, uint64(i), nil, nil, nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to settle htlc: %v\", err)\n\t\t}\n\t\terr = aliceChannel.ReceiveHTLCSettle(preImage, uint64(i))\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to settle htlc: %v\", err)\n\t\t}\n\t}\n\n\thtlcIndex := uint64((numHtlcs * 2) - 1)\n\terr = bobChannel.FailHTLC(htlcIndex, []byte(\"f\"), nil, nil, nil)\n\trequire.NoError(t, err, \"unable to cancel HTLC\")\n\terr = aliceChannel.ReceiveFailHTLC(htlcIndex, []byte(\"bad\"))\n\trequire.NoError(t, err, \"unable to recv htlc cancel\")\n\n\t// We must do a state transition before the balance is available\n\t// for Alice.\n\tif err := ForceStateTransition(aliceChannel, bobChannel); err != nil {\n\t\tt.Fatalf(\"unable to complete alice's state \"+\n\t\t\t\"transition: %v\", err)\n\t}\n\n\t// With the HTLC's settled in the log, we'll now assert that if we\n\t// initiate a state transition, then our guess was correct.\n\tassertBandwidthEstimateCorrect(false)\n\n\t// TODO(roasbeef): additional tests from diff starting conditions\n}\n\n// TestChanAvailableBalanceNearHtlcFee checks that we get the expected reported\n// balance when it is close to the htlc fee.",
      "length": 4304,
      "tokens": 591,
      "embedding": []
    },
    {
      "slug": "func TestChanAvailableBalanceNearHtlcFee(t *testing.T) {",
      "content": "func TestChanAvailableBalanceNearHtlcFee(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a test channel which will be used for the duration of this\n\t// unittest. The channel will be funded evenly with Alice having 5 BTC,\n\t// and Bob having 5 BTC.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// Alice and Bob start with half the channel capacity.\n\taliceBalance := lnwire.NewMSatFromSatoshis(5 * btcutil.SatoshiPerBitcoin)\n\tbobBalance := lnwire.NewMSatFromSatoshis(5 * btcutil.SatoshiPerBitcoin)\n\n\taliceReserve := lnwire.NewMSatFromSatoshis(\n\t\taliceChannel.channelState.LocalChanCfg.ChanReserve,\n\t)\n\tbobReserve := lnwire.NewMSatFromSatoshis(\n\t\tbobChannel.channelState.LocalChanCfg.ChanReserve,\n\t)\n\n\taliceDustlimit := lnwire.NewMSatFromSatoshis(\n\t\taliceChannel.channelState.LocalChanCfg.DustLimit,\n\t)\n\tfeeRate := chainfee.SatPerKWeight(\n\t\taliceChannel.channelState.LocalCommitment.FeePerKw,\n\t)\n\thtlcFee := lnwire.NewMSatFromSatoshis(\n\t\tfeeRate.FeeForWeight(input.HTLCWeight),\n\t)\n\tcommitFee := lnwire.NewMSatFromSatoshis(\n\t\taliceChannel.channelState.LocalCommitment.CommitFee,\n\t)\n\thtlcTimeoutFee := lnwire.NewMSatFromSatoshis(\n\t\tHtlcTimeoutFee(aliceChannel.channelState.ChanType, feeRate),\n\t)\n\thtlcSuccessFee := lnwire.NewMSatFromSatoshis(\n\t\tHtlcSuccessFee(aliceChannel.channelState.ChanType, feeRate),\n\t)\n\n\t// Helper method to check the current reported balance.\n\tcheckBalance := func(t *testing.T, expBalanceAlice,\n\t\texpBalanceBob lnwire.MilliSatoshi) {\n\n\t\tt.Helper()\n\t\taliceBalance := aliceChannel.AvailableBalance()\n\t\tif aliceBalance != expBalanceAlice {\n\t\t\tt.Fatalf(\"Expected alice balance %v, got %v\",\n\t\t\t\texpBalanceAlice, aliceBalance)\n\t\t}\n\n\t\tbobBalance := bobChannel.AvailableBalance()\n\t\tif bobBalance != expBalanceBob {\n\t\t\tt.Fatalf(\"Expected bob balance %v, got %v\",\n\t\t\t\texpBalanceBob, bobBalance)\n\t\t}\n\t}\n\n\t// Helper method to send an HTLC from Alice to Bob, decreasing Alice's\n\t// balance.\n\thtlcIndex := uint64(0)\n\tsendHtlc := func(htlcAmt lnwire.MilliSatoshi) {\n\t\tt.Helper()\n\n\t\thtlc, preImage := createHTLC(int(htlcIndex), htlcAmt)\n\t\tif _, err := aliceChannel.AddHTLC(htlc, nil); err != nil {\n\t\t\tt.Fatalf(\"unable to add htlc: %v\", err)\n\t\t}\n\t\tif _, err := bobChannel.ReceiveHTLC(htlc); err != nil {\n\t\t\tt.Fatalf(\"unable to recv htlc: %v\", err)\n\t\t}\n\n\t\tif err := ForceStateTransition(aliceChannel, bobChannel); err != nil {\n\t\t\tt.Fatalf(\"unable to complete alice's state \"+\n\t\t\t\t\"transition: %v\", err)\n\t\t}\n\n\t\terr = bobChannel.SettleHTLC(preImage, htlcIndex, nil, nil, nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to settle htlc: %v\", err)\n\t\t}\n\t\terr = aliceChannel.ReceiveHTLCSettle(preImage, htlcIndex)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to settle htlc: %v\", err)\n\t\t}\n\n\t\tif err := ForceStateTransition(aliceChannel, bobChannel); err != nil {\n\t\t\tt.Fatalf(\"unable to complete alice's state \"+\n\t\t\t\t\"transition: %v\", err)\n\t\t}\n\n\t\thtlcIndex++\n\t\taliceBalance -= htlcAmt\n\t\tbobBalance += htlcAmt\n\t}\n\n\t// Balance should start out equal to half the channel capacity minus\n\t// the commitment fee Alice must pay and the channel reserve. In\n\t// addition the HTLC fee will be subtracted fromt the balance to\n\t// reflect that this value must be reserved for any payment above the\n\t// dust limit.\n\texpAliceBalance := aliceBalance - commitFee - aliceReserve - htlcFee\n\n\t// Bob is not the initiator, so he will have all his balance available,\n\t// since Alice pays for fees. Bob only need to keep his balance above\n\t// the reserve.\n\texpBobBalance := bobBalance - bobReserve\n\tcheckBalance(t, expAliceBalance, expBobBalance)\n\n\t// Find the minumim size of a non-dust HTLC.\n\taliceNonDustHtlc := aliceDustlimit + htlcTimeoutFee\n\n\t// Send a HTLC leaving Alice's remaining balance just enough to have\n\t// nonDustHtlc left after paying the commit fee and htlc fee.\n\thtlcAmt := aliceBalance - (commitFee + aliceReserve + htlcFee + aliceNonDustHtlc)\n\tsendHtlc(htlcAmt)\n\n\t// Now the real balance left will be\n\t// nonDustHtlc+commitfee+aliceReserve+htlcfee. The available balance\n\t// reported will just be nonDustHtlc, since the rest of the balance is\n\t// reserved.\n\texpAliceBalance = aliceNonDustHtlc\n\texpBobBalance = bobBalance - bobReserve\n\tcheckBalance(t, expAliceBalance, expBobBalance)\n\n\t// Send an HTLC using all but one msat of the reported balance.\n\thtlcAmt = aliceNonDustHtlc - 1\n\tsendHtlc(htlcAmt)\n\n\t// 1 msat should be left.\n\texpAliceBalance = 1\n\n\t// Bob should still have all his balance available, since even though\n\t// Alice cannot afford to add a non-dust HTLC, she can afford to add a\n\t// non-dust HTLC from Bob.\n\texpBobBalance = bobBalance - bobReserve\n\tcheckBalance(t, expAliceBalance, expBobBalance)\n\n\t// Sendng the last msat.\n\thtlcAmt = 1\n\tsendHtlc(htlcAmt)\n\n\t// No balance left.\n\texpAliceBalance = 0\n\n\t// We try to always reserve enough for the non-iniitator to be able to\n\t// add an HTLC, hence Bob should still have all his non-reserved\n\t// balance available.\n\texpBobBalance = bobBalance - bobReserve\n\tcheckBalance(t, expAliceBalance, expBobBalance)\n\n\t// Even though Alice has a reported balance of 0, this is because we\n\t// try to avoid getting into the position where she cannot pay the fee\n\t// for Bob adding another HTLC. This means she actually _has_ some\n\t// balance left, and we now force the channel into this situation by\n\t// sending yet another HTLC. In practice this can also happen if a fee\n\t// update eats into Alice's balance.\n\thtlcAmt = 1\n\tsendHtlc(htlcAmt)\n\n\t// Now Alice balance is so low that she cannot even afford to add a new\n\t// HTLC from Bob to the commitment transaction. Bob's balance should\n\t// reflect this, by only reporting dust amount being available. Alice\n\t// should still report a zero balance.\n\n\t// Since the dustlimit is different for the two commitments, the\n\t// largest HTLC Bob can send that Alice can afford on both commitments\n\t// (remember she cannot afford to pay the HTLC fee) is the largest dust\n\t// HTLC on Alice's commitemnt, since her dust limit is lower.\n\tbobNonDustHtlc := aliceDustlimit + htlcSuccessFee\n\texpBobBalance = bobNonDustHtlc - 1\n\texpAliceBalance = 0\n\tcheckBalance(t, expAliceBalance, expBobBalance)\n}\n\n// TestChanCommitWeightDustHtlcs checks that we correctly calculate the\n// commitment weight when some HTLCs are dust.",
      "length": 6051,
      "tokens": 820,
      "embedding": []
    },
    {
      "slug": "func TestChanCommitWeightDustHtlcs(t *testing.T) {",
      "content": "func TestChanCommitWeightDustHtlcs(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a test channel which will be used for the duration of this\n\t// unittest. The channel will be funded evenly with Alice having 5 BTC,\n\t// and Bob having 5 BTC.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\taliceDustlimit := lnwire.NewMSatFromSatoshis(\n\t\taliceChannel.channelState.LocalChanCfg.DustLimit,\n\t)\n\tbobDustlimit := lnwire.NewMSatFromSatoshis(\n\t\tbobChannel.channelState.LocalChanCfg.DustLimit,\n\t)\n\n\tfeeRate := chainfee.SatPerKWeight(\n\t\taliceChannel.channelState.LocalCommitment.FeePerKw,\n\t)\n\thtlcTimeoutFee := lnwire.NewMSatFromSatoshis(\n\t\tHtlcTimeoutFee(aliceChannel.channelState.ChanType, feeRate),\n\t)\n\thtlcSuccessFee := lnwire.NewMSatFromSatoshis(\n\t\tHtlcSuccessFee(aliceChannel.channelState.ChanType, feeRate),\n\t)\n\n\t// Helper method to add an HTLC from Alice to Bob.\n\thtlcIndex := uint64(0)\n\taddHtlc := func(htlcAmt lnwire.MilliSatoshi) lntypes.Preimage {\n\t\tt.Helper()\n\n\t\thtlc, preImage := createHTLC(int(htlcIndex), htlcAmt)\n\t\tif _, err := aliceChannel.AddHTLC(htlc, nil); err != nil {\n\t\t\tt.Fatalf(\"unable to add htlc: %v\", err)\n\t\t}\n\t\tif _, err := bobChannel.ReceiveHTLC(htlc); err != nil {\n\t\t\tt.Fatalf(\"unable to recv htlc: %v\", err)\n\t\t}\n\n\t\tif err := ForceStateTransition(aliceChannel, bobChannel); err != nil {\n\t\t\tt.Fatalf(\"unable to complete alice's state \"+\n\t\t\t\t\"transition: %v\", err)\n\t\t}\n\n\t\treturn preImage\n\t}\n\n\tsettleHtlc := func(preImage lntypes.Preimage) {\n\t\tt.Helper()\n\n\t\terr = bobChannel.SettleHTLC(preImage, htlcIndex, nil, nil, nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to settle htlc: %v\", err)\n\t\t}\n\t\terr = aliceChannel.ReceiveHTLCSettle(preImage, htlcIndex)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to settle htlc: %v\", err)\n\t\t}\n\n\t\tif err := ForceStateTransition(aliceChannel, bobChannel); err != nil {\n\t\t\tt.Fatalf(\"unable to complete alice's state \"+\n\t\t\t\t\"transition: %v\", err)\n\t\t}\n\t\thtlcIndex++\n\t}\n\n\t// Helper method that fetches the current remote commitment weight\n\t// fromt the given channel's POV.\n\tremoteCommitWeight := func(lc *LightningChannel) int64 {\n\t\tremoteACKedIndex := lc.localCommitChain.tip().theirMessageIndex\n\t\thtlcView := lc.fetchHTLCView(remoteACKedIndex,\n\t\t\tlc.localUpdateLog.logIndex)\n\n\t\t_, w := lc.availableCommitmentBalance(\n\t\t\thtlcView, true,\n\t\t)\n\n\t\treturn w\n\t}\n\n\t// Start by getting the initial remote commitment weight seen from\n\t// Alice's perspective. At this point there are no HTLCs on the\n\t// commitment.\n\tweight1 := remoteCommitWeight(aliceChannel)\n\n\t// Now add an HTLC that will be just below Bob's dustlimit.\n\t// Since this is an HTLC added from Alice on Bob's commitment, we will\n\t// use the HTLC success fee.\n\tbobDustHtlc := bobDustlimit + htlcSuccessFee - 1\n\tpreimg := addHtlc(bobDustHtlc)\n\n\t// Now get the current weight of the remote commitment. We expect it to\n\t// not have changed, since the HTLC we added is considered dust.\n\tweight2 := remoteCommitWeight(aliceChannel)\n\trequire.Equal(t, weight1, weight2)\n\n\t// In addition, we expect this weight to result in the fee we currently\n\t// see being paid on the remote commitent.\n\tcalcFee := feeRate.FeeForWeight(weight2)\n\tremoteCommitFee := aliceChannel.channelState.RemoteCommitment.CommitFee\n\trequire.Equal(t, calcFee, remoteCommitFee)\n\n\t// Settle the HTLC, bringing commitment weight back to base.\n\tsettleHtlc(preimg)\n\n\t// Now we do a similar check from Bob's POV. Start with getting his\n\t// current view of Alice's commitment weight.\n\tweight1 = remoteCommitWeight(bobChannel)\n\n\t// We'll add an HTLC from Alice to Bob, that is just above dust on\n\t// Alice's commitment. Now we'll use the timeout fee.\n\taliceDustHtlc := aliceDustlimit + htlcTimeoutFee\n\tpreimg = addHtlc(aliceDustHtlc)\n\n\t// Get the current remote commitment weight from Bob's POV, and ensure\n\t// it is now heavier, since Alice added a non-dust HTLC.\n\tweight2 = remoteCommitWeight(bobChannel)\n\trequire.Greater(t, weight2, weight1)\n\n\t// Ensure the current remote commit has the expected commitfee.\n\tcalcFee = feeRate.FeeForWeight(weight2)\n\tremoteCommitFee = bobChannel.channelState.RemoteCommitment.CommitFee\n\trequire.Equal(t, calcFee, remoteCommitFee)\n\n\tsettleHtlc(preimg)\n}\n\n// TestSignCommitmentFailNotLockedIn tests that a channel will not attempt to\n// create a new state if it doesn't yet know of the next revocation point for\n// the remote party.",
      "length": 4239,
      "tokens": 538,
      "embedding": []
    },
    {
      "slug": "func TestSignCommitmentFailNotLockedIn(t *testing.T) {",
      "content": "func TestSignCommitmentFailNotLockedIn(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a test channel which will be used for the duration of this\n\t// unittest. The channel will be funded evenly with Alice having 5 BTC,\n\t// and Bob having 5 BTC.\n\taliceChannel, _, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// Next, we'll modify Alice's internal state to omit knowledge of Bob's\n\t// next revocation point.\n\taliceChannel.channelState.RemoteNextRevocation = nil\n\n\t// If we now try to initiate a state update, then it should fail as\n\t// Alice is unable to actually create a new state.\n\t_, _, _, err = aliceChannel.SignNextCommitment()\n\tif err != ErrNoWindow {\n\t\tt.Fatalf(\"expected ErrNoWindow, instead have: %v\", err)\n\t}\n}\n\n// TestLockedInHtlcForwardingSkipAfterRestart ensures that after a restart, a\n// state machine doesn't attempt to re-forward any HTLC's that were already\n// locked in, but in a prior state.",
      "length": 913,
      "tokens": 140,
      "embedding": []
    },
    {
      "slug": "func TestLockedInHtlcForwardingSkipAfterRestart(t *testing.T) {",
      "content": "func TestLockedInHtlcForwardingSkipAfterRestart(t *testing.T) {\n\tt.Parallel()\n\n\t// First, we'll make a channel between Alice and Bob.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// We'll now add two HTLC's from Alice to Bob, then Alice will initiate\n\t// a state transition.\n\tvar htlcAmt lnwire.MilliSatoshi = 100000\n\thtlc, _ := createHTLC(0, htlcAmt)\n\tif _, err := aliceChannel.AddHTLC(htlc, nil); err != nil {\n\t\tt.Fatalf(\"unable to add htlc: %v\", err)\n\t}\n\tif _, err := bobChannel.ReceiveHTLC(htlc); err != nil {\n\t\tt.Fatalf(\"unable to recv htlc: %v\", err)\n\t}\n\thtlc2, _ := createHTLC(1, htlcAmt)\n\tif _, err := aliceChannel.AddHTLC(htlc2, nil); err != nil {\n\t\tt.Fatalf(\"unable to add htlc2: %v\", err)\n\t}\n\tif _, err := bobChannel.ReceiveHTLC(htlc2); err != nil {\n\t\tt.Fatalf(\"unable to recv htlc2: %v\", err)\n\t}\n\n\t// We'll now manually initiate a state transition between Alice and\n\t// bob.\n\taliceSig, aliceHtlcSigs, _, err := aliceChannel.SignNextCommitment()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tbobRevocation, _, _, err := bobChannel.RevokeCurrentCommitment()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Alice should detect that she doesn't need to forward any HTLC's.\n\tfwdPkg, _, _, _, err := aliceChannel.ReceiveRevocation(bobRevocation)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(fwdPkg.Adds) != 0 {\n\t\tt.Fatalf(\"alice shouldn't forward any HTLC's, instead wants to \"+\n\t\t\t\"forward %v htlcs\", len(fwdPkg.Adds))\n\t}\n\tif len(fwdPkg.SettleFails) != 0 {\n\t\tt.Fatalf(\"alice shouldn't forward any HTLC's, instead wants to \"+\n\t\t\t\"forward %v htlcs\", len(fwdPkg.SettleFails))\n\t}\n\n\t// Now, have Bob initiate a transition to lock in the Adds sent by\n\t// Alice.\n\tbobSig, bobHtlcSigs, _, err := bobChannel.SignNextCommitment()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = aliceChannel.ReceiveNewCommitment(bobSig, bobHtlcSigs)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\taliceRevocation, _, _, err := aliceChannel.RevokeCurrentCommitment()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Bob should now detect that he now has 2 incoming HTLC's that he can\n\t// forward along.\n\tfwdPkg, _, _, _, err = bobChannel.ReceiveRevocation(aliceRevocation)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(fwdPkg.Adds) != 2 {\n\t\tt.Fatalf(\"bob should forward 2 hltcs, instead has %v\",\n\t\t\tlen(fwdPkg.Adds))\n\t}\n\tif len(fwdPkg.SettleFails) != 0 {\n\t\tt.Fatalf(\"bob should forward 0 hltcs, instead has %v\",\n\t\t\tlen(fwdPkg.SettleFails))\n\t}\n\n\t// We'll now restart both Alice and Bob. This emulates a reconnection\n\t// between the two peers.\n\taliceChannel, err = restartChannel(aliceChannel)\n\trequire.NoError(t, err, \"unable to restart alice\")\n\tbobChannel, err = restartChannel(bobChannel)\n\trequire.NoError(t, err, \"unable to restart bob\")\n\n\t// With both nodes restarted, Bob will now attempt to cancel one of\n\t// Alice's HTLC's.\n\terr = bobChannel.FailHTLC(htlc.ID, []byte(\"failreason\"), nil, nil, nil)\n\trequire.NoError(t, err, \"unable to cancel HTLC\")\n\terr = aliceChannel.ReceiveFailHTLC(htlc.ID, []byte(\"bad\"))\n\trequire.NoError(t, err, \"unable to recv htlc cancel\")\n\n\t// We'll now initiate another state transition, but this time Bob will\n\t// lead.\n\tbobSig, bobHtlcSigs, _, err = bobChannel.SignNextCommitment()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = aliceChannel.ReceiveNewCommitment(bobSig, bobHtlcSigs)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\taliceRevocation, _, _, err = aliceChannel.RevokeCurrentCommitment()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// At this point, Bob receives the revocation from Alice, which is now\n\t// his signal to examine all the HTLC's that have been locked in to\n\t// process.\n\tfwdPkg, _, _, _, err = bobChannel.ReceiveRevocation(aliceRevocation)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Bob should detect that he doesn't need to forward *any* HTLC's, as\n\t// he was the one that initiated extending the commitment chain of\n\t// Alice.\n\tif len(fwdPkg.Adds) != 0 {\n\t\tt.Fatalf(\"alice shouldn't forward any HTLC's, instead wants to \"+\n\t\t\t\"forward %v htlcs\", len(fwdPkg.Adds))\n\t}\n\tif len(fwdPkg.SettleFails) != 0 {\n\t\tt.Fatalf(\"alice shouldn't forward any HTLC's, instead wants to \"+\n\t\t\t\"forward %v htlcs\", len(fwdPkg.SettleFails))\n\t}\n\n\t// Now, begin another state transition led by Alice, and fail the second\n\t// HTLC part-way through the dance.\n\taliceSig, aliceHtlcSigs, _, err = aliceChannel.SignNextCommitment()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Failing the HTLC here will cause the update to be included in Alice's\n\t// remote log, but it should not be committed by this transition.\n\terr = bobChannel.FailHTLC(htlc2.ID, []byte(\"failreason\"), nil, nil, nil)\n\trequire.NoError(t, err, \"unable to cancel HTLC\")\n\terr = aliceChannel.ReceiveFailHTLC(htlc2.ID, []byte(\"bad\"))\n\trequire.NoError(t, err, \"unable to recv htlc cancel\")\n\n\tbobRevocation, _, finalHtlcs, err := bobChannel.\n\t\tRevokeCurrentCommitment()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Check finalHtlcs for the expected final resolution.\n\trequire.Len(t, finalHtlcs, 1, \"final htlc expected\")\n\tfor _, settled := range finalHtlcs {\n\t\trequire.False(t, settled, \"final fail expected\")\n\t}\n\n\t// Alice should detect that she doesn't need to forward any Adds's, but\n\t// that the Fail has been locked in an can be forwarded.\n\t_, adds, settleFails, _, err := aliceChannel.ReceiveRevocation(bobRevocation)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(adds) != 0 {\n\t\tt.Fatalf(\"alice shouldn't forward any HTLC's, instead wants to \"+\n\t\t\t\"forward %v htlcs\", len(adds))\n\t}\n\tif len(settleFails) != 1 {\n\t\tt.Fatalf(\"alice should only forward %d HTLC's, instead wants to \"+\n\t\t\t\"forward %v htlcs\", 1, len(settleFails))\n\t}\n\tif settleFails[0].ParentIndex != htlc.ID {\n\t\tt.Fatalf(\"alice should forward fail for htlcid=%d, instead \"+\n\t\t\t\"forwarding id=%d\", htlc.ID,\n\t\t\tsettleFails[0].ParentIndex)\n\t}\n\n\t// We'll now restart both Alice and Bob. This emulates a reconnection\n\t// between the two peers.\n\taliceChannel, err = restartChannel(aliceChannel)\n\trequire.NoError(t, err, \"unable to restart alice\")\n\tbobChannel, err = restartChannel(bobChannel)\n\trequire.NoError(t, err, \"unable to restart bob\")\n\n\t// Re-add the Fail to both Alice and Bob's channels, as the non-committed\n\t// update will not have survived the restart.\n\terr = bobChannel.FailHTLC(htlc2.ID, []byte(\"failreason\"), nil, nil, nil)\n\trequire.NoError(t, err, \"unable to cancel HTLC\")\n\terr = aliceChannel.ReceiveFailHTLC(htlc2.ID, []byte(\"bad\"))\n\trequire.NoError(t, err, \"unable to recv htlc cancel\")\n\n\t// Have Alice initiate a state transition, which does not include the\n\t// HTLCs just re-added to the channel state.\n\taliceSig, aliceHtlcSigs, _, err = aliceChannel.SignNextCommitment()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tbobRevocation, _, _, err = bobChannel.RevokeCurrentCommitment()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Alice should detect that she doesn't need to forward any HTLC's, as\n\t// the updates haven't been committed by Bob yet.\n\tfwdPkg, _, _, _, err = aliceChannel.ReceiveRevocation(bobRevocation)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(fwdPkg.Adds) != 0 {\n\t\tt.Fatalf(\"alice shouldn't forward any HTLC's, instead wants to \"+\n\t\t\t\"forward %v htlcs\", len(fwdPkg.Adds))\n\t}\n\tif len(fwdPkg.SettleFails) != 0 {\n\t\tt.Fatalf(\"alice shouldn't forward any HTLC's, instead wants to \"+\n\t\t\t\"forward %v htlcs\", len(fwdPkg.SettleFails))\n\t}\n\n\t// Now initiate a final update from Bob to lock in the final Fail.\n\tbobSig, bobHtlcSigs, _, err = bobChannel.SignNextCommitment()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = aliceChannel.ReceiveNewCommitment(bobSig, bobHtlcSigs)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\taliceRevocation, _, _, err = aliceChannel.RevokeCurrentCommitment()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Bob should detect that he has nothing to forward, as he hasn't\n\t// received any HTLCs.\n\tfwdPkg, _, _, _, err = bobChannel.ReceiveRevocation(aliceRevocation)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(fwdPkg.Adds) != 0 {\n\t\tt.Fatalf(\"bob should forward 4 hltcs, instead has %v\",\n\t\t\tlen(fwdPkg.Adds))\n\t}\n\tif len(fwdPkg.SettleFails) != 0 {\n\t\tt.Fatalf(\"bob should forward 0 hltcs, instead has %v\",\n\t\t\tlen(fwdPkg.SettleFails))\n\t}\n\n\t// Finally, have Bob initiate a state transition that locks in the Fail\n\t// added after the restart.\n\taliceSig, aliceHtlcSigs, _, err = aliceChannel.SignNextCommitment()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tbobRevocation, _, _, err = bobChannel.RevokeCurrentCommitment()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// When Alice receives the revocation, she should detect that she\n\t// can now forward the freshly locked-in Fail.\n\t_, adds, settleFails, _, err = aliceChannel.ReceiveRevocation(bobRevocation)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(adds) != 0 {\n\t\tt.Fatalf(\"alice shouldn't forward any HTLC's, instead wants to \"+\n\t\t\t\"forward %v htlcs\", len(adds))\n\t}\n\tif len(settleFails) != 1 {\n\t\tt.Fatalf(\"alice should only forward one HTLC, instead wants to \"+\n\t\t\t\"forward %v htlcs\", len(settleFails))\n\t}\n\tif settleFails[0].ParentIndex != htlc2.ID {\n\t\tt.Fatalf(\"alice should forward fail for htlcid=%d, instead \"+\n\t\t\t\"forwarding id=%d\", htlc2.ID,\n\t\t\tsettleFails[0].ParentIndex)\n\t}\n}\n\n// TestInvalidCommitSigError tests that if the remote party sends us an invalid\n// commitment signature, then we'll reject it and return a special error that\n// contains information to allow the remote party to debug their issues.",
      "length": 9354,
      "tokens": 1329,
      "embedding": []
    },
    {
      "slug": "func TestInvalidCommitSigError(t *testing.T) {",
      "content": "func TestInvalidCommitSigError(t *testing.T) {\n\tt.Parallel()\n\n\t// First, we'll make a channel between Alice and Bob.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// With the channel established, we'll now send a single HTLC from\n\t// Alice to Bob.\n\tvar htlcAmt lnwire.MilliSatoshi = 100000\n\thtlc, _ := createHTLC(0, htlcAmt)\n\tif _, err := aliceChannel.AddHTLC(htlc, nil); err != nil {\n\t\tt.Fatalf(\"unable to add htlc: %v\", err)\n\t}\n\tif _, err := bobChannel.ReceiveHTLC(htlc); err != nil {\n\t\tt.Fatalf(\"unable to recv htlc: %v\", err)\n\t}\n\n\t// Alice will now attempt to initiate a state transition.\n\taliceSig, aliceHtlcSigs, _, err := aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"unable to sign new commit\")\n\n\t// Before the signature gets to Bob, we'll mutate it, such that the\n\t// signature is now actually invalid.\n\taliceSig[0] ^= 88\n\n\t// Bob should reject this new state, and return the proper error.\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\tif err == nil {\n\t\tt.Fatalf(\"bob accepted invalid state but shouldn't have\")\n\t}\n\tif _, ok := err.(*InvalidCommitSigError); !ok {\n\t\tt.Fatalf(\"bob sent incorrect error, expected %T, got %T\",\n\t\t\t&InvalidCommitSigError{}, err)\n\t}\n}\n\n// TestChannelUnilateralCloseHtlcResolution tests that in the case of a\n// unilateral channel closure, then the party that didn't broadcast the\n// commitment is able to properly sweep all relevant outputs.",
      "length": 1437,
      "tokens": 208,
      "embedding": []
    },
    {
      "slug": "func TestChannelUnilateralCloseHtlcResolution(t *testing.T) {",
      "content": "func TestChannelUnilateralCloseHtlcResolution(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a test channel which will be used for the duration of this\n\t// unittest. The channel will be funded evenly with Alice having 5 BTC,\n\t// and Bob having 5 BTC.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// We'll start off the test by adding an HTLC in both directions, then\n\t// initiating enough state transitions to lock both of them in.\n\thtlcAmount := lnwire.NewMSatFromSatoshis(20000)\n\thtlcAlice, _ := createHTLC(0, htlcAmount)\n\tif _, err := aliceChannel.AddHTLC(htlcAlice, nil); err != nil {\n\t\tt.Fatalf(\"alice unable to add htlc: %v\", err)\n\t}\n\tif _, err := bobChannel.ReceiveHTLC(htlcAlice); err != nil {\n\t\tt.Fatalf(\"bob unable to recv add htlc: %v\", err)\n\t}\n\thtlcBob, preimageBob := createHTLC(0, htlcAmount)\n\tif _, err := bobChannel.AddHTLC(htlcBob, nil); err != nil {\n\t\tt.Fatalf(\"bob unable to add htlc: %v\", err)\n\t}\n\tif _, err := aliceChannel.ReceiveHTLC(htlcBob); err != nil {\n\t\tt.Fatalf(\"alice unable to recv add htlc: %v\", err)\n\t}\n\tif err := ForceStateTransition(aliceChannel, bobChannel); err != nil {\n\t\tt.Fatalf(\"Can't update the channel state: %v\", err)\n\t}\n\tif err := ForceStateTransition(bobChannel, aliceChannel); err != nil {\n\t\tt.Fatalf(\"Can't update the channel state: %v\", err)\n\t}\n\n\t// With both HTLC's locked in, we'll now simulate Bob force closing the\n\t// transaction on Alice.\n\tbobForceClose, err := bobChannel.ForceClose()\n\trequire.NoError(t, err, \"unable to close\")\n\n\t// We'll then use Bob's transaction to trigger a spend notification for\n\t// Alice.\n\tcloseTx := bobForceClose.CloseTx\n\tcommitTxHash := closeTx.TxHash()\n\tspendDetail := &chainntnfs.SpendDetail{\n\t\tSpendingTx:    closeTx,\n\t\tSpenderTxHash: &commitTxHash,\n\t}\n\taliceCloseSummary, err := NewUnilateralCloseSummary(\n\t\taliceChannel.channelState, aliceChannel.Signer,\n\t\tspendDetail,\n\t\taliceChannel.channelState.RemoteCommitment,\n\t\taliceChannel.channelState.RemoteCurrentRevocation,\n\t)\n\trequire.NoError(t, err, \"unable to create alice close summary\")\n\n\t// She should detect that she can sweep both the outgoing HTLC as well\n\t// as the incoming one from Bob.\n\tif len(aliceCloseSummary.HtlcResolutions.OutgoingHTLCs) != 1 {\n\t\tt.Fatalf(\"alice out htlc resolutions not populated: expected %v \"+\n\t\t\t\"htlcs, got %v htlcs\",\n\t\t\t1, len(aliceCloseSummary.HtlcResolutions.OutgoingHTLCs))\n\t}\n\tif len(aliceCloseSummary.HtlcResolutions.IncomingHTLCs) != 1 {\n\t\tt.Fatalf(\"alice in htlc resolutions not populated: expected %v \"+\n\t\t\t\"htlcs, got %v htlcs\",\n\t\t\t1, len(aliceCloseSummary.HtlcResolutions.IncomingHTLCs))\n\t}\n\n\toutHtlcResolution := aliceCloseSummary.HtlcResolutions.OutgoingHTLCs[0]\n\tinHtlcResolution := aliceCloseSummary.HtlcResolutions.IncomingHTLCs[0]\n\n\t// First, we'll ensure that Alice can directly spend the outgoing HTLC\n\t// given a transaction with the proper lock time set.\n\treceiverHtlcScript := closeTx.TxOut[outHtlcResolution.ClaimOutpoint.Index].PkScript\n\tsweepTx := wire.NewMsgTx(2)\n\tsweepTx.AddTxIn(&wire.TxIn{\n\t\tPreviousOutPoint: outHtlcResolution.ClaimOutpoint,\n\t})\n\tsweepTx.AddTxOut(&wire.TxOut{\n\t\tPkScript: receiverHtlcScript,\n\t\tValue:    outHtlcResolution.SweepSignDesc.Output.Value,\n\t})\n\toutHtlcResolution.SweepSignDesc.InputIndex = 0\n\toutHtlcResolution.SweepSignDesc.SigHashes = input.NewTxSigHashesV0Only(\n\t\tsweepTx,\n\t)\n\tsweepTx.LockTime = outHtlcResolution.Expiry\n\n\t// With the transaction constructed, we'll generate a witness that\n\t// should be valid for it, and verify using an instance of Script.\n\tsweepTx.TxIn[0].Witness, err = input.ReceiverHtlcSpendTimeout(\n\t\taliceChannel.Signer, &outHtlcResolution.SweepSignDesc,\n\t\tsweepTx, int32(outHtlcResolution.Expiry),\n\t)\n\trequire.NoError(t, err, \"unable to witness\")\n\tvm, err := txscript.NewEngine(\n\t\toutHtlcResolution.SweepSignDesc.Output.PkScript,\n\t\tsweepTx, 0, txscript.StandardVerifyFlags, nil,\n\t\tnil, outHtlcResolution.SweepSignDesc.Output.Value,\n\t\ttxscript.NewCannedPrevOutputFetcher(\n\t\t\toutHtlcResolution.SweepSignDesc.Output.PkScript,\n\t\t\toutHtlcResolution.SweepSignDesc.Output.Value,\n\t\t),\n\t)\n\trequire.NoError(t, err, \"unable to create engine\")\n\tif err := vm.Execute(); err != nil {\n\t\tt.Fatalf(\"htlc timeout spend is invalid: %v\", err)\n\t}\n\n\t// Next, we'll ensure that we're able to sweep the incoming HTLC with a\n\t// similar sweep transaction, this time using the payment pre-image.\n\tsenderHtlcScript := closeTx.TxOut[inHtlcResolution.ClaimOutpoint.Index].PkScript\n\tsweepTx = wire.NewMsgTx(2)\n\tsweepTx.AddTxIn(&wire.TxIn{\n\t\tPreviousOutPoint: inHtlcResolution.ClaimOutpoint,\n\t})\n\tsweepTx.AddTxOut(&wire.TxOut{\n\t\tPkScript: senderHtlcScript,\n\t\tValue:    inHtlcResolution.SweepSignDesc.Output.Value,\n\t})\n\tinHtlcResolution.SweepSignDesc.InputIndex = 0\n\tinHtlcResolution.SweepSignDesc.SigHashes = input.NewTxSigHashesV0Only(\n\t\tsweepTx,\n\t)\n\tsweepTx.TxIn[0].Witness, err = input.SenderHtlcSpendRedeem(\n\t\taliceChannel.Signer, &inHtlcResolution.SweepSignDesc,\n\t\tsweepTx, preimageBob[:],\n\t)\n\tif err != nil {\n\t\tt.Fatalf(\"unable to generate witness for success \"+\n\t\t\t\"output: %v\", err)\n\t}\n\n\t// Finally, we'll verify the constructed witness to ensure that Alice\n\t// can properly sweep the output.\n\tvm, err = txscript.NewEngine(\n\t\tinHtlcResolution.SweepSignDesc.Output.PkScript,\n\t\tsweepTx, 0, txscript.StandardVerifyFlags, nil,\n\t\tnil, inHtlcResolution.SweepSignDesc.Output.Value,\n\t\ttxscript.NewCannedPrevOutputFetcher(\n\t\t\tinHtlcResolution.SweepSignDesc.Output.PkScript,\n\t\t\tinHtlcResolution.SweepSignDesc.Output.Value,\n\t\t),\n\t)\n\trequire.NoError(t, err, \"unable to create engine\")\n\tif err := vm.Execute(); err != nil {\n\t\tt.Fatalf(\"htlc timeout spend is invalid: %v\", err)\n\t}\n}\n\n// TestChannelUnilateralClosePendingCommit tests that if the remote party\n// broadcasts their pending commit (hasn't yet revoked the lower one), then\n// we'll create a proper unilateral channel clsoure that can sweep the created\n// outputs.",
      "length": 5739,
      "tokens": 622,
      "embedding": []
    },
    {
      "slug": "func TestChannelUnilateralClosePendingCommit(t *testing.T) {",
      "content": "func TestChannelUnilateralClosePendingCommit(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a test channel which will be used for the duration of this\n\t// unittest. The channel will be funded evenly with Alice having 5 BTC,\n\t// and Bob having 5 BTC.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// First, we'll add an HTLC from Alice to Bob, just to be be able to\n\t// create a new state transition.\n\thtlcAmount := lnwire.NewMSatFromSatoshis(20000)\n\thtlcAlice, _ := createHTLC(0, htlcAmount)\n\tif _, err := aliceChannel.AddHTLC(htlcAlice, nil); err != nil {\n\t\tt.Fatalf(\"alice unable to add htlc: %v\", err)\n\t}\n\tif _, err := bobChannel.ReceiveHTLC(htlcAlice); err != nil {\n\t\tt.Fatalf(\"bob unable to recv add htlc: %v\", err)\n\t}\n\n\t// With the HTLC added, we'll now manually initiate a state transition\n\t// from Alice to Bob.\n\t_, _, _, err = aliceChannel.SignNextCommitment()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// At this point, Alice's commitment chain should have a new pending\n\t// commit for Bob. We'll extract it so we can simulate Bob broadcasting\n\t// the commitment due to an issue.\n\tbobCommit := aliceChannel.remoteCommitChain.tip().txn\n\tbobTxHash := bobCommit.TxHash()\n\tspendDetail := &chainntnfs.SpendDetail{\n\t\tSpenderTxHash: &bobTxHash,\n\t\tSpendingTx:    bobCommit,\n\t}\n\n\t// At this point, if we attempt to create a unilateral close summary\n\t// using this commitment, but with the wrong state, we should find that\n\t// our output wasn't picked up.\n\taliceWrongCloseSummary, err := NewUnilateralCloseSummary(\n\t\taliceChannel.channelState, aliceChannel.Signer,\n\t\tspendDetail,\n\t\taliceChannel.channelState.RemoteCommitment,\n\t\taliceChannel.channelState.RemoteCurrentRevocation,\n\t)\n\trequire.NoError(t, err, \"unable to create alice close summary\")\n\n\tif aliceWrongCloseSummary.CommitResolution != nil {\n\t\tt.Fatalf(\"alice shouldn't have found self output\")\n\t}\n\n\t// If we create the close summary again, but this time use Alice's\n\t// pending commit to Bob, then the unilateral close summary should be\n\t// properly populated.\n\taliceRemoteChainTip, err := aliceChannel.channelState.RemoteCommitChainTip()\n\trequire.NoError(t, err, \"unable to fetch remote chain tip\")\n\taliceCloseSummary, err := NewUnilateralCloseSummary(\n\t\taliceChannel.channelState, aliceChannel.Signer,\n\t\tspendDetail,\n\t\taliceRemoteChainTip.Commitment,\n\t\taliceChannel.channelState.RemoteNextRevocation,\n\t)\n\trequire.NoError(t, err, \"unable to create alice close summary\")\n\n\t// With this proper version, Alice's commit resolution should have been\n\t// properly located.\n\tif aliceCloseSummary.CommitResolution == nil {\n\t\tt.Fatalf(\"unable to find alice's commit resolution\")\n\t}\n\n\t// The proper short channel ID should also be set in Alice's close\n\t// channel summary.\n\tif aliceCloseSummary.ChannelCloseSummary.ShortChanID !=\n\t\taliceChannel.ShortChanID() {\n\n\t\tt.Fatalf(\"wrong short chan ID, expected %v got %v\",\n\t\t\taliceChannel.ShortChanID(),\n\t\t\taliceCloseSummary.ChannelCloseSummary.ShortChanID)\n\t}\n\n\taliceSignDesc := aliceCloseSummary.CommitResolution.SelfOutputSignDesc\n\n\t// Finally, we'll ensure that we're able to properly sweep our output\n\t// from using the materials within the unilateral close summary.\n\tsweepTx := wire.NewMsgTx(2)\n\tsweepTx.AddTxIn(&wire.TxIn{\n\t\tPreviousOutPoint: aliceCloseSummary.CommitResolution.SelfOutPoint,\n\t})\n\tsweepTx.AddTxOut(&wire.TxOut{\n\t\tPkScript: testHdSeed[:],\n\t\tValue:    aliceSignDesc.Output.Value,\n\t})\n\taliceSignDesc.SigHashes = input.NewTxSigHashesV0Only(sweepTx)\n\tsweepTx.TxIn[0].Witness, err = input.CommitSpendNoDelay(\n\t\taliceChannel.Signer, &aliceSignDesc, sweepTx, false,\n\t)\n\trequire.NoError(t, err, \"unable to generate sweep witness\")\n\n\t// If we validate the signature on the new sweep transaction, it should\n\t// be fully valid.\n\tvm, err := txscript.NewEngine(\n\t\taliceSignDesc.Output.PkScript, sweepTx, 0,\n\t\ttxscript.StandardVerifyFlags, nil, nil,\n\t\taliceSignDesc.Output.Value,\n\t\ttxscript.NewCannedPrevOutputFetcher(\n\t\t\taliceSignDesc.Output.PkScript,\n\t\t\taliceSignDesc.Output.Value,\n\t\t),\n\t)\n\trequire.NoError(t, err, \"unable to create engine\")\n\tif err := vm.Execute(); err != nil {\n\t\tt.Fatalf(\"htlc timeout spend is invalid: %v\", err)\n\t}\n}\n\n// TestDesyncHTLCs checks that we cannot add HTLCs that would make the\n// balance negative, when the remote and local update logs are desynced.",
      "length": 4200,
      "tokens": 506,
      "embedding": []
    },
    {
      "slug": "func TestDesyncHTLCs(t *testing.T) {",
      "content": "func TestDesyncHTLCs(t *testing.T) {\n\tt.Parallel()\n\n\t// We'll kick off the test by creating our channels which both are\n\t// loaded with 5 BTC each.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// First add one HTLC of value 4.1 BTC.\n\thtlcAmt := lnwire.NewMSatFromSatoshis(4.1 * btcutil.SatoshiPerBitcoin)\n\thtlc, _ := createHTLC(0, htlcAmt)\n\taliceIndex, err := aliceChannel.AddHTLC(htlc, nil)\n\trequire.NoError(t, err, \"unable to add htlc\")\n\tbobIndex, err := bobChannel.ReceiveHTLC(htlc)\n\trequire.NoError(t, err, \"unable to recv htlc\")\n\n\t// Lock this HTLC in.\n\tif err := ForceStateTransition(aliceChannel, bobChannel); err != nil {\n\t\tt.Fatalf(\"unable to complete state update: %v\", err)\n\t}\n\n\t// Now let Bob fail this HTLC.\n\terr = bobChannel.FailHTLC(bobIndex, []byte(\"failreason\"), nil, nil, nil)\n\trequire.NoError(t, err, \"unable to cancel HTLC\")\n\tif err := aliceChannel.ReceiveFailHTLC(aliceIndex, []byte(\"bad\")); err != nil {\n\t\tt.Fatalf(\"unable to recv htlc cancel: %v\", err)\n\t}\n\n\t// Alice now has gotten all her original balance (5 BTC) back, however,\n\t// adding a new HTLC at this point SHOULD fail, since if she adds the\n\t// HTLC and signs the next state, Bob cannot assume she received the\n\t// FailHTLC, and must assume she doesn't have the necessary balance\n\t// available.\n\t//\n\t// We try adding an HTLC of value 1 BTC, which should fail because the\n\t// balance is unavailable.\n\thtlcAmt = lnwire.NewMSatFromSatoshis(1 * btcutil.SatoshiPerBitcoin)\n\thtlc, _ = createHTLC(1, htlcAmt)\n\t_, err = aliceChannel.AddHTLC(htlc, nil)\n\trequire.ErrorIs(t, err, ErrBelowChanReserve)\n\n\t// Now do a state transition, which will ACK the FailHTLC, making Alice\n\t// able to add the new HTLC.\n\tif err := ForceStateTransition(aliceChannel, bobChannel); err != nil {\n\t\tt.Fatalf(\"unable to complete state update: %v\", err)\n\t}\n\tif _, err = aliceChannel.AddHTLC(htlc, nil); err != nil {\n\t\tt.Fatalf(\"unable to add htlc: %v\", err)\n\t}\n}\n\n// TODO(roasbeef): testing.Quick test case for retrans!!!\n\n// TestMaxAcceptedHTLCs tests that the correct error message (ErrMaxHTLCNumber)\n// is thrown when a node tries to accept more than MaxAcceptedHTLCs in a\n// channel.",
      "length": 2158,
      "tokens": 313,
      "embedding": []
    },
    {
      "slug": "func TestMaxAcceptedHTLCs(t *testing.T) {",
      "content": "func TestMaxAcceptedHTLCs(t *testing.T) {\n\tt.Parallel()\n\n\t// We'll kick off the test by creating our channels which both are\n\t// loaded with 5 BTC each.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// One over the maximum number of HTLCs that either can accept.\n\tconst numHTLCs = 12\n\n\t// Set the remote's required MaxAcceptedHtlcs. This means that Alice\n\t// can only offer the remote up to numHTLCs HTLCs.\n\taliceChannel.channelState.LocalChanCfg.MaxAcceptedHtlcs = numHTLCs\n\tbobChannel.channelState.RemoteChanCfg.MaxAcceptedHtlcs = numHTLCs\n\n\t// Similarly, set the remote config's MaxAcceptedHtlcs. This means\n\t// that the remote will be aware that Bob will only accept up to\n\t// numHTLCs at a time.\n\taliceChannel.channelState.RemoteChanCfg.MaxAcceptedHtlcs = numHTLCs\n\tbobChannel.channelState.LocalChanCfg.MaxAcceptedHtlcs = numHTLCs\n\n\t// Each HTLC amount is 0.1 BTC.\n\thtlcAmt := lnwire.NewMSatFromSatoshis(0.1 * btcutil.SatoshiPerBitcoin)\n\n\t// htlcID is used to keep track of the HTLC that Bob will fail back to\n\t// Alice.\n\tvar htlcID uint64\n\n\t// Send the maximum allowed number of HTLCs.\n\tfor i := 0; i < numHTLCs; i++ {\n\t\thtlc, _ := createHTLC(i, htlcAmt)\n\t\tif _, err := aliceChannel.AddHTLC(htlc, nil); err != nil {\n\t\t\tt.Fatalf(\"unable to add htlc: %v\", err)\n\t\t}\n\t\tif _, err := bobChannel.ReceiveHTLC(htlc); err != nil {\n\t\t\tt.Fatalf(\"unable to recv htlc: %v\", err)\n\t\t}\n\n\t\t// Just assign htlcID to the last received HTLC.\n\t\thtlcID = htlc.ID\n\t}\n\n\tif err := ForceStateTransition(aliceChannel, bobChannel); err != nil {\n\t\tt.Fatalf(\"unable to transition state: %v\", err)\n\t}\n\n\t// The next HTLC should fail with ErrMaxHTLCNumber.\n\thtlc, _ := createHTLC(numHTLCs, htlcAmt)\n\t_, err = aliceChannel.AddHTLC(htlc, nil)\n\tif err != ErrMaxHTLCNumber {\n\t\tt.Fatalf(\"expected ErrMaxHTLCNumber, instead received: %v\", err)\n\t}\n\n\t// Receiving the next HTLC should fail.\n\tif _, err := bobChannel.ReceiveHTLC(htlc); err != ErrMaxHTLCNumber {\n\t\tt.Fatalf(\"expected ErrMaxHTLCNumber, instead received: %v\", err)\n\t}\n\n\t// Bob will fail the htlc specified by htlcID and then force a state\n\t// transition.\n\terr = bobChannel.FailHTLC(htlcID, []byte{}, nil, nil, nil)\n\trequire.NoError(t, err, \"unable to fail htlc\")\n\n\tif err := aliceChannel.ReceiveFailHTLC(htlcID, []byte{}); err != nil {\n\t\tt.Fatalf(\"unable to receive fail htlc: %v\", err)\n\t}\n\n\tif err := ForceStateTransition(bobChannel, aliceChannel); err != nil {\n\t\tt.Fatalf(\"unable to transition state: %v\", err)\n\t}\n\n\t// Bob should succeed in adding a new HTLC since a previous HTLC was just\n\t// failed. We use numHTLCs here since the previous AddHTLC with this index\n\t// failed.\n\thtlc, _ = createHTLC(numHTLCs, htlcAmt)\n\tif _, err := aliceChannel.AddHTLC(htlc, nil); err != nil {\n\t\tt.Fatalf(\"unable to add htlc: %v\", err)\n\t}\n\tif _, err := bobChannel.ReceiveHTLC(htlc); err != nil {\n\t\tt.Fatalf(\"unable to recv htlc: %v\", err)\n\t}\n\n\t// Add a commitment to Bob's commitment chain.\n\taliceSig, aliceHtlcSigs, _, err := aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"unable to sign next commitment\")\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\trequire.NoError(t, err, \"unable to recv new commitment\")\n\n\t// The next HTLC should fail with ErrMaxHTLCNumber. The index is incremented\n\t// by one.\n\thtlc, _ = createHTLC(numHTLCs+1, htlcAmt)\n\tif _, err = aliceChannel.AddHTLC(htlc, nil); err != ErrMaxHTLCNumber {\n\t\tt.Fatalf(\"expected ErrMaxHTLCNumber, instead received: %v\", err)\n\t}\n\n\t// Likewise, Bob should not be able to receive this HTLC if Alice can't\n\t// add it.\n\tif _, err := bobChannel.ReceiveHTLC(htlc); err != ErrMaxHTLCNumber {\n\t\tt.Fatalf(\"expected ErrMaxHTLCNumber, instead received: %v\", err)\n\t}\n}\n\n// TestMaxAsynchronousHtlcs tests that Bob correctly receives (and does not\n// fail) an HTLC from Alice when exchanging asynchronous payments. We want to\n// mimic the following case where Bob's commitment transaction is full before\n// starting:\n//\n//\tAlice                    Bob\n//\n// 1.         <---settle/fail---\n// 2.         <-------sig-------\n// 3.         --------sig------> (covers an add sent before step 1)\n// 4.         <-------rev-------\n// 5.         --------rev------>\n// 6.         --------add------>\n// 7.         - - - - sig - - ->\n// This represents an asynchronous commitment dance in which both sides are\n// sending signatures at the same time. In step 3, the signature does not\n// cover the recent settle/fail that Bob sent in step 1. However, the add that\n// Alice sends to Bob in step 6 does not overflow Bob's commitment transaction.\n// This is because validateCommitmentSanity counts the HTLC's by ignoring\n// HTLC's which will be removed in the next signature that Alice sends. Thus,\n// the add won't overflow. This is because the signature received in step 7\n// covers the settle/fail in step 1 and makes space for the add in step 6.",
      "length": 4767,
      "tokens": 700,
      "embedding": []
    },
    {
      "slug": "func TestMaxAsynchronousHtlcs(t *testing.T) {",
      "content": "func TestMaxAsynchronousHtlcs(t *testing.T) {\n\tt.Parallel()\n\n\t// We'll kick off the test by creating our channels which both are\n\t// loaded with 5 BTC each.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// One over the maximum number of HTLCs that either can accept.\n\tconst numHTLCs = 12\n\n\t// Set the remote's required MaxAcceptedHtlcs. This means that Alice\n\t// can only offer the remote up to numHTLCs HTLCs.\n\taliceChannel.channelState.LocalChanCfg.MaxAcceptedHtlcs = numHTLCs\n\tbobChannel.channelState.RemoteChanCfg.MaxAcceptedHtlcs = numHTLCs\n\n\t// Similarly, set the remote config's MaxAcceptedHtlcs. This means\n\t// that the remote will be aware that Bob will only accept up to\n\t// numHTLCs at a time.\n\taliceChannel.channelState.RemoteChanCfg.MaxAcceptedHtlcs = numHTLCs\n\tbobChannel.channelState.LocalChanCfg.MaxAcceptedHtlcs = numHTLCs\n\n\t// Each HTLC amount is 0.1 BTC.\n\thtlcAmt := lnwire.NewMSatFromSatoshis(0.1 * btcutil.SatoshiPerBitcoin)\n\n\tvar htlcID uint64\n\n\t// Send the maximum allowed number of HTLCs minus one.\n\tfor i := 0; i < numHTLCs-1; i++ {\n\t\thtlc, _ := createHTLC(i, htlcAmt)\n\t\tif _, err := aliceChannel.AddHTLC(htlc, nil); err != nil {\n\t\t\tt.Fatalf(\"unable to add htlc: %v\", err)\n\t\t}\n\t\tif _, err := bobChannel.ReceiveHTLC(htlc); err != nil {\n\t\t\tt.Fatalf(\"unable to recv htlc: %v\", err)\n\t\t}\n\n\t\t// Just assign htlcID to the last received HTLC.\n\t\thtlcID = htlc.ID\n\t}\n\n\tif err := ForceStateTransition(aliceChannel, bobChannel); err != nil {\n\t\tt.Fatalf(\"unable to transition state: %v\", err)\n\t}\n\n\t// Send an HTLC to Bob so that Bob's commitment transaction is full.\n\thtlc, _ := createHTLC(numHTLCs-1, htlcAmt)\n\tif _, err := aliceChannel.AddHTLC(htlc, nil); err != nil {\n\t\tt.Fatalf(\"unable to add htlc: %v\", err)\n\t}\n\tif _, err := bobChannel.ReceiveHTLC(htlc); err != nil {\n\t\tt.Fatalf(\"unable to recv htlc: %v\", err)\n\t}\n\n\t// Fail back an HTLC and sign a commitment as in steps 1 & 2.\n\terr = bobChannel.FailHTLC(htlcID, []byte{}, nil, nil, nil)\n\trequire.NoError(t, err, \"unable to fail htlc\")\n\n\tif err := aliceChannel.ReceiveFailHTLC(htlcID, []byte{}); err != nil {\n\t\tt.Fatalf(\"unable to receive fail htlc: %v\", err)\n\t}\n\n\tbobSig, bobHtlcSigs, _, err := bobChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"unable to sign next commitment\")\n\n\terr = aliceChannel.ReceiveNewCommitment(bobSig, bobHtlcSigs)\n\trequire.NoError(t, err, \"unable to receive new commitment\")\n\n\t// Cover the HTLC referenced with id equal to numHTLCs-1 with a new\n\t// signature (step 3).\n\taliceSig, aliceHtlcSigs, _, err := aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"unable to sign next commitment\")\n\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\trequire.NoError(t, err, \"unable to receive new commitment\")\n\n\t// Both sides exchange revocations as in step 4 & 5.\n\tbobRevocation, _, _, err := bobChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"unable to revoke revocation\")\n\n\t_, _, _, _, err = aliceChannel.ReceiveRevocation(bobRevocation)\n\trequire.NoError(t, err, \"unable to receive revocation\")\n\n\taliceRevocation, _, _, err := aliceChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"unable to revoke revocation\")\n\n\t_, _, _, _, err = bobChannel.ReceiveRevocation(aliceRevocation)\n\trequire.NoError(t, err, \"unable to receive revocation\")\n\n\t// Send the final Add which should succeed as in step 6.\n\thtlc, _ = createHTLC(numHTLCs, htlcAmt)\n\tif _, err := aliceChannel.AddHTLC(htlc, nil); err != nil {\n\t\tt.Fatalf(\"unable to add htlc: %v\", err)\n\t}\n\tif _, err := bobChannel.ReceiveHTLC(htlc); err != nil {\n\t\tt.Fatalf(\"unable to recv htlc: %v\", err)\n\t}\n\n\t// Receiving the commitment should succeed as in step 7 since space was\n\t// made.\n\taliceSig, aliceHtlcSigs, _, err = aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"unable to sign next commitment\")\n\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\trequire.NoError(t, err, \"unable to receive new commitment\")\n}\n\n// TestMaxPendingAmount tests that the maximum overall pending HTLC value is met\n// given several HTLCs that, combined, exceed this value. An ErrMaxPendingAmount\n// error should be returned.",
      "length": 4073,
      "tokens": 552,
      "embedding": []
    },
    {
      "slug": "func TestMaxPendingAmount(t *testing.T) {",
      "content": "func TestMaxPendingAmount(t *testing.T) {\n\tt.Parallel()\n\n\t// We'll kick off the test by creating our channels which both are\n\t// loaded with 5 BTC each.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// We set the remote required MaxPendingAmount to 3 BTC. We will\n\t// attempt to overflow this value and see if it gives us the\n\t// ErrMaxPendingAmount error.\n\tmaxPending := lnwire.NewMSatFromSatoshis(btcutil.SatoshiPerBitcoin * 3)\n\n\t// We set the max pending amount of Alice's config. This mean that she\n\t// cannot offer Bob HTLCs with a total value above this limit at a given\n\t// time.\n\taliceChannel.channelState.LocalChanCfg.MaxPendingAmount = maxPending\n\tbobChannel.channelState.RemoteChanCfg.MaxPendingAmount = maxPending\n\n\t// First, we'll add 2 HTLCs of 1.5 BTC each to Alice's commitment.\n\t// This won't trigger Alice's ErrMaxPendingAmount error.\n\tconst numHTLCs = 2\n\thtlcAmt := lnwire.NewMSatFromSatoshis(1.5 * btcutil.SatoshiPerBitcoin)\n\tfor i := 0; i < numHTLCs; i++ {\n\t\thtlc, _ := createHTLC(i, htlcAmt)\n\t\tif _, err := aliceChannel.AddHTLC(htlc, nil); err != nil {\n\t\t\tt.Fatalf(\"unable to add htlc: %v\", err)\n\t\t}\n\t\tif _, err := bobChannel.ReceiveHTLC(htlc); err != nil {\n\t\t\tt.Fatalf(\"unable to recv htlc: %v\", err)\n\t\t}\n\t}\n\n\t// We finally add one more HTLC of 0.1 BTC to Alice's commitment. This\n\t// SHOULD trigger Alice's ErrMaxPendingAmount error.\n\thtlcAmt = lnwire.NewMSatFromSatoshis(0.1 * btcutil.SatoshiPerBitcoin)\n\thtlc, _ := createHTLC(numHTLCs, htlcAmt)\n\t_, err = aliceChannel.AddHTLC(htlc, nil)\n\tif err != ErrMaxPendingAmount {\n\t\tt.Fatalf(\"expected ErrMaxPendingAmount, instead received: %v\", err)\n\t}\n\n\t// And also Bob shouldn't be accepting this HTLC upon calling ReceiveHTLC.\n\tif _, err := bobChannel.ReceiveHTLC(htlc); err != ErrMaxPendingAmount {\n\t\tt.Fatalf(\"expected ErrMaxPendingAmount, instead received: %v\", err)\n\t}\n}\n",
      "length": 1867,
      "tokens": 258,
      "embedding": []
    },
    {
      "slug": "func assertChannelBalances(t *testing.T, alice, bob *LightningChannel,",
      "content": "func assertChannelBalances(t *testing.T, alice, bob *LightningChannel,\n\taliceBalance, bobBalance btcutil.Amount) {\n\n\t_, _, line, _ := runtime.Caller(1)\n\n\taliceSelfBalance := alice.channelState.LocalCommitment.LocalBalance.ToSatoshis()\n\taliceBobBalance := alice.channelState.LocalCommitment.RemoteBalance.ToSatoshis()\n\tif aliceSelfBalance != aliceBalance {\n\t\tt.Fatalf(\"line #%v: wrong alice self balance: expected %v, got %v\",\n\t\t\tline, aliceBalance, aliceSelfBalance)\n\t}\n\tif aliceBobBalance != bobBalance {\n\t\tt.Fatalf(\"line #%v: wrong alice bob's balance: expected %v, got %v\",\n\t\t\tline, bobBalance, aliceBobBalance)\n\t}\n\n\tbobSelfBalance := bob.channelState.LocalCommitment.LocalBalance.ToSatoshis()\n\tbobAliceBalance := bob.channelState.LocalCommitment.RemoteBalance.ToSatoshis()\n\tif bobSelfBalance != bobBalance {\n\t\tt.Fatalf(\"line #%v: wrong bob self balance: expected %v, got %v\",\n\t\t\tline, bobBalance, bobSelfBalance)\n\t}\n\tif bobAliceBalance != aliceBalance {\n\t\tt.Fatalf(\"line #%v: wrong alice bob's balance: expected %v, got %v\",\n\t\t\tline, aliceBalance, bobAliceBalance)\n\t}\n}\n\n// TestChanReserve tests that the ErrBelowChanReserve error is thrown when an\n// HTLC is added that causes a node's balance to dip below its channel reserve\n// limit.",
      "length": 1141,
      "tokens": 127,
      "embedding": []
    },
    {
      "slug": "func TestChanReserve(t *testing.T) {",
      "content": "func TestChanReserve(t *testing.T) {\n\tt.Parallel()\n\n\tsetupChannels := func() (*LightningChannel, *LightningChannel) {\n\t\t// We'll kick off the test by creating our channels which both\n\t\t// are loaded with 5 BTC each.\n\t\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\t\tt, channeldb.SingleFunderTweaklessBit,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to create test channels: %v\", err)\n\t\t}\n\n\t\t// We set the remote required ChanReserve to 0.5 BTC. We will\n\t\t// attempt to cause Alice's balance to dip below this amount\n\t\t// and test whether it triggers the ErrBelowChanReserve error.\n\t\taliceMinReserve := btcutil.Amount(0.5 *\n\t\t\tbtcutil.SatoshiPerBitcoin)\n\n\t\t// Alice will need to keep her reserve above aliceMinReserve,\n\t\t// so set this limit to here local config.\n\t\taliceChannel.channelState.LocalChanCfg.ChanReserve = aliceMinReserve\n\n\t\t// During channel opening Bob will also get to know Alice's\n\t\t// minimum reserve, and this will be found in his remote\n\t\t// config.\n\t\tbobChannel.channelState.RemoteChanCfg.ChanReserve = aliceMinReserve\n\n\t\t// We set Bob's channel reserve to a value that is larger than\n\t\t// his current balance in the channel. This will ensure that\n\t\t// after a channel is first opened, Bob can still receive HTLCs\n\t\t// even though his balance is less than his channel reserve.\n\t\tbobMinReserve := btcutil.Amount(6 * btcutil.SatoshiPerBitcoin)\n\t\tbobChannel.channelState.LocalChanCfg.ChanReserve = bobMinReserve\n\t\taliceChannel.channelState.RemoteChanCfg.ChanReserve = bobMinReserve\n\n\t\treturn aliceChannel, bobChannel\n\t}\n\taliceChannel, bobChannel := setupChannels()\n\n\taliceIndex := 0\n\tbobIndex := 0\n\n\t// Add an HTLC that will increase Bob's balance. This should succeed,\n\t// since Alice stays above her channel reserve, and Bob increases his\n\t// balance (while still being below his channel reserve).\n\t//\n\t// Resulting balances:\n\t//\tAlice:\t4.5\n\t//\tBob:\t5.0\n\thtlcAmt := lnwire.NewMSatFromSatoshis(0.5 * btcutil.SatoshiPerBitcoin)\n\thtlc, _ := createHTLC(aliceIndex, htlcAmt)\n\taliceIndex++\n\tif _, err := aliceChannel.AddHTLC(htlc, nil); err != nil {\n\t\tt.Fatalf(\"unable to add htlc: %v\", err)\n\t}\n\tif _, err := bobChannel.ReceiveHTLC(htlc); err != nil {\n\t\tt.Fatalf(\"unable to recv htlc: %v\", err)\n\t}\n\n\t// Force a state transition, making sure this HTLC is considered valid\n\t// even though the channel reserves are not met.\n\tif err := ForceStateTransition(aliceChannel, bobChannel); err != nil {\n\t\tt.Fatalf(\"unable to complete state update: %v\", err)\n\t}\n\n\tcommitFee := aliceChannel.channelState.LocalCommitment.CommitFee\n\tassertChannelBalances(\n\t\tt, aliceChannel, bobChannel,\n\t\tbtcutil.SatoshiPerBitcoin*4.5-commitFee, btcutil.SatoshiPerBitcoin*5,\n\t)\n\n\t// Now let Bob try to add an HTLC. This should fail, since it will\n\t// decrease his balance, which is already below the channel reserve.\n\t//\n\t// Resulting balances:\n\t//\tAlice:\t4.5\n\t//\tBob:\t5.0\n\thtlc, _ = createHTLC(bobIndex, htlcAmt)\n\tbobIndex++\n\t_, err := bobChannel.AddHTLC(htlc, nil)\n\trequire.ErrorIs(t, err, ErrBelowChanReserve)\n\n\t// Alice will reject this htlc upon receiving the htlc.\n\t_, err = aliceChannel.ReceiveHTLC(htlc)\n\trequire.ErrorIs(t, err, ErrBelowChanReserve)\n\n\t// We must setup the channels again, since a violation of the channel\n\t// constraints leads to channel shutdown.\n\taliceChannel, bobChannel = setupChannels()\n\n\taliceIndex = 0\n\tbobIndex = 0\n\n\t// Now we'll add HTLC of 3.5 BTC to Alice's commitment, this should put\n\t// Alice's balance at 1.5 BTC.\n\t//\n\t// Resulting balances:\n\t//\tAlice:\t1.5\n\t//\tBob:\t9.5\n\thtlcAmt = lnwire.NewMSatFromSatoshis(3.5 * btcutil.SatoshiPerBitcoin)\n\n\t// The first HTLC should successfully be sent.\n\thtlc, _ = createHTLC(aliceIndex, htlcAmt)\n\taliceIndex++\n\tif _, err := aliceChannel.AddHTLC(htlc, nil); err != nil {\n\t\tt.Fatalf(\"unable to add htlc: %v\", err)\n\t}\n\tif _, err := bobChannel.ReceiveHTLC(htlc); err != nil {\n\t\tt.Fatalf(\"unable to recv htlc: %v\", err)\n\t}\n\n\t// Add a second HTLC of 1 BTC. This should fail because it will take\n\t// Alice's balance all the way down to her channel reserve, but since\n\t// she is the initiator the additional transaction fee makes her\n\t// balance dip below.\n\thtlcAmt = lnwire.NewMSatFromSatoshis(1 * btcutil.SatoshiPerBitcoin)\n\thtlc, _ = createHTLC(aliceIndex, htlcAmt)\n\taliceIndex++\n\t_, err = aliceChannel.AddHTLC(htlc, nil)\n\trequire.ErrorIs(t, err, ErrBelowChanReserve)\n\n\t// Likewise, Bob will reject receiving the htlc because of the same reason.\n\t_, err = bobChannel.ReceiveHTLC(htlc)\n\trequire.ErrorIs(t, err, ErrBelowChanReserve)\n\n\t// We must setup the channels again, since a violation of the channel\n\t// constraints leads to channel shutdown.\n\taliceChannel, bobChannel = setupChannels()\n\n\taliceIndex = 0\n\tbobIndex = 0\n\n\t// Add a HTLC of 2 BTC to Alice, and the settle it.\n\t// Resulting balances:\n\t//\tAlice:\t3.0\n\t//\tBob:\t7.0\n\thtlcAmt = lnwire.NewMSatFromSatoshis(2 * btcutil.SatoshiPerBitcoin)\n\thtlc, preimage := createHTLC(aliceIndex, htlcAmt)\n\taliceIndex++\n\taliceHtlcIndex, err := aliceChannel.AddHTLC(htlc, nil)\n\trequire.NoError(t, err, \"unable to add htlc\")\n\tbobHtlcIndex, err := bobChannel.ReceiveHTLC(htlc)\n\trequire.NoError(t, err, \"unable to recv htlc\")\n\tif err := ForceStateTransition(aliceChannel, bobChannel); err != nil {\n\t\tt.Fatalf(\"unable to complete state update: %v\", err)\n\t}\n\n\tcommitFee = aliceChannel.channelState.LocalCommitment.CommitFee\n\tassertChannelBalances(\n\t\tt, aliceChannel, bobChannel,\n\t\tbtcutil.SatoshiPerBitcoin*3-commitFee, btcutil.SatoshiPerBitcoin*5,\n\t)\n\n\tif err := bobChannel.SettleHTLC(preimage, bobHtlcIndex, nil, nil, nil); err != nil {\n\t\tt.Fatalf(\"bob unable to settle inbound htlc: %v\", err)\n\t}\n\tif err := aliceChannel.ReceiveHTLCSettle(preimage, aliceHtlcIndex); err != nil {\n\t\tt.Fatalf(\"alice unable to accept settle of outbound htlc: %v\", err)\n\t}\n\tif err := ForceStateTransition(bobChannel, aliceChannel); err != nil {\n\t\tt.Fatalf(\"unable to complete state update: %v\", err)\n\t}\n\n\tcommitFee = aliceChannel.channelState.LocalCommitment.CommitFee\n\tassertChannelBalances(\n\t\tt, aliceChannel, bobChannel,\n\t\tbtcutil.SatoshiPerBitcoin*3-commitFee, btcutil.SatoshiPerBitcoin*7,\n\t)\n\n\t// And now let Bob add an HTLC of 1 BTC. This will take Bob's balance\n\t// all the way down to his channel reserve, but since he is not paying\n\t// the fee this is okay.\n\thtlcAmt = lnwire.NewMSatFromSatoshis(1 * btcutil.SatoshiPerBitcoin)\n\thtlc, _ = createHTLC(bobIndex, htlcAmt)\n\tbobIndex++\n\tif _, err := bobChannel.AddHTLC(htlc, nil); err != nil {\n\t\tt.Fatalf(\"unable to add htlc: %v\", err)\n\t}\n\tif _, err := aliceChannel.ReceiveHTLC(htlc); err != nil {\n\t\tt.Fatalf(\"unable to recv htlc: %v\", err)\n\t}\n\n\t// Do a last state transition, which should succeed.\n\tif err := ForceStateTransition(bobChannel, aliceChannel); err != nil {\n\t\tt.Fatalf(\"unable to complete state update: %v\", err)\n\t}\n\n\tcommitFee = aliceChannel.channelState.LocalCommitment.CommitFee\n\tassertChannelBalances(\n\t\tt, aliceChannel, bobChannel,\n\t\tbtcutil.SatoshiPerBitcoin*3-commitFee, btcutil.SatoshiPerBitcoin*6,\n\t)\n}\n\n// TestChanReserveRemoteInitiator tests that the channel reserve of the\n// initiator is accounted for when adding HTLCs, whether the initiator is the\n// local or remote node.",
      "length": 6897,
      "tokens": 923,
      "embedding": []
    },
    {
      "slug": "func TestChanReserveRemoteInitiator(t *testing.T) {",
      "content": "func TestChanReserveRemoteInitiator(t *testing.T) {\n\tt.Parallel()\n\n\t// We start out with a channel where both parties have 5 BTC.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Set Alice's channel reserve to be 5 BTC-commitfee. This means she\n\t// has just enough balance to cover the comitment fee, but not enough\n\t// to add any more HTLCs to the commitment. Although a reserve this\n\t// high is unrealistic, a channel can easily get into a situation\n\t// where the initiator cannot pay for the fee of any more HTLCs.\n\tcommitFee := aliceChannel.channelState.LocalCommitment.CommitFee\n\taliceMinReserve := 5*btcutil.SatoshiPerBitcoin - commitFee\n\n\taliceChannel.channelState.LocalChanCfg.ChanReserve = aliceMinReserve\n\tbobChannel.channelState.RemoteChanCfg.ChanReserve = aliceMinReserve\n\n\t// Now let Bob attempt to add an HTLC of 0.1 BTC. He has plenty of\n\t// money available to spend, but Alice, which is the initiator, cannot\n\t// afford any more HTLCs on the commitment transaction because that\n\t// would take here below her channel reserve..\n\thtlcAmt := lnwire.NewMSatFromSatoshis(0.1 * btcutil.SatoshiPerBitcoin)\n\thtlc, _ := createHTLC(0, htlcAmt)\n\n\t// Bob should refuse to add this HTLC, since he realizes it will create\n\t// an invalid commitment.\n\t_, err = bobChannel.AddHTLC(htlc, nil)\n\trequire.ErrorIs(t, err, ErrBelowChanReserve)\n\n\t// Of course Alice will also not have enough balance to add it herself.\n\t_, err = aliceChannel.AddHTLC(htlc, nil)\n\trequire.ErrorIs(t, err, ErrBelowChanReserve)\n\n\t// Same for Alice, she should refuse to accept this second HTLC.\n\t_, err = aliceChannel.ReceiveHTLC(htlc)\n\trequire.ErrorIs(t, err, ErrBelowChanReserve)\n}\n\n// TestChanReserveLocalInitiatorDustHtlc tests that fee the initiator must pay\n// when adding HTLCs is accounted for, even though the HTLC is considered dust\n// by the remote bode.",
      "length": 1828,
      "tokens": 259,
      "embedding": []
    },
    {
      "slug": "func TestChanReserveLocalInitiatorDustHtlc(t *testing.T) {",
      "content": "func TestChanReserveLocalInitiatorDustHtlc(t *testing.T) {\n\tt.Parallel()\n\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// The amount of the HTLC should not be considered dust according to\n\t// Alice's dust limit (200 sat), but be dust according to Bob's dust\n\t// limit (1300 sat). It is considered dust if the amount remaining\n\t// after paying the HTLC fee is below the dustlimit, so we choose a\n\t// size of 500+htlcFee.\n\thtlcSat := btcutil.Amount(500) + HtlcTimeoutFee(\n\t\taliceChannel.channelState.ChanType,\n\t\tchainfee.SatPerKWeight(\n\t\t\taliceChannel.channelState.LocalCommitment.FeePerKw,\n\t\t),\n\t)\n\n\t// Set Alice's channel reserve to be low enough to carry the value of\n\t// the HTLC, but not low enough to allow the extra fee from adding the\n\t// HTLC to the commitment.\n\tcommitFee := aliceChannel.channelState.LocalCommitment.CommitFee\n\taliceMinReserve := 5*btcutil.SatoshiPerBitcoin - commitFee - htlcSat\n\n\taliceChannel.channelState.LocalChanCfg.ChanReserve = aliceMinReserve\n\tbobChannel.channelState.RemoteChanCfg.ChanReserve = aliceMinReserve\n\n\thtlcDustAmt := lnwire.NewMSatFromSatoshis(htlcSat)\n\thtlc, _ := createHTLC(0, htlcDustAmt)\n\n\t// Alice should realize that the fee she must pay to add this HTLC to\n\t// the local commitment would take her below the channel reserve.\n\t_, err = aliceChannel.AddHTLC(htlc, nil)\n\trequire.ErrorIs(t, err, ErrBelowChanReserve)\n}\n\n// TestMinHTLC tests that the ErrBelowMinHTLC error is thrown if an HTLC is added\n// that is below the minimm allowed value for HTLCs.",
      "length": 1492,
      "tokens": 199,
      "embedding": []
    },
    {
      "slug": "func TestMinHTLC(t *testing.T) {",
      "content": "func TestMinHTLC(t *testing.T) {\n\tt.Parallel()\n\n\t// We'll kick off the test by creating our channels which both are\n\t// loaded with 5 BTC each.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// We set Alice's MinHTLC to 0.1 BTC. We will attempt to send an\n\t// HTLC BELOW this value to trigger the ErrBelowMinHTLC error.\n\tminValue := lnwire.NewMSatFromSatoshis(0.1 * btcutil.SatoshiPerBitcoin)\n\n\t// Setting the min value in Alice's local config means that the\n\t// remote will not accept any HTLCs of value less than specified.\n\taliceChannel.channelState.LocalChanCfg.MinHTLC = minValue\n\tbobChannel.channelState.RemoteChanCfg.MinHTLC = minValue\n\n\t// First, we will add an HTLC of 0.5 BTC. This will not trigger\n\t// ErrBelowMinHTLC.\n\thtlcAmt := lnwire.NewMSatFromSatoshis(0.5 * btcutil.SatoshiPerBitcoin)\n\thtlc, _ := createHTLC(0, htlcAmt)\n\tif _, err := aliceChannel.AddHTLC(htlc, nil); err != nil {\n\t\tt.Fatalf(\"unable to add htlc: %v\", err)\n\t}\n\tif _, err := bobChannel.ReceiveHTLC(htlc); err != nil {\n\t\tt.Fatalf(\"unable to recv htlc: %v\", err)\n\t}\n\n\t// We add an HTLC below the min value, this should result in\n\t// an ErrBelowMinHTLC error.\n\tamt := minValue - 100\n\thtlc, _ = createHTLC(1, amt)\n\t_, err = aliceChannel.AddHTLC(htlc, nil)\n\tif err != ErrBelowMinHTLC {\n\t\tt.Fatalf(\"expected ErrBelowMinHTLC, instead received: %v\", err)\n\t}\n\n\t// Bob will receive this HTLC, but reject the next received htlc, since\n\t// the htlc is too small.\n\t_, err = bobChannel.ReceiveHTLC(htlc)\n\tif err != ErrBelowMinHTLC {\n\t\tt.Fatalf(\"expected ErrBelowMinHTLC, instead received: %v\", err)\n\t}\n}\n\n// TestInvalidHTLCAmt tests that ErrInvalidHTLCAmt is returned when trying to\n// add HTLCs that don't carry a positive value.",
      "length": 1729,
      "tokens": 252,
      "embedding": []
    },
    {
      "slug": "func TestInvalidHTLCAmt(t *testing.T) {",
      "content": "func TestInvalidHTLCAmt(t *testing.T) {\n\tt.Parallel()\n\n\t// We'll kick off the test by creating our channels which both are\n\t// loaded with 5 BTC each.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// We'll set the min HTLC values for each party to zero, which\n\t// technically would permit zero-value HTLCs.\n\taliceChannel.channelState.LocalChanCfg.MinHTLC = 0\n\tbobChannel.channelState.RemoteChanCfg.MinHTLC = 0\n\n\t// Create a zero-value HTLC.\n\thtlcAmt := lnwire.MilliSatoshi(0)\n\thtlc, _ := createHTLC(0, htlcAmt)\n\n\t// Sending or receiving the HTLC should fail with ErrInvalidHTLCAmt.\n\t_, err = aliceChannel.AddHTLC(htlc, nil)\n\tif err != ErrInvalidHTLCAmt {\n\t\tt.Fatalf(\"expected ErrInvalidHTLCAmt, got: %v\", err)\n\t}\n\t_, err = bobChannel.ReceiveHTLC(htlc)\n\tif err != ErrInvalidHTLCAmt {\n\t\tt.Fatalf(\"expected ErrInvalidHTLCAmt, got: %v\", err)\n\t}\n}\n\n// TestNewBreachRetributionSkipsDustHtlcs ensures that in the case of a\n// contract breach, all dust HTLCs are ignored and not reflected in the\n// produced BreachRetribution struct. We ignore these HTLCs as they aren't\n// actually manifested on the commitment transaction, as a result we can't\n// actually revoked them.",
      "length": 1203,
      "tokens": 164,
      "embedding": []
    },
    {
      "slug": "func TestNewBreachRetributionSkipsDustHtlcs(t *testing.T) {",
      "content": "func TestNewBreachRetributionSkipsDustHtlcs(t *testing.T) {\n\tt.Parallel()\n\n\t// We'll kick off the test by creating our channels which both are\n\t// loaded with 5 BTC each.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\tvar fakeOnionBlob [lnwire.OnionPacketSize]byte\n\tcopy(fakeOnionBlob[:], bytes.Repeat([]byte{0x05}, lnwire.OnionPacketSize))\n\n\t// We'll modify the dust settings on both channels to be a predictable\n\t// value for the prurpose of the test.\n\tdustValue := btcutil.Amount(200)\n\taliceChannel.channelState.LocalChanCfg.DustLimit = dustValue\n\taliceChannel.channelState.RemoteChanCfg.DustLimit = dustValue\n\tbobChannel.channelState.LocalChanCfg.DustLimit = dustValue\n\tbobChannel.channelState.RemoteChanCfg.DustLimit = dustValue\n\n\t// We'll now create a series of dust HTLC's, and send then from Alice\n\t// to Bob, finally locking both of them in.\n\tvar bobPreimage [32]byte\n\tcopy(bobPreimage[:], bytes.Repeat([]byte{0xbb}, 32))\n\tfor i := 0; i < 3; i++ {\n\t\trHash := sha256.Sum256(bobPreimage[:])\n\t\th := &lnwire.UpdateAddHTLC{\n\t\t\tPaymentHash: rHash,\n\t\t\tAmount:      lnwire.NewMSatFromSatoshis(dustValue),\n\t\t\tExpiry:      uint32(10),\n\t\t\tOnionBlob:   fakeOnionBlob,\n\t\t}\n\n\t\thtlcIndex, err := aliceChannel.AddHTLC(h, nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to add bob's htlc: %v\", err)\n\t\t}\n\n\t\th.ID = htlcIndex\n\t\tif _, err := bobChannel.ReceiveHTLC(h); err != nil {\n\t\t\tt.Fatalf(\"unable to recv bob's htlc: %v\", err)\n\t\t}\n\t}\n\n\t// With the HTLC's applied to both update logs, we'll initiate a state\n\t// transition from Alice.\n\tif err := ForceStateTransition(aliceChannel, bobChannel); err != nil {\n\t\tt.Fatalf(\"unable to complete alice's state transition: %v\", err)\n\t}\n\n\t// At this point, we'll capture the current state number, as well as\n\t// the current commitment.\n\trevokedStateNum := aliceChannel.channelState.LocalCommitment.CommitHeight\n\n\t// We'll now have Bob settle those HTLC's to Alice and then advance\n\t// forward to a new state.\n\tfor i := 0; i < 3; i++ {\n\t\terr := bobChannel.SettleHTLC(bobPreimage, uint64(i), nil, nil, nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to settle htlc: %v\", err)\n\t\t}\n\t\terr = aliceChannel.ReceiveHTLCSettle(bobPreimage, uint64(i))\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to settle htlc: %v\", err)\n\t\t}\n\t}\n\tif err := ForceStateTransition(bobChannel, aliceChannel); err != nil {\n\t\tt.Fatalf(\"unable to complete bob's state transition: %v\", err)\n\t}\n\n\t// At this point, we'll now simulate a contract breach by Bob using the\n\t// NewBreachRetribution method.\n\tbreachTx := aliceChannel.channelState.RemoteCommitment.CommitTx\n\tbreachRet, err := NewBreachRetribution(\n\t\taliceChannel.channelState, revokedStateNum, 100, breachTx,\n\t)\n\trequire.NoError(t, err, \"unable to create breach retribution\")\n\n\t// The retribution shouldn't have any HTLCs set as they were all below\n\t// dust for both parties.\n\tif len(breachRet.HtlcRetributions) != 0 {\n\t\tt.Fatalf(\"zero HTLC retributions should have been created, \"+\n\t\t\t\"instead %v were\", len(breachRet.HtlcRetributions))\n\t}\n}\n\n// compareHtlcs compares two PaymentDescriptors.",
      "length": 2997,
      "tokens": 384,
      "embedding": []
    },
    {
      "slug": "func compareHtlcs(htlc1, htlc2 *PaymentDescriptor) error {",
      "content": "func compareHtlcs(htlc1, htlc2 *PaymentDescriptor) error {\n\tif htlc1.LogIndex != htlc2.LogIndex {\n\t\treturn fmt.Errorf(\"htlc log index did not match\")\n\t}\n\tif htlc1.HtlcIndex != htlc2.HtlcIndex {\n\t\treturn fmt.Errorf(\"htlc index did not match\")\n\t}\n\tif htlc1.ParentIndex != htlc2.ParentIndex {\n\t\treturn fmt.Errorf(\"htlc parent index did not match\")\n\t}\n\n\tif htlc1.RHash != htlc2.RHash {\n\t\treturn fmt.Errorf(\"htlc rhash did not match\")\n\t}\n\treturn nil\n}\n\n// compareIndexes is a helper method to compare two index maps.",
      "length": 436,
      "tokens": 64,
      "embedding": []
    },
    {
      "slug": "func compareIndexes(a, b map[uint64]*list.Element) error {",
      "content": "func compareIndexes(a, b map[uint64]*list.Element) error {\n\tfor k1, e1 := range a {\n\t\te2, ok := b[k1]\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"element with key %d \"+\n\t\t\t\t\"not found in b\", k1)\n\t\t}\n\t\thtlc1, htlc2 := e1.Value.(*PaymentDescriptor), e2.Value.(*PaymentDescriptor)\n\t\tif err := compareHtlcs(htlc1, htlc2); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tfor k1, e1 := range b {\n\t\te2, ok := a[k1]\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"element with key %d not \"+\n\t\t\t\t\"found in a\", k1)\n\t\t}\n\t\thtlc1, htlc2 := e1.Value.(*PaymentDescriptor), e2.Value.(*PaymentDescriptor)\n\t\tif err := compareHtlcs(htlc1, htlc2); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// compareLogs is a helper method to compare two updateLogs.",
      "length": 614,
      "tokens": 101,
      "embedding": []
    },
    {
      "slug": "func compareLogs(a, b *updateLog) error {",
      "content": "func compareLogs(a, b *updateLog) error {\n\tif a.logIndex != b.logIndex {\n\t\treturn fmt.Errorf(\"log indexes don't match: %d vs %d\",\n\t\t\ta.logIndex, b.logIndex)\n\t}\n\n\tif a.htlcCounter != b.htlcCounter {\n\t\treturn fmt.Errorf(\"htlc counters don't match: %d vs %d\",\n\t\t\ta.htlcCounter, b.htlcCounter)\n\t}\n\n\tif err := compareIndexes(a.updateIndex, b.updateIndex); err != nil {\n\t\treturn fmt.Errorf(\"update indexes don't match: %v\", err)\n\t}\n\tif err := compareIndexes(a.htlcIndex, b.htlcIndex); err != nil {\n\t\treturn fmt.Errorf(\"htlc indexes don't match: %v\", err)\n\t}\n\n\tif a.Len() != b.Len() {\n\t\treturn fmt.Errorf(\"list lengths not equal: %d vs %d\",\n\t\t\ta.Len(), b.Len())\n\t}\n\n\te1, e2 := a.Front(), b.Front()\n\tfor ; e1 != nil; e1, e2 = e1.Next(), e2.Next() {\n\t\thtlc1, htlc2 := e1.Value.(*PaymentDescriptor), e2.Value.(*PaymentDescriptor)\n\t\tif err := compareHtlcs(htlc1, htlc2); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// TestChannelRestoreUpdateLogs makes sure we are able to properly restore the\n// update logs in the case where a different number of HTLCs are locked in on\n// the local, remote and pending remote commitment.",
      "length": 1041,
      "tokens": 154,
      "embedding": []
    },
    {
      "slug": "func TestChannelRestoreUpdateLogs(t *testing.T) {",
      "content": "func TestChannelRestoreUpdateLogs(t *testing.T) {\n\tt.Parallel()\n\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// First, we'll add an HTLC from Alice to Bob, which we will lock in on\n\t// Bob's commit, but not on Alice's.\n\thtlcAmount := lnwire.NewMSatFromSatoshis(20000)\n\thtlcAlice, _ := createHTLC(0, htlcAmount)\n\tif _, err := aliceChannel.AddHTLC(htlcAlice, nil); err != nil {\n\t\tt.Fatalf(\"alice unable to add htlc: %v\", err)\n\t}\n\tif _, err := bobChannel.ReceiveHTLC(htlcAlice); err != nil {\n\t\tt.Fatalf(\"bob unable to recv add htlc: %v\", err)\n\t}\n\n\t// Let Alice sign a new state, which will include the HTLC just sent.\n\taliceSig, aliceHtlcSigs, _, err := aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"unable to sign commitment\")\n\n\t// Bob receives this commitment signature, and revokes his old state.\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\trequire.NoError(t, err, \"unable to receive commitment\")\n\tbobRevocation, _, _, err := bobChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"unable to revoke commitment\")\n\n\t// When Alice now receives this revocation, she will advance her remote\n\t// commitment chain to the commitment which includes the HTLC just\n\t// sent. However her local commitment chain still won't include the\n\t// state with the HTLC, since she hasn't received a new commitment\n\t// signature from Bob yet.\n\t_, _, _, _, err = aliceChannel.ReceiveRevocation(bobRevocation)\n\trequire.NoError(t, err, \"unable to receive revocation\")\n\n\t// Now make Alice send and sign an additional HTLC. We don't let Bob\n\t// receive it. We do this since we want to check that update logs are\n\t// restored properly below, and we'll only restore updates that have\n\t// been ACKed.\n\thtlcAlice, _ = createHTLC(1, htlcAmount)\n\tif _, err := aliceChannel.AddHTLC(htlcAlice, nil); err != nil {\n\t\tt.Fatalf(\"alice unable to add htlc: %v\", err)\n\t}\n\n\t// Send the signature covering the HTLC. This is okay, since the local\n\t// and remote commit chains are updated in an async fashion. Since the\n\t// remote chain was updated with the latest state (since Bob sent the\n\t// revocation earlier) we can keep advancing the remote commit chain.\n\taliceSig, aliceHtlcSigs, _, err = aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"unable to sign commitment\")\n\n\t// After Alice has signed this commitment, her local commitment will\n\t// contain no HTLCs, her remote commitment will contain an HTLC with\n\t// index 0, and the pending remote commitment (a signed remote\n\t// commitment which is not AKCed yet) will contain an additional HTLC\n\t// with index 1.\n\n\t// We now re-create the channels, mimicking a restart. This should sync\n\t// the update logs up to the correct state set up above.\n\tnewAliceChannel, err := NewLightningChannel(\n\t\taliceChannel.Signer, aliceChannel.channelState,\n\t\taliceChannel.sigPool,\n\t)\n\trequire.NoError(t, err, \"unable to create new channel\")\n\n\tnewBobChannel, err := NewLightningChannel(\n\t\tbobChannel.Signer, bobChannel.channelState,\n\t\tbobChannel.sigPool,\n\t)\n\trequire.NoError(t, err, \"unable to create new channel\")\n\n\t// compare all the logs between the old and new channels, to make sure\n\t// they all got restored properly.\n\terr = compareLogs(aliceChannel.localUpdateLog,\n\t\tnewAliceChannel.localUpdateLog)\n\trequire.NoError(t, err, \"alice local log not restored\")\n\n\terr = compareLogs(aliceChannel.remoteUpdateLog,\n\t\tnewAliceChannel.remoteUpdateLog)\n\trequire.NoError(t, err, \"alice remote log not restored\")\n\n\terr = compareLogs(bobChannel.localUpdateLog,\n\t\tnewBobChannel.localUpdateLog)\n\trequire.NoError(t, err, \"bob local log not restored\")\n\n\terr = compareLogs(bobChannel.remoteUpdateLog,\n\t\tnewBobChannel.remoteUpdateLog)\n\trequire.NoError(t, err, \"bob remote log not restored\")\n}\n\n// fetchNumUpdates counts the number of updateType in the log.",
      "length": 3759,
      "tokens": 513,
      "embedding": []
    },
    {
      "slug": "func fetchNumUpdates(t updateType, log *updateLog) int {",
      "content": "func fetchNumUpdates(t updateType, log *updateLog) int {\n\tnum := 0\n\tfor e := log.Front(); e != nil; e = e.Next() {\n\t\thtlc := e.Value.(*PaymentDescriptor)\n\t\tif htlc.EntryType == t {\n\t\t\tnum++\n\t\t}\n\t}\n\treturn num\n}\n\n// assertInLog checks that the given log contains the expected number of Adds\n// and Fails.",
      "length": 235,
      "tokens": 44,
      "embedding": []
    },
    {
      "slug": "func assertInLog(t *testing.T, log *updateLog, numAdds, numFails int) {",
      "content": "func assertInLog(t *testing.T, log *updateLog, numAdds, numFails int) {\n\tadds := fetchNumUpdates(Add, log)\n\tif adds != numAdds {\n\t\tt.Fatalf(\"expected %d adds, found %d\", numAdds, adds)\n\t}\n\tfails := fetchNumUpdates(Fail, log)\n\tif fails != numFails {\n\t\tt.Fatalf(\"expected %d fails, found %d\", numFails, fails)\n\t}\n}\n\n// assertInLogs asserts that the expected number of Adds and Fails occurs in\n// the local and remote update log of the given channel.",
      "length": 364,
      "tokens": 59,
      "embedding": []
    },
    {
      "slug": "func assertInLogs(t *testing.T, channel *LightningChannel, numAddsLocal,",
      "content": "func assertInLogs(t *testing.T, channel *LightningChannel, numAddsLocal,\n\tnumFailsLocal, numAddsRemote, numFailsRemote int) {\n\tassertInLog(t, channel.localUpdateLog, numAddsLocal, numFailsLocal)\n\tassertInLog(t, channel.remoteUpdateLog, numAddsRemote, numFailsRemote)\n}\n\n// restoreAndAssert creates a new LightningChannel from the given channel's\n// state, and asserts that the new channel has had its logs restored to the\n// expected state.",
      "length": 360,
      "tokens": 42,
      "embedding": []
    },
    {
      "slug": "func restoreAndAssert(t *testing.T, channel *LightningChannel, numAddsLocal,",
      "content": "func restoreAndAssert(t *testing.T, channel *LightningChannel, numAddsLocal,\n\tnumFailsLocal, numAddsRemote, numFailsRemote int) {\n\n\tnewChannel, err := NewLightningChannel(\n\t\tchannel.Signer, channel.channelState,\n\t\tchannel.sigPool,\n\t)\n\trequire.NoError(t, err, \"unable to create new channel\")\n\n\tassertInLog(t, newChannel.localUpdateLog, numAddsLocal, numFailsLocal)\n\tassertInLog(t, newChannel.remoteUpdateLog, numAddsRemote, numFailsRemote)\n}\n\n// TestChannelRestoreUpdateLogsFailedHTLC runs through a scenario where an\n// HTLC is added and failed, and asserts along the way that we would restore\n// the update logs of the channel to the expected state at any point.",
      "length": 572,
      "tokens": 66,
      "embedding": []
    },
    {
      "slug": "func TestChannelRestoreUpdateLogsFailedHTLC(t *testing.T) {",
      "content": "func TestChannelRestoreUpdateLogsFailedHTLC(t *testing.T) {\n\tt.Parallel()\n\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// First, we'll add an HTLC from Alice to Bob, and lock it in for both.\n\thtlcAmount := lnwire.NewMSatFromSatoshis(20000)\n\thtlcAlice, _ := createHTLC(0, htlcAmount)\n\tif _, err := aliceChannel.AddHTLC(htlcAlice, nil); err != nil {\n\t\tt.Fatalf(\"alice unable to add htlc: %v\", err)\n\t}\n\t// The htlc Alice sent should be in her local update log.\n\tassertInLogs(t, aliceChannel, 1, 0, 0, 0)\n\n\t// A restore at this point should NOT restore this update, as it is not\n\t// locked in anywhere yet.\n\trestoreAndAssert(t, aliceChannel, 0, 0, 0, 0)\n\n\tif _, err := bobChannel.ReceiveHTLC(htlcAlice); err != nil {\n\t\tt.Fatalf(\"bob unable to recv add htlc: %v\", err)\n\t}\n\n\t// Lock in the Add on both sides.\n\tif err := ForceStateTransition(aliceChannel, bobChannel); err != nil {\n\t\tt.Fatalf(\"unable to complete state update: %v\", err)\n\t}\n\n\t// Since it is locked in, Alice should have the Add in the local log,\n\t// and it should be restored during restoration.\n\tassertInLogs(t, aliceChannel, 1, 0, 0, 0)\n\trestoreAndAssert(t, aliceChannel, 1, 0, 0, 0)\n\n\t// Now we make Bob fail this HTLC.\n\terr = bobChannel.FailHTLC(0, []byte(\"failreason\"), nil, nil, nil)\n\trequire.NoError(t, err, \"unable to cancel HTLC\")\n\n\terr = aliceChannel.ReceiveFailHTLC(0, []byte(\"failreason\"))\n\trequire.NoError(t, err, \"unable to recv htlc cancel\")\n\n\t// This Fail update should have been added to Alice's remote update log.\n\tassertInLogs(t, aliceChannel, 1, 0, 0, 1)\n\n\t// Restoring should restore the HTLC added to Alice's local log, but\n\t// NOT the Fail sent by Bob, since it is not locked in.\n\trestoreAndAssert(t, aliceChannel, 1, 0, 0, 0)\n\n\t// Bob sends a signature.\n\tbobSig, bobHtlcSigs, _, err := bobChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"unable to sign commitment\")\n\terr = aliceChannel.ReceiveNewCommitment(bobSig, bobHtlcSigs)\n\trequire.NoError(t, err, \"unable to receive commitment\")\n\n\t// When Alice receives Bob's new commitment, the logs will stay the\n\t// same until she revokes her old state. The Fail will still not be\n\t// restored during a restoration.\n\tassertInLogs(t, aliceChannel, 1, 0, 0, 1)\n\trestoreAndAssert(t, aliceChannel, 1, 0, 0, 0)\n\n\taliceRevocation, _, _, err := aliceChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"unable to revoke commitment\")\n\t_, _, _, _, err = bobChannel.ReceiveRevocation(aliceRevocation)\n\trequire.NoError(t, err, \"bob unable to process alice's revocation\")\n\n\t// At this point Alice has advanced her local commitment chain to a\n\t// commitment with no HTLCs left. The current state on her remote\n\t// commitment chain, however, still has the HTLC active, as she hasn't\n\t// sent a new signature yet. If we'd now restart and restore, the htlc\n\t// failure update should still be waiting for inclusion in Alice's next\n\t// signature. Otherwise the produced signature would be invalid.\n\tassertInLogs(t, aliceChannel, 1, 0, 0, 1)\n\trestoreAndAssert(t, aliceChannel, 1, 0, 0, 1)\n\n\t// Now send a signature from Alice. This will give Bob a new commitment\n\t// where the HTLC is removed.\n\taliceSig, aliceHtlcSigs, _, err := aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"unable to sign commitment\")\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\trequire.NoError(t, err, \"unable to receive commitment\")\n\n\t// When sending a new commitment, Alice will add a pending commit to\n\t// her remote chain. Since the unsigned acked updates aren't deleted\n\t// until we receive a revocation, the fail should still be present.\n\tassertInLogs(t, aliceChannel, 1, 0, 0, 1)\n\trestoreAndAssert(t, aliceChannel, 1, 0, 0, 1)\n\n\t// When Alice receives Bob's revocation, the Fail is irrevocably locked\n\t// in on both sides. She should compact the logs, removing the HTLC and\n\t// the corresponding Fail from the local update log.\n\tbobRevocation, _, _, err := bobChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"unable to revoke commitment\")\n\t_, _, _, _, err = aliceChannel.ReceiveRevocation(bobRevocation)\n\trequire.NoError(t, err, \"unable to receive revocation\")\n\n\tassertInLogs(t, aliceChannel, 0, 0, 0, 0)\n\trestoreAndAssert(t, aliceChannel, 0, 0, 0, 0)\n}\n\n// TestDuplicateFailRejection tests that if either party attempts to fail an\n// HTLC twice, then we'll reject the second fail attempt.",
      "length": 4287,
      "tokens": 626,
      "embedding": []
    },
    {
      "slug": "func TestDuplicateFailRejection(t *testing.T) {",
      "content": "func TestDuplicateFailRejection(t *testing.T) {\n\tt.Parallel()\n\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// First, we'll add an HTLC from Alice to Bob, and lock it in for both\n\t// parties.\n\thtlcAmount := lnwire.NewMSatFromSatoshis(20000)\n\thtlcAlice, _ := createHTLC(0, htlcAmount)\n\tif _, err := aliceChannel.AddHTLC(htlcAlice, nil); err != nil {\n\t\tt.Fatalf(\"alice unable to add htlc: %v\", err)\n\t}\n\t_, err = bobChannel.ReceiveHTLC(htlcAlice)\n\trequire.NoError(t, err, \"unable to recv htlc\")\n\n\tif err := ForceStateTransition(aliceChannel, bobChannel); err != nil {\n\t\tt.Fatalf(\"unable to complete state update: %v\", err)\n\t}\n\n\t// With the HTLC locked in, we'll now have Bob fail the HTLC back to\n\t// Alice.\n\terr = bobChannel.FailHTLC(0, []byte(\"failreason\"), nil, nil, nil)\n\trequire.NoError(t, err, \"unable to cancel HTLC\")\n\tif err := aliceChannel.ReceiveFailHTLC(0, []byte(\"bad\")); err != nil {\n\t\tt.Fatalf(\"unable to recv htlc cancel: %v\", err)\n\t}\n\n\t// If we attempt to fail it AGAIN, then both sides should reject this\n\t// second failure attempt.\n\terr = bobChannel.FailHTLC(0, []byte(\"failreason\"), nil, nil, nil)\n\tif err == nil {\n\t\tt.Fatalf(\"duplicate HTLC failure attempt should have failed\")\n\t}\n\tif err := aliceChannel.ReceiveFailHTLC(0, []byte(\"bad\")); err == nil {\n\t\tt.Fatalf(\"duplicate HTLC failure attempt should have failed\")\n\t}\n\n\t// We'll now have Bob sign a new commitment to lock in the HTLC fail\n\t// for Alice.\n\t_, _, _, err = bobChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"unable to sign commit\")\n\n\t// We'll now force a restart for Bob and Alice, so we can test the\n\t// persistence related portion of this assertion.\n\tbobChannel, err = restartChannel(bobChannel)\n\trequire.NoError(t, err, \"unable to restart channel\")\n\taliceChannel, err = restartChannel(aliceChannel)\n\trequire.NoError(t, err, \"unable to restart channel\")\n\n\t// If we try to fail the same HTLC again, then we should get an error.\n\terr = bobChannel.FailHTLC(0, []byte(\"failreason\"), nil, nil, nil)\n\tif err == nil {\n\t\tt.Fatalf(\"duplicate HTLC failure attempt should have failed\")\n\t}\n\n\t// Alice on the other hand should accept the failure again, as she\n\t// dropped all items in the logs which weren't committed.\n\tif err := aliceChannel.ReceiveFailHTLC(0, []byte(\"bad\")); err != nil {\n\t\tt.Fatalf(\"unable to recv htlc cancel: %v\", err)\n\t}\n}\n\n// TestDuplicateSettleRejection tests that if either party attempts to settle\n// an HTLC twice, then we'll reject the second settle attempt.",
      "length": 2466,
      "tokens": 359,
      "embedding": []
    },
    {
      "slug": "func TestDuplicateSettleRejection(t *testing.T) {",
      "content": "func TestDuplicateSettleRejection(t *testing.T) {\n\tt.Parallel()\n\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// First, we'll add an HTLC from Alice to Bob, and lock it in for both\n\t// parties.\n\thtlcAmount := lnwire.NewMSatFromSatoshis(20000)\n\thtlcAlice, alicePreimage := createHTLC(0, htlcAmount)\n\tif _, err := aliceChannel.AddHTLC(htlcAlice, nil); err != nil {\n\t\tt.Fatalf(\"alice unable to add htlc: %v\", err)\n\t}\n\t_, err = bobChannel.ReceiveHTLC(htlcAlice)\n\trequire.NoError(t, err, \"unable to recv htlc\")\n\n\tif err := ForceStateTransition(aliceChannel, bobChannel); err != nil {\n\t\tt.Fatalf(\"unable to complete state update: %v\", err)\n\t}\n\n\t// With the HTLC locked in, we'll now have Bob settle the HTLC back to\n\t// Alice.\n\terr = bobChannel.SettleHTLC(alicePreimage, uint64(0), nil, nil, nil)\n\trequire.NoError(t, err, \"unable to cancel HTLC\")\n\terr = aliceChannel.ReceiveHTLCSettle(alicePreimage, uint64(0))\n\trequire.NoError(t, err, \"unable to recv htlc cancel\")\n\n\t// If we attempt to fail it AGAIN, then both sides should reject this\n\t// second failure attempt.\n\terr = bobChannel.SettleHTLC(alicePreimage, uint64(0), nil, nil, nil)\n\tif err == nil {\n\t\tt.Fatalf(\"duplicate HTLC failure attempt should have failed\")\n\t}\n\terr = aliceChannel.ReceiveHTLCSettle(alicePreimage, uint64(0))\n\tif err == nil {\n\t\tt.Fatalf(\"duplicate HTLC failure attempt should have failed\")\n\t}\n\n\t// We'll now have Bob sign a new commitment to lock in the HTLC fail\n\t// for Alice.\n\t_, _, _, err = bobChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"unable to sign commit\")\n\n\t// We'll now force a restart for Bob and Alice, so we can test the\n\t// persistence related portion of this assertion.\n\tbobChannel, err = restartChannel(bobChannel)\n\trequire.NoError(t, err, \"unable to restart channel\")\n\taliceChannel, err = restartChannel(aliceChannel)\n\trequire.NoError(t, err, \"unable to restart channel\")\n\n\t// If we try to fail the same HTLC again, then we should get an error.\n\terr = bobChannel.SettleHTLC(alicePreimage, uint64(0), nil, nil, nil)\n\tif err == nil {\n\t\tt.Fatalf(\"duplicate HTLC failure attempt should have failed\")\n\t}\n\n\t// Alice on the other hand should accept the failure again, as she\n\t// dropped all items in the logs which weren't committed.\n\terr = aliceChannel.ReceiveHTLCSettle(alicePreimage, uint64(0))\n\trequire.NoError(t, err, \"unable to recv htlc cancel\")\n}\n\n// TestChannelRestoreCommitHeight tests that the local and remote commit\n// heights of HTLCs are set correctly across restores.",
      "length": 2474,
      "tokens": 344,
      "embedding": []
    },
    {
      "slug": "func TestChannelRestoreCommitHeight(t *testing.T) {",
      "content": "func TestChannelRestoreCommitHeight(t *testing.T) {\n\tt.Parallel()\n\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// helper method to check add heights of the htlcs found in the given\n\t// log after a restore.\n\trestoreAndAssertCommitHeights := func(t *testing.T,\n\t\tchannel *LightningChannel, remoteLog bool, htlcIndex uint64,\n\t\texpLocal, expRemote uint64) *LightningChannel {\n\n\t\tnewChannel, err := NewLightningChannel(\n\t\t\tchannel.Signer, channel.channelState, channel.sigPool,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to create new channel: %v\", err)\n\t\t}\n\n\t\tvar pd *PaymentDescriptor\n\t\tif remoteLog {\n\t\t\tif newChannel.localUpdateLog.lookupHtlc(htlcIndex) != nil {\n\t\t\t\tt.Fatalf(\"htlc found in wrong log\")\n\t\t\t}\n\t\t\tpd = newChannel.remoteUpdateLog.lookupHtlc(htlcIndex)\n\n\t\t} else {\n\t\t\tif newChannel.remoteUpdateLog.lookupHtlc(htlcIndex) != nil {\n\t\t\t\tt.Fatalf(\"htlc found in wrong log\")\n\t\t\t}\n\t\t\tpd = newChannel.localUpdateLog.lookupHtlc(htlcIndex)\n\t\t}\n\t\tif pd == nil {\n\t\t\tt.Fatalf(\"htlc not found in log\")\n\t\t}\n\n\t\tif pd.addCommitHeightLocal != expLocal {\n\t\t\tt.Fatalf(\"expected local add height to be %d, was %d\",\n\t\t\t\texpLocal, pd.addCommitHeightLocal)\n\t\t}\n\t\tif pd.addCommitHeightRemote != expRemote {\n\t\t\tt.Fatalf(\"expected remote add height to be %d, was %d\",\n\t\t\t\texpRemote, pd.addCommitHeightRemote)\n\t\t}\n\t\treturn newChannel\n\t}\n\n\t// We'll send an HtLC from Alice to Bob.\n\thtlcAmount := lnwire.NewMSatFromSatoshis(100000000)\n\thtlcAlice, _ := createHTLC(0, htlcAmount)\n\tif _, err := aliceChannel.AddHTLC(htlcAlice, nil); err != nil {\n\t\tt.Fatalf(\"alice unable to add htlc: %v\", err)\n\t}\n\tif _, err := bobChannel.ReceiveHTLC(htlcAlice); err != nil {\n\t\tt.Fatalf(\"bob unable to recv add htlc: %v\", err)\n\t}\n\n\t// Let Alice sign a new state, which will include the HTLC just sent.\n\taliceSig, aliceHtlcSigs, _, err := aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"unable to sign commitment\")\n\n\t// The HTLC should only be on the pending remote commitment, so the\n\t// only the remote add height should be set during a restore.\n\taliceChannel = restoreAndAssertCommitHeights(\n\t\tt, aliceChannel, false, 0, 0, 1,\n\t)\n\n\t// Bob receives this commitment signature, and revokes his old state.\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\trequire.NoError(t, err, \"unable to receive commitment\")\n\tbobRevocation, _, _, err := bobChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"unable to revoke commitment\")\n\n\t// Now the HTLC is locked into Bob's commitment, a restoration should\n\t// set only the local commit height, as it is not locked into Alice's\n\t// yet.\n\tbobChannel = restoreAndAssertCommitHeights(t, bobChannel, true, 0, 1, 0)\n\n\t// Alice receives the revocation, ACKing her pending commitment.\n\t_, _, _, _, err = aliceChannel.ReceiveRevocation(bobRevocation)\n\trequire.NoError(t, err, \"unable to receive revocation\")\n\n\t// However, the HTLC is still not locked into her local commitment, so\n\t// the local add height should still be 0 after a restoration.\n\taliceChannel = restoreAndAssertCommitHeights(\n\t\tt, aliceChannel, false, 0, 0, 1,\n\t)\n\n\t// Now let Bob send the commitment signature making the HTLC lock in on\n\t// Alice's commitment.\n\tbobSig, bobHtlcSigs, _, err := bobChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"unable to sign commitment\")\n\n\t// At this stage Bob has a pending remote commitment. Make sure\n\t// restoring at this stage correctly restores the HTLC add commit\n\t// heights.\n\tbobChannel = restoreAndAssertCommitHeights(t, bobChannel, true, 0, 1, 1)\n\n\terr = aliceChannel.ReceiveNewCommitment(bobSig, bobHtlcSigs)\n\trequire.NoError(t, err, \"unable to receive commitment\")\n\taliceRevocation, _, _, err := aliceChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"unable to revoke commitment\")\n\n\t// Now both the local and remote add heights should be properly set.\n\taliceChannel = restoreAndAssertCommitHeights(\n\t\tt, aliceChannel, false, 0, 1, 1,\n\t)\n\n\t_, _, _, _, err = bobChannel.ReceiveRevocation(aliceRevocation)\n\trequire.NoError(t, err, \"unable to receive revocation\")\n\n\t// Alice ACKing Bob's pending commitment shouldn't change the heights\n\t// restored.\n\tbobChannel = restoreAndAssertCommitHeights(t, bobChannel, true, 0, 1, 1)\n\n\t// Send andother HTLC from Alice to Bob, to test whether already\n\t// existing HTLCs (the HTLC with index 0) keep getting the add heights\n\t// restored properly.\n\thtlcAlice, _ = createHTLC(1, htlcAmount)\n\tif _, err := aliceChannel.AddHTLC(htlcAlice, nil); err != nil {\n\t\tt.Fatalf(\"alice unable to add htlc: %v\", err)\n\t}\n\tif _, err := bobChannel.ReceiveHTLC(htlcAlice); err != nil {\n\t\tt.Fatalf(\"bob unable to recv add htlc: %v\", err)\n\t}\n\n\t// Send a new signature from Alice to Bob, making Alice have a pending\n\t// remote commitment.\n\taliceSig, aliceHtlcSigs, _, err = aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"unable to sign commitment\")\n\n\t// A restoration should keep the add heights iof the first HTLC, and\n\t// the new HTLC should have a remote add height 2.\n\taliceChannel = restoreAndAssertCommitHeights(\n\t\tt, aliceChannel, false, 0, 1, 1,\n\t)\n\taliceChannel = restoreAndAssertCommitHeights(\n\t\tt, aliceChannel, false, 1, 0, 2,\n\t)\n\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\trequire.NoError(t, err, \"unable to receive commitment\")\n\tbobRevocation, _, _, err = bobChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"unable to revoke commitment\")\n\n\t// Since Bob just revoked another commitment, a restoration should\n\t// increase the add height of the first HTLC to 2, as we only keep the\n\t// last unrevoked commitment. The new HTLC will also have a local add\n\t// height of 2.\n\tbobChannel = restoreAndAssertCommitHeights(t, bobChannel, true, 0, 2, 1)\n\tbobChannel = restoreAndAssertCommitHeights(t, bobChannel, true, 1, 2, 0)\n\n\t// Alice receives the revocation, ACKing her pending commitment for Bob.\n\t_, _, _, _, err = aliceChannel.ReceiveRevocation(bobRevocation)\n\trequire.NoError(t, err, \"unable to receive revocation\")\n\n\t// Alice receiving Bob's revocation should bump both addCommitHeightRemote\n\t// heights to 2.\n\taliceChannel = restoreAndAssertCommitHeights(\n\t\tt, aliceChannel, false, 0, 1, 2,\n\t)\n\taliceChannel = restoreAndAssertCommitHeights(\n\t\tt, aliceChannel, false, 1, 0, 2,\n\t)\n\n\t// Sign a new state for Alice, making Bob have a pending remote\n\t// commitment.\n\tbobSig, bobHtlcSigs, _, err = bobChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"unable to sign commitment\")\n\n\t// The signing of a new commitment for Alice should have given the new\n\t// HTLC an add height.\n\tbobChannel = restoreAndAssertCommitHeights(t, bobChannel, true, 0, 2, 1)\n\tbobChannel = restoreAndAssertCommitHeights(t, bobChannel, true, 1, 2, 2)\n\n\t// Alice should receive the commitment and send over a revocation.\n\terr = aliceChannel.ReceiveNewCommitment(bobSig, bobHtlcSigs)\n\trequire.NoError(t, err, \"unable to receive commitment\")\n\taliceRevocation, _, _, err = aliceChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"unable to revoke commitment\")\n\n\t// Both heights should be 2 and they are on both commitments.\n\taliceChannel = restoreAndAssertCommitHeights(\n\t\tt, aliceChannel, false, 0, 2, 2,\n\t)\n\taliceChannel = restoreAndAssertCommitHeights(\n\t\tt, aliceChannel, false, 1, 2, 2,\n\t)\n\n\t// Bob receives the revocation, which should set both addCommitHeightRemote\n\t// fields to 2.\n\t_, _, _, _, err = bobChannel.ReceiveRevocation(aliceRevocation)\n\trequire.NoError(t, err, \"unable to receive revocation\")\n\n\tbobChannel = restoreAndAssertCommitHeights(t, bobChannel, true, 0, 2, 2)\n\tbobChannel = restoreAndAssertCommitHeights(t, bobChannel, true, 1, 2, 2)\n\n\t// Bob now fails back the htlc that was just locked in.\n\terr = bobChannel.FailHTLC(0, []byte(\"failreason\"), nil, nil, nil)\n\trequire.NoError(t, err, \"unable to cancel HTLC\")\n\terr = aliceChannel.ReceiveFailHTLC(0, []byte(\"bad\"))\n\trequire.NoError(t, err, \"unable to recv htlc cancel\")\n\n\t// Now Bob signs for the fail update.\n\tbobSig, bobHtlcSigs, _, err = bobChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"unable to sign commitment\")\n\n\t// Bob has a pending commitment for Alice, it shouldn't affect the add\n\t// commit heights though.\n\tbobChannel = restoreAndAssertCommitHeights(t, bobChannel, true, 0, 2, 2)\n\t_ = restoreAndAssertCommitHeights(t, bobChannel, true, 1, 2, 2)\n\n\t// Alice receives commitment, sends revocation.\n\terr = aliceChannel.ReceiveNewCommitment(bobSig, bobHtlcSigs)\n\trequire.NoError(t, err, \"unable to receive commitment\")\n\t_, _, _, err = aliceChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"unable to revoke commitment\")\n\n\taliceChannel = restoreAndAssertCommitHeights(\n\t\tt, aliceChannel, false, 0, 3, 2,\n\t)\n\t_ = restoreAndAssertCommitHeights(t, aliceChannel, false, 1, 3, 2)\n}\n\n// TestForceCloseFailLocalDataLoss tests that we don't allow a force close of a\n// channel that's in a non-default state.",
      "length": 8639,
      "tokens": 1142,
      "embedding": []
    },
    {
      "slug": "func TestForceCloseFailLocalDataLoss(t *testing.T) {",
      "content": "func TestForceCloseFailLocalDataLoss(t *testing.T) {\n\tt.Parallel()\n\n\taliceChannel, _, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// Now that we have our set of channels, we'll modify the channel state\n\t// to have a non-default channel flag.\n\terr = aliceChannel.channelState.ApplyChanStatus(\n\t\tchanneldb.ChanStatusLocalDataLoss,\n\t)\n\trequire.NoError(t, err, \"unable to apply channel state\")\n\n\t// Due to the change above, if we attempt to force close this\n\t// channel, we should fail as it isn't safe to force close a\n\t// channel that isn't in the pure default state.\n\t_, err = aliceChannel.ForceClose()\n\tif err == nil {\n\t\tt.Fatalf(\"expected force close to fail due to non-default \" +\n\t\t\t\"chan state\")\n\t}\n}\n\n// TestForceCloseBorkedState tests that once we force close a channel, it's\n// marked as borked in the database. Additionally, all calls to mutate channel\n// state should also fail.",
      "length": 887,
      "tokens": 136,
      "embedding": []
    },
    {
      "slug": "func TestForceCloseBorkedState(t *testing.T) {",
      "content": "func TestForceCloseBorkedState(t *testing.T) {\n\tt.Parallel()\n\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// Do the commitment dance until Bob sends a revocation so Alice is\n\t// able to receive the revocation, and then also make a new state\n\t// herself.\n\taliceSigs, aliceHtlcSigs, _, err := aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"unable to sign commit\")\n\terr = bobChannel.ReceiveNewCommitment(aliceSigs, aliceHtlcSigs)\n\trequire.NoError(t, err, \"unable to receive commitment\")\n\trevokeMsg, _, _, err := bobChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err, \"unable to revoke bob commitment\")\n\tbobSigs, bobHtlcSigs, _, err := bobChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"unable to sign commit\")\n\terr = aliceChannel.ReceiveNewCommitment(bobSigs, bobHtlcSigs)\n\trequire.NoError(t, err, \"unable to receive commitment\")\n\n\t// Now that we have a new Alice channel, we'll force close once to\n\t// trigger the update on disk to mark the channel as borked.\n\tif _, err := aliceChannel.ForceClose(); err != nil {\n\t\tt.Fatalf(\"unable to force close channel: %v\", err)\n\t}\n\n\t// Next we'll mark the channel as borked before we proceed.\n\terr = aliceChannel.channelState.ApplyChanStatus(\n\t\tchanneldb.ChanStatusBorked,\n\t)\n\trequire.NoError(t, err, \"unable to apply chan status\")\n\n\t// The on-disk state should indicate that the channel is now borked.\n\tif !aliceChannel.channelState.HasChanStatus(\n\t\tchanneldb.ChanStatusBorked,\n\t) {\n\t\tt.Fatalf(\"chan status not updated as borked\")\n\t}\n\n\t// At this point, all channel mutating methods should now fail as they\n\t// shouldn't be able to proceed if the channel is borked.\n\t_, _, _, _, err = aliceChannel.ReceiveRevocation(revokeMsg)\n\tif err != channeldb.ErrChanBorked {\n\t\tt.Fatalf(\"advance commitment tail should have failed\")\n\t}\n\n\t// We manually advance the commitment tail here since the above\n\t// ReceiveRevocation call will fail before it's actually advanced.\n\taliceChannel.remoteCommitChain.advanceTail()\n\t_, _, _, err = aliceChannel.SignNextCommitment()\n\tif err != channeldb.ErrChanBorked {\n\t\tt.Fatalf(\"sign commitment should have failed: %v\", err)\n\t}\n\t_, _, _, err = aliceChannel.RevokeCurrentCommitment()\n\tif err != channeldb.ErrChanBorked {\n\t\tt.Fatalf(\"append remove chain tail should have failed\")\n\t}\n}\n\n// TestChannelMaxFeeRate ensures we correctly compute a channel initiator's max\n// fee rate based on an allocation and its available balance. It should never\n// dip below the established fee floor.",
      "length": 2467,
      "tokens": 325,
      "embedding": []
    },
    {
      "slug": "func TestChannelMaxFeeRate(t *testing.T) {",
      "content": "func TestChannelMaxFeeRate(t *testing.T) {\n\tt.Parallel()\n\n\tassertMaxFeeRate := func(c *LightningChannel, maxAlloc float64,\n\t\texpFeeRate chainfee.SatPerKWeight) {\n\n\t\tmaxFeeRate := c.MaxFeeRate(maxAlloc)\n\t\tif maxFeeRate != expFeeRate {\n\t\t\tt.Fatalf(\"expected max fee rate of %v with max \"+\n\t\t\t\t\"allocation of %v, got %v\", expFeeRate,\n\t\t\t\tmaxAlloc, maxFeeRate)\n\t\t}\n\n\t\tif err := c.validateFeeRate(maxFeeRate); err != nil {\n\t\t\tt.Fatalf(\"fee rate validation failed: %v\", err)\n\t\t}\n\t}\n\n\t// propertyTest tests that the validateFeeRate function always passes\n\t// for the output returned by MaxFeeRate for any valid random inputs\n\t// fed to MaxFeeRate.\n\tpropertyTest := func(c *LightningChannel) func(alloc maxAlloc) bool {\n\t\treturn func(ma maxAlloc) bool {\n\t\t\tmaxFeeRate := c.MaxFeeRate(float64(ma))\n\t\t\treturn c.validateFeeRate(maxFeeRate) == nil\n\t\t}\n\t}\n\n\taliceChannel, _, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\tif err := quick.Check(propertyTest(aliceChannel), nil); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tassertMaxFeeRate(aliceChannel, 1.0, 676794154)\n\tassertMaxFeeRate(aliceChannel, 0.001, 676794)\n\tassertMaxFeeRate(aliceChannel, 0.000001, 676)\n\tassertMaxFeeRate(aliceChannel, 0.0000001, chainfee.FeePerKwFloor)\n\n\t// Check that anchor channels are capped at their max fee rate.\n\tanchorChannel, _, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit|\n\t\t\tchanneldb.AnchorOutputsBit|channeldb.ZeroHtlcTxFeeBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\tif err = quick.Check(propertyTest(anchorChannel), nil); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Anchor commitments are heavier, hence will the same allocation lead\n\t// to slightly lower fee rates.\n\tassertMaxFeeRate(anchorChannel, 1.0, 435941555)\n\tassertMaxFeeRate(anchorChannel, 0.001, 435941)\n\tassertMaxFeeRate(anchorChannel, 0.000001, 435)\n\tassertMaxFeeRate(anchorChannel, 0.0000001, chainfee.FeePerKwFloor)\n}\n\n// TestIdealCommitFeeRate tests that we correctly compute the ideal commitment\n// fee of a channel given the current network fee, minimum relay fee, maximum\n// fee allocation and whether the channel has anchor outputs.",
      "length": 2088,
      "tokens": 240,
      "embedding": []
    },
    {
      "slug": "func TestIdealCommitFeeRate(t *testing.T) {",
      "content": "func TestIdealCommitFeeRate(t *testing.T) {\n\tt.Parallel()\n\n\tassertIdealFeeRate := func(c *LightningChannel, netFee, minRelay,\n\t\tmaxAnchorCommit chainfee.SatPerKWeight,\n\t\tmaxFeeAlloc float64, expectedFeeRate chainfee.SatPerKWeight) {\n\n\t\tfeeRate := c.IdealCommitFeeRate(\n\t\t\tnetFee, minRelay, maxAnchorCommit, maxFeeAlloc,\n\t\t)\n\t\tif feeRate != expectedFeeRate {\n\t\t\tt.Fatalf(\"expected fee rate of %v got %v\",\n\t\t\t\texpectedFeeRate, feeRate)\n\t\t}\n\n\t\tif err := c.validateFeeRate(feeRate); err != nil {\n\t\t\tt.Fatalf(\"fee rate validation failed: %v\", err)\n\t\t}\n\t}\n\n\t// propertyTest tests that the validateFeeRate function always passes\n\t// for the output returned by IdealCommitFeeRate for any valid random\n\t// inputs fed to IdealCommitFeeRate.\n\tpropertyTest := func(c *LightningChannel) func(ma maxAlloc,\n\t\tnetFee, minRelayFee, maxAnchorFee fee) bool {\n\n\t\treturn func(ma maxAlloc, netFee, minRelayFee,\n\t\t\tmaxAnchorFee fee) bool {\n\n\t\t\tidealFeeRate := c.IdealCommitFeeRate(\n\t\t\t\tchainfee.SatPerKWeight(netFee),\n\t\t\t\tchainfee.SatPerKWeight(minRelayFee),\n\t\t\t\tchainfee.SatPerKWeight(maxAnchorFee),\n\t\t\t\tfloat64(ma),\n\t\t\t)\n\n\t\t\treturn c.validateFeeRate(idealFeeRate) == nil\n\t\t}\n\t}\n\n\t// Test ideal fee rates for a non-anchor channel\n\tt.Run(\"non-anchor-channel\", func(t *testing.T) {\n\t\taliceChannel, _, err := CreateTestChannels(\n\t\t\tt, channeldb.SingleFunderTweaklessBit,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to create test channels: %v\", err)\n\t\t}\n\n\t\terr = quick.Check(propertyTest(aliceChannel), nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// If the maximum fee is lower than the network fee and above\n\t\t// the min relay fee, use the maximum fee.\n\t\tassertIdealFeeRate(\n\t\t\taliceChannel, 700000000, 0, 0, 1.0, 676794154,\n\t\t)\n\n\t\t// If the network fee is lower than the max fee and above the\n\t\t// min relay fee, use the network fee.\n\t\tassertIdealFeeRate(\n\t\t\taliceChannel, 500000000, 0, 0, 1.0, 500000000,\n\t\t)\n\n\t\t// If the fee is below the minimum relay fee, and the min relay\n\t\t// fee is less than our max fee, use the minimum relay fee.\n\t\tassertIdealFeeRate(\n\t\t\taliceChannel, 500000000, 600000000, 0, 1.0, 600000000,\n\t\t)\n\n\t\t// The absolute maximum fee rate we can pay (ie, using a max\n\t\t// allocation of 1) is still below the minimum relay fee. In\n\t\t// this case, use the absolute max fee.\n\t\tassertIdealFeeRate(\n\t\t\taliceChannel, 800000000, 700000000, 0, 0.001,\n\t\t\t676794154,\n\t\t)\n\t})\n\n\t// Test ideal fee rates for an anchor channel\n\tt.Run(\"anchor-channel\", func(t *testing.T) {\n\t\tanchorChannel, _, err := CreateTestChannels(\n\t\t\tt, channeldb.SingleFunderTweaklessBit|\n\t\t\t\tchanneldb.AnchorOutputsBit|\n\t\t\t\tchanneldb.ZeroHtlcTxFeeBit,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to create test channels: %v\", err)\n\t\t}\n\n\t\terr = quick.Check(propertyTest(anchorChannel), nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// Anchor commitments are heavier, hence the same allocation\n\t\t// leads to slightly lower fee rates.\n\t\tassertIdealFeeRate(\n\t\t\tanchorChannel, 700000000, 0, chainfee.FeePerKwFloor,\n\t\t\t0.1, chainfee.FeePerKwFloor,\n\t\t)\n\n\t\t// If the maximum fee is lower than the network fee, use the\n\t\t// maximum fee.\n\t\tassertIdealFeeRate(\n\t\t\tanchorChannel, 700000000, 0, 1000000, 0.001, 435941,\n\t\t)\n\n\t\tassertIdealFeeRate(\n\t\t\tanchorChannel, 700000000, 0, 700, 0.000001, 435,\n\t\t)\n\n\t\tassertIdealFeeRate(\n\t\t\tanchorChannel, 700000000, 0, 1000000, 0.0000001,\n\t\t\tchainfee.FeePerKwFloor,\n\t\t)\n\n\t\t// If the maximum anchor commit fee rate is less than the\n\t\t// maximum fee, use the max anchor commit fee since this is an\n\t\t// anchor channel.\n\t\tassertIdealFeeRate(\n\t\t\tanchorChannel, 700000000, 0, 400000, 0.001, 400000,\n\t\t)\n\n\t\t// If the minimum relay fee is above the max anchor commitment\n\t\t// fee rate but still below our max fee rate then use the min\n\t\t// relay fee.\n\t\tassertIdealFeeRate(\n\t\t\tanchorChannel, 700000000, 400000, 300000, 0.001,\n\t\t\t400000,\n\t\t)\n\n\t\t// If the min relay fee is above the ideal max fee rate but is\n\t\t// below the max fee rate when the max fee allocation is set to\n\t\t// 1, the minimum relay fee is used.\n\t\tassertIdealFeeRate(\n\t\t\tanchorChannel, 700000000, 500000, 300000, 0.001,\n\t\t\t500000,\n\t\t)\n\n\t\t// The absolute maximum fee rate we can pay (ie, using a max\n\t\t// allocation of 1) is still below the minimum relay fee. In\n\t\t// this case, use the absolute max fee.\n\t\tassertIdealFeeRate(\n\t\t\tanchorChannel, 700000000, 450000000, 300000, 0.001,\n\t\t\t435941555,\n\t\t)\n\t})\n}\n",
      "length": 4149,
      "tokens": 567,
      "embedding": []
    },
    {
      "slug": "type maxAlloc float64",
      "content": "type maxAlloc float64\n\n// Generate ensures that the random value generated by the testing quick\n// package for maxAlloc is always a positive float64 between 0 and 1.",
      "length": 141,
      "tokens": 25,
      "embedding": []
    },
    {
      "slug": "func (maxAlloc) Generate(r *rand.Rand, _ int) reflect.Value {",
      "content": "func (maxAlloc) Generate(r *rand.Rand, _ int) reflect.Value {\n\tma := maxAlloc(r.Float64())\n\treturn reflect.ValueOf(ma)\n}\n",
      "length": 56,
      "tokens": 6,
      "embedding": []
    },
    {
      "slug": "type fee chainfee.SatPerKWeight",
      "content": "type fee chainfee.SatPerKWeight\n\n// Generate ensures that the random value generated by the testing quick\n// package for a fee is always a positive int64.",
      "length": 120,
      "tokens": 22,
      "embedding": []
    },
    {
      "slug": "func (fee) Generate(r *rand.Rand, _ int) reflect.Value {",
      "content": "func (fee) Generate(r *rand.Rand, _ int) reflect.Value {\n\tam := fee(r.Int63())\n\treturn reflect.ValueOf(am)\n}\n\n// TestChannelFeeRateFloor asserts that valid commitments can be proposed and\n// received using chainfee.FeePerKwFloor as the initiator's fee rate.",
      "length": 195,
      "tokens": 25,
      "embedding": []
    },
    {
      "slug": "func TestChannelFeeRateFloor(t *testing.T) {",
      "content": "func TestChannelFeeRateFloor(t *testing.T) {\n\tt.Parallel()\n\n\talice, bob, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\t// Set the fee rate to the proposing fee rate floor.\n\tminFee := chainfee.FeePerKwFloor\n\n\t// Alice is the initiator, so only she can propose fee updates.\n\tif err := alice.UpdateFee(minFee); err != nil {\n\t\tt.Fatalf(\"unable to send fee update\")\n\t}\n\tif err := bob.ReceiveUpdateFee(minFee); err != nil {\n\t\tt.Fatalf(\"unable to receive fee update\")\n\t}\n\n\t// Check that alice can still sign commitments.\n\tsig, htlcSigs, _, err := alice.SignNextCommitment()\n\trequire.NoError(t, err, \"alice unable to sign commitment\")\n\n\t// Check that bob can still receive commitments.\n\terr = bob.ReceiveNewCommitment(sig, htlcSigs)\n\tif err != nil {\n\t\tt.Fatalf(\"bob unable to process alice's new commitment: %v\",\n\t\t\terr)\n\t}\n}\n\n// TestFetchParent tests lookup of an entry's parent in the appropriate log.",
      "length": 906,
      "tokens": 131,
      "embedding": []
    },
    {
      "slug": "func TestFetchParent(t *testing.T) {",
      "content": "func TestFetchParent(t *testing.T) {\n\ttests := []struct {\n\t\tname          string\n\t\tremoteChain   bool\n\t\tremoteLog     bool\n\t\tlocalEntries  []*PaymentDescriptor\n\t\tremoteEntries []*PaymentDescriptor\n\n\t\t// parentIndex is the parent index of the entry that we will\n\t\t// lookup with fetch parent.\n\t\tparentIndex uint64\n\n\t\t// expectErr indicates that we expect fetch parent to fail.\n\t\texpectErr bool\n\n\t\t// expectedIndex is the htlc index that we expect the parent\n\t\t// to have.\n\t\texpectedIndex uint64\n\t}{\n\t\t{\n\t\t\tname:          \"not found in remote log\",\n\t\t\tlocalEntries:  nil,\n\t\t\tremoteEntries: nil,\n\t\t\tremoteChain:   true,\n\t\t\tremoteLog:     true,\n\t\t\tparentIndex:   0,\n\t\t\texpectErr:     true,\n\t\t},\n\t\t{\n\t\t\tname:          \"not found in local log\",\n\t\t\tlocalEntries:  nil,\n\t\t\tremoteEntries: nil,\n\t\t\tremoteChain:   false,\n\t\t\tremoteLog:     false,\n\t\t\tparentIndex:   0,\n\t\t\texpectErr:     true,\n\t\t},\n\t\t{\n\t\t\tname:         \"remote log + chain, remote add height 0\",\n\t\t\tlocalEntries: nil,\n\t\t\tremoteEntries: []*PaymentDescriptor{\n\t\t\t\t// This entry will be added at log index =0.\n\t\t\t\t{\n\t\t\t\t\tHtlcIndex:             1,\n\t\t\t\t\taddCommitHeightLocal:  100,\n\t\t\t\t\taddCommitHeightRemote: 100,\n\t\t\t\t},\n\t\t\t\t// This entry will be added at log index =1, it\n\t\t\t\t// is the parent entry we are looking for.\n\t\t\t\t{\n\t\t\t\t\tHtlcIndex:             2,\n\t\t\t\t\taddCommitHeightLocal:  100,\n\t\t\t\t\taddCommitHeightRemote: 0,\n\t\t\t\t},\n\t\t\t},\n\t\t\tremoteChain: true,\n\t\t\tremoteLog:   true,\n\t\t\tparentIndex: 1,\n\t\t\texpectErr:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"remote log, local chain, local add height 0\",\n\t\t\tremoteEntries: []*PaymentDescriptor{\n\t\t\t\t// This entry will be added at log index =0.\n\t\t\t\t{\n\t\t\t\t\tHtlcIndex:             1,\n\t\t\t\t\taddCommitHeightLocal:  100,\n\t\t\t\t\taddCommitHeightRemote: 100,\n\t\t\t\t},\n\t\t\t\t// This entry will be added at log index =1, it\n\t\t\t\t// is the parent entry we are looking for.\n\t\t\t\t{\n\t\t\t\t\tHtlcIndex:             2,\n\t\t\t\t\taddCommitHeightLocal:  0,\n\t\t\t\t\taddCommitHeightRemote: 100,\n\t\t\t\t},\n\t\t\t},\n\t\t\tlocalEntries: nil,\n\t\t\tremoteChain:  false,\n\t\t\tremoteLog:    true,\n\t\t\tparentIndex:  1,\n\t\t\texpectErr:    true,\n\t\t},\n\t\t{\n\t\t\tname: \"local log + chain, local add height 0\",\n\t\t\tlocalEntries: []*PaymentDescriptor{\n\t\t\t\t// This entry will be added at log index =0.\n\t\t\t\t{\n\t\t\t\t\tHtlcIndex:             1,\n\t\t\t\t\taddCommitHeightLocal:  100,\n\t\t\t\t\taddCommitHeightRemote: 100,\n\t\t\t\t},\n\t\t\t\t// This entry will be added at log index =1, it\n\t\t\t\t// is the parent entry we are looking for.\n\t\t\t\t{\n\t\t\t\t\tHtlcIndex:             2,\n\t\t\t\t\taddCommitHeightLocal:  0,\n\t\t\t\t\taddCommitHeightRemote: 100,\n\t\t\t\t},\n\t\t\t},\n\t\t\tremoteEntries: nil,\n\t\t\tremoteChain:   false,\n\t\t\tremoteLog:     false,\n\t\t\tparentIndex:   1,\n\t\t\texpectErr:     true,\n\t\t},\n\n\t\t{\n\t\t\tname: \"local log + remote chain, remote add height 0\",\n\t\t\tlocalEntries: []*PaymentDescriptor{\n\t\t\t\t// This entry will be added at log index =0.\n\t\t\t\t{\n\t\t\t\t\tHtlcIndex:             1,\n\t\t\t\t\taddCommitHeightLocal:  100,\n\t\t\t\t\taddCommitHeightRemote: 100,\n\t\t\t\t},\n\t\t\t\t// This entry will be added at log index =1, it\n\t\t\t\t// is the parent entry we are looking for.\n\t\t\t\t{\n\t\t\t\t\tHtlcIndex:             2,\n\t\t\t\t\taddCommitHeightLocal:  100,\n\t\t\t\t\taddCommitHeightRemote: 0,\n\t\t\t\t},\n\t\t\t},\n\t\t\tremoteEntries: nil,\n\t\t\tremoteChain:   true,\n\t\t\tremoteLog:     false,\n\t\t\tparentIndex:   1,\n\t\t\texpectErr:     true,\n\t\t},\n\t\t{\n\t\t\tname:         \"remote log found\",\n\t\t\tlocalEntries: nil,\n\t\t\tremoteEntries: []*PaymentDescriptor{\n\t\t\t\t// This entry will be added at log index =0.\n\t\t\t\t{\n\t\t\t\t\tHtlcIndex:             1,\n\t\t\t\t\taddCommitHeightLocal:  100,\n\t\t\t\t\taddCommitHeightRemote: 0,\n\t\t\t\t},\n\t\t\t\t// This entry will be added at log index =1, it\n\t\t\t\t// is the parent entry we are looking for.\n\t\t\t\t{\n\t\t\t\t\tHtlcIndex:             2,\n\t\t\t\t\taddCommitHeightLocal:  100,\n\t\t\t\t\taddCommitHeightRemote: 100,\n\t\t\t\t},\n\t\t\t},\n\t\t\tremoteChain:   true,\n\t\t\tremoteLog:     true,\n\t\t\tparentIndex:   1,\n\t\t\texpectErr:     false,\n\t\t\texpectedIndex: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"local log found\",\n\t\t\tlocalEntries: []*PaymentDescriptor{\n\t\t\t\t// This entry will be added at log index =0.\n\t\t\t\t{\n\t\t\t\t\tHtlcIndex:             1,\n\t\t\t\t\taddCommitHeightLocal:  0,\n\t\t\t\t\taddCommitHeightRemote: 100,\n\t\t\t\t},\n\t\t\t\t// This entry will be added at log index =1, it\n\t\t\t\t// is the parent entry we are looking for.\n\t\t\t\t{\n\t\t\t\t\tHtlcIndex:             2,\n\t\t\t\t\taddCommitHeightLocal:  100,\n\t\t\t\t\taddCommitHeightRemote: 100,\n\t\t\t\t},\n\t\t\t},\n\t\t\tremoteEntries: nil,\n\t\t\tremoteChain:   false,\n\t\t\tremoteLog:     false,\n\t\t\tparentIndex:   1,\n\t\t\texpectErr:     false,\n\t\t\texpectedIndex: 2,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t// Create a lightning channel with newly initialized\n\t\t\t// local and remote logs.\n\t\t\tlc := LightningChannel{\n\t\t\t\tlocalUpdateLog:  newUpdateLog(0, 0),\n\t\t\t\tremoteUpdateLog: newUpdateLog(0, 0),\n\t\t\t}\n\n\t\t\t// Add the local and remote entries to update logs.\n\t\t\tfor _, entry := range test.localEntries {\n\t\t\t\tlc.localUpdateLog.appendHtlc(entry)\n\t\t\t}\n\t\t\tfor _, entry := range test.remoteEntries {\n\t\t\t\tlc.remoteUpdateLog.appendHtlc(entry)\n\t\t\t}\n\n\t\t\tparent, err := lc.fetchParent(\n\t\t\t\t&PaymentDescriptor{\n\t\t\t\t\tParentIndex: test.parentIndex,\n\t\t\t\t},\n\t\t\t\ttest.remoteChain,\n\t\t\t\ttest.remoteLog,\n\t\t\t)\n\t\t\tgotErr := err != nil\n\t\t\tif test.expectErr != gotErr {\n\t\t\t\tt.Fatalf(\"expected error: %v, got: %v, \"+\n\t\t\t\t\t\"error:%v\", test.expectErr, gotErr, err)\n\t\t\t}\n\n\t\t\t// If our lookup failed, we do not need to check parent\n\t\t\t// index.\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif parent.HtlcIndex != test.expectedIndex {\n\t\t\t\tt.Fatalf(\"expected parent index: %v, got: %v\",\n\t\t\t\t\ttest.parentIndex, parent.HtlcIndex)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestEvaluateView tests the creation of a htlc view and the opt in mutation of\n// send and receive balances. This test does not check htlc mutation on a htlc\n// level.",
      "length": 5428,
      "tokens": 685,
      "embedding": []
    },
    {
      "slug": "func TestEvaluateView(t *testing.T) {",
      "content": "func TestEvaluateView(t *testing.T) {\n\tconst (\n\t\t// addHeight is a non-zero height that is used for htlc adds.\n\t\taddHeight = 200\n\n\t\t// nextHeight is a constant that we use for the next height in\n\t\t// all unit tests.\n\t\tnextHeight = 400\n\n\t\t// feePerKw is the fee we start all of our unit tests with.\n\t\tfeePerKw = 1\n\n\t\t// htlcAddAmount is the amount for htlc adds in tests.\n\t\thtlcAddAmount = 15\n\n\t\t// ourFeeUpdateAmt is an amount that we update fees to\n\t\t// expressed in msat.\n\t\tourFeeUpdateAmt = 20000\n\n\t\t// ourFeeUpdatePerSat is the fee rate *in satoshis* that we\n\t\t// expect if we update to ourFeeUpdateAmt.\n\t\tourFeeUpdatePerSat = chainfee.SatPerKWeight(20)\n\n\t\t// theirFeeUpdateAmt iis an amount that they update fees to\n\t\t// expressed in msat.\n\t\ttheirFeeUpdateAmt = 10000\n\n\t\t// theirFeeUpdatePerSat is the fee rate *in satoshis* that we\n\t\t// expect if we update to ourFeeUpdateAmt.\n\t\ttheirFeeUpdatePerSat = chainfee.SatPerKWeight(10)\n\t)\n\n\ttests := []struct {\n\t\tname        string\n\t\tourHtlcs    []*PaymentDescriptor\n\t\ttheirHtlcs  []*PaymentDescriptor\n\t\tremoteChain bool\n\t\tmutateState bool\n\n\t\t// ourExpectedHtlcs is the set of our htlcs that we expect in\n\t\t// the htlc view once it has been evaluated. We just store\n\t\t// htlc index -> bool for brevity, because we only check the\n\t\t// presence of the htlc in the returned set.\n\t\tourExpectedHtlcs map[uint64]bool\n\n\t\t// theirExpectedHtlcs is the set of their htlcs that we expect\n\t\t// in the htlc view once it has been evaluated. We just store\n\t\t// htlc index -> bool for brevity, because we only check the\n\t\t// presence of the htlc in the returned set.\n\t\ttheirExpectedHtlcs map[uint64]bool\n\n\t\t// expectedFee is the fee we expect to be set after evaluating\n\t\t// the htlc view.\n\t\texpectedFee chainfee.SatPerKWeight\n\n\t\t// expectReceived is the amount we expect the channel to have\n\t\t// tracked as our receive total.\n\t\texpectReceived lnwire.MilliSatoshi\n\n\t\t// expectSent is the amount we expect the channel to have\n\t\t// tracked as our send total.\n\t\texpectSent lnwire.MilliSatoshi\n\t}{\n\t\t{\n\t\t\tname:        \"our fee update is applied\",\n\t\t\tremoteChain: false,\n\t\t\tmutateState: false,\n\t\t\tourHtlcs: []*PaymentDescriptor{\n\t\t\t\t{\n\t\t\t\t\tAmount:    ourFeeUpdateAmt,\n\t\t\t\t\tEntryType: FeeUpdate,\n\t\t\t\t},\n\t\t\t},\n\t\t\ttheirHtlcs:         nil,\n\t\t\texpectedFee:        ourFeeUpdatePerSat,\n\t\t\tourExpectedHtlcs:   nil,\n\t\t\ttheirExpectedHtlcs: nil,\n\t\t\texpectReceived:     0,\n\t\t\texpectSent:         0,\n\t\t},\n\t\t{\n\t\t\tname:        \"their fee update is applied\",\n\t\t\tremoteChain: false,\n\t\t\tmutateState: false,\n\t\t\tourHtlcs:    []*PaymentDescriptor{},\n\t\t\ttheirHtlcs: []*PaymentDescriptor{\n\t\t\t\t{\n\t\t\t\t\tAmount:    theirFeeUpdateAmt,\n\t\t\t\t\tEntryType: FeeUpdate,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedFee:        theirFeeUpdatePerSat,\n\t\t\tourExpectedHtlcs:   nil,\n\t\t\ttheirExpectedHtlcs: nil,\n\t\t\texpectReceived:     0,\n\t\t\texpectSent:         0,\n\t\t},\n\t\t{\n\t\t\t// We expect unresolved htlcs to to remain in the view.\n\t\t\tname:        \"htlcs adds without settles\",\n\t\t\tremoteChain: false,\n\t\t\tmutateState: false,\n\t\t\tourHtlcs: []*PaymentDescriptor{\n\t\t\t\t{\n\t\t\t\t\tHtlcIndex: 0,\n\t\t\t\t\tAmount:    htlcAddAmount,\n\t\t\t\t\tEntryType: Add,\n\t\t\t\t},\n\t\t\t},\n\t\t\ttheirHtlcs: []*PaymentDescriptor{\n\t\t\t\t{\n\t\t\t\t\tHtlcIndex: 0,\n\t\t\t\t\tAmount:    htlcAddAmount,\n\t\t\t\t\tEntryType: Add,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tHtlcIndex: 1,\n\t\t\t\t\tAmount:    htlcAddAmount,\n\t\t\t\t\tEntryType: Add,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedFee: feePerKw,\n\t\t\tourExpectedHtlcs: map[uint64]bool{\n\t\t\t\t0: true,\n\t\t\t},\n\t\t\ttheirExpectedHtlcs: map[uint64]bool{\n\t\t\t\t0: true,\n\t\t\t\t1: true,\n\t\t\t},\n\t\t\texpectReceived: 0,\n\t\t\texpectSent:     0,\n\t\t},\n\t\t{\n\t\t\tname:        \"our htlc settled, state mutated\",\n\t\t\tremoteChain: false,\n\t\t\tmutateState: true,\n\t\t\tourHtlcs: []*PaymentDescriptor{\n\t\t\t\t{\n\t\t\t\t\tHtlcIndex:            0,\n\t\t\t\t\tAmount:               htlcAddAmount,\n\t\t\t\t\tEntryType:            Add,\n\t\t\t\t\taddCommitHeightLocal: addHeight,\n\t\t\t\t},\n\t\t\t},\n\t\t\ttheirHtlcs: []*PaymentDescriptor{\n\t\t\t\t{\n\t\t\t\t\tHtlcIndex: 0,\n\t\t\t\t\tAmount:    htlcAddAmount,\n\t\t\t\t\tEntryType: Add,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tHtlcIndex: 1,\n\t\t\t\t\tAmount:    htlcAddAmount,\n\t\t\t\t\tEntryType: Settle,\n\t\t\t\t\t// Map their htlc settle update to our\n\t\t\t\t\t// htlc add (0).\n\t\t\t\t\tParentIndex: 0,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedFee:      feePerKw,\n\t\t\tourExpectedHtlcs: nil,\n\t\t\ttheirExpectedHtlcs: map[uint64]bool{\n\t\t\t\t0: true,\n\t\t\t},\n\t\t\texpectReceived: 0,\n\t\t\texpectSent:     htlcAddAmount,\n\t\t},\n\t\t{\n\t\t\tname:        \"our htlc settled, state not mutated\",\n\t\t\tremoteChain: false,\n\t\t\tmutateState: false,\n\t\t\tourHtlcs: []*PaymentDescriptor{\n\t\t\t\t{\n\t\t\t\t\tHtlcIndex:            0,\n\t\t\t\t\tAmount:               htlcAddAmount,\n\t\t\t\t\tEntryType:            Add,\n\t\t\t\t\taddCommitHeightLocal: addHeight,\n\t\t\t\t},\n\t\t\t},\n\t\t\ttheirHtlcs: []*PaymentDescriptor{\n\t\t\t\t{\n\t\t\t\t\tHtlcIndex: 0,\n\t\t\t\t\tAmount:    htlcAddAmount,\n\t\t\t\t\tEntryType: Add,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tHtlcIndex: 1,\n\t\t\t\t\tAmount:    htlcAddAmount,\n\t\t\t\t\tEntryType: Settle,\n\t\t\t\t\t// Map their htlc settle update to our\n\t\t\t\t\t// htlc add (0).\n\t\t\t\t\tParentIndex: 0,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedFee:      feePerKw,\n\t\t\tourExpectedHtlcs: nil,\n\t\t\ttheirExpectedHtlcs: map[uint64]bool{\n\t\t\t\t0: true,\n\t\t\t},\n\t\t\texpectReceived: 0,\n\t\t\texpectSent:     0,\n\t\t},\n\t\t{\n\t\t\tname:        \"their htlc settled, state mutated\",\n\t\t\tremoteChain: false,\n\t\t\tmutateState: true,\n\t\t\tourHtlcs: []*PaymentDescriptor{\n\t\t\t\t{\n\t\t\t\t\tHtlcIndex: 0,\n\t\t\t\t\tAmount:    htlcAddAmount,\n\t\t\t\t\tEntryType: Add,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tHtlcIndex: 1,\n\t\t\t\t\tAmount:    htlcAddAmount,\n\t\t\t\t\tEntryType: Settle,\n\t\t\t\t\t// Map our htlc settle update to their\n\t\t\t\t\t// htlc add (1).\n\t\t\t\t\tParentIndex: 1,\n\t\t\t\t},\n\t\t\t},\n\t\t\ttheirHtlcs: []*PaymentDescriptor{\n\t\t\t\t{\n\t\t\t\t\tHtlcIndex:            0,\n\t\t\t\t\tAmount:               htlcAddAmount,\n\t\t\t\t\tEntryType:            Add,\n\t\t\t\t\taddCommitHeightLocal: addHeight,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tHtlcIndex:            1,\n\t\t\t\t\tAmount:               htlcAddAmount,\n\t\t\t\t\tEntryType:            Add,\n\t\t\t\t\taddCommitHeightLocal: addHeight,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedFee: feePerKw,\n\t\t\tourExpectedHtlcs: map[uint64]bool{\n\t\t\t\t0: true,\n\t\t\t},\n\t\t\ttheirExpectedHtlcs: map[uint64]bool{\n\t\t\t\t0: true,\n\t\t\t},\n\t\t\texpectReceived: htlcAddAmount,\n\t\t\texpectSent:     0,\n\t\t},\n\t\t{\n\t\t\tname:        \"their htlc settled, state not mutated\",\n\t\t\tremoteChain: false,\n\t\t\tmutateState: false,\n\t\t\tourHtlcs: []*PaymentDescriptor{\n\t\t\t\t{\n\t\t\t\t\tHtlcIndex: 0,\n\t\t\t\t\tAmount:    htlcAddAmount,\n\t\t\t\t\tEntryType: Add,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tHtlcIndex: 1,\n\t\t\t\t\tAmount:    htlcAddAmount,\n\t\t\t\t\tEntryType: Settle,\n\t\t\t\t\t// Map our htlc settle update to their\n\t\t\t\t\t// htlc add (0).\n\t\t\t\t\tParentIndex: 0,\n\t\t\t\t},\n\t\t\t},\n\t\t\ttheirHtlcs: []*PaymentDescriptor{\n\t\t\t\t{\n\t\t\t\t\tHtlcIndex:            0,\n\t\t\t\t\tAmount:               htlcAddAmount,\n\t\t\t\t\tEntryType:            Add,\n\t\t\t\t\taddCommitHeightLocal: addHeight,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedFee: feePerKw,\n\t\t\tourExpectedHtlcs: map[uint64]bool{\n\t\t\t\t0: true,\n\t\t\t},\n\t\t\ttheirExpectedHtlcs: nil,\n\t\t\texpectReceived:     0,\n\t\t\texpectSent:         0,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tlc := LightningChannel{\n\t\t\t\tchannelState: &channeldb.OpenChannel{\n\t\t\t\t\tTotalMSatSent:     0,\n\t\t\t\t\tTotalMSatReceived: 0,\n\t\t\t\t},\n\n\t\t\t\t// Create update logs for local and remote.\n\t\t\t\tlocalUpdateLog:  newUpdateLog(0, 0),\n\t\t\t\tremoteUpdateLog: newUpdateLog(0, 0),\n\t\t\t}\n\n\t\t\tfor _, htlc := range test.ourHtlcs {\n\t\t\t\tif htlc.EntryType == Add {\n\t\t\t\t\tlc.localUpdateLog.appendHtlc(htlc)\n\t\t\t\t} else {\n\t\t\t\t\tlc.localUpdateLog.appendUpdate(htlc)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor _, htlc := range test.theirHtlcs {\n\t\t\t\tif htlc.EntryType == Add {\n\t\t\t\t\tlc.remoteUpdateLog.appendHtlc(htlc)\n\t\t\t\t} else {\n\t\t\t\t\tlc.remoteUpdateLog.appendUpdate(htlc)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tview := &htlcView{\n\t\t\t\tourUpdates:   test.ourHtlcs,\n\t\t\t\ttheirUpdates: test.theirHtlcs,\n\t\t\t\tfeePerKw:     feePerKw,\n\t\t\t}\n\n\t\t\tvar (\n\t\t\t\t// Create vars to store balance changes. We do\n\t\t\t\t// not check these values in this test because\n\t\t\t\t// balance modification happens on the htlc\n\t\t\t\t// processing level.\n\t\t\t\tourBalance   lnwire.MilliSatoshi\n\t\t\t\ttheirBalance lnwire.MilliSatoshi\n\t\t\t)\n\n\t\t\t// Evaluate the htlc view, mutate as test expects.\n\t\t\tresult, err := lc.evaluateHTLCView(\n\t\t\t\tview, &ourBalance, &theirBalance, nextHeight,\n\t\t\t\ttest.remoteChain, test.mutateState,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t\t}\n\n\t\t\tif result.feePerKw != test.expectedFee {\n\t\t\t\tt.Fatalf(\"expected fee: %v, got: %v\",\n\t\t\t\t\ttest.expectedFee, result.feePerKw)\n\t\t\t}\n\n\t\t\tcheckExpectedHtlcs(\n\t\t\t\tt, result.ourUpdates, test.ourExpectedHtlcs,\n\t\t\t)\n\n\t\t\tcheckExpectedHtlcs(\n\t\t\t\tt, result.theirUpdates, test.theirExpectedHtlcs,\n\t\t\t)\n\n\t\t\tif lc.channelState.TotalMSatSent != test.expectSent {\n\t\t\t\tt.Fatalf(\"expected sent: %v, got: %v\",\n\t\t\t\t\ttest.expectSent,\n\t\t\t\t\tlc.channelState.TotalMSatSent)\n\t\t\t}\n\n\t\t\tif lc.channelState.TotalMSatReceived !=\n\t\t\t\ttest.expectReceived {\n\n\t\t\t\tt.Fatalf(\"expected received: %v, got: %v\",\n\t\t\t\t\ttest.expectReceived,\n\t\t\t\t\tlc.channelState.TotalMSatReceived)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// checkExpectedHtlcs checks that a set of htlcs that we have contains all the\n// htlcs we expect.",
      "length": 8506,
      "tokens": 964,
      "embedding": []
    },
    {
      "slug": "func checkExpectedHtlcs(t *testing.T, actual []*PaymentDescriptor,",
      "content": "func checkExpectedHtlcs(t *testing.T, actual []*PaymentDescriptor,\n\texpected map[uint64]bool) {\n\n\tif len(expected) != len(actual) {\n\t\tt.Fatalf(\"expected: %v htlcs, got: %v\",\n\t\t\tlen(expected), len(actual))\n\t}\n\n\tfor _, htlc := range actual {\n\t\t_, ok := expected[htlc.HtlcIndex]\n\t\tif !ok {\n\t\t\tt.Fatalf(\"htlc with index: %v not \"+\n\t\t\t\t\"expected in set\", htlc.HtlcIndex)\n\t\t}\n\t}\n}\n\n// heights represents the heights on a payment descriptor.",
      "length": 351,
      "tokens": 52,
      "embedding": []
    },
    {
      "slug": "type heights struct {",
      "content": "type heights struct {\n\tlocalAdd     uint64\n\tlocalRemove  uint64\n\tremoteAdd    uint64\n\tremoteRemove uint64\n}\n\n// TestProcessFeeUpdate tests the applying of fee updates and mutation of\n// local and remote add and remove heights on update messages.",
      "length": 216,
      "tokens": 31,
      "embedding": []
    },
    {
      "slug": "func TestProcessFeeUpdate(t *testing.T) {",
      "content": "func TestProcessFeeUpdate(t *testing.T) {\n\tconst (\n\t\t// height is a non-zero height that can be used for htlcs\n\t\t// heights.\n\t\theight = 200\n\n\t\t// nextHeight is a constant that we use for the next height in\n\t\t// all unit tests.\n\t\tnextHeight = 400\n\n\t\t// feePerKw is the fee we start all of our unit tests with.\n\t\tfeePerKw = 1\n\n\t\t// ourFeeUpdateAmt is an amount that we update fees to expressed\n\t\t// in msat.\n\t\tourFeeUpdateAmt = 20000\n\n\t\t// ourFeeUpdatePerSat is the fee rate *in satoshis* that we\n\t\t// expect if we update to ourFeeUpdateAmt.\n\t\tourFeeUpdatePerSat = chainfee.SatPerKWeight(20)\n\t)\n\n\ttests := []struct {\n\t\tname            string\n\t\tstartHeights    heights\n\t\texpectedHeights heights\n\t\tremoteChain     bool\n\t\tmutate          bool\n\t\texpectedFee     chainfee.SatPerKWeight\n\t}{\n\t\t{\n\t\t\t// Looking at local chain, local add is non-zero so\n\t\t\t// the update has been applied already; no fee change.\n\t\t\tname: \"non-zero local height, fee unchanged\",\n\t\t\tstartHeights: heights{\n\t\t\t\tlocalAdd:     height,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteAdd:    0,\n\t\t\t\tremoteRemove: height,\n\t\t\t},\n\t\t\texpectedHeights: heights{\n\t\t\t\tlocalAdd:     height,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteAdd:    0,\n\t\t\t\tremoteRemove: height,\n\t\t\t},\n\t\t\tremoteChain: false,\n\t\t\tmutate:      false,\n\t\t\texpectedFee: feePerKw,\n\t\t},\n\t\t{\n\t\t\t// Looking at local chain, local add is zero so the\n\t\t\t// update has not been applied yet; we expect a fee\n\t\t\t// update.\n\t\t\tname: \"zero local height, fee changed\",\n\t\t\tstartHeights: heights{\n\t\t\t\tlocalAdd:     0,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteAdd:    height,\n\t\t\t\tremoteRemove: 0,\n\t\t\t},\n\t\t\texpectedHeights: heights{\n\t\t\t\tlocalAdd:     0,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteAdd:    height,\n\t\t\t\tremoteRemove: 0,\n\t\t\t},\n\t\t\tremoteChain: false,\n\t\t\tmutate:      false,\n\t\t\texpectedFee: ourFeeUpdatePerSat,\n\t\t},\n\t\t{\n\t\t\t// Looking at remote chain, the remote add height is\n\t\t\t// zero, so the update has not been applied so we expect\n\t\t\t// a fee change.\n\t\t\tname: \"zero remote height, fee changed\",\n\t\t\tstartHeights: heights{\n\t\t\t\tlocalAdd:     height,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteAdd:    0,\n\t\t\t\tremoteRemove: 0,\n\t\t\t},\n\t\t\texpectedHeights: heights{\n\t\t\t\tlocalAdd:     height,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteAdd:    0,\n\t\t\t\tremoteRemove: 0,\n\t\t\t},\n\t\t\tremoteChain: true,\n\t\t\tmutate:      false,\n\t\t\texpectedFee: ourFeeUpdatePerSat,\n\t\t},\n\t\t{\n\t\t\t// Looking at remote chain, the remote add height is\n\t\t\t// non-zero, so the update has been applied so we expect\n\t\t\t// no fee change.\n\t\t\tname: \"non-zero remote height, no fee change\",\n\t\t\tstartHeights: heights{\n\t\t\t\tlocalAdd:     height,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteAdd:    height,\n\t\t\t\tremoteRemove: 0,\n\t\t\t},\n\t\t\texpectedHeights: heights{\n\t\t\t\tlocalAdd:     height,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteAdd:    height,\n\t\t\t\tremoteRemove: 0,\n\t\t\t},\n\t\t\tremoteChain: true,\n\t\t\tmutate:      false,\n\t\t\texpectedFee: feePerKw,\n\t\t},\n\t\t{\n\t\t\t// Local add height is non-zero, so the update has\n\t\t\t// already been applied; we do not expect fee to\n\t\t\t// change or any mutations to be applied.\n\t\t\tname: \"non-zero local height, mutation not applied\",\n\t\t\tstartHeights: heights{\n\t\t\t\tlocalAdd:     height,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteAdd:    0,\n\t\t\t\tremoteRemove: height,\n\t\t\t},\n\t\t\texpectedHeights: heights{\n\t\t\t\tlocalAdd:     height,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteAdd:    0,\n\t\t\t\tremoteRemove: height,\n\t\t\t},\n\t\t\tremoteChain: false,\n\t\t\tmutate:      true,\n\t\t\texpectedFee: feePerKw,\n\t\t},\n\t\t{\n\t\t\t// Local add is zero and we are looking at our local\n\t\t\t// chain, so the update has not been applied yet. We\n\t\t\t// expect the local add and remote heights to be\n\t\t\t// mutated.\n\t\t\tname: \"zero height, fee changed, mutation applied\",\n\t\t\tstartHeights: heights{\n\t\t\t\tlocalAdd:     0,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteAdd:    0,\n\t\t\t\tremoteRemove: 0,\n\t\t\t},\n\t\t\texpectedHeights: heights{\n\t\t\t\tlocalAdd:     nextHeight,\n\t\t\t\tlocalRemove:  nextHeight,\n\t\t\t\tremoteAdd:    0,\n\t\t\t\tremoteRemove: 0,\n\t\t\t},\n\t\t\tremoteChain: false,\n\t\t\tmutate:      true,\n\t\t\texpectedFee: ourFeeUpdatePerSat,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t// Create a fee update with add and remove heights as\n\t\t\t// set in the test.\n\t\t\theights := test.startHeights\n\t\t\tupdate := &PaymentDescriptor{\n\t\t\t\tAmount:                   ourFeeUpdateAmt,\n\t\t\t\taddCommitHeightRemote:    heights.remoteAdd,\n\t\t\t\taddCommitHeightLocal:     heights.localAdd,\n\t\t\t\tremoveCommitHeightRemote: heights.remoteRemove,\n\t\t\t\tremoveCommitHeightLocal:  heights.localRemove,\n\t\t\t\tEntryType:                FeeUpdate,\n\t\t\t}\n\n\t\t\tview := &htlcView{\n\t\t\t\tfeePerKw: chainfee.SatPerKWeight(feePerKw),\n\t\t\t}\n\t\t\tprocessFeeUpdate(\n\t\t\t\tupdate, nextHeight, test.remoteChain,\n\t\t\t\ttest.mutate, view,\n\t\t\t)\n\n\t\t\tif view.feePerKw != test.expectedFee {\n\t\t\t\tt.Fatalf(\"expected fee: %v, got: %v\",\n\t\t\t\t\ttest.expectedFee, feePerKw)\n\t\t\t}\n\n\t\t\tcheckHeights(t, update, test.expectedHeights)\n\t\t})\n\t}\n}\n",
      "length": 4586,
      "tokens": 569,
      "embedding": []
    },
    {
      "slug": "func checkHeights(t *testing.T, update *PaymentDescriptor, expected heights) {",
      "content": "func checkHeights(t *testing.T, update *PaymentDescriptor, expected heights) {\n\tupdateHeights := heights{\n\t\tlocalAdd:     update.addCommitHeightLocal,\n\t\tlocalRemove:  update.removeCommitHeightLocal,\n\t\tremoteAdd:    update.addCommitHeightRemote,\n\t\tremoteRemove: update.removeCommitHeightRemote,\n\t}\n\n\tif !reflect.DeepEqual(updateHeights, expected) {\n\t\tt.Fatalf(\"expected: %v, got: %v\", expected, updateHeights)\n\t}\n}\n\n// TestProcessAddRemoveEntry tests the updating of our and their balances when\n// we process adds, settles and fails. It also tests the mutating of add and\n// remove heights.",
      "length": 496,
      "tokens": 53,
      "embedding": []
    },
    {
      "slug": "func TestProcessAddRemoveEntry(t *testing.T) {",
      "content": "func TestProcessAddRemoveEntry(t *testing.T) {\n\tconst (\n\t\t// addHeight is a non-zero addHeight that is used for htlc\n\t\t// add heights.\n\t\taddHeight = 100\n\n\t\t// removeHeight is a non-zero removeHeight that is used for\n\t\t// htlc remove heights.\n\t\tremoveHeight = 200\n\n\t\t// nextHeight is a constant that we use for the nextHeight in\n\t\t// all unit tests.\n\t\tnextHeight = 400\n\n\t\t// updateAmount is the amount that the update is set to.\n\t\tupdateAmount = lnwire.MilliSatoshi(10)\n\n\t\t// startBalance is a balance we start both sides out with\n\t\t// so that balances can be incremented.\n\t\tstartBalance = lnwire.MilliSatoshi(100)\n\t)\n\n\ttests := []struct {\n\t\tname                 string\n\t\tstartHeights         heights\n\t\tremoteChain          bool\n\t\tisIncoming           bool\n\t\tmutateState          bool\n\t\tourExpectedBalance   lnwire.MilliSatoshi\n\t\ttheirExpectedBalance lnwire.MilliSatoshi\n\t\texpectedHeights      heights\n\t\tupdateType           updateType\n\t}{\n\t\t{\n\t\t\tname: \"add, remote chain, already processed\",\n\t\t\tstartHeights: heights{\n\t\t\t\tlocalAdd:     0,\n\t\t\t\tremoteAdd:    addHeight,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteRemove: 0,\n\t\t\t},\n\t\t\tremoteChain:          true,\n\t\t\tisIncoming:           false,\n\t\t\tmutateState:          false,\n\t\t\tourExpectedBalance:   startBalance,\n\t\t\ttheirExpectedBalance: startBalance,\n\t\t\texpectedHeights: heights{\n\t\t\t\tlocalAdd:     0,\n\t\t\t\tremoteAdd:    addHeight,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteRemove: 0,\n\t\t\t},\n\t\t\tupdateType: Add,\n\t\t},\n\t\t{\n\t\t\tname: \"add, local chain, already processed\",\n\t\t\tstartHeights: heights{\n\t\t\t\tlocalAdd:     addHeight,\n\t\t\t\tremoteAdd:    0,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteRemove: 0,\n\t\t\t},\n\t\t\tremoteChain:          false,\n\t\t\tisIncoming:           false,\n\t\t\tmutateState:          false,\n\t\t\tourExpectedBalance:   startBalance,\n\t\t\ttheirExpectedBalance: startBalance,\n\t\t\texpectedHeights: heights{\n\t\t\t\tlocalAdd:     addHeight,\n\t\t\t\tremoteAdd:    0,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteRemove: 0,\n\t\t\t},\n\t\t\tupdateType: Add,\n\t\t},\n\t\t{\n\t\t\tname: \"incoming add, local chain, not mutated\",\n\t\t\tstartHeights: heights{\n\t\t\t\tlocalAdd:     0,\n\t\t\t\tremoteAdd:    0,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteRemove: 0,\n\t\t\t},\n\t\t\tremoteChain:          false,\n\t\t\tisIncoming:           true,\n\t\t\tmutateState:          false,\n\t\t\tourExpectedBalance:   startBalance,\n\t\t\ttheirExpectedBalance: startBalance - updateAmount,\n\t\t\texpectedHeights: heights{\n\t\t\t\tlocalAdd:     0,\n\t\t\t\tremoteAdd:    0,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteRemove: 0,\n\t\t\t},\n\t\t\tupdateType: Add,\n\t\t},\n\t\t{\n\t\t\tname: \"incoming add, local chain, mutated\",\n\t\t\tstartHeights: heights{\n\t\t\t\tlocalAdd:     0,\n\t\t\t\tremoteAdd:    0,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteRemove: 0,\n\t\t\t},\n\t\t\tremoteChain:          false,\n\t\t\tisIncoming:           true,\n\t\t\tmutateState:          true,\n\t\t\tourExpectedBalance:   startBalance,\n\t\t\ttheirExpectedBalance: startBalance - updateAmount,\n\t\t\texpectedHeights: heights{\n\t\t\t\tlocalAdd:     nextHeight,\n\t\t\t\tremoteAdd:    0,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteRemove: 0,\n\t\t\t},\n\t\t\tupdateType: Add,\n\t\t},\n\n\t\t{\n\t\t\tname: \"outgoing add, remote chain, not mutated\",\n\t\t\tstartHeights: heights{\n\t\t\t\tlocalAdd:     0,\n\t\t\t\tremoteAdd:    0,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteRemove: 0,\n\t\t\t},\n\t\t\tremoteChain:          true,\n\t\t\tisIncoming:           false,\n\t\t\tmutateState:          false,\n\t\t\tourExpectedBalance:   startBalance - updateAmount,\n\t\t\ttheirExpectedBalance: startBalance,\n\t\t\texpectedHeights: heights{\n\t\t\t\tlocalAdd:     0,\n\t\t\t\tremoteAdd:    0,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteRemove: 0,\n\t\t\t},\n\t\t\tupdateType: Add,\n\t\t},\n\t\t{\n\t\t\tname: \"outgoing add, remote chain, mutated\",\n\t\t\tstartHeights: heights{\n\t\t\t\tlocalAdd:     0,\n\t\t\t\tremoteAdd:    0,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteRemove: 0,\n\t\t\t},\n\t\t\tremoteChain:          true,\n\t\t\tisIncoming:           false,\n\t\t\tmutateState:          true,\n\t\t\tourExpectedBalance:   startBalance - updateAmount,\n\t\t\ttheirExpectedBalance: startBalance,\n\t\t\texpectedHeights: heights{\n\t\t\t\tlocalAdd:     0,\n\t\t\t\tremoteAdd:    nextHeight,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteRemove: 0,\n\t\t\t},\n\t\t\tupdateType: Add,\n\t\t},\n\t\t{\n\t\t\tname: \"settle, remote chain, already processed\",\n\t\t\tstartHeights: heights{\n\t\t\t\tlocalAdd:     addHeight,\n\t\t\t\tremoteAdd:    addHeight,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteRemove: removeHeight,\n\t\t\t},\n\t\t\tremoteChain:          true,\n\t\t\tisIncoming:           false,\n\t\t\tmutateState:          false,\n\t\t\tourExpectedBalance:   startBalance,\n\t\t\ttheirExpectedBalance: startBalance,\n\t\t\texpectedHeights: heights{\n\t\t\t\tlocalAdd:     addHeight,\n\t\t\t\tremoteAdd:    addHeight,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteRemove: removeHeight,\n\t\t\t},\n\t\t\tupdateType: Settle,\n\t\t},\n\t\t{\n\t\t\tname: \"settle, local chain, already processed\",\n\t\t\tstartHeights: heights{\n\t\t\t\tlocalAdd:     addHeight,\n\t\t\t\tremoteAdd:    addHeight,\n\t\t\t\tlocalRemove:  removeHeight,\n\t\t\t\tremoteRemove: 0,\n\t\t\t},\n\t\t\tremoteChain:          false,\n\t\t\tisIncoming:           false,\n\t\t\tmutateState:          false,\n\t\t\tourExpectedBalance:   startBalance,\n\t\t\ttheirExpectedBalance: startBalance,\n\t\t\texpectedHeights: heights{\n\t\t\t\tlocalAdd:     addHeight,\n\t\t\t\tremoteAdd:    addHeight,\n\t\t\t\tlocalRemove:  removeHeight,\n\t\t\t\tremoteRemove: 0,\n\t\t\t},\n\t\t\tupdateType: Settle,\n\t\t},\n\t\t{\n\t\t\t// Remote chain, and not processed yet. Incoming settle,\n\t\t\t// so we expect our balance to increase.\n\t\t\tname: \"incoming settle\",\n\t\t\tstartHeights: heights{\n\t\t\t\tlocalAdd:     addHeight,\n\t\t\t\tremoteAdd:    addHeight,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteRemove: 0,\n\t\t\t},\n\t\t\tremoteChain:          true,\n\t\t\tisIncoming:           true,\n\t\t\tmutateState:          false,\n\t\t\tourExpectedBalance:   startBalance + updateAmount,\n\t\t\ttheirExpectedBalance: startBalance,\n\t\t\texpectedHeights: heights{\n\t\t\t\tlocalAdd:     addHeight,\n\t\t\t\tremoteAdd:    addHeight,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteRemove: 0,\n\t\t\t},\n\t\t\tupdateType: Settle,\n\t\t},\n\t\t{\n\t\t\t// Remote chain, and not processed yet. Incoming settle,\n\t\t\t// so we expect our balance to increase.\n\t\t\tname: \"outgoing settle\",\n\t\t\tstartHeights: heights{\n\t\t\t\tlocalAdd:     addHeight,\n\t\t\t\tremoteAdd:    addHeight,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteRemove: 0,\n\t\t\t},\n\t\t\tremoteChain:          true,\n\t\t\tisIncoming:           false,\n\t\t\tmutateState:          false,\n\t\t\tourExpectedBalance:   startBalance,\n\t\t\ttheirExpectedBalance: startBalance + updateAmount,\n\t\t\texpectedHeights: heights{\n\t\t\t\tlocalAdd:     addHeight,\n\t\t\t\tremoteAdd:    addHeight,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteRemove: 0,\n\t\t\t},\n\t\t\tupdateType: Settle,\n\t\t},\n\t\t{\n\t\t\t// Remote chain, and not processed yet. Incoming fail,\n\t\t\t// so we expect their balance to increase.\n\t\t\tname: \"incoming fail\",\n\t\t\tstartHeights: heights{\n\t\t\t\tlocalAdd:     addHeight,\n\t\t\t\tremoteAdd:    addHeight,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteRemove: 0,\n\t\t\t},\n\t\t\tremoteChain:          true,\n\t\t\tisIncoming:           true,\n\t\t\tmutateState:          false,\n\t\t\tourExpectedBalance:   startBalance,\n\t\t\ttheirExpectedBalance: startBalance + updateAmount,\n\t\t\texpectedHeights: heights{\n\t\t\t\tlocalAdd:     addHeight,\n\t\t\t\tremoteAdd:    addHeight,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteRemove: 0,\n\t\t\t},\n\t\t\tupdateType: Fail,\n\t\t},\n\t\t{\n\t\t\t// Remote chain, and not processed yet. Outgoing fail,\n\t\t\t// so we expect our balance to increase.\n\t\t\tname: \"outgoing fail\",\n\t\t\tstartHeights: heights{\n\t\t\t\tlocalAdd:     addHeight,\n\t\t\t\tremoteAdd:    addHeight,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteRemove: 0,\n\t\t\t},\n\t\t\tremoteChain:          true,\n\t\t\tisIncoming:           false,\n\t\t\tmutateState:          false,\n\t\t\tourExpectedBalance:   startBalance + updateAmount,\n\t\t\ttheirExpectedBalance: startBalance,\n\t\t\texpectedHeights: heights{\n\t\t\t\tlocalAdd:     addHeight,\n\t\t\t\tremoteAdd:    addHeight,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteRemove: 0,\n\t\t\t},\n\t\t\tupdateType: Fail,\n\t\t},\n\t\t{\n\t\t\t// Local chain, and not processed yet. Incoming settle,\n\t\t\t// so we expect our balance to increase. Mutate is\n\t\t\t// true, so we expect our remove removeHeight to have\n\t\t\t// changed.\n\t\t\tname: \"fail, our remove height mutated\",\n\t\t\tstartHeights: heights{\n\t\t\t\tlocalAdd:     addHeight,\n\t\t\t\tremoteAdd:    addHeight,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteRemove: 0,\n\t\t\t},\n\t\t\tremoteChain:          false,\n\t\t\tisIncoming:           true,\n\t\t\tmutateState:          true,\n\t\t\tourExpectedBalance:   startBalance + updateAmount,\n\t\t\ttheirExpectedBalance: startBalance,\n\t\t\texpectedHeights: heights{\n\t\t\t\tlocalAdd:     addHeight,\n\t\t\t\tremoteAdd:    addHeight,\n\t\t\t\tlocalRemove:  nextHeight,\n\t\t\t\tremoteRemove: 0,\n\t\t\t},\n\t\t\tupdateType: Settle,\n\t\t},\n\t\t{\n\t\t\t// Remote chain, and not processed yet. Incoming settle,\n\t\t\t// so we expect our balance to increase. Mutate is\n\t\t\t// true, so we expect their remove removeHeight to have\n\t\t\t// changed.\n\t\t\tname: \"fail, their remove height mutated\",\n\t\t\tstartHeights: heights{\n\t\t\t\tlocalAdd:     addHeight,\n\t\t\t\tremoteAdd:    addHeight,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteRemove: 0,\n\t\t\t},\n\t\t\tremoteChain:          true,\n\t\t\tisIncoming:           true,\n\t\t\tmutateState:          true,\n\t\t\tourExpectedBalance:   startBalance + updateAmount,\n\t\t\ttheirExpectedBalance: startBalance,\n\t\t\texpectedHeights: heights{\n\t\t\t\tlocalAdd:     addHeight,\n\t\t\t\tremoteAdd:    addHeight,\n\t\t\t\tlocalRemove:  0,\n\t\t\t\tremoteRemove: nextHeight,\n\t\t\t},\n\t\t\tupdateType: Settle,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\theights := test.startHeights\n\t\t\tupdate := &PaymentDescriptor{\n\t\t\t\tAmount:                   updateAmount,\n\t\t\t\taddCommitHeightLocal:     heights.localAdd,\n\t\t\t\taddCommitHeightRemote:    heights.remoteAdd,\n\t\t\t\tremoveCommitHeightLocal:  heights.localRemove,\n\t\t\t\tremoveCommitHeightRemote: heights.remoteRemove,\n\t\t\t\tEntryType:                test.updateType,\n\t\t\t}\n\n\t\t\tvar (\n\t\t\t\t// Start both parties off with an initial\n\t\t\t\t// balance. Copy by value here so that we do\n\t\t\t\t// not mutate the startBalance constant.\n\t\t\t\tourBalance, theirBalance = startBalance,\n\t\t\t\t\tstartBalance\n\t\t\t)\n\n\t\t\t// Choose the processing function we need based on the\n\t\t\t// update type. Process remove is used for settles,\n\t\t\t// fails and malformed htlcs.\n\t\t\tprocess := processRemoveEntry\n\t\t\tif test.updateType == Add {\n\t\t\t\tprocess = processAddEntry\n\t\t\t}\n\n\t\t\tprocess(\n\t\t\t\tupdate, &ourBalance, &theirBalance, nextHeight,\n\t\t\t\ttest.remoteChain, test.isIncoming,\n\t\t\t\ttest.mutateState,\n\t\t\t)\n\n\t\t\t// Check that balances were updated as expected.\n\t\t\tif ourBalance != test.ourExpectedBalance {\n\t\t\t\tt.Fatalf(\"expected our balance: %v, got: %v\",\n\t\t\t\t\ttest.ourExpectedBalance, ourBalance)\n\t\t\t}\n\n\t\t\tif theirBalance != test.theirExpectedBalance {\n\t\t\t\tt.Fatalf(\"expected their balance: %v, got: %v\",\n\t\t\t\t\ttest.theirExpectedBalance, theirBalance)\n\t\t\t}\n\n\t\t\t// Check that heights on the update are as expected.\n\t\t\tcheckHeights(t, update, test.expectedHeights)\n\t\t})\n\t}\n}\n\n// TestChannelUnsignedAckedFailure tests that unsigned acked updates are\n// properly restored after signing for them and disconnecting.\n//\n// The full state transition of this test is:\n//\n// Alice                   Bob\n//\n//\t-----add----->\n//\t-----sig----->\n//\t<----rev------\n//\t<----sig------\n//\t-----rev----->\n//\t<----fail-----\n//\t<----sig------\n//\t-----rev----->\n//\t-----sig-----X (does not reach Bob! Alice dies!)\n//\n//\t-----sig----->\n//\t<----rev------\n//\t<----add------\n//\t<----sig------\n//\n// The last sig was rejected with the old behavior of deleting unsigned\n// acked updates from the database after signing for them. The current\n// behavior of filtering them for deletion upon receiving a revocation\n// causes Alice to accept the signature as valid.",
      "length": 10791,
      "tokens": 1117,
      "embedding": []
    },
    {
      "slug": "func TestChannelUnsignedAckedFailure(t *testing.T) {",
      "content": "func TestChannelUnsignedAckedFailure(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a test channel so that we can test the buggy behavior.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err)\n\n\t// First we create an HTLC that Alice sends to Bob.\n\thtlc, _ := createHTLC(0, lnwire.MilliSatoshi(500000))\n\n\t// -----add----->\n\t_, err = aliceChannel.AddHTLC(htlc, nil)\n\trequire.NoError(t, err)\n\t_, err = bobChannel.ReceiveHTLC(htlc)\n\trequire.NoError(t, err)\n\n\t// Force a state transition to lock in this add on both commitments.\n\t// -----sig----->\n\t// <----rev------\n\t// <----sig------\n\t// -----rev----->\n\terr = ForceStateTransition(aliceChannel, bobChannel)\n\trequire.NoError(t, err)\n\n\t// Now Bob should fail the htlc back to Alice.\n\t// <----fail-----\n\terr = bobChannel.FailHTLC(0, []byte(\"failreason\"), nil, nil, nil)\n\trequire.NoError(t, err)\n\terr = aliceChannel.ReceiveFailHTLC(0, []byte(\"bad\"))\n\trequire.NoError(t, err)\n\n\t// Bob should send a commitment signature to Alice.\n\t// <----sig------\n\tbobSig, bobHtlcSigs, _, err := bobChannel.SignNextCommitment()\n\trequire.NoError(t, err)\n\terr = aliceChannel.ReceiveNewCommitment(bobSig, bobHtlcSigs)\n\trequire.NoError(t, err)\n\n\t// Alice should reply with a revocation.\n\t// -----rev----->\n\taliceRevocation, _, _, err := aliceChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err)\n\t_, _, _, _, err = bobChannel.ReceiveRevocation(aliceRevocation)\n\trequire.NoError(t, err)\n\n\t// Alice should sign the next commitment and go down before\n\t// sending it.\n\t// -----sig-----X\n\taliceSig, aliceHtlcSigs, _, err := aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err)\n\n\tnewAliceChannel, err := NewLightningChannel(\n\t\taliceChannel.Signer, aliceChannel.channelState,\n\t\taliceChannel.sigPool,\n\t)\n\trequire.NoError(t, err)\n\n\t// Bob receives Alice's signature.\n\t// -----sig----->\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\trequire.NoError(t, err)\n\n\t// Bob revokes his current commitment and sends a revocation\n\t// to Alice.\n\t// <----rev------\n\tbobRevocation, _, _, err := bobChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err)\n\t_, _, _, _, err = newAliceChannel.ReceiveRevocation(bobRevocation)\n\trequire.NoError(t, err)\n\n\t// Now Bob sends an HTLC to Alice.\n\thtlc2, _ := createHTLC(0, lnwire.MilliSatoshi(500000))\n\n\t// <----add------\n\t_, err = bobChannel.AddHTLC(htlc2, nil)\n\trequire.NoError(t, err)\n\t_, err = newAliceChannel.ReceiveHTLC(htlc2)\n\trequire.NoError(t, err)\n\n\t// Bob sends the final signature to Alice and Alice should not\n\t// reject it, given that we properly restore the unsigned acked\n\t// updates and therefore our update log is structured correctly.\n\tbobSig, bobHtlcSigs, _, err = bobChannel.SignNextCommitment()\n\trequire.NoError(t, err)\n\terr = newAliceChannel.ReceiveNewCommitment(bobSig, bobHtlcSigs)\n\trequire.NoError(t, err)\n}\n\n// TestChannelLocalUnsignedUpdatesFailure checks that updates from the local\n// log are restored if the remote hasn't sent us a signature covering them.\n//\n// The full state transition is:\n//\n// Alice                Bob\n//\n//\t<----add-----\n//\t<----sig-----\n//\t-----rev---->\n//\t-----sig---->\n//\t<----rev-----\n//\t----fail---->\n//\t-----sig---->\n//\t<----rev-----\n//\t *reconnect*\n//\t<----sig-----\n//\n// Alice should reject the last signature since the settle is not restored\n// into the local update log and thus calculates Bob's signature as invalid.",
      "length": 3255,
      "tokens": 396,
      "embedding": []
    },
    {
      "slug": "func TestChannelLocalUnsignedUpdatesFailure(t *testing.T) {",
      "content": "func TestChannelLocalUnsignedUpdatesFailure(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a test channel so that we can test the buggy behavior.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err)\n\n\t// First we create an htlc that Bob sends to Alice.\n\thtlc, _ := createHTLC(0, lnwire.MilliSatoshi(500000))\n\n\t// <----add-----\n\t_, err = bobChannel.AddHTLC(htlc, nil)\n\trequire.NoError(t, err)\n\t_, err = aliceChannel.ReceiveHTLC(htlc)\n\trequire.NoError(t, err)\n\n\t// Force a state transition to lock in this add on both commitments.\n\t// <----sig-----\n\t// -----rev---->\n\t// -----sig---->\n\t// <----rev-----\n\terr = ForceStateTransition(bobChannel, aliceChannel)\n\trequire.NoError(t, err)\n\n\t// Now Alice should fail the htlc back to Bob.\n\t// -----fail--->\n\terr = aliceChannel.FailHTLC(0, []byte(\"failreason\"), nil, nil, nil)\n\trequire.NoError(t, err)\n\terr = bobChannel.ReceiveFailHTLC(0, []byte(\"bad\"))\n\trequire.NoError(t, err)\n\n\t// Alice should send a commitment signature to Bob.\n\t// -----sig---->\n\taliceSig, aliceHtlcSigs, _, err := aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err)\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\trequire.NoError(t, err)\n\n\t// Bob should reply with a revocation and Alice should save the fail as\n\t// an unsigned local update.\n\t// <----rev-----\n\tbobRevocation, _, _, err := bobChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err)\n\t_, _, _, _, err = aliceChannel.ReceiveRevocation(bobRevocation)\n\trequire.NoError(t, err)\n\n\t// Restart Alice and assert that she can receive Bob's next commitment\n\t// signature.\n\t// *reconnect*\n\tnewAliceChannel, err := NewLightningChannel(\n\t\taliceChannel.Signer, aliceChannel.channelState,\n\t\taliceChannel.sigPool,\n\t)\n\trequire.NoError(t, err)\n\n\t// Bob sends the final signature and Alice should not reject it.\n\t// <----sig-----\n\tbobSig, bobHtlcSigs, _, err := bobChannel.SignNextCommitment()\n\trequire.NoError(t, err)\n\terr = newAliceChannel.ReceiveNewCommitment(bobSig, bobHtlcSigs)\n\trequire.NoError(t, err)\n}\n\n// TestChannelSignedAckRegression tests a previously-regressing state\n// transition no longer causes channel desynchronization.\n//\n// The full state transition of this test is:\n//\n// Alice                   Bob\n//\n//\t<----add-------\n//\t<----sig-------\n//\t-----rev------>\n//\t-----sig------>\n//\t<----rev-------\n//\t----settle---->\n//\t-----sig------>\n//\t<----rev-------\n//\t<----sig-------\n//\t-----add------>\n//\t-----sig------>\n//\t<----rev-------\n//\t                *restarts*\n//\t-----rev------>\n//\t<----sig-------",
      "length": 2425,
      "tokens": 285,
      "embedding": []
    },
    {
      "slug": "func TestChannelSignedAckRegression(t *testing.T) {",
      "content": "func TestChannelSignedAckRegression(t *testing.T) {\n\tt.Parallel()\n\n\t// Create test channels to test out this state transition.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err)\n\n\t// Create an HTLC that Bob will send to Alice.\n\thtlc, preimage := createHTLC(0, lnwire.MilliSatoshi(5000000))\n\n\t// <----add------\n\t_, err = bobChannel.AddHTLC(htlc, nil)\n\trequire.NoError(t, err)\n\t_, err = aliceChannel.ReceiveHTLC(htlc)\n\trequire.NoError(t, err)\n\n\t// Force a state transition to lock in the HTLC.\n\t// <----sig------\n\t// -----rev----->\n\t// -----sig----->\n\t// <----rev------\n\terr = ForceStateTransition(bobChannel, aliceChannel)\n\trequire.NoError(t, err)\n\n\t// Alice settles the HTLC back to Bob.\n\t// ----settle--->\n\terr = aliceChannel.SettleHTLC(preimage, uint64(0), nil, nil, nil)\n\trequire.NoError(t, err)\n\terr = bobChannel.ReceiveHTLCSettle(preimage, uint64(0))\n\trequire.NoError(t, err)\n\n\t// -----sig---->\n\taliceSig, aliceHtlcSigs, _, err := aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err)\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\trequire.NoError(t, err)\n\n\t// <----rev-----\n\tbobRevocation, _, _, err := bobChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err)\n\t_, _, _, _, err = aliceChannel.ReceiveRevocation(bobRevocation)\n\trequire.NoError(t, err)\n\n\t// <----sig-----\n\tbobSig, bobHtlcSigs, _, err := bobChannel.SignNextCommitment()\n\trequire.NoError(t, err)\n\terr = aliceChannel.ReceiveNewCommitment(bobSig, bobHtlcSigs)\n\trequire.NoError(t, err)\n\n\t// Create an HTLC that Alice will send to Bob.\n\thtlc2, _ := createHTLC(0, lnwire.MilliSatoshi(5000000))\n\n\t// -----add---->\n\t_, err = aliceChannel.AddHTLC(htlc2, nil)\n\trequire.NoError(t, err)\n\t_, err = bobChannel.ReceiveHTLC(htlc2)\n\trequire.NoError(t, err)\n\n\t// -----sig---->\n\taliceSig, aliceHtlcSigs, _, err = aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err)\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\trequire.NoError(t, err)\n\n\t// <----rev-----\n\tbobRevocation, _, _, err = bobChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err)\n\t_, _, _, _, err = aliceChannel.ReceiveRevocation(bobRevocation)\n\trequire.NoError(t, err)\n\n\t// Restart Bob's channel state here.\n\tnewBobChannel, err := NewLightningChannel(\n\t\tbobChannel.Signer, bobChannel.channelState,\n\t\tbobChannel.sigPool,\n\t)\n\trequire.NoError(t, err)\n\n\t// -----rev---->\n\taliceRevocation, _, _, err := aliceChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err)\n\tfwdPkg, _, _, _, err := newBobChannel.ReceiveRevocation(aliceRevocation)\n\trequire.NoError(t, err)\n\n\t// Assert that the fwdpkg is not empty.\n\trequire.Equal(t, len(fwdPkg.SettleFails), 1)\n\n\t// Bob should no longer fail to sign this commitment due to faulty\n\t// update logs.\n\t// <----sig-----\n\tbobSig, bobHtlcSigs, _, err = newBobChannel.SignNextCommitment()\n\trequire.NoError(t, err)\n\n\t// Alice should receive the new commitment without hiccups.\n\terr = aliceChannel.ReceiveNewCommitment(bobSig, bobHtlcSigs)\n\trequire.NoError(t, err)\n}\n\n// TestMayAddOutgoingHtlc tests MayAddOutgoingHtlc against zero and non-zero\n// htlc amounts.",
      "length": 2979,
      "tokens": 315,
      "embedding": []
    },
    {
      "slug": "func TestMayAddOutgoingHtlc(t *testing.T) {",
      "content": "func TestMayAddOutgoingHtlc(t *testing.T) {\n\tt.Parallel()\n\n\t// The default channel created as a part of the test fixture already\n\t// has a MinHTLC value of zero, so we don't need to do anything here\n\t// other than create it.\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.SingleFunderTweaklessBit,\n\t)\n\trequire.NoError(t, err)\n\n\t// The channels start out with a 50/50 balance, so both sides should be\n\t// able to add an outgoing HTLC with no specific amount added.\n\trequire.NoError(t, aliceChannel.MayAddOutgoingHtlc(0))\n\trequire.NoError(t, bobChannel.MayAddOutgoingHtlc(0))\n\n\tchanBal, err := btcutil.NewAmount(testChannelCapacity)\n\trequire.NoError(t, err)\n\n\t// Each side should be able to add 1/4 of total channel balance since\n\t// we're 50/50 split.\n\tmayAdd := lnwire.MilliSatoshi(chanBal / 4 * 1000)\n\trequire.NoError(t, aliceChannel.MayAddOutgoingHtlc(mayAdd))\n\trequire.NoError(t, bobChannel.MayAddOutgoingHtlc(mayAdd))\n\n\t// Both channels should fail if we try to add an amount more than\n\t// their current balance.\n\tmayNotAdd := lnwire.MilliSatoshi(chanBal * 1000)\n\trequire.Error(t, aliceChannel.MayAddOutgoingHtlc(mayNotAdd))\n\trequire.Error(t, bobChannel.MayAddOutgoingHtlc(mayNotAdd))\n\n\t// Hard set alice's min htlc to zero and test the case where we just\n\t// fall back to a non-zero value.\n\taliceChannel.channelState.LocalChanCfg.MinHTLC = 0\n\trequire.NoError(t, aliceChannel.MayAddOutgoingHtlc(0))\n}\n\n// TestIsChannelClean tests that IsChannelClean returns the expected values\n// in different channel states.",
      "length": 1454,
      "tokens": 178,
      "embedding": []
    },
    {
      "slug": "func TestIsChannelClean(t *testing.T) {",
      "content": "func TestIsChannelClean(t *testing.T) {\n\tt.Parallel()\n\n\taliceChannel, bobChannel, err := CreateTestChannels(\n\t\tt, channeldb.ZeroHtlcTxFeeBit,\n\t)\n\trequire.NoError(t, err)\n\n\t// Channel state should be clean at the start of the test.\n\tassertCleanOrDirty(true, aliceChannel, bobChannel, t)\n\n\t// Assert that neither side considers the channel clean when alice\n\t// sends an htlc.\n\t// ---add--->\n\thtlc, preimage := createHTLC(0, lnwire.MilliSatoshi(5000000))\n\t_, err = aliceChannel.AddHTLC(htlc, nil)\n\trequire.NoError(t, err)\n\t_, err = bobChannel.ReceiveHTLC(htlc)\n\trequire.NoError(t, err)\n\tassertCleanOrDirty(false, aliceChannel, bobChannel, t)\n\n\t// Assert that the channel remains dirty until the HTLC is completely\n\t// removed from both commitments.\n\n\t// ---sig--->\n\taliceSig, aliceHtlcSigs, _, err := aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err)\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\trequire.NoError(t, err)\n\tassertCleanOrDirty(false, aliceChannel, bobChannel, t)\n\n\t// <---rev---\n\tbobRevocation, _, _, err := bobChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err)\n\t_, _, _, _, err = aliceChannel.ReceiveRevocation(bobRevocation)\n\trequire.NoError(t, err)\n\tassertCleanOrDirty(false, aliceChannel, bobChannel, t)\n\n\t// <---sig---\n\tbobSig, bobHtlcSigs, _, err := bobChannel.SignNextCommitment()\n\trequire.NoError(t, err)\n\terr = aliceChannel.ReceiveNewCommitment(bobSig, bobHtlcSigs)\n\trequire.NoError(t, err)\n\tassertCleanOrDirty(false, aliceChannel, bobChannel, t)\n\n\t// ---rev--->\n\taliceRevocation, _, _, err := aliceChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err)\n\t_, _, _, _, err = bobChannel.ReceiveRevocation(aliceRevocation)\n\trequire.NoError(t, err)\n\tassertCleanOrDirty(false, aliceChannel, bobChannel, t)\n\n\t// <--settle--\n\terr = bobChannel.SettleHTLC(preimage, 0, nil, nil, nil)\n\trequire.NoError(t, err)\n\terr = aliceChannel.ReceiveHTLCSettle(preimage, 0)\n\trequire.NoError(t, err)\n\tassertCleanOrDirty(false, aliceChannel, bobChannel, t)\n\n\t// <---sig---\n\tbobSig, bobHtlcSigs, _, err = bobChannel.SignNextCommitment()\n\trequire.NoError(t, err)\n\terr = aliceChannel.ReceiveNewCommitment(bobSig, bobHtlcSigs)\n\trequire.NoError(t, err)\n\tassertCleanOrDirty(false, aliceChannel, bobChannel, t)\n\n\t// ---rev--->\n\taliceRevocation, _, _, err = aliceChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err)\n\t_, _, _, _, err = bobChannel.ReceiveRevocation(aliceRevocation)\n\trequire.NoError(t, err)\n\tassertCleanOrDirty(false, aliceChannel, bobChannel, t)\n\n\t// ---sig--->\n\taliceSig, aliceHtlcSigs, _, err = aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err)\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\trequire.NoError(t, err)\n\tassertCleanOrDirty(false, aliceChannel, bobChannel, t)\n\n\t// <---rev---\n\tbobRevocation, _, _, err = bobChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err)\n\t_, _, _, _, err = aliceChannel.ReceiveRevocation(bobRevocation)\n\trequire.NoError(t, err)\n\tassertCleanOrDirty(true, aliceChannel, bobChannel, t)\n\n\t// Now we check that update_fee is handled and state is dirty until it\n\t// is completely locked in.\n\t// ---fee--->\n\tfee := chainfee.SatPerKWeight(333)\n\terr = aliceChannel.UpdateFee(fee)\n\trequire.NoError(t, err)\n\terr = bobChannel.ReceiveUpdateFee(fee)\n\trequire.NoError(t, err)\n\tassertCleanOrDirty(false, aliceChannel, bobChannel, t)\n\n\t// ---sig--->\n\taliceSig, aliceHtlcSigs, _, err = aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err)\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\trequire.NoError(t, err)\n\tassertCleanOrDirty(false, aliceChannel, bobChannel, t)\n\n\t// <---rev---\n\tbobRevocation, _, _, err = bobChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err)\n\t_, _, _, _, err = aliceChannel.ReceiveRevocation(bobRevocation)\n\trequire.NoError(t, err)\n\tassertCleanOrDirty(false, aliceChannel, bobChannel, t)\n\n\t// <---sig---\n\tbobSig, bobHtlcSigs, _, err = bobChannel.SignNextCommitment()\n\trequire.NoError(t, err)\n\terr = aliceChannel.ReceiveNewCommitment(bobSig, bobHtlcSigs)\n\trequire.NoError(t, err)\n\tassertCleanOrDirty(false, aliceChannel, bobChannel, t)\n\n\t// The state should finally be clean after alice sends her revocation.\n\t// ---rev--->\n\taliceRevocation, _, _, err = aliceChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err)\n\t_, _, _, _, err = bobChannel.ReceiveRevocation(aliceRevocation)\n\trequire.NoError(t, err)\n\tassertCleanOrDirty(true, aliceChannel, bobChannel, t)\n}\n\n// assertCleanOrDirty is a helper function that asserts that both channels are\n// clean if clean is true, and dirty if clean is false.",
      "length": 4385,
      "tokens": 437,
      "embedding": []
    },
    {
      "slug": "func assertCleanOrDirty(clean bool, alice, bob *LightningChannel,",
      "content": "func assertCleanOrDirty(clean bool, alice, bob *LightningChannel,\n\tt *testing.T) {\n\n\tt.Helper()\n\n\tif clean {\n\t\trequire.True(t, alice.IsChannelClean())\n\t\trequire.True(t, bob.IsChannelClean())\n\t\treturn\n\t}\n\n\trequire.False(t, alice.IsChannelClean())\n\trequire.False(t, bob.IsChannelClean())\n}\n\n// TestChannelGetDustSum tests that we correctly calculate the channel's dust\n// sum for the local and remote commitments.",
      "length": 330,
      "tokens": 36,
      "embedding": []
    },
    {
      "slug": "func TestChannelGetDustSum(t *testing.T) {",
      "content": "func TestChannelGetDustSum(t *testing.T) {\n\tt.Run(\"dust sum tweakless\", func(t *testing.T) {\n\t\ttestGetDustSum(t, channeldb.SingleFunderTweaklessBit)\n\t})\n\tt.Run(\"dust sum anchors zero htlc fee\", func(t *testing.T) {\n\t\ttestGetDustSum(t, channeldb.SingleFunderTweaklessBit|\n\t\t\tchanneldb.AnchorOutputsBit|\n\t\t\tchanneldb.ZeroHtlcTxFeeBit,\n\t\t)\n\t})\n}\n",
      "length": 290,
      "tokens": 25,
      "embedding": []
    },
    {
      "slug": "func testGetDustSum(t *testing.T, chantype channeldb.ChannelType) {",
      "content": "func testGetDustSum(t *testing.T, chantype channeldb.ChannelType) {\n\tt.Parallel()\n\n\t// This makes a channel with Alice's dust limit set to 200sats and\n\t// Bob's dust limit set to 1300sats.\n\taliceChannel, bobChannel, err := CreateTestChannels(t, chantype)\n\trequire.NoError(t, err)\n\n\t// Use a function closure to assert the dust sum for a passed channel's\n\t// local and remote commitments match the expected values.\n\tcheckDust := func(c *LightningChannel, expLocal,\n\t\texpRemote lnwire.MilliSatoshi) {\n\n\t\tlocalDustSum := c.GetDustSum(false)\n\t\trequire.Equal(t, expLocal, localDustSum)\n\t\tremoteDustSum := c.GetDustSum(true)\n\t\trequire.Equal(t, expRemote, remoteDustSum)\n\t}\n\n\t// We'll lower the fee from 6000sats/kWU to 253sats/kWU for our test.\n\tfee := chainfee.SatPerKWeight(253)\n\terr = aliceChannel.UpdateFee(fee)\n\trequire.NoError(t, err)\n\terr = bobChannel.ReceiveUpdateFee(fee)\n\trequire.NoError(t, err)\n\terr = ForceStateTransition(aliceChannel, bobChannel)\n\trequire.NoError(t, err)\n\n\t// Create an HTLC that Bob will send to Alice which is above Alice's\n\t// dust limit and below Bob's dust limit. This takes into account dust\n\t// trimming for non-zero-fee channels.\n\thtlc1Amt := lnwire.MilliSatoshi(700_000)\n\thtlc1, preimage1 := createHTLC(0, htlc1Amt)\n\n\t_, err = bobChannel.AddHTLC(htlc1, nil)\n\trequire.NoError(t, err)\n\t_, err = aliceChannel.ReceiveHTLC(htlc1)\n\trequire.NoError(t, err)\n\n\t// Assert that GetDustSum from Alice's perspective does not consider\n\t// the HTLC dust on her commitment, but does on Bob's commitment.\n\tcheckDust(aliceChannel, lnwire.MilliSatoshi(0), htlc1Amt)\n\n\t// Assert that GetDustSum from Bob's perspective results in the same\n\t// conditions above holding.\n\tcheckDust(bobChannel, htlc1Amt, lnwire.MilliSatoshi(0))\n\n\t// Forcing a state transition to occur should not change the dust sum.\n\terr = ForceStateTransition(bobChannel, aliceChannel)\n\trequire.NoError(t, err)\n\tcheckDust(aliceChannel, lnwire.MilliSatoshi(0), htlc1Amt)\n\tcheckDust(bobChannel, htlc1Amt, lnwire.MilliSatoshi(0))\n\n\t// Settling the HTLC back from Alice to Bob should not change the dust\n\t// sum because the HTLC is counted until it's removed from the update\n\t// logs via compactLogs.\n\terr = aliceChannel.SettleHTLC(preimage1, uint64(0), nil, nil, nil)\n\trequire.NoError(t, err)\n\terr = bobChannel.ReceiveHTLCSettle(preimage1, uint64(0))\n\trequire.NoError(t, err)\n\tcheckDust(aliceChannel, lnwire.MilliSatoshi(0), htlc1Amt)\n\tcheckDust(bobChannel, htlc1Amt, lnwire.MilliSatoshi(0))\n\n\t// Forcing a state transition will remove the HTLC in-memory for Bob\n\t// since ReceiveRevocation is called which calls compactLogs. Bob\n\t// should have a zero dust sum at this point. Alice will see Bob as\n\t// having the original dust sum since compactLogs hasn't been called.\n\terr = ForceStateTransition(aliceChannel, bobChannel)\n\trequire.NoError(t, err)\n\tcheckDust(aliceChannel, lnwire.MilliSatoshi(0), htlc1Amt)\n\tcheckDust(bobChannel, lnwire.MilliSatoshi(0), lnwire.MilliSatoshi(0))\n\n\t// Alice now sends an HTLC of 100sats, which is below both sides' dust\n\t// limits.\n\thtlc2Amt := lnwire.MilliSatoshi(100_000)\n\thtlc2, _ := createHTLC(0, htlc2Amt)\n\n\t_, err = aliceChannel.AddHTLC(htlc2, nil)\n\trequire.NoError(t, err)\n\t_, err = bobChannel.ReceiveHTLC(htlc2)\n\trequire.NoError(t, err)\n\n\t// Assert that GetDustSum from Alice's perspective includes the new\n\t// HTLC as dust on both commitments.\n\tcheckDust(aliceChannel, htlc2Amt, htlc1Amt+htlc2Amt)\n\n\t// Assert that GetDustSum from Bob's perspective also includes the HTLC\n\t// on both commitments.\n\tcheckDust(bobChannel, htlc2Amt, htlc2Amt)\n\n\t// Alice signs for this HTLC and neither perspective should change.\n\taliceSig, aliceHtlcSigs, _, err := aliceChannel.SignNextCommitment()\n\trequire.NoError(t, err)\n\terr = bobChannel.ReceiveNewCommitment(aliceSig, aliceHtlcSigs)\n\trequire.NoError(t, err)\n\tcheckDust(aliceChannel, htlc2Amt, htlc1Amt+htlc2Amt)\n\tcheckDust(bobChannel, htlc2Amt, htlc2Amt)\n\n\t// Bob now sends a revocation for his prior commitment, and this should\n\t// change Alice's perspective to no longer include the first HTLC as\n\t// dust.\n\tbobRevocation, _, _, err := bobChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err)\n\t_, _, _, _, err = aliceChannel.ReceiveRevocation(bobRevocation)\n\trequire.NoError(t, err)\n\tcheckDust(aliceChannel, htlc2Amt, htlc2Amt)\n\tcheckDust(bobChannel, htlc2Amt, htlc2Amt)\n\n\t// The rest of the dance is completed and neither perspective should\n\t// change.\n\tbobSig, bobHtlcSigs, _, err := bobChannel.SignNextCommitment()\n\trequire.NoError(t, err)\n\terr = aliceChannel.ReceiveNewCommitment(bobSig, bobHtlcSigs)\n\trequire.NoError(t, err)\n\taliceRevocation, _, _, err := aliceChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err)\n\t_, _, _, _, err = bobChannel.ReceiveRevocation(aliceRevocation)\n\trequire.NoError(t, err)\n\tcheckDust(aliceChannel, htlc2Amt, htlc2Amt)\n\tcheckDust(bobChannel, htlc2Amt, htlc2Amt)\n\n\t// We'll now assert that if Alice sends an HTLC above her dust limit\n\t// and then updates the fee of the channel to trigger the trimmed to\n\t// dust mechanism, Alice will count this HTLC in the dust sum for her\n\t// commitment in the non-zero-fee case.\n\thtlc3Amt := lnwire.MilliSatoshi(400_000)\n\thtlc3, _ := createHTLC(1, htlc3Amt)\n\n\t_, err = aliceChannel.AddHTLC(htlc3, nil)\n\trequire.NoError(t, err)\n\t_, err = bobChannel.ReceiveHTLC(htlc3)\n\trequire.NoError(t, err)\n\n\t// Assert that this new HTLC is not counted on Alice's local commitment\n\t// in the dust sum. Bob's commitment should count it.\n\tcheckDust(aliceChannel, htlc2Amt, htlc2Amt+htlc3Amt)\n\tcheckDust(bobChannel, htlc2Amt+htlc3Amt, htlc2Amt)\n\n\t// Alice will now send UpdateFee with a large feerate and neither\n\t// perspective should change.\n\tfee = chainfee.SatPerKWeight(50_000)\n\terr = aliceChannel.UpdateFee(fee)\n\trequire.NoError(t, err)\n\terr = bobChannel.ReceiveUpdateFee(fee)\n\trequire.NoError(t, err)\n\tcheckDust(aliceChannel, htlc2Amt, htlc2Amt+htlc3Amt)\n\tcheckDust(bobChannel, htlc2Amt+htlc3Amt, htlc2Amt)\n\n\t// Forcing a state transition should change in the non-zero-fee case.\n\terr = ForceStateTransition(aliceChannel, bobChannel)\n\trequire.NoError(t, err)\n\tif chantype.ZeroHtlcTxFee() {\n\t\tcheckDust(aliceChannel, htlc2Amt, htlc2Amt+htlc3Amt)\n\t\tcheckDust(bobChannel, htlc2Amt+htlc3Amt, htlc2Amt)\n\t} else {\n\t\tcheckDust(aliceChannel, htlc2Amt+htlc3Amt, htlc2Amt+htlc3Amt)\n\t\tcheckDust(bobChannel, htlc2Amt+htlc3Amt, htlc2Amt+htlc3Amt)\n\t}\n}\n\n// deriveDummyRetributionParams is a helper function that derives a list of\n// dummy params to assist retribution creation related tests.",
      "length": 6273,
      "tokens": 733,
      "embedding": []
    },
    {
      "slug": "func deriveDummyRetributionParams(chanState *channeldb.OpenChannel) (uint32,",
      "content": "func deriveDummyRetributionParams(chanState *channeldb.OpenChannel) (uint32,\n\t*CommitmentKeyRing, chainhash.Hash) {\n\n\tconfig := chanState.RemoteChanCfg\n\tcommitHash := chanState.RemoteCommitment.CommitTx.TxHash()\n\tkeyRing := DeriveCommitmentKeys(\n\t\tconfig.RevocationBasePoint.PubKey, false, chanState.ChanType,\n\t\t&chanState.LocalChanCfg, &chanState.RemoteChanCfg,\n\t)\n\tleaseExpiry := chanState.ThawHeight\n\treturn leaseExpiry, keyRing, commitHash\n}\n\n// TestCreateHtlcRetribution checks that `createHtlcRetribution` behaves as\n// epxected.",
      "length": 445,
      "tokens": 35,
      "embedding": []
    },
    {
      "slug": "func TestCreateHtlcRetribution(t *testing.T) {",
      "content": "func TestCreateHtlcRetribution(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a dummy private key and an HTLC amount for testing.\n\tdummyPrivate, _ := btcec.PrivKeyFromBytes([]byte{1})\n\ttestAmt := btcutil.Amount(100)\n\n\t// Create a test channel.\n\taliceChannel, _, err := CreateTestChannels(\n\t\tt, channeldb.ZeroHtlcTxFeeBit,\n\t)\n\trequire.NoError(t, err)\n\n\t// Prepare the params needed to call the function. Note that the values\n\t// here are not necessary \"cryptography-correct\", we just use them to\n\t// construct the htlc retribution.\n\tleaseExpiry, keyRing, commitHash := deriveDummyRetributionParams(\n\t\taliceChannel.channelState,\n\t)\n\thtlc := &channeldb.HTLCEntry{\n\t\tAmt:         testAmt,\n\t\tIncoming:    true,\n\t\tOutputIndex: 1,\n\t}\n\n\t// Create the htlc retribution.\n\thr, err := createHtlcRetribution(\n\t\taliceChannel.channelState, keyRing, commitHash,\n\t\tdummyPrivate, leaseExpiry, htlc,\n\t)\n\t// Expect no error.\n\trequire.NoError(t, err)\n\n\t// Check the fields have expected values.\n\trequire.EqualValues(t, testAmt, hr.SignDesc.Output.Value)\n\trequire.Equal(t, commitHash, hr.OutPoint.Hash)\n\trequire.EqualValues(t, htlc.OutputIndex, hr.OutPoint.Index)\n\trequire.Equal(t, htlc.Incoming, hr.IsIncoming)\n}\n\n// TestCreateBreachRetribution checks that `createBreachRetribution` behaves as\n// expected.",
      "length": 1193,
      "tokens": 132,
      "embedding": []
    },
    {
      "slug": "func TestCreateBreachRetribution(t *testing.T) {",
      "content": "func TestCreateBreachRetribution(t *testing.T) {\n\tt.Parallel()\n\n\t// Create dummy values for the test.\n\tdummyPrivate, _ := btcec.PrivKeyFromBytes([]byte{1})\n\ttestAmt := int64(100)\n\tourAmt := int64(1000)\n\ttheirAmt := int64(2000)\n\tlocalIndex := uint32(0)\n\tremoteIndex := uint32(1)\n\thtlcIndex := uint32(2)\n\n\t// Create a dummy breach tx, which has our output located at index 0\n\t// and theirs at 1.\n\tspendTx := &wire.MsgTx{\n\t\tTxOut: []*wire.TxOut{\n\t\t\t{Value: ourAmt},\n\t\t\t{Value: theirAmt},\n\t\t\t{Value: testAmt},\n\t\t},\n\t}\n\n\t// Create a test channel.\n\taliceChannel, _, err := CreateTestChannels(\n\t\tt, channeldb.ZeroHtlcTxFeeBit,\n\t)\n\trequire.NoError(t, err)\n\n\t// Prepare the params needed to call the function. Note that the values\n\t// here are not necessary \"cryptography-correct\", we just use them to\n\t// construct the retribution.\n\tleaseExpiry, keyRing, commitHash := deriveDummyRetributionParams(\n\t\taliceChannel.channelState,\n\t)\n\thtlc := &channeldb.HTLCEntry{\n\t\tAmt:         btcutil.Amount(testAmt),\n\t\tIncoming:    true,\n\t\tOutputIndex: uint16(htlcIndex),\n\t}\n\n\t// Create a dummy revocation log.\n\tourAmtMsat := lnwire.MilliSatoshi(ourAmt * 1000)\n\ttheirAmtMsat := lnwire.MilliSatoshi(theirAmt * 1000)\n\trevokedLog := channeldb.RevocationLog{\n\t\tCommitTxHash:     commitHash,\n\t\tOurOutputIndex:   uint16(localIndex),\n\t\tTheirOutputIndex: uint16(remoteIndex),\n\t\tHTLCEntries:      []*channeldb.HTLCEntry{htlc},\n\t\tTheirBalance:     &theirAmtMsat,\n\t\tOurBalance:       &ourAmtMsat,\n\t}\n\n\t// Create a log with an empty local output index.\n\trevokedLogNoLocal := revokedLog\n\trevokedLogNoLocal.OurOutputIndex = channeldb.OutputIndexEmpty\n\n\t// Create a log with an empty remote output index.\n\trevokedLogNoRemote := revokedLog\n\trevokedLogNoRemote.TheirOutputIndex = channeldb.OutputIndexEmpty\n\n\ttestCases := []struct {\n\t\tname             string\n\t\trevocationLog    *channeldb.RevocationLog\n\t\texpectedErr      error\n\t\texpectedOurAmt   int64\n\t\texpectedTheirAmt int64\n\t\tnoSpendTx        bool\n\t}{\n\t\t{\n\t\t\tname: \"create retribution successfully \" +\n\t\t\t\t\"with spend tx\",\n\t\t\trevocationLog:    &revokedLog,\n\t\t\texpectedErr:      nil,\n\t\t\texpectedOurAmt:   ourAmt,\n\t\t\texpectedTheirAmt: theirAmt,\n\t\t},\n\t\t{\n\t\t\tname: \"create retribution successfully \" +\n\t\t\t\t\"without spend tx\",\n\t\t\trevocationLog:    &revokedLog,\n\t\t\texpectedErr:      nil,\n\t\t\texpectedOurAmt:   ourAmt,\n\t\t\texpectedTheirAmt: theirAmt,\n\t\t\tnoSpendTx:        true,\n\t\t},\n\t\t{\n\t\t\tname: \"fail due to our index too big\",\n\t\t\trevocationLog: &channeldb.RevocationLog{\n\t\t\t\tOurOutputIndex: uint16(htlcIndex + 1),\n\t\t\t},\n\t\t\texpectedErr: ErrOutputIndexOutOfRange,\n\t\t},\n\t\t{\n\t\t\tname: \"fail due to their index too big\",\n\t\t\trevocationLog: &channeldb.RevocationLog{\n\t\t\t\tTheirOutputIndex: uint16(htlcIndex + 1),\n\t\t\t},\n\t\t\texpectedErr: ErrOutputIndexOutOfRange,\n\t\t},\n\t\t{\n\t\t\tname: \"empty local output index with spend \" +\n\t\t\t\t\"tx\",\n\t\t\trevocationLog:    &revokedLogNoLocal,\n\t\t\texpectedErr:      nil,\n\t\t\texpectedOurAmt:   0,\n\t\t\texpectedTheirAmt: theirAmt,\n\t\t},\n\t\t{\n\t\t\tname: \"empty local output index without spend \" +\n\t\t\t\t\"tx\",\n\t\t\trevocationLog:    &revokedLogNoLocal,\n\t\t\texpectedErr:      nil,\n\t\t\texpectedOurAmt:   0,\n\t\t\texpectedTheirAmt: theirAmt,\n\t\t\tnoSpendTx:        true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty remote output index with spend \" +\n\t\t\t\t\"tx\",\n\t\t\trevocationLog:    &revokedLogNoRemote,\n\t\t\texpectedErr:      nil,\n\t\t\texpectedOurAmt:   ourAmt,\n\t\t\texpectedTheirAmt: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"empty remote output index without spend \" +\n\t\t\t\t\"tx\",\n\t\t\trevocationLog:    &revokedLogNoRemote,\n\t\t\texpectedErr:      nil,\n\t\t\texpectedOurAmt:   ourAmt,\n\t\t\texpectedTheirAmt: 0,\n\t\t\tnoSpendTx:        true,\n\t\t},\n\t}\n\n\t// assertRetribution is a helper closure that checks a given breach\n\t// retribution has the expected values on certain fields.\n\tassertRetribution := func(br *BreachRetribution, our, their int64) {\n\t\tchainHash := aliceChannel.channelState.ChainHash\n\t\trequire.Equal(t, commitHash, br.BreachTxHash)\n\t\trequire.Equal(t, chainHash, br.ChainHash)\n\n\t\t// Construct local outpoint, we only have the index when the\n\t\t// amount is not zero.\n\t\tlocal := wire.OutPoint{\n\t\t\tHash: commitHash,\n\t\t}\n\t\tif our != 0 {\n\t\t\tlocal.Index = localIndex\n\t\t}\n\n\t\t// Construct remote outpoint, we only have the index when the\n\t\t// amount is not zero.\n\t\tremote := wire.OutPoint{\n\t\t\tHash: commitHash,\n\t\t}\n\t\tif their != 0 {\n\t\t\tremote.Index = remoteIndex\n\t\t}\n\n\t\trequire.Equal(t, local, br.LocalOutpoint)\n\t\trequire.Equal(t, remote, br.RemoteOutpoint)\n\n\t\tfor _, hr := range br.HtlcRetributions {\n\t\t\trequire.EqualValues(t, testAmt,\n\t\t\t\thr.SignDesc.Output.Value)\n\t\t\trequire.Equal(t, commitHash, hr.OutPoint.Hash)\n\t\t\trequire.EqualValues(t, htlcIndex, hr.OutPoint.Index)\n\t\t\trequire.Equal(t, htlc.Incoming, hr.IsIncoming)\n\t\t}\n\t}\n\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\ttx := spendTx\n\t\t\tif tc.noSpendTx {\n\t\t\t\ttx = nil\n\t\t\t}\n\n\t\t\tbr, our, their, err := createBreachRetribution(\n\t\t\t\ttc.revocationLog, tx,\n\t\t\t\taliceChannel.channelState, keyRing,\n\t\t\t\tdummyPrivate, leaseExpiry,\n\t\t\t)\n\n\t\t\t// Check the error if expected.\n\t\t\tif tc.expectedErr != nil {\n\t\t\t\trequire.ErrorIs(t, err, tc.expectedErr)\n\t\t\t} else {\n\t\t\t\t// Otherwise we expect no error.\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\t// Check the amounts and the contructed partial\n\t\t\t\t// retribution are returned as expected.\n\t\t\t\trequire.Equal(t, tc.expectedOurAmt, our)\n\t\t\t\trequire.Equal(t, tc.expectedTheirAmt, their)\n\t\t\t\tassertRetribution(br, our, their)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestCreateBreachRetributionLegacy checks that\n// `createBreachRetributionLegacy` behaves as expected.",
      "length": 5255,
      "tokens": 590,
      "embedding": []
    },
    {
      "slug": "func TestCreateBreachRetributionLegacy(t *testing.T) {",
      "content": "func TestCreateBreachRetributionLegacy(t *testing.T) {\n\tt.Parallel()\n\n\t// Create dummy values for the test.\n\tdummyPrivate, _ := btcec.PrivKeyFromBytes([]byte{1})\n\n\t// Create a test channel.\n\taliceChannel, _, err := CreateTestChannels(\n\t\tt, channeldb.ZeroHtlcTxFeeBit,\n\t)\n\trequire.NoError(t, err)\n\n\t// Prepare the params needed to call the function. Note that the values\n\t// here are not necessary \"cryptography-correct\", we just use them to\n\t// construct the retribution.\n\tleaseExpiry, keyRing, _ := deriveDummyRetributionParams(\n\t\taliceChannel.channelState,\n\t)\n\n\t// Use the remote commitment as our revocation log.\n\trevokedLog := aliceChannel.channelState.RemoteCommitment\n\n\tourOp := revokedLog.CommitTx.TxOut[0]\n\ttheirOp := revokedLog.CommitTx.TxOut[1]\n\n\t// Create the dummy scripts.\n\tourScript := &ScriptInfo{\n\t\tPkScript: ourOp.PkScript,\n\t}\n\ttheirScript := &ScriptInfo{\n\t\tPkScript: theirOp.PkScript,\n\t}\n\n\t// Create the breach retribution using the legacy format.\n\tbr, ourAmt, theirAmt, err := createBreachRetributionLegacy(\n\t\t&revokedLog, aliceChannel.channelState, keyRing,\n\t\tdummyPrivate, ourScript, theirScript, leaseExpiry,\n\t)\n\trequire.NoError(t, err)\n\n\t// Check the commitHash and chainHash.\n\tcommitHash := revokedLog.CommitTx.TxHash()\n\tchainHash := aliceChannel.channelState.ChainHash\n\trequire.Equal(t, commitHash, br.BreachTxHash)\n\trequire.Equal(t, chainHash, br.ChainHash)\n\n\t// Check the outpoints.\n\tlocal := wire.OutPoint{\n\t\tHash:  commitHash,\n\t\tIndex: 0,\n\t}\n\tremote := wire.OutPoint{\n\t\tHash:  commitHash,\n\t\tIndex: 1,\n\t}\n\trequire.Equal(t, local, br.LocalOutpoint)\n\trequire.Equal(t, remote, br.RemoteOutpoint)\n\n\t// Validate the amounts, note that in the legacy format, our amount is\n\t// not directly the amount found in the to local output. Rather, it's\n\t// the local output value minus the commit fee and anchor value(if\n\t// present).\n\trequire.EqualValues(t, revokedLog.LocalBalance.ToSatoshis(), ourAmt)\n\trequire.Equal(t, theirOp.Value, theirAmt)\n}\n\n// TestNewBreachRetribution tests that the function `NewBreachRetribution`\n// behaves as expected.",
      "length": 1940,
      "tokens": 224,
      "embedding": []
    },
    {
      "slug": "func TestNewBreachRetribution(t *testing.T) {",
      "content": "func TestNewBreachRetribution(t *testing.T) {\n\tt.Run(\"non-anchor\", func(t *testing.T) {\n\t\ttestNewBreachRetribution(t, channeldb.ZeroHtlcTxFeeBit)\n\t})\n\tt.Run(\"anchor\", func(t *testing.T) {\n\t\tchanType := channeldb.SingleFunderTweaklessBit |\n\t\t\tchanneldb.AnchorOutputsBit\n\t\ttestNewBreachRetribution(t, chanType)\n\t})\n}\n\n// testNewBreachRetribution takes a channel type and tests the function\n// `NewBreachRetribution`.",
      "length": 357,
      "tokens": 32,
      "embedding": []
    },
    {
      "slug": "func testNewBreachRetribution(t *testing.T, chanType channeldb.ChannelType) {",
      "content": "func testNewBreachRetribution(t *testing.T, chanType channeldb.ChannelType) {\n\tt.Parallel()\n\n\taliceChannel, bobChannel, err := CreateTestChannels(t, chanType)\n\trequire.NoError(t, err)\n\n\tbreachHeight := uint32(101)\n\tstateNum := uint64(0)\n\tchainHash := aliceChannel.channelState.ChainHash\n\ttheirDelay := uint32(aliceChannel.channelState.RemoteChanCfg.CsvDelay)\n\tbreachTx := aliceChannel.channelState.RemoteCommitment.CommitTx\n\n\t// Create a breach retribution at height 0, which should give us an\n\t// error as there are no past delta state saved as revocation logs yet.\n\t_, err = NewBreachRetribution(\n\t\taliceChannel.channelState, stateNum, breachHeight, breachTx,\n\t)\n\trequire.ErrorIs(t, err, channeldb.ErrNoPastDeltas)\n\n\t// We also check that the same error is returned if no breach tx is\n\t// provided.\n\t_, err = NewBreachRetribution(\n\t\taliceChannel.channelState, stateNum, breachHeight, nil,\n\t)\n\trequire.ErrorIs(t, err, channeldb.ErrNoPastDeltas)\n\n\t// We now force a state transition which will give us a revocation log\n\t// at height 0.\n\ttxid := aliceChannel.channelState.RemoteCommitment.CommitTx.TxHash()\n\terr = ForceStateTransition(aliceChannel, bobChannel)\n\trequire.NoError(t, err)\n\n\t// assertRetribution is a helper closure that checks a given breach\n\t// retribution has the expected values on certain fields.\n\tassertRetribution := func(br *BreachRetribution,\n\t\tlocalIndex, remoteIndex uint32) {\n\n\t\trequire.Equal(t, txid, br.BreachTxHash)\n\t\trequire.Equal(t, chainHash, br.ChainHash)\n\t\trequire.Equal(t, breachHeight, br.BreachHeight)\n\t\trequire.Equal(t, stateNum, br.RevokedStateNum)\n\t\trequire.Equal(t, theirDelay, br.RemoteDelay)\n\n\t\tlocal := wire.OutPoint{\n\t\t\tHash:  txid,\n\t\t\tIndex: localIndex,\n\t\t}\n\t\tremote := wire.OutPoint{\n\t\t\tHash:  txid,\n\t\t\tIndex: remoteIndex,\n\t\t}\n\n\t\tif chanType.HasAnchors() {\n\t\t\t// For anchor channels, we expect the local delay to be\n\t\t\t// 1 otherwise 0.\n\t\t\trequire.EqualValues(t, 1, br.LocalDelay)\n\t\t} else {\n\t\t\trequire.Zero(t, br.LocalDelay)\n\t\t}\n\n\t\trequire.Equal(t, local, br.LocalOutpoint)\n\t\trequire.Equal(t, remote, br.RemoteOutpoint)\n\t}\n\n\t// Create the retribution again and we should expect it to be created\n\t// successfully.\n\tbr, err := NewBreachRetribution(\n\t\taliceChannel.channelState, stateNum, breachHeight, breachTx,\n\t)\n\trequire.NoError(t, err)\n\n\t// Check the retribution is as expected.\n\tt.Log(spew.Sdump(breachTx))\n\tassertRetribution(br, 1, 0)\n\n\t// Repeat the check but with the breach tx set to nil. This should work\n\t// since the necessary info should now be found in the revocation log.\n\tbr, err = NewBreachRetribution(\n\t\taliceChannel.channelState, stateNum, breachHeight, nil,\n\t)\n\trequire.NoError(t, err)\n\tassertRetribution(br, 1, 0)\n\n\t// Create the retribution using a stateNum+1 and we should expect an\n\t// error.\n\t_, err = NewBreachRetribution(\n\t\taliceChannel.channelState, stateNum+1, breachHeight, breachTx,\n\t)\n\trequire.ErrorIs(t, err, channeldb.ErrLogEntryNotFound)\n\n\t// Once again, repeat the check for the case when no breach tx is\n\t// provided.\n\t_, err = NewBreachRetribution(\n\t\taliceChannel.channelState, stateNum+1, breachHeight, nil,\n\t)\n\trequire.ErrorIs(t, err, channeldb.ErrLogEntryNotFound)\n}\n",
      "length": 2978,
      "tokens": 346,
      "embedding": []
    }
  ]
}