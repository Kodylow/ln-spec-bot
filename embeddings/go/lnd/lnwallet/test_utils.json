{
  "filepath": "../implementations/go/lnd/lnwallet/test_utils.go",
  "package": "lnwallet",
  "sections": [
    {
      "slug": "func CreateTestChannels(t *testing.T, chanType channeldb.ChannelType,",
      "content": "func CreateTestChannels(t *testing.T, chanType channeldb.ChannelType,\n\tdbModifiers ...channeldb.OptionModifier) (*LightningChannel,\n\t*LightningChannel, error) {\n\n\tchannelCapacity, err := btcutil.NewAmount(testChannelCapacity)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tchannelBal := channelCapacity / 2\n\tcsvTimeoutAlice := uint32(5)\n\tcsvTimeoutBob := uint32(4)\n\tisAliceInitiator := true\n\n\tprevOut := &wire.OutPoint{\n\t\tHash:  chainhash.Hash(testHdSeed),\n\t\tIndex: prand.Uint32(),\n\t}\n\tfundingTxIn := wire.NewTxIn(prevOut, nil, nil)\n\n\t// For each party, we'll create a distinct set of keys in order to\n\t// emulate the typical set up with live channels.\n\tvar (\n\t\taliceKeys []*btcec.PrivateKey\n\t\tbobKeys   []*btcec.PrivateKey\n\t)\n\tfor i := 0; i < 5; i++ {\n\t\tkey := make([]byte, len(testWalletPrivKey))\n\t\tcopy(key[:], testWalletPrivKey[:])\n\t\tkey[0] ^= byte(i + 1)\n\n\t\taliceKey, _ := btcec.PrivKeyFromBytes(key)\n\t\taliceKeys = append(aliceKeys, aliceKey)\n\n\t\tkey = make([]byte, len(bobsPrivKey))\n\t\tcopy(key[:], bobsPrivKey)\n\t\tkey[0] ^= byte(i + 1)\n\n\t\tbobKey, _ := btcec.PrivKeyFromBytes(key)\n\t\tbobKeys = append(bobKeys, bobKey)\n\t}\n\n\taliceCfg := channeldb.ChannelConfig{\n\t\tChannelConstraints: channeldb.ChannelConstraints{\n\t\t\tDustLimit:        aliceDustLimit,\n\t\t\tMaxPendingAmount: lnwire.NewMSatFromSatoshis(channelCapacity),\n\t\t\tChanReserve:      channelCapacity / 100,\n\t\t\tMinHTLC:          0,\n\t\t\tMaxAcceptedHtlcs: input.MaxHTLCNumber / 2,\n\t\t\tCsvDelay:         uint16(csvTimeoutAlice),\n\t\t},\n\t\tMultiSigKey: keychain.KeyDescriptor{\n\t\t\tPubKey: aliceKeys[0].PubKey(),\n\t\t},\n\t\tRevocationBasePoint: keychain.KeyDescriptor{\n\t\t\tPubKey: aliceKeys[1].PubKey(),\n\t\t},\n\t\tPaymentBasePoint: keychain.KeyDescriptor{\n\t\t\tPubKey: aliceKeys[2].PubKey(),\n\t\t},\n\t\tDelayBasePoint: keychain.KeyDescriptor{\n\t\t\tPubKey: aliceKeys[3].PubKey(),\n\t\t},\n\t\tHtlcBasePoint: keychain.KeyDescriptor{\n\t\t\tPubKey: aliceKeys[4].PubKey(),\n\t\t},\n\t}\n\tbobCfg := channeldb.ChannelConfig{\n\t\tChannelConstraints: channeldb.ChannelConstraints{\n\t\t\tDustLimit:        bobDustLimit,\n\t\t\tMaxPendingAmount: lnwire.NewMSatFromSatoshis(channelCapacity),\n\t\t\tChanReserve:      channelCapacity / 100,\n\t\t\tMinHTLC:          0,\n\t\t\tMaxAcceptedHtlcs: input.MaxHTLCNumber / 2,\n\t\t\tCsvDelay:         uint16(csvTimeoutBob),\n\t\t},\n\t\tMultiSigKey: keychain.KeyDescriptor{\n\t\t\tPubKey: bobKeys[0].PubKey(),\n\t\t},\n\t\tRevocationBasePoint: keychain.KeyDescriptor{\n\t\t\tPubKey: bobKeys[1].PubKey(),\n\t\t},\n\t\tPaymentBasePoint: keychain.KeyDescriptor{\n\t\t\tPubKey: bobKeys[2].PubKey(),\n\t\t},\n\t\tDelayBasePoint: keychain.KeyDescriptor{\n\t\t\tPubKey: bobKeys[3].PubKey(),\n\t\t},\n\t\tHtlcBasePoint: keychain.KeyDescriptor{\n\t\t\tPubKey: bobKeys[4].PubKey(),\n\t\t},\n\t}\n\n\tbobRoot, err := chainhash.NewHash(bobKeys[0].Serialize())\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tbobPreimageProducer := shachain.NewRevocationProducer(*bobRoot)\n\tbobFirstRevoke, err := bobPreimageProducer.AtIndex(0)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tbobCommitPoint := input.ComputeCommitmentPoint(bobFirstRevoke[:])\n\n\taliceRoot, err := chainhash.NewHash(aliceKeys[0].Serialize())\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\talicePreimageProducer := shachain.NewRevocationProducer(*aliceRoot)\n\taliceFirstRevoke, err := alicePreimageProducer.AtIndex(0)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\taliceCommitPoint := input.ComputeCommitmentPoint(aliceFirstRevoke[:])\n\n\taliceCommitTx, bobCommitTx, err := CreateCommitmentTxns(\n\t\tchannelBal, channelBal, &aliceCfg, &bobCfg, aliceCommitPoint,\n\t\tbobCommitPoint, *fundingTxIn, chanType, isAliceInitiator, 0,\n\t)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tdbAlice, err := channeldb.Open(t.TempDir(), dbModifiers...)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, dbAlice.Close())\n\t})\n\n\tdbBob, err := channeldb.Open(t.TempDir(), dbModifiers...)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, dbBob.Close())\n\t})\n\n\testimator := chainfee.NewStaticEstimator(6000, 0)\n\tfeePerKw, err := estimator.EstimateFeePerKW(1)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tcommitFee := calcStaticFee(chanType, 0)\n\tvar anchorAmt btcutil.Amount\n\tif chanType.HasAnchors() {\n\t\tanchorAmt += 2 * anchorSize\n\t}\n\n\taliceBalance := lnwire.NewMSatFromSatoshis(\n\t\tchannelBal - commitFee - anchorAmt,\n\t)\n\tbobBalance := lnwire.NewMSatFromSatoshis(channelBal)\n\n\taliceLocalCommit := channeldb.ChannelCommitment{\n\t\tCommitHeight:  0,\n\t\tLocalBalance:  aliceBalance,\n\t\tRemoteBalance: bobBalance,\n\t\tCommitFee:     commitFee,\n\t\tFeePerKw:      btcutil.Amount(feePerKw),\n\t\tCommitTx:      aliceCommitTx,\n\t\tCommitSig:     testSigBytes,\n\t}\n\taliceRemoteCommit := channeldb.ChannelCommitment{\n\t\tCommitHeight:  0,\n\t\tLocalBalance:  aliceBalance,\n\t\tRemoteBalance: bobBalance,\n\t\tCommitFee:     commitFee,\n\t\tFeePerKw:      btcutil.Amount(feePerKw),\n\t\tCommitTx:      bobCommitTx,\n\t\tCommitSig:     testSigBytes,\n\t}\n\tbobLocalCommit := channeldb.ChannelCommitment{\n\t\tCommitHeight:  0,\n\t\tLocalBalance:  bobBalance,\n\t\tRemoteBalance: aliceBalance,\n\t\tCommitFee:     commitFee,\n\t\tFeePerKw:      btcutil.Amount(feePerKw),\n\t\tCommitTx:      bobCommitTx,\n\t\tCommitSig:     testSigBytes,\n\t}\n\tbobRemoteCommit := channeldb.ChannelCommitment{\n\t\tCommitHeight:  0,\n\t\tLocalBalance:  bobBalance,\n\t\tRemoteBalance: aliceBalance,\n\t\tCommitFee:     commitFee,\n\t\tFeePerKw:      btcutil.Amount(feePerKw),\n\t\tCommitTx:      aliceCommitTx,\n\t\tCommitSig:     testSigBytes,\n\t}\n\n\tvar chanIDBytes [8]byte\n\tif _, err := io.ReadFull(rand.Reader, chanIDBytes[:]); err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tshortChanID := lnwire.NewShortChanIDFromInt(\n\t\tbinary.BigEndian.Uint64(chanIDBytes[:]),\n\t)\n\n\taliceChannelState := &channeldb.OpenChannel{\n\t\tLocalChanCfg:            aliceCfg,\n\t\tRemoteChanCfg:           bobCfg,\n\t\tIdentityPub:             aliceKeys[0].PubKey(),\n\t\tFundingOutpoint:         *prevOut,\n\t\tShortChannelID:          shortChanID,\n\t\tChanType:                chanType,\n\t\tIsInitiator:             isAliceInitiator,\n\t\tCapacity:                channelCapacity,\n\t\tRemoteCurrentRevocation: bobCommitPoint,\n\t\tRevocationProducer:      alicePreimageProducer,\n\t\tRevocationStore:         shachain.NewRevocationStore(),\n\t\tLocalCommitment:         aliceLocalCommit,\n\t\tRemoteCommitment:        aliceRemoteCommit,\n\t\tDb:                      dbAlice.ChannelStateDB(),\n\t\tPackager:                channeldb.NewChannelPackager(shortChanID),\n\t\tFundingTxn:              testTx,\n\t}\n\tbobChannelState := &channeldb.OpenChannel{\n\t\tLocalChanCfg:            bobCfg,\n\t\tRemoteChanCfg:           aliceCfg,\n\t\tIdentityPub:             bobKeys[0].PubKey(),\n\t\tFundingOutpoint:         *prevOut,\n\t\tShortChannelID:          shortChanID,\n\t\tChanType:                chanType,\n\t\tIsInitiator:             !isAliceInitiator,\n\t\tCapacity:                channelCapacity,\n\t\tRemoteCurrentRevocation: aliceCommitPoint,\n\t\tRevocationProducer:      bobPreimageProducer,\n\t\tRevocationStore:         shachain.NewRevocationStore(),\n\t\tLocalCommitment:         bobLocalCommit,\n\t\tRemoteCommitment:        bobRemoteCommit,\n\t\tDb:                      dbBob.ChannelStateDB(),\n\t\tPackager:                channeldb.NewChannelPackager(shortChanID),\n\t}\n\n\taliceSigner := &input.MockSigner{Privkeys: aliceKeys}\n\tbobSigner := &input.MockSigner{Privkeys: bobKeys}\n\n\t// TODO(roasbeef): make mock version of pre-image store\n\n\talicePool := NewSigPool(1, aliceSigner)\n\tchannelAlice, err := NewLightningChannel(\n\t\taliceSigner, aliceChannelState, alicePool,\n\t)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\talicePool.Start()\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, alicePool.Stop())\n\t})\n\n\tobfuscator := createStateHintObfuscator(aliceChannelState)\n\n\tbobPool := NewSigPool(1, bobSigner)\n\tchannelBob, err := NewLightningChannel(\n\t\tbobSigner, bobChannelState, bobPool,\n\t)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tbobPool.Start()\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, bobPool.Stop())\n\t})\n\n\terr = SetStateNumHint(\n\t\taliceCommitTx, 0, obfuscator,\n\t)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\terr = SetStateNumHint(\n\t\tbobCommitTx, 0, obfuscator,\n\t)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\taddr := &net.TCPAddr{\n\t\tIP:   net.ParseIP(\"127.0.0.1\"),\n\t\tPort: 18556,\n\t}\n\tif err := channelAlice.channelState.SyncPending(addr, 101); err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\taddr = &net.TCPAddr{\n\t\tIP:   net.ParseIP(\"127.0.0.1\"),\n\t\tPort: 18555,\n\t}\n\n\tif err := channelBob.channelState.SyncPending(addr, 101); err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// Now that the channel are open, simulate the start of a session by\n\t// having Alice and Bob extend their revocation windows to each other.\n\terr = initRevocationWindows(channelAlice, channelBob)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn channelAlice, channelBob, nil\n}\n\n// initRevocationWindows simulates a new channel being opened within the p2p\n// network by populating the initial revocation windows of the passed\n// commitment state machines.",
      "length": 8445,
      "tokens": 790,
      "embedding": []
    },
    {
      "slug": "func initRevocationWindows(chanA, chanB *LightningChannel) error {",
      "content": "func initRevocationWindows(chanA, chanB *LightningChannel) error {\n\taliceNextRevoke, err := chanA.NextRevocationKey()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := chanB.InitNextRevocation(aliceNextRevoke); err != nil {\n\t\treturn err\n\t}\n\n\tbobNextRevoke, err := chanB.NextRevocationKey()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := chanA.InitNextRevocation(bobNextRevoke); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// pubkeyFromHex parses a Bitcoin public key from a hex encoded string.",
      "length": 399,
      "tokens": 61,
      "embedding": []
    },
    {
      "slug": "func pubkeyFromHex(keyHex string) (*btcec.PublicKey, error) {",
      "content": "func pubkeyFromHex(keyHex string) (*btcec.PublicKey, error) {\n\tbytes, err := hex.DecodeString(keyHex)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn btcec.ParsePubKey(bytes)\n}\n\n// privkeyFromHex parses a Bitcoin private key from a hex encoded string.",
      "length": 180,
      "tokens": 28,
      "embedding": []
    },
    {
      "slug": "func privkeyFromHex(keyHex string) (*btcec.PrivateKey, error) {",
      "content": "func privkeyFromHex(keyHex string) (*btcec.PrivateKey, error) {\n\tbytes, err := hex.DecodeString(keyHex)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tkey, _ := btcec.PrivKeyFromBytes(bytes)\n\treturn key, nil\n\n}\n\n// blockFromHex parses a full Bitcoin block from a hex encoded string.",
      "length": 201,
      "tokens": 33,
      "embedding": []
    },
    {
      "slug": "func blockFromHex(blockHex string) (*btcutil.Block, error) {",
      "content": "func blockFromHex(blockHex string) (*btcutil.Block, error) {\n\tbytes, err := hex.DecodeString(blockHex)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn btcutil.NewBlockFromBytes(bytes)\n}\n\n// txFromHex parses a full Bitcoin transaction from a hex encoded string.",
      "length": 190,
      "tokens": 28,
      "embedding": []
    },
    {
      "slug": "func txFromHex(txHex string) (*btcutil.Tx, error) {",
      "content": "func txFromHex(txHex string) (*btcutil.Tx, error) {\n\tbytes, err := hex.DecodeString(txHex)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn btcutil.NewTxFromBytes(bytes)\n}\n\n// calcStaticFee calculates appropriate fees for commitment transactions.  This\n// function provides a simple way to allow test balance assertions to take fee\n// calculations into account.\n//\n// TODO(bvu): Refactor when dynamic fee estimation is added.",
      "length": 359,
      "tokens": 53,
      "embedding": []
    },
    {
      "slug": "func calcStaticFee(chanType channeldb.ChannelType, numHTLCs int) btcutil.Amount {",
      "content": "func calcStaticFee(chanType channeldb.ChannelType, numHTLCs int) btcutil.Amount {\n\tconst (\n\t\thtlcWeight = 172\n\t\tfeePerKw   = btcutil.Amount(24/4) * 1000\n\t)\n\treturn feePerKw *\n\t\t(btcutil.Amount(CommitWeight(chanType) +\n\t\t\thtlcWeight*int64(numHTLCs))) / 1000\n}\n\n// ForceStateTransition executes the necessary interaction between the two\n// commitment state machines to transition to a new state locking in any\n// pending updates. This method is useful when testing interactions between two\n// live state machines.",
      "length": 417,
      "tokens": 58,
      "embedding": []
    },
    {
      "slug": "func ForceStateTransition(chanA, chanB *LightningChannel) error {",
      "content": "func ForceStateTransition(chanA, chanB *LightningChannel) error {\n\taliceSig, aliceHtlcSigs, _, err := chanA.SignNextCommitment()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err = chanB.ReceiveNewCommitment(aliceSig, aliceHtlcSigs); err != nil {\n\t\treturn err\n\t}\n\n\tbobRevocation, _, _, err := chanB.RevokeCurrentCommitment()\n\tif err != nil {\n\t\treturn err\n\t}\n\tbobSig, bobHtlcSigs, _, err := chanB.SignNextCommitment()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif _, _, _, _, err := chanA.ReceiveRevocation(bobRevocation); err != nil {\n\t\treturn err\n\t}\n\tif err := chanA.ReceiveNewCommitment(bobSig, bobHtlcSigs); err != nil {\n\t\treturn err\n\t}\n\n\taliceRevocation, _, _, err := chanA.RevokeCurrentCommitment()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif _, _, _, _, err := chanB.ReceiveRevocation(aliceRevocation); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n",
      "length": 729,
      "tokens": 113,
      "embedding": []
    }
  ]
}