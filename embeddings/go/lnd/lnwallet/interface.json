{
  "filepath": "../implementations/go/lnd/lnwallet/interface.go",
  "package": "lnwallet",
  "sections": [
    {
      "slug": "type AddressType uint8",
      "content": "type AddressType uint8\n\n// AccountAddressMap maps the account properties to an array of\n// address properties.",
      "length": 85,
      "tokens": 13,
      "embedding": []
    },
    {
      "slug": "type AccountAddressMap map[*waddrmgr.AccountProperties][]AddressProperty",
      "content": "type AccountAddressMap map[*waddrmgr.AccountProperties][]AddressProperty\n\nconst (\n\t// UnknownAddressType represents an output with an unknown or non-standard\n\t// script.\n\tUnknownAddressType AddressType = iota\n\n\t// WitnessPubKey represents a p2wkh address.\n\tWitnessPubKey\n\n\t// NestedWitnessPubKey represents a p2sh output which is itself a\n\t// nested p2wkh output.\n\tNestedWitnessPubKey\n\n\t// TaprootPubkey represents a p2tr key path spending address.\n\tTaprootPubkey\n)\n\nvar (\n\t// DefaultPublicPassphrase is the default public passphrase used for the\n\t// wallet.\n\tDefaultPublicPassphrase = []byte(\"public\")\n\n\t// DefaultPrivatePassphrase is the default private passphrase used for\n\t// the wallet.\n\tDefaultPrivatePassphrase = []byte(\"hello\")\n\n\t// ErrDoubleSpend is returned from PublishTransaction in case the\n\t// tx being published is spending an output spent by a conflicting\n\t// transaction.\n\tErrDoubleSpend = errors.New(\"transaction rejected: output already spent\")\n\n\t// ErrNotMine is an error denoting that a WalletController instance is\n\t// unable to spend a specified output.\n\tErrNotMine = errors.New(\"the passed output doesn't belong to the wallet\")\n)\n\n// ErrNoOutputs is returned if we try to create a transaction with no outputs\n// or send coins to a set of outputs that is empty.\nvar ErrNoOutputs = errors.New(\"no outputs\")\n\n// ErrInvalidMinconf is returned if we try to create a transaction with\n// invalid minConfs value.\nvar ErrInvalidMinconf = errors.New(\"minimum number of confirmations must \" +\n\t\"be a non-negative number\")\n\n// AddressProperty contains wallet related information of an address.",
      "length": 1487,
      "tokens": 212,
      "embedding": []
    },
    {
      "slug": "type AddressProperty struct {",
      "content": "type AddressProperty struct {\n\t// Address is the address of an account.\n\tAddress string\n\n\t// Internal denotes if the address is a change address.\n\tInternal bool\n\n\t// Balance returns the total balance of an address.\n\tBalance btcutil.Amount\n}\n\n// AccountIdentifier contains information to uniquely identify an account.",
      "length": 276,
      "tokens": 43,
      "embedding": []
    },
    {
      "slug": "type AccountIdentifier struct {",
      "content": "type AccountIdentifier struct {\n\t// Name is the name of the account.\n\tName string\n\n\t// AddressType is the type of addresses supported by the account.\n\tAddressType AddressType\n\n\t// DerivationPath is the derivation path corresponding to the account\n\t// public key.\n\tDerivationPath string\n}\n\n// Utxo is an unspent output denoted by its outpoint, and output value of the\n// original output.",
      "length": 342,
      "tokens": 57,
      "embedding": []
    },
    {
      "slug": "type Utxo struct {",
      "content": "type Utxo struct {\n\tAddressType   AddressType\n\tValue         btcutil.Amount\n\tConfirmations int64\n\tPkScript      []byte\n\twire.OutPoint\n\tDerivation *psbt.Bip32Derivation\n\tPrevTx     *wire.MsgTx\n}\n\n// OutputDetail contains additional information on a destination address.",
      "length": 240,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "type OutputDetail struct {",
      "content": "type OutputDetail struct {\n\tOutputType   txscript.ScriptClass\n\tAddresses    []btcutil.Address\n\tPkScript     []byte\n\tOutputIndex  int\n\tValue        btcutil.Amount\n\tIsOurAddress bool\n}\n\n// PreviousOutPoint contains information about the previous outpoint.",
      "length": 218,
      "tokens": 21,
      "embedding": []
    },
    {
      "slug": "type PreviousOutPoint struct {",
      "content": "type PreviousOutPoint struct {\n\t// OutPoint is the transaction out point in the format txid:n.\n\tOutPoint string\n\n\t// IsOurOutput denotes if the previous output is controlled by the\n\t// internal wallet. The flag will only detect p2wkh, np2wkh and p2tr\n\t// inputs as its own.\n\tIsOurOutput bool\n}\n\n// TransactionDetail describes a transaction with either inputs which belong to\n// the wallet, or has outputs that pay to the wallet.",
      "length": 387,
      "tokens": 66,
      "embedding": []
    },
    {
      "slug": "type TransactionDetail struct {",
      "content": "type TransactionDetail struct {\n\t// Hash is the transaction hash of the transaction.\n\tHash chainhash.Hash\n\n\t// Value is the net value of this transaction (in satoshis) from the\n\t// PoV of the wallet. If this transaction purely spends from the\n\t// wallet's funds, then this value will be negative. Similarly, if this\n\t// transaction credits the wallet, then this value will be positive.\n\tValue btcutil.Amount\n\n\t// NumConfirmations is the number of confirmations this transaction\n\t// has. If the transaction is unconfirmed, then this value will be\n\t// zero.\n\tNumConfirmations int32\n\n\t// BlockHeight is the hash of the block which includes this\n\t// transaction. Unconfirmed transactions will have a nil value for this\n\t// field.\n\tBlockHash *chainhash.Hash\n\n\t// BlockHeight is the height of the block including this transaction.\n\t// Unconfirmed transaction will show a height of zero.\n\tBlockHeight int32\n\n\t// Timestamp is the unix timestamp of the block including this\n\t// transaction. If the transaction is unconfirmed, then this will be a\n\t// timestamp of txn creation.\n\tTimestamp int64\n\n\t// TotalFees is the total fee in satoshis paid by this transaction.\n\tTotalFees int64\n\n\t// OutputDetails contains output data for each destination address, such\n\t// as the output script and amount.\n\tOutputDetails []OutputDetail\n\n\t// RawTx returns the raw serialized transaction.\n\tRawTx []byte\n\n\t// Label is an optional transaction label.\n\tLabel string\n\n\t// PreviousOutpoints are the inputs for a transaction.\n\tPreviousOutpoints []PreviousOutPoint\n}\n\n// TransactionSubscription is an interface which describes an object capable of\n// receiving notifications of new transaction related to the underlying wallet.\n// TODO(roasbeef): add balance updates?",
      "length": 1656,
      "tokens": 253,
      "embedding": []
    },
    {
      "slug": "type TransactionSubscription interface {",
      "content": "type TransactionSubscription interface {\n\t// ConfirmedTransactions returns a channel which will be sent on as new\n\t// relevant transactions are confirmed.\n\tConfirmedTransactions() chan *TransactionDetail\n\n\t// UnconfirmedTransactions returns a channel which will be sent on as\n\t// new relevant transactions are seen within the network.\n\tUnconfirmedTransactions() chan *TransactionDetail\n\n\t// Cancel finalizes the subscription, cleaning up any resources\n\t// allocated.\n\tCancel()\n}\n\n// WalletController defines an abstract interface for controlling a local Pure\n// Go wallet, a local or remote wallet via an RPC mechanism, or possibly even\n// a daemon assisted hardware wallet. This interface serves the purpose of\n// allowing LightningWallet to be seamlessly compatible with several wallets\n// such as: uspv, btcwallet, Bitcoin Core, Electrum, etc. This interface then\n// serves as a \"base wallet\", with Lightning Network awareness taking place at\n// a \"higher\" level of abstraction. Essentially, an overlay wallet.\n// Implementors of this interface must closely adhere to the documented\n// behavior of all interface methods in order to ensure identical behavior\n// across all concrete implementations.",
      "length": 1137,
      "tokens": 167,
      "embedding": []
    },
    {
      "slug": "type WalletController interface {",
      "content": "type WalletController interface {\n\t// FetchInputInfo queries for the WalletController's knowledge of the\n\t// passed outpoint. If the base wallet determines this output is under\n\t// its control, then the original txout should be returned.  Otherwise,\n\t// a non-nil error value of ErrNotMine should be returned instead.\n\tFetchInputInfo(prevOut *wire.OutPoint) (*Utxo, error)\n\n\t// ScriptForOutput returns the address, witness program and redeem\n\t// script for a given UTXO. An error is returned if the UTXO does not\n\t// belong to our wallet or it is not a managed pubKey address.\n\tScriptForOutput(output *wire.TxOut) (waddrmgr.ManagedPubKeyAddress,\n\t\t[]byte, []byte, error)\n\n\t// ConfirmedBalance returns the sum of all the wallet's unspent outputs\n\t// that have at least confs confirmations. If confs is set to zero,\n\t// then all unspent outputs, including those currently in the mempool\n\t// will be included in the final sum. The account parameter serves as a\n\t// filter to retrieve the balance for a specific account. When empty,\n\t// the confirmed balance of all wallet accounts is returned.\n\t//\n\t// NOTE: Only witness outputs should be included in the computation of\n\t// the total spendable balance of the wallet. We require this as only\n\t// witness inputs can be used for funding channels.\n\tConfirmedBalance(confs int32, accountFilter string) (btcutil.Amount,\n\t\terror)\n\n\t// NewAddress returns the next external or internal address for the\n\t// wallet dictated by the value of the `change` parameter. If change is\n\t// true, then an internal address should be used, otherwise an external\n\t// address should be returned. The type of address returned is dictated\n\t// by the wallet's capabilities, and may be of type: p2sh, p2wkh,\n\t// p2wsh, etc. The account parameter must be non-empty as it determines\n\t// which account the address should be generated from.\n\tNewAddress(addrType AddressType, change bool,\n\t\taccount string) (btcutil.Address, error)\n\n\t// LastUnusedAddress returns the last *unused* address known by the\n\t// wallet. An address is unused if it hasn't received any payments.\n\t// This can be useful in UIs in order to continually show the\n\t// \"freshest\" address without having to worry about \"address inflation\"\n\t// caused by continual refreshing. Similar to NewAddress it can derive\n\t// a specified address type. By default, this is a non-change address.\n\t// The account parameter must be non-empty as it determines which\n\t// account the address should be generated from.\n\tLastUnusedAddress(addrType AddressType,\n\t\taccount string) (btcutil.Address, error)\n\n\t// IsOurAddress checks if the passed address belongs to this wallet\n\tIsOurAddress(a btcutil.Address) bool\n\n\t// AddressInfo returns the information about an address, if it's known\n\t// to this wallet.\n\tAddressInfo(a btcutil.Address) (waddrmgr.ManagedAddress, error)\n\n\t// ListAccounts retrieves all accounts belonging to the wallet by\n\t// default. A name and key scope filter can be provided to filter\n\t// through all of the wallet accounts and return only those matching.\n\tListAccounts(string, *waddrmgr.KeyScope) ([]*waddrmgr.AccountProperties,\n\t\terror)\n\n\t// RequiredReserve returns the minimum amount of satoshis that should be\n\t// kept in the wallet in order to fee bump anchor channels if necessary.\n\t// The value scales with the number of public anchor channels but is\n\t// capped at a maximum.\n\tRequiredReserve(uint32) btcutil.Amount\n\n\t// ListAddresses retrieves all the addresses along with their balance. An\n\t// account name filter can be provided to filter through all of the\n\t// wallet accounts and return the addresses of only those matching.\n\tListAddresses(string, bool) (AccountAddressMap, error)\n\n\t// ImportAccount imports an account backed by an account extended public\n\t// key. The master key fingerprint denotes the fingerprint of the root\n\t// key corresponding to the account public key (also known as the key\n\t// with derivation path m/). This may be required by some hardware\n\t// wallets for proper identification and signing.\n\t//\n\t// The address type can usually be inferred from the key's version, but\n\t// may be required for certain keys to map them into the proper scope.\n\t//\n\t// For BIP-0044 keys, an address type must be specified as we intend to\n\t// not support importing BIP-0044 keys into the wallet using the legacy\n\t// pay-to-pubkey-hash (P2PKH) scheme. A nested witness address type will\n\t// force the standard BIP-0049 derivation scheme, while a witness\n\t// address type will force the standard BIP-0084 derivation scheme.\n\t//\n\t// For BIP-0049 keys, an address type must also be specified to make a\n\t// distinction between the standard BIP-0049 address schema (nested\n\t// witness pubkeys everywhere) and our own BIP-0049Plus address schema\n\t// (nested pubkeys externally, witness pubkeys internally).\n\tImportAccount(name string, accountPubKey *hdkeychain.ExtendedKey,\n\t\tmasterKeyFingerprint uint32, addrType *waddrmgr.AddressType,\n\t\tdryRun bool) (*waddrmgr.AccountProperties, []btcutil.Address,\n\t\t[]btcutil.Address, error)\n\n\t// ImportPublicKey imports a single derived public key into the wallet.\n\t// The address type can usually be inferred from the key's version, but\n\t// in the case of legacy versions (xpub, tpub), an address type must be\n\t// specified as we intend to not support importing BIP-44 keys into the\n\t// wallet using the legacy pay-to-pubkey-hash (P2PKH) scheme.\n\tImportPublicKey(pubKey *btcec.PublicKey,\n\t\taddrType waddrmgr.AddressType) error\n\n\t// ImportTaprootScript imports a user-provided taproot script into the\n\t// wallet. The imported script will act as a pay-to-taproot address.\n\t//\n\t// NOTE: Taproot keys imported through this RPC currently _cannot_ be\n\t// used for funding PSBTs. Only tracking the balance and UTXOs is\n\t// currently supported.\n\tImportTaprootScript(scope waddrmgr.KeyScope,\n\t\ttapscript *waddrmgr.Tapscript) (waddrmgr.ManagedAddress, error)\n\n\t// SendOutputs funds, signs, and broadcasts a Bitcoin transaction paying\n\t// out to the specified outputs. In the case the wallet has insufficient\n\t// funds, or the outputs are non-standard, an error should be returned.\n\t// This method also takes the target fee expressed in sat/kw that should\n\t// be used when crafting the transaction.\n\t//\n\t// NOTE: This method requires the global coin selection lock to be held.\n\tSendOutputs(outputs []*wire.TxOut, feeRate chainfee.SatPerKWeight,\n\t\tminConfs int32, label string) (*wire.MsgTx, error)\n\n\t// CreateSimpleTx creates a Bitcoin transaction paying to the specified\n\t// outputs. The transaction is not broadcasted to the network. In the\n\t// case the wallet has insufficient funds, or the outputs are\n\t// non-standard, an error should be returned. This method also takes\n\t// the target fee expressed in sat/kw that should be used when crafting\n\t// the transaction.\n\t//\n\t// NOTE: The dryRun argument can be set true to create a tx that\n\t// doesn't alter the database. A tx created with this set to true\n\t// SHOULD NOT be broadcasted.\n\t//\n\t// NOTE: This method requires the global coin selection lock to be held.\n\tCreateSimpleTx(outputs []*wire.TxOut, feeRate chainfee.SatPerKWeight,\n\t\tminConfs int32, dryRun bool) (*txauthor.AuthoredTx, error)\n\n\t// ListUnspentWitness returns all unspent outputs which are version 0\n\t// witness programs. The 'minConfs' and 'maxConfs' parameters\n\t// indicate the minimum and maximum number of confirmations an output\n\t// needs in order to be returned by this method. Passing -1 as\n\t// 'minConfs' indicates that even unconfirmed outputs should be\n\t// returned. Using MaxInt32 as 'maxConfs' implies returning all\n\t// outputs with at least 'minConfs'. The account parameter serves as\n\t// a filter to retrieve the unspent outputs for a specific account.\n\t// When empty, the unspent outputs of all wallet accounts are returned.\n\t//\n\t// NOTE: This method requires the global coin selection lock to be held.\n\tListUnspentWitness(minConfs, maxConfs int32,\n\t\taccountFilter string) ([]*Utxo, error)\n\n\t// ListTransactionDetails returns a list of all transactions which are\n\t// relevant to the wallet over [startHeight;endHeight]. If start height\n\t// is greater than end height, the transactions will be retrieved in\n\t// reverse order. To include unconfirmed transactions, endHeight should\n\t// be set to the special value -1. This will return transactions from\n\t// the tip of the chain until the start height (inclusive) and\n\t// unconfirmed transactions. The account parameter serves as a filter to\n\t// retrieve the transactions relevant to a specific account. When\n\t// empty, transactions of all wallet accounts are returned.\n\tListTransactionDetails(startHeight, endHeight int32,\n\t\taccountFilter string) ([]*TransactionDetail, error)\n\n\t// LockOutpoint marks an outpoint as locked meaning it will no longer\n\t// be deemed as eligible for coin selection. Locking outputs are\n\t// utilized in order to avoid race conditions when selecting inputs for\n\t// usage when funding a channel.\n\t//\n\t// NOTE: This method requires the global coin selection lock to be held.\n\tLockOutpoint(o wire.OutPoint)\n\n\t// UnlockOutpoint unlocks a previously locked output, marking it\n\t// eligible for coin selection.\n\t//\n\t// NOTE: This method requires the global coin selection lock to be held.\n\tUnlockOutpoint(o wire.OutPoint)\n\n\t// LeaseOutput locks an output to the given ID, preventing it from being\n\t// available for any future coin selection attempts. The absolute time\n\t// of the lock's expiration is returned. The expiration of the lock can\n\t// be extended by successive invocations of this call. Outputs can be\n\t// unlocked before their expiration through `ReleaseOutput`.\n\t//\n\t// If the output is not known, wtxmgr.ErrUnknownOutput is returned. If\n\t// the output has already been locked to a different ID, then\n\t// wtxmgr.ErrOutputAlreadyLocked is returned.\n\t//\n\t// NOTE: This method requires the global coin selection lock to be held.\n\tLeaseOutput(id wtxmgr.LockID, op wire.OutPoint,\n\t\tduration time.Duration) (time.Time, []byte, btcutil.Amount,\n\t\terror)\n\n\t// ReleaseOutput unlocks an output, allowing it to be available for coin\n\t// selection if it remains unspent. The ID should match the one used to\n\t// originally lock the output.\n\t//\n\t// NOTE: This method requires the global coin selection lock to be held.\n\tReleaseOutput(id wtxmgr.LockID, op wire.OutPoint) error\n\n\t// ListLeasedOutputs returns a list of all currently locked outputs.\n\tListLeasedOutputs() ([]*base.ListLeasedOutputResult, error)\n\n\t// PublishTransaction performs cursory validation (dust checks, etc),\n\t// then finally broadcasts the passed transaction to the Bitcoin network.\n\t// If the transaction is rejected because it is conflicting with an\n\t// already known transaction, ErrDoubleSpend is returned. If the\n\t// transaction is already known (published already), no error will be\n\t// returned. Other error returned depends on the currently active chain\n\t// backend. It takes an optional label which will save a label with the\n\t// published transaction.\n\tPublishTransaction(tx *wire.MsgTx, label string) error\n\n\t// LabelTransaction adds a label to a transaction. If the tx already\n\t// has a label, this call will fail unless the overwrite parameter\n\t// is set. Labels must not be empty, and they are limited to 500 chars.\n\tLabelTransaction(hash chainhash.Hash, label string, overwrite bool) error\n\n\t// FetchTx attempts to fetch a transaction in the wallet's database\n\t// identified by the passed transaction hash. If the transaction can't\n\t// be found, then a nil pointer is returned.\n\tFetchTx(chainhash.Hash) (*wire.MsgTx, error)\n\n\t// RemoveDescendants attempts to remove any transaction from the\n\t// wallet's tx store (that may be unconfirmed) that spends outputs\n\t// created by the passed transaction. This remove propagates\n\t// recursively down the chain of descendent transactions.\n\tRemoveDescendants(*wire.MsgTx) error\n\n\t// FundPsbt creates a fully populated PSBT packet that contains enough\n\t// inputs to fund the outputs specified in the passed in packet with the\n\t// specified fee rate. If there is change left, a change output from the\n\t// internal wallet is added and the index of the change output is\n\t// returned. Otherwise no additional output is created and the index -1\n\t// is returned. If no custom change scope is specified, the BIP0084 will\n\t// be used for default accounts and single imported public keys. For\n\t// custom account, no key scope should be provided as the coin selection\n\t// key scope will always be used to generate the change address.\n\t//\n\t// NOTE: If the packet doesn't contain any inputs, coin selection is\n\t// performed automatically. The account parameter must be non-empty as\n\t// it determines which set of coins are eligible for coin selection. If\n\t// the packet does contain any inputs, it is assumed that full coin\n\t// selection happened externally and no additional inputs are added. If\n\t// the specified inputs aren't enough to fund the outputs with the given\n\t// fee rate, an error is returned. No lock lease is acquired for any of\n\t// the selected/validated inputs. It is in the caller's responsibility\n\t// to lock the inputs before handing them out.\n\tFundPsbt(packet *psbt.Packet, minConfs int32,\n\t\tfeeRate chainfee.SatPerKWeight, account string,\n\t\tchangeScope *waddrmgr.KeyScope) (int32, error)\n\n\t// SignPsbt expects a partial transaction with all inputs and outputs\n\t// fully declared and tries to sign all unsigned inputs that have all\n\t// required fields (UTXO information, BIP32 derivation information,\n\t// witness or sig scripts) set.\n\t// If no error is returned, the PSBT is ready to be given to the next\n\t// signer or to be finalized if lnd was the last signer.\n\t//\n\t// NOTE: This method only signs inputs (and only those it can sign), it\n\t// does not perform any other tasks (such as coin selection, UTXO\n\t// locking or input/output/fee value validation, PSBT finalization). Any\n\t// input that is incomplete will be skipped.\n\tSignPsbt(packet *psbt.Packet) ([]uint32, error)\n\n\t// FinalizePsbt expects a partial transaction with all inputs and\n\t// outputs fully declared and tries to sign all inputs that belong to\n\t// the specified account. Lnd must be the last signer of the\n\t// transaction. That means, if there are any unsigned non-witness inputs\n\t// or inputs without UTXO information attached or inputs without witness\n\t// data that do not belong to lnd's wallet, this method will fail. If no\n\t// error is returned, the PSBT is ready to be extracted and the final TX\n\t// within to be broadcast.\n\t//\n\t// NOTE: This method does NOT publish the transaction after it's been\n\t// finalized successfully.\n\tFinalizePsbt(packet *psbt.Packet, account string) error\n\n\t// SubscribeTransactions returns a TransactionSubscription client which\n\t// is capable of receiving async notifications as new transactions\n\t// related to the wallet are seen within the network, or found in\n\t// blocks.\n\t//\n\t// NOTE: a non-nil error should be returned if notifications aren't\n\t// supported.\n\t//\n\t// TODO(roasbeef): make distinct interface?\n\tSubscribeTransactions() (TransactionSubscription, error)\n\n\t// IsSynced returns a boolean indicating if from the PoV of the wallet,\n\t// it has fully synced to the current best block in the main chain.\n\t// It also returns an int64 indicating the timestamp of the best block\n\t// known to the wallet, expressed in Unix epoch time\n\tIsSynced() (bool, int64, error)\n\n\t// GetRecoveryInfo returns a boolean indicating whether the wallet is\n\t// started in recovery mode. It also returns a float64 indicating the\n\t// recovery progress made so far.\n\tGetRecoveryInfo() (bool, float64, error)\n\n\t// Start initializes the wallet, making any necessary connections,\n\t// starting up required goroutines etc.\n\tStart() error\n\n\t// Stop signals the wallet for shutdown. Shutdown may entail closing\n\t// any active sockets, database handles, stopping goroutines, etc.\n\tStop() error\n\n\t// BackEnd returns a name for the wallet's backing chain service,\n\t// which could be e.g. btcd, bitcoind, neutrino, or another consensus\n\t// service.\n\tBackEnd() string\n}\n\n// BlockChainIO is a dedicated source which will be used to obtain queries\n// related to the current state of the blockchain. The data returned by each of\n// the defined methods within this interface should always return the most up\n// to date data possible.\n//\n// TODO(roasbeef): move to diff package perhaps?\n// TODO(roasbeef): move publish txn here?",
      "length": 16004,
      "tokens": 2455,
      "embedding": []
    },
    {
      "slug": "type BlockChainIO interface {",
      "content": "type BlockChainIO interface {\n\t// GetBestBlock returns the current height and block hash of the valid\n\t// most-work chain the implementation is aware of.\n\tGetBestBlock() (*chainhash.Hash, int32, error)\n\n\t// GetUtxo attempts to return the passed outpoint if it's still a\n\t// member of the utxo set. The passed height hint should be the \"birth\n\t// height\" of the passed outpoint. The script passed should be the\n\t// script that the outpoint creates. In the case that the output is in\n\t// the UTXO set, then the output corresponding to that output is\n\t// returned.  Otherwise, a non-nil error will be returned.\n\t// As for some backends this call can initiate a rescan, the passed\n\t// cancel channel can be closed to abort the call.\n\tGetUtxo(op *wire.OutPoint, pkScript []byte, heightHint uint32,\n\t\tcancel <-chan struct{}) (*wire.TxOut, error)\n\n\t// GetBlockHash returns the hash of the block in the best blockchain\n\t// at the given height.\n\tGetBlockHash(blockHeight int64) (*chainhash.Hash, error)\n\n\t// GetBlock returns the block in the main chain identified by the given\n\t// hash.\n\tGetBlock(blockHash *chainhash.Hash) (*wire.MsgBlock, error)\n}\n\n// MessageSigner represents an abstract object capable of signing arbitrary\n// messages. The capabilities of this interface are used to sign announcements\n// to the network, or just arbitrary messages that leverage the wallet's keys\n// to attest to some message.",
      "length": 1347,
      "tokens": 213,
      "embedding": []
    },
    {
      "slug": "type MessageSigner interface {",
      "content": "type MessageSigner interface {\n\t// SignMessage attempts to sign a target message with the private key\n\t// described in the key locator. If the target private key is unable to\n\t// be found, then an error will be returned. The actual digest signed is\n\t// the single or double SHA-256 of the passed message.\n\tSignMessage(keyLoc keychain.KeyLocator, msg []byte,\n\t\tdoubleHash bool) (*ecdsa.Signature, error)\n}\n\n// WalletDriver represents a \"driver\" for a particular concrete\n// WalletController implementation. A driver is identified by a globally unique\n// string identifier along with a 'New()' method which is responsible for\n// initializing a particular WalletController concrete implementation.",
      "length": 652,
      "tokens": 98,
      "embedding": []
    },
    {
      "slug": "type WalletDriver struct {",
      "content": "type WalletDriver struct {\n\t// WalletType is a string which uniquely identifies the\n\t// WalletController that this driver, drives.\n\tWalletType string\n\n\t// New creates a new instance of a concrete WalletController\n\t// implementation given a variadic set up arguments. The function takes\n\t// a variadic number of interface parameters in order to provide\n\t// initialization flexibility, thereby accommodating several potential\n\t// WalletController implementations.\n\tNew func(args ...interface{}) (WalletController, error)\n\n\t// BackEnds returns a list of available chain service drivers for the\n\t// wallet driver. This could be e.g. bitcoind, btcd, neutrino, etc.\n\tBackEnds func() []string\n}\n\nvar (\n\twallets     = make(map[string]*WalletDriver)\n\tregisterMtx sync.Mutex\n)\n\n// RegisteredWallets returns a slice of all currently registered notifiers.\n//\n// NOTE: This function is safe for concurrent access.",
      "length": 850,
      "tokens": 119,
      "embedding": []
    },
    {
      "slug": "func RegisteredWallets() []*WalletDriver {",
      "content": "func RegisteredWallets() []*WalletDriver {\n\tregisterMtx.Lock()\n\tdefer registerMtx.Unlock()\n\n\tregisteredWallets := make([]*WalletDriver, 0, len(wallets))\n\tfor _, wallet := range wallets {\n\t\tregisteredWallets = append(registeredWallets, wallet)\n\t}\n\n\treturn registeredWallets\n}\n\n// RegisterWallet registers a WalletDriver which is capable of driving a\n// concrete WalletController interface. In the case that this driver has\n// already been registered, an error is returned.\n//\n// NOTE: This function is safe for concurrent access.",
      "length": 470,
      "tokens": 63,
      "embedding": []
    },
    {
      "slug": "func RegisterWallet(driver *WalletDriver) error {",
      "content": "func RegisterWallet(driver *WalletDriver) error {\n\tregisterMtx.Lock()\n\tdefer registerMtx.Unlock()\n\n\tif _, ok := wallets[driver.WalletType]; ok {\n\t\treturn fmt.Errorf(\"wallet already registered\")\n\t}\n\n\twallets[driver.WalletType] = driver\n\n\treturn nil\n}\n\n// SupportedWallets returns a slice of strings that represents the wallet\n// drivers that have been registered and are therefore supported.\n//\n// NOTE: This function is safe for concurrent access.",
      "length": 382,
      "tokens": 52,
      "embedding": []
    },
    {
      "slug": "func SupportedWallets() []string {",
      "content": "func SupportedWallets() []string {\n\tregisterMtx.Lock()\n\tdefer registerMtx.Unlock()\n\n\tsupportedWallets := make([]string, 0, len(wallets))\n\tfor walletName := range wallets {\n\t\tsupportedWallets = append(supportedWallets, walletName)\n\t}\n\n\treturn supportedWallets\n}\n",
      "length": 216,
      "tokens": 22,
      "embedding": []
    }
  ]
}