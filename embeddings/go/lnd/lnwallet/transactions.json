{
  "filepath": "../implementations/go/lnd/lnwallet/transactions.go",
  "package": "lnwallet",
  "sections": [
    {
      "slug": "func CreateHtlcSuccessTx(chanType channeldb.ChannelType, initiator bool,",
      "content": "func CreateHtlcSuccessTx(chanType channeldb.ChannelType, initiator bool,\n\thtlcOutput wire.OutPoint, htlcAmt btcutil.Amount, csvDelay,\n\tleaseExpiry uint32, revocationKey, delayKey *btcec.PublicKey) (\n\t*wire.MsgTx, error) {\n\n\t// Create a version two transaction (as the success version of this\n\t// spends an output with a CSV timeout).\n\tsuccessTx := wire.NewMsgTx(2)\n\n\t// The input to the transaction is the outpoint that creates the\n\t// original HTLC on the sender's commitment transaction. Set the\n\t// sequence number based on the channel type.\n\ttxin := &wire.TxIn{\n\t\tPreviousOutPoint: htlcOutput,\n\t\tSequence:         HtlcSecondLevelInputSequence(chanType),\n\t}\n\tsuccessTx.AddTxIn(txin)\n\n\t// Next, we'll generate the script used as the output for all second\n\t// level HTLC which forces a covenant w.r.t what can be done with all\n\t// HTLC outputs.\n\tscript, err := SecondLevelHtlcScript(\n\t\tchanType, initiator, revocationKey, delayKey, csvDelay,\n\t\tleaseExpiry,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Finally, the output is simply the amount of the HTLC (minus the\n\t// required fees), paying to the timeout script.\n\tsuccessTx.AddTxOut(&wire.TxOut{\n\t\tValue:    int64(htlcAmt),\n\t\tPkScript: script.PkScript,\n\t})\n\n\treturn successTx, nil\n}\n\n// CreateHtlcTimeoutTx creates a transaction that spends the HTLC output on the\n// commitment transaction of the peer that created an HTLC (the sender). This\n// transaction essentially acts as an off-chain covenant as it spends a 2-of-2\n// multi-sig output. This output requires a signature from both the sender and\n// receiver of the HTLC. By using a distinct transaction, we're able to\n// uncouple the timeout and delay clauses of the HTLC contract. This\n// transaction is locked with an absolute lock-time so the sender can only\n// attempt to claim the output using it after the lock time has passed.\n//\n// In order to spend the HTLC output, the witness for the passed transaction\n// should be:\n// * <0> <sender sig> <receiver sig> <0>\n//\n// NOTE: The passed amount for the HTLC should take into account the required\n// fee rate at the time the HTLC was created. The fee should be able to\n// entirely pay for this (tiny: 1-in 1-out) transaction.",
      "length": 2061,
      "tokens": 326,
      "embedding": []
    },
    {
      "slug": "func CreateHtlcTimeoutTx(chanType channeldb.ChannelType, initiator bool,",
      "content": "func CreateHtlcTimeoutTx(chanType channeldb.ChannelType, initiator bool,\n\thtlcOutput wire.OutPoint, htlcAmt btcutil.Amount,\n\tcltvExpiry, csvDelay, leaseExpiry uint32,\n\trevocationKey, delayKey *btcec.PublicKey) (*wire.MsgTx, error) {\n\n\t// Create a version two transaction (as the success version of this\n\t// spends an output with a CSV timeout), and set the lock-time to the\n\t// specified absolute lock-time in blocks.\n\ttimeoutTx := wire.NewMsgTx(2)\n\ttimeoutTx.LockTime = cltvExpiry\n\n\t// The input to the transaction is the outpoint that creates the\n\t// original HTLC on the sender's commitment transaction. Set the\n\t// sequence number based on the channel type.\n\ttxin := &wire.TxIn{\n\t\tPreviousOutPoint: htlcOutput,\n\t\tSignatureScript:  []byte{},\n\t\tWitness:          [][]byte{},\n\t\tSequence:         HtlcSecondLevelInputSequence(chanType),\n\t}\n\ttimeoutTx.AddTxIn(txin)\n\n\t// Next, we'll generate the script used as the output for all second\n\t// level HTLC which forces a covenant w.r.t what can be done with all\n\t// HTLC outputs.\n\tscript, err := SecondLevelHtlcScript(\n\t\tchanType, initiator, revocationKey, delayKey, csvDelay,\n\t\tleaseExpiry,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Finally, the output is simply the amount of the HTLC (minus the\n\t// required fees), paying to the regular second level HTLC script.\n\ttimeoutTx.AddTxOut(&wire.TxOut{\n\t\tValue:    int64(htlcAmt),\n\t\tPkScript: script.PkScript,\n\t})\n\n\treturn timeoutTx, nil\n}\n\n// SetStateNumHint encodes the current state number within the passed\n// commitment transaction by re-purposing the locktime and sequence fields in\n// the commitment transaction to encode the obfuscated state number.  The state\n// number is encoded using 48 bits. The lower 24 bits of the lock time are the\n// lower 24 bits of the obfuscated state number and the lower 24 bits of the\n// sequence field are the higher 24 bits. Finally before encoding, the\n// obfuscator is XOR'd against the state number in order to hide the exact\n// state number from the PoV of outside parties.",
      "length": 1892,
      "tokens": 280,
      "embedding": []
    },
    {
      "slug": "func SetStateNumHint(commitTx *wire.MsgTx, stateNum uint64,",
      "content": "func SetStateNumHint(commitTx *wire.MsgTx, stateNum uint64,\n\tobfuscator [StateHintSize]byte) error {\n\n\t// With the current schema we are only able to encode state num\n\t// hints up to 2^48. Therefore if the passed height is greater than our\n\t// state hint ceiling, then exit early.\n\tif stateNum > maxStateHint {\n\t\treturn fmt.Errorf(\"unable to encode state, %v is greater \"+\n\t\t\t\"state num that max of %v\", stateNum, maxStateHint)\n\t}\n\n\tif len(commitTx.TxIn) != 1 {\n\t\treturn fmt.Errorf(\"commitment tx must have exactly 1 input, \"+\n\t\t\t\"instead has %v\", len(commitTx.TxIn))\n\t}\n\n\t// Convert the obfuscator into a uint64, then XOR that against the\n\t// targeted height in order to obfuscate the state number of the\n\t// commitment transaction in the case that either commitment\n\t// transaction is broadcast directly on chain.\n\tvar obfs [8]byte\n\tcopy(obfs[2:], obfuscator[:])\n\txorInt := binary.BigEndian.Uint64(obfs[:])\n\n\tstateNum = stateNum ^ xorInt\n\n\t// Set the height bit of the sequence number in order to disable any\n\t// sequence locks semantics.\n\tcommitTx.TxIn[0].Sequence = uint32(stateNum>>24) | wire.SequenceLockTimeDisabled\n\tcommitTx.LockTime = uint32(stateNum&0xFFFFFF) | TimelockShift\n\n\treturn nil\n}\n\n// GetStateNumHint recovers the current state number given a commitment\n// transaction which has previously had the state number encoded within it via\n// setStateNumHint and a shared obfuscator.\n//\n// See setStateNumHint for further details w.r.t exactly how the state-hints\n// are encoded.",
      "length": 1394,
      "tokens": 208,
      "embedding": []
    },
    {
      "slug": "func GetStateNumHint(commitTx *wire.MsgTx, obfuscator [StateHintSize]byte) uint64 {",
      "content": "func GetStateNumHint(commitTx *wire.MsgTx, obfuscator [StateHintSize]byte) uint64 {\n\t// Convert the obfuscator into a uint64, this will be used to\n\t// de-obfuscate the final recovered state number.\n\tvar obfs [8]byte\n\tcopy(obfs[2:], obfuscator[:])\n\txorInt := binary.BigEndian.Uint64(obfs[:])\n\n\t// Retrieve the state hint from the sequence number and locktime\n\t// of the transaction.\n\tstateNumXor := uint64(commitTx.TxIn[0].Sequence&0xFFFFFF) << 24\n\tstateNumXor |= uint64(commitTx.LockTime & 0xFFFFFF)\n\n\t// Finally, to obtain the final state number, we XOR by the obfuscator\n\t// value to de-obfuscate the state number.\n\treturn stateNumXor ^ xorInt\n}\n",
      "length": 549,
      "tokens": 77,
      "embedding": []
    }
  ]
}