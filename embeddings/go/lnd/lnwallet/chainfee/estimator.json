{
  "filepath": "../implementations/go/lnd/lnwallet/chainfee/estimator.go",
  "package": "chainfee",
  "sections": [
    {
      "slug": "type Estimator interface {",
      "content": "type Estimator interface {\n\t// EstimateFeePerKW takes in a target for the number of blocks until an\n\t// initial confirmation and returns the estimated fee expressed in\n\t// sat/kw.\n\tEstimateFeePerKW(numBlocks uint32) (SatPerKWeight, error)\n\n\t// Start signals the Estimator to start any processes or goroutines\n\t// it needs to perform its duty.\n\tStart() error\n\n\t// Stop stops any spawned goroutines and cleans up the resources used\n\t// by the fee estimator.\n\tStop() error\n\n\t// RelayFeePerKW returns the minimum fee rate required for transactions\n\t// to be relayed. This is also the basis for calculation of the dust\n\t// limit.\n\tRelayFeePerKW() SatPerKWeight\n}\n\n// StaticEstimator will return a static value for all fee calculation requests.\n// It is designed to be replaced by a proper fee calculation implementation.\n// The fees are not accessible directly, because changing them would not be\n// thread safe.",
      "length": 858,
      "tokens": 138,
      "embedding": []
    },
    {
      "slug": "type StaticEstimator struct {",
      "content": "type StaticEstimator struct {\n\t// feePerKW is the static fee rate in satoshis-per-vbyte that will be\n\t// returned by this fee estimator.\n\tfeePerKW SatPerKWeight\n\n\t// relayFee is the minimum fee rate required for transactions to be\n\t// relayed.\n\trelayFee SatPerKWeight\n}\n\n// NewStaticEstimator returns a new static fee estimator instance.",
      "length": 298,
      "tokens": 46,
      "embedding": []
    },
    {
      "slug": "func NewStaticEstimator(feePerKW, relayFee SatPerKWeight) *StaticEstimator {",
      "content": "func NewStaticEstimator(feePerKW, relayFee SatPerKWeight) *StaticEstimator {\n\treturn &StaticEstimator{\n\t\tfeePerKW: feePerKW,\n\t\trelayFee: relayFee,\n\t}\n}\n\n// EstimateFeePerKW will return a static value for fee calculations.\n//\n// NOTE: This method is part of the Estimator interface.",
      "length": 196,
      "tokens": 29,
      "embedding": []
    },
    {
      "slug": "func (e StaticEstimator) EstimateFeePerKW(numBlocks uint32) (SatPerKWeight, error) {",
      "content": "func (e StaticEstimator) EstimateFeePerKW(numBlocks uint32) (SatPerKWeight, error) {\n\treturn e.feePerKW, nil\n}\n\n// RelayFeePerKW returns the minimum fee rate required for transactions to be\n// relayed.\n//\n// NOTE: This method is part of the Estimator interface.",
      "length": 170,
      "tokens": 29,
      "embedding": []
    },
    {
      "slug": "func (e StaticEstimator) RelayFeePerKW() SatPerKWeight {",
      "content": "func (e StaticEstimator) RelayFeePerKW() SatPerKWeight {\n\treturn e.relayFee\n}\n\n// Start signals the Estimator to start any processes or goroutines\n// it needs to perform its duty.\n//\n// NOTE: This method is part of the Estimator interface.",
      "length": 176,
      "tokens": 32,
      "embedding": []
    },
    {
      "slug": "func (e StaticEstimator) Start() error {",
      "content": "func (e StaticEstimator) Start() error {\n\treturn nil\n}\n\n// Stop stops any spawned goroutines and cleans up the resources used\n// by the fee estimator.\n//\n// NOTE: This method is part of the Estimator interface.",
      "length": 163,
      "tokens": 31,
      "embedding": []
    },
    {
      "slug": "func (e StaticEstimator) Stop() error {",
      "content": "func (e StaticEstimator) Stop() error {\n\treturn nil\n}\n\n// A compile-time assertion to ensure that StaticFeeEstimator implements the\n// Estimator interface.\nvar _ Estimator = (*StaticEstimator)(nil)\n\n// BtcdEstimator is an implementation of the Estimator interface backed\n// by the RPC interface of an active btcd node. This implementation will proxy\n// any fee estimation requests to btcd's RPC interface.",
      "length": 356,
      "tokens": 54,
      "embedding": []
    },
    {
      "slug": "type BtcdEstimator struct {",
      "content": "type BtcdEstimator struct {\n\t// fallbackFeePerKW is the fall back fee rate in sat/kw that is returned\n\t// if the fee estimator does not yet have enough data to actually\n\t// produce fee estimates.\n\tfallbackFeePerKW SatPerKWeight\n\n\t// minFeeManager is used to query the current minimum fee, in sat/kw,\n\t// that we should enforce. This will be used to determine fee rate for\n\t// a transaction when the estimated fee rate is too low to allow the\n\t// transaction to propagate through the network.\n\tminFeeManager *minFeeManager\n\n\tbtcdConn *rpcclient.Client\n}\n\n// NewBtcdEstimator creates a new BtcdEstimator given a fully populated\n// rpc config that is able to successfully connect and authenticate with the\n// btcd node, and also a fall back fee rate. The fallback fee rate is used in\n// the occasion that the estimator has insufficient data, or returns zero for a\n// fee estimate.",
      "length": 831,
      "tokens": 141,
      "embedding": []
    },
    {
      "slug": "func NewBtcdEstimator(rpcConfig rpcclient.ConnConfig,",
      "content": "func NewBtcdEstimator(rpcConfig rpcclient.ConnConfig,\n\tfallBackFeeRate SatPerKWeight) (*BtcdEstimator, error) {\n\n\trpcConfig.DisableConnectOnNew = true\n\trpcConfig.DisableAutoReconnect = false\n\tchainConn, err := rpcclient.New(&rpcConfig, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &BtcdEstimator{\n\t\tfallbackFeePerKW: fallBackFeeRate,\n\t\tbtcdConn:         chainConn,\n\t}, nil\n}\n\n// Start signals the Estimator to start any processes or goroutines\n// it needs to perform its duty.\n//\n// NOTE: This method is part of the Estimator interface.",
      "length": 471,
      "tokens": 63,
      "embedding": []
    },
    {
      "slug": "func (b *BtcdEstimator) Start() error {",
      "content": "func (b *BtcdEstimator) Start() error {\n\tif err := b.btcdConn.Connect(20); err != nil {\n\t\treturn err\n\t}\n\n\t// Once the connection to the backend node has been established, we\n\t// can initialise the minimum relay fee manager which queries the\n\t// chain backend for the minimum relay fee on construction.\n\tminRelayFeeManager, err := newMinFeeManager(\n\t\tdefaultUpdateInterval, b.fetchMinRelayFee,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\tb.minFeeManager = minRelayFeeManager\n\n\treturn nil\n}\n\n// fetchMinRelayFee fetches and returns the minimum relay fee in sat/kb from\n// the btcd backend.",
      "length": 521,
      "tokens": 81,
      "embedding": []
    },
    {
      "slug": "func (b *BtcdEstimator) fetchMinRelayFee() (SatPerKWeight, error) {",
      "content": "func (b *BtcdEstimator) fetchMinRelayFee() (SatPerKWeight, error) {\n\tinfo, err := b.btcdConn.GetInfo()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\trelayFee, err := btcutil.NewAmount(info.RelayFee)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// The fee rate is expressed in sat/kb, so we'll manually convert it to\n\t// our desired sat/kw rate.\n\treturn SatPerKVByte(relayFee).FeePerKWeight(), nil\n}\n\n// Stop stops any spawned goroutines and cleans up the resources used\n// by the fee estimator.\n//\n// NOTE: This method is part of the Estimator interface.",
      "length": 453,
      "tokens": 77,
      "embedding": []
    },
    {
      "slug": "func (b *BtcdEstimator) Stop() error {",
      "content": "func (b *BtcdEstimator) Stop() error {\n\tb.btcdConn.Shutdown()\n\n\treturn nil\n}\n\n// EstimateFeePerKW takes in a target for the number of blocks until an initial\n// confirmation and returns the estimated fee expressed in sat/kw.\n//\n// NOTE: This method is part of the Estimator interface.",
      "length": 237,
      "tokens": 39,
      "embedding": []
    },
    {
      "slug": "func (b *BtcdEstimator) EstimateFeePerKW(numBlocks uint32) (SatPerKWeight, error) {",
      "content": "func (b *BtcdEstimator) EstimateFeePerKW(numBlocks uint32) (SatPerKWeight, error) {\n\tfeeEstimate, err := b.fetchEstimate(numBlocks)\n\tswitch {\n\t// If the estimator doesn't have enough data, or returns an error, then\n\t// to return a proper value, then we'll return the default fall back\n\t// fee rate.\n\tcase err != nil:\n\t\tlog.Errorf(\"unable to query estimator: %v\", err)\n\t\tfallthrough\n\n\tcase feeEstimate == 0:\n\t\treturn b.fallbackFeePerKW, nil\n\t}\n\n\treturn feeEstimate, nil\n}\n\n// RelayFeePerKW returns the minimum fee rate required for transactions to be\n// relayed.\n//\n// NOTE: This method is part of the Estimator interface.",
      "length": 518,
      "tokens": 83,
      "embedding": []
    },
    {
      "slug": "func (b *BtcdEstimator) RelayFeePerKW() SatPerKWeight {",
      "content": "func (b *BtcdEstimator) RelayFeePerKW() SatPerKWeight {\n\treturn b.minFeeManager.fetchMinFee()\n}\n\n// fetchEstimate returns a fee estimate for a transaction to be confirmed in\n// confTarget blocks. The estimate is returned in sat/kw.",
      "length": 171,
      "tokens": 25,
      "embedding": []
    },
    {
      "slug": "func (b *BtcdEstimator) fetchEstimate(confTarget uint32) (SatPerKWeight, error) {",
      "content": "func (b *BtcdEstimator) fetchEstimate(confTarget uint32) (SatPerKWeight, error) {\n\t// First, we'll fetch the estimate for our confirmation target.\n\tbtcPerKB, err := b.btcdConn.EstimateFee(int64(confTarget))\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Next, we'll convert the returned value to satoshis, as it's\n\t// currently returned in BTC.\n\tsatPerKB, err := btcutil.NewAmount(btcPerKB)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Since we use fee rates in sat/kw internally, we'll convert the\n\t// estimated fee rate from its sat/kb representation to sat/kw.\n\tsatPerKw := SatPerKVByte(satPerKB).FeePerKWeight()\n\n\t// Finally, we'll enforce our fee floor.\n\tif satPerKw < b.minFeeManager.fetchMinFee() {\n\t\tlog.Debugf(\"Estimated fee rate of %v sat/kw is too low, \"+\n\t\t\t\"using fee floor of %v sat/kw instead\", satPerKw,\n\t\t\tb.minFeeManager)\n\t\tsatPerKw = b.minFeeManager.fetchMinFee()\n\t}\n\n\tlog.Debugf(\"Returning %v sat/kw for conf target of %v\",\n\t\tint64(satPerKw), confTarget)\n\n\treturn satPerKw, nil\n}\n\n// A compile-time assertion to ensure that BtcdEstimator implements the\n// Estimator interface.\nvar _ Estimator = (*BtcdEstimator)(nil)\n\n// BitcoindEstimator is an implementation of the Estimator interface backed by\n// the RPC interface of an active bitcoind node. This implementation will proxy\n// any fee estimation requests to bitcoind's RPC interface.",
      "length": 1227,
      "tokens": 177,
      "embedding": []
    },
    {
      "slug": "type BitcoindEstimator struct {",
      "content": "type BitcoindEstimator struct {\n\t// fallbackFeePerKW is the fallback fee rate in sat/kw that is returned\n\t// if the fee estimator does not yet have enough data to actually\n\t// produce fee estimates.\n\tfallbackFeePerKW SatPerKWeight\n\n\t// minFeeManager is used to keep track of the minimum fee, in sat/kw,\n\t// that we should enforce. This will be used as the default fee rate\n\t// for a transaction when the estimated fee rate is too low to allow\n\t// the transaction to propagate through the network.\n\tminFeeManager *minFeeManager\n\n\t// feeMode is the estimate_mode to use when calling \"estimatesmartfee\".\n\t// It can be either \"ECONOMICAL\" or \"CONSERVATIVE\", and it's default\n\t// to \"CONSERVATIVE\".\n\tfeeMode string\n\n\tbitcoindConn *rpcclient.Client\n}\n\n// NewBitcoindEstimator creates a new BitcoindEstimator given a fully populated\n// rpc config that is able to successfully connect and authenticate with the\n// bitcoind node, and also a fall back fee rate. The fallback fee rate is used\n// in the occasion that the estimator has insufficient data, or returns zero\n// for a fee estimate.",
      "length": 1026,
      "tokens": 168,
      "embedding": []
    },
    {
      "slug": "func NewBitcoindEstimator(rpcConfig rpcclient.ConnConfig, feeMode string,",
      "content": "func NewBitcoindEstimator(rpcConfig rpcclient.ConnConfig, feeMode string,\n\tfallBackFeeRate SatPerKWeight) (*BitcoindEstimator, error) {\n\n\trpcConfig.DisableConnectOnNew = true\n\trpcConfig.DisableAutoReconnect = false\n\trpcConfig.DisableTLS = true\n\trpcConfig.HTTPPostMode = true\n\tchainConn, err := rpcclient.New(&rpcConfig, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &BitcoindEstimator{\n\t\tfallbackFeePerKW: fallBackFeeRate,\n\t\tbitcoindConn:     chainConn,\n\t\tfeeMode:          feeMode,\n\t}, nil\n}\n\n// Start signals the Estimator to start any processes or goroutines\n// it needs to perform its duty.\n//\n// NOTE: This method is part of the Estimator interface.",
      "length": 565,
      "tokens": 71,
      "embedding": []
    },
    {
      "slug": "func (b *BitcoindEstimator) Start() error {",
      "content": "func (b *BitcoindEstimator) Start() error {\n\t// Once the connection to the backend node has been established, we'll\n\t// initialise the minimum relay fee manager which will query\n\t// the backend node for its minimum mempool fee.\n\trelayFeeManager, err := newMinFeeManager(\n\t\tdefaultUpdateInterval,\n\t\tb.fetchMinMempoolFee,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\tb.minFeeManager = relayFeeManager\n\n\treturn nil\n}\n\n// fetchMinMempoolFee is used to fetch the minimum fee that the backend node\n// requires for a tx to enter its mempool. The returned fee will be the\n// maximum of the minimum relay fee and the minimum mempool fee.",
      "length": 559,
      "tokens": 92,
      "embedding": []
    },
    {
      "slug": "func (b *BitcoindEstimator) fetchMinMempoolFee() (SatPerKWeight, error) {",
      "content": "func (b *BitcoindEstimator) fetchMinMempoolFee() (SatPerKWeight, error) {\n\tresp, err := b.bitcoindConn.RawRequest(\"getmempoolinfo\", nil)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Parse the response to retrieve the min mempool fee in sat/KB.\n\t// mempoolminfee is the maximum of minrelaytxfee and\n\t// minimum mempool fee\n\tinfo := struct {\n\t\tMempoolMinFee float64 `json:\"mempoolminfee\"`\n\t}{}\n\tif err := json.Unmarshal(resp, &info); err != nil {\n\t\treturn 0, err\n\t}\n\n\tminMempoolFee, err := btcutil.NewAmount(info.MempoolMinFee)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// The fee rate is expressed in sat/kb, so we'll manually convert it to\n\t// our desired sat/kw rate.\n\treturn SatPerKVByte(minMempoolFee).FeePerKWeight(), nil\n}\n\n// Stop stops any spawned goroutines and cleans up the resources used\n// by the fee estimator.\n//\n// NOTE: This method is part of the Estimator interface.",
      "length": 773,
      "tokens": 123,
      "embedding": []
    },
    {
      "slug": "func (b *BitcoindEstimator) Stop() error {",
      "content": "func (b *BitcoindEstimator) Stop() error {\n\treturn nil\n}\n\n// EstimateFeePerKW takes in a target for the number of blocks until an initial\n// confirmation and returns the estimated fee expressed in sat/kw.\n//\n// NOTE: This method is part of the Estimator interface.",
      "length": 215,
      "tokens": 38,
      "embedding": []
    },
    {
      "slug": "func (b *BitcoindEstimator) EstimateFeePerKW(",
      "content": "func (b *BitcoindEstimator) EstimateFeePerKW(\n\tnumBlocks uint32) (SatPerKWeight, error) {\n\n\tif numBlocks > maxBlockTarget {\n\t\tlog.Debugf(\"conf target %d exceeds the max value, \"+\n\t\t\t\"use %d instead.\", numBlocks, maxBlockTarget,\n\t\t)\n\t\tnumBlocks = maxBlockTarget\n\t}\n\n\tfeeEstimate, err := b.fetchEstimate(numBlocks)\n\tswitch {\n\t// If the estimator doesn't have enough data, or returns an error, then\n\t// to return a proper value, then we'll return the default fall back\n\t// fee rate.\n\tcase err != nil:\n\t\tlog.Errorf(\"unable to query estimator: %v\", err)\n\t\tfallthrough\n\n\tcase feeEstimate == 0:\n\t\treturn b.fallbackFeePerKW, nil\n\t}\n\n\treturn feeEstimate, nil\n}\n\n// RelayFeePerKW returns the minimum fee rate required for transactions to be\n// relayed.\n//\n// NOTE: This method is part of the Estimator interface.",
      "length": 728,
      "tokens": 111,
      "embedding": []
    },
    {
      "slug": "func (b *BitcoindEstimator) RelayFeePerKW() SatPerKWeight {",
      "content": "func (b *BitcoindEstimator) RelayFeePerKW() SatPerKWeight {\n\treturn b.minFeeManager.fetchMinFee()\n}\n\n// fetchEstimate returns a fee estimate for a transaction to be confirmed in\n// confTarget blocks. The estimate is returned in sat/kw.",
      "length": 171,
      "tokens": 25,
      "embedding": []
    },
    {
      "slug": "func (b *BitcoindEstimator) fetchEstimate(confTarget uint32) (SatPerKWeight, error) {",
      "content": "func (b *BitcoindEstimator) fetchEstimate(confTarget uint32) (SatPerKWeight, error) {\n\t// First, we'll send an \"estimatesmartfee\" command as a raw request,\n\t// since it isn't supported by btcd but is available in bitcoind.\n\ttarget, err := json.Marshal(uint64(confTarget))\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// The mode must be either ECONOMICAL or CONSERVATIVE.\n\tmode, err := json.Marshal(b.feeMode)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tresp, err := b.bitcoindConn.RawRequest(\n\t\t\"estimatesmartfee\", []json.RawMessage{target, mode},\n\t)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Next, we'll parse the response to get the BTC per KB.\n\tfeeEstimate := struct {\n\t\tFeeRate float64 `json:\"feerate\"`\n\t}{}\n\terr = json.Unmarshal(resp, &feeEstimate)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Next, we'll convert the returned value to satoshis, as it's currently\n\t// returned in BTC.\n\tsatPerKB, err := btcutil.NewAmount(feeEstimate.FeeRate)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Since we use fee rates in sat/kw internally, we'll convert the\n\t// estimated fee rate from its sat/kb representation to sat/kw.\n\tsatPerKw := SatPerKVByte(satPerKB).FeePerKWeight()\n\n\t// Finally, we'll enforce our fee floor.\n\tminRelayFee := b.minFeeManager.fetchMinFee()\n\tif satPerKw < minRelayFee {\n\t\tlog.Debugf(\"Estimated fee rate of %v sat/kw is too low, \"+\n\t\t\t\"using fee floor of %v sat/kw instead\", satPerKw,\n\t\t\tminRelayFee)\n\n\t\tsatPerKw = minRelayFee\n\t}\n\n\tlog.Debugf(\"Returning %v sat/kw for conf target of %v\",\n\t\tint64(satPerKw), confTarget)\n\n\treturn satPerKw, nil\n}\n\n// A compile-time assertion to ensure that BitcoindEstimator implements the\n// Estimator interface.\nvar _ Estimator = (*BitcoindEstimator)(nil)\n\n// WebAPIFeeSource is an interface allows the WebAPIEstimator to query an\n// arbitrary HTTP-based fee estimator. Each new set/network will gain an\n// implementation of this interface in order to allow the WebAPIEstimator to\n// be fully generic in its logic.",
      "length": 1796,
      "tokens": 273,
      "embedding": []
    },
    {
      "slug": "type WebAPIFeeSource interface {",
      "content": "type WebAPIFeeSource interface {\n\t// GenQueryURL generates the full query URL. The value returned by this\n\t// method should be able to be used directly as a path for an HTTP GET\n\t// request.\n\tGenQueryURL() string\n\n\t// ParseResponse attempts to parse the body of the response generated\n\t// by the above query URL. Typically this will be JSON, but the\n\t// specifics are left to the WebAPIFeeSource implementation.\n\tParseResponse(r io.Reader) (map[uint32]uint32, error)\n}\n\n// SparseConfFeeSource is an implementation of the WebAPIFeeSource that utilizes\n// a user-specified fee estimation API for Bitcoin. It expects the response\n// to be in the JSON format: `fee_by_block_target: { ... }` where the value maps\n// block targets to fee estimates (in sat per kilovbyte).",
      "length": 718,
      "tokens": 116,
      "embedding": []
    },
    {
      "slug": "type SparseConfFeeSource struct {",
      "content": "type SparseConfFeeSource struct {\n\t// URL is the fee estimation API specified by the user.\n\tURL string\n}\n\n// GenQueryURL generates the full query URL. The value returned by this\n// method should be able to be used directly as a path for an HTTP GET\n// request.\n//\n// NOTE: Part of the WebAPIFeeSource interface.",
      "length": 269,
      "tokens": 52,
      "embedding": []
    },
    {
      "slug": "func (s SparseConfFeeSource) GenQueryURL() string {",
      "content": "func (s SparseConfFeeSource) GenQueryURL() string {\n\treturn s.URL\n}\n\n// ParseResponse attempts to parse the body of the response generated by the\n// above query URL. Typically this will be JSON, but the specifics are left to\n// the WebAPIFeeSource implementation.\n//\n// NOTE: Part of the WebAPIFeeSource interface.",
      "length": 255,
      "tokens": 43,
      "embedding": []
    },
    {
      "slug": "func (s SparseConfFeeSource) ParseResponse(r io.Reader) (map[uint32]uint32, error) {",
      "content": "func (s SparseConfFeeSource) ParseResponse(r io.Reader) (map[uint32]uint32, error) {\n\ttype jsonResp struct {\n\t\tFeeByBlockTarget map[uint32]uint32 `json:\"fee_by_block_target\"`\n\t}\n\n\tresp := jsonResp{\n\t\tFeeByBlockTarget: make(map[uint32]uint32),\n\t}\n\tjsonReader := json.NewDecoder(r)\n\tif err := jsonReader.Decode(&resp); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn resp.FeeByBlockTarget, nil\n}\n\n// A compile-time assertion to ensure that SparseConfFeeSource implements the\n// WebAPIFeeSource interface.\nvar _ WebAPIFeeSource = (*SparseConfFeeSource)(nil)\n\n// WebAPIEstimator is an implementation of the Estimator interface that\n// queries an HTTP-based fee estimation from an existing web API.",
      "length": 583,
      "tokens": 72,
      "embedding": []
    },
    {
      "slug": "type WebAPIEstimator struct {",
      "content": "type WebAPIEstimator struct {\n\tstarted sync.Once\n\tstopped sync.Once\n\n\t// apiSource is the backing web API source we'll use for our queries.\n\tapiSource WebAPIFeeSource\n\n\t// updateFeeTicker is the ticker responsible for updating the Estimator's\n\t// fee estimates every time it fires.\n\tupdateFeeTicker *time.Ticker\n\n\t// feeByBlockTarget is our cache for fees pulled from the API. When a\n\t// fee estimate request comes in, we pull the estimate from this array\n\t// rather than re-querying the API, to prevent an inadvertent DoS attack.\n\tfeesMtx          sync.Mutex\n\tfeeByBlockTarget map[uint32]uint32\n\n\t// noCache determines whether the web estimator should cache fee\n\t// estimates.\n\tnoCache bool\n\n\tquit chan struct{}\n\twg   sync.WaitGroup\n}\n\n// NewWebAPIEstimator creates a new WebAPIEstimator from a given URL and a\n// fallback default fee. The fees are updated whenever a new block is mined.",
      "length": 833,
      "tokens": 126,
      "embedding": []
    },
    {
      "slug": "func NewWebAPIEstimator(api WebAPIFeeSource, noCache bool) *WebAPIEstimator {",
      "content": "func NewWebAPIEstimator(api WebAPIFeeSource, noCache bool) *WebAPIEstimator {\n\treturn &WebAPIEstimator{\n\t\tapiSource:        api,\n\t\tfeeByBlockTarget: make(map[uint32]uint32),\n\t\tnoCache:          noCache,\n\t\tquit:             make(chan struct{}),\n\t}\n}\n\n// EstimateFeePerKW takes in a target for the number of blocks until an initial\n// confirmation and returns the estimated fee expressed in sat/kw.\n//\n// NOTE: This method is part of the Estimator interface.",
      "length": 367,
      "tokens": 48,
      "embedding": []
    },
    {
      "slug": "func (w *WebAPIEstimator) EstimateFeePerKW(numBlocks uint32) (",
      "content": "func (w *WebAPIEstimator) EstimateFeePerKW(numBlocks uint32) (\n\tSatPerKWeight, error) {\n\n\tif numBlocks > maxBlockTarget {\n\t\tnumBlocks = maxBlockTarget\n\t} else if numBlocks < minBlockTarget {\n\t\treturn 0, fmt.Errorf(\"conf target of %v is too low, minimum \"+\n\t\t\t\"accepted is %v\", numBlocks, minBlockTarget)\n\t}\n\n\t// Get fee estimates now if we don't refresh periodically.\n\tif w.noCache {\n\t\tw.updateFeeEstimates()\n\t}\n\n\tfeePerKb, err := w.getCachedFee(numBlocks)\n\n\t// If the estimator returns an error, a zero value fee rate will be\n\t// returned. We will log the error and return the fall back fee rate\n\t// instead.\n\tif err != nil {\n\t\tlog.Errorf(\"unable to query estimator: %v\", err)\n\t}\n\n\t// If the result is too low, then we'll clamp it to our current fee\n\t// floor.\n\tsatPerKw := SatPerKVByte(feePerKb).FeePerKWeight()\n\tif satPerKw < FeePerKwFloor {\n\t\tsatPerKw = FeePerKwFloor\n\t}\n\n\tlog.Debugf(\"Web API returning %v sat/kw for conf target of %v\",\n\t\tint64(satPerKw), numBlocks)\n\n\treturn satPerKw, nil\n}\n\n// Start signals the Estimator to start any processes or goroutines it needs\n// to perform its duty.\n//\n// NOTE: This method is part of the Estimator interface.",
      "length": 1055,
      "tokens": 170,
      "embedding": []
    },
    {
      "slug": "func (w *WebAPIEstimator) Start() error {",
      "content": "func (w *WebAPIEstimator) Start() error {\n\t// No update loop is needed when we don't cache.\n\tif w.noCache {\n\t\treturn nil\n\t}\n\n\tvar err error\n\tw.started.Do(func() {\n\t\tlog.Infof(\"Starting web API fee estimator\")\n\n\t\tw.updateFeeTicker = time.NewTicker(w.randomFeeUpdateTimeout())\n\t\tw.updateFeeEstimates()\n\n\t\tw.wg.Add(1)\n\t\tgo w.feeUpdateManager()\n\n\t})\n\treturn err\n}\n\n// Stop stops any spawned goroutines and cleans up the resources used by the\n// fee estimator.\n//\n// NOTE: This method is part of the Estimator interface.",
      "length": 451,
      "tokens": 65,
      "embedding": []
    },
    {
      "slug": "func (w *WebAPIEstimator) Stop() error {",
      "content": "func (w *WebAPIEstimator) Stop() error {\n\t// Update loop is not running when we don't cache.\n\tif w.noCache {\n\t\treturn nil\n\t}\n\n\tw.stopped.Do(func() {\n\t\tlog.Infof(\"Stopping web API fee estimator\")\n\n\t\tw.updateFeeTicker.Stop()\n\n\t\tclose(w.quit)\n\t\tw.wg.Wait()\n\t})\n\treturn nil\n}\n\n// RelayFeePerKW returns the minimum fee rate required for transactions to be\n// relayed.\n//\n// NOTE: This method is part of the Estimator interface.",
      "length": 362,
      "tokens": 55,
      "embedding": []
    },
    {
      "slug": "func (w *WebAPIEstimator) RelayFeePerKW() SatPerKWeight {",
      "content": "func (w *WebAPIEstimator) RelayFeePerKW() SatPerKWeight {\n\treturn FeePerKwFloor\n}\n\n// randomFeeUpdateTimeout returns a random timeout between minFeeUpdateTimeout\n// and maxFeeUpdateTimeout that will be used to determine how often the Estimator\n// should retrieve fresh fees from its API.",
      "length": 224,
      "tokens": 32,
      "embedding": []
    },
    {
      "slug": "func (w *WebAPIEstimator) randomFeeUpdateTimeout() time.Duration {",
      "content": "func (w *WebAPIEstimator) randomFeeUpdateTimeout() time.Duration {\n\tlower := int64(minFeeUpdateTimeout)\n\tupper := int64(maxFeeUpdateTimeout)\n\treturn time.Duration(prand.Int63n(upper-lower) + lower)\n}\n\n// getCachedFee takes a conf target and returns the cached fee rate. When the\n// fee rate cannot be found, it will search the cache by decrementing the conf\n// target until a fee rate is found. If still not found, it will return the fee\n// rate of the minimum conf target cached, in other words, the most expensive\n// fee rate it knows of.",
      "length": 464,
      "tokens": 77,
      "embedding": []
    },
    {
      "slug": "func (w *WebAPIEstimator) getCachedFee(numBlocks uint32) (uint32, error) {",
      "content": "func (w *WebAPIEstimator) getCachedFee(numBlocks uint32) (uint32, error) {\n\tw.feesMtx.Lock()\n\tdefer w.feesMtx.Unlock()\n\n\t// If the cache is empty, return an error.\n\tif len(w.feeByBlockTarget) == 0 {\n\t\treturn 0, fmt.Errorf(\"web API error: %w\", errEmptyCache)\n\t}\n\n\t// Search the conf target from the cache. We expect a query to the web\n\t// API has been made and the result has been cached at this point.\n\tfee, ok := w.feeByBlockTarget[numBlocks]\n\n\t// If the conf target can be found, exit early.\n\tif ok {\n\t\treturn fee, nil\n\t}\n\n\t// The conf target cannot be found. We will first search the cache\n\t// using a lower conf target. This is a conservative approach as the\n\t// fee rate returned will be larger than what's requested.\n\tfor target := numBlocks; target >= minBlockTarget; target-- {\n\t\tfee, ok := w.feeByBlockTarget[target]\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tlog.Warnf(\"Web API does not have a fee rate for target=%d, \"+\n\t\t\t\"using the fee rate for target=%d instead\",\n\t\t\tnumBlocks, target)\n\n\t\t// Return the fee rate found, which will be more expensive than\n\t\t// requested. We will not cache the fee rate here in the hope\n\t\t// that the web API will later populate this value.\n\t\treturn fee, nil\n\t}\n\n\t// There are no lower conf targets cached, which is likely when the\n\t// requested conf target is 1. We will search the cache using a higher\n\t// conf target, which gives a fee rate that's cheaper than requested.\n\t//\n\t// NOTE: we can only get here iff the requested conf target is smaller\n\t// than the minimum conf target cached, so we return the minimum conf\n\t// target from the cache.\n\tminTargetCached := uint32(math.MaxUint32)\n\tfor target := range w.feeByBlockTarget {\n\t\tif target < minTargetCached {\n\t\t\tminTargetCached = target\n\t\t}\n\t}\n\n\tfee, ok = w.feeByBlockTarget[minTargetCached]\n\tif !ok {\n\t\t// We should never get here, just a vanity check.\n\t\treturn 0, fmt.Errorf(\"web API error: %w, conf target: %d\",\n\t\t\terrNoFeeRateFound, numBlocks)\n\t}\n\n\t// Log an error instead of a warning as a cheaper fee rate may delay\n\t// the confirmation for some important transactions.\n\tlog.Errorf(\"Web API does not have a fee rate for target=%d, \"+\n\t\t\"using the fee rate for target=%d instead\",\n\t\tnumBlocks, minTargetCached)\n\n\treturn fee, nil\n}\n\n// updateFeeEstimates re-queries the API for fresh fees and caches them.",
      "length": 2156,
      "tokens": 365,
      "embedding": []
    },
    {
      "slug": "func (w *WebAPIEstimator) updateFeeEstimates() {",
      "content": "func (w *WebAPIEstimator) updateFeeEstimates() {\n\t// Rather than use the default http.Client, we'll make a custom one\n\t// which will allow us to control how long we'll wait to read the\n\t// response from the service. This way, if the service is down or\n\t// overloaded, we can exit early and use our default fee.\n\tnetTransport := &http.Transport{\n\t\tDial: (&net.Dialer{\n\t\t\tTimeout: 5 * time.Second,\n\t\t}).Dial,\n\t\tTLSHandshakeTimeout: 5 * time.Second,\n\t}\n\tnetClient := &http.Client{\n\t\tTimeout:   time.Second * 10,\n\t\tTransport: netTransport,\n\t}\n\n\t// With the client created, we'll query the API source to fetch the URL\n\t// that we should use to query for the fee estimation.\n\ttargetURL := w.apiSource.GenQueryURL()\n\tresp, err := netClient.Get(targetURL)\n\tif err != nil {\n\t\tlog.Errorf(\"unable to query web api for fee response: %v\",\n\t\t\terr)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\t// Once we've obtained the response, we'll instruct the WebAPIFeeSource\n\t// to parse out the body to obtain our final result.\n\tfeesByBlockTarget, err := w.apiSource.ParseResponse(resp.Body)\n\tif err != nil {\n\t\tlog.Errorf(\"unable to query web api for fee response: %v\",\n\t\t\terr)\n\t\treturn\n\t}\n\n\tw.feesMtx.Lock()\n\tw.feeByBlockTarget = feesByBlockTarget\n\tw.feesMtx.Unlock()\n}\n\n// feeUpdateManager updates the fee estimates whenever a new block comes in.",
      "length": 1230,
      "tokens": 186,
      "embedding": []
    },
    {
      "slug": "func (w *WebAPIEstimator) feeUpdateManager() {",
      "content": "func (w *WebAPIEstimator) feeUpdateManager() {\n\tdefer w.wg.Done()\n\n\tfor {\n\t\tselect {\n\t\tcase <-w.updateFeeTicker.C:\n\t\t\tw.updateFeeEstimates()\n\t\tcase <-w.quit:\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// A compile-time assertion to ensure that WebAPIEstimator implements the\n// Estimator interface.\nvar _ Estimator = (*WebAPIEstimator)(nil)\n",
      "length": 256,
      "tokens": 33,
      "embedding": []
    }
  ]
}