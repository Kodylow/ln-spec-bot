{
  "filepath": "../implementations/go/lnd/lnwallet/chanfunding/coin_select_test.go",
  "package": "chanfunding",
  "sections": [
    {
      "slug": "func fundingFee(feeRate chainfee.SatPerKWeight, numInput int, // nolint:unparam",
      "content": "func fundingFee(feeRate chainfee.SatPerKWeight, numInput int, // nolint:unparam\n\tchange bool) btcutil.Amount {\n\n\tvar weightEstimate input.TxWeightEstimator\n\n\t// All inputs.\n\tfor i := 0; i < numInput; i++ {\n\t\tweightEstimate.AddP2WKHInput()\n\t}\n\n\t// The multisig funding output.\n\tweightEstimate.AddP2WSHOutput()\n\n\t// Optionally count a change output.\n\tif change {\n\t\tweightEstimate.AddP2TROutput()\n\t}\n\n\ttotalWeight := int64(weightEstimate.Weight())\n\treturn feeRate.FeeForWeight(totalWeight)\n}\n\n// TestCalculateFees tests that the helper function to calculate the fees\n// both with and without applying a change output is done correctly for\n// (N)P2WKH inputs, and should raise an error otherwise.",
      "length": 589,
      "tokens": 77,
      "embedding": []
    },
    {
      "slug": "func TestCalculateFees(t *testing.T) {",
      "content": "func TestCalculateFees(t *testing.T) {\n\tt.Parallel()\n\n\tconst feeRate = chainfee.SatPerKWeight(1000)\n\n\ttype testCase struct {\n\t\tname  string\n\t\tutxos []Coin\n\n\t\texpectedFeeNoChange   btcutil.Amount\n\t\texpectedFeeWithChange btcutil.Amount\n\t\texpectedErr           error\n\t}\n\n\ttestCases := []testCase{\n\t\t{\n\t\t\tname: \"one P2WKH input\",\n\t\t\tutxos: []Coin{\n\t\t\t\t{\n\t\t\t\t\tTxOut: wire.TxOut{\n\t\t\t\t\t\tPkScript: p2wkhScript,\n\t\t\t\t\t\tValue:    1,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\n\t\t\texpectedFeeNoChange:   487,\n\t\t\texpectedFeeWithChange: 659,\n\t\t\texpectedErr:           nil,\n\t\t},\n\n\t\t{\n\t\t\tname: \"one NP2WKH input\",\n\t\t\tutxos: []Coin{\n\t\t\t\t{\n\t\t\t\t\tTxOut: wire.TxOut{\n\t\t\t\t\t\tPkScript: np2wkhScript,\n\t\t\t\t\t\tValue:    1,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\n\t\t\texpectedFeeNoChange:   579,\n\t\t\texpectedFeeWithChange: 751,\n\t\t\texpectedErr:           nil,\n\t\t},\n\n\t\t{\n\t\t\tname: \"not supported P2KH input\",\n\t\t\tutxos: []Coin{\n\t\t\t\t{\n\t\t\t\t\tTxOut: wire.TxOut{\n\t\t\t\t\t\tPkScript: p2khScript,\n\t\t\t\t\t\tValue:    1,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\n\t\t\texpectedErr: &errUnsupportedInput{p2khScript},\n\t\t},\n\t}\n\n\tfor _, test := range testCases {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tfeeNoChange, feeWithChange, err := calculateFees(\n\t\t\t\ttest.utxos, feeRate,\n\t\t\t)\n\t\t\trequire.Equal(t, test.expectedErr, err)\n\n\t\t\t// Note: The error-case will have zero values returned\n\t\t\t// for fees and therefore anyway pass the following\n\t\t\t// requirements.\n\t\t\trequire.Equal(t, test.expectedFeeNoChange, feeNoChange)\n\t\t\trequire.Equal(t, test.expectedFeeWithChange, feeWithChange)\n\t\t})\n\t}\n}\n\n// TestCoinSelect tests that we pick coins adding up to the expected amount\n// when creating a funding transaction, and that the calculated change is the\n// expected amount.\n//\n// NOTE: coinSelect will always attempt to add a change output, so we must\n// account for this in the tests.",
      "length": 1656,
      "tokens": 198,
      "embedding": []
    },
    {
      "slug": "func TestCoinSelect(t *testing.T) {",
      "content": "func TestCoinSelect(t *testing.T) {\n\tt.Parallel()\n\n\tconst feeRate = chainfee.SatPerKWeight(100)\n\tconst dustLimit = btcutil.Amount(1000)\n\n\ttype testCase struct {\n\t\tname        string\n\t\toutputValue btcutil.Amount\n\t\tcoins       []Coin\n\n\t\texpectedInput  []btcutil.Amount\n\t\texpectedChange btcutil.Amount\n\t\texpectErr      bool\n\t}\n\n\ttestCases := []testCase{\n\t\t{\n\t\t\t// We have 1.0 BTC available, and wants to send 0.5.\n\t\t\t// This will obviously lead to a change output of\n\t\t\t// almost 0.5 BTC.\n\t\t\tname: \"big change\",\n\t\t\tcoins: []Coin{\n\t\t\t\t{\n\t\t\t\t\tTxOut: wire.TxOut{\n\t\t\t\t\t\tPkScript: p2wkhScript,\n\t\t\t\t\t\tValue:    1 * btcutil.SatoshiPerBitcoin,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\toutputValue: 0.5 * btcutil.SatoshiPerBitcoin,\n\n\t\t\t// The one and only input will be selected.\n\t\t\texpectedInput: []btcutil.Amount{\n\t\t\t\t1 * btcutil.SatoshiPerBitcoin,\n\t\t\t},\n\t\t\t// Change will be what's left minus the fee.\n\t\t\texpectedChange: 0.5*btcutil.SatoshiPerBitcoin - fundingFee(feeRate, 1, true),\n\t\t},\n\t\t{\n\t\t\t// We have 1 BTC available, and we want to send 1 BTC.\n\t\t\t// This should lead to an error, as we don't have\n\t\t\t// enough funds to pay the fee.\n\t\t\tname: \"nothing left for fees\",\n\t\t\tcoins: []Coin{\n\t\t\t\t{\n\t\t\t\t\tTxOut: wire.TxOut{\n\t\t\t\t\t\tPkScript: p2wkhScript,\n\t\t\t\t\t\tValue:    1 * btcutil.SatoshiPerBitcoin,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\toutputValue: 1 * btcutil.SatoshiPerBitcoin,\n\t\t\texpectErr:   true,\n\t\t},\n\t\t{\n\t\t\t// We have a 1 BTC input, and want to create an output\n\t\t\t// as big as possible, such that the remaining change\n\t\t\t// would be dust but instead goes to fees.\n\t\t\tname: \"dust change\",\n\t\t\tcoins: []Coin{\n\t\t\t\t{\n\t\t\t\t\tTxOut: wire.TxOut{\n\t\t\t\t\t\tPkScript: p2wkhScript,\n\t\t\t\t\t\tValue:    1 * btcutil.SatoshiPerBitcoin,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t// We tune the output value by subtracting the expected\n\t\t\t// fee and the dustlimit.\n\t\t\toutputValue: 1*btcutil.SatoshiPerBitcoin - fundingFee(feeRate, 1, false) - dustLimit,\n\n\t\t\texpectedInput: []btcutil.Amount{\n\t\t\t\t1 * btcutil.SatoshiPerBitcoin,\n\t\t\t},\n\n\t\t\t// Change must be zero.\n\t\t\texpectedChange: 0,\n\t\t},\n\t\t{\n\t\t\t// We got just enough funds to create a change output above the\n\t\t\t// dust limit.\n\t\t\tname: \"change right above dustlimit\",\n\t\t\tcoins: []Coin{\n\t\t\t\t{\n\t\t\t\t\tTxOut: wire.TxOut{\n\t\t\t\t\t\tPkScript: p2wkhScript,\n\t\t\t\t\t\tValue:    int64(fundingFee(feeRate, 1, true) + 2*(dustLimit+1)),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t// We tune the output value to be just above the dust limit.\n\t\t\toutputValue: dustLimit + 1,\n\n\t\t\texpectedInput: []btcutil.Amount{\n\t\t\t\tfundingFee(feeRate, 1, true) + 2*(dustLimit+1),\n\t\t\t},\n\n\t\t\t// After paying for the fee the change output should be just above\n\t\t\t// the dust limit.\n\t\t\texpectedChange: dustLimit + 1,\n\t\t},\n\t\t{\n\t\t\t// If more than 20% of funds goes to fees, it should fail.\n\t\t\tname: \"high fee\",\n\t\t\tcoins: []Coin{\n\t\t\t\t{\n\t\t\t\t\tTxOut: wire.TxOut{\n\t\t\t\t\t\tPkScript: p2wkhScript,\n\t\t\t\t\t\tValue:    int64(5 * fundingFee(feeRate, 1, false)),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\toutputValue: 4 * fundingFee(feeRate, 1, false),\n\n\t\t\texpectErr: true,\n\t\t},\n\t}\n\n\tfor _, test := range testCases {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tselected, changeAmt, err := CoinSelect(\n\t\t\t\tfeeRate, test.outputValue, dustLimit, test.coins,\n\t\t\t)\n\t\t\tif !test.expectErr && err != nil {\n\t\t\t\tt.Fatalf(err.Error())\n\t\t\t}\n\n\t\t\tif test.expectErr && err == nil {\n\t\t\t\tt.Fatalf(\"expected error\")\n\t\t\t}\n\n\t\t\t// If we got an expected error, there is nothing more to test.\n\t\t\tif test.expectErr {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Check that the selected inputs match what we expect.\n\t\t\tif len(selected) != len(test.expectedInput) {\n\t\t\t\tt.Fatalf(\"expected %v inputs, got %v\",\n\t\t\t\t\tlen(test.expectedInput), len(selected))\n\t\t\t}\n\n\t\t\tfor i, coin := range selected {\n\t\t\t\tif coin.Value != int64(test.expectedInput[i]) {\n\t\t\t\t\tt.Fatalf(\"expected input %v to have value %v, \"+\n\t\t\t\t\t\t\"had %v\", i, test.expectedInput[i],\n\t\t\t\t\t\tcoin.Value)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Assert we got the expected change amount.\n\t\t\tif changeAmt != test.expectedChange {\n\t\t\t\tt.Fatalf(\"expected %v change amt, got %v\",\n\t\t\t\t\ttest.expectedChange, changeAmt)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestCoinSelectSubtractFees tests that we pick coins adding up to the\n// expected amount when creating a funding transaction, and that a change\n// output is created only when necessary.",
      "length": 4003,
      "tokens": 547,
      "embedding": []
    },
    {
      "slug": "func TestCoinSelectSubtractFees(t *testing.T) {",
      "content": "func TestCoinSelectSubtractFees(t *testing.T) {\n\tt.Parallel()\n\n\tconst feeRate = chainfee.SatPerKWeight(100)\n\tconst highFeeRate = chainfee.SatPerKWeight(1000)\n\tconst dustLimit = btcutil.Amount(1000)\n\tconst dust = btcutil.Amount(100)\n\n\t// removeAmounts replaces any amounts in string with \"<amt>\".\n\tremoveAmounts := func(s string) string {\n\t\tre := regexp.MustCompile(`[[:digit:]]+\\.?[[:digit:]]*`)\n\t\treturn re.ReplaceAllString(s, \"<amt>\")\n\t}\n\n\ttype testCase struct {\n\t\tname       string\n\t\thighFee    bool\n\t\tspendValue btcutil.Amount\n\t\tcoins      []Coin\n\n\t\texpectedInput      []btcutil.Amount\n\t\texpectedFundingAmt btcutil.Amount\n\t\texpectedChange     btcutil.Amount\n\t\texpectErr          string\n\t}\n\n\ttestCases := []testCase{\n\t\t{\n\t\t\t// We have 1.0 BTC available, spend them all. This\n\t\t\t// should lead to a funding TX with one output, the\n\t\t\t// rest goes to fees.\n\t\t\tname: \"spend all\",\n\t\t\tcoins: []Coin{\n\t\t\t\t{\n\t\t\t\t\tTxOut: wire.TxOut{\n\t\t\t\t\t\tPkScript: p2wkhScript,\n\t\t\t\t\t\tValue:    1 * btcutil.SatoshiPerBitcoin,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tspendValue: 1 * btcutil.SatoshiPerBitcoin,\n\n\t\t\t// The one and only input will be selected.\n\t\t\texpectedInput: []btcutil.Amount{\n\t\t\t\t1 * btcutil.SatoshiPerBitcoin,\n\t\t\t},\n\t\t\texpectedFundingAmt: 1*btcutil.SatoshiPerBitcoin - fundingFee(feeRate, 1, false),\n\t\t\texpectedChange:     0,\n\t\t},\n\t\t{\n\t\t\t// We have 1.0 BTC available and spend half of it. This\n\t\t\t// should lead to a funding TX with a change output.\n\t\t\tname: \"spend with change\",\n\t\t\tcoins: []Coin{\n\t\t\t\t{\n\t\t\t\t\tTxOut: wire.TxOut{\n\t\t\t\t\t\tPkScript: p2wkhScript,\n\t\t\t\t\t\tValue:    1 * btcutil.SatoshiPerBitcoin,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tspendValue: 0.5 * btcutil.SatoshiPerBitcoin,\n\n\t\t\t// The one and only input will be selected.\n\t\t\texpectedInput: []btcutil.Amount{\n\t\t\t\t1 * btcutil.SatoshiPerBitcoin,\n\t\t\t},\n\t\t\texpectedFundingAmt: 0.5*btcutil.SatoshiPerBitcoin - fundingFee(feeRate, 1, true),\n\t\t\texpectedChange:     0.5 * btcutil.SatoshiPerBitcoin,\n\t\t},\n\t\t{\n\t\t\t// The total funds available is below the dust limit\n\t\t\t// after paying fees.\n\t\t\tname: \"dust output\",\n\t\t\tcoins: []Coin{\n\t\t\t\t{\n\t\t\t\t\tTxOut: wire.TxOut{\n\t\t\t\t\t\tPkScript: p2wkhScript,\n\t\t\t\t\t\tValue:    int64(fundingFee(feeRate, 1, false) + dustLimit - 1),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tspendValue: fundingFee(feeRate, 1, false) + dust,\n\n\t\t\texpectErr: \"output amount(<amt> BTC) after subtracting \" +\n\t\t\t\t\"fees(<amt> BTC) below dust limit(<amt> BTC)\",\n\t\t},\n\t\t{\n\t\t\t// After subtracting fees, the resulting change output\n\t\t\t// is below the dust limit. The remainder should go\n\t\t\t// towards the funding output.\n\t\t\tname: \"dust change\",\n\t\t\tcoins: []Coin{\n\t\t\t\t{\n\t\t\t\t\tTxOut: wire.TxOut{\n\t\t\t\t\t\tPkScript: p2wkhScript,\n\t\t\t\t\t\tValue:    1 * btcutil.SatoshiPerBitcoin,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tspendValue: 1*btcutil.SatoshiPerBitcoin - dust,\n\n\t\t\texpectedInput: []btcutil.Amount{\n\t\t\t\t1 * btcutil.SatoshiPerBitcoin,\n\t\t\t},\n\t\t\texpectedFundingAmt: 1*btcutil.SatoshiPerBitcoin - fundingFee(feeRate, 1, false),\n\t\t\texpectedChange:     0,\n\t\t},\n\t\t{\n\t\t\t// We got just enough funds to create an output above the dust limit.\n\t\t\tname: \"output right above dustlimit\",\n\t\t\tcoins: []Coin{\n\t\t\t\t{\n\t\t\t\t\tTxOut: wire.TxOut{\n\t\t\t\t\t\tPkScript: p2wkhScript,\n\t\t\t\t\t\tValue:    int64(fundingFee(feeRate, 1, false) + dustLimit + 1),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tspendValue: fundingFee(feeRate, 1, false) + dustLimit + 1,\n\n\t\t\texpectedInput: []btcutil.Amount{\n\t\t\t\tfundingFee(feeRate, 1, false) + dustLimit + 1,\n\t\t\t},\n\t\t\texpectedFundingAmt: dustLimit + 1,\n\t\t\texpectedChange:     0,\n\t\t},\n\t\t{\n\t\t\t// Amount left is below dust limit after paying fee for\n\t\t\t// a change output, resulting in a no-change tx.\n\t\t\tname: \"no amount to pay fee for change\",\n\t\t\tcoins: []Coin{\n\t\t\t\t{\n\t\t\t\t\tTxOut: wire.TxOut{\n\t\t\t\t\t\tPkScript: p2wkhScript,\n\t\t\t\t\t\tValue:    int64(fundingFee(feeRate, 1, false) + 2*(dustLimit+1)),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tspendValue: fundingFee(feeRate, 1, false) + dustLimit + 1,\n\n\t\t\texpectedInput: []btcutil.Amount{\n\t\t\t\tfundingFee(feeRate, 1, false) + 2*(dustLimit+1),\n\t\t\t},\n\t\t\texpectedFundingAmt: 2 * (dustLimit + 1),\n\t\t\texpectedChange:     0,\n\t\t},\n\t\t{\n\t\t\t// If more than 20% of funds goes to fees, it should fail.\n\t\t\tname:    \"high fee\",\n\t\t\thighFee: true,\n\t\t\tcoins: []Coin{\n\t\t\t\t{\n\t\t\t\t\tTxOut: wire.TxOut{\n\t\t\t\t\t\tPkScript: p2wkhScript,\n\t\t\t\t\t\tValue:    int64(5 * fundingFee(highFeeRate, 1, false)),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tspendValue: 5 * fundingFee(highFeeRate, 1, false),\n\n\t\t\texpectErr: \"fee <amt> BTC on total output value <amt> BTC\",\n\t\t},\n\t}\n\n\tfor _, test := range testCases {\n\t\ttest := test\n\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tfeeRate := feeRate\n\t\t\tif test.highFee {\n\t\t\t\tfeeRate = highFeeRate\n\t\t\t}\n\n\t\t\tselected, localFundingAmt, changeAmt, err := CoinSelectSubtractFees(\n\t\t\t\tfeeRate, test.spendValue, dustLimit, test.coins,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tswitch {\n\t\t\t\tcase test.expectErr == \"\":\n\t\t\t\t\tt.Fatalf(err.Error())\n\n\t\t\t\tcase test.expectErr != removeAmounts(err.Error()):\n\t\t\t\t\tt.Fatalf(\"expected error '%v', got '%v'\",\n\t\t\t\t\t\ttest.expectErr,\n\t\t\t\t\t\tremoveAmounts(err.Error()))\n\n\t\t\t\t// If we got an expected error, there is\n\t\t\t\t// nothing more to test.\n\t\t\t\tdefault:\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check that there was no expected error we missed.\n\t\t\tif test.expectErr != \"\" {\n\t\t\t\tt.Fatalf(\"expected error\")\n\t\t\t}\n\n\t\t\t// Check that the selected inputs match what we expect.\n\t\t\tif len(selected) != len(test.expectedInput) {\n\t\t\t\tt.Fatalf(\"expected %v inputs, got %v\",\n\t\t\t\t\tlen(test.expectedInput), len(selected))\n\t\t\t}\n\n\t\t\tfor i, coin := range selected {\n\t\t\t\tif coin.Value != int64(test.expectedInput[i]) {\n\t\t\t\t\tt.Fatalf(\"expected input %v to have value %v, \"+\n\t\t\t\t\t\t\"had %v\", i, test.expectedInput[i],\n\t\t\t\t\t\tcoin.Value)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Assert we got the expected change amount.\n\t\t\tif localFundingAmt != test.expectedFundingAmt {\n\t\t\t\tt.Fatalf(\"expected %v local funding amt, got %v\",\n\t\t\t\t\ttest.expectedFundingAmt, localFundingAmt)\n\t\t\t}\n\t\t\tif changeAmt != test.expectedChange {\n\t\t\t\tt.Fatalf(\"expected %v change amt, got %v\",\n\t\t\t\t\ttest.expectedChange, changeAmt)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "length": 5671,
      "tokens": 694,
      "embedding": []
    }
  ]
}