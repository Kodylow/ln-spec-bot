{
  "filepath": "../implementations/go/lnd/lnwallet/chanfunding/psbt_assembler_test.go",
  "package": "chanfunding",
  "sections": [
    {
      "slug": "func TestPsbtIntent(t *testing.T) {",
      "content": "func TestPsbtIntent(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a simple assembler and ask it to provision a channel to get\n\t// the funding intent.\n\ta := NewPsbtAssembler(chanCapacity, nil, &params, true)\n\tintent, err := a.ProvisionChannel(&Request{LocalAmt: chanCapacity})\n\trequire.NoError(t, err, \"error provisioning channel\")\n\tpsbtIntent, ok := intent.(*PsbtIntent)\n\tif !ok {\n\t\tt.Fatalf(\"intent was not a PsbtIntent\")\n\t}\n\tif psbtIntent.State != PsbtShimRegistered {\n\t\tt.Fatalf(\"unexpected state. got %d wanted %d\", psbtIntent.State,\n\t\t\tPsbtShimRegistered)\n\t}\n\n\t// The first step with the intent is that the funding manager starts\n\t// negotiating with the remote peer and they accept. By accepting, they\n\t// send over their multisig key that's going to be used for the funding\n\t// output. With that known, we can start crafting a PSBT.\n\t_, localPubkey := btcec.PrivKeyFromBytes(localPrivkey)\n\t_, remotePubkey := btcec.PrivKeyFromBytes(remotePrivkey)\n\tpsbtIntent.BindKeys(\n\t\t&keychain.KeyDescriptor{PubKey: localPubkey}, remotePubkey,\n\t)\n\tif psbtIntent.State != PsbtOutputKnown {\n\t\tt.Fatalf(\"unexpected state. got %d wanted %d\", psbtIntent.State,\n\t\t\tPsbtOutputKnown)\n\t}\n\n\t// Make sure the output script address is correct.\n\tscript, _, err := input.GenFundingPkScript(\n\t\tlocalPubkey.SerializeCompressed(),\n\t\tremotePubkey.SerializeCompressed(), int64(chanCapacity),\n\t)\n\trequire.NoError(t, err, \"error calculating script\")\n\twitnessScriptHash := sha256.Sum256(script)\n\taddr, err := btcutil.NewAddressWitnessScriptHash(\n\t\twitnessScriptHash[:], &params,\n\t)\n\trequire.NoError(t, err, \"unable to encode address\")\n\tfundingAddr, amt, pendingPsbt, err := psbtIntent.FundingParams()\n\trequire.NoError(t, err, \"unable to get funding params\")\n\tif addr.EncodeAddress() != fundingAddr.EncodeAddress() {\n\t\tt.Fatalf(\"unexpected address. got %s wanted %s\", fundingAddr,\n\t\t\taddr)\n\t}\n\tif amt != int64(chanCapacity) {\n\t\tt.Fatalf(\"unexpected amount. got %d wanted %d\", amt,\n\t\t\tchanCapacity)\n\t}\n\n\t// Parse and check the returned PSBT packet.\n\tif pendingPsbt == nil {\n\t\tt.Fatalf(\"expected pending PSBT to be returned\")\n\t}\n\tif len(pendingPsbt.UnsignedTx.TxOut) != 1 {\n\t\tt.Fatalf(\"unexpected number of outputs. got %d wanted %d\",\n\t\t\tlen(pendingPsbt.UnsignedTx.TxOut), 1)\n\t}\n\ttxOut := pendingPsbt.UnsignedTx.TxOut[0]\n\tif !bytes.Equal(txOut.PkScript[2:], witnessScriptHash[:]) {\n\t\tt.Fatalf(\"unexpected PK script in output. got %x wanted %x\",\n\t\t\ttxOut.PkScript[2:], witnessScriptHash)\n\t}\n\tif txOut.Value != int64(chanCapacity) {\n\t\tt.Fatalf(\"unexpected value in output. got %d wanted %d\",\n\t\t\ttxOut.Value, chanCapacity)\n\t}\n\n\t// Add an input to the pending TX to simulate it being funded.\n\tpendingPsbt.UnsignedTx.TxIn = []*wire.TxIn{\n\t\t{PreviousOutPoint: wire.OutPoint{Index: 0}},\n\t}\n\tpendingPsbt.Inputs = []psbt.PInput{\n\t\t{WitnessUtxo: &wire.TxOut{Value: int64(chanCapacity + 1)}},\n\t}\n\n\t// Verify the dummy PSBT with the intent.\n\terr = psbtIntent.Verify(pendingPsbt, false)\n\trequire.NoError(t, err, \"error verifying pending PSBT\")\n\tif psbtIntent.State != PsbtVerified {\n\t\tt.Fatalf(\"unexpected state. got %d wanted %d\", psbtIntent.State,\n\t\t\tPsbtVerified)\n\t}\n\n\t// Add some fake witness data to the transaction so it thinks it's\n\t// signed.\n\tpendingPsbt.Inputs[0].WitnessUtxo = &wire.TxOut{\n\t\tValue:    int64(chanCapacity) * 2,\n\t\tPkScript: []byte{99, 99, 99},\n\t}\n\tpendingPsbt.Inputs[0].FinalScriptSig = []byte{88, 88, 88}\n\tpendingPsbt.Inputs[0].FinalScriptWitness = []byte{2, 0, 0}\n\n\t// If we call Finalize, the intent will signal to the funding manager\n\t// that it can continue with the funding flow. We want to make sure\n\t// the signal arrives.\n\tvar wg sync.WaitGroup\n\terrChan := make(chan error, 1)\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tselect {\n\t\tcase err := <-psbtIntent.PsbtReady:\n\t\t\terrChan <- err\n\n\t\tcase <-time.After(defaultTimeout):\n\t\t\terrChan <- fmt.Errorf(\"timed out\")\n\t\t}\n\t}()\n\terr = psbtIntent.Finalize(pendingPsbt)\n\trequire.NoError(t, err, \"error finalizing pending PSBT\")\n\twg.Wait()\n\n\t// We should have a nil error in our channel now.\n\terr = <-errChan\n\trequire.NoError(t, err, \"unexpected error after finalize\")\n\tif psbtIntent.State != PsbtFinalized {\n\t\tt.Fatalf(\"unexpected state. got %d wanted %d\", psbtIntent.State,\n\t\t\tPsbtFinalized)\n\t}\n\n\t// Make sure the funding transaction can be compiled.\n\t_, err = psbtIntent.CompileFundingTx()\n\trequire.NoError(t, err, \"error compiling funding TX from PSBT\")\n\tif psbtIntent.State != PsbtFundingTxCompiled {\n\t\tt.Fatalf(\"unexpected state. got %d wanted %d\", psbtIntent.State,\n\t\t\tPsbtFundingTxCompiled)\n\t}\n}\n\n// TestPsbtIntentBasePsbt tests that a channel funding output can be appended to\n// a given base PSBT in the funding flow.",
      "length": 4485,
      "tokens": 551,
      "embedding": []
    },
    {
      "slug": "func TestPsbtIntentBasePsbt(t *testing.T) {",
      "content": "func TestPsbtIntentBasePsbt(t *testing.T) {\n\tt.Parallel()\n\n\t// First create a dummy PSBT with a single output.\n\tpendingPsbt, err := psbt.New(\n\t\t[]*wire.OutPoint{{}}, []*wire.TxOut{\n\t\t\t{Value: 999, PkScript: []byte{99, 88, 77}},\n\t\t}, 2, 0, []uint32{0},\n\t)\n\tif err != nil {\n\t\tt.Fatalf(\"unable to create dummy PSBT\")\n\t}\n\n\t// Generate the funding multisig keys and the address so we can compare\n\t// it to the output of the intent.\n\t_, localPubkey := btcec.PrivKeyFromBytes(localPrivkey)\n\t_, remotePubkey := btcec.PrivKeyFromBytes(remotePrivkey)\n\t// Make sure the output script address is correct.\n\tscript, _, err := input.GenFundingPkScript(\n\t\tlocalPubkey.SerializeCompressed(),\n\t\tremotePubkey.SerializeCompressed(), int64(chanCapacity),\n\t)\n\trequire.NoError(t, err, \"error calculating script\")\n\twitnessScriptHash := sha256.Sum256(script)\n\taddr, err := btcutil.NewAddressWitnessScriptHash(\n\t\twitnessScriptHash[:], &params,\n\t)\n\trequire.NoError(t, err, \"unable to encode address\")\n\n\t// Now as the next step, create a new assembler/intent pair with a base\n\t// PSBT to see that we can add an additional output to it.\n\ta := NewPsbtAssembler(chanCapacity, pendingPsbt, &params, true)\n\tintent, err := a.ProvisionChannel(&Request{LocalAmt: chanCapacity})\n\trequire.NoError(t, err, \"error provisioning channel\")\n\tpsbtIntent, ok := intent.(*PsbtIntent)\n\tif !ok {\n\t\tt.Fatalf(\"intent was not a PsbtIntent\")\n\t}\n\tpsbtIntent.BindKeys(\n\t\t&keychain.KeyDescriptor{PubKey: localPubkey}, remotePubkey,\n\t)\n\tnewAddr, amt, twoOutPsbt, err := psbtIntent.FundingParams()\n\trequire.NoError(t, err, \"unable to get funding params\")\n\tif addr.EncodeAddress() != newAddr.EncodeAddress() {\n\t\tt.Fatalf(\"unexpected address. got %s wanted %s\", newAddr,\n\t\t\taddr)\n\t}\n\tif amt != int64(chanCapacity) {\n\t\tt.Fatalf(\"unexpected amount. got %d wanted %d\", amt,\n\t\t\tchanCapacity)\n\t}\n\tif len(twoOutPsbt.UnsignedTx.TxOut) != 2 {\n\t\tt.Fatalf(\"unexpected number of outputs. got %d wanted %d\",\n\t\t\tlen(twoOutPsbt.UnsignedTx.TxOut), 2)\n\t}\n\tif len(twoOutPsbt.UnsignedTx.TxIn) != 1 {\n\t\tt.Fatalf(\"unexpected number of inputs. got %d wanted %d\",\n\t\t\tlen(twoOutPsbt.UnsignedTx.TxIn), 1)\n\t}\n\ttxOld := pendingPsbt.UnsignedTx\n\ttxNew := twoOutPsbt.UnsignedTx\n\tprevoutEqual := reflect.DeepEqual(\n\t\ttxOld.TxIn[0].PreviousOutPoint, txNew.TxIn[0].PreviousOutPoint,\n\t)\n\tif !prevoutEqual {\n\t\tt.Fatalf(\"inputs changed. got %s wanted %s\",\n\t\t\tspew.Sdump(txOld.TxIn[0].PreviousOutPoint),\n\t\t\tspew.Sdump(txNew.TxIn[0].PreviousOutPoint))\n\t}\n\tif !reflect.DeepEqual(txOld.TxOut[0], txNew.TxOut[0]) {\n\t\tt.Fatalf(\"existing output changed. got %v wanted %v\",\n\t\t\ttxOld.TxOut[0], txNew.TxOut[0])\n\t}\n}\n\n// TestPsbtVerify tests the PSBT verification process more deeply than just\n// the happy path.",
      "length": 2587,
      "tokens": 295,
      "embedding": []
    },
    {
      "slug": "func TestPsbtVerify(t *testing.T) {",
      "content": "func TestPsbtVerify(t *testing.T) {\n\tt.Parallel()\n\n\ttestCases := []struct {\n\t\tname          string\n\t\texpectedErr   string\n\t\tshouldPublish bool\n\t\tdoVerify      func(int64, *psbt.Packet, *PsbtIntent) error\n\t}{\n\t\t{\n\t\t\tname:          \"nil packet\",\n\t\t\texpectedErr:   \"PSBT is nil\",\n\t\t\tshouldPublish: true,\n\t\t\tdoVerify: func(amt int64, p *psbt.Packet,\n\t\t\t\ti *PsbtIntent) error {\n\n\t\t\t\treturn i.Verify(nil, false)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:          \"wrong state\",\n\t\t\tshouldPublish: true,\n\t\t\texpectedErr: \"invalid state. got user_canceled \" +\n\t\t\t\t\"expected output_known\",\n\t\t\tdoVerify: func(amt int64, p *psbt.Packet,\n\t\t\t\ti *PsbtIntent) error {\n\n\t\t\t\ti.State = PsbtInitiatorCanceled\n\t\t\t\treturn i.Verify(p, false)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:          \"output not found, value wrong\",\n\t\t\tshouldPublish: true,\n\t\t\texpectedErr:   \"funding output not found in PSBT\",\n\t\t\tdoVerify: func(amt int64, p *psbt.Packet,\n\t\t\t\ti *PsbtIntent) error {\n\n\t\t\t\tp.UnsignedTx.TxOut[0].Value = 123\n\t\t\t\treturn i.Verify(p, false)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:          \"output not found, pk script wrong\",\n\t\t\tshouldPublish: true,\n\t\t\texpectedErr:   \"funding output not found in PSBT\",\n\t\t\tdoVerify: func(amt int64, p *psbt.Packet,\n\t\t\t\ti *PsbtIntent) error {\n\n\t\t\t\tp.UnsignedTx.TxOut[0].PkScript = []byte{1, 2, 3}\n\t\t\t\treturn i.Verify(p, false)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:          \"no inputs\",\n\t\t\tshouldPublish: true,\n\t\t\texpectedErr:   \"PSBT has no inputs\",\n\t\t\tdoVerify: func(amt int64, p *psbt.Packet,\n\t\t\t\ti *PsbtIntent) error {\n\n\t\t\t\treturn i.Verify(p, false)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:          \"input(s) too small\",\n\t\t\tshouldPublish: true,\n\t\t\texpectedErr: \"input amount sum must be larger than \" +\n\t\t\t\t\"output amount sum\",\n\t\t\tdoVerify: func(amt int64, p *psbt.Packet,\n\t\t\t\ti *PsbtIntent) error {\n\n\t\t\t\tp.UnsignedTx.TxIn = []*wire.TxIn{{}}\n\t\t\t\tp.Inputs = []psbt.PInput{{\n\t\t\t\t\tWitnessUtxo: &wire.TxOut{\n\t\t\t\t\t\tValue: int64(chanCapacity),\n\t\t\t\t\t},\n\t\t\t\t}}\n\t\t\t\treturn i.Verify(p, false)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:          \"missing witness-utxo field\",\n\t\t\tshouldPublish: true,\n\t\t\texpectedErr: \"cannot use TX for channel funding, not \" +\n\t\t\t\t\"all inputs are SegWit spends, risk of \" +\n\t\t\t\t\"malleability: input 1 is non-SegWit spend \" +\n\t\t\t\t\"or missing redeem script\",\n\t\t\tdoVerify: func(amt int64, p *psbt.Packet,\n\t\t\t\ti *PsbtIntent) error {\n\n\t\t\t\ttxOut := &wire.TxOut{\n\t\t\t\t\tValue: int64(chanCapacity/2) + 1,\n\t\t\t\t}\n\t\t\t\tp.UnsignedTx.TxIn = []*wire.TxIn{\n\t\t\t\t\t{},\n\t\t\t\t\t{\n\t\t\t\t\t\tPreviousOutPoint: wire.OutPoint{\n\t\t\t\t\t\t\tIndex: 0,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\tp.Inputs = []psbt.PInput{\n\t\t\t\t\t{\n\t\t\t\t\t\tWitnessUtxo: txOut,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tNonWitnessUtxo: &wire.MsgTx{\n\t\t\t\t\t\t\tTxOut: []*wire.TxOut{\n\t\t\t\t\t\t\t\ttxOut,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn i.Verify(p, false)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:          \"skip verify\",\n\t\t\tshouldPublish: false,\n\t\t\texpectedErr:   \"\",\n\t\t\tdoVerify: func(amt int64, p *psbt.Packet,\n\t\t\t\ti *PsbtIntent) error {\n\n\t\t\t\ttxOut := &wire.TxOut{\n\t\t\t\t\tValue: int64(chanCapacity/2) + 1,\n\t\t\t\t}\n\t\t\t\tp.UnsignedTx.TxIn = []*wire.TxIn{\n\t\t\t\t\t{},\n\t\t\t\t\t{\n\t\t\t\t\t\tPreviousOutPoint: wire.OutPoint{\n\t\t\t\t\t\t\tIndex: 0,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\tp.Inputs = []psbt.PInput{\n\t\t\t\t\t{\n\t\t\t\t\t\tWitnessUtxo: txOut,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tWitnessUtxo: txOut,\n\t\t\t\t\t},\n\t\t\t\t}\n\n\t\t\t\tif err := i.Verify(p, true); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tif i.FinalTX != p.UnsignedTx {\n\t\t\t\t\treturn fmt.Errorf(\"expected final TX \" +\n\t\t\t\t\t\t\"to be set\")\n\t\t\t\t}\n\t\t\t\tif i.State != PsbtFinalized {\n\t\t\t\t\treturn fmt.Errorf(\"expected state to \" +\n\t\t\t\t\t\t\"be finalized\")\n\t\t\t\t}\n\n\t\t\t\tselect {\n\t\t\t\tcase <-i.PsbtReady:\n\n\t\t\t\tcase <-time.After(50 * time.Millisecond):\n\t\t\t\t\treturn fmt.Errorf(\"expected PSBT \" +\n\t\t\t\t\t\t\"ready to be signaled\")\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:          \"input correct\",\n\t\t\tshouldPublish: true,\n\t\t\texpectedErr:   \"\",\n\t\t\tdoVerify: func(amt int64, p *psbt.Packet,\n\t\t\t\ti *PsbtIntent) error {\n\n\t\t\t\ttxOut := &wire.TxOut{\n\t\t\t\t\tValue: int64(chanCapacity/2) + 1,\n\t\t\t\t}\n\t\t\t\tp.UnsignedTx.TxIn = []*wire.TxIn{\n\t\t\t\t\t{},\n\t\t\t\t\t{\n\t\t\t\t\t\tPreviousOutPoint: wire.OutPoint{\n\t\t\t\t\t\t\tIndex: 0,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\tp.Inputs = []psbt.PInput{\n\t\t\t\t\t{\n\t\t\t\t\t\tWitnessUtxo: txOut,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tWitnessUtxo: txOut,\n\t\t\t\t\t}}\n\t\t\t\treturn i.Verify(p, false)\n\t\t\t},\n\t\t},\n\t}\n\n\t// Create a simple assembler and ask it to provision a channel to get\n\t// the funding intent.\n\ta := NewPsbtAssembler(chanCapacity, nil, &params, true)\n\tintent, err := a.ProvisionChannel(&Request{LocalAmt: chanCapacity})\n\trequire.NoError(t, err, \"error provisioning channel\")\n\tpsbtIntent := intent.(*PsbtIntent)\n\n\t// Bind our test keys to get the funding parameters.\n\t_, localPubkey := btcec.PrivKeyFromBytes(localPrivkey)\n\t_, remotePubkey := btcec.PrivKeyFromBytes(remotePrivkey)\n\tpsbtIntent.BindKeys(\n\t\t&keychain.KeyDescriptor{PubKey: localPubkey}, remotePubkey,\n\t)\n\n\t// Loop through all our test cases.\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Reset the state from a previous test and create a new\n\t\t\t// pending PSBT that we can manipulate.\n\t\t\tpsbtIntent.shouldPublish = tc.shouldPublish\n\t\t\tpsbtIntent.State = PsbtOutputKnown\n\t\t\t_, amt, pendingPsbt, err := psbtIntent.FundingParams()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to get funding params: %v\", err)\n\t\t\t}\n\n\t\t\terr = tc.doVerify(amt, pendingPsbt, psbtIntent)\n\t\t\tif err != nil && tc.expectedErr == \"\" {\n\t\t\t\tt.Fatalf(\"unexpected error, got '%v' wanted \"+\n\t\t\t\t\t\"'%v'\", err, tc.expectedErr)\n\t\t\t}\n\t\t\tif err != nil && err.Error() != tc.expectedErr {\n\t\t\t\tt.Fatalf(\"unexpected error, got '%v' wanted \"+\n\t\t\t\t\t\"'%v'\", err, tc.expectedErr)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestPsbtFinalize tests the PSBT finalization process more deeply than just\n// the happy path.",
      "length": 5348,
      "tokens": 654,
      "embedding": []
    },
    {
      "slug": "func TestPsbtFinalize(t *testing.T) {",
      "content": "func TestPsbtFinalize(t *testing.T) {\n\tt.Parallel()\n\n\ttestCases := []struct {\n\t\tname        string\n\t\texpectedErr string\n\t\tdoFinalize  func(int64, *psbt.Packet, *PsbtIntent) error\n\t}{\n\t\t{\n\t\t\tname:        \"nil packet\",\n\t\t\texpectedErr: \"PSBT is nil\",\n\t\t\tdoFinalize: func(amt int64, p *psbt.Packet,\n\t\t\t\ti *PsbtIntent) error {\n\n\t\t\t\treturn i.Finalize(nil)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"wrong state\",\n\t\t\texpectedErr: \"invalid state. got user_canceled \" +\n\t\t\t\t\"expected verified\",\n\t\t\tdoFinalize: func(amt int64, p *psbt.Packet,\n\t\t\t\ti *PsbtIntent) error {\n\n\t\t\t\ti.State = PsbtInitiatorCanceled\n\t\t\t\treturn i.Finalize(p)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:        \"not verified first\",\n\t\t\texpectedErr: \"PSBT was not verified first\",\n\t\t\tdoFinalize: func(amt int64, p *psbt.Packet,\n\t\t\t\ti *PsbtIntent) error {\n\n\t\t\t\ti.State = PsbtVerified\n\t\t\t\ti.PendingPsbt = nil\n\t\t\t\treturn i.Finalize(p)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"output value changed\",\n\t\t\texpectedErr: \"outputs differ from verified PSBT: \" +\n\t\t\t\t\"output 0 is different\",\n\t\t\tdoFinalize: func(amt int64, p *psbt.Packet,\n\t\t\t\ti *PsbtIntent) error {\n\n\t\t\t\tp.UnsignedTx.TxOut[0].Value = 123\n\t\t\t\treturn i.Finalize(p)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"output pk script changed\",\n\t\t\texpectedErr: \"outputs differ from verified PSBT: \" +\n\t\t\t\t\"output 0 is different\",\n\t\t\tdoFinalize: func(amt int64, p *psbt.Packet,\n\t\t\t\ti *PsbtIntent) error {\n\n\t\t\t\tp.UnsignedTx.TxOut[0].PkScript = []byte{3, 2, 1}\n\t\t\t\treturn i.Finalize(p)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"input previous outpoint index changed\",\n\t\t\texpectedErr: \"inputs differ from verified PSBT: \" +\n\t\t\t\t\"previous outpoint of input 0 is different\",\n\t\t\tdoFinalize: func(amt int64, p *psbt.Packet,\n\t\t\t\ti *PsbtIntent) error {\n\n\t\t\t\tp.UnsignedTx.TxIn[0].PreviousOutPoint.Index = 0\n\t\t\t\treturn i.Finalize(p)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"input previous outpoint hash changed\",\n\t\t\texpectedErr: \"inputs differ from verified PSBT: \" +\n\t\t\t\t\"previous outpoint of input 0 is different\",\n\t\t\tdoFinalize: func(amt int64, p *psbt.Packet,\n\t\t\t\ti *PsbtIntent) error {\n\n\t\t\t\tprevout := &p.UnsignedTx.TxIn[0].PreviousOutPoint\n\t\t\t\tprevout.Hash = chainhash.Hash{77, 88, 99, 11}\n\t\t\t\treturn i.Finalize(p)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:        \"raw tx - nil transaction\",\n\t\t\texpectedErr: \"raw transaction is nil\",\n\t\t\tdoFinalize: func(amt int64, p *psbt.Packet,\n\t\t\t\ti *PsbtIntent) error {\n\n\t\t\t\treturn i.FinalizeRawTX(nil)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"raw tx - no witness data in raw tx\",\n\t\t\texpectedErr: \"inputs not signed: input 0 has no \" +\n\t\t\t\t\"signature data attached\",\n\t\t\tdoFinalize: func(amt int64, p *psbt.Packet,\n\t\t\t\ti *PsbtIntent) error {\n\n\t\t\t\trawTx, err := psbt.Extract(p)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trawTx.TxIn[0].Witness = nil\n\n\t\t\t\treturn i.FinalizeRawTX(rawTx)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:        \"happy path\",\n\t\t\texpectedErr: \"\",\n\t\t\tdoFinalize: func(amt int64, p *psbt.Packet,\n\t\t\t\ti *PsbtIntent) error {\n\n\t\t\t\terr := i.Finalize(p)\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\trequire.Equal(t, PsbtFinalized, i.State)\n\t\t\t\trequire.NotNil(t, i.FinalTX)\n\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t}\n\n\t// Create a simple assembler and ask it to provision a channel to get\n\t// the funding intent.\n\ta := NewPsbtAssembler(chanCapacity, nil, &params, true)\n\tintent, err := a.ProvisionChannel(&Request{LocalAmt: chanCapacity})\n\trequire.NoError(t, err, \"error provisioning channel\")\n\tpsbtIntent := intent.(*PsbtIntent)\n\n\t// Bind our test keys to get the funding parameters.\n\t_, localPubkey := btcec.PrivKeyFromBytes(localPrivkey)\n\t_, remotePubkey := btcec.PrivKeyFromBytes(remotePrivkey)\n\tpsbtIntent.BindKeys(\n\t\t&keychain.KeyDescriptor{PubKey: localPubkey}, remotePubkey,\n\t)\n\n\t// Loop through all our test cases.\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Reset the state from a previous test and create a new\n\t\t\t// pending PSBT that we can manipulate.\n\t\t\tpsbtIntent.State = PsbtOutputKnown\n\t\t\t_, amt, pendingPsbt, err := psbtIntent.FundingParams()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to get funding params: %v\", err)\n\t\t\t}\n\n\t\t\t// We need to have a simulated transaction here that is\n\t\t\t// fully funded and signed.\n\t\t\tpendingPsbt.UnsignedTx.TxIn = []*wire.TxIn{{\n\t\t\t\tPreviousOutPoint: wire.OutPoint{\n\t\t\t\t\tIndex: 1,\n\t\t\t\t\tHash:  chainhash.Hash{1, 2, 3},\n\t\t\t\t},\n\t\t\t}}\n\t\t\tpendingPsbt.Inputs = []psbt.PInput{{\n\t\t\t\tWitnessUtxo: &wire.TxOut{\n\t\t\t\t\tValue:    int64(chanCapacity) + 1,\n\t\t\t\t\tPkScript: []byte{1, 2, 3},\n\t\t\t\t},\n\t\t\t\tFinalScriptWitness: []byte{0x01, 0x00},\n\t\t\t}}\n\t\t\terr = psbtIntent.Verify(pendingPsbt, false)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"error verifying PSBT: %v\", err)\n\t\t\t}\n\n\t\t\t// Deep clone the PSBT so we don't modify the pending\n\t\t\t// one that was registered during Verify.\n\t\t\tpendingPsbt = clonePsbt(t, pendingPsbt)\n\n\t\t\terr = tc.doFinalize(amt, pendingPsbt, psbtIntent)\n\t\t\tif (err == nil && tc.expectedErr != \"\") ||\n\t\t\t\t(err != nil && err.Error() != tc.expectedErr) {\n\n\t\t\t\tt.Fatalf(\"unexpected error, got '%v' wanted \"+\n\t\t\t\t\t\"'%v'\", err, tc.expectedErr)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "length": 4671,
      "tokens": 588,
      "embedding": []
    },
    {
      "slug": "func TestVerifyAllInputsSegWit(t *testing.T) {",
      "content": "func TestVerifyAllInputsSegWit(t *testing.T) {\n\ttestCases := []struct {\n\t\tname       string\n\t\tpacket     string\n\t\tshouldFail bool\n\t}{{\n\t\t// Electrum takes the spec literally and does not include the\n\t\t// WitnessUtxo field in the PSBT.\n\t\tname: \"Electrum np2wkh spend\",\n\t\tpacket: \"cHNidP8BAFMCAAAAAcptbRo6Ez2R8WclfL4IAW+XEWIl8sNOHnw\" +\n\t\t\t\"eXfeU3dTwAQAAAAD9////Ab26GQAAAAAAF6kUf+wXsa7Z4ejieW\" +\n\t\t\t\"CSdKaGFwJmfbyHQyMeAAABAOACAAAAAAEBiS1A2NE4KW00wLQ1B\" +\n\t\t\t\"9R05jFMINs6egYFNL/5vLseeXMBAAAAAP7///8CNl1m1AEAAAAX\" +\n\t\t\t\"qRR/7Bexrtnh6OJ5YJJ0poYXAmZ9vIdDuxkAAAAAABepFMD8Ngx\" +\n\t\t\t\"k/Z7M5nJM2ltpszQZ4KGahwJHMEQCIAD4EIg16hjWEnEf2pilRF\" +\n\t\t\t\"UmWSk5UsMD7tTrR2FbFCurAiAiNvqpFQSr/FCCXknOV1HzeDVxe\" +\n\t\t\t\"B9gXeDZ62tmZv04/AEhAxGTJ9E/ImiOp2Ti3w/l/JFHa95RvXCB\" +\n\t\t\t\"UXFKifC/7f9dQyMeAAEEFgAU9pqV6WX0D/HEMfdw9yzU30MmkV4\" +\n\t\t\t\"iBgP4kZAAjhAKuixOLJczugvMmlS0xxPc2eD+4IJPHVOeRgxGbt\" +\n\t\t\t\"z0AAAAAAAAAAAAAA==\",\n\t}, {\n\t\tname: \"Electrum p2wkh spend\",\n\t\tpacket: \"cHNidP8BAFMCAAAAASaMwGRzF7QWjHMX9WaGyUp7f3jznuNigHF\" +\n\t\t\t\"4l57hW0CgAAAAAAD9////AU+6GQAAAAAAF6kUf+wXsa7Z4ejieW\" +\n\t\t\t\"CSdKaGFwJmfbyHRSMeAAABANYCAAAAAAEBym1tGjoTPZHxZyV8v\" +\n\t\t\t\"ggBb5cRYiXyw04efB5d95Td1PABAAAAFxYAFPaalell9A/xxDH3\" +\n\t\t\t\"cPcs1N9DJpFe/f///wG+uhkAAAAAABYAFPaalell9A/xxDH3cPc\" +\n\t\t\t\"s1N9DJpFeAkcwRAIgRwfN0qpcM5DHR+YrgXFxhEi6F0qTf4dmQc\" +\n\t\t\t\"c1cu3TnnICIH5wc0kkMbHZ2mqZUFEITRUXExR7US3wohctQK1lf\" +\n\t\t\t\"q/oASED+JGQAI4QCrosTiyXM7oLzJpUtMcT3Nng/uCCTx1TnkZF\" +\n\t\t\t\"Ix4AIgYD+JGQAI4QCrosTiyXM7oLzJpUtMcT3Nng/uCCTx1TnkY\" +\n\t\t\t\"MRm7c9AAAAAAAAAAAAAA=\",\n\t}, {\n\t\tname: \"Bitcoind p2wkh spend\",\n\t\tpacket: \"cHNidP8BAHICAAAAAeEw64k3k+YEk5EgNTytvkGlpiF6iMSsm0o\" +\n\t\t\t\"dCSm03dt7AAAAAAD+////AsSvp8oAAAAAFgAUzWRW/Ccwf/Cosy\" +\n\t\t\t\"dy0uYe5fa/Gb0A4fUFAAAAABepFMD8Ngxk/Z7M5nJM2ltpszQZ4\" +\n\t\t\t\"KGahwAAAAAAAQBxAgAAAAEtMrUZuqjRoaSEMU9sc7pS2zKlS8X3\" +\n\t\t\t\"/CUaENX1IHOICgEAAAAA/v///wLcm53QAAAAABYAFB1zJOaGOpk\" +\n\t\t\t\"NHVkIguiZ2Zh46dlmAGXNHQAAAAAWABTbjTIbrBMD+sWxE6mahK\" +\n\t\t\t\"tKGa//O1wAAAABAR/cm53QAAAAABYAFB1zJOaGOpkNHVkIguiZ2\" +\n\t\t\t\"Zh46dlmIgYDjVRSrQ7d5Rld1nDBTY/uA7Xp+SKUfaFpB0SQiM8O\" +\n\t\t\t\"3usQBp+HNQAAAIABAACADwAAgAAiAgJ9LOXb4MwHRoq31B9fQ2U\" +\n\t\t\t\"0K+Uj8BBJzy+MWc0OOOVuQxAGn4c1AAAAgAEAAIARAACAAAA=\",\n\t}, {\n\t\tname: \"Bitcoind p2pkh spend\",\n\t\tpacket: \"cHNidP8BAHICAAAAAdp3QE/zv3Q7RhkAR0JyzBWLttUqRHJ\" +\n\t\t\t\"pAYmHLIqJzGXOAQAAAAD/////AoDw+gIAAAAAF6kUwPw2DGT9ns\" +\n\t\t\t\"zmckzaW2mzNBngoZqHUN/6AgAAAAAWABRLzlCRi8BozkTClLcIN\" +\n\t\t\t\"tnz8zYTtAAAAAAAAQB0AgAAAAHhMOuJN5PmBJORIDU8rb5BpaYh\" +\n\t\t\t\"eojErJtKHQkptN3bewAAAAAA/v///wKcr6fKAAAAABYAFOvePfh\" +\n\t\t\t\"lztKeDuQRgcGsHLS5BPhTAOH1BQAAAAAZdqkUt9QziR33rxhwcg\" +\n\t\t\t\"ipzwrDti93vTWIrAAAAAAiBgNKzHC4j7KaSKeH9RYx3Ur3dHL5w\" +\n\t\t\t\"YRjXpOAi3SI12WNFxAGn4c1AAAAgAAAAIAGAACAAAAiAgK8Fq3O\" +\n\t\t\t\"5nnASvhn9LJMIJOkGBMYQFd5DcbvOCbBCX/VBRAGn4c1AAAAgAE\" +\n\t\t\t\"AAIAVAACAAA==\",\n\t\tshouldFail: true,\n\t}, {\n\t\tname: \"Bitcoind p2sh multisig spend\",\n\t\tpacket: \"cHNidP8BAHICAAAAAQvO6z5f4wghsQ2c5+Zcw2qdZ4FOYkyWBFe\" +\n\t\t\t\"U/jiIKcwdAAAAAAD/////AkTc+gIAAAAAFgAU2kWEYfMLfgwVQ0\" +\n\t\t\t\"2wJwFNsOmorBWA8PoCAAAAABepFMD8Ngxk/Z7M5nJM2ltpszQZ4\" +\n\t\t\t\"KGahwAAAAAAAQByAgAAAAHad0BP8790O0YZAEdCcswVi7bVKkRy\" +\n\t\t\t\"aQGJhyyKicxlzgAAAAAA/v///wIA4fUFAAAAABepFJdSg2Xdeo3\" +\n\t\t\t\"mYbTqbcZnZIH8oWbPh4TDscQAAAAAFgAUs5d3GhxrF5Zdi8fQHy\" +\n\t\t\t\"A05BSZr4t3AAAAAQRHUSEDdy41G190ATg/VnhXHE4dufESLLl53\" +\n\t\t\t\"RewoYB2ZYRJ/4AhA6MR4qMgHUkIyqhXW0jEECV8cHg/DCiuLgUk\" +\n\t\t\t\"YvQeub1zUq4AAAA=\",\n\t\tshouldFail: true,\n\t}}\n\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tr := strings.NewReader(tc.packet)\n\t\t\tpacket, err := psbt.NewFromRawBytes(r, true)\n\t\t\trequire.NoError(t, err)\n\n\t\t\ttxIns := packet.UnsignedTx.TxIn\n\t\t\tins := packet.Inputs\n\n\t\t\terr = verifyAllInputsSegWit(txIns, ins)\n\t\t\tif tc.shouldFail {\n\t\t\t\trequire.Error(t, err)\n\t\t\t} else {\n\t\t\t\trequire.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// clonePsbt creates a clone of a PSBT packet by serializing then de-serializing\n// it.",
      "length": 3661,
      "tokens": 225,
      "embedding": []
    },
    {
      "slug": "func clonePsbt(t *testing.T, p *psbt.Packet) *psbt.Packet {",
      "content": "func clonePsbt(t *testing.T, p *psbt.Packet) *psbt.Packet {\n\tvar buf bytes.Buffer\n\terr := p.Serialize(&buf)\n\trequire.NoError(t, err, \"error serializing PSBT\")\n\tnewPacket, err := psbt.NewFromRawBytes(&buf, false)\n\trequire.NoError(t, err, \"error unserializing PSBT\")\n\treturn newPacket\n}\n",
      "length": 218,
      "tokens": 24,
      "embedding": []
    }
  ]
}