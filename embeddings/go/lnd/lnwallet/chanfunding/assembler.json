{
  "filepath": "../implementations/go/lnd/lnwallet/chanfunding/assembler.go",
  "package": "chanfunding",
  "sections": [
    {
      "slug": "type CoinSource interface {",
      "content": "type CoinSource interface {\n\t// ListCoins returns all UTXOs from the source that have between\n\t// minConfs and maxConfs number of confirmations.\n\tListCoins(minConfs, maxConfs int32) ([]Coin, error)\n\n\t// CoinFromOutPoint attempts to locate details pertaining to a coin\n\t// based on its outpoint. If the coin isn't under the control of the\n\t// backing CoinSource, then an error should be returned.\n\tCoinFromOutPoint(wire.OutPoint) (*Coin, error)\n}\n\n// CoinSelectionLocker is an interface that allows the caller to perform an\n// operation, which is synchronized with all coin selection attempts. This can\n// be used when an operation requires that all coin selection operations cease\n// forward progress. Think of this as an exclusive lock on coin selection\n// operations.",
      "length": 727,
      "tokens": 112,
      "embedding": []
    },
    {
      "slug": "type CoinSelectionLocker interface {",
      "content": "type CoinSelectionLocker interface {\n\t// WithCoinSelectLock will execute the passed function closure in a\n\t// synchronized manner preventing any coin selection operations from\n\t// proceeding while the closure is executing. This can be seen as the\n\t// ability to execute a function closure under an exclusive coin\n\t// selection lock.\n\tWithCoinSelectLock(func() error) error\n}\n\n// OutpointLocker allows a caller to lock/unlock an outpoint. When locked, the\n// outpoints shouldn't be used for any sort of channel funding of coin\n// selection. Locked outpoints are not expected to be persisted between\n// restarts.",
      "length": 562,
      "tokens": 88,
      "embedding": []
    },
    {
      "slug": "type OutpointLocker interface {",
      "content": "type OutpointLocker interface {\n\t// LockOutpoint locks a target outpoint, rendering it unusable for coin\n\t// selection.\n\tLockOutpoint(o wire.OutPoint)\n\n\t// UnlockOutpoint unlocks a target outpoint, allowing it to be used for\n\t// coin selection once again.\n\tUnlockOutpoint(o wire.OutPoint)\n}\n\n// Request is a new request for funding a channel. The items in the struct\n// governs how the final channel point will be provisioned by the target\n// Assembler.",
      "length": 410,
      "tokens": 65,
      "embedding": []
    },
    {
      "slug": "type Request struct {",
      "content": "type Request struct {\n\t// LocalAmt is the amount of coins we're placing into the funding\n\t// output.\n\tLocalAmt btcutil.Amount\n\n\t// RemoteAmt is the amount of coins the remote party is contributing to\n\t// the funding output.\n\tRemoteAmt btcutil.Amount\n\n\t// MinConfs controls how many confirmations a coin need to be eligible\n\t// to be used as an input to the funding transaction. If this value is\n\t// set to zero, then zero conf outputs may be spent.\n\tMinConfs int32\n\n\t// SubtractFees should be set if we intend to spend exactly LocalAmt\n\t// when opening the channel, subtracting the fees from the funding\n\t// output. This can be used for instance to use all our remaining funds\n\t// to open the channel, since it will take fees into\n\t// account.\n\tSubtractFees bool\n\n\t// FeeRate is the fee rate in sat/kw that the funding transaction\n\t// should carry.\n\tFeeRate chainfee.SatPerKWeight\n\n\t// ChangeAddr is a closure that will provide the Assembler with a\n\t// change address for the funding transaction if needed.\n\tChangeAddr func() (btcutil.Address, error)\n}\n\n// Intent is returned by an Assembler and represents the base functionality the\n// caller needs to proceed with channel funding on a higher level. If the\n// Cancel method is called, then all resources assembled to fund the channel\n// will be released back to the eligible pool.",
      "length": 1277,
      "tokens": 219,
      "embedding": []
    },
    {
      "slug": "type Intent interface {",
      "content": "type Intent interface {\n\t// FundingOutput returns the witness script, and the output that\n\t// creates the funding output.\n\tFundingOutput() ([]byte, *wire.TxOut, error)\n\n\t// ChanPoint returns the final outpoint that will create the funding\n\t// output described above.\n\tChanPoint() (*wire.OutPoint, error)\n\n\t// RemoteFundingAmt is the amount the remote party put into the\n\t// channel.\n\tRemoteFundingAmt() btcutil.Amount\n\n\t// LocalFundingAmt is the amount we put into the channel. This may\n\t// differ from the local amount requested, as depending on coin\n\t// selection, we may bleed from of that LocalAmt into fees to minimize\n\t// change.\n\tLocalFundingAmt() btcutil.Amount\n\n\t// Inputs returns all inputs to the final funding transaction that we\n\t// know about. Note that there might be more, but we are not (yet)\n\t// aware of.\n\tInputs() []wire.OutPoint\n\n\t// Outputs returns all outputs of the final funding transaction that we\n\t// know about. Note that there might be more, but we are not (yet)\n\t// aware of.\n\tOutputs() []*wire.TxOut\n\n\t// Cancel allows the caller to cancel a funding Intent at any time.\n\t// This will return any resources such as coins back to the eligible\n\t// pool to be used in order channel fundings.\n\tCancel()\n}\n\n// Assembler is an abstract object that is capable of assembling everything\n// needed to create a new funding output. As an example, this assembler may be\n// our core backing wallet, an interactive PSBT based assembler, an assembler\n// than can aggregate multiple intents into a single funding transaction, or an\n// external protocol that creates a funding output out-of-band such as channel\n// factories.",
      "length": 1573,
      "tokens": 257,
      "embedding": []
    },
    {
      "slug": "type Assembler interface {",
      "content": "type Assembler interface {\n\t// ProvisionChannel returns a populated Intent that can be used to\n\t// further the channel funding workflow. Depending on the\n\t// implementation of Assembler, additional state machine (Intent)\n\t// actions may be required before the FundingOutput and ChanPoint are\n\t// made available to the caller.\n\tProvisionChannel(*Request) (Intent, error)\n}\n\n// FundingTxAssembler is a super-set of the regular Assembler interface that's\n// also able to provide a fully populated funding transaction via the intents\n// that it produces.",
      "length": 513,
      "tokens": 77,
      "embedding": []
    },
    {
      "slug": "type FundingTxAssembler interface {",
      "content": "type FundingTxAssembler interface {\n\tAssembler\n\n\t// FundingTxAvailable is an empty method that an assembler can\n\t// implement to signal to callers that its able to provide the funding\n\t// transaction for the channel via the intent it returns.\n\tFundingTxAvailable()\n}\n\n// ConditionalPublishAssembler is an assembler that can dynamically define if\n// the funding transaction should be published after channel negotiations or\n// not. Not publishing the transaction is only useful if the particular channel\n// the assembler is in charge of is part of a batch of channels. In that case\n// it is only safe to wait for all channel negotiations of the batch to complete\n// before publishing the batch transaction.",
      "length": 656,
      "tokens": 109,
      "embedding": []
    },
    {
      "slug": "type ConditionalPublishAssembler interface {",
      "content": "type ConditionalPublishAssembler interface {\n\tAssembler\n\n\t// ShouldPublishFundingTx is a method of the assembler that signals if\n\t// the funding transaction should be published after the channel\n\t// negotiations are completed with the remote peer.\n\tShouldPublishFundingTx() bool\n}\n",
      "length": 229,
      "tokens": 33,
      "embedding": []
    }
  ]
}