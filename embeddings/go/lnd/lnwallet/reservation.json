{
  "filepath": "../implementations/go/lnd/lnwallet/reservation.go",
  "package": "lnwallet",
  "sections": [
    {
      "slug": "type CommitmentType int",
      "content": "type CommitmentType int\n\nconst (\n\t// CommitmentTypeLegacy is the legacy commitment format with a tweaked\n\t// to_remote key.\n\tCommitmentTypeLegacy = iota\n\n\t// CommitmentTypeTweakless is a newer commitment format where the\n\t// to_remote key is static.\n\tCommitmentTypeTweakless\n\n\t// CommitmentTypeAnchorsZeroFeeHtlcTx is a commitment type that is an\n\t// extension of the outdated CommitmentTypeAnchors, which in addition\n\t// requires second-level HTLC transactions to be signed using a\n\t// zero-fee.\n\tCommitmentTypeAnchorsZeroFeeHtlcTx\n\n\t// CommitmentTypeScriptEnforcedLease is a commitment type that builds\n\t// upon CommitmentTypeTweakless and CommitmentTypeAnchorsZeroFeeHtlcTx,\n\t// which in addition requires a CLTV clause to spend outputs paying to\n\t// the channel initiator. This is intended for use on leased channels to\n\t// guarantee that the channel initiator has no incentives to close a\n\t// leased channel before its maturity date.\n\tCommitmentTypeScriptEnforcedLease\n)\n\n// HasStaticRemoteKey returns whether the commitment type supports remote\n// outputs backed by static keys.",
      "length": 1034,
      "tokens": 139,
      "embedding": []
    },
    {
      "slug": "func (c CommitmentType) HasStaticRemoteKey() bool {",
      "content": "func (c CommitmentType) HasStaticRemoteKey() bool {\n\tswitch c {\n\tcase CommitmentTypeTweakless,\n\t\tCommitmentTypeAnchorsZeroFeeHtlcTx,\n\t\tCommitmentTypeScriptEnforcedLease:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// HasAnchors returns whether the commitment type supports anchor outputs.",
      "length": 227,
      "tokens": 24,
      "embedding": []
    },
    {
      "slug": "func (c CommitmentType) HasAnchors() bool {",
      "content": "func (c CommitmentType) HasAnchors() bool {\n\tswitch c {\n\tcase CommitmentTypeAnchorsZeroFeeHtlcTx,\n\t\tCommitmentTypeScriptEnforcedLease:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// String returns the name of the CommitmentType.",
      "length": 176,
      "tokens": 21,
      "embedding": []
    },
    {
      "slug": "func (c CommitmentType) String() string {",
      "content": "func (c CommitmentType) String() string {\n\tswitch c {\n\tcase CommitmentTypeLegacy:\n\t\treturn \"legacy\"\n\tcase CommitmentTypeTweakless:\n\t\treturn \"tweakless\"\n\tcase CommitmentTypeAnchorsZeroFeeHtlcTx:\n\t\treturn \"anchors-zero-fee-second-level\"\n\tcase CommitmentTypeScriptEnforcedLease:\n\t\treturn \"script-enforced-lease\"\n\tdefault:\n\t\treturn \"invalid\"\n\t}\n}\n\n// ChannelContribution is the primary constituent of the funding workflow\n// within lnwallet. Each side first exchanges their respective contributions\n// along with channel specific parameters like the min fee/KB. Once\n// contributions have been exchanged, each side will then produce signatures\n// for all their inputs to the funding transactions, and finally a signature\n// for the other party's version of the commitment transaction.",
      "length": 719,
      "tokens": 89,
      "embedding": []
    },
    {
      "slug": "type ChannelContribution struct {",
      "content": "type ChannelContribution struct {\n\t// FundingOutpoint is the amount of funds contributed to the funding\n\t// transaction.\n\tFundingAmount btcutil.Amount\n\n\t// Inputs to the funding transaction.\n\tInputs []*wire.TxIn\n\n\t// ChangeOutputs are the Outputs to be used in the case that the total\n\t// value of the funding inputs is greater than the total potential\n\t// channel capacity.\n\tChangeOutputs []*wire.TxOut\n\n\t// FirstCommitmentPoint is the first commitment point that will be used\n\t// to create the revocation key in the first commitment transaction we\n\t// send to the remote party.\n\tFirstCommitmentPoint *btcec.PublicKey\n\n\t// ChannelConfig is the concrete contribution that this node is\n\t// offering to the channel. This includes all the various constraints\n\t// such as the min HTLC, and also all the keys which will be used for\n\t// the duration of the channel.\n\t*channeldb.ChannelConfig\n\n\t// UpfrontShutdown is an optional address to which the channel should be\n\t// paid out to on cooperative close.\n\tUpfrontShutdown lnwire.DeliveryAddress\n}\n\n// toChanConfig returns the raw channel configuration generated by a node's\n// contribution to the channel.",
      "length": 1086,
      "tokens": 167,
      "embedding": []
    },
    {
      "slug": "func (c *ChannelContribution) toChanConfig() channeldb.ChannelConfig {",
      "content": "func (c *ChannelContribution) toChanConfig() channeldb.ChannelConfig {\n\treturn *c.ChannelConfig\n}\n\n// ChannelReservation represents an intent to open a lightning payment channel\n// with a counterparty. The funding processes from reservation to channel opening\n// is a 3-step process. In order to allow for full concurrency during the\n// reservation workflow, resources consumed by a contribution are \"locked\"\n// themselves. This prevents a number of race conditions such as two funding\n// transactions double-spending the same input. A reservation can also be\n// canceled, which removes the resources from limbo, allowing another\n// reservation to claim them.\n//\n// The reservation workflow consists of the following three steps:\n//  1. lnwallet.InitChannelReservation\n//     * One requests the wallet to allocate the necessary resources for a\n//     channel reservation. These resources are put in limbo for the lifetime\n//     of a reservation.\n//     * Once completed the reservation will have the wallet's contribution\n//     accessible via the .OurContribution() method. This contribution\n//     contains the necessary items to allow the remote party to build both\n//     the funding, and commitment transactions.\n//  2. ChannelReservation.ProcessContribution/ChannelReservation.ProcessSingleContribution\n//     * The counterparty presents their contribution to the payment channel.\n//     This allows us to build the funding, and commitment transactions\n//     ourselves.\n//     * We're now able to sign our inputs to the funding transactions, and\n//     the counterparty's version of the commitment transaction.\n//     * All signatures crafted by us, are now available via .OurSignatures().\n//  3. ChannelReservation.CompleteReservation/ChannelReservation.CompleteReservationSingle\n//     * The final step in the workflow. The counterparty presents the\n//     signatures for all their inputs to the funding transaction, as well\n//     as a signature to our version of the commitment transaction.\n//     * We then verify the validity of all signatures before considering the\n//     channel \"open\".",
      "length": 1999,
      "tokens": 285,
      "embedding": []
    },
    {
      "slug": "type ChannelReservation struct {",
      "content": "type ChannelReservation struct {\n\t// This mutex MUST be held when either reading or modifying any of the\n\t// fields below.\n\tsync.RWMutex\n\n\t// fundingTx is the funding transaction for this pending channel.\n\tfundingTx *wire.MsgTx\n\n\t// In order of sorted inputs. Sorting is done in accordance\n\t// to BIP-69: https://github.com/bitcoin/bips/blob/master/bip-0069.mediawiki.\n\tourFundingInputScripts   []*input.Script\n\ttheirFundingInputScripts []*input.Script\n\n\t// Our signature for their version of the commitment transaction.\n\tourCommitmentSig   input.Signature\n\ttheirCommitmentSig input.Signature\n\n\tourContribution   *ChannelContribution\n\ttheirContribution *ChannelContribution\n\n\tpartialState *channeldb.OpenChannel\n\tnodeAddr     net.Addr\n\n\t// The ID of this reservation, used to uniquely track the reservation\n\t// throughout its lifetime.\n\treservationID uint64\n\n\t// pendingChanID is the pending channel ID for this channel as\n\t// identified within the wire protocol.\n\tpendingChanID [32]byte\n\n\t// pushMSat the amount of milli-satoshis that should be pushed to the\n\t// responder of a single funding channel as part of the initial\n\t// commitment state.\n\tpushMSat lnwire.MilliSatoshi\n\n\twallet     *LightningWallet\n\tchanFunder chanfunding.Assembler\n\n\tfundingIntent chanfunding.Intent\n\n\t// nextRevocationKeyLoc stores the key locator information for this\n\t// channel.\n\tnextRevocationKeyLoc keychain.KeyLocator\n}\n\n// NewChannelReservation creates a new channel reservation. This function is\n// used only internally by lnwallet. In order to concurrent safety, the\n// creation of all channel reservations should be carried out via the\n// lnwallet.InitChannelReservation interface.",
      "length": 1587,
      "tokens": 194,
      "embedding": []
    },
    {
      "slug": "func NewChannelReservation(capacity, localFundingAmt btcutil.Amount,",
      "content": "func NewChannelReservation(capacity, localFundingAmt btcutil.Amount,\n\twallet *LightningWallet, id uint64, chainHash *chainhash.Hash,\n\tthawHeight uint32, req *InitFundingReserveMsg) (*ChannelReservation,\n\terror) {\n\n\tvar (\n\t\tourBalance   lnwire.MilliSatoshi\n\t\ttheirBalance lnwire.MilliSatoshi\n\t\tinitiator    bool\n\t)\n\n\t// Based on the channel type, we determine the initial commit weight\n\t// and fee.\n\tcommitWeight := int64(input.CommitWeight)\n\tif req.CommitType.HasAnchors() {\n\t\tcommitWeight = int64(input.AnchorCommitWeight)\n\t}\n\tcommitFee := req.CommitFeePerKw.FeeForWeight(commitWeight)\n\n\tlocalFundingMSat := lnwire.NewMSatFromSatoshis(localFundingAmt)\n\t// TODO(halseth): make method take remote funding amount directly\n\t// instead of inferring it from capacity and local amt.\n\tcapacityMSat := lnwire.NewMSatFromSatoshis(capacity)\n\n\t// The total fee paid by the initiator will be the commitment fee in\n\t// addition to the two anchor outputs.\n\tfeeMSat := lnwire.NewMSatFromSatoshis(commitFee)\n\tif req.CommitType.HasAnchors() {\n\t\tfeeMSat += 2 * lnwire.NewMSatFromSatoshis(anchorSize)\n\t}\n\n\t// Used to cut down on verbosity.\n\tdefaultDust := wallet.Cfg.DefaultConstraints.DustLimit\n\n\t// If we're the responder to a single-funder reservation, then we have\n\t// no initial balance in the channel unless the remote party is pushing\n\t// some funds to us within the first commitment state.\n\tif localFundingAmt == 0 {\n\t\tourBalance = req.PushMSat\n\t\ttheirBalance = capacityMSat - feeMSat - req.PushMSat\n\t\tinitiator = false\n\n\t\t// If the responder doesn't have enough funds to actually pay\n\t\t// the fees, then we'll bail our early.\n\t\tif int64(theirBalance) < 0 {\n\t\t\treturn nil, ErrFunderBalanceDust(\n\t\t\t\tint64(commitFee), int64(theirBalance.ToSatoshis()),\n\t\t\t\tint64(2*defaultDust),\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// TODO(roasbeef): need to rework fee structure in general and\n\t\t// also when we \"unlock\" dual funder within the daemon\n\n\t\tif capacity == localFundingAmt {\n\t\t\t// If we're initiating a single funder workflow, then\n\t\t\t// we pay all the initial fees within the commitment\n\t\t\t// transaction. We also deduct our balance by the\n\t\t\t// amount pushed as part of the initial state.\n\t\t\tourBalance = capacityMSat - feeMSat - req.PushMSat\n\t\t\ttheirBalance = req.PushMSat\n\t\t} else {\n\t\t\t// Otherwise, this is a dual funder workflow where both\n\t\t\t// slides split the amount funded and the commitment\n\t\t\t// fee.\n\t\t\tourBalance = localFundingMSat - (feeMSat / 2)\n\t\t\ttheirBalance = capacityMSat - localFundingMSat - (feeMSat / 2) + req.PushMSat\n\t\t}\n\n\t\tinitiator = true\n\n\t\t// If we, the initiator don't have enough funds to actually pay\n\t\t// the fees, then we'll exit with an error.\n\t\tif int64(ourBalance) < 0 {\n\t\t\treturn nil, ErrFunderBalanceDust(\n\t\t\t\tint64(commitFee), int64(ourBalance),\n\t\t\t\tint64(2*defaultDust),\n\t\t\t)\n\t\t}\n\t}\n\n\t// If we're the initiator and our starting balance within the channel\n\t// after we take account of fees is below 2x the dust limit, then we'll\n\t// reject this channel creation request.\n\t//\n\t// TODO(roasbeef): reject if 30% goes to fees? dust channel\n\tif initiator && ourBalance.ToSatoshis() <= 2*defaultDust {\n\t\treturn nil, ErrFunderBalanceDust(\n\t\t\tint64(commitFee),\n\t\t\tint64(ourBalance.ToSatoshis()),\n\t\t\tint64(2*defaultDust),\n\t\t)\n\t}\n\n\t// Similarly we ensure their balance is reasonable if we are not the\n\t// initiator.\n\tif !initiator && theirBalance.ToSatoshis() <= 2*defaultDust {\n\t\treturn nil, ErrFunderBalanceDust(\n\t\t\tint64(commitFee),\n\t\t\tint64(theirBalance.ToSatoshis()),\n\t\t\tint64(2*defaultDust),\n\t\t)\n\t}\n\n\t// Next we'll set the channel type based on what we can ascertain about\n\t// the balances/push amount within the channel.\n\tvar chanType channeldb.ChannelType\n\n\t// If either of the balances are zero at this point, or we have a\n\t// non-zero push amt (there's no pushing for dual funder), then this is\n\t// a single-funder channel.\n\tif ourBalance == 0 || theirBalance == 0 || req.PushMSat != 0 {\n\t\t// Both the tweakless type and the anchor type is tweakless,\n\t\t// hence set the bit.\n\t\tif req.CommitType.HasStaticRemoteKey() {\n\t\t\tchanType |= channeldb.SingleFunderTweaklessBit\n\t\t} else {\n\t\t\tchanType |= channeldb.SingleFunderBit\n\t\t}\n\n\t\tswitch a := req.ChanFunder.(type) {\n\t\t// The first channels of a batch shouldn't publish the batch TX\n\t\t// to avoid problems if some of the funding flows can't be\n\t\t// completed. Only the last channel of a batch should publish.\n\t\tcase chanfunding.ConditionalPublishAssembler:\n\t\t\tif !a.ShouldPublishFundingTx() {\n\t\t\t\tchanType |= channeldb.NoFundingTxBit\n\t\t\t}\n\n\t\t// Normal funding flow, the assembler creates a TX from the\n\t\t// internal wallet.\n\t\tcase chanfunding.FundingTxAssembler:\n\t\t\t// Do nothing, a FundingTxAssembler has the transaction.\n\n\t\t// If this intent isn't one that's able to provide us with a\n\t\t// funding transaction, then we'll set the chanType bit to\n\t\t// signal that we don't have access to one.\n\t\tdefault:\n\t\t\tchanType |= channeldb.NoFundingTxBit\n\t\t}\n\t} else {\n\t\t// Otherwise, this is a dual funder channel, and no side is\n\t\t// technically the \"initiator\"\n\t\tinitiator = false\n\t\tchanType |= channeldb.DualFunderBit\n\t}\n\n\t// We are adding anchor outputs to our commitment. We only support this\n\t// in combination with zero-fee second-levels HTLCs.\n\tif req.CommitType.HasAnchors() {\n\t\tchanType |= channeldb.AnchorOutputsBit\n\t\tchanType |= channeldb.ZeroHtlcTxFeeBit\n\t}\n\n\t// Set the appropriate LeaseExpiration/Frozen bit based on the\n\t// reservation parameters.\n\tif req.CommitType == CommitmentTypeScriptEnforcedLease {\n\t\tif thawHeight == 0 {\n\t\t\treturn nil, errors.New(\"missing absolute expiration \" +\n\t\t\t\t\"for script enforced lease commitment type\")\n\t\t}\n\t\tchanType |= channeldb.LeaseExpirationBit\n\t} else if thawHeight > 0 {\n\t\tchanType |= channeldb.FrozenBit\n\t}\n\n\tif req.ZeroConf {\n\t\tchanType |= channeldb.ZeroConfBit\n\t}\n\n\tif req.OptionScidAlias {\n\t\tchanType |= channeldb.ScidAliasChanBit\n\t}\n\n\tif req.ScidAliasFeature {\n\t\tchanType |= channeldb.ScidAliasFeatureBit\n\t}\n\n\treturn &ChannelReservation{\n\t\tourContribution: &ChannelContribution{\n\t\t\tFundingAmount: ourBalance.ToSatoshis(),\n\t\t\tChannelConfig: &channeldb.ChannelConfig{},\n\t\t},\n\t\ttheirContribution: &ChannelContribution{\n\t\t\tFundingAmount: theirBalance.ToSatoshis(),\n\t\t\tChannelConfig: &channeldb.ChannelConfig{},\n\t\t},\n\t\tpartialState: &channeldb.OpenChannel{\n\t\t\tChanType:     chanType,\n\t\t\tChainHash:    *chainHash,\n\t\t\tIsPending:    true,\n\t\t\tIsInitiator:  initiator,\n\t\t\tChannelFlags: req.Flags,\n\t\t\tCapacity:     capacity,\n\t\t\tLocalCommitment: channeldb.ChannelCommitment{\n\t\t\t\tLocalBalance:  ourBalance,\n\t\t\t\tRemoteBalance: theirBalance,\n\t\t\t\tFeePerKw:      btcutil.Amount(req.CommitFeePerKw),\n\t\t\t\tCommitFee:     commitFee,\n\t\t\t},\n\t\t\tRemoteCommitment: channeldb.ChannelCommitment{\n\t\t\t\tLocalBalance:  ourBalance,\n\t\t\t\tRemoteBalance: theirBalance,\n\t\t\t\tFeePerKw:      btcutil.Amount(req.CommitFeePerKw),\n\t\t\t\tCommitFee:     commitFee,\n\t\t\t},\n\t\t\tThawHeight:           thawHeight,\n\t\t\tDb:                   wallet.Cfg.Database,\n\t\t\tInitialLocalBalance:  ourBalance,\n\t\t\tInitialRemoteBalance: theirBalance,\n\t\t},\n\t\tpushMSat:      req.PushMSat,\n\t\tpendingChanID: req.PendingChanID,\n\t\treservationID: id,\n\t\twallet:        wallet,\n\t\tchanFunder:    req.ChanFunder,\n\t}, nil\n}\n\n// AddAlias stores the first alias for zero-conf channels.",
      "length": 6923,
      "tokens": 866,
      "embedding": []
    },
    {
      "slug": "func (r *ChannelReservation) AddAlias(scid lnwire.ShortChannelID) {",
      "content": "func (r *ChannelReservation) AddAlias(scid lnwire.ShortChannelID) {\n\tr.Lock()\n\tdefer r.Unlock()\n\n\tr.partialState.ShortChannelID = scid\n}\n\n// SetNumConfsRequired sets the number of confirmations that are required for\n// the ultimate funding transaction before the channel can be considered open.\n// This is distinct from the main reservation workflow as it allows\n// implementations a bit more flexibility w.r.t to if the responder of the\n// initiator sets decides the number of confirmations needed.",
      "length": 421,
      "tokens": 64,
      "embedding": []
    },
    {
      "slug": "func (r *ChannelReservation) SetNumConfsRequired(numConfs uint16) {",
      "content": "func (r *ChannelReservation) SetNumConfsRequired(numConfs uint16) {\n\tr.Lock()\n\tdefer r.Unlock()\n\n\tr.partialState.NumConfsRequired = numConfs\n}\n\n// IsZeroConf returns if the reservation's underlying partial channel state is\n// a zero-conf channel.",
      "length": 171,
      "tokens": 22,
      "embedding": []
    },
    {
      "slug": "func (r *ChannelReservation) IsZeroConf() bool {",
      "content": "func (r *ChannelReservation) IsZeroConf() bool {\n\tr.RLock()\n\tdefer r.RUnlock()\n\n\treturn r.partialState.IsZeroConf()\n}\n\n// CommitConstraints takes the constraints that the remote party specifies for\n// the type of commitments that we can generate for them. These constraints\n// include several parameters that serve as flow control restricting the amount\n// of satoshis that can be transferred in a single commitment. This function\n// will also attempt to verify the constraints for sanity, returning an error\n// if the parameters are seemed unsound.",
      "length": 489,
      "tokens": 75,
      "embedding": []
    },
    {
      "slug": "func (r *ChannelReservation) CommitConstraints(c *channeldb.ChannelConstraints,",
      "content": "func (r *ChannelReservation) CommitConstraints(c *channeldb.ChannelConstraints,\n\tmaxLocalCSVDelay uint16, responder bool) error {\n\n\tr.Lock()\n\tdefer r.Unlock()\n\n\t// First, verify the sanity of the channel constraints.\n\terr := VerifyConstraints(c, maxLocalCSVDelay, r.partialState.Capacity)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Our dust limit should always be less than or equal to our proposed\n\t// channel reserve.\n\tif responder && r.ourContribution.DustLimit > c.ChanReserve {\n\t\tr.ourContribution.DustLimit = c.ChanReserve\n\t}\n\n\tr.ourContribution.ChanReserve = c.ChanReserve\n\tr.ourContribution.MaxPendingAmount = c.MaxPendingAmount\n\tr.ourContribution.MinHTLC = c.MinHTLC\n\tr.ourContribution.MaxAcceptedHtlcs = c.MaxAcceptedHtlcs\n\tr.ourContribution.CsvDelay = c.CsvDelay\n\n\treturn nil\n}\n\n// validateReserveBounds checks that both ChannelReserve values are above both\n// DustLimit values. This not only avoids stuck channels, but is also mandated\n// by BOLT#02 even if it's not explicit. This returns true if the bounds are\n// valid. This function should be called with the lock held.",
      "length": 971,
      "tokens": 126,
      "embedding": []
    },
    {
      "slug": "func (r *ChannelReservation) validateReserveBounds() bool {",
      "content": "func (r *ChannelReservation) validateReserveBounds() bool {\n\tourDustLimit := r.ourContribution.DustLimit\n\tourRequiredReserve := r.ourContribution.ChanReserve\n\ttheirDustLimit := r.theirContribution.DustLimit\n\ttheirRequiredReserve := r.theirContribution.ChanReserve\n\n\t// We take the smaller of the two ChannelReserves and compare it\n\t// against the larger of the two DustLimits.\n\tminChanReserve := ourRequiredReserve\n\tif minChanReserve > theirRequiredReserve {\n\t\tminChanReserve = theirRequiredReserve\n\t}\n\n\tmaxDustLimit := ourDustLimit\n\tif maxDustLimit < theirDustLimit {\n\t\tmaxDustLimit = theirDustLimit\n\t}\n\n\treturn minChanReserve >= maxDustLimit\n}\n\n// OurContribution returns the wallet's fully populated contribution to the\n// pending payment channel. See 'ChannelContribution' for further details\n// regarding the contents of a contribution.\n//\n// NOTE: This SHOULD NOT be modified.\n// TODO(roasbeef): make copy?",
      "length": 827,
      "tokens": 99,
      "embedding": []
    },
    {
      "slug": "func (r *ChannelReservation) OurContribution() *ChannelContribution {",
      "content": "func (r *ChannelReservation) OurContribution() *ChannelContribution {\n\tr.RLock()\n\tdefer r.RUnlock()\n\n\treturn r.ourContribution\n}\n\n// ProcessContribution verifies the counterparty's contribution to the pending\n// payment channel. As a result of this incoming message, lnwallet is able to\n// build the funding transaction, and both commitment transactions. Once this\n// message has been processed, all signatures to inputs to the funding\n// transaction belonging to the wallet are available. Additionally, the wallet\n// will generate a signature to the counterparty's version of the commitment\n// transaction.",
      "length": 525,
      "tokens": 77,
      "embedding": []
    },
    {
      "slug": "func (r *ChannelReservation) ProcessContribution(theirContribution *ChannelContribution) error {",
      "content": "func (r *ChannelReservation) ProcessContribution(theirContribution *ChannelContribution) error {\n\terrChan := make(chan error, 1)\n\n\tr.wallet.msgChan <- &addContributionMsg{\n\t\tpendingFundingID: r.reservationID,\n\t\tcontribution:     theirContribution,\n\t\terr:              errChan,\n\t}\n\n\treturn <-errChan\n}\n\n// IsPsbt returns true if there is a PSBT funding intent mapped to this\n// reservation.",
      "length": 280,
      "tokens": 34,
      "embedding": []
    },
    {
      "slug": "func (r *ChannelReservation) IsPsbt() bool {",
      "content": "func (r *ChannelReservation) IsPsbt() bool {\n\t_, ok := r.fundingIntent.(*chanfunding.PsbtIntent)\n\treturn ok\n}\n\n// IsCannedShim returns true if there is a canned shim funding intent mapped to\n// this reservation.",
      "length": 161,
      "tokens": 24,
      "embedding": []
    },
    {
      "slug": "func (r *ChannelReservation) IsCannedShim() bool {",
      "content": "func (r *ChannelReservation) IsCannedShim() bool {\n\t_, ok := r.fundingIntent.(*chanfunding.ShimIntent)\n\treturn ok\n}\n\n// ProcessPsbt continues a previously paused funding flow that involves PSBT to\n// construct the funding transaction. This method can be called once the PSBT is\n// finalized and the signed transaction is available.",
      "length": 274,
      "tokens": 41,
      "embedding": []
    },
    {
      "slug": "func (r *ChannelReservation) ProcessPsbt() error {",
      "content": "func (r *ChannelReservation) ProcessPsbt() error {\n\terrChan := make(chan error, 1)\n\n\tr.wallet.msgChan <- &continueContributionMsg{\n\t\tpendingFundingID: r.reservationID,\n\t\terr:              errChan,\n\t}\n\n\treturn <-errChan\n}\n\n// RemoteCanceled informs the PSBT funding state machine that the remote peer\n// has canceled the pending reservation, likely due to a timeout.",
      "length": 303,
      "tokens": 39,
      "embedding": []
    },
    {
      "slug": "func (r *ChannelReservation) RemoteCanceled() {",
      "content": "func (r *ChannelReservation) RemoteCanceled() {\n\tpsbtIntent, ok := r.fundingIntent.(*chanfunding.PsbtIntent)\n\tif !ok {\n\t\treturn\n\t}\n\tpsbtIntent.RemoteCanceled()\n}\n\n// ProcessSingleContribution verifies, and records the initiator's contribution\n// to this pending single funder channel. Internally, no further action is\n// taken other than recording the initiator's contribution to the single funder\n// channel.",
      "length": 351,
      "tokens": 45,
      "embedding": []
    },
    {
      "slug": "func (r *ChannelReservation) ProcessSingleContribution(theirContribution *ChannelContribution) error {",
      "content": "func (r *ChannelReservation) ProcessSingleContribution(theirContribution *ChannelContribution) error {\n\terrChan := make(chan error, 1)\n\n\tr.wallet.msgChan <- &addSingleContributionMsg{\n\t\tpendingFundingID: r.reservationID,\n\t\tcontribution:     theirContribution,\n\t\terr:              errChan,\n\t}\n\n\treturn <-errChan\n}\n\n// TheirContribution returns the counterparty's pending contribution to the\n// payment channel. See 'ChannelContribution' for further details regarding the\n// contents of a contribution. This attribute will ONLY be available after a\n// call to .ProcessContribution().\n//\n// NOTE: This SHOULD NOT be modified.",
      "length": 503,
      "tokens": 62,
      "embedding": []
    },
    {
      "slug": "func (r *ChannelReservation) TheirContribution() *ChannelContribution {",
      "content": "func (r *ChannelReservation) TheirContribution() *ChannelContribution {\n\tr.RLock()\n\tdefer r.RUnlock()\n\treturn r.theirContribution\n}\n\n// OurSignatures retrieves the wallet's signatures to all inputs to the funding\n// transaction belonging to itself, and also a signature for the counterparty's\n// version of the commitment transaction. The signatures for the wallet's\n// inputs to the funding transaction are returned in sorted order according to\n// BIP-69: https://github.com/bitcoin/bips/blob/master/bip-0069.mediawiki.\n//\n// NOTE: These signatures will only be populated after a call to\n// .ProcessContribution()",
      "length": 530,
      "tokens": 72,
      "embedding": []
    },
    {
      "slug": "func (r *ChannelReservation) OurSignatures() ([]*input.Script,",
      "content": "func (r *ChannelReservation) OurSignatures() ([]*input.Script,\n\tinput.Signature) {\n\n\tr.RLock()\n\tdefer r.RUnlock()\n\treturn r.ourFundingInputScripts, r.ourCommitmentSig\n}\n\n// CompleteReservation finalizes the pending channel reservation, transitioning\n// from a pending payment channel, to an open payment channel. All passed\n// signatures to the counterparty's inputs to the funding transaction will be\n// fully verified. Signatures are expected to be passed in sorted order\n// according to BIP-69:\n// https://github.com/bitcoin/bips/blob/master/bip-0069.mediawiki.\n// Additionally, verification is performed in order to ensure that the\n// counterparty supplied a valid signature to our version of the commitment\n// transaction.  Once this method returns, callers should broadcast the\n// created funding transaction, then call .WaitForChannelOpen() which will\n// block until the funding transaction obtains the configured number of\n// confirmations. Once the method unblocks, a LightningChannel instance is\n// returned, marking the channel available for updates.",
      "length": 979,
      "tokens": 131,
      "embedding": []
    },
    {
      "slug": "func (r *ChannelReservation) CompleteReservation(fundingInputScripts []*input.Script,",
      "content": "func (r *ChannelReservation) CompleteReservation(fundingInputScripts []*input.Script,\n\tcommitmentSig input.Signature) (*channeldb.OpenChannel, error) {\n\n\t// TODO(roasbeef): add flag for watch or not?\n\terrChan := make(chan error, 1)\n\tcompleteChan := make(chan *channeldb.OpenChannel, 1)\n\n\tr.wallet.msgChan <- &addCounterPartySigsMsg{\n\t\tpendingFundingID:         r.reservationID,\n\t\ttheirFundingInputScripts: fundingInputScripts,\n\t\ttheirCommitmentSig:       commitmentSig,\n\t\tcompleteChan:             completeChan,\n\t\terr:                      errChan,\n\t}\n\n\treturn <-completeChan, <-errChan\n}\n\n// CompleteReservationSingle finalizes the pending single funder channel\n// reservation. Using the funding outpoint of the constructed funding\n// transaction, and the initiator's signature for our version of the commitment\n// transaction, we are able to verify the correctness of our commitment\n// transaction as crafted by the initiator. Once this method returns, our\n// signature for the initiator's version of the commitment transaction is\n// available via the .OurSignatures() method. As this method should only be\n// called as a response to a single funder channel, only a commitment signature\n// will be populated.",
      "length": 1099,
      "tokens": 136,
      "embedding": []
    },
    {
      "slug": "func (r *ChannelReservation) CompleteReservationSingle(fundingPoint *wire.OutPoint,",
      "content": "func (r *ChannelReservation) CompleteReservationSingle(fundingPoint *wire.OutPoint,\n\tcommitSig input.Signature) (*channeldb.OpenChannel, error) {\n\n\terrChan := make(chan error, 1)\n\tcompleteChan := make(chan *channeldb.OpenChannel, 1)\n\n\tr.wallet.msgChan <- &addSingleFunderSigsMsg{\n\t\tpendingFundingID:   r.reservationID,\n\t\tfundingOutpoint:    fundingPoint,\n\t\ttheirCommitmentSig: commitSig,\n\t\tcompleteChan:       completeChan,\n\t\terr:                errChan,\n\t}\n\n\treturn <-completeChan, <-errChan\n}\n\n// TheirSignatures returns the counterparty's signatures to all inputs to the\n// funding transaction belonging to them, as well as their signature for the\n// wallet's version of the commitment transaction. This methods is provided for\n// additional verification, such as needed by tests.\n//\n// NOTE: These attributes will be unpopulated before a call to\n// .CompleteReservation().",
      "length": 770,
      "tokens": 91,
      "embedding": []
    },
    {
      "slug": "func (r *ChannelReservation) TheirSignatures() ([]*input.Script,",
      "content": "func (r *ChannelReservation) TheirSignatures() ([]*input.Script,\n\tinput.Signature) {\n\n\tr.RLock()\n\tdefer r.RUnlock()\n\treturn r.theirFundingInputScripts, r.theirCommitmentSig\n}\n\n// FinalFundingTx returns the finalized, fully signed funding transaction for\n// this reservation.\n//\n// NOTE: If this reservation was created as the non-initiator to a single\n// funding workflow, then the full funding transaction will not be available.\n// Instead we will only have the final outpoint of the funding transaction.",
      "length": 428,
      "tokens": 61,
      "embedding": []
    },
    {
      "slug": "func (r *ChannelReservation) FinalFundingTx() *wire.MsgTx {",
      "content": "func (r *ChannelReservation) FinalFundingTx() *wire.MsgTx {\n\tr.RLock()\n\tdefer r.RUnlock()\n\treturn r.fundingTx\n}\n\n// FundingOutpoint returns the outpoint of the funding transaction.\n//\n// NOTE: The pointer returned will only be set once the .ProcessContribution()\n// method is called in the case of the initiator of a single funder workflow,\n// and after the .CompleteReservationSingle() method is called in the case of\n// a responder to a single funder workflow.",
      "length": 392,
      "tokens": 63,
      "embedding": []
    },
    {
      "slug": "func (r *ChannelReservation) FundingOutpoint() *wire.OutPoint {",
      "content": "func (r *ChannelReservation) FundingOutpoint() *wire.OutPoint {\n\tr.RLock()\n\tdefer r.RUnlock()\n\treturn &r.partialState.FundingOutpoint\n}\n\n// SetOurUpfrontShutdown sets the upfront shutdown address on our contribution.",
      "length": 147,
      "tokens": 16,
      "embedding": []
    },
    {
      "slug": "func (r *ChannelReservation) SetOurUpfrontShutdown(shutdown lnwire.DeliveryAddress) {",
      "content": "func (r *ChannelReservation) SetOurUpfrontShutdown(shutdown lnwire.DeliveryAddress) {\n\tr.Lock()\n\tdefer r.Unlock()\n\n\tr.ourContribution.UpfrontShutdown = shutdown\n}\n\n// Capacity returns the channel capacity for this reservation.",
      "length": 134,
      "tokens": 16,
      "embedding": []
    },
    {
      "slug": "func (r *ChannelReservation) Capacity() btcutil.Amount {",
      "content": "func (r *ChannelReservation) Capacity() btcutil.Amount {\n\tr.RLock()\n\tdefer r.RUnlock()\n\treturn r.partialState.Capacity\n}\n\n// LeaseExpiry returns the absolute expiration height for a leased channel using\n// the script enforced commitment type. A zero value is returned when the\n// channel is not using a script enforced lease commitment type.",
      "length": 277,
      "tokens": 42,
      "embedding": []
    },
    {
      "slug": "func (r *ChannelReservation) LeaseExpiry() uint32 {",
      "content": "func (r *ChannelReservation) LeaseExpiry() uint32 {\n\tif !r.partialState.ChanType.HasLeaseExpiration() {\n\t\treturn 0\n\t}\n\treturn r.partialState.ThawHeight\n}\n\n// Cancel abandons this channel reservation. This method should be called in\n// the scenario that communications with the counterparty break down. Upon\n// cancellation, all resources previously reserved for this pending payment\n// channel are returned to the free pool, allowing subsequent reservations to\n// utilize the now freed resources.",
      "length": 434,
      "tokens": 60,
      "embedding": []
    },
    {
      "slug": "func (r *ChannelReservation) Cancel() error {",
      "content": "func (r *ChannelReservation) Cancel() error {\n\terrChan := make(chan error, 1)\n\tr.wallet.msgChan <- &fundingReserveCancelMsg{\n\t\tpendingFundingID: r.reservationID,\n\t\terr:              errChan,\n\t}\n\n\treturn <-errChan\n}\n\n// VerifyConstraints is a helper function that can be used to check the sanity\n// of various channel constraints.",
      "length": 273,
      "tokens": 35,
      "embedding": []
    },
    {
      "slug": "func VerifyConstraints(c *channeldb.ChannelConstraints,",
      "content": "func VerifyConstraints(c *channeldb.ChannelConstraints,\n\tmaxLocalCSVDelay uint16, channelCapacity btcutil.Amount) error {\n\n\t// Fail if the csv delay for our funds exceeds our maximum.\n\tif c.CsvDelay > maxLocalCSVDelay {\n\t\treturn ErrCsvDelayTooLarge(c.CsvDelay, maxLocalCSVDelay)\n\t}\n\n\t// The channel reserve should always be greater or equal to the dust\n\t// limit. The reservation request should be denied if otherwise.\n\tif c.DustLimit > c.ChanReserve {\n\t\treturn ErrChanReserveTooSmall(c.ChanReserve, c.DustLimit)\n\t}\n\n\t// Validate against the maximum-sized witness script dust limit, and\n\t// also ensure that the DustLimit is not too large.\n\tmaxWitnessLimit := DustLimitForSize(input.UnknownWitnessSize)\n\tif c.DustLimit < maxWitnessLimit || c.DustLimit > 3*maxWitnessLimit {\n\t\treturn ErrInvalidDustLimit(c.DustLimit)\n\t}\n\n\t// Fail if we consider the channel reserve to be too large.  We\n\t// currently fail if it is greater than 20% of the channel capacity.\n\tmaxChanReserve := channelCapacity / 5\n\tif c.ChanReserve > maxChanReserve {\n\t\treturn ErrChanReserveTooLarge(c.ChanReserve, maxChanReserve)\n\t}\n\n\t// Fail if the minimum HTLC value is too large. If this is too large,\n\t// the channel won't be useful for sending small payments. This limit\n\t// is currently set to maxValueInFlight, effectively letting the remote\n\t// setting this as large as it wants.\n\tif c.MinHTLC > c.MaxPendingAmount {\n\t\treturn ErrMinHtlcTooLarge(c.MinHTLC, c.MaxPendingAmount)\n\t}\n\n\t// Fail if maxHtlcs is above the maximum allowed number of 483.  This\n\t// number is specified in BOLT-02.\n\tif c.MaxAcceptedHtlcs > uint16(input.MaxHTLCNumber/2) {\n\t\treturn ErrMaxHtlcNumTooLarge(\n\t\t\tc.MaxAcceptedHtlcs, uint16(input.MaxHTLCNumber/2),\n\t\t)\n\t}\n\n\t// Fail if we consider maxHtlcs too small. If this is too small we\n\t// cannot offer many HTLCs to the remote.\n\tconst minNumHtlc = 5\n\tif c.MaxAcceptedHtlcs < minNumHtlc {\n\t\treturn ErrMaxHtlcNumTooSmall(c.MaxAcceptedHtlcs, minNumHtlc)\n\t}\n\n\t// Fail if we consider maxValueInFlight too small. We currently require\n\t// the remote to at least allow minNumHtlc * minHtlc in flight.\n\tif c.MaxPendingAmount < minNumHtlc*c.MinHTLC {\n\t\treturn ErrMaxValueInFlightTooSmall(\n\t\t\tc.MaxPendingAmount, minNumHtlc*c.MinHTLC,\n\t\t)\n\t}\n\n\treturn nil\n}\n\n// OpenChannelDetails wraps the finalized fully confirmed channel which\n// resulted from a ChannelReservation instance with details concerning exactly\n// _where_ in the chain the channel was ultimately opened.",
      "length": 2330,
      "tokens": 319,
      "embedding": []
    },
    {
      "slug": "type OpenChannelDetails struct {",
      "content": "type OpenChannelDetails struct {\n\t// Channel is the active channel created by an instance of a\n\t// ChannelReservation and the required funding workflow.\n\tChannel *LightningChannel\n\n\t// ConfirmationHeight is the block height within the chain that\n\t// included the channel.\n\tConfirmationHeight uint32\n\n\t// TransactionIndex is the index within the confirming block that the\n\t// transaction resides.\n\tTransactionIndex uint32\n}\n",
      "length": 378,
      "tokens": 54,
      "embedding": []
    }
  ]
}