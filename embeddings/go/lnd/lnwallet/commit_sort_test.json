{
  "filepath": "../implementations/go/lnd/lnwallet/commit_sort_test.go",
  "package": "lnwallet_test",
  "sections": [
    {
      "slug": "type commitSortTest struct {",
      "content": "type commitSortTest struct {\n\tname     string\n\ttx       *wire.MsgTx\n\tcltvs    []uint32\n\tintrans  map[int]int // input transformation\n\touttrans map[int]int // output transformation\n}\n",
      "length": 147,
      "tokens": 17,
      "embedding": []
    },
    {
      "slug": "func (t *commitSortTest) expTxIns() []*wire.TxIn {",
      "content": "func (t *commitSortTest) expTxIns() []*wire.TxIn {\n\tif len(t.intrans) == 0 {\n\t\treturn nil\n\t}\n\n\texpTxIns := make([]*wire.TxIn, len(t.intrans))\n\tfor start, end := range t.intrans {\n\t\texpTxIns[end] = t.tx.TxIn[start]\n\t}\n\n\treturn expTxIns\n}\n",
      "length": 175,
      "tokens": 26,
      "embedding": []
    },
    {
      "slug": "func (t *commitSortTest) expTxOuts() []*wire.TxOut {",
      "content": "func (t *commitSortTest) expTxOuts() []*wire.TxOut {\n\tif len(t.outtrans) == 0 {\n\t\treturn nil\n\t}\n\n\texpTxOuts := make([]*wire.TxOut, len(t.outtrans))\n\tfor start, end := range t.outtrans {\n\t\texpTxOuts[end] = t.tx.TxOut[start]\n\t}\n\n\treturn expTxOuts\n}\n\nvar commitSortTests = []commitSortTest{\n\t{\n\t\tname: \"sort inputs on prevoutpoint txid\",\n\t\ttx: &wire.MsgTx{\n\t\t\tTxIn: []*wire.TxIn{\n\t\t\t\t{\n\t\t\t\t\tPreviousOutPoint: wire.OutPoint{\n\t\t\t\t\t\tHash: [32]byte{0x01},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tPreviousOutPoint: wire.OutPoint{\n\t\t\t\t\t\tHash: [32]byte{0x00},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tintrans: map[int]int{\n\t\t\t0: 1,\n\t\t\t1: 0,\n\t\t},\n\t},\n\t{\n\t\tname: \"sort inputs on prevoutpoint index\",\n\t\ttx: &wire.MsgTx{\n\t\t\tTxIn: []*wire.TxIn{\n\t\t\t\t{\n\t\t\t\t\tPreviousOutPoint: wire.OutPoint{\n\t\t\t\t\t\tIndex: 1,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tPreviousOutPoint: wire.OutPoint{\n\t\t\t\t\t\tIndex: 0,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tintrans: map[int]int{\n\t\t\t0: 1,\n\t\t\t1: 0,\n\t\t},\n\t},\n\t{\n\t\tname: \"inputs already sorted\",\n\t\ttx: &wire.MsgTx{\n\t\t\tTxIn: []*wire.TxIn{\n\t\t\t\t{\n\t\t\t\t\tPreviousOutPoint: wire.OutPoint{\n\t\t\t\t\t\tIndex: 0,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tPreviousOutPoint: wire.OutPoint{\n\t\t\t\t\t\tIndex: 1,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tintrans: map[int]int{\n\t\t\t0: 0,\n\t\t\t1: 1,\n\t\t},\n\t},\n\t{\n\t\tname: \"sort outputs on value\",\n\t\ttx: &wire.MsgTx{\n\t\t\tTxOut: []*wire.TxOut{\n\t\t\t\t{\n\t\t\t\t\tValue:    2,\n\t\t\t\t\tPkScript: []byte{0x0},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tValue:    1,\n\t\t\t\t\tPkScript: []byte{0x0},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tcltvs: []uint32{0, 0},\n\t\touttrans: map[int]int{\n\t\t\t0: 1,\n\t\t\t1: 0,\n\t\t},\n\t},\n\t{\n\t\tname: \"sort outputs on pkscript\",\n\t\ttx: &wire.MsgTx{\n\t\t\tTxOut: []*wire.TxOut{\n\t\t\t\t{\n\t\t\t\t\tValue:    1,\n\t\t\t\t\tPkScript: []byte{0x2},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tValue:    1,\n\t\t\t\t\tPkScript: []byte{0x1},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tcltvs: []uint32{0, 0},\n\t\touttrans: map[int]int{\n\t\t\t0: 1,\n\t\t\t1: 0,\n\t\t},\n\t},\n\t{\n\t\tname: \"sort outputs on cltv\",\n\t\ttx: &wire.MsgTx{\n\t\t\tTxOut: []*wire.TxOut{\n\t\t\t\t{\n\t\t\t\t\tValue:    1,\n\t\t\t\t\tPkScript: []byte{0x1},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tValue:    1,\n\t\t\t\t\tPkScript: []byte{0x1},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tcltvs: []uint32{2, 1},\n\t\touttrans: map[int]int{\n\t\t\t0: 1,\n\t\t\t1: 0,\n\t\t},\n\t},\n\t{\n\t\tname: \"sort complex outputs\",\n\t\ttx: &wire.MsgTx{\n\t\t\tTxOut: []*wire.TxOut{\n\t\t\t\t{\n\t\t\t\t\tValue:    100000,\n\t\t\t\t\tPkScript: []byte{0x01, 0x02},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tValue:    200000,\n\t\t\t\t\tPkScript: []byte{0x03, 0x02},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tValue:    1000,\n\t\t\t\t\tPkScript: []byte{0x03},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tValue:    1000,\n\t\t\t\t\tPkScript: []byte{0x02},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tValue:    1000,\n\t\t\t\t\tPkScript: []byte{0x1},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tValue:    1000,\n\t\t\t\t\tPkScript: []byte{0x1},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tcltvs: []uint32{0, 0, 100, 90, 70, 80},\n\t\touttrans: map[int]int{\n\t\t\t0: 4,\n\t\t\t1: 5,\n\t\t\t2: 3,\n\t\t\t3: 2,\n\t\t\t4: 0,\n\t\t\t5: 1,\n\t\t},\n\t},\n\t{\n\t\tname: \"outputs already sorted\",\n\t\ttx: &wire.MsgTx{\n\t\t\tTxOut: []*wire.TxOut{\n\t\t\t\t{\n\t\t\t\t\tValue:    1,\n\t\t\t\t\tPkScript: []byte{0x1},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tValue:    1,\n\t\t\t\t\tPkScript: []byte{0x1},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tcltvs: []uint32{1, 2},\n\t\touttrans: map[int]int{\n\t\t\t0: 0,\n\t\t\t1: 1,\n\t\t},\n\t},\n}\n\n// TestCommitSort asserts that the outputs of a transaction are properly sorted\n// using InPlaceCommitSort. The outputs should always be sorted by value, then\n// lexicographically by pkscript, and then CLTV value.",
      "length": 2927,
      "tokens": 377,
      "embedding": []
    },
    {
      "slug": "func TestCommitSort(t *testing.T) {",
      "content": "func TestCommitSort(t *testing.T) {\n\tfor _, test := range commitSortTests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\texpTxIns := test.expTxIns()\n\t\t\texpTxOuts := test.expTxOuts()\n\n\t\t\tlnwallet.InPlaceCommitSort(test.tx, test.cltvs)\n\n\t\t\tif !reflect.DeepEqual(test.tx.TxIn, expTxIns) {\n\t\t\t\tt.Fatalf(\"commit inputs mismatch, want: %v, \"+\n\t\t\t\t\t\"got: %v\", expTxIns, test.tx.TxIn)\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(test.tx.TxOut, expTxOuts) {\n\t\t\t\tt.Fatalf(\"commit outputs mismatch, want: %v, \"+\n\t\t\t\t\t\"got: %v\", expTxOuts, test.tx.TxOut)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "length": 488,
      "tokens": 52,
      "embedding": []
    }
  ]
}