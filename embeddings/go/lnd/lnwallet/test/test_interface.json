{
  "filepath": "../implementations/go/lnd/lnwallet/test/test_interface.go",
  "package": "lnwallettest",
  "sections": [
    {
      "slug": "func getFreePort() int {",
      "content": "func getFreePort() int {\n\tport := atomic.AddUint32(&lastPort, 1)\n\tfor port < 65535 {\n\t\t// If there are no errors while attempting to listen on this\n\t\t// port, close the socket and return it as available.\n\t\taddr := fmt.Sprintf(\"127.0.0.1:%d\", port)\n\t\tl, err := net.Listen(\"tcp4\", addr)\n\t\tif err == nil {\n\t\t\terr := l.Close()\n\t\t\tif err == nil {\n\t\t\t\treturn int(port)\n\t\t\t}\n\t\t}\n\t\tport = atomic.AddUint32(&lastPort, 1)\n\t}\n\n\t// No ports available? Must be a mistake.\n\tpanic(\"no ports available for listening\")\n}\n\n// assertProperBalance asserts than the total value of the unspent outputs\n// within the wallet are *exactly* amount. If unable to retrieve the current\n// balance, or the assertion fails, the test will halt with a fatal error.",
      "length": 685,
      "tokens": 114,
      "embedding": []
    },
    {
      "slug": "func assertProperBalance(t *testing.T, lw *lnwallet.LightningWallet,",
      "content": "func assertProperBalance(t *testing.T, lw *lnwallet.LightningWallet,\n\tnumConfirms int32, amount float64) {\n\n\tbalance, err := lw.ConfirmedBalance(numConfirms, lnwallet.DefaultAccountName)\n\trequire.NoError(t, err, \"unable to query for balance\")\n\tif balance.ToBTC() != amount {\n\t\tt.Fatalf(\"wallet credits not properly loaded, should have 40BTC, \"+\n\t\t\t\"instead have %v\", balance)\n\t}\n}\n",
      "length": 303,
      "tokens": 37,
      "embedding": []
    },
    {
      "slug": "func assertReservationDeleted(res *lnwallet.ChannelReservation, t *testing.T) {",
      "content": "func assertReservationDeleted(res *lnwallet.ChannelReservation, t *testing.T) {\n\tif err := res.Cancel(); err == nil {\n\t\tt.Fatalf(\"reservation wasn't deleted from wallet\")\n\t}\n}\n\n// mineAndAssertTxInBlock asserts that a transaction is included within the next\n// block mined.",
      "length": 187,
      "tokens": 29,
      "embedding": []
    },
    {
      "slug": "func mineAndAssertTxInBlock(t *testing.T, miner *rpctest.Harness,",
      "content": "func mineAndAssertTxInBlock(t *testing.T, miner *rpctest.Harness,\n\ttxid chainhash.Hash) {\n\n\tt.Helper()\n\n\t// First, we'll wait for the transaction to arrive in the mempool.\n\tif err := waitForMempoolTx(miner, &txid); err != nil {\n\t\tt.Fatalf(\"unable to find %v in the mempool: %v\", txid, err)\n\t}\n\n\t// We'll mined a block to confirm it.\n\tblockHashes, err := miner.Client.Generate(1)\n\trequire.NoError(t, err, \"unable to generate new block\")\n\n\t// Finally, we'll check it was actually mined in this block.\n\tblock, err := miner.Client.GetBlock(blockHashes[0])\n\tif err != nil {\n\t\tt.Fatalf(\"unable to get block %v: %v\", blockHashes[0], err)\n\t}\n\tif len(block.Transactions) != 2 {\n\t\tt.Fatalf(\"expected 2 transactions in block, found %d\",\n\t\t\tlen(block.Transactions))\n\t}\n\ttxHash := block.Transactions[1].TxHash()\n\tif txHash != txid {\n\t\tt.Fatalf(\"expected transaction %v to be mined, found %v\", txid,\n\t\t\ttxHash)\n\t}\n}\n\n// newPkScript generates a new public key script of the given address type.",
      "length": 883,
      "tokens": 131,
      "embedding": []
    },
    {
      "slug": "func newPkScript(t *testing.T, w *lnwallet.LightningWallet,",
      "content": "func newPkScript(t *testing.T, w *lnwallet.LightningWallet,\n\taddrType lnwallet.AddressType) []byte {\n\n\tt.Helper()\n\n\taddr, err := w.NewAddress(addrType, false, lnwallet.DefaultAccountName)\n\trequire.NoError(t, err, \"unable to create new address\")\n\tpkScript, err := txscript.PayToAddrScript(addr)\n\trequire.NoError(t, err, \"unable to create output script\")\n\n\treturn pkScript\n}\n\n// sendCoins is a helper function that encompasses all the things needed for two\n// parties to send on-chain funds to each other.",
      "length": 430,
      "tokens": 55,
      "embedding": []
    },
    {
      "slug": "func sendCoins(t *testing.T, miner *rpctest.Harness,",
      "content": "func sendCoins(t *testing.T, miner *rpctest.Harness,\n\tsender, receiver *lnwallet.LightningWallet, output *wire.TxOut,\n\tfeeRate chainfee.SatPerKWeight, mineBlock bool, minConf int32) *wire.MsgTx { //nolint:unparam\n\n\tt.Helper()\n\n\ttx, err := sender.SendOutputs(\n\t\t[]*wire.TxOut{output}, feeRate, minConf, labels.External,\n\t)\n\trequire.NoError(t, err, \"unable to send transaction\")\n\n\tif mineBlock {\n\t\tmineAndAssertTxInBlock(t, miner, tx.TxHash())\n\t}\n\n\tif err := waitForWalletSync(miner, sender); err != nil {\n\t\tt.Fatalf(\"unable to sync alice: %v\", err)\n\t}\n\tif err := waitForWalletSync(miner, receiver); err != nil {\n\t\tt.Fatalf(\"unable to sync bob: %v\", err)\n\t}\n\n\treturn tx\n}\n\n// assertTxInWallet asserts that a transaction exists in the wallet with the\n// expected confirmation status.",
      "length": 702,
      "tokens": 88,
      "embedding": []
    },
    {
      "slug": "func assertTxInWallet(t *testing.T, w *lnwallet.LightningWallet,",
      "content": "func assertTxInWallet(t *testing.T, w *lnwallet.LightningWallet,\n\ttxHash chainhash.Hash, confirmed bool) {\n\n\tt.Helper()\n\n\t// We'll fetch all of our transaction and go through each one until\n\t// finding the expected transaction with its expected confirmation\n\t// status.\n\ttxs, err := w.ListTransactionDetails(0, btcwallet.UnconfirmedHeight, \"\")\n\trequire.NoError(t, err, \"unable to retrieve transactions\")\n\tfor _, tx := range txs {\n\t\tif tx.Hash != txHash {\n\t\t\tcontinue\n\t\t}\n\t\tif tx.NumConfirmations <= 0 && confirmed {\n\t\t\tt.Fatalf(\"expected transaction %v to be confirmed\",\n\t\t\t\ttxHash)\n\t\t}\n\t\tif tx.NumConfirmations > 0 && !confirmed {\n\t\t\tt.Fatalf(\"expected transaction %v to be unconfirmed\",\n\t\t\t\ttxHash)\n\t\t}\n\n\t\t// We've found the transaction and it matches the desired\n\t\t// confirmation status, so we can exit.\n\t\treturn\n\t}\n\n\tt.Fatalf(\"transaction %v not found\", txHash)\n}\n",
      "length": 775,
      "tokens": 111,
      "embedding": []
    },
    {
      "slug": "func loadTestCredits(miner *rpctest.Harness, w *lnwallet.LightningWallet,",
      "content": "func loadTestCredits(miner *rpctest.Harness, w *lnwallet.LightningWallet,\n\tnumOutputs int, btcPerOutput float64) error {\n\n\t// For initial neutrino connection, wait a second.\n\t// TODO(aakselrod): Eliminate the need for this.\n\tswitch w.BackEnd() {\n\tcase \"neutrino\":\n\t\ttime.Sleep(time.Second)\n\t}\n\t// Using the mining node, spend from a coinbase output numOutputs to\n\t// give us btcPerOutput with each output.\n\tsatoshiPerOutput, err := btcutil.NewAmount(btcPerOutput)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to create amt: %v\", err)\n\t}\n\texpectedBalance, err := w.ConfirmedBalance(1, lnwallet.DefaultAccountName)\n\tif err != nil {\n\t\treturn err\n\t}\n\texpectedBalance += btcutil.Amount(int64(satoshiPerOutput) * int64(numOutputs))\n\taddrs := make([]btcutil.Address, 0, numOutputs)\n\tfor i := 0; i < numOutputs; i++ {\n\t\t// Grab a fresh address from the wallet to house this output.\n\t\twalletAddr, err := w.NewAddress(\n\t\t\tlnwallet.WitnessPubKey, false,\n\t\t\tlnwallet.DefaultAccountName,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tscript, err := txscript.PayToAddrScript(walletAddr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\taddrs = append(addrs, walletAddr)\n\n\t\toutput := &wire.TxOut{\n\t\t\tValue:    int64(satoshiPerOutput),\n\t\t\tPkScript: script,\n\t\t}\n\t\tif _, err := miner.SendOutputs([]*wire.TxOut{output}, 2500); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// TODO(roasbeef): shouldn't hardcode 10, use config param that dictates\n\t// how many confs we wait before opening a channel.\n\t// Generate 10 blocks with the mining node, this should mine all\n\t// numOutputs transactions created above. We generate 10 blocks here\n\t// in order to give all the outputs a \"sufficient\" number of confirmations.\n\tif _, err := miner.Client.Generate(10); err != nil {\n\t\treturn err\n\t}\n\n\t// Wait until the wallet has finished syncing up to the main chain.\n\tticker := time.NewTicker(100 * time.Millisecond)\n\ttimeout := time.After(30 * time.Second)\n\n\tfor range ticker.C {\n\t\tbalance, err := w.ConfirmedBalance(1, lnwallet.DefaultAccountName)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif balance == expectedBalance {\n\t\t\tbreak\n\t\t}\n\t\tselect {\n\t\tcase <-timeout:\n\t\t\tsynced, _, err := w.IsSynced()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"timed out after 30 seconds \"+\n\t\t\t\t\"waiting for balance %v, current balance %v, \"+\n\t\t\t\t\"synced: %t\", expectedBalance, balance, synced)\n\t\tdefault:\n\t\t}\n\t}\n\tticker.Stop()\n\n\treturn nil\n}\n\n// createTestWallet creates a test LightningWallet will a total of 20BTC\n// available for funding channels.",
      "length": 2331,
      "tokens": 336,
      "embedding": []
    },
    {
      "slug": "func createTestWallet(tempTestDir string, miningNode *rpctest.Harness,",
      "content": "func createTestWallet(tempTestDir string, miningNode *rpctest.Harness,\n\tnetParams *chaincfg.Params, notifier chainntnfs.ChainNotifier,\n\twc lnwallet.WalletController, keyRing keychain.SecretKeyRing,\n\tsigner input.Signer, bio lnwallet.BlockChainIO) (*lnwallet.LightningWallet, error) {\n\n\tdbDir := filepath.Join(tempTestDir, \"cdb\")\n\tfullDB, err := channeldb.Open(dbDir)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcfg := lnwallet.Config{\n\t\tDatabase:         fullDB.ChannelStateDB(),\n\t\tNotifier:         notifier,\n\t\tSecretKeyRing:    keyRing,\n\t\tWalletController: wc,\n\t\tSigner:           signer,\n\t\tChainIO:          bio,\n\t\tFeeEstimator:     chainfee.NewStaticEstimator(2500, 0),\n\t\tDefaultConstraints: channeldb.ChannelConstraints{\n\t\t\tDustLimit:        500,\n\t\t\tMaxPendingAmount: lnwire.NewMSatFromSatoshis(btcutil.SatoshiPerBitcoin) * 100,\n\t\t\tChanReserve:      100,\n\t\t\tMinHTLC:          400,\n\t\t\tMaxAcceptedHtlcs: 900,\n\t\t},\n\t\tNetParams: *netParams,\n\t}\n\n\twallet, err := lnwallet.NewLightningWallet(cfg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := wallet.Startup(); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Load our test wallet with 20 outputs each holding 4BTC.\n\tif err := loadTestCredits(miningNode, wallet, 20, 4); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn wallet, nil\n}\n",
      "length": 1151,
      "tokens": 123,
      "embedding": []
    },
    {
      "slug": "func testGetRecoveryInfo(miner *rpctest.Harness,",
      "content": "func testGetRecoveryInfo(miner *rpctest.Harness,\n\talice, bob *lnwallet.LightningWallet, t *testing.T) {\n\n\t// alice's wallet is in recovery mode\n\texpectedRecoveryMode := true\n\texpectedProgress := float64(1)\n\n\tisRecoveryMode, progress, err := alice.GetRecoveryInfo()\n\trequire.NoError(t, err, \"unable to get alice's recovery info\")\n\n\trequire.Equal(t,\n\t\texpectedRecoveryMode, isRecoveryMode, \"recovery mode incorrect\",\n\t)\n\trequire.Equal(t, expectedProgress, progress, \"progress incorrect\")\n\n\t// Generate 5 blocks and check the recovery process again.\n\tconst numBlocksMined = 5\n\t_, err = miner.Client.Generate(numBlocksMined)\n\trequire.NoError(t, err, \"unable to mine blocks\")\n\n\t// Check the recovery process. Once synced, the progress should be 1.\n\terr = waitForWalletSync(miner, alice)\n\trequire.NoError(t, err, \"Couldn't sync Alice's wallet\")\n\n\tisRecoveryMode, progress, err = alice.GetRecoveryInfo()\n\trequire.NoError(t, err, \"unable to get alice's recovery info\")\n\n\trequire.Equal(t,\n\t\texpectedRecoveryMode, isRecoveryMode, \"recovery mode incorrect\",\n\t)\n\trequire.Equal(t, expectedProgress, progress, \"progress incorrect\")\n\n\t// bob's wallet is not in recovery mode\n\texpectedRecoveryMode = false\n\texpectedProgress = float64(0)\n\n\tisRecoveryMode, progress, err = bob.GetRecoveryInfo()\n\trequire.NoError(t, err, \"unable to get bob's recovery info\")\n\n\trequire.Equal(t,\n\t\texpectedRecoveryMode, isRecoveryMode, \"recovery mode incorrect\",\n\t)\n\trequire.Equal(t, expectedProgress, progress, \"progress incorrect\")\n}\n",
      "length": 1406,
      "tokens": 155,
      "embedding": []
    },
    {
      "slug": "func testDualFundingReservationWorkflow(miner *rpctest.Harness,",
      "content": "func testDualFundingReservationWorkflow(miner *rpctest.Harness,\n\talice, bob *lnwallet.LightningWallet, t *testing.T) {\n\n\tt.Skipf(\"dual funding isn't exposed on the p2p layer\")\n\n\tfundingAmount, err := btcutil.NewAmount(5)\n\trequire.NoError(t, err, \"unable to create amt\")\n\n\t// In this scenario, we'll test a dual funder reservation, with each\n\t// side putting in 10 BTC.\n\n\t// Alice initiates a channel funded with 5 BTC for each side, so 10 BTC\n\t// total. She also generates 2 BTC in change.\n\tfeePerKw, err := alice.Cfg.FeeEstimator.EstimateFeePerKW(1)\n\trequire.NoError(t, err, \"unable to query fee estimator\")\n\taliceReq := &lnwallet.InitFundingReserveMsg{\n\t\tChainHash:        chainHash,\n\t\tNodeID:           bobPub,\n\t\tNodeAddr:         bobAddr,\n\t\tLocalFundingAmt:  fundingAmount,\n\t\tRemoteFundingAmt: fundingAmount,\n\t\tCommitFeePerKw:   feePerKw,\n\t\tFundingFeePerKw:  feePerKw,\n\t\tPushMSat:         0,\n\t\tFlags:            lnwire.FFAnnounceChannel,\n\t}\n\taliceChanReservation, err := alice.InitChannelReservation(aliceReq)\n\trequire.NoError(t, err, \"unable to initialize funding reservation\")\n\taliceChanReservation.SetNumConfsRequired(numReqConfs)\n\tchannelConstraints := &channeldb.ChannelConstraints{\n\t\tDustLimit:        alice.Cfg.DefaultConstraints.DustLimit,\n\t\tChanReserve:      fundingAmount / 100,\n\t\tMaxPendingAmount: lnwire.NewMSatFromSatoshis(fundingAmount),\n\t\tMinHTLC:          1,\n\t\tMaxAcceptedHtlcs: input.MaxHTLCNumber / 2,\n\t\tCsvDelay:         csvDelay,\n\t}\n\terr = aliceChanReservation.CommitConstraints(\n\t\tchannelConstraints, defaultMaxLocalCsvDelay, false,\n\t)\n\trequire.NoError(t, err, \"unable to verify constraints\")\n\n\t// The channel reservation should now be populated with a multi-sig key\n\t// from our HD chain, a change output with 3 BTC, and 2 outputs\n\t// selected of 4 BTC each. Additionally, the rest of the items needed\n\t// to fulfill a funding contribution should also have been filled in.\n\taliceContribution := aliceChanReservation.OurContribution()\n\tif len(aliceContribution.Inputs) != 2 {\n\t\tt.Fatalf(\"outputs for funding tx not properly selected, have %v \"+\n\t\t\t\"outputs should have 2\", len(aliceContribution.Inputs))\n\t}\n\tassertContributionInitPopulated(t, aliceContribution)\n\n\t// Bob does the same, generating his own contribution. He then also\n\t// receives' Alice's contribution, and consumes that so we can continue\n\t// the funding process.\n\tbobReq := &lnwallet.InitFundingReserveMsg{\n\t\tChainHash:        chainHash,\n\t\tNodeID:           alicePub,\n\t\tNodeAddr:         aliceAddr,\n\t\tLocalFundingAmt:  fundingAmount,\n\t\tRemoteFundingAmt: fundingAmount,\n\t\tCommitFeePerKw:   feePerKw,\n\t\tFundingFeePerKw:  feePerKw,\n\t\tPushMSat:         0,\n\t\tFlags:            lnwire.FFAnnounceChannel,\n\t}\n\tbobChanReservation, err := bob.InitChannelReservation(bobReq)\n\trequire.NoError(t, err, \"bob unable to init channel reservation\")\n\terr = bobChanReservation.CommitConstraints(\n\t\tchannelConstraints, defaultMaxLocalCsvDelay, true,\n\t)\n\trequire.NoError(t, err, \"unable to verify constraints\")\n\tbobChanReservation.SetNumConfsRequired(numReqConfs)\n\n\tassertContributionInitPopulated(t, bobChanReservation.OurContribution())\n\n\terr = bobChanReservation.ProcessContribution(aliceContribution)\n\trequire.NoError(t, err, \"bob unable to process alice's contribution\")\n\tassertContributionInitPopulated(t, bobChanReservation.TheirContribution())\n\n\tbobContribution := bobChanReservation.OurContribution()\n\n\t// Bob then sends over his contribution, which will be consumed by\n\t// Alice. After this phase, Alice should have all the necessary\n\t// material required to craft the funding transaction and commitment\n\t// transactions.\n\terr = aliceChanReservation.ProcessContribution(bobContribution)\n\trequire.NoError(t, err, \"alice unable to process bob's contribution\")\n\tassertContributionInitPopulated(t, aliceChanReservation.TheirContribution())\n\n\t// At this point, all Alice's signatures should be fully populated.\n\taliceFundingSigs, aliceCommitSig := aliceChanReservation.OurSignatures()\n\tif aliceFundingSigs == nil {\n\t\tt.Fatalf(\"alice's funding signatures not populated\")\n\t}\n\tif aliceCommitSig == nil {\n\t\tt.Fatalf(\"alice's commit signatures not populated\")\n\t}\n\n\t// Additionally, Bob's signatures should also be fully populated.\n\tbobFundingSigs, bobCommitSig := bobChanReservation.OurSignatures()\n\tif bobFundingSigs == nil {\n\t\tt.Fatalf(\"bob's funding signatures not populated\")\n\t}\n\tif bobCommitSig == nil {\n\t\tt.Fatalf(\"bob's commit signatures not populated\")\n\t}\n\n\t// To conclude, we'll consume first Alice's signatures with Bob, and\n\t// then the other way around.\n\t_, err = aliceChanReservation.CompleteReservation(\n\t\tbobFundingSigs, bobCommitSig,\n\t)\n\tif err != nil {\n\t\tfor _, in := range aliceChanReservation.FinalFundingTx().TxIn {\n\t\t\tfmt.Println(in.PreviousOutPoint.String())\n\t\t}\n\t\tt.Fatalf(\"unable to consume alice's sigs: %v\", err)\n\t}\n\t_, err = bobChanReservation.CompleteReservation(\n\t\taliceFundingSigs, aliceCommitSig,\n\t)\n\trequire.NoError(t, err, \"unable to consume bob's sigs\")\n\n\t// At this point, the funding tx should have been populated.\n\tfundingTx := aliceChanReservation.FinalFundingTx()\n\tif fundingTx == nil {\n\t\tt.Fatalf(\"funding transaction never created!\")\n\t}\n\n\t// The resulting active channel state should have been persisted to the\n\t// DB.\n\tfundingSha := fundingTx.TxHash()\n\taliceChannels, err := alice.Cfg.Database.FetchOpenChannels(bobPub)\n\trequire.NoError(t, err, \"unable to retrieve channel from DB\")\n\tif !bytes.Equal(aliceChannels[0].FundingOutpoint.Hash[:], fundingSha[:]) {\n\t\tt.Fatalf(\"channel state not properly saved\")\n\t}\n\tif !aliceChannels[0].ChanType.IsDualFunder() {\n\t\tt.Fatalf(\"channel not detected as dual funder\")\n\t}\n\tbobChannels, err := bob.Cfg.Database.FetchOpenChannels(alicePub)\n\trequire.NoError(t, err, \"unable to retrieve channel from DB\")\n\tif !bytes.Equal(bobChannels[0].FundingOutpoint.Hash[:], fundingSha[:]) {\n\t\tt.Fatalf(\"channel state not properly saved\")\n\t}\n\tif !bobChannels[0].ChanType.IsDualFunder() {\n\t\tt.Fatalf(\"channel not detected as dual funder\")\n\t}\n\n\t// Let Alice publish the funding transaction.\n\terr = alice.PublishTransaction(fundingTx, \"\")\n\trequire.NoError(t, err, \"unable to publish funding tx\")\n\n\t// Mine a single block, the funding transaction should be included\n\t// within this block.\n\terr = waitForMempoolTx(miner, &fundingSha)\n\trequire.NoError(t, err, \"tx not relayed to miner\")\n\tblockHashes, err := miner.Client.Generate(1)\n\trequire.NoError(t, err, \"unable to generate block\")\n\tblock, err := miner.Client.GetBlock(blockHashes[0])\n\trequire.NoError(t, err, \"unable to find block\")\n\tif len(block.Transactions) != 2 {\n\t\tt.Fatalf(\"funding transaction wasn't mined: %v\", err)\n\t}\n\tblockTx := block.Transactions[1]\n\tif blockTx.TxHash() != fundingSha {\n\t\tt.Fatalf(\"incorrect transaction was mined\")\n\t}\n\n\tassertReservationDeleted(aliceChanReservation, t)\n\tassertReservationDeleted(bobChanReservation, t)\n\n\t// Wait for wallets to catch up to prevent issues in subsequent tests.\n\terr = waitForWalletSync(miner, alice)\n\trequire.NoError(t, err, \"unable to sync alice\")\n\terr = waitForWalletSync(miner, bob)\n\trequire.NoError(t, err, \"unable to sync bob\")\n}\n",
      "length": 6834,
      "tokens": 726,
      "embedding": []
    },
    {
      "slug": "func testFundingTransactionLockedOutputs(miner *rpctest.Harness,",
      "content": "func testFundingTransactionLockedOutputs(miner *rpctest.Harness,\n\talice, _ *lnwallet.LightningWallet, t *testing.T) {\n\n\t// Create a single channel asking for 16 BTC total.\n\tfundingAmount, err := btcutil.NewAmount(8)\n\trequire.NoError(t, err, \"unable to create amt\")\n\tfeePerKw, err := alice.Cfg.FeeEstimator.EstimateFeePerKW(1)\n\trequire.NoError(t, err, \"unable to query fee estimator\")\n\treq := &lnwallet.InitFundingReserveMsg{\n\t\tChainHash:        chainHash,\n\t\tNodeID:           bobPub,\n\t\tNodeAddr:         bobAddr,\n\t\tLocalFundingAmt:  fundingAmount,\n\t\tRemoteFundingAmt: 0,\n\t\tCommitFeePerKw:   feePerKw,\n\t\tFundingFeePerKw:  feePerKw,\n\t\tPushMSat:         0,\n\t\tFlags:            lnwire.FFAnnounceChannel,\n\t\tPendingChanID:    [32]byte{0, 1, 2, 3},\n\t}\n\tif _, err := alice.InitChannelReservation(req); err != nil {\n\t\tt.Fatalf(\"unable to initialize funding reservation 1: %v\", err)\n\t}\n\n\t// Now attempt to reserve funds for another channel, this time\n\t// requesting 900 BTC. We only have around 64BTC worth of outpoints\n\t// that aren't locked, so this should fail.\n\tamt, err := btcutil.NewAmount(900)\n\trequire.NoError(t, err, \"unable to create amt\")\n\tfailedReq := &lnwallet.InitFundingReserveMsg{\n\t\tChainHash:        chainHash,\n\t\tNodeID:           bobPub,\n\t\tNodeAddr:         bobAddr,\n\t\tLocalFundingAmt:  amt,\n\t\tRemoteFundingAmt: 0,\n\t\tCommitFeePerKw:   feePerKw,\n\t\tFundingFeePerKw:  feePerKw,\n\t\tPushMSat:         0,\n\t\tFlags:            lnwire.FFAnnounceChannel,\n\t\tPendingChanID:    [32]byte{1, 2, 3, 4},\n\t}\n\tfailedReservation, err := alice.InitChannelReservation(failedReq)\n\tif err == nil {\n\t\tt.Fatalf(\"not error returned, should fail on coin selection\")\n\t}\n\tif _, ok := err.(*chanfunding.ErrInsufficientFunds); !ok {\n\t\tt.Fatalf(\"error not coinselect error: %v\", err)\n\t}\n\tif failedReservation != nil {\n\t\tt.Fatalf(\"reservation should be nil\")\n\t}\n}\n",
      "length": 1721,
      "tokens": 193,
      "embedding": []
    },
    {
      "slug": "func testFundingCancellationNotEnoughFunds(miner *rpctest.Harness,",
      "content": "func testFundingCancellationNotEnoughFunds(miner *rpctest.Harness,\n\talice, _ *lnwallet.LightningWallet, t *testing.T) {\n\n\tfeePerKw, err := alice.Cfg.FeeEstimator.EstimateFeePerKW(1)\n\trequire.NoError(t, err, \"unable to query fee estimator\")\n\n\t// Create a reservation for 44 BTC.\n\tfundingAmount, err := btcutil.NewAmount(44)\n\trequire.NoError(t, err, \"unable to create amt\")\n\treq := &lnwallet.InitFundingReserveMsg{\n\t\tChainHash:        chainHash,\n\t\tNodeID:           bobPub,\n\t\tNodeAddr:         bobAddr,\n\t\tLocalFundingAmt:  fundingAmount,\n\t\tRemoteFundingAmt: 0,\n\t\tCommitFeePerKw:   feePerKw,\n\t\tFundingFeePerKw:  feePerKw,\n\t\tPushMSat:         0,\n\t\tFlags:            lnwire.FFAnnounceChannel,\n\t\tPendingChanID:    [32]byte{2, 3, 4, 5},\n\t}\n\tchanReservation, err := alice.InitChannelReservation(req)\n\trequire.NoError(t, err, \"unable to initialize funding reservation\")\n\n\t// Attempt to create another channel with 44 BTC, this should fail.\n\treq.PendingChanID = [32]byte{3, 4, 5, 6}\n\t_, err = alice.InitChannelReservation(req)\n\tif _, ok := err.(*chanfunding.ErrInsufficientFunds); !ok {\n\t\tt.Fatalf(\"coin selection succeeded should have insufficient funds: %v\",\n\t\t\terr)\n\t}\n\n\t// Now cancel that old reservation.\n\tif err := chanReservation.Cancel(); err != nil {\n\t\tt.Fatalf(\"unable to cancel reservation: %v\", err)\n\t}\n\n\t// Those outpoints should no longer be locked.\n\tlockedOutPoints := alice.LockedOutpoints()\n\tif len(lockedOutPoints) != 0 {\n\t\tt.Fatalf(\"outpoints still locked\")\n\t}\n\n\t// Reservation ID should no longer be tracked.\n\tnumReservations := alice.ActiveReservations()\n\tif len(alice.ActiveReservations()) != 0 {\n\t\tt.Fatalf(\"should have 0 reservations, instead have %v\",\n\t\t\tnumReservations)\n\t}\n\n\t// TODO(roasbeef): create method like Balance that ignores locked\n\t// outpoints, will let us fail early/fast instead of querying and\n\t// attempting coin selection.\n\n\t// Request to fund a new channel should now succeed.\n\treq.PendingChanID = [32]byte{4, 5, 6, 7, 8}\n\tif _, err := alice.InitChannelReservation(req); err != nil {\n\t\tt.Fatalf(\"unable to initialize funding reservation: %v\", err)\n\t}\n}\n",
      "length": 1961,
      "tokens": 236,
      "embedding": []
    },
    {
      "slug": "func testCancelNonExistentReservation(miner *rpctest.Harness,",
      "content": "func testCancelNonExistentReservation(miner *rpctest.Harness,\n\talice, _ *lnwallet.LightningWallet, t *testing.T) {\n\n\tfeePerKw, err := alice.Cfg.FeeEstimator.EstimateFeePerKW(1)\n\trequire.NoError(t, err, \"unable to query fee estimator\")\n\n\treq := &lnwallet.InitFundingReserveMsg{\n\t\tCommitFeePerKw: feePerKw,\n\t\tPushMSat:       10,\n\t\tFlags:          lnwire.FFAnnounceChannel,\n\t\tCommitType:     lnwallet.CommitmentTypeTweakless,\n\t\tPendingChanID:  [32]byte{},\n\t}\n\n\t// Create our own reservation, give it some ID.\n\tres, err := lnwallet.NewChannelReservation(\n\t\t10000, 10000, alice, 22, &testHdSeed, 0, req,\n\t)\n\trequire.NoError(t, err, \"unable to create res\")\n\n\t// Attempt to cancel this reservation. This should fail, we know\n\t// nothing of it.\n\tif err := res.Cancel(); err == nil {\n\t\tt.Fatalf(\"canceled non-existent reservation\")\n\t}\n}\n",
      "length": 741,
      "tokens": 86,
      "embedding": []
    },
    {
      "slug": "func testReservationInitiatorBalanceBelowDustCancel(miner *rpctest.Harness,",
      "content": "func testReservationInitiatorBalanceBelowDustCancel(miner *rpctest.Harness,\n\talice, _ *lnwallet.LightningWallet, t *testing.T) {\n\n\t// We'll attempt to create a new reservation with an extremely high\n\t// commitment fee rate. This should push our balance into the negative\n\t// and result in a failure to create the reservation.\n\tconst numBTC = 4\n\tfundingAmount, err := btcutil.NewAmount(numBTC)\n\trequire.NoError(t, err, \"unable to create amt\")\n\n\tfeePerKw := chainfee.SatPerKWeight(\n\t\tnumBTC * numBTC * btcutil.SatoshiPerBitcoin,\n\t)\n\treq := &lnwallet.InitFundingReserveMsg{\n\t\tChainHash:        chainHash,\n\t\tNodeID:           bobPub,\n\t\tNodeAddr:         bobAddr,\n\t\tLocalFundingAmt:  fundingAmount,\n\t\tRemoteFundingAmt: 0,\n\t\tCommitFeePerKw:   feePerKw,\n\t\tFundingFeePerKw:  1000,\n\t\tPushMSat:         0,\n\t\tFlags:            lnwire.FFAnnounceChannel,\n\t\tCommitType:       lnwallet.CommitmentTypeTweakless,\n\t}\n\t_, err = alice.InitChannelReservation(req)\n\tswitch {\n\tcase err == nil:\n\t\tt.Fatalf(\"initialization should have failed due to \" +\n\t\t\t\"insufficient local amount\")\n\n\tcase !strings.Contains(err.Error(), \"funder balance too small\"):\n\t\tt.Fatalf(\"incorrect error: %v\", err)\n\t}\n}\n",
      "length": 1061,
      "tokens": 120,
      "embedding": []
    },
    {
      "slug": "func assertContributionInitPopulated(t *testing.T, c *lnwallet.ChannelContribution) {",
      "content": "func assertContributionInitPopulated(t *testing.T, c *lnwallet.ChannelContribution) {\n\t_, _, line, _ := runtime.Caller(1)\n\n\tif c.FirstCommitmentPoint == nil {\n\t\tt.Fatalf(\"line #%v: commitment point not fond\", line)\n\t}\n\n\tif c.CsvDelay == 0 {\n\t\tt.Fatalf(\"line #%v: csv delay not set\", line)\n\t}\n\n\tif c.MultiSigKey.PubKey == nil {\n\t\tt.Fatalf(\"line #%v: multi-sig key not set\", line)\n\t}\n\tif c.RevocationBasePoint.PubKey == nil {\n\t\tt.Fatalf(\"line #%v: revocation key not set\", line)\n\t}\n\tif c.PaymentBasePoint.PubKey == nil {\n\t\tt.Fatalf(\"line #%v: payment key not set\", line)\n\t}\n\tif c.DelayBasePoint.PubKey == nil {\n\t\tt.Fatalf(\"line #%v: delay key not set\", line)\n\t}\n\n\tif c.DustLimit == 0 {\n\t\tt.Fatalf(\"line #%v: dust limit not set\", line)\n\t}\n\tif c.MaxPendingAmount == 0 {\n\t\tt.Fatalf(\"line #%v: max pending amt not set\", line)\n\t}\n\tif c.ChanReserve == 0 {\n\t\tt.Fatalf(\"line #%v: chan reserve not set\", line)\n\t}\n\tif c.MinHTLC == 0 {\n\t\tt.Fatalf(\"line #%v: min htlc not set\", line)\n\t}\n\tif c.MaxAcceptedHtlcs == 0 {\n\t\tt.Fatalf(\"line #%v: max accepted htlc's not set\", line)\n\t}\n}\n",
      "length": 941,
      "tokens": 152,
      "embedding": []
    },
    {
      "slug": "func testSingleFunderReservationWorkflow(miner *rpctest.Harness,",
      "content": "func testSingleFunderReservationWorkflow(miner *rpctest.Harness,\n\talice, bob *lnwallet.LightningWallet, t *testing.T,\n\tcommitType lnwallet.CommitmentType,\n\taliceChanFunder chanfunding.Assembler, fetchFundingTx func() *wire.MsgTx,\n\tpendingChanID [32]byte, thawHeight uint32) {\n\n\t// For this scenario, Alice will be the channel initiator while bob\n\t// will act as the responder to the workflow.\n\n\t// First, Alice will Initialize a reservation for a channel with 4 BTC\n\t// funded solely by us. We'll also initially push 1 BTC of the channel\n\t// towards Bob's side.\n\tfundingAmt, err := btcutil.NewAmount(4)\n\trequire.NoError(t, err, \"unable to create amt\")\n\tpushAmt := lnwire.NewMSatFromSatoshis(btcutil.SatoshiPerBitcoin)\n\tfeePerKw, err := alice.Cfg.FeeEstimator.EstimateFeePerKW(1)\n\trequire.NoError(t, err, \"unable to query fee estimator\")\n\taliceReq := &lnwallet.InitFundingReserveMsg{\n\t\tChainHash:        chainHash,\n\t\tPendingChanID:    pendingChanID,\n\t\tNodeID:           bobPub,\n\t\tNodeAddr:         bobAddr,\n\t\tLocalFundingAmt:  fundingAmt,\n\t\tRemoteFundingAmt: 0,\n\t\tCommitFeePerKw:   feePerKw,\n\t\tFundingFeePerKw:  feePerKw,\n\t\tPushMSat:         pushAmt,\n\t\tFlags:            lnwire.FFAnnounceChannel,\n\t\tCommitType:       commitType,\n\t\tChanFunder:       aliceChanFunder,\n\t}\n\taliceChanReservation, err := alice.InitChannelReservation(aliceReq)\n\trequire.NoError(t, err, \"unable to init channel reservation\")\n\taliceChanReservation.SetNumConfsRequired(numReqConfs)\n\tchannelConstraints := &channeldb.ChannelConstraints{\n\t\tDustLimit:        alice.Cfg.DefaultConstraints.DustLimit,\n\t\tChanReserve:      fundingAmt / 100,\n\t\tMaxPendingAmount: lnwire.NewMSatFromSatoshis(fundingAmt),\n\t\tMinHTLC:          1,\n\t\tMaxAcceptedHtlcs: input.MaxHTLCNumber / 2,\n\t\tCsvDelay:         csvDelay,\n\t}\n\terr = aliceChanReservation.CommitConstraints(\n\t\tchannelConstraints, defaultMaxLocalCsvDelay, false,\n\t)\n\trequire.NoError(t, err, \"unable to verify constraints\")\n\n\t// Verify all contribution fields have been set properly, but only if\n\t// Alice is the funder herself.\n\taliceContribution := aliceChanReservation.OurContribution()\n\tif fetchFundingTx == nil {\n\t\tif len(aliceContribution.Inputs) < 1 {\n\t\t\tt.Fatalf(\"outputs for funding tx not properly \"+\n\t\t\t\t\"selected, have %v outputs should at least 1\",\n\t\t\t\tlen(aliceContribution.Inputs))\n\t\t}\n\t\tif len(aliceContribution.ChangeOutputs) != 1 {\n\t\t\tt.Fatalf(\"coin selection failed, should have one \"+\n\t\t\t\t\"change outputs, instead have: %v\",\n\t\t\t\tlen(aliceContribution.ChangeOutputs))\n\t\t}\n\t}\n\tassertContributionInitPopulated(t, aliceContribution)\n\n\t// Next, Bob receives the initial request, generates a corresponding\n\t// reservation initiation, then consume Alice's contribution.\n\tbobReq := &lnwallet.InitFundingReserveMsg{\n\t\tChainHash:        chainHash,\n\t\tPendingChanID:    pendingChanID,\n\t\tNodeID:           alicePub,\n\t\tNodeAddr:         aliceAddr,\n\t\tLocalFundingAmt:  0,\n\t\tRemoteFundingAmt: fundingAmt,\n\t\tCommitFeePerKw:   feePerKw,\n\t\tFundingFeePerKw:  feePerKw,\n\t\tPushMSat:         pushAmt,\n\t\tFlags:            lnwire.FFAnnounceChannel,\n\t\tCommitType:       commitType,\n\t}\n\tbobChanReservation, err := bob.InitChannelReservation(bobReq)\n\trequire.NoError(t, err, \"unable to create bob reservation\")\n\terr = bobChanReservation.CommitConstraints(\n\t\tchannelConstraints, defaultMaxLocalCsvDelay, true,\n\t)\n\trequire.NoError(t, err, \"unable to verify constraints\")\n\tbobChanReservation.SetNumConfsRequired(numReqConfs)\n\n\t// We'll ensure that Bob's contribution also gets generated properly.\n\tbobContribution := bobChanReservation.OurContribution()\n\tassertContributionInitPopulated(t, bobContribution)\n\n\t// With his contribution generated, he can now process Alice's\n\t// contribution.\n\terr = bobChanReservation.ProcessSingleContribution(aliceContribution)\n\trequire.NoError(t, err, \"bob unable to process alice's contribution\")\n\tassertContributionInitPopulated(t, bobChanReservation.TheirContribution())\n\n\t// Bob will next send over his contribution to Alice, we simulate this\n\t// by having Alice immediately process his contribution.\n\terr = aliceChanReservation.ProcessContribution(bobContribution)\n\tif err != nil {\n\t\tt.Fatalf(\"alice unable to process bob's contribution\")\n\t}\n\tassertContributionInitPopulated(t, bobChanReservation.TheirContribution())\n\n\t// At this point, Alice should have generated all the signatures\n\t// required for the funding transaction, as well as Alice's commitment\n\t// signature to bob, but only if the funding transaction was\n\t// constructed internally.\n\taliceRemoteContribution := aliceChanReservation.TheirContribution()\n\taliceFundingSigs, aliceCommitSig := aliceChanReservation.OurSignatures()\n\tif fetchFundingTx == nil && aliceFundingSigs == nil {\n\t\tt.Fatalf(\"funding sigs not found\")\n\t}\n\tif aliceCommitSig == nil {\n\t\tt.Fatalf(\"commitment sig not found\")\n\t}\n\n\t// Additionally, the funding tx and the funding outpoint should have\n\t// been populated.\n\tif aliceChanReservation.FinalFundingTx() == nil && fetchFundingTx == nil {\n\t\tt.Fatalf(\"funding transaction never created!\")\n\t}\n\tif aliceChanReservation.FundingOutpoint() == nil {\n\t\tt.Fatalf(\"funding outpoint never created!\")\n\t}\n\n\t// Their funds should also be filled in.\n\tif len(aliceRemoteContribution.Inputs) != 0 {\n\t\tt.Fatalf(\"bob shouldn't have any inputs, instead has %v\",\n\t\t\tlen(aliceRemoteContribution.Inputs))\n\t}\n\tif len(aliceRemoteContribution.ChangeOutputs) != 0 {\n\t\tt.Fatalf(\"bob shouldn't have any change outputs, instead \"+\n\t\t\t\"has %v\",\n\t\t\taliceRemoteContribution.ChangeOutputs[0].Value)\n\t}\n\n\t// Next, Alice will send over her signature for Bob's commitment\n\t// transaction, as well as the funding outpoint.\n\tfundingPoint := aliceChanReservation.FundingOutpoint()\n\t_, err = bobChanReservation.CompleteReservationSingle(\n\t\tfundingPoint, aliceCommitSig,\n\t)\n\trequire.NoError(t, err, \"bob unable to consume single reservation\")\n\n\t// Finally, we'll conclude the reservation process by sending over\n\t// Bob's commitment signature, which is the final thing Alice needs to\n\t// be able to safely broadcast the funding transaction.\n\t_, bobCommitSig := bobChanReservation.OurSignatures()\n\tif bobCommitSig == nil {\n\t\tt.Fatalf(\"bob failed to generate commitment signature: %v\", err)\n\t}\n\t_, err = aliceChanReservation.CompleteReservation(\n\t\tnil, bobCommitSig,\n\t)\n\trequire.NoError(t, err, \"alice unable to complete reservation\")\n\n\t// If the caller provided an alternative way to obtain the funding tx,\n\t// then we'll use that. Otherwise, we'll obtain it directly from Alice.\n\tvar fundingTx *wire.MsgTx\n\tif fetchFundingTx != nil {\n\t\tfundingTx = fetchFundingTx()\n\t} else {\n\t\tfundingTx = aliceChanReservation.FinalFundingTx()\n\t}\n\n\t// The resulting active channel state should have been persisted to the\n\t// DB for both Alice and Bob.\n\tfundingSha := fundingTx.TxHash()\n\taliceChannels, err := alice.Cfg.Database.FetchOpenChannels(bobPub)\n\trequire.NoError(t, err, \"unable to retrieve channel from DB\")\n\tif len(aliceChannels) != 1 {\n\t\tt.Fatalf(\"alice didn't save channel state: %v\", err)\n\t}\n\tif !bytes.Equal(aliceChannels[0].FundingOutpoint.Hash[:], fundingSha[:]) {\n\t\tt.Fatalf(\"channel state not properly saved: %v vs %v\",\n\t\t\thex.EncodeToString(aliceChannels[0].FundingOutpoint.Hash[:]),\n\t\t\thex.EncodeToString(fundingSha[:]))\n\t}\n\tif !aliceChannels[0].IsInitiator {\n\t\tt.Fatalf(\"alice not detected as channel initiator\")\n\t}\n\tif !aliceChannels[0].ChanType.IsSingleFunder() {\n\t\tt.Fatalf(\"channel type is incorrect, expected %v instead got %v\",\n\t\t\tchanneldb.SingleFunderBit, aliceChannels[0].ChanType)\n\t}\n\n\tbobChannels, err := bob.Cfg.Database.FetchOpenChannels(alicePub)\n\trequire.NoError(t, err, \"unable to retrieve channel from DB\")\n\tif len(bobChannels) != 1 {\n\t\tt.Fatalf(\"bob didn't save channel state: %v\", err)\n\t}\n\tif !bytes.Equal(bobChannels[0].FundingOutpoint.Hash[:], fundingSha[:]) {\n\t\tt.Fatalf(\"channel state not properly saved: %v vs %v\",\n\t\t\thex.EncodeToString(bobChannels[0].FundingOutpoint.Hash[:]),\n\t\t\thex.EncodeToString(fundingSha[:]))\n\t}\n\tif bobChannels[0].IsInitiator {\n\t\tt.Fatalf(\"bob not detected as channel responder\")\n\t}\n\tif !bobChannels[0].ChanType.IsSingleFunder() {\n\t\tt.Fatalf(\"channel type is incorrect, expected %v instead got %v\",\n\t\t\tchanneldb.SingleFunderBit, bobChannels[0].ChanType)\n\t}\n\n\t// Let Alice publish the funding transaction.\n\terr = alice.PublishTransaction(fundingTx, \"\")\n\trequire.NoError(t, err, \"unable to publish funding tx\")\n\n\t// Mine a single block, the funding transaction should be included\n\t// within this block.\n\terr = waitForMempoolTx(miner, &fundingSha)\n\trequire.NoError(t, err, \"tx not relayed to miner\")\n\tblockHashes, err := miner.Client.Generate(1)\n\trequire.NoError(t, err, \"unable to generate block\")\n\tblock, err := miner.Client.GetBlock(blockHashes[0])\n\trequire.NoError(t, err, \"unable to find block\")\n\tif len(block.Transactions) != 2 {\n\t\tt.Fatalf(\"funding transaction wasn't mined: %d\",\n\t\t\tlen(block.Transactions))\n\t}\n\tblockTx := block.Transactions[1]\n\tif blockTx.TxHash() != fundingSha {\n\t\tt.Fatalf(\"incorrect transaction was mined\")\n\t}\n\n\t// If a frozen channel was requested, then we expect that both channel\n\t// types show as being a frozen channel type.\n\taliceChanFrozen := aliceChannels[0].ChanType.IsFrozen()\n\tbobChanFrozen := bobChannels[0].ChanType.IsFrozen()\n\tif thawHeight != 0 && (!aliceChanFrozen || !bobChanFrozen) {\n\t\tt.Fatalf(\"expected both alice and bob to have frozen chans: \"+\n\t\t\t\"alice_frozen=%v, bob_frozen=%v\", aliceChanFrozen,\n\t\t\tbobChanFrozen)\n\t}\n\tif thawHeight != bobChannels[0].ThawHeight {\n\t\tt.Fatalf(\"wrong thaw height: expected %v got %v\", thawHeight,\n\t\t\tbobChannels[0].ThawHeight)\n\t}\n\tif thawHeight != aliceChannels[0].ThawHeight {\n\t\tt.Fatalf(\"wrong thaw height: expected %v got %v\", thawHeight,\n\t\t\taliceChannels[0].ThawHeight)\n\t}\n\n\tassertReservationDeleted(aliceChanReservation, t)\n\tassertReservationDeleted(bobChanReservation, t)\n}\n",
      "length": 9474,
      "tokens": 998,
      "embedding": []
    },
    {
      "slug": "func testListTransactionDetails(miner *rpctest.Harness,",
      "content": "func testListTransactionDetails(miner *rpctest.Harness,\n\talice, _ *lnwallet.LightningWallet, t *testing.T) {\n\n\t// Create 5 new outputs spendable by the wallet.\n\tconst numTxns = 5\n\tconst outputAmt = btcutil.SatoshiPerBitcoin\n\tisOurAddress := make(map[string]bool)\n\ttxids := make(map[chainhash.Hash]struct{})\n\tfor i := 0; i < numTxns; i++ {\n\t\taddr, err := alice.NewAddress(\n\t\t\tlnwallet.WitnessPubKey, false,\n\t\t\tlnwallet.DefaultAccountName,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to create new address: %v\", err)\n\t\t}\n\t\tisOurAddress[addr.EncodeAddress()] = true\n\t\tscript, err := txscript.PayToAddrScript(addr)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to create output script: %v\", err)\n\t\t}\n\n\t\toutput := &wire.TxOut{\n\t\t\tValue:    outputAmt,\n\t\t\tPkScript: script,\n\t\t}\n\t\ttxid, err := miner.SendOutputs([]*wire.TxOut{output}, 2500)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to send coinbase: %v\", err)\n\t\t}\n\t\ttxids[*txid] = struct{}{}\n\t}\n\n\t// Get the miner's current best block height before we mine blocks.\n\t_, startHeight, err := miner.Client.GetBestBlock()\n\trequire.NoError(t, err, \"cannot get best block\")\n\n\t// Generate 10 blocks to mine all the transactions created above.\n\tconst numBlocksMined = 10\n\tblocks, err := miner.Client.Generate(numBlocksMined)\n\trequire.NoError(t, err, \"unable to mine blocks\")\n\n\t// Our new best block height should be our start height + the number of\n\t// blocks we just mined.\n\tchainTip := startHeight + numBlocksMined\n\n\t// Next, fetch all the current transaction details. We should find all\n\t// of our transactions between our start height before we generated\n\t// blocks, and our end height, which is the chain tip. This query does\n\t// not include unconfirmed transactions, since all of our transactions\n\t// should be confirmed.\n\terr = waitForWalletSync(miner, alice)\n\trequire.NoError(t, err, \"Couldn't sync Alice's wallet\")\n\ttxDetails, err := alice.ListTransactionDetails(\n\t\tstartHeight, chainTip, \"\",\n\t)\n\trequire.NoError(t, err, \"unable to fetch tx details\")\n\n\t// This is a mapping from:\n\t// blockHash -> transactionHash -> transactionOutputs\n\tblockTxOuts := make(map[chainhash.Hash]map[chainhash.Hash][]*wire.TxOut)\n\n\t// Each of the transactions created above should be found with the\n\t// proper details populated.\n\tfor _, txDetail := range txDetails {\n\t\tif _, ok := txids[txDetail.Hash]; !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tif txDetail.NumConfirmations != numBlocksMined {\n\t\t\tt.Fatalf(\"num confs incorrect, got %v expected %v\",\n\t\t\t\ttxDetail.NumConfirmations, numBlocksMined)\n\t\t}\n\t\tif txDetail.Value != outputAmt {\n\t\t\tt.Fatalf(\"tx value incorrect, got %v expected %v\",\n\t\t\t\ttxDetail.Value, outputAmt)\n\t\t}\n\n\t\tif !bytes.Equal(txDetail.BlockHash[:], blocks[0][:]) {\n\t\t\tt.Fatalf(\"block hash mismatch, got %v expected %v\",\n\t\t\t\ttxDetail.BlockHash, blocks[0])\n\t\t}\n\n\t\t// This fetches the transactions in a block so that we can compare the\n\t\t// txouts stored in the mined transaction against the ones in the transaction\n\t\t// details\n\t\tif _, ok := blockTxOuts[*txDetail.BlockHash]; !ok {\n\t\t\tfetchedBlock, err := alice.Cfg.ChainIO.GetBlock(txDetail.BlockHash)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"err fetching block: %s\", err)\n\t\t\t}\n\n\t\t\ttransactions :=\n\t\t\t\tmake(map[chainhash.Hash][]*wire.TxOut, len(fetchedBlock.Transactions))\n\t\t\tfor _, tx := range fetchedBlock.Transactions {\n\t\t\t\ttransactions[tx.TxHash()] = tx.TxOut\n\t\t\t}\n\n\t\t\tblockTxOuts[fetchedBlock.BlockHash()] = transactions\n\t\t}\n\n\t\tif txOuts, ok := blockTxOuts[*txDetail.BlockHash][txDetail.Hash]; !ok {\n\t\t\tt.Fatalf(\"tx (%v) not found in block (%v)\",\n\t\t\t\ttxDetail.Hash, txDetail.BlockHash)\n\t\t} else {\n\t\t\tvar destinationOutputs []lnwallet.OutputDetail\n\n\t\t\tfor i, txOut := range txOuts {\n\t\t\t\tsc, addrs, _, err :=\n\t\t\t\t\ttxscript.ExtractPkScriptAddrs(txOut.PkScript, &alice.Cfg.NetParams)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"err extract script addresses: %s\", err)\n\t\t\t\t}\n\t\t\t\tdestinationOutputs = append(destinationOutputs, lnwallet.OutputDetail{\n\t\t\t\t\tOutputType:   sc,\n\t\t\t\t\tAddresses:    addrs,\n\t\t\t\t\tPkScript:     txOut.PkScript,\n\t\t\t\t\tOutputIndex:  i,\n\t\t\t\t\tValue:        btcutil.Amount(txOut.Value),\n\t\t\t\t\tIsOurAddress: isOurAddress[addrs[0].EncodeAddress()],\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(txDetail.OutputDetails, destinationOutputs) {\n\t\t\t\tt.Fatalf(\"destination outputs mismatch, got %v expected %v\",\n\t\t\t\t\ttxDetail.OutputDetails, destinationOutputs)\n\t\t\t}\n\t\t}\n\n\t\tdelete(txids, txDetail.Hash)\n\t}\n\tif len(txids) != 0 {\n\t\tt.Fatalf(\"all transactions not found in details: left=%v, \"+\n\t\t\t\"returned_set=%v\", spew.Sdump(txids),\n\t\t\tspew.Sdump(txDetails))\n\t}\n\n\t// Next create a transaction paying to an output which isn't under the\n\t// wallet's control.\n\tminerAddr, err := miner.NewAddress()\n\trequire.NoError(t, err, \"unable to generate address\")\n\toutputScript, err := txscript.PayToAddrScript(minerAddr)\n\trequire.NoError(t, err, \"unable to make output script\")\n\tburnOutput := wire.NewTxOut(outputAmt, outputScript)\n\tburnTX, err := alice.SendOutputs(\n\t\t[]*wire.TxOut{burnOutput}, 2500, 1, labels.External,\n\t)\n\trequire.NoError(t, err, \"unable to create burn tx\")\n\tburnTXID := burnTX.TxHash()\n\terr = waitForMempoolTx(miner, &burnTXID)\n\trequire.NoError(t, err, \"tx not relayed to miner\")\n\n\t// Before we mine the next block, we'll ensure that the above\n\t// transaction shows up in the set of unconfirmed transactions returned\n\t// by ListTransactionDetails.\n\terr = waitForWalletSync(miner, alice)\n\trequire.NoError(t, err, \"Couldn't sync Alice's wallet\")\n\n\t// Query our wallet for transactions from the chain tip, including\n\t// unconfirmed transactions. The transaction above should be included\n\t// with a confirmation height of 0, indicating that it has not been\n\t// mined yet.\n\ttxDetails, err = alice.ListTransactionDetails(\n\t\tchainTip, btcwallet.UnconfirmedHeight, \"\",\n\t)\n\trequire.NoError(t, err, \"unable to fetch tx details\")\n\tvar mempoolTxFound bool\n\tfor _, txDetail := range txDetails {\n\t\tif !bytes.Equal(txDetail.Hash[:], burnTXID[:]) {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Now that we've found the transaction, ensure that it has a\n\t\t// negative number of confirmations to indicate that it's\n\t\t// unconfirmed.\n\t\tmempoolTxFound = true\n\t\tif txDetail.NumConfirmations != 0 {\n\t\t\tt.Fatalf(\"num confs incorrect, got %v expected %v\",\n\t\t\t\ttxDetail.NumConfirmations, 0)\n\t\t}\n\n\t\t// We test that each txDetail has destination addresses. This ensures\n\t\t// that even when we have 0 confirmation transactions, the destination\n\t\t// addresses are returned.\n\t\tvar match bool\n\t\tfor _, o := range txDetail.OutputDetails {\n\t\t\tfor _, addr := range o.Addresses {\n\t\t\t\tif addr.String() == minerAddr.String() {\n\t\t\t\t\tmatch = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif !match {\n\t\t\tt.Fatalf(\"minerAddr: %v should have been a dest addr\", minerAddr)\n\t\t}\n\t}\n\tif !mempoolTxFound {\n\t\tt.Fatalf(\"unable to find mempool tx in tx details!\")\n\t}\n\n\t// Generate one block for our transaction to confirm in.\n\tvar numBlocks int32 = 1\n\tburnBlock, err := miner.Client.Generate(uint32(numBlocks))\n\trequire.NoError(t, err, \"unable to mine block\")\n\n\t// Progress our chain tip by the number of blocks we have just mined.\n\tchainTip += numBlocks\n\n\t// Fetch the transaction details again, the new transaction should be\n\t// shown as debiting from the wallet's balance. Start and end height\n\t// are inclusive, so we use chainTip for both parameters to get only\n\t// transactions from the last block.\n\terr = waitForWalletSync(miner, alice)\n\trequire.NoError(t, err, \"Couldn't sync Alice's wallet\")\n\ttxDetails, err = alice.ListTransactionDetails(chainTip, chainTip, \"\")\n\trequire.NoError(t, err, \"unable to fetch tx details\")\n\tvar burnTxFound bool\n\tfor _, txDetail := range txDetails {\n\t\tif !bytes.Equal(txDetail.Hash[:], burnTXID[:]) {\n\t\t\tcontinue\n\t\t}\n\n\t\tburnTxFound = true\n\t\tif txDetail.NumConfirmations != 1 {\n\t\t\tt.Fatalf(\"num confs incorrect, got %v expected %v\",\n\t\t\t\ttxDetail.NumConfirmations, 1)\n\t\t}\n\n\t\t// We assert that the value is greater than the amount we\n\t\t// attempted to send, as the wallet should have paid some amount\n\t\t// of network fees.\n\t\tif txDetail.Value >= -outputAmt {\n\t\t\tfmt.Println(spew.Sdump(txDetail))\n\t\t\tt.Fatalf(\"tx value incorrect, got %v expected %v\",\n\t\t\t\tint64(txDetail.Value), -int64(outputAmt))\n\t\t}\n\t\tif !bytes.Equal(txDetail.BlockHash[:], burnBlock[0][:]) {\n\t\t\tt.Fatalf(\"block hash mismatch, got %v expected %v\",\n\t\t\t\ttxDetail.BlockHash, burnBlock[0])\n\t\t}\n\t}\n\tif !burnTxFound {\n\t\tt.Fatal(\"tx burning btc not found\")\n\t}\n\n\t// Generate a block which has no wallet transactions in it.\n\tchainTip += numBlocks\n\t_, err = miner.Client.Generate(uint32(numBlocks))\n\trequire.NoError(t, err, \"unable to mine block\")\n\n\terr = waitForWalletSync(miner, alice)\n\trequire.NoError(t, err, \"Couldn't sync Alice's wallet\")\n\n\t// Query for transactions only in the latest block. We do not expect\n\t// any transactions to be returned.\n\ttxDetails, err = alice.ListTransactionDetails(chainTip, chainTip, \"\")\n\trequire.NoError(t, err, \"unexpected error\")\n\tif len(txDetails) != 0 {\n\t\tt.Fatalf(\"expected 0 transactions, got: %v\", len(txDetails))\n\t}\n}\n",
      "length": 8597,
      "tokens": 1100,
      "embedding": []
    },
    {
      "slug": "func testTransactionSubscriptions(miner *rpctest.Harness,",
      "content": "func testTransactionSubscriptions(miner *rpctest.Harness,\n\talice, _ *lnwallet.LightningWallet, t *testing.T) {\n\n\t// First, check to see if this wallet meets the TransactionNotifier\n\t// interface, if not then we'll skip this test for this particular\n\t// implementation of the WalletController.\n\ttxClient, err := alice.SubscribeTransactions()\n\tif err != nil {\n\t\tt.Skipf(\"unable to generate tx subscription: %v\", err)\n\t}\n\tdefer txClient.Cancel()\n\n\tconst (\n\t\toutputAmt = btcutil.SatoshiPerBitcoin\n\t\tnumTxns   = 3\n\t)\n\terrCh1 := make(chan error, 1)\n\tswitch alice.BackEnd() {\n\tcase \"neutrino\":\n\t\t// Neutrino doesn't listen for unconfirmed transactions.\n\tdefault:\n\t\tgo func() {\n\t\t\tfor i := 0; i < numTxns; i++ {\n\t\t\t\ttxDetail := <-txClient.UnconfirmedTransactions()\n\t\t\t\tif txDetail.NumConfirmations != 0 {\n\t\t\t\t\terrCh1 <- fmt.Errorf(\"incorrect number of confs, \"+\n\t\t\t\t\t\t\"expected %v got %v\", 0,\n\t\t\t\t\t\ttxDetail.NumConfirmations)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif txDetail.Value != outputAmt {\n\t\t\t\t\terrCh1 <- fmt.Errorf(\"incorrect output amt, \"+\n\t\t\t\t\t\t\"expected %v got %v\", outputAmt,\n\t\t\t\t\t\ttxDetail.Value)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif txDetail.BlockHash != nil {\n\t\t\t\t\terrCh1 <- fmt.Errorf(\"block hash should be nil, \"+\n\t\t\t\t\t\t\"is instead %v\",\n\t\t\t\t\t\ttxDetail.BlockHash)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\terrCh1 <- nil\n\t\t}()\n\t}\n\n\t// Next, fetch a fresh address from the wallet, create 3 new outputs\n\t// with the pkScript.\n\tfor i := 0; i < numTxns; i++ {\n\t\taddr, err := alice.NewAddress(\n\t\t\tlnwallet.WitnessPubKey, false,\n\t\t\tlnwallet.DefaultAccountName,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to create new address: %v\", err)\n\t\t}\n\t\tscript, err := txscript.PayToAddrScript(addr)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to create output script: %v\", err)\n\t\t}\n\n\t\toutput := &wire.TxOut{\n\t\t\tValue:    outputAmt,\n\t\t\tPkScript: script,\n\t\t}\n\t\ttxid, err := miner.SendOutputs([]*wire.TxOut{output}, 2500)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to send coinbase: %v\", err)\n\t\t}\n\t\terr = waitForMempoolTx(miner, txid)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"tx not relayed to miner: %v\", err)\n\t\t}\n\t}\n\n\tswitch alice.BackEnd() {\n\tcase \"neutrino\":\n\t\t// Neutrino doesn't listen for on unconfirmed transactions.\n\tdefault:\n\t\t// We should receive a notification for all three transactions\n\t\t// generated above.\n\t\tselect {\n\t\tcase <-time.After(time.Second * 10):\n\t\t\tt.Fatalf(\"transactions not received after 10 seconds\")\n\t\tcase err := <-errCh1:\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}\n\t}\n\n\terrCh2 := make(chan error, 1)\n\tgo func() {\n\t\tfor i := 0; i < numTxns; i++ {\n\t\t\ttxDetail := <-txClient.ConfirmedTransactions()\n\t\t\tif txDetail.NumConfirmations != 1 {\n\t\t\t\terrCh2 <- fmt.Errorf(\"incorrect number of confs for %s, expected %v got %v\",\n\t\t\t\t\ttxDetail.Hash, 1, txDetail.NumConfirmations)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif txDetail.Value != outputAmt {\n\t\t\t\terrCh2 <- fmt.Errorf(\"incorrect output amt, expected %v got %v in txid %s\",\n\t\t\t\t\toutputAmt, txDetail.Value, txDetail.Hash)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\terrCh2 <- nil\n\t}()\n\n\t// Next mine a single block, all the transactions generated above\n\t// should be included.\n\tif _, err := miner.Client.Generate(1); err != nil {\n\t\tt.Fatalf(\"unable to generate block: %v\", err)\n\t}\n\n\t// We should receive a notification for all three transactions\n\t// since they should be mined in the next block.\n\tselect {\n\tcase <-time.After(time.Second * 5):\n\t\tt.Fatalf(\"transactions not received after 5 seconds\")\n\tcase err := <-errCh2:\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\t// We'll also ensure that the client is able to send our new\n\t// notifications when we _create_ transactions ourselves that spend our\n\t// own outputs.\n\tb := txscript.NewScriptBuilder()\n\tb.AddOp(txscript.OP_RETURN)\n\toutputScript, err := b.Script()\n\trequire.NoError(t, err, \"unable to make output script\")\n\tburnOutput := wire.NewTxOut(outputAmt, outputScript)\n\ttx, err := alice.SendOutputs(\n\t\t[]*wire.TxOut{burnOutput}, 2500, 1, labels.External,\n\t)\n\trequire.NoError(t, err, \"unable to create burn tx\")\n\ttxid := tx.TxHash()\n\terr = waitForMempoolTx(miner, &txid)\n\trequire.NoError(t, err, \"tx not relayed to miner\")\n\n\t// Before we mine the next block, we'll ensure that the above\n\t// transaction shows up in the set of unconfirmed transactions returned\n\t// by ListTransactionDetails.\n\terr = waitForWalletSync(miner, alice)\n\trequire.NoError(t, err, \"Couldn't sync Alice's wallet\")\n\n\t// As we just sent the transaction and it was landed in the mempool, we\n\t// should get a notification for a new unconfirmed transactions\n\tselect {\n\tcase <-time.After(time.Second * 10):\n\t\tt.Fatalf(\"transactions not received after 10 seconds\")\n\tcase unConfTx := <-txClient.UnconfirmedTransactions():\n\t\tif unConfTx.Hash != txid {\n\t\t\tt.Fatalf(\"wrong txn notified: expected %v got %v\",\n\t\t\t\ttxid, unConfTx.Hash)\n\t\t}\n\t}\n}\n\n// scriptFromKey creates a P2WKH script from the given pubkey.",
      "length": 4558,
      "tokens": 641,
      "embedding": []
    },
    {
      "slug": "func scriptFromKey(pubkey *btcec.PublicKey) ([]byte, error) {",
      "content": "func scriptFromKey(pubkey *btcec.PublicKey) ([]byte, error) {\n\tpubkeyHash := btcutil.Hash160(pubkey.SerializeCompressed())\n\tkeyAddr, err := btcutil.NewAddressWitnessPubKeyHash(\n\t\tpubkeyHash, &chaincfg.RegressionNetParams,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to create addr: %v\", err)\n\t}\n\tkeyScript, err := txscript.PayToAddrScript(keyAddr)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to generate script: %v\", err)\n\t}\n\n\treturn keyScript, nil\n}\n\n// mineAndAssert mines a block and ensures the passed TX is part of that block.",
      "length": 469,
      "tokens": 61,
      "embedding": []
    },
    {
      "slug": "func mineAndAssert(r *rpctest.Harness, tx *wire.MsgTx) error {",
      "content": "func mineAndAssert(r *rpctest.Harness, tx *wire.MsgTx) error {\n\ttxid := tx.TxHash()\n\terr := waitForMempoolTx(r, &txid)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"tx not relayed to miner: %v\", err)\n\t}\n\n\tblockHashes, err := r.Client.Generate(1)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to generate block: %v\", err)\n\t}\n\n\tblock, err := r.Client.GetBlock(blockHashes[0])\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to find block: %v\", err)\n\t}\n\n\tif len(block.Transactions) != 2 {\n\t\treturn fmt.Errorf(\"expected 2 txs in block, got %d\",\n\t\t\tlen(block.Transactions))\n\t}\n\n\tblockTx := block.Transactions[1]\n\tif blockTx.TxHash() != tx.TxHash() {\n\t\treturn fmt.Errorf(\"incorrect transaction was mined\")\n\t}\n\n\t// Sleep for a second before returning, to make sure the block has\n\t// propagated.\n\ttime.Sleep(1 * time.Second)\n\treturn nil\n}\n\n// txFromOutput takes a tx paying to fromPubKey, and creates a new tx that\n// spends the output from this tx, to an address derived from payToPubKey.",
      "length": 873,
      "tokens": 132,
      "embedding": []
    },
    {
      "slug": "func txFromOutput(tx *wire.MsgTx, signer input.Signer, fromPubKey,",
      "content": "func txFromOutput(tx *wire.MsgTx, signer input.Signer, fromPubKey,\n\tpayToPubKey *btcec.PublicKey, txFee btcutil.Amount,\n\trbf bool) (*wire.MsgTx, error) {\n\n\t// Generate the script we want to spend from.\n\tkeyScript, err := scriptFromKey(fromPubKey)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to generate script: %v\", err)\n\t}\n\n\t// We assume the output was paid to the keyScript made earlier.\n\tvar outputIndex uint32\n\tif len(tx.TxOut) == 1 || bytes.Equal(tx.TxOut[0].PkScript, keyScript) {\n\t\toutputIndex = 0\n\t} else {\n\t\toutputIndex = 1\n\t}\n\toutputValue := tx.TxOut[outputIndex].Value\n\n\t// With the index located, we can create a transaction spending the\n\t// referenced output.\n\ttx1 := wire.NewMsgTx(2)\n\n\t// If we want to create a tx that signals replacement, set its\n\t// sequence number to the max one that signals replacement.\n\t// Otherwise we just use the standard max sequence.\n\tsequence := wire.MaxTxInSequenceNum\n\tif rbf {\n\t\tsequence = mempool.MaxRBFSequence\n\t}\n\n\ttx1.AddTxIn(&wire.TxIn{\n\t\tPreviousOutPoint: wire.OutPoint{\n\t\t\tHash:  tx.TxHash(),\n\t\t\tIndex: outputIndex,\n\t\t},\n\t\tSequence: sequence,\n\t})\n\n\t// Create a script to pay to.\n\tpayToScript, err := scriptFromKey(payToPubKey)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to generate script: %v\", err)\n\t}\n\ttx1.AddTxOut(&wire.TxOut{\n\t\tValue:    outputValue - int64(txFee),\n\t\tPkScript: payToScript,\n\t})\n\n\t// Now we can populate the sign descriptor which we'll use to generate\n\t// the signature.\n\tsignDesc := &input.SignDescriptor{\n\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\tPubKey: fromPubKey,\n\t\t},\n\t\tWitnessScript: keyScript,\n\t\tOutput:        tx.TxOut[outputIndex],\n\t\tHashType:      txscript.SigHashAll,\n\t\tSigHashes:     input.NewTxSigHashesV0Only(tx1),\n\t\tInputIndex:    0, // Has only one input.\n\t}\n\n\t// With the descriptor created, we use it to generate a signature, then\n\t// manually create a valid witness stack we'll use for signing.\n\tspendSig, err := signer.SignOutputRaw(tx1, signDesc)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to generate signature: %v\", err)\n\t}\n\twitness := make([][]byte, 2)\n\twitness[0] = append(spendSig.Serialize(), byte(txscript.SigHashAll))\n\twitness[1] = fromPubKey.SerializeCompressed()\n\ttx1.TxIn[0].Witness = witness\n\n\t// Finally, attempt to validate the completed transaction. This should\n\t// succeed if the wallet was able to properly generate the proper\n\t// private key.\n\tvm, err := txscript.NewEngine(\n\t\tkeyScript, tx1, 0, txscript.StandardVerifyFlags, nil,\n\t\tnil, outputValue, txscript.NewCannedPrevOutputFetcher(\n\t\t\tkeyScript, outputValue,\n\t\t),\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to create engine: %v\", err)\n\t}\n\tif err := vm.Execute(); err != nil {\n\t\treturn nil, fmt.Errorf(\"spend is invalid: %v\", err)\n\t}\n\n\treturn tx1, nil\n}\n\n// newTx sends coins from Alice's wallet, mines this transaction, and creates a\n// new, unconfirmed tx that spends this output to pubKey.",
      "length": 2728,
      "tokens": 371,
      "embedding": []
    },
    {
      "slug": "func newTx(t *testing.T, r *rpctest.Harness, pubKey *btcec.PublicKey,",
      "content": "func newTx(t *testing.T, r *rpctest.Harness, pubKey *btcec.PublicKey,\n\talice *lnwallet.LightningWallet, rbf bool) *wire.MsgTx {\n\n\tt.Helper()\n\n\tkeyScript, err := scriptFromKey(pubKey)\n\trequire.NoError(t, err, \"unable to generate script\")\n\n\t// Instruct the wallet to fund the output with a newly created\n\t// transaction.\n\tnewOutput := &wire.TxOut{\n\t\tValue:    btcutil.SatoshiPerBitcoin,\n\t\tPkScript: keyScript,\n\t}\n\ttx, err := alice.SendOutputs(\n\t\t[]*wire.TxOut{newOutput}, 2500, 1, labels.External,\n\t)\n\trequire.NoError(t, err, \"unable to create output\")\n\n\t// Query for the transaction generated above so we can located the\n\t// index of our output.\n\tif err := mineAndAssert(r, tx); err != nil {\n\t\tt.Fatalf(\"unable to mine tx: %v\", err)\n\t}\n\n\t// Create a new unconfirmed tx that spends this output.\n\ttxFee := btcutil.Amount(0.001 * btcutil.SatoshiPerBitcoin)\n\ttx1, err := txFromOutput(\n\t\ttx, alice.Cfg.Signer, pubKey, pubKey, txFee, rbf,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treturn tx1\n}\n\n// testPublishTransaction checks that PublishTransaction returns the expected\n// error types in case the transaction being published conflicts with the\n// current mempool or chain.",
      "length": 1058,
      "tokens": 148,
      "embedding": []
    },
    {
      "slug": "func testPublishTransaction(r *rpctest.Harness,",
      "content": "func testPublishTransaction(r *rpctest.Harness,\n\talice, _ *lnwallet.LightningWallet, t *testing.T) {\n\n\t// Generate a pubkey, and pay-to-addr script.\n\tkeyDesc, err := alice.DeriveNextKey(keychain.KeyFamilyMultiSig)\n\trequire.NoError(t, err, \"unable to obtain public key\")\n\n\t// We will first check that publishing a transaction already in the\n\t// mempool does NOT return an error. Create the tx.\n\ttx1 := newTx(t, r, keyDesc.PubKey, alice, false)\n\n\t// Publish the transaction.\n\terr = alice.PublishTransaction(tx1, labels.External)\n\trequire.NoError(t, err, \"unable to publish\")\n\n\ttxid1 := tx1.TxHash()\n\terr = waitForMempoolTx(r, &txid1)\n\trequire.NoError(t, err, \"tx not relayed to miner\")\n\n\t// Publish the exact same transaction again. This should not return an\n\t// error, even though the transaction is already in the mempool.\n\terr = alice.PublishTransaction(tx1, labels.External)\n\trequire.NoError(t, err, \"unable to publish\")\n\n\t// Mine the transaction.\n\tif _, err := r.Client.Generate(1); err != nil {\n\t\tt.Fatalf(\"unable to generate block: %v\", err)\n\t}\n\n\t// We'll now test that we don't get an error if we try to publish a\n\t// transaction that is already mined.\n\t//\n\t// Create a new transaction. We must do this to properly test the\n\t// reject messages from our peers. They might only send us a reject\n\t// message for a given tx once, so we create a new to make sure it is\n\t// not just immediately rejected.\n\ttx2 := newTx(t, r, keyDesc.PubKey, alice, false)\n\n\t// Publish this tx.\n\terr = alice.PublishTransaction(tx2, labels.External)\n\trequire.NoError(t, err, \"unable to publish\")\n\n\t// Mine the transaction.\n\tif err := mineAndAssert(r, tx2); err != nil {\n\t\tt.Fatalf(\"unable to mine tx: %v\", err)\n\t}\n\n\t// Publish the transaction again. It is already mined, and we don't\n\t// expect this to return an error.\n\terr = alice.PublishTransaction(tx2, labels.External)\n\trequire.NoError(t, err, \"unable to publish\")\n\n\t// We'll do the next mempool check on both RBF and non-RBF enabled\n\t// transactions.\n\tvar (\n\t\ttxFee         = btcutil.Amount(0.005 * btcutil.SatoshiPerBitcoin)\n\t\ttx3, tx3Spend *wire.MsgTx\n\t)\n\n\tfor _, rbf := range []bool{false, true} {\n\t\t// Now we'll try to double spend an output with a different\n\t\t// transaction. Create a new tx and publish it. This is the\n\t\t// output we'll try to double spend.\n\t\ttx3 = newTx(t, r, keyDesc.PubKey, alice, false)\n\t\terr := alice.PublishTransaction(tx3, labels.External)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to publish: %v\", err)\n\t\t}\n\n\t\t// Mine the transaction.\n\t\tif err := mineAndAssert(r, tx3); err != nil {\n\t\t\tt.Fatalf(\"unable to mine tx: %v\", err)\n\t\t}\n\n\t\t// Now we create a transaction that spends the output from the\n\t\t// tx just mined.\n\t\ttx4, err := txFromOutput(\n\t\t\ttx3, alice.Cfg.Signer, keyDesc.PubKey,\n\t\t\tkeyDesc.PubKey, txFee, rbf,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// This should be accepted into the mempool.\n\t\terr = alice.PublishTransaction(tx4, labels.External)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to publish: %v\", err)\n\t\t}\n\n\t\t// Keep track of the last successfully published tx to spend\n\t\t// tx3.\n\t\ttx3Spend = tx4\n\n\t\ttxid4 := tx4.TxHash()\n\t\terr = waitForMempoolTx(r, &txid4)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"tx not relayed to miner: %v\", err)\n\t\t}\n\n\t\t// Create a new key we'll pay to, to ensure we create a unique\n\t\t// transaction.\n\t\tkeyDesc2, err := alice.DeriveNextKey(\n\t\t\tkeychain.KeyFamilyMultiSig,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to obtain public key: %v\", err)\n\t\t}\n\n\t\t// Create a new transaction that spends the output from tx3,\n\t\t// and that pays to a different address. We expect this to be\n\t\t// rejected because it is a double spend.\n\t\ttx5, err := txFromOutput(\n\t\t\ttx3, alice.Cfg.Signer, keyDesc.PubKey,\n\t\t\tkeyDesc2.PubKey, txFee, rbf,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\terr = alice.PublishTransaction(tx5, labels.External)\n\t\tif err != lnwallet.ErrDoubleSpend {\n\t\t\tt.Fatalf(\"expected ErrDoubleSpend, got: %v\", err)\n\t\t}\n\n\t\t// Create another transaction that spends the same output, but\n\t\t// has a higher fee. We expect also this tx to be rejected for\n\t\t// non-RBF enabled transactions, while it should succeed\n\t\t// otherwise.\n\t\tpubKey3, err := alice.DeriveNextKey(keychain.KeyFamilyMultiSig)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to obtain public key: %v\", err)\n\t\t}\n\t\ttx6, err := txFromOutput(\n\t\t\ttx3, alice.Cfg.Signer, keyDesc.PubKey,\n\t\t\tpubKey3.PubKey, 2*txFee, rbf,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// Expect rejection in non-RBF case.\n\t\texpErr := lnwallet.ErrDoubleSpend\n\t\tif rbf {\n\t\t\t// Expect success in rbf case.\n\t\t\texpErr = nil\n\t\t\ttx3Spend = tx6\n\t\t}\n\t\terr = alice.PublishTransaction(tx6, labels.External)\n\t\tif err != expErr {\n\t\t\tt.Fatalf(\"expected ErrDoubleSpend, got: %v\", err)\n\t\t}\n\n\t\t// Mine the tx spending tx3.\n\t\tif err := mineAndAssert(r, tx3Spend); err != nil {\n\t\t\tt.Fatalf(\"unable to mine tx: %v\", err)\n\t\t}\n\t}\n\n\t// At last we try to spend an output already spent by a confirmed\n\t// transaction.\n\t// TODO(halseth): we currently skip this test for neutrino, as the\n\t// backing btcd node will consider the tx being an orphan, and will\n\t// accept it. Should look into if this is the behavior also for\n\t// bitcoind, and update test accordingly.\n\tif alice.BackEnd() != \"neutrino\" {\n\t\t// Create another tx spending tx3.\n\t\tpubKey4, err := alice.DeriveNextKey(\n\t\t\tkeychain.KeyFamilyMultiSig,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to obtain public key: %v\", err)\n\t\t}\n\t\ttx7, err := txFromOutput(\n\t\t\ttx3, alice.Cfg.Signer, keyDesc.PubKey,\n\t\t\tpubKey4.PubKey, txFee, false,\n\t\t)\n\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// Expect rejection.\n\t\terr = alice.PublishTransaction(tx7, labels.External)\n\t\tif err != lnwallet.ErrDoubleSpend {\n\t\t\tt.Fatalf(\"expected ErrDoubleSpend, got: %v\", err)\n\t\t}\n\t}\n}\n",
      "length": 5468,
      "tokens": 830,
      "embedding": []
    },
    {
      "slug": "func testSignOutputUsingTweaks(r *rpctest.Harness,",
      "content": "func testSignOutputUsingTweaks(r *rpctest.Harness,\n\talice, _ *lnwallet.LightningWallet, t *testing.T) {\n\n\t// We'd like to test the ability of the wallet's Signer implementation\n\t// to be able to sign with a private key derived from tweaking the\n\t// specific public key. This scenario exercises the case when the\n\t// wallet needs to sign for a sweep of a revoked output, or just claim\n\t// any output that pays to a tweaked key.\n\n\t// First, generate a new public key under the control of the wallet,\n\t// then generate a revocation key using it.\n\tpubKey, err := alice.DeriveNextKey(\n\t\tkeychain.KeyFamilyMultiSig,\n\t)\n\trequire.NoError(t, err, \"unable to obtain public key\")\n\n\t// As we'd like to test both single tweak, and double tweak spends,\n\t// we'll generate a commitment pre-image, then derive a revocation key\n\t// and single tweak from that.\n\tcommitPreimage := bytes.Repeat([]byte{2}, 32)\n\tcommitSecret, commitPoint := btcec.PrivKeyFromBytes(commitPreimage)\n\n\trevocationKey := input.DeriveRevocationPubkey(pubKey.PubKey, commitPoint)\n\tcommitTweak := input.SingleTweakBytes(commitPoint, pubKey.PubKey)\n\n\ttweakedPub := input.TweakPubKey(pubKey.PubKey, commitPoint)\n\n\t// As we'd like to test both single and double tweaks, we'll repeat\n\t// the same set up twice. The first will use a regular single tweak,\n\t// and the second will use a double tweak.\n\tbaseKey := pubKey\n\tfor i := 0; i < 2; i++ {\n\t\tvar tweakedKey *btcec.PublicKey\n\t\tif i == 0 {\n\t\t\ttweakedKey = tweakedPub\n\t\t} else {\n\t\t\ttweakedKey = revocationKey\n\t\t}\n\n\t\t// Using the given key for the current iteration, we'll\n\t\t// generate a regular p2wkh from that.\n\t\tpubkeyHash := btcutil.Hash160(tweakedKey.SerializeCompressed())\n\t\tkeyAddr, err := btcutil.NewAddressWitnessPubKeyHash(pubkeyHash,\n\t\t\t&chaincfg.RegressionNetParams)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to create addr: %v\", err)\n\t\t}\n\t\tkeyScript, err := txscript.PayToAddrScript(keyAddr)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to generate script: %v\", err)\n\t\t}\n\n\t\t// With the script fully assembled, instruct the wallet to fund\n\t\t// the output with a newly created transaction.\n\t\tnewOutput := &wire.TxOut{\n\t\t\tValue:    btcutil.SatoshiPerBitcoin,\n\t\t\tPkScript: keyScript,\n\t\t}\n\t\ttx, err := alice.SendOutputs(\n\t\t\t[]*wire.TxOut{newOutput}, 2500, 1, labels.External,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to create output: %v\", err)\n\t\t}\n\t\ttxid := tx.TxHash()\n\t\t// Query for the transaction generated above so we can located\n\t\t// the index of our output.\n\t\terr = waitForMempoolTx(r, &txid)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"tx not relayed to miner: %v\", err)\n\t\t}\n\t\tvar outputIndex uint32\n\t\tif bytes.Equal(tx.TxOut[0].PkScript, keyScript) {\n\t\t\toutputIndex = 0\n\t\t} else {\n\t\t\toutputIndex = 1\n\t\t}\n\n\t\t// With the index located, we can create a transaction spending\n\t\t// the referenced output.\n\t\tsweepTx := wire.NewMsgTx(2)\n\t\tsweepTx.AddTxIn(&wire.TxIn{\n\t\t\tPreviousOutPoint: wire.OutPoint{\n\t\t\t\tHash:  txid,\n\t\t\t\tIndex: outputIndex,\n\t\t\t},\n\t\t})\n\t\tsweepTx.AddTxOut(&wire.TxOut{\n\t\t\tValue:    1000,\n\t\t\tPkScript: keyScript,\n\t\t})\n\n\t\t// Now we can populate the sign descriptor which we'll use to\n\t\t// generate the signature. Within the descriptor we set the\n\t\t// private tweak value as the key in the script is derived\n\t\t// based on this tweak value and the key we originally\n\t\t// generated above.\n\t\tsignDesc := &input.SignDescriptor{\n\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\tPubKey: baseKey.PubKey,\n\t\t\t},\n\t\t\tWitnessScript: keyScript,\n\t\t\tOutput:        newOutput,\n\t\t\tHashType:      txscript.SigHashAll,\n\t\t\tSigHashes:     input.NewTxSigHashesV0Only(sweepTx),\n\t\t\tInputIndex:    0,\n\t\t}\n\n\t\t// If this is the first, loop, we'll use the generated single\n\t\t// tweak, otherwise, we'll use the double tweak.\n\t\tif i == 0 {\n\t\t\tsignDesc.SingleTweak = commitTweak\n\t\t} else {\n\t\t\tsignDesc.DoubleTweak = commitSecret\n\t\t}\n\n\t\t// With the descriptor created, we use it to generate a\n\t\t// signature, then manually create a valid witness stack we'll\n\t\t// use for signing.\n\t\tspendSig, err := alice.Cfg.Signer.SignOutputRaw(sweepTx, signDesc)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to generate signature: %v\", err)\n\t\t}\n\t\twitness := make([][]byte, 2)\n\t\twitness[0] = append(spendSig.Serialize(), byte(txscript.SigHashAll))\n\t\twitness[1] = tweakedKey.SerializeCompressed()\n\t\tsweepTx.TxIn[0].Witness = witness\n\n\t\t// Finally, attempt to validate the completed transaction. This\n\t\t// should succeed if the wallet was able to properly generate\n\t\t// the proper private key.\n\t\tvm, err := txscript.NewEngine(\n\t\t\tkeyScript, sweepTx, 0, txscript.StandardVerifyFlags,\n\t\t\tnil, nil, int64(btcutil.SatoshiPerBitcoin),\n\t\t\ttxscript.NewCannedPrevOutputFetcher(\n\t\t\t\tkeyScript, int64(btcutil.SatoshiPerBitcoin),\n\t\t\t),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to create engine: %v\", err)\n\t\t}\n\t\tif err := vm.Execute(); err != nil {\n\t\t\tt.Fatalf(\"spend #%v is invalid: %v\", i, err)\n\t\t}\n\t}\n}\n",
      "length": 4636,
      "tokens": 634,
      "embedding": []
    },
    {
      "slug": "func testReorgWalletBalance(r *rpctest.Harness, w *lnwallet.LightningWallet,",
      "content": "func testReorgWalletBalance(r *rpctest.Harness, w *lnwallet.LightningWallet,\n\t_ *lnwallet.LightningWallet, t *testing.T) {\n\n\t// We first mine a few blocks to ensure any transactions still in the\n\t// mempool confirm, and then get the original balance, before a\n\t// reorganization that doesn't invalidate any existing transactions or\n\t// create any new non-coinbase transactions. We'll then check if it's\n\t// the same after the empty reorg.\n\t_, err := r.Client.Generate(5)\n\trequire.NoError(t, err, \"unable to generate blocks on passed node\")\n\n\t// Give wallet time to catch up.\n\terr = waitForWalletSync(r, w)\n\trequire.NoError(t, err, \"unable to sync wallet\")\n\n\t// Send some money from the miner to the wallet\n\terr = loadTestCredits(r, w, 20, 4)\n\trequire.NoError(t, err, \"unable to send money to lnwallet\")\n\n\t// Send some money from the wallet back to the miner.\n\t// Grab a fresh address from the miner to house this output.\n\tminerAddr, err := r.NewAddress()\n\trequire.NoError(t, err, \"unable to generate address for miner\")\n\tscript, err := txscript.PayToAddrScript(minerAddr)\n\trequire.NoError(t, err, \"unable to create pay to addr script\")\n\toutput := &wire.TxOut{\n\t\tValue:    1e8,\n\t\tPkScript: script,\n\t}\n\ttx, err := w.SendOutputs(\n\t\t[]*wire.TxOut{output}, 2500, 1, labels.External,\n\t)\n\trequire.NoError(t, err, \"unable to send outputs\")\n\ttxid := tx.TxHash()\n\terr = waitForMempoolTx(r, &txid)\n\trequire.NoError(t, err, \"tx not relayed to miner\")\n\t_, err = r.Client.Generate(50)\n\trequire.NoError(t, err, \"unable to generate blocks on passed node\")\n\n\t// Give wallet time to catch up.\n\terr = waitForWalletSync(r, w)\n\trequire.NoError(t, err, \"unable to sync wallet\")\n\n\t// Get the original balance.\n\torigBalance, err := w.ConfirmedBalance(1, lnwallet.DefaultAccountName)\n\trequire.NoError(t, err, \"unable to query for balance\")\n\n\t// Now we cause a reorganization as follows.\n\t// Step 1: create a new miner and start it.\n\tr2, err := rpctest.New(r.ActiveNet, nil, []string{\"--txindex\"}, \"\")\n\trequire.NoError(t, err, \"unable to create mining node\")\n\terr = r2.SetUp(false, 0)\n\trequire.NoError(t, err, \"unable to set up mining node\")\n\tdefer r2.TearDown()\n\tnewBalance, err := w.ConfirmedBalance(1, lnwallet.DefaultAccountName)\n\trequire.NoError(t, err, \"unable to query for balance\")\n\tif origBalance != newBalance {\n\t\tt.Fatalf(\"wallet balance incorrect, should have %v, \"+\n\t\t\t\"instead have %v\", origBalance, newBalance)\n\t}\n\n\t// Step 2: connect the miner to the passed miner and wait for\n\t// synchronization.\n\terr = r2.Client.AddNode(r.P2PAddress(), rpcclient.ANAdd)\n\trequire.NoError(t, err, \"unable to connect mining nodes together\")\n\terr = rpctest.JoinNodes([]*rpctest.Harness{r2, r}, rpctest.Blocks)\n\trequire.NoError(t, err, \"unable to synchronize mining nodes\")\n\n\t// Step 3: Do a set of reorgs by disconnecting the two miners, mining\n\t// one block on the passed miner and two on the created miner,\n\t// connecting them, and waiting for them to sync.\n\tfor i := 0; i < 5; i++ {\n\t\t// Wait for disconnection\n\t\ttimeout := time.After(30 * time.Second)\n\t\tstillConnected := true\n\t\tvar peers []btcjson.GetPeerInfoResult\n\t\tfor stillConnected {\n\t\t\t// Allow for timeout\n\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\tselect {\n\t\t\tcase <-timeout:\n\t\t\t\tt.Fatalf(\"timeout waiting for miner disconnect\")\n\t\t\tdefault:\n\t\t\t}\n\t\t\terr = r2.Client.AddNode(r.P2PAddress(), rpcclient.ANRemove)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to disconnect mining nodes: %v\",\n\t\t\t\t\terr)\n\t\t\t}\n\t\t\tpeers, err = r2.Client.GetPeerInfo()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to get peer info: %v\", err)\n\t\t\t}\n\t\t\tstillConnected = false\n\t\t\tfor _, peer := range peers {\n\t\t\t\tif peer.Addr == r.P2PAddress() {\n\t\t\t\t\tstillConnected = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_, err = r.Client.Generate(2)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to generate blocks on passed node: %v\",\n\t\t\t\terr)\n\t\t}\n\t\t_, err = r2.Client.Generate(3)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to generate blocks on created node: %v\",\n\t\t\t\terr)\n\t\t}\n\n\t\t// Step 5: Reconnect the miners and wait for them to synchronize.\n\t\terr = r2.Client.AddNode(r.P2PAddress(), rpcclient.ANAdd)\n\t\tif err != nil {\n\t\t\tswitch err := err.(type) {\n\t\t\tcase *btcjson.RPCError:\n\t\t\t\tif err.Code != -8 {\n\t\t\t\t\tt.Fatalf(\"unable to connect mining \"+\n\t\t\t\t\t\t\"nodes together: %v\", err)\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tt.Fatalf(\"unable to connect mining nodes \"+\n\t\t\t\t\t\"together: %v\", err)\n\t\t\t}\n\t\t}\n\t\terr = rpctest.JoinNodes([]*rpctest.Harness{r2, r},\n\t\t\trpctest.Blocks)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to synchronize mining nodes: %v\", err)\n\t\t}\n\n\t\t// Give wallet time to catch up.\n\t\terr = waitForWalletSync(r, w)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to sync wallet: %v\", err)\n\t\t}\n\t}\n\n\t// Now we check that the wallet balance stays the same.\n\tnewBalance, err = w.ConfirmedBalance(1, lnwallet.DefaultAccountName)\n\trequire.NoError(t, err, \"unable to query for balance\")\n\tif origBalance != newBalance {\n\t\tt.Fatalf(\"wallet balance incorrect, should have %v, \"+\n\t\t\t\"instead have %v\", origBalance, newBalance)\n\t}\n}\n\n// testChangeOutputSpendConfirmation ensures that when we attempt to spend a\n// change output created by the wallet, the wallet receives its confirmation\n// once included in the chain.",
      "length": 4919,
      "tokens": 700,
      "embedding": []
    },
    {
      "slug": "func testChangeOutputSpendConfirmation(r *rpctest.Harness,",
      "content": "func testChangeOutputSpendConfirmation(r *rpctest.Harness,\n\talice, bob *lnwallet.LightningWallet, t *testing.T) {\n\n\t// In order to test that we see the confirmation of a transaction that\n\t// spends an output created by SendOutputs, we'll start by emptying\n\t// Alice's wallet so that no other UTXOs can be picked. To do so, we'll\n\t// generate an address for Bob, who will receive all the coins.\n\t// Assuming a balance of 80 BTC and a transaction fee of 2500 sat/kw,\n\t// we'll craft the following transaction so that Alice doesn't have any\n\t// UTXOs left.\n\taliceBalance, err := alice.ConfirmedBalance(0, lnwallet.DefaultAccountName)\n\trequire.NoError(t, err, \"unable to retrieve alice's balance\")\n\tbobPkScript := newPkScript(t, bob, lnwallet.WitnessPubKey)\n\n\t// We'll use a transaction fee of 14380 satoshis, which will allow us to\n\t// sweep all of Alice's balance in one transaction containing 1 input\n\t// and 1 output.\n\t//\n\t// TODO(wilmer): replace this once SendOutputs easily supports sending\n\t// all funds in one transaction.\n\ttxFeeRate := chainfee.SatPerKWeight(2500)\n\tconst txFee = int64(14500)\n\toutput := &wire.TxOut{\n\t\tValue:    int64(aliceBalance) - txFee,\n\t\tPkScript: bobPkScript,\n\t}\n\ttx := sendCoins(t, r, alice, bob, output, txFeeRate, true, 1)\n\ttxHash := tx.TxHash()\n\tassertTxInWallet(t, alice, txHash, true)\n\tassertTxInWallet(t, bob, txHash, true)\n\n\t// With the transaction sent and confirmed, Alice's balance should now\n\t// be 0.\n\taliceBalance, err = alice.ConfirmedBalance(0, lnwallet.DefaultAccountName)\n\trequire.NoError(t, err, \"unable to retrieve alice's balance\")\n\tif aliceBalance != 0 {\n\t\tt.Fatalf(\"expected alice's balance to be 0 BTC, found %v\",\n\t\t\taliceBalance)\n\t}\n\n\t// Now, we'll send an output back to Alice from Bob of 1 BTC.\n\talicePkScript := newPkScript(t, alice, lnwallet.WitnessPubKey)\n\toutput = &wire.TxOut{\n\t\tValue:    btcutil.SatoshiPerBitcoin,\n\t\tPkScript: alicePkScript,\n\t}\n\ttx = sendCoins(t, r, bob, alice, output, txFeeRate, true, 1)\n\ttxHash = tx.TxHash()\n\tassertTxInWallet(t, alice, txHash, true)\n\tassertTxInWallet(t, bob, txHash, true)\n\n\t// Alice now has an available output to spend, but it was not a change\n\t// output, which is what the test expects. Therefore, we'll generate one\n\t// by sending Bob back some coins.\n\toutput = &wire.TxOut{\n\t\tValue:    btcutil.SatoshiPerBitcent,\n\t\tPkScript: bobPkScript,\n\t}\n\ttx = sendCoins(t, r, alice, bob, output, txFeeRate, true, 1)\n\ttxHash = tx.TxHash()\n\tassertTxInWallet(t, alice, txHash, true)\n\tassertTxInWallet(t, bob, txHash, true)\n\n\t// Then, we'll spend the change output and ensure we see its\n\t// confirmation come in.\n\ttx = sendCoins(t, r, alice, bob, output, txFeeRate, true, 1)\n\ttxHash = tx.TxHash()\n\tassertTxInWallet(t, alice, txHash, true)\n\tassertTxInWallet(t, bob, txHash, true)\n\n\t// Finally, we'll replenish Alice's wallet with some more coins to\n\t// ensure she has enough for any following test cases.\n\tif err := loadTestCredits(r, alice, 20, 4); err != nil {\n\t\tt.Fatalf(\"unable to replenish alice's wallet: %v\", err)\n\t}\n}\n\n// testSpendUnconfirmed ensures that when can spend unconfirmed outputs.",
      "length": 2951,
      "tokens": 428,
      "embedding": []
    },
    {
      "slug": "func testSpendUnconfirmed(miner *rpctest.Harness,",
      "content": "func testSpendUnconfirmed(miner *rpctest.Harness,\n\talice, bob *lnwallet.LightningWallet, t *testing.T) {\n\n\tbobPkScript := newPkScript(t, bob, lnwallet.WitnessPubKey)\n\talicePkScript := newPkScript(t, alice, lnwallet.WitnessPubKey)\n\ttxFeeRate := chainfee.SatPerKWeight(2500)\n\n\t// First we will empty out bob's wallet, sending the entire balance\n\t// to alice.\n\tbobBalance, err := bob.ConfirmedBalance(0, lnwallet.DefaultAccountName)\n\trequire.NoError(t, err, \"unable to retrieve bob's balance\")\n\ttxFee := btcutil.Amount(28760)\n\toutput := &wire.TxOut{\n\t\tValue:    int64(bobBalance - txFee),\n\t\tPkScript: alicePkScript,\n\t}\n\ttx := sendCoins(t, miner, bob, alice, output, txFeeRate, true, 1)\n\ttxHash := tx.TxHash()\n\tassertTxInWallet(t, alice, txHash, true)\n\tassertTxInWallet(t, bob, txHash, true)\n\n\t// Verify that bob doesn't have enough balance to send coins.\n\toutput = &wire.TxOut{\n\t\tValue:    btcutil.SatoshiPerBitcoin * 0.5,\n\t\tPkScript: alicePkScript,\n\t}\n\t_, err = bob.SendOutputs(\n\t\t[]*wire.TxOut{output}, txFeeRate, 0, labels.External,\n\t)\n\tif err == nil {\n\t\tt.Fatalf(\"should have not been able to pay due to insufficient balance: %v\", err)\n\t}\n\n\t// Next we will send a transaction to bob but leave it in an\n\t// unconfirmed state.\n\toutput = &wire.TxOut{\n\t\tValue:    btcutil.SatoshiPerBitcoin,\n\t\tPkScript: bobPkScript,\n\t}\n\ttx = sendCoins(t, miner, alice, bob, output, txFeeRate, false, 1)\n\ttxHash = tx.TxHash()\n\tassertTxInWallet(t, alice, txHash, false)\n\tassertTxInWallet(t, bob, txHash, false)\n\n\t// Now, try to spend some of the unconfirmed funds from bob's wallet.\n\toutput = &wire.TxOut{\n\t\tValue:    btcutil.SatoshiPerBitcoin * 0.5,\n\t\tPkScript: alicePkScript,\n\t}\n\n\t// First, verify that we don't have enough balance to send the coins\n\t// using confirmed outputs only.\n\t_, err = bob.SendOutputs(\n\t\t[]*wire.TxOut{output}, txFeeRate, 1, labels.External,\n\t)\n\tif err == nil {\n\t\tt.Fatalf(\"should have not been able to pay due to insufficient balance: %v\", err)\n\t}\n\n\t// Now try the send again using unconfirmed outputs.\n\ttx = sendCoins(t, miner, bob, alice, output, txFeeRate, false, 0)\n\ttxHash = tx.TxHash()\n\tassertTxInWallet(t, alice, txHash, false)\n\tassertTxInWallet(t, bob, txHash, false)\n\n\t// Mine the unconfirmed transactions.\n\terr = waitForMempoolTx(miner, &txHash)\n\trequire.NoError(t, err, \"tx not relayed to miner\")\n\tif _, err := miner.Client.Generate(1); err != nil {\n\t\tt.Fatalf(\"unable to generate block: %v\", err)\n\t}\n\tif err := waitForWalletSync(miner, alice); err != nil {\n\t\tt.Fatalf(\"unable to sync alice: %v\", err)\n\t}\n\tif err := waitForWalletSync(miner, bob); err != nil {\n\t\tt.Fatalf(\"unable to sync bob: %v\", err)\n\t}\n\n\t// Finally, send the remainder of bob's wallet balance back to him so\n\t// that these money movements dont mess up later tests.\n\toutput = &wire.TxOut{\n\t\tValue:    int64(bobBalance) - (btcutil.SatoshiPerBitcoin * 0.4),\n\t\tPkScript: bobPkScript,\n\t}\n\ttx = sendCoins(t, miner, alice, bob, output, txFeeRate, true, 1)\n\ttxHash = tx.TxHash()\n\tassertTxInWallet(t, alice, txHash, true)\n\tassertTxInWallet(t, bob, txHash, true)\n}\n\n// testLastUnusedAddr tests that the LastUnusedAddress returns the address if\n// it isn't used, and also that once the address becomes used, then it's\n// properly rotated.",
      "length": 3072,
      "tokens": 422,
      "embedding": []
    },
    {
      "slug": "func testLastUnusedAddr(miner *rpctest.Harness,",
      "content": "func testLastUnusedAddr(miner *rpctest.Harness,\n\talice, bob *lnwallet.LightningWallet, t *testing.T) {\n\n\tif _, err := miner.Client.Generate(1); err != nil {\n\t\tt.Fatalf(\"unable to generate block: %v\", err)\n\t}\n\n\t// We'll repeat this test for each address type to ensure they're all\n\t// rotated properly.\n\taddrTypes := []lnwallet.AddressType{\n\t\tlnwallet.WitnessPubKey, lnwallet.NestedWitnessPubKey,\n\t}\n\tfor _, addrType := range addrTypes {\n\t\taddr1, err := alice.LastUnusedAddress(\n\t\t\taddrType, lnwallet.DefaultAccountName,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to get addr: %v\", err)\n\t\t}\n\t\taddr2, err := alice.LastUnusedAddress(\n\t\t\taddrType, lnwallet.DefaultAccountName,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to get addr: %v\", err)\n\t\t}\n\n\t\t// If we generate two addresses back to back, then we should\n\t\t// get the same addr, as none of them have been used yet.\n\t\tif addr1.String() != addr2.String() {\n\t\t\tt.Fatalf(\"addresses changed w/o use: %v vs %v\", addr1, addr2)\n\t\t}\n\n\t\t// Next, we'll have Bob pay to Alice's new address. This should\n\t\t// trigger address rotation at the backend wallet.\n\t\taddrScript, err := txscript.PayToAddrScript(addr1)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to convert addr to script: %v\", err)\n\t\t}\n\t\tfeeRate := chainfee.SatPerKWeight(2500)\n\t\toutput := &wire.TxOut{\n\t\t\tValue:    1000000,\n\t\t\tPkScript: addrScript,\n\t\t}\n\t\tsendCoins(t, miner, bob, alice, output, feeRate, true, 1)\n\n\t\t// If we make a new address, then it should be brand new, as\n\t\t// the prior address has been used.\n\t\taddr3, err := alice.LastUnusedAddress(\n\t\t\taddrType, lnwallet.DefaultAccountName,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to get addr: %v\", err)\n\t\t}\n\t\tif addr1.String() == addr3.String() {\n\t\t\tt.Fatalf(\"address should have changed but didn't\")\n\t\t}\n\t}\n}\n\n// testCreateSimpleTx checks that a call to CreateSimpleTx will return a\n// transaction that is equal to the one that is being created by SendOutputs in\n// a subsequent call.\n// All test cases are doubled-up: one for testing unconfirmed inputs,\n// one for testing only confirmed inputs.",
      "length": 1938,
      "tokens": 288,
      "embedding": []
    },
    {
      "slug": "func testCreateSimpleTx(r *rpctest.Harness, w *lnwallet.LightningWallet,",
      "content": "func testCreateSimpleTx(r *rpctest.Harness, w *lnwallet.LightningWallet,\n\t_ *lnwallet.LightningWallet, t *testing.T) {\n\n\t// Send some money from the miner to the wallet\n\terr := loadTestCredits(r, w, 20, 4)\n\trequire.NoError(t, err, \"unable to send money to lnwallet\")\n\n\t// The test cases we will run through for all backends.\n\ttestCases := []struct {\n\t\toutVals     []int64\n\t\tfeeRate     chainfee.SatPerKWeight\n\t\tvalid       bool\n\t\tunconfirmed bool\n\t}{\n\t\t{\n\t\t\toutVals:     []int64{},\n\t\t\tfeeRate:     2500,\n\t\t\tvalid:       false, // No outputs.\n\t\t\tunconfirmed: false,\n\t\t},\n\t\t{\n\t\t\toutVals:     []int64{},\n\t\t\tfeeRate:     2500,\n\t\t\tvalid:       false, // No outputs.\n\t\t\tunconfirmed: true,\n\t\t},\n\n\t\t{\n\t\t\toutVals:     []int64{200},\n\t\t\tfeeRate:     2500,\n\t\t\tvalid:       false, // Dust output.\n\t\t\tunconfirmed: false,\n\t\t},\n\t\t{\n\t\t\toutVals:     []int64{200},\n\t\t\tfeeRate:     2500,\n\t\t\tvalid:       false, // Dust output.\n\t\t\tunconfirmed: true,\n\t\t},\n\n\t\t{\n\t\t\toutVals:     []int64{1e8},\n\t\t\tfeeRate:     2500,\n\t\t\tvalid:       true,\n\t\t\tunconfirmed: false,\n\t\t},\n\t\t{\n\t\t\toutVals:     []int64{1e8},\n\t\t\tfeeRate:     2500,\n\t\t\tvalid:       true,\n\t\t\tunconfirmed: true,\n\t\t},\n\n\t\t{\n\t\t\toutVals:     []int64{1e8, 2e8, 1e8, 2e7, 3e5},\n\t\t\tfeeRate:     2500,\n\t\t\tvalid:       true,\n\t\t\tunconfirmed: false,\n\t\t},\n\t\t{\n\t\t\toutVals:     []int64{1e8, 2e8, 1e8, 2e7, 3e5},\n\t\t\tfeeRate:     2500,\n\t\t\tvalid:       true,\n\t\t\tunconfirmed: true,\n\t\t},\n\n\t\t{\n\t\t\toutVals:     []int64{1e8, 2e8, 1e8, 2e7, 3e5},\n\t\t\tfeeRate:     12500,\n\t\t\tvalid:       true,\n\t\t\tunconfirmed: false,\n\t\t},\n\t\t{\n\t\t\toutVals:     []int64{1e8, 2e8, 1e8, 2e7, 3e5},\n\t\t\tfeeRate:     12500,\n\t\t\tvalid:       true,\n\t\t\tunconfirmed: true,\n\t\t},\n\n\t\t{\n\t\t\toutVals:     []int64{1e8, 2e8, 1e8, 2e7, 3e5},\n\t\t\tfeeRate:     50000,\n\t\t\tvalid:       true,\n\t\t\tunconfirmed: false,\n\t\t},\n\t\t{\n\t\t\toutVals:     []int64{1e8, 2e8, 1e8, 2e7, 3e5},\n\t\t\tfeeRate:     50000,\n\t\t\tvalid:       true,\n\t\t\tunconfirmed: true,\n\t\t},\n\n\t\t{\n\t\t\toutVals: []int64{1e8, 2e8, 1e8, 2e7, 3e5, 1e8, 2e8,\n\t\t\t\t1e8, 2e7, 3e5},\n\t\t\tfeeRate:     44250,\n\t\t\tvalid:       true,\n\t\t\tunconfirmed: false,\n\t\t},\n\t\t{\n\t\t\toutVals: []int64{1e8, 2e8, 1e8, 2e7, 3e5, 1e8, 2e8,\n\t\t\t\t1e8, 2e7, 3e5},\n\t\t\tfeeRate:     44250,\n\t\t\tvalid:       true,\n\t\t\tunconfirmed: true,\n\t\t},\n\t}\n\n\tfor i, test := range testCases {\n\t\tvar minConfs int32 = 1\n\n\t\tfeeRate := test.feeRate\n\n\t\t// Grab some fresh addresses from the miner that we will send\n\t\t// to.\n\t\toutputs := make([]*wire.TxOut, len(test.outVals))\n\t\tfor i, outVal := range test.outVals {\n\t\t\tminerAddr, err := r.NewAddress()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to generate address for \"+\n\t\t\t\t\t\"miner: %v\", err)\n\t\t\t}\n\t\t\tscript, err := txscript.PayToAddrScript(minerAddr)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to create pay to addr \"+\n\t\t\t\t\t\"script: %v\", err)\n\t\t\t}\n\t\t\toutput := &wire.TxOut{\n\t\t\t\tValue:    outVal,\n\t\t\t\tPkScript: script,\n\t\t\t}\n\n\t\t\toutputs[i] = output\n\t\t}\n\n\t\t// Now try creating a tx spending to these outputs.\n\t\tcreateTx, createErr := w.CreateSimpleTx(\n\t\t\toutputs, feeRate, minConfs, true,\n\t\t)\n\t\tswitch {\n\t\tcase test.valid && createErr != nil:\n\t\t\tfmt.Println(spew.Sdump(createTx.Tx))\n\t\t\tt.Fatalf(\"got unexpected error when creating tx: %v\",\n\t\t\t\tcreateErr)\n\n\t\tcase !test.valid && createErr == nil:\n\t\t\tt.Fatalf(\"test #%v should have failed on tx \"+\n\t\t\t\t\"creation\", i)\n\t\t}\n\n\t\t// Also send to these outputs. This should result in a tx\n\t\t// _very_ similar to the one we just created being sent. The\n\t\t// only difference is that the dry run tx is not signed, and\n\t\t// that the change output position might be different.\n\t\ttx, sendErr := w.SendOutputs(\n\t\t\toutputs, feeRate, minConfs, labels.External,\n\t\t)\n\t\tswitch {\n\t\tcase test.valid && sendErr != nil:\n\t\t\tt.Fatalf(\"got unexpected error when sending tx: %v\",\n\t\t\t\tsendErr)\n\n\t\tcase !test.valid && sendErr == nil:\n\t\t\tt.Fatalf(\"test #%v should fail for tx sending\", i)\n\t\t}\n\n\t\t// We expected either both to not fail, or both to fail with\n\t\t// the same error.\n\t\tif createErr != sendErr {\n\t\t\tt.Fatalf(\"error creating tx (%v) different \"+\n\t\t\t\t\"from error sending outputs (%v)\",\n\t\t\t\tcreateErr, sendErr)\n\t\t}\n\n\t\t// If we expected the creation to fail, then this test is over.\n\t\tif !test.valid {\n\t\t\tcontinue\n\t\t}\n\n\t\ttxid := tx.TxHash()\n\t\terr = waitForMempoolTx(r, &txid)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"tx not relayed to miner: %v\", err)\n\t\t}\n\n\t\t// Helper method to check that the two txs are similar.\n\t\tassertSimilarTx := func(a, b *wire.MsgTx) error {\n\t\t\tif a.Version != b.Version {\n\t\t\t\treturn fmt.Errorf(\"different versions: \"+\n\t\t\t\t\t\"%v vs %v\", a.Version, b.Version)\n\t\t\t}\n\t\t\tif a.LockTime != b.LockTime {\n\t\t\t\treturn fmt.Errorf(\"different locktimes: \"+\n\t\t\t\t\t\"%v vs %v\", a.LockTime, b.LockTime)\n\t\t\t}\n\t\t\tif len(a.TxIn) != len(b.TxIn) {\n\t\t\t\treturn fmt.Errorf(\"different number of \"+\n\t\t\t\t\t\"inputs: %v vs %v\", len(a.TxIn),\n\t\t\t\t\tlen(b.TxIn))\n\t\t\t}\n\t\t\tif len(a.TxOut) != len(b.TxOut) {\n\t\t\t\treturn fmt.Errorf(\"different number of \"+\n\t\t\t\t\t\"outputs: %v vs %v\", len(a.TxOut),\n\t\t\t\t\tlen(b.TxOut))\n\t\t\t}\n\n\t\t\t// They should be spending the same inputs.\n\t\t\tfor i := range a.TxIn {\n\t\t\t\tprevA := a.TxIn[i].PreviousOutPoint\n\t\t\t\tprevB := b.TxIn[i].PreviousOutPoint\n\t\t\t\tif prevA != prevB {\n\t\t\t\t\treturn fmt.Errorf(\"different inputs: \"+\n\t\t\t\t\t\t\"%v vs %v\", spew.Sdump(prevA),\n\t\t\t\t\t\tspew.Sdump(prevB))\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// They should have the same outputs. Since the change\n\t\t\t// output position gets randomized, they are not\n\t\t\t// guaranteed to be in the same order.\n\t\t\tfor _, outA := range a.TxOut {\n\t\t\t\tfound := false\n\t\t\t\tfor _, outB := range b.TxOut {\n\t\t\t\t\tif reflect.DeepEqual(outA, outB) {\n\t\t\t\t\t\tfound = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif !found {\n\t\t\t\t\treturn fmt.Errorf(\"did not find \"+\n\t\t\t\t\t\t\"output %v\", spew.Sdump(outA))\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\t// Assert that our \"template tx\" was similar to the one that\n\t\t// ended up being sent.\n\t\tif err := assertSimilarTx(createTx.Tx, tx); err != nil {\n\t\t\tt.Fatalf(\"transactions not similar: %v\", err)\n\t\t}\n\n\t\t// Now that we know both transactions were essentially\n\t\t// identical, we'll make sure that a P2TR addr was used as the\n\t\t// change output, which is the current default.\n\t\tchangeTxOut := createTx.Tx.TxOut[createTx.ChangeIndex]\n\t\tchangeScriptType, _, _, err := txscript.ExtractPkScriptAddrs(\n\t\t\tchangeTxOut.PkScript, &w.Cfg.NetParams,\n\t\t)\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, changeScriptType, txscript.WitnessV1TaprootTy)\n\t}\n}\n\n// testSignOutputCreateAccount tests that we're able to properly sign for an\n// output if the target account hasn't yet been created on disk. In this case,\n// we'll create the account, then sign.",
      "length": 6163,
      "tokens": 853,
      "embedding": []
    },
    {
      "slug": "func testSignOutputCreateAccount(r *rpctest.Harness, w *lnwallet.LightningWallet,",
      "content": "func testSignOutputCreateAccount(r *rpctest.Harness, w *lnwallet.LightningWallet,\n\t_ *lnwallet.LightningWallet, t *testing.T) {\n\n\t// First, we'll create a sign desc that references a non-default key\n\t// family. Under the hood, key families are actually accounts, so this\n\t// should force create of the account so we can sign with it.\n\tfakeTx := wire.NewMsgTx(2)\n\tfakeTx.AddTxIn(&wire.TxIn{\n\t\tPreviousOutPoint: wire.OutPoint{\n\t\t\tHash:  chainhash.Hash{},\n\t\t\tIndex: 0,\n\t\t},\n\t})\n\tsignDesc := &input.SignDescriptor{\n\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\tKeyLocator: keychain.KeyLocator{\n\t\t\t\tFamily: 99,\n\t\t\t\tIndex:  1,\n\t\t\t},\n\t\t},\n\t\tWitnessScript: []byte{},\n\t\tOutput: &wire.TxOut{\n\t\t\tValue: 1000,\n\t\t},\n\t\tHashType:   txscript.SigHashAll,\n\t\tSigHashes:  input.NewTxSigHashesV0Only(fakeTx),\n\t\tInputIndex: 0,\n\t}\n\n\t// We'll now sign and expect this to succeed, as even though the\n\t// account doesn't exist atm, it should be created in order to process\n\t// the inbound signing request.\n\t_, err := w.Cfg.Signer.SignOutputRaw(fakeTx, signDesc)\n\tif err != nil {\n\t\tt.Fatalf(\"unable to sign for output with non-existent \"+\n\t\t\t\"account: %v\", err)\n\t}\n}\n",
      "length": 1013,
      "tokens": 135,
      "embedding": []
    },
    {
      "slug": "type walletTestCase struct {",
      "content": "type walletTestCase struct {\n\tname string\n\ttest func(miner *rpctest.Harness, alice, bob *lnwallet.LightningWallet,\n\t\ttest *testing.T)\n}\n\nvar walletTests = []walletTestCase{\n\t{\n\t\t// TODO(wilmer): this test should remain first until the wallet\n\t\t// can properly craft a transaction that spends all of its\n\t\t// on-chain funds.\n\t\tname: \"change output spend confirmation\",\n\t\ttest: testChangeOutputSpendConfirmation,\n\t},\n\t{\n\t\t// TODO(guggero): this test should remain second until dual\n\t\t// funding can properly exchange full UTXO information and we\n\t\t// can use P2TR change outputs as the funding inputs for a dual\n\t\t// funded channel.\n\t\tname: \"dual funder workflow\",\n\t\ttest: testDualFundingReservationWorkflow,\n\t},\n\t{\n\t\tname: \"spend unconfirmed outputs\",\n\t\ttest: testSpendUnconfirmed,\n\t},\n\t{\n\t\tname: \"insane fee reject\",\n\t\ttest: testReservationInitiatorBalanceBelowDustCancel,\n\t},\n\t{\n\t\tname: \"single funding workflow\",\n\t\ttest: func(miner *rpctest.Harness, alice,\n\t\t\tbob *lnwallet.LightningWallet, t *testing.T) {\n\n\t\t\ttestSingleFunderReservationWorkflow(\n\t\t\t\tminer, alice, bob, t,\n\t\t\t\tlnwallet.CommitmentTypeLegacy, nil,\n\t\t\t\tnil, [32]byte{}, 0,\n\t\t\t)\n\t\t},\n\t},\n\t{\n\t\tname: \"single funding workflow tweakless\",\n\t\ttest: func(miner *rpctest.Harness, alice,\n\t\t\tbob *lnwallet.LightningWallet, t *testing.T) {\n\n\t\t\ttestSingleFunderReservationWorkflow(\n\t\t\t\tminer, alice, bob, t,\n\t\t\t\tlnwallet.CommitmentTypeTweakless, nil,\n\t\t\t\tnil, [32]byte{}, 0,\n\t\t\t)\n\t\t},\n\t},\n\t{\n\t\tname: \"single funding workflow external funding tx\",\n\t\ttest: testSingleFunderExternalFundingTx,\n\t},\n\t{\n\t\tname: \"output locking\",\n\t\ttest: testFundingTransactionLockedOutputs,\n\t},\n\t{\n\t\tname: \"reservation insufficient funds\",\n\t\ttest: testFundingCancellationNotEnoughFunds,\n\t},\n\t{\n\t\tname: \"transaction subscriptions\",\n\t\ttest: testTransactionSubscriptions,\n\t},\n\t{\n\t\tname: \"transaction details\",\n\t\ttest: testListTransactionDetails,\n\t},\n\t{\n\t\tname: \"publish transaction\",\n\t\ttest: testPublishTransaction,\n\t},\n\t{\n\t\tname: \"signed with tweaked pubkeys\",\n\t\ttest: testSignOutputUsingTweaks,\n\t},\n\t{\n\t\tname: \"test cancel non-existent reservation\",\n\t\ttest: testCancelNonExistentReservation,\n\t},\n\t{\n\t\tname: \"last unused addr\",\n\t\ttest: testLastUnusedAddr,\n\t},\n\t{\n\t\tname: \"reorg wallet balance\",\n\t\ttest: testReorgWalletBalance,\n\t},\n\t{\n\t\tname: \"create simple tx\",\n\t\ttest: testCreateSimpleTx,\n\t},\n\t{\n\t\tname: \"test sign create account\",\n\t\ttest: testSignOutputCreateAccount,\n\t},\n\t{\n\t\tname: \"test get recovery info\",\n\t\ttest: testGetRecoveryInfo,\n\t},\n}\n",
      "length": 2341,
      "tokens": 270,
      "embedding": []
    },
    {
      "slug": "func clearWalletStates(a, b *lnwallet.LightningWallet) error {",
      "content": "func clearWalletStates(a, b *lnwallet.LightningWallet) error {\n\ta.ResetReservations()\n\tb.ResetReservations()\n\n\tif err := a.Cfg.Database.GetParentDB().Wipe(); err != nil {\n\t\treturn err\n\t}\n\n\treturn b.Cfg.Database.GetParentDB().Wipe()\n}\n",
      "length": 162,
      "tokens": 16,
      "embedding": []
    },
    {
      "slug": "func waitForMempoolTx(r *rpctest.Harness, txid *chainhash.Hash) error {",
      "content": "func waitForMempoolTx(r *rpctest.Harness, txid *chainhash.Hash) error {\n\tvar found bool\n\tvar tx *btcutil.Tx\n\tvar err error\n\ttimeout := time.After(30 * time.Second)\n\tfor !found {\n\t\t// Do a short wait\n\t\tselect {\n\t\tcase <-timeout:\n\t\t\treturn fmt.Errorf(\"timeout after 10s\")\n\t\tdefault:\n\t\t}\n\t\ttime.Sleep(100 * time.Millisecond)\n\n\t\t// Check for the harness' knowledge of the txid\n\t\ttx, err = r.Client.GetRawTransaction(txid)\n\t\tif err != nil {\n\t\t\tswitch e := err.(type) {\n\t\t\tcase *btcjson.RPCError:\n\t\t\t\tif e.Code == btcjson.ErrRPCNoTxInfo {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tif tx != nil && tx.MsgTx().TxHash() == *txid {\n\t\t\tfound = true\n\t\t}\n\t}\n\treturn nil\n}\n",
      "length": 571,
      "tokens": 89,
      "embedding": []
    },
    {
      "slug": "func waitForWalletSync(r *rpctest.Harness, w *lnwallet.LightningWallet) error {",
      "content": "func waitForWalletSync(r *rpctest.Harness, w *lnwallet.LightningWallet) error {\n\tvar (\n\t\tsynced                  bool\n\t\terr                     error\n\t\tbestHash, knownHash     *chainhash.Hash\n\t\tbestHeight, knownHeight int32\n\t)\n\ttimeout := time.After(10 * time.Second)\n\tfor !synced {\n\t\t// Do a short wait\n\t\tselect {\n\t\tcase <-timeout:\n\t\t\treturn fmt.Errorf(\"timeout after 30s\")\n\t\tcase <-time.Tick(100 * time.Millisecond):\n\t\t}\n\n\t\t// Check whether the chain source of the wallet is caught up to\n\t\t// the harness it's supposed to be catching up to.\n\t\tbestHash, bestHeight, err = r.Client.GetBestBlock()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tknownHash, knownHeight, err = w.Cfg.ChainIO.GetBestBlock()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif knownHeight != bestHeight {\n\t\t\tcontinue\n\t\t}\n\t\tif *knownHash != *bestHash {\n\t\t\treturn fmt.Errorf(\"hash at height %d doesn't match: \"+\n\t\t\t\t\"expected %s, got %s\", bestHeight, bestHash,\n\t\t\t\tknownHash)\n\t\t}\n\n\t\t// Check for synchronization.\n\t\tsynced, _, err = w.IsSynced()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// testSingleFunderExternalFundingTx tests that the wallet is able to properly\n// carry out a funding flow backed by a channel point that has been crafted\n// outside the wallet.",
      "length": 1107,
      "tokens": 166,
      "embedding": []
    },
    {
      "slug": "func testSingleFunderExternalFundingTx(miner *rpctest.Harness,",
      "content": "func testSingleFunderExternalFundingTx(miner *rpctest.Harness,\n\talice, bob *lnwallet.LightningWallet, t *testing.T) {\n\n\t// First, we'll obtain multi-sig keys from both Alice and Bob which\n\t// simulates them exchanging keys on a higher level.\n\taliceFundingKey, err := alice.DeriveNextKey(keychain.KeyFamilyMultiSig)\n\trequire.NoError(t, err, \"unable to obtain alice funding key\")\n\tbobFundingKey, err := bob.DeriveNextKey(keychain.KeyFamilyMultiSig)\n\trequire.NoError(t, err, \"unable to obtain bob funding key\")\n\n\t// We'll now set up for them to open a 4 BTC channel, with 1 BTC pushed\n\t// to Bob's side.\n\tchanAmt := 4 * btcutil.SatoshiPerBitcoin\n\n\t// Simulating external funding negotiation, we'll now create the\n\t// funding transaction for both parties. Utilizing existing tools,\n\t// we'll create a new chanfunding.Assembler hacked by Alice's wallet.\n\taliceChanFunder := chanfunding.NewWalletAssembler(chanfunding.WalletConfig{\n\t\tCoinSource:       lnwallet.NewCoinSource(alice),\n\t\tCoinSelectLocker: alice,\n\t\tCoinLocker:       alice,\n\t\tSigner:           alice.Cfg.Signer,\n\t\tDustLimit:        600,\n\t})\n\n\t// With the chan funder created, we'll now provision a funding intent,\n\t// bind the keys we obtained above, and finally obtain our funding\n\t// transaction and outpoint.\n\tfundingIntent, err := aliceChanFunder.ProvisionChannel(&chanfunding.Request{\n\t\tLocalAmt: btcutil.Amount(chanAmt),\n\t\tMinConfs: 1,\n\t\tFeeRate:  253,\n\t\tChangeAddr: func() (btcutil.Address, error) {\n\t\t\treturn alice.NewAddress(\n\t\t\t\tlnwallet.WitnessPubKey, true,\n\t\t\t\tlnwallet.DefaultAccountName,\n\t\t\t)\n\t\t},\n\t})\n\trequire.NoError(t, err, \"unable to perform coin selection\")\n\n\t// With our intent created, we'll instruct it to finalize the funding\n\t// transaction, and also hand us the outpoint so we can simulate\n\t// external crafting of the funding transaction.\n\tvar (\n\t\tfundingTx *wire.MsgTx\n\t\tchanPoint *wire.OutPoint\n\t)\n\tif fullIntent, ok := fundingIntent.(*chanfunding.FullIntent); ok {\n\t\tfullIntent.BindKeys(&aliceFundingKey, bobFundingKey.PubKey)\n\n\t\tfundingTx, err = fullIntent.CompileFundingTx(nil, nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to compile funding tx: %v\", err)\n\t\t}\n\t\tchanPoint, err = fullIntent.ChanPoint()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to obtain chan point: %v\", err)\n\t\t}\n\t} else {\n\t\tt.Fatalf(\"expected full intent, instead got: %T\", fullIntent)\n\t}\n\n\t// Now that we have the fully constructed funding transaction, we'll\n\t// create a new shim external funder out of it for Alice, and prep a\n\t// shim intent for Bob.\n\tthawHeight := uint32(200)\n\taliceExternalFunder := chanfunding.NewCannedAssembler(\n\t\tthawHeight, *chanPoint, btcutil.Amount(chanAmt), &aliceFundingKey,\n\t\tbobFundingKey.PubKey, true,\n\t)\n\tbobShimIntent, err := chanfunding.NewCannedAssembler(\n\t\tthawHeight, *chanPoint, btcutil.Amount(chanAmt), &bobFundingKey,\n\t\taliceFundingKey.PubKey, false,\n\t).ProvisionChannel(&chanfunding.Request{\n\t\tLocalAmt: btcutil.Amount(chanAmt),\n\t\tMinConfs: 1,\n\t\tFeeRate:  253,\n\t\tChangeAddr: func() (btcutil.Address, error) {\n\t\t\treturn bob.NewAddress(\n\t\t\t\tlnwallet.WitnessPubKey, true,\n\t\t\t\tlnwallet.DefaultAccountName,\n\t\t\t)\n\t\t},\n\t})\n\trequire.NoError(t, err, \"unable to create shim intent for bob\")\n\n\t// At this point, we have everything we need to carry out our test, so\n\t// we'll being the funding flow between Alice and Bob.\n\t//\n\t// However, before we do so, we'll register a new shim intent for Bob,\n\t// so he knows what keys to use when he receives the funding request\n\t// from Alice.\n\tpendingChanID := testHdSeed\n\terr = bob.RegisterFundingIntent(pendingChanID, bobShimIntent)\n\trequire.NoError(t, err, \"unable to register intent\")\n\n\t// Now we can carry out the single funding flow as normal, we'll\n\t// specify our external funder and funding transaction, as well as the\n\t// pending channel ID generated above to allow Alice and Bob to track\n\t// the funding flow externally.\n\ttestSingleFunderReservationWorkflow(\n\t\tminer, alice, bob, t, lnwallet.CommitmentTypeTweakless,\n\t\taliceExternalFunder, func() *wire.MsgTx {\n\t\t\treturn fundingTx\n\t\t}, pendingChanID, thawHeight,\n\t)\n}\n\n// TestInterfaces tests all registered interfaces with a unified set of tests\n// which exercise each of the required methods found within the WalletController\n// interface.\n//\n// NOTE: In the future, when additional implementations of the WalletController\n// interface have been implemented, in order to ensure the new concrete\n// implementation is automatically tested, two steps must be undertaken. First,\n// one needs add a \"non-captured\" (_) import from the new sub-package. This\n// import should trigger an init() method within the package which registers\n// the interface. Second, an additional case in the switch within the main loop\n// below needs to be added which properly initializes the interface.\n//\n// TODO(roasbeef): purge bobNode in favor of dual lnwallet's",
      "length": 4644,
      "tokens": 604,
      "embedding": []
    },
    {
      "slug": "func TestLightningWallet(t *testing.T, targetBackEnd string) {",
      "content": "func TestLightningWallet(t *testing.T, targetBackEnd string) {\n\tt.Parallel()\n\n\t// Initialize the harness around a btcd node which will serve as our\n\t// dedicated miner to generate blocks, cause re-orgs, etc. We'll set\n\t// up this node with a chain length of 125, so we have plenty of BTC\n\t// to play around with.\n\tminingNode, err := rpctest.New(\n\t\tnetParams, nil, []string{\"--txindex\"}, \"\",\n\t)\n\trequire.NoError(t, err, \"unable to create mining node\")\n\tdefer miningNode.TearDown()\n\tif err := miningNode.SetUp(true, 25); err != nil {\n\t\tt.Fatalf(\"unable to set up mining node: %v\", err)\n\t}\n\n\t// Next mine enough blocks in order for segwit and the CSV package\n\t// soft-fork to activate on RegNet.\n\tnumBlocks := netParams.MinerConfirmationWindow * 2\n\tif _, err := miningNode.Client.Generate(numBlocks); err != nil {\n\t\tt.Fatalf(\"unable to generate blocks: %v\", err)\n\t}\n\n\trpcConfig := miningNode.RPCConfig()\n\n\ttempDir := t.TempDir()\n\tdb, err := channeldb.Open(tempDir)\n\trequire.NoError(t, err, \"unable to create db\")\n\ttestCfg := channeldb.CacheConfig{\n\t\tQueryDisable: false,\n\t}\n\thintCache, err := channeldb.NewHeightHintCache(testCfg, db.Backend)\n\trequire.NoError(t, err, \"unable to create height hint cache\")\n\tblockCache := blockcache.NewBlockCache(10000)\n\tchainNotifier, err := btcdnotify.New(\n\t\t&rpcConfig, netParams, hintCache, hintCache, blockCache,\n\t)\n\trequire.NoError(t, err, \"unable to create notifier\")\n\tif err := chainNotifier.Start(); err != nil {\n\t\tt.Fatalf(\"unable to start notifier: %v\", err)\n\t}\n\n\tfor _, walletDriver := range lnwallet.RegisteredWallets() {\n\t\tfor _, backEnd := range walletDriver.BackEnds() {\n\t\t\tif backEnd != targetBackEnd {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif !runTests(t, walletDriver, backEnd, miningNode,\n\t\t\t\trpcConfig, chainNotifier) {\n\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\n// runTests runs all of the tests for a single interface implementation and\n// chain back-end combination. This makes it easier to use `defer` as well as\n// factoring out the test logic from the loop which cycles through the\n// interface implementations.",
      "length": 1914,
      "tokens": 268,
      "embedding": []
    },
    {
      "slug": "func runTests(t *testing.T, walletDriver *lnwallet.WalletDriver,",
      "content": "func runTests(t *testing.T, walletDriver *lnwallet.WalletDriver,\n\tbackEnd string, miningNode *rpctest.Harness,\n\trpcConfig rpcclient.ConnConfig,\n\tchainNotifier chainntnfs.ChainNotifier) bool {\n\n\tvar (\n\t\tbio lnwallet.BlockChainIO\n\n\t\taliceSigner input.Signer\n\t\tbobSigner   input.Signer\n\n\t\taliceKeyRing keychain.SecretKeyRing\n\t\tbobKeyRing   keychain.SecretKeyRing\n\n\t\taliceWalletController lnwallet.WalletController\n\t\tbobWalletController   lnwallet.WalletController\n\n\t\terr error\n\t)\n\n\ttempTestDirAlice := t.TempDir()\n\ttempTestDirBob := t.TempDir()\n\n\tblockCache := blockcache.NewBlockCache(10000)\n\n\twalletType := walletDriver.WalletType\n\tswitch walletType {\n\tcase \"btcwallet\":\n\t\tvar aliceClient, bobClient chain.Interface\n\t\tswitch backEnd {\n\t\tcase \"btcd\":\n\t\t\taliceClient, err = chain.NewRPCClient(netParams,\n\t\t\t\trpcConfig.Host, rpcConfig.User, rpcConfig.Pass,\n\t\t\t\trpcConfig.Certificates, false, 20)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to make chain rpc: %v\", err)\n\t\t\t}\n\t\t\tbobClient, err = chain.NewRPCClient(netParams,\n\t\t\t\trpcConfig.Host, rpcConfig.User, rpcConfig.Pass,\n\t\t\t\trpcConfig.Certificates, false, 20)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to make chain rpc: %v\", err)\n\t\t\t}\n\n\t\tcase \"neutrino\":\n\t\t\t// Set some package-level variable to speed up\n\t\t\t// operation for tests.\n\t\t\tneutrino.BanDuration = time.Millisecond * 100\n\t\t\tneutrino.QueryTimeout = time.Millisecond * 500\n\t\t\tneutrino.QueryNumRetries = 1\n\n\t\t\t// Start Alice - open a database, start a neutrino\n\t\t\t// instance, and initialize a btcwallet driver for it.\n\t\t\taliceDB, err := walletdb.Create(\n\t\t\t\t\"bdb\", tempTestDirAlice+\"/neutrino.db\", true,\n\t\t\t\tkvdb.DefaultDBTimeout,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to create DB: %v\", err)\n\t\t\t}\n\t\t\tdefer aliceDB.Close()\n\t\t\taliceChain, err := neutrino.NewChainService(\n\t\t\t\tneutrino.Config{\n\t\t\t\t\tDataDir:     tempTestDirAlice,\n\t\t\t\t\tDatabase:    aliceDB,\n\t\t\t\t\tChainParams: *netParams,\n\t\t\t\t\tConnectPeers: []string{\n\t\t\t\t\t\tminingNode.P2PAddress(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to make neutrino: %v\", err)\n\t\t\t}\n\t\t\taliceChain.Start()\n\t\t\tdefer aliceChain.Stop()\n\t\t\taliceClient = chain.NewNeutrinoClient(\n\t\t\t\tnetParams, aliceChain,\n\t\t\t)\n\n\t\t\t// Start Bob - open a database, start a neutrino\n\t\t\t// instance, and initialize a btcwallet driver for it.\n\t\t\tbobDB, err := walletdb.Create(\n\t\t\t\t\"bdb\", tempTestDirBob+\"/neutrino.db\", true,\n\t\t\t\tkvdb.DefaultDBTimeout,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to create DB: %v\", err)\n\t\t\t}\n\t\t\tdefer bobDB.Close()\n\t\t\tbobChain, err := neutrino.NewChainService(\n\t\t\t\tneutrino.Config{\n\t\t\t\t\tDataDir:     tempTestDirBob,\n\t\t\t\t\tDatabase:    bobDB,\n\t\t\t\t\tChainParams: *netParams,\n\t\t\t\t\tConnectPeers: []string{\n\t\t\t\t\t\tminingNode.P2PAddress(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to make neutrino: %v\", err)\n\t\t\t}\n\t\t\tbobChain.Start()\n\t\t\tdefer bobChain.Stop()\n\t\t\tbobClient = chain.NewNeutrinoClient(\n\t\t\t\tnetParams, bobChain,\n\t\t\t)\n\n\t\tcase \"bitcoind\":\n\t\t\t// Start a bitcoind instance.\n\t\t\ttempBitcoindDir := t.TempDir()\n\t\t\tzmqBlockHost := \"ipc:///\" + tempBitcoindDir + \"/blocks.socket\"\n\t\t\tzmqTxHost := \"ipc:///\" + tempBitcoindDir + \"/tx.socket\"\n\t\t\trpcPort := getFreePort()\n\t\t\tbitcoind := exec.Command(\n\t\t\t\t\"bitcoind\",\n\t\t\t\t\"-datadir=\"+tempBitcoindDir,\n\t\t\t\t\"-regtest\",\n\t\t\t\t\"-connect=\"+miningNode.P2PAddress(),\n\t\t\t\t\"-txindex\",\n\t\t\t\t\"-rpcauth=weks:469e9bb14ab2360f8e226efed5ca6f\"+\n\t\t\t\t\t\"d$507c670e800a95284294edb5773b05544b\"+\n\t\t\t\t\t\"220110063096c221be9933c82d38e1\",\n\t\t\t\tfmt.Sprintf(\"-rpcport=%d\", rpcPort),\n\t\t\t\t\"-disablewallet\",\n\t\t\t\t\"-zmqpubrawblock=\"+zmqBlockHost,\n\t\t\t\t\"-zmqpubrawtx=\"+zmqTxHost,\n\t\t\t)\n\t\t\terr = bitcoind.Start()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"couldn't start bitcoind: %v\", err)\n\t\t\t}\n\n\t\t\t// Sanity check to ensure that the process did in fact\n\t\t\t// start.\n\t\t\tif bitcoind.Process == nil {\n\t\t\t\tt.Fatalf(\"bitcoind cmd Process is not set \" +\n\t\t\t\t\t\"after Start\")\n\t\t\t}\n\n\t\t\tdefer func() {\n\t\t\t\t_ = bitcoind.Process.Kill()\n\t\t\t\t_ = bitcoind.Wait()\n\t\t\t}()\n\n\t\t\t// Wait for the bitcoind instance to start up.\n\n\t\t\thost := fmt.Sprintf(\"127.0.0.1:%d\", rpcPort)\n\t\t\tvar chainConn *chain.BitcoindConn\n\t\t\terr = wait.NoError(func() error {\n\t\t\t\tchainConn, err = chain.NewBitcoindConn(&chain.BitcoindConfig{\n\t\t\t\t\tChainParams: netParams,\n\t\t\t\t\tHost:        host,\n\t\t\t\t\tUser:        \"weks\",\n\t\t\t\t\tPass:        \"weks\",\n\t\t\t\t\tZMQConfig: &chain.ZMQConfig{\n\t\t\t\t\t\tZMQBlockHost:    zmqBlockHost,\n\t\t\t\t\t\tZMQTxHost:       zmqTxHost,\n\t\t\t\t\t\tZMQReadDeadline: 5 * time.Second,\n\t\t\t\t\t},\n\t\t\t\t\t// Fields only required for pruned nodes, not\n\t\t\t\t\t// needed for these tests.\n\t\t\t\t\tDialer:             nil,\n\t\t\t\t\tPrunedModeMaxPeers: 0,\n\t\t\t\t})\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\treturn chainConn.Start()\n\t\t\t}, 10*time.Second)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to establish connection to \"+\n\t\t\t\t\t\"bitcoind: %v\", err)\n\t\t\t}\n\t\t\tdefer chainConn.Stop()\n\n\t\t\t// Create a btcwallet bitcoind client for both Alice and\n\t\t\t// Bob.\n\t\t\taliceClient = chainConn.NewBitcoindClient()\n\t\t\tbobClient = chainConn.NewBitcoindClient()\n\n\t\tcase \"bitcoind-rpc-polling\":\n\t\t\t// Start a bitcoind instance.\n\t\t\ttempBitcoindDir := t.TempDir()\n\t\t\trpcPort := getFreePort()\n\t\t\tbitcoind := exec.Command(\n\t\t\t\t\"bitcoind\",\n\t\t\t\t\"-datadir=\"+tempBitcoindDir,\n\t\t\t\t\"-regtest\",\n\t\t\t\t\"-connect=\"+miningNode.P2PAddress(),\n\t\t\t\t\"-txindex\",\n\t\t\t\t\"-rpcauth=weks:469e9bb14ab2360f8e226efed5ca6f\"+\n\t\t\t\t\t\"d$507c670e800a95284294edb5773b05544b\"+\n\t\t\t\t\t\"220110063096c221be9933c82d38e1\",\n\t\t\t\tfmt.Sprintf(\"-rpcport=%d\", rpcPort),\n\t\t\t\t\"-disablewallet\",\n\t\t\t)\n\t\t\terr = bitcoind.Start()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"couldn't start bitcoind: %v\", err)\n\t\t\t}\n\t\t\tdefer func() {\n\t\t\t\t_ = bitcoind.Process.Kill()\n\t\t\t\t_ = bitcoind.Wait()\n\t\t\t}()\n\n\t\t\t// Sanity check to ensure that the process did in fact\n\t\t\t// start.\n\t\t\tif bitcoind.Process == nil {\n\t\t\t\tt.Fatalf(\"bitcoind cmd Process is not set \" +\n\t\t\t\t\t\"after Start\")\n\t\t\t}\n\n\t\t\t// Wait for the bitcoind instance to start up.\n\t\t\thost := fmt.Sprintf(\"127.0.0.1:%d\", rpcPort)\n\t\t\tvar chainConn *chain.BitcoindConn\n\t\t\terr = wait.NoError(func() error {\n\t\t\t\tchainConn, err = chain.NewBitcoindConn(&chain.BitcoindConfig{\n\t\t\t\t\tChainParams: netParams,\n\t\t\t\t\tHost:        host,\n\t\t\t\t\tUser:        \"weks\",\n\t\t\t\t\tPass:        \"weks\",\n\t\t\t\t\tPollingConfig: &chain.PollingConfig{\n\t\t\t\t\t\tBlockPollingInterval: time.Millisecond * 20,\n\t\t\t\t\t\tTxPollingInterval:    time.Millisecond * 20,\n\t\t\t\t\t},\n\t\t\t\t\t// Fields only required for pruned nodes, not\n\t\t\t\t\t// needed for these tests.\n\t\t\t\t\tDialer:             nil,\n\t\t\t\t\tPrunedModeMaxPeers: 0,\n\t\t\t\t})\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\treturn chainConn.Start()\n\t\t\t}, 10*time.Second)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to establish connection to \"+\n\t\t\t\t\t\"bitcoind: %v\", err)\n\t\t\t}\n\t\t\tdefer chainConn.Stop()\n\n\t\t\t// Create a btcwallet bitcoind client for both Alice and\n\t\t\t// Bob.\n\t\t\taliceClient = chainConn.NewBitcoindClient()\n\t\t\tbobClient = chainConn.NewBitcoindClient()\n\n\t\tdefault:\n\t\t\tt.Fatalf(\"unknown chain driver: %v\", backEnd)\n\t\t}\n\n\t\taliceSeed := sha256.New()\n\t\taliceSeed.Write([]byte(backEnd))\n\t\taliceSeed.Write(aliceHDSeed[:])\n\t\taliceSeedBytes := aliceSeed.Sum(nil)\n\n\t\taliceWalletConfig := &btcwallet.Config{\n\t\t\tPrivatePass: []byte(\"alice-pass\"),\n\t\t\tHdSeed:      aliceSeedBytes,\n\t\t\tNetParams:   netParams,\n\t\t\tChainSource: aliceClient,\n\t\t\tCoinType:    keychain.CoinTypeTestnet,\n\t\t\t// wallet starts in recovery mode\n\t\t\tRecoveryWindow: 2,\n\t\t\tLoaderOptions: []btcwallet.LoaderOption{\n\t\t\t\tbtcwallet.LoaderWithLocalWalletDB(\n\t\t\t\t\ttempTestDirAlice, false, time.Minute,\n\t\t\t\t),\n\t\t\t},\n\t\t}\n\t\taliceWalletController, err = walletDriver.New(\n\t\t\taliceWalletConfig, blockCache,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to create btcwallet: %v\", err)\n\t\t}\n\t\taliceSigner = aliceWalletController.(*btcwallet.BtcWallet)\n\t\taliceKeyRing = keychain.NewBtcWalletKeyRing(\n\t\t\taliceWalletController.(*btcwallet.BtcWallet).InternalWallet(),\n\t\t\tkeychain.CoinTypeTestnet,\n\t\t)\n\n\t\tbobSeed := sha256.New()\n\t\tbobSeed.Write([]byte(backEnd))\n\t\tbobSeed.Write(bobHDSeed[:])\n\t\tbobSeedBytes := bobSeed.Sum(nil)\n\n\t\tbobWalletConfig := &btcwallet.Config{\n\t\t\tPrivatePass: []byte(\"bob-pass\"),\n\t\t\tHdSeed:      bobSeedBytes,\n\t\t\tNetParams:   netParams,\n\t\t\tChainSource: bobClient,\n\t\t\tCoinType:    keychain.CoinTypeTestnet,\n\t\t\t// wallet starts without recovery mode\n\t\t\tRecoveryWindow: 0,\n\t\t\tLoaderOptions: []btcwallet.LoaderOption{\n\t\t\t\tbtcwallet.LoaderWithLocalWalletDB(\n\t\t\t\t\ttempTestDirBob, false, time.Minute,\n\t\t\t\t),\n\t\t\t},\n\t\t}\n\t\tbobWalletController, err = walletDriver.New(\n\t\t\tbobWalletConfig, blockCache,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to create btcwallet: %v\", err)\n\t\t}\n\t\tbobSigner = bobWalletController.(*btcwallet.BtcWallet)\n\t\tbobKeyRing = keychain.NewBtcWalletKeyRing(\n\t\t\tbobWalletController.(*btcwallet.BtcWallet).InternalWallet(),\n\t\t\tkeychain.CoinTypeTestnet,\n\t\t)\n\t\tbio = bobWalletController.(*btcwallet.BtcWallet)\n\tdefault:\n\t\tt.Fatalf(\"unknown wallet driver: %v\", walletType)\n\t}\n\n\t// Funding via 20 outputs with 4BTC each.\n\talice, err := createTestWallet(\n\t\ttempTestDirAlice, miningNode, netParams,\n\t\tchainNotifier, aliceWalletController, aliceKeyRing,\n\t\taliceSigner, bio,\n\t)\n\trequire.NoError(t, err, \"unable to create test ln wallet\")\n\tdefer alice.Shutdown()\n\n\tbob, err := createTestWallet(\n\t\ttempTestDirBob, miningNode, netParams,\n\t\tchainNotifier, bobWalletController, bobKeyRing, bobSigner, bio,\n\t)\n\trequire.NoError(t, err, \"unable to create test ln wallet\")\n\tdefer bob.Shutdown()\n\n\t// Both wallets should now have 80BTC available for\n\t// spending.\n\tassertProperBalance(t, alice, 1, 80)\n\tassertProperBalance(t, bob, 1, 80)\n\n\t// Execute every test, clearing possibly mutated\n\t// wallet state after each step.\n\tfor _, walletTest := range walletTests {\n\n\t\twalletTest := walletTest\n\n\t\ttestName := fmt.Sprintf(\"%v/%v:%v\", walletType, backEnd,\n\t\t\twalletTest.name)\n\t\tsuccess := t.Run(testName, func(t *testing.T) {\n\t\t\tif backEnd == \"neutrino\" &&\n\t\t\t\tstrings.Contains(walletTest.name, \"dual funder\") {\n\n\t\t\t\tt.Skip(\"skipping dual funder tests for neutrino\")\n\t\t\t}\n\t\t\tif backEnd == \"neutrino\" &&\n\t\t\t\tstrings.Contains(walletTest.name, \"spend unconfirmed\") {\n\n\t\t\t\tt.Skip(\"skipping spend unconfirmed tests for neutrino\")\n\t\t\t}\n\n\t\t\twalletTest.test(miningNode, alice, bob, t)\n\t\t})\n\t\tif !success {\n\t\t\treturn false\n\t\t}\n\n\t\t// TODO(roasbeef): possible reset mining\n\t\t// node's chainstate to initial level, cleanly\n\t\t// wipe buckets\n\t\tif err := clearWalletStates(alice, bob); err !=\n\t\t\tnil && err != kvdb.ErrBucketNotFound {\n\n\t\t\tt.Fatalf(\"unable to wipe wallet state: %v\", err)\n\t\t}\n\t}\n\n\treturn true\n}\n",
      "length": 9983,
      "tokens": 1024,
      "embedding": []
    }
  ]
}