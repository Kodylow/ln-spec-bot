{
  "filepath": "../implementations/go/lnd/lnwallet/transactions_test.go",
  "package": "lnwallet",
  "sections": [
    {
      "slug": "type testContext struct {",
      "content": "type testContext struct {\n\tlocalFundingPrivkey                *btcec.PrivateKey\n\tlocalPaymentBasepointSecret        *btcec.PrivateKey\n\tlocalDelayedPaymentBasepointSecret *btcec.PrivateKey\n\tremoteFundingPrivkey               *btcec.PrivateKey\n\tremoteRevocationBasepointSecret    *btcec.PrivateKey\n\tremotePaymentBasepointSecret       *btcec.PrivateKey\n\n\tlocalPerCommitSecret lntypes.Hash\n\n\tfundingTx *btcutil.Tx\n\n\tlocalCsvDelay uint16\n\tfundingAmount btcutil.Amount\n\tdustLimit     btcutil.Amount\n\tcommitHeight  uint64\n\n\tt *testing.T\n}\n\n// newTestContext populates a new testContext struct with the constant\n// parameters defined in the BOLT 03 spec.",
      "length": 600,
      "tokens": 45,
      "embedding": []
    },
    {
      "slug": "func newTestContext(t *testing.T) *testContext {",
      "content": "func newTestContext(t *testing.T) *testContext {\n\ttc := new(testContext)\n\n\tpriv := func(v string) *btcec.PrivateKey {\n\t\tk, err := privkeyFromHex(v)\n\t\trequire.NoError(t, err)\n\n\t\treturn k\n\t}\n\n\ttc.remoteFundingPrivkey = priv(\"1552dfba4f6cf29a62a0af13c8d6981d36d0ef8d61ba10fb0fe90da7634d7e13\")\n\ttc.remoteRevocationBasepointSecret = priv(\"2222222222222222222222222222222222222222222222222222222222222222\")\n\ttc.remotePaymentBasepointSecret = priv(\"4444444444444444444444444444444444444444444444444444444444444444\")\n\ttc.localPaymentBasepointSecret = priv(\"1111111111111111111111111111111111111111111111111111111111111111\")\n\ttc.localDelayedPaymentBasepointSecret = priv(\"3333333333333333333333333333333333333333333333333333333333333333\")\n\ttc.localFundingPrivkey = priv(\"30ff4956bbdd3222d44cc5e8a1261dab1e07957bdac5ae88fe3261ef321f3749\")\n\n\tvar err error\n\ttc.localPerCommitSecret, err = lntypes.MakeHashFromStr(\"1f1e1d1c1b1a191817161514131211100f0e0d0c0b0a09080706050403020100\")\n\trequire.NoError(t, err)\n\n\tconst fundingTxHex = \"0200000001adbb20ea41a8423ea937e76e8151636bf6093b70eaff942930d20576600521fd000000006b48304502210090587b6201e166ad6af0227d3036a9454223d49a1f11839c1a362184340ef0240220577f7cd5cca78719405cbf1de7414ac027f0239ef6e214c90fcaab0454d84b3b012103535b32d5eb0a6ed0982a0479bbadc9868d9836f6ba94dd5a63be16d875069184ffffffff028096980000000000220020c015c4a6be010e21657068fc2e6a9d02b27ebe4d490a25846f7237f104d1a3cd20256d29010000001600143ca33c2e4446f4a305f23c80df8ad1afdcf652f900000000\"\n\ttc.fundingTx, err = txFromHex(fundingTxHex)\n\trequire.NoError(t, err)\n\n\ttc.localCsvDelay = 144\n\ttc.fundingAmount = 10000000\n\ttc.dustLimit = 546\n\ttc.commitHeight = 42\n\ttc.t = t\n\n\treturn tc\n}\n\nvar testHtlcs = []struct {\n\tincoming bool\n\tamount   lnwire.MilliSatoshi\n\texpiry   uint32\n\tpreimage string\n}{\n\t{\n\t\tincoming: true,\n\t\tamount:   1000000,\n\t\texpiry:   500,\n\t\tpreimage: \"0000000000000000000000000000000000000000000000000000000000000000\",\n\t},\n\t{\n\t\tincoming: true,\n\t\tamount:   2000000,\n\t\texpiry:   501,\n\t\tpreimage: \"0101010101010101010101010101010101010101010101010101010101010101\",\n\t},\n\t{\n\t\tincoming: false,\n\t\tamount:   2000000,\n\t\texpiry:   502,\n\t\tpreimage: \"0202020202020202020202020202020202020202020202020202020202020202\",\n\t},\n\t{\n\t\tincoming: false,\n\t\tamount:   3000000,\n\t\texpiry:   503,\n\t\tpreimage: \"0303030303030303030303030303030303030303030303030303030303030303\",\n\t},\n\t{\n\t\tincoming: true,\n\t\tamount:   4000000,\n\t\texpiry:   504,\n\t\tpreimage: \"0404040404040404040404040404040404040404040404040404040404040404\",\n\t},\n}\n\n// htlcDesc is a description used to construct each HTLC in each test case.",
      "length": 2459,
      "tokens": 152,
      "embedding": []
    },
    {
      "slug": "type htlcDesc struct {",
      "content": "type htlcDesc struct {\n\tRemoteSigHex    string\n\tResolutionTxHex string\n}\n",
      "length": 47,
      "tokens": 5,
      "embedding": []
    },
    {
      "slug": "type testCase struct {",
      "content": "type testCase struct {\n\tName          string\n\tLocalBalance  lnwire.MilliSatoshi\n\tRemoteBalance lnwire.MilliSatoshi\n\tFeePerKw      btcutil.Amount\n\n\t// UseTestHtlcs defined whether the fixed set of test htlc should be\n\t// added to the channel before checking the commitment assertions.\n\tUseTestHtlcs bool\n\n\tHtlcDescs               []htlcDesc\n\tExpectedCommitmentTxHex string\n\tRemoteSigHex            string\n}\n\n// TestCommitmentAndHTLCTransactions checks the test vectors specified in\n// BOLT 03, Appendix C. This deterministically generates commitment and second\n// level HTLC transactions and checks that they match the expected values.",
      "length": 595,
      "tokens": 70,
      "embedding": []
    },
    {
      "slug": "func TestCommitmentAndHTLCTransactions(t *testing.T) {",
      "content": "func TestCommitmentAndHTLCTransactions(t *testing.T) {\n\tt.Parallel()\n\n\tvectorSets := []struct {\n\t\tname     string\n\t\tjsonFile string\n\t\tchanType channeldb.ChannelType\n\t}{\n\t\t{\n\t\t\tname:     \"legacy\",\n\t\t\tchanType: channeldb.SingleFunderBit,\n\t\t\tjsonFile: \"test_vectors_legacy.json\",\n\t\t},\n\t\t{\n\t\t\tname:     \"anchors\",\n\t\t\tchanType: channeldb.SingleFunderTweaklessBit | channeldb.AnchorOutputsBit,\n\t\t\tjsonFile: \"test_vectors_anchors.json\",\n\t\t},\n\t}\n\n\tfor _, set := range vectorSets {\n\t\tset := set\n\n\t\tvar testCases []testCase\n\n\t\tjsonText, err := ioutil.ReadFile(set.jsonFile)\n\t\trequire.NoError(t, err)\n\n\t\terr = json.Unmarshal(jsonText, &testCases)\n\t\trequire.NoError(t, err)\n\n\t\tt.Run(set.name, func(t *testing.T) {\n\t\t\tfor _, test := range testCases {\n\t\t\t\ttest := test\n\n\t\t\t\tt.Run(test.Name, func(t *testing.T) {\n\t\t\t\t\ttestVectors(t, set.chanType, test)\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t}\n}\n\n// addTestHtlcs adds the test vector htlcs to the update logs of the local and\n// remote node.",
      "length": 857,
      "tokens": 100,
      "embedding": []
    },
    {
      "slug": "func addTestHtlcs(t *testing.T, remote,",
      "content": "func addTestHtlcs(t *testing.T, remote,\n\tlocal *LightningChannel) map[[20]byte]lntypes.Preimage {\n\n\thash160map := make(map[[20]byte]lntypes.Preimage)\n\tfor _, htlc := range testHtlcs {\n\t\tpreimage, err := lntypes.MakePreimageFromStr(htlc.preimage)\n\t\trequire.NoError(t, err)\n\n\t\thash := preimage.Hash()\n\n\t\t// Store ripemd160 hash of the payment hash to later identify\n\t\t// resolutions.\n\t\tvar hash160 [20]byte\n\t\tcopy(hash160[:], input.Ripemd160H(hash[:]))\n\t\thash160map[hash160] = preimage\n\n\t\t// Add htlc to the channel.\n\t\tchanID := lnwire.NewChanIDFromOutPoint(remote.ChanPoint)\n\n\t\tmsg := &lnwire.UpdateAddHTLC{\n\t\t\tAmount:      htlc.amount,\n\t\t\tChanID:      chanID,\n\t\t\tExpiry:      htlc.expiry,\n\t\t\tPaymentHash: hash,\n\t\t}\n\t\tif htlc.incoming {\n\t\t\thtlcID, err := remote.AddHTLC(msg, nil)\n\t\t\trequire.NoError(t, err, \"unable to add htlc\")\n\n\t\t\tmsg.ID = htlcID\n\t\t\t_, err = local.ReceiveHTLC(msg)\n\t\t\trequire.NoError(t, err, \"unable to recv htlc\")\n\t\t} else {\n\t\t\thtlcID, err := local.AddHTLC(msg, nil)\n\t\t\trequire.NoError(t, err, \"unable to add htlc\")\n\n\t\t\tmsg.ID = htlcID\n\t\t\t_, err = remote.ReceiveHTLC(msg)\n\t\t\trequire.NoError(t, err, \"unable to recv htlc\")\n\t\t}\n\t}\n\n\treturn hash160map\n}\n\n// testVectors executes a commit dance to end up with the commitment transaction\n// that is described in the test vectors and then asserts that all values are\n// correct.",
      "length": 1255,
      "tokens": 154,
      "embedding": []
    },
    {
      "slug": "func testVectors(t *testing.T, chanType channeldb.ChannelType, test testCase) {",
      "content": "func testVectors(t *testing.T, chanType channeldb.ChannelType, test testCase) {\n\ttc := newTestContext(t)\n\n\t// Balances in the test vectors are before subtraction of in-flight\n\t// htlcs. Convert to spendable balances.\n\tremoteBalance := test.RemoteBalance\n\tlocalBalance := test.LocalBalance\n\n\tif test.UseTestHtlcs {\n\t\tfor _, htlc := range testHtlcs {\n\t\t\tif htlc.incoming {\n\t\t\t\tremoteBalance += htlc.amount\n\t\t\t} else {\n\t\t\t\tlocalBalance += htlc.amount\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set up a test channel on which the test commitment transaction is\n\t// going to be produced.\n\tremoteChannel, localChannel := createTestChannelsForVectors(\n\t\ttc,\n\t\tchanType, test.FeePerKw,\n\t\tremoteBalance.ToSatoshis(),\n\t\tlocalBalance.ToSatoshis(),\n\t)\n\n\t// Add htlcs (if any) to the update logs of both sides and save a hash\n\t// map that allows us to identify the htlcs in the scripts later on and\n\t// retrieve the corresponding preimage.\n\tvar hash160map map[[20]byte]lntypes.Preimage\n\tif test.UseTestHtlcs {\n\t\thash160map = addTestHtlcs(t, remoteChannel, localChannel)\n\t}\n\n\t// Execute commit dance to arrive at the point where the local node has\n\t// received the test commitment and the remote signature.\n\tlocalSig, localHtlcSigs, _, err := localChannel.SignNextCommitment()\n\trequire.NoError(t, err, \"local unable to sign commitment\")\n\n\terr = remoteChannel.ReceiveNewCommitment(localSig, localHtlcSigs)\n\trequire.NoError(t, err)\n\n\trevMsg, _, _, err := remoteChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err)\n\n\t_, _, _, _, err = localChannel.ReceiveRevocation(revMsg)\n\trequire.NoError(t, err)\n\n\tremoteSig, remoteHtlcSigs, _, err := remoteChannel.SignNextCommitment()\n\trequire.NoError(t, err)\n\n\trequire.Equal(t, test.RemoteSigHex, hex.EncodeToString(remoteSig.ToSignatureBytes()))\n\n\tfor i, sig := range remoteHtlcSigs {\n\t\trequire.Equal(t, test.HtlcDescs[i].RemoteSigHex, hex.EncodeToString(sig.ToSignatureBytes()))\n\t}\n\n\terr = localChannel.ReceiveNewCommitment(remoteSig, remoteHtlcSigs)\n\trequire.NoError(t, err)\n\n\t_, _, _, err = localChannel.RevokeCurrentCommitment()\n\trequire.NoError(t, err)\n\n\t// Now the local node force closes the channel so that we can inspect\n\t// its state.\n\tforceCloseSum, err := localChannel.ForceClose()\n\trequire.NoError(t, err)\n\n\t// Assert that the commitment transaction itself is as expected.\n\tvar txBytes bytes.Buffer\n\trequire.NoError(t, forceCloseSum.CloseTx.Serialize(&txBytes))\n\n\trequire.Equal(t, test.ExpectedCommitmentTxHex, hex.EncodeToString(txBytes.Bytes()))\n\n\t// Obtain the second level transactions that the local node's channel\n\t// state machine has produced. Store them in a map indexed by commit tx\n\t// output index. Also complete the second level transaction with the\n\t// preimage. This is normally done later in the contract resolver.\n\tsecondLevelTxes := map[uint32]*wire.MsgTx{}\n\tstoreTx := func(index uint32, tx *wire.MsgTx) {\n\t\t// Prevent overwrites.\n\t\t_, exists := secondLevelTxes[index]\n\t\trequire.False(t, exists)\n\n\t\tsecondLevelTxes[index] = tx\n\t}\n\n\tfor _, r := range forceCloseSum.HtlcResolutions.IncomingHTLCs {\n\t\tsuccessTx := r.SignedSuccessTx\n\t\twitnessScript := successTx.TxIn[0].Witness[4]\n\t\tvar hash160 [20]byte\n\t\tcopy(hash160[:], witnessScript[69:69+20])\n\t\tpreimage := hash160map[hash160]\n\t\tsuccessTx.TxIn[0].Witness[3] = preimage[:]\n\t\tstoreTx(r.HtlcPoint().Index, successTx)\n\t}\n\tfor _, r := range forceCloseSum.HtlcResolutions.OutgoingHTLCs {\n\t\tstoreTx(r.HtlcPoint().Index, r.SignedTimeoutTx)\n\t}\n\n\t// Create a list of second level transactions ordered by commit tx\n\t// output index.\n\tvar keys []uint32\n\tfor k := range secondLevelTxes {\n\t\tkeys = append(keys, k)\n\t}\n\tsort.Slice(keys, func(a, b int) bool {\n\t\treturn keys[a] < keys[b]\n\t})\n\n\t// Assert that this list matches the test vectors.\n\tfor i, idx := range keys {\n\t\ttx := secondLevelTxes[idx]\n\t\tvar b bytes.Buffer\n\t\terr := tx.Serialize(&b)\n\t\trequire.NoError(t, err)\n\n\t\trequire.Equal(\n\t\t\tt,\n\t\t\ttest.HtlcDescs[i].ResolutionTxHex,\n\t\t\thex.EncodeToString(b.Bytes()),\n\t\t)\n\t}\n}\n\n// htlcViewFromHTLCs constructs an htlcView of PaymentDescriptors from a slice\n// of channeldb.HTLC structs.",
      "length": 3851,
      "tokens": 458,
      "embedding": []
    },
    {
      "slug": "func htlcViewFromHTLCs(htlcs []channeldb.HTLC) *htlcView {",
      "content": "func htlcViewFromHTLCs(htlcs []channeldb.HTLC) *htlcView {\n\tvar theHTLCView htlcView\n\tfor _, htlc := range htlcs {\n\t\tpaymentDesc := &PaymentDescriptor{\n\t\t\tRHash:   htlc.RHash,\n\t\t\tTimeout: htlc.RefundTimeout,\n\t\t\tAmount:  htlc.Amt,\n\t\t}\n\t\tif htlc.Incoming {\n\t\t\ttheHTLCView.theirUpdates =\n\t\t\t\tappend(theHTLCView.theirUpdates, paymentDesc)\n\t\t} else {\n\t\t\ttheHTLCView.ourUpdates =\n\t\t\t\tappend(theHTLCView.ourUpdates, paymentDesc)\n\t\t}\n\t}\n\treturn &theHTLCView\n}\n",
      "length": 376,
      "tokens": 39,
      "embedding": []
    },
    {
      "slug": "func TestCommitTxStateHint(t *testing.T) {",
      "content": "func TestCommitTxStateHint(t *testing.T) {\n\tt.Parallel()\n\n\tstateHintTests := []struct {\n\t\tname       string\n\t\tfrom       uint64\n\t\tto         uint64\n\t\tinputs     int\n\t\tshouldFail bool\n\t}{\n\t\t{\n\t\t\tname:       \"states 0 to 1000\",\n\t\t\tfrom:       0,\n\t\t\tto:         1000,\n\t\t\tinputs:     1,\n\t\t\tshouldFail: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"states 'maxStateHint-1000' to 'maxStateHint'\",\n\t\t\tfrom:       maxStateHint - 1000,\n\t\t\tto:         maxStateHint,\n\t\t\tinputs:     1,\n\t\t\tshouldFail: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"state 'maxStateHint+1'\",\n\t\t\tfrom:       maxStateHint + 1,\n\t\t\tto:         maxStateHint + 10,\n\t\t\tinputs:     1,\n\t\t\tshouldFail: true,\n\t\t},\n\t\t{\n\t\t\tname:       \"commit transaction with two inputs\",\n\t\t\tinputs:     2,\n\t\t\tshouldFail: true,\n\t\t},\n\t}\n\n\tvar obfuscator [StateHintSize]byte\n\tcopy(obfuscator[:], testHdSeed[:StateHintSize])\n\ttimeYesterday := uint32(time.Now().Unix() - 24*60*60)\n\n\tfor _, test := range stateHintTests {\n\t\tcommitTx := wire.NewMsgTx(2)\n\n\t\t// Add supplied number of inputs to the commitment transaction.\n\t\tfor i := 0; i < test.inputs; i++ {\n\t\t\tcommitTx.AddTxIn(&wire.TxIn{})\n\t\t}\n\n\t\tfor i := test.from; i <= test.to; i++ {\n\t\t\tstateNum := uint64(i)\n\n\t\t\terr := SetStateNumHint(commitTx, stateNum, obfuscator)\n\t\t\tif err != nil && !test.shouldFail {\n\t\t\t\tt.Fatalf(\"unable to set state num %v: %v\", i, err)\n\t\t\t} else if err == nil && test.shouldFail {\n\t\t\t\tt.Fatalf(\"Failed(%v): test should fail but did not\", test.name)\n\t\t\t}\n\n\t\t\tlocktime := commitTx.LockTime\n\t\t\tsequence := commitTx.TxIn[0].Sequence\n\n\t\t\t// Locktime should not be less than 500,000,000 and not larger\n\t\t\t// than the time 24 hours ago. One day should provide a good\n\t\t\t// enough buffer for the tests.\n\t\t\tif locktime < 5e8 || locktime > timeYesterday {\n\t\t\t\tif !test.shouldFail {\n\t\t\t\t\tt.Fatalf(\"The value of locktime (%v) may cause the commitment \"+\n\t\t\t\t\t\t\"transaction to be unspendable\", locktime)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif sequence&wire.SequenceLockTimeDisabled == 0 {\n\t\t\t\tif !test.shouldFail {\n\t\t\t\t\tt.Fatalf(\"Sequence locktime is NOT disabled when it should be\")\n\t\t\t\t}\n\t\t\t}\n\n\t\t\textractedStateNum := GetStateNumHint(commitTx, obfuscator)\n\t\t\tif extractedStateNum != stateNum && !test.shouldFail {\n\t\t\t\tt.Fatalf(\"state number mismatched, expected %v, got %v\",\n\t\t\t\t\tstateNum, extractedStateNum)\n\t\t\t} else if extractedStateNum == stateNum && test.shouldFail {\n\t\t\t\tt.Fatalf(\"Failed(%v): test should fail but did not\", test.name)\n\t\t\t}\n\t\t}\n\t\tt.Logf(\"Passed: %v\", test.name)\n\t}\n}\n\n// testSpendValidation ensures that we're able to spend all outputs in the\n// commitment transaction that we create.",
      "length": 2426,
      "tokens": 316,
      "embedding": []
    },
    {
      "slug": "func testSpendValidation(t *testing.T, tweakless bool) {",
      "content": "func testSpendValidation(t *testing.T, tweakless bool) {\n\t// We generate a fake output, and the corresponding txin. This output\n\t// doesn't need to exist, as we'll only be validating spending from the\n\t// transaction that references this.\n\ttxid, err := chainhash.NewHash(testHdSeed.CloneBytes())\n\trequire.NoError(t, err, \"unable to create txid\")\n\tfundingOut := &wire.OutPoint{\n\t\tHash:  *txid,\n\t\tIndex: 50,\n\t}\n\tfakeFundingTxIn := wire.NewTxIn(fundingOut, nil, nil)\n\n\tconst channelBalance = btcutil.Amount(1 * 10e8)\n\tconst csvTimeout = 5\n\n\t// We also set up set some resources for the commitment transaction.\n\t// Each side currently has 1 BTC within the channel, with a total\n\t// channel capacity of 2BTC.\n\taliceKeyPriv, aliceKeyPub := btcec.PrivKeyFromBytes(\n\t\ttestWalletPrivKey,\n\t)\n\tbobKeyPriv, bobKeyPub := btcec.PrivKeyFromBytes(\n\t\tbobsPrivKey,\n\t)\n\n\trevocationPreimage := testHdSeed.CloneBytes()\n\tcommitSecret, commitPoint := btcec.PrivKeyFromBytes(\n\t\trevocationPreimage,\n\t)\n\trevokePubKey := input.DeriveRevocationPubkey(bobKeyPub, commitPoint)\n\n\taliceDelayKey := input.TweakPubKey(aliceKeyPub, commitPoint)\n\n\t// Bob will have the channel \"force closed\" on him, so for the sake of\n\t// our commitments, if it's tweakless, his key will just be his regular\n\t// pubkey.\n\tbobPayKey := input.TweakPubKey(bobKeyPub, commitPoint)\n\tchannelType := channeldb.SingleFunderBit\n\tif tweakless {\n\t\tbobPayKey = bobKeyPub\n\t\tchannelType = channeldb.SingleFunderTweaklessBit\n\t}\n\n\tremoteCommitTweak := input.SingleTweakBytes(commitPoint, aliceKeyPub)\n\tlocalCommitTweak := input.SingleTweakBytes(commitPoint, bobKeyPub)\n\n\taliceSelfOutputSigner := &input.MockSigner{\n\t\tPrivkeys: []*btcec.PrivateKey{aliceKeyPriv},\n\t}\n\n\t// Calculate the dust limit we'll use for the test.\n\tdustLimit := DustLimitForSize(input.UnknownWitnessSize)\n\n\taliceChanCfg := &channeldb.ChannelConfig{\n\t\tChannelConstraints: channeldb.ChannelConstraints{\n\t\t\tDustLimit: dustLimit,\n\t\t\tCsvDelay:  csvTimeout,\n\t\t},\n\t}\n\n\tbobChanCfg := &channeldb.ChannelConfig{\n\t\tChannelConstraints: channeldb.ChannelConstraints{\n\t\t\tDustLimit: dustLimit,\n\t\t\tCsvDelay:  csvTimeout,\n\t\t},\n\t}\n\n\t// With all the test data set up, we create the commitment transaction.\n\t// We only focus on a single party's transactions, as the scripts are\n\t// identical with the roles reversed.\n\t//\n\t// This is Alice's commitment transaction, so she must wait a CSV delay\n\t// of 5 blocks before sweeping the output, while bob can spend\n\t// immediately with either the revocation key, or his regular key.\n\tkeyRing := &CommitmentKeyRing{\n\t\tToLocalKey:    aliceDelayKey,\n\t\tRevocationKey: revokePubKey,\n\t\tToRemoteKey:   bobPayKey,\n\t}\n\tcommitmentTx, err := CreateCommitTx(\n\t\tchannelType, *fakeFundingTxIn, keyRing, aliceChanCfg,\n\t\tbobChanCfg, channelBalance, channelBalance, 0, true, 0,\n\t)\n\tif err != nil {\n\t\tt.Fatalf(\"unable to create commitment transaction: %v\", nil)\n\t}\n\n\tdelayOutput := commitmentTx.TxOut[0]\n\tregularOutput := commitmentTx.TxOut[1]\n\n\t// We're testing an uncooperative close, output sweep, so construct a\n\t// transaction which sweeps the funds to a random address.\n\ttargetOutput, err := input.CommitScriptUnencumbered(aliceKeyPub)\n\trequire.NoError(t, err, \"unable to create target output\")\n\tsweepTx := wire.NewMsgTx(2)\n\tsweepTx.AddTxIn(wire.NewTxIn(&wire.OutPoint{\n\t\tHash:  commitmentTx.TxHash(),\n\t\tIndex: 0,\n\t}, nil, nil))\n\tsweepTx.AddTxOut(&wire.TxOut{\n\t\tPkScript: targetOutput,\n\t\tValue:    0.5 * 10e8,\n\t})\n\n\t// First, we'll test spending with Alice's key after the timeout.\n\tdelayScript, err := input.CommitScriptToSelf(\n\t\tcsvTimeout, aliceDelayKey, revokePubKey,\n\t)\n\trequire.NoError(t, err, \"unable to generate alice delay script\")\n\tsweepTx.TxIn[0].Sequence = input.LockTimeToSequence(false, csvTimeout)\n\tsignDesc := &input.SignDescriptor{\n\t\tWitnessScript: delayScript,\n\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\tPubKey: aliceKeyPub,\n\t\t},\n\t\tSingleTweak: remoteCommitTweak,\n\t\tSigHashes:   input.NewTxSigHashesV0Only(sweepTx),\n\t\tOutput: &wire.TxOut{\n\t\t\tValue: int64(channelBalance),\n\t\t},\n\t\tHashType:   txscript.SigHashAll,\n\t\tInputIndex: 0,\n\t}\n\taliceWitnessSpend, err := input.CommitSpendTimeout(\n\t\taliceSelfOutputSigner, signDesc, sweepTx,\n\t)\n\trequire.NoError(t, err, \"unable to generate delay commit spend witness\")\n\tsweepTx.TxIn[0].Witness = aliceWitnessSpend\n\tvm, err := txscript.NewEngine(\n\t\tdelayOutput.PkScript, sweepTx, 0, txscript.StandardVerifyFlags,\n\t\tnil, nil, int64(channelBalance),\n\t\ttxscript.NewCannedPrevOutputFetcher(nil, 0),\n\t)\n\trequire.NoError(t, err, \"unable to create engine\")\n\tif err := vm.Execute(); err != nil {\n\t\tt.Fatalf(\"spend from delay output is invalid: %v\", err)\n\t}\n\n\tlocalSigner := &input.MockSigner{Privkeys: []*btcec.PrivateKey{bobKeyPriv}}\n\n\t// Next, we'll test bob spending with the derived revocation key to\n\t// simulate the scenario when Alice broadcasts this commitment\n\t// transaction after it's been revoked.\n\tsignDesc = &input.SignDescriptor{\n\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\tPubKey: bobKeyPub,\n\t\t},\n\t\tDoubleTweak:   commitSecret,\n\t\tWitnessScript: delayScript,\n\t\tSigHashes:     input.NewTxSigHashesV0Only(sweepTx),\n\t\tOutput: &wire.TxOut{\n\t\t\tValue: int64(channelBalance),\n\t\t},\n\t\tHashType:   txscript.SigHashAll,\n\t\tInputIndex: 0,\n\t}\n\tbobWitnessSpend, err := input.CommitSpendRevoke(localSigner, signDesc,\n\t\tsweepTx)\n\trequire.NoError(t, err, \"unable to generate revocation witness\")\n\tsweepTx.TxIn[0].Witness = bobWitnessSpend\n\tvm, err = txscript.NewEngine(\n\t\tdelayOutput.PkScript, sweepTx, 0, txscript.StandardVerifyFlags,\n\t\tnil, nil, int64(channelBalance),\n\t\ttxscript.NewCannedPrevOutputFetcher(nil, 0),\n\t)\n\trequire.NoError(t, err, \"unable to create engine\")\n\tif err := vm.Execute(); err != nil {\n\t\tt.Fatalf(\"revocation spend is invalid: %v\", err)\n\t}\n\n\t// In order to test the final scenario, we modify the TxIn of the sweep\n\t// transaction to instead point to the regular output (non delay)\n\t// within the commitment transaction.\n\tsweepTx.TxIn[0] = &wire.TxIn{\n\t\tPreviousOutPoint: wire.OutPoint{\n\t\t\tHash:  commitmentTx.TxHash(),\n\t\t\tIndex: 1,\n\t\t},\n\t}\n\n\t// Finally, we test bob sweeping his output as normal in the case that\n\t// Alice broadcasts this commitment transaction.\n\tbobScriptP2WKH, err := input.CommitScriptUnencumbered(bobPayKey)\n\trequire.NoError(t, err, \"unable to create bob p2wkh script\")\n\tsignDesc = &input.SignDescriptor{\n\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\tPubKey: bobKeyPub,\n\t\t},\n\t\tWitnessScript: bobScriptP2WKH,\n\t\tSigHashes:     input.NewTxSigHashesV0Only(sweepTx),\n\t\tOutput: &wire.TxOut{\n\t\t\tValue:    int64(channelBalance),\n\t\t\tPkScript: bobScriptP2WKH,\n\t\t},\n\t\tHashType:   txscript.SigHashAll,\n\t\tInputIndex: 0,\n\t}\n\tif !tweakless {\n\t\tsignDesc.SingleTweak = localCommitTweak\n\t}\n\tbobRegularSpend, err := input.CommitSpendNoDelay(\n\t\tlocalSigner, signDesc, sweepTx, tweakless,\n\t)\n\trequire.NoError(t, err, \"unable to create bob regular spend\")\n\tsweepTx.TxIn[0].Witness = bobRegularSpend\n\tvm, err = txscript.NewEngine(\n\t\tregularOutput.PkScript,\n\t\tsweepTx, 0, txscript.StandardVerifyFlags, nil,\n\t\tnil, int64(channelBalance),\n\t\ttxscript.NewCannedPrevOutputFetcher(bobScriptP2WKH, 0),\n\t)\n\trequire.NoError(t, err, \"unable to create engine\")\n\tif err := vm.Execute(); err != nil {\n\t\tt.Fatalf(\"bob p2wkh spend is invalid: %v\", err)\n\t}\n}\n\n// TestCommitmentSpendValidation test the spendability of both outputs within\n// the commitment transaction.\n//\n// The following spending cases are covered by this test:\n//   - Alice's spend from the delayed output on her commitment transaction.\n//   - Bob's spend from Alice's delayed output when she broadcasts a revoked\n//     commitment transaction.\n//   - Bob's spend from his unencumbered output within Alice's commitment\n//     transaction.",
      "length": 7369,
      "tokens": 827,
      "embedding": []
    },
    {
      "slug": "func TestCommitmentSpendValidation(t *testing.T) {",
      "content": "func TestCommitmentSpendValidation(t *testing.T) {\n\tt.Parallel()\n\n\t// In the modern network, all channels use the new tweakless format,\n\t// but we also need to support older nodes that want to open channels\n\t// with the legacy format, so we'll test spending in both scenarios.\n\tfor _, tweakless := range []bool{true, false} {\n\t\ttweakless := tweakless\n\t\tt.Run(fmt.Sprintf(\"tweak=%v\", tweakless), func(t *testing.T) {\n\t\t\ttestSpendValidation(t, tweakless)\n\t\t})\n\t}\n}\n",
      "length": 400,
      "tokens": 60,
      "embedding": []
    },
    {
      "slug": "type mockProducer struct {",
      "content": "type mockProducer struct {\n\tsecret chainhash.Hash\n}\n",
      "length": 23,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (p *mockProducer) AtIndex(uint64) (*chainhash.Hash, error) {",
      "content": "func (p *mockProducer) AtIndex(uint64) (*chainhash.Hash, error) {\n\treturn &p.secret, nil\n}\n",
      "length": 23,
      "tokens": 4,
      "embedding": []
    },
    {
      "slug": "func (p *mockProducer) Encode(w io.Writer) error {",
      "content": "func (p *mockProducer) Encode(w io.Writer) error {\n\t_, err := w.Write(p.secret[:])\n\treturn err\n}\n\n// createTestChannelsForVectors creates two LightningChannel instances for the\n// test channel that is used to verify the test vectors.",
      "length": 177,
      "tokens": 26,
      "embedding": []
    },
    {
      "slug": "func createTestChannelsForVectors(tc *testContext, chanType channeldb.ChannelType,",
      "content": "func createTestChannelsForVectors(tc *testContext, chanType channeldb.ChannelType,\n\tfeeRate btcutil.Amount, remoteBalance, localBalance btcutil.Amount) (\n\t*LightningChannel, *LightningChannel) {\n\n\tt := tc.t\n\n\tprevOut := &wire.OutPoint{\n\t\tHash:  *tc.fundingTx.Hash(),\n\t\tIndex: 0,\n\t}\n\n\tfundingTxIn := wire.NewTxIn(prevOut, nil, nil)\n\n\t// Generate random some keys that don't actually matter but need to be\n\t// set.\n\tvar (\n\t\tremoteDummy1, remoteDummy2 *btcec.PrivateKey\n\t\tlocalDummy2, localDummy1   *btcec.PrivateKey\n\t)\n\tgenerateKeys := []**btcec.PrivateKey{\n\t\t&remoteDummy1, &remoteDummy2, &localDummy1, &localDummy2,\n\t}\n\tfor _, keyRef := range generateKeys {\n\t\tprivkey, err := btcec.NewPrivateKey()\n\t\trequire.NoError(t, err)\n\t\t*keyRef = privkey\n\t}\n\n\t// Define channel configurations.\n\tremoteCfg := channeldb.ChannelConfig{\n\t\tChannelConstraints: channeldb.ChannelConstraints{\n\t\t\tDustLimit: tc.dustLimit,\n\t\t\tMaxPendingAmount: lnwire.NewMSatFromSatoshis(\n\t\t\t\ttc.fundingAmount,\n\t\t\t),\n\t\t\tChanReserve:      0,\n\t\t\tMinHTLC:          0,\n\t\t\tMaxAcceptedHtlcs: input.MaxHTLCNumber / 2,\n\t\t\tCsvDelay:         tc.localCsvDelay,\n\t\t},\n\t\tMultiSigKey: keychain.KeyDescriptor{\n\t\t\tPubKey: tc.remoteFundingPrivkey.PubKey(),\n\t\t},\n\t\tPaymentBasePoint: keychain.KeyDescriptor{\n\t\t\tPubKey: tc.remotePaymentBasepointSecret.PubKey(),\n\t\t},\n\t\tHtlcBasePoint: keychain.KeyDescriptor{\n\t\t\tPubKey: tc.remotePaymentBasepointSecret.PubKey(),\n\t\t},\n\t\tDelayBasePoint: keychain.KeyDescriptor{\n\t\t\tPubKey: remoteDummy1.PubKey(),\n\t\t},\n\t\tRevocationBasePoint: keychain.KeyDescriptor{\n\t\t\tPubKey: tc.remoteRevocationBasepointSecret.PubKey(),\n\t\t},\n\t}\n\tlocalCfg := channeldb.ChannelConfig{\n\t\tChannelConstraints: channeldb.ChannelConstraints{\n\t\t\tDustLimit: tc.dustLimit,\n\t\t\tMaxPendingAmount: lnwire.NewMSatFromSatoshis(\n\t\t\t\ttc.fundingAmount,\n\t\t\t),\n\t\t\tChanReserve:      0,\n\t\t\tMinHTLC:          0,\n\t\t\tMaxAcceptedHtlcs: input.MaxHTLCNumber / 2,\n\t\t\tCsvDelay:         tc.localCsvDelay,\n\t\t},\n\t\tMultiSigKey: keychain.KeyDescriptor{\n\t\t\tPubKey: tc.localFundingPrivkey.PubKey(),\n\t\t},\n\t\tPaymentBasePoint: keychain.KeyDescriptor{\n\t\t\tPubKey: tc.localPaymentBasepointSecret.PubKey(),\n\t\t},\n\t\tHtlcBasePoint: keychain.KeyDescriptor{\n\t\t\tPubKey: tc.localPaymentBasepointSecret.PubKey(),\n\t\t},\n\t\tDelayBasePoint: keychain.KeyDescriptor{\n\t\t\tPubKey: tc.localDelayedPaymentBasepointSecret.PubKey(),\n\t\t},\n\t\tRevocationBasePoint: keychain.KeyDescriptor{\n\t\t\tPubKey: localDummy1.PubKey(),\n\t\t},\n\t}\n\n\t// Create mock producers to force usage of the test vector commitment\n\t// point.\n\tremotePreimageProducer := &mockProducer{\n\t\tsecret: chainhash.Hash(tc.localPerCommitSecret),\n\t}\n\tremoteCommitPoint := input.ComputeCommitmentPoint(\n\t\ttc.localPerCommitSecret[:],\n\t)\n\n\tlocalPreimageProducer := &mockProducer{\n\t\tsecret: chainhash.Hash(tc.localPerCommitSecret),\n\t}\n\tlocalCommitPoint := input.ComputeCommitmentPoint(\n\t\ttc.localPerCommitSecret[:],\n\t)\n\n\t// Create temporary databases.\n\tdbRemote, err := channeldb.Open(t.TempDir())\n\trequire.NoError(t, err)\n\n\tdbLocal, err := channeldb.Open(t.TempDir())\n\trequire.NoError(t, err)\n\n\t// Create the initial commitment transactions for the channel.\n\tfeePerKw := chainfee.SatPerKWeight(feeRate)\n\tcommitWeight := int64(input.CommitWeight)\n\tif chanType.HasAnchors() {\n\t\tcommitWeight = input.AnchorCommitWeight\n\t}\n\tcommitFee := feePerKw.FeeForWeight(commitWeight)\n\n\tvar anchorAmt btcutil.Amount\n\tif chanType.HasAnchors() {\n\t\tanchorAmt = 2 * anchorSize\n\t}\n\n\tremoteCommitTx, localCommitTx, err := CreateCommitmentTxns(\n\t\tremoteBalance, localBalance-commitFee,\n\t\t&remoteCfg, &localCfg, remoteCommitPoint,\n\t\tlocalCommitPoint, *fundingTxIn, chanType, true, 0,\n\t)\n\trequire.NoError(t, err)\n\n\t// Set up the full channel state.\n\n\t// Subtract one because extra sig exchange will take place during setup\n\t// to get to the right test point.\n\tvar commitHeight = tc.commitHeight - 1\n\n\tremoteCommit := channeldb.ChannelCommitment{\n\t\tCommitHeight:  commitHeight,\n\t\tLocalBalance:  lnwire.NewMSatFromSatoshis(remoteBalance),\n\t\tRemoteBalance: lnwire.NewMSatFromSatoshis(localBalance - commitFee - anchorAmt),\n\t\tCommitFee:     commitFee,\n\t\tFeePerKw:      btcutil.Amount(feePerKw),\n\t\tCommitTx:      remoteCommitTx,\n\t\tCommitSig:     testSigBytes,\n\t}\n\tlocalCommit := channeldb.ChannelCommitment{\n\t\tCommitHeight:  commitHeight,\n\t\tLocalBalance:  lnwire.NewMSatFromSatoshis(localBalance - commitFee - anchorAmt),\n\t\tRemoteBalance: lnwire.NewMSatFromSatoshis(remoteBalance),\n\t\tCommitFee:     commitFee,\n\t\tFeePerKw:      btcutil.Amount(feePerKw),\n\t\tCommitTx:      localCommitTx,\n\t\tCommitSig:     testSigBytes,\n\t}\n\n\tvar chanIDBytes [8]byte\n\t_, err = io.ReadFull(rand.Reader, chanIDBytes[:])\n\trequire.NoError(t, err)\n\n\tshortChanID := lnwire.NewShortChanIDFromInt(\n\t\tbinary.BigEndian.Uint64(chanIDBytes[:]),\n\t)\n\n\tremoteChannelState := &channeldb.OpenChannel{\n\t\tLocalChanCfg:            remoteCfg,\n\t\tRemoteChanCfg:           localCfg,\n\t\tIdentityPub:             remoteDummy2.PubKey(),\n\t\tFundingOutpoint:         *prevOut,\n\t\tShortChannelID:          shortChanID,\n\t\tChanType:                chanType,\n\t\tIsInitiator:             false,\n\t\tCapacity:                tc.fundingAmount,\n\t\tRemoteCurrentRevocation: localCommitPoint,\n\t\tRevocationProducer:      remotePreimageProducer,\n\t\tRevocationStore:         shachain.NewRevocationStore(),\n\t\tLocalCommitment:         remoteCommit,\n\t\tRemoteCommitment:        remoteCommit,\n\t\tDb:                      dbRemote.ChannelStateDB(),\n\t\tPackager:                channeldb.NewChannelPackager(shortChanID),\n\t\tFundingTxn:              tc.fundingTx.MsgTx(),\n\t}\n\tlocalChannelState := &channeldb.OpenChannel{\n\t\tLocalChanCfg:            localCfg,\n\t\tRemoteChanCfg:           remoteCfg,\n\t\tIdentityPub:             localDummy2.PubKey(),\n\t\tFundingOutpoint:         *prevOut,\n\t\tShortChannelID:          shortChanID,\n\t\tChanType:                chanType,\n\t\tIsInitiator:             true,\n\t\tCapacity:                tc.fundingAmount,\n\t\tRemoteCurrentRevocation: remoteCommitPoint,\n\t\tRevocationProducer:      localPreimageProducer,\n\t\tRevocationStore:         shachain.NewRevocationStore(),\n\t\tLocalCommitment:         localCommit,\n\t\tRemoteCommitment:        localCommit,\n\t\tDb:                      dbLocal.ChannelStateDB(),\n\t\tPackager:                channeldb.NewChannelPackager(shortChanID),\n\t\tFundingTxn:              tc.fundingTx.MsgTx(),\n\t}\n\n\t// Create mock signers that can sign for the keys that are used.\n\tlocalSigner := &input.MockSigner{Privkeys: []*btcec.PrivateKey{\n\t\ttc.localPaymentBasepointSecret, tc.localDelayedPaymentBasepointSecret,\n\t\ttc.localFundingPrivkey, localDummy1, localDummy2,\n\t}}\n\n\tremoteSigner := &input.MockSigner{Privkeys: []*btcec.PrivateKey{\n\t\ttc.remoteFundingPrivkey, tc.remoteRevocationBasepointSecret,\n\t\ttc.remotePaymentBasepointSecret, remoteDummy1, remoteDummy2,\n\t}}\n\n\tremotePool := NewSigPool(1, remoteSigner)\n\tchannelRemote, err := NewLightningChannel(\n\t\tremoteSigner, remoteChannelState, remotePool,\n\t)\n\trequire.NoError(t, err)\n\trequire.NoError(t, remotePool.Start())\n\n\tlocalPool := NewSigPool(1, localSigner)\n\tchannelLocal, err := NewLightningChannel(\n\t\tlocalSigner, localChannelState, localPool,\n\t)\n\trequire.NoError(t, err)\n\trequire.NoError(t, localPool.Start())\n\n\t// Create state hunt obfuscator for the commitment transaction.\n\tobfuscator := createStateHintObfuscator(remoteChannelState)\n\terr = SetStateNumHint(\n\t\tremoteCommitTx, commitHeight, obfuscator,\n\t)\n\trequire.NoError(t, err)\n\n\terr = SetStateNumHint(\n\t\tlocalCommitTx, commitHeight, obfuscator,\n\t)\n\trequire.NoError(t, err)\n\n\t// Initialize the database.\n\taddr := &net.TCPAddr{\n\t\tIP:   net.ParseIP(\"127.0.0.1\"),\n\t\tPort: 18556,\n\t}\n\trequire.NoError(t, channelRemote.channelState.SyncPending(addr, 101))\n\n\taddr = &net.TCPAddr{\n\t\tIP:   net.ParseIP(\"127.0.0.1\"),\n\t\tPort: 18555,\n\t}\n\trequire.NoError(t, channelLocal.channelState.SyncPending(addr, 101))\n\n\t// Now that the channel are open, simulate the start of a session by\n\t// having local and remote extend their revocation windows to each other.\n\terr = initRevocationWindows(channelRemote, channelLocal)\n\trequire.NoError(t, err)\n\n\t// Return a clean up function that stops goroutines and removes the test\n\t// databases.\n\tt.Cleanup(func() {\n\t\tdbLocal.Close()\n\t\tdbRemote.Close()\n\n\t\trequire.NoError(t, remotePool.Stop())\n\t\trequire.NoError(t, localPool.Stop())\n\t})\n\n\treturn channelRemote, channelLocal\n}\n",
      "length": 7924,
      "tokens": 626,
      "embedding": []
    }
  ]
}