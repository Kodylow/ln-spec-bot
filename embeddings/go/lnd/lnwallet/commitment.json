{
  "filepath": "../implementations/go/lnd/lnwallet/commitment.go",
  "package": "lnwallet",
  "sections": [
    {
      "slug": "type CommitmentKeyRing struct {",
      "content": "type CommitmentKeyRing struct {\n\t// CommitPoint is the \"per commitment point\" used to derive the tweak\n\t// for each base point.\n\tCommitPoint *btcec.PublicKey\n\n\t// LocalCommitKeyTweak is the tweak used to derive the local public key\n\t// from the local payment base point or the local private key from the\n\t// base point secret. This may be included in a SignDescriptor to\n\t// generate signatures for the local payment key.\n\t//\n\t// NOTE: This will always refer to \"our\" local key, regardless of\n\t// whether this is our commit or not.\n\tLocalCommitKeyTweak []byte\n\n\t// TODO(roasbeef): need delay tweak as well?\n\n\t// LocalHtlcKeyTweak is the tweak used to derive the local HTLC key\n\t// from the local HTLC base point. This value is needed in order to\n\t// derive the final key used within the HTLC scripts in the commitment\n\t// transaction.\n\t//\n\t// NOTE: This will always refer to \"our\" local HTLC key, regardless of\n\t// whether this is our commit or not.\n\tLocalHtlcKeyTweak []byte\n\n\t// LocalHtlcKey is the key that will be used in any clause paying to\n\t// our node of any HTLC scripts within the commitment transaction for\n\t// this key ring set.\n\t//\n\t// NOTE: This will always refer to \"our\" local HTLC key, regardless of\n\t// whether this is our commit or not.\n\tLocalHtlcKey *btcec.PublicKey\n\n\t// RemoteHtlcKey is the key that will be used in clauses within the\n\t// HTLC script that send money to the remote party.\n\t//\n\t// NOTE: This will always refer to \"their\" remote HTLC key, regardless\n\t// of whether this is our commit or not.\n\tRemoteHtlcKey *btcec.PublicKey\n\n\t// ToLocalKey is the commitment transaction owner's key which is\n\t// included in HTLC success and timeout transaction scripts. This is\n\t// the public key used for the to_local output of the commitment\n\t// transaction.\n\t//\n\t// NOTE: Who's key this is depends on the current perspective. If this\n\t// is our commitment this will be our key.\n\tToLocalKey *btcec.PublicKey\n\n\t// ToRemoteKey is the non-owner's payment key in the commitment tx.\n\t// This is the key used to generate the to_remote output within the\n\t// commitment transaction.\n\t//\n\t// NOTE: Who's key this is depends on the current perspective. If this\n\t// is our commitment this will be their key.\n\tToRemoteKey *btcec.PublicKey\n\n\t// RevocationKey is the key that can be used by the other party to\n\t// redeem outputs from a revoked commitment transaction if it were to\n\t// be published.\n\t//\n\t// NOTE: Who can sign for this key depends on the current perspective.\n\t// If this is our commitment, it means the remote node can sign for\n\t// this key in case of a breach.\n\tRevocationKey *btcec.PublicKey\n}\n\n// DeriveCommitmentKeys generates a new commitment key set using the base points\n// and commitment point. The keys are derived differently depending on the type\n// of channel, and whether the commitment transaction is ours or the remote\n// peer's.",
      "length": 2766,
      "tokens": 482,
      "embedding": []
    },
    {
      "slug": "func DeriveCommitmentKeys(commitPoint *btcec.PublicKey,",
      "content": "func DeriveCommitmentKeys(commitPoint *btcec.PublicKey,\n\tisOurCommit bool, chanType channeldb.ChannelType,\n\tlocalChanCfg, remoteChanCfg *channeldb.ChannelConfig) *CommitmentKeyRing {\n\n\ttweaklessCommit := chanType.IsTweakless()\n\n\t// Depending on if this is our commit or not, we'll choose the correct\n\t// base point.\n\tlocalBasePoint := localChanCfg.PaymentBasePoint\n\tif isOurCommit {\n\t\tlocalBasePoint = localChanCfg.DelayBasePoint\n\t}\n\n\t// First, we'll derive all the keys that don't depend on the context of\n\t// whose commitment transaction this is.\n\tkeyRing := &CommitmentKeyRing{\n\t\tCommitPoint: commitPoint,\n\n\t\tLocalCommitKeyTweak: input.SingleTweakBytes(\n\t\t\tcommitPoint, localBasePoint.PubKey,\n\t\t),\n\t\tLocalHtlcKeyTweak: input.SingleTweakBytes(\n\t\t\tcommitPoint, localChanCfg.HtlcBasePoint.PubKey,\n\t\t),\n\t\tLocalHtlcKey: input.TweakPubKey(\n\t\t\tlocalChanCfg.HtlcBasePoint.PubKey, commitPoint,\n\t\t),\n\t\tRemoteHtlcKey: input.TweakPubKey(\n\t\t\tremoteChanCfg.HtlcBasePoint.PubKey, commitPoint,\n\t\t),\n\t}\n\n\t// We'll now compute the to_local, to_remote, and revocation key based\n\t// on the current commitment point. All keys are tweaked each state in\n\t// order to ensure the keys from each state are unlinkable. To create\n\t// the revocation key, we take the opposite party's revocation base\n\t// point and combine that with the current commitment point.\n\tvar (\n\t\ttoLocalBasePoint    *btcec.PublicKey\n\t\ttoRemoteBasePoint   *btcec.PublicKey\n\t\trevocationBasePoint *btcec.PublicKey\n\t)\n\tif isOurCommit {\n\t\ttoLocalBasePoint = localChanCfg.DelayBasePoint.PubKey\n\t\ttoRemoteBasePoint = remoteChanCfg.PaymentBasePoint.PubKey\n\t\trevocationBasePoint = remoteChanCfg.RevocationBasePoint.PubKey\n\t} else {\n\t\ttoLocalBasePoint = remoteChanCfg.DelayBasePoint.PubKey\n\t\ttoRemoteBasePoint = localChanCfg.PaymentBasePoint.PubKey\n\t\trevocationBasePoint = localChanCfg.RevocationBasePoint.PubKey\n\t}\n\n\t// With the base points assigned, we can now derive the actual keys\n\t// using the base point, and the current commitment tweak.\n\tkeyRing.ToLocalKey = input.TweakPubKey(toLocalBasePoint, commitPoint)\n\tkeyRing.RevocationKey = input.DeriveRevocationPubkey(\n\t\trevocationBasePoint, commitPoint,\n\t)\n\n\t// If this commitment should omit the tweak for the remote point, then\n\t// we'll use that directly, and ignore the commitPoint tweak.\n\tif tweaklessCommit {\n\t\tkeyRing.ToRemoteKey = toRemoteBasePoint\n\n\t\t// If this is not our commitment, the above ToRemoteKey will be\n\t\t// ours, and we blank out the local commitment tweak to\n\t\t// indicate that the key should not be tweaked when signing.\n\t\tif !isOurCommit {\n\t\t\tkeyRing.LocalCommitKeyTweak = nil\n\t\t}\n\t} else {\n\t\tkeyRing.ToRemoteKey = input.TweakPubKey(\n\t\t\ttoRemoteBasePoint, commitPoint,\n\t\t)\n\t}\n\n\treturn keyRing\n}\n\n// ScriptInfo holds a redeem script and hash.",
      "length": 2625,
      "tokens": 301,
      "embedding": []
    },
    {
      "slug": "type ScriptInfo struct {",
      "content": "type ScriptInfo struct {\n\t// PkScript is the output's PkScript.\n\tPkScript []byte\n\n\t// WitnessScript is the full script required to properly redeem the\n\t// output. This field should be set to the full script if a p2wsh\n\t// output is being signed. For p2wkh it should be set equal to the\n\t// PkScript.\n\tWitnessScript []byte\n}\n\n// CommitScriptToSelf constructs the public key script for the output on the\n// commitment transaction paying to the \"owner\" of said commitment transaction.\n// The `initiator` argument should correspond to the owner of the commitment\n// transaction which we are generating the to_local script for. If the other\n// party learns of the preimage to the revocation hash, then they can claim all\n// the settled funds in the channel, plus the unsettled funds.",
      "length": 738,
      "tokens": 126,
      "embedding": []
    },
    {
      "slug": "func CommitScriptToSelf(chanType channeldb.ChannelType, initiator bool,",
      "content": "func CommitScriptToSelf(chanType channeldb.ChannelType, initiator bool,\n\tselfKey, revokeKey *btcec.PublicKey, csvDelay, leaseExpiry uint32) (\n\t*ScriptInfo, error) {\n\n\tvar (\n\t\ttoLocalRedeemScript []byte\n\t\terr                 error\n\t)\n\tswitch {\n\t// If we are the initiator of a leased channel, then we have an\n\t// additional CLTV requirement in addition to the usual CSV requirement.\n\tcase initiator && chanType.HasLeaseExpiration():\n\t\ttoLocalRedeemScript, err = input.LeaseCommitScriptToSelf(\n\t\t\tselfKey, revokeKey, csvDelay, leaseExpiry,\n\t\t)\n\n\tdefault:\n\t\ttoLocalRedeemScript, err = input.CommitScriptToSelf(\n\t\t\tcsvDelay, selfKey, revokeKey,\n\t\t)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ttoLocalScriptHash, err := input.WitnessScriptHash(toLocalRedeemScript)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &ScriptInfo{\n\t\tPkScript:      toLocalScriptHash,\n\t\tWitnessScript: toLocalRedeemScript,\n\t}, nil\n}\n\n// CommitScriptToRemote derives the appropriate to_remote script based on the\n// channel's commitment type. The `initiator` argument should correspond to the\n// owner of the commitment transaction which we are generating the to_remote\n// script for. The second return value is the CSV delay of the output script,\n// what must be satisfied in order to spend the output.",
      "length": 1161,
      "tokens": 157,
      "embedding": []
    },
    {
      "slug": "func CommitScriptToRemote(chanType channeldb.ChannelType, initiator bool,",
      "content": "func CommitScriptToRemote(chanType channeldb.ChannelType, initiator bool,\n\tkey *btcec.PublicKey, leaseExpiry uint32) (*ScriptInfo, uint32, error) {\n\n\tswitch {\n\t// If we are not the initiator of a leased channel, then the remote\n\t// party has an additional CLTV requirement in addition to the 1 block\n\t// CSV requirement.\n\tcase chanType.HasLeaseExpiration() && !initiator:\n\t\tscript, err := input.LeaseCommitScriptToRemoteConfirmed(\n\t\t\tkey, leaseExpiry,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, 0, err\n\t\t}\n\n\t\tp2wsh, err := input.WitnessScriptHash(script)\n\t\tif err != nil {\n\t\t\treturn nil, 0, err\n\t\t}\n\n\t\treturn &ScriptInfo{\n\t\t\tPkScript:      p2wsh,\n\t\t\tWitnessScript: script,\n\t\t}, 1, nil\n\n\t// If this channel type has anchors, we derive the delayed to_remote\n\t// script.\n\tcase chanType.HasAnchors():\n\t\tscript, err := input.CommitScriptToRemoteConfirmed(key)\n\t\tif err != nil {\n\t\t\treturn nil, 0, err\n\t\t}\n\n\t\tp2wsh, err := input.WitnessScriptHash(script)\n\t\tif err != nil {\n\t\t\treturn nil, 0, err\n\t\t}\n\n\t\treturn &ScriptInfo{\n\t\t\tPkScript:      p2wsh,\n\t\t\tWitnessScript: script,\n\t\t}, 1, nil\n\n\tdefault:\n\t\t// Otherwise the to_remote will be a simple p2wkh.\n\t\tp2wkh, err := input.CommitScriptUnencumbered(key)\n\t\tif err != nil {\n\t\t\treturn nil, 0, err\n\t\t}\n\n\t\t// Since this is a regular P2WKH, the WitnessScipt and PkScript\n\t\t// should both be set to the script hash.\n\t\treturn &ScriptInfo{\n\t\t\tWitnessScript: p2wkh,\n\t\t\tPkScript:      p2wkh,\n\t\t}, 0, nil\n\t}\n}\n\n// HtlcSigHashType returns the sighash type to use for HTLC success and timeout\n// transactions given the channel type.",
      "length": 1419,
      "tokens": 211,
      "embedding": []
    },
    {
      "slug": "func HtlcSigHashType(chanType channeldb.ChannelType) txscript.SigHashType {",
      "content": "func HtlcSigHashType(chanType channeldb.ChannelType) txscript.SigHashType {\n\tif chanType.HasAnchors() {\n\t\treturn txscript.SigHashSingle | txscript.SigHashAnyOneCanPay\n\t}\n\n\treturn txscript.SigHashAll\n}\n\n// HtlcSignDetails converts the passed parameters to a SignDetails valid for\n// this channel type. For non-anchor channels this will return nil.",
      "length": 262,
      "tokens": 33,
      "embedding": []
    },
    {
      "slug": "func HtlcSignDetails(chanType channeldb.ChannelType, signDesc input.SignDescriptor,",
      "content": "func HtlcSignDetails(chanType channeldb.ChannelType, signDesc input.SignDescriptor,\n\tsigHash txscript.SigHashType, peerSig input.Signature) *input.SignDetails {\n\n\t// Non-anchor channels don't need sign details, as the HTLC second\n\t// level cannot be altered.\n\tif !chanType.HasAnchors() {\n\t\treturn nil\n\t}\n\n\treturn &input.SignDetails{\n\t\tSignDesc:    signDesc,\n\t\tSigHashType: sigHash,\n\t\tPeerSig:     peerSig,\n\t}\n}\n\n// HtlcSecondLevelInputSequence dictates the sequence number we must use on the\n// input to a second level HTLC transaction.",
      "length": 436,
      "tokens": 57,
      "embedding": []
    },
    {
      "slug": "func HtlcSecondLevelInputSequence(chanType channeldb.ChannelType) uint32 {",
      "content": "func HtlcSecondLevelInputSequence(chanType channeldb.ChannelType) uint32 {\n\tif chanType.HasAnchors() {\n\t\treturn 1\n\t}\n\n\treturn 0\n}\n\n// SecondLevelHtlcScript derives the appropriate second level HTLC script based\n// on the channel's commitment type. It is the uniform script that's used as the\n// output for the second-level HTLC transactions. The second level transaction\n// act as a sort of covenant, ensuring that a 2-of-2 multi-sig output can only\n// be spent in a particular way, and to a particular output. The `initiator`\n// argument should correspond to the owner of the commitment transaction which\n// we are generating the to_local script for.",
      "length": 563,
      "tokens": 94,
      "embedding": []
    },
    {
      "slug": "func SecondLevelHtlcScript(chanType channeldb.ChannelType, initiator bool,",
      "content": "func SecondLevelHtlcScript(chanType channeldb.ChannelType, initiator bool,\n\trevocationKey, delayKey *btcec.PublicKey,\n\tcsvDelay, leaseExpiry uint32) (*ScriptInfo, error) {\n\n\tvar (\n\t\twitnessScript []byte\n\t\terr           error\n\t)\n\tswitch {\n\t// If we are the initiator of a leased channel, then we have an\n\t// additional CLTV requirement in addition to the usual CSV requirement.\n\tcase initiator && chanType.HasLeaseExpiration():\n\t\twitnessScript, err = input.LeaseSecondLevelHtlcScript(\n\t\t\trevocationKey, delayKey, csvDelay, leaseExpiry,\n\t\t)\n\n\tdefault:\n\t\twitnessScript, err = input.SecondLevelHtlcScript(\n\t\t\trevocationKey, delayKey, csvDelay,\n\t\t)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpkScript, err := input.WitnessScriptHash(witnessScript)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &ScriptInfo{\n\t\tPkScript:      pkScript,\n\t\tWitnessScript: witnessScript,\n\t}, nil\n}\n\n// CommitWeight returns the base commitment weight before adding HTLCs.",
      "length": 834,
      "tokens": 107,
      "embedding": []
    },
    {
      "slug": "func CommitWeight(chanType channeldb.ChannelType) int64 {",
      "content": "func CommitWeight(chanType channeldb.ChannelType) int64 {\n\t// If this commitment has anchors, it will be slightly heavier.\n\tif chanType.HasAnchors() {\n\t\treturn input.AnchorCommitWeight\n\t}\n\n\treturn input.CommitWeight\n}\n\n// HtlcTimeoutFee returns the fee in satoshis required for an HTLC timeout\n// transaction based on the current fee rate.",
      "length": 272,
      "tokens": 40,
      "embedding": []
    },
    {
      "slug": "func HtlcTimeoutFee(chanType channeldb.ChannelType,",
      "content": "func HtlcTimeoutFee(chanType channeldb.ChannelType,\n\tfeePerKw chainfee.SatPerKWeight) btcutil.Amount {\n\n\t// For zero-fee HTLC channels, this will always be zero, regardless of\n\t// feerate.\n\tif chanType.ZeroHtlcTxFee() {\n\t\treturn 0\n\t}\n\n\tif chanType.HasAnchors() {\n\t\treturn feePerKw.FeeForWeight(input.HtlcTimeoutWeightConfirmed)\n\t}\n\n\treturn feePerKw.FeeForWeight(input.HtlcTimeoutWeight)\n}\n\n// HtlcSuccessFee returns the fee in satoshis required for an HTLC success\n// transaction based on the current fee rate.",
      "length": 442,
      "tokens": 53,
      "embedding": []
    },
    {
      "slug": "func HtlcSuccessFee(chanType channeldb.ChannelType,",
      "content": "func HtlcSuccessFee(chanType channeldb.ChannelType,\n\tfeePerKw chainfee.SatPerKWeight) btcutil.Amount {\n\n\t// For zero-fee HTLC channels, this will always be zero, regardless of\n\t// feerate.\n\tif chanType.ZeroHtlcTxFee() {\n\t\treturn 0\n\t}\n\n\tif chanType.HasAnchors() {\n\t\treturn feePerKw.FeeForWeight(input.HtlcSuccessWeightConfirmed)\n\t}\n\treturn feePerKw.FeeForWeight(input.HtlcSuccessWeight)\n}\n\n// CommitScriptAnchors return the scripts to use for the local and remote\n// anchor.",
      "length": 406,
      "tokens": 47,
      "embedding": []
    },
    {
      "slug": "func CommitScriptAnchors(localChanCfg,",
      "content": "func CommitScriptAnchors(localChanCfg,\n\tremoteChanCfg *channeldb.ChannelConfig) (*ScriptInfo,\n\t*ScriptInfo, error) {\n\n\t// Helper to create anchor ScriptInfo from key.\n\tanchorScript := func(key *btcec.PublicKey) (*ScriptInfo, error) {\n\t\tscript, err := input.CommitScriptAnchor(key)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tscriptHash, err := input.WitnessScriptHash(script)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn &ScriptInfo{\n\t\t\tPkScript:      scriptHash,\n\t\t\tWitnessScript: script,\n\t\t}, nil\n\t}\n\n\t// Get the script used for the anchor output spendable by the local\n\t// node.\n\tlocalAnchor, err := anchorScript(localChanCfg.MultiSigKey.PubKey)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// And the anchor spendable by the remote node.\n\tremoteAnchor, err := anchorScript(remoteChanCfg.MultiSigKey.PubKey)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn localAnchor, remoteAnchor, nil\n}\n\n// CommitmentBuilder is a type that wraps the type of channel we are dealing\n// with, and abstracts the various ways of constructing commitment\n// transactions.",
      "length": 985,
      "tokens": 139,
      "embedding": []
    },
    {
      "slug": "type CommitmentBuilder struct {",
      "content": "type CommitmentBuilder struct {\n\t// chanState is the underlying channels's state struct, used to\n\t// determine the type of channel we are dealing with, and relevant\n\t// parameters.\n\tchanState *channeldb.OpenChannel\n\n\t// obfuscator is a 48-bit state hint that's used to obfuscate the\n\t// current state number on the commitment transactions.\n\tobfuscator [StateHintSize]byte\n}\n\n// NewCommitmentBuilder creates a new CommitmentBuilder from chanState.",
      "length": 404,
      "tokens": 57,
      "embedding": []
    },
    {
      "slug": "func NewCommitmentBuilder(chanState *channeldb.OpenChannel) *CommitmentBuilder {",
      "content": "func NewCommitmentBuilder(chanState *channeldb.OpenChannel) *CommitmentBuilder {\n\t// The anchor channel type MUST be tweakless.\n\tif chanState.ChanType.HasAnchors() && !chanState.ChanType.IsTweakless() {\n\t\tpanic(\"invalid channel type combination\")\n\t}\n\n\treturn &CommitmentBuilder{\n\t\tchanState:  chanState,\n\t\tobfuscator: createStateHintObfuscator(chanState),\n\t}\n}\n\n// createStateHintObfuscator derives and assigns the state hint obfuscator for\n// the channel, which is used to encode the commitment height in the sequence\n// number of commitment transaction inputs.",
      "length": 468,
      "tokens": 56,
      "embedding": []
    },
    {
      "slug": "func createStateHintObfuscator(state *channeldb.OpenChannel) [StateHintSize]byte {",
      "content": "func createStateHintObfuscator(state *channeldb.OpenChannel) [StateHintSize]byte {\n\tif state.IsInitiator {\n\t\treturn DeriveStateHintObfuscator(\n\t\t\tstate.LocalChanCfg.PaymentBasePoint.PubKey,\n\t\t\tstate.RemoteChanCfg.PaymentBasePoint.PubKey,\n\t\t)\n\t}\n\n\treturn DeriveStateHintObfuscator(\n\t\tstate.RemoteChanCfg.PaymentBasePoint.PubKey,\n\t\tstate.LocalChanCfg.PaymentBasePoint.PubKey,\n\t)\n}\n\n// unsignedCommitmentTx is the final commitment created from evaluating an HTLC\n// view at a given height, along with some meta data.",
      "length": 416,
      "tokens": 37,
      "embedding": []
    },
    {
      "slug": "type unsignedCommitmentTx struct {",
      "content": "type unsignedCommitmentTx struct {\n\t// txn is the final, unsigned commitment transaction for this view.\n\ttxn *wire.MsgTx\n\n\t// fee is the total fee of the commitment transaction.\n\tfee btcutil.Amount\n\n\t// ourBalance is our balance on this commitment *after* subtracting\n\t// commitment fees and anchor outputs. This can be different than the\n\t// balances before creating the commitment transaction as one party must\n\t// pay the commitment fee.\n\tourBalance lnwire.MilliSatoshi\n\n\t// theirBalance is their balance of this commitment *after* subtracting\n\t// commitment fees and anchor outputs. This can be different than the\n\t// balances before creating the commitment transaction as one party must\n\t// pay the commitment fee.\n\ttheirBalance lnwire.MilliSatoshi\n\n\t// cltvs is a sorted list of CLTV deltas for each HTLC on the commitment\n\t// transaction. Any non-htlc outputs will have a CLTV delay of zero.\n\tcltvs []uint32\n}\n\n// createUnsignedCommitmentTx generates the unsigned commitment transaction for\n// a commitment view and returns it as part of the unsignedCommitmentTx. The\n// passed in balances should be balances *before* subtracting any commitment\n// fees, but after anchor outputs.",
      "length": 1125,
      "tokens": 173,
      "embedding": []
    },
    {
      "slug": "func (cb *CommitmentBuilder) createUnsignedCommitmentTx(ourBalance,",
      "content": "func (cb *CommitmentBuilder) createUnsignedCommitmentTx(ourBalance,\n\ttheirBalance lnwire.MilliSatoshi, isOurs bool,\n\tfeePerKw chainfee.SatPerKWeight, height uint64,\n\tfilteredHTLCView *htlcView,\n\tkeyRing *CommitmentKeyRing) (*unsignedCommitmentTx, error) {\n\n\tdustLimit := cb.chanState.LocalChanCfg.DustLimit\n\tif !isOurs {\n\t\tdustLimit = cb.chanState.RemoteChanCfg.DustLimit\n\t}\n\n\tnumHTLCs := int64(0)\n\tfor _, htlc := range filteredHTLCView.ourUpdates {\n\t\tif HtlcIsDust(\n\t\t\tcb.chanState.ChanType, false, isOurs, feePerKw,\n\t\t\thtlc.Amount.ToSatoshis(), dustLimit,\n\t\t) {\n\n\t\t\tcontinue\n\t\t}\n\n\t\tnumHTLCs++\n\t}\n\tfor _, htlc := range filteredHTLCView.theirUpdates {\n\t\tif HtlcIsDust(\n\t\t\tcb.chanState.ChanType, true, isOurs, feePerKw,\n\t\t\thtlc.Amount.ToSatoshis(), dustLimit,\n\t\t) {\n\n\t\t\tcontinue\n\t\t}\n\n\t\tnumHTLCs++\n\t}\n\n\t// Next, we'll calculate the fee for the commitment transaction based\n\t// on its total weight. Once we have the total weight, we'll multiply\n\t// by the current fee-per-kw, then divide by 1000 to get the proper\n\t// fee.\n\ttotalCommitWeight := CommitWeight(cb.chanState.ChanType) +\n\t\tinput.HTLCWeight*numHTLCs\n\n\t// With the weight known, we can now calculate the commitment fee,\n\t// ensuring that we account for any dust outputs trimmed above.\n\tcommitFee := feePerKw.FeeForWeight(totalCommitWeight)\n\tcommitFeeMSat := lnwire.NewMSatFromSatoshis(commitFee)\n\n\t// Currently, within the protocol, the initiator always pays the fees.\n\t// So we'll subtract the fee amount from the balance of the current\n\t// initiator. If the initiator is unable to pay the fee fully, then\n\t// their entire output is consumed.\n\tswitch {\n\tcase cb.chanState.IsInitiator && commitFee > ourBalance.ToSatoshis():\n\t\tourBalance = 0\n\n\tcase cb.chanState.IsInitiator:\n\t\tourBalance -= commitFeeMSat\n\n\tcase !cb.chanState.IsInitiator && commitFee > theirBalance.ToSatoshis():\n\t\ttheirBalance = 0\n\n\tcase !cb.chanState.IsInitiator:\n\t\ttheirBalance -= commitFeeMSat\n\t}\n\n\tvar (\n\t\tcommitTx *wire.MsgTx\n\t\terr      error\n\t)\n\n\t// Depending on whether the transaction is ours or not, we call\n\t// CreateCommitTx with parameters matching the perspective, to generate\n\t// a new commitment transaction with all the latest unsettled/un-timed\n\t// out HTLCs.\n\tvar leaseExpiry uint32\n\tif cb.chanState.ChanType.HasLeaseExpiration() {\n\t\tleaseExpiry = cb.chanState.ThawHeight\n\t}\n\tif isOurs {\n\t\tcommitTx, err = CreateCommitTx(\n\t\t\tcb.chanState.ChanType, fundingTxIn(cb.chanState), keyRing,\n\t\t\t&cb.chanState.LocalChanCfg, &cb.chanState.RemoteChanCfg,\n\t\t\tourBalance.ToSatoshis(), theirBalance.ToSatoshis(),\n\t\t\tnumHTLCs, cb.chanState.IsInitiator, leaseExpiry,\n\t\t)\n\t} else {\n\t\tcommitTx, err = CreateCommitTx(\n\t\t\tcb.chanState.ChanType, fundingTxIn(cb.chanState), keyRing,\n\t\t\t&cb.chanState.RemoteChanCfg, &cb.chanState.LocalChanCfg,\n\t\t\ttheirBalance.ToSatoshis(), ourBalance.ToSatoshis(),\n\t\t\tnumHTLCs, !cb.chanState.IsInitiator, leaseExpiry,\n\t\t)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// We'll now add all the HTLC outputs to the commitment transaction.\n\t// Each output includes an off-chain 2-of-2 covenant clause, so we'll\n\t// need the objective local/remote keys for this particular commitment\n\t// as well. For any non-dust HTLCs that are manifested on the commitment\n\t// transaction, we'll also record its CLTV which is required to sort the\n\t// commitment transaction below. The slice is initially sized to the\n\t// number of existing outputs, since any outputs already added are\n\t// commitment outputs and should correspond to zero values for the\n\t// purposes of sorting.\n\tcltvs := make([]uint32, len(commitTx.TxOut))\n\tfor _, htlc := range filteredHTLCView.ourUpdates {\n\t\tif HtlcIsDust(\n\t\t\tcb.chanState.ChanType, false, isOurs, feePerKw,\n\t\t\thtlc.Amount.ToSatoshis(), dustLimit,\n\t\t) {\n\n\t\t\tcontinue\n\t\t}\n\n\t\terr := addHTLC(\n\t\t\tcommitTx, isOurs, false, htlc, keyRing,\n\t\t\tcb.chanState.ChanType,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tcltvs = append(cltvs, htlc.Timeout) // nolint:makezero\n\t}\n\tfor _, htlc := range filteredHTLCView.theirUpdates {\n\t\tif HtlcIsDust(\n\t\t\tcb.chanState.ChanType, true, isOurs, feePerKw,\n\t\t\thtlc.Amount.ToSatoshis(), dustLimit,\n\t\t) {\n\n\t\t\tcontinue\n\t\t}\n\n\t\terr := addHTLC(\n\t\t\tcommitTx, isOurs, true, htlc, keyRing,\n\t\t\tcb.chanState.ChanType,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tcltvs = append(cltvs, htlc.Timeout) // nolint:makezero\n\t}\n\n\t// Set the state hint of the commitment transaction to facilitate\n\t// quickly recovering the necessary penalty state in the case of an\n\t// uncooperative broadcast.\n\terr = SetStateNumHint(commitTx, height, cb.obfuscator)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Sort the transactions according to the agreed upon canonical\n\t// ordering. This lets us skip sending the entire transaction over,\n\t// instead we'll just send signatures.\n\tInPlaceCommitSort(commitTx, cltvs)\n\n\t// Next, we'll ensure that we don't accidentally create a commitment\n\t// transaction which would be invalid by consensus.\n\tuTx := btcutil.NewTx(commitTx)\n\tif err := blockchain.CheckTransactionSanity(uTx); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Finally, we'll assert that were not attempting to draw more out of\n\t// the channel that was originally placed within it.\n\tvar totalOut btcutil.Amount\n\tfor _, txOut := range commitTx.TxOut {\n\t\ttotalOut += btcutil.Amount(txOut.Value)\n\t}\n\tif totalOut+commitFee > cb.chanState.Capacity {\n\t\treturn nil, fmt.Errorf(\"height=%v, for ChannelPoint(%v) \"+\n\t\t\t\"attempts to consume %v while channel capacity is %v\",\n\t\t\theight, cb.chanState.FundingOutpoint,\n\t\t\ttotalOut+commitFee, cb.chanState.Capacity)\n\t}\n\n\treturn &unsignedCommitmentTx{\n\t\ttxn:          commitTx,\n\t\tfee:          commitFee,\n\t\tourBalance:   ourBalance,\n\t\ttheirBalance: theirBalance,\n\t\tcltvs:        cltvs,\n\t}, nil\n}\n\n// CreateCommitTx creates a commitment transaction, spending from specified\n// funding output. The commitment transaction contains two outputs: one local\n// output paying to the \"owner\" of the commitment transaction which can be\n// spent after a relative block delay or revocation event, and a remote output\n// paying the counterparty within the channel, which can be spent immediately\n// or after a delay depending on the commitment type. The `initiator` argument\n// should correspond to the owner of the commitment transaction we are creating.",
      "length": 5981,
      "tokens": 768,
      "embedding": []
    },
    {
      "slug": "func CreateCommitTx(chanType channeldb.ChannelType,",
      "content": "func CreateCommitTx(chanType channeldb.ChannelType,\n\tfundingOutput wire.TxIn, keyRing *CommitmentKeyRing,\n\tlocalChanCfg, remoteChanCfg *channeldb.ChannelConfig,\n\tamountToLocal, amountToRemote btcutil.Amount,\n\tnumHTLCs int64, initiator bool, leaseExpiry uint32) (*wire.MsgTx, error) {\n\n\t// First, we create the script for the delayed \"pay-to-self\" output.\n\t// This output has 2 main redemption clauses: either we can redeem the\n\t// output after a relative block delay, or the remote node can claim\n\t// the funds with the revocation key if we broadcast a revoked\n\t// commitment transaction.\n\ttoLocalScript, err := CommitScriptToSelf(\n\t\tchanType, initiator, keyRing.ToLocalKey, keyRing.RevocationKey,\n\t\tuint32(localChanCfg.CsvDelay), leaseExpiry,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Next, we create the script paying to the remote.\n\ttoRemoteScript, _, err := CommitScriptToRemote(\n\t\tchanType, initiator, keyRing.ToRemoteKey, leaseExpiry,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Now that both output scripts have been created, we can finally create\n\t// the transaction itself. We use a transaction version of 2 since CSV\n\t// will fail unless the tx version is >= 2.\n\tcommitTx := wire.NewMsgTx(2)\n\tcommitTx.AddTxIn(&fundingOutput)\n\n\t// Avoid creating dust outputs within the commitment transaction.\n\tlocalOutput := amountToLocal >= localChanCfg.DustLimit\n\tif localOutput {\n\t\tcommitTx.AddTxOut(&wire.TxOut{\n\t\t\tPkScript: toLocalScript.PkScript,\n\t\t\tValue:    int64(amountToLocal),\n\t\t})\n\t}\n\n\tremoteOutput := amountToRemote >= localChanCfg.DustLimit\n\tif remoteOutput {\n\t\tcommitTx.AddTxOut(&wire.TxOut{\n\t\t\tPkScript: toRemoteScript.PkScript,\n\t\t\tValue:    int64(amountToRemote),\n\t\t})\n\t}\n\n\t// If this channel type has anchors, we'll also add those.\n\tif chanType.HasAnchors() {\n\t\tlocalAnchor, remoteAnchor, err := CommitScriptAnchors(\n\t\t\tlocalChanCfg, remoteChanCfg,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Add local anchor output only if we have a commitment output\n\t\t// or there are HTLCs.\n\t\tif localOutput || numHTLCs > 0 {\n\t\t\tcommitTx.AddTxOut(&wire.TxOut{\n\t\t\t\tPkScript: localAnchor.PkScript,\n\t\t\t\tValue:    int64(anchorSize),\n\t\t\t})\n\t\t}\n\n\t\t// Add anchor output to remote only if they have a commitment\n\t\t// output or there are HTLCs.\n\t\tif remoteOutput || numHTLCs > 0 {\n\t\t\tcommitTx.AddTxOut(&wire.TxOut{\n\t\t\t\tPkScript: remoteAnchor.PkScript,\n\t\t\t\tValue:    int64(anchorSize),\n\t\t\t})\n\t\t}\n\t}\n\n\treturn commitTx, nil\n}\n\n// CoopCloseBalance returns the final balances that should be used to create\n// the cooperative close tx, given the channel type and transaction fee.",
      "length": 2444,
      "tokens": 322,
      "embedding": []
    },
    {
      "slug": "func CoopCloseBalance(chanType channeldb.ChannelType, isInitiator bool,",
      "content": "func CoopCloseBalance(chanType channeldb.ChannelType, isInitiator bool,\n\tcoopCloseFee btcutil.Amount, localCommit channeldb.ChannelCommitment) (\n\tbtcutil.Amount, btcutil.Amount, error) {\n\n\t// Get both parties' balances from the latest commitment.\n\tourBalance := localCommit.LocalBalance.ToSatoshis()\n\ttheirBalance := localCommit.RemoteBalance.ToSatoshis()\n\n\t// We'll make sure we account for the complete balance by adding the\n\t// current dangling commitment fee to the balance of the initiator.\n\tinitiatorDelta := localCommit.CommitFee\n\n\t// Since the initiator's balance also is stored after subtracting the\n\t// anchor values, add that back in case this was an anchor commitment.\n\tif chanType.HasAnchors() {\n\t\tinitiatorDelta += 2 * anchorSize\n\t}\n\n\t// The initiator will pay the full coop close fee, subtract that value\n\t// from their balance.\n\tinitiatorDelta -= coopCloseFee\n\n\tif isInitiator {\n\t\tourBalance += initiatorDelta\n\t} else {\n\t\ttheirBalance += initiatorDelta\n\t}\n\n\t// During fee negotiation it should always be verified that the\n\t// initiator can pay the proposed fee, but we do a sanity check just to\n\t// be sure here.\n\tif ourBalance < 0 || theirBalance < 0 {\n\t\treturn 0, 0, fmt.Errorf(\"initiator cannot afford proposed \" +\n\t\t\t\"coop close fee\")\n\t}\n\n\treturn ourBalance, theirBalance, nil\n}\n\n// genHtlcScript generates the proper P2WSH public key scripts for the HTLC\n// output modified by two-bits denoting if this is an incoming HTLC, and if the\n// HTLC is being applied to their commitment transaction or ours.",
      "length": 1409,
      "tokens": 212,
      "embedding": []
    },
    {
      "slug": "func genHtlcScript(chanType channeldb.ChannelType, isIncoming, ourCommit bool,",
      "content": "func genHtlcScript(chanType channeldb.ChannelType, isIncoming, ourCommit bool,\n\ttimeout uint32, rHash [32]byte,\n\tkeyRing *CommitmentKeyRing) ([]byte, []byte, error) {\n\n\tvar (\n\t\twitnessScript []byte\n\t\terr           error\n\t)\n\n\t// Choose scripts based on channel type.\n\tconfirmedHtlcSpends := false\n\tif chanType.HasAnchors() {\n\t\tconfirmedHtlcSpends = true\n\t}\n\n\t// Generate the proper redeem scripts for the HTLC output modified by\n\t// two-bits denoting if this is an incoming HTLC, and if the HTLC is\n\t// being applied to their commitment transaction or ours.\n\tswitch {\n\t// The HTLC is paying to us, and being applied to our commitment\n\t// transaction. So we need to use the receiver's version of HTLC the\n\t// script.\n\tcase isIncoming && ourCommit:\n\t\twitnessScript, err = input.ReceiverHTLCScript(\n\t\t\ttimeout, keyRing.RemoteHtlcKey, keyRing.LocalHtlcKey,\n\t\t\tkeyRing.RevocationKey, rHash[:], confirmedHtlcSpends,\n\t\t)\n\n\t// We're being paid via an HTLC by the remote party, and the HTLC is\n\t// being added to their commitment transaction, so we use the sender's\n\t// version of the HTLC script.\n\tcase isIncoming && !ourCommit:\n\t\twitnessScript, err = input.SenderHTLCScript(\n\t\t\tkeyRing.RemoteHtlcKey, keyRing.LocalHtlcKey,\n\t\t\tkeyRing.RevocationKey, rHash[:], confirmedHtlcSpends,\n\t\t)\n\n\t// We're sending an HTLC which is being added to our commitment\n\t// transaction. Therefore, we need to use the sender's version of the\n\t// HTLC script.\n\tcase !isIncoming && ourCommit:\n\t\twitnessScript, err = input.SenderHTLCScript(\n\t\t\tkeyRing.LocalHtlcKey, keyRing.RemoteHtlcKey,\n\t\t\tkeyRing.RevocationKey, rHash[:], confirmedHtlcSpends,\n\t\t)\n\n\t// Finally, we're paying the remote party via an HTLC, which is being\n\t// added to their commitment transaction. Therefore, we use the\n\t// receiver's version of the HTLC script.\n\tcase !isIncoming && !ourCommit:\n\t\twitnessScript, err = input.ReceiverHTLCScript(\n\t\t\ttimeout, keyRing.LocalHtlcKey, keyRing.RemoteHtlcKey,\n\t\t\tkeyRing.RevocationKey, rHash[:], confirmedHtlcSpends,\n\t\t)\n\t}\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// Now that we have the redeem scripts, create the P2WSH public key\n\t// script for the output itself.\n\thtlcP2WSH, err := input.WitnessScriptHash(witnessScript)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn htlcP2WSH, witnessScript, nil\n}\n\n// addHTLC adds a new HTLC to the passed commitment transaction. One of four\n// full scripts will be generated for the HTLC output depending on if the HTLC\n// is incoming and if it's being applied to our commitment transaction or that\n// of the remote node's. Additionally, in order to be able to efficiently\n// locate the added HTLC on the commitment transaction from the\n// PaymentDescriptor that generated it, the generated script is stored within\n// the descriptor itself.",
      "length": 2614,
      "tokens": 378,
      "embedding": []
    },
    {
      "slug": "func addHTLC(commitTx *wire.MsgTx, ourCommit bool,",
      "content": "func addHTLC(commitTx *wire.MsgTx, ourCommit bool,\n\tisIncoming bool, paymentDesc *PaymentDescriptor,\n\tkeyRing *CommitmentKeyRing, chanType channeldb.ChannelType) error {\n\n\ttimeout := paymentDesc.Timeout\n\trHash := paymentDesc.RHash\n\n\tp2wsh, witnessScript, err := genHtlcScript(\n\t\tchanType, isIncoming, ourCommit, timeout, rHash, keyRing,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Add the new HTLC outputs to the respective commitment transactions.\n\tamountPending := int64(paymentDesc.Amount.ToSatoshis())\n\tcommitTx.AddTxOut(wire.NewTxOut(amountPending, p2wsh))\n\n\t// Store the pkScript of this particular PaymentDescriptor so we can\n\t// quickly locate it within the commitment transaction later.\n\tif ourCommit {\n\t\tpaymentDesc.ourPkScript = p2wsh\n\t\tpaymentDesc.ourWitnessScript = witnessScript\n\t} else {\n\t\tpaymentDesc.theirPkScript = p2wsh\n\t\tpaymentDesc.theirWitnessScript = witnessScript\n\t}\n\n\treturn nil\n}\n\n// findOutputIndexesFromRemote finds the index of our and their outputs from\n// the remote commitment transaction. It derives the key ring to compute the\n// output scripts and compares them against the outputs inside the commitment\n// to find the match.",
      "length": 1073,
      "tokens": 135,
      "embedding": []
    },
    {
      "slug": "func findOutputIndexesFromRemote(revocationPreimage *chainhash.Hash,",
      "content": "func findOutputIndexesFromRemote(revocationPreimage *chainhash.Hash,\n\tchanState *channeldb.OpenChannel) (uint32, uint32, error) {\n\n\t// Init the output indexes as empty.\n\tourIndex := uint32(channeldb.OutputIndexEmpty)\n\ttheirIndex := uint32(channeldb.OutputIndexEmpty)\n\n\tchanCommit := chanState.RemoteCommitment\n\t_, commitmentPoint := btcec.PrivKeyFromBytes(revocationPreimage[:])\n\n\t// With the commitment point generated, we can now derive the king ring\n\t// which will be used to generate the output scripts.\n\tkeyRing := DeriveCommitmentKeys(\n\t\tcommitmentPoint, false, chanState.ChanType,\n\t\t&chanState.LocalChanCfg, &chanState.RemoteChanCfg,\n\t)\n\n\t// Since it's remote commitment chain, we'd used the mirrored values.\n\t//\n\t// We use the remote's channel config for the csv delay.\n\ttheirDelay := uint32(chanState.RemoteChanCfg.CsvDelay)\n\n\t// If we are the initiator of this channel, then it's be false from the\n\t// remote's PoV.\n\tisRemoteInitiator := !chanState.IsInitiator\n\n\tvar leaseExpiry uint32\n\tif chanState.ChanType.HasLeaseExpiration() {\n\t\tleaseExpiry = chanState.ThawHeight\n\t}\n\n\t// Map the scripts from our PoV. When facing a local commitment, the to\n\t// local output belongs to us and the to remote output belongs to them.\n\t// When facing a remote commitment, the to local output belongs to them\n\t// and the to remote output belongs to us.\n\n\t// Compute the to local script. From our PoV, when facing a remote\n\t// commitment, the to local output belongs to them.\n\ttheirScript, err := CommitScriptToSelf(\n\t\tchanState.ChanType, isRemoteInitiator, keyRing.ToLocalKey,\n\t\tkeyRing.RevocationKey, theirDelay, leaseExpiry,\n\t)\n\tif err != nil {\n\t\treturn ourIndex, theirIndex, err\n\t}\n\n\t// Compute the to remote script. From our PoV, when facing a remote\n\t// commitment, the to remote output belongs to us.\n\tourScript, _, err := CommitScriptToRemote(\n\t\tchanState.ChanType, isRemoteInitiator, keyRing.ToRemoteKey,\n\t\tleaseExpiry,\n\t)\n\tif err != nil {\n\t\treturn ourIndex, theirIndex, err\n\t}\n\n\t// Now compare the scripts to find our/their output index.\n\tfor i, txOut := range chanCommit.CommitTx.TxOut {\n\t\tswitch {\n\t\tcase bytes.Equal(txOut.PkScript, ourScript.PkScript):\n\t\t\tourIndex = uint32(i)\n\t\tcase bytes.Equal(txOut.PkScript, theirScript.PkScript):\n\t\t\ttheirIndex = uint32(i)\n\t\t}\n\t}\n\n\treturn ourIndex, theirIndex, nil\n}\n",
      "length": 2174,
      "tokens": 288,
      "embedding": []
    }
  ]
}