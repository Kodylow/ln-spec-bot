{
  "filepath": "../implementations/go/lnd/lnwallet/rpcwallet/rpcwallet.go",
  "package": "rpcwallet",
  "sections": [
    {
      "slug": "type RPCKeyRing struct {",
      "content": "type RPCKeyRing struct {\n\t// WalletController is the embedded wallet controller of the watch-only\n\t// base wallet. We need to overwrite/shadow certain of the implemented\n\t// methods to make sure we can mirror them to the remote wallet.\n\tlnwallet.WalletController\n\n\twatchOnlyKeyRing keychain.SecretKeyRing\n\n\tnetParams *chaincfg.Params\n\n\trpcTimeout time.Duration\n\n\tsignerClient signrpc.SignerClient\n\twalletClient walletrpc.WalletKitClient\n}\n\nvar _ keychain.SecretKeyRing = (*RPCKeyRing)(nil)\nvar _ input.Signer = (*RPCKeyRing)(nil)\nvar _ keychain.MessageSignerRing = (*RPCKeyRing)(nil)\nvar _ lnwallet.WalletController = (*RPCKeyRing)(nil)\n\n// NewRPCKeyRing creates a new remote signing secret key ring that uses the\n// given watch-only base wallet to keep track of addresses and transactions but\n// delegates any signing or ECDH operations to the remove signer through RPC.",
      "length": 824,
      "tokens": 105,
      "embedding": []
    },
    {
      "slug": "func NewRPCKeyRing(watchOnlyKeyRing keychain.SecretKeyRing,",
      "content": "func NewRPCKeyRing(watchOnlyKeyRing keychain.SecretKeyRing,\n\twatchOnlyWalletController lnwallet.WalletController,\n\tremoteSigner *lncfg.RemoteSigner,\n\tnetParams *chaincfg.Params) (*RPCKeyRing, error) {\n\n\trpcConn, err := connectRPC(\n\t\tremoteSigner.RPCHost, remoteSigner.TLSCertPath,\n\t\tremoteSigner.MacaroonPath, remoteSigner.Timeout,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error connecting to the remote \"+\n\t\t\t\"signing node through RPC: %v\", err)\n\t}\n\n\treturn &RPCKeyRing{\n\t\tWalletController: watchOnlyWalletController,\n\t\twatchOnlyKeyRing: watchOnlyKeyRing,\n\t\tnetParams:        netParams,\n\t\trpcTimeout:       remoteSigner.Timeout,\n\t\tsignerClient:     signrpc.NewSignerClient(rpcConn),\n\t\twalletClient:     walletrpc.NewWalletKitClient(rpcConn),\n\t}, nil\n}\n\n// NewAddress returns the next external or internal address for the\n// wallet dictated by the value of the `change` parameter. If change is\n// true, then an internal address should be used, otherwise an external\n// address should be returned. The type of address returned is dictated\n// by the wallet's capabilities, and may be of type: p2sh, p2wkh,\n// p2wsh, etc. The account parameter must be non-empty as it determines\n// which account the address should be generated from.",
      "length": 1146,
      "tokens": 136,
      "embedding": []
    },
    {
      "slug": "func (r *RPCKeyRing) NewAddress(addrType lnwallet.AddressType, change bool,",
      "content": "func (r *RPCKeyRing) NewAddress(addrType lnwallet.AddressType, change bool,\n\taccount string) (btcutil.Address, error) {\n\n\treturn r.WalletController.NewAddress(addrType, change, account)\n}\n\n// SendOutputs funds, signs, and broadcasts a Bitcoin transaction paying out to\n// the specified outputs. In the case the wallet has insufficient funds, or the\n// outputs are non-standard, a non-nil error will be returned.\n//\n// NOTE: This method requires the global coin selection lock to be held.\n//\n// NOTE: This is a part of the WalletController interface.\n//\n// NOTE: This method only signs with BIP49/84 keys.",
      "length": 515,
      "tokens": 81,
      "embedding": []
    },
    {
      "slug": "func (r *RPCKeyRing) SendOutputs(outputs []*wire.TxOut,",
      "content": "func (r *RPCKeyRing) SendOutputs(outputs []*wire.TxOut,\n\tfeeRate chainfee.SatPerKWeight, minConfs int32,\n\tlabel string) (*wire.MsgTx, error) {\n\n\ttx, err := r.WalletController.SendOutputs(\n\t\toutputs, feeRate, minConfs, label,\n\t)\n\tif err != nil && err != basewallet.ErrTxUnsigned {\n\t\treturn nil, err\n\t}\n\tif err == nil {\n\t\t// This shouldn't happen since our wallet controller is watch-\n\t\t// only and can't sign the TX.\n\t\treturn tx, nil\n\t}\n\n\t// We know at this point that we only have inputs from our own wallet.\n\t// So we can just compute the input script using the remote signer.\n\toutputFetcher := lnwallet.NewWalletPrevOutputFetcher(r.WalletController)\n\tfor i, txIn := range tx.TxIn {\n\t\tsignDesc := input.SignDescriptor{\n\t\t\tHashType: txscript.SigHashAll,\n\t\t\tSigHashes: txscript.NewTxSigHashes(\n\t\t\t\ttx, outputFetcher,\n\t\t\t),\n\t\t\tPrevOutputFetcher: outputFetcher,\n\t\t}\n\n\t\t// We can only sign this input if it's ours, so we'll ask the\n\t\t// watch-only wallet if it can map this outpoint into a coin we\n\t\t// own. If not, then we can't continue because our wallet state\n\t\t// is out of sync.\n\t\tinfo, err := r.WalletController.FetchInputInfo(\n\t\t\t&txIn.PreviousOutPoint,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"error looking up utxo: %v\", err)\n\t\t}\n\n\t\tif txscript.IsPayToTaproot(info.PkScript) {\n\t\t\tsignDesc.HashType = txscript.SigHashDefault\n\t\t}\n\n\t\t// Now that we know the input is ours, we'll populate the\n\t\t// signDesc with the per input unique information.\n\t\tsignDesc.Output = &wire.TxOut{\n\t\t\tValue:    int64(info.Value),\n\t\t\tPkScript: info.PkScript,\n\t\t}\n\t\tsignDesc.InputIndex = i\n\n\t\t// Finally, we'll sign the input as is, and populate the input\n\t\t// with the witness and sigScript (if needed).\n\t\tinputScript, err := r.ComputeInputScript(tx, &signDesc)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\ttxIn.SignatureScript = inputScript.SigScript\n\t\ttxIn.Witness = inputScript.Witness\n\t}\n\n\treturn tx, r.WalletController.PublishTransaction(tx, label)\n}\n\n// SignPsbt expects a partial transaction with all inputs and outputs fully\n// declared and tries to sign all unsigned inputs that have all required fields\n// (UTXO information, BIP32 derivation information, witness or sig scripts) set.\n// If no error is returned, the PSBT is ready to be given to the next signer or\n// to be finalized if lnd was the last signer.\n//\n// NOTE: This RPC only signs inputs (and only those it can sign), it does not\n// perform any other tasks (such as coin selection, UTXO locking or\n// input/output/fee value validation, PSBT finalization). Any input that is\n// incomplete will be skipped.",
      "length": 2436,
      "tokens": 365,
      "embedding": []
    },
    {
      "slug": "func (r *RPCKeyRing) SignPsbt(packet *psbt.Packet) ([]uint32, error) {",
      "content": "func (r *RPCKeyRing) SignPsbt(packet *psbt.Packet) ([]uint32, error) {\n\tctxt, cancel := context.WithTimeout(context.Background(), r.rpcTimeout)\n\tdefer cancel()\n\n\tvar buf bytes.Buffer\n\tif err := packet.Serialize(&buf); err != nil {\n\t\treturn nil, fmt.Errorf(\"error serializing PSBT: %v\", err)\n\t}\n\n\tresp, err := r.walletClient.SignPsbt(ctxt, &walletrpc.SignPsbtRequest{\n\t\tFundedPsbt: buf.Bytes(),\n\t})\n\tif err != nil {\n\t\tconsiderShutdown(err)\n\t\treturn nil, fmt.Errorf(\"error signing PSBT in remote signer \"+\n\t\t\t\"instance: %v\", err)\n\t}\n\n\tsignedPacket, err := psbt.NewFromRawBytes(\n\t\tbytes.NewReader(resp.SignedPsbt), false,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error parsing signed PSBT: %v\", err)\n\t}\n\n\t// The caller expects the packet to be modified instead of a new\n\t// instance to be returned. So we just overwrite all fields in the\n\t// original packet.\n\tpacket.UnsignedTx = signedPacket.UnsignedTx\n\tpacket.Inputs = signedPacket.Inputs\n\tpacket.Outputs = signedPacket.Outputs\n\tpacket.Unknowns = signedPacket.Unknowns\n\n\treturn resp.SignedInputs, nil\n}\n\n// FinalizePsbt expects a partial transaction with all inputs and outputs fully\n// declared and tries to sign all inputs that belong to the specified account.\n// Lnd must be the last signer of the transaction. That means, if there are any\n// unsigned non-witness inputs or inputs without UTXO information attached or\n// inputs without witness data that do not belong to lnd's wallet, this method\n// will fail. If no error is returned, the PSBT is ready to be extracted and the\n// final TX within to be broadcast.\n//\n// NOTE: This method does NOT publish the transaction after it's been\n// finalized successfully.\n//\n// NOTE: This is a part of the WalletController interface.\n//\n// NOTE: We need to overwrite this method because we need to redirect the call\n// to ComputeInputScript to the RPC key ring's implementation. If we forward\n// the call to the default WalletController implementation, we get an error\n// since that wallet is watch-only. If we forward the call to the remote signer,\n// we get an error because the signer doesn't know the UTXO information required\n// in ComputeInputScript.\n//\n// TODO(guggero): Refactor btcwallet to accept ComputeInputScript as a function\n// parameter in FinalizePsbt so we can get rid of this code duplication.",
      "length": 2184,
      "tokens": 333,
      "embedding": []
    },
    {
      "slug": "func (r *RPCKeyRing) FinalizePsbt(packet *psbt.Packet, _ string) error {",
      "content": "func (r *RPCKeyRing) FinalizePsbt(packet *psbt.Packet, _ string) error {\n\t// Let's check that this is actually something we can and want to sign.\n\t// We need at least one input and one output.\n\terr := psbt.VerifyInputOutputLen(packet, true, true)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Go through each input that doesn't have final witness data attached\n\t// to it already and try to sign it. We do expect that we're the last\n\t// ones to sign. If there is any input without witness data that we\n\t// cannot sign because it's not our UTXO, this will be a hard failure.\n\ttx := packet.UnsignedTx\n\tprevOutFetcher := basewallet.PsbtPrevOutputFetcher(packet)\n\tsigHashes := txscript.NewTxSigHashes(tx, prevOutFetcher)\n\tfor idx, txIn := range tx.TxIn {\n\t\tin := packet.Inputs[idx]\n\n\t\t// We can only sign if we have UTXO information available. We\n\t\t// can just continue here as a later step will fail with a more\n\t\t// precise error message.\n\t\tif in.WitnessUtxo == nil && in.NonWitnessUtxo == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Skip this input if it's got final witness data attached.\n\t\tif len(in.FinalScriptWitness) > 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// We can only sign this input if it's ours, so we try to map it\n\t\t// to a coin we own. If we can't, then we'll continue as it\n\t\t// isn't our input.\n\t\tutxo, err := r.FetchInputInfo(&txIn.PreviousOutPoint)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tfullTx := utxo.PrevTx\n\t\tsignDesc := &input.SignDescriptor{\n\t\t\tKeyDesc: keychain.KeyDescriptor{},\n\t\t\tOutput: &wire.TxOut{\n\t\t\t\tValue:    int64(utxo.Value),\n\t\t\t\tPkScript: utxo.PkScript,\n\t\t\t},\n\t\t\tHashType:          in.SighashType,\n\t\t\tSigHashes:         sigHashes,\n\t\t\tInputIndex:        idx,\n\t\t\tPrevOutputFetcher: prevOutFetcher,\n\t\t}\n\n\t\t// Find out what UTXO we are signing. Wallets _should_ always\n\t\t// provide the full non-witness UTXO for segwit v0.\n\t\tvar signOutput *wire.TxOut\n\t\tif in.NonWitnessUtxo != nil {\n\t\t\tprevIndex := txIn.PreviousOutPoint.Index\n\t\t\tsignOutput = in.NonWitnessUtxo.TxOut[prevIndex]\n\n\t\t\tif !psbt.TxOutsEqual(signDesc.Output, signOutput) {\n\t\t\t\treturn fmt.Errorf(\"found UTXO %#v but it \"+\n\t\t\t\t\t\"doesn't match PSBT's input %v\",\n\t\t\t\t\tsignDesc.Output, signOutput)\n\t\t\t}\n\n\t\t\tif fullTx.TxHash() != txIn.PreviousOutPoint.Hash {\n\t\t\t\treturn fmt.Errorf(\"found UTXO tx %v but it \"+\n\t\t\t\t\t\"doesn't match PSBT's input %v\",\n\t\t\t\t\tfullTx.TxHash(),\n\t\t\t\t\ttxIn.PreviousOutPoint.Hash)\n\t\t\t}\n\t\t}\n\n\t\t// Fall back to witness UTXO only for older wallets.\n\t\tif in.WitnessUtxo != nil {\n\t\t\tsignOutput = in.WitnessUtxo\n\n\t\t\tif !psbt.TxOutsEqual(signDesc.Output, signOutput) {\n\t\t\t\treturn fmt.Errorf(\"found UTXO %#v but it \"+\n\t\t\t\t\t\"doesn't match PSBT's input %v\",\n\t\t\t\t\tsignDesc.Output, signOutput)\n\t\t\t}\n\t\t}\n\n\t\t// Do the actual signing in ComputeInputScript which in turn\n\t\t// will invoke the remote signer.\n\t\tscript, err := r.ComputeInputScript(tx, signDesc)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error computing input script for \"+\n\t\t\t\t\"input %d: %v\", idx, err)\n\t\t}\n\n\t\t// Serialize the witness format from the stack representation to\n\t\t// the wire representation.\n\t\tvar witnessBytes bytes.Buffer\n\t\terr = psbt.WriteTxWitness(&witnessBytes, script.Witness)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error serializing witness: %v\", err)\n\t\t}\n\t\tpacket.Inputs[idx].FinalScriptWitness = witnessBytes.Bytes()\n\t\tpacket.Inputs[idx].FinalScriptSig = script.SigScript\n\t}\n\n\t// Make sure the PSBT itself thinks it's finalized and ready to be\n\t// broadcast.\n\terr = psbt.MaybeFinalizeAll(packet)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error finalizing PSBT: %v\", err)\n\t}\n\n\treturn nil\n}\n\n// DeriveNextKey attempts to derive the *next* key within the key family\n// (account in BIP43) specified. This method should return the next external\n// child within this branch.\n//\n// NOTE: This method is part of the keychain.KeyRing interface.",
      "length": 3577,
      "tokens": 506,
      "embedding": []
    },
    {
      "slug": "func (r *RPCKeyRing) DeriveNextKey(",
      "content": "func (r *RPCKeyRing) DeriveNextKey(\n\tkeyFam keychain.KeyFamily) (keychain.KeyDescriptor, error) {\n\n\treturn r.watchOnlyKeyRing.DeriveNextKey(keyFam)\n}\n\n// DeriveKey attempts to derive an arbitrary key specified by the passed\n// KeyLocator. This may be used in several recovery scenarios, or when manually\n// rotating something like our current default node key.\n//\n// NOTE: This method is part of the keychain.KeyRing interface.",
      "length": 382,
      "tokens": 53,
      "embedding": []
    },
    {
      "slug": "func (r *RPCKeyRing) DeriveKey(",
      "content": "func (r *RPCKeyRing) DeriveKey(\n\tkeyLoc keychain.KeyLocator) (keychain.KeyDescriptor, error) {\n\n\treturn r.watchOnlyKeyRing.DeriveKey(keyLoc)\n}\n\n// ECDH performs a scalar multiplication (ECDH-like operation) between the\n// target key descriptor and remote public key. The output returned will be the\n// sha256 of the resulting shared point serialized in compressed format. If k is\n// our private key, and P is the public key, we perform the following operation:\n//\n//\tsx := k*P\n//\ts := sha256(sx.SerializeCompressed())\n//\n// NOTE: This method is part of the keychain.ECDHRing interface.",
      "length": 540,
      "tokens": 81,
      "embedding": []
    },
    {
      "slug": "func (r *RPCKeyRing) ECDH(keyDesc keychain.KeyDescriptor,",
      "content": "func (r *RPCKeyRing) ECDH(keyDesc keychain.KeyDescriptor,\n\tpubKey *btcec.PublicKey) ([32]byte, error) {\n\n\tctxt, cancel := context.WithTimeout(context.Background(), r.rpcTimeout)\n\tdefer cancel()\n\n\tkey := [32]byte{}\n\treq := &signrpc.SharedKeyRequest{\n\t\tEphemeralPubkey: pubKey.SerializeCompressed(),\n\t\tKeyDesc: &signrpc.KeyDescriptor{\n\t\t\tKeyLoc: &signrpc.KeyLocator{\n\t\t\t\tKeyFamily: int32(keyDesc.Family),\n\t\t\t\tKeyIndex:  int32(keyDesc.Index),\n\t\t\t},\n\t\t},\n\t}\n\n\tif keyDesc.Index == 0 && keyDesc.PubKey != nil {\n\t\treq.KeyDesc.RawKeyBytes = keyDesc.PubKey.SerializeCompressed()\n\t}\n\n\tresp, err := r.signerClient.DeriveSharedKey(ctxt, req)\n\tif err != nil {\n\t\tconsiderShutdown(err)\n\t\treturn key, fmt.Errorf(\"error deriving shared key in remote \"+\n\t\t\t\"signer instance: %v\", err)\n\t}\n\n\tcopy(key[:], resp.SharedKey)\n\treturn key, nil\n}\n\n// SignMessage attempts to sign a target message with the private key described\n// in the key locator. If the target private key is unable to be found, then an\n// error will be returned. The actual digest signed is the single or double\n// SHA-256 of the passed message.\n//\n// NOTE: This method is part of the keychain.MessageSignerRing interface.",
      "length": 1073,
      "tokens": 136,
      "embedding": []
    },
    {
      "slug": "func (r *RPCKeyRing) SignMessage(keyLoc keychain.KeyLocator,",
      "content": "func (r *RPCKeyRing) SignMessage(keyLoc keychain.KeyLocator,\n\tmsg []byte, doubleHash bool) (*ecdsa.Signature, error) {\n\n\tctxt, cancel := context.WithTimeout(context.Background(), r.rpcTimeout)\n\tdefer cancel()\n\n\tresp, err := r.signerClient.SignMessage(ctxt, &signrpc.SignMessageReq{\n\t\tMsg: msg,\n\t\tKeyLoc: &signrpc.KeyLocator{\n\t\t\tKeyFamily: int32(keyLoc.Family),\n\t\t\tKeyIndex:  int32(keyLoc.Index),\n\t\t},\n\t\tDoubleHash: doubleHash,\n\t})\n\tif err != nil {\n\t\tconsiderShutdown(err)\n\t\treturn nil, fmt.Errorf(\"error signing message in remote \"+\n\t\t\t\"signer instance: %v\", err)\n\t}\n\n\twireSig, err := lnwire.NewSigFromRawSignature(resp.Signature)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error parsing raw signature: %v\", err)\n\t}\n\treturn wireSig.ToSignature()\n}\n\n// SignMessageCompact signs the given message, single or double SHA256 hashing\n// it first, with the private key described in the key locator and returns the\n// signature in the compact, public key recoverable format.\n//\n// NOTE: This method is part of the keychain.MessageSignerRing interface.",
      "length": 952,
      "tokens": 117,
      "embedding": []
    },
    {
      "slug": "func (r *RPCKeyRing) SignMessageCompact(keyLoc keychain.KeyLocator,",
      "content": "func (r *RPCKeyRing) SignMessageCompact(keyLoc keychain.KeyLocator,\n\tmsg []byte, doubleHash bool) ([]byte, error) {\n\n\tif keyLoc.Family != keychain.KeyFamilyNodeKey {\n\t\treturn nil, fmt.Errorf(\"error compact signing with key \"+\n\t\t\t\"locator %v, can only sign with node key\", keyLoc)\n\t}\n\n\tctxt, cancel := context.WithTimeout(context.Background(), r.rpcTimeout)\n\tdefer cancel()\n\n\tresp, err := r.signerClient.SignMessage(ctxt, &signrpc.SignMessageReq{\n\t\tMsg: msg,\n\t\tKeyLoc: &signrpc.KeyLocator{\n\t\t\tKeyFamily: int32(keyLoc.Family),\n\t\t\tKeyIndex:  int32(keyLoc.Index),\n\t\t},\n\t\tDoubleHash: doubleHash,\n\t\tCompactSig: true,\n\t})\n\tif err != nil {\n\t\tconsiderShutdown(err)\n\t\treturn nil, fmt.Errorf(\"error signing message in remote \"+\n\t\t\t\"signer instance: %v\", err)\n\t}\n\n\t// The signature in the response is zbase32 encoded, so we need to\n\t// decode it before returning.\n\treturn resp.Signature, nil\n}\n\n// SignMessageSchnorr attempts to sign a target message with the private key\n// described in the key locator. If the target private key is unable to be\n// found, then an error will be returned. The actual digest signed is the\n// single or double SHA-256 of the passed message.\n//\n// NOTE: This method is part of the keychain.MessageSignerRing interface.",
      "length": 1133,
      "tokens": 158,
      "embedding": []
    },
    {
      "slug": "func (r *RPCKeyRing) SignMessageSchnorr(keyLoc keychain.KeyLocator,",
      "content": "func (r *RPCKeyRing) SignMessageSchnorr(keyLoc keychain.KeyLocator,\n\tmsg []byte, doubleHash bool, taprootTweak []byte) (*schnorr.Signature,\n\terror) {\n\n\tctxt, cancel := context.WithTimeout(context.Background(), r.rpcTimeout)\n\tdefer cancel()\n\n\tresp, err := r.signerClient.SignMessage(ctxt, &signrpc.SignMessageReq{\n\t\tMsg: msg,\n\t\tKeyLoc: &signrpc.KeyLocator{\n\t\t\tKeyFamily: int32(keyLoc.Family),\n\t\t\tKeyIndex:  int32(keyLoc.Index),\n\t\t},\n\t\tDoubleHash:         doubleHash,\n\t\tSchnorrSig:         true,\n\t\tSchnorrSigTapTweak: taprootTweak,\n\t})\n\tif err != nil {\n\t\tconsiderShutdown(err)\n\t\treturn nil, fmt.Errorf(\"error signing message in remote \"+\n\t\t\t\"signer instance: %v\", err)\n\t}\n\n\tsigParsed, err := schnorr.ParseSignature(resp.Signature)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"can't parse schnorr signature: %v\",\n\t\t\terr)\n\t}\n\treturn sigParsed, nil\n}\n\n// DerivePrivKey attempts to derive the private key that corresponds to the\n// passed key descriptor.  If the public key is set, then this method will\n// perform an in-order scan over the key set, with a max of MaxKeyRangeScan\n// keys. In order for this to work, the caller MUST set the KeyFamily within the\n// partially populated KeyLocator.\n//\n// NOTE: This method is part of the keychain.SecretKeyRing interface.",
      "length": 1156,
      "tokens": 149,
      "embedding": []
    },
    {
      "slug": "func (r *RPCKeyRing) DerivePrivKey(_ keychain.KeyDescriptor) (*btcec.PrivateKey,",
      "content": "func (r *RPCKeyRing) DerivePrivKey(_ keychain.KeyDescriptor) (*btcec.PrivateKey,\n\terror) {\n\n\t// This operation is not supported with remote signing. There should be\n\t// no need for invoking this method unless a channel backup (SCB) file\n\t// for pre-0.13.0 channels are attempted to be restored. In that case\n\t// it is recommended to restore the channels using a node with the full\n\t// seed available.\n\treturn nil, ErrRemoteSigningPrivateKeyNotAvailable\n}\n\n// SignOutputRaw generates a signature for the passed transaction\n// according to the data within the passed SignDescriptor.\n//\n// NOTE: The resulting signature should be void of a sighash byte.\n//\n// NOTE: This method is part of the input.Signer interface.\n//\n// NOTE: This method only signs with BIP1017 (internal) keys!",
      "length": 680,
      "tokens": 113,
      "embedding": []
    },
    {
      "slug": "func (r *RPCKeyRing) SignOutputRaw(tx *wire.MsgTx,",
      "content": "func (r *RPCKeyRing) SignOutputRaw(tx *wire.MsgTx,\n\tsignDesc *input.SignDescriptor) (input.Signature, error) {\n\n\t// Forward the call to the remote signing instance. This call is only\n\t// ever called for signing witness (p2pkh or p2wsh) inputs and never\n\t// nested witness inputs, so the sigScript is always nil.\n\treturn r.remoteSign(tx, signDesc, nil)\n}\n\n// ComputeInputScript generates a complete InputIndex for the passed\n// transaction with the signature as defined within the passed\n// SignDescriptor. This method should be capable of generating the\n// proper input script for both regular p2wkh output and p2wkh outputs\n// nested within a regular p2sh output.\n//\n// NOTE: This method will ignore any tweak parameters set within the\n// passed SignDescriptor as it assumes a set of typical script\n// templates (p2wkh, np2wkh, BIP0086 p2tr, etc).\n//\n// NOTE: This method is part of the input.Signer interface.",
      "length": 842,
      "tokens": 135,
      "embedding": []
    },
    {
      "slug": "func (r *RPCKeyRing) ComputeInputScript(tx *wire.MsgTx,",
      "content": "func (r *RPCKeyRing) ComputeInputScript(tx *wire.MsgTx,\n\tsignDesc *input.SignDescriptor) (*input.Script, error) {\n\n\taddr, witnessProgram, sigScript, err := r.WalletController.ScriptForOutput(\n\t\tsignDesc.Output,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tsignDesc.WitnessScript = witnessProgram\n\n\t// If this is a p2tr address, then it must be a BIP0086 key spend if we\n\t// are coming through this path (instead of SignOutputRaw).\n\tswitch addr.AddrType() {\n\tcase waddrmgr.TaprootPubKey:\n\t\tsignDesc.SignMethod = input.TaprootKeySpendBIP0086SignMethod\n\t\tsignDesc.WitnessScript = nil\n\n\t\tsig, err := r.remoteSign(tx, signDesc, nil)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"error signing with remote\"+\n\t\t\t\t\"instance: %v\", err)\n\t\t}\n\n\t\trawSig := sig.Serialize()\n\t\tif signDesc.HashType != txscript.SigHashDefault {\n\t\t\trawSig = append(rawSig, byte(signDesc.HashType))\n\t\t}\n\n\t\treturn &input.Script{\n\t\t\tWitness: wire.TxWitness{\n\t\t\t\trawSig,\n\t\t\t},\n\t\t}, nil\n\n\tcase waddrmgr.TaprootScript:\n\t\treturn nil, fmt.Errorf(\"computing input script for taproot \" +\n\t\t\t\"script address not supported\")\n\t}\n\n\t// Let's give the TX to the remote instance now, so it can sign the\n\t// input.\n\tsig, err := r.remoteSign(tx, signDesc, witnessProgram)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error signing with remote instance: %v\",\n\t\t\terr)\n\t}\n\n\t// ComputeInputScript currently is only used for P2WKH and NP2WKH\n\t// addresses. So the last item on the stack is always the compressed\n\t// public key.\n\treturn &input.Script{\n\t\tWitness: wire.TxWitness{\n\t\t\tappend(sig.Serialize(), byte(signDesc.HashType)),\n\t\t\taddr.PubKey().SerializeCompressed(),\n\t\t},\n\t\tSigScript: sigScript,\n\t}, nil\n}\n\n// MuSig2CreateSession creates a new MuSig2 signing session using the local\n// key identified by the key locator. The complete list of all public keys of\n// all signing parties must be provided, including the public key of the local\n// signing key. If nonces of other parties are already known, they can be\n// submitted as well to reduce the number of method calls necessary later on.",
      "length": 1912,
      "tokens": 265,
      "embedding": []
    },
    {
      "slug": "func (r *RPCKeyRing) MuSig2CreateSession(bipVersion input.MuSig2Version,",
      "content": "func (r *RPCKeyRing) MuSig2CreateSession(bipVersion input.MuSig2Version,\n\tkeyLoc keychain.KeyLocator, pubKeys []*btcec.PublicKey,\n\ttweaks *input.MuSig2Tweaks,\n\totherNonces [][musig2.PubNonceSize]byte) (*input.MuSig2SessionInfo,\n\terror) {\n\n\tapiVersion, err := signrpc.MarshalMuSig2Version(bipVersion)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// We need to serialize all data for the RPC call. We can do that by\n\t// putting everything directly into the request struct.\n\treq := &signrpc.MuSig2SessionRequest{\n\t\tKeyLoc: &signrpc.KeyLocator{\n\t\t\tKeyFamily: int32(keyLoc.Family),\n\t\t\tKeyIndex:  int32(keyLoc.Index),\n\t\t},\n\t\tAllSignerPubkeys: make([][]byte, len(pubKeys)),\n\t\tTweaks: make(\n\t\t\t[]*signrpc.TweakDesc, len(tweaks.GenericTweaks),\n\t\t),\n\t\tOtherSignerPublicNonces: make([][]byte, len(otherNonces)),\n\t\tVersion:                 apiVersion,\n\t}\n\tfor idx, pubKey := range pubKeys {\n\t\tswitch bipVersion {\n\t\tcase input.MuSig2Version040:\n\t\t\treq.AllSignerPubkeys[idx] = schnorr.SerializePubKey(\n\t\t\t\tpubKey,\n\t\t\t)\n\n\t\tcase input.MuSig2Version100RC2:\n\t\t\treq.AllSignerPubkeys[idx] = pubKey.SerializeCompressed()\n\t\t}\n\t}\n\tfor idx, genericTweak := range tweaks.GenericTweaks {\n\t\treq.Tweaks[idx] = &signrpc.TweakDesc{\n\t\t\tTweak:   genericTweak.Tweak[:],\n\t\t\tIsXOnly: genericTweak.IsXOnly,\n\t\t}\n\t}\n\tfor idx, nonce := range otherNonces {\n\t\treq.OtherSignerPublicNonces[idx] = make([]byte, len(nonce))\n\t\tcopy(req.OtherSignerPublicNonces[idx], nonce[:])\n\t}\n\tif tweaks.HasTaprootTweak() {\n\t\treq.TaprootTweak = &signrpc.TaprootTweakDesc{\n\t\t\tKeySpendOnly: tweaks.TaprootBIP0086Tweak,\n\t\t\tScriptRoot:   tweaks.TaprootTweak,\n\t\t}\n\t}\n\n\tctxt, cancel := context.WithTimeout(context.Background(), r.rpcTimeout)\n\tdefer cancel()\n\n\tresp, err := r.signerClient.MuSig2CreateSession(ctxt, req)\n\tif err != nil {\n\t\tconsiderShutdown(err)\n\t\treturn nil, fmt.Errorf(\"error creating MuSig2 session in \"+\n\t\t\t\"remote signer instance: %v\", err)\n\t}\n\n\t// De-Serialize all the info back into our native struct.\n\tinfo := &input.MuSig2SessionInfo{\n\t\tVersion:       bipVersion,\n\t\tTaprootTweak:  tweaks.HasTaprootTweak(),\n\t\tHaveAllNonces: resp.HaveAllNonces,\n\t}\n\tcopy(info.SessionID[:], resp.SessionId)\n\tcopy(info.PublicNonce[:], resp.LocalPublicNonces)\n\n\tinfo.CombinedKey, err = schnorr.ParsePubKey(resp.CombinedKey)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error parsing combined key: %v\", err)\n\t}\n\n\tif tweaks.HasTaprootTweak() {\n\t\tinfo.TaprootInternalKey, err = schnorr.ParsePubKey(\n\t\t\tresp.TaprootInternalKey,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"error parsing internal key: %v\",\n\t\t\t\terr)\n\t\t}\n\t}\n\n\treturn info, nil\n}\n\n// MuSig2RegisterNonces registers one or more public nonces of other signing\n// participants for a session identified by its ID. This method returns true\n// once we have all nonces for all other signing participants.",
      "length": 2625,
      "tokens": 275,
      "embedding": []
    },
    {
      "slug": "func (r *RPCKeyRing) MuSig2RegisterNonces(sessionID input.MuSig2SessionID,",
      "content": "func (r *RPCKeyRing) MuSig2RegisterNonces(sessionID input.MuSig2SessionID,\n\tpubNonces [][musig2.PubNonceSize]byte) (bool, error) {\n\n\t// We need to serialize all data for the RPC call. We can do that by\n\t// putting everything directly into the request struct.\n\treq := &signrpc.MuSig2RegisterNoncesRequest{\n\t\tSessionId:               sessionID[:],\n\t\tOtherSignerPublicNonces: make([][]byte, len(pubNonces)),\n\t}\n\tfor idx, nonce := range pubNonces {\n\t\treq.OtherSignerPublicNonces[idx] = make([]byte, len(nonce))\n\t\tcopy(req.OtherSignerPublicNonces[idx], nonce[:])\n\t}\n\n\tctxt, cancel := context.WithTimeout(context.Background(), r.rpcTimeout)\n\tdefer cancel()\n\n\tresp, err := r.signerClient.MuSig2RegisterNonces(ctxt, req)\n\tif err != nil {\n\t\tconsiderShutdown(err)\n\t\treturn false, fmt.Errorf(\"error registering MuSig2 nonces in \"+\n\t\t\t\"remote signer instance: %v\", err)\n\t}\n\n\treturn resp.HaveAllNonces, nil\n}\n\n// MuSig2Sign creates a partial signature using the local signing key\n// that was specified when the session was created. This can only be\n// called when all public nonces of all participants are known and have\n// been registered with the session. If this node isn't responsible for\n// combining all the partial signatures, then the cleanup parameter\n// should be set, indicating that the session can be removed from memory\n// once the signature was produced.",
      "length": 1249,
      "tokens": 166,
      "embedding": []
    },
    {
      "slug": "func (r *RPCKeyRing) MuSig2Sign(sessionID input.MuSig2SessionID,",
      "content": "func (r *RPCKeyRing) MuSig2Sign(sessionID input.MuSig2SessionID,\n\tmsg [sha256.Size]byte, cleanUp bool) (*musig2.PartialSignature, error) {\n\n\t// We need to serialize all data for the RPC call. We can do that by\n\t// putting everything directly into the request struct.\n\treq := &signrpc.MuSig2SignRequest{\n\t\tSessionId:     sessionID[:],\n\t\tMessageDigest: msg[:],\n\t\tCleanup:       cleanUp,\n\t}\n\n\tctxt, cancel := context.WithTimeout(context.Background(), r.rpcTimeout)\n\tdefer cancel()\n\n\tresp, err := r.signerClient.MuSig2Sign(ctxt, req)\n\tif err != nil {\n\t\tconsiderShutdown(err)\n\t\treturn nil, fmt.Errorf(\"error signing MuSig2 session in \"+\n\t\t\t\"remote signer instance: %v\", err)\n\t}\n\n\tpartialSig, err := input.DeserializePartialSignature(\n\t\tresp.LocalPartialSignature,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error parsing partial signature from \"+\n\t\t\t\"remote signer: %v\", err)\n\t}\n\n\treturn partialSig, nil\n}\n\n// MuSig2CombineSig combines the given partial signature(s) with the\n// local one, if it already exists. Once a partial signature of all\n// participants is registered, the final signature will be combined and\n// returned.",
      "length": 1027,
      "tokens": 136,
      "embedding": []
    },
    {
      "slug": "func (r *RPCKeyRing) MuSig2CombineSig(sessionID input.MuSig2SessionID,",
      "content": "func (r *RPCKeyRing) MuSig2CombineSig(sessionID input.MuSig2SessionID,\n\tpartialSigs []*musig2.PartialSignature) (*schnorr.Signature, bool,\n\terror) {\n\n\t// We need to serialize all data for the RPC call. We can do that by\n\t// putting everything directly into the request struct.\n\treq := &signrpc.MuSig2CombineSigRequest{\n\t\tSessionId:              sessionID[:],\n\t\tOtherPartialSignatures: make([][]byte, len(partialSigs)),\n\t}\n\tfor idx, partialSig := range partialSigs {\n\t\trawSig, err := input.SerializePartialSignature(partialSig)\n\t\tif err != nil {\n\t\t\treturn nil, false, fmt.Errorf(\"error serializing \"+\n\t\t\t\t\"partial signature: %v\", err)\n\t\t}\n\t\treq.OtherPartialSignatures[idx] = rawSig[:]\n\t}\n\n\tctxt, cancel := context.WithTimeout(context.Background(), r.rpcTimeout)\n\tdefer cancel()\n\n\tresp, err := r.signerClient.MuSig2CombineSig(ctxt, req)\n\tif err != nil {\n\t\tconsiderShutdown(err)\n\t\treturn nil, false, fmt.Errorf(\"error combining MuSig2 \"+\n\t\t\t\"signatures in remote signer instance: %v\", err)\n\t}\n\n\t// The final signature is only available when we have all the other\n\t// partial signatures from all participants.\n\tif !resp.HaveAllSignatures {\n\t\treturn nil, resp.HaveAllSignatures, nil\n\t}\n\n\tfinalSig, err := schnorr.ParseSignature(resp.FinalSignature)\n\tif err != nil {\n\t\treturn nil, false, fmt.Errorf(\"error parsing final signature: \"+\n\t\t\t\"%v\", err)\n\t}\n\n\treturn finalSig, resp.HaveAllSignatures, nil\n}\n\n// MuSig2Cleanup removes a session from memory to free up resources.",
      "length": 1349,
      "tokens": 166,
      "embedding": []
    },
    {
      "slug": "func (r *RPCKeyRing) MuSig2Cleanup(sessionID input.MuSig2SessionID) error {",
      "content": "func (r *RPCKeyRing) MuSig2Cleanup(sessionID input.MuSig2SessionID) error {\n\treq := &signrpc.MuSig2CleanupRequest{\n\t\tSessionId: sessionID[:],\n\t}\n\n\tctxt, cancel := context.WithTimeout(context.Background(), r.rpcTimeout)\n\tdefer cancel()\n\n\t_, err := r.signerClient.MuSig2Cleanup(ctxt, req)\n\tif err != nil {\n\t\tconsiderShutdown(err)\n\t\treturn fmt.Errorf(\"error cleaning up MuSig2 session in remote \"+\n\t\t\t\"signer instance: %v\", err)\n\t}\n\n\treturn nil\n}\n\n// remoteSign signs the input specified in signDesc of the given transaction tx\n// using the remote signing instance.",
      "length": 468,
      "tokens": 60,
      "embedding": []
    },
    {
      "slug": "func (r *RPCKeyRing) remoteSign(tx *wire.MsgTx, signDesc *input.SignDescriptor,",
      "content": "func (r *RPCKeyRing) remoteSign(tx *wire.MsgTx, signDesc *input.SignDescriptor,\n\tsigScript []byte) (input.Signature, error) {\n\n\tpacket, err := packetFromTx(tx)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error converting TX into PSBT: %v\", err)\n\t}\n\n\t// We need to add witness information for all inputs! Otherwise, we'll\n\t// have a problem when attempting to sign a taproot input!\n\tfor idx := range packet.Inputs {\n\t\t// Skip the input we're signing for, that will get a special\n\t\t// treatment later on.\n\t\tif idx == signDesc.InputIndex {\n\t\t\tcontinue\n\t\t}\n\n\t\ttxIn := tx.TxIn[idx]\n\t\tinfo, err := r.WalletController.FetchInputInfo(\n\t\t\t&txIn.PreviousOutPoint,\n\t\t)\n\t\tif err != nil {\n\t\t\t// Maybe we have an UTXO in the previous output fetcher?\n\t\t\tif signDesc.PrevOutputFetcher != nil {\n\t\t\t\tutxo := signDesc.PrevOutputFetcher.FetchPrevOutput(\n\t\t\t\t\ttxIn.PreviousOutPoint,\n\t\t\t\t)\n\t\t\t\tif utxo != nil && utxo.Value != 0 &&\n\t\t\t\t\tlen(utxo.PkScript) > 0 {\n\n\t\t\t\t\tpacket.Inputs[idx].WitnessUtxo = utxo\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlog.Warnf(\"No UTXO info found for index %d \"+\n\t\t\t\t\"(prev_outpoint=%v), won't be able to sign \"+\n\t\t\t\t\"for taproot output!\", idx,\n\t\t\t\ttxIn.PreviousOutPoint)\n\t\t\tcontinue\n\t\t}\n\t\tpacket.Inputs[idx].WitnessUtxo = &wire.TxOut{\n\t\t\tValue:    int64(info.Value),\n\t\t\tPkScript: info.PkScript,\n\t\t}\n\t}\n\n\t// Catch incorrect signing input index, just in case.\n\tif signDesc.InputIndex < 0 || signDesc.InputIndex >= len(packet.Inputs) {\n\t\treturn nil, fmt.Errorf(\"invalid input index in sign descriptor\")\n\t}\n\tin := &packet.Inputs[signDesc.InputIndex]\n\ttxIn := tx.TxIn[signDesc.InputIndex]\n\n\t// Things are a bit tricky with the sign descriptor. There basically are\n\t// four ways to describe a key:\n\t//   1. By public key only. To match this case both family and index\n\t//      must be set to 0.\n\t//   2. By family and index only. To match this case the public key\n\t//      must be nil and either the family or index must be non-zero.\n\t//   3. All values are set and locator is non-empty. To match this case\n\t//      the public key must be set and either the family or index must\n\t//      be non-zero.\n\t//   4. All values are set and locator is empty. This is a special case\n\t//      for the very first channel ever created (with the multi-sig key\n\t//      family which is 0 and the index which is 0 as well). This looks\n\t//      identical to case 1 and will also be handled like that case.\n\t// We only really handle case 1 and 2 here, since 3 is no problem and 4\n\t// is identical to 1.\n\tswitch {\n\t// Case 1: Public key only. We need to find out the derivation path for\n\t// this public key by asking the wallet. This is only possible for our\n\t// internal, custom 1017 scope since we know all keys derived there are\n\t// internally stored as p2wkh addresses.\n\tcase signDesc.KeyDesc.PubKey != nil && signDesc.KeyDesc.IsEmpty():\n\t\tpubKeyBytes := signDesc.KeyDesc.PubKey.SerializeCompressed()\n\t\taddr, err := btcutil.NewAddressWitnessPubKeyHash(\n\t\t\tbtcutil.Hash160(pubKeyBytes), r.netParams,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"error deriving address from \"+\n\t\t\t\t\"public key %x: %v\", pubKeyBytes, err)\n\t\t}\n\n\t\tmanagedAddr, err := r.AddressInfo(addr)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"error fetching address info \"+\n\t\t\t\t\"for public key %x: %v\", pubKeyBytes, err)\n\t\t}\n\n\t\tpubKeyAddr, ok := managedAddr.(waddrmgr.ManagedPubKeyAddress)\n\t\tif !ok {\n\t\t\treturn nil, fmt.Errorf(\"address derived for public \"+\n\t\t\t\t\"key %x is not a p2wkh address\", pubKeyBytes)\n\t\t}\n\n\t\tscope, path, _ := pubKeyAddr.DerivationInfo()\n\t\tif scope.Purpose != keychain.BIP0043Purpose {\n\t\t\treturn nil, fmt.Errorf(\"address derived for public \"+\n\t\t\t\t\"key %x is not in custom key scope %d'\",\n\t\t\t\tpubKeyBytes, keychain.BIP0043Purpose)\n\t\t}\n\n\t\t// We now have all the information we need to complete our key\n\t\t// locator information.\n\t\tsignDesc.KeyDesc.KeyLocator = keychain.KeyLocator{\n\t\t\tFamily: keychain.KeyFamily(path.InternalAccount),\n\t\t\tIndex:  path.Index,\n\t\t}\n\n\t// Case 2: Family and index only. This case is easy, we can just go\n\t// ahead and derive the public key from the family and index and then\n\t// supply that information in the BIP32 derivation field.\n\tcase signDesc.KeyDesc.PubKey == nil && !signDesc.KeyDesc.IsEmpty():\n\t\tfullDesc, err := r.watchOnlyKeyRing.DeriveKey(\n\t\t\tsignDesc.KeyDesc.KeyLocator,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"error deriving key with \"+\n\t\t\t\t\"family %d and index %d from the watch-only \"+\n\t\t\t\t\"wallet: %v\",\n\t\t\t\tsignDesc.KeyDesc.KeyLocator.Family,\n\t\t\t\tsignDesc.KeyDesc.KeyLocator.Index, err)\n\t\t}\n\t\tsignDesc.KeyDesc.PubKey = fullDesc.PubKey\n\t}\n\n\t// Make sure we actually know about the input. We either have been\n\t// watching the UTXO on-chain or we have been given all the required\n\t// info in the sign descriptor.\n\tinfo, err := r.WalletController.FetchInputInfo(&txIn.PreviousOutPoint)\n\tswitch {\n\t// No error, we do have the full UTXO and derivation info available.\n\tcase err == nil:\n\t\tin.WitnessUtxo = &wire.TxOut{\n\t\t\tValue:    int64(info.Value),\n\t\t\tPkScript: info.PkScript,\n\t\t}\n\t\tin.NonWitnessUtxo = info.PrevTx\n\t\tin.Bip32Derivation = []*psbt.Bip32Derivation{info.Derivation}\n\n\t// The wallet doesn't know about this UTXO, so it's probably a TX that\n\t// we haven't published yet (e.g. a channel funding TX). So we need to\n\t// assemble everything from the sign descriptor. We won't be able to\n\t// supply a non-witness UTXO (=full TX of the input being spent) in this\n\t// case. That is no problem if the signing instance is another lnd\n\t// instance since we don't require it for pure witness inputs. But a\n\t// hardware wallet might require it for security reasons.\n\tcase signDesc.KeyDesc.PubKey != nil && signDesc.Output != nil:\n\t\tin.WitnessUtxo = signDesc.Output\n\t\tin.Bip32Derivation = []*psbt.Bip32Derivation{{\n\t\t\tBip32Path: []uint32{\n\t\t\t\tkeychain.BIP0043Purpose +\n\t\t\t\t\thdkeychain.HardenedKeyStart,\n\t\t\t\tr.netParams.HDCoinType +\n\t\t\t\t\thdkeychain.HardenedKeyStart,\n\t\t\t\tuint32(signDesc.KeyDesc.Family) +\n\t\t\t\t\thdkeychain.HardenedKeyStart,\n\t\t\t\t0,\n\t\t\t\tsignDesc.KeyDesc.Index,\n\t\t\t},\n\t\t\tPubKey: signDesc.KeyDesc.PubKey.SerializeCompressed(),\n\t\t}}\n\n\t\t// We need to specify a pk script in the witness UTXO, otherwise\n\t\t// the field becomes invalid when serialized as a PSBT. To avoid\n\t\t// running into a generic \"Invalid PSBT serialization format\"\n\t\t// error later, we return a more descriptive error now.\n\t\tif len(in.WitnessUtxo.PkScript) == 0 {\n\t\t\treturn nil, fmt.Errorf(\"error assembling UTXO \" +\n\t\t\t\t\"information, output not known to wallet and \" +\n\t\t\t\t\"no UTXO pk script provided in sign descriptor\")\n\t\t}\n\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"error assembling UTXO information, \"+\n\t\t\t\"wallet returned err='%v' and sign descriptor is \"+\n\t\t\t\"incomplete\", err)\n\t}\n\n\t// Assemble all other information about the input we have.\n\tin.RedeemScript = sigScript\n\tin.SighashType = signDesc.HashType\n\tin.WitnessScript = signDesc.WitnessScript\n\n\tif len(signDesc.SingleTweak) > 0 {\n\t\tin.Unknowns = append(in.Unknowns, &psbt.Unknown{\n\t\t\tKey:   btcwallet.PsbtKeyTypeInputSignatureTweakSingle,\n\t\t\tValue: signDesc.SingleTweak,\n\t\t})\n\t}\n\tif signDesc.DoubleTweak != nil {\n\t\tin.Unknowns = append(in.Unknowns, &psbt.Unknown{\n\t\t\tKey:   btcwallet.PsbtKeyTypeInputSignatureTweakDouble,\n\t\t\tValue: signDesc.DoubleTweak.Serialize(),\n\t\t})\n\t}\n\n\t// Add taproot specific fields.\n\tswitch signDesc.SignMethod {\n\tcase input.TaprootKeySpendBIP0086SignMethod,\n\t\tinput.TaprootKeySpendSignMethod:\n\n\t\t// The key identifying factor for a key spend is that we don't\n\t\t// provide any leaf hashes to signal we want a signature for the\n\t\t// key spend path (with the internal key).\n\t\td := in.Bip32Derivation[0]\n\t\tin.TaprootBip32Derivation = []*psbt.TaprootBip32Derivation{{\n\t\t\t// The x-only public key is just our compressed public\n\t\t\t// key without the first byte (type/parity).\n\t\t\tXOnlyPubKey:          d.PubKey[1:],\n\t\t\tLeafHashes:           nil,\n\t\t\tMasterKeyFingerprint: d.MasterKeyFingerprint,\n\t\t\tBip32Path:            d.Bip32Path,\n\t\t}}\n\n\t\t// If this is a BIP0086 key spend then the tap tweak is empty,\n\t\t// otherwise it's set to the Taproot root hash.\n\t\tin.TaprootMerkleRoot = signDesc.TapTweak\n\n\tcase input.TaprootScriptSpendSignMethod:\n\t\t// The script spend path is a bit more involved when doing it\n\t\t// through the PSBT method. We need to specify the leaf hash\n\t\t// that the signer should sign for.\n\t\tleaf := txscript.TapLeaf{\n\t\t\tLeafVersion: txscript.BaseLeafVersion,\n\t\t\tScript:      signDesc.WitnessScript,\n\t\t}\n\t\tleafHash := leaf.TapHash()\n\n\t\td := in.Bip32Derivation[0]\n\t\tin.TaprootBip32Derivation = []*psbt.TaprootBip32Derivation{{\n\t\t\tXOnlyPubKey:          d.PubKey[1:],\n\t\t\tLeafHashes:           [][]byte{leafHash[:]},\n\t\t\tMasterKeyFingerprint: d.MasterKeyFingerprint,\n\t\t\tBip32Path:            d.Bip32Path,\n\t\t}}\n\n\t\t// We also need to supply a control block. But because we don't\n\t\t// know the internal key nor the merkle proofs (both is not\n\t\t// supplied through the SignOutputRaw RPC) and is technically\n\t\t// not really needed by the signer (since we only want a\n\t\t// signature, the full witness stack is assembled by the caller\n\t\t// of this RPC), we can get by with faking certain information\n\t\t// that we don't have.\n\t\tfakeInternalKey, _ := btcec.ParsePubKey(d.PubKey)\n\t\tfakeKeyIsOdd := d.PubKey[0] == input.PubKeyFormatCompressedOdd\n\t\tcontrolBlock := txscript.ControlBlock{\n\t\t\tInternalKey:     fakeInternalKey,\n\t\t\tOutputKeyYIsOdd: fakeKeyIsOdd,\n\t\t\tLeafVersion:     leaf.LeafVersion,\n\t\t}\n\t\tblockBytes, err := controlBlock.ToBytes()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"error serializing control \"+\n\t\t\t\t\"block: %v\", err)\n\t\t}\n\n\t\tin.TaprootLeafScript = []*psbt.TaprootTapLeafScript{{\n\t\t\tControlBlock: blockBytes,\n\t\t\tScript:       leaf.Script,\n\t\t\tLeafVersion:  leaf.LeafVersion,\n\t\t}}\n\t}\n\n\t// Okay, let's sign the input by the remote signer now.\n\tctxt, cancel := context.WithTimeout(context.Background(), r.rpcTimeout)\n\tdefer cancel()\n\n\tvar buf bytes.Buffer\n\tif err := packet.Serialize(&buf); err != nil {\n\t\treturn nil, fmt.Errorf(\"error serializing PSBT: %v\", err)\n\t}\n\n\tresp, err := r.walletClient.SignPsbt(\n\t\tctxt, &walletrpc.SignPsbtRequest{FundedPsbt: buf.Bytes()},\n\t)\n\tif err != nil {\n\t\tconsiderShutdown(err)\n\t\treturn nil, fmt.Errorf(\"error signing PSBT in remote signer \"+\n\t\t\t\"instance: %v\", err)\n\t}\n\n\tsignedPacket, err := psbt.NewFromRawBytes(\n\t\tbytes.NewReader(resp.SignedPsbt), false,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error parsing signed PSBT: %v\", err)\n\t}\n\n\t// We expect a signature in the input now.\n\tif signDesc.InputIndex >= len(signedPacket.Inputs) {\n\t\treturn nil, fmt.Errorf(\"remote signer returned invalid PSBT\")\n\t}\n\tin = &signedPacket.Inputs[signDesc.InputIndex]\n\n\treturn extractSignature(in, signDesc.SignMethod)\n}\n\n// extractSignature attempts to extract the signature from the PSBT input,\n// looking at different fields depending on the signing method that was used.",
      "length": 10400,
      "tokens": 1390,
      "embedding": []
    },
    {
      "slug": "func extractSignature(in *psbt.PInput,",
      "content": "func extractSignature(in *psbt.PInput,\n\tsignMethod input.SignMethod) (input.Signature, error) {\n\n\tswitch signMethod {\n\tcase input.WitnessV0SignMethod:\n\t\tif len(in.PartialSigs) != 1 {\n\t\t\treturn nil, fmt.Errorf(\"remote signer returned \"+\n\t\t\t\t\"invalid partial signature, wanted 1, got %d\",\n\t\t\t\tlen(in.PartialSigs))\n\t\t}\n\t\tsigWithSigHash := in.PartialSigs[0]\n\t\tif sigWithSigHash == nil {\n\t\t\treturn nil, fmt.Errorf(\"remote signer returned nil \" +\n\t\t\t\t\"signature\")\n\t\t}\n\n\t\t// The remote signer always adds the sighash type, so we need to\n\t\t// account for that.\n\t\tsigLen := len(sigWithSigHash.Signature)\n\t\tif sigLen < ecdsa.MinSigLen+1 {\n\t\t\treturn nil, fmt.Errorf(\"remote signer returned \"+\n\t\t\t\t\"invalid partial signature: signature too \"+\n\t\t\t\t\"short with %d bytes\", sigLen)\n\t\t}\n\n\t\t// Parse the signature, but chop off the last byte which is the\n\t\t// sighash type.\n\t\tsig := sigWithSigHash.Signature[0 : sigLen-1]\n\t\treturn ecdsa.ParseDERSignature(sig)\n\n\t// The type of key spend doesn't matter, the signature should be in the\n\t// same field for both of those signing methods.\n\tcase input.TaprootKeySpendBIP0086SignMethod,\n\t\tinput.TaprootKeySpendSignMethod:\n\n\t\tsigLen := len(in.TaprootKeySpendSig)\n\t\tif sigLen < schnorr.SignatureSize {\n\t\t\treturn nil, fmt.Errorf(\"remote signer returned \"+\n\t\t\t\t\"invalid key spend signature: signature too \"+\n\t\t\t\t\"short with %d bytes\", sigLen)\n\t\t}\n\n\t\treturn schnorr.ParseSignature(\n\t\t\tin.TaprootKeySpendSig[:schnorr.SignatureSize],\n\t\t)\n\n\tcase input.TaprootScriptSpendSignMethod:\n\t\tif len(in.TaprootScriptSpendSig) != 1 {\n\t\t\treturn nil, fmt.Errorf(\"remote signer returned \"+\n\t\t\t\t\"invalid taproot script spend signature, \"+\n\t\t\t\t\"wanted 1, got %d\",\n\t\t\t\tlen(in.TaprootScriptSpendSig))\n\t\t}\n\t\tscriptSpendSig := in.TaprootScriptSpendSig[0]\n\t\tif scriptSpendSig == nil {\n\t\t\treturn nil, fmt.Errorf(\"remote signer returned nil \" +\n\t\t\t\t\"taproot script spend signature\")\n\t\t}\n\n\t\treturn schnorr.ParseSignature(scriptSpendSig.Signature)\n\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"can't extract signature, unsupported \"+\n\t\t\t\"signing method: %v\", signMethod)\n\t}\n}\n\n// connectRPC tries to establish an RPC connection to the given host:port with\n// the supplied certificate and macaroon.",
      "length": 2075,
      "tokens": 252,
      "embedding": []
    },
    {
      "slug": "func connectRPC(hostPort, tlsCertPath, macaroonPath string,",
      "content": "func connectRPC(hostPort, tlsCertPath, macaroonPath string,\n\ttimeout time.Duration) (*grpc.ClientConn, error) {\n\n\tcertBytes, err := ioutil.ReadFile(tlsCertPath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error reading TLS cert file %v: %v\",\n\t\t\ttlsCertPath, err)\n\t}\n\n\tcp := x509.NewCertPool()\n\tif !cp.AppendCertsFromPEM(certBytes) {\n\t\treturn nil, fmt.Errorf(\"credentials: failed to append \" +\n\t\t\t\"certificate\")\n\t}\n\n\tmacBytes, err := ioutil.ReadFile(macaroonPath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error reading macaroon file %v: %v\",\n\t\t\tmacaroonPath, err)\n\t}\n\tmac := &macaroon.Macaroon{}\n\tif err := mac.UnmarshalBinary(macBytes); err != nil {\n\t\treturn nil, fmt.Errorf(\"error decoding macaroon: %v\", err)\n\t}\n\n\tmacCred, err := macaroons.NewMacaroonCredential(mac)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error creating creds: %v\", err)\n\t}\n\n\topts := []grpc.DialOption{\n\t\tgrpc.WithTransportCredentials(credentials.NewClientTLSFromCert(\n\t\t\tcp, \"\",\n\t\t)),\n\t\tgrpc.WithPerRPCCredentials(macCred),\n\t\tgrpc.WithBlock(),\n\t}\n\tctxt, cancel := context.WithTimeout(context.Background(), timeout)\n\tdefer cancel()\n\tconn, err := grpc.DialContext(ctxt, hostPort, opts...)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to connect to RPC server: %v\",\n\t\t\terr)\n\t}\n\n\treturn conn, nil\n}\n\n// packetFromTx creates a PSBT from a tx that potentially already contains\n// signed inputs.",
      "length": 1260,
      "tokens": 156,
      "embedding": []
    },
    {
      "slug": "func packetFromTx(original *wire.MsgTx) (*psbt.Packet, error) {",
      "content": "func packetFromTx(original *wire.MsgTx) (*psbt.Packet, error) {\n\t// The psbt.NewFromUnsignedTx function complains if there are any\n\t// scripts or witness content on a TX. So we create a copy of the TX and\n\t// nil out all the offending data, but also keep a backup around that we\n\t// add to the PSBT afterwards.\n\tnoSigs := original.Copy()\n\tfor idx := range noSigs.TxIn {\n\t\tnoSigs.TxIn[idx].SignatureScript = nil\n\t\tnoSigs.TxIn[idx].Witness = nil\n\t}\n\n\t// With all the data that is seen as \"signed\", we can now create the\n\t// empty packet.\n\tpacket, err := psbt.NewFromUnsignedTx(noSigs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar buf bytes.Buffer\n\tfor idx, txIn := range original.TxIn {\n\t\tif len(txIn.SignatureScript) > 0 {\n\t\t\tpacket.Inputs[idx].FinalScriptSig = txIn.SignatureScript\n\t\t}\n\n\t\tif len(txIn.Witness) > 0 {\n\t\t\tbuf.Reset()\n\t\t\terr = psbt.WriteTxWitness(&buf, txIn.Witness)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tpacket.Inputs[idx].FinalScriptWitness = buf.Bytes()\n\t\t}\n\t}\n\n\treturn packet, nil\n}\n\n// considerShutdown inspects the error and issues a shutdown (through logging\n// a critical error, which will cause the logger to issue a clean shutdown\n// request) if the error looks like a connection or general availability error\n// and not some application specific problem.",
      "length": 1183,
      "tokens": 186,
      "embedding": []
    },
    {
      "slug": "func considerShutdown(err error) {",
      "content": "func considerShutdown(err error) {\n\tstatusErr, isStatusErr := status.FromError(err)\n\tswitch {\n\t// The context attached to the client request has timed out. This can be\n\t// due to not being able to reach the signing server, or it's taking too\n\t// long to respond. In either case, request a shutdown.\n\tcase err == context.DeadlineExceeded:\n\t\tfallthrough\n\n\t// The signing server's context timed out before the client's due to\n\t// clock skew, request a shutdown anyway.\n\tcase isStatusErr && statusErr.Code() == codes.DeadlineExceeded:\n\t\tlog.Critical(\"RPC signing timed out: %v\", err)\n\n\tcase isStatusErr && statusErr.Code() == codes.Unavailable:\n\t\tlog.Critical(\"RPC signing server not available: %v\", err)\n\t}\n}\n",
      "length": 654,
      "tokens": 96,
      "embedding": []
    }
  ]
}