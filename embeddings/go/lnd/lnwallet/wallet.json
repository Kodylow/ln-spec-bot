{
  "filepath": "../implementations/go/lnd/lnwallet/wallet.go",
  "package": "lnwallet",
  "sections": [
    {
      "slug": "type PsbtFundingRequired struct {",
      "content": "type PsbtFundingRequired struct {\n\t// Intent is the pending PSBT funding intent that needs to be funded\n\t// if the wrapping error is returned.\n\tIntent *chanfunding.PsbtIntent\n}\n\n// Error returns the underlying error.\n//\n// NOTE: This method is part of the error interface.",
      "length": 231,
      "tokens": 40,
      "embedding": []
    },
    {
      "slug": "func (p *PsbtFundingRequired) Error() string {",
      "content": "func (p *PsbtFundingRequired) Error() string {\n\treturn ErrPsbtFundingRequired.Error()\n}\n\n// InitFundingReserveMsg is the first message sent to initiate the workflow\n// required to open a payment channel with a remote peer. The initial required\n// parameters are configurable across channels. These parameters are to be\n// chosen depending on the fee climate within the network, and time value of\n// funds to be locked up within the channel. Upon success a ChannelReservation\n// will be created in order to track the lifetime of this pending channel.\n// Outputs selected will be 'locked', making them unavailable, for any other\n// pending reservations. Therefore, all channels in reservation limbo will be\n// periodically timed out after an idle period in order to avoid \"exhaustion\"\n// attacks.",
      "length": 735,
      "tokens": 118,
      "embedding": []
    },
    {
      "slug": "type InitFundingReserveMsg struct {",
      "content": "type InitFundingReserveMsg struct {\n\t// ChainHash denotes that chain to be used to ultimately open the\n\t// target channel.\n\tChainHash *chainhash.Hash\n\n\t// PendingChanID is the pending channel ID for this funding flow as\n\t// used in the wire protocol.\n\tPendingChanID [32]byte\n\n\t// NodeID is the ID of the remote node we would like to open a channel\n\t// with.\n\tNodeID *btcec.PublicKey\n\n\t// NodeAddr is the address port that we used to either establish or\n\t// accept the connection which led to the negotiation of this funding\n\t// workflow.\n\tNodeAddr net.Addr\n\n\t// SubtractFees should be set if we intend to spend exactly\n\t// LocalFundingAmt when opening the channel, subtracting the fees from\n\t// the funding output. This can be used for instance to use all our\n\t// remaining funds to open the channel, since it will take fees into\n\t// account.\n\tSubtractFees bool\n\n\t// LocalFundingAmt is the amount of funds requested from us for this\n\t// channel.\n\tLocalFundingAmt btcutil.Amount\n\n\t// RemoteFundingAmnt is the amount of funds the remote will contribute\n\t// to this channel.\n\tRemoteFundingAmt btcutil.Amount\n\n\t// CommitFeePerKw is the starting accepted satoshis/Kw fee for the set\n\t// of initial commitment transactions. In order to ensure timely\n\t// confirmation, it is recommended that this fee should be generous,\n\t// paying some multiple of the accepted base fee rate of the network.\n\tCommitFeePerKw chainfee.SatPerKWeight\n\n\t// FundingFeePerKw is the fee rate in sat/kw to use for the initial\n\t// funding transaction.\n\tFundingFeePerKw chainfee.SatPerKWeight\n\n\t// PushMSat is the number of milli-satoshis that should be pushed over\n\t// the responder as part of the initial channel creation.\n\tPushMSat lnwire.MilliSatoshi\n\n\t// Flags are the channel flags specified by the initiator in the\n\t// open_channel message.\n\tFlags lnwire.FundingFlag\n\n\t// MinConfs indicates the minimum number of confirmations that each\n\t// output selected to fund the channel should satisfy.\n\tMinConfs int32\n\n\t// CommitType indicates what type of commitment type the channel should\n\t// be using, like tweakless or anchors.\n\tCommitType CommitmentType\n\n\t// ChanFunder is an optional channel funder that allows the caller to\n\t// control exactly how the channel funding is carried out. If not\n\t// specified, then the default chanfunding.WalletAssembler will be\n\t// used.\n\tChanFunder chanfunding.Assembler\n\n\t// ZeroConf is a boolean that is true if a zero-conf channel was\n\t// negotiated.\n\tZeroConf bool\n\n\t// OptionScidAlias is a boolean that is true if an option-scid-alias\n\t// channel type was explicitly negotiated.\n\tOptionScidAlias bool\n\n\t// ScidAliasFeature is true if the option-scid-alias feature bit was\n\t// negotiated.\n\tScidAliasFeature bool\n\n\t// err is a channel in which all errors will be sent across. Will be\n\t// nil if this initial set is successful.\n\t//\n\t// NOTE: In order to avoid deadlocks, this channel MUST be buffered.\n\terr chan error\n\n\t// resp is channel in which a ChannelReservation with our contributions\n\t// filled in will be sent across this channel in the case of a\n\t// successfully reservation initiation. In the case of an error, this\n\t// will read a nil pointer.\n\t//\n\t// NOTE: In order to avoid deadlocks, this channel MUST be buffered.\n\tresp chan *ChannelReservation\n}\n\n// fundingReserveCancelMsg is a message reserved for cancelling an existing\n// channel reservation identified by its reservation ID. Cancelling a reservation\n// frees its locked outputs up, for inclusion within further reservations.",
      "length": 3373,
      "tokens": 534,
      "embedding": []
    },
    {
      "slug": "type fundingReserveCancelMsg struct {",
      "content": "type fundingReserveCancelMsg struct {\n\tpendingFundingID uint64\n\n\t// NOTE: In order to avoid deadlocks, this channel MUST be buffered.\n\terr chan error // Buffered\n}\n\n// addContributionMsg represents a message executing the second phase of the\n// channel reservation workflow. This message carries the counterparty's\n// \"contribution\" to the payment channel. In the case that this message is\n// processed without generating any errors, then channel reservation will then\n// be able to construct the funding tx, both commitment transactions, and\n// finally generate signatures for all our inputs to the funding transaction,\n// and for the remote node's version of the commitment transaction.",
      "length": 638,
      "tokens": 99,
      "embedding": []
    },
    {
      "slug": "type addContributionMsg struct {",
      "content": "type addContributionMsg struct {\n\tpendingFundingID uint64\n\n\t// TODO(roasbeef): Should also carry SPV proofs in we're in SPV mode\n\tcontribution *ChannelContribution\n\n\t// NOTE: In order to avoid deadlocks, this channel MUST be buffered.\n\terr chan error\n}\n\n// continueContributionMsg represents a message that signals that the\n// interrupted funding process involving a PSBT can now be continued because the\n// finalized transaction is now available.",
      "length": 403,
      "tokens": 60,
      "embedding": []
    },
    {
      "slug": "type continueContributionMsg struct {",
      "content": "type continueContributionMsg struct {\n\tpendingFundingID uint64\n\n\t// NOTE: In order to avoid deadlocks, this channel MUST be buffered.\n\terr chan error\n}\n\n// addSingleContributionMsg represents a message executing the second phase of\n// a single funder channel reservation workflow. This messages carries the\n// counterparty's \"contribution\" to the payment channel. As this message is\n// sent when on the responding side to a single funder workflow, no further\n// action apart from storing the provided contribution is carried out.",
      "length": 481,
      "tokens": 75,
      "embedding": []
    },
    {
      "slug": "type addSingleContributionMsg struct {",
      "content": "type addSingleContributionMsg struct {\n\tpendingFundingID uint64\n\n\tcontribution *ChannelContribution\n\n\t// NOTE: In order to avoid deadlocks, this channel MUST be buffered.\n\terr chan error\n}\n\n// addCounterPartySigsMsg represents the final message required to complete,\n// and 'open' a payment channel. This message carries the counterparty's\n// signatures for each of their inputs to the funding transaction, and also a\n// signature allowing us to spend our version of the commitment transaction.\n// If we're able to verify all the signatures are valid, the funding transaction\n// will be broadcast to the network. After the funding transaction gains a\n// configurable number of confirmations, the channel is officially considered\n// 'open'.",
      "length": 685,
      "tokens": 105,
      "embedding": []
    },
    {
      "slug": "type addCounterPartySigsMsg struct {",
      "content": "type addCounterPartySigsMsg struct {\n\tpendingFundingID uint64\n\n\t// Should be order of sorted inputs that are theirs. Sorting is done\n\t// in accordance to BIP-69:\n\t// https://github.com/bitcoin/bips/blob/master/bip-0069.mediawiki.\n\ttheirFundingInputScripts []*input.Script\n\n\t// This should be 1/2 of the signatures needed to successfully spend our\n\t// version of the commitment transaction.\n\ttheirCommitmentSig input.Signature\n\n\t// This channel is used to return the completed channel after the wallet\n\t// has completed all of its stages in the funding process.\n\tcompleteChan chan *channeldb.OpenChannel\n\n\t// NOTE: In order to avoid deadlocks, this channel MUST be buffered.\n\terr chan error\n}\n\n// addSingleFunderSigsMsg represents the next-to-last message required to\n// complete a single-funder channel workflow. Once the initiator is able to\n// construct the funding transaction, they send both the outpoint and a\n// signature for our version of the commitment transaction. Once this message\n// is processed we (the responder) are able to construct both commitment\n// transactions, signing the remote party's version.",
      "length": 1057,
      "tokens": 151,
      "embedding": []
    },
    {
      "slug": "type addSingleFunderSigsMsg struct {",
      "content": "type addSingleFunderSigsMsg struct {\n\tpendingFundingID uint64\n\n\t// fundingOutpoint is the outpoint of the completed funding\n\t// transaction as assembled by the workflow initiator.\n\tfundingOutpoint *wire.OutPoint\n\n\t// theirCommitmentSig are the 1/2 of the signatures needed to\n\t// successfully spend our version of the commitment transaction.\n\ttheirCommitmentSig input.Signature\n\n\t// This channel is used to return the completed channel after the wallet\n\t// has completed all of its stages in the funding process.\n\tcompleteChan chan *channeldb.OpenChannel\n\n\t// NOTE: In order to avoid deadlocks, this channel MUST be buffered.\n\terr chan error\n}\n\n// CheckReservedValueTxReq is the request struct used to call\n// CheckReservedValueTx with. It contains the transaction to check as well as\n// an optional explicitly defined index to denote a change output that is not\n// watched by the wallet.",
      "length": 830,
      "tokens": 125,
      "embedding": []
    },
    {
      "slug": "type CheckReservedValueTxReq struct {",
      "content": "type CheckReservedValueTxReq struct {\n\t// Tx is the transaction to check the outputs for.\n\tTx *wire.MsgTx\n\n\t// ChangeIndex denotes an optional output index that can be explicitly\n\t// set for a change that is not being watched by the wallet and would\n\t// otherwise not be recognized as a change output.\n\tChangeIndex *int\n}\n\n// LightningWallet is a domain specific, yet general Bitcoin wallet capable of\n// executing workflow required to interact with the Lightning Network. It is\n// domain specific in the sense that it understands all the fancy scripts used\n// within the Lightning Network, channel lifetimes, etc. However, it embeds a\n// general purpose Bitcoin wallet within it. Therefore, it is also able to\n// serve as a regular Bitcoin wallet which uses HD keys. The wallet is highly\n// concurrent internally. All communication, and requests towards the wallet\n// are dispatched as messages over channels, ensuring thread safety across all\n// operations. Interaction has been designed independent of any peer-to-peer\n// communication protocol, allowing the wallet to be self-contained and\n// embeddable within future projects interacting with the Lightning Network.\n//\n// NOTE: At the moment the wallet requires a btcd full node, as it's dependent\n// on btcd's websockets notifications as event triggers during the lifetime of a\n// channel. However, once the chainntnfs package is complete, the wallet will\n// be compatible with multiple RPC/notification services such as Electrum,\n// Bitcoin Core + ZeroMQ, etc. Eventually, the wallet won't require a full-node\n// at all, as SPV support is integrated into btcwallet.",
      "length": 1558,
      "tokens": 254,
      "embedding": []
    },
    {
      "slug": "type LightningWallet struct {",
      "content": "type LightningWallet struct {\n\tstarted  int32 // To be used atomically.\n\tshutdown int32 // To be used atomically.\n\n\tnextFundingID uint64 // To be used atomically.\n\n\t// Cfg is the configuration struct that will be used by the wallet to\n\t// access the necessary interfaces and default it needs to carry on its\n\t// duties.\n\tCfg Config\n\n\t// WalletController is the core wallet, all non Lightning Network\n\t// specific interaction is proxied to the internal wallet.\n\tWalletController\n\n\t// SecretKeyRing is the interface we'll use to derive any keys related\n\t// to our purpose within the network including: multi-sig keys, node\n\t// keys, revocation keys, etc.\n\tkeychain.SecretKeyRing\n\n\t// This mutex MUST be held when performing coin selection in order to\n\t// avoid inadvertently creating multiple funding transaction which\n\t// double spend inputs across each other.\n\tcoinSelectMtx sync.RWMutex\n\n\t// All messages to the wallet are to be sent across this channel.\n\tmsgChan chan interface{}\n\n\t// Incomplete payment channels are stored in the map below. An intent\n\t// to create a payment channel is tracked as a \"reservation\" within\n\t// limbo. Once the final signatures have been exchanged, a reservation\n\t// is removed from limbo. Each reservation is tracked by a unique\n\t// monotonically integer. All requests concerning the channel MUST\n\t// carry a valid, active funding ID.\n\tfundingLimbo map[uint64]*ChannelReservation\n\n\t// reservationIDs maps a pending channel ID to the reservation ID used\n\t// as key in the fundingLimbo map. Used to easily look up a channel\n\t// reservation given a pending channel ID.\n\treservationIDs map[[32]byte]uint64\n\tlimboMtx       sync.RWMutex\n\n\t// lockedOutPoints is a set of the currently locked outpoint. This\n\t// information is kept in order to provide an easy way to unlock all\n\t// the currently locked outpoints.\n\tlockedOutPoints map[wire.OutPoint]struct{}\n\n\t// fundingIntents houses all the \"interception\" registered by a caller\n\t// using the RegisterFundingIntent method.\n\tintentMtx      sync.RWMutex\n\tfundingIntents map[[32]byte]chanfunding.Intent\n\n\tquit chan struct{}\n\n\twg sync.WaitGroup\n\n\t// TODO(roasbeef): handle wallet lock/unlock\n}\n\n// NewLightningWallet creates/opens and initializes a LightningWallet instance.\n// If the wallet has never been created (according to the passed dataDir), first-time\n// setup is executed.",
      "length": 2265,
      "tokens": 337,
      "embedding": []
    },
    {
      "slug": "func NewLightningWallet(Cfg Config) (*LightningWallet, error) {",
      "content": "func NewLightningWallet(Cfg Config) (*LightningWallet, error) {\n\n\treturn &LightningWallet{\n\t\tCfg:              Cfg,\n\t\tSecretKeyRing:    Cfg.SecretKeyRing,\n\t\tWalletController: Cfg.WalletController,\n\t\tmsgChan:          make(chan interface{}, msgBufferSize),\n\t\tnextFundingID:    0,\n\t\tfundingLimbo:     make(map[uint64]*ChannelReservation),\n\t\treservationIDs:   make(map[[32]byte]uint64),\n\t\tlockedOutPoints:  make(map[wire.OutPoint]struct{}),\n\t\tfundingIntents:   make(map[[32]byte]chanfunding.Intent),\n\t\tquit:             make(chan struct{}),\n\t}, nil\n}\n\n// Startup establishes a connection to the RPC source, and spins up all\n// goroutines required to handle incoming messages.",
      "length": 592,
      "tokens": 48,
      "embedding": []
    },
    {
      "slug": "func (l *LightningWallet) Startup() error {",
      "content": "func (l *LightningWallet) Startup() error {\n\t// Already started?\n\tif atomic.AddInt32(&l.started, 1) != 1 {\n\t\treturn nil\n\t}\n\n\t// Start the underlying wallet controller.\n\tif err := l.Start(); err != nil {\n\t\treturn err\n\t}\n\n\tl.wg.Add(1)\n\t// TODO(roasbeef): multiple request handlers?\n\tgo l.requestHandler()\n\n\treturn nil\n}\n\n// Shutdown gracefully stops the wallet, and all active goroutines.",
      "length": 325,
      "tokens": 50,
      "embedding": []
    },
    {
      "slug": "func (l *LightningWallet) Shutdown() error {",
      "content": "func (l *LightningWallet) Shutdown() error {\n\tif atomic.AddInt32(&l.shutdown, 1) != 1 {\n\t\treturn nil\n\t}\n\n\t// Signal the underlying wallet controller to shutdown, waiting until\n\t// all active goroutines have been shutdown.\n\tif err := l.Stop(); err != nil {\n\t\treturn err\n\t}\n\n\tclose(l.quit)\n\tl.wg.Wait()\n\treturn nil\n}\n\n// ConfirmedBalance returns the current confirmed balance of a wallet account.\n// This methods wraps the internal WalletController method so we're able to\n// properly hold the coin select mutex while we compute the balance.",
      "length": 477,
      "tokens": 77,
      "embedding": []
    },
    {
      "slug": "func (l *LightningWallet) ConfirmedBalance(confs int32,",
      "content": "func (l *LightningWallet) ConfirmedBalance(confs int32,\n\taccount string) (btcutil.Amount, error) {\n\n\tl.coinSelectMtx.Lock()\n\tdefer l.coinSelectMtx.Unlock()\n\n\treturn l.WalletController.ConfirmedBalance(confs, account)\n}\n\n// ListUnspentWitnessFromDefaultAccount returns all unspent outputs from the\n// default wallet account which are version 0 witness programs. The 'minConfs'\n// and 'maxConfs' parameters indicate the minimum and maximum number of\n// confirmations an output needs in order to be returned by this method. Passing\n// -1 as 'minConfs' indicates that even unconfirmed outputs should be returned.\n// Using MaxInt32 as 'maxConfs' implies returning all outputs with at least\n// 'minConfs'.\n//\n// NOTE: This method requires the global coin selection lock to be held.",
      "length": 703,
      "tokens": 97,
      "embedding": []
    },
    {
      "slug": "func (l *LightningWallet) ListUnspentWitnessFromDefaultAccount(",
      "content": "func (l *LightningWallet) ListUnspentWitnessFromDefaultAccount(\n\tminConfs, maxConfs int32) ([]*Utxo, error) {\n\n\treturn l.WalletController.ListUnspentWitness(\n\t\tminConfs, maxConfs, DefaultAccountName,\n\t)\n}\n\n// LockedOutpoints returns a list of all currently locked outpoint.",
      "length": 202,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (l *LightningWallet) LockedOutpoints() []*wire.OutPoint {",
      "content": "func (l *LightningWallet) LockedOutpoints() []*wire.OutPoint {\n\toutPoints := make([]*wire.OutPoint, 0, len(l.lockedOutPoints))\n\tfor outPoint := range l.lockedOutPoints {\n\t\toutPoint := outPoint\n\n\t\toutPoints = append(outPoints, &outPoint)\n\t}\n\n\treturn outPoints\n}\n\n// ResetReservations reset the volatile wallet state which tracks all currently\n// active reservations.",
      "length": 291,
      "tokens": 36,
      "embedding": []
    },
    {
      "slug": "func (l *LightningWallet) ResetReservations() {",
      "content": "func (l *LightningWallet) ResetReservations() {\n\tl.nextFundingID = 0\n\tl.fundingLimbo = make(map[uint64]*ChannelReservation)\n\tl.reservationIDs = make(map[[32]byte]uint64)\n\n\tfor outpoint := range l.lockedOutPoints {\n\t\tl.UnlockOutpoint(outpoint)\n\t}\n\tl.lockedOutPoints = make(map[wire.OutPoint]struct{})\n}\n\n// ActiveReservations returns a slice of all the currently active\n// (non-canceled) reservations.",
      "length": 341,
      "tokens": 34,
      "embedding": []
    },
    {
      "slug": "func (l *LightningWallet) ActiveReservations() []*ChannelReservation {",
      "content": "func (l *LightningWallet) ActiveReservations() []*ChannelReservation {\n\treservations := make([]*ChannelReservation, 0, len(l.fundingLimbo))\n\tfor _, reservation := range l.fundingLimbo {\n\t\treservations = append(reservations, reservation)\n\t}\n\n\treturn reservations\n}\n\n// requestHandler is the primary goroutine(s) responsible for handling, and\n// dispatching replies to all messages.",
      "length": 300,
      "tokens": 36,
      "embedding": []
    },
    {
      "slug": "func (l *LightningWallet) requestHandler() {",
      "content": "func (l *LightningWallet) requestHandler() {\n\tdefer l.wg.Done()\n\nout:\n\tfor {\n\t\tselect {\n\t\tcase m := <-l.msgChan:\n\t\t\tswitch msg := m.(type) {\n\t\t\tcase *InitFundingReserveMsg:\n\t\t\t\tl.handleFundingReserveRequest(msg)\n\t\t\tcase *fundingReserveCancelMsg:\n\t\t\t\tl.handleFundingCancelRequest(msg)\n\t\t\tcase *addSingleContributionMsg:\n\t\t\t\tl.handleSingleContribution(msg)\n\t\t\tcase *addContributionMsg:\n\t\t\t\tl.handleContributionMsg(msg)\n\t\t\tcase *continueContributionMsg:\n\t\t\t\tl.handleChanPointReady(msg)\n\t\t\tcase *addSingleFunderSigsMsg:\n\t\t\t\tl.handleSingleFunderSigs(msg)\n\t\t\tcase *addCounterPartySigsMsg:\n\t\t\t\tl.handleFundingCounterPartySigs(msg)\n\t\t\t}\n\t\tcase <-l.quit:\n\t\t\t// TODO: do some clean up\n\t\t\tbreak out\n\t\t}\n\t}\n}\n\n// InitChannelReservation kicks off the 3-step workflow required to successfully\n// open a payment channel with a remote node. As part of the funding\n// reservation, the inputs selected for the funding transaction are 'locked'.\n// This ensures that multiple channel reservations aren't double spending the\n// same inputs in the funding transaction. If reservation initialization is\n// successful, a ChannelReservation containing our completed contribution is\n// returned. Our contribution contains all the items necessary to allow the\n// counterparty to build the funding transaction, and both versions of the\n// commitment transaction. Otherwise, an error occurred and a nil pointer along\n// with an error are returned.\n//\n// Once a ChannelReservation has been obtained, two additional steps must be\n// processed before a payment channel can be considered 'open'. The second step\n// validates, and processes the counterparty's channel contribution. The third,\n// and final step verifies all signatures for the inputs of the funding\n// transaction, and that the signature we record for our version of the\n// commitment transaction is valid.",
      "length": 1748,
      "tokens": 226,
      "embedding": []
    },
    {
      "slug": "func (l *LightningWallet) InitChannelReservation(",
      "content": "func (l *LightningWallet) InitChannelReservation(\n\treq *InitFundingReserveMsg) (*ChannelReservation, error) {\n\n\treq.resp = make(chan *ChannelReservation, 1)\n\treq.err = make(chan error, 1)\n\n\tselect {\n\tcase l.msgChan <- req:\n\tcase <-l.quit:\n\t\treturn nil, errors.New(\"wallet shutting down\")\n\t}\n\n\treturn <-req.resp, <-req.err\n}\n\n// RegisterFundingIntent allows a caller to signal to the wallet that if a\n// pending channel ID of expectedID is found, then it can skip constructing a\n// new chanfunding.Assembler, and instead use the specified chanfunding.Intent.\n// As an example, this lets some of the parameters for funding transaction to\n// be negotiated outside the regular funding protocol.",
      "length": 622,
      "tokens": 91,
      "embedding": []
    },
    {
      "slug": "func (l *LightningWallet) RegisterFundingIntent(expectedID [32]byte,",
      "content": "func (l *LightningWallet) RegisterFundingIntent(expectedID [32]byte,\n\tshimIntent chanfunding.Intent) error {\n\n\tl.intentMtx.Lock()\n\tdefer l.intentMtx.Unlock()\n\n\tif _, ok := l.fundingIntents[expectedID]; ok {\n\t\treturn fmt.Errorf(\"pendingChanID(%x) already has intent \"+\n\t\t\t\"registered\", expectedID[:])\n\t}\n\n\tl.fundingIntents[expectedID] = shimIntent\n\n\treturn nil\n}\n\n// PsbtFundingVerify looks up a previously registered funding intent by its\n// pending channel ID and tries to advance the state machine by verifying the\n// passed PSBT.",
      "length": 446,
      "tokens": 57,
      "embedding": []
    },
    {
      "slug": "func (l *LightningWallet) PsbtFundingVerify(pendingChanID [32]byte,",
      "content": "func (l *LightningWallet) PsbtFundingVerify(pendingChanID [32]byte,\n\tpacket *psbt.Packet, skipFinalize bool) error {\n\n\tl.intentMtx.Lock()\n\tdefer l.intentMtx.Unlock()\n\n\tintent, ok := l.fundingIntents[pendingChanID]\n\tif !ok {\n\t\treturn fmt.Errorf(\"no funding intent found for \"+\n\t\t\t\"pendingChannelID(%x)\", pendingChanID[:])\n\t}\n\tpsbtIntent, ok := intent.(*chanfunding.PsbtIntent)\n\tif !ok {\n\t\treturn fmt.Errorf(\"incompatible funding intent\")\n\t}\n\n\tif skipFinalize && psbtIntent.ShouldPublishFundingTX() {\n\t\treturn fmt.Errorf(\"cannot set skip_finalize for channel that \" +\n\t\t\t\"did not set no_publish\")\n\t}\n\n\terr := psbtIntent.Verify(packet, skipFinalize)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error verifying PSBT: %v\", err)\n\t}\n\n\t// Get the channel reservation for that corresponds to this pending\n\t// channel ID.\n\tl.limboMtx.Lock()\n\tpid, ok := l.reservationIDs[pendingChanID]\n\tif !ok {\n\t\tl.limboMtx.Unlock()\n\t\treturn fmt.Errorf(\"no channel reservation found for \"+\n\t\t\t\"pendingChannelID(%x)\", pendingChanID[:])\n\t}\n\n\tpendingReservation, ok := l.fundingLimbo[pid]\n\tl.limboMtx.Unlock()\n\n\tif !ok {\n\t\treturn fmt.Errorf(\"no channel reservation found for \"+\n\t\t\t\"reservation ID %v\", pid)\n\t}\n\n\t// Now the the PSBT has been populated and verified, we can again check\n\t// whether the value reserved for anchor fee bumping is respected.\n\tisPublic := pendingReservation.partialState.ChannelFlags&lnwire.FFAnnounceChannel != 0\n\thasAnchors := pendingReservation.partialState.ChanType.HasAnchors()\n\treturn l.enforceNewReservedValue(intent, isPublic, hasAnchors)\n}\n\n// PsbtFundingFinalize looks up a previously registered funding intent by its\n// pending channel ID and tries to advance the state machine by finalizing the\n// passed PSBT.",
      "length": 1593,
      "tokens": 192,
      "embedding": []
    },
    {
      "slug": "func (l *LightningWallet) PsbtFundingFinalize(pid [32]byte, packet *psbt.Packet,",
      "content": "func (l *LightningWallet) PsbtFundingFinalize(pid [32]byte, packet *psbt.Packet,\n\trawTx *wire.MsgTx) error {\n\n\tl.intentMtx.Lock()\n\tdefer l.intentMtx.Unlock()\n\n\tintent, ok := l.fundingIntents[pid]\n\tif !ok {\n\t\treturn fmt.Errorf(\"no funding intent found for \"+\n\t\t\t\"pendingChannelID(%x)\", pid[:])\n\t}\n\tpsbtIntent, ok := intent.(*chanfunding.PsbtIntent)\n\tif !ok {\n\t\treturn fmt.Errorf(\"incompatible funding intent\")\n\t}\n\n\t// Either the PSBT or the raw TX must be set.\n\tswitch {\n\tcase packet != nil && rawTx == nil:\n\t\terr := psbtIntent.Finalize(packet)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error finalizing PSBT: %v\", err)\n\t\t}\n\n\tcase rawTx != nil && packet == nil:\n\t\terr := psbtIntent.FinalizeRawTX(rawTx)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error finalizing raw TX: %v\", err)\n\t\t}\n\n\tdefault:\n\t\treturn fmt.Errorf(\"either a PSBT or raw TX must be specified\")\n\t}\n\n\treturn nil\n}\n\n// CancelFundingIntent allows a caller to cancel a previously registered\n// funding intent. If no intent was found, then an error will be returned.",
      "length": 903,
      "tokens": 135,
      "embedding": []
    },
    {
      "slug": "func (l *LightningWallet) CancelFundingIntent(pid [32]byte) error {",
      "content": "func (l *LightningWallet) CancelFundingIntent(pid [32]byte) error {\n\tl.intentMtx.Lock()\n\tdefer l.intentMtx.Unlock()\n\n\tintent, ok := l.fundingIntents[pid]\n\tif !ok {\n\t\treturn fmt.Errorf(\"no funding intent found for \"+\n\t\t\t\"pendingChannelID(%x)\", pid[:])\n\t}\n\n\t// Give the intent a chance to clean up after itself, removing coin\n\t// locks or similar reserved resources.\n\tintent.Cancel()\n\n\tdelete(l.fundingIntents, pid)\n\n\treturn nil\n}\n\n// handleFundingReserveRequest processes a message intending to create, and\n// validate a funding reservation request.",
      "length": 461,
      "tokens": 60,
      "embedding": []
    },
    {
      "slug": "func (l *LightningWallet) handleFundingReserveRequest(req *InitFundingReserveMsg) {",
      "content": "func (l *LightningWallet) handleFundingReserveRequest(req *InitFundingReserveMsg) {\n\t// It isn't possible to create a channel with zero funds committed.\n\tif req.LocalFundingAmt+req.RemoteFundingAmt == 0 {\n\t\terr := ErrZeroCapacity()\n\t\treq.err <- err\n\t\treq.resp <- nil\n\t\treturn\n\t}\n\n\t// If the funding request is for a different chain than the one the\n\t// wallet is aware of, then we'll reject the request.\n\tif !bytes.Equal(l.Cfg.NetParams.GenesisHash[:], req.ChainHash[:]) {\n\t\terr := ErrChainMismatch(\n\t\t\tl.Cfg.NetParams.GenesisHash, req.ChainHash,\n\t\t)\n\t\treq.err <- err\n\t\treq.resp <- nil\n\t\treturn\n\t}\n\n\t// We need to avoid enforcing reserved value in the middle of PSBT\n\t// funding because some of the following steps may add UTXOs funding\n\t// the on-chain wallet.\n\t// The enforcement still happens at the last step - in PsbtFundingVerify\n\tenforceNewReservedValue := true\n\n\t// If no chanFunder was provided, then we'll assume the default\n\t// assembler, which is backed by the wallet's internal coin selection.\n\tif req.ChanFunder == nil {\n\t\t// We use the P2WSH dust limit since it is larger than the\n\t\t// P2WPKH dust limit and to avoid threading through two\n\t\t// different dust limits.\n\t\tcfg := chanfunding.WalletConfig{\n\t\t\tCoinSource:       &CoinSource{l},\n\t\t\tCoinSelectLocker: l,\n\t\t\tCoinLocker:       l,\n\t\t\tSigner:           l.Cfg.Signer,\n\t\t\tDustLimit:        DustLimitForSize(input.P2WSHSize),\n\t\t}\n\t\treq.ChanFunder = chanfunding.NewWalletAssembler(cfg)\n\t} else {\n\t\t_, isPsbtFunder := req.ChanFunder.(*chanfunding.PsbtAssembler)\n\t\tenforceNewReservedValue = !isPsbtFunder\n\t}\n\n\tlocalFundingAmt := req.LocalFundingAmt\n\tremoteFundingAmt := req.RemoteFundingAmt\n\n\tvar (\n\t\tfundingIntent chanfunding.Intent\n\t\terr           error\n\t)\n\n\t// If we've just received an inbound funding request that we have a\n\t// registered shim intent to, then we'll obtain the backing intent now.\n\t// In this case, we're doing a special funding workflow that allows\n\t// more advanced constructions such as channel factories to be\n\t// instantiated.\n\tl.intentMtx.Lock()\n\tfundingIntent, ok := l.fundingIntents[req.PendingChanID]\n\tl.intentMtx.Unlock()\n\n\t// Otherwise, this is a normal funding flow, so we'll use the chan\n\t// funder in the attached request to provision the inputs/outputs\n\t// that'll ultimately be used to construct the funding transaction.\n\tif !ok {\n\t\t// Coin selection is done on the basis of sat/kw, so we'll use\n\t\t// the fee rate passed in to perform coin selection.\n\t\tvar err error\n\t\tfundingReq := &chanfunding.Request{\n\t\t\tRemoteAmt:    req.RemoteFundingAmt,\n\t\t\tLocalAmt:     req.LocalFundingAmt,\n\t\t\tMinConfs:     req.MinConfs,\n\t\t\tSubtractFees: req.SubtractFees,\n\t\t\tFeeRate:      req.FundingFeePerKw,\n\t\t\tChangeAddr: func() (btcutil.Address, error) {\n\t\t\t\treturn l.NewAddress(\n\t\t\t\t\tTaprootPubkey, true, DefaultAccountName,\n\t\t\t\t)\n\t\t\t},\n\t\t}\n\t\tfundingIntent, err = req.ChanFunder.ProvisionChannel(\n\t\t\tfundingReq,\n\t\t)\n\t\tif err != nil {\n\t\t\treq.err <- err\n\t\t\treq.resp <- nil\n\t\t\treturn\n\t\t}\n\n\t\t// Register the funding intent now in case we need to access it\n\t\t// again later, as it's the case for the PSBT state machine for\n\t\t// example.\n\t\terr = l.RegisterFundingIntent(req.PendingChanID, fundingIntent)\n\t\tif err != nil {\n\t\t\treq.err <- err\n\t\t\treq.resp <- nil\n\t\t\treturn\n\t\t}\n\n\t\twalletLog.Debugf(\"Registered funding intent for \"+\n\t\t\t\"PendingChanID: %x\", req.PendingChanID)\n\n\t\tlocalFundingAmt = fundingIntent.LocalFundingAmt()\n\t\tremoteFundingAmt = fundingIntent.RemoteFundingAmt()\n\t}\n\n\t// At this point there _has_ to be a funding intent, otherwise something\n\t// went really wrong.\n\tif fundingIntent == nil {\n\t\treq.err <- fmt.Errorf(\"no funding intent present\")\n\t\treq.resp <- nil\n\t\treturn\n\t}\n\n\t// If this is a shim intent, then it may be attempting to use an\n\t// existing set of keys for the funding workflow. In this case, we'll\n\t// make a simple wrapper keychain.KeyRing that will proxy certain\n\t// derivation calls to future callers.\n\tvar (\n\t\tkeyRing    keychain.KeyRing = l.SecretKeyRing\n\t\tthawHeight uint32\n\t)\n\tif shimIntent, ok := fundingIntent.(*chanfunding.ShimIntent); ok {\n\t\tkeyRing = &shimKeyRing{\n\t\t\tKeyRing:    keyRing,\n\t\t\tShimIntent: shimIntent,\n\t\t}\n\n\t\t// As this was a registered shim intent, we'll obtain the thaw\n\t\t// height of the intent, if present at all. If this is\n\t\t// non-zero, then we'll mark this as the proper channel type.\n\t\tthawHeight = shimIntent.ThawHeight()\n\t}\n\n\t// Now that we have a funding intent, we'll check whether funding a\n\t// channel using it would violate our reserved value for anchor channel\n\t// fee bumping.\n\t//\n\t// Check the reserved value using the inputs and outputs given by the\n\t// intent. Note that for the PSBT intent type we don't yet have the\n\t// funding tx ready, so this will always pass.  We'll do another check\n\t// when the PSBT has been verified.\n\tisPublic := req.Flags&lnwire.FFAnnounceChannel != 0\n\thasAnchors := req.CommitType.HasAnchors()\n\tif enforceNewReservedValue {\n\t\terr = l.enforceNewReservedValue(fundingIntent, isPublic, hasAnchors)\n\t\tif err != nil {\n\t\t\tfundingIntent.Cancel()\n\n\t\t\treq.err <- err\n\t\t\treq.resp <- nil\n\t\t\treturn\n\t\t}\n\t}\n\n\t// The total channel capacity will be the size of the funding output we\n\t// created plus the remote contribution.\n\tcapacity := localFundingAmt + remoteFundingAmt\n\n\tid := atomic.AddUint64(&l.nextFundingID, 1)\n\treservation, err := NewChannelReservation(\n\t\tcapacity, localFundingAmt, l, id, l.Cfg.NetParams.GenesisHash,\n\t\tthawHeight, req,\n\t)\n\tif err != nil {\n\t\tfundingIntent.Cancel()\n\n\t\treq.err <- err\n\t\treq.resp <- nil\n\t\treturn\n\t}\n\n\terr = l.initOurContribution(\n\t\treservation, fundingIntent, req.NodeAddr, req.NodeID, keyRing,\n\t)\n\tif err != nil {\n\t\tfundingIntent.Cancel()\n\n\t\treq.err <- err\n\t\treq.resp <- nil\n\t\treturn\n\t}\n\n\t// Create a limbo and record entry for this newly pending funding\n\t// request.\n\tl.limboMtx.Lock()\n\tl.fundingLimbo[id] = reservation\n\tl.reservationIDs[req.PendingChanID] = id\n\tl.limboMtx.Unlock()\n\n\t// Funding reservation request successfully handled. The funding inputs\n\t// will be marked as unavailable until the reservation is either\n\t// completed, or canceled.\n\treq.resp <- reservation\n\treq.err <- nil\n\n\twalletLog.Debugf(\"Successfully handled funding reservation with \"+\n\t\t\"pendingChanID: %x, reservationID: %v\",\n\t\treservation.pendingChanID, reservation.reservationID)\n}\n\n// enforceReservedValue enforces that the wallet, upon a new channel being\n// opened, meets the minimum amount of funds required for each advertised anchor\n// channel.\n//\n// We only enforce the reserve if we are contributing funds to the channel. This\n// is done to still allow incoming channels even though we have no UTXOs\n// available, as in bootstrapping phases.",
      "length": 6345,
      "tokens": 883,
      "embedding": []
    },
    {
      "slug": "func (l *LightningWallet) enforceNewReservedValue(fundingIntent chanfunding.Intent,",
      "content": "func (l *LightningWallet) enforceNewReservedValue(fundingIntent chanfunding.Intent,\n\tisPublic, hasAnchors bool) error {\n\n\t// Only enforce the reserve when an advertised channel is being opened\n\t// in which we are contributing funds to. This ensures we never dip\n\t// below the reserve.\n\tif !isPublic || fundingIntent.LocalFundingAmt() == 0 {\n\t\treturn nil\n\t}\n\n\tnumAnchors, err := l.CurrentNumAnchorChans()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Add the to-be-opened channel.\n\tif hasAnchors {\n\t\tnumAnchors++\n\t}\n\n\treturn l.WithCoinSelectLock(func() error {\n\t\t_, err := l.CheckReservedValue(\n\t\t\tfundingIntent.Inputs(), fundingIntent.Outputs(),\n\t\t\tnumAnchors,\n\t\t)\n\t\treturn err\n\t})\n}\n\n// CurrentNumAnchorChans returns the current number of non-private anchor\n// channels the wallet should be ready to fee bump if needed.",
      "length": 699,
      "tokens": 103,
      "embedding": []
    },
    {
      "slug": "func (l *LightningWallet) CurrentNumAnchorChans() (int, error) {",
      "content": "func (l *LightningWallet) CurrentNumAnchorChans() (int, error) {\n\t// Count all anchor channels that are open or pending\n\t// open, or waiting close.\n\tchans, err := l.Cfg.Database.FetchAllChannels()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tvar numAnchors int\n\tcntChannel := func(c *channeldb.OpenChannel) {\n\t\t// We skip private channels, as we assume they won't be used\n\t\t// for routing.\n\t\tif c.ChannelFlags&lnwire.FFAnnounceChannel == 0 {\n\t\t\treturn\n\t\t}\n\n\t\t// Count anchor channels.\n\t\tif c.ChanType.HasAnchors() {\n\t\t\tnumAnchors++\n\t\t}\n\t}\n\n\tfor _, c := range chans {\n\t\tcntChannel(c)\n\t}\n\n\t// We also count pending close channels.\n\tpendingClosed, err := l.Cfg.Database.FetchClosedChannels(\n\t\ttrue,\n\t)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tfor _, c := range pendingClosed {\n\t\tc, err := l.Cfg.Database.FetchHistoricalChannel(\n\t\t\t&c.ChanPoint,\n\t\t)\n\t\tif err != nil {\n\t\t\t// We don't have a guarantee that all channels re found\n\t\t\t// in the historical channels bucket, so we continue.\n\t\t\twalletLog.Warnf(\"Unable to fetch historical \"+\n\t\t\t\t\"channel: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tcntChannel(c)\n\t}\n\n\treturn numAnchors, nil\n}\n\n// CheckReservedValue checks whether publishing a transaction with the given\n// inputs and outputs would violate the value we reserve in the wallet for\n// bumping the fee of anchor channels. The numAnchorChans argument should be\n// set the the number of open anchor channels controlled by the wallet after\n// the transaction has been published.\n//\n// If the reserved value is violated, the returned error will be\n// ErrReservedValueInvalidated. The method will also return the current\n// reserved value, both in case of success and in case of\n// ErrReservedValueInvalidated.\n//\n// NOTE: This method should only be run with the CoinSelectLock held.",
      "length": 1628,
      "tokens": 258,
      "embedding": []
    },
    {
      "slug": "func (l *LightningWallet) CheckReservedValue(in []wire.OutPoint,",
      "content": "func (l *LightningWallet) CheckReservedValue(in []wire.OutPoint,\n\tout []*wire.TxOut, numAnchorChans int) (btcutil.Amount, error) {\n\n\t// Get all unspent coins in the wallet. We only care about those part of\n\t// the wallet's default account as we know we can readily sign for those\n\t// at any time.\n\twitnessOutputs, err := l.ListUnspentWitnessFromDefaultAccount(\n\t\t0, math.MaxInt32,\n\t)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tourInput := make(map[wire.OutPoint]struct{})\n\tfor _, op := range in {\n\t\tourInput[op] = struct{}{}\n\t}\n\n\t// When crafting a transaction with inputs from the wallet, these coins\n\t// will usually be locked in the process, and not be returned when\n\t// listing unspents. In this case they have already been deducted from\n\t// the wallet balance. In case they haven't been properly locked, we\n\t// check whether they are still listed among our unspents and deduct\n\t// them.\n\tvar walletBalance btcutil.Amount\n\tfor _, in := range witnessOutputs {\n\t\t// Spending an unlocked wallet UTXO, don't add it to the\n\t\t// balance.\n\t\tif _, ok := ourInput[in.OutPoint]; ok {\n\t\t\tcontinue\n\t\t}\n\n\t\twalletBalance += in.Value\n\t}\n\n\t// Now we go through the outputs of the transaction, if any of the\n\t// outputs are paying into the wallet (likely a change output), we add\n\t// it to our final balance.\n\tfor _, txOut := range out {\n\t\t_, addrs, _, err := txscript.ExtractPkScriptAddrs(\n\t\t\ttxOut.PkScript, &l.Cfg.NetParams,\n\t\t)\n\t\tif err != nil {\n\t\t\t// Non-standard outputs can safely be skipped because\n\t\t\t// they're not supported by the wallet.\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, addr := range addrs {\n\t\t\tif !l.IsOurAddress(addr) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\twalletBalance += btcutil.Amount(txOut.Value)\n\n\t\t\t// We break since we don't want to double count the output.\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// We reserve a given amount for each anchor channel.\n\treserved := btcutil.Amount(numAnchorChans) * AnchorChanReservedValue\n\tif reserved > MaxAnchorChanReservedValue {\n\t\treserved = MaxAnchorChanReservedValue\n\t}\n\n\tif walletBalance < reserved {\n\t\twalletLog.Debugf(\"Reserved value=%v above final \"+\n\t\t\t\"walletbalance=%v with %d anchor channels open\",\n\t\t\treserved, walletBalance, numAnchorChans)\n\t\treturn reserved, ErrReservedValueInvalidated\n\t}\n\n\treturn reserved, nil\n}\n\n// CheckReservedValueTx calls CheckReservedValue with the inputs and outputs\n// from the given tx, with the number of anchor channels currently open in the\n// database.\n//\n// NOTE: This method should only be run with the CoinSelectLock held.",
      "length": 2324,
      "tokens": 360,
      "embedding": []
    },
    {
      "slug": "func (l *LightningWallet) CheckReservedValueTx(req CheckReservedValueTxReq) (",
      "content": "func (l *LightningWallet) CheckReservedValueTx(req CheckReservedValueTxReq) (\n\tbtcutil.Amount, error) {\n\n\tnumAnchors, err := l.CurrentNumAnchorChans()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tvar inputs []wire.OutPoint\n\tfor _, txIn := range req.Tx.TxIn {\n\t\tinputs = append(inputs, txIn.PreviousOutPoint)\n\t}\n\n\treservedVal, err := l.CheckReservedValue(\n\t\tinputs, req.Tx.TxOut, numAnchors,\n\t)\n\tswitch {\n\t// If the error returned from CheckReservedValue is\n\t// ErrReservedValueInvalidated, then it did nonetheless return\n\t// the required reserved value and we check for the optional\n\t// change index.\n\tcase errors.Is(err, ErrReservedValueInvalidated):\n\t\t// Without a change index provided there is nothing more to\n\t\t// check and the error is returned.\n\t\tif req.ChangeIndex == nil {\n\t\t\treturn reservedVal, err\n\t\t}\n\n\t\t// If a change index was provided we make only sure that it\n\t\t// would leave sufficient funds for the reserved balance value.\n\t\t//\n\t\t// Note: This is used if a change output index is explicitly set\n\t\t// but that may not be watched by the wallet and therefore is\n\t\t// not picked up by the call to CheckReservedValue above.\n\t\tchIdx := *req.ChangeIndex\n\t\tif chIdx < 0 || chIdx >= len(req.Tx.TxOut) ||\n\t\t\treq.Tx.TxOut[chIdx].Value < int64(reservedVal) {\n\n\t\t\treturn reservedVal, err\n\t\t}\n\n\tcase err != nil:\n\t\treturn reservedVal, err\n\t}\n\n\treturn reservedVal, nil\n}\n\n// initOurContribution initializes the given ChannelReservation with our coins\n// and change reserved for the channel, and derives the keys to use for this\n// channel.",
      "length": 1408,
      "tokens": 218,
      "embedding": []
    },
    {
      "slug": "func (l *LightningWallet) initOurContribution(reservation *ChannelReservation,",
      "content": "func (l *LightningWallet) initOurContribution(reservation *ChannelReservation,\n\tfundingIntent chanfunding.Intent, nodeAddr net.Addr,\n\tnodeID *btcec.PublicKey, keyRing keychain.KeyRing) error {\n\n\t// Grab the mutex on the ChannelReservation to ensure thread-safety\n\treservation.Lock()\n\tdefer reservation.Unlock()\n\n\t// At this point, if we have a funding intent, we'll use it to populate\n\t// the existing reservation state entries for our coin selection.\n\tif fundingIntent != nil {\n\t\tif intent, ok := fundingIntent.(*chanfunding.FullIntent); ok {\n\t\t\tfor _, coin := range intent.InputCoins {\n\t\t\t\treservation.ourContribution.Inputs = append(\n\t\t\t\t\treservation.ourContribution.Inputs,\n\t\t\t\t\t&wire.TxIn{\n\t\t\t\t\t\tPreviousOutPoint: coin.OutPoint,\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t}\n\t\t\treservation.ourContribution.ChangeOutputs = intent.ChangeOutputs\n\t\t}\n\n\t\treservation.fundingIntent = fundingIntent\n\t}\n\n\treservation.nodeAddr = nodeAddr\n\treservation.partialState.IdentityPub = nodeID\n\n\tvar err error\n\treservation.ourContribution.MultiSigKey, err = keyRing.DeriveNextKey(\n\t\tkeychain.KeyFamilyMultiSig,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\treservation.ourContribution.RevocationBasePoint, err = keyRing.DeriveNextKey(\n\t\tkeychain.KeyFamilyRevocationBase,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\treservation.ourContribution.HtlcBasePoint, err = keyRing.DeriveNextKey(\n\t\tkeychain.KeyFamilyHtlcBase,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\treservation.ourContribution.PaymentBasePoint, err = keyRing.DeriveNextKey(\n\t\tkeychain.KeyFamilyPaymentBase,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\treservation.ourContribution.DelayBasePoint, err = keyRing.DeriveNextKey(\n\t\tkeychain.KeyFamilyDelayBase,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// With the above keys created, we'll also need to initialize our\n\t// revocation tree state, and from that generate the per-commitment point.\n\tproducer, err := l.nextRevocationProducer(reservation, keyRing)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfirstPreimage, err := producer.AtIndex(0)\n\tif err != nil {\n\t\treturn err\n\t}\n\treservation.ourContribution.FirstCommitmentPoint = input.ComputeCommitmentPoint(\n\t\tfirstPreimage[:],\n\t)\n\n\treservation.partialState.RevocationProducer = producer\n\treservation.ourContribution.ChannelConstraints = l.Cfg.DefaultConstraints\n\n\treturn nil\n}\n\n// handleFundingReserveCancel cancels an existing channel reservation. As part\n// of the cancellation, outputs previously selected as inputs for the funding\n// transaction via coin selection are freed allowing future reservations to\n// include them.",
      "length": 2341,
      "tokens": 261,
      "embedding": []
    },
    {
      "slug": "func (l *LightningWallet) handleFundingCancelRequest(req *fundingReserveCancelMsg) {",
      "content": "func (l *LightningWallet) handleFundingCancelRequest(req *fundingReserveCancelMsg) {\n\t// TODO(roasbeef): holding lock too long\n\tl.limboMtx.Lock()\n\tdefer l.limboMtx.Unlock()\n\n\tpendingReservation, ok := l.fundingLimbo[req.pendingFundingID]\n\tif !ok {\n\t\t// TODO(roasbeef): make new error, \"unknown funding state\" or something\n\t\treq.err <- fmt.Errorf(\"attempted to cancel non-existent funding state\")\n\t\treturn\n\t}\n\n\t// Grab the mutex on the ChannelReservation to ensure thread-safety\n\tpendingReservation.Lock()\n\tdefer pendingReservation.Unlock()\n\n\t// Mark all previously locked outpoints as usable for future funding\n\t// requests.\n\tfor _, unusedInput := range pendingReservation.ourContribution.Inputs {\n\t\tdelete(l.lockedOutPoints, unusedInput.PreviousOutPoint)\n\t\tl.UnlockOutpoint(unusedInput.PreviousOutPoint)\n\t}\n\n\t// TODO(roasbeef): is it even worth it to keep track of unused keys?\n\n\t// TODO(roasbeef): Is it possible to mark the unused change also as\n\t// available?\n\n\tdelete(l.fundingLimbo, req.pendingFundingID)\n\n\tpid := pendingReservation.pendingChanID\n\tdelete(l.reservationIDs, pid)\n\n\tl.intentMtx.Lock()\n\tif intent, ok := l.fundingIntents[pid]; ok {\n\t\tintent.Cancel()\n\n\t\tdelete(l.fundingIntents, pendingReservation.pendingChanID)\n\t}\n\tl.intentMtx.Unlock()\n\n\treq.err <- nil\n}\n\n// CreateCommitmentTxns is a helper function that creates the initial\n// commitment transaction for both parties. This function is used during the\n// initial funding workflow as both sides must generate a signature for the\n// remote party's commitment transaction, and verify the signature for their\n// version of the commitment transaction.",
      "length": 1485,
      "tokens": 176,
      "embedding": []
    },
    {
      "slug": "func CreateCommitmentTxns(localBalance, remoteBalance btcutil.Amount,",
      "content": "func CreateCommitmentTxns(localBalance, remoteBalance btcutil.Amount,\n\tourChanCfg, theirChanCfg *channeldb.ChannelConfig,\n\tlocalCommitPoint, remoteCommitPoint *btcec.PublicKey,\n\tfundingTxIn wire.TxIn, chanType channeldb.ChannelType, initiator bool,\n\tleaseExpiry uint32) (*wire.MsgTx, *wire.MsgTx, error) {\n\n\tlocalCommitmentKeys := DeriveCommitmentKeys(\n\t\tlocalCommitPoint, true, chanType, ourChanCfg, theirChanCfg,\n\t)\n\tremoteCommitmentKeys := DeriveCommitmentKeys(\n\t\tremoteCommitPoint, false, chanType, ourChanCfg, theirChanCfg,\n\t)\n\n\tourCommitTx, err := CreateCommitTx(\n\t\tchanType, fundingTxIn, localCommitmentKeys, ourChanCfg,\n\t\ttheirChanCfg, localBalance, remoteBalance, 0, initiator,\n\t\tleaseExpiry,\n\t)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\totxn := btcutil.NewTx(ourCommitTx)\n\tif err := blockchain.CheckTransactionSanity(otxn); err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\ttheirCommitTx, err := CreateCommitTx(\n\t\tchanType, fundingTxIn, remoteCommitmentKeys, theirChanCfg,\n\t\tourChanCfg, remoteBalance, localBalance, 0, !initiator,\n\t\tleaseExpiry,\n\t)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tttxn := btcutil.NewTx(theirCommitTx)\n\tif err := blockchain.CheckTransactionSanity(ttxn); err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn ourCommitTx, theirCommitTx, nil\n}\n\n// handleContributionMsg processes the second workflow step for the lifetime of\n// a channel reservation. Upon completion, the reservation will carry a\n// completed funding transaction (minus the counterparty's input signatures),\n// both versions of the commitment transaction, and our signature for their\n// version of the commitment transaction.",
      "length": 1500,
      "tokens": 172,
      "embedding": []
    },
    {
      "slug": "func (l *LightningWallet) handleContributionMsg(req *addContributionMsg) {",
      "content": "func (l *LightningWallet) handleContributionMsg(req *addContributionMsg) {\n\n\tl.limboMtx.Lock()\n\tpendingReservation, ok := l.fundingLimbo[req.pendingFundingID]\n\tl.limboMtx.Unlock()\n\tif !ok {\n\t\treq.err <- fmt.Errorf(\"attempted to update non-existent funding state\")\n\t\treturn\n\t}\n\n\t// Grab the mutex on the ChannelReservation to ensure thread-safety\n\tpendingReservation.Lock()\n\tdefer pendingReservation.Unlock()\n\n\t// If UpfrontShutdownScript is set, validate that it is a valid script.\n\tshutdown := req.contribution.UpfrontShutdown\n\tif len(shutdown) > 0 {\n\t\t// Validate the shutdown script.\n\t\tif !ValidateUpfrontShutdown(shutdown, &l.Cfg.NetParams) {\n\t\t\treq.err <- fmt.Errorf(\"invalid shutdown script\")\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Some temporary variables to cut down on the resolution verbosity.\n\tpendingReservation.theirContribution = req.contribution\n\ttheirContribution := req.contribution\n\tourContribution := pendingReservation.ourContribution\n\n\t// Perform bounds-checking on both ChannelReserve and DustLimit\n\t// parameters.\n\tif !pendingReservation.validateReserveBounds() {\n\t\treq.err <- fmt.Errorf(\"invalid reserve and dust bounds\")\n\t\treturn\n\t}\n\n\tvar (\n\t\tchanPoint *wire.OutPoint\n\t\terr       error\n\t)\n\n\t// At this point, we can now construct our channel point. Depending on\n\t// which type of intent we obtained from our chanfunding.Assembler,\n\t// we'll carry out a distinct set of steps.\n\tswitch fundingIntent := pendingReservation.fundingIntent.(type) {\n\t// The transaction was created outside of the wallet and might already\n\t// be published. Nothing left to do other than using the correct\n\t// outpoint.\n\tcase *chanfunding.ShimIntent:\n\t\tchanPoint, err = fundingIntent.ChanPoint()\n\t\tif err != nil {\n\t\t\treq.err <- fmt.Errorf(\"unable to obtain chan point: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tpendingReservation.partialState.FundingOutpoint = *chanPoint\n\n\t// The user has signaled that they want to use a PSBT to construct the\n\t// funding transaction. Because we now have the multisig keys from both\n\t// parties, we can create the multisig script that needs to be funded\n\t// and then pause the process until the user supplies the PSBT\n\t// containing the eventual funding transaction.\n\tcase *chanfunding.PsbtIntent:\n\t\tif fundingIntent.PendingPsbt != nil {\n\t\t\treq.err <- fmt.Errorf(\"PSBT funding already in\" +\n\t\t\t\t\"progress\")\n\t\t\treturn\n\t\t}\n\n\t\t// Now that we know our contribution, we can bind both the local\n\t\t// and remote key which will be needed to calculate the multisig\n\t\t// funding output in a next step.\n\t\tpendingChanID := pendingReservation.pendingChanID\n\t\twalletLog.Debugf(\"Advancing PSBT funding flow for \"+\n\t\t\t\"pending_id(%x), binding keys local_key=%v, \"+\n\t\t\t\"remote_key=%x\", pendingChanID,\n\t\t\t&ourContribution.MultiSigKey,\n\t\t\ttheirContribution.MultiSigKey.PubKey.SerializeCompressed())\n\t\tfundingIntent.BindKeys(\n\t\t\t&ourContribution.MultiSigKey,\n\t\t\ttheirContribution.MultiSigKey.PubKey,\n\t\t)\n\n\t\t// Exit early because we can't continue the funding flow yet.\n\t\treq.err <- &PsbtFundingRequired{\n\t\t\tIntent: fundingIntent,\n\t\t}\n\t\treturn\n\n\tcase *chanfunding.FullIntent:\n\t\t// Now that we know their public key, we can bind theirs as\n\t\t// well as ours to the funding intent.\n\t\tfundingIntent.BindKeys(\n\t\t\t&pendingReservation.ourContribution.MultiSigKey,\n\t\t\ttheirContribution.MultiSigKey.PubKey,\n\t\t)\n\n\t\t// With our keys bound, we can now construct+sign the final\n\t\t// funding transaction and also obtain the chanPoint that\n\t\t// creates the channel.\n\t\tfundingTx, err := fundingIntent.CompileFundingTx(\n\t\t\ttheirContribution.Inputs,\n\t\t\ttheirContribution.ChangeOutputs,\n\t\t)\n\t\tif err != nil {\n\t\t\treq.err <- fmt.Errorf(\"unable to construct funding \"+\n\t\t\t\t\"tx: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tchanPoint, err = fundingIntent.ChanPoint()\n\t\tif err != nil {\n\t\t\treq.err <- fmt.Errorf(\"unable to obtain chan \"+\n\t\t\t\t\"point: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\t// Finally, we'll populate the relevant information in our\n\t\t// pendingReservation so the rest of the funding flow can\n\t\t// continue as normal.\n\t\tpendingReservation.fundingTx = fundingTx\n\t\tpendingReservation.partialState.FundingOutpoint = *chanPoint\n\t\tpendingReservation.ourFundingInputScripts = make(\n\t\t\t[]*input.Script, 0, len(ourContribution.Inputs),\n\t\t)\n\t\tfor _, txIn := range fundingTx.TxIn {\n\t\t\t_, err := l.FetchInputInfo(&txIn.PreviousOutPoint)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tpendingReservation.ourFundingInputScripts = append(\n\t\t\t\tpendingReservation.ourFundingInputScripts,\n\t\t\t\t&input.Script{\n\t\t\t\t\tWitness:   txIn.Witness,\n\t\t\t\t\tSigScript: txIn.SignatureScript,\n\t\t\t\t},\n\t\t\t)\n\t\t}\n\n\t\twalletLog.Tracef(\"Funding tx for ChannelPoint(%v) \"+\n\t\t\t\"generated: %v\", chanPoint, spew.Sdump(fundingTx))\n\t}\n\n\t// If we landed here and didn't exit early, it means we already have\n\t// the channel point ready. We can jump directly to the next step.\n\tl.handleChanPointReady(&continueContributionMsg{\n\t\tpendingFundingID: req.pendingFundingID,\n\t\terr:              req.err,\n\t})\n}\n\n// handleChanPointReady continues the funding process once the channel point\n// is known and the funding transaction can be completed.",
      "length": 4798,
      "tokens": 579,
      "embedding": []
    },
    {
      "slug": "func (l *LightningWallet) handleChanPointReady(req *continueContributionMsg) {",
      "content": "func (l *LightningWallet) handleChanPointReady(req *continueContributionMsg) {\n\tl.limboMtx.Lock()\n\tpendingReservation, ok := l.fundingLimbo[req.pendingFundingID]\n\tl.limboMtx.Unlock()\n\tif !ok {\n\t\treq.err <- fmt.Errorf(\"attempted to update non-existent \" +\n\t\t\t\"funding state\")\n\t\treturn\n\t}\n\tourContribution := pendingReservation.ourContribution\n\ttheirContribution := pendingReservation.theirContribution\n\tchanPoint := pendingReservation.partialState.FundingOutpoint\n\n\t// If we're in the PSBT funding flow, we now should have everything that\n\t// is needed to construct and publish the full funding transaction.\n\tintent := pendingReservation.fundingIntent\n\tif psbtIntent, ok := intent.(*chanfunding.PsbtIntent); ok {\n\t\t// With our keys bound, we can now construct and possibly sign\n\t\t// the final funding transaction and also obtain the chanPoint\n\t\t// that creates the channel. We _have_ to call CompileFundingTx\n\t\t// even if we don't publish ourselves as that sets the actual\n\t\t// funding outpoint in stone for this channel.\n\t\tfundingTx, err := psbtIntent.CompileFundingTx()\n\t\tif err != nil {\n\t\t\treq.err <- fmt.Errorf(\"unable to construct funding \"+\n\t\t\t\t\"tx: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tchanPointPtr, err := psbtIntent.ChanPoint()\n\t\tif err != nil {\n\t\t\treq.err <- fmt.Errorf(\"unable to obtain chan \"+\n\t\t\t\t\"point: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tpendingReservation.partialState.FundingOutpoint = *chanPointPtr\n\t\tchanPoint = *chanPointPtr\n\n\t\t// Finally, we'll populate the relevant information in our\n\t\t// pendingReservation so the rest of the funding flow can\n\t\t// continue as normal in case we are going to publish ourselves.\n\t\tif psbtIntent.ShouldPublishFundingTX() {\n\t\t\tpendingReservation.fundingTx = fundingTx\n\t\t\tpendingReservation.ourFundingInputScripts = make(\n\t\t\t\t[]*input.Script, 0, len(ourContribution.Inputs),\n\t\t\t)\n\t\t\tfor _, txIn := range fundingTx.TxIn {\n\t\t\t\tpendingReservation.ourFundingInputScripts = append(\n\t\t\t\t\tpendingReservation.ourFundingInputScripts,\n\t\t\t\t\t&input.Script{\n\t\t\t\t\t\tWitness:   txIn.Witness,\n\t\t\t\t\t\tSigScript: txIn.SignatureScript,\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Initialize an empty sha-chain for them, tracking the current pending\n\t// revocation hash (we don't yet know the preimage so we can't add it\n\t// to the chain).\n\ts := shachain.NewRevocationStore()\n\tpendingReservation.partialState.RevocationStore = s\n\n\t// Store their current commitment point. We'll need this after the\n\t// first state transition in order to verify the authenticity of the\n\t// revocation.\n\tchanState := pendingReservation.partialState\n\tchanState.RemoteCurrentRevocation = theirContribution.FirstCommitmentPoint\n\n\t// Create the txin to our commitment transaction; required to construct\n\t// the commitment transactions.\n\tfundingTxIn := wire.TxIn{\n\t\tPreviousOutPoint: chanPoint,\n\t}\n\n\t// With the funding tx complete, create both commitment transactions.\n\tlocalBalance := pendingReservation.partialState.LocalCommitment.LocalBalance.ToSatoshis()\n\tremoteBalance := pendingReservation.partialState.LocalCommitment.RemoteBalance.ToSatoshis()\n\tvar leaseExpiry uint32\n\tif pendingReservation.partialState.ChanType.HasLeaseExpiration() {\n\t\tleaseExpiry = pendingReservation.partialState.ThawHeight\n\t}\n\tourCommitTx, theirCommitTx, err := CreateCommitmentTxns(\n\t\tlocalBalance, remoteBalance, ourContribution.ChannelConfig,\n\t\ttheirContribution.ChannelConfig,\n\t\tourContribution.FirstCommitmentPoint,\n\t\ttheirContribution.FirstCommitmentPoint, fundingTxIn,\n\t\tpendingReservation.partialState.ChanType,\n\t\tpendingReservation.partialState.IsInitiator, leaseExpiry,\n\t)\n\tif err != nil {\n\t\treq.err <- err\n\t\treturn\n\t}\n\n\t// With both commitment transactions constructed, generate the state\n\t// obfuscator then use it to encode the current state number within\n\t// both commitment transactions.\n\tvar stateObfuscator [StateHintSize]byte\n\tif chanState.ChanType.IsSingleFunder() {\n\t\tstateObfuscator = DeriveStateHintObfuscator(\n\t\t\tourContribution.PaymentBasePoint.PubKey,\n\t\t\ttheirContribution.PaymentBasePoint.PubKey,\n\t\t)\n\t} else {\n\t\tourSer := ourContribution.PaymentBasePoint.PubKey.SerializeCompressed()\n\t\ttheirSer := theirContribution.PaymentBasePoint.PubKey.SerializeCompressed()\n\t\tswitch bytes.Compare(ourSer, theirSer) {\n\t\tcase -1:\n\t\t\tstateObfuscator = DeriveStateHintObfuscator(\n\t\t\t\tourContribution.PaymentBasePoint.PubKey,\n\t\t\t\ttheirContribution.PaymentBasePoint.PubKey,\n\t\t\t)\n\t\tdefault:\n\t\t\tstateObfuscator = DeriveStateHintObfuscator(\n\t\t\t\ttheirContribution.PaymentBasePoint.PubKey,\n\t\t\t\tourContribution.PaymentBasePoint.PubKey,\n\t\t\t)\n\t\t}\n\t}\n\terr = initStateHints(ourCommitTx, theirCommitTx, stateObfuscator)\n\tif err != nil {\n\t\treq.err <- err\n\t\treturn\n\t}\n\n\t// Sort both transactions according to the agreed upon canonical\n\t// ordering. This lets us skip sending the entire transaction over,\n\t// instead we'll just send signatures.\n\ttxsort.InPlaceSort(ourCommitTx)\n\ttxsort.InPlaceSort(theirCommitTx)\n\n\twalletLog.Tracef(\"Local commit tx for ChannelPoint(%v): %v\",\n\t\tchanPoint, spew.Sdump(ourCommitTx))\n\twalletLog.Tracef(\"Remote commit tx for ChannelPoint(%v): %v\",\n\t\tchanPoint, spew.Sdump(theirCommitTx))\n\n\t// Record newly available information within the open channel state.\n\tchanState.FundingOutpoint = chanPoint\n\tchanState.LocalCommitment.CommitTx = ourCommitTx\n\tchanState.RemoteCommitment.CommitTx = theirCommitTx\n\n\t// Next, we'll obtain the funding witness script, and the funding\n\t// output itself so we can generate a valid signature for the remote\n\t// party.\n\tfundingIntent := pendingReservation.fundingIntent\n\tfundingWitnessScript, fundingOutput, err := fundingIntent.FundingOutput()\n\tif err != nil {\n\t\treq.err <- fmt.Errorf(\"unable to obtain funding output\")\n\t\treturn\n\t}\n\n\t// Generate a signature for their version of the initial commitment\n\t// transaction.\n\tourKey := ourContribution.MultiSigKey\n\tsignDesc := input.SignDescriptor{\n\t\tWitnessScript: fundingWitnessScript,\n\t\tKeyDesc:       ourKey,\n\t\tOutput:        fundingOutput,\n\t\tHashType:      txscript.SigHashAll,\n\t\tSigHashes:     input.NewTxSigHashesV0Only(theirCommitTx),\n\t\tInputIndex:    0,\n\t}\n\tsigTheirCommit, err := l.Cfg.Signer.SignOutputRaw(theirCommitTx, &signDesc)\n\tif err != nil {\n\t\treq.err <- err\n\t\treturn\n\t}\n\tpendingReservation.ourCommitmentSig = sigTheirCommit\n\n\treq.err <- nil\n}\n\n// handleSingleContribution is called as the second step to a single funder\n// workflow to which we are the responder. It simply saves the remote peer's\n// contribution to the channel, as solely the remote peer will contribute any\n// funds to the channel.",
      "length": 6218,
      "tokens": 661,
      "embedding": []
    },
    {
      "slug": "func (l *LightningWallet) handleSingleContribution(req *addSingleContributionMsg) {",
      "content": "func (l *LightningWallet) handleSingleContribution(req *addSingleContributionMsg) {\n\tl.limboMtx.Lock()\n\tpendingReservation, ok := l.fundingLimbo[req.pendingFundingID]\n\tl.limboMtx.Unlock()\n\tif !ok {\n\t\treq.err <- fmt.Errorf(\"attempted to update non-existent funding state\")\n\t\treturn\n\t}\n\n\t// Grab the mutex on the channelReservation to ensure thread-safety.\n\tpendingReservation.Lock()\n\tdefer pendingReservation.Unlock()\n\n\t// Validate that the remote's UpfrontShutdownScript is a valid script\n\t// if it's set.\n\tshutdown := req.contribution.UpfrontShutdown\n\tif len(shutdown) > 0 {\n\t\t// Validate the shutdown script.\n\t\tif !ValidateUpfrontShutdown(shutdown, &l.Cfg.NetParams) {\n\t\t\treq.err <- fmt.Errorf(\"invalid shutdown script\")\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Simply record the counterparty's contribution into the pending\n\t// reservation data as they'll be solely funding the channel entirely.\n\tpendingReservation.theirContribution = req.contribution\n\ttheirContribution := pendingReservation.theirContribution\n\tchanState := pendingReservation.partialState\n\n\t// Perform bounds checking on both ChannelReserve and DustLimit\n\t// parameters. The ChannelReserve may have been changed by the\n\t// ChannelAcceptor RPC, so this is necessary.\n\tif !pendingReservation.validateReserveBounds() {\n\t\treq.err <- fmt.Errorf(\"invalid reserve and dust bounds\")\n\t\treturn\n\t}\n\n\t// Initialize an empty sha-chain for them, tracking the current pending\n\t// revocation hash (we don't yet know the preimage so we can't add it\n\t// to the chain).\n\tremotePreimageStore := shachain.NewRevocationStore()\n\tchanState.RevocationStore = remotePreimageStore\n\n\t// Now that we've received their first commitment point, we'll store it\n\t// within the channel state so we can sync it to disk once the funding\n\t// process is complete.\n\tchanState.RemoteCurrentRevocation = theirContribution.FirstCommitmentPoint\n\n\treq.err <- nil\n}\n\n// verifyFundingInputs attempts to verify all remote inputs to the funding\n// transaction.",
      "length": 1828,
      "tokens": 224,
      "embedding": []
    },
    {
      "slug": "func (l *LightningWallet) verifyFundingInputs(fundingTx *wire.MsgTx,",
      "content": "func (l *LightningWallet) verifyFundingInputs(fundingTx *wire.MsgTx,\n\tremoteInputScripts []*input.Script) error {\n\n\tsigIndex := 0\n\tfundingHashCache := input.NewTxSigHashesV0Only(fundingTx)\n\tinputScripts := remoteInputScripts\n\tfor i, txin := range fundingTx.TxIn {\n\t\tif len(inputScripts) != 0 && len(txin.Witness) == 0 {\n\t\t\t// Attach the input scripts so we can verify it below.\n\t\t\ttxin.Witness = inputScripts[sigIndex].Witness\n\t\t\ttxin.SignatureScript = inputScripts[sigIndex].SigScript\n\n\t\t\t// Fetch the alleged previous output along with the\n\t\t\t// pkscript referenced by this input.\n\t\t\t//\n\t\t\t// TODO(roasbeef): when dual funder pass actual\n\t\t\t// height-hint\n\t\t\t//\n\t\t\t// TODO(roasbeef): this fails for neutrino always as it\n\t\t\t// treats the height hint as an exact birthday of the\n\t\t\t// utxo rather than a lower bound\n\t\t\tpkScript, err := txscript.ComputePkScript(\n\t\t\t\ttxin.SignatureScript, txin.Witness,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"cannot create script: %v\", err)\n\t\t\t}\n\t\t\toutput, err := l.Cfg.ChainIO.GetUtxo(\n\t\t\t\t&txin.PreviousOutPoint,\n\t\t\t\tpkScript.Script(), 0, l.quit,\n\t\t\t)\n\t\t\tif output == nil {\n\t\t\t\treturn fmt.Errorf(\"input to funding tx does \"+\n\t\t\t\t\t\"not exist: %v\", err)\n\t\t\t}\n\n\t\t\t// Ensure that the witness+sigScript combo is valid.\n\t\t\tvm, err := txscript.NewEngine(\n\t\t\t\toutput.PkScript, fundingTx, i,\n\t\t\t\ttxscript.StandardVerifyFlags, nil,\n\t\t\t\tfundingHashCache, output.Value,\n\t\t\t\ttxscript.NewCannedPrevOutputFetcher(\n\t\t\t\t\toutput.PkScript, output.Value,\n\t\t\t\t),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"cannot create script \"+\n\t\t\t\t\t\"engine: %s\", err)\n\t\t\t}\n\t\t\tif err = vm.Execute(); err != nil {\n\t\t\t\treturn fmt.Errorf(\"cannot validate \"+\n\t\t\t\t\t\"transaction: %s\", err)\n\t\t\t}\n\n\t\t\tsigIndex++\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// handleFundingCounterPartySigs is the final step in the channel reservation\n// workflow. During this step, we validate *all* the received signatures for\n// inputs to the funding transaction. If any of these are invalid, we bail,\n// and forcibly cancel this funding request. Additionally, we ensure that the\n// signature we received from the counterparty for our version of the commitment\n// transaction allows us to spend from the funding output with the addition of\n// our signature.",
      "length": 2089,
      "tokens": 282,
      "embedding": []
    },
    {
      "slug": "func (l *LightningWallet) handleFundingCounterPartySigs(msg *addCounterPartySigsMsg) {",
      "content": "func (l *LightningWallet) handleFundingCounterPartySigs(msg *addCounterPartySigsMsg) {\n\tl.limboMtx.RLock()\n\tres, ok := l.fundingLimbo[msg.pendingFundingID]\n\tl.limboMtx.RUnlock()\n\tif !ok {\n\t\tmsg.err <- fmt.Errorf(\"attempted to update non-existent funding state\")\n\t\treturn\n\t}\n\n\t// Grab the mutex on the ChannelReservation to ensure thread-safety\n\tres.Lock()\n\tdefer res.Unlock()\n\n\t// Now we can complete the funding transaction by adding their\n\t// signatures to their inputs.\n\tres.theirFundingInputScripts = msg.theirFundingInputScripts\n\tinputScripts := msg.theirFundingInputScripts\n\n\t// Only if we have the final funding transaction do we need to verify\n\t// the final set of inputs. Otherwise, it may be the case that the\n\t// channel was funded via an external wallet.\n\tfundingTx := res.fundingTx\n\tif res.partialState.ChanType.HasFundingTx() {\n\t\terr := l.verifyFundingInputs(fundingTx, inputScripts)\n\t\tif err != nil {\n\t\t\tmsg.err <- err\n\t\t\tmsg.completeChan <- nil\n\t\t\treturn\n\t\t}\n\t}\n\n\t// At this point, we can also record and verify their signature for our\n\t// commitment transaction.\n\tres.theirCommitmentSig = msg.theirCommitmentSig\n\tcommitTx := res.partialState.LocalCommitment.CommitTx\n\tourKey := res.ourContribution.MultiSigKey\n\ttheirKey := res.theirContribution.MultiSigKey\n\n\t// Re-generate both the witnessScript and p2sh output. We sign the\n\t// witnessScript script, but include the p2sh output as the subscript\n\t// for verification.\n\twitnessScript, _, err := input.GenFundingPkScript(\n\t\tourKey.PubKey.SerializeCompressed(),\n\t\ttheirKey.PubKey.SerializeCompressed(),\n\t\tint64(res.partialState.Capacity),\n\t)\n\tif err != nil {\n\t\tmsg.err <- err\n\t\tmsg.completeChan <- nil\n\t\treturn\n\t}\n\n\t// Next, create the spending scriptSig, and then verify that the script\n\t// is complete, allowing us to spend from the funding transaction.\n\tchannelValue := int64(res.partialState.Capacity)\n\thashCache := input.NewTxSigHashesV0Only(commitTx)\n\tsigHash, err := txscript.CalcWitnessSigHash(\n\t\twitnessScript, hashCache, txscript.SigHashAll, commitTx,\n\t\t0, channelValue,\n\t)\n\tif err != nil {\n\t\tmsg.err <- err\n\t\tmsg.completeChan <- nil\n\t\treturn\n\t}\n\n\t// Verify that we've received a valid signature from the remote party\n\t// for our version of the commitment transaction.\n\tif !msg.theirCommitmentSig.Verify(sigHash, theirKey.PubKey) {\n\t\tmsg.err <- fmt.Errorf(\"counterparty's commitment signature is invalid\")\n\t\tmsg.completeChan <- nil\n\t\treturn\n\t}\n\ttheirCommitSigBytes := msg.theirCommitmentSig.Serialize()\n\tres.partialState.LocalCommitment.CommitSig = theirCommitSigBytes\n\n\t// Funding complete, this entry can be removed from limbo.\n\tl.limboMtx.Lock()\n\tdelete(l.fundingLimbo, res.reservationID)\n\tdelete(l.reservationIDs, res.pendingChanID)\n\tl.limboMtx.Unlock()\n\n\tl.intentMtx.Lock()\n\tdelete(l.fundingIntents, res.pendingChanID)\n\tl.intentMtx.Unlock()\n\n\t// As we're about to broadcast the funding transaction, we'll take note\n\t// of the current height for record keeping purposes.\n\t//\n\t// TODO(roasbeef): this info can also be piped into light client's\n\t// basic fee estimation?\n\t_, bestHeight, err := l.Cfg.ChainIO.GetBestBlock()\n\tif err != nil {\n\t\tmsg.err <- err\n\t\tmsg.completeChan <- nil\n\t\treturn\n\t}\n\n\t// As we've completed the funding process, we'll no convert the\n\t// contribution structs into their underlying channel config objects to\n\t// he stored within the database.\n\tres.partialState.LocalChanCfg = res.ourContribution.toChanConfig()\n\tres.partialState.RemoteChanCfg = res.theirContribution.toChanConfig()\n\n\t// We'll also record the finalized funding txn, which will allow us to\n\t// rebroadcast on startup in case we fail.\n\tres.partialState.FundingTxn = fundingTx\n\n\t// Set optional upfront shutdown scripts on the channel state so that they\n\t// are persisted. These values may be nil.\n\tres.partialState.LocalShutdownScript =\n\t\tres.ourContribution.UpfrontShutdown\n\tres.partialState.RemoteShutdownScript =\n\t\tres.theirContribution.UpfrontShutdown\n\n\tres.partialState.RevocationKeyLocator = res.nextRevocationKeyLoc\n\n\t// Add the complete funding transaction to the DB, in its open bucket\n\t// which will be used for the lifetime of this channel.\n\tnodeAddr := res.nodeAddr\n\terr = res.partialState.SyncPending(nodeAddr, uint32(bestHeight))\n\tif err != nil {\n\t\tmsg.err <- err\n\t\tmsg.completeChan <- nil\n\t\treturn\n\t}\n\n\tmsg.completeChan <- res.partialState\n\tmsg.err <- nil\n}\n\n// handleSingleFunderSigs is called once the remote peer who initiated the\n// single funder workflow has assembled the funding transaction, and generated\n// a signature for our version of the commitment transaction. This method\n// progresses the workflow by generating a signature for the remote peer's\n// version of the commitment transaction.",
      "length": 4464,
      "tokens": 550,
      "embedding": []
    },
    {
      "slug": "func (l *LightningWallet) handleSingleFunderSigs(req *addSingleFunderSigsMsg) {",
      "content": "func (l *LightningWallet) handleSingleFunderSigs(req *addSingleFunderSigsMsg) {\n\tl.limboMtx.RLock()\n\tpendingReservation, ok := l.fundingLimbo[req.pendingFundingID]\n\tl.limboMtx.RUnlock()\n\tif !ok {\n\t\treq.err <- fmt.Errorf(\"attempted to update non-existent funding state\")\n\t\treq.completeChan <- nil\n\t\treturn\n\t}\n\n\t// Grab the mutex on the ChannelReservation to ensure thread-safety\n\tpendingReservation.Lock()\n\tdefer pendingReservation.Unlock()\n\n\tchanState := pendingReservation.partialState\n\tchanState.FundingOutpoint = *req.fundingOutpoint\n\tfundingTxIn := wire.NewTxIn(req.fundingOutpoint, nil, nil)\n\n\t// Now that we have the funding outpoint, we can generate both versions\n\t// of the commitment transaction, and generate a signature for the\n\t// remote node's commitment transactions.\n\tlocalBalance := pendingReservation.partialState.LocalCommitment.LocalBalance.ToSatoshis()\n\tremoteBalance := pendingReservation.partialState.LocalCommitment.RemoteBalance.ToSatoshis()\n\tvar leaseExpiry uint32\n\tif pendingReservation.partialState.ChanType.HasLeaseExpiration() {\n\t\tleaseExpiry = pendingReservation.partialState.ThawHeight\n\t}\n\tourCommitTx, theirCommitTx, err := CreateCommitmentTxns(\n\t\tlocalBalance, remoteBalance,\n\t\tpendingReservation.ourContribution.ChannelConfig,\n\t\tpendingReservation.theirContribution.ChannelConfig,\n\t\tpendingReservation.ourContribution.FirstCommitmentPoint,\n\t\tpendingReservation.theirContribution.FirstCommitmentPoint,\n\t\t*fundingTxIn, pendingReservation.partialState.ChanType,\n\t\tpendingReservation.partialState.IsInitiator, leaseExpiry,\n\t)\n\tif err != nil {\n\t\treq.err <- err\n\t\treq.completeChan <- nil\n\t\treturn\n\t}\n\n\t// With both commitment transactions constructed, we can now use the\n\t// generator state obfuscator to encode the current state number within\n\t// both commitment transactions.\n\tstateObfuscator := DeriveStateHintObfuscator(\n\t\tpendingReservation.theirContribution.PaymentBasePoint.PubKey,\n\t\tpendingReservation.ourContribution.PaymentBasePoint.PubKey,\n\t)\n\terr = initStateHints(ourCommitTx, theirCommitTx, stateObfuscator)\n\tif err != nil {\n\t\treq.err <- err\n\t\treq.completeChan <- nil\n\t\treturn\n\t}\n\n\t// Sort both transactions according to the agreed upon canonical\n\t// ordering. This ensures that both parties sign the same sighash\n\t// without further synchronization.\n\ttxsort.InPlaceSort(ourCommitTx)\n\ttxsort.InPlaceSort(theirCommitTx)\n\tchanState.LocalCommitment.CommitTx = ourCommitTx\n\tchanState.RemoteCommitment.CommitTx = theirCommitTx\n\n\twalletLog.Debugf(\"Local commit tx for ChannelPoint(%v): %v\",\n\t\treq.fundingOutpoint, spew.Sdump(ourCommitTx))\n\twalletLog.Debugf(\"Remote commit tx for ChannelPoint(%v): %v\",\n\t\treq.fundingOutpoint, spew.Sdump(theirCommitTx))\n\n\tchannelValue := int64(pendingReservation.partialState.Capacity)\n\thashCache := input.NewTxSigHashesV0Only(ourCommitTx)\n\ttheirKey := pendingReservation.theirContribution.MultiSigKey\n\tourKey := pendingReservation.ourContribution.MultiSigKey\n\twitnessScript, _, err := input.GenFundingPkScript(\n\t\tourKey.PubKey.SerializeCompressed(),\n\t\ttheirKey.PubKey.SerializeCompressed(), channelValue,\n\t)\n\tif err != nil {\n\t\treq.err <- err\n\t\treq.completeChan <- nil\n\t\treturn\n\t}\n\n\tsigHash, err := txscript.CalcWitnessSigHash(\n\t\twitnessScript, hashCache, txscript.SigHashAll, ourCommitTx, 0,\n\t\tchannelValue,\n\t)\n\tif err != nil {\n\t\treq.err <- err\n\t\treq.completeChan <- nil\n\t\treturn\n\t}\n\n\t// Verify that we've received a valid signature from the remote party\n\t// for our version of the commitment transaction.\n\tif !req.theirCommitmentSig.Verify(sigHash, theirKey.PubKey) {\n\t\treq.err <- fmt.Errorf(\"counterparty's commitment signature \" +\n\t\t\t\"is invalid\")\n\t\treq.completeChan <- nil\n\t\treturn\n\t}\n\ttheirCommitSigBytes := req.theirCommitmentSig.Serialize()\n\tchanState.LocalCommitment.CommitSig = theirCommitSigBytes\n\n\t// With their signature for our version of the commitment transactions\n\t// verified, we can now generate a signature for their version,\n\t// allowing the funding transaction to be safely broadcast.\n\tp2wsh, err := input.WitnessScriptHash(witnessScript)\n\tif err != nil {\n\t\treq.err <- err\n\t\treq.completeChan <- nil\n\t\treturn\n\t}\n\tsignDesc := input.SignDescriptor{\n\t\tWitnessScript: witnessScript,\n\t\tKeyDesc:       ourKey,\n\t\tOutput: &wire.TxOut{\n\t\t\tPkScript: p2wsh,\n\t\t\tValue:    channelValue,\n\t\t},\n\t\tHashType:   txscript.SigHashAll,\n\t\tSigHashes:  input.NewTxSigHashesV0Only(theirCommitTx),\n\t\tInputIndex: 0,\n\t}\n\tsigTheirCommit, err := l.Cfg.Signer.SignOutputRaw(theirCommitTx, &signDesc)\n\tif err != nil {\n\t\treq.err <- err\n\t\treq.completeChan <- nil\n\t\treturn\n\t}\n\tpendingReservation.ourCommitmentSig = sigTheirCommit\n\n\t_, bestHeight, err := l.Cfg.ChainIO.GetBestBlock()\n\tif err != nil {\n\t\treq.err <- err\n\t\treq.completeChan <- nil\n\t\treturn\n\t}\n\n\t// Set optional upfront shutdown scripts on the channel state so that they\n\t// are persisted. These values may be nil.\n\tchanState.LocalShutdownScript =\n\t\tpendingReservation.ourContribution.UpfrontShutdown\n\tchanState.RemoteShutdownScript =\n\t\tpendingReservation.theirContribution.UpfrontShutdown\n\n\t// Add the complete funding transaction to the DB, in it's open bucket\n\t// which will be used for the lifetime of this channel.\n\tchanState.LocalChanCfg = pendingReservation.ourContribution.toChanConfig()\n\tchanState.RemoteChanCfg = pendingReservation.theirContribution.toChanConfig()\n\n\tchanState.RevocationKeyLocator = pendingReservation.nextRevocationKeyLoc\n\n\terr = chanState.SyncPending(pendingReservation.nodeAddr, uint32(bestHeight))\n\tif err != nil {\n\t\treq.err <- err\n\t\treq.completeChan <- nil\n\t\treturn\n\t}\n\n\treq.completeChan <- chanState\n\treq.err <- nil\n\n\tl.limboMtx.Lock()\n\tdelete(l.fundingLimbo, req.pendingFundingID)\n\tdelete(l.reservationIDs, pendingReservation.pendingChanID)\n\tl.limboMtx.Unlock()\n\n\tl.intentMtx.Lock()\n\tdelete(l.fundingIntents, pendingReservation.pendingChanID)\n\tl.intentMtx.Unlock()\n}\n\n// WithCoinSelectLock will execute the passed function closure in a\n// synchronized manner preventing any coin selection operations from proceeding\n// while the closure is executing. This can be seen as the ability to execute a\n// function closure under an exclusive coin selection lock.",
      "length": 5847,
      "tokens": 568,
      "embedding": []
    },
    {
      "slug": "func (l *LightningWallet) WithCoinSelectLock(f func() error) error {",
      "content": "func (l *LightningWallet) WithCoinSelectLock(f func() error) error {\n\tl.coinSelectMtx.Lock()\n\tdefer l.coinSelectMtx.Unlock()\n\n\treturn f()\n}\n\n// DeriveStateHintObfuscator derives the bytes to be used for obfuscating the\n// state hints from the root to be used for a new channel. The obfuscator is\n// generated via the following computation:\n//\n//   - sha256(initiatorKey || responderKey)[26:]\n//     -- where both keys are the multi-sig keys of the respective parties\n//\n// The first 6 bytes of the resulting hash are used as the state hint.",
      "length": 458,
      "tokens": 74,
      "embedding": []
    },
    {
      "slug": "func DeriveStateHintObfuscator(key1, key2 *btcec.PublicKey) [StateHintSize]byte {",
      "content": "func DeriveStateHintObfuscator(key1, key2 *btcec.PublicKey) [StateHintSize]byte {\n\th := sha256.New()\n\th.Write(key1.SerializeCompressed())\n\th.Write(key2.SerializeCompressed())\n\n\tsha := h.Sum(nil)\n\n\tvar obfuscator [StateHintSize]byte\n\tcopy(obfuscator[:], sha[26:])\n\n\treturn obfuscator\n}\n\n// initStateHints properly sets the obfuscated state hints on both commitment\n// transactions using the passed obfuscator.",
      "length": 313,
      "tokens": 33,
      "embedding": []
    },
    {
      "slug": "func initStateHints(commit1, commit2 *wire.MsgTx,",
      "content": "func initStateHints(commit1, commit2 *wire.MsgTx,\n\tobfuscator [StateHintSize]byte) error {\n\n\tif err := SetStateNumHint(commit1, 0, obfuscator); err != nil {\n\t\treturn err\n\t}\n\tif err := SetStateNumHint(commit2, 0, obfuscator); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// ValidateChannel will attempt to fully validate a newly mined channel, given\n// its funding transaction and existing channel state. If this method returns\n// an error, then the mined channel is invalid, and shouldn't be used.",
      "length": 433,
      "tokens": 70,
      "embedding": []
    },
    {
      "slug": "func (l *LightningWallet) ValidateChannel(channelState *channeldb.OpenChannel,",
      "content": "func (l *LightningWallet) ValidateChannel(channelState *channeldb.OpenChannel,\n\tfundingTx *wire.MsgTx) error {\n\n\t// First, we'll obtain a fully signed commitment transaction so we can\n\t// pass into it on the chanvalidate package for verification.\n\tchannel, err := NewLightningChannel(l.Cfg.Signer, channelState, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tsignedCommitTx, err := channel.getSignedCommitTx()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// We'll also need the multi-sig witness script itself so the\n\t// chanvalidate package can check it for correctness against the\n\t// funding transaction, and also commitment validity.\n\tlocalKey := channelState.LocalChanCfg.MultiSigKey.PubKey\n\tremoteKey := channelState.RemoteChanCfg.MultiSigKey.PubKey\n\twitnessScript, err := input.GenMultiSigScript(\n\t\tlocalKey.SerializeCompressed(),\n\t\tremoteKey.SerializeCompressed(),\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\tpkScript, err := input.WitnessScriptHash(witnessScript)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Finally, we'll pass in all the necessary context needed to fully\n\t// validate that this channel is indeed what we expect, and can be\n\t// used.\n\t_, err = chanvalidate.Validate(&chanvalidate.Context{\n\t\tLocator: &chanvalidate.OutPointChanLocator{\n\t\t\tChanPoint: channelState.FundingOutpoint,\n\t\t},\n\t\tMultiSigPkScript: pkScript,\n\t\tFundingTx:        fundingTx,\n\t\tCommitCtx: &chanvalidate.CommitmentContext{\n\t\t\tValue:               channel.Capacity,\n\t\t\tFullySignedCommitTx: signedCommitTx,\n\t\t},\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// CoinSource is a wrapper around the wallet that implements the\n// chanfunding.CoinSource interface.",
      "length": 1496,
      "tokens": 186,
      "embedding": []
    },
    {
      "slug": "type CoinSource struct {",
      "content": "type CoinSource struct {\n\twallet *LightningWallet\n}\n\n// NewCoinSource creates a new instance of the CoinSource wrapper struct.",
      "length": 98,
      "tokens": 14,
      "embedding": []
    },
    {
      "slug": "func NewCoinSource(w *LightningWallet) *CoinSource {",
      "content": "func NewCoinSource(w *LightningWallet) *CoinSource {\n\treturn &CoinSource{wallet: w}\n}\n\n// ListCoins returns all UTXOs from the source that have between\n// minConfs and maxConfs number of confirmations.",
      "length": 144,
      "tokens": 22,
      "embedding": []
    },
    {
      "slug": "func (c *CoinSource) ListCoins(minConfs int32,",
      "content": "func (c *CoinSource) ListCoins(minConfs int32,\n\tmaxConfs int32) ([]chanfunding.Coin, error) {\n\n\tutxos, err := c.wallet.ListUnspentWitnessFromDefaultAccount(\n\t\tminConfs, maxConfs,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar coins []chanfunding.Coin\n\tfor _, utxo := range utxos {\n\t\tcoins = append(coins, chanfunding.Coin{\n\t\t\tTxOut: wire.TxOut{\n\t\t\t\tValue:    int64(utxo.Value),\n\t\t\t\tPkScript: utxo.PkScript,\n\t\t\t},\n\t\t\tOutPoint: utxo.OutPoint,\n\t\t})\n\t}\n\n\treturn coins, nil\n}\n\n// CoinFromOutPoint attempts to locate details pertaining to a coin based on\n// its outpoint. If the coin isn't under the control of the backing CoinSource,\n// then an error should be returned.",
      "length": 593,
      "tokens": 83,
      "embedding": []
    },
    {
      "slug": "func (c *CoinSource) CoinFromOutPoint(op wire.OutPoint) (*chanfunding.Coin, error) {",
      "content": "func (c *CoinSource) CoinFromOutPoint(op wire.OutPoint) (*chanfunding.Coin, error) {\n\tinputInfo, err := c.wallet.FetchInputInfo(&op)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &chanfunding.Coin{\n\t\tTxOut: wire.TxOut{\n\t\t\tValue:    int64(inputInfo.Value),\n\t\t\tPkScript: inputInfo.PkScript,\n\t\t},\n\t\tOutPoint: inputInfo.OutPoint,\n\t}, nil\n}\n\n// shimKeyRing is a wrapper struct that's used to provide the proper multi-sig\n// key for an initiated external funding flow.",
      "length": 363,
      "tokens": 48,
      "embedding": []
    },
    {
      "slug": "type shimKeyRing struct {",
      "content": "type shimKeyRing struct {\n\tkeychain.KeyRing\n\n\t*chanfunding.ShimIntent\n}\n\n// DeriveNextKey intercepts the normal DeriveNextKey call to a keychain.KeyRing\n// instance, and supplies the multi-sig key specified by the ShimIntent. This\n// allows us to transparently insert new keys into the existing funding flow,\n// as these keys may not come from the wallet itself.",
      "length": 328,
      "tokens": 49,
      "embedding": []
    },
    {
      "slug": "func (s *shimKeyRing) DeriveNextKey(keyFam keychain.KeyFamily) (keychain.KeyDescriptor, error) {",
      "content": "func (s *shimKeyRing) DeriveNextKey(keyFam keychain.KeyFamily) (keychain.KeyDescriptor, error) {\n\tif keyFam != keychain.KeyFamilyMultiSig {\n\t\treturn s.KeyRing.DeriveNextKey(keyFam)\n\t}\n\n\tfundingKeys, err := s.ShimIntent.MultiSigKeys()\n\tif err != nil {\n\t\treturn keychain.KeyDescriptor{}, err\n\t}\n\n\treturn *fundingKeys.LocalKey, nil\n}\n\n// ValidateUpfrontShutdown checks whether the provided upfront_shutdown_script\n// is of a valid type that we accept.",
      "length": 338,
      "tokens": 41,
      "embedding": []
    },
    {
      "slug": "func ValidateUpfrontShutdown(shutdown lnwire.DeliveryAddress,",
      "content": "func ValidateUpfrontShutdown(shutdown lnwire.DeliveryAddress,\n\tparams *chaincfg.Params) bool {\n\n\t// We don't need to worry about a large UpfrontShutdownScript since it\n\t// was already checked in lnwire when decoding from the wire.\n\tscriptClass, _, _, _ := txscript.ExtractPkScriptAddrs(shutdown, params)\n\n\tswitch {\n\tcase scriptClass == txscript.WitnessV0PubKeyHashTy,\n\t\tscriptClass == txscript.WitnessV0ScriptHashTy,\n\t\tscriptClass == txscript.WitnessV1TaprootTy:\n\n\t\t// The above three types are permitted according to BOLT#02 and\n\t\t// BOLT#05.  Everything else is disallowed.\n\t\treturn true\n\n\t// In this case, we don't know about the actual script template, but it\n\t// might be a witness program with versions 2-16. So we'll check that\n\t// now\n\tcase txscript.IsWitnessProgram(shutdown):\n\t\tversion, _, err := txscript.ExtractWitnessProgramInfo(shutdown)\n\t\tif err != nil {\n\t\t\twalletLog.Warnf(\"unable to extract witness program \"+\n\t\t\t\t\"version (script=%x): %v\", shutdown, err)\n\t\t\treturn false\n\t\t}\n\n\t\treturn version >= 1 && version <= 16\n\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// WalletPrevOutputFetcher is a txscript.PrevOutputFetcher that can fetch\n// outputs from a given wallet controller.",
      "length": 1085,
      "tokens": 148,
      "embedding": []
    },
    {
      "slug": "type WalletPrevOutputFetcher struct {",
      "content": "type WalletPrevOutputFetcher struct {\n\twc WalletController\n}\n\n// A compile time assertion that WalletPrevOutputFetcher implements the\n// txscript.PrevOutputFetcher interface.\nvar _ txscript.PrevOutputFetcher = (*WalletPrevOutputFetcher)(nil)\n\n// NewWalletPrevOutputFetcher creates a new WalletPrevOutputFetcher that fetches\n// previous outputs from the given wallet controller.",
      "length": 331,
      "tokens": 36,
      "embedding": []
    },
    {
      "slug": "func NewWalletPrevOutputFetcher(wc WalletController) *WalletPrevOutputFetcher {",
      "content": "func NewWalletPrevOutputFetcher(wc WalletController) *WalletPrevOutputFetcher {\n\treturn &WalletPrevOutputFetcher{\n\t\twc: wc,\n\t}\n}\n\n// FetchPrevOutput attempts to fetch the previous output referenced by the\n// passed outpoint. A nil value will be returned if the passed outpoint doesn't\n// exist.",
      "length": 207,
      "tokens": 33,
      "embedding": []
    },
    {
      "slug": "func (w *WalletPrevOutputFetcher) FetchPrevOutput(op wire.OutPoint) *wire.TxOut {",
      "content": "func (w *WalletPrevOutputFetcher) FetchPrevOutput(op wire.OutPoint) *wire.TxOut {\n\tutxo, err := w.wc.FetchInputInfo(&op)\n\tif err != nil {\n\t\treturn nil\n\t}\n\n\treturn &wire.TxOut{\n\t\tValue:    int64(utxo.Value),\n\t\tPkScript: utxo.PkScript,\n\t}\n}\n",
      "length": 147,
      "tokens": 20,
      "embedding": []
    }
  ]
}