{
  "filepath": "../implementations/go/lnd/lnwallet/chancloser/chancloser.go",
  "package": "chancloser",
  "sections": [
    {
      "slug": "type closeState uint8",
      "content": "type closeState uint8\n\nconst (\n\t// closeIdle is the initial starting state. In this state, the state\n\t// machine has been instantiated, but no state transitions have been\n\t// attempted. If a state machine receives a message while in this state,\n\t// then it is the responder to an initiated cooperative channel closure.\n\tcloseIdle closeState = iota\n\n\t// closeShutdownInitiated is the state that's transitioned to once the\n\t// initiator of a closing workflow sends the shutdown message. At this\n\t// point, they're waiting for the remote party to respond with their own\n\t// shutdown message. After which, they'll both enter the fee negotiation\n\t// phase.\n\tcloseShutdownInitiated\n\n\t// closeFeeNegotiation is the third, and most persistent state. Both\n\t// parties enter this state after they've sent and received a shutdown\n\t// message. During this phase, both sides will send monotonically\n\t// increasing fee requests until one side accepts the last fee rate offered\n\t// by the other party. In this case, the party will broadcast the closing\n\t// transaction, and send the accepted fee to the remote party. This then\n\t// causes a shift into the closeFinished state.\n\tcloseFeeNegotiation\n\n\t// closeFinished is the final state of the state machine. In this state, a\n\t// side has accepted a fee offer and has broadcast the valid closing\n\t// transaction to the network. During this phase, the closing transaction\n\t// becomes available for examination.\n\tcloseFinished\n)\n\nconst (\n\t// defaultMaxFeeMultiplier is a multiplier we'll apply to the ideal fee\n\t// of the initiator, to decide when the negotiated fee is too high. By\n\t// default, we want to bail out if we attempt to negotiate a fee that's\n\t// 3x higher than our max fee.\n\tdefaultMaxFeeMultiplier = 3\n)\n\n// Channel abstracts away from the core channel state machine by exposing an\n// interface that requires only the methods we need to carry out the channel\n// closing process.",
      "length": 1861,
      "tokens": 312,
      "embedding": []
    },
    {
      "slug": "type Channel interface {",
      "content": "type Channel interface {\n\t// ChannelPoint returns the channel point of the target channel.\n\tChannelPoint() *wire.OutPoint\n\n\t// MarkCoopBroadcasted persistently marks that the channel close\n\t// transaction has been broadcast.\n\tMarkCoopBroadcasted(*wire.MsgTx, bool) error\n\n\t// IsInitiator returns true we are the initiator of the channel.\n\tIsInitiator() bool\n\n\t// ShortChanID returns the scid of the channel.\n\tShortChanID() lnwire.ShortChannelID\n\n\t// AbsoluteThawHeight returns the absolute thaw height of the channel.\n\t// If the channel is pending, or an unconfirmed zero conf channel, then\n\t// an error should be returned.\n\tAbsoluteThawHeight() (uint32, error)\n\n\t// LocalBalanceDust returns true if when creating a co-op close\n\t// transaction, the balance of the local party will be dust after\n\t// accounting for any anchor outputs.\n\tLocalBalanceDust() bool\n\n\t// RemoteBalanceDust returns true if when creating a co-op close\n\t// transaction, the balance of the remote party will be dust after\n\t// accounting for any anchor outputs.\n\tRemoteBalanceDust() bool\n\n\t// RemoteUpfrontShutdownScript returns the upfront shutdown script of\n\t// the remote party. If the remote party didn't specify such a script,\n\t// an empty delivery address should be returned.\n\tRemoteUpfrontShutdownScript() lnwire.DeliveryAddress\n\n\t// CreateCloseProposal creates a new co-op close proposal in the form\n\t// of a valid signature, the chainhash of the final txid, and our final\n\t// balance in the created state.\n\tCreateCloseProposal(proposedFee btcutil.Amount, localDeliveryScript []byte,\n\t\tremoteDeliveryScript []byte) (input.Signature, *chainhash.Hash,\n\t\tbtcutil.Amount, error)\n\n\t// CompleteCooperativeClose persistently \"completes\" the cooperative\n\t// close by producing a fully signed co-op close transaction.\n\tCompleteCooperativeClose(localSig, remoteSig input.Signature,\n\t\tlocalDeliveryScript, remoteDeliveryScript []byte,\n\t\tproposedFee btcutil.Amount) (*wire.MsgTx, btcutil.Amount, error)\n}\n\n// CoopFeeEstimator is used to estimate the fee of a co-op close transaction.",
      "length": 1978,
      "tokens": 256,
      "embedding": []
    },
    {
      "slug": "type CoopFeeEstimator interface {",
      "content": "type CoopFeeEstimator interface {\n\t// EstimateFee estimates an _absolute_ fee for a co-op close transaction\n\t// given the local+remote tx outs (for the co-op close transaction),\n\t// channel type, and ideal fee rate. If a passed TxOut is nil, then\n\t// that indicates that an output is dust on the co-op close transaction\n\t// _before_ fees are accounted for.\n\tEstimateFee(chanType channeldb.ChannelType,\n\t\tlocalTxOut, remoteTxOut *wire.TxOut,\n\t\tidealFeeRate chainfee.SatPerKWeight) btcutil.Amount\n}\n\n// ChanCloseCfg holds all the items that a ChanCloser requires to carry out its\n// duties.",
      "length": 543,
      "tokens": 80,
      "embedding": []
    },
    {
      "slug": "type ChanCloseCfg struct {",
      "content": "type ChanCloseCfg struct {\n\t// Channel is the channel that should be closed.\n\tChannel Channel\n\n\t// BroadcastTx broadcasts the passed transaction to the network.\n\tBroadcastTx func(*wire.MsgTx, string) error\n\n\t// DisableChannel disables a channel, resulting in it not being able to\n\t// forward payments.\n\tDisableChannel func(wire.OutPoint) error\n\n\t// Disconnect will disconnect from the remote peer in this close.\n\tDisconnect func() error\n\n\t// MaxFee, is non-zero represents the highest fee that the initiator is\n\t// willing to pay to close the channel.\n\tMaxFee chainfee.SatPerKWeight\n\n\t// ChainParams holds the parameters of the chain that we're active on.\n\tChainParams *chaincfg.Params\n\n\t// Quit is a channel that should be sent upon in the occasion the state\n\t// machine should cease all progress and shutdown.\n\tQuit chan struct{}\n\n\t// FeeEstimator is used to estimate the absolute starting co-op close\n\t// fee.\n\tFeeEstimator CoopFeeEstimator\n}\n\n// ChanCloser is a state machine that handles the cooperative channel closure\n// procedure. This includes shutting down a channel, marking it ineligible for\n// routing HTLC's, negotiating fees with the remote party, and finally\n// broadcasting the fully signed closure transaction to the network.",
      "length": 1184,
      "tokens": 179,
      "embedding": []
    },
    {
      "slug": "type ChanCloser struct {",
      "content": "type ChanCloser struct {\n\t// state is the current state of the state machine.\n\tstate closeState\n\n\t// cfg holds the configuration for this ChanCloser instance.\n\tcfg ChanCloseCfg\n\n\t// chanPoint is the full channel point of the target channel.\n\tchanPoint wire.OutPoint\n\n\t// cid is the full channel ID of the target channel.\n\tcid lnwire.ChannelID\n\n\t// negotiationHeight is the height that the fee negotiation begun at.\n\tnegotiationHeight uint32\n\n\t// closingTx is the final, fully signed closing transaction. This will only\n\t// be populated once the state machine shifts to the closeFinished state.\n\tclosingTx *wire.MsgTx\n\n\t// idealFeeSat is the ideal fee that the state machine should initially\n\t// offer when starting negotiation. This will be used as a baseline.\n\tidealFeeSat btcutil.Amount\n\n\t// maxFee is the highest fee the initiator is willing to pay to close\n\t// out the channel. This is either a use specified value, or a default\n\t// multiplier based of the initial starting ideal fee.\n\tmaxFee btcutil.Amount\n\n\t// idealFeeRate is our ideal fee rate.\n\tidealFeeRate chainfee.SatPerKWeight\n\n\t// lastFeeProposal is the last fee that we proposed to the remote party.\n\t// We'll use this as a pivot point to ratchet our next offer up, down, or\n\t// simply accept the remote party's prior offer.\n\tlastFeeProposal btcutil.Amount\n\n\t// priorFeeOffers is a map that keeps track of all the proposed fees that\n\t// we've offered during the fee negotiation. We use this map to cut the\n\t// negotiation early if the remote party ever sends an offer that we've\n\t// sent in the past. Once negotiation terminates, we can extract the prior\n\t// signature of our accepted offer from this map.\n\t//\n\t// TODO(roasbeef): need to ensure if they broadcast w/ any of our prior\n\t// sigs, we are aware of\n\tpriorFeeOffers map[btcutil.Amount]*lnwire.ClosingSigned\n\n\t// closeReq is the initial closing request. This will only be populated if\n\t// we're the initiator of this closing negotiation.\n\t//\n\t// TODO(roasbeef): abstract away\n\tcloseReq *htlcswitch.ChanClose\n\n\t// localDeliveryScript is the script that we'll send our settled channel\n\t// funds to.\n\tlocalDeliveryScript []byte\n\n\t// remoteDeliveryScript is the script that we'll send the remote party's\n\t// settled channel funds to.\n\tremoteDeliveryScript []byte\n\n\t// locallyInitiated is true if we initiated the channel close.\n\tlocallyInitiated bool\n}\n\n// calcCoopCloseFee computes an \"ideal\" absolute co-op close fee given the\n// delivery scripts of both parties and our ideal fee rate.",
      "length": 2417,
      "tokens": 383,
      "embedding": []
    },
    {
      "slug": "func calcCoopCloseFee(localOutput, remoteOutput *wire.TxOut,",
      "content": "func calcCoopCloseFee(localOutput, remoteOutput *wire.TxOut,\n\tidealFeeRate chainfee.SatPerKWeight) btcutil.Amount {\n\n\tvar weightEstimator input.TxWeightEstimator\n\n\tweightEstimator.AddWitnessInput(input.MultiSigWitnessSize)\n\n\t// One of these outputs might be dust, so we'll skip adding it to our\n\t// mock transaction, so the fees are more accurate.\n\tif localOutput != nil {\n\t\tweightEstimator.AddTxOutput(localOutput)\n\t}\n\tif remoteOutput != nil {\n\t\tweightEstimator.AddTxOutput(remoteOutput)\n\t}\n\n\ttotalWeight := int64(weightEstimator.Weight())\n\n\treturn idealFeeRate.FeeForWeight(totalWeight)\n}\n\n// SimpleCoopFeeEstimator is the default co-op close fee estimator. It assumes\n// a normal segwit v0 channel, and that no outputs on the closing transaction\n// are dust.",
      "length": 678,
      "tokens": 80,
      "embedding": []
    },
    {
      "slug": "type SimpleCoopFeeEstimator struct {",
      "content": "type SimpleCoopFeeEstimator struct {\n}\n\n// EstimateFee estimates an _absolute_ fee for a co-op close transaction given\n// the local+remote tx outs (for the co-op close transaction), channel type,\n// and ideal fee rate.",
      "length": 177,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func (d *SimpleCoopFeeEstimator) EstimateFee(chanType channeldb.ChannelType,",
      "content": "func (d *SimpleCoopFeeEstimator) EstimateFee(chanType channeldb.ChannelType,\n\tlocalTxOut, remoteTxOut *wire.TxOut,\n\tidealFeeRate chainfee.SatPerKWeight) btcutil.Amount {\n\n\treturn calcCoopCloseFee(localTxOut, remoteTxOut, idealFeeRate)\n}\n\n// NewChanCloser creates a new instance of the channel closure given the passed\n// configuration, and delivery+fee preference. The final argument should only\n// be populated iff, we're the initiator of this closing request.",
      "length": 376,
      "tokens": 46,
      "embedding": []
    },
    {
      "slug": "func NewChanCloser(cfg ChanCloseCfg, deliveryScript []byte,",
      "content": "func NewChanCloser(cfg ChanCloseCfg, deliveryScript []byte,\n\tidealFeePerKw chainfee.SatPerKWeight, negotiationHeight uint32,\n\tcloseReq *htlcswitch.ChanClose, locallyInitiated bool) *ChanCloser {\n\n\tcid := lnwire.NewChanIDFromOutPoint(cfg.Channel.ChannelPoint())\n\treturn &ChanCloser{\n\t\tcloseReq:            closeReq,\n\t\tstate:               closeIdle,\n\t\tchanPoint:           *cfg.Channel.ChannelPoint(),\n\t\tcid:                 cid,\n\t\tcfg:                 cfg,\n\t\tnegotiationHeight:   negotiationHeight,\n\t\tidealFeeRate:        idealFeePerKw,\n\t\tlocalDeliveryScript: deliveryScript,\n\t\tpriorFeeOffers:      make(map[btcutil.Amount]*lnwire.ClosingSigned),\n\t\tlocallyInitiated:    locallyInitiated,\n\t}\n}\n\n// initFeeBaseline computes our ideal fee rate, and also the largest fee we'll\n// accept given information about the delivery script of the remote party.",
      "length": 768,
      "tokens": 62,
      "embedding": []
    },
    {
      "slug": "func (c *ChanCloser) initFeeBaseline() {",
      "content": "func (c *ChanCloser) initFeeBaseline() {\n\t// Depending on if a balance ends up being dust or not, we'll pass a\n\t// nil TxOut into the EstimateFee call which can handle it.\n\tvar localTxOut, remoteTxOut *wire.TxOut\n\tif !c.cfg.Channel.LocalBalanceDust() {\n\t\tlocalTxOut = &wire.TxOut{\n\t\t\tPkScript: c.localDeliveryScript,\n\t\t\tValue:    0,\n\t\t}\n\t}\n\tif !c.cfg.Channel.RemoteBalanceDust() {\n\t\tremoteTxOut = &wire.TxOut{\n\t\t\tPkScript: c.remoteDeliveryScript,\n\t\t\tValue:    0,\n\t\t}\n\t}\n\n\t// Given the target fee-per-kw, we'll compute what our ideal _total_\n\t// fee will be starting at for this fee negotiation.\n\tc.idealFeeSat = c.cfg.FeeEstimator.EstimateFee(\n\t\t0, localTxOut, remoteTxOut, c.idealFeeRate,\n\t)\n\n\t// When we're the initiator, we'll want to also factor in the highest\n\t// fee we want to pay. This'll either be 3x the ideal fee, or the\n\t// specified explicit max fee.\n\tc.maxFee = c.idealFeeSat * defaultMaxFeeMultiplier\n\tif c.cfg.MaxFee > 0 {\n\t\tc.maxFee = c.cfg.FeeEstimator.EstimateFee(\n\t\t\t0, localTxOut, remoteTxOut, c.cfg.MaxFee,\n\t\t)\n\t}\n\n\tchancloserLog.Infof(\"Ideal fee for closure of ChannelPoint(%v) \"+\n\t\t\"is: %v sat (max_fee=%v sat)\", c.cfg.Channel.ChannelPoint(),\n\t\tint64(c.idealFeeSat), int64(c.maxFee))\n}\n\n// initChanShutdown begins the shutdown process by un-registering the channel,\n// and creating a valid shutdown message to our target delivery address.",
      "length": 1283,
      "tokens": 173,
      "embedding": []
    },
    {
      "slug": "func (c *ChanCloser) initChanShutdown() (*lnwire.Shutdown, error) {",
      "content": "func (c *ChanCloser) initChanShutdown() (*lnwire.Shutdown, error) {\n\t// With both items constructed we'll now send the shutdown message for this\n\t// particular channel, advertising a shutdown request to our desired\n\t// closing script.\n\tshutdown := lnwire.NewShutdown(c.cid, c.localDeliveryScript)\n\n\t// Before closing, we'll attempt to send a disable update for the channel.\n\t// We do so before closing the channel as otherwise the current edge policy\n\t// won't be retrievable from the graph.\n\tif err := c.cfg.DisableChannel(c.chanPoint); err != nil {\n\t\tchancloserLog.Warnf(\"Unable to disable channel %v on close: %v\",\n\t\t\tc.chanPoint, err)\n\t}\n\n\t// Before continuing, mark the channel as cooperatively closed with a nil\n\t// txn. Even though we haven't negotiated the final txn, this guarantees\n\t// that our listchannels rpc will be externally consistent, and reflect\n\t// that the channel is being shutdown by the time the closing request\n\t// returns.\n\terr := c.cfg.Channel.MarkCoopBroadcasted(nil, c.locallyInitiated)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tchancloserLog.Infof(\"ChannelPoint(%v): sending shutdown message\",\n\t\tc.chanPoint)\n\n\treturn shutdown, nil\n}\n\n// ShutdownChan is the first method that's to be called by the initiator of the\n// cooperative channel closure. This message returns the shutdown message to\n// send to the remote party. Upon completion, we enter the\n// closeShutdownInitiated phase as we await a response.",
      "length": 1334,
      "tokens": 200,
      "embedding": []
    },
    {
      "slug": "func (c *ChanCloser) ShutdownChan() (*lnwire.Shutdown, error) {",
      "content": "func (c *ChanCloser) ShutdownChan() (*lnwire.Shutdown, error) {\n\t// If we attempt to shutdown the channel for the first time, and we're not\n\t// in the closeIdle state, then the caller made an error.\n\tif c.state != closeIdle {\n\t\treturn nil, ErrChanAlreadyClosing\n\t}\n\n\tchancloserLog.Infof(\"ChannelPoint(%v): initiating shutdown\", c.chanPoint)\n\n\tshutdownMsg, err := c.initChanShutdown()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// With the opening steps complete, we'll transition into the\n\t// closeShutdownInitiated state. In this state, we'll wait until the other\n\t// party sends their version of the shutdown message.\n\tc.state = closeShutdownInitiated\n\n\t// Finally, we'll return the shutdown message to the caller so it can send\n\t// it to the remote peer.\n\treturn shutdownMsg, nil\n}\n\n// ClosingTx returns the fully signed, final closing transaction.\n//\n// NOTE: This transaction is only available if the state machine is in the\n// closeFinished state.",
      "length": 860,
      "tokens": 136,
      "embedding": []
    },
    {
      "slug": "func (c *ChanCloser) ClosingTx() (*wire.MsgTx, error) {",
      "content": "func (c *ChanCloser) ClosingTx() (*wire.MsgTx, error) {\n\t// If the state machine hasn't finished closing the channel, then we'll\n\t// return an error as we haven't yet computed the closing tx.\n\tif c.state != closeFinished {\n\t\treturn nil, ErrChanCloseNotFinished\n\t}\n\n\treturn c.closingTx, nil\n}\n\n// CloseRequest returns the original close request that prompted the creation\n// of the state machine.\n//\n// NOTE: This will only return a non-nil pointer if we were the initiator of\n// the cooperative closure workflow.",
      "length": 443,
      "tokens": 74,
      "embedding": []
    },
    {
      "slug": "func (c *ChanCloser) CloseRequest() *htlcswitch.ChanClose {",
      "content": "func (c *ChanCloser) CloseRequest() *htlcswitch.ChanClose {\n\treturn c.closeReq\n}\n\n// Channel returns the channel stored in the config as a\n// *lnwallet.LightningChannel.\n//\n// NOTE: This method will PANIC if the underlying channel implementation isn't\n// the desired type.",
      "length": 205,
      "tokens": 33,
      "embedding": []
    },
    {
      "slug": "func (c *ChanCloser) Channel() *lnwallet.LightningChannel {",
      "content": "func (c *ChanCloser) Channel() *lnwallet.LightningChannel {\n\treturn c.cfg.Channel.(*lnwallet.LightningChannel)\n}\n\n// NegotiationHeight returns the negotiation height.",
      "length": 103,
      "tokens": 9,
      "embedding": []
    },
    {
      "slug": "func (c *ChanCloser) NegotiationHeight() uint32 {",
      "content": "func (c *ChanCloser) NegotiationHeight() uint32 {\n\treturn c.negotiationHeight\n}\n\n// validateShutdownScript attempts to match and validate the script provided in\n// our peer's shutdown message with the upfront shutdown script we have on\n// record. For any script specified, we also make sure it matches our\n// requirements. If no upfront shutdown script was set, we do not need to\n// enforce option upfront shutdown, so the function returns early. If an\n// upfront script is set, we check whether it matches the script provided by\n// our peer. If they do not match, we use the disconnect function provided to\n// disconnect from the peer.",
      "length": 576,
      "tokens": 100,
      "embedding": []
    },
    {
      "slug": "func validateShutdownScript(disconnect func() error, upfrontScript,",
      "content": "func validateShutdownScript(disconnect func() error, upfrontScript,\n\tpeerScript lnwire.DeliveryAddress, netParams *chaincfg.Params) error {\n\n\t// Either way, we'll make sure that the script passed meets our\n\t// standards. The upfrontScript should have already been checked at an\n\t// earlier stage, but we'll repeat the check here for defense in depth.\n\tif len(upfrontScript) != 0 {\n\t\tif !lnwallet.ValidateUpfrontShutdown(upfrontScript, netParams) {\n\t\t\treturn ErrInvalidShutdownScript\n\t\t}\n\t}\n\tif len(peerScript) != 0 {\n\t\tif !lnwallet.ValidateUpfrontShutdown(peerScript, netParams) {\n\t\t\treturn ErrInvalidShutdownScript\n\t\t}\n\t}\n\n\t// If no upfront shutdown script was set, return early because we do\n\t// not need to enforce closure to a specific script.\n\tif len(upfrontScript) == 0 {\n\t\treturn nil\n\t}\n\n\t// If an upfront shutdown script was provided, disconnect from the peer, as\n\t// per BOLT 2, and return an error.\n\tif !bytes.Equal(upfrontScript, peerScript) {\n\t\tchancloserLog.Warnf(\"peer's script: %x does not match upfront \"+\n\t\t\t\"shutdown script: %x\", peerScript, upfrontScript)\n\n\t\t// Disconnect from the peer because they have violated option upfront\n\t\t// shutdown.\n\t\tif err := disconnect(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn ErrUpfrontShutdownScriptMismatch\n\t}\n\n\treturn nil\n}\n\n// ProcessCloseMsg attempts to process the next message in the closing series.\n// This method will update the state accordingly and return two primary values:\n// the next set of messages to be sent, and a bool indicating if the fee\n// negotiation process has completed. If the second value is true, then this\n// means the ChanCloser can be garbage collected.",
      "length": 1528,
      "tokens": 229,
      "embedding": []
    },
    {
      "slug": "func (c *ChanCloser) ProcessCloseMsg(msg lnwire.Message) ([]lnwire.Message,",
      "content": "func (c *ChanCloser) ProcessCloseMsg(msg lnwire.Message) ([]lnwire.Message,\n\tbool, error) {\n\n\tswitch c.state {\n\t// If we're in the close idle state, and we're receiving a channel closure\n\t// related message, then this indicates that we're on the receiving side of\n\t// an initiated channel closure.\n\tcase closeIdle:\n\t\t// First, we'll assert that we have a channel shutdown message,\n\t\t// as otherwise, this is an attempted invalid state transition.\n\t\tshutdownMsg, ok := msg.(*lnwire.Shutdown)\n\t\tif !ok {\n\t\t\treturn nil, false, fmt.Errorf(\"expected lnwire.Shutdown, instead \"+\n\t\t\t\t\"have %v\", spew.Sdump(msg))\n\t\t}\n\n\t\t// As we're the responder to this shutdown (the other party\n\t\t// wants to close), we'll check if this is a frozen channel or\n\t\t// not. If the channel is frozen and we were not also the\n\t\t// initiator of the channel opening, then we'll deny their close\n\t\t// attempt.\n\t\tchanInitiator := c.cfg.Channel.IsInitiator()\n\t\tif !chanInitiator {\n\t\t\tabsoluteThawHeight, err := c.cfg.Channel.AbsoluteThawHeight()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, false, err\n\t\t\t}\n\t\t\tif c.negotiationHeight < absoluteThawHeight {\n\t\t\t\treturn nil, false, fmt.Errorf(\"initiator \"+\n\t\t\t\t\t\"attempting to co-op close frozen \"+\n\t\t\t\t\t\"ChannelPoint(%v) (current_height=%v, \"+\n\t\t\t\t\t\"thaw_height=%v)\", c.chanPoint,\n\t\t\t\t\tc.negotiationHeight, absoluteThawHeight)\n\t\t\t}\n\t\t}\n\n\t\t// If the remote node opened the channel with option upfront shutdown\n\t\t// script, check that the script they provided matches.\n\t\tif err := validateShutdownScript(\n\t\t\tc.cfg.Disconnect, c.cfg.Channel.RemoteUpfrontShutdownScript(),\n\t\t\tshutdownMsg.Address, c.cfg.ChainParams,\n\t\t); err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\n\t\t// Once we have checked that the other party has not violated option\n\t\t// upfront shutdown we set their preference for delivery address. We'll\n\t\t// use this when we craft the closure transaction.\n\t\tc.remoteDeliveryScript = shutdownMsg.Address\n\n\t\t// Now that we know their desried delivery script, we can\n\t\t// compute what our max/ideal fee will be.\n\t\tc.initFeeBaseline()\n\n\t\t// We'll generate a shutdown message of our own to send across the\n\t\t// wire.\n\t\tlocalShutdown, err := c.initChanShutdown()\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\n\t\tchancloserLog.Infof(\"ChannelPoint(%v): responding to shutdown\",\n\t\t\tc.chanPoint)\n\n\t\tmsgsToSend := make([]lnwire.Message, 0, 2)\n\t\tmsgsToSend = append(msgsToSend, localShutdown)\n\n\t\t// After the other party receives this message, we'll actually start\n\t\t// the final stage of the closure process: fee negotiation. So we'll\n\t\t// update our internal state to reflect this, so we can handle the next\n\t\t// message sent.\n\t\tc.state = closeFeeNegotiation\n\n\t\t// We'll also craft our initial close proposal in order to keep the\n\t\t// negotiation moving, but only if we're the negotiator.\n\t\tif chanInitiator {\n\t\t\tcloseSigned, err := c.proposeCloseSigned(c.idealFeeSat)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, false, err\n\t\t\t}\n\t\t\tmsgsToSend = append(msgsToSend, closeSigned)\n\t\t}\n\n\t\t// We'll return both sets of messages to send to the remote party to\n\t\t// kick off the fee negotiation process.\n\t\treturn msgsToSend, false, nil\n\n\t// If we just initiated a channel shutdown, and we receive a new message,\n\t// then this indicates the other party is ready to shutdown as well. In\n\t// this state we'll send our first signature.\n\tcase closeShutdownInitiated:\n\t\t// First, we'll assert that we have a channel shutdown message.\n\t\t// Otherwise, this is an attempted invalid state transition.\n\t\tshutdownMsg, ok := msg.(*lnwire.Shutdown)\n\t\tif !ok {\n\t\t\treturn nil, false, fmt.Errorf(\"expected lnwire.Shutdown, instead \"+\n\t\t\t\t\"have %v\", spew.Sdump(msg))\n\t\t}\n\n\t\t// If the remote node opened the channel with option upfront shutdown\n\t\t// script, check that the script they provided matches.\n\t\tif err := validateShutdownScript(\n\t\t\tc.cfg.Disconnect,\n\t\t\tc.cfg.Channel.RemoteUpfrontShutdownScript(), shutdownMsg.Address,\n\t\t\tc.cfg.ChainParams,\n\t\t); err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\n\t\t// Now that we know this is a valid shutdown message and address, we'll\n\t\t// record their preferred delivery closing script.\n\t\tc.remoteDeliveryScript = shutdownMsg.Address\n\n\t\t// At this point, we can now start the fee negotiation state, by\n\t\t// constructing and sending our initial signature for what we think the\n\t\t// closing transaction should look like.\n\t\tc.state = closeFeeNegotiation\n\n\t\t// Now that we know their desried delivery script, we can\n\t\t// compute what our max/ideal fee will be.\n\t\tc.initFeeBaseline()\n\n\t\tchancloserLog.Infof(\"ChannelPoint(%v): shutdown response received, \"+\n\t\t\t\"entering fee negotiation\", c.chanPoint)\n\n\t\t// Starting with our ideal fee rate, we'll create an initial closing\n\t\t// proposal, but only if we're the initiator, as otherwise, the other\n\t\t// party will send their initial proposal first.\n\t\tif c.cfg.Channel.IsInitiator() {\n\t\t\tcloseSigned, err := c.proposeCloseSigned(c.idealFeeSat)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, false, err\n\t\t\t}\n\n\t\t\treturn []lnwire.Message{closeSigned}, false, nil\n\t\t}\n\n\t\treturn nil, false, nil\n\n\t// If we're receiving a message while we're in the fee negotiation phase,\n\t// then this indicates the remote party is responding to a close signed\n\t// message we sent, or kicking off the process with their own.\n\tcase closeFeeNegotiation:\n\t\t// First, we'll assert that we're actually getting a ClosingSigned\n\t\t// message, otherwise an invalid state transition was attempted.\n\t\tcloseSignedMsg, ok := msg.(*lnwire.ClosingSigned)\n\t\tif !ok {\n\t\t\treturn nil, false, fmt.Errorf(\"expected lnwire.ClosingSigned, \"+\n\t\t\t\t\"instead have %v\", spew.Sdump(msg))\n\t\t}\n\n\t\t// We'll compare the proposed total fee, to what we've proposed during\n\t\t// the negotiations. If it doesn't match any of our prior offers, then\n\t\t// we'll attempt to ratchet the fee closer to\n\t\tremoteProposedFee := closeSignedMsg.FeeSatoshis\n\t\tif _, ok := c.priorFeeOffers[remoteProposedFee]; !ok {\n\t\t\t// We'll now attempt to ratchet towards a fee deemed acceptable by\n\t\t\t// both parties, factoring in our ideal fee rate, and the last\n\t\t\t// proposed fee by both sides.\n\t\t\tfeeProposal := calcCompromiseFee(c.chanPoint, c.idealFeeSat,\n\t\t\t\tc.lastFeeProposal, remoteProposedFee,\n\t\t\t)\n\t\t\tif c.cfg.Channel.IsInitiator() && feeProposal > c.maxFee {\n\t\t\t\treturn nil, false, fmt.Errorf(\"%w: %v > %v\",\n\t\t\t\t\tErrProposalExeceedsMaxFee, feeProposal,\n\t\t\t\t\tc.maxFee)\n\t\t\t}\n\n\t\t\t// With our new fee proposal calculated, we'll craft a new close\n\t\t\t// signed signature to send to the other party so we can continue\n\t\t\t// the fee negotiation process.\n\t\t\tcloseSigned, err := c.proposeCloseSigned(feeProposal)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, false, err\n\t\t\t}\n\n\t\t\t// If the compromise fee doesn't match what the peer proposed, then\n\t\t\t// we'll return this latest close signed message so we can continue\n\t\t\t// negotiation.\n\t\t\tif feeProposal != remoteProposedFee {\n\t\t\t\tchancloserLog.Debugf(\"ChannelPoint(%v): close tx fee \"+\n\t\t\t\t\t\"disagreement, continuing negotiation\", c.chanPoint)\n\t\t\t\treturn []lnwire.Message{closeSigned}, false, nil\n\t\t\t}\n\t\t}\n\n\t\tchancloserLog.Infof(\"ChannelPoint(%v) fee of %v accepted, ending \"+\n\t\t\t\"negotiation\", c.chanPoint, remoteProposedFee)\n\n\t\t// Otherwise, we've agreed on a fee for the closing transaction! We'll\n\t\t// craft the final closing transaction so we can broadcast it to the\n\t\t// network.\n\t\tmatchingSig := c.priorFeeOffers[remoteProposedFee].Signature\n\t\tlocalSig, err := matchingSig.ToSignature()\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\n\t\tremoteSig, err := closeSignedMsg.Signature.ToSignature()\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\n\t\tcloseTx, _, err := c.cfg.Channel.CompleteCooperativeClose(\n\t\t\tlocalSig, remoteSig, c.localDeliveryScript, c.remoteDeliveryScript,\n\t\t\tremoteProposedFee,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\t\tc.closingTx = closeTx\n\n\t\t// Before publishing the closing tx, we persist it to the database,\n\t\t// such that it can be republished if something goes wrong.\n\t\terr = c.cfg.Channel.MarkCoopBroadcasted(closeTx, c.locallyInitiated)\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\n\t\t// With the closing transaction crafted, we'll now broadcast it to the\n\t\t// network.\n\t\tchancloserLog.Infof(\"Broadcasting cooperative close tx: %v\",\n\t\t\tnewLogClosure(func() string {\n\t\t\t\treturn spew.Sdump(closeTx)\n\t\t\t}),\n\t\t)\n\n\t\t// Create a close channel label.\n\t\tchanID := c.cfg.Channel.ShortChanID()\n\t\tcloseLabel := labels.MakeLabel(\n\t\t\tlabels.LabelTypeChannelClose, &chanID,\n\t\t)\n\n\t\tif err := c.cfg.BroadcastTx(closeTx, closeLabel); err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\n\t\t// Finally, we'll transition to the closeFinished state, and also\n\t\t// return the final close signed message we sent. Additionally, we\n\t\t// return true for the second argument to indicate we're finished with\n\t\t// the channel closing negotiation.\n\t\tc.state = closeFinished\n\t\tmatchingOffer := c.priorFeeOffers[remoteProposedFee]\n\t\treturn []lnwire.Message{matchingOffer}, true, nil\n\n\t// If we received a message while in the closeFinished state, then this\n\t// should only be the remote party echoing the last ClosingSigned message\n\t// that we agreed on.\n\tcase closeFinished:\n\t\tif _, ok := msg.(*lnwire.ClosingSigned); !ok {\n\t\t\treturn nil, false, fmt.Errorf(\"expected lnwire.ClosingSigned, \"+\n\t\t\t\t\"instead have %v\", spew.Sdump(msg))\n\t\t}\n\n\t\t// There's no more to do as both sides should have already broadcast\n\t\t// the closing transaction at this state.\n\t\treturn nil, true, nil\n\n\t// Otherwise, we're in an unknown state, and can't proceed.\n\tdefault:\n\t\treturn nil, false, ErrInvalidState\n\t}\n}\n\n// proposeCloseSigned attempts to propose a new signature for the closing\n// transaction for a channel based on the prior fee negotiations and our current\n// compromise fee.",
      "length": 9324,
      "tokens": 1301,
      "embedding": []
    },
    {
      "slug": "func (c *ChanCloser) proposeCloseSigned(fee btcutil.Amount) (*lnwire.ClosingSigned, error) {",
      "content": "func (c *ChanCloser) proposeCloseSigned(fee btcutil.Amount) (*lnwire.ClosingSigned, error) {\n\trawSig, _, _, err := c.cfg.Channel.CreateCloseProposal(\n\t\tfee, c.localDeliveryScript, c.remoteDeliveryScript,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// We'll note our last signature and proposed fee so when the remote party\n\t// responds we'll be able to decide if we've agreed on fees or not.\n\tc.lastFeeProposal = fee\n\tparsedSig, err := lnwire.NewSigFromSignature(rawSig)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tchancloserLog.Infof(\"ChannelPoint(%v): proposing fee of %v sat to close \"+\n\t\t\"chan\", c.chanPoint, int64(fee))\n\n\t// We'll assemble a ClosingSigned message using this information and return\n\t// it to the caller so we can kick off the final stage of the channel\n\t// closure process.\n\tcloseSignedMsg := lnwire.NewClosingSigned(c.cid, fee, parsedSig)\n\n\t// We'll also save this close signed, in the case that the remote party\n\t// accepts our offer. This way, we don't have to re-sign.\n\tc.priorFeeOffers[fee] = closeSignedMsg\n\n\treturn closeSignedMsg, nil\n}\n\n// feeInAcceptableRange returns true if the passed remote fee is deemed to be\n// in an \"acceptable\" range to our local fee. This is an attempt at a\n// compromise and to ensure that the fee negotiation has a stopping point. We\n// consider their fee acceptable if it's within 30% of our fee.",
      "length": 1224,
      "tokens": 196,
      "embedding": []
    },
    {
      "slug": "func feeInAcceptableRange(localFee, remoteFee btcutil.Amount) bool {",
      "content": "func feeInAcceptableRange(localFee, remoteFee btcutil.Amount) bool {\n\t// If our offer is lower than theirs, then we'll accept their offer if it's\n\t// no more than 30% *greater* than our current offer.\n\tif localFee < remoteFee {\n\t\tacceptableRange := localFee + ((localFee * 3) / 10)\n\t\treturn remoteFee <= acceptableRange\n\t}\n\n\t// If our offer is greater than theirs, then we'll accept their offer if\n\t// it's no more than 30% *less* than our current offer.\n\tacceptableRange := localFee - ((localFee * 3) / 10)\n\treturn remoteFee >= acceptableRange\n}\n\n// ratchetFee is our step function used to inch our fee closer to something\n// that both sides can agree on. If up is true, then we'll attempt to increase\n// our offered fee. Otherwise, if up is false, then we'll attempt to decrease\n// our offered fee.",
      "length": 715,
      "tokens": 131,
      "embedding": []
    },
    {
      "slug": "func ratchetFee(fee btcutil.Amount, up bool) btcutil.Amount {",
      "content": "func ratchetFee(fee btcutil.Amount, up bool) btcutil.Amount {\n\t// If we need to ratchet up, then we'll increase our fee by 10%.\n\tif up {\n\t\treturn fee + ((fee * 1) / 10)\n\t}\n\n\t// Otherwise, we'll *decrease* our fee by 10%.\n\treturn fee - ((fee * 1) / 10)\n}\n\n// calcCompromiseFee performs the current fee negotiation algorithm, taking\n// into consideration our ideal fee based on current fee environment, the fee\n// we last proposed (if any), and the fee proposed by the peer.",
      "length": 399,
      "tokens": 78,
      "embedding": []
    },
    {
      "slug": "func calcCompromiseFee(chanPoint wire.OutPoint, ourIdealFee, lastSentFee,",
      "content": "func calcCompromiseFee(chanPoint wire.OutPoint, ourIdealFee, lastSentFee,\n\tremoteFee btcutil.Amount) btcutil.Amount {\n\n\t// TODO(roasbeef): take in number of rounds as well?\n\n\tchancloserLog.Infof(\"ChannelPoint(%v): computing fee compromise, ideal=\"+\n\t\t\"%v, last_sent=%v, remote_offer=%v\", chanPoint, int64(ourIdealFee),\n\t\tint64(lastSentFee), int64(remoteFee))\n\n\t// Otherwise, we'll need to attempt to make a fee compromise if this is the\n\t// second round, and neither side has agreed on fees.\n\tswitch {\n\t// If their proposed fee is identical to our ideal fee, then we'll go with\n\t// that as we can short circuit the fee negotiation. Similarly, if we\n\t// haven't sent an offer yet, we'll default to our ideal fee.\n\tcase ourIdealFee == remoteFee || lastSentFee == 0:\n\t\treturn ourIdealFee\n\n\t// If the last fee we sent, is equal to the fee the remote party is\n\t// offering, then we can simply return this fee as the negotiation is over.\n\tcase remoteFee == lastSentFee:\n\t\treturn lastSentFee\n\n\t// If the fee the remote party is offering is less than the last one we\n\t// sent, then we'll need to ratchet down in order to move our offer closer\n\t// to theirs.\n\tcase remoteFee < lastSentFee:\n\t\t// If the fee is lower, but still acceptable, then we'll just return\n\t\t// this fee and end the negotiation.\n\t\tif feeInAcceptableRange(lastSentFee, remoteFee) {\n\t\t\tchancloserLog.Infof(\"ChannelPoint(%v): proposed remote fee is \"+\n\t\t\t\t\"close enough, capitulating\", chanPoint)\n\t\t\treturn remoteFee\n\t\t}\n\n\t\t// Otherwise, we'll ratchet the fee *down* using our current algorithm.\n\t\treturn ratchetFee(lastSentFee, false)\n\n\t// If the fee the remote party is offering is greater than the last one we\n\t// sent, then we'll ratchet up in order to ensure we terminate eventually.\n\tcase remoteFee > lastSentFee:\n\t\t// If the fee is greater, but still acceptable, then we'll just return\n\t\t// this fee in order to put an end to the negotiation.\n\t\tif feeInAcceptableRange(lastSentFee, remoteFee) {\n\t\t\tchancloserLog.Infof(\"ChannelPoint(%v): proposed remote fee is \"+\n\t\t\t\t\"close enough, capitulating\", chanPoint)\n\t\t\treturn remoteFee\n\t\t}\n\n\t\t// Otherwise, we'll ratchet the fee up using our current algorithm.\n\t\treturn ratchetFee(lastSentFee, true)\n\n\tdefault:\n\t\t// TODO(roasbeef): fail if their fee isn't in expected range\n\t\treturn remoteFee\n\t}\n}\n\n// ParseUpfrontShutdownAddress attempts to parse an upfront shutdown address.\n// If the address is empty, it returns nil. If it successfully decoded the\n// address, it returns a script that pays out to the address.",
      "length": 2388,
      "tokens": 366,
      "embedding": []
    },
    {
      "slug": "func ParseUpfrontShutdownAddress(address string,",
      "content": "func ParseUpfrontShutdownAddress(address string,\n\tparams *chaincfg.Params) (lnwire.DeliveryAddress, error) {\n\n\tif len(address) == 0 {\n\t\treturn nil, nil\n\t}\n\n\taddr, err := btcutil.DecodeAddress(\n\t\taddress, params,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"invalid address: %v\", err)\n\t}\n\n\tif !addr.IsForNet(params) {\n\t\treturn nil, fmt.Errorf(\"invalid address: %v is not a %s \"+\n\t\t\t\"address\", addr, params.Name)\n\t}\n\n\treturn txscript.PayToAddrScript(addr)\n}\n",
      "length": 388,
      "tokens": 53,
      "embedding": []
    }
  ]
}