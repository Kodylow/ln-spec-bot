{
  "filepath": "../implementations/go/lnd/lnwallet/chancloser/chancloser_test.go",
  "package": "chancloser",
  "sections": [
    {
      "slug": "func TestMaybeMatchScript(t *testing.T) {",
      "content": "func TestMaybeMatchScript(t *testing.T) {\n\tt.Parallel()\n\n\tpubHash := bytes.Repeat([]byte{0x0}, 20)\n\tscriptHash := bytes.Repeat([]byte{0x0}, 32)\n\n\tp2wkh, err := txscript.NewScriptBuilder().AddOp(txscript.OP_0).\n\t\tAddData(pubHash).Script()\n\trequire.NoError(t, err)\n\n\tp2wsh, err := txscript.NewScriptBuilder().AddOp(txscript.OP_0).\n\t\tAddData(scriptHash).Script()\n\trequire.NoError(t, err)\n\n\tp2tr, err := txscript.NewScriptBuilder().AddOp(txscript.OP_1).\n\t\tAddData(scriptHash).Script()\n\trequire.NoError(t, err)\n\n\tp2OtherV1, err := txscript.NewScriptBuilder().AddOp(txscript.OP_1).\n\t\tAddData(pubHash).Script()\n\trequire.NoError(t, err)\n\n\tinvalidFork, err := txscript.NewScriptBuilder().AddOp(txscript.OP_NOP).\n\t\tAddData(scriptHash).Script()\n\trequire.NoError(t, err)\n\n\ttype testCase struct {\n\t\tname           string\n\t\tshutdownScript lnwire.DeliveryAddress\n\t\tupfrontScript  lnwire.DeliveryAddress\n\t\texpectedErr    error\n\t}\n\ttests := []testCase{\n\t\t{\n\t\t\tname:           \"no upfront shutdown set, script ok\",\n\t\t\tshutdownScript: p2wkh,\n\t\t\tupfrontScript:  []byte{},\n\t\t\texpectedErr:    nil,\n\t\t},\n\t\t{\n\t\t\tname:           \"upfront shutdown set, script ok\",\n\t\t\tshutdownScript: p2wkh,\n\t\t\tupfrontScript:  p2wkh,\n\t\t\texpectedErr:    nil,\n\t\t},\n\t\t{\n\t\t\tname:           \"upfront shutdown set, script not ok\",\n\t\t\tshutdownScript: p2wkh,\n\t\t\tupfrontScript:  p2wsh,\n\t\t\texpectedErr:    ErrUpfrontShutdownScriptMismatch,\n\t\t},\n\t\t{\n\t\t\tname:           \"nil shutdown and empty upfront\",\n\t\t\tshutdownScript: nil,\n\t\t\tupfrontScript:  []byte{},\n\t\t\texpectedErr:    nil,\n\t\t},\n\t\t{\n\t\t\tname:           \"p2tr is ok\",\n\t\t\tshutdownScript: p2tr,\n\t\t},\n\t\t{\n\t\t\tname:           \"segwit v1 is ok\",\n\t\t\tshutdownScript: p2OtherV1,\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid script not allowed\",\n\t\t\tshutdownScript: invalidFork,\n\t\t\texpectedErr:    ErrInvalidShutdownScript,\n\t\t},\n\t}\n\n\t// All future segwit softforks should also be ok.\n\tfutureForks := []byte{\n\t\ttxscript.OP_1, txscript.OP_2, txscript.OP_3, txscript.OP_4,\n\t\ttxscript.OP_5, txscript.OP_6, txscript.OP_7, txscript.OP_8,\n\t\ttxscript.OP_9, txscript.OP_10, txscript.OP_11, txscript.OP_12,\n\t\ttxscript.OP_13, txscript.OP_14, txscript.OP_15, txscript.OP_16,\n\t}\n\tfor _, witnessVersion := range futureForks {\n\t\tp2FutureFork, err := txscript.NewScriptBuilder().AddOp(witnessVersion).\n\t\t\tAddData(scriptHash).Script()\n\t\trequire.NoError(t, err)\n\n\t\topString, err := txscript.DisasmString([]byte{witnessVersion})\n\t\trequire.NoError(t, err)\n\n\t\ttests = append(tests, testCase{\n\t\t\tname:           fmt.Sprintf(\"witness_version=%v\", opString),\n\t\t\tshutdownScript: p2FutureFork,\n\t\t})\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\terr := validateShutdownScript(\n\t\t\t\tfunc() error { return nil }, test.upfrontScript,\n\t\t\t\ttest.shutdownScript, &chaincfg.SimNetParams,\n\t\t\t)\n\n\t\t\tif err != test.expectedErr {\n\t\t\t\tt.Fatalf(\"Error: %v, expected error: %v\", err, test.expectedErr)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "length": 2768,
      "tokens": 251,
      "embedding": []
    },
    {
      "slug": "type mockChannel struct {",
      "content": "type mockChannel struct {\n\tchanPoint wire.OutPoint\n\tinitiator bool\n\tscid      lnwire.ShortChannelID\n}\n",
      "length": 72,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "func (m *mockChannel) ChannelPoint() *wire.OutPoint {",
      "content": "func (m *mockChannel) ChannelPoint() *wire.OutPoint {\n\treturn &m.chanPoint\n}\n",
      "length": 21,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (m *mockChannel) MarkCoopBroadcasted(*wire.MsgTx, bool) error {",
      "content": "func (m *mockChannel) MarkCoopBroadcasted(*wire.MsgTx, bool) error {\n\treturn nil\n}\n",
      "length": 12,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (m *mockChannel) IsInitiator() bool {",
      "content": "func (m *mockChannel) IsInitiator() bool {\n\treturn m.initiator\n}\n",
      "length": 20,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (m *mockChannel) ShortChanID() lnwire.ShortChannelID {",
      "content": "func (m *mockChannel) ShortChanID() lnwire.ShortChannelID {\n\treturn m.scid\n}\n",
      "length": 15,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (m *mockChannel) AbsoluteThawHeight() (uint32, error) {",
      "content": "func (m *mockChannel) AbsoluteThawHeight() (uint32, error) {\n\treturn 0, nil\n}\n",
      "length": 15,
      "tokens": 4,
      "embedding": []
    },
    {
      "slug": "func (m *mockChannel) RemoteUpfrontShutdownScript() lnwire.DeliveryAddress {",
      "content": "func (m *mockChannel) RemoteUpfrontShutdownScript() lnwire.DeliveryAddress {\n\treturn lnwire.DeliveryAddress{}\n}\n",
      "length": 33,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (m *mockChannel) CreateCloseProposal(fee btcutil.Amount,",
      "content": "func (m *mockChannel) CreateCloseProposal(fee btcutil.Amount,\n\tlocalScript, remoteScript []byte,\n) (input.Signature, *chainhash.Hash, btcutil.Amount, error) {\n\n\treturn nil, nil, 0, nil\n}\n",
      "length": 120,
      "tokens": 15,
      "embedding": []
    },
    {
      "slug": "func (m *mockChannel) CompleteCooperativeClose(localSig,",
      "content": "func (m *mockChannel) CompleteCooperativeClose(localSig,\n\tremoteSig input.Signature, localScript, remoteScript []byte,\n\tproposedFee btcutil.Amount) (*wire.MsgTx, btcutil.Amount, error) {\n\n\treturn nil, 0, nil\n}\n",
      "length": 148,
      "tokens": 16,
      "embedding": []
    },
    {
      "slug": "func (m *mockChannel) LocalBalanceDust() bool {",
      "content": "func (m *mockChannel) LocalBalanceDust() bool {\n\treturn false\n}\n",
      "length": 14,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (m *mockChannel) RemoteBalanceDust() bool {",
      "content": "func (m *mockChannel) RemoteBalanceDust() bool {\n\treturn false\n}\n",
      "length": 14,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "type mockCoopFeeEstimator struct {",
      "content": "type mockCoopFeeEstimator struct {\n\ttargetFee btcutil.Amount\n}\n",
      "length": 26,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (m *mockCoopFeeEstimator) EstimateFee(chanType channeldb.ChannelType,",
      "content": "func (m *mockCoopFeeEstimator) EstimateFee(chanType channeldb.ChannelType,\n\tlocalTxOut, remoteTxOut *wire.TxOut,\n\tidealFeeRate chainfee.SatPerKWeight) btcutil.Amount {\n\n\treturn m.targetFee\n}\n\n// TestMaxFeeClamp tests that if a max fee is specified, then it's used instead\n// of the default max fee multiplier.",
      "length": 227,
      "tokens": 31,
      "embedding": []
    },
    {
      "slug": "func TestMaxFeeClamp(t *testing.T) {",
      "content": "func TestMaxFeeClamp(t *testing.T) {\n\tt.Parallel()\n\n\tconst (\n\t\tabsoluteFeeOneSatByte = 126\n\t\tabsoluteFeeTenSatByte = 1265\n\t)\n\n\ttests := []struct {\n\t\tname string\n\n\t\tidealFee    chainfee.SatPerKWeight\n\t\tinputMaxFee chainfee.SatPerKWeight\n\n\t\tmaxFee btcutil.Amount\n\t}{\n\t\t{\n\t\t\t// No max fee specified, we should see 3x the ideal fee.\n\t\t\tname: \"no max fee\",\n\n\t\t\tidealFee: chainfee.SatPerKWeight(253),\n\t\t\tmaxFee:   absoluteFeeOneSatByte * defaultMaxFeeMultiplier,\n\t\t},\n\t\t{\n\t\t\t// Max fee specified, this should be used in place.\n\t\t\tname: \"max fee clamp\",\n\n\t\t\tidealFee:    chainfee.SatPerKWeight(253),\n\t\t\tinputMaxFee: chainfee.SatPerKWeight(2530),\n\n\t\t\t// We should get the resulting absolute fee based on a\n\t\t\t// factor of 10 sat/byte (our new max fee).\n\t\t\tmaxFee: absoluteFeeTenSatByte,\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\ttest := test\n\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tchannel := mockChannel{}\n\n\t\t\tchanCloser := NewChanCloser(\n\t\t\t\tChanCloseCfg{\n\t\t\t\t\tChannel:      &channel,\n\t\t\t\t\tMaxFee:       test.inputMaxFee,\n\t\t\t\t\tFeeEstimator: &SimpleCoopFeeEstimator{},\n\t\t\t\t}, nil, test.idealFee, 0, nil, false,\n\t\t\t)\n\n\t\t\t// We'll call initFeeBaseline early here since we need\n\t\t\t// the populate these internal variables.\n\t\t\tchanCloser.initFeeBaseline()\n\n\t\t\trequire.Equal(t, test.maxFee, chanCloser.maxFee)\n\t\t})\n\t}\n}\n\n// TestMaxFeeBailOut tests that once the negotiated fee rate rises above our\n// maximum fee, we'll return an error and refuse to process a co-op close\n// message.",
      "length": 1392,
      "tokens": 175,
      "embedding": []
    },
    {
      "slug": "func TestMaxFeeBailOut(t *testing.T) {",
      "content": "func TestMaxFeeBailOut(t *testing.T) {\n\tt.Parallel()\n\n\tconst (\n\t\tabsoluteFee = btcutil.Amount(1000)\n\t\tidealFee    = chainfee.SatPerKWeight(253)\n\t)\n\n\tfor _, isInitiator := range []bool{true, false} {\n\t\tisInitiator := isInitiator\n\n\t\tt.Run(fmt.Sprintf(\"initiator=%v\", isInitiator), func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\t// First, we'll make our mock channel, and use that to\n\t\t\t// instantiate our channel closer.\n\t\t\tcloseCfg := ChanCloseCfg{\n\t\t\t\tChannel: &mockChannel{\n\t\t\t\t\tinitiator: isInitiator,\n\t\t\t\t},\n\t\t\t\tFeeEstimator: &mockCoopFeeEstimator{\n\t\t\t\t\ttargetFee: absoluteFee,\n\t\t\t\t},\n\t\t\t\tMaxFee: idealFee * 2,\n\t\t\t}\n\t\t\tchanCloser := NewChanCloser(\n\t\t\t\tcloseCfg, nil, idealFee, 0, nil, false,\n\t\t\t)\n\n\t\t\t// We'll now force the channel state into the\n\t\t\t// closeFeeNegotiation state so we can skip straight to\n\t\t\t// the juicy part. We'll also set our last fee sent so\n\t\t\t// we'll attempt to actually \"negotiate\" here.\n\t\t\tchanCloser.state = closeFeeNegotiation\n\t\t\tchanCloser.lastFeeProposal = absoluteFee\n\n\t\t\t// Next, we'll make a ClosingSigned message that\n\t\t\t// proposes a fee that's above the specified max fee.\n\t\t\t//\n\t\t\t// NOTE: We use the absoluteFee here since our mock\n\t\t\t// always returns this fee for the CalcFee method which\n\t\t\t// is used to translate a fee rate\n\t\t\t// into an absolute fee amount in sats.\n\t\t\tcloseMsg := &lnwire.ClosingSigned{\n\t\t\t\tFeeSatoshis: absoluteFee * 2,\n\t\t\t}\n\n\t\t\t_, _, err := chanCloser.ProcessCloseMsg(closeMsg)\n\n\t\t\tswitch isInitiator {\n\t\t\t// If we're the initiator, then we expect an error at\n\t\t\t// this point.\n\t\t\tcase true:\n\t\t\t\trequire.ErrorIs(t, err, ErrProposalExeceedsMaxFee)\n\n\t\t\t// Otherwise, we expect things to fail for some other\n\t\t\t// reason (invalid sig, etc).\n\t\t\tcase false:\n\t\t\t\trequire.NotErrorIs(t, err, ErrProposalExeceedsMaxFee)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestParseUpfrontShutdownAddress tests the we are able to parse the upfront\n// shutdown address properly.",
      "length": 1792,
      "tokens": 243,
      "embedding": []
    },
    {
      "slug": "func TestParseUpfrontShutdownAddress(t *testing.T) {",
      "content": "func TestParseUpfrontShutdownAddress(t *testing.T) {\n\tt.Parallel()\n\n\tvar (\n\t\ttestnetAddress = \"tb1qdfkmwwgdaa5dnezrlhtftvmj5qn2kwgp7n0z6r\"\n\t\tregtestAddress = \"bcrt1q09crvvuj95x5nk64wsxf5n6ky0kr8358vpx4d8\"\n\t)\n\n\ttests := []struct {\n\t\tname        string\n\t\taddress     string\n\t\tparams      chaincfg.Params\n\t\texpectedErr string\n\t}{\n\t\t{\n\t\t\tname:        \"invalid closing address\",\n\t\t\taddress:     \"non-valid-address\",\n\t\t\tparams:      chaincfg.RegressionNetParams,\n\t\t\texpectedErr: \"invalid address\",\n\t\t},\n\t\t{\n\t\t\tname:        \"closing address from another net\",\n\t\t\taddress:     testnetAddress,\n\t\t\tparams:      chaincfg.RegressionNetParams,\n\t\t\texpectedErr: \"not a regtest address\",\n\t\t},\n\t\t{\n\t\t\tname:    \"valid p2wkh closing address\",\n\t\t\taddress: regtestAddress,\n\t\t\tparams:  chaincfg.RegressionNetParams,\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\ttc := tc\n\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\t_, err := ParseUpfrontShutdownAddress(\n\t\t\t\ttc.address, &tc.params,\n\t\t\t)\n\n\t\t\tif tc.expectedErr != \"\" {\n\t\t\t\trequire.ErrorContains(t, err, tc.expectedErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\trequire.NoError(t, err)\n\t\t})\n\t}\n}\n",
      "length": 1003,
      "tokens": 102,
      "embedding": []
    }
  ]
}