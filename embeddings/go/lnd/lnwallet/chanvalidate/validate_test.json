{
  "filepath": "../implementations/go/lnd/lnwallet/chanvalidate/validate_test.go",
  "package": "chanvalidate",
  "sections": [
    {
      "slug": "type channelTestCtx struct {",
      "content": "type channelTestCtx struct {\n\tfundingTx *wire.MsgTx\n\n\tinvalidCommitTx, validCommitTx *wire.MsgTx\n\n\tchanPoint wire.OutPoint\n\tcid       lnwire.ShortChannelID\n\n\tfundingScript []byte\n}\n\n// newChannelTestCtx creates a new channelCtx for use in the validation tests\n// below. This creates a fake funding transaction, as well as an invalid and\n// valid commitment transaction.",
      "length": 328,
      "tokens": 42,
      "embedding": []
    },
    {
      "slug": "func newChannelTestCtx(chanSize int64) (*channelTestCtx, error) {",
      "content": "func newChannelTestCtx(chanSize int64) (*channelTestCtx, error) {\n\tmultiSigScript, err := input.GenMultiSigScript(\n\t\talicePub.SerializeCompressed(), bobPub.SerializeCompressed(),\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpkScript, err := input.WitnessScriptHash(multiSigScript)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfundingOutput := wire.TxOut{\n\t\tValue:    chanSize,\n\t\tPkScript: pkScript,\n\t}\n\n\tfundingTx := &wire.MsgTx{\n\t\tTxIn: []*wire.TxIn{\n\t\t\t{},\n\t\t},\n\t\tTxOut: []*wire.TxOut{\n\t\t\t&fundingOutput,\n\t\t\t{\n\t\t\t\tValue:    9999,\n\t\t\t\tPkScript: bytes.Repeat([]byte{'a'}, 32),\n\t\t\t},\n\t\t\t{\n\t\t\t\tValue:    99999,\n\t\t\t\tPkScript: bytes.Repeat([]byte{'b'}, 32),\n\t\t\t},\n\t\t},\n\t}\n\n\tfundingTxHash := fundingTx.TxHash()\n\n\tcommitTx := &wire.MsgTx{\n\t\tTxIn: []*wire.TxIn{\n\t\t\t{\n\t\t\t\tPreviousOutPoint: wire.OutPoint{\n\t\t\t\t\tHash:  fundingTxHash,\n\t\t\t\t\tIndex: 0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTxOut: []*wire.TxOut{\n\t\t\t&fundingOutput,\n\t\t},\n\t}\n\n\tsigHashes := input.NewTxSigHashesV0Only(commitTx)\n\taliceSigRaw, err := txscript.RawTxInWitnessSignature(\n\t\tcommitTx, sigHashes, 0, chanSize,\n\t\tmultiSigScript, txscript.SigHashAll, alicePriv,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\taliceSig, err := ecdsa.ParseDERSignature(aliceSigRaw)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbobSigRaw, err := txscript.RawTxInWitnessSignature(\n\t\tcommitTx, sigHashes, 0, chanSize,\n\t\tmultiSigScript, txscript.SigHashAll, bobPriv,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbobSig, err := ecdsa.ParseDERSignature(bobSigRaw)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcommitTx.TxIn[0].Witness = input.SpendMultiSig(\n\t\tmultiSigScript, alicePub.SerializeCompressed(), aliceSig,\n\t\tbobPub.SerializeCompressed(), bobSig,\n\t)\n\n\tinvalidCommitTx := commitTx.Copy()\n\tinvalidCommitTx.TxIn[0].PreviousOutPoint.Index = 2\n\n\treturn &channelTestCtx{\n\t\tfundingTx:       fundingTx,\n\t\tvalidCommitTx:   commitTx,\n\t\tinvalidCommitTx: invalidCommitTx,\n\t\tchanPoint: wire.OutPoint{\n\t\t\tHash:  fundingTxHash,\n\t\t\tIndex: 0,\n\t\t},\n\t\tcid: lnwire.ShortChannelID{\n\t\t\tTxPosition: 0,\n\t\t},\n\t\tfundingScript: pkScript,\n\t}, nil\n}\n\n// TestValidate ensures that the Validate method is able to detect all cases of\n// invalid channels, and properly accept invalid channels.",
      "length": 1994,
      "tokens": 219,
      "embedding": []
    },
    {
      "slug": "func TestValidate(t *testing.T) {",
      "content": "func TestValidate(t *testing.T) {\n\tt.Parallel()\n\n\tchanSize := int64(1000000)\n\tchannelCtx, err := newChannelTestCtx(chanSize)\n\trequire.NoError(t, err, \"unable to make channel context\")\n\n\ttestCases := []struct {\n\t\t// expectedErr is the error we expect, this should be nil if\n\t\t// the channel is valid.\n\t\texpectedErr error\n\n\t\t// locator is how the Validate method should find the target\n\t\t// outpoint.\n\t\tlocator ChanLocator\n\n\t\t// chanPoint is the expected final out point.\n\t\tchanPoint wire.OutPoint\n\n\t\t// chanScript is the funding pkScript.\n\t\tchanScript []byte\n\n\t\t// fundingTx is the funding transaction to use in the test.\n\t\tfundingTx *wire.MsgTx\n\n\t\t// commitTx is the commitment transaction to use in the test,\n\t\t// this is optional.\n\t\tcommitTx *wire.MsgTx\n\n\t\t// expectedValue is the value of the funding transaction we\n\t\t// should expect. This is only required if commitTx is non-nil.\n\t\texpectedValue int64\n\t}{\n\t\t// Short chan ID channel locator, unable to find target\n\t\t// outpoint.\n\t\t{\n\t\t\texpectedErr: ErrInvalidOutPoint,\n\t\t\tlocator: &ShortChanIDChanLocator{\n\t\t\t\tID: lnwire.NewShortChanIDFromInt(9),\n\t\t\t},\n\t\t\tfundingTx: &wire.MsgTx{},\n\t\t},\n\n\t\t// Chan point based channel locator, unable to find target\n\t\t// outpoint.\n\t\t{\n\t\t\texpectedErr: ErrInvalidOutPoint,\n\t\t\tlocator: &OutPointChanLocator{\n\t\t\t\tChanPoint: wire.OutPoint{\n\t\t\t\t\tIndex: 99,\n\t\t\t\t},\n\t\t\t},\n\t\t\tfundingTx: &wire.MsgTx{},\n\t\t},\n\n\t\t// Invalid pkScript match on mined funding transaction, chan\n\t\t// point based locator.\n\t\t{\n\t\t\texpectedErr: ErrWrongPkScript,\n\t\t\tlocator: &OutPointChanLocator{\n\t\t\t\tChanPoint: channelCtx.chanPoint,\n\t\t\t},\n\t\t\tchanScript: bytes.Repeat([]byte(\"a\"), 32),\n\t\t\tfundingTx:  channelCtx.fundingTx,\n\t\t},\n\n\t\t// Invalid pkScript match on mined funding transaction, short\n\t\t// chan ID based locator.\n\t\t{\n\t\t\texpectedErr: ErrWrongPkScript,\n\t\t\tlocator: &ShortChanIDChanLocator{\n\t\t\t\tID: channelCtx.cid,\n\t\t\t},\n\t\t\tchanScript: bytes.Repeat([]byte(\"a\"), 32),\n\t\t\tfundingTx:  channelCtx.fundingTx,\n\t\t},\n\n\t\t// Invalid amount on funding transaction.\n\t\t{\n\t\t\texpectedErr: ErrInvalidSize,\n\t\t\tlocator: &OutPointChanLocator{\n\t\t\t\tChanPoint: channelCtx.chanPoint,\n\t\t\t},\n\t\t\tchanScript:    channelCtx.fundingScript,\n\t\t\tfundingTx:     channelCtx.fundingTx,\n\t\t\texpectedValue: 555,\n\t\t\tcommitTx:      channelCtx.validCommitTx,\n\t\t},\n\n\t\t// Validation failure on final commitment transaction\n\t\t{\n\t\t\texpectedErr: &ErrScriptValidateError{},\n\t\t\tlocator: &OutPointChanLocator{\n\t\t\t\tChanPoint: channelCtx.chanPoint,\n\t\t\t},\n\t\t\tchanScript:    channelCtx.fundingScript,\n\t\t\tfundingTx:     channelCtx.fundingTx,\n\t\t\texpectedValue: chanSize,\n\t\t\tcommitTx:      channelCtx.invalidCommitTx,\n\t\t},\n\n\t\t// Fully valid 3rd party verification.\n\t\t{\n\t\t\texpectedErr: nil,\n\t\t\tlocator: &OutPointChanLocator{\n\t\t\t\tChanPoint: channelCtx.chanPoint,\n\t\t\t},\n\t\t\tchanScript: channelCtx.fundingScript,\n\t\t\tfundingTx:  channelCtx.fundingTx,\n\t\t\tchanPoint:  channelCtx.chanPoint,\n\t\t},\n\n\t\t// Fully valid self-channel verification.\n\t\t{\n\t\t\texpectedErr: nil,\n\t\t\tlocator: &OutPointChanLocator{\n\t\t\t\tChanPoint: channelCtx.chanPoint,\n\t\t\t},\n\t\t\tchanScript:    channelCtx.fundingScript,\n\t\t\tfundingTx:     channelCtx.fundingTx,\n\t\t\texpectedValue: chanSize,\n\t\t\tcommitTx:      channelCtx.validCommitTx,\n\t\t\tchanPoint:     channelCtx.chanPoint,\n\t\t},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tctx := &Context{\n\t\t\tLocator:          testCase.locator,\n\t\t\tMultiSigPkScript: testCase.chanScript,\n\t\t\tFundingTx:        testCase.fundingTx,\n\t\t}\n\n\t\tif testCase.commitTx != nil {\n\t\t\tctx.CommitCtx = &CommitmentContext{\n\t\t\t\tValue: btcutil.Amount(\n\t\t\t\t\ttestCase.expectedValue,\n\t\t\t\t),\n\t\t\t\tFullySignedCommitTx: testCase.commitTx,\n\t\t\t}\n\t\t}\n\n\t\tchanPoint, err := Validate(ctx)\n\t\tif err != testCase.expectedErr {\n\t\t\t_, ok := testCase.expectedErr.(*ErrScriptValidateError)\n\t\t\t_, scriptErr := err.(*ErrScriptValidateError)\n\t\t\tif ok && scriptErr {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tt.Fatalf(\"test #%v: validation failed: expected %v, \"+\n\t\t\t\t\"got %v\", i, testCase.expectedErr, err)\n\t\t}\n\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tif *chanPoint != testCase.chanPoint {\n\t\t\tt.Fatalf(\"test #%v: wrong outpoint: want %v, got %v\",\n\t\t\t\ti, testCase.chanPoint, chanPoint)\n\t\t}\n\t}\n}\n",
      "length": 3920,
      "tokens": 418,
      "embedding": []
    }
  ]
}