{
  "filepath": "../implementations/go/lnd/lnwallet/chanvalidate/validate.go",
  "package": "chanvalidate",
  "sections": [
    {
      "slug": "type ErrScriptValidateError struct {",
      "content": "type ErrScriptValidateError struct {\n\terr error\n}\n\n// Error returns a human readable string describing the error.",
      "length": 73,
      "tokens": 13,
      "embedding": []
    },
    {
      "slug": "func (e *ErrScriptValidateError) Error() string {",
      "content": "func (e *ErrScriptValidateError) Error() string {\n\treturn fmt.Sprintf(\"script validation failed: %v\", e.err)\n}\n\n// Unwrap returns the underlying wrapped VM execution failure error.",
      "length": 127,
      "tokens": 17,
      "embedding": []
    },
    {
      "slug": "func (e *ErrScriptValidateError) Unwrap() error {",
      "content": "func (e *ErrScriptValidateError) Unwrap() error {\n\treturn e.err\n}\n\n// ChanLocator abstracts away obtaining the output that created the channel, as\n// well as validating its existence given the funding transaction.  We need\n// this as there are several ways (outpoint, short chan ID) to identify the\n// output of a channel given the funding transaction.",
      "length": 296,
      "tokens": 50,
      "embedding": []
    },
    {
      "slug": "type ChanLocator interface {",
      "content": "type ChanLocator interface {\n\t// Locate attempts to locate the funding output within the funding\n\t// transaction. It also returns the final out point of the channel\n\t// which uniquely identifies the output which creates the channel. If\n\t// the target output cannot be found, or cannot exist on the funding\n\t// transaction, then an error is to be returned.\n\tLocate(*wire.MsgTx) (*wire.TxOut, *wire.OutPoint, error)\n}\n\n// OutPointChanLocator is an implementation of the ChanLocator that can be used\n// when one already knows the expected chan point.",
      "length": 509,
      "tokens": 82,
      "embedding": []
    },
    {
      "slug": "type OutPointChanLocator struct {",
      "content": "type OutPointChanLocator struct {\n\t// ChanPoint is the expected chan point.\n\tChanPoint wire.OutPoint\n}\n\n// Locate attempts to locate the funding output within the passed funding\n// transaction.\n//\n// NOTE: Part of the ChanLocator interface.",
      "length": 199,
      "tokens": 32,
      "embedding": []
    },
    {
      "slug": "func (o *OutPointChanLocator) Locate(fundingTx *wire.MsgTx) (",
      "content": "func (o *OutPointChanLocator) Locate(fundingTx *wire.MsgTx) (\n\t*wire.TxOut, *wire.OutPoint, error) {\n\n\t// If the expected index is greater than the amount of output in the\n\t// transaction, then we'll reject this channel as it's invalid.\n\tif int(o.ChanPoint.Index) >= len(fundingTx.TxOut) {\n\t\treturn nil, nil, ErrInvalidOutPoint\n\t}\n\n\t// As an extra sanity check, we'll also ensure the txid hash matches.\n\tfundingHash := fundingTx.TxHash()\n\tif !bytes.Equal(fundingHash[:], o.ChanPoint.Hash[:]) {\n\t\treturn nil, nil, ErrInvalidOutPoint\n\t}\n\n\treturn fundingTx.TxOut[o.ChanPoint.Index], &o.ChanPoint, nil\n}\n\n// ShortChanIDChanLocator is an implementation of the ChanLocator that can be\n// used when one only knows the short channel ID of a channel. This should be\n// used in contexts when one is verifying a 3rd party channel.",
      "length": 738,
      "tokens": 107,
      "embedding": []
    },
    {
      "slug": "type ShortChanIDChanLocator struct {",
      "content": "type ShortChanIDChanLocator struct {\n\t// ID is the short channel ID of the target channel.\n\tID lnwire.ShortChannelID\n}\n\n// Locate attempts to locate the funding output within the passed funding\n// transaction.\n//\n// NOTE: Part of the ChanLocator interface.",
      "length": 212,
      "tokens": 36,
      "embedding": []
    },
    {
      "slug": "func (s *ShortChanIDChanLocator) Locate(fundingTx *wire.MsgTx) (",
      "content": "func (s *ShortChanIDChanLocator) Locate(fundingTx *wire.MsgTx) (\n\t*wire.TxOut, *wire.OutPoint, error) {\n\n\t// If the expected index is greater than the amount of output in the\n\t// transaction, then we'll reject this channel as it's invalid.\n\toutputIndex := s.ID.TxPosition\n\tif int(outputIndex) >= len(fundingTx.TxOut) {\n\t\treturn nil, nil, ErrInvalidOutPoint\n\t}\n\n\tchanPoint := wire.OutPoint{\n\t\tHash:  fundingTx.TxHash(),\n\t\tIndex: uint32(outputIndex),\n\t}\n\n\treturn fundingTx.TxOut[outputIndex], &chanPoint, nil\n}\n\n// CommitmentContext is optional validation context that can be passed into the\n// main Validate for self-owned channel. The information in this context allows\n// us to fully verify out initial commitment spend based on the on-chain state\n// of the funding output.",
      "length": 689,
      "tokens": 97,
      "embedding": []
    },
    {
      "slug": "type CommitmentContext struct {",
      "content": "type CommitmentContext struct {\n\t// Value is the known size of the channel.\n\tValue btcutil.Amount\n\n\t// FullySignedCommitTx is the fully signed commitment transaction. This\n\t// should include a valid witness.\n\tFullySignedCommitTx *wire.MsgTx\n}\n\n// Context is the main validation contxet. For a given channel, all fields but\n// the optional CommitCtx should be populated based on existing\n// known-to-be-valid parameters.",
      "length": 377,
      "tokens": 56,
      "embedding": []
    },
    {
      "slug": "type Context struct {",
      "content": "type Context struct {\n\t// Locator is a concrete implementation of the ChanLocator interface.\n\tLocator ChanLocator\n\n\t// MultiSigPkScript is the fully serialized witness script of the\n\t// multi-sig output. This is the final witness program that should be\n\t// found in the funding output.\n\tMultiSigPkScript []byte\n\n\t// FundingTx is channel funding transaction as found confirmed in the\n\t// chain.\n\tFundingTx *wire.MsgTx\n\n\t// CommitCtx is an optional additional set of validation context\n\t// required to validate a self-owned channel. If present, then a full\n\t// Script VM validation will be performed.\n\tCommitCtx *CommitmentContext\n}\n\n// Validate given the specified context, this function validates that the\n// alleged channel is well formed, and spendable (if the optional CommitCtx is\n// specified).  If this method returns an error, then the alleged channel is\n// invalid and should be abandoned immediately.",
      "length": 866,
      "tokens": 133,
      "embedding": []
    },
    {
      "slug": "func Validate(ctx *Context) (*wire.OutPoint, error) {",
      "content": "func Validate(ctx *Context) (*wire.OutPoint, error) {\n\t// First, we'll attempt to locate the target outpoint in the funding\n\t// transaction. If this returns an error, then we know that the\n\t// outpoint doesn't actually exist, so we'll exit early.\n\tfundingOutput, chanPoint, err := ctx.Locator.Locate(\n\t\tctx.FundingTx,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// The scripts should match up exactly, otherwise the channel is\n\t// invalid.\n\tfundingScript := fundingOutput.PkScript\n\tif !bytes.Equal(ctx.MultiSigPkScript, fundingScript) {\n\t\treturn nil, ErrWrongPkScript\n\t}\n\n\t// If there's no commitment context, then we're done here as this is a\n\t// 3rd party channel.\n\tif ctx.CommitCtx == nil {\n\t\treturn chanPoint, nil\n\t}\n\n\t// Now that we know this is our channel, we'll verify the amount of the\n\t// created output against our expected size of the channel.\n\tfundingValue := fundingOutput.Value\n\tif btcutil.Amount(fundingValue) != ctx.CommitCtx.Value {\n\t\treturn nil, ErrInvalidSize\n\t}\n\n\t// If we reach this point, then all other checks have succeeded, so\n\t// we'll now attempt a full Script VM execution to ensure that we're\n\t// able to close the channel using this initial state.\n\tvm, err := txscript.NewEngine(\n\t\tctx.MultiSigPkScript, ctx.CommitCtx.FullySignedCommitTx,\n\t\t0, txscript.StandardVerifyFlags, nil, nil, fundingValue,\n\t\ttxscript.NewCannedPrevOutputFetcher(ctx.MultiSigPkScript, 0),\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Finally, we'll attempt to verify our full spend, if this fails then\n\t// the channel is definitely invalid.\n\terr = vm.Execute()\n\tif err != nil {\n\t\treturn nil, &ErrScriptValidateError{err: err}\n\t}\n\n\treturn chanPoint, nil\n}\n",
      "length": 1554,
      "tokens": 232,
      "embedding": []
    }
  ]
}