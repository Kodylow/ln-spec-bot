{
  "filepath": "../implementations/go/lnd/lnwallet/btcwallet/btcwallet.go",
  "package": "btcwallet",
  "sections": [
    {
      "slug": "type BtcWallet struct {",
      "content": "type BtcWallet struct {\n\t// wallet is an active instance of btcwallet.\n\twallet *base.Wallet\n\n\tchain chain.Interface\n\n\tdb walletdb.DB\n\n\tcfg *Config\n\n\tnetParams *chaincfg.Params\n\n\tchainKeyScope waddrmgr.KeyScope\n\n\tblockCache *blockcache.BlockCache\n\n\tmusig2Sessions    map[input.MuSig2SessionID]*muSig2State\n\tmusig2SessionsMtx sync.Mutex\n}\n\n// A compile time check to ensure that BtcWallet implements the\n// WalletController and BlockChainIO interfaces.\nvar _ lnwallet.WalletController = (*BtcWallet)(nil)\nvar _ lnwallet.BlockChainIO = (*BtcWallet)(nil)\n\n// New returns a new fully initialized instance of BtcWallet given a valid\n// configuration struct.",
      "length": 602,
      "tokens": 69,
      "embedding": []
    },
    {
      "slug": "func New(cfg Config, blockCache *blockcache.BlockCache) (*BtcWallet, error) {",
      "content": "func New(cfg Config, blockCache *blockcache.BlockCache) (*BtcWallet, error) {\n\t// Create the key scope for the coin type being managed by this wallet.\n\tchainKeyScope := waddrmgr.KeyScope{\n\t\tPurpose: keychain.BIP0043Purpose,\n\t\tCoin:    cfg.CoinType,\n\t}\n\n\t// Maybe the wallet has already been opened and unlocked by the\n\t// WalletUnlocker. So if we get a non-nil value from the config,\n\t// we assume everything is in order.\n\tvar wallet = cfg.Wallet\n\tif wallet == nil {\n\t\t// No ready wallet was passed, so try to open an existing one.\n\t\tvar pubPass []byte\n\t\tif cfg.PublicPass == nil {\n\t\t\tpubPass = defaultPubPassphrase\n\t\t} else {\n\t\t\tpubPass = cfg.PublicPass\n\t\t}\n\n\t\tloader, err := NewWalletLoader(\n\t\t\tcfg.NetParams, cfg.RecoveryWindow, cfg.LoaderOptions...,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\twalletExists, err := loader.WalletExists()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif !walletExists {\n\t\t\t// Wallet has never been created, perform initial\n\t\t\t// set up.\n\t\t\twallet, err = loader.CreateNewWallet(\n\t\t\t\tpubPass, cfg.PrivatePass, cfg.HdSeed,\n\t\t\t\tcfg.Birthday,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\t// Wallet has been created and been initialized at\n\t\t\t// this point, open it along with all the required DB\n\t\t\t// namespaces, and the DB itself.\n\t\t\twallet, err = loader.OpenExistingWallet(pubPass, false)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn &BtcWallet{\n\t\tcfg:            &cfg,\n\t\twallet:         wallet,\n\t\tdb:             wallet.Database(),\n\t\tchain:          cfg.ChainSource,\n\t\tnetParams:      cfg.NetParams,\n\t\tchainKeyScope:  chainKeyScope,\n\t\tblockCache:     blockCache,\n\t\tmusig2Sessions: make(map[input.MuSig2SessionID]*muSig2State),\n\t}, nil\n}\n\n// loaderCfg holds optional wallet loader configuration.",
      "length": 1622,
      "tokens": 228,
      "embedding": []
    },
    {
      "slug": "type loaderCfg struct {",
      "content": "type loaderCfg struct {\n\tdbDirPath      string\n\tnoFreelistSync bool\n\tdbTimeout      time.Duration\n\tuseLocalDB     bool\n\texternalDB     kvdb.Backend\n}\n\n// LoaderOption is a functional option to update the optional loader config.",
      "length": 196,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "type LoaderOption func(*loaderCfg)",
      "content": "type LoaderOption func(*loaderCfg)\n\n// LoaderWithLocalWalletDB configures the wallet loader to use the local db.",
      "length": 76,
      "tokens": 11,
      "embedding": []
    },
    {
      "slug": "func LoaderWithLocalWalletDB(dbDirPath string, noFreelistSync bool,",
      "content": "func LoaderWithLocalWalletDB(dbDirPath string, noFreelistSync bool,\n\tdbTimeout time.Duration) LoaderOption {\n\n\treturn func(cfg *loaderCfg) {\n\t\tcfg.dbDirPath = dbDirPath\n\t\tcfg.noFreelistSync = noFreelistSync\n\t\tcfg.dbTimeout = dbTimeout\n\t\tcfg.useLocalDB = true\n\t}\n}\n\n// LoaderWithExternalWalletDB configures the wallet loadr to use an external db.",
      "length": 267,
      "tokens": 33,
      "embedding": []
    },
    {
      "slug": "func LoaderWithExternalWalletDB(db kvdb.Backend) LoaderOption {",
      "content": "func LoaderWithExternalWalletDB(db kvdb.Backend) LoaderOption {\n\treturn func(cfg *loaderCfg) {\n\t\tcfg.externalDB = db\n\t}\n}\n\n// NewWalletLoader constructs a wallet loader.",
      "length": 100,
      "tokens": 15,
      "embedding": []
    },
    {
      "slug": "func NewWalletLoader(chainParams *chaincfg.Params, recoveryWindow uint32,",
      "content": "func NewWalletLoader(chainParams *chaincfg.Params, recoveryWindow uint32,\n\topts ...LoaderOption) (*base.Loader, error) {\n\n\tcfg := &loaderCfg{}\n\n\t// Apply all functional options.\n\tfor _, o := range opts {\n\t\to(cfg)\n\t}\n\n\tif cfg.externalDB != nil && cfg.useLocalDB {\n\t\treturn nil, fmt.Errorf(\"wallet can either be in the local or \" +\n\t\t\t\"an external db\")\n\t}\n\n\tif cfg.externalDB != nil {\n\t\tloader, err := base.NewLoaderWithDB(\n\t\t\tchainParams, recoveryWindow, cfg.externalDB,\n\t\t\tfunc() (bool, error) {\n\t\t\t\treturn externalWalletExists(cfg.externalDB)\n\t\t\t},\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Decorate wallet db with out own key such that we\n\t\t// can always check whether the wallet exists or not.\n\t\tloader.OnWalletCreated(onWalletCreated)\n\t\treturn loader, nil\n\t}\n\n\treturn base.NewLoader(\n\t\tchainParams, cfg.dbDirPath, cfg.noFreelistSync,\n\t\tcfg.dbTimeout, recoveryWindow,\n\t), nil\n}\n\n// externalWalletExists is a helper function that we use to template btcwallet's\n// Loader in order to be able check if the wallet database has been initialized\n// in an external DB.",
      "length": 960,
      "tokens": 142,
      "embedding": []
    },
    {
      "slug": "func externalWalletExists(db kvdb.Backend) (bool, error) {",
      "content": "func externalWalletExists(db kvdb.Backend) (bool, error) {\n\texists := false\n\terr := kvdb.View(db, func(tx kvdb.RTx) error {\n\t\tmetaBucket := tx.ReadBucket([]byte(walletMetaBucket))\n\t\tif metaBucket != nil {\n\t\t\twalletReady := metaBucket.Get([]byte(walletReadyKey))\n\t\t\texists = string(walletReady) == walletReadyKey\n\t\t}\n\n\t\treturn nil\n\t}, func() {})\n\n\treturn exists, err\n}\n\n// onWalletCreated is executed when btcwallet creates the wallet the first time.",
      "length": 376,
      "tokens": 48,
      "embedding": []
    },
    {
      "slug": "func onWalletCreated(tx kvdb.RwTx) error {",
      "content": "func onWalletCreated(tx kvdb.RwTx) error {\n\tmetaBucket, err := tx.CreateTopLevelBucket([]byte(walletMetaBucket))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn metaBucket.Put([]byte(walletReadyKey), []byte(walletReadyKey))\n}\n\n// BackEnd returns the underlying ChainService's name as a string.\n//\n// This is a part of the WalletController interface.",
      "length": 290,
      "tokens": 36,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) BackEnd() string {",
      "content": "func (b *BtcWallet) BackEnd() string {\n\tif b.chain != nil {\n\t\treturn b.chain.BackEnd()\n\t}\n\n\treturn \"\"\n}\n\n// InternalWallet returns a pointer to the internal base wallet which is the\n// core of btcwallet.",
      "length": 156,
      "tokens": 28,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) InternalWallet() *base.Wallet {",
      "content": "func (b *BtcWallet) InternalWallet() *base.Wallet {\n\treturn b.wallet\n}\n\n// Start initializes the underlying rpc connection, the wallet itself, and\n// begins syncing to the current available blockchain state.\n//\n// This is a part of the WalletController interface.",
      "length": 205,
      "tokens": 33,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) Start() error {",
      "content": "func (b *BtcWallet) Start() error {\n\t// Is the wallet (according to its database) currently watch-only\n\t// already? If it is, we won't need to convert it later.\n\twalletIsWatchOnly := b.wallet.Manager.WatchOnly()\n\n\t// If the wallet is watch-only, but we don't expect it to be, then we\n\t// are in an unexpected state and cannot continue.\n\tif walletIsWatchOnly && !b.cfg.WatchOnly {\n\t\treturn fmt.Errorf(\"wallet is watch-only but we expect it \" +\n\t\t\t\"not to be; check if remote signing was disabled by \" +\n\t\t\t\"accident\")\n\t}\n\n\t// We'll start by unlocking the wallet and ensuring that the KeyScope:\n\t// (1017, 1) exists within the internal waddrmgr. We'll need this in\n\t// order to properly generate the keys required for signing various\n\t// contracts. If this is a watch-only wallet, we don't have any private\n\t// keys and therefore unlocking is not necessary.\n\tif !walletIsWatchOnly {\n\t\tif err := b.wallet.Unlock(b.cfg.PrivatePass, nil); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// If the wallet isn't about to be converted, we need to inform\n\t\t// the user that this wallet still contains all private key\n\t\t// material and that they need to migrate the existing wallet.\n\t\tif b.cfg.WatchOnly && !b.cfg.MigrateWatchOnly {\n\t\t\tlog.Warnf(\"Wallet is expected to be in watch-only \" +\n\t\t\t\t\"mode but hasn't been migrated to watch-only \" +\n\t\t\t\t\"yet, it still contains private keys; \" +\n\t\t\t\t\"consider turning on the watch-only wallet \" +\n\t\t\t\t\"migration in remote signing mode\")\n\t\t}\n\t}\n\n\t// Because we might add new \"default\" key scopes over time, they are\n\t// created correctly for new wallets. Existing wallets don't\n\t// automatically add them, we need to do that manually now.\n\tfor _, scope := range LndDefaultKeyScopes {\n\t\t_, err := b.wallet.Manager.FetchScopedKeyManager(scope)\n\t\tif waddrmgr.IsError(err, waddrmgr.ErrScopeNotFound) {\n\t\t\t// The default scope wasn't found, that probably means\n\t\t\t// it was added recently and older wallets don't know it\n\t\t\t// yet. Let's add it now.\n\t\t\taddrSchema := waddrmgr.ScopeAddrMap[scope]\n\t\t\terr := walletdb.Update(\n\t\t\t\tb.db, func(tx walletdb.ReadWriteTx) error {\n\t\t\t\t\taddrmgrNs := tx.ReadWriteBucket(\n\t\t\t\t\t\twaddrmgrNamespaceKey,\n\t\t\t\t\t)\n\n\t\t\t\t\t_, err := b.wallet.Manager.NewScopedKeyManager(\n\t\t\t\t\t\taddrmgrNs, scope, addrSchema,\n\t\t\t\t\t)\n\t\t\t\t\treturn err\n\t\t\t\t},\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tscope, err := b.wallet.Manager.FetchScopedKeyManager(b.chainKeyScope)\n\tif err != nil {\n\t\t// If the scope hasn't yet been created (it wouldn't been\n\t\t// loaded by default if it was), then we'll manually create the\n\t\t// scope for the first time ourselves.\n\t\terr := walletdb.Update(b.db, func(tx walletdb.ReadWriteTx) error {\n\t\t\taddrmgrNs := tx.ReadWriteBucket(waddrmgrNamespaceKey)\n\n\t\t\tscope, err = b.wallet.Manager.NewScopedKeyManager(\n\t\t\t\taddrmgrNs, b.chainKeyScope, lightningAddrSchema,\n\t\t\t)\n\t\t\treturn err\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Now that the wallet is unlocked, we'll go ahead and make sure we\n\t// create accounts for all the key families we're going to use. This\n\t// will make it possible to list all the account/family xpubs in the\n\t// wallet list RPC.\n\terr = walletdb.Update(b.db, func(tx walletdb.ReadWriteTx) error {\n\t\taddrmgrNs := tx.ReadWriteBucket(waddrmgrNamespaceKey)\n\n\t\t// Generate all accounts that we could ever need. This includes\n\t\t// all lnd key families as well as some key families used in\n\t\t// external liquidity tools.\n\t\tfor keyFam := uint32(1); keyFam <= 255; keyFam++ {\n\t\t\t// Otherwise, we'll check if the account already exists,\n\t\t\t// if so, we can once again bail early.\n\t\t\t_, err := scope.AccountName(addrmgrNs, keyFam)\n\t\t\tif err == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// If we reach this point, then the account hasn't yet\n\t\t\t// been created, so we'll need to create it before we\n\t\t\t// can proceed.\n\t\t\terr = scope.NewRawAccount(addrmgrNs, keyFam)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\t// If this is the first startup with remote signing and wallet\n\t\t// migration turned on and the wallet wasn't previously\n\t\t// migrated, we can do that now that we made sure all accounts\n\t\t// that we need were derived correctly.\n\t\tif !walletIsWatchOnly && b.cfg.WatchOnly &&\n\t\t\tb.cfg.MigrateWatchOnly {\n\n\t\t\tlog.Infof(\"Migrating wallet to watch-only mode, \" +\n\t\t\t\t\"purging all private key material\")\n\n\t\t\tns := tx.ReadWriteBucket(waddrmgrNamespaceKey)\n\t\t\terr = b.wallet.Manager.ConvertToWatchingOnly(ns)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Establish an RPC connection in addition to starting the goroutines\n\t// in the underlying wallet.\n\tif err := b.chain.Start(); err != nil {\n\t\treturn err\n\t}\n\n\t// Start the underlying btcwallet core.\n\tb.wallet.Start()\n\n\t// Pass the rpc client into the wallet so it can sync up to the\n\t// current main chain.\n\tb.wallet.SynchronizeRPC(b.chain)\n\n\treturn nil\n}\n\n// Stop signals the wallet for shutdown. Shutdown may entail closing\n// any active sockets, database handles, stopping goroutines, etc.\n//\n// This is a part of the WalletController interface.",
      "length": 4828,
      "tokens": 743,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) Stop() error {",
      "content": "func (b *BtcWallet) Stop() error {\n\tb.wallet.Stop()\n\n\tb.wallet.WaitForShutdown()\n\n\tb.chain.Stop()\n\n\treturn nil\n}\n\n// ConfirmedBalance returns the sum of all the wallet's unspent outputs that\n// have at least confs confirmations. If confs is set to zero, then all unspent\n// outputs, including those currently in the mempool will be included in the\n// final sum. The account parameter serves as a filter to retrieve the balance\n// for a specific account. When empty, the confirmed balance of all wallet\n// accounts is returned.\n//\n// This is a part of the WalletController interface.",
      "length": 531,
      "tokens": 87,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) ConfirmedBalance(confs int32,",
      "content": "func (b *BtcWallet) ConfirmedBalance(confs int32,\n\taccountFilter string) (btcutil.Amount, error) {\n\n\tvar balance btcutil.Amount\n\n\twitnessOutputs, err := b.ListUnspentWitness(\n\t\tconfs, math.MaxInt32, accountFilter,\n\t)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tfor _, witnessOutput := range witnessOutputs {\n\t\tbalance += witnessOutput.Value\n\t}\n\n\treturn balance, nil\n}\n\n// keyScopeForAccountAddr determines the appropriate key scope of an account\n// based on its name/address type.",
      "length": 405,
      "tokens": 56,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) keyScopeForAccountAddr(accountName string,",
      "content": "func (b *BtcWallet) keyScopeForAccountAddr(accountName string,\n\taddrType lnwallet.AddressType) (waddrmgr.KeyScope, uint32, error) {\n\n\t// Map the requested address type to its key scope.\n\tvar addrKeyScope waddrmgr.KeyScope\n\tswitch addrType {\n\tcase lnwallet.WitnessPubKey:\n\t\taddrKeyScope = waddrmgr.KeyScopeBIP0084\n\tcase lnwallet.NestedWitnessPubKey:\n\t\taddrKeyScope = waddrmgr.KeyScopeBIP0049Plus\n\tcase lnwallet.TaprootPubkey:\n\t\taddrKeyScope = waddrmgr.KeyScopeBIP0086\n\tdefault:\n\t\treturn waddrmgr.KeyScope{}, 0,\n\t\t\tfmt.Errorf(\"unknown address type\")\n\t}\n\n\t// The default account spans across multiple key scopes, so the\n\t// requested address type should already be valid for this account.\n\tif accountName == lnwallet.DefaultAccountName {\n\t\treturn addrKeyScope, defaultAccount, nil\n\t}\n\n\t// Otherwise, look up the account's key scope and check that it supports\n\t// the requested address type.\n\tkeyScope, account, err := b.wallet.LookupAccount(accountName)\n\tif err != nil {\n\t\treturn waddrmgr.KeyScope{}, 0, err\n\t}\n\n\tif keyScope != addrKeyScope {\n\t\treturn waddrmgr.KeyScope{}, 0, errIncompatibleAccountAddr\n\t}\n\n\treturn keyScope, account, nil\n}\n\n// NewAddress returns the next external or internal address for the wallet\n// dictated by the value of the `change` parameter. If change is true, then an\n// internal address will be returned, otherwise an external address should be\n// returned. The account parameter must be non-empty as it determines which\n// account the address should be generated from.\n//\n// This is a part of the WalletController interface.",
      "length": 1445,
      "tokens": 194,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) NewAddress(t lnwallet.AddressType, change bool,",
      "content": "func (b *BtcWallet) NewAddress(t lnwallet.AddressType, change bool,\n\taccountName string) (btcutil.Address, error) {\n\n\t// Addresses cannot be derived from the catch-all imported accounts.\n\tif accountName == waddrmgr.ImportedAddrAccountName {\n\t\treturn nil, errNoImportedAddrGen\n\t}\n\n\tkeyScope, account, err := b.keyScopeForAccountAddr(accountName, t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif change {\n\t\treturn b.wallet.NewChangeAddress(account, keyScope)\n\t}\n\treturn b.wallet.NewAddress(account, keyScope)\n}\n\n// LastUnusedAddress returns the last *unused* address known by the wallet. An\n// address is unused if it hasn't received any payments. This can be useful in\n// UIs in order to continually show the \"freshest\" address without having to\n// worry about \"address inflation\" caused by continual refreshing. Similar to\n// NewAddress it can derive a specified address type, and also optionally a\n// change address. The account parameter must be non-empty as it determines\n// which account the address should be generated from.",
      "length": 934,
      "tokens": 135,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) LastUnusedAddress(addrType lnwallet.AddressType,",
      "content": "func (b *BtcWallet) LastUnusedAddress(addrType lnwallet.AddressType,\n\taccountName string) (btcutil.Address, error) {\n\n\t// Addresses cannot be derived from the catch-all imported accounts.\n\tif accountName == waddrmgr.ImportedAddrAccountName {\n\t\treturn nil, errNoImportedAddrGen\n\t}\n\n\tkeyScope, account, err := b.keyScopeForAccountAddr(accountName, addrType)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn b.wallet.CurrentAddress(account, keyScope)\n}\n\n// IsOurAddress checks if the passed address belongs to this wallet\n//\n// This is a part of the WalletController interface.",
      "length": 486,
      "tokens": 64,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) IsOurAddress(a btcutil.Address) bool {",
      "content": "func (b *BtcWallet) IsOurAddress(a btcutil.Address) bool {\n\tresult, err := b.wallet.HaveAddress(a)\n\treturn result && (err == nil)\n}\n\n// AddressInfo returns the information about an address, if it's known to this\n// wallet.\n//\n// NOTE: This is a part of the WalletController interface.",
      "length": 218,
      "tokens": 37,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) AddressInfo(a btcutil.Address) (waddrmgr.ManagedAddress,",
      "content": "func (b *BtcWallet) AddressInfo(a btcutil.Address) (waddrmgr.ManagedAddress,\n\terror) {\n\n\treturn b.wallet.AddressInfo(a)\n}\n\n// ListAccounts retrieves all accounts belonging to the wallet by default. A\n// name and key scope filter can be provided to filter through all of the wallet\n// accounts and return only those matching.\n//\n// This is a part of the WalletController interface.",
      "length": 294,
      "tokens": 50,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) ListAccounts(name string,",
      "content": "func (b *BtcWallet) ListAccounts(name string,\n\tkeyScope *waddrmgr.KeyScope) ([]*waddrmgr.AccountProperties, error) {\n\n\tvar res []*waddrmgr.AccountProperties\n\tswitch {\n\t// If both the name and key scope filters were provided, we'll return\n\t// the existing account matching those.\n\tcase name != \"\" && keyScope != nil:\n\t\taccount, err := b.wallet.AccountPropertiesByName(*keyScope, name)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tres = append(res, account)\n\n\t// Only the name filter was provided.\n\tcase name != \"\" && keyScope == nil:\n\t\t// If the name corresponds to the default or imported accounts,\n\t\t// we'll return them for all our supported key scopes.\n\t\tif name == lnwallet.DefaultAccountName ||\n\t\t\tname == waddrmgr.ImportedAddrAccountName {\n\n\t\t\tfor _, defaultScope := range LndDefaultKeyScopes {\n\t\t\t\ta, err := b.wallet.AccountPropertiesByName(\n\t\t\t\t\tdefaultScope, name,\n\t\t\t\t)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tres = append(res, a)\n\t\t\t}\n\n\t\t\tbreak\n\t\t}\n\n\t\t// Otherwise, we'll retrieve the single account that's mapped by\n\t\t// the given name.\n\t\tscope, acctNum, err := b.wallet.LookupAccount(name)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\taccount, err := b.wallet.AccountProperties(scope, acctNum)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tres = append(res, account)\n\n\t// Only the key scope filter was provided, so we'll return all accounts\n\t// matching it.\n\tcase name == \"\" && keyScope != nil:\n\t\taccounts, err := b.wallet.Accounts(*keyScope)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfor _, account := range accounts.Accounts {\n\t\t\taccount := account\n\t\t\tres = append(res, &account.AccountProperties)\n\t\t}\n\n\t// Neither of the filters were provided, so return all accounts for our\n\t// supported key scopes.\n\tcase name == \"\" && keyScope == nil:\n\t\tfor _, defaultScope := range LndDefaultKeyScopes {\n\t\t\taccounts, err := b.wallet.Accounts(defaultScope)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tfor _, account := range accounts.Accounts {\n\t\t\t\taccount := account\n\t\t\t\tres = append(res, &account.AccountProperties)\n\t\t\t}\n\t\t}\n\n\t\taccounts, err := b.wallet.Accounts(waddrmgr.KeyScope{\n\t\t\tPurpose: keychain.BIP0043Purpose,\n\t\t\tCoin:    b.cfg.CoinType,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfor _, account := range accounts.Accounts {\n\t\t\taccount := account\n\t\t\tres = append(res, &account.AccountProperties)\n\t\t}\n\t}\n\n\treturn res, nil\n}\n\n// RequiredReserve returns the minimum amount of satoshis that should be\n// kept in the wallet in order to fee bump anchor channels if necessary.\n// The value scales with the number of public anchor channels but is\n// capped at a maximum.",
      "length": 2452,
      "tokens": 370,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) RequiredReserve(",
      "content": "func (b *BtcWallet) RequiredReserve(\n\tnumAnchorChans uint32) btcutil.Amount {\n\n\tanchorChanReservedValue := lnwallet.AnchorChanReservedValue\n\treserved := btcutil.Amount(numAnchorChans) * anchorChanReservedValue\n\tif reserved > lnwallet.MaxAnchorChanReservedValue {\n\t\treserved = lnwallet.MaxAnchorChanReservedValue\n\t}\n\n\treturn reserved\n}\n\n// ListAddresses retrieves all the addresses along with their balance. An\n// account name filter can be provided to filter through all of the\n// wallet accounts and return the addresses of only those matching.\n//\n// This is a part of the WalletController interface.",
      "length": 549,
      "tokens": 69,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) ListAddresses(name string,",
      "content": "func (b *BtcWallet) ListAddresses(name string,\n\tshowCustomAccounts bool) (lnwallet.AccountAddressMap, error) {\n\n\taccounts, err := b.ListAccounts(name, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\taddresses := make(lnwallet.AccountAddressMap)\n\taddressBalance := make(map[string]btcutil.Amount)\n\n\t// Retrieve all the unspent ouputs.\n\toutputs, err := b.wallet.ListUnspent(0, math.MaxInt32, \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Calculate the total balance of each address.\n\tfor _, output := range outputs {\n\t\tamount, err := btcutil.NewAmount(output.Amount)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\taddressBalance[output.Address] += amount\n\t}\n\n\tfor _, accntDetails := range accounts {\n\t\taccntScope := accntDetails.KeyScope\n\t\tscopedMgr, err := b.wallet.Manager.FetchScopedKeyManager(\n\t\t\taccntScope,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tvar managedAddrs []waddrmgr.ManagedAddress\n\t\terr = walletdb.View(\n\t\t\tb.wallet.Database(), func(tx walletdb.ReadTx) error {\n\t\t\t\tmanagedAddrs = nil\n\t\t\t\taddrmgrNs := tx.ReadBucket(waddrmgrNamespaceKey)\n\t\t\t\treturn scopedMgr.ForEachAccountAddress(\n\t\t\t\t\taddrmgrNs, accntDetails.AccountNumber,\n\t\t\t\t\tfunc(a waddrmgr.ManagedAddress) error {\n\t\t\t\t\t\tmanagedAddrs = append(\n\t\t\t\t\t\t\tmanagedAddrs, a,\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t},\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Only consider those accounts which have addresses.\n\t\tif len(managedAddrs) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// All the lnd internal/custom keys for channels and other\n\t\t// functionality are derived from the same scope. Since they\n\t\t// aren't really used as addresses and will never have an\n\t\t// on-chain balance, we'll want to show the public key instead.\n\t\tisLndCustom := accntScope.Purpose == keychain.BIP0043Purpose\n\t\taddressProperties := make(\n\t\t\t[]lnwallet.AddressProperty, len(managedAddrs),\n\t\t)\n\n\t\tfor idx, managedAddr := range managedAddrs {\n\t\t\taddr := managedAddr.Address()\n\t\t\taddressString := addr.String()\n\n\t\t\t// Hex-encode the compressed public key for custom lnd\n\t\t\t// keys, addresses don't make a lot of sense.\n\t\t\tpubKey, ok := managedAddr.(waddrmgr.ManagedPubKeyAddress)\n\t\t\tif ok && isLndCustom {\n\t\t\t\taddressString = hex.EncodeToString(\n\t\t\t\t\tpubKey.PubKey().SerializeCompressed(),\n\t\t\t\t)\n\t\t\t}\n\n\t\t\taddressProperties[idx] = lnwallet.AddressProperty{\n\t\t\t\tAddress:  addressString,\n\t\t\t\tInternal: managedAddr.Internal(),\n\t\t\t\tBalance:  addressBalance[addressString],\n\t\t\t}\n\t\t}\n\n\t\tif accntScope.Purpose != keychain.BIP0043Purpose ||\n\t\t\tshowCustomAccounts {\n\n\t\t\taddresses[accntDetails] = addressProperties\n\t\t}\n\t}\n\n\treturn addresses, nil\n}\n\n// ImportAccount imports an account backed by an account extended public key.\n// The master key fingerprint denotes the fingerprint of the root key\n// corresponding to the account public key (also known as the key with\n// derivation path m/). This may be required by some hardware wallets for proper\n// identification and signing.\n//\n// The address type can usually be inferred from the key's version, but may be\n// required for certain keys to map them into the proper scope.\n//\n// For BIP-0044 keys, an address type must be specified as we intend to not\n// support importing BIP-0044 keys into the wallet using the legacy\n// pay-to-pubkey-hash (P2PKH) scheme. A nested witness address type will force\n// the standard BIP-0049 derivation scheme, while a witness address type will\n// force the standard BIP-0084 derivation scheme.\n//\n// For BIP-0049 keys, an address type must also be specified to make a\n// distinction between the standard BIP-0049 address schema (nested witness\n// pubkeys everywhere) and our own BIP-0049Plus address schema (nested pubkeys\n// externally, witness pubkeys internally).\n//\n// This is a part of the WalletController interface.",
      "length": 3564,
      "tokens": 481,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) ImportAccount(name string, accountPubKey *hdkeychain.ExtendedKey,",
      "content": "func (b *BtcWallet) ImportAccount(name string, accountPubKey *hdkeychain.ExtendedKey,\n\tmasterKeyFingerprint uint32, addrType *waddrmgr.AddressType,\n\tdryRun bool) (*waddrmgr.AccountProperties, []btcutil.Address,\n\t[]btcutil.Address, error) {\n\n\tif !dryRun {\n\t\taccountProps, err := b.wallet.ImportAccount(\n\t\t\tname, accountPubKey, masterKeyFingerprint, addrType,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, nil, nil, err\n\t\t}\n\t\treturn accountProps, nil, nil, nil\n\t}\n\n\t// Derive addresses from both the external and internal branches of the\n\t// account. There's no risk of address inflation as this is only done\n\t// for dry runs.\n\taccountProps, extAddrs, intAddrs, err := b.wallet.ImportAccountDryRun(\n\t\tname, accountPubKey, masterKeyFingerprint, addrType,\n\t\tdryRunImportAccountNumAddrs,\n\t)\n\tif err != nil {\n\t\treturn nil, nil, nil, err\n\t}\n\n\texternalAddrs := make([]btcutil.Address, len(extAddrs))\n\tfor i := 0; i < len(extAddrs); i++ {\n\t\texternalAddrs[i] = extAddrs[i].Address()\n\t}\n\n\tinternalAddrs := make([]btcutil.Address, len(intAddrs))\n\tfor i := 0; i < len(intAddrs); i++ {\n\t\tinternalAddrs[i] = intAddrs[i].Address()\n\t}\n\n\treturn accountProps, externalAddrs, internalAddrs, nil\n}\n\n// ImportPublicKey imports a single derived public key into the wallet. The\n// address type can usually be inferred from the key's version, but in the case\n// of legacy versions (xpub, tpub), an address type must be specified as we\n// intend to not support importing BIP-44 keys into the wallet using the legacy\n// pay-to-pubkey-hash (P2PKH) scheme.\n//\n// This is a part of the WalletController interface.",
      "length": 1444,
      "tokens": 201,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) ImportPublicKey(pubKey *btcec.PublicKey,",
      "content": "func (b *BtcWallet) ImportPublicKey(pubKey *btcec.PublicKey,\n\taddrType waddrmgr.AddressType) error {\n\n\treturn b.wallet.ImportPublicKey(pubKey, addrType)\n}\n\n// ImportTaprootScript imports a user-provided taproot script into the address\n// manager. The imported script will act as a pay-to-taproot address.",
      "length": 237,
      "tokens": 29,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) ImportTaprootScript(scope waddrmgr.KeyScope,",
      "content": "func (b *BtcWallet) ImportTaprootScript(scope waddrmgr.KeyScope,\n\ttapscript *waddrmgr.Tapscript) (waddrmgr.ManagedAddress, error) {\n\n\t// We want to be able to import script addresses into a watch-only\n\t// wallet, which is only possible if we don't encrypt the script with\n\t// the private key encryption key. By specifying the script as being\n\t// \"not secret\", we can also decrypt the script in a watch-only wallet.\n\tconst isSecretScript = false\n\n\t// Currently, only v1 (Taproot) scripts are supported. We don't even\n\t// know what a v2 witness version would look like at this point.\n\tconst witnessVersionTaproot byte = 1\n\n\treturn b.wallet.ImportTaprootScript(\n\t\tscope, tapscript, nil, witnessVersionTaproot, isSecretScript,\n\t)\n}\n\n// SendOutputs funds, signs, and broadcasts a Bitcoin transaction paying out to\n// the specified outputs. In the case the wallet has insufficient funds, or the\n// outputs are non-standard, a non-nil error will be returned.\n//\n// NOTE: This method requires the global coin selection lock to be held.\n//\n// This is a part of the WalletController interface.",
      "length": 995,
      "tokens": 158,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) SendOutputs(outputs []*wire.TxOut,",
      "content": "func (b *BtcWallet) SendOutputs(outputs []*wire.TxOut,\n\tfeeRate chainfee.SatPerKWeight, minConfs int32,\n\tlabel string) (*wire.MsgTx, error) {\n\n\t// Convert our fee rate from sat/kw to sat/kb since it's required by\n\t// SendOutputs.\n\tfeeSatPerKB := btcutil.Amount(feeRate.FeePerKVByte())\n\n\t// Sanity check outputs.\n\tif len(outputs) < 1 {\n\t\treturn nil, lnwallet.ErrNoOutputs\n\t}\n\n\t// Sanity check minConfs.\n\tif minConfs < 0 {\n\t\treturn nil, lnwallet.ErrInvalidMinconf\n\t}\n\n\treturn b.wallet.SendOutputs(\n\t\toutputs, nil, defaultAccount, minConfs, feeSatPerKB,\n\t\tb.cfg.CoinSelectionStrategy, label,\n\t)\n}\n\n// CreateSimpleTx creates a Bitcoin transaction paying to the specified\n// outputs. The transaction is not broadcasted to the network, but a new change\n// address might be created in the wallet database. In the case the wallet has\n// insufficient funds, or the outputs are non-standard, an error should be\n// returned. This method also takes the target fee expressed in sat/kw that\n// should be used when crafting the transaction.\n//\n// NOTE: The dryRun argument can be set true to create a tx that doesn't alter\n// the database. A tx created with this set to true SHOULD NOT be broadcasted.\n//\n// NOTE: This method requires the global coin selection lock to be held.\n//\n// This is a part of the WalletController interface.",
      "length": 1228,
      "tokens": 192,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) CreateSimpleTx(outputs []*wire.TxOut,",
      "content": "func (b *BtcWallet) CreateSimpleTx(outputs []*wire.TxOut,\n\tfeeRate chainfee.SatPerKWeight, minConfs int32,\n\tdryRun bool) (*txauthor.AuthoredTx, error) {\n\n\t// The fee rate is passed in using units of sat/kw, so we'll convert\n\t// this to sat/KB as the CreateSimpleTx method requires this unit.\n\tfeeSatPerKB := btcutil.Amount(feeRate.FeePerKVByte())\n\n\t// Sanity check outputs.\n\tif len(outputs) < 1 {\n\t\treturn nil, lnwallet.ErrNoOutputs\n\t}\n\n\t// Sanity check minConfs.\n\tif minConfs < 0 {\n\t\treturn nil, lnwallet.ErrInvalidMinconf\n\t}\n\n\tfor _, output := range outputs {\n\t\t// When checking an output for things like dusty-ness, we'll\n\t\t// use the default mempool relay fee rather than the target\n\t\t// effective fee rate to ensure accuracy. Otherwise, we may\n\t\t// mistakenly mark small-ish, but not quite dust output as\n\t\t// dust.\n\t\terr := txrules.CheckOutput(\n\t\t\toutput, txrules.DefaultRelayFeePerKb,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn b.wallet.CreateSimpleTx(\n\t\tnil, defaultAccount, outputs, minConfs, feeSatPerKB,\n\t\tb.cfg.CoinSelectionStrategy, dryRun,\n\t)\n}\n\n// LockOutpoint marks an outpoint as locked meaning it will no longer be deemed\n// as eligible for coin selection. Locking outputs are utilized in order to\n// avoid race conditions when selecting inputs for usage when funding a\n// channel.\n//\n// NOTE: This method requires the global coin selection lock to be held.\n//\n// This is a part of the WalletController interface.",
      "length": 1343,
      "tokens": 205,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) LockOutpoint(o wire.OutPoint) {",
      "content": "func (b *BtcWallet) LockOutpoint(o wire.OutPoint) {\n\tb.wallet.LockOutpoint(o)\n}\n\n// UnlockOutpoint unlocks a previously locked output, marking it eligible for\n// coin selection.\n//\n// NOTE: This method requires the global coin selection lock to be held.\n//\n// This is a part of the WalletController interface.",
      "length": 249,
      "tokens": 40,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) UnlockOutpoint(o wire.OutPoint) {",
      "content": "func (b *BtcWallet) UnlockOutpoint(o wire.OutPoint) {\n\tb.wallet.UnlockOutpoint(o)\n}\n\n// LeaseOutput locks an output to the given ID, preventing it from being\n// available for any future coin selection attempts. The absolute time of the\n// lock's expiration is returned. The expiration of the lock can be extended by\n// successive invocations of this call. Outputs can be unlocked before their\n// expiration through `ReleaseOutput`.\n//\n// If the output is not known, wtxmgr.ErrUnknownOutput is returned. If the\n// output has already been locked to a different ID, then\n// wtxmgr.ErrOutputAlreadyLocked is returned.\n//\n// NOTE: This method requires the global coin selection lock to be held.",
      "length": 622,
      "tokens": 100,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) LeaseOutput(id wtxmgr.LockID, op wire.OutPoint,",
      "content": "func (b *BtcWallet) LeaseOutput(id wtxmgr.LockID, op wire.OutPoint,\n\tduration time.Duration) (time.Time, []byte, btcutil.Amount, error) {\n\n\t// Make sure we don't attempt to double lock an output that's been\n\t// locked by the in-memory implementation.\n\tif b.wallet.LockedOutpoint(op) {\n\t\treturn time.Time{}, nil, 0, wtxmgr.ErrOutputAlreadyLocked\n\t}\n\n\tlockedUntil, err := b.wallet.LeaseOutput(id, op, duration)\n\tif err != nil {\n\t\treturn time.Time{}, nil, 0, err\n\t}\n\n\t// Get the pkScript and value for this lock from the list of all leased\n\t// outputs.\n\tallLeases, err := b.wallet.ListLeasedOutputs()\n\tif err != nil {\n\t\treturn time.Time{}, nil, 0, err\n\t}\n\n\tfor _, lease := range allLeases {\n\t\tif lease.Outpoint == op {\n\t\t\treturn lockedUntil, lease.PkScript,\n\t\t\t\tbtcutil.Amount(lease.Value), nil\n\t\t}\n\t}\n\n\t// We MUST find the leased output in the loop above, otherwise something\n\t// is seriously wrong.\n\treturn time.Time{}, nil, 0, wtxmgr.ErrUnknownOutput\n}\n\n// ListLeasedOutputs returns a list of all currently locked outputs.",
      "length": 922,
      "tokens": 136,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) ListLeasedOutputs() ([]*base.ListLeasedOutputResult,",
      "content": "func (b *BtcWallet) ListLeasedOutputs() ([]*base.ListLeasedOutputResult,\n\terror) {\n\n\treturn b.wallet.ListLeasedOutputs()\n}\n\n// ReleaseOutput unlocks an output, allowing it to be available for coin\n// selection if it remains unspent. The ID should match the one used to\n// originally lock the output.\n//\n// NOTE: This method requires the global coin selection lock to be held.",
      "length": 293,
      "tokens": 50,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) ReleaseOutput(id wtxmgr.LockID, op wire.OutPoint) error {",
      "content": "func (b *BtcWallet) ReleaseOutput(id wtxmgr.LockID, op wire.OutPoint) error {\n\treturn b.wallet.ReleaseOutput(id, op)\n}\n\n// ListUnspentWitness returns all unspent outputs which are version 0 witness\n// programs. The 'minConfs' and 'maxConfs' parameters indicate the minimum\n// and maximum number of confirmations an output needs in order to be returned\n// by this method. Passing -1 as 'minConfs' indicates that even unconfirmed\n// outputs should be returned. Using MaxInt32 as 'maxConfs' implies returning\n// all outputs with at least 'minConfs'. The account parameter serves as a\n// filter to retrieve the unspent outputs for a specific account.  When empty,\n// the unspent outputs of all wallet accounts are returned.\n//\n// NOTE: This method requires the global coin selection lock to be held.\n//\n// This is a part of the WalletController interface.",
      "length": 759,
      "tokens": 122,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) ListUnspentWitness(minConfs, maxConfs int32,",
      "content": "func (b *BtcWallet) ListUnspentWitness(minConfs, maxConfs int32,\n\taccountFilter string) ([]*lnwallet.Utxo, error) {\n\n\t// First, grab all the unfiltered currently unspent outputs.\n\tunspentOutputs, err := b.wallet.ListUnspent(\n\t\tminConfs, maxConfs, accountFilter,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Next, we'll run through all the regular outputs, only saving those\n\t// which are p2wkh outputs or a p2wsh output nested within a p2sh output.\n\twitnessOutputs := make([]*lnwallet.Utxo, 0, len(unspentOutputs))\n\tfor _, output := range unspentOutputs {\n\t\tpkScript, err := hex.DecodeString(output.ScriptPubKey)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\taddressType := lnwallet.UnknownAddressType\n\t\tif txscript.IsPayToWitnessPubKeyHash(pkScript) {\n\t\t\taddressType = lnwallet.WitnessPubKey\n\t\t} else if txscript.IsPayToScriptHash(pkScript) {\n\t\t\t// TODO(roasbeef): This assumes all p2sh outputs returned by the\n\t\t\t// wallet are nested p2pkh. We can't check the redeem script because\n\t\t\t// the btcwallet service does not include it.\n\t\t\taddressType = lnwallet.NestedWitnessPubKey\n\t\t} else if txscript.IsPayToTaproot(pkScript) {\n\t\t\taddressType = lnwallet.TaprootPubkey\n\t\t}\n\n\t\tif addressType == lnwallet.WitnessPubKey ||\n\t\t\taddressType == lnwallet.NestedWitnessPubKey ||\n\t\t\taddressType == lnwallet.TaprootPubkey {\n\n\t\t\ttxid, err := chainhash.NewHashFromStr(output.TxID)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\t// We'll ensure we properly convert the amount given in\n\t\t\t// BTC to satoshis.\n\t\t\tamt, err := btcutil.NewAmount(output.Amount)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tutxo := &lnwallet.Utxo{\n\t\t\t\tAddressType: addressType,\n\t\t\t\tValue:       amt,\n\t\t\t\tPkScript:    pkScript,\n\t\t\t\tOutPoint: wire.OutPoint{\n\t\t\t\t\tHash:  *txid,\n\t\t\t\t\tIndex: output.Vout,\n\t\t\t\t},\n\t\t\t\tConfirmations: output.Confirmations,\n\t\t\t}\n\t\t\twitnessOutputs = append(witnessOutputs, utxo)\n\t\t}\n\n\t}\n\n\treturn witnessOutputs, nil\n}\n\n// PublishTransaction performs cursory validation (dust checks, etc), then\n// finally broadcasts the passed transaction to the Bitcoin network. If\n// publishing the transaction fails, an error describing the reason is returned\n// (currently ErrDoubleSpend). If the transaction is already published to the\n// network (either in the mempool or chain) no error will be returned.",
      "length": 2147,
      "tokens": 276,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) PublishTransaction(tx *wire.MsgTx, label string) error {",
      "content": "func (b *BtcWallet) PublishTransaction(tx *wire.MsgTx, label string) error {\n\tif err := b.wallet.PublishTransaction(tx, label); err != nil {\n\t\t// If we failed to publish the transaction, check whether we\n\t\t// got an error of known type.\n\t\tswitch err.(type) {\n\t\t// If the wallet reports a double spend, convert it to our\n\t\t// internal ErrDoubleSpend and return.\n\t\tcase *base.ErrDoubleSpend:\n\t\t\treturn lnwallet.ErrDoubleSpend\n\n\t\t// If the wallet reports a replacement error, return\n\t\t// ErrDoubleSpend, as we currently are never attempting to\n\t\t// replace transactions.\n\t\tcase *base.ErrReplacement:\n\t\t\treturn lnwallet.ErrDoubleSpend\n\n\t\tdefault:\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// LabelTransaction adds a label to a transaction. If the tx already\n// has a label, this call will fail unless the overwrite parameter\n// is set. Labels must not be empty, and they are limited to 500 chars.\n//\n// Note: it is part of the WalletController interface.",
      "length": 841,
      "tokens": 133,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) LabelTransaction(hash chainhash.Hash, label string,",
      "content": "func (b *BtcWallet) LabelTransaction(hash chainhash.Hash, label string,\n\toverwrite bool) error {\n\n\treturn b.wallet.LabelTransaction(hash, label, overwrite)\n}\n\n// extractBalanceDelta extracts the net balance delta from the PoV of the\n// wallet given a TransactionSummary.",
      "length": 192,
      "tokens": 26,
      "embedding": []
    },
    {
      "slug": "func extractBalanceDelta(",
      "content": "func extractBalanceDelta(\n\ttxSummary base.TransactionSummary,\n\ttx *wire.MsgTx,\n) (btcutil.Amount, error) {\n\t// For each input we debit the wallet's outflow for this transaction,\n\t// and for each output we credit the wallet's inflow for this\n\t// transaction.\n\tvar balanceDelta btcutil.Amount\n\tfor _, input := range txSummary.MyInputs {\n\t\tbalanceDelta -= input.PreviousAmount\n\t}\n\tfor _, output := range txSummary.MyOutputs {\n\t\tbalanceDelta += btcutil.Amount(tx.TxOut[output.Index].Value)\n\t}\n\n\treturn balanceDelta, nil\n}\n\n// getPreviousOutpoints is a helper function which gets the previous\n// outpoints of a transaction.",
      "length": 574,
      "tokens": 78,
      "embedding": []
    },
    {
      "slug": "func getPreviousOutpoints(wireTx *wire.MsgTx,",
      "content": "func getPreviousOutpoints(wireTx *wire.MsgTx,\n\tmyInputs []wallet.TransactionSummaryInput) []lnwallet.PreviousOutPoint {\n\n\t// isOurOutput is a map containing the output indices\n\t// controlled by the wallet.\n\t// Note: We make use of the information in `myInputs` provided\n\t// by the `wallet.TransactionSummary` structure that holds\n\t// information only if the input/previous_output is controlled by the wallet.\n\tisOurOutput := make(map[uint32]bool, len(myInputs))\n\tfor _, myInput := range myInputs {\n\t\tisOurOutput[myInput.Index] = true\n\t}\n\n\tpreviousOutpoints := make([]lnwallet.PreviousOutPoint, len(wireTx.TxIn))\n\tfor idx, txIn := range wireTx.TxIn {\n\t\tpreviousOutpoints[idx] = lnwallet.PreviousOutPoint{\n\t\t\tOutPoint:    txIn.PreviousOutPoint.String(),\n\t\t\tIsOurOutput: isOurOutput[uint32(idx)],\n\t\t}\n\t}\n\n\treturn previousOutpoints\n}\n\n// minedTransactionsToDetails is a helper function which converts a summary\n// information about mined transactions to a TransactionDetail.",
      "length": 900,
      "tokens": 103,
      "embedding": []
    },
    {
      "slug": "func minedTransactionsToDetails(",
      "content": "func minedTransactionsToDetails(\n\tcurrentHeight int32,\n\tblock base.Block,\n\tchainParams *chaincfg.Params,\n) ([]*lnwallet.TransactionDetail, error) {\n\n\tdetails := make([]*lnwallet.TransactionDetail, 0, len(block.Transactions))\n\tfor _, tx := range block.Transactions {\n\t\twireTx := &wire.MsgTx{}\n\t\ttxReader := bytes.NewReader(tx.Transaction)\n\n\t\tif err := wireTx.Deserialize(txReader); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// isOurAddress is a map containing the output indices\n\t\t// controlled by the wallet.\n\t\t// Note: We make use of the information in `MyOutputs` provided\n\t\t// by the `wallet.TransactionSummary` structure that holds\n\t\t// information only if the output is controlled by the wallet.\n\t\tisOurAddress := make(map[int]bool, len(tx.MyOutputs))\n\t\tfor _, o := range tx.MyOutputs {\n\t\t\tisOurAddress[int(o.Index)] = true\n\t\t}\n\n\t\tvar outputDetails []lnwallet.OutputDetail\n\t\tfor i, txOut := range wireTx.TxOut {\n\t\t\tvar addresses []btcutil.Address\n\t\t\tsc, outAddresses, _, err := txscript.ExtractPkScriptAddrs(\n\t\t\t\ttxOut.PkScript, chainParams,\n\t\t\t)\n\t\t\tif err == nil {\n\t\t\t\t// Add supported addresses.\n\t\t\t\taddresses = outAddresses\n\t\t\t}\n\n\t\t\toutputDetails = append(outputDetails, lnwallet.OutputDetail{\n\t\t\t\tOutputType:   sc,\n\t\t\t\tAddresses:    addresses,\n\t\t\t\tPkScript:     txOut.PkScript,\n\t\t\t\tOutputIndex:  i,\n\t\t\t\tValue:        btcutil.Amount(txOut.Value),\n\t\t\t\tIsOurAddress: isOurAddress[i],\n\t\t\t})\n\t\t}\n\n\t\tpreviousOutpoints := getPreviousOutpoints(wireTx, tx.MyInputs)\n\n\t\ttxDetail := &lnwallet.TransactionDetail{\n\t\t\tHash:              *tx.Hash,\n\t\t\tNumConfirmations:  currentHeight - block.Height + 1,\n\t\t\tBlockHash:         block.Hash,\n\t\t\tBlockHeight:       block.Height,\n\t\t\tTimestamp:         block.Timestamp,\n\t\t\tTotalFees:         int64(tx.Fee),\n\t\t\tOutputDetails:     outputDetails,\n\t\t\tRawTx:             tx.Transaction,\n\t\t\tLabel:             tx.Label,\n\t\t\tPreviousOutpoints: previousOutpoints,\n\t\t}\n\n\t\tbalanceDelta, err := extractBalanceDelta(tx, wireTx)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ttxDetail.Value = balanceDelta\n\n\t\tdetails = append(details, txDetail)\n\t}\n\n\treturn details, nil\n}\n\n// unminedTransactionsToDetail is a helper function which converts a summary\n// for an unconfirmed transaction to a transaction detail.",
      "length": 2118,
      "tokens": 228,
      "embedding": []
    },
    {
      "slug": "func unminedTransactionsToDetail(",
      "content": "func unminedTransactionsToDetail(\n\tsummary base.TransactionSummary,\n\tchainParams *chaincfg.Params,\n) (*lnwallet.TransactionDetail, error) {\n\n\twireTx := &wire.MsgTx{}\n\ttxReader := bytes.NewReader(summary.Transaction)\n\n\tif err := wireTx.Deserialize(txReader); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// isOurAddress is a map containing the output indices controlled by\n\t// the wallet.\n\t// Note: We make use of the information in `MyOutputs` provided\n\t// by the `wallet.TransactionSummary` structure that holds information\n\t// only if the output is controlled by the wallet.\n\tisOurAddress := make(map[int]bool, len(summary.MyOutputs))\n\tfor _, o := range summary.MyOutputs {\n\t\tisOurAddress[int(o.Index)] = true\n\t}\n\n\tvar outputDetails []lnwallet.OutputDetail\n\tfor i, txOut := range wireTx.TxOut {\n\t\tvar addresses []btcutil.Address\n\t\tsc, outAddresses, _, err := txscript.ExtractPkScriptAddrs(\n\t\t\ttxOut.PkScript, chainParams,\n\t\t)\n\t\tif err == nil {\n\t\t\t// Add supported addresses.\n\t\t\taddresses = outAddresses\n\t\t}\n\n\t\toutputDetails = append(outputDetails, lnwallet.OutputDetail{\n\t\t\tOutputType:   sc,\n\t\t\tAddresses:    addresses,\n\t\t\tPkScript:     txOut.PkScript,\n\t\t\tOutputIndex:  i,\n\t\t\tValue:        btcutil.Amount(txOut.Value),\n\t\t\tIsOurAddress: isOurAddress[i],\n\t\t})\n\t}\n\n\tpreviousOutpoints := getPreviousOutpoints(wireTx, summary.MyInputs)\n\n\ttxDetail := &lnwallet.TransactionDetail{\n\t\tHash:              *summary.Hash,\n\t\tTotalFees:         int64(summary.Fee),\n\t\tTimestamp:         summary.Timestamp,\n\t\tOutputDetails:     outputDetails,\n\t\tRawTx:             summary.Transaction,\n\t\tLabel:             summary.Label,\n\t\tPreviousOutpoints: previousOutpoints,\n\t}\n\n\tbalanceDelta, err := extractBalanceDelta(summary, wireTx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttxDetail.Value = balanceDelta\n\n\treturn txDetail, nil\n}\n\n// ListTransactionDetails returns a list of all transactions which are relevant\n// to the wallet over [startHeight;endHeight]. If start height is greater than\n// end height, the transactions will be retrieved in reverse order. To include\n// unconfirmed transactions, endHeight should be set to the special value -1.\n// This will return transactions from the tip of the chain until the start\n// height (inclusive) and unconfirmed transactions. The account parameter serves\n// as a filter to retrieve the transactions relevant to a specific account. When\n// empty, transactions of all wallet accounts are returned.\n//\n// This is a part of the WalletController interface.",
      "length": 2358,
      "tokens": 285,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) ListTransactionDetails(startHeight, endHeight int32,",
      "content": "func (b *BtcWallet) ListTransactionDetails(startHeight, endHeight int32,\n\taccountFilter string) ([]*lnwallet.TransactionDetail, error) {\n\n\t// Grab the best block the wallet knows of, we'll use this to calculate\n\t// # of confirmations shortly below.\n\tbestBlock := b.wallet.Manager.SyncedTo()\n\tcurrentHeight := bestBlock.Height\n\n\t// We'll attempt to find all transactions from start to end height.\n\tstart := base.NewBlockIdentifierFromHeight(startHeight)\n\tstop := base.NewBlockIdentifierFromHeight(endHeight)\n\ttxns, err := b.wallet.GetTransactions(start, stop, accountFilter, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ttxDetails := make([]*lnwallet.TransactionDetail, 0,\n\t\tlen(txns.MinedTransactions)+len(txns.UnminedTransactions))\n\n\t// For both confirmed and unconfirmed transactions, create a\n\t// TransactionDetail which re-packages the data returned by the base\n\t// wallet.\n\tfor _, blockPackage := range txns.MinedTransactions {\n\t\tdetails, err := minedTransactionsToDetails(\n\t\t\tcurrentHeight, blockPackage, b.netParams,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\ttxDetails = append(txDetails, details...)\n\t}\n\tfor _, tx := range txns.UnminedTransactions {\n\t\tdetail, err := unminedTransactionsToDetail(tx, b.netParams)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\ttxDetails = append(txDetails, detail)\n\t}\n\n\treturn txDetails, nil\n}\n\n// txSubscriptionClient encapsulates the transaction notification client from\n// the base wallet. Notifications received from the client will be proxied over\n// two distinct channels.",
      "length": 1402,
      "tokens": 175,
      "embedding": []
    },
    {
      "slug": "type txSubscriptionClient struct {",
      "content": "type txSubscriptionClient struct {\n\ttxClient base.TransactionNotificationsClient\n\n\tconfirmed   chan *lnwallet.TransactionDetail\n\tunconfirmed chan *lnwallet.TransactionDetail\n\n\tw *base.Wallet\n\n\twg   sync.WaitGroup\n\tquit chan struct{}\n}\n\n// ConfirmedTransactions returns a channel which will be sent on as new\n// relevant transactions are confirmed.\n//\n// This is part of the TransactionSubscription interface.",
      "length": 359,
      "tokens": 42,
      "embedding": []
    },
    {
      "slug": "func (t *txSubscriptionClient) ConfirmedTransactions() chan *lnwallet.TransactionDetail {",
      "content": "func (t *txSubscriptionClient) ConfirmedTransactions() chan *lnwallet.TransactionDetail {\n\treturn t.confirmed\n}\n\n// UnconfirmedTransactions returns a channel which will be sent on as\n// new relevant transactions are seen within the network.\n//\n// This is part of the TransactionSubscription interface.",
      "length": 205,
      "tokens": 32,
      "embedding": []
    },
    {
      "slug": "func (t *txSubscriptionClient) UnconfirmedTransactions() chan *lnwallet.TransactionDetail {",
      "content": "func (t *txSubscriptionClient) UnconfirmedTransactions() chan *lnwallet.TransactionDetail {\n\treturn t.unconfirmed\n}\n\n// Cancel finalizes the subscription, cleaning up any resources allocated.\n//\n// This is part of the TransactionSubscription interface.",
      "length": 155,
      "tokens": 22,
      "embedding": []
    },
    {
      "slug": "func (t *txSubscriptionClient) Cancel() {",
      "content": "func (t *txSubscriptionClient) Cancel() {\n\tclose(t.quit)\n\tt.wg.Wait()\n\n\tt.txClient.Done()\n}\n\n// notificationProxier proxies the notifications received by the underlying\n// wallet's notification client to a higher-level TransactionSubscription\n// client.",
      "length": 203,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (t *txSubscriptionClient) notificationProxier() {",
      "content": "func (t *txSubscriptionClient) notificationProxier() {\n\tdefer t.wg.Done()\n\nout:\n\tfor {\n\t\tselect {\n\t\tcase txNtfn := <-t.txClient.C:\n\t\t\t// TODO(roasbeef): handle detached blocks\n\t\t\tcurrentHeight := t.w.Manager.SyncedTo().Height\n\n\t\t\t// Launch a goroutine to re-package and send\n\t\t\t// notifications for any newly confirmed transactions.\n\t\t\t//nolint:lll\n\t\t\tgo func(txNtfn *wallet.TransactionNotifications) {\n\t\t\t\tfor _, block := range txNtfn.AttachedBlocks {\n\t\t\t\t\tdetails, err := minedTransactionsToDetails(\n\t\t\t\t\t\tcurrentHeight, block,\n\t\t\t\t\t\tt.w.ChainParams(),\n\t\t\t\t\t)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\tfor _, d := range details {\n\t\t\t\t\t\tselect {\n\t\t\t\t\t\tcase t.confirmed <- d:\n\t\t\t\t\t\tcase <-t.quit:\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}(txNtfn)\n\n\t\t\t// Launch a goroutine to re-package and send\n\t\t\t// notifications for any newly unconfirmed transactions.\n\t\t\tgo func(txNtfn *wallet.TransactionNotifications) {\n\t\t\t\tfor _, tx := range txNtfn.UnminedTransactions {\n\t\t\t\t\tdetail, err := unminedTransactionsToDetail(\n\t\t\t\t\t\ttx, t.w.ChainParams(),\n\t\t\t\t\t)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\tselect {\n\t\t\t\t\tcase t.unconfirmed <- detail:\n\t\t\t\t\tcase <-t.quit:\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}(txNtfn)\n\t\tcase <-t.quit:\n\t\t\tbreak out\n\t\t}\n\t}\n}\n\n// SubscribeTransactions returns a TransactionSubscription client which\n// is capable of receiving async notifications as new transactions\n// related to the wallet are seen within the network, or found in\n// blocks.\n//\n// This is a part of the WalletController interface.",
      "length": 1399,
      "tokens": 182,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) SubscribeTransactions() (lnwallet.TransactionSubscription, error) {",
      "content": "func (b *BtcWallet) SubscribeTransactions() (lnwallet.TransactionSubscription, error) {\n\twalletClient := b.wallet.NtfnServer.TransactionNotifications()\n\n\ttxClient := &txSubscriptionClient{\n\t\ttxClient:    walletClient,\n\t\tconfirmed:   make(chan *lnwallet.TransactionDetail),\n\t\tunconfirmed: make(chan *lnwallet.TransactionDetail),\n\t\tw:           b.wallet,\n\t\tquit:        make(chan struct{}),\n\t}\n\ttxClient.wg.Add(1)\n\tgo txClient.notificationProxier()\n\n\treturn txClient, nil\n}\n\n// IsSynced returns a boolean indicating if from the PoV of the wallet, it has\n// fully synced to the current best block in the main chain.\n//\n// This is a part of the WalletController interface.",
      "length": 562,
      "tokens": 64,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) IsSynced() (bool, int64, error) {",
      "content": "func (b *BtcWallet) IsSynced() (bool, int64, error) {\n\t// Grab the best chain state the wallet is currently aware of.\n\tsyncState := b.wallet.Manager.SyncedTo()\n\n\t// We'll also extract the current best wallet timestamp so the caller\n\t// can get an idea of where we are in the sync timeline.\n\tbestTimestamp := syncState.Timestamp.Unix()\n\n\t// Next, query the chain backend to grab the info about the tip of the\n\t// main chain.\n\tbestHash, bestHeight, err := b.cfg.ChainSource.GetBestBlock()\n\tif err != nil {\n\t\treturn false, 0, err\n\t}\n\n\t// Make sure the backing chain has been considered synced first.\n\tif !b.wallet.ChainSynced() {\n\t\tbestHeader, err := b.cfg.ChainSource.GetBlockHeader(bestHash)\n\t\tif err != nil {\n\t\t\treturn false, 0, err\n\t\t}\n\t\tbestTimestamp = bestHeader.Timestamp.Unix()\n\t\treturn false, bestTimestamp, nil\n\t}\n\n\t// If the wallet hasn't yet fully synced to the node's best chain tip,\n\t// then we're not yet fully synced.\n\tif syncState.Height < bestHeight {\n\t\treturn false, bestTimestamp, nil\n\t}\n\n\t// If the wallet is on par with the current best chain tip, then we\n\t// still may not yet be synced as the chain backend may still be\n\t// catching up to the main chain. So we'll grab the block header in\n\t// order to make a guess based on the current time stamp.\n\tblockHeader, err := b.cfg.ChainSource.GetBlockHeader(bestHash)\n\tif err != nil {\n\t\treturn false, 0, err\n\t}\n\n\t// If the timestamp on the best header is more than 2 hours in the\n\t// past, then we're not yet synced.\n\tminus24Hours := time.Now().Add(-2 * time.Hour)\n\tif blockHeader.Timestamp.Before(minus24Hours) {\n\t\treturn false, bestTimestamp, nil\n\t}\n\n\treturn true, bestTimestamp, nil\n}\n\n// GetRecoveryInfo returns a boolean indicating whether the wallet is started\n// in recovery mode. It also returns a float64, ranging from 0 to 1,\n// representing the recovery progress made so far.\n//\n// This is a part of the WalletController interface.",
      "length": 1800,
      "tokens": 295,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) GetRecoveryInfo() (bool, float64, error) {",
      "content": "func (b *BtcWallet) GetRecoveryInfo() (bool, float64, error) {\n\tisRecoveryMode := true\n\tprogress := float64(0)\n\n\t// A zero value in RecoveryWindow indicates there is no trigger of\n\t// recovery mode.\n\tif b.cfg.RecoveryWindow == 0 {\n\t\tisRecoveryMode = false\n\t\treturn isRecoveryMode, progress, nil\n\t}\n\n\t// Query the wallet's birthday block height from db.\n\tvar birthdayBlock waddrmgr.BlockStamp\n\terr := walletdb.View(b.db, func(tx walletdb.ReadTx) error {\n\t\tvar err error\n\t\taddrmgrNs := tx.ReadBucket(waddrmgrNamespaceKey)\n\t\tbirthdayBlock, _, err = b.wallet.Manager.BirthdayBlock(addrmgrNs)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n\n\tif err != nil {\n\t\t// The wallet won't start until the backend is synced, thus the birthday\n\t\t// block won't be set and this particular error will be returned. We'll\n\t\t// catch this error and return a progress of 0 instead.\n\t\tif waddrmgr.IsError(err, waddrmgr.ErrBirthdayBlockNotSet) {\n\t\t\treturn isRecoveryMode, progress, nil\n\t\t}\n\n\t\treturn isRecoveryMode, progress, err\n\t}\n\n\t// Grab the best chain state the wallet is currently aware of.\n\tsyncState := b.wallet.Manager.SyncedTo()\n\n\t// Next, query the chain backend to grab the info about the tip of the\n\t// main chain.\n\t//\n\t// NOTE: The actual recovery process is handled by the btcsuite/btcwallet.\n\t// The process purposefully doesn't update the best height. It might create\n\t// a small difference between the height queried here and the height used\n\t// in the recovery process, ie, the bestHeight used here might be greater,\n\t// showing the recovery being unfinished while it's actually done. However,\n\t// during a wallet rescan after the recovery, the wallet's synced height\n\t// will catch up and this won't be an issue.\n\t_, bestHeight, err := b.cfg.ChainSource.GetBestBlock()\n\tif err != nil {\n\t\treturn isRecoveryMode, progress, err\n\t}\n\n\t// The birthday block height might be greater than the current synced height\n\t// in a newly restored wallet, and might be greater than the chain tip if a\n\t// rollback happens. In that case, we will return zero progress here.\n\tif syncState.Height < birthdayBlock.Height ||\n\t\tbestHeight < birthdayBlock.Height {\n\n\t\treturn isRecoveryMode, progress, nil\n\t}\n\n\t// progress is the ratio of the [number of blocks processed] over the [total\n\t// number of blocks] needed in a recovery mode, ranging from 0 to 1, in\n\t// which,\n\t// - total number of blocks is the current chain's best height minus the\n\t//   wallet's birthday height plus 1.\n\t// - number of blocks processed is the wallet's synced height minus its\n\t//   birthday height plus 1.\n\t// - If the wallet is born very recently, the bestHeight can be equal to\n\t//   the birthdayBlock.Height, and it will recovery instantly.\n\tprogress = float64(syncState.Height-birthdayBlock.Height+1) /\n\t\tfloat64(bestHeight-birthdayBlock.Height+1)\n\n\treturn isRecoveryMode, progress, nil\n}\n\n// FetchTx attempts to fetch a transaction in the wallet's database identified\n// by the passed transaction hash. If the transaction can't be found, then a\n// nil pointer is returned.",
      "length": 2896,
      "tokens": 450,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) FetchTx(txHash chainhash.Hash) (*wire.MsgTx, error) {",
      "content": "func (b *BtcWallet) FetchTx(txHash chainhash.Hash) (*wire.MsgTx, error) {\n\tvar targetTx *wtxmgr.TxDetails\n\terr := walletdb.View(b.db, func(tx walletdb.ReadTx) error {\n\t\twtxmgrNs := tx.ReadBucket(wtxmgrNamespaceKey)\n\t\ttxDetails, err := b.wallet.TxStore.TxDetails(wtxmgrNs, &txHash)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\ttargetTx = txDetails\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif targetTx == nil {\n\t\treturn nil, nil\n\t}\n\n\treturn &targetTx.TxRecord.MsgTx, nil\n}\n\n// RemoveDescendants attempts to remove any transaction from the wallet's tx\n// store (that may be unconfirmed) that spends outputs created by the passed\n// transaction. This remove propagates recursively down the chain of descendent\n// transactions.",
      "length": 633,
      "tokens": 91,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) RemoveDescendants(tx *wire.MsgTx) error {",
      "content": "func (b *BtcWallet) RemoveDescendants(tx *wire.MsgTx) error {\n\ttxRecord, err := wtxmgr.NewTxRecordFromMsgTx(tx, time.Now())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn walletdb.Update(b.db, func(tx walletdb.ReadWriteTx) error {\n\t\twtxmgrNs := tx.ReadWriteBucket(wtxmgrNamespaceKey)\n\t\treturn b.wallet.TxStore.RemoveUnminedTx(wtxmgrNs, txRecord)\n\t})\n}\n",
      "length": 275,
      "tokens": 27,
      "embedding": []
    }
  ]
}