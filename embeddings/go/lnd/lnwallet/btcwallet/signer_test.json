{
  "filepath": "../implementations/go/lnd/lnwallet/btcwallet/signer_test.go",
  "package": "btcwallet",
  "sections": [
    {
      "slug": "func TestBip32KeyDerivation(t *testing.T) {",
      "content": "func TestBip32KeyDerivation(t *testing.T) {\n\tnetParams := &chaincfg.RegressionNetParams\n\tw, _ := newTestWallet(t, netParams, seedBytes)\n\n\t// This is just a sanity check that the wallet was initialized\n\t// correctly. We make sure the first derived address is the expected\n\t// one.\n\tfirstDerivedAddr, err := w.NewAddress(\n\t\tlnwallet.WitnessPubKey, false, lnwallet.DefaultAccountName,\n\t)\n\trequire.NoError(t, err)\n\trequire.Equal(t, firstAddress, firstDerivedAddr.String())\n\n\t// Let's go through the test cases now that we know our wallet is ready.\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tprivKey, err := w.deriveKeyByBIP32Path(tc.path)\n\n\t\t\tif tc.err == \"\" {\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\twif, err := btcutil.NewWIF(\n\t\t\t\t\tprivKey, netParams, true,\n\t\t\t\t)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.Equal(t, tc.wif, wif.String())\n\t\t\t} else {\n\t\t\t\trequire.Error(t, err)\n\t\t\t\trequire.Contains(t, err.Error(), tc.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestScriptImport tests the btcwallet's tapscript import capabilities by\n// importing both a full taproot script tree and a partially revealed branch\n// with a proof to make sure the resulting addresses match up.",
      "length": 1100,
      "tokens": 147,
      "embedding": []
    },
    {
      "slug": "func TestScriptImport(t *testing.T) {",
      "content": "func TestScriptImport(t *testing.T) {\n\tnetParams := &chaincfg.RegressionNetParams\n\tw, miner := newTestWallet(t, netParams, seedBytes)\n\n\tfirstDerivedAddr, err := w.NewAddress(\n\t\tlnwallet.TaprootPubkey, false, lnwallet.DefaultAccountName,\n\t)\n\trequire.NoError(t, err)\n\trequire.Equal(t, firstAddressTaproot, firstDerivedAddr.String())\n\n\tscope := waddrmgr.KeyScopeBIP0086\n\t_, err = w.InternalWallet().Manager.FetchScopedKeyManager(scope)\n\trequire.NoError(t, err)\n\n\t// Let's create a taproot script output now. This is a hash lock with a\n\t// simple preimage of \"foobar\".\n\tbuilder := txscript.NewScriptBuilder()\n\tbuilder.AddOp(txscript.OP_DUP)\n\tbuilder.AddOp(txscript.OP_HASH160)\n\tbuilder.AddData(btcutil.Hash160([]byte(\"foobar\")))\n\tbuilder.AddOp(txscript.OP_EQUALVERIFY)\n\tscript1, err := builder.Script()\n\trequire.NoError(t, err)\n\tleaf1 := txscript.NewBaseTapLeaf(script1)\n\n\t// Let's add a second script output as well to test the partial reveal.\n\tbuilder = txscript.NewScriptBuilder()\n\tbuilder.AddData(schnorr.SerializePubKey(testPubKey))\n\tbuilder.AddOp(txscript.OP_CHECKSIG)\n\tscript2, err := builder.Script()\n\trequire.NoError(t, err)\n\tleaf2 := txscript.NewBaseTapLeaf(script2)\n\n\t// Our first test case is storing the script with all its leaves.\n\ttapscript1 := input.TapscriptFullTree(testPubKey, leaf1, leaf2)\n\n\ttaprootKey1, err := tapscript1.TaprootKey()\n\trequire.NoError(t, err)\n\trequire.Equal(\n\t\tt, testTaprootKey.SerializeCompressed(),\n\t\ttaprootKey1.SerializeCompressed(),\n\t)\n\n\taddr1, err := w.ImportTaprootScript(scope, tapscript1)\n\trequire.NoError(t, err)\n\n\trequire.Equal(t, testTapscriptAddr, addr1.Address().String())\n\tpkScript, err := txscript.PayToAddrScript(addr1.Address())\n\trequire.NoError(t, err)\n\trequire.Equal(t, testTapscriptPkScript, pkScript)\n\n\t// Send some coins to the taproot address now and wait until they are\n\t// seen as unconfirmed.\n\t_, err = miner.SendOutputs([]*wire.TxOut{{\n\t\tValue:    btcutil.SatoshiPerBitcoin,\n\t\tPkScript: pkScript,\n\t}}, 1)\n\trequire.NoError(t, err)\n\n\tvar utxos []*lnwallet.Utxo\n\trequire.Eventually(t, func() bool {\n\t\tutxos, err = w.ListUnspentWitness(0, math.MaxInt32, \"\")\n\t\trequire.NoError(t, err)\n\n\t\treturn len(utxos) == 1\n\t}, time.Minute, 50*time.Millisecond)\n\trequire.Equal(t, testTapscriptPkScript, utxos[0].PkScript)\n\n\t// Now, as a last test, make sure that when we try adding an address\n\t// with partial script reveal, we get an error that the address already\n\t// exists.\n\tinclusionProof := leaf2.TapHash()\n\ttapscript2 := input.TapscriptPartialReveal(\n\t\ttestPubKey, leaf1, inclusionProof[:],\n\t)\n\t_, err = w.ImportTaprootScript(scope, tapscript2)\n\trequire.Error(t, err)\n\trequire.Contains(t, err.Error(), fmt.Sprintf(\n\t\t\"address for script hash/key %x already exists\",\n\t\tschnorr.SerializePubKey(testTaprootKey),\n\t))\n}\n",
      "length": 2648,
      "tokens": 258,
      "embedding": []
    },
    {
      "slug": "func newTestWallet(t *testing.T, netParams *chaincfg.Params,",
      "content": "func newTestWallet(t *testing.T, netParams *chaincfg.Params,\n\tseedBytes []byte) (*BtcWallet, *rpctest.Harness) {\n\n\tchainBackend, miner, backendCleanup := getChainBackend(t, netParams)\n\tt.Cleanup(backendCleanup)\n\n\tloaderOpt := LoaderWithLocalWalletDB(t.TempDir(), false, time.Minute)\n\tconfig := Config{\n\t\tPrivatePass: []byte(\"some-pass\"),\n\t\tHdSeed:      seedBytes,\n\t\tNetParams:   netParams,\n\t\tCoinType:    netParams.HDCoinType,\n\t\tChainSource: chainBackend,\n\t\t// wallet starts in recovery mode\n\t\tRecoveryWindow: 2,\n\t\tLoaderOptions:  []LoaderOption{loaderOpt},\n\t}\n\tblockCache := blockcache.NewBlockCache(10000)\n\tw, err := New(config, blockCache)\n\tif err != nil {\n\t\tt.Fatalf(\"creating wallet failed: %v\", err)\n\t}\n\n\terr = w.Start()\n\tif err != nil {\n\t\tt.Fatalf(\"starting wallet failed: %v\", err)\n\t}\n\n\treturn w, miner\n}\n\n// getChainBackend returns a simple btcd based chain backend to back the wallet.",
      "length": 803,
      "tokens": 91,
      "embedding": []
    },
    {
      "slug": "func getChainBackend(t *testing.T, netParams *chaincfg.Params) (chain.Interface,",
      "content": "func getChainBackend(t *testing.T, netParams *chaincfg.Params) (chain.Interface,\n\t*rpctest.Harness, func()) {\n\n\tminingNode, err := rpctest.New(netParams, nil, nil, \"\")\n\trequire.NoError(t, err)\n\trequire.NoError(t, miningNode.SetUp(true, 25))\n\n\t// Next, mine enough blocks in order for SegWit and the CSV package\n\t// soft-fork to activate on RegNet.\n\tnumBlocks := netParams.MinerConfirmationWindow * 2\n\t_, err = miningNode.Client.Generate(numBlocks)\n\trequire.NoError(t, err)\n\n\trpcConfig := miningNode.RPCConfig()\n\tchainClient, err := chain.NewRPCClient(\n\t\tnetParams, rpcConfig.Host, rpcConfig.User, rpcConfig.Pass,\n\t\trpcConfig.Certificates, false, 20,\n\t)\n\trequire.NoError(t, err)\n\n\treturn chainClient, miningNode, func() {\n\t\t_ = miningNode.TearDown()\n\t}\n}\n\n// hardenedKey returns a key of a hardened derivation key path.",
      "length": 713,
      "tokens": 83,
      "embedding": []
    },
    {
      "slug": "func hardenedKey(part uint32) uint32 {",
      "content": "func hardenedKey(part uint32) uint32 {\n\treturn part + hdkeychain.HardenedKeyStart\n}\n",
      "length": 43,
      "tokens": 5,
      "embedding": []
    }
  ]
}