{
  "filepath": "../implementations/go/lnd/lnwallet/btcwallet/signer.go",
  "package": "btcwallet",
  "sections": [
    {
      "slug": "func (b *BtcWallet) FetchInputInfo(prevOut *wire.OutPoint) (*lnwallet.Utxo,",
      "content": "func (b *BtcWallet) FetchInputInfo(prevOut *wire.OutPoint) (*lnwallet.Utxo,\n\terror) {\n\n\tprevTx, txOut, bip32, confirmations, err := b.wallet.FetchInputInfo(\n\t\tprevOut,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Then, we'll populate all of the information required by the struct.\n\taddressType := lnwallet.UnknownAddressType\n\tswitch {\n\tcase txscript.IsPayToWitnessPubKeyHash(txOut.PkScript):\n\t\taddressType = lnwallet.WitnessPubKey\n\tcase txscript.IsPayToScriptHash(txOut.PkScript):\n\t\taddressType = lnwallet.NestedWitnessPubKey\n\tcase txscript.IsPayToTaproot(txOut.PkScript):\n\t\taddressType = lnwallet.TaprootPubkey\n\t}\n\n\treturn &lnwallet.Utxo{\n\t\tAddressType:   addressType,\n\t\tValue:         btcutil.Amount(txOut.Value),\n\t\tPkScript:      txOut.PkScript,\n\t\tConfirmations: confirmations,\n\t\tOutPoint:      *prevOut,\n\t\tDerivation:    bip32,\n\t\tPrevTx:        prevTx,\n\t}, nil\n}\n\n// ScriptForOutput returns the address, witness program and redeem script for a\n// given UTXO. An error is returned if the UTXO does not belong to our wallet or\n// it is not a managed pubKey address.",
      "length": 959,
      "tokens": 109,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) ScriptForOutput(output *wire.TxOut) (",
      "content": "func (b *BtcWallet) ScriptForOutput(output *wire.TxOut) (\n\twaddrmgr.ManagedPubKeyAddress, []byte, []byte, error) {\n\n\treturn b.wallet.ScriptForOutput(output)\n}\n\n// deriveFromKeyLoc attempts to derive a private key using a fully specified\n// KeyLocator.",
      "length": 187,
      "tokens": 22,
      "embedding": []
    },
    {
      "slug": "func deriveFromKeyLoc(scopedMgr *waddrmgr.ScopedKeyManager,",
      "content": "func deriveFromKeyLoc(scopedMgr *waddrmgr.ScopedKeyManager,\n\taddrmgrNs walletdb.ReadWriteBucket,\n\tkeyLoc keychain.KeyLocator) (*btcec.PrivateKey, error) {\n\n\tpath := waddrmgr.DerivationPath{\n\t\tInternalAccount: uint32(keyLoc.Family),\n\t\tAccount:         uint32(keyLoc.Family),\n\t\tBranch:          0,\n\t\tIndex:           keyLoc.Index,\n\t}\n\taddr, err := scopedMgr.DeriveFromKeyPath(addrmgrNs, path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn addr.(waddrmgr.ManagedPubKeyAddress).PrivKey()\n}\n\n// deriveKeyByBIP32Path derives a key described by a BIP32 path. We expect the\n// first three elements of the path to be hardened according to BIP44, so they\n// must be a number >= 2^31.",
      "length": 595,
      "tokens": 71,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) deriveKeyByBIP32Path(path []uint32) (*btcec.PrivateKey,",
      "content": "func (b *BtcWallet) deriveKeyByBIP32Path(path []uint32) (*btcec.PrivateKey,\n\terror) {\n\n\t// Make sure we get a full path with exactly 5 elements. A path is\n\t// either custom purpose one with 4 dynamic and one static elements:\n\t//    m/1017'/coinType'/keyFamily'/0/index\n\t// Or a default BIP49/89 one with 5 elements:\n\t//    m/purpose'/coinType'/account'/change/index\n\tconst expectedDerivationPathDepth = 5\n\tif len(path) != expectedDerivationPathDepth {\n\t\treturn nil, fmt.Errorf(\"invalid BIP32 derivation path, \"+\n\t\t\t\"expected path length %d, instead was %d\",\n\t\t\texpectedDerivationPathDepth, len(path))\n\t}\n\n\t// Assert that the first three parts of the path are actually hardened\n\t// to avoid under-flowing the uint32 type.\n\tif err := assertHardened(path[0], path[1], path[2]); err != nil {\n\t\treturn nil, fmt.Errorf(\"invalid BIP32 derivation path, \"+\n\t\t\t\"expected first three elements to be hardened: %w\", err)\n\t}\n\n\tpurpose := path[0] - hdkeychain.HardenedKeyStart\n\tcoinType := path[1] - hdkeychain.HardenedKeyStart\n\taccount := path[2] - hdkeychain.HardenedKeyStart\n\tchange, index := path[3], path[4]\n\n\t// Is this a custom lnd internal purpose key?\n\tswitch purpose {\n\tcase keychain.BIP0043Purpose:\n\t\t// Make sure it's for the same coin type as our wallet's\n\t\t// keychain scope.\n\t\tif coinType != b.chainKeyScope.Coin {\n\t\t\treturn nil, fmt.Errorf(\"invalid BIP32 derivation \"+\n\t\t\t\t\"path, expected coin type %d, instead was %d\",\n\t\t\t\tb.chainKeyScope.Coin, coinType)\n\t\t}\n\n\t\treturn b.deriveKeyByLocator(keychain.KeyLocator{\n\t\t\tFamily: keychain.KeyFamily(account),\n\t\t\tIndex:  index,\n\t\t})\n\n\t// Is it a standard, BIP defined purpose that the wallet understands?\n\tcase waddrmgr.KeyScopeBIP0044.Purpose,\n\t\twaddrmgr.KeyScopeBIP0049Plus.Purpose,\n\t\twaddrmgr.KeyScopeBIP0084.Purpose,\n\t\twaddrmgr.KeyScopeBIP0086.Purpose:\n\n\t\t// We're going to continue below the switch statement to avoid\n\t\t// unnecessary indentation for this default case.\n\n\t// Currently, there is no way to import any other key scopes than the\n\t// one custom purpose or three standard ones into lnd's wallet. So we\n\t// shouldn't accept any other scopes to sign for.\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"invalid BIP32 derivation path, \"+\n\t\t\t\"unknown purpose %d\", purpose)\n\t}\n\n\t// Okay, we made sure it's a BIP49/84 key, so we need to derive it now.\n\t// Interestingly, the btcwallet never actually uses a coin type other\n\t// than 0 for those keys, so we need to make sure this behavior is\n\t// replicated here.\n\tif coinType != 0 {\n\t\treturn nil, fmt.Errorf(\"invalid BIP32 derivation path, coin \" +\n\t\t\t\"type must be 0 for BIP49/84 btcwallet keys\")\n\t}\n\n\t// We only expect to be asked to sign with key scopes that we know\n\t// about. So if the scope doesn't exist, we don't create it.\n\tscope := waddrmgr.KeyScope{\n\t\tPurpose: purpose,\n\t\tCoin:    coinType,\n\t}\n\tscopedMgr, err := b.wallet.Manager.FetchScopedKeyManager(scope)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error fetching manager for scope %v: \"+\n\t\t\t\"%w\", scope, err)\n\t}\n\n\t// Let's see if we can hit the private key cache.\n\tkeyPath := waddrmgr.DerivationPath{\n\t\tInternalAccount: account,\n\t\tAccount:         account,\n\t\tBranch:          change,\n\t\tIndex:           index,\n\t}\n\tprivKey, err := scopedMgr.DeriveFromKeyPathCache(keyPath)\n\tif err == nil {\n\t\treturn privKey, nil\n\t}\n\n\t// The key wasn't in the cache, let's fully derive it now.\n\terr = walletdb.View(b.db, func(tx walletdb.ReadTx) error {\n\t\taddrmgrNs := tx.ReadBucket(waddrmgrNamespaceKey)\n\n\t\taddr, err := scopedMgr.DeriveFromKeyPath(addrmgrNs, keyPath)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error deriving private key: %w\", err)\n\t\t}\n\n\t\tprivKey, err = addr.(waddrmgr.ManagedPubKeyAddress).PrivKey()\n\t\treturn err\n\t})\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error deriving key from path %#v: %w\",\n\t\t\tkeyPath, err)\n\t}\n\n\treturn privKey, nil\n}\n\n// assertHardened makes sure each given element is >= 2^31.",
      "length": 3667,
      "tokens": 516,
      "embedding": []
    },
    {
      "slug": "func assertHardened(elements ...uint32) error {",
      "content": "func assertHardened(elements ...uint32) error {\n\tfor idx, element := range elements {\n\t\tif element < hdkeychain.HardenedKeyStart {\n\t\t\treturn fmt.Errorf(\"element at index %d is not hardened\",\n\t\t\t\tidx)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// deriveKeyByLocator attempts to derive a key stored in the wallet given a\n// valid key locator.",
      "length": 261,
      "tokens": 43,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) deriveKeyByLocator(",
      "content": "func (b *BtcWallet) deriveKeyByLocator(\n\tkeyLoc keychain.KeyLocator) (*btcec.PrivateKey, error) {\n\n\t// We'll assume the special lightning key scope in this case.\n\tscopedMgr, err := b.wallet.Manager.FetchScopedKeyManager(\n\t\tb.chainKeyScope,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// First try to read the key from the cached store, if this fails, then\n\t// we'll fall through to the method below that requires a database\n\t// transaction.\n\tpath := waddrmgr.DerivationPath{\n\t\tInternalAccount: uint32(keyLoc.Family),\n\t\tAccount:         uint32(keyLoc.Family),\n\t\tBranch:          0,\n\t\tIndex:           keyLoc.Index,\n\t}\n\tprivKey, err := scopedMgr.DeriveFromKeyPathCache(path)\n\tif err == nil {\n\t\treturn privKey, nil\n\t}\n\n\tvar key *btcec.PrivateKey\n\terr = walletdb.Update(b.db, func(tx walletdb.ReadWriteTx) error {\n\t\taddrmgrNs := tx.ReadWriteBucket(waddrmgrNamespaceKey)\n\n\t\tkey, err = deriveFromKeyLoc(scopedMgr, addrmgrNs, keyLoc)\n\t\tif waddrmgr.IsError(err, waddrmgr.ErrAccountNotFound) {\n\t\t\t// If we've reached this point, then the account\n\t\t\t// doesn't yet exist, so we'll create it now to ensure\n\t\t\t// we can sign.\n\t\t\tacctErr := scopedMgr.NewRawAccount(\n\t\t\t\taddrmgrNs, uint32(keyLoc.Family),\n\t\t\t)\n\t\t\tif acctErr != nil {\n\t\t\t\treturn acctErr\n\t\t\t}\n\n\t\t\t// Now that we know the account exists, we'll attempt\n\t\t\t// to re-derive the private key.\n\t\t\tkey, err = deriveFromKeyLoc(\n\t\t\t\tscopedMgr, addrmgrNs, keyLoc,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\treturn err\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn key, nil\n}\n\n// fetchPrivKey attempts to retrieve the raw private key corresponding to the\n// passed public key if populated, or the key descriptor path (if non-empty).",
      "length": 1582,
      "tokens": 220,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) fetchPrivKey(",
      "content": "func (b *BtcWallet) fetchPrivKey(\n\tkeyDesc *keychain.KeyDescriptor) (*btcec.PrivateKey, error) {\n\n\t// If the key locator within the descriptor *isn't* empty, then we can\n\t// directly derive the keys raw.\n\temptyLocator := keyDesc.KeyLocator.IsEmpty()\n\tif !emptyLocator || keyDesc.PubKey == nil {\n\t\treturn b.deriveKeyByLocator(keyDesc.KeyLocator)\n\t}\n\n\thash160 := btcutil.Hash160(keyDesc.PubKey.SerializeCompressed())\n\taddr, err := btcutil.NewAddressWitnessPubKeyHash(hash160, b.netParams)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Otherwise, we'll attempt to derive the key based on the address.\n\t// This will only work if we've already derived this address in the\n\t// past, since the wallet relies on a mapping of addr -> key.\n\tkey, err := b.wallet.PrivKeyForAddress(addr)\n\tswitch {\n\t// If we didn't find this key in the wallet, then there's a chance that\n\t// this is actually an \"empty\" key locator. The legacy KeyLocator\n\t// format failed to properly distinguish an empty key locator from the\n\t// very first in the index (0, 0).IsEmpty() == true.\n\tcase waddrmgr.IsError(err, waddrmgr.ErrAddressNotFound) && emptyLocator:\n\t\treturn b.deriveKeyByLocator(keyDesc.KeyLocator)\n\n\tcase err != nil:\n\t\treturn nil, err\n\n\tdefault:\n\t\treturn key, nil\n\t}\n}\n\n// maybeTweakPrivKey examines the single and double tweak parameters on the\n// passed sign descriptor and may perform a mapping on the passed private key\n// in order to utilize the tweaks, if populated.",
      "length": 1376,
      "tokens": 200,
      "embedding": []
    },
    {
      "slug": "func maybeTweakPrivKey(signDesc *input.SignDescriptor,",
      "content": "func maybeTweakPrivKey(signDesc *input.SignDescriptor,\n\tprivKey *btcec.PrivateKey) (*btcec.PrivateKey, error) {\n\n\tvar retPriv *btcec.PrivateKey\n\tswitch {\n\n\tcase signDesc.SingleTweak != nil:\n\t\tretPriv = input.TweakPrivKey(privKey,\n\t\t\tsignDesc.SingleTweak)\n\n\tcase signDesc.DoubleTweak != nil:\n\t\tretPriv = input.DeriveRevocationPrivKey(privKey,\n\t\t\tsignDesc.DoubleTweak)\n\n\tdefault:\n\t\tretPriv = privKey\n\t}\n\n\treturn retPriv, nil\n}\n\n// SignOutputRaw generates a signature for the passed transaction according to\n// the data within the passed SignDescriptor.\n//\n// This is a part of the WalletController interface.",
      "length": 528,
      "tokens": 63,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) SignOutputRaw(tx *wire.MsgTx,",
      "content": "func (b *BtcWallet) SignOutputRaw(tx *wire.MsgTx,\n\tsignDesc *input.SignDescriptor) (input.Signature, error) {\n\n\twitnessScript := signDesc.WitnessScript\n\n\t// First attempt to fetch the private key which corresponds to the\n\t// specified public key.\n\tprivKey, err := b.fetchPrivKey(&signDesc.KeyDesc)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// If a tweak (single or double) is specified, then we'll need to use\n\t// this tweak to derive the final private key to be used for signing\n\t// this output.\n\tprivKey, err = maybeTweakPrivKey(signDesc, privKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// In case of a taproot output any signature is always a Schnorr\n\t// signature, based on the new tapscript sighash algorithm.\n\tif txscript.IsPayToTaproot(signDesc.Output.PkScript) {\n\t\tsigHashes := txscript.NewTxSigHashes(\n\t\t\ttx, signDesc.PrevOutputFetcher,\n\t\t)\n\n\t\t// Are we spending a script path or the key path? The API is\n\t\t// slightly different, so we need to account for that to get the\n\t\t// raw signature.\n\t\tvar rawSig []byte\n\t\tswitch signDesc.SignMethod {\n\t\tcase input.TaprootKeySpendBIP0086SignMethod,\n\t\t\tinput.TaprootKeySpendSignMethod:\n\n\t\t\t// This function tweaks the private key using the tap\n\t\t\t// root key supplied as the tweak.\n\t\t\trawSig, err = txscript.RawTxInTaprootSignature(\n\t\t\t\ttx, sigHashes, signDesc.InputIndex,\n\t\t\t\tsignDesc.Output.Value, signDesc.Output.PkScript,\n\t\t\t\tsignDesc.TapTweak, signDesc.HashType,\n\t\t\t\tprivKey,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\tcase input.TaprootScriptSpendSignMethod:\n\t\t\tleaf := txscript.TapLeaf{\n\t\t\t\tLeafVersion: txscript.BaseLeafVersion,\n\t\t\t\tScript:      witnessScript,\n\t\t\t}\n\t\t\trawSig, err = txscript.RawTxInTapscriptSignature(\n\t\t\t\ttx, sigHashes, signDesc.InputIndex,\n\t\t\t\tsignDesc.Output.Value, signDesc.Output.PkScript,\n\t\t\t\tleaf, signDesc.HashType, privKey,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"unknown sign method: %v\",\n\t\t\t\tsignDesc.SignMethod)\n\t\t}\n\n\t\t// The signature returned above might have a sighash flag\n\t\t// attached if a non-default type was used. We'll slice this\n\t\t// off if it exists to ensure we can properly parse the raw\n\t\t// signature.\n\t\tsig, err := schnorr.ParseSignature(\n\t\t\trawSig[:schnorr.SignatureSize],\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn sig, nil\n\t}\n\n\t// TODO(roasbeef): generate sighash midstate if not present?\n\n\tamt := signDesc.Output.Value\n\tsig, err := txscript.RawTxInWitnessSignature(\n\t\ttx, signDesc.SigHashes, signDesc.InputIndex, amt,\n\t\twitnessScript, signDesc.HashType, privKey,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Chop off the sighash flag at the end of the signature.\n\treturn ecdsa.ParseDERSignature(sig[:len(sig)-1])\n}\n\n// ComputeInputScript generates a complete InputScript for the passed\n// transaction with the signature as defined within the passed SignDescriptor.\n// This method is capable of generating the proper input script for both\n// regular p2wkh output and p2wkh outputs nested within a regular p2sh output.\n//\n// This is a part of the WalletController interface.",
      "length": 2899,
      "tokens": 390,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) ComputeInputScript(tx *wire.MsgTx,",
      "content": "func (b *BtcWallet) ComputeInputScript(tx *wire.MsgTx,\n\tsignDesc *input.SignDescriptor) (*input.Script, error) {\n\n\t// If a tweak (single or double) is specified, then we'll need to use\n\t// this tweak to derive the final private key to be used for signing\n\t// this output.\n\tprivKeyTweaker := func(k *btcec.PrivateKey) (*btcec.PrivateKey, error) {\n\t\treturn maybeTweakPrivKey(signDesc, k)\n\t}\n\n\t// Let the wallet compute the input script now.\n\twitness, sigScript, err := b.wallet.ComputeInputScript(\n\t\ttx, signDesc.Output, signDesc.InputIndex, signDesc.SigHashes,\n\t\tsignDesc.HashType, privKeyTweaker,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &input.Script{\n\t\tWitness:   witness,\n\t\tSigScript: sigScript,\n\t}, nil\n}\n\n// muSig2State is a struct that holds on to the internal signing session state\n// of a MuSig2 session.",
      "length": 741,
      "tokens": 105,
      "embedding": []
    },
    {
      "slug": "type muSig2State struct {",
      "content": "type muSig2State struct {\n\t// MuSig2SessionInfo is the associated meta information of the signing\n\t// session.\n\tinput.MuSig2SessionInfo\n\n\t// context is the signing context responsible for keeping track of the\n\t// public keys involved in the signing process.\n\tcontext input.MuSig2Context\n\n\t// session is the signing session responsible for keeping track of the\n\t// nonces and partial signatures involved in the signing process.\n\tsession input.MuSig2Session\n}\n\n// MuSig2CreateSession creates a new MuSig2 signing session using the local\n// key identified by the key locator. The complete list of all public keys of\n// all signing parties must be provided, including the public key of the local\n// signing key. If nonces of other parties are already known, they can be\n// submitted as well to reduce the number of method calls necessary later on.",
      "length": 800,
      "tokens": 128,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) MuSig2CreateSession(bipVersion input.MuSig2Version,",
      "content": "func (b *BtcWallet) MuSig2CreateSession(bipVersion input.MuSig2Version,\n\tkeyLoc keychain.KeyLocator, allSignerPubKeys []*btcec.PublicKey,\n\ttweaks *input.MuSig2Tweaks,\n\totherSignerNonces [][musig2.PubNonceSize]byte) (*input.MuSig2SessionInfo,\n\terror) {\n\n\t// We need to derive the private key for signing. In the remote signing\n\t// setup, this whole RPC call will be forwarded to the signing\n\t// instance, which requires it to be stateful.\n\tprivKey, err := b.fetchPrivKey(&keychain.KeyDescriptor{\n\t\tKeyLocator: keyLoc,\n\t})\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error deriving private key: %w\", err)\n\t}\n\n\t// Create a signing context and session with the given private key and\n\t// list of all known signer public keys.\n\tmuSigContext, muSigSession, err := input.MuSig2CreateContext(\n\t\tbipVersion, privKey, allSignerPubKeys, tweaks,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error creating signing context: %w\",\n\t\t\terr)\n\t}\n\n\t// Add all nonces we might've learned so far.\n\thaveAllNonces := false\n\tfor _, otherSignerNonce := range otherSignerNonces {\n\t\thaveAllNonces, err = muSigSession.RegisterPubNonce(\n\t\t\totherSignerNonce,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"error registering other \"+\n\t\t\t\t\"signer public nonce: %w\", err)\n\t\t}\n\t}\n\n\t// Register the new session.\n\tcombinedKey, err := muSigContext.CombinedKey()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error getting combined key: %w\", err)\n\t}\n\tsession := &muSig2State{\n\t\tMuSig2SessionInfo: input.MuSig2SessionInfo{\n\t\t\tSessionID: input.NewMuSig2SessionID(\n\t\t\t\tcombinedKey, muSigSession.PublicNonce(),\n\t\t\t),\n\t\t\tVersion:       bipVersion,\n\t\t\tPublicNonce:   muSigSession.PublicNonce(),\n\t\t\tCombinedKey:   combinedKey,\n\t\t\tTaprootTweak:  tweaks.HasTaprootTweak(),\n\t\t\tHaveAllNonces: haveAllNonces,\n\t\t},\n\t\tcontext: muSigContext,\n\t\tsession: muSigSession,\n\t}\n\n\t// The internal key is only calculated if we are using a taproot tweak\n\t// and need to know it for a potential script spend.\n\tif tweaks.HasTaprootTweak() {\n\t\tinternalKey, err := muSigContext.TaprootInternalKey()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"error getting internal key: %w\",\n\t\t\t\terr)\n\t\t}\n\t\tsession.TaprootInternalKey = internalKey\n\t}\n\n\t// Since we generate new nonces for every session, there is no way that\n\t// a session with the same ID already exists. So even if we call the API\n\t// twice with the same signers, we still get a new ID.\n\tb.musig2SessionsMtx.Lock()\n\tb.musig2Sessions[session.SessionID] = session\n\tb.musig2SessionsMtx.Unlock()\n\n\treturn &session.MuSig2SessionInfo, nil\n}\n\n// MuSig2RegisterNonces registers one or more public nonces of other signing\n// participants for a session identified by its ID. This method returns true\n// once we have all nonces for all other signing participants.",
      "length": 2582,
      "tokens": 339,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) MuSig2RegisterNonces(sessionID input.MuSig2SessionID,",
      "content": "func (b *BtcWallet) MuSig2RegisterNonces(sessionID input.MuSig2SessionID,\n\totherSignerNonces [][musig2.PubNonceSize]byte) (bool, error) {\n\n\t// We hold the lock during the whole operation, we don't want any\n\t// interference with calls that might come through in parallel for the\n\t// same session.\n\tb.musig2SessionsMtx.Lock()\n\tdefer b.musig2SessionsMtx.Unlock()\n\n\tsession, ok := b.musig2Sessions[sessionID]\n\tif !ok {\n\t\treturn false, fmt.Errorf(\"session with ID %x not found\",\n\t\t\tsessionID[:])\n\t}\n\n\t// Make sure we don't exceed the number of expected nonces as that would\n\t// indicate something is wrong with the signing setup.\n\tif session.HaveAllNonces {\n\t\treturn true, fmt.Errorf(\"already have all nonces\")\n\t}\n\n\tnumSigners := len(session.context.SigningKeys())\n\tremainingNonces := numSigners - session.session.NumRegisteredNonces()\n\tif len(otherSignerNonces) > remainingNonces {\n\t\treturn false, fmt.Errorf(\"only %d other nonces remaining but \"+\n\t\t\t\"trying to register %d more\", remainingNonces,\n\t\t\tlen(otherSignerNonces))\n\t}\n\n\t// Add all nonces we've learned so far.\n\tvar err error\n\tfor _, otherSignerNonce := range otherSignerNonces {\n\t\tsession.HaveAllNonces, err = session.session.RegisterPubNonce(\n\t\t\totherSignerNonce,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn false, fmt.Errorf(\"error registering other \"+\n\t\t\t\t\"signer public nonce: %w\", err)\n\t\t}\n\t}\n\n\treturn session.HaveAllNonces, nil\n}\n\n// MuSig2Sign creates a partial signature using the local signing key\n// that was specified when the session was created. This can only be\n// called when all public nonces of all participants are known and have\n// been registered with the session. If this node isn't responsible for\n// combining all the partial signatures, then the cleanup parameter\n// should be set, indicating that the session can be removed from memory\n// once the signature was produced.",
      "length": 1717,
      "tokens": 240,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) MuSig2Sign(sessionID input.MuSig2SessionID,",
      "content": "func (b *BtcWallet) MuSig2Sign(sessionID input.MuSig2SessionID,\n\tmsg [sha256.Size]byte, cleanUp bool) (*musig2.PartialSignature, error) {\n\n\t// We hold the lock during the whole operation, we don't want any\n\t// interference with calls that might come through in parallel for the\n\t// same session.\n\tb.musig2SessionsMtx.Lock()\n\tdefer b.musig2SessionsMtx.Unlock()\n\n\tsession, ok := b.musig2Sessions[sessionID]\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"session with ID %x not found\",\n\t\t\tsessionID[:])\n\t}\n\n\t// We can only sign once we have all other signer's nonces.\n\tif !session.HaveAllNonces {\n\t\treturn nil, fmt.Errorf(\"only have %d of %d required nonces\",\n\t\t\tsession.session.NumRegisteredNonces(),\n\t\t\tlen(session.context.SigningKeys()))\n\t}\n\n\t// Create our own partial signature with the local signing key.\n\tpartialSig, err := input.MuSig2Sign(session.session, msg, true)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error signing with local key: %w\", err)\n\t}\n\n\t// Clean up our local state if requested.\n\tif cleanUp {\n\t\tdelete(b.musig2Sessions, sessionID)\n\t}\n\n\treturn partialSig, nil\n}\n\n// MuSig2CombineSig combines the given partial signature(s) with the\n// local one, if it already exists. Once a partial signature of all\n// participants is registered, the final signature will be combined and\n// returned.",
      "length": 1193,
      "tokens": 167,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) MuSig2CombineSig(sessionID input.MuSig2SessionID,",
      "content": "func (b *BtcWallet) MuSig2CombineSig(sessionID input.MuSig2SessionID,\n\tpartialSigs []*musig2.PartialSignature) (*schnorr.Signature, bool,\n\terror) {\n\n\t// We hold the lock during the whole operation, we don't want any\n\t// interference with calls that might come through in parallel for the\n\t// same session.\n\tb.musig2SessionsMtx.Lock()\n\tdefer b.musig2SessionsMtx.Unlock()\n\n\tsession, ok := b.musig2Sessions[sessionID]\n\tif !ok {\n\t\treturn nil, false, fmt.Errorf(\"session with ID %x not found\",\n\t\t\tsessionID[:])\n\t}\n\n\t// Make sure we don't exceed the number of expected partial signatures\n\t// as that would indicate something is wrong with the signing setup.\n\tif session.HaveAllSigs {\n\t\treturn nil, true, fmt.Errorf(\"already have all partial\" +\n\t\t\t\"signatures\")\n\t}\n\n\t// Add all sigs we got so far.\n\tvar (\n\t\tfinalSig *schnorr.Signature\n\t\terr      error\n\t)\n\tfor _, otherPartialSig := range partialSigs {\n\t\tsession.HaveAllSigs, err = input.MuSig2CombineSig(\n\t\t\tsession.session, otherPartialSig,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, false, fmt.Errorf(\"error combining \"+\n\t\t\t\t\"partial signature: %w\", err)\n\t\t}\n\t}\n\n\t// If we have all partial signatures, we should be able to get the\n\t// complete signature now. We also remove this session from memory since\n\t// there is nothing more left to do.\n\tif session.HaveAllSigs {\n\t\tfinalSig = session.session.FinalSig()\n\t\tdelete(b.musig2Sessions, sessionID)\n\t}\n\n\treturn finalSig, session.HaveAllSigs, nil\n}\n\n// MuSig2Cleanup removes a session from memory to free up resources.",
      "length": 1386,
      "tokens": 197,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) MuSig2Cleanup(sessionID input.MuSig2SessionID) error {",
      "content": "func (b *BtcWallet) MuSig2Cleanup(sessionID input.MuSig2SessionID) error {\n\t// We hold the lock during the whole operation, we don't want any\n\t// interference with calls that might come through in parallel for the\n\t// same session.\n\tb.musig2SessionsMtx.Lock()\n\tdefer b.musig2SessionsMtx.Unlock()\n\n\t_, ok := b.musig2Sessions[sessionID]\n\tif !ok {\n\t\treturn fmt.Errorf(\"session with ID %x not found\", sessionID[:])\n\t}\n\n\tdelete(b.musig2Sessions, sessionID)\n\n\treturn nil\n}\n\n// A compile time check to ensure that BtcWallet implements the Signer\n// interface.\nvar _ input.Signer = (*BtcWallet)(nil)\n\n// SignMessage attempts to sign a target message with the private key that\n// corresponds to the passed key locator. If the target private key is unable to\n// be found, then an error will be returned. The actual digest signed is the\n// double SHA-256 of the passed message.\n//\n// NOTE: This is a part of the MessageSigner interface.",
      "length": 825,
      "tokens": 132,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) SignMessage(keyLoc keychain.KeyLocator,",
      "content": "func (b *BtcWallet) SignMessage(keyLoc keychain.KeyLocator,\n\tmsg []byte, doubleHash bool) (*ecdsa.Signature, error) {\n\n\t// First attempt to fetch the private key which corresponds to the\n\t// specified public key.\n\tprivKey, err := b.fetchPrivKey(&keychain.KeyDescriptor{\n\t\tKeyLocator: keyLoc,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Double hash and sign the data.\n\tvar msgDigest []byte\n\tif doubleHash {\n\t\tmsgDigest = chainhash.DoubleHashB(msg)\n\t} else {\n\t\tmsgDigest = chainhash.HashB(msg)\n\t}\n\treturn ecdsa.Sign(privKey, msgDigest), nil\n}\n\n// A compile time check to ensure that BtcWallet implements the MessageSigner\n// interface.\nvar _ lnwallet.MessageSigner = (*BtcWallet)(nil)\n",
      "length": 602,
      "tokens": 86,
      "embedding": []
    }
  ]
}