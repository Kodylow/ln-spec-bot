{
  "filepath": "../implementations/go/lnd/lnwallet/btcwallet/psbt.go",
  "package": "btcwallet",
  "sections": [
    {
      "slug": "func (b *BtcWallet) FundPsbt(packet *psbt.Packet, minConfs int32,",
      "content": "func (b *BtcWallet) FundPsbt(packet *psbt.Packet, minConfs int32,\n\tfeeRate chainfee.SatPerKWeight, accountName string,\n\tchangeScope *waddrmgr.KeyScope) (int32, error) {\n\n\t// The fee rate is passed in using units of sat/kw, so we'll convert\n\t// this to sat/KB as the CreateSimpleTx method requires this unit.\n\tfeeSatPerKB := btcutil.Amount(feeRate.FeePerKVByte())\n\n\tvar (\n\t\tkeyScope   *waddrmgr.KeyScope\n\t\taccountNum uint32\n\t)\n\n\tswitch accountName {\n\t// For default accounts and single imported public keys, we'll provide a\n\t// nil key scope to FundPsbt, allowing it to select nputs from all\n\t// scopes (NP2WKH, P2WKH, P2TR). By default, the change key scope for\n\t// these accounts will be P2WKH.\n\tcase lnwallet.DefaultAccountName:\n\t\tif changeScope == nil {\n\t\t\tchangeScope = &waddrmgr.KeyScopeBIP0084\n\t\t}\n\n\t\taccountNum = defaultAccount\n\n\tcase waddrmgr.ImportedAddrAccountName:\n\t\tif changeScope == nil {\n\t\t\tchangeScope = &waddrmgr.KeyScopeBIP0084\n\t\t}\n\n\t\taccountNum = importedAccount\n\n\t// Otherwise, map the account name to its key scope and internal account\n\t// number to only select inputs from said account. No change key scope\n\t// should have been specified as a custom account should only have one\n\t// key scope. Providing a change key scope would break this assumption\n\t// and lead to non-deterministic behavior by using a different change\n\t// key scope than the custom account key scope. The change key scope\n\t// will always be the same as the coin selection.\n\tdefault:\n\t\tif changeScope != nil {\n\t\t\treturn 0, fmt.Errorf(\"couldn't select a \" +\n\t\t\t\t\"custom change type for custom accounts\")\n\t\t}\n\n\t\tscope, account, err := b.wallet.LookupAccount(accountName)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tkeyScope = &scope\n\t\tchangeScope = keyScope\n\t\taccountNum = account\n\t}\n\n\tvar opts []wallet.TxCreateOption\n\tif changeScope != nil {\n\t\topts = append(opts, wallet.WithCustomChangeScope(changeScope))\n\t}\n\n\t// Let the wallet handle coin selection and/or fee estimation based on\n\t// the partial TX information in the packet.\n\treturn b.wallet.FundPsbt(\n\t\tpacket, keyScope, minConfs, accountNum, feeSatPerKB,\n\t\tb.cfg.CoinSelectionStrategy, opts...,\n\t)\n}\n\n// SignPsbt expects a partial transaction with all inputs and outputs fully\n// declared and tries to sign all unsigned inputs that have all required fields\n// (UTXO information, BIP32 derivation information, witness or sig scripts) set.\n// If no error is returned, the PSBT is ready to be given to the next signer or\n// to be finalized if lnd was the last signer.\n//\n// NOTE: This method only signs inputs (and only those it can sign), it does not\n// perform any other tasks (such as coin selection, UTXO locking or\n// input/output/fee value validation, PSBT finalization). Any input that is\n// incomplete will be skipped.",
      "length": 2625,
      "tokens": 400,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) SignPsbt(packet *psbt.Packet) ([]uint32, error) {",
      "content": "func (b *BtcWallet) SignPsbt(packet *psbt.Packet) ([]uint32, error) {\n\t// In signedInputs we return the indices of psbt inputs that were signed\n\t// by our wallet. This way the caller can check if any inputs were signed.\n\tvar signedInputs []uint32\n\n\t// Let's check that this is actually something we can and want to sign.\n\t// We need at least one input and one output.\n\terr := psbt.VerifyInputOutputLen(packet, true, true)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Go through each input that doesn't have final witness data attached\n\t// to it already and try to sign it. If there is nothing more to sign or\n\t// there are inputs that we don't know how to sign, we won't return any\n\t// error. So it's possible we're not the final signer.\n\ttx := packet.UnsignedTx\n\tprevOutputFetcher := wallet.PsbtPrevOutputFetcher(packet)\n\tsigHashes := txscript.NewTxSigHashes(tx, prevOutputFetcher)\n\tfor idx := range tx.TxIn {\n\t\tin := &packet.Inputs[idx]\n\n\t\t// We can only sign if we have UTXO information available. Since\n\t\t// we don't finalize, we just skip over any input that we know\n\t\t// we can't do anything with. Since we only support signing\n\t\t// witness inputs, we only look at the witness UTXO being set.\n\t\tif in.WitnessUtxo == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Skip this input if it's got final witness data attached.\n\t\tif len(in.FinalScriptWitness) > 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Skip this input if there is no BIP32 derivation info\n\t\t// available.\n\t\tif len(in.Bip32Derivation) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// TODO(guggero): For multisig, we'll need to find out what key\n\t\t// to use and there should be multiple derivation paths in the\n\t\t// BIP32 derivation field.\n\n\t\t// Let's try and derive the key now. This method will decide if\n\t\t// it's a BIP49/84 key for normal on-chain funds or a key of the\n\t\t// custom purpose 1017 key scope.\n\t\tderivationInfo := in.Bip32Derivation[0]\n\t\tprivKey, err := b.deriveKeyByBIP32Path(derivationInfo.Bip32Path)\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"SignPsbt: Skipping input %d, error \"+\n\t\t\t\t\"deriving signing key: %v\", idx, err)\n\t\t\tcontinue\n\t\t}\n\n\t\t// We need to make sure we actually derived the key that was\n\t\t// expected to be derived.\n\t\tpubKeysEqual := bytes.Equal(\n\t\t\tderivationInfo.PubKey,\n\t\t\tprivKey.PubKey().SerializeCompressed(),\n\t\t)\n\t\tif !pubKeysEqual {\n\t\t\tlog.Warnf(\"SignPsbt: Skipping input %d, derived \"+\n\t\t\t\t\"public key %x does not match bip32 \"+\n\t\t\t\t\"derivation info public key %x\", idx,\n\t\t\t\tprivKey.PubKey().SerializeCompressed(),\n\t\t\t\tderivationInfo.PubKey)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Do we need to tweak anything? Single or double tweaks are\n\t\t// sent as custom/proprietary fields in the PSBT input section.\n\t\tprivKey = maybeTweakPrivKeyPsbt(in.Unknowns, privKey)\n\n\t\t// What kind of signature is expected from us and do we have all\n\t\t// information we need?\n\t\tsignMethod, err := validateSigningMethod(in)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tswitch signMethod {\n\t\t// For p2wkh, np2wkh and p2wsh.\n\t\tcase input.WitnessV0SignMethod:\n\t\t\terr = signSegWitV0(in, tx, sigHashes, idx, privKey)\n\n\t\t// For p2tr BIP0086 key spend only.\n\t\tcase input.TaprootKeySpendBIP0086SignMethod:\n\t\t\trootHash := make([]byte, 0)\n\t\t\terr = signSegWitV1KeySpend(\n\t\t\t\tin, tx, sigHashes, idx, privKey, rootHash,\n\t\t\t)\n\n\t\t// For p2tr with script commitment key spend path.\n\t\tcase input.TaprootKeySpendSignMethod:\n\t\t\trootHash := in.TaprootMerkleRoot\n\t\t\terr = signSegWitV1KeySpend(\n\t\t\t\tin, tx, sigHashes, idx, privKey, rootHash,\n\t\t\t)\n\n\t\t// For p2tr script spend path.\n\t\tcase input.TaprootScriptSpendSignMethod:\n\t\t\tleafScript := in.TaprootLeafScript[0]\n\t\t\tleaf := txscript.TapLeaf{\n\t\t\t\tLeafVersion: leafScript.LeafVersion,\n\t\t\t\tScript:      leafScript.Script,\n\t\t\t}\n\t\t\terr = signSegWitV1ScriptSpend(\n\t\t\t\tin, tx, sigHashes, idx, privKey, leaf,\n\t\t\t)\n\n\t\tdefault:\n\t\t\terr = fmt.Errorf(\"unsupported signing method for \"+\n\t\t\t\t\"PSBT signing: %v\", signMethod)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tsignedInputs = append(signedInputs, uint32(idx))\n\t}\n\treturn signedInputs, nil\n}\n\n// validateSigningMethod attempts to detect the signing method that is required\n// to sign for the given PSBT input and makes sure all information is available\n// to do so.",
      "length": 3944,
      "tokens": 584,
      "embedding": []
    },
    {
      "slug": "func validateSigningMethod(in *psbt.PInput) (input.SignMethod, error) {",
      "content": "func validateSigningMethod(in *psbt.PInput) (input.SignMethod, error) {\n\tscript, err := txscript.ParsePkScript(in.WitnessUtxo.PkScript)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"error detecting signing method, \"+\n\t\t\t\"couldn't parse pkScript: %v\", err)\n\t}\n\n\tswitch script.Class() {\n\tcase txscript.WitnessV0PubKeyHashTy, txscript.ScriptHashTy,\n\t\ttxscript.WitnessV0ScriptHashTy:\n\n\t\treturn input.WitnessV0SignMethod, nil\n\n\tcase txscript.WitnessV1TaprootTy:\n\t\tif len(in.TaprootBip32Derivation) == 0 {\n\t\t\treturn 0, fmt.Errorf(\"cannot sign for taproot input \" +\n\t\t\t\t\"without taproot BIP0032 derivation info\")\n\t\t}\n\n\t\t// Currently, we only support creating one signature per input.\n\t\t//\n\t\t// TODO(guggero): Should we support signing multiple paths at\n\t\t// the same time? What are the performance and security\n\t\t// implications?\n\t\tif len(in.TaprootBip32Derivation) > 1 {\n\t\t\treturn 0, fmt.Errorf(\"unsupported multiple taproot \" +\n\t\t\t\t\"BIP0032 derivation info found, can only \" +\n\t\t\t\t\"sign for one at a time\")\n\t\t}\n\n\t\tderivation := in.TaprootBip32Derivation[0]\n\t\tswitch {\n\t\t// No leaf hashes means this is the internal key we're signing\n\t\t// with, so it's a key spend. And no merkle root means this is\n\t\t// a BIP0086 output we're signing for.\n\t\tcase len(derivation.LeafHashes) == 0 &&\n\t\t\tlen(in.TaprootMerkleRoot) == 0:\n\n\t\t\treturn input.TaprootKeySpendBIP0086SignMethod, nil\n\n\t\t// A non-empty merkle root means we committed to a taproot hash\n\t\t// that we need to use in the tap tweak.\n\t\tcase len(derivation.LeafHashes) == 0:\n\t\t\t// Getting here means the merkle root isn't empty, but\n\t\t\t// is it exactly the length we need?\n\t\t\tif len(in.TaprootMerkleRoot) != sha256.Size {\n\t\t\t\treturn 0, fmt.Errorf(\"invalid taproot merkle \"+\n\t\t\t\t\t\"root length, got %d expected %d\",\n\t\t\t\t\tlen(in.TaprootMerkleRoot), sha256.Size)\n\t\t\t}\n\n\t\t\treturn input.TaprootKeySpendSignMethod, nil\n\n\t\t// Currently, we only support signing for one leaf at a time.\n\t\t//\n\t\t// TODO(guggero): Should we support signing multiple paths at\n\t\t// the same time? What are the performance and security\n\t\t// implications?\n\t\tcase len(derivation.LeafHashes) == 1:\n\t\t\t// If we're supposed to be signing for a leaf hash, we\n\t\t\t// also expect the leaf script that hashes to that hash\n\t\t\t// in the appropriate field.\n\t\t\tif len(in.TaprootLeafScript) != 1 {\n\t\t\t\treturn 0, fmt.Errorf(\"specified leaf hash in \" +\n\t\t\t\t\t\"taproot BIP0032 derivation but \" +\n\t\t\t\t\t\"missing taproot leaf script\")\n\t\t\t}\n\n\t\t\tleafScript := in.TaprootLeafScript[0]\n\t\t\tleaf := txscript.TapLeaf{\n\t\t\t\tLeafVersion: leafScript.LeafVersion,\n\t\t\t\tScript:      leafScript.Script,\n\t\t\t}\n\t\t\tleafHash := leaf.TapHash()\n\t\t\tif !bytes.Equal(leafHash[:], derivation.LeafHashes[0]) {\n\t\t\t\treturn 0, fmt.Errorf(\"specified leaf hash in\" +\n\t\t\t\t\t\"taproot BIP0032 derivation but \" +\n\t\t\t\t\t\"corresponding taproot leaf script \" +\n\t\t\t\t\t\"was not found\")\n\t\t\t}\n\n\t\t\treturn input.TaprootScriptSpendSignMethod, nil\n\n\t\tdefault:\n\t\t\treturn 0, fmt.Errorf(\"unsupported number of leaf \" +\n\t\t\t\t\"hashes in taproot BIP0032 derivation info, \" +\n\t\t\t\t\"can only sign for one at a time\")\n\t\t}\n\n\tdefault:\n\t\treturn 0, fmt.Errorf(\"unsupported script class for signing \"+\n\t\t\t\"PSBT: %v\", script.Class())\n\t}\n}\n\n// SignSegWitV0 attempts to generate a signature for a SegWit version 0 input\n// and stores it in the PartialSigs (and FinalScriptSig for np2wkh addresses)\n// field.",
      "length": 3152,
      "tokens": 430,
      "embedding": []
    },
    {
      "slug": "func signSegWitV0(in *psbt.PInput, tx *wire.MsgTx,",
      "content": "func signSegWitV0(in *psbt.PInput, tx *wire.MsgTx,\n\tsigHashes *txscript.TxSigHashes, idx int,\n\tprivKey *btcec.PrivateKey) error {\n\n\tpubKeyBytes := privKey.PubKey().SerializeCompressed()\n\n\t// Extract the correct witness and/or legacy scripts now, depending on\n\t// the type of input we sign. The txscript package has the peculiar\n\t// requirement that the PkScript of a P2PKH must be given as the witness\n\t// script in order for it to arrive at the correct sighash. That's why\n\t// we call it subScript here instead of witness script.\n\tsubScript := prepareScriptsV0(in)\n\n\t// We have everything we need for signing the input now.\n\tsig, err := txscript.RawTxInWitnessSignature(\n\t\ttx, sigHashes, idx, in.WitnessUtxo.Value, subScript,\n\t\tin.SighashType, privKey,\n\t)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error signing input %d: %v\", idx, err)\n\t}\n\tin.PartialSigs = append(in.PartialSigs, &psbt.PartialSig{\n\t\tPubKey:    pubKeyBytes,\n\t\tSignature: sig,\n\t})\n\n\treturn nil\n}\n\n// signSegWitV1KeySpend attempts to generate a signature for a SegWit version 1\n// (p2tr) input and stores it in the TaprootKeySpendSig field.",
      "length": 1022,
      "tokens": 147,
      "embedding": []
    },
    {
      "slug": "func signSegWitV1KeySpend(in *psbt.PInput, tx *wire.MsgTx,",
      "content": "func signSegWitV1KeySpend(in *psbt.PInput, tx *wire.MsgTx,\n\tsigHashes *txscript.TxSigHashes, idx int, privKey *btcec.PrivateKey,\n\ttapscriptRootHash []byte) error {\n\n\trawSig, err := txscript.RawTxInTaprootSignature(\n\t\ttx, sigHashes, idx, in.WitnessUtxo.Value,\n\t\tin.WitnessUtxo.PkScript, tapscriptRootHash, in.SighashType,\n\t\tprivKey,\n\t)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error signing taproot input %d: %v\", idx,\n\t\t\terr)\n\t}\n\n\tin.TaprootKeySpendSig = rawSig\n\n\treturn nil\n}\n\n// signSegWitV1ScriptSpend attempts to generate a signature for a SegWit version\n// 1 (p2tr) input and stores it in the TaprootScriptSpendSig field.",
      "length": 545,
      "tokens": 66,
      "embedding": []
    },
    {
      "slug": "func signSegWitV1ScriptSpend(in *psbt.PInput, tx *wire.MsgTx,",
      "content": "func signSegWitV1ScriptSpend(in *psbt.PInput, tx *wire.MsgTx,\n\tsigHashes *txscript.TxSigHashes, idx int, privKey *btcec.PrivateKey,\n\tleaf txscript.TapLeaf) error {\n\n\trawSig, err := txscript.RawTxInTapscriptSignature(\n\t\ttx, sigHashes, idx, in.WitnessUtxo.Value,\n\t\tin.WitnessUtxo.PkScript, leaf, in.SighashType, privKey,\n\t)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error signing taproot script input %d: %v\",\n\t\t\tidx, err)\n\t}\n\n\tleafHash := leaf.TapHash()\n\tin.TaprootScriptSpendSig = append(\n\t\tin.TaprootScriptSpendSig, &psbt.TaprootScriptSpendSig{\n\t\t\tXOnlyPubKey: in.TaprootBip32Derivation[0].XOnlyPubKey,\n\t\t\tLeafHash:    leafHash[:],\n\t\t\t// We snip off the sighash flag from the end (if it was\n\t\t\t// specified in the first place.)\n\t\t\tSignature: rawSig[:schnorr.SignatureSize],\n\t\t\tSigHash:   in.SighashType,\n\t\t},\n\t)\n\n\treturn nil\n}\n\n// prepareScriptsV0 returns the appropriate witness v0 and/or legacy scripts,\n// depending on the type of input that should be signed.",
      "length": 869,
      "tokens": 100,
      "embedding": []
    },
    {
      "slug": "func prepareScriptsV0(in *psbt.PInput) []byte {",
      "content": "func prepareScriptsV0(in *psbt.PInput) []byte {\n\tswitch {\n\t// It's a NP2WKH input:\n\tcase len(in.RedeemScript) > 0:\n\t\treturn in.RedeemScript\n\n\t// It's a P2WSH input:\n\tcase len(in.WitnessScript) > 0:\n\t\treturn in.WitnessScript\n\n\t// It's a P2WKH input:\n\tdefault:\n\t\treturn in.WitnessUtxo.PkScript\n\t}\n}\n\n// maybeTweakPrivKeyPsbt examines if there are any tweak parameters given in the\n// custom/proprietary PSBT fields and may perform a mapping on the passed\n// private key in order to utilize the tweaks, if populated.",
      "length": 448,
      "tokens": 69,
      "embedding": []
    },
    {
      "slug": "func maybeTweakPrivKeyPsbt(unknowns []*psbt.Unknown,",
      "content": "func maybeTweakPrivKeyPsbt(unknowns []*psbt.Unknown,\n\tprivKey *btcec.PrivateKey) *btcec.PrivateKey {\n\n\t// There can be other custom/unknown keys in a PSBT that we just ignore.\n\t// Key tweaking is optional and only one tweak (single _or_ double) can\n\t// ever be applied (at least for any use cases described in the BOLT\n\t// spec).\n\tfor _, u := range unknowns {\n\t\tif bytes.Equal(u.Key, PsbtKeyTypeInputSignatureTweakSingle) {\n\t\t\treturn input.TweakPrivKey(privKey, u.Value)\n\t\t}\n\n\t\tif bytes.Equal(u.Key, PsbtKeyTypeInputSignatureTweakDouble) {\n\t\t\tdoubleTweakKey, _ := btcec.PrivKeyFromBytes(\n\t\t\t\tu.Value,\n\t\t\t)\n\t\t\treturn input.DeriveRevocationPrivKey(\n\t\t\t\tprivKey, doubleTweakKey,\n\t\t\t)\n\t\t}\n\t}\n\n\treturn privKey\n}\n\n// FinalizePsbt expects a partial transaction with all inputs and outputs fully\n// declared and tries to sign all inputs that belong to the specified account.\n// Lnd must be the last signer of the transaction. That means, if there are any\n// unsigned non-witness inputs or inputs without UTXO information attached or\n// inputs without witness data that do not belong to lnd's wallet, this method\n// will fail. If no error is returned, the PSBT is ready to be extracted and the\n// final TX within to be broadcast.\n//\n// NOTE: This method does NOT publish the transaction after it's been\n// finalized successfully.\n//\n// This is a part of the WalletController interface.",
      "length": 1288,
      "tokens": 199,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) FinalizePsbt(packet *psbt.Packet, accountName string) error {",
      "content": "func (b *BtcWallet) FinalizePsbt(packet *psbt.Packet, accountName string) error {\n\tvar (\n\t\tkeyScope   *waddrmgr.KeyScope\n\t\taccountNum uint32\n\t)\n\tswitch accountName {\n\t// If the default/imported account name was specified, we'll provide a\n\t// nil key scope to FundPsbt, allowing it to sign inputs from both key\n\t// scopes (NP2WKH, P2WKH).\n\tcase lnwallet.DefaultAccountName:\n\t\taccountNum = defaultAccount\n\n\tcase waddrmgr.ImportedAddrAccountName:\n\t\taccountNum = importedAccount\n\n\t// Otherwise, map the account name to its key scope and internal account\n\t// number to determine if the inputs belonging to this account should be\n\t// signed.\n\tdefault:\n\t\tscope, account, err := b.wallet.LookupAccount(accountName)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tkeyScope = &scope\n\t\taccountNum = account\n\t}\n\n\treturn b.wallet.FinalizePsbt(keyScope, accountNum, packet)\n}\n",
      "length": 742,
      "tokens": 103,
      "embedding": []
    }
  ]
}