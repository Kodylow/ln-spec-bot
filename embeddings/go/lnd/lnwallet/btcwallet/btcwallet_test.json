{
  "filepath": "../implementations/go/lnd/lnwallet/btcwallet/btcwallet_test.go",
  "package": "btcwallet",
  "sections": [
    {
      "slug": "type previousOutpointsTest struct {",
      "content": "type previousOutpointsTest struct {\n\tname     string\n\ttx       *wire.MsgTx\n\tmyInputs []wallet.TransactionSummaryInput\n\texpRes   []lnwallet.PreviousOutPoint\n}\n\nvar previousOutpointsTests = []previousOutpointsTest{{\n\tname: \"both outpoints are wallet controlled\",\n\ttx: &wire.MsgTx{\n\t\tTxIn: []*wire.TxIn{{\n\t\t\tPreviousOutPoint: wire.OutPoint{Index: 0},\n\t\t}, {\n\t\t\tPreviousOutPoint: wire.OutPoint{Index: 1},\n\t\t}},\n\t},\n\tmyInputs: []wallet.TransactionSummaryInput{{\n\t\tIndex: 0,\n\t}, {\n\t\tIndex: 1,\n\t}},\n\texpRes: []lnwallet.PreviousOutPoint{{\n\t\tOutPoint:    wire.OutPoint{Index: 0}.String(),\n\t\tIsOurOutput: true,\n\t}, {\n\t\tOutPoint:    wire.OutPoint{Index: 1}.String(),\n\t\tIsOurOutput: true,\n\t}},\n}, {\n\tname: \"only one outpoint is wallet controlled\",\n\ttx: &wire.MsgTx{\n\t\tTxIn: []*wire.TxIn{{\n\t\t\tPreviousOutPoint: wire.OutPoint{Index: 0},\n\t\t}, {\n\t\t\tPreviousOutPoint: wire.OutPoint{Index: 1},\n\t\t}},\n\t},\n\tmyInputs: []wallet.TransactionSummaryInput{{\n\t\tIndex: 0,\n\t}, {\n\t\tIndex: 2,\n\t}},\n\texpRes: []lnwallet.PreviousOutPoint{{\n\t\tOutPoint:    wire.OutPoint{Index: 0}.String(),\n\t\tIsOurOutput: true,\n\t}, {\n\t\tOutPoint:    wire.OutPoint{Index: 1}.String(),\n\t\tIsOurOutput: false,\n\t}},\n}, {\n\tname: \"no outpoint is wallet controlled\",\n\ttx: &wire.MsgTx{\n\t\tTxIn: []*wire.TxIn{{\n\t\t\tPreviousOutPoint: wire.OutPoint{Index: 0},\n\t\t}, {\n\t\t\tPreviousOutPoint: wire.OutPoint{Index: 1},\n\t\t}},\n\t},\n\tmyInputs: []wallet.TransactionSummaryInput{{\n\t\tIndex: 2,\n\t}, {\n\t\tIndex: 3,\n\t}},\n\texpRes: []lnwallet.PreviousOutPoint{{\n\t\tOutPoint:    wire.OutPoint{Index: 0}.String(),\n\t\tIsOurOutput: false,\n\t}, {\n\t\tOutPoint:    wire.OutPoint{Index: 1}.String(),\n\t\tIsOurOutput: false,\n\t}},\n}, {\n\tname: \"tx is empty\",\n\ttx: &wire.MsgTx{\n\t\tTxIn: []*wire.TxIn{},\n\t},\n\tmyInputs: []wallet.TransactionSummaryInput{{\n\t\tIndex: 2,\n\t}, {\n\t\tIndex: 3,\n\t}},\n\texpRes: []lnwallet.PreviousOutPoint{},\n}, {\n\tname: \"wallet controlled input set is empty\",\n\ttx: &wire.MsgTx{\n\t\tTxIn: []*wire.TxIn{{\n\t\t\tPreviousOutPoint: wire.OutPoint{Index: 0},\n\t\t}, {\n\t\t\tPreviousOutPoint: wire.OutPoint{Index: 1},\n\t\t}},\n\t},\n\tmyInputs: []wallet.TransactionSummaryInput{},\n\texpRes: []lnwallet.PreviousOutPoint{{\n\t\tOutPoint:    wire.OutPoint{Index: 0}.String(),\n\t\tIsOurOutput: false,\n\t}, {\n\t\tOutPoint:    wire.OutPoint{Index: 1}.String(),\n\t\tIsOurOutput: false,\n\t}},\n}}\n\n// TestPreviousOutpoints tests if we are able to get the previous\n// outpoints correctly.",
      "length": 2221,
      "tokens": 227,
      "embedding": []
    },
    {
      "slug": "func TestPreviousOutpoints(t *testing.T) {",
      "content": "func TestPreviousOutpoints(t *testing.T) {\n\tfor _, test := range previousOutpointsTests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\trespOutpoints := getPreviousOutpoints(\n\t\t\t\ttest.tx, test.myInputs,\n\t\t\t)\n\n\t\t\tfor idx, respOutpoint := range respOutpoints {\n\t\t\t\texpRes := test.expRes[idx]\n\t\t\t\trequire.Equal(\n\t\t\t\t\tt, expRes.OutPoint,\n\t\t\t\t\trespOutpoint.OutPoint,\n\t\t\t\t)\n\t\t\t\trequire.Equal(\n\t\t\t\t\tt, expRes.IsOurOutput,\n\t\t\t\t\trespOutpoint.IsOurOutput,\n\t\t\t\t)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "length": 401,
      "tokens": 41,
      "embedding": []
    }
  ]
}