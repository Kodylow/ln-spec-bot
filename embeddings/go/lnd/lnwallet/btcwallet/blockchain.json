{
  "filepath": "../implementations/go/lnd/lnwallet/btcwallet/blockchain.go",
  "package": "btcwallet",
  "sections": [
    {
      "slug": "func (b *BtcWallet) GetBestBlock() (*chainhash.Hash, int32, error) {",
      "content": "func (b *BtcWallet) GetBestBlock() (*chainhash.Hash, int32, error) {\n\treturn b.chain.GetBestBlock()\n}\n\n// GetUtxo returns the original output referenced by the passed outpoint that\n// creates the target pkScript.\n//\n// This method is a part of the lnwallet.BlockChainIO interface.",
      "length": 205,
      "tokens": 31,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) GetUtxo(op *wire.OutPoint, pkScript []byte,",
      "content": "func (b *BtcWallet) GetUtxo(op *wire.OutPoint, pkScript []byte,\n\theightHint uint32, cancel <-chan struct{}) (*wire.TxOut, error) {\n\n\tswitch backend := b.chain.(type) {\n\n\tcase *chain.NeutrinoClient:\n\t\tspendReport, err := backend.CS.GetUtxo(\n\t\t\tneutrino.WatchInputs(neutrino.InputWithScript{\n\t\t\t\tOutPoint: *op,\n\t\t\t\tPkScript: pkScript,\n\t\t\t}),\n\t\t\tneutrino.StartBlock(&headerfs.BlockStamp{\n\t\t\t\tHeight: int32(heightHint),\n\t\t\t}),\n\t\t\tneutrino.QuitChan(cancel),\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// If the spend report is nil, then the output was not found in\n\t\t// the rescan.\n\t\tif spendReport == nil {\n\t\t\treturn nil, ErrOutputNotFound\n\t\t}\n\n\t\t// If the spending transaction is populated in the spend report,\n\t\t// this signals that the output has already been spent.\n\t\tif spendReport.SpendingTx != nil {\n\t\t\treturn nil, ErrOutputSpent\n\t\t}\n\n\t\t// Otherwise, the output is assumed to be in the UTXO.\n\t\treturn spendReport.Output, nil\n\n\tcase *chain.RPCClient:\n\t\ttxout, err := backend.GetTxOut(&op.Hash, op.Index, false)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t} else if txout == nil {\n\t\t\treturn nil, ErrOutputSpent\n\t\t}\n\n\t\tpkScript, err := hex.DecodeString(txout.ScriptPubKey.Hex)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// We'll ensure we properly convert the amount given in BTC to\n\t\t// satoshis.\n\t\tamt, err := btcutil.NewAmount(txout.Value)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn &wire.TxOut{\n\t\t\tValue:    int64(amt),\n\t\t\tPkScript: pkScript,\n\t\t}, nil\n\n\tcase *chain.BitcoindClient:\n\t\ttxout, err := backend.GetTxOut(&op.Hash, op.Index, false)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t} else if txout == nil {\n\t\t\treturn nil, ErrOutputSpent\n\t\t}\n\n\t\tpkScript, err := hex.DecodeString(txout.ScriptPubKey.Hex)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Sadly, gettxout returns the output value in BTC instead of\n\t\t// satoshis.\n\t\tamt, err := btcutil.NewAmount(txout.Value)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn &wire.TxOut{\n\t\t\tValue:    int64(amt),\n\t\t\tPkScript: pkScript,\n\t\t}, nil\n\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unknown backend\")\n\t}\n}\n\n// GetBlock returns a raw block from the server given its hash. For the Neutrino\n// implementation of the lnwallet.BlockChainIO interface, the Neutrino GetBlock\n// method is called directly. For other implementations, the block cache is used\n// to wrap the call to GetBlock.\n//\n// This method is a part of the lnwallet.BlockChainIO interface.",
      "length": 2246,
      "tokens": 321,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) GetBlock(blockHash *chainhash.Hash) (*wire.MsgBlock, error) {",
      "content": "func (b *BtcWallet) GetBlock(blockHash *chainhash.Hash) (*wire.MsgBlock, error) {\n\t_, ok := b.chain.(*chain.NeutrinoClient)\n\tif !ok {\n\t\treturn b.blockCache.GetBlock(blockHash, b.chain.GetBlock)\n\t}\n\n\t// For the neutrino implementation of lnwallet.BlockChainIO the neutrino\n\t// GetBlock function can be called directly since it uses the same block\n\t// cache. However, it does not lock the block cache mutex for the given\n\t// block hash and so that is done here.\n\tb.blockCache.HashMutex.Lock(lntypes.Hash(*blockHash))\n\tdefer b.blockCache.HashMutex.Unlock(lntypes.Hash(*blockHash))\n\n\treturn b.chain.GetBlock(blockHash)\n}\n\n// GetBlockHash returns the hash of the block in the best blockchain at the\n// given height.\n//\n// This method is a part of the lnwallet.BlockChainIO interface.",
      "length": 678,
      "tokens": 90,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWallet) GetBlockHash(blockHeight int64) (*chainhash.Hash, error) {",
      "content": "func (b *BtcWallet) GetBlockHash(blockHeight int64) (*chainhash.Hash, error) {\n\treturn b.chain.GetBlockHash(blockHeight)\n}\n\n// A compile time check to ensure that BtcWallet implements the BlockChainIO\n// interface.\nvar _ lnwallet.WalletController = (*BtcWallet)(nil)\n",
      "length": 182,
      "tokens": 22,
      "embedding": []
    }
  ]
}