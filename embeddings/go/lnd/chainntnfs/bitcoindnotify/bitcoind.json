{
  "filepath": "../implementations/go/lnd/chainntnfs/bitcoindnotify/bitcoind.go",
  "package": "bitcoindnotify",
  "sections": [
    {
      "slug": "type BitcoindNotifier struct {",
      "content": "type BitcoindNotifier struct {\n\tepochClientCounter uint64 // To be used atomically.\n\n\tstart   sync.Once\n\tactive  int32 // To be used atomically.\n\tstopped int32 // To be used atomically.\n\n\tchainConn   *chain.BitcoindClient\n\tchainParams *chaincfg.Params\n\n\tnotificationCancels  chan interface{}\n\tnotificationRegistry chan interface{}\n\n\ttxNotifier *chainntnfs.TxNotifier\n\n\tblockEpochClients map[uint64]*blockEpochRegistration\n\n\tbestBlock chainntnfs.BlockEpoch\n\n\t// blockCache is a LRU block cache.\n\tblockCache *blockcache.BlockCache\n\n\t// spendHintCache is a cache used to query and update the latest height\n\t// hints for an outpoint. Each height hint represents the earliest\n\t// height at which the outpoint could have been spent within the chain.\n\tspendHintCache chainntnfs.SpendHintCache\n\n\t// confirmHintCache is a cache used to query the latest height hints for\n\t// a transaction. Each height hint represents the earliest height at\n\t// which the transaction could have confirmed within the chain.\n\tconfirmHintCache chainntnfs.ConfirmHintCache\n\n\twg   sync.WaitGroup\n\tquit chan struct{}\n}\n\n// Ensure BitcoindNotifier implements the ChainNotifier interface at compile\n// time.\nvar _ chainntnfs.ChainNotifier = (*BitcoindNotifier)(nil)\n\n// New returns a new BitcoindNotifier instance. This function assumes the\n// bitcoind node detailed in the passed configuration is already running, and\n// willing to accept RPC requests and new zmq clients.",
      "length": 1366,
      "tokens": 178,
      "embedding": []
    },
    {
      "slug": "func New(chainConn *chain.BitcoindConn, chainParams *chaincfg.Params,",
      "content": "func New(chainConn *chain.BitcoindConn, chainParams *chaincfg.Params,\n\tspendHintCache chainntnfs.SpendHintCache,\n\tconfirmHintCache chainntnfs.ConfirmHintCache,\n\tblockCache *blockcache.BlockCache) *BitcoindNotifier {\n\n\tnotifier := &BitcoindNotifier{\n\t\tchainParams: chainParams,\n\n\t\tnotificationCancels:  make(chan interface{}),\n\t\tnotificationRegistry: make(chan interface{}),\n\n\t\tblockEpochClients: make(map[uint64]*blockEpochRegistration),\n\n\t\tspendHintCache:   spendHintCache,\n\t\tconfirmHintCache: confirmHintCache,\n\n\t\tblockCache: blockCache,\n\n\t\tquit: make(chan struct{}),\n\t}\n\n\tnotifier.chainConn = chainConn.NewBitcoindClient()\n\n\treturn notifier\n}\n\n// Start connects to the running bitcoind node over websockets, registers for\n// block notifications, and finally launches all related helper goroutines.",
      "length": 704,
      "tokens": 59,
      "embedding": []
    },
    {
      "slug": "func (b *BitcoindNotifier) Start() error {",
      "content": "func (b *BitcoindNotifier) Start() error {\n\tvar startErr error\n\tb.start.Do(func() {\n\t\tstartErr = b.startNotifier()\n\t})\n\treturn startErr\n}\n\n// Stop shutsdown the BitcoindNotifier.",
      "length": 128,
      "tokens": 17,
      "embedding": []
    },
    {
      "slug": "func (b *BitcoindNotifier) Stop() error {",
      "content": "func (b *BitcoindNotifier) Stop() error {\n\t// Already shutting down?\n\tif atomic.AddInt32(&b.stopped, 1) != 1 {\n\t\treturn nil\n\t}\n\n\tchainntnfs.Log.Info(\"bitcoind notifier shutting down\")\n\n\t// Shutdown the rpc client, this gracefully disconnects from bitcoind,\n\t// and cleans up all related resources.\n\tb.chainConn.Stop()\n\n\tclose(b.quit)\n\tb.wg.Wait()\n\n\t// Notify all pending clients of our shutdown by closing the related\n\t// notification channels.\n\tfor _, epochClient := range b.blockEpochClients {\n\t\tclose(epochClient.cancelChan)\n\t\tepochClient.wg.Wait()\n\n\t\tclose(epochClient.epochChan)\n\t}\n\tb.txNotifier.TearDown()\n\n\treturn nil\n}\n\n// Started returns true if this instance has been started, and false otherwise.",
      "length": 638,
      "tokens": 80,
      "embedding": []
    },
    {
      "slug": "func (b *BitcoindNotifier) Started() bool {",
      "content": "func (b *BitcoindNotifier) Started() bool {\n\treturn atomic.LoadInt32(&b.active) != 0\n}\n",
      "length": 41,
      "tokens": 5,
      "embedding": []
    },
    {
      "slug": "func (b *BitcoindNotifier) startNotifier() error {",
      "content": "func (b *BitcoindNotifier) startNotifier() error {\n\t// Connect to bitcoind, and register for notifications on connected,\n\t// and disconnected blocks.\n\tif err := b.chainConn.Start(); err != nil {\n\t\treturn err\n\t}\n\tif err := b.chainConn.NotifyBlocks(); err != nil {\n\t\treturn err\n\t}\n\n\tcurrentHash, currentHeight, err := b.chainConn.GetBestBlock()\n\tif err != nil {\n\t\treturn err\n\t}\n\tblockHeader, err := b.chainConn.GetBlockHeader(currentHash)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tb.txNotifier = chainntnfs.NewTxNotifier(\n\t\tuint32(currentHeight), chainntnfs.ReorgSafetyLimit,\n\t\tb.confirmHintCache, b.spendHintCache,\n\t)\n\n\tb.bestBlock = chainntnfs.BlockEpoch{\n\t\tHeight:      currentHeight,\n\t\tHash:        currentHash,\n\t\tBlockHeader: blockHeader,\n\t}\n\n\tb.wg.Add(1)\n\tgo b.notificationDispatcher()\n\n\t// Set the active flag now that we've completed the full\n\t// startup.\n\tatomic.StoreInt32(&b.active, 1)\n\n\treturn nil\n}\n\n// notificationDispatcher is the primary goroutine which handles client\n// notification registrations, as well as notification dispatches.",
      "length": 951,
      "tokens": 117,
      "embedding": []
    },
    {
      "slug": "func (b *BitcoindNotifier) notificationDispatcher() {",
      "content": "func (b *BitcoindNotifier) notificationDispatcher() {\n\tdefer b.wg.Done()\n\nout:\n\tfor {\n\t\tselect {\n\t\tcase cancelMsg := <-b.notificationCancels:\n\t\t\tswitch msg := cancelMsg.(type) {\n\t\t\tcase *epochCancel:\n\t\t\t\tchainntnfs.Log.Infof(\"Cancelling epoch \"+\n\t\t\t\t\t\"notification, epoch_id=%v\", msg.epochID)\n\n\t\t\t\t// First, we'll lookup the original\n\t\t\t\t// registration in order to stop the active\n\t\t\t\t// queue goroutine.\n\t\t\t\treg := b.blockEpochClients[msg.epochID]\n\t\t\t\treg.epochQueue.Stop()\n\n\t\t\t\t// Next, close the cancel channel for this\n\t\t\t\t// specific client, and wait for the client to\n\t\t\t\t// exit.\n\t\t\t\tclose(b.blockEpochClients[msg.epochID].cancelChan)\n\t\t\t\tb.blockEpochClients[msg.epochID].wg.Wait()\n\n\t\t\t\t// Once the client has exited, we can then\n\t\t\t\t// safely close the channel used to send epoch\n\t\t\t\t// notifications, in order to notify any\n\t\t\t\t// listeners that the intent has been\n\t\t\t\t// canceled.\n\t\t\t\tclose(b.blockEpochClients[msg.epochID].epochChan)\n\t\t\t\tdelete(b.blockEpochClients, msg.epochID)\n\n\t\t\t}\n\t\tcase registerMsg := <-b.notificationRegistry:\n\t\t\tswitch msg := registerMsg.(type) {\n\t\t\tcase *chainntnfs.HistoricalConfDispatch:\n\t\t\t\t// Look up whether the transaction is already\n\t\t\t\t// included in the active chain. We'll do this\n\t\t\t\t// in a goroutine to prevent blocking\n\t\t\t\t// potentially long rescans.\n\t\t\t\t//\n\t\t\t\t// TODO(wilmer): add retry logic if rescan fails?\n\t\t\t\tb.wg.Add(1)\n\n\t\t\t\t//nolint:lll\n\t\t\t\tgo func(msg *chainntnfs.HistoricalConfDispatch) {\n\t\t\t\t\tdefer b.wg.Done()\n\n\t\t\t\t\tconfDetails, _, err := b.historicalConfDetails(\n\t\t\t\t\t\tmsg.ConfRequest,\n\t\t\t\t\t\tmsg.StartHeight, msg.EndHeight,\n\t\t\t\t\t)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tchainntnfs.Log.Errorf(\"Rescan to \"+\n\t\t\t\t\t\t\t\"determine the conf \"+\n\t\t\t\t\t\t\t\"details of %v within \"+\n\t\t\t\t\t\t\t\"range %d-%d failed: %v\",\n\t\t\t\t\t\t\tmsg.ConfRequest,\n\t\t\t\t\t\t\tmsg.StartHeight,\n\t\t\t\t\t\t\tmsg.EndHeight, err)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the historical dispatch finished\n\t\t\t\t\t// without error, we will invoke\n\t\t\t\t\t// UpdateConfDetails even if none were\n\t\t\t\t\t// found. This allows the notifier to\n\t\t\t\t\t// begin safely updating the height hint\n\t\t\t\t\t// cache at tip, since any pending\n\t\t\t\t\t// rescans have now completed.\n\t\t\t\t\terr = b.txNotifier.UpdateConfDetails(\n\t\t\t\t\t\tmsg.ConfRequest, confDetails,\n\t\t\t\t\t)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tchainntnfs.Log.Errorf(\"Unable \"+\n\t\t\t\t\t\t\t\"to update conf \"+\n\t\t\t\t\t\t\t\"details of %v: %v\",\n\t\t\t\t\t\t\tmsg.ConfRequest, err)\n\t\t\t\t\t}\n\t\t\t\t}(msg)\n\n\t\t\tcase *chainntnfs.HistoricalSpendDispatch:\n\t\t\t\t// In order to ensure we don't block the caller\n\t\t\t\t// on what may be a long rescan, we'll launch a\n\t\t\t\t// goroutine to do so in the background.\n\t\t\t\t//\n\t\t\t\t// TODO(wilmer): add retry logic if rescan fails?\n\t\t\t\tb.wg.Add(1)\n\n\t\t\t\t//nolint:lll\n\t\t\t\tgo func(msg *chainntnfs.HistoricalSpendDispatch) {\n\t\t\t\t\tdefer b.wg.Done()\n\n\t\t\t\t\tspendDetails, err := b.historicalSpendDetails(\n\t\t\t\t\t\tmsg.SpendRequest,\n\t\t\t\t\t\tmsg.StartHeight, msg.EndHeight,\n\t\t\t\t\t)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tchainntnfs.Log.Errorf(\"Rescan to \"+\n\t\t\t\t\t\t\t\"determine the spend \"+\n\t\t\t\t\t\t\t\"details of %v within \"+\n\t\t\t\t\t\t\t\"range %d-%d failed: %v\",\n\t\t\t\t\t\t\tmsg.SpendRequest,\n\t\t\t\t\t\t\tmsg.StartHeight,\n\t\t\t\t\t\t\tmsg.EndHeight, err)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\tchainntnfs.Log.Infof(\"Historical \"+\n\t\t\t\t\t\t\"spend dispatch finished \"+\n\t\t\t\t\t\t\"for request %v (start=%v \"+\n\t\t\t\t\t\t\"end=%v) with details: %v\",\n\t\t\t\t\t\tmsg.SpendRequest,\n\t\t\t\t\t\tmsg.StartHeight, msg.EndHeight,\n\t\t\t\t\t\tspendDetails)\n\n\t\t\t\t\t// If the historical dispatch finished\n\t\t\t\t\t// without error, we will invoke\n\t\t\t\t\t// UpdateSpendDetails even if none were\n\t\t\t\t\t// found. This allows the notifier to\n\t\t\t\t\t// begin safely updating the height hint\n\t\t\t\t\t// cache at tip, since any pending\n\t\t\t\t\t// rescans have now completed.\n\t\t\t\t\terr = b.txNotifier.UpdateSpendDetails(\n\t\t\t\t\t\tmsg.SpendRequest, spendDetails,\n\t\t\t\t\t)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tchainntnfs.Log.Errorf(\"Unable \"+\n\t\t\t\t\t\t\t\"to update spend \"+\n\t\t\t\t\t\t\t\"details of %v: %v\",\n\t\t\t\t\t\t\tmsg.SpendRequest, err)\n\t\t\t\t\t}\n\t\t\t\t}(msg)\n\n\t\t\tcase *blockEpochRegistration:\n\t\t\t\tchainntnfs.Log.Infof(\"New block epoch subscription\")\n\n\t\t\t\tb.blockEpochClients[msg.epochID] = msg\n\n\t\t\t\t// If the client did not provide their best\n\t\t\t\t// known block, then we'll immediately dispatch\n\t\t\t\t// a notification for the current tip.\n\t\t\t\tif msg.bestBlock == nil {\n\t\t\t\t\tb.notifyBlockEpochClient(\n\t\t\t\t\t\tmsg, b.bestBlock.Height,\n\t\t\t\t\t\tb.bestBlock.Hash,\n\t\t\t\t\t\tb.bestBlock.BlockHeader,\n\t\t\t\t\t)\n\n\t\t\t\t\tmsg.errorChan <- nil\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, we'll attempt to deliver the\n\t\t\t\t// backlog of notifications from their best\n\t\t\t\t// known block.\n\t\t\t\tmissedBlocks, err := chainntnfs.GetClientMissedBlocks(\n\t\t\t\t\tb.chainConn, msg.bestBlock,\n\t\t\t\t\tb.bestBlock.Height, true,\n\t\t\t\t)\n\t\t\t\tif err != nil {\n\t\t\t\t\tmsg.errorChan <- err\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tfor _, block := range missedBlocks {\n\t\t\t\t\tb.notifyBlockEpochClient(\n\t\t\t\t\t\tmsg, block.Height, block.Hash,\n\t\t\t\t\t\tblock.BlockHeader,\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tmsg.errorChan <- nil\n\t\t\t}\n\n\t\tcase ntfn := <-b.chainConn.Notifications():\n\t\t\tswitch item := ntfn.(type) {\n\t\t\tcase chain.BlockConnected:\n\t\t\t\tblockHeader, err :=\n\t\t\t\t\tb.chainConn.GetBlockHeader(&item.Hash)\n\t\t\t\tif err != nil {\n\t\t\t\t\tchainntnfs.Log.Errorf(\"Unable to fetch \"+\n\t\t\t\t\t\t\"block header: %v\", err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tif blockHeader.PrevBlock != *b.bestBlock.Hash {\n\t\t\t\t\t// Handle the case where the notifier\n\t\t\t\t\t// missed some blocks from its chain\n\t\t\t\t\t// backend.\n\t\t\t\t\tchainntnfs.Log.Infof(\"Missed blocks, \" +\n\t\t\t\t\t\t\"attempting to catch up\")\n\t\t\t\t\tnewBestBlock, missedBlocks, err :=\n\t\t\t\t\t\tchainntnfs.HandleMissedBlocks(\n\t\t\t\t\t\t\tb.chainConn,\n\t\t\t\t\t\t\tb.txNotifier,\n\t\t\t\t\t\t\tb.bestBlock, item.Height,\n\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t)\n\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t// Set the bestBlock here in case\n\t\t\t\t\t\t// a catch up partially completed.\n\t\t\t\t\t\tb.bestBlock = newBestBlock\n\t\t\t\t\t\tchainntnfs.Log.Error(err)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\tfor _, block := range missedBlocks {\n\t\t\t\t\t\terr := b.handleBlockConnected(block)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tchainntnfs.Log.Error(err)\n\t\t\t\t\t\t\tcontinue out\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tnewBlock := chainntnfs.BlockEpoch{\n\t\t\t\t\tHeight:      item.Height,\n\t\t\t\t\tHash:        &item.Hash,\n\t\t\t\t\tBlockHeader: blockHeader,\n\t\t\t\t}\n\t\t\t\tif err := b.handleBlockConnected(newBlock); err != nil {\n\t\t\t\t\tchainntnfs.Log.Error(err)\n\t\t\t\t}\n\n\t\t\t\tcontinue\n\n\t\t\tcase chain.BlockDisconnected:\n\t\t\t\tif item.Height != b.bestBlock.Height {\n\t\t\t\t\tchainntnfs.Log.Infof(\"Missed disconnected\" +\n\t\t\t\t\t\t\"blocks, attempting to catch up\")\n\t\t\t\t}\n\n\t\t\t\tnewBestBlock, err := chainntnfs.RewindChain(\n\t\t\t\t\tb.chainConn, b.txNotifier,\n\t\t\t\t\tb.bestBlock, item.Height-1,\n\t\t\t\t)\n\t\t\t\tif err != nil {\n\t\t\t\t\tchainntnfs.Log.Errorf(\"Unable to rewind chain \"+\n\t\t\t\t\t\t\"from height %d to height %d: %v\",\n\t\t\t\t\t\tb.bestBlock.Height, item.Height-1, err)\n\t\t\t\t}\n\n\t\t\t\t// Set the bestBlock here in case a chain\n\t\t\t\t// rewind partially completed.\n\t\t\t\tb.bestBlock = newBestBlock\n\n\t\t\tcase chain.RelevantTx:\n\t\t\t\t// We only care about notifying on confirmed\n\t\t\t\t// spends, so if this is a mempool spend, we can\n\t\t\t\t// ignore it and wait for the spend to appear in\n\t\t\t\t// on-chain.\n\t\t\t\tif item.Block == nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\ttx := btcutil.NewTx(&item.TxRecord.MsgTx)\n\t\t\t\terr := b.txNotifier.ProcessRelevantSpendTx(\n\t\t\t\t\ttx, uint32(item.Block.Height),\n\t\t\t\t)\n\t\t\t\tif err != nil {\n\t\t\t\t\tchainntnfs.Log.Errorf(\"Unable to \"+\n\t\t\t\t\t\t\"process transaction %v: %v\",\n\t\t\t\t\t\ttx.Hash(), err)\n\t\t\t\t}\n\t\t\t}\n\n\t\tcase <-b.quit:\n\t\t\tbreak out\n\t\t}\n\t}\n}\n\n// historicalConfDetails looks up whether a confirmation request (txid/output\n// script) has already been included in a block in the active chain and, if so,\n// returns details about said block.",
      "length": 7192,
      "tokens": 840,
      "embedding": []
    },
    {
      "slug": "func (b *BitcoindNotifier) historicalConfDetails(confRequest chainntnfs.ConfRequest,",
      "content": "func (b *BitcoindNotifier) historicalConfDetails(confRequest chainntnfs.ConfRequest,\n\tstartHeight, endHeight uint32) (*chainntnfs.TxConfirmation,\n\tchainntnfs.TxConfStatus, error) {\n\n\t// If a txid was not provided, then we should dispatch upon seeing the\n\t// script on-chain, so we'll short-circuit straight to scanning manually\n\t// as there doesn't exist a script index to query.\n\tif confRequest.TxID == chainntnfs.ZeroHash {\n\t\treturn b.confDetailsManually(\n\t\t\tconfRequest, startHeight, endHeight,\n\t\t)\n\t}\n\n\t// Otherwise, we'll dispatch upon seeing a transaction on-chain with the\n\t// given hash.\n\t//\n\t// We'll first attempt to retrieve the transaction using the node's\n\t// txindex.\n\ttxNotFoundErr := \"No such mempool or blockchain transaction\"\n\ttxConf, txStatus, err := chainntnfs.ConfDetailsFromTxIndex(\n\t\tb.chainConn, confRequest, txNotFoundErr,\n\t)\n\n\t// We'll then check the status of the transaction lookup returned to\n\t// determine whether we should proceed with any fallback methods.\n\tswitch {\n\n\t// We failed querying the index for the transaction, fall back to\n\t// scanning manually.\n\tcase err != nil:\n\t\tchainntnfs.Log.Debugf(\"Failed getting conf details from \"+\n\t\t\t\"index (%v), scanning manually\", err)\n\t\treturn b.confDetailsManually(confRequest, startHeight, endHeight)\n\n\t// The transaction was found within the node's mempool.\n\tcase txStatus == chainntnfs.TxFoundMempool:\n\n\t// The transaction was found within the node's txindex.\n\tcase txStatus == chainntnfs.TxFoundIndex:\n\n\t// The transaction was not found within the node's mempool or txindex.\n\tcase txStatus == chainntnfs.TxNotFoundIndex:\n\n\t// Unexpected txStatus returned.\n\tdefault:\n\t\treturn nil, txStatus,\n\t\t\tfmt.Errorf(\"Got unexpected txConfStatus: %v\", txStatus)\n\t}\n\n\treturn txConf, txStatus, nil\n}\n\n// confDetailsManually looks up whether a transaction/output script has already\n// been included in a block in the active chain by scanning the chain's blocks\n// within the given range. If the transaction/output script is found, its\n// confirmation details are returned. Otherwise, nil is returned.",
      "length": 1925,
      "tokens": 263,
      "embedding": []
    },
    {
      "slug": "func (b *BitcoindNotifier) confDetailsManually(confRequest chainntnfs.ConfRequest,",
      "content": "func (b *BitcoindNotifier) confDetailsManually(confRequest chainntnfs.ConfRequest,\n\theightHint, currentHeight uint32) (*chainntnfs.TxConfirmation,\n\tchainntnfs.TxConfStatus, error) {\n\n\t// Begin scanning blocks at every height to determine where the\n\t// transaction was included in.\n\tfor height := currentHeight; height >= heightHint && height > 0; height-- {\n\t\t// Ensure we haven't been requested to shut down before\n\t\t// processing the next height.\n\t\tselect {\n\t\tcase <-b.quit:\n\t\t\treturn nil, chainntnfs.TxNotFoundManually,\n\t\t\t\tchainntnfs.ErrChainNotifierShuttingDown\n\t\tdefault:\n\t\t}\n\n\t\tblockHash, err := b.chainConn.GetBlockHash(int64(height))\n\t\tif err != nil {\n\t\t\treturn nil, chainntnfs.TxNotFoundManually,\n\t\t\t\tfmt.Errorf(\"unable to get hash from block \"+\n\t\t\t\t\t\"with height %d\", height)\n\t\t}\n\n\t\tblock, err := b.GetBlock(blockHash)\n\t\tif err != nil {\n\t\t\treturn nil, chainntnfs.TxNotFoundManually,\n\t\t\t\tfmt.Errorf(\"unable to get block with hash \"+\n\t\t\t\t\t\"%v: %v\", blockHash, err)\n\t\t}\n\n\t\t// For every transaction in the block, check which one matches\n\t\t// our request. If we find one that does, we can dispatch its\n\t\t// confirmation details.\n\t\tfor txIndex, tx := range block.Transactions {\n\t\t\tif !confRequest.MatchesTx(tx) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\treturn &chainntnfs.TxConfirmation{\n\t\t\t\tTx:          tx,\n\t\t\t\tBlockHash:   blockHash,\n\t\t\t\tBlockHeight: height,\n\t\t\t\tTxIndex:     uint32(txIndex),\n\t\t\t\tBlock:       block,\n\t\t\t}, chainntnfs.TxFoundManually, nil\n\t\t}\n\t}\n\n\t// If we reach here, then we were not able to find the transaction\n\t// within a block, so we avoid returning an error.\n\treturn nil, chainntnfs.TxNotFoundManually, nil\n}\n\n// handleBlockConnected applies a chain update for a new block. Any watched\n// transactions included this block will processed to either send notifications\n// now or after numConfirmations confs.",
      "length": 1682,
      "tokens": 223,
      "embedding": []
    },
    {
      "slug": "func (b *BitcoindNotifier) handleBlockConnected(block chainntnfs.BlockEpoch) error {",
      "content": "func (b *BitcoindNotifier) handleBlockConnected(block chainntnfs.BlockEpoch) error {\n\t// First, we'll fetch the raw block as we'll need to gather all the\n\t// transactions to determine whether any are relevant to our registered\n\t// clients.\n\trawBlock, err := b.GetBlock(block.Hash)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to get block: %v\", err)\n\t}\n\tutilBlock := btcutil.NewBlock(rawBlock)\n\n\t// We'll then extend the txNotifier's height with the information of\n\t// this new block, which will handle all of the notification logic for\n\t// us.\n\terr = b.txNotifier.ConnectTip(utilBlock, uint32(block.Height))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to connect tip: %v\", err)\n\t}\n\n\tchainntnfs.Log.Infof(\"New block: height=%v, sha=%v\", block.Height,\n\t\tblock.Hash)\n\n\t// Now that we've guaranteed the new block extends the txNotifier's\n\t// current tip, we'll proceed to dispatch notifications to all of our\n\t// registered clients whom have had notifications fulfilled. Before\n\t// doing so, we'll make sure update our in memory state in order to\n\t// satisfy any client requests based upon the new block.\n\tb.bestBlock = block\n\n\tb.notifyBlockEpochs(block.Height, block.Hash, block.BlockHeader)\n\treturn b.txNotifier.NotifyHeight(uint32(block.Height))\n}\n\n// notifyBlockEpochs notifies all registered block epoch clients of the newly\n// connected block to the main chain.",
      "length": 1248,
      "tokens": 179,
      "embedding": []
    },
    {
      "slug": "func (b *BitcoindNotifier) notifyBlockEpochs(newHeight int32, newSha *chainhash.Hash,",
      "content": "func (b *BitcoindNotifier) notifyBlockEpochs(newHeight int32, newSha *chainhash.Hash,\n\tblockHeader *wire.BlockHeader) {\n\n\tfor _, client := range b.blockEpochClients {\n\t\tb.notifyBlockEpochClient(client, newHeight, newSha, blockHeader)\n\t}\n}\n\n// notifyBlockEpochClient sends a registered block epoch client a notification\n// about a specific block.",
      "length": 251,
      "tokens": 31,
      "embedding": []
    },
    {
      "slug": "func (b *BitcoindNotifier) notifyBlockEpochClient(epochClient *blockEpochRegistration,",
      "content": "func (b *BitcoindNotifier) notifyBlockEpochClient(epochClient *blockEpochRegistration,\n\theight int32, sha *chainhash.Hash, header *wire.BlockHeader) {\n\n\tepoch := &chainntnfs.BlockEpoch{\n\t\tHeight:      height,\n\t\tHash:        sha,\n\t\tBlockHeader: header,\n\t}\n\n\tselect {\n\tcase epochClient.epochQueue.ChanIn() <- epoch:\n\tcase <-epochClient.cancelChan:\n\tcase <-b.quit:\n\t}\n}\n\n// RegisterSpendNtfn registers an intent to be notified once the target\n// outpoint/output script has been spent by a transaction on-chain. When\n// intending to be notified of the spend of an output script, a nil outpoint\n// must be used. The heightHint should represent the earliest height in the\n// chain of the transaction that spent the outpoint/output script.\n//\n// Once a spend of has been detected, the details of the spending event will be\n// sent across the 'Spend' channel.",
      "length": 742,
      "tokens": 112,
      "embedding": []
    },
    {
      "slug": "func (b *BitcoindNotifier) RegisterSpendNtfn(outpoint *wire.OutPoint,",
      "content": "func (b *BitcoindNotifier) RegisterSpendNtfn(outpoint *wire.OutPoint,\n\tpkScript []byte, heightHint uint32) (*chainntnfs.SpendEvent, error) {\n\n\t// Register the conf notification with the TxNotifier. A non-nil value\n\t// for `dispatch` will be returned if we are required to perform a\n\t// manual scan for the confirmation. Otherwise the notifier will begin\n\t// watching at tip for the transaction to confirm.\n\tntfn, err := b.txNotifier.RegisterSpend(outpoint, pkScript, heightHint)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// We'll then request the backend to notify us when it has detected the\n\t// outpoint/output script as spent.\n\t//\n\t// TODO(wilmer): use LoadFilter API instead.\n\tif outpoint == nil || *outpoint == chainntnfs.ZeroOutPoint {\n\t\t_, addrs, _, err := txscript.ExtractPkScriptAddrs(\n\t\t\tpkScript, b.chainParams,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to parse script: %v\", err)\n\t\t}\n\t\tif err := b.chainConn.NotifyReceived(addrs); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\tops := []*wire.OutPoint{outpoint}\n\t\tif err := b.chainConn.NotifySpent(ops); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// If the txNotifier didn't return any details to perform a historical\n\t// scan of the chain, then we can return early as there's nothing left\n\t// for us to do.\n\tif ntfn.HistoricalDispatch == nil {\n\t\treturn ntfn.Event, nil\n\t}\n\n\t// Otherwise, we'll need to dispatch a historical rescan to determine if\n\t// the outpoint was already spent at a previous height.\n\t//\n\t// We'll short-circuit the path when dispatching the spend of a script,\n\t// rather than an outpoint, as there aren't any additional checks we can\n\t// make for scripts.\n\tif ntfn.HistoricalDispatch.OutPoint == chainntnfs.ZeroOutPoint {\n\t\tselect {\n\t\tcase b.notificationRegistry <- ntfn.HistoricalDispatch:\n\t\tcase <-b.quit:\n\t\t\treturn nil, chainntnfs.ErrChainNotifierShuttingDown\n\t\t}\n\n\t\treturn ntfn.Event, nil\n\t}\n\n\t// When dispatching spends of outpoints, there are a number of checks we\n\t// can make to start our rescan from a better height or completely avoid\n\t// it.\n\t//\n\t// We'll start by checking the backend's UTXO set to determine whether\n\t// the outpoint has been spent. If it hasn't, we can return to the\n\t// caller as well.\n\ttxOut, err := b.chainConn.GetTxOut(&outpoint.Hash, outpoint.Index, true)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif txOut != nil {\n\t\t// We'll let the txNotifier know the outpoint is still unspent\n\t\t// in order to begin updating its spend hint.\n\t\terr := b.txNotifier.UpdateSpendDetails(\n\t\t\tntfn.HistoricalDispatch.SpendRequest, nil,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn ntfn.Event, nil\n\t}\n\n\t// Since the outpoint was spent, as it no longer exists within the UTXO\n\t// set, we'll determine when it happened by scanning the chain.\n\t//\n\t// As a minimal optimization, we'll query the backend's transaction\n\t// index (if enabled) to determine if we have a better rescan starting\n\t// height. We can do this as the GetRawTransaction call will return the\n\t// hash of the block it was included in within the chain.\n\ttx, err := b.chainConn.GetRawTransactionVerbose(&outpoint.Hash)\n\tif err != nil {\n\t\t// Avoid returning an error if the transaction was not found to\n\t\t// proceed with fallback methods.\n\t\tjsonErr, ok := err.(*btcjson.RPCError)\n\t\tif !ok || jsonErr.Code != btcjson.ErrRPCNoTxInfo {\n\t\t\treturn nil, fmt.Errorf(\"unable to query for txid %v: %v\",\n\t\t\t\toutpoint.Hash, err)\n\t\t}\n\t}\n\n\t// If the transaction index was enabled, we'll use the block's hash to\n\t// retrieve its height and check whether it provides a better starting\n\t// point for our rescan.\n\tif tx != nil {\n\t\t// If the transaction containing the outpoint hasn't confirmed\n\t\t// on-chain, then there's no need to perform a rescan.\n\t\tif tx.BlockHash == \"\" {\n\t\t\treturn ntfn.Event, nil\n\t\t}\n\n\t\tblockHash, err := chainhash.NewHashFromStr(tx.BlockHash)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tblockHeight, err := b.chainConn.GetBlockHeight(blockHash)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif uint32(blockHeight) > ntfn.HistoricalDispatch.StartHeight {\n\t\t\tntfn.HistoricalDispatch.StartHeight = uint32(blockHeight)\n\t\t}\n\t}\n\n\t// Now that we've determined the starting point of our rescan, we can\n\t// dispatch it and return.\n\tselect {\n\tcase b.notificationRegistry <- ntfn.HistoricalDispatch:\n\tcase <-b.quit:\n\t\treturn nil, chainntnfs.ErrChainNotifierShuttingDown\n\t}\n\n\treturn ntfn.Event, nil\n}\n\n// historicalSpendDetails attempts to manually scan the chain within the given\n// height range for a transaction that spends the given outpoint/output script.\n// If one is found, the spend details are assembled and returned to the caller.\n// If the spend is not found, a nil spend detail will be returned.",
      "length": 4473,
      "tokens": 696,
      "embedding": []
    },
    {
      "slug": "func (b *BitcoindNotifier) historicalSpendDetails(",
      "content": "func (b *BitcoindNotifier) historicalSpendDetails(\n\tspendRequest chainntnfs.SpendRequest, startHeight, endHeight uint32) (\n\t*chainntnfs.SpendDetail, error) {\n\n\t// Begin scanning blocks at every height to determine if the outpoint\n\t// was spent.\n\tfor height := endHeight; height >= startHeight && height > 0; height-- {\n\t\t// Ensure we haven't been requested to shut down before\n\t\t// processing the next height.\n\t\tselect {\n\t\tcase <-b.quit:\n\t\t\treturn nil, chainntnfs.ErrChainNotifierShuttingDown\n\t\tdefault:\n\t\t}\n\n\t\t// First, we'll fetch the block for the current height.\n\t\tblockHash, err := b.chainConn.GetBlockHash(int64(height))\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to retrieve hash for \"+\n\t\t\t\t\"block with height %d: %v\", height, err)\n\t\t}\n\t\tblock, err := b.GetBlock(blockHash)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to retrieve block \"+\n\t\t\t\t\"with hash %v: %v\", blockHash, err)\n\t\t}\n\n\t\t// Then, we'll manually go over every input in every transaction\n\t\t// in it and determine whether it spends the request in\n\t\t// question. If we find one, we'll dispatch the spend details.\n\t\tfor _, tx := range block.Transactions {\n\t\t\tmatches, inputIdx, err := spendRequest.MatchesTx(tx)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif !matches {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\ttxHash := tx.TxHash()\n\t\t\treturn &chainntnfs.SpendDetail{\n\t\t\t\tSpentOutPoint:     &tx.TxIn[inputIdx].PreviousOutPoint,\n\t\t\t\tSpenderTxHash:     &txHash,\n\t\t\t\tSpendingTx:        tx,\n\t\t\t\tSpenderInputIndex: inputIdx,\n\t\t\t\tSpendingHeight:    int32(height),\n\t\t\t}, nil\n\t\t}\n\t}\n\n\treturn nil, nil\n}\n\n// RegisterConfirmationsNtfn registers an intent to be notified once the target\n// txid/output script has reached numConfs confirmations on-chain. When\n// intending to be notified of the confirmation of an output script, a nil txid\n// must be used. The heightHint should represent the earliest height at which\n// the txid/output script could have been included in the chain.\n//\n// Progress on the number of confirmations left can be read from the 'Updates'\n// channel. Once it has reached all of its confirmations, a notification will be\n// sent across the 'Confirmed' channel.",
      "length": 2030,
      "tokens": 295,
      "embedding": []
    },
    {
      "slug": "func (b *BitcoindNotifier) RegisterConfirmationsNtfn(txid *chainhash.Hash,",
      "content": "func (b *BitcoindNotifier) RegisterConfirmationsNtfn(txid *chainhash.Hash,\n\tpkScript []byte, numConfs, heightHint uint32,\n\topts ...chainntnfs.NotifierOption) (*chainntnfs.ConfirmationEvent, error) {\n\n\t// Register the conf notification with the TxNotifier. A non-nil value\n\t// for `dispatch` will be returned if we are required to perform a\n\t// manual scan for the confirmation. Otherwise the notifier will begin\n\t// watching at tip for the transaction to confirm.\n\tntfn, err := b.txNotifier.RegisterConf(\n\t\ttxid, pkScript, numConfs, heightHint, opts...,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif ntfn.HistoricalDispatch == nil {\n\t\treturn ntfn.Event, nil\n\t}\n\n\tselect {\n\tcase b.notificationRegistry <- ntfn.HistoricalDispatch:\n\t\treturn ntfn.Event, nil\n\tcase <-b.quit:\n\t\treturn nil, chainntnfs.ErrChainNotifierShuttingDown\n\t}\n}\n\n// blockEpochRegistration represents a client's intent to receive a\n// notification with each newly connected block.",
      "length": 844,
      "tokens": 114,
      "embedding": []
    },
    {
      "slug": "type blockEpochRegistration struct {",
      "content": "type blockEpochRegistration struct {\n\tepochID uint64\n\n\tepochChan chan *chainntnfs.BlockEpoch\n\n\tepochQueue *queue.ConcurrentQueue\n\n\tbestBlock *chainntnfs.BlockEpoch\n\n\terrorChan chan error\n\n\tcancelChan chan struct{}\n\n\twg sync.WaitGroup\n}\n\n// epochCancel is a message sent to the BitcoindNotifier when a client wishes\n// to cancel an outstanding epoch notification that has yet to be dispatched.",
      "length": 339,
      "tokens": 44,
      "embedding": []
    },
    {
      "slug": "type epochCancel struct {",
      "content": "type epochCancel struct {\n\tepochID uint64\n}\n\n// RegisterBlockEpochNtfn returns a BlockEpochEvent which subscribes the\n// caller to receive notifications, of each new block connected to the main\n// chain. Clients have the option of passing in their best known block, which\n// the notifier uses to check if they are behind on blocks and catch them up. If\n// they do not provide one, then a notification will be dispatched immediately\n// for the current tip of the chain upon a successful registration.",
      "length": 465,
      "tokens": 80,
      "embedding": []
    },
    {
      "slug": "func (b *BitcoindNotifier) RegisterBlockEpochNtfn(",
      "content": "func (b *BitcoindNotifier) RegisterBlockEpochNtfn(\n\tbestBlock *chainntnfs.BlockEpoch) (*chainntnfs.BlockEpochEvent, error) {\n\n\treg := &blockEpochRegistration{\n\t\tepochQueue: queue.NewConcurrentQueue(20),\n\t\tepochChan:  make(chan *chainntnfs.BlockEpoch, 20),\n\t\tcancelChan: make(chan struct{}),\n\t\tepochID:    atomic.AddUint64(&b.epochClientCounter, 1),\n\t\tbestBlock:  bestBlock,\n\t\terrorChan:  make(chan error, 1),\n\t}\n\treg.epochQueue.Start()\n\n\t// Before we send the request to the main goroutine, we'll launch a new\n\t// goroutine to proxy items added to our queue to the client itself.\n\t// This ensures that all notifications are received *in order*.\n\treg.wg.Add(1)\n\tgo func() {\n\t\tdefer reg.wg.Done()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase ntfn := <-reg.epochQueue.ChanOut():\n\t\t\t\tblockNtfn := ntfn.(*chainntnfs.BlockEpoch)\n\t\t\t\tselect {\n\t\t\t\tcase reg.epochChan <- blockNtfn:\n\n\t\t\t\tcase <-reg.cancelChan:\n\t\t\t\t\treturn\n\n\t\t\t\tcase <-b.quit:\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\tcase <-reg.cancelChan:\n\t\t\t\treturn\n\n\t\t\tcase <-b.quit:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tselect {\n\tcase <-b.quit:\n\t\t// As we're exiting before the registration could be sent,\n\t\t// we'll stop the queue now ourselves.\n\t\treg.epochQueue.Stop()\n\n\t\treturn nil, errors.New(\"chainntnfs: system interrupt while \" +\n\t\t\t\"attempting to register for block epoch notification.\")\n\tcase b.notificationRegistry <- reg:\n\t\treturn &chainntnfs.BlockEpochEvent{\n\t\t\tEpochs: reg.epochChan,\n\t\t\tCancel: func() {\n\t\t\t\tcancel := &epochCancel{\n\t\t\t\t\tepochID: reg.epochID,\n\t\t\t\t}\n\n\t\t\t\t// Submit epoch cancellation to notification dispatcher.\n\t\t\t\tselect {\n\t\t\t\tcase b.notificationCancels <- cancel:\n\t\t\t\t\t// Cancellation is being handled, drain the epoch channel until it is\n\t\t\t\t\t// closed before yielding to caller.\n\t\t\t\t\tfor {\n\t\t\t\t\t\tselect {\n\t\t\t\t\t\tcase _, ok := <-reg.epochChan:\n\t\t\t\t\t\t\tif !ok {\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase <-b.quit:\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tcase <-b.quit:\n\t\t\t\t}\n\t\t\t},\n\t\t}, nil\n\t}\n}\n\n// GetBlock is used to retrieve the block with the given hash. This function\n// wraps the blockCache's GetBlock function.",
      "length": 1899,
      "tokens": 236,
      "embedding": []
    },
    {
      "slug": "func (b *BitcoindNotifier) GetBlock(hash *chainhash.Hash) (*wire.MsgBlock,",
      "content": "func (b *BitcoindNotifier) GetBlock(hash *chainhash.Hash) (*wire.MsgBlock,\n\terror) {\n\n\treturn b.blockCache.GetBlock(hash, b.chainConn.GetBlock)\n}\n",
      "length": 67,
      "tokens": 6,
      "embedding": []
    }
  ]
}