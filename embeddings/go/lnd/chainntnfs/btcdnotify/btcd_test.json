{
  "filepath": "../implementations/go/lnd/chainntnfs/btcdnotify/btcd_test.go",
  "package": "btcdnotify",
  "sections": [
    {
      "slug": "//go:build dev",
      "content": "//go:build dev\n// +build dev\n\npackage btcdnotify\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n\n\t\"github.com/btcsuite/btcd/chaincfg/chainhash\"\n\t\"github.com/btcsuite/btcd/integration/rpctest\"\n\t\"github.com/lightningnetwork/lnd/blockcache\"\n\t\"github.com/lightningnetwork/lnd/chainntnfs\"\n\t\"github.com/lightningnetwork/lnd/channeldb\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nvar (\n\ttestScript = []byte{\n\t\t// OP_HASH160\n\t\t0xA9,\n\t\t// OP_DATA_20\n\t\t0x14,\n\t\t// <20-byte hash>\n\t\t0xec, 0x6f, 0x7a, 0x5a, 0xa8, 0xf2, 0xb1, 0x0c, 0xa5, 0x15,\n\t\t0x04, 0x52, 0x3a, 0x60, 0xd4, 0x03, 0x06, 0xf6, 0x96, 0xcd,\n\t\t// OP_EQUAL\n\t\t0x87,\n\t}\n)\n",
      "length": 557,
      "tokens": 55,
      "embedding": []
    },
    {
      "slug": "func initHintCache(t *testing.T) *channeldb.HeightHintCache {",
      "content": "func initHintCache(t *testing.T) *channeldb.HeightHintCache {\n\tt.Helper()\n\n\tdb, err := channeldb.Open(t.TempDir())\n\trequire.NoError(t, err, \"unable to create db\")\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, db.Close())\n\t})\n\n\ttestCfg := channeldb.CacheConfig{\n\t\tQueryDisable: false,\n\t}\n\thintCache, err := channeldb.NewHeightHintCache(testCfg, db.Backend)\n\trequire.NoError(t, err, \"unable to create hint cache\")\n\n\treturn hintCache\n}\n\n// setUpNotifier is a helper function to start a new notifier backed by a btcd\n// driver.",
      "length": 438,
      "tokens": 54,
      "embedding": []
    },
    {
      "slug": "func setUpNotifier(t *testing.T, h *rpctest.Harness) *BtcdNotifier {",
      "content": "func setUpNotifier(t *testing.T, h *rpctest.Harness) *BtcdNotifier {\n\thintCache := initHintCache(t)\n\tblockCache := blockcache.NewBlockCache(10000)\n\n\trpcCfg := h.RPCConfig()\n\tnotifier, err := New(\n\t\t&rpcCfg, chainntnfs.NetParams, hintCache, hintCache, blockCache,\n\t)\n\trequire.NoError(t, err, \"unable to create notifier\")\n\tif err := notifier.Start(); err != nil {\n\t\tt.Fatalf(\"unable to start notifier: %v\", err)\n\t}\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, notifier.Stop())\n\t})\n\n\treturn notifier\n}\n\n// TestHistoricalConfDetailsTxIndex ensures that we correctly retrieve\n// historical confirmation details using the backend node's txindex.",
      "length": 547,
      "tokens": 64,
      "embedding": []
    },
    {
      "slug": "func TestHistoricalConfDetailsTxIndex(t *testing.T) {",
      "content": "func TestHistoricalConfDetailsTxIndex(t *testing.T) {\n\tt.Parallel()\n\n\tharness := chainntnfs.NewMiner(\n\t\tt, []string{\"--txindex\"}, true, 25,\n\t)\n\n\tnotifier := setUpNotifier(t, harness)\n\n\t// A transaction unknown to the node should not be found within the\n\t// txindex even if it is enabled, so we should not proceed with any\n\t// fallback methods.\n\tvar unknownHash chainhash.Hash\n\tcopy(unknownHash[:], bytes.Repeat([]byte{0x10}, 32))\n\tunknownConfReq, err := chainntnfs.NewConfRequest(&unknownHash, testScript)\n\trequire.NoError(t, err, \"unable to create conf request\")\n\t_, txStatus, err := notifier.historicalConfDetails(unknownConfReq, 0, 0)\n\trequire.NoError(t, err, \"unable to retrieve historical conf details\")\n\n\tswitch txStatus {\n\tcase chainntnfs.TxNotFoundIndex:\n\tcase chainntnfs.TxNotFoundManually:\n\t\tt.Fatal(\"should not have proceeded with fallback method, but did\")\n\tdefault:\n\t\tt.Fatal(\"should not have found non-existent transaction, but did\")\n\t}\n\n\t// Now, we'll create a test transaction and attempt to retrieve its\n\t// confirmation details.\n\ttxid, pkScript, err := chainntnfs.GetTestTxidAndScript(harness)\n\trequire.NoError(t, err, \"unable to create tx\")\n\tif err := chainntnfs.WaitForMempoolTx(harness, txid); err != nil {\n\t\tt.Fatalf(\"unable to find tx in the mempool: %v\", err)\n\t}\n\tconfReq, err := chainntnfs.NewConfRequest(txid, pkScript)\n\trequire.NoError(t, err, \"unable to create conf request\")\n\n\t// The transaction should be found in the mempool at this point.\n\t_, txStatus, err = notifier.historicalConfDetails(confReq, 0, 0)\n\trequire.NoError(t, err, \"unable to retrieve historical conf details\")\n\n\t// Since it has yet to be included in a block, it should have been found\n\t// within the mempool.\n\tswitch txStatus {\n\tcase chainntnfs.TxFoundMempool:\n\tdefault:\n\t\tt.Fatalf(\"should have found the transaction within the \"+\n\t\t\t\"mempool, but did not: %v\", txStatus)\n\t}\n\n\t// We'll now confirm this transaction and re-attempt to retrieve its\n\t// confirmation details.\n\tif _, err := harness.Client.Generate(1); err != nil {\n\t\tt.Fatalf(\"unable to generate block: %v\", err)\n\t}\n\n\t_, txStatus, err = notifier.historicalConfDetails(confReq, 0, 0)\n\trequire.NoError(t, err, \"unable to retrieve historical conf details\")\n\n\t// Since the backend node's txindex is enabled and the transaction has\n\t// confirmed, we should be able to retrieve it using the txindex.\n\tswitch txStatus {\n\tcase chainntnfs.TxFoundIndex:\n\tdefault:\n\t\tt.Fatal(\"should have found the transaction within the \" +\n\t\t\t\"txindex, but did not\")\n\t}\n}\n\n// TestHistoricalConfDetailsNoTxIndex ensures that we correctly retrieve\n// historical confirmation details using the set of fallback methods when the\n// backend node's txindex is disabled.",
      "length": 2572,
      "tokens": 342,
      "embedding": []
    },
    {
      "slug": "func TestHistoricalConfDetailsNoTxIndex(t *testing.T) {",
      "content": "func TestHistoricalConfDetailsNoTxIndex(t *testing.T) {\n\tt.Parallel()\n\n\tharness := chainntnfs.NewMiner(t, nil, true, 25)\n\n\tnotifier := setUpNotifier(t, harness)\n\n\t// Since the node has its txindex disabled, we fall back to scanning the\n\t// chain manually. A transaction unknown to the network should not be\n\t// found.\n\tvar unknownHash chainhash.Hash\n\tcopy(unknownHash[:], bytes.Repeat([]byte{0x10}, 32))\n\tunknownConfReq, err := chainntnfs.NewConfRequest(&unknownHash, testScript)\n\trequire.NoError(t, err, \"unable to create conf request\")\n\t_, txStatus, err := notifier.historicalConfDetails(unknownConfReq, 0, 0)\n\trequire.NoError(t, err, \"unable to retrieve historical conf details\")\n\n\tswitch txStatus {\n\tcase chainntnfs.TxNotFoundManually:\n\tcase chainntnfs.TxNotFoundIndex:\n\t\tt.Fatal(\"should have proceeded with fallback method, but did not\")\n\tdefault:\n\t\tt.Fatal(\"should not have found non-existent transaction, but did\")\n\t}\n\n\t// Now, we'll create a test transaction and attempt to retrieve its\n\t// confirmation details. We'll note its broadcast height to use as the\n\t// height hint when manually scanning the chain.\n\t_, currentHeight, err := harness.Client.GetBestBlock()\n\trequire.NoError(t, err, \"unable to retrieve current height\")\n\n\ttxid, pkScript, err := chainntnfs.GetTestTxidAndScript(harness)\n\trequire.NoError(t, err, \"unable to create tx\")\n\tif err := chainntnfs.WaitForMempoolTx(harness, txid); err != nil {\n\t\tt.Fatalf(\"unable to find tx in the mempool: %v\", err)\n\t}\n\tconfReq, err := chainntnfs.NewConfRequest(txid, pkScript)\n\trequire.NoError(t, err, \"unable to create conf request\")\n\n\t_, txStatus, err = notifier.historicalConfDetails(confReq, 0, 0)\n\trequire.NoError(t, err, \"unable to retrieve historical conf details\")\n\n\t// Since it has yet to be included in a block, it should have been found\n\t// within the mempool.\n\tif txStatus != chainntnfs.TxFoundMempool {\n\t\tt.Fatal(\"should have found the transaction within the \" +\n\t\t\t\"mempool, but did not\")\n\t}\n\n\t// We'll now confirm this transaction and re-attempt to retrieve its\n\t// confirmation details.\n\tif _, err := harness.Client.Generate(1); err != nil {\n\t\tt.Fatalf(\"unable to generate block: %v\", err)\n\t}\n\n\t_, txStatus, err = notifier.historicalConfDetails(\n\t\tconfReq, uint32(currentHeight), uint32(currentHeight)+1,\n\t)\n\trequire.NoError(t, err, \"unable to retrieve historical conf details\")\n\n\t// Since the backend node's txindex is disabled and the transaction has\n\t// confirmed, we should be able to find it by falling back to scanning\n\t// the chain manually.\n\tif txStatus != chainntnfs.TxFoundManually {\n\t\tt.Fatal(\"should have found the transaction by manually \" +\n\t\t\t\"scanning the chain, but did not\")\n\t}\n}\n",
      "length": 2549,
      "tokens": 337,
      "embedding": []
    }
  ]
}