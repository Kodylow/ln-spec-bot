{
  "filepath": "../implementations/go/lnd/chainntnfs/btcdnotify/btcd.go",
  "package": "btcdnotify",
  "sections": [
    {
      "slug": "type chainUpdate struct {",
      "content": "type chainUpdate struct {\n\tblockHash   *chainhash.Hash\n\tblockHeight int32\n\n\t// connected is true if this update is a new block and false if it is a\n\t// disconnected block.\n\tconnect bool\n}\n\n// txUpdate encapsulates a transaction related notification sent from btcd to\n// the registered RPC client. This struct is used as an element within an\n// unbounded queue in order to avoid blocking the main rpc dispatch rule.",
      "length": 378,
      "tokens": 65,
      "embedding": []
    },
    {
      "slug": "type txUpdate struct {",
      "content": "type txUpdate struct {\n\ttx      *btcutil.Tx\n\tdetails *btcjson.BlockDetails\n}\n\n// TODO(roasbeef): generalize struct below:\n//  * move chans to config, allow outside callers to handle send conditions\n\n// BtcdNotifier implements the ChainNotifier interface using btcd's websockets\n// notifications. Multiple concurrent clients are supported. All notifications\n// are achieved via non-blocking sends on client channels.",
      "length": 383,
      "tokens": 50,
      "embedding": []
    },
    {
      "slug": "type BtcdNotifier struct {",
      "content": "type BtcdNotifier struct {\n\tepochClientCounter uint64 // To be used atomically.\n\n\tstart   sync.Once\n\tactive  int32 // To be used atomically.\n\tstopped int32 // To be used atomically.\n\n\tchainConn   *rpcclient.Client\n\tchainParams *chaincfg.Params\n\n\tnotificationCancels  chan interface{}\n\tnotificationRegistry chan interface{}\n\n\ttxNotifier *chainntnfs.TxNotifier\n\n\tblockEpochClients map[uint64]*blockEpochRegistration\n\n\tbestBlock chainntnfs.BlockEpoch\n\n\t// blockCache is a LRU block cache.\n\tblockCache *blockcache.BlockCache\n\n\tchainUpdates *queue.ConcurrentQueue\n\ttxUpdates    *queue.ConcurrentQueue\n\n\t// spendHintCache is a cache used to query and update the latest height\n\t// hints for an outpoint. Each height hint represents the earliest\n\t// height at which the outpoint could have been spent within the chain.\n\tspendHintCache chainntnfs.SpendHintCache\n\n\t// confirmHintCache is a cache used to query the latest height hints for\n\t// a transaction. Each height hint represents the earliest height at\n\t// which the transaction could have confirmed within the chain.\n\tconfirmHintCache chainntnfs.ConfirmHintCache\n\n\twg   sync.WaitGroup\n\tquit chan struct{}\n}\n\n// Ensure BtcdNotifier implements the ChainNotifier interface at compile time.\nvar _ chainntnfs.ChainNotifier = (*BtcdNotifier)(nil)\n\n// New returns a new BtcdNotifier instance. This function assumes the btcd node\n// detailed in the passed configuration is already running, and willing to\n// accept new websockets clients.",
      "length": 1406,
      "tokens": 178,
      "embedding": []
    },
    {
      "slug": "func New(config *rpcclient.ConnConfig, chainParams *chaincfg.Params,",
      "content": "func New(config *rpcclient.ConnConfig, chainParams *chaincfg.Params,\n\tspendHintCache chainntnfs.SpendHintCache,\n\tconfirmHintCache chainntnfs.ConfirmHintCache,\n\tblockCache *blockcache.BlockCache) (*BtcdNotifier, error) {\n\n\tnotifier := &BtcdNotifier{\n\t\tchainParams: chainParams,\n\n\t\tnotificationCancels:  make(chan interface{}),\n\t\tnotificationRegistry: make(chan interface{}),\n\n\t\tblockEpochClients: make(map[uint64]*blockEpochRegistration),\n\n\t\tchainUpdates: queue.NewConcurrentQueue(10),\n\t\ttxUpdates:    queue.NewConcurrentQueue(10),\n\n\t\tspendHintCache:   spendHintCache,\n\t\tconfirmHintCache: confirmHintCache,\n\n\t\tblockCache: blockCache,\n\n\t\tquit: make(chan struct{}),\n\t}\n\n\tntfnCallbacks := &rpcclient.NotificationHandlers{\n\t\tOnBlockConnected:    notifier.onBlockConnected,\n\t\tOnBlockDisconnected: notifier.onBlockDisconnected,\n\t\tOnRedeemingTx:       notifier.onRedeemingTx,\n\t}\n\n\t// Disable connecting to btcd within the rpcclient.New method. We\n\t// defer establishing the connection to our .Start() method.\n\tconfig.DisableConnectOnNew = true\n\tconfig.DisableAutoReconnect = false\n\tchainConn, err := rpcclient.New(config, ntfnCallbacks)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tnotifier.chainConn = chainConn\n\n\treturn notifier, nil\n}\n\n// Start connects to the running btcd node over websockets, registers for block\n// notifications, and finally launches all related helper goroutines.",
      "length": 1262,
      "tokens": 114,
      "embedding": []
    },
    {
      "slug": "func (b *BtcdNotifier) Start() error {",
      "content": "func (b *BtcdNotifier) Start() error {\n\tvar startErr error\n\tb.start.Do(func() {\n\t\tstartErr = b.startNotifier()\n\t})\n\treturn startErr\n}\n\n// Started returns true if this instance has been started, and false otherwise.",
      "length": 168,
      "tokens": 25,
      "embedding": []
    },
    {
      "slug": "func (b *BtcdNotifier) Started() bool {",
      "content": "func (b *BtcdNotifier) Started() bool {\n\treturn atomic.LoadInt32(&b.active) != 0\n}\n\n// Stop shutsdown the BtcdNotifier.",
      "length": 76,
      "tokens": 10,
      "embedding": []
    },
    {
      "slug": "func (b *BtcdNotifier) Stop() error {",
      "content": "func (b *BtcdNotifier) Stop() error {\n\t// Already shutting down?\n\tif atomic.AddInt32(&b.stopped, 1) != 1 {\n\t\treturn nil\n\t}\n\n\tchainntnfs.Log.Info(\"btcd notifier shutting down\")\n\n\t// Shutdown the rpc client, this gracefully disconnects from btcd, and\n\t// cleans up all related resources.\n\tb.chainConn.Shutdown()\n\n\tclose(b.quit)\n\tb.wg.Wait()\n\n\tb.chainUpdates.Stop()\n\tb.txUpdates.Stop()\n\n\t// Notify all pending clients of our shutdown by closing the related\n\t// notification channels.\n\tfor _, epochClient := range b.blockEpochClients {\n\t\tclose(epochClient.cancelChan)\n\t\tepochClient.wg.Wait()\n\n\t\tclose(epochClient.epochChan)\n\t}\n\tb.txNotifier.TearDown()\n\n\treturn nil\n}\n",
      "length": 596,
      "tokens": 69,
      "embedding": []
    },
    {
      "slug": "func (b *BtcdNotifier) startNotifier() error {",
      "content": "func (b *BtcdNotifier) startNotifier() error {\n\t// Start our concurrent queues before starting the chain connection, to\n\t// ensure onBlockConnected and onRedeemingTx callbacks won't be\n\t// blocked.\n\tb.chainUpdates.Start()\n\tb.txUpdates.Start()\n\n\t// Connect to btcd, and register for notifications on connected, and\n\t// disconnected blocks.\n\tif err := b.chainConn.Connect(20); err != nil {\n\t\tb.txUpdates.Stop()\n\t\tb.chainUpdates.Stop()\n\t\treturn err\n\t}\n\n\tcurrentHash, currentHeight, err := b.chainConn.GetBestBlock()\n\tif err != nil {\n\t\tb.txUpdates.Stop()\n\t\tb.chainUpdates.Stop()\n\t\treturn err\n\t}\n\n\tbestBlock, err := b.chainConn.GetBlock(currentHash)\n\tif err != nil {\n\t\tb.txUpdates.Stop()\n\t\tb.chainUpdates.Stop()\n\t\treturn err\n\t}\n\n\tb.txNotifier = chainntnfs.NewTxNotifier(\n\t\tuint32(currentHeight), chainntnfs.ReorgSafetyLimit,\n\t\tb.confirmHintCache, b.spendHintCache,\n\t)\n\n\tb.bestBlock = chainntnfs.BlockEpoch{\n\t\tHeight:      currentHeight,\n\t\tHash:        currentHash,\n\t\tBlockHeader: &bestBlock.Header,\n\t}\n\n\tif err := b.chainConn.NotifyBlocks(); err != nil {\n\t\tb.txUpdates.Stop()\n\t\tb.chainUpdates.Stop()\n\t\treturn err\n\t}\n\n\tb.wg.Add(1)\n\tgo b.notificationDispatcher()\n\n\t// Set the active flag now that we've completed the full\n\t// startup.\n\tatomic.StoreInt32(&b.active, 1)\n\n\treturn nil\n}\n\n// onBlockConnected implements on OnBlockConnected callback for rpcclient.\n// Ingesting a block updates the wallet's internal utxo state based on the\n// outputs created and destroyed within each block.",
      "length": 1374,
      "tokens": 160,
      "embedding": []
    },
    {
      "slug": "func (b *BtcdNotifier) onBlockConnected(hash *chainhash.Hash, height int32, t time.Time) {",
      "content": "func (b *BtcdNotifier) onBlockConnected(hash *chainhash.Hash, height int32, t time.Time) {\n\t// Append this new chain update to the end of the queue of new chain\n\t// updates.\n\tselect {\n\tcase b.chainUpdates.ChanIn() <- &chainUpdate{\n\t\tblockHash:   hash,\n\t\tblockHeight: height,\n\t\tconnect:     true,\n\t}:\n\tcase <-b.quit:\n\t\treturn\n\t}\n}\n\n// filteredBlock represents a new block which has been connected to the main\n// chain. The slice of transactions will only be populated if the block\n// includes a transaction that confirmed one of our watched txids, or spends\n// one of the outputs currently being watched.\n//\n// TODO(halseth): this is currently used for complete blocks. Change to use\n// onFilteredBlockConnected and onFilteredBlockDisconnected, making it easier\n// to unify with the Neutrino implementation.",
      "length": 695,
      "tokens": 109,
      "embedding": []
    },
    {
      "slug": "type filteredBlock struct {",
      "content": "type filteredBlock struct {\n\thash   chainhash.Hash\n\theight uint32\n\tblock  *btcutil.Block\n\n\t// connected is true if this update is a new block and false if it is a\n\t// disconnected block.\n\tconnect bool\n}\n\n// onBlockDisconnected implements on OnBlockDisconnected callback for rpcclient.",
      "length": 247,
      "tokens": 37,
      "embedding": []
    },
    {
      "slug": "func (b *BtcdNotifier) onBlockDisconnected(hash *chainhash.Hash, height int32, t time.Time) {",
      "content": "func (b *BtcdNotifier) onBlockDisconnected(hash *chainhash.Hash, height int32, t time.Time) {\n\t// Append this new chain update to the end of the queue of new chain\n\t// updates.\n\tselect {\n\tcase b.chainUpdates.ChanIn() <- &chainUpdate{\n\t\tblockHash:   hash,\n\t\tblockHeight: height,\n\t\tconnect:     false,\n\t}:\n\tcase <-b.quit:\n\t\treturn\n\t}\n}\n\n// onRedeemingTx implements on OnRedeemingTx callback for rpcclient.",
      "length": 296,
      "tokens": 43,
      "embedding": []
    },
    {
      "slug": "func (b *BtcdNotifier) onRedeemingTx(tx *btcutil.Tx, details *btcjson.BlockDetails) {",
      "content": "func (b *BtcdNotifier) onRedeemingTx(tx *btcutil.Tx, details *btcjson.BlockDetails) {\n\t// Append this new transaction update to the end of the queue of new\n\t// chain updates.\n\tselect {\n\tcase b.txUpdates.ChanIn() <- &txUpdate{tx, details}:\n\tcase <-b.quit:\n\t\treturn\n\t}\n}\n\n// notificationDispatcher is the primary goroutine which handles client\n// notification registrations, as well as notification dispatches.",
      "length": 312,
      "tokens": 46,
      "embedding": []
    },
    {
      "slug": "func (b *BtcdNotifier) notificationDispatcher() {",
      "content": "func (b *BtcdNotifier) notificationDispatcher() {\n\tdefer b.wg.Done()\n\nout:\n\tfor {\n\t\tselect {\n\t\tcase cancelMsg := <-b.notificationCancels:\n\t\t\tswitch msg := cancelMsg.(type) {\n\t\t\tcase *epochCancel:\n\t\t\t\tchainntnfs.Log.Infof(\"Cancelling epoch \"+\n\t\t\t\t\t\"notification, epoch_id=%v\", msg.epochID)\n\n\t\t\t\t// First, we'll lookup the original\n\t\t\t\t// registration in order to stop the active\n\t\t\t\t// queue goroutine.\n\t\t\t\treg := b.blockEpochClients[msg.epochID]\n\t\t\t\treg.epochQueue.Stop()\n\n\t\t\t\t// Next, close the cancel channel for this\n\t\t\t\t// specific client, and wait for the client to\n\t\t\t\t// exit.\n\t\t\t\tclose(b.blockEpochClients[msg.epochID].cancelChan)\n\t\t\t\tb.blockEpochClients[msg.epochID].wg.Wait()\n\n\t\t\t\t// Once the client has exited, we can then\n\t\t\t\t// safely close the channel used to send epoch\n\t\t\t\t// notifications, in order to notify any\n\t\t\t\t// listeners that the intent has been\n\t\t\t\t// canceled.\n\t\t\t\tclose(b.blockEpochClients[msg.epochID].epochChan)\n\t\t\t\tdelete(b.blockEpochClients, msg.epochID)\n\t\t\t}\n\t\tcase registerMsg := <-b.notificationRegistry:\n\t\t\tswitch msg := registerMsg.(type) {\n\t\t\tcase *chainntnfs.HistoricalConfDispatch:\n\t\t\t\t// Look up whether the transaction/output script\n\t\t\t\t// has already confirmed in the active chain.\n\t\t\t\t// We'll do this in a goroutine to prevent\n\t\t\t\t// blocking potentially long rescans.\n\t\t\t\t//\n\t\t\t\t// TODO(wilmer): add retry logic if rescan fails?\n\t\t\t\tb.wg.Add(1)\n\n\t\t\t\t//nolint:lll\n\t\t\t\tgo func(msg *chainntnfs.HistoricalConfDispatch) {\n\t\t\t\t\tdefer b.wg.Done()\n\n\t\t\t\t\tconfDetails, _, err := b.historicalConfDetails(\n\t\t\t\t\t\tmsg.ConfRequest,\n\t\t\t\t\t\tmsg.StartHeight, msg.EndHeight,\n\t\t\t\t\t)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tchainntnfs.Log.Error(err)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the historical dispatch finished\n\t\t\t\t\t// without error, we will invoke\n\t\t\t\t\t// UpdateConfDetails even if none were\n\t\t\t\t\t// found. This allows the notifier to\n\t\t\t\t\t// begin safely updating the height hint\n\t\t\t\t\t// cache at tip, since any pending\n\t\t\t\t\t// rescans have now completed.\n\t\t\t\t\terr = b.txNotifier.UpdateConfDetails(\n\t\t\t\t\t\tmsg.ConfRequest, confDetails,\n\t\t\t\t\t)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tchainntnfs.Log.Error(err)\n\t\t\t\t\t}\n\t\t\t\t}(msg)\n\n\t\t\tcase *blockEpochRegistration:\n\t\t\t\tchainntnfs.Log.Infof(\"New block epoch subscription\")\n\n\t\t\t\tb.blockEpochClients[msg.epochID] = msg\n\n\t\t\t\t// If the client did not provide their best\n\t\t\t\t// known block, then we'll immediately dispatch\n\t\t\t\t// a notification for the current tip.\n\t\t\t\tif msg.bestBlock == nil {\n\t\t\t\t\tb.notifyBlockEpochClient(\n\t\t\t\t\t\tmsg, b.bestBlock.Height,\n\t\t\t\t\t\tb.bestBlock.Hash,\n\t\t\t\t\t\tb.bestBlock.BlockHeader,\n\t\t\t\t\t)\n\n\t\t\t\t\tmsg.errorChan <- nil\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, we'll attempt to deliver the\n\t\t\t\t// backlog of notifications from their best\n\t\t\t\t// known block.\n\t\t\t\tmissedBlocks, err := chainntnfs.GetClientMissedBlocks(\n\t\t\t\t\tb.chainConn, msg.bestBlock,\n\t\t\t\t\tb.bestBlock.Height, true,\n\t\t\t\t)\n\t\t\t\tif err != nil {\n\t\t\t\t\tmsg.errorChan <- err\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tfor _, block := range missedBlocks {\n\t\t\t\t\tb.notifyBlockEpochClient(\n\t\t\t\t\t\tmsg, block.Height, block.Hash,\n\t\t\t\t\t\tblock.BlockHeader,\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tmsg.errorChan <- nil\n\t\t\t}\n\n\t\tcase item := <-b.chainUpdates.ChanOut():\n\t\t\tupdate := item.(*chainUpdate)\n\t\t\tif update.connect {\n\t\t\t\tblockHeader, err := b.chainConn.GetBlockHeader(\n\t\t\t\t\tupdate.blockHash,\n\t\t\t\t)\n\t\t\t\tif err != nil {\n\t\t\t\t\tchainntnfs.Log.Errorf(\"Unable to fetch \"+\n\t\t\t\t\t\t\"block header: %v\", err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tif blockHeader.PrevBlock != *b.bestBlock.Hash {\n\t\t\t\t\t// Handle the case where the notifier\n\t\t\t\t\t// missed some blocks from its chain\n\t\t\t\t\t// backend\n\t\t\t\t\tchainntnfs.Log.Infof(\"Missed blocks, \" +\n\t\t\t\t\t\t\"attempting to catch up\")\n\t\t\t\t\tnewBestBlock, missedBlocks, err :=\n\t\t\t\t\t\tchainntnfs.HandleMissedBlocks(\n\t\t\t\t\t\t\tb.chainConn,\n\t\t\t\t\t\t\tb.txNotifier,\n\t\t\t\t\t\t\tb.bestBlock,\n\t\t\t\t\t\t\tupdate.blockHeight,\n\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t// Set the bestBlock here in case\n\t\t\t\t\t\t// a catch up partially completed.\n\t\t\t\t\t\tb.bestBlock = newBestBlock\n\t\t\t\t\t\tchainntnfs.Log.Error(err)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\tfor _, block := range missedBlocks {\n\t\t\t\t\t\terr := b.handleBlockConnected(block)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tchainntnfs.Log.Error(err)\n\t\t\t\t\t\t\tcontinue out\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tnewBlock := chainntnfs.BlockEpoch{\n\t\t\t\t\tHeight:      update.blockHeight,\n\t\t\t\t\tHash:        update.blockHash,\n\t\t\t\t\tBlockHeader: blockHeader,\n\t\t\t\t}\n\t\t\t\tif err := b.handleBlockConnected(newBlock); err != nil {\n\t\t\t\t\tchainntnfs.Log.Error(err)\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif update.blockHeight != b.bestBlock.Height {\n\t\t\t\tchainntnfs.Log.Infof(\"Missed disconnected\" +\n\t\t\t\t\t\"blocks, attempting to catch up\")\n\t\t\t}\n\n\t\t\tnewBestBlock, err := chainntnfs.RewindChain(\n\t\t\t\tb.chainConn, b.txNotifier, b.bestBlock,\n\t\t\t\tupdate.blockHeight-1,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tchainntnfs.Log.Errorf(\"Unable to rewind chain \"+\n\t\t\t\t\t\"from height %d to height %d: %v\",\n\t\t\t\t\tb.bestBlock.Height, update.blockHeight-1, err)\n\t\t\t}\n\n\t\t\t// Set the bestBlock here in case a chain rewind\n\t\t\t// partially completed.\n\t\t\tb.bestBlock = newBestBlock\n\n\t\tcase item := <-b.txUpdates.ChanOut():\n\t\t\tnewSpend := item.(*txUpdate)\n\n\t\t\t// We only care about notifying on confirmed spends, so\n\t\t\t// if this is a mempool spend, we can ignore it and wait\n\t\t\t// for the spend to appear in on-chain.\n\t\t\tif newSpend.details == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\terr := b.txNotifier.ProcessRelevantSpendTx(\n\t\t\t\tnewSpend.tx, uint32(newSpend.details.Height),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tchainntnfs.Log.Errorf(\"Unable to process \"+\n\t\t\t\t\t\"transaction %v: %v\",\n\t\t\t\t\tnewSpend.tx.Hash(), err)\n\t\t\t}\n\n\t\tcase <-b.quit:\n\t\t\tbreak out\n\t\t}\n\t}\n}\n\n// historicalConfDetails looks up whether a confirmation request (txid/output\n// script) has already been included in a block in the active chain and, if so,\n// returns details about said block.",
      "length": 5494,
      "tokens": 640,
      "embedding": []
    },
    {
      "slug": "func (b *BtcdNotifier) historicalConfDetails(confRequest chainntnfs.ConfRequest,",
      "content": "func (b *BtcdNotifier) historicalConfDetails(confRequest chainntnfs.ConfRequest,\n\tstartHeight, endHeight uint32) (*chainntnfs.TxConfirmation,\n\tchainntnfs.TxConfStatus, error) {\n\n\t// If a txid was not provided, then we should dispatch upon seeing the\n\t// script on-chain, so we'll short-circuit straight to scanning manually\n\t// as there doesn't exist a script index to query.\n\tif confRequest.TxID == chainntnfs.ZeroHash {\n\t\treturn b.confDetailsManually(\n\t\t\tconfRequest, startHeight, endHeight,\n\t\t)\n\t}\n\n\t// Otherwise, we'll dispatch upon seeing a transaction on-chain with the\n\t// given hash.\n\t//\n\t// We'll first attempt to retrieve the transaction using the node's\n\t// txindex.\n\ttxNotFoundErr := \"No information available about transaction\"\n\ttxConf, txStatus, err := chainntnfs.ConfDetailsFromTxIndex(\n\t\tb.chainConn, confRequest, txNotFoundErr,\n\t)\n\n\t// We'll then check the status of the transaction lookup returned to\n\t// determine whether we should proceed with any fallback methods.\n\tswitch {\n\n\t// We failed querying the index for the transaction, fall back to\n\t// scanning manually.\n\tcase err != nil:\n\t\tchainntnfs.Log.Debugf(\"Unable to determine confirmation of %v \"+\n\t\t\t\"through the backend's txindex (%v), scanning manually\",\n\t\t\tconfRequest.TxID, err)\n\n\t\treturn b.confDetailsManually(\n\t\t\tconfRequest, startHeight, endHeight,\n\t\t)\n\n\t// The transaction was found within the node's mempool.\n\tcase txStatus == chainntnfs.TxFoundMempool:\n\n\t// The transaction was found within the node's txindex.\n\tcase txStatus == chainntnfs.TxFoundIndex:\n\n\t// The transaction was not found within the node's mempool or txindex.\n\tcase txStatus == chainntnfs.TxNotFoundIndex:\n\n\t// Unexpected txStatus returned.\n\tdefault:\n\t\treturn nil, txStatus,\n\t\t\tfmt.Errorf(\"Got unexpected txConfStatus: %v\", txStatus)\n\t}\n\n\treturn txConf, txStatus, nil\n}\n\n// confDetailsManually looks up whether a transaction/output script has already\n// been included in a block in the active chain by scanning the chain's blocks\n// within the given range. If the transaction/output script is found, its\n// confirmation details are returned. Otherwise, nil is returned.",
      "length": 1982,
      "tokens": 269,
      "embedding": []
    },
    {
      "slug": "func (b *BtcdNotifier) confDetailsManually(confRequest chainntnfs.ConfRequest,",
      "content": "func (b *BtcdNotifier) confDetailsManually(confRequest chainntnfs.ConfRequest,\n\tstartHeight, endHeight uint32) (*chainntnfs.TxConfirmation,\n\tchainntnfs.TxConfStatus, error) {\n\n\t// Begin scanning blocks at every height to determine where the\n\t// transaction was included in.\n\tfor height := endHeight; height >= startHeight && height > 0; height-- {\n\t\t// Ensure we haven't been requested to shut down before\n\t\t// processing the next height.\n\t\tselect {\n\t\tcase <-b.quit:\n\t\t\treturn nil, chainntnfs.TxNotFoundManually,\n\t\t\t\tchainntnfs.ErrChainNotifierShuttingDown\n\t\tdefault:\n\t\t}\n\n\t\tblockHash, err := b.chainConn.GetBlockHash(int64(height))\n\t\tif err != nil {\n\t\t\treturn nil, chainntnfs.TxNotFoundManually,\n\t\t\t\tfmt.Errorf(\"unable to get hash from block \"+\n\t\t\t\t\t\"with height %d\", height)\n\t\t}\n\n\t\t// TODO: fetch the neutrino filters instead.\n\t\tblock, err := b.GetBlock(blockHash)\n\t\tif err != nil {\n\t\t\treturn nil, chainntnfs.TxNotFoundManually,\n\t\t\t\tfmt.Errorf(\"unable to get block with hash \"+\n\t\t\t\t\t\"%v: %v\", blockHash, err)\n\t\t}\n\n\t\t// For every transaction in the block, check which one matches\n\t\t// our request. If we find one that does, we can dispatch its\n\t\t// confirmation details.\n\t\tfor txIndex, tx := range block.Transactions {\n\t\t\tif !confRequest.MatchesTx(tx) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\treturn &chainntnfs.TxConfirmation{\n\t\t\t\tTx:          tx,\n\t\t\t\tBlockHash:   blockHash,\n\t\t\t\tBlockHeight: height,\n\t\t\t\tTxIndex:     uint32(txIndex),\n\t\t\t\tBlock:       block,\n\t\t\t}, chainntnfs.TxFoundManually, nil\n\t\t}\n\t}\n\n\t// If we reach here, then we were not able to find the transaction\n\t// within a block, so we avoid returning an error.\n\treturn nil, chainntnfs.TxNotFoundManually, nil\n}\n\n// handleBlockConnected applies a chain update for a new block. Any watched\n// transactions included this block will processed to either send notifications\n// now or after numConfirmations confs.\n// TODO(halseth): this is reusing the neutrino notifier implementation, unify\n// them.",
      "length": 1807,
      "tokens": 242,
      "embedding": []
    },
    {
      "slug": "func (b *BtcdNotifier) handleBlockConnected(epoch chainntnfs.BlockEpoch) error {",
      "content": "func (b *BtcdNotifier) handleBlockConnected(epoch chainntnfs.BlockEpoch) error {\n\t// First, we'll fetch the raw block as we'll need to gather all the\n\t// transactions to determine whether any are relevant to our registered\n\t// clients.\n\trawBlock, err := b.GetBlock(epoch.Hash)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to get block: %v\", err)\n\t}\n\tnewBlock := &filteredBlock{\n\t\thash:    *epoch.Hash,\n\t\theight:  uint32(epoch.Height),\n\t\tblock:   btcutil.NewBlock(rawBlock),\n\t\tconnect: true,\n\t}\n\n\t// We'll then extend the txNotifier's height with the information of\n\t// this new block, which will handle all of the notification logic for\n\t// us.\n\terr = b.txNotifier.ConnectTip(newBlock.block, newBlock.height)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to connect tip: %v\", err)\n\t}\n\n\tchainntnfs.Log.Infof(\"New block: height=%v, sha=%v\", epoch.Height,\n\t\tepoch.Hash)\n\n\t// Now that we've guaranteed the new block extends the txNotifier's\n\t// current tip, we'll proceed to dispatch notifications to all of our\n\t// registered clients whom have had notifications fulfilled. Before\n\t// doing so, we'll make sure update our in memory state in order to\n\t// satisfy any client requests based upon the new block.\n\tb.bestBlock = epoch\n\n\tb.notifyBlockEpochs(\n\t\tepoch.Height, epoch.Hash, epoch.BlockHeader,\n\t)\n\n\treturn b.txNotifier.NotifyHeight(uint32(epoch.Height))\n}\n\n// notifyBlockEpochs notifies all registered block epoch clients of the newly\n// connected block to the main chain.",
      "length": 1351,
      "tokens": 190,
      "embedding": []
    },
    {
      "slug": "func (b *BtcdNotifier) notifyBlockEpochs(newHeight int32,",
      "content": "func (b *BtcdNotifier) notifyBlockEpochs(newHeight int32,\n\tnewSha *chainhash.Hash, blockHeader *wire.BlockHeader) {\n\n\tfor _, client := range b.blockEpochClients {\n\t\tb.notifyBlockEpochClient(\n\t\t\tclient, newHeight, newSha, blockHeader,\n\t\t)\n\t}\n}\n\n// notifyBlockEpochClient sends a registered block epoch client a notification\n// about a specific block.",
      "length": 281,
      "tokens": 35,
      "embedding": []
    },
    {
      "slug": "func (b *BtcdNotifier) notifyBlockEpochClient(epochClient *blockEpochRegistration,",
      "content": "func (b *BtcdNotifier) notifyBlockEpochClient(epochClient *blockEpochRegistration,\n\theight int32, sha *chainhash.Hash, blockHeader *wire.BlockHeader) {\n\n\tepoch := &chainntnfs.BlockEpoch{\n\t\tHeight:      height,\n\t\tHash:        sha,\n\t\tBlockHeader: blockHeader,\n\t}\n\n\tselect {\n\tcase epochClient.epochQueue.ChanIn() <- epoch:\n\tcase <-epochClient.cancelChan:\n\tcase <-b.quit:\n\t}\n}\n\n// RegisterSpendNtfn registers an intent to be notified once the target\n// outpoint/output script has been spent by a transaction on-chain. When\n// intending to be notified of the spend of an output script, a nil outpoint\n// must be used. The heightHint should represent the earliest height in the\n// chain of the transaction that spent the outpoint/output script.\n//\n// Once a spend of has been detected, the details of the spending event will be\n// sent across the 'Spend' channel.",
      "length": 752,
      "tokens": 112,
      "embedding": []
    },
    {
      "slug": "func (b *BtcdNotifier) RegisterSpendNtfn(outpoint *wire.OutPoint,",
      "content": "func (b *BtcdNotifier) RegisterSpendNtfn(outpoint *wire.OutPoint,\n\tpkScript []byte, heightHint uint32) (*chainntnfs.SpendEvent, error) {\n\n\t// Register the conf notification with the TxNotifier. A non-nil value\n\t// for `dispatch` will be returned if we are required to perform a\n\t// manual scan for the confirmation. Otherwise the notifier will begin\n\t// watching at tip for the transaction to confirm.\n\tntfn, err := b.txNotifier.RegisterSpend(outpoint, pkScript, heightHint)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// We'll then request the backend to notify us when it has detected the\n\t// outpoint/output script as spent.\n\t//\n\t// TODO(wilmer): use LoadFilter API instead.\n\tif outpoint == nil || *outpoint == chainntnfs.ZeroOutPoint {\n\t\t_, addrs, _, err := txscript.ExtractPkScriptAddrs(\n\t\t\tpkScript, b.chainParams,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to parse script: %v\", err)\n\t\t}\n\t\tif err := b.chainConn.NotifyReceived(addrs); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\tops := []*wire.OutPoint{outpoint}\n\t\tif err := b.chainConn.NotifySpent(ops); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// If the txNotifier didn't return any details to perform a historical\n\t// scan of the chain, then we can return early as there's nothing left\n\t// for us to do.\n\tif ntfn.HistoricalDispatch == nil {\n\t\treturn ntfn.Event, nil\n\t}\n\n\t// Otherwise, we'll need to dispatch a historical rescan to determine if\n\t// the outpoint was already spent at a previous height.\n\t//\n\t// We'll short-circuit the path when dispatching the spend of a script,\n\t// rather than an outpoint, as there aren't any additional checks we can\n\t// make for scripts.\n\tif outpoint == nil || *outpoint == chainntnfs.ZeroOutPoint {\n\t\tstartHash, err := b.chainConn.GetBlockHash(\n\t\t\tint64(ntfn.HistoricalDispatch.StartHeight),\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// TODO(wilmer): add retry logic if rescan fails?\n\t\t_, addrs, _, err := txscript.ExtractPkScriptAddrs(\n\t\t\tpkScript, b.chainParams,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to parse address: %v\", err)\n\t\t}\n\n\t\tasyncResult := b.chainConn.RescanAsync(startHash, addrs, nil)\n\t\tgo func() {\n\t\t\tif rescanErr := asyncResult.Receive(); rescanErr != nil {\n\t\t\t\tchainntnfs.Log.Errorf(\"Rescan to determine \"+\n\t\t\t\t\t\"the spend details of %v failed: %v\",\n\t\t\t\t\tntfn.HistoricalDispatch.SpendRequest,\n\t\t\t\t\trescanErr)\n\t\t\t}\n\t\t}()\n\n\t\treturn ntfn.Event, nil\n\t}\n\n\t// When dispatching spends of outpoints, there are a number of checks we\n\t// can make to start our rescan from a better height or completely avoid\n\t// it.\n\t//\n\t// We'll start by checking the backend's UTXO set to determine whether\n\t// the outpoint has been spent. If it hasn't, we can return to the\n\t// caller as well.\n\ttxOut, err := b.chainConn.GetTxOut(&outpoint.Hash, outpoint.Index, true)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif txOut != nil {\n\t\t// We'll let the txNotifier know the outpoint is still unspent\n\t\t// in order to begin updating its spend hint.\n\t\terr := b.txNotifier.UpdateSpendDetails(\n\t\t\tntfn.HistoricalDispatch.SpendRequest, nil,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn ntfn.Event, nil\n\t}\n\n\t// Since the outpoint was spent, as it no longer exists within the UTXO\n\t// set, we'll determine when it happened by scanning the chain. We'll\n\t// begin by fetching the block hash of our starting height.\n\tstartHash, err := b.chainConn.GetBlockHash(\n\t\tint64(ntfn.HistoricalDispatch.StartHeight),\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to get block hash for height \"+\n\t\t\t\"%d: %v\", ntfn.HistoricalDispatch.StartHeight, err)\n\t}\n\n\t// As a minimal optimization, we'll query the backend's transaction\n\t// index (if enabled) to determine if we have a better rescan starting\n\t// height. We can do this as the GetRawTransaction call will return the\n\t// hash of the block it was included in within the chain.\n\ttx, err := b.chainConn.GetRawTransactionVerbose(&outpoint.Hash)\n\tif err != nil {\n\t\t// Avoid returning an error if the transaction was not found to\n\t\t// proceed with fallback methods.\n\t\tjsonErr, ok := err.(*btcjson.RPCError)\n\t\tif !ok || jsonErr.Code != btcjson.ErrRPCNoTxInfo {\n\t\t\treturn nil, fmt.Errorf(\"unable to query for txid %v: %v\",\n\t\t\t\toutpoint.Hash, err)\n\t\t}\n\t}\n\n\t// If the transaction index was enabled, we'll use the block's hash to\n\t// retrieve its height and check whether it provides a better starting\n\t// point for our rescan.\n\tif tx != nil {\n\t\t// If the transaction containing the outpoint hasn't confirmed\n\t\t// on-chain, then there's no need to perform a rescan.\n\t\tif tx.BlockHash == \"\" {\n\t\t\treturn ntfn.Event, nil\n\t\t}\n\n\t\tblockHash, err := chainhash.NewHashFromStr(tx.BlockHash)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tblockHeader, err := b.chainConn.GetBlockHeaderVerbose(blockHash)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to get header for \"+\n\t\t\t\t\"block %v: %v\", blockHash, err)\n\t\t}\n\n\t\tif uint32(blockHeader.Height) > ntfn.HistoricalDispatch.StartHeight {\n\t\t\tstartHash, err = b.chainConn.GetBlockHash(\n\t\t\t\tint64(blockHeader.Height),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"unable to get block \"+\n\t\t\t\t\t\"hash for height %d: %v\",\n\t\t\t\t\tblockHeader.Height, err)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Now that we've determined the best starting point for our rescan,\n\t// we can go ahead and dispatch it.\n\t//\n\t// In order to ensure that we don't block the caller on what may be a\n\t// long rescan, we'll launch a new goroutine to handle the async result\n\t// of the rescan. We purposefully prevent from adding this goroutine to\n\t// the WaitGroup as we cannot wait for a quit signal due to the\n\t// asyncResult channel not being exposed.\n\t//\n\t// TODO(wilmer): add retry logic if rescan fails?\n\tasyncResult := b.chainConn.RescanAsync(\n\t\tstartHash, nil, []*wire.OutPoint{outpoint},\n\t)\n\tgo func() {\n\t\tif rescanErr := asyncResult.Receive(); rescanErr != nil {\n\t\t\tchainntnfs.Log.Errorf(\"Rescan to determine the spend \"+\n\t\t\t\t\"details of %v failed: %v\", outpoint, rescanErr)\n\t\t}\n\t}()\n\n\treturn ntfn.Event, nil\n}\n\n// RegisterConfirmationsNtfn registers an intent to be notified once the target\n// txid/output script has reached numConfs confirmations on-chain. When\n// intending to be notified of the confirmation of an output script, a nil txid\n// must be used. The heightHint should represent the earliest height at which\n// the txid/output script could have been included in the chain.\n//\n// Progress on the number of confirmations left can be read from the 'Updates'\n// channel. Once it has reached all of its confirmations, a notification will be\n// sent across the 'Confirmed' channel.",
      "length": 6284,
      "tokens": 971,
      "embedding": []
    },
    {
      "slug": "func (b *BtcdNotifier) RegisterConfirmationsNtfn(txid *chainhash.Hash,",
      "content": "func (b *BtcdNotifier) RegisterConfirmationsNtfn(txid *chainhash.Hash,\n\tpkScript []byte, numConfs, heightHint uint32,\n\topts ...chainntnfs.NotifierOption) (*chainntnfs.ConfirmationEvent, error) {\n\n\t// Register the conf notification with the TxNotifier. A non-nil value\n\t// for `dispatch` will be returned if we are required to perform a\n\t// manual scan for the confirmation. Otherwise the notifier will begin\n\t// watching at tip for the transaction to confirm.\n\tntfn, err := b.txNotifier.RegisterConf(\n\t\ttxid, pkScript, numConfs, heightHint, opts...,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif ntfn.HistoricalDispatch == nil {\n\t\treturn ntfn.Event, nil\n\t}\n\n\tselect {\n\tcase b.notificationRegistry <- ntfn.HistoricalDispatch:\n\t\treturn ntfn.Event, nil\n\tcase <-b.quit:\n\t\treturn nil, chainntnfs.ErrChainNotifierShuttingDown\n\t}\n}\n\n// blockEpochRegistration represents a client's intent to receive a\n// notification with each newly connected block.",
      "length": 844,
      "tokens": 114,
      "embedding": []
    },
    {
      "slug": "type blockEpochRegistration struct {",
      "content": "type blockEpochRegistration struct {\n\tepochID uint64\n\n\tepochChan chan *chainntnfs.BlockEpoch\n\n\tepochQueue *queue.ConcurrentQueue\n\n\tbestBlock *chainntnfs.BlockEpoch\n\n\terrorChan chan error\n\n\tcancelChan chan struct{}\n\n\twg sync.WaitGroup\n}\n\n// epochCancel is a message sent to the BtcdNotifier when a client wishes to\n// cancel an outstanding epoch notification that has yet to be dispatched.",
      "length": 335,
      "tokens": 44,
      "embedding": []
    },
    {
      "slug": "type epochCancel struct {",
      "content": "type epochCancel struct {\n\tepochID uint64\n}\n\n// RegisterBlockEpochNtfn returns a BlockEpochEvent which subscribes the\n// caller to receive notifications, of each new block connected to the main\n// chain. Clients have the option of passing in their best known block, which\n// the notifier uses to check if they are behind on blocks and catch them up. If\n// they do not provide one, then a notification will be dispatched immediately\n// for the current tip of the chain upon a successful registration.",
      "length": 465,
      "tokens": 80,
      "embedding": []
    },
    {
      "slug": "func (b *BtcdNotifier) RegisterBlockEpochNtfn(",
      "content": "func (b *BtcdNotifier) RegisterBlockEpochNtfn(\n\tbestBlock *chainntnfs.BlockEpoch) (*chainntnfs.BlockEpochEvent, error) {\n\n\treg := &blockEpochRegistration{\n\t\tepochQueue: queue.NewConcurrentQueue(20),\n\t\tepochChan:  make(chan *chainntnfs.BlockEpoch, 20),\n\t\tcancelChan: make(chan struct{}),\n\t\tepochID:    atomic.AddUint64(&b.epochClientCounter, 1),\n\t\tbestBlock:  bestBlock,\n\t\terrorChan:  make(chan error, 1),\n\t}\n\n\treg.epochQueue.Start()\n\n\t// Before we send the request to the main goroutine, we'll launch a new\n\t// goroutine to proxy items added to our queue to the client itself.\n\t// This ensures that all notifications are received *in order*.\n\treg.wg.Add(1)\n\tgo func() {\n\t\tdefer reg.wg.Done()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase ntfn := <-reg.epochQueue.ChanOut():\n\t\t\t\tblockNtfn := ntfn.(*chainntnfs.BlockEpoch)\n\t\t\t\tselect {\n\t\t\t\tcase reg.epochChan <- blockNtfn:\n\n\t\t\t\tcase <-reg.cancelChan:\n\t\t\t\t\treturn\n\n\t\t\t\tcase <-b.quit:\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\tcase <-reg.cancelChan:\n\t\t\t\treturn\n\n\t\t\tcase <-b.quit:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tselect {\n\tcase <-b.quit:\n\t\t// As we're exiting before the registration could be sent,\n\t\t// we'll stop the queue now ourselves.\n\t\treg.epochQueue.Stop()\n\n\t\treturn nil, errors.New(\"chainntnfs: system interrupt while \" +\n\t\t\t\"attempting to register for block epoch notification.\")\n\tcase b.notificationRegistry <- reg:\n\t\treturn &chainntnfs.BlockEpochEvent{\n\t\t\tEpochs: reg.epochChan,\n\t\t\tCancel: func() {\n\t\t\t\tcancel := &epochCancel{\n\t\t\t\t\tepochID: reg.epochID,\n\t\t\t\t}\n\n\t\t\t\t// Submit epoch cancellation to notification dispatcher.\n\t\t\t\tselect {\n\t\t\t\tcase b.notificationCancels <- cancel:\n\t\t\t\t\t// Cancellation is being handled, drain\n\t\t\t\t\t// the epoch channel until it is closed\n\t\t\t\t\t// before yielding to caller.\n\t\t\t\t\tfor {\n\t\t\t\t\t\tselect {\n\t\t\t\t\t\tcase _, ok := <-reg.epochChan:\n\t\t\t\t\t\t\tif !ok {\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase <-b.quit:\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tcase <-b.quit:\n\t\t\t\t}\n\t\t\t},\n\t\t}, nil\n\t}\n}\n\n// GetBlock is used to retrieve the block with the given hash. This function\n// wraps the blockCache's GetBlock function.",
      "length": 1906,
      "tokens": 237,
      "embedding": []
    },
    {
      "slug": "func (b *BtcdNotifier) GetBlock(hash *chainhash.Hash) (*wire.MsgBlock,",
      "content": "func (b *BtcdNotifier) GetBlock(hash *chainhash.Hash) (*wire.MsgBlock,\n\terror) {\n\n\treturn b.blockCache.GetBlock(hash, b.chainConn.GetBlock)\n}\n",
      "length": 67,
      "tokens": 6,
      "embedding": []
    }
  ]
}