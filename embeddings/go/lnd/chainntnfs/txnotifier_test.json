{
  "filepath": "../implementations/go/lnd/chainntnfs/txnotifier_test.go",
  "package": "chainntnfs_test",
  "sections": [
    {
      "slug": "type mockHintCache struct {",
      "content": "type mockHintCache struct {\n\tmu         sync.Mutex\n\tconfHints  map[chainntnfs.ConfRequest]uint32\n\tspendHints map[chainntnfs.SpendRequest]uint32\n}\n\nvar _ chainntnfs.SpendHintCache = (*mockHintCache)(nil)\nvar _ chainntnfs.ConfirmHintCache = (*mockHintCache)(nil)\n",
      "length": 226,
      "tokens": 17,
      "embedding": []
    },
    {
      "slug": "func (c *mockHintCache) CommitSpendHint(heightHint uint32,",
      "content": "func (c *mockHintCache) CommitSpendHint(heightHint uint32,\n\tspendRequests ...chainntnfs.SpendRequest) error {\n\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tfor _, spendRequest := range spendRequests {\n\t\tc.spendHints[spendRequest] = heightHint\n\t}\n\n\treturn nil\n}\n",
      "length": 182,
      "tokens": 21,
      "embedding": []
    },
    {
      "slug": "func (c *mockHintCache) QuerySpendHint(spendRequest chainntnfs.SpendRequest) (uint32, error) {",
      "content": "func (c *mockHintCache) QuerySpendHint(spendRequest chainntnfs.SpendRequest) (uint32, error) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\thint, ok := c.spendHints[spendRequest]\n\tif !ok {\n\t\treturn 0, chainntnfs.ErrSpendHintNotFound\n\t}\n\n\treturn hint, nil\n}\n",
      "length": 143,
      "tokens": 18,
      "embedding": []
    },
    {
      "slug": "func (c *mockHintCache) PurgeSpendHint(spendRequests ...chainntnfs.SpendRequest) error {",
      "content": "func (c *mockHintCache) PurgeSpendHint(spendRequests ...chainntnfs.SpendRequest) error {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tfor _, spendRequest := range spendRequests {\n\t\tdelete(c.spendHints, spendRequest)\n\t}\n\n\treturn nil\n}\n",
      "length": 127,
      "tokens": 16,
      "embedding": []
    },
    {
      "slug": "func (c *mockHintCache) CommitConfirmHint(heightHint uint32,",
      "content": "func (c *mockHintCache) CommitConfirmHint(heightHint uint32,\n\tconfRequests ...chainntnfs.ConfRequest) error {\n\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tfor _, confRequest := range confRequests {\n\t\tc.confHints[confRequest] = heightHint\n\t}\n\n\treturn nil\n}\n",
      "length": 176,
      "tokens": 21,
      "embedding": []
    },
    {
      "slug": "func (c *mockHintCache) QueryConfirmHint(confRequest chainntnfs.ConfRequest) (uint32, error) {",
      "content": "func (c *mockHintCache) QueryConfirmHint(confRequest chainntnfs.ConfRequest) (uint32, error) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\thint, ok := c.confHints[confRequest]\n\tif !ok {\n\t\treturn 0, chainntnfs.ErrConfirmHintNotFound\n\t}\n\n\treturn hint, nil\n}\n",
      "length": 143,
      "tokens": 18,
      "embedding": []
    },
    {
      "slug": "func (c *mockHintCache) PurgeConfirmHint(confRequests ...chainntnfs.ConfRequest) error {",
      "content": "func (c *mockHintCache) PurgeConfirmHint(confRequests ...chainntnfs.ConfRequest) error {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tfor _, confRequest := range confRequests {\n\t\tdelete(c.confHints, confRequest)\n\t}\n\n\treturn nil\n}\n",
      "length": 123,
      "tokens": 16,
      "embedding": []
    },
    {
      "slug": "func newMockHintCache() *mockHintCache {",
      "content": "func newMockHintCache() *mockHintCache {\n\treturn &mockHintCache{\n\t\tconfHints:  make(map[chainntnfs.ConfRequest]uint32),\n\t\tspendHints: make(map[chainntnfs.SpendRequest]uint32),\n\t}\n}\n\n// TestTxNotifierRegistrationValidation ensures that we are not able to register\n// requests with invalid parameters.",
      "length": 251,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func TestTxNotifierRegistrationValidation(t *testing.T) {",
      "content": "func TestTxNotifierRegistrationValidation(t *testing.T) {\n\tt.Parallel()\n\n\ttestCases := []struct {\n\t\tname       string\n\t\tpkScript   []byte\n\t\tnumConfs   uint32\n\t\theightHint uint32\n\t\tcheckSpend bool\n\t\terr        error\n\t}{\n\t\t{\n\t\t\tname:       \"empty output script\",\n\t\t\tpkScript:   nil,\n\t\t\tnumConfs:   1,\n\t\t\theightHint: 1,\n\t\t\tcheckSpend: true,\n\t\t\terr:        chainntnfs.ErrNoScript,\n\t\t},\n\t\t{\n\t\t\tname:       \"zero num confs\",\n\t\t\tpkScript:   testRawScript,\n\t\t\tnumConfs:   0,\n\t\t\theightHint: 1,\n\t\t\terr:        chainntnfs.ErrNumConfsOutOfRange,\n\t\t},\n\t\t{\n\t\t\tname:       \"exceed max num confs\",\n\t\t\tpkScript:   testRawScript,\n\t\t\tnumConfs:   chainntnfs.MaxNumConfs + 1,\n\t\t\theightHint: 1,\n\t\t\terr:        chainntnfs.ErrNumConfsOutOfRange,\n\t\t},\n\t\t{\n\t\t\tname:       \"empty height hint\",\n\t\t\tpkScript:   testRawScript,\n\t\t\tnumConfs:   1,\n\t\t\theightHint: 0,\n\t\t\tcheckSpend: true,\n\t\t\terr:        chainntnfs.ErrNoHeightHint,\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\ttestCase := testCase\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\thintCache := newMockHintCache()\n\t\t\tn := chainntnfs.NewTxNotifier(\n\t\t\t\t10, chainntnfs.ReorgSafetyLimit, hintCache, hintCache,\n\t\t\t)\n\n\t\t\t_, err := n.RegisterConf(\n\t\t\t\t&chainntnfs.ZeroHash, testCase.pkScript,\n\t\t\t\ttestCase.numConfs, testCase.heightHint,\n\t\t\t)\n\t\t\tif err != testCase.err {\n\t\t\t\tt.Fatalf(\"conf registration expected error \"+\n\t\t\t\t\t\"\\\"%v\\\", got \\\"%v\\\"\", testCase.err, err)\n\t\t\t}\n\n\t\t\tif !testCase.checkSpend {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t_, err = n.RegisterSpend(\n\t\t\t\t&chainntnfs.ZeroOutPoint, testCase.pkScript,\n\t\t\t\ttestCase.heightHint,\n\t\t\t)\n\t\t\tif err != testCase.err {\n\t\t\t\tt.Fatalf(\"spend registration expected error \"+\n\t\t\t\t\t\"\\\"%v\\\", got \\\"%v\\\"\", testCase.err, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestTxNotifierFutureConfDispatch tests that the TxNotifier dispatches\n// registered notifications when a transaction confirms after registration.",
      "length": 1707,
      "tokens": 180,
      "embedding": []
    },
    {
      "slug": "func TestTxNotifierFutureConfDispatch(t *testing.T) {",
      "content": "func TestTxNotifierFutureConfDispatch(t *testing.T) {\n\tt.Parallel()\n\n\tconst (\n\t\ttx1NumConfs uint32 = 1\n\t\ttx2NumConfs uint32 = 2\n\t)\n\n\thintCache := newMockHintCache()\n\tn := chainntnfs.NewTxNotifier(\n\t\t10, chainntnfs.ReorgSafetyLimit, hintCache, hintCache,\n\t)\n\n\t// Create the test transactions and register them with the TxNotifier\n\t// before including them in a block to receive future\n\t// notifications.\n\ttx1 := wire.MsgTx{Version: 1}\n\ttx1.AddTxOut(&wire.TxOut{PkScript: testRawScript})\n\ttx1Hash := tx1.TxHash()\n\tntfn1, err := n.RegisterConf(&tx1Hash, testRawScript, tx1NumConfs, 1)\n\trequire.NoError(t, err, \"unable to register ntfn\")\n\n\ttx2 := wire.MsgTx{Version: 2}\n\ttx2.AddTxOut(&wire.TxOut{PkScript: testRawScript})\n\ttx2Hash := tx2.TxHash()\n\tntfn2, err := n.RegisterConf(&tx2Hash, testRawScript, tx2NumConfs, 1)\n\trequire.NoError(t, err, \"unable to register ntfn\")\n\n\t// We should not receive any notifications from both transactions\n\t// since they have not been included in a block yet.\n\tselect {\n\tcase <-ntfn1.Event.Updates:\n\t\tt.Fatal(\"Received unexpected confirmation update for tx1\")\n\tcase txConf := <-ntfn1.Event.Confirmed:\n\t\tt.Fatalf(\"Received unexpected confirmation for tx1: %v\", txConf)\n\tdefault:\n\t}\n\n\tselect {\n\tcase <-ntfn2.Event.Updates:\n\t\tt.Fatal(\"Received unexpected confirmation update for tx2\")\n\tcase txConf := <-ntfn2.Event.Confirmed:\n\t\tt.Fatalf(\"Received unexpected confirmation for tx2: %v\", txConf)\n\tdefault:\n\t}\n\n\t// Include the transactions in a block and add it to the TxNotifier.\n\t// This should confirm tx1, but not tx2.\n\tblock1 := btcutil.NewBlock(&wire.MsgBlock{\n\t\tTransactions: []*wire.MsgTx{&tx1, &tx2},\n\t})\n\n\terr = n.ConnectTip(block1, 11)\n\trequire.NoError(t, err, \"Failed to connect block\")\n\tif err := n.NotifyHeight(11); err != nil {\n\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t}\n\n\t// We should only receive one update for tx1 since it only requires\n\t// one confirmation and it already met it.\n\tselect {\n\tcase numConfsLeft := <-ntfn1.Event.Updates:\n\t\tconst expected = 0\n\t\tif numConfsLeft != expected {\n\t\t\tt.Fatalf(\"Received incorrect confirmation update: tx1 \"+\n\t\t\t\t\"expected %d confirmations left, got %d\",\n\t\t\t\texpected, numConfsLeft)\n\t\t}\n\tdefault:\n\t\tt.Fatal(\"Expected confirmation update for tx1\")\n\t}\n\n\t// A confirmation notification for this transaction should be dispatched,\n\t// as it only required one confirmation.\n\tselect {\n\tcase txConf := <-ntfn1.Event.Confirmed:\n\t\texpectedConf := chainntnfs.TxConfirmation{\n\t\t\tBlockHash:   block1.Hash(),\n\t\t\tBlockHeight: 11,\n\t\t\tTxIndex:     0,\n\t\t\tTx:          &tx1,\n\t\t}\n\t\tassertConfDetails(t, txConf, &expectedConf)\n\tdefault:\n\t\tt.Fatalf(\"Expected confirmation for tx1\")\n\t}\n\n\t// We should only receive one update for tx2 since it only has one\n\t// confirmation so far and it requires two.\n\tselect {\n\tcase numConfsLeft := <-ntfn2.Event.Updates:\n\t\tconst expected = 1\n\t\tif numConfsLeft != expected {\n\t\t\tt.Fatalf(\"Received incorrect confirmation update: tx2 \"+\n\t\t\t\t\"expected %d confirmations left, got %d\",\n\t\t\t\texpected, numConfsLeft)\n\t\t}\n\tdefault:\n\t\tt.Fatal(\"Expected confirmation update for tx2\")\n\t}\n\n\t// A confirmation notification for tx2 should not be dispatched yet, as\n\t// it requires one more confirmation.\n\tselect {\n\tcase txConf := <-ntfn2.Event.Confirmed:\n\t\tt.Fatalf(\"Received unexpected confirmation for tx2: %v\", txConf)\n\tdefault:\n\t}\n\n\t// Create a new block and add it to the TxNotifier at the next height.\n\t// This should confirm tx2.\n\tblock2 := btcutil.NewBlock(&wire.MsgBlock{})\n\terr = n.ConnectTip(block2, 12)\n\trequire.NoError(t, err, \"Failed to connect block\")\n\tif err := n.NotifyHeight(12); err != nil {\n\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t}\n\n\t// We should not receive any event notifications for tx1 since it has\n\t// already been confirmed.\n\tselect {\n\tcase <-ntfn1.Event.Updates:\n\t\tt.Fatal(\"Received unexpected confirmation update for tx1\")\n\tcase txConf := <-ntfn1.Event.Confirmed:\n\t\tt.Fatalf(\"Received unexpected confirmation for tx1: %v\", txConf)\n\tdefault:\n\t}\n\n\t// We should only receive one update since the last at the new height,\n\t// indicating how many confirmations are still left.\n\tselect {\n\tcase numConfsLeft := <-ntfn2.Event.Updates:\n\t\tconst expected = 0\n\t\tif numConfsLeft != expected {\n\t\t\tt.Fatalf(\"Received incorrect confirmation update: tx2 \"+\n\t\t\t\t\"expected %d confirmations left, got %d\",\n\t\t\t\texpected, numConfsLeft)\n\t\t}\n\tdefault:\n\t\tt.Fatal(\"Expected confirmation update for tx2\")\n\t}\n\n\t// A confirmation notification for tx2 should be dispatched, since it\n\t// now meets its required number of confirmations.\n\tselect {\n\tcase txConf := <-ntfn2.Event.Confirmed:\n\t\texpectedConf := chainntnfs.TxConfirmation{\n\t\t\tBlockHash:   block1.Hash(),\n\t\t\tBlockHeight: 11,\n\t\t\tTxIndex:     1,\n\t\t\tTx:          &tx2,\n\t\t}\n\t\tassertConfDetails(t, txConf, &expectedConf)\n\tdefault:\n\t\tt.Fatalf(\"Expected confirmation for tx2\")\n\t}\n}\n\n// TestTxNotifierHistoricalConfDispatch tests that the TxNotifier dispatches\n// registered notifications when the transaction is confirmed before\n// registration.",
      "length": 4789,
      "tokens": 616,
      "embedding": []
    },
    {
      "slug": "func TestTxNotifierHistoricalConfDispatch(t *testing.T) {",
      "content": "func TestTxNotifierHistoricalConfDispatch(t *testing.T) {\n\tt.Parallel()\n\n\tconst (\n\t\ttx1NumConfs uint32 = 1\n\t\ttx2NumConfs uint32 = 3\n\t)\n\n\tvar (\n\t\ttx1 = wire.MsgTx{Version: 1}\n\t\ttx2 = wire.MsgTx{Version: 2}\n\t\ttx3 = wire.MsgTx{Version: 3}\n\t)\n\n\thintCache := newMockHintCache()\n\tn := chainntnfs.NewTxNotifier(\n\t\t10, chainntnfs.ReorgSafetyLimit, hintCache, hintCache,\n\t)\n\n\t// Create the test transactions at a height before the TxNotifier's\n\t// starting height so that they are confirmed once registering them.\n\ttx1Hash := tx1.TxHash()\n\tntfn1, err := n.RegisterConf(&tx1Hash, testRawScript, tx1NumConfs, 1)\n\trequire.NoError(t, err, \"unable to register ntfn\")\n\n\ttx2Hash := tx2.TxHash()\n\tntfn2, err := n.RegisterConf(&tx2Hash, testRawScript, tx2NumConfs, 1)\n\trequire.NoError(t, err, \"unable to register ntfn\")\n\n\t// Update tx1 with its confirmation details. We should only receive one\n\t// update since it only requires one confirmation and it already met it.\n\ttxConf1 := chainntnfs.TxConfirmation{\n\t\tBlockHash:   &chainntnfs.ZeroHash,\n\t\tBlockHeight: 9,\n\t\tTxIndex:     1,\n\t\tTx:          &tx1,\n\t}\n\terr = n.UpdateConfDetails(ntfn1.HistoricalDispatch.ConfRequest, &txConf1)\n\trequire.NoError(t, err, \"unable to update conf details\")\n\tselect {\n\tcase numConfsLeft := <-ntfn1.Event.Updates:\n\t\tconst expected = 0\n\t\tif numConfsLeft != expected {\n\t\t\tt.Fatalf(\"Received incorrect confirmation update: tx1 \"+\n\t\t\t\t\"expected %d confirmations left, got %d\",\n\t\t\t\texpected, numConfsLeft)\n\t\t}\n\tdefault:\n\t\tt.Fatal(\"Expected confirmation update for tx1\")\n\t}\n\n\t// A confirmation notification for tx1 should also be dispatched.\n\tselect {\n\tcase txConf := <-ntfn1.Event.Confirmed:\n\t\tassertConfDetails(t, txConf, &txConf1)\n\tdefault:\n\t\tt.Fatalf(\"Expected confirmation for tx1\")\n\t}\n\n\t// Update tx2 with its confirmation details. This should not trigger a\n\t// confirmation notification since it hasn't reached its required number\n\t// of confirmations, but we should receive a confirmation update\n\t// indicating how many confirmation are left.\n\ttxConf2 := chainntnfs.TxConfirmation{\n\t\tBlockHash:   &chainntnfs.ZeroHash,\n\t\tBlockHeight: 9,\n\t\tTxIndex:     2,\n\t\tTx:          &tx2,\n\t}\n\terr = n.UpdateConfDetails(ntfn2.HistoricalDispatch.ConfRequest, &txConf2)\n\trequire.NoError(t, err, \"unable to update conf details\")\n\tselect {\n\tcase numConfsLeft := <-ntfn2.Event.Updates:\n\t\tconst expected = 1\n\t\tif numConfsLeft != expected {\n\t\t\tt.Fatalf(\"Received incorrect confirmation update: tx2 \"+\n\t\t\t\t\"expected %d confirmations left, got %d\",\n\t\t\t\texpected, numConfsLeft)\n\t\t}\n\tdefault:\n\t\tt.Fatal(\"Expected confirmation update for tx2\")\n\t}\n\n\tselect {\n\tcase txConf := <-ntfn2.Event.Confirmed:\n\t\tt.Fatalf(\"Received unexpected confirmation for tx2: %v\", txConf)\n\tdefault:\n\t}\n\n\t// Create a new block and add it to the TxNotifier at the next height.\n\t// This should confirm tx2.\n\tblock := btcutil.NewBlock(&wire.MsgBlock{\n\t\tTransactions: []*wire.MsgTx{&tx3},\n\t})\n\n\terr = n.ConnectTip(block, 11)\n\trequire.NoError(t, err, \"Failed to connect block\")\n\tif err := n.NotifyHeight(11); err != nil {\n\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t}\n\n\t// We should not receive any event notifications for tx1 since it has\n\t// already been confirmed.\n\tselect {\n\tcase <-ntfn1.Event.Updates:\n\t\tt.Fatal(\"Received unexpected confirmation update for tx1\")\n\tcase txConf := <-ntfn1.Event.Confirmed:\n\t\tt.Fatalf(\"Received unexpected confirmation for tx1: %v\", txConf)\n\tdefault:\n\t}\n\n\t// We should only receive one update for tx2 since the last one,\n\t// indicating how many confirmations are still left.\n\tselect {\n\tcase numConfsLeft := <-ntfn2.Event.Updates:\n\t\tconst expected = 0\n\t\tif numConfsLeft != expected {\n\t\t\tt.Fatalf(\"Received incorrect confirmation update: tx2 \"+\n\t\t\t\t\"expected %d confirmations left, got %d\",\n\t\t\t\texpected, numConfsLeft)\n\t\t}\n\tdefault:\n\t\tt.Fatal(\"Expected confirmation update for tx2\")\n\t}\n\n\t// A confirmation notification for tx2 should be dispatched, as it met\n\t// its required number of confirmations.\n\tselect {\n\tcase txConf := <-ntfn2.Event.Confirmed:\n\t\tassertConfDetails(t, txConf, &txConf2)\n\tdefault:\n\t\tt.Fatalf(\"Expected confirmation for tx2\")\n\t}\n}\n\n// TestTxNotifierFutureSpendDispatch tests that the TxNotifier dispatches\n// registered notifications when an outpoint is spent after registration.",
      "length": 4060,
      "tokens": 516,
      "embedding": []
    },
    {
      "slug": "func TestTxNotifierFutureSpendDispatch(t *testing.T) {",
      "content": "func TestTxNotifierFutureSpendDispatch(t *testing.T) {\n\tt.Parallel()\n\n\thintCache := newMockHintCache()\n\tn := chainntnfs.NewTxNotifier(\n\t\t10, chainntnfs.ReorgSafetyLimit, hintCache, hintCache,\n\t)\n\n\t// We'll start off by registering for a spend notification of an\n\t// outpoint.\n\top := wire.OutPoint{Index: 1}\n\tntfn, err := n.RegisterSpend(&op, testRawScript, 1)\n\trequire.NoError(t, err, \"unable to register spend ntfn\")\n\n\t// We should not receive a notification as the outpoint has not been\n\t// spent yet.\n\tselect {\n\tcase <-ntfn.Event.Spend:\n\t\tt.Fatal(\"received unexpected spend notification\")\n\tdefault:\n\t}\n\n\t// Construct the details of the spending transaction of the outpoint\n\t// above. We'll include it in the next block, which should trigger a\n\t// spend notification.\n\tspendTx := wire.NewMsgTx(2)\n\tspendTx.AddTxIn(&wire.TxIn{\n\t\tPreviousOutPoint: op,\n\t\tSignatureScript:  testSigScript,\n\t})\n\tspendTxHash := spendTx.TxHash()\n\tblock := btcutil.NewBlock(&wire.MsgBlock{\n\t\tTransactions: []*wire.MsgTx{spendTx},\n\t})\n\terr = n.ConnectTip(block, 11)\n\trequire.NoError(t, err, \"unable to connect block\")\n\tif err := n.NotifyHeight(11); err != nil {\n\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t}\n\n\texpectedSpendDetails := &chainntnfs.SpendDetail{\n\t\tSpentOutPoint:     &op,\n\t\tSpenderTxHash:     &spendTxHash,\n\t\tSpendingTx:        spendTx,\n\t\tSpenderInputIndex: 0,\n\t\tSpendingHeight:    11,\n\t}\n\n\t// Ensure that the details of the notification match as expected.\n\tselect {\n\tcase spendDetails := <-ntfn.Event.Spend:\n\t\tassertSpendDetails(t, spendDetails, expectedSpendDetails)\n\tdefault:\n\t\tt.Fatal(\"expected to receive spend details\")\n\t}\n\n\t// Finally, we'll ensure that if the spending transaction has also been\n\t// spent, then we don't receive another spend notification.\n\tprevOut := wire.OutPoint{Hash: spendTxHash, Index: 0}\n\tspendOfSpend := wire.NewMsgTx(2)\n\tspendOfSpend.AddTxIn(&wire.TxIn{\n\t\tPreviousOutPoint: prevOut,\n\t\tSignatureScript:  testSigScript,\n\t})\n\tblock = btcutil.NewBlock(&wire.MsgBlock{\n\t\tTransactions: []*wire.MsgTx{spendOfSpend},\n\t})\n\terr = n.ConnectTip(block, 12)\n\trequire.NoError(t, err, \"unable to connect block\")\n\tif err := n.NotifyHeight(12); err != nil {\n\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t}\n\n\tselect {\n\tcase <-ntfn.Event.Spend:\n\t\tt.Fatal(\"received unexpected spend notification\")\n\tdefault:\n\t}\n}\n\n// TestTxNotifierFutureConfDispatchReuseSafe tests that the notifier does not\n// misbehave even if two confirmation requests for the same script are issued\n// at different block heights (which means funds are being sent to the same\n// script multiple times).",
      "length": 2460,
      "tokens": 297,
      "embedding": []
    },
    {
      "slug": "func TestTxNotifierFutureConfDispatchReuseSafe(t *testing.T) {",
      "content": "func TestTxNotifierFutureConfDispatchReuseSafe(t *testing.T) {\n\tt.Parallel()\n\n\tcurrentBlock := uint32(10)\n\thintCache := newMockHintCache()\n\tn := chainntnfs.NewTxNotifier(\n\t\tcurrentBlock, 2, hintCache, hintCache,\n\t)\n\n\t// We'll register a TX that sends to our test script and put it into a\n\t// block. Additionally we register a notification request for just the\n\t// script which should also be confirmed with that block.\n\ttx1 := wire.MsgTx{Version: 1}\n\ttx1.AddTxOut(&wire.TxOut{PkScript: testRawScript})\n\ttx1Hash := tx1.TxHash()\n\tntfn1, err := n.RegisterConf(&tx1Hash, testRawScript, 1, 1)\n\trequire.NoError(t, err, \"unable to register ntfn\")\n\tscriptNtfn1, err := n.RegisterConf(nil, testRawScript, 1, 1)\n\trequire.NoError(t, err, \"unable to register ntfn\")\n\tblock := btcutil.NewBlock(&wire.MsgBlock{\n\t\tTransactions: []*wire.MsgTx{&tx1},\n\t})\n\tcurrentBlock++\n\terr = n.ConnectTip(block, currentBlock)\n\trequire.NoError(t, err, \"unable to connect block\")\n\tif err := n.NotifyHeight(currentBlock); err != nil {\n\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t}\n\n\t// Expect an update and confirmation of TX 1 at this point. We save the\n\t// confirmation details because we expect to receive the same details\n\t// for all further registrations.\n\tvar confDetails *chainntnfs.TxConfirmation\n\tselect {\n\tcase <-ntfn1.Event.Updates:\n\tdefault:\n\t\tt.Fatal(\"expected update of TX 1\")\n\t}\n\tselect {\n\tcase confDetails = <-ntfn1.Event.Confirmed:\n\t\tif confDetails.BlockHeight != currentBlock {\n\t\t\tt.Fatalf(\"expected TX to be confirmed in latest block\")\n\t\t}\n\tdefault:\n\t\tt.Fatal(\"expected confirmation of TX 1\")\n\t}\n\n\t// The notification for the script should also have received a\n\t// confirmation.\n\tselect {\n\tcase <-scriptNtfn1.Event.Updates:\n\tdefault:\n\t\tt.Fatal(\"expected update of script ntfn\")\n\t}\n\tselect {\n\tcase details := <-scriptNtfn1.Event.Confirmed:\n\t\tassertConfDetails(t, details, confDetails)\n\tdefault:\n\t\tt.Fatal(\"expected update of script ntfn\")\n\t}\n\n\t// Now register a second TX that spends to two outputs with the same\n\t// script so we have a different TXID. And again register a confirmation\n\t// for just the script.\n\ttx2 := wire.MsgTx{Version: 1}\n\ttx2.AddTxOut(&wire.TxOut{PkScript: testRawScript})\n\ttx2.AddTxOut(&wire.TxOut{PkScript: testRawScript})\n\ttx2Hash := tx2.TxHash()\n\tntfn2, err := n.RegisterConf(&tx2Hash, testRawScript, 1, 1)\n\trequire.NoError(t, err, \"unable to register ntfn\")\n\tscriptNtfn2, err := n.RegisterConf(nil, testRawScript, 1, 1)\n\trequire.NoError(t, err, \"unable to register ntfn\")\n\tblock2 := btcutil.NewBlock(&wire.MsgBlock{\n\t\tTransactions: []*wire.MsgTx{&tx2},\n\t})\n\tcurrentBlock++\n\terr = n.ConnectTip(block2, currentBlock)\n\trequire.NoError(t, err, \"unable to connect block\")\n\tif err := n.NotifyHeight(currentBlock); err != nil {\n\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t}\n\n\t// Transaction 2 should get a confirmation here too. Since it was\n\t// a different TXID we wouldn't get the cached details here but the TX\n\t// should be confirmed right away still.\n\tselect {\n\tcase <-ntfn2.Event.Updates:\n\tdefault:\n\t\tt.Fatal(\"expected update of TX 2\")\n\t}\n\tselect {\n\tcase details := <-ntfn2.Event.Confirmed:\n\t\tif details.BlockHeight != currentBlock {\n\t\t\tt.Fatalf(\"expected TX to be confirmed in latest block\")\n\t\t}\n\tdefault:\n\t\tt.Fatal(\"expected update of TX 2\")\n\t}\n\n\t// The second notification for the script should also have received a\n\t// confirmation. Since it's the same script, we expect to get the cached\n\t// details from the first TX back immediately. Nothing should be\n\t// registered at the notifier for the current block height for that\n\t// script any more.\n\tselect {\n\tcase <-scriptNtfn2.Event.Updates:\n\tdefault:\n\t\tt.Fatal(\"expected update of script ntfn\")\n\t}\n\tselect {\n\tcase details := <-scriptNtfn2.Event.Confirmed:\n\t\tassertConfDetails(t, details, confDetails)\n\tdefault:\n\t\tt.Fatal(\"expected update of script ntfn\")\n\t}\n\n\t// Finally, mine a few empty blocks and expect both TXs to be confirmed.\n\tfor currentBlock < 15 {\n\t\tblock := btcutil.NewBlock(&wire.MsgBlock{})\n\t\tcurrentBlock++\n\t\terr = n.ConnectTip(block, currentBlock)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to connect block: %v\", err)\n\t\t}\n\t\tif err := n.NotifyHeight(currentBlock); err != nil {\n\t\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t\t}\n\t}\n\n\t// Events for both confirmation requests should have been dispatched.\n\tselect {\n\tcase <-ntfn1.Event.Done:\n\tdefault:\n\t\tt.Fatal(\"expected notifications for TX 1 to be done\")\n\t}\n\tselect {\n\tcase <-ntfn2.Event.Done:\n\tdefault:\n\t\tt.Fatal(\"expected notifications for TX 2 to be done\")\n\t}\n}\n\n// TestTxNotifierHistoricalSpendDispatch tests that the TxNotifier dispatches\n// registered notifications when an outpoint is spent before registration.",
      "length": 4473,
      "tokens": 593,
      "embedding": []
    },
    {
      "slug": "func TestTxNotifierHistoricalSpendDispatch(t *testing.T) {",
      "content": "func TestTxNotifierHistoricalSpendDispatch(t *testing.T) {\n\tt.Parallel()\n\n\tconst startingHeight = 10\n\n\thintCache := newMockHintCache()\n\tn := chainntnfs.NewTxNotifier(\n\t\tstartingHeight, chainntnfs.ReorgSafetyLimit, hintCache,\n\t\thintCache,\n\t)\n\n\t// We'll start by constructing the spending details of the outpoint\n\t// below.\n\tspentOutpoint := wire.OutPoint{Index: 1}\n\tspendTx := wire.NewMsgTx(2)\n\tspendTx.AddTxIn(&wire.TxIn{\n\t\tPreviousOutPoint: spentOutpoint,\n\t\tSignatureScript:  testSigScript,\n\t})\n\tspendTxHash := spendTx.TxHash()\n\n\texpectedSpendDetails := &chainntnfs.SpendDetail{\n\t\tSpentOutPoint:     &spentOutpoint,\n\t\tSpenderTxHash:     &spendTxHash,\n\t\tSpendingTx:        spendTx,\n\t\tSpenderInputIndex: 0,\n\t\tSpendingHeight:    startingHeight - 1,\n\t}\n\n\t// We'll register for a spend notification of the outpoint and ensure\n\t// that a notification isn't dispatched.\n\tntfn, err := n.RegisterSpend(&spentOutpoint, testRawScript, 1)\n\trequire.NoError(t, err, \"unable to register spend ntfn\")\n\n\tselect {\n\tcase <-ntfn.Event.Spend:\n\t\tt.Fatal(\"received unexpected spend notification\")\n\tdefault:\n\t}\n\n\t// Because we're interested in testing the case of a historical spend,\n\t// we'll hand off the spending details of the outpoint to the notifier\n\t// as it is not possible for it to view historical events in the chain.\n\t// By doing this, we replicate the functionality of the ChainNotifier.\n\terr = n.UpdateSpendDetails(\n\t\tntfn.HistoricalDispatch.SpendRequest, expectedSpendDetails,\n\t)\n\trequire.NoError(t, err, \"unable to update spend details\")\n\n\t// Now that we have the spending details, we should receive a spend\n\t// notification. We'll ensure that the details match as intended.\n\tselect {\n\tcase spendDetails := <-ntfn.Event.Spend:\n\t\tassertSpendDetails(t, spendDetails, expectedSpendDetails)\n\tdefault:\n\t\tt.Fatalf(\"expected to receive spend details\")\n\t}\n\n\t// Finally, we'll ensure that if the spending transaction has also been\n\t// spent, then we don't receive another spend notification.\n\tprevOut := wire.OutPoint{Hash: spendTxHash, Index: 0}\n\tspendOfSpend := wire.NewMsgTx(2)\n\tspendOfSpend.AddTxIn(&wire.TxIn{\n\t\tPreviousOutPoint: prevOut,\n\t\tSignatureScript:  testSigScript,\n\t})\n\tblock := btcutil.NewBlock(&wire.MsgBlock{\n\t\tTransactions: []*wire.MsgTx{spendOfSpend},\n\t})\n\terr = n.ConnectTip(block, startingHeight+1)\n\trequire.NoError(t, err, \"unable to connect block\")\n\tif err := n.NotifyHeight(startingHeight + 1); err != nil {\n\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t}\n\n\tselect {\n\tcase <-ntfn.Event.Spend:\n\t\tt.Fatal(\"received unexpected spend notification\")\n\tdefault:\n\t}\n}\n\n// TestTxNotifierMultipleHistoricalRescans ensures that we don't attempt to\n// request multiple historical confirmation rescans per transactions.",
      "length": 2584,
      "tokens": 301,
      "embedding": []
    },
    {
      "slug": "func TestTxNotifierMultipleHistoricalConfRescans(t *testing.T) {",
      "content": "func TestTxNotifierMultipleHistoricalConfRescans(t *testing.T) {\n\tt.Parallel()\n\n\tconst startingHeight = 10\n\thintCache := newMockHintCache()\n\tn := chainntnfs.NewTxNotifier(\n\t\tstartingHeight, chainntnfs.ReorgSafetyLimit, hintCache,\n\t\thintCache,\n\t)\n\n\t// The first registration for a transaction in the notifier should\n\t// request a historical confirmation rescan as it does not have a\n\t// historical view of the chain.\n\tntfn1, err := n.RegisterConf(&chainntnfs.ZeroHash, testRawScript, 1, 1)\n\trequire.NoError(t, err, \"unable to register spend ntfn\")\n\tif ntfn1.HistoricalDispatch == nil {\n\t\tt.Fatal(\"expected to receive historical dispatch request\")\n\t}\n\n\t// We'll register another confirmation notification for the same\n\t// transaction. This should not request a historical confirmation rescan\n\t// since the first one is still pending.\n\tntfn2, err := n.RegisterConf(&chainntnfs.ZeroHash, testRawScript, 1, 1)\n\trequire.NoError(t, err, \"unable to register spend ntfn\")\n\tif ntfn2.HistoricalDispatch != nil {\n\t\tt.Fatal(\"received unexpected historical rescan request\")\n\t}\n\n\t// Finally, we'll mark the ongoing historical rescan as complete and\n\t// register another notification. We should also expect not to see a\n\t// historical rescan request since the confirmation details should be\n\t// cached.\n\tconfDetails := &chainntnfs.TxConfirmation{\n\t\tBlockHeight: startingHeight - 1,\n\t}\n\terr = n.UpdateConfDetails(ntfn1.HistoricalDispatch.ConfRequest, confDetails)\n\trequire.NoError(t, err, \"unable to update conf details\")\n\n\tntfn3, err := n.RegisterConf(&chainntnfs.ZeroHash, testRawScript, 1, 1)\n\trequire.NoError(t, err, \"unable to register spend ntfn\")\n\tif ntfn3.HistoricalDispatch != nil {\n\t\tt.Fatal(\"received unexpected historical rescan request\")\n\t}\n}\n\n// TestTxNotifierMultipleHistoricalRescans ensures that we don't attempt to\n// request multiple historical spend rescans per outpoints.",
      "length": 1765,
      "tokens": 219,
      "embedding": []
    },
    {
      "slug": "func TestTxNotifierMultipleHistoricalSpendRescans(t *testing.T) {",
      "content": "func TestTxNotifierMultipleHistoricalSpendRescans(t *testing.T) {\n\tt.Parallel()\n\n\tconst startingHeight = 10\n\thintCache := newMockHintCache()\n\tn := chainntnfs.NewTxNotifier(\n\t\tstartingHeight, chainntnfs.ReorgSafetyLimit, hintCache,\n\t\thintCache,\n\t)\n\n\t// The first registration for an outpoint in the notifier should request\n\t// a historical spend rescan as it does not have a historical view of\n\t// the chain.\n\top := wire.OutPoint{Index: 1}\n\tntfn1, err := n.RegisterSpend(&op, testRawScript, 1)\n\trequire.NoError(t, err, \"unable to register spend ntfn\")\n\tif ntfn1.HistoricalDispatch == nil {\n\t\tt.Fatal(\"expected to receive historical dispatch request\")\n\t}\n\n\t// We'll register another spend notification for the same outpoint. This\n\t// should not request a historical spend rescan since the first one is\n\t// still pending.\n\tntfn2, err := n.RegisterSpend(&op, testRawScript, 1)\n\trequire.NoError(t, err, \"unable to register spend ntfn\")\n\tif ntfn2.HistoricalDispatch != nil {\n\t\tt.Fatal(\"received unexpected historical rescan request\")\n\t}\n\n\t// Finally, we'll mark the ongoing historical rescan as complete and\n\t// register another notification. We should also expect not to see a\n\t// historical rescan request since the confirmation details should be\n\t// cached.\n\tspendDetails := &chainntnfs.SpendDetail{\n\t\tSpentOutPoint:     &op,\n\t\tSpenderTxHash:     &chainntnfs.ZeroHash,\n\t\tSpendingTx:        wire.NewMsgTx(2),\n\t\tSpenderInputIndex: 0,\n\t\tSpendingHeight:    startingHeight - 1,\n\t}\n\terr = n.UpdateSpendDetails(\n\t\tntfn1.HistoricalDispatch.SpendRequest, spendDetails,\n\t)\n\trequire.NoError(t, err, \"unable to update spend details\")\n\n\tntfn3, err := n.RegisterSpend(&op, testRawScript, 1)\n\trequire.NoError(t, err, \"unable to register spend ntfn\")\n\tif ntfn3.HistoricalDispatch != nil {\n\t\tt.Fatal(\"received unexpected historical rescan request\")\n\t}\n}\n\n// TestTxNotifierMultipleHistoricalNtfns ensures that the TxNotifier will only\n// request one rescan for a transaction/outpoint when having multiple client\n// registrations. Once the rescan has completed and retrieved the\n// confirmation/spend details, a notification should be dispatched to _all_\n// clients.",
      "length": 2023,
      "tokens": 255,
      "embedding": []
    },
    {
      "slug": "func TestTxNotifierMultipleHistoricalNtfns(t *testing.T) {",
      "content": "func TestTxNotifierMultipleHistoricalNtfns(t *testing.T) {\n\tt.Parallel()\n\n\tconst (\n\t\tnumNtfns       = 5\n\t\tstartingHeight = 10\n\t)\n\n\thintCache := newMockHintCache()\n\tn := chainntnfs.NewTxNotifier(\n\t\tstartingHeight, chainntnfs.ReorgSafetyLimit, hintCache,\n\t\thintCache,\n\t)\n\n\tvar txid chainhash.Hash\n\tcopy(txid[:], bytes.Repeat([]byte{0x01}, 32))\n\n\t// We'll start off by registered 5 clients for a confirmation\n\t// notification on the same transaction.\n\tconfNtfns := make([]*chainntnfs.ConfRegistration, numNtfns)\n\tfor i := uint64(0); i < numNtfns; i++ {\n\t\tntfn, err := n.RegisterConf(&txid, testRawScript, 1, 1)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to register conf ntfn #%d: %v\", i, err)\n\t\t}\n\t\tconfNtfns[i] = ntfn\n\t}\n\n\t// Ensure none of them have received the confirmation details.\n\tfor i, ntfn := range confNtfns {\n\t\tselect {\n\t\tcase <-ntfn.Event.Confirmed:\n\t\t\tt.Fatalf(\"request #%d received unexpected confirmation \"+\n\t\t\t\t\"notification\", i)\n\t\tdefault:\n\t\t}\n\t}\n\n\t// We'll assume a historical rescan was dispatched and found the\n\t// following confirmation details. We'll let the notifier know so that\n\t// it can stop watching at tip.\n\texpectedConfDetails := &chainntnfs.TxConfirmation{\n\t\tBlockHeight: startingHeight - 1,\n\t\tTx:          wire.NewMsgTx(1),\n\t}\n\terr := n.UpdateConfDetails(\n\t\tconfNtfns[0].HistoricalDispatch.ConfRequest, expectedConfDetails,\n\t)\n\trequire.NoError(t, err, \"unable to update conf details\")\n\n\t// With the confirmation details retrieved, each client should now have\n\t// been notified of the confirmation.\n\tfor i, ntfn := range confNtfns {\n\t\tselect {\n\t\tcase confDetails := <-ntfn.Event.Confirmed:\n\t\t\tassertConfDetails(t, confDetails, expectedConfDetails)\n\t\tdefault:\n\t\t\tt.Fatalf(\"request #%d expected to received \"+\n\t\t\t\t\"confirmation notification\", i)\n\t\t}\n\t}\n\n\t// In order to ensure that the confirmation details are properly cached,\n\t// we'll register another client for the same transaction. We should not\n\t// see a historical rescan request and the confirmation notification\n\t// should come through immediately.\n\textraConfNtfn, err := n.RegisterConf(&txid, testRawScript, 1, 1)\n\trequire.NoError(t, err, \"unable to register conf ntfn\")\n\tif extraConfNtfn.HistoricalDispatch != nil {\n\t\tt.Fatal(\"received unexpected historical rescan request\")\n\t}\n\n\tselect {\n\tcase confDetails := <-extraConfNtfn.Event.Confirmed:\n\t\tassertConfDetails(t, confDetails, expectedConfDetails)\n\tdefault:\n\t\tt.Fatal(\"expected to receive spend notification\")\n\t}\n\n\t// Similarly, we'll do the same thing but for spend notifications.\n\top := wire.OutPoint{Index: 1}\n\tspendNtfns := make([]*chainntnfs.SpendRegistration, numNtfns)\n\tfor i := uint64(0); i < numNtfns; i++ {\n\t\tntfn, err := n.RegisterSpend(&op, testRawScript, 1)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to register spend ntfn #%d: %v\", i, err)\n\t\t}\n\t\tspendNtfns[i] = ntfn\n\t}\n\n\t// Ensure none of them have received the spend details.\n\tfor i, ntfn := range spendNtfns {\n\t\tselect {\n\t\tcase <-ntfn.Event.Spend:\n\t\t\tt.Fatalf(\"request #%d received unexpected spend \"+\n\t\t\t\t\"notification\", i)\n\t\tdefault:\n\t\t}\n\t}\n\n\t// We'll assume a historical rescan was dispatched and found the\n\t// following spend details. We'll let the notifier know so that it can\n\t// stop watching at tip.\n\texpectedSpendDetails := &chainntnfs.SpendDetail{\n\t\tSpentOutPoint:     &op,\n\t\tSpenderTxHash:     &chainntnfs.ZeroHash,\n\t\tSpendingTx:        wire.NewMsgTx(2),\n\t\tSpenderInputIndex: 0,\n\t\tSpendingHeight:    startingHeight - 1,\n\t}\n\terr = n.UpdateSpendDetails(\n\t\tspendNtfns[0].HistoricalDispatch.SpendRequest, expectedSpendDetails,\n\t)\n\trequire.NoError(t, err, \"unable to update spend details\")\n\n\t// With the spend details retrieved, each client should now have been\n\t// notified of the spend.\n\tfor i, ntfn := range spendNtfns {\n\t\tselect {\n\t\tcase spendDetails := <-ntfn.Event.Spend:\n\t\t\tassertSpendDetails(t, spendDetails, expectedSpendDetails)\n\t\tdefault:\n\t\t\tt.Fatalf(\"request #%d expected to received spend \"+\n\t\t\t\t\"notification\", i)\n\t\t}\n\t}\n\n\t// Finally, in order to ensure that the spend details are properly\n\t// cached, we'll register another client for the same outpoint. We\n\t// should not see a historical rescan request and the spend notification\n\t// should come through immediately.\n\textraSpendNtfn, err := n.RegisterSpend(&op, testRawScript, 1)\n\trequire.NoError(t, err, \"unable to register spend ntfn\")\n\tif extraSpendNtfn.HistoricalDispatch != nil {\n\t\tt.Fatal(\"received unexpected historical rescan request\")\n\t}\n\n\tselect {\n\tcase spendDetails := <-extraSpendNtfn.Event.Spend:\n\t\tassertSpendDetails(t, spendDetails, expectedSpendDetails)\n\tdefault:\n\t\tt.Fatal(\"expected to receive spend notification\")\n\t}\n}\n\n// TestTxNotifierCancelConf ensures that a confirmation notification after a\n// client has canceled their intent to receive one.",
      "length": 4534,
      "tokens": 579,
      "embedding": []
    },
    {
      "slug": "func TestTxNotifierCancelConf(t *testing.T) {",
      "content": "func TestTxNotifierCancelConf(t *testing.T) {\n\tt.Parallel()\n\n\tconst startingHeight = 10\n\thintCache := newMockHintCache()\n\tn := chainntnfs.NewTxNotifier(startingHeight, 100, hintCache, hintCache)\n\n\t// We'll register four notification requests. The last three will be\n\t// canceled.\n\ttx1 := wire.NewMsgTx(1)\n\ttx1.AddTxOut(&wire.TxOut{PkScript: testRawScript})\n\ttx1Hash := tx1.TxHash()\n\tntfn1, err := n.RegisterConf(&tx1Hash, testRawScript, 1, 1)\n\trequire.NoError(t, err, \"unable to register spend ntfn\")\n\n\ttx2 := wire.NewMsgTx(2)\n\ttx2.AddTxOut(&wire.TxOut{PkScript: testRawScript})\n\ttx2Hash := tx2.TxHash()\n\tntfn2, err := n.RegisterConf(&tx2Hash, testRawScript, 1, 1)\n\trequire.NoError(t, err, \"unable to register spend ntfn\")\n\tntfn3, err := n.RegisterConf(&tx2Hash, testRawScript, 1, 1)\n\trequire.NoError(t, err, \"unable to register spend ntfn\")\n\n\t// This request will have a three block num confs.\n\tntfn4, err := n.RegisterConf(&tx2Hash, testRawScript, 3, 1)\n\trequire.NoError(t, err, \"unable to register spend ntfn\")\n\n\t// Extend the chain with a block that will confirm both transactions.\n\t// This will queue confirmation notifications to dispatch once their\n\t// respective heights have been met.\n\tblock := btcutil.NewBlock(&wire.MsgBlock{\n\t\tTransactions: []*wire.MsgTx{tx1, tx2},\n\t})\n\ttx1ConfDetails := &chainntnfs.TxConfirmation{\n\t\tBlockHeight: startingHeight + 1,\n\t\tBlockHash:   block.Hash(),\n\t\tTxIndex:     0,\n\t\tTx:          tx1,\n\t}\n\n\t// Cancel the second notification before connecting the block.\n\tntfn2.Event.Cancel()\n\n\terr = n.ConnectTip(block, startingHeight+1)\n\trequire.NoError(t, err, \"unable to connect block\")\n\n\t// Cancel the third notification before notifying to ensure its queued\n\t// confirmation notification gets removed as well.\n\tntfn3.Event.Cancel()\n\n\tif err := n.NotifyHeight(startingHeight + 1); err != nil {\n\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t}\n\n\t// The first request should still be active, so we should receive a\n\t// confirmation notification with the correct details.\n\tselect {\n\tcase confDetails := <-ntfn1.Event.Confirmed:\n\t\tassertConfDetails(t, confDetails, tx1ConfDetails)\n\tdefault:\n\t\tt.Fatalf(\"expected to receive confirmation notification\")\n\t}\n\n\t// The second and third, however, should not have. The event's Confirmed\n\t// channel must have also been closed to indicate the caller that the\n\t// TxNotifier can no longer fulfill their canceled request.\n\tselect {\n\tcase _, ok := <-ntfn2.Event.Confirmed:\n\t\tif ok {\n\t\t\tt.Fatal(\"expected Confirmed channel to be closed\")\n\t\t}\n\tdefault:\n\t\tt.Fatal(\"expected Confirmed channel to be closed\")\n\t}\n\tselect {\n\tcase _, ok := <-ntfn3.Event.Confirmed:\n\t\tif ok {\n\t\t\tt.Fatal(\"expected Confirmed channel to be closed\")\n\t\t}\n\tdefault:\n\t\tt.Fatal(\"expected Confirmed channel to be closed\")\n\t}\n\n\t// Connect yet another block.\n\tblock1 := btcutil.NewBlock(&wire.MsgBlock{\n\t\tTransactions: []*wire.MsgTx{},\n\t})\n\n\terr = n.ConnectTip(block1, startingHeight+2)\n\trequire.NoError(t, err, \"unable to connect block\")\n\n\tif err := n.NotifyHeight(startingHeight + 2); err != nil {\n\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t}\n\n\t// Since neither it reached the set confirmation height or was\n\t// canceled, nothing should happen to ntfn4 in this block.\n\tselect {\n\tcase <-ntfn4.Event.Confirmed:\n\t\tt.Fatal(\"expected nothing to happen\")\n\tcase <-time.After(10 * time.Millisecond):\n\t}\n\n\t// Now cancel the notification.\n\tntfn4.Event.Cancel()\n\tselect {\n\tcase _, ok := <-ntfn4.Event.Confirmed:\n\t\tif ok {\n\t\t\tt.Fatal(\"expected Confirmed channel to be closed\")\n\t\t}\n\tdefault:\n\t\tt.Fatal(\"expected Confirmed channel to be closed\")\n\t}\n\n\t// Finally, confirm a block that would trigger ntfn4 confirmation\n\t// hadn't it already been canceled.\n\tblock2 := btcutil.NewBlock(&wire.MsgBlock{\n\t\tTransactions: []*wire.MsgTx{},\n\t})\n\n\terr = n.ConnectTip(block2, startingHeight+3)\n\trequire.NoError(t, err, \"unable to connect block\")\n\n\tif err := n.NotifyHeight(startingHeight + 3); err != nil {\n\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t}\n}\n\n// TestTxNotifierCancelSpend ensures that a spend notification after a client\n// has canceled their intent to receive one.",
      "length": 3948,
      "tokens": 505,
      "embedding": []
    },
    {
      "slug": "func TestTxNotifierCancelSpend(t *testing.T) {",
      "content": "func TestTxNotifierCancelSpend(t *testing.T) {\n\tt.Parallel()\n\n\tconst startingHeight = 10\n\thintCache := newMockHintCache()\n\tn := chainntnfs.NewTxNotifier(\n\t\tstartingHeight, chainntnfs.ReorgSafetyLimit, hintCache,\n\t\thintCache,\n\t)\n\n\t// We'll register two notification requests. Only the second one will be\n\t// canceled.\n\top1 := wire.OutPoint{Index: 1}\n\tntfn1, err := n.RegisterSpend(&op1, testRawScript, 1)\n\trequire.NoError(t, err, \"unable to register spend ntfn\")\n\n\top2 := wire.OutPoint{Index: 2}\n\tntfn2, err := n.RegisterSpend(&op2, testRawScript, 1)\n\trequire.NoError(t, err, \"unable to register spend ntfn\")\n\n\t// Construct the spending details of the outpoint and create a dummy\n\t// block containing it.\n\tspendTx := wire.NewMsgTx(2)\n\tspendTx.AddTxIn(&wire.TxIn{\n\t\tPreviousOutPoint: op1,\n\t\tSignatureScript:  testSigScript,\n\t})\n\tspendTxHash := spendTx.TxHash()\n\texpectedSpendDetails := &chainntnfs.SpendDetail{\n\t\tSpentOutPoint:     &op1,\n\t\tSpenderTxHash:     &spendTxHash,\n\t\tSpendingTx:        spendTx,\n\t\tSpenderInputIndex: 0,\n\t\tSpendingHeight:    startingHeight + 1,\n\t}\n\n\tblock := btcutil.NewBlock(&wire.MsgBlock{\n\t\tTransactions: []*wire.MsgTx{spendTx},\n\t})\n\n\t// Before extending the notifier's tip with the dummy block above, we'll\n\t// cancel the second request.\n\tn.CancelSpend(ntfn2.HistoricalDispatch.SpendRequest, 2)\n\n\terr = n.ConnectTip(block, startingHeight+1)\n\trequire.NoError(t, err, \"unable to connect block\")\n\tif err := n.NotifyHeight(startingHeight + 1); err != nil {\n\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t}\n\n\t// The first request should still be active, so we should receive a\n\t// spend notification with the correct spending details.\n\tselect {\n\tcase spendDetails := <-ntfn1.Event.Spend:\n\t\tassertSpendDetails(t, spendDetails, expectedSpendDetails)\n\tdefault:\n\t\tt.Fatalf(\"expected to receive spend notification\")\n\t}\n\n\t// The second one, however, should not have. The event's Spend channel\n\t// must have also been closed to indicate the caller that the TxNotifier\n\t// can no longer fulfill their canceled request.\n\tselect {\n\tcase _, ok := <-ntfn2.Event.Spend:\n\t\tif ok {\n\t\t\tt.Fatal(\"expected Spend channel to be closed\")\n\t\t}\n\tdefault:\n\t\tt.Fatal(\"expected Spend channel to be closed\")\n\t}\n}\n\n// TestTxNotifierConfReorg ensures that clients are notified of a reorg when a\n// transaction for which they registered a confirmation notification has been\n// reorged out of the chain.",
      "length": 2281,
      "tokens": 285,
      "embedding": []
    },
    {
      "slug": "func TestTxNotifierConfReorg(t *testing.T) {",
      "content": "func TestTxNotifierConfReorg(t *testing.T) {\n\tt.Parallel()\n\n\tconst (\n\t\ttx1NumConfs uint32 = 2\n\t\ttx2NumConfs uint32 = 1\n\t\ttx3NumConfs uint32 = 2\n\t)\n\n\thintCache := newMockHintCache()\n\tn := chainntnfs.NewTxNotifier(\n\t\t7, chainntnfs.ReorgSafetyLimit, hintCache, hintCache,\n\t)\n\n\t// Tx 1 will be confirmed in block 9 and requires 2 confs.\n\ttx1 := wire.MsgTx{Version: 1}\n\ttx1.AddTxOut(&wire.TxOut{PkScript: testRawScript})\n\ttx1Hash := tx1.TxHash()\n\tntfn1, err := n.RegisterConf(&tx1Hash, testRawScript, tx1NumConfs, 1)\n\trequire.NoError(t, err, \"unable to register ntfn\")\n\n\terr = n.UpdateConfDetails(ntfn1.HistoricalDispatch.ConfRequest, nil)\n\trequire.NoError(t, err, \"unable to deliver conf details\")\n\n\t// Tx 2 will be confirmed in block 10 and requires 1 conf.\n\ttx2 := wire.MsgTx{Version: 2}\n\ttx2.AddTxOut(&wire.TxOut{PkScript: testRawScript})\n\ttx2Hash := tx2.TxHash()\n\tntfn2, err := n.RegisterConf(&tx2Hash, testRawScript, tx2NumConfs, 1)\n\trequire.NoError(t, err, \"unable to register ntfn\")\n\n\terr = n.UpdateConfDetails(ntfn2.HistoricalDispatch.ConfRequest, nil)\n\trequire.NoError(t, err, \"unable to deliver conf details\")\n\n\t// Tx 3 will be confirmed in block 10 and requires 2 confs.\n\ttx3 := wire.MsgTx{Version: 3}\n\ttx3.AddTxOut(&wire.TxOut{PkScript: testRawScript})\n\ttx3Hash := tx3.TxHash()\n\tntfn3, err := n.RegisterConf(&tx3Hash, testRawScript, tx3NumConfs, 1)\n\trequire.NoError(t, err, \"unable to register ntfn\")\n\n\terr = n.UpdateConfDetails(ntfn3.HistoricalDispatch.ConfRequest, nil)\n\trequire.NoError(t, err, \"unable to deliver conf details\")\n\n\t// Sync chain to block 10. Txs 1 & 2 should be confirmed.\n\tblock1 := btcutil.NewBlock(&wire.MsgBlock{\n\t\tTransactions: []*wire.MsgTx{&tx1},\n\t})\n\tif err := n.ConnectTip(block1, 8); err != nil {\n\t\tt.Fatalf(\"Failed to connect block: %v\", err)\n\t}\n\tif err := n.NotifyHeight(8); err != nil {\n\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t}\n\tif err := n.ConnectTip(nil, 9); err != nil {\n\t\tt.Fatalf(\"Failed to connect block: %v\", err)\n\t}\n\tif err := n.NotifyHeight(9); err != nil {\n\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t}\n\n\tblock2 := btcutil.NewBlock(&wire.MsgBlock{\n\t\tTransactions: []*wire.MsgTx{&tx2, &tx3},\n\t})\n\tif err := n.ConnectTip(block2, 10); err != nil {\n\t\tt.Fatalf(\"Failed to connect block: %v\", err)\n\t}\n\tif err := n.NotifyHeight(10); err != nil {\n\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t}\n\n\t// We should receive two updates for tx1 since it requires two\n\t// confirmations and it has already met them.\n\tfor i := 0; i < 2; i++ {\n\t\tselect {\n\t\tcase <-ntfn1.Event.Updates:\n\t\tdefault:\n\t\t\tt.Fatal(\"Expected confirmation update for tx1\")\n\t\t}\n\t}\n\n\t// A confirmation notification for tx1 should be dispatched, as it met\n\t// its required number of confirmations.\n\tselect {\n\tcase <-ntfn1.Event.Confirmed:\n\tdefault:\n\t\tt.Fatalf(\"Expected confirmation for tx1\")\n\t}\n\n\t// We should only receive one update for tx2 since it only requires\n\t// one confirmation and it already met it.\n\tselect {\n\tcase <-ntfn2.Event.Updates:\n\tdefault:\n\t\tt.Fatal(\"Expected confirmation update for tx2\")\n\t}\n\n\t// A confirmation notification for tx2 should be dispatched, as it met\n\t// its required number of confirmations.\n\tselect {\n\tcase <-ntfn2.Event.Confirmed:\n\tdefault:\n\t\tt.Fatalf(\"Expected confirmation for tx2\")\n\t}\n\n\t// We should only receive one update for tx3 since it only has one\n\t// confirmation so far and it requires two.\n\tselect {\n\tcase <-ntfn3.Event.Updates:\n\tdefault:\n\t\tt.Fatal(\"Expected confirmation update for tx3\")\n\t}\n\n\t// A confirmation notification for tx3 should not be dispatched yet, as\n\t// it requires one more confirmation.\n\tselect {\n\tcase txConf := <-ntfn3.Event.Confirmed:\n\t\tt.Fatalf(\"Received unexpected confirmation for tx3: %v\", txConf)\n\tdefault:\n\t}\n\n\t// The block that included tx2 and tx3 is disconnected and two next\n\t// blocks without them are connected.\n\tif err := n.DisconnectTip(10); err != nil {\n\t\tt.Fatalf(\"Failed to connect block: %v\", err)\n\t}\n\n\tif err := n.ConnectTip(nil, 10); err != nil {\n\t\tt.Fatalf(\"Failed to connect block: %v\", err)\n\t}\n\tif err := n.NotifyHeight(10); err != nil {\n\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t}\n\n\tif err := n.ConnectTip(nil, 11); err != nil {\n\t\tt.Fatalf(\"Failed to connect block: %v\", err)\n\t}\n\tif err := n.NotifyHeight(11); err != nil {\n\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t}\n\n\tselect {\n\tcase reorgDepth := <-ntfn2.Event.NegativeConf:\n\t\tif reorgDepth != 1 {\n\t\t\tt.Fatalf(\"Incorrect value for negative conf notification: \"+\n\t\t\t\t\"expected %d, got %d\", 1, reorgDepth)\n\t\t}\n\tdefault:\n\t\tt.Fatalf(\"Expected negative conf notification for tx1\")\n\t}\n\n\t// We should not receive any event notifications from all of the\n\t// transactions because tx1 has already been confirmed and tx2 and tx3\n\t// have not been included in the chain since the reorg.\n\tselect {\n\tcase <-ntfn1.Event.Updates:\n\t\tt.Fatal(\"Received unexpected confirmation update for tx1\")\n\tcase txConf := <-ntfn1.Event.Confirmed:\n\t\tt.Fatalf(\"Received unexpected confirmation for tx1: %v\", txConf)\n\tdefault:\n\t}\n\n\tselect {\n\tcase <-ntfn2.Event.Updates:\n\t\tt.Fatal(\"Received unexpected confirmation update for tx2\")\n\tcase txConf := <-ntfn2.Event.Confirmed:\n\t\tt.Fatalf(\"Received unexpected confirmation for tx2: %v\", txConf)\n\tdefault:\n\t}\n\n\tselect {\n\tcase <-ntfn3.Event.Updates:\n\t\tt.Fatal(\"Received unexpected confirmation update for tx3\")\n\tcase txConf := <-ntfn3.Event.Confirmed:\n\t\tt.Fatalf(\"Received unexpected confirmation for tx3: %v\", txConf)\n\tdefault:\n\t}\n\n\t// Now transactions 2 & 3 are re-included in a new block.\n\tblock3 := btcutil.NewBlock(&wire.MsgBlock{\n\t\tTransactions: []*wire.MsgTx{&tx2, &tx3},\n\t})\n\tblock4 := btcutil.NewBlock(&wire.MsgBlock{})\n\n\terr = n.ConnectTip(block3, 12)\n\trequire.NoError(t, err, \"Failed to connect block\")\n\tif err := n.NotifyHeight(12); err != nil {\n\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t}\n\n\terr = n.ConnectTip(block4, 13)\n\trequire.NoError(t, err, \"Failed to connect block\")\n\tif err := n.NotifyHeight(13); err != nil {\n\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t}\n\n\t// We should only receive one update for tx2 since it only requires\n\t// one confirmation and it already met it.\n\tselect {\n\tcase numConfsLeft := <-ntfn2.Event.Updates:\n\t\tconst expected = 0\n\t\tif numConfsLeft != expected {\n\t\t\tt.Fatalf(\"Received incorrect confirmation update: tx2 \"+\n\t\t\t\t\"expected %d confirmations left, got %d\",\n\t\t\t\texpected, numConfsLeft)\n\t\t}\n\tdefault:\n\t\tt.Fatal(\"Expected confirmation update for tx2\")\n\t}\n\n\t// A confirmation notification for tx2 should be dispatched, as it met\n\t// its required number of confirmations.\n\tselect {\n\tcase txConf := <-ntfn2.Event.Confirmed:\n\t\texpectedConf := chainntnfs.TxConfirmation{\n\t\t\tBlockHash:   block3.Hash(),\n\t\t\tBlockHeight: 12,\n\t\t\tTxIndex:     0,\n\t\t\tTx:          &tx2,\n\t\t}\n\t\tassertConfDetails(t, txConf, &expectedConf)\n\tdefault:\n\t\tt.Fatalf(\"Expected confirmation for tx2\")\n\t}\n\n\t// We should receive two updates for tx3 since it requires two\n\t// confirmations and it has already met them.\n\tfor i := uint32(1); i <= 2; i++ {\n\t\tselect {\n\t\tcase numConfsLeft := <-ntfn3.Event.Updates:\n\t\t\texpected := tx3NumConfs - i\n\t\t\tif numConfsLeft != expected {\n\t\t\t\tt.Fatalf(\"Received incorrect confirmation update: tx3 \"+\n\t\t\t\t\t\"expected %d confirmations left, got %d\",\n\t\t\t\t\texpected, numConfsLeft)\n\t\t\t}\n\t\tdefault:\n\t\t\tt.Fatal(\"Expected confirmation update for tx2\")\n\t\t}\n\t}\n\n\t// A confirmation notification for tx3 should be dispatched, as it met\n\t// its required number of confirmations.\n\tselect {\n\tcase txConf := <-ntfn3.Event.Confirmed:\n\t\texpectedConf := chainntnfs.TxConfirmation{\n\t\t\tBlockHash:   block3.Hash(),\n\t\t\tBlockHeight: 12,\n\t\t\tTxIndex:     1,\n\t\t\tTx:          &tx3,\n\t\t}\n\t\tassertConfDetails(t, txConf, &expectedConf)\n\tdefault:\n\t\tt.Fatalf(\"Expected confirmation for tx3\")\n\t}\n}\n\n// TestTxNotifierSpendReorg ensures that clients are notified of a reorg when\n// the spending transaction of an outpoint for which they registered a spend\n// notification for has been reorged out of the chain.",
      "length": 7662,
      "tokens": 1035,
      "embedding": []
    },
    {
      "slug": "func TestTxNotifierSpendReorg(t *testing.T) {",
      "content": "func TestTxNotifierSpendReorg(t *testing.T) {\n\tt.Parallel()\n\n\tconst startingHeight = 10\n\thintCache := newMockHintCache()\n\tn := chainntnfs.NewTxNotifier(\n\t\tstartingHeight, chainntnfs.ReorgSafetyLimit, hintCache,\n\t\thintCache,\n\t)\n\n\t// We'll have two outpoints that will be spent throughout the test. The\n\t// first will be spent and will not experience a reorg, while the second\n\t// one will.\n\top1 := wire.OutPoint{Index: 1}\n\tspendTx1 := wire.NewMsgTx(2)\n\tspendTx1.AddTxIn(&wire.TxIn{\n\t\tPreviousOutPoint: op1,\n\t\tSignatureScript:  testSigScript,\n\t})\n\tspendTxHash1 := spendTx1.TxHash()\n\texpectedSpendDetails1 := &chainntnfs.SpendDetail{\n\t\tSpentOutPoint:     &op1,\n\t\tSpenderTxHash:     &spendTxHash1,\n\t\tSpendingTx:        spendTx1,\n\t\tSpenderInputIndex: 0,\n\t\tSpendingHeight:    startingHeight + 1,\n\t}\n\n\top2 := wire.OutPoint{Index: 2}\n\tspendTx2 := wire.NewMsgTx(2)\n\tspendTx2.AddTxIn(&wire.TxIn{\n\t\tPreviousOutPoint: chainntnfs.ZeroOutPoint,\n\t\tSignatureScript:  testSigScript,\n\t})\n\tspendTx2.AddTxIn(&wire.TxIn{\n\t\tPreviousOutPoint: op2,\n\t\tSignatureScript:  testSigScript,\n\t})\n\tspendTxHash2 := spendTx2.TxHash()\n\n\t// The second outpoint will experience a reorg and get re-spent at a\n\t// different height, so we'll need to construct the spend details for\n\t// before and after the reorg.\n\texpectedSpendDetails2BeforeReorg := chainntnfs.SpendDetail{\n\t\tSpentOutPoint:     &op2,\n\t\tSpenderTxHash:     &spendTxHash2,\n\t\tSpendingTx:        spendTx2,\n\t\tSpenderInputIndex: 1,\n\t\tSpendingHeight:    startingHeight + 2,\n\t}\n\n\t// The spend details after the reorg will be exactly the same, except\n\t// for the spend confirming at the next height.\n\texpectedSpendDetails2AfterReorg := expectedSpendDetails2BeforeReorg\n\texpectedSpendDetails2AfterReorg.SpendingHeight++\n\n\t// We'll register for a spend notification for each outpoint above.\n\tntfn1, err := n.RegisterSpend(&op1, testRawScript, 1)\n\trequire.NoError(t, err, \"unable to register spend ntfn\")\n\n\tntfn2, err := n.RegisterSpend(&op2, testRawScript, 1)\n\trequire.NoError(t, err, \"unable to register spend ntfn\")\n\n\t// We'll extend the chain by connecting a new block at tip. This block\n\t// will only contain the spending transaction of the first outpoint.\n\tblock1 := btcutil.NewBlock(&wire.MsgBlock{\n\t\tTransactions: []*wire.MsgTx{spendTx1},\n\t})\n\terr = n.ConnectTip(block1, startingHeight+1)\n\trequire.NoError(t, err, \"unable to connect block\")\n\tif err := n.NotifyHeight(startingHeight + 1); err != nil {\n\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t}\n\n\t// We should receive a spend notification for the first outpoint with\n\t// its correct spending details.\n\tselect {\n\tcase spendDetails := <-ntfn1.Event.Spend:\n\t\tassertSpendDetails(t, spendDetails, expectedSpendDetails1)\n\tdefault:\n\t\tt.Fatal(\"expected to receive spend details\")\n\t}\n\n\t// We should not, however, receive one for the second outpoint as it has\n\t// yet to be spent.\n\tselect {\n\tcase <-ntfn2.Event.Spend:\n\t\tt.Fatal(\"received unexpected spend notification\")\n\tdefault:\n\t}\n\n\t// Now, we'll extend the chain again, this time with a block containing\n\t// the spending transaction of the second outpoint.\n\tblock2 := btcutil.NewBlock(&wire.MsgBlock{\n\t\tTransactions: []*wire.MsgTx{spendTx2},\n\t})\n\terr = n.ConnectTip(block2, startingHeight+2)\n\trequire.NoError(t, err, \"unable to connect block\")\n\tif err := n.NotifyHeight(startingHeight + 2); err != nil {\n\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t}\n\n\t// We should not receive another spend notification for the first\n\t// outpoint.\n\tselect {\n\tcase <-ntfn1.Event.Spend:\n\t\tt.Fatal(\"received unexpected spend notification\")\n\tdefault:\n\t}\n\n\t// We should receive one for the second outpoint.\n\tselect {\n\tcase spendDetails := <-ntfn2.Event.Spend:\n\t\tassertSpendDetails(\n\t\t\tt, spendDetails, &expectedSpendDetails2BeforeReorg,\n\t\t)\n\tdefault:\n\t\tt.Fatal(\"expected to receive spend details\")\n\t}\n\n\t// Now, to replicate a chain reorg, we'll disconnect the block that\n\t// contained the spending transaction of the second outpoint.\n\tif err := n.DisconnectTip(startingHeight + 2); err != nil {\n\t\tt.Fatalf(\"unable to disconnect block: %v\", err)\n\t}\n\n\t// No notifications should be dispatched for the first outpoint as it\n\t// was spent at a previous height.\n\tselect {\n\tcase <-ntfn1.Event.Spend:\n\t\tt.Fatal(\"received unexpected spend notification\")\n\tcase <-ntfn1.Event.Reorg:\n\t\tt.Fatal(\"received unexpected spend reorg notification\")\n\tdefault:\n\t}\n\n\t// We should receive a reorg notification for the second outpoint.\n\tselect {\n\tcase <-ntfn2.Event.Spend:\n\t\tt.Fatal(\"received unexpected spend notification\")\n\tcase <-ntfn2.Event.Reorg:\n\tdefault:\n\t\tt.Fatal(\"expected spend reorg notification\")\n\t}\n\n\t// We'll now extend the chain with an empty block, to ensure that we can\n\t// properly detect when an outpoint has been re-spent at a later height.\n\temptyBlock := btcutil.NewBlock(&wire.MsgBlock{})\n\terr = n.ConnectTip(emptyBlock, startingHeight+2)\n\trequire.NoError(t, err, \"unable to disconnect block\")\n\tif err := n.NotifyHeight(startingHeight + 2); err != nil {\n\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t}\n\n\t// We shouldn't receive notifications for either of the outpoints.\n\tselect {\n\tcase <-ntfn1.Event.Spend:\n\t\tt.Fatal(\"received unexpected spend notification\")\n\tcase <-ntfn1.Event.Reorg:\n\t\tt.Fatal(\"received unexpected spend reorg notification\")\n\tcase <-ntfn2.Event.Spend:\n\t\tt.Fatal(\"received unexpected spend notification\")\n\tcase <-ntfn2.Event.Reorg:\n\t\tt.Fatal(\"received unexpected spend reorg notification\")\n\tdefault:\n\t}\n\n\t// Finally, extend the chain with another block containing the same\n\t// spending transaction of the second outpoint.\n\terr = n.ConnectTip(block2, startingHeight+3)\n\trequire.NoError(t, err, \"unable to connect block\")\n\tif err := n.NotifyHeight(startingHeight + 3); err != nil {\n\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t}\n\n\t// We should now receive a spend notification once again for the second\n\t// outpoint containing the new spend details.\n\tselect {\n\tcase spendDetails := <-ntfn2.Event.Spend:\n\t\tassertSpendDetails(\n\t\t\tt, spendDetails, &expectedSpendDetails2AfterReorg,\n\t\t)\n\tdefault:\n\t\tt.Fatalf(\"expected to receive spend notification\")\n\t}\n\n\t// Once again, we should not receive one for the first outpoint.\n\tselect {\n\tcase <-ntfn1.Event.Spend:\n\t\tt.Fatal(\"received unexpected spend notification\")\n\tdefault:\n\t}\n}\n\n// TestTxNotifierUpdateSpendReorg tests that a call to RegisterSpend after the\n// spend has been confirmed, and then UpdateSpendDetails (called by historical\n// dispatch), followed by a chain re-org will notify on the Reorg channel. This\n// was not always the case and has since been fixed.",
      "length": 6329,
      "tokens": 785,
      "embedding": []
    },
    {
      "slug": "func TestTxNotifierSpendReorgMissed(t *testing.T) {",
      "content": "func TestTxNotifierSpendReorgMissed(t *testing.T) {\n\tt.Parallel()\n\n\tconst startingHeight = 10\n\thintCache := newMockHintCache()\n\tn := chainntnfs.NewTxNotifier(\n\t\tstartingHeight, chainntnfs.ReorgSafetyLimit, hintCache,\n\t\thintCache,\n\t)\n\n\t// We'll create a spending transaction that spends the outpoint we'll\n\t// watch.\n\top := wire.OutPoint{Index: 1}\n\tspendTx := wire.NewMsgTx(2)\n\tspendTx.AddTxIn(&wire.TxIn{\n\t\tPreviousOutPoint: op,\n\t\tSignatureScript:  testSigScript,\n\t})\n\tspendTxHash := spendTx.TxHash()\n\n\t// Create the spend details that we'll call UpdateSpendDetails with.\n\tspendDetails := &chainntnfs.SpendDetail{\n\t\tSpentOutPoint:     &op,\n\t\tSpenderTxHash:     &spendTxHash,\n\t\tSpendingTx:        spendTx,\n\t\tSpenderInputIndex: 0,\n\t\tSpendingHeight:    startingHeight + 1,\n\t}\n\n\t// Now confirm the spending transaction.\n\tblock := btcutil.NewBlock(&wire.MsgBlock{\n\t\tTransactions: []*wire.MsgTx{spendTx},\n\t})\n\terr := n.ConnectTip(block, startingHeight+1)\n\trequire.NoError(t, err, \"unable to connect block\")\n\tif err := n.NotifyHeight(startingHeight + 1); err != nil {\n\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t}\n\n\t// We register for the spend now and will not get a spend notification\n\t// until we call UpdateSpendDetails.\n\tntfn, err := n.RegisterSpend(&op, testRawScript, 1)\n\trequire.NoError(t, err, \"unable to register spend\")\n\n\t// Assert that the HistoricalDispatch variable is non-nil. We'll use\n\t// the SpendRequest member to update the spend details.\n\trequire.NotEmpty(t, ntfn.HistoricalDispatch)\n\n\tselect {\n\tcase <-ntfn.Event.Spend:\n\t\tt.Fatalf(\"did not expect to receive spend ntfn\")\n\tdefault:\n\t}\n\n\t// We now call UpdateSpendDetails with our generated spend details to\n\t// simulate a historical spend dispatch being performed. This should\n\t// result in a notification being received on the Spend channel.\n\terr = n.UpdateSpendDetails(\n\t\tntfn.HistoricalDispatch.SpendRequest, spendDetails,\n\t)\n\trequire.Empty(t, err)\n\n\t// Assert that we receive a Spend notification.\n\tselect {\n\tcase <-ntfn.Event.Spend:\n\tdefault:\n\t\tt.Fatalf(\"expected to receive spend ntfn\")\n\t}\n\n\t// We will now re-org the spending transaction out of the chain, and we\n\t// should receive a notification on the Reorg channel.\n\terr = n.DisconnectTip(startingHeight + 1)\n\trequire.Empty(t, err)\n\n\tselect {\n\tcase <-ntfn.Event.Spend:\n\t\tt.Fatalf(\"received unexpected spend ntfn\")\n\tcase <-ntfn.Event.Reorg:\n\tdefault:\n\t\tt.Fatalf(\"expected spend reorg ntfn\")\n\t}\n}\n\n// TestTxNotifierConfirmHintCache ensures that the height hints for transactions\n// are kept track of correctly with each new block connected/disconnected. This\n// test also asserts that the height hints are not updated until the simulated\n// historical dispatches have returned, and we know the transactions aren't\n// already in the chain.",
      "length": 2635,
      "tokens": 332,
      "embedding": []
    },
    {
      "slug": "func TestTxNotifierConfirmHintCache(t *testing.T) {",
      "content": "func TestTxNotifierConfirmHintCache(t *testing.T) {\n\tt.Parallel()\n\n\tconst (\n\t\tstartingHeight = 200\n\t\ttxDummyHeight  = 201\n\t\ttx1Height      = 202\n\t\ttx2Height      = 203\n\t)\n\n\t// Initialize our TxNotifier instance backed by a height hint cache.\n\thintCache := newMockHintCache()\n\tn := chainntnfs.NewTxNotifier(\n\t\tstartingHeight, chainntnfs.ReorgSafetyLimit, hintCache,\n\t\thintCache,\n\t)\n\n\t// Create two test transactions and register them for notifications.\n\ttx1 := wire.MsgTx{Version: 1}\n\ttx1.AddTxOut(&wire.TxOut{PkScript: testRawScript})\n\ttx1Hash := tx1.TxHash()\n\tntfn1, err := n.RegisterConf(&tx1Hash, testRawScript, 1, 1)\n\trequire.NoError(t, err, \"unable to register tx1\")\n\n\ttx2 := wire.MsgTx{Version: 2}\n\ttx2.AddTxOut(&wire.TxOut{PkScript: testRawScript})\n\ttx2Hash := tx2.TxHash()\n\tntfn2, err := n.RegisterConf(&tx2Hash, testRawScript, 2, 1)\n\trequire.NoError(t, err, \"unable to register tx2\")\n\n\t// Both transactions should not have a height hint set, as RegisterConf\n\t// should not alter the cache state.\n\t_, err = hintCache.QueryConfirmHint(ntfn1.HistoricalDispatch.ConfRequest)\n\tif err != chainntnfs.ErrConfirmHintNotFound {\n\t\tt.Fatalf(\"unexpected error when querying for height hint \"+\n\t\t\t\"want: %v, got %v\",\n\t\t\tchainntnfs.ErrConfirmHintNotFound, err)\n\t}\n\n\t_, err = hintCache.QueryConfirmHint(ntfn2.HistoricalDispatch.ConfRequest)\n\tif err != chainntnfs.ErrConfirmHintNotFound {\n\t\tt.Fatalf(\"unexpected error when querying for height hint \"+\n\t\t\t\"want: %v, got %v\",\n\t\t\tchainntnfs.ErrConfirmHintNotFound, err)\n\t}\n\n\t// Create a new block that will include the dummy transaction and extend\n\t// the chain.\n\ttxDummy := wire.MsgTx{Version: 3}\n\tblock1 := btcutil.NewBlock(&wire.MsgBlock{\n\t\tTransactions: []*wire.MsgTx{&txDummy},\n\t})\n\n\terr = n.ConnectTip(block1, txDummyHeight)\n\trequire.NoError(t, err, \"Failed to connect block\")\n\tif err := n.NotifyHeight(txDummyHeight); err != nil {\n\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t}\n\n\t// Since UpdateConfDetails has not been called for either transaction,\n\t// the height hints should remain unchanged. This simulates blocks\n\t// confirming while the historical dispatch is processing the\n\t// registration.\n\thint, err := hintCache.QueryConfirmHint(ntfn1.HistoricalDispatch.ConfRequest)\n\tif err != chainntnfs.ErrConfirmHintNotFound {\n\t\tt.Fatalf(\"unexpected error when querying for height hint \"+\n\t\t\t\"want: %v, got %v\",\n\t\t\tchainntnfs.ErrConfirmHintNotFound, err)\n\t}\n\n\thint, err = hintCache.QueryConfirmHint(ntfn2.HistoricalDispatch.ConfRequest)\n\tif err != chainntnfs.ErrConfirmHintNotFound {\n\t\tt.Fatalf(\"unexpected error when querying for height hint \"+\n\t\t\t\"want: %v, got %v\",\n\t\t\tchainntnfs.ErrConfirmHintNotFound, err)\n\t}\n\n\t// Now, update the conf details reporting that the neither txn was found\n\t// in the historical dispatch.\n\terr = n.UpdateConfDetails(ntfn1.HistoricalDispatch.ConfRequest, nil)\n\trequire.NoError(t, err, \"unable to update conf details\")\n\terr = n.UpdateConfDetails(ntfn2.HistoricalDispatch.ConfRequest, nil)\n\trequire.NoError(t, err, \"unable to update conf details\")\n\n\t// We'll create another block that will include the first transaction\n\t// and extend the chain.\n\tblock2 := btcutil.NewBlock(&wire.MsgBlock{\n\t\tTransactions: []*wire.MsgTx{&tx1},\n\t})\n\n\terr = n.ConnectTip(block2, tx1Height)\n\trequire.NoError(t, err, \"Failed to connect block\")\n\tif err := n.NotifyHeight(tx1Height); err != nil {\n\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t}\n\n\t// Now that both notifications are waiting at tip for confirmations,\n\t// they should have their height hints updated to the latest block\n\t// height.\n\thint, err = hintCache.QueryConfirmHint(ntfn1.HistoricalDispatch.ConfRequest)\n\trequire.NoError(t, err, \"unable to query for hint\")\n\tif hint != tx1Height {\n\t\tt.Fatalf(\"expected hint %d, got %d\",\n\t\t\ttx1Height, hint)\n\t}\n\n\thint, err = hintCache.QueryConfirmHint(ntfn2.HistoricalDispatch.ConfRequest)\n\trequire.NoError(t, err, \"unable to query for hint\")\n\tif hint != tx1Height {\n\t\tt.Fatalf(\"expected hint %d, got %d\",\n\t\t\ttx2Height, hint)\n\t}\n\n\t// Next, we'll create another block that will include the second\n\t// transaction and extend the chain.\n\tblock3 := btcutil.NewBlock(&wire.MsgBlock{\n\t\tTransactions: []*wire.MsgTx{&tx2},\n\t})\n\n\terr = n.ConnectTip(block3, tx2Height)\n\trequire.NoError(t, err, \"Failed to connect block\")\n\tif err := n.NotifyHeight(tx2Height); err != nil {\n\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t}\n\n\t// The height hint for the first transaction should remain the same.\n\thint, err = hintCache.QueryConfirmHint(ntfn1.HistoricalDispatch.ConfRequest)\n\trequire.NoError(t, err, \"unable to query for hint\")\n\tif hint != tx1Height {\n\t\tt.Fatalf(\"expected hint %d, got %d\",\n\t\t\ttx1Height, hint)\n\t}\n\n\t// The height hint for the second transaction should now be updated to\n\t// reflect its confirmation.\n\thint, err = hintCache.QueryConfirmHint(ntfn2.HistoricalDispatch.ConfRequest)\n\trequire.NoError(t, err, \"unable to query for hint\")\n\tif hint != tx2Height {\n\t\tt.Fatalf(\"expected hint %d, got %d\",\n\t\t\ttx2Height, hint)\n\t}\n\n\t// Finally, we'll attempt do disconnect the last block in order to\n\t// simulate a chain reorg.\n\tif err := n.DisconnectTip(tx2Height); err != nil {\n\t\tt.Fatalf(\"Failed to disconnect block: %v\", err)\n\t}\n\n\t// This should update the second transaction's height hint within the\n\t// cache to the previous height.\n\thint, err = hintCache.QueryConfirmHint(ntfn2.HistoricalDispatch.ConfRequest)\n\trequire.NoError(t, err, \"unable to query for hint\")\n\tif hint != tx1Height {\n\t\tt.Fatalf(\"expected hint %d, got %d\",\n\t\t\ttx1Height, hint)\n\t}\n\n\t// The first transaction's height hint should remain at the original\n\t// confirmation height.\n\thint, err = hintCache.QueryConfirmHint(ntfn2.HistoricalDispatch.ConfRequest)\n\trequire.NoError(t, err, \"unable to query for hint\")\n\tif hint != tx1Height {\n\t\tt.Fatalf(\"expected hint %d, got %d\",\n\t\t\ttx1Height, hint)\n\t}\n}\n\n// TestTxNotifierSpendHintCache ensures that the height hints for outpoints are\n// kept track of correctly with each new block connected/disconnected. This test\n// also asserts that the height hints are not updated until the simulated\n// historical dispatches have returned, and we know the outpoints haven't\n// already been spent in the chain.",
      "length": 5969,
      "tokens": 739,
      "embedding": []
    },
    {
      "slug": "func TestTxNotifierSpendHintCache(t *testing.T) {",
      "content": "func TestTxNotifierSpendHintCache(t *testing.T) {\n\tt.Parallel()\n\n\tconst (\n\t\tstartingHeight = 200\n\t\tdummyHeight    = 201\n\t\top1Height      = 202\n\t\top2Height      = 203\n\t)\n\n\t// Initialize our TxNotifier instance backed by a height hint cache.\n\thintCache := newMockHintCache()\n\tn := chainntnfs.NewTxNotifier(\n\t\tstartingHeight, chainntnfs.ReorgSafetyLimit, hintCache,\n\t\thintCache,\n\t)\n\n\t// Create two test outpoints and register them for spend notifications.\n\top1 := wire.OutPoint{Index: 1}\n\tntfn1, err := n.RegisterSpend(&op1, testRawScript, 1)\n\trequire.NoError(t, err, \"unable to register spend for op1\")\n\top2 := wire.OutPoint{Index: 2}\n\tntfn2, err := n.RegisterSpend(&op2, testRawScript, 1)\n\trequire.NoError(t, err, \"unable to register spend for op2\")\n\n\t// Both outpoints should not have a spend hint set upon registration, as\n\t// we must first determine whether they have already been spent in the\n\t// chain.\n\t_, err = hintCache.QuerySpendHint(ntfn1.HistoricalDispatch.SpendRequest)\n\tif err != chainntnfs.ErrSpendHintNotFound {\n\t\tt.Fatalf(\"unexpected error when querying for height hint \"+\n\t\t\t\"expected: %v, got %v\", chainntnfs.ErrSpendHintNotFound,\n\t\t\terr)\n\t}\n\t_, err = hintCache.QuerySpendHint(ntfn2.HistoricalDispatch.SpendRequest)\n\tif err != chainntnfs.ErrSpendHintNotFound {\n\t\tt.Fatalf(\"unexpected error when querying for height hint \"+\n\t\t\t\"expected: %v, got %v\", chainntnfs.ErrSpendHintNotFound,\n\t\t\terr)\n\t}\n\n\t// Create a new empty block and extend the chain.\n\temptyBlock := btcutil.NewBlock(&wire.MsgBlock{})\n\terr = n.ConnectTip(emptyBlock, dummyHeight)\n\trequire.NoError(t, err, \"unable to connect block\")\n\tif err := n.NotifyHeight(dummyHeight); err != nil {\n\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t}\n\n\t// Since we haven't called UpdateSpendDetails on any of the test\n\t// outpoints, this implies that there is a still a pending historical\n\t// rescan for them, so their spend hints should not be created/updated.\n\t_, err = hintCache.QuerySpendHint(ntfn1.HistoricalDispatch.SpendRequest)\n\tif err != chainntnfs.ErrSpendHintNotFound {\n\t\tt.Fatalf(\"unexpected error when querying for height hint \"+\n\t\t\t\"expected: %v, got %v\", chainntnfs.ErrSpendHintNotFound,\n\t\t\terr)\n\t}\n\t_, err = hintCache.QuerySpendHint(ntfn2.HistoricalDispatch.SpendRequest)\n\tif err != chainntnfs.ErrSpendHintNotFound {\n\t\tt.Fatalf(\"unexpected error when querying for height hint \"+\n\t\t\t\"expected: %v, got %v\", chainntnfs.ErrSpendHintNotFound,\n\t\t\terr)\n\t}\n\n\t// Now, we'll simulate that their historical rescans have finished by\n\t// calling UpdateSpendDetails. This should allow their spend hints to be\n\t// updated upon every block connected/disconnected.\n\terr = n.UpdateSpendDetails(ntfn1.HistoricalDispatch.SpendRequest, nil)\n\trequire.NoError(t, err, \"unable to update spend details\")\n\terr = n.UpdateSpendDetails(ntfn2.HistoricalDispatch.SpendRequest, nil)\n\trequire.NoError(t, err, \"unable to update spend details\")\n\n\t// We'll create a new block that only contains the spending transaction\n\t// of the first outpoint.\n\tspendTx1 := wire.NewMsgTx(2)\n\tspendTx1.AddTxIn(&wire.TxIn{\n\t\tPreviousOutPoint: op1,\n\t\tSignatureScript:  testSigScript,\n\t})\n\tblock1 := btcutil.NewBlock(&wire.MsgBlock{\n\t\tTransactions: []*wire.MsgTx{spendTx1},\n\t})\n\terr = n.ConnectTip(block1, op1Height)\n\trequire.NoError(t, err, \"unable to connect block\")\n\tif err := n.NotifyHeight(op1Height); err != nil {\n\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t}\n\n\t// Both outpoints should have their spend hints reflect the height of\n\t// the new block being connected due to the first outpoint being spent\n\t// at this height, and the second outpoint still being unspent.\n\top1Hint, err := hintCache.QuerySpendHint(ntfn1.HistoricalDispatch.SpendRequest)\n\trequire.NoError(t, err, \"unable to query for spend hint of op1\")\n\tif op1Hint != op1Height {\n\t\tt.Fatalf(\"expected hint %d, got %d\", op1Height, op1Hint)\n\t}\n\top2Hint, err := hintCache.QuerySpendHint(ntfn2.HistoricalDispatch.SpendRequest)\n\trequire.NoError(t, err, \"unable to query for spend hint of op2\")\n\tif op2Hint != op1Height {\n\t\tt.Fatalf(\"expected hint %d, got %d\", op1Height, op2Hint)\n\t}\n\n\t// Then, we'll create another block that spends the second outpoint.\n\tspendTx2 := wire.NewMsgTx(2)\n\tspendTx2.AddTxIn(&wire.TxIn{\n\t\tPreviousOutPoint: op2,\n\t\tSignatureScript:  testSigScript,\n\t})\n\tblock2 := btcutil.NewBlock(&wire.MsgBlock{\n\t\tTransactions: []*wire.MsgTx{spendTx2},\n\t})\n\terr = n.ConnectTip(block2, op2Height)\n\trequire.NoError(t, err, \"unable to connect block\")\n\tif err := n.NotifyHeight(op2Height); err != nil {\n\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t}\n\n\t// Only the second outpoint should have its spend hint updated due to\n\t// being spent within the new block. The first outpoint's spend hint\n\t// should remain the same as it's already been spent before.\n\top1Hint, err = hintCache.QuerySpendHint(ntfn1.HistoricalDispatch.SpendRequest)\n\trequire.NoError(t, err, \"unable to query for spend hint of op1\")\n\tif op1Hint != op1Height {\n\t\tt.Fatalf(\"expected hint %d, got %d\", op1Height, op1Hint)\n\t}\n\top2Hint, err = hintCache.QuerySpendHint(ntfn2.HistoricalDispatch.SpendRequest)\n\trequire.NoError(t, err, \"unable to query for spend hint of op2\")\n\tif op2Hint != op2Height {\n\t\tt.Fatalf(\"expected hint %d, got %d\", op2Height, op2Hint)\n\t}\n\n\t// Finally, we'll attempt do disconnect the last block in order to\n\t// simulate a chain reorg.\n\tif err := n.DisconnectTip(op2Height); err != nil {\n\t\tt.Fatalf(\"unable to disconnect block: %v\", err)\n\t}\n\n\t// This should update the second outpoint's spend hint within the cache\n\t// to the previous height, as that's where its spending transaction was\n\t// included in within the chain. The first outpoint's spend hint should\n\t// remain the same.\n\top1Hint, err = hintCache.QuerySpendHint(ntfn1.HistoricalDispatch.SpendRequest)\n\trequire.NoError(t, err, \"unable to query for spend hint of op1\")\n\tif op1Hint != op1Height {\n\t\tt.Fatalf(\"expected hint %d, got %d\", op1Height, op1Hint)\n\t}\n\top2Hint, err = hintCache.QuerySpendHint(ntfn2.HistoricalDispatch.SpendRequest)\n\trequire.NoError(t, err, \"unable to query for spend hint of op2\")\n\tif op2Hint != op1Height {\n\t\tt.Fatalf(\"expected hint %d, got %d\", op1Height, op2Hint)\n\t}\n}\n\n// TestTxNotifierSpendHinthistoricalRescan checks that the height hints and\n// spend notifications behave as expected when a spend is found at tip during a\n// historical rescan.",
      "length": 6141,
      "tokens": 773,
      "embedding": []
    },
    {
      "slug": "func TestTxNotifierSpendDuringHistoricalRescan(t *testing.T) {",
      "content": "func TestTxNotifierSpendDuringHistoricalRescan(t *testing.T) {\n\tt.Parallel()\n\n\tconst (\n\t\tstartingHeight = 200\n\t\treorgSafety    = 10\n\t)\n\n\t// Initialize our TxNotifier instance backed by a height hint cache.\n\thintCache := newMockHintCache()\n\tn := chainntnfs.NewTxNotifier(\n\t\tstartingHeight, reorgSafety, hintCache, hintCache,\n\t)\n\n\t// Create a test outpoint and register it for spend notifications.\n\top1 := wire.OutPoint{Index: 1}\n\tntfn1, err := n.RegisterSpend(&op1, testRawScript, 1)\n\trequire.NoError(t, err, \"unable to register spend for op1\")\n\n\t// A historical rescan should be initiated from the height hint to the\n\t// current height.\n\tif ntfn1.HistoricalDispatch.StartHeight != 1 {\n\t\tt.Fatalf(\"expected historical dispatch to start at height hint\")\n\t}\n\n\tif ntfn1.HistoricalDispatch.EndHeight != startingHeight {\n\t\tt.Fatalf(\"expected historical dispatch to end at current height\")\n\t}\n\n\t// It should not have a spend hint set upon registration, as we must\n\t// first determine whether it has already been spent in the chain.\n\t_, err = hintCache.QuerySpendHint(ntfn1.HistoricalDispatch.SpendRequest)\n\tif err != chainntnfs.ErrSpendHintNotFound {\n\t\tt.Fatalf(\"unexpected error when querying for height hint \"+\n\t\t\t\"expected: %v, got %v\", chainntnfs.ErrSpendHintNotFound,\n\t\t\terr)\n\t}\n\n\t// Create a new empty block and extend the chain.\n\theight := uint32(startingHeight) + 1\n\temptyBlock := btcutil.NewBlock(&wire.MsgBlock{})\n\terr = n.ConnectTip(emptyBlock, height)\n\trequire.NoError(t, err, \"unable to connect block\")\n\tif err := n.NotifyHeight(height); err != nil {\n\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t}\n\n\t// Since we haven't called UpdateSpendDetails yet, there should be no\n\t// spend hint found.\n\t_, err = hintCache.QuerySpendHint(ntfn1.HistoricalDispatch.SpendRequest)\n\tif err != chainntnfs.ErrSpendHintNotFound {\n\t\tt.Fatalf(\"unexpected error when querying for height hint \"+\n\t\t\t\"expected: %v, got %v\", chainntnfs.ErrSpendHintNotFound,\n\t\t\terr)\n\t}\n\n\t// Simulate a bunch of blocks being mined while the historical rescan\n\t// is still in progress. We make sure to not mine more than reorgSafety\n\t// blocks after the spend, since it will be forgotten then.\n\tvar spendHeight uint32\n\tfor i := 0; i < reorgSafety; i++ {\n\t\theight++\n\n\t\t// Let the outpoint we are watching be spent midway.\n\t\tvar block *btcutil.Block\n\t\tif i == 5 {\n\t\t\t// We'll create a new block that only contains the\n\t\t\t// spending transaction of the outpoint.\n\t\t\tspendTx1 := wire.NewMsgTx(2)\n\t\t\tspendTx1.AddTxIn(&wire.TxIn{\n\t\t\t\tPreviousOutPoint: op1,\n\t\t\t\tSignatureScript:  testSigScript,\n\t\t\t})\n\t\t\tblock = btcutil.NewBlock(&wire.MsgBlock{\n\t\t\t\tTransactions: []*wire.MsgTx{spendTx1},\n\t\t\t})\n\t\t\tspendHeight = height\n\t\t} else {\n\t\t\t// Otherwise we just create an empty block.\n\t\t\tblock = btcutil.NewBlock(&wire.MsgBlock{})\n\t\t}\n\n\t\terr = n.ConnectTip(block, height)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to connect block: %v\", err)\n\t\t}\n\t\tif err := n.NotifyHeight(height); err != nil {\n\t\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t\t}\n\t}\n\n\t// Check that the height hint was set to the spending block.\n\top1Hint, err := hintCache.QuerySpendHint(\n\t\tntfn1.HistoricalDispatch.SpendRequest,\n\t)\n\trequire.NoError(t, err, \"unable to query for spend hint of op1\")\n\tif op1Hint != spendHeight {\n\t\tt.Fatalf(\"expected hint %d, got %d\", spendHeight, op1Hint)\n\t}\n\n\t// We should be getting notified about the spend at this point.\n\tselect {\n\tcase <-ntfn1.Event.Spend:\n\tdefault:\n\t\tt.Fatal(\"expected to receive spend notification\")\n\t}\n\n\t// Now, we'll simulate that the historical rescan finished by\n\t// calling UpdateSpendDetails. Since a the spend actually happened at\n\t// tip while the rescan was in progress, the height hint should not be\n\t// updated to the latest height, but stay at the spend height.\n\terr = n.UpdateSpendDetails(ntfn1.HistoricalDispatch.SpendRequest, nil)\n\trequire.NoError(t, err, \"unable to update spend details\")\n\n\top1Hint, err = hintCache.QuerySpendHint(\n\t\tntfn1.HistoricalDispatch.SpendRequest,\n\t)\n\trequire.NoError(t, err, \"unable to query for spend hint of op1\")\n\tif op1Hint != spendHeight {\n\t\tt.Fatalf(\"expected hint %d, got %d\", spendHeight, op1Hint)\n\t}\n\n\t// Then, we'll create another block that spends a second outpoint.\n\top2 := wire.OutPoint{Index: 2}\n\tspendTx2 := wire.NewMsgTx(2)\n\tspendTx2.AddTxIn(&wire.TxIn{\n\t\tPreviousOutPoint: op2,\n\t\tSignatureScript:  testSigScript,\n\t})\n\theight++\n\tblock2 := btcutil.NewBlock(&wire.MsgBlock{\n\t\tTransactions: []*wire.MsgTx{spendTx2},\n\t})\n\terr = n.ConnectTip(block2, height)\n\trequire.NoError(t, err, \"unable to connect block\")\n\tif err := n.NotifyHeight(height); err != nil {\n\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t}\n\n\t// The outpoint's spend hint should remain the same as it's already\n\t// been spent before.\n\top1Hint, err = hintCache.QuerySpendHint(ntfn1.HistoricalDispatch.SpendRequest)\n\trequire.NoError(t, err, \"unable to query for spend hint of op1\")\n\tif op1Hint != spendHeight {\n\t\tt.Fatalf(\"expected hint %d, got %d\", spendHeight, op1Hint)\n\t}\n\n\t// Now mine enough blocks for the spend notification to be forgotten.\n\tfor i := 0; i < 2*reorgSafety; i++ {\n\t\theight++\n\t\tblock := btcutil.NewBlock(&wire.MsgBlock{})\n\n\t\terr := n.ConnectTip(block, height)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to connect block: %v\", err)\n\t\t}\n\t\tif err := n.NotifyHeight(height); err != nil {\n\t\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t\t}\n\t}\n\n\t// Attempting to update spend details at this point should fail, since\n\t// the spend request should be removed. This is to ensure the height\n\t// hint won't be overwritten if the historical rescan finishes after\n\t// the spend request has been notified and removed because it has\n\t// matured.\n\terr = n.UpdateSpendDetails(ntfn1.HistoricalDispatch.SpendRequest, nil)\n\tif err == nil {\n\t\tt.Fatalf(\"expected updating spend details to fail\")\n\t}\n\n\t// Finally, check that the height hint is still there, unchanged.\n\top1Hint, err = hintCache.QuerySpendHint(ntfn1.HistoricalDispatch.SpendRequest)\n\trequire.NoError(t, err, \"unable to query for spend hint of op1\")\n\tif op1Hint != spendHeight {\n\t\tt.Fatalf(\"expected hint %d, got %d\", spendHeight, op1Hint)\n\t}\n}\n\n// TestTxNotifierNtfnDone ensures that a notification is sent to registered\n// clients through the Done channel once the notification request is no longer\n// under the risk of being reorged out of the chain.",
      "length": 6090,
      "tokens": 831,
      "embedding": []
    },
    {
      "slug": "func TestTxNotifierNtfnDone(t *testing.T) {",
      "content": "func TestTxNotifierNtfnDone(t *testing.T) {\n\tt.Parallel()\n\n\thintCache := newMockHintCache()\n\tconst reorgSafetyLimit = 100\n\tn := chainntnfs.NewTxNotifier(10, reorgSafetyLimit, hintCache, hintCache)\n\n\t// We'll start by creating two notification requests: one confirmation\n\t// and one spend.\n\tconfNtfn, err := n.RegisterConf(&chainntnfs.ZeroHash, testRawScript, 1, 1)\n\trequire.NoError(t, err, \"unable to register conf ntfn\")\n\tspendNtfn, err := n.RegisterSpend(&chainntnfs.ZeroOutPoint, testRawScript, 1)\n\trequire.NoError(t, err, \"unable to register spend\")\n\n\t// We'll create two transactions that will satisfy the notification\n\t// requests above and include them in the next block of the chain.\n\ttx := wire.NewMsgTx(1)\n\ttx.AddTxOut(&wire.TxOut{PkScript: testRawScript})\n\tspendTx := wire.NewMsgTx(1)\n\tspendTx.AddTxIn(&wire.TxIn{\n\t\tPreviousOutPoint: wire.OutPoint{Index: 1},\n\t\tSignatureScript:  testSigScript,\n\t})\n\tblock := btcutil.NewBlock(&wire.MsgBlock{\n\t\tTransactions: []*wire.MsgTx{tx, spendTx},\n\t})\n\n\terr = n.ConnectTip(block, 11)\n\trequire.NoError(t, err, \"unable to connect block\")\n\tif err := n.NotifyHeight(11); err != nil {\n\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t}\n\n\t// With the chain extended, we should see notifications dispatched for\n\t// both requests.\n\tselect {\n\tcase <-confNtfn.Event.Confirmed:\n\tdefault:\n\t\tt.Fatal(\"expected to receive confirmation notification\")\n\t}\n\n\tselect {\n\tcase <-spendNtfn.Event.Spend:\n\tdefault:\n\t\tt.Fatal(\"expected to receive spend notification\")\n\t}\n\n\t// The done notifications should not be dispatched yet as the requests\n\t// are still under the risk of being reorged out the chain.\n\tselect {\n\tcase <-confNtfn.Event.Done:\n\t\tt.Fatal(\"received unexpected done notification for confirmation\")\n\tcase <-spendNtfn.Event.Done:\n\t\tt.Fatal(\"received unexpected done notification for spend\")\n\tdefault:\n\t}\n\n\t// Now, we'll disconnect the block at tip to simulate a reorg. The reorg\n\t// notifications should be dispatched to the respective clients.\n\tif err := n.DisconnectTip(11); err != nil {\n\t\tt.Fatalf(\"unable to disconnect block: %v\", err)\n\t}\n\n\tselect {\n\tcase <-confNtfn.Event.NegativeConf:\n\tdefault:\n\t\tt.Fatal(\"expected to receive reorg notification for confirmation\")\n\t}\n\n\tselect {\n\tcase <-spendNtfn.Event.Reorg:\n\tdefault:\n\t\tt.Fatal(\"expected to receive reorg notification for spend\")\n\t}\n\n\t// We'll reconnect the block that satisfies both of these requests.\n\t// We should see notifications dispatched for both once again.\n\terr = n.ConnectTip(block, 11)\n\trequire.NoError(t, err, \"unable to connect block\")\n\tif err := n.NotifyHeight(11); err != nil {\n\t\tt.Fatalf(\"unable to dispatch notifications: %v\", err)\n\t}\n\n\tselect {\n\tcase <-confNtfn.Event.Confirmed:\n\tdefault:\n\t\tt.Fatal(\"expected to receive confirmation notification\")\n\t}\n\n\tselect {\n\tcase <-spendNtfn.Event.Spend:\n\tdefault:\n\t\tt.Fatal(\"expected to receive spend notification\")\n\t}\n\n\t// Finally, we'll extend the chain with blocks until the requests are no\n\t// longer under the risk of being reorged out of the chain. We should\n\t// expect the done notifications to be dispatched.\n\tnextHeight := uint32(12)\n\tfor i := nextHeight; i < nextHeight+reorgSafetyLimit; i++ {\n\t\tdummyBlock := btcutil.NewBlock(&wire.MsgBlock{})\n\t\tif err := n.ConnectTip(dummyBlock, i); err != nil {\n\t\t\tt.Fatalf(\"unable to connect block: %v\", err)\n\t\t}\n\t}\n\n\tselect {\n\tcase <-confNtfn.Event.Done:\n\tdefault:\n\t\tt.Fatal(\"expected to receive done notification for confirmation\")\n\t}\n\n\tselect {\n\tcase <-spendNtfn.Event.Done:\n\tdefault:\n\t\tt.Fatal(\"expected to receive done notification for spend\")\n\t}\n}\n\n// TestTxNotifierTearDown ensures that the TxNotifier properly alerts clients\n// that it is shutting down and will be unable to deliver notifications.",
      "length": 3548,
      "tokens": 452,
      "embedding": []
    },
    {
      "slug": "func TestTxNotifierTearDown(t *testing.T) {",
      "content": "func TestTxNotifierTearDown(t *testing.T) {\n\tt.Parallel()\n\n\thintCache := newMockHintCache()\n\tn := chainntnfs.NewTxNotifier(\n\t\t10, chainntnfs.ReorgSafetyLimit, hintCache, hintCache,\n\t)\n\n\t// To begin the test, we'll register for a confirmation and spend\n\t// notification.\n\tconfNtfn, err := n.RegisterConf(&chainntnfs.ZeroHash, testRawScript, 1, 1)\n\trequire.NoError(t, err, \"unable to register conf ntfn\")\n\tspendNtfn, err := n.RegisterSpend(&chainntnfs.ZeroOutPoint, testRawScript, 1)\n\trequire.NoError(t, err, \"unable to register spend ntfn\")\n\n\t// With the notifications registered, we'll now tear down the notifier.\n\t// The notification channels should be closed for notifications, whether\n\t// they have been dispatched or not, so we should not expect to receive\n\t// any more updates.\n\tn.TearDown()\n\n\tselect {\n\tcase _, ok := <-confNtfn.Event.Confirmed:\n\t\tif ok {\n\t\t\tt.Fatal(\"expected closed Confirmed channel for conf ntfn\")\n\t\t}\n\tcase _, ok := <-confNtfn.Event.Updates:\n\t\tif ok {\n\t\t\tt.Fatal(\"expected closed Updates channel for conf ntfn\")\n\t\t}\n\tcase _, ok := <-confNtfn.Event.NegativeConf:\n\t\tif ok {\n\t\t\tt.Fatal(\"expected closed NegativeConf channel for conf ntfn\")\n\t\t}\n\tcase _, ok := <-spendNtfn.Event.Spend:\n\t\tif ok {\n\t\t\tt.Fatal(\"expected closed Spend channel for spend ntfn\")\n\t\t}\n\tcase _, ok := <-spendNtfn.Event.Reorg:\n\t\tif ok {\n\t\t\tt.Fatalf(\"expected closed Reorg channel for spend ntfn\")\n\t\t}\n\tdefault:\n\t\tt.Fatalf(\"expected closed notification channels for all ntfns\")\n\t}\n\n\t// Now that the notifier is torn down, we should no longer be able to\n\t// register notification requests.\n\t_, err = n.RegisterConf(&chainntnfs.ZeroHash, testRawScript, 1, 1)\n\tif err == nil {\n\t\tt.Fatal(\"expected confirmation registration to fail\")\n\t}\n\t_, err = n.RegisterSpend(&chainntnfs.ZeroOutPoint, testRawScript, 1)\n\tif err == nil {\n\t\tt.Fatal(\"expected spend registration to fail\")\n\t}\n}\n",
      "length": 1766,
      "tokens": 239,
      "embedding": []
    },
    {
      "slug": "func assertConfDetails(t *testing.T, result, expected *chainntnfs.TxConfirmation) {",
      "content": "func assertConfDetails(t *testing.T, result, expected *chainntnfs.TxConfirmation) {\n\tt.Helper()\n\n\tif result.BlockHeight != expected.BlockHeight {\n\t\tt.Fatalf(\"Incorrect block height in confirmation details: \"+\n\t\t\t\"expected %d, got %d\", expected.BlockHeight,\n\t\t\tresult.BlockHeight)\n\t}\n\tif !result.BlockHash.IsEqual(expected.BlockHash) {\n\t\tt.Fatalf(\"Incorrect block hash in confirmation details: \"+\n\t\t\t\"expected %d, got %d\", expected.BlockHash,\n\t\t\tresult.BlockHash)\n\t}\n\tif result.TxIndex != expected.TxIndex {\n\t\tt.Fatalf(\"Incorrect tx index in confirmation details: \"+\n\t\t\t\"expected %d, got %d\", expected.TxIndex, result.TxIndex)\n\t}\n\tif result.Tx.TxHash() != expected.Tx.TxHash() {\n\t\tt.Fatalf(\"expected tx hash %v, got %v\", expected.Tx.TxHash(),\n\t\t\tresult.Tx.TxHash())\n\t}\n}\n",
      "length": 665,
      "tokens": 71,
      "embedding": []
    },
    {
      "slug": "func assertSpendDetails(t *testing.T, result, expected *chainntnfs.SpendDetail) {",
      "content": "func assertSpendDetails(t *testing.T, result, expected *chainntnfs.SpendDetail) {\n\tt.Helper()\n\n\tif *result.SpentOutPoint != *expected.SpentOutPoint {\n\t\tt.Fatalf(\"expected spent outpoint %v, got %v\",\n\t\t\texpected.SpentOutPoint, result.SpentOutPoint)\n\t}\n\tif !result.SpenderTxHash.IsEqual(expected.SpenderTxHash) {\n\t\tt.Fatalf(\"expected spender tx hash %v, got %v\",\n\t\t\texpected.SpenderTxHash, result.SpenderTxHash)\n\t}\n\tif result.SpenderInputIndex != expected.SpenderInputIndex {\n\t\tt.Fatalf(\"expected spender input index %d, got %d\",\n\t\t\texpected.SpenderInputIndex, result.SpenderInputIndex)\n\t}\n\tif result.SpendingHeight != expected.SpendingHeight {\n\t\tt.Fatalf(\"expected spending height %d, got %d\",\n\t\t\texpected.SpendingHeight, result.SpendingHeight)\n\t}\n}\n",
      "length": 648,
      "tokens": 58,
      "embedding": []
    }
  ]
}