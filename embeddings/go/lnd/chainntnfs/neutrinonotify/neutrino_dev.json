{
  "filepath": "../implementations/go/lnd/chainntnfs/neutrinonotify/neutrino_dev.go",
  "package": "neutrinonotify",
  "sections": [
    {
      "slug": "//go:build dev",
      "content": "//go:build dev\n// +build dev\n\npackage neutrinonotify\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/btcsuite/btcd/chaincfg/chainhash\"\n\t\"github.com/btcsuite/btcd/rpcclient\"\n\t\"github.com/lightninglabs/neutrino\"\n\t\"github.com/lightningnetwork/lnd/chainntnfs\"\n)\n\n// UnsafeStart starts the notifier with a specified best height and optional\n// best hash. Its bestHeight, txNotifier and neutrino node are initialized with\n// bestHeight. The parameter generateBlocks is necessary for the bitcoind\n// notifier to ensure we drain all notifications up to syncHeight, since if they\n// are generated ahead of UnsafeStart the chainConn may start up with an\n// outdated best block and miss sending ntfns. Used for testing.",
      "length": 665,
      "tokens": 86,
      "embedding": []
    },
    {
      "slug": "func (n *NeutrinoNotifier) UnsafeStart(bestHeight int32,",
      "content": "func (n *NeutrinoNotifier) UnsafeStart(bestHeight int32,\n\tbestHash *chainhash.Hash, syncHeight int32,\n\tgenerateBlocks func() error) error {\n\n\t// We'll obtain the latest block height of the p2p node. We'll\n\t// start the auto-rescan from this point. Once a caller actually wishes\n\t// to register a chain view, the rescan state will be rewound\n\t// accordingly.\n\tstartingPoint, err := n.p2pNode.BestBlock()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Next, we'll create our set of rescan options. Currently it's\n\t// required that a user MUST set an addr/outpoint/txid when creating a\n\t// rescan. To get around this, we'll add a \"zero\" outpoint, that won't\n\t// actually be matched.\n\tvar zeroInput neutrino.InputWithScript\n\trescanOptions := []neutrino.RescanOption{\n\t\tneutrino.StartBlock(startingPoint),\n\t\tneutrino.QuitChan(n.quit),\n\t\tneutrino.NotificationHandlers(\n\t\t\trpcclient.NotificationHandlers{\n\t\t\t\tOnFilteredBlockConnected:    n.onFilteredBlockConnected,\n\t\t\t\tOnFilteredBlockDisconnected: n.onFilteredBlockDisconnected,\n\t\t\t},\n\t\t),\n\t\tneutrino.WatchInputs(zeroInput),\n\t}\n\n\tn.txNotifier = chainntnfs.NewTxNotifier(\n\t\tuint32(bestHeight), chainntnfs.ReorgSafetyLimit,\n\t\tn.confirmHintCache, n.spendHintCache,\n\t)\n\n\t// Finally, we'll create our rescan struct, start it, and launch all\n\t// the goroutines we need to operate this ChainNotifier instance.\n\tn.chainView = neutrino.NewRescan(\n\t\t&neutrino.RescanChainSource{\n\t\t\tChainService: n.p2pNode,\n\t\t},\n\t\trescanOptions...,\n\t)\n\tn.rescanErr = n.chainView.Start()\n\n\tn.txUpdates.Start()\n\n\tif generateBlocks != nil {\n\t\t// Ensure no block notifications are pending when we start the\n\t\t// notification dispatcher goroutine.\n\n\t\t// First generate the blocks, then drain the notifications\n\t\t// for the generated blocks.\n\t\tif err := generateBlocks(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\ttimeout := time.After(60 * time.Second)\n\tloop:\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase ntfn := <-n.chainUpdates:\n\t\t\t\tlastReceivedNtfn := ntfn\n\t\t\t\tif lastReceivedNtfn.height >= uint32(syncHeight) {\n\t\t\t\t\tbreak loop\n\t\t\t\t}\n\t\t\tcase <-timeout:\n\t\t\t\treturn fmt.Errorf(\"unable to catch up to height %d\",\n\t\t\t\t\tsyncHeight)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Run notificationDispatcher after setting the notifier's best height\n\t// to avoid a race condition.\n\tn.bestBlock.Hash = bestHash\n\tn.bestBlock.Height = bestHeight\n\n\tn.wg.Add(1)\n\tgo n.notificationDispatcher()\n\n\treturn nil\n}\n",
      "length": 2207,
      "tokens": 271,
      "embedding": []
    }
  ]
}