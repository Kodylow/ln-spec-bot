{
  "filepath": "../implementations/go/lnd/chainntnfs/txnotifier.go",
  "package": "chainntnfs",
  "sections": [
    {
      "slug": "type rescanState byte",
      "content": "type rescanState byte\n\nconst (\n\t// rescanNotStarted is the initial state, denoting that a historical\n\t// dispatch may be required.\n\trescanNotStarted rescanState = iota\n\n\t// rescanPending indicates that a dispatch has already been made, and we\n\t// are waiting for its completion. No other rescans should be dispatched\n\t// while in this state.\n\trescanPending\n\n\t// rescanComplete signals either that a rescan was dispatched and has\n\t// completed, or that we began watching at tip immediately. In either\n\t// case, the notifier can only dispatch notifications from tip when in\n\t// this state.\n\trescanComplete\n)\n\n// confNtfnSet holds all known, registered confirmation notifications for a\n// txid/output script. If duplicates notifications are requested, only one\n// historical dispatch will be spawned to ensure redundant scans are not\n// permitted. A single conf detail will be constructed and dispatched to all\n// interested\n// clients.",
      "length": 888,
      "tokens": 140,
      "embedding": []
    },
    {
      "slug": "type confNtfnSet struct {",
      "content": "type confNtfnSet struct {\n\t// ntfns keeps tracks of all the active client notification requests for\n\t// a transaction/output script\n\tntfns map[uint64]*ConfNtfn\n\n\t// rescanStatus represents the current rescan state for the\n\t// transaction/output script.\n\trescanStatus rescanState\n\n\t// details serves as a cache of the confirmation details of a\n\t// transaction that we'll use to determine if a transaction/output\n\t// script has already confirmed at the time of registration.\n\t// details is also used to make sure that in case of an address reuse\n\t// (funds sent to a previously confirmed script) no additional\n\t// notification is registered which would lead to an inconsistent state.\n\tdetails *TxConfirmation\n}\n\n// newConfNtfnSet constructs a fresh confNtfnSet for a group of clients\n// interested in a notification for a particular txid.",
      "length": 792,
      "tokens": 123,
      "embedding": []
    },
    {
      "slug": "func newConfNtfnSet() *confNtfnSet {",
      "content": "func newConfNtfnSet() *confNtfnSet {\n\treturn &confNtfnSet{\n\t\tntfns:        make(map[uint64]*ConfNtfn),\n\t\trescanStatus: rescanNotStarted,\n\t}\n}\n\n// spendNtfnSet holds all known, registered spend notifications for a spend\n// request (outpoint/output script). If duplicate notifications are requested,\n// only one historical dispatch will be spawned to ensure redundant scans are\n// not permitted.",
      "length": 347,
      "tokens": 44,
      "embedding": []
    },
    {
      "slug": "type spendNtfnSet struct {",
      "content": "type spendNtfnSet struct {\n\t// ntfns keeps tracks of all the active client notification requests for\n\t// an outpoint/output script.\n\tntfns map[uint64]*SpendNtfn\n\n\t// rescanStatus represents the current rescan state for the spend\n\t// request (outpoint/output script).\n\trescanStatus rescanState\n\n\t// details serves as a cache of the spend details for an outpoint/output\n\t// script that we'll use to determine if it has already been spent at\n\t// the time of registration.\n\tdetails *SpendDetail\n}\n\n// newSpendNtfnSet constructs a new spend notification set.",
      "length": 512,
      "tokens": 77,
      "embedding": []
    },
    {
      "slug": "func newSpendNtfnSet() *spendNtfnSet {",
      "content": "func newSpendNtfnSet() *spendNtfnSet {\n\treturn &spendNtfnSet{\n\t\tntfns:        make(map[uint64]*SpendNtfn),\n\t\trescanStatus: rescanNotStarted,\n\t}\n}\n\n// ConfRequest encapsulates a request for a confirmation notification of either\n// a txid or output script.",
      "length": 208,
      "tokens": 25,
      "embedding": []
    },
    {
      "slug": "type ConfRequest struct {",
      "content": "type ConfRequest struct {\n\t// TxID is the hash of the transaction for which confirmation\n\t// notifications are requested. If set to a zero hash, then a\n\t// confirmation notification will be dispatched upon inclusion of the\n\t// _script_, rather than the txid.\n\tTxID chainhash.Hash\n\n\t// PkScript is the public key script of an outpoint created in this\n\t// transaction.\n\tPkScript txscript.PkScript\n}\n\n// NewConfRequest creates a request for a confirmation notification of either a\n// txid or output script. A nil txid or an allocated ZeroHash can be used to\n// dispatch the confirmation notification on the script.",
      "length": 572,
      "tokens": 95,
      "embedding": []
    },
    {
      "slug": "func NewConfRequest(txid *chainhash.Hash, pkScript []byte) (ConfRequest, error) {",
      "content": "func NewConfRequest(txid *chainhash.Hash, pkScript []byte) (ConfRequest, error) {\n\tvar r ConfRequest\n\toutputScript, err := txscript.ParsePkScript(pkScript)\n\tif err != nil {\n\t\treturn r, err\n\t}\n\n\t// We'll only set a txid for which we'll dispatch a confirmation\n\t// notification on this request if one was provided. Otherwise, we'll\n\t// default to dispatching on the confirmation of the script instead.\n\tif txid != nil {\n\t\tr.TxID = *txid\n\t}\n\tr.PkScript = outputScript\n\n\treturn r, nil\n}\n\n// String returns the string representation of the ConfRequest.",
      "length": 448,
      "tokens": 75,
      "embedding": []
    },
    {
      "slug": "func (r ConfRequest) String() string {",
      "content": "func (r ConfRequest) String() string {\n\tif r.TxID != ZeroHash {\n\t\treturn fmt.Sprintf(\"txid=%v\", r.TxID)\n\t}\n\treturn fmt.Sprintf(\"script=%v\", r.PkScript)\n}\n\n// MatchesTx determines whether the given transaction satisfies the confirmation\n// request. If the confirmation request is for a script, then we'll check all of\n// the outputs of the transaction to determine if it matches. Otherwise, we'll\n// match on the txid.",
      "length": 369,
      "tokens": 56,
      "embedding": []
    },
    {
      "slug": "func (r ConfRequest) MatchesTx(tx *wire.MsgTx) bool {",
      "content": "func (r ConfRequest) MatchesTx(tx *wire.MsgTx) bool {\n\tscriptMatches := func() bool {\n\t\tpkScript := r.PkScript.Script()\n\t\tfor _, txOut := range tx.TxOut {\n\t\t\tif bytes.Equal(txOut.PkScript, pkScript) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\n\t\treturn false\n\t}\n\n\tif r.TxID != ZeroHash {\n\t\treturn r.TxID == tx.TxHash() && scriptMatches()\n\t}\n\n\treturn scriptMatches()\n}\n\n// ConfNtfn represents a notifier client's request to receive a notification\n// once the target transaction/output script gets sufficient confirmations. The\n// client is asynchronously notified via the ConfirmationEvent channels.",
      "length": 507,
      "tokens": 71,
      "embedding": []
    },
    {
      "slug": "type ConfNtfn struct {",
      "content": "type ConfNtfn struct {\n\t// ConfID uniquely identifies the confirmation notification request for\n\t// the specified transaction/output script.\n\tConfID uint64\n\n\t// ConfRequest represents either the txid or script we should detect\n\t// inclusion of within the chain.\n\tConfRequest\n\n\t// NumConfirmations is the number of confirmations after which the\n\t// notification is to be sent.\n\tNumConfirmations uint32\n\n\t// Event contains references to the channels that the notifications are to\n\t// be sent over.\n\tEvent *ConfirmationEvent\n\n\t// HeightHint is the minimum height in the chain that we expect to find\n\t// this txid.\n\tHeightHint uint32\n\n\t// dispatched is false if the confirmed notification has not been sent yet.\n\tdispatched bool\n\n\t// includeBlock is true if the dispatched notification should also have\n\t// the block included with it.\n\tincludeBlock bool\n}\n\n// HistoricalConfDispatch parametrizes a manual rescan for a particular\n// transaction/output script. The parameters include the start and end block\n// heights specifying the range of blocks to scan.",
      "length": 999,
      "tokens": 153,
      "embedding": []
    },
    {
      "slug": "type HistoricalConfDispatch struct {",
      "content": "type HistoricalConfDispatch struct {\n\t// ConfRequest represents either the txid or script we should detect\n\t// inclusion of within the chain.\n\tConfRequest\n\n\t// StartHeight specifies the block height at which to begin the\n\t// historical rescan.\n\tStartHeight uint32\n\n\t// EndHeight specifies the last block height (inclusive) that the\n\t// historical scan should consider.\n\tEndHeight uint32\n}\n\n// ConfRegistration encompasses all of the information required for callers to\n// retrieve details about a confirmation event.",
      "length": 465,
      "tokens": 70,
      "embedding": []
    },
    {
      "slug": "type ConfRegistration struct {",
      "content": "type ConfRegistration struct {\n\t// Event contains references to the channels that the notifications are\n\t// to be sent over.\n\tEvent *ConfirmationEvent\n\n\t// HistoricalDispatch, if non-nil, signals to the client who registered\n\t// the notification that they are responsible for attempting to manually\n\t// rescan blocks for the txid/output script between the start and end\n\t// heights.\n\tHistoricalDispatch *HistoricalConfDispatch\n\n\t// Height is the height of the TxNotifier at the time the confirmation\n\t// notification was registered. This can be used so that backends can\n\t// request to be notified of confirmations from this point forwards.\n\tHeight uint32\n}\n\n// SpendRequest encapsulates a request for a spend notification of either an\n// outpoint or output script.",
      "length": 717,
      "tokens": 111,
      "embedding": []
    },
    {
      "slug": "type SpendRequest struct {",
      "content": "type SpendRequest struct {\n\t// OutPoint is the outpoint for which a client has requested a spend\n\t// notification for. If set to a zero outpoint, then a spend\n\t// notification will be dispatched upon detecting the spend of the\n\t// _script_, rather than the outpoint.\n\tOutPoint wire.OutPoint\n\n\t// PkScript is the script of the outpoint. If a zero outpoint is set,\n\t// then this can be an arbitrary script.\n\tPkScript txscript.PkScript\n}\n\n// NewSpendRequest creates a request for a spend notification of either an\n// outpoint or output script. A nil outpoint or an allocated ZeroOutPoint can be\n// used to dispatch the confirmation notification on the script.",
      "length": 616,
      "tokens": 105,
      "embedding": []
    },
    {
      "slug": "func NewSpendRequest(op *wire.OutPoint, pkScript []byte) (SpendRequest, error) {",
      "content": "func NewSpendRequest(op *wire.OutPoint, pkScript []byte) (SpendRequest, error) {\n\tvar r SpendRequest\n\toutputScript, err := txscript.ParsePkScript(pkScript)\n\tif err != nil {\n\t\treturn r, err\n\t}\n\n\t// We'll only set an outpoint for which we'll dispatch a spend\n\t// notification on this request if one was provided. Otherwise, we'll\n\t// default to dispatching on the spend of the script instead.\n\tif op != nil {\n\t\tr.OutPoint = *op\n\t}\n\tr.PkScript = outputScript\n\n\t// For Taproot spends we have the main problem that for the key spend\n\t// path we cannot derive the pkScript from only looking at the input's\n\t// witness. So we need to rely on the outpoint information alone.\n\t//\n\t// TODO(guggero): For script path spends we can derive the pkScript from\n\t// the witness, since we have the full control block and the spent\n\t// script available.\n\tif outputScript.Class() == txscript.WitnessV1TaprootTy {\n\t\tif op == nil {\n\t\t\treturn r, fmt.Errorf(\"cannot register witness v1 \" +\n\t\t\t\t\"spend request without outpoint\")\n\t\t}\n\n\t\t// We have an outpoint, so we can set the pkScript to an all\n\t\t// zero Taproot key that we'll compare this spend request to.\n\t\tr.PkScript = ZeroTaprootPkScript\n\t}\n\n\treturn r, nil\n}\n\n// String returns the string representation of the SpendRequest.",
      "length": 1141,
      "tokens": 195,
      "embedding": []
    },
    {
      "slug": "func (r SpendRequest) String() string {",
      "content": "func (r SpendRequest) String() string {\n\tif r.OutPoint != ZeroOutPoint {\n\t\treturn fmt.Sprintf(\"outpoint=%v, script=%v\", r.OutPoint,\n\t\t\tr.PkScript)\n\t}\n\treturn fmt.Sprintf(\"outpoint=<zero>, script=%v\", r.PkScript)\n}\n\n// MatchesTx determines whether the given transaction satisfies the spend\n// request. If the spend request is for an outpoint, then we'll check all of\n// the outputs being spent by the inputs of the transaction to determine if it\n// matches. Otherwise, we'll need to match on the output script being spent, so\n// we'll recompute it for each input of the transaction to determine if it\n// matches.",
      "length": 559,
      "tokens": 86,
      "embedding": []
    },
    {
      "slug": "func (r SpendRequest) MatchesTx(tx *wire.MsgTx) (bool, uint32, error) {",
      "content": "func (r SpendRequest) MatchesTx(tx *wire.MsgTx) (bool, uint32, error) {\n\tif r.OutPoint != ZeroOutPoint {\n\t\tfor i, txIn := range tx.TxIn {\n\t\t\tif txIn.PreviousOutPoint == r.OutPoint {\n\t\t\t\treturn true, uint32(i), nil\n\t\t\t}\n\t\t}\n\n\t\treturn false, 0, nil\n\t}\n\n\tfor i, txIn := range tx.TxIn {\n\t\tpkScript, err := txscript.ComputePkScript(\n\t\t\ttxIn.SignatureScript, txIn.Witness,\n\t\t)\n\t\tif err == txscript.ErrUnsupportedScriptType {\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil {\n\t\t\treturn false, 0, err\n\t\t}\n\n\t\tif bytes.Equal(pkScript.Script(), r.PkScript.Script()) {\n\t\t\treturn true, uint32(i), nil\n\t\t}\n\t}\n\n\treturn false, 0, nil\n}\n\n// SpendNtfn represents a client's request to receive a notification once an\n// outpoint/output script has been spent on-chain. The client is asynchronously\n// notified via the SpendEvent channels.",
      "length": 699,
      "tokens": 103,
      "embedding": []
    },
    {
      "slug": "type SpendNtfn struct {",
      "content": "type SpendNtfn struct {\n\t// SpendID uniquely identies the spend notification request for the\n\t// specified outpoint/output script.\n\tSpendID uint64\n\n\t// SpendRequest represents either the outpoint or script we should\n\t// detect the spend of.\n\tSpendRequest\n\n\t// Event contains references to the channels that the notifications are\n\t// to be sent over.\n\tEvent *SpendEvent\n\n\t// HeightHint is the earliest height in the chain that we expect to find\n\t// the spending transaction of the specified outpoint/output script.\n\t// This value will be overridden by the spend hint cache if it contains\n\t// an entry for it.\n\tHeightHint uint32\n\n\t// dispatched signals whether a spend notification has been dispatched\n\t// to the client.\n\tdispatched bool\n}\n\n// HistoricalSpendDispatch parametrizes a manual rescan to determine the\n// spending details (if any) of an outpoint/output script. The parameters\n// include the start and end block heights specifying the range of blocks to\n// scan.",
      "length": 921,
      "tokens": 147,
      "embedding": []
    },
    {
      "slug": "type HistoricalSpendDispatch struct {",
      "content": "type HistoricalSpendDispatch struct {\n\t// SpendRequest represents either the outpoint or script we should\n\t// detect the spend of.\n\tSpendRequest\n\n\t// StartHeight specified the block height at which to begin the\n\t// historical rescan.\n\tStartHeight uint32\n\n\t// EndHeight specifies the last block height (inclusive) that the\n\t// historical rescan should consider.\n\tEndHeight uint32\n}\n\n// SpendRegistration encompasses all of the information required for callers to\n// retrieve details about a spend event.",
      "length": 450,
      "tokens": 68,
      "embedding": []
    },
    {
      "slug": "type SpendRegistration struct {",
      "content": "type SpendRegistration struct {\n\t// Event contains references to the channels that the notifications are\n\t// to be sent over.\n\tEvent *SpendEvent\n\n\t// HistoricalDispatch, if non-nil, signals to the client who registered\n\t// the notification that they are responsible for attempting to manually\n\t// rescan blocks for the txid/output script between the start and end\n\t// heights.\n\tHistoricalDispatch *HistoricalSpendDispatch\n\n\t// Height is the height of the TxNotifier at the time the spend\n\t// notification was registered. This can be used so that backends can\n\t// request to be notified of spends from this point forwards.\n\tHeight uint32\n}\n\n// TxNotifier is a struct responsible for delivering transaction notifications\n// to subscribers. These notifications can be of two different types:\n// transaction/output script confirmations and/or outpoint/output script spends.\n// The TxNotifier will watch the blockchain as new blocks come in, in order to\n// satisfy its client requests.",
      "length": 928,
      "tokens": 143,
      "embedding": []
    },
    {
      "slug": "type TxNotifier struct {",
      "content": "type TxNotifier struct {\n\tconfClientCounter  uint64 // To be used atomically.\n\tspendClientCounter uint64 // To be used atomically.\n\n\t// currentHeight is the height of the tracked blockchain. It is used to\n\t// determine the number of confirmations a tx has and ensure blocks are\n\t// connected and disconnected in order.\n\tcurrentHeight uint32\n\n\t// reorgSafetyLimit is the chain depth beyond which it is assumed a\n\t// block will not be reorganized out of the chain. This is used to\n\t// determine when to prune old notification requests so that reorgs are\n\t// handled correctly. The coinbase maturity period is a reasonable value\n\t// to use.\n\treorgSafetyLimit uint32\n\n\t// reorgDepth is the depth of a chain organization that this system is\n\t// being informed of. This is incremented as long as a sequence of\n\t// blocks are disconnected without being interrupted by a new block.\n\treorgDepth uint32\n\n\t// confNotifications is an index of confirmation notification requests\n\t// by transaction hash/output script.\n\tconfNotifications map[ConfRequest]*confNtfnSet\n\n\t// confsByInitialHeight is an index of watched transactions/output\n\t// scripts by the height that they are included at in the chain. This\n\t// is tracked so that incorrect notifications are not sent if a\n\t// transaction/output script is reorged out of the chain and so that\n\t// negative confirmations can be recognized.\n\tconfsByInitialHeight map[uint32]map[ConfRequest]struct{}\n\n\t// ntfnsByConfirmHeight is an index of notification requests by the\n\t// height at which the transaction/output script will have sufficient\n\t// confirmations.\n\tntfnsByConfirmHeight map[uint32]map[*ConfNtfn]struct{}\n\n\t// spendNotifications is an index of all active notification requests\n\t// per outpoint/output script.\n\tspendNotifications map[SpendRequest]*spendNtfnSet\n\n\t// spendsByHeight is an index that keeps tracks of the spending height\n\t// of outpoints/output scripts we are currently tracking notifications\n\t// for. This is used in order to recover from spending transactions\n\t// being reorged out of the chain.\n\tspendsByHeight map[uint32]map[SpendRequest]struct{}\n\n\t// confirmHintCache is a cache used to maintain the latest height hints\n\t// for transactions/output scripts. Each height hint represents the\n\t// earliest height at which they scripts could have been confirmed\n\t// within the chain.\n\tconfirmHintCache ConfirmHintCache\n\n\t// spendHintCache is a cache used to maintain the latest height hints\n\t// for outpoints/output scripts. Each height hint represents the\n\t// earliest height at which they could have been spent within the chain.\n\tspendHintCache SpendHintCache\n\n\t// quit is closed in order to signal that the notifier is gracefully\n\t// exiting.\n\tquit chan struct{}\n\n\tsync.Mutex\n}\n\n// NewTxNotifier creates a TxNotifier. The current height of the blockchain is\n// accepted as a parameter. The different hint caches (confirm and spend) are\n// used as an optimization in order to retrieve a better starting point when\n// dispatching a rescan for a historical event in the chain.",
      "length": 2939,
      "tokens": 437,
      "embedding": []
    },
    {
      "slug": "func NewTxNotifier(startHeight uint32, reorgSafetyLimit uint32,",
      "content": "func NewTxNotifier(startHeight uint32, reorgSafetyLimit uint32,\n\tconfirmHintCache ConfirmHintCache,\n\tspendHintCache SpendHintCache) *TxNotifier {\n\n\treturn &TxNotifier{\n\t\tcurrentHeight:        startHeight,\n\t\treorgSafetyLimit:     reorgSafetyLimit,\n\t\tconfNotifications:    make(map[ConfRequest]*confNtfnSet),\n\t\tconfsByInitialHeight: make(map[uint32]map[ConfRequest]struct{}),\n\t\tntfnsByConfirmHeight: make(map[uint32]map[*ConfNtfn]struct{}),\n\t\tspendNotifications:   make(map[SpendRequest]*spendNtfnSet),\n\t\tspendsByHeight:       make(map[uint32]map[SpendRequest]struct{}),\n\t\tconfirmHintCache:     confirmHintCache,\n\t\tspendHintCache:       spendHintCache,\n\t\tquit:                 make(chan struct{}),\n\t}\n}\n\n// newConfNtfn validates all of the parameters required to successfully create\n// and register a confirmation notification.",
      "length": 743,
      "tokens": 48,
      "embedding": []
    },
    {
      "slug": "func (n *TxNotifier) newConfNtfn(txid *chainhash.Hash,",
      "content": "func (n *TxNotifier) newConfNtfn(txid *chainhash.Hash,\n\tpkScript []byte, numConfs, heightHint uint32,\n\topts *notifierOptions) (*ConfNtfn, error) {\n\n\t// An accompanying output script must always be provided.\n\tif len(pkScript) == 0 {\n\t\treturn nil, ErrNoScript\n\t}\n\n\t// Enforce that we will not dispatch confirmations beyond the reorg\n\t// safety limit.\n\tif numConfs == 0 || numConfs > n.reorgSafetyLimit {\n\t\treturn nil, ErrNumConfsOutOfRange\n\t}\n\n\t// A height hint must be provided to prevent scanning from the genesis\n\t// block.\n\tif heightHint == 0 {\n\t\treturn nil, ErrNoHeightHint\n\t}\n\n\t// Ensure the output script is of a supported type.\n\tconfRequest, err := NewConfRequest(txid, pkScript)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tconfID := atomic.AddUint64(&n.confClientCounter, 1)\n\treturn &ConfNtfn{\n\t\tConfID:           confID,\n\t\tConfRequest:      confRequest,\n\t\tNumConfirmations: numConfs,\n\t\tEvent: NewConfirmationEvent(numConfs, func() {\n\t\t\tn.CancelConf(confRequest, confID)\n\t\t}),\n\t\tHeightHint:   heightHint,\n\t\tincludeBlock: opts.includeBlock,\n\t}, nil\n}\n\n// RegisterConf handles a new confirmation notification request. The client will\n// be notified when the transaction/output script gets a sufficient number of\n// confirmations in the blockchain.\n//\n// NOTE: If the transaction/output script has already been included in a block\n// on the chain, the confirmation details must be provided with the\n// UpdateConfDetails method, otherwise we will wait for the transaction/output\n// script to confirm even though it already has.",
      "length": 1425,
      "tokens": 202,
      "embedding": []
    },
    {
      "slug": "func (n *TxNotifier) RegisterConf(txid *chainhash.Hash, pkScript []byte,",
      "content": "func (n *TxNotifier) RegisterConf(txid *chainhash.Hash, pkScript []byte,\n\tnumConfs, heightHint uint32,\n\toptFuncs ...NotifierOption) (*ConfRegistration, error) {\n\n\tselect {\n\tcase <-n.quit:\n\t\treturn nil, ErrTxNotifierExiting\n\tdefault:\n\t}\n\n\topts := defaultNotifierOptions()\n\tfor _, optFunc := range optFuncs {\n\t\toptFunc(opts)\n\t}\n\n\t// We'll start by performing a series of validation checks.\n\tntfn, err := n.newConfNtfn(txid, pkScript, numConfs, heightHint, opts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Before proceeding to register the notification, we'll query our\n\t// height hint cache to determine whether a better one exists.\n\t//\n\t// TODO(conner): verify that all submitted height hints are identical.\n\tstartHeight := ntfn.HeightHint\n\thint, err := n.confirmHintCache.QueryConfirmHint(ntfn.ConfRequest)\n\tif err == nil {\n\t\tif hint > startHeight {\n\t\t\tLog.Debugf(\"Using height hint %d retrieved from cache \"+\n\t\t\t\t\"for %v instead of %d for conf subscription\",\n\t\t\t\thint, ntfn.ConfRequest, startHeight)\n\t\t\tstartHeight = hint\n\t\t}\n\t} else if err != ErrConfirmHintNotFound {\n\t\tLog.Errorf(\"Unable to query confirm hint for %v: %v\",\n\t\t\tntfn.ConfRequest, err)\n\t}\n\n\tLog.Infof(\"New confirmation subscription: conf_id=%d, %v, \"+\n\t\t\"num_confs=%v height_hint=%d\", ntfn.ConfID, ntfn.ConfRequest,\n\t\tnumConfs, startHeight)\n\n\tn.Lock()\n\tdefer n.Unlock()\n\n\tconfSet, ok := n.confNotifications[ntfn.ConfRequest]\n\tif !ok {\n\t\t// If this is the first registration for this request, construct\n\t\t// a confSet to coalesce all notifications for the same request.\n\t\tconfSet = newConfNtfnSet()\n\t\tn.confNotifications[ntfn.ConfRequest] = confSet\n\t}\n\tconfSet.ntfns[ntfn.ConfID] = ntfn\n\n\tswitch confSet.rescanStatus {\n\n\t// A prior rescan has already completed and we are actively watching at\n\t// tip for this request.\n\tcase rescanComplete:\n\t\t// If the confirmation details for this set of notifications has\n\t\t// already been found, we'll attempt to deliver them immediately\n\t\t// to this client.\n\t\tLog.Debugf(\"Attempting to dispatch confirmation for %v on \"+\n\t\t\t\"registration since rescan has finished\",\n\t\t\tntfn.ConfRequest)\n\n\t\t// The default notification we assigned above includes the\n\t\t// block along with the rest of the details. However not all\n\t\t// clients want the block, so we make a copy here w/o the block\n\t\t// if needed so we can give clients only what they ask for.\n\t\tif !ntfn.includeBlock && confSet.details != nil {\n\t\t\tconfSet.details.Block = nil\n\t\t}\n\n\t\terr := n.dispatchConfDetails(ntfn, confSet.details)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn &ConfRegistration{\n\t\t\tEvent:              ntfn.Event,\n\t\t\tHistoricalDispatch: nil,\n\t\t\tHeight:             n.currentHeight,\n\t\t}, nil\n\n\t// A rescan is already in progress, return here to prevent dispatching\n\t// another. When the rescan returns, this notification's details will be\n\t// updated as well.\n\tcase rescanPending:\n\t\tLog.Debugf(\"Waiting for pending rescan to finish before \"+\n\t\t\t\"notifying %v at tip\", ntfn.ConfRequest)\n\n\t\treturn &ConfRegistration{\n\t\t\tEvent:              ntfn.Event,\n\t\t\tHistoricalDispatch: nil,\n\t\t\tHeight:             n.currentHeight,\n\t\t}, nil\n\n\t// If no rescan has been dispatched, attempt to do so now.\n\tcase rescanNotStarted:\n\t}\n\n\t// If the provided or cached height hint indicates that the\n\t// transaction with the given txid/output script is to be confirmed at a\n\t// height greater than the notifier's current height, we'll refrain from\n\t// spawning a historical dispatch.\n\tif startHeight > n.currentHeight {\n\t\tLog.Debugf(\"Height hint is above current height, not \"+\n\t\t\t\"dispatching historical confirmation rescan for %v\",\n\t\t\tntfn.ConfRequest)\n\n\t\t// Set the rescan status to complete, which will allow the\n\t\t// notifier to start delivering messages for this set\n\t\t// immediately.\n\t\tconfSet.rescanStatus = rescanComplete\n\t\treturn &ConfRegistration{\n\t\t\tEvent:              ntfn.Event,\n\t\t\tHistoricalDispatch: nil,\n\t\t\tHeight:             n.currentHeight,\n\t\t}, nil\n\t}\n\n\tLog.Debugf(\"Dispatching historical confirmation rescan for %v\",\n\t\tntfn.ConfRequest)\n\n\t// Construct the parameters for historical dispatch, scanning the range\n\t// of blocks between our best known height hint and the notifier's\n\t// current height. The notifier will begin also watching for\n\t// confirmations at tip starting with the next block.\n\tdispatch := &HistoricalConfDispatch{\n\t\tConfRequest: ntfn.ConfRequest,\n\t\tStartHeight: startHeight,\n\t\tEndHeight:   n.currentHeight,\n\t}\n\n\t// Set this confSet's status to pending, ensuring subsequent\n\t// registrations don't also attempt a dispatch.\n\tconfSet.rescanStatus = rescanPending\n\n\treturn &ConfRegistration{\n\t\tEvent:              ntfn.Event,\n\t\tHistoricalDispatch: dispatch,\n\t\tHeight:             n.currentHeight,\n\t}, nil\n}\n\n// CancelConf cancels an existing request for a spend notification of an\n// outpoint/output script. The request is identified by its spend ID.",
      "length": 4621,
      "tokens": 618,
      "embedding": []
    },
    {
      "slug": "func (n *TxNotifier) CancelConf(confRequest ConfRequest, confID uint64) {",
      "content": "func (n *TxNotifier) CancelConf(confRequest ConfRequest, confID uint64) {\n\tselect {\n\tcase <-n.quit:\n\t\treturn\n\tdefault:\n\t}\n\n\tn.Lock()\n\tdefer n.Unlock()\n\n\tconfSet, ok := n.confNotifications[confRequest]\n\tif !ok {\n\t\treturn\n\t}\n\tntfn, ok := confSet.ntfns[confID]\n\tif !ok {\n\t\treturn\n\t}\n\n\tLog.Infof(\"Canceling confirmation notification: conf_id=%d, %v\", confID,\n\t\tconfRequest)\n\n\t// We'll close all the notification channels to let the client know\n\t// their cancel request has been fulfilled.\n\tclose(ntfn.Event.Confirmed)\n\tclose(ntfn.Event.Updates)\n\tclose(ntfn.Event.NegativeConf)\n\n\t// Finally, we'll clean up any lingering references to this\n\t// notification.\n\tdelete(confSet.ntfns, confID)\n\n\t// Remove the queued confirmation notification if the transaction has\n\t// already confirmed, but hasn't met its required number of\n\t// confirmations.\n\tif confSet.details != nil {\n\t\tconfHeight := confSet.details.BlockHeight +\n\t\t\tntfn.NumConfirmations - 1\n\t\tdelete(n.ntfnsByConfirmHeight[confHeight], ntfn)\n\t}\n}\n\n// UpdateConfDetails attempts to update the confirmation details for an active\n// notification within the notifier. This should only be used in the case of a\n// transaction/output script that has confirmed before the notifier's current\n// height.\n//\n// NOTE: The notification should be registered first to ensure notifications are\n// dispatched correctly.",
      "length": 1231,
      "tokens": 163,
      "embedding": []
    },
    {
      "slug": "func (n *TxNotifier) UpdateConfDetails(confRequest ConfRequest,",
      "content": "func (n *TxNotifier) UpdateConfDetails(confRequest ConfRequest,\n\tdetails *TxConfirmation) error {\n\n\tselect {\n\tcase <-n.quit:\n\t\treturn ErrTxNotifierExiting\n\tdefault:\n\t}\n\n\t// Ensure we hold the lock throughout handling the notification to\n\t// prevent the notifier from advancing its height underneath us.\n\tn.Lock()\n\tdefer n.Unlock()\n\n\t// First, we'll determine whether we have an active confirmation\n\t// notification for the given txid/script.\n\tconfSet, ok := n.confNotifications[confRequest]\n\tif !ok {\n\t\treturn fmt.Errorf(\"confirmation notification for %v not found\",\n\t\t\tconfRequest)\n\t}\n\n\t// If the confirmation details were already found at tip, all existing\n\t// notifications will have been dispatched or queued for dispatch. We\n\t// can exit early to avoid sending too many notifications on the\n\t// buffered channels.\n\tif confSet.details != nil {\n\t\treturn nil\n\t}\n\n\t// The historical dispatch has been completed for this confSet. We'll\n\t// update the rescan status and cache any details that were found. If\n\t// the details are nil, that implies we did not find them and will\n\t// continue to watch for them at tip.\n\tconfSet.rescanStatus = rescanComplete\n\n\t// The notifier has yet to reach the height at which the\n\t// transaction/output script was included in a block, so we should defer\n\t// until handling it then within ConnectTip.\n\tif details == nil {\n\t\tLog.Debugf(\"Confirmation details for %v not found during \"+\n\t\t\t\"historical dispatch, waiting to dispatch at tip\",\n\t\t\tconfRequest)\n\n\t\t// We'll commit the current height as the confirm hint to\n\t\t// prevent another potentially long rescan if we restart before\n\t\t// a new block comes in.\n\t\terr := n.confirmHintCache.CommitConfirmHint(\n\t\t\tn.currentHeight, confRequest,\n\t\t)\n\t\tif err != nil {\n\t\t\t// The error is not fatal as this is an optimistic\n\t\t\t// optimization, so we'll avoid returning an error.\n\t\t\tLog.Debugf(\"Unable to update confirm hint to %d for \"+\n\t\t\t\t\"%v: %v\", n.currentHeight, confRequest, err)\n\t\t}\n\n\t\treturn nil\n\t}\n\n\tif details.BlockHeight > n.currentHeight {\n\t\tLog.Debugf(\"Confirmation details for %v found above current \"+\n\t\t\t\"height, waiting to dispatch at tip\", confRequest)\n\n\t\treturn nil\n\t}\n\n\tLog.Debugf(\"Updating confirmation details for %v\", confRequest)\n\n\terr := n.confirmHintCache.CommitConfirmHint(\n\t\tdetails.BlockHeight, confRequest,\n\t)\n\tif err != nil {\n\t\t// The error is not fatal, so we should not return an error to\n\t\t// the caller.\n\t\tLog.Errorf(\"Unable to update confirm hint to %d for %v: %v\",\n\t\t\tdetails.BlockHeight, confRequest, err)\n\t}\n\n\t// Cache the details found in the rescan and attempt to dispatch any\n\t// notifications that have not yet been delivered.\n\tconfSet.details = details\n\tfor _, ntfn := range confSet.ntfns {\n\t\t// The default notification we assigned above includes the\n\t\t// block along with the rest of the details. However not all\n\t\t// clients want the block, so we make a copy here w/o the block\n\t\t// if needed so we can give clients only what they ask for.\n\t\tconfDetails := *details\n\t\tif !ntfn.includeBlock {\n\t\t\tconfDetails.Block = nil\n\t\t}\n\n\t\terr = n.dispatchConfDetails(ntfn, &confDetails)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// dispatchConfDetails attempts to cache and dispatch details to a particular\n// client if the transaction/output script has sufficiently confirmed. If the\n// provided details are nil, this method will be a no-op.",
      "length": 3194,
      "tokens": 499,
      "embedding": []
    },
    {
      "slug": "func (n *TxNotifier) dispatchConfDetails(",
      "content": "func (n *TxNotifier) dispatchConfDetails(\n\tntfn *ConfNtfn, details *TxConfirmation) error {\n\n\t// If there are no conf details to dispatch or if the notification has\n\t// already been dispatched, then we can skip dispatching to this\n\t// client.\n\tif details == nil || ntfn.dispatched {\n\t\tLog.Debugf(\"Skipping dispatch of conf details(%v) for \"+\n\t\t\t\"request %v, dispatched=%v\", details, ntfn.ConfRequest,\n\t\t\tntfn.dispatched)\n\n\t\treturn nil\n\t}\n\n\t// Now, we'll examine whether the transaction/output script of this\n\t// request has reached its required number of confirmations. If it has,\n\t// we'll dispatch a confirmation notification to the caller.\n\tconfHeight := details.BlockHeight + ntfn.NumConfirmations - 1\n\tif confHeight <= n.currentHeight {\n\t\tLog.Infof(\"Dispatching %v confirmation notification for %v\",\n\t\t\tntfn.NumConfirmations, ntfn.ConfRequest)\n\n\t\t// We'll send a 0 value to the Updates channel,\n\t\t// indicating that the transaction/output script has already\n\t\t// been confirmed.\n\t\tselect {\n\t\tcase ntfn.Event.Updates <- 0:\n\t\tcase <-n.quit:\n\t\t\treturn ErrTxNotifierExiting\n\t\t}\n\n\t\tselect {\n\t\tcase ntfn.Event.Confirmed <- details:\n\t\t\tntfn.dispatched = true\n\t\tcase <-n.quit:\n\t\t\treturn ErrTxNotifierExiting\n\t\t}\n\t} else {\n\t\tLog.Debugf(\"Queueing %v confirmation notification for %v at tip \",\n\t\t\tntfn.NumConfirmations, ntfn.ConfRequest)\n\n\t\t// Otherwise, we'll keep track of the notification\n\t\t// request by the height at which we should dispatch the\n\t\t// confirmation notification.\n\t\tntfnSet, exists := n.ntfnsByConfirmHeight[confHeight]\n\t\tif !exists {\n\t\t\tntfnSet = make(map[*ConfNtfn]struct{})\n\t\t\tn.ntfnsByConfirmHeight[confHeight] = ntfnSet\n\t\t}\n\t\tntfnSet[ntfn] = struct{}{}\n\n\t\t// We'll also send an update to the client of how many\n\t\t// confirmations are left for the transaction/output script to\n\t\t// be confirmed.\n\t\tnumConfsLeft := confHeight - n.currentHeight\n\t\tselect {\n\t\tcase ntfn.Event.Updates <- numConfsLeft:\n\t\tcase <-n.quit:\n\t\t\treturn ErrTxNotifierExiting\n\t\t}\n\t}\n\n\t// As a final check, we'll also watch the transaction/output script if\n\t// it's still possible for it to get reorged out of the chain.\n\treorgSafeHeight := details.BlockHeight + n.reorgSafetyLimit\n\tif reorgSafeHeight > n.currentHeight {\n\t\ttxSet, exists := n.confsByInitialHeight[details.BlockHeight]\n\t\tif !exists {\n\t\t\ttxSet = make(map[ConfRequest]struct{})\n\t\t\tn.confsByInitialHeight[details.BlockHeight] = txSet\n\t\t}\n\t\ttxSet[ntfn.ConfRequest] = struct{}{}\n\t}\n\n\treturn nil\n}\n\n// newSpendNtfn validates all of the parameters required to successfully create\n// and register a spend notification.",
      "length": 2442,
      "tokens": 320,
      "embedding": []
    },
    {
      "slug": "func (n *TxNotifier) newSpendNtfn(outpoint *wire.OutPoint,",
      "content": "func (n *TxNotifier) newSpendNtfn(outpoint *wire.OutPoint,\n\tpkScript []byte, heightHint uint32) (*SpendNtfn, error) {\n\n\t// An accompanying output script must always be provided.\n\tif len(pkScript) == 0 {\n\t\treturn nil, ErrNoScript\n\t}\n\n\t// A height hint must be provided to prevent scanning from the genesis\n\t// block.\n\tif heightHint == 0 {\n\t\treturn nil, ErrNoHeightHint\n\t}\n\n\t// Ensure the output script is of a supported type.\n\tspendRequest, err := NewSpendRequest(outpoint, pkScript)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tspendID := atomic.AddUint64(&n.spendClientCounter, 1)\n\treturn &SpendNtfn{\n\t\tSpendID:      spendID,\n\t\tSpendRequest: spendRequest,\n\t\tEvent: NewSpendEvent(func() {\n\t\t\tn.CancelSpend(spendRequest, spendID)\n\t\t}),\n\t\tHeightHint: heightHint,\n\t}, nil\n}\n\n// RegisterSpend handles a new spend notification request. The client will be\n// notified once the outpoint/output script is detected as spent within the\n// chain.\n//\n// NOTE: If the outpoint/output script has already been spent within the chain\n// before the notifier's current tip, the spend details must be provided with\n// the UpdateSpendDetails method, otherwise we will wait for the outpoint/output\n// script to be spent at tip, even though it already has.",
      "length": 1133,
      "tokens": 170,
      "embedding": []
    },
    {
      "slug": "func (n *TxNotifier) RegisterSpend(outpoint *wire.OutPoint, pkScript []byte,",
      "content": "func (n *TxNotifier) RegisterSpend(outpoint *wire.OutPoint, pkScript []byte,\n\theightHint uint32) (*SpendRegistration, error) {\n\n\tselect {\n\tcase <-n.quit:\n\t\treturn nil, ErrTxNotifierExiting\n\tdefault:\n\t}\n\n\t// We'll start by performing a series of validation checks.\n\tntfn, err := n.newSpendNtfn(outpoint, pkScript, heightHint)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Before proceeding to register the notification, we'll query our spend\n\t// hint cache to determine whether a better one exists.\n\tstartHeight := ntfn.HeightHint\n\thint, err := n.spendHintCache.QuerySpendHint(ntfn.SpendRequest)\n\tif err == nil {\n\t\tif hint > startHeight {\n\t\t\tLog.Debugf(\"Using height hint %d retrieved from cache \"+\n\t\t\t\t\"for %v instead of %d for spend subscription\",\n\t\t\t\thint, ntfn.SpendRequest, startHeight)\n\t\t\tstartHeight = hint\n\t\t}\n\t} else if err != ErrSpendHintNotFound {\n\t\tLog.Errorf(\"Unable to query spend hint for %v: %v\",\n\t\t\tntfn.SpendRequest, err)\n\t}\n\n\tn.Lock()\n\tdefer n.Unlock()\n\n\tLog.Infof(\"New spend subscription: spend_id=%d, %v, height_hint=%d\",\n\t\tntfn.SpendID, ntfn.SpendRequest, startHeight)\n\n\t// Keep track of the notification request so that we can properly\n\t// dispatch a spend notification later on.\n\tspendSet, ok := n.spendNotifications[ntfn.SpendRequest]\n\tif !ok {\n\t\t// If this is the first registration for the request, we'll\n\t\t// construct a spendNtfnSet to coalesce all notifications.\n\t\tspendSet = newSpendNtfnSet()\n\t\tn.spendNotifications[ntfn.SpendRequest] = spendSet\n\t}\n\tspendSet.ntfns[ntfn.SpendID] = ntfn\n\n\t// We'll now let the caller know whether a historical rescan is needed\n\t// depending on the current rescan status.\n\tswitch spendSet.rescanStatus {\n\n\t// If the spending details for this request have already been determined\n\t// and cached, then we can use them to immediately dispatch the spend\n\t// notification to the client.\n\tcase rescanComplete:\n\t\tLog.Debugf(\"Attempting to dispatch spend for %v on \"+\n\t\t\t\"registration since rescan has finished\",\n\t\t\tntfn.SpendRequest)\n\n\t\terr := n.dispatchSpendDetails(ntfn, spendSet.details)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn &SpendRegistration{\n\t\t\tEvent:              ntfn.Event,\n\t\t\tHistoricalDispatch: nil,\n\t\t\tHeight:             n.currentHeight,\n\t\t}, nil\n\n\t// If there is an active rescan to determine whether the request has\n\t// been spent, then we won't trigger another one.\n\tcase rescanPending:\n\t\tLog.Debugf(\"Waiting for pending rescan to finish before \"+\n\t\t\t\"notifying %v at tip\", ntfn.SpendRequest)\n\n\t\treturn &SpendRegistration{\n\t\t\tEvent:              ntfn.Event,\n\t\t\tHistoricalDispatch: nil,\n\t\t\tHeight:             n.currentHeight,\n\t\t}, nil\n\n\t// Otherwise, we'll fall through and let the caller know that a rescan\n\t// should be dispatched to determine whether the request has already\n\t// been spent.\n\tcase rescanNotStarted:\n\t}\n\n\t// However, if the spend hint, either provided by the caller or\n\t// retrieved from the cache, is found to be at a later height than the\n\t// TxNotifier is aware of, then we'll refrain from dispatching a\n\t// historical rescan and wait for the spend to come in at tip.\n\tif startHeight > n.currentHeight {\n\t\tLog.Debugf(\"Spend hint of %d for %v is above current height %d\",\n\t\t\tstartHeight, ntfn.SpendRequest, n.currentHeight)\n\n\t\t// We'll also set the rescan status as complete to ensure that\n\t\t// spend hints for this request get updated upon\n\t\t// connected/disconnected blocks.\n\t\tspendSet.rescanStatus = rescanComplete\n\t\treturn &SpendRegistration{\n\t\t\tEvent:              ntfn.Event,\n\t\t\tHistoricalDispatch: nil,\n\t\t\tHeight:             n.currentHeight,\n\t\t}, nil\n\t}\n\n\t// We'll set the rescan status to pending to ensure subsequent\n\t// notifications don't also attempt a historical dispatch.\n\tspendSet.rescanStatus = rescanPending\n\n\tLog.Infof(\"Dispatching historical spend rescan for %v, start=%d, \"+\n\t\t\"end=%d\", ntfn.SpendRequest, startHeight, n.currentHeight)\n\n\treturn &SpendRegistration{\n\t\tEvent: ntfn.Event,\n\t\tHistoricalDispatch: &HistoricalSpendDispatch{\n\t\t\tSpendRequest: ntfn.SpendRequest,\n\t\t\tStartHeight:  startHeight,\n\t\t\tEndHeight:    n.currentHeight,\n\t\t},\n\t\tHeight: n.currentHeight,\n\t}, nil\n}\n\n// CancelSpend cancels an existing request for a spend notification of an\n// outpoint/output script. The request is identified by its spend ID.",
      "length": 4039,
      "tokens": 537,
      "embedding": []
    },
    {
      "slug": "func (n *TxNotifier) CancelSpend(spendRequest SpendRequest, spendID uint64) {",
      "content": "func (n *TxNotifier) CancelSpend(spendRequest SpendRequest, spendID uint64) {\n\tselect {\n\tcase <-n.quit:\n\t\treturn\n\tdefault:\n\t}\n\n\tn.Lock()\n\tdefer n.Unlock()\n\n\tspendSet, ok := n.spendNotifications[spendRequest]\n\tif !ok {\n\t\treturn\n\t}\n\tntfn, ok := spendSet.ntfns[spendID]\n\tif !ok {\n\t\treturn\n\t}\n\n\tLog.Infof(\"Canceling spend notification: spend_id=%d, %v\", spendID,\n\t\tspendRequest)\n\n\t// We'll close all the notification channels to let the client know\n\t// their cancel request has been fulfilled.\n\tclose(ntfn.Event.Spend)\n\tclose(ntfn.Event.Reorg)\n\tclose(ntfn.Event.Done)\n\tdelete(spendSet.ntfns, spendID)\n}\n\n// ProcessRelevantSpendTx processes a transaction provided externally. This will\n// check whether the transaction is relevant to the notifier if it spends any\n// outpoints/output scripts for which we currently have registered notifications\n// for. If it is relevant, spend notifications will be dispatched to the caller.",
      "length": 810,
      "tokens": 107,
      "embedding": []
    },
    {
      "slug": "func (n *TxNotifier) ProcessRelevantSpendTx(tx *btcutil.Tx,",
      "content": "func (n *TxNotifier) ProcessRelevantSpendTx(tx *btcutil.Tx,\n\tblockHeight uint32) error {\n\n\tselect {\n\tcase <-n.quit:\n\t\treturn ErrTxNotifierExiting\n\tdefault:\n\t}\n\n\t// Ensure we hold the lock throughout handling the notification to\n\t// prevent the notifier from advancing its height underneath us.\n\tn.Lock()\n\tdefer n.Unlock()\n\n\t// We'll use a channel to coalesce all the spend requests that this\n\t// transaction fulfills.\n\ttype spend struct {\n\t\trequest *SpendRequest\n\t\tdetails *SpendDetail\n\t}\n\n\t// We'll set up the onSpend filter callback to gather all the fulfilled\n\t// spends requests within this transaction.\n\tvar spends []spend\n\tonSpend := func(request SpendRequest, details *SpendDetail) {\n\t\tspends = append(spends, spend{&request, details})\n\t}\n\tn.filterTx(nil, tx, blockHeight, nil, onSpend)\n\n\t// After the transaction has been filtered, we can finally dispatch\n\t// notifications for each request.\n\tfor _, spend := range spends {\n\t\terr := n.updateSpendDetails(*spend.request, spend.details)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// UpdateSpendDetails attempts to update the spend details for all active spend\n// notification requests for an outpoint/output script. This method should be\n// used once a historical scan of the chain has finished. If the historical scan\n// did not find a spending transaction for it, the spend details may be nil.\n//\n// NOTE: A notification request for the outpoint/output script must be\n// registered first to ensure notifications are delivered.",
      "length": 1390,
      "tokens": 213,
      "embedding": []
    },
    {
      "slug": "func (n *TxNotifier) UpdateSpendDetails(spendRequest SpendRequest,",
      "content": "func (n *TxNotifier) UpdateSpendDetails(spendRequest SpendRequest,\n\tdetails *SpendDetail) error {\n\n\tselect {\n\tcase <-n.quit:\n\t\treturn ErrTxNotifierExiting\n\tdefault:\n\t}\n\n\t// Ensure we hold the lock throughout handling the notification to\n\t// prevent the notifier from advancing its height underneath us.\n\tn.Lock()\n\tdefer n.Unlock()\n\n\treturn n.updateSpendDetails(spendRequest, details)\n}\n\n// updateSpendDetails attempts to update the spend details for all active spend\n// notification requests for an outpoint/output script. This method should be\n// used once a historical scan of the chain has finished. If the historical scan\n// did not find a spending transaction for it, the spend details may be nil.\n//\n// NOTE: This method must be called with the TxNotifier's lock held.",
      "length": 686,
      "tokens": 106,
      "embedding": []
    },
    {
      "slug": "func (n *TxNotifier) updateSpendDetails(spendRequest SpendRequest,",
      "content": "func (n *TxNotifier) updateSpendDetails(spendRequest SpendRequest,\n\tdetails *SpendDetail) error {\n\n\t// Mark the ongoing historical rescan for this request as finished. This\n\t// will allow us to update the spend hints for it at tip.\n\tspendSet, ok := n.spendNotifications[spendRequest]\n\tif !ok {\n\t\treturn fmt.Errorf(\"spend notification for %v not found\",\n\t\t\tspendRequest)\n\t}\n\n\t// If the spend details have already been found either at tip, then the\n\t// notifications should have already been dispatched, so we can exit\n\t// early to prevent sending duplicate notifications.\n\tif spendSet.details != nil {\n\t\treturn nil\n\t}\n\n\t// Since the historical rescan has completed for this request, we'll\n\t// mark its rescan status as complete in order to ensure that the\n\t// TxNotifier can properly update its spend hints upon\n\t// connected/disconnected blocks.\n\tspendSet.rescanStatus = rescanComplete\n\n\t// If the historical rescan was not able to find a spending transaction\n\t// for this request, then we can track the spend at tip.\n\tif details == nil {\n\t\t// We'll commit the current height as the spend hint to prevent\n\t\t// another potentially long rescan if we restart before a new\n\t\t// block comes in.\n\t\terr := n.spendHintCache.CommitSpendHint(\n\t\t\tn.currentHeight, spendRequest,\n\t\t)\n\t\tif err != nil {\n\t\t\t// The error is not fatal as this is an optimistic\n\t\t\t// optimization, so we'll avoid returning an error.\n\t\t\tLog.Debugf(\"Unable to update spend hint to %d for %v: %v\",\n\t\t\t\tn.currentHeight, spendRequest, err)\n\t\t}\n\n\t\tLog.Debugf(\"Updated spend hint to height=%v for unconfirmed \"+\n\t\t\t\"spend request %v\", n.currentHeight, spendRequest)\n\t\treturn nil\n\t}\n\n\t// If the historical rescan found the spending transaction for this\n\t// request, but it's at a later height than the notifier (this can\n\t// happen due to latency with the backend during a reorg), then we'll\n\t// defer handling the notification until the notifier has caught up to\n\t// such height.\n\tif uint32(details.SpendingHeight) > n.currentHeight {\n\t\treturn nil\n\t}\n\n\t// Now that we've determined the request has been spent, we'll commit\n\t// its spending height as its hint in the cache and dispatch\n\t// notifications to all of its respective clients.\n\terr := n.spendHintCache.CommitSpendHint(\n\t\tuint32(details.SpendingHeight), spendRequest,\n\t)\n\tif err != nil {\n\t\t// The error is not fatal as this is an optimistic optimization,\n\t\t// so we'll avoid returning an error.\n\t\tLog.Debugf(\"Unable to update spend hint to %d for %v: %v\",\n\t\t\tdetails.SpendingHeight, spendRequest, err)\n\t}\n\n\tLog.Debugf(\"Updated spend hint to height=%v for confirmed spend \"+\n\t\t\"request %v\", details.SpendingHeight, spendRequest)\n\n\tspendSet.details = details\n\tfor _, ntfn := range spendSet.ntfns {\n\t\terr := n.dispatchSpendDetails(ntfn, spendSet.details)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// dispatchSpendDetails dispatches a spend notification to the client.\n//\n// NOTE: This must be called with the TxNotifier's lock held.",
      "length": 2810,
      "tokens": 437,
      "embedding": []
    },
    {
      "slug": "func (n *TxNotifier) dispatchSpendDetails(ntfn *SpendNtfn, details *SpendDetail) error {",
      "content": "func (n *TxNotifier) dispatchSpendDetails(ntfn *SpendNtfn, details *SpendDetail) error {\n\t// If there are no spend details to dispatch or if the notification has\n\t// already been dispatched, then we can skip dispatching to this client.\n\tif details == nil || ntfn.dispatched {\n\t\tLog.Debugf(\"Skipping dispatch of spend details(%v) for \"+\n\t\t\t\"request %v, dispatched=%v\", details, ntfn.SpendRequest,\n\t\t\tntfn.dispatched)\n\t\treturn nil\n\t}\n\n\tLog.Infof(\"Dispatching confirmed spend notification for %v at \"+\n\t\t\"current height=%d: %v\", ntfn.SpendRequest, n.currentHeight,\n\t\tdetails)\n\n\tselect {\n\tcase ntfn.Event.Spend <- details:\n\t\tntfn.dispatched = true\n\tcase <-n.quit:\n\t\treturn ErrTxNotifierExiting\n\t}\n\n\tspendHeight := uint32(details.SpendingHeight)\n\n\t// We also add to spendsByHeight to notify on chain reorgs.\n\treorgSafeHeight := spendHeight + n.reorgSafetyLimit\n\tif reorgSafeHeight > n.currentHeight {\n\t\ttxSet, exists := n.spendsByHeight[spendHeight]\n\t\tif !exists {\n\t\t\ttxSet = make(map[SpendRequest]struct{})\n\t\t\tn.spendsByHeight[spendHeight] = txSet\n\t\t}\n\t\ttxSet[ntfn.SpendRequest] = struct{}{}\n\t}\n\n\treturn nil\n}\n\n// ConnectTip handles a new block extending the current chain. It will go\n// through every transaction and determine if it is relevant to any of its\n// clients. A transaction can be relevant in either of the following two ways:\n//\n//  1. One of the inputs in the transaction spends an outpoint/output script\n//     for which we currently have an active spend registration for.\n//\n//  2. The transaction has a txid or output script for which we currently have\n//     an active confirmation registration for.\n//\n// In the event that the transaction is relevant, a confirmation/spend\n// notification will be queued for dispatch to the relevant clients.\n// Confirmation notifications will only be dispatched for transactions/output\n// scripts that have met the required number of confirmations required by the\n// client.\n//\n// NOTE: In order to actually dispatch the relevant transaction notifications to\n// clients, NotifyHeight must be called with the same block height in order to\n// maintain correctness.",
      "length": 1968,
      "tokens": 287,
      "embedding": []
    },
    {
      "slug": "func (n *TxNotifier) ConnectTip(block *btcutil.Block,",
      "content": "func (n *TxNotifier) ConnectTip(block *btcutil.Block,\n\tblockHeight uint32) error {\n\n\tselect {\n\tcase <-n.quit:\n\t\treturn ErrTxNotifierExiting\n\tdefault:\n\t}\n\n\tn.Lock()\n\tdefer n.Unlock()\n\n\tif blockHeight != n.currentHeight+1 {\n\t\treturn fmt.Errorf(\"received blocks out of order: \"+\n\t\t\t\"current height=%d, new height=%d\",\n\t\t\tn.currentHeight, blockHeight)\n\t}\n\tn.currentHeight++\n\tn.reorgDepth = 0\n\n\t// First, we'll iterate over all the transactions found in this block to\n\t// determine if it includes any relevant transactions to the TxNotifier.\n\tif block != nil {\n\t\tLog.Debugf(\"Filtering %d txns for %d spend requests at \"+\n\t\t\t\"height %d\", len(block.Transactions()),\n\t\t\tlen(n.spendNotifications), blockHeight)\n\n\t\tfor _, tx := range block.Transactions() {\n\t\t\tn.filterTx(\n\t\t\t\tblock, tx, blockHeight,\n\t\t\t\tn.handleConfDetailsAtTip,\n\t\t\t\tn.handleSpendDetailsAtTip,\n\t\t\t)\n\t\t}\n\t}\n\n\t// Now that we've determined which requests were confirmed and spent\n\t// within the new block, we can update their entries in their respective\n\t// caches, along with all of our unconfirmed and unspent requests.\n\tn.updateHints(blockHeight)\n\n\t// Finally, we'll clear the entries from our set of notifications for\n\t// requests that are no longer under the risk of being reorged out of\n\t// the chain.\n\tif blockHeight >= n.reorgSafetyLimit {\n\t\tmatureBlockHeight := blockHeight - n.reorgSafetyLimit\n\t\tfor confRequest := range n.confsByInitialHeight[matureBlockHeight] {\n\t\t\tconfSet := n.confNotifications[confRequest]\n\t\t\tfor _, ntfn := range confSet.ntfns {\n\t\t\t\tselect {\n\t\t\t\tcase ntfn.Event.Done <- struct{}{}:\n\t\t\t\tcase <-n.quit:\n\t\t\t\t\treturn ErrTxNotifierExiting\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdelete(n.confNotifications, confRequest)\n\t\t}\n\t\tdelete(n.confsByInitialHeight, matureBlockHeight)\n\n\t\tfor spendRequest := range n.spendsByHeight[matureBlockHeight] {\n\t\t\tspendSet := n.spendNotifications[spendRequest]\n\t\t\tfor _, ntfn := range spendSet.ntfns {\n\t\t\t\tselect {\n\t\t\t\tcase ntfn.Event.Done <- struct{}{}:\n\t\t\t\tcase <-n.quit:\n\t\t\t\t\treturn ErrTxNotifierExiting\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLog.Debugf(\"Deleting mature spend request %v at \"+\n\t\t\t\t\"height=%d\", spendRequest, blockHeight)\n\t\t\tdelete(n.spendNotifications, spendRequest)\n\t\t}\n\t\tdelete(n.spendsByHeight, matureBlockHeight)\n\t}\n\n\treturn nil\n}\n\n// filterTx determines whether the transaction spends or confirms any\n// outstanding pending requests. The onConf and onSpend callbacks can be used to\n// retrieve all the requests fulfilled by this transaction as they occur.",
      "length": 2310,
      "tokens": 287,
      "embedding": []
    },
    {
      "slug": "func (n *TxNotifier) filterTx(block *btcutil.Block, tx *btcutil.Tx,",
      "content": "func (n *TxNotifier) filterTx(block *btcutil.Block, tx *btcutil.Tx,\n\tblockHeight uint32, onConf func(ConfRequest, *TxConfirmation),\n\tonSpend func(SpendRequest, *SpendDetail)) {\n\n\t// In order to determine if this transaction is relevant to the\n\t// notifier, we'll check its inputs for any outstanding spend\n\t// requests.\n\ttxHash := tx.Hash()\n\tif onSpend != nil {\n\t\t// notifyDetails is a helper closure that will construct the\n\t\t// spend details of a request and hand them off to the onSpend\n\t\t// callback.\n\t\tnotifyDetails := func(spendRequest SpendRequest,\n\t\t\tprevOut wire.OutPoint, inputIdx uint32) {\n\n\t\t\tLog.Debugf(\"Found spend of %v: spend_tx=%v, \"+\n\t\t\t\t\"block_height=%d\", spendRequest, txHash,\n\t\t\t\tblockHeight)\n\n\t\t\tonSpend(spendRequest, &SpendDetail{\n\t\t\t\tSpentOutPoint:     &prevOut,\n\t\t\t\tSpenderTxHash:     txHash,\n\t\t\t\tSpendingTx:        tx.MsgTx(),\n\t\t\t\tSpenderInputIndex: inputIdx,\n\t\t\t\tSpendingHeight:    int32(blockHeight),\n\t\t\t})\n\t\t}\n\n\t\tfor i, txIn := range tx.MsgTx().TxIn {\n\t\t\t// We'll re-derive the script of the output being spent\n\t\t\t// to determine if the inputs spends any registered\n\t\t\t// requests.\n\t\t\tprevOut := txIn.PreviousOutPoint\n\t\t\tpkScript, err := txscript.ComputePkScript(\n\t\t\t\ttxIn.SignatureScript, txIn.Witness,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tspendRequest := SpendRequest{\n\t\t\t\tOutPoint: prevOut,\n\t\t\t\tPkScript: pkScript,\n\t\t\t}\n\n\t\t\t// If we have any, we'll record their spend height so\n\t\t\t// that notifications get dispatched to the respective\n\t\t\t// clients.\n\t\t\tif _, ok := n.spendNotifications[spendRequest]; ok {\n\t\t\t\tnotifyDetails(spendRequest, prevOut, uint32(i))\n\t\t\t}\n\n\t\t\t// Now try with an empty taproot key pkScript, since we\n\t\t\t// cannot derive the spent pkScript directly from the\n\t\t\t// witness. But we have the outpoint, which should be\n\t\t\t// enough.\n\t\t\tspendRequest.PkScript = ZeroTaprootPkScript\n\t\t\tif _, ok := n.spendNotifications[spendRequest]; ok {\n\t\t\t\tnotifyDetails(spendRequest, prevOut, uint32(i))\n\t\t\t}\n\n\t\t\t// Restore the pkScript but try with a zero outpoint\n\t\t\t// instead (won't be possible for Taproot).\n\t\t\tspendRequest.PkScript = pkScript\n\t\t\tspendRequest.OutPoint = ZeroOutPoint\n\t\t\tif _, ok := n.spendNotifications[spendRequest]; ok {\n\t\t\t\tnotifyDetails(spendRequest, prevOut, uint32(i))\n\t\t\t}\n\t\t}\n\t}\n\n\t// We'll also check its outputs to determine if there are any\n\t// outstanding confirmation requests.\n\tif onConf != nil {\n\t\t// notifyDetails is a helper closure that will construct the\n\t\t// confirmation details of a request and hand them off to the\n\t\t// onConf callback.\n\t\tnotifyDetails := func(confRequest ConfRequest) {\n\t\t\tLog.Debugf(\"Found initial confirmation of %v: \"+\n\t\t\t\t\"height=%d, hash=%v\", confRequest,\n\t\t\t\tblockHeight, block.Hash())\n\n\t\t\tdetails := &TxConfirmation{\n\t\t\t\tTx:          tx.MsgTx(),\n\t\t\t\tBlockHash:   block.Hash(),\n\t\t\t\tBlockHeight: blockHeight,\n\t\t\t\tTxIndex:     uint32(tx.Index()),\n\t\t\t\tBlock:       block.MsgBlock(),\n\t\t\t}\n\n\t\t\tonConf(confRequest, details)\n\t\t}\n\n\t\tfor _, txOut := range tx.MsgTx().TxOut {\n\t\t\t// We'll parse the script of the output to determine if\n\t\t\t// we have any registered requests for it or the\n\t\t\t// transaction itself.\n\t\t\tpkScript, err := txscript.ParsePkScript(txOut.PkScript)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tconfRequest := ConfRequest{\n\t\t\t\tTxID:     *txHash,\n\t\t\t\tPkScript: pkScript,\n\t\t\t}\n\n\t\t\t// If we have any, we'll record their confirmed height\n\t\t\t// so that notifications get dispatched when they\n\t\t\t// reaches the clients' desired number of confirmations.\n\t\t\tif _, ok := n.confNotifications[confRequest]; ok {\n\t\t\t\tnotifyDetails(confRequest)\n\t\t\t}\n\t\t\tconfRequest.TxID = ZeroHash\n\t\t\tif _, ok := n.confNotifications[confRequest]; ok {\n\t\t\t\tnotifyDetails(confRequest)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// handleConfDetailsAtTip tracks the confirmation height of the txid/output\n// script in order to properly dispatch a confirmation notification after\n// meeting each request's desired number of confirmations for all current and\n// future registered clients.",
      "length": 3754,
      "tokens": 481,
      "embedding": []
    },
    {
      "slug": "func (n *TxNotifier) handleConfDetailsAtTip(confRequest ConfRequest,",
      "content": "func (n *TxNotifier) handleConfDetailsAtTip(confRequest ConfRequest,\n\tdetails *TxConfirmation) {\n\n\t// TODO(wilmer): cancel pending historical rescans if any?\n\tconfSet := n.confNotifications[confRequest]\n\n\t// If we already have details for this request, we don't want to add it\n\t// again since we have already dispatched notifications for it.\n\tif confSet.details != nil {\n\t\tLog.Warnf(\"Ignoring address reuse for %s at height %d.\",\n\t\t\tconfRequest, details.BlockHeight)\n\t\treturn\n\t}\n\n\tconfSet.rescanStatus = rescanComplete\n\tconfSet.details = details\n\n\tfor _, ntfn := range confSet.ntfns {\n\t\t// In the event that this notification was aware that the\n\t\t// transaction/output script was reorged out of the chain, we'll\n\t\t// consume the reorg notification if it hasn't been done yet\n\t\t// already.\n\t\tselect {\n\t\tcase <-ntfn.Event.NegativeConf:\n\t\tdefault:\n\t\t}\n\n\t\t// We'll note this client's required number of confirmations so\n\t\t// that we can notify them when expected.\n\t\tconfHeight := details.BlockHeight + ntfn.NumConfirmations - 1\n\t\tntfnSet, exists := n.ntfnsByConfirmHeight[confHeight]\n\t\tif !exists {\n\t\t\tntfnSet = make(map[*ConfNtfn]struct{})\n\t\t\tn.ntfnsByConfirmHeight[confHeight] = ntfnSet\n\t\t}\n\t\tntfnSet[ntfn] = struct{}{}\n\t}\n\n\t// We'll also note the initial confirmation height in order to correctly\n\t// handle dispatching notifications when the transaction/output script\n\t// gets reorged out of the chain.\n\ttxSet, exists := n.confsByInitialHeight[details.BlockHeight]\n\tif !exists {\n\t\ttxSet = make(map[ConfRequest]struct{})\n\t\tn.confsByInitialHeight[details.BlockHeight] = txSet\n\t}\n\ttxSet[confRequest] = struct{}{}\n}\n\n// handleSpendDetailsAtTip tracks the spend height of the outpoint/output script\n// in order to properly dispatch a spend notification for all current and future\n// registered clients.",
      "length": 1678,
      "tokens": 224,
      "embedding": []
    },
    {
      "slug": "func (n *TxNotifier) handleSpendDetailsAtTip(spendRequest SpendRequest,",
      "content": "func (n *TxNotifier) handleSpendDetailsAtTip(spendRequest SpendRequest,\n\tdetails *SpendDetail) {\n\n\t// TODO(wilmer): cancel pending historical rescans if any?\n\tspendSet := n.spendNotifications[spendRequest]\n\tspendSet.rescanStatus = rescanComplete\n\tspendSet.details = details\n\n\tfor _, ntfn := range spendSet.ntfns {\n\t\t// In the event that this notification was aware that the\n\t\t// spending transaction of its outpoint/output script was\n\t\t// reorged out of the chain, we'll consume the reorg\n\t\t// notification if it hasn't been done yet already.\n\t\tselect {\n\t\tcase <-ntfn.Event.Reorg:\n\t\tdefault:\n\t\t}\n\t}\n\n\t// We'll note the spending height of the request in order to correctly\n\t// handle dispatching notifications when the spending transactions gets\n\t// reorged out of the chain.\n\tspendHeight := uint32(details.SpendingHeight)\n\topSet, exists := n.spendsByHeight[spendHeight]\n\tif !exists {\n\t\topSet = make(map[SpendRequest]struct{})\n\t\tn.spendsByHeight[spendHeight] = opSet\n\t}\n\topSet[spendRequest] = struct{}{}\n\n\tLog.Debugf(\"Spend request %v spent at tip=%d\", spendRequest,\n\t\tspendHeight)\n}\n\n// NotifyHeight dispatches confirmation and spend notifications to the clients\n// who registered for a notification which has been fulfilled at the passed\n// height.",
      "length": 1142,
      "tokens": 154,
      "embedding": []
    },
    {
      "slug": "func (n *TxNotifier) NotifyHeight(height uint32) error {",
      "content": "func (n *TxNotifier) NotifyHeight(height uint32) error {\n\tn.Lock()\n\tdefer n.Unlock()\n\n\t// First, we'll dispatch an update to all of the notification clients\n\t// for our watched requests with the number of confirmations left at\n\t// this new height.\n\tfor _, confRequests := range n.confsByInitialHeight {\n\t\tfor confRequest := range confRequests {\n\t\t\tconfSet := n.confNotifications[confRequest]\n\t\t\tfor _, ntfn := range confSet.ntfns {\n\t\t\t\ttxConfHeight := confSet.details.BlockHeight +\n\t\t\t\t\tntfn.NumConfirmations - 1\n\t\t\t\tnumConfsLeft := txConfHeight - height\n\n\t\t\t\t// Since we don't clear notifications until\n\t\t\t\t// transactions/output scripts are no longer\n\t\t\t\t// under the risk of being reorganized out of\n\t\t\t\t// the chain, we'll skip sending updates for\n\t\t\t\t// those that have already been confirmed.\n\t\t\t\tif int32(numConfsLeft) < 0 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tselect {\n\t\t\t\tcase ntfn.Event.Updates <- numConfsLeft:\n\t\t\t\tcase <-n.quit:\n\t\t\t\t\treturn ErrTxNotifierExiting\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Then, we'll dispatch notifications for all the requests that have\n\t// become confirmed at this new block height.\n\tfor ntfn := range n.ntfnsByConfirmHeight[height] {\n\t\tconfSet := n.confNotifications[ntfn.ConfRequest]\n\n\t\tLog.Infof(\"Dispatching %v confirmation notification for %v\",\n\t\t\tntfn.NumConfirmations, ntfn.ConfRequest)\n\n\t\t// The default notification we assigned above includes the\n\t\t// block along with the rest of the details. However not all\n\t\t// clients want the block, so we make a copy here w/o the block\n\t\t// if needed so we can give clients only what they ask for.\n\t\tconfDetails := *confSet.details\n\t\tif !ntfn.includeBlock {\n\t\t\tconfDetails.Block = nil\n\t\t}\n\n\t\tselect {\n\t\tcase ntfn.Event.Confirmed <- &confDetails:\n\t\t\tntfn.dispatched = true\n\t\tcase <-n.quit:\n\t\t\treturn ErrTxNotifierExiting\n\t\t}\n\t}\n\tdelete(n.ntfnsByConfirmHeight, height)\n\n\t// Finally, we'll dispatch spend notifications for all the requests that\n\t// were spent at this new block height.\n\tfor spendRequest := range n.spendsByHeight[height] {\n\t\tspendSet := n.spendNotifications[spendRequest]\n\t\tfor _, ntfn := range spendSet.ntfns {\n\t\t\terr := n.dispatchSpendDetails(ntfn, spendSet.details)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// DisconnectTip handles the tip of the current chain being disconnected during\n// a chain reorganization. If any watched requests were included in this block,\n// internal structures are updated to ensure confirmation/spend notifications\n// are consumed (if not already), and reorg notifications are dispatched\n// instead. Confirmation/spend notifications will be dispatched again upon block\n// inclusion.",
      "length": 2480,
      "tokens": 344,
      "embedding": []
    },
    {
      "slug": "func (n *TxNotifier) DisconnectTip(blockHeight uint32) error {",
      "content": "func (n *TxNotifier) DisconnectTip(blockHeight uint32) error {\n\tselect {\n\tcase <-n.quit:\n\t\treturn ErrTxNotifierExiting\n\tdefault:\n\t}\n\n\tn.Lock()\n\tdefer n.Unlock()\n\n\tif blockHeight != n.currentHeight {\n\t\treturn fmt.Errorf(\"received blocks out of order: \"+\n\t\t\t\"current height=%d, disconnected height=%d\",\n\t\t\tn.currentHeight, blockHeight)\n\t}\n\tn.currentHeight--\n\tn.reorgDepth++\n\n\t// With the block disconnected, we'll update the confirm and spend hints\n\t// for our notification requests to reflect the new height, except for\n\t// those that have confirmed/spent at previous heights.\n\tn.updateHints(blockHeight)\n\n\t// We'll go through all of our watched confirmation requests and attempt\n\t// to drain their notification channels to ensure sending notifications\n\t// to the clients is always non-blocking.\n\tfor initialHeight, txHashes := range n.confsByInitialHeight {\n\t\tfor txHash := range txHashes {\n\t\t\t// If the transaction/output script has been reorged out\n\t\t\t// of the chain, we'll make sure to remove the cached\n\t\t\t// confirmation details to prevent notifying clients\n\t\t\t// with old information.\n\t\t\tconfSet := n.confNotifications[txHash]\n\t\t\tif initialHeight == blockHeight {\n\t\t\t\tconfSet.details = nil\n\t\t\t}\n\n\t\t\tfor _, ntfn := range confSet.ntfns {\n\t\t\t\t// First, we'll attempt to drain an update\n\t\t\t\t// from each notification to ensure sends to the\n\t\t\t\t// Updates channel are always non-blocking.\n\t\t\t\tselect {\n\t\t\t\tcase <-ntfn.Event.Updates:\n\t\t\t\tcase <-n.quit:\n\t\t\t\t\treturn ErrTxNotifierExiting\n\t\t\t\tdefault:\n\t\t\t\t}\n\n\t\t\t\t// Then, we'll check if the current\n\t\t\t\t// transaction/output script was included in the\n\t\t\t\t// block currently being disconnected. If it\n\t\t\t\t// was, we'll need to dispatch a reorg\n\t\t\t\t// notification to the client.\n\t\t\t\tif initialHeight == blockHeight {\n\t\t\t\t\terr := n.dispatchConfReorg(\n\t\t\t\t\t\tntfn, blockHeight,\n\t\t\t\t\t)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// We'll also go through our watched spend requests and attempt to drain\n\t// their dispatched notifications to ensure dispatching notifications to\n\t// clients later on is always non-blocking. We're only interested in\n\t// requests whose spending transaction was included at the height being\n\t// disconnected.\n\tfor op := range n.spendsByHeight[blockHeight] {\n\t\t// Since the spending transaction is being reorged out of the\n\t\t// chain, we'll need to clear out the spending details of the\n\t\t// request.\n\t\tspendSet := n.spendNotifications[op]\n\t\tspendSet.details = nil\n\n\t\t// For all requests which have had a spend notification\n\t\t// dispatched, we'll attempt to drain it and send a reorg\n\t\t// notification instead.\n\t\tfor _, ntfn := range spendSet.ntfns {\n\t\t\tif err := n.dispatchSpendReorg(ntfn); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\t// Finally, we can remove the requests that were confirmed and/or spent\n\t// at the height being disconnected. We'll still continue to track them\n\t// until they have been confirmed/spent and are no longer under the risk\n\t// of being reorged out of the chain again.\n\tdelete(n.confsByInitialHeight, blockHeight)\n\tdelete(n.spendsByHeight, blockHeight)\n\n\treturn nil\n}\n\n// updateHints attempts to update the confirm and spend hints for all relevant\n// requests respectively. The height parameter is used to determine which\n// requests we should update based on whether a new block is being\n// connected/disconnected.\n//\n// NOTE: This must be called with the TxNotifier's lock held and after its\n// height has already been reflected by a block being connected/disconnected.",
      "length": 3328,
      "tokens": 492,
      "embedding": []
    },
    {
      "slug": "func (n *TxNotifier) updateHints(height uint32) {",
      "content": "func (n *TxNotifier) updateHints(height uint32) {\n\t// TODO(wilmer): update under one database transaction.\n\t//\n\t// To update the height hint for all the required confirmation requests\n\t// under one database transaction, we'll gather the set of unconfirmed\n\t// requests along with the ones that confirmed at the height being\n\t// connected/disconnected.\n\tconfRequests := n.unconfirmedRequests()\n\tfor confRequest := range n.confsByInitialHeight[height] {\n\t\tconfRequests = append(confRequests, confRequest)\n\t}\n\terr := n.confirmHintCache.CommitConfirmHint(\n\t\tn.currentHeight, confRequests...,\n\t)\n\tif err != nil {\n\t\t// The error is not fatal as this is an optimistic optimization,\n\t\t// so we'll avoid returning an error.\n\t\tLog.Debugf(\"Unable to update confirm hints to %d for \"+\n\t\t\t\"%v: %v\", n.currentHeight, confRequests, err)\n\t}\n\n\t// Similarly, to update the height hint for all the required spend\n\t// requests under one database transaction, we'll gather the set of\n\t// unspent requests along with the ones that were spent at the height\n\t// being connected/disconnected.\n\tspendRequests := n.unspentRequests()\n\tfor spendRequest := range n.spendsByHeight[height] {\n\t\tspendRequests = append(spendRequests, spendRequest)\n\t}\n\terr = n.spendHintCache.CommitSpendHint(n.currentHeight, spendRequests...)\n\tif err != nil {\n\t\t// The error is not fatal as this is an optimistic optimization,\n\t\t// so we'll avoid returning an error.\n\t\tLog.Debugf(\"Unable to update spend hints to %d for \"+\n\t\t\t\"%v: %v\", n.currentHeight, spendRequests, err)\n\t}\n}\n\n// unconfirmedRequests returns the set of confirmation requests that are\n// still seen as unconfirmed by the TxNotifier.\n//\n// NOTE: This method must be called with the TxNotifier's lock held.",
      "length": 1630,
      "tokens": 232,
      "embedding": []
    },
    {
      "slug": "func (n *TxNotifier) unconfirmedRequests() []ConfRequest {",
      "content": "func (n *TxNotifier) unconfirmedRequests() []ConfRequest {\n\tvar unconfirmed []ConfRequest\n\tfor confRequest, confNtfnSet := range n.confNotifications {\n\t\t// If the notification is already aware of its confirmation\n\t\t// details, or it's in the process of learning them, we'll skip\n\t\t// it as we can't yet determine if it's confirmed or not.\n\t\tif confNtfnSet.rescanStatus != rescanComplete ||\n\t\t\tconfNtfnSet.details != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tunconfirmed = append(unconfirmed, confRequest)\n\t}\n\n\treturn unconfirmed\n}\n\n// unspentRequests returns the set of spend requests that are still seen as\n// unspent by the TxNotifier.\n//\n// NOTE: This method must be called with the TxNotifier's lock held.",
      "length": 614,
      "tokens": 94,
      "embedding": []
    },
    {
      "slug": "func (n *TxNotifier) unspentRequests() []SpendRequest {",
      "content": "func (n *TxNotifier) unspentRequests() []SpendRequest {\n\tvar unspent []SpendRequest\n\tfor spendRequest, spendNtfnSet := range n.spendNotifications {\n\t\t// If the notification is already aware of its spend details, or\n\t\t// it's in the process of learning them, we'll skip it as we\n\t\t// can't yet determine if it's unspent or not.\n\t\tif spendNtfnSet.rescanStatus != rescanComplete ||\n\t\t\tspendNtfnSet.details != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tunspent = append(unspent, spendRequest)\n\t}\n\n\treturn unspent\n}\n\n// dispatchConfReorg dispatches a reorg notification to the client if the\n// confirmation notification was already delivered.\n//\n// NOTE: This must be called with the TxNotifier's lock held.",
      "length": 609,
      "tokens": 92,
      "embedding": []
    },
    {
      "slug": "func (n *TxNotifier) dispatchConfReorg(ntfn *ConfNtfn,",
      "content": "func (n *TxNotifier) dispatchConfReorg(ntfn *ConfNtfn,\n\theightDisconnected uint32) error {\n\n\t// If the request's confirmation notification has yet to be dispatched,\n\t// we'll need to clear its entry within the ntfnsByConfirmHeight index\n\t// to prevent from notifying the client once the notifier reaches the\n\t// confirmation height.\n\tif !ntfn.dispatched {\n\t\tconfHeight := heightDisconnected + ntfn.NumConfirmations - 1\n\t\tntfnSet, exists := n.ntfnsByConfirmHeight[confHeight]\n\t\tif exists {\n\t\t\tdelete(ntfnSet, ntfn)\n\t\t}\n\t\treturn nil\n\t}\n\n\t// Otherwise, the entry within the ntfnsByConfirmHeight has already been\n\t// deleted, so we'll attempt to drain the confirmation notification to\n\t// ensure sends to the Confirmed channel are always non-blocking.\n\tselect {\n\tcase <-ntfn.Event.Confirmed:\n\tcase <-n.quit:\n\t\treturn ErrTxNotifierExiting\n\tdefault:\n\t}\n\n\tntfn.dispatched = false\n\n\t// Send a negative confirmation notification to the client indicating\n\t// how many blocks have been disconnected successively.\n\tselect {\n\tcase ntfn.Event.NegativeConf <- int32(n.reorgDepth):\n\tcase <-n.quit:\n\t\treturn ErrTxNotifierExiting\n\t}\n\n\treturn nil\n}\n\n// dispatchSpendReorg dispatches a reorg notification to the client if a spend\n// notiification was already delivered.\n//\n// NOTE: This must be called with the TxNotifier's lock held.",
      "length": 1218,
      "tokens": 169,
      "embedding": []
    },
    {
      "slug": "func (n *TxNotifier) dispatchSpendReorg(ntfn *SpendNtfn) error {",
      "content": "func (n *TxNotifier) dispatchSpendReorg(ntfn *SpendNtfn) error {\n\tif !ntfn.dispatched {\n\t\treturn nil\n\t}\n\n\t// Attempt to drain the spend notification to ensure sends to the Spend\n\t// channel are always non-blocking.\n\tselect {\n\tcase <-ntfn.Event.Spend:\n\tdefault:\n\t}\n\n\t// Send a reorg notification to the client in order for them to\n\t// correctly handle reorgs.\n\tselect {\n\tcase ntfn.Event.Reorg <- struct{}{}:\n\tcase <-n.quit:\n\t\treturn ErrTxNotifierExiting\n\t}\n\n\tntfn.dispatched = false\n\n\treturn nil\n}\n\n// TearDown is to be called when the owner of the TxNotifier is exiting. This\n// closes the event channels of all registered notifications that have not been\n// dispatched yet.",
      "length": 583,
      "tokens": 95,
      "embedding": []
    },
    {
      "slug": "func (n *TxNotifier) TearDown() {",
      "content": "func (n *TxNotifier) TearDown() {\n\tclose(n.quit)\n\n\tn.Lock()\n\tdefer n.Unlock()\n\n\tfor _, confSet := range n.confNotifications {\n\t\tfor confID, ntfn := range confSet.ntfns {\n\t\t\tclose(ntfn.Event.Confirmed)\n\t\t\tclose(ntfn.Event.Updates)\n\t\t\tclose(ntfn.Event.NegativeConf)\n\t\t\tclose(ntfn.Event.Done)\n\t\t\tdelete(confSet.ntfns, confID)\n\t\t}\n\t}\n\n\tfor _, spendSet := range n.spendNotifications {\n\t\tfor spendID, ntfn := range spendSet.ntfns {\n\t\t\tclose(ntfn.Event.Spend)\n\t\t\tclose(ntfn.Event.Reorg)\n\t\t\tclose(ntfn.Event.Done)\n\t\t\tdelete(spendSet.ntfns, spendID)\n\t\t}\n\t}\n}\n",
      "length": 492,
      "tokens": 48,
      "embedding": []
    }
  ]
}