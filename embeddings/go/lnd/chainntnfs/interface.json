{
  "filepath": "../implementations/go/lnd/chainntnfs/interface.go",
  "package": "chainntnfs",
  "sections": [
    {
      "slug": "type TxConfStatus uint8",
      "content": "type TxConfStatus uint8\n\nconst (\n\t// TxFoundMempool denotes that the transaction was found within the\n\t// backend node's mempool.\n\tTxFoundMempool TxConfStatus = iota\n\n\t// TxFoundIndex denotes that the transaction was found within the\n\t// backend node's txindex.\n\tTxFoundIndex\n\n\t// TxNotFoundIndex denotes that the transaction was not found within the\n\t// backend node's txindex.\n\tTxNotFoundIndex\n\n\t// TxFoundManually denotes that the transaction was found within the\n\t// chain by scanning for it manually.\n\tTxFoundManually\n\n\t// TxNotFoundManually denotes that the transaction was not found within\n\t// the chain by scanning for it manually.\n\tTxNotFoundManually\n)\n\n// String returns the string representation of the TxConfStatus.",
      "length": 680,
      "tokens": 98,
      "embedding": []
    },
    {
      "slug": "func (t TxConfStatus) String() string {",
      "content": "func (t TxConfStatus) String() string {\n\tswitch t {\n\tcase TxFoundMempool:\n\t\treturn \"TxFoundMempool\"\n\n\tcase TxFoundIndex:\n\t\treturn \"TxFoundIndex\"\n\n\tcase TxNotFoundIndex:\n\t\treturn \"TxNotFoundIndex\"\n\n\tcase TxFoundManually:\n\t\treturn \"TxFoundManually\"\n\n\tcase TxNotFoundManually:\n\t\treturn \"TxNotFoundManually\"\n\n\tdefault:\n\t\treturn \"unknown\"\n\t}\n}\n\n// notifierOptions is a set of functional options that allow callers to further\n// modify the type of chain event notifications they receive.",
      "length": 419,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "type notifierOptions struct {",
      "content": "type notifierOptions struct {\n\t// includeBlock if true, then the dispatched confirmation notification\n\t// will include the block that mined the transaction.\n\tincludeBlock bool\n}\n\n// defaultNotifierOptions returns the set of default options for the notifier.",
      "length": 222,
      "tokens": 32,
      "embedding": []
    },
    {
      "slug": "func defaultNotifierOptions() *notifierOptions {",
      "content": "func defaultNotifierOptions() *notifierOptions {\n\treturn &notifierOptions{}\n}\n\n// NotifierOption is a functional option that allows a caller to modify the\n// events received from the notifier.",
      "length": 139,
      "tokens": 22,
      "embedding": []
    },
    {
      "slug": "type NotifierOption func(*notifierOptions)",
      "content": "type NotifierOption func(*notifierOptions)\n\n// WithIncludeBlock is an optional argument that allows the calelr to specify\n// that the block that mined a transaction should be included in the response.",
      "length": 155,
      "tokens": 26,
      "embedding": []
    },
    {
      "slug": "func WithIncludeBlock() NotifierOption {",
      "content": "func WithIncludeBlock() NotifierOption {\n\treturn func(o *notifierOptions) {\n\t\to.includeBlock = true\n\t}\n}\n\n// ChainNotifier represents a trusted source to receive notifications concerning\n// targeted events on the Bitcoin blockchain. The interface specification is\n// intentionally general in order to support a wide array of chain notification\n// implementations such as: btcd's websockets notifications, Bitcoin Core's\n// ZeroMQ notifications, various Bitcoin API services, Electrum servers, etc.\n//\n// Concrete implementations of ChainNotifier should be able to support multiple\n// concurrent client requests, as well as multiple concurrent notification events.",
      "length": 610,
      "tokens": 85,
      "embedding": []
    },
    {
      "slug": "type ChainNotifier interface {",
      "content": "type ChainNotifier interface {\n\t// RegisterConfirmationsNtfn registers an intent to be notified once\n\t// txid reaches numConfs confirmations. We also pass in the pkScript as\n\t// the default light client instead needs to match on scripts created in\n\t// the block. If a nil txid is passed in, then not only should we match\n\t// on the script, but we should also dispatch once the transaction\n\t// containing the script reaches numConfs confirmations. This can be\n\t// useful in instances where we only know the script in advance, but not\n\t// the transaction containing it.\n\t//\n\t// The returned ConfirmationEvent should properly notify the client once\n\t// the specified number of confirmations has been reached for the txid,\n\t// as well as if the original tx gets re-org'd out of the mainchain. The\n\t// heightHint parameter is provided as a convenience to light clients.\n\t// It heightHint denotes the earliest height in the blockchain in which\n\t// the target txid _could_ have been included in the chain. This can be\n\t// used to bound the search space when checking to see if a notification\n\t// can immediately be dispatched due to historical data.\n\t//\n\t// NOTE: Dispatching notifications to multiple clients subscribed to\n\t// the same (txid, numConfs) tuple MUST be supported.\n\tRegisterConfirmationsNtfn(txid *chainhash.Hash, pkScript []byte,\n\t\tnumConfs, heightHint uint32,\n\t\topts ...NotifierOption) (*ConfirmationEvent, error)\n\n\t// RegisterSpendNtfn registers an intent to be notified once the target\n\t// outpoint is successfully spent within a transaction. The script that\n\t// the outpoint creates must also be specified. This allows this\n\t// interface to be implemented by BIP 158-like filtering. If a nil\n\t// outpoint is passed in, then not only should we match on the script,\n\t// but we should also dispatch once a transaction spends the output\n\t// containing said script. This can be useful in instances where we only\n\t// know the script in advance, but not the outpoint itself.\n\t//\n\t// The returned SpendEvent will receive a send on the 'Spend'\n\t// transaction once a transaction spending the input is detected on the\n\t// blockchain. The heightHint parameter is provided as a convenience to\n\t// light clients. It denotes the earliest height in the blockchain in\n\t// which the target output could have been spent.\n\t//\n\t// NOTE: The notification should only be triggered when the spending\n\t// transaction receives a single confirmation.\n\t//\n\t// NOTE: Dispatching notifications to multiple clients subscribed to a\n\t// spend of the same outpoint MUST be supported.\n\tRegisterSpendNtfn(outpoint *wire.OutPoint, pkScript []byte,\n\t\theightHint uint32) (*SpendEvent, error)\n\n\t// RegisterBlockEpochNtfn registers an intent to be notified of each\n\t// new block connected to the tip of the main chain. The returned\n\t// BlockEpochEvent struct contains a channel which will be sent upon\n\t// for each new block discovered.\n\t//\n\t// Clients have the option of passing in their best known block.\n\t// If they specify a block, the ChainNotifier checks whether the client\n\t// is behind on blocks. If they are, the ChainNotifier sends a backlog\n\t// of block notifications for the missed blocks. If they do not provide\n\t// one, then a notification will be dispatched immediately for the\n\t// current tip of the chain upon a successful registration.\n\tRegisterBlockEpochNtfn(*BlockEpoch) (*BlockEpochEvent, error)\n\n\t// Start the ChainNotifier. Once started, the implementation should be\n\t// ready, and able to receive notification registrations from clients.\n\tStart() error\n\n\t// Started returns true if this instance has been started, and false otherwise.\n\tStarted() bool\n\n\t// Stops the concrete ChainNotifier. Once stopped, the ChainNotifier\n\t// should disallow any future requests from potential clients.\n\t// Additionally, all pending client notifications will be canceled\n\t// by closing the related channels on the *Event's.\n\tStop() error\n}\n\n// TxConfirmation carries some additional block-level details of the exact\n// block that specified transactions was confirmed within.",
      "length": 3947,
      "tokens": 625,
      "embedding": []
    },
    {
      "slug": "type TxConfirmation struct {",
      "content": "type TxConfirmation struct {\n\t// BlockHash is the hash of the block that confirmed the original\n\t// transition.\n\tBlockHash *chainhash.Hash\n\n\t// BlockHeight is the height of the block in which the transaction was\n\t// confirmed within.\n\tBlockHeight uint32\n\n\t// TxIndex is the index within the block of the ultimate confirmed\n\t// transaction.\n\tTxIndex uint32\n\n\t// Tx is the transaction for which the notification was requested for.\n\tTx *wire.MsgTx\n\n\t// Block is the block that contains the transaction referenced above.\n\t//\n\t// NOTE: This is only specified if the confirmation request opts to\n\t// have the response include the block itself.\n\tBlock *wire.MsgBlock\n}\n\n// ConfirmationEvent encapsulates a confirmation notification. With this struct,\n// callers can be notified of: the instance the target txid reaches the targeted\n// number of confirmations, how many confirmations are left for the target txid\n// to be fully confirmed at every new block height, and also in the event that\n// the original txid becomes disconnected from the blockchain as a result of a\n// re-org.\n//\n// Once the txid reaches the specified number of confirmations, the 'Confirmed'\n// channel will be sent upon fulfilling the notification.\n//\n// If the event that the original transaction becomes re-org'd out of the main\n// chain, the 'NegativeConf' will be sent upon with a value representing the\n// depth of the re-org.\n//\n// NOTE: If the caller wishes to cancel their registered spend notification,\n// the Cancel closure MUST be called.",
      "length": 1449,
      "tokens": 242,
      "embedding": []
    },
    {
      "slug": "type ConfirmationEvent struct {",
      "content": "type ConfirmationEvent struct {\n\t// Confirmed is a channel that will be sent upon once the transaction\n\t// has been fully confirmed. The struct sent will contain all the\n\t// details of the channel's confirmation.\n\t//\n\t// NOTE: This channel must be buffered.\n\tConfirmed chan *TxConfirmation\n\n\t// Updates is a channel that will sent upon, at every incremental\n\t// confirmation, how many confirmations are left to declare the\n\t// transaction as fully confirmed.\n\t//\n\t// NOTE: This channel must be buffered with the number of required\n\t// confirmations.\n\tUpdates chan uint32\n\n\t// NegativeConf is a channel that will be sent upon if the transaction\n\t// confirms, but is later reorged out of the chain. The integer sent\n\t// through the channel represents the reorg depth.\n\t//\n\t// NOTE: This channel must be buffered.\n\tNegativeConf chan int32\n\n\t// Done is a channel that gets sent upon once the confirmation request\n\t// is no longer under the risk of being reorged out of the chain.\n\t//\n\t// NOTE: This channel must be buffered.\n\tDone chan struct{}\n\n\t// Cancel is a closure that should be executed by the caller in the case\n\t// that they wish to prematurely abandon their registered confirmation\n\t// notification.\n\tCancel func()\n}\n\n// NewConfirmationEvent constructs a new ConfirmationEvent with newly opened\n// channels.",
      "length": 1246,
      "tokens": 211,
      "embedding": []
    },
    {
      "slug": "func NewConfirmationEvent(numConfs uint32, cancel func()) *ConfirmationEvent {",
      "content": "func NewConfirmationEvent(numConfs uint32, cancel func()) *ConfirmationEvent {\n\treturn &ConfirmationEvent{\n\t\tConfirmed:    make(chan *TxConfirmation, 1),\n\t\tUpdates:      make(chan uint32, numConfs),\n\t\tNegativeConf: make(chan int32, 1),\n\t\tDone:         make(chan struct{}, 1),\n\t\tCancel:       cancel,\n\t}\n}\n\n// SpendDetail contains details pertaining to a spent output. This struct itself\n// is the spentness notification. It includes the original outpoint which triggered\n// the notification, the hash of the transaction spending the output, the\n// spending transaction itself, and finally the input index which spent the\n// target output.",
      "length": 546,
      "tokens": 73,
      "embedding": []
    },
    {
      "slug": "type SpendDetail struct {",
      "content": "type SpendDetail struct {\n\tSpentOutPoint     *wire.OutPoint\n\tSpenderTxHash     *chainhash.Hash\n\tSpendingTx        *wire.MsgTx\n\tSpenderInputIndex uint32\n\tSpendingHeight    int32\n}\n\n// String returns a string representation of SpendDetail.",
      "length": 204,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func (s *SpendDetail) String() string {",
      "content": "func (s *SpendDetail) String() string {\n\treturn fmt.Sprintf(\"%v[%d] spending %v at height=%v\", s.SpenderTxHash,\n\t\ts.SpenderInputIndex, s.SpentOutPoint, s.SpendingHeight)\n}\n\n// SpendEvent encapsulates a spentness notification. Its only field 'Spend' will\n// be sent upon once the target output passed into RegisterSpendNtfn has been\n// spent on the blockchain.\n//\n// NOTE: If the caller wishes to cancel their registered spend notification,\n// the Cancel closure MUST be called.",
      "length": 428,
      "tokens": 60,
      "embedding": []
    },
    {
      "slug": "type SpendEvent struct {",
      "content": "type SpendEvent struct {\n\t// Spend is a receive only channel which will be sent upon once the\n\t// target outpoint has been spent.\n\t//\n\t// NOTE: This channel must be buffered.\n\tSpend chan *SpendDetail\n\n\t// Reorg is a channel that will be sent upon once we detect the spending\n\t// transaction of the outpoint in question has been reorged out of the\n\t// chain.\n\t//\n\t// NOTE: This channel must be buffered.\n\tReorg chan struct{}\n\n\t// Done is a channel that gets sent upon once the confirmation request\n\t// is no longer under the risk of being reorged out of the chain.\n\t//\n\t// NOTE: This channel must be buffered.\n\tDone chan struct{}\n\n\t// Cancel is a closure that should be executed by the caller in the case\n\t// that they wish to prematurely abandon their registered spend\n\t// notification.\n\tCancel func()\n}\n\n// NewSpendEvent constructs a new SpendEvent with newly opened channels.",
      "length": 827,
      "tokens": 150,
      "embedding": []
    },
    {
      "slug": "func NewSpendEvent(cancel func()) *SpendEvent {",
      "content": "func NewSpendEvent(cancel func()) *SpendEvent {\n\treturn &SpendEvent{\n\t\tSpend:  make(chan *SpendDetail, 1),\n\t\tReorg:  make(chan struct{}, 1),\n\t\tDone:   make(chan struct{}, 1),\n\t\tCancel: cancel,\n\t}\n}\n\n// BlockEpoch represents metadata concerning each new block connected to the\n// main chain.",
      "length": 233,
      "tokens": 32,
      "embedding": []
    },
    {
      "slug": "type BlockEpoch struct {",
      "content": "type BlockEpoch struct {\n\t// Hash is the block hash of the latest block to be added to the tip of\n\t// the main chain.\n\tHash *chainhash.Hash\n\n\t// Height is the height of the latest block to be added to the tip of\n\t// the main chain.\n\tHeight int32\n\n\t// BlockHeader is the block header of this new height.\n\tBlockHeader *wire.BlockHeader\n}\n\n// BlockEpochEvent encapsulates an on-going stream of block epoch\n// notifications. Its only field 'Epochs' will be sent upon for each new block\n// connected to the main-chain.\n//\n// NOTE: If the caller wishes to cancel their registered block epoch\n// notification, the Cancel closure MUST be called.",
      "length": 595,
      "tokens": 107,
      "embedding": []
    },
    {
      "slug": "type BlockEpochEvent struct {",
      "content": "type BlockEpochEvent struct {\n\t// Epochs is a receive only channel that will be sent upon each time a\n\t// new block is connected to the end of the main chain.\n\t//\n\t// NOTE: This channel must be buffered.\n\tEpochs <-chan *BlockEpoch\n\n\t// Cancel is a closure that should be executed by the caller in the case\n\t// that they wish to abandon their registered block epochs notification.\n\tCancel func()\n}\n\n// NotifierDriver represents a \"driver\" for a particular interface. A driver is\n// identified by a globally unique string identifier along with a 'New()'\n// method which is responsible for initializing a particular ChainNotifier\n// concrete implementation.",
      "length": 610,
      "tokens": 104,
      "embedding": []
    },
    {
      "slug": "type NotifierDriver struct {",
      "content": "type NotifierDriver struct {\n\t// NotifierType is a string which uniquely identifies the ChainNotifier\n\t// that this driver, drives.\n\tNotifierType string\n\n\t// New creates a new instance of a concrete ChainNotifier\n\t// implementation given a variadic set up arguments. The function takes\n\t// a variadic number of interface parameters in order to provide\n\t// initialization flexibility, thereby accommodating several potential\n\t// ChainNotifier implementations.\n\tNew func(args ...interface{}) (ChainNotifier, error)\n}\n\nvar (\n\tnotifiers   = make(map[string]*NotifierDriver)\n\tregisterMtx sync.Mutex\n)\n\n// RegisteredNotifiers returns a slice of all currently registered notifiers.\n//\n// NOTE: This function is safe for concurrent access.",
      "length": 683,
      "tokens": 93,
      "embedding": []
    },
    {
      "slug": "func RegisteredNotifiers() []*NotifierDriver {",
      "content": "func RegisteredNotifiers() []*NotifierDriver {\n\tregisterMtx.Lock()\n\tdefer registerMtx.Unlock()\n\n\tdrivers := make([]*NotifierDriver, 0, len(notifiers))\n\tfor _, driver := range notifiers {\n\t\tdrivers = append(drivers, driver)\n\t}\n\n\treturn drivers\n}\n\n// RegisterNotifier registers a NotifierDriver which is capable of driving a\n// concrete ChainNotifier interface. In the case that this driver has already\n// been registered, an error is returned.\n//\n// NOTE: This function is safe for concurrent access.",
      "length": 437,
      "tokens": 63,
      "embedding": []
    },
    {
      "slug": "func RegisterNotifier(driver *NotifierDriver) error {",
      "content": "func RegisterNotifier(driver *NotifierDriver) error {\n\tregisterMtx.Lock()\n\tdefer registerMtx.Unlock()\n\n\tif _, ok := notifiers[driver.NotifierType]; ok {\n\t\treturn fmt.Errorf(\"notifier already registered\")\n\t}\n\n\tnotifiers[driver.NotifierType] = driver\n\n\treturn nil\n}\n\n// SupportedNotifiers returns a slice of strings that represent the database\n// drivers that have been registered and are therefore supported.\n//\n// NOTE: This function is safe for concurrent access.",
      "length": 395,
      "tokens": 52,
      "embedding": []
    },
    {
      "slug": "func SupportedNotifiers() []string {",
      "content": "func SupportedNotifiers() []string {\n\tregisterMtx.Lock()\n\tdefer registerMtx.Unlock()\n\n\tsupportedNotifiers := make([]string, 0, len(notifiers))\n\tfor driverName := range notifiers {\n\t\tsupportedNotifiers = append(supportedNotifiers, driverName)\n\t}\n\n\treturn supportedNotifiers\n}\n\n// ChainConn enables notifiers to pass in their chain backend to interface\n// functions that require it.",
      "length": 331,
      "tokens": 39,
      "embedding": []
    },
    {
      "slug": "type ChainConn interface {",
      "content": "type ChainConn interface {\n\t// GetBlockHeader returns the block header for a hash.\n\tGetBlockHeader(blockHash *chainhash.Hash) (*wire.BlockHeader, error)\n\n\t// GetBlockHeaderVerbose returns the verbose block header for a hash.\n\tGetBlockHeaderVerbose(blockHash *chainhash.Hash) (\n\t\t*btcjson.GetBlockHeaderVerboseResult, error)\n\n\t// GetBlockHash returns the hash from a block height.\n\tGetBlockHash(blockHeight int64) (*chainhash.Hash, error)\n}\n\n// GetCommonBlockAncestorHeight takes in:\n// (1) the hash of a block that has been reorged out of the main chain\n// (2) the hash of the block of the same height from the main chain\n// It returns the height of the nearest common ancestor between the two hashes,\n// or an error",
      "length": 674,
      "tokens": 95,
      "embedding": []
    },
    {
      "slug": "func GetCommonBlockAncestorHeight(chainConn ChainConn, reorgHash,",
      "content": "func GetCommonBlockAncestorHeight(chainConn ChainConn, reorgHash,\n\tchainHash chainhash.Hash) (int32, error) {\n\n\tfor reorgHash != chainHash {\n\t\treorgHeader, err := chainConn.GetBlockHeader(&reorgHash)\n\t\tif err != nil {\n\t\t\treturn 0, fmt.Errorf(\"unable to get header for hash=%v: %v\",\n\t\t\t\treorgHash, err)\n\t\t}\n\t\tchainHeader, err := chainConn.GetBlockHeader(&chainHash)\n\t\tif err != nil {\n\t\t\treturn 0, fmt.Errorf(\"unable to get header for hash=%v: %v\",\n\t\t\t\tchainHash, err)\n\t\t}\n\t\treorgHash = reorgHeader.PrevBlock\n\t\tchainHash = chainHeader.PrevBlock\n\t}\n\n\tverboseHeader, err := chainConn.GetBlockHeaderVerbose(&chainHash)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"unable to get verbose header for hash=%v: %v\",\n\t\t\tchainHash, err)\n\t}\n\n\treturn verboseHeader.Height, nil\n}\n\n// GetClientMissedBlocks uses a client's best block to determine what blocks\n// it missed being notified about, and returns them in a slice. Its\n// backendStoresReorgs parameter tells it whether or not the notifier's\n// chainConn stores information about blocks that have been reorged out of the\n// chain, which allows GetClientMissedBlocks to find out whether the client's\n// best block has been reorged out of the chain, rewind to the common ancestor\n// and return blocks starting right after the common ancestor.",
      "length": 1179,
      "tokens": 168,
      "embedding": []
    },
    {
      "slug": "func GetClientMissedBlocks(chainConn ChainConn, clientBestBlock *BlockEpoch,",
      "content": "func GetClientMissedBlocks(chainConn ChainConn, clientBestBlock *BlockEpoch,\n\tnotifierBestHeight int32, backendStoresReorgs bool) ([]BlockEpoch, error) {\n\n\tstartingHeight := clientBestBlock.Height\n\tif backendStoresReorgs {\n\t\t// If a reorg causes the client's best hash to be incorrect,\n\t\t// retrieve the closest common ancestor and dispatch\n\t\t// notifications from there.\n\t\thashAtBestHeight, err := chainConn.GetBlockHash(\n\t\t\tint64(clientBestBlock.Height))\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to find blockhash for \"+\n\t\t\t\t\"height=%d: %v\", clientBestBlock.Height, err)\n\t\t}\n\n\t\tstartingHeight, err = GetCommonBlockAncestorHeight(\n\t\t\tchainConn, *clientBestBlock.Hash, *hashAtBestHeight,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to find common ancestor: \"+\n\t\t\t\t\"%v\", err)\n\t\t}\n\t}\n\n\t// We want to start dispatching historical notifications from the block\n\t// right after the client's best block, to avoid a redundant notification.\n\tmissedBlocks, err := getMissedBlocks(\n\t\tchainConn, startingHeight+1, notifierBestHeight+1,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to get missed blocks: %v\", err)\n\t}\n\n\treturn missedBlocks, nil\n}\n\n// RewindChain handles internal state updates for the notifier's TxNotifier. It\n// has no effect if given a height greater than or equal to our current best\n// known height. It returns the new best block for the notifier.",
      "length": 1272,
      "tokens": 174,
      "embedding": []
    },
    {
      "slug": "func RewindChain(chainConn ChainConn, txNotifier *TxNotifier,",
      "content": "func RewindChain(chainConn ChainConn, txNotifier *TxNotifier,\n\tcurrBestBlock BlockEpoch, targetHeight int32) (BlockEpoch, error) {\n\n\tnewBestBlock := BlockEpoch{\n\t\tHeight:      currBestBlock.Height,\n\t\tHash:        currBestBlock.Hash,\n\t\tBlockHeader: currBestBlock.BlockHeader,\n\t}\n\n\tfor height := currBestBlock.Height; height > targetHeight; height-- {\n\t\thash, err := chainConn.GetBlockHash(int64(height - 1))\n\t\tif err != nil {\n\t\t\treturn newBestBlock, fmt.Errorf(\"unable to \"+\n\t\t\t\t\"find blockhash for disconnected height=%d: %v\",\n\t\t\t\theight, err)\n\t\t}\n\t\theader, err := chainConn.GetBlockHeader(hash)\n\t\tif err != nil {\n\t\t\treturn newBestBlock, fmt.Errorf(\"unable to get block \"+\n\t\t\t\t\"header for height=%v\", height-1)\n\t\t}\n\n\t\tLog.Infof(\"Block disconnected from main chain: \"+\n\t\t\t\"height=%v, sha=%v\", height, newBestBlock.Hash)\n\n\t\terr = txNotifier.DisconnectTip(uint32(height))\n\t\tif err != nil {\n\t\t\treturn newBestBlock, fmt.Errorf(\"unable to \"+\n\t\t\t\t\" disconnect tip for height=%d: %v\",\n\t\t\t\theight, err)\n\t\t}\n\t\tnewBestBlock.Height = height - 1\n\t\tnewBestBlock.Hash = hash\n\t\tnewBestBlock.BlockHeader = header\n\t}\n\n\treturn newBestBlock, nil\n}\n\n// HandleMissedBlocks is called when the chain backend for a notifier misses a\n// series of blocks, handling a reorg if necessary. Its backendStoresReorgs\n// parameter tells it whether or not the notifier's chainConn stores\n// information about blocks that have been reorged out of the chain, which allows\n// HandleMissedBlocks to check whether the notifier's best block has been\n// reorged out, and rewind the chain accordingly. It returns the best block for\n// the notifier and a slice of the missed blocks. The new best block needs to be\n// returned in case a chain rewind occurs and partially completes before\n// erroring. In the case where there is no rewind, the notifier's\n// current best block is returned.",
      "length": 1734,
      "tokens": 241,
      "embedding": []
    },
    {
      "slug": "func HandleMissedBlocks(chainConn ChainConn, txNotifier *TxNotifier,",
      "content": "func HandleMissedBlocks(chainConn ChainConn, txNotifier *TxNotifier,\n\tcurrBestBlock BlockEpoch, newHeight int32,\n\tbackendStoresReorgs bool) (BlockEpoch, []BlockEpoch, error) {\n\n\tstartingHeight := currBestBlock.Height\n\n\tif backendStoresReorgs {\n\t\t// If a reorg causes our best hash to be incorrect, rewind the\n\t\t// chain so our best block is set to the closest common\n\t\t// ancestor, then dispatch notifications from there.\n\t\thashAtBestHeight, err := chainConn.GetBlockHash(\n\t\t\tint64(currBestBlock.Height),\n\t\t)\n\t\tif err != nil {\n\t\t\treturn currBestBlock, nil, fmt.Errorf(\"unable to find \"+\n\t\t\t\t\"blockhash for height=%d: %v\",\n\t\t\t\tcurrBestBlock.Height, err)\n\t\t}\n\n\t\tstartingHeight, err = GetCommonBlockAncestorHeight(\n\t\t\tchainConn, *currBestBlock.Hash, *hashAtBestHeight,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn currBestBlock, nil, fmt.Errorf(\"unable to find \"+\n\t\t\t\t\"common ancestor: %v\", err)\n\t\t}\n\n\t\tcurrBestBlock, err = RewindChain(\n\t\t\tchainConn, txNotifier, currBestBlock, startingHeight,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn currBestBlock, nil, fmt.Errorf(\"unable to \"+\n\t\t\t\t\"rewind chain: %v\", err)\n\t\t}\n\t}\n\n\t// We want to start dispatching historical notifications from the block\n\t// right after our best block, to avoid a redundant notification.\n\tmissedBlocks, err := getMissedBlocks(chainConn, startingHeight+1, newHeight)\n\tif err != nil {\n\t\treturn currBestBlock, nil, fmt.Errorf(\"unable to get missed \"+\n\t\t\t\"blocks: %v\", err)\n\t}\n\n\treturn currBestBlock, missedBlocks, nil\n}\n\n// getMissedBlocks returns a slice of blocks: [startingHeight, endingHeight)\n// fetched from the chain.",
      "length": 1449,
      "tokens": 188,
      "embedding": []
    },
    {
      "slug": "func getMissedBlocks(chainConn ChainConn, startingHeight,",
      "content": "func getMissedBlocks(chainConn ChainConn, startingHeight,\n\tendingHeight int32) ([]BlockEpoch, error) {\n\n\tnumMissedBlocks := endingHeight - startingHeight\n\tif numMissedBlocks < 0 {\n\t\treturn nil, fmt.Errorf(\"starting height %d is greater than \"+\n\t\t\t\"ending height %d\", startingHeight, endingHeight)\n\t}\n\n\tmissedBlocks := make([]BlockEpoch, 0, numMissedBlocks)\n\tfor height := startingHeight; height < endingHeight; height++ {\n\t\thash, err := chainConn.GetBlockHash(int64(height))\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to find blockhash for \"+\n\t\t\t\t\"height=%d: %v\", height, err)\n\t\t}\n\t\theader, err := chainConn.GetBlockHeader(hash)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to find block header \"+\n\t\t\t\t\"for height=%d: %v\", height, err)\n\t\t}\n\n\t\tmissedBlocks = append(\n\t\t\tmissedBlocks,\n\t\t\tBlockEpoch{\n\t\t\t\tHash:        hash,\n\t\t\t\tHeight:      height,\n\t\t\t\tBlockHeader: header,\n\t\t\t},\n\t\t)\n\t}\n\n\treturn missedBlocks, nil\n}\n\n// TxIndexConn abstracts an RPC backend with txindex enabled.",
      "length": 899,
      "tokens": 116,
      "embedding": []
    },
    {
      "slug": "type TxIndexConn interface {",
      "content": "type TxIndexConn interface {\n\t// GetRawTransactionVerbose returns the transaction identified by the\n\t// passed chain hash, and returns additional information such as the\n\t// block that the transaction confirmed.\n\tGetRawTransactionVerbose(*chainhash.Hash) (*btcjson.TxRawResult, error)\n\n\t// GetBlock returns the block identified by the chain hash.\n\tGetBlock(*chainhash.Hash) (*wire.MsgBlock, error)\n}\n\n// ConfDetailsFromTxIndex looks up whether a transaction is already included in\n// a block in the active chain by using the backend node's transaction index.\n// If the transaction is found its TxConfStatus is returned. If it was found in\n// the mempool this will be TxFoundMempool, if it is found in a block this will\n// be TxFoundIndex. Otherwise TxNotFoundIndex is returned. If the tx is found\n// in a block its confirmation details are also returned.",
      "length": 811,
      "tokens": 120,
      "embedding": []
    },
    {
      "slug": "func ConfDetailsFromTxIndex(chainConn TxIndexConn, r ConfRequest,",
      "content": "func ConfDetailsFromTxIndex(chainConn TxIndexConn, r ConfRequest,\n\ttxNotFoundErr string) (*TxConfirmation, TxConfStatus, error) {\n\n\t// If the transaction has some or all of its confirmations required,\n\t// then we may be able to dispatch it immediately.\n\trawTxRes, err := chainConn.GetRawTransactionVerbose(&r.TxID)\n\tif err != nil {\n\t\t// If the transaction lookup was successful, but it wasn't found\n\t\t// within the index itself, then we can exit early. We'll also\n\t\t// need to look at the error message returned as the error code\n\t\t// is used for multiple errors.\n\t\tjsonErr, ok := err.(*btcjson.RPCError)\n\t\tif ok && jsonErr.Code == btcjson.ErrRPCNoTxInfo &&\n\t\t\tstrings.Contains(jsonErr.Message, txNotFoundErr) {\n\n\t\t\treturn nil, TxNotFoundIndex, nil\n\t\t}\n\n\t\treturn nil, TxNotFoundIndex,\n\t\t\tfmt.Errorf(\"unable to query for txid %v: %v\",\n\t\t\t\tr.TxID, err)\n\t}\n\n\t// Deserialize the hex-encoded transaction to include it in the\n\t// confirmation details.\n\trawTx, err := hex.DecodeString(rawTxRes.Hex)\n\tif err != nil {\n\t\treturn nil, TxNotFoundIndex,\n\t\t\tfmt.Errorf(\"unable to deserialize tx %v: %v\",\n\t\t\t\tr.TxID, err)\n\t}\n\tvar tx wire.MsgTx\n\tif err := tx.Deserialize(bytes.NewReader(rawTx)); err != nil {\n\t\treturn nil, TxNotFoundIndex,\n\t\t\tfmt.Errorf(\"unable to deserialize tx %v: %v\",\n\t\t\t\tr.TxID, err)\n\t}\n\n\t// Ensure the transaction matches our confirmation request in terms of\n\t// txid and pkscript.\n\tif !r.MatchesTx(&tx) {\n\t\treturn nil, TxNotFoundIndex,\n\t\t\tfmt.Errorf(\"unable to locate tx %v\", r.TxID)\n\t}\n\n\t// Make sure we actually retrieved a transaction that is included in a\n\t// block. If not, the transaction must be unconfirmed (in the mempool),\n\t// and we'll return TxFoundMempool together with a nil TxConfirmation.\n\tif rawTxRes.BlockHash == \"\" {\n\t\treturn nil, TxFoundMempool, nil\n\t}\n\n\t// As we need to fully populate the returned TxConfirmation struct,\n\t// grab the block in which the transaction was confirmed so we can\n\t// locate its exact index within the block.\n\tblockHash, err := chainhash.NewHashFromStr(rawTxRes.BlockHash)\n\tif err != nil {\n\t\treturn nil, TxNotFoundIndex,\n\t\t\tfmt.Errorf(\"unable to get block hash %v for \"+\n\t\t\t\t\"historical dispatch: %v\", rawTxRes.BlockHash, err)\n\t}\n\tblock, err := chainConn.GetBlock(blockHash)\n\tif err != nil {\n\t\treturn nil, TxNotFoundIndex,\n\t\t\tfmt.Errorf(\"unable to get block with hash %v for \"+\n\t\t\t\t\"historical dispatch: %v\", blockHash, err)\n\t}\n\n\t// In the modern chain (the only one we really care about for LN), the\n\t// coinbase transaction of all blocks will include the block height.\n\t// Therefore we can save another query, and just use that height\n\t// directly.\n\tblockHeight, err := blockchain.ExtractCoinbaseHeight(\n\t\tbtcutil.NewTx(block.Transactions[0]),\n\t)\n\tif err != nil {\n\t\treturn nil, TxNotFoundIndex, fmt.Errorf(\"unable to extract \"+\n\t\t\t\"coinbase height: %w\", err)\n\t}\n\n\t// If the block was obtained, locate the transaction's index within the\n\t// block so we can give the subscriber full confirmation details.\n\tfor txIndex, blockTx := range block.Transactions {\n\t\tif blockTx.TxHash() != r.TxID {\n\t\t\tcontinue\n\t\t}\n\n\t\treturn &TxConfirmation{\n\t\t\tTx:          &tx,\n\t\t\tBlockHash:   blockHash,\n\t\t\tBlockHeight: uint32(blockHeight),\n\t\t\tTxIndex:     uint32(txIndex),\n\t\t\tBlock:       block,\n\t\t}, TxFoundIndex, nil\n\t}\n\n\t// We return an error because we should have found the transaction\n\t// within the block, but didn't.\n\treturn nil, TxNotFoundIndex, fmt.Errorf(\"unable to locate \"+\n\t\t\"tx %v in block %v\", r.TxID, blockHash)\n}\n\n// SpendHintCache is an interface whose duty is to cache spend hints for\n// outpoints. A spend hint is defined as the earliest height in the chain at\n// which an outpoint could have been spent within.",
      "length": 3496,
      "tokens": 512,
      "embedding": []
    },
    {
      "slug": "type SpendHintCache interface {",
      "content": "type SpendHintCache interface {\n\t// CommitSpendHint commits a spend hint for the outpoints to the cache.\n\tCommitSpendHint(height uint32, spendRequests ...SpendRequest) error\n\n\t// QuerySpendHint returns the latest spend hint for an outpoint.\n\t// ErrSpendHintNotFound is returned if a spend hint does not exist\n\t// within the cache for the outpoint.\n\tQuerySpendHint(spendRequest SpendRequest) (uint32, error)\n\n\t// PurgeSpendHint removes the spend hint for the outpoints from the\n\t// cache.\n\tPurgeSpendHint(spendRequests ...SpendRequest) error\n}\n\n// ConfirmHintCache is an interface whose duty is to cache confirm hints for\n// transactions. A confirm hint is defined as the earliest height in the chain\n// at which a transaction could have been included in a block.",
      "length": 715,
      "tokens": 105,
      "embedding": []
    },
    {
      "slug": "type ConfirmHintCache interface {",
      "content": "type ConfirmHintCache interface {\n\t// CommitConfirmHint commits a confirm hint for the transactions to the\n\t// cache.\n\tCommitConfirmHint(height uint32, confRequests ...ConfRequest) error\n\n\t// QueryConfirmHint returns the latest confirm hint for a transaction\n\t// hash. ErrConfirmHintNotFound is returned if a confirm hint does not\n\t// exist within the cache for the transaction hash.\n\tQueryConfirmHint(confRequest ConfRequest) (uint32, error)\n\n\t// PurgeConfirmHint removes the confirm hint for the transactions from\n\t// the cache.\n\tPurgeConfirmHint(confRequests ...ConfRequest) error\n}\n",
      "length": 539,
      "tokens": 69,
      "embedding": []
    }
  ]
}