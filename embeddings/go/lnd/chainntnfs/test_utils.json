{
  "filepath": "../implementations/go/lnd/chainntnfs/test_utils.go",
  "package": "chainntnfs",
  "sections": [
    {
      "slug": "//go:build dev",
      "content": "//go:build dev\n// +build dev\n\npackage chainntnfs\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/btcsuite/btcd/btcec/v2\"\n\t\"github.com/btcsuite/btcd/btcjson\"\n\t\"github.com/btcsuite/btcd/btcutil\"\n\t\"github.com/btcsuite/btcd/chaincfg\"\n\t\"github.com/btcsuite/btcd/chaincfg/chainhash\"\n\t\"github.com/btcsuite/btcd/integration/rpctest\"\n\t\"github.com/btcsuite/btcd/txscript\"\n\t\"github.com/btcsuite/btcd/wire\"\n\t\"github.com/btcsuite/btcwallet/chain\"\n\t\"github.com/btcsuite/btcwallet/walletdb\"\n\t\"github.com/lightninglabs/neutrino\"\n\t\"github.com/lightningnetwork/lnd/kvdb\"\n\t\"github.com/lightningnetwork/lnd/lntest/wait\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nvar (\n\t// TrickleInterval is the interval at which the miner should trickle\n\t// transactions to its peers. We'll set it small to ensure the miner\n\t// propagates transactions quickly in the tests.\n\tTrickleInterval = 10 * time.Millisecond\n)\n\nvar (\n\tNetParams = &chaincfg.RegressionNetParams\n)\n\n// randPubKeyHashScript generates a P2PKH script that pays to the public key of\n// a randomly-generated private key.",
      "length": 1047,
      "tokens": 92,
      "embedding": []
    },
    {
      "slug": "func randPubKeyHashScript() ([]byte, *btcec.PrivateKey, error) {",
      "content": "func randPubKeyHashScript() ([]byte, *btcec.PrivateKey, error) {\n\tprivKey, err := btcec.NewPrivateKey()\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpubKeyHash := btcutil.Hash160(privKey.PubKey().SerializeCompressed())\n\taddrScript, err := btcutil.NewAddressPubKeyHash(pubKeyHash, NetParams)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpkScript, err := txscript.PayToAddrScript(addrScript)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn pkScript, privKey, nil\n}\n\n// GetTestTxidAndScript generate a new test transaction and returns its txid and\n// the script of the output being generated.",
      "length": 508,
      "tokens": 71,
      "embedding": []
    },
    {
      "slug": "func GetTestTxidAndScript(h *rpctest.Harness) (*chainhash.Hash, []byte, error) {",
      "content": "func GetTestTxidAndScript(h *rpctest.Harness) (*chainhash.Hash, []byte, error) {\n\tpkScript, _, err := randPubKeyHashScript()\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"unable to generate pkScript: %v\", err)\n\t}\n\toutput := &wire.TxOut{Value: 2e8, PkScript: pkScript}\n\ttxid, err := h.SendOutputs([]*wire.TxOut{output}, 10)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn txid, pkScript, nil\n}\n\n// WaitForMempoolTx waits for the txid to be seen in the miner's mempool.",
      "length": 379,
      "tokens": 59,
      "embedding": []
    },
    {
      "slug": "func WaitForMempoolTx(miner *rpctest.Harness, txid *chainhash.Hash) error {",
      "content": "func WaitForMempoolTx(miner *rpctest.Harness, txid *chainhash.Hash) error {\n\ttimeout := time.After(10 * time.Second)\n\ttrickle := time.After(2 * TrickleInterval)\n\tfor {\n\t\t// Check for the harness' knowledge of the txid.\n\t\ttx, err := miner.Client.GetRawTransaction(txid)\n\t\tif err != nil {\n\t\t\tjsonErr, ok := err.(*btcjson.RPCError)\n\t\t\tif ok && jsonErr.Code == btcjson.ErrRPCNoTxInfo {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\tif tx != nil && tx.Hash().IsEqual(txid) {\n\t\t\tbreak\n\t\t}\n\n\t\tselect {\n\t\tcase <-time.After(100 * time.Millisecond):\n\t\tcase <-timeout:\n\t\t\treturn errors.New(\"timed out waiting for tx\")\n\t\t}\n\t}\n\n\t// To ensure any transactions propagate from the miner to the peers\n\t// before returning, ensure we have waited for at least\n\t// 2*trickleInterval before returning.\n\tselect {\n\tcase <-trickle:\n\tcase <-timeout:\n\t\treturn errors.New(\"timeout waiting for trickle interval. \" +\n\t\t\t\"Trickle interval to large?\")\n\t}\n\n\treturn nil\n}\n\n// CreateSpendableOutput creates and returns an output that can be spent later\n// on.",
      "length": 904,
      "tokens": 133,
      "embedding": []
    },
    {
      "slug": "func CreateSpendableOutput(t *testing.T,",
      "content": "func CreateSpendableOutput(t *testing.T,\n\tminer *rpctest.Harness) (*wire.OutPoint, *wire.TxOut, *btcec.PrivateKey) {\n\n\tt.Helper()\n\n\t// Create a transaction that only has one output, the one destined for\n\t// the recipient.\n\tpkScript, privKey, err := randPubKeyHashScript()\n\trequire.NoError(t, err, \"unable to generate pkScript\")\n\toutput := &wire.TxOut{Value: 2e8, PkScript: pkScript}\n\ttxid, err := miner.SendOutputsWithoutChange([]*wire.TxOut{output}, 10)\n\trequire.NoError(t, err, \"unable to create tx\")\n\n\t// Mine the transaction to mark the output as spendable.\n\tif err := WaitForMempoolTx(miner, txid); err != nil {\n\t\tt.Fatalf(\"tx not relayed to miner: %v\", err)\n\t}\n\tif _, err := miner.Client.Generate(1); err != nil {\n\t\tt.Fatalf(\"unable to generate single block: %v\", err)\n\t}\n\n\treturn wire.NewOutPoint(txid, 0), output, privKey\n}\n\n// CreateSpendTx creates a transaction spending the specified output.",
      "length": 838,
      "tokens": 110,
      "embedding": []
    },
    {
      "slug": "func CreateSpendTx(t *testing.T, prevOutPoint *wire.OutPoint,",
      "content": "func CreateSpendTx(t *testing.T, prevOutPoint *wire.OutPoint,\n\tprevOutput *wire.TxOut, privKey *btcec.PrivateKey) *wire.MsgTx {\n\n\tt.Helper()\n\n\tspendingTx := wire.NewMsgTx(1)\n\tspendingTx.AddTxIn(&wire.TxIn{PreviousOutPoint: *prevOutPoint})\n\tspendingTx.AddTxOut(&wire.TxOut{Value: 1e8, PkScript: prevOutput.PkScript})\n\n\tsigScript, err := txscript.SignatureScript(\n\t\tspendingTx, 0, prevOutput.PkScript, txscript.SigHashAll,\n\t\tprivKey, true,\n\t)\n\trequire.NoError(t, err, \"unable to sign tx\")\n\tspendingTx.TxIn[0].SignatureScript = sigScript\n\n\treturn spendingTx\n}\n\n// NewMiner spawns testing harness backed by a btcd node that can serve as a\n// miner.",
      "length": 563,
      "tokens": 56,
      "embedding": []
    },
    {
      "slug": "func NewMiner(t *testing.T, extraArgs []string, createChain bool,",
      "content": "func NewMiner(t *testing.T, extraArgs []string, createChain bool,\n\tspendableOutputs uint32) *rpctest.Harness {\n\n\tt.Helper()\n\n\t// Add the trickle interval argument to the extra args.\n\ttrickle := fmt.Sprintf(\"--trickleinterval=%v\", TrickleInterval)\n\textraArgs = append(extraArgs, trickle)\n\n\tnode, err := rpctest.New(NetParams, nil, extraArgs, \"\")\n\trequire.NoError(t, err, \"unable to create backend node\")\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, node.TearDown())\n\t})\n\n\tif err := node.SetUp(createChain, spendableOutputs); err != nil {\n\t\tt.Fatalf(\"unable to set up backend node: %v\", err)\n\t}\n\n\treturn node\n}\n\n// NewBitcoindBackend spawns a new bitcoind node that connects to a miner at the\n// specified address. The txindex boolean can be set to determine whether the\n// backend node should maintain a transaction index. The rpcpolling boolean\n// can be set to determine whether bitcoind's RPC polling interface should be\n// used for block and tx notifications or if its ZMQ interface should be used.\n// A connection to the newly spawned bitcoind node is returned.",
      "length": 969,
      "tokens": 140,
      "embedding": []
    },
    {
      "slug": "func NewBitcoindBackend(t *testing.T, minerAddr string, txindex,",
      "content": "func NewBitcoindBackend(t *testing.T, minerAddr string, txindex,\n\trpcpolling bool) *chain.BitcoindConn {\n\n\tt.Helper()\n\n\ttempBitcoindDir := t.TempDir()\n\n\trpcPort := rand.Intn(65536-1024) + 1024\n\tzmqBlockHost := \"ipc:///\" + tempBitcoindDir + \"/blocks.socket\"\n\tzmqTxHost := \"ipc:///\" + tempBitcoindDir + \"/tx.socket\"\n\n\targs := []string{\n\t\t\"-connect=\" + minerAddr,\n\t\t\"-datadir=\" + tempBitcoindDir,\n\t\t\"-regtest\",\n\t\t\"-rpcauth=weks:469e9bb14ab2360f8e226efed5ca6fd$507c670e800a952\" +\n\t\t\t\"84294edb5773b05544b220110063096c221be9933c82d38e1\",\n\t\tfmt.Sprintf(\"-rpcport=%d\", rpcPort),\n\t\t\"-disablewallet\",\n\t\t\"-zmqpubrawblock=\" + zmqBlockHost,\n\t\t\"-zmqpubrawtx=\" + zmqTxHost,\n\t}\n\tif txindex {\n\t\targs = append(args, \"-txindex\")\n\t}\n\n\tbitcoind := exec.Command(\"bitcoind\", args...)\n\tif err := bitcoind.Start(); err != nil {\n\t\tt.Fatalf(\"unable to start bitcoind: %v\", err)\n\t}\n\tt.Cleanup(func() {\n\t\t_ = bitcoind.Process.Kill()\n\t\t_ = bitcoind.Wait()\n\t})\n\n\t// Wait for the bitcoind instance to start up.\n\thost := fmt.Sprintf(\"127.0.0.1:%d\", rpcPort)\n\tcfg := &chain.BitcoindConfig{\n\t\tChainParams: NetParams,\n\t\tHost:        host,\n\t\tUser:        \"weks\",\n\t\tPass:        \"weks\",\n\t\t// Fields only required for pruned nodes, not needed for these\n\t\t// tests.\n\t\tDialer:             nil,\n\t\tPrunedModeMaxPeers: 0,\n\t}\n\n\tif rpcpolling {\n\t\tcfg.ZMQConfig = &chain.ZMQConfig{\n\t\t\tZMQBlockHost:    zmqBlockHost,\n\t\t\tZMQTxHost:       zmqTxHost,\n\t\t\tZMQReadDeadline: 5 * time.Second,\n\t\t}\n\t} else {\n\t\tcfg.PollingConfig = &chain.PollingConfig{\n\t\t\tBlockPollingInterval: time.Millisecond * 20,\n\t\t\tTxPollingInterval:    time.Millisecond * 20,\n\t\t}\n\t}\n\n\tvar conn *chain.BitcoindConn\n\terr := wait.NoError(func() error {\n\t\tvar err error\n\t\tconn, err = chain.NewBitcoindConn(cfg)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn conn.Start()\n\t}, 10*time.Second)\n\tif err != nil {\n\t\tt.Fatalf(\"unable to establish connection to bitcoind: %v\", err)\n\t}\n\tt.Cleanup(conn.Stop)\n\n\treturn conn\n}\n\n// NewNeutrinoBackend spawns a new neutrino node that connects to a miner at\n// the specified address.",
      "length": 1884,
      "tokens": 221,
      "embedding": []
    },
    {
      "slug": "func NewNeutrinoBackend(t *testing.T, minerAddr string) *neutrino.ChainService {",
      "content": "func NewNeutrinoBackend(t *testing.T, minerAddr string) *neutrino.ChainService {\n\tt.Helper()\n\n\tspvDir := t.TempDir()\n\n\tdbName := filepath.Join(spvDir, \"neutrino.db\")\n\tspvDatabase, err := walletdb.Create(\n\t\t\"bdb\", dbName, true, kvdb.DefaultDBTimeout,\n\t)\n\tif err != nil {\n\t\tt.Fatalf(\"unable to create walletdb: %v\", err)\n\t}\n\tt.Cleanup(func() {\n\t\tspvDatabase.Close()\n\t})\n\n\t// Create an instance of neutrino connected to the running btcd\n\t// instance.\n\tspvConfig := neutrino.Config{\n\t\tDataDir:      spvDir,\n\t\tDatabase:     spvDatabase,\n\t\tChainParams:  *NetParams,\n\t\tConnectPeers: []string{minerAddr},\n\t}\n\tspvNode, err := neutrino.NewChainService(spvConfig)\n\tif err != nil {\n\t\tt.Fatalf(\"unable to create neutrino: %v\", err)\n\t}\n\n\t// We'll also wait for the instance to sync up fully to the chain\n\t// generated by the btcd instance.\n\tspvNode.Start()\n\tfor !spvNode.IsCurrent() {\n\t\ttime.Sleep(time.Millisecond * 100)\n\t}\n\tt.Cleanup(func() {\n\t\tspvNode.Stop()\n\t})\n\n\treturn spvNode\n}\n",
      "length": 850,
      "tokens": 109,
      "embedding": []
    }
  ]
}