{
  "filepath": "../implementations/go/lnd/brontide/noise_test.go",
  "package": "brontide",
  "sections": [
    {
      "slug": "type maybeNetConn struct {",
      "content": "type maybeNetConn struct {\n\tconn net.Conn\n\terr  error\n}\n",
      "length": 26,
      "tokens": 5,
      "embedding": []
    },
    {
      "slug": "func makeListener() (*Listener, *lnwire.NetAddress, error) {",
      "content": "func makeListener() (*Listener, *lnwire.NetAddress, error) {\n\t// First, generate the long-term private keys for the brontide listener.\n\tlocalPriv, err := btcec.NewPrivateKey()\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tlocalKeyECDH := &keychain.PrivKeyECDH{PrivKey: localPriv}\n\n\t// Having a port of \":0\" means a random port, and interface will be\n\t// chosen for our listener.\n\taddr := \"localhost:0\"\n\n\t// Our listener will be local, and the connection remote.\n\tlistener, err := NewListener(localKeyECDH, addr)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tnetAddr := &lnwire.NetAddress{\n\t\tIdentityKey: localPriv.PubKey(),\n\t\tAddress:     listener.Addr().(*net.TCPAddr),\n\t}\n\n\treturn listener, netAddr, nil\n}\n",
      "length": 620,
      "tokens": 89,
      "embedding": []
    },
    {
      "slug": "func establishTestConnection(t testing.TB) (net.Conn, net.Conn, error) {",
      "content": "func establishTestConnection(t testing.TB) (net.Conn, net.Conn, error) {\n\tlistener, netAddr, err := makeListener()\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tt.Cleanup(func() {\n\t\tlistener.Close()\n\t})\n\n\t// Nos, generate the long-term private keys remote end of the connection\n\t// within our test.\n\tremotePriv, err := btcec.NewPrivateKey()\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tremoteKeyECDH := &keychain.PrivKeyECDH{PrivKey: remotePriv}\n\n\t// Initiate a connection with a separate goroutine, and listen with our\n\t// main one. If both errors are nil, then encryption+auth was\n\t// successful.\n\tremoteConnChan := make(chan maybeNetConn, 1)\n\tgo func() {\n\t\tremoteConn, err := Dial(\n\t\t\tremoteKeyECDH, netAddr,\n\t\t\ttor.DefaultConnTimeout, net.DialTimeout,\n\t\t)\n\t\tremoteConnChan <- maybeNetConn{remoteConn, err}\n\t}()\n\n\tlocalConnChan := make(chan maybeNetConn, 1)\n\tgo func() {\n\t\tlocalConn, err := listener.Accept()\n\t\tlocalConnChan <- maybeNetConn{localConn, err}\n\t}()\n\n\tremote := <-remoteConnChan\n\tif remote.err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tlocal := <-localConnChan\n\tif local.err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tt.Cleanup(func() {\n\t\tlocal.conn.Close()\n\t\tremote.conn.Close()\n\t})\n\n\treturn local.conn, remote.conn, nil\n}\n",
      "length": 1101,
      "tokens": 153,
      "embedding": []
    },
    {
      "slug": "func TestConnectionCorrectness(t *testing.T) {",
      "content": "func TestConnectionCorrectness(t *testing.T) {\n\t// Create a test connection, grabbing either side of the connection\n\t// into local variables. If the initial crypto handshake fails, then\n\t// we'll get a non-nil error here.\n\tlocalConn, remoteConn, err := establishTestConnection(t)\n\trequire.NoError(t, err, \"unable to establish test connection\")\n\n\t// Test out some message full-message reads.\n\tfor i := 0; i < 10; i++ {\n\t\tmsg := []byte(fmt.Sprintf(\"hello%d\", i))\n\n\t\tif _, err := localConn.Write(msg); err != nil {\n\t\t\tt.Fatalf(\"remote conn failed to write: %v\", err)\n\t\t}\n\n\t\treadBuf := make([]byte, len(msg))\n\t\tif _, err := remoteConn.Read(readBuf); err != nil {\n\t\t\tt.Fatalf(\"local conn failed to read: %v\", err)\n\t\t}\n\n\t\tif !bytes.Equal(readBuf, msg) {\n\t\t\tt.Fatalf(\"messages don't match, %v vs %v\",\n\t\t\t\tstring(readBuf), string(msg))\n\t\t}\n\t}\n\n\t// Now try incremental message reads. This simulates first writing a\n\t// message header, then a message body.\n\toutMsg := []byte(\"hello world\")\n\tif _, err := localConn.Write(outMsg); err != nil {\n\t\tt.Fatalf(\"remote conn failed to write: %v\", err)\n\t}\n\n\treadBuf := make([]byte, len(outMsg))\n\tif _, err := remoteConn.Read(readBuf[:len(outMsg)/2]); err != nil {\n\t\tt.Fatalf(\"local conn failed to read: %v\", err)\n\t}\n\tif _, err := remoteConn.Read(readBuf[len(outMsg)/2:]); err != nil {\n\t\tt.Fatalf(\"local conn failed to read: %v\", err)\n\t}\n\n\tif !bytes.Equal(outMsg, readBuf) {\n\t\tt.Fatalf(\"messages don't match, %v vs %v\",\n\t\t\tstring(readBuf), string(outMsg))\n\t}\n}\n\n// TestConecurrentHandshakes verifies the listener's ability to not be blocked\n// by other pending handshakes. This is tested by opening multiple tcp\n// connections with the listener, without completing any of the brontide acts.\n// The test passes if real brontide dialer connects while the others are\n// stalled.",
      "length": 1707,
      "tokens": 253,
      "embedding": []
    },
    {
      "slug": "func TestConcurrentHandshakes(t *testing.T) {",
      "content": "func TestConcurrentHandshakes(t *testing.T) {\n\tlistener, netAddr, err := makeListener()\n\trequire.NoError(t, err, \"unable to create listener connection\")\n\tdefer listener.Close()\n\n\tconst nblocking = 5\n\n\t// Open a handful of tcp connections, that do not complete any steps of\n\t// the brontide handshake.\n\tconnChan := make(chan maybeNetConn)\n\tfor i := 0; i < nblocking; i++ {\n\t\tgo func() {\n\t\t\tconn, err := net.Dial(\"tcp\", listener.Addr().String())\n\t\t\tconnChan <- maybeNetConn{conn, err}\n\t\t}()\n\t}\n\n\t// Receive all connections/errors from our blocking tcp dials. We make a\n\t// pass to gather all connections and errors to make sure we defer the\n\t// calls to Close() on all successful connections.\n\ttcpErrs := make([]error, 0, nblocking)\n\tfor i := 0; i < nblocking; i++ {\n\t\tresult := <-connChan\n\t\tif result.conn != nil {\n\t\t\tdefer result.conn.Close()\n\t\t}\n\t\tif result.err != nil {\n\t\t\ttcpErrs = append(tcpErrs, result.err)\n\t\t}\n\t}\n\tfor _, tcpErr := range tcpErrs {\n\t\tif tcpErr != nil {\n\t\t\tt.Fatalf(\"unable to tcp dial listener: %v\", tcpErr)\n\t\t}\n\t}\n\n\t// Now, construct a new private key and use the brontide dialer to\n\t// connect to the listener.\n\tremotePriv, err := btcec.NewPrivateKey()\n\trequire.NoError(t, err, \"unable to generate private key\")\n\tremoteKeyECDH := &keychain.PrivKeyECDH{PrivKey: remotePriv}\n\n\tgo func() {\n\t\tremoteConn, err := Dial(\n\t\t\tremoteKeyECDH, netAddr,\n\t\t\ttor.DefaultConnTimeout, net.DialTimeout,\n\t\t)\n\t\tconnChan <- maybeNetConn{remoteConn, err}\n\t}()\n\n\t// This connection should be accepted without error, as the brontide\n\t// connection should bypass stalled tcp connections.\n\tconn, err := listener.Accept()\n\trequire.NoError(t, err, \"unable to accept dial\")\n\tdefer conn.Close()\n\n\tresult := <-connChan\n\tif result.err != nil {\n\t\tt.Fatalf(\"unable to dial %v: %v\", netAddr, result.err)\n\t}\n\tresult.conn.Close()\n}\n",
      "length": 1712,
      "tokens": 252,
      "embedding": []
    },
    {
      "slug": "func TestMaxPayloadLength(t *testing.T) {",
      "content": "func TestMaxPayloadLength(t *testing.T) {\n\tt.Parallel()\n\n\tb := Machine{}\n\tb.split()\n\n\t// Create a payload that's only *slightly* above the maximum allotted\n\t// payload length.\n\tpayloadToReject := make([]byte, math.MaxUint16+1)\n\n\t// A write of the payload generated above to the state machine should\n\t// be rejected as it's over the max payload length.\n\terr := b.WriteMessage(payloadToReject)\n\tif err != ErrMaxMessageLengthExceeded {\n\t\tt.Fatalf(\"payload is over the max allowed length, the write \" +\n\t\t\t\"should have been rejected\")\n\t}\n\n\t// Generate another payload which should be accepted as a valid\n\t// payload.\n\tpayloadToAccept := make([]byte, math.MaxUint16-1)\n\tif err := b.WriteMessage(payloadToAccept); err != nil {\n\t\tt.Fatalf(\"write for payload was rejected, should have been \" +\n\t\t\t\"accepted\")\n\t}\n\n\t// Generate a final payload which is only *slightly* above the max payload length\n\t// when the MAC is accounted for.\n\tpayloadToReject = make([]byte, math.MaxUint16+1)\n\n\t// This payload should be rejected.\n\terr = b.WriteMessage(payloadToReject)\n\tif err != ErrMaxMessageLengthExceeded {\n\t\tt.Fatalf(\"payload is over the max allowed length, the write \" +\n\t\t\t\"should have been rejected\")\n\t}\n}\n",
      "length": 1116,
      "tokens": 163,
      "embedding": []
    },
    {
      "slug": "func TestWriteMessageChunking(t *testing.T) {",
      "content": "func TestWriteMessageChunking(t *testing.T) {\n\t// Create a test connection, grabbing either side of the connection\n\t// into local variables. If the initial crypto handshake fails, then\n\t// we'll get a non-nil error here.\n\tlocalConn, remoteConn, err := establishTestConnection(t)\n\trequire.NoError(t, err, \"unable to establish test connection\")\n\n\t// Attempt to write a message which is over 3x the max allowed payload\n\t// size.\n\tlargeMessage := bytes.Repeat([]byte(\"kek\"), math.MaxUint16*3)\n\n\t// Launch a new goroutine to write the large message generated above in\n\t// chunks. We spawn a new goroutine because otherwise, we may block as\n\t// the kernel waits for the buffer to flush.\n\terrCh := make(chan error)\n\tgo func() {\n\t\tdefer close(errCh)\n\n\t\tbytesWritten, err := localConn.Write(largeMessage)\n\t\tif err != nil {\n\t\t\terrCh <- fmt.Errorf(\"unable to write message: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\t// The entire message should have been written out to the remote\n\t\t// connection.\n\t\tif bytesWritten != len(largeMessage) {\n\t\t\terrCh <- fmt.Errorf(\"bytes not fully written\")\n\t\t\treturn\n\t\t}\n\t}()\n\n\t// Attempt to read the entirety of the message generated above.\n\tbuf := make([]byte, len(largeMessage))\n\tif _, err := io.ReadFull(remoteConn, buf); err != nil {\n\t\tt.Fatalf(\"unable to read message: %v\", err)\n\t}\n\n\terr = <-errCh\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Finally, the message the remote end of the connection received\n\t// should be identical to what we sent from the local connection.\n\tif !bytes.Equal(buf, largeMessage) {\n\t\tt.Fatalf(\"bytes don't match\")\n\t}\n}\n\n// TestBolt0008TestVectors ensures that our implementation of brontide exactly\n// matches the test vectors within the specification.",
      "length": 1592,
      "tokens": 243,
      "embedding": []
    },
    {
      "slug": "func TestBolt0008TestVectors(t *testing.T) {",
      "content": "func TestBolt0008TestVectors(t *testing.T) {\n\tt.Parallel()\n\n\t// First, we'll generate the state of the initiator from the test\n\t// vectors at the appendix of BOLT-0008\n\tinitiatorKeyBytes, err := hex.DecodeString(\"1111111111111111111111\" +\n\t\t\"111111111111111111111111111111111111111111\")\n\trequire.NoError(t, err, \"unable to decode hex\")\n\tinitiatorPriv, _ := btcec.PrivKeyFromBytes(\n\t\tinitiatorKeyBytes,\n\t)\n\tinitiatorKeyECDH := &keychain.PrivKeyECDH{PrivKey: initiatorPriv}\n\n\t// We'll then do the same for the responder.\n\tresponderKeyBytes, err := hex.DecodeString(\"212121212121212121212121\" +\n\t\t\"2121212121212121212121212121212121212121\")\n\trequire.NoError(t, err, \"unable to decode hex\")\n\tresponderPriv, responderPub := btcec.PrivKeyFromBytes(\n\t\tresponderKeyBytes,\n\t)\n\tresponderKeyECDH := &keychain.PrivKeyECDH{PrivKey: responderPriv}\n\n\t// With the initiator's key data parsed, we'll now define a custom\n\t// EphemeralGenerator function for the state machine to ensure that the\n\t// initiator and responder both generate the ephemeral public key\n\t// defined within the test vectors.\n\tinitiatorEphemeral := EphemeralGenerator(func() (*btcec.PrivateKey, error) {\n\t\te := \"121212121212121212121212121212121212121212121212121212\" +\n\t\t\t\"1212121212\"\n\t\teBytes, err := hex.DecodeString(e)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpriv, _ := btcec.PrivKeyFromBytes(eBytes)\n\t\treturn priv, nil\n\t})\n\tresponderEphemeral := EphemeralGenerator(func() (*btcec.PrivateKey, error) {\n\t\te := \"222222222222222222222222222222222222222222222222222\" +\n\t\t\t\"2222222222222\"\n\t\teBytes, err := hex.DecodeString(e)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpriv, _ := btcec.PrivKeyFromBytes(eBytes)\n\t\treturn priv, nil\n\t})\n\n\t// Finally, we'll create both brontide state machines, so we can begin\n\t// our test.\n\tinitiator := NewBrontideMachine(\n\t\ttrue, initiatorKeyECDH, responderPub, initiatorEphemeral,\n\t)\n\tresponder := NewBrontideMachine(\n\t\tfalse, responderKeyECDH, nil, responderEphemeral,\n\t)\n\n\t// We'll start with the initiator generating the initial payload for\n\t// act one. This should consist of exactly 50 bytes. We'll assert that\n\t// the payload return is _exactly_ the same as what's specified within\n\t// the test vectors.\n\tactOne, err := initiator.GenActOne()\n\trequire.NoError(t, err, \"unable to generate act one\")\n\texpectedActOne, err := hex.DecodeString(\"00036360e856310ce5d294e\" +\n\t\t\"8be33fc807077dc56ac80d95d9cd4ddbd21325eff73f70df608655115\" +\n\t\t\"1f58b8afe6c195782c6a\")\n\trequire.NoError(t, err, \"unable to parse expected act one\")\n\tif !bytes.Equal(expectedActOne, actOne[:]) {\n\t\tt.Fatalf(\"act one mismatch: expected %x, got %x\",\n\t\t\texpectedActOne, actOne)\n\t}\n\n\t// With the assertion above passed, we'll now process the act one\n\t// payload with the responder of the crypto handshake.\n\tif err := responder.RecvActOne(actOne); err != nil {\n\t\tt.Fatalf(\"responder unable to process act one: %v\", err)\n\t}\n\n\t// Next, we'll start the second act by having the responder generate\n\t// its contribution to the crypto handshake. We'll also verify that we\n\t// produce the _exact_ same byte stream as advertised within the spec's\n\t// test vectors.\n\tactTwo, err := responder.GenActTwo()\n\trequire.NoError(t, err, \"unable to generate act two\")\n\texpectedActTwo, err := hex.DecodeString(\"0002466d7fcae563e5cb09a0\" +\n\t\t\"d1870bb580344804617879a14949cf22285f1bae3f276e2470b93aac58\" +\n\t\t\"3c9ef6eafca3f730ae\")\n\trequire.NoError(t, err, \"unable to parse expected act two\")\n\tif !bytes.Equal(expectedActTwo, actTwo[:]) {\n\t\tt.Fatalf(\"act two mismatch: expected %x, got %x\",\n\t\t\texpectedActTwo, actTwo)\n\t}\n\n\t// Moving the handshake along, we'll also ensure that the initiator\n\t// accepts the act two payload.\n\tif err := initiator.RecvActTwo(actTwo); err != nil {\n\t\tt.Fatalf(\"initiator unable to process act two: %v\", err)\n\t}\n\n\t// At the final step, we'll generate the last act from the initiator\n\t// and once again verify that it properly matches the test vectors.\n\tactThree, err := initiator.GenActThree()\n\trequire.NoError(t, err, \"unable to generate act three\")\n\texpectedActThree, err := hex.DecodeString(\"00b9e3a702e93e3a9948c2e\" +\n\t\t\"d6e5fd7590a6e1c3a0344cfc9d5b57357049aa22355361aa02e55a8f\" +\n\t\t\"c28fef5bd6d71ad0c38228dc68b1c466263b47fdf31e560e139ba\")\n\trequire.NoError(t, err, \"unable to parse expected act three\")\n\tif !bytes.Equal(expectedActThree, actThree[:]) {\n\t\tt.Fatalf(\"act three mismatch: expected %x, got %x\",\n\t\t\texpectedActThree, actThree)\n\t}\n\n\t// Finally, we'll ensure that the responder itself also properly parses\n\t// the last payload in the crypto handshake.\n\tif err := responder.RecvActThree(actThree); err != nil {\n\t\tt.Fatalf(\"responder unable to process act three: %v\", err)\n\t}\n\n\t// As a final assertion, we'll ensure that both sides have derived the\n\t// proper symmetric encryption keys.\n\tsendingKey, err := hex.DecodeString(\"969ab31b4d288cedf6218839b27a3e2\" +\n\t\t\"140827047f2c0f01bf5c04435d43511a9\")\n\trequire.NoError(t, err, \"unable to parse sending key\")\n\trecvKey, err := hex.DecodeString(\"bb9020b8965f4df047e07f955f3c4b884\" +\n\t\t\"18984aadc5cdb35096b9ea8fa5c3442\")\n\trequire.NoError(t, err, \"unable to parse receiving key\")\n\n\tchainKey, err := hex.DecodeString(\"919219dbb2920afa8db80f9a51787a840\" +\n\t\t\"bcf111ed8d588caf9ab4be716e42b01\")\n\trequire.NoError(t, err, \"unable to parse chaining key\")\n\n\tif !bytes.Equal(initiator.sendCipher.secretKey[:], sendingKey) {\n\t\tt.Fatalf(\"sending key mismatch: expected %x, got %x\",\n\t\t\tinitiator.sendCipher.secretKey[:], sendingKey)\n\t}\n\tif !bytes.Equal(initiator.recvCipher.secretKey[:], recvKey) {\n\t\tt.Fatalf(\"receiving key mismatch: expected %x, got %x\",\n\t\t\tinitiator.recvCipher.secretKey[:], recvKey)\n\t}\n\tif !bytes.Equal(initiator.chainingKey[:], chainKey) {\n\t\tt.Fatalf(\"chaining key mismatch: expected %x, got %x\",\n\t\t\tinitiator.chainingKey[:], chainKey)\n\t}\n\n\tif !bytes.Equal(responder.sendCipher.secretKey[:], recvKey) {\n\t\tt.Fatalf(\"sending key mismatch: expected %x, got %x\",\n\t\t\tresponder.sendCipher.secretKey[:], recvKey)\n\t}\n\tif !bytes.Equal(responder.recvCipher.secretKey[:], sendingKey) {\n\t\tt.Fatalf(\"receiving key mismatch: expected %x, got %x\",\n\t\t\tresponder.recvCipher.secretKey[:], sendingKey)\n\t}\n\tif !bytes.Equal(responder.chainingKey[:], chainKey) {\n\t\tt.Fatalf(\"chaining key mismatch: expected %x, got %x\",\n\t\t\tresponder.chainingKey[:], chainKey)\n\t}\n\n\t// Now test as per section \"transport-message test\" in Test Vectors\n\t// (the transportMessageVectors ciphertexts are from this section of BOLT 8);\n\t// we do slightly greater than 1000 encryption/decryption operations\n\t// to ensure that the key rotation algorithm is operating as expected.\n\t// The starting point for enc/decr is already guaranteed correct from the\n\t// above tests of sendingKey, receivingKey, chainingKey.\n\ttransportMessageVectors := map[int]string{\n\t\t0: \"cf2b30ddf0cf3f80e7c35a6e6730b59fe802473180f396d88a8fb0db8cb\" +\n\t\t\t\"cf25d2f214cf9ea1d95\",\n\t\t1: \"72887022101f0b6753e0c7de21657d35a4cb2a1f5cde2650528bbc8f837\" +\n\t\t\t\"d0f0d7ad833b1a256a1\",\n\t\t500: \"178cb9d7387190fa34db9c2d50027d21793c9bc2d40b1e14dcf30ebeeeb2\" +\n\t\t\t\"20f48364f7a4c68bf8\",\n\t\t501: \"1b186c57d44eb6de4c057c49940d79bb838a145cb528d6e8fd26dbe50a6\" +\n\t\t\t\"0ca2c104b56b60e45bd\",\n\t\t1000: \"4a2f3cc3b5e78ddb83dcb426d9863d9d9a723b0337c89dd0b005d89f8d3\" +\n\t\t\t\"c05c52b76b29b740f09\",\n\t\t1001: \"2ecd8c8a5629d0d02ab457a0fdd0f7b90a192cd46be5ecb6ca570bfc5e2\" +\n\t\t\t\"68338b1a16cf4ef2d36\",\n\t}\n\n\t// Payload for every message is the string \"hello\".\n\tpayload := []byte(\"hello\")\n\n\tvar buf bytes.Buffer\n\n\tfor i := 0; i < 1002; i++ {\n\t\terr = initiator.WriteMessage(payload)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"could not write message %s\", payload)\n\t\t}\n\t\t_, err = initiator.Flush(&buf)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"could not flush message: %v\", err)\n\t\t}\n\t\tif val, ok := transportMessageVectors[i]; ok {\n\t\t\tbinaryVal, err := hex.DecodeString(val)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Failed to decode hex string %s\", val)\n\t\t\t}\n\t\t\tif !bytes.Equal(buf.Bytes(), binaryVal) {\n\t\t\t\tt.Fatalf(\"Ciphertext %x was not equal to expected %s\",\n\t\t\t\t\tbuf.String()[:], val)\n\t\t\t}\n\t\t}\n\n\t\t// Responder decrypts the bytes, in every iteration, and\n\t\t// should always be able to decrypt the same payload message.\n\t\tplaintext, err := responder.ReadMessage(&buf)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to read message in responder: %v\", err)\n\t\t}\n\n\t\t// Ensure decryption succeeded\n\t\tif !bytes.Equal(plaintext, payload) {\n\t\t\tt.Fatalf(\"Decryption failed to receive plaintext: %s, got %s\",\n\t\t\t\tpayload, plaintext)\n\t\t}\n\n\t\t// Clear out the buffer for the next iteration\n\t\tbuf.Reset()\n\t}\n}\n\n// timeoutWriter wraps an io.Writer and throws an iotest.ErrTimeout after\n// writing n bytes.",
      "length": 8296,
      "tokens": 951,
      "embedding": []
    },
    {
      "slug": "type timeoutWriter struct {",
      "content": "type timeoutWriter struct {\n\tw io.Writer\n\tn int64\n}\n",
      "length": 21,
      "tokens": 5,
      "embedding": []
    },
    {
      "slug": "func NewTimeoutWriter(w io.Writer, n int64) io.Writer {",
      "content": "func NewTimeoutWriter(w io.Writer, n int64) io.Writer {\n\treturn &timeoutWriter{w, n}\n}\n",
      "length": 29,
      "tokens": 4,
      "embedding": []
    },
    {
      "slug": "func (t *timeoutWriter) Write(p []byte) (int, error) {",
      "content": "func (t *timeoutWriter) Write(p []byte) (int, error) {\n\tn := len(p)\n\tif int64(n) > t.n {\n\t\tn = int(t.n)\n\t}\n\tn, err := t.w.Write(p[:n])\n\tt.n -= int64(n)\n\tif err == nil && t.n == 0 {\n\t\treturn n, iotest.ErrTimeout\n\t}\n\treturn n, err\n}\n\nconst payloadSize = 10\n",
      "length": 187,
      "tokens": 40,
      "embedding": []
    },
    {
      "slug": "type flushChunk struct {",
      "content": "type flushChunk struct {\n\terrAfter int64\n\texpN     int\n\texpErr   error\n}\n",
      "length": 44,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "type flushTest struct {",
      "content": "type flushTest struct {\n\tname   string\n\tchunks []flushChunk\n}\n\nvar flushTests = []flushTest{\n\t{\n\t\tname: \"partial header write\",\n\t\tchunks: []flushChunk{\n\t\t\t// Write 18-byte header in two parts, 16 then 2.\n\t\t\t{\n\t\t\t\terrAfter: encHeaderSize - 2,\n\t\t\t\texpN:     0,\n\t\t\t\texpErr:   iotest.ErrTimeout,\n\t\t\t},\n\t\t\t{\n\t\t\t\terrAfter: 2,\n\t\t\t\texpN:     0,\n\t\t\t\texpErr:   iotest.ErrTimeout,\n\t\t\t},\n\t\t\t// Write payload and MAC in one go.\n\t\t\t{\n\t\t\t\terrAfter: -1,\n\t\t\t\texpN:     payloadSize,\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\tname: \"full payload then full mac\",\n\t\tchunks: []flushChunk{\n\t\t\t// Write entire header and entire payload w/o MAC.\n\t\t\t{\n\t\t\t\terrAfter: encHeaderSize + payloadSize,\n\t\t\t\texpN:     payloadSize,\n\t\t\t\texpErr:   iotest.ErrTimeout,\n\t\t\t},\n\t\t\t// Write the entire MAC.\n\t\t\t{\n\t\t\t\terrAfter: -1,\n\t\t\t\texpN:     0,\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\tname: \"payload-only, straddle, mac-only\",\n\t\tchunks: []flushChunk{\n\t\t\t// Write header and all but last byte of payload.\n\t\t\t{\n\t\t\t\terrAfter: encHeaderSize + payloadSize - 1,\n\t\t\t\texpN:     payloadSize - 1,\n\t\t\t\texpErr:   iotest.ErrTimeout,\n\t\t\t},\n\t\t\t// Write last byte of payload and first byte of MAC.\n\t\t\t{\n\t\t\t\terrAfter: 2,\n\t\t\t\texpN:     1,\n\t\t\t\texpErr:   iotest.ErrTimeout,\n\t\t\t},\n\t\t\t// Write 10 bytes of the MAC.\n\t\t\t{\n\t\t\t\terrAfter: 10,\n\t\t\t\texpN:     0,\n\t\t\t\texpErr:   iotest.ErrTimeout,\n\t\t\t},\n\t\t\t// Write the remaining 5 MAC bytes.\n\t\t\t{\n\t\t\t\terrAfter: -1,\n\t\t\t\texpN:     0,\n\t\t\t},\n\t\t},\n\t},\n}\n\n// TestFlush asserts a Machine's ability to handle timeouts during Flush that\n// cause partial writes, and that the machine can properly resume writes on\n// subsequent calls to Flush.",
      "length": 1470,
      "tokens": 212,
      "embedding": []
    },
    {
      "slug": "func TestFlush(t *testing.T) {",
      "content": "func TestFlush(t *testing.T) {\n\t// Run each test individually, to assert that they pass in isolation.\n\tfor _, test := range flushTests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar (\n\t\t\t\tw bytes.Buffer\n\t\t\t\tb Machine\n\t\t\t)\n\t\t\tb.split()\n\t\t\ttestFlush(t, test, &b, &w)\n\t\t})\n\t}\n\n\t// Finally, run the tests serially as if all on one connection.\n\tt.Run(\"flush serial\", func(t *testing.T) {\n\t\tvar (\n\t\t\tw bytes.Buffer\n\t\t\tb Machine\n\t\t)\n\t\tb.split()\n\t\tfor _, test := range flushTests {\n\t\t\ttestFlush(t, test, &b, &w)\n\t\t}\n\t})\n}\n\n// testFlush buffers a message on the Machine, then flushes it to the io.Writer\n// in chunks. Once complete, a final call to flush is made to assert that Write\n// is not called again.",
      "length": 642,
      "tokens": 111,
      "embedding": []
    },
    {
      "slug": "func testFlush(t *testing.T, test flushTest, b *Machine, w io.Writer) {",
      "content": "func testFlush(t *testing.T, test flushTest, b *Machine, w io.Writer) {\n\tpayload := make([]byte, payloadSize)\n\tif err := b.WriteMessage(payload); err != nil {\n\t\tt.Fatalf(\"unable to write message: %v\", err)\n\t}\n\n\tfor _, chunk := range test.chunks {\n\t\tassertFlush(t, b, w, chunk.errAfter, chunk.expN, chunk.expErr)\n\t}\n\n\t// We should always be able to call Flush after a message has been\n\t// successfully written, and it should result in a NOP.\n\tassertFlush(t, b, w, 0, 0, nil)\n}\n\n// assertFlush flushes a chunk to the passed io.Writer. If n >= 0, a\n// timeoutWriter will be used the flush should stop with iotest.ErrTimeout after\n// n bytes. The method asserts that the returned error matches expErr and that\n// the number of bytes written by Flush matches expN.",
      "length": 670,
      "tokens": 114,
      "embedding": []
    },
    {
      "slug": "func assertFlush(t *testing.T, b *Machine, w io.Writer, n int64, expN int,",
      "content": "func assertFlush(t *testing.T, b *Machine, w io.Writer, n int64, expN int,\n\texpErr error) {\n\n\tt.Helper()\n\n\tif n >= 0 {\n\t\tw = NewTimeoutWriter(w, n)\n\t}\n\tnn, err := b.Flush(w)\n\tif err != expErr {\n\t\tt.Fatalf(\"expected flush err: %v, got: %v\", expErr, err)\n\t}\n\tif nn != expN {\n\t\tt.Fatalf(\"expected n: %d, got: %d\", expN, nn)\n\t}\n}\n",
      "length": 236,
      "tokens": 46,
      "embedding": []
    }
  ]
}