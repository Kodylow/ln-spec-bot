{
  "filepath": "../implementations/go/lnd/brontide/noise.go",
  "package": "brontide",
  "sections": [
    {
      "slug": "func ecdh(pub *btcec.PublicKey, priv keychain.SingleKeyECDH) ([]byte, error) {",
      "content": "func ecdh(pub *btcec.PublicKey, priv keychain.SingleKeyECDH) ([]byte, error) {\n\thash, err := priv.ECDH(pub)\n\treturn hash[:], err\n}\n\n// cipherState encapsulates the state for the AEAD which will be used to\n// encrypt+authenticate any payloads sent during the handshake, and messages\n// sent once the handshake has completed.",
      "length": 238,
      "tokens": 38,
      "embedding": []
    },
    {
      "slug": "type cipherState struct {",
      "content": "type cipherState struct {\n\t// nonce is the nonce passed into the chacha20-poly1305 instance for\n\t// encryption+decryption. The nonce is incremented after each successful\n\t// encryption/decryption.\n\t//\n\t// TODO(roasbeef): this should actually be 96 bit\n\tnonce uint64\n\n\t// secretKey is the shared symmetric key which will be used to\n\t// instantiate the cipher.\n\t//\n\t// TODO(roasbeef): m-lock??\n\tsecretKey [32]byte\n\n\t// salt is an additional secret which is used during key rotation to\n\t// generate new keys.\n\tsalt [32]byte\n\n\t// cipher is an instance of the ChaCha20-Poly1305 AEAD construction\n\t// created using the secretKey above.\n\tcipher cipher.AEAD\n}\n\n// Encrypt returns a ciphertext which is the encryption of the plainText\n// observing the passed associatedData within the AEAD construction.",
      "length": 745,
      "tokens": 114,
      "embedding": []
    },
    {
      "slug": "func (c *cipherState) Encrypt(associatedData, cipherText, plainText []byte) []byte {",
      "content": "func (c *cipherState) Encrypt(associatedData, cipherText, plainText []byte) []byte {\n\tdefer func() {\n\t\tc.nonce++\n\n\t\tif c.nonce == keyRotationInterval {\n\t\t\tc.rotateKey()\n\t\t}\n\t}()\n\n\tvar nonce [12]byte\n\tbinary.LittleEndian.PutUint64(nonce[4:], c.nonce)\n\n\treturn c.cipher.Seal(cipherText, nonce[:], plainText, associatedData)\n}\n\n// Decrypt attempts to decrypt the passed ciphertext observing the specified\n// associatedData within the AEAD construction. In the case that the final MAC\n// check fails, then a non-nil error will be returned.",
      "length": 434,
      "tokens": 57,
      "embedding": []
    },
    {
      "slug": "func (c *cipherState) Decrypt(associatedData, plainText, cipherText []byte) ([]byte, error) {",
      "content": "func (c *cipherState) Decrypt(associatedData, plainText, cipherText []byte) ([]byte, error) {\n\tdefer func() {\n\t\tc.nonce++\n\n\t\tif c.nonce == keyRotationInterval {\n\t\t\tc.rotateKey()\n\t\t}\n\t}()\n\n\tvar nonce [12]byte\n\tbinary.LittleEndian.PutUint64(nonce[4:], c.nonce)\n\n\treturn c.cipher.Open(plainText, nonce[:], cipherText, associatedData)\n}\n\n// InitializeKey initializes the secret key and AEAD cipher scheme based off of\n// the passed key.",
      "length": 323,
      "tokens": 40,
      "embedding": []
    },
    {
      "slug": "func (c *cipherState) InitializeKey(key [32]byte) {",
      "content": "func (c *cipherState) InitializeKey(key [32]byte) {\n\tc.secretKey = key\n\tc.nonce = 0\n\n\t// Safe to ignore the error here as our key is properly sized\n\t// (32-bytes).\n\tc.cipher, _ = chacha20poly1305.New(c.secretKey[:])\n}\n\n// InitializeKeyWithSalt is identical to InitializeKey however it also sets the\n// cipherState's salt field which is used for key rotation.",
      "length": 297,
      "tokens": 47,
      "embedding": []
    },
    {
      "slug": "func (c *cipherState) InitializeKeyWithSalt(salt, key [32]byte) {",
      "content": "func (c *cipherState) InitializeKeyWithSalt(salt, key [32]byte) {\n\tc.salt = salt\n\tc.InitializeKey(key)\n}\n\n// rotateKey rotates the current encryption/decryption key for this cipherState\n// instance. Key rotation is performed by ratcheting the current key forward\n// using an HKDF invocation with the cipherState's salt as the salt, and the\n// current key as the input.",
      "length": 295,
      "tokens": 47,
      "embedding": []
    },
    {
      "slug": "func (c *cipherState) rotateKey() {",
      "content": "func (c *cipherState) rotateKey() {\n\tvar (\n\t\tinfo    []byte\n\t\tnextKey [32]byte\n\t)\n\n\toldKey := c.secretKey\n\th := hkdf.New(sha256.New, oldKey[:], c.salt[:], info)\n\n\t// hkdf(ck, k, zero)\n\t// |\n\t// | \\\n\t// |  \\\n\t// ck  k'\n\th.Read(c.salt[:])\n\th.Read(nextKey[:])\n\n\tc.InitializeKey(nextKey)\n}\n\n// symmetricState encapsulates a cipherState object and houses the ephemeral\n// handshake digest state. This struct is used during the handshake to derive\n// new shared secrets based off of the result of ECDH operations. Ultimately,\n// the final key yielded by this struct is the result of an incremental\n// Triple-DH operation.",
      "length": 556,
      "tokens": 88,
      "embedding": []
    },
    {
      "slug": "type symmetricState struct {",
      "content": "type symmetricState struct {\n\tcipherState\n\n\t// chainingKey is used as the salt to the HKDF function to derive a new\n\t// chaining key as well as a new tempKey which is used for\n\t// encryption/decryption.\n\tchainingKey [32]byte\n\n\t// tempKey is the latter 32 bytes resulted from the latest HKDF\n\t// iteration. This key is used to encrypt/decrypt any handshake\n\t// messages or payloads sent until the next DH operation is executed.\n\ttempKey [32]byte\n\n\t// handshakeDigest is the cumulative hash digest of all handshake\n\t// messages sent from start to finish. This value is never transmitted\n\t// to the other side, but will be used as the AD when\n\t// encrypting/decrypting messages using our AEAD construction.\n\thandshakeDigest [32]byte\n}\n\n// mixKey implements a basic HKDF-based key ratchet. This method is called\n// with the result of each DH output generated during the handshake process.\n// The first 32 bytes extract from the HKDF reader is the next chaining key,\n// then latter 32 bytes become the temp secret key using within any future AEAD\n// operations until another DH operation is performed.",
      "length": 1044,
      "tokens": 177,
      "embedding": []
    },
    {
      "slug": "func (s *symmetricState) mixKey(input []byte) {",
      "content": "func (s *symmetricState) mixKey(input []byte) {\n\tvar info []byte\n\n\tsecret := input\n\tsalt := s.chainingKey\n\th := hkdf.New(sha256.New, secret, salt[:], info)\n\n\t// hkdf(ck, input, zero)\n\t// |\n\t// | \\\n\t// |  \\\n\t// ck  k\n\th.Read(s.chainingKey[:])\n\th.Read(s.tempKey[:])\n\n\t// cipher.k = temp_key\n\ts.InitializeKey(s.tempKey)\n}\n\n// mixHash hashes the passed input data into the cumulative handshake digest.\n// The running result of this value (h) is used as the associated data in all\n// decryption/encryption operations.",
      "length": 444,
      "tokens": 69,
      "embedding": []
    },
    {
      "slug": "func (s *symmetricState) mixHash(data []byte) {",
      "content": "func (s *symmetricState) mixHash(data []byte) {\n\th := sha256.New()\n\th.Write(s.handshakeDigest[:])\n\th.Write(data)\n\n\tcopy(s.handshakeDigest[:], h.Sum(nil))\n}\n\n// EncryptAndHash returns the authenticated encryption of the passed plaintext.\n// When encrypting the handshake digest (h) is used as the associated data to\n// the AEAD cipher.",
      "length": 277,
      "tokens": 36,
      "embedding": []
    },
    {
      "slug": "func (s *symmetricState) EncryptAndHash(plaintext []byte) []byte {",
      "content": "func (s *symmetricState) EncryptAndHash(plaintext []byte) []byte {\n\tciphertext := s.Encrypt(s.handshakeDigest[:], nil, plaintext)\n\n\ts.mixHash(ciphertext)\n\n\treturn ciphertext\n}\n\n// DecryptAndHash returns the authenticated decryption of the passed\n// ciphertext. When encrypting the handshake digest (h) is used as the\n// associated data to the AEAD cipher.",
      "length": 279,
      "tokens": 37,
      "embedding": []
    },
    {
      "slug": "func (s *symmetricState) DecryptAndHash(ciphertext []byte) ([]byte, error) {",
      "content": "func (s *symmetricState) DecryptAndHash(ciphertext []byte) ([]byte, error) {\n\tplaintext, err := s.Decrypt(s.handshakeDigest[:], nil, ciphertext)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ts.mixHash(ciphertext)\n\n\treturn plaintext, nil\n}\n\n// InitializeSymmetric initializes the symmetric state by setting the handshake\n// digest (h) and the chaining key (ck) to protocol name.",
      "length": 283,
      "tokens": 41,
      "embedding": []
    },
    {
      "slug": "func (s *symmetricState) InitializeSymmetric(protocolName []byte) {",
      "content": "func (s *symmetricState) InitializeSymmetric(protocolName []byte) {\n\tvar empty [32]byte\n\n\ts.handshakeDigest = sha256.Sum256(protocolName)\n\ts.chainingKey = s.handshakeDigest\n\ts.InitializeKey(empty)\n}\n\n// handshakeState encapsulates the symmetricState and keeps track of all the\n// public keys (static and ephemeral) for both sides during the handshake\n// transcript. If the handshake completes successfully, then two instances of a\n// cipherState are emitted: one to encrypt messages from initiator to\n// responder, and the other for the opposite direction.",
      "length": 477,
      "tokens": 66,
      "embedding": []
    },
    {
      "slug": "type handshakeState struct {",
      "content": "type handshakeState struct {\n\tsymmetricState\n\n\tinitiator bool\n\n\tlocalStatic    keychain.SingleKeyECDH\n\tlocalEphemeral keychain.SingleKeyECDH // nolint (false positive)\n\n\tremoteStatic    *btcec.PublicKey\n\tremoteEphemeral *btcec.PublicKey\n}\n\n// newHandshakeState returns a new instance of the handshake state initialized\n// with the prologue and protocol name. If this is the responder's handshake\n// state, then the remotePub can be nil.",
      "length": 394,
      "tokens": 48,
      "embedding": []
    },
    {
      "slug": "func newHandshakeState(initiator bool, prologue []byte,",
      "content": "func newHandshakeState(initiator bool, prologue []byte,\n\tlocalKey keychain.SingleKeyECDH,\n\tremotePub *btcec.PublicKey) handshakeState {\n\n\th := handshakeState{\n\t\tinitiator:    initiator,\n\t\tlocalStatic:  localKey,\n\t\tremoteStatic: remotePub,\n\t}\n\n\t// Set the current chaining key and handshake digest to the hash of the\n\t// protocol name, and additionally mix in the prologue. If either sides\n\t// disagree about the prologue or protocol name, then the handshake\n\t// will fail.\n\th.InitializeSymmetric([]byte(protocolName))\n\th.mixHash(prologue)\n\n\t// In Noise_XK, the initiator should know the responder's static\n\t// public key, therefore we include the responder's static key in the\n\t// handshake digest. If the initiator gets this value wrong, then the\n\t// handshake will fail.\n\tif initiator {\n\t\th.mixHash(remotePub.SerializeCompressed())\n\t} else {\n\t\th.mixHash(localKey.PubKey().SerializeCompressed())\n\t}\n\n\treturn h\n}\n\n// EphemeralGenerator is a functional option that allows callers to substitute\n// a custom function for use when generating ephemeral keys for ActOne or\n// ActTwo. The function closure returned by this function can be passed into\n// NewBrontideMachine as a function option parameter.",
      "length": 1109,
      "tokens": 152,
      "embedding": []
    },
    {
      "slug": "func EphemeralGenerator(gen func() (*btcec.PrivateKey, error)) func(*Machine) {",
      "content": "func EphemeralGenerator(gen func() (*btcec.PrivateKey, error)) func(*Machine) {\n\treturn func(m *Machine) {\n\t\tm.ephemeralGen = gen\n\t}\n}\n\n// Machine is a state-machine which implements Brontide: an\n// Authenticated-key Exchange in Three Acts. Brontide is derived from the Noise\n// framework, specifically implementing the Noise_XK handshake. Once the\n// initial 3-act handshake has completed all messages are encrypted with a\n// chacha20 AEAD cipher. On the wire, all messages are prefixed with an\n// authenticated+encrypted length field. Additionally, the encrypted+auth'd\n// length prefix is used as the AD when encrypting+decryption messages. This\n// construction provides confidentiality of packet length, avoids introducing\n// a padding-oracle, and binds the encrypted packet length to the packet\n// itself.\n//\n// The acts proceeds the following order (initiator on the left):\n//\n//\tGenActOne()   ->\n//\t                  RecvActOne()\n//\t              <-  GenActTwo()\n//\tRecvActTwo()\n//\tGenActThree() ->\n//\t                  RecvActThree()\n//\n// This exchange corresponds to the following Noise handshake:\n//\n//\t<- s\n//\t...\n//\t-> e, es\n//\t<- e, ee\n//\t-> s, se",
      "length": 1050,
      "tokens": 162,
      "embedding": []
    },
    {
      "slug": "type Machine struct {",
      "content": "type Machine struct {\n\tsendCipher cipherState\n\trecvCipher cipherState\n\n\tephemeralGen func() (*btcec.PrivateKey, error)\n\n\thandshakeState\n\n\t// nextCipherHeader is a static buffer that we'll use to read in the\n\t// next ciphertext header from the wire. The header is a 2 byte length\n\t// (of the next ciphertext), followed by a 16 byte MAC.\n\tnextCipherHeader [encHeaderSize]byte\n\n\t// nextHeaderSend holds a reference to the remaining header bytes to\n\t// write out for a pending message. This allows us to tolerate timeout\n\t// errors that cause partial writes.\n\tnextHeaderSend []byte\n\n\t// nextHeaderBody holds a reference to the remaining body bytes to write\n\t// out for a pending message. This allows us to tolerate timeout errors\n\t// that cause partial writes.\n\tnextBodySend []byte\n}\n\n// NewBrontideMachine creates a new instance of the brontide state-machine. If\n// the responder (listener) is creating the object, then the remotePub should\n// be nil. The handshake state within brontide is initialized using the ascii\n// string \"lightning\" as the prologue. The last parameter is a set of variadic\n// arguments for adding additional options to the brontide Machine\n// initialization.",
      "length": 1130,
      "tokens": 176,
      "embedding": []
    },
    {
      "slug": "func NewBrontideMachine(initiator bool, localKey keychain.SingleKeyECDH,",
      "content": "func NewBrontideMachine(initiator bool, localKey keychain.SingleKeyECDH,\n\tremotePub *btcec.PublicKey, options ...func(*Machine)) *Machine {\n\n\thandshake := newHandshakeState(\n\t\tinitiator, lightningPrologue, localKey, remotePub,\n\t)\n\n\tm := &Machine{\n\t\thandshakeState: handshake,\n\t\tephemeralGen:   ephemeralGen,\n\t}\n\n\t// With the default options established, we'll now process all the\n\t// options passed in as parameters.\n\tfor _, option := range options {\n\t\toption(m)\n\t}\n\n\treturn m\n}\n\nconst (\n\t// HandshakeVersion is the expected version of the brontide handshake.\n\t// Any messages that carry a different version will cause the handshake\n\t// to abort immediately.\n\tHandshakeVersion = byte(0)\n\n\t// ActOneSize is the size of the packet sent from initiator to\n\t// responder in ActOne. The packet consists of a handshake version, an\n\t// ephemeral key in compressed format, and a 16-byte poly1305 tag.\n\t//\n\t// 1 + 33 + 16\n\tActOneSize = 50\n\n\t// ActTwoSize is the size the packet sent from responder to initiator\n\t// in ActTwo. The packet consists of a handshake version, an ephemeral\n\t// key in compressed format and a 16-byte poly1305 tag.\n\t//\n\t// 1 + 33 + 16\n\tActTwoSize = 50\n\n\t// ActThreeSize is the size of the packet sent from initiator to\n\t// responder in ActThree. The packet consists of a handshake version,\n\t// the initiators static key encrypted with strong forward secrecy and\n\t// a 16-byte poly1035 tag.\n\t//\n\t// 1 + 33 + 16 + 16\n\tActThreeSize = 66\n)\n\n// GenActOne generates the initial packet (act one) to be sent from initiator\n// to responder. During act one the initiator generates a fresh ephemeral key,\n// hashes it into the handshake digest, and performs an ECDH between this key\n// and the responder's static key. Future payloads are encrypted with a key\n// derived from this result.\n//\n//\t-> e, es",
      "length": 1678,
      "tokens": 286,
      "embedding": []
    },
    {
      "slug": "func (b *Machine) GenActOne() ([ActOneSize]byte, error) {",
      "content": "func (b *Machine) GenActOne() ([ActOneSize]byte, error) {\n\tvar actOne [ActOneSize]byte\n\n\t// e\n\tlocalEphemeral, err := b.ephemeralGen()\n\tif err != nil {\n\t\treturn actOne, err\n\t}\n\tb.localEphemeral = &keychain.PrivKeyECDH{\n\t\tPrivKey: localEphemeral,\n\t}\n\n\tephemeral := localEphemeral.PubKey().SerializeCompressed()\n\tb.mixHash(ephemeral)\n\n\t// es\n\ts, err := ecdh(b.remoteStatic, b.localEphemeral)\n\tif err != nil {\n\t\treturn actOne, err\n\t}\n\tb.mixKey(s[:])\n\n\tauthPayload := b.EncryptAndHash([]byte{})\n\n\tactOne[0] = HandshakeVersion\n\tcopy(actOne[1:34], ephemeral)\n\tcopy(actOne[34:], authPayload)\n\n\treturn actOne, nil\n}\n\n// RecvActOne processes the act one packet sent by the initiator. The responder\n// executes the mirrored actions to that of the initiator extending the\n// handshake digest and deriving a new shared secret based on an ECDH with the\n// initiator's ephemeral key and responder's static key.",
      "length": 805,
      "tokens": 107,
      "embedding": []
    },
    {
      "slug": "func (b *Machine) RecvActOne(actOne [ActOneSize]byte) error {",
      "content": "func (b *Machine) RecvActOne(actOne [ActOneSize]byte) error {\n\tvar (\n\t\terr error\n\t\te   [33]byte\n\t\tp   [16]byte\n\t)\n\n\t// If the handshake version is unknown, then the handshake fails\n\t// immediately.\n\tif actOne[0] != HandshakeVersion {\n\t\treturn fmt.Errorf(\"act one: invalid handshake version: %v, \"+\n\t\t\t\"only %v is valid, msg=%x\", actOne[0], HandshakeVersion,\n\t\t\tactOne[:])\n\t}\n\n\tcopy(e[:], actOne[1:34])\n\tcopy(p[:], actOne[34:])\n\n\t// e\n\tb.remoteEphemeral, err = btcec.ParsePubKey(e[:])\n\tif err != nil {\n\t\treturn err\n\t}\n\tb.mixHash(b.remoteEphemeral.SerializeCompressed())\n\n\t// es\n\ts, err := ecdh(b.remoteEphemeral, b.localStatic)\n\tif err != nil {\n\t\treturn err\n\t}\n\tb.mixKey(s)\n\n\t// If the initiator doesn't know our static key, then this operation\n\t// will fail.\n\t_, err = b.DecryptAndHash(p[:])\n\treturn err\n}\n\n// GenActTwo generates the second packet (act two) to be sent from the\n// responder to the initiator. The packet for act two is identical to that of\n// act one, but then results in a different ECDH operation between the\n// initiator's and responder's ephemeral keys.\n//\n//\t<- e, ee",
      "length": 984,
      "tokens": 153,
      "embedding": []
    },
    {
      "slug": "func (b *Machine) GenActTwo() ([ActTwoSize]byte, error) {",
      "content": "func (b *Machine) GenActTwo() ([ActTwoSize]byte, error) {\n\tvar actTwo [ActTwoSize]byte\n\n\t// e\n\tlocalEphemeral, err := b.ephemeralGen()\n\tif err != nil {\n\t\treturn actTwo, err\n\t}\n\tb.localEphemeral = &keychain.PrivKeyECDH{\n\t\tPrivKey: localEphemeral,\n\t}\n\n\tephemeral := localEphemeral.PubKey().SerializeCompressed()\n\tb.mixHash(localEphemeral.PubKey().SerializeCompressed())\n\n\t// ee\n\ts, err := ecdh(b.remoteEphemeral, b.localEphemeral)\n\tif err != nil {\n\t\treturn actTwo, err\n\t}\n\tb.mixKey(s)\n\n\tauthPayload := b.EncryptAndHash([]byte{})\n\n\tactTwo[0] = HandshakeVersion\n\tcopy(actTwo[1:34], ephemeral)\n\tcopy(actTwo[34:], authPayload)\n\n\treturn actTwo, nil\n}\n\n// RecvActTwo processes the second packet (act two) sent from the responder to\n// the initiator. A successful processing of this packet authenticates the\n// initiator to the responder.",
      "length": 739,
      "tokens": 88,
      "embedding": []
    },
    {
      "slug": "func (b *Machine) RecvActTwo(actTwo [ActTwoSize]byte) error {",
      "content": "func (b *Machine) RecvActTwo(actTwo [ActTwoSize]byte) error {\n\tvar (\n\t\terr error\n\t\te   [33]byte\n\t\tp   [16]byte\n\t)\n\n\t// If the handshake version is unknown, then the handshake fails\n\t// immediately.\n\tif actTwo[0] != HandshakeVersion {\n\t\treturn fmt.Errorf(\"act two: invalid handshake version: %v, \"+\n\t\t\t\"only %v is valid, msg=%x\", actTwo[0], HandshakeVersion,\n\t\t\tactTwo[:])\n\t}\n\n\tcopy(e[:], actTwo[1:34])\n\tcopy(p[:], actTwo[34:])\n\n\t// e\n\tb.remoteEphemeral, err = btcec.ParsePubKey(e[:])\n\tif err != nil {\n\t\treturn err\n\t}\n\tb.mixHash(b.remoteEphemeral.SerializeCompressed())\n\n\t// ee\n\ts, err := ecdh(b.remoteEphemeral, b.localEphemeral)\n\tif err != nil {\n\t\treturn err\n\t}\n\tb.mixKey(s)\n\n\t_, err = b.DecryptAndHash(p[:])\n\treturn err\n}\n\n// GenActThree creates the final (act three) packet of the handshake. Act three\n// is to be sent from the initiator to the responder. The purpose of act three\n// is to transmit the initiator's public key under strong forward secrecy to\n// the responder. This act also includes the final ECDH operation which yields\n// the final session.\n//\n//\t-> s, se",
      "length": 973,
      "tokens": 150,
      "embedding": []
    },
    {
      "slug": "func (b *Machine) GenActThree() ([ActThreeSize]byte, error) {",
      "content": "func (b *Machine) GenActThree() ([ActThreeSize]byte, error) {\n\tvar actThree [ActThreeSize]byte\n\n\tourPubkey := b.localStatic.PubKey().SerializeCompressed()\n\tciphertext := b.EncryptAndHash(ourPubkey)\n\n\ts, err := ecdh(b.remoteEphemeral, b.localStatic)\n\tif err != nil {\n\t\treturn actThree, err\n\t}\n\tb.mixKey(s)\n\n\tauthPayload := b.EncryptAndHash([]byte{})\n\n\tactThree[0] = HandshakeVersion\n\tcopy(actThree[1:50], ciphertext)\n\tcopy(actThree[50:], authPayload)\n\n\t// With the final ECDH operation complete, derive the session sending\n\t// and receiving keys.\n\tb.split()\n\n\treturn actThree, nil\n}\n\n// RecvActThree processes the final act (act three) sent from the initiator to\n// the responder. After processing this act, the responder learns of the\n// initiator's static public key. Decryption of the static key serves to\n// authenticate the initiator to the responder.",
      "length": 766,
      "tokens": 98,
      "embedding": []
    },
    {
      "slug": "func (b *Machine) RecvActThree(actThree [ActThreeSize]byte) error {",
      "content": "func (b *Machine) RecvActThree(actThree [ActThreeSize]byte) error {\n\tvar (\n\t\terr error\n\t\ts   [33 + 16]byte\n\t\tp   [16]byte\n\t)\n\n\t// If the handshake version is unknown, then the handshake fails\n\t// immediately.\n\tif actThree[0] != HandshakeVersion {\n\t\treturn fmt.Errorf(\"act three: invalid handshake version: %v, \"+\n\t\t\t\"only %v is valid, msg=%x\", actThree[0], HandshakeVersion,\n\t\t\tactThree[:])\n\t}\n\n\tcopy(s[:], actThree[1:33+16+1])\n\tcopy(p[:], actThree[33+16+1:])\n\n\t// s\n\tremotePub, err := b.DecryptAndHash(s[:])\n\tif err != nil {\n\t\treturn err\n\t}\n\tb.remoteStatic, err = btcec.ParsePubKey(remotePub)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// se\n\tse, err := ecdh(b.remoteStatic, b.localEphemeral)\n\tif err != nil {\n\t\treturn err\n\t}\n\tb.mixKey(se)\n\n\tif _, err := b.DecryptAndHash(p[:]); err != nil {\n\t\treturn err\n\t}\n\n\t// With the final ECDH operation complete, derive the session sending\n\t// and receiving keys.\n\tb.split()\n\n\treturn nil\n}\n\n// split is the final wrap-up act to be executed at the end of a successful\n// three act handshake. This function creates two internal cipherState\n// instances: one which is used to encrypt messages from the initiator to the\n// responder, and another which is used to encrypt message for the opposite\n// direction.",
      "length": 1121,
      "tokens": 178,
      "embedding": []
    },
    {
      "slug": "func (b *Machine) split() {",
      "content": "func (b *Machine) split() {\n\tvar (\n\t\tempty   []byte\n\t\tsendKey [32]byte\n\t\trecvKey [32]byte\n\t)\n\n\th := hkdf.New(sha256.New, empty, b.chainingKey[:], empty)\n\n\t// If we're the initiator the first 32 bytes are used to encrypt our\n\t// messages and the second 32-bytes to decrypt their messages. For the\n\t// responder the opposite is true.\n\tif b.initiator {\n\t\th.Read(sendKey[:])\n\t\tb.sendCipher = cipherState{}\n\t\tb.sendCipher.InitializeKeyWithSalt(b.chainingKey, sendKey)\n\n\t\th.Read(recvKey[:])\n\t\tb.recvCipher = cipherState{}\n\t\tb.recvCipher.InitializeKeyWithSalt(b.chainingKey, recvKey)\n\t} else {\n\t\th.Read(recvKey[:])\n\t\tb.recvCipher = cipherState{}\n\t\tb.recvCipher.InitializeKeyWithSalt(b.chainingKey, recvKey)\n\n\t\th.Read(sendKey[:])\n\t\tb.sendCipher = cipherState{}\n\t\tb.sendCipher.InitializeKeyWithSalt(b.chainingKey, sendKey)\n\t}\n}\n\n// WriteMessage encrypts and buffers the next message p. The ciphertext of the\n// message is prepended with an encrypt+auth'd length which must be used as the\n// AD to the AEAD construction when being decrypted by the other side.\n//\n// NOTE: This DOES NOT write the message to the wire, it should be followed by a\n// call to Flush to ensure the message is written.",
      "length": 1121,
      "tokens": 147,
      "embedding": []
    },
    {
      "slug": "func (b *Machine) WriteMessage(p []byte) error {",
      "content": "func (b *Machine) WriteMessage(p []byte) error {\n\t// The total length of each message payload including the MAC size\n\t// payload exceed the largest number encodable within a 16-bit unsigned\n\t// integer.\n\tif len(p) > math.MaxUint16 {\n\t\treturn ErrMaxMessageLengthExceeded\n\t}\n\n\t// If a prior message was written but it hasn't been fully flushed,\n\t// return an error as we only support buffering of one message at a\n\t// time.\n\tif len(b.nextHeaderSend) > 0 || len(b.nextBodySend) > 0 {\n\t\treturn ErrMessageNotFlushed\n\t}\n\n\t// The full length of the packet is only the packet length, and does\n\t// NOT include the MAC.\n\tfullLength := uint16(len(p))\n\n\tvar pktLen [2]byte\n\tbinary.BigEndian.PutUint16(pktLen[:], fullLength)\n\n\t// First, generate the encrypted+MAC'd length prefix for the packet.\n\tb.nextHeaderSend = b.sendCipher.Encrypt(nil, nil, pktLen[:])\n\n\t// Finally, generate the encrypted packet itself.\n\tb.nextBodySend = b.sendCipher.Encrypt(nil, nil, p)\n\n\treturn nil\n}\n\n// Flush attempts to write a message buffered using WriteMessage to the provided\n// io.Writer. If no buffered message exists, this will result in a NOP.\n// Otherwise, it will continue to write the remaining bytes, picking up where\n// the byte stream left off in the event of a partial write. The number of bytes\n// returned reflects the number of plaintext bytes in the payload, and does not\n// account for the overhead of the header or MACs.\n//\n// NOTE: It is safe to call this method again iff a timeout error is returned.",
      "length": 1403,
      "tokens": 228,
      "embedding": []
    },
    {
      "slug": "func (b *Machine) Flush(w io.Writer) (int, error) {",
      "content": "func (b *Machine) Flush(w io.Writer) (int, error) {\n\t// First, write out the pending header bytes, if any exist. Any header\n\t// bytes written will not count towards the total amount flushed.\n\tif len(b.nextHeaderSend) > 0 {\n\t\t// Write any remaining header bytes and shift the slice to point\n\t\t// to the next segment of unwritten bytes. If an error is\n\t\t// encountered, we can continue to write the header from where\n\t\t// we left off on a subsequent call to Flush.\n\t\tn, err := w.Write(b.nextHeaderSend)\n\t\tb.nextHeaderSend = b.nextHeaderSend[n:]\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Next, write the pending body bytes, if any exist. Only the number of\n\t// bytes written that correspond to the ciphertext will be included in\n\t// the total bytes written, bytes written as part of the MAC will not be\n\t// counted.\n\tvar nn int\n\tif len(b.nextBodySend) > 0 {\n\t\t// Write out all bytes excluding the mac and shift the body\n\t\t// slice depending on the number of actual bytes written.\n\t\tn, err := w.Write(b.nextBodySend)\n\t\tb.nextBodySend = b.nextBodySend[n:]\n\n\t\t// If we partially or fully wrote any of the body's MAC, we'll\n\t\t// subtract that contribution from the total amount flushed to\n\t\t// preserve the abstraction of returning the number of plaintext\n\t\t// bytes written by the connection.\n\t\t//\n\t\t// There are three possible scenarios we must handle to ensure\n\t\t// the returned value is correct. In the first case, the write\n\t\t// straddles both payload and MAC bytes, and we must subtract\n\t\t// the number of MAC bytes written from n. In the second, only\n\t\t// payload bytes are written, thus we can return n unmodified.\n\t\t// The final scenario pertains to the case where only MAC bytes\n\t\t// are written, none of which count towards the total.\n\t\t//\n\t\t//                 |-----------Payload------------|----MAC----|\n\t\t// Straddle:       S---------------------------------E--------0\n\t\t// Payload-only:   S------------------------E-----------------0\n\t\t// MAC-only:                                        S-------E-0\n\t\tstart, end := n+len(b.nextBodySend), len(b.nextBodySend)\n\t\tswitch {\n\n\t\t// Straddles payload and MAC bytes, subtract number of MAC bytes\n\t\t// written from the actual number written.\n\t\tcase start > macSize && end <= macSize:\n\t\t\tnn = n - (macSize - end)\n\n\t\t// Only payload bytes are written, return n directly.\n\t\tcase start > macSize && end > macSize:\n\t\t\tnn = n\n\n\t\t// Only MAC bytes are written, return 0 bytes written.\n\t\tdefault:\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn nn, err\n\t\t}\n\t}\n\n\treturn nn, nil\n}\n\n// ReadMessage attempts to read the next message from the passed io.Reader. In\n// the case of an authentication error, a non-nil error is returned.",
      "length": 2539,
      "tokens": 414,
      "embedding": []
    },
    {
      "slug": "func (b *Machine) ReadMessage(r io.Reader) ([]byte, error) {",
      "content": "func (b *Machine) ReadMessage(r io.Reader) ([]byte, error) {\n\tpktLen, err := b.ReadHeader(r)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbuf := make([]byte, pktLen)\n\treturn b.ReadBody(r, buf)\n}\n\n// ReadHeader attempts to read the next message header from the passed\n// io.Reader. The header contains the length of the next body including\n// additional overhead of the MAC. In the case of an authentication error, a\n// non-nil error is returned.\n//\n// NOTE: This method SHOULD NOT be used in the case that the io.Reader may be\n// adversarial and induce long delays. If the caller needs to set read deadlines\n// appropriately, it is preferred that they use the split ReadHeader and\n// ReadBody methods so that the deadlines can be set appropriately on each.",
      "length": 673,
      "tokens": 120,
      "embedding": []
    },
    {
      "slug": "func (b *Machine) ReadHeader(r io.Reader) (uint32, error) {",
      "content": "func (b *Machine) ReadHeader(r io.Reader) (uint32, error) {\n\t_, err := io.ReadFull(r, b.nextCipherHeader[:])\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Attempt to decrypt+auth the packet length present in the stream.\n\t//\n\t// By passing in `nextCipherHeader` as the destination, we avoid making\n\t// the library allocate a new buffer to decode the plaintext.\n\tpktLenBytes, err := b.recvCipher.Decrypt(\n\t\tnil, b.nextCipherHeader[:0], b.nextCipherHeader[:],\n\t)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Compute the packet length that we will need to read off the wire.\n\tpktLen := uint32(binary.BigEndian.Uint16(pktLenBytes)) + macSize\n\n\treturn pktLen, nil\n}\n\n// ReadBody attempts to ready the next message body from the passed io.Reader.\n// The provided buffer MUST be the length indicated by the packet length\n// returned by the preceding call to ReadHeader. In the case of an\n// authentication error, a non-nil error is returned.",
      "length": 839,
      "tokens": 135,
      "embedding": []
    },
    {
      "slug": "func (b *Machine) ReadBody(r io.Reader, buf []byte) ([]byte, error) {",
      "content": "func (b *Machine) ReadBody(r io.Reader, buf []byte) ([]byte, error) {\n\t// Next, using the length read from the packet header, read the\n\t// encrypted packet itself into the buffer allocated by the read\n\t// pool.\n\t_, err := io.ReadFull(r, buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Finally, decrypt the message held in the buffer, and return a new\n\t// byte slice containing the plaintext.\n\t//\n\t// By passing in the buf (the ciphertext) as the first argument, we end\n\t// up re-using it as we don't force the library to allocate a new\n\t// buffer to decode the plaintext.\n\treturn b.recvCipher.Decrypt(nil, buf[:0], buf)\n}\n",
      "length": 536,
      "tokens": 98,
      "embedding": []
    }
  ]
}