{
  "filepath": "../implementations/go/lnd/brontide/listener.go",
  "package": "brontide",
  "sections": [
    {
      "slug": "type Listener struct {",
      "content": "type Listener struct {\n\tlocalStatic keychain.SingleKeyECDH\n\n\ttcp *net.TCPListener\n\n\thandshakeSema chan struct{}\n\tconns         chan maybeConn\n\tquit          chan struct{}\n}\n\n// A compile-time assertion to ensure that Conn meets the net.Listener interface.\nvar _ net.Listener = (*Listener)(nil)\n\n// NewListener returns a new net.Listener which enforces the Brontide scheme\n// during both initial connection establishment and data transfer.",
      "length": 402,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func NewListener(localStatic keychain.SingleKeyECDH,",
      "content": "func NewListener(localStatic keychain.SingleKeyECDH,\n\tlistenAddr string) (*Listener, error) {\n\n\taddr, err := net.ResolveTCPAddr(\"tcp\", listenAddr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tl, err := net.ListenTCP(\"tcp\", addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbrontideListener := &Listener{\n\t\tlocalStatic:   localStatic,\n\t\ttcp:           l,\n\t\thandshakeSema: make(chan struct{}, defaultHandshakes),\n\t\tconns:         make(chan maybeConn),\n\t\tquit:          make(chan struct{}),\n\t}\n\n\tfor i := 0; i < defaultHandshakes; i++ {\n\t\tbrontideListener.handshakeSema <- struct{}{}\n\t}\n\n\tgo brontideListener.listen()\n\n\treturn brontideListener, nil\n}\n\n// listen accepts connection from the underlying tcp conn, then performs\n// the brontinde handshake procedure asynchronously. A maximum of\n// defaultHandshakes will be active at any given time.\n//\n// NOTE: This method must be run as a goroutine.",
      "length": 799,
      "tokens": 110,
      "embedding": []
    },
    {
      "slug": "func (l *Listener) listen() {",
      "content": "func (l *Listener) listen() {\n\tfor {\n\t\tselect {\n\t\tcase <-l.handshakeSema:\n\t\tcase <-l.quit:\n\t\t\treturn\n\t\t}\n\n\t\tconn, err := l.tcp.Accept()\n\t\tif err != nil {\n\t\t\tl.rejectConn(err)\n\t\t\tl.handshakeSema <- struct{}{}\n\t\t\tcontinue\n\t\t}\n\n\t\tgo l.doHandshake(conn)\n\t}\n}\n\n// rejectedConnErr is a helper function that prepends the remote address of the\n// failed connection attempt to the original error message.",
      "length": 346,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func rejectedConnErr(err error, remoteAddr string) error {",
      "content": "func rejectedConnErr(err error, remoteAddr string) error {\n\treturn fmt.Errorf(\"unable to accept connection from %v: %v\", remoteAddr,\n\t\terr)\n}\n\n// doHandshake asynchronously performs the brontide handshake, so that it does\n// not block the main accept loop. This prevents peers that delay writing to the\n// connection from block other connection attempts.",
      "length": 289,
      "tokens": 44,
      "embedding": []
    },
    {
      "slug": "func (l *Listener) doHandshake(conn net.Conn) {",
      "content": "func (l *Listener) doHandshake(conn net.Conn) {\n\tdefer func() { l.handshakeSema <- struct{}{} }()\n\n\tselect {\n\tcase <-l.quit:\n\t\treturn\n\tdefault:\n\t}\n\n\tremoteAddr := conn.RemoteAddr().String()\n\n\tbrontideConn := &Conn{\n\t\tconn:  conn,\n\t\tnoise: NewBrontideMachine(false, l.localStatic, nil),\n\t}\n\n\t// We'll ensure that we get ActOne from the remote peer in a timely\n\t// manner. If they don't respond within handshakeReadTimeout, then\n\t// we'll kill the connection.\n\terr := conn.SetReadDeadline(time.Now().Add(handshakeReadTimeout))\n\tif err != nil {\n\t\tbrontideConn.conn.Close()\n\t\tl.rejectConn(rejectedConnErr(err, remoteAddr))\n\t\treturn\n\t}\n\n\t// Attempt to carry out the first act of the handshake protocol. If the\n\t// connecting node doesn't know our long-term static public key, then\n\t// this portion will fail with a non-nil error.\n\tvar actOne [ActOneSize]byte\n\tif _, err := io.ReadFull(conn, actOne[:]); err != nil {\n\t\tbrontideConn.conn.Close()\n\t\tl.rejectConn(rejectedConnErr(err, remoteAddr))\n\t\treturn\n\t}\n\tif err := brontideConn.noise.RecvActOne(actOne); err != nil {\n\t\tbrontideConn.conn.Close()\n\t\tl.rejectConn(rejectedConnErr(err, remoteAddr))\n\t\treturn\n\t}\n\n\t// Next, progress the handshake processes by sending over our ephemeral\n\t// key for the session along with an authenticating tag.\n\tactTwo, err := brontideConn.noise.GenActTwo()\n\tif err != nil {\n\t\tbrontideConn.conn.Close()\n\t\tl.rejectConn(rejectedConnErr(err, remoteAddr))\n\t\treturn\n\t}\n\tif _, err := conn.Write(actTwo[:]); err != nil {\n\t\tbrontideConn.conn.Close()\n\t\tl.rejectConn(rejectedConnErr(err, remoteAddr))\n\t\treturn\n\t}\n\n\tselect {\n\tcase <-l.quit:\n\t\treturn\n\tdefault:\n\t}\n\n\t// We'll ensure that we get ActTwo from the remote peer in a timely\n\t// manner. If they don't respond within handshakeReadTimeout, then\n\t// we'll kill the connection.\n\terr = conn.SetReadDeadline(time.Now().Add(handshakeReadTimeout))\n\tif err != nil {\n\t\tbrontideConn.conn.Close()\n\t\tl.rejectConn(rejectedConnErr(err, remoteAddr))\n\t\treturn\n\t}\n\n\t// Finally, finish the handshake processes by reading and decrypting\n\t// the connection peer's static public key. If this succeeds then both\n\t// sides have mutually authenticated each other.\n\tvar actThree [ActThreeSize]byte\n\tif _, err := io.ReadFull(conn, actThree[:]); err != nil {\n\t\tbrontideConn.conn.Close()\n\t\tl.rejectConn(rejectedConnErr(err, remoteAddr))\n\t\treturn\n\t}\n\tif err := brontideConn.noise.RecvActThree(actThree); err != nil {\n\t\tbrontideConn.conn.Close()\n\t\tl.rejectConn(rejectedConnErr(err, remoteAddr))\n\t\treturn\n\t}\n\n\t// We'll reset the deadline as it's no longer critical beyond the\n\t// initial handshake.\n\terr = conn.SetReadDeadline(time.Time{})\n\tif err != nil {\n\t\tbrontideConn.conn.Close()\n\t\tl.rejectConn(rejectedConnErr(err, remoteAddr))\n\t\treturn\n\t}\n\n\tl.acceptConn(brontideConn)\n}\n\n// maybeConn holds either a brontide connection or an error returned from the\n// handshake.",
      "length": 2711,
      "tokens": 335,
      "embedding": []
    },
    {
      "slug": "type maybeConn struct {",
      "content": "type maybeConn struct {\n\tconn *Conn\n\terr  error\n}\n\n// acceptConn returns a connection that successfully performed a handshake.",
      "length": 98,
      "tokens": 15,
      "embedding": []
    },
    {
      "slug": "func (l *Listener) acceptConn(conn *Conn) {",
      "content": "func (l *Listener) acceptConn(conn *Conn) {\n\tselect {\n\tcase l.conns <- maybeConn{conn: conn}:\n\tcase <-l.quit:\n\t}\n}\n\n// rejectConn returns any errors encountered during connection or handshake.",
      "length": 142,
      "tokens": 21,
      "embedding": []
    },
    {
      "slug": "func (l *Listener) rejectConn(err error) {",
      "content": "func (l *Listener) rejectConn(err error) {\n\tselect {\n\tcase l.conns <- maybeConn{err: err}:\n\tcase <-l.quit:\n\t}\n}\n\n// Accept waits for and returns the next connection to the listener. All\n// incoming connections are authenticated via the three act Brontide\n// key-exchange scheme. This function will fail with a non-nil error in the\n// case that either the handshake breaks down, or the remote peer doesn't know\n// our static public key.\n//\n// Part of the net.Listener interface.",
      "length": 422,
      "tokens": 73,
      "embedding": []
    },
    {
      "slug": "func (l *Listener) Accept() (net.Conn, error) {",
      "content": "func (l *Listener) Accept() (net.Conn, error) {\n\tselect {\n\tcase result := <-l.conns:\n\t\treturn result.conn, result.err\n\tcase <-l.quit:\n\t\treturn nil, errors.New(\"brontide connection closed\")\n\t}\n}\n\n// Close closes the listener.  Any blocked Accept operations will be unblocked\n// and return errors.\n//\n// Part of the net.Listener interface.",
      "length": 278,
      "tokens": 41,
      "embedding": []
    },
    {
      "slug": "func (l *Listener) Close() error {",
      "content": "func (l *Listener) Close() error {\n\tselect {\n\tcase <-l.quit:\n\tdefault:\n\t\tclose(l.quit)\n\t}\n\n\treturn l.tcp.Close()\n}\n\n// Addr returns the listener's network address.\n//\n// Part of the net.Listener interface.",
      "length": 159,
      "tokens": 24,
      "embedding": []
    },
    {
      "slug": "func (l *Listener) Addr() net.Addr {",
      "content": "func (l *Listener) Addr() net.Addr {\n\treturn l.tcp.Addr()\n}\n",
      "length": 21,
      "tokens": 3,
      "embedding": []
    }
  ]
}