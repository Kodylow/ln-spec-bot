{
  "filepath": "../implementations/go/lnd/zpay32/invoice_internal_test.go",
  "package": "zpay32",
  "sections": [
    {
      "slug": "func TestDecodeAmount(t *testing.T) {",
      "content": "func TestDecodeAmount(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tamount string\n\t\tvalid  bool\n\t\tresult lnwire.MilliSatoshi\n\t}{\n\t\t{\n\t\t\tamount: \"\",\n\t\t\tvalid:  false,\n\t\t},\n\t\t{\n\t\t\tamount: \"20n00\",\n\t\t\tvalid:  false,\n\t\t},\n\t\t{\n\t\t\tamount: \"2000y\",\n\t\t\tvalid:  false,\n\t\t},\n\t\t{\n\t\t\tamount: \"2000mm\",\n\t\t\tvalid:  false,\n\t\t},\n\t\t{\n\t\t\tamount: \"2000nm\",\n\t\t\tvalid:  false,\n\t\t},\n\t\t{\n\t\t\tamount: \"m\",\n\t\t\tvalid:  false,\n\t\t},\n\t\t{\n\t\t\tamount: \"1p\",  // pBTC\n\t\t\tvalid:  false, // too small\n\t\t},\n\t\t{\n\t\t\tamount: \"1109p\", // pBTC\n\t\t\tvalid:  false,   // not divisible by 10\n\t\t},\n\t\t{\n\t\t\tamount: \"-10p\", // pBTC\n\t\t\tvalid:  false,  // negative amount\n\t\t},\n\t\t{\n\t\t\tamount: \"10p\", // pBTC\n\t\t\tvalid:  true,\n\t\t\tresult: 1, // mSat\n\t\t},\n\t\t{\n\t\t\tamount: \"1000p\", // pBTC\n\t\t\tvalid:  true,\n\t\t\tresult: 100, // mSat\n\t\t},\n\t\t{\n\t\t\tamount: \"1n\", // nBTC\n\t\t\tvalid:  true,\n\t\t\tresult: 100, // mSat\n\t\t},\n\t\t{\n\t\t\tamount: \"9000n\", // nBTC\n\t\t\tvalid:  true,\n\t\t\tresult: 900000, // mSat\n\t\t},\n\t\t{\n\t\t\tamount: \"9u\", // uBTC\n\t\t\tvalid:  true,\n\t\t\tresult: 900000, // mSat\n\t\t},\n\t\t{\n\t\t\tamount: \"2000u\", // uBTC\n\t\t\tvalid:  true,\n\t\t\tresult: 200000000, // mSat\n\t\t},\n\t\t{\n\t\t\tamount: \"2m\", // mBTC\n\t\t\tvalid:  true,\n\t\t\tresult: 200000000, // mSat\n\t\t},\n\t\t{\n\t\t\tamount: \"2000m\", // mBTC\n\t\t\tvalid:  true,\n\t\t\tresult: 200000000000, // mSat\n\t\t},\n\t\t{\n\t\t\tamount: \"2\", // BTC\n\t\t\tvalid:  true,\n\t\t\tresult: 200000000000, // mSat\n\t\t},\n\t\t{\n\t\t\tamount: \"2000\", // BTC\n\t\t\tvalid:  true,\n\t\t\tresult: 200000000000000, // mSat\n\t\t},\n\t\t{\n\t\t\tamount: \"2009\", // BTC\n\t\t\tvalid:  true,\n\t\t\tresult: 200900000000000, // mSat\n\t\t},\n\t\t{\n\t\t\tamount: \"1234\", // BTC\n\t\t\tvalid:  true,\n\t\t\tresult: 123400000000000, // mSat\n\t\t},\n\t\t{\n\t\t\tamount: \"21000000\", // BTC\n\t\t\tvalid:  true,\n\t\t\tresult: 2100000000000000000, // mSat\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\tsat, err := decodeAmount(test.amount)\n\t\tif (err == nil) != test.valid {\n\t\t\tt.Errorf(\"amount decoding test %d failed: %v\", i, err)\n\t\t\treturn\n\t\t}\n\t\tif test.valid && sat != test.result {\n\t\t\tt.Fatalf(\"test %d failed decoding amount, expected %v, \"+\n\t\t\t\t\"got %v\", i, test.result, sat)\n\t\t}\n\t}\n}\n\n// TestEncodeAmount checks that the given amount in millisatoshis gets encoded\n// into the shortest possible amount string.",
      "length": 1999,
      "tokens": 309,
      "embedding": []
    },
    {
      "slug": "func TestEncodeAmount(t *testing.T) {",
      "content": "func TestEncodeAmount(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tmsat   lnwire.MilliSatoshi\n\t\tvalid  bool\n\t\tresult string\n\t}{\n\t\t{\n\t\t\tmsat:   1, // mSat\n\t\t\tvalid:  true,\n\t\t\tresult: \"10p\", // pBTC\n\t\t},\n\t\t{\n\t\t\tmsat:   120, // mSat\n\t\t\tvalid:  true,\n\t\t\tresult: \"1200p\", // pBTC\n\t\t},\n\t\t{\n\t\t\tmsat:   100, // mSat\n\t\t\tvalid:  true,\n\t\t\tresult: \"1n\", // nBTC\n\t\t},\n\t\t{\n\t\t\tmsat:   900000, // mSat\n\t\t\tvalid:  true,\n\t\t\tresult: \"9u\", // uBTC\n\t\t},\n\t\t{\n\t\t\tmsat:   200000000, // mSat\n\t\t\tvalid:  true,\n\t\t\tresult: \"2m\", // mBTC\n\t\t},\n\t\t{\n\t\t\tmsat:   200000000000, // mSat\n\t\t\tvalid:  true,\n\t\t\tresult: \"2\", // BTC\n\t\t},\n\t\t{\n\t\t\tmsat:   200000000000000, // mSat\n\t\t\tvalid:  true,\n\t\t\tresult: \"2000\", // BTC\n\t\t},\n\t\t{\n\t\t\tmsat:   200900000000000, // mSat\n\t\t\tvalid:  true,\n\t\t\tresult: \"2009\", // BTC\n\t\t},\n\t\t{\n\t\t\tmsat:   123400000000000, // mSat\n\t\t\tvalid:  true,\n\t\t\tresult: \"1234\", // BTC\n\t\t},\n\t\t{\n\t\t\tmsat:   2100000000000000000, // mSat\n\t\t\tvalid:  true,\n\t\t\tresult: \"21000000\", // BTC\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\tshortened, err := encodeAmount(test.msat)\n\t\tif (err == nil) != test.valid {\n\t\t\tt.Errorf(\"amount encoding test %d failed: %v\", i, err)\n\t\t\treturn\n\t\t}\n\t\tif test.valid && shortened != test.result {\n\t\t\tt.Fatalf(\"test %d failed encoding amount, expected %v, \"+\n\t\t\t\t\"got %v\", i, test.result, shortened)\n\t\t}\n\t}\n}\n\n// TestParseTimestamp checks that the 35 bit timestamp is properly parsed.",
      "length": 1271,
      "tokens": 195,
      "embedding": []
    },
    {
      "slug": "func TestParseTimestamp(t *testing.T) {",
      "content": "func TestParseTimestamp(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tdata   []byte\n\t\tvalid  bool\n\t\tresult uint64\n\t}{\n\t\t{\n\t\t\tdata:  []byte(\"\"),\n\t\t\tvalid: false, // empty data\n\t\t},\n\t\t{\n\t\t\tdata:  []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n\t\t\tvalid: false, // data too short\n\t\t},\n\t\t{\n\t\t\tdata:   []byte{0x01, 0x0c, 0x12, 0x1f, 0x1c, 0x19, 0x02},\n\t\t\tvalid:  true, // timestamp 1496314658\n\t\t\tresult: 1496314658,\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\ttime, err := parseTimestamp(test.data)\n\t\tif (err == nil) != test.valid {\n\t\t\tt.Errorf(\"timestamp decoding test %d failed: %v\", i, err)\n\t\t\treturn\n\t\t}\n\t\tif test.valid && time != test.result {\n\t\t\tt.Fatalf(\"test %d failed decoding timestamp: \"+\n\t\t\t\t\"expected %d, got %d\",\n\t\t\t\ti, test.result, time)\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// TestParseFieldDataLength checks that the 16 bit length is properly parsed.",
      "length": 769,
      "tokens": 117,
      "embedding": []
    },
    {
      "slug": "func TestParseFieldDataLength(t *testing.T) {",
      "content": "func TestParseFieldDataLength(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tdata   []byte\n\t\tvalid  bool\n\t\tresult uint16\n\t}{\n\t\t{\n\t\t\tdata:  []byte{},\n\t\t\tvalid: false, // empty data\n\t\t},\n\t\t{\n\t\t\tdata:  []byte{0x0},\n\t\t\tvalid: false, // data too short\n\t\t},\n\t\t{\n\t\t\tdata:  []byte{0x0, 0x0, 0x0},\n\t\t\tvalid: false, // data too long\n\t\t},\n\t\t{\n\t\t\tdata:   []byte{0x0, 0x0},\n\t\t\tvalid:  true,\n\t\t\tresult: 0,\n\t\t},\n\t\t{\n\t\t\tdata:   []byte{0x1f, 0x1f},\n\t\t\tvalid:  true,\n\t\t\tresult: 1023,\n\t\t},\n\t\t{\n\t\t\t// The first byte is <= 3 bits long.\n\t\t\tdata:   []byte{0x1, 0x2},\n\t\t\tvalid:  true,\n\t\t\tresult: 34,\n\t\t},\n\t\t{\n\t\t\t// The first byte is > 3 bits long.\n\t\t\tdata:   []byte{0xa, 0x0},\n\t\t\tvalid:  true,\n\t\t\tresult: 320,\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\tlength, err := parseFieldDataLength(test.data)\n\t\tif (err == nil) != test.valid {\n\t\t\tt.Errorf(\"field data length decoding test %d failed: %v\", i, err)\n\t\t\treturn\n\t\t}\n\t\tif test.valid && length != test.result {\n\t\t\tt.Fatalf(\"test %d failed decoding field data length: \"+\n\t\t\t\t\"expected %d, got %d\",\n\t\t\t\ti, test.result, length)\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// TestParse32Bytes checks that the payment hash is properly parsed.\n// If the data does not have a length of 52 bytes, we skip over parsing the\n// field and do not return an error.",
      "length": 1150,
      "tokens": 189,
      "embedding": []
    },
    {
      "slug": "func TestParse32Bytes(t *testing.T) {",
      "content": "func TestParse32Bytes(t *testing.T) {\n\tt.Parallel()\n\n\ttestPaymentHashData, _ := bech32.ConvertBits(testPaymentHash[:], 8, 5, true)\n\n\ttests := []struct {\n\t\tdata   []byte\n\t\tvalid  bool\n\t\tresult *[32]byte\n\t}{\n\t\t{\n\t\t\tdata:   []byte{},\n\t\t\tvalid:  true,\n\t\t\tresult: nil, // skip unknown length, not 52 bytes\n\t\t},\n\t\t{\n\t\t\tdata:   []byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0},\n\t\t\tvalid:  true,\n\t\t\tresult: nil, // skip unknown length, not 52 bytes\n\t\t},\n\t\t{\n\t\t\tdata:   testPaymentHashData,\n\t\t\tvalid:  true,\n\t\t\tresult: &testPaymentHash,\n\t\t},\n\t\t{\n\t\t\tdata:   append(testPaymentHashData, 0x0),\n\t\t\tvalid:  true,\n\t\t\tresult: nil, // skip unknown length, not 52 bytes\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\tpaymentHash, err := parse32Bytes(test.data)\n\t\tif (err == nil) != test.valid {\n\t\t\tt.Errorf(\"payment hash decoding test %d failed: %v\", i, err)\n\t\t\treturn\n\t\t}\n\t\tif test.valid && !compareHashes(paymentHash, test.result) {\n\t\t\tt.Fatalf(\"test %d failed decoding payment hash: \"+\n\t\t\t\t\"expected %x, got %x\",\n\t\t\t\ti, *test.result, *paymentHash)\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// TestParseDescription checks that the description is properly parsed.",
      "length": 1022,
      "tokens": 141,
      "embedding": []
    },
    {
      "slug": "func TestParseDescription(t *testing.T) {",
      "content": "func TestParseDescription(t *testing.T) {\n\tt.Parallel()\n\n\ttestCupOfCoffeeData, _ := bech32.ConvertBits([]byte(testCupOfCoffee), 8, 5, true)\n\ttestPleaseConsiderData, _ := bech32.ConvertBits([]byte(testPleaseConsider), 8, 5, true)\n\n\ttests := []struct {\n\t\tdata   []byte\n\t\tvalid  bool\n\t\tresult *string\n\t}{\n\t\t{\n\t\t\tdata:   []byte{},\n\t\t\tvalid:  true,\n\t\t\tresult: &testEmptyString,\n\t\t},\n\t\t{\n\t\t\tdata:   testCupOfCoffeeData,\n\t\t\tvalid:  true,\n\t\t\tresult: &testCupOfCoffee,\n\t\t},\n\t\t{\n\t\t\tdata:   testPleaseConsiderData,\n\t\t\tvalid:  true,\n\t\t\tresult: &testPleaseConsider,\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\tdescription, err := parseDescription(test.data)\n\t\tif (err == nil) != test.valid {\n\t\t\tt.Errorf(\"description decoding test %d failed: %v\", i, err)\n\t\t\treturn\n\t\t}\n\t\tif test.valid && !reflect.DeepEqual(description, test.result) {\n\t\t\tt.Fatalf(\"test %d failed decoding description: \"+\n\t\t\t\t\"expected \\\"%s\\\", got \\\"%s\\\"\",\n\t\t\t\ti, *test.result, *description)\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// TestParseDestination checks that the destination is properly parsed.\n// If the data does not have a length of 53 bytes, we skip over parsing the\n// field and do not return an error.",
      "length": 1060,
      "tokens": 136,
      "embedding": []
    },
    {
      "slug": "func TestParseDestination(t *testing.T) {",
      "content": "func TestParseDestination(t *testing.T) {\n\tt.Parallel()\n\n\ttestPubKeyData, _ := bech32.ConvertBits(testPubKey.SerializeCompressed(), 8, 5, true)\n\n\ttests := []struct {\n\t\tdata   []byte\n\t\tvalid  bool\n\t\tresult *btcec.PublicKey\n\t}{\n\t\t{\n\t\t\tdata:   []byte{},\n\t\t\tvalid:  true,\n\t\t\tresult: nil, // skip unknown length, not 53 bytes\n\t\t},\n\t\t{\n\t\t\tdata:   []byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0},\n\t\t\tvalid:  true,\n\t\t\tresult: nil, // skip unknown length, not 53 bytes\n\t\t},\n\t\t{\n\t\t\tdata:   testPubKeyData,\n\t\t\tvalid:  true,\n\t\t\tresult: testPubKey,\n\t\t},\n\t\t{\n\t\t\tdata:   append(testPubKeyData, 0x0),\n\t\t\tvalid:  true,\n\t\t\tresult: nil, // skip unknown length, not 53 bytes\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\tdestination, err := parseDestination(test.data)\n\t\tif (err == nil) != test.valid {\n\t\t\tt.Errorf(\"destination decoding test %d failed: %v\", i, err)\n\t\t\treturn\n\t\t}\n\t\tif test.valid && !comparePubkeys(destination, test.result) {\n\t\t\tt.Fatalf(\"test %d failed decoding destination: \"+\n\t\t\t\t\"expected %x, got %x\",\n\t\t\t\ti, test.result.SerializeCompressed(),\n\t\t\t\tdestination.SerializeCompressed())\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// TestParseExpiry checks that the expiry is properly parsed.",
      "length": 1060,
      "tokens": 139,
      "embedding": []
    },
    {
      "slug": "func TestParseExpiry(t *testing.T) {",
      "content": "func TestParseExpiry(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tdata   []byte\n\t\tvalid  bool\n\t\tresult *time.Duration\n\t}{\n\t\t{\n\t\t\tdata:   []byte{},\n\t\t\tvalid:  true,\n\t\t\tresult: &testExpiry0,\n\t\t},\n\t\t{\n\t\t\tdata:   []byte{0x1, 0x1c},\n\t\t\tvalid:  true,\n\t\t\tresult: &testExpiry60,\n\t\t},\n\t\t{\n\t\t\tdata: []byte{\n\t\t\t\t0x0, 0x1, 0x2, 0x3, 0x4, 0x5,\n\t\t\t\t0x6, 0x7, 0x8, 0x9, 0xa, 0xb,\n\t\t\t\t0xc, 0x3,\n\t\t\t},\n\t\t\tvalid: false, // data too long\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\texpiry, err := parseExpiry(test.data)\n\t\tif (err == nil) != test.valid {\n\t\t\tt.Errorf(\"expiry decoding test %d failed: %v\", i, err)\n\t\t\treturn\n\t\t}\n\t\tif test.valid && !reflect.DeepEqual(expiry, test.result) {\n\t\t\tt.Fatalf(\"test %d failed decoding expiry: \"+\n\t\t\t\t\"expected expiry %v, got %v\",\n\t\t\t\ti, *test.result, *expiry)\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// TestParseMinFinalCLTVExpiry checks that the minFinalCLTVExpiry is properly\n// parsed.",
      "length": 814,
      "tokens": 117,
      "embedding": []
    },
    {
      "slug": "func TestParseMinFinalCLTVExpiry(t *testing.T) {",
      "content": "func TestParseMinFinalCLTVExpiry(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tdata   []byte\n\t\tvalid  bool\n\t\tresult uint64\n\t}{\n\t\t{\n\t\t\tdata:   []byte{},\n\t\t\tvalid:  true,\n\t\t\tresult: 0,\n\t\t},\n\t\t{\n\t\t\tdata:   []byte{0x1, 0x1c},\n\t\t\tvalid:  true,\n\t\t\tresult: 60,\n\t\t},\n\t\t{\n\t\t\tdata: []byte{\n\t\t\t\t0x1, 0x2, 0x3, 0x4, 0x5,\n\t\t\t\t0x6, 0x7, 0x8, 0x9, 0xa,\n\t\t\t\t0xb, 0xc,\n\t\t\t},\n\t\t\tvalid:  true,\n\t\t\tresult: 38390726480144748,\n\t\t},\n\t\t{\n\t\t\tdata: []byte{\n\t\t\t\t0x0, 0x1, 0x2, 0x3, 0x4, 0x5,\n\t\t\t\t0x6, 0x7, 0x8, 0x9, 0xa, 0xb,\n\t\t\t\t0xc, 0x94,\n\t\t\t},\n\t\t\tvalid: false, // data too long\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\texpiry, err := parseMinFinalCLTVExpiry(test.data)\n\t\tif (err == nil) != test.valid {\n\t\t\tt.Errorf(\"minFinalCLTVExpiry decoding test %d failed: %v\", i, err)\n\t\t\treturn\n\t\t}\n\t\tif test.valid && *expiry != test.result {\n\t\t\tt.Fatalf(\"test %d failed decoding minFinalCLTVExpiry: \"+\n\t\t\t\t\"expected %d, got %d\",\n\t\t\t\ti, test.result, *expiry)\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// TestParseMinFinalCLTVExpiry tests that were able to properly encode/decode\n// the math.MaxUint64 integer without panicking.",
      "length": 976,
      "tokens": 143,
      "embedding": []
    },
    {
      "slug": "func TestParseMaxUint64Expiry(t *testing.T) {",
      "content": "func TestParseMaxUint64Expiry(t *testing.T) {\n\tt.Parallel()\n\n\texpiry := uint64(math.MaxUint64)\n\n\texpiryBytes := uint64ToBase32(expiry)\n\n\texpiryReParse, err := base32ToUint64(expiryBytes)\n\trequire.NoError(t, err, \"unable to parse uint64\")\n\n\tif expiryReParse != expiry {\n\t\tt.Fatalf(\"wrong expiry: expected %v got %v\", expiry,\n\t\t\texpiryReParse)\n\t}\n}\n\n// TestParseFallbackAddr checks that the fallback address is properly parsed.",
      "length": 364,
      "tokens": 42,
      "embedding": []
    },
    {
      "slug": "func TestParseFallbackAddr(t *testing.T) {",
      "content": "func TestParseFallbackAddr(t *testing.T) {\n\tt.Parallel()\n\n\ttestAddrTestnetData, _ := bech32.ConvertBits(testAddrTestnet.ScriptAddress(), 8, 5, true)\n\ttestAddrTestnetDataWithVersion := append([]byte{17}, testAddrTestnetData...)\n\n\ttestRustyAddrData, _ := bech32.ConvertBits(testRustyAddr.ScriptAddress(), 8, 5, true)\n\ttestRustyAddrDataWithVersion := append([]byte{17}, testRustyAddrData...)\n\n\ttestAddrMainnetP2SHData, _ := bech32.ConvertBits(testAddrMainnetP2SH.ScriptAddress(), 8, 5, true)\n\ttestAddrMainnetP2SHDataWithVersion := append([]byte{18}, testAddrMainnetP2SHData...)\n\n\ttestAddrMainnetP2WPKHData, _ := bech32.ConvertBits(testAddrMainnetP2WPKH.ScriptAddress(), 8, 5, true)\n\ttestAddrMainnetP2WPKHDataWithVersion := append([]byte{0}, testAddrMainnetP2WPKHData...)\n\n\ttestAddrMainnetP2WSHData, _ := bech32.ConvertBits(testAddrMainnetP2WSH.ScriptAddress(), 8, 5, true)\n\ttestAddrMainnetP2WSHDataWithVersion := append([]byte{0}, testAddrMainnetP2WSHData...)\n\n\ttests := []struct {\n\t\tdata   []byte\n\t\tnet    *chaincfg.Params\n\t\tvalid  bool\n\t\tresult btcutil.Address\n\t}{\n\t\t{\n\t\t\tdata:  []byte{},\n\t\t\tvalid: false, // empty data\n\t\t},\n\t\t{\n\t\t\tdata:  []byte{0x0},\n\t\t\tvalid: false, // data too short, version without address\n\t\t},\n\t\t{\n\t\t\tdata:   testAddrTestnetDataWithVersion,\n\t\t\tnet:    &chaincfg.TestNet3Params,\n\t\t\tvalid:  true,\n\t\t\tresult: testAddrTestnet,\n\t\t},\n\t\t{\n\t\t\tdata:   testRustyAddrDataWithVersion,\n\t\t\tnet:    &chaincfg.MainNetParams,\n\t\t\tvalid:  true,\n\t\t\tresult: testRustyAddr,\n\t\t},\n\t\t{\n\t\t\tdata:   testAddrMainnetP2SHDataWithVersion,\n\t\t\tnet:    &chaincfg.MainNetParams,\n\t\t\tvalid:  true,\n\t\t\tresult: testAddrMainnetP2SH,\n\t\t},\n\t\t{\n\t\t\tdata:   testAddrMainnetP2WPKHDataWithVersion,\n\t\t\tnet:    &chaincfg.MainNetParams,\n\t\t\tvalid:  true,\n\t\t\tresult: testAddrMainnetP2WPKH,\n\t\t},\n\t\t{\n\t\t\tdata:   testAddrMainnetP2WSHDataWithVersion,\n\t\t\tnet:    &chaincfg.MainNetParams,\n\t\t\tvalid:  true,\n\t\t\tresult: testAddrMainnetP2WSH,\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\tfallbackAddr, err := parseFallbackAddr(test.data, test.net)\n\t\tif (err == nil) != test.valid {\n\t\t\tt.Errorf(\"fallback addr decoding test %d failed: %v\", i, err)\n\t\t\treturn\n\t\t}\n\t\tif test.valid && !reflect.DeepEqual(test.result, fallbackAddr) {\n\t\t\tt.Fatalf(\"test %d failed decoding fallback addr: \"+\n\t\t\t\t\"expected %v, got %v\",\n\t\t\t\ti, test.result, fallbackAddr)\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// TestParseRouteHint checks that the routing info is properly parsed.",
      "length": 2269,
      "tokens": 206,
      "embedding": []
    },
    {
      "slug": "func TestParseRouteHint(t *testing.T) {",
      "content": "func TestParseRouteHint(t *testing.T) {\n\tt.Parallel()\n\n\tvar testSingleHopData []byte\n\tfor _, r := range testSingleHop {\n\t\tbase256 := make([]byte, 51)\n\t\tcopy(base256[:33], r.NodeID.SerializeCompressed())\n\t\tbinary.BigEndian.PutUint64(base256[33:41], r.ChannelID)\n\t\tbinary.BigEndian.PutUint32(base256[41:45], r.FeeBaseMSat)\n\t\tbinary.BigEndian.PutUint32(base256[45:49], r.FeeProportionalMillionths)\n\t\tbinary.BigEndian.PutUint16(base256[49:51], r.CLTVExpiryDelta)\n\t\ttestSingleHopData = append(testSingleHopData, base256...)\n\t}\n\ttestSingleHopData, _ = bech32.ConvertBits(testSingleHopData, 8, 5, true)\n\n\tvar testDoubleHopData []byte\n\tfor _, r := range testDoubleHop {\n\t\tbase256 := make([]byte, 51)\n\t\tcopy(base256[:33], r.NodeID.SerializeCompressed())\n\t\tbinary.BigEndian.PutUint64(base256[33:41], r.ChannelID)\n\t\tbinary.BigEndian.PutUint32(base256[41:45], r.FeeBaseMSat)\n\t\tbinary.BigEndian.PutUint32(base256[45:49], r.FeeProportionalMillionths)\n\t\tbinary.BigEndian.PutUint16(base256[49:51], r.CLTVExpiryDelta)\n\t\ttestDoubleHopData = append(testDoubleHopData, base256...)\n\t}\n\ttestDoubleHopData, _ = bech32.ConvertBits(testDoubleHopData, 8, 5, true)\n\n\ttests := []struct {\n\t\tdata   []byte\n\t\tvalid  bool\n\t\tresult []HopHint\n\t}{\n\t\t{\n\t\t\tdata:  []byte{0x0, 0x0, 0x0, 0x0},\n\t\t\tvalid: false, // data too short, not multiple of 51 bytes\n\t\t},\n\t\t{\n\t\t\tdata:   []byte{},\n\t\t\tvalid:  true,\n\t\t\tresult: []HopHint{},\n\t\t},\n\t\t{\n\t\t\tdata:   testSingleHopData,\n\t\t\tvalid:  true,\n\t\t\tresult: testSingleHop,\n\t\t},\n\t\t{\n\t\t\tdata:  append(testSingleHopData, 0x0),\n\t\t\tvalid: false, // data too long, not multiple of 51 bytes\n\t\t},\n\t\t{\n\t\t\tdata:   testDoubleHopData,\n\t\t\tvalid:  true,\n\t\t\tresult: testDoubleHop,\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\trouteHint, err := parseRouteHint(test.data)\n\t\tif (err == nil) != test.valid {\n\t\t\tt.Errorf(\"routing info decoding test %d failed: %v\", i, err)\n\t\t\treturn\n\t\t}\n\t\tif test.valid {\n\t\t\tif err := compareRouteHints(test.result, routeHint); err != nil {\n\t\t\t\tt.Fatalf(\"test %d failed decoding routing info: %v\", i, err)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// TestParseTaggedFields checks that tagged field data is correctly parsed or\n// errors as expected.",
      "length": 2015,
      "tokens": 212,
      "embedding": []
    },
    {
      "slug": "func TestParseTaggedFields(t *testing.T) {",
      "content": "func TestParseTaggedFields(t *testing.T) {\n\tt.Parallel()\n\n\tnetParams := &chaincfg.SimNetParams\n\n\ttests := []struct {\n\t\tname    string\n\t\tdata    []byte\n\t\twantErr error\n\t}{\n\t\t{\n\t\t\tname: \"nil data\",\n\t\t\tdata: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"empty data\",\n\t\t\tdata: []byte{},\n\t\t},\n\t\t{\n\t\t\t// Type 0xff cannot be encoded in a single 5-bit\n\t\t\t// element, so it's technically invalid but\n\t\t\t// parseTaggedFields doesn't error on non-5bpp\n\t\t\t// compatible codes so we can use a code in tests which\n\t\t\t// will never become known in the future.\n\t\t\tname: \"valid unknown field\",\n\t\t\tdata: []byte{0xff, 0x00, 0x00},\n\t\t},\n\t\t{\n\t\t\tname: \"unknown field valid data\",\n\t\t\tdata: []byte{0xff, 0x00, 0x01, 0xab},\n\t\t},\n\t\t{\n\t\t\tname:    \"only type specified\",\n\t\t\tdata:    []byte{0x0d},\n\t\t\twantErr: ErrBrokenTaggedField,\n\t\t},\n\t\t{\n\t\t\tname:    \"not enough bytes for len\",\n\t\t\tdata:    []byte{0x0d, 0x00},\n\t\t\twantErr: ErrBrokenTaggedField,\n\t\t},\n\t\t{\n\t\t\tname:    \"no bytes after len\",\n\t\t\tdata:    []byte{0x0d, 0x00, 0x01},\n\t\t\twantErr: ErrInvalidFieldLength,\n\t\t},\n\t\t{\n\t\t\tname:    \"not enough bytes after len\",\n\t\t\tdata:    []byte{0x0d, 0x00, 0x02, 0x01},\n\t\t\twantErr: ErrInvalidFieldLength,\n\t\t},\n\t\t{\n\t\t\tname:    \"not enough bytes after len with unknown type\",\n\t\t\tdata:    []byte{0xff, 0x00, 0x02, 0x01},\n\t\t\twantErr: ErrInvalidFieldLength,\n\t\t},\n\t}\n\tfor _, tc := range tests {\n\t\ttc := tc // pin\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tvar invoice Invoice\n\t\t\tgotErr := parseTaggedFields(&invoice, tc.data, netParams)\n\t\t\tif tc.wantErr != gotErr {\n\t\t\t\tt.Fatalf(\"Unexpected error. want=%v got=%v\",\n\t\t\t\t\ttc.wantErr, gotErr)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "length": 1473,
      "tokens": 203,
      "embedding": []
    }
  ]
}