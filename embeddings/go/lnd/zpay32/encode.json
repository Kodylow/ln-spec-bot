{
  "filepath": "../implementations/go/lnd/zpay32/encode.go",
  "package": "zpay32",
  "sections": [
    {
      "slug": "func (invoice *Invoice) Encode(signer MessageSigner) (string, error) {",
      "content": "func (invoice *Invoice) Encode(signer MessageSigner) (string, error) {\n\t// First check that this invoice is valid before starting the encoding.\n\tif err := validateInvoice(invoice); err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// The buffer will encoded the invoice data using 5-bit groups (base32).\n\tvar bufferBase32 bytes.Buffer\n\n\t// The timestamp will be encoded using 35 bits, in base32.\n\ttimestampBase32 := uint64ToBase32(uint64(invoice.Timestamp.Unix()))\n\n\t// The timestamp must be exactly 35 bits, which means 7 groups. If it\n\t// can fit into fewer groups we add leading zero groups, if it is too\n\t// big we fail early, as there is not possible to encode it.\n\tif len(timestampBase32) > timestampBase32Len {\n\t\treturn \"\", fmt.Errorf(\"timestamp too big: %d\",\n\t\t\tinvoice.Timestamp.Unix())\n\t}\n\n\t// Add zero bytes to the first timestampBase32Len-len(timestampBase32)\n\t// groups, then add the non-zero groups.\n\tzeroes := make([]byte, timestampBase32Len-len(timestampBase32))\n\t_, err := bufferBase32.Write(zeroes)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"unable to write to buffer: %v\", err)\n\t}\n\t_, err = bufferBase32.Write(timestampBase32)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"unable to write to buffer: %v\", err)\n\t}\n\n\t// We now write the tagged fields to the buffer, which will fill the\n\t// rest of the data part before the signature.\n\tif err := writeTaggedFields(&bufferBase32, invoice); err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// The human-readable part (hrp) is \"ln\" + net hrp + optional amount,\n\t// except for signet where we add an additional \"s\" to differentiate it\n\t// from the older testnet3 (Core devs decided to use the same hrp for\n\t// signet as for testnet3 which is not optimal for LN). See\n\t// https://github.com/lightningnetwork/lightning-rfc/pull/844 for more\n\t// information.\n\thrp := \"ln\" + invoice.Net.Bech32HRPSegwit\n\tif invoice.Net.Name == chaincfg.SigNetParams.Name {\n\t\thrp = \"lntbs\"\n\t}\n\tif invoice.MilliSat != nil {\n\t\t// Encode the amount using the fewest possible characters.\n\t\tam, err := encodeAmount(*invoice.MilliSat)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\thrp += am\n\t}\n\n\t// The signature is over the single SHA-256 hash of the hrp + the\n\t// tagged fields encoded in base256.\n\ttaggedFieldsBytes, err := bech32.ConvertBits(bufferBase32.Bytes(), 5, 8, true)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\ttoSign := append([]byte(hrp), taggedFieldsBytes...)\n\n\t// We use compact signature format, and also encoded the recovery ID\n\t// such that a reader of the invoice can recover our pubkey from the\n\t// signature.\n\tsign, err := signer.SignCompact(toSign)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// From the header byte we can extract the recovery ID, and the last 64\n\t// bytes encode the signature.\n\trecoveryID := sign[0] - 27 - 4\n\tvar sig lnwire.Sig\n\tcopy(sig[:], sign[1:])\n\n\t// If the pubkey field was explicitly set, it must be set to the pubkey\n\t// used to create the signature.\n\tif invoice.Destination != nil {\n\t\tsignature, err := sig.ToSignature()\n\t\tif err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"unable to deserialize \"+\n\t\t\t\t\"signature: %v\", err)\n\t\t}\n\n\t\thash := chainhash.HashB(toSign)\n\t\tvalid := signature.Verify(hash, invoice.Destination)\n\t\tif !valid {\n\t\t\treturn \"\", fmt.Errorf(\"signature does not match \" +\n\t\t\t\t\"provided pubkey\")\n\t\t}\n\t}\n\n\t// Convert the signature to base32 before writing it to the buffer.\n\tsignBase32, err := bech32.ConvertBits(append(sig[:], recoveryID), 8, 5, true)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tbufferBase32.Write(signBase32)\n\n\t// Now we can create the bech32 encoded string from the base32 buffer.\n\tb32, err := bech32.Encode(hrp, bufferBase32.Bytes())\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Before returning, check that the bech32 encoded string is not greater\n\t// than our largest supported invoice size.\n\tif len(b32) > maxInvoiceLength {\n\t\treturn \"\", ErrInvoiceTooLarge\n\t}\n\n\treturn b32, nil\n}\n\n// writeTaggedFields writes the non-nil tagged fields of the Invoice to the\n// base32 buffer.",
      "length": 3745,
      "tokens": 588,
      "embedding": []
    },
    {
      "slug": "func writeTaggedFields(bufferBase32 *bytes.Buffer, invoice *Invoice) error {",
      "content": "func writeTaggedFields(bufferBase32 *bytes.Buffer, invoice *Invoice) error {\n\tif invoice.PaymentHash != nil {\n\t\terr := writeBytes32(bufferBase32, fieldTypeP, *invoice.PaymentHash)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif invoice.Description != nil {\n\t\tbase32, err := bech32.ConvertBits([]byte(*invoice.Description),\n\t\t\t8, 5, true)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = writeTaggedField(bufferBase32, fieldTypeD, base32)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif invoice.DescriptionHash != nil {\n\t\terr := writeBytes32(\n\t\t\tbufferBase32, fieldTypeH, *invoice.DescriptionHash,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif invoice.Metadata != nil {\n\t\tbase32, err := bech32.ConvertBits(invoice.Metadata, 8, 5, true)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = writeTaggedField(bufferBase32, fieldTypeM, base32)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif invoice.minFinalCLTVExpiry != nil {\n\t\tfinalDelta := uint64ToBase32(*invoice.minFinalCLTVExpiry)\n\t\terr := writeTaggedField(bufferBase32, fieldTypeC, finalDelta)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif invoice.expiry != nil {\n\t\tseconds := invoice.expiry.Seconds()\n\t\texpiry := uint64ToBase32(uint64(seconds))\n\t\terr := writeTaggedField(bufferBase32, fieldTypeX, expiry)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif invoice.FallbackAddr != nil {\n\t\tvar version byte\n\t\tswitch addr := invoice.FallbackAddr.(type) {\n\t\tcase *btcutil.AddressPubKeyHash:\n\t\t\tversion = 17\n\t\tcase *btcutil.AddressScriptHash:\n\t\t\tversion = 18\n\t\tcase *btcutil.AddressWitnessPubKeyHash:\n\t\t\tversion = addr.WitnessVersion()\n\t\tcase *btcutil.AddressWitnessScriptHash:\n\t\t\tversion = addr.WitnessVersion()\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"unknown fallback address type\")\n\t\t}\n\t\tbase32Addr, err := bech32.ConvertBits(\n\t\t\tinvoice.FallbackAddr.ScriptAddress(), 8, 5, true)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = writeTaggedField(bufferBase32, fieldTypeF,\n\t\t\tappend([]byte{version}, base32Addr...))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tfor _, routeHint := range invoice.RouteHints {\n\t\t// Each hop hint is encoded using 51 bytes, so we'll make to\n\t\t// sure to allocate enough space for the whole route hint.\n\t\trouteHintBase256 := make([]byte, 0, hopHintLen*len(routeHint))\n\n\t\tfor _, hopHint := range routeHint {\n\t\t\thopHintBase256 := make([]byte, hopHintLen)\n\t\t\tcopy(hopHintBase256[:33], hopHint.NodeID.SerializeCompressed())\n\t\t\tbinary.BigEndian.PutUint64(\n\t\t\t\thopHintBase256[33:41], hopHint.ChannelID,\n\t\t\t)\n\t\t\tbinary.BigEndian.PutUint32(\n\t\t\t\thopHintBase256[41:45], hopHint.FeeBaseMSat,\n\t\t\t)\n\t\t\tbinary.BigEndian.PutUint32(\n\t\t\t\thopHintBase256[45:49], hopHint.FeeProportionalMillionths,\n\t\t\t)\n\t\t\tbinary.BigEndian.PutUint16(\n\t\t\t\thopHintBase256[49:51], hopHint.CLTVExpiryDelta,\n\t\t\t)\n\t\t\trouteHintBase256 = append(routeHintBase256, hopHintBase256...)\n\t\t}\n\n\t\trouteHintBase32, err := bech32.ConvertBits(\n\t\t\trouteHintBase256, 8, 5, true,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = writeTaggedField(bufferBase32, fieldTypeR, routeHintBase32)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif invoice.Destination != nil {\n\t\t// Convert 33 byte pubkey to 53 5-bit groups.\n\t\tpubKeyBase32, err := bech32.ConvertBits(\n\t\t\tinvoice.Destination.SerializeCompressed(), 8, 5, true)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif len(pubKeyBase32) != pubKeyBase32Len {\n\t\t\treturn fmt.Errorf(\"invalid pubkey length: %d\",\n\t\t\t\tlen(invoice.Destination.SerializeCompressed()))\n\t\t}\n\n\t\terr = writeTaggedField(bufferBase32, fieldTypeN, pubKeyBase32)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif invoice.PaymentAddr != nil {\n\t\terr := writeBytes32(\n\t\t\tbufferBase32, fieldTypeS, *invoice.PaymentAddr,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif invoice.Features.SerializeSize32() > 0 {\n\t\tvar b bytes.Buffer\n\t\terr := invoice.Features.RawFeatureVector.EncodeBase32(&b)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = writeTaggedField(bufferBase32, fieldType9, b.Bytes())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// writeBytes32 encodes a 32-byte array as base32 and writes it to bufferBase32\n// under the passed fieldType.",
      "length": 3778,
      "tokens": 458,
      "embedding": []
    },
    {
      "slug": "func writeBytes32(bufferBase32 *bytes.Buffer, fieldType byte, b [32]byte) error {",
      "content": "func writeBytes32(bufferBase32 *bytes.Buffer, fieldType byte, b [32]byte) error {\n\t// Convert 32 byte hash to 52 5-bit groups.\n\tbase32, err := bech32.ConvertBits(b[:], 8, 5, true)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn writeTaggedField(bufferBase32, fieldType, base32)\n}\n\n// writeTaggedField takes the type of a tagged data field, and the data of\n// the tagged field (encoded in base32), and writes the type, length and data\n// to the buffer.",
      "length": 352,
      "tokens": 61,
      "embedding": []
    },
    {
      "slug": "func writeTaggedField(bufferBase32 *bytes.Buffer, dataType byte, data []byte) error {",
      "content": "func writeTaggedField(bufferBase32 *bytes.Buffer, dataType byte, data []byte) error {\n\t// Length must be exactly 10 bits, so add leading zero groups if\n\t// needed.\n\tlenBase32 := uint64ToBase32(uint64(len(data)))\n\tfor len(lenBase32) < 2 {\n\t\tlenBase32 = append([]byte{0}, lenBase32...)\n\t}\n\n\tif len(lenBase32) != 2 {\n\t\treturn fmt.Errorf(\"data length too big to fit within 10 bits: %d\",\n\t\t\tlen(data))\n\t}\n\n\terr := bufferBase32.WriteByte(dataType)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to write to buffer: %v\", err)\n\t}\n\t_, err = bufferBase32.Write(lenBase32)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to write to buffer: %v\", err)\n\t}\n\t_, err = bufferBase32.Write(data)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to write to buffer: %v\", err)\n\t}\n\n\treturn nil\n}\n\n// uint64ToBase32 converts a uint64 to a base32 encoded integer encoded using\n// as few 5-bit groups as possible.",
      "length": 765,
      "tokens": 121,
      "embedding": []
    },
    {
      "slug": "func uint64ToBase32(num uint64) []byte {",
      "content": "func uint64ToBase32(num uint64) []byte {\n\t// Return at least one group.\n\tif num == 0 {\n\t\treturn []byte{0}\n\t}\n\n\t// To fit an uint64, we need at most is ceil(64 / 5) = 13 groups.\n\tarr := make([]byte, 13)\n\ti := 13\n\tfor num > 0 {\n\t\ti--\n\t\tarr[i] = byte(num & uint64(31)) // 0b11111 in binary\n\t\tnum >>= 5\n\t}\n\n\t// We only return non-zero leading groups.\n\treturn arr[i:]\n}\n",
      "length": 307,
      "tokens": 66,
      "embedding": []
    }
  ]
}