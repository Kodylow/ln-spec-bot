{
  "filepath": "../implementations/go/lnd/kvdb/readwrite_bucket_test.go",
  "package": "kvdb",
  "sections": [
    {
      "slug": "func testBucketCreation(t *testing.T, db walletdb.DB) {",
      "content": "func testBucketCreation(t *testing.T, db walletdb.DB) {\n\terr := Update(db, func(tx walletdb.ReadWriteTx) error {\n\t\t// empty bucket name\n\t\tb, err := tx.CreateTopLevelBucket(nil)\n\t\trequire.Error(t, walletdb.ErrBucketNameRequired, err)\n\t\trequire.Nil(t, b)\n\n\t\t// empty bucket name\n\t\tb, err = tx.CreateTopLevelBucket([]byte(\"\"))\n\t\trequire.Error(t, walletdb.ErrBucketNameRequired, err)\n\t\trequire.Nil(t, b)\n\n\t\t// \"apple\"\n\t\tapple, err := tx.CreateTopLevelBucket([]byte(\"apple\"))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, apple)\n\n\t\t// Check bucket tx.\n\t\trequire.Equal(t, tx, apple.Tx())\n\n\t\t// \"apple\" already created\n\t\tb, err = tx.CreateTopLevelBucket([]byte(\"apple\"))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, b)\n\n\t\t// \"apple/banana\"\n\t\tbanana, err := apple.CreateBucket([]byte(\"banana\"))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, banana)\n\n\t\tbanana, err = apple.CreateBucketIfNotExists([]byte(\"banana\"))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, banana)\n\n\t\t// Try creating \"apple/banana\" again\n\t\tb, err = apple.CreateBucket([]byte(\"banana\"))\n\t\trequire.Error(t, walletdb.ErrBucketExists, err)\n\t\trequire.Nil(t, b)\n\n\t\t// \"apple/mango\"\n\t\tmango, err := apple.CreateBucket([]byte(\"mango\"))\n\t\trequire.Nil(t, err)\n\t\trequire.NotNil(t, mango)\n\n\t\t// \"apple/banana/pear\"\n\t\tpear, err := banana.CreateBucket([]byte(\"pear\"))\n\t\trequire.Nil(t, err)\n\t\trequire.NotNil(t, pear)\n\n\t\t// empty bucket\n\t\trequire.Nil(t, apple.NestedReadWriteBucket(nil))\n\t\trequire.Nil(t, apple.NestedReadWriteBucket([]byte(\"\")))\n\n\t\t// \"apple/pear\" doesn't exist\n\t\trequire.Nil(t, apple.NestedReadWriteBucket([]byte(\"pear\")))\n\n\t\t// \"apple/banana\" exits\n\t\trequire.NotNil(t, apple.NestedReadWriteBucket([]byte(\"banana\")))\n\t\trequire.NotNil(t, apple.NestedReadBucket([]byte(\"banana\")))\n\t\treturn nil\n\t}, func() {})\n\n\trequire.Nil(t, err)\n}\n",
      "length": 1677,
      "tokens": 142,
      "embedding": []
    },
    {
      "slug": "func testBucketDeletion(t *testing.T, db walletdb.DB) {",
      "content": "func testBucketDeletion(t *testing.T, db walletdb.DB) {\n\terr := Update(db, func(tx walletdb.ReadWriteTx) error {\n\t\t// \"apple\"\n\t\tapple, err := tx.CreateTopLevelBucket([]byte(\"apple\"))\n\t\trequire.Nil(t, err)\n\t\trequire.NotNil(t, apple)\n\n\t\t// \"apple/banana\"\n\t\tbanana, err := apple.CreateBucket([]byte(\"banana\"))\n\t\trequire.Nil(t, err)\n\t\trequire.NotNil(t, banana)\n\n\t\tkvs := []KV{{\"key1\", \"val1\"}, {\"key2\", \"val2\"}, {\"key3\", \"val3\"}}\n\n\t\tfor _, kv := range kvs {\n\t\t\trequire.NoError(t, banana.Put([]byte(kv.key), []byte(kv.val)))\n\t\t\trequire.Equal(t, []byte(kv.val), banana.Get([]byte(kv.key)))\n\t\t}\n\n\t\t// Delete a k/v from \"apple/banana\"\n\t\trequire.NoError(t, banana.Delete([]byte(\"key2\")))\n\t\t// Try getting/putting/deleting invalid k/v's.\n\t\trequire.Nil(t, banana.Get(nil))\n\t\trequire.Error(t, walletdb.ErrKeyRequired, banana.Put(nil, []byte(\"val\")))\n\t\trequire.Error(t, walletdb.ErrKeyRequired, banana.Delete(nil))\n\n\t\t// Try deleting a k/v that doesn't exist.\n\t\trequire.NoError(t, banana.Delete([]byte(\"nokey\")))\n\n\t\t// \"apple/pear\"\n\t\tpear, err := apple.CreateBucket([]byte(\"pear\"))\n\t\trequire.Nil(t, err)\n\t\trequire.NotNil(t, pear)\n\n\t\t// Put some values into \"apple/pear\"\n\t\tfor _, kv := range kvs {\n\t\t\trequire.Nil(t, pear.Put([]byte(kv.key), []byte(kv.val)))\n\t\t\trequire.Equal(t, []byte(kv.val), pear.Get([]byte(kv.key)))\n\t\t}\n\n\t\t// Create nested bucket \"apple/pear/cherry\"\n\t\tcherry, err := pear.CreateBucket([]byte(\"cherry\"))\n\t\trequire.Nil(t, err)\n\t\trequire.NotNil(t, cherry)\n\n\t\t// Put some values into \"apple/pear/cherry\"\n\t\tfor _, kv := range kvs {\n\t\t\trequire.NoError(t, cherry.Put([]byte(kv.key), []byte(kv.val)))\n\t\t}\n\n\t\t// Read back values in \"apple/pear/cherry\" trough a read bucket.\n\t\tcherryReadBucket := pear.NestedReadBucket([]byte(\"cherry\"))\n\t\tfor _, kv := range kvs {\n\t\t\trequire.Equal(\n\t\t\t\tt, []byte(kv.val),\n\t\t\t\tcherryReadBucket.Get([]byte(kv.key)),\n\t\t\t)\n\t\t}\n\n\t\t// Try deleting some invalid buckets.\n\t\trequire.Error(t,\n\t\t\twalletdb.ErrBucketNameRequired, apple.DeleteNestedBucket(nil),\n\t\t)\n\n\t\t// Try deleting a non existing bucket.\n\t\trequire.Error(\n\t\t\tt,\n\t\t\twalletdb.ErrBucketNotFound,\n\t\t\tapple.DeleteNestedBucket([]byte(\"missing\")),\n\t\t)\n\n\t\t// Delete \"apple/pear\"\n\t\trequire.Nil(t, apple.DeleteNestedBucket([]byte(\"pear\")))\n\n\t\t// \"apple/pear\" deleted\n\t\trequire.Nil(t, apple.NestedReadWriteBucket([]byte(\"pear\")))\n\n\t\t// \"aple/banana\" exists\n\t\trequire.NotNil(t, apple.NestedReadWriteBucket([]byte(\"banana\")))\n\t\treturn nil\n\t}, func() {})\n\n\trequire.Nil(t, err)\n}\n",
      "length": 2312,
      "tokens": 212,
      "embedding": []
    },
    {
      "slug": "type bucketIterator = func(walletdb.ReadWriteBucket,",
      "content": "type bucketIterator = func(walletdb.ReadWriteBucket,\n\tfunc(key, val []byte) error) error\n",
      "length": 35,
      "tokens": 5,
      "embedding": []
    },
    {
      "slug": "func testBucketForEach(t *testing.T, db walletdb.DB) {",
      "content": "func testBucketForEach(t *testing.T, db walletdb.DB) {\n\ttestBucketIterator(t, db, func(bucket walletdb.ReadWriteBucket,\n\t\tcallback func(key, val []byte) error) error {\n\n\t\treturn bucket.ForEach(callback)\n\t})\n}\n",
      "length": 148,
      "tokens": 15,
      "embedding": []
    },
    {
      "slug": "func testBucketIterator(t *testing.T, db walletdb.DB,",
      "content": "func testBucketIterator(t *testing.T, db walletdb.DB,\n\titerator bucketIterator) {\n\n\terr := Update(db, func(tx walletdb.ReadWriteTx) error {\n\t\t// \"apple\"\n\t\tapple, err := tx.CreateTopLevelBucket([]byte(\"apple\"))\n\t\trequire.Nil(t, err)\n\t\trequire.NotNil(t, apple)\n\n\t\t// \"apple/banana\"\n\t\tbanana, err := apple.CreateBucket([]byte(\"banana\"))\n\t\trequire.Nil(t, err)\n\t\trequire.NotNil(t, banana)\n\n\t\tkvs := []KV{{\"key1\", \"val1\"}, {\"key2\", \"val2\"}, {\"key3\", \"val3\"}}\n\n\t\t// put some values into \"apple\" and \"apple/banana\" too\n\t\tfor _, kv := range kvs {\n\t\t\trequire.Nil(t, apple.Put([]byte(kv.key), []byte(kv.val)))\n\t\t\trequire.Equal(t, []byte(kv.val), apple.Get([]byte(kv.key)))\n\n\t\t\trequire.Nil(t, banana.Put([]byte(kv.key), []byte(kv.val)))\n\t\t\trequire.Equal(t, []byte(kv.val), banana.Get([]byte(kv.key)))\n\t\t}\n\n\t\tgot := make(map[string]string)\n\t\terr = apple.ForEach(func(key, val []byte) error {\n\t\t\tgot[string(key)] = string(val)\n\t\t\treturn nil\n\t\t})\n\n\t\texpected := map[string]string{\n\t\t\t\"key1\":   \"val1\",\n\t\t\t\"key2\":   \"val2\",\n\t\t\t\"key3\":   \"val3\",\n\t\t\t\"banana\": \"\",\n\t\t}\n\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, expected, got)\n\n\t\tgot = make(map[string]string)\n\t\terr = iterator(banana, func(key, val []byte) error {\n\t\t\tgot[string(key)] = string(val)\n\t\t\treturn nil\n\t\t})\n\n\t\trequire.NoError(t, err)\n\t\t// remove the sub-bucket key\n\t\tdelete(expected, \"banana\")\n\t\trequire.Equal(t, expected, got)\n\n\t\treturn nil\n\t}, func() {})\n\n\trequire.Nil(t, err)\n}\n",
      "length": 1316,
      "tokens": 137,
      "embedding": []
    },
    {
      "slug": "func testBucketForEachWithError(t *testing.T, db walletdb.DB) {",
      "content": "func testBucketForEachWithError(t *testing.T, db walletdb.DB) {\n\terr := Update(db, func(tx walletdb.ReadWriteTx) error {\n\t\t// \"apple\"\n\t\tapple, err := tx.CreateTopLevelBucket([]byte(\"apple\"))\n\t\trequire.Nil(t, err)\n\t\trequire.NotNil(t, apple)\n\n\t\t// \"apple/banana\"\n\t\tbanana, err := apple.CreateBucket([]byte(\"banana\"))\n\t\trequire.Nil(t, err)\n\t\trequire.NotNil(t, banana)\n\n\t\t// \"apple/pear\"\n\t\tpear, err := apple.CreateBucket([]byte(\"pear\"))\n\t\trequire.Nil(t, err)\n\t\trequire.NotNil(t, pear)\n\n\t\tkvs := []KV{{\"key1\", \"val1\"}, {\"key2\", \"val2\"}}\n\n\t\t// Put some values into \"apple\" and \"apple/banana\" too.\n\t\tfor _, kv := range kvs {\n\t\t\trequire.Nil(t, apple.Put([]byte(kv.key), []byte(kv.val)))\n\t\t\trequire.Equal(t, []byte(kv.val), apple.Get([]byte(kv.key)))\n\t\t}\n\n\t\tgot := make(map[string]string)\n\t\ti := 0\n\t\t// Error while iterating value keys.\n\t\terr = apple.ForEach(func(key, val []byte) error {\n\t\t\tif i == 2 {\n\t\t\t\treturn fmt.Errorf(\"error\")\n\t\t\t}\n\n\t\t\tgot[string(key)] = string(val)\n\t\t\ti++\n\t\t\treturn nil\n\t\t})\n\n\t\texpected := map[string]string{\n\t\t\t\"banana\": \"\",\n\t\t\t\"key1\":   \"val1\",\n\t\t}\n\n\t\trequire.Equal(t, expected, got)\n\t\trequire.Error(t, err)\n\n\t\tgot = make(map[string]string)\n\t\ti = 0\n\t\t// Erro while iterating buckets.\n\t\terr = apple.ForEach(func(key, val []byte) error {\n\t\t\tif i == 3 {\n\t\t\t\treturn fmt.Errorf(\"error\")\n\t\t\t}\n\n\t\t\tgot[string(key)] = string(val)\n\t\t\ti++\n\t\t\treturn nil\n\t\t})\n\n\t\texpected = map[string]string{\n\t\t\t\"banana\": \"\",\n\t\t\t\"key1\":   \"val1\",\n\t\t\t\"key2\":   \"val2\",\n\t\t}\n\n\t\trequire.Equal(t, expected, got)\n\t\trequire.Error(t, err)\n\t\treturn nil\n\t}, func() {})\n\n\trequire.Nil(t, err)\n}\n",
      "length": 1440,
      "tokens": 169,
      "embedding": []
    },
    {
      "slug": "func testBucketSequence(t *testing.T, db walletdb.DB) {",
      "content": "func testBucketSequence(t *testing.T, db walletdb.DB) {\n\terr := Update(db, func(tx walletdb.ReadWriteTx) error {\n\t\tapple, err := tx.CreateTopLevelBucket([]byte(\"apple\"))\n\t\trequire.Nil(t, err)\n\t\trequire.NotNil(t, apple)\n\n\t\tbanana, err := apple.CreateBucket([]byte(\"banana\"))\n\t\trequire.Nil(t, err)\n\t\trequire.NotNil(t, banana)\n\n\t\trequire.Equal(t, uint64(0), apple.Sequence())\n\t\trequire.Equal(t, uint64(0), banana.Sequence())\n\n\t\trequire.Nil(t, apple.SetSequence(math.MaxUint64))\n\t\trequire.Equal(t, uint64(math.MaxUint64), apple.Sequence())\n\n\t\tfor i := uint64(0); i < uint64(5); i++ {\n\t\t\ts, err := apple.NextSequence()\n\t\t\trequire.Nil(t, err)\n\t\t\trequire.Equal(t, i, s)\n\t\t}\n\n\t\treturn nil\n\t}, func() {})\n\n\trequire.Nil(t, err)\n}\n\n// TestKeyClash tests that one cannot create a bucket if a value with the same\n// key exists and the same is true in reverse: that a value cannot be put if\n// a bucket with the same key exists.",
      "length": 829,
      "tokens": 101,
      "embedding": []
    },
    {
      "slug": "func testKeyClash(t *testing.T, db walletdb.DB) {",
      "content": "func testKeyClash(t *testing.T, db walletdb.DB) {\n\t// First:\n\t// put: /apple/key -> val\n\t// create bucket: /apple/banana\n\terr := Update(db, func(tx walletdb.ReadWriteTx) error {\n\t\tapple, err := tx.CreateTopLevelBucket([]byte(\"apple\"))\n\t\trequire.Nil(t, err)\n\t\trequire.NotNil(t, apple)\n\n\t\trequire.NoError(t, apple.Put([]byte(\"key\"), []byte(\"val\")))\n\n\t\tbanana, err := apple.CreateBucket([]byte(\"banana\"))\n\t\trequire.Nil(t, err)\n\t\trequire.NotNil(t, banana)\n\n\t\treturn nil\n\t}, func() {})\n\n\trequire.Nil(t, err)\n\n\t// Next try to:\n\t// put: /apple/banana -> val => will fail (as /apple/banana is a bucket)\n\t// create bucket: /apple/key => will fail (as /apple/key is a value)\n\terr = Update(db, func(tx walletdb.ReadWriteTx) error {\n\t\tapple, err := tx.CreateTopLevelBucket([]byte(\"apple\"))\n\t\trequire.Nil(t, err)\n\t\trequire.NotNil(t, apple)\n\n\t\trequire.Error(t,\n\t\t\twalletdb.ErrIncompatibleValue,\n\t\t\tapple.Put([]byte(\"banana\"), []byte(\"val\")),\n\t\t)\n\n\t\tb, err := apple.CreateBucket([]byte(\"key\"))\n\t\trequire.Nil(t, b)\n\t\trequire.Error(t, walletdb.ErrIncompatibleValue, b)\n\n\t\tb, err = apple.CreateBucketIfNotExists([]byte(\"key\"))\n\t\trequire.Nil(t, b)\n\t\trequire.Error(t, walletdb.ErrIncompatibleValue, b)\n\n\t\treturn nil\n\t}, func() {})\n\n\trequire.Nil(t, err)\n}\n\n// TestBucketCreateDelete tests that creating then deleting then creating a\n// bucket suceeds.",
      "length": 1233,
      "tokens": 132,
      "embedding": []
    },
    {
      "slug": "func testBucketCreateDelete(t *testing.T, db walletdb.DB) {",
      "content": "func testBucketCreateDelete(t *testing.T, db walletdb.DB) {\n\terr := Update(db, func(tx walletdb.ReadWriteTx) error {\n\t\tapple, err := tx.CreateTopLevelBucket([]byte(\"apple\"))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, apple)\n\n\t\tbanana, err := apple.CreateBucket([]byte(\"banana\"))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, banana)\n\n\t\treturn nil\n\t}, func() {})\n\trequire.NoError(t, err)\n\n\terr = Update(db, func(tx walletdb.ReadWriteTx) error {\n\t\tapple := tx.ReadWriteBucket([]byte(\"apple\"))\n\t\trequire.NotNil(t, apple)\n\t\trequire.NoError(t, apple.DeleteNestedBucket([]byte(\"banana\")))\n\n\t\treturn nil\n\t}, func() {})\n\trequire.NoError(t, err)\n\n\terr = Update(db, func(tx walletdb.ReadWriteTx) error {\n\t\tapple := tx.ReadWriteBucket([]byte(\"apple\"))\n\t\trequire.NotNil(t, apple)\n\t\trequire.NoError(t, apple.Put([]byte(\"banana\"), []byte(\"value\")))\n\n\t\treturn nil\n\t}, func() {})\n\trequire.NoError(t, err)\n}\n",
      "length": 803,
      "tokens": 74,
      "embedding": []
    },
    {
      "slug": "func testTopLevelBucketCreation(t *testing.T, db walletdb.DB) {",
      "content": "func testTopLevelBucketCreation(t *testing.T, db walletdb.DB) {\n\trequire.NoError(t, Update(db, func(tx walletdb.ReadWriteTx) error {\n\t\t// Try to delete all data (there is none).\n\t\terr := tx.DeleteTopLevelBucket([]byte(\"top\"))\n\t\trequire.ErrorIs(t, walletdb.ErrBucketNotFound, err)\n\n\t\t// Create top level bucket.\n\t\ttop, err := tx.CreateTopLevelBucket([]byte(\"top\"))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, top)\n\n\t\t// Create second top level bucket with special characters.\n\t\ttop2, err := tx.CreateTopLevelBucket([]byte{1, 2, 3})\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, top2)\n\n\t\ttop2 = tx.ReadWriteBucket([]byte{1, 2, 3})\n\t\trequire.NotNil(t, top2)\n\n\t\t// List top level buckets.\n\t\tvar tlKeys [][]byte\n\t\trequire.NoError(t, tx.ForEachBucket(func(k []byte) error {\n\t\t\ttlKeys = append(tlKeys, k)\n\t\t\treturn nil\n\t\t}))\n\t\trequire.Equal(t, [][]byte{{1, 2, 3}, []byte(\"top\")}, tlKeys)\n\n\t\t// Create third top level bucket with special uppercase.\n\t\ttop3, err := tx.CreateTopLevelBucket([]byte(\"UpperBucket\"))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, top3)\n\n\t\ttop3 = tx.ReadWriteBucket([]byte(\"UpperBucket\"))\n\t\trequire.NotNil(t, top3)\n\n\t\trequire.NoError(t, tx.DeleteTopLevelBucket([]byte(\"top\")))\n\t\trequire.NoError(t, tx.DeleteTopLevelBucket([]byte{1, 2, 3}))\n\t\trequire.NoError(t, tx.DeleteTopLevelBucket([]byte(\"UpperBucket\")))\n\n\t\ttx.ForEachBucket(func(k []byte) error {\n\t\t\trequire.Fail(t, \"no top level buckets expected\")\n\t\t\treturn nil\n\t\t})\n\n\t\treturn nil\n\t}, func() {}))\n}\n",
      "length": 1365,
      "tokens": 135,
      "embedding": []
    },
    {
      "slug": "func testBucketOperations(t *testing.T, db walletdb.DB) {",
      "content": "func testBucketOperations(t *testing.T, db walletdb.DB) {\n\trequire.NoError(t, Update(db, func(tx walletdb.ReadWriteTx) error {\n\t\t// Create top level bucket.\n\t\ttop, err := tx.CreateTopLevelBucket([]byte(\"top\"))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, top)\n\n\t\t// Assert that key doesn't exist.\n\t\trequire.Nil(t, top.Get([]byte(\"key\")))\n\n\t\trequire.NoError(t, top.ForEach(func(k, v []byte) error {\n\t\t\trequire.Fail(t, \"unexpected data\")\n\t\t\treturn nil\n\t\t}))\n\n\t\t// Put key.\n\t\trequire.NoError(t, top.Put([]byte(\"key\"), []byte(\"val\")))\n\t\trequire.Equal(t, []byte(\"val\"), top.Get([]byte(\"key\")))\n\n\t\t// Overwrite key.\n\t\trequire.NoError(t, top.Put([]byte(\"key\"), []byte(\"val2\")))\n\t\trequire.Equal(t, []byte(\"val2\"), top.Get([]byte(\"key\")))\n\n\t\t// Put nil value.\n\t\trequire.NoError(t, top.Put([]byte(\"nilkey\"), nil))\n\t\trequire.Equal(t, []byte(\"\"), top.Get([]byte(\"nilkey\")))\n\n\t\t// Put empty value.\n\t\trequire.NoError(t, top.Put([]byte(\"nilkey\"), []byte{}))\n\t\trequire.Equal(t, []byte(\"\"), top.Get([]byte(\"nilkey\")))\n\n\t\t// Try to create bucket with same name as previous key.\n\t\t_, err = top.CreateBucket([]byte(\"key\"))\n\t\trequire.ErrorIs(t, err, walletdb.ErrIncompatibleValue)\n\n\t\t_, err = top.CreateBucketIfNotExists([]byte(\"key\"))\n\t\trequire.ErrorIs(t, err, walletdb.ErrIncompatibleValue)\n\n\t\t// Create sub-bucket.\n\t\tsub2, err := top.CreateBucket([]byte(\"sub2\"))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, sub2)\n\n\t\t// Assert that re-creating the bucket fails.\n\t\t_, err = top.CreateBucket([]byte(\"sub2\"))\n\t\trequire.ErrorIs(t, err, walletdb.ErrBucketExists)\n\n\t\t// Assert that create-if-not-exists succeeds.\n\t\t_, err = top.CreateBucketIfNotExists([]byte(\"sub2\"))\n\t\trequire.NoError(t, err)\n\n\t\t// Assert that fetching the bucket succeeds.\n\t\tsub2 = top.NestedReadWriteBucket([]byte(\"sub2\"))\n\t\trequire.NotNil(t, sub2)\n\n\t\t// Try to put key with same name as bucket.\n\t\trequire.ErrorIs(t, top.Put([]byte(\"sub2\"), []byte(\"val\")), walletdb.ErrIncompatibleValue)\n\n\t\t// Put key into sub bucket.\n\t\trequire.NoError(t, sub2.Put([]byte(\"subkey\"), []byte(\"subval\")))\n\t\trequire.Equal(t, []byte(\"subval\"), sub2.Get([]byte(\"subkey\")))\n\n\t\t// Overwrite key in sub bucket.\n\t\trequire.NoError(t, sub2.Put([]byte(\"subkey\"), []byte(\"subval2\")))\n\t\trequire.Equal(t, []byte(\"subval2\"), sub2.Get([]byte(\"subkey\")))\n\n\t\t// Check for each result.\n\t\tkvs := make(map[string][]byte)\n\t\trequire.NoError(t, top.ForEach(func(k, v []byte) error {\n\t\t\tkvs[string(k)] = v\n\t\t\treturn nil\n\t\t}))\n\t\trequire.Equal(t, map[string][]byte{\n\t\t\t\"key\":    []byte(\"val2\"),\n\t\t\t\"nilkey\": []byte(\"\"),\n\t\t\t\"sub2\":   nil,\n\t\t}, kvs)\n\n\t\t// Delete key.\n\t\trequire.NoError(t, top.Delete([]byte(\"key\")))\n\n\t\t// Delete non-existent key.\n\t\trequire.NoError(t, top.Delete([]byte(\"keynonexistent\")))\n\n\t\t// Test cursor.\n\t\tcursor := top.ReadWriteCursor()\n\t\tk, v := cursor.First()\n\t\trequire.Equal(t, []byte(\"nilkey\"), k)\n\t\trequire.Equal(t, []byte(\"\"), v)\n\n\t\tk, v = cursor.Last()\n\t\trequire.Equal(t, []byte(\"sub2\"), k)\n\t\trequire.Nil(t, v)\n\n\t\tk, v = cursor.Prev()\n\t\trequire.Equal(t, []byte(\"nilkey\"), k)\n\t\trequire.Equal(t, []byte(\"\"), v)\n\n\t\tk, v = cursor.Prev()\n\t\trequire.Nil(t, k)\n\t\trequire.Nil(t, v)\n\n\t\tk, v = cursor.Next()\n\t\trequire.Equal(t, []byte(\"sub2\"), k)\n\t\trequire.Nil(t, v)\n\n\t\tk, v = cursor.Next()\n\t\trequire.Nil(t, k)\n\t\trequire.Nil(t, v)\n\n\t\tk, v = cursor.Seek([]byte(\"nilkey\"))\n\t\trequire.Equal(t, []byte(\"nilkey\"), k)\n\t\trequire.Equal(t, []byte(\"\"), v)\n\n\t\trequire.NoError(t, sub2.Put([]byte(\"k1\"), []byte(\"v1\")))\n\t\trequire.NoError(t, sub2.Put([]byte(\"k2\"), []byte(\"v2\")))\n\t\trequire.NoError(t, sub2.Put([]byte(\"k3\"), []byte(\"v3\")))\n\n\t\tcursor = sub2.ReadWriteCursor()\n\t\tcursor.First()\n\t\tfor i := 0; i < 4; i++ {\n\t\t\trequire.NoError(t, cursor.Delete())\n\t\t}\n\t\trequire.NoError(t, sub2.ForEach(func(k, v []byte) error {\n\t\t\trequire.Fail(t, \"unexpected data\")\n\t\t\treturn nil\n\t\t}))\n\n\t\t_, err = sub2.CreateBucket([]byte(\"sub3\"))\n\t\trequire.NoError(t, err)\n\t\trequire.ErrorIs(t, cursor.Delete(), walletdb.ErrIncompatibleValue)\n\n\t\t//Try to delete all data.\n\t\trequire.NoError(t, tx.DeleteTopLevelBucket([]byte(\"top\")))\n\t\trequire.Nil(t, tx.ReadBucket([]byte(\"top\")))\n\n\t\treturn nil\n\t}, func() {}))\n}\n",
      "length": 3895,
      "tokens": 360,
      "embedding": []
    },
    {
      "slug": "func testSubBucketSequence(t *testing.T, db walletdb.DB) {",
      "content": "func testSubBucketSequence(t *testing.T, db walletdb.DB) {\n\trequire.NoError(t, Update(db, func(tx walletdb.ReadWriteTx) error {\n\t\t// Create top level bucket.\n\t\ttop, err := tx.CreateTopLevelBucket([]byte(\"top\"))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, top)\n\n\t\t// Create sub-bucket.\n\t\tsub2, err := top.CreateBucket([]byte(\"sub2\"))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, sub2)\n\n\t\t// Test sequence.\n\t\trequire.Equal(t, uint64(0), top.Sequence())\n\n\t\trequire.NoError(t, top.SetSequence(100))\n\t\trequire.Equal(t, uint64(100), top.Sequence())\n\n\t\trequire.NoError(t, top.SetSequence(101))\n\t\trequire.Equal(t, uint64(101), top.Sequence())\n\n\t\tnext, err := top.NextSequence()\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, uint64(102), next)\n\n\t\tnext, err = sub2.NextSequence()\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, uint64(1), next)\n\n\t\treturn nil\n\t}, func() {}))\n}\n",
      "length": 776,
      "tokens": 70,
      "embedding": []
    }
  ]
}