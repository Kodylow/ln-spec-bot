{
  "filepath": "../implementations/go/lnd/kvdb/readwrite_cursor_test.go",
  "package": "kvdb",
  "sections": [
    {
      "slug": "func testReadCursorEmptyInterval(t *testing.T, db walletdb.DB) {",
      "content": "func testReadCursorEmptyInterval(t *testing.T, db walletdb.DB) {\n\terr := Update(db, func(tx walletdb.ReadWriteTx) error {\n\t\tb, err := tx.CreateTopLevelBucket([]byte(\"apple\"))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, b)\n\n\t\treturn nil\n\t}, func() {})\n\trequire.NoError(t, err)\n\n\terr = View(db, func(tx walletdb.ReadTx) error {\n\t\tb := tx.ReadBucket([]byte(\"apple\"))\n\t\trequire.NotNil(t, b)\n\n\t\tcursor := b.ReadCursor()\n\t\tk, v := cursor.First()\n\t\trequire.Nil(t, k)\n\t\trequire.Nil(t, v)\n\n\t\tk, v = cursor.Next()\n\t\trequire.Nil(t, k)\n\t\trequire.Nil(t, v)\n\n\t\tk, v = cursor.Last()\n\t\trequire.Nil(t, k)\n\t\trequire.Nil(t, v)\n\n\t\tk, v = cursor.Prev()\n\t\trequire.Nil(t, k)\n\t\trequire.Nil(t, v)\n\n\t\treturn nil\n\t}, func() {})\n\trequire.NoError(t, err)\n}\n",
      "length": 631,
      "tokens": 77,
      "embedding": []
    },
    {
      "slug": "func testReadCursorNonEmptyInterval(t *testing.T, db walletdb.DB) {",
      "content": "func testReadCursorNonEmptyInterval(t *testing.T, db walletdb.DB) {\n\ttestKeyValues := []KV{\n\t\t{\"b\", \"1\"},\n\t\t{\"c\", \"2\"},\n\t\t{\"da\", \"3\"},\n\t\t{\"e\", \"4\"},\n\t}\n\n\terr := Update(db, func(tx walletdb.ReadWriteTx) error {\n\t\tb, err := tx.CreateTopLevelBucket([]byte(\"apple\"))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, b)\n\n\t\tfor _, kv := range testKeyValues {\n\t\t\trequire.NoError(t, b.Put([]byte(kv.key), []byte(kv.val)))\n\t\t}\n\t\treturn nil\n\t}, func() {})\n\n\trequire.NoError(t, err)\n\n\terr = View(db, func(tx walletdb.ReadTx) error {\n\t\tb := tx.ReadBucket([]byte(\"apple\"))\n\t\trequire.NotNil(t, b)\n\n\t\t// Iterate from the front.\n\t\tvar kvs []KV\n\t\tcursor := b.ReadCursor()\n\t\tk, v := cursor.First()\n\n\t\tfor k != nil && v != nil {\n\t\t\tkvs = append(kvs, KV{string(k), string(v)})\n\t\t\tk, v = cursor.Next()\n\t\t}\n\t\trequire.Equal(t, testKeyValues, kvs)\n\n\t\t// Iterate from the back.\n\t\tkvs = []KV{}\n\t\tk, v = cursor.Last()\n\n\t\tfor k != nil && v != nil {\n\t\t\tkvs = append(kvs, KV{string(k), string(v)})\n\t\t\tk, v = cursor.Prev()\n\t\t}\n\t\trequire.Equal(t, reverseKVs(testKeyValues), kvs)\n\n\t\t// Random access\n\t\tperm := []int{3, 0, 2, 1}\n\t\tfor _, i := range perm {\n\t\t\tk, v := cursor.Seek([]byte(testKeyValues[i].key))\n\t\t\trequire.Equal(t, []byte(testKeyValues[i].key), k)\n\t\t\trequire.Equal(t, []byte(testKeyValues[i].val), v)\n\t\t}\n\n\t\t// Seek to nonexisting key.\n\t\tk, v = cursor.Seek(nil)\n\t\trequire.Equal(t, \"b\", string(k))\n\t\trequire.Equal(t, \"1\", string(v))\n\n\t\tk, v = cursor.Seek([]byte(\"x\"))\n\t\trequire.Nil(t, k)\n\t\trequire.Nil(t, v)\n\n\t\treturn nil\n\t}, func() {})\n\n\trequire.NoError(t, err)\n}\n",
      "length": 1406,
      "tokens": 186,
      "embedding": []
    },
    {
      "slug": "func testReadWriteCursor(t *testing.T, db walletdb.DB) {",
      "content": "func testReadWriteCursor(t *testing.T, db walletdb.DB) {\n\ttestKeyValues := []KV{\n\t\t{\"b\", \"1\"},\n\t\t{\"c\", \"2\"},\n\t\t{\"da\", \"3\"},\n\t\t{\"e\", \"4\"},\n\t}\n\n\tcount := len(testKeyValues)\n\n\t// Pre-store the first half of the interval.\n\trequire.NoError(t, Update(db, func(tx walletdb.ReadWriteTx) error {\n\t\tb, err := tx.CreateTopLevelBucket([]byte(\"apple\"))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, b)\n\n\t\tfor i := 0; i < count/2; i++ {\n\t\t\terr = b.Put(\n\t\t\t\t[]byte(testKeyValues[i].key),\n\t\t\t\t[]byte(testKeyValues[i].val),\n\t\t\t)\n\t\t\trequire.NoError(t, err)\n\t\t}\n\t\treturn nil\n\t}, func() {}))\n\n\terr := Update(db, func(tx walletdb.ReadWriteTx) error {\n\t\tb := tx.ReadWriteBucket([]byte(\"apple\"))\n\t\trequire.NotNil(t, b)\n\n\t\t// Store the second half of the interval.\n\t\tfor i := count / 2; i < count; i++ {\n\t\t\terr := b.Put(\n\t\t\t\t[]byte(testKeyValues[i].key),\n\t\t\t\t[]byte(testKeyValues[i].val),\n\t\t\t)\n\t\t\trequire.NoError(t, err)\n\t\t}\n\n\t\tcursor := b.ReadWriteCursor()\n\n\t\t// First on valid interval.\n\t\tfk, fv := cursor.First()\n\t\trequire.Equal(t, []byte(\"b\"), fk)\n\t\trequire.Equal(t, []byte(\"1\"), fv)\n\n\t\t// Prev(First()) = nil\n\t\tk, v := cursor.Prev()\n\t\trequire.Nil(t, k)\n\t\trequire.Nil(t, v)\n\n\t\t// Last on valid interval.\n\t\tlk, lv := cursor.Last()\n\t\trequire.Equal(t, []byte(\"e\"), lk)\n\t\trequire.Equal(t, []byte(\"4\"), lv)\n\n\t\t// Next(Last()) = nil\n\t\tk, v = cursor.Next()\n\t\trequire.Nil(t, k)\n\t\trequire.Nil(t, v)\n\n\t\t// Delete first item, then add an item before the\n\t\t// deleted one. Check that First/Next will \"jump\"\n\t\t// over the deleted item and return the new first.\n\t\t_, _ = cursor.First()\n\t\trequire.NoError(t, cursor.Delete())\n\t\trequire.NoError(t, b.Put([]byte(\"a\"), []byte(\"0\")))\n\t\tfk, fv = cursor.First()\n\n\t\trequire.Equal(t, []byte(\"a\"), fk)\n\t\trequire.Equal(t, []byte(\"0\"), fv)\n\n\t\tk, v = cursor.Next()\n\t\trequire.Equal(t, []byte(\"c\"), k)\n\t\trequire.Equal(t, []byte(\"2\"), v)\n\n\t\t// Similarly test that a new end is returned if\n\t\t// the old end is deleted first.\n\t\t_, _ = cursor.Last()\n\t\trequire.NoError(t, cursor.Delete())\n\t\trequire.NoError(t, b.Put([]byte(\"f\"), []byte(\"5\")))\n\n\t\tlk, lv = cursor.Last()\n\t\trequire.Equal(t, []byte(\"f\"), lk)\n\t\trequire.Equal(t, []byte(\"5\"), lv)\n\n\t\tk, v = cursor.Prev()\n\t\trequire.Equal(t, []byte(\"da\"), k)\n\t\trequire.Equal(t, []byte(\"3\"), v)\n\n\t\t// Overwrite k/v in the middle of the interval.\n\t\trequire.NoError(t, b.Put([]byte(\"c\"), []byte(\"3\")))\n\t\tk, v = cursor.Prev()\n\t\trequire.Equal(t, []byte(\"c\"), k)\n\t\trequire.Equal(t, []byte(\"3\"), v)\n\n\t\t// Insert new key/values.\n\t\trequire.NoError(t, b.Put([]byte(\"cx\"), []byte(\"x\")))\n\t\trequire.NoError(t, b.Put([]byte(\"cy\"), []byte(\"y\")))\n\n\t\tk, v = cursor.Next()\n\t\trequire.Equal(t, []byte(\"cx\"), k)\n\t\trequire.Equal(t, []byte(\"x\"), v)\n\n\t\tk, v = cursor.Next()\n\t\trequire.Equal(t, []byte(\"cy\"), k)\n\t\trequire.Equal(t, []byte(\"y\"), v)\n\n\t\texpected := []KV{\n\t\t\t{\"a\", \"0\"},\n\t\t\t{\"c\", \"3\"},\n\t\t\t{\"cx\", \"x\"},\n\t\t\t{\"cy\", \"y\"},\n\t\t\t{\"da\", \"3\"},\n\t\t\t{\"f\", \"5\"},\n\t\t}\n\n\t\t// Iterate from the front.\n\t\tvar kvs []KV\n\t\tk, v = cursor.First()\n\n\t\tfor k != nil && v != nil {\n\t\t\tkvs = append(kvs, KV{string(k), string(v)})\n\t\t\tk, v = cursor.Next()\n\t\t}\n\t\trequire.Equal(t, expected, kvs)\n\n\t\t// Iterate from the back.\n\t\tkvs = []KV{}\n\t\tk, v = cursor.Last()\n\n\t\tfor k != nil && v != nil {\n\t\t\tkvs = append(kvs, KV{string(k), string(v)})\n\t\t\tk, v = cursor.Prev()\n\t\t}\n\t\trequire.Equal(t, reverseKVs(expected), kvs)\n\n\t\treturn nil\n\t}, func() {})\n\n\trequire.NoError(t, err)\n}\n\n// testReadWriteCursorWithBucketAndValue tests that cursors are able to iterate\n// over both bucket and value keys if both are present in the iterated bucket.",
      "length": 3318,
      "tokens": 428,
      "embedding": []
    },
    {
      "slug": "func testReadWriteCursorWithBucketAndValue(t *testing.T, db walletdb.DB) {",
      "content": "func testReadWriteCursorWithBucketAndValue(t *testing.T, db walletdb.DB) {\n\n\t// Pre-store the first half of the interval.\n\trequire.NoError(t, Update(db, func(tx walletdb.ReadWriteTx) error {\n\t\tb, err := tx.CreateTopLevelBucket([]byte(\"apple\"))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, b)\n\n\t\trequire.NoError(t, b.Put([]byte(\"key\"), []byte(\"val\")))\n\n\t\tb1, err := b.CreateBucket([]byte(\"banana\"))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, b1)\n\n\t\tb2, err := b.CreateBucket([]byte(\"pear\"))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, b2)\n\n\t\treturn nil\n\t}, func() {}))\n\n\terr := View(db, func(tx walletdb.ReadTx) error {\n\t\tb := tx.ReadBucket([]byte(\"apple\"))\n\t\trequire.NotNil(t, b)\n\n\t\tcursor := b.ReadCursor()\n\n\t\t// First on valid interval.\n\t\tk, v := cursor.First()\n\t\trequire.Equal(t, []byte(\"banana\"), k)\n\t\trequire.Nil(t, v)\n\n\t\tk, v = cursor.Next()\n\t\trequire.Equal(t, []byte(\"key\"), k)\n\t\trequire.Equal(t, []byte(\"val\"), v)\n\n\t\tk, v = cursor.Last()\n\t\trequire.Equal(t, []byte(\"pear\"), k)\n\t\trequire.Nil(t, v)\n\n\t\tk, v = cursor.Seek([]byte(\"k\"))\n\t\trequire.Equal(t, []byte(\"key\"), k)\n\t\trequire.Equal(t, []byte(\"val\"), v)\n\n\t\tk, v = cursor.Seek([]byte(\"banana\"))\n\t\trequire.Equal(t, []byte(\"banana\"), k)\n\t\trequire.Nil(t, v)\n\n\t\tk, v = cursor.Next()\n\t\trequire.Equal(t, []byte(\"key\"), k)\n\t\trequire.Equal(t, []byte(\"val\"), v)\n\n\t\treturn nil\n\t}, func() {})\n\n\trequire.NoError(t, err)\n}\n",
      "length": 1243,
      "tokens": 131,
      "embedding": []
    }
  ]
}