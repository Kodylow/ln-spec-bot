{
  "filepath": "../implementations/go/lnd/kvdb/etcd/readwrite_tx.go",
  "package": "etcd",
  "sections": [
    {
      "slug": "//go:build kvdb_etcd",
      "content": "//go:build kvdb_etcd\n// +build kvdb_etcd\n\npackage etcd\n\nimport (\n\t\"sync\"\n\n\t\"github.com/btcsuite/btcwallet/walletdb\"\n)\n\n// readWriteTx holds a reference to the STM transaction.",
      "length": 144,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "type readWriteTx struct {",
      "content": "type readWriteTx struct {\n\t// stm is the reference to the parent STM.\n\tstm STM\n\n\t// rootBucketID holds the sha256 hash of the root bucket id, which is used\n\t// for key space spearation.\n\trootBucketID [bucketIDLength]byte\n\n\t// active is true if the transaction hasn't been committed yet.\n\tactive bool\n\n\t// lock is passed on for manual txns when the backend is instantiated\n\t// such that we read/write lock transactions to ensure a single writer.\n\tlock sync.Locker\n}\n\n// newReadWriteTx creates an rw transaction with the passed STM.",
      "length": 489,
      "tokens": 83,
      "embedding": []
    },
    {
      "slug": "func newReadWriteTx(stm STM, prefix string, lock sync.Locker) *readWriteTx {",
      "content": "func newReadWriteTx(stm STM, prefix string, lock sync.Locker) *readWriteTx {\n\treturn &readWriteTx{\n\t\tstm:          stm,\n\t\tactive:       true,\n\t\tlock:         lock,\n\t\trootBucketID: makeBucketID([]byte(prefix)),\n\t}\n}\n\n// rooBucket is a helper function to return the always present\n// pseudo root bucket.",
      "length": 215,
      "tokens": 27,
      "embedding": []
    },
    {
      "slug": "func rootBucket(tx *readWriteTx) *readWriteBucket {",
      "content": "func rootBucket(tx *readWriteTx) *readWriteBucket {\n\treturn newReadWriteBucket(tx, tx.rootBucketID[:], tx.rootBucketID[:])\n}\n\n// RootBucket will return a handle to the root bucket. This is not a real handle\n// but just a wrapper around the root bucket ID to allow derivation of child\n// keys.",
      "length": 235,
      "tokens": 38,
      "embedding": []
    },
    {
      "slug": "func (tx *readWriteTx) RootBucket() walletdb.ReadBucket {",
      "content": "func (tx *readWriteTx) RootBucket() walletdb.ReadBucket {\n\treturn rootBucket(tx)\n}\n\n// ReadBucket opens the root bucket for read only access.  If the bucket\n// described by the key does not exist, nil is returned.",
      "length": 151,
      "tokens": 27,
      "embedding": []
    },
    {
      "slug": "func (tx *readWriteTx) ReadBucket(key []byte) walletdb.ReadBucket {",
      "content": "func (tx *readWriteTx) ReadBucket(key []byte) walletdb.ReadBucket {\n\treturn rootBucket(tx).NestedReadWriteBucket(key)\n}\n\n// ForEachBucket iterates through all top level buckets.",
      "length": 106,
      "tokens": 11,
      "embedding": []
    },
    {
      "slug": "func (tx *readWriteTx) ForEachBucket(fn func(key []byte) error) error {",
      "content": "func (tx *readWriteTx) ForEachBucket(fn func(key []byte) error) error {\n\troot := rootBucket(tx)\n\t// We can safely use ForEach here since on the top level there are\n\t// no values, only buckets.\n\treturn root.ForEach(func(key []byte, val []byte) error {\n\t\tif val != nil {\n\t\t\t// A non-nil value would mean that we have a non\n\t\t\t// walletdb/kvdb compatibel database containing\n\t\t\t// arbitrary key/values.\n\t\t\treturn walletdb.ErrInvalid\n\t\t}\n\n\t\treturn fn(key)\n\t})\n}\n\n// Rollback closes the transaction, discarding changes (if any) if the\n// database was modified by a write transaction.",
      "length": 490,
      "tokens": 79,
      "embedding": []
    },
    {
      "slug": "func (tx *readWriteTx) Rollback() error {",
      "content": "func (tx *readWriteTx) Rollback() error {\n\t// If the transaction has been closed roolback will fail.\n\tif !tx.active {\n\t\treturn walletdb.ErrTxClosed\n\t}\n\n\tif tx.lock != nil {\n\t\tdefer tx.lock.Unlock()\n\t}\n\n\t// Rollback the STM and set the tx to inactive.\n\ttx.stm.Rollback()\n\ttx.active = false\n\n\treturn nil\n}\n\n// ReadWriteBucket opens the root bucket for read/write access.  If the\n// bucket described by the key does not exist, nil is returned.",
      "length": 381,
      "tokens": 64,
      "embedding": []
    },
    {
      "slug": "func (tx *readWriteTx) ReadWriteBucket(key []byte) walletdb.ReadWriteBucket {",
      "content": "func (tx *readWriteTx) ReadWriteBucket(key []byte) walletdb.ReadWriteBucket {\n\treturn rootBucket(tx).NestedReadWriteBucket(key)\n}\n\n// CreateTopLevelBucket creates the top level bucket for a key if it\n// does not exist.  The newly-created bucket it returned.",
      "length": 175,
      "tokens": 24,
      "embedding": []
    },
    {
      "slug": "func (tx *readWriteTx) CreateTopLevelBucket(key []byte) (walletdb.ReadWriteBucket, error) {",
      "content": "func (tx *readWriteTx) CreateTopLevelBucket(key []byte) (walletdb.ReadWriteBucket, error) {\n\treturn rootBucket(tx).CreateBucketIfNotExists(key)\n}\n\n// DeleteTopLevelBucket deletes the top level bucket for a key.  This\n// errors if the bucket can not be found or the key keys a single value\n// instead of a bucket.",
      "length": 215,
      "tokens": 35,
      "embedding": []
    },
    {
      "slug": "func (tx *readWriteTx) DeleteTopLevelBucket(key []byte) error {",
      "content": "func (tx *readWriteTx) DeleteTopLevelBucket(key []byte) error {\n\treturn rootBucket(tx).DeleteNestedBucket(key)\n}\n\n// Commit commits the transaction if not already committed. Will return\n// error if the underlying STM fails.",
      "length": 155,
      "tokens": 21,
      "embedding": []
    },
    {
      "slug": "func (tx *readWriteTx) Commit() error {",
      "content": "func (tx *readWriteTx) Commit() error {\n\t// Commit will fail if the transaction is already committed.\n\tif !tx.active {\n\t\treturn walletdb.ErrTxClosed\n\t}\n\n\tif tx.lock != nil {\n\t\tdefer tx.lock.Unlock()\n\t}\n\n\t// Try committing the transaction.\n\tif err := tx.stm.Commit(); err != nil {\n\t\treturn err\n\t}\n\n\t// Mark the transaction as not active after commit.\n\ttx.active = false\n\n\treturn nil\n}\n\n// OnCommit sets the commit callback (overriding if already set).",
      "length": 390,
      "tokens": 65,
      "embedding": []
    },
    {
      "slug": "func (tx *readWriteTx) OnCommit(cb func()) {",
      "content": "func (tx *readWriteTx) OnCommit(cb func()) {\n\ttx.stm.OnCommit(cb)\n}\n",
      "length": 21,
      "tokens": 2,
      "embedding": []
    }
  ]
}