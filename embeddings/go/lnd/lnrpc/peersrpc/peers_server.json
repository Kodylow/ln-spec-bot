{
  "filepath": "../implementations/go/lnd/lnrpc/peersrpc/peers_server.go",
  "package": "peersrpc",
  "sections": [
    {
      "slug": "//go:build peersrpc",
      "content": "//go:build peersrpc\n// +build peersrpc\n\npackage peersrpc\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"sync/atomic\"\n\n\t\"github.com/grpc-ecosystem/grpc-gateway/v2/runtime\"\n\t\"github.com/lightningnetwork/lnd/feature\"\n\t\"github.com/lightningnetwork/lnd/lncfg\"\n\t\"github.com/lightningnetwork/lnd/lnrpc\"\n\t\"github.com/lightningnetwork/lnd/lnwire\"\n\t\"github.com/lightningnetwork/lnd/netann\"\n\t\"google.golang.org/grpc\"\n\t\"gopkg.in/macaroon-bakery.v2/bakery\"\n)\n\nconst (\n\t// subServerName is the name of the sub rpc server. We'll use this name\n\t// to register ourselves, and we also require that the main\n\t// SubServerConfigDispatcher instance recognize tt as the name of our\n\t// RPC service.\n\tsubServerName = \"PeersRPC\"\n)\n\nvar (\n\t// macPermissions maps RPC calls to the permissions they require.\n\tmacPermissions = map[string][]bakery.Op{\n\t\t\"/peersrpc.Peers/UpdateNodeAnnouncement\": {{\n\t\t\tEntity: \"peers\",\n\t\t\tAction: \"write\",\n\t\t}},\n\t}\n)\n\n// ServerShell is a shell struct holding a reference to the actual sub-server.\n// It is used to register the gRPC sub-server with the root server before we\n// have the necessary dependencies to populate the actual sub-server.",
      "length": 1077,
      "tokens": 126,
      "embedding": []
    },
    {
      "slug": "type ServerShell struct {",
      "content": "type ServerShell struct {\n\tPeersServer\n}\n\n// Server is a sub-server of the main RPC server: the peers RPC. This sub\n// RPC server allows to intereact with our Peers in the Lightning Network.",
      "length": 160,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "type Server struct {",
      "content": "type Server struct {\n\tstarted  int32 // To be used atomically.\n\tshutdown int32 // To be used atomically.\n\n\t// Required by the grpc-gateway/v2 library for forward compatibility.\n\t// Must be after the atomically used variables to not break struct\n\t// alignment.\n\tUnimplementedPeersServer\n\n\tcfg *Config\n}\n\n// A compile time check to ensure that Server fully implements the PeersServer\n// gRPC service.\nvar _ PeersServer = (*Server)(nil)\n\n// New returns a new instance of the peersrpc Peers sub-server. We also\n// return the set of permissions for the macaroons that we may create within\n// this method. If the macaroons we need aren't found in the filepath, then\n// we'll create them on start up. If we're unable to locate, or create the\n// macaroons we need, then we'll return with an error.",
      "length": 749,
      "tokens": 128,
      "embedding": []
    },
    {
      "slug": "func New(cfg *Config) (*Server, lnrpc.MacaroonPerms, error) {",
      "content": "func New(cfg *Config) (*Server, lnrpc.MacaroonPerms, error) {\n\tserver := &Server{\n\t\tcfg: cfg,\n\t}\n\n\treturn server, macPermissions, nil\n}\n\n// Start launches any helper goroutines required for the Server to function.\n//\n// NOTE: This is part of the lnrpc.SubServer interface.",
      "length": 201,
      "tokens": 33,
      "embedding": []
    },
    {
      "slug": "func (s *Server) Start() error {",
      "content": "func (s *Server) Start() error {\n\tif atomic.AddInt32(&s.started, 1) != 1 {\n\t\treturn nil\n\t}\n\n\treturn nil\n}\n\n// Stop signals any active goroutines for a graceful closure.\n//\n// NOTE: This is part of the lnrpc.SubServer interface.",
      "length": 185,
      "tokens": 32,
      "embedding": []
    },
    {
      "slug": "func (s *Server) Stop() error {",
      "content": "func (s *Server) Stop() error {\n\tif atomic.AddInt32(&s.shutdown, 1) != 1 {\n\t\treturn nil\n\t}\n\n\treturn nil\n}\n\n// Name returns a unique string representation of the sub-server. This can be\n// used to identify the sub-server and also de-duplicate them.\n//\n// NOTE: This is part of the lnrpc.SubServer interface.",
      "length": 264,
      "tokens": 45,
      "embedding": []
    },
    {
      "slug": "func (s *Server) Name() string {",
      "content": "func (s *Server) Name() string {\n\treturn subServerName\n}\n\n// RegisterWithRootServer will be called by the root gRPC server to direct a\n// sub RPC server to register itself with the main gRPC root server. Until this\n// is called, each sub-server won't be able to have\n// requests routed towards it.\n//\n// NOTE: This is part of the lnrpc.GrpcHandler interface.",
      "length": 317,
      "tokens": 56,
      "embedding": []
    },
    {
      "slug": "func (r *ServerShell) RegisterWithRootServer(grpcServer *grpc.Server) error {",
      "content": "func (r *ServerShell) RegisterWithRootServer(grpcServer *grpc.Server) error {\n\t// We make sure that we register it with the main gRPC server to ensure\n\t// all our methods are routed properly.\n\tRegisterPeersServer(grpcServer, r)\n\n\tlog.Debugf(\"Peers RPC server successfully register with root \" +\n\t\t\"gRPC server\")\n\n\treturn nil\n}\n\n// RegisterWithRestServer will be called by the root REST mux to direct a sub\n// RPC server to register itself with the main REST mux server. Until this is\n// called, each sub-server won't be able to have requests routed towards it.\n//\n// NOTE: This is part of the lnrpc.GrpcHandler interface.",
      "length": 529,
      "tokens": 90,
      "embedding": []
    },
    {
      "slug": "func (r *ServerShell) RegisterWithRestServer(ctx context.Context,",
      "content": "func (r *ServerShell) RegisterWithRestServer(ctx context.Context,\n\tmux *runtime.ServeMux, dest string, opts []grpc.DialOption) error {\n\n\t// We make sure that we register it with the main REST server to ensure\n\t// all our methods are routed properly.\n\terr := RegisterPeersHandlerFromEndpoint(ctx, mux, dest, opts)\n\tif err != nil {\n\t\tlog.Errorf(\"Could not register Peers REST server \"+\n\t\t\t\"with root REST server: %v\", err)\n\t\treturn err\n\t}\n\n\tlog.Debugf(\"Peers REST server successfully registered with \" +\n\t\t\"root REST server\")\n\treturn nil\n}\n\n// CreateSubServer populates the subserver's dependencies using the passed\n// SubServerConfigDispatcher. This method should fully initialize the\n// sub-server instance, making it ready for action. It returns the macaroon\n// permissions that the sub-server wishes to pass on to the root server for all\n// methods routed towards it.\n//\n// NOTE: This is part of the lnrpc.GrpcHandler interface.",
      "length": 842,
      "tokens": 130,
      "embedding": []
    },
    {
      "slug": "func (r *ServerShell) CreateSubServer(configRegistry lnrpc.SubServerConfigDispatcher) (",
      "content": "func (r *ServerShell) CreateSubServer(configRegistry lnrpc.SubServerConfigDispatcher) (\n\tlnrpc.SubServer, lnrpc.MacaroonPerms, error) {\n\n\tsubServer, macPermissions, err := createNewSubServer(configRegistry)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tr.PeersServer = subServer\n\treturn subServer, macPermissions, nil\n}\n\n// updateAddresses computes the new address set after executing the update\n// actions.",
      "length": 306,
      "tokens": 40,
      "embedding": []
    },
    {
      "slug": "func (s *Server) updateAddresses(currentAddresses []net.Addr,",
      "content": "func (s *Server) updateAddresses(currentAddresses []net.Addr,\n\tupdates []*UpdateAddressAction) ([]net.Addr, *lnrpc.Op, error) {\n\n\t// net.Addr is not comparable so we cannot use the default map\n\t// (map[net.Addr]struct{}) so we have to use arrays and a helping\n\t// function.\n\tfindAddr := func(addr net.Addr, slice []net.Addr) bool {\n\t\tfor _, sAddr := range slice {\n\t\t\tif sAddr.Network() != addr.Network() {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif sAddr.String() == addr.String() {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\t// Preallocate enough memory for both arrays.\n\tremoveAddr := make([]net.Addr, 0, len(updates))\n\taddAddr := make([]net.Addr, 0, len(updates))\n\tfor _, update := range updates {\n\t\taddr, err := s.cfg.ParseAddr(update.Address)\n\t\tif err != nil {\n\t\t\treturn nil, nil, fmt.Errorf(\"unable to resolve \"+\n\t\t\t\t\"address %v: %v\", update.Address, err)\n\t\t}\n\n\t\tswitch update.Action {\n\t\tcase UpdateAction_ADD:\n\t\t\taddAddr = append(addAddr, addr)\n\t\tcase UpdateAction_REMOVE:\n\t\t\tremoveAddr = append(removeAddr, addr)\n\t\tdefault:\n\t\t\treturn nil, nil, fmt.Errorf(\"invalid address update \"+\n\t\t\t\t\"action: %v\", update.Action)\n\t\t}\n\t}\n\n\t// Look for any inconsistency trying to add AND remove the same address.\n\tfor _, addr := range removeAddr {\n\t\tif findAddr(addr, addAddr) {\n\t\t\treturn nil, nil, fmt.Errorf(\"invalid updates for \"+\n\t\t\t\t\"removing AND adding %v\", addr)\n\t\t}\n\t}\n\n\tops := &lnrpc.Op{Entity: \"addresses\"}\n\tnewAddrs := make([]net.Addr, 0, len(updates)+len(currentAddresses))\n\n\t// Copy current addresses excluding the ones that need to be removed.\n\tfor _, addr := range currentAddresses {\n\t\tif findAddr(addr, removeAddr) {\n\t\t\tops.Actions = append(\n\t\t\t\tops.Actions,\n\t\t\t\tfmt.Sprintf(\"%s removed\", addr.String()),\n\t\t\t)\n\t\t\tcontinue\n\t\t}\n\t\tnewAddrs = append(newAddrs, addr)\n\t}\n\n\t// Add new adresses if needed.\n\tfor _, addr := range addAddr {\n\t\tif !findAddr(addr, newAddrs) {\n\t\t\tops.Actions = append(\n\t\t\t\tops.Actions,\n\t\t\t\tfmt.Sprintf(\"%s added\", addr.String()),\n\t\t\t)\n\t\t\tnewAddrs = append(newAddrs, addr)\n\t\t}\n\t}\n\n\treturn newAddrs, ops, nil\n}\n\n// updateFeatures computes the new raw SetNodeAnn after executing the update\n// actions.",
      "length": 1970,
      "tokens": 273,
      "embedding": []
    },
    {
      "slug": "func (s *Server) updateFeatures(currentfeatures *lnwire.RawFeatureVector,",
      "content": "func (s *Server) updateFeatures(currentfeatures *lnwire.RawFeatureVector,\n\tupdates []*UpdateFeatureAction) (*lnwire.RawFeatureVector,\n\t*lnrpc.Op, error) {\n\n\tops := &lnrpc.Op{Entity: \"features\"}\n\traw := currentfeatures.Clone()\n\n\tfor _, update := range updates {\n\t\tbit := lnwire.FeatureBit(update.FeatureBit)\n\n\t\tswitch update.Action {\n\t\tcase UpdateAction_ADD:\n\t\t\tif raw.IsSet(bit) {\n\t\t\t\treturn nil, nil, fmt.Errorf(\n\t\t\t\t\t\"invalid add action for bit %v, \"+\n\t\t\t\t\t\t\"bit is already set\",\n\t\t\t\t\tupdate.FeatureBit,\n\t\t\t\t)\n\t\t\t}\n\t\t\traw.Set(bit)\n\t\t\tops.Actions = append(\n\t\t\t\tops.Actions,\n\t\t\t\tfmt.Sprintf(\"%s set\", lnwire.Features[bit]),\n\t\t\t)\n\n\t\tcase UpdateAction_REMOVE:\n\t\t\tif !raw.IsSet(bit) {\n\t\t\t\treturn nil, nil, fmt.Errorf(\n\t\t\t\t\t\"invalid remove action for bit %v, \"+\n\t\t\t\t\t\t\"bit is already unset\",\n\t\t\t\t\tupdate.FeatureBit,\n\t\t\t\t)\n\t\t\t}\n\t\t\traw.Unset(bit)\n\t\t\tops.Actions = append(\n\t\t\t\tops.Actions,\n\t\t\t\tfmt.Sprintf(\"%s unset\", lnwire.Features[bit]),\n\t\t\t)\n\n\t\tdefault:\n\t\t\treturn nil, nil, fmt.Errorf(\n\t\t\t\t\"invalid update action (%v) for bit %v\",\n\t\t\t\tupdate.Action,\n\t\t\t\tupdate.FeatureBit,\n\t\t\t)\n\t\t}\n\t}\n\n\t// Validate our new SetNodeAnn.\n\tfv := lnwire.NewFeatureVector(raw, lnwire.Features)\n\tif err := feature.ValidateDeps(fv); err != nil {\n\t\treturn nil, nil, fmt.Errorf(\n\t\t\t\"invalid feature set (SetNodeAnn): %v\",\n\t\t\terr,\n\t\t)\n\t}\n\n\treturn raw, ops, nil\n}\n\n// UpdateNodeAnnouncement allows the caller to update the node parameters\n// and broadcasts a new version of the node announcement to its peers.",
      "length": 1344,
      "tokens": 164,
      "embedding": []
    },
    {
      "slug": "func (s *Server) UpdateNodeAnnouncement(_ context.Context,",
      "content": "func (s *Server) UpdateNodeAnnouncement(_ context.Context,\n\treq *NodeAnnouncementUpdateRequest) (\n\t*NodeAnnouncementUpdateResponse, error) {\n\n\tresp := &NodeAnnouncementUpdateResponse{}\n\tnodeModifiers := make([]netann.NodeAnnModifier, 0)\n\n\tcurrentNodeAnn, err := s.cfg.GetNodeAnnouncement()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to get current node \"+\n\t\t\t\"announcement: %v\", err)\n\t}\n\n\tif len(req.FeatureUpdates) > 0 {\n\t\tfeatures, ops, err := s.updateFeatures(\n\t\t\tcurrentNodeAnn.Features,\n\t\t\treq.FeatureUpdates,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"error trying to update node \"+\n\t\t\t\t\"features: %w\", err)\n\t\t}\n\t\tresp.Ops = append(resp.Ops, ops)\n\t\tnodeModifiers = append(\n\t\t\tnodeModifiers,\n\t\t\tnetann.NodeAnnSetFeatures(features),\n\t\t)\n\t}\n\n\tif req.Color != \"\" {\n\t\tcolor, err := lncfg.ParseHexColor(req.Color)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to parse color: %v\", err)\n\t\t}\n\n\t\tif color != currentNodeAnn.RGBColor {\n\t\t\tresp.Ops = append(resp.Ops, &lnrpc.Op{\n\t\t\t\tEntity: \"color\",\n\t\t\t\tActions: []string{\n\t\t\t\t\tfmt.Sprintf(\"changed to %v\", color),\n\t\t\t\t},\n\t\t\t})\n\t\t\tnodeModifiers = append(\n\t\t\t\tnodeModifiers,\n\t\t\t\tnetann.NodeAnnSetColor(color),\n\t\t\t)\n\t\t}\n\t}\n\n\tif req.Alias != \"\" {\n\t\talias, err := lnwire.NewNodeAlias(req.Alias)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"invalid alias value: %v\", err)\n\t\t}\n\t\tif alias != currentNodeAnn.Alias {\n\t\t\tresp.Ops = append(resp.Ops, &lnrpc.Op{\n\t\t\t\tEntity: \"alias\",\n\t\t\t\tActions: []string{\n\t\t\t\t\tfmt.Sprintf(\"changed to %v\", alias),\n\t\t\t\t},\n\t\t\t})\n\t\t\tnodeModifiers = append(\n\t\t\t\tnodeModifiers,\n\t\t\t\tnetann.NodeAnnSetAlias(alias),\n\t\t\t)\n\t\t}\n\t}\n\n\tif len(req.AddressUpdates) > 0 {\n\t\tnewAddrs, ops, err := s.updateAddresses(\n\t\t\tcurrentNodeAnn.Addresses,\n\t\t\treq.AddressUpdates,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"error trying to update node \"+\n\t\t\t\t\"addresses: %w\", err)\n\t\t}\n\t\tresp.Ops = append(resp.Ops, ops)\n\t\tnodeModifiers = append(\n\t\t\tnodeModifiers,\n\t\t\tnetann.NodeAnnSetAddrs(newAddrs),\n\t\t)\n\t}\n\n\tif len(nodeModifiers) == 0 {\n\t\treturn nil, fmt.Errorf(\"unable detect any new values to \" +\n\t\t\t\"update the node announcement\")\n\t}\n\n\tif err := s.cfg.UpdateNodeAnnouncement(nodeModifiers...); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn resp, nil\n}\n",
      "length": 2061,
      "tokens": 251,
      "embedding": []
    }
  ]
}