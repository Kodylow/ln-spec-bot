{
  "filepath": "../implementations/go/lnd/lnrpc/walletrpc/walletkit_server.go",
  "package": "walletrpc",
  "sections": [
    {
      "slug": "//go:build walletrpc",
      "content": "//go:build walletrpc\n// +build walletrpc\n\npackage walletrpc\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/base64\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"math\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"time\"\n\n\t\"github.com/btcsuite/btcd/btcec/v2\"\n\t\"github.com/btcsuite/btcd/btcec/v2/ecdsa\"\n\t\"github.com/btcsuite/btcd/btcec/v2/schnorr\"\n\t\"github.com/btcsuite/btcd/btcutil\"\n\t\"github.com/btcsuite/btcd/btcutil/hdkeychain\"\n\t\"github.com/btcsuite/btcd/btcutil/psbt\"\n\t\"github.com/btcsuite/btcd/chaincfg/chainhash\"\n\t\"github.com/btcsuite/btcd/txscript\"\n\t\"github.com/btcsuite/btcd/wire\"\n\t\"github.com/btcsuite/btcwallet/waddrmgr\"\n\tbase \"github.com/btcsuite/btcwallet/wallet\"\n\t\"github.com/btcsuite/btcwallet/wtxmgr\"\n\t\"github.com/grpc-ecosystem/grpc-gateway/v2/runtime\"\n\t\"github.com/lightningnetwork/lnd/input\"\n\t\"github.com/lightningnetwork/lnd/keychain\"\n\t\"github.com/lightningnetwork/lnd/labels\"\n\t\"github.com/lightningnetwork/lnd/lnrpc\"\n\t\"github.com/lightningnetwork/lnd/lnrpc/signrpc\"\n\t\"github.com/lightningnetwork/lnd/lnwallet\"\n\t\"github.com/lightningnetwork/lnd/lnwallet/btcwallet\"\n\t\"github.com/lightningnetwork/lnd/lnwallet/chainfee\"\n\t\"github.com/lightningnetwork/lnd/macaroons\"\n\t\"github.com/lightningnetwork/lnd/sweep\"\n\t\"google.golang.org/grpc\"\n\t\"gopkg.in/macaroon-bakery.v2/bakery\"\n)\n\nvar (\n\t// macaroonOps are the set of capabilities that our minted macaroon (if\n\t// it doesn't already exist) will have.\n\tmacaroonOps = []bakery.Op{\n\t\t{\n\t\t\tEntity: \"address\",\n\t\t\tAction: \"write\",\n\t\t},\n\t\t{\n\t\t\tEntity: \"address\",\n\t\t\tAction: \"read\",\n\t\t},\n\t\t{\n\t\t\tEntity: \"onchain\",\n\t\t\tAction: \"write\",\n\t\t},\n\t\t{\n\t\t\tEntity: \"onchain\",\n\t\t\tAction: \"read\",\n\t\t},\n\t}\n\n\t// macPermissions maps RPC calls to the permissions they require.\n\tmacPermissions = map[string][]bakery.Op{\n\t\t\"/walletrpc.WalletKit/DeriveNextKey\": {{\n\t\t\tEntity: \"address\",\n\t\t\tAction: \"read\",\n\t\t}},\n\t\t\"/walletrpc.WalletKit/DeriveKey\": {{\n\t\t\tEntity: \"address\",\n\t\t\tAction: \"read\",\n\t\t}},\n\t\t\"/walletrpc.WalletKit/NextAddr\": {{\n\t\t\tEntity: \"address\",\n\t\t\tAction: \"read\",\n\t\t}},\n\t\t\"/walletrpc.WalletKit/PublishTransaction\": {{\n\t\t\tEntity: \"onchain\",\n\t\t\tAction: \"write\",\n\t\t}},\n\t\t\"/walletrpc.WalletKit/SendOutputs\": {{\n\t\t\tEntity: \"onchain\",\n\t\t\tAction: \"write\",\n\t\t}},\n\t\t\"/walletrpc.WalletKit/EstimateFee\": {{\n\t\t\tEntity: \"onchain\",\n\t\t\tAction: \"read\",\n\t\t}},\n\t\t\"/walletrpc.WalletKit/PendingSweeps\": {{\n\t\t\tEntity: \"onchain\",\n\t\t\tAction: \"read\",\n\t\t}},\n\t\t\"/walletrpc.WalletKit/BumpFee\": {{\n\t\t\tEntity: \"onchain\",\n\t\t\tAction: \"write\",\n\t\t}},\n\t\t\"/walletrpc.WalletKit/ListSweeps\": {{\n\t\t\tEntity: \"onchain\",\n\t\t\tAction: \"read\",\n\t\t}},\n\t\t\"/walletrpc.WalletKit/LabelTransaction\": {{\n\t\t\tEntity: \"onchain\",\n\t\t\tAction: \"write\",\n\t\t}},\n\t\t\"/walletrpc.WalletKit/LeaseOutput\": {{\n\t\t\tEntity: \"onchain\",\n\t\t\tAction: \"write\",\n\t\t}},\n\t\t\"/walletrpc.WalletKit/ReleaseOutput\": {{\n\t\t\tEntity: \"onchain\",\n\t\t\tAction: \"write\",\n\t\t}},\n\t\t\"/walletrpc.WalletKit/ListLeases\": {{\n\t\t\tEntity: \"onchain\",\n\t\t\tAction: \"read\",\n\t\t}},\n\t\t\"/walletrpc.WalletKit/ListUnspent\": {{\n\t\t\tEntity: \"onchain\",\n\t\t\tAction: \"read\",\n\t\t}},\n\t\t\"/walletrpc.WalletKit/ListAddresses\": {{\n\t\t\tEntity: \"onchain\",\n\t\t\tAction: \"read\",\n\t\t}},\n\t\t\"/walletrpc.WalletKit/SignMessageWithAddr\": {{\n\t\t\tEntity: \"onchain\",\n\t\t\tAction: \"write\",\n\t\t}},\n\t\t\"/walletrpc.WalletKit/VerifyMessageWithAddr\": {{\n\t\t\tEntity: \"onchain\",\n\t\t\tAction: \"write\",\n\t\t}},\n\t\t\"/walletrpc.WalletKit/FundPsbt\": {{\n\t\t\tEntity: \"onchain\",\n\t\t\tAction: \"write\",\n\t\t}},\n\t\t\"/walletrpc.WalletKit/SignPsbt\": {{\n\t\t\tEntity: \"onchain\",\n\t\t\tAction: \"write\",\n\t\t}},\n\t\t\"/walletrpc.WalletKit/FinalizePsbt\": {{\n\t\t\tEntity: \"onchain\",\n\t\t\tAction: \"write\",\n\t\t}},\n\t\t\"/walletrpc.WalletKit/ListAccounts\": {{\n\t\t\tEntity: \"onchain\",\n\t\t\tAction: \"read\",\n\t\t}},\n\t\t\"/walletrpc.WalletKit/RequiredReserve\": {{\n\t\t\tEntity: \"onchain\",\n\t\t\tAction: \"read\",\n\t\t}},\n\t\t\"/walletrpc.WalletKit/ImportAccount\": {{\n\t\t\tEntity: \"onchain\",\n\t\t\tAction: \"write\",\n\t\t}},\n\t\t\"/walletrpc.WalletKit/ImportPublicKey\": {{\n\t\t\tEntity: \"onchain\",\n\t\t\tAction: \"write\",\n\t\t}},\n\t\t\"/walletrpc.WalletKit/ImportTapscript\": {{\n\t\t\tEntity: \"onchain\",\n\t\t\tAction: \"write\",\n\t\t}},\n\t}\n\n\t// DefaultWalletKitMacFilename is the default name of the wallet kit\n\t// macaroon that we expect to find via a file handle within the main\n\t// configuration file in this package.\n\tDefaultWalletKitMacFilename = \"walletkit.macaroon\"\n\n\t// LndInternalLockID is the binary representation of the SHA256 hash of\n\t// the string \"lnd-internal-lock-id\" and is used for UTXO lock leases to\n\t// identify that we ourselves are locking an UTXO, for example when\n\t// giving out a funded PSBT. The ID corresponds to the hex value of\n\t// ede19a92ed321a4705f8a1cccc1d4f6182545d4bb4fae08bd5937831b7e38f98.\n\tLndInternalLockID = wtxmgr.LockID{\n\t\t0xed, 0xe1, 0x9a, 0x92, 0xed, 0x32, 0x1a, 0x47,\n\t\t0x05, 0xf8, 0xa1, 0xcc, 0xcc, 0x1d, 0x4f, 0x61,\n\t\t0x82, 0x54, 0x5d, 0x4b, 0xb4, 0xfa, 0xe0, 0x8b,\n\t\t0xd5, 0x93, 0x78, 0x31, 0xb7, 0xe3, 0x8f, 0x98,\n\t}\n)\n\n// ErrZeroLabel is returned when an attempt is made to label a transaction with\n// an empty label.\nvar ErrZeroLabel = errors.New(\"cannot label transaction with empty label\")\n\n// ServerShell is a shell struct holding a reference to the actual sub-server.\n// It is used to register the gRPC sub-server with the root server before we\n// have the necessary dependencies to populate the actual sub-server.",
      "length": 5005,
      "tokens": 470,
      "embedding": []
    },
    {
      "slug": "type ServerShell struct {",
      "content": "type ServerShell struct {\n\tWalletKitServer\n}\n\n// WalletKit is a sub-RPC server that exposes a tool kit which allows clients\n// to execute common wallet operations. This includes requesting new addresses,\n// keys (for contracts!), and publishing transactions.",
      "length": 227,
      "tokens": 34,
      "embedding": []
    },
    {
      "slug": "type WalletKit struct {",
      "content": "type WalletKit struct {\n\t// Required by the grpc-gateway/v2 library for forward compatibility.\n\tUnimplementedWalletKitServer\n\n\tcfg *Config\n}\n\n// A compile time check to ensure that WalletKit fully implements the\n// WalletKitServer gRPC service.\nvar _ WalletKitServer = (*WalletKit)(nil)\n\n// New creates a new instance of the WalletKit sub-RPC server.",
      "length": 316,
      "tokens": 45,
      "embedding": []
    },
    {
      "slug": "func New(cfg *Config) (*WalletKit, lnrpc.MacaroonPerms, error) {",
      "content": "func New(cfg *Config) (*WalletKit, lnrpc.MacaroonPerms, error) {\n\t// If the path of the wallet kit macaroon wasn't specified, then we'll\n\t// assume that it's found at the default network directory.\n\tif cfg.WalletKitMacPath == \"\" {\n\t\tcfg.WalletKitMacPath = filepath.Join(\n\t\t\tcfg.NetworkDir, DefaultWalletKitMacFilename,\n\t\t)\n\t}\n\n\t// Now that we know the full path of the wallet kit macaroon, we can\n\t// check to see if we need to create it or not. If stateless_init is set\n\t// then we don't write the macaroons.\n\tmacFilePath := cfg.WalletKitMacPath\n\tif cfg.MacService != nil && !cfg.MacService.StatelessInit &&\n\t\t!lnrpc.FileExists(macFilePath) {\n\n\t\tlog.Infof(\"Baking macaroons for WalletKit RPC Server at: %v\",\n\t\t\tmacFilePath)\n\n\t\t// At this point, we know that the wallet kit macaroon doesn't\n\t\t// yet, exist, so we need to create it with the help of the\n\t\t// main macaroon service.\n\t\twalletKitMac, err := cfg.MacService.NewMacaroon(\n\t\t\tcontext.Background(), macaroons.DefaultRootKeyID,\n\t\t\tmacaroonOps...,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\twalletKitMacBytes, err := walletKitMac.M().MarshalBinary()\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\terr = ioutil.WriteFile(macFilePath, walletKitMacBytes, 0644)\n\t\tif err != nil {\n\t\t\t_ = os.Remove(macFilePath)\n\t\t\treturn nil, nil, err\n\t\t}\n\t}\n\n\twalletKit := &WalletKit{\n\t\tcfg: cfg,\n\t}\n\n\treturn walletKit, macPermissions, nil\n}\n\n// Start launches any helper goroutines required for the sub-server to function.\n//\n// NOTE: This is part of the lnrpc.SubServer interface.",
      "length": 1414,
      "tokens": 208,
      "embedding": []
    },
    {
      "slug": "func (w *WalletKit) Start() error {",
      "content": "func (w *WalletKit) Start() error {\n\treturn nil\n}\n\n// Stop signals any active goroutines for a graceful closure.\n//\n// NOTE: This is part of the lnrpc.SubServer interface.",
      "length": 130,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (w *WalletKit) Stop() error {",
      "content": "func (w *WalletKit) Stop() error {\n\treturn nil\n}\n\n// Name returns a unique string representation of the sub-server. This can be\n// used to identify the sub-server and also de-duplicate them.\n//\n// NOTE: This is part of the lnrpc.SubServer interface.",
      "length": 208,
      "tokens": 36,
      "embedding": []
    },
    {
      "slug": "func (w *WalletKit) Name() string {",
      "content": "func (w *WalletKit) Name() string {\n\treturn SubServerName\n}\n\n// RegisterWithRootServer will be called by the root gRPC server to direct a\n// sub RPC server to register itself with the main gRPC root server. Until this\n// is called, each sub-server won't be able to have requests routed towards it.\n//\n// NOTE: This is part of the lnrpc.GrpcHandler interface.",
      "length": 315,
      "tokens": 55,
      "embedding": []
    },
    {
      "slug": "func (r *ServerShell) RegisterWithRootServer(grpcServer *grpc.Server) error {",
      "content": "func (r *ServerShell) RegisterWithRootServer(grpcServer *grpc.Server) error {\n\t// We make sure that we register it with the main gRPC server to ensure\n\t// all our methods are routed properly.\n\tRegisterWalletKitServer(grpcServer, r)\n\n\tlog.Debugf(\"WalletKit RPC server successfully registered with \" +\n\t\t\"root gRPC server\")\n\n\treturn nil\n}\n\n// RegisterWithRestServer will be called by the root REST mux to direct a sub\n// RPC server to register itself with the main REST mux server. Until this is\n// called, each sub-server won't be able to have requests routed towards it.\n//\n// NOTE: This is part of the lnrpc.GrpcHandler interface.",
      "length": 539,
      "tokens": 90,
      "embedding": []
    },
    {
      "slug": "func (r *ServerShell) RegisterWithRestServer(ctx context.Context,",
      "content": "func (r *ServerShell) RegisterWithRestServer(ctx context.Context,\n\tmux *runtime.ServeMux, dest string, opts []grpc.DialOption) error {\n\n\t// We make sure that we register it with the main REST server to ensure\n\t// all our methods are routed properly.\n\terr := RegisterWalletKitHandlerFromEndpoint(ctx, mux, dest, opts)\n\tif err != nil {\n\t\tlog.Errorf(\"Could not register WalletKit REST server \"+\n\t\t\t\"with root REST server: %v\", err)\n\t\treturn err\n\t}\n\n\tlog.Debugf(\"WalletKit REST server successfully registered with \" +\n\t\t\"root REST server\")\n\treturn nil\n}\n\n// CreateSubServer populates the subserver's dependencies using the passed\n// SubServerConfigDispatcher. This method should fully initialize the\n// sub-server instance, making it ready for action. It returns the macaroon\n// permissions that the sub-server wishes to pass on to the root server for all\n// methods routed towards it.\n//\n// NOTE: This is part of the lnrpc.GrpcHandler interface.",
      "length": 854,
      "tokens": 130,
      "embedding": []
    },
    {
      "slug": "func (r *ServerShell) CreateSubServer(configRegistry lnrpc.SubServerConfigDispatcher) (",
      "content": "func (r *ServerShell) CreateSubServer(configRegistry lnrpc.SubServerConfigDispatcher) (\n\tlnrpc.SubServer, lnrpc.MacaroonPerms, error) {\n\n\tsubServer, macPermissions, err := createNewSubServer(configRegistry)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tr.WalletKitServer = subServer\n\treturn subServer, macPermissions, nil\n}\n\n// internalScope returns the internal key scope.",
      "length": 273,
      "tokens": 34,
      "embedding": []
    },
    {
      "slug": "func (w *WalletKit) internalScope() waddrmgr.KeyScope {",
      "content": "func (w *WalletKit) internalScope() waddrmgr.KeyScope {\n\treturn waddrmgr.KeyScope{\n\t\tPurpose: keychain.BIP0043Purpose,\n\t\tCoin:    w.cfg.ChainParams.HDCoinType,\n\t}\n}\n\n// ListUnspent returns useful information about each unspent output owned by\n// the wallet, as reported by the underlying `ListUnspentWitness`; the\n// information returned is: outpoint, amount in satoshis, address, address\n// type, scriptPubKey in hex and number of confirmations. The result is\n// filtered to contain outputs whose number of confirmations is between a\n// minimum and maximum number of confirmations specified by the user.",
      "length": 537,
      "tokens": 74,
      "embedding": []
    },
    {
      "slug": "func (w *WalletKit) ListUnspent(ctx context.Context,",
      "content": "func (w *WalletKit) ListUnspent(ctx context.Context,\n\treq *ListUnspentRequest) (*ListUnspentResponse, error) {\n\n\t// Force min_confs and max_confs to be zero if unconfirmed_only is\n\t// true.\n\tif req.UnconfirmedOnly && (req.MinConfs != 0 || req.MaxConfs != 0) {\n\t\treturn nil, fmt.Errorf(\"min_confs and max_confs must be zero if \" +\n\t\t\t\"unconfirmed_only is true\")\n\t}\n\n\t// When unconfirmed_only is inactive and max_confs is zero (default\n\t// values), we will override max_confs to be a MaxInt32, in order\n\t// to return all confirmed and unconfirmed utxos as a default response.\n\tif req.MaxConfs == 0 && !req.UnconfirmedOnly {\n\t\treq.MaxConfs = math.MaxInt32\n\t}\n\n\t// Validate the confirmation arguments.\n\tminConfs, maxConfs, err := lnrpc.ParseConfs(req.MinConfs, req.MaxConfs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// With our arguments validated, we'll query the internal wallet for\n\t// the set of UTXOs that match our query.\n\t//\n\t// We'll acquire the global coin selection lock to ensure there aren't\n\t// any other concurrent processes attempting to lock any UTXOs which may\n\t// be shown available to us.\n\tvar utxos []*lnwallet.Utxo\n\terr = w.cfg.CoinSelectionLocker.WithCoinSelectLock(func() error {\n\t\tutxos, err = w.cfg.Wallet.ListUnspentWitness(\n\t\t\tminConfs, maxConfs, req.Account,\n\t\t)\n\n\t\treturn err\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trpcUtxos, err := lnrpc.MarshalUtxos(utxos, w.cfg.ChainParams)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &ListUnspentResponse{\n\t\tUtxos: rpcUtxos,\n\t}, nil\n}\n\n// LeaseOutput locks an output to the given ID, preventing it from being\n// available for any future coin selection attempts. The absolute time of the\n// lock's expiration is returned. The expiration of the lock can be extended by\n// successive invocations of this call. Outputs can be unlocked before their\n// expiration through `ReleaseOutput`.\n//\n// If the output is not known, wtxmgr.ErrUnknownOutput is returned. If the\n// output has already been locked to a different ID, then\n// wtxmgr.ErrOutputAlreadyLocked is returned.",
      "length": 1922,
      "tokens": 293,
      "embedding": []
    },
    {
      "slug": "func (w *WalletKit) LeaseOutput(ctx context.Context,",
      "content": "func (w *WalletKit) LeaseOutput(ctx context.Context,\n\treq *LeaseOutputRequest) (*LeaseOutputResponse, error) {\n\n\tif len(req.Id) != 32 {\n\t\treturn nil, errors.New(\"id must be 32 random bytes\")\n\t}\n\tvar lockID wtxmgr.LockID\n\tcopy(lockID[:], req.Id)\n\n\t// Don't allow ID's of 32 bytes, but all zeros.\n\tif lockID == (wtxmgr.LockID{}) {\n\t\treturn nil, errors.New(\"id must be 32 random bytes\")\n\t}\n\n\t// Don't allow our internal ID to be used externally for locking. Only\n\t// unlocking is allowed.\n\tif lockID == LndInternalLockID {\n\t\treturn nil, errors.New(\"reserved id cannot be used\")\n\t}\n\n\top, err := unmarshallOutPoint(req.Outpoint)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Use the specified lock duration or fall back to the default.\n\tduration := DefaultLockDuration\n\tif req.ExpirationSeconds != 0 {\n\t\tduration = time.Duration(req.ExpirationSeconds) * time.Second\n\t}\n\n\t// Acquire the global coin selection lock to ensure there aren't any\n\t// other concurrent processes attempting to lease the same UTXO.\n\tvar expiration time.Time\n\terr = w.cfg.CoinSelectionLocker.WithCoinSelectLock(func() error {\n\t\texpiration, _, _, err = w.cfg.Wallet.LeaseOutput(\n\t\t\tlockID, *op, duration,\n\t\t)\n\t\treturn err\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &LeaseOutputResponse{\n\t\tExpiration: uint64(expiration.Unix()),\n\t}, nil\n}\n\n// ReleaseOutput unlocks an output, allowing it to be available for coin\n// selection if it remains unspent. The ID should match the one used to\n// originally lock the output.",
      "length": 1383,
      "tokens": 207,
      "embedding": []
    },
    {
      "slug": "func (w *WalletKit) ReleaseOutput(ctx context.Context,",
      "content": "func (w *WalletKit) ReleaseOutput(ctx context.Context,\n\treq *ReleaseOutputRequest) (*ReleaseOutputResponse, error) {\n\n\tif len(req.Id) != 32 {\n\t\treturn nil, errors.New(\"id must be 32 random bytes\")\n\t}\n\tvar lockID wtxmgr.LockID\n\tcopy(lockID[:], req.Id)\n\n\top, err := unmarshallOutPoint(req.Outpoint)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Acquire the global coin selection lock to maintain consistency as\n\t// it's acquired when we initially leased the output.\n\terr = w.cfg.CoinSelectionLocker.WithCoinSelectLock(func() error {\n\t\treturn w.cfg.Wallet.ReleaseOutput(lockID, *op)\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &ReleaseOutputResponse{}, nil\n}\n\n// ListLeases returns a list of all currently locked utxos.",
      "length": 640,
      "tokens": 89,
      "embedding": []
    },
    {
      "slug": "func (w *WalletKit) ListLeases(ctx context.Context,",
      "content": "func (w *WalletKit) ListLeases(ctx context.Context,\n\treq *ListLeasesRequest) (*ListLeasesResponse, error) {\n\n\tleases, err := w.cfg.Wallet.ListLeasedOutputs()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &ListLeasesResponse{\n\t\tLockedUtxos: marshallLeases(leases),\n\t}, nil\n}\n\n// DeriveNextKey attempts to derive the *next* key within the key family\n// (account in BIP43) specified. This method should return the next external\n// child within this branch.",
      "length": 388,
      "tokens": 54,
      "embedding": []
    },
    {
      "slug": "func (w *WalletKit) DeriveNextKey(ctx context.Context,",
      "content": "func (w *WalletKit) DeriveNextKey(ctx context.Context,\n\treq *KeyReq) (*signrpc.KeyDescriptor, error) {\n\n\tnextKeyDesc, err := w.cfg.KeyRing.DeriveNextKey(\n\t\tkeychain.KeyFamily(req.KeyFamily),\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &signrpc.KeyDescriptor{\n\t\tKeyLoc: &signrpc.KeyLocator{\n\t\t\tKeyFamily: int32(nextKeyDesc.Family),\n\t\t\tKeyIndex:  int32(nextKeyDesc.Index),\n\t\t},\n\t\tRawKeyBytes: nextKeyDesc.PubKey.SerializeCompressed(),\n\t}, nil\n}\n\n// DeriveKey attempts to derive an arbitrary key specified by the passed\n// KeyLocator.",
      "length": 463,
      "tokens": 48,
      "embedding": []
    },
    {
      "slug": "func (w *WalletKit) DeriveKey(ctx context.Context,",
      "content": "func (w *WalletKit) DeriveKey(ctx context.Context,\n\treq *signrpc.KeyLocator) (*signrpc.KeyDescriptor, error) {\n\n\tkeyDesc, err := w.cfg.KeyRing.DeriveKey(keychain.KeyLocator{\n\t\tFamily: keychain.KeyFamily(req.KeyFamily),\n\t\tIndex:  uint32(req.KeyIndex),\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &signrpc.KeyDescriptor{\n\t\tKeyLoc: &signrpc.KeyLocator{\n\t\t\tKeyFamily: int32(keyDesc.Family),\n\t\t\tKeyIndex:  int32(keyDesc.Index),\n\t\t},\n\t\tRawKeyBytes: keyDesc.PubKey.SerializeCompressed(),\n\t}, nil\n}\n\n// NextAddr returns the next unused address within the wallet.",
      "length": 491,
      "tokens": 47,
      "embedding": []
    },
    {
      "slug": "func (w *WalletKit) NextAddr(ctx context.Context,",
      "content": "func (w *WalletKit) NextAddr(ctx context.Context,\n\treq *AddrRequest) (*AddrResponse, error) {\n\n\taccount := lnwallet.DefaultAccountName\n\tif req.Account != \"\" {\n\t\taccount = req.Account\n\t}\n\n\taddrType := lnwallet.WitnessPubKey\n\tswitch req.Type {\n\tcase AddressType_NESTED_WITNESS_PUBKEY_HASH:\n\t\taddrType = lnwallet.NestedWitnessPubKey\n\n\tcase AddressType_HYBRID_NESTED_WITNESS_PUBKEY_HASH:\n\t\treturn nil, fmt.Errorf(\"invalid address type for next \"+\n\t\t\t\"address: %v\", req.Type)\n\n\tcase AddressType_TAPROOT_PUBKEY:\n\t\taddrType = lnwallet.TaprootPubkey\n\t}\n\n\taddr, err := w.cfg.Wallet.NewAddress(addrType, req.Change, account)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &AddrResponse{\n\t\tAddr: addr.String(),\n\t}, nil\n}\n\n// Attempts to publish the passed transaction to the network. Once this returns\n// without an error, the wallet will continually attempt to re-broadcast the\n// transaction on start up, until it enters the chain.",
      "length": 840,
      "tokens": 104,
      "embedding": []
    },
    {
      "slug": "func (w *WalletKit) PublishTransaction(ctx context.Context,",
      "content": "func (w *WalletKit) PublishTransaction(ctx context.Context,\n\treq *Transaction) (*PublishResponse, error) {\n\n\tswitch {\n\t// If the client doesn't specify a transaction, then there's nothing to\n\t// publish.\n\tcase len(req.TxHex) == 0:\n\t\treturn nil, fmt.Errorf(\"must provide a transaction to \" +\n\t\t\t\"publish\")\n\t}\n\n\ttx := &wire.MsgTx{}\n\ttxReader := bytes.NewReader(req.TxHex)\n\tif err := tx.Deserialize(txReader); err != nil {\n\t\treturn nil, err\n\t}\n\n\tlabel, err := labels.ValidateAPI(req.Label)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = w.cfg.Wallet.PublishTransaction(tx, label)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &PublishResponse{}, nil\n}\n\n// SendOutputs is similar to the existing sendmany call in Bitcoind, and allows\n// the caller to create a transaction that sends to several outputs at once.\n// This is ideal when wanting to batch create a set of transactions.",
      "length": 784,
      "tokens": 124,
      "embedding": []
    },
    {
      "slug": "func (w *WalletKit) SendOutputs(ctx context.Context,",
      "content": "func (w *WalletKit) SendOutputs(ctx context.Context,\n\treq *SendOutputsRequest) (*SendOutputsResponse, error) {\n\n\tswitch {\n\t// If the client didn't specify any outputs to create, then  we can't\n\t// proceed .\n\tcase len(req.Outputs) == 0:\n\t\treturn nil, fmt.Errorf(\"must specify at least one output \" +\n\t\t\t\"to create\")\n\t}\n\n\t// Before we can request this transaction to be created, we'll need to\n\t// amp the protos back into the format that the internal wallet will\n\t// recognize.\n\toutputsToCreate := make([]*wire.TxOut, 0, len(req.Outputs))\n\tfor _, output := range req.Outputs {\n\t\toutputsToCreate = append(outputsToCreate, &wire.TxOut{\n\t\t\tValue:    output.Value,\n\t\t\tPkScript: output.PkScript,\n\t\t})\n\t}\n\n\t// Then, we'll extract the minimum number of confirmations that each\n\t// output we use to fund the transaction should satisfy.\n\tminConfs, err := lnrpc.ExtractMinConfs(req.MinConfs, req.SpendUnconfirmed)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tlabel, err := labels.ValidateAPI(req.Label)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Now that we have the outputs mapped, we can request that the wallet\n\t// attempt to create this transaction.\n\ttx, err := w.cfg.Wallet.SendOutputs(\n\t\toutputsToCreate, chainfee.SatPerKWeight(req.SatPerKw), minConfs, label,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar b bytes.Buffer\n\tif err := tx.Serialize(&b); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &SendOutputsResponse{\n\t\tRawTx: b.Bytes(),\n\t}, nil\n}\n\n// EstimateFee attempts to query the internal fee estimator of the wallet to\n// determine the fee (in sat/kw) to attach to a transaction in order to achieve\n// the confirmation target.",
      "length": 1513,
      "tokens": 230,
      "embedding": []
    },
    {
      "slug": "func (w *WalletKit) EstimateFee(ctx context.Context,",
      "content": "func (w *WalletKit) EstimateFee(ctx context.Context,\n\treq *EstimateFeeRequest) (*EstimateFeeResponse, error) {\n\n\tswitch {\n\t// A confirmation target of zero doesn't make any sense. Similarly, we\n\t// reject confirmation targets of 1 as they're unreasonable.\n\tcase req.ConfTarget == 0 || req.ConfTarget == 1:\n\t\treturn nil, fmt.Errorf(\"confirmation target must be greater \" +\n\t\t\t\"than 1\")\n\t}\n\n\tsatPerKw, err := w.cfg.FeeEstimator.EstimateFeePerKW(\n\t\tuint32(req.ConfTarget),\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &EstimateFeeResponse{\n\t\tSatPerKw: int64(satPerKw),\n\t}, nil\n}\n\n// PendingSweeps returns lists of on-chain outputs that lnd is currently\n// attempting to sweep within its central batching engine. Outputs with similar\n// fee rates are batched together in order to sweep them within a single\n// transaction. The fee rate of each sweeping transaction is determined by\n// taking the average fee rate of all the outputs it's trying to sweep.",
      "length": 875,
      "tokens": 133,
      "embedding": []
    },
    {
      "slug": "func (w *WalletKit) PendingSweeps(ctx context.Context,",
      "content": "func (w *WalletKit) PendingSweeps(ctx context.Context,\n\tin *PendingSweepsRequest) (*PendingSweepsResponse, error) {\n\n\t// Retrieve all of the outputs the UtxoSweeper is currently trying to\n\t// sweep.\n\tpendingInputs, err := w.cfg.Sweeper.PendingInputs()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Convert them into their respective RPC format.\n\trpcPendingSweeps := make([]*PendingSweep, 0, len(pendingInputs))\n\tfor _, pendingInput := range pendingInputs {\n\t\tvar witnessType WitnessType\n\t\tswitch pendingInput.WitnessType {\n\t\tcase input.CommitmentTimeLock:\n\t\t\twitnessType = WitnessType_COMMITMENT_TIME_LOCK\n\t\tcase input.CommitmentNoDelay:\n\t\t\twitnessType = WitnessType_COMMITMENT_NO_DELAY\n\t\tcase input.CommitmentRevoke:\n\t\t\twitnessType = WitnessType_COMMITMENT_REVOKE\n\t\tcase input.HtlcOfferedRevoke:\n\t\t\twitnessType = WitnessType_HTLC_OFFERED_REVOKE\n\t\tcase input.HtlcAcceptedRevoke:\n\t\t\twitnessType = WitnessType_HTLC_ACCEPTED_REVOKE\n\t\tcase input.HtlcOfferedTimeoutSecondLevel:\n\t\t\twitnessType = WitnessType_HTLC_OFFERED_TIMEOUT_SECOND_LEVEL\n\t\tcase input.HtlcAcceptedSuccessSecondLevel:\n\t\t\twitnessType = WitnessType_HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL\n\t\tcase input.HtlcOfferedRemoteTimeout:\n\t\t\twitnessType = WitnessType_HTLC_OFFERED_REMOTE_TIMEOUT\n\t\tcase input.HtlcAcceptedRemoteSuccess:\n\t\t\twitnessType = WitnessType_HTLC_ACCEPTED_REMOTE_SUCCESS\n\t\tcase input.HtlcSecondLevelRevoke:\n\t\t\twitnessType = WitnessType_HTLC_SECOND_LEVEL_REVOKE\n\t\tcase input.WitnessKeyHash:\n\t\t\twitnessType = WitnessType_WITNESS_KEY_HASH\n\t\tcase input.NestedWitnessKeyHash:\n\t\t\twitnessType = WitnessType_NESTED_WITNESS_KEY_HASH\n\t\tcase input.CommitmentAnchor:\n\t\t\twitnessType = WitnessType_COMMITMENT_ANCHOR\n\t\tdefault:\n\t\t\tlog.Warnf(\"Unhandled witness type %v for input %v\",\n\t\t\t\tpendingInput.WitnessType, pendingInput.OutPoint)\n\t\t}\n\n\t\top := &lnrpc.OutPoint{\n\t\t\tTxidBytes:   pendingInput.OutPoint.Hash[:],\n\t\t\tOutputIndex: pendingInput.OutPoint.Index,\n\t\t}\n\t\tamountSat := uint32(pendingInput.Amount)\n\t\tsatPerVbyte := uint64(pendingInput.LastFeeRate.FeePerKVByte() / 1000)\n\t\tbroadcastAttempts := uint32(pendingInput.BroadcastAttempts)\n\t\tnextBroadcastHeight := uint32(pendingInput.NextBroadcastHeight)\n\n\t\trequestedFee := pendingInput.Params.Fee\n\t\trequestedFeeRate := uint64(requestedFee.FeeRate.FeePerKVByte() / 1000)\n\n\t\trpcPendingSweeps = append(rpcPendingSweeps, &PendingSweep{\n\t\t\tOutpoint:             op,\n\t\t\tWitnessType:          witnessType,\n\t\t\tAmountSat:            amountSat,\n\t\t\tSatPerVbyte:          satPerVbyte,\n\t\t\tBroadcastAttempts:    broadcastAttempts,\n\t\t\tNextBroadcastHeight:  nextBroadcastHeight,\n\t\t\tRequestedSatPerVbyte: requestedFeeRate,\n\t\t\tRequestedConfTarget:  requestedFee.ConfTarget,\n\t\t\tForce:                pendingInput.Params.Force,\n\t\t})\n\t}\n\n\treturn &PendingSweepsResponse{\n\t\tPendingSweeps: rpcPendingSweeps,\n\t}, nil\n}\n\n// unmarshallOutPoint converts an outpoint from its lnrpc type to its canonical\n// type.",
      "length": 2753,
      "tokens": 209,
      "embedding": []
    },
    {
      "slug": "func unmarshallOutPoint(op *lnrpc.OutPoint) (*wire.OutPoint, error) {",
      "content": "func unmarshallOutPoint(op *lnrpc.OutPoint) (*wire.OutPoint, error) {\n\tif op == nil {\n\t\treturn nil, fmt.Errorf(\"empty outpoint provided\")\n\t}\n\n\tvar hash chainhash.Hash\n\tswitch {\n\tcase len(op.TxidBytes) == 0 && len(op.TxidStr) == 0:\n\t\tfallthrough\n\n\tcase len(op.TxidBytes) != 0 && len(op.TxidStr) != 0:\n\t\treturn nil, fmt.Errorf(\"either TxidBytes or TxidStr must be \" +\n\t\t\t\"specified, but not both\")\n\n\t// The hash was provided as raw bytes.\n\tcase len(op.TxidBytes) != 0:\n\t\tcopy(hash[:], op.TxidBytes)\n\n\t// The hash was provided as a hex-encoded string.\n\tcase len(op.TxidStr) != 0:\n\t\th, err := chainhash.NewHashFromStr(op.TxidStr)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\thash = *h\n\t}\n\n\treturn &wire.OutPoint{\n\t\tHash:  hash,\n\t\tIndex: op.OutputIndex,\n\t}, nil\n}\n\n// BumpFee allows bumping the fee rate of an arbitrary input. A fee preference\n// can be expressed either as a specific fee rate or a delta of blocks in which\n// the output should be swept on-chain within. If a fee preference is not\n// explicitly specified, then an error is returned. The status of the input\n// sweep can be checked through the PendingSweeps RPC.",
      "length": 1015,
      "tokens": 167,
      "embedding": []
    },
    {
      "slug": "func (w *WalletKit) BumpFee(ctx context.Context,",
      "content": "func (w *WalletKit) BumpFee(ctx context.Context,\n\tin *BumpFeeRequest) (*BumpFeeResponse, error) {\n\n\t// Parse the outpoint from the request.\n\top, err := unmarshallOutPoint(in.Outpoint)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// We only allow using either the deprecated field or the new field.\n\tif in.SatPerByte != 0 && in.SatPerVbyte != 0 {\n\t\treturn nil, fmt.Errorf(\"either SatPerByte or \" +\n\t\t\t\"SatPerVbyte should be set, but not both\")\n\t}\n\n\t// Construct the request's fee preference.\n\tsatPerKw := chainfee.SatPerKVByte(in.SatPerVbyte * 1000).FeePerKWeight()\n\tif in.SatPerByte != 0 {\n\t\tsatPerKw = chainfee.SatPerKVByte(\n\t\t\tin.SatPerByte * 1000,\n\t\t).FeePerKWeight()\n\t}\n\tfeePreference := sweep.FeePreference{\n\t\tConfTarget: uint32(in.TargetConf),\n\t\tFeeRate:    satPerKw,\n\t}\n\n\t// We'll attempt to bump the fee of the input through the UtxoSweeper.\n\t// If it is currently attempting to sweep the input, then it'll simply\n\t// bump its fee, which will result in a replacement transaction (RBF)\n\t// being broadcast. If it is not aware of the input however,\n\t// lnwallet.ErrNotMine is returned.\n\tparams := sweep.ParamsUpdate{\n\t\tFee:   feePreference,\n\t\tForce: in.Force,\n\t}\n\n\t_, err = w.cfg.Sweeper.UpdateParams(*op, params)\n\tswitch err {\n\tcase nil:\n\t\treturn &BumpFeeResponse{}, nil\n\tcase lnwallet.ErrNotMine:\n\t\tbreak\n\tdefault:\n\t\treturn nil, err\n\t}\n\n\tlog.Debugf(\"Attempting to CPFP outpoint %s\", op)\n\n\t// Since we're unable to perform a bump through RBF, we'll assume the\n\t// user is attempting to bump an unconfirmed transaction's fee rate by\n\t// sweeping an output within it under control of the wallet with a\n\t// higher fee rate, essentially performing a Child-Pays-For-Parent\n\t// (CPFP).\n\t//\n\t// We'll gather all of the information required by the UtxoSweeper in\n\t// order to sweep the output.\n\tutxo, err := w.cfg.Wallet.FetchInputInfo(op)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// We're only able to bump the fee of unconfirmed transactions.\n\tif utxo.Confirmations > 0 {\n\t\treturn nil, errors.New(\"unable to bump fee of a confirmed \" +\n\t\t\t\"transaction\")\n\t}\n\n\tsignDesc := &input.SignDescriptor{\n\t\tOutput: &wire.TxOut{\n\t\t\tPkScript: utxo.PkScript,\n\t\t\tValue:    int64(utxo.Value),\n\t\t},\n\t\tHashType: txscript.SigHashAll,\n\t}\n\n\tvar witnessType input.WitnessType\n\tswitch utxo.AddressType {\n\tcase lnwallet.WitnessPubKey:\n\t\twitnessType = input.WitnessKeyHash\n\tcase lnwallet.NestedWitnessPubKey:\n\t\twitnessType = input.NestedWitnessKeyHash\n\tcase lnwallet.TaprootPubkey:\n\t\twitnessType = input.TaprootPubKeySpend\n\t\tsignDesc.HashType = txscript.SigHashDefault\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unknown input witness %v\", op)\n\t}\n\n\t// We'll use the current height as the height hint since we're dealing\n\t// with an unconfirmed transaction.\n\t_, currentHeight, err := w.cfg.Chain.GetBestBlock()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to retrieve current height: %v\",\n\t\t\terr)\n\t}\n\n\tinp := input.NewBaseInput(op, witnessType, signDesc, uint32(currentHeight))\n\tsweepParams := sweep.Params{Fee: feePreference}\n\tif _, err = w.cfg.Sweeper.SweepInput(inp, sweepParams); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &BumpFeeResponse{}, nil\n}\n\n// ListSweeps returns a list of the sweeps that our node has published.",
      "length": 3037,
      "tokens": 417,
      "embedding": []
    },
    {
      "slug": "func (w *WalletKit) ListSweeps(ctx context.Context,",
      "content": "func (w *WalletKit) ListSweeps(ctx context.Context,\n\tin *ListSweepsRequest) (*ListSweepsResponse, error) {\n\n\tsweeps, err := w.cfg.Sweeper.ListSweeps()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsweepTxns := make(map[string]bool)\n\tfor _, sweep := range sweeps {\n\t\tsweepTxns[sweep.String()] = true\n\t}\n\n\t// Some of our sweeps could have been replaced by fee, or dropped out\n\t// of the mempool. Here, we lookup our wallet transactions so that we\n\t// can match our list of sweeps against the list of transactions that\n\t// the wallet is still tracking. Sweeps are currently always swept to\n\t// the default wallet account.\n\ttransactions, err := w.cfg.Wallet.ListTransactionDetails(\n\t\t0, btcwallet.UnconfirmedHeight, lnwallet.DefaultAccountName,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar (\n\t\ttxids     []string\n\t\ttxDetails []*lnwallet.TransactionDetail\n\t)\n\n\tfor _, tx := range transactions {\n\t\t_, ok := sweepTxns[tx.Hash.String()]\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Add the txid or full tx details depending on whether we want\n\t\t// verbose output or not.\n\t\tif in.Verbose {\n\t\t\ttxDetails = append(txDetails, tx)\n\t\t} else {\n\t\t\ttxids = append(txids, tx.Hash.String())\n\t\t}\n\t}\n\n\tif in.Verbose {\n\t\treturn &ListSweepsResponse{\n\t\t\tSweeps: &ListSweepsResponse_TransactionDetails{\n\t\t\t\tTransactionDetails: lnrpc.RPCTransactionDetails(\n\t\t\t\t\ttxDetails,\n\t\t\t\t),\n\t\t\t},\n\t\t}, nil\n\t}\n\n\treturn &ListSweepsResponse{\n\t\tSweeps: &ListSweepsResponse_TransactionIds{\n\t\t\tTransactionIds: &ListSweepsResponse_TransactionIDs{\n\t\t\t\tTransactionIds: txids,\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// LabelTransaction adds a label to a transaction.",
      "length": 1471,
      "tokens": 199,
      "embedding": []
    },
    {
      "slug": "func (w *WalletKit) LabelTransaction(ctx context.Context,",
      "content": "func (w *WalletKit) LabelTransaction(ctx context.Context,\n\treq *LabelTransactionRequest) (*LabelTransactionResponse, error) {\n\n\t// Check that the label provided in non-zero.\n\tif len(req.Label) == 0 {\n\t\treturn nil, ErrZeroLabel\n\t}\n\n\t// Validate the length of the non-zero label. We do not need to use the\n\t// label returned here, because the original is non-zero so will not\n\t// be replaced.\n\tif _, err := labels.ValidateAPI(req.Label); err != nil {\n\t\treturn nil, err\n\t}\n\n\thash, err := chainhash.NewHash(req.Txid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = w.cfg.Wallet.LabelTransaction(*hash, req.Label, req.Overwrite)\n\treturn &LabelTransactionResponse{}, err\n}\n\n// FundPsbt creates a fully populated PSBT that contains enough inputs to fund\n// the outputs specified in the template. There are two ways of specifying a\n// template: Either by passing in a PSBT with at least one output declared or\n// by passing in a raw TxTemplate message. If there are no inputs specified in\n// the template, coin selection is performed automatically. If the template does\n// contain any inputs, it is assumed that full coin selection happened\n// externally and no additional inputs are added. If the specified inputs aren't\n// enough to fund the outputs with the given fee rate, an error is returned.\n// After either selecting or verifying the inputs, all input UTXOs are locked\n// with an internal app ID. A custom address type for change can be specified\n// for default accounts and single imported public keys (only P2TR for now).\n// Otherwise, P2WPKH will be used by default. No custom address type should be\n// provided for custom accounts as we will always generate the change address\n// using the coin selection key scope.\n//\n// NOTE: If this method returns without an error, it is the caller's\n// responsibility to either spend the locked UTXOs (by finalizing and then\n// publishing the transaction) or to unlock/release the locked UTXOs in case of\n// an error on the caller's side.",
      "length": 1879,
      "tokens": 317,
      "embedding": []
    },
    {
      "slug": "func (w *WalletKit) FundPsbt(_ context.Context,",
      "content": "func (w *WalletKit) FundPsbt(_ context.Context,\n\treq *FundPsbtRequest) (*FundPsbtResponse, error) {\n\n\tvar (\n\t\terr         error\n\t\tpacket      *psbt.Packet\n\t\tfeeSatPerKW chainfee.SatPerKWeight\n\t\tlocks       []*base.ListLeasedOutputResult\n\t\trawPsbt     bytes.Buffer\n\t)\n\n\t// There are two ways a user can specify what we call the template (a\n\t// list of inputs and outputs to use in the PSBT): Either as a PSBT\n\t// packet directly or as a special RPC message. Find out which one the\n\t// user wants to use, they are mutually exclusive.\n\tswitch {\n\t// The template is specified as a PSBT. All we have to do is parse it.\n\tcase req.GetPsbt() != nil:\n\t\tr := bytes.NewReader(req.GetPsbt())\n\t\tpacket, err = psbt.NewFromRawBytes(r, false)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not parse PSBT: %v\", err)\n\t\t}\n\n\t// The template is specified as a RPC message. We need to create a new\n\t// PSBT and copy the RPC information over.\n\tcase req.GetRaw() != nil:\n\t\ttpl := req.GetRaw()\n\n\t\ttxOut := make([]*wire.TxOut, 0, len(tpl.Outputs))\n\t\tfor addrStr, amt := range tpl.Outputs {\n\t\t\taddr, err := btcutil.DecodeAddress(\n\t\t\t\taddrStr, w.cfg.ChainParams,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"error parsing address \"+\n\t\t\t\t\t\"%s for network %s: %v\", addrStr,\n\t\t\t\t\tw.cfg.ChainParams.Name, err)\n\t\t\t}\n\t\t\tpkScript, err := txscript.PayToAddrScript(addr)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"error getting pk \"+\n\t\t\t\t\t\"script for address %s: %v\", addrStr,\n\t\t\t\t\terr)\n\t\t\t}\n\n\t\t\ttxOut = append(txOut, &wire.TxOut{\n\t\t\t\tValue:    int64(amt),\n\t\t\t\tPkScript: pkScript,\n\t\t\t})\n\t\t}\n\n\t\ttxIn := make([]*wire.OutPoint, len(tpl.Inputs))\n\t\tfor idx, in := range tpl.Inputs {\n\t\t\top, err := unmarshallOutPoint(in)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"error parsing \"+\n\t\t\t\t\t\"outpoint: %v\", err)\n\t\t\t}\n\t\t\ttxIn[idx] = op\n\t\t}\n\n\t\tsequences := make([]uint32, len(txIn))\n\t\tpacket, err = psbt.New(txIn, txOut, 2, 0, sequences)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not create PSBT: %v\", err)\n\t\t}\n\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"transaction template missing, need \" +\n\t\t\t\"to specify either PSBT or raw TX template\")\n\t}\n\n\t// Determine the desired transaction fee.\n\tswitch {\n\t// Estimate the fee by the target number of blocks to confirmation.\n\tcase req.GetTargetConf() != 0:\n\t\ttargetConf := req.GetTargetConf()\n\t\tif targetConf < 2 {\n\t\t\treturn nil, fmt.Errorf(\"confirmation target must be \" +\n\t\t\t\t\"greater than 1\")\n\t\t}\n\n\t\tfeeSatPerKW, err = w.cfg.FeeEstimator.EstimateFeePerKW(\n\t\t\ttargetConf,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not estimate fee: %v\",\n\t\t\t\terr)\n\t\t}\n\n\t// Convert the fee to sat/kW from the specified sat/vByte.\n\tcase req.GetSatPerVbyte() != 0:\n\t\tfeeSatPerKW = chainfee.SatPerKVByte(\n\t\t\treq.GetSatPerVbyte() * 1000,\n\t\t).FeePerKWeight()\n\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"fee definition missing, need to \" +\n\t\t\t\"specify either target_conf or sat_per_vbyte\")\n\t}\n\n\t// Then, we'll extract the minimum number of confirmations that each\n\t// output we use to fund the transaction should satisfy.\n\tminConfs, err := lnrpc.ExtractMinConfs(\n\t\treq.GetMinConfs(), req.GetSpendUnconfirmed(),\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// The RPC parsing part is now over. Several of the following operations\n\t// require us to hold the global coin selection lock so we do the rest\n\t// of the tasks while holding the lock. The result is a list of locked\n\t// UTXOs.\n\tchangeIndex := int32(-1)\n\terr = w.cfg.CoinSelectionLocker.WithCoinSelectLock(func() error {\n\t\t// We'll assume the PSBT will be funded by the default account\n\t\t// unless otherwise specified.\n\t\taccount := lnwallet.DefaultAccountName\n\t\tif req.Account != \"\" {\n\t\t\taccount = req.Account\n\t\t}\n\n\t\t// In case the user did specify inputs, we need to make sure\n\t\t// they are known to us, still unspent and not yet locked.\n\t\tif len(packet.UnsignedTx.TxIn) > 0 {\n\t\t\t// Get a list of all unspent witness outputs.\n\t\t\tutxos, err := w.cfg.Wallet.ListUnspentWitness(\n\t\t\t\tminConfs, defaultMaxConf, account,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Validate all inputs against our known list of UTXOs\n\t\t\t// now.\n\t\t\terr = verifyInputsUnspent(packet.UnsignedTx.TxIn, utxos)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\t// We made sure the input from the user is as sane as possible.\n\t\t// We can now ask the wallet to fund the TX. This will not yet\n\t\t// lock any coins but might still change the wallet DB by\n\t\t// generating a new change address.\n\t\tchangeIndex, err = w.cfg.Wallet.FundPsbt(\n\t\t\tpacket, minConfs, feeSatPerKW, account,\n\t\t\tkeyScopeFromChangeAddressType(req.ChangeType),\n\t\t)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"wallet couldn't fund PSBT: %v\", err)\n\t\t}\n\n\t\t// Make sure we can properly serialize the packet. If this goes\n\t\t// wrong then something isn't right with the inputs and we\n\t\t// probably shouldn't try to lock any of them.\n\t\terr = packet.Serialize(&rawPsbt)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error serializing funded PSBT: %v\",\n\t\t\t\terr)\n\t\t}\n\n\t\t// Now we have obtained a set of coins that can be used to fund\n\t\t// the TX. Let's lock them to be sure they aren't spent by the\n\t\t// time the PSBT is published. This is the action we do here\n\t\t// that could cause an error. Therefore if some of the UTXOs\n\t\t// cannot be locked, the rollback of the other's locks also\n\t\t// happens in this function. If we ever need to do more after\n\t\t// this function, we need to extract the rollback needs to be\n\t\t// extracted into a defer.\n\t\tlocks, err = lockInputs(w.cfg.Wallet, packet)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"could not lock inputs: %v\", err)\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Convert the lock leases to the RPC format.\n\trpcLocks := marshallLeases(locks)\n\n\treturn &FundPsbtResponse{\n\t\tFundedPsbt:        rawPsbt.Bytes(),\n\t\tChangeOutputIndex: changeIndex,\n\t\tLockedUtxos:       rpcLocks,\n\t}, nil\n}\n\n// marshallLeases converts the lock leases to the RPC format.",
      "length": 5642,
      "tokens": 869,
      "embedding": []
    },
    {
      "slug": "func marshallLeases(locks []*base.ListLeasedOutputResult) []*UtxoLease {",
      "content": "func marshallLeases(locks []*base.ListLeasedOutputResult) []*UtxoLease {\n\trpcLocks := make([]*UtxoLease, len(locks))\n\tfor idx, lock := range locks {\n\t\tlock := lock\n\n\t\trpcLocks[idx] = &UtxoLease{\n\t\t\tId: lock.LockID[:],\n\t\t\tOutpoint: &lnrpc.OutPoint{\n\t\t\t\tTxidBytes:   lock.Outpoint.Hash[:],\n\t\t\t\tTxidStr:     lock.Outpoint.Hash.String(),\n\t\t\t\tOutputIndex: lock.Outpoint.Index,\n\t\t\t},\n\t\t\tExpiration: uint64(lock.Expiration.Unix()),\n\t\t\tPkScript:   lock.PkScript,\n\t\t\tValue:      uint64(lock.Value),\n\t\t}\n\t}\n\n\treturn rpcLocks\n}\n\n// keyScopeFromChangeAddressType maps a ChangeAddressType from protobuf to a\n// KeyScope. If the type is ChangeAddressType_CHANGE_ADDRESS_TYPE_UNSPECIFIED,\n// it returns nil.",
      "length": 597,
      "tokens": 59,
      "embedding": []
    },
    {
      "slug": "func keyScopeFromChangeAddressType(",
      "content": "func keyScopeFromChangeAddressType(\n\tchangeAddressType ChangeAddressType) *waddrmgr.KeyScope {\n\n\tswitch changeAddressType {\n\tcase ChangeAddressType_CHANGE_ADDRESS_TYPE_P2TR:\n\t\treturn &waddrmgr.KeyScopeBIP0086\n\n\tdefault:\n\t\treturn nil\n\t}\n}\n\n// SignPsbt expects a partial transaction with all inputs and outputs fully\n// declared and tries to sign all unsigned inputs that have all required fields\n// (UTXO information, BIP32 derivation information, witness or sig scripts)\n// set.\n// If no error is returned, the PSBT is ready to be given to the next signer or\n// to be finalized if lnd was the last signer.\n//\n// NOTE: This RPC only signs inputs (and only those it can sign), it does not\n// perform any other tasks (such as coin selection, UTXO locking or\n// input/output/fee value validation, PSBT finalization). Any input that is\n// incomplete will be skipped.",
      "length": 804,
      "tokens": 126,
      "embedding": []
    },
    {
      "slug": "func (w *WalletKit) SignPsbt(_ context.Context, req *SignPsbtRequest) (",
      "content": "func (w *WalletKit) SignPsbt(_ context.Context, req *SignPsbtRequest) (\n\t*SignPsbtResponse, error) {\n\n\tpacket, err := psbt.NewFromRawBytes(\n\t\tbytes.NewReader(req.FundedPsbt), false,\n\t)\n\tif err != nil {\n\t\tlog.Debugf(\"Error parsing PSBT: %v, raw input: %x\", err,\n\t\t\treq.FundedPsbt)\n\t\treturn nil, fmt.Errorf(\"error parsing PSBT: %v\", err)\n\t}\n\n\t// Before we attempt to sign the packet, ensure that every input either\n\t// has a witness UTXO, or a non witness UTXO.\n\tfor idx := range packet.UnsignedTx.TxIn {\n\t\tin := packet.Inputs[idx]\n\n\t\t// Doesn't have either a witness or non witness UTXO so we need\n\t\t// to exit here as otherwise signing will fail.\n\t\tif in.WitnessUtxo == nil && in.NonWitnessUtxo == nil {\n\t\t\treturn nil, fmt.Errorf(\"input (index=%v) doesn't \"+\n\t\t\t\t\"specify any UTXO info\", idx)\n\t\t}\n\t}\n\n\t// Let the wallet do the heavy lifting. This will sign all inputs that\n\t// we have the UTXO for. If some inputs can't be signed and don't have\n\t// witness data attached, they will just be skipped.\n\tsignedInputs, err := w.cfg.Wallet.SignPsbt(packet)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error signing PSBT: %v\", err)\n\t}\n\n\t// Serialize the signed PSBT in both the packet and wire format.\n\tvar signedPsbtBytes bytes.Buffer\n\terr = packet.Serialize(&signedPsbtBytes)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error serializing PSBT: %v\", err)\n\t}\n\n\treturn &SignPsbtResponse{\n\t\tSignedPsbt:   signedPsbtBytes.Bytes(),\n\t\tSignedInputs: signedInputs,\n\t}, nil\n}\n\n// FinalizePsbt expects a partial transaction with all inputs and outputs fully\n// declared and tries to sign all inputs that belong to the wallet. Lnd must be\n// the last signer of the transaction. That means, if there are any unsigned\n// non-witness inputs or inputs without UTXO information attached or inputs\n// without witness data that do not belong to lnd's wallet, this method will\n// fail. If no error is returned, the PSBT is ready to be extracted and the\n// final TX within to be broadcast.\n//\n// NOTE: This method does NOT publish the transaction once finalized. It is the\n// caller's responsibility to either publish the transaction on success or\n// unlock/release any locked UTXOs in case of an error in this method.",
      "length": 2063,
      "tokens": 332,
      "embedding": []
    },
    {
      "slug": "func (w *WalletKit) FinalizePsbt(_ context.Context,",
      "content": "func (w *WalletKit) FinalizePsbt(_ context.Context,\n\treq *FinalizePsbtRequest) (*FinalizePsbtResponse, error) {\n\n\t// We'll assume the PSBT was funded by the default account unless\n\t// otherwise specified.\n\taccount := lnwallet.DefaultAccountName\n\tif req.Account != \"\" {\n\t\taccount = req.Account\n\t}\n\n\t// Parse the funded PSBT.\n\tpacket, err := psbt.NewFromRawBytes(\n\t\tbytes.NewReader(req.FundedPsbt), false,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error parsing PSBT: %v\", err)\n\t}\n\n\t// The only check done at this level is to validate that the PSBT is\n\t// not complete. The wallet performs all other checks.\n\tif packet.IsComplete() {\n\t\treturn nil, fmt.Errorf(\"PSBT is already fully signed\")\n\t}\n\n\t// Let the wallet do the heavy lifting. This will sign all inputs that\n\t// we have the UTXO for. If some inputs can't be signed and don't have\n\t// witness data attached, this will fail.\n\terr = w.cfg.Wallet.FinalizePsbt(packet, account)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error finalizing PSBT: %v\", err)\n\t}\n\n\tvar (\n\t\tfinalPsbtBytes bytes.Buffer\n\t\tfinalTxBytes   bytes.Buffer\n\t)\n\n\t// Serialize the finalized PSBT in both the packet and wire format.\n\terr = packet.Serialize(&finalPsbtBytes)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error serializing PSBT: %v\", err)\n\t}\n\tfinalTx, err := psbt.Extract(packet)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to extract final TX: %v\", err)\n\t}\n\terr = finalTx.Serialize(&finalTxBytes)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error serializing final TX: %v\", err)\n\t}\n\n\treturn &FinalizePsbtResponse{\n\t\tSignedPsbt: finalPsbtBytes.Bytes(),\n\t\tRawFinalTx: finalTxBytes.Bytes(),\n\t}, nil\n}\n\n// marshalWalletAccount converts the properties of an account into its RPC\n// representation.",
      "length": 1622,
      "tokens": 238,
      "embedding": []
    },
    {
      "slug": "func marshalWalletAccount(internalScope waddrmgr.KeyScope,",
      "content": "func marshalWalletAccount(internalScope waddrmgr.KeyScope,\n\taccount *waddrmgr.AccountProperties) (*Account, error) {\n\n\tvar addrType AddressType\n\tswitch account.KeyScope {\n\tcase waddrmgr.KeyScopeBIP0049Plus:\n\t\t// No address schema present represents the traditional BIP-0049\n\t\t// address derivation scheme.\n\t\tif account.AddrSchema == nil {\n\t\t\taddrType = AddressType_HYBRID_NESTED_WITNESS_PUBKEY_HASH\n\t\t\tbreak\n\t\t}\n\n\t\tswitch *account.AddrSchema {\n\t\tcase waddrmgr.KeyScopeBIP0049AddrSchema:\n\t\t\taddrType = AddressType_NESTED_WITNESS_PUBKEY_HASH\n\n\t\tcase waddrmgr.ScopeAddrMap[waddrmgr.KeyScopeBIP0049Plus]:\n\t\t\taddrType = AddressType_HYBRID_NESTED_WITNESS_PUBKEY_HASH\n\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"unsupported address schema %v\",\n\t\t\t\t*account.AddrSchema)\n\t\t}\n\n\tcase waddrmgr.KeyScopeBIP0084:\n\t\taddrType = AddressType_WITNESS_PUBKEY_HASH\n\n\tcase waddrmgr.KeyScopeBIP0086:\n\t\taddrType = AddressType_TAPROOT_PUBKEY\n\n\tcase internalScope:\n\t\taddrType = AddressType_WITNESS_PUBKEY_HASH\n\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"account %v has unsupported \"+\n\t\t\t\"key scope %v\", account.AccountName, account.KeyScope)\n\t}\n\n\trpcAccount := &Account{\n\t\tName:             account.AccountName,\n\t\tAddressType:      addrType,\n\t\tExternalKeyCount: account.ExternalKeyCount,\n\t\tInternalKeyCount: account.InternalKeyCount,\n\t\tWatchOnly:        account.IsWatchOnly,\n\t}\n\n\t// The remaining fields can only be done on accounts other than the\n\t// default imported one existing within each key scope.\n\tif account.AccountName != waddrmgr.ImportedAddrAccountName {\n\t\tnonHardenedIndex := account.AccountPubKey.ChildIndex() -\n\t\t\thdkeychain.HardenedKeyStart\n\t\trpcAccount.ExtendedPublicKey = account.AccountPubKey.String()\n\t\tif account.MasterKeyFingerprint != 0 {\n\t\t\tvar mkfp [4]byte\n\t\t\tbinary.BigEndian.PutUint32(\n\t\t\t\tmkfp[:], account.MasterKeyFingerprint,\n\t\t\t)\n\t\t\trpcAccount.MasterKeyFingerprint = mkfp[:]\n\t\t}\n\t\trpcAccount.DerivationPath = fmt.Sprintf(\"%v/%v'\",\n\t\t\taccount.KeyScope, nonHardenedIndex)\n\t}\n\n\treturn rpcAccount, nil\n}\n\n// marshalWalletAddressList converts the list of address into its RPC\n// representation.",
      "length": 1956,
      "tokens": 174,
      "embedding": []
    },
    {
      "slug": "func marshalWalletAddressList(w *WalletKit, account *waddrmgr.AccountProperties,",
      "content": "func marshalWalletAddressList(w *WalletKit, account *waddrmgr.AccountProperties,\n\taddressList []lnwallet.AddressProperty) (*AccountWithAddresses, error) {\n\n\t// Get the RPC representation of account.\n\trpcAccount, err := marshalWalletAccount(\n\t\tw.internalScope(), account,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\taddresses := make([]*AddressProperty, len(addressList))\n\tfor idx, addr := range addressList {\n\t\taddresses[idx] = &AddressProperty{\n\t\t\tAddress:    addr.Address,\n\t\t\tIsInternal: addr.Internal,\n\t\t\tBalance:    int64(addr.Balance),\n\t\t}\n\t}\n\n\trpcAddressList := &AccountWithAddresses{\n\t\tName:           rpcAccount.Name,\n\t\tAddressType:    rpcAccount.AddressType,\n\t\tDerivationPath: rpcAccount.DerivationPath,\n\t\tAddresses:      addresses,\n\t}\n\n\treturn rpcAddressList, nil\n}\n\n// ListAccounts retrieves all accounts belonging to the wallet by default. A\n// name and key scope filter can be provided to filter through all of the wallet\n// accounts and return only those matching.",
      "length": 865,
      "tokens": 101,
      "embedding": []
    },
    {
      "slug": "func (w *WalletKit) ListAccounts(ctx context.Context,",
      "content": "func (w *WalletKit) ListAccounts(ctx context.Context,\n\treq *ListAccountsRequest) (*ListAccountsResponse, error) {\n\n\t// Map the supported address types into their corresponding key scope.\n\tvar keyScopeFilter *waddrmgr.KeyScope\n\tswitch req.AddressType {\n\tcase AddressType_UNKNOWN:\n\t\tbreak\n\n\tcase AddressType_WITNESS_PUBKEY_HASH:\n\t\tkeyScope := waddrmgr.KeyScopeBIP0084\n\t\tkeyScopeFilter = &keyScope\n\n\tcase AddressType_NESTED_WITNESS_PUBKEY_HASH,\n\t\tAddressType_HYBRID_NESTED_WITNESS_PUBKEY_HASH:\n\n\t\tkeyScope := waddrmgr.KeyScopeBIP0049Plus\n\t\tkeyScopeFilter = &keyScope\n\n\tcase AddressType_TAPROOT_PUBKEY:\n\t\tkeyScope := waddrmgr.KeyScopeBIP0086\n\t\tkeyScopeFilter = &keyScope\n\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unhandled address type %v\", req.AddressType)\n\t}\n\n\taccounts, err := w.cfg.Wallet.ListAccounts(req.Name, keyScopeFilter)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trpcAccounts := make([]*Account, 0, len(accounts))\n\tfor _, account := range accounts {\n\t\t// Don't include the default imported accounts created by the\n\t\t// wallet in the response if they don't have any keys imported.\n\t\tif account.AccountName == waddrmgr.ImportedAddrAccountName &&\n\t\t\taccount.ImportedKeyCount == 0 {\n\n\t\t\tcontinue\n\t\t}\n\n\t\trpcAccount, err := marshalWalletAccount(\n\t\t\tw.internalScope(), account,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\trpcAccounts = append(rpcAccounts, rpcAccount)\n\t}\n\n\treturn &ListAccountsResponse{Accounts: rpcAccounts}, nil\n}\n\n// RequiredReserve returns the minimum amount of satoshis that should be\n// kept in the wallet in order to fee bump anchor channels if necessary.\n// The value scales with the number of public anchor channels but is\n// capped at a maximum.",
      "length": 1556,
      "tokens": 187,
      "embedding": []
    },
    {
      "slug": "func (w *WalletKit) RequiredReserve(ctx context.Context,",
      "content": "func (w *WalletKit) RequiredReserve(ctx context.Context,\n\treq *RequiredReserveRequest) (*RequiredReserveResponse, error) {\n\n\tnumAnchorChans, err := w.cfg.CurrentNumAnchorChans()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tadditionalChans := req.AdditionalPublicChannels\n\ttotalChans := uint32(numAnchorChans) + additionalChans\n\treserved := w.cfg.Wallet.RequiredReserve(totalChans)\n\n\treturn &RequiredReserveResponse{\n\t\tRequiredReserve: int64(reserved),\n\t}, nil\n}\n\n// ListAddresses retrieves all the addresses along with their balance. An\n// account name filter can be provided to filter through all of the\n// wallet accounts and return the addresses of only those matching.",
      "length": 592,
      "tokens": 71,
      "embedding": []
    },
    {
      "slug": "func (w *WalletKit) ListAddresses(ctx context.Context,",
      "content": "func (w *WalletKit) ListAddresses(ctx context.Context,\n\treq *ListAddressesRequest) (*ListAddressesResponse, error) {\n\n\taddressLists, err := w.cfg.Wallet.ListAddresses(\n\t\treq.AccountName,\n\t\treq.ShowCustomAccounts,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a slice of accounts from addressLists map.\n\taccounts := make([]*waddrmgr.AccountProperties, 0, len(addressLists))\n\tfor account := range addressLists {\n\t\taccounts = append(accounts, account)\n\t}\n\n\t// Sort the accounts by derivation path.\n\tsort.Slice(accounts, func(i, j int) bool {\n\t\tscopeI := accounts[i].KeyScope\n\t\tscopeJ := accounts[j].KeyScope\n\t\tif scopeI.Purpose == scopeJ.Purpose {\n\t\t\tif scopeI.Coin == scopeJ.Coin {\n\t\t\t\tacntNumI := accounts[i].AccountNumber\n\t\t\t\tacntNumJ := accounts[j].AccountNumber\n\t\t\t\treturn acntNumI < acntNumJ\n\t\t\t}\n\n\t\t\treturn scopeI.Coin < scopeJ.Coin\n\t\t}\n\n\t\treturn scopeI.Purpose < scopeJ.Purpose\n\t})\n\n\trpcAddressLists := make([]*AccountWithAddresses, 0, len(addressLists))\n\tfor _, account := range accounts {\n\t\taddressList := addressLists[account]\n\t\trpcAddressList, err := marshalWalletAddressList(\n\t\t\tw, account, addressList,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\trpcAddressLists = append(rpcAddressLists, rpcAddressList)\n\t}\n\n\treturn &ListAddressesResponse{\n\t\tAccountWithAddresses: rpcAddressLists,\n\t}, nil\n}\n\n// parseAddrType parses an address type from its RPC representation to a\n// *waddrmgr.AddressType.",
      "length": 1306,
      "tokens": 154,
      "embedding": []
    },
    {
      "slug": "func parseAddrType(addrType AddressType,",
      "content": "func parseAddrType(addrType AddressType,\n\trequired bool) (*waddrmgr.AddressType, error) {\n\n\tswitch addrType {\n\tcase AddressType_UNKNOWN:\n\t\tif required {\n\t\t\treturn nil, errors.New(\"an address type must be specified\")\n\t\t}\n\t\treturn nil, nil\n\n\tcase AddressType_WITNESS_PUBKEY_HASH:\n\t\taddrTyp := waddrmgr.WitnessPubKey\n\t\treturn &addrTyp, nil\n\n\tcase AddressType_NESTED_WITNESS_PUBKEY_HASH:\n\t\taddrTyp := waddrmgr.NestedWitnessPubKey\n\t\treturn &addrTyp, nil\n\n\tcase AddressType_HYBRID_NESTED_WITNESS_PUBKEY_HASH:\n\t\taddrTyp := waddrmgr.WitnessPubKey\n\t\treturn &addrTyp, nil\n\n\tcase AddressType_TAPROOT_PUBKEY:\n\t\taddrTyp := waddrmgr.TaprootPubKey\n\t\treturn &addrTyp, nil\n\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unhandled address type %v\", addrType)\n\t}\n}\n\n// msgSignaturePrefix is a prefix used to prevent inadvertently signing a\n// transaction or a signature. It is prepended in front of the message and\n// follows the same standard as bitcoin core and btcd.\nconst msgSignaturePrefix = \"Bitcoin Signed Message:\\n\"\n\n// SignMessageWithAddr signs a message with the private key of the provided\n// address. The address needs to belong to the lnd wallet.",
      "length": 1054,
      "tokens": 131,
      "embedding": []
    },
    {
      "slug": "func (w *WalletKit) SignMessageWithAddr(ctx context.Context,",
      "content": "func (w *WalletKit) SignMessageWithAddr(ctx context.Context,\n\treq *SignMessageWithAddrRequest) (*SignMessageWithAddrResponse, error) {\n\n\taddr, err := btcutil.DecodeAddress(req.Addr, w.cfg.ChainParams)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to decode address: %w\", err)\n\t}\n\n\tif !addr.IsForNet(w.cfg.ChainParams) {\n\t\treturn nil, fmt.Errorf(\"encoded address is for \"+\n\t\t\t\"the wrong network %s\", req.Addr)\n\t}\n\n\t// Fetch address infos from own wallet and check whether it belongs\n\t// to the lnd wallet.\n\tmanagedAddr, err := w.cfg.Wallet.AddressInfo(addr)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"address could not be found in the \"+\n\t\t\t\"wallet database: %w\", err)\n\t}\n\n\t// Verifying by checking the interface type that the wallet knows about\n\t// the public and private keys so it can sign the message with the\n\t// private key of this address.\n\tpubKey, ok := managedAddr.(waddrmgr.ManagedPubKeyAddress)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"private key to address is unknown\")\n\t}\n\n\tdigest, err := doubleHashMessage(msgSignaturePrefix, string(req.Msg))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// For all address types (P2WKH, NP2WKH,P2TR) the ECDSA compact signing\n\t// algorithm is used. For P2TR addresses this represents a special case.\n\t// ECDSA is used to create a compact signature which makes the public\n\t// key of the signature recoverable. For Schnorr no known compact\n\t// signing algorithm exists yet.\n\tprivKey, err := pubKey.PrivKey()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"no private key could be \"+\n\t\t\t\"fetched from wallet database: %w\", err)\n\t}\n\n\tsigBytes, err := ecdsa.SignCompact(privKey, digest, pubKey.Compressed())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create signature: %w\", err)\n\t}\n\n\t// Bitcoin signatures are base64 encoded (being compatible with\n\t// bitcoin-core and btcd).\n\tsig := base64.StdEncoding.EncodeToString(sigBytes)\n\n\treturn &SignMessageWithAddrResponse{\n\t\tSignature: sig,\n\t}, nil\n}\n\n// VerifyMessageWithAddr verifies a signature on a message with a provided\n// address, it checks both the validity of the signature itself and then\n// verifies whether the signature corresponds to the public key of the\n// provided address. There is no dependence on the private key of the address\n// therefore also external addresses are allowed to verify signatures.\n// Supported address types are P2PKH, P2WKH, NP2WKH, P2TR.",
      "length": 2240,
      "tokens": 331,
      "embedding": []
    },
    {
      "slug": "func (w *WalletKit) VerifyMessageWithAddr(ctx context.Context,",
      "content": "func (w *WalletKit) VerifyMessageWithAddr(ctx context.Context,\n\treq *VerifyMessageWithAddrRequest) (*VerifyMessageWithAddrResponse,\n\terror) {\n\n\tsig, err := base64.StdEncoding.DecodeString(req.Signature)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"malformed base64 encoding of \"+\n\t\t\t\"the signature: %w\", err)\n\t}\n\n\tdigest, err := doubleHashMessage(msgSignaturePrefix, string(req.Msg))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpk, wasCompressed, err := ecdsa.RecoverCompact(sig, digest)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to recover public key \"+\n\t\t\t\"from compact signature: %w\", err)\n\t}\n\n\tvar serializedPubkey []byte\n\tif wasCompressed {\n\t\tserializedPubkey = pk.SerializeCompressed()\n\t} else {\n\t\tserializedPubkey = pk.SerializeUncompressed()\n\t}\n\n\taddr, err := btcutil.DecodeAddress(req.Addr, w.cfg.ChainParams)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to decode address: %w\", err)\n\t}\n\n\tif !addr.IsForNet(w.cfg.ChainParams) {\n\t\treturn nil, fmt.Errorf(\"encoded address is for\"+\n\t\t\t\"the wrong network %s\", req.Addr)\n\t}\n\n\tvar (\n\t\taddress    btcutil.Address\n\t\tpubKeyHash = btcutil.Hash160(serializedPubkey)\n\t)\n\n\t// Ensure the address is one of the supported types.\n\tswitch addr.(type) {\n\tcase *btcutil.AddressPubKeyHash:\n\t\taddress, err = btcutil.NewAddressPubKeyHash(\n\t\t\tpubKeyHash, w.cfg.ChainParams,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\tcase *btcutil.AddressWitnessPubKeyHash:\n\t\taddress, err = btcutil.NewAddressWitnessPubKeyHash(\n\t\t\tpubKeyHash, w.cfg.ChainParams,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\tcase *btcutil.AddressScriptHash:\n\t\t// Check if address is a Nested P2WKH (NP2WKH).\n\t\taddress, err = btcutil.NewAddressWitnessPubKeyHash(\n\t\t\tpubKeyHash, w.cfg.ChainParams,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\twitnessScript, err := txscript.PayToAddrScript(address)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\taddress, err = btcutil.NewAddressScriptHashFromHash(\n\t\t\tbtcutil.Hash160(witnessScript), w.cfg.ChainParams,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\tcase *btcutil.AddressTaproot:\n\t\t// Only addresses without a tapscript are allowed because\n\t\t// the verification is using the internal key.\n\t\ttapKey := txscript.ComputeTaprootKeyNoScript(pk)\n\t\taddress, err = btcutil.NewAddressTaproot(\n\t\t\tschnorr.SerializePubKey(tapKey),\n\t\t\tw.cfg.ChainParams,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported address type\")\n\t}\n\n\treturn &VerifyMessageWithAddrResponse{\n\t\tValid:  req.Addr == address.EncodeAddress(),\n\t\tPubkey: serializedPubkey,\n\t}, nil\n}\n\n// ImportAccount imports an account backed by an account extended public key.\n// The master key fingerprint denotes the fingerprint of the root key\n// corresponding to the account public key (also known as the key with\n// derivation path m/). This may be required by some hardware wallets for proper\n// identification and signing.\n//\n// The address type can usually be inferred from the key's version, but may be\n// required for certain keys to map them into the proper scope.\n//\n// For BIP-0044 keys, an address type must be specified as we intend to not\n// support importing BIP-0044 keys into the wallet using the legacy\n// pay-to-pubkey-hash (P2PKH) scheme. A nested witness address type will force\n// the standard BIP-0049 derivation scheme, while a witness address type will\n// force the standard BIP-0084 derivation scheme.\n//\n// For BIP-0049 keys, an address type must also be specified to make a\n// distinction between the standard BIP-0049 address schema (nested witness\n// pubkeys everywhere) and our own BIP-0049Plus address schema (nested pubkeys\n// externally, witness pubkeys internally).",
      "length": 3461,
      "tokens": 465,
      "embedding": []
    },
    {
      "slug": "func (w *WalletKit) ImportAccount(_ context.Context,",
      "content": "func (w *WalletKit) ImportAccount(_ context.Context,\n\treq *ImportAccountRequest) (*ImportAccountResponse, error) {\n\n\taccountPubKey, err := hdkeychain.NewKeyFromString(req.ExtendedPublicKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar mkfp uint32\n\tswitch len(req.MasterKeyFingerprint) {\n\t// No master key fingerprint provided, which is fine as it's not\n\t// required.\n\tcase 0:\n\t// Expected length.\n\tcase 4:\n\t\tmkfp = binary.BigEndian.Uint32(req.MasterKeyFingerprint)\n\tdefault:\n\t\treturn nil, errors.New(\"invalid length for master key \" +\n\t\t\t\"fingerprint, expected 4 bytes in big-endian\")\n\t}\n\n\taddrType, err := parseAddrType(req.AddressType, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\taccountProps, extAddrs, intAddrs, err := w.cfg.Wallet.ImportAccount(\n\t\treq.Name, accountPubKey, mkfp, addrType, req.DryRun,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trpcAccount, err := marshalWalletAccount(w.internalScope(), accountProps)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresp := &ImportAccountResponse{Account: rpcAccount}\n\tif !req.DryRun {\n\t\treturn resp, nil\n\t}\n\n\tresp.DryRunExternalAddrs = make([]string, len(extAddrs))\n\tfor i := 0; i < len(extAddrs); i++ {\n\t\tresp.DryRunExternalAddrs[i] = extAddrs[i].String()\n\t}\n\tresp.DryRunInternalAddrs = make([]string, len(intAddrs))\n\tfor i := 0; i < len(intAddrs); i++ {\n\t\tresp.DryRunInternalAddrs[i] = intAddrs[i].String()\n\t}\n\n\treturn resp, nil\n}\n\n// ImportPublicKey imports a single derived public key into the wallet. The\n// address type can usually be inferred from the key's version, but in the case\n// of legacy versions (xpub, tpub), an address type must be specified as we\n// intend to not support importing BIP-44 keys into the wallet using the legacy\n// pay-to-pubkey-hash (P2PKH) scheme. For Taproot keys, this will only watch\n// the BIP-0086 style output script. Use ImportTapscript for more advanced key\n// spend or script spend outputs.",
      "length": 1771,
      "tokens": 247,
      "embedding": []
    },
    {
      "slug": "func (w *WalletKit) ImportPublicKey(_ context.Context,",
      "content": "func (w *WalletKit) ImportPublicKey(_ context.Context,\n\treq *ImportPublicKeyRequest) (*ImportPublicKeyResponse, error) {\n\n\tvar (\n\t\tpubKey *btcec.PublicKey\n\t\terr    error\n\t)\n\tswitch req.AddressType {\n\tcase AddressType_TAPROOT_PUBKEY:\n\t\tpubKey, err = schnorr.ParsePubKey(req.PublicKey)\n\n\tdefault:\n\t\tpubKey, err = btcec.ParsePubKey(req.PublicKey)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\taddrType, err := parseAddrType(req.AddressType, true)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := w.cfg.Wallet.ImportPublicKey(pubKey, *addrType); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &ImportPublicKeyResponse{}, nil\n}\n\n// ImportTapscript imports a Taproot script and internal key and adds the\n// resulting Taproot output key as a watch-only output script into the wallet.\n// For BIP-0086 style Taproot keys (no root hash commitment and no script spend\n// path) use ImportPublicKey.\n//\n// NOTE: Taproot keys imported through this RPC currently _cannot_ be used for\n// funding PSBTs. Only tracking the balance and UTXOs is currently supported.",
      "length": 950,
      "tokens": 136,
      "embedding": []
    },
    {
      "slug": "func (w *WalletKit) ImportTapscript(_ context.Context,",
      "content": "func (w *WalletKit) ImportTapscript(_ context.Context,\n\treq *ImportTapscriptRequest) (*ImportTapscriptResponse, error) {\n\n\tinternalKey, err := schnorr.ParsePubKey(req.InternalPublicKey)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error parsing internal key: %v\", err)\n\t}\n\n\tvar tapscript *waddrmgr.Tapscript\n\tswitch {\n\tcase req.GetFullTree() != nil:\n\t\ttree := req.GetFullTree()\n\t\tleaves := make([]txscript.TapLeaf, len(tree.AllLeaves))\n\t\tfor idx, leaf := range tree.AllLeaves {\n\t\t\tleaves[idx] = txscript.TapLeaf{\n\t\t\t\tLeafVersion: txscript.TapscriptLeafVersion(\n\t\t\t\t\tleaf.LeafVersion,\n\t\t\t\t),\n\t\t\t\tScript: leaf.Script,\n\t\t\t}\n\t\t}\n\n\t\ttapscript = input.TapscriptFullTree(internalKey, leaves...)\n\n\tcase req.GetPartialReveal() != nil:\n\t\tpartialReveal := req.GetPartialReveal()\n\t\tif partialReveal.RevealedLeaf == nil {\n\t\t\treturn nil, fmt.Errorf(\"missing revealed leaf\")\n\t\t}\n\n\t\trevealedLeaf := txscript.TapLeaf{\n\t\t\tLeafVersion: txscript.TapscriptLeafVersion(\n\t\t\t\tpartialReveal.RevealedLeaf.LeafVersion,\n\t\t\t),\n\t\t\tScript: partialReveal.RevealedLeaf.Script,\n\t\t}\n\t\tif len(partialReveal.FullInclusionProof)%32 != 0 {\n\t\t\treturn nil, fmt.Errorf(\"invalid inclusion proof \"+\n\t\t\t\t\"length, expected multiple of 32, got %d\",\n\t\t\t\tlen(partialReveal.FullInclusionProof)%32)\n\t\t}\n\n\t\ttapscript = input.TapscriptPartialReveal(\n\t\t\tinternalKey, revealedLeaf,\n\t\t\tpartialReveal.FullInclusionProof,\n\t\t)\n\n\tcase req.GetRootHashOnly() != nil:\n\t\trootHash := req.GetRootHashOnly()\n\t\tif len(rootHash) == 0 {\n\t\t\treturn nil, fmt.Errorf(\"missing root hash\")\n\t\t}\n\n\t\ttapscript = input.TapscriptRootHashOnly(internalKey, rootHash)\n\n\tcase req.GetFullKeyOnly():\n\t\ttapscript = input.TapscriptFullKeyOnly(internalKey)\n\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"invalid script\")\n\t}\n\n\ttaprootScope := waddrmgr.KeyScopeBIP0086\n\taddr, err := w.cfg.Wallet.ImportTaprootScript(taprootScope, tapscript)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error importing script into wallet: %v\",\n\t\t\terr)\n\t}\n\n\treturn &ImportTapscriptResponse{\n\t\tP2TrAddress: addr.Address().String(),\n\t}, nil\n}\n",
      "length": 1890,
      "tokens": 179,
      "embedding": []
    }
  ]
}