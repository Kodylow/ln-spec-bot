{
  "filepath": "../implementations/go/lnd/lnrpc/walletrpc/walletkit_grpc.pb.go",
  "package": "walletrpc",
  "sections": [
    {
      "slug": "type WalletKitClient interface {",
      "content": "type WalletKitClient interface {\n\t// ListUnspent returns a list of all utxos spendable by the wallet with a\n\t// number of confirmations between the specified minimum and maximum. By\n\t// default, all utxos are listed. To list only the unconfirmed utxos, set\n\t// the unconfirmed_only to true.\n\tListUnspent(ctx context.Context, in *ListUnspentRequest, opts ...grpc.CallOption) (*ListUnspentResponse, error)\n\t// LeaseOutput locks an output to the given ID, preventing it from being\n\t// available for any future coin selection attempts. The absolute time of the\n\t// lock's expiration is returned. The expiration of the lock can be extended by\n\t// successive invocations of this RPC. Outputs can be unlocked before their\n\t// expiration through `ReleaseOutput`.\n\tLeaseOutput(ctx context.Context, in *LeaseOutputRequest, opts ...grpc.CallOption) (*LeaseOutputResponse, error)\n\t// ReleaseOutput unlocks an output, allowing it to be available for coin\n\t// selection if it remains unspent. The ID should match the one used to\n\t// originally lock the output.\n\tReleaseOutput(ctx context.Context, in *ReleaseOutputRequest, opts ...grpc.CallOption) (*ReleaseOutputResponse, error)\n\t// ListLeases lists all currently locked utxos.\n\tListLeases(ctx context.Context, in *ListLeasesRequest, opts ...grpc.CallOption) (*ListLeasesResponse, error)\n\t// DeriveNextKey attempts to derive the *next* key within the key family\n\t// (account in BIP43) specified. This method should return the next external\n\t// child within this branch.\n\tDeriveNextKey(ctx context.Context, in *KeyReq, opts ...grpc.CallOption) (*signrpc.KeyDescriptor, error)\n\t// DeriveKey attempts to derive an arbitrary key specified by the passed\n\t// KeyLocator.\n\tDeriveKey(ctx context.Context, in *signrpc.KeyLocator, opts ...grpc.CallOption) (*signrpc.KeyDescriptor, error)\n\t// NextAddr returns the next unused address within the wallet.\n\tNextAddr(ctx context.Context, in *AddrRequest, opts ...grpc.CallOption) (*AddrResponse, error)\n\t// ListAccounts retrieves all accounts belonging to the wallet by default. A\n\t// name and key scope filter can be provided to filter through all of the\n\t// wallet accounts and return only those matching.\n\tListAccounts(ctx context.Context, in *ListAccountsRequest, opts ...grpc.CallOption) (*ListAccountsResponse, error)\n\t// RequiredReserve returns the minimum amount of satoshis that should be kept\n\t// in the wallet in order to fee bump anchor channels if necessary. The value\n\t// scales with the number of public anchor channels but is capped at a maximum.\n\tRequiredReserve(ctx context.Context, in *RequiredReserveRequest, opts ...grpc.CallOption) (*RequiredReserveResponse, error)\n\t// ListAddresses retrieves all the addresses along with their balance. An\n\t// account name filter can be provided to filter through all of the\n\t// wallet accounts and return the addresses of only those matching.\n\tListAddresses(ctx context.Context, in *ListAddressesRequest, opts ...grpc.CallOption) (*ListAddressesResponse, error)\n\t// SignMessageWithAddr returns the compact signature (base64 encoded) created\n\t// with the private key of the provided address. This requires the address\n\t// to be solely based on a public key lock (no scripts). Obviously the internal\n\t// lnd wallet has to possess the private key of the address otherwise\n\t// an error is returned.\n\t//\n\t// This method aims to provide full compatibility with the bitcoin-core and\n\t// btcd implementation. Bitcoin-core's algorithm is not specified in a\n\t// BIP and only applicable for legacy addresses. This method enhances the\n\t// signing for additional address types: P2WKH, NP2WKH, P2TR.\n\t// For P2TR addresses this represents a special case. ECDSA is used to create\n\t// a compact signature which makes the public key of the signature recoverable.\n\tSignMessageWithAddr(ctx context.Context, in *SignMessageWithAddrRequest, opts ...grpc.CallOption) (*SignMessageWithAddrResponse, error)\n\t// VerifyMessageWithAddr returns the validity and the recovered public key of\n\t// the provided compact signature (base64 encoded). The verification is\n\t// twofold. First the validity of the signature itself is checked and then\n\t// it is verified that the recovered public key of the signature equals\n\t// the public key of the provided address. There is no dependence on the\n\t// private key of the address therefore also external addresses are allowed\n\t// to verify signatures.\n\t// Supported address types are P2PKH, P2WKH, NP2WKH, P2TR.\n\t//\n\t// This method is the counterpart of the related signing method\n\t// (SignMessageWithAddr) and aims to provide full compatibility to\n\t// bitcoin-core's implementation. Although bitcoin-core/btcd only provide\n\t// this functionality for legacy addresses this function enhances it to\n\t// the address types: P2PKH, P2WKH, NP2WKH, P2TR.\n\t//\n\t// The verification for P2TR addresses is a special case and requires the\n\t// ECDSA compact signature to compare the reovered public key to the internal\n\t// taproot key. The compact ECDSA signature format was used because there\n\t// are still no known compact signature schemes for schnorr signatures.\n\tVerifyMessageWithAddr(ctx context.Context, in *VerifyMessageWithAddrRequest, opts ...grpc.CallOption) (*VerifyMessageWithAddrResponse, error)\n\t// ImportAccount imports an account backed by an account extended public key.\n\t// The master key fingerprint denotes the fingerprint of the root key\n\t// corresponding to the account public key (also known as the key with\n\t// derivation path m/). This may be required by some hardware wallets for\n\t// proper identification and signing.\n\t//\n\t// The address type can usually be inferred from the key's version, but may be\n\t// required for certain keys to map them into the proper scope.\n\t//\n\t// For BIP-0044 keys, an address type must be specified as we intend to not\n\t// support importing BIP-0044 keys into the wallet using the legacy\n\t// pay-to-pubkey-hash (P2PKH) scheme. A nested witness address type will force\n\t// the standard BIP-0049 derivation scheme, while a witness address type will\n\t// force the standard BIP-0084 derivation scheme.\n\t//\n\t// For BIP-0049 keys, an address type must also be specified to make a\n\t// distinction between the standard BIP-0049 address schema (nested witness\n\t// pubkeys everywhere) and our own BIP-0049Plus address schema (nested pubkeys\n\t// externally, witness pubkeys internally).\n\t//\n\t// NOTE: Events (deposits/spends) for keys derived from an account will only be\n\t// detected by lnd if they happen after the import. Rescans to detect past\n\t// events will be supported later on.\n\tImportAccount(ctx context.Context, in *ImportAccountRequest, opts ...grpc.CallOption) (*ImportAccountResponse, error)\n\t// ImportPublicKey imports a public key as watch-only into the wallet. The\n\t// public key is converted into a simple address of the given type and that\n\t// address script is watched on chain. For Taproot keys, this will only watch\n\t// the BIP-0086 style output script. Use ImportTapscript for more advanced key\n\t// spend or script spend outputs.\n\t//\n\t// NOTE: Events (deposits/spends) for a key will only be detected by lnd if\n\t// they happen after the import. Rescans to detect past events will be\n\t// supported later on.\n\tImportPublicKey(ctx context.Context, in *ImportPublicKeyRequest, opts ...grpc.CallOption) (*ImportPublicKeyResponse, error)\n\t// ImportTapscript imports a Taproot script and internal key and adds the\n\t// resulting Taproot output key as a watch-only output script into the wallet.\n\t// For BIP-0086 style Taproot keys (no root hash commitment and no script spend\n\t// path) use ImportPublicKey.\n\t//\n\t// NOTE: Events (deposits/spends) for a key will only be detected by lnd if\n\t// they happen after the import. Rescans to detect past events will be\n\t// supported later on.\n\t//\n\t// NOTE: Taproot keys imported through this RPC currently _cannot_ be used for\n\t// funding PSBTs. Only tracking the balance and UTXOs is currently supported.\n\tImportTapscript(ctx context.Context, in *ImportTapscriptRequest, opts ...grpc.CallOption) (*ImportTapscriptResponse, error)\n\t// PublishTransaction attempts to publish the passed transaction to the\n\t// network. Once this returns without an error, the wallet will continually\n\t// attempt to re-broadcast the transaction on start up, until it enters the\n\t// chain.\n\tPublishTransaction(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*PublishResponse, error)\n\t// SendOutputs is similar to the existing sendmany call in Bitcoind, and\n\t// allows the caller to create a transaction that sends to several outputs at\n\t// once. This is ideal when wanting to batch create a set of transactions.\n\tSendOutputs(ctx context.Context, in *SendOutputsRequest, opts ...grpc.CallOption) (*SendOutputsResponse, error)\n\t// EstimateFee attempts to query the internal fee estimator of the wallet to\n\t// determine the fee (in sat/kw) to attach to a transaction in order to\n\t// achieve the confirmation target.\n\tEstimateFee(ctx context.Context, in *EstimateFeeRequest, opts ...grpc.CallOption) (*EstimateFeeResponse, error)\n\t// PendingSweeps returns lists of on-chain outputs that lnd is currently\n\t// attempting to sweep within its central batching engine. Outputs with similar\n\t// fee rates are batched together in order to sweep them within a single\n\t// transaction.\n\t//\n\t// NOTE: Some of the fields within PendingSweepsRequest are not guaranteed to\n\t// remain supported. This is an advanced API that depends on the internals of\n\t// the UtxoSweeper, so things may change.\n\tPendingSweeps(ctx context.Context, in *PendingSweepsRequest, opts ...grpc.CallOption) (*PendingSweepsResponse, error)\n\t// BumpFee bumps the fee of an arbitrary input within a transaction. This RPC\n\t// takes a different approach than bitcoind's bumpfee command. lnd has a\n\t// central batching engine in which inputs with similar fee rates are batched\n\t// together to save on transaction fees. Due to this, we cannot rely on\n\t// bumping the fee on a specific transaction, since transactions can change at\n\t// any point with the addition of new inputs. The list of inputs that\n\t// currently exist within lnd's central batching engine can be retrieved\n\t// through the PendingSweeps RPC.\n\t//\n\t// When bumping the fee of an input that currently exists within lnd's central\n\t// batching engine, a higher fee transaction will be created that replaces the\n\t// lower fee transaction through the Replace-By-Fee (RBF) policy. If it\n\t//\n\t// This RPC also serves useful when wanting to perform a Child-Pays-For-Parent\n\t// (CPFP), where the child transaction pays for its parent's fee. This can be\n\t// done by specifying an outpoint within the low fee transaction that is under\n\t// the control of the wallet.\n\t//\n\t// The fee preference can be expressed either as a specific fee rate or a delta\n\t// of blocks in which the output should be swept on-chain within. If a fee\n\t// preference is not explicitly specified, then an error is returned.\n\t//\n\t// Note that this RPC currently doesn't perform any validation checks on the\n\t// fee preference being provided. For now, the responsibility of ensuring that\n\t// the new fee preference is sufficient is delegated to the user.\n\tBumpFee(ctx context.Context, in *BumpFeeRequest, opts ...grpc.CallOption) (*BumpFeeResponse, error)\n\t// ListSweeps returns a list of the sweep transactions our node has produced.\n\t// Note that these sweeps may not be confirmed yet, as we record sweeps on\n\t// broadcast, not confirmation.\n\tListSweeps(ctx context.Context, in *ListSweepsRequest, opts ...grpc.CallOption) (*ListSweepsResponse, error)\n\t// LabelTransaction adds a label to a transaction. If the transaction already\n\t// has a label the call will fail unless the overwrite bool is set. This will\n\t// overwrite the exiting transaction label. Labels must not be empty, and\n\t// cannot exceed 500 characters.\n\tLabelTransaction(ctx context.Context, in *LabelTransactionRequest, opts ...grpc.CallOption) (*LabelTransactionResponse, error)\n\t// FundPsbt creates a fully populated PSBT that contains enough inputs to fund\n\t// the outputs specified in the template. There are two ways of specifying a\n\t// template: Either by passing in a PSBT with at least one output declared or\n\t// by passing in a raw TxTemplate message.\n\t//\n\t// If there are no inputs specified in the template, coin selection is\n\t// performed automatically. If the template does contain any inputs, it is\n\t// assumed that full coin selection happened externally and no additional\n\t// inputs are added. If the specified inputs aren't enough to fund the outputs\n\t// with the given fee rate, an error is returned.\n\t//\n\t// After either selecting or verifying the inputs, all input UTXOs are locked\n\t// with an internal app ID.\n\t//\n\t// NOTE: If this method returns without an error, it is the caller's\n\t// responsibility to either spend the locked UTXOs (by finalizing and then\n\t// publishing the transaction) or to unlock/release the locked UTXOs in case of\n\t// an error on the caller's side.\n\tFundPsbt(ctx context.Context, in *FundPsbtRequest, opts ...grpc.CallOption) (*FundPsbtResponse, error)\n\t// SignPsbt expects a partial transaction with all inputs and outputs fully\n\t// declared and tries to sign all unsigned inputs that have all required fields\n\t// (UTXO information, BIP32 derivation information, witness or sig scripts)\n\t// set.\n\t// If no error is returned, the PSBT is ready to be given to the next signer or\n\t// to be finalized if lnd was the last signer.\n\t//\n\t// NOTE: This RPC only signs inputs (and only those it can sign), it does not\n\t// perform any other tasks (such as coin selection, UTXO locking or\n\t// input/output/fee value validation, PSBT finalization). Any input that is\n\t// incomplete will be skipped.\n\tSignPsbt(ctx context.Context, in *SignPsbtRequest, opts ...grpc.CallOption) (*SignPsbtResponse, error)\n\t// FinalizePsbt expects a partial transaction with all inputs and outputs fully\n\t// declared and tries to sign all inputs that belong to the wallet. Lnd must be\n\t// the last signer of the transaction. That means, if there are any unsigned\n\t// non-witness inputs or inputs without UTXO information attached or inputs\n\t// without witness data that do not belong to lnd's wallet, this method will\n\t// fail. If no error is returned, the PSBT is ready to be extracted and the\n\t// final TX within to be broadcast.\n\t//\n\t// NOTE: This method does NOT publish the transaction once finalized. It is the\n\t// caller's responsibility to either publish the transaction on success or\n\t// unlock/release any locked UTXOs in case of an error in this method.\n\tFinalizePsbt(ctx context.Context, in *FinalizePsbtRequest, opts ...grpc.CallOption) (*FinalizePsbtResponse, error)\n}\n",
      "length": 14418,
      "tokens": 2158,
      "embedding": []
    },
    {
      "slug": "type walletKitClient struct {",
      "content": "type walletKitClient struct {\n\tcc grpc.ClientConnInterface\n}\n",
      "length": 29,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func NewWalletKitClient(cc grpc.ClientConnInterface) WalletKitClient {",
      "content": "func NewWalletKitClient(cc grpc.ClientConnInterface) WalletKitClient {\n\treturn &walletKitClient{cc}\n}\n",
      "length": 29,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (c *walletKitClient) ListUnspent(ctx context.Context, in *ListUnspentRequest, opts ...grpc.CallOption) (*ListUnspentResponse, error) {",
      "content": "func (c *walletKitClient) ListUnspent(ctx context.Context, in *ListUnspentRequest, opts ...grpc.CallOption) (*ListUnspentResponse, error) {\n\tout := new(ListUnspentResponse)\n\terr := c.cc.Invoke(ctx, \"/walletrpc.WalletKit/ListUnspent\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 162,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *walletKitClient) LeaseOutput(ctx context.Context, in *LeaseOutputRequest, opts ...grpc.CallOption) (*LeaseOutputResponse, error) {",
      "content": "func (c *walletKitClient) LeaseOutput(ctx context.Context, in *LeaseOutputRequest, opts ...grpc.CallOption) (*LeaseOutputResponse, error) {\n\tout := new(LeaseOutputResponse)\n\terr := c.cc.Invoke(ctx, \"/walletrpc.WalletKit/LeaseOutput\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 162,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *walletKitClient) ReleaseOutput(ctx context.Context, in *ReleaseOutputRequest, opts ...grpc.CallOption) (*ReleaseOutputResponse, error) {",
      "content": "func (c *walletKitClient) ReleaseOutput(ctx context.Context, in *ReleaseOutputRequest, opts ...grpc.CallOption) (*ReleaseOutputResponse, error) {\n\tout := new(ReleaseOutputResponse)\n\terr := c.cc.Invoke(ctx, \"/walletrpc.WalletKit/ReleaseOutput\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 166,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *walletKitClient) ListLeases(ctx context.Context, in *ListLeasesRequest, opts ...grpc.CallOption) (*ListLeasesResponse, error) {",
      "content": "func (c *walletKitClient) ListLeases(ctx context.Context, in *ListLeasesRequest, opts ...grpc.CallOption) (*ListLeasesResponse, error) {\n\tout := new(ListLeasesResponse)\n\terr := c.cc.Invoke(ctx, \"/walletrpc.WalletKit/ListLeases\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 160,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *walletKitClient) DeriveNextKey(ctx context.Context, in *KeyReq, opts ...grpc.CallOption) (*signrpc.KeyDescriptor, error) {",
      "content": "func (c *walletKitClient) DeriveNextKey(ctx context.Context, in *KeyReq, opts ...grpc.CallOption) (*signrpc.KeyDescriptor, error) {\n\tout := new(signrpc.KeyDescriptor)\n\terr := c.cc.Invoke(ctx, \"/walletrpc.WalletKit/DeriveNextKey\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 166,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *walletKitClient) DeriveKey(ctx context.Context, in *signrpc.KeyLocator, opts ...grpc.CallOption) (*signrpc.KeyDescriptor, error) {",
      "content": "func (c *walletKitClient) DeriveKey(ctx context.Context, in *signrpc.KeyLocator, opts ...grpc.CallOption) (*signrpc.KeyDescriptor, error) {\n\tout := new(signrpc.KeyDescriptor)\n\terr := c.cc.Invoke(ctx, \"/walletrpc.WalletKit/DeriveKey\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 162,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *walletKitClient) NextAddr(ctx context.Context, in *AddrRequest, opts ...grpc.CallOption) (*AddrResponse, error) {",
      "content": "func (c *walletKitClient) NextAddr(ctx context.Context, in *AddrRequest, opts ...grpc.CallOption) (*AddrResponse, error) {\n\tout := new(AddrResponse)\n\terr := c.cc.Invoke(ctx, \"/walletrpc.WalletKit/NextAddr\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 152,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *walletKitClient) ListAccounts(ctx context.Context, in *ListAccountsRequest, opts ...grpc.CallOption) (*ListAccountsResponse, error) {",
      "content": "func (c *walletKitClient) ListAccounts(ctx context.Context, in *ListAccountsRequest, opts ...grpc.CallOption) (*ListAccountsResponse, error) {\n\tout := new(ListAccountsResponse)\n\terr := c.cc.Invoke(ctx, \"/walletrpc.WalletKit/ListAccounts\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 164,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *walletKitClient) RequiredReserve(ctx context.Context, in *RequiredReserveRequest, opts ...grpc.CallOption) (*RequiredReserveResponse, error) {",
      "content": "func (c *walletKitClient) RequiredReserve(ctx context.Context, in *RequiredReserveRequest, opts ...grpc.CallOption) (*RequiredReserveResponse, error) {\n\tout := new(RequiredReserveResponse)\n\terr := c.cc.Invoke(ctx, \"/walletrpc.WalletKit/RequiredReserve\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 170,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *walletKitClient) ListAddresses(ctx context.Context, in *ListAddressesRequest, opts ...grpc.CallOption) (*ListAddressesResponse, error) {",
      "content": "func (c *walletKitClient) ListAddresses(ctx context.Context, in *ListAddressesRequest, opts ...grpc.CallOption) (*ListAddressesResponse, error) {\n\tout := new(ListAddressesResponse)\n\terr := c.cc.Invoke(ctx, \"/walletrpc.WalletKit/ListAddresses\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 166,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *walletKitClient) SignMessageWithAddr(ctx context.Context, in *SignMessageWithAddrRequest, opts ...grpc.CallOption) (*SignMessageWithAddrResponse, error) {",
      "content": "func (c *walletKitClient) SignMessageWithAddr(ctx context.Context, in *SignMessageWithAddrRequest, opts ...grpc.CallOption) (*SignMessageWithAddrResponse, error) {\n\tout := new(SignMessageWithAddrResponse)\n\terr := c.cc.Invoke(ctx, \"/walletrpc.WalletKit/SignMessageWithAddr\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 178,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *walletKitClient) VerifyMessageWithAddr(ctx context.Context, in *VerifyMessageWithAddrRequest, opts ...grpc.CallOption) (*VerifyMessageWithAddrResponse, error) {",
      "content": "func (c *walletKitClient) VerifyMessageWithAddr(ctx context.Context, in *VerifyMessageWithAddrRequest, opts ...grpc.CallOption) (*VerifyMessageWithAddrResponse, error) {\n\tout := new(VerifyMessageWithAddrResponse)\n\terr := c.cc.Invoke(ctx, \"/walletrpc.WalletKit/VerifyMessageWithAddr\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 182,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *walletKitClient) ImportAccount(ctx context.Context, in *ImportAccountRequest, opts ...grpc.CallOption) (*ImportAccountResponse, error) {",
      "content": "func (c *walletKitClient) ImportAccount(ctx context.Context, in *ImportAccountRequest, opts ...grpc.CallOption) (*ImportAccountResponse, error) {\n\tout := new(ImportAccountResponse)\n\terr := c.cc.Invoke(ctx, \"/walletrpc.WalletKit/ImportAccount\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 166,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *walletKitClient) ImportPublicKey(ctx context.Context, in *ImportPublicKeyRequest, opts ...grpc.CallOption) (*ImportPublicKeyResponse, error) {",
      "content": "func (c *walletKitClient) ImportPublicKey(ctx context.Context, in *ImportPublicKeyRequest, opts ...grpc.CallOption) (*ImportPublicKeyResponse, error) {\n\tout := new(ImportPublicKeyResponse)\n\terr := c.cc.Invoke(ctx, \"/walletrpc.WalletKit/ImportPublicKey\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 170,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *walletKitClient) ImportTapscript(ctx context.Context, in *ImportTapscriptRequest, opts ...grpc.CallOption) (*ImportTapscriptResponse, error) {",
      "content": "func (c *walletKitClient) ImportTapscript(ctx context.Context, in *ImportTapscriptRequest, opts ...grpc.CallOption) (*ImportTapscriptResponse, error) {\n\tout := new(ImportTapscriptResponse)\n\terr := c.cc.Invoke(ctx, \"/walletrpc.WalletKit/ImportTapscript\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 170,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *walletKitClient) PublishTransaction(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*PublishResponse, error) {",
      "content": "func (c *walletKitClient) PublishTransaction(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*PublishResponse, error) {\n\tout := new(PublishResponse)\n\terr := c.cc.Invoke(ctx, \"/walletrpc.WalletKit/PublishTransaction\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 165,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *walletKitClient) SendOutputs(ctx context.Context, in *SendOutputsRequest, opts ...grpc.CallOption) (*SendOutputsResponse, error) {",
      "content": "func (c *walletKitClient) SendOutputs(ctx context.Context, in *SendOutputsRequest, opts ...grpc.CallOption) (*SendOutputsResponse, error) {\n\tout := new(SendOutputsResponse)\n\terr := c.cc.Invoke(ctx, \"/walletrpc.WalletKit/SendOutputs\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 162,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *walletKitClient) EstimateFee(ctx context.Context, in *EstimateFeeRequest, opts ...grpc.CallOption) (*EstimateFeeResponse, error) {",
      "content": "func (c *walletKitClient) EstimateFee(ctx context.Context, in *EstimateFeeRequest, opts ...grpc.CallOption) (*EstimateFeeResponse, error) {\n\tout := new(EstimateFeeResponse)\n\terr := c.cc.Invoke(ctx, \"/walletrpc.WalletKit/EstimateFee\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 162,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *walletKitClient) PendingSweeps(ctx context.Context, in *PendingSweepsRequest, opts ...grpc.CallOption) (*PendingSweepsResponse, error) {",
      "content": "func (c *walletKitClient) PendingSweeps(ctx context.Context, in *PendingSweepsRequest, opts ...grpc.CallOption) (*PendingSweepsResponse, error) {\n\tout := new(PendingSweepsResponse)\n\terr := c.cc.Invoke(ctx, \"/walletrpc.WalletKit/PendingSweeps\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 166,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *walletKitClient) BumpFee(ctx context.Context, in *BumpFeeRequest, opts ...grpc.CallOption) (*BumpFeeResponse, error) {",
      "content": "func (c *walletKitClient) BumpFee(ctx context.Context, in *BumpFeeRequest, opts ...grpc.CallOption) (*BumpFeeResponse, error) {\n\tout := new(BumpFeeResponse)\n\terr := c.cc.Invoke(ctx, \"/walletrpc.WalletKit/BumpFee\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 154,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *walletKitClient) ListSweeps(ctx context.Context, in *ListSweepsRequest, opts ...grpc.CallOption) (*ListSweepsResponse, error) {",
      "content": "func (c *walletKitClient) ListSweeps(ctx context.Context, in *ListSweepsRequest, opts ...grpc.CallOption) (*ListSweepsResponse, error) {\n\tout := new(ListSweepsResponse)\n\terr := c.cc.Invoke(ctx, \"/walletrpc.WalletKit/ListSweeps\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 160,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *walletKitClient) LabelTransaction(ctx context.Context, in *LabelTransactionRequest, opts ...grpc.CallOption) (*LabelTransactionResponse, error) {",
      "content": "func (c *walletKitClient) LabelTransaction(ctx context.Context, in *LabelTransactionRequest, opts ...grpc.CallOption) (*LabelTransactionResponse, error) {\n\tout := new(LabelTransactionResponse)\n\terr := c.cc.Invoke(ctx, \"/walletrpc.WalletKit/LabelTransaction\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 172,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *walletKitClient) FundPsbt(ctx context.Context, in *FundPsbtRequest, opts ...grpc.CallOption) (*FundPsbtResponse, error) {",
      "content": "func (c *walletKitClient) FundPsbt(ctx context.Context, in *FundPsbtRequest, opts ...grpc.CallOption) (*FundPsbtResponse, error) {\n\tout := new(FundPsbtResponse)\n\terr := c.cc.Invoke(ctx, \"/walletrpc.WalletKit/FundPsbt\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 156,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *walletKitClient) SignPsbt(ctx context.Context, in *SignPsbtRequest, opts ...grpc.CallOption) (*SignPsbtResponse, error) {",
      "content": "func (c *walletKitClient) SignPsbt(ctx context.Context, in *SignPsbtRequest, opts ...grpc.CallOption) (*SignPsbtResponse, error) {\n\tout := new(SignPsbtResponse)\n\terr := c.cc.Invoke(ctx, \"/walletrpc.WalletKit/SignPsbt\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 156,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *walletKitClient) FinalizePsbt(ctx context.Context, in *FinalizePsbtRequest, opts ...grpc.CallOption) (*FinalizePsbtResponse, error) {",
      "content": "func (c *walletKitClient) FinalizePsbt(ctx context.Context, in *FinalizePsbtRequest, opts ...grpc.CallOption) (*FinalizePsbtResponse, error) {\n\tout := new(FinalizePsbtResponse)\n\terr := c.cc.Invoke(ctx, \"/walletrpc.WalletKit/FinalizePsbt\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n\n// WalletKitServer is the server API for WalletKit service.\n// All implementations must embed UnimplementedWalletKitServer\n// for forward compatibility",
      "length": 313,
      "tokens": 42,
      "embedding": []
    },
    {
      "slug": "type WalletKitServer interface {",
      "content": "type WalletKitServer interface {\n\t// ListUnspent returns a list of all utxos spendable by the wallet with a\n\t// number of confirmations between the specified minimum and maximum. By\n\t// default, all utxos are listed. To list only the unconfirmed utxos, set\n\t// the unconfirmed_only to true.\n\tListUnspent(context.Context, *ListUnspentRequest) (*ListUnspentResponse, error)\n\t// LeaseOutput locks an output to the given ID, preventing it from being\n\t// available for any future coin selection attempts. The absolute time of the\n\t// lock's expiration is returned. The expiration of the lock can be extended by\n\t// successive invocations of this RPC. Outputs can be unlocked before their\n\t// expiration through `ReleaseOutput`.\n\tLeaseOutput(context.Context, *LeaseOutputRequest) (*LeaseOutputResponse, error)\n\t// ReleaseOutput unlocks an output, allowing it to be available for coin\n\t// selection if it remains unspent. The ID should match the one used to\n\t// originally lock the output.\n\tReleaseOutput(context.Context, *ReleaseOutputRequest) (*ReleaseOutputResponse, error)\n\t// ListLeases lists all currently locked utxos.\n\tListLeases(context.Context, *ListLeasesRequest) (*ListLeasesResponse, error)\n\t// DeriveNextKey attempts to derive the *next* key within the key family\n\t// (account in BIP43) specified. This method should return the next external\n\t// child within this branch.\n\tDeriveNextKey(context.Context, *KeyReq) (*signrpc.KeyDescriptor, error)\n\t// DeriveKey attempts to derive an arbitrary key specified by the passed\n\t// KeyLocator.\n\tDeriveKey(context.Context, *signrpc.KeyLocator) (*signrpc.KeyDescriptor, error)\n\t// NextAddr returns the next unused address within the wallet.\n\tNextAddr(context.Context, *AddrRequest) (*AddrResponse, error)\n\t// ListAccounts retrieves all accounts belonging to the wallet by default. A\n\t// name and key scope filter can be provided to filter through all of the\n\t// wallet accounts and return only those matching.\n\tListAccounts(context.Context, *ListAccountsRequest) (*ListAccountsResponse, error)\n\t// RequiredReserve returns the minimum amount of satoshis that should be kept\n\t// in the wallet in order to fee bump anchor channels if necessary. The value\n\t// scales with the number of public anchor channels but is capped at a maximum.\n\tRequiredReserve(context.Context, *RequiredReserveRequest) (*RequiredReserveResponse, error)\n\t// ListAddresses retrieves all the addresses along with their balance. An\n\t// account name filter can be provided to filter through all of the\n\t// wallet accounts and return the addresses of only those matching.\n\tListAddresses(context.Context, *ListAddressesRequest) (*ListAddressesResponse, error)\n\t// SignMessageWithAddr returns the compact signature (base64 encoded) created\n\t// with the private key of the provided address. This requires the address\n\t// to be solely based on a public key lock (no scripts). Obviously the internal\n\t// lnd wallet has to possess the private key of the address otherwise\n\t// an error is returned.\n\t//\n\t// This method aims to provide full compatibility with the bitcoin-core and\n\t// btcd implementation. Bitcoin-core's algorithm is not specified in a\n\t// BIP and only applicable for legacy addresses. This method enhances the\n\t// signing for additional address types: P2WKH, NP2WKH, P2TR.\n\t// For P2TR addresses this represents a special case. ECDSA is used to create\n\t// a compact signature which makes the public key of the signature recoverable.\n\tSignMessageWithAddr(context.Context, *SignMessageWithAddrRequest) (*SignMessageWithAddrResponse, error)\n\t// VerifyMessageWithAddr returns the validity and the recovered public key of\n\t// the provided compact signature (base64 encoded). The verification is\n\t// twofold. First the validity of the signature itself is checked and then\n\t// it is verified that the recovered public key of the signature equals\n\t// the public key of the provided address. There is no dependence on the\n\t// private key of the address therefore also external addresses are allowed\n\t// to verify signatures.\n\t// Supported address types are P2PKH, P2WKH, NP2WKH, P2TR.\n\t//\n\t// This method is the counterpart of the related signing method\n\t// (SignMessageWithAddr) and aims to provide full compatibility to\n\t// bitcoin-core's implementation. Although bitcoin-core/btcd only provide\n\t// this functionality for legacy addresses this function enhances it to\n\t// the address types: P2PKH, P2WKH, NP2WKH, P2TR.\n\t//\n\t// The verification for P2TR addresses is a special case and requires the\n\t// ECDSA compact signature to compare the reovered public key to the internal\n\t// taproot key. The compact ECDSA signature format was used because there\n\t// are still no known compact signature schemes for schnorr signatures.\n\tVerifyMessageWithAddr(context.Context, *VerifyMessageWithAddrRequest) (*VerifyMessageWithAddrResponse, error)\n\t// ImportAccount imports an account backed by an account extended public key.\n\t// The master key fingerprint denotes the fingerprint of the root key\n\t// corresponding to the account public key (also known as the key with\n\t// derivation path m/). This may be required by some hardware wallets for\n\t// proper identification and signing.\n\t//\n\t// The address type can usually be inferred from the key's version, but may be\n\t// required for certain keys to map them into the proper scope.\n\t//\n\t// For BIP-0044 keys, an address type must be specified as we intend to not\n\t// support importing BIP-0044 keys into the wallet using the legacy\n\t// pay-to-pubkey-hash (P2PKH) scheme. A nested witness address type will force\n\t// the standard BIP-0049 derivation scheme, while a witness address type will\n\t// force the standard BIP-0084 derivation scheme.\n\t//\n\t// For BIP-0049 keys, an address type must also be specified to make a\n\t// distinction between the standard BIP-0049 address schema (nested witness\n\t// pubkeys everywhere) and our own BIP-0049Plus address schema (nested pubkeys\n\t// externally, witness pubkeys internally).\n\t//\n\t// NOTE: Events (deposits/spends) for keys derived from an account will only be\n\t// detected by lnd if they happen after the import. Rescans to detect past\n\t// events will be supported later on.\n\tImportAccount(context.Context, *ImportAccountRequest) (*ImportAccountResponse, error)\n\t// ImportPublicKey imports a public key as watch-only into the wallet. The\n\t// public key is converted into a simple address of the given type and that\n\t// address script is watched on chain. For Taproot keys, this will only watch\n\t// the BIP-0086 style output script. Use ImportTapscript for more advanced key\n\t// spend or script spend outputs.\n\t//\n\t// NOTE: Events (deposits/spends) for a key will only be detected by lnd if\n\t// they happen after the import. Rescans to detect past events will be\n\t// supported later on.\n\tImportPublicKey(context.Context, *ImportPublicKeyRequest) (*ImportPublicKeyResponse, error)\n\t// ImportTapscript imports a Taproot script and internal key and adds the\n\t// resulting Taproot output key as a watch-only output script into the wallet.\n\t// For BIP-0086 style Taproot keys (no root hash commitment and no script spend\n\t// path) use ImportPublicKey.\n\t//\n\t// NOTE: Events (deposits/spends) for a key will only be detected by lnd if\n\t// they happen after the import. Rescans to detect past events will be\n\t// supported later on.\n\t//\n\t// NOTE: Taproot keys imported through this RPC currently _cannot_ be used for\n\t// funding PSBTs. Only tracking the balance and UTXOs is currently supported.\n\tImportTapscript(context.Context, *ImportTapscriptRequest) (*ImportTapscriptResponse, error)\n\t// PublishTransaction attempts to publish the passed transaction to the\n\t// network. Once this returns without an error, the wallet will continually\n\t// attempt to re-broadcast the transaction on start up, until it enters the\n\t// chain.\n\tPublishTransaction(context.Context, *Transaction) (*PublishResponse, error)\n\t// SendOutputs is similar to the existing sendmany call in Bitcoind, and\n\t// allows the caller to create a transaction that sends to several outputs at\n\t// once. This is ideal when wanting to batch create a set of transactions.\n\tSendOutputs(context.Context, *SendOutputsRequest) (*SendOutputsResponse, error)\n\t// EstimateFee attempts to query the internal fee estimator of the wallet to\n\t// determine the fee (in sat/kw) to attach to a transaction in order to\n\t// achieve the confirmation target.\n\tEstimateFee(context.Context, *EstimateFeeRequest) (*EstimateFeeResponse, error)\n\t// PendingSweeps returns lists of on-chain outputs that lnd is currently\n\t// attempting to sweep within its central batching engine. Outputs with similar\n\t// fee rates are batched together in order to sweep them within a single\n\t// transaction.\n\t//\n\t// NOTE: Some of the fields within PendingSweepsRequest are not guaranteed to\n\t// remain supported. This is an advanced API that depends on the internals of\n\t// the UtxoSweeper, so things may change.\n\tPendingSweeps(context.Context, *PendingSweepsRequest) (*PendingSweepsResponse, error)\n\t// BumpFee bumps the fee of an arbitrary input within a transaction. This RPC\n\t// takes a different approach than bitcoind's bumpfee command. lnd has a\n\t// central batching engine in which inputs with similar fee rates are batched\n\t// together to save on transaction fees. Due to this, we cannot rely on\n\t// bumping the fee on a specific transaction, since transactions can change at\n\t// any point with the addition of new inputs. The list of inputs that\n\t// currently exist within lnd's central batching engine can be retrieved\n\t// through the PendingSweeps RPC.\n\t//\n\t// When bumping the fee of an input that currently exists within lnd's central\n\t// batching engine, a higher fee transaction will be created that replaces the\n\t// lower fee transaction through the Replace-By-Fee (RBF) policy. If it\n\t//\n\t// This RPC also serves useful when wanting to perform a Child-Pays-For-Parent\n\t// (CPFP), where the child transaction pays for its parent's fee. This can be\n\t// done by specifying an outpoint within the low fee transaction that is under\n\t// the control of the wallet.\n\t//\n\t// The fee preference can be expressed either as a specific fee rate or a delta\n\t// of blocks in which the output should be swept on-chain within. If a fee\n\t// preference is not explicitly specified, then an error is returned.\n\t//\n\t// Note that this RPC currently doesn't perform any validation checks on the\n\t// fee preference being provided. For now, the responsibility of ensuring that\n\t// the new fee preference is sufficient is delegated to the user.\n\tBumpFee(context.Context, *BumpFeeRequest) (*BumpFeeResponse, error)\n\t// ListSweeps returns a list of the sweep transactions our node has produced.\n\t// Note that these sweeps may not be confirmed yet, as we record sweeps on\n\t// broadcast, not confirmation.\n\tListSweeps(context.Context, *ListSweepsRequest) (*ListSweepsResponse, error)\n\t// LabelTransaction adds a label to a transaction. If the transaction already\n\t// has a label the call will fail unless the overwrite bool is set. This will\n\t// overwrite the exiting transaction label. Labels must not be empty, and\n\t// cannot exceed 500 characters.\n\tLabelTransaction(context.Context, *LabelTransactionRequest) (*LabelTransactionResponse, error)\n\t// FundPsbt creates a fully populated PSBT that contains enough inputs to fund\n\t// the outputs specified in the template. There are two ways of specifying a\n\t// template: Either by passing in a PSBT with at least one output declared or\n\t// by passing in a raw TxTemplate message.\n\t//\n\t// If there are no inputs specified in the template, coin selection is\n\t// performed automatically. If the template does contain any inputs, it is\n\t// assumed that full coin selection happened externally and no additional\n\t// inputs are added. If the specified inputs aren't enough to fund the outputs\n\t// with the given fee rate, an error is returned.\n\t//\n\t// After either selecting or verifying the inputs, all input UTXOs are locked\n\t// with an internal app ID.\n\t//\n\t// NOTE: If this method returns without an error, it is the caller's\n\t// responsibility to either spend the locked UTXOs (by finalizing and then\n\t// publishing the transaction) or to unlock/release the locked UTXOs in case of\n\t// an error on the caller's side.\n\tFundPsbt(context.Context, *FundPsbtRequest) (*FundPsbtResponse, error)\n\t// SignPsbt expects a partial transaction with all inputs and outputs fully\n\t// declared and tries to sign all unsigned inputs that have all required fields\n\t// (UTXO information, BIP32 derivation information, witness or sig scripts)\n\t// set.\n\t// If no error is returned, the PSBT is ready to be given to the next signer or\n\t// to be finalized if lnd was the last signer.\n\t//\n\t// NOTE: This RPC only signs inputs (and only those it can sign), it does not\n\t// perform any other tasks (such as coin selection, UTXO locking or\n\t// input/output/fee value validation, PSBT finalization). Any input that is\n\t// incomplete will be skipped.\n\tSignPsbt(context.Context, *SignPsbtRequest) (*SignPsbtResponse, error)\n\t// FinalizePsbt expects a partial transaction with all inputs and outputs fully\n\t// declared and tries to sign all inputs that belong to the wallet. Lnd must be\n\t// the last signer of the transaction. That means, if there are any unsigned\n\t// non-witness inputs or inputs without UTXO information attached or inputs\n\t// without witness data that do not belong to lnd's wallet, this method will\n\t// fail. If no error is returned, the PSBT is ready to be extracted and the\n\t// final TX within to be broadcast.\n\t//\n\t// NOTE: This method does NOT publish the transaction once finalized. It is the\n\t// caller's responsibility to either publish the transaction on success or\n\t// unlock/release any locked UTXOs in case of an error in this method.\n\tFinalizePsbt(context.Context, *FinalizePsbtRequest) (*FinalizePsbtResponse, error)\n\tmustEmbedUnimplementedWalletKitServer()\n}\n\n// UnimplementedWalletKitServer must be embedded to have forward compatible implementations.",
      "length": 13750,
      "tokens": 2069,
      "embedding": []
    },
    {
      "slug": "type UnimplementedWalletKitServer struct {",
      "content": "type UnimplementedWalletKitServer struct {\n}\n",
      "length": 1,
      "tokens": 1,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedWalletKitServer) ListUnspent(context.Context, *ListUnspentRequest) (*ListUnspentResponse, error) {",
      "content": "func (UnimplementedWalletKitServer) ListUnspent(context.Context, *ListUnspentRequest) (*ListUnspentResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method ListUnspent not implemented\")\n}",
      "length": 86,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedWalletKitServer) LeaseOutput(context.Context, *LeaseOutputRequest) (*LeaseOutputResponse, error) {",
      "content": "func (UnimplementedWalletKitServer) LeaseOutput(context.Context, *LeaseOutputRequest) (*LeaseOutputResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method LeaseOutput not implemented\")\n}",
      "length": 86,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedWalletKitServer) ReleaseOutput(context.Context, *ReleaseOutputRequest) (*ReleaseOutputResponse, error) {",
      "content": "func (UnimplementedWalletKitServer) ReleaseOutput(context.Context, *ReleaseOutputRequest) (*ReleaseOutputResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method ReleaseOutput not implemented\")\n}",
      "length": 88,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedWalletKitServer) ListLeases(context.Context, *ListLeasesRequest) (*ListLeasesResponse, error) {",
      "content": "func (UnimplementedWalletKitServer) ListLeases(context.Context, *ListLeasesRequest) (*ListLeasesResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method ListLeases not implemented\")\n}",
      "length": 85,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedWalletKitServer) DeriveNextKey(context.Context, *KeyReq) (*signrpc.KeyDescriptor, error) {",
      "content": "func (UnimplementedWalletKitServer) DeriveNextKey(context.Context, *KeyReq) (*signrpc.KeyDescriptor, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method DeriveNextKey not implemented\")\n}",
      "length": 88,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedWalletKitServer) DeriveKey(context.Context, *signrpc.KeyLocator) (*signrpc.KeyDescriptor, error) {",
      "content": "func (UnimplementedWalletKitServer) DeriveKey(context.Context, *signrpc.KeyLocator) (*signrpc.KeyDescriptor, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method DeriveKey not implemented\")\n}",
      "length": 84,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedWalletKitServer) NextAddr(context.Context, *AddrRequest) (*AddrResponse, error) {",
      "content": "func (UnimplementedWalletKitServer) NextAddr(context.Context, *AddrRequest) (*AddrResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method NextAddr not implemented\")\n}",
      "length": 83,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedWalletKitServer) ListAccounts(context.Context, *ListAccountsRequest) (*ListAccountsResponse, error) {",
      "content": "func (UnimplementedWalletKitServer) ListAccounts(context.Context, *ListAccountsRequest) (*ListAccountsResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method ListAccounts not implemented\")\n}",
      "length": 87,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedWalletKitServer) RequiredReserve(context.Context, *RequiredReserveRequest) (*RequiredReserveResponse, error) {",
      "content": "func (UnimplementedWalletKitServer) RequiredReserve(context.Context, *RequiredReserveRequest) (*RequiredReserveResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method RequiredReserve not implemented\")\n}",
      "length": 90,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedWalletKitServer) ListAddresses(context.Context, *ListAddressesRequest) (*ListAddressesResponse, error) {",
      "content": "func (UnimplementedWalletKitServer) ListAddresses(context.Context, *ListAddressesRequest) (*ListAddressesResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method ListAddresses not implemented\")\n}",
      "length": 88,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedWalletKitServer) SignMessageWithAddr(context.Context, *SignMessageWithAddrRequest) (*SignMessageWithAddrResponse, error) {",
      "content": "func (UnimplementedWalletKitServer) SignMessageWithAddr(context.Context, *SignMessageWithAddrRequest) (*SignMessageWithAddrResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method SignMessageWithAddr not implemented\")\n}",
      "length": 94,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedWalletKitServer) VerifyMessageWithAddr(context.Context, *VerifyMessageWithAddrRequest) (*VerifyMessageWithAddrResponse, error) {",
      "content": "func (UnimplementedWalletKitServer) VerifyMessageWithAddr(context.Context, *VerifyMessageWithAddrRequest) (*VerifyMessageWithAddrResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method VerifyMessageWithAddr not implemented\")\n}",
      "length": 96,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedWalletKitServer) ImportAccount(context.Context, *ImportAccountRequest) (*ImportAccountResponse, error) {",
      "content": "func (UnimplementedWalletKitServer) ImportAccount(context.Context, *ImportAccountRequest) (*ImportAccountResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method ImportAccount not implemented\")\n}",
      "length": 88,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedWalletKitServer) ImportPublicKey(context.Context, *ImportPublicKeyRequest) (*ImportPublicKeyResponse, error) {",
      "content": "func (UnimplementedWalletKitServer) ImportPublicKey(context.Context, *ImportPublicKeyRequest) (*ImportPublicKeyResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method ImportPublicKey not implemented\")\n}",
      "length": 90,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedWalletKitServer) ImportTapscript(context.Context, *ImportTapscriptRequest) (*ImportTapscriptResponse, error) {",
      "content": "func (UnimplementedWalletKitServer) ImportTapscript(context.Context, *ImportTapscriptRequest) (*ImportTapscriptResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method ImportTapscript not implemented\")\n}",
      "length": 90,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedWalletKitServer) PublishTransaction(context.Context, *Transaction) (*PublishResponse, error) {",
      "content": "func (UnimplementedWalletKitServer) PublishTransaction(context.Context, *Transaction) (*PublishResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method PublishTransaction not implemented\")\n}",
      "length": 93,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedWalletKitServer) SendOutputs(context.Context, *SendOutputsRequest) (*SendOutputsResponse, error) {",
      "content": "func (UnimplementedWalletKitServer) SendOutputs(context.Context, *SendOutputsRequest) (*SendOutputsResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method SendOutputs not implemented\")\n}",
      "length": 86,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedWalletKitServer) EstimateFee(context.Context, *EstimateFeeRequest) (*EstimateFeeResponse, error) {",
      "content": "func (UnimplementedWalletKitServer) EstimateFee(context.Context, *EstimateFeeRequest) (*EstimateFeeResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method EstimateFee not implemented\")\n}",
      "length": 86,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedWalletKitServer) PendingSweeps(context.Context, *PendingSweepsRequest) (*PendingSweepsResponse, error) {",
      "content": "func (UnimplementedWalletKitServer) PendingSweeps(context.Context, *PendingSweepsRequest) (*PendingSweepsResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method PendingSweeps not implemented\")\n}",
      "length": 88,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedWalletKitServer) BumpFee(context.Context, *BumpFeeRequest) (*BumpFeeResponse, error) {",
      "content": "func (UnimplementedWalletKitServer) BumpFee(context.Context, *BumpFeeRequest) (*BumpFeeResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method BumpFee not implemented\")\n}",
      "length": 82,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedWalletKitServer) ListSweeps(context.Context, *ListSweepsRequest) (*ListSweepsResponse, error) {",
      "content": "func (UnimplementedWalletKitServer) ListSweeps(context.Context, *ListSweepsRequest) (*ListSweepsResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method ListSweeps not implemented\")\n}",
      "length": 85,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedWalletKitServer) LabelTransaction(context.Context, *LabelTransactionRequest) (*LabelTransactionResponse, error) {",
      "content": "func (UnimplementedWalletKitServer) LabelTransaction(context.Context, *LabelTransactionRequest) (*LabelTransactionResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method LabelTransaction not implemented\")\n}",
      "length": 91,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedWalletKitServer) FundPsbt(context.Context, *FundPsbtRequest) (*FundPsbtResponse, error) {",
      "content": "func (UnimplementedWalletKitServer) FundPsbt(context.Context, *FundPsbtRequest) (*FundPsbtResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method FundPsbt not implemented\")\n}",
      "length": 83,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedWalletKitServer) SignPsbt(context.Context, *SignPsbtRequest) (*SignPsbtResponse, error) {",
      "content": "func (UnimplementedWalletKitServer) SignPsbt(context.Context, *SignPsbtRequest) (*SignPsbtResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method SignPsbt not implemented\")\n}",
      "length": 83,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedWalletKitServer) FinalizePsbt(context.Context, *FinalizePsbtRequest) (*FinalizePsbtResponse, error) {",
      "content": "func (UnimplementedWalletKitServer) FinalizePsbt(context.Context, *FinalizePsbtRequest) (*FinalizePsbtResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method FinalizePsbt not implemented\")\n}",
      "length": 87,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedWalletKitServer) mustEmbedUnimplementedWalletKitServer() {}",
      "content": "func (UnimplementedWalletKitServer) mustEmbedUnimplementedWalletKitServer() {}\n\n// UnsafeWalletKitServer may be embedded to opt out of forward compatibility for this service.\n// Use of this interface is not recommended, as added methods to WalletKitServer will\n// result in compilation errors.",
      "length": 211,
      "tokens": 33,
      "embedding": []
    },
    {
      "slug": "type UnsafeWalletKitServer interface {",
      "content": "type UnsafeWalletKitServer interface {\n\tmustEmbedUnimplementedWalletKitServer()\n}\n",
      "length": 41,
      "tokens": 2,
      "embedding": []
    },
    {
      "slug": "func RegisterWalletKitServer(s grpc.ServiceRegistrar, srv WalletKitServer) {",
      "content": "func RegisterWalletKitServer(s grpc.ServiceRegistrar, srv WalletKitServer) {\n\ts.RegisterService(&WalletKit_ServiceDesc, srv)\n}\n",
      "length": 48,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func _WalletKit_ListUnspent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _WalletKit_ListUnspent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(ListUnspentRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(WalletKitServer).ListUnspent(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/walletrpc.WalletKit/ListUnspent\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(WalletKitServer).ListUnspent(ctx, req.(*ListUnspentRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 455,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _WalletKit_LeaseOutput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _WalletKit_LeaseOutput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(LeaseOutputRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(WalletKitServer).LeaseOutput(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/walletrpc.WalletKit/LeaseOutput\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(WalletKitServer).LeaseOutput(ctx, req.(*LeaseOutputRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 455,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _WalletKit_ReleaseOutput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _WalletKit_ReleaseOutput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(ReleaseOutputRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(WalletKitServer).ReleaseOutput(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/walletrpc.WalletKit/ReleaseOutput\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(WalletKitServer).ReleaseOutput(ctx, req.(*ReleaseOutputRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 465,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _WalletKit_ListLeases_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _WalletKit_ListLeases_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(ListLeasesRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(WalletKitServer).ListLeases(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/walletrpc.WalletKit/ListLeases\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(WalletKitServer).ListLeases(ctx, req.(*ListLeasesRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 450,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _WalletKit_DeriveNextKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _WalletKit_DeriveNextKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(KeyReq)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(WalletKitServer).DeriveNextKey(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/walletrpc.WalletKit/DeriveNextKey\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(WalletKitServer).DeriveNextKey(ctx, req.(*KeyReq))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 437,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _WalletKit_DeriveKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _WalletKit_DeriveKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(signrpc.KeyLocator)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(WalletKitServer).DeriveKey(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/walletrpc.WalletKit/DeriveKey\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(WalletKitServer).DeriveKey(ctx, req.(*signrpc.KeyLocator))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 449,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _WalletKit_NextAddr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _WalletKit_NextAddr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(AddrRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(WalletKitServer).NextAddr(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/walletrpc.WalletKit/NextAddr\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(WalletKitServer).NextAddr(ctx, req.(*AddrRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 432,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _WalletKit_ListAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _WalletKit_ListAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(ListAccountsRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(WalletKitServer).ListAccounts(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/walletrpc.WalletKit/ListAccounts\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(WalletKitServer).ListAccounts(ctx, req.(*ListAccountsRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 460,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _WalletKit_RequiredReserve_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _WalletKit_RequiredReserve_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(RequiredReserveRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(WalletKitServer).RequiredReserve(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/walletrpc.WalletKit/RequiredReserve\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(WalletKitServer).RequiredReserve(ctx, req.(*RequiredReserveRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 475,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _WalletKit_ListAddresses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _WalletKit_ListAddresses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(ListAddressesRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(WalletKitServer).ListAddresses(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/walletrpc.WalletKit/ListAddresses\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(WalletKitServer).ListAddresses(ctx, req.(*ListAddressesRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 465,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _WalletKit_SignMessageWithAddr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _WalletKit_SignMessageWithAddr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(SignMessageWithAddrRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(WalletKitServer).SignMessageWithAddr(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/walletrpc.WalletKit/SignMessageWithAddr\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(WalletKitServer).SignMessageWithAddr(ctx, req.(*SignMessageWithAddrRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 495,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _WalletKit_VerifyMessageWithAddr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _WalletKit_VerifyMessageWithAddr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(VerifyMessageWithAddrRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(WalletKitServer).VerifyMessageWithAddr(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/walletrpc.WalletKit/VerifyMessageWithAddr\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(WalletKitServer).VerifyMessageWithAddr(ctx, req.(*VerifyMessageWithAddrRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 505,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _WalletKit_ImportAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _WalletKit_ImportAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(ImportAccountRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(WalletKitServer).ImportAccount(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/walletrpc.WalletKit/ImportAccount\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(WalletKitServer).ImportAccount(ctx, req.(*ImportAccountRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 465,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _WalletKit_ImportPublicKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _WalletKit_ImportPublicKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(ImportPublicKeyRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(WalletKitServer).ImportPublicKey(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/walletrpc.WalletKit/ImportPublicKey\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(WalletKitServer).ImportPublicKey(ctx, req.(*ImportPublicKeyRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 475,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _WalletKit_ImportTapscript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _WalletKit_ImportTapscript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(ImportTapscriptRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(WalletKitServer).ImportTapscript(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/walletrpc.WalletKit/ImportTapscript\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(WalletKitServer).ImportTapscript(ctx, req.(*ImportTapscriptRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 475,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _WalletKit_PublishTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _WalletKit_PublishTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(Transaction)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(WalletKitServer).PublishTransaction(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/walletrpc.WalletKit/PublishTransaction\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(WalletKitServer).PublishTransaction(ctx, req.(*Transaction))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 462,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _WalletKit_SendOutputs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _WalletKit_SendOutputs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(SendOutputsRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(WalletKitServer).SendOutputs(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/walletrpc.WalletKit/SendOutputs\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(WalletKitServer).SendOutputs(ctx, req.(*SendOutputsRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 455,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _WalletKit_EstimateFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _WalletKit_EstimateFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(EstimateFeeRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(WalletKitServer).EstimateFee(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/walletrpc.WalletKit/EstimateFee\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(WalletKitServer).EstimateFee(ctx, req.(*EstimateFeeRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 455,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _WalletKit_PendingSweeps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _WalletKit_PendingSweeps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(PendingSweepsRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(WalletKitServer).PendingSweeps(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/walletrpc.WalletKit/PendingSweeps\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(WalletKitServer).PendingSweeps(ctx, req.(*PendingSweepsRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 465,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _WalletKit_BumpFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _WalletKit_BumpFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(BumpFeeRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(WalletKitServer).BumpFee(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/walletrpc.WalletKit/BumpFee\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(WalletKitServer).BumpFee(ctx, req.(*BumpFeeRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 435,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _WalletKit_ListSweeps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _WalletKit_ListSweeps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(ListSweepsRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(WalletKitServer).ListSweeps(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/walletrpc.WalletKit/ListSweeps\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(WalletKitServer).ListSweeps(ctx, req.(*ListSweepsRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 450,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _WalletKit_LabelTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _WalletKit_LabelTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(LabelTransactionRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(WalletKitServer).LabelTransaction(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/walletrpc.WalletKit/LabelTransaction\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(WalletKitServer).LabelTransaction(ctx, req.(*LabelTransactionRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 480,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _WalletKit_FundPsbt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _WalletKit_FundPsbt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(FundPsbtRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(WalletKitServer).FundPsbt(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/walletrpc.WalletKit/FundPsbt\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(WalletKitServer).FundPsbt(ctx, req.(*FundPsbtRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 440,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _WalletKit_SignPsbt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _WalletKit_SignPsbt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(SignPsbtRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(WalletKitServer).SignPsbt(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/walletrpc.WalletKit/SignPsbt\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(WalletKitServer).SignPsbt(ctx, req.(*SignPsbtRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 440,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _WalletKit_FinalizePsbt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _WalletKit_FinalizePsbt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(FinalizePsbtRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(WalletKitServer).FinalizePsbt(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/walletrpc.WalletKit/FinalizePsbt\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(WalletKitServer).FinalizePsbt(ctx, req.(*FinalizePsbtRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n\n// WalletKit_ServiceDesc is the grpc.ServiceDesc for WalletKit service.\n// It's only intended for direct use with grpc.RegisterService,\n// and not to be introspected or modified (even as a copy)\nvar WalletKit_ServiceDesc = grpc.ServiceDesc{\n\tServiceName: \"walletrpc.WalletKit\",\n\tHandlerType: (*WalletKitServer)(nil),\n\tMethods: []grpc.MethodDesc{\n\t\t{\n\t\t\tMethodName: \"ListUnspent\",\n\t\t\tHandler:    _WalletKit_ListUnspent_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"LeaseOutput\",\n\t\t\tHandler:    _WalletKit_LeaseOutput_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"ReleaseOutput\",\n\t\t\tHandler:    _WalletKit_ReleaseOutput_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"ListLeases\",\n\t\t\tHandler:    _WalletKit_ListLeases_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"DeriveNextKey\",\n\t\t\tHandler:    _WalletKit_DeriveNextKey_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"DeriveKey\",\n\t\t\tHandler:    _WalletKit_DeriveKey_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"NextAddr\",\n\t\t\tHandler:    _WalletKit_NextAddr_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"ListAccounts\",\n\t\t\tHandler:    _WalletKit_ListAccounts_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"RequiredReserve\",\n\t\t\tHandler:    _WalletKit_RequiredReserve_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"ListAddresses\",\n\t\t\tHandler:    _WalletKit_ListAddresses_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"SignMessageWithAddr\",\n\t\t\tHandler:    _WalletKit_SignMessageWithAddr_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"VerifyMessageWithAddr\",\n\t\t\tHandler:    _WalletKit_VerifyMessageWithAddr_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"ImportAccount\",\n\t\t\tHandler:    _WalletKit_ImportAccount_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"ImportPublicKey\",\n\t\t\tHandler:    _WalletKit_ImportPublicKey_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"ImportTapscript\",\n\t\t\tHandler:    _WalletKit_ImportTapscript_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"PublishTransaction\",\n\t\t\tHandler:    _WalletKit_PublishTransaction_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"SendOutputs\",\n\t\t\tHandler:    _WalletKit_SendOutputs_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"EstimateFee\",\n\t\t\tHandler:    _WalletKit_EstimateFee_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"PendingSweeps\",\n\t\t\tHandler:    _WalletKit_PendingSweeps_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"BumpFee\",\n\t\t\tHandler:    _WalletKit_BumpFee_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"ListSweeps\",\n\t\t\tHandler:    _WalletKit_ListSweeps_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"LabelTransaction\",\n\t\t\tHandler:    _WalletKit_LabelTransaction_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"FundPsbt\",\n\t\t\tHandler:    _WalletKit_FundPsbt_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"SignPsbt\",\n\t\t\tHandler:    _WalletKit_SignPsbt_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"FinalizePsbt\",\n\t\t\tHandler:    _WalletKit_FinalizePsbt_Handler,\n\t\t},\n\t},\n\tStreams:  []grpc.StreamDesc{},\n\tMetadata: \"walletrpc/walletkit.proto\",\n}\n",
      "length": 2997,
      "tokens": 246,
      "embedding": []
    }
  ]
}