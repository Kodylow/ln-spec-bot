{
  "filepath": "../implementations/go/lnd/lnrpc/walletrpc/psbt.go",
  "package": "walletrpc",
  "sections": [
    {
      "slug": "//go:build walletrpc",
      "content": "//go:build walletrpc\n// +build walletrpc\n\npackage walletrpc\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"time\"\n\n\t\"github.com/btcsuite/btcd/btcutil/psbt\"\n\t\"github.com/btcsuite/btcd/wire\"\n\tbase \"github.com/btcsuite/btcwallet/wallet\"\n\t\"github.com/btcsuite/btcwallet/wtxmgr\"\n\t\"github.com/lightningnetwork/lnd/lnwallet\"\n)\n\nconst (\n\tdefaultMaxConf = math.MaxInt32\n)\n\nvar (\n\t// DefaultLockDuration is the default duration used to lock outputs.\n\tDefaultLockDuration = 10 * time.Minute\n)\n\n// verifyInputsUnspent checks that all inputs are contained in the list of\n// known, non-locked UTXOs given.",
      "length": 523,
      "tokens": 58,
      "embedding": []
    },
    {
      "slug": "func verifyInputsUnspent(inputs []*wire.TxIn, utxos []*lnwallet.Utxo) error {",
      "content": "func verifyInputsUnspent(inputs []*wire.TxIn, utxos []*lnwallet.Utxo) error {\n\t// TODO(guggero): Pass in UTXOs as a map to make lookup more efficient.\n\tfor idx, txIn := range inputs {\n\t\tfound := false\n\t\tfor _, u := range utxos {\n\t\t\tif u.OutPoint == txIn.PreviousOutPoint {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif !found {\n\t\t\treturn fmt.Errorf(\"input %d not found in list of non-\"+\n\t\t\t\t\"locked UTXO\", idx)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// lockInputs requests a lock lease for all inputs specified in a PSBT packet\n// by using the internal, static lock ID of lnd's wallet.",
      "length": 467,
      "tokens": 86,
      "embedding": []
    },
    {
      "slug": "func lockInputs(w lnwallet.WalletController,",
      "content": "func lockInputs(w lnwallet.WalletController,\n\tpacket *psbt.Packet) ([]*base.ListLeasedOutputResult, error) {\n\n\tlocks := make(\n\t\t[]*base.ListLeasedOutputResult, len(packet.UnsignedTx.TxIn),\n\t)\n\tfor idx, rawInput := range packet.UnsignedTx.TxIn {\n\t\tlock := &base.ListLeasedOutputResult{\n\t\t\tLockedOutput: &wtxmgr.LockedOutput{\n\t\t\t\tLockID:   LndInternalLockID,\n\t\t\t\tOutpoint: rawInput.PreviousOutPoint,\n\t\t\t},\n\t\t}\n\n\t\texpiration, pkScript, value, err := w.LeaseOutput(\n\t\t\tlock.LockID, lock.Outpoint, DefaultLockDuration,\n\t\t)\n\t\tif err != nil {\n\t\t\t// If we run into a problem with locking one output, we\n\t\t\t// should try to unlock those that we successfully\n\t\t\t// locked so far. If that fails as well, there's not\n\t\t\t// much we can do.\n\t\t\tfor i := 0; i < idx; i++ {\n\t\t\t\top := locks[i].Outpoint\n\t\t\t\tif err := w.ReleaseOutput(\n\t\t\t\t\tLndInternalLockID, op,\n\t\t\t\t); err != nil {\n\t\t\t\t\tlog.Errorf(\"could not release the \"+\n\t\t\t\t\t\t\"lock on %v: %v\", op, err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn nil, fmt.Errorf(\"could not lease a lock on \"+\n\t\t\t\t\"UTXO: %v\", err)\n\t\t}\n\n\t\tlock.Expiration = expiration\n\t\tlock.PkScript = pkScript\n\t\tlock.Value = int64(value)\n\t\tlocks[idx] = lock\n\t}\n\n\treturn locks, nil\n}\n",
      "length": 1076,
      "tokens": 147,
      "embedding": []
    }
  ]
}