{
  "filepath": "../implementations/go/lnd/lnrpc/devrpc/dev_server.go",
  "package": "devrpc",
  "sections": [
    {
      "slug": "//go:build dev",
      "content": "//go:build dev\n// +build dev\n\npackage devrpc\n\nimport (\n\t\"context\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/btcsuite/btcd/btcutil\"\n\t\"github.com/btcsuite/btcd/chaincfg/chainhash\"\n\t\"github.com/btcsuite/btcd/wire\"\n\t\"github.com/grpc-ecosystem/grpc-gateway/v2/runtime\"\n\t\"github.com/lightningnetwork/lnd/channeldb\"\n\t\"github.com/lightningnetwork/lnd/lncfg\"\n\t\"github.com/lightningnetwork/lnd/lnrpc\"\n\t\"github.com/lightningnetwork/lnd/lnwire\"\n\t\"google.golang.org/grpc\"\n\t\"gopkg.in/macaroon-bakery.v2/bakery\"\n)\n\nconst (\n\t// subServerName is the name of the sub rpc server. We'll use this name\n\t// to register ourselves, and we also require that the main\n\t// SubServerConfigDispatcher instance recognize tt as the name of our\n\t// RPC service.\n\tsubServerName = \"DevRPC\"\n)\n\nvar (\n\t// macPermissions maps RPC calls to the permissions they require.\n\tmacPermissions = map[string][]bakery.Op{\n\t\t\"/devrpc.Dev/ImportGraph\": {{\n\t\t\tEntity: \"offchain\",\n\t\t\tAction: \"write\",\n\t\t}},\n\t}\n)\n\n// ServerShell is a shell struct holding a reference to the actual sub-server.\n// It is used to register the gRPC sub-server with the root server before we\n// have the necessary dependencies to populate the actual sub-server.",
      "length": 1166,
      "tokens": 131,
      "embedding": []
    },
    {
      "slug": "type ServerShell struct {",
      "content": "type ServerShell struct {\n\tDevServer\n}\n\n// Server is a sub-server of the main RPC server: the dev RPC. This sub\n// RPC server allows developers to set and query LND state that is not possible\n// during normal operation.",
      "length": 188,
      "tokens": 36,
      "embedding": []
    },
    {
      "slug": "type Server struct {",
      "content": "type Server struct {\n\tstarted  int32 // To be used atomically.\n\tshutdown int32 // To be used atomically.\n\n\t// Required by the grpc-gateway/v2 library for forward compatibility.\n\t// Must be after the atomically used variables to not break struct\n\t// alignment.\n\tUnimplementedDevServer\n\n\tcfg *Config\n}\n\n// A compile time check to ensure that Server fully implements the\n// DevServer gRPC service.\nvar _ DevServer = (*Server)(nil)\n\n// New returns a new instance of the devrpc Dev sub-server. We also return the\n// set of permissions for the macaroons that we may create within this method.\n// If the macaroons we need aren't found in the filepath, then we'll create them\n// on start up. If we're unable to locate, or create the macaroons we need, then\n// we'll return with an error.",
      "length": 739,
      "tokens": 128,
      "embedding": []
    },
    {
      "slug": "func New(cfg *Config) (*Server, lnrpc.MacaroonPerms, error) {",
      "content": "func New(cfg *Config) (*Server, lnrpc.MacaroonPerms, error) {\n\t// We don't create any new macaroons for this subserver, instead reuse\n\t// existing onchain/offchain permissions.\n\tserver := &Server{\n\t\tcfg: cfg,\n\t}\n\n\treturn server, macPermissions, nil\n}\n\n// Start launches any helper goroutines required for the Server to function.\n//\n// NOTE: This is part of the lnrpc.SubServer interface.",
      "length": 314,
      "tokens": 49,
      "embedding": []
    },
    {
      "slug": "func (s *Server) Start() error {",
      "content": "func (s *Server) Start() error {\n\tif atomic.AddInt32(&s.started, 1) != 1 {\n\t\treturn nil\n\t}\n\n\treturn nil\n}\n\n// Stop signals any active goroutines for a graceful closure.\n//\n// NOTE: This is part of the lnrpc.SubServer interface.",
      "length": 185,
      "tokens": 32,
      "embedding": []
    },
    {
      "slug": "func (s *Server) Stop() error {",
      "content": "func (s *Server) Stop() error {\n\tif atomic.AddInt32(&s.shutdown, 1) != 1 {\n\t\treturn nil\n\t}\n\n\treturn nil\n}\n\n// Name returns a unique string representation of the sub-server. This can be\n// used to identify the sub-server and also de-duplicate them.\n//\n// NOTE: This is part of the lnrpc.SubServer interface.",
      "length": 264,
      "tokens": 45,
      "embedding": []
    },
    {
      "slug": "func (s *Server) Name() string {",
      "content": "func (s *Server) Name() string {\n\treturn subServerName\n}\n\n// RegisterWithRootServer will be called by the root gRPC server to direct a\n// sub RPC server to register itself with the main gRPC root server. Until this\n// is called, each sub-server won't be able to have\n// requests routed towards it.\n//\n// NOTE: This is part of the lnrpc.GrpcHandler interface.",
      "length": 317,
      "tokens": 56,
      "embedding": []
    },
    {
      "slug": "func (r *ServerShell) RegisterWithRootServer(grpcServer *grpc.Server) error {",
      "content": "func (r *ServerShell) RegisterWithRootServer(grpcServer *grpc.Server) error {\n\t// We make sure that we register it with the main gRPC server to ensure\n\t// all our methods are routed properly.\n\tRegisterDevServer(grpcServer, r)\n\n\tlog.Debugf(\"DEV RPC server successfully register with root the \" +\n\t\t\"gRPC server\")\n\n\treturn nil\n}\n\n// RegisterWithRestServer will be called by the root REST mux to direct a sub\n// RPC server to register itself with the main REST mux server. Until this is\n// called, each sub-server won't be able to have requests routed towards it.\n//\n// NOTE: This is part of the lnrpc.GrpcHandler interface.",
      "length": 529,
      "tokens": 91,
      "embedding": []
    },
    {
      "slug": "func (r *ServerShell) RegisterWithRestServer(ctx context.Context,",
      "content": "func (r *ServerShell) RegisterWithRestServer(ctx context.Context,\n\tmux *runtime.ServeMux, dest string, opts []grpc.DialOption) error {\n\n\t// We make sure that we register it with the main REST server to ensure\n\t// all our methods are routed properly.\n\terr := RegisterDevHandlerFromEndpoint(ctx, mux, dest, opts)\n\tif err != nil {\n\t\tlog.Errorf(\"Could not register DEV REST server with the root \"+\n\t\t\t\"REST server: %v\", err)\n\t\treturn err\n\t}\n\n\tlog.Debugf(\"DEV REST server successfully registered with the root \" +\n\t\t\"REST server\")\n\treturn nil\n}\n\n// CreateSubServer populates the subserver's dependencies using the passed\n// SubServerConfigDispatcher. This method should fully initialize the\n// sub-server instance, making it ready for action. It returns the macaroon\n// permissions that the sub-server wishes to pass on to the root server for all\n// methods routed towards it.\n//\n// NOTE: This is part of the lnrpc.GrpcHandler interface.",
      "length": 844,
      "tokens": 132,
      "embedding": []
    },
    {
      "slug": "func (r *ServerShell) CreateSubServer(configRegistry lnrpc.SubServerConfigDispatcher) (",
      "content": "func (r *ServerShell) CreateSubServer(configRegistry lnrpc.SubServerConfigDispatcher) (\n\tlnrpc.SubServer, lnrpc.MacaroonPerms, error) {\n\n\tsubServer, macPermissions, err := createNewSubServer(configRegistry)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tr.DevServer = subServer\n\treturn subServer, macPermissions, nil\n}\n",
      "length": 219,
      "tokens": 27,
      "embedding": []
    },
    {
      "slug": "func parseOutPoint(s string) (*wire.OutPoint, error) {",
      "content": "func parseOutPoint(s string) (*wire.OutPoint, error) {\n\tsplit := strings.Split(s, \":\")\n\tif len(split) != 2 {\n\t\treturn nil, fmt.Errorf(\"expecting outpoint to be in format of: \" +\n\t\t\t\"txid:index\")\n\t}\n\n\tindex, err := strconv.ParseInt(split[1], 10, 32)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to decode output index: %v\", err)\n\t}\n\n\ttxid, err := chainhash.NewHashFromStr(split[0])\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to parse hex string: %v\", err)\n\t}\n\n\treturn &wire.OutPoint{\n\t\tHash:  *txid,\n\t\tIndex: uint32(index),\n\t}, nil\n}\n",
      "length": 469,
      "tokens": 71,
      "embedding": []
    },
    {
      "slug": "func parsePubKey(pubKeyStr string) ([33]byte, error) {",
      "content": "func parsePubKey(pubKeyStr string) ([33]byte, error) {\n\tvar pubKey [33]byte\n\tpubKeyBytes, err := hex.DecodeString(pubKeyStr)\n\tif err != nil || len(pubKeyBytes) != 33 {\n\t\treturn pubKey, fmt.Errorf(\"invalid pubkey: %v\", pubKeyStr)\n\t}\n\n\tcopy(pubKey[:], pubKeyBytes)\n\treturn pubKey, nil\n}\n\n// ImportGraph imports a graph dump (without auth proofs).\n//\n// NOTE: Part of the DevServer interface.",
      "length": 322,
      "tokens": 46,
      "embedding": []
    },
    {
      "slug": "func (s *Server) ImportGraph(ctx context.Context,",
      "content": "func (s *Server) ImportGraph(ctx context.Context,\n\tgraph *lnrpc.ChannelGraph) (*ImportGraphResponse, error) {\n\n\t// Obtain the pointer to the global singleton channel graph.\n\tgraphDB := s.cfg.GraphDB\n\n\tvar err error\n\tfor _, rpcNode := range graph.Nodes {\n\t\tnode := &channeldb.LightningNode{\n\t\t\tHaveNodeAnnouncement: true,\n\t\t\tLastUpdate: time.Unix(\n\t\t\t\tint64(rpcNode.LastUpdate), 0,\n\t\t\t),\n\t\t\tAlias: rpcNode.Alias,\n\t\t}\n\n\t\tnode.PubKeyBytes, err = parsePubKey(rpcNode.PubKey)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tfeatureBits := make([]lnwire.FeatureBit, 0, len(rpcNode.Features))\n\t\tfeatureNames := make(map[lnwire.FeatureBit]string)\n\n\t\tfor featureBit, feature := range rpcNode.Features {\n\t\t\tfeatureBits = append(\n\t\t\t\tfeatureBits, lnwire.FeatureBit(featureBit),\n\t\t\t)\n\n\t\t\tfeatureNames[lnwire.FeatureBit(featureBit)] = feature.Name\n\t\t}\n\n\t\tfeatureVector := lnwire.NewRawFeatureVector(featureBits...)\n\t\tnode.Features = lnwire.NewFeatureVector(\n\t\t\tfeatureVector, featureNames,\n\t\t)\n\n\t\tnode.Color, err = lncfg.ParseHexColor(rpcNode.Color)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif err := graphDB.AddLightningNode(node); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to add node %v: %v\",\n\t\t\t\trpcNode.PubKey, err)\n\t\t}\n\n\t\tlog.Debugf(\"Imported node: %v\", rpcNode.PubKey)\n\t}\n\n\tfor _, rpcEdge := range graph.Edges {\n\t\trpcEdge := rpcEdge\n\n\t\tedge := &channeldb.ChannelEdgeInfo{\n\t\t\tChannelID: rpcEdge.ChannelId,\n\t\t\tChainHash: *s.cfg.ActiveNetParams.GenesisHash,\n\t\t\tCapacity:  btcutil.Amount(rpcEdge.Capacity),\n\t\t}\n\n\t\tedge.NodeKey1Bytes, err = parsePubKey(rpcEdge.Node1Pub)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tedge.NodeKey2Bytes, err = parsePubKey(rpcEdge.Node2Pub)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tchannelPoint, err := parseOutPoint(rpcEdge.ChanPoint)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tedge.ChannelPoint = *channelPoint\n\n\t\tif err := graphDB.AddChannelEdge(edge); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to add edge %v: %v\",\n\t\t\t\trpcEdge.ChanPoint, err)\n\t\t}\n\n\t\tmakePolicy := func(rpcPolicy *lnrpc.RoutingPolicy) *channeldb.ChannelEdgePolicy {\n\t\t\tpolicy := &channeldb.ChannelEdgePolicy{\n\t\t\t\tChannelID: rpcEdge.ChannelId,\n\t\t\t\tLastUpdate: time.Unix(\n\t\t\t\t\tint64(rpcPolicy.LastUpdate), 0,\n\t\t\t\t),\n\t\t\t\tTimeLockDelta: uint16(\n\t\t\t\t\trpcPolicy.TimeLockDelta,\n\t\t\t\t),\n\t\t\t\tMinHTLC: lnwire.MilliSatoshi(\n\t\t\t\t\trpcPolicy.MinHtlc,\n\t\t\t\t),\n\t\t\t\tFeeBaseMSat: lnwire.MilliSatoshi(\n\t\t\t\t\trpcPolicy.FeeBaseMsat,\n\t\t\t\t),\n\t\t\t\tFeeProportionalMillionths: lnwire.MilliSatoshi(\n\t\t\t\t\trpcPolicy.FeeRateMilliMsat,\n\t\t\t\t),\n\t\t\t}\n\t\t\tif rpcPolicy.MaxHtlcMsat > 0 {\n\t\t\t\tpolicy.MaxHTLC = lnwire.MilliSatoshi(\n\t\t\t\t\trpcPolicy.MaxHtlcMsat,\n\t\t\t\t)\n\t\t\t\tpolicy.MessageFlags |=\n\t\t\t\t\tlnwire.ChanUpdateRequiredMaxHtlc\n\t\t\t}\n\n\t\t\treturn policy\n\t\t}\n\n\t\tif rpcEdge.Node1Policy != nil {\n\t\t\tpolicy := makePolicy(rpcEdge.Node1Policy)\n\t\t\tpolicy.ChannelFlags = 0\n\t\t\tif err := graphDB.UpdateEdgePolicy(policy); err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\n\t\t\t\t\t\"unable to update policy: %v\", err)\n\t\t\t}\n\t\t}\n\n\t\tif rpcEdge.Node2Policy != nil {\n\t\t\tpolicy := makePolicy(rpcEdge.Node2Policy)\n\t\t\tpolicy.ChannelFlags = 1\n\t\t\tif err := graphDB.UpdateEdgePolicy(policy); err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\n\t\t\t\t\t\"unable to update policy: %v\", err)\n\t\t\t}\n\t\t}\n\n\t\tlog.Debugf(\"Added edge: %v\", rpcEdge.ChannelId)\n\t}\n\n\treturn &ImportGraphResponse{}, nil\n}\n",
      "length": 3117,
      "tokens": 325,
      "embedding": []
    }
  ]
}