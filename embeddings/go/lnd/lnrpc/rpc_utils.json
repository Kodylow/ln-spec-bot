{
  "filepath": "../implementations/go/lnd/lnrpc/rpc_utils.go",
  "package": "lnrpc",
  "sections": [
    {
      "slug": "func RPCTransaction(tx *lnwallet.TransactionDetail) *Transaction {",
      "content": "func RPCTransaction(tx *lnwallet.TransactionDetail) *Transaction {\n\tvar destAddresses []string\n\t// Re-package destination output information.\n\tvar outputDetails []*OutputDetail\n\tfor _, o := range tx.OutputDetails {\n\t\t// Note: DestAddresses is deprecated but we keep\n\t\t// populating it with addresses for backwards\n\t\t// compatibility.\n\t\tfor _, a := range o.Addresses {\n\t\t\tdestAddresses = append(destAddresses,\n\t\t\t\ta.EncodeAddress())\n\t\t}\n\n\t\tvar address string\n\t\tif len(o.Addresses) == 1 {\n\t\t\taddress = o.Addresses[0].EncodeAddress()\n\t\t}\n\n\t\toutputDetails = append(outputDetails, &OutputDetail{\n\t\t\tOutputType:   MarshallOutputType(o.OutputType),\n\t\t\tAddress:      address,\n\t\t\tPkScript:     hex.EncodeToString(o.PkScript),\n\t\t\tOutputIndex:  int64(o.OutputIndex),\n\t\t\tAmount:       int64(o.Value),\n\t\t\tIsOurAddress: o.IsOurAddress,\n\t\t})\n\t}\n\n\tpreviousOutpoints := make([]*PreviousOutPoint, len(tx.PreviousOutpoints))\n\tfor idx, previousOutPoint := range tx.PreviousOutpoints {\n\t\tpreviousOutpoints[idx] = &PreviousOutPoint{\n\t\t\tOutpoint:    previousOutPoint.OutPoint,\n\t\t\tIsOurOutput: previousOutPoint.IsOurOutput,\n\t\t}\n\t}\n\n\t// We also get unconfirmed transactions, so BlockHash can be nil.\n\tblockHash := \"\"\n\tif tx.BlockHash != nil {\n\t\tblockHash = tx.BlockHash.String()\n\t}\n\n\treturn &Transaction{\n\t\tTxHash:            tx.Hash.String(),\n\t\tAmount:            int64(tx.Value),\n\t\tNumConfirmations:  tx.NumConfirmations,\n\t\tBlockHash:         blockHash,\n\t\tBlockHeight:       tx.BlockHeight,\n\t\tTimeStamp:         tx.Timestamp,\n\t\tTotalFees:         tx.TotalFees,\n\t\tDestAddresses:     destAddresses,\n\t\tOutputDetails:     outputDetails,\n\t\tRawTxHex:          hex.EncodeToString(tx.RawTx),\n\t\tLabel:             tx.Label,\n\t\tPreviousOutpoints: previousOutpoints,\n\t}\n}\n\n// RPCTransactionDetails returns a set of rpc transaction details.",
      "length": 1680,
      "tokens": 157,
      "embedding": []
    },
    {
      "slug": "func RPCTransactionDetails(txns []*lnwallet.TransactionDetail) *TransactionDetails {",
      "content": "func RPCTransactionDetails(txns []*lnwallet.TransactionDetail) *TransactionDetails {\n\ttxDetails := &TransactionDetails{\n\t\tTransactions: make([]*Transaction, len(txns)),\n\t}\n\n\tfor i, tx := range txns {\n\t\ttxDetails.Transactions[i] = RPCTransaction(tx)\n\t}\n\n\t// Sort transactions by number of confirmations rather than height so\n\t// that unconfirmed transactions (height =0; confirmations =-1) will\n\t// follow the most recently set of confirmed transactions. If we sort\n\t// by height, unconfirmed transactions will follow our oldest\n\t// transactions, because they have lower block heights.\n\tsort.Slice(txDetails.Transactions, func(i, j int) bool {\n\t\treturn txDetails.Transactions[i].NumConfirmations <\n\t\t\ttxDetails.Transactions[j].NumConfirmations\n\t})\n\n\treturn txDetails\n}\n\n// ExtractMinConfs extracts the minimum number of confirmations that each\n// output used to fund a transaction should satisfy.",
      "length": 788,
      "tokens": 100,
      "embedding": []
    },
    {
      "slug": "func ExtractMinConfs(minConfs int32, spendUnconfirmed bool) (int32, error) {",
      "content": "func ExtractMinConfs(minConfs int32, spendUnconfirmed bool) (int32, error) {\n\tswitch {\n\t// Ensure that the MinConfs parameter is non-negative.\n\tcase minConfs < 0:\n\t\treturn 0, errors.New(\"minimum number of confirmations must \" +\n\t\t\t\"be a non-negative number\")\n\n\t// The transaction should not be funded with unconfirmed outputs\n\t// unless explicitly specified by SpendUnconfirmed. We do this to\n\t// provide sane defaults to the OpenChannel RPC, as otherwise, if the\n\t// MinConfs field isn't explicitly set by the caller, we'll use\n\t// unconfirmed outputs without the caller being aware.\n\tcase minConfs == 0 && !spendUnconfirmed:\n\t\treturn 1, nil\n\n\t// In the event that the caller set MinConfs > 0 and SpendUnconfirmed to\n\t// true, we'll return an error to indicate the conflict.\n\tcase minConfs > 0 && spendUnconfirmed:\n\t\treturn 0, errors.New(\"SpendUnconfirmed set to true with \" +\n\t\t\t\"MinConfs > 0\")\n\n\t// The funding transaction of the new channel to be created can be\n\t// funded with unconfirmed outputs.\n\tcase spendUnconfirmed:\n\t\treturn 0, nil\n\n\t// If none of the above cases matched, we'll return the value set\n\t// explicitly by the caller.\n\tdefault:\n\t\treturn minConfs, nil\n\t}\n}\n\n// GetChanPointFundingTxid returns the given channel point's funding txid in\n// raw bytes.",
      "length": 1160,
      "tokens": 189,
      "embedding": []
    },
    {
      "slug": "func GetChanPointFundingTxid(chanPoint *ChannelPoint) (*chainhash.Hash, error) {",
      "content": "func GetChanPointFundingTxid(chanPoint *ChannelPoint) (*chainhash.Hash, error) {\n\tvar txid []byte\n\n\t// A channel point's funding txid can be get/set as a byte slice or a\n\t// string. In the case it is a string, decode it.\n\tswitch chanPoint.GetFundingTxid().(type) {\n\tcase *ChannelPoint_FundingTxidBytes:\n\t\ttxid = chanPoint.GetFundingTxidBytes()\n\tcase *ChannelPoint_FundingTxidStr:\n\t\ts := chanPoint.GetFundingTxidStr()\n\t\th, err := chainhash.NewHashFromStr(s)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\ttxid = h[:]\n\t}\n\n\treturn chainhash.NewHash(txid)\n}\n",
      "length": 451,
      "tokens": 62,
      "embedding": []
    }
  ]
}