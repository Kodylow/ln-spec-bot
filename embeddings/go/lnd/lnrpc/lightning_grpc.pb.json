{
  "filepath": "../implementations/go/lnd/lnrpc/lightning_grpc.pb.go",
  "package": "lnrpc",
  "sections": [
    {
      "slug": "type LightningClient interface {",
      "content": "type LightningClient interface {\n\t// lncli: `walletbalance`\n\t// WalletBalance returns total unspent outputs(confirmed and unconfirmed), all\n\t// confirmed unspent outputs and all unconfirmed unspent outputs under control\n\t// of the wallet.\n\tWalletBalance(ctx context.Context, in *WalletBalanceRequest, opts ...grpc.CallOption) (*WalletBalanceResponse, error)\n\t// lncli: `channelbalance`\n\t// ChannelBalance returns a report on the total funds across all open channels,\n\t// categorized in local/remote, pending local/remote and unsettled local/remote\n\t// balances.\n\tChannelBalance(ctx context.Context, in *ChannelBalanceRequest, opts ...grpc.CallOption) (*ChannelBalanceResponse, error)\n\t// lncli: `listchaintxns`\n\t// GetTransactions returns a list describing all the known transactions\n\t// relevant to the wallet.\n\tGetTransactions(ctx context.Context, in *GetTransactionsRequest, opts ...grpc.CallOption) (*TransactionDetails, error)\n\t// lncli: `estimatefee`\n\t// EstimateFee asks the chain backend to estimate the fee rate and total fees\n\t// for a transaction that pays to multiple specified outputs.\n\t//\n\t// When using REST, the `AddrToAmount` map type can be set by appending\n\t// `&AddrToAmount[<address>]=<amount_to_send>` to the URL. Unfortunately this\n\t// map type doesn't appear in the REST API documentation because of a bug in\n\t// the grpc-gateway library.\n\tEstimateFee(ctx context.Context, in *EstimateFeeRequest, opts ...grpc.CallOption) (*EstimateFeeResponse, error)\n\t// lncli: `sendcoins`\n\t// SendCoins executes a request to send coins to a particular address. Unlike\n\t// SendMany, this RPC call only allows creating a single output at a time. If\n\t// neither target_conf, or sat_per_vbyte are set, then the internal wallet will\n\t// consult its fee model to determine a fee for the default confirmation\n\t// target.\n\tSendCoins(ctx context.Context, in *SendCoinsRequest, opts ...grpc.CallOption) (*SendCoinsResponse, error)\n\t// lncli: `listunspent`\n\t// Deprecated, use walletrpc.ListUnspent instead.\n\t//\n\t// ListUnspent returns a list of all utxos spendable by the wallet with a\n\t// number of confirmations between the specified minimum and maximum.\n\tListUnspent(ctx context.Context, in *ListUnspentRequest, opts ...grpc.CallOption) (*ListUnspentResponse, error)\n\t// SubscribeTransactions creates a uni-directional stream from the server to\n\t// the client in which any newly discovered transactions relevant to the\n\t// wallet are sent over.\n\tSubscribeTransactions(ctx context.Context, in *GetTransactionsRequest, opts ...grpc.CallOption) (Lightning_SubscribeTransactionsClient, error)\n\t// lncli: `sendmany`\n\t// SendMany handles a request for a transaction that creates multiple specified\n\t// outputs in parallel. If neither target_conf, or sat_per_vbyte are set, then\n\t// the internal wallet will consult its fee model to determine a fee for the\n\t// default confirmation target.\n\tSendMany(ctx context.Context, in *SendManyRequest, opts ...grpc.CallOption) (*SendManyResponse, error)\n\t// lncli: `newaddress`\n\t// NewAddress creates a new address under control of the local wallet.\n\tNewAddress(ctx context.Context, in *NewAddressRequest, opts ...grpc.CallOption) (*NewAddressResponse, error)\n\t// lncli: `signmessage`\n\t// SignMessage signs a message with this node's private key. The returned\n\t// signature string is `zbase32` encoded and pubkey recoverable, meaning that\n\t// only the message digest and signature are needed for verification.\n\tSignMessage(ctx context.Context, in *SignMessageRequest, opts ...grpc.CallOption) (*SignMessageResponse, error)\n\t// lncli: `verifymessage`\n\t// VerifyMessage verifies a signature over a msg. The signature must be\n\t// zbase32 encoded and signed by an active node in the resident node's\n\t// channel database. In addition to returning the validity of the signature,\n\t// VerifyMessage also returns the recovered pubkey from the signature.\n\tVerifyMessage(ctx context.Context, in *VerifyMessageRequest, opts ...grpc.CallOption) (*VerifyMessageResponse, error)\n\t// lncli: `connect`\n\t// ConnectPeer attempts to establish a connection to a remote peer. This is at\n\t// the networking level, and is used for communication between nodes. This is\n\t// distinct from establishing a channel with a peer.\n\tConnectPeer(ctx context.Context, in *ConnectPeerRequest, opts ...grpc.CallOption) (*ConnectPeerResponse, error)\n\t// lncli: `disconnect`\n\t// DisconnectPeer attempts to disconnect one peer from another identified by a\n\t// given pubKey. In the case that we currently have a pending or active channel\n\t// with the target peer, then this action will be not be allowed.\n\tDisconnectPeer(ctx context.Context, in *DisconnectPeerRequest, opts ...grpc.CallOption) (*DisconnectPeerResponse, error)\n\t// lncli: `listpeers`\n\t// ListPeers returns a verbose listing of all currently active peers.\n\tListPeers(ctx context.Context, in *ListPeersRequest, opts ...grpc.CallOption) (*ListPeersResponse, error)\n\t// SubscribePeerEvents creates a uni-directional stream from the server to\n\t// the client in which any events relevant to the state of peers are sent\n\t// over. Events include peers going online and offline.\n\tSubscribePeerEvents(ctx context.Context, in *PeerEventSubscription, opts ...grpc.CallOption) (Lightning_SubscribePeerEventsClient, error)\n\t// lncli: `getinfo`\n\t// GetInfo returns general information concerning the lightning node including\n\t// it's identity pubkey, alias, the chains it is connected to, and information\n\t// concerning the number of open+pending channels.\n\tGetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*GetInfoResponse, error)\n\t// * lncli: `getrecoveryinfo`\n\t// GetRecoveryInfo returns information concerning the recovery mode including\n\t// whether it's in a recovery mode, whether the recovery is finished, and the\n\t// progress made so far.\n\tGetRecoveryInfo(ctx context.Context, in *GetRecoveryInfoRequest, opts ...grpc.CallOption) (*GetRecoveryInfoResponse, error)\n\t// lncli: `pendingchannels`\n\t// PendingChannels returns a list of all the channels that are currently\n\t// considered \"pending\". A channel is pending if it has finished the funding\n\t// workflow and is waiting for confirmations for the funding txn, or is in the\n\t// process of closure, either initiated cooperatively or non-cooperatively.\n\tPendingChannels(ctx context.Context, in *PendingChannelsRequest, opts ...grpc.CallOption) (*PendingChannelsResponse, error)\n\t// lncli: `listchannels`\n\t// ListChannels returns a description of all the open channels that this node\n\t// is a participant in.\n\tListChannels(ctx context.Context, in *ListChannelsRequest, opts ...grpc.CallOption) (*ListChannelsResponse, error)\n\t// SubscribeChannelEvents creates a uni-directional stream from the server to\n\t// the client in which any updates relevant to the state of the channels are\n\t// sent over. Events include new active channels, inactive channels, and closed\n\t// channels.\n\tSubscribeChannelEvents(ctx context.Context, in *ChannelEventSubscription, opts ...grpc.CallOption) (Lightning_SubscribeChannelEventsClient, error)\n\t// lncli: `closedchannels`\n\t// ClosedChannels returns a description of all the closed channels that\n\t// this node was a participant in.\n\tClosedChannels(ctx context.Context, in *ClosedChannelsRequest, opts ...grpc.CallOption) (*ClosedChannelsResponse, error)\n\t// OpenChannelSync is a synchronous version of the OpenChannel RPC call. This\n\t// call is meant to be consumed by clients to the REST proxy. As with all\n\t// other sync calls, all byte slices are intended to be populated as hex\n\t// encoded strings.\n\tOpenChannelSync(ctx context.Context, in *OpenChannelRequest, opts ...grpc.CallOption) (*ChannelPoint, error)\n\t// lncli: `openchannel`\n\t// OpenChannel attempts to open a singly funded channel specified in the\n\t// request to a remote peer. Users are able to specify a target number of\n\t// blocks that the funding transaction should be confirmed in, or a manual fee\n\t// rate to us for the funding transaction. If neither are specified, then a\n\t// lax block confirmation target is used. Each OpenStatusUpdate will return\n\t// the pending channel ID of the in-progress channel. Depending on the\n\t// arguments specified in the OpenChannelRequest, this pending channel ID can\n\t// then be used to manually progress the channel funding flow.\n\tOpenChannel(ctx context.Context, in *OpenChannelRequest, opts ...grpc.CallOption) (Lightning_OpenChannelClient, error)\n\t// lncli: `batchopenchannel`\n\t// BatchOpenChannel attempts to open multiple single-funded channels in a\n\t// single transaction in an atomic way. This means either all channel open\n\t// requests succeed at once or all attempts are aborted if any of them fail.\n\t// This is the safer variant of using PSBTs to manually fund a batch of\n\t// channels through the OpenChannel RPC.\n\tBatchOpenChannel(ctx context.Context, in *BatchOpenChannelRequest, opts ...grpc.CallOption) (*BatchOpenChannelResponse, error)\n\t// FundingStateStep is an advanced funding related call that allows the caller\n\t// to either execute some preparatory steps for a funding workflow, or\n\t// manually progress a funding workflow. The primary way a funding flow is\n\t// identified is via its pending channel ID. As an example, this method can be\n\t// used to specify that we're expecting a funding flow for a particular\n\t// pending channel ID, for which we need to use specific parameters.\n\t// Alternatively, this can be used to interactively drive PSBT signing for\n\t// funding for partially complete funding transactions.\n\tFundingStateStep(ctx context.Context, in *FundingTransitionMsg, opts ...grpc.CallOption) (*FundingStateStepResp, error)\n\t// ChannelAcceptor dispatches a bi-directional streaming RPC in which\n\t// OpenChannel requests are sent to the client and the client responds with\n\t// a boolean that tells LND whether or not to accept the channel. This allows\n\t// node operators to specify their own criteria for accepting inbound channels\n\t// through a single persistent connection.\n\tChannelAcceptor(ctx context.Context, opts ...grpc.CallOption) (Lightning_ChannelAcceptorClient, error)\n\t// lncli: `closechannel`\n\t// CloseChannel attempts to close an active channel identified by its channel\n\t// outpoint (ChannelPoint). The actions of this method can additionally be\n\t// augmented to attempt a force close after a timeout period in the case of an\n\t// inactive peer. If a non-force close (cooperative closure) is requested,\n\t// then the user can specify either a target number of blocks until the\n\t// closure transaction is confirmed, or a manual fee rate. If neither are\n\t// specified, then a default lax, block confirmation target is used.\n\tCloseChannel(ctx context.Context, in *CloseChannelRequest, opts ...grpc.CallOption) (Lightning_CloseChannelClient, error)\n\t// lncli: `abandonchannel`\n\t// AbandonChannel removes all channel state from the database except for a\n\t// close summary. This method can be used to get rid of permanently unusable\n\t// channels due to bugs fixed in newer versions of lnd. This method can also be\n\t// used to remove externally funded channels where the funding transaction was\n\t// never broadcast. Only available for non-externally funded channels in dev\n\t// build.\n\tAbandonChannel(ctx context.Context, in *AbandonChannelRequest, opts ...grpc.CallOption) (*AbandonChannelResponse, error)\n\t// Deprecated: Do not use.\n\t// lncli: `sendpayment`\n\t// Deprecated, use routerrpc.SendPaymentV2. SendPayment dispatches a\n\t// bi-directional streaming RPC for sending payments through the Lightning\n\t// Network. A single RPC invocation creates a persistent bi-directional\n\t// stream allowing clients to rapidly send payments through the Lightning\n\t// Network with a single persistent connection.\n\tSendPayment(ctx context.Context, opts ...grpc.CallOption) (Lightning_SendPaymentClient, error)\n\t// SendPaymentSync is the synchronous non-streaming version of SendPayment.\n\t// This RPC is intended to be consumed by clients of the REST proxy.\n\t// Additionally, this RPC expects the destination's public key and the payment\n\t// hash (if any) to be encoded as hex strings.\n\tSendPaymentSync(ctx context.Context, in *SendRequest, opts ...grpc.CallOption) (*SendResponse, error)\n\t// Deprecated: Do not use.\n\t// lncli: `sendtoroute`\n\t// Deprecated, use routerrpc.SendToRouteV2. SendToRoute is a bi-directional\n\t// streaming RPC for sending payment through the Lightning Network. This\n\t// method differs from SendPayment in that it allows users to specify a full\n\t// route manually. This can be used for things like rebalancing, and atomic\n\t// swaps.\n\tSendToRoute(ctx context.Context, opts ...grpc.CallOption) (Lightning_SendToRouteClient, error)\n\t// SendToRouteSync is a synchronous version of SendToRoute. It Will block\n\t// until the payment either fails or succeeds.\n\tSendToRouteSync(ctx context.Context, in *SendToRouteRequest, opts ...grpc.CallOption) (*SendResponse, error)\n\t// lncli: `addinvoice`\n\t// AddInvoice attempts to add a new invoice to the invoice database. Any\n\t// duplicated invoices are rejected, therefore all invoices *must* have a\n\t// unique payment preimage.\n\tAddInvoice(ctx context.Context, in *Invoice, opts ...grpc.CallOption) (*AddInvoiceResponse, error)\n\t// lncli: `listinvoices`\n\t// ListInvoices returns a list of all the invoices currently stored within the\n\t// database. Any active debug invoices are ignored. It has full support for\n\t// paginated responses, allowing users to query for specific invoices through\n\t// their add_index. This can be done by using either the first_index_offset or\n\t// last_index_offset fields included in the response as the index_offset of the\n\t// next request. By default, the first 100 invoices created will be returned.\n\t// Backwards pagination is also supported through the Reversed flag.\n\tListInvoices(ctx context.Context, in *ListInvoiceRequest, opts ...grpc.CallOption) (*ListInvoiceResponse, error)\n\t// lncli: `lookupinvoice`\n\t// LookupInvoice attempts to look up an invoice according to its payment hash.\n\t// The passed payment hash *must* be exactly 32 bytes, if not, an error is\n\t// returned.\n\tLookupInvoice(ctx context.Context, in *PaymentHash, opts ...grpc.CallOption) (*Invoice, error)\n\t// SubscribeInvoices returns a uni-directional stream (server -> client) for\n\t// notifying the client of newly added/settled invoices. The caller can\n\t// optionally specify the add_index and/or the settle_index. If the add_index\n\t// is specified, then we'll first start by sending add invoice events for all\n\t// invoices with an add_index greater than the specified value. If the\n\t// settle_index is specified, the next, we'll send out all settle events for\n\t// invoices with a settle_index greater than the specified value. One or both\n\t// of these fields can be set. If no fields are set, then we'll only send out\n\t// the latest add/settle events.\n\tSubscribeInvoices(ctx context.Context, in *InvoiceSubscription, opts ...grpc.CallOption) (Lightning_SubscribeInvoicesClient, error)\n\t// lncli: `decodepayreq`\n\t// DecodePayReq takes an encoded payment request string and attempts to decode\n\t// it, returning a full description of the conditions encoded within the\n\t// payment request.\n\tDecodePayReq(ctx context.Context, in *PayReqString, opts ...grpc.CallOption) (*PayReq, error)\n\t// lncli: `listpayments`\n\t// ListPayments returns a list of all outgoing payments.\n\tListPayments(ctx context.Context, in *ListPaymentsRequest, opts ...grpc.CallOption) (*ListPaymentsResponse, error)\n\t// DeletePayment deletes an outgoing payment from DB. Note that it will not\n\t// attempt to delete an In-Flight payment, since that would be unsafe.\n\tDeletePayment(ctx context.Context, in *DeletePaymentRequest, opts ...grpc.CallOption) (*DeletePaymentResponse, error)\n\t// DeleteAllPayments deletes all outgoing payments from DB. Note that it will\n\t// not attempt to delete In-Flight payments, since that would be unsafe.\n\tDeleteAllPayments(ctx context.Context, in *DeleteAllPaymentsRequest, opts ...grpc.CallOption) (*DeleteAllPaymentsResponse, error)\n\t// lncli: `describegraph`\n\t// DescribeGraph returns a description of the latest graph state from the\n\t// point of view of the node. The graph information is partitioned into two\n\t// components: all the nodes/vertexes, and all the edges that connect the\n\t// vertexes themselves. As this is a directed graph, the edges also contain\n\t// the node directional specific routing policy which includes: the time lock\n\t// delta, fee information, etc.\n\tDescribeGraph(ctx context.Context, in *ChannelGraphRequest, opts ...grpc.CallOption) (*ChannelGraph, error)\n\t// lncli: `getnodemetrics`\n\t// GetNodeMetrics returns node metrics calculated from the graph. Currently\n\t// the only supported metric is betweenness centrality of individual nodes.\n\tGetNodeMetrics(ctx context.Context, in *NodeMetricsRequest, opts ...grpc.CallOption) (*NodeMetricsResponse, error)\n\t// lncli: `getchaninfo`\n\t// GetChanInfo returns the latest authenticated network announcement for the\n\t// given channel identified by its channel ID: an 8-byte integer which\n\t// uniquely identifies the location of transaction's funding output within the\n\t// blockchain.\n\tGetChanInfo(ctx context.Context, in *ChanInfoRequest, opts ...grpc.CallOption) (*ChannelEdge, error)\n\t// lncli: `getnodeinfo`\n\t// GetNodeInfo returns the latest advertised, aggregated, and authenticated\n\t// channel information for the specified node identified by its public key.\n\tGetNodeInfo(ctx context.Context, in *NodeInfoRequest, opts ...grpc.CallOption) (*NodeInfo, error)\n\t// lncli: `queryroutes`\n\t// QueryRoutes attempts to query the daemon's Channel Router for a possible\n\t// route to a target destination capable of carrying a specific amount of\n\t// satoshis. The returned route contains the full details required to craft and\n\t// send an HTLC, also including the necessary information that should be\n\t// present within the Sphinx packet encapsulated within the HTLC.\n\t//\n\t// When using REST, the `dest_custom_records` map type can be set by appending\n\t// `&dest_custom_records[<record_number>]=<record_data_base64_url_encoded>`\n\t// to the URL. Unfortunately this map type doesn't appear in the REST API\n\t// documentation because of a bug in the grpc-gateway library.\n\tQueryRoutes(ctx context.Context, in *QueryRoutesRequest, opts ...grpc.CallOption) (*QueryRoutesResponse, error)\n\t// lncli: `getnetworkinfo`\n\t// GetNetworkInfo returns some basic stats about the known channel graph from\n\t// the point of view of the node.\n\tGetNetworkInfo(ctx context.Context, in *NetworkInfoRequest, opts ...grpc.CallOption) (*NetworkInfo, error)\n\t// lncli: `stop`\n\t// StopDaemon will send a shutdown request to the interrupt handler, triggering\n\t// a graceful shutdown of the daemon.\n\tStopDaemon(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopResponse, error)\n\t// SubscribeChannelGraph launches a streaming RPC that allows the caller to\n\t// receive notifications upon any changes to the channel graph topology from\n\t// the point of view of the responding node. Events notified include: new\n\t// nodes coming online, nodes updating their authenticated attributes, new\n\t// channels being advertised, updates in the routing policy for a directional\n\t// channel edge, and when channels are closed on-chain.\n\tSubscribeChannelGraph(ctx context.Context, in *GraphTopologySubscription, opts ...grpc.CallOption) (Lightning_SubscribeChannelGraphClient, error)\n\t// lncli: `debuglevel`\n\t// DebugLevel allows a caller to programmatically set the logging verbosity of\n\t// lnd. The logging can be targeted according to a coarse daemon-wide logging\n\t// level, or in a granular fashion to specify the logging for a target\n\t// sub-system.\n\tDebugLevel(ctx context.Context, in *DebugLevelRequest, opts ...grpc.CallOption) (*DebugLevelResponse, error)\n\t// lncli: `feereport`\n\t// FeeReport allows the caller to obtain a report detailing the current fee\n\t// schedule enforced by the node globally for each channel.\n\tFeeReport(ctx context.Context, in *FeeReportRequest, opts ...grpc.CallOption) (*FeeReportResponse, error)\n\t// lncli: `updatechanpolicy`\n\t// UpdateChannelPolicy allows the caller to update the fee schedule and\n\t// channel policies for all channels globally, or a particular channel.\n\tUpdateChannelPolicy(ctx context.Context, in *PolicyUpdateRequest, opts ...grpc.CallOption) (*PolicyUpdateResponse, error)\n\t// lncli: `fwdinghistory`\n\t// ForwardingHistory allows the caller to query the htlcswitch for a record of\n\t// all HTLCs forwarded within the target time range, and integer offset\n\t// within that time range, for a maximum number of events. If no maximum number\n\t// of events is specified, up to 100 events will be returned. If no time-range\n\t// is specified, then events will be returned in the order that they occured.\n\t//\n\t// A list of forwarding events are returned. The size of each forwarding event\n\t// is 40 bytes, and the max message size able to be returned in gRPC is 4 MiB.\n\t// As a result each message can only contain 50k entries. Each response has\n\t// the index offset of the last entry. The index offset can be provided to the\n\t// request to allow the caller to skip a series of records.\n\tForwardingHistory(ctx context.Context, in *ForwardingHistoryRequest, opts ...grpc.CallOption) (*ForwardingHistoryResponse, error)\n\t// lncli: `exportchanbackup`\n\t// ExportChannelBackup attempts to return an encrypted static channel backup\n\t// for the target channel identified by it channel point. The backup is\n\t// encrypted with a key generated from the aezeed seed of the user. The\n\t// returned backup can either be restored using the RestoreChannelBackup\n\t// method once lnd is running, or via the InitWallet and UnlockWallet methods\n\t// from the WalletUnlocker service.\n\tExportChannelBackup(ctx context.Context, in *ExportChannelBackupRequest, opts ...grpc.CallOption) (*ChannelBackup, error)\n\t// ExportAllChannelBackups returns static channel backups for all existing\n\t// channels known to lnd. A set of regular singular static channel backups for\n\t// each channel are returned. Additionally, a multi-channel backup is returned\n\t// as well, which contains a single encrypted blob containing the backups of\n\t// each channel.\n\tExportAllChannelBackups(ctx context.Context, in *ChanBackupExportRequest, opts ...grpc.CallOption) (*ChanBackupSnapshot, error)\n\t// VerifyChanBackup allows a caller to verify the integrity of a channel backup\n\t// snapshot. This method will accept either a packed Single or a packed Multi.\n\t// Specifying both will result in an error.\n\tVerifyChanBackup(ctx context.Context, in *ChanBackupSnapshot, opts ...grpc.CallOption) (*VerifyChanBackupResponse, error)\n\t// lncli: `restorechanbackup`\n\t// RestoreChannelBackups accepts a set of singular channel backups, or a\n\t// single encrypted multi-chan backup and attempts to recover any funds\n\t// remaining within the channel. If we are able to unpack the backup, then the\n\t// new channel will be shown under listchannels, as well as pending channels.\n\tRestoreChannelBackups(ctx context.Context, in *RestoreChanBackupRequest, opts ...grpc.CallOption) (*RestoreBackupResponse, error)\n\t// SubscribeChannelBackups allows a client to sub-subscribe to the most up to\n\t// date information concerning the state of all channel backups. Each time a\n\t// new channel is added, we return the new set of channels, along with a\n\t// multi-chan backup containing the backup info for all channels. Each time a\n\t// channel is closed, we send a new update, which contains new new chan back\n\t// ups, but the updated set of encrypted multi-chan backups with the closed\n\t// channel(s) removed.\n\tSubscribeChannelBackups(ctx context.Context, in *ChannelBackupSubscription, opts ...grpc.CallOption) (Lightning_SubscribeChannelBackupsClient, error)\n\t// lncli: `bakemacaroon`\n\t// BakeMacaroon allows the creation of a new macaroon with custom read and\n\t// write permissions. No first-party caveats are added since this can be done\n\t// offline.\n\tBakeMacaroon(ctx context.Context, in *BakeMacaroonRequest, opts ...grpc.CallOption) (*BakeMacaroonResponse, error)\n\t// lncli: `listmacaroonids`\n\t// ListMacaroonIDs returns all root key IDs that are in use.\n\tListMacaroonIDs(ctx context.Context, in *ListMacaroonIDsRequest, opts ...grpc.CallOption) (*ListMacaroonIDsResponse, error)\n\t// lncli: `deletemacaroonid`\n\t// DeleteMacaroonID deletes the specified macaroon ID and invalidates all\n\t// macaroons derived from that ID.\n\tDeleteMacaroonID(ctx context.Context, in *DeleteMacaroonIDRequest, opts ...grpc.CallOption) (*DeleteMacaroonIDResponse, error)\n\t// lncli: `listpermissions`\n\t// ListPermissions lists all RPC method URIs and their required macaroon\n\t// permissions to access them.\n\tListPermissions(ctx context.Context, in *ListPermissionsRequest, opts ...grpc.CallOption) (*ListPermissionsResponse, error)\n\t// CheckMacaroonPermissions checks whether a request follows the constraints\n\t// imposed on the macaroon and that the macaroon is authorized to follow the\n\t// provided permissions.\n\tCheckMacaroonPermissions(ctx context.Context, in *CheckMacPermRequest, opts ...grpc.CallOption) (*CheckMacPermResponse, error)\n\t// RegisterRPCMiddleware adds a new gRPC middleware to the interceptor chain. A\n\t// gRPC middleware is software component external to lnd that aims to add\n\t// additional business logic to lnd by observing/intercepting/validating\n\t// incoming gRPC client requests and (if needed) replacing/overwriting outgoing\n\t// messages before they're sent to the client. When registering the middleware\n\t// must identify itself and indicate what custom macaroon caveats it wants to\n\t// be responsible for. Only requests that contain a macaroon with that specific\n\t// custom caveat are then sent to the middleware for inspection. The other\n\t// option is to register for the read-only mode in which all requests/responses\n\t// are forwarded for interception to the middleware but the middleware is not\n\t// allowed to modify any responses. As a security measure, _no_ middleware can\n\t// modify responses for requests made with _unencumbered_ macaroons!\n\tRegisterRPCMiddleware(ctx context.Context, opts ...grpc.CallOption) (Lightning_RegisterRPCMiddlewareClient, error)\n\t// lncli: `sendcustom`\n\t// SendCustomMessage sends a custom peer message.\n\tSendCustomMessage(ctx context.Context, in *SendCustomMessageRequest, opts ...grpc.CallOption) (*SendCustomMessageResponse, error)\n\t// lncli: `subscribecustom`\n\t// SubscribeCustomMessages subscribes to a stream of incoming custom peer\n\t// messages.\n\t//\n\t// To include messages with type outside of the custom range (>= 32768) lnd\n\t// needs to be compiled with  the `dev` build tag, and the message type to\n\t// override should be specified in lnd's experimental protocol configuration.\n\tSubscribeCustomMessages(ctx context.Context, in *SubscribeCustomMessagesRequest, opts ...grpc.CallOption) (Lightning_SubscribeCustomMessagesClient, error)\n\t// lncli: `listaliases`\n\t// ListAliases returns the set of all aliases that have ever existed with\n\t// their confirmed SCID (if it exists) and/or the base SCID (in the case of\n\t// zero conf).\n\tListAliases(ctx context.Context, in *ListAliasesRequest, opts ...grpc.CallOption) (*ListAliasesResponse, error)\n\t// LookupHtlcResolution retrieves a final htlc resolution from the database.\n\t// If the htlc has no final resolution yet, a NotFound grpc status code is\n\t// returned.\n\tLookupHtlcResolution(ctx context.Context, in *LookupHtlcResolutionRequest, opts ...grpc.CallOption) (*LookupHtlcResolutionResponse, error)\n}\n",
      "length": 27051,
      "tokens": 3587,
      "embedding": []
    },
    {
      "slug": "type lightningClient struct {",
      "content": "type lightningClient struct {\n\tcc grpc.ClientConnInterface\n}\n",
      "length": 29,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func NewLightningClient(cc grpc.ClientConnInterface) LightningClient {",
      "content": "func NewLightningClient(cc grpc.ClientConnInterface) LightningClient {\n\treturn &lightningClient{cc}\n}\n",
      "length": 29,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) WalletBalance(ctx context.Context, in *WalletBalanceRequest, opts ...grpc.CallOption) (*WalletBalanceResponse, error) {",
      "content": "func (c *lightningClient) WalletBalance(ctx context.Context, in *WalletBalanceRequest, opts ...grpc.CallOption) (*WalletBalanceResponse, error) {\n\tout := new(WalletBalanceResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/WalletBalance\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 162,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) ChannelBalance(ctx context.Context, in *ChannelBalanceRequest, opts ...grpc.CallOption) (*ChannelBalanceResponse, error) {",
      "content": "func (c *lightningClient) ChannelBalance(ctx context.Context, in *ChannelBalanceRequest, opts ...grpc.CallOption) (*ChannelBalanceResponse, error) {\n\tout := new(ChannelBalanceResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/ChannelBalance\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 164,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) GetTransactions(ctx context.Context, in *GetTransactionsRequest, opts ...grpc.CallOption) (*TransactionDetails, error) {",
      "content": "func (c *lightningClient) GetTransactions(ctx context.Context, in *GetTransactionsRequest, opts ...grpc.CallOption) (*TransactionDetails, error) {\n\tout := new(TransactionDetails)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/GetTransactions\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 161,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) EstimateFee(ctx context.Context, in *EstimateFeeRequest, opts ...grpc.CallOption) (*EstimateFeeResponse, error) {",
      "content": "func (c *lightningClient) EstimateFee(ctx context.Context, in *EstimateFeeRequest, opts ...grpc.CallOption) (*EstimateFeeResponse, error) {\n\tout := new(EstimateFeeResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/EstimateFee\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 158,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) SendCoins(ctx context.Context, in *SendCoinsRequest, opts ...grpc.CallOption) (*SendCoinsResponse, error) {",
      "content": "func (c *lightningClient) SendCoins(ctx context.Context, in *SendCoinsRequest, opts ...grpc.CallOption) (*SendCoinsResponse, error) {\n\tout := new(SendCoinsResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/SendCoins\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 154,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) ListUnspent(ctx context.Context, in *ListUnspentRequest, opts ...grpc.CallOption) (*ListUnspentResponse, error) {",
      "content": "func (c *lightningClient) ListUnspent(ctx context.Context, in *ListUnspentRequest, opts ...grpc.CallOption) (*ListUnspentResponse, error) {\n\tout := new(ListUnspentResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/ListUnspent\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 158,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) SubscribeTransactions(ctx context.Context, in *GetTransactionsRequest, opts ...grpc.CallOption) (Lightning_SubscribeTransactionsClient, error) {",
      "content": "func (c *lightningClient) SubscribeTransactions(ctx context.Context, in *GetTransactionsRequest, opts ...grpc.CallOption) (Lightning_SubscribeTransactionsClient, error) {\n\tstream, err := c.cc.NewStream(ctx, &Lightning_ServiceDesc.Streams[0], \"/lnrpc.Lightning/SubscribeTransactions\", opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tx := &lightningSubscribeTransactionsClient{stream}\n\tif err := x.ClientStream.SendMsg(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := x.ClientStream.CloseSend(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn x, nil\n}\n",
      "length": 362,
      "tokens": 47,
      "embedding": []
    },
    {
      "slug": "type Lightning_SubscribeTransactionsClient interface {",
      "content": "type Lightning_SubscribeTransactionsClient interface {\n\tRecv() (*Transaction, error)\n\tgrpc.ClientStream\n}\n",
      "length": 48,
      "tokens": 5,
      "embedding": []
    },
    {
      "slug": "type lightningSubscribeTransactionsClient struct {",
      "content": "type lightningSubscribeTransactionsClient struct {\n\tgrpc.ClientStream\n}\n",
      "length": 19,
      "tokens": 2,
      "embedding": []
    },
    {
      "slug": "func (x *lightningSubscribeTransactionsClient) Recv() (*Transaction, error) {",
      "content": "func (x *lightningSubscribeTransactionsClient) Recv() (*Transaction, error) {\n\tm := new(Transaction)\n\tif err := x.ClientStream.RecvMsg(m); err != nil {\n\t\treturn nil, err\n\t}\n\treturn m, nil\n}\n",
      "length": 106,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) SendMany(ctx context.Context, in *SendManyRequest, opts ...grpc.CallOption) (*SendManyResponse, error) {",
      "content": "func (c *lightningClient) SendMany(ctx context.Context, in *SendManyRequest, opts ...grpc.CallOption) (*SendManyResponse, error) {\n\tout := new(SendManyResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/SendMany\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 152,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) NewAddress(ctx context.Context, in *NewAddressRequest, opts ...grpc.CallOption) (*NewAddressResponse, error) {",
      "content": "func (c *lightningClient) NewAddress(ctx context.Context, in *NewAddressRequest, opts ...grpc.CallOption) (*NewAddressResponse, error) {\n\tout := new(NewAddressResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/NewAddress\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 156,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) SignMessage(ctx context.Context, in *SignMessageRequest, opts ...grpc.CallOption) (*SignMessageResponse, error) {",
      "content": "func (c *lightningClient) SignMessage(ctx context.Context, in *SignMessageRequest, opts ...grpc.CallOption) (*SignMessageResponse, error) {\n\tout := new(SignMessageResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/SignMessage\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 158,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) VerifyMessage(ctx context.Context, in *VerifyMessageRequest, opts ...grpc.CallOption) (*VerifyMessageResponse, error) {",
      "content": "func (c *lightningClient) VerifyMessage(ctx context.Context, in *VerifyMessageRequest, opts ...grpc.CallOption) (*VerifyMessageResponse, error) {\n\tout := new(VerifyMessageResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/VerifyMessage\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 162,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) ConnectPeer(ctx context.Context, in *ConnectPeerRequest, opts ...grpc.CallOption) (*ConnectPeerResponse, error) {",
      "content": "func (c *lightningClient) ConnectPeer(ctx context.Context, in *ConnectPeerRequest, opts ...grpc.CallOption) (*ConnectPeerResponse, error) {\n\tout := new(ConnectPeerResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/ConnectPeer\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 158,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) DisconnectPeer(ctx context.Context, in *DisconnectPeerRequest, opts ...grpc.CallOption) (*DisconnectPeerResponse, error) {",
      "content": "func (c *lightningClient) DisconnectPeer(ctx context.Context, in *DisconnectPeerRequest, opts ...grpc.CallOption) (*DisconnectPeerResponse, error) {\n\tout := new(DisconnectPeerResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/DisconnectPeer\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 164,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) ListPeers(ctx context.Context, in *ListPeersRequest, opts ...grpc.CallOption) (*ListPeersResponse, error) {",
      "content": "func (c *lightningClient) ListPeers(ctx context.Context, in *ListPeersRequest, opts ...grpc.CallOption) (*ListPeersResponse, error) {\n\tout := new(ListPeersResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/ListPeers\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 154,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) SubscribePeerEvents(ctx context.Context, in *PeerEventSubscription, opts ...grpc.CallOption) (Lightning_SubscribePeerEventsClient, error) {",
      "content": "func (c *lightningClient) SubscribePeerEvents(ctx context.Context, in *PeerEventSubscription, opts ...grpc.CallOption) (Lightning_SubscribePeerEventsClient, error) {\n\tstream, err := c.cc.NewStream(ctx, &Lightning_ServiceDesc.Streams[1], \"/lnrpc.Lightning/SubscribePeerEvents\", opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tx := &lightningSubscribePeerEventsClient{stream}\n\tif err := x.ClientStream.SendMsg(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := x.ClientStream.CloseSend(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn x, nil\n}\n",
      "length": 358,
      "tokens": 47,
      "embedding": []
    },
    {
      "slug": "type Lightning_SubscribePeerEventsClient interface {",
      "content": "type Lightning_SubscribePeerEventsClient interface {\n\tRecv() (*PeerEvent, error)\n\tgrpc.ClientStream\n}\n",
      "length": 46,
      "tokens": 5,
      "embedding": []
    },
    {
      "slug": "type lightningSubscribePeerEventsClient struct {",
      "content": "type lightningSubscribePeerEventsClient struct {\n\tgrpc.ClientStream\n}\n",
      "length": 19,
      "tokens": 2,
      "embedding": []
    },
    {
      "slug": "func (x *lightningSubscribePeerEventsClient) Recv() (*PeerEvent, error) {",
      "content": "func (x *lightningSubscribePeerEventsClient) Recv() (*PeerEvent, error) {\n\tm := new(PeerEvent)\n\tif err := x.ClientStream.RecvMsg(m); err != nil {\n\t\treturn nil, err\n\t}\n\treturn m, nil\n}\n",
      "length": 104,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*GetInfoResponse, error) {",
      "content": "func (c *lightningClient) GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*GetInfoResponse, error) {\n\tout := new(GetInfoResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/GetInfo\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 150,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) GetRecoveryInfo(ctx context.Context, in *GetRecoveryInfoRequest, opts ...grpc.CallOption) (*GetRecoveryInfoResponse, error) {",
      "content": "func (c *lightningClient) GetRecoveryInfo(ctx context.Context, in *GetRecoveryInfoRequest, opts ...grpc.CallOption) (*GetRecoveryInfoResponse, error) {\n\tout := new(GetRecoveryInfoResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/GetRecoveryInfo\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 166,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) PendingChannels(ctx context.Context, in *PendingChannelsRequest, opts ...grpc.CallOption) (*PendingChannelsResponse, error) {",
      "content": "func (c *lightningClient) PendingChannels(ctx context.Context, in *PendingChannelsRequest, opts ...grpc.CallOption) (*PendingChannelsResponse, error) {\n\tout := new(PendingChannelsResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/PendingChannels\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 166,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) ListChannels(ctx context.Context, in *ListChannelsRequest, opts ...grpc.CallOption) (*ListChannelsResponse, error) {",
      "content": "func (c *lightningClient) ListChannels(ctx context.Context, in *ListChannelsRequest, opts ...grpc.CallOption) (*ListChannelsResponse, error) {\n\tout := new(ListChannelsResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/ListChannels\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 160,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) SubscribeChannelEvents(ctx context.Context, in *ChannelEventSubscription, opts ...grpc.CallOption) (Lightning_SubscribeChannelEventsClient, error) {",
      "content": "func (c *lightningClient) SubscribeChannelEvents(ctx context.Context, in *ChannelEventSubscription, opts ...grpc.CallOption) (Lightning_SubscribeChannelEventsClient, error) {\n\tstream, err := c.cc.NewStream(ctx, &Lightning_ServiceDesc.Streams[2], \"/lnrpc.Lightning/SubscribeChannelEvents\", opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tx := &lightningSubscribeChannelEventsClient{stream}\n\tif err := x.ClientStream.SendMsg(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := x.ClientStream.CloseSend(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn x, nil\n}\n",
      "length": 364,
      "tokens": 47,
      "embedding": []
    },
    {
      "slug": "type Lightning_SubscribeChannelEventsClient interface {",
      "content": "type Lightning_SubscribeChannelEventsClient interface {\n\tRecv() (*ChannelEventUpdate, error)\n\tgrpc.ClientStream\n}\n",
      "length": 55,
      "tokens": 5,
      "embedding": []
    },
    {
      "slug": "type lightningSubscribeChannelEventsClient struct {",
      "content": "type lightningSubscribeChannelEventsClient struct {\n\tgrpc.ClientStream\n}\n",
      "length": 19,
      "tokens": 2,
      "embedding": []
    },
    {
      "slug": "func (x *lightningSubscribeChannelEventsClient) Recv() (*ChannelEventUpdate, error) {",
      "content": "func (x *lightningSubscribeChannelEventsClient) Recv() (*ChannelEventUpdate, error) {\n\tm := new(ChannelEventUpdate)\n\tif err := x.ClientStream.RecvMsg(m); err != nil {\n\t\treturn nil, err\n\t}\n\treturn m, nil\n}\n",
      "length": 113,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) ClosedChannels(ctx context.Context, in *ClosedChannelsRequest, opts ...grpc.CallOption) (*ClosedChannelsResponse, error) {",
      "content": "func (c *lightningClient) ClosedChannels(ctx context.Context, in *ClosedChannelsRequest, opts ...grpc.CallOption) (*ClosedChannelsResponse, error) {\n\tout := new(ClosedChannelsResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/ClosedChannels\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 164,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) OpenChannelSync(ctx context.Context, in *OpenChannelRequest, opts ...grpc.CallOption) (*ChannelPoint, error) {",
      "content": "func (c *lightningClient) OpenChannelSync(ctx context.Context, in *OpenChannelRequest, opts ...grpc.CallOption) (*ChannelPoint, error) {\n\tout := new(ChannelPoint)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/OpenChannelSync\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 155,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) OpenChannel(ctx context.Context, in *OpenChannelRequest, opts ...grpc.CallOption) (Lightning_OpenChannelClient, error) {",
      "content": "func (c *lightningClient) OpenChannel(ctx context.Context, in *OpenChannelRequest, opts ...grpc.CallOption) (Lightning_OpenChannelClient, error) {\n\tstream, err := c.cc.NewStream(ctx, &Lightning_ServiceDesc.Streams[3], \"/lnrpc.Lightning/OpenChannel\", opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tx := &lightningOpenChannelClient{stream}\n\tif err := x.ClientStream.SendMsg(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := x.ClientStream.CloseSend(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn x, nil\n}\n",
      "length": 342,
      "tokens": 47,
      "embedding": []
    },
    {
      "slug": "type Lightning_OpenChannelClient interface {",
      "content": "type Lightning_OpenChannelClient interface {\n\tRecv() (*OpenStatusUpdate, error)\n\tgrpc.ClientStream\n}\n",
      "length": 53,
      "tokens": 5,
      "embedding": []
    },
    {
      "slug": "type lightningOpenChannelClient struct {",
      "content": "type lightningOpenChannelClient struct {\n\tgrpc.ClientStream\n}\n",
      "length": 19,
      "tokens": 2,
      "embedding": []
    },
    {
      "slug": "func (x *lightningOpenChannelClient) Recv() (*OpenStatusUpdate, error) {",
      "content": "func (x *lightningOpenChannelClient) Recv() (*OpenStatusUpdate, error) {\n\tm := new(OpenStatusUpdate)\n\tif err := x.ClientStream.RecvMsg(m); err != nil {\n\t\treturn nil, err\n\t}\n\treturn m, nil\n}\n",
      "length": 111,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) BatchOpenChannel(ctx context.Context, in *BatchOpenChannelRequest, opts ...grpc.CallOption) (*BatchOpenChannelResponse, error) {",
      "content": "func (c *lightningClient) BatchOpenChannel(ctx context.Context, in *BatchOpenChannelRequest, opts ...grpc.CallOption) (*BatchOpenChannelResponse, error) {\n\tout := new(BatchOpenChannelResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/BatchOpenChannel\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 168,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) FundingStateStep(ctx context.Context, in *FundingTransitionMsg, opts ...grpc.CallOption) (*FundingStateStepResp, error) {",
      "content": "func (c *lightningClient) FundingStateStep(ctx context.Context, in *FundingTransitionMsg, opts ...grpc.CallOption) (*FundingStateStepResp, error) {\n\tout := new(FundingStateStepResp)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/FundingStateStep\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 164,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) ChannelAcceptor(ctx context.Context, opts ...grpc.CallOption) (Lightning_ChannelAcceptorClient, error) {",
      "content": "func (c *lightningClient) ChannelAcceptor(ctx context.Context, opts ...grpc.CallOption) (Lightning_ChannelAcceptorClient, error) {\n\tstream, err := c.cc.NewStream(ctx, &Lightning_ServiceDesc.Streams[4], \"/lnrpc.Lightning/ChannelAcceptor\", opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tx := &lightningChannelAcceptorClient{stream}\n\treturn x, nil\n}\n",
      "length": 210,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "type Lightning_ChannelAcceptorClient interface {",
      "content": "type Lightning_ChannelAcceptorClient interface {\n\tSend(*ChannelAcceptResponse) error\n\tRecv() (*ChannelAcceptRequest, error)\n\tgrpc.ClientStream\n}\n",
      "length": 92,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "type lightningChannelAcceptorClient struct {",
      "content": "type lightningChannelAcceptorClient struct {\n\tgrpc.ClientStream\n}\n",
      "length": 19,
      "tokens": 2,
      "embedding": []
    },
    {
      "slug": "func (x *lightningChannelAcceptorClient) Send(m *ChannelAcceptResponse) error {",
      "content": "func (x *lightningChannelAcceptorClient) Send(m *ChannelAcceptResponse) error {\n\treturn x.ClientStream.SendMsg(m)\n}\n",
      "length": 34,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (x *lightningChannelAcceptorClient) Recv() (*ChannelAcceptRequest, error) {",
      "content": "func (x *lightningChannelAcceptorClient) Recv() (*ChannelAcceptRequest, error) {\n\tm := new(ChannelAcceptRequest)\n\tif err := x.ClientStream.RecvMsg(m); err != nil {\n\t\treturn nil, err\n\t}\n\treturn m, nil\n}\n",
      "length": 115,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) CloseChannel(ctx context.Context, in *CloseChannelRequest, opts ...grpc.CallOption) (Lightning_CloseChannelClient, error) {",
      "content": "func (c *lightningClient) CloseChannel(ctx context.Context, in *CloseChannelRequest, opts ...grpc.CallOption) (Lightning_CloseChannelClient, error) {\n\tstream, err := c.cc.NewStream(ctx, &Lightning_ServiceDesc.Streams[5], \"/lnrpc.Lightning/CloseChannel\", opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tx := &lightningCloseChannelClient{stream}\n\tif err := x.ClientStream.SendMsg(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := x.ClientStream.CloseSend(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn x, nil\n}\n",
      "length": 344,
      "tokens": 47,
      "embedding": []
    },
    {
      "slug": "type Lightning_CloseChannelClient interface {",
      "content": "type Lightning_CloseChannelClient interface {\n\tRecv() (*CloseStatusUpdate, error)\n\tgrpc.ClientStream\n}\n",
      "length": 54,
      "tokens": 5,
      "embedding": []
    },
    {
      "slug": "type lightningCloseChannelClient struct {",
      "content": "type lightningCloseChannelClient struct {\n\tgrpc.ClientStream\n}\n",
      "length": 19,
      "tokens": 2,
      "embedding": []
    },
    {
      "slug": "func (x *lightningCloseChannelClient) Recv() (*CloseStatusUpdate, error) {",
      "content": "func (x *lightningCloseChannelClient) Recv() (*CloseStatusUpdate, error) {\n\tm := new(CloseStatusUpdate)\n\tif err := x.ClientStream.RecvMsg(m); err != nil {\n\t\treturn nil, err\n\t}\n\treturn m, nil\n}\n",
      "length": 112,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) AbandonChannel(ctx context.Context, in *AbandonChannelRequest, opts ...grpc.CallOption) (*AbandonChannelResponse, error) {",
      "content": "func (c *lightningClient) AbandonChannel(ctx context.Context, in *AbandonChannelRequest, opts ...grpc.CallOption) (*AbandonChannelResponse, error) {\n\tout := new(AbandonChannelResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/AbandonChannel\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n\n// Deprecated: Do not use.",
      "length": 190,
      "tokens": 28,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) SendPayment(ctx context.Context, opts ...grpc.CallOption) (Lightning_SendPaymentClient, error) {",
      "content": "func (c *lightningClient) SendPayment(ctx context.Context, opts ...grpc.CallOption) (Lightning_SendPaymentClient, error) {\n\tstream, err := c.cc.NewStream(ctx, &Lightning_ServiceDesc.Streams[6], \"/lnrpc.Lightning/SendPayment\", opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tx := &lightningSendPaymentClient{stream}\n\treturn x, nil\n}\n",
      "length": 202,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "type Lightning_SendPaymentClient interface {",
      "content": "type Lightning_SendPaymentClient interface {\n\tSend(*SendRequest) error\n\tRecv() (*SendResponse, error)\n\tgrpc.ClientStream\n}\n",
      "length": 74,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "type lightningSendPaymentClient struct {",
      "content": "type lightningSendPaymentClient struct {\n\tgrpc.ClientStream\n}\n",
      "length": 19,
      "tokens": 2,
      "embedding": []
    },
    {
      "slug": "func (x *lightningSendPaymentClient) Send(m *SendRequest) error {",
      "content": "func (x *lightningSendPaymentClient) Send(m *SendRequest) error {\n\treturn x.ClientStream.SendMsg(m)\n}\n",
      "length": 34,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (x *lightningSendPaymentClient) Recv() (*SendResponse, error) {",
      "content": "func (x *lightningSendPaymentClient) Recv() (*SendResponse, error) {\n\tm := new(SendResponse)\n\tif err := x.ClientStream.RecvMsg(m); err != nil {\n\t\treturn nil, err\n\t}\n\treturn m, nil\n}\n",
      "length": 107,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) SendPaymentSync(ctx context.Context, in *SendRequest, opts ...grpc.CallOption) (*SendResponse, error) {",
      "content": "func (c *lightningClient) SendPaymentSync(ctx context.Context, in *SendRequest, opts ...grpc.CallOption) (*SendResponse, error) {\n\tout := new(SendResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/SendPaymentSync\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n\n// Deprecated: Do not use.",
      "length": 181,
      "tokens": 28,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) SendToRoute(ctx context.Context, opts ...grpc.CallOption) (Lightning_SendToRouteClient, error) {",
      "content": "func (c *lightningClient) SendToRoute(ctx context.Context, opts ...grpc.CallOption) (Lightning_SendToRouteClient, error) {\n\tstream, err := c.cc.NewStream(ctx, &Lightning_ServiceDesc.Streams[7], \"/lnrpc.Lightning/SendToRoute\", opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tx := &lightningSendToRouteClient{stream}\n\treturn x, nil\n}\n",
      "length": 202,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "type Lightning_SendToRouteClient interface {",
      "content": "type Lightning_SendToRouteClient interface {\n\tSend(*SendToRouteRequest) error\n\tRecv() (*SendResponse, error)\n\tgrpc.ClientStream\n}\n",
      "length": 81,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "type lightningSendToRouteClient struct {",
      "content": "type lightningSendToRouteClient struct {\n\tgrpc.ClientStream\n}\n",
      "length": 19,
      "tokens": 2,
      "embedding": []
    },
    {
      "slug": "func (x *lightningSendToRouteClient) Send(m *SendToRouteRequest) error {",
      "content": "func (x *lightningSendToRouteClient) Send(m *SendToRouteRequest) error {\n\treturn x.ClientStream.SendMsg(m)\n}\n",
      "length": 34,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (x *lightningSendToRouteClient) Recv() (*SendResponse, error) {",
      "content": "func (x *lightningSendToRouteClient) Recv() (*SendResponse, error) {\n\tm := new(SendResponse)\n\tif err := x.ClientStream.RecvMsg(m); err != nil {\n\t\treturn nil, err\n\t}\n\treturn m, nil\n}\n",
      "length": 107,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) SendToRouteSync(ctx context.Context, in *SendToRouteRequest, opts ...grpc.CallOption) (*SendResponse, error) {",
      "content": "func (c *lightningClient) SendToRouteSync(ctx context.Context, in *SendToRouteRequest, opts ...grpc.CallOption) (*SendResponse, error) {\n\tout := new(SendResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/SendToRouteSync\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 155,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) AddInvoice(ctx context.Context, in *Invoice, opts ...grpc.CallOption) (*AddInvoiceResponse, error) {",
      "content": "func (c *lightningClient) AddInvoice(ctx context.Context, in *Invoice, opts ...grpc.CallOption) (*AddInvoiceResponse, error) {\n\tout := new(AddInvoiceResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/AddInvoice\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 156,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) ListInvoices(ctx context.Context, in *ListInvoiceRequest, opts ...grpc.CallOption) (*ListInvoiceResponse, error) {",
      "content": "func (c *lightningClient) ListInvoices(ctx context.Context, in *ListInvoiceRequest, opts ...grpc.CallOption) (*ListInvoiceResponse, error) {\n\tout := new(ListInvoiceResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/ListInvoices\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 159,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) LookupInvoice(ctx context.Context, in *PaymentHash, opts ...grpc.CallOption) (*Invoice, error) {",
      "content": "func (c *lightningClient) LookupInvoice(ctx context.Context, in *PaymentHash, opts ...grpc.CallOption) (*Invoice, error) {\n\tout := new(Invoice)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/LookupInvoice\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 148,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) SubscribeInvoices(ctx context.Context, in *InvoiceSubscription, opts ...grpc.CallOption) (Lightning_SubscribeInvoicesClient, error) {",
      "content": "func (c *lightningClient) SubscribeInvoices(ctx context.Context, in *InvoiceSubscription, opts ...grpc.CallOption) (Lightning_SubscribeInvoicesClient, error) {\n\tstream, err := c.cc.NewStream(ctx, &Lightning_ServiceDesc.Streams[8], \"/lnrpc.Lightning/SubscribeInvoices\", opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tx := &lightningSubscribeInvoicesClient{stream}\n\tif err := x.ClientStream.SendMsg(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := x.ClientStream.CloseSend(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn x, nil\n}\n",
      "length": 354,
      "tokens": 47,
      "embedding": []
    },
    {
      "slug": "type Lightning_SubscribeInvoicesClient interface {",
      "content": "type Lightning_SubscribeInvoicesClient interface {\n\tRecv() (*Invoice, error)\n\tgrpc.ClientStream\n}\n",
      "length": 44,
      "tokens": 5,
      "embedding": []
    },
    {
      "slug": "type lightningSubscribeInvoicesClient struct {",
      "content": "type lightningSubscribeInvoicesClient struct {\n\tgrpc.ClientStream\n}\n",
      "length": 19,
      "tokens": 2,
      "embedding": []
    },
    {
      "slug": "func (x *lightningSubscribeInvoicesClient) Recv() (*Invoice, error) {",
      "content": "func (x *lightningSubscribeInvoicesClient) Recv() (*Invoice, error) {\n\tm := new(Invoice)\n\tif err := x.ClientStream.RecvMsg(m); err != nil {\n\t\treturn nil, err\n\t}\n\treturn m, nil\n}\n",
      "length": 102,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) DecodePayReq(ctx context.Context, in *PayReqString, opts ...grpc.CallOption) (*PayReq, error) {",
      "content": "func (c *lightningClient) DecodePayReq(ctx context.Context, in *PayReqString, opts ...grpc.CallOption) (*PayReq, error) {\n\tout := new(PayReq)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/DecodePayReq\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 146,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) ListPayments(ctx context.Context, in *ListPaymentsRequest, opts ...grpc.CallOption) (*ListPaymentsResponse, error) {",
      "content": "func (c *lightningClient) ListPayments(ctx context.Context, in *ListPaymentsRequest, opts ...grpc.CallOption) (*ListPaymentsResponse, error) {\n\tout := new(ListPaymentsResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/ListPayments\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 160,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) DeletePayment(ctx context.Context, in *DeletePaymentRequest, opts ...grpc.CallOption) (*DeletePaymentResponse, error) {",
      "content": "func (c *lightningClient) DeletePayment(ctx context.Context, in *DeletePaymentRequest, opts ...grpc.CallOption) (*DeletePaymentResponse, error) {\n\tout := new(DeletePaymentResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/DeletePayment\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 162,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) DeleteAllPayments(ctx context.Context, in *DeleteAllPaymentsRequest, opts ...grpc.CallOption) (*DeleteAllPaymentsResponse, error) {",
      "content": "func (c *lightningClient) DeleteAllPayments(ctx context.Context, in *DeleteAllPaymentsRequest, opts ...grpc.CallOption) (*DeleteAllPaymentsResponse, error) {\n\tout := new(DeleteAllPaymentsResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/DeleteAllPayments\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 170,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) DescribeGraph(ctx context.Context, in *ChannelGraphRequest, opts ...grpc.CallOption) (*ChannelGraph, error) {",
      "content": "func (c *lightningClient) DescribeGraph(ctx context.Context, in *ChannelGraphRequest, opts ...grpc.CallOption) (*ChannelGraph, error) {\n\tout := new(ChannelGraph)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/DescribeGraph\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 153,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) GetNodeMetrics(ctx context.Context, in *NodeMetricsRequest, opts ...grpc.CallOption) (*NodeMetricsResponse, error) {",
      "content": "func (c *lightningClient) GetNodeMetrics(ctx context.Context, in *NodeMetricsRequest, opts ...grpc.CallOption) (*NodeMetricsResponse, error) {\n\tout := new(NodeMetricsResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/GetNodeMetrics\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 161,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) GetChanInfo(ctx context.Context, in *ChanInfoRequest, opts ...grpc.CallOption) (*ChannelEdge, error) {",
      "content": "func (c *lightningClient) GetChanInfo(ctx context.Context, in *ChanInfoRequest, opts ...grpc.CallOption) (*ChannelEdge, error) {\n\tout := new(ChannelEdge)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/GetChanInfo\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 150,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) GetNodeInfo(ctx context.Context, in *NodeInfoRequest, opts ...grpc.CallOption) (*NodeInfo, error) {",
      "content": "func (c *lightningClient) GetNodeInfo(ctx context.Context, in *NodeInfoRequest, opts ...grpc.CallOption) (*NodeInfo, error) {\n\tout := new(NodeInfo)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/GetNodeInfo\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 147,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) QueryRoutes(ctx context.Context, in *QueryRoutesRequest, opts ...grpc.CallOption) (*QueryRoutesResponse, error) {",
      "content": "func (c *lightningClient) QueryRoutes(ctx context.Context, in *QueryRoutesRequest, opts ...grpc.CallOption) (*QueryRoutesResponse, error) {\n\tout := new(QueryRoutesResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/QueryRoutes\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 158,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) GetNetworkInfo(ctx context.Context, in *NetworkInfoRequest, opts ...grpc.CallOption) (*NetworkInfo, error) {",
      "content": "func (c *lightningClient) GetNetworkInfo(ctx context.Context, in *NetworkInfoRequest, opts ...grpc.CallOption) (*NetworkInfo, error) {\n\tout := new(NetworkInfo)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/GetNetworkInfo\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 153,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) StopDaemon(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopResponse, error) {",
      "content": "func (c *lightningClient) StopDaemon(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopResponse, error) {\n\tout := new(StopResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/StopDaemon\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 150,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) SubscribeChannelGraph(ctx context.Context, in *GraphTopologySubscription, opts ...grpc.CallOption) (Lightning_SubscribeChannelGraphClient, error) {",
      "content": "func (c *lightningClient) SubscribeChannelGraph(ctx context.Context, in *GraphTopologySubscription, opts ...grpc.CallOption) (Lightning_SubscribeChannelGraphClient, error) {\n\tstream, err := c.cc.NewStream(ctx, &Lightning_ServiceDesc.Streams[9], \"/lnrpc.Lightning/SubscribeChannelGraph\", opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tx := &lightningSubscribeChannelGraphClient{stream}\n\tif err := x.ClientStream.SendMsg(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := x.ClientStream.CloseSend(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn x, nil\n}\n",
      "length": 362,
      "tokens": 47,
      "embedding": []
    },
    {
      "slug": "type Lightning_SubscribeChannelGraphClient interface {",
      "content": "type Lightning_SubscribeChannelGraphClient interface {\n\tRecv() (*GraphTopologyUpdate, error)\n\tgrpc.ClientStream\n}\n",
      "length": 56,
      "tokens": 5,
      "embedding": []
    },
    {
      "slug": "type lightningSubscribeChannelGraphClient struct {",
      "content": "type lightningSubscribeChannelGraphClient struct {\n\tgrpc.ClientStream\n}\n",
      "length": 19,
      "tokens": 2,
      "embedding": []
    },
    {
      "slug": "func (x *lightningSubscribeChannelGraphClient) Recv() (*GraphTopologyUpdate, error) {",
      "content": "func (x *lightningSubscribeChannelGraphClient) Recv() (*GraphTopologyUpdate, error) {\n\tm := new(GraphTopologyUpdate)\n\tif err := x.ClientStream.RecvMsg(m); err != nil {\n\t\treturn nil, err\n\t}\n\treturn m, nil\n}\n",
      "length": 114,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) DebugLevel(ctx context.Context, in *DebugLevelRequest, opts ...grpc.CallOption) (*DebugLevelResponse, error) {",
      "content": "func (c *lightningClient) DebugLevel(ctx context.Context, in *DebugLevelRequest, opts ...grpc.CallOption) (*DebugLevelResponse, error) {\n\tout := new(DebugLevelResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/DebugLevel\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 156,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) FeeReport(ctx context.Context, in *FeeReportRequest, opts ...grpc.CallOption) (*FeeReportResponse, error) {",
      "content": "func (c *lightningClient) FeeReport(ctx context.Context, in *FeeReportRequest, opts ...grpc.CallOption) (*FeeReportResponse, error) {\n\tout := new(FeeReportResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/FeeReport\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 154,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) UpdateChannelPolicy(ctx context.Context, in *PolicyUpdateRequest, opts ...grpc.CallOption) (*PolicyUpdateResponse, error) {",
      "content": "func (c *lightningClient) UpdateChannelPolicy(ctx context.Context, in *PolicyUpdateRequest, opts ...grpc.CallOption) (*PolicyUpdateResponse, error) {\n\tout := new(PolicyUpdateResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/UpdateChannelPolicy\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 167,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) ForwardingHistory(ctx context.Context, in *ForwardingHistoryRequest, opts ...grpc.CallOption) (*ForwardingHistoryResponse, error) {",
      "content": "func (c *lightningClient) ForwardingHistory(ctx context.Context, in *ForwardingHistoryRequest, opts ...grpc.CallOption) (*ForwardingHistoryResponse, error) {\n\tout := new(ForwardingHistoryResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/ForwardingHistory\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 170,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) ExportChannelBackup(ctx context.Context, in *ExportChannelBackupRequest, opts ...grpc.CallOption) (*ChannelBackup, error) {",
      "content": "func (c *lightningClient) ExportChannelBackup(ctx context.Context, in *ExportChannelBackupRequest, opts ...grpc.CallOption) (*ChannelBackup, error) {\n\tout := new(ChannelBackup)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/ExportChannelBackup\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 160,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) ExportAllChannelBackups(ctx context.Context, in *ChanBackupExportRequest, opts ...grpc.CallOption) (*ChanBackupSnapshot, error) {",
      "content": "func (c *lightningClient) ExportAllChannelBackups(ctx context.Context, in *ChanBackupExportRequest, opts ...grpc.CallOption) (*ChanBackupSnapshot, error) {\n\tout := new(ChanBackupSnapshot)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/ExportAllChannelBackups\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 169,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) VerifyChanBackup(ctx context.Context, in *ChanBackupSnapshot, opts ...grpc.CallOption) (*VerifyChanBackupResponse, error) {",
      "content": "func (c *lightningClient) VerifyChanBackup(ctx context.Context, in *ChanBackupSnapshot, opts ...grpc.CallOption) (*VerifyChanBackupResponse, error) {\n\tout := new(VerifyChanBackupResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/VerifyChanBackup\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 168,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) RestoreChannelBackups(ctx context.Context, in *RestoreChanBackupRequest, opts ...grpc.CallOption) (*RestoreBackupResponse, error) {",
      "content": "func (c *lightningClient) RestoreChannelBackups(ctx context.Context, in *RestoreChanBackupRequest, opts ...grpc.CallOption) (*RestoreBackupResponse, error) {\n\tout := new(RestoreBackupResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/RestoreChannelBackups\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 170,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) SubscribeChannelBackups(ctx context.Context, in *ChannelBackupSubscription, opts ...grpc.CallOption) (Lightning_SubscribeChannelBackupsClient, error) {",
      "content": "func (c *lightningClient) SubscribeChannelBackups(ctx context.Context, in *ChannelBackupSubscription, opts ...grpc.CallOption) (Lightning_SubscribeChannelBackupsClient, error) {\n\tstream, err := c.cc.NewStream(ctx, &Lightning_ServiceDesc.Streams[10], \"/lnrpc.Lightning/SubscribeChannelBackups\", opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tx := &lightningSubscribeChannelBackupsClient{stream}\n\tif err := x.ClientStream.SendMsg(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := x.ClientStream.CloseSend(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn x, nil\n}\n",
      "length": 367,
      "tokens": 47,
      "embedding": []
    },
    {
      "slug": "type Lightning_SubscribeChannelBackupsClient interface {",
      "content": "type Lightning_SubscribeChannelBackupsClient interface {\n\tRecv() (*ChanBackupSnapshot, error)\n\tgrpc.ClientStream\n}\n",
      "length": 55,
      "tokens": 5,
      "embedding": []
    },
    {
      "slug": "type lightningSubscribeChannelBackupsClient struct {",
      "content": "type lightningSubscribeChannelBackupsClient struct {\n\tgrpc.ClientStream\n}\n",
      "length": 19,
      "tokens": 2,
      "embedding": []
    },
    {
      "slug": "func (x *lightningSubscribeChannelBackupsClient) Recv() (*ChanBackupSnapshot, error) {",
      "content": "func (x *lightningSubscribeChannelBackupsClient) Recv() (*ChanBackupSnapshot, error) {\n\tm := new(ChanBackupSnapshot)\n\tif err := x.ClientStream.RecvMsg(m); err != nil {\n\t\treturn nil, err\n\t}\n\treturn m, nil\n}\n",
      "length": 113,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) BakeMacaroon(ctx context.Context, in *BakeMacaroonRequest, opts ...grpc.CallOption) (*BakeMacaroonResponse, error) {",
      "content": "func (c *lightningClient) BakeMacaroon(ctx context.Context, in *BakeMacaroonRequest, opts ...grpc.CallOption) (*BakeMacaroonResponse, error) {\n\tout := new(BakeMacaroonResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/BakeMacaroon\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 160,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) ListMacaroonIDs(ctx context.Context, in *ListMacaroonIDsRequest, opts ...grpc.CallOption) (*ListMacaroonIDsResponse, error) {",
      "content": "func (c *lightningClient) ListMacaroonIDs(ctx context.Context, in *ListMacaroonIDsRequest, opts ...grpc.CallOption) (*ListMacaroonIDsResponse, error) {\n\tout := new(ListMacaroonIDsResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/ListMacaroonIDs\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 166,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) DeleteMacaroonID(ctx context.Context, in *DeleteMacaroonIDRequest, opts ...grpc.CallOption) (*DeleteMacaroonIDResponse, error) {",
      "content": "func (c *lightningClient) DeleteMacaroonID(ctx context.Context, in *DeleteMacaroonIDRequest, opts ...grpc.CallOption) (*DeleteMacaroonIDResponse, error) {\n\tout := new(DeleteMacaroonIDResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/DeleteMacaroonID\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 168,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) ListPermissions(ctx context.Context, in *ListPermissionsRequest, opts ...grpc.CallOption) (*ListPermissionsResponse, error) {",
      "content": "func (c *lightningClient) ListPermissions(ctx context.Context, in *ListPermissionsRequest, opts ...grpc.CallOption) (*ListPermissionsResponse, error) {\n\tout := new(ListPermissionsResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/ListPermissions\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 166,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) CheckMacaroonPermissions(ctx context.Context, in *CheckMacPermRequest, opts ...grpc.CallOption) (*CheckMacPermResponse, error) {",
      "content": "func (c *lightningClient) CheckMacaroonPermissions(ctx context.Context, in *CheckMacPermRequest, opts ...grpc.CallOption) (*CheckMacPermResponse, error) {\n\tout := new(CheckMacPermResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/CheckMacaroonPermissions\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 172,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) RegisterRPCMiddleware(ctx context.Context, opts ...grpc.CallOption) (Lightning_RegisterRPCMiddlewareClient, error) {",
      "content": "func (c *lightningClient) RegisterRPCMiddleware(ctx context.Context, opts ...grpc.CallOption) (Lightning_RegisterRPCMiddlewareClient, error) {\n\tstream, err := c.cc.NewStream(ctx, &Lightning_ServiceDesc.Streams[11], \"/lnrpc.Lightning/RegisterRPCMiddleware\", opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tx := &lightningRegisterRPCMiddlewareClient{stream}\n\treturn x, nil\n}\n",
      "length": 223,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "type Lightning_RegisterRPCMiddlewareClient interface {",
      "content": "type Lightning_RegisterRPCMiddlewareClient interface {\n\tSend(*RPCMiddlewareResponse) error\n\tRecv() (*RPCMiddlewareRequest, error)\n\tgrpc.ClientStream\n}\n",
      "length": 92,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "type lightningRegisterRPCMiddlewareClient struct {",
      "content": "type lightningRegisterRPCMiddlewareClient struct {\n\tgrpc.ClientStream\n}\n",
      "length": 19,
      "tokens": 2,
      "embedding": []
    },
    {
      "slug": "func (x *lightningRegisterRPCMiddlewareClient) Send(m *RPCMiddlewareResponse) error {",
      "content": "func (x *lightningRegisterRPCMiddlewareClient) Send(m *RPCMiddlewareResponse) error {\n\treturn x.ClientStream.SendMsg(m)\n}\n",
      "length": 34,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (x *lightningRegisterRPCMiddlewareClient) Recv() (*RPCMiddlewareRequest, error) {",
      "content": "func (x *lightningRegisterRPCMiddlewareClient) Recv() (*RPCMiddlewareRequest, error) {\n\tm := new(RPCMiddlewareRequest)\n\tif err := x.ClientStream.RecvMsg(m); err != nil {\n\t\treturn nil, err\n\t}\n\treturn m, nil\n}\n",
      "length": 115,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) SendCustomMessage(ctx context.Context, in *SendCustomMessageRequest, opts ...grpc.CallOption) (*SendCustomMessageResponse, error) {",
      "content": "func (c *lightningClient) SendCustomMessage(ctx context.Context, in *SendCustomMessageRequest, opts ...grpc.CallOption) (*SendCustomMessageResponse, error) {\n\tout := new(SendCustomMessageResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/SendCustomMessage\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 170,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) SubscribeCustomMessages(ctx context.Context, in *SubscribeCustomMessagesRequest, opts ...grpc.CallOption) (Lightning_SubscribeCustomMessagesClient, error) {",
      "content": "func (c *lightningClient) SubscribeCustomMessages(ctx context.Context, in *SubscribeCustomMessagesRequest, opts ...grpc.CallOption) (Lightning_SubscribeCustomMessagesClient, error) {\n\tstream, err := c.cc.NewStream(ctx, &Lightning_ServiceDesc.Streams[12], \"/lnrpc.Lightning/SubscribeCustomMessages\", opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tx := &lightningSubscribeCustomMessagesClient{stream}\n\tif err := x.ClientStream.SendMsg(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := x.ClientStream.CloseSend(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn x, nil\n}\n",
      "length": 367,
      "tokens": 47,
      "embedding": []
    },
    {
      "slug": "type Lightning_SubscribeCustomMessagesClient interface {",
      "content": "type Lightning_SubscribeCustomMessagesClient interface {\n\tRecv() (*CustomMessage, error)\n\tgrpc.ClientStream\n}\n",
      "length": 50,
      "tokens": 5,
      "embedding": []
    },
    {
      "slug": "type lightningSubscribeCustomMessagesClient struct {",
      "content": "type lightningSubscribeCustomMessagesClient struct {\n\tgrpc.ClientStream\n}\n",
      "length": 19,
      "tokens": 2,
      "embedding": []
    },
    {
      "slug": "func (x *lightningSubscribeCustomMessagesClient) Recv() (*CustomMessage, error) {",
      "content": "func (x *lightningSubscribeCustomMessagesClient) Recv() (*CustomMessage, error) {\n\tm := new(CustomMessage)\n\tif err := x.ClientStream.RecvMsg(m); err != nil {\n\t\treturn nil, err\n\t}\n\treturn m, nil\n}\n",
      "length": 108,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) ListAliases(ctx context.Context, in *ListAliasesRequest, opts ...grpc.CallOption) (*ListAliasesResponse, error) {",
      "content": "func (c *lightningClient) ListAliases(ctx context.Context, in *ListAliasesRequest, opts ...grpc.CallOption) (*ListAliasesResponse, error) {\n\tout := new(ListAliasesResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/ListAliases\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n",
      "length": 158,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *lightningClient) LookupHtlcResolution(ctx context.Context, in *LookupHtlcResolutionRequest, opts ...grpc.CallOption) (*LookupHtlcResolutionResponse, error) {",
      "content": "func (c *lightningClient) LookupHtlcResolution(ctx context.Context, in *LookupHtlcResolutionRequest, opts ...grpc.CallOption) (*LookupHtlcResolutionResponse, error) {\n\tout := new(LookupHtlcResolutionResponse)\n\terr := c.cc.Invoke(ctx, \"/lnrpc.Lightning/LookupHtlcResolution\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n\n// LightningServer is the server API for Lightning service.\n// All implementations must embed UnimplementedLightningServer\n// for forward compatibility",
      "length": 325,
      "tokens": 42,
      "embedding": []
    },
    {
      "slug": "type LightningServer interface {",
      "content": "type LightningServer interface {\n\t// lncli: `walletbalance`\n\t// WalletBalance returns total unspent outputs(confirmed and unconfirmed), all\n\t// confirmed unspent outputs and all unconfirmed unspent outputs under control\n\t// of the wallet.\n\tWalletBalance(context.Context, *WalletBalanceRequest) (*WalletBalanceResponse, error)\n\t// lncli: `channelbalance`\n\t// ChannelBalance returns a report on the total funds across all open channels,\n\t// categorized in local/remote, pending local/remote and unsettled local/remote\n\t// balances.\n\tChannelBalance(context.Context, *ChannelBalanceRequest) (*ChannelBalanceResponse, error)\n\t// lncli: `listchaintxns`\n\t// GetTransactions returns a list describing all the known transactions\n\t// relevant to the wallet.\n\tGetTransactions(context.Context, *GetTransactionsRequest) (*TransactionDetails, error)\n\t// lncli: `estimatefee`\n\t// EstimateFee asks the chain backend to estimate the fee rate and total fees\n\t// for a transaction that pays to multiple specified outputs.\n\t//\n\t// When using REST, the `AddrToAmount` map type can be set by appending\n\t// `&AddrToAmount[<address>]=<amount_to_send>` to the URL. Unfortunately this\n\t// map type doesn't appear in the REST API documentation because of a bug in\n\t// the grpc-gateway library.\n\tEstimateFee(context.Context, *EstimateFeeRequest) (*EstimateFeeResponse, error)\n\t// lncli: `sendcoins`\n\t// SendCoins executes a request to send coins to a particular address. Unlike\n\t// SendMany, this RPC call only allows creating a single output at a time. If\n\t// neither target_conf, or sat_per_vbyte are set, then the internal wallet will\n\t// consult its fee model to determine a fee for the default confirmation\n\t// target.\n\tSendCoins(context.Context, *SendCoinsRequest) (*SendCoinsResponse, error)\n\t// lncli: `listunspent`\n\t// Deprecated, use walletrpc.ListUnspent instead.\n\t//\n\t// ListUnspent returns a list of all utxos spendable by the wallet with a\n\t// number of confirmations between the specified minimum and maximum.\n\tListUnspent(context.Context, *ListUnspentRequest) (*ListUnspentResponse, error)\n\t// SubscribeTransactions creates a uni-directional stream from the server to\n\t// the client in which any newly discovered transactions relevant to the\n\t// wallet are sent over.\n\tSubscribeTransactions(*GetTransactionsRequest, Lightning_SubscribeTransactionsServer) error\n\t// lncli: `sendmany`\n\t// SendMany handles a request for a transaction that creates multiple specified\n\t// outputs in parallel. If neither target_conf, or sat_per_vbyte are set, then\n\t// the internal wallet will consult its fee model to determine a fee for the\n\t// default confirmation target.\n\tSendMany(context.Context, *SendManyRequest) (*SendManyResponse, error)\n\t// lncli: `newaddress`\n\t// NewAddress creates a new address under control of the local wallet.\n\tNewAddress(context.Context, *NewAddressRequest) (*NewAddressResponse, error)\n\t// lncli: `signmessage`\n\t// SignMessage signs a message with this node's private key. The returned\n\t// signature string is `zbase32` encoded and pubkey recoverable, meaning that\n\t// only the message digest and signature are needed for verification.\n\tSignMessage(context.Context, *SignMessageRequest) (*SignMessageResponse, error)\n\t// lncli: `verifymessage`\n\t// VerifyMessage verifies a signature over a msg. The signature must be\n\t// zbase32 encoded and signed by an active node in the resident node's\n\t// channel database. In addition to returning the validity of the signature,\n\t// VerifyMessage also returns the recovered pubkey from the signature.\n\tVerifyMessage(context.Context, *VerifyMessageRequest) (*VerifyMessageResponse, error)\n\t// lncli: `connect`\n\t// ConnectPeer attempts to establish a connection to a remote peer. This is at\n\t// the networking level, and is used for communication between nodes. This is\n\t// distinct from establishing a channel with a peer.\n\tConnectPeer(context.Context, *ConnectPeerRequest) (*ConnectPeerResponse, error)\n\t// lncli: `disconnect`\n\t// DisconnectPeer attempts to disconnect one peer from another identified by a\n\t// given pubKey. In the case that we currently have a pending or active channel\n\t// with the target peer, then this action will be not be allowed.\n\tDisconnectPeer(context.Context, *DisconnectPeerRequest) (*DisconnectPeerResponse, error)\n\t// lncli: `listpeers`\n\t// ListPeers returns a verbose listing of all currently active peers.\n\tListPeers(context.Context, *ListPeersRequest) (*ListPeersResponse, error)\n\t// SubscribePeerEvents creates a uni-directional stream from the server to\n\t// the client in which any events relevant to the state of peers are sent\n\t// over. Events include peers going online and offline.\n\tSubscribePeerEvents(*PeerEventSubscription, Lightning_SubscribePeerEventsServer) error\n\t// lncli: `getinfo`\n\t// GetInfo returns general information concerning the lightning node including\n\t// it's identity pubkey, alias, the chains it is connected to, and information\n\t// concerning the number of open+pending channels.\n\tGetInfo(context.Context, *GetInfoRequest) (*GetInfoResponse, error)\n\t// * lncli: `getrecoveryinfo`\n\t// GetRecoveryInfo returns information concerning the recovery mode including\n\t// whether it's in a recovery mode, whether the recovery is finished, and the\n\t// progress made so far.\n\tGetRecoveryInfo(context.Context, *GetRecoveryInfoRequest) (*GetRecoveryInfoResponse, error)\n\t// lncli: `pendingchannels`\n\t// PendingChannels returns a list of all the channels that are currently\n\t// considered \"pending\". A channel is pending if it has finished the funding\n\t// workflow and is waiting for confirmations for the funding txn, or is in the\n\t// process of closure, either initiated cooperatively or non-cooperatively.\n\tPendingChannels(context.Context, *PendingChannelsRequest) (*PendingChannelsResponse, error)\n\t// lncli: `listchannels`\n\t// ListChannels returns a description of all the open channels that this node\n\t// is a participant in.\n\tListChannels(context.Context, *ListChannelsRequest) (*ListChannelsResponse, error)\n\t// SubscribeChannelEvents creates a uni-directional stream from the server to\n\t// the client in which any updates relevant to the state of the channels are\n\t// sent over. Events include new active channels, inactive channels, and closed\n\t// channels.\n\tSubscribeChannelEvents(*ChannelEventSubscription, Lightning_SubscribeChannelEventsServer) error\n\t// lncli: `closedchannels`\n\t// ClosedChannels returns a description of all the closed channels that\n\t// this node was a participant in.\n\tClosedChannels(context.Context, *ClosedChannelsRequest) (*ClosedChannelsResponse, error)\n\t// OpenChannelSync is a synchronous version of the OpenChannel RPC call. This\n\t// call is meant to be consumed by clients to the REST proxy. As with all\n\t// other sync calls, all byte slices are intended to be populated as hex\n\t// encoded strings.\n\tOpenChannelSync(context.Context, *OpenChannelRequest) (*ChannelPoint, error)\n\t// lncli: `openchannel`\n\t// OpenChannel attempts to open a singly funded channel specified in the\n\t// request to a remote peer. Users are able to specify a target number of\n\t// blocks that the funding transaction should be confirmed in, or a manual fee\n\t// rate to us for the funding transaction. If neither are specified, then a\n\t// lax block confirmation target is used. Each OpenStatusUpdate will return\n\t// the pending channel ID of the in-progress channel. Depending on the\n\t// arguments specified in the OpenChannelRequest, this pending channel ID can\n\t// then be used to manually progress the channel funding flow.\n\tOpenChannel(*OpenChannelRequest, Lightning_OpenChannelServer) error\n\t// lncli: `batchopenchannel`\n\t// BatchOpenChannel attempts to open multiple single-funded channels in a\n\t// single transaction in an atomic way. This means either all channel open\n\t// requests succeed at once or all attempts are aborted if any of them fail.\n\t// This is the safer variant of using PSBTs to manually fund a batch of\n\t// channels through the OpenChannel RPC.\n\tBatchOpenChannel(context.Context, *BatchOpenChannelRequest) (*BatchOpenChannelResponse, error)\n\t// FundingStateStep is an advanced funding related call that allows the caller\n\t// to either execute some preparatory steps for a funding workflow, or\n\t// manually progress a funding workflow. The primary way a funding flow is\n\t// identified is via its pending channel ID. As an example, this method can be\n\t// used to specify that we're expecting a funding flow for a particular\n\t// pending channel ID, for which we need to use specific parameters.\n\t// Alternatively, this can be used to interactively drive PSBT signing for\n\t// funding for partially complete funding transactions.\n\tFundingStateStep(context.Context, *FundingTransitionMsg) (*FundingStateStepResp, error)\n\t// ChannelAcceptor dispatches a bi-directional streaming RPC in which\n\t// OpenChannel requests are sent to the client and the client responds with\n\t// a boolean that tells LND whether or not to accept the channel. This allows\n\t// node operators to specify their own criteria for accepting inbound channels\n\t// through a single persistent connection.\n\tChannelAcceptor(Lightning_ChannelAcceptorServer) error\n\t// lncli: `closechannel`\n\t// CloseChannel attempts to close an active channel identified by its channel\n\t// outpoint (ChannelPoint). The actions of this method can additionally be\n\t// augmented to attempt a force close after a timeout period in the case of an\n\t// inactive peer. If a non-force close (cooperative closure) is requested,\n\t// then the user can specify either a target number of blocks until the\n\t// closure transaction is confirmed, or a manual fee rate. If neither are\n\t// specified, then a default lax, block confirmation target is used.\n\tCloseChannel(*CloseChannelRequest, Lightning_CloseChannelServer) error\n\t// lncli: `abandonchannel`\n\t// AbandonChannel removes all channel state from the database except for a\n\t// close summary. This method can be used to get rid of permanently unusable\n\t// channels due to bugs fixed in newer versions of lnd. This method can also be\n\t// used to remove externally funded channels where the funding transaction was\n\t// never broadcast. Only available for non-externally funded channels in dev\n\t// build.\n\tAbandonChannel(context.Context, *AbandonChannelRequest) (*AbandonChannelResponse, error)\n\t// Deprecated: Do not use.\n\t// lncli: `sendpayment`\n\t// Deprecated, use routerrpc.SendPaymentV2. SendPayment dispatches a\n\t// bi-directional streaming RPC for sending payments through the Lightning\n\t// Network. A single RPC invocation creates a persistent bi-directional\n\t// stream allowing clients to rapidly send payments through the Lightning\n\t// Network with a single persistent connection.\n\tSendPayment(Lightning_SendPaymentServer) error\n\t// SendPaymentSync is the synchronous non-streaming version of SendPayment.\n\t// This RPC is intended to be consumed by clients of the REST proxy.\n\t// Additionally, this RPC expects the destination's public key and the payment\n\t// hash (if any) to be encoded as hex strings.\n\tSendPaymentSync(context.Context, *SendRequest) (*SendResponse, error)\n\t// Deprecated: Do not use.\n\t// lncli: `sendtoroute`\n\t// Deprecated, use routerrpc.SendToRouteV2. SendToRoute is a bi-directional\n\t// streaming RPC for sending payment through the Lightning Network. This\n\t// method differs from SendPayment in that it allows users to specify a full\n\t// route manually. This can be used for things like rebalancing, and atomic\n\t// swaps.\n\tSendToRoute(Lightning_SendToRouteServer) error\n\t// SendToRouteSync is a synchronous version of SendToRoute. It Will block\n\t// until the payment either fails or succeeds.\n\tSendToRouteSync(context.Context, *SendToRouteRequest) (*SendResponse, error)\n\t// lncli: `addinvoice`\n\t// AddInvoice attempts to add a new invoice to the invoice database. Any\n\t// duplicated invoices are rejected, therefore all invoices *must* have a\n\t// unique payment preimage.\n\tAddInvoice(context.Context, *Invoice) (*AddInvoiceResponse, error)\n\t// lncli: `listinvoices`\n\t// ListInvoices returns a list of all the invoices currently stored within the\n\t// database. Any active debug invoices are ignored. It has full support for\n\t// paginated responses, allowing users to query for specific invoices through\n\t// their add_index. This can be done by using either the first_index_offset or\n\t// last_index_offset fields included in the response as the index_offset of the\n\t// next request. By default, the first 100 invoices created will be returned.\n\t// Backwards pagination is also supported through the Reversed flag.\n\tListInvoices(context.Context, *ListInvoiceRequest) (*ListInvoiceResponse, error)\n\t// lncli: `lookupinvoice`\n\t// LookupInvoice attempts to look up an invoice according to its payment hash.\n\t// The passed payment hash *must* be exactly 32 bytes, if not, an error is\n\t// returned.\n\tLookupInvoice(context.Context, *PaymentHash) (*Invoice, error)\n\t// SubscribeInvoices returns a uni-directional stream (server -> client) for\n\t// notifying the client of newly added/settled invoices. The caller can\n\t// optionally specify the add_index and/or the settle_index. If the add_index\n\t// is specified, then we'll first start by sending add invoice events for all\n\t// invoices with an add_index greater than the specified value. If the\n\t// settle_index is specified, the next, we'll send out all settle events for\n\t// invoices with a settle_index greater than the specified value. One or both\n\t// of these fields can be set. If no fields are set, then we'll only send out\n\t// the latest add/settle events.\n\tSubscribeInvoices(*InvoiceSubscription, Lightning_SubscribeInvoicesServer) error\n\t// lncli: `decodepayreq`\n\t// DecodePayReq takes an encoded payment request string and attempts to decode\n\t// it, returning a full description of the conditions encoded within the\n\t// payment request.\n\tDecodePayReq(context.Context, *PayReqString) (*PayReq, error)\n\t// lncli: `listpayments`\n\t// ListPayments returns a list of all outgoing payments.\n\tListPayments(context.Context, *ListPaymentsRequest) (*ListPaymentsResponse, error)\n\t// DeletePayment deletes an outgoing payment from DB. Note that it will not\n\t// attempt to delete an In-Flight payment, since that would be unsafe.\n\tDeletePayment(context.Context, *DeletePaymentRequest) (*DeletePaymentResponse, error)\n\t// DeleteAllPayments deletes all outgoing payments from DB. Note that it will\n\t// not attempt to delete In-Flight payments, since that would be unsafe.\n\tDeleteAllPayments(context.Context, *DeleteAllPaymentsRequest) (*DeleteAllPaymentsResponse, error)\n\t// lncli: `describegraph`\n\t// DescribeGraph returns a description of the latest graph state from the\n\t// point of view of the node. The graph information is partitioned into two\n\t// components: all the nodes/vertexes, and all the edges that connect the\n\t// vertexes themselves. As this is a directed graph, the edges also contain\n\t// the node directional specific routing policy which includes: the time lock\n\t// delta, fee information, etc.\n\tDescribeGraph(context.Context, *ChannelGraphRequest) (*ChannelGraph, error)\n\t// lncli: `getnodemetrics`\n\t// GetNodeMetrics returns node metrics calculated from the graph. Currently\n\t// the only supported metric is betweenness centrality of individual nodes.\n\tGetNodeMetrics(context.Context, *NodeMetricsRequest) (*NodeMetricsResponse, error)\n\t// lncli: `getchaninfo`\n\t// GetChanInfo returns the latest authenticated network announcement for the\n\t// given channel identified by its channel ID: an 8-byte integer which\n\t// uniquely identifies the location of transaction's funding output within the\n\t// blockchain.\n\tGetChanInfo(context.Context, *ChanInfoRequest) (*ChannelEdge, error)\n\t// lncli: `getnodeinfo`\n\t// GetNodeInfo returns the latest advertised, aggregated, and authenticated\n\t// channel information for the specified node identified by its public key.\n\tGetNodeInfo(context.Context, *NodeInfoRequest) (*NodeInfo, error)\n\t// lncli: `queryroutes`\n\t// QueryRoutes attempts to query the daemon's Channel Router for a possible\n\t// route to a target destination capable of carrying a specific amount of\n\t// satoshis. The returned route contains the full details required to craft and\n\t// send an HTLC, also including the necessary information that should be\n\t// present within the Sphinx packet encapsulated within the HTLC.\n\t//\n\t// When using REST, the `dest_custom_records` map type can be set by appending\n\t// `&dest_custom_records[<record_number>]=<record_data_base64_url_encoded>`\n\t// to the URL. Unfortunately this map type doesn't appear in the REST API\n\t// documentation because of a bug in the grpc-gateway library.\n\tQueryRoutes(context.Context, *QueryRoutesRequest) (*QueryRoutesResponse, error)\n\t// lncli: `getnetworkinfo`\n\t// GetNetworkInfo returns some basic stats about the known channel graph from\n\t// the point of view of the node.\n\tGetNetworkInfo(context.Context, *NetworkInfoRequest) (*NetworkInfo, error)\n\t// lncli: `stop`\n\t// StopDaemon will send a shutdown request to the interrupt handler, triggering\n\t// a graceful shutdown of the daemon.\n\tStopDaemon(context.Context, *StopRequest) (*StopResponse, error)\n\t// SubscribeChannelGraph launches a streaming RPC that allows the caller to\n\t// receive notifications upon any changes to the channel graph topology from\n\t// the point of view of the responding node. Events notified include: new\n\t// nodes coming online, nodes updating their authenticated attributes, new\n\t// channels being advertised, updates in the routing policy for a directional\n\t// channel edge, and when channels are closed on-chain.\n\tSubscribeChannelGraph(*GraphTopologySubscription, Lightning_SubscribeChannelGraphServer) error\n\t// lncli: `debuglevel`\n\t// DebugLevel allows a caller to programmatically set the logging verbosity of\n\t// lnd. The logging can be targeted according to a coarse daemon-wide logging\n\t// level, or in a granular fashion to specify the logging for a target\n\t// sub-system.\n\tDebugLevel(context.Context, *DebugLevelRequest) (*DebugLevelResponse, error)\n\t// lncli: `feereport`\n\t// FeeReport allows the caller to obtain a report detailing the current fee\n\t// schedule enforced by the node globally for each channel.\n\tFeeReport(context.Context, *FeeReportRequest) (*FeeReportResponse, error)\n\t// lncli: `updatechanpolicy`\n\t// UpdateChannelPolicy allows the caller to update the fee schedule and\n\t// channel policies for all channels globally, or a particular channel.\n\tUpdateChannelPolicy(context.Context, *PolicyUpdateRequest) (*PolicyUpdateResponse, error)\n\t// lncli: `fwdinghistory`\n\t// ForwardingHistory allows the caller to query the htlcswitch for a record of\n\t// all HTLCs forwarded within the target time range, and integer offset\n\t// within that time range, for a maximum number of events. If no maximum number\n\t// of events is specified, up to 100 events will be returned. If no time-range\n\t// is specified, then events will be returned in the order that they occured.\n\t//\n\t// A list of forwarding events are returned. The size of each forwarding event\n\t// is 40 bytes, and the max message size able to be returned in gRPC is 4 MiB.\n\t// As a result each message can only contain 50k entries. Each response has\n\t// the index offset of the last entry. The index offset can be provided to the\n\t// request to allow the caller to skip a series of records.\n\tForwardingHistory(context.Context, *ForwardingHistoryRequest) (*ForwardingHistoryResponse, error)\n\t// lncli: `exportchanbackup`\n\t// ExportChannelBackup attempts to return an encrypted static channel backup\n\t// for the target channel identified by it channel point. The backup is\n\t// encrypted with a key generated from the aezeed seed of the user. The\n\t// returned backup can either be restored using the RestoreChannelBackup\n\t// method once lnd is running, or via the InitWallet and UnlockWallet methods\n\t// from the WalletUnlocker service.\n\tExportChannelBackup(context.Context, *ExportChannelBackupRequest) (*ChannelBackup, error)\n\t// ExportAllChannelBackups returns static channel backups for all existing\n\t// channels known to lnd. A set of regular singular static channel backups for\n\t// each channel are returned. Additionally, a multi-channel backup is returned\n\t// as well, which contains a single encrypted blob containing the backups of\n\t// each channel.\n\tExportAllChannelBackups(context.Context, *ChanBackupExportRequest) (*ChanBackupSnapshot, error)\n\t// VerifyChanBackup allows a caller to verify the integrity of a channel backup\n\t// snapshot. This method will accept either a packed Single or a packed Multi.\n\t// Specifying both will result in an error.\n\tVerifyChanBackup(context.Context, *ChanBackupSnapshot) (*VerifyChanBackupResponse, error)\n\t// lncli: `restorechanbackup`\n\t// RestoreChannelBackups accepts a set of singular channel backups, or a\n\t// single encrypted multi-chan backup and attempts to recover any funds\n\t// remaining within the channel. If we are able to unpack the backup, then the\n\t// new channel will be shown under listchannels, as well as pending channels.\n\tRestoreChannelBackups(context.Context, *RestoreChanBackupRequest) (*RestoreBackupResponse, error)\n\t// SubscribeChannelBackups allows a client to sub-subscribe to the most up to\n\t// date information concerning the state of all channel backups. Each time a\n\t// new channel is added, we return the new set of channels, along with a\n\t// multi-chan backup containing the backup info for all channels. Each time a\n\t// channel is closed, we send a new update, which contains new new chan back\n\t// ups, but the updated set of encrypted multi-chan backups with the closed\n\t// channel(s) removed.\n\tSubscribeChannelBackups(*ChannelBackupSubscription, Lightning_SubscribeChannelBackupsServer) error\n\t// lncli: `bakemacaroon`\n\t// BakeMacaroon allows the creation of a new macaroon with custom read and\n\t// write permissions. No first-party caveats are added since this can be done\n\t// offline.\n\tBakeMacaroon(context.Context, *BakeMacaroonRequest) (*BakeMacaroonResponse, error)\n\t// lncli: `listmacaroonids`\n\t// ListMacaroonIDs returns all root key IDs that are in use.\n\tListMacaroonIDs(context.Context, *ListMacaroonIDsRequest) (*ListMacaroonIDsResponse, error)\n\t// lncli: `deletemacaroonid`\n\t// DeleteMacaroonID deletes the specified macaroon ID and invalidates all\n\t// macaroons derived from that ID.\n\tDeleteMacaroonID(context.Context, *DeleteMacaroonIDRequest) (*DeleteMacaroonIDResponse, error)\n\t// lncli: `listpermissions`\n\t// ListPermissions lists all RPC method URIs and their required macaroon\n\t// permissions to access them.\n\tListPermissions(context.Context, *ListPermissionsRequest) (*ListPermissionsResponse, error)\n\t// CheckMacaroonPermissions checks whether a request follows the constraints\n\t// imposed on the macaroon and that the macaroon is authorized to follow the\n\t// provided permissions.\n\tCheckMacaroonPermissions(context.Context, *CheckMacPermRequest) (*CheckMacPermResponse, error)\n\t// RegisterRPCMiddleware adds a new gRPC middleware to the interceptor chain. A\n\t// gRPC middleware is software component external to lnd that aims to add\n\t// additional business logic to lnd by observing/intercepting/validating\n\t// incoming gRPC client requests and (if needed) replacing/overwriting outgoing\n\t// messages before they're sent to the client. When registering the middleware\n\t// must identify itself and indicate what custom macaroon caveats it wants to\n\t// be responsible for. Only requests that contain a macaroon with that specific\n\t// custom caveat are then sent to the middleware for inspection. The other\n\t// option is to register for the read-only mode in which all requests/responses\n\t// are forwarded for interception to the middleware but the middleware is not\n\t// allowed to modify any responses. As a security measure, _no_ middleware can\n\t// modify responses for requests made with _unencumbered_ macaroons!\n\tRegisterRPCMiddleware(Lightning_RegisterRPCMiddlewareServer) error\n\t// lncli: `sendcustom`\n\t// SendCustomMessage sends a custom peer message.\n\tSendCustomMessage(context.Context, *SendCustomMessageRequest) (*SendCustomMessageResponse, error)\n\t// lncli: `subscribecustom`\n\t// SubscribeCustomMessages subscribes to a stream of incoming custom peer\n\t// messages.\n\t//\n\t// To include messages with type outside of the custom range (>= 32768) lnd\n\t// needs to be compiled with  the `dev` build tag, and the message type to\n\t// override should be specified in lnd's experimental protocol configuration.\n\tSubscribeCustomMessages(*SubscribeCustomMessagesRequest, Lightning_SubscribeCustomMessagesServer) error\n\t// lncli: `listaliases`\n\t// ListAliases returns the set of all aliases that have ever existed with\n\t// their confirmed SCID (if it exists) and/or the base SCID (in the case of\n\t// zero conf).\n\tListAliases(context.Context, *ListAliasesRequest) (*ListAliasesResponse, error)\n\t// LookupHtlcResolution retrieves a final htlc resolution from the database.\n\t// If the htlc has no final resolution yet, a NotFound grpc status code is\n\t// returned.\n\tLookupHtlcResolution(context.Context, *LookupHtlcResolutionRequest) (*LookupHtlcResolutionResponse, error)\n\tmustEmbedUnimplementedLightningServer()\n}\n\n// UnimplementedLightningServer must be embedded to have forward compatible implementations.",
      "length": 24804,
      "tokens": 3321,
      "embedding": []
    },
    {
      "slug": "type UnimplementedLightningServer struct {",
      "content": "type UnimplementedLightningServer struct {\n}\n",
      "length": 1,
      "tokens": 1,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) WalletBalance(context.Context, *WalletBalanceRequest) (*WalletBalanceResponse, error) {",
      "content": "func (UnimplementedLightningServer) WalletBalance(context.Context, *WalletBalanceRequest) (*WalletBalanceResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method WalletBalance not implemented\")\n}",
      "length": 88,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) ChannelBalance(context.Context, *ChannelBalanceRequest) (*ChannelBalanceResponse, error) {",
      "content": "func (UnimplementedLightningServer) ChannelBalance(context.Context, *ChannelBalanceRequest) (*ChannelBalanceResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method ChannelBalance not implemented\")\n}",
      "length": 89,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) GetTransactions(context.Context, *GetTransactionsRequest) (*TransactionDetails, error) {",
      "content": "func (UnimplementedLightningServer) GetTransactions(context.Context, *GetTransactionsRequest) (*TransactionDetails, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method GetTransactions not implemented\")\n}",
      "length": 90,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) EstimateFee(context.Context, *EstimateFeeRequest) (*EstimateFeeResponse, error) {",
      "content": "func (UnimplementedLightningServer) EstimateFee(context.Context, *EstimateFeeRequest) (*EstimateFeeResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method EstimateFee not implemented\")\n}",
      "length": 86,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) SendCoins(context.Context, *SendCoinsRequest) (*SendCoinsResponse, error) {",
      "content": "func (UnimplementedLightningServer) SendCoins(context.Context, *SendCoinsRequest) (*SendCoinsResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method SendCoins not implemented\")\n}",
      "length": 84,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) ListUnspent(context.Context, *ListUnspentRequest) (*ListUnspentResponse, error) {",
      "content": "func (UnimplementedLightningServer) ListUnspent(context.Context, *ListUnspentRequest) (*ListUnspentResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method ListUnspent not implemented\")\n}",
      "length": 86,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) SubscribeTransactions(*GetTransactionsRequest, Lightning_SubscribeTransactionsServer) error {",
      "content": "func (UnimplementedLightningServer) SubscribeTransactions(*GetTransactionsRequest, Lightning_SubscribeTransactionsServer) error {\n\treturn status.Errorf(codes.Unimplemented, \"method SubscribeTransactions not implemented\")\n}",
      "length": 91,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) SendMany(context.Context, *SendManyRequest) (*SendManyResponse, error) {",
      "content": "func (UnimplementedLightningServer) SendMany(context.Context, *SendManyRequest) (*SendManyResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method SendMany not implemented\")\n}",
      "length": 83,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) NewAddress(context.Context, *NewAddressRequest) (*NewAddressResponse, error) {",
      "content": "func (UnimplementedLightningServer) NewAddress(context.Context, *NewAddressRequest) (*NewAddressResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method NewAddress not implemented\")\n}",
      "length": 85,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) SignMessage(context.Context, *SignMessageRequest) (*SignMessageResponse, error) {",
      "content": "func (UnimplementedLightningServer) SignMessage(context.Context, *SignMessageRequest) (*SignMessageResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method SignMessage not implemented\")\n}",
      "length": 86,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) VerifyMessage(context.Context, *VerifyMessageRequest) (*VerifyMessageResponse, error) {",
      "content": "func (UnimplementedLightningServer) VerifyMessage(context.Context, *VerifyMessageRequest) (*VerifyMessageResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method VerifyMessage not implemented\")\n}",
      "length": 88,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) ConnectPeer(context.Context, *ConnectPeerRequest) (*ConnectPeerResponse, error) {",
      "content": "func (UnimplementedLightningServer) ConnectPeer(context.Context, *ConnectPeerRequest) (*ConnectPeerResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method ConnectPeer not implemented\")\n}",
      "length": 86,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) DisconnectPeer(context.Context, *DisconnectPeerRequest) (*DisconnectPeerResponse, error) {",
      "content": "func (UnimplementedLightningServer) DisconnectPeer(context.Context, *DisconnectPeerRequest) (*DisconnectPeerResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method DisconnectPeer not implemented\")\n}",
      "length": 89,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) ListPeers(context.Context, *ListPeersRequest) (*ListPeersResponse, error) {",
      "content": "func (UnimplementedLightningServer) ListPeers(context.Context, *ListPeersRequest) (*ListPeersResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method ListPeers not implemented\")\n}",
      "length": 84,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) SubscribePeerEvents(*PeerEventSubscription, Lightning_SubscribePeerEventsServer) error {",
      "content": "func (UnimplementedLightningServer) SubscribePeerEvents(*PeerEventSubscription, Lightning_SubscribePeerEventsServer) error {\n\treturn status.Errorf(codes.Unimplemented, \"method SubscribePeerEvents not implemented\")\n}",
      "length": 89,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) GetInfo(context.Context, *GetInfoRequest) (*GetInfoResponse, error) {",
      "content": "func (UnimplementedLightningServer) GetInfo(context.Context, *GetInfoRequest) (*GetInfoResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method GetInfo not implemented\")\n}",
      "length": 82,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) GetRecoveryInfo(context.Context, *GetRecoveryInfoRequest) (*GetRecoveryInfoResponse, error) {",
      "content": "func (UnimplementedLightningServer) GetRecoveryInfo(context.Context, *GetRecoveryInfoRequest) (*GetRecoveryInfoResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method GetRecoveryInfo not implemented\")\n}",
      "length": 90,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) PendingChannels(context.Context, *PendingChannelsRequest) (*PendingChannelsResponse, error) {",
      "content": "func (UnimplementedLightningServer) PendingChannels(context.Context, *PendingChannelsRequest) (*PendingChannelsResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method PendingChannels not implemented\")\n}",
      "length": 90,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) ListChannels(context.Context, *ListChannelsRequest) (*ListChannelsResponse, error) {",
      "content": "func (UnimplementedLightningServer) ListChannels(context.Context, *ListChannelsRequest) (*ListChannelsResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method ListChannels not implemented\")\n}",
      "length": 87,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) SubscribeChannelEvents(*ChannelEventSubscription, Lightning_SubscribeChannelEventsServer) error {",
      "content": "func (UnimplementedLightningServer) SubscribeChannelEvents(*ChannelEventSubscription, Lightning_SubscribeChannelEventsServer) error {\n\treturn status.Errorf(codes.Unimplemented, \"method SubscribeChannelEvents not implemented\")\n}",
      "length": 92,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) ClosedChannels(context.Context, *ClosedChannelsRequest) (*ClosedChannelsResponse, error) {",
      "content": "func (UnimplementedLightningServer) ClosedChannels(context.Context, *ClosedChannelsRequest) (*ClosedChannelsResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method ClosedChannels not implemented\")\n}",
      "length": 89,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) OpenChannelSync(context.Context, *OpenChannelRequest) (*ChannelPoint, error) {",
      "content": "func (UnimplementedLightningServer) OpenChannelSync(context.Context, *OpenChannelRequest) (*ChannelPoint, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method OpenChannelSync not implemented\")\n}",
      "length": 90,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) OpenChannel(*OpenChannelRequest, Lightning_OpenChannelServer) error {",
      "content": "func (UnimplementedLightningServer) OpenChannel(*OpenChannelRequest, Lightning_OpenChannelServer) error {\n\treturn status.Errorf(codes.Unimplemented, \"method OpenChannel not implemented\")\n}",
      "length": 81,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) BatchOpenChannel(context.Context, *BatchOpenChannelRequest) (*BatchOpenChannelResponse, error) {",
      "content": "func (UnimplementedLightningServer) BatchOpenChannel(context.Context, *BatchOpenChannelRequest) (*BatchOpenChannelResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method BatchOpenChannel not implemented\")\n}",
      "length": 91,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) FundingStateStep(context.Context, *FundingTransitionMsg) (*FundingStateStepResp, error) {",
      "content": "func (UnimplementedLightningServer) FundingStateStep(context.Context, *FundingTransitionMsg) (*FundingStateStepResp, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method FundingStateStep not implemented\")\n}",
      "length": 91,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) ChannelAcceptor(Lightning_ChannelAcceptorServer) error {",
      "content": "func (UnimplementedLightningServer) ChannelAcceptor(Lightning_ChannelAcceptorServer) error {\n\treturn status.Errorf(codes.Unimplemented, \"method ChannelAcceptor not implemented\")\n}",
      "length": 85,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) CloseChannel(*CloseChannelRequest, Lightning_CloseChannelServer) error {",
      "content": "func (UnimplementedLightningServer) CloseChannel(*CloseChannelRequest, Lightning_CloseChannelServer) error {\n\treturn status.Errorf(codes.Unimplemented, \"method CloseChannel not implemented\")\n}",
      "length": 82,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) AbandonChannel(context.Context, *AbandonChannelRequest) (*AbandonChannelResponse, error) {",
      "content": "func (UnimplementedLightningServer) AbandonChannel(context.Context, *AbandonChannelRequest) (*AbandonChannelResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method AbandonChannel not implemented\")\n}",
      "length": 89,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) SendPayment(Lightning_SendPaymentServer) error {",
      "content": "func (UnimplementedLightningServer) SendPayment(Lightning_SendPaymentServer) error {\n\treturn status.Errorf(codes.Unimplemented, \"method SendPayment not implemented\")\n}",
      "length": 81,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) SendPaymentSync(context.Context, *SendRequest) (*SendResponse, error) {",
      "content": "func (UnimplementedLightningServer) SendPaymentSync(context.Context, *SendRequest) (*SendResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method SendPaymentSync not implemented\")\n}",
      "length": 90,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) SendToRoute(Lightning_SendToRouteServer) error {",
      "content": "func (UnimplementedLightningServer) SendToRoute(Lightning_SendToRouteServer) error {\n\treturn status.Errorf(codes.Unimplemented, \"method SendToRoute not implemented\")\n}",
      "length": 81,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) SendToRouteSync(context.Context, *SendToRouteRequest) (*SendResponse, error) {",
      "content": "func (UnimplementedLightningServer) SendToRouteSync(context.Context, *SendToRouteRequest) (*SendResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method SendToRouteSync not implemented\")\n}",
      "length": 90,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) AddInvoice(context.Context, *Invoice) (*AddInvoiceResponse, error) {",
      "content": "func (UnimplementedLightningServer) AddInvoice(context.Context, *Invoice) (*AddInvoiceResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method AddInvoice not implemented\")\n}",
      "length": 85,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) ListInvoices(context.Context, *ListInvoiceRequest) (*ListInvoiceResponse, error) {",
      "content": "func (UnimplementedLightningServer) ListInvoices(context.Context, *ListInvoiceRequest) (*ListInvoiceResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method ListInvoices not implemented\")\n}",
      "length": 87,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) LookupInvoice(context.Context, *PaymentHash) (*Invoice, error) {",
      "content": "func (UnimplementedLightningServer) LookupInvoice(context.Context, *PaymentHash) (*Invoice, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method LookupInvoice not implemented\")\n}",
      "length": 88,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) SubscribeInvoices(*InvoiceSubscription, Lightning_SubscribeInvoicesServer) error {",
      "content": "func (UnimplementedLightningServer) SubscribeInvoices(*InvoiceSubscription, Lightning_SubscribeInvoicesServer) error {\n\treturn status.Errorf(codes.Unimplemented, \"method SubscribeInvoices not implemented\")\n}",
      "length": 87,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) DecodePayReq(context.Context, *PayReqString) (*PayReq, error) {",
      "content": "func (UnimplementedLightningServer) DecodePayReq(context.Context, *PayReqString) (*PayReq, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method DecodePayReq not implemented\")\n}",
      "length": 87,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) ListPayments(context.Context, *ListPaymentsRequest) (*ListPaymentsResponse, error) {",
      "content": "func (UnimplementedLightningServer) ListPayments(context.Context, *ListPaymentsRequest) (*ListPaymentsResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method ListPayments not implemented\")\n}",
      "length": 87,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) DeletePayment(context.Context, *DeletePaymentRequest) (*DeletePaymentResponse, error) {",
      "content": "func (UnimplementedLightningServer) DeletePayment(context.Context, *DeletePaymentRequest) (*DeletePaymentResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method DeletePayment not implemented\")\n}",
      "length": 88,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) DeleteAllPayments(context.Context, *DeleteAllPaymentsRequest) (*DeleteAllPaymentsResponse, error) {",
      "content": "func (UnimplementedLightningServer) DeleteAllPayments(context.Context, *DeleteAllPaymentsRequest) (*DeleteAllPaymentsResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method DeleteAllPayments not implemented\")\n}",
      "length": 92,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) DescribeGraph(context.Context, *ChannelGraphRequest) (*ChannelGraph, error) {",
      "content": "func (UnimplementedLightningServer) DescribeGraph(context.Context, *ChannelGraphRequest) (*ChannelGraph, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method DescribeGraph not implemented\")\n}",
      "length": 88,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) GetNodeMetrics(context.Context, *NodeMetricsRequest) (*NodeMetricsResponse, error) {",
      "content": "func (UnimplementedLightningServer) GetNodeMetrics(context.Context, *NodeMetricsRequest) (*NodeMetricsResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method GetNodeMetrics not implemented\")\n}",
      "length": 89,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) GetChanInfo(context.Context, *ChanInfoRequest) (*ChannelEdge, error) {",
      "content": "func (UnimplementedLightningServer) GetChanInfo(context.Context, *ChanInfoRequest) (*ChannelEdge, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method GetChanInfo not implemented\")\n}",
      "length": 86,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) GetNodeInfo(context.Context, *NodeInfoRequest) (*NodeInfo, error) {",
      "content": "func (UnimplementedLightningServer) GetNodeInfo(context.Context, *NodeInfoRequest) (*NodeInfo, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method GetNodeInfo not implemented\")\n}",
      "length": 86,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) QueryRoutes(context.Context, *QueryRoutesRequest) (*QueryRoutesResponse, error) {",
      "content": "func (UnimplementedLightningServer) QueryRoutes(context.Context, *QueryRoutesRequest) (*QueryRoutesResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method QueryRoutes not implemented\")\n}",
      "length": 86,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) GetNetworkInfo(context.Context, *NetworkInfoRequest) (*NetworkInfo, error) {",
      "content": "func (UnimplementedLightningServer) GetNetworkInfo(context.Context, *NetworkInfoRequest) (*NetworkInfo, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method GetNetworkInfo not implemented\")\n}",
      "length": 89,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) StopDaemon(context.Context, *StopRequest) (*StopResponse, error) {",
      "content": "func (UnimplementedLightningServer) StopDaemon(context.Context, *StopRequest) (*StopResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method StopDaemon not implemented\")\n}",
      "length": 85,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) SubscribeChannelGraph(*GraphTopologySubscription, Lightning_SubscribeChannelGraphServer) error {",
      "content": "func (UnimplementedLightningServer) SubscribeChannelGraph(*GraphTopologySubscription, Lightning_SubscribeChannelGraphServer) error {\n\treturn status.Errorf(codes.Unimplemented, \"method SubscribeChannelGraph not implemented\")\n}",
      "length": 91,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) DebugLevel(context.Context, *DebugLevelRequest) (*DebugLevelResponse, error) {",
      "content": "func (UnimplementedLightningServer) DebugLevel(context.Context, *DebugLevelRequest) (*DebugLevelResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method DebugLevel not implemented\")\n}",
      "length": 85,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) FeeReport(context.Context, *FeeReportRequest) (*FeeReportResponse, error) {",
      "content": "func (UnimplementedLightningServer) FeeReport(context.Context, *FeeReportRequest) (*FeeReportResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method FeeReport not implemented\")\n}",
      "length": 84,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) UpdateChannelPolicy(context.Context, *PolicyUpdateRequest) (*PolicyUpdateResponse, error) {",
      "content": "func (UnimplementedLightningServer) UpdateChannelPolicy(context.Context, *PolicyUpdateRequest) (*PolicyUpdateResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method UpdateChannelPolicy not implemented\")\n}",
      "length": 94,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) ForwardingHistory(context.Context, *ForwardingHistoryRequest) (*ForwardingHistoryResponse, error) {",
      "content": "func (UnimplementedLightningServer) ForwardingHistory(context.Context, *ForwardingHistoryRequest) (*ForwardingHistoryResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method ForwardingHistory not implemented\")\n}",
      "length": 92,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) ExportChannelBackup(context.Context, *ExportChannelBackupRequest) (*ChannelBackup, error) {",
      "content": "func (UnimplementedLightningServer) ExportChannelBackup(context.Context, *ExportChannelBackupRequest) (*ChannelBackup, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method ExportChannelBackup not implemented\")\n}",
      "length": 94,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) ExportAllChannelBackups(context.Context, *ChanBackupExportRequest) (*ChanBackupSnapshot, error) {",
      "content": "func (UnimplementedLightningServer) ExportAllChannelBackups(context.Context, *ChanBackupExportRequest) (*ChanBackupSnapshot, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method ExportAllChannelBackups not implemented\")\n}",
      "length": 98,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) VerifyChanBackup(context.Context, *ChanBackupSnapshot) (*VerifyChanBackupResponse, error) {",
      "content": "func (UnimplementedLightningServer) VerifyChanBackup(context.Context, *ChanBackupSnapshot) (*VerifyChanBackupResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method VerifyChanBackup not implemented\")\n}",
      "length": 91,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) RestoreChannelBackups(context.Context, *RestoreChanBackupRequest) (*RestoreBackupResponse, error) {",
      "content": "func (UnimplementedLightningServer) RestoreChannelBackups(context.Context, *RestoreChanBackupRequest) (*RestoreBackupResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method RestoreChannelBackups not implemented\")\n}",
      "length": 96,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) SubscribeChannelBackups(*ChannelBackupSubscription, Lightning_SubscribeChannelBackupsServer) error {",
      "content": "func (UnimplementedLightningServer) SubscribeChannelBackups(*ChannelBackupSubscription, Lightning_SubscribeChannelBackupsServer) error {\n\treturn status.Errorf(codes.Unimplemented, \"method SubscribeChannelBackups not implemented\")\n}",
      "length": 93,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) BakeMacaroon(context.Context, *BakeMacaroonRequest) (*BakeMacaroonResponse, error) {",
      "content": "func (UnimplementedLightningServer) BakeMacaroon(context.Context, *BakeMacaroonRequest) (*BakeMacaroonResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method BakeMacaroon not implemented\")\n}",
      "length": 87,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) ListMacaroonIDs(context.Context, *ListMacaroonIDsRequest) (*ListMacaroonIDsResponse, error) {",
      "content": "func (UnimplementedLightningServer) ListMacaroonIDs(context.Context, *ListMacaroonIDsRequest) (*ListMacaroonIDsResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method ListMacaroonIDs not implemented\")\n}",
      "length": 90,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) DeleteMacaroonID(context.Context, *DeleteMacaroonIDRequest) (*DeleteMacaroonIDResponse, error) {",
      "content": "func (UnimplementedLightningServer) DeleteMacaroonID(context.Context, *DeleteMacaroonIDRequest) (*DeleteMacaroonIDResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method DeleteMacaroonID not implemented\")\n}",
      "length": 91,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) ListPermissions(context.Context, *ListPermissionsRequest) (*ListPermissionsResponse, error) {",
      "content": "func (UnimplementedLightningServer) ListPermissions(context.Context, *ListPermissionsRequest) (*ListPermissionsResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method ListPermissions not implemented\")\n}",
      "length": 90,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) CheckMacaroonPermissions(context.Context, *CheckMacPermRequest) (*CheckMacPermResponse, error) {",
      "content": "func (UnimplementedLightningServer) CheckMacaroonPermissions(context.Context, *CheckMacPermRequest) (*CheckMacPermResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method CheckMacaroonPermissions not implemented\")\n}",
      "length": 99,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) RegisterRPCMiddleware(Lightning_RegisterRPCMiddlewareServer) error {",
      "content": "func (UnimplementedLightningServer) RegisterRPCMiddleware(Lightning_RegisterRPCMiddlewareServer) error {\n\treturn status.Errorf(codes.Unimplemented, \"method RegisterRPCMiddleware not implemented\")\n}",
      "length": 91,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) SendCustomMessage(context.Context, *SendCustomMessageRequest) (*SendCustomMessageResponse, error) {",
      "content": "func (UnimplementedLightningServer) SendCustomMessage(context.Context, *SendCustomMessageRequest) (*SendCustomMessageResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method SendCustomMessage not implemented\")\n}",
      "length": 92,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) SubscribeCustomMessages(*SubscribeCustomMessagesRequest, Lightning_SubscribeCustomMessagesServer) error {",
      "content": "func (UnimplementedLightningServer) SubscribeCustomMessages(*SubscribeCustomMessagesRequest, Lightning_SubscribeCustomMessagesServer) error {\n\treturn status.Errorf(codes.Unimplemented, \"method SubscribeCustomMessages not implemented\")\n}",
      "length": 93,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) ListAliases(context.Context, *ListAliasesRequest) (*ListAliasesResponse, error) {",
      "content": "func (UnimplementedLightningServer) ListAliases(context.Context, *ListAliasesRequest) (*ListAliasesResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method ListAliases not implemented\")\n}",
      "length": 86,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) LookupHtlcResolution(context.Context, *LookupHtlcResolutionRequest) (*LookupHtlcResolutionResponse, error) {",
      "content": "func (UnimplementedLightningServer) LookupHtlcResolution(context.Context, *LookupHtlcResolutionRequest) (*LookupHtlcResolutionResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method LookupHtlcResolution not implemented\")\n}",
      "length": 95,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (UnimplementedLightningServer) mustEmbedUnimplementedLightningServer() {}",
      "content": "func (UnimplementedLightningServer) mustEmbedUnimplementedLightningServer() {}\n\n// UnsafeLightningServer may be embedded to opt out of forward compatibility for this service.\n// Use of this interface is not recommended, as added methods to LightningServer will\n// result in compilation errors.",
      "length": 211,
      "tokens": 33,
      "embedding": []
    },
    {
      "slug": "type UnsafeLightningServer interface {",
      "content": "type UnsafeLightningServer interface {\n\tmustEmbedUnimplementedLightningServer()\n}\n",
      "length": 41,
      "tokens": 2,
      "embedding": []
    },
    {
      "slug": "func RegisterLightningServer(s grpc.ServiceRegistrar, srv LightningServer) {",
      "content": "func RegisterLightningServer(s grpc.ServiceRegistrar, srv LightningServer) {\n\ts.RegisterService(&Lightning_ServiceDesc, srv)\n}\n",
      "length": 48,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func _Lightning_WalletBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_WalletBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(WalletBalanceRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).WalletBalance(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/WalletBalance\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).WalletBalance(ctx, req.(*WalletBalanceRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 461,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_ChannelBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_ChannelBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(ChannelBalanceRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).ChannelBalance(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/ChannelBalance\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).ChannelBalance(ctx, req.(*ChannelBalanceRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 466,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_GetTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_GetTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(GetTransactionsRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).GetTransactions(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/GetTransactions\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).GetTransactions(ctx, req.(*GetTransactionsRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 471,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_EstimateFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_EstimateFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(EstimateFeeRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).EstimateFee(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/EstimateFee\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).EstimateFee(ctx, req.(*EstimateFeeRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 451,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_SendCoins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_SendCoins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(SendCoinsRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).SendCoins(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/SendCoins\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).SendCoins(ctx, req.(*SendCoinsRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 441,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_ListUnspent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_ListUnspent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(ListUnspentRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).ListUnspent(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/ListUnspent\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).ListUnspent(ctx, req.(*ListUnspentRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 451,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_SubscribeTransactions_Handler(srv interface{}, stream grpc.ServerStream) error {",
      "content": "func _Lightning_SubscribeTransactions_Handler(srv interface{}, stream grpc.ServerStream) error {\n\tm := new(GetTransactionsRequest)\n\tif err := stream.RecvMsg(m); err != nil {\n\t\treturn err\n\t}\n\treturn srv.(LightningServer).SubscribeTransactions(m, &lightningSubscribeTransactionsServer{stream})\n}\n",
      "length": 191,
      "tokens": 18,
      "embedding": []
    },
    {
      "slug": "type Lightning_SubscribeTransactionsServer interface {",
      "content": "type Lightning_SubscribeTransactionsServer interface {\n\tSend(*Transaction) error\n\tgrpc.ServerStream\n}\n",
      "length": 44,
      "tokens": 4,
      "embedding": []
    },
    {
      "slug": "type lightningSubscribeTransactionsServer struct {",
      "content": "type lightningSubscribeTransactionsServer struct {\n\tgrpc.ServerStream\n}\n",
      "length": 19,
      "tokens": 2,
      "embedding": []
    },
    {
      "slug": "func (x *lightningSubscribeTransactionsServer) Send(m *Transaction) error {",
      "content": "func (x *lightningSubscribeTransactionsServer) Send(m *Transaction) error {\n\treturn x.ServerStream.SendMsg(m)\n}\n",
      "length": 34,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func _Lightning_SendMany_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_SendMany_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(SendManyRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).SendMany(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/SendMany\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).SendMany(ctx, req.(*SendManyRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 436,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_NewAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_NewAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(NewAddressRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).NewAddress(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/NewAddress\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).NewAddress(ctx, req.(*NewAddressRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 446,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_SignMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_SignMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(SignMessageRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).SignMessage(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/SignMessage\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).SignMessage(ctx, req.(*SignMessageRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 451,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_VerifyMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_VerifyMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(VerifyMessageRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).VerifyMessage(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/VerifyMessage\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).VerifyMessage(ctx, req.(*VerifyMessageRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 461,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_ConnectPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_ConnectPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(ConnectPeerRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).ConnectPeer(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/ConnectPeer\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).ConnectPeer(ctx, req.(*ConnectPeerRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 451,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_DisconnectPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_DisconnectPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(DisconnectPeerRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).DisconnectPeer(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/DisconnectPeer\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).DisconnectPeer(ctx, req.(*DisconnectPeerRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 466,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_ListPeers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_ListPeers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(ListPeersRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).ListPeers(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/ListPeers\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).ListPeers(ctx, req.(*ListPeersRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 441,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_SubscribePeerEvents_Handler(srv interface{}, stream grpc.ServerStream) error {",
      "content": "func _Lightning_SubscribePeerEvents_Handler(srv interface{}, stream grpc.ServerStream) error {\n\tm := new(PeerEventSubscription)\n\tif err := stream.RecvMsg(m); err != nil {\n\t\treturn err\n\t}\n\treturn srv.(LightningServer).SubscribePeerEvents(m, &lightningSubscribePeerEventsServer{stream})\n}\n",
      "length": 186,
      "tokens": 18,
      "embedding": []
    },
    {
      "slug": "type Lightning_SubscribePeerEventsServer interface {",
      "content": "type Lightning_SubscribePeerEventsServer interface {\n\tSend(*PeerEvent) error\n\tgrpc.ServerStream\n}\n",
      "length": 42,
      "tokens": 4,
      "embedding": []
    },
    {
      "slug": "type lightningSubscribePeerEventsServer struct {",
      "content": "type lightningSubscribePeerEventsServer struct {\n\tgrpc.ServerStream\n}\n",
      "length": 19,
      "tokens": 2,
      "embedding": []
    },
    {
      "slug": "func (x *lightningSubscribePeerEventsServer) Send(m *PeerEvent) error {",
      "content": "func (x *lightningSubscribePeerEventsServer) Send(m *PeerEvent) error {\n\treturn x.ServerStream.SendMsg(m)\n}\n",
      "length": 34,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func _Lightning_GetInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_GetInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(GetInfoRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).GetInfo(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/GetInfo\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).GetInfo(ctx, req.(*GetInfoRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 431,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_GetRecoveryInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_GetRecoveryInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(GetRecoveryInfoRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).GetRecoveryInfo(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/GetRecoveryInfo\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).GetRecoveryInfo(ctx, req.(*GetRecoveryInfoRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 471,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_PendingChannels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_PendingChannels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(PendingChannelsRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).PendingChannels(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/PendingChannels\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).PendingChannels(ctx, req.(*PendingChannelsRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 471,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_ListChannels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_ListChannels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(ListChannelsRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).ListChannels(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/ListChannels\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).ListChannels(ctx, req.(*ListChannelsRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 456,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_SubscribeChannelEvents_Handler(srv interface{}, stream grpc.ServerStream) error {",
      "content": "func _Lightning_SubscribeChannelEvents_Handler(srv interface{}, stream grpc.ServerStream) error {\n\tm := new(ChannelEventSubscription)\n\tif err := stream.RecvMsg(m); err != nil {\n\t\treturn err\n\t}\n\treturn srv.(LightningServer).SubscribeChannelEvents(m, &lightningSubscribeChannelEventsServer{stream})\n}\n",
      "length": 195,
      "tokens": 18,
      "embedding": []
    },
    {
      "slug": "type Lightning_SubscribeChannelEventsServer interface {",
      "content": "type Lightning_SubscribeChannelEventsServer interface {\n\tSend(*ChannelEventUpdate) error\n\tgrpc.ServerStream\n}\n",
      "length": 51,
      "tokens": 4,
      "embedding": []
    },
    {
      "slug": "type lightningSubscribeChannelEventsServer struct {",
      "content": "type lightningSubscribeChannelEventsServer struct {\n\tgrpc.ServerStream\n}\n",
      "length": 19,
      "tokens": 2,
      "embedding": []
    },
    {
      "slug": "func (x *lightningSubscribeChannelEventsServer) Send(m *ChannelEventUpdate) error {",
      "content": "func (x *lightningSubscribeChannelEventsServer) Send(m *ChannelEventUpdate) error {\n\treturn x.ServerStream.SendMsg(m)\n}\n",
      "length": 34,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func _Lightning_ClosedChannels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_ClosedChannels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(ClosedChannelsRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).ClosedChannels(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/ClosedChannels\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).ClosedChannels(ctx, req.(*ClosedChannelsRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 466,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_OpenChannelSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_OpenChannelSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(OpenChannelRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).OpenChannelSync(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/OpenChannelSync\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).OpenChannelSync(ctx, req.(*OpenChannelRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 463,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_OpenChannel_Handler(srv interface{}, stream grpc.ServerStream) error {",
      "content": "func _Lightning_OpenChannel_Handler(srv interface{}, stream grpc.ServerStream) error {\n\tm := new(OpenChannelRequest)\n\tif err := stream.RecvMsg(m); err != nil {\n\t\treturn err\n\t}\n\treturn srv.(LightningServer).OpenChannel(m, &lightningOpenChannelServer{stream})\n}\n",
      "length": 167,
      "tokens": 18,
      "embedding": []
    },
    {
      "slug": "type Lightning_OpenChannelServer interface {",
      "content": "type Lightning_OpenChannelServer interface {\n\tSend(*OpenStatusUpdate) error\n\tgrpc.ServerStream\n}\n",
      "length": 49,
      "tokens": 4,
      "embedding": []
    },
    {
      "slug": "type lightningOpenChannelServer struct {",
      "content": "type lightningOpenChannelServer struct {\n\tgrpc.ServerStream\n}\n",
      "length": 19,
      "tokens": 2,
      "embedding": []
    },
    {
      "slug": "func (x *lightningOpenChannelServer) Send(m *OpenStatusUpdate) error {",
      "content": "func (x *lightningOpenChannelServer) Send(m *OpenStatusUpdate) error {\n\treturn x.ServerStream.SendMsg(m)\n}\n",
      "length": 34,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func _Lightning_BatchOpenChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_BatchOpenChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(BatchOpenChannelRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).BatchOpenChannel(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/BatchOpenChannel\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).BatchOpenChannel(ctx, req.(*BatchOpenChannelRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 476,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_FundingStateStep_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_FundingStateStep_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(FundingTransitionMsg)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).FundingStateStep(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/FundingStateStep\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).FundingStateStep(ctx, req.(*FundingTransitionMsg))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 470,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_ChannelAcceptor_Handler(srv interface{}, stream grpc.ServerStream) error {",
      "content": "func _Lightning_ChannelAcceptor_Handler(srv interface{}, stream grpc.ServerStream) error {\n\treturn srv.(LightningServer).ChannelAcceptor(&lightningChannelAcceptorServer{stream})\n}\n",
      "length": 87,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "type Lightning_ChannelAcceptorServer interface {",
      "content": "type Lightning_ChannelAcceptorServer interface {\n\tSend(*ChannelAcceptRequest) error\n\tRecv() (*ChannelAcceptResponse, error)\n\tgrpc.ServerStream\n}\n",
      "length": 92,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "type lightningChannelAcceptorServer struct {",
      "content": "type lightningChannelAcceptorServer struct {\n\tgrpc.ServerStream\n}\n",
      "length": 19,
      "tokens": 2,
      "embedding": []
    },
    {
      "slug": "func (x *lightningChannelAcceptorServer) Send(m *ChannelAcceptRequest) error {",
      "content": "func (x *lightningChannelAcceptorServer) Send(m *ChannelAcceptRequest) error {\n\treturn x.ServerStream.SendMsg(m)\n}\n",
      "length": 34,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (x *lightningChannelAcceptorServer) Recv() (*ChannelAcceptResponse, error) {",
      "content": "func (x *lightningChannelAcceptorServer) Recv() (*ChannelAcceptResponse, error) {\n\tm := new(ChannelAcceptResponse)\n\tif err := x.ServerStream.RecvMsg(m); err != nil {\n\t\treturn nil, err\n\t}\n\treturn m, nil\n}\n",
      "length": 116,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func _Lightning_CloseChannel_Handler(srv interface{}, stream grpc.ServerStream) error {",
      "content": "func _Lightning_CloseChannel_Handler(srv interface{}, stream grpc.ServerStream) error {\n\tm := new(CloseChannelRequest)\n\tif err := stream.RecvMsg(m); err != nil {\n\t\treturn err\n\t}\n\treturn srv.(LightningServer).CloseChannel(m, &lightningCloseChannelServer{stream})\n}\n",
      "length": 170,
      "tokens": 18,
      "embedding": []
    },
    {
      "slug": "type Lightning_CloseChannelServer interface {",
      "content": "type Lightning_CloseChannelServer interface {\n\tSend(*CloseStatusUpdate) error\n\tgrpc.ServerStream\n}\n",
      "length": 50,
      "tokens": 4,
      "embedding": []
    },
    {
      "slug": "type lightningCloseChannelServer struct {",
      "content": "type lightningCloseChannelServer struct {\n\tgrpc.ServerStream\n}\n",
      "length": 19,
      "tokens": 2,
      "embedding": []
    },
    {
      "slug": "func (x *lightningCloseChannelServer) Send(m *CloseStatusUpdate) error {",
      "content": "func (x *lightningCloseChannelServer) Send(m *CloseStatusUpdate) error {\n\treturn x.ServerStream.SendMsg(m)\n}\n",
      "length": 34,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func _Lightning_AbandonChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_AbandonChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(AbandonChannelRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).AbandonChannel(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/AbandonChannel\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).AbandonChannel(ctx, req.(*AbandonChannelRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 466,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_SendPayment_Handler(srv interface{}, stream grpc.ServerStream) error {",
      "content": "func _Lightning_SendPayment_Handler(srv interface{}, stream grpc.ServerStream) error {\n\treturn srv.(LightningServer).SendPayment(&lightningSendPaymentServer{stream})\n}\n",
      "length": 79,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "type Lightning_SendPaymentServer interface {",
      "content": "type Lightning_SendPaymentServer interface {\n\tSend(*SendResponse) error\n\tRecv() (*SendRequest, error)\n\tgrpc.ServerStream\n}\n",
      "length": 74,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "type lightningSendPaymentServer struct {",
      "content": "type lightningSendPaymentServer struct {\n\tgrpc.ServerStream\n}\n",
      "length": 19,
      "tokens": 2,
      "embedding": []
    },
    {
      "slug": "func (x *lightningSendPaymentServer) Send(m *SendResponse) error {",
      "content": "func (x *lightningSendPaymentServer) Send(m *SendResponse) error {\n\treturn x.ServerStream.SendMsg(m)\n}\n",
      "length": 34,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (x *lightningSendPaymentServer) Recv() (*SendRequest, error) {",
      "content": "func (x *lightningSendPaymentServer) Recv() (*SendRequest, error) {\n\tm := new(SendRequest)\n\tif err := x.ServerStream.RecvMsg(m); err != nil {\n\t\treturn nil, err\n\t}\n\treturn m, nil\n}\n",
      "length": 106,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func _Lightning_SendPaymentSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_SendPaymentSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(SendRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).SendPaymentSync(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/SendPaymentSync\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).SendPaymentSync(ctx, req.(*SendRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 449,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_SendToRoute_Handler(srv interface{}, stream grpc.ServerStream) error {",
      "content": "func _Lightning_SendToRoute_Handler(srv interface{}, stream grpc.ServerStream) error {\n\treturn srv.(LightningServer).SendToRoute(&lightningSendToRouteServer{stream})\n}\n",
      "length": 79,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "type Lightning_SendToRouteServer interface {",
      "content": "type Lightning_SendToRouteServer interface {\n\tSend(*SendResponse) error\n\tRecv() (*SendToRouteRequest, error)\n\tgrpc.ServerStream\n}\n",
      "length": 81,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "type lightningSendToRouteServer struct {",
      "content": "type lightningSendToRouteServer struct {\n\tgrpc.ServerStream\n}\n",
      "length": 19,
      "tokens": 2,
      "embedding": []
    },
    {
      "slug": "func (x *lightningSendToRouteServer) Send(m *SendResponse) error {",
      "content": "func (x *lightningSendToRouteServer) Send(m *SendResponse) error {\n\treturn x.ServerStream.SendMsg(m)\n}\n",
      "length": 34,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (x *lightningSendToRouteServer) Recv() (*SendToRouteRequest, error) {",
      "content": "func (x *lightningSendToRouteServer) Recv() (*SendToRouteRequest, error) {\n\tm := new(SendToRouteRequest)\n\tif err := x.ServerStream.RecvMsg(m); err != nil {\n\t\treturn nil, err\n\t}\n\treturn m, nil\n}\n",
      "length": 113,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func _Lightning_SendToRouteSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_SendToRouteSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(SendToRouteRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).SendToRouteSync(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/SendToRouteSync\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).SendToRouteSync(ctx, req.(*SendToRouteRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 463,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_AddInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_AddInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(Invoice)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).AddInvoice(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/AddInvoice\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).AddInvoice(ctx, req.(*Invoice))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 426,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_ListInvoices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_ListInvoices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(ListInvoiceRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).ListInvoices(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/ListInvoices\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).ListInvoices(ctx, req.(*ListInvoiceRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 454,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_LookupInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_LookupInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(PaymentHash)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).LookupInvoice(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/LookupInvoice\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).LookupInvoice(ctx, req.(*PaymentHash))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 443,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_SubscribeInvoices_Handler(srv interface{}, stream grpc.ServerStream) error {",
      "content": "func _Lightning_SubscribeInvoices_Handler(srv interface{}, stream grpc.ServerStream) error {\n\tm := new(InvoiceSubscription)\n\tif err := stream.RecvMsg(m); err != nil {\n\t\treturn err\n\t}\n\treturn srv.(LightningServer).SubscribeInvoices(m, &lightningSubscribeInvoicesServer{stream})\n}\n",
      "length": 180,
      "tokens": 18,
      "embedding": []
    },
    {
      "slug": "type Lightning_SubscribeInvoicesServer interface {",
      "content": "type Lightning_SubscribeInvoicesServer interface {\n\tSend(*Invoice) error\n\tgrpc.ServerStream\n}\n",
      "length": 40,
      "tokens": 4,
      "embedding": []
    },
    {
      "slug": "type lightningSubscribeInvoicesServer struct {",
      "content": "type lightningSubscribeInvoicesServer struct {\n\tgrpc.ServerStream\n}\n",
      "length": 19,
      "tokens": 2,
      "embedding": []
    },
    {
      "slug": "func (x *lightningSubscribeInvoicesServer) Send(m *Invoice) error {",
      "content": "func (x *lightningSubscribeInvoicesServer) Send(m *Invoice) error {\n\treturn x.ServerStream.SendMsg(m)\n}\n",
      "length": 34,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func _Lightning_DecodePayReq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_DecodePayReq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(PayReqString)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).DecodePayReq(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/DecodePayReq\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).DecodePayReq(ctx, req.(*PayReqString))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 442,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_ListPayments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_ListPayments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(ListPaymentsRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).ListPayments(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/ListPayments\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).ListPayments(ctx, req.(*ListPaymentsRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 456,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_DeletePayment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_DeletePayment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(DeletePaymentRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).DeletePayment(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/DeletePayment\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).DeletePayment(ctx, req.(*DeletePaymentRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 461,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_DeleteAllPayments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_DeleteAllPayments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(DeleteAllPaymentsRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).DeleteAllPayments(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/DeleteAllPayments\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).DeleteAllPayments(ctx, req.(*DeleteAllPaymentsRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 481,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_DescribeGraph_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_DescribeGraph_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(ChannelGraphRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).DescribeGraph(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/DescribeGraph\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).DescribeGraph(ctx, req.(*ChannelGraphRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 459,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_GetNodeMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_GetNodeMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(NodeMetricsRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).GetNodeMetrics(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/GetNodeMetrics\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).GetNodeMetrics(ctx, req.(*NodeMetricsRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 460,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_GetChanInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_GetChanInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(ChanInfoRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).GetChanInfo(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/GetChanInfo\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).GetChanInfo(ctx, req.(*ChanInfoRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 445,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_GetNodeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_GetNodeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(NodeInfoRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).GetNodeInfo(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/GetNodeInfo\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).GetNodeInfo(ctx, req.(*NodeInfoRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 445,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_QueryRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_QueryRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(QueryRoutesRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).QueryRoutes(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/QueryRoutes\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).QueryRoutes(ctx, req.(*QueryRoutesRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 451,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_GetNetworkInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_GetNetworkInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(NetworkInfoRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).GetNetworkInfo(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/GetNetworkInfo\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).GetNetworkInfo(ctx, req.(*NetworkInfoRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 460,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_StopDaemon_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_StopDaemon_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(StopRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).StopDaemon(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/StopDaemon\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).StopDaemon(ctx, req.(*StopRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 434,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_SubscribeChannelGraph_Handler(srv interface{}, stream grpc.ServerStream) error {",
      "content": "func _Lightning_SubscribeChannelGraph_Handler(srv interface{}, stream grpc.ServerStream) error {\n\tm := new(GraphTopologySubscription)\n\tif err := stream.RecvMsg(m); err != nil {\n\t\treturn err\n\t}\n\treturn srv.(LightningServer).SubscribeChannelGraph(m, &lightningSubscribeChannelGraphServer{stream})\n}\n",
      "length": 194,
      "tokens": 18,
      "embedding": []
    },
    {
      "slug": "type Lightning_SubscribeChannelGraphServer interface {",
      "content": "type Lightning_SubscribeChannelGraphServer interface {\n\tSend(*GraphTopologyUpdate) error\n\tgrpc.ServerStream\n}\n",
      "length": 52,
      "tokens": 4,
      "embedding": []
    },
    {
      "slug": "type lightningSubscribeChannelGraphServer struct {",
      "content": "type lightningSubscribeChannelGraphServer struct {\n\tgrpc.ServerStream\n}\n",
      "length": 19,
      "tokens": 2,
      "embedding": []
    },
    {
      "slug": "func (x *lightningSubscribeChannelGraphServer) Send(m *GraphTopologyUpdate) error {",
      "content": "func (x *lightningSubscribeChannelGraphServer) Send(m *GraphTopologyUpdate) error {\n\treturn x.ServerStream.SendMsg(m)\n}\n",
      "length": 34,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func _Lightning_DebugLevel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_DebugLevel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(DebugLevelRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).DebugLevel(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/DebugLevel\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).DebugLevel(ctx, req.(*DebugLevelRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 446,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_FeeReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_FeeReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(FeeReportRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).FeeReport(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/FeeReport\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).FeeReport(ctx, req.(*FeeReportRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 441,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_UpdateChannelPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_UpdateChannelPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(PolicyUpdateRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).UpdateChannelPolicy(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/UpdateChannelPolicy\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).UpdateChannelPolicy(ctx, req.(*PolicyUpdateRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 477,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_ForwardingHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_ForwardingHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(ForwardingHistoryRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).ForwardingHistory(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/ForwardingHistory\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).ForwardingHistory(ctx, req.(*ForwardingHistoryRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 481,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_ExportChannelBackup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_ExportChannelBackup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(ExportChannelBackupRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).ExportChannelBackup(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/ExportChannelBackup\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).ExportChannelBackup(ctx, req.(*ExportChannelBackupRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 491,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_ExportAllChannelBackups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_ExportAllChannelBackups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(ChanBackupExportRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).ExportAllChannelBackups(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/ExportAllChannelBackups\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).ExportAllChannelBackups(ctx, req.(*ChanBackupExportRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 497,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_VerifyChanBackup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_VerifyChanBackup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(ChanBackupSnapshot)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).VerifyChanBackup(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/VerifyChanBackup\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).VerifyChanBackup(ctx, req.(*ChanBackupSnapshot))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 466,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_RestoreChannelBackups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_RestoreChannelBackups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(RestoreChanBackupRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).RestoreChannelBackups(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/RestoreChannelBackups\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).RestoreChannelBackups(ctx, req.(*RestoreChanBackupRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 493,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_SubscribeChannelBackups_Handler(srv interface{}, stream grpc.ServerStream) error {",
      "content": "func _Lightning_SubscribeChannelBackups_Handler(srv interface{}, stream grpc.ServerStream) error {\n\tm := new(ChannelBackupSubscription)\n\tif err := stream.RecvMsg(m); err != nil {\n\t\treturn err\n\t}\n\treturn srv.(LightningServer).SubscribeChannelBackups(m, &lightningSubscribeChannelBackupsServer{stream})\n}\n",
      "length": 198,
      "tokens": 18,
      "embedding": []
    },
    {
      "slug": "type Lightning_SubscribeChannelBackupsServer interface {",
      "content": "type Lightning_SubscribeChannelBackupsServer interface {\n\tSend(*ChanBackupSnapshot) error\n\tgrpc.ServerStream\n}\n",
      "length": 51,
      "tokens": 4,
      "embedding": []
    },
    {
      "slug": "type lightningSubscribeChannelBackupsServer struct {",
      "content": "type lightningSubscribeChannelBackupsServer struct {\n\tgrpc.ServerStream\n}\n",
      "length": 19,
      "tokens": 2,
      "embedding": []
    },
    {
      "slug": "func (x *lightningSubscribeChannelBackupsServer) Send(m *ChanBackupSnapshot) error {",
      "content": "func (x *lightningSubscribeChannelBackupsServer) Send(m *ChanBackupSnapshot) error {\n\treturn x.ServerStream.SendMsg(m)\n}\n",
      "length": 34,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func _Lightning_BakeMacaroon_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_BakeMacaroon_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(BakeMacaroonRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).BakeMacaroon(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/BakeMacaroon\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).BakeMacaroon(ctx, req.(*BakeMacaroonRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 456,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_ListMacaroonIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_ListMacaroonIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(ListMacaroonIDsRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).ListMacaroonIDs(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/ListMacaroonIDs\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).ListMacaroonIDs(ctx, req.(*ListMacaroonIDsRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 471,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_DeleteMacaroonID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_DeleteMacaroonID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(DeleteMacaroonIDRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).DeleteMacaroonID(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/DeleteMacaroonID\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).DeleteMacaroonID(ctx, req.(*DeleteMacaroonIDRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 476,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_ListPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_ListPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(ListPermissionsRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).ListPermissions(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/ListPermissions\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).ListPermissions(ctx, req.(*ListPermissionsRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 471,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_CheckMacaroonPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_CheckMacaroonPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(CheckMacPermRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).CheckMacaroonPermissions(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/CheckMacaroonPermissions\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).CheckMacaroonPermissions(ctx, req.(*CheckMacPermRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 492,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_RegisterRPCMiddleware_Handler(srv interface{}, stream grpc.ServerStream) error {",
      "content": "func _Lightning_RegisterRPCMiddleware_Handler(srv interface{}, stream grpc.ServerStream) error {\n\treturn srv.(LightningServer).RegisterRPCMiddleware(&lightningRegisterRPCMiddlewareServer{stream})\n}\n",
      "length": 99,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "type Lightning_RegisterRPCMiddlewareServer interface {",
      "content": "type Lightning_RegisterRPCMiddlewareServer interface {\n\tSend(*RPCMiddlewareRequest) error\n\tRecv() (*RPCMiddlewareResponse, error)\n\tgrpc.ServerStream\n}\n",
      "length": 92,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "type lightningRegisterRPCMiddlewareServer struct {",
      "content": "type lightningRegisterRPCMiddlewareServer struct {\n\tgrpc.ServerStream\n}\n",
      "length": 19,
      "tokens": 2,
      "embedding": []
    },
    {
      "slug": "func (x *lightningRegisterRPCMiddlewareServer) Send(m *RPCMiddlewareRequest) error {",
      "content": "func (x *lightningRegisterRPCMiddlewareServer) Send(m *RPCMiddlewareRequest) error {\n\treturn x.ServerStream.SendMsg(m)\n}\n",
      "length": 34,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (x *lightningRegisterRPCMiddlewareServer) Recv() (*RPCMiddlewareResponse, error) {",
      "content": "func (x *lightningRegisterRPCMiddlewareServer) Recv() (*RPCMiddlewareResponse, error) {\n\tm := new(RPCMiddlewareResponse)\n\tif err := x.ServerStream.RecvMsg(m); err != nil {\n\t\treturn nil, err\n\t}\n\treturn m, nil\n}\n",
      "length": 116,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func _Lightning_SendCustomMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_SendCustomMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(SendCustomMessageRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).SendCustomMessage(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/SendCustomMessage\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).SendCustomMessage(ctx, req.(*SendCustomMessageRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 481,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_SubscribeCustomMessages_Handler(srv interface{}, stream grpc.ServerStream) error {",
      "content": "func _Lightning_SubscribeCustomMessages_Handler(srv interface{}, stream grpc.ServerStream) error {\n\tm := new(SubscribeCustomMessagesRequest)\n\tif err := stream.RecvMsg(m); err != nil {\n\t\treturn err\n\t}\n\treturn srv.(LightningServer).SubscribeCustomMessages(m, &lightningSubscribeCustomMessagesServer{stream})\n}\n",
      "length": 203,
      "tokens": 18,
      "embedding": []
    },
    {
      "slug": "type Lightning_SubscribeCustomMessagesServer interface {",
      "content": "type Lightning_SubscribeCustomMessagesServer interface {\n\tSend(*CustomMessage) error\n\tgrpc.ServerStream\n}\n",
      "length": 46,
      "tokens": 4,
      "embedding": []
    },
    {
      "slug": "type lightningSubscribeCustomMessagesServer struct {",
      "content": "type lightningSubscribeCustomMessagesServer struct {\n\tgrpc.ServerStream\n}\n",
      "length": 19,
      "tokens": 2,
      "embedding": []
    },
    {
      "slug": "func (x *lightningSubscribeCustomMessagesServer) Send(m *CustomMessage) error {",
      "content": "func (x *lightningSubscribeCustomMessagesServer) Send(m *CustomMessage) error {\n\treturn x.ServerStream.SendMsg(m)\n}\n",
      "length": 34,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func _Lightning_ListAliases_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_ListAliases_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(ListAliasesRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).ListAliases(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/ListAliases\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).ListAliases(ctx, req.(*ListAliasesRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n",
      "length": 451,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func _Lightning_LookupHtlcResolution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {",
      "content": "func _Lightning_LookupHtlcResolution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(LookupHtlcResolutionRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(LightningServer).LookupHtlcResolution(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/lnrpc.Lightning/LookupHtlcResolution\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(LightningServer).LookupHtlcResolution(ctx, req.(*LookupHtlcResolutionRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n\n// Lightning_ServiceDesc is the grpc.ServiceDesc for Lightning service.\n// It's only intended for direct use with grpc.RegisterService,\n// and not to be introspected or modified (even as a copy)\nvar Lightning_ServiceDesc = grpc.ServiceDesc{\n\tServiceName: \"lnrpc.Lightning\",\n\tHandlerType: (*LightningServer)(nil),\n\tMethods: []grpc.MethodDesc{\n\t\t{\n\t\t\tMethodName: \"WalletBalance\",\n\t\t\tHandler:    _Lightning_WalletBalance_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"ChannelBalance\",\n\t\t\tHandler:    _Lightning_ChannelBalance_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"GetTransactions\",\n\t\t\tHandler:    _Lightning_GetTransactions_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"EstimateFee\",\n\t\t\tHandler:    _Lightning_EstimateFee_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"SendCoins\",\n\t\t\tHandler:    _Lightning_SendCoins_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"ListUnspent\",\n\t\t\tHandler:    _Lightning_ListUnspent_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"SendMany\",\n\t\t\tHandler:    _Lightning_SendMany_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"NewAddress\",\n\t\t\tHandler:    _Lightning_NewAddress_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"SignMessage\",\n\t\t\tHandler:    _Lightning_SignMessage_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"VerifyMessage\",\n\t\t\tHandler:    _Lightning_VerifyMessage_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"ConnectPeer\",\n\t\t\tHandler:    _Lightning_ConnectPeer_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"DisconnectPeer\",\n\t\t\tHandler:    _Lightning_DisconnectPeer_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"ListPeers\",\n\t\t\tHandler:    _Lightning_ListPeers_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"GetInfo\",\n\t\t\tHandler:    _Lightning_GetInfo_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"GetRecoveryInfo\",\n\t\t\tHandler:    _Lightning_GetRecoveryInfo_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"PendingChannels\",\n\t\t\tHandler:    _Lightning_PendingChannels_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"ListChannels\",\n\t\t\tHandler:    _Lightning_ListChannels_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"ClosedChannels\",\n\t\t\tHandler:    _Lightning_ClosedChannels_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"OpenChannelSync\",\n\t\t\tHandler:    _Lightning_OpenChannelSync_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"BatchOpenChannel\",\n\t\t\tHandler:    _Lightning_BatchOpenChannel_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"FundingStateStep\",\n\t\t\tHandler:    _Lightning_FundingStateStep_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"AbandonChannel\",\n\t\t\tHandler:    _Lightning_AbandonChannel_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"SendPaymentSync\",\n\t\t\tHandler:    _Lightning_SendPaymentSync_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"SendToRouteSync\",\n\t\t\tHandler:    _Lightning_SendToRouteSync_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"AddInvoice\",\n\t\t\tHandler:    _Lightning_AddInvoice_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"ListInvoices\",\n\t\t\tHandler:    _Lightning_ListInvoices_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"LookupInvoice\",\n\t\t\tHandler:    _Lightning_LookupInvoice_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"DecodePayReq\",\n\t\t\tHandler:    _Lightning_DecodePayReq_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"ListPayments\",\n\t\t\tHandler:    _Lightning_ListPayments_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"DeletePayment\",\n\t\t\tHandler:    _Lightning_DeletePayment_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"DeleteAllPayments\",\n\t\t\tHandler:    _Lightning_DeleteAllPayments_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"DescribeGraph\",\n\t\t\tHandler:    _Lightning_DescribeGraph_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"GetNodeMetrics\",\n\t\t\tHandler:    _Lightning_GetNodeMetrics_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"GetChanInfo\",\n\t\t\tHandler:    _Lightning_GetChanInfo_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"GetNodeInfo\",\n\t\t\tHandler:    _Lightning_GetNodeInfo_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"QueryRoutes\",\n\t\t\tHandler:    _Lightning_QueryRoutes_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"GetNetworkInfo\",\n\t\t\tHandler:    _Lightning_GetNetworkInfo_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"StopDaemon\",\n\t\t\tHandler:    _Lightning_StopDaemon_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"DebugLevel\",\n\t\t\tHandler:    _Lightning_DebugLevel_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"FeeReport\",\n\t\t\tHandler:    _Lightning_FeeReport_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"UpdateChannelPolicy\",\n\t\t\tHandler:    _Lightning_UpdateChannelPolicy_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"ForwardingHistory\",\n\t\t\tHandler:    _Lightning_ForwardingHistory_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"ExportChannelBackup\",\n\t\t\tHandler:    _Lightning_ExportChannelBackup_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"ExportAllChannelBackups\",\n\t\t\tHandler:    _Lightning_ExportAllChannelBackups_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"VerifyChanBackup\",\n\t\t\tHandler:    _Lightning_VerifyChanBackup_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"RestoreChannelBackups\",\n\t\t\tHandler:    _Lightning_RestoreChannelBackups_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"BakeMacaroon\",\n\t\t\tHandler:    _Lightning_BakeMacaroon_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"ListMacaroonIDs\",\n\t\t\tHandler:    _Lightning_ListMacaroonIDs_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"DeleteMacaroonID\",\n\t\t\tHandler:    _Lightning_DeleteMacaroonID_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"ListPermissions\",\n\t\t\tHandler:    _Lightning_ListPermissions_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"CheckMacaroonPermissions\",\n\t\t\tHandler:    _Lightning_CheckMacaroonPermissions_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"SendCustomMessage\",\n\t\t\tHandler:    _Lightning_SendCustomMessage_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"ListAliases\",\n\t\t\tHandler:    _Lightning_ListAliases_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"LookupHtlcResolution\",\n\t\t\tHandler:    _Lightning_LookupHtlcResolution_Handler,\n\t\t},\n\t},\n\tStreams: []grpc.StreamDesc{\n\t\t{\n\t\t\tStreamName:    \"SubscribeTransactions\",\n\t\t\tHandler:       _Lightning_SubscribeTransactions_Handler,\n\t\t\tServerStreams: true,\n\t\t},\n\t\t{\n\t\t\tStreamName:    \"SubscribePeerEvents\",\n\t\t\tHandler:       _Lightning_SubscribePeerEvents_Handler,\n\t\t\tServerStreams: true,\n\t\t},\n\t\t{\n\t\t\tStreamName:    \"SubscribeChannelEvents\",\n\t\t\tHandler:       _Lightning_SubscribeChannelEvents_Handler,\n\t\t\tServerStreams: true,\n\t\t},\n\t\t{\n\t\t\tStreamName:    \"OpenChannel\",\n\t\t\tHandler:       _Lightning_OpenChannel_Handler,\n\t\t\tServerStreams: true,\n\t\t},\n\t\t{\n\t\t\tStreamName:    \"ChannelAcceptor\",\n\t\t\tHandler:       _Lightning_ChannelAcceptor_Handler,\n\t\t\tServerStreams: true,\n\t\t\tClientStreams: true,\n\t\t},\n\t\t{\n\t\t\tStreamName:    \"CloseChannel\",\n\t\t\tHandler:       _Lightning_CloseChannel_Handler,\n\t\t\tServerStreams: true,\n\t\t},\n\t\t{\n\t\t\tStreamName:    \"SendPayment\",\n\t\t\tHandler:       _Lightning_SendPayment_Handler,\n\t\t\tServerStreams: true,\n\t\t\tClientStreams: true,\n\t\t},\n\t\t{\n\t\t\tStreamName:    \"SendToRoute\",\n\t\t\tHandler:       _Lightning_SendToRoute_Handler,\n\t\t\tServerStreams: true,\n\t\t\tClientStreams: true,\n\t\t},\n\t\t{\n\t\t\tStreamName:    \"SubscribeInvoices\",\n\t\t\tHandler:       _Lightning_SubscribeInvoices_Handler,\n\t\t\tServerStreams: true,\n\t\t},\n\t\t{\n\t\t\tStreamName:    \"SubscribeChannelGraph\",\n\t\t\tHandler:       _Lightning_SubscribeChannelGraph_Handler,\n\t\t\tServerStreams: true,\n\t\t},\n\t\t{\n\t\t\tStreamName:    \"SubscribeChannelBackups\",\n\t\t\tHandler:       _Lightning_SubscribeChannelBackups_Handler,\n\t\t\tServerStreams: true,\n\t\t},\n\t\t{\n\t\t\tStreamName:    \"RegisterRPCMiddleware\",\n\t\t\tHandler:       _Lightning_RegisterRPCMiddleware_Handler,\n\t\t\tServerStreams: true,\n\t\t\tClientStreams: true,\n\t\t},\n\t\t{\n\t\t\tStreamName:    \"SubscribeCustomMessages\",\n\t\t\tHandler:       _Lightning_SubscribeCustomMessages_Handler,\n\t\t\tServerStreams: true,\n\t\t},\n\t},\n\tMetadata: \"lightning.proto\",\n}\n",
      "length": 7318,
      "tokens": 533,
      "embedding": []
    }
  ]
}