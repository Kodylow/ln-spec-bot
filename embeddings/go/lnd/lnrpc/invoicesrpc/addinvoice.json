{
  "filepath": "../implementations/go/lnd/lnrpc/invoicesrpc/addinvoice.go",
  "package": "invoicesrpc",
  "sections": [
    {
      "slug": "type AddInvoiceConfig struct {",
      "content": "type AddInvoiceConfig struct {\n\t// AddInvoice is called to add the invoice to the registry.\n\tAddInvoice func(invoice *invoices.Invoice, paymentHash lntypes.Hash) (\n\t\tuint64, error)\n\n\t// IsChannelActive is used to generate valid hop hints.\n\tIsChannelActive func(chanID lnwire.ChannelID) bool\n\n\t// ChainParams are required to properly decode invoice payment requests\n\t// that are marshalled over rpc.\n\tChainParams *chaincfg.Params\n\n\t// NodeSigner is an implementation of the MessageSigner implementation\n\t// that's backed by the identity private key of the running lnd node.\n\tNodeSigner *netann.NodeSigner\n\n\t// DefaultCLTVExpiry is the default invoice expiry if no values is\n\t// specified.\n\tDefaultCLTVExpiry uint32\n\n\t// ChanDB is a global boltdb instance which is needed to access the\n\t// channel graph.\n\tChanDB *channeldb.ChannelStateDB\n\n\t// Graph holds a reference to the ChannelGraph database.\n\tGraph *channeldb.ChannelGraph\n\n\t// GenInvoiceFeatures returns a feature containing feature bits that\n\t// should be advertised on freshly generated invoices.\n\tGenInvoiceFeatures func() *lnwire.FeatureVector\n\n\t// GenAmpInvoiceFeatures returns a feature containing feature bits that\n\t// should be advertised on freshly generated AMP invoices.\n\tGenAmpInvoiceFeatures func() *lnwire.FeatureVector\n\n\t// GetAlias allows the peer's alias SCID to be retrieved for private\n\t// option_scid_alias channels.\n\tGetAlias func(lnwire.ChannelID) (lnwire.ShortChannelID, error)\n}\n\n// AddInvoiceData contains the required data to create a new invoice.",
      "length": 1458,
      "tokens": 190,
      "embedding": []
    },
    {
      "slug": "type AddInvoiceData struct {",
      "content": "type AddInvoiceData struct {\n\t// An optional memo to attach along with the invoice. Used for record\n\t// keeping purposes for the invoice's creator, and will also be set in\n\t// the description field of the encoded payment request if the\n\t// description_hash field is not being used.\n\tMemo string\n\n\t// The preimage which will allow settling an incoming HTLC payable to\n\t// this preimage. If Preimage is set, Hash should be nil. If both\n\t// Preimage and Hash are nil, a random preimage is generated.\n\tPreimage *lntypes.Preimage\n\n\t// The hash of the preimage. If Hash is set, Preimage should be nil.\n\t// This condition indicates that we have a 'hold invoice' for which the\n\t// htlc will be accepted and held until the preimage becomes known.\n\tHash *lntypes.Hash\n\n\t// The value of this invoice in millisatoshis.\n\tValue lnwire.MilliSatoshi\n\n\t// Hash (SHA-256) of a description of the payment. Used if the\n\t// description of payment (memo) is too long to naturally fit within the\n\t// description field of an encoded payment request.\n\tDescriptionHash []byte\n\n\t// Payment request expiry time in seconds. Default is 3600 (1 hour).\n\tExpiry int64\n\n\t// Fallback on-chain address.\n\tFallbackAddr string\n\n\t// Delta to use for the time-lock of the CLTV extended to the final hop.\n\tCltvExpiry uint64\n\n\t// Whether this invoice should include routing hints for private\n\t// channels.\n\tPrivate bool\n\n\t// HodlInvoice signals that this invoice shouldn't be settled\n\t// immediately upon receiving the payment.\n\tHodlInvoice bool\n\n\t// Amp signals whether or not to create an AMP invoice.\n\t//\n\t// NOTE: Preimage should always be set to nil when this value is true.\n\tAmp bool\n\n\t// RouteHints are optional route hints that can each be individually\n\t// used to assist in reaching the invoice's destination.\n\tRouteHints [][]zpay32.HopHint\n}\n\n// paymentHashAndPreimage returns the payment hash and preimage for this invoice\n// depending on the configuration.\n//\n// For AMP invoices (when Amp flag is true), this method always returns a nil\n// preimage. The hash value can be set externally by the user using the Hash\n// field, or one will be generated randomly. The payment hash here only serves\n// as a unique identifier for insertion into the invoice index, as there is\n// no universal preimage for an AMP payment.\n//\n// For MPP invoices (when Amp flag is false), this method may return nil\n// preimage when create a hodl invoice, but otherwise will always return a\n// non-nil preimage and the corresponding payment hash. The valid combinations\n// are parsed as follows:\n//   - Preimage == nil && Hash == nil -> (random preimage, H(random preimage))\n//   - Preimage != nil && Hash == nil -> (Preimage, H(Preimage))\n//   - Preimage == nil && Hash != nil -> (nil, Hash)",
      "length": 2641,
      "tokens": 454,
      "embedding": []
    },
    {
      "slug": "func (d *AddInvoiceData) paymentHashAndPreimage() (",
      "content": "func (d *AddInvoiceData) paymentHashAndPreimage() (\n\t*lntypes.Preimage, lntypes.Hash, error) {\n\n\tif d.Amp {\n\t\treturn d.ampPaymentHashAndPreimage()\n\t}\n\n\treturn d.mppPaymentHashAndPreimage()\n}\n\n// ampPaymentHashAndPreimage returns the payment hash to use for an AMP invoice.\n// The preimage will always be nil.",
      "length": 246,
      "tokens": 32,
      "embedding": []
    },
    {
      "slug": "func (d *AddInvoiceData) ampPaymentHashAndPreimage() (*lntypes.Preimage,",
      "content": "func (d *AddInvoiceData) ampPaymentHashAndPreimage() (*lntypes.Preimage,\n\tlntypes.Hash, error) {\n\n\tswitch {\n\t// Preimages cannot be set on AMP invoice.\n\tcase d.Preimage != nil:\n\t\treturn nil, lntypes.Hash{},\n\t\t\terrors.New(\"preimage set on AMP invoice\")\n\n\t// If a specific hash was requested, use that.\n\tcase d.Hash != nil:\n\t\treturn nil, *d.Hash, nil\n\n\t// Otherwise generate a random hash value, just needs to be unique to be\n\t// added to the invoice index.\n\tdefault:\n\t\tvar paymentHash lntypes.Hash\n\t\tif _, err := rand.Read(paymentHash[:]); err != nil {\n\t\t\treturn nil, lntypes.Hash{}, err\n\t\t}\n\n\t\treturn nil, paymentHash, nil\n\t}\n}\n\n// mppPaymentHashAndPreimage returns the payment hash and preimage to use for an\n// MPP invoice.",
      "length": 627,
      "tokens": 101,
      "embedding": []
    },
    {
      "slug": "func (d *AddInvoiceData) mppPaymentHashAndPreimage() (*lntypes.Preimage,",
      "content": "func (d *AddInvoiceData) mppPaymentHashAndPreimage() (*lntypes.Preimage,\n\tlntypes.Hash, error) {\n\n\tvar (\n\t\tpaymentPreimage *lntypes.Preimage\n\t\tpaymentHash     lntypes.Hash\n\t)\n\n\tswitch {\n\n\t// Only either preimage or hash can be set.\n\tcase d.Preimage != nil && d.Hash != nil:\n\t\treturn nil, lntypes.Hash{},\n\t\t\terrors.New(\"preimage and hash both set\")\n\n\t// If no hash or preimage is given, generate a random preimage.\n\tcase d.Preimage == nil && d.Hash == nil:\n\t\tpaymentPreimage = &lntypes.Preimage{}\n\t\tif _, err := rand.Read(paymentPreimage[:]); err != nil {\n\t\t\treturn nil, lntypes.Hash{}, err\n\t\t}\n\t\tpaymentHash = paymentPreimage.Hash()\n\n\t// If just a hash is given, we create a hold invoice by setting the\n\t// preimage to unknown.\n\tcase d.Preimage == nil && d.Hash != nil:\n\t\tpaymentHash = *d.Hash\n\n\t// A specific preimage was supplied. Use that for the invoice.\n\tcase d.Preimage != nil && d.Hash == nil:\n\t\tpreimage := *d.Preimage\n\t\tpaymentPreimage = &preimage\n\t\tpaymentHash = d.Preimage.Hash()\n\t}\n\n\treturn paymentPreimage, paymentHash, nil\n}\n\n// AddInvoice attempts to add a new invoice to the invoice database. Any\n// duplicated invoices are rejected, therefore all invoices *must* have a\n// unique payment preimage.",
      "length": 1102,
      "tokens": 169,
      "embedding": []
    },
    {
      "slug": "func AddInvoice(ctx context.Context, cfg *AddInvoiceConfig,",
      "content": "func AddInvoice(ctx context.Context, cfg *AddInvoiceConfig,\n\tinvoice *AddInvoiceData) (*lntypes.Hash, *invoices.Invoice, error) {\n\n\tpaymentPreimage, paymentHash, err := invoice.paymentHashAndPreimage()\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// The size of the memo, receipt and description hash attached must not\n\t// exceed the maximum values for either of the fields.\n\tif len(invoice.Memo) > invoices.MaxMemoSize {\n\t\treturn nil, nil, fmt.Errorf(\"memo too large: %v bytes \"+\n\t\t\t\"(maxsize=%v)\", len(invoice.Memo),\n\t\t\tinvoices.MaxMemoSize)\n\t}\n\tif len(invoice.DescriptionHash) > 0 &&\n\t\tlen(invoice.DescriptionHash) != 32 {\n\n\t\treturn nil, nil, fmt.Errorf(\"description hash is %v bytes, \"+\n\t\t\t\"must be 32\", len(invoice.DescriptionHash))\n\t}\n\n\t// We set the max invoice amount to 100k BTC, which itself is several\n\t// multiples off the current block reward.\n\tmaxInvoiceAmt := btcutil.Amount(btcutil.SatoshiPerBitcoin * 100000)\n\n\tswitch {\n\t// The value of the invoice must not be negative.\n\tcase int64(invoice.Value) < 0:\n\t\treturn nil, nil, fmt.Errorf(\"payments of negative value \"+\n\t\t\t\"are not allowed, value is %v\", int64(invoice.Value))\n\n\t// Also ensure that the invoice is actually realistic, while preventing\n\t// any issues due to underflow.\n\tcase invoice.Value.ToSatoshis() > maxInvoiceAmt:\n\t\treturn nil, nil, fmt.Errorf(\"invoice amount %v is \"+\n\t\t\t\"too large, max is %v\", invoice.Value.ToSatoshis(),\n\t\t\tmaxInvoiceAmt)\n\t}\n\n\tamtMSat := invoice.Value\n\n\t// We also create an encoded payment request which allows the\n\t// caller to compactly send the invoice to the payer. We'll create a\n\t// list of options to be added to the encoded payment request. For now\n\t// we only support the required fields description/description_hash,\n\t// expiry, fallback address, and the amount field.\n\tvar options []func(*zpay32.Invoice)\n\n\t// We only include the amount in the invoice if it is greater than 0.\n\t// By not including the amount, we enable the creation of invoices that\n\t// allow the payer to specify the amount of satoshis they wish to send.\n\tif amtMSat > 0 {\n\t\toptions = append(options, zpay32.Amount(amtMSat))\n\t}\n\n\t// If specified, add a fallback address to the payment request.\n\tif len(invoice.FallbackAddr) > 0 {\n\t\taddr, err := btcutil.DecodeAddress(invoice.FallbackAddr,\n\t\t\tcfg.ChainParams)\n\t\tif err != nil {\n\t\t\treturn nil, nil, fmt.Errorf(\"invalid fallback \"+\n\t\t\t\t\"address: %v\", err)\n\t\t}\n\t\toptions = append(options, zpay32.FallbackAddr(addr))\n\t}\n\n\tswitch {\n\t// If expiry is set, specify it. If it is not provided, no expiry time\n\t// will be explicitly added to this payment request, which will imply\n\t// the default 3600 seconds.\n\tcase invoice.Expiry > 0:\n\n\t\t// We'll ensure that the specified expiry is restricted to sane\n\t\t// number of seconds. As a result, we'll reject an invoice with\n\t\t// an expiry greater than 1 year.\n\t\tmaxExpiry := time.Hour * 24 * 365\n\t\texpSeconds := invoice.Expiry\n\n\t\tif float64(expSeconds) > maxExpiry.Seconds() {\n\t\t\treturn nil, nil, fmt.Errorf(\"expiry of %v seconds \"+\n\t\t\t\t\"greater than max expiry of %v seconds\",\n\t\t\t\tfloat64(expSeconds), maxExpiry.Seconds())\n\t\t}\n\n\t\texpiry := time.Duration(invoice.Expiry) * time.Second\n\t\toptions = append(options, zpay32.Expiry(expiry))\n\n\t// If no custom expiry is provided, use the default MPP expiry.\n\tcase !invoice.Amp:\n\t\toptions = append(options, zpay32.Expiry(DefaultInvoiceExpiry))\n\n\t// Otherwise, use the default AMP expiry.\n\tdefault:\n\t\tdefaultExpiry := zpay32.Expiry(DefaultAMPInvoiceExpiry)\n\t\toptions = append(options, defaultExpiry)\n\t}\n\n\t// If the description hash is set, then we add it do the list of\n\t// options. If not, use the memo field as the payment request\n\t// description.\n\tif len(invoice.DescriptionHash) > 0 {\n\t\tvar descHash [32]byte\n\t\tcopy(descHash[:], invoice.DescriptionHash[:])\n\t\toptions = append(options, zpay32.DescriptionHash(descHash))\n\t} else {\n\t\t// Use the memo field as the description. If this is not set\n\t\t// this will just be an empty string.\n\t\toptions = append(options, zpay32.Description(invoice.Memo))\n\t}\n\n\t// We'll use our current default CLTV value unless one was specified as\n\t// an option on the command line when creating an invoice.\n\tswitch {\n\tcase invoice.CltvExpiry > math.MaxUint16:\n\t\treturn nil, nil, fmt.Errorf(\"CLTV delta of %v is too large, \"+\n\t\t\t\"max accepted is: %v\", invoice.CltvExpiry,\n\t\t\tmath.MaxUint16)\n\n\tcase invoice.CltvExpiry != 0:\n\t\t// Disallow user-chosen final CLTV deltas below the required\n\t\t// minimum.\n\t\tif invoice.CltvExpiry < routing.MinCLTVDelta {\n\t\t\treturn nil, nil, fmt.Errorf(\"CLTV delta of %v must be \"+\n\t\t\t\t\"greater than minimum of %v\",\n\t\t\t\trouting.MinCLTVDelta, invoice.CltvExpiry)\n\t\t}\n\n\t\toptions = append(options,\n\t\t\tzpay32.CLTVExpiry(invoice.CltvExpiry))\n\n\tdefault:\n\t\t// TODO(roasbeef): assumes set delta between versions\n\t\tdefaultCLTVExpiry := uint64(cfg.DefaultCLTVExpiry)\n\t\toptions = append(options, zpay32.CLTVExpiry(defaultCLTVExpiry))\n\t}\n\n\t// We make sure that the given invoice routing hints number is within\n\t// the valid range\n\tif len(invoice.RouteHints) > maxHopHints {\n\t\treturn nil, nil, fmt.Errorf(\"number of routing hints must \"+\n\t\t\t\"not exceed maximum of %v\", maxHopHints)\n\t}\n\n\t// Include route hints if needed.\n\tif len(invoice.RouteHints) > 0 || invoice.Private {\n\t\t// Validate provided hop hints.\n\t\tfor _, hint := range invoice.RouteHints {\n\t\t\tif len(hint) == 0 {\n\t\t\t\treturn nil, nil, fmt.Errorf(\"number of hop \" +\n\t\t\t\t\t\"hint within a route must be positive\")\n\t\t\t}\n\t\t}\n\n\t\ttotalHopHints := len(invoice.RouteHints)\n\t\tif invoice.Private {\n\t\t\ttotalHopHints = maxHopHints\n\t\t}\n\n\t\thopHintsCfg := newSelectHopHintsCfg(cfg, totalHopHints)\n\t\thopHints, err := PopulateHopHints(\n\t\t\thopHintsCfg, amtMSat, invoice.RouteHints,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, nil, fmt.Errorf(\"unable to populate hop \"+\n\t\t\t\t\"hints: %v\", err)\n\t\t}\n\n\t\t// Convert our set of selected hop hints into route\n\t\t// hints and add to our invoice options.\n\t\tfor _, hopHint := range hopHints {\n\t\t\trouteHint := zpay32.RouteHint(hopHint)\n\n\t\t\toptions = append(\n\t\t\t\toptions, routeHint,\n\t\t\t)\n\t\t}\n\t}\n\n\t// Set our desired invoice features and add them to our list of options.\n\tvar invoiceFeatures *lnwire.FeatureVector\n\tif invoice.Amp {\n\t\tinvoiceFeatures = cfg.GenAmpInvoiceFeatures()\n\t} else {\n\t\tinvoiceFeatures = cfg.GenInvoiceFeatures()\n\t}\n\toptions = append(options, zpay32.Features(invoiceFeatures))\n\n\t// Generate and set a random payment address for this invoice. If the\n\t// sender understands payment addresses, this can be used to avoid\n\t// intermediaries probing the receiver.\n\tvar paymentAddr [32]byte\n\tif _, err := rand.Read(paymentAddr[:]); err != nil {\n\t\treturn nil, nil, err\n\t}\n\toptions = append(options, zpay32.PaymentAddr(paymentAddr))\n\n\t// Create and encode the payment request as a bech32 (zpay32) string.\n\tcreationDate := time.Now()\n\tpayReq, err := zpay32.NewInvoice(\n\t\tcfg.ChainParams, paymentHash, creationDate, options...,\n\t)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpayReqString, err := payReq.Encode(zpay32.MessageSigner{\n\t\tSignCompact: func(msg []byte) ([]byte, error) {\n\t\t\treturn cfg.NodeSigner.SignMessageCompact(msg, false)\n\t\t},\n\t})\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tnewInvoice := &invoices.Invoice{\n\t\tCreationDate:   creationDate,\n\t\tMemo:           []byte(invoice.Memo),\n\t\tPaymentRequest: []byte(payReqString),\n\t\tTerms: invoices.ContractTerm{\n\t\t\tFinalCltvDelta:  int32(payReq.MinFinalCLTVExpiry()),\n\t\t\tExpiry:          payReq.Expiry(),\n\t\t\tValue:           amtMSat,\n\t\t\tPaymentPreimage: paymentPreimage,\n\t\t\tPaymentAddr:     paymentAddr,\n\t\t\tFeatures:        invoiceFeatures,\n\t\t},\n\t\tHodlInvoice: invoice.HodlInvoice,\n\t}\n\n\tlog.Tracef(\"[addinvoice] adding new invoice %v\",\n\t\tnewLogClosure(func() string {\n\t\t\treturn spew.Sdump(newInvoice)\n\t\t}),\n\t)\n\n\t// With all sanity checks passed, write the invoice to the database.\n\t_, err = cfg.AddInvoice(newInvoice, paymentHash)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn &paymentHash, newInvoice, nil\n}\n\n// chanCanBeHopHint returns true if the target channel is eligible to be a hop\n// hint.",
      "length": 7683,
      "tokens": 1043,
      "embedding": []
    },
    {
      "slug": "func chanCanBeHopHint(channel *HopHintInfo, cfg *SelectHopHintsCfg) (",
      "content": "func chanCanBeHopHint(channel *HopHintInfo, cfg *SelectHopHintsCfg) (\n\t*channeldb.ChannelEdgePolicy, bool) {\n\n\t// Since we're only interested in our private channels, we'll skip\n\t// public ones.\n\tif channel.IsPublic {\n\t\treturn nil, false\n\t}\n\n\t// Make sure the channel is active.\n\tif !channel.IsActive {\n\t\tlog.Debugf(\"Skipping channel %v due to not \"+\n\t\t\t\"being eligible to forward payments\",\n\t\t\tchannel.ShortChannelID)\n\t\treturn nil, false\n\t}\n\n\t// To ensure we don't leak unadvertised nodes, we'll make sure our\n\t// counterparty is publicly advertised within the network.  Otherwise,\n\t// we'll end up leaking information about nodes that intend to stay\n\t// unadvertised, like in the case of a node only having private\n\t// channels.\n\tvar remotePub [33]byte\n\tcopy(remotePub[:], channel.RemotePubkey.SerializeCompressed())\n\tisRemoteNodePublic, err := cfg.IsPublicNode(remotePub)\n\tif err != nil {\n\t\tlog.Errorf(\"Unable to determine if node %x \"+\n\t\t\t\"is advertised: %v\", remotePub, err)\n\t\treturn nil, false\n\t}\n\n\tif !isRemoteNodePublic {\n\t\tlog.Debugf(\"Skipping channel %v due to \"+\n\t\t\t\"counterparty %x being unadvertised\",\n\t\t\tchannel.ShortChannelID, remotePub)\n\t\treturn nil, false\n\t}\n\n\t// Fetch the policies for each end of the channel.\n\tinfo, p1, p2, err := cfg.FetchChannelEdgesByID(channel.ShortChannelID)\n\tif err != nil {\n\t\t// In the case of zero-conf channels, it may be the case that\n\t\t// the alias SCID was deleted from the graph, and replaced by\n\t\t// the confirmed SCID. Check the Graph for the confirmed SCID.\n\t\tconfirmedScid := channel.ConfirmedScidZC\n\t\tinfo, p1, p2, err = cfg.FetchChannelEdgesByID(confirmedScid)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Unable to fetch the routing policies for \"+\n\t\t\t\t\"the edges of the channel %v: %v\",\n\t\t\t\tchannel.ShortChannelID, err)\n\t\t\treturn nil, false\n\t\t}\n\t}\n\n\t// Now, we'll need to determine which is the correct policy for HTLCs\n\t// being sent from the remote node.\n\tvar remotePolicy *channeldb.ChannelEdgePolicy\n\tif bytes.Equal(remotePub[:], info.NodeKey1Bytes[:]) {\n\t\tremotePolicy = p1\n\t} else {\n\t\tremotePolicy = p2\n\t}\n\n\treturn remotePolicy, true\n}\n\n// HopHintInfo contains the channel information required to create a hop hint.",
      "length": 2032,
      "tokens": 293,
      "embedding": []
    },
    {
      "slug": "type HopHintInfo struct {",
      "content": "type HopHintInfo struct {\n\t// IsPublic indicates whether a channel is advertised to the network.\n\tIsPublic bool\n\n\t// IsActive indicates whether the channel is online and available for\n\t// use.\n\tIsActive bool\n\n\t// FundingOutpoint is the funding txid:index for the channel.\n\tFundingOutpoint wire.OutPoint\n\n\t// RemotePubkey is the public key of the remote party that this channel\n\t// is in.\n\tRemotePubkey *btcec.PublicKey\n\n\t// RemoteBalance is the remote party's balance (our current incoming\n\t// capacity).\n\tRemoteBalance lnwire.MilliSatoshi\n\n\t// ShortChannelID is the short channel ID of the channel.\n\tShortChannelID uint64\n\n\t// ConfirmedScidZC is the confirmed SCID of a zero-conf channel. This\n\t// may be used for looking up a channel in the graph.\n\tConfirmedScidZC uint64\n\n\t// ScidAliasFeature denotes whether the channel has negotiated the\n\t// option-scid-alias feature bit.\n\tScidAliasFeature bool\n}\n",
      "length": 848,
      "tokens": 124,
      "embedding": []
    },
    {
      "slug": "func newHopHintInfo(c *channeldb.OpenChannel, isActive bool) *HopHintInfo {",
      "content": "func newHopHintInfo(c *channeldb.OpenChannel, isActive bool) *HopHintInfo {\n\tisPublic := c.ChannelFlags&lnwire.FFAnnounceChannel != 0\n\n\treturn &HopHintInfo{\n\t\tIsPublic:         isPublic,\n\t\tIsActive:         isActive,\n\t\tFundingOutpoint:  c.FundingOutpoint,\n\t\tRemotePubkey:     c.IdentityPub,\n\t\tRemoteBalance:    c.LocalCommitment.RemoteBalance,\n\t\tShortChannelID:   c.ShortChannelID.ToUint64(),\n\t\tConfirmedScidZC:  c.ZeroConfRealScid().ToUint64(),\n\t\tScidAliasFeature: c.ChanType.HasScidAliasFeature(),\n\t}\n}\n\n// newHopHint returns a new hop hint using the relevant data from a hopHintInfo\n// and a ChannelEdgePolicy.",
      "length": 522,
      "tokens": 43,
      "embedding": []
    },
    {
      "slug": "func newHopHint(hopHintInfo *HopHintInfo,",
      "content": "func newHopHint(hopHintInfo *HopHintInfo,\n\tchanPolicy *channeldb.ChannelEdgePolicy) zpay32.HopHint {\n\n\treturn zpay32.HopHint{\n\t\tNodeID:      hopHintInfo.RemotePubkey,\n\t\tChannelID:   hopHintInfo.ShortChannelID,\n\t\tFeeBaseMSat: uint32(chanPolicy.FeeBaseMSat),\n\t\tFeeProportionalMillionths: uint32(\n\t\t\tchanPolicy.FeeProportionalMillionths,\n\t\t),\n\t\tCLTVExpiryDelta: chanPolicy.TimeLockDelta,\n\t}\n}\n\n// SelectHopHintsCfg contains the dependencies required to obtain hop hints\n// for an invoice.",
      "length": 429,
      "tokens": 34,
      "embedding": []
    },
    {
      "slug": "type SelectHopHintsCfg struct {",
      "content": "type SelectHopHintsCfg struct {\n\t// IsPublicNode is returns a bool indicating whether the node with the\n\t// given public key is seen as a public node in the graph from the\n\t// graph's source node's point of view.\n\tIsPublicNode func(pubKey [33]byte) (bool, error)\n\n\t// FetchChannelEdgesByID attempts to lookup the two directed edges for\n\t// the channel identified by the channel ID.\n\tFetchChannelEdgesByID func(chanID uint64) (*channeldb.ChannelEdgeInfo,\n\t\t*channeldb.ChannelEdgePolicy, *channeldb.ChannelEdgePolicy,\n\t\terror)\n\n\t// GetAlias allows the peer's alias SCID to be retrieved for private\n\t// option_scid_alias channels.\n\tGetAlias func(lnwire.ChannelID) (lnwire.ShortChannelID, error)\n\n\t// FetchAllChannels retrieves all open channels currently stored\n\t// within the database.\n\tFetchAllChannels func() ([]*channeldb.OpenChannel, error)\n\n\t// IsChannelActive checks whether the channel identified by the provided\n\t// ChannelID is considered active.\n\tIsChannelActive func(chanID lnwire.ChannelID) bool\n\n\t// MaxHopHints is the maximum number of hop hints we are interested in.\n\tMaxHopHints int\n}\n",
      "length": 1041,
      "tokens": 134,
      "embedding": []
    },
    {
      "slug": "func newSelectHopHintsCfg(invoicesCfg *AddInvoiceConfig,",
      "content": "func newSelectHopHintsCfg(invoicesCfg *AddInvoiceConfig,\n\tmaxHopHints int) *SelectHopHintsCfg {\n\n\treturn &SelectHopHintsCfg{\n\t\tFetchAllChannels:      invoicesCfg.ChanDB.FetchAllChannels,\n\t\tIsChannelActive:       invoicesCfg.IsChannelActive,\n\t\tIsPublicNode:          invoicesCfg.Graph.IsPublicNode,\n\t\tFetchChannelEdgesByID: invoicesCfg.Graph.FetchChannelEdgesByID,\n\t\tGetAlias:              invoicesCfg.GetAlias,\n\t\tMaxHopHints:           maxHopHints,\n\t}\n}\n\n// sufficientHints checks whether we have sufficient hop hints, based on the\n// any of the following criteria:\n//   - Hop hint count: the number of hints have reach our max target.\n//   - Total incoming capacity (for non-zero invoice amounts): the sum of the\n//     remote balance amount in the hints is bigger of equal than our target\n//     (currently twice the invoice amount)\n//\n// We limit our number of hop hints like this to keep our invoice size down,\n// and to avoid leaking all our private channels when we don't need to.",
      "length": 909,
      "tokens": 116,
      "embedding": []
    },
    {
      "slug": "func sufficientHints(nHintsLeft int, currentAmount,",
      "content": "func sufficientHints(nHintsLeft int, currentAmount,\n\ttargetAmount lnwire.MilliSatoshi) bool {\n\n\tif nHintsLeft <= 0 {\n\t\tlog.Debugf(\"Reached targeted number of hop hints\")\n\t\treturn true\n\t}\n\n\tif targetAmount != 0 && currentAmount >= targetAmount {\n\t\tlog.Debugf(\"Total hint amount: %v has reached target hint \"+\n\t\t\t\"bandwidth: %v\", currentAmount, targetAmount)\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// getPotentialHints returns a slice of open channels that should be considered\n// for the hopHint list in an invoice. The slice is sorted in descending order\n// based on the remote balance.",
      "length": 512,
      "tokens": 79,
      "embedding": []
    },
    {
      "slug": "func getPotentialHints(cfg *SelectHopHintsCfg) ([]*channeldb.OpenChannel,",
      "content": "func getPotentialHints(cfg *SelectHopHintsCfg) ([]*channeldb.OpenChannel,\n\terror) {\n\n\t// TODO(positiveblue): get the channels slice already filtered by\n\t// private == true and sorted by RemoteBalance?\n\topenChannels, err := cfg.FetchAllChannels()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tprivateChannels := make([]*channeldb.OpenChannel, 0, len(openChannels))\n\tfor _, oc := range openChannels {\n\t\tisPublic := oc.ChannelFlags&lnwire.FFAnnounceChannel != 0\n\t\tif !isPublic {\n\t\t\tprivateChannels = append(privateChannels, oc)\n\t\t}\n\t}\n\n\t// Sort the channels in descending remote balance.\n\tcompareRemoteBalance := func(i, j int) bool {\n\t\tiBalance := privateChannels[i].LocalCommitment.RemoteBalance\n\t\tjBalance := privateChannels[j].LocalCommitment.RemoteBalance\n\t\treturn iBalance > jBalance\n\t}\n\tsort.Slice(privateChannels, compareRemoteBalance)\n\n\treturn privateChannels, nil\n}\n\n// shouldIncludeChannel returns true if the channel passes all the checks to\n// be a hopHint in a given invoice.",
      "length": 877,
      "tokens": 110,
      "embedding": []
    },
    {
      "slug": "func shouldIncludeChannel(cfg *SelectHopHintsCfg,",
      "content": "func shouldIncludeChannel(cfg *SelectHopHintsCfg,\n\tchannel *channeldb.OpenChannel,\n\talreadyIncluded map[uint64]bool) (zpay32.HopHint, lnwire.MilliSatoshi,\n\tbool) {\n\n\tif _, ok := alreadyIncluded[channel.ShortChannelID.ToUint64()]; ok {\n\t\treturn zpay32.HopHint{}, 0, false\n\t}\n\n\tchanID := lnwire.NewChanIDFromOutPoint(\n\t\t&channel.FundingOutpoint,\n\t)\n\n\thopHintInfo := newHopHintInfo(channel, cfg.IsChannelActive(chanID))\n\n\t// If this channel can't be a hop hint, then skip it.\n\tedgePolicy, canBeHopHint := chanCanBeHopHint(hopHintInfo, cfg)\n\tif edgePolicy == nil || !canBeHopHint {\n\t\treturn zpay32.HopHint{}, 0, false\n\t}\n\n\tif hopHintInfo.ScidAliasFeature {\n\t\talias, err := cfg.GetAlias(chanID)\n\t\tif err != nil {\n\t\t\treturn zpay32.HopHint{}, 0, false\n\t\t}\n\n\t\tif alias.IsDefault() || alreadyIncluded[alias.ToUint64()] {\n\t\t\treturn zpay32.HopHint{}, 0, false\n\t\t}\n\n\t\thopHintInfo.ShortChannelID = alias.ToUint64()\n\t}\n\n\t// Now that we know this channel use usable, add it as a hop hint and\n\t// the indexes we'll use later.\n\thopHint := newHopHint(hopHintInfo, edgePolicy)\n\treturn hopHint, hopHintInfo.RemoteBalance, true\n}\n\n// selectHopHints iterates a list of potential hints selecting the valid hop\n// hints until we have enough hints or run out of channels.\n//\n// NOTE: selectHopHints expects potentialHints to be already sorted in\n// descending priority.",
      "length": 1251,
      "tokens": 158,
      "embedding": []
    },
    {
      "slug": "func selectHopHints(cfg *SelectHopHintsCfg, nHintsLeft int,",
      "content": "func selectHopHints(cfg *SelectHopHintsCfg, nHintsLeft int,\n\ttargetBandwidth lnwire.MilliSatoshi,\n\tpotentialHints []*channeldb.OpenChannel,\n\talreadyIncluded map[uint64]bool) [][]zpay32.HopHint {\n\n\tcurrentBandwidth := lnwire.MilliSatoshi(0)\n\thopHints := make([][]zpay32.HopHint, 0, nHintsLeft)\n\tfor _, channel := range potentialHints {\n\t\tenoughHopHints := sufficientHints(\n\t\t\tnHintsLeft, currentBandwidth, targetBandwidth,\n\t\t)\n\t\tif enoughHopHints {\n\t\t\treturn hopHints\n\t\t}\n\n\t\thopHint, remoteBalance, include := shouldIncludeChannel(\n\t\t\tcfg, channel, alreadyIncluded,\n\t\t)\n\n\t\tif include {\n\t\t\t// Now that we now this channel use usable, add it as a hop\n\t\t\t// hint and the indexes we'll use later.\n\t\t\thopHints = append(hopHints, []zpay32.HopHint{hopHint})\n\t\t\tcurrentBandwidth += remoteBalance\n\t\t\tnHintsLeft--\n\t\t}\n\t}\n\n\t// We do not want to leak information about how our remote balance is\n\t// distributed in our private channels. We shuffle the selected ones\n\t// here so they do not appear in order in the invoice.\n\tmathRand.Shuffle(\n\t\tlen(hopHints), func(i, j int) {\n\t\t\thopHints[i], hopHints[j] = hopHints[j], hopHints[i]\n\t\t},\n\t)\n\treturn hopHints\n}\n\n// PopulateHopHints will select up to cfg.MaxHophints from the current open\n// channels. The set of hop hints will be returned as a slice of functional\n// options that'll append the route hint to the set of all route hints.\n//\n// TODO(roasbeef): do proper sub-set sum max hints usually << numChans.",
      "length": 1340,
      "tokens": 185,
      "embedding": []
    },
    {
      "slug": "func PopulateHopHints(cfg *SelectHopHintsCfg, amtMSat lnwire.MilliSatoshi,",
      "content": "func PopulateHopHints(cfg *SelectHopHintsCfg, amtMSat lnwire.MilliSatoshi,\n\tforcedHints [][]zpay32.HopHint) ([][]zpay32.HopHint, error) {\n\n\thopHints := forcedHints\n\n\t// If we already have enough hints we don't need to add any more.\n\tnHintsLeft := cfg.MaxHopHints - len(hopHints)\n\tif nHintsLeft <= 0 {\n\t\treturn hopHints, nil\n\t}\n\n\talreadyIncluded := make(map[uint64]bool)\n\tfor _, hopHint := range hopHints {\n\t\talreadyIncluded[hopHint[0].ChannelID] = true\n\t}\n\n\tpotentialHints, err := getPotentialHints(cfg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ttargetBandwidth := amtMSat * hopHintFactor\n\tselectedHints := selectHopHints(\n\t\tcfg, nHintsLeft, targetBandwidth, potentialHints,\n\t\talreadyIncluded,\n\t)\n\n\thopHints = append(hopHints, selectedHints...)\n\treturn hopHints, nil\n}\n",
      "length": 663,
      "tokens": 85,
      "embedding": []
    }
  ]
}