{
  "filepath": "../implementations/go/lnd/lnrpc/invoicesrpc/addinvoice_test.go",
  "package": "invoicesrpc",
  "sections": [
    {
      "slug": "type hopHintsConfigMock struct {",
      "content": "type hopHintsConfigMock struct {\n\tmock.Mock\n}\n\n// IsPublicNode mocks node public state lookup.",
      "length": 58,
      "tokens": 9,
      "embedding": []
    },
    {
      "slug": "func (h *hopHintsConfigMock) IsPublicNode(pubKey [33]byte) (bool, error) {",
      "content": "func (h *hopHintsConfigMock) IsPublicNode(pubKey [33]byte) (bool, error) {\n\targs := h.Mock.Called(pubKey)\n\treturn args.Bool(0), args.Error(1)\n}\n\n// IsChannelActive is used to generate valid hop hints.",
      "length": 121,
      "tokens": 16,
      "embedding": []
    },
    {
      "slug": "func (h *hopHintsConfigMock) IsChannelActive(chanID lnwire.ChannelID) bool {",
      "content": "func (h *hopHintsConfigMock) IsChannelActive(chanID lnwire.ChannelID) bool {\n\targs := h.Mock.Called(chanID)\n\treturn args.Bool(0)\n}\n\n// GetAlias allows the peer's alias SCID to be retrieved for private\n// option_scid_alias channels.",
      "length": 149,
      "tokens": 21,
      "embedding": []
    },
    {
      "slug": "func (h *hopHintsConfigMock) GetAlias(",
      "content": "func (h *hopHintsConfigMock) GetAlias(\n\tchanID lnwire.ChannelID) (lnwire.ShortChannelID, error) {\n\n\targs := h.Mock.Called(chanID)\n\treturn args.Get(0).(lnwire.ShortChannelID), args.Error(1)\n}\n\n// FetchAllChannels retrieves all open channels currently stored\n// within the database.",
      "length": 234,
      "tokens": 24,
      "embedding": []
    },
    {
      "slug": "func (h *hopHintsConfigMock) FetchAllChannels() ([]*channeldb.OpenChannel,",
      "content": "func (h *hopHintsConfigMock) FetchAllChannels() ([]*channeldb.OpenChannel,\n\terror) {\n\n\targs := h.Mock.Called()\n\treturn args.Get(0).([]*channeldb.OpenChannel), args.Error(1)\n}\n\n// FetchChannelEdgesByID attempts to lookup the two directed edges for\n// the channel identified by the channel ID.",
      "length": 209,
      "tokens": 27,
      "embedding": []
    },
    {
      "slug": "func (h *hopHintsConfigMock) FetchChannelEdgesByID(chanID uint64) (",
      "content": "func (h *hopHintsConfigMock) FetchChannelEdgesByID(chanID uint64) (\n\t*channeldb.ChannelEdgeInfo, *channeldb.ChannelEdgePolicy,\n\t*channeldb.ChannelEdgePolicy, error) {\n\n\targs := h.Mock.Called(chanID)\n\n\t// If our error is non-nil, we expect nil responses otherwise. Our\n\t// casts below will fail with nil values, so we check our error and\n\t// return early on failure first.\n\terr := args.Error(3)\n\tif err != nil {\n\t\treturn nil, nil, nil, err\n\t}\n\n\tedgeInfo := args.Get(0).(*channeldb.ChannelEdgeInfo)\n\tpolicy1 := args.Get(1).(*channeldb.ChannelEdgePolicy)\n\tpolicy2 := args.Get(2).(*channeldb.ChannelEdgePolicy)\n\n\treturn edgeInfo, policy1, policy2, err\n}\n\n// getTestPubKey returns a valid parsed pub key to be used in our tests.",
      "length": 635,
      "tokens": 83,
      "embedding": []
    },
    {
      "slug": "func getTestPubKey() *btcec.PublicKey {",
      "content": "func getTestPubKey() *btcec.PublicKey {\n\tpubkeyBytes, _ := hex.DecodeString(\n\t\t\"598ec453728e0ffe0ae2f5e174243cf58f2\" +\n\t\t\t\"a3f2c83d2457b43036db568b11093\",\n\t)\n\tpubKeyY := new(btcec.FieldVal)\n\t_ = pubKeyY.SetByteSlice(pubkeyBytes)\n\tpubkey := btcec.NewPublicKey(\n\t\tnew(btcec.FieldVal).SetInt(4),\n\t\tpubKeyY,\n\t)\n\treturn pubkey\n}\n\nvar shouldIncludeChannelTestCases = []struct {\n\tname            string\n\tsetupMock       func(*hopHintsConfigMock)\n\tchannel         *channeldb.OpenChannel\n\talreadyIncluded map[uint64]bool\n\tcfg             *SelectHopHintsCfg\n\thopHint         zpay32.HopHint\n\tremoteBalance   lnwire.MilliSatoshi\n\tinclude         bool\n}{{\n\tname: \"already included channels should not be included \" +\n\t\t\"again\",\n\talreadyIncluded: map[uint64]bool{1: true},\n\tchannel: &channeldb.OpenChannel{\n\t\tShortChannelID: lnwire.NewShortChanIDFromInt(1),\n\t},\n\tinclude: false,\n}, {\n\tname: \"public channels should not be included\",\n\tsetupMock: func(h *hopHintsConfigMock) {\n\t\tfundingOutpoint := wire.OutPoint{\n\t\t\tIndex: 0,\n\t\t}\n\t\tchanID := lnwire.NewChanIDFromOutPoint(&fundingOutpoint)\n\t\th.Mock.On(\n\t\t\t\"IsChannelActive\", chanID,\n\t\t).Once().Return(true)\n\t},\n\tchannel: &channeldb.OpenChannel{\n\t\tFundingOutpoint: wire.OutPoint{\n\t\t\tIndex: 0,\n\t\t},\n\t\tChannelFlags: lnwire.FFAnnounceChannel,\n\t},\n}, {\n\tname: \"not active channels should not be included\",\n\tsetupMock: func(h *hopHintsConfigMock) {\n\t\tfundingOutpoint := wire.OutPoint{\n\t\t\tIndex: 0,\n\t\t}\n\t\tchanID := lnwire.NewChanIDFromOutPoint(&fundingOutpoint)\n\t\th.Mock.On(\n\t\t\t\"IsChannelActive\", chanID,\n\t\t).Once().Return(false)\n\t},\n\tchannel: &channeldb.OpenChannel{\n\t\tFundingOutpoint: wire.OutPoint{\n\t\t\tIndex: 0,\n\t\t},\n\t},\n\tinclude: false,\n}, {\n\tname: \"a channel with a not public peer should not be included\",\n\tsetupMock: func(h *hopHintsConfigMock) {\n\t\tfundingOutpoint := wire.OutPoint{\n\t\t\tIndex: 0,\n\t\t}\n\t\tchanID := lnwire.NewChanIDFromOutPoint(&fundingOutpoint)\n\n\t\th.Mock.On(\n\t\t\t\"IsChannelActive\", chanID,\n\t\t).Once().Return(true)\n\n\t\th.Mock.On(\n\t\t\t\"IsPublicNode\", mock.Anything,\n\t\t).Once().Return(false, nil)\n\t},\n\tchannel: &channeldb.OpenChannel{\n\t\tFundingOutpoint: wire.OutPoint{\n\t\t\tIndex: 0,\n\t\t},\n\t\tIdentityPub: getTestPubKey(),\n\t},\n\tinclude: false,\n}, {\n\tname: \"if we are unable to fetch the edge policy for the channel it \" +\n\t\t\"should not be included\",\n\tsetupMock: func(h *hopHintsConfigMock) {\n\t\tfundingOutpoint := wire.OutPoint{\n\t\t\tIndex: 0,\n\t\t}\n\t\tchanID := lnwire.NewChanIDFromOutPoint(&fundingOutpoint)\n\n\t\th.Mock.On(\n\t\t\t\"IsChannelActive\", chanID,\n\t\t).Once().Return(true)\n\n\t\th.Mock.On(\n\t\t\t\"IsPublicNode\", mock.Anything,\n\t\t).Once().Return(true, nil)\n\n\t\th.Mock.On(\n\t\t\t\"FetchChannelEdgesByID\", mock.Anything,\n\t\t).Once().Return(nil, nil, nil, fmt.Errorf(\"no edge\"))\n\n\t\t// TODO(positiveblue): check that the func is called with the\n\t\t// right scid when we have access to the `confirmedscid` form\n\t\t// here.\n\t\th.Mock.On(\n\t\t\t\"FetchChannelEdgesByID\", mock.Anything,\n\t\t).Once().Return(nil, nil, nil, fmt.Errorf(\"no edge\"))\n\t},\n\tchannel: &channeldb.OpenChannel{\n\t\tFundingOutpoint: wire.OutPoint{\n\t\t\tIndex: 0,\n\t\t},\n\t\tIdentityPub: getTestPubKey(),\n\t},\n\tinclude: false,\n}, {\n\tname: \"channels with the option-scid-alias but not assigned alias \" +\n\t\t\"yet should not be included\",\n\tsetupMock: func(h *hopHintsConfigMock) {\n\t\tfundingOutpoint := wire.OutPoint{\n\t\t\tIndex: 0,\n\t\t}\n\t\tchanID := lnwire.NewChanIDFromOutPoint(&fundingOutpoint)\n\n\t\th.Mock.On(\n\t\t\t\"IsChannelActive\", chanID,\n\t\t).Once().Return(true)\n\n\t\th.Mock.On(\n\t\t\t\"IsPublicNode\", mock.Anything,\n\t\t).Once().Return(true, nil)\n\n\t\th.Mock.On(\n\t\t\t\"FetchChannelEdgesByID\", mock.Anything,\n\t\t).Once().Return(\n\t\t\t&channeldb.ChannelEdgeInfo{},\n\t\t\t&channeldb.ChannelEdgePolicy{},\n\t\t\t&channeldb.ChannelEdgePolicy{}, nil,\n\t\t)\n\n\t\th.Mock.On(\n\t\t\t\"GetAlias\", mock.Anything,\n\t\t).Once().Return(lnwire.ShortChannelID{}, nil)\n\t},\n\tchannel: &channeldb.OpenChannel{\n\t\tFundingOutpoint: wire.OutPoint{\n\t\t\tIndex: 0,\n\t\t},\n\t\tIdentityPub: getTestPubKey(),\n\t\tChanType:    channeldb.ScidAliasFeatureBit,\n\t},\n\tinclude: false,\n}, {\n\tname: \"channels with the option-scid-alias and an alias that has \" +\n\t\t\"already been included should not be included again\",\n\talreadyIncluded: map[uint64]bool{5: true},\n\tsetupMock: func(h *hopHintsConfigMock) {\n\t\tfundingOutpoint := wire.OutPoint{\n\t\t\tIndex: 0,\n\t\t}\n\t\tchanID := lnwire.NewChanIDFromOutPoint(&fundingOutpoint)\n\n\t\th.Mock.On(\n\t\t\t\"IsChannelActive\", chanID,\n\t\t).Once().Return(true)\n\n\t\th.Mock.On(\n\t\t\t\"IsPublicNode\", mock.Anything,\n\t\t).Once().Return(true, nil)\n\n\t\th.Mock.On(\n\t\t\t\"FetchChannelEdgesByID\", mock.Anything,\n\t\t).Once().Return(\n\t\t\t&channeldb.ChannelEdgeInfo{},\n\t\t\t&channeldb.ChannelEdgePolicy{},\n\t\t\t&channeldb.ChannelEdgePolicy{}, nil,\n\t\t)\n\t\talias := lnwire.ShortChannelID{TxPosition: 5}\n\t\th.Mock.On(\n\t\t\t\"GetAlias\", mock.Anything,\n\t\t).Once().Return(alias, nil)\n\t},\n\tchannel: &channeldb.OpenChannel{\n\t\tFundingOutpoint: wire.OutPoint{\n\t\t\tIndex: 0,\n\t\t},\n\t\tIdentityPub: getTestPubKey(),\n\t\tChanType:    channeldb.ScidAliasFeatureBit,\n\t},\n\tinclude: false,\n}, {\n\tname: \"channels that pass all the checks should be \" +\n\t\t\"included, using policy 1\",\n\talreadyIncluded: map[uint64]bool{5: true},\n\tsetupMock: func(h *hopHintsConfigMock) {\n\t\tfundingOutpoint := wire.OutPoint{\n\t\t\tIndex: 1,\n\t\t}\n\t\tchanID := lnwire.NewChanIDFromOutPoint(&fundingOutpoint)\n\n\t\th.Mock.On(\n\t\t\t\"IsChannelActive\", chanID,\n\t\t).Once().Return(true)\n\n\t\th.Mock.On(\n\t\t\t\"IsPublicNode\", mock.Anything,\n\t\t).Once().Return(true, nil)\n\n\t\tvar selectedPolicy [33]byte\n\t\tcopy(selectedPolicy[:], getTestPubKey().SerializeCompressed())\n\n\t\th.Mock.On(\n\t\t\t\"FetchChannelEdgesByID\", mock.Anything,\n\t\t).Once().Return(\n\t\t\t&channeldb.ChannelEdgeInfo{\n\t\t\t\tNodeKey1Bytes: selectedPolicy,\n\t\t\t},\n\t\t\t&channeldb.ChannelEdgePolicy{\n\t\t\t\tFeeBaseMSat:               1000,\n\t\t\t\tFeeProportionalMillionths: 20,\n\t\t\t\tTimeLockDelta:             13,\n\t\t\t},\n\t\t\t&channeldb.ChannelEdgePolicy{},\n\t\t\tnil,\n\t\t)\n\t},\n\tchannel: &channeldb.OpenChannel{\n\t\tFundingOutpoint: wire.OutPoint{\n\t\t\tIndex: 1,\n\t\t},\n\t\tIdentityPub:    getTestPubKey(),\n\t\tShortChannelID: lnwire.NewShortChanIDFromInt(12),\n\t},\n\thopHint: zpay32.HopHint{\n\t\tNodeID:                    getTestPubKey(),\n\t\tFeeBaseMSat:               1000,\n\t\tFeeProportionalMillionths: 20,\n\t\tChannelID:                 12,\n\t\tCLTVExpiryDelta:           13,\n\t},\n\tinclude: true,\n}, {\n\tname: \"channels that pass all the checks should be \" +\n\t\t\"included, using policy 2\",\n\talreadyIncluded: map[uint64]bool{5: true},\n\tsetupMock: func(h *hopHintsConfigMock) {\n\t\tfundingOutpoint := wire.OutPoint{\n\t\t\tIndex: 1,\n\t\t}\n\t\tchanID := lnwire.NewChanIDFromOutPoint(&fundingOutpoint)\n\n\t\th.Mock.On(\n\t\t\t\"IsChannelActive\", chanID,\n\t\t).Once().Return(true)\n\n\t\th.Mock.On(\n\t\t\t\"IsPublicNode\", mock.Anything,\n\t\t).Once().Return(true, nil)\n\n\t\th.Mock.On(\n\t\t\t\"FetchChannelEdgesByID\", mock.Anything,\n\t\t).Once().Return(\n\t\t\t&channeldb.ChannelEdgeInfo{},\n\t\t\t&channeldb.ChannelEdgePolicy{},\n\t\t\t&channeldb.ChannelEdgePolicy{\n\t\t\t\tFeeBaseMSat:               1000,\n\t\t\t\tFeeProportionalMillionths: 20,\n\t\t\t\tTimeLockDelta:             13,\n\t\t\t}, nil,\n\t\t)\n\t},\n\tchannel: &channeldb.OpenChannel{\n\t\tFundingOutpoint: wire.OutPoint{\n\t\t\tIndex: 1,\n\t\t},\n\t\tIdentityPub:    getTestPubKey(),\n\t\tShortChannelID: lnwire.NewShortChanIDFromInt(12),\n\t},\n\thopHint: zpay32.HopHint{\n\t\tNodeID:                    getTestPubKey(),\n\t\tFeeBaseMSat:               1000,\n\t\tFeeProportionalMillionths: 20,\n\t\tChannelID:                 12,\n\t\tCLTVExpiryDelta:           13,\n\t},\n\tinclude: true,\n}, {\n\tname: \"channels that pass all the checks and have an alias \" +\n\t\t\"should be included with the alias\",\n\talreadyIncluded: map[uint64]bool{5: true},\n\tsetupMock: func(h *hopHintsConfigMock) {\n\t\tfundingOutpoint := wire.OutPoint{\n\t\t\tIndex: 1,\n\t\t}\n\t\tchanID := lnwire.NewChanIDFromOutPoint(&fundingOutpoint)\n\n\t\th.Mock.On(\n\t\t\t\"IsChannelActive\", chanID,\n\t\t).Once().Return(true)\n\n\t\th.Mock.On(\n\t\t\t\"IsPublicNode\", mock.Anything,\n\t\t).Once().Return(true, nil)\n\n\t\th.Mock.On(\n\t\t\t\"FetchChannelEdgesByID\", mock.Anything,\n\t\t).Once().Return(\n\t\t\t&channeldb.ChannelEdgeInfo{},\n\t\t\t&channeldb.ChannelEdgePolicy{},\n\t\t\t&channeldb.ChannelEdgePolicy{\n\t\t\t\tFeeBaseMSat:               1000,\n\t\t\t\tFeeProportionalMillionths: 20,\n\t\t\t\tTimeLockDelta:             13,\n\t\t\t}, nil,\n\t\t)\n\n\t\taliasSCID := lnwire.NewShortChanIDFromInt(15)\n\n\t\th.Mock.On(\n\t\t\t\"GetAlias\", mock.Anything,\n\t\t).Once().Return(aliasSCID, nil)\n\t},\n\tchannel: &channeldb.OpenChannel{\n\t\tFundingOutpoint: wire.OutPoint{\n\t\t\tIndex: 1,\n\t\t},\n\t\tIdentityPub:    getTestPubKey(),\n\t\tShortChannelID: lnwire.NewShortChanIDFromInt(12),\n\t\tChanType:       channeldb.ScidAliasFeatureBit,\n\t},\n\thopHint: zpay32.HopHint{\n\t\tNodeID:                    getTestPubKey(),\n\t\tFeeBaseMSat:               1000,\n\t\tFeeProportionalMillionths: 20,\n\t\tChannelID:                 15,\n\t\tCLTVExpiryDelta:           13,\n\t},\n\tinclude: true,\n}}\n",
      "length": 8310,
      "tokens": 716,
      "embedding": []
    },
    {
      "slug": "func TestShouldIncludeChannel(t *testing.T) {",
      "content": "func TestShouldIncludeChannel(t *testing.T) {\n\tfor _, tc := range shouldIncludeChannelTestCases {\n\t\ttc := tc\n\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\t// Create mock and prime it for the test case.\n\t\t\tmock := &hopHintsConfigMock{}\n\t\t\tif tc.setupMock != nil {\n\t\t\t\ttc.setupMock(mock)\n\t\t\t}\n\t\t\tdefer mock.AssertExpectations(t)\n\n\t\t\tcfg := &SelectHopHintsCfg{\n\t\t\t\tIsPublicNode:          mock.IsPublicNode,\n\t\t\t\tIsChannelActive:       mock.IsChannelActive,\n\t\t\t\tFetchChannelEdgesByID: mock.FetchChannelEdgesByID,\n\t\t\t\tGetAlias:              mock.GetAlias,\n\t\t\t}\n\n\t\t\thopHint, remoteBalance, include := shouldIncludeChannel(\n\t\t\t\tcfg, tc.channel, tc.alreadyIncluded,\n\t\t\t)\n\n\t\t\trequire.Equal(t, tc.include, include)\n\t\t\tif include {\n\t\t\t\trequire.Equal(t, tc.hopHint, hopHint)\n\t\t\t\trequire.Equal(\n\t\t\t\t\tt, tc.remoteBalance, remoteBalance,\n\t\t\t\t)\n\t\t\t}\n\t\t})\n\t}\n}\n\nvar sufficientHintsTestCases = []struct {\n\tname          string\n\tnHintsLeft    int\n\tcurrentAmount lnwire.MilliSatoshi\n\ttargetAmount  lnwire.MilliSatoshi\n\tdone          bool\n}{{\n\tname:          \"not enough hints neither bandwidth\",\n\tnHintsLeft:    3,\n\tcurrentAmount: 100,\n\ttargetAmount:  200,\n\tdone:          false,\n}, {\n\tname:       \"enough hints\",\n\tnHintsLeft: 0,\n\tdone:       true,\n}, {\n\tname:          \"enough bandwidth\",\n\tnHintsLeft:    1,\n\tcurrentAmount: 200,\n\ttargetAmount:  200,\n\tdone:          true,\n}, {\n\tname:          \"no amount provided\",\n\tnHintsLeft:    1,\n\tcurrentAmount: 100,\n\ttargetAmount:  0,\n\tdone:          false,\n}}\n",
      "length": 1383,
      "tokens": 143,
      "embedding": []
    },
    {
      "slug": "func TestSufficientHints(t *testing.T) {",
      "content": "func TestSufficientHints(t *testing.T) {\n\tfor _, tc := range sufficientHintsTestCases {\n\t\ttc := tc\n\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tenoughHints := sufficientHints(\n\t\t\t\ttc.nHintsLeft, tc.currentAmount,\n\t\t\t\ttc.targetAmount,\n\t\t\t)\n\t\t\trequire.Equal(t, tc.done, enoughHints)\n\t\t})\n\t}\n}\n\nvar populateHopHintsTestCases = []struct {\n\tname             string\n\tsetupMock        func(*hopHintsConfigMock)\n\tamount           lnwire.MilliSatoshi\n\tmaxHopHints      int\n\tforcedHints      [][]zpay32.HopHint\n\texpectedHopHints [][]zpay32.HopHint\n}{{\n\tname:        \"populate hop hints with forced hints\",\n\tmaxHopHints: 1,\n\tforcedHints: [][]zpay32.HopHint{\n\t\t{\n\t\t\t{ChannelID: 12},\n\t\t},\n\t},\n\texpectedHopHints: [][]zpay32.HopHint{\n\t\t{\n\t\t\t{ChannelID: 12},\n\t\t},\n\t},\n}, {\n\tname: \"populate hop hints stops when we reached the max number of \" +\n\t\t\"hop hints allowed\",\n\tsetupMock: func(h *hopHintsConfigMock) {\n\t\tfundingOutpoint := wire.OutPoint{Index: 9}\n\t\tchanID := lnwire.NewChanIDFromOutPoint(&fundingOutpoint)\n\t\tallChannels := []*channeldb.OpenChannel{\n\t\t\t{\n\t\t\t\tFundingOutpoint: fundingOutpoint,\n\t\t\t\tShortChannelID:  lnwire.NewShortChanIDFromInt(9),\n\t\t\t\tIdentityPub:     getTestPubKey(),\n\t\t\t},\n\t\t\t// Have one empty channel that we should not process\n\t\t\t// because we have already finished.\n\t\t\t{},\n\t\t}\n\n\t\th.Mock.On(\n\t\t\t\"FetchAllChannels\",\n\t\t).Once().Return(allChannels, nil)\n\n\t\th.Mock.On(\n\t\t\t\"IsChannelActive\", chanID,\n\t\t).Once().Return(true)\n\n\t\th.Mock.On(\n\t\t\t\"IsPublicNode\", mock.Anything,\n\t\t).Once().Return(true, nil)\n\n\t\th.Mock.On(\n\t\t\t\"FetchChannelEdgesByID\", mock.Anything,\n\t\t).Once().Return(\n\t\t\t&channeldb.ChannelEdgeInfo{},\n\t\t\t&channeldb.ChannelEdgePolicy{},\n\t\t\t&channeldb.ChannelEdgePolicy{}, nil,\n\t\t)\n\t},\n\tmaxHopHints: 1,\n\tamount:      1_000_000,\n\texpectedHopHints: [][]zpay32.HopHint{\n\t\t{\n\t\t\t{\n\t\t\t\tNodeID:    getTestPubKey(),\n\t\t\t\tChannelID: 9,\n\t\t\t},\n\t\t},\n\t},\n}, {\n\tname: \"populate hop hints stops when we reached the targeted bandwidth\",\n\tsetupMock: func(h *hopHintsConfigMock) {\n\t\tfundingOutpoint := wire.OutPoint{Index: 9}\n\t\tchanID := lnwire.NewChanIDFromOutPoint(&fundingOutpoint)\n\t\tremoteBalance := lnwire.MilliSatoshi(10_000_000)\n\t\tallChannels := []*channeldb.OpenChannel{\n\t\t\t{\n\t\t\t\tLocalCommitment: channeldb.ChannelCommitment{\n\t\t\t\t\tRemoteBalance: remoteBalance,\n\t\t\t\t},\n\t\t\t\tFundingOutpoint: fundingOutpoint,\n\t\t\t\tShortChannelID:  lnwire.NewShortChanIDFromInt(9),\n\t\t\t\tIdentityPub:     getTestPubKey(),\n\t\t\t},\n\t\t\t// Have one empty channel that we should not process\n\t\t\t// because we have already finished.\n\t\t\t{},\n\t\t}\n\n\t\th.Mock.On(\n\t\t\t\"FetchAllChannels\",\n\t\t).Once().Return(allChannels, nil)\n\n\t\th.Mock.On(\n\t\t\t\"IsChannelActive\", chanID,\n\t\t).Once().Return(true)\n\n\t\th.Mock.On(\n\t\t\t\"IsPublicNode\", mock.Anything,\n\t\t).Once().Return(true, nil)\n\n\t\th.Mock.On(\n\t\t\t\"FetchChannelEdgesByID\", mock.Anything,\n\t\t).Once().Return(\n\t\t\t&channeldb.ChannelEdgeInfo{},\n\t\t\t&channeldb.ChannelEdgePolicy{},\n\t\t\t&channeldb.ChannelEdgePolicy{}, nil,\n\t\t)\n\t},\n\tmaxHopHints: 10,\n\tamount:      1_000_000,\n\texpectedHopHints: [][]zpay32.HopHint{\n\t\t{\n\t\t\t{\n\t\t\t\tNodeID:    getTestPubKey(),\n\t\t\t\tChannelID: 9,\n\t\t\t},\n\t\t},\n\t},\n}, {\n\tname: \"populate hop hints tries to use the channels with higher \" +\n\t\t\"remote balance frist\",\n\tsetupMock: func(h *hopHintsConfigMock) {\n\t\tfundingOutpoint := wire.OutPoint{Index: 9}\n\t\tchanID := lnwire.NewChanIDFromOutPoint(&fundingOutpoint)\n\t\tremoteBalance := lnwire.MilliSatoshi(10_000_000)\n\t\tallChannels := []*channeldb.OpenChannel{\n\t\t\t// Because the channels with higher remote balance have\n\t\t\t// enough bandwidth we should never use this one.\n\t\t\t{},\n\t\t\t{\n\t\t\t\tLocalCommitment: channeldb.ChannelCommitment{\n\t\t\t\t\tRemoteBalance: remoteBalance,\n\t\t\t\t},\n\t\t\t\tFundingOutpoint: fundingOutpoint,\n\t\t\t\tShortChannelID:  lnwire.NewShortChanIDFromInt(9),\n\t\t\t\tIdentityPub:     getTestPubKey(),\n\t\t\t},\n\t\t}\n\n\t\th.Mock.On(\n\t\t\t\"FetchAllChannels\",\n\t\t).Once().Return(allChannels, nil)\n\n\t\th.Mock.On(\n\t\t\t\"IsChannelActive\", chanID,\n\t\t).Once().Return(true)\n\n\t\th.Mock.On(\n\t\t\t\"IsPublicNode\", mock.Anything,\n\t\t).Once().Return(true, nil)\n\n\t\th.Mock.On(\n\t\t\t\"FetchChannelEdgesByID\", mock.Anything,\n\t\t).Once().Return(\n\t\t\t&channeldb.ChannelEdgeInfo{},\n\t\t\t&channeldb.ChannelEdgePolicy{},\n\t\t\t&channeldb.ChannelEdgePolicy{}, nil,\n\t\t)\n\t},\n\tmaxHopHints: 1,\n\tamount:      1_000_000,\n\texpectedHopHints: [][]zpay32.HopHint{\n\t\t{\n\t\t\t{\n\t\t\t\tNodeID:    getTestPubKey(),\n\t\t\t\tChannelID: 9,\n\t\t\t},\n\t\t},\n\t},\n}, {\n\tname: \"populate hop hints stops after having considered all the open \" +\n\t\t\"channels\",\n\tsetupMock: func(h *hopHintsConfigMock) {\n\t\tchanID1, chanID2 := setupMockTwoChannels(h)\n\n\t\t// Prepare the mock for the first channel.\n\t\th.Mock.On(\n\t\t\t\"IsChannelActive\", chanID1,\n\t\t).Once().Return(true)\n\n\t\th.Mock.On(\n\t\t\t\"IsPublicNode\", mock.Anything,\n\t\t).Once().Return(true, nil)\n\n\t\th.Mock.On(\n\t\t\t\"FetchChannelEdgesByID\", mock.Anything,\n\t\t).Once().Return(\n\t\t\t&channeldb.ChannelEdgeInfo{},\n\t\t\t&channeldb.ChannelEdgePolicy{},\n\t\t\t&channeldb.ChannelEdgePolicy{}, nil,\n\t\t)\n\n\t\t// Prepare the mock for the second channel.\n\t\th.Mock.On(\n\t\t\t\"IsChannelActive\", chanID2,\n\t\t).Once().Return(true)\n\n\t\th.Mock.On(\n\t\t\t\"IsPublicNode\", mock.Anything,\n\t\t).Once().Return(true, nil)\n\n\t\th.Mock.On(\n\t\t\t\"FetchChannelEdgesByID\", mock.Anything,\n\t\t).Once().Return(\n\t\t\t&channeldb.ChannelEdgeInfo{},\n\t\t\t&channeldb.ChannelEdgePolicy{},\n\t\t\t&channeldb.ChannelEdgePolicy{}, nil,\n\t\t)\n\t},\n\tmaxHopHints: 10,\n\tamount:      100_000_000,\n\texpectedHopHints: [][]zpay32.HopHint{\n\t\t{\n\t\t\t{\n\t\t\t\tNodeID:    getTestPubKey(),\n\t\t\t\tChannelID: 9,\n\t\t\t},\n\t\t}, {\n\t\t\t{\n\t\t\t\tNodeID:    getTestPubKey(),\n\t\t\t\tChannelID: 2,\n\t\t\t},\n\t\t},\n\t},\n}, {\n\tname: \"consider all the open channels when amount is zero\",\n\tsetupMock: func(h *hopHintsConfigMock) {\n\t\tchanID1, chanID2 := setupMockTwoChannels(h)\n\n\t\t// Prepare the mock for the first channel.\n\t\th.Mock.On(\n\t\t\t\"IsChannelActive\", chanID1,\n\t\t).Once().Return(true)\n\n\t\th.Mock.On(\n\t\t\t\"IsPublicNode\", mock.Anything,\n\t\t).Once().Return(true, nil)\n\n\t\th.Mock.On(\n\t\t\t\"FetchChannelEdgesByID\", mock.Anything,\n\t\t).Once().Return(\n\t\t\t&channeldb.ChannelEdgeInfo{},\n\t\t\t&channeldb.ChannelEdgePolicy{},\n\t\t\t&channeldb.ChannelEdgePolicy{}, nil,\n\t\t)\n\n\t\t// Prepare the mock for the second channel.\n\t\th.Mock.On(\n\t\t\t\"IsChannelActive\", chanID2,\n\t\t).Once().Return(true)\n\n\t\th.Mock.On(\n\t\t\t\"IsPublicNode\", mock.Anything,\n\t\t).Once().Return(true, nil)\n\n\t\th.Mock.On(\n\t\t\t\"FetchChannelEdgesByID\", mock.Anything,\n\t\t).Once().Return(\n\t\t\t&channeldb.ChannelEdgeInfo{},\n\t\t\t&channeldb.ChannelEdgePolicy{},\n\t\t\t&channeldb.ChannelEdgePolicy{}, nil,\n\t\t)\n\t},\n\tmaxHopHints: 10,\n\tamount:      0,\n\texpectedHopHints: [][]zpay32.HopHint{\n\t\t{\n\t\t\t{\n\t\t\t\tNodeID:    getTestPubKey(),\n\t\t\t\tChannelID: 9,\n\t\t\t},\n\t\t}, {\n\t\t\t{\n\t\t\t\tNodeID:    getTestPubKey(),\n\t\t\t\tChannelID: 2,\n\t\t\t},\n\t\t},\n\t},\n}, {\n\tname: \"consider all the open channels when amount is zero\" +\n\t\t\" up to maxHopHints\",\n\tsetupMock: func(h *hopHintsConfigMock) {\n\t\tchanID1, _ := setupMockTwoChannels(h)\n\n\t\t// Prepare the mock for the first channel.\n\t\th.Mock.On(\n\t\t\t\"IsChannelActive\", chanID1,\n\t\t).Once().Return(true)\n\n\t\th.Mock.On(\n\t\t\t\"IsPublicNode\", mock.Anything,\n\t\t).Once().Return(true, nil)\n\n\t\th.Mock.On(\n\t\t\t\"FetchChannelEdgesByID\", mock.Anything,\n\t\t).Once().Return(\n\t\t\t&channeldb.ChannelEdgeInfo{},\n\t\t\t&channeldb.ChannelEdgePolicy{},\n\t\t\t&channeldb.ChannelEdgePolicy{}, nil,\n\t\t)\n\t},\n\tmaxHopHints: 1,\n\tamount:      0,\n\texpectedHopHints: [][]zpay32.HopHint{\n\t\t{\n\t\t\t{\n\t\t\t\tNodeID:    getTestPubKey(),\n\t\t\t\tChannelID: 9,\n\t\t\t},\n\t\t},\n\t},\n}}\n",
      "length": 6995,
      "tokens": 635,
      "embedding": []
    },
    {
      "slug": "func setupMockTwoChannels(h *hopHintsConfigMock) (lnwire.ChannelID,",
      "content": "func setupMockTwoChannels(h *hopHintsConfigMock) (lnwire.ChannelID,\n\tlnwire.ChannelID) {\n\n\tfundingOutpoint1 := wire.OutPoint{Index: 9}\n\tchanID1 := lnwire.NewChanIDFromOutPoint(&fundingOutpoint1)\n\tremoteBalance1 := lnwire.MilliSatoshi(10_000_000)\n\n\tfundingOutpoint2 := wire.OutPoint{Index: 2}\n\tchanID2 := lnwire.NewChanIDFromOutPoint(&fundingOutpoint2)\n\tremoteBalance2 := lnwire.MilliSatoshi(1_000_000)\n\n\tallChannels := []*channeldb.OpenChannel{\n\t\t// After sorting we will first process chanID1 and then\n\t\t// chanID2.\n\t\t{\n\t\t\tLocalCommitment: channeldb.ChannelCommitment{\n\t\t\t\tRemoteBalance: remoteBalance2,\n\t\t\t},\n\t\t\tFundingOutpoint: fundingOutpoint2,\n\t\t\tShortChannelID:  lnwire.NewShortChanIDFromInt(2),\n\t\t\tIdentityPub:     getTestPubKey(),\n\t\t},\n\t\t{\n\t\t\tLocalCommitment: channeldb.ChannelCommitment{\n\t\t\t\tRemoteBalance: remoteBalance1,\n\t\t\t},\n\t\t\tFundingOutpoint: fundingOutpoint1,\n\t\t\tShortChannelID:  lnwire.NewShortChanIDFromInt(9),\n\t\t\tIdentityPub:     getTestPubKey(),\n\t\t},\n\t}\n\n\th.Mock.On(\n\t\t\"FetchAllChannels\",\n\t).Once().Return(allChannels, nil)\n\n\treturn chanID1, chanID2\n}\n",
      "length": 967,
      "tokens": 72,
      "embedding": []
    },
    {
      "slug": "func TestPopulateHopHints(t *testing.T) {",
      "content": "func TestPopulateHopHints(t *testing.T) {\n\tfor _, tc := range populateHopHintsTestCases {\n\t\ttc := tc\n\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\t// Create mock and prime it for the test case.\n\t\t\tmock := &hopHintsConfigMock{}\n\t\t\tif tc.setupMock != nil {\n\t\t\t\ttc.setupMock(mock)\n\t\t\t}\n\t\t\tdefer mock.AssertExpectations(t)\n\n\t\t\tcfg := &SelectHopHintsCfg{\n\t\t\t\tIsPublicNode:          mock.IsPublicNode,\n\t\t\t\tIsChannelActive:       mock.IsChannelActive,\n\t\t\t\tFetchChannelEdgesByID: mock.FetchChannelEdgesByID,\n\t\t\t\tGetAlias:              mock.GetAlias,\n\t\t\t\tFetchAllChannels:      mock.FetchAllChannels,\n\t\t\t\tMaxHopHints:           tc.maxHopHints,\n\t\t\t}\n\t\t\thopHints, err := PopulateHopHints(\n\t\t\t\tcfg, tc.amount, tc.forcedHints,\n\t\t\t)\n\t\t\trequire.NoError(t, err)\n\t\t\t// We shuffle the elements in the hop hint list so we\n\t\t\t// need to compare the elements here.\n\t\t\trequire.ElementsMatch(t, tc.expectedHopHints, hopHints)\n\t\t})\n\t}\n}\n",
      "length": 853,
      "tokens": 88,
      "embedding": []
    }
  ]
}