{
  "filepath": "../implementations/go/lnd/lnrpc/invoicesrpc/utils.go",
  "package": "invoicesrpc",
  "sections": [
    {
      "slug": "func decodePayReq(invoice *invoices.Invoice,",
      "content": "func decodePayReq(invoice *invoices.Invoice,\n\tactiveNetParams *chaincfg.Params) (*zpay32.Invoice, error) {\n\n\tpaymentRequest := string(invoice.PaymentRequest)\n\tif paymentRequest == \"\" {\n\t\tpreimage := invoice.Terms.PaymentPreimage\n\t\tif preimage == nil {\n\t\t\treturn &zpay32.Invoice{}, nil\n\t\t}\n\t\thash := [32]byte(preimage.Hash())\n\t\treturn &zpay32.Invoice{\n\t\t\tPaymentHash: &hash,\n\t\t}, nil\n\t}\n\n\tvar err error\n\tdecoded, err := zpay32.Decode(paymentRequest, activeNetParams)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to decode payment \"+\n\t\t\t\"request: %v\", err)\n\t}\n\treturn decoded, nil\n}\n\n// CreateRPCInvoice creates an *lnrpc.Invoice from the *invoices.Invoice.",
      "length": 592,
      "tokens": 71,
      "embedding": []
    },
    {
      "slug": "func CreateRPCInvoice(invoice *invoices.Invoice,",
      "content": "func CreateRPCInvoice(invoice *invoices.Invoice,\n\tactiveNetParams *chaincfg.Params) (*lnrpc.Invoice, error) {\n\n\tdecoded, err := decodePayReq(invoice, activeNetParams)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar rHash []byte\n\tif decoded.PaymentHash != nil {\n\t\trHash = decoded.PaymentHash[:]\n\t}\n\n\tvar descHash []byte\n\tif decoded.DescriptionHash != nil {\n\t\tdescHash = decoded.DescriptionHash[:]\n\t}\n\n\tfallbackAddr := \"\"\n\tif decoded.FallbackAddr != nil {\n\t\tfallbackAddr = decoded.FallbackAddr.String()\n\t}\n\n\tsettleDate := int64(0)\n\tif !invoice.SettleDate.IsZero() {\n\t\tsettleDate = invoice.SettleDate.Unix()\n\t}\n\n\t// Convert between the `lnrpc` and `routing` types.\n\trouteHints := CreateRPCRouteHints(decoded.RouteHints)\n\n\tpreimage := invoice.Terms.PaymentPreimage\n\tsatAmt := invoice.Terms.Value.ToSatoshis()\n\tsatAmtPaid := invoice.AmtPaid.ToSatoshis()\n\n\tisSettled := invoice.State == invoices.ContractSettled\n\n\tvar state lnrpc.Invoice_InvoiceState\n\tswitch invoice.State {\n\tcase invoices.ContractOpen:\n\t\tstate = lnrpc.Invoice_OPEN\n\n\tcase invoices.ContractSettled:\n\t\tstate = lnrpc.Invoice_SETTLED\n\n\tcase invoices.ContractCanceled:\n\t\tstate = lnrpc.Invoice_CANCELED\n\n\tcase invoices.ContractAccepted:\n\t\tstate = lnrpc.Invoice_ACCEPTED\n\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unknown invoice state %v\",\n\t\t\tinvoice.State)\n\t}\n\n\trpcHtlcs := make([]*lnrpc.InvoiceHTLC, 0, len(invoice.Htlcs))\n\tfor key, htlc := range invoice.Htlcs {\n\t\tvar state lnrpc.InvoiceHTLCState\n\t\tswitch htlc.State {\n\t\tcase invoices.HtlcStateAccepted:\n\t\t\tstate = lnrpc.InvoiceHTLCState_ACCEPTED\n\t\tcase invoices.HtlcStateSettled:\n\t\t\tstate = lnrpc.InvoiceHTLCState_SETTLED\n\t\tcase invoices.HtlcStateCanceled:\n\t\t\tstate = lnrpc.InvoiceHTLCState_CANCELED\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"unknown state %v\", htlc.State)\n\t\t}\n\n\t\trpcHtlc := lnrpc.InvoiceHTLC{\n\t\t\tChanId:          key.ChanID.ToUint64(),\n\t\t\tHtlcIndex:       key.HtlcID,\n\t\t\tAcceptHeight:    int32(htlc.AcceptHeight),\n\t\t\tAcceptTime:      htlc.AcceptTime.Unix(),\n\t\t\tExpiryHeight:    int32(htlc.Expiry),\n\t\t\tAmtMsat:         uint64(htlc.Amt),\n\t\t\tState:           state,\n\t\t\tCustomRecords:   htlc.CustomRecords,\n\t\t\tMppTotalAmtMsat: uint64(htlc.MppTotalAmt),\n\t\t}\n\n\t\t// Populate any fields relevant to AMP payments.\n\t\tif htlc.AMP != nil {\n\t\t\trootShare := htlc.AMP.Record.RootShare()\n\t\t\tsetID := htlc.AMP.Record.SetID()\n\n\t\t\tvar preimage []byte\n\t\t\tif htlc.AMP.Preimage != nil {\n\t\t\t\tpreimage = htlc.AMP.Preimage[:]\n\t\t\t}\n\n\t\t\trpcHtlc.Amp = &lnrpc.AMP{\n\t\t\t\tRootShare:  rootShare[:],\n\t\t\t\tSetId:      setID[:],\n\t\t\t\tChildIndex: htlc.AMP.Record.ChildIndex(),\n\t\t\t\tHash:       htlc.AMP.Hash[:],\n\t\t\t\tPreimage:   preimage,\n\t\t\t}\n\t\t}\n\n\t\t// Only report resolved times if htlc is resolved.\n\t\tif htlc.State != invoices.HtlcStateAccepted {\n\t\t\trpcHtlc.ResolveTime = htlc.ResolveTime.Unix()\n\t\t}\n\n\t\trpcHtlcs = append(rpcHtlcs, &rpcHtlc)\n\t}\n\n\trpcInvoice := &lnrpc.Invoice{\n\t\tMemo:            string(invoice.Memo),\n\t\tRHash:           rHash,\n\t\tValue:           int64(satAmt),\n\t\tValueMsat:       int64(invoice.Terms.Value),\n\t\tCreationDate:    invoice.CreationDate.Unix(),\n\t\tSettleDate:      settleDate,\n\t\tSettled:         isSettled,\n\t\tPaymentRequest:  string(invoice.PaymentRequest),\n\t\tDescriptionHash: descHash,\n\t\tExpiry:          int64(invoice.Terms.Expiry.Seconds()),\n\t\tCltvExpiry:      uint64(invoice.Terms.FinalCltvDelta),\n\t\tFallbackAddr:    fallbackAddr,\n\t\tRouteHints:      routeHints,\n\t\tAddIndex:        invoice.AddIndex,\n\t\tPrivate:         len(routeHints) > 0,\n\t\tSettleIndex:     invoice.SettleIndex,\n\t\tAmtPaidSat:      int64(satAmtPaid),\n\t\tAmtPaidMsat:     int64(invoice.AmtPaid),\n\t\tAmtPaid:         int64(invoice.AmtPaid),\n\t\tState:           state,\n\t\tHtlcs:           rpcHtlcs,\n\t\tFeatures:        CreateRPCFeatures(invoice.Terms.Features),\n\t\tIsKeysend:       invoice.IsKeysend(),\n\t\tPaymentAddr:     invoice.Terms.PaymentAddr[:],\n\t\tIsAmp:           invoice.IsAMP(),\n\t}\n\n\trpcInvoice.AmpInvoiceState = make(map[string]*lnrpc.AMPInvoiceState)\n\tfor setID, ampState := range invoice.AMPState {\n\t\tsetIDStr := hex.EncodeToString(setID[:])\n\n\t\tvar state lnrpc.InvoiceHTLCState\n\t\tswitch ampState.State {\n\t\tcase invoices.HtlcStateAccepted:\n\t\t\tstate = lnrpc.InvoiceHTLCState_ACCEPTED\n\t\tcase invoices.HtlcStateSettled:\n\t\t\tstate = lnrpc.InvoiceHTLCState_SETTLED\n\t\tcase invoices.HtlcStateCanceled:\n\t\t\tstate = lnrpc.InvoiceHTLCState_CANCELED\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"unknown state %v\", ampState.State)\n\t\t}\n\n\t\trpcInvoice.AmpInvoiceState[setIDStr] = &lnrpc.AMPInvoiceState{\n\t\t\tState:       state,\n\t\t\tSettleIndex: ampState.SettleIndex,\n\t\t\tSettleTime:  ampState.SettleDate.Unix(),\n\t\t\tAmtPaidMsat: int64(ampState.AmtPaid),\n\t\t}\n\n\t\t// If at least one of the present HTLC sets show up as being\n\t\t// settled, then we'll mark the invoice itself as being\n\t\t// settled.\n\t\tif ampState.State == invoices.HtlcStateSettled {\n\t\t\trpcInvoice.Settled = true // nolint:staticcheck\n\t\t\trpcInvoice.State = lnrpc.Invoice_SETTLED\n\t\t}\n\t}\n\n\tif preimage != nil {\n\t\trpcInvoice.RPreimage = preimage[:]\n\t}\n\n\treturn rpcInvoice, nil\n}\n\n// CreateRPCFeatures maps a feature vector into a list of lnrpc.Features.",
      "length": 4832,
      "tokens": 432,
      "embedding": []
    },
    {
      "slug": "func CreateRPCFeatures(fv *lnwire.FeatureVector) map[uint32]*lnrpc.Feature {",
      "content": "func CreateRPCFeatures(fv *lnwire.FeatureVector) map[uint32]*lnrpc.Feature {\n\tif fv == nil {\n\t\treturn nil\n\t}\n\n\tfeatures := fv.Features()\n\trpcFeatures := make(map[uint32]*lnrpc.Feature, len(features))\n\tfor bit := range features {\n\t\trpcFeatures[uint32(bit)] = &lnrpc.Feature{\n\t\t\tName:       fv.Name(bit),\n\t\t\tIsRequired: bit.IsRequired(),\n\t\t\tIsKnown:    fv.IsKnown(bit),\n\t\t}\n\t}\n\n\treturn rpcFeatures\n}\n\n// CreateRPCRouteHints takes in the decoded form of an invoice's route hints\n// and converts them into the lnrpc type.",
      "length": 422,
      "tokens": 55,
      "embedding": []
    },
    {
      "slug": "func CreateRPCRouteHints(routeHints [][]zpay32.HopHint) []*lnrpc.RouteHint {",
      "content": "func CreateRPCRouteHints(routeHints [][]zpay32.HopHint) []*lnrpc.RouteHint {\n\tvar res []*lnrpc.RouteHint\n\n\tfor _, route := range routeHints {\n\t\thopHints := make([]*lnrpc.HopHint, 0, len(route))\n\t\tfor _, hop := range route {\n\t\t\tpubKey := hex.EncodeToString(\n\t\t\t\thop.NodeID.SerializeCompressed(),\n\t\t\t)\n\n\t\t\thint := &lnrpc.HopHint{\n\t\t\t\tNodeId:                    pubKey,\n\t\t\t\tChanId:                    hop.ChannelID,\n\t\t\t\tFeeBaseMsat:               hop.FeeBaseMSat,\n\t\t\t\tFeeProportionalMillionths: hop.FeeProportionalMillionths,\n\t\t\t\tCltvExpiryDelta:           uint32(hop.CLTVExpiryDelta),\n\t\t\t}\n\n\t\t\thopHints = append(hopHints, hint)\n\t\t}\n\n\t\trouteHint := &lnrpc.RouteHint{HopHints: hopHints}\n\t\tres = append(res, routeHint)\n\t}\n\n\treturn res\n}\n\n// CreateZpay32HopHints takes in the lnrpc form of route hints and converts them\n// into an invoice decoded form.",
      "length": 741,
      "tokens": 77,
      "embedding": []
    },
    {
      "slug": "func CreateZpay32HopHints(routeHints []*lnrpc.RouteHint) ([][]zpay32.HopHint, error) {",
      "content": "func CreateZpay32HopHints(routeHints []*lnrpc.RouteHint) ([][]zpay32.HopHint, error) {\n\tvar res [][]zpay32.HopHint\n\tfor _, route := range routeHints {\n\t\thopHints := make([]zpay32.HopHint, 0, len(route.HopHints))\n\t\tfor _, hop := range route.HopHints {\n\t\t\tpubKeyBytes, err := hex.DecodeString(hop.NodeId)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tp, err := btcec.ParsePubKey(pubKeyBytes)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\thopHints = append(hopHints, zpay32.HopHint{\n\t\t\t\tNodeID:                    p,\n\t\t\t\tChannelID:                 hop.ChanId,\n\t\t\t\tFeeBaseMSat:               hop.FeeBaseMsat,\n\t\t\t\tFeeProportionalMillionths: hop.FeeProportionalMillionths,\n\t\t\t\tCLTVExpiryDelta:           uint16(hop.CltvExpiryDelta),\n\t\t\t})\n\t\t}\n\t\tres = append(res, hopHints)\n\t}\n\treturn res, nil\n}\n",
      "length": 680,
      "tokens": 73,
      "embedding": []
    }
  ]
}