{
  "filepath": "../implementations/go/lnd/lnrpc/websocket_proxy.go",
  "package": "lnrpc",
  "sections": [
    {
      "slug": "func NewWebSocketProxy(h http.Handler, logger btclog.Logger,",
      "content": "func NewWebSocketProxy(h http.Handler, logger btclog.Logger,\n\tpingInterval, pongWait time.Duration,\n\tclientStreamingURIs []*regexp.Regexp) http.Handler {\n\n\tp := &WebsocketProxy{\n\t\tbackend: h,\n\t\tlogger:  logger,\n\t\tupgrader: &websocket.Upgrader{\n\t\t\tReadBufferSize:  1024,\n\t\t\tWriteBufferSize: 1024,\n\t\t\tCheckOrigin: func(r *http.Request) bool {\n\t\t\t\treturn true\n\t\t\t},\n\t\t},\n\t\tclientStreamingURIs: clientStreamingURIs,\n\t}\n\n\tif pingInterval > 0 && pongWait > 0 {\n\t\tp.pingInterval = pingInterval\n\t\tp.pongWait = pongWait\n\t}\n\n\treturn p\n}\n\n// WebsocketProxy provides websocket transport upgrade to compatible endpoints.",
      "length": 522,
      "tokens": 60,
      "embedding": []
    },
    {
      "slug": "type WebsocketProxy struct {",
      "content": "type WebsocketProxy struct {\n\tbackend  http.Handler\n\tlogger   btclog.Logger\n\tupgrader *websocket.Upgrader\n\n\t// clientStreamingURIs holds a list of all patterns for URIs that are\n\t// mapped to client-streaming RPC methods. We need to keep track of\n\t// those to make sure we initialize the request body correctly for the\n\t// underlying grpc-gateway library.\n\tclientStreamingURIs []*regexp.Regexp\n\n\tpingInterval time.Duration\n\tpongWait     time.Duration\n}\n\n// pingPongEnabled returns true if a ping interval is set to enable sending and\n// expecting regular ping/pong messages.",
      "length": 530,
      "tokens": 73,
      "embedding": []
    },
    {
      "slug": "func (p *WebsocketProxy) pingPongEnabled() bool {",
      "content": "func (p *WebsocketProxy) pingPongEnabled() bool {\n\treturn p.pingInterval > 0 && p.pongWait > 0\n}\n\n// ServeHTTP handles the incoming HTTP request. If the request is an\n// \"upgradeable\" WebSocket request (identified by header fields), then the\n// WS proxy handles the request. Otherwise the request is passed directly to the\n// underlying REST proxy.",
      "length": 292,
      "tokens": 49,
      "embedding": []
    },
    {
      "slug": "func (p *WebsocketProxy) ServeHTTP(w http.ResponseWriter, r *http.Request) {",
      "content": "func (p *WebsocketProxy) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tif !websocket.IsWebSocketUpgrade(r) {\n\t\tp.backend.ServeHTTP(w, r)\n\t\treturn\n\t}\n\tp.upgradeToWebSocketProxy(w, r)\n}\n\n// upgradeToWebSocketProxy upgrades the incoming request to a WebSocket, reads\n// one incoming message then streams all responses until either the client or\n// server quit the connection.",
      "length": 293,
      "tokens": 38,
      "embedding": []
    },
    {
      "slug": "func (p *WebsocketProxy) upgradeToWebSocketProxy(w http.ResponseWriter,",
      "content": "func (p *WebsocketProxy) upgradeToWebSocketProxy(w http.ResponseWriter,\n\tr *http.Request) {\n\n\tconn, err := p.upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tp.logger.Errorf(\"error upgrading websocket:\", err)\n\t\treturn\n\t}\n\tdefer func() {\n\t\terr := conn.Close()\n\t\tif err != nil && !IsClosedConnError(err) {\n\t\t\tp.logger.Errorf(\"WS: error closing upgraded conn: %v\",\n\t\t\t\terr)\n\t\t}\n\t}()\n\n\tctx, cancelFn := context.WithCancel(r.Context())\n\tdefer cancelFn()\n\n\trequestForwarder := newRequestForwardingReader()\n\trequest, err := http.NewRequestWithContext(\n\t\tctx, r.Method, r.URL.String(), requestForwarder,\n\t)\n\tif err != nil {\n\t\tp.logger.Errorf(\"WS: error preparing request:\", err)\n\t\treturn\n\t}\n\n\t// Allow certain headers to be forwarded, either from source headers\n\t// or the special Sec-Websocket-Protocol header field.\n\tforwardHeaders(r.Header, request.Header)\n\n\t// Also allow the target request method to be overwritten, as all\n\t// WebSocket establishment calls MUST be GET requests.\n\tif m := r.URL.Query().Get(MethodOverrideParam); m != \"\" {\n\t\trequest.Method = m\n\t}\n\n\t// Is this a call to a client-streaming RPC method?\n\tclientStreaming := false\n\tfor _, pattern := range p.clientStreamingURIs {\n\t\tif pattern.MatchString(r.URL.Path) {\n\t\t\tclientStreaming = true\n\t\t}\n\t}\n\n\tresponseForwarder := newResponseForwardingWriter()\n\tgo func() {\n\t\t<-ctx.Done()\n\t\tresponseForwarder.Close()\n\t\trequestForwarder.CloseWriter()\n\t}()\n\n\tgo func() {\n\t\tdefer cancelFn()\n\t\tp.backend.ServeHTTP(responseForwarder, request)\n\t}()\n\n\t// Read loop: Take messages from websocket and write them to the payload\n\t// channel. This needs to be its own goroutine because for non-client\n\t// streaming RPCs, the requestForwarder.Write() in the second goroutine\n\t// will block until the request has fully completed. But for the ping/\n\t// pong handler to work, we need to have an active call to\n\t// conn.ReadMessage() going on. So we make sure we have such an active\n\t// call by starting a second read as soon as the first one has\n\t// completed.\n\tpayloadChannel := make(chan []byte, 1)\n\tgo func() {\n\t\tdefer cancelFn()\n\t\tdefer close(payloadChannel)\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t}\n\n\t\t\t_, payload, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tif IsClosedConnError(err) {\n\t\t\t\t\tp.logger.Tracef(\"WS: socket \"+\n\t\t\t\t\t\t\"closed: %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tp.logger.Errorf(\"error reading message: %v\",\n\t\t\t\t\terr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tselect {\n\t\t\tcase payloadChannel <- payload:\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Forward loop: Take messages from the incoming payload channel and\n\t// write them to the http request.\n\tgo func() {\n\t\tdefer cancelFn()\n\t\tfor {\n\t\t\tvar payload []byte\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase newPayload, more := <-payloadChannel:\n\t\t\t\tif !more {\n\t\t\t\t\tp.logger.Infof(\"WS: incoming payload \" +\n\t\t\t\t\t\t\"chan closed\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tpayload = newPayload\n\t\t\t}\n\n\t\t\t_, err := requestForwarder.Write(payload)\n\t\t\tif err != nil {\n\t\t\t\tp.logger.Errorf(\"WS: error writing message \"+\n\t\t\t\t\t\"to upstream http server: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\t_, _ = requestForwarder.Write([]byte{'\\n'})\n\n\t\t\t// The grpc-gateway library uses a different request\n\t\t\t// reader depending on whether it is a client streaming\n\t\t\t// RPC or not. For a non-streaming request we need to\n\t\t\t// close with EOF to signal the request was completed.\n\t\t\tif !clientStreaming {\n\t\t\t\trequestForwarder.CloseWriter()\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Ping write loop: Send a ping message regularly if ping/pong is\n\t// enabled.\n\tif p.pingPongEnabled() {\n\t\t// We'll send out our first ping in pingInterval. So the initial\n\t\t// deadline is that interval plus the time we allow for a\n\t\t// response to be sent.\n\t\tinitialDeadline := time.Now().Add(p.pingInterval + p.pongWait)\n\t\t_ = conn.SetReadDeadline(initialDeadline)\n\n\t\t// Whenever a pong message comes in, we extend the deadline\n\t\t// until the next read is expected by the interval plus pong\n\t\t// wait time. Since we can never _reach_ any of the deadlines,\n\t\t// we also have to advance the deadline for the next expected\n\t\t// write to happen, in case the next thing we actually write is\n\t\t// the next ping.\n\t\tconn.SetPongHandler(func(appData string) error {\n\t\t\tnextDeadline := time.Now().Add(\n\t\t\t\tp.pingInterval + p.pongWait,\n\t\t\t)\n\t\t\t_ = conn.SetReadDeadline(nextDeadline)\n\t\t\t_ = conn.SetWriteDeadline(nextDeadline)\n\n\t\t\treturn nil\n\t\t})\n\t\tgo func() {\n\t\t\tticker := time.NewTicker(p.pingInterval)\n\t\t\tdefer ticker.Stop()\n\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\tp.logger.Debug(\"WS: ping loop done\")\n\t\t\t\t\treturn\n\n\t\t\t\tcase <-ticker.C:\n\t\t\t\t\t// Writing the ping shouldn't take any\n\t\t\t\t\t// longer than we'll wait for a response\n\t\t\t\t\t// in the first place.\n\t\t\t\t\twriteDeadline := time.Now().Add(\n\t\t\t\t\t\tp.pongWait,\n\t\t\t\t\t)\n\t\t\t\t\terr := conn.WriteControl(\n\t\t\t\t\t\twebsocket.PingMessage,\n\t\t\t\t\t\t[]byte(PingContent),\n\t\t\t\t\t\twriteDeadline,\n\t\t\t\t\t)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tp.logger.Warnf(\"WS: could not \"+\n\t\t\t\t\t\t\t\"send ping message: %v\",\n\t\t\t\t\t\t\terr)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\t// Write loop: Take messages from the response forwarder and write them\n\t// to the WebSocket.\n\tfor responseForwarder.Scan() {\n\t\tif len(responseForwarder.Bytes()) == 0 {\n\t\t\tp.logger.Errorf(\"WS: empty scan: %v\",\n\t\t\t\tresponseForwarder.Err())\n\n\t\t\tcontinue\n\t\t}\n\n\t\terr := conn.WriteMessage(\n\t\t\twebsocket.TextMessage, responseForwarder.Bytes(),\n\t\t)\n\t\tif err != nil {\n\t\t\tp.logger.Errorf(\"WS: error writing message: %v\", err)\n\t\t\treturn\n\t\t}\n\t}\n\tif err := responseForwarder.Err(); err != nil && !IsClosedConnError(err) {\n\t\tp.logger.Errorf(\"WS: scanner err: %v\", err)\n\t}\n}\n\n// forwardHeaders forwards certain allowed header fields from the source request\n// to the target request. Because browsers are limited in what header fields\n// they can send on the WebSocket setup call, we also allow additional fields to\n// be transported in the special Sec-Websocket-Protocol field.",
      "length": 5583,
      "tokens": 772,
      "embedding": []
    },
    {
      "slug": "func forwardHeaders(source, target http.Header) {",
      "content": "func forwardHeaders(source, target http.Header) {\n\t// Forward allowed header fields directly.\n\tfor header := range source {\n\t\theaderName := textproto.CanonicalMIMEHeaderKey(header)\n\t\tforward, ok := defaultHeadersToForward[headerName]\n\t\tif ok && forward {\n\t\t\ttarget.Set(headerName, source.Get(header))\n\t\t}\n\t}\n\n\t// Browser aren't allowed to set custom header fields on WebSocket\n\t// requests. We need to allow them to submit the macaroon as a WS\n\t// protocol, which is the only allowed header. Set any \"protocols\" we\n\t// declare valid as header fields on the forwarded request.\n\tprotocol := source.Get(HeaderWebSocketProtocol)\n\tfor key := range defaultProtocolsToAllow {\n\t\tif strings.HasPrefix(protocol, key) {\n\t\t\t// The format is \"<protocol name>+<value>\". We know the\n\t\t\t// protocol string starts with the name so we only need\n\t\t\t// to set the value.\n\t\t\tvalues := strings.Split(\n\t\t\t\tprotocol, WebSocketProtocolDelimiter,\n\t\t\t)\n\t\t\ttarget.Set(key, values[1])\n\t\t}\n\t}\n}\n\n// newRequestForwardingReader creates a new request forwarding pipe.",
      "length": 957,
      "tokens": 132,
      "embedding": []
    },
    {
      "slug": "func newRequestForwardingReader() *requestForwardingReader {",
      "content": "func newRequestForwardingReader() *requestForwardingReader {\n\tr, w := io.Pipe()\n\treturn &requestForwardingReader{\n\t\tReader: r,\n\t\tWriter: w,\n\t\tpipeR:  r,\n\t\tpipeW:  w,\n\t}\n}\n\n// requestForwardingReader is a wrapper around io.Pipe that embeds both the\n// io.Reader and io.Writer interface and can be closed.",
      "length": 232,
      "tokens": 36,
      "embedding": []
    },
    {
      "slug": "type requestForwardingReader struct {",
      "content": "type requestForwardingReader struct {\n\tio.Reader\n\tio.Writer\n\n\tpipeR *io.PipeReader\n\tpipeW *io.PipeWriter\n}\n\n// CloseWriter closes the underlying pipe writer.",
      "length": 112,
      "tokens": 14,
      "embedding": []
    },
    {
      "slug": "func (r *requestForwardingReader) CloseWriter() {",
      "content": "func (r *requestForwardingReader) CloseWriter() {\n\t_ = r.pipeW.CloseWithError(io.EOF)\n}\n\n// newResponseForwardingWriter creates a new http.ResponseWriter that intercepts\n// what's written to it and presents it through a bufio.Scanner interface.",
      "length": 190,
      "tokens": 24,
      "embedding": []
    },
    {
      "slug": "func newResponseForwardingWriter() *responseForwardingWriter {",
      "content": "func newResponseForwardingWriter() *responseForwardingWriter {\n\tr, w := io.Pipe()\n\treturn &responseForwardingWriter{\n\t\tWriter:  w,\n\t\tScanner: bufio.NewScanner(r),\n\t\tpipeR:   r,\n\t\tpipeW:   w,\n\t\theader:  http.Header{},\n\t\tclosed:  make(chan bool, 1),\n\t}\n}\n\n// responseForwardingWriter is a type that implements the http.ResponseWriter\n// interface but internally forwards what's written to the writer through a pipe\n// so it can easily be read again through the bufio.Scanner interface.",
      "length": 407,
      "tokens": 56,
      "embedding": []
    },
    {
      "slug": "type responseForwardingWriter struct {",
      "content": "type responseForwardingWriter struct {\n\tio.Writer\n\t*bufio.Scanner\n\n\tpipeR *io.PipeReader\n\tpipeW *io.PipeWriter\n\n\theader http.Header\n\tcode   int\n\tclosed chan bool\n}\n\n// Write writes the given bytes to the internal pipe.\n//\n// NOTE: This is part of the http.ResponseWriter interface.",
      "length": 229,
      "tokens": 34,
      "embedding": []
    },
    {
      "slug": "func (w *responseForwardingWriter) Write(b []byte) (int, error) {",
      "content": "func (w *responseForwardingWriter) Write(b []byte) (int, error) {\n\treturn w.Writer.Write(b)\n}\n\n// Header returns the HTTP header fields intercepted so far.\n//\n// NOTE: This is part of the http.ResponseWriter interface.",
      "length": 147,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (w *responseForwardingWriter) Header() http.Header {",
      "content": "func (w *responseForwardingWriter) Header() http.Header {\n\treturn w.header\n}\n\n// WriteHeader indicates that the header part of the response is now finished\n// and sets the response code.\n//\n// NOTE: This is part of the http.ResponseWriter interface.",
      "length": 185,
      "tokens": 32,
      "embedding": []
    },
    {
      "slug": "func (w *responseForwardingWriter) WriteHeader(code int) {",
      "content": "func (w *responseForwardingWriter) WriteHeader(code int) {\n\tw.code = code\n}\n\n// CloseNotify returns a channel that indicates if a connection was closed.\n//\n// NOTE: This is part of the http.CloseNotifier interface.",
      "length": 150,
      "tokens": 26,
      "embedding": []
    },
    {
      "slug": "func (w *responseForwardingWriter) CloseNotify() <-chan bool {",
      "content": "func (w *responseForwardingWriter) CloseNotify() <-chan bool {\n\treturn w.closed\n}\n\n// Flush empties all buffers. We implement this to indicate to our backend that\n// we support flushing our content. There is no actual implementation because\n// all writes happen immediately, there is no internal buffering.\n//\n// NOTE: This is part of the http.Flusher interface.",
      "length": 292,
      "tokens": 49,
      "embedding": []
    },
    {
      "slug": "func (w *responseForwardingWriter) Flush() {}",
      "content": "func (w *responseForwardingWriter) Flush() {}\n",
      "length": 0,
      "tokens": 0,
      "embedding": []
    },
    {
      "slug": "func (w *responseForwardingWriter) Close() {",
      "content": "func (w *responseForwardingWriter) Close() {\n\t_ = w.pipeR.CloseWithError(io.EOF)\n\t_ = w.pipeW.CloseWithError(io.EOF)\n\tw.closed <- true\n}\n\n// IsClosedConnError is a helper function that returns true if the given error\n// is an error indicating we are using a closed connection.",
      "length": 225,
      "tokens": 34,
      "embedding": []
    },
    {
      "slug": "func IsClosedConnError(err error) bool {",
      "content": "func IsClosedConnError(err error) bool {\n\tif err == nil {\n\t\treturn false\n\t}\n\tif err == http.ErrServerClosed {\n\t\treturn true\n\t}\n\n\tstr := err.Error()\n\tif strings.Contains(str, \"use of closed network connection\") {\n\t\treturn true\n\t}\n\tif strings.Contains(str, \"closed pipe\") {\n\t\treturn true\n\t}\n\tif strings.Contains(str, \"broken pipe\") {\n\t\treturn true\n\t}\n\tif strings.Contains(str, \"connection reset by peer\") {\n\t\treturn true\n\t}\n\treturn websocket.IsCloseError(\n\t\terr, websocket.CloseNormalClosure, websocket.CloseGoingAway,\n\t)\n}\n",
      "length": 457,
      "tokens": 63,
      "embedding": []
    }
  ]
}