{
  "filepath": "../implementations/go/lnd/lnrpc/signrpc/signer_server.go",
  "package": "signrpc",
  "sections": [
    {
      "slug": "//go:build signrpc",
      "content": "//go:build signrpc\n// +build signrpc\n\npackage signrpc\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/sha256\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/btcsuite/btcd/btcec/v2\"\n\t\"github.com/btcsuite/btcd/btcec/v2/schnorr\"\n\t\"github.com/btcsuite/btcd/btcec/v2/schnorr/musig2\"\n\t\"github.com/btcsuite/btcd/chaincfg/chainhash\"\n\t\"github.com/btcsuite/btcd/txscript\"\n\t\"github.com/btcsuite/btcd/wire\"\n\t\"github.com/grpc-ecosystem/grpc-gateway/v2/runtime\"\n\t\"github.com/lightningnetwork/lnd/input\"\n\t\"github.com/lightningnetwork/lnd/keychain\"\n\t\"github.com/lightningnetwork/lnd/lnrpc\"\n\t\"github.com/lightningnetwork/lnd/lnwire\"\n\t\"github.com/lightningnetwork/lnd/macaroons\"\n\t\"google.golang.org/grpc\"\n\t\"gopkg.in/macaroon-bakery.v2/bakery\"\n)\n\nconst (\n\t// subServerName is the name of the sub rpc server. We'll use this name\n\t// to register ourselves, and we also require that the main\n\t// SubServerConfigDispatcher instance recognize this as the name of the\n\t// config file that we need.\n\tsubServerName = \"SignRPC\"\n)\n\nvar (\n\t// macaroonOps are the set of capabilities that our minted macaroon (if\n\t// it doesn't already exist) will have.\n\tmacaroonOps = []bakery.Op{\n\t\t{\n\t\t\tEntity: \"signer\",\n\t\t\tAction: \"generate\",\n\t\t},\n\t\t{\n\t\t\tEntity: \"signer\",\n\t\t\tAction: \"read\",\n\t\t},\n\t}\n\n\t// macPermissions maps RPC calls to the permissions they require.\n\tmacPermissions = map[string][]bakery.Op{\n\t\t\"/signrpc.Signer/SignOutputRaw\": {{\n\t\t\tEntity: \"signer\",\n\t\t\tAction: \"generate\",\n\t\t}},\n\t\t\"/signrpc.Signer/ComputeInputScript\": {{\n\t\t\tEntity: \"signer\",\n\t\t\tAction: \"generate\",\n\t\t}},\n\t\t\"/signrpc.Signer/SignMessage\": {{\n\t\t\tEntity: \"signer\",\n\t\t\tAction: \"generate\",\n\t\t}},\n\t\t\"/signrpc.Signer/VerifyMessage\": {{\n\t\t\tEntity: \"signer\",\n\t\t\tAction: \"read\",\n\t\t}},\n\t\t\"/signrpc.Signer/DeriveSharedKey\": {{\n\t\t\tEntity: \"signer\",\n\t\t\tAction: \"generate\",\n\t\t}},\n\t\t\"/signrpc.Signer/MuSig2CombineKeys\": {{\n\t\t\tEntity: \"signer\",\n\t\t\tAction: \"read\",\n\t\t}},\n\t\t\"/signrpc.Signer/MuSig2CreateSession\": {{\n\t\t\tEntity: \"signer\",\n\t\t\tAction: \"generate\",\n\t\t}},\n\t\t\"/signrpc.Signer/MuSig2RegisterNonces\": {{\n\t\t\tEntity: \"signer\",\n\t\t\tAction: \"generate\",\n\t\t}},\n\t\t\"/signrpc.Signer/MuSig2Sign\": {{\n\t\t\tEntity: \"signer\",\n\t\t\tAction: \"generate\",\n\t\t}},\n\t\t\"/signrpc.Signer/MuSig2CombineSig\": {{\n\t\t\tEntity: \"signer\",\n\t\t\tAction: \"generate\",\n\t\t}},\n\t\t\"/signrpc.Signer/MuSig2Cleanup\": {{\n\t\t\tEntity: \"signer\",\n\t\t\tAction: \"generate\",\n\t\t}},\n\t}\n\n\t// DefaultSignerMacFilename is the default name of the signer macaroon\n\t// that we expect to find via a file handle within the main\n\t// configuration file in this package.\n\tDefaultSignerMacFilename = \"signer.macaroon\"\n)\n\n// ServerShell is a shell struct holding a reference to the actual sub-server.\n// It is used to register the gRPC sub-server with the root server before we\n// have the necessary dependencies to populate the actual sub-server.",
      "length": 2674,
      "tokens": 275,
      "embedding": []
    },
    {
      "slug": "type ServerShell struct {",
      "content": "type ServerShell struct {\n\tSignerServer\n}\n\n// Server is a sub-server of the main RPC server: the signer RPC. This sub RPC\n// server allows external callers to access the full signing capabilities of\n// lnd. This allows callers to create custom protocols, external to lnd, even\n// backed by multiple distinct lnd across independent failure domains.",
      "length": 315,
      "tokens": 53,
      "embedding": []
    },
    {
      "slug": "type Server struct {",
      "content": "type Server struct {\n\t// Required by the grpc-gateway/v2 library for forward compatibility.\n\tUnimplementedSignerServer\n\n\tcfg *Config\n}\n\n// A compile time check to ensure that Server fully implements the SignerServer\n// gRPC service.\nvar _ SignerServer = (*Server)(nil)\n\n// New returns a new instance of the signrpc Signer sub-server. We also return\n// the set of permissions for the macaroons that we may create within this\n// method. If the macaroons we need aren't found in the filepath, then we'll\n// create them on start up. If we're unable to locate, or create the macaroons\n// we need, then we'll return with an error.",
      "length": 589,
      "tokens": 100,
      "embedding": []
    },
    {
      "slug": "func New(cfg *Config) (*Server, lnrpc.MacaroonPerms, error) {",
      "content": "func New(cfg *Config) (*Server, lnrpc.MacaroonPerms, error) {\n\t// If the path of the signer macaroon wasn't generated, then we'll\n\t// assume that it's found at the default network directory.\n\tif cfg.SignerMacPath == \"\" {\n\t\tcfg.SignerMacPath = filepath.Join(\n\t\t\tcfg.NetworkDir, DefaultSignerMacFilename,\n\t\t)\n\t}\n\n\t// Now that we know the full path of the signer macaroon, we can check\n\t// to see if we need to create it or not. If stateless_init is set\n\t// then we don't write the macaroons.\n\tmacFilePath := cfg.SignerMacPath\n\tif cfg.MacService != nil && !cfg.MacService.StatelessInit &&\n\t\t!lnrpc.FileExists(macFilePath) {\n\n\t\tlog.Infof(\"Making macaroons for Signer RPC Server at: %v\",\n\t\t\tmacFilePath)\n\n\t\t// At this point, we know that the signer macaroon doesn't yet,\n\t\t// exist, so we need to create it with the help of the main\n\t\t// macaroon service.\n\t\tsignerMac, err := cfg.MacService.NewMacaroon(\n\t\t\tcontext.Background(), macaroons.DefaultRootKeyID,\n\t\t\tmacaroonOps...,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\tsignerMacBytes, err := signerMac.M().MarshalBinary()\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\terr = ioutil.WriteFile(macFilePath, signerMacBytes, 0644)\n\t\tif err != nil {\n\t\t\t_ = os.Remove(macFilePath)\n\t\t\treturn nil, nil, err\n\t\t}\n\t}\n\n\tsignerServer := &Server{\n\t\tcfg: cfg,\n\t}\n\n\treturn signerServer, macPermissions, nil\n}\n\n// Start launches any helper goroutines required for the rpcServer to function.\n//\n// NOTE: This is part of the lnrpc.SubServer interface.",
      "length": 1377,
      "tokens": 205,
      "embedding": []
    },
    {
      "slug": "func (s *Server) Start() error {",
      "content": "func (s *Server) Start() error {\n\treturn nil\n}\n\n// Stop signals any active goroutines for a graceful closure.\n//\n// NOTE: This is part of the lnrpc.SubServer interface.",
      "length": 130,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (s *Server) Stop() error {",
      "content": "func (s *Server) Stop() error {\n\treturn nil\n}\n\n// Name returns a unique string representation of the sub-server. This can be\n// used to identify the sub-server and also de-duplicate them.\n//\n// NOTE: This is part of the lnrpc.SubServer interface.",
      "length": 208,
      "tokens": 36,
      "embedding": []
    },
    {
      "slug": "func (s *Server) Name() string {",
      "content": "func (s *Server) Name() string {\n\treturn subServerName\n}\n\n// RegisterWithRootServer will be called by the root gRPC server to direct a\n// sub RPC server to register itself with the main gRPC root server. Until this\n// is called, each sub-server won't be able to have\n// requests routed towards it.\n//\n// NOTE: This is part of the lnrpc.GrpcHandler interface.",
      "length": 317,
      "tokens": 56,
      "embedding": []
    },
    {
      "slug": "func (r *ServerShell) RegisterWithRootServer(grpcServer *grpc.Server) error {",
      "content": "func (r *ServerShell) RegisterWithRootServer(grpcServer *grpc.Server) error {\n\t// We make sure that we register it with the main gRPC server to ensure\n\t// all our methods are routed properly.\n\tRegisterSignerServer(grpcServer, r)\n\n\tlog.Debugf(\"Signer RPC server successfully register with root gRPC \" +\n\t\t\"server\")\n\n\treturn nil\n}\n\n// RegisterWithRestServer will be called by the root REST mux to direct a sub\n// RPC server to register itself with the main REST mux server. Until this is\n// called, each sub-server won't be able to have requests routed towards it.\n//\n// NOTE: This is part of the lnrpc.GrpcHandler interface.",
      "length": 531,
      "tokens": 90,
      "embedding": []
    },
    {
      "slug": "func (r *ServerShell) RegisterWithRestServer(ctx context.Context,",
      "content": "func (r *ServerShell) RegisterWithRestServer(ctx context.Context,\n\tmux *runtime.ServeMux, dest string, opts []grpc.DialOption) error {\n\n\t// We make sure that we register it with the main REST server to ensure\n\t// all our methods are routed properly.\n\terr := RegisterSignerHandlerFromEndpoint(ctx, mux, dest, opts)\n\tif err != nil {\n\t\tlog.Errorf(\"Could not register Signer REST server \"+\n\t\t\t\"with root REST server: %v\", err)\n\t\treturn err\n\t}\n\n\tlog.Debugf(\"Signer REST server successfully registered with \" +\n\t\t\"root REST server\")\n\treturn nil\n}\n\n// CreateSubServer populates the subserver's dependencies using the passed\n// SubServerConfigDispatcher. This method should fully initialize the\n// sub-server instance, making it ready for action. It returns the macaroon\n// permissions that the sub-server wishes to pass on to the root server for all\n// methods routed towards it.\n//\n// NOTE: This is part of the lnrpc.GrpcHandler interface.",
      "length": 845,
      "tokens": 130,
      "embedding": []
    },
    {
      "slug": "func (r *ServerShell) CreateSubServer(configRegistry lnrpc.SubServerConfigDispatcher) (",
      "content": "func (r *ServerShell) CreateSubServer(configRegistry lnrpc.SubServerConfigDispatcher) (\n\tlnrpc.SubServer, lnrpc.MacaroonPerms, error) {\n\n\tsubServer, macPermissions, err := createNewSubServer(configRegistry)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tr.SignerServer = subServer\n\treturn subServer, macPermissions, nil\n}\n\n// SignOutputRaw generates a signature for the passed transaction according to\n// the data within the passed SignReq. If we're unable to find the keys that\n// correspond to the KeyLocators in the SignReq then we'll return an error.\n// Additionally, if the user doesn't provide the set of required parameters, or\n// provides an invalid transaction, then we'll return with an error.\n//\n// NOTE: The resulting signature should be void of a sighash byte.",
      "length": 666,
      "tokens": 103,
      "embedding": []
    },
    {
      "slug": "func (s *Server) SignOutputRaw(_ context.Context, in *SignReq) (*SignResp,",
      "content": "func (s *Server) SignOutputRaw(_ context.Context, in *SignReq) (*SignResp,\n\terror) {\n\n\tswitch {\n\t// If the client doesn't specify a transaction, then there's nothing to\n\t// sign, so we'll exit early.\n\tcase len(in.RawTxBytes) == 0:\n\t\treturn nil, fmt.Errorf(\"a transaction to sign MUST be \" +\n\t\t\t\"passed in\")\n\n\t// If the client doesn't tell us *how* to sign the transaction, then we\n\t// can't sign anything, so we'll exit early.\n\tcase len(in.SignDescs) == 0:\n\t\treturn nil, fmt.Errorf(\"at least one SignDescs MUST be \" +\n\t\t\t\"passed in\")\n\t}\n\n\t// Now that we know we have an actual transaction to decode, we'll\n\t// deserialize it into something that we can properly utilize.\n\tvar (\n\t\ttxToSign wire.MsgTx\n\t\terr      error\n\t)\n\ttxReader := bytes.NewReader(in.RawTxBytes)\n\tif err := txToSign.Deserialize(txReader); err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to decode tx: %v\", err)\n\t}\n\n\tvar (\n\t\tsigHashCache      = input.NewTxSigHashesV0Only(&txToSign)\n\t\tprevOutputFetcher = txscript.NewMultiPrevOutFetcher(nil)\n\t)\n\n\t// If we're spending one or more SegWit v1 (Taproot) inputs, then we\n\t// need the full UTXO information available.\n\tif len(in.PrevOutputs) > 0 {\n\t\tif len(in.PrevOutputs) != len(txToSign.TxIn) {\n\t\t\treturn nil, fmt.Errorf(\"provided previous outputs \" +\n\t\t\t\t\"doesn't match number of transaction inputs\")\n\t\t}\n\n\t\t// Add all previous inputs to our sighash prev out fetcher so we\n\t\t// can calculate the sighash correctly.\n\t\tfor idx, txIn := range txToSign.TxIn {\n\t\t\tprevOutputFetcher.AddPrevOut(\n\t\t\t\ttxIn.PreviousOutPoint, &wire.TxOut{\n\t\t\t\t\tValue:    in.PrevOutputs[idx].Value,\n\t\t\t\t\tPkScript: in.PrevOutputs[idx].PkScript,\n\t\t\t\t},\n\t\t\t)\n\t\t}\n\t\tsigHashCache = txscript.NewTxSigHashes(\n\t\t\t&txToSign, prevOutputFetcher,\n\t\t)\n\t}\n\n\tlog.Debugf(\"Generating sigs for %v inputs: \", len(in.SignDescs))\n\n\t// With the transaction deserialized, we'll now convert sign descs so\n\t// we can feed it into the actual signer.\n\tsignDescs := make([]*input.SignDescriptor, 0, len(in.SignDescs))\n\tfor _, signDesc := range in.SignDescs {\n\t\tkeyDesc := signDesc.KeyDesc\n\n\t\t// The caller can either specify the key using the raw pubkey,\n\t\t// or the description of the key. We'll still attempt to parse\n\t\t// both if both were provided however, to ensure the underlying\n\t\t// SignOutputRaw has as much information as possible.\n\t\tvar (\n\t\t\ttargetPubKey *btcec.PublicKey\n\t\t\tkeyLoc       keychain.KeyLocator\n\t\t)\n\n\t\t// If this method doesn't return nil, then we know that user is\n\t\t// attempting to include a raw serialized pub key.\n\t\tif keyDesc.GetRawKeyBytes() != nil {\n\t\t\ttargetPubKey, err = parseRawKeyBytes(\n\t\t\t\tkeyDesc.GetRawKeyBytes(),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\t// Similarly, if they specified a key locator, then we'll parse\n\t\t// that as well.\n\t\tif keyDesc.GetKeyLoc() != nil {\n\t\t\tprotoLoc := keyDesc.GetKeyLoc()\n\t\t\tkeyLoc = keychain.KeyLocator{\n\t\t\t\tFamily: keychain.KeyFamily(\n\t\t\t\t\tprotoLoc.KeyFamily,\n\t\t\t\t),\n\t\t\t\tIndex: uint32(protoLoc.KeyIndex),\n\t\t\t}\n\t\t}\n\n\t\t// Check what sign method was selected by the user so, we know\n\t\t// exactly what we're expecting and can prevent some of the more\n\t\t// obvious usage errors.\n\t\tsignMethod, err := UnmarshalSignMethod(signDesc.SignMethod)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to unmarshal sign \"+\n\t\t\t\t\"method: %v\", err)\n\t\t}\n\t\tif !signMethod.PkScriptCompatible(signDesc.Output.PkScript) {\n\t\t\treturn nil, fmt.Errorf(\"selected sign method %v is \"+\n\t\t\t\t\"not compatible with given pk script %x\",\n\t\t\t\tsignMethod, signDesc.Output.PkScript)\n\t\t}\n\n\t\t// Perform input validation according to the sign method. Not\n\t\t// all methods require the same fields to be provided.\n\t\tswitch signMethod {\n\t\tcase input.WitnessV0SignMethod:\n\t\t\t// If a witness script isn't passed, then we can't\n\t\t\t// proceed, as in the p2wsh case, we can't properly\n\t\t\t// generate the sighash. A P2WKH doesn't need a witness\n\t\t\t// script. But SignOutputRaw still needs to know the PK\n\t\t\t// script that was used for the output. We'll send it in\n\t\t\t// the WitnessScript field, the SignOutputRaw RPC will\n\t\t\t// know what to do with it when creating the sighash.\n\t\t\tif len(signDesc.WitnessScript) == 0 {\n\t\t\t\treturn nil, fmt.Errorf(\"witness script MUST \" +\n\t\t\t\t\t\"be specified for segwit v0 sign \" +\n\t\t\t\t\t\"method\")\n\t\t\t}\n\n\t\tcase input.TaprootKeySpendBIP0086SignMethod:\n\t\t\tif len(signDesc.TapTweak) > 0 {\n\t\t\t\treturn nil, fmt.Errorf(\"tap tweak must be \" +\n\t\t\t\t\t\"empty for BIP0086 key spend\")\n\t\t\t}\n\n\t\tcase input.TaprootKeySpendSignMethod:\n\t\t\tif len(signDesc.TapTweak) != sha256.Size {\n\t\t\t\treturn nil, fmt.Errorf(\"tap tweak must be \" +\n\t\t\t\t\t\"specified for key spend with root \" +\n\t\t\t\t\t\"hash\")\n\t\t\t}\n\n\t\tcase input.TaprootScriptSpendSignMethod:\n\t\t\tif len(signDesc.WitnessScript) == 0 {\n\t\t\t\treturn nil, fmt.Errorf(\"witness script MUST \" +\n\t\t\t\t\t\"be specified for taproot script \" +\n\t\t\t\t\t\"spend method\")\n\t\t\t}\n\t\t}\n\n\t\t// If the users provided a double tweak, then we'll need to\n\t\t// parse that out now to ensure their input is properly signed.\n\t\tvar tweakPrivKey *btcec.PrivateKey\n\t\tif len(signDesc.DoubleTweak) != 0 {\n\t\t\ttweakPrivKey, _ = btcec.PrivKeyFromBytes(\n\t\t\t\tsignDesc.DoubleTweak,\n\t\t\t)\n\t\t}\n\n\t\t// Finally, with verification and parsing complete, we can\n\t\t// construct the final sign descriptor to generate the proper\n\t\t// signature for this input.\n\t\tsignDescs = append(signDescs, &input.SignDescriptor{\n\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\tKeyLocator: keyLoc,\n\t\t\t\tPubKey:     targetPubKey,\n\t\t\t},\n\t\t\tSingleTweak:   signDesc.SingleTweak,\n\t\t\tDoubleTweak:   tweakPrivKey,\n\t\t\tTapTweak:      signDesc.TapTweak,\n\t\t\tWitnessScript: signDesc.WitnessScript,\n\t\t\tSignMethod:    signMethod,\n\t\t\tOutput: &wire.TxOut{\n\t\t\t\tValue:    signDesc.Output.Value,\n\t\t\t\tPkScript: signDesc.Output.PkScript,\n\t\t\t},\n\t\t\tHashType:          txscript.SigHashType(signDesc.Sighash),\n\t\t\tSigHashes:         sigHashCache,\n\t\t\tInputIndex:        int(signDesc.InputIndex),\n\t\t\tPrevOutputFetcher: prevOutputFetcher,\n\t\t})\n\n\t\t// Are we trying to sign for a Taproot output? Then we need all\n\t\t// previous outputs being declared, otherwise we'd run into a\n\t\t// panic later on.\n\t\tif txscript.IsPayToTaproot(signDesc.Output.PkScript) {\n\t\t\tfor idx, txIn := range txToSign.TxIn {\n\t\t\t\tutxo := prevOutputFetcher.FetchPrevOutput(\n\t\t\t\t\ttxIn.PreviousOutPoint,\n\t\t\t\t)\n\t\t\t\tif utxo == nil {\n\t\t\t\t\treturn nil, fmt.Errorf(\"error signing \"+\n\t\t\t\t\t\t\"taproot output, transaction \"+\n\t\t\t\t\t\t\"input %d is missing its \"+\n\t\t\t\t\t\t\"previous outpoint information\",\n\t\t\t\t\t\tidx)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Now that we've mapped all the proper sign descriptors, we can\n\t// request signatures for each of them, passing in the transaction to\n\t// be signed.\n\tnumSigs := len(in.SignDescs)\n\tresp := &SignResp{\n\t\tRawSigs: make([][]byte, numSigs),\n\t}\n\tfor i, signDesc := range signDescs {\n\t\tsig, err := s.cfg.Signer.SignOutputRaw(&txToSign, signDesc)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"unable to generate sig for input \"+\n\t\t\t\t\"#%v: %v\", i, err)\n\n\t\t\treturn nil, err\n\t\t}\n\n\t\tresp.RawSigs[i] = sig.Serialize()\n\t}\n\n\treturn resp, nil\n}\n\n// ComputeInputScript generates a complete InputIndex for the passed\n// transaction with the signature as defined within the passed SignDescriptor.\n// This method should be capable of generating the proper input script for both\n// regular p2wkh/p2tr outputs and p2wkh outputs nested within a regular p2sh\n// output.\n//\n// Note that when using this method to sign inputs belonging to the wallet, the\n// only items of the SignDescriptor that need to be populated are pkScript in\n// the TxOut field, the value in that same field, and finally the input index.",
      "length": 7195,
      "tokens": 992,
      "embedding": []
    },
    {
      "slug": "func (s *Server) ComputeInputScript(ctx context.Context,",
      "content": "func (s *Server) ComputeInputScript(ctx context.Context,\n\tin *SignReq) (*InputScriptResp, error) {\n\n\tswitch {\n\t// If the client doesn't specify a transaction, then there's nothing to\n\t// sign, so we'll exit early.\n\tcase len(in.RawTxBytes) == 0:\n\t\treturn nil, fmt.Errorf(\"a transaction to sign MUST be \" +\n\t\t\t\"passed in\")\n\n\t// If the client doesn't tell us *how* to sign the transaction, then we\n\t// can't sign anything, so we'll exit early.\n\tcase len(in.SignDescs) == 0:\n\t\treturn nil, fmt.Errorf(\"at least one SignDescs MUST be \" +\n\t\t\t\"passed in\")\n\t}\n\n\t// Now that we know we have an actual transaction to decode, we'll\n\t// deserialize it into something that we can properly utilize.\n\tvar txToSign wire.MsgTx\n\ttxReader := bytes.NewReader(in.RawTxBytes)\n\tif err := txToSign.Deserialize(txReader); err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to decode tx: %v\", err)\n\t}\n\n\tvar (\n\t\tsigHashCache      = input.NewTxSigHashesV0Only(&txToSign)\n\t\tprevOutputFetcher = txscript.NewMultiPrevOutFetcher(nil)\n\t)\n\n\t// If we're spending one or more SegWit v1 (Taproot) inputs, then we\n\t// need the full UTXO information available.\n\tif len(in.PrevOutputs) > 0 {\n\t\tif len(in.PrevOutputs) != len(txToSign.TxIn) {\n\t\t\treturn nil, fmt.Errorf(\"provided previous outputs \" +\n\t\t\t\t\"doesn't match number of transaction inputs\")\n\t\t}\n\n\t\t// Add all previous inputs to our sighash prev out fetcher so we\n\t\t// can calculate the sighash correctly.\n\t\tfor idx, txIn := range txToSign.TxIn {\n\t\t\tprevOutputFetcher.AddPrevOut(\n\t\t\t\ttxIn.PreviousOutPoint, &wire.TxOut{\n\t\t\t\t\tValue:    in.PrevOutputs[idx].Value,\n\t\t\t\t\tPkScript: in.PrevOutputs[idx].PkScript,\n\t\t\t\t},\n\t\t\t)\n\t\t}\n\t\tsigHashCache = txscript.NewTxSigHashes(\n\t\t\t&txToSign, prevOutputFetcher,\n\t\t)\n\t}\n\n\tsignDescs := make([]*input.SignDescriptor, 0, len(in.SignDescs))\n\tfor _, signDesc := range in.SignDescs {\n\t\t// For this method, the only fields that we care about are the\n\t\t// hash type, and the information concerning the output as we\n\t\t// only know how to provide full witnesses for outputs that we\n\t\t// solely control.\n\t\tsignDescs = append(signDescs, &input.SignDescriptor{\n\t\t\tOutput: &wire.TxOut{\n\t\t\t\tValue:    signDesc.Output.Value,\n\t\t\t\tPkScript: signDesc.Output.PkScript,\n\t\t\t},\n\t\t\tHashType:          txscript.SigHashType(signDesc.Sighash),\n\t\t\tSigHashes:         sigHashCache,\n\t\t\tPrevOutputFetcher: prevOutputFetcher,\n\t\t\tInputIndex:        int(signDesc.InputIndex),\n\t\t})\n\t}\n\n\t// With all of our signDescs assembled, we can now generate a valid\n\t// input script for each of them, and collate the responses to return\n\t// back to the caller.\n\tnumWitnesses := len(in.SignDescs)\n\tresp := &InputScriptResp{\n\t\tInputScripts: make([]*InputScript, numWitnesses),\n\t}\n\tfor i, signDesc := range signDescs {\n\t\tinputScript, err := s.cfg.Signer.ComputeInputScript(\n\t\t\t&txToSign, signDesc,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tresp.InputScripts[i] = &InputScript{\n\t\t\tWitness:   inputScript.Witness,\n\t\t\tSigScript: inputScript.SigScript,\n\t\t}\n\t}\n\n\treturn resp, nil\n}\n\n// SignMessage signs a message with the key specified in the key locator. The\n// returned signature is fixed-size LN wire format encoded.",
      "length": 2965,
      "tokens": 394,
      "embedding": []
    },
    {
      "slug": "func (s *Server) SignMessage(_ context.Context,",
      "content": "func (s *Server) SignMessage(_ context.Context,\n\tin *SignMessageReq) (*SignMessageResp, error) {\n\n\tif in.Msg == nil {\n\t\treturn nil, fmt.Errorf(\"a message to sign MUST be passed in\")\n\t}\n\tif in.KeyLoc == nil {\n\t\treturn nil, fmt.Errorf(\"a key locator MUST be passed in\")\n\t}\n\tif in.SchnorrSig && in.CompactSig {\n\t\treturn nil, fmt.Errorf(\"compact format can not be used for \" +\n\t\t\t\"Schnorr signatures\")\n\t}\n\n\t// Describe the private key we'll be using for signing.\n\tkeyLocator := keychain.KeyLocator{\n\t\tFamily: keychain.KeyFamily(in.KeyLoc.KeyFamily),\n\t\tIndex:  uint32(in.KeyLoc.KeyIndex),\n\t}\n\n\t// Use the schnorr signature algorithm to sign the message.\n\tif in.SchnorrSig {\n\t\tsig, err := s.cfg.KeyRing.SignMessageSchnorr(\n\t\t\tkeyLocator, in.Msg, in.DoubleHash,\n\t\t\tin.SchnorrSigTapTweak,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"can't sign the hash: %v\", err)\n\t\t}\n\n\t\tsigParsed, err := schnorr.ParseSignature(sig.Serialize())\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"can't parse Schnorr \"+\n\t\t\t\t\"signature: %v\", err)\n\t\t}\n\n\t\treturn &SignMessageResp{\n\t\t\tSignature: sigParsed.Serialize(),\n\t\t}, nil\n\t}\n\n\t// To allow a watch-only wallet to forward the SignMessageCompact to an\n\t// endpoint that doesn't add the message prefix, we allow this RPC to\n\t// also return the compact signature format instead of adding a flag to\n\t// the lnrpc.SignMessage call that removes the message prefix.\n\tif in.CompactSig {\n\t\tsigBytes, err := s.cfg.KeyRing.SignMessageCompact(\n\t\t\tkeyLocator, in.Msg, in.DoubleHash,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"can't sign the hash: %v\", err)\n\t\t}\n\n\t\treturn &SignMessageResp{\n\t\t\tSignature: sigBytes,\n\t\t}, nil\n\t}\n\n\t// Create the raw ECDSA signature first and convert it to the final wire\n\t// format after.\n\tsig, err := s.cfg.KeyRing.SignMessage(\n\t\tkeyLocator, in.Msg, in.DoubleHash,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"can't sign the hash: %v\", err)\n\t}\n\twireSig, err := lnwire.NewSigFromSignature(sig)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"can't convert to wire format: %v\", err)\n\t}\n\treturn &SignMessageResp{\n\t\tSignature: wireSig.ToSignatureBytes(),\n\t}, nil\n}\n\n// VerifyMessage verifies a signature over a message using the public key\n// provided. The signature must be fixed-size LN wire format encoded.",
      "length": 2125,
      "tokens": 302,
      "embedding": []
    },
    {
      "slug": "func (s *Server) VerifyMessage(_ context.Context,",
      "content": "func (s *Server) VerifyMessage(_ context.Context,\n\tin *VerifyMessageReq) (*VerifyMessageResp, error) {\n\n\tif in.Msg == nil {\n\t\treturn nil, fmt.Errorf(\"a message to verify MUST be passed in\")\n\t}\n\tif in.Signature == nil {\n\t\treturn nil, fmt.Errorf(\"a signature to verify MUST be passed \" +\n\t\t\t\"in\")\n\t}\n\tif in.Pubkey == nil {\n\t\treturn nil, fmt.Errorf(\"a pubkey to verify MUST be passed in\")\n\t}\n\n\t// We allow for Schnorr signatures to be verified.\n\tif in.IsSchnorrSig {\n\t\t// We expect the public key to be in the BIP-340 32-byte format\n\t\t// for Schnorr signatures.\n\t\tpubkey, err := schnorr.ParsePubKey(in.Pubkey)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to parse pubkey: %v\",\n\t\t\t\terr)\n\t\t}\n\n\t\tsigParsed, err := schnorr.ParseSignature(in.Signature)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"can't parse Schnorr \"+\n\t\t\t\t\"signature: %v\", err)\n\t\t}\n\n\t\tdigest := chainhash.HashB(in.Msg)\n\t\tvalid := sigParsed.Verify(digest, pubkey)\n\n\t\treturn &VerifyMessageResp{\n\t\t\tValid: valid,\n\t\t}, nil\n\t}\n\n\tpubkey, err := btcec.ParsePubKey(in.Pubkey)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to parse pubkey: %v\", err)\n\t}\n\n\t// The signature must be fixed-size LN wire format encoded.\n\twireSig, err := lnwire.NewSigFromRawSignature(in.Signature)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to decode signature: %v\", err)\n\t}\n\tsig, err := wireSig.ToSignature()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to convert from wire format: %v\",\n\t\t\terr)\n\t}\n\n\t// The signature is over the sha256 hash of the message.\n\tdigest := chainhash.HashB(in.Msg)\n\tvalid := sig.Verify(digest, pubkey)\n\treturn &VerifyMessageResp{\n\t\tValid: valid,\n\t}, nil\n}\n\n// DeriveSharedKey returns a shared secret key by performing Diffie-Hellman key\n// derivation between the ephemeral public key in the request and the node's\n// key specified in the key_desc parameter. Either a key locator or a raw public\n// key is expected in the key_desc, if neither is supplied, defaults to the\n// node's identity private key. The old key_loc parameter in the request\n// shouldn't be used anymore.\n// The resulting shared public key is serialized in the compressed format and\n// hashed with sha256, resulting in the final key length of 256bit.",
      "length": 2083,
      "tokens": 321,
      "embedding": []
    },
    {
      "slug": "func (s *Server) DeriveSharedKey(_ context.Context, in *SharedKeyRequest) (",
      "content": "func (s *Server) DeriveSharedKey(_ context.Context, in *SharedKeyRequest) (\n\t*SharedKeyResponse, error) {\n\n\t// Check that EphemeralPubkey is valid.\n\tephemeralPubkey, err := parseRawKeyBytes(in.EphemeralPubkey)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error in ephemeral pubkey: %v\", err)\n\t}\n\tif ephemeralPubkey == nil {\n\t\treturn nil, fmt.Errorf(\"must provide ephemeral pubkey\")\n\t}\n\n\t// Check for backward compatibility. The caller either specifies the old\n\t// key_loc field, or the new key_desc field, but not both.\n\tif in.KeyDesc != nil && in.KeyLoc != nil {\n\t\treturn nil, fmt.Errorf(\"use either key_desc or key_loc\")\n\t}\n\n\t// When key_desc is used, the key_desc.key_loc is expected as the caller\n\t// needs to specify the KeyFamily.\n\tif in.KeyDesc != nil && in.KeyDesc.KeyLoc == nil {\n\t\treturn nil, fmt.Errorf(\"when setting key_desc the field \" +\n\t\t\t\"key_desc.key_loc must also be set\")\n\t}\n\n\t// We extract two params, rawKeyBytes and keyLoc. Notice their initial\n\t// values will be overwritten if not using the deprecated RPC param.\n\tvar rawKeyBytes []byte\n\tkeyLoc := in.KeyLoc\n\tif in.KeyDesc != nil {\n\t\tkeyLoc = in.KeyDesc.GetKeyLoc()\n\t\trawKeyBytes = in.KeyDesc.GetRawKeyBytes()\n\t}\n\n\t// When no keyLoc is supplied, defaults to the node's identity private\n\t// key.\n\tif keyLoc == nil {\n\t\tkeyLoc = &KeyLocator{\n\t\t\tKeyFamily: int32(keychain.KeyFamilyNodeKey),\n\t\t\tKeyIndex:  0,\n\t\t}\n\t}\n\n\t// Check the caller is using either the key index or the raw public key\n\t// to perform the ECDH, we can't have both.\n\tif rawKeyBytes != nil && keyLoc.KeyIndex != 0 {\n\t\treturn nil, fmt.Errorf(\"use either raw_key_bytes or key_index\")\n\t}\n\n\t// Check the raw public key is valid. Notice that if the rawKeyBytes is\n\t// empty, the parseRawKeyBytes won't return an error, a nil\n\t// *btcec.PublicKey is returned instead.\n\tpk, err := parseRawKeyBytes(rawKeyBytes)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error in raw pubkey: %v\", err)\n\t}\n\n\t// Create a key descriptor. When the KeyIndex is not specified, it uses\n\t// the empty value 0, and when the raw public key is not specified, the\n\t// pk is nil.\n\tkeyDescriptor := keychain.KeyDescriptor{\n\t\tKeyLocator: keychain.KeyLocator{\n\t\t\tFamily: keychain.KeyFamily(keyLoc.KeyFamily),\n\t\t\tIndex:  uint32(keyLoc.KeyIndex),\n\t\t},\n\t\tPubKey: pk,\n\t}\n\n\t// Derive the shared key using ECDH and hashing the serialized\n\t// compressed shared point.\n\tsharedKeyHash, err := s.cfg.KeyRing.ECDH(keyDescriptor, ephemeralPubkey)\n\tif err != nil {\n\t\terr := fmt.Errorf(\"unable to derive shared key: %v\", err)\n\t\tlog.Error(err)\n\t\treturn nil, err\n\t}\n\n\treturn &SharedKeyResponse{SharedKey: sharedKeyHash[:]}, nil\n}\n\n// MuSig2CombineKeys combines the given set of public keys into a single\n// combined MuSig2 combined public key, applying the given tweaks.",
      "length": 2593,
      "tokens": 388,
      "embedding": []
    },
    {
      "slug": "func (s *Server) MuSig2CombineKeys(_ context.Context,",
      "content": "func (s *Server) MuSig2CombineKeys(_ context.Context,\n\tin *MuSig2CombineKeysRequest) (*MuSig2CombineKeysResponse, error) {\n\n\t// Check the now mandatory version first. We made the version mandatory,\n\t// so we don't get unexpected/undefined behavior for old clients that\n\t// don't specify the version. Since this API is still declared to be\n\t// experimental this should be the approach that leads to the least\n\t// amount of unexpected behavior.\n\tversion, err := UnmarshalMuSig2Version(in.Version)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error parsing version: %w\", err)\n\t}\n\n\t// Parse the public keys of all signing participants. This must also\n\t// include our own, local key.\n\tallSignerPubKeys, err := input.MuSig2ParsePubKeys(\n\t\tversion, in.AllSignerPubkeys,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error parsing all signer public \"+\n\t\t\t\"keys: %w\", err)\n\t}\n\n\t// Are there any tweaks to apply to the combined public key?\n\ttweaks, err := UnmarshalTweaks(in.Tweaks, in.TaprootTweak)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error unmarshaling tweak options: %v\",\n\t\t\terr)\n\t}\n\n\t// Combine the keys now without creating a session in memory.\n\tcombinedKey, err := input.MuSig2CombineKeys(\n\t\tversion, allSignerPubKeys, true, tweaks,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error combining keys: %v\", err)\n\t}\n\n\tvar internalKeyBytes []byte\n\tif combinedKey.PreTweakedKey != nil {\n\t\tinternalKeyBytes = schnorr.SerializePubKey(\n\t\t\tcombinedKey.PreTweakedKey,\n\t\t)\n\t}\n\n\treturn &MuSig2CombineKeysResponse{\n\t\tCombinedKey: schnorr.SerializePubKey(\n\t\t\tcombinedKey.FinalKey,\n\t\t),\n\t\tTaprootInternalKey: internalKeyBytes,\n\t\tVersion:            in.Version,\n\t}, nil\n}\n\n// MuSig2CreateSession creates a new MuSig2 signing session using the local\n// key identified by the key locator. The complete list of all public keys of\n// all signing parties must be provided, including the public key of the local\n// signing key. If nonces of other parties are already known, they can be\n// submitted as well to reduce the number of RPC calls necessary later on.",
      "length": 1929,
      "tokens": 276,
      "embedding": []
    },
    {
      "slug": "func (s *Server) MuSig2CreateSession(_ context.Context,",
      "content": "func (s *Server) MuSig2CreateSession(_ context.Context,\n\tin *MuSig2SessionRequest) (*MuSig2SessionResponse, error) {\n\n\t// Check the now mandatory version first. We made the version mandatory,\n\t// so we don't get unexpected/undefined behavior for old clients that\n\t// don't specify the version. Since this API is still declared to be\n\t// experimental this should be the approach that leads to the least\n\t// amount of unexpected behavior.\n\tversion, err := UnmarshalMuSig2Version(in.Version)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error parsing version: %w\", err)\n\t}\n\n\t// A key locator is always mandatory.\n\tif in.KeyLoc == nil {\n\t\treturn nil, fmt.Errorf(\"missing key_loc\")\n\t}\n\tkeyLoc := keychain.KeyLocator{\n\t\tFamily: keychain.KeyFamily(in.KeyLoc.KeyFamily),\n\t\tIndex:  uint32(in.KeyLoc.KeyIndex),\n\t}\n\n\t// Parse the public keys of all signing participants. This must also\n\t// include our own, local key.\n\tallSignerPubKeys, err := input.MuSig2ParsePubKeys(\n\t\tversion, in.AllSignerPubkeys,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error parsing all signer public \"+\n\t\t\t\"keys: %w\", err)\n\t}\n\n\t// We participate a nonce ourselves, so we can't have more nonces than\n\t// the total number of participants minus ourselves.\n\tmaxNonces := len(in.AllSignerPubkeys) - 1\n\tif len(in.OtherSignerPublicNonces) > maxNonces {\n\t\treturn nil, fmt.Errorf(\"too many other signer public nonces, \"+\n\t\t\t\"got %d but expected a maximum of %d\",\n\t\t\tlen(in.OtherSignerPublicNonces), maxNonces)\n\t}\n\n\t// Parse all other nonces we might already know.\n\totherSignerNonces, err := parseMuSig2PublicNonces(\n\t\tin.OtherSignerPublicNonces, true,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error parsing other nonces: %v\", err)\n\t}\n\n\t// Are there any tweaks to apply to the combined public key?\n\ttweaks, err := UnmarshalTweaks(in.Tweaks, in.TaprootTweak)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error unmarshaling tweak options: %v\",\n\t\t\terr)\n\t}\n\n\t// Register the session with the internal wallet/signer now.\n\tsession, err := s.cfg.Signer.MuSig2CreateSession(\n\t\tversion, keyLoc, allSignerPubKeys, tweaks, otherSignerNonces,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error registering session: %v\", err)\n\t}\n\n\tvar internalKeyBytes []byte\n\tif session.TaprootTweak {\n\t\tinternalKeyBytes = schnorr.SerializePubKey(\n\t\t\tsession.TaprootInternalKey,\n\t\t)\n\t}\n\n\treturn &MuSig2SessionResponse{\n\t\tSessionId: session.SessionID[:],\n\t\tCombinedKey: schnorr.SerializePubKey(\n\t\t\tsession.CombinedKey,\n\t\t),\n\t\tTaprootInternalKey: internalKeyBytes,\n\t\tLocalPublicNonces:  session.PublicNonce[:],\n\t\tHaveAllNonces:      session.HaveAllNonces,\n\t\tVersion:            in.Version,\n\t}, nil\n}\n\n// MuSig2RegisterNonces registers one or more public nonces of other signing\n// participants for a session identified by its ID.",
      "length": 2620,
      "tokens": 337,
      "embedding": []
    },
    {
      "slug": "func (s *Server) MuSig2RegisterNonces(_ context.Context,",
      "content": "func (s *Server) MuSig2RegisterNonces(_ context.Context,\n\tin *MuSig2RegisterNoncesRequest) (*MuSig2RegisterNoncesResponse, error) {\n\n\t// Check session ID length.\n\tsessionID, err := parseMuSig2SessionID(in.SessionId)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error parsing session ID: %v\", err)\n\t}\n\n\t// Parse the other signing participants' nonces. We can't validate the\n\t// number of nonces here because we don't have access to the session in\n\t// this context. But the signer will be able to make sure we don't\n\t// register more nonces than there are signers (which would mean\n\t// something is wrong in the signing setup). But we want at least a\n\t// single nonce for each call.\n\totherSignerNonces, err := parseMuSig2PublicNonces(\n\t\tin.OtherSignerPublicNonces, false,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error parsing other nonces: %v\", err)\n\t}\n\n\t// Register the nonces now.\n\thaveAllNonces, err := s.cfg.Signer.MuSig2RegisterNonces(\n\t\tsessionID, otherSignerNonces,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error registering nonces: %v\", err)\n\t}\n\n\treturn &MuSig2RegisterNoncesResponse{HaveAllNonces: haveAllNonces}, nil\n}\n\n// MuSig2Sign creates a partial signature using the local signing key that was\n// specified when the session was created. This can only be called when all\n// public nonces of all participants are known and have been registered with\n// the session. If this node isn't responsible for combining all the partial\n// signatures, then the cleanup flag should be set, indicating that the session\n// can be removed from memory once the signature was produced.",
      "length": 1494,
      "tokens": 226,
      "embedding": []
    },
    {
      "slug": "func (s *Server) MuSig2Sign(_ context.Context,",
      "content": "func (s *Server) MuSig2Sign(_ context.Context,\n\tin *MuSig2SignRequest) (*MuSig2SignResponse, error) {\n\n\t// Check session ID length.\n\tsessionID, err := parseMuSig2SessionID(in.SessionId)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error parsing session ID: %v\", err)\n\t}\n\n\t// Schnorr signatures only work reliably if the message is 32 bytes.\n\tmsg := [sha256.Size]byte{}\n\tif len(in.MessageDigest) != sha256.Size {\n\t\treturn nil, fmt.Errorf(\"invalid message digest size, got %d \"+\n\t\t\t\"but expected %d\", len(in.MessageDigest), sha256.Size)\n\t}\n\tcopy(msg[:], in.MessageDigest)\n\n\t// Create our own partial signature with the local signing key.\n\tpartialSig, err := s.cfg.Signer.MuSig2Sign(sessionID, msg, in.Cleanup)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error signing: %v\", err)\n\t}\n\n\tserializedPartialSig, err := input.SerializePartialSignature(partialSig)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error serializing sig: %v\", err)\n\t}\n\n\treturn &MuSig2SignResponse{\n\t\tLocalPartialSignature: serializedPartialSig[:],\n\t}, nil\n}\n\n// MuSig2CombineSig combines the given partial signature(s) with the local one,\n// if it already exists. Once a partial signature of all participants is\n// registered, the final signature will be combined and returned.",
      "length": 1159,
      "tokens": 152,
      "embedding": []
    },
    {
      "slug": "func (s *Server) MuSig2CombineSig(_ context.Context,",
      "content": "func (s *Server) MuSig2CombineSig(_ context.Context,\n\tin *MuSig2CombineSigRequest) (*MuSig2CombineSigResponse, error) {\n\n\t// Check session ID length.\n\tsessionID, err := parseMuSig2SessionID(in.SessionId)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error parsing session ID: %v\", err)\n\t}\n\n\t// Parse all other signatures. This can be called multiple times, so we\n\t// can't really sanity check how many we already have vs. how many the\n\t// user supplied in this call.\n\tpartialSigs, err := parseMuSig2PartialSignatures(\n\t\tin.OtherPartialSignatures,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error parsing partial signatures: %v\",\n\t\t\terr)\n\t}\n\n\t// Combine the signatures now, potentially getting the final, full\n\t// signature if we've already got all partial ones.\n\tfinalSig, haveAllSigs, err := s.cfg.Signer.MuSig2CombineSig(\n\t\tsessionID, partialSigs,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error combining signatures: %v\", err)\n\t}\n\n\tresp := &MuSig2CombineSigResponse{\n\t\tHaveAllSignatures: haveAllSigs,\n\t}\n\n\tif haveAllSigs {\n\t\tresp.FinalSignature = finalSig.Serialize()\n\t}\n\n\treturn resp, err\n}\n\n// MuSig2Cleanup removes a session from memory to free up resources.",
      "length": 1076,
      "tokens": 149,
      "embedding": []
    },
    {
      "slug": "func (s *Server) MuSig2Cleanup(_ context.Context,",
      "content": "func (s *Server) MuSig2Cleanup(_ context.Context,\n\tin *MuSig2CleanupRequest) (*MuSig2CleanupResponse, error) {\n\n\t// Check session ID length.\n\tsessionID, err := parseMuSig2SessionID(in.SessionId)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error parsing session ID: %v\", err)\n\t}\n\n\terr = s.cfg.Signer.MuSig2Cleanup(sessionID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error cleaning up session: %v\", err)\n\t}\n\n\treturn &MuSig2CleanupResponse{}, nil\n}\n\n// parseRawKeyBytes checks that the provided raw public key is valid and returns\n// the public key. A nil public key is returned if the length of the rawKeyBytes\n// is zero.",
      "length": 553,
      "tokens": 81,
      "embedding": []
    },
    {
      "slug": "func parseRawKeyBytes(rawKeyBytes []byte) (*btcec.PublicKey, error) {",
      "content": "func parseRawKeyBytes(rawKeyBytes []byte) (*btcec.PublicKey, error) {\n\tswitch {\n\tcase len(rawKeyBytes) == 33:\n\t\t// If a proper raw key was provided, then we'll attempt\n\t\t// to decode and parse it.\n\t\treturn btcec.ParsePubKey(rawKeyBytes)\n\n\tcase len(rawKeyBytes) == 0:\n\t\t// No key is provided, return nil.\n\t\treturn nil, nil\n\n\tdefault:\n\t\t// If the user provided a raw key, but it's of the\n\t\t// wrong length, then we'll return with an error.\n\t\treturn nil, fmt.Errorf(\"pubkey must be \" +\n\t\t\t\"serialized in compressed format if \" +\n\t\t\t\"specified\")\n\t}\n}\n\n// parseMuSig2SessionID parses a MuSig2 session ID from a raw byte slice.",
      "length": 532,
      "tokens": 90,
      "embedding": []
    },
    {
      "slug": "func parseMuSig2SessionID(rawID []byte) (input.MuSig2SessionID, error) {",
      "content": "func parseMuSig2SessionID(rawID []byte) (input.MuSig2SessionID, error) {\n\tsessionID := input.MuSig2SessionID{}\n\n\t// The session ID must be exact in its length.\n\tif len(rawID) != sha256.Size {\n\t\treturn sessionID, fmt.Errorf(\"invalid session ID size, got \"+\n\t\t\t\"%d but expected %d\", len(rawID), sha256.Size)\n\t}\n\tcopy(sessionID[:], rawID)\n\n\treturn sessionID, nil\n}\n\n// parseMuSig2PublicNonces sanity checks and parses the other signers' public\n// nonces.",
      "length": 365,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func parseMuSig2PublicNonces(pubNonces [][]byte,",
      "content": "func parseMuSig2PublicNonces(pubNonces [][]byte,\n\temptyAllowed bool) ([][musig2.PubNonceSize]byte, error) {\n\n\t// For some calls the nonces are optional while for others it doesn't\n\t// make any sense to not specify them (for example for the explicit\n\t// nonce registration call there should be at least one nonce).\n\tif !emptyAllowed && len(pubNonces) == 0 {\n\t\treturn nil, fmt.Errorf(\"at least one other signer public \" +\n\t\t\t\"nonce is required\")\n\t}\n\n\t// Parse all other nonces. This can be called multiple times, so we\n\t// can't really sanity check how many we already have vs. how many the\n\t// user supplied in this call.\n\totherSignerNonces := make([][musig2.PubNonceSize]byte, len(pubNonces))\n\tfor idx, otherNonceBytes := range pubNonces {\n\t\tif len(otherNonceBytes) != musig2.PubNonceSize {\n\t\t\treturn nil, fmt.Errorf(\"invalid public nonce at \"+\n\t\t\t\t\"index %d: invalid length, got %d but \"+\n\t\t\t\t\"expected %d\", idx, len(otherNonceBytes),\n\t\t\t\tmusig2.PubNonceSize)\n\t\t}\n\t\tcopy(otherSignerNonces[idx][:], otherNonceBytes)\n\t}\n\n\treturn otherSignerNonces, nil\n}\n\n// parseMuSig2PartialSignatures sanity checks and parses the other signers'\n// partial signatures.",
      "length": 1075,
      "tokens": 152,
      "embedding": []
    },
    {
      "slug": "func parseMuSig2PartialSignatures(",
      "content": "func parseMuSig2PartialSignatures(\n\tpartialSignatures [][]byte) ([]*musig2.PartialSignature, error) {\n\n\t// We always want at least one partial signature.\n\tif len(partialSignatures) == 0 {\n\t\treturn nil, fmt.Errorf(\"at least one partial signature is \" +\n\t\t\t\"required\")\n\t}\n\n\tparsedPartialSigs := make(\n\t\t[]*musig2.PartialSignature, len(partialSignatures),\n\t)\n\tfor idx, otherPartialSigBytes := range partialSignatures {\n\t\tsig, err := input.DeserializePartialSignature(\n\t\t\totherPartialSigBytes,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"invalid partial signature at \"+\n\t\t\t\t\"index %d: %v\", idx, err)\n\t\t}\n\n\t\tparsedPartialSigs[idx] = sig\n\t}\n\n\treturn parsedPartialSigs, nil\n}\n\n// UnmarshalTweaks parses the RPC tweak descriptions into their native\n// counterpart.",
      "length": 699,
      "tokens": 88,
      "embedding": []
    },
    {
      "slug": "func UnmarshalTweaks(rpcTweaks []*TweakDesc,",
      "content": "func UnmarshalTweaks(rpcTweaks []*TweakDesc,\n\ttaprootTweak *TaprootTweakDesc) (*input.MuSig2Tweaks, error) {\n\n\t// Parse the generic tweaks first.\n\ttweaks := &input.MuSig2Tweaks{\n\t\tGenericTweaks: make([]musig2.KeyTweakDesc, len(rpcTweaks)),\n\t}\n\tfor idx, rpcTweak := range rpcTweaks {\n\t\tif len(rpcTweak.Tweak) == 0 {\n\t\t\treturn nil, fmt.Errorf(\"tweak cannot be empty\")\n\t\t}\n\n\t\tcopy(tweaks.GenericTweaks[idx].Tweak[:], rpcTweak.Tweak)\n\t\ttweaks.GenericTweaks[idx].IsXOnly = rpcTweak.IsXOnly\n\t}\n\n\t// Now parse the taproot specific tweak.\n\tif taprootTweak != nil {\n\t\tif taprootTweak.KeySpendOnly {\n\t\t\ttweaks.TaprootBIP0086Tweak = true\n\t\t} else {\n\t\t\tif len(taprootTweak.ScriptRoot) == 0 {\n\t\t\t\treturn nil, fmt.Errorf(\"script root cannot \" +\n\t\t\t\t\t\"be empty for non-keyspend\")\n\t\t\t}\n\n\t\t\ttweaks.TaprootTweak = taprootTweak.ScriptRoot\n\t\t}\n\t}\n\n\treturn tweaks, nil\n}\n\n// UnmarshalSignMethod parses the RPC sign method into the native counterpart.",
      "length": 852,
      "tokens": 101,
      "embedding": []
    },
    {
      "slug": "func UnmarshalSignMethod(rpcSignMethod SignMethod) (input.SignMethod, error) {",
      "content": "func UnmarshalSignMethod(rpcSignMethod SignMethod) (input.SignMethod, error) {\n\tswitch rpcSignMethod {\n\tcase SignMethod_SIGN_METHOD_WITNESS_V0:\n\t\treturn input.WitnessV0SignMethod, nil\n\n\tcase SignMethod_SIGN_METHOD_TAPROOT_KEY_SPEND_BIP0086:\n\t\treturn input.TaprootKeySpendBIP0086SignMethod, nil\n\n\tcase SignMethod_SIGN_METHOD_TAPROOT_KEY_SPEND:\n\t\treturn input.TaprootKeySpendSignMethod, nil\n\n\tcase SignMethod_SIGN_METHOD_TAPROOT_SCRIPT_SPEND:\n\t\treturn input.TaprootScriptSpendSignMethod, nil\n\n\tdefault:\n\t\treturn 0, fmt.Errorf(\"unknown RPC sign method <%d>\",\n\t\t\trpcSignMethod)\n\t}\n}\n",
      "length": 482,
      "tokens": 34,
      "embedding": []
    }
  ]
}