{
  "filepath": "../implementations/go/lnd/lnrpc/chainrpc/chain_server.go",
  "package": "chainrpc",
  "sections": [
    {
      "slug": "//go:build chainrpc",
      "content": "//go:build chainrpc\n// +build chainrpc\n\npackage chainrpc\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sync\"\n\n\t\"github.com/btcsuite/btcd/chaincfg/chainhash\"\n\t\"github.com/btcsuite/btcd/wire\"\n\t\"github.com/grpc-ecosystem/grpc-gateway/v2/runtime\"\n\t\"github.com/lightningnetwork/lnd/chainntnfs\"\n\t\"github.com/lightningnetwork/lnd/lnrpc\"\n\t\"github.com/lightningnetwork/lnd/macaroons\"\n\t\"google.golang.org/grpc\"\n\t\"gopkg.in/macaroon-bakery.v2/bakery\"\n)\n\nconst (\n\t// subServerName is the name of the RPC sub-server. We'll use this name\n\t// to register ourselves, and we also require that the main\n\t// SubServerConfigDispatcher instance recognize this as the name of the\n\t// config file that we need.\n\tsubServerName = \"ChainRPC\"\n)\n\nvar (\n\t// macaroonOps are the set of capabilities that our minted macaroon (if\n\t// it doesn't already exist) will have.\n\tmacaroonOps = []bakery.Op{\n\t\t{\n\t\t\tEntity: \"onchain\",\n\t\t\tAction: \"read\",\n\t\t},\n\t}\n\n\t// macPermissions maps RPC calls to the permissions they require.\n\tmacPermissions = map[string][]bakery.Op{\n\t\t\"/chainrpc.ChainKit/GetBlock\": {{\n\t\t\tEntity: \"onchain\",\n\t\t\tAction: \"read\",\n\t\t}},\n\t\t\"/chainrpc.ChainKit/GetBestBlock\": {{\n\t\t\tEntity: \"onchain\",\n\t\t\tAction: \"read\",\n\t\t}},\n\t\t\"/chainrpc.ChainKit/GetBlockHash\": {{\n\t\t\tEntity: \"onchain\",\n\t\t\tAction: \"read\",\n\t\t}},\n\t\t\"/chainrpc.ChainNotifier/RegisterConfirmationsNtfn\": {{\n\t\t\tEntity: \"onchain\",\n\t\t\tAction: \"read\",\n\t\t}},\n\t\t\"/chainrpc.ChainNotifier/RegisterSpendNtfn\": {{\n\t\t\tEntity: \"onchain\",\n\t\t\tAction: \"read\",\n\t\t}},\n\t\t\"/chainrpc.ChainNotifier/RegisterBlockEpochNtfn\": {{\n\t\t\tEntity: \"onchain\",\n\t\t\tAction: \"read\",\n\t\t}},\n\t}\n\n\t// DefaultChainNotifierMacFilename is the default name of the chain\n\t// notifier macaroon that we expect to find via a file handle within the\n\t// main configuration file in this package.\n\tDefaultChainNotifierMacFilename = \"chainnotifier.macaroon\"\n\n\t// ErrChainNotifierServerShuttingDown is an error returned when we are\n\t// waiting for a notification to arrive but the chain notifier server\n\t// has been shut down.\n\tErrChainNotifierServerShuttingDown = errors.New(\"chain notifier RPC \" +\n\t\t\"subserver shutting down\")\n\n\t// ErrChainNotifierServerNotActive indicates that the chain notifier hasn't\n\t// finished the startup process.\n\tErrChainNotifierServerNotActive = errors.New(\"chain notifier RPC is \" +\n\t\t\"still in the process of starting\")\n)\n\n// ServerShell is a shell struct holding a reference to the actual sub-server.\n// It is used to register the gRPC sub-server with the root server before we\n// have the necessary dependencies to populate the actual sub-server.",
      "length": 2487,
      "tokens": 291,
      "embedding": []
    },
    {
      "slug": "type ServerShell struct {",
      "content": "type ServerShell struct {\n\tChainKitServer\n\tChainNotifierServer\n}\n\n// Server is a sub-server of the main RPC server. It serves the chainkit RPC\n// and chain notifier RPC. This RPC sub-server allows external callers to access\n// the full chainkit and chain notifier capabilities of lnd. This allows callers\n// to create custom protocols, external to lnd, even backed by multiple distinct\n// lnd across independent failure domains.",
      "length": 394,
      "tokens": 63,
      "embedding": []
    },
    {
      "slug": "type Server struct {",
      "content": "type Server struct {\n\t// Required by the grpc-gateway/v2 library for forward compatibility.\n\tUnimplementedChainNotifierServer\n\tUnimplementedChainKitServer\n\n\tstarted sync.Once\n\tstopped sync.Once\n\n\tcfg Config\n\n\tquit chan struct{}\n}\n\n// New returns a new instance of the chainrpc ChainNotifier sub-server. We also\n// return the set of permissions for the macaroons that we may create within\n// this method. If the macaroons we need aren't found in the filepath, then\n// we'll create them on start up. If we're unable to locate, or create the\n// macaroons we need, then we'll return with an error.",
      "length": 556,
      "tokens": 87,
      "embedding": []
    },
    {
      "slug": "func New(cfg *Config) (*Server, lnrpc.MacaroonPerms, error) {",
      "content": "func New(cfg *Config) (*Server, lnrpc.MacaroonPerms, error) {\n\t// If the path of the chain notifier macaroon wasn't generated, then\n\t// we'll assume that it's found at the default network directory.\n\tif cfg.ChainNotifierMacPath == \"\" {\n\t\tcfg.ChainNotifierMacPath = filepath.Join(\n\t\t\tcfg.NetworkDir, DefaultChainNotifierMacFilename,\n\t\t)\n\t}\n\n\t// Now that we know the full path of the chain notifier macaroon, we can\n\t// check to see if we need to create it or not. If stateless_init is set\n\t// then we don't write the macaroons.\n\tmacFilePath := cfg.ChainNotifierMacPath\n\tif cfg.MacService != nil && !cfg.MacService.StatelessInit &&\n\t\t!lnrpc.FileExists(macFilePath) {\n\n\t\tlog.Infof(\"Baking macaroons for ChainNotifier RPC Server at: %v\",\n\t\t\tmacFilePath)\n\n\t\t// At this point, we know that the chain notifier macaroon\n\t\t// doesn't yet, exist, so we need to create it with the help of\n\t\t// the main macaroon service.\n\t\tchainNotifierMac, err := cfg.MacService.NewMacaroon(\n\t\t\tcontext.Background(), macaroons.DefaultRootKeyID,\n\t\t\tmacaroonOps...,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\tchainNotifierMacBytes, err := chainNotifierMac.M().MarshalBinary()\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\terr = ioutil.WriteFile(macFilePath, chainNotifierMacBytes, 0644)\n\t\tif err != nil {\n\t\t\t_ = os.Remove(macFilePath)\n\t\t\treturn nil, nil, err\n\t\t}\n\t}\n\n\treturn &Server{\n\t\tcfg:  *cfg,\n\t\tquit: make(chan struct{}),\n\t}, macPermissions, nil\n}\n\n// Compile-time checks to ensure that Server fully implements the\n// ChainNotifierServer gRPC service, ChainKitServer gRPC service, and\n// lnrpc.SubServer interface.\nvar _ ChainNotifierServer = (*Server)(nil)\nvar _ ChainKitServer = (*Server)(nil)\nvar _ lnrpc.SubServer = (*Server)(nil)\n\n// Start launches any helper goroutines required for the server to function.\n//\n// NOTE: This is part of the lnrpc.SubServer interface.",
      "length": 1742,
      "tokens": 244,
      "embedding": []
    },
    {
      "slug": "func (s *Server) Start() error {",
      "content": "func (s *Server) Start() error {\n\ts.started.Do(func() {})\n\treturn nil\n}\n\n// Stop signals any active goroutines for a graceful closure.\n//\n// NOTE: This is part of the lnrpc.SubServer interface.",
      "length": 154,
      "tokens": 25,
      "embedding": []
    },
    {
      "slug": "func (s *Server) Stop() error {",
      "content": "func (s *Server) Stop() error {\n\ts.stopped.Do(func() {\n\t\tclose(s.quit)\n\t})\n\treturn nil\n}\n\n// Name returns a unique string representation of the sub-server. This can be\n// used to identify the sub-server and also de-duplicate them.\n//\n// NOTE: This is part of the lnrpc.SubServer interface.",
      "length": 248,
      "tokens": 40,
      "embedding": []
    },
    {
      "slug": "func (s *Server) Name() string {",
      "content": "func (s *Server) Name() string {\n\treturn subServerName\n}\n\n// RegisterWithRootServer will be called by the root gRPC server to direct a RPC\n// sub-server to register itself with the main gRPC root server. Until this is\n// called, each sub-server won't be able to have requests routed towards it.\n//\n// NOTE: This is part of the lnrpc.GrpcHandler interface.",
      "length": 315,
      "tokens": 54,
      "embedding": []
    },
    {
      "slug": "func (r *ServerShell) RegisterWithRootServer(grpcServer *grpc.Server) error {",
      "content": "func (r *ServerShell) RegisterWithRootServer(grpcServer *grpc.Server) error {\n\t// We make sure that we register it with the main gRPC server to ensure\n\t// all our methods are routed properly.\n\tRegisterChainNotifierServer(grpcServer, r)\n\tlog.Debug(\"ChainNotifier RPC server successfully register with root \" +\n\t\t\"gRPC server\")\n\n\tRegisterChainKitServer(grpcServer, r)\n\tlog.Debug(\"ChainKit RPC server successfully register with root gRPC \" +\n\t\t\"server\")\n\n\treturn nil\n}\n\n// RegisterWithRestServer will be called by the root REST mux to direct a sub\n// RPC server to register itself with the main REST mux server. Until this is\n// called, each sub-server won't be able to have requests routed towards it.\n//\n// NOTE: This is part of the lnrpc.GrpcHandler interface.",
      "length": 665,
      "tokens": 103,
      "embedding": []
    },
    {
      "slug": "func (r *ServerShell) RegisterWithRestServer(ctx context.Context,",
      "content": "func (r *ServerShell) RegisterWithRestServer(ctx context.Context,\n\tmux *runtime.ServeMux, dest string, opts []grpc.DialOption) error {\n\n\t// We make sure that we register it with the main REST server to ensure\n\t// all our methods are routed properly.\n\terr := RegisterChainNotifierHandlerFromEndpoint(ctx, mux, dest, opts)\n\tif err != nil {\n\t\tlog.Errorf(\"Could not register ChainNotifier REST server \"+\n\t\t\t\"with root REST server: %v\", err)\n\t\treturn err\n\t}\n\n\tlog.Debugf(\"ChainNotifier REST server successfully registered with \" +\n\t\t\"root REST server\")\n\n\t// Register chainkit with the main REST server to ensure all our methods\n\t// are routed properly.\n\terr = RegisterChainKitHandlerFromEndpoint(ctx, mux, dest, opts)\n\tif err != nil {\n\t\tlog.Errorf(\"Could not register ChainKit REST server with root \"+\n\t\t\t\"REST server: %v\", err)\n\t\treturn err\n\t}\n\tlog.Debugf(\"ChainKit REST server successfully registered with root \" +\n\t\t\"REST server\")\n\n\treturn nil\n}\n\n// CreateSubServer populates the subserver's dependencies using the passed\n// SubServerConfigDispatcher. This method should fully initialize the\n// sub-server instance, making it ready for action. It returns the macaroon\n// permissions that the sub-server wishes to pass on to the root server for all\n// methods routed towards it.\n//\n// NOTE: This is part of the lnrpc.GrpcHandler interface.",
      "length": 1236,
      "tokens": 185,
      "embedding": []
    },
    {
      "slug": "func (r *ServerShell) CreateSubServer(configRegistry lnrpc.SubServerConfigDispatcher) (",
      "content": "func (r *ServerShell) CreateSubServer(configRegistry lnrpc.SubServerConfigDispatcher) (\n\tlnrpc.SubServer, lnrpc.MacaroonPerms, error) {\n\n\tsubServer, macPermissions, err := createNewSubServer(configRegistry)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tr.ChainNotifierServer = subServer\n\tr.ChainKitServer = subServer\n\treturn subServer, macPermissions, nil\n}\n\n// GetBlock returns a block given the corresponding block hash.",
      "length": 321,
      "tokens": 40,
      "embedding": []
    },
    {
      "slug": "func (s *Server) GetBlock(ctx context.Context,",
      "content": "func (s *Server) GetBlock(ctx context.Context,\n\tin *GetBlockRequest) (*GetBlockResponse, error) {\n\n\t// We'll start by reconstructing the RPC request into what the\n\t// underlying chain functionality expects.\n\tvar blockHash chainhash.Hash\n\tcopy(blockHash[:], in.BlockHash)\n\n\tblock, err := s.cfg.Chain.GetBlock(&blockHash)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Serialize block for RPC response.\n\tvar blockBuf bytes.Buffer\n\terr = block.Serialize(&blockBuf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trawBlock := blockBuf.Bytes()\n\n\treturn &GetBlockResponse{RawBlock: rawBlock}, nil\n}\n\n// GetBestBlock returns the latest block hash and current height of the valid\n// most-work chain.",
      "length": 607,
      "tokens": 84,
      "embedding": []
    },
    {
      "slug": "func (s *Server) GetBestBlock(ctx context.Context,",
      "content": "func (s *Server) GetBestBlock(ctx context.Context,\n\treq *GetBestBlockRequest) (*GetBestBlockResponse, error) {\n\n\tblockHash, blockHeight, err := s.cfg.Chain.GetBestBlock()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &GetBestBlockResponse{\n\t\tBlockHash:   blockHash[:],\n\t\tBlockHeight: blockHeight,\n\t}, nil\n}\n\n// GetBlockHash returns the hash of the block in the best blockchain\n// at the given height.",
      "length": 336,
      "tokens": 45,
      "embedding": []
    },
    {
      "slug": "func (s *Server) GetBlockHash(ctx context.Context,",
      "content": "func (s *Server) GetBlockHash(ctx context.Context,\n\treq *GetBlockHashRequest) (*GetBlockHashResponse, error) {\n\n\tblockHash, err := s.cfg.Chain.GetBlockHash(req.BlockHeight)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &GetBlockHashResponse{\n\t\tBlockHash: blockHash[:],\n\t}, nil\n}\n\n// RegisterConfirmationsNtfn is a synchronous response-streaming RPC that\n// registers an intent for a client to be notified once a confirmation request\n// has reached its required number of confirmations on-chain.\n//\n// A client can specify whether the confirmation request should be for a\n// particular transaction by its hash or for an output script by specifying a\n// zero hash.\n//\n// NOTE: This is part of the chainrpc.ChainNotifierService interface.",
      "length": 665,
      "tokens": 97,
      "embedding": []
    },
    {
      "slug": "func (s *Server) RegisterConfirmationsNtfn(in *ConfRequest,",
      "content": "func (s *Server) RegisterConfirmationsNtfn(in *ConfRequest,\n\tconfStream ChainNotifier_RegisterConfirmationsNtfnServer) error {\n\n\tif !s.cfg.ChainNotifier.Started() {\n\t\treturn ErrChainNotifierServerNotActive\n\t}\n\n\t// We'll start by reconstructing the RPC request into what the\n\t// underlying ChainNotifier expects.\n\tvar txid chainhash.Hash\n\tcopy(txid[:], in.Txid)\n\n\tvar opts []chainntnfs.NotifierOption\n\tif in.IncludeBlock {\n\t\topts = append(opts, chainntnfs.WithIncludeBlock())\n\t}\n\n\t// We'll then register for the spend notification of the request.\n\tconfEvent, err := s.cfg.ChainNotifier.RegisterConfirmationsNtfn(\n\t\t&txid, in.Script, in.NumConfs, in.HeightHint, opts...,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer confEvent.Cancel()\n\n\t// With the request registered, we'll wait for its spend notification to\n\t// be dispatched.\n\tfor {\n\t\tselect {\n\t\t// The transaction satisfying the request has confirmed on-chain\n\t\t// and reached its required number of confirmations. We'll\n\t\t// dispatch an event to the caller indicating so.\n\t\tcase details, ok := <-confEvent.Confirmed:\n\t\t\tif !ok {\n\t\t\t\treturn chainntnfs.ErrChainNotifierShuttingDown\n\t\t\t}\n\n\t\t\tvar rawTxBuf bytes.Buffer\n\t\t\terr := details.Tx.Serialize(&rawTxBuf)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// If the block was included (should only be there if\n\t\t\t// IncludeBlock is true), then we'll encode the bytes\n\t\t\t// to send with the response.\n\t\t\tvar blockBytes []byte\n\t\t\tif details.Block != nil {\n\t\t\t\tvar blockBuf bytes.Buffer\n\t\t\t\terr := details.Block.Serialize(&blockBuf)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tblockBytes = blockBuf.Bytes()\n\t\t\t}\n\n\t\t\trpcConfDetails := &ConfDetails{\n\t\t\t\tRawTx:       rawTxBuf.Bytes(),\n\t\t\t\tBlockHash:   details.BlockHash[:],\n\t\t\t\tBlockHeight: details.BlockHeight,\n\t\t\t\tTxIndex:     details.TxIndex,\n\t\t\t\tRawBlock:    blockBytes,\n\t\t\t}\n\n\t\t\tconf := &ConfEvent{\n\t\t\t\tEvent: &ConfEvent_Conf{\n\t\t\t\t\tConf: rpcConfDetails,\n\t\t\t\t},\n\t\t\t}\n\t\t\tif err := confStream.Send(conf); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t// The transaction satisfying the request has been reorged out\n\t\t// of the chain, so we'll send an event describing it.\n\t\tcase _, ok := <-confEvent.NegativeConf:\n\t\t\tif !ok {\n\t\t\t\treturn chainntnfs.ErrChainNotifierShuttingDown\n\t\t\t}\n\n\t\t\treorg := &ConfEvent{\n\t\t\t\tEvent: &ConfEvent_Reorg{Reorg: &Reorg{}},\n\t\t\t}\n\t\t\tif err := confStream.Send(reorg); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t// The transaction satisfying the request has confirmed and is\n\t\t// no longer under the risk of being reorged out of the chain,\n\t\t// so we can safely exit.\n\t\tcase _, ok := <-confEvent.Done:\n\t\t\tif !ok {\n\t\t\t\treturn chainntnfs.ErrChainNotifierShuttingDown\n\t\t\t}\n\n\t\t\treturn nil\n\n\t\t// The response stream's context for whatever reason has been\n\t\t// closed. If context is closed by an exceeded deadline we will\n\t\t// return an error.\n\t\tcase <-confStream.Context().Done():\n\t\t\tif errors.Is(confStream.Context().Err(), context.Canceled) {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn confStream.Context().Err()\n\n\t\t// The server has been requested to shut down.\n\t\tcase <-s.quit:\n\t\t\treturn ErrChainNotifierServerShuttingDown\n\t\t}\n\t}\n}\n\n// RegisterSpendNtfn is a synchronous response-streaming RPC that registers an\n// intent for a client to be notification once a spend request has been spent by\n// a transaction that has confirmed on-chain.\n//\n// A client can specify whether the spend request should be for a particular\n// outpoint  or for an output script by specifying a zero outpoint.\n//\n// NOTE: This is part of the chainrpc.ChainNotifierService interface.",
      "length": 3317,
      "tokens": 444,
      "embedding": []
    },
    {
      "slug": "func (s *Server) RegisterSpendNtfn(in *SpendRequest,",
      "content": "func (s *Server) RegisterSpendNtfn(in *SpendRequest,\n\tspendStream ChainNotifier_RegisterSpendNtfnServer) error {\n\n\tif !s.cfg.ChainNotifier.Started() {\n\t\treturn ErrChainNotifierServerNotActive\n\t}\n\n\t// We'll start by reconstructing the RPC request into what the\n\t// underlying ChainNotifier expects.\n\tvar op *wire.OutPoint\n\tif in.Outpoint != nil {\n\t\tvar txid chainhash.Hash\n\t\tcopy(txid[:], in.Outpoint.Hash)\n\t\top = &wire.OutPoint{Hash: txid, Index: in.Outpoint.Index}\n\t}\n\n\t// We'll then register for the spend notification of the request.\n\tspendEvent, err := s.cfg.ChainNotifier.RegisterSpendNtfn(\n\t\top, in.Script, in.HeightHint,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer spendEvent.Cancel()\n\n\t// With the request registered, we'll wait for its spend notification to\n\t// be dispatched.\n\tfor {\n\t\tselect {\n\t\t// A transaction that spends the given has confirmed on-chain.\n\t\t// We'll return an event to the caller indicating so that\n\t\t// includes the details of the spending transaction.\n\t\tcase details, ok := <-spendEvent.Spend:\n\t\t\tif !ok {\n\t\t\t\treturn chainntnfs.ErrChainNotifierShuttingDown\n\t\t\t}\n\n\t\t\tvar rawSpendingTxBuf bytes.Buffer\n\t\t\terr := details.SpendingTx.Serialize(&rawSpendingTxBuf)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\trpcSpendDetails := &SpendDetails{\n\t\t\t\tSpendingOutpoint: &Outpoint{\n\t\t\t\t\tHash:  details.SpentOutPoint.Hash[:],\n\t\t\t\t\tIndex: details.SpentOutPoint.Index,\n\t\t\t\t},\n\t\t\t\tRawSpendingTx:      rawSpendingTxBuf.Bytes(),\n\t\t\t\tSpendingTxHash:     details.SpenderTxHash[:],\n\t\t\t\tSpendingInputIndex: details.SpenderInputIndex,\n\t\t\t\tSpendingHeight:     uint32(details.SpendingHeight),\n\t\t\t}\n\n\t\t\tspend := &SpendEvent{\n\t\t\t\tEvent: &SpendEvent_Spend{\n\t\t\t\t\tSpend: rpcSpendDetails,\n\t\t\t\t},\n\t\t\t}\n\t\t\tif err := spendStream.Send(spend); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t// The spending transaction of the request has been reorged of\n\t\t// the chain. We'll return an event to the caller indicating so.\n\t\tcase _, ok := <-spendEvent.Reorg:\n\t\t\tif !ok {\n\t\t\t\treturn chainntnfs.ErrChainNotifierShuttingDown\n\t\t\t}\n\n\t\t\treorg := &SpendEvent{\n\t\t\t\tEvent: &SpendEvent_Reorg{Reorg: &Reorg{}},\n\t\t\t}\n\t\t\tif err := spendStream.Send(reorg); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t// The spending transaction of the requests has confirmed\n\t\t// on-chain and is no longer under the risk of being reorged out\n\t\t// of the chain, so we can safely exit.\n\t\tcase _, ok := <-spendEvent.Done:\n\t\t\tif !ok {\n\t\t\t\treturn chainntnfs.ErrChainNotifierShuttingDown\n\t\t\t}\n\n\t\t\treturn nil\n\n\t\t// The response stream's context for whatever reason has been\n\t\t// closed. If context is closed by an exceeded deadline we will\n\t\t// return an error.\n\t\tcase <-spendStream.Context().Done():\n\t\t\tif errors.Is(spendStream.Context().Err(), context.Canceled) {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn spendStream.Context().Err()\n\n\t\t// The server has been requested to shut down.\n\t\tcase <-s.quit:\n\t\t\treturn ErrChainNotifierServerShuttingDown\n\t\t}\n\t}\n}\n\n// RegisterBlockEpochNtfn is a synchronous response-streaming RPC that registers\n// an intent for a client to be notified of blocks in the chain. The stream will\n// return a hash and height tuple of a block for each new/stale block in the\n// chain. It is the client's responsibility to determine whether the tuple\n// returned is for a new or stale block in the chain.\n//\n// A client can also request a historical backlog of blocks from a particular\n// point. This allows clients to be idempotent by ensuring that they do not\n// missing processing a single block within the chain.\n//\n// NOTE: This is part of the chainrpc.ChainNotifierService interface.",
      "length": 3368,
      "tokens": 449,
      "embedding": []
    },
    {
      "slug": "func (s *Server) RegisterBlockEpochNtfn(in *BlockEpoch,",
      "content": "func (s *Server) RegisterBlockEpochNtfn(in *BlockEpoch,\n\tepochStream ChainNotifier_RegisterBlockEpochNtfnServer) error {\n\n\tif !s.cfg.ChainNotifier.Started() {\n\t\treturn ErrChainNotifierServerNotActive\n\t}\n\n\t// We'll start by reconstructing the RPC request into what the\n\t// underlying ChainNotifier expects.\n\tvar hash chainhash.Hash\n\tcopy(hash[:], in.Hash)\n\n\t// If the request isn't for a zero hash and a zero height, then we\n\t// should deliver a backlog of notifications from the given block\n\t// (hash/height tuple) until tip, and continue delivering epochs for\n\t// new blocks.\n\tvar blockEpoch *chainntnfs.BlockEpoch\n\tif hash != chainntnfs.ZeroHash && in.Height != 0 {\n\t\tblockEpoch = &chainntnfs.BlockEpoch{\n\t\t\tHash:   &hash,\n\t\t\tHeight: int32(in.Height),\n\t\t}\n\t}\n\n\tepochEvent, err := s.cfg.ChainNotifier.RegisterBlockEpochNtfn(blockEpoch)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer epochEvent.Cancel()\n\n\tfor {\n\t\tselect {\n\t\t// A notification for a block has been received. This block can\n\t\t// either be a new block or stale.\n\t\tcase blockEpoch, ok := <-epochEvent.Epochs:\n\t\t\tif !ok {\n\t\t\t\treturn chainntnfs.ErrChainNotifierShuttingDown\n\t\t\t}\n\n\t\t\tepoch := &BlockEpoch{\n\t\t\t\tHash:   blockEpoch.Hash[:],\n\t\t\t\tHeight: uint32(blockEpoch.Height),\n\t\t\t}\n\t\t\tif err := epochStream.Send(epoch); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t// The response stream's context for whatever reason has been\n\t\t// closed. If context is closed by an exceeded deadline we will\n\t\t// return an error.\n\t\tcase <-epochStream.Context().Done():\n\t\t\tif errors.Is(epochStream.Context().Err(), context.Canceled) {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn epochStream.Context().Err()\n\n\t\t// The server has been requested to shut down.\n\t\tcase <-s.quit:\n\t\t\treturn ErrChainNotifierServerShuttingDown\n\t\t}\n\t}\n}\n",
      "length": 1625,
      "tokens": 211,
      "embedding": []
    }
  ]
}