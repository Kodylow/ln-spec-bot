{
  "filepath": "../implementations/go/lnd/lnrpc/chainrpc/chainnotifier.pb.gw.go",
  "package": "chainrpc",
  "sections": [
    {
      "slug": "func request_ChainNotifier_RegisterConfirmationsNtfn_0(ctx context.Context, marshaler runtime.Marshaler, client ChainNotifierClient, req *http.Request, pathParams map[string]string) (ChainNotifier_RegisterConfirmationsNtfnClient, runtime.ServerMetadata, error) {",
      "content": "func request_ChainNotifier_RegisterConfirmationsNtfn_0(ctx context.Context, marshaler runtime.Marshaler, client ChainNotifierClient, req *http.Request, pathParams map[string]string) (ChainNotifier_RegisterConfirmationsNtfnClient, runtime.ServerMetadata, error) {\n\tvar protoReq ConfRequest\n\tvar metadata runtime.ServerMetadata\n\n\tnewReader, berr := utilities.IOReaderFactory(req.Body)\n\tif berr != nil {\n\t\treturn nil, metadata, status.Errorf(codes.InvalidArgument, \"%v\", berr)\n\t}\n\tif err := marshaler.NewDecoder(newReader()).Decode(&protoReq); err != nil && err != io.EOF {\n\t\treturn nil, metadata, status.Errorf(codes.InvalidArgument, \"%v\", err)\n\t}\n\n\tstream, err := client.RegisterConfirmationsNtfn(ctx, &protoReq)\n\tif err != nil {\n\t\treturn nil, metadata, err\n\t}\n\theader, err := stream.Header()\n\tif err != nil {\n\t\treturn nil, metadata, err\n\t}\n\tmetadata.HeaderMD = header\n\treturn stream, metadata, nil\n\n}\n",
      "length": 615,
      "tokens": 78,
      "embedding": []
    },
    {
      "slug": "func request_ChainNotifier_RegisterSpendNtfn_0(ctx context.Context, marshaler runtime.Marshaler, client ChainNotifierClient, req *http.Request, pathParams map[string]string) (ChainNotifier_RegisterSpendNtfnClient, runtime.ServerMetadata, error) {",
      "content": "func request_ChainNotifier_RegisterSpendNtfn_0(ctx context.Context, marshaler runtime.Marshaler, client ChainNotifierClient, req *http.Request, pathParams map[string]string) (ChainNotifier_RegisterSpendNtfnClient, runtime.ServerMetadata, error) {\n\tvar protoReq SpendRequest\n\tvar metadata runtime.ServerMetadata\n\n\tnewReader, berr := utilities.IOReaderFactory(req.Body)\n\tif berr != nil {\n\t\treturn nil, metadata, status.Errorf(codes.InvalidArgument, \"%v\", berr)\n\t}\n\tif err := marshaler.NewDecoder(newReader()).Decode(&protoReq); err != nil && err != io.EOF {\n\t\treturn nil, metadata, status.Errorf(codes.InvalidArgument, \"%v\", err)\n\t}\n\n\tstream, err := client.RegisterSpendNtfn(ctx, &protoReq)\n\tif err != nil {\n\t\treturn nil, metadata, err\n\t}\n\theader, err := stream.Header()\n\tif err != nil {\n\t\treturn nil, metadata, err\n\t}\n\tmetadata.HeaderMD = header\n\treturn stream, metadata, nil\n\n}\n",
      "length": 608,
      "tokens": 78,
      "embedding": []
    },
    {
      "slug": "func request_ChainNotifier_RegisterBlockEpochNtfn_0(ctx context.Context, marshaler runtime.Marshaler, client ChainNotifierClient, req *http.Request, pathParams map[string]string) (ChainNotifier_RegisterBlockEpochNtfnClient, runtime.ServerMetadata, error) {",
      "content": "func request_ChainNotifier_RegisterBlockEpochNtfn_0(ctx context.Context, marshaler runtime.Marshaler, client ChainNotifierClient, req *http.Request, pathParams map[string]string) (ChainNotifier_RegisterBlockEpochNtfnClient, runtime.ServerMetadata, error) {\n\tvar protoReq BlockEpoch\n\tvar metadata runtime.ServerMetadata\n\n\tnewReader, berr := utilities.IOReaderFactory(req.Body)\n\tif berr != nil {\n\t\treturn nil, metadata, status.Errorf(codes.InvalidArgument, \"%v\", berr)\n\t}\n\tif err := marshaler.NewDecoder(newReader()).Decode(&protoReq); err != nil && err != io.EOF {\n\t\treturn nil, metadata, status.Errorf(codes.InvalidArgument, \"%v\", err)\n\t}\n\n\tstream, err := client.RegisterBlockEpochNtfn(ctx, &protoReq)\n\tif err != nil {\n\t\treturn nil, metadata, err\n\t}\n\theader, err := stream.Header()\n\tif err != nil {\n\t\treturn nil, metadata, err\n\t}\n\tmetadata.HeaderMD = header\n\treturn stream, metadata, nil\n\n}\n\n// RegisterChainNotifierHandlerServer registers the http handlers for service ChainNotifier to \"mux\".\n// UnaryRPC     :call ChainNotifierServer directly.\n// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.\n// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterChainNotifierHandlerFromEndpoint instead.",
      "length": 1016,
      "tokens": 120,
      "embedding": []
    },
    {
      "slug": "func RegisterChainNotifierHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ChainNotifierServer) error {",
      "content": "func RegisterChainNotifierHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ChainNotifierServer) error {\n\n\tmux.Handle(\"POST\", pattern_ChainNotifier_RegisterConfirmationsNtfn_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {\n\t\terr := status.Error(codes.Unimplemented, \"streaming calls are not yet supported in the in-process transport\")\n\t\t_, outboundMarshaler := runtime.MarshalerForRequest(mux, req)\n\t\truntime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)\n\t\treturn\n\t})\n\n\tmux.Handle(\"POST\", pattern_ChainNotifier_RegisterSpendNtfn_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {\n\t\terr := status.Error(codes.Unimplemented, \"streaming calls are not yet supported in the in-process transport\")\n\t\t_, outboundMarshaler := runtime.MarshalerForRequest(mux, req)\n\t\truntime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)\n\t\treturn\n\t})\n\n\tmux.Handle(\"POST\", pattern_ChainNotifier_RegisterBlockEpochNtfn_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {\n\t\terr := status.Error(codes.Unimplemented, \"streaming calls are not yet supported in the in-process transport\")\n\t\t_, outboundMarshaler := runtime.MarshalerForRequest(mux, req)\n\t\truntime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)\n\t\treturn\n\t})\n\n\treturn nil\n}\n\n// RegisterChainNotifierHandlerFromEndpoint is same as RegisterChainNotifierHandler but\n// automatically dials to \"endpoint\" and closes the connection when \"ctx\" gets done.",
      "length": 1357,
      "tokens": 128,
      "embedding": []
    },
    {
      "slug": "func RegisterChainNotifierHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {",
      "content": "func RegisterChainNotifierHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {\n\tconn, err := grpc.Dial(endpoint, opts...)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() {\n\t\tif err != nil {\n\t\t\tif cerr := conn.Close(); cerr != nil {\n\t\t\t\tgrpclog.Infof(\"Failed to close conn to %s: %v\", endpoint, cerr)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tgo func() {\n\t\t\t<-ctx.Done()\n\t\t\tif cerr := conn.Close(); cerr != nil {\n\t\t\t\tgrpclog.Infof(\"Failed to close conn to %s: %v\", endpoint, cerr)\n\t\t\t}\n\t\t}()\n\t}()\n\n\treturn RegisterChainNotifierHandler(ctx, mux, conn)\n}\n\n// RegisterChainNotifierHandler registers the http handlers for service ChainNotifier to \"mux\".\n// The handlers forward requests to the grpc endpoint over \"conn\".",
      "length": 591,
      "tokens": 92,
      "embedding": []
    },
    {
      "slug": "func RegisterChainNotifierHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {",
      "content": "func RegisterChainNotifierHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {\n\treturn RegisterChainNotifierHandlerClient(ctx, mux, NewChainNotifierClient(conn))\n}\n\n// RegisterChainNotifierHandlerClient registers the http handlers for service ChainNotifier\n// to \"mux\". The handlers forward requests to the grpc endpoint over the given implementation of \"ChainNotifierClient\".\n// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in \"ChainNotifierClient\"\n// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in\n// \"ChainNotifierClient\" to call the correct interceptors.",
      "length": 572,
      "tokens": 76,
      "embedding": []
    },
    {
      "slug": "func RegisterChainNotifierHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ChainNotifierClient) error {",
      "content": "func RegisterChainNotifierHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ChainNotifierClient) error {\n\n\tmux.Handle(\"POST\", pattern_ChainNotifier_RegisterConfirmationsNtfn_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {\n\t\tctx, cancel := context.WithCancel(req.Context())\n\t\tdefer cancel()\n\t\tinboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)\n\t\trctx, err := runtime.AnnotateContext(ctx, mux, req, \"/chainrpc.ChainNotifier/RegisterConfirmationsNtfn\", runtime.WithHTTPPathPattern(\"/v2/chainnotifier/register/confirmations\"))\n\t\tif err != nil {\n\t\t\truntime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)\n\t\t\treturn\n\t\t}\n\t\tresp, md, err := request_ChainNotifier_RegisterConfirmationsNtfn_0(rctx, inboundMarshaler, client, req, pathParams)\n\t\tctx = runtime.NewServerMetadataContext(ctx, md)\n\t\tif err != nil {\n\t\t\truntime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)\n\t\t\treturn\n\t\t}\n\n\t\tforward_ChainNotifier_RegisterConfirmationsNtfn_0(ctx, mux, outboundMarshaler, w, req, func() (proto.Message, error) { return resp.Recv() }, mux.GetForwardResponseOptions()...)\n\n\t})\n\n\tmux.Handle(\"POST\", pattern_ChainNotifier_RegisterSpendNtfn_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {\n\t\tctx, cancel := context.WithCancel(req.Context())\n\t\tdefer cancel()\n\t\tinboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)\n\t\trctx, err := runtime.AnnotateContext(ctx, mux, req, \"/chainrpc.ChainNotifier/RegisterSpendNtfn\", runtime.WithHTTPPathPattern(\"/v2/chainnotifier/register/spends\"))\n\t\tif err != nil {\n\t\t\truntime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)\n\t\t\treturn\n\t\t}\n\t\tresp, md, err := request_ChainNotifier_RegisterSpendNtfn_0(rctx, inboundMarshaler, client, req, pathParams)\n\t\tctx = runtime.NewServerMetadataContext(ctx, md)\n\t\tif err != nil {\n\t\t\truntime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)\n\t\t\treturn\n\t\t}\n\n\t\tforward_ChainNotifier_RegisterSpendNtfn_0(ctx, mux, outboundMarshaler, w, req, func() (proto.Message, error) { return resp.Recv() }, mux.GetForwardResponseOptions()...)\n\n\t})\n\n\tmux.Handle(\"POST\", pattern_ChainNotifier_RegisterBlockEpochNtfn_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {\n\t\tctx, cancel := context.WithCancel(req.Context())\n\t\tdefer cancel()\n\t\tinboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)\n\t\trctx, err := runtime.AnnotateContext(ctx, mux, req, \"/chainrpc.ChainNotifier/RegisterBlockEpochNtfn\", runtime.WithHTTPPathPattern(\"/v2/chainnotifier/register/blocks\"))\n\t\tif err != nil {\n\t\t\truntime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)\n\t\t\treturn\n\t\t}\n\t\tresp, md, err := request_ChainNotifier_RegisterBlockEpochNtfn_0(rctx, inboundMarshaler, client, req, pathParams)\n\t\tctx = runtime.NewServerMetadataContext(ctx, md)\n\t\tif err != nil {\n\t\t\truntime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)\n\t\t\treturn\n\t\t}\n\n\t\tforward_ChainNotifier_RegisterBlockEpochNtfn_0(ctx, mux, outboundMarshaler, w, req, func() (proto.Message, error) { return resp.Recv() }, mux.GetForwardResponseOptions()...)\n\n\t})\n\n\treturn nil\n}\n\nvar (\n\tpattern_ChainNotifier_RegisterConfirmationsNtfn_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3}, []string{\"v2\", \"chainnotifier\", \"register\", \"confirmations\"}, \"\"))\n\n\tpattern_ChainNotifier_RegisterSpendNtfn_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3}, []string{\"v2\", \"chainnotifier\", \"register\", \"spends\"}, \"\"))\n\n\tpattern_ChainNotifier_RegisterBlockEpochNtfn_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3}, []string{\"v2\", \"chainnotifier\", \"register\", \"blocks\"}, \"\"))\n)\n\nvar (\n\tforward_ChainNotifier_RegisterConfirmationsNtfn_0 = runtime.ForwardResponseStream\n\n\tforward_ChainNotifier_RegisterSpendNtfn_0 = runtime.ForwardResponseStream\n\n\tforward_ChainNotifier_RegisterBlockEpochNtfn_0 = runtime.ForwardResponseStream\n)\n",
      "length": 3755,
      "tokens": 309,
      "embedding": []
    }
  ]
}