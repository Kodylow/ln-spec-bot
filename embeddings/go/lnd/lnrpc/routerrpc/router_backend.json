{
  "filepath": "../implementations/go/lnd/lnrpc/routerrpc/router_backend.go",
  "package": "routerrpc",
  "sections": [
    {
      "slug": "type RouterBackend struct {",
      "content": "type RouterBackend struct {\n\t// SelfNode is the vertex of the node sending the payment.\n\tSelfNode route.Vertex\n\n\t// FetchChannelCapacity is a closure that we'll use the fetch the total\n\t// capacity of a channel to populate in responses.\n\tFetchChannelCapacity func(chanID uint64) (btcutil.Amount, error)\n\n\t// FetchAmountPairCapacity determines the maximal channel capacity\n\t// between two nodes given a certain amount.\n\tFetchAmountPairCapacity func(nodeFrom, nodeTo route.Vertex,\n\t\tamount lnwire.MilliSatoshi) (btcutil.Amount, error)\n\n\t// FetchChannelEndpoints returns the pubkeys of both endpoints of the\n\t// given channel id.\n\tFetchChannelEndpoints func(chanID uint64) (route.Vertex,\n\t\troute.Vertex, error)\n\n\t// FindRoutes is a closure that abstracts away how we locate/query for\n\t// routes.\n\tFindRoute func(source, target route.Vertex,\n\t\tamt lnwire.MilliSatoshi, timePref float64,\n\t\trestrictions *routing.RestrictParams,\n\t\tdestCustomRecords record.CustomSet,\n\t\trouteHints map[route.Vertex][]*channeldb.CachedEdgePolicy,\n\t\tfinalExpiry uint16) (*route.Route, float64, error)\n\n\tMissionControl MissionControl\n\n\t// ActiveNetParams are the network parameters of the primary network\n\t// that the route is operating on. This is necessary so we can ensure\n\t// that we receive payment requests that send to destinations on our\n\t// network.\n\tActiveNetParams *chaincfg.Params\n\n\t// Tower is the ControlTower instance that is used to track pending\n\t// payments.\n\tTower routing.ControlTower\n\n\t// MaxTotalTimelock is the maximum total time lock a route is allowed to\n\t// have.\n\tMaxTotalTimelock uint32\n\n\t// DefaultFinalCltvDelta is the default value used as final cltv delta\n\t// when an RPC caller doesn't specify a value.\n\tDefaultFinalCltvDelta uint16\n\n\t// SubscribeHtlcEvents returns a subscription client for the node's\n\t// htlc events.\n\tSubscribeHtlcEvents func() (*subscribe.Client, error)\n\n\t// InterceptableForwarder exposes the ability to intercept forward events\n\t// by letting the router register a ForwardInterceptor.\n\tInterceptableForwarder htlcswitch.InterceptableHtlcForwarder\n\n\t// SetChannelEnabled exposes the ability to manually enable a channel.\n\tSetChannelEnabled func(wire.OutPoint) error\n\n\t// SetChannelDisabled exposes the ability to manually disable a channel\n\tSetChannelDisabled func(wire.OutPoint) error\n\n\t// SetChannelAuto exposes the ability to restore automatic channel state\n\t// management after manually setting channel status.\n\tSetChannelAuto func(wire.OutPoint) error\n}\n\n// MissionControl defines the mission control dependencies of routerrpc.",
      "length": 2467,
      "tokens": 303,
      "embedding": []
    },
    {
      "slug": "type MissionControl interface {",
      "content": "type MissionControl interface {\n\t// GetProbability is expected to return the success probability of a\n\t// payment from fromNode to toNode.\n\tGetProbability(fromNode, toNode route.Vertex,\n\t\tamt lnwire.MilliSatoshi, capacity btcutil.Amount) float64\n\n\t// ResetHistory resets the history of MissionControl returning it to a\n\t// state as if no payment attempts have been made.\n\tResetHistory() error\n\n\t// GetHistorySnapshot takes a snapshot from the current mission control\n\t// state and actual probability estimates.\n\tGetHistorySnapshot() *routing.MissionControlSnapshot\n\n\t// ImportHistory imports the mission control snapshot to our internal\n\t// state. This import will only be applied in-memory, and will not be\n\t// persisted across restarts.\n\tImportHistory(snapshot *routing.MissionControlSnapshot, force bool) error\n\n\t// GetPairHistorySnapshot returns the stored history for a given node\n\t// pair.\n\tGetPairHistorySnapshot(fromNode,\n\t\ttoNode route.Vertex) routing.TimedPairResult\n\n\t// GetConfig gets mission control's current config.\n\tGetConfig() *routing.MissionControlConfig\n\n\t// SetConfig sets mission control's config to the values provided, if\n\t// they are valid.\n\tSetConfig(cfg *routing.MissionControlConfig) error\n}\n\n// QueryRoutes attempts to query the daemons' Channel Router for a possible\n// route to a target destination capable of carrying a specific amount of\n// satoshis within the route's flow. The returned route contains the full\n// details required to craft and send an HTLC, also including the necessary\n// information that should be present within the Sphinx packet encapsulated\n// within the HTLC.\n//\n// TODO(roasbeef): should return a slice of routes in reality * create separate\n// PR to send based on well formatted route",
      "length": 1672,
      "tokens": 230,
      "embedding": []
    },
    {
      "slug": "func (r *RouterBackend) QueryRoutes(ctx context.Context,",
      "content": "func (r *RouterBackend) QueryRoutes(ctx context.Context,\n\tin *lnrpc.QueryRoutesRequest) (*lnrpc.QueryRoutesResponse, error) {\n\n\tparsePubKey := func(key string) (route.Vertex, error) {\n\t\tpubKeyBytes, err := hex.DecodeString(key)\n\t\tif err != nil {\n\t\t\treturn route.Vertex{}, err\n\t\t}\n\n\t\treturn route.NewVertexFromBytes(pubKeyBytes)\n\t}\n\n\t// Parse the hex-encoded source and target public keys into full public\n\t// key objects we can properly manipulate.\n\ttargetPubKey, err := parsePubKey(in.PubKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar sourcePubKey route.Vertex\n\tif in.SourcePubKey != \"\" {\n\t\tvar err error\n\t\tsourcePubKey, err = parsePubKey(in.SourcePubKey)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\t// If no source is specified, use self.\n\t\tsourcePubKey = r.SelfNode\n\t}\n\n\t// Currently, within the bootstrap phase of the network, we limit the\n\t// largest payment size allotted to (2^32) - 1 mSAT or 4.29 million\n\t// satoshis.\n\tamt, err := lnrpc.UnmarshallAmt(in.Amt, in.AmtMsat)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Unmarshall restrictions from request.\n\tfeeLimit := lnrpc.CalculateFeeLimit(in.FeeLimit, amt)\n\n\tignoredNodes := make(map[route.Vertex]struct{})\n\tfor _, ignorePubKey := range in.IgnoredNodes {\n\t\tignoreVertex, err := route.NewVertexFromBytes(ignorePubKey)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tignoredNodes[ignoreVertex] = struct{}{}\n\t}\n\n\tignoredPairs := make(map[routing.DirectedNodePair]struct{})\n\n\t// Convert deprecated ignoredEdges to pairs.\n\tfor _, ignoredEdge := range in.IgnoredEdges {\n\t\tpair, err := r.rpcEdgeToPair(ignoredEdge)\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"Ignore channel %v skipped: %v\",\n\t\t\t\tignoredEdge.ChannelId, err)\n\n\t\t\tcontinue\n\t\t}\n\t\tignoredPairs[pair] = struct{}{}\n\t}\n\n\t// Add ignored pairs to set.\n\tfor _, ignorePair := range in.IgnoredPairs {\n\t\tfrom, err := route.NewVertexFromBytes(ignorePair.From)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tto, err := route.NewVertexFromBytes(ignorePair.To)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpair := routing.NewDirectedNodePair(from, to)\n\t\tignoredPairs[pair] = struct{}{}\n\t}\n\n\t// Since QueryRoutes allows having a different source other than\n\t// ourselves, we'll only apply our max time lock if we are the source.\n\tmaxTotalTimelock := r.MaxTotalTimelock\n\tif sourcePubKey != r.SelfNode {\n\t\tmaxTotalTimelock = math.MaxUint32\n\t}\n\tcltvLimit, err := ValidateCLTVLimit(in.CltvLimit, maxTotalTimelock)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// We need to subtract the final delta before passing it into path\n\t// finding. The optimal path is independent of the final cltv delta and\n\t// the path finding algorithm is unaware of this value.\n\tfinalCLTVDelta := r.DefaultFinalCltvDelta\n\tif in.FinalCltvDelta != 0 {\n\t\tfinalCLTVDelta = uint16(in.FinalCltvDelta)\n\t}\n\n\t// Do bounds checking without block padding so we don't give routes\n\t// that will leave the router in a zombie payment state.\n\terr = routing.ValidateCLTVLimit(cltvLimit, finalCLTVDelta, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcltvLimit -= uint32(finalCLTVDelta)\n\n\t// Parse destination feature bits.\n\tfeatures, err := UnmarshalFeatures(in.DestFeatures)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trestrictions := &routing.RestrictParams{\n\t\tFeeLimit: feeLimit,\n\t\tProbabilitySource: func(fromNode, toNode route.Vertex,\n\t\t\tamt lnwire.MilliSatoshi,\n\t\t\tcapacity btcutil.Amount) float64 {\n\n\t\t\tif _, ok := ignoredNodes[fromNode]; ok {\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\tpair := routing.DirectedNodePair{\n\t\t\t\tFrom: fromNode,\n\t\t\t\tTo:   toNode,\n\t\t\t}\n\t\t\tif _, ok := ignoredPairs[pair]; ok {\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\tif !in.UseMissionControl {\n\t\t\t\treturn 1\n\t\t\t}\n\n\t\t\treturn r.MissionControl.GetProbability(\n\t\t\t\tfromNode, toNode, amt, capacity,\n\t\t\t)\n\t\t},\n\t\tDestCustomRecords: record.CustomSet(in.DestCustomRecords),\n\t\tCltvLimit:         cltvLimit,\n\t\tDestFeatures:      features,\n\t}\n\n\t// Pass along an outgoing channel restriction if specified.\n\tif in.OutgoingChanId != 0 {\n\t\trestrictions.OutgoingChannelIDs = []uint64{in.OutgoingChanId}\n\t}\n\n\t// Pass along a last hop restriction if specified.\n\tif len(in.LastHopPubkey) > 0 {\n\t\tlastHop, err := route.NewVertexFromBytes(\n\t\t\tin.LastHopPubkey,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\trestrictions.LastHop = &lastHop\n\t}\n\n\t// If we have any TLV records destined for the final hop, then we'll\n\t// attempt to decode them now into a form that the router can more\n\t// easily manipulate.\n\tcustomRecords := record.CustomSet(in.DestCustomRecords)\n\tif err := customRecords.Validate(); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Convert route hints to an edge map.\n\trouteHints, err := unmarshallRouteHints(in.RouteHints)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trouteHintEdges, err := routing.RouteHintsToEdges(\n\t\trouteHints, targetPubKey,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Query the channel router for a possible path to the destination that\n\t// can carry `in.Amt` satoshis _including_ the total fee required on\n\t// the route.\n\troute, successProb, err := r.FindRoute(\n\t\tsourcePubKey, targetPubKey, amt, in.TimePref, restrictions,\n\t\tcustomRecords, routeHintEdges, finalCLTVDelta,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// For each valid route, we'll convert the result into the format\n\t// required by the RPC system.\n\trpcRoute, err := r.MarshallRoute(route)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trouteResp := &lnrpc.QueryRoutesResponse{\n\t\tRoutes:      []*lnrpc.Route{rpcRoute},\n\t\tSuccessProb: successProb,\n\t}\n\n\treturn routeResp, nil\n}\n\n// rpcEdgeToPair looks up the provided channel and returns the channel endpoints\n// as a directed pair.",
      "length": 5258,
      "tokens": 725,
      "embedding": []
    },
    {
      "slug": "func (r *RouterBackend) rpcEdgeToPair(e *lnrpc.EdgeLocator) (",
      "content": "func (r *RouterBackend) rpcEdgeToPair(e *lnrpc.EdgeLocator) (\n\trouting.DirectedNodePair, error) {\n\n\ta, b, err := r.FetchChannelEndpoints(e.ChannelId)\n\tif err != nil {\n\t\treturn routing.DirectedNodePair{}, err\n\t}\n\n\tvar pair routing.DirectedNodePair\n\tif e.DirectionReverse {\n\t\tpair.From, pair.To = b, a\n\t} else {\n\t\tpair.From, pair.To = a, b\n\t}\n\n\treturn pair, nil\n}\n\n// MarshallRoute marshalls an internal route to an rpc route struct.",
      "length": 352,
      "tokens": 52,
      "embedding": []
    },
    {
      "slug": "func (r *RouterBackend) MarshallRoute(route *route.Route) (*lnrpc.Route, error) {",
      "content": "func (r *RouterBackend) MarshallRoute(route *route.Route) (*lnrpc.Route, error) {\n\tresp := &lnrpc.Route{\n\t\tTotalTimeLock: route.TotalTimeLock,\n\t\tTotalFees:     int64(route.TotalFees().ToSatoshis()),\n\t\tTotalFeesMsat: int64(route.TotalFees()),\n\t\tTotalAmt:      int64(route.TotalAmount.ToSatoshis()),\n\t\tTotalAmtMsat:  int64(route.TotalAmount),\n\t\tHops:          make([]*lnrpc.Hop, len(route.Hops)),\n\t}\n\tincomingAmt := route.TotalAmount\n\tfor i, hop := range route.Hops {\n\t\tfee := route.HopFee(i)\n\n\t\t// Channel capacity is not a defining property of a route. For\n\t\t// backwards RPC compatibility, we retrieve it here from the\n\t\t// graph.\n\t\tchanCapacity, err := r.FetchChannelCapacity(hop.ChannelID)\n\t\tif err != nil {\n\t\t\t// If capacity cannot be retrieved, this may be a\n\t\t\t// not-yet-received or private channel. Then report\n\t\t\t// amount that is sent through the channel as capacity.\n\t\t\tchanCapacity = incomingAmt.ToSatoshis()\n\t\t}\n\n\t\t// Extract the MPP fields if present on this hop.\n\t\tvar mpp *lnrpc.MPPRecord\n\t\tif hop.MPP != nil {\n\t\t\taddr := hop.MPP.PaymentAddr()\n\n\t\t\tmpp = &lnrpc.MPPRecord{\n\t\t\t\tPaymentAddr:  addr[:],\n\t\t\t\tTotalAmtMsat: int64(hop.MPP.TotalMsat()),\n\t\t\t}\n\t\t}\n\n\t\tresp.Hops[i] = &lnrpc.Hop{\n\t\t\tChanId:           hop.ChannelID,\n\t\t\tChanCapacity:     int64(chanCapacity),\n\t\t\tAmtToForward:     int64(hop.AmtToForward.ToSatoshis()),\n\t\t\tAmtToForwardMsat: int64(hop.AmtToForward),\n\t\t\tFee:              int64(fee.ToSatoshis()),\n\t\t\tFeeMsat:          int64(fee),\n\t\t\tExpiry:           uint32(hop.OutgoingTimeLock),\n\t\t\tPubKey: hex.EncodeToString(\n\t\t\t\thop.PubKeyBytes[:],\n\t\t\t),\n\t\t\tCustomRecords: hop.CustomRecords,\n\t\t\tTlvPayload:    !hop.LegacyPayload,\n\t\t\tMppRecord:     mpp,\n\t\t\tMetadata:      hop.Metadata,\n\t\t}\n\t\tincomingAmt = hop.AmtToForward\n\t}\n\n\treturn resp, nil\n}\n\n// UnmarshallHopWithPubkey unmarshalls an rpc hop for which the pubkey has\n// already been extracted.",
      "length": 1728,
      "tokens": 177,
      "embedding": []
    },
    {
      "slug": "func UnmarshallHopWithPubkey(rpcHop *lnrpc.Hop, pubkey route.Vertex) (*route.Hop,",
      "content": "func UnmarshallHopWithPubkey(rpcHop *lnrpc.Hop, pubkey route.Vertex) (*route.Hop,\n\terror) {\n\n\tcustomRecords := record.CustomSet(rpcHop.CustomRecords)\n\tif err := customRecords.Validate(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tmpp, err := UnmarshalMPP(rpcHop.MppRecord)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tamp, err := UnmarshalAMP(rpcHop.AmpRecord)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &route.Hop{\n\t\tOutgoingTimeLock: rpcHop.Expiry,\n\t\tAmtToForward:     lnwire.MilliSatoshi(rpcHop.AmtToForwardMsat),\n\t\tPubKeyBytes:      pubkey,\n\t\tChannelID:        rpcHop.ChanId,\n\t\tCustomRecords:    customRecords,\n\t\tLegacyPayload:    false,\n\t\tMPP:              mpp,\n\t\tAMP:              amp,\n\t}, nil\n}\n\n// UnmarshallHop unmarshalls an rpc hop that may or may not contain a node\n// pubkey.",
      "length": 668,
      "tokens": 80,
      "embedding": []
    },
    {
      "slug": "func (r *RouterBackend) UnmarshallHop(rpcHop *lnrpc.Hop,",
      "content": "func (r *RouterBackend) UnmarshallHop(rpcHop *lnrpc.Hop,\n\tprevNodePubKey [33]byte) (*route.Hop, error) {\n\n\tvar pubKeyBytes [33]byte\n\tif rpcHop.PubKey != \"\" {\n\t\t// Unmarshall the provided hop pubkey.\n\t\tpubKey, err := hex.DecodeString(rpcHop.PubKey)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"cannot decode pubkey %s\",\n\t\t\t\trpcHop.PubKey)\n\t\t}\n\t\tcopy(pubKeyBytes[:], pubKey)\n\t} else {\n\t\t// If no pub key is given of the hop, the local channel graph\n\t\t// needs to be queried to complete the information necessary for\n\t\t// routing. Discard edge policies, because they may be nil.\n\t\tnode1, node2, err := r.FetchChannelEndpoints(rpcHop.ChanId)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tswitch {\n\t\tcase prevNodePubKey == node1:\n\t\t\tpubKeyBytes = node2\n\t\tcase prevNodePubKey == node2:\n\t\t\tpubKeyBytes = node1\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"channel edge does not match \" +\n\t\t\t\t\"expected node\")\n\t\t}\n\t}\n\n\treturn UnmarshallHopWithPubkey(rpcHop, pubKeyBytes)\n}\n\n// UnmarshallRoute unmarshalls an rpc route. For hops that don't specify a\n// pubkey, the channel graph is queried.",
      "length": 979,
      "tokens": 143,
      "embedding": []
    },
    {
      "slug": "func (r *RouterBackend) UnmarshallRoute(rpcroute *lnrpc.Route) (",
      "content": "func (r *RouterBackend) UnmarshallRoute(rpcroute *lnrpc.Route) (\n\t*route.Route, error) {\n\n\tprevNodePubKey := r.SelfNode\n\n\thops := make([]*route.Hop, len(rpcroute.Hops))\n\tfor i, hop := range rpcroute.Hops {\n\t\trouteHop, err := r.UnmarshallHop(hop, prevNodePubKey)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\thops[i] = routeHop\n\n\t\tprevNodePubKey = routeHop.PubKeyBytes\n\t}\n\n\troute, err := route.NewRouteFromHops(\n\t\tlnwire.MilliSatoshi(rpcroute.TotalAmtMsat),\n\t\trpcroute.TotalTimeLock,\n\t\tr.SelfNode,\n\t\thops,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn route, nil\n}\n\n// extractIntentFromSendRequest attempts to parse the SendRequest details\n// required to dispatch a client from the information presented by an RPC\n// client.",
      "length": 629,
      "tokens": 83,
      "embedding": []
    },
    {
      "slug": "func (r *RouterBackend) extractIntentFromSendRequest(",
      "content": "func (r *RouterBackend) extractIntentFromSendRequest(\n\trpcPayReq *SendPaymentRequest) (*routing.LightningPayment, error) {\n\n\tpayIntent := &routing.LightningPayment{}\n\n\t// Pass along time preference.\n\tif rpcPayReq.TimePref < -1 || rpcPayReq.TimePref > 1 {\n\t\treturn nil, errors.New(\"time preference out of range\")\n\t}\n\tpayIntent.TimePref = rpcPayReq.TimePref\n\n\t// Pass along restrictions on the outgoing channels that may be used.\n\tpayIntent.OutgoingChannelIDs = rpcPayReq.OutgoingChanIds\n\n\t// Add the deprecated single outgoing channel restriction if present.\n\tif rpcPayReq.OutgoingChanId != 0 {\n\t\tif payIntent.OutgoingChannelIDs != nil {\n\t\t\treturn nil, errors.New(\"outgoing_chan_id and \" +\n\t\t\t\t\"outgoing_chan_ids are mutually exclusive\")\n\t\t}\n\n\t\tpayIntent.OutgoingChannelIDs = append(\n\t\t\tpayIntent.OutgoingChannelIDs, rpcPayReq.OutgoingChanId,\n\t\t)\n\t}\n\n\t// Pass along a last hop restriction if specified.\n\tif len(rpcPayReq.LastHopPubkey) > 0 {\n\t\tlastHop, err := route.NewVertexFromBytes(\n\t\t\trpcPayReq.LastHopPubkey,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpayIntent.LastHop = &lastHop\n\t}\n\n\t// Take the CLTV limit from the request if set, otherwise use the max.\n\tcltvLimit, err := ValidateCLTVLimit(\n\t\tuint32(rpcPayReq.CltvLimit), r.MaxTotalTimelock,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpayIntent.CltvLimit = cltvLimit\n\n\t// Attempt to parse the max parts value set by the user, if this value\n\t// isn't set, then we'll use the current default value for this\n\t// setting.\n\tmaxParts := rpcPayReq.MaxParts\n\tif maxParts == 0 {\n\t\tmaxParts = DefaultMaxParts\n\t}\n\tpayIntent.MaxParts = maxParts\n\n\t// If this payment had a max shard amount specified, then we'll apply\n\t// that now, which'll force us to always make payment splits smaller\n\t// than this.\n\tif rpcPayReq.MaxShardSizeMsat > 0 {\n\t\tshardAmtMsat := lnwire.MilliSatoshi(rpcPayReq.MaxShardSizeMsat)\n\t\tpayIntent.MaxShardAmt = &shardAmtMsat\n\t}\n\n\t// Take fee limit from request.\n\tpayIntent.FeeLimit, err = lnrpc.UnmarshallAmt(\n\t\trpcPayReq.FeeLimitSat, rpcPayReq.FeeLimitMsat,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Set payment attempt timeout.\n\tif rpcPayReq.TimeoutSeconds == 0 {\n\t\treturn nil, errors.New(\"timeout_seconds must be specified\")\n\t}\n\n\tcustomRecords := record.CustomSet(rpcPayReq.DestCustomRecords)\n\tif err := customRecords.Validate(); err != nil {\n\t\treturn nil, err\n\t}\n\tpayIntent.DestCustomRecords = customRecords\n\n\tpayIntent.PayAttemptTimeout = time.Second *\n\t\ttime.Duration(rpcPayReq.TimeoutSeconds)\n\n\t// Route hints.\n\trouteHints, err := unmarshallRouteHints(\n\t\trpcPayReq.RouteHints,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpayIntent.RouteHints = routeHints\n\n\t// Unmarshall either sat or msat amount from request.\n\treqAmt, err := lnrpc.UnmarshallAmt(\n\t\trpcPayReq.Amt, rpcPayReq.AmtMsat,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// If the payment request field isn't blank, then the details of the\n\t// invoice are encoded entirely within the encoded payReq.  So we'll\n\t// attempt to decode it, populating the payment accordingly.\n\tif rpcPayReq.PaymentRequest != \"\" {\n\t\tswitch {\n\n\t\tcase len(rpcPayReq.Dest) > 0:\n\t\t\treturn nil, errors.New(\"dest and payment_request \" +\n\t\t\t\t\"cannot appear together\")\n\n\t\tcase len(rpcPayReq.PaymentHash) > 0:\n\t\t\treturn nil, errors.New(\"payment_hash and payment_request \" +\n\t\t\t\t\"cannot appear together\")\n\n\t\tcase rpcPayReq.FinalCltvDelta != 0:\n\t\t\treturn nil, errors.New(\"final_cltv_delta and payment_request \" +\n\t\t\t\t\"cannot appear together\")\n\t\t}\n\n\t\tpayReq, err := zpay32.Decode(\n\t\t\trpcPayReq.PaymentRequest, r.ActiveNetParams,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Next, we'll ensure that this payreq hasn't already expired.\n\t\terr = ValidatePayReqExpiry(payReq)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// If the amount was not included in the invoice, then we let\n\t\t// the payer specify the amount of satoshis they wish to send.\n\t\t// We override the amount to pay with the amount provided from\n\t\t// the payment request.\n\t\tif payReq.MilliSat == nil {\n\t\t\tif reqAmt == 0 {\n\t\t\t\treturn nil, errors.New(\"amount must be \" +\n\t\t\t\t\t\"specified when paying a zero amount \" +\n\t\t\t\t\t\"invoice\")\n\t\t\t}\n\n\t\t\tpayIntent.Amount = reqAmt\n\t\t} else {\n\t\t\tif reqAmt != 0 {\n\t\t\t\treturn nil, errors.New(\"amount must not be \" +\n\t\t\t\t\t\"specified when paying a non-zero \" +\n\t\t\t\t\t\" amount invoice\")\n\t\t\t}\n\n\t\t\tpayIntent.Amount = *payReq.MilliSat\n\t\t}\n\n\t\tif !payReq.Features.HasFeature(lnwire.MPPOptional) &&\n\t\t\t!payReq.Features.HasFeature(lnwire.AMPOptional) {\n\n\t\t\tpayIntent.MaxParts = 1\n\t\t}\n\n\t\tpayAddr := payReq.PaymentAddr\n\t\tif payReq.Features.HasFeature(lnwire.AMPOptional) {\n\t\t\t// Generate random SetID and root share.\n\t\t\tvar setID [32]byte\n\t\t\t_, err = rand.Read(setID[:])\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tvar rootShare [32]byte\n\t\t\t_, err = rand.Read(rootShare[:])\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\terr := payIntent.SetAMP(&routing.AMPOptions{\n\t\t\t\tSetID:     setID,\n\t\t\t\tRootShare: rootShare,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\t// For AMP invoices, we'll allow users to override the\n\t\t\t// included payment addr to allow the invoice to be\n\t\t\t// pseudo-reusable, e.g. the invoice parameters are\n\t\t\t// reused (amt, cltv, hop hints, etc) even though the\n\t\t\t// payments will share different payment hashes.\n\t\t\tif len(rpcPayReq.PaymentAddr) > 0 {\n\t\t\t\tvar addr [32]byte\n\t\t\t\tcopy(addr[:], rpcPayReq.PaymentAddr)\n\t\t\t\tpayAddr = &addr\n\t\t\t}\n\t\t} else {\n\t\t\terr = payIntent.SetPaymentHash(*payReq.PaymentHash)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\tdestKey := payReq.Destination.SerializeCompressed()\n\t\tcopy(payIntent.Target[:], destKey)\n\n\t\tpayIntent.FinalCLTVDelta = uint16(payReq.MinFinalCLTVExpiry())\n\t\tpayIntent.RouteHints = append(\n\t\t\tpayIntent.RouteHints, payReq.RouteHints...,\n\t\t)\n\t\tpayIntent.DestFeatures = payReq.Features\n\t\tpayIntent.PaymentAddr = payAddr\n\t\tpayIntent.PaymentRequest = []byte(rpcPayReq.PaymentRequest)\n\t\tpayIntent.Metadata = payReq.Metadata\n\t} else {\n\t\t// Otherwise, If the payment request field was not specified\n\t\t// (and a custom route wasn't specified), construct the payment\n\t\t// from the other fields.\n\n\t\t// Payment destination.\n\t\ttarget, err := route.NewVertexFromBytes(rpcPayReq.Dest)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpayIntent.Target = target\n\n\t\t// Final payment CLTV delta.\n\t\tif rpcPayReq.FinalCltvDelta != 0 {\n\t\t\tpayIntent.FinalCLTVDelta =\n\t\t\t\tuint16(rpcPayReq.FinalCltvDelta)\n\t\t} else {\n\t\t\tpayIntent.FinalCLTVDelta = r.DefaultFinalCltvDelta\n\t\t}\n\n\t\t// Amount.\n\t\tif reqAmt == 0 {\n\t\t\treturn nil, errors.New(\"amount must be specified\")\n\t\t}\n\n\t\tpayIntent.Amount = reqAmt\n\n\t\t// Parse destination feature bits.\n\t\tfeatures, err := UnmarshalFeatures(rpcPayReq.DestFeatures)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Validate the features if any was specified.\n\t\tif features != nil {\n\t\t\terr = feature.ValidateDeps(features)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\t// If this is an AMP payment, we must generate the initial\n\t\t// randomness.\n\t\tif rpcPayReq.Amp {\n\t\t\t// If no destination features were specified, we set\n\t\t\t// those necessary for AMP payments.\n\t\t\tif features == nil {\n\t\t\t\tampFeatures := []lnrpc.FeatureBit{\n\t\t\t\t\tlnrpc.FeatureBit_TLV_ONION_OPT,\n\t\t\t\t\tlnrpc.FeatureBit_PAYMENT_ADDR_OPT,\n\t\t\t\t\tlnrpc.FeatureBit_AMP_OPT,\n\t\t\t\t}\n\n\t\t\t\tfeatures, err = UnmarshalFeatures(ampFeatures)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// First make sure the destination supports AMP.\n\t\t\tif !features.HasFeature(lnwire.AMPOptional) {\n\t\t\t\treturn nil, fmt.Errorf(\"destination doesn't \" +\n\t\t\t\t\t\"support AMP payments\")\n\t\t\t}\n\n\t\t\t// If no payment address is set, generate a random one.\n\t\t\tvar payAddr [32]byte\n\t\t\tif len(rpcPayReq.PaymentAddr) == 0 {\n\t\t\t\t_, err = rand.Read(payAddr[:])\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcopy(payAddr[:], rpcPayReq.PaymentAddr)\n\t\t\t}\n\t\t\tpayIntent.PaymentAddr = &payAddr\n\n\t\t\t// Generate random SetID and root share.\n\t\t\tvar setID [32]byte\n\t\t\t_, err = rand.Read(setID[:])\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tvar rootShare [32]byte\n\t\t\t_, err = rand.Read(rootShare[:])\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\terr := payIntent.SetAMP(&routing.AMPOptions{\n\t\t\t\tSetID:     setID,\n\t\t\t\tRootShare: rootShare,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\t// Payment hash.\n\t\t\tpaymentHash, err := lntypes.MakeHash(rpcPayReq.PaymentHash)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\terr = payIntent.SetPaymentHash(paymentHash)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\t// If the payment addresses is specified, then we'll\n\t\t\t// also populate that now as well.\n\t\t\tif len(rpcPayReq.PaymentAddr) != 0 {\n\t\t\t\tvar payAddr [32]byte\n\t\t\t\tcopy(payAddr[:], rpcPayReq.PaymentAddr)\n\n\t\t\t\tpayIntent.PaymentAddr = &payAddr\n\t\t\t}\n\t\t}\n\n\t\tpayIntent.DestFeatures = features\n\t}\n\n\t// Do bounds checking with the block padding so the router isn't\n\t// left with a zombie payment in case the user messes up.\n\terr = routing.ValidateCLTVLimit(\n\t\tpayIntent.CltvLimit, payIntent.FinalCLTVDelta, true,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check for disallowed payments to self.\n\tif !rpcPayReq.AllowSelfPayment && payIntent.Target == r.SelfNode {\n\t\treturn nil, errors.New(\"self-payments not allowed\")\n\t}\n\n\treturn payIntent, nil\n}\n\n// unmarshallRouteHints unmarshalls a list of route hints.",
      "length": 8832,
      "tokens": 1180,
      "embedding": []
    },
    {
      "slug": "func unmarshallRouteHints(rpcRouteHints []*lnrpc.RouteHint) (",
      "content": "func unmarshallRouteHints(rpcRouteHints []*lnrpc.RouteHint) (\n\t[][]zpay32.HopHint, error) {\n\n\trouteHints := make([][]zpay32.HopHint, 0, len(rpcRouteHints))\n\tfor _, rpcRouteHint := range rpcRouteHints {\n\t\trouteHint := make(\n\t\t\t[]zpay32.HopHint, 0, len(rpcRouteHint.HopHints),\n\t\t)\n\t\tfor _, rpcHint := range rpcRouteHint.HopHints {\n\t\t\thint, err := unmarshallHopHint(rpcHint)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\trouteHint = append(routeHint, hint)\n\t\t}\n\t\trouteHints = append(routeHints, routeHint)\n\t}\n\n\treturn routeHints, nil\n}\n\n// unmarshallHopHint unmarshalls a single hop hint.",
      "length": 504,
      "tokens": 63,
      "embedding": []
    },
    {
      "slug": "func unmarshallHopHint(rpcHint *lnrpc.HopHint) (zpay32.HopHint, error) {",
      "content": "func unmarshallHopHint(rpcHint *lnrpc.HopHint) (zpay32.HopHint, error) {\n\tpubBytes, err := hex.DecodeString(rpcHint.NodeId)\n\tif err != nil {\n\t\treturn zpay32.HopHint{}, err\n\t}\n\n\tpubkey, err := btcec.ParsePubKey(pubBytes)\n\tif err != nil {\n\t\treturn zpay32.HopHint{}, err\n\t}\n\n\treturn zpay32.HopHint{\n\t\tNodeID:                    pubkey,\n\t\tChannelID:                 rpcHint.ChanId,\n\t\tFeeBaseMSat:               rpcHint.FeeBaseMsat,\n\t\tFeeProportionalMillionths: rpcHint.FeeProportionalMillionths,\n\t\tCLTVExpiryDelta:           uint16(rpcHint.CltvExpiryDelta),\n\t}, nil\n}\n\n// UnmarshalFeatures converts a list of uint32's into a valid feature vector.\n// This method checks that feature bit pairs aren't assigned toegether, and\n// validates transitive dependencies.",
      "length": 662,
      "tokens": 69,
      "embedding": []
    },
    {
      "slug": "func UnmarshalFeatures(",
      "content": "func UnmarshalFeatures(\n\trpcFeatures []lnrpc.FeatureBit) (*lnwire.FeatureVector, error) {\n\n\t// If no destination features are specified we'll return nil to signal\n\t// that the router should try to use the graph as a fallback.\n\tif rpcFeatures == nil {\n\t\treturn nil, nil\n\t}\n\n\traw := lnwire.NewRawFeatureVector()\n\tfor _, bit := range rpcFeatures {\n\t\terr := raw.SafeSet(lnwire.FeatureBit(bit))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn lnwire.NewFeatureVector(raw, lnwire.Features), nil\n}\n\n// ValidatePayReqExpiry checks if the passed payment request has expired. In\n// the case it has expired, an error will be returned.",
      "length": 584,
      "tokens": 89,
      "embedding": []
    },
    {
      "slug": "func ValidatePayReqExpiry(payReq *zpay32.Invoice) error {",
      "content": "func ValidatePayReqExpiry(payReq *zpay32.Invoice) error {\n\texpiry := payReq.Expiry()\n\tvalidUntil := payReq.Timestamp.Add(expiry)\n\tif time.Now().After(validUntil) {\n\t\treturn fmt.Errorf(\"invoice expired. Valid until %v\", validUntil)\n\t}\n\n\treturn nil\n}\n\n// ValidateCLTVLimit returns a valid CLTV limit given a value and a maximum. If\n// the value exceeds the maximum, then an error is returned. If the value is 0,\n// then the maximum is used.",
      "length": 369,
      "tokens": 56,
      "embedding": []
    },
    {
      "slug": "func ValidateCLTVLimit(val, max uint32) (uint32, error) {",
      "content": "func ValidateCLTVLimit(val, max uint32) (uint32, error) {\n\tswitch {\n\tcase val == 0:\n\t\treturn max, nil\n\tcase val > max:\n\t\treturn 0, fmt.Errorf(\"total time lock of %v exceeds max \"+\n\t\t\t\"allowed %v\", val, max)\n\tdefault:\n\t\treturn val, nil\n\t}\n}\n\n// UnmarshalMPP accepts the mpp_total_amt_msat and mpp_payment_addr fields from\n// an RPC request and converts into an record.MPP object. An error is returned\n// if the payment address is not 0 or 32 bytes. If the total amount and payment\n// address are zero-value, the return value will be nil signaling there is no\n// MPP record to attach to this hop. Otherwise, a non-nil reocrd will be\n// contained combining the provided values.",
      "length": 600,
      "tokens": 107,
      "embedding": []
    },
    {
      "slug": "func UnmarshalMPP(reqMPP *lnrpc.MPPRecord) (*record.MPP, error) {",
      "content": "func UnmarshalMPP(reqMPP *lnrpc.MPPRecord) (*record.MPP, error) {\n\t// If no MPP record was submitted, assume the user wants to send a\n\t// regular payment.\n\tif reqMPP == nil {\n\t\treturn nil, nil\n\t}\n\n\treqTotal := reqMPP.TotalAmtMsat\n\treqAddr := reqMPP.PaymentAddr\n\n\tswitch {\n\t// No MPP fields were provided.\n\tcase reqTotal == 0 && len(reqAddr) == 0:\n\t\treturn nil, fmt.Errorf(\"missing total_msat and payment_addr\")\n\n\t// Total is present, but payment address is missing.\n\tcase reqTotal > 0 && len(reqAddr) == 0:\n\t\treturn nil, fmt.Errorf(\"missing payment_addr\")\n\n\t// Payment address is present, but total is missing.\n\tcase reqTotal == 0 && len(reqAddr) > 0:\n\t\treturn nil, fmt.Errorf(\"missing total_msat\")\n\t}\n\n\taddr, err := lntypes.MakeHash(reqAddr)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to parse \"+\n\t\t\t\"payment_addr: %v\", err)\n\t}\n\n\ttotal := lnwire.MilliSatoshi(reqTotal)\n\n\treturn record.NewMPP(total, addr), nil\n}\n",
      "length": 821,
      "tokens": 124,
      "embedding": []
    },
    {
      "slug": "func UnmarshalAMP(reqAMP *lnrpc.AMPRecord) (*record.AMP, error) {",
      "content": "func UnmarshalAMP(reqAMP *lnrpc.AMPRecord) (*record.AMP, error) {\n\tif reqAMP == nil {\n\t\treturn nil, nil\n\t}\n\n\treqRootShare := reqAMP.RootShare\n\treqSetID := reqAMP.SetId\n\n\tswitch {\n\tcase len(reqRootShare) != 32:\n\t\treturn nil, errors.New(\"AMP root_share must be 32 bytes\")\n\n\tcase len(reqSetID) != 32:\n\t\treturn nil, errors.New(\"AMP set_id must be 32 bytes\")\n\t}\n\n\tvar (\n\t\trootShare [32]byte\n\t\tsetID     [32]byte\n\t)\n\tcopy(rootShare[:], reqRootShare)\n\tcopy(setID[:], reqSetID)\n\n\treturn record.NewAMP(rootShare, setID, reqAMP.ChildIndex), nil\n}\n\n// MarshalHTLCAttempt constructs an RPC HTLCAttempt from the db representation.",
      "length": 526,
      "tokens": 69,
      "embedding": []
    },
    {
      "slug": "func (r *RouterBackend) MarshalHTLCAttempt(",
      "content": "func (r *RouterBackend) MarshalHTLCAttempt(\n\thtlc channeldb.HTLCAttempt) (*lnrpc.HTLCAttempt, error) {\n\n\troute, err := r.MarshallRoute(&htlc.Route)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trpcAttempt := &lnrpc.HTLCAttempt{\n\t\tAttemptId:     htlc.AttemptID,\n\t\tAttemptTimeNs: MarshalTimeNano(htlc.AttemptTime),\n\t\tRoute:         route,\n\t}\n\n\tswitch {\n\tcase htlc.Settle != nil:\n\t\trpcAttempt.Status = lnrpc.HTLCAttempt_SUCCEEDED\n\t\trpcAttempt.ResolveTimeNs = MarshalTimeNano(\n\t\t\thtlc.Settle.SettleTime,\n\t\t)\n\t\trpcAttempt.Preimage = htlc.Settle.Preimage[:]\n\n\tcase htlc.Failure != nil:\n\t\trpcAttempt.Status = lnrpc.HTLCAttempt_FAILED\n\t\trpcAttempt.ResolveTimeNs = MarshalTimeNano(\n\t\t\thtlc.Failure.FailTime,\n\t\t)\n\n\t\tvar err error\n\t\trpcAttempt.Failure, err = marshallHtlcFailure(htlc.Failure)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\tdefault:\n\t\trpcAttempt.Status = lnrpc.HTLCAttempt_IN_FLIGHT\n\t}\n\n\treturn rpcAttempt, nil\n}\n\n// marshallHtlcFailure marshalls htlc fail info from the database to its rpc\n// representation.",
      "length": 919,
      "tokens": 96,
      "embedding": []
    },
    {
      "slug": "func marshallHtlcFailure(failure *channeldb.HTLCFailInfo) (*lnrpc.Failure,",
      "content": "func marshallHtlcFailure(failure *channeldb.HTLCFailInfo) (*lnrpc.Failure,\n\terror) {\n\n\trpcFailure := &lnrpc.Failure{\n\t\tFailureSourceIndex: failure.FailureSourceIndex,\n\t}\n\n\tswitch failure.Reason {\n\tcase channeldb.HTLCFailUnknown:\n\t\trpcFailure.Code = lnrpc.Failure_UNKNOWN_FAILURE\n\n\tcase channeldb.HTLCFailUnreadable:\n\t\trpcFailure.Code = lnrpc.Failure_UNREADABLE_FAILURE\n\n\tcase channeldb.HTLCFailInternal:\n\t\trpcFailure.Code = lnrpc.Failure_INTERNAL_FAILURE\n\n\tcase channeldb.HTLCFailMessage:\n\t\terr := marshallWireError(failure.Message, rpcFailure)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\tdefault:\n\t\treturn nil, errors.New(\"unknown htlc failure reason\")\n\t}\n\n\treturn rpcFailure, nil\n}\n\n// MarshalTimeNano converts a time.Time into its nanosecond representation. If\n// the time is zero, this method simply returns 0, since calling UnixNano() on a\n// zero-valued time is undefined.",
      "length": 771,
      "tokens": 83,
      "embedding": []
    },
    {
      "slug": "func MarshalTimeNano(t time.Time) int64 {",
      "content": "func MarshalTimeNano(t time.Time) int64 {\n\tif t.IsZero() {\n\t\treturn 0\n\t}\n\treturn t.UnixNano()\n}\n\n// marshallError marshall an error as received from the switch to rpc structs\n// suitable for returning to the caller of an rpc method.\n//\n// Because of difficulties with using protobuf oneof constructs in some\n// languages, the decision was made here to use a single message format for all\n// failure messages with some fields left empty depending on the failure type.",
      "length": 413,
      "tokens": 73,
      "embedding": []
    },
    {
      "slug": "func marshallError(sendError error) (*lnrpc.Failure, error) {",
      "content": "func marshallError(sendError error) (*lnrpc.Failure, error) {\n\tresponse := &lnrpc.Failure{}\n\n\tif sendError == htlcswitch.ErrUnreadableFailureMessage {\n\t\tresponse.Code = lnrpc.Failure_UNREADABLE_FAILURE\n\t\treturn response, nil\n\t}\n\n\trtErr, ok := sendError.(htlcswitch.ClearTextError)\n\tif !ok {\n\t\treturn nil, sendError\n\t}\n\n\terr := marshallWireError(rtErr.WireMessage(), response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// If the ClearTextError received is a ForwardingError, the error\n\t// originated from a node along the route, not locally on our outgoing\n\t// link. We set failureSourceIdx to the index of the node where the\n\t// failure occurred. If the error is not a ForwardingError, the failure\n\t// occurred at our node, so we leave the index as 0 to indicate that\n\t// we failed locally.\n\tfErr, ok := rtErr.(*htlcswitch.ForwardingError)\n\tif ok {\n\t\tresponse.FailureSourceIndex = uint32(fErr.FailureSourceIdx)\n\t}\n\n\treturn response, nil\n}\n\n// marshallError marshall an error as received from the switch to rpc structs\n// suitable for returning to the caller of an rpc method.\n//\n// Because of difficulties with using protobuf oneof constructs in some\n// languages, the decision was made here to use a single message format for all\n// failure messages with some fields left empty depending on the failure type.",
      "length": 1209,
      "tokens": 185,
      "embedding": []
    },
    {
      "slug": "func marshallWireError(msg lnwire.FailureMessage,",
      "content": "func marshallWireError(msg lnwire.FailureMessage,\n\tresponse *lnrpc.Failure) error {\n\n\tswitch onionErr := msg.(type) {\n\tcase *lnwire.FailIncorrectDetails:\n\t\tresponse.Code = lnrpc.Failure_INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS\n\t\tresponse.Height = onionErr.Height()\n\n\tcase *lnwire.FailIncorrectPaymentAmount:\n\t\tresponse.Code = lnrpc.Failure_INCORRECT_PAYMENT_AMOUNT\n\n\tcase *lnwire.FailFinalIncorrectCltvExpiry:\n\t\tresponse.Code = lnrpc.Failure_FINAL_INCORRECT_CLTV_EXPIRY\n\t\tresponse.CltvExpiry = onionErr.CltvExpiry\n\n\tcase *lnwire.FailFinalIncorrectHtlcAmount:\n\t\tresponse.Code = lnrpc.Failure_FINAL_INCORRECT_HTLC_AMOUNT\n\t\tresponse.HtlcMsat = uint64(onionErr.IncomingHTLCAmount)\n\n\tcase *lnwire.FailFinalExpiryTooSoon:\n\t\tresponse.Code = lnrpc.Failure_FINAL_EXPIRY_TOO_SOON\n\n\tcase *lnwire.FailInvalidRealm:\n\t\tresponse.Code = lnrpc.Failure_INVALID_REALM\n\n\tcase *lnwire.FailExpiryTooSoon:\n\t\tresponse.Code = lnrpc.Failure_EXPIRY_TOO_SOON\n\t\tresponse.ChannelUpdate = marshallChannelUpdate(&onionErr.Update)\n\n\tcase *lnwire.FailExpiryTooFar:\n\t\tresponse.Code = lnrpc.Failure_EXPIRY_TOO_FAR\n\n\tcase *lnwire.FailInvalidOnionVersion:\n\t\tresponse.Code = lnrpc.Failure_INVALID_ONION_VERSION\n\t\tresponse.OnionSha_256 = onionErr.OnionSHA256[:]\n\n\tcase *lnwire.FailInvalidOnionHmac:\n\t\tresponse.Code = lnrpc.Failure_INVALID_ONION_HMAC\n\t\tresponse.OnionSha_256 = onionErr.OnionSHA256[:]\n\n\tcase *lnwire.FailInvalidOnionKey:\n\t\tresponse.Code = lnrpc.Failure_INVALID_ONION_KEY\n\t\tresponse.OnionSha_256 = onionErr.OnionSHA256[:]\n\n\tcase *lnwire.FailAmountBelowMinimum:\n\t\tresponse.Code = lnrpc.Failure_AMOUNT_BELOW_MINIMUM\n\t\tresponse.ChannelUpdate = marshallChannelUpdate(&onionErr.Update)\n\t\tresponse.HtlcMsat = uint64(onionErr.HtlcMsat)\n\n\tcase *lnwire.FailFeeInsufficient:\n\t\tresponse.Code = lnrpc.Failure_FEE_INSUFFICIENT\n\t\tresponse.ChannelUpdate = marshallChannelUpdate(&onionErr.Update)\n\t\tresponse.HtlcMsat = uint64(onionErr.HtlcMsat)\n\n\tcase *lnwire.FailIncorrectCltvExpiry:\n\t\tresponse.Code = lnrpc.Failure_INCORRECT_CLTV_EXPIRY\n\t\tresponse.ChannelUpdate = marshallChannelUpdate(&onionErr.Update)\n\t\tresponse.CltvExpiry = onionErr.CltvExpiry\n\n\tcase *lnwire.FailChannelDisabled:\n\t\tresponse.Code = lnrpc.Failure_CHANNEL_DISABLED\n\t\tresponse.ChannelUpdate = marshallChannelUpdate(&onionErr.Update)\n\t\tresponse.Flags = uint32(onionErr.Flags)\n\n\tcase *lnwire.FailTemporaryChannelFailure:\n\t\tresponse.Code = lnrpc.Failure_TEMPORARY_CHANNEL_FAILURE\n\t\tresponse.ChannelUpdate = marshallChannelUpdate(onionErr.Update)\n\n\tcase *lnwire.FailRequiredNodeFeatureMissing:\n\t\tresponse.Code = lnrpc.Failure_REQUIRED_NODE_FEATURE_MISSING\n\n\tcase *lnwire.FailRequiredChannelFeatureMissing:\n\t\tresponse.Code = lnrpc.Failure_REQUIRED_CHANNEL_FEATURE_MISSING\n\n\tcase *lnwire.FailUnknownNextPeer:\n\t\tresponse.Code = lnrpc.Failure_UNKNOWN_NEXT_PEER\n\n\tcase *lnwire.FailTemporaryNodeFailure:\n\t\tresponse.Code = lnrpc.Failure_TEMPORARY_NODE_FAILURE\n\n\tcase *lnwire.FailPermanentNodeFailure:\n\t\tresponse.Code = lnrpc.Failure_PERMANENT_NODE_FAILURE\n\n\tcase *lnwire.FailPermanentChannelFailure:\n\t\tresponse.Code = lnrpc.Failure_PERMANENT_CHANNEL_FAILURE\n\n\tcase *lnwire.FailMPPTimeout:\n\t\tresponse.Code = lnrpc.Failure_MPP_TIMEOUT\n\n\tcase *lnwire.InvalidOnionPayload:\n\t\tresponse.Code = lnrpc.Failure_INVALID_ONION_PAYLOAD\n\n\tcase nil:\n\t\tresponse.Code = lnrpc.Failure_UNKNOWN_FAILURE\n\n\tdefault:\n\t\treturn fmt.Errorf(\"cannot marshall failure %T\", onionErr)\n\t}\n\n\treturn nil\n}\n\n// marshallChannelUpdate marshalls a channel update as received over the wire to\n// the router rpc format.",
      "length": 3339,
      "tokens": 210,
      "embedding": []
    },
    {
      "slug": "func marshallChannelUpdate(update *lnwire.ChannelUpdate) *lnrpc.ChannelUpdate {",
      "content": "func marshallChannelUpdate(update *lnwire.ChannelUpdate) *lnrpc.ChannelUpdate {\n\tif update == nil {\n\t\treturn nil\n\t}\n\n\treturn &lnrpc.ChannelUpdate{\n\t\tSignature:       update.Signature[:],\n\t\tChainHash:       update.ChainHash[:],\n\t\tChanId:          update.ShortChannelID.ToUint64(),\n\t\tTimestamp:       update.Timestamp,\n\t\tMessageFlags:    uint32(update.MessageFlags),\n\t\tChannelFlags:    uint32(update.ChannelFlags),\n\t\tTimeLockDelta:   uint32(update.TimeLockDelta),\n\t\tHtlcMinimumMsat: uint64(update.HtlcMinimumMsat),\n\t\tBaseFee:         update.BaseFee,\n\t\tFeeRate:         update.FeeRate,\n\t\tHtlcMaximumMsat: uint64(update.HtlcMaximumMsat),\n\t\tExtraOpaqueData: update.ExtraOpaqueData,\n\t}\n}\n\n// MarshallPayment marshall a payment to its rpc representation.",
      "length": 647,
      "tokens": 45,
      "embedding": []
    },
    {
      "slug": "func (r *RouterBackend) MarshallPayment(payment *channeldb.MPPayment) (",
      "content": "func (r *RouterBackend) MarshallPayment(payment *channeldb.MPPayment) (\n\t*lnrpc.Payment, error) {\n\n\t// Fetch the payment's preimage and the total paid in fees.\n\tvar (\n\t\tfee      lnwire.MilliSatoshi\n\t\tpreimage lntypes.Preimage\n\t)\n\tfor _, htlc := range payment.HTLCs {\n\t\t// If any of the htlcs have settled, extract a valid\n\t\t// preimage.\n\t\tif htlc.Settle != nil {\n\t\t\tpreimage = htlc.Settle.Preimage\n\t\t\tfee += htlc.Route.TotalFees()\n\t\t}\n\t}\n\n\tmsatValue := int64(payment.Info.Value)\n\tsatValue := int64(payment.Info.Value.ToSatoshis())\n\n\tstatus, err := convertPaymentStatus(payment.Status)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\thtlcs := make([]*lnrpc.HTLCAttempt, 0, len(payment.HTLCs))\n\tfor _, dbHTLC := range payment.HTLCs {\n\t\thtlc, err := r.MarshalHTLCAttempt(dbHTLC)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\thtlcs = append(htlcs, htlc)\n\t}\n\n\tpaymentID := payment.Info.PaymentIdentifier\n\tcreationTimeNS := MarshalTimeNano(payment.Info.CreationTime)\n\n\tfailureReason, err := marshallPaymentFailureReason(\n\t\tpayment.FailureReason,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &lnrpc.Payment{\n\t\t// TODO: set this to setID for AMP-payments?\n\t\tPaymentHash:     hex.EncodeToString(paymentID[:]),\n\t\tValue:           satValue,\n\t\tValueMsat:       msatValue,\n\t\tValueSat:        satValue,\n\t\tCreationDate:    payment.Info.CreationTime.Unix(),\n\t\tCreationTimeNs:  creationTimeNS,\n\t\tFee:             int64(fee.ToSatoshis()),\n\t\tFeeSat:          int64(fee.ToSatoshis()),\n\t\tFeeMsat:         int64(fee),\n\t\tPaymentPreimage: hex.EncodeToString(preimage[:]),\n\t\tPaymentRequest:  string(payment.Info.PaymentRequest),\n\t\tStatus:          status,\n\t\tHtlcs:           htlcs,\n\t\tPaymentIndex:    payment.SequenceNum,\n\t\tFailureReason:   failureReason,\n\t}, nil\n}\n\n// convertPaymentStatus converts a channeldb.PaymentStatus to the type expected\n// by the RPC.",
      "length": 1694,
      "tokens": 180,
      "embedding": []
    },
    {
      "slug": "func convertPaymentStatus(dbStatus channeldb.PaymentStatus) (",
      "content": "func convertPaymentStatus(dbStatus channeldb.PaymentStatus) (\n\tlnrpc.Payment_PaymentStatus, error) {\n\n\tswitch dbStatus {\n\tcase channeldb.StatusUnknown:\n\t\treturn lnrpc.Payment_UNKNOWN, nil\n\n\tcase channeldb.StatusInFlight:\n\t\treturn lnrpc.Payment_IN_FLIGHT, nil\n\n\tcase channeldb.StatusSucceeded:\n\t\treturn lnrpc.Payment_SUCCEEDED, nil\n\n\tcase channeldb.StatusFailed:\n\t\treturn lnrpc.Payment_FAILED, nil\n\n\tdefault:\n\t\treturn 0, fmt.Errorf(\"unhandled payment status %v\", dbStatus)\n\t}\n}\n\n// marshallPaymentFailureReason marshalls the failure reason to the corresponding rpc\n// type.",
      "length": 489,
      "tokens": 48,
      "embedding": []
    },
    {
      "slug": "func marshallPaymentFailureReason(reason *channeldb.FailureReason) (",
      "content": "func marshallPaymentFailureReason(reason *channeldb.FailureReason) (\n\tlnrpc.PaymentFailureReason, error) {\n\n\tif reason == nil {\n\t\treturn lnrpc.PaymentFailureReason_FAILURE_REASON_NONE, nil\n\t}\n\n\tswitch *reason {\n\tcase channeldb.FailureReasonTimeout:\n\t\treturn lnrpc.PaymentFailureReason_FAILURE_REASON_TIMEOUT, nil\n\n\tcase channeldb.FailureReasonNoRoute:\n\t\treturn lnrpc.PaymentFailureReason_FAILURE_REASON_NO_ROUTE, nil\n\n\tcase channeldb.FailureReasonError:\n\t\treturn lnrpc.PaymentFailureReason_FAILURE_REASON_ERROR, nil\n\n\tcase channeldb.FailureReasonPaymentDetails:\n\t\treturn lnrpc.PaymentFailureReason_FAILURE_REASON_INCORRECT_PAYMENT_DETAILS, nil\n\n\tcase channeldb.FailureReasonInsufficientBalance:\n\t\treturn lnrpc.PaymentFailureReason_FAILURE_REASON_INSUFFICIENT_BALANCE, nil\n\t}\n\n\treturn 0, errors.New(\"unknown failure reason\")\n}\n",
      "length": 732,
      "tokens": 47,
      "embedding": []
    }
  ]
}