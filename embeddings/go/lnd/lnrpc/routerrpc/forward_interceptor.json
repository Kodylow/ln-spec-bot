{
  "filepath": "../implementations/go/lnd/lnrpc/routerrpc/forward_interceptor.go",
  "package": "routerrpc",
  "sections": [
    {
      "slug": "type forwardInterceptor struct {",
      "content": "type forwardInterceptor struct {\n\t// stream is the bidirectional RPC stream\n\tstream Router_HtlcInterceptorServer\n\n\thtlcSwitch htlcswitch.InterceptableHtlcForwarder\n}\n\n// newForwardInterceptor creates a new forwardInterceptor.",
      "length": 186,
      "tokens": 18,
      "embedding": []
    },
    {
      "slug": "func newForwardInterceptor(htlcSwitch htlcswitch.InterceptableHtlcForwarder,",
      "content": "func newForwardInterceptor(htlcSwitch htlcswitch.InterceptableHtlcForwarder,\n\tstream Router_HtlcInterceptorServer) *forwardInterceptor {\n\n\treturn &forwardInterceptor{\n\t\thtlcSwitch: htlcSwitch,\n\t\tstream:     stream,\n\t}\n}\n\n// run sends the intercepted packets to the client and receives the\n// corersponding responses. On one hand it registered itself as an interceptor\n// that receives the switch packets and on the other hand launches a go routine\n// to read from the client stream.\n// To coordinate all this and make sure it is safe for concurrent access all\n// packets are sent to the main where they are handled.",
      "length": 525,
      "tokens": 84,
      "embedding": []
    },
    {
      "slug": "func (r *forwardInterceptor) run() error {",
      "content": "func (r *forwardInterceptor) run() error {\n\t// Register our interceptor so we receive all forwarded packets.\n\tr.htlcSwitch.SetInterceptor(r.onIntercept)\n\tdefer r.htlcSwitch.SetInterceptor(nil)\n\n\tfor {\n\t\tresp, err := r.stream.Recv()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := r.resolveFromClient(resp); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\n// onIntercept is the function that is called by the switch for every forwarded\n// packet. Our interceptor makes sure we hold the packet and then signal to the\n// main loop to handle the packet. We only return true if we were able\n// to deliver the packet to the main loop.",
      "length": 556,
      "tokens": 93,
      "embedding": []
    },
    {
      "slug": "func (r *forwardInterceptor) onIntercept(",
      "content": "func (r *forwardInterceptor) onIntercept(\n\thtlc htlcswitch.InterceptedPacket) error {\n\n\tlog.Tracef(\"Sending intercepted packet to client %v\", htlc)\n\n\tinKey := htlc.IncomingCircuit\n\n\t// First hold the forward, then send to client.\n\tinterceptionRequest := &ForwardHtlcInterceptRequest{\n\t\tIncomingCircuitKey: &CircuitKey{\n\t\t\tChanId: inKey.ChanID.ToUint64(),\n\t\t\tHtlcId: inKey.HtlcID,\n\t\t},\n\t\tOutgoingRequestedChanId: htlc.OutgoingChanID.ToUint64(),\n\t\tPaymentHash:             htlc.Hash[:],\n\t\tOutgoingAmountMsat:      uint64(htlc.OutgoingAmount),\n\t\tOutgoingExpiry:          htlc.OutgoingExpiry,\n\t\tIncomingAmountMsat:      uint64(htlc.IncomingAmount),\n\t\tIncomingExpiry:          htlc.IncomingExpiry,\n\t\tCustomRecords:           htlc.CustomRecords,\n\t\tOnionBlob:               htlc.OnionBlob[:],\n\t\tAutoFailHeight:          htlc.AutoFailHeight,\n\t}\n\n\treturn r.stream.Send(interceptionRequest)\n}\n\n// resolveFromClient handles a resolution arrived from the client.",
      "length": 882,
      "tokens": 64,
      "embedding": []
    },
    {
      "slug": "func (r *forwardInterceptor) resolveFromClient(",
      "content": "func (r *forwardInterceptor) resolveFromClient(\n\tin *ForwardHtlcInterceptResponse) error {\n\n\tif in.IncomingCircuitKey == nil {\n\t\treturn status.Errorf(codes.InvalidArgument,\n\t\t\t\"CircuitKey missing from ForwardHtlcInterceptResponse\")\n\t}\n\n\tlog.Tracef(\"Resolving intercepted packet %v\", in)\n\n\tcircuitKey := models.CircuitKey{\n\t\tChanID: lnwire.NewShortChanIDFromInt(in.IncomingCircuitKey.ChanId),\n\t\tHtlcID: in.IncomingCircuitKey.HtlcId,\n\t}\n\n\tswitch in.Action {\n\tcase ResolveHoldForwardAction_RESUME:\n\t\treturn r.htlcSwitch.Resolve(&htlcswitch.FwdResolution{\n\t\t\tKey:    circuitKey,\n\t\t\tAction: htlcswitch.FwdActionResume,\n\t\t})\n\n\tcase ResolveHoldForwardAction_FAIL:\n\t\t// Fail with an encrypted reason.\n\t\tif in.FailureMessage != nil {\n\t\t\tif in.FailureCode != 0 {\n\t\t\t\treturn status.Errorf(\n\t\t\t\t\tcodes.InvalidArgument,\n\t\t\t\t\t\"failure message and failure code \"+\n\t\t\t\t\t\t\"are mutually exclusive\",\n\t\t\t\t)\n\t\t\t}\n\n\t\t\t// Verify that the size is equal to the fixed failure\n\t\t\t// message size + hmac + two uint16 lengths. See BOLT\n\t\t\t// #4.\n\t\t\tif len(in.FailureMessage) !=\n\t\t\t\tlnwire.FailureMessageLength+32+2+2 {\n\n\t\t\t\treturn status.Errorf(\n\t\t\t\t\tcodes.InvalidArgument,\n\t\t\t\t\t\"failure message length invalid\",\n\t\t\t\t)\n\t\t\t}\n\n\t\t\treturn r.htlcSwitch.Resolve(&htlcswitch.FwdResolution{\n\t\t\t\tKey:            circuitKey,\n\t\t\t\tAction:         htlcswitch.FwdActionFail,\n\t\t\t\tFailureMessage: in.FailureMessage,\n\t\t\t})\n\t\t}\n\n\t\tvar code lnwire.FailCode\n\t\tswitch in.FailureCode {\n\t\tcase lnrpc.Failure_INVALID_ONION_HMAC:\n\t\t\tcode = lnwire.CodeInvalidOnionHmac\n\n\t\tcase lnrpc.Failure_INVALID_ONION_KEY:\n\t\t\tcode = lnwire.CodeInvalidOnionKey\n\n\t\tcase lnrpc.Failure_INVALID_ONION_VERSION:\n\t\t\tcode = lnwire.CodeInvalidOnionVersion\n\n\t\t// Default to TemporaryChannelFailure.\n\t\tcase 0, lnrpc.Failure_TEMPORARY_CHANNEL_FAILURE:\n\t\t\tcode = lnwire.CodeTemporaryChannelFailure\n\n\t\tdefault:\n\t\t\treturn status.Errorf(\n\t\t\t\tcodes.InvalidArgument,\n\t\t\t\t\"unsupported failure code: %v\", in.FailureCode,\n\t\t\t)\n\t\t}\n\n\t\treturn r.htlcSwitch.Resolve(&htlcswitch.FwdResolution{\n\t\t\tKey:         circuitKey,\n\t\t\tAction:      htlcswitch.FwdActionFail,\n\t\t\tFailureCode: code,\n\t\t})\n\n\tcase ResolveHoldForwardAction_SETTLE:\n\t\tif in.Preimage == nil {\n\t\t\treturn ErrMissingPreimage\n\t\t}\n\t\tpreimage, err := lntypes.MakePreimage(in.Preimage)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn r.htlcSwitch.Resolve(&htlcswitch.FwdResolution{\n\t\t\tKey:      circuitKey,\n\t\t\tAction:   htlcswitch.FwdActionSettle,\n\t\t\tPreimage: preimage,\n\t\t})\n\n\tdefault:\n\t\treturn status.Errorf(\n\t\t\tcodes.InvalidArgument,\n\t\t\t\"unrecognized resolve action %v\", in.Action,\n\t\t)\n\t}\n}\n",
      "length": 2405,
      "tokens": 215,
      "embedding": []
    }
  ]
}