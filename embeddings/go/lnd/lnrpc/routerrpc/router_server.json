{
  "filepath": "../implementations/go/lnd/lnrpc/routerrpc/router_server.go",
  "package": "routerrpc",
  "sections": [
    {
      "slug": "type ServerShell struct {",
      "content": "type ServerShell struct {\n\tRouterServer\n}\n\n// Server is a stand alone sub RPC server which exposes functionality that\n// allows clients to route arbitrary payment through the Lightning Network.",
      "length": 163,
      "tokens": 26,
      "embedding": []
    },
    {
      "slug": "type Server struct {",
      "content": "type Server struct {\n\tstarted                  int32 // To be used atomically.\n\tshutdown                 int32 // To be used atomically.\n\tforwardInterceptorActive int32 // To be used atomically.\n\n\t// Required by the grpc-gateway/v2 library for forward compatibility.\n\t// Must be after the atomically used variables to not break struct\n\t// alignment.\n\tUnimplementedRouterServer\n\n\tcfg *Config\n\n\tquit chan struct{}\n}\n\n// A compile time check to ensure that Server fully implements the RouterServer\n// gRPC service.\nvar _ RouterServer = (*Server)(nil)\n\n// New creates a new instance of the RouterServer given a configuration struct\n// that contains all external dependencies. If the target macaroon exists, and\n// we're unable to create it, then an error will be returned. We also return\n// the set of permissions that we require as a server. At the time of writing\n// of this documentation, this is the same macaroon as as the admin macaroon.",
      "length": 896,
      "tokens": 142,
      "embedding": []
    },
    {
      "slug": "func New(cfg *Config) (*Server, lnrpc.MacaroonPerms, error) {",
      "content": "func New(cfg *Config) (*Server, lnrpc.MacaroonPerms, error) {\n\t// If the path of the router macaroon wasn't generated, then we'll\n\t// assume that it's found at the default network directory.\n\tif cfg.RouterMacPath == \"\" {\n\t\tcfg.RouterMacPath = filepath.Join(\n\t\t\tcfg.NetworkDir, DefaultRouterMacFilename,\n\t\t)\n\t}\n\n\t// Now that we know the full path of the router macaroon, we can check\n\t// to see if we need to create it or not. If stateless_init is set\n\t// then we don't write the macaroons.\n\tmacFilePath := cfg.RouterMacPath\n\tif cfg.MacService != nil && !cfg.MacService.StatelessInit &&\n\t\t!lnrpc.FileExists(macFilePath) {\n\n\t\tlog.Infof(\"Making macaroons for Router RPC Server at: %v\",\n\t\t\tmacFilePath)\n\n\t\t// At this point, we know that the router macaroon doesn't yet,\n\t\t// exist, so we need to create it with the help of the main\n\t\t// macaroon service.\n\t\trouterMac, err := cfg.MacService.NewMacaroon(\n\t\t\tcontext.Background(), macaroons.DefaultRootKeyID,\n\t\t\tmacaroonOps...,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\trouterMacBytes, err := routerMac.M().MarshalBinary()\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\terr = ioutil.WriteFile(macFilePath, routerMacBytes, 0644)\n\t\tif err != nil {\n\t\t\t_ = os.Remove(macFilePath)\n\t\t\treturn nil, nil, err\n\t\t}\n\t}\n\n\trouterServer := &Server{\n\t\tcfg:  cfg,\n\t\tquit: make(chan struct{}),\n\t}\n\n\treturn routerServer, macPermissions, nil\n}\n\n// Start launches any helper goroutines required for the rpcServer to function.\n//\n// NOTE: This is part of the lnrpc.SubServer interface.",
      "length": 1406,
      "tokens": 208,
      "embedding": []
    },
    {
      "slug": "func (s *Server) Start() error {",
      "content": "func (s *Server) Start() error {\n\tif atomic.AddInt32(&s.started, 1) != 1 {\n\t\treturn nil\n\t}\n\n\treturn nil\n}\n\n// Stop signals any active goroutines for a graceful closure.\n//\n// NOTE: This is part of the lnrpc.SubServer interface.",
      "length": 185,
      "tokens": 32,
      "embedding": []
    },
    {
      "slug": "func (s *Server) Stop() error {",
      "content": "func (s *Server) Stop() error {\n\tif atomic.AddInt32(&s.shutdown, 1) != 1 {\n\t\treturn nil\n\t}\n\n\tclose(s.quit)\n\treturn nil\n}\n\n// Name returns a unique string representation of the sub-server. This can be\n// used to identify the sub-server and also de-duplicate them.\n//\n// NOTE: This is part of the lnrpc.SubServer interface.",
      "length": 278,
      "tokens": 46,
      "embedding": []
    },
    {
      "slug": "func (s *Server) Name() string {",
      "content": "func (s *Server) Name() string {\n\treturn subServerName\n}\n\n// RegisterWithRootServer will be called by the root gRPC server to direct a\n// sub RPC server to register itself with the main gRPC root server. Until this\n// is called, each sub-server won't be able to have requests routed towards it.\n//\n// NOTE: This is part of the lnrpc.GrpcHandler interface.",
      "length": 315,
      "tokens": 55,
      "embedding": []
    },
    {
      "slug": "func (r *ServerShell) RegisterWithRootServer(grpcServer *grpc.Server) error {",
      "content": "func (r *ServerShell) RegisterWithRootServer(grpcServer *grpc.Server) error {\n\t// We make sure that we register it with the main gRPC server to ensure\n\t// all our methods are routed properly.\n\tRegisterRouterServer(grpcServer, r)\n\n\tlog.Debugf(\"Router RPC server successfully register with root gRPC \" +\n\t\t\"server\")\n\n\treturn nil\n}\n\n// RegisterWithRestServer will be called by the root REST mux to direct a sub\n// RPC server to register itself with the main REST mux server. Until this is\n// called, each sub-server won't be able to have requests routed towards it.\n//\n// NOTE: This is part of the lnrpc.GrpcHandler interface.",
      "length": 531,
      "tokens": 90,
      "embedding": []
    },
    {
      "slug": "func (r *ServerShell) RegisterWithRestServer(ctx context.Context,",
      "content": "func (r *ServerShell) RegisterWithRestServer(ctx context.Context,\n\tmux *runtime.ServeMux, dest string, opts []grpc.DialOption) error {\n\n\t// We make sure that we register it with the main REST server to ensure\n\t// all our methods are routed properly.\n\terr := RegisterRouterHandlerFromEndpoint(ctx, mux, dest, opts)\n\tif err != nil {\n\t\tlog.Errorf(\"Could not register Router REST server \"+\n\t\t\t\"with root REST server: %v\", err)\n\t\treturn err\n\t}\n\n\tlog.Debugf(\"Router REST server successfully registered with \" +\n\t\t\"root REST server\")\n\treturn nil\n}\n\n// CreateSubServer populates the subserver's dependencies using the passed\n// SubServerConfigDispatcher. This method should fully initialize the\n// sub-server instance, making it ready for action. It returns the macaroon\n// permissions that the sub-server wishes to pass on to the root server for all\n// methods routed towards it.\n//\n// NOTE: This is part of the lnrpc.GrpcHandler interface.",
      "length": 845,
      "tokens": 130,
      "embedding": []
    },
    {
      "slug": "func (r *ServerShell) CreateSubServer(configRegistry lnrpc.SubServerConfigDispatcher) (",
      "content": "func (r *ServerShell) CreateSubServer(configRegistry lnrpc.SubServerConfigDispatcher) (\n\tlnrpc.SubServer, lnrpc.MacaroonPerms, error) {\n\n\tsubServer, macPermissions, err := createNewSubServer(configRegistry)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tr.RouterServer = subServer\n\treturn subServer, macPermissions, nil\n}\n\n// SendPaymentV2 attempts to route a payment described by the passed\n// PaymentRequest to the final destination. If we are unable to route the\n// payment, or cannot find a route that satisfies the constraints in the\n// PaymentRequest, then an error will be returned. Otherwise, the payment\n// pre-image, along with the final route will be returned.",
      "length": 566,
      "tokens": 85,
      "embedding": []
    },
    {
      "slug": "func (s *Server) SendPaymentV2(req *SendPaymentRequest,",
      "content": "func (s *Server) SendPaymentV2(req *SendPaymentRequest,\n\tstream Router_SendPaymentV2Server) error {\n\n\tpayment, err := s.cfg.RouterBackend.extractIntentFromSendRequest(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = s.cfg.Router.SendPaymentAsync(payment)\n\tif err != nil {\n\t\t// Transform user errors to grpc code.\n\t\tif err == channeldb.ErrPaymentInFlight ||\n\t\t\terr == channeldb.ErrAlreadyPaid {\n\n\t\t\tlog.Debugf(\"SendPayment async result for payment %x: %v\",\n\t\t\t\tpayment.Identifier(), err)\n\n\t\t\treturn status.Error(\n\t\t\t\tcodes.AlreadyExists, err.Error(),\n\t\t\t)\n\t\t}\n\n\t\tlog.Errorf(\"SendPayment async error for payment %x: %v\",\n\t\t\tpayment.Identifier(), err)\n\n\t\treturn err\n\t}\n\n\treturn s.trackPayment(payment.Identifier(), stream, req.NoInflightUpdates)\n}\n\n// EstimateRouteFee allows callers to obtain a lower bound w.r.t how much it\n// may cost to send an HTLC to the target end destination.",
      "length": 791,
      "tokens": 97,
      "embedding": []
    },
    {
      "slug": "func (s *Server) EstimateRouteFee(ctx context.Context,",
      "content": "func (s *Server) EstimateRouteFee(ctx context.Context,\n\treq *RouteFeeRequest) (*RouteFeeResponse, error) {\n\n\tif len(req.Dest) != 33 {\n\t\treturn nil, errors.New(\"invalid length destination key\")\n\t}\n\tvar destNode route.Vertex\n\tcopy(destNode[:], req.Dest)\n\n\t// Next, we'll convert the amount in satoshis to mSAT, which are the\n\t// native unit of LN.\n\tamtMsat := lnwire.NewMSatFromSatoshis(btcutil.Amount(req.AmtSat))\n\n\t// Pick a fee limit\n\t//\n\t// TODO: Change this into behaviour that makes more sense.\n\tfeeLimit := lnwire.NewMSatFromSatoshis(btcutil.SatoshiPerBitcoin)\n\n\t// Finally, we'll query for a route to the destination that can carry\n\t// that target amount, we'll only request a single route. Set a\n\t// restriction for the default CLTV limit, otherwise we can find a route\n\t// that exceeds it and is useless to us.\n\tmc := s.cfg.RouterBackend.MissionControl\n\troute, _, err := s.cfg.Router.FindRoute(\n\t\ts.cfg.RouterBackend.SelfNode, destNode, amtMsat, 0,\n\t\t&routing.RestrictParams{\n\t\t\tFeeLimit:          feeLimit,\n\t\t\tCltvLimit:         s.cfg.RouterBackend.MaxTotalTimelock,\n\t\t\tProbabilitySource: mc.GetProbability,\n\t\t}, nil, nil, s.cfg.RouterBackend.DefaultFinalCltvDelta,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &RouteFeeResponse{\n\t\tRoutingFeeMsat: int64(route.TotalFees()),\n\t\tTimeLockDelay:  int64(route.TotalTimeLock),\n\t}, nil\n}\n\n// SendToRouteV2 sends a payment through a predefined route. The response of this\n// call contains structured error information.",
      "length": 1377,
      "tokens": 170,
      "embedding": []
    },
    {
      "slug": "func (s *Server) SendToRouteV2(ctx context.Context,",
      "content": "func (s *Server) SendToRouteV2(ctx context.Context,\n\treq *SendToRouteRequest) (*lnrpc.HTLCAttempt, error) {\n\n\tif req.Route == nil {\n\t\treturn nil, fmt.Errorf(\"unable to send, no routes provided\")\n\t}\n\n\troute, err := s.cfg.RouterBackend.UnmarshallRoute(req.Route)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\thash, err := lntypes.MakeHash(req.PaymentHash)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar attempt *channeldb.HTLCAttempt\n\n\t// Pass route to the router. This call returns the full htlc attempt\n\t// information as it is stored in the database. It is possible that both\n\t// the attempt return value and err are non-nil. This can happen when\n\t// the attempt was already initiated before the error happened. In that\n\t// case, we give precedence to the attempt information as stored in the\n\t// db.\n\tif req.SkipTempErr {\n\t\tattempt, err = s.cfg.Router.SendToRouteSkipTempErr(hash, route)\n\t} else {\n\t\tattempt, err = s.cfg.Router.SendToRoute(hash, route)\n\t}\n\tif attempt != nil {\n\t\trpcAttempt, err := s.cfg.RouterBackend.MarshalHTLCAttempt(\n\t\t\t*attempt,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn rpcAttempt, nil\n\t}\n\n\t// Transform user errors to grpc code.\n\tif err == channeldb.ErrPaymentInFlight ||\n\t\terr == channeldb.ErrAlreadyPaid {\n\n\t\treturn nil, status.Error(codes.AlreadyExists, err.Error())\n\t}\n\n\treturn nil, err\n}\n\n// ResetMissionControl clears all mission control state and starts with a clean\n// slate.",
      "length": 1310,
      "tokens": 195,
      "embedding": []
    },
    {
      "slug": "func (s *Server) ResetMissionControl(ctx context.Context,",
      "content": "func (s *Server) ResetMissionControl(ctx context.Context,\n\treq *ResetMissionControlRequest) (*ResetMissionControlResponse, error) {\n\n\terr := s.cfg.RouterBackend.MissionControl.ResetHistory()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &ResetMissionControlResponse{}, nil\n}\n\n// GetMissionControlConfig returns our current mission control config.",
      "length": 279,
      "tokens": 29,
      "embedding": []
    },
    {
      "slug": "func (s *Server) GetMissionControlConfig(ctx context.Context,",
      "content": "func (s *Server) GetMissionControlConfig(ctx context.Context,\n\treq *GetMissionControlConfigRequest) (*GetMissionControlConfigResponse,\n\terror) {\n\n\t// Query the current mission control config.\n\tcfg := s.cfg.RouterBackend.MissionControl.GetConfig()\n\tresp := &GetMissionControlConfigResponse{\n\t\tConfig: &MissionControlConfig{\n\t\t\tMaximumPaymentResults: uint32(cfg.MaxMcHistory),\n\t\t\tMinimumFailureRelaxInterval: uint64(\n\t\t\t\tcfg.MinFailureRelaxInterval.Seconds(),\n\t\t\t),\n\t\t},\n\t}\n\n\t// We only populate fields based on the current estimator.\n\tswitch v := cfg.Estimator.Config().(type) {\n\tcase routing.AprioriConfig:\n\t\tresp.Config.Model = MissionControlConfig_APRIORI\n\t\taCfg := AprioriParameters{\n\t\t\tHalfLifeSeconds:  uint64(v.PenaltyHalfLife.Seconds()),\n\t\t\tHopProbability:   v.AprioriHopProbability,\n\t\t\tWeight:           v.AprioriWeight,\n\t\t\tCapacityFraction: v.CapacityFraction,\n\t\t}\n\n\t\t// Populate deprecated fields.\n\t\tresp.Config.HalfLifeSeconds = uint64(\n\t\t\tv.PenaltyHalfLife.Seconds(),\n\t\t)\n\t\tresp.Config.HopProbability = float32(v.AprioriHopProbability)\n\t\tresp.Config.Weight = float32(v.AprioriWeight)\n\n\t\tresp.Config.EstimatorConfig = &MissionControlConfig_Apriori{\n\t\t\tApriori: &aCfg,\n\t\t}\n\n\tcase routing.BimodalConfig:\n\t\tresp.Config.Model = MissionControlConfig_BIMODAL\n\t\tbCfg := BimodalParameters{\n\t\t\tNodeWeight: v.BimodalNodeWeight,\n\t\t\tScaleMsat:  uint64(v.BimodalScaleMsat),\n\t\t\tDecayTime:  uint64(v.BimodalDecayTime.Seconds()),\n\t\t}\n\n\t\tresp.Config.EstimatorConfig = &MissionControlConfig_Bimodal{\n\t\t\tBimodal: &bCfg,\n\t\t}\n\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unknown estimator config type %T\", v)\n\t}\n\n\treturn resp, nil\n}\n\n// SetMissionControlConfig sets parameters in the mission control config.",
      "length": 1572,
      "tokens": 125,
      "embedding": []
    },
    {
      "slug": "func (s *Server) SetMissionControlConfig(ctx context.Context,",
      "content": "func (s *Server) SetMissionControlConfig(ctx context.Context,\n\treq *SetMissionControlConfigRequest) (*SetMissionControlConfigResponse,\n\terror) {\n\n\tmcCfg := &routing.MissionControlConfig{\n\t\tMaxMcHistory: int(req.Config.MaximumPaymentResults),\n\t\tMinFailureRelaxInterval: time.Duration(\n\t\t\treq.Config.MinimumFailureRelaxInterval,\n\t\t) * time.Second,\n\t}\n\n\tswitch req.Config.Model {\n\tcase MissionControlConfig_APRIORI:\n\t\tvar aprioriConfig routing.AprioriConfig\n\n\t\t// Determine the apriori config with backward compatibility\n\t\t// should the api use deprecated fields.\n\t\tswitch v := req.Config.EstimatorConfig.(type) {\n\t\tcase *MissionControlConfig_Bimodal:\n\t\t\treturn nil, fmt.Errorf(\"bimodal config \" +\n\t\t\t\t\"provided, but apriori model requested\")\n\n\t\tcase *MissionControlConfig_Apriori:\n\t\t\taprioriConfig = routing.AprioriConfig{\n\t\t\t\tPenaltyHalfLife: time.Duration(\n\t\t\t\t\tv.Apriori.HalfLifeSeconds,\n\t\t\t\t) * time.Second,\n\t\t\t\tAprioriHopProbability: v.Apriori.HopProbability,\n\t\t\t\tAprioriWeight:         v.Apriori.Weight,\n\t\t\t\tCapacityFraction: v.Apriori.\n\t\t\t\t\tCapacityFraction,\n\t\t\t}\n\n\t\tdefault:\n\t\t\taprioriConfig = routing.AprioriConfig{\n\t\t\t\tPenaltyHalfLife: time.Duration(\n\t\t\t\t\tint64(req.Config.HalfLifeSeconds),\n\t\t\t\t) * time.Second,\n\t\t\t\tAprioriHopProbability: float64(\n\t\t\t\t\treq.Config.HopProbability,\n\t\t\t\t),\n\t\t\t\tAprioriWeight: float64(req.Config.Weight),\n\t\t\t\tCapacityFraction: float64(\n\t\t\t\t\trouting.DefaultCapacityFraction),\n\t\t\t}\n\t\t}\n\n\t\testimator, err := routing.NewAprioriEstimator(aprioriConfig)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tmcCfg.Estimator = estimator\n\n\tcase MissionControlConfig_BIMODAL:\n\t\tcfg, ok := req.Config.\n\t\t\tEstimatorConfig.(*MissionControlConfig_Bimodal)\n\t\tif !ok {\n\t\t\treturn nil, fmt.Errorf(\"bimodal estimator requested \" +\n\t\t\t\t\"but corresponding config not set\")\n\t\t}\n\t\tbCfg := cfg.Bimodal\n\n\t\tbimodalConfig := routing.BimodalConfig{\n\t\t\tBimodalDecayTime: time.Duration(\n\t\t\t\tbCfg.DecayTime,\n\t\t\t) * time.Second,\n\t\t\tBimodalScaleMsat:  lnwire.MilliSatoshi(bCfg.ScaleMsat),\n\t\t\tBimodalNodeWeight: bCfg.NodeWeight,\n\t\t}\n\n\t\testimator, err := routing.NewBimodalEstimator(bimodalConfig)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tmcCfg.Estimator = estimator\n\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unknown estimator type %v\",\n\t\t\treq.Config.Model)\n\t}\n\n\treturn &SetMissionControlConfigResponse{},\n\t\ts.cfg.RouterBackend.MissionControl.SetConfig(mcCfg)\n}\n\n// QueryMissionControl exposes the internal mission control state to callers. It\n// is a development feature.",
      "length": 2314,
      "tokens": 199,
      "embedding": []
    },
    {
      "slug": "func (s *Server) QueryMissionControl(ctx context.Context,",
      "content": "func (s *Server) QueryMissionControl(ctx context.Context,\n\treq *QueryMissionControlRequest) (*QueryMissionControlResponse, error) {\n\n\tsnapshot := s.cfg.RouterBackend.MissionControl.GetHistorySnapshot()\n\n\trpcPairs := make([]*PairHistory, 0, len(snapshot.Pairs))\n\tfor _, p := range snapshot.Pairs {\n\t\t// Prevent binding to loop variable.\n\t\tpair := p\n\n\t\trpcPair := PairHistory{\n\t\t\tNodeFrom: pair.Pair.From[:],\n\t\t\tNodeTo:   pair.Pair.To[:],\n\t\t\tHistory:  toRPCPairData(&pair.TimedPairResult),\n\t\t}\n\n\t\trpcPairs = append(rpcPairs, &rpcPair)\n\t}\n\n\tresponse := QueryMissionControlResponse{\n\t\tPairs: rpcPairs,\n\t}\n\n\treturn &response, nil\n}\n\n// toRPCPairData marshalls mission control pair data to the rpc struct.",
      "length": 616,
      "tokens": 65,
      "embedding": []
    },
    {
      "slug": "func toRPCPairData(data *routing.TimedPairResult) *PairData {",
      "content": "func toRPCPairData(data *routing.TimedPairResult) *PairData {\n\trpcData := PairData{\n\t\tFailAmtSat:     int64(data.FailAmt.ToSatoshis()),\n\t\tFailAmtMsat:    int64(data.FailAmt),\n\t\tSuccessAmtSat:  int64(data.SuccessAmt.ToSatoshis()),\n\t\tSuccessAmtMsat: int64(data.SuccessAmt),\n\t}\n\n\tif !data.FailTime.IsZero() {\n\t\trpcData.FailTime = data.FailTime.Unix()\n\t}\n\n\tif !data.SuccessTime.IsZero() {\n\t\trpcData.SuccessTime = data.SuccessTime.Unix()\n\t}\n\n\treturn &rpcData\n}\n\n// XImportMissionControl imports the state provided to our internal mission\n// control. Only entries that are fresher than our existing state will be used.",
      "length": 531,
      "tokens": 53,
      "embedding": []
    },
    {
      "slug": "func (s *Server) XImportMissionControl(ctx context.Context,",
      "content": "func (s *Server) XImportMissionControl(ctx context.Context,\n\treq *XImportMissionControlRequest) (*XImportMissionControlResponse,\n\terror) {\n\n\tif len(req.Pairs) == 0 {\n\t\treturn nil, errors.New(\"at least one pair required for import\")\n\t}\n\n\tsnapshot := &routing.MissionControlSnapshot{\n\t\tPairs: make(\n\t\t\t[]routing.MissionControlPairSnapshot, len(req.Pairs),\n\t\t),\n\t}\n\n\tfor i, pairResult := range req.Pairs {\n\t\tpairSnapshot, err := toPairSnapshot(pairResult)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tsnapshot.Pairs[i] = *pairSnapshot\n\t}\n\n\terr := s.cfg.RouterBackend.MissionControl.ImportHistory(\n\t\tsnapshot, req.Force,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &XImportMissionControlResponse{}, nil\n}\n",
      "length": 615,
      "tokens": 72,
      "embedding": []
    },
    {
      "slug": "func toPairSnapshot(pairResult *PairHistory) (*routing.MissionControlPairSnapshot,",
      "content": "func toPairSnapshot(pairResult *PairHistory) (*routing.MissionControlPairSnapshot,\n\terror) {\n\n\tfrom, err := route.NewVertexFromBytes(pairResult.NodeFrom)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tto, err := route.NewVertexFromBytes(pairResult.NodeTo)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpairPrefix := fmt.Sprintf(\"pair: %v -> %v:\", from, to)\n\n\tif from == to {\n\t\treturn nil, fmt.Errorf(\"%v source and destination node must \"+\n\t\t\t\"differ\", pairPrefix)\n\t}\n\n\tfailAmt, failTime, err := getPair(\n\t\tlnwire.MilliSatoshi(pairResult.History.FailAmtMsat),\n\t\tbtcutil.Amount(pairResult.History.FailAmtSat),\n\t\tpairResult.History.FailTime,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"%v invalid failure: %v\", pairPrefix,\n\t\t\terr)\n\t}\n\n\tsuccessAmt, successTime, err := getPair(\n\t\tlnwire.MilliSatoshi(pairResult.History.SuccessAmtMsat),\n\t\tbtcutil.Amount(pairResult.History.SuccessAmtSat),\n\t\tpairResult.History.SuccessTime,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"%v invalid success: %v\", pairPrefix,\n\t\t\terr)\n\t}\n\n\tif successAmt == 0 && failAmt == 0 {\n\t\treturn nil, fmt.Errorf(\"%v: either success or failure result \"+\n\t\t\t\"required\", pairPrefix)\n\t}\n\n\tpair := routing.NewDirectedNodePair(from, to)\n\n\tresult := &routing.TimedPairResult{\n\t\tFailAmt:     failAmt,\n\t\tFailTime:    failTime,\n\t\tSuccessAmt:  successAmt,\n\t\tSuccessTime: successTime,\n\t}\n\n\treturn &routing.MissionControlPairSnapshot{\n\t\tPair:            pair,\n\t\tTimedPairResult: *result,\n\t}, nil\n}\n\n// getPair validates the values provided for a mission control result and\n// returns the msat amount and timestamp for it.",
      "length": 1419,
      "tokens": 166,
      "embedding": []
    },
    {
      "slug": "func getPair(amtMsat lnwire.MilliSatoshi, amtSat btcutil.Amount,",
      "content": "func getPair(amtMsat lnwire.MilliSatoshi, amtSat btcutil.Amount,\n\ttimestamp int64) (lnwire.MilliSatoshi, time.Time, error) {\n\n\tamt, err := getMsatPairValue(amtMsat, amtSat)\n\tif err != nil {\n\t\treturn 0, time.Time{}, err\n\t}\n\n\tvar (\n\t\ttimeSet   = timestamp != 0\n\t\tamountSet = amt != 0\n\t)\n\n\tswitch {\n\tcase timeSet && amountSet:\n\t\treturn amt, time.Unix(timestamp, 0), nil\n\n\tcase timeSet && !amountSet:\n\t\treturn 0, time.Time{}, errors.New(\"non-zero timestamp \" +\n\t\t\t\"requires non-zero amount\")\n\n\tcase !timeSet && amountSet:\n\t\treturn 0, time.Time{}, errors.New(\"non-zero amount requires \" +\n\t\t\t\"non-zero timestamp\")\n\n\tdefault:\n\t\treturn 0, time.Time{}, nil\n\t}\n}\n\n// getMsatPairValue checks the msat and sat values set for a pair and ensures\n// that the values provided are either the same, or only a single value is set.",
      "length": 717,
      "tokens": 110,
      "embedding": []
    },
    {
      "slug": "func getMsatPairValue(msatValue lnwire.MilliSatoshi,",
      "content": "func getMsatPairValue(msatValue lnwire.MilliSatoshi,\n\tsatValue btcutil.Amount) (lnwire.MilliSatoshi, error) {\n\n\t// If our msat value converted to sats equals our sat value, we just\n\t// return the msat value, since the values are the same.\n\tif msatValue.ToSatoshis() == satValue {\n\t\treturn msatValue, nil\n\t}\n\n\t// If we have no msatValue, we can just return our state value even if\n\t// it is zero, because it's impossible that we have mismatched values.\n\tif msatValue == 0 {\n\t\treturn lnwire.MilliSatoshi(satValue * 1000), nil\n\t}\n\n\t// Likewise, we can just use msat value if we have no sat value set.\n\tif satValue == 0 {\n\t\treturn msatValue, nil\n\t}\n\n\t// If our values are non-zero but not equal, we have invalid amounts\n\t// set, so we fail.\n\treturn 0, fmt.Errorf(\"msat: %v and sat: %v values not equal\", msatValue,\n\t\tsatValue)\n}\n\n// TrackPaymentV2 returns a stream of payment state updates. The stream is\n// closed when the payment completes.",
      "length": 859,
      "tokens": 150,
      "embedding": []
    },
    {
      "slug": "func (s *Server) TrackPaymentV2(request *TrackPaymentRequest,",
      "content": "func (s *Server) TrackPaymentV2(request *TrackPaymentRequest,\n\tstream Router_TrackPaymentV2Server) error {\n\n\tpaymentHash, err := lntypes.MakeHash(request.PaymentHash)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlog.Debugf(\"TrackPayment called for payment %v\", paymentHash)\n\n\treturn s.trackPayment(paymentHash, stream, request.NoInflightUpdates)\n}\n\n// trackPayment writes payment status updates to the provided stream.",
      "length": 334,
      "tokens": 37,
      "embedding": []
    },
    {
      "slug": "func (s *Server) trackPayment(identifier lntypes.Hash,",
      "content": "func (s *Server) trackPayment(identifier lntypes.Hash,\n\tstream Router_TrackPaymentV2Server, noInflightUpdates bool) error {\n\n\trouter := s.cfg.RouterBackend\n\n\t// Subscribe to the outcome of this payment.\n\tsubscription, err := router.Tower.SubscribePayment(identifier)\n\n\tswitch {\n\tcase err == channeldb.ErrPaymentNotInitiated:\n\t\treturn status.Error(codes.NotFound, err.Error())\n\tcase err != nil:\n\t\treturn err\n\t}\n\n\t// Stream updates to the client.\n\terr = s.trackPaymentStream(\n\t\tstream.Context(), subscription, noInflightUpdates, stream.Send,\n\t)\n\n\tif errors.Is(err, context.Canceled) {\n\t\tlog.Debugf(\"Payment stream %v canceled\", identifier)\n\t}\n\n\treturn err\n}\n\n// TrackPayments returns a stream of payment state updates.",
      "length": 635,
      "tokens": 73,
      "embedding": []
    },
    {
      "slug": "func (s *Server) TrackPayments(request *TrackPaymentsRequest,",
      "content": "func (s *Server) TrackPayments(request *TrackPaymentsRequest,\n\tstream Router_TrackPaymentsServer) error {\n\n\tlog.Debug(\"TrackPayments called\")\n\n\trouter := s.cfg.RouterBackend\n\n\t// Subscribe to payments.\n\tsubscription, err := router.Tower.SubscribeAllPayments()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Stream updates to the client.\n\terr = s.trackPaymentStream(\n\t\tstream.Context(), subscription, request.NoInflightUpdates,\n\t\tstream.Send,\n\t)\n\n\tif errors.Is(err, context.Canceled) {\n\t\tlog.Debugf(\"TrackPayments payment stream canceled.\")\n\t}\n\n\treturn err\n}\n\n// trackPaymentStream streams payment updates to the client.",
      "length": 523,
      "tokens": 59,
      "embedding": []
    },
    {
      "slug": "func (s *Server) trackPaymentStream(context context.Context,",
      "content": "func (s *Server) trackPaymentStream(context context.Context,\n\tsubscription routing.ControlTowerSubscriber, noInflightUpdates bool,\n\tsend func(*lnrpc.Payment) error) error {\n\n\tdefer subscription.Close()\n\n\t// Stream updates back to the client.\n\tfor {\n\t\tselect {\n\t\tcase item, ok := <-subscription.Updates():\n\t\t\tif !ok {\n\t\t\t\t// No more payment updates.\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tresult := item.(*channeldb.MPPayment)\n\n\t\t\t// Skip in-flight updates unless requested.\n\t\t\tif noInflightUpdates &&\n\t\t\t\tresult.Status == channeldb.StatusInFlight {\n\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\trpcPayment, err := s.cfg.RouterBackend.MarshallPayment(\n\t\t\t\tresult,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Send event to the client.\n\t\t\terr = send(rpcPayment)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase <-s.quit:\n\t\t\treturn errServerShuttingDown\n\n\t\tcase <-context.Done():\n\t\t\treturn context.Err()\n\t\t}\n\t}\n}\n\n// BuildRoute builds a route from a list of hop addresses.",
      "length": 829,
      "tokens": 109,
      "embedding": []
    },
    {
      "slug": "func (s *Server) BuildRoute(ctx context.Context,",
      "content": "func (s *Server) BuildRoute(ctx context.Context,\n\treq *BuildRouteRequest) (*BuildRouteResponse, error) {\n\n\t// Unmarshall hop list.\n\thops := make([]route.Vertex, len(req.HopPubkeys))\n\tfor i, pubkeyBytes := range req.HopPubkeys {\n\t\tpubkey, err := route.NewVertexFromBytes(pubkeyBytes)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\thops[i] = pubkey\n\t}\n\n\t// Prepare BuildRoute call parameters from rpc request.\n\tvar amt *lnwire.MilliSatoshi\n\tif req.AmtMsat != 0 {\n\t\trpcAmt := lnwire.MilliSatoshi(req.AmtMsat)\n\t\tamt = &rpcAmt\n\t}\n\n\tvar outgoingChan *uint64\n\tif req.OutgoingChanId != 0 {\n\t\toutgoingChan = &req.OutgoingChanId\n\t}\n\n\tvar payAddr *[32]byte\n\tif len(req.PaymentAddr) != 0 {\n\t\tvar backingPayAddr [32]byte\n\t\tcopy(backingPayAddr[:], req.PaymentAddr)\n\n\t\tpayAddr = &backingPayAddr\n\t}\n\n\t// Build the route and return it to the caller.\n\troute, err := s.cfg.Router.BuildRoute(\n\t\tamt, hops, outgoingChan, req.FinalCltvDelta, payAddr,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trpcRoute, err := s.cfg.RouterBackend.MarshallRoute(route)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trouteResp := &BuildRouteResponse{\n\t\tRoute: rpcRoute,\n\t}\n\n\treturn routeResp, nil\n}\n\n// SubscribeHtlcEvents creates a uni-directional stream from the server to\n// the client which delivers a stream of htlc events.",
      "length": 1175,
      "tokens": 161,
      "embedding": []
    },
    {
      "slug": "func (s *Server) SubscribeHtlcEvents(req *SubscribeHtlcEventsRequest,",
      "content": "func (s *Server) SubscribeHtlcEvents(req *SubscribeHtlcEventsRequest,\n\tstream Router_SubscribeHtlcEventsServer) error {\n\n\thtlcClient, err := s.cfg.RouterBackend.SubscribeHtlcEvents()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer htlcClient.Cancel()\n\n\t// Send out an initial subscribed event so that the caller knows the\n\t// point from which new events will be transmitted.\n\tif err := stream.Send(&HtlcEvent{\n\t\tEvent: &HtlcEvent_SubscribedEvent{\n\t\t\tSubscribedEvent: &SubscribedEvent{},\n\t\t},\n\t}); err != nil {\n\t\treturn err\n\t}\n\n\tfor {\n\t\tselect {\n\t\tcase event := <-htlcClient.Updates():\n\t\t\trpcEvent, err := rpcHtlcEvent(event)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif err := stream.Send(rpcEvent); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t// If the stream's context is cancelled, return an error.\n\t\tcase <-stream.Context().Done():\n\t\t\tlog.Debugf(\"htlc event stream cancelled\")\n\t\t\treturn stream.Context().Err()\n\n\t\t// If the subscribe client terminates, exit with an error.\n\t\tcase <-htlcClient.Quit():\n\t\t\treturn errors.New(\"htlc event subscription terminated\")\n\n\t\t// If the server has been signalled to shut down, exit.\n\t\tcase <-s.quit:\n\t\t\treturn errServerShuttingDown\n\t\t}\n\t}\n}\n\n// HtlcInterceptor is a bidirectional stream for streaming interception\n// requests to the caller.\n// Upon connection it does the following:\n// 1. Check if there is already a live stream, if yes it rejects the request.\n// 2. Registered a ForwardInterceptor\n// 3. Delivers to the caller every \u221a\u221a and detect his answer.\n// It uses a local implementation of holdForwardsStore to keep all the hold\n// forwards and find them when manual resolution is later needed.",
      "length": 1502,
      "tokens": 219,
      "embedding": []
    },
    {
      "slug": "func (s *Server) HtlcInterceptor(stream Router_HtlcInterceptorServer) error {",
      "content": "func (s *Server) HtlcInterceptor(stream Router_HtlcInterceptorServer) error {\n\t// We ensure there is only one interceptor at a time.\n\tif !atomic.CompareAndSwapInt32(&s.forwardInterceptorActive, 0, 1) {\n\t\treturn ErrInterceptorAlreadyExists\n\t}\n\tdefer atomic.CompareAndSwapInt32(&s.forwardInterceptorActive, 1, 0)\n\n\t// run the forward interceptor.\n\treturn newForwardInterceptor(\n\t\ts.cfg.RouterBackend.InterceptableForwarder, stream,\n\t).run()\n}\n",
      "length": 352,
      "tokens": 34,
      "embedding": []
    },
    {
      "slug": "func extractOutPoint(req *UpdateChanStatusRequest) (*wire.OutPoint, error) {",
      "content": "func extractOutPoint(req *UpdateChanStatusRequest) (*wire.OutPoint, error) {\n\tchanPoint := req.GetChanPoint()\n\ttxid, err := lnrpc.GetChanPointFundingTxid(chanPoint)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tindex := chanPoint.OutputIndex\n\treturn wire.NewOutPoint(txid, index), nil\n}\n\n// UpdateChanStatus allows channel state to be set manually.",
      "length": 255,
      "tokens": 33,
      "embedding": []
    },
    {
      "slug": "func (s *Server) UpdateChanStatus(ctx context.Context,",
      "content": "func (s *Server) UpdateChanStatus(ctx context.Context,\n\treq *UpdateChanStatusRequest) (*UpdateChanStatusResponse, error) {\n\n\toutPoint, err := extractOutPoint(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\taction := req.GetAction()\n\n\tlog.Debugf(\"UpdateChanStatus called for channel(%v) with \"+\n\t\t\"action %v\", outPoint, action)\n\n\tswitch action {\n\tcase ChanStatusAction_ENABLE:\n\t\terr = s.cfg.RouterBackend.SetChannelEnabled(*outPoint)\n\tcase ChanStatusAction_DISABLE:\n\t\terr = s.cfg.RouterBackend.SetChannelDisabled(*outPoint)\n\tcase ChanStatusAction_AUTO:\n\t\terr = s.cfg.RouterBackend.SetChannelAuto(*outPoint)\n\tdefault:\n\t\terr = fmt.Errorf(\"unrecognized ChannelStatusAction %v\", action)\n\t}\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &UpdateChanStatusResponse{}, nil\n}\n",
      "length": 681,
      "tokens": 70,
      "embedding": []
    }
  ]
}