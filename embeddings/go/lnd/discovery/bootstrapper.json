{
  "filepath": "../implementations/go/lnd/discovery/bootstrapper.go",
  "package": "discovery",
  "sections": [
    {
      "slug": "func init() {",
      "content": "func init() {\n\tprand.Seed(time.Now().Unix())\n}\n\n// NetworkPeerBootstrapper is an interface that represents an initial peer\n// bootstrap mechanism. This interface is to be used to bootstrap a new peer to\n// the connection by providing it with the pubkey+address of a set of existing\n// peers on the network. Several bootstrap mechanisms can be implemented such\n// as DNS, in channel graph, DHT's, etc.",
      "length": 379,
      "tokens": 61,
      "embedding": []
    },
    {
      "slug": "type NetworkPeerBootstrapper interface {",
      "content": "type NetworkPeerBootstrapper interface {\n\t// SampleNodeAddrs uniformly samples a set of specified address from\n\t// the network peer bootstrapper source. The num addrs field passed in\n\t// denotes how many valid peer addresses to return. The passed set of\n\t// node nodes allows the caller to ignore a set of nodes perhaps\n\t// because they already have connections established.\n\tSampleNodeAddrs(numAddrs uint32,\n\t\tignore map[autopilot.NodeID]struct{}) ([]*lnwire.NetAddress, error)\n\n\t// Name returns a human readable string which names the concrete\n\t// implementation of the NetworkPeerBootstrapper.\n\tName() string\n}\n\n// MultiSourceBootstrap attempts to utilize a set of NetworkPeerBootstrapper\n// passed in to return the target (numAddrs) number of peer addresses that can\n// be used to bootstrap a peer just joining the Lightning Network. Each\n// bootstrapper will be queried successively until the target amount is met. If\n// the ignore map is populated, then the bootstrappers will be instructed to\n// skip those nodes.",
      "length": 961,
      "tokens": 146,
      "embedding": []
    },
    {
      "slug": "func MultiSourceBootstrap(ignore map[autopilot.NodeID]struct{}, numAddrs uint32,",
      "content": "func MultiSourceBootstrap(ignore map[autopilot.NodeID]struct{}, numAddrs uint32,\n\tbootstrappers ...NetworkPeerBootstrapper) ([]*lnwire.NetAddress, error) {\n\n\t// We'll randomly shuffle our bootstrappers before querying them in\n\t// order to avoid from querying the same bootstrapper method over and\n\t// over, as some of these might tend to provide better/worse results\n\t// than others.\n\tbootstrappers = shuffleBootstrappers(bootstrappers)\n\n\tvar addrs []*lnwire.NetAddress\n\tfor _, bootstrapper := range bootstrappers {\n\t\t// If we already have enough addresses, then we can exit early\n\t\t// w/o querying the additional bootstrappers.\n\t\tif uint32(len(addrs)) >= numAddrs {\n\t\t\tbreak\n\t\t}\n\n\t\tlog.Infof(\"Attempting to bootstrap with: %v\", bootstrapper.Name())\n\n\t\t// If we still need additional addresses, then we'll compute\n\t\t// the number of address remaining that we need to fetch.\n\t\tnumAddrsLeft := numAddrs - uint32(len(addrs))\n\t\tlog.Tracef(\"Querying for %v addresses\", numAddrsLeft)\n\t\tnetAddrs, err := bootstrapper.SampleNodeAddrs(numAddrsLeft, ignore)\n\t\tif err != nil {\n\t\t\t// If we encounter an error with a bootstrapper, then\n\t\t\t// we'll continue on to the next available\n\t\t\t// bootstrapper.\n\t\t\tlog.Errorf(\"Unable to query bootstrapper %v: %v\",\n\t\t\t\tbootstrapper.Name(), err)\n\t\t\tcontinue\n\t\t}\n\n\t\taddrs = append(addrs, netAddrs...)\n\t}\n\n\tif len(addrs) == 0 {\n\t\treturn nil, errors.New(\"no addresses found\")\n\t}\n\n\tlog.Infof(\"Obtained %v addrs to bootstrap network with\", len(addrs))\n\n\treturn addrs, nil\n}\n\n// shuffleBootstrappers shuffles the set of bootstrappers in order to avoid\n// querying the same bootstrapper over and over. To shuffle the set of\n// candidates, we use a version of the Fisher\u2013Yates shuffle algorithm.",
      "length": 1586,
      "tokens": 220,
      "embedding": []
    },
    {
      "slug": "func shuffleBootstrappers(candidates []NetworkPeerBootstrapper) []NetworkPeerBootstrapper {",
      "content": "func shuffleBootstrappers(candidates []NetworkPeerBootstrapper) []NetworkPeerBootstrapper {\n\tshuffled := make([]NetworkPeerBootstrapper, len(candidates))\n\tperm := prand.Perm(len(candidates))\n\n\tfor i, v := range perm {\n\t\tshuffled[v] = candidates[i]\n\t}\n\n\treturn shuffled\n}\n\n// ChannelGraphBootstrapper is an implementation of the NetworkPeerBootstrapper\n// which attempts to retrieve advertised peers directly from the active channel\n// graph. This instance requires a backing autopilot.ChannelGraph instance in\n// order to operate properly.",
      "length": 434,
      "tokens": 56,
      "embedding": []
    },
    {
      "slug": "type ChannelGraphBootstrapper struct {",
      "content": "type ChannelGraphBootstrapper struct {\n\tchanGraph autopilot.ChannelGraph\n\n\t// hashAccumulator is a set of 32 random bytes that are read upon the\n\t// creation of the channel graph bootstrapper. We use this value to\n\t// randomly select nodes within the known graph to connect to. After\n\t// each selection, we rotate the accumulator by hashing it with itself.\n\thashAccumulator [32]byte\n\n\ttried map[autopilot.NodeID]struct{}\n}\n\n// A compile time assertion to ensure that ChannelGraphBootstrapper meets the\n// NetworkPeerBootstrapper interface.\nvar _ NetworkPeerBootstrapper = (*ChannelGraphBootstrapper)(nil)\n\n// NewGraphBootstrapper returns a new instance of a ChannelGraphBootstrapper\n// backed by an active autopilot.ChannelGraph instance. This type of network\n// peer bootstrapper will use the authenticated nodes within the known channel\n// graph to bootstrap connections.",
      "length": 816,
      "tokens": 113,
      "embedding": []
    },
    {
      "slug": "func NewGraphBootstrapper(cg autopilot.ChannelGraph) (NetworkPeerBootstrapper, error) {",
      "content": "func NewGraphBootstrapper(cg autopilot.ChannelGraph) (NetworkPeerBootstrapper, error) {\n\n\tc := &ChannelGraphBootstrapper{\n\t\tchanGraph: cg,\n\t\ttried:     make(map[autopilot.NodeID]struct{}),\n\t}\n\n\tif _, err := rand.Read(c.hashAccumulator[:]); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn c, nil\n}\n\n// SampleNodeAddrs uniformly samples a set of specified address from the\n// network peer bootstrapper source. The num addrs field passed in denotes how\n// many valid peer addresses to return.\n//\n// NOTE: Part of the NetworkPeerBootstrapper interface.",
      "length": 438,
      "tokens": 64,
      "embedding": []
    },
    {
      "slug": "func (c *ChannelGraphBootstrapper) SampleNodeAddrs(numAddrs uint32,",
      "content": "func (c *ChannelGraphBootstrapper) SampleNodeAddrs(numAddrs uint32,\n\tignore map[autopilot.NodeID]struct{}) ([]*lnwire.NetAddress, error) {\n\n\t// We'll merge the ignore map with our currently selected map in order\n\t// to ensure we don't return any duplicate nodes.\n\tfor n := range ignore {\n\t\tlog.Tracef(\"Ignored node %x for bootstrapping\", n)\n\t\tc.tried[n] = struct{}{}\n\t}\n\n\t// In order to bootstrap, we'll iterate all the nodes in the channel\n\t// graph, accumulating nodes until either we go through all active\n\t// nodes, or we reach our limit. We ensure that we meet the randomly\n\t// sample constraint as we maintain an xor accumulator to ensure we\n\t// randomly sample nodes independent of the iteration of the channel\n\t// graph.\n\tsampleAddrs := func() ([]*lnwire.NetAddress, error) {\n\t\tvar (\n\t\t\ta []*lnwire.NetAddress\n\n\t\t\t// We'll create a special error so we can return early\n\t\t\t// and abort the transaction once we find a match.\n\t\t\terrFound = fmt.Errorf(\"found node\")\n\t\t)\n\n\t\terr := c.chanGraph.ForEachNode(func(node autopilot.Node) error {\n\t\t\tnID := autopilot.NodeID(node.PubKey())\n\t\t\tif _, ok := c.tried[nID]; ok {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// We'll select the first node we come across who's\n\t\t\t// public key is less than our current accumulator\n\t\t\t// value. When comparing, we skip the first byte as\n\t\t\t// it's 50/50. If it isn't less, than then we'll\n\t\t\t// continue forward.\n\t\t\tnodePubKeyBytes := node.PubKey()\n\t\t\tif bytes.Compare(c.hashAccumulator[:], nodePubKeyBytes[1:]) > 0 {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tfor _, nodeAddr := range node.Addrs() {\n\t\t\t\t// If we haven't yet reached our limit, then\n\t\t\t\t// we'll copy over the details of this node\n\t\t\t\t// into the set of addresses to be returned.\n\t\t\t\tswitch nodeAddr.(type) {\n\t\t\t\tcase *net.TCPAddr, *tor.OnionAddr:\n\t\t\t\tdefault:\n\t\t\t\t\t// If this isn't a valid address\n\t\t\t\t\t// supported by the protocol, then we'll\n\t\t\t\t\t// skip this node.\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\n\t\t\t\tnodePub, err := btcec.ParsePubKey(\n\t\t\t\t\tnodePubKeyBytes[:],\n\t\t\t\t)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\t// At this point, we've found an eligible node,\n\t\t\t\t// so we'll return early with our shibboleth\n\t\t\t\t// error.\n\t\t\t\ta = append(a, &lnwire.NetAddress{\n\t\t\t\t\tIdentityKey: nodePub,\n\t\t\t\t\tAddress:     nodeAddr,\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tc.tried[nID] = struct{}{}\n\n\t\t\treturn errFound\n\t\t})\n\t\tif err != nil && err != errFound {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn a, nil\n\t}\n\n\t// We'll loop and sample new addresses from the graph source until\n\t// we've reached our target number of outbound connections or we hit 50\n\t// attempts, which ever comes first.\n\tvar (\n\t\taddrs []*lnwire.NetAddress\n\t\ttries uint32\n\t)\n\tfor tries < 30 && uint32(len(addrs)) < numAddrs {\n\t\tsampleAddrs, err := sampleAddrs()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\ttries++\n\n\t\t// We'll now rotate our hash accumulator one value forwards.\n\t\tc.hashAccumulator = sha256.Sum256(c.hashAccumulator[:])\n\n\t\t// If this attempt didn't yield any addresses, then we'll exit\n\t\t// early.\n\t\tif len(sampleAddrs) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\taddrs = append(addrs, sampleAddrs...)\n\t}\n\n\tlog.Tracef(\"Ending hash accumulator state: %x\", c.hashAccumulator)\n\n\treturn addrs, nil\n}\n\n// Name returns a human readable string which names the concrete implementation\n// of the NetworkPeerBootstrapper.\n//\n// NOTE: Part of the NetworkPeerBootstrapper interface.",
      "length": 3118,
      "tokens": 476,
      "embedding": []
    },
    {
      "slug": "func (c *ChannelGraphBootstrapper) Name() string {",
      "content": "func (c *ChannelGraphBootstrapper) Name() string {\n\treturn \"Authenticated Channel Graph\"\n}\n\n// DNSSeedBootstrapper as an implementation of the NetworkPeerBootstrapper\n// interface which implements peer bootstrapping via a special DNS seed as\n// defined in BOLT-0010. For further details concerning Lightning's current DNS\n// boot strapping protocol, see this link:\n//   - https://github.com/lightningnetwork/lightning-rfc/blob/master/10-dns-bootstrap.md",
      "length": 395,
      "tokens": 46,
      "embedding": []
    },
    {
      "slug": "type DNSSeedBootstrapper struct {",
      "content": "type DNSSeedBootstrapper struct {\n\t// dnsSeeds is an array of two tuples we'll use for bootstrapping. The\n\t// first item in the tuple is the primary host we'll use to attempt the\n\t// SRV lookup we require. If we're unable to receive a response over\n\t// UDP, then we'll fall back to manual TCP resolution. The second item\n\t// in the tuple is a special A record that we'll query in order to\n\t// receive the IP address of the current authoritative DNS server for\n\t// the network seed.\n\tdnsSeeds [][2]string\n\tnet      tor.Net\n\n\t// timeout is the maximum amount of time a dial will wait for a connect to\n\t// complete.\n\ttimeout time.Duration\n}\n\n// A compile time assertion to ensure that DNSSeedBootstrapper meets the\n// NetworkPeerjBootstrapper interface.\nvar _ NetworkPeerBootstrapper = (*ChannelGraphBootstrapper)(nil)\n\n// NewDNSSeedBootstrapper returns a new instance of the DNSSeedBootstrapper.\n// The set of passed seeds should point to DNS servers that properly implement\n// Lightning's DNS peer bootstrapping protocol as defined in BOLT-0010. The set\n// of passed DNS seeds should come in pairs, with the second host name to be\n// used as a fallback for manual TCP resolution in the case of an error\n// receiving the UDP response. The second host should return a single A record\n// with the IP address of the authoritative name server.",
      "length": 1278,
      "tokens": 219,
      "embedding": []
    },
    {
      "slug": "func NewDNSSeedBootstrapper(",
      "content": "func NewDNSSeedBootstrapper(\n\tseeds [][2]string, net tor.Net,\n\ttimeout time.Duration) NetworkPeerBootstrapper {\n\n\treturn &DNSSeedBootstrapper{dnsSeeds: seeds, net: net, timeout: timeout}\n}\n\n// fallBackSRVLookup attempts to manually query for SRV records we need to\n// properly bootstrap. We do this by querying the special record at the \"soa.\"\n// sub-domain of supporting DNS servers. The returned IP address will be the IP\n// address of the authoritative DNS server. Once we have this IP address, we'll\n// connect manually over TCP to request the SRV record. This is necessary as\n// the records we return are currently too large for a class of resolvers,\n// causing them to be filtered out. The targetEndPoint is the original end\n// point that was meant to be hit.",
      "length": 723,
      "tokens": 119,
      "embedding": []
    },
    {
      "slug": "func (d *DNSSeedBootstrapper) fallBackSRVLookup(soaShim string,",
      "content": "func (d *DNSSeedBootstrapper) fallBackSRVLookup(soaShim string,\n\ttargetEndPoint string) ([]*net.SRV, error) {\n\n\tlog.Tracef(\"Attempting to query fallback DNS seed\")\n\n\t// First, we'll lookup the IP address of the server that will act as\n\t// our shim.\n\taddrs, err := d.net.LookupHost(soaShim)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Once we have the IP address, we'll establish a TCP connection using\n\t// port 53.\n\tdnsServer := net.JoinHostPort(addrs[0], \"53\")\n\tconn, err := d.net.Dial(\"tcp\", dnsServer, d.timeout)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdnsHost := fmt.Sprintf(\"_nodes._tcp.%v.\", targetEndPoint)\n\tdnsConn := &dns.Conn{Conn: conn}\n\tdefer dnsConn.Close()\n\n\t// With the connection established, we'll craft our SRV query, write\n\t// toe request, then wait for the server to give our response.\n\tmsg := new(dns.Msg)\n\tmsg.SetQuestion(dnsHost, dns.TypeSRV)\n\tif err := dnsConn.WriteMsg(msg); err != nil {\n\t\treturn nil, err\n\t}\n\tresp, err := dnsConn.ReadMsg()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// If the message response code was not the success code, fail.\n\tif resp.Rcode != dns.RcodeSuccess {\n\t\treturn nil, fmt.Errorf(\"unsuccessful SRV request, \"+\n\t\t\t\"received: %v\", resp.Rcode)\n\t}\n\n\t// Retrieve the RR(s) of the Answer section, and convert to the format\n\t// that net.LookupSRV would normally return.\n\tvar rrs []*net.SRV\n\tfor _, rr := range resp.Answer {\n\t\tsrv := rr.(*dns.SRV)\n\t\trrs = append(rrs, &net.SRV{\n\t\t\tTarget:   srv.Target,\n\t\t\tPort:     srv.Port,\n\t\t\tPriority: srv.Priority,\n\t\t\tWeight:   srv.Weight,\n\t\t})\n\t}\n\n\treturn rrs, nil\n}\n\n// SampleNodeAddrs uniformly samples a set of specified address from the\n// network peer bootstrapper source. The num addrs field passed in denotes how\n// many valid peer addresses to return. The set of DNS seeds are used\n// successively to retrieve eligible target nodes.",
      "length": 1698,
      "tokens": 261,
      "embedding": []
    },
    {
      "slug": "func (d *DNSSeedBootstrapper) SampleNodeAddrs(numAddrs uint32,",
      "content": "func (d *DNSSeedBootstrapper) SampleNodeAddrs(numAddrs uint32,\n\tignore map[autopilot.NodeID]struct{}) ([]*lnwire.NetAddress, error) {\n\n\tvar netAddrs []*lnwire.NetAddress\n\n\t// We'll try all the registered DNS seeds, exiting early if one of them\n\t// gives us all the peers we need.\n\t//\n\t// TODO(roasbeef): should combine results from both\nsearch:\n\tfor _, dnsSeedTuple := range d.dnsSeeds {\n\t\t// We'll first query the seed with an SRV record so we can\n\t\t// obtain a random sample of the encoded public keys of nodes.\n\t\t// We use the lndLookupSRV function for this task.\n\t\tprimarySeed := dnsSeedTuple[0]\n\t\t_, addrs, err := d.net.LookupSRV(\n\t\t\t\"nodes\", \"tcp\", primarySeed, d.timeout,\n\t\t)\n\t\tif err != nil {\n\t\t\tlog.Tracef(\"Unable to lookup SRV records via \"+\n\t\t\t\t\"primary seed (%v): %v\", primarySeed, err)\n\n\t\t\tlog.Trace(\"Falling back to secondary\")\n\n\t\t\t// If the host of the secondary seed is blank, then\n\t\t\t// we'll bail here as we can't proceed.\n\t\t\tif dnsSeedTuple[1] == \"\" {\n\t\t\t\tlog.Tracef(\"DNS seed %v has no secondary, \"+\n\t\t\t\t\t\"skipping fallback\", primarySeed)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// If we get an error when trying to query via the\n\t\t\t// primary seed, we'll fallback to the secondary seed\n\t\t\t// before concluding failure.\n\t\t\tsoaShim := dnsSeedTuple[1]\n\t\t\taddrs, err = d.fallBackSRVLookup(\n\t\t\t\tsoaShim, primarySeed,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tlog.Tracef(\"Unable to query fall \"+\n\t\t\t\t\t\"back dns seed (%v): %v\", soaShim, err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tlog.Tracef(\"Successfully queried fallback DNS seed\")\n\t\t}\n\n\t\tlog.Tracef(\"Retrieved SRV records from dns seed: %v\",\n\t\t\tnewLogClosure(func() string {\n\t\t\t\treturn spew.Sdump(addrs)\n\t\t\t}),\n\t\t)\n\n\t\t// Next, we'll need to issue an A record request for each of\n\t\t// the nodes, skipping it if nothing comes back.\n\t\tfor _, nodeSrv := range addrs {\n\t\t\tif uint32(len(netAddrs)) >= numAddrs {\n\t\t\t\tbreak search\n\t\t\t}\n\n\t\t\t// With the SRV target obtained, we'll now perform\n\t\t\t// another query to obtain the IP address for the\n\t\t\t// matching bech32 encoded node key. We use the\n\t\t\t// lndLookup function for this task.\n\t\t\tbechNodeHost := nodeSrv.Target\n\t\t\taddrs, err := d.net.LookupHost(bechNodeHost)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tif len(addrs) == 0 {\n\t\t\t\tlog.Tracef(\"No addresses for %v, skipping\",\n\t\t\t\t\tbechNodeHost)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tlog.Tracef(\"Attempting to convert: %v\", bechNodeHost)\n\n\t\t\t// If the host isn't correctly formatted, then we'll\n\t\t\t// skip it.\n\t\t\tif len(bechNodeHost) == 0 ||\n\t\t\t\t!strings.Contains(bechNodeHost, \".\") {\n\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// If we have a set of valid addresses, then we'll need\n\t\t\t// to parse the public key from the original bech32\n\t\t\t// encoded string.\n\t\t\tbechNode := strings.Split(bechNodeHost, \".\")\n\t\t\t_, nodeBytes5Bits, err := bech32.Decode(bechNode[0])\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\t// Once we have the bech32 decoded pubkey, we'll need\n\t\t\t// to convert the 5-bit word grouping into our regular\n\t\t\t// 8-bit word grouping so we can convert it into a\n\t\t\t// public key.\n\t\t\tnodeBytes, err := bech32.ConvertBits(\n\t\t\t\tnodeBytes5Bits, 5, 8, false,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tnodeKey, err := btcec.ParsePubKey(nodeBytes)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\t// If we have an ignore list, and this node is in the\n\t\t\t// ignore list, then we'll go to the next candidate.\n\t\t\tif ignore != nil {\n\t\t\t\tnID := autopilot.NewNodeID(nodeKey)\n\t\t\t\tif _, ok := ignore[nID]; ok {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Finally we'll convert the host:port peer to a proper\n\t\t\t// TCP address to use within the lnwire.NetAddress. We\n\t\t\t// don't need to use the lndResolveTCP function here\n\t\t\t// because we already have the host:port peer.\n\t\t\taddr := net.JoinHostPort(\n\t\t\t\taddrs[0],\n\t\t\t\tstrconv.FormatUint(uint64(nodeSrv.Port), 10),\n\t\t\t)\n\t\t\ttcpAddr, err := net.ResolveTCPAddr(\"tcp\", addr)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\t// Finally, with all the information parsed, we'll\n\t\t\t// return this fully valid address as a connection\n\t\t\t// attempt.\n\t\t\tlnAddr := &lnwire.NetAddress{\n\t\t\t\tIdentityKey: nodeKey,\n\t\t\t\tAddress:     tcpAddr,\n\t\t\t}\n\n\t\t\tlog.Tracef(\"Obtained %v as valid reachable \"+\n\t\t\t\t\"node\", lnAddr)\n\n\t\t\tnetAddrs = append(netAddrs, lnAddr)\n\t\t}\n\t}\n\n\treturn netAddrs, nil\n}\n\n// Name returns a human readable string which names the concrete\n// implementation of the NetworkPeerBootstrapper.",
      "length": 4102,
      "tokens": 619,
      "embedding": []
    },
    {
      "slug": "func (d *DNSSeedBootstrapper) Name() string {",
      "content": "func (d *DNSSeedBootstrapper) Name() string {\n\treturn fmt.Sprintf(\"BOLT-0010 DNS Seed: %v\", d.dnsSeeds)\n}\n",
      "length": 58,
      "tokens": 7,
      "embedding": []
    }
  ]
}