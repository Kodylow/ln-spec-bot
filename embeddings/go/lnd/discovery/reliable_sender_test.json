{
  "filepath": "../implementations/go/lnd/discovery/reliable_sender_test.go",
  "package": "discovery",
  "sections": [
    {
      "slug": "func newTestReliableSender(t *testing.T) *reliableSender {",
      "content": "func newTestReliableSender(t *testing.T) *reliableSender {\n\tt.Helper()\n\n\tcfg := &reliableSenderCfg{\n\t\tNotifyWhenOnline: func(pubKey [33]byte,\n\t\t\tpeerChan chan<- lnpeer.Peer) {\n\t\t\tpk, err := btcec.ParsePubKey(pubKey[:])\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to parse pubkey: %v\", err)\n\t\t\t}\n\t\t\tpeerChan <- &mockPeer{pk: pk}\n\t\t},\n\t\tNotifyWhenOffline: func(_ [33]byte) <-chan struct{} {\n\t\t\tc := make(chan struct{}, 1)\n\t\t\treturn c\n\t\t},\n\t\tMessageStore: newMockMessageStore(),\n\t\tIsMsgStale: func(lnwire.Message) bool {\n\t\t\treturn false\n\t\t},\n\t}\n\n\treturn newReliableSender(cfg)\n}\n\n// assertMsgsSent ensures that the given messages can be read from a mock peer's\n// msgChan.",
      "length": 581,
      "tokens": 75,
      "embedding": []
    },
    {
      "slug": "func assertMsgsSent(t *testing.T, msgChan chan lnwire.Message,",
      "content": "func assertMsgsSent(t *testing.T, msgChan chan lnwire.Message,\n\tmsgs ...lnwire.Message) {\n\n\tt.Helper()\n\n\tm := make(map[lnwire.Message]struct{}, len(msgs))\n\tfor _, msg := range msgs {\n\t\tm[msg] = struct{}{}\n\t}\n\n\tfor i := 0; i < len(msgs); i++ {\n\t\tselect {\n\t\tcase msg := <-msgChan:\n\t\t\tif _, ok := m[msg]; !ok {\n\t\t\t\tt.Fatalf(\"found unexpected message sent: %v\",\n\t\t\t\t\tspew.Sdump(msg))\n\t\t\t}\n\t\tcase <-time.After(time.Second):\n\t\t\tt.Fatal(\"reliable sender did not send message to peer\")\n\t\t}\n\t}\n}\n\n// TestReliableSenderFlow ensures that the flow for sending messages reliably to\n// a peer while taking into account its connection lifecycle works as expected.",
      "length": 562,
      "tokens": 85,
      "embedding": []
    },
    {
      "slug": "func TestReliableSenderFlow(t *testing.T) {",
      "content": "func TestReliableSenderFlow(t *testing.T) {\n\tt.Parallel()\n\n\treliableSender := newTestReliableSender(t)\n\n\t// Create a mock peer to send the messages to.\n\tpubKey := randPubKey(t)\n\tmsgsSent := make(chan lnwire.Message)\n\tpeer := &mockPeer{pubKey, msgsSent, reliableSender.quit}\n\n\t// Override NotifyWhenOnline and NotifyWhenOffline to provide the\n\t// notification channels so that we can control when notifications get\n\t// dispatched.\n\tnotifyOnline := make(chan chan<- lnpeer.Peer, 2)\n\tnotifyOffline := make(chan chan struct{}, 1)\n\n\treliableSender.cfg.NotifyWhenOnline = func(_ [33]byte,\n\t\tpeerChan chan<- lnpeer.Peer) {\n\t\tnotifyOnline <- peerChan\n\t}\n\treliableSender.cfg.NotifyWhenOffline = func(_ [33]byte) <-chan struct{} {\n\t\tc := make(chan struct{}, 1)\n\t\tnotifyOffline <- c\n\t\treturn c\n\t}\n\n\t// We'll start by creating our first message which we should reliably\n\t// send to our peer.\n\tmsg1 := randChannelUpdate()\n\tvar peerPubKey [33]byte\n\tcopy(peerPubKey[:], pubKey.SerializeCompressed())\n\tif err := reliableSender.sendMessage(msg1, peerPubKey); err != nil {\n\t\tt.Fatalf(\"unable to reliably send message: %v\", err)\n\t}\n\n\t// Since there isn't a peerHandler for this peer currently active due to\n\t// this being the first message being sent reliably, we should expect to\n\t// see a notification request for when the peer is online.\n\tvar peerChan chan<- lnpeer.Peer\n\tselect {\n\tcase peerChan = <-notifyOnline:\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"reliable sender did not request online notification\")\n\t}\n\n\t// We'll then attempt to send another additional message reliably.\n\tmsg2 := randAnnounceSignatures()\n\tif err := reliableSender.sendMessage(msg2, peerPubKey); err != nil {\n\t\tt.Fatalf(\"unable to reliably send message: %v\", err)\n\t}\n\n\t// This should not however request another peer online notification as\n\t// the peerHandler has already been started and is waiting for the\n\t// notification to be dispatched.\n\tselect {\n\tcase <-notifyOnline:\n\t\tt.Fatal(\"reliable sender should not request online notification\")\n\tcase <-time.After(time.Second):\n\t}\n\n\t// We'll go ahead and notify the peer.\n\tpeerChan <- peer\n\n\t// By doing so, we should expect to see a notification request for when\n\t// the peer is offline.\n\tvar offlineChan chan struct{}\n\tselect {\n\tcase offlineChan = <-notifyOffline:\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"reliable sender did not request offline notification\")\n\t}\n\n\t// We should also see the messages arrive at the peer since they are now\n\t// seen as online.\n\tassertMsgsSent(t, peer.sentMsgs, msg1, msg2)\n\n\t// Then, we'll send one more message reliably.\n\tmsg3 := randChannelUpdate()\n\tif err := reliableSender.sendMessage(msg3, peerPubKey); err != nil {\n\t\tt.Fatalf(\"unable to reliably send message: %v\", err)\n\t}\n\n\t// Again, this should not request another peer online notification\n\t// request since we are currently waiting for the peer to be offline.\n\tselect {\n\tcase <-notifyOnline:\n\t\tt.Fatal(\"reliable sender should not request online notification\")\n\tcase <-time.After(time.Second):\n\t}\n\n\t// The expected message should be sent to the peer.\n\tassertMsgsSent(t, peer.sentMsgs, msg3)\n\n\t// We'll then notify that the peer is offline.\n\tclose(offlineChan)\n\n\t// This should cause an online notification to be requested.\n\tselect {\n\tcase peerChan = <-notifyOnline:\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"reliable sender did not request online notification\")\n\t}\n\n\t// Once we dispatch it, we should expect to see the messages be resent\n\t// to the peer as they are not stale.\n\tpeerChan <- peer\n\n\tselect {\n\tcase <-notifyOffline:\n\tcase <-time.After(5 * time.Second):\n\t\tt.Fatal(\"reliable sender did not request offline notification\")\n\t}\n\n\tassertMsgsSent(t, peer.sentMsgs, msg1, msg2, msg3)\n}\n\n// TestReliableSenderStaleMessages ensures that the reliable sender is no longer\n// active for a peer which has successfully sent all of its messages and deemed\n// them as stale.",
      "length": 3716,
      "tokens": 524,
      "embedding": []
    },
    {
      "slug": "func TestReliableSenderStaleMessages(t *testing.T) {",
      "content": "func TestReliableSenderStaleMessages(t *testing.T) {\n\tt.Parallel()\n\n\treliableSender := newTestReliableSender(t)\n\n\t// Create a mock peer to send the messages to.\n\tpubKey := randPubKey(t)\n\tmsgsSent := make(chan lnwire.Message)\n\tpeer := &mockPeer{pubKey, msgsSent, reliableSender.quit}\n\n\t// Override NotifyWhenOnline to provide the notification channel so that\n\t// we can control when notifications get dispatched.\n\tnotifyOnline := make(chan chan<- lnpeer.Peer, 1)\n\treliableSender.cfg.NotifyWhenOnline = func(_ [33]byte,\n\t\tpeerChan chan<- lnpeer.Peer) {\n\t\tnotifyOnline <- peerChan\n\t}\n\n\t// We'll also override IsMsgStale to mark all messages as stale as we're\n\t// interested in testing the stale message behavior.\n\treliableSender.cfg.IsMsgStale = func(_ lnwire.Message) bool {\n\t\treturn true\n\t}\n\n\t// We'll start by creating our first message which we should reliably\n\t// send to our peer, but will be seen as stale.\n\tmsg1 := randAnnounceSignatures()\n\tvar peerPubKey [33]byte\n\tcopy(peerPubKey[:], pubKey.SerializeCompressed())\n\tif err := reliableSender.sendMessage(msg1, peerPubKey); err != nil {\n\t\tt.Fatalf(\"unable to reliably send message: %v\", err)\n\t}\n\n\t// Since there isn't a peerHandler for this peer currently active due to\n\t// this being the first message being sent reliably, we should expect to\n\t// see a notification request for when the peer is online.\n\tvar peerChan chan<- lnpeer.Peer\n\tselect {\n\tcase peerChan = <-notifyOnline:\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"reliable sender did not request online notification\")\n\t}\n\n\t// We'll go ahead and notify the peer.\n\tpeerChan <- peer\n\n\t// This should cause the message to be sent to the peer since they are\n\t// now seen as online. The message will be sent at least once to ensure\n\t// they can propagate before deciding whether they are stale or not.\n\tassertMsgsSent(t, peer.sentMsgs, msg1)\n\n\t// We'll create another message which we'll send reliably. This one\n\t// won't be seen as stale.\n\tmsg2 := randChannelUpdate()\n\n\t// We'll then wait for the message to be removed from the backing\n\t// message store since it is seen as stale and has been sent at least\n\t// once. Once the message is removed, the peerHandler should be torn\n\t// down as there are no longer any pending messages within the store.\n\terr := wait.NoError(func() error {\n\t\tmsgs, err := reliableSender.cfg.MessageStore.MessagesForPeer(\n\t\t\tpeerPubKey,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to retrieve messages for \"+\n\t\t\t\t\"peer: %v\", err)\n\t\t}\n\t\tif len(msgs) != 0 {\n\t\t\treturn fmt.Errorf(\"expected to not find any \"+\n\t\t\t\t\"messages for peer, found %d\", len(msgs))\n\t\t}\n\n\t\treturn nil\n\t}, time.Second)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Override IsMsgStale to no longer mark messages as stale.\n\treliableSender.cfg.IsMsgStale = func(_ lnwire.Message) bool {\n\t\treturn false\n\t}\n\n\t// We'll request the message to be sent reliably.\n\tif err := reliableSender.sendMessage(msg2, peerPubKey); err != nil {\n\t\tt.Fatalf(\"unable to reliably send message: %v\", err)\n\t}\n\n\t// We should see an online notification request indicating that a new\n\t// peerHandler has been spawned since it was previously torn down.\n\tselect {\n\tcase peerChan = <-notifyOnline:\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"reliable sender did not request online notification\")\n\t}\n\n\t// Finally, notifying the peer is online should prompt the message to be\n\t// sent. Only the ChannelUpdate will be sent in this case since the\n\t// AnnounceSignatures message above was seen as stale.\n\tpeerChan <- peer\n\n\tassertMsgsSent(t, peer.sentMsgs, msg2)\n}\n",
      "length": 3377,
      "tokens": 508,
      "embedding": []
    }
  ]
}