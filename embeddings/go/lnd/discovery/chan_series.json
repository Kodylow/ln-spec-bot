{
  "filepath": "../implementations/go/lnd/discovery/chan_series.go",
  "package": "discovery",
  "sections": [
    {
      "slug": "type ChannelGraphTimeSeries interface {",
      "content": "type ChannelGraphTimeSeries interface {\n\t// HighestChanID should return the channel ID of the channel we know of\n\t// that's furthest in the target chain. This channel will have a block\n\t// height that's close to the current tip of the main chain as we\n\t// know it.  We'll use this to start our QueryChannelRange dance with\n\t// the remote node.\n\tHighestChanID(chain chainhash.Hash) (*lnwire.ShortChannelID, error)\n\n\t// UpdatesInHorizon returns all known channel and node updates with an\n\t// update timestamp between the start time and end time. We'll use this\n\t// to catch up a remote node to the set of channel updates that they\n\t// may have missed out on within the target chain.\n\tUpdatesInHorizon(chain chainhash.Hash,\n\t\tstartTime time.Time, endTime time.Time) ([]lnwire.Message, error)\n\n\t// FilterKnownChanIDs takes a target chain, and a set of channel ID's,\n\t// and returns a filtered set of chan ID's. This filtered set of chan\n\t// ID's represents the ID's that we don't know of which were in the\n\t// passed superSet.\n\tFilterKnownChanIDs(chain chainhash.Hash,\n\t\tsuperSet []lnwire.ShortChannelID) ([]lnwire.ShortChannelID, error)\n\n\t// FilterChannelRange returns the set of channels that we created\n\t// between the start height and the end height. The channel IDs are\n\t// grouped by their common block height. We'll use this to to a remote\n\t// peer's QueryChannelRange message.\n\tFilterChannelRange(chain chainhash.Hash,\n\t\tstartHeight, endHeight uint32) ([]channeldb.BlockChannelRange, error)\n\n\t// FetchChanAnns returns a full set of channel announcements as well as\n\t// their updates that match the set of specified short channel ID's.\n\t// We'll use this to reply to a QueryShortChanIDs message sent by a\n\t// remote peer. The response will contain a unique set of\n\t// ChannelAnnouncements, the latest ChannelUpdate for each of the\n\t// announcements, and a unique set of NodeAnnouncements.\n\tFetchChanAnns(chain chainhash.Hash,\n\t\tshortChanIDs []lnwire.ShortChannelID) ([]lnwire.Message, error)\n\n\t// FetchChanUpdates returns the latest channel update messages for the\n\t// specified short channel ID. If no channel updates are known for the\n\t// channel, then an empty slice will be returned.\n\tFetchChanUpdates(chain chainhash.Hash,\n\t\tshortChanID lnwire.ShortChannelID) ([]*lnwire.ChannelUpdate, error)\n}\n\n// ChanSeries is an implementation of the ChannelGraphTimeSeries\n// interface backed by the channeldb ChannelGraph database. We'll provide this\n// implementation to the AuthenticatedGossiper so it can properly use the\n// in-protocol channel range queries to quickly and efficiently synchronize our\n// channel state with all peers.",
      "length": 2546,
      "tokens": 371,
      "embedding": []
    },
    {
      "slug": "type ChanSeries struct {",
      "content": "type ChanSeries struct {\n\tgraph *channeldb.ChannelGraph\n}\n\n// NewChanSeries constructs a new ChanSeries backed by a channeldb.ChannelGraph.\n// The returned ChanSeries implements the ChannelGraphTimeSeries interface.",
      "length": 186,
      "tokens": 21,
      "embedding": []
    },
    {
      "slug": "func NewChanSeries(graph *channeldb.ChannelGraph) *ChanSeries {",
      "content": "func NewChanSeries(graph *channeldb.ChannelGraph) *ChanSeries {\n\treturn &ChanSeries{\n\t\tgraph: graph,\n\t}\n}\n\n// HighestChanID should return is the channel ID of the channel we know of\n// that's furthest in the target chain. This channel will have a block height\n// that's close to the current tip of the main chain as we know it.  We'll use\n// this to start our QueryChannelRange dance with the remote node.\n//\n// NOTE: This is part of the ChannelGraphTimeSeries interface.",
      "length": 397,
      "tokens": 72,
      "embedding": []
    },
    {
      "slug": "func (c *ChanSeries) HighestChanID(chain chainhash.Hash) (*lnwire.ShortChannelID, error) {",
      "content": "func (c *ChanSeries) HighestChanID(chain chainhash.Hash) (*lnwire.ShortChannelID, error) {\n\tchanID, err := c.graph.HighestChanID()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tshortChanID := lnwire.NewShortChanIDFromInt(chanID)\n\treturn &shortChanID, nil\n}\n\n// UpdatesInHorizon returns all known channel and node updates with an update\n// timestamp between the start time and end time. We'll use this to catch up a\n// remote node to the set of channel updates that they may have missed out on\n// within the target chain.\n//\n// NOTE: This is part of the ChannelGraphTimeSeries interface.",
      "length": 475,
      "tokens": 79,
      "embedding": []
    },
    {
      "slug": "func (c *ChanSeries) UpdatesInHorizon(chain chainhash.Hash,",
      "content": "func (c *ChanSeries) UpdatesInHorizon(chain chainhash.Hash,\n\tstartTime time.Time, endTime time.Time) ([]lnwire.Message, error) {\n\n\tvar updates []lnwire.Message\n\n\t// First, we'll query for all the set of channels that have an update\n\t// that falls within the specified horizon.\n\tchansInHorizon, err := c.graph.ChanUpdatesInHorizon(\n\t\tstartTime, endTime,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor _, channel := range chansInHorizon {\n\t\t// If the channel hasn't been fully advertised yet, or is a\n\t\t// private channel, then we'll skip it as we can't construct a\n\t\t// full authentication proof if one is requested.\n\t\tif channel.Info.AuthProof == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tchanAnn, edge1, edge2, err := netann.CreateChanAnnouncement(\n\t\t\tchannel.Info.AuthProof, channel.Info, channel.Policy1,\n\t\t\tchannel.Policy2,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tupdates = append(updates, chanAnn)\n\t\tif edge1 != nil {\n\t\t\t// We don't want to send channel updates that don't\n\t\t\t// conform to the spec (anymore).\n\t\t\terr := routing.ValidateChannelUpdateFields(0, edge1)\n\t\t\tif err != nil {\n\t\t\t\tlog.Errorf(\"not sending invalid channel \"+\n\t\t\t\t\t\"update %v: %v\", edge1, err)\n\t\t\t} else {\n\t\t\t\tupdates = append(updates, edge1)\n\t\t\t}\n\t\t}\n\t\tif edge2 != nil {\n\t\t\terr := routing.ValidateChannelUpdateFields(0, edge2)\n\t\t\tif err != nil {\n\t\t\t\tlog.Errorf(\"not sending invalid channel \"+\n\t\t\t\t\t\"update %v: %v\", edge2, err)\n\t\t\t} else {\n\t\t\t\tupdates = append(updates, edge2)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Next, we'll send out all the node announcements that have an update\n\t// within the horizon as well. We send these second to ensure that they\n\t// follow any active channels they have.\n\tnodeAnnsInHorizon, err := c.graph.NodeUpdatesInHorizon(\n\t\tstartTime, endTime,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor _, nodeAnn := range nodeAnnsInHorizon {\n\t\t// Ensure we only forward nodes that are publicly advertised to\n\t\t// prevent leaking information about nodes.\n\t\tisNodePublic, err := c.graph.IsPublicNode(nodeAnn.PubKeyBytes)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Unable to determine if node %x is \"+\n\t\t\t\t\"advertised: %v\", nodeAnn.PubKeyBytes, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !isNodePublic {\n\t\t\tlog.Tracef(\"Skipping forwarding announcement for \"+\n\t\t\t\t\"node %x due to being unadvertised\",\n\t\t\t\tnodeAnn.PubKeyBytes)\n\t\t\tcontinue\n\t\t}\n\n\t\tnodeUpdate, err := nodeAnn.NodeAnnouncement(true)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tupdates = append(updates, nodeUpdate)\n\t}\n\n\treturn updates, nil\n}\n\n// FilterKnownChanIDs takes a target chain, and a set of channel ID's, and\n// returns a filtered set of chan ID's. This filtered set of chan ID's\n// represents the ID's that we don't know of which were in the passed superSet.\n//\n// NOTE: This is part of the ChannelGraphTimeSeries interface.",
      "length": 2581,
      "tokens": 388,
      "embedding": []
    },
    {
      "slug": "func (c *ChanSeries) FilterKnownChanIDs(chain chainhash.Hash,",
      "content": "func (c *ChanSeries) FilterKnownChanIDs(chain chainhash.Hash,\n\tsuperSet []lnwire.ShortChannelID) ([]lnwire.ShortChannelID, error) {\n\n\tchanIDs := make([]uint64, 0, len(superSet))\n\tfor _, chanID := range superSet {\n\t\tchanIDs = append(chanIDs, chanID.ToUint64())\n\t}\n\n\tnewChanIDs, err := c.graph.FilterKnownChanIDs(chanIDs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfilteredIDs := make([]lnwire.ShortChannelID, 0, len(newChanIDs))\n\tfor _, chanID := range newChanIDs {\n\t\tfilteredIDs = append(\n\t\t\tfilteredIDs, lnwire.NewShortChanIDFromInt(chanID),\n\t\t)\n\t}\n\n\treturn filteredIDs, nil\n}\n\n// FilterChannelRange returns the set of channels that we created between the\n// start height and the end height. The channel IDs are grouped by their common\n// block height. We'll use this respond to a remote peer's QueryChannelRange\n// message.\n//\n// NOTE: This is part of the ChannelGraphTimeSeries interface.",
      "length": 799,
      "tokens": 109,
      "embedding": []
    },
    {
      "slug": "func (c *ChanSeries) FilterChannelRange(chain chainhash.Hash,",
      "content": "func (c *ChanSeries) FilterChannelRange(chain chainhash.Hash,\n\tstartHeight, endHeight uint32) ([]channeldb.BlockChannelRange, error) {\n\n\treturn c.graph.FilterChannelRange(startHeight, endHeight)\n}\n\n// FetchChanAnns returns a full set of channel announcements as well as their\n// updates that match the set of specified short channel ID's.  We'll use this\n// to reply to a QueryShortChanIDs message sent by a remote peer. The response\n// will contain a unique set of ChannelAnnouncements, the latest ChannelUpdate\n// for each of the announcements, and a unique set of NodeAnnouncements.\n//\n// NOTE: This is part of the ChannelGraphTimeSeries interface.",
      "length": 578,
      "tokens": 84,
      "embedding": []
    },
    {
      "slug": "func (c *ChanSeries) FetchChanAnns(chain chainhash.Hash,",
      "content": "func (c *ChanSeries) FetchChanAnns(chain chainhash.Hash,\n\tshortChanIDs []lnwire.ShortChannelID) ([]lnwire.Message, error) {\n\n\tchanIDs := make([]uint64, 0, len(shortChanIDs))\n\tfor _, chanID := range shortChanIDs {\n\t\tchanIDs = append(chanIDs, chanID.ToUint64())\n\t}\n\n\tchannels, err := c.graph.FetchChanInfos(chanIDs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// We'll use this map to ensure we don't send the same node\n\t// announcement more than one time as one node may have many channel\n\t// anns we'll need to send.\n\tnodePubsSent := make(map[route.Vertex]struct{})\n\n\tchanAnns := make([]lnwire.Message, 0, len(channels)*3)\n\tfor _, channel := range channels {\n\t\t// If the channel doesn't have an authentication proof, then we\n\t\t// won't send it over as it may not yet be finalized, or be a\n\t\t// non-advertised channel.\n\t\tif channel.Info.AuthProof == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tchanAnn, edge1, edge2, err := netann.CreateChanAnnouncement(\n\t\t\tchannel.Info.AuthProof, channel.Info, channel.Policy1,\n\t\t\tchannel.Policy2,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tchanAnns = append(chanAnns, chanAnn)\n\t\tif edge1 != nil {\n\t\t\tchanAnns = append(chanAnns, edge1)\n\n\t\t\t// If this edge has a validated node announcement, that\n\t\t\t// we haven't yet sent, then we'll send that as well.\n\t\t\tnodePub := channel.Policy1.Node.PubKeyBytes\n\t\t\thasNodeAnn := channel.Policy1.Node.HaveNodeAnnouncement\n\t\t\tif _, ok := nodePubsSent[nodePub]; !ok && hasNodeAnn {\n\t\t\t\tnodeAnn, err := channel.Policy1.Node.NodeAnnouncement(true)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\tchanAnns = append(chanAnns, nodeAnn)\n\t\t\t\tnodePubsSent[nodePub] = struct{}{}\n\t\t\t}\n\t\t}\n\t\tif edge2 != nil {\n\t\t\tchanAnns = append(chanAnns, edge2)\n\n\t\t\t// If this edge has a validated node announcement, that\n\t\t\t// we haven't yet sent, then we'll send that as well.\n\t\t\tnodePub := channel.Policy2.Node.PubKeyBytes\n\t\t\thasNodeAnn := channel.Policy2.Node.HaveNodeAnnouncement\n\t\t\tif _, ok := nodePubsSent[nodePub]; !ok && hasNodeAnn {\n\t\t\t\tnodeAnn, err := channel.Policy2.Node.NodeAnnouncement(true)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\tchanAnns = append(chanAnns, nodeAnn)\n\t\t\t\tnodePubsSent[nodePub] = struct{}{}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn chanAnns, nil\n}\n\n// FetchChanUpdates returns the latest channel update messages for the\n// specified short channel ID. If no channel updates are known for the channel,\n// then an empty slice will be returned.\n//\n// NOTE: This is part of the ChannelGraphTimeSeries interface.",
      "length": 2325,
      "tokens": 323,
      "embedding": []
    },
    {
      "slug": "func (c *ChanSeries) FetchChanUpdates(chain chainhash.Hash,",
      "content": "func (c *ChanSeries) FetchChanUpdates(chain chainhash.Hash,\n\tshortChanID lnwire.ShortChannelID) ([]*lnwire.ChannelUpdate, error) {\n\n\tchanInfo, e1, e2, err := c.graph.FetchChannelEdgesByID(\n\t\tshortChanID.ToUint64(),\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tchanUpdates := make([]*lnwire.ChannelUpdate, 0, 2)\n\tif e1 != nil {\n\t\tchanUpdate, err := netann.ChannelUpdateFromEdge(chanInfo, e1)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tchanUpdates = append(chanUpdates, chanUpdate)\n\t}\n\tif e2 != nil {\n\t\tchanUpdate, err := netann.ChannelUpdateFromEdge(chanInfo, e2)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tchanUpdates = append(chanUpdates, chanUpdate)\n\t}\n\n\treturn chanUpdates, nil\n}\n\n// A compile-time assertion to ensure that ChanSeries meets the\n// ChannelGraphTimeSeries interface.\nvar _ ChannelGraphTimeSeries = (*ChanSeries)(nil)\n",
      "length": 742,
      "tokens": 97,
      "embedding": []
    }
  ]
}