{
  "filepath": "../implementations/go/lnd/keychain/btcwallet.go",
  "package": "keychain",
  "sections": [
    {
      "slug": "type BtcWalletKeyRing struct {",
      "content": "type BtcWalletKeyRing struct {\n\t// wallet is a pointer to the active instance of the btcwallet core.\n\t// This is required as we'll need to manually open database\n\t// transactions in order to derive addresses and lookup relevant keys\n\twallet *wallet.Wallet\n\n\t// chainKeyScope defines the purpose and coin type to be used when generating\n\t// keys for this keyring.\n\tchainKeyScope waddrmgr.KeyScope\n\n\t// lightningScope is a pointer to the scope that we'll be using as a\n\t// sub key manager to derive all the keys that we require.\n\tlightningScope *waddrmgr.ScopedKeyManager\n}\n\n// NewBtcWalletKeyRing creates a new implementation of the\n// keychain.SecretKeyRing interface backed by btcwallet.\n//\n// NOTE: The passed waddrmgr.Manager MUST be unlocked in order for the keychain\n// to function.",
      "length": 738,
      "tokens": 117,
      "embedding": []
    },
    {
      "slug": "func NewBtcWalletKeyRing(w *wallet.Wallet, coinType uint32) SecretKeyRing {",
      "content": "func NewBtcWalletKeyRing(w *wallet.Wallet, coinType uint32) SecretKeyRing {\n\t// Construct the key scope that will be used within the waddrmgr to\n\t// create an HD chain for deriving all of our required keys. A different\n\t// scope is used for each specific coin type.\n\tchainKeyScope := waddrmgr.KeyScope{\n\t\tPurpose: BIP0043Purpose,\n\t\tCoin:    coinType,\n\t}\n\n\treturn &BtcWalletKeyRing{\n\t\twallet:        w,\n\t\tchainKeyScope: chainKeyScope,\n\t}\n}\n\n// keyScope attempts to return the key scope that we'll use to derive all of\n// our keys. If the scope has already been fetched from the database, then a\n// cached version will be returned. Otherwise, we'll fetch it from the database\n// and cache it for subsequent accesses.",
      "length": 621,
      "tokens": 102,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWalletKeyRing) keyScope() (*waddrmgr.ScopedKeyManager, error) {",
      "content": "func (b *BtcWalletKeyRing) keyScope() (*waddrmgr.ScopedKeyManager, error) {\n\t// If the scope has already been populated, then we'll return it\n\t// directly.\n\tif b.lightningScope != nil {\n\t\treturn b.lightningScope, nil\n\t}\n\n\t// Otherwise, we'll first do a check to ensure that the root manager\n\t// isn't locked, as otherwise we won't be able to *use* the scope.\n\tif !b.wallet.Manager.WatchOnly() && b.wallet.Manager.IsLocked() {\n\t\treturn nil, fmt.Errorf(\"cannot create BtcWalletKeyRing with \" +\n\t\t\t\"locked waddrmgr.Manager\")\n\t}\n\n\t// If the manager is indeed unlocked, then we'll fetch the scope, cache\n\t// it, and return to the caller.\n\tlnScope, err := b.wallet.Manager.FetchScopedKeyManager(b.chainKeyScope)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tb.lightningScope = lnScope\n\n\treturn lnScope, nil\n}\n\n// createAccountIfNotExists will create the corresponding account for a key\n// family if it doesn't already exist in the database.",
      "length": 826,
      "tokens": 125,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWalletKeyRing) createAccountIfNotExists(",
      "content": "func (b *BtcWalletKeyRing) createAccountIfNotExists(\n\taddrmgrNs walletdb.ReadWriteBucket, keyFam KeyFamily,\n\tscope *waddrmgr.ScopedKeyManager) error {\n\n\t// If this is the multi-sig key family, then we can return early as\n\t// this is the default account that's created.\n\tif keyFam == KeyFamilyMultiSig {\n\t\treturn nil\n\t}\n\n\t// Otherwise, we'll check if the account already exists, if so, we can\n\t// once again bail early.\n\t_, err := scope.AccountName(addrmgrNs, uint32(keyFam))\n\tif err == nil {\n\t\treturn nil\n\t}\n\n\t// If we reach this point, then the account hasn't yet been created, so\n\t// we'll need to create it before we can proceed.\n\treturn scope.NewRawAccount(addrmgrNs, uint32(keyFam))\n}\n\n// DeriveNextKey attempts to derive the *next* key within the key family\n// (account in BIP43) specified. This method should return the next external\n// child within this branch.\n//\n// NOTE: This is part of the keychain.KeyRing interface.",
      "length": 851,
      "tokens": 136,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWalletKeyRing) DeriveNextKey(keyFam KeyFamily) (KeyDescriptor, error) {",
      "content": "func (b *BtcWalletKeyRing) DeriveNextKey(keyFam KeyFamily) (KeyDescriptor, error) {\n\tvar (\n\t\tpubKey *btcec.PublicKey\n\t\tkeyLoc KeyLocator\n\t)\n\n\tdb := b.wallet.Database()\n\terr := walletdb.Update(db, func(tx walletdb.ReadWriteTx) error {\n\t\taddrmgrNs := tx.ReadWriteBucket(waddrmgrNamespaceKey)\n\n\t\tscope, err := b.keyScope()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// If the account doesn't exist, then we may need to create it\n\t\t// for the first time in order to derive the keys that we\n\t\t// require.\n\t\terr = b.createAccountIfNotExists(addrmgrNs, keyFam, scope)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\taddrs, err := scope.NextExternalAddresses(\n\t\t\taddrmgrNs, uint32(keyFam), 1,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Extract the first address, ensuring that it is of the proper\n\t\t// interface type, otherwise we can't manipulate it below.\n\t\taddr, ok := addrs[0].(waddrmgr.ManagedPubKeyAddress)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"address is not a managed pubkey \" +\n\t\t\t\t\"addr\")\n\t\t}\n\n\t\tpubKey = addr.PubKey()\n\n\t\t_, pathInfo, _ := addr.DerivationInfo()\n\t\tkeyLoc = KeyLocator{\n\t\t\tFamily: keyFam,\n\t\t\tIndex:  pathInfo.Index,\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn KeyDescriptor{}, err\n\t}\n\n\treturn KeyDescriptor{\n\t\tPubKey:     pubKey,\n\t\tKeyLocator: keyLoc,\n\t}, nil\n}\n\n// DeriveKey attempts to derive an arbitrary key specified by the passed\n// KeyLocator. This may be used in several recovery scenarios, or when manually\n// rotating something like our current default node key.\n//\n// NOTE: This is part of the keychain.KeyRing interface.",
      "length": 1393,
      "tokens": 209,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWalletKeyRing) DeriveKey(keyLoc KeyLocator) (KeyDescriptor, error) {",
      "content": "func (b *BtcWalletKeyRing) DeriveKey(keyLoc KeyLocator) (KeyDescriptor, error) {\n\tvar keyDesc KeyDescriptor\n\n\tdb := b.wallet.Database()\n\terr := walletdb.Update(db, func(tx walletdb.ReadWriteTx) error {\n\t\taddrmgrNs := tx.ReadWriteBucket(waddrmgrNamespaceKey)\n\n\t\tscope, err := b.keyScope()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// If the account doesn't exist, then we may need to create it\n\t\t// for the first time in order to derive the keys that we\n\t\t// require. We skip this if we're using a remote signer in which\n\t\t// case we _need_ to create all accounts when creating the\n\t\t// wallet, so it must exist now.\n\t\tif !b.wallet.Manager.WatchOnly() {\n\t\t\terr = b.createAccountIfNotExists(\n\t\t\t\taddrmgrNs, keyLoc.Family, scope,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tpath := waddrmgr.DerivationPath{\n\t\t\tInternalAccount: uint32(keyLoc.Family),\n\t\t\tBranch:          0,\n\t\t\tIndex:           keyLoc.Index,\n\t\t}\n\t\taddr, err := scope.DeriveFromKeyPath(addrmgrNs, path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tkeyDesc.KeyLocator = keyLoc\n\t\tkeyDesc.PubKey = addr.(waddrmgr.ManagedPubKeyAddress).PubKey()\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn keyDesc, err\n\t}\n\n\treturn keyDesc, nil\n}\n\n// DerivePrivKey attempts to derive the private key that corresponds to the\n// passed key descriptor.\n//\n// NOTE: This is part of the keychain.SecretKeyRing interface.",
      "length": 1221,
      "tokens": 175,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWalletKeyRing) DerivePrivKey(keyDesc KeyDescriptor) (",
      "content": "func (b *BtcWalletKeyRing) DerivePrivKey(keyDesc KeyDescriptor) (\n\t*btcec.PrivateKey, error) {\n\n\tvar key *btcec.PrivateKey\n\n\tscope, err := b.keyScope()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// First, attempt to see if we can read the key directly from\n\t// btcwallet's internal cache, if we can then we can skip all the\n\t// operations below (fast path).\n\tif keyDesc.PubKey == nil {\n\t\tkeyPath := waddrmgr.DerivationPath{\n\t\t\tInternalAccount: uint32(keyDesc.Family),\n\t\t\tAccount:         uint32(keyDesc.Family),\n\t\t\tBranch:          0,\n\t\t\tIndex:           keyDesc.Index,\n\t\t}\n\t\tprivKey, err := scope.DeriveFromKeyPathCache(keyPath)\n\t\tif err == nil {\n\t\t\treturn privKey, nil\n\t\t}\n\t}\n\n\tdb := b.wallet.Database()\n\terr = walletdb.Update(db, func(tx walletdb.ReadWriteTx) error {\n\t\taddrmgrNs := tx.ReadWriteBucket(waddrmgrNamespaceKey)\n\n\t\t// If the account doesn't exist, then we may need to create it\n\t\t// for the first time in order to derive the keys that we\n\t\t// require. We skip this if we're using a remote signer in which\n\t\t// case we _need_ to create all accounts when creating the\n\t\t// wallet, so it must exist now.\n\t\tif !b.wallet.Manager.WatchOnly() {\n\t\t\terr = b.createAccountIfNotExists(\n\t\t\t\taddrmgrNs, keyDesc.Family, scope,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\t// If the public key isn't set or they have a non-zero index,\n\t\t// then we know that the caller instead knows the derivation\n\t\t// path for a key.\n\t\tif keyDesc.PubKey == nil || keyDesc.Index > 0 {\n\t\t\t// Now that we know the account exists, we can safely\n\t\t\t// derive the full private key from the given path.\n\t\t\tpath := waddrmgr.DerivationPath{\n\t\t\t\tInternalAccount: uint32(keyDesc.Family),\n\t\t\t\tBranch:          0,\n\t\t\t\tIndex:           keyDesc.Index,\n\t\t\t}\n\t\t\taddr, err := scope.DeriveFromKeyPath(addrmgrNs, path)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tkey, err = addr.(waddrmgr.ManagedPubKeyAddress).PrivKey()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\treturn nil\n\t\t}\n\n\t\t// If the public key isn't nil, then this indicates that we\n\t\t// need to scan for the private key, assuming that we know the\n\t\t// valid key family.\n\t\tnextPath := waddrmgr.DerivationPath{\n\t\t\tInternalAccount: uint32(keyDesc.Family),\n\t\t\tBranch:          0,\n\t\t\tIndex:           0,\n\t\t}\n\n\t\t// We'll now iterate through our key range in an attempt to\n\t\t// find the target public key.\n\t\t//\n\t\t// TODO(roasbeef): possibly move scanning into wallet to allow\n\t\t// to be parallelized\n\t\tfor i := 0; i < MaxKeyRangeScan; i++ {\n\t\t\t// Derive the next key in the range and fetch its\n\t\t\t// managed address.\n\t\t\taddr, err := scope.DeriveFromKeyPath(\n\t\t\t\taddrmgrNs, nextPath,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tmanagedAddr := addr.(waddrmgr.ManagedPubKeyAddress)\n\n\t\t\t// If this is the target public key, then we'll return\n\t\t\t// it directly back to the caller.\n\t\t\tif managedAddr.PubKey().IsEqual(keyDesc.PubKey) {\n\t\t\t\tkey, err = managedAddr.PrivKey()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// This wasn't the target key, so roll forward and try\n\t\t\t// the next one.\n\t\t\tnextPath.Index++\n\t\t}\n\n\t\t// If we reach this point, then we we're unable to derive the\n\t\t// private key, so return an error back to the user.\n\t\treturn ErrCannotDerivePrivKey\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn key, nil\n}\n\n// ECDH performs a scalar multiplication (ECDH-like operation) between the\n// target key descriptor and remote public key. The output returned will be\n// the sha256 of the resulting shared point serialized in compressed format. If\n// k is our private key, and P is the public key, we perform the following\n// operation:\n//\n//\tsx := k*P s := sha256(sx.SerializeCompressed())\n//\n// NOTE: This is part of the keychain.ECDHRing interface.",
      "length": 3511,
      "tokens": 544,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWalletKeyRing) ECDH(keyDesc KeyDescriptor,",
      "content": "func (b *BtcWalletKeyRing) ECDH(keyDesc KeyDescriptor,\n\tpub *btcec.PublicKey) ([32]byte, error) {\n\n\tprivKey, err := b.DerivePrivKey(keyDesc)\n\tif err != nil {\n\t\treturn [32]byte{}, err\n\t}\n\n\tvar (\n\t\tpubJacobian btcec.JacobianPoint\n\t\ts           btcec.JacobianPoint\n\t)\n\tpub.AsJacobian(&pubJacobian)\n\n\tbtcec.ScalarMultNonConst(&privKey.Key, &pubJacobian, &s)\n\ts.ToAffine()\n\tsPubKey := btcec.NewPublicKey(&s.X, &s.Y)\n\th := sha256.Sum256(sPubKey.SerializeCompressed())\n\n\treturn h, nil\n}\n\n// SignMessage signs the given message, single or double SHA256 hashing it\n// first, with the private key described in the key locator.\n//\n// NOTE: This is part of the keychain.MessageSignerRing interface.",
      "length": 607,
      "tokens": 74,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWalletKeyRing) SignMessage(keyLoc KeyLocator,",
      "content": "func (b *BtcWalletKeyRing) SignMessage(keyLoc KeyLocator,\n\tmsg []byte, doubleHash bool) (*ecdsa.Signature, error) {\n\n\tprivKey, err := b.DerivePrivKey(KeyDescriptor{\n\t\tKeyLocator: keyLoc,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar digest []byte\n\tif doubleHash {\n\t\tdigest = chainhash.DoubleHashB(msg)\n\t} else {\n\t\tdigest = chainhash.HashB(msg)\n\t}\n\treturn ecdsa.Sign(privKey, digest), nil\n}\n\n// SignMessageCompact signs the given message, single or double SHA256 hashing\n// it first, with the private key described in the key locator and returns\n// the signature in the compact, public key recoverable format.\n//\n// NOTE: This is part of the keychain.MessageSignerRing interface.",
      "length": 600,
      "tokens": 89,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWalletKeyRing) SignMessageCompact(keyLoc KeyLocator,",
      "content": "func (b *BtcWalletKeyRing) SignMessageCompact(keyLoc KeyLocator,\n\tmsg []byte, doubleHash bool) ([]byte, error) {\n\n\tprivKey, err := b.DerivePrivKey(KeyDescriptor{\n\t\tKeyLocator: keyLoc,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar digest []byte\n\tif doubleHash {\n\t\tdigest = chainhash.DoubleHashB(msg)\n\t} else {\n\t\tdigest = chainhash.HashB(msg)\n\t}\n\treturn ecdsa.SignCompact(privKey, digest, true)\n}\n\n// SignMessageSchnorr uses the Schnorr signature algorithm to sign the given\n// message, single or double SHA256 hashing it first, with the private key\n// described in the key locator and the optional tweak applied to the private\n// key.\n//\n// NOTE: This is part of the keychain.MessageSignerRing interface.",
      "length": 617,
      "tokens": 94,
      "embedding": []
    },
    {
      "slug": "func (b *BtcWalletKeyRing) SignMessageSchnorr(keyLoc KeyLocator,",
      "content": "func (b *BtcWalletKeyRing) SignMessageSchnorr(keyLoc KeyLocator,\n\tmsg []byte, doubleHash bool, taprootTweak []byte) (*schnorr.Signature,\n\terror) {\n\n\tprivKey, err := b.DerivePrivKey(KeyDescriptor{\n\t\tKeyLocator: keyLoc,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(taprootTweak) > 0 {\n\t\tprivKey = txscript.TweakTaprootPrivKey(*privKey, taprootTweak)\n\t}\n\n\tvar digest []byte\n\tif doubleHash {\n\t\tdigest = chainhash.DoubleHashB(msg)\n\t} else {\n\t\tdigest = chainhash.HashB(msg)\n\t}\n\treturn schnorr.Sign(privKey, digest)\n}\n",
      "length": 430,
      "tokens": 55,
      "embedding": []
    }
  ]
}