{
  "filepath": "../implementations/go/lnd/keychain/interface_test.go",
  "package": "keychain",
  "sections": [
    {
      "slug": "func createTestBtcWallet(t testing.TB, coinType uint32) (*wallet.Wallet, error) {",
      "content": "func createTestBtcWallet(t testing.TB, coinType uint32) (*wallet.Wallet, error) {\n\t// Instruct waddrmgr to use the cranked down scrypt parameters when\n\t// creating new wallet encryption keys.\n\tfastScrypt := waddrmgr.FastScryptOptions\n\tkeyGen := func(passphrase *[]byte, config *waddrmgr.ScryptOptions) (\n\t\t*snacl.SecretKey, error) {\n\n\t\treturn snacl.NewSecretKey(\n\t\t\tpassphrase, fastScrypt.N, fastScrypt.R, fastScrypt.P,\n\t\t)\n\t}\n\twaddrmgr.SetSecretKeyGen(keyGen)\n\n\t// Create a new test wallet that uses fast scrypt as KDF.\n\tloader := wallet.NewLoader(\n\t\t&chaincfg.SimNetParams, t.TempDir(), true, testDBTimeout, 0,\n\t)\n\n\tpass := []byte(\"test\")\n\n\tbaseWallet, err := loader.CreateNewWallet(\n\t\tpass, pass, testHDSeed[:], time.Time{},\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := baseWallet.Unlock(pass, nil); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Construct the key scope required to derive keys for the chose\n\t// coinType.\n\tchainKeyScope := waddrmgr.KeyScope{\n\t\tPurpose: BIP0043Purpose,\n\t\tCoin:    coinType,\n\t}\n\n\t// We'll now ensure that the KeyScope: (1017, coinType) exists within\n\t// the internal waddrmgr. We'll need this in order to properly generate\n\t// the keys required for signing various contracts.\n\t_, err = baseWallet.Manager.FetchScopedKeyManager(chainKeyScope)\n\tif err != nil {\n\t\terr := walletdb.Update(baseWallet.Database(), func(tx walletdb.ReadWriteTx) error {\n\t\t\taddrmgrNs := tx.ReadWriteBucket(waddrmgrNamespaceKey)\n\n\t\t\t_, err := baseWallet.Manager.NewScopedKeyManager(\n\t\t\t\taddrmgrNs, chainKeyScope, lightningAddrSchema,\n\t\t\t)\n\t\t\treturn err\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tt.Cleanup(func() {\n\t\tbaseWallet.Lock()\n\t})\n\n\treturn baseWallet, nil\n}\n",
      "length": 1540,
      "tokens": 195,
      "embedding": []
    },
    {
      "slug": "func assertEqualKeyLocator(t *testing.T, a, b KeyLocator) {",
      "content": "func assertEqualKeyLocator(t *testing.T, a, b KeyLocator) {\n\tt.Helper()\n\tif a != b {\n\t\tt.Fatalf(\"mismatched key locators: expected %v, \"+\n\t\t\t\"got %v\", spew.Sdump(a), spew.Sdump(b))\n\t}\n}\n\n// secretKeyRingConstructor is a function signature that's used as a generic\n// constructor for various implementations of the KeyRing interface. A string\n// naming the returned interface, and the KeyRing interface itself are to be\n// returned.",
      "length": 361,
      "tokens": 55,
      "embedding": []
    },
    {
      "slug": "type keyRingConstructor func() (string, KeyRing, error)",
      "content": "type keyRingConstructor func() (string, KeyRing, error)\n\n// TestKeyRingDerivation tests that each known KeyRing implementation properly\n// adheres to the expected behavior of the set of interfaces.",
      "length": 139,
      "tokens": 20,
      "embedding": []
    },
    {
      "slug": "func TestKeyRingDerivation(t *testing.T) {",
      "content": "func TestKeyRingDerivation(t *testing.T) {\n\tt.Parallel()\n\n\tkeyRingImplementations := []keyRingConstructor{\n\t\tfunc() (string, KeyRing, error) {\n\t\t\twallet, err := createTestBtcWallet(t, CoinTypeBitcoin)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tkeyRing := NewBtcWalletKeyRing(wallet, CoinTypeBitcoin)\n\n\t\t\treturn \"btcwallet\", keyRing, nil\n\t\t},\n\t\tfunc() (string, KeyRing, error) {\n\t\t\twallet, err := createTestBtcWallet(t, CoinTypeLitecoin)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tkeyRing := NewBtcWalletKeyRing(wallet, CoinTypeLitecoin)\n\n\t\t\treturn \"ltcwallet\", keyRing, nil\n\t\t},\n\t\tfunc() (string, KeyRing, error) {\n\t\t\twallet, err := createTestBtcWallet(t, CoinTypeTestnet)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tkeyRing := NewBtcWalletKeyRing(wallet, CoinTypeTestnet)\n\n\t\t\treturn \"testwallet\", keyRing, nil\n\t\t},\n\t}\n\n\tconst numKeysToDerive = 10\n\n\t// For each implementation constructor registered above, we'll execute\n\t// an identical set of tests in order to ensure that the interface\n\t// adheres to our nominal specification.\n\tfor _, keyRingConstructor := range keyRingImplementations {\n\t\tkeyRingName, keyRing, err := keyRingConstructor()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to create key ring %v: %v\", keyRingName,\n\t\t\t\terr)\n\t\t}\n\n\t\tsuccess := t.Run(fmt.Sprintf(\"%v\", keyRingName), func(t *testing.T) {\n\t\t\t// First, we'll ensure that we're able to derive keys\n\t\t\t// from each of the known key families.\n\t\t\tfor _, keyFam := range VersionZeroKeyFamilies {\n\t\t\t\t// First, we'll ensure that we can derive the\n\t\t\t\t// *next* key in the keychain.\n\t\t\t\tkeyDesc, err := keyRing.DeriveNextKey(keyFam)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassertEqualKeyLocator(t,\n\t\t\t\t\tKeyLocator{\n\t\t\t\t\t\tFamily: keyFam,\n\t\t\t\t\t\tIndex:  0,\n\t\t\t\t\t}, keyDesc.KeyLocator,\n\t\t\t\t)\n\n\t\t\t\t// We'll now re-derive that key to ensure that\n\t\t\t\t// we're able to properly access the key via\n\t\t\t\t// the random access derivation methods.\n\t\t\t\tkeyLoc := KeyLocator{\n\t\t\t\t\tFamily: keyFam,\n\t\t\t\t\tIndex:  0,\n\t\t\t\t}\n\t\t\t\tfirstKeyDesc, err := keyRing.DeriveKey(keyLoc)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tif !keyDesc.PubKey.IsEqual(firstKeyDesc.PubKey) {\n\t\t\t\t\tt.Fatalf(\"mismatched keys: expected %x, \"+\n\t\t\t\t\t\t\"got %x\",\n\t\t\t\t\t\tkeyDesc.PubKey.SerializeCompressed(),\n\t\t\t\t\t\tfirstKeyDesc.PubKey.SerializeCompressed())\n\t\t\t\t}\n\t\t\t\tassertEqualKeyLocator(t,\n\t\t\t\t\tKeyLocator{\n\t\t\t\t\t\tFamily: keyFam,\n\t\t\t\t\t\tIndex:  0,\n\t\t\t\t\t}, firstKeyDesc.KeyLocator,\n\t\t\t\t)\n\n\t\t\t\t// If we now try to manually derive the next 10\n\t\t\t\t// keys (including the original key), then we\n\t\t\t\t// should get an identical public key back and\n\t\t\t\t// their KeyLocator information\n\t\t\t\t// should be set properly.\n\t\t\t\tfor i := 0; i < numKeysToDerive+1; i++ {\n\t\t\t\t\tkeyLoc := KeyLocator{\n\t\t\t\t\t\tFamily: keyFam,\n\t\t\t\t\t\tIndex:  uint32(i),\n\t\t\t\t\t}\n\t\t\t\t\tkeyDesc, err := keyRing.DeriveKey(keyLoc)\n\t\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\t\t// Ensure that the key locator matches\n\t\t\t\t\t// up as well.\n\t\t\t\t\tassertEqualKeyLocator(\n\t\t\t\t\t\tt, keyLoc, keyDesc.KeyLocator,\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\t// If this succeeds, then we'll also try to\n\t\t\t\t// derive a random index within the range.\n\t\t\t\trandKeyIndex := uint32(rand.Int31())\n\t\t\t\tkeyLoc = KeyLocator{\n\t\t\t\t\tFamily: keyFam,\n\t\t\t\t\tIndex:  randKeyIndex,\n\t\t\t\t}\n\t\t\t\tkeyDesc, err = keyRing.DeriveKey(keyLoc)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassertEqualKeyLocator(\n\t\t\t\t\tt, keyLoc, keyDesc.KeyLocator,\n\t\t\t\t)\n\t\t\t}\n\t\t})\n\t\tif !success {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\n// secretKeyRingConstructor is a function signature that's used as a generic\n// constructor for various implementations of the SecretKeyRing interface. A\n// string naming the returned interface, and the SecretKeyRing interface itself\n// are to be returned.",
      "length": 3401,
      "tokens": 411,
      "embedding": []
    },
    {
      "slug": "type secretKeyRingConstructor func() (string, SecretKeyRing, error)",
      "content": "type secretKeyRingConstructor func() (string, SecretKeyRing, error)\n\n// TestSecretKeyRingDerivation tests that each known SecretKeyRing\n// implementation properly adheres to the expected behavior of the set of\n// interface.",
      "length": 152,
      "tokens": 21,
      "embedding": []
    },
    {
      "slug": "func TestSecretKeyRingDerivation(t *testing.T) {",
      "content": "func TestSecretKeyRingDerivation(t *testing.T) {\n\tt.Parallel()\n\n\tsecretKeyRingImplementations := []secretKeyRingConstructor{\n\t\tfunc() (string, SecretKeyRing, error) {\n\t\t\twallet, err := createTestBtcWallet(t, CoinTypeBitcoin)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tkeyRing := NewBtcWalletKeyRing(wallet, CoinTypeBitcoin)\n\n\t\t\treturn \"btcwallet\", keyRing, nil\n\t\t},\n\t\tfunc() (string, SecretKeyRing, error) {\n\t\t\twallet, err := createTestBtcWallet(t, CoinTypeLitecoin)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tkeyRing := NewBtcWalletKeyRing(wallet, CoinTypeLitecoin)\n\n\t\t\treturn \"ltcwallet\", keyRing, nil\n\t\t},\n\t\tfunc() (string, SecretKeyRing, error) {\n\t\t\twallet, err := createTestBtcWallet(t, CoinTypeTestnet)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tkeyRing := NewBtcWalletKeyRing(wallet, CoinTypeTestnet)\n\n\t\t\treturn \"testwallet\", keyRing, nil\n\t\t},\n\t}\n\n\t// For each implementation constructor registered above, we'll execute\n\t// an identical set of tests in order to ensure that the interface\n\t// adheres to our nominal specification.\n\tfor _, secretKeyRingConstructor := range secretKeyRingImplementations {\n\t\tkeyRingName, secretKeyRing, err := secretKeyRingConstructor()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to create secret key ring %v: %v\",\n\t\t\t\tkeyRingName, err)\n\t\t}\n\n\t\tsuccess := t.Run(fmt.Sprintf(\"%v\", keyRingName), func(t *testing.T) {\n\t\t\t// For, each key family, we'll ensure that we're able\n\t\t\t// to obtain the private key of a randomly select child\n\t\t\t// index within the key family.\n\t\t\tfor _, keyFam := range VersionZeroKeyFamilies {\n\t\t\t\trandKeyIndex := uint32(rand.Int31())\n\t\t\t\tkeyLoc := KeyLocator{\n\t\t\t\t\tFamily: keyFam,\n\t\t\t\t\tIndex:  randKeyIndex,\n\t\t\t\t}\n\n\t\t\t\t// First, we'll query for the public key for\n\t\t\t\t// this target key locator.\n\t\t\t\tpubKeyDesc, err := secretKeyRing.DeriveKey(keyLoc)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"unable to derive pubkey \"+\n\t\t\t\t\t\t\"(fam=%v, index=%v): %v\",\n\t\t\t\t\t\tkeyLoc.Family,\n\t\t\t\t\t\tkeyLoc.Index, err)\n\t\t\t\t}\n\n\t\t\t\t// With the public key derive, ensure that\n\t\t\t\t// we're able to obtain the corresponding\n\t\t\t\t// private key correctly.\n\t\t\t\tprivKey, err := secretKeyRing.DerivePrivKey(KeyDescriptor{\n\t\t\t\t\tKeyLocator: keyLoc,\n\t\t\t\t})\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"unable to derive priv \"+\n\t\t\t\t\t\t\"(fam=%v, index=%v): %v\", keyLoc.Family,\n\t\t\t\t\t\tkeyLoc.Index, err)\n\t\t\t\t}\n\n\t\t\t\t// Finally, ensure that the keys match up\n\t\t\t\t// properly.\n\t\t\t\tif !pubKeyDesc.PubKey.IsEqual(privKey.PubKey()) {\n\t\t\t\t\tt.Fatalf(\"pubkeys mismatched: expected %x, got %x\",\n\t\t\t\t\t\tpubKeyDesc.PubKey.SerializeCompressed(),\n\t\t\t\t\t\tprivKey.PubKey().SerializeCompressed())\n\t\t\t\t}\n\n\t\t\t\t// Next, we'll test that we're able to derive a\n\t\t\t\t// key given only the public key and key\n\t\t\t\t// family.\n\t\t\t\t//\n\t\t\t\t// Derive a new key from the key ring.\n\t\t\t\tkeyDesc, err := secretKeyRing.DeriveNextKey(keyFam)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"unable to derive key: %v\", err)\n\t\t\t\t}\n\n\t\t\t\t// We'll now construct a key descriptor that\n\t\t\t\t// requires us to scan the key range, and query\n\t\t\t\t// for the key, we should be able to find it as\n\t\t\t\t// it's valid.\n\t\t\t\tkeyDesc = KeyDescriptor{\n\t\t\t\t\tPubKey: keyDesc.PubKey,\n\t\t\t\t\tKeyLocator: KeyLocator{\n\t\t\t\t\t\tFamily: keyFam,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\tprivKey, err = secretKeyRing.DerivePrivKey(keyDesc)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"unable to derive priv key \"+\n\t\t\t\t\t\t\"via scanning: %v\", err)\n\t\t\t\t}\n\n\t\t\t\t// Having to resort to scanning, we should be\n\t\t\t\t// able to find the target public key.\n\t\t\t\tif !keyDesc.PubKey.IsEqual(privKey.PubKey()) {\n\t\t\t\t\tt.Fatalf(\"pubkeys mismatched: expected %x, got %x\",\n\t\t\t\t\t\tpubKeyDesc.PubKey.SerializeCompressed(),\n\t\t\t\t\t\tprivKey.PubKey().SerializeCompressed())\n\t\t\t\t}\n\n\t\t\t\t// We'll try again, but this time with an\n\t\t\t\t// unknown public key.\n\t\t\t\t_, pub := btcec.PrivKeyFromBytes(\n\t\t\t\t\ttestHDSeed[:],\n\t\t\t\t)\n\t\t\t\tkeyDesc.PubKey = pub\n\n\t\t\t\t// If we attempt to query for this key, then we\n\t\t\t\t// should get ErrCannotDerivePrivKey.\n\t\t\t\tprivKey, err = secretKeyRing.DerivePrivKey(\n\t\t\t\t\tkeyDesc,\n\t\t\t\t)\n\t\t\t\tif err != ErrCannotDerivePrivKey {\n\t\t\t\t\tt.Fatalf(\"expected %T, instead got %v\",\n\t\t\t\t\t\tErrCannotDerivePrivKey, err)\n\t\t\t\t}\n\n\t\t\t\t// TODO(roasbeef): scalar mult once integrated\n\t\t\t}\n\t\t})\n\t\tif !success {\n\t\t\tbreak\n\t\t}\n\t}\n}\n",
      "length": 3952,
      "tokens": 487,
      "embedding": []
    },
    {
      "slug": "func init() {",
      "content": "func init() {\n\t// We'll clamp the max range scan to constrain the run time of the\n\t// private key scan test.\n\tMaxKeyRangeScan = 3\n}\n",
      "length": 114,
      "tokens": 23,
      "embedding": []
    }
  ]
}