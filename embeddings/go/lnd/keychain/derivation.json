{
  "filepath": "../implementations/go/lnd/keychain/derivation.go",
  "package": "keychain",
  "sections": [
    {
      "slug": "func IsKnownVersion(internalVersion uint8) bool {",
      "content": "func IsKnownVersion(internalVersion uint8) bool {\n\treturn internalVersion == KeyDerivationVersionLegacy ||\n\t\tinternalVersion == KeyDerivationVersionTaproot\n}\n\nvar (\n\t// MaxKeyRangeScan is the maximum number of keys that we'll attempt to\n\t// scan with if a caller knows the public key, but not the KeyLocator\n\t// and wishes to derive a private key.\n\tMaxKeyRangeScan = 100000\n\n\t// ErrCannotDerivePrivKey is returned when DerivePrivKey is unable to\n\t// derive a private key given only the public key and target key\n\t// family.\n\tErrCannotDerivePrivKey = fmt.Errorf(\"unable to derive private key\")\n)\n\n// KeyFamily represents a \"family\" of keys that will be used within various\n// contracts created by lnd. These families are meant to be distinct branches\n// within the HD key chain of the backing wallet. Usage of key families within\n// the interface below are strict in order to promote integrability and the\n// ability to restore all keys given a user master seed backup.\n//\n// The key derivation in this file follows the following hierarchy based on\n// BIP43:\n//\n//   - m/1017'/coinType'/keyFamily'/0/index",
      "length": 1029,
      "tokens": 166,
      "embedding": []
    },
    {
      "slug": "type KeyFamily uint32",
      "content": "type KeyFamily uint32\n\nconst (\n\t// KeyFamilyMultiSig are keys to be used within multi-sig scripts.\n\tKeyFamilyMultiSig KeyFamily = 0\n\n\t// KeyFamilyRevocationBase are keys that are used within channels to\n\t// create revocation basepoints that the remote party will use to\n\t// create revocation keys for us.\n\tKeyFamilyRevocationBase KeyFamily = 1\n\n\t// KeyFamilyHtlcBase are keys used within channels that will be\n\t// combined with per-state randomness to produce public keys that will\n\t// be used in HTLC scripts.\n\tKeyFamilyHtlcBase KeyFamily = 2\n\n\t// KeyFamilyPaymentBase are keys used within channels that will be\n\t// combined with per-state randomness to produce public keys that will\n\t// be used in scripts that pay directly to us without any delay.\n\tKeyFamilyPaymentBase KeyFamily = 3\n\n\t// KeyFamilyDelayBase are keys used within channels that will be\n\t// combined with per-state randomness to produce public keys that will\n\t// be used in scripts that pay to us, but require a CSV delay before we\n\t// can sweep the funds.\n\tKeyFamilyDelayBase KeyFamily = 4\n\n\t// KeyFamilyRevocationRoot is a family of keys which will be used to\n\t// derive the root of a revocation tree for a particular channel.\n\tKeyFamilyRevocationRoot KeyFamily = 5\n\n\t// KeyFamilyNodeKey is a family of keys that will be used to derive\n\t// keys that will be advertised on the network to represent our current\n\t// \"identity\" within the network. Peers will need our latest node key\n\t// in order to establish a transport session with us on the Lightning\n\t// p2p level (BOLT-0008).\n\tKeyFamilyNodeKey KeyFamily = 6\n\n\t// KeyFamilyBaseEncryption is the family of keys that will be used to\n\t// derive keys that we use to encrypt and decrypt any general blob data\n\t// like static channel backups and the TLS private key. Often used when\n\t// encrypting files on disk.\n\tKeyFamilyBaseEncryption KeyFamily = 7\n\n\t// KeyFamilyTowerSession is the family of keys that will be used to\n\t// derive session keys when negotiating sessions with watchtowers. The\n\t// session keys are limited to the lifetime of the session and are used\n\t// to increase privacy in the watchtower protocol.\n\tKeyFamilyTowerSession KeyFamily = 8\n\n\t// KeyFamilyTowerID is the family of keys used to derive the public key\n\t// of a watchtower. This made distinct from the node key to offer a form\n\t// of rudimentary whitelisting, i.e. via knowledge of the pubkey,\n\t// preventing others from having full access to the tower just as a\n\t// result of knowing the node key.\n\tKeyFamilyTowerID KeyFamily = 9\n)\n\n// VersionZeroKeyFamilies is a slice of all the known key families for first\n// version of the key derivation schema defined in this package.\nvar VersionZeroKeyFamilies = []KeyFamily{\n\tKeyFamilyMultiSig,\n\tKeyFamilyRevocationBase,\n\tKeyFamilyHtlcBase,\n\tKeyFamilyPaymentBase,\n\tKeyFamilyDelayBase,\n\tKeyFamilyRevocationRoot,\n\tKeyFamilyNodeKey,\n\tKeyFamilyBaseEncryption,\n\tKeyFamilyTowerSession,\n\tKeyFamilyTowerID,\n}\n\n// KeyLocator is a two-tuple that can be used to derive *any* key that has ever\n// been used under the key derivation mechanisms described in this file.\n// Version 0 of our key derivation schema uses the following BIP43-like\n// derivation:\n//\n//   - m/1017'/coinType'/keyFamily'/0/index\n//\n// Our purpose is 1017 (chosen arbitrary for now), and the coin type will vary\n// based on which coin/chain the channels are being created on. The key family\n// are actually just individual \"accounts\" in the nomenclature of BIP43. By\n// default we assume a branch of 0 (external). Finally, the key index (which\n// will vary per channel and use case) is the final element which allows us to\n// deterministically derive keys.",
      "length": 3543,
      "tokens": 569,
      "embedding": []
    },
    {
      "slug": "type KeyLocator struct {",
      "content": "type KeyLocator struct {\n\t// TODO(roasbeef): add the key scope as well??\n\n\t// Family is the family of key being identified.\n\tFamily KeyFamily\n\n\t// Index is the precise index of the key being identified.\n\tIndex uint32\n}\n\n// IsEmpty returns true if a KeyLocator is \"empty\". This may be the case where\n// we learn of a key from a remote party for a contract, but don't know the\n// precise details of its derivation (as we don't know the private key!).",
      "length": 412,
      "tokens": 78,
      "embedding": []
    },
    {
      "slug": "func (k KeyLocator) IsEmpty() bool {",
      "content": "func (k KeyLocator) IsEmpty() bool {\n\treturn k.Family == 0 && k.Index == 0\n}\n\n// KeyDescriptor wraps a KeyLocator and also optionally includes a public key.\n// Either the KeyLocator must be non-empty, or the public key pointer be\n// non-nil. This will be used by the KeyRing interface to lookup arbitrary\n// private keys, and also within the SignDescriptor struct to locate precisely\n// which keys should be used for signing.",
      "length": 381,
      "tokens": 67,
      "embedding": []
    },
    {
      "slug": "type KeyDescriptor struct {",
      "content": "type KeyDescriptor struct {\n\t// KeyLocator is the internal KeyLocator of the descriptor.\n\tKeyLocator\n\n\t// PubKey is an optional public key that fully describes a target key.\n\t// If this is nil, the KeyLocator MUST NOT be empty.\n\tPubKey *btcec.PublicKey\n}\n\n// KeyRing is the primary interface that will be used to perform public\n// derivation of various keys used within the peer-to-peer network, and also\n// within any created contracts. All derivation required by the KeyRing is\n// based off of public derivation, so a system with only an extended public key\n// (for the particular purpose+family) can derive this set of keys.",
      "length": 587,
      "tokens": 100,
      "embedding": []
    },
    {
      "slug": "type KeyRing interface {",
      "content": "type KeyRing interface {\n\t// DeriveNextKey attempts to derive the *next* key within the key\n\t// family (account in BIP43) specified. This method should return the\n\t// next external child within this branch.\n\tDeriveNextKey(keyFam KeyFamily) (KeyDescriptor, error)\n\n\t// DeriveKey attempts to derive an arbitrary key specified by the\n\t// passed KeyLocator. This may be used in several recovery scenarios,\n\t// or when manually rotating something like our current default node\n\t// key.\n\tDeriveKey(keyLoc KeyLocator) (KeyDescriptor, error)\n}\n\n// SecretKeyRing is a ring similar to the regular KeyRing interface, but it is\n// also able to derive *private keys*. As this is a super-set of the regular\n// KeyRing, we also expect the SecretKeyRing to implement the fully KeyRing\n// interface. The methods in this struct may be used to extract the node key in\n// order to accept inbound network connections, or to do manual signing for\n// recovery purposes.",
      "length": 904,
      "tokens": 146,
      "embedding": []
    },
    {
      "slug": "type SecretKeyRing interface {",
      "content": "type SecretKeyRing interface {\n\tKeyRing\n\n\tECDHRing\n\n\tMessageSignerRing\n\n\t// DerivePrivKey attempts to derive the private key that corresponds to\n\t// the passed key descriptor.  If the public key is set, then this\n\t// method will perform an in-order scan over the key set, with a max of\n\t// MaxKeyRangeScan keys. In order for this to work, the caller MUST set\n\t// the KeyFamily within the partially populated KeyLocator.\n\tDerivePrivKey(keyDesc KeyDescriptor) (*btcec.PrivateKey, error)\n}\n\n// MessageSignerRing is an interface that abstracts away basic low-level ECDSA\n// signing on keys within a key ring.",
      "length": 558,
      "tokens": 87,
      "embedding": []
    },
    {
      "slug": "type MessageSignerRing interface {",
      "content": "type MessageSignerRing interface {\n\t// SignMessage signs the given message, single or double SHA256 hashing\n\t// it first, with the private key described in the key locator.\n\tSignMessage(keyLoc KeyLocator, msg []byte,\n\t\tdoubleHash bool) (*ecdsa.Signature, error)\n\n\t// SignMessageCompact signs the given message, single or double SHA256\n\t// hashing it first, with the private key described in the key locator\n\t// and returns the signature in the compact, public key recoverable\n\t// format.\n\tSignMessageCompact(keyLoc KeyLocator, msg []byte,\n\t\tdoubleHash bool) ([]byte, error)\n\n\t// SignMessageSchnorr signs the given message, single or double SHA256\n\t// hashing it first, with the private key described in the key locator\n\t// and the optional Taproot tweak applied to the private key.\n\tSignMessageSchnorr(keyLoc KeyLocator, msg []byte,\n\t\tdoubleHash bool, taprootTweak []byte) (*schnorr.Signature,\n\t\terror)\n}\n\n// SingleKeyMessageSigner is an abstraction interface that hides the\n// implementation of the low-level ECDSA signing operations by wrapping a\n// single, specific private key.",
      "length": 1024,
      "tokens": 145,
      "embedding": []
    },
    {
      "slug": "type SingleKeyMessageSigner interface {",
      "content": "type SingleKeyMessageSigner interface {\n\t// PubKey returns the public key of the wrapped private key.\n\tPubKey() *btcec.PublicKey\n\n\t// KeyLocator returns the locator that describes the wrapped private\n\t// key.\n\tKeyLocator() KeyLocator\n\n\t// SignMessage signs the given message, single or double SHA256 hashing\n\t// it first, with the wrapped private key.\n\tSignMessage(message []byte, doubleHash bool) (*ecdsa.Signature, error)\n\n\t// SignMessageCompact signs the given message, single or double SHA256\n\t// hashing it first, with the wrapped private key and returns the\n\t// signature in the compact, public key recoverable format.\n\tSignMessageCompact(message []byte, doubleHash bool) ([]byte, error)\n}\n\n// ECDHRing is an interface that abstracts away basic low-level ECDH shared key\n// generation on keys within a key ring.",
      "length": 759,
      "tokens": 111,
      "embedding": []
    },
    {
      "slug": "type ECDHRing interface {",
      "content": "type ECDHRing interface {\n\t// ECDH performs a scalar multiplication (ECDH-like operation) between\n\t// the target key descriptor and remote public key. The output\n\t// returned will be the sha256 of the resulting shared point serialized\n\t// in compressed format. If k is our private key, and P is the public\n\t// key, we perform the following operation:\n\t//\n\t//  sx := k*P\n\t//  s := sha256(sx.SerializeCompressed())\n\tECDH(keyDesc KeyDescriptor, pubKey *btcec.PublicKey) ([32]byte, error)\n}\n\n// SingleKeyECDH is an abstraction interface that hides the implementation of an\n// ECDH operation by wrapping a single, specific private key.",
      "length": 592,
      "tokens": 92,
      "embedding": []
    },
    {
      "slug": "type SingleKeyECDH interface {",
      "content": "type SingleKeyECDH interface {\n\t// PubKey returns the public key of the wrapped private key.\n\tPubKey() *btcec.PublicKey\n\n\t// ECDH performs a scalar multiplication (ECDH-like operation) between\n\t// the wrapped private key and remote public key. The output returned\n\t// will be the sha256 of the resulting shared point serialized in\n\t// compressed format.\n\tECDH(pubKey *btcec.PublicKey) ([32]byte, error)\n}\n\n// TODO(roasbeef): extend to actually support scalar mult of key?\n//  * would allow to push in initial handshake auth into interface as well\n",
      "length": 504,
      "tokens": 78,
      "embedding": []
    }
  ]
}