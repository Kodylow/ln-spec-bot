{
  "filepath": "../implementations/go/lnd/multimutex/multimutex.go",
  "package": "multimutex",
  "sections": [
    {
      "slug": "type cntMutex struct {",
      "content": "type cntMutex struct {\n\tcnt int\n\tsync.Mutex\n}\n\n// Mutex is a struct that keeps track of a set of mutexes with\n// a given ID. It can be used for making sure only one goroutine\n// gets given the mutex per ID.",
      "length": 177,
      "tokens": 39,
      "embedding": []
    },
    {
      "slug": "type Mutex struct {",
      "content": "type Mutex struct {\n\t// mutexes is a map of IDs to a cntMutex. The cntMutex for\n\t// a given ID will hold the mutex to be used by all\n\t// callers requesting access for the ID, in addition to\n\t// the count of callers.\n\tmutexes map[uint64]*cntMutex\n\n\t// mapMtx is used to give synchronize concurrent access\n\t// to the mutexes map.\n\tmapMtx sync.Mutex\n}\n\n// NewMutex creates a new Mutex.",
      "length": 351,
      "tokens": 66,
      "embedding": []
    },
    {
      "slug": "func NewMutex() *Mutex {",
      "content": "func NewMutex() *Mutex {\n\treturn &Mutex{\n\t\tmutexes: make(map[uint64]*cntMutex),\n\t}\n}\n\n// Lock locks the mutex by the given ID. If the mutex is already\n// locked by this ID, Lock blocks until the mutex is available.",
      "length": 183,
      "tokens": 32,
      "embedding": []
    },
    {
      "slug": "func (c *Mutex) Lock(id uint64) {",
      "content": "func (c *Mutex) Lock(id uint64) {\n\tc.mapMtx.Lock()\n\tmtx, ok := c.mutexes[id]\n\tif ok {\n\t\t// If the mutex already existed in the map, we\n\t\t// increment its counter, to indicate that there\n\t\t// now is one more goroutine waiting for it.\n\t\tmtx.cnt++\n\t} else {\n\t\t// If it was not in the map, it means no other\n\t\t// goroutine has locked the mutex for this ID,\n\t\t// and we can create a new mutex with count 1\n\t\t// and add it to the map.\n\t\tmtx = &cntMutex{\n\t\t\tcnt: 1,\n\t\t}\n\t\tc.mutexes[id] = mtx\n\t}\n\tc.mapMtx.Unlock()\n\n\t// Acquire the mutex for this ID.\n\tmtx.Lock()\n}\n\n// Unlock unlocks the mutex by the given ID. It is a run-time\n// error if the mutex is not locked by the ID on entry to Unlock.",
      "length": 627,
      "tokens": 126,
      "embedding": []
    },
    {
      "slug": "func (c *Mutex) Unlock(id uint64) {",
      "content": "func (c *Mutex) Unlock(id uint64) {\n\t// Since we are done with all the work for this\n\t// update, we update the map to reflect that.\n\tc.mapMtx.Lock()\n\n\tmtx, ok := c.mutexes[id]\n\tif !ok {\n\t\t// The mutex not existing in the map means\n\t\t// an unlock for an ID not currently locked\n\t\t// was attempted.\n\t\tpanic(fmt.Sprintf(\"double unlock for id %v\",\n\t\t\tid))\n\t}\n\n\t// Decrement the counter. If the count goes to\n\t// zero, it means this caller was the last one\n\t// to wait for the mutex, and we can delete it\n\t// from the map. We can do this safely since we\n\t// are under the mapMtx, meaning that all other\n\t// goroutines waiting for the mutex already\n\t// have incremented it, or will create a new\n\t// mutex when they get the mapMtx.\n\tmtx.cnt--\n\tif mtx.cnt == 0 {\n\t\tdelete(c.mutexes, id)\n\t}\n\tc.mapMtx.Unlock()\n\n\t// Unlock the mutex for this ID.\n\tmtx.Unlock()\n}\n",
      "length": 786,
      "tokens": 148,
      "embedding": []
    }
  ]
}