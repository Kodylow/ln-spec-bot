{
  "filepath": "../implementations/go/lnd/multimutex/hash_mutex.go",
  "package": "multimutex",
  "sections": [
    {
      "slug": "type HashMutex struct {",
      "content": "type HashMutex struct {\n\t// mutexes is a map of hashes to a cntMutex. The cntMutex for\n\t// a given hash will hold the mutex to be used by all\n\t// callers requesting access for the hash, in addition to\n\t// the count of callers.\n\tmutexes map[lntypes.Hash]*cntMutex\n\n\t// mapMtx is used to give synchronize concurrent access\n\t// to the mutexes map.\n\tmapMtx sync.Mutex\n}\n\n// NewHashMutex creates a new Mutex.",
      "length": 368,
      "tokens": 66,
      "embedding": []
    },
    {
      "slug": "func NewHashMutex() *HashMutex {",
      "content": "func NewHashMutex() *HashMutex {\n\treturn &HashMutex{\n\t\tmutexes: make(map[lntypes.Hash]*cntMutex),\n\t}\n}\n\n// Lock locks the mutex by the given hash. If the mutex is already\n// locked by this hash, Lock blocks until the mutex is available.",
      "length": 197,
      "tokens": 32,
      "embedding": []
    },
    {
      "slug": "func (c *HashMutex) Lock(hash lntypes.Hash) {",
      "content": "func (c *HashMutex) Lock(hash lntypes.Hash) {\n\tc.mapMtx.Lock()\n\tmtx, ok := c.mutexes[hash]\n\tif ok {\n\t\t// If the mutex already existed in the map, we\n\t\t// increment its counter, to indicate that there\n\t\t// now is one more goroutine waiting for it.\n\t\tmtx.cnt++\n\t} else {\n\t\t// If it was not in the map, it means no other\n\t\t// goroutine has locked the mutex for this hash,\n\t\t// and we can create a new mutex with count 1\n\t\t// and add it to the map.\n\t\tmtx = &cntMutex{\n\t\t\tcnt: 1,\n\t\t}\n\t\tc.mutexes[hash] = mtx\n\t}\n\tc.mapMtx.Unlock()\n\n\t// Acquire the mutex for this hash.\n\tmtx.Lock()\n}\n\n// Unlock unlocks the mutex by the given hash. It is a run-time\n// error if the mutex is not locked by the hash on entry to Unlock.",
      "length": 639,
      "tokens": 126,
      "embedding": []
    },
    {
      "slug": "func (c *HashMutex) Unlock(hash lntypes.Hash) {",
      "content": "func (c *HashMutex) Unlock(hash lntypes.Hash) {\n\t// Since we are done with all the work for this\n\t// update, we update the map to reflect that.\n\tc.mapMtx.Lock()\n\n\tmtx, ok := c.mutexes[hash]\n\tif !ok {\n\t\t// The mutex not existing in the map means\n\t\t// an unlock for an hash not currently locked\n\t\t// was attempted.\n\t\tpanic(fmt.Sprintf(\"double unlock for hash %v\",\n\t\t\thash))\n\t}\n\n\t// Decrement the counter. If the count goes to\n\t// zero, it means this caller was the last one\n\t// to wait for the mutex, and we can delete it\n\t// from the map. We can do this safely since we\n\t// are under the mapMtx, meaning that all other\n\t// goroutines waiting for the mutex already\n\t// have incremented it, or will create a new\n\t// mutex when they get the mapMtx.\n\tmtx.cnt--\n\tif mtx.cnt == 0 {\n\t\tdelete(c.mutexes, hash)\n\t}\n\tc.mapMtx.Unlock()\n\n\t// Unlock the mutex for this hash.\n\tmtx.Unlock()\n}\n",
      "length": 798,
      "tokens": 148,
      "embedding": []
    }
  ]
}