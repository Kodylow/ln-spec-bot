{
  "filepath": "../implementations/go/lnd/pool/worker_test.go",
  "package": "pool_test",
  "sections": [
    {
      "slug": "type workerPoolTest struct {",
      "content": "type workerPoolTest struct {\n\tname       string\n\tnewPool    func() interface{}\n\tnumWorkers int\n}\n\n// TestConcreteWorkerPools asserts the behavior of any concrete implementations\n// of worker pools provided by the pool package. Currently this tests the\n// pool.Read and pool.Write instances.",
      "length": 254,
      "tokens": 35,
      "embedding": []
    },
    {
      "slug": "func TestConcreteWorkerPools(t *testing.T) {",
      "content": "func TestConcreteWorkerPools(t *testing.T) {\n\tconst (\n\t\tgcInterval     = time.Second\n\t\texpiryInterval = 250 * time.Millisecond\n\t\tnumWorkers     = 5\n\t\tworkerTimeout  = 500 * time.Millisecond\n\t)\n\n\ttests := []workerPoolTest{\n\t\t{\n\t\t\tname: \"write pool\",\n\t\t\tnewPool: func() interface{} {\n\t\t\t\tbp := pool.NewWriteBuffer(\n\t\t\t\t\tgcInterval, expiryInterval,\n\t\t\t\t)\n\n\t\t\t\treturn pool.NewWrite(\n\t\t\t\t\tbp, numWorkers, workerTimeout,\n\t\t\t\t)\n\t\t\t},\n\t\t\tnumWorkers: numWorkers,\n\t\t},\n\t\t{\n\t\t\tname: \"read pool\",\n\t\t\tnewPool: func() interface{} {\n\t\t\t\tbp := pool.NewReadBuffer(\n\t\t\t\t\tgcInterval, expiryInterval,\n\t\t\t\t)\n\n\t\t\t\treturn pool.NewRead(\n\t\t\t\t\tbp, numWorkers, workerTimeout,\n\t\t\t\t)\n\t\t\t},\n\t\t\tnumWorkers: numWorkers,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttestWorkerPool(t, test)\n\t}\n}\n",
      "length": 673,
      "tokens": 82,
      "embedding": []
    },
    {
      "slug": "func testWorkerPool(t *testing.T, test workerPoolTest) {",
      "content": "func testWorkerPool(t *testing.T, test workerPoolTest) {\n\tt.Run(test.name+\" non blocking\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tp := test.newPool()\n\t\tstartGeneric(t, p)\n\t\tt.Cleanup(func() {\n\t\t\tstopGeneric(t, p)\n\t\t})\n\n\t\tsubmitNonblockingGeneric(t, p, test.numWorkers)\n\t})\n\n\tt.Run(test.name+\" blocking\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tp := test.newPool()\n\t\tstartGeneric(t, p)\n\t\tt.Cleanup(func() {\n\t\t\tstopGeneric(t, p)\n\t\t})\n\n\t\tsubmitBlockingGeneric(t, p, test.numWorkers)\n\t})\n\n\tt.Run(test.name+\" partial blocking\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tp := test.newPool()\n\t\tstartGeneric(t, p)\n\t\tt.Cleanup(func() {\n\t\t\tstopGeneric(t, p)\n\t\t})\n\n\t\tsubmitPartialBlockingGeneric(t, p, test.numWorkers)\n\t})\n}\n\n// submitNonblockingGeneric asserts that queueing tasks to the worker pool and\n// allowing them all to unblock simultaneously results in all of the tasks being\n// completed in a timely manner.",
      "length": 807,
      "tokens": 94,
      "embedding": []
    },
    {
      "slug": "func submitNonblockingGeneric(t *testing.T, p interface{}, nWorkers int) {",
      "content": "func submitNonblockingGeneric(t *testing.T, p interface{}, nWorkers int) {\n\t// We'll submit 2*nWorkers tasks that will all be unblocked\n\t// simultaneously.\n\tnUnblocked := 2 * nWorkers\n\n\t// First we'll queue all of the tasks for the pool.\n\terrChan := make(chan error)\n\tsemChan := make(chan struct{})\n\tfor i := 0; i < nUnblocked; i++ {\n\t\tgo func() { errChan <- submitGeneric(p, semChan) }()\n\t}\n\n\t// Since we haven't signaled the semaphore, none of the them should\n\t// complete.\n\tpullNothing(t, errChan)\n\n\t// Now, unblock them all simultaneously. All of the tasks should then be\n\t// processed in parallel. Afterward, no more errors should come through.\n\tclose(semChan)\n\tpullParllel(t, nUnblocked, errChan)\n\tpullNothing(t, errChan)\n}\n\n// submitBlockingGeneric asserts that submitting blocking tasks to the pool and\n// unblocking each sequentially results in a single task being processed at a\n// time.",
      "length": 798,
      "tokens": 127,
      "embedding": []
    },
    {
      "slug": "func submitBlockingGeneric(t *testing.T, p interface{}, nWorkers int) {",
      "content": "func submitBlockingGeneric(t *testing.T, p interface{}, nWorkers int) {\n\t// We'll submit 2*nWorkers tasks that will be unblocked sequentially.\n\tnBlocked := 2 * nWorkers\n\n\t// First, queue all of the blocking tasks for the pool.\n\terrChan := make(chan error)\n\tsemChan := make(chan struct{})\n\tfor i := 0; i < nBlocked; i++ {\n\t\tgo func() { errChan <- submitGeneric(p, semChan) }()\n\t}\n\n\t// Since we haven't signaled the semaphore, none of them should\n\t// complete.\n\tpullNothing(t, errChan)\n\n\t// Now, pull each blocking task sequentially from the pool. Afterwards,\n\t// no more errors should come through.\n\tpullSequntial(t, nBlocked, errChan, semChan)\n\tpullNothing(t, errChan)\n\n}\n\n// submitPartialBlockingGeneric tests that so long as one worker is not blocked,\n// any other non-blocking submitted tasks can still be processed.",
      "length": 725,
      "tokens": 114,
      "embedding": []
    },
    {
      "slug": "func submitPartialBlockingGeneric(t *testing.T, p interface{}, nWorkers int) {",
      "content": "func submitPartialBlockingGeneric(t *testing.T, p interface{}, nWorkers int) {\n\t// We'll submit nWorkers-1 tasks that will be initially blocked, the\n\t// remainder will all be unblocked simultaneously. After the unblocked\n\t// tasks have finished, we will sequentially unblock the nWorkers-1\n\t// tasks that were first submitted.\n\tnBlocked := nWorkers - 1\n\tnUnblocked := 2*nWorkers - nBlocked\n\n\t// First, submit all of the blocking tasks to the pool.\n\terrChan := make(chan error)\n\tsemChan := make(chan struct{})\n\tfor i := 0; i < nBlocked; i++ {\n\t\tgo func() { errChan <- submitGeneric(p, semChan) }()\n\t}\n\n\t// Since these are all blocked, no errors should be returned yet.\n\tpullNothing(t, errChan)\n\n\t// Now, add all of the non-blocking task to the pool.\n\tsemChanNB := make(chan struct{})\n\tfor i := 0; i < nUnblocked; i++ {\n\t\tgo func() { errChan <- submitGeneric(p, semChanNB) }()\n\t}\n\n\t// Since we haven't unblocked the second batch, we again expect no tasks\n\t// to finish.\n\tpullNothing(t, errChan)\n\n\t// Now, unblock the unblocked task and pull all of them. After they have\n\t// been pulled, we should see no more tasks.\n\tclose(semChanNB)\n\tpullParllel(t, nUnblocked, errChan)\n\tpullNothing(t, errChan)\n\n\t// Finally, unblock each the blocked tasks we added initially, and\n\t// assert that no further errors come through.\n\tpullSequntial(t, nBlocked, errChan, semChan)\n\tpullNothing(t, errChan)\n}\n",
      "length": 1267,
      "tokens": 204,
      "embedding": []
    },
    {
      "slug": "func pullNothing(t *testing.T, errChan chan error) {",
      "content": "func pullNothing(t *testing.T, errChan chan error) {\n\tt.Helper()\n\n\tselect {\n\tcase err := <-errChan:\n\t\tt.Fatalf(\"received unexpected error before semaphore \"+\n\t\t\t\"release: %v\", err)\n\n\tcase <-time.After(time.Second):\n\t}\n}\n",
      "length": 157,
      "tokens": 20,
      "embedding": []
    },
    {
      "slug": "func pullParllel(t *testing.T, n int, errChan chan error) {",
      "content": "func pullParllel(t *testing.T, n int, errChan chan error) {\n\tt.Helper()\n\n\tfor i := 0; i < n; i++ {\n\t\tselect {\n\t\tcase err := <-errChan:\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\tcase <-time.After(time.Second):\n\t\t\tt.Fatalf(\"task %d was not processed in time\", i)\n\t\t}\n\t}\n}\n",
      "length": 198,
      "tokens": 36,
      "embedding": []
    },
    {
      "slug": "func pullSequntial(t *testing.T, n int, errChan chan error, semChan chan struct{}) {",
      "content": "func pullSequntial(t *testing.T, n int, errChan chan error, semChan chan struct{}) {\n\tt.Helper()\n\n\tfor i := 0; i < n; i++ {\n\t\t// Signal for another task to unblock.\n\t\tselect {\n\t\tcase semChan <- struct{}{}:\n\t\tcase <-time.After(time.Second):\n\t\t\tt.Fatalf(\"task %d was not unblocked\", i)\n\t\t}\n\n\t\t// Wait for the error to arrive, we expect it to be non-nil.\n\t\tselect {\n\t\tcase err := <-errChan:\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\tcase <-time.After(time.Second):\n\t\t\tt.Fatalf(\"task %d was not processed in time\", i)\n\t\t}\n\t}\n}\n",
      "length": 418,
      "tokens": 71,
      "embedding": []
    },
    {
      "slug": "func startGeneric(t *testing.T, p interface{}) {",
      "content": "func startGeneric(t *testing.T, p interface{}) {\n\tt.Helper()\n\n\tvar err error\n\tswitch pp := p.(type) {\n\tcase *pool.Write:\n\t\terr = pp.Start()\n\n\tcase *pool.Read:\n\t\terr = pp.Start()\n\n\tdefault:\n\t\tt.Fatalf(\"unknown worker pool type: %T\", p)\n\t}\n\n\trequire.NoError(t, err, \"unable to start worker pool\")\n}\n",
      "length": 232,
      "tokens": 35,
      "embedding": []
    },
    {
      "slug": "func stopGeneric(t *testing.T, p interface{}) {",
      "content": "func stopGeneric(t *testing.T, p interface{}) {\n\tt.Helper()\n\n\tvar err error\n\tswitch pp := p.(type) {\n\tcase *pool.Write:\n\t\terr = pp.Stop()\n\n\tcase *pool.Read:\n\t\terr = pp.Stop()\n\n\tdefault:\n\t\tt.Fatalf(\"unknown worker pool type: %T\", p)\n\t}\n\n\trequire.NoError(t, err, \"unable to stop worker pool\")\n}\n",
      "length": 229,
      "tokens": 35,
      "embedding": []
    },
    {
      "slug": "func submitGeneric(p interface{}, sem <-chan struct{}) error {",
      "content": "func submitGeneric(p interface{}, sem <-chan struct{}) error {\n\tvar err error\n\tswitch pp := p.(type) {\n\tcase *pool.Write:\n\t\terr = pp.Submit(func(buf *bytes.Buffer) error {\n\t\t\t// Verify that the provided buffer has been reset to be\n\t\t\t// zero length.\n\t\t\tif buf.Len() != 0 {\n\t\t\t\treturn fmt.Errorf(\"buf should be length zero, \"+\n\t\t\t\t\t\"instead has length %d\", buf.Len())\n\t\t\t}\n\n\t\t\t// Verify that the capacity of the buffer has the\n\t\t\t// correct underlying size of a buffer.WriteSize.\n\t\t\tif buf.Cap() != buffer.WriteSize {\n\t\t\t\treturn fmt.Errorf(\"buf should have capacity \"+\n\t\t\t\t\t\"%d, instead has capacity %d\",\n\t\t\t\t\tbuffer.WriteSize, buf.Cap())\n\t\t\t}\n\n\t\t\t// Sample some random bytes that we'll use to dirty the\n\t\t\t// buffer.\n\t\t\tb := make([]byte, rand.Intn(buf.Cap()))\n\t\t\t_, err := io.ReadFull(crand.Reader, b)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Write the random bytes the buffer.\n\t\t\t_, err = buf.Write(b)\n\n\t\t\t// Wait until this task is signaled to exit.\n\t\t\t<-sem\n\n\t\t\treturn err\n\t\t})\n\n\tcase *pool.Read:\n\t\terr = pp.Submit(func(buf *buffer.Read) error {\n\t\t\t// Assert that all of the bytes in the provided array\n\t\t\t// are zero, indicating that the buffer was reset\n\t\t\t// between uses.\n\t\t\tfor i := range buf[:] {\n\t\t\t\tif buf[i] != 0x00 {\n\t\t\t\t\treturn fmt.Errorf(\"byte %d of \"+\n\t\t\t\t\t\t\"buffer.Read should be \"+\n\t\t\t\t\t\t\"0, instead is %d\", i, buf[i])\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Sample some random bytes to read into the buffer.\n\t\t\t_, err := io.ReadFull(crand.Reader, buf[:])\n\n\t\t\t// Wait until this task is signaled to exit.\n\t\t\t<-sem\n\n\t\t\treturn err\n\n\t\t})\n\n\tdefault:\n\t\treturn fmt.Errorf(\"unknown worker pool type: %T\", p)\n\t}\n\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to submit task: %v\", err)\n\t}\n\n\treturn nil\n}\n",
      "length": 1563,
      "tokens": 250,
      "embedding": []
    }
  ]
}