{
  "filepath": "../implementations/go/lnd/tlv/truncated_test.go",
  "package": "tlv_test",
  "sections": [
    {
      "slug": "func TestSizeTUint16(t *testing.T) {",
      "content": "func TestSizeTUint16(t *testing.T) {\n\tfor _, test := range tuint16Tests {\n\t\tname := fmt.Sprintf(\"0x%x\", test.value)\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tsize := tlv.SizeTUint16(test.value)\n\t\t\tif test.size != size {\n\t\t\t\tt.Fatalf(\"size mismatch, expected: %d got: %d\",\n\t\t\t\t\ttest.size, size)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestTUint16 asserts that ETUint16 outputs the proper encoding of a truncated\n// uint16, and that DTUint16 is able to parse the output.",
      "length": 393,
      "tokens": 58,
      "embedding": []
    },
    {
      "slug": "func TestTUint16(t *testing.T) {",
      "content": "func TestTUint16(t *testing.T) {\n\tvar buf [8]byte\n\tfor _, test := range tuint16Tests {\n\t\ttest := test\n\n\t\tif len(test.bytes) != int(test.size) {\n\t\t\tt.Fatalf(\"invalid test case, \"+\n\t\t\t\t\"len(bytes)[%d] != size[%d]\",\n\t\t\t\tlen(test.bytes), test.size)\n\t\t}\n\n\t\tname := fmt.Sprintf(\"0x%x\", test.value)\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\t// Test generic encoder.\n\t\t\tvar b bytes.Buffer\n\t\t\terr := tlv.ETUint16(&b, &test.value, &buf)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to encode tuint16: %v\", err)\n\t\t\t}\n\n\t\t\tif !bytes.Equal(b.Bytes(), test.bytes) {\n\t\t\t\tt.Fatalf(\"encoding mismatch, \"+\n\t\t\t\t\t\"expected: %x, got: %x\",\n\t\t\t\t\ttest.bytes, b.Bytes())\n\t\t\t}\n\n\t\t\t// Test non-generic encoder.\n\t\t\tvar b2 bytes.Buffer\n\t\t\terr = tlv.ETUint16T(&b2, test.value, &buf)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to encode tuint16: %v\", err)\n\t\t\t}\n\n\t\t\tif !bytes.Equal(b2.Bytes(), test.bytes) {\n\t\t\t\tt.Fatalf(\"encoding mismatch, \"+\n\t\t\t\t\t\"expected: %x, got: %x\",\n\t\t\t\t\ttest.bytes, b2.Bytes())\n\t\t\t}\n\n\t\t\tvar value uint16\n\t\t\tr := bytes.NewReader(b.Bytes())\n\t\t\terr = tlv.DTUint16(r, &value, &buf, test.size)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to decode tuint16: %v\", err)\n\t\t\t}\n\n\t\t\tif value != test.value {\n\t\t\t\tt.Fatalf(\"decoded value mismatch, \"+\n\t\t\t\t\t\"expected: %d, got: %d\",\n\t\t\t\t\ttest.value, value)\n\t\t\t}\n\t\t})\n\t}\n}\n\nvar tuint32Tests = []struct {\n\tvalue uint32\n\tsize  uint64\n\tbytes []byte\n}{\n\t{\n\t\tvalue: 0x00000000,\n\t\tsize:  0,\n\t\tbytes: []byte{},\n\t},\n\t{\n\t\tvalue: 0x00000001,\n\t\tsize:  1,\n\t\tbytes: []byte{0x01},\n\t},\n\t{\n\t\tvalue: 0x000000ff,\n\t\tsize:  1,\n\t\tbytes: []byte{0xff},\n\t},\n\t{\n\t\tvalue: 0x00000100,\n\t\tsize:  2,\n\t\tbytes: []byte{0x01, 0x00},\n\t},\n\t{\n\t\tvalue: 0x0000ffff,\n\t\tsize:  2,\n\t\tbytes: []byte{0xff, 0xff},\n\t},\n\t{\n\t\tvalue: 0x00010000,\n\t\tsize:  3,\n\t\tbytes: []byte{0x01, 0x00, 0x00},\n\t},\n\t{\n\t\tvalue: 0x00ffffff,\n\t\tsize:  3,\n\t\tbytes: []byte{0xff, 0xff, 0xff},\n\t},\n\t{\n\t\tvalue: 0x01000000,\n\t\tsize:  4,\n\t\tbytes: []byte{0x01, 0x00, 0x00, 0x00},\n\t},\n\t{\n\t\tvalue: 0xffffffff,\n\t\tsize:  4,\n\t\tbytes: []byte{0xff, 0xff, 0xff, 0xff},\n\t},\n}\n\n// TestSizeTUint32 asserts that SizeTUint32 computes the proper truncated size\n// along boundary conditions of the input space.",
      "length": 1983,
      "tokens": 270,
      "embedding": []
    },
    {
      "slug": "func TestSizeTUint32(t *testing.T) {",
      "content": "func TestSizeTUint32(t *testing.T) {\n\tfor _, test := range tuint32Tests {\n\t\tname := fmt.Sprintf(\"0x%x\", test.value)\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tsize := tlv.SizeTUint32(test.value)\n\t\t\tif test.size != size {\n\t\t\t\tt.Fatalf(\"size mismatch, expected: %d got: %d\",\n\t\t\t\t\ttest.size, size)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestTUint32 asserts that ETUint32 outputs the proper encoding of a truncated\n// uint32, and that DTUint32 is able to parse the output.",
      "length": 393,
      "tokens": 58,
      "embedding": []
    },
    {
      "slug": "func TestTUint32(t *testing.T) {",
      "content": "func TestTUint32(t *testing.T) {\n\tvar buf [8]byte\n\tfor _, test := range tuint32Tests {\n\t\ttest := test\n\n\t\tif len(test.bytes) != int(test.size) {\n\t\t\tt.Fatalf(\"invalid test case, \"+\n\t\t\t\t\"len(bytes)[%d] != size[%d]\",\n\t\t\t\tlen(test.bytes), test.size)\n\t\t}\n\n\t\tname := fmt.Sprintf(\"0x%x\", test.value)\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\t// Test generic encoder.\n\t\t\tvar b bytes.Buffer\n\t\t\terr := tlv.ETUint32(&b, &test.value, &buf)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to encode tuint32: %v\", err)\n\t\t\t}\n\n\t\t\tif !bytes.Equal(b.Bytes(), test.bytes) {\n\t\t\t\tt.Fatalf(\"encoding mismatch, \"+\n\t\t\t\t\t\"expected: %x, got: %x\",\n\t\t\t\t\ttest.bytes, b.Bytes())\n\t\t\t}\n\n\t\t\t// Test non-generic encoder.\n\t\t\tvar b2 bytes.Buffer\n\t\t\terr = tlv.ETUint32T(&b2, test.value, &buf)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to encode tuint32: %v\", err)\n\t\t\t}\n\n\t\t\tif !bytes.Equal(b2.Bytes(), test.bytes) {\n\t\t\t\tt.Fatalf(\"encoding mismatch, \"+\n\t\t\t\t\t\"expected: %x, got: %x\",\n\t\t\t\t\ttest.bytes, b2.Bytes())\n\t\t\t}\n\n\t\t\tvar value uint32\n\t\t\tr := bytes.NewReader(b.Bytes())\n\t\t\terr = tlv.DTUint32(r, &value, &buf, test.size)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to decode tuint32: %v\", err)\n\t\t\t}\n\n\t\t\tif value != test.value {\n\t\t\t\tt.Fatalf(\"decoded value mismatch, \"+\n\t\t\t\t\t\"expected: %d, got: %d\",\n\t\t\t\t\ttest.value, value)\n\t\t\t}\n\t\t})\n\t}\n}\n\nvar tuint64Tests = []struct {\n\tvalue uint64\n\tsize  uint64\n\tbytes []byte\n}{\n\t{\n\t\tvalue: 0x0000000000000000,\n\t\tsize:  0,\n\t\tbytes: []byte{},\n\t},\n\t{\n\t\tvalue: 0x0000000000000001,\n\t\tsize:  1,\n\t\tbytes: []byte{0x01},\n\t},\n\t{\n\t\tvalue: 0x00000000000000ff,\n\t\tsize:  1,\n\t\tbytes: []byte{0xff},\n\t},\n\t{\n\t\tvalue: 0x0000000000000100,\n\t\tsize:  2,\n\t\tbytes: []byte{0x01, 0x00},\n\t},\n\t{\n\t\tvalue: 0x000000000000ffff,\n\t\tsize:  2,\n\t\tbytes: []byte{0xff, 0xff},\n\t},\n\t{\n\t\tvalue: 0x0000000000010000,\n\t\tsize:  3,\n\t\tbytes: []byte{0x01, 0x00, 0x00},\n\t},\n\t{\n\t\tvalue: 0x0000000000ffffff,\n\t\tsize:  3,\n\t\tbytes: []byte{0xff, 0xff, 0xff},\n\t},\n\t{\n\t\tvalue: 0x0000000001000000,\n\t\tsize:  4,\n\t\tbytes: []byte{0x01, 0x00, 0x00, 0x00},\n\t},\n\t{\n\t\tvalue: 0x00000000ffffffff,\n\t\tsize:  4,\n\t\tbytes: []byte{0xff, 0xff, 0xff, 0xff},\n\t},\n\t{\n\t\tvalue: 0x0000000100000000,\n\t\tsize:  5,\n\t\tbytes: []byte{0x01, 0x00, 0x00, 0x00, 0x00},\n\t},\n\t{\n\t\tvalue: 0x000000ffffffffff,\n\t\tsize:  5,\n\t\tbytes: []byte{0xff, 0xff, 0xff, 0xff, 0xff},\n\t},\n\t{\n\t\tvalue: 0x0000010000000000,\n\t\tsize:  6,\n\t\tbytes: []byte{0x01, 0x00, 0x00, 0x00, 0x00, 0x00},\n\t},\n\t{\n\t\tvalue: 0x0000ffffffffffff,\n\t\tsize:  6,\n\t\tbytes: []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n\t},\n\t{\n\t\tvalue: 0x0001000000000000,\n\t\tsize:  7,\n\t\tbytes: []byte{0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n\t},\n\t{\n\t\tvalue: 0x00ffffffffffffff,\n\t\tsize:  7,\n\t\tbytes: []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n\t},\n\t{\n\t\tvalue: 0x0100000000000000,\n\t\tsize:  8,\n\t\tbytes: []byte{0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n\t},\n\t{\n\t\tvalue: 0xffffffffffffffff,\n\t\tsize:  8,\n\t\tbytes: []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n\t},\n}\n\n// TestSizeTUint64 asserts that SizeTUint64 computes the proper truncated size\n// along boundary conditions of the input space.",
      "length": 2847,
      "tokens": 378,
      "embedding": []
    },
    {
      "slug": "func TestSizeTUint64(t *testing.T) {",
      "content": "func TestSizeTUint64(t *testing.T) {\n\tfor _, test := range tuint64Tests {\n\t\tif len(test.bytes) != int(test.size) {\n\t\t\tt.Fatalf(\"invalid test case, \"+\n\t\t\t\t\"len(bytes)[%d] != size[%d]\",\n\t\t\t\tlen(test.bytes), test.size)\n\t\t}\n\n\t\tname := fmt.Sprintf(\"0x%x\", test.value)\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tsize := tlv.SizeTUint64(test.value)\n\t\t\tif test.size != size {\n\t\t\t\tt.Fatalf(\"size mismatch, expected: %d got: %d\",\n\t\t\t\t\ttest.size, size)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestTUint64 asserts that ETUint64 outputs the proper encoding of a truncated\n// uint64, and that DTUint64 is able to parse the output.",
      "length": 534,
      "tokens": 73,
      "embedding": []
    },
    {
      "slug": "func TestTUint64(t *testing.T) {",
      "content": "func TestTUint64(t *testing.T) {\n\tvar buf [8]byte\n\tfor _, test := range tuint64Tests {\n\t\ttest := test\n\n\t\tif len(test.bytes) != int(test.size) {\n\t\t\tt.Fatalf(\"invalid test case, \"+\n\t\t\t\t\"len(bytes)[%d] != size[%d]\",\n\t\t\t\tlen(test.bytes), test.size)\n\t\t}\n\n\t\tname := fmt.Sprintf(\"0x%x\", test.value)\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\t// Test generic encoder.\n\t\t\tvar b bytes.Buffer\n\t\t\terr := tlv.ETUint64(&b, &test.value, &buf)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to encode tuint64: %v\", err)\n\t\t\t}\n\n\t\t\tif !bytes.Equal(b.Bytes(), test.bytes) {\n\t\t\t\tt.Fatalf(\"encoding mismatch, \"+\n\t\t\t\t\t\"expected: %x, got: %x\",\n\t\t\t\t\ttest.bytes, b.Bytes())\n\t\t\t}\n\n\t\t\t// Test non-generic encoder.\n\t\t\tvar b2 bytes.Buffer\n\t\t\terr = tlv.ETUint64T(&b2, test.value, &buf)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to encode tuint64: %v\", err)\n\t\t\t}\n\n\t\t\tif !bytes.Equal(b2.Bytes(), test.bytes) {\n\t\t\t\tt.Fatalf(\"encoding mismatch, \"+\n\t\t\t\t\t\"expected: %x, got: %x\",\n\t\t\t\t\ttest.bytes, b2.Bytes())\n\t\t\t}\n\n\t\t\tvar value uint64\n\t\t\tr := bytes.NewReader(b.Bytes())\n\t\t\terr = tlv.DTUint64(r, &value, &buf, test.size)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to decode tuint64: %v\", err)\n\t\t\t}\n\n\t\t\tif value != test.value {\n\t\t\t\tt.Fatalf(\"decoded value mismatch, \"+\n\t\t\t\t\t\"expected: %d, got: %d\",\n\t\t\t\t\ttest.value, value)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "length": 1196,
      "tokens": 155,
      "embedding": []
    }
  ]
}