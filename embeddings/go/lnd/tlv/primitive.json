{
  "filepath": "../implementations/go/lnd/tlv/primitive.go",
  "package": "tlv",
  "sections": [
    {
      "slug": "type ErrTypeForEncoding struct {",
      "content": "type ErrTypeForEncoding struct {\n\tval     interface{}\n\texpType string\n}\n\n// NewTypeForEncodingErr creates a new ErrTypeForEncoding given the incorrect\n// val and the expected type.",
      "length": 142,
      "tokens": 20,
      "embedding": []
    },
    {
      "slug": "func NewTypeForEncodingErr(val interface{}, expType string) ErrTypeForEncoding {",
      "content": "func NewTypeForEncodingErr(val interface{}, expType string) ErrTypeForEncoding {\n\treturn ErrTypeForEncoding{\n\t\tval:     val,\n\t\texpType: expType,\n\t}\n}\n\n// Error returns a human-readable description of the type mismatch.",
      "length": 131,
      "tokens": 18,
      "embedding": []
    },
    {
      "slug": "func (e ErrTypeForEncoding) Error() string {",
      "content": "func (e ErrTypeForEncoding) Error() string {\n\treturn fmt.Sprintf(\"ErrTypeForEncoding want (type: *%s), \"+\n\t\t\"got (type: %T)\", e.expType, e.val)\n}\n\n// ErrTypeForDecoding signals that an incorrect type was passed to a Decoder or\n// that the expected length of the encoding is different from that required by\n// the expected type.",
      "length": 276,
      "tokens": 43,
      "embedding": []
    },
    {
      "slug": "type ErrTypeForDecoding struct {",
      "content": "type ErrTypeForDecoding struct {\n\tval       interface{}\n\texpType   string\n\tvalLength uint64\n\texpLength uint64\n}\n\n// NewTypeForDecodingErr creates a new ErrTypeForDecoding given the incorrect\n// val and expected type, or the mismatch in their expected lengths.",
      "length": 219,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func NewTypeForDecodingErr(val interface{}, expType string,",
      "content": "func NewTypeForDecodingErr(val interface{}, expType string,\n\tvalLength, expLength uint64) ErrTypeForDecoding {\n\n\treturn ErrTypeForDecoding{\n\t\tval:       val,\n\t\texpType:   expType,\n\t\tvalLength: valLength,\n\t\texpLength: expLength,\n\t}\n}\n\n// Error returns a human-readable description of the type mismatch.",
      "length": 231,
      "tokens": 27,
      "embedding": []
    },
    {
      "slug": "func (e ErrTypeForDecoding) Error() string {",
      "content": "func (e ErrTypeForDecoding) Error() string {\n\treturn fmt.Sprintf(\"ErrTypeForDecoding want (type: *%s, length: %v), \"+\n\t\t\"got (type: %T, length: %v)\", e.expType, e.expLength, e.val,\n\t\te.valLength)\n}\n\nvar (\n\tbyteOrder = binary.BigEndian\n)\n\n// EUint8 is an Encoder for uint8 values. An error is returned if val is not a\n// *uint8.",
      "length": 272,
      "tokens": 43,
      "embedding": []
    },
    {
      "slug": "func EUint8(w io.Writer, val interface{}, buf *[8]byte) error {",
      "content": "func EUint8(w io.Writer, val interface{}, buf *[8]byte) error {\n\tif i, ok := val.(*uint8); ok {\n\t\tbuf[0] = *i\n\t\t_, err := w.Write(buf[:1])\n\t\treturn err\n\t}\n\treturn NewTypeForEncodingErr(val, \"uint8\")\n}\n\n// EUint8T encodes a uint8 val to the provided io.Writer. This method is exposed\n// so that encodings for custom uint8-like types can be created without\n// incurring an extra heap allocation.",
      "length": 319,
      "tokens": 53,
      "embedding": []
    },
    {
      "slug": "func EUint8T(w io.Writer, val uint8, buf *[8]byte) error {",
      "content": "func EUint8T(w io.Writer, val uint8, buf *[8]byte) error {\n\tbuf[0] = val\n\t_, err := w.Write(buf[:1])\n\treturn err\n}\n\n// EUint16 is an Encoder for uint16 values. An error is returned if val is not a\n// *uint16.",
      "length": 143,
      "tokens": 29,
      "embedding": []
    },
    {
      "slug": "func EUint16(w io.Writer, val interface{}, buf *[8]byte) error {",
      "content": "func EUint16(w io.Writer, val interface{}, buf *[8]byte) error {\n\tif i, ok := val.(*uint16); ok {\n\t\tbyteOrder.PutUint16(buf[:2], *i)\n\t\t_, err := w.Write(buf[:2])\n\t\treturn err\n\t}\n\treturn NewTypeForEncodingErr(val, \"uint16\")\n}\n\n// EUint16T encodes a uint16 val to the provided io.Writer. This method is\n// exposed so that encodings for custom uint16-like types can be created without\n// incurring an extra heap allocation.",
      "length": 345,
      "tokens": 52,
      "embedding": []
    },
    {
      "slug": "func EUint16T(w io.Writer, val uint16, buf *[8]byte) error {",
      "content": "func EUint16T(w io.Writer, val uint16, buf *[8]byte) error {\n\tbyteOrder.PutUint16(buf[:2], val)\n\t_, err := w.Write(buf[:2])\n\treturn err\n}\n\n// EUint32 is an Encoder for uint32 values. An error is returned if val is not a\n// *uint32.",
      "length": 164,
      "tokens": 28,
      "embedding": []
    },
    {
      "slug": "func EUint32(w io.Writer, val interface{}, buf *[8]byte) error {",
      "content": "func EUint32(w io.Writer, val interface{}, buf *[8]byte) error {\n\tif i, ok := val.(*uint32); ok {\n\t\tbyteOrder.PutUint32(buf[:4], *i)\n\t\t_, err := w.Write(buf[:4])\n\t\treturn err\n\t}\n\treturn NewTypeForEncodingErr(val, \"uint32\")\n}\n\n// EUint32T encodes a uint32 val to the provided io.Writer. This method is\n// exposed so that encodings for custom uint32-like types can be created without\n// incurring an extra heap allocation.",
      "length": 345,
      "tokens": 52,
      "embedding": []
    },
    {
      "slug": "func EUint32T(w io.Writer, val uint32, buf *[8]byte) error {",
      "content": "func EUint32T(w io.Writer, val uint32, buf *[8]byte) error {\n\tbyteOrder.PutUint32(buf[:4], val)\n\t_, err := w.Write(buf[:4])\n\treturn err\n}\n\n// EUint64 is an Encoder for uint64 values. An error is returned if val is not a\n// *uint64.",
      "length": 164,
      "tokens": 28,
      "embedding": []
    },
    {
      "slug": "func EUint64(w io.Writer, val interface{}, buf *[8]byte) error {",
      "content": "func EUint64(w io.Writer, val interface{}, buf *[8]byte) error {\n\tif i, ok := val.(*uint64); ok {\n\t\tbyteOrder.PutUint64(buf[:], *i)\n\t\t_, err := w.Write(buf[:])\n\t\treturn err\n\t}\n\treturn NewTypeForEncodingErr(val, \"uint64\")\n}\n\n// EUint64T encodes a uint64 val to the provided io.Writer. This method is\n// exposed so that encodings for custom uint64-like types can be created without\n// incurring an extra heap allocation.",
      "length": 343,
      "tokens": 52,
      "embedding": []
    },
    {
      "slug": "func EUint64T(w io.Writer, val uint64, buf *[8]byte) error {",
      "content": "func EUint64T(w io.Writer, val uint64, buf *[8]byte) error {\n\tbyteOrder.PutUint64(buf[:], val)\n\t_, err := w.Write(buf[:])\n\treturn err\n}\n\n// DUint8 is a Decoder for uint8 values. An error is returned if val is not a\n// *uint8.",
      "length": 158,
      "tokens": 28,
      "embedding": []
    },
    {
      "slug": "func DUint8(r io.Reader, val interface{}, buf *[8]byte, l uint64) error {",
      "content": "func DUint8(r io.Reader, val interface{}, buf *[8]byte, l uint64) error {\n\tif i, ok := val.(*uint8); ok && l == 1 {\n\t\tif _, err := io.ReadFull(r, buf[:1]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*i = buf[0]\n\t\treturn nil\n\t}\n\treturn NewTypeForDecodingErr(val, \"uint8\", l, 1)\n}\n\n// DUint16 is a Decoder for uint16 values. An error is returned if val is not a\n// *uint16.",
      "length": 276,
      "tokens": 55,
      "embedding": []
    },
    {
      "slug": "func DUint16(r io.Reader, val interface{}, buf *[8]byte, l uint64) error {",
      "content": "func DUint16(r io.Reader, val interface{}, buf *[8]byte, l uint64) error {\n\tif i, ok := val.(*uint16); ok && l == 2 {\n\t\tif _, err := io.ReadFull(r, buf[:2]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*i = byteOrder.Uint16(buf[:2])\n\t\treturn nil\n\t}\n\treturn NewTypeForDecodingErr(val, \"uint16\", l, 2)\n}\n\n// DUint32 is a Decoder for uint32 values. An error is returned if val is not a\n// *uint32.",
      "length": 297,
      "tokens": 55,
      "embedding": []
    },
    {
      "slug": "func DUint32(r io.Reader, val interface{}, buf *[8]byte, l uint64) error {",
      "content": "func DUint32(r io.Reader, val interface{}, buf *[8]byte, l uint64) error {\n\tif i, ok := val.(*uint32); ok && l == 4 {\n\t\tif _, err := io.ReadFull(r, buf[:4]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*i = byteOrder.Uint32(buf[:4])\n\t\treturn nil\n\t}\n\treturn NewTypeForDecodingErr(val, \"uint32\", l, 4)\n}\n\n// DUint64 is a Decoder for uint64 values. An error is returned if val is not a\n// *uint64.",
      "length": 297,
      "tokens": 55,
      "embedding": []
    },
    {
      "slug": "func DUint64(r io.Reader, val interface{}, buf *[8]byte, l uint64) error {",
      "content": "func DUint64(r io.Reader, val interface{}, buf *[8]byte, l uint64) error {\n\tif i, ok := val.(*uint64); ok && l == 8 {\n\t\tif _, err := io.ReadFull(r, buf[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*i = byteOrder.Uint64(buf[:])\n\t\treturn nil\n\t}\n\treturn NewTypeForDecodingErr(val, \"uint64\", l, 8)\n}\n\n// EBytes32 is an Encoder for 32-byte arrays. An error is returned if val is not\n// a *[32]byte.",
      "length": 300,
      "tokens": 55,
      "embedding": []
    },
    {
      "slug": "func EBytes32(w io.Writer, val interface{}, _ *[8]byte) error {",
      "content": "func EBytes32(w io.Writer, val interface{}, _ *[8]byte) error {\n\tif b, ok := val.(*[32]byte); ok {\n\t\t_, err := w.Write(b[:])\n\t\treturn err\n\t}\n\treturn NewTypeForEncodingErr(val, \"[32]byte\")\n}\n\n// DBytes32 is a Decoder for 32-byte arrays. An error is returned if val is not\n// a *[32]byte.",
      "length": 214,
      "tokens": 37,
      "embedding": []
    },
    {
      "slug": "func DBytes32(r io.Reader, val interface{}, _ *[8]byte, l uint64) error {",
      "content": "func DBytes32(r io.Reader, val interface{}, _ *[8]byte, l uint64) error {\n\tif b, ok := val.(*[32]byte); ok && l == 32 {\n\t\t_, err := io.ReadFull(r, b[:])\n\t\treturn err\n\t}\n\treturn NewTypeForDecodingErr(val, \"[32]byte\", l, 32)\n}\n\n// EBytes33 is an Encoder for 33-byte arrays. An error is returned if val is not\n// a *[33]byte.",
      "length": 240,
      "tokens": 44,
      "embedding": []
    },
    {
      "slug": "func EBytes33(w io.Writer, val interface{}, _ *[8]byte) error {",
      "content": "func EBytes33(w io.Writer, val interface{}, _ *[8]byte) error {\n\tif b, ok := val.(*[33]byte); ok {\n\t\t_, err := w.Write(b[:])\n\t\treturn err\n\t}\n\treturn NewTypeForEncodingErr(val, \"[33]byte\")\n}\n\n// DBytes33 is a Decoder for 33-byte arrays. An error is returned if val is not\n// a *[33]byte.",
      "length": 214,
      "tokens": 37,
      "embedding": []
    },
    {
      "slug": "func DBytes33(r io.Reader, val interface{}, _ *[8]byte, l uint64) error {",
      "content": "func DBytes33(r io.Reader, val interface{}, _ *[8]byte, l uint64) error {\n\tif b, ok := val.(*[33]byte); ok {\n\t\t_, err := io.ReadFull(r, b[:])\n\t\treturn err\n\t}\n\treturn NewTypeForDecodingErr(val, \"[33]byte\", l, 33)\n}\n\n// EBytes64 is an Encoder for 64-byte arrays. An error is returned if val is not\n// a *[64]byte.",
      "length": 229,
      "tokens": 40,
      "embedding": []
    },
    {
      "slug": "func EBytes64(w io.Writer, val interface{}, _ *[8]byte) error {",
      "content": "func EBytes64(w io.Writer, val interface{}, _ *[8]byte) error {\n\tif b, ok := val.(*[64]byte); ok {\n\t\t_, err := w.Write(b[:])\n\t\treturn err\n\t}\n\treturn NewTypeForEncodingErr(val, \"[64]byte\")\n}\n\n// DBytes64 is an Decoder for 64-byte arrays. An error is returned if val is not\n// a *[64]byte.",
      "length": 215,
      "tokens": 37,
      "embedding": []
    },
    {
      "slug": "func DBytes64(r io.Reader, val interface{}, _ *[8]byte, l uint64) error {",
      "content": "func DBytes64(r io.Reader, val interface{}, _ *[8]byte, l uint64) error {\n\tif b, ok := val.(*[64]byte); ok && l == 64 {\n\t\t_, err := io.ReadFull(r, b[:])\n\t\treturn err\n\t}\n\treturn NewTypeForDecodingErr(val, \"[64]byte\", l, 64)\n}\n\n// EPubKey is an Encoder for *btcec.PublicKey values. An error is returned if\n// val is not a **btcec.PublicKey.",
      "length": 256,
      "tokens": 44,
      "embedding": []
    },
    {
      "slug": "func EPubKey(w io.Writer, val interface{}, _ *[8]byte) error {",
      "content": "func EPubKey(w io.Writer, val interface{}, _ *[8]byte) error {\n\tif pk, ok := val.(**btcec.PublicKey); ok {\n\t\t_, err := w.Write((*pk).SerializeCompressed())\n\t\treturn err\n\t}\n\treturn NewTypeForEncodingErr(val, \"*btcec.PublicKey\")\n}\n\n// DPubKey is a Decoder for *btcec.PublicKey values. An error is returned if val\n// is not a **btcec.PublicKey.",
      "length": 270,
      "tokens": 37,
      "embedding": []
    },
    {
      "slug": "func DPubKey(r io.Reader, val interface{}, _ *[8]byte, l uint64) error {",
      "content": "func DPubKey(r io.Reader, val interface{}, _ *[8]byte, l uint64) error {\n\tif pk, ok := val.(**btcec.PublicKey); ok && l == 33 {\n\t\tvar b [33]byte\n\t\t_, err := io.ReadFull(r, b[:])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tp, err := btcec.ParsePubKey(b[:])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t*pk = p\n\n\t\treturn nil\n\t}\n\treturn NewTypeForDecodingErr(val, \"*btcec.PublicKey\", l, 33)\n}\n\n// EVarBytes is an Encoder for variable byte slices. An error is returned if val\n// is not *[]byte.",
      "length": 386,
      "tokens": 70,
      "embedding": []
    },
    {
      "slug": "func EVarBytes(w io.Writer, val interface{}, _ *[8]byte) error {",
      "content": "func EVarBytes(w io.Writer, val interface{}, _ *[8]byte) error {\n\tif b, ok := val.(*[]byte); ok {\n\t\t_, err := w.Write(*b)\n\t\treturn err\n\t}\n\treturn NewTypeForEncodingErr(val, \"[]byte\")\n}\n\n// DVarBytes is a Decoder for variable byte slices. An error is returned if val\n// is not *[]byte.",
      "length": 211,
      "tokens": 37,
      "embedding": []
    },
    {
      "slug": "func DVarBytes(r io.Reader, val interface{}, _ *[8]byte, l uint64) error {",
      "content": "func DVarBytes(r io.Reader, val interface{}, _ *[8]byte, l uint64) error {\n\tif b, ok := val.(*[]byte); ok {\n\t\t*b = make([]byte, l)\n\t\t_, err := io.ReadFull(r, *b)\n\t\treturn err\n\t}\n\treturn NewTypeForDecodingErr(val, \"[]byte\", l, l)\n}\n\n// EBigSize encodes an uint32 or an uint64 using BigSize format. An error is\n// returned if val is not either *uint32 or *uint64.",
      "length": 277,
      "tokens": 49,
      "embedding": []
    },
    {
      "slug": "func EBigSize(w io.Writer, val interface{}, buf *[8]byte) error {",
      "content": "func EBigSize(w io.Writer, val interface{}, buf *[8]byte) error {\n\tif i, ok := val.(*uint32); ok {\n\t\treturn WriteVarInt(w, uint64(*i), buf)\n\t}\n\n\tif i, ok := val.(*uint64); ok {\n\t\treturn WriteVarInt(w, uint64(*i), buf)\n\t}\n\n\treturn NewTypeForEncodingErr(val, \"BigSize\")\n}\n\n// DBigSize decodes an uint32 or an uint64 using BigSize format. An error is\n// returned if val is not either *uint32 or *uint64.",
      "length": 322,
      "tokens": 52,
      "embedding": []
    },
    {
      "slug": "func DBigSize(r io.Reader, val interface{}, buf *[8]byte, l uint64) error {",
      "content": "func DBigSize(r io.Reader, val interface{}, buf *[8]byte, l uint64) error {\n\tif i, ok := val.(*uint32); ok {\n\t\tv, err := ReadVarInt(r, buf)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*i = uint32(v)\n\t\treturn nil\n\t}\n\n\tif i, ok := val.(*uint64); ok {\n\t\tv, err := ReadVarInt(r, buf)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*i = v\n\t\treturn nil\n\t}\n\n\treturn NewTypeForDecodingErr(val, \"BigSize\", l, 8)\n}\n\n// SizeBigSize returns a SizeFunc that can compute the length of BigSize.",
      "length": 367,
      "tokens": 70,
      "embedding": []
    },
    {
      "slug": "func SizeBigSize(val interface{}) SizeFunc {",
      "content": "func SizeBigSize(val interface{}) SizeFunc {\n\tvar size uint64\n\n\tif i, ok := val.(*uint32); ok {\n\t\tsize = VarIntSize(uint64(*i))\n\t}\n\n\tif i, ok := val.(*uint64); ok {\n\t\tsize = VarIntSize(uint64(*i))\n\t}\n\n\treturn func() uint64 {\n\t\treturn size\n\t}\n}\n",
      "length": 185,
      "tokens": 33,
      "embedding": []
    }
  ]
}