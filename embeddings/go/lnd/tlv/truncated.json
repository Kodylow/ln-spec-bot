{
  "filepath": "../implementations/go/lnd/tlv/truncated.go",
  "package": "tlv",
  "sections": [
    {
      "slug": "func numLeadingZeroBytes16(v uint16) uint64 {",
      "content": "func numLeadingZeroBytes16(v uint16) uint64 {\n\tswitch {\n\tcase v == 0:\n\t\treturn 2\n\tcase v&0xff00 == 0:\n\t\treturn 1\n\tdefault:\n\t\treturn 0\n\t}\n}\n\n// SizeTUint16 returns the number of bytes remaining in a uint16 after\n// truncating the leading zeros.",
      "length": 186,
      "tokens": 36,
      "embedding": []
    },
    {
      "slug": "func SizeTUint16(v uint16) uint64 {",
      "content": "func SizeTUint16(v uint16) uint64 {\n\treturn 2 - numLeadingZeroBytes16(v)\n}\n\n// ETUint16 is an Encoder for truncated uint16 values, where leading zeros will\n// be omitted. An error is returned if val is not a *uint16.",
      "length": 176,
      "tokens": 31,
      "embedding": []
    },
    {
      "slug": "func ETUint16(w io.Writer, val interface{}, buf *[8]byte) error {",
      "content": "func ETUint16(w io.Writer, val interface{}, buf *[8]byte) error {\n\tif t, ok := val.(*uint16); ok {\n\t\tbinary.BigEndian.PutUint16(buf[:2], *t)\n\t\tnumZeros := numLeadingZeroBytes16(*t)\n\t\t_, err := w.Write(buf[numZeros:2])\n\t\treturn err\n\t}\n\treturn NewTypeForEncodingErr(val, \"uint16\")\n}\n\n// ETUint16T is an Encoder for truncated uint16 values, where leading zeros will\n// be omitted. An error is returned if val is not a *uint16.",
      "length": 347,
      "tokens": 49,
      "embedding": []
    },
    {
      "slug": "func ETUint16T(w io.Writer, val uint16, buf *[8]byte) error {",
      "content": "func ETUint16T(w io.Writer, val uint16, buf *[8]byte) error {\n\tbinary.BigEndian.PutUint16(buf[:2], val)\n\tnumZeros := numLeadingZeroBytes16(val)\n\t_, err := w.Write(buf[numZeros:2])\n\treturn err\n}\n\n// DTUint16 is an Decoder for truncated uint16 values, where leading zeros will\n// be resurrected. An error is returned if val is not a *uint16.",
      "length": 270,
      "tokens": 38,
      "embedding": []
    },
    {
      "slug": "func DTUint16(r io.Reader, val interface{}, buf *[8]byte, l uint64) error {",
      "content": "func DTUint16(r io.Reader, val interface{}, buf *[8]byte, l uint64) error {\n\tif t, ok := val.(*uint16); ok && l <= 2 {\n\t\t_, err := io.ReadFull(r, buf[2-l:2])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tzero(buf[:2-l])\n\t\t*t = binary.BigEndian.Uint16(buf[:2])\n\t\tif 2-numLeadingZeroBytes16(*t) != l {\n\t\t\treturn ErrTUintNotMinimal\n\t\t}\n\t\treturn nil\n\t}\n\treturn NewTypeForDecodingErr(val, \"uint16\", l, 2)\n}\n\n// numLeadingZeroBytes32 computes the number of leading zeros for a uint32.",
      "length": 379,
      "tokens": 56,
      "embedding": []
    },
    {
      "slug": "func numLeadingZeroBytes32(v uint32) uint64 {",
      "content": "func numLeadingZeroBytes32(v uint32) uint64 {\n\tswitch {\n\tcase v == 0:\n\t\treturn 4\n\tcase v&0xffffff00 == 0:\n\t\treturn 3\n\tcase v&0xffff0000 == 0:\n\t\treturn 2\n\tcase v&0xff000000 == 0:\n\t\treturn 1\n\tdefault:\n\t\treturn 0\n\t}\n}\n\n// SizeTUint32 returns the number of bytes remaining in a uint32 after\n// truncating the leading zeros.",
      "length": 258,
      "tokens": 48,
      "embedding": []
    },
    {
      "slug": "func SizeTUint32(v uint32) uint64 {",
      "content": "func SizeTUint32(v uint32) uint64 {\n\treturn 4 - numLeadingZeroBytes32(v)\n}\n\n// ETUint32 is an Encoder for truncated uint32 values, where leading zeros will\n// be omitted. An error is returned if val is not a *uint32.",
      "length": 176,
      "tokens": 31,
      "embedding": []
    },
    {
      "slug": "func ETUint32(w io.Writer, val interface{}, buf *[8]byte) error {",
      "content": "func ETUint32(w io.Writer, val interface{}, buf *[8]byte) error {\n\tif t, ok := val.(*uint32); ok {\n\t\tbinary.BigEndian.PutUint32(buf[:4], *t)\n\t\tnumZeros := numLeadingZeroBytes32(*t)\n\t\t_, err := w.Write(buf[numZeros:4])\n\t\treturn err\n\t}\n\treturn NewTypeForEncodingErr(val, \"uint32\")\n}\n\n// ETUint32T is an Encoder for truncated uint32 values, where leading zeros will\n// be omitted. An error is returned if val is not a *uint32.",
      "length": 347,
      "tokens": 49,
      "embedding": []
    },
    {
      "slug": "func ETUint32T(w io.Writer, val uint32, buf *[8]byte) error {",
      "content": "func ETUint32T(w io.Writer, val uint32, buf *[8]byte) error {\n\tbinary.BigEndian.PutUint32(buf[:4], val)\n\tnumZeros := numLeadingZeroBytes32(val)\n\t_, err := w.Write(buf[numZeros:4])\n\treturn err\n}\n\n// DTUint32 is an Decoder for truncated uint32 values, where leading zeros will\n// be resurrected. An error is returned if val is not a *uint32.",
      "length": 270,
      "tokens": 38,
      "embedding": []
    },
    {
      "slug": "func DTUint32(r io.Reader, val interface{}, buf *[8]byte, l uint64) error {",
      "content": "func DTUint32(r io.Reader, val interface{}, buf *[8]byte, l uint64) error {\n\tif t, ok := val.(*uint32); ok && l <= 4 {\n\t\t_, err := io.ReadFull(r, buf[4-l:4])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tzero(buf[:4-l])\n\t\t*t = binary.BigEndian.Uint32(buf[:4])\n\t\tif 4-numLeadingZeroBytes32(*t) != l {\n\t\t\treturn ErrTUintNotMinimal\n\t\t}\n\t\treturn nil\n\t}\n\treturn NewTypeForDecodingErr(val, \"uint32\", l, 4)\n}\n\n// numLeadingZeroBytes64 computes the number of leading zeros for a uint64.\n//\n// TODO(conner): optimize using unrolled binary search",
      "length": 435,
      "tokens": 64,
      "embedding": []
    },
    {
      "slug": "func numLeadingZeroBytes64(v uint64) uint64 {",
      "content": "func numLeadingZeroBytes64(v uint64) uint64 {\n\tswitch {\n\tcase v == 0:\n\t\treturn 8\n\tcase v&0xffffffffffffff00 == 0:\n\t\treturn 7\n\tcase v&0xffffffffffff0000 == 0:\n\t\treturn 6\n\tcase v&0xffffffffff000000 == 0:\n\t\treturn 5\n\tcase v&0xffffffff00000000 == 0:\n\t\treturn 4\n\tcase v&0xffffff0000000000 == 0:\n\t\treturn 3\n\tcase v&0xffff000000000000 == 0:\n\t\treturn 2\n\tcase v&0xff00000000000000 == 0:\n\t\treturn 1\n\tdefault:\n\t\treturn 0\n\t}\n}\n\n// SizeTUint64 returns the number of bytes remaining in a uint64 after\n// truncating the leading zeros.",
      "length": 450,
      "tokens": 72,
      "embedding": []
    },
    {
      "slug": "func SizeTUint64(v uint64) uint64 {",
      "content": "func SizeTUint64(v uint64) uint64 {\n\treturn 8 - numLeadingZeroBytes64(v)\n}\n\n// ETUint64 is an Encoder for truncated uint64 values, where leading zeros will\n// be omitted. An error is returned if val is not a *uint64.",
      "length": 176,
      "tokens": 31,
      "embedding": []
    },
    {
      "slug": "func ETUint64(w io.Writer, val interface{}, buf *[8]byte) error {",
      "content": "func ETUint64(w io.Writer, val interface{}, buf *[8]byte) error {\n\tif t, ok := val.(*uint64); ok {\n\t\tbinary.BigEndian.PutUint64(buf[:], *t)\n\t\tnumZeros := numLeadingZeroBytes64(*t)\n\t\t_, err := w.Write(buf[numZeros:])\n\t\treturn err\n\t}\n\treturn NewTypeForEncodingErr(val, \"uint64\")\n}\n\n// ETUint64T is an Encoder for truncated uint64 values, where leading zeros will\n// be omitted. An error is returned if val is not a *uint64.",
      "length": 345,
      "tokens": 49,
      "embedding": []
    },
    {
      "slug": "func ETUint64T(w io.Writer, val uint64, buf *[8]byte) error {",
      "content": "func ETUint64T(w io.Writer, val uint64, buf *[8]byte) error {\n\tbinary.BigEndian.PutUint64(buf[:], val)\n\tnumZeros := numLeadingZeroBytes64(val)\n\t_, err := w.Write(buf[numZeros:])\n\treturn err\n}\n\n// DTUint64 is an Decoder for truncated uint64 values, where leading zeros will\n// be resurrected. An error is returned if val is not a *uint64.",
      "length": 268,
      "tokens": 38,
      "embedding": []
    },
    {
      "slug": "func DTUint64(r io.Reader, val interface{}, buf *[8]byte, l uint64) error {",
      "content": "func DTUint64(r io.Reader, val interface{}, buf *[8]byte, l uint64) error {\n\tif t, ok := val.(*uint64); ok && l <= 8 {\n\t\t_, err := io.ReadFull(r, buf[8-l:])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tzero(buf[:8-l])\n\t\t*t = binary.BigEndian.Uint64(buf[:])\n\t\tif 8-numLeadingZeroBytes64(*t) != l {\n\t\t\treturn ErrTUintNotMinimal\n\t\t}\n\t\treturn nil\n\t}\n\treturn NewTypeForDecodingErr(val, \"uint64\", l, 8)\n}\n\n// zero clears the passed byte slice.",
      "length": 339,
      "tokens": 52,
      "embedding": []
    },
    {
      "slug": "func zero(b []byte) {",
      "content": "func zero(b []byte) {\n\tfor i := range b {\n\t\tb[i] = 0x00\n\t}\n}\n",
      "length": 35,
      "tokens": 11,
      "embedding": []
    }
  ]
}