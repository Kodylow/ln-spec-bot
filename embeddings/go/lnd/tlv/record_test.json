{
  "filepath": "../implementations/go/lnd/tlv/record_test.go",
  "package": "tlv",
  "sections": [
    {
      "slug": "func TestSortRecords(t *testing.T) {",
      "content": "func TestSortRecords(t *testing.T) {\n\tt.Parallel()\n\n\ttestCases := []struct {\n\t\tpreSort  []Record\n\t\tpostSort []Record\n\t}{\n\t\t// An empty slice requires no sorting.\n\t\t{\n\t\t\tpreSort:  []Record{},\n\t\t\tpostSort: []Record{},\n\t\t},\n\n\t\t// An already sorted slice should be passed through.\n\t\t{\n\t\t\tpreSort: []Record{\n\t\t\t\tMakeStaticRecord(1, nil, 0, nil, nil),\n\t\t\t\tMakeStaticRecord(2, nil, 0, nil, nil),\n\t\t\t\tMakeStaticRecord(3, nil, 0, nil, nil),\n\t\t\t},\n\t\t\tpostSort: []Record{\n\t\t\t\tMakeStaticRecord(1, nil, 0, nil, nil),\n\t\t\t\tMakeStaticRecord(2, nil, 0, nil, nil),\n\t\t\t\tMakeStaticRecord(3, nil, 0, nil, nil),\n\t\t\t},\n\t\t},\n\n\t\t// We should be able to sort a randomized set of records .\n\t\t{\n\t\t\tpreSort: []Record{\n\t\t\t\tMakeStaticRecord(9, nil, 0, nil, nil),\n\t\t\t\tMakeStaticRecord(43, nil, 0, nil, nil),\n\t\t\t\tMakeStaticRecord(1, nil, 0, nil, nil),\n\t\t\t\tMakeStaticRecord(0, nil, 0, nil, nil),\n\t\t\t},\n\t\t\tpostSort: []Record{\n\t\t\t\tMakeStaticRecord(0, nil, 0, nil, nil),\n\t\t\t\tMakeStaticRecord(1, nil, 0, nil, nil),\n\t\t\t\tMakeStaticRecord(9, nil, 0, nil, nil),\n\t\t\t\tMakeStaticRecord(43, nil, 0, nil, nil),\n\t\t\t},\n\t\t},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tSortRecords(testCase.preSort)\n\n\t\tif !reflect.DeepEqual(testCase.preSort, testCase.postSort) {\n\t\t\tt.Fatalf(\"#%v: wrong order: expected %v, got %v\", i,\n\t\t\t\tspew.Sdump(testCase.preSort),\n\t\t\t\tspew.Sdump(testCase.postSort))\n\t\t}\n\t}\n}\n\n// TestRecordMapTransformation tests that we're able to properly morph a set of\n// records into a map using TlvRecordsToMap, then the other way around using\n// the MapToTlvRecords method.",
      "length": 1442,
      "tokens": 186,
      "embedding": []
    },
    {
      "slug": "func TestRecordMapTransformation(t *testing.T) {",
      "content": "func TestRecordMapTransformation(t *testing.T) {\n\tt.Parallel()\n\n\ttlvBytes := []byte{1, 2, 3, 4}\n\tencoder := StubEncoder(tlvBytes)\n\n\ttestCases := []struct {\n\t\trecords []Record\n\n\t\ttlvMap map[uint64][]byte\n\t}{\n\t\t// An empty set of records should yield an empty map, and the other\n\t\t// way around.\n\t\t{\n\t\t\trecords: []Record{},\n\t\t\ttlvMap:  map[uint64][]byte{},\n\t\t},\n\n\t\t// We should be able to transform this set of records, then obtain\n\t\t// the records back in the same order.\n\t\t{\n\t\t\trecords: []Record{\n\t\t\t\tMakeStaticRecord(1, nil, 4, encoder, nil),\n\t\t\t\tMakeStaticRecord(2, nil, 4, encoder, nil),\n\t\t\t\tMakeStaticRecord(3, nil, 4, encoder, nil),\n\t\t\t},\n\t\t\ttlvMap: map[uint64][]byte{\n\t\t\t\t1: tlvBytes,\n\t\t\t\t2: tlvBytes,\n\t\t\t\t3: tlvBytes,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tmappedRecords, err := RecordsToMap(testCase.records)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"#%v: unable to map records: %v\", i, err)\n\t\t}\n\n\t\tif !reflect.DeepEqual(mappedRecords, testCase.tlvMap) {\n\t\t\tt.Fatalf(\"#%v: incorrect record map: expected %v, got %v\",\n\t\t\t\ti, spew.Sdump(testCase.tlvMap),\n\t\t\t\tspew.Sdump(mappedRecords))\n\t\t}\n\n\t\tunmappedRecords := MapToRecords(mappedRecords)\n\n\t\tfor i := 0; i < len(testCase.records); i++ {\n\t\t\tif unmappedRecords[i].Type() != testCase.records[i].Type() {\n\t\t\t\tt.Fatalf(\"#%v: wrong type: expected %v, got %v\",\n\t\t\t\t\ti, unmappedRecords[i].Type(),\n\t\t\t\t\ttestCase.records[i].Type())\n\t\t\t}\n\n\t\t\tvar b bytes.Buffer\n\t\t\tif err := unmappedRecords[i].Encode(&b); err != nil {\n\t\t\t\tt.Fatalf(\"#%v: unable to encode record: %v\",\n\t\t\t\t\ti, err)\n\t\t\t}\n\n\t\t\tif !bytes.Equal(b.Bytes(), tlvBytes) {\n\t\t\t\tt.Fatalf(\"#%v: wrong raw record: \"+\n\t\t\t\t\t\"expected %x, got %x\",\n\t\t\t\t\ti, tlvBytes, b.Bytes())\n\t\t\t}\n\n\t\t\tif unmappedRecords[i].Size() != testCase.records[0].Size() {\n\t\t\t\tt.Fatalf(\"#%v: wrong size: expected %v, \"+\n\t\t\t\t\t\"got %v\", i,\n\t\t\t\t\tunmappedRecords[i].Size(),\n\t\t\t\t\ttestCase.records[i].Size())\n\t\t\t}\n\t\t}\n\t}\n}\n",
      "length": 1766,
      "tokens": 219,
      "embedding": []
    }
  ]
}