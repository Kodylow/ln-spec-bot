{
  "filepath": "../implementations/go/lnd/queue/gc_queue_test.go",
  "package": "queue_test",
  "sections": [
    {
      "slug": "type testItem uint32",
      "content": "type testItem uint32\n\n// TestGCQueueGCCycle asserts that items that are kept in the GCQueue past their\n// expiration will be released by a subsequent gc cycle.",
      "length": 136,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func TestGCQueueGCCycle(t *testing.T) {",
      "content": "func TestGCQueueGCCycle(t *testing.T) {\n\tt.Parallel()\n\n\tconst (\n\t\tgcInterval     = time.Second\n\t\texpiryInterval = 250 * time.Millisecond\n\t\tnumItems       = 6\n\t)\n\n\tnewItem := func() interface{} { return new(testItem) }\n\n\tbp := queue.NewGCQueue(newItem, 100, gcInterval, expiryInterval)\n\n\t// Take numItems items from the queue, and immediately return them.\n\t// Returning the items will trigger the gc ticker to start.\n\titemSet1 := takeN(t, bp, numItems)\n\treturnAll(bp, itemSet1)\n\n\t// Allow enough time for all expired items to be released by the queue.\n\t<-time.After(gcInterval + expiryInterval)\n\n\t// Take another set of numItems items from the queue.\n\titemSet2 := takeN(t, bp, numItems)\n\n\t// Since the gc ticker should have elapsed, we expect the intersection\n\t// of sets 1 and 2 to be empty.\n\tfor item := range itemSet2 {\n\t\tif _, ok := itemSet1[item]; ok {\n\t\t\tt.Fatalf(\"items taken should not have been reused\")\n\t\t}\n\t}\n}\n\n// TestGCQueuePartialGCCycle asserts that the GCQueue will only garbage collect\n// the items in its queue that have fully expired. We test this by adding items\n// into the queue such that the garbage collection will occur before the items\n// expire. Taking items after the gc cycle should return the items that were not\n// released by the gc cycle.",
      "length": 1194,
      "tokens": 195,
      "embedding": []
    },
    {
      "slug": "func TestGCQueuePartialGCCycle(t *testing.T) {",
      "content": "func TestGCQueuePartialGCCycle(t *testing.T) {\n\tt.Parallel()\n\n\tconst (\n\t\tgcInterval     = time.Second\n\t\texpiryInterval = 250 * time.Millisecond\n\t\tnumItems       = 6\n\t)\n\n\tnewItem := func() interface{} { return new(testItem) }\n\n\tbp := queue.NewGCQueue(newItem, 100, gcInterval, expiryInterval)\n\n\t// Take numItems items from the gc queue.\n\titemSet1 := takeN(t, bp, numItems)\n\n\t// Immediately return half of the items, and construct a set of items\n\t// consisting of the half that were not returned.\n\thalfItemSet1 := returnN(t, bp, itemSet1, numItems/2)\n\n\t// Wait long enough to ensure that adding subsequent items will not be\n\t// released in the next gc cycle.\n\t<-time.After(gcInterval - expiryInterval/2)\n\n\t// Return the remaining items from itemSet1.\n\treturnAll(bp, halfItemSet1)\n\n\t// Wait until the gc cycle as done a sweep of the items and released all\n\t// those that have expired.\n\t<-time.After(expiryInterval / 2)\n\n\t// Retrieve numItems items from the gc queue.\n\titemSet2 := takeN(t, bp, numItems)\n\n\t// Tally the number of items returned from Take that are in the second\n\t// half of items returned.\n\tvar numReused int\n\tfor item := range itemSet2 {\n\t\tif _, ok := halfItemSet1[item]; ok {\n\t\t\tnumReused++\n\t\t}\n\t}\n\n\t// We expect the number of reused items to be equal to half numItems.\n\tif numReused != numItems/2 {\n\t\tt.Fatalf(\"expected %d items to be reused, got %d\",\n\t\t\tnumItems/2, numReused)\n\t}\n}\n\n// takeN draws n items from the provided GCQueue. This method also asserts that\n// n unique items are drawn, and then returns the resulting set.",
      "length": 1445,
      "tokens": 234,
      "embedding": []
    },
    {
      "slug": "func takeN(t *testing.T, q *queue.GCQueue, n int) map[interface{}]struct{} {",
      "content": "func takeN(t *testing.T, q *queue.GCQueue, n int) map[interface{}]struct{} {\n\tt.Helper()\n\n\titems := make(map[interface{}]struct{})\n\tfor i := 0; i < n; i++ {\n\t\t// Wait a small duration to ensure the tests behave reliable,\n\t\t// and don't activate the non-blocking case unintentionally.\n\t\t<-time.After(time.Millisecond)\n\n\t\titems[q.Take()] = struct{}{}\n\t}\n\n\tif len(items) != n {\n\t\tt.Fatalf(\"items taken from gc queue should be distinct, \"+\n\t\t\t\"want %d unique items, got %d\", n, len(items))\n\t}\n\n\treturn items\n}\n\n// returnAll returns the items of the given set back to the GCQueue.",
      "length": 479,
      "tokens": 76,
      "embedding": []
    },
    {
      "slug": "func returnAll(q *queue.GCQueue, items map[interface{}]struct{}) {",
      "content": "func returnAll(q *queue.GCQueue, items map[interface{}]struct{}) {\n\tfor item := range items {\n\t\tq.Return(item)\n\n\t\t// Wait a small duration to ensure the tests behave reliable,\n\t\t// and don't activate the non-blocking case unintentionally.\n\t\t<-time.After(time.Millisecond)\n\t}\n}\n\n// returnN returns n items at random from the set of items back to the GCQueue.\n// This method fails if the set's cardinality is smaller than n.",
      "length": 345,
      "tokens": 57,
      "embedding": []
    },
    {
      "slug": "func returnN(t *testing.T, q *queue.GCQueue,",
      "content": "func returnN(t *testing.T, q *queue.GCQueue,\n\titems map[interface{}]struct{}, n int) map[interface{}]struct{} {\n\n\tt.Helper()\n\n\tvar remainingItems = make(map[interface{}]struct{})\n\tvar numReturned int\n\tfor item := range items {\n\t\tif numReturned < n {\n\t\t\tq.Return(item)\n\t\t\tnumReturned++\n\n\t\t\t// Wait a small duration to ensure the tests behave\n\t\t\t// reliable, and don't activate the non-blocking case\n\t\t\t// unintentionally.\n\t\t\t<-time.After(time.Millisecond)\n\t\t} else {\n\t\t\tremainingItems[item] = struct{}{}\n\t\t}\n\t}\n\n\tif numReturned < n {\n\t\tt.Fatalf(\"insufficient number of items to return, need %d, \"+\n\t\t\t\"got %d\", n, numReturned)\n\t}\n\n\treturn remainingItems\n}\n",
      "length": 583,
      "tokens": 78,
      "embedding": []
    }
  ]
}