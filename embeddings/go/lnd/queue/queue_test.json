{
  "filepath": "../implementations/go/lnd/queue/queue_test.go",
  "package": "queue_test",
  "sections": [
    {
      "slug": "func testQueueAddDrain(t *testing.T, size, numStart, numStop, numAdd, numDrain int) {",
      "content": "func testQueueAddDrain(t *testing.T, size, numStart, numStop, numAdd, numDrain int) {\n\tt.Helper()\n\n\tqueue := queue.NewConcurrentQueue(size)\n\tfor i := 0; i < numStart; i++ {\n\t\tqueue.Start()\n\t}\n\tfor i := 0; i < numStop; i++ {\n\t\tt.Cleanup(queue.Stop)\n\t}\n\n\t// Pushes should never block for long.\n\tfor i := 0; i < numAdd; i++ {\n\t\tqueue.ChanIn() <- i\n\t}\n\n\t// Pops also should not block for long. Expect elements in FIFO order.\n\tfor i := 0; i < numDrain; i++ {\n\t\titem := <-queue.ChanOut()\n\t\tif i != item.(int) {\n\t\t\tt.Fatalf(\"Dequeued wrong value: expected %d, got %d\",\n\t\t\t\ti, item.(int))\n\t\t}\n\t}\n}\n\n// TestConcurrentQueue tests that the queue properly adds 1000 items, drain all\n// of them, and exit cleanly.",
      "length": 588,
      "tokens": 106,
      "embedding": []
    },
    {
      "slug": "func TestConcurrentQueue(t *testing.T) {",
      "content": "func TestConcurrentQueue(t *testing.T) {\n\tt.Parallel()\n\n\ttestQueueAddDrain(t, 100, 1, 1, 1000, 1000)\n}\n\n// TestConcurrentQueueEarlyStop tests that the queue properly adds 1000 items,\n// drain half of them, and still exit cleanly.",
      "length": 182,
      "tokens": 27,
      "embedding": []
    },
    {
      "slug": "func TestConcurrentQueueEarlyStop(t *testing.T) {",
      "content": "func TestConcurrentQueueEarlyStop(t *testing.T) {\n\tt.Parallel()\n\n\ttestQueueAddDrain(t, 100, 1, 1, 1000, 500)\n}\n\n// TestConcurrentQueueIdempotentStart asserts that calling Start multiple times\n// doesn't fail, and that the queue can still exit cleanly.",
      "length": 195,
      "tokens": 27,
      "embedding": []
    },
    {
      "slug": "func TestConcurrentQueueIdempotentStart(t *testing.T) {",
      "content": "func TestConcurrentQueueIdempotentStart(t *testing.T) {\n\tt.Parallel()\n\n\ttestQueueAddDrain(t, 100, 10, 1, 1000, 1000)\n}\n\n// TestConcurrentQueueIdempotentStop asserts that calling Stop multiple times\n// doesn't fail, and that exiting doesn't block on subsequent Stops.",
      "length": 204,
      "tokens": 27,
      "embedding": []
    },
    {
      "slug": "func TestConcurrentQueueIdempotentStop(t *testing.T) {",
      "content": "func TestConcurrentQueueIdempotentStop(t *testing.T) {\n\tt.Parallel()\n\n\ttestQueueAddDrain(t, 100, 1, 10, 1000, 1000)\n}\n\n// TestQueueCloseIncoming tests that the queue properly handles an incoming\n// channel that is closed.",
      "length": 160,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func TestQueueCloseIncoming(t *testing.T) {",
      "content": "func TestQueueCloseIncoming(t *testing.T) {\n\tt.Parallel()\n\n\tqueue := queue.NewConcurrentQueue(10)\n\tqueue.Start()\n\n\tqueue.ChanIn() <- 1\n\tclose(queue.ChanIn())\n\n\titem := <-queue.ChanOut()\n\tif item.(int) != 1 {\n\t\tt.Fatalf(\"unexpected item\")\n\t}\n\n\t_, ok := <-queue.ChanOut()\n\tif ok {\n\t\tt.Fatalf(\"expected outgoing channel being closed\")\n\t}\n}\n",
      "length": 275,
      "tokens": 34,
      "embedding": []
    }
  ]
}