{
  "filepath": "../implementations/go/lnd/lntest/harness_node_manager.go",
  "package": "lntest",
  "sections": [
    {
      "slug": "type nodeManager struct {",
      "content": "type nodeManager struct {\n\tsync.Mutex\n\n\t// chainBackend houses the information necessary to use a node as LND\n\t// chain backend, such as rpc configuration, P2P information etc.\n\tchainBackend node.BackendConfig\n\n\t// currentTestCase holds the name for the currently run test case.\n\tcurrentTestCase string\n\n\t// lndBinary is the full path to the lnd binary that was specifically\n\t// compiled with all required itest flags.\n\tlndBinary string\n\n\t// dbBackend sets the database backend to use.\n\tdbBackend node.DatabaseBackend\n\n\t// activeNodes is a map of all running nodes, format:\n\t// {pubkey: *HarnessNode}.\n\tactiveNodes map[uint32]*node.HarnessNode\n\n\t// standbyNodes is a map of all the standby nodes, format:\n\t// {pubkey: *HarnessNode}.\n\tstandbyNodes map[uint32]*node.HarnessNode\n\n\t// nodeCounter is a monotonically increasing counter that's used as the\n\t// node's unique ID.\n\tnodeCounter uint32\n\n\t// feeServiceURL is the url of the fee service.\n\tfeeServiceURL string\n}\n\n// newNodeManager creates a new node manager instance.",
      "length": 963,
      "tokens": 138,
      "embedding": []
    },
    {
      "slug": "func newNodeManager(lndBinary string,",
      "content": "func newNodeManager(lndBinary string,\n\tdbBackend node.DatabaseBackend) *nodeManager {\n\n\treturn &nodeManager{\n\t\tlndBinary:    lndBinary,\n\t\tdbBackend:    dbBackend,\n\t\tactiveNodes:  make(map[uint32]*node.HarnessNode),\n\t\tstandbyNodes: make(map[uint32]*node.HarnessNode),\n\t}\n}\n\n// nextNodeID generates a unique sequence to be used as the node's ID.",
      "length": 295,
      "tokens": 29,
      "embedding": []
    },
    {
      "slug": "func (nm *nodeManager) nextNodeID() uint32 {",
      "content": "func (nm *nodeManager) nextNodeID() uint32 {\n\tnodeID := atomic.AddUint32(&nm.nodeCounter, 1)\n\treturn nodeID - 1\n}\n\n// newNode initializes a new HarnessNode, supporting the ability to initialize\n// a wallet with or without a seed. If useSeed is false, the returned harness\n// node can be used immediately. Otherwise, the node will require an additional\n// initialization phase where the wallet is either created or restored.",
      "length": 371,
      "tokens": 59,
      "embedding": []
    },
    {
      "slug": "func (nm *nodeManager) newNode(t *testing.T, name string, extraArgs []string,",
      "content": "func (nm *nodeManager) newNode(t *testing.T, name string, extraArgs []string,\n\tpassword []byte, noAuth bool) (*node.HarnessNode, error) {\n\n\tcfg := &node.BaseNodeConfig{\n\t\tName:              name,\n\t\tLogFilenamePrefix: nm.currentTestCase,\n\t\tPassword:          password,\n\t\tBackendCfg:        nm.chainBackend,\n\t\tExtraArgs:         extraArgs,\n\t\tFeeURL:            nm.feeServiceURL,\n\t\tDBBackend:         nm.dbBackend,\n\t\tNodeID:            nm.nextNodeID(),\n\t\tLndBinary:         nm.lndBinary,\n\t\tNetParams:         harnessNetParams,\n\t\tSkipUnlock:        noAuth,\n\t}\n\n\tnode, err := node.NewHarnessNode(t, cfg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Put node in activeNodes to ensure Shutdown is called even if start\n\t// returns an error.\n\tnm.registerNode(node)\n\n\treturn node, nil\n}\n\n// RegisterNode records a new HarnessNode in the NetworkHarnesses map of known\n// nodes. This method should only be called with nodes that have successfully\n// retrieved their public keys via FetchNodeInfo.",
      "length": 874,
      "tokens": 101,
      "embedding": []
    },
    {
      "slug": "func (nm *nodeManager) registerNode(node *node.HarnessNode) {",
      "content": "func (nm *nodeManager) registerNode(node *node.HarnessNode) {\n\tnm.Lock()\n\tnm.activeNodes[node.Cfg.NodeID] = node\n\tnm.Unlock()\n}\n\n// ShutdownNode stops an active lnd process and returns when the process has\n// exited and any temporary directories have been cleaned up.",
      "length": 199,
      "tokens": 29,
      "embedding": []
    },
    {
      "slug": "func (nm *nodeManager) shutdownNode(node *node.HarnessNode) error {",
      "content": "func (nm *nodeManager) shutdownNode(node *node.HarnessNode) error {\n\tif err := node.Shutdown(); err != nil {\n\t\treturn err\n\t}\n\n\tdelete(nm.activeNodes, node.Cfg.NodeID)\n\treturn nil\n}\n\n// restartNode attempts to restart a lightning node by shutting it down\n// cleanly, then restarting the process. This function is fully blocking. Upon\n// restart, the RPC connection to the node will be re-attempted, continuing iff\n// the connection attempt is successful. If the callback parameter is non-nil,\n// then the function will be executed after the node shuts down, but *before*\n// the process has been started up again.",
      "length": 530,
      "tokens": 87,
      "embedding": []
    },
    {
      "slug": "func (nm *nodeManager) restartNode(ctxt context.Context,",
      "content": "func (nm *nodeManager) restartNode(ctxt context.Context,\n\thn *node.HarnessNode, callback func() error) error {\n\n\t// Stop the node.\n\tif err := hn.Stop(); err != nil {\n\t\treturn fmt.Errorf(\"restart node got error: %w\", err)\n\t}\n\n\tif callback != nil {\n\t\tif err := callback(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Start the node without unlocking the wallet.\n\tif hn.Cfg.SkipUnlock {\n\t\treturn hn.StartWithNoAuth(ctxt)\n\t}\n\n\treturn hn.Start(ctxt)\n}\n\n// unlockNode unlocks the node's wallet if the password is configured.\n// Additionally, each time the node is unlocked, the caller can pass a set of\n// SCBs to pass in via the Unlock method allowing them to restore channels\n// during restart.",
      "length": 604,
      "tokens": 104,
      "embedding": []
    },
    {
      "slug": "func (nm *nodeManager) unlockNode(hn *node.HarnessNode,",
      "content": "func (nm *nodeManager) unlockNode(hn *node.HarnessNode,\n\tchanBackups ...*lnrpc.ChanBackupSnapshot) error {\n\n\t// If the node doesn't have a password set, then we can exit here as we\n\t// don't need to unlock it.\n\tif len(hn.Cfg.Password) == 0 {\n\t\treturn nil\n\t}\n\n\t// Otherwise, we'll unlock the wallet, then complete the final steps\n\t// for the node initialization process.\n\tunlockReq := &lnrpc.UnlockWalletRequest{\n\t\tWalletPassword: hn.Cfg.Password,\n\t}\n\tif len(chanBackups) != 0 {\n\t\tunlockReq.ChannelBackups = chanBackups[0]\n\t\tunlockReq.RecoveryWindow = 100\n\t}\n\n\terr := wait.NoError(func() error {\n\t\treturn hn.Unlock(unlockReq)\n\t}, DefaultTimeout)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s: failed to unlock: %w\", hn.Name(), err)\n\t}\n\n\treturn nil\n}\n\n// initWalletAndNode will unlock the node's wallet and finish setting up the\n// node so it's ready to take RPC requests.",
      "length": 780,
      "tokens": 116,
      "embedding": []
    },
    {
      "slug": "func (nm *nodeManager) initWalletAndNode(hn *node.HarnessNode,",
      "content": "func (nm *nodeManager) initWalletAndNode(hn *node.HarnessNode,\n\treq *lnrpc.InitWalletRequest) ([]byte, error) {\n\n\t// Pass the init request via rpc to finish unlocking the node.\n\tresp := hn.RPC.InitWallet(req)\n\n\t// Now that the wallet is unlocked, before creating an authed\n\t// connection we will close the old unauthed connection.\n\tif err := hn.CloseConn(); err != nil {\n\t\treturn nil, fmt.Errorf(\"close unauthed conn failed\")\n\t}\n\n\t// Init the node, which will create the authed grpc conn and all its\n\t// rpc clients.\n\terr := hn.InitNode(resp.AdminMacaroon)\n\n\t// In stateless initialization mode we get a macaroon back that we have\n\t// to return to the test, otherwise gRPC calls won't be possible since\n\t// there are no macaroon files created in that mode.\n\t// In stateful init the admin macaroon will just be nil.\n\treturn resp.AdminMacaroon, err\n}\n",
      "length": 765,
      "tokens": 126,
      "embedding": []
    }
  ]
}