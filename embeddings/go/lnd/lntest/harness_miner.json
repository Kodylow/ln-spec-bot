{
  "filepath": "../implementations/go/lnd/lntest/harness_miner.go",
  "package": "lntest",
  "sections": [
    {
      "slug": "type HarnessMiner struct {",
      "content": "type HarnessMiner struct {\n\t*testing.T\n\t*rpctest.Harness\n\n\t// runCtx is a context with cancel method. It's used to signal when the\n\t// node needs to quit, and used as the parent context when spawning\n\t// children contexts for RPC requests.\n\trunCtx context.Context //nolint:containedctx\n\tcancel context.CancelFunc\n\n\t// logPath is the directory path of the miner's logs.\n\tlogPath string\n\n\t// logFilename is the saved log filename of the miner node.\n\tlogFilename string\n}\n\n// NewMiner creates a new miner using btcd backend with the default log file\n// dir and name.",
      "length": 519,
      "tokens": 84,
      "embedding": []
    },
    {
      "slug": "func NewMiner(ctxt context.Context, t *testing.T) *HarnessMiner {",
      "content": "func NewMiner(ctxt context.Context, t *testing.T) *HarnessMiner {\n\tt.Helper()\n\treturn newMiner(ctxt, t, minerLogDir, minerLogFilename)\n}\n\n// NewTempMiner creates a new miner using btcd backend with the specified log\n// file dir and name.",
      "length": 166,
      "tokens": 25,
      "embedding": []
    },
    {
      "slug": "func NewTempMiner(ctxt context.Context, t *testing.T,",
      "content": "func NewTempMiner(ctxt context.Context, t *testing.T,\n\ttempDir, tempLogFilename string) *HarnessMiner {\n\n\tt.Helper()\n\n\treturn newMiner(ctxt, t, tempDir, tempLogFilename)\n}\n\n// newMiner creates a new miner using btcd's rpctest.",
      "length": 165,
      "tokens": 21,
      "embedding": []
    },
    {
      "slug": "func newMiner(ctxb context.Context, t *testing.T, minerDirName,",
      "content": "func newMiner(ctxb context.Context, t *testing.T, minerDirName,\n\tlogFilename string) *HarnessMiner {\n\n\tt.Helper()\n\n\thandler := &rpcclient.NotificationHandlers{}\n\tbtcdBinary := node.GetBtcdBinary()\n\tbaseLogPath := fmt.Sprintf(\"%s/%s\", node.GetLogDir(), minerDirName)\n\n\targs := []string{\n\t\t\"--rejectnonstd\",\n\t\t\"--txindex\",\n\t\t\"--nowinservice\",\n\t\t\"--nobanning\",\n\t\t\"--debuglevel=debug\",\n\t\t\"--logdir=\" + baseLogPath,\n\t\t\"--trickleinterval=100ms\",\n\t\t// Don't disconnect if a reply takes too long.\n\t\t\"--nostalldetect\",\n\t}\n\n\tminer, err := rpctest.New(harnessNetParams, handler, args, btcdBinary)\n\trequire.NoError(t, err, \"unable to create mining node\")\n\n\tctxt, cancel := context.WithCancel(ctxb)\n\n\treturn &HarnessMiner{\n\t\tT:           t,\n\t\tHarness:     miner,\n\t\trunCtx:      ctxt,\n\t\tcancel:      cancel,\n\t\tlogPath:     baseLogPath,\n\t\tlogFilename: logFilename,\n\t}\n}\n\n// saveLogs copies the node logs and save it to the file specified by\n// h.logFilename.",
      "length": 843,
      "tokens": 89,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessMiner) saveLogs() {",
      "content": "func (h *HarnessMiner) saveLogs() {\n\t// After shutting down the miner, we'll make a copy of the log files\n\t// before deleting the temporary log dir.\n\tpath := fmt.Sprintf(\"%s/%s\", h.logPath, harnessNetParams.Name)\n\tfiles, err := ioutil.ReadDir(path)\n\trequire.NoError(h, err, \"unable to read log directory\")\n\n\tfor _, file := range files {\n\t\tnewFilename := strings.Replace(\n\t\t\tfile.Name(), \"btcd.log\", h.logFilename, 1,\n\t\t)\n\t\tcopyPath := fmt.Sprintf(\"%s/../%s\", h.logPath, newFilename)\n\n\t\tlogFile := fmt.Sprintf(\"%s/%s\", path, file.Name())\n\t\terr := CopyFile(filepath.Clean(copyPath), logFile)\n\t\trequire.NoError(h, err, \"unable to copy file\")\n\t}\n\n\terr = os.RemoveAll(h.logPath)\n\trequire.NoErrorf(h, err, \"cannot remove dir %s\", h.logPath)\n}\n\n// Stop shuts down the miner and saves its logs.",
      "length": 729,
      "tokens": 94,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessMiner) Stop() {",
      "content": "func (h *HarnessMiner) Stop() {\n\th.cancel()\n\trequire.NoError(h, h.TearDown(), \"tear down miner got error\")\n\th.saveLogs()\n}\n\n// GetBestBlock makes a RPC request to miner and asserts.",
      "length": 144,
      "tokens": 20,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessMiner) GetBestBlock() (*chainhash.Hash, int32) {",
      "content": "func (h *HarnessMiner) GetBestBlock() (*chainhash.Hash, int32) {\n\tblockHash, height, err := h.Client.GetBestBlock()\n\trequire.NoError(h, err, \"failed to GetBestBlock\")\n\n\treturn blockHash, height\n}\n\n// GetRawMempool makes a RPC call to the miner's GetRawMempool and\n// asserts.",
      "length": 203,
      "tokens": 27,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessMiner) GetRawMempool() []*chainhash.Hash {",
      "content": "func (h *HarnessMiner) GetRawMempool() []*chainhash.Hash {\n\tmempool, err := h.Client.GetRawMempool()\n\trequire.NoError(h, err, \"unable to get mempool\")\n\n\treturn mempool\n}\n\n// GenerateBlocks mine 'num' of blocks and returns them.",
      "length": 162,
      "tokens": 22,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessMiner) GenerateBlocks(num uint32) []*chainhash.Hash {",
      "content": "func (h *HarnessMiner) GenerateBlocks(num uint32) []*chainhash.Hash {\n\tblockHashes, err := h.Client.Generate(num)\n\trequire.NoError(h, err, \"unable to generate blocks\")\n\trequire.Len(h, blockHashes, int(num), \"wrong num of blocks generated\")\n\n\treturn blockHashes\n}\n\n// GetBlock gets a block using its block hash.",
      "length": 233,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessMiner) GetBlock(blockHash *chainhash.Hash) *wire.MsgBlock {",
      "content": "func (h *HarnessMiner) GetBlock(blockHash *chainhash.Hash) *wire.MsgBlock {\n\tblock, err := h.Client.GetBlock(blockHash)\n\trequire.NoError(h, err, \"unable to get block\")\n\n\treturn block\n}\n\n// MineBlocks mine 'num' of blocks and check that blocks are present in\n// node blockchain.",
      "length": 194,
      "tokens": 29,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessMiner) MineBlocks(num uint32) []*wire.MsgBlock {",
      "content": "func (h *HarnessMiner) MineBlocks(num uint32) []*wire.MsgBlock {\n\tblocks := make([]*wire.MsgBlock, num)\n\n\tblockHashes := h.GenerateBlocks(num)\n\n\tfor i, blockHash := range blockHashes {\n\t\tblock := h.GetBlock(blockHash)\n\t\tblocks[i] = block\n\t}\n\n\treturn blocks\n}\n\n// AssertNumTxsInMempool polls until finding the desired number of transactions\n// in the provided miner's mempool. It will asserrt if this number is not met\n// after the given timeout.",
      "length": 366,
      "tokens": 54,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessMiner) AssertNumTxsInMempool(n int) []*chainhash.Hash {",
      "content": "func (h *HarnessMiner) AssertNumTxsInMempool(n int) []*chainhash.Hash {\n\tvar (\n\t\tmem []*chainhash.Hash\n\t\terr error\n\t)\n\n\terr = wait.NoError(func() error {\n\t\t// We require the RPC call to be succeeded and won't wait for\n\t\t// it as it's an unexpected behavior.\n\t\tmem = h.GetRawMempool()\n\t\tif len(mem) == n {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn fmt.Errorf(\"want %v, got %v in mempool: %v\",\n\t\t\tn, len(mem), mem)\n\t}, wait.MinerMempoolTimeout)\n\trequire.NoError(h, err, \"assert tx in mempool timeout\")\n\n\treturn mem\n}\n\n// AssertTxInBlock asserts that a given txid can be found in the passed block.",
      "length": 487,
      "tokens": 80,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessMiner) AssertTxInBlock(block *wire.MsgBlock,",
      "content": "func (h *HarnessMiner) AssertTxInBlock(block *wire.MsgBlock,\n\ttxid *chainhash.Hash) {\n\n\tblockTxes := make([]chainhash.Hash, 0)\n\n\tfor _, tx := range block.Transactions {\n\t\tsha := tx.TxHash()\n\t\tblockTxes = append(blockTxes, sha)\n\n\t\tif bytes.Equal(txid[:], sha[:]) {\n\t\t\treturn\n\t\t}\n\t}\n\n\trequire.Failf(h, \"tx was not included in block\", \"tx:%v, block has:%v\",\n\t\ttxid, blockTxes)\n}\n\n// MineBlocksAndAssertNumTxes mine 'num' of blocks and check that blocks are\n// present in node blockchain. numTxs should be set to the number of\n// transactions (excluding the coinbase) we expect to be included in the first\n// mined block.",
      "length": 536,
      "tokens": 81,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessMiner) MineBlocksAndAssertNumTxes(num uint32,",
      "content": "func (h *HarnessMiner) MineBlocksAndAssertNumTxes(num uint32,\n\tnumTxs int) []*wire.MsgBlock {\n\n\t// If we expect transactions to be included in the blocks we'll mine,\n\t// we wait here until they are seen in the miner's mempool.\n\ttxids := h.AssertNumTxsInMempool(numTxs)\n\n\t// Mine blocks.\n\tblocks := h.MineBlocks(num)\n\n\t// Finally, assert that all the transactions were included in the first\n\t// block.\n\tfor _, txid := range txids {\n\t\th.AssertTxInBlock(blocks[0], txid)\n\t}\n\n\treturn blocks\n}\n\n// GetRawTransaction makes a RPC call to the miner's GetRawTransaction and\n// asserts.",
      "length": 495,
      "tokens": 78,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessMiner) GetRawTransaction(txid *chainhash.Hash) *btcutil.Tx {",
      "content": "func (h *HarnessMiner) GetRawTransaction(txid *chainhash.Hash) *btcutil.Tx {\n\ttx, err := h.Client.GetRawTransaction(txid)\n\trequire.NoErrorf(h, err, \"failed to get raw tx: %v\", txid)\n\treturn tx\n}\n\n// GetRawTransactionVerbose makes a RPC call to the miner's\n// GetRawTransactionVerbose and asserts.",
      "length": 213,
      "tokens": 29,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessMiner) GetRawTransactionVerbose(",
      "content": "func (h *HarnessMiner) GetRawTransactionVerbose(\n\ttxid *chainhash.Hash) *btcjson.TxRawResult {\n\n\ttx, err := h.Client.GetRawTransactionVerbose(txid)\n\trequire.NoErrorf(h, err, \"failed to get raw tx verbose: %v\", txid)\n\treturn tx\n}\n\n// AssertTxInMempool asserts a given transaction can be found in the mempool.",
      "length": 251,
      "tokens": 33,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessMiner) AssertTxInMempool(txid *chainhash.Hash) *wire.MsgTx {",
      "content": "func (h *HarnessMiner) AssertTxInMempool(txid *chainhash.Hash) *wire.MsgTx {\n\tvar msgTx *wire.MsgTx\n\n\terr := wait.NoError(func() error {\n\t\t// We require the RPC call to be succeeded and won't wait for\n\t\t// it as it's an unexpected behavior.\n\t\tmempool := h.GetRawMempool()\n\n\t\tif len(mempool) == 0 {\n\t\t\treturn fmt.Errorf(\"empty mempool\")\n\t\t}\n\n\t\tfor _, memTx := range mempool {\n\t\t\t// Check the values are equal.\n\t\t\tif *memTx == *txid {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\n\t\treturn fmt.Errorf(\"txid %v not found in mempool: %v\", txid,\n\t\t\tmempool)\n\t}, wait.MinerMempoolTimeout)\n\n\trequire.NoError(h, err, \"timeout checking mempool\")\n\n\treturn msgTx\n}\n\n// SendOutputsWithoutChange uses the miner to send the given outputs using the\n// specified fee rate and returns the txid.",
      "length": 651,
      "tokens": 102,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessMiner) SendOutputsWithoutChange(outputs []*wire.TxOut,",
      "content": "func (h *HarnessMiner) SendOutputsWithoutChange(outputs []*wire.TxOut,\n\tfeeRate btcutil.Amount) *chainhash.Hash {\n\n\ttxid, err := h.Harness.SendOutputsWithoutChange(\n\t\toutputs, feeRate,\n\t)\n\trequire.NoErrorf(h, err, \"failed to send output\")\n\n\treturn txid\n}\n\n// CreateTransaction uses the miner to create a transaction using the given\n// outputs using the specified fee rate and returns the transaction.",
      "length": 318,
      "tokens": 43,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessMiner) CreateTransaction(outputs []*wire.TxOut,",
      "content": "func (h *HarnessMiner) CreateTransaction(outputs []*wire.TxOut,\n\tfeeRate btcutil.Amount) *wire.MsgTx {\n\n\ttx, err := h.Harness.CreateTransaction(outputs, feeRate, false)\n\trequire.NoErrorf(h, err, \"failed to create transaction\")\n\n\treturn tx\n}\n\n// SendOutput creates, signs, and finally broadcasts a transaction spending\n// the harness' available mature coinbase outputs to create the new output.",
      "length": 320,
      "tokens": 41,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessMiner) SendOutput(newOutput *wire.TxOut,",
      "content": "func (h *HarnessMiner) SendOutput(newOutput *wire.TxOut,\n\tfeeRate btcutil.Amount) *chainhash.Hash {\n\n\thash, err := h.Harness.SendOutputs([]*wire.TxOut{newOutput}, feeRate)\n\trequire.NoErrorf(h, err, \"failed to send outputs\")\n\n\treturn hash\n}\n\n// MineBlocksSlow mines 'num' of blocks. Between each mined block an artificial\n// delay is introduced to give all network participants time to catch up.",
      "length": 328,
      "tokens": 43,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessMiner) MineBlocksSlow(num uint32) []*wire.MsgBlock {",
      "content": "func (h *HarnessMiner) MineBlocksSlow(num uint32) []*wire.MsgBlock {\n\tblocks := make([]*wire.MsgBlock, num)\n\tblockHashes := make([]*chainhash.Hash, 0, num)\n\n\tfor i := uint32(0); i < num; i++ {\n\t\tgeneratedHashes := h.GenerateBlocks(1)\n\t\tblockHashes = append(blockHashes, generatedHashes...)\n\n\t\ttime.Sleep(slowMineDelay)\n\t}\n\n\tfor i, blockHash := range blockHashes {\n\t\tblock, err := h.Client.GetBlock(blockHash)\n\t\trequire.NoError(h, err, \"get blocks\")\n\n\t\tblocks[i] = block\n\t}\n\n\treturn blocks\n}\n\n// AssertOutpointInMempool asserts a given outpoint can be found in the mempool.",
      "length": 483,
      "tokens": 61,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessMiner) AssertOutpointInMempool(op wire.OutPoint) *wire.MsgTx {",
      "content": "func (h *HarnessMiner) AssertOutpointInMempool(op wire.OutPoint) *wire.MsgTx {\n\tvar msgTx *wire.MsgTx\n\n\terr := wait.NoError(func() error {\n\t\t// We require the RPC call to be succeeded and won't wait for\n\t\t// it as it's an unexpected behavior.\n\t\tmempool := h.GetRawMempool()\n\n\t\tif len(mempool) == 0 {\n\t\t\treturn fmt.Errorf(\"empty mempool\")\n\t\t}\n\n\t\tfor _, txid := range mempool {\n\t\t\t// We don't use `ht.Miner.GetRawTransaction` which\n\t\t\t// asserts a txid must be found. While iterating here,\n\t\t\t// the actual mempool state might have been changed,\n\t\t\t// causing a given txid being removed and cannot be\n\t\t\t// found. For instance, the aggregation logic used in\n\t\t\t// sweeping HTLC outputs will update the mempool by\n\t\t\t// replacing the HTLC spending txes with a single one.\n\t\t\ttx, err := h.Client.GetRawTransaction(txid)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tmsgTx = tx.MsgTx()\n\t\t\tfor _, txIn := range msgTx.TxIn {\n\t\t\t\tif txIn.PreviousOutPoint == op {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn fmt.Errorf(\"outpoint %v not found in mempool\", op)\n\t}, wait.MinerMempoolTimeout)\n\n\trequire.NoError(h, err, \"timeout checking mempool\")\n\n\treturn msgTx\n}\n\n// GetNumTxsFromMempool polls until finding the desired number of transactions\n// in the miner's mempool and returns the full transactions to the caller.",
      "length": 1179,
      "tokens": 183,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessMiner) GetNumTxsFromMempool(n int) []*wire.MsgTx {",
      "content": "func (h *HarnessMiner) GetNumTxsFromMempool(n int) []*wire.MsgTx {\n\ttxids := h.AssertNumTxsInMempool(n)\n\n\tvar txes []*wire.MsgTx\n\tfor _, txid := range txids {\n\t\ttx := h.GetRawTransaction(txid)\n\t\ttxes = append(txes, tx.MsgTx())\n\t}\n\n\treturn txes\n}\n\n// NewMinerAddress creates a new address for the miner and asserts.",
      "length": 236,
      "tokens": 35,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessMiner) NewMinerAddress() btcutil.Address {",
      "content": "func (h *HarnessMiner) NewMinerAddress() btcutil.Address {\n\taddr, err := h.NewAddress()\n\trequire.NoError(h, err, \"failed to create new miner address\")\n\treturn addr\n}\n\n// MineBlocksWithTxes mines a single block to include the specifies\n// transactions only.",
      "length": 191,
      "tokens": 28,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessMiner) MineBlockWithTxes(txes []*btcutil.Tx) *wire.MsgBlock {",
      "content": "func (h *HarnessMiner) MineBlockWithTxes(txes []*btcutil.Tx) *wire.MsgBlock {\n\tvar emptyTime time.Time\n\n\t// Generate a block.\n\tb, err := h.GenerateAndSubmitBlock(txes, -1, emptyTime)\n\trequire.NoError(h, err, \"unable to mine block\")\n\n\tblock, err := h.Client.GetBlock(b.Hash())\n\trequire.NoError(h, err, \"unable to get block\")\n\n\treturn block\n}\n\n// MineEmptyBlocks mines a given number of empty blocks.",
      "length": 308,
      "tokens": 41,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessMiner) MineEmptyBlocks(num int) []*wire.MsgBlock {",
      "content": "func (h *HarnessMiner) MineEmptyBlocks(num int) []*wire.MsgBlock {\n\tvar emptyTime time.Time\n\n\tblocks := make([]*wire.MsgBlock, num)\n\tfor i := 0; i < num; i++ {\n\t\t// Generate an empty block.\n\t\tb, err := h.GenerateAndSubmitBlock(nil, -1, emptyTime)\n\t\trequire.NoError(h, err, \"unable to mine empty block\")\n\n\t\tblock := h.GetBlock(b.Hash())\n\t\tblocks[i] = block\n\t}\n\n\treturn blocks\n}\n",
      "length": 296,
      "tokens": 44,
      "embedding": []
    }
  ]
}