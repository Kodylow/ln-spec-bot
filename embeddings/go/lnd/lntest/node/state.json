{
  "filepath": "../implementations/go/lnd/lntest/node/state.go",
  "package": "node",
  "sections": [
    {
      "slug": "type (",
      "content": "type (\n\t// PolicyUpdate defines a type to store channel policy updates for a\n\t// given advertisingNode. It has the format,\n\t// {\"advertisingNode\": [policy1, policy2, ...]}.\n\tPolicyUpdate map[string][]*PolicyUpdateInfo\n\n\t// policyUpdateMap defines a type to store channel policy updates. It\n\t// has the format,\n\t// {\n\t//  \"chanPoint1\": {\n\t//       \"advertisingNode1\": [\n\t//              policy1, policy2, ...\n\t//       ],\n\t//       \"advertisingNode2\": [\n\t//              policy1, policy2, ...\n\t//       ]\n\t//  },\n\t//  \"chanPoint2\": ...\n\t// }.\n\tpolicyUpdateMap map[string]map[string][]*lnrpc.RoutingPolicy\n)\n\n// PolicyUpdateInfo stores the RoutingPolicy plus the connecting node info.",
      "length": 654,
      "tokens": 84,
      "embedding": []
    },
    {
      "slug": "type PolicyUpdateInfo struct {",
      "content": "type PolicyUpdateInfo struct {\n\t*lnrpc.RoutingPolicy\n\n\t// ConnectingNode specifies the node that is connected with the\n\t// advertising node.\n\tConnectingNode string `json:\"connecting_node\"`\n\n\t// Timestamp records the time the policy update is made.\n\tTimestamp time.Time `json:\"timestamp\"`\n}\n\n// OpenChannelUpdate stores the open channel updates.",
      "length": 303,
      "tokens": 38,
      "embedding": []
    },
    {
      "slug": "type OpenChannelUpdate struct {",
      "content": "type OpenChannelUpdate struct {\n\t// AdvertisingNode specifies the node that advertised this update.\n\tAdvertisingNode string `json:\"advertising_node\"`\n\n\t// ConnectingNode specifies the node that is connected with the\n\t// advertising node.\n\tConnectingNode string `json:\"connecting_node\"`\n\n\t// Timestamp records the time the policy update is made.\n\tTimestamp time.Time `json:\"timestamp\"`\n}\n\n// openChannelCount stores the total number of channel related counts.",
      "length": 415,
      "tokens": 52,
      "embedding": []
    },
    {
      "slug": "type openChannelCount struct {",
      "content": "type openChannelCount struct {\n\tActive     int\n\tInactive   int\n\tPending    int\n\tPublic     int\n\tPrivate    int\n\tNumUpdates uint64\n}\n\n// closedChannelCount stores the total number of closed, waiting and pending\n// force close channels.",
      "length": 194,
      "tokens": 28,
      "embedding": []
    },
    {
      "slug": "type closedChannelCount struct {",
      "content": "type closedChannelCount struct {\n\tPendingForceClose int\n\tWaitingClose      int\n\tClosed            int\n}\n\n// utxoCount counts the total confirmed and unconfirmed UTXOs.",
      "length": 129,
      "tokens": 16,
      "embedding": []
    },
    {
      "slug": "type utxoCount struct {",
      "content": "type utxoCount struct {\n\tConfirmed   int\n\tUnconfirmed int\n}\n\n// edgeCount counts the total and public edges.",
      "length": 80,
      "tokens": 13,
      "embedding": []
    },
    {
      "slug": "type edgeCount struct {",
      "content": "type edgeCount struct {\n\tTotal  int\n\tPublic int\n}\n\n// paymentCount counts the complete(settled/failed) and incomplete payments.",
      "length": 99,
      "tokens": 13,
      "embedding": []
    },
    {
      "slug": "type paymentCount struct {",
      "content": "type paymentCount struct {\n\tTotal           int\n\tCompleted       int\n\tLastIndexOffset uint64\n}\n\n// invoiceCount counts the complete(settled/failed) and incomplete invoices.",
      "length": 140,
      "tokens": 15,
      "embedding": []
    },
    {
      "slug": "type invoiceCount struct {",
      "content": "type invoiceCount struct {\n\tTotal           int\n\tCompleted       int\n\tLastIndexOffset uint64\n}\n\n// walletBalance provides a summary over balances related the node's wallet.",
      "length": 140,
      "tokens": 18,
      "embedding": []
    },
    {
      "slug": "type walletBalance struct {",
      "content": "type walletBalance struct {\n\tTotalBalance       int64\n\tConfirmedBalance   int64\n\tUnconfirmedBalance int64\n\tAccountBalance     map[string]*lnrpc.WalletAccountBalance\n}\n\n// State records the current state for a given node. It provides a simple count\n// over the node so that the test can track its state. For a channel-specific\n// state check, use dedicated function to query the channel as each channel is\n// meant to be unique.",
      "length": 390,
      "tokens": 58,
      "embedding": []
    },
    {
      "slug": "type State struct {",
      "content": "type State struct {\n\t// rpc is the RPC clients used for the current node.\n\trpc *rpc.HarnessRPC\n\n\t// OpenChannel gives the summary of open channel related counts.\n\tOpenChannel openChannelCount\n\n\t// CloseChannel gives the summary of close channel related counts.\n\tCloseChannel closedChannelCount\n\n\t// Wallet gives the summary of the wallet balance.\n\tWallet walletBalance\n\n\t// HTLC counts the total active HTLCs.\n\tHTLC int\n\n\t// Edge counts the total private/public edges.\n\tEdge edgeCount\n\n\t// ChannelUpdate counts the total channel updates seen from the graph\n\t// subscription.\n\tChannelUpdate int\n\n\t// NodeUpdate counts the total node announcements seen from the graph\n\t// subscription.\n\tNodeUpdate int\n\n\t// UTXO counts the total active UTXOs.\n\tUTXO utxoCount\n\n\t// Payment counts the total payment of the node.\n\tPayment paymentCount\n\n\t// Invoice counts the total invoices made by the node.\n\tInvoice invoiceCount\n\n\t// openChans records each opened channel and how many times it has\n\t// heard the announcements from its graph subscription.\n\topenChans *lnutils.SyncMap[wire.OutPoint, []*OpenChannelUpdate]\n\n\t// closedChans records each closed channel and its close channel update\n\t// message received from its graph subscription.\n\tclosedChans *lnutils.SyncMap[wire.OutPoint, *lnrpc.ClosedChannelUpdate]\n\n\t// numChanUpdates records the number of channel updates seen by each\n\t// channel.\n\tnumChanUpdates *lnutils.SyncMap[wire.OutPoint, int]\n\n\t// nodeUpdates records the node announcements seen by each node.\n\tnodeUpdates *lnutils.SyncMap[string, []*lnrpc.NodeUpdate]\n\n\t// policyUpdates defines a type to store channel policy updates. It has\n\t// the format,\n\t// {\n\t//  \"chanPoint1\": {\n\t//       \"advertisingNode1\": [\n\t//              policy1, policy2, ...\n\t//       ],\n\t//       \"advertisingNode2\": [\n\t//              policy1, policy2, ...\n\t//       ]\n\t//  },\n\t//  \"chanPoint2\": ...\n\t// }\n\tpolicyUpdates *lnutils.SyncMap[wire.OutPoint, PolicyUpdate]\n}\n\n// newState initialize a new state with every field being set to its zero\n// value.",
      "length": 1941,
      "tokens": 266,
      "embedding": []
    },
    {
      "slug": "func newState(rpc *rpc.HarnessRPC) *State {",
      "content": "func newState(rpc *rpc.HarnessRPC) *State {\n\treturn &State{\n\t\trpc: rpc,\n\t\topenChans: &lnutils.SyncMap[\n\t\t\twire.OutPoint, []*OpenChannelUpdate,\n\t\t]{},\n\t\tclosedChans: &lnutils.SyncMap[\n\t\t\twire.OutPoint, *lnrpc.ClosedChannelUpdate,\n\t\t]{},\n\t\tnumChanUpdates: &lnutils.SyncMap[wire.OutPoint, int]{},\n\t\tnodeUpdates:    &lnutils.SyncMap[string, []*lnrpc.NodeUpdate]{},\n\t\tpolicyUpdates:  &lnutils.SyncMap[wire.OutPoint, PolicyUpdate]{},\n\t}\n}\n\n// updateChannelStats gives the stats on open channel related fields.",
      "length": 445,
      "tokens": 35,
      "embedding": []
    },
    {
      "slug": "func (s *State) updateChannelStats() {",
      "content": "func (s *State) updateChannelStats() {\n\treq := &lnrpc.ListChannelsRequest{}\n\tresp := s.rpc.ListChannels(req)\n\n\tfor _, channel := range resp.Channels {\n\t\tif channel.Active {\n\t\t\ts.OpenChannel.Active++\n\t\t} else {\n\t\t\ts.OpenChannel.Inactive++\n\t\t}\n\n\t\tif channel.Private {\n\t\t\ts.OpenChannel.Private++\n\t\t} else {\n\t\t\ts.OpenChannel.Public++\n\t\t}\n\t\ts.OpenChannel.NumUpdates += channel.NumUpdates\n\t\ts.HTLC += len(channel.PendingHtlcs)\n\t}\n}\n\n// updateCloseChannelStats gives the stats on close channel related fields.",
      "length": 443,
      "tokens": 49,
      "embedding": []
    },
    {
      "slug": "func (s *State) updateCloseChannelStats() {",
      "content": "func (s *State) updateCloseChannelStats() {\n\tresp := s.rpc.PendingChannels()\n\ts.CloseChannel.PendingForceClose += len(\n\t\tresp.PendingForceClosingChannels,\n\t)\n\ts.CloseChannel.WaitingClose += len(resp.WaitingCloseChannels)\n\n\tcloseReq := &lnrpc.ClosedChannelsRequest{}\n\tclosed := s.rpc.ClosedChannels(closeReq)\n\n\ts.CloseChannel.Closed += len(closed.Channels)\n\ts.OpenChannel.Pending += len(resp.PendingOpenChannels)\n}\n\n// updatePaymentStats counts the total payments made.",
      "length": 411,
      "tokens": 31,
      "embedding": []
    },
    {
      "slug": "func (s *State) updatePaymentStats() {",
      "content": "func (s *State) updatePaymentStats() {\n\treq := &lnrpc.ListPaymentsRequest{\n\t\tIndexOffset: s.Payment.LastIndexOffset,\n\t}\n\tresp := s.rpc.ListPayments(req)\n\n\t// Exit early when the there's no payment.\n\t//\n\t// NOTE: we need to exit early here because when there's no invoice the\n\t// `LastOffsetIndex` will be zero.\n\tif len(resp.Payments) == 0 {\n\t\treturn\n\t}\n\n\ts.Payment.LastIndexOffset = resp.LastIndexOffset\n\tfor _, payment := range resp.Payments {\n\t\tif payment.Status == lnrpc.Payment_FAILED ||\n\t\t\tpayment.Status == lnrpc.Payment_SUCCEEDED {\n\n\t\t\ts.Payment.Completed++\n\t\t}\n\t}\n\n\ts.Payment.Total += len(resp.Payments)\n}\n\n// updateInvoiceStats counts the total invoices made.",
      "length": 604,
      "tokens": 77,
      "embedding": []
    },
    {
      "slug": "func (s *State) updateInvoiceStats() {",
      "content": "func (s *State) updateInvoiceStats() {\n\treq := &lnrpc.ListInvoiceRequest{\n\t\tNumMaxInvoices: math.MaxUint64,\n\t\tIndexOffset:    s.Invoice.LastIndexOffset,\n\t}\n\tresp := s.rpc.ListInvoices(req)\n\n\t// Exit early when the there's no invoice.\n\t//\n\t// NOTE: we need to exit early here because when there's no invoice the\n\t// `LastOffsetIndex` will be zero.\n\tif len(resp.Invoices) == 0 {\n\t\treturn\n\t}\n\n\ts.Invoice.LastIndexOffset = resp.LastIndexOffset\n\tfor _, invoice := range resp.Invoices {\n\t\tif invoice.State == lnrpc.Invoice_SETTLED ||\n\t\t\tinvoice.State == lnrpc.Invoice_CANCELED {\n\n\t\t\ts.Invoice.Completed++\n\t\t}\n\t}\n\n\ts.Invoice.Total += len(resp.Invoices)\n}\n\n// updateUTXOStats counts the total UTXOs made.",
      "length": 631,
      "tokens": 79,
      "embedding": []
    },
    {
      "slug": "func (s *State) updateUTXOStats() {",
      "content": "func (s *State) updateUTXOStats() {\n\treq := &walletrpc.ListUnspentRequest{}\n\tresp := s.rpc.ListUnspent(req)\n\n\tfor _, utxo := range resp.Utxos {\n\t\tif utxo.Confirmations > 0 {\n\t\t\ts.UTXO.Confirmed++\n\t\t} else {\n\t\t\ts.UTXO.Unconfirmed++\n\t\t}\n\t}\n}\n\n// updateEdgeStats counts the total edges.",
      "length": 235,
      "tokens": 32,
      "embedding": []
    },
    {
      "slug": "func (s *State) updateEdgeStats() {",
      "content": "func (s *State) updateEdgeStats() {\n\treq := &lnrpc.ChannelGraphRequest{IncludeUnannounced: true}\n\tresp := s.rpc.DescribeGraph(req)\n\ts.Edge.Total = len(resp.Edges)\n\n\treq = &lnrpc.ChannelGraphRequest{IncludeUnannounced: false}\n\tresp = s.rpc.DescribeGraph(req)\n\ts.Edge.Public = len(resp.Edges)\n}\n\n// updateWalletBalance creates stats for the node's wallet balance.",
      "length": 316,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func (s *State) updateWalletBalance() {",
      "content": "func (s *State) updateWalletBalance() {\n\tresp := s.rpc.WalletBalance()\n\n\ts.Wallet.TotalBalance = resp.TotalBalance\n\ts.Wallet.ConfirmedBalance = resp.ConfirmedBalance\n\ts.Wallet.UnconfirmedBalance = resp.UnconfirmedBalance\n\ts.Wallet.AccountBalance = resp.AccountBalance\n}\n\n// updateState updates the internal state of the node.",
      "length": 277,
      "tokens": 25,
      "embedding": []
    },
    {
      "slug": "func (s *State) updateState() {",
      "content": "func (s *State) updateState() {\n\ts.updateChannelStats()\n\ts.updateCloseChannelStats()\n\ts.updatePaymentStats()\n\ts.updateInvoiceStats()\n\ts.updateUTXOStats()\n\ts.updateEdgeStats()\n\ts.updateWalletBalance()\n}\n\n// String encodes the node's state for debugging.",
      "length": 211,
      "tokens": 16,
      "embedding": []
    },
    {
      "slug": "func (s *State) String() string {",
      "content": "func (s *State) String() string {\n\tstateBytes, err := json.MarshalIndent(s, \"\", \"\\t\")\n\tif err != nil {\n\t\treturn fmt.Sprintf(\"\\n encode node state with err: %v\", err)\n\t}\n\n\treturn fmt.Sprintf(\"\\n%s\", stateBytes)\n}\n\n// resetEphermalStates resets the current state with a new HarnessRPC and empty\n// private fields which are used to track state only valid for the last test.",
      "length": 327,
      "tokens": 52,
      "embedding": []
    },
    {
      "slug": "func (s *State) resetEphermalStates(rpc *rpc.HarnessRPC) {",
      "content": "func (s *State) resetEphermalStates(rpc *rpc.HarnessRPC) {\n\ts.rpc = rpc\n\n\t// Reset ephermal states which are used to record info from finished\n\t// tests.\n\ts.openChans = &lnutils.SyncMap[wire.OutPoint, []*OpenChannelUpdate]{}\n\ts.closedChans = &lnutils.SyncMap[\n\t\twire.OutPoint, *lnrpc.ClosedChannelUpdate,\n\t]{}\n\ts.numChanUpdates = &lnutils.SyncMap[wire.OutPoint, int]{}\n\ts.nodeUpdates = &lnutils.SyncMap[string, []*lnrpc.NodeUpdate]{}\n\ts.policyUpdates = &lnutils.SyncMap[wire.OutPoint, PolicyUpdate]{}\n}\n",
      "length": 432,
      "tokens": 40,
      "embedding": []
    }
  ]
}