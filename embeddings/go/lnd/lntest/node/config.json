{
  "filepath": "../implementations/go/lnd/lntest/node/config.go",
  "package": "node",
  "sections": [
    {
      "slug": "type DatabaseBackend int",
      "content": "type DatabaseBackend int\n\nconst (\n\tBackendBbolt DatabaseBackend = iota\n\tBackendEtcd\n\tBackendPostgres\n\tBackendSqlite\n)\n\n// Option is a function for updating a node's configuration.",
      "length": 146,
      "tokens": 20,
      "embedding": []
    },
    {
      "slug": "type Option func(*BaseNodeConfig)",
      "content": "type Option func(*BaseNodeConfig)\n\n// BackendConfig is an interface that abstracts away the specific chain backend\n// node implementation.",
      "length": 102,
      "tokens": 15,
      "embedding": []
    },
    {
      "slug": "type BackendConfig interface {",
      "content": "type BackendConfig interface {\n\t// GenArgs returns the arguments needed to be passed to LND at startup\n\t// for using this node as a chain backend.\n\tGenArgs() []string\n\n\t// ConnectMiner is called to establish a connection to the test miner.\n\tConnectMiner() error\n\n\t// DisconnectMiner is called to disconnect the miner.\n\tDisconnectMiner() error\n\n\t// Name returns the name of the backend type.\n\tName() string\n\n\t// Credentials returns the rpc username, password and host for the\n\t// backend.\n\tCredentials() (string, string, string, error)\n}\n\n// BaseNodeConfig is the base node configuration.",
      "length": 538,
      "tokens": 85,
      "embedding": []
    },
    {
      "slug": "type BaseNodeConfig struct {",
      "content": "type BaseNodeConfig struct {\n\tName string\n\n\t// LogFilenamePrefix is used to prefix node log files. Can be used to\n\t// store the current test case for simpler postmortem debugging.\n\tLogFilenamePrefix string\n\n\tNetParams         *chaincfg.Params\n\tBackendCfg        BackendConfig\n\tBaseDir           string\n\tExtraArgs         []string\n\tOriginalExtraArgs []string\n\n\tDataDir        string\n\tLogDir         string\n\tTLSCertPath    string\n\tTLSKeyPath     string\n\tAdminMacPath   string\n\tReadMacPath    string\n\tInvoiceMacPath string\n\n\tSkipUnlock bool\n\tPassword   []byte\n\n\tP2PPort     int\n\tRPCPort     int\n\tRESTPort    int\n\tProfilePort int\n\n\tFeeURL string\n\n\tDBBackend   DatabaseBackend\n\tPostgresDsn string\n\n\t// NodeID is a unique ID used to identify the node.\n\tNodeID uint32\n\n\t// LndBinary is the full path to the lnd binary that was specifically\n\t// compiled with all required itest flags.\n\tLndBinary string\n\n\t// backupDBDir is the path where a database backup is stored, if any.\n\tbackupDBDir string\n\n\t// postgresDBName is the name of the postgres database where lnd data\n\t// is stored in.\n\tpostgresDBName string\n}\n",
      "length": 1026,
      "tokens": 138,
      "embedding": []
    },
    {
      "slug": "func (cfg BaseNodeConfig) P2PAddr() string {",
      "content": "func (cfg BaseNodeConfig) P2PAddr() string {\n\treturn fmt.Sprintf(ListenerFormat, cfg.P2PPort)\n}\n",
      "length": 49,
      "tokens": 4,
      "embedding": []
    },
    {
      "slug": "func (cfg BaseNodeConfig) RPCAddr() string {",
      "content": "func (cfg BaseNodeConfig) RPCAddr() string {\n\treturn fmt.Sprintf(ListenerFormat, cfg.RPCPort)\n}\n",
      "length": 49,
      "tokens": 4,
      "embedding": []
    },
    {
      "slug": "func (cfg BaseNodeConfig) RESTAddr() string {",
      "content": "func (cfg BaseNodeConfig) RESTAddr() string {\n\treturn fmt.Sprintf(ListenerFormat, cfg.RESTPort)\n}\n\n// DBDir returns the holding directory path of the graph database.",
      "length": 116,
      "tokens": 15,
      "embedding": []
    },
    {
      "slug": "func (cfg BaseNodeConfig) DBDir() string {",
      "content": "func (cfg BaseNodeConfig) DBDir() string {\n\treturn filepath.Join(cfg.DataDir, \"graph\", cfg.NetParams.Name)\n}\n",
      "length": 64,
      "tokens": 5,
      "embedding": []
    },
    {
      "slug": "func (cfg BaseNodeConfig) DBPath() string {",
      "content": "func (cfg BaseNodeConfig) DBPath() string {\n\treturn filepath.Join(cfg.DBDir(), \"channel.db\")\n}\n",
      "length": 49,
      "tokens": 4,
      "embedding": []
    },
    {
      "slug": "func (cfg BaseNodeConfig) ChanBackupPath() string {",
      "content": "func (cfg BaseNodeConfig) ChanBackupPath() string {\n\treturn filepath.Join(\n\t\tcfg.DataDir, \"chain\", \"bitcoin\",\n\t\tfmt.Sprintf(\n\t\t\t\"%v/%v\", cfg.NetParams.Name,\n\t\t\tchanbackup.DefaultBackupFileName,\n\t\t),\n\t)\n}\n\n// GenerateListeningPorts generates the ports to listen on designated for the\n// current lightning network test.",
      "length": 255,
      "tokens": 28,
      "embedding": []
    },
    {
      "slug": "func (cfg *BaseNodeConfig) GenerateListeningPorts() {",
      "content": "func (cfg *BaseNodeConfig) GenerateListeningPorts() {\n\tif cfg.P2PPort == 0 {\n\t\tcfg.P2PPort = NextAvailablePort()\n\t}\n\tif cfg.RPCPort == 0 {\n\t\tcfg.RPCPort = NextAvailablePort()\n\t}\n\tif cfg.RESTPort == 0 {\n\t\tcfg.RESTPort = NextAvailablePort()\n\t}\n\tif cfg.ProfilePort == 0 {\n\t\tcfg.ProfilePort = NextAvailablePort()\n\t}\n}\n\n// BaseConfig returns the base node configuration struct.",
      "length": 304,
      "tokens": 45,
      "embedding": []
    },
    {
      "slug": "func (cfg *BaseNodeConfig) BaseConfig() *BaseNodeConfig {",
      "content": "func (cfg *BaseNodeConfig) BaseConfig() *BaseNodeConfig {\n\treturn cfg\n}\n\n// GenArgs generates a slice of command line arguments from the lightning node\n// config struct.",
      "length": 107,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func (cfg *BaseNodeConfig) GenArgs() []string {",
      "content": "func (cfg *BaseNodeConfig) GenArgs() []string {\n\tvar args []string\n\n\tswitch cfg.NetParams {\n\tcase &chaincfg.TestNet3Params:\n\t\targs = append(args, \"--bitcoin.testnet\")\n\tcase &chaincfg.SimNetParams:\n\t\targs = append(args, \"--bitcoin.simnet\")\n\tcase &chaincfg.RegressionNetParams:\n\t\targs = append(args, \"--bitcoin.regtest\")\n\t}\n\n\tbackendArgs := cfg.BackendCfg.GenArgs()\n\targs = append(args, backendArgs...)\n\n\tnodeArgs := []string{\n\t\t\"--bitcoin.active\",\n\t\t\"--nobootstrap\",\n\t\t\"--debuglevel=debug\",\n\t\t\"--bitcoin.defaultchanconfs=1\",\n\t\t\"--accept-keysend\",\n\t\t\"--keep-failed-payment-attempts\",\n\t\tfmt.Sprintf(\"--db.batch-commit-interval=%v\", commitInterval),\n\t\tfmt.Sprintf(\"--bitcoin.defaultremotedelay=%v\", DefaultCSV),\n\t\tfmt.Sprintf(\"--rpclisten=%v\", cfg.RPCAddr()),\n\t\tfmt.Sprintf(\"--restlisten=%v\", cfg.RESTAddr()),\n\t\tfmt.Sprintf(\"--restcors=https://%v\", cfg.RESTAddr()),\n\t\tfmt.Sprintf(\"--listen=%v\", cfg.P2PAddr()),\n\t\tfmt.Sprintf(\"--externalip=%v\", cfg.P2PAddr()),\n\t\tfmt.Sprintf(\"--lnddir=%v\", cfg.BaseDir),\n\t\tfmt.Sprintf(\"--adminmacaroonpath=%v\", cfg.AdminMacPath),\n\t\tfmt.Sprintf(\"--readonlymacaroonpath=%v\", cfg.ReadMacPath),\n\t\tfmt.Sprintf(\"--invoicemacaroonpath=%v\", cfg.InvoiceMacPath),\n\t\tfmt.Sprintf(\"--trickledelay=%v\", trickleDelay),\n\t\tfmt.Sprintf(\"--profile=%d\", cfg.ProfilePort),\n\n\t\t// Use a small batch window so we can broadcast our sweep\n\t\t// transactions faster.\n\t\t\"--sweeper.batchwindowduration=5s\",\n\n\t\t// Use a small batch delay so we can broadcast the\n\t\t// announcements quickly in the tests.\n\t\t\"--gossip.sub-batch-delay=5ms\",\n\n\t\t// Use a small cache duration so the `DescribeGraph` can be\n\t\t// updated quicker.\n\t\t\"--caches.rpc-graph-cache-duration=100ms\",\n\t}\n\n\targs = append(args, nodeArgs...)\n\n\tif cfg.Password == nil {\n\t\targs = append(args, \"--noseedbackup\")\n\t}\n\n\tswitch cfg.DBBackend {\n\tcase BackendEtcd:\n\t\targs = append(args, \"--db.backend=etcd\")\n\t\targs = append(args, \"--db.etcd.embedded\")\n\t\targs = append(\n\t\t\targs, fmt.Sprintf(\n\t\t\t\t\"--db.etcd.embedded_client_port=%v\",\n\t\t\t\tNextAvailablePort(),\n\t\t\t),\n\t\t)\n\t\targs = append(\n\t\t\targs, fmt.Sprintf(\n\t\t\t\t\"--db.etcd.embedded_peer_port=%v\",\n\t\t\t\tNextAvailablePort(),\n\t\t\t),\n\t\t)\n\t\targs = append(\n\t\t\targs, fmt.Sprintf(\n\t\t\t\t\"--db.etcd.embedded_log_file=%v\",\n\t\t\t\tpath.Join(cfg.LogDir, \"etcd.log\"),\n\t\t\t),\n\t\t)\n\n\tcase BackendPostgres:\n\t\targs = append(args, \"--db.backend=postgres\")\n\t\targs = append(args, \"--db.postgres.dsn=\"+cfg.PostgresDsn)\n\n\tcase BackendSqlite:\n\t\targs = append(args, \"--db.backend=sqlite\")\n\t\targs = append(args, fmt.Sprintf(\"--db.sqlite.busytimeout=%v\",\n\t\t\twait.SqliteBusyTimeout))\n\t}\n\n\tif cfg.FeeURL != \"\" {\n\t\targs = append(args, \"--feeurl=\"+cfg.FeeURL)\n\t}\n\n\t// Put extra args in the end so the args can be overwritten.\n\tif cfg.ExtraArgs != nil {\n\t\targs = append(args, cfg.ExtraArgs...)\n\t}\n\n\treturn args\n}\n\n// ExtraArgsEtcd returns extra args for configuring LND to use an external etcd\n// database (for remote channel DB and wallet DB).",
      "length": 2755,
      "tokens": 252,
      "embedding": []
    },
    {
      "slug": "func ExtraArgsEtcd(etcdCfg *etcd.Config, name string, cluster bool,",
      "content": "func ExtraArgsEtcd(etcdCfg *etcd.Config, name string, cluster bool,\n\tleaderSessionTTL int) []string {\n\n\textraArgs := []string{\n\t\t\"--db.backend=etcd\",\n\t\tfmt.Sprintf(\"--db.etcd.host=%v\", etcdCfg.Host),\n\t\tfmt.Sprintf(\"--db.etcd.user=%v\", etcdCfg.User),\n\t\tfmt.Sprintf(\"--db.etcd.pass=%v\", etcdCfg.Pass),\n\t\tfmt.Sprintf(\"--db.etcd.namespace=%v\", etcdCfg.Namespace),\n\t}\n\n\tif etcdCfg.InsecureSkipVerify {\n\t\textraArgs = append(extraArgs, \"--db.etcd.insecure_skip_verify\")\n\t}\n\n\tif cluster {\n\t\tclusterArgs := []string{\n\t\t\t\"--cluster.enable-leader-election\",\n\t\t\tfmt.Sprintf(\"--cluster.id=%v\", name),\n\t\t\tfmt.Sprintf(\"--cluster.leader-session-ttl=%v\",\n\t\t\t\tleaderSessionTTL),\n\t\t}\n\t\textraArgs = append(extraArgs, clusterArgs...)\n\t}\n\n\treturn extraArgs\n}\n\n// NextAvailablePort returns the first port that is available for listening by\n// a new node. It panics if no port is found and the maximum available TCP port\n// is reached.",
      "length": 814,
      "tokens": 77,
      "embedding": []
    },
    {
      "slug": "func NextAvailablePort() int {",
      "content": "func NextAvailablePort() int {\n\tport := atomic.AddUint32(&lastPort, 1)\n\tfor port < 65535 {\n\t\t// If there are no errors while attempting to listen on this\n\t\t// port, close the socket and return it as available. While it\n\t\t// could be the case that some other process picks up this port\n\t\t// between the time the socket is closed and it's reopened in\n\t\t// the harness node, in practice in CI servers this seems much\n\t\t// less likely than simply some other process already being\n\t\t// bound at the start of the tests.\n\t\taddr := fmt.Sprintf(ListenerFormat, port)\n\t\tl, err := net.Listen(\"tcp4\", addr)\n\t\tif err == nil {\n\t\t\terr := l.Close()\n\t\t\tif err == nil {\n\t\t\t\treturn int(port)\n\t\t\t}\n\t\t}\n\t\tport = atomic.AddUint32(&lastPort, 1)\n\t}\n\n\t// No ports available? Must be a mistake.\n\tpanic(\"no ports available for listening\")\n}\n\n// GetLogDir returns the passed --logdir flag or the default value if it wasn't\n// set.",
      "length": 846,
      "tokens": 149,
      "embedding": []
    },
    {
      "slug": "func GetLogDir() string {",
      "content": "func GetLogDir() string {\n\tif logSubDir != nil && *logSubDir != \"\" {\n\t\treturn *logSubDir\n\t}\n\n\treturn \".\"\n}\n\n// CopyFile copies the file src to dest.",
      "length": 115,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func CopyFile(dest, src string) error {",
      "content": "func CopyFile(dest, src string) error {\n\ts, err := os.Open(src)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer s.Close()\n\n\td, err := os.Create(dest)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif _, err := io.Copy(d, s); err != nil {\n\t\td.Close()\n\t\treturn err\n\t}\n\n\treturn d.Close()\n}\n\n// GetBtcdBinary returns the full path to the binary of the custom built btcd\n// executable or an empty string if none is set.",
      "length": 334,
      "tokens": 67,
      "embedding": []
    },
    {
      "slug": "func GetBtcdBinary() string {",
      "content": "func GetBtcdBinary() string {\n\tif btcdExecutable != nil {\n\t\treturn *btcdExecutable\n\t}\n\n\treturn \"\"\n}\n\n// GenerateBtcdListenerAddresses is a function that returns two listener\n// addresses with unique ports and should be used to overwrite rpctest's\n// default generator which is prone to use colliding ports.",
      "length": 267,
      "tokens": 42,
      "embedding": []
    },
    {
      "slug": "func GenerateBtcdListenerAddresses() (string, string) {",
      "content": "func GenerateBtcdListenerAddresses() (string, string) {\n\treturn fmt.Sprintf(ListenerFormat, NextAvailablePort()),\n\t\tfmt.Sprintf(ListenerFormat, NextAvailablePort())\n}\n\n// ApplyPortOffset adds the given offset to the lastPort variable, making it\n// possible to run the tests in parallel without colliding on the same ports.",
      "length": 261,
      "tokens": 32,
      "embedding": []
    },
    {
      "slug": "func ApplyPortOffset(offset uint32) {",
      "content": "func ApplyPortOffset(offset uint32) {\n\t_ = atomic.AddUint32(&lastPort, offset)\n}\n",
      "length": 41,
      "tokens": 5,
      "embedding": []
    }
  ]
}