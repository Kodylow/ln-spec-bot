{
  "filepath": "../implementations/go/lnd/lntest/harness_assertion.go",
  "package": "lntest",
  "sections": [
    {
      "slug": "type ListChannelOption func(r *lnrpc.ListChannelsRequest)",
      "content": "type ListChannelOption func(r *lnrpc.ListChannelsRequest)\n\n// WithPeerAliasLookup is an option for setting the peer alias lookup flag on a\n// ListChannelsRequest.",
      "length": 102,
      "tokens": 16,
      "embedding": []
    },
    {
      "slug": "func WithPeerAliasLookup() ListChannelOption {",
      "content": "func WithPeerAliasLookup() ListChannelOption {\n\treturn func(r *lnrpc.ListChannelsRequest) {\n\t\tr.PeerAliasLookup = true\n\t}\n}\n\n// WaitForBlockchainSync waits until the node is synced to chain.",
      "length": 138,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) WaitForBlockchainSync(hn *node.HarnessNode) {",
      "content": "func (h *HarnessTest) WaitForBlockchainSync(hn *node.HarnessNode) {\n\terr := wait.NoError(func() error {\n\t\tresp := hn.RPC.GetInfo()\n\t\tif resp.SyncedToChain {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn fmt.Errorf(\"%s is not synced to chain\", hn.Name())\n\t}, DefaultTimeout)\n\n\trequire.NoError(h, err, \"timeout waiting for blockchain sync\")\n}\n\n// WaitForBlockchainSyncTo waits until the node is synced to bestBlock.",
      "length": 315,
      "tokens": 42,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) WaitForBlockchainSyncTo(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) WaitForBlockchainSyncTo(hn *node.HarnessNode,\n\tbestBlock *wire.MsgBlock) {\n\n\tbestBlockHash := bestBlock.BlockHash().String()\n\terr := wait.NoError(func() error {\n\t\tresp := hn.RPC.GetInfo()\n\t\tif resp.SyncedToChain {\n\t\t\tif resp.BlockHash == bestBlockHash {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\treturn fmt.Errorf(\"%s's backend is synced to the \"+\n\t\t\t\t\"wrong block (expected=%s, actual=%s)\",\n\t\t\t\thn.Name(), bestBlockHash, resp.BlockHash)\n\t\t}\n\n\t\treturn fmt.Errorf(\"%s is not synced to chain\", hn.Name())\n\t}, DefaultTimeout)\n\n\trequire.NoError(h, err, \"timeout waiting for blockchain sync\")\n}\n\n// AssertPeerConnected asserts that the given node b is connected to a.",
      "length": 577,
      "tokens": 71,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertPeerConnected(a, b *node.HarnessNode) {",
      "content": "func (h *HarnessTest) AssertPeerConnected(a, b *node.HarnessNode) {\n\terr := wait.NoError(func() error {\n\t\t// We require the RPC call to be succeeded and won't wait for\n\t\t// it as it's an unexpected behavior.\n\t\tresp := a.RPC.ListPeers()\n\n\t\t// If node B is seen in the ListPeers response from node A,\n\t\t// then we can return true as the connection has been fully\n\t\t// established.\n\t\tfor _, peer := range resp.Peers {\n\t\t\tif peer.PubKey == b.PubKeyStr {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\n\t\treturn fmt.Errorf(\"%s not found in %s's ListPeers\",\n\t\t\tb.Name(), a.Name())\n\t}, DefaultTimeout)\n\n\trequire.NoError(h, err, \"unable to connect %s to %s, got error: \"+\n\t\t\"peers not connected within %v seconds\",\n\t\ta.Name(), b.Name(), DefaultTimeout)\n}\n\n// ConnectNodes creates a connection between the two nodes and asserts the\n// connection is succeeded.",
      "length": 735,
      "tokens": 119,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) ConnectNodes(a, b *node.HarnessNode) {",
      "content": "func (h *HarnessTest) ConnectNodes(a, b *node.HarnessNode) {\n\tbobInfo := b.RPC.GetInfo()\n\n\treq := &lnrpc.ConnectPeerRequest{\n\t\tAddr: &lnrpc.LightningAddress{\n\t\t\tPubkey: bobInfo.IdentityPubkey,\n\t\t\tHost:   b.Cfg.P2PAddr(),\n\t\t},\n\t}\n\ta.RPC.ConnectPeer(req)\n\th.AssertPeerConnected(a, b)\n}\n\n// ConnectNodesPerm creates a persistent connection between the two nodes and\n// asserts the connection is succeeded.",
      "length": 328,
      "tokens": 35,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) ConnectNodesPerm(a, b *node.HarnessNode) {",
      "content": "func (h *HarnessTest) ConnectNodesPerm(a, b *node.HarnessNode) {\n\tbobInfo := b.RPC.GetInfo()\n\n\treq := &lnrpc.ConnectPeerRequest{\n\t\tAddr: &lnrpc.LightningAddress{\n\t\t\tPubkey: bobInfo.IdentityPubkey,\n\t\t\tHost:   b.Cfg.P2PAddr(),\n\t\t},\n\t\tPerm: true,\n\t}\n\ta.RPC.ConnectPeer(req)\n\th.AssertPeerConnected(a, b)\n}\n\n// DisconnectNodes disconnects the given two nodes and asserts the\n// disconnection is succeeded. The request is made from node a and sent to node\n// b.",
      "length": 375,
      "tokens": 47,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) DisconnectNodes(a, b *node.HarnessNode) {",
      "content": "func (h *HarnessTest) DisconnectNodes(a, b *node.HarnessNode) {\n\tbobInfo := b.RPC.GetInfo()\n\ta.RPC.DisconnectPeer(bobInfo.IdentityPubkey)\n\n\t// Assert disconnected.\n\th.AssertPeerNotConnected(a, b)\n}\n\n// EnsureConnected will try to connect to two nodes, returning no error if they\n// are already connected. If the nodes were not connected previously, this will\n// behave the same as ConnectNodes. If a pending connection request has already\n// been made, the method will block until the two nodes appear in each other's\n// peers list, or until the DefaultTimeout expires.",
      "length": 494,
      "tokens": 73,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) EnsureConnected(a, b *node.HarnessNode) {",
      "content": "func (h *HarnessTest) EnsureConnected(a, b *node.HarnessNode) {\n\t// errConnectionRequested is used to signal that a connection was\n\t// requested successfully, which is distinct from already being\n\t// connected to the peer.\n\terrConnectionRequested := \"connection request in progress\"\n\n\t// windowsErr is an error we've seen from windows build where\n\t// connecting to an already connected node gives such error from the\n\t// receiver side.\n\twindowsErr := \"An established connection was aborted by the software \" +\n\t\t\"in your host machine.\"\n\n\ttryConnect := func(a, b *node.HarnessNode) error {\n\t\tbInfo := b.RPC.GetInfo()\n\n\t\treq := &lnrpc.ConnectPeerRequest{\n\t\t\tAddr: &lnrpc.LightningAddress{\n\t\t\t\tPubkey: bInfo.IdentityPubkey,\n\t\t\t\tHost:   b.Cfg.P2PAddr(),\n\t\t\t},\n\t\t}\n\n\t\tctxt, cancel := context.WithTimeout(h.runCtx, DefaultTimeout)\n\t\tdefer cancel()\n\n\t\t_, err := a.RPC.LN.ConnectPeer(ctxt, req)\n\n\t\t// Request was successful.\n\t\tif err == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\t// If the two are already connected, we return early with no\n\t\t// error.\n\t\tif strings.Contains(err.Error(), \"already connected to peer\") {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Otherwise we log the error to console.\n\t\th.Logf(\"EnsureConnected %s=>%s got err: %v\", a.Name(),\n\t\t\tb.Name(), err)\n\n\t\t// If the connection is in process, we return no error.\n\t\tif strings.Contains(err.Error(), errConnectionRequested) {\n\t\t\treturn nil\n\t\t}\n\n\t\t// We may get connection refused error if we happens to be in\n\t\t// the middle of a previous node disconnection, e.g., a restart\n\t\t// from one of the nodes.\n\t\tif strings.Contains(err.Error(), \"connection refused\") {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Check for windows error. If Alice connects to Bob, Alice\n\t\t// will throw \"i/o timeout\" and Bob will give windowsErr.\n\t\tif strings.Contains(err.Error(), windowsErr) {\n\t\t\treturn nil\n\t\t}\n\n\t\tif strings.Contains(err.Error(), \"i/o timeout\") {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn err\n\t}\n\n\t// Return any critical errors returned by either alice or bob.\n\trequire.NoError(h, tryConnect(a, b), \"connection failed between %s \"+\n\t\t\"and %s\", a.Cfg.Name, b.Cfg.Name)\n\n\t// When Alice and Bob each makes a connection to the other side at the\n\t// same time, it's likely neither connections could succeed. Bob's\n\t// connection will be canceled by Alice since she has an outbound\n\t// connection to Bob already, and same happens to Alice's. Thus the two\n\t// connections cancel each other out.\n\t// TODO(yy): move this back when the above issue is fixed.\n\t// require.NoError(h, tryConnect(b, a), \"connection failed between %s \"+\n\t// \t\"and %s\", a.Cfg.Name, b.Cfg.Name)\n\n\t// Otherwise one or both requested a connection, so we wait for the\n\t// peers lists to reflect the connection.\n\th.AssertPeerConnected(a, b)\n\th.AssertPeerConnected(b, a)\n}\n\n// AssertNumEdges checks that an expected number of edges can be found in the\n// node specified.",
      "length": 2670,
      "tokens": 398,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertNumEdges(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertNumEdges(hn *node.HarnessNode,\n\texpected int, includeUnannounced bool) []*lnrpc.ChannelEdge {\n\n\tvar edges []*lnrpc.ChannelEdge\n\n\told := hn.State.Edge.Public\n\tif includeUnannounced {\n\t\told = hn.State.Edge.Total\n\t}\n\n\terr := wait.NoError(func() error {\n\t\treq := &lnrpc.ChannelGraphRequest{\n\t\t\tIncludeUnannounced: includeUnannounced,\n\t\t}\n\t\tchanGraph := hn.RPC.DescribeGraph(req)\n\t\ttotal := len(chanGraph.Edges)\n\n\t\tif total-old == expected {\n\t\t\tif expected != 0 {\n\t\t\t\t// NOTE: assume edges come in ascending order\n\t\t\t\t// that the old edges are at the front of the\n\t\t\t\t// slice.\n\t\t\t\tedges = chanGraph.Edges[old:]\n\t\t\t}\n\n\t\t\treturn nil\n\t\t}\n\n\t\treturn errNumNotMatched(hn.Name(), \"num of channel edges\",\n\t\t\texpected, total-old, total, old)\n\t}, DefaultTimeout)\n\n\trequire.NoError(h, err, \"timeout while checking for edges\")\n\n\treturn edges\n}\n\n// ReceiveOpenChannelUpdate waits until a message is received on the stream or\n// the timeout is reached.",
      "length": 866,
      "tokens": 113,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) ReceiveOpenChannelUpdate(",
      "content": "func (h *HarnessTest) ReceiveOpenChannelUpdate(\n\tstream rpc.OpenChanClient) *lnrpc.OpenStatusUpdate {\n\n\tupdate, err := h.receiveOpenChannelUpdate(stream)\n\trequire.NoError(h, err, \"received err from open channel stream\")\n\n\treturn update\n}\n\n// receiveOpenChannelUpdate waits until a message or an error is received on\n// the stream or the timeout is reached.\n//\n// TODO(yy): use generics to unify all receiving stream update once go@1.18 is\n// used.",
      "length": 387,
      "tokens": 55,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) receiveOpenChannelUpdate(",
      "content": "func (h *HarnessTest) receiveOpenChannelUpdate(\n\tstream rpc.OpenChanClient) (*lnrpc.OpenStatusUpdate, error) {\n\n\tchanMsg := make(chan *lnrpc.OpenStatusUpdate)\n\terrChan := make(chan error)\n\tgo func() {\n\t\t// Consume one message. This will block until the message is\n\t\t// received.\n\t\tresp, err := stream.Recv()\n\t\tif err != nil {\n\t\t\terrChan <- err\n\t\t\treturn\n\t\t}\n\t\tchanMsg <- resp\n\t}()\n\n\tselect {\n\tcase <-time.After(DefaultTimeout):\n\t\trequire.Fail(h, \"timeout\", \"timeout waiting for open channel \"+\n\t\t\t\"update sent\")\n\t\treturn nil, nil\n\n\tcase err := <-errChan:\n\t\treturn nil, err\n\n\tcase updateMsg := <-chanMsg:\n\t\treturn updateMsg, nil\n\t}\n}\n\n// WaitForChannelOpenEvent waits for a notification that a channel is open by\n// consuming a message from the passed open channel stream.",
      "length": 693,
      "tokens": 102,
      "embedding": []
    },
    {
      "slug": "func (h HarnessTest) WaitForChannelOpenEvent(",
      "content": "func (h HarnessTest) WaitForChannelOpenEvent(\n\tstream rpc.OpenChanClient) *lnrpc.ChannelPoint {\n\n\t// Consume one event.\n\tevent := h.ReceiveOpenChannelUpdate(stream)\n\n\tresp, ok := event.Update.(*lnrpc.OpenStatusUpdate_ChanOpen)\n\trequire.Truef(h, ok, \"expected channel open update, instead got %v\",\n\t\tresp)\n\n\treturn resp.ChanOpen.ChannelPoint\n}\n\n// AssertTopologyChannelOpen asserts that a given channel outpoint is seen by\n// the passed node's network topology.",
      "length": 401,
      "tokens": 45,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertTopologyChannelOpen(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertTopologyChannelOpen(hn *node.HarnessNode,\n\tchanPoint *lnrpc.ChannelPoint) {\n\n\terr := hn.Watcher.WaitForChannelOpen(chanPoint)\n\trequire.NoErrorf(h, err, \"%s didn't report channel\", hn.Name())\n}\n\n// AssertChannelExists asserts that an active channel identified by the\n// specified channel point exists from the point-of-view of the node.",
      "length": 286,
      "tokens": 35,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertChannelExists(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertChannelExists(hn *node.HarnessNode,\n\tcp *lnrpc.ChannelPoint) *lnrpc.Channel {\n\n\tvar (\n\t\tchannel *lnrpc.Channel\n\t\terr     error\n\t)\n\n\terr = wait.NoError(func() error {\n\t\tchannel, err = h.findChannel(hn, cp)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Check whether the channel is active, exit early if it is.\n\t\tif channel.Active {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn fmt.Errorf(\"channel point not active\")\n\t}, DefaultTimeout)\n\n\trequire.NoErrorf(h, err, \"%s: timeout checking for channel point: %v\",\n\t\thn.Name(), cp)\n\n\treturn channel\n}\n\n// findChannel tries to find a target channel in the node using the given\n// channel point.",
      "length": 551,
      "tokens": 85,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) findChannel(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) findChannel(hn *node.HarnessNode,\n\tchanPoint *lnrpc.ChannelPoint,\n\topts ...ListChannelOption) (*lnrpc.Channel, error) {\n\n\t// Get the funding point.\n\tfp := h.OutPointFromChannelPoint(chanPoint)\n\n\treq := &lnrpc.ListChannelsRequest{}\n\n\tfor _, opt := range opts {\n\t\topt(req)\n\t}\n\n\tchannelInfo := hn.RPC.ListChannels(req)\n\n\t// Find the target channel.\n\tfor _, channel := range channelInfo.Channels {\n\t\tif channel.ChannelPoint == fp.String() {\n\t\t\treturn channel, nil\n\t\t}\n\t}\n\n\treturn nil, fmt.Errorf(\"channel not found using %s\", chanPoint)\n}\n\n// ReceiveCloseChannelUpdate waits until a message or an error is received on\n// the subscribe channel close stream or the timeout is reached.",
      "length": 619,
      "tokens": 84,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) ReceiveCloseChannelUpdate(",
      "content": "func (h *HarnessTest) ReceiveCloseChannelUpdate(\n\tstream rpc.CloseChanClient) (*lnrpc.CloseStatusUpdate, error) {\n\n\tchanMsg := make(chan *lnrpc.CloseStatusUpdate)\n\terrChan := make(chan error)\n\tgo func() {\n\t\t// Consume one message. This will block until the message is\n\t\t// received.\n\t\tresp, err := stream.Recv()\n\t\tif err != nil {\n\t\t\terrChan <- err\n\t\t\treturn\n\t\t}\n\t\tchanMsg <- resp\n\t}()\n\n\tselect {\n\tcase <-time.After(DefaultTimeout):\n\t\trequire.Fail(h, \"timeout\", \"timeout waiting for close channel \"+\n\t\t\t\"update sent\")\n\n\t\treturn nil, nil\n\n\tcase err := <-errChan:\n\t\treturn nil, fmt.Errorf(\"received err from close channel \"+\n\t\t\t\"stream: %v\", err)\n\n\tcase updateMsg := <-chanMsg:\n\t\treturn updateMsg, nil\n\t}\n}\n",
      "length": 625,
      "tokens": 88,
      "embedding": []
    },
    {
      "slug": "type WaitingCloseChannel *lnrpc.PendingChannelsResponse_WaitingCloseChannel",
      "content": "type WaitingCloseChannel *lnrpc.PendingChannelsResponse_WaitingCloseChannel\n\n// AssertChannelWaitingClose asserts that the given channel found in the node\n// is waiting close. Returns the WaitingCloseChannel if found.",
      "length": 139,
      "tokens": 20,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertChannelWaitingClose(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertChannelWaitingClose(hn *node.HarnessNode,\n\tchanPoint *lnrpc.ChannelPoint) WaitingCloseChannel {\n\n\tvar target WaitingCloseChannel\n\n\top := h.OutPointFromChannelPoint(chanPoint)\n\n\terr := wait.NoError(func() error {\n\t\tresp := hn.RPC.PendingChannels()\n\n\t\tfor _, waitingClose := range resp.WaitingCloseChannels {\n\t\t\tif waitingClose.Channel.ChannelPoint == op.String() {\n\t\t\t\ttarget = waitingClose\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\n\t\treturn fmt.Errorf(\"%v: channel %s not found in waiting close\",\n\t\t\thn.Name(), op)\n\t}, DefaultTimeout)\n\trequire.NoError(h, err, \"assert channel waiting close timed out\")\n\n\treturn target\n}\n\n// AssertTopologyChannelClosed asserts a given channel is closed by checking\n// the graph topology subscription of the specified node. Returns the closed\n// channel update if found.",
      "length": 717,
      "tokens": 88,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertTopologyChannelClosed(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertTopologyChannelClosed(hn *node.HarnessNode,\n\tchanPoint *lnrpc.ChannelPoint) *lnrpc.ClosedChannelUpdate {\n\n\tclosedChan, err := hn.Watcher.WaitForChannelClose(chanPoint)\n\trequire.NoError(h, err, \"failed to wait for channel close\")\n\n\treturn closedChan\n}\n\n// WaitForChannelCloseEvent waits for a notification that a channel is closed\n// by consuming a message from the passed close channel stream. Returns the\n// closing txid if found.",
      "length": 377,
      "tokens": 48,
      "embedding": []
    },
    {
      "slug": "func (h HarnessTest) WaitForChannelCloseEvent(",
      "content": "func (h HarnessTest) WaitForChannelCloseEvent(\n\tstream rpc.CloseChanClient) *chainhash.Hash {\n\n\t// Consume one event.\n\tevent, err := h.ReceiveCloseChannelUpdate(stream)\n\trequire.NoError(h, err)\n\n\tresp, ok := event.Update.(*lnrpc.CloseStatusUpdate_ChanClose)\n\trequire.Truef(h, ok, \"expected channel open update, instead got %v\",\n\t\tresp)\n\n\ttxid, err := chainhash.NewHash(resp.ChanClose.ClosingTxid)\n\trequire.NoErrorf(h, err, \"wrong format found in closing txid: %v\",\n\t\tresp.ChanClose.ClosingTxid)\n\n\treturn txid\n}\n\n// AssertNumWaitingClose checks that a PendingChannels response from the node\n// reports the expected number of waiting close channels.",
      "length": 582,
      "tokens": 64,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertNumWaitingClose(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertNumWaitingClose(hn *node.HarnessNode,\n\tnum int) []*lnrpc.PendingChannelsResponse_WaitingCloseChannel {\n\n\tvar channels []*lnrpc.PendingChannelsResponse_WaitingCloseChannel\n\toldWaiting := hn.State.CloseChannel.WaitingClose\n\n\terr := wait.NoError(func() error {\n\t\tresp := hn.RPC.PendingChannels()\n\t\tchannels = resp.WaitingCloseChannels\n\t\ttotal := len(channels)\n\n\t\tgot := total - oldWaiting\n\t\tif got == num {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn errNumNotMatched(hn.Name(), \"waiting close channels\",\n\t\t\tnum, got, total, oldWaiting)\n\t}, DefaultTimeout)\n\n\trequire.NoErrorf(h, err, \"%s: assert waiting close timeout\",\n\t\thn.Name())\n\n\treturn channels\n}\n\n// AssertNumPendingForceClose checks that a PendingChannels response from the\n// node reports the expected number of pending force close channels.",
      "length": 717,
      "tokens": 79,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertNumPendingForceClose(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertNumPendingForceClose(hn *node.HarnessNode,\n\tnum int) []*lnrpc.PendingChannelsResponse_ForceClosedChannel {\n\n\tvar channels []*lnrpc.PendingChannelsResponse_ForceClosedChannel\n\toldForce := hn.State.CloseChannel.PendingForceClose\n\n\terr := wait.NoError(func() error {\n\t\t// TODO(yy): we should be able to use `hn.RPC.PendingChannels`\n\t\t// here to avoid checking the RPC error. However, we may get a\n\t\t// `unable to find arbitrator` error from the rpc point, due to\n\t\t// a timing issue in rpcserver,\n\t\t// 1. `r.server.chanStateDB.FetchClosedChannels` fetches\n\t\t//    the pending force close channel.\n\t\t// 2. `r.arbitratorPopulateForceCloseResp` relies on the\n\t\t//    channel arbitrator to get the report, and,\n\t\t// 3. the arbitrator may be deleted due to the force close\n\t\t//    channel being resolved.\n\t\t// Somewhere along the line is missing a lock to keep the data\n\t\t// consistent.\n\t\treq := &lnrpc.PendingChannelsRequest{}\n\t\tresp, err := hn.RPC.LN.PendingChannels(h.runCtx, req)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"PendingChannels got: %w\", err)\n\t\t}\n\n\t\tchannels = resp.PendingForceClosingChannels\n\t\ttotal := len(channels)\n\n\t\tgot := total - oldForce\n\t\tif got == num {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn errNumNotMatched(hn.Name(), \"pending force close \"+\n\t\t\t\"channels\", num, got, total, oldForce)\n\t}, DefaultTimeout)\n\n\trequire.NoErrorf(h, err, \"%s: assert pending force close timeout\",\n\t\thn.Name())\n\n\treturn channels\n}\n\n// AssertStreamChannelCoopClosed reads an update from the close channel client\n// stream and asserts that the mempool state and node's topology match a coop\n// close. In specific,\n// - assert the channel is waiting close and has the expected ChanStatusFlags.\n// - assert the mempool has the closing txes and anchor sweeps.\n// - mine a block and assert the closing txid is mined.\n// - assert the node has zero waiting close channels.\n// - assert the node has seen the channel close update.",
      "length": 1809,
      "tokens": 259,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertStreamChannelCoopClosed(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertStreamChannelCoopClosed(hn *node.HarnessNode,\n\tcp *lnrpc.ChannelPoint, anchors bool,\n\tstream rpc.CloseChanClient) *chainhash.Hash {\n\n\t// Assert the channel is waiting close.\n\tresp := h.AssertChannelWaitingClose(hn, cp)\n\n\t// Assert that the channel is in coop broadcasted.\n\trequire.Contains(h, resp.Channel.ChanStatusFlags,\n\t\tchanneldb.ChanStatusCoopBroadcasted.String(),\n\t\t\"channel not coop broadcasted\")\n\n\t// We'll now, generate a single block, wait for the final close status\n\t// update, then ensure that the closing transaction was included in the\n\t// block. If there are anchors, we also expect an anchor sweep.\n\texpectedTxes := 1\n\tif anchors {\n\t\texpectedTxes = 2\n\t}\n\tblock := h.MineBlocksAndAssertNumTxes(1, expectedTxes)[0]\n\n\t// Consume one close event and assert the closing txid can be found in\n\t// the block.\n\tclosingTxid := h.WaitForChannelCloseEvent(stream)\n\th.Miner.AssertTxInBlock(block, closingTxid)\n\n\t// We should see zero waiting close channels now.\n\th.AssertNumWaitingClose(hn, 0)\n\n\t// Finally, check that the node's topology graph has seen this channel\n\t// closed if it's a public channel.\n\tif !resp.Channel.Private {\n\t\th.AssertTopologyChannelClosed(hn, cp)\n\t}\n\n\treturn closingTxid\n}\n\n// AssertStreamChannelForceClosed reads an update from the close channel client\n// stream and asserts that the mempool state and node's topology match a local\n// force close. In specific,\n// - assert the channel is waiting close and has the expected ChanStatusFlags.\n// - assert the mempool has the closing txes and anchor sweeps.\n// - mine a block and assert the closing txid is mined.\n// - assert the channel is pending force close.\n// - assert the node has seen the channel close update.",
      "length": 1603,
      "tokens": 233,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertStreamChannelForceClosed(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertStreamChannelForceClosed(hn *node.HarnessNode,\n\tcp *lnrpc.ChannelPoint, anchors bool,\n\tstream rpc.CloseChanClient) *chainhash.Hash {\n\n\t// Assert the channel is waiting close.\n\tresp := h.AssertChannelWaitingClose(hn, cp)\n\n\t// Assert that the channel is in local force broadcasted.\n\trequire.Contains(h, resp.Channel.ChanStatusFlags,\n\t\tchanneldb.ChanStatusLocalCloseInitiator.String(),\n\t\t\"channel not coop broadcasted\")\n\n\t// We'll now, generate a single block, wait for the final close status\n\t// update, then ensure that the closing transaction was included in the\n\t// block. If there are anchors, we also expect an anchor sweep.\n\texpectedTxes := 1\n\tif anchors {\n\t\texpectedTxes = 2\n\t}\n\tblock := h.MineBlocksAndAssertNumTxes(1, expectedTxes)[0]\n\n\t// Consume one close event and assert the closing txid can be found in\n\t// the block.\n\tclosingTxid := h.WaitForChannelCloseEvent(stream)\n\th.Miner.AssertTxInBlock(block, closingTxid)\n\n\t// We should see zero waiting close channels and 1 pending force close\n\t// channels now.\n\th.AssertNumWaitingClose(hn, 0)\n\th.AssertNumPendingForceClose(hn, 1)\n\n\t// Finally, check that the node's topology graph has seen this channel\n\t// closed if it's a public channel.\n\tif !resp.Channel.Private {\n\t\th.AssertTopologyChannelClosed(hn, cp)\n\t}\n\n\treturn closingTxid\n}\n\n// AssertChannelPolicyUpdate checks that the required policy update has\n// happened on the given node.",
      "length": 1306,
      "tokens": 172,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertChannelPolicyUpdate(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertChannelPolicyUpdate(hn *node.HarnessNode,\n\tadvertisingNode *node.HarnessNode, policy *lnrpc.RoutingPolicy,\n\tchanPoint *lnrpc.ChannelPoint, includeUnannounced bool) {\n\n\trequire.NoError(\n\t\th, hn.Watcher.WaitForChannelPolicyUpdate(\n\t\t\tadvertisingNode, policy,\n\t\t\tchanPoint, includeUnannounced,\n\t\t), \"%s: error while waiting for channel update\", hn.Name(),\n\t)\n}\n\n// WaitForGraphSync waits until the node is synced to graph or times out.",
      "length": 379,
      "tokens": 40,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) WaitForGraphSync(hn *node.HarnessNode) {",
      "content": "func (h *HarnessTest) WaitForGraphSync(hn *node.HarnessNode) {\n\terr := wait.NoError(func() error {\n\t\tresp := hn.RPC.GetInfo()\n\t\tif resp.SyncedToGraph {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn fmt.Errorf(\"node not synced to graph\")\n\t}, DefaultTimeout)\n\trequire.NoError(h, err, \"%s: timeout while sync to graph\", hn.Name())\n}\n\n// AssertNumUTXOsWithConf waits for the given number of UTXOs with the\n// specified confirmations range to be available or fails if that isn't the\n// case before the default timeout.\n//\n// NOTE: for standby nodes(Alice and Bob), this method takes account of the\n// previous state of the node's UTXOs. The previous state is snapshotted when\n// finishing a previous test case via the cleanup function in `Subtest`. In\n// other words, this assertion only checks the new changes made in the current\n// test.",
      "length": 734,
      "tokens": 118,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertNumUTXOsWithConf(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertNumUTXOsWithConf(hn *node.HarnessNode,\n\texpectedUtxos int, max, min int32) []*lnrpc.Utxo {\n\n\tvar unconfirmed bool\n\n\told := hn.State.UTXO.Confirmed\n\tif max == 0 {\n\t\told = hn.State.UTXO.Unconfirmed\n\t\tunconfirmed = true\n\t}\n\n\tvar utxos []*lnrpc.Utxo\n\terr := wait.NoError(func() error {\n\t\treq := &walletrpc.ListUnspentRequest{\n\t\t\tAccount:         \"\",\n\t\t\tMaxConfs:        max,\n\t\t\tMinConfs:        min,\n\t\t\tUnconfirmedOnly: unconfirmed,\n\t\t}\n\t\tresp := hn.RPC.ListUnspent(req)\n\t\ttotal := len(resp.Utxos)\n\n\t\tif total-old == expectedUtxos {\n\t\t\tutxos = resp.Utxos[old:]\n\n\t\t\treturn nil\n\t\t}\n\n\t\treturn errNumNotMatched(hn.Name(), \"num of UTXOs\",\n\t\t\texpectedUtxos, total-old, total, old)\n\t}, DefaultTimeout)\n\trequire.NoError(h, err, \"timeout waiting for UTXOs\")\n\n\treturn utxos\n}\n\n// AssertNumUTXOsUnconfirmed asserts the expected num of unconfirmed utxos are\n// seen.\n//\n// NOTE: for standby nodes(Alice and Bob), this method takes account of the\n// previous state of the node's UTXOs. Check `AssertNumUTXOsWithConf` for\n// details.",
      "length": 936,
      "tokens": 120,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertNumUTXOsUnconfirmed(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertNumUTXOsUnconfirmed(hn *node.HarnessNode,\n\tnum int) []*lnrpc.Utxo {\n\n\treturn h.AssertNumUTXOsWithConf(hn, num, 0, 0)\n}\n\n// AssertNumUTXOsConfirmed asserts the expected num of confirmed utxos are\n// seen, which means the returned utxos have at least one confirmation.\n//\n// NOTE: for standby nodes(Alice and Bob), this method takes account of the\n// previous state of the node's UTXOs. Check `AssertNumUTXOsWithConf` for\n// details.",
      "length": 379,
      "tokens": 58,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertNumUTXOsConfirmed(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertNumUTXOsConfirmed(hn *node.HarnessNode,\n\tnum int) []*lnrpc.Utxo {\n\n\treturn h.AssertNumUTXOsWithConf(hn, num, math.MaxInt32, 1)\n}\n\n// AssertNumUTXOs asserts the expected num of utxos are seen, including\n// confirmed and unconfirmed outputs.\n//\n// NOTE: for standby nodes(Alice and Bob), this method takes account of the\n// previous state of the node's UTXOs. Check `AssertNumUTXOsWithConf` for\n// details.",
      "length": 354,
      "tokens": 52,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertNumUTXOs(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertNumUTXOs(hn *node.HarnessNode,\n\tnum int) []*lnrpc.Utxo {\n\n\treturn h.AssertNumUTXOsWithConf(hn, num, math.MaxInt32, 0)\n}\n\n// getUTXOs gets the number of newly created UTOXs within the current test\n// scope.",
      "length": 168,
      "tokens": 25,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) getUTXOs(hn *node.HarnessNode, account string,",
      "content": "func (h *HarnessTest) getUTXOs(hn *node.HarnessNode, account string,\n\tmax, min int32) []*lnrpc.Utxo {\n\n\tvar unconfirmed bool\n\n\tif max == 0 {\n\t\tunconfirmed = true\n\t}\n\n\treq := &walletrpc.ListUnspentRequest{\n\t\tAccount:         account,\n\t\tMaxConfs:        max,\n\t\tMinConfs:        min,\n\t\tUnconfirmedOnly: unconfirmed,\n\t}\n\tresp := hn.RPC.ListUnspent(req)\n\n\treturn resp.Utxos\n}\n\n// GetUTXOs returns all the UTXOs for the given node's account, including\n// confirmed and unconfirmed.",
      "length": 386,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) GetUTXOs(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) GetUTXOs(hn *node.HarnessNode,\n\taccount string) []*lnrpc.Utxo {\n\n\treturn h.getUTXOs(hn, account, math.MaxInt32, 0)\n}\n\n// GetUTXOsConfirmed returns the confirmed UTXOs for the given node's account.",
      "length": 160,
      "tokens": 21,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) GetUTXOsConfirmed(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) GetUTXOsConfirmed(hn *node.HarnessNode,\n\taccount string) []*lnrpc.Utxo {\n\n\treturn h.getUTXOs(hn, account, math.MaxInt32, 1)\n}\n\n// GetUTXOsUnconfirmed returns the unconfirmed UTXOs for the given node's\n// account.",
      "length": 166,
      "tokens": 22,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) GetUTXOsUnconfirmed(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) GetUTXOsUnconfirmed(hn *node.HarnessNode,\n\taccount string) []*lnrpc.Utxo {\n\n\treturn h.getUTXOs(hn, account, 0, 0)\n}\n\n// WaitForBalanceConfirmed waits until the node sees the expected confirmed\n// balance in its wallet.",
      "length": 170,
      "tokens": 25,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) WaitForBalanceConfirmed(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) WaitForBalanceConfirmed(hn *node.HarnessNode,\n\texpected btcutil.Amount) {\n\n\tvar lastBalance btcutil.Amount\n\terr := wait.NoError(func() error {\n\t\tresp := hn.RPC.WalletBalance()\n\n\t\tlastBalance = btcutil.Amount(resp.ConfirmedBalance)\n\t\tif lastBalance == expected {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn fmt.Errorf(\"expected %v, only have %v\", expected,\n\t\t\tlastBalance)\n\t}, DefaultTimeout)\n\n\trequire.NoError(h, err, \"timeout waiting for confirmed balances\")\n}\n\n// WaitForBalanceUnconfirmed waits until the node sees the expected unconfirmed\n// balance in its wallet.",
      "length": 487,
      "tokens": 58,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) WaitForBalanceUnconfirmed(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) WaitForBalanceUnconfirmed(hn *node.HarnessNode,\n\texpected btcutil.Amount) {\n\n\tvar lastBalance btcutil.Amount\n\terr := wait.NoError(func() error {\n\t\tresp := hn.RPC.WalletBalance()\n\n\t\tlastBalance = btcutil.Amount(resp.UnconfirmedBalance)\n\t\tif lastBalance == expected {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn fmt.Errorf(\"expected %v, only have %v\", expected,\n\t\t\tlastBalance)\n\t}, DefaultTimeout)\n\n\trequire.NoError(h, err, \"timeout waiting for unconfirmed balances\")\n}\n\n// Random32Bytes generates a random 32 bytes which can be used as a pay hash,\n// preimage, etc.",
      "length": 481,
      "tokens": 61,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) Random32Bytes() []byte {",
      "content": "func (h *HarnessTest) Random32Bytes() []byte {\n\trandBuf := make([]byte, lntypes.HashSize)\n\n\t_, err := rand.Read(randBuf)\n\trequire.NoErrorf(h, err, \"internal error, cannot generate random bytes\")\n\n\treturn randBuf\n}\n\n// DecodeAddress decodes a given address and asserts there's no error.",
      "length": 230,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) DecodeAddress(addr string) btcutil.Address {",
      "content": "func (h *HarnessTest) DecodeAddress(addr string) btcutil.Address {\n\tresp, err := btcutil.DecodeAddress(addr, harnessNetParams)\n\trequire.NoError(h, err, \"DecodeAddress failed\")\n\n\treturn resp\n}\n\n// PayToAddrScript creates a new script from the given address and asserts\n// there's no error.",
      "length": 214,
      "tokens": 28,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) PayToAddrScript(addr btcutil.Address) []byte {",
      "content": "func (h *HarnessTest) PayToAddrScript(addr btcutil.Address) []byte {\n\taddrScript, err := txscript.PayToAddrScript(addr)\n\trequire.NoError(h, err, \"PayToAddrScript failed\")\n\n\treturn addrScript\n}\n\n// AssertChannelBalanceResp makes a ChannelBalance request and checks the\n// returned response matches the expected.",
      "length": 234,
      "tokens": 26,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertChannelBalanceResp(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertChannelBalanceResp(hn *node.HarnessNode,\n\texpected *lnrpc.ChannelBalanceResponse) {\n\n\tresp := hn.RPC.ChannelBalance()\n\trequire.True(h, proto.Equal(expected, resp), \"balance is incorrect \"+\n\t\t\"got: %v, want: %v\", resp, expected)\n}\n\n// GetChannelByChanPoint tries to find a channel matching the channel point and\n// asserts. It returns the channel found.",
      "length": 303,
      "tokens": 39,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) GetChannelByChanPoint(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) GetChannelByChanPoint(hn *node.HarnessNode,\n\tchanPoint *lnrpc.ChannelPoint) *lnrpc.Channel {\n\n\tchannel, err := h.findChannel(hn, chanPoint)\n\trequire.NoErrorf(h, err, \"channel not found using %v\", chanPoint)\n\n\treturn channel\n}\n\n// GetChannelCommitType retrieves the active channel commitment type for the\n// given chan point.",
      "length": 271,
      "tokens": 34,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) GetChannelCommitType(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) GetChannelCommitType(hn *node.HarnessNode,\n\tchanPoint *lnrpc.ChannelPoint) lnrpc.CommitmentType {\n\n\tc := h.GetChannelByChanPoint(hn, chanPoint)\n\n\treturn c.CommitmentType\n}\n\n// AssertNumPendingOpenChannels asserts that a given node have the expected\n// number of pending open channels.",
      "length": 233,
      "tokens": 27,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertNumPendingOpenChannels(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertNumPendingOpenChannels(hn *node.HarnessNode,\n\texpected int) []*lnrpc.PendingChannelsResponse_PendingOpenChannel {\n\n\tvar channels []*lnrpc.PendingChannelsResponse_PendingOpenChannel\n\n\toldNum := hn.State.OpenChannel.Pending\n\n\terr := wait.NoError(func() error {\n\t\tresp := hn.RPC.PendingChannels()\n\t\tchannels = resp.PendingOpenChannels\n\t\ttotal := len(channels)\n\n\t\tnumChans := total - oldNum\n\n\t\tif numChans != expected {\n\t\t\treturn errNumNotMatched(hn.Name(),\n\t\t\t\t\"pending open channels\", expected,\n\t\t\t\tnumChans, total, oldNum)\n\t\t}\n\n\t\treturn nil\n\t}, DefaultTimeout)\n\n\trequire.NoError(h, err, \"num of pending open channels not match\")\n\n\treturn channels\n}\n\n// AssertNodesNumPendingOpenChannels asserts that both of the nodes have the\n// expected number of pending open channels.",
      "length": 697,
      "tokens": 77,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertNodesNumPendingOpenChannels(a, b *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertNodesNumPendingOpenChannels(a, b *node.HarnessNode,\n\texpected int) {\n\n\th.AssertNumPendingOpenChannels(a, expected)\n\th.AssertNumPendingOpenChannels(b, expected)\n}\n\n// AssertPaymentStatusFromStream takes a client stream and asserts the payment\n// is in desired status before default timeout. The payment found is returned\n// once succeeded.",
      "length": 278,
      "tokens": 34,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertPaymentStatusFromStream(stream rpc.PaymentClient,",
      "content": "func (h *HarnessTest) AssertPaymentStatusFromStream(stream rpc.PaymentClient,\n\tstatus lnrpc.Payment_PaymentStatus) *lnrpc.Payment {\n\n\treturn h.assertPaymentStatusWithTimeout(\n\t\tstream, status, wait.PaymentTimeout,\n\t)\n}\n\n// AssertPaymentSucceedWithTimeout asserts that a payment is succeeded within\n// the specified timeout.",
      "length": 237,
      "tokens": 24,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertPaymentSucceedWithTimeout(stream rpc.PaymentClient,",
      "content": "func (h *HarnessTest) AssertPaymentSucceedWithTimeout(stream rpc.PaymentClient,\n\ttimeout time.Duration) *lnrpc.Payment {\n\n\treturn h.assertPaymentStatusWithTimeout(\n\t\tstream, lnrpc.Payment_SUCCEEDED, timeout,\n\t)\n}\n\n// assertPaymentStatusWithTimeout takes a client stream and asserts the payment\n// is in desired status before the specified timeout. The payment found is\n// returned once succeeded.",
      "length": 307,
      "tokens": 38,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) assertPaymentStatusWithTimeout(stream rpc.PaymentClient,",
      "content": "func (h *HarnessTest) assertPaymentStatusWithTimeout(stream rpc.PaymentClient,\n\tstatus lnrpc.Payment_PaymentStatus,\n\ttimeout time.Duration) *lnrpc.Payment {\n\n\tvar target *lnrpc.Payment\n\terr := wait.NoError(func() error {\n\t\t// Consume one message. This will raise an error if the message\n\t\t// is not received within DefaultTimeout.\n\t\tpayment, err := h.receivePaymentUpdateWithTimeout(\n\t\t\tstream, timeout,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"received error from payment \"+\n\t\t\t\t\"stream: %s\", err)\n\t\t}\n\n\t\t// Return if the desired payment state is reached.\n\t\tif payment.Status == status {\n\t\t\ttarget = payment\n\n\t\t\treturn nil\n\t\t}\n\n\t\t// Return the err so that it can be used for debugging when\n\t\t// timeout is reached.\n\t\treturn fmt.Errorf(\"payment %v status, got %v, want %v\",\n\t\t\tpayment.PaymentHash, payment.Status, status)\n\t}, timeout)\n\n\trequire.NoError(h, err, \"timeout while waiting payment\")\n\n\treturn target\n}\n\n// ReceivePaymentUpdate waits until a message is received on the payment client\n// stream or the timeout is reached.",
      "length": 919,
      "tokens": 132,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) ReceivePaymentUpdate(",
      "content": "func (h *HarnessTest) ReceivePaymentUpdate(\n\tstream rpc.PaymentClient) (*lnrpc.Payment, error) {\n\n\treturn h.receivePaymentUpdateWithTimeout(stream, DefaultTimeout)\n}\n\n// receivePaymentUpdateWithTimeout waits until a message is received on the\n// payment client stream or the timeout is reached.",
      "length": 244,
      "tokens": 28,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) receivePaymentUpdateWithTimeout(stream rpc.PaymentClient,",
      "content": "func (h *HarnessTest) receivePaymentUpdateWithTimeout(stream rpc.PaymentClient,\n\ttimeout time.Duration) (*lnrpc.Payment, error) {\n\n\tchanMsg := make(chan *lnrpc.Payment, 1)\n\terrChan := make(chan error, 1)\n\n\tgo func() {\n\t\t// Consume one message. This will block until the message is\n\t\t// received.\n\t\tresp, err := stream.Recv()\n\t\tif err != nil {\n\t\t\terrChan <- err\n\n\t\t\treturn\n\t\t}\n\t\tchanMsg <- resp\n\t}()\n\n\tselect {\n\tcase <-time.After(timeout):\n\t\trequire.Fail(h, \"timeout\", \"timeout waiting for payment update\")\n\t\treturn nil, nil\n\n\tcase err := <-errChan:\n\t\treturn nil, err\n\n\tcase updateMsg := <-chanMsg:\n\t\treturn updateMsg, nil\n\t}\n}\n\n// AssertInvoiceSettled asserts a given invoice specified by its payment\n// address is settled.",
      "length": 612,
      "tokens": 93,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertInvoiceSettled(hn *node.HarnessNode, addr []byte) {",
      "content": "func (h *HarnessTest) AssertInvoiceSettled(hn *node.HarnessNode, addr []byte) {\n\tmsg := &invoicesrpc.LookupInvoiceMsg{\n\t\tInvoiceRef: &invoicesrpc.LookupInvoiceMsg_PaymentAddr{\n\t\t\tPaymentAddr: addr,\n\t\t},\n\t}\n\n\terr := wait.NoError(func() error {\n\t\tinvoice := hn.RPC.LookupInvoiceV2(msg)\n\t\tif invoice.State == lnrpc.Invoice_SETTLED {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn fmt.Errorf(\"%s: invoice with payment address %x not \"+\n\t\t\t\"settled\", hn.Name(), addr)\n\t}, DefaultTimeout)\n\trequire.NoError(h, err, \"timeout waiting for invoice settled state\")\n}\n\n// AssertNodeNumChannels polls the provided node's list channels rpc until it\n// reaches the desired number of total channels.",
      "length": 564,
      "tokens": 67,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertNodeNumChannels(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertNodeNumChannels(hn *node.HarnessNode,\n\tnumChannels int) {\n\n\t// Get the total number of channels.\n\told := hn.State.OpenChannel.Active + hn.State.OpenChannel.Inactive\n\n\terr := wait.NoError(func() error {\n\t\t// We require the RPC call to be succeeded and won't wait for\n\t\t// it as it's an unexpected behavior.\n\t\tchanInfo := hn.RPC.ListChannels(&lnrpc.ListChannelsRequest{})\n\n\t\t// Return true if the query returned the expected number of\n\t\t// channels.\n\t\tnum := len(chanInfo.Channels) - old\n\t\tif num != numChannels {\n\t\t\treturn fmt.Errorf(\"expected %v channels, got %v\",\n\t\t\t\tnumChannels, num)\n\t\t}\n\n\t\treturn nil\n\t}, DefaultTimeout)\n\n\trequire.NoError(h, err, \"timeout checking node's num of channels\")\n}\n\n// AssertChannelLocalBalance checks the local balance of the given channel is\n// expected. The channel found using the specified channel point is returned.",
      "length": 789,
      "tokens": 111,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertChannelLocalBalance(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertChannelLocalBalance(hn *node.HarnessNode,\n\tcp *lnrpc.ChannelPoint, balance int64) *lnrpc.Channel {\n\n\tvar result *lnrpc.Channel\n\n\t// Get the funding point.\n\terr := wait.NoError(func() error {\n\t\t// Find the target channel first.\n\t\ttarget, err := h.findChannel(hn, cp)\n\n\t\t// Exit early if the channel is not found.\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"check balance failed: %w\", err)\n\t\t}\n\n\t\tresult = target\n\n\t\t// Check local balance.\n\t\tif target.LocalBalance == balance {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn fmt.Errorf(\"balance is incorrect, got %v, expected %v\",\n\t\t\ttarget.LocalBalance, balance)\n\t}, DefaultTimeout)\n\n\trequire.NoError(h, err, \"timeout while checking for balance\")\n\n\treturn result\n}\n\n// AssertChannelNumUpdates checks the num of updates is expected from the given\n// channel.",
      "length": 710,
      "tokens": 102,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertChannelNumUpdates(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertChannelNumUpdates(hn *node.HarnessNode,\n\tnum uint64, cp *lnrpc.ChannelPoint) {\n\n\told := int(hn.State.OpenChannel.NumUpdates)\n\n\t// Find the target channel first.\n\ttarget, err := h.findChannel(hn, cp)\n\trequire.NoError(h, err, \"unable to find channel\")\n\n\terr = wait.NoError(func() error {\n\t\ttotal := int(target.NumUpdates)\n\t\tif total-old == int(num) {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn errNumNotMatched(hn.Name(), \"channel updates\",\n\t\t\tint(num), total-old, total, old)\n\t}, DefaultTimeout)\n\trequire.NoError(h, err, \"timeout while checking for num of updates\")\n}\n\n// AssertNumActiveHtlcs asserts that a given number of HTLCs are seen in the\n// node's channels.",
      "length": 588,
      "tokens": 77,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertNumActiveHtlcs(hn *node.HarnessNode, num int) {",
      "content": "func (h *HarnessTest) AssertNumActiveHtlcs(hn *node.HarnessNode, num int) {\n\told := hn.State.HTLC\n\n\terr := wait.NoError(func() error {\n\t\t// We require the RPC call to be succeeded and won't wait for\n\t\t// it as it's an unexpected behavior.\n\t\treq := &lnrpc.ListChannelsRequest{}\n\t\tnodeChans := hn.RPC.ListChannels(req)\n\n\t\ttotal := 0\n\t\tfor _, channel := range nodeChans.Channels {\n\t\t\ttotal += len(channel.PendingHtlcs)\n\t\t}\n\t\tif total-old != num {\n\t\t\treturn errNumNotMatched(hn.Name(), \"active HTLCs\",\n\t\t\t\tnum, total-old, total, old)\n\t\t}\n\n\t\treturn nil\n\t}, DefaultTimeout)\n\n\trequire.NoErrorf(h, err, \"%s timeout checking num active htlcs\",\n\t\thn.Name())\n}\n\n// AssertActiveHtlcs makes sure the node has the _exact_ HTLCs matching\n// payHashes on _all_ their channels.",
      "length": 659,
      "tokens": 93,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertActiveHtlcs(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertActiveHtlcs(hn *node.HarnessNode,\n\tpayHashes ...[]byte) {\n\n\terr := wait.NoError(func() error {\n\t\t// We require the RPC call to be succeeded and won't wait for\n\t\t// it as it's an unexpected behavior.\n\t\treq := &lnrpc.ListChannelsRequest{}\n\t\tnodeChans := hn.RPC.ListChannels(req)\n\n\t\tfor _, ch := range nodeChans.Channels {\n\t\t\t// Record all payment hashes active for this channel.\n\t\t\thtlcHashes := make(map[string]struct{})\n\n\t\t\tfor _, htlc := range ch.PendingHtlcs {\n\t\t\t\th := hex.EncodeToString(htlc.HashLock)\n\t\t\t\t_, ok := htlcHashes[h]\n\t\t\t\tif ok {\n\t\t\t\t\treturn fmt.Errorf(\"duplicate HashLock \"+\n\t\t\t\t\t\t\"in PendingHtlcs: %v\",\n\t\t\t\t\t\tch.PendingHtlcs)\n\t\t\t\t}\n\t\t\t\thtlcHashes[h] = struct{}{}\n\t\t\t}\n\n\t\t\t// Channel should have exactly the payHashes active.\n\t\t\tif len(payHashes) != len(htlcHashes) {\n\t\t\t\treturn fmt.Errorf(\"node [%s:%x] had %v \"+\n\t\t\t\t\t\"htlcs active, expected %v\",\n\t\t\t\t\thn.Name(), hn.PubKey[:],\n\t\t\t\t\tlen(htlcHashes), len(payHashes))\n\t\t\t}\n\n\t\t\t// Make sure all the payHashes are active.\n\t\t\tfor _, payHash := range payHashes {\n\t\t\t\th := hex.EncodeToString(payHash)\n\t\t\t\tif _, ok := htlcHashes[h]; ok {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\treturn fmt.Errorf(\"node [%s:%x] didn't have: \"+\n\t\t\t\t\t\"the payHash %v active\", hn.Name(),\n\t\t\t\t\thn.PubKey[:], h)\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}, DefaultTimeout)\n\trequire.NoError(h, err, \"timeout checking active HTLCs\")\n}\n\n// ReceiveSingleInvoice waits until a message is received on the subscribe\n// single invoice stream or the timeout is reached.",
      "length": 1378,
      "tokens": 184,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) ReceiveSingleInvoice(",
      "content": "func (h *HarnessTest) ReceiveSingleInvoice(\n\tstream rpc.SingleInvoiceClient) *lnrpc.Invoice {\n\n\tchanMsg := make(chan *lnrpc.Invoice, 1)\n\terrChan := make(chan error, 1)\n\tgo func() {\n\t\t// Consume one message. This will block until the message is\n\t\t// received.\n\t\tresp, err := stream.Recv()\n\t\tif err != nil {\n\t\t\terrChan <- err\n\n\t\t\treturn\n\t\t}\n\t\tchanMsg <- resp\n\t}()\n\n\tselect {\n\tcase <-time.After(DefaultTimeout):\n\t\trequire.Fail(h, \"timeout\", \"timeout receiving single invoice\")\n\n\tcase err := <-errChan:\n\t\trequire.Failf(h, \"err from stream\",\n\t\t\t\"received err from stream: %v\", err)\n\n\tcase updateMsg := <-chanMsg:\n\t\treturn updateMsg\n\t}\n\n\treturn nil\n}\n\n// AssertInvoiceState takes a single invoice subscription stream and asserts\n// that a given invoice has became the desired state before timeout and returns\n// the invoice found.",
      "length": 747,
      "tokens": 110,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertInvoiceState(stream rpc.SingleInvoiceClient,",
      "content": "func (h *HarnessTest) AssertInvoiceState(stream rpc.SingleInvoiceClient,\n\tstate lnrpc.Invoice_InvoiceState) *lnrpc.Invoice {\n\n\tvar invoice *lnrpc.Invoice\n\n\terr := wait.NoError(func() error {\n\t\tinvoice = h.ReceiveSingleInvoice(stream)\n\t\tif invoice.State == state {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn fmt.Errorf(\"mismatched invoice state, want %v, got %v\",\n\t\t\tstate, invoice.State)\n\t}, DefaultTimeout)\n\trequire.NoError(h, err, \"timeout waiting for invoice state: %v\", state)\n\n\treturn invoice\n}\n\n// assertAllTxesSpendFrom asserts that all txes in the list spend from the\n// given tx.",
      "length": 481,
      "tokens": 62,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertAllTxesSpendFrom(txes []*wire.MsgTx,",
      "content": "func (h *HarnessTest) AssertAllTxesSpendFrom(txes []*wire.MsgTx,\n\tprevTxid chainhash.Hash) {\n\n\tfor _, tx := range txes {\n\t\tif tx.TxIn[0].PreviousOutPoint.Hash != prevTxid {\n\t\t\trequire.Failf(h, \"\", \"tx %v did not spend from %v\",\n\t\t\t\ttx.TxHash(), prevTxid)\n\t\t}\n\t}\n}\n\n// AssertTxSpendFrom asserts that a given tx is spent from a previous tx.",
      "length": 263,
      "tokens": 42,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertTxSpendFrom(tx *wire.MsgTx,",
      "content": "func (h *HarnessTest) AssertTxSpendFrom(tx *wire.MsgTx,\n\tprevTxid chainhash.Hash) {\n\n\tif tx.TxIn[0].PreviousOutPoint.Hash != prevTxid {\n\t\trequire.Failf(h, \"\", \"tx %v did not spend from %v\",\n\t\t\ttx.TxHash(), prevTxid)\n\t}\n}\n",
      "length": 158,
      "tokens": 21,
      "embedding": []
    },
    {
      "slug": "type PendingForceClose *lnrpc.PendingChannelsResponse_ForceClosedChannel",
      "content": "type PendingForceClose *lnrpc.PendingChannelsResponse_ForceClosedChannel\n\n// AssertChannelPendingForceClose asserts that the given channel found in the\n// node is pending force close. Returns the PendingForceClose if found.",
      "length": 148,
      "tokens": 21,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertChannelPendingForceClose(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertChannelPendingForceClose(hn *node.HarnessNode,\n\tchanPoint *lnrpc.ChannelPoint) PendingForceClose {\n\n\tvar target PendingForceClose\n\n\top := h.OutPointFromChannelPoint(chanPoint)\n\n\terr := wait.NoError(func() error {\n\t\tresp := hn.RPC.PendingChannels()\n\n\t\tforceCloseChans := resp.PendingForceClosingChannels\n\t\tfor _, ch := range forceCloseChans {\n\t\t\tif ch.Channel.ChannelPoint == op.String() {\n\t\t\t\ttarget = ch\n\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\n\t\treturn fmt.Errorf(\"%v: channel %s not found in pending \"+\n\t\t\t\"force close\", hn.Name(), chanPoint)\n\t}, DefaultTimeout)\n\trequire.NoError(h, err, \"assert pending force close timed out\")\n\n\treturn target\n}\n\n// AssertNumHTLCsAndStage takes a pending force close channel's channel point\n// and asserts the expected number of pending HTLCs and HTLC stage are matched.",
      "length": 718,
      "tokens": 90,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertNumHTLCsAndStage(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertNumHTLCsAndStage(hn *node.HarnessNode,\n\tchanPoint *lnrpc.ChannelPoint, num int, stage uint32) {\n\n\t// Get the channel output point.\n\tcp := h.OutPointFromChannelPoint(chanPoint)\n\n\tvar target PendingForceClose\n\tcheckStage := func() error {\n\t\tresp := hn.RPC.PendingChannels()\n\t\tif len(resp.PendingForceClosingChannels) == 0 {\n\t\t\treturn fmt.Errorf(\"zero pending force closing channels\")\n\t\t}\n\n\t\tfor _, ch := range resp.PendingForceClosingChannels {\n\t\t\tif ch.Channel.ChannelPoint == cp.String() {\n\t\t\t\ttarget = ch\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif target == nil {\n\t\t\treturn fmt.Errorf(\"cannot find pending force closing \"+\n\t\t\t\t\"channel using %v\", cp)\n\t\t}\n\n\t\tif target.LimboBalance == 0 {\n\t\t\treturn fmt.Errorf(\"zero limbo balance\")\n\t\t}\n\n\t\tif len(target.PendingHtlcs) != num {\n\t\t\treturn fmt.Errorf(\"got %d pending htlcs, want %d\",\n\t\t\t\tlen(target.PendingHtlcs), num)\n\t\t}\n\n\t\tfor i, htlc := range target.PendingHtlcs {\n\t\t\tif htlc.Stage == stage {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\treturn fmt.Errorf(\"HTLC %d got stage: %v, \"+\n\t\t\t\t\"want stage: %v\", i, htlc.Stage, stage)\n\t\t}\n\n\t\treturn nil\n\t}\n\n\trequire.NoErrorf(h, wait.NoError(checkStage, DefaultTimeout),\n\t\t\"timeout waiting for htlc stage\")\n}\n\n// findPayment queries the payment from the node's ListPayments which matches\n// the specified preimage hash.",
      "length": 1180,
      "tokens": 155,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) findPayment(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) findPayment(hn *node.HarnessNode,\n\tpaymentHash string) *lnrpc.Payment {\n\n\treq := &lnrpc.ListPaymentsRequest{IncludeIncomplete: true}\n\tpaymentsResp := hn.RPC.ListPayments(req)\n\n\tfor _, p := range paymentsResp.Payments {\n\t\tif p.PaymentHash != paymentHash {\n\t\t\tcontinue\n\t\t}\n\n\t\treturn p\n\t}\n\n\trequire.Failf(h, \"payment not found\", \"payment %v cannot be found\",\n\t\tpaymentHash)\n\n\treturn nil\n}\n\n// AssertPaymentStatus asserts that the given node list a payment with the\n// given preimage has the expected status. It also checks that the payment has\n// the expected preimage, which is empty when it's not settled and matches the\n// given preimage when it's succeeded.",
      "length": 602,
      "tokens": 87,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertPaymentStatus(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertPaymentStatus(hn *node.HarnessNode,\n\tpreimage lntypes.Preimage,\n\tstatus lnrpc.Payment_PaymentStatus) *lnrpc.Payment {\n\n\tvar target *lnrpc.Payment\n\n\terr := wait.NoError(func() error {\n\t\tp := h.findPayment(hn, preimage.Hash().String())\n\t\tif status == p.Status {\n\t\t\ttarget = p\n\t\t\treturn nil\n\t\t}\n\n\t\treturn fmt.Errorf(\"payment: %v status not match, want %s \"+\n\t\t\t\"got %s\", preimage, status, p.Status)\n\t}, DefaultTimeout)\n\trequire.NoError(h, err, \"timeout checking payment status\")\n\n\tswitch status {\n\t// If this expected status is SUCCEEDED, we expect the final\n\t// preimage.\n\tcase lnrpc.Payment_SUCCEEDED:\n\t\trequire.Equal(h, preimage.String(), target.PaymentPreimage,\n\t\t\t\"preimage not match\")\n\n\t// Otherwise we expect an all-zero preimage.\n\tdefault:\n\t\trequire.Equal(h, (lntypes.Preimage{}).String(),\n\t\t\ttarget.PaymentPreimage, \"expected zero preimage\")\n\t}\n\n\treturn target\n}\n\n// AssertActiveNodesSynced asserts all active nodes have synced to the chain.",
      "length": 878,
      "tokens": 104,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertActiveNodesSynced() {",
      "content": "func (h *HarnessTest) AssertActiveNodesSynced() {\n\tfor _, node := range h.manager.activeNodes {\n\t\th.WaitForBlockchainSync(node)\n\t}\n}\n\n// AssertActiveNodesSyncedTo asserts all active nodes have synced to the\n// provided bestBlock.",
      "length": 173,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertActiveNodesSyncedTo(bestBlock *wire.MsgBlock) {",
      "content": "func (h *HarnessTest) AssertActiveNodesSyncedTo(bestBlock *wire.MsgBlock) {\n\tfor _, node := range h.manager.activeNodes {\n\t\th.WaitForBlockchainSyncTo(node, bestBlock)\n\t}\n}\n\n// AssertPeerNotConnected asserts that the given node b is not connected to a.",
      "length": 170,
      "tokens": 24,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertPeerNotConnected(a, b *node.HarnessNode) {",
      "content": "func (h *HarnessTest) AssertPeerNotConnected(a, b *node.HarnessNode) {\n\terr := wait.NoError(func() error {\n\t\t// We require the RPC call to be succeeded and won't wait for\n\t\t// it as it's an unexpected behavior.\n\t\tresp := a.RPC.ListPeers()\n\n\t\t// If node B is seen in the ListPeers response from node A,\n\t\t// then we return false as the connection has been fully\n\t\t// established.\n\t\tfor _, peer := range resp.Peers {\n\t\t\tif peer.PubKey == b.PubKeyStr {\n\t\t\t\treturn fmt.Errorf(\"peers %s and %s still \"+\n\t\t\t\t\t\"connected\", a.Name(), b.Name())\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}, DefaultTimeout)\n\trequire.NoError(h, err, \"timeout checking peers not connected\")\n}\n\n// AssertNotConnected asserts that two peers are not connected.",
      "length": 619,
      "tokens": 99,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertNotConnected(a, b *node.HarnessNode) {",
      "content": "func (h *HarnessTest) AssertNotConnected(a, b *node.HarnessNode) {\n\th.AssertPeerNotConnected(a, b)\n\th.AssertPeerNotConnected(b, a)\n}\n\n// AssertConnected asserts that two peers are connected.",
      "length": 119,
      "tokens": 13,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertConnected(a, b *node.HarnessNode) {",
      "content": "func (h *HarnessTest) AssertConnected(a, b *node.HarnessNode) {\n\th.AssertPeerConnected(a, b)\n\th.AssertPeerConnected(b, a)\n}\n\n// AssertAmountPaid checks that the ListChannels command of the provided\n// node list the total amount sent and received as expected for the\n// provided channel.",
      "length": 216,
      "tokens": 31,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertAmountPaid(channelName string, hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertAmountPaid(channelName string, hn *node.HarnessNode,\n\tchanPoint *lnrpc.ChannelPoint, amountSent, amountReceived int64) {\n\n\tcheckAmountPaid := func() error {\n\t\t// Find the targeted channel.\n\t\tchannel, err := h.findChannel(hn, chanPoint)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"assert amount failed: %w\", err)\n\t\t}\n\n\t\tif channel.TotalSatoshisSent != amountSent {\n\t\t\treturn fmt.Errorf(\"%v: incorrect amount\"+\n\t\t\t\t\" sent: %v != %v\", channelName,\n\t\t\t\tchannel.TotalSatoshisSent,\n\t\t\t\tamountSent)\n\t\t}\n\t\tif channel.TotalSatoshisReceived !=\n\t\t\tamountReceived {\n\n\t\t\treturn fmt.Errorf(\"%v: incorrect amount\"+\n\t\t\t\t\" received: %v != %v\",\n\t\t\t\tchannelName,\n\t\t\t\tchannel.TotalSatoshisReceived,\n\t\t\t\tamountReceived)\n\t\t}\n\n\t\treturn nil\n\t}\n\n\t// As far as HTLC inclusion in commitment transaction might be\n\t// postponed we will try to check the balance couple of times,\n\t// and then if after some period of time we receive wrong\n\t// balance return the error.\n\terr := wait.NoError(checkAmountPaid, DefaultTimeout)\n\trequire.NoError(h, err, \"timeout while checking amount paid\")\n}\n\n// AssertLastHTLCError checks that the last sent HTLC of the last payment sent\n// by the given node failed with the expected failure code.",
      "length": 1102,
      "tokens": 148,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertLastHTLCError(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertLastHTLCError(hn *node.HarnessNode,\n\tcode lnrpc.Failure_FailureCode) {\n\n\t// Use -1 to specify the last HTLC.\n\th.assertHTLCError(hn, code, -1)\n}\n\n// AssertFirstHTLCError checks that the first HTLC of the last payment sent\n// by the given node failed with the expected failure code.",
      "length": 237,
      "tokens": 38,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertFirstHTLCError(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertFirstHTLCError(hn *node.HarnessNode,\n\tcode lnrpc.Failure_FailureCode) {\n\n\t// Use 0 to specify the first HTLC.\n\th.assertHTLCError(hn, code, 0)\n}\n\n// assertLastHTLCError checks that the HTLC at the specified index of the last\n// payment sent by the given node failed with the expected failure code.",
      "length": 252,
      "tokens": 41,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) assertHTLCError(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) assertHTLCError(hn *node.HarnessNode,\n\tcode lnrpc.Failure_FailureCode, index int) {\n\n\treq := &lnrpc.ListPaymentsRequest{\n\t\tIncludeIncomplete: true,\n\t}\n\n\terr := wait.NoError(func() error {\n\t\tpaymentsResp := hn.RPC.ListPayments(req)\n\n\t\tpayments := paymentsResp.Payments\n\t\tif len(payments) == 0 {\n\t\t\treturn fmt.Errorf(\"no payments found\")\n\t\t}\n\n\t\tpayment := payments[len(payments)-1]\n\t\thtlcs := payment.Htlcs\n\t\tif len(htlcs) == 0 {\n\t\t\treturn fmt.Errorf(\"no htlcs found\")\n\t\t}\n\n\t\t// If the index is greater than 0, check we have enough htlcs.\n\t\tif index > 0 && len(htlcs) <= index {\n\t\t\treturn fmt.Errorf(\"not enough htlcs\")\n\t\t}\n\n\t\t// If index is less than or equal to 0, we will read the last\n\t\t// htlc.\n\t\tif index <= 0 {\n\t\t\tindex = len(htlcs) - 1\n\t\t}\n\n\t\thtlc := htlcs[index]\n\n\t\t// The htlc must have a status of failed.\n\t\tif htlc.Status != lnrpc.HTLCAttempt_FAILED {\n\t\t\treturn fmt.Errorf(\"htlc should be failed\")\n\t\t}\n\t\t// The failure field must not be empty.\n\t\tif htlc.Failure == nil {\n\t\t\treturn fmt.Errorf(\"expected htlc failure\")\n\t\t}\n\n\t\t// Exit if the expected code is found.\n\t\tif htlc.Failure.Code == code {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn fmt.Errorf(\"unexpected failure code\")\n\t}, DefaultTimeout)\n\n\trequire.NoError(h, err, \"timeout checking HTLC error\")\n}\n\n// AssertZombieChannel asserts that a given channel found using the chanID is\n// marked as zombie.",
      "length": 1258,
      "tokens": 189,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertZombieChannel(hn *node.HarnessNode, chanID uint64) {",
      "content": "func (h *HarnessTest) AssertZombieChannel(hn *node.HarnessNode, chanID uint64) {\n\tctxt, cancel := context.WithTimeout(h.runCtx, DefaultTimeout)\n\tdefer cancel()\n\n\terr := wait.NoError(func() error {\n\t\t_, err := hn.RPC.LN.GetChanInfo(\n\t\t\tctxt, &lnrpc.ChanInfoRequest{ChanId: chanID},\n\t\t)\n\t\tif err == nil {\n\t\t\treturn fmt.Errorf(\"expected error but got nil\")\n\t\t}\n\n\t\tif !strings.Contains(err.Error(), \"marked as zombie\") {\n\t\t\treturn fmt.Errorf(\"expected error to contain '%s' but \"+\n\t\t\t\t\"was '%v'\", \"marked as zombie\", err)\n\t\t}\n\n\t\treturn nil\n\t}, DefaultTimeout)\n\trequire.NoError(h, err, \"timeout while checking zombie channel\")\n}\n\n// AssertTxAtHeight gets all of the transactions that a node's wallet has a\n// record of at the target height, and finds and returns the tx with the target\n// txid, failing if it is not found.",
      "length": 713,
      "tokens": 102,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertTxAtHeight(hn *node.HarnessNode, height int32,",
      "content": "func (h *HarnessTest) AssertTxAtHeight(hn *node.HarnessNode, height int32,\n\ttxid *chainhash.Hash) *lnrpc.Transaction {\n\n\treq := &lnrpc.GetTransactionsRequest{\n\t\tStartHeight: height,\n\t\tEndHeight:   height,\n\t}\n\ttxns := hn.RPC.GetTransactions(req)\n\n\tfor _, tx := range txns.Transactions {\n\t\tif tx.TxHash == txid.String() {\n\t\t\treturn tx\n\t\t}\n\t}\n\n\trequire.Failf(h, \"fail to find tx\", \"tx:%v not found at height:%v\",\n\t\ttxid, height)\n\n\treturn nil\n}\n\n// getChannelPolicies queries the channel graph and retrieves the current edge\n// policies for the provided channel point.",
      "length": 468,
      "tokens": 64,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) getChannelPolicies(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) getChannelPolicies(hn *node.HarnessNode,\n\tadvertisingNode string,\n\tcp *lnrpc.ChannelPoint) (*lnrpc.RoutingPolicy, error) {\n\n\treq := &lnrpc.ChannelGraphRequest{IncludeUnannounced: true}\n\tchanGraph := hn.RPC.DescribeGraph(req)\n\n\tcpStr := channelPointStr(cp)\n\tfor _, e := range chanGraph.Edges {\n\t\tif e.ChanPoint != cpStr {\n\t\t\tcontinue\n\t\t}\n\n\t\tif e.Node1Pub == advertisingNode {\n\t\t\treturn e.Node1Policy, nil\n\t\t}\n\n\t\treturn e.Node2Policy, nil\n\t}\n\n\t// If we've iterated over all the known edges and we weren't\n\t// able to find this specific one, then we'll fail.\n\treturn nil, fmt.Errorf(\"did not find edge with advertisingNode: %s\"+\n\t\t\", channel point: %s\", advertisingNode, cpStr)\n}\n\n// AssertChannelPolicy asserts that the passed node's known channel policy for\n// the passed chanPoint is consistent with the expected policy values.",
      "length": 760,
      "tokens": 104,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertChannelPolicy(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertChannelPolicy(hn *node.HarnessNode,\n\tadvertisingNode string, expectedPolicy *lnrpc.RoutingPolicy,\n\tchanPoint *lnrpc.ChannelPoint) {\n\n\tpolicy, err := h.getChannelPolicies(hn, advertisingNode, chanPoint)\n\trequire.NoErrorf(h, err, \"%s: failed to find policy\", hn.Name())\n\n\terr = node.CheckChannelPolicy(policy, expectedPolicy)\n\trequire.NoErrorf(h, err, \"%s: check policy failed\", hn.Name())\n}\n\n// AssertNumPolicyUpdates asserts that a given number of channel policy updates\n// has been seen in the specified node.",
      "length": 463,
      "tokens": 52,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertNumPolicyUpdates(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertNumPolicyUpdates(hn *node.HarnessNode,\n\tchanPoint *lnrpc.ChannelPoint,\n\tadvertisingNode *node.HarnessNode, num int) {\n\n\top := h.OutPointFromChannelPoint(chanPoint)\n\n\tvar policies []*node.PolicyUpdateInfo\n\n\terr := wait.NoError(func() error {\n\t\tpolicyMap := hn.Watcher.GetPolicyUpdates(op)\n\t\tnodePolicy, ok := policyMap[advertisingNode.PubKeyStr]\n\t\tif ok {\n\t\t\tpolicies = nodePolicy\n\t\t}\n\n\t\tif len(policies) == num {\n\t\t\treturn nil\n\t\t}\n\n\t\tp, err := json.MarshalIndent(policies, \"\", \"\\t\")\n\t\trequire.NoError(h, err, \"encode policy err\")\n\n\t\treturn fmt.Errorf(\"expected to find %d policy updates, \"+\n\t\t\t\"instead got: %d, chanPoint: %v, \"+\n\t\t\t\"advertisingNode: %s:%s, policy: %s\", num,\n\t\t\tlen(policies), op, advertisingNode.Name(),\n\t\t\tadvertisingNode.PubKeyStr, p)\n\t}, DefaultTimeout)\n\n\trequire.NoError(h, err, \"%s: timeout waiting for num of policy updates\",\n\t\thn.Name())\n}\n\n// AssertNumPayments asserts that the number of payments made within the test\n// scope is as expected, including the incomplete ones.",
      "length": 927,
      "tokens": 110,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertNumPayments(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertNumPayments(hn *node.HarnessNode,\n\tnum int) []*lnrpc.Payment {\n\n\t// Get the number of payments we already have from the previous test.\n\thave := hn.State.Payment.Total\n\n\treq := &lnrpc.ListPaymentsRequest{\n\t\tIncludeIncomplete: true,\n\t\tIndexOffset:       hn.State.Payment.LastIndexOffset,\n\t}\n\n\tvar payments []*lnrpc.Payment\n\terr := wait.NoError(func() error {\n\t\tresp := hn.RPC.ListPayments(req)\n\n\t\tpayments = resp.Payments\n\t\tif len(payments) == num {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn errNumNotMatched(hn.Name(), \"num of payments\",\n\t\t\tnum, len(payments), have+len(payments), have)\n\t}, DefaultTimeout)\n\trequire.NoError(h, err, \"%s: timeout checking num of payments\",\n\t\thn.Name())\n\n\treturn payments\n}\n\n// AssertNumNodeAnns asserts that a given number of node announcements has been\n// seen in the specified node.",
      "length": 738,
      "tokens": 91,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertNumNodeAnns(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertNumNodeAnns(hn *node.HarnessNode,\n\tpubkey string, num int) []*lnrpc.NodeUpdate {\n\n\t// We will get the current number of channel updates first and add it\n\t// to our expected number of newly created channel updates.\n\tanns, err := hn.Watcher.WaitForNumNodeUpdates(pubkey, num)\n\trequire.NoError(h, err, \"%s: failed to assert num of node anns\",\n\t\thn.Name())\n\n\treturn anns\n}\n\n// AssertNumChannelUpdates asserts that a given number of channel updates has\n// been seen in the specified node's network topology.",
      "length": 456,
      "tokens": 69,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertNumChannelUpdates(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertNumChannelUpdates(hn *node.HarnessNode,\n\tchanPoint *lnrpc.ChannelPoint, num int) {\n\n\top := h.OutPointFromChannelPoint(chanPoint)\n\terr := hn.Watcher.WaitForNumChannelUpdates(op, num)\n\trequire.NoError(h, err, \"%s: failed to assert num of channel updates\",\n\t\thn.Name())\n}\n\n// CreateBurnAddr creates a random burn address of the given type.",
      "length": 288,
      "tokens": 35,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) CreateBurnAddr(addrType lnrpc.AddressType) ([]byte,",
      "content": "func (h *HarnessTest) CreateBurnAddr(addrType lnrpc.AddressType) ([]byte,\n\tbtcutil.Address) {\n\n\trandomPrivKey, err := btcec.NewPrivateKey()\n\trequire.NoError(h, err)\n\n\trandomKeyBytes := randomPrivKey.PubKey().SerializeCompressed()\n\n\tvar addr btcutil.Address\n\tswitch addrType {\n\tcase lnrpc.AddressType_WITNESS_PUBKEY_HASH:\n\t\taddr, err = btcutil.NewAddressWitnessPubKeyHash(\n\t\t\tbtcutil.Hash160(randomKeyBytes), harnessNetParams,\n\t\t)\n\n\tcase lnrpc.AddressType_TAPROOT_PUBKEY:\n\t\ttaprootKey := txscript.ComputeTaprootKeyNoScript(\n\t\t\trandomPrivKey.PubKey(),\n\t\t)\n\t\taddr, err = btcutil.NewAddressPubKey(\n\t\t\tschnorr.SerializePubKey(taprootKey), harnessNetParams,\n\t\t)\n\n\tcase lnrpc.AddressType_NESTED_PUBKEY_HASH:\n\t\tvar witnessAddr btcutil.Address\n\t\twitnessAddr, err = btcutil.NewAddressWitnessPubKeyHash(\n\t\t\tbtcutil.Hash160(randomKeyBytes), harnessNetParams,\n\t\t)\n\t\trequire.NoError(h, err)\n\n\t\taddr, err = btcutil.NewAddressScriptHash(\n\t\t\th.PayToAddrScript(witnessAddr), harnessNetParams,\n\t\t)\n\n\tdefault:\n\t\th.Fatalf(\"Unsupported burn address type: %v\", addrType)\n\t}\n\trequire.NoError(h, err)\n\n\treturn h.PayToAddrScript(addr), addr\n}\n\n// ReceiveTrackPayment waits until a message is received on the track payment\n// stream or the timeout is reached.",
      "length": 1116,
      "tokens": 94,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) ReceiveTrackPayment(",
      "content": "func (h *HarnessTest) ReceiveTrackPayment(\n\tstream rpc.TrackPaymentClient) *lnrpc.Payment {\n\n\tchanMsg := make(chan *lnrpc.Payment)\n\terrChan := make(chan error)\n\tgo func() {\n\t\t// Consume one message. This will block until the message is\n\t\t// received.\n\t\tresp, err := stream.Recv()\n\t\tif err != nil {\n\t\t\terrChan <- err\n\t\t\treturn\n\t\t}\n\t\tchanMsg <- resp\n\t}()\n\n\tselect {\n\tcase <-time.After(DefaultTimeout):\n\t\trequire.Fail(h, \"timeout\", \"timeout trakcing payment\")\n\n\tcase err := <-errChan:\n\t\trequire.Failf(h, \"err from stream\",\n\t\t\t\"received err from stream: %v\", err)\n\n\tcase updateMsg := <-chanMsg:\n\t\treturn updateMsg\n\t}\n\n\treturn nil\n}\n\n// ReceiveHtlcEvent waits until a message is received on the subscribe\n// htlc event stream or the timeout is reached.",
      "length": 673,
      "tokens": 99,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) ReceiveHtlcEvent(",
      "content": "func (h *HarnessTest) ReceiveHtlcEvent(\n\tstream rpc.HtlcEventsClient) *routerrpc.HtlcEvent {\n\n\tchanMsg := make(chan *routerrpc.HtlcEvent)\n\terrChan := make(chan error)\n\tgo func() {\n\t\t// Consume one message. This will block until the message is\n\t\t// received.\n\t\tresp, err := stream.Recv()\n\t\tif err != nil {\n\t\t\terrChan <- err\n\t\t\treturn\n\t\t}\n\t\tchanMsg <- resp\n\t}()\n\n\tselect {\n\tcase <-time.After(DefaultTimeout):\n\t\trequire.Fail(h, \"timeout\", \"timeout receiving htlc \"+\n\t\t\t\"event update\")\n\n\tcase err := <-errChan:\n\t\trequire.Failf(h, \"err from stream\",\n\t\t\t\"received err from stream: %v\", err)\n\n\tcase updateMsg := <-chanMsg:\n\t\treturn updateMsg\n\t}\n\n\treturn nil\n}\n\n// AssertHtlcEventType consumes one event from a client and asserts the event\n// type is matched.",
      "length": 679,
      "tokens": 98,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertHtlcEventType(client rpc.HtlcEventsClient,",
      "content": "func (h *HarnessTest) AssertHtlcEventType(client rpc.HtlcEventsClient,\n\tuserType routerrpc.HtlcEvent_EventType) *routerrpc.HtlcEvent {\n\n\tevent := h.ReceiveHtlcEvent(client)\n\trequire.Equalf(h, userType, event.EventType, \"wrong event type, \"+\n\t\t\"want %v got %v\", userType, event.EventType)\n\n\treturn event\n}\n\n// HtlcEvent maps the series of event types used in `*routerrpc.HtlcEvent_*`.",
      "length": 303,
      "tokens": 34,
      "embedding": []
    },
    {
      "slug": "type HtlcEvent int",
      "content": "type HtlcEvent int\n\nconst (\n\tHtlcEventForward HtlcEvent = iota\n\tHtlcEventForwardFail\n\tHtlcEventSettle\n\tHtlcEventLinkFail\n\tHtlcEventFinal\n)\n\n// AssertHtlcEventType consumes one event from a client and asserts both the\n// user event type the event.Event type is matched.",
      "length": 239,
      "tokens": 32,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertHtlcEventTypes(client rpc.HtlcEventsClient,",
      "content": "func (h *HarnessTest) AssertHtlcEventTypes(client rpc.HtlcEventsClient,\n\tuserType routerrpc.HtlcEvent_EventType,\n\teventType HtlcEvent) *routerrpc.HtlcEvent {\n\n\tevent := h.ReceiveHtlcEvent(client)\n\trequire.Equalf(h, userType, event.EventType, \"wrong event type, \"+\n\t\t\"want %v got %v\", userType, event.EventType)\n\n\tvar ok bool\n\n\tswitch eventType {\n\tcase HtlcEventForward:\n\t\t_, ok = event.Event.(*routerrpc.HtlcEvent_ForwardEvent)\n\n\tcase HtlcEventForwardFail:\n\t\t_, ok = event.Event.(*routerrpc.HtlcEvent_ForwardFailEvent)\n\n\tcase HtlcEventSettle:\n\t\t_, ok = event.Event.(*routerrpc.HtlcEvent_SettleEvent)\n\n\tcase HtlcEventLinkFail:\n\t\t_, ok = event.Event.(*routerrpc.HtlcEvent_LinkFailEvent)\n\n\tcase HtlcEventFinal:\n\t\t_, ok = event.Event.(*routerrpc.HtlcEvent_FinalHtlcEvent)\n\t}\n\n\trequire.Truef(h, ok, \"wrong event type: %T, want %T\", event.Event,\n\t\teventType)\n\n\treturn event\n}\n\n// AssertFeeReport checks that the fee report from the given node has the\n// desired day, week, and month sum values.",
      "length": 883,
      "tokens": 93,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertFeeReport(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertFeeReport(hn *node.HarnessNode,\n\tday, week, month int) {\n\n\tctxt, cancel := context.WithTimeout(h.runCtx, DefaultTimeout)\n\tdefer cancel()\n\n\tfeeReport, err := hn.RPC.LN.FeeReport(ctxt, &lnrpc.FeeReportRequest{})\n\trequire.NoError(h, err, \"unable to query for fee report\")\n\n\trequire.EqualValues(h, day, feeReport.DayFeeSum, \"day fee mismatch\")\n\trequire.EqualValues(h, week, feeReport.WeekFeeSum, \"day week mismatch\")\n\trequire.EqualValues(h, month, feeReport.MonthFeeSum,\n\t\t\"day month mismatch\")\n}\n\n// AssertHtlcEvents consumes events from a client and ensures that they are of\n// the expected type and contain the expected number of forwards, forward\n// failures and settles.\n//\n// TODO(yy): needs refactor to reduce its complexity.",
      "length": 678,
      "tokens": 82,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertHtlcEvents(client rpc.HtlcEventsClient,",
      "content": "func (h *HarnessTest) AssertHtlcEvents(client rpc.HtlcEventsClient,\n\tfwdCount, fwdFailCount, settleCount int,\n\tuserType routerrpc.HtlcEvent_EventType) []*routerrpc.HtlcEvent {\n\n\tvar forwards, forwardFails, settles int\n\n\tnumEvents := fwdCount + fwdFailCount + settleCount\n\tevents := make([]*routerrpc.HtlcEvent, 0)\n\n\t// It's either the userType or the unknown type.\n\t//\n\t// TODO(yy): maybe the FinalHtlcEvent shouldn't be in UNKNOWN type?\n\teventTypes := []routerrpc.HtlcEvent_EventType{\n\t\tuserType, routerrpc.HtlcEvent_UNKNOWN,\n\t}\n\n\tfor i := 0; i < numEvents; i++ {\n\t\tevent := h.ReceiveHtlcEvent(client)\n\n\t\trequire.Containsf(h, eventTypes, event.EventType,\n\t\t\t\"wrong event type, got %v\", userType, event.EventType)\n\n\t\tevents = append(events, event)\n\n\t\tswitch e := event.Event.(type) {\n\t\tcase *routerrpc.HtlcEvent_ForwardEvent:\n\t\t\tforwards++\n\n\t\tcase *routerrpc.HtlcEvent_ForwardFailEvent:\n\t\t\tforwardFails++\n\n\t\tcase *routerrpc.HtlcEvent_SettleEvent:\n\t\t\tsettles++\n\n\t\tcase *routerrpc.HtlcEvent_FinalHtlcEvent:\n\t\t\tif e.FinalHtlcEvent.Settled {\n\t\t\t\tsettles++\n\t\t\t}\n\n\t\tdefault:\n\t\t\trequire.Fail(h, \"assert event fail\",\n\t\t\t\t\"unexpected event: %T\", event.Event)\n\t\t}\n\t}\n\n\trequire.Equal(h, fwdCount, forwards, \"num of forwards mismatch\")\n\trequire.Equal(h, fwdFailCount, forwardFails,\n\t\t\"num of forward fails mismatch\")\n\trequire.Equal(h, settleCount, settles, \"num of settles mismatch\")\n\n\treturn events\n}\n\n// AssertTransactionInWallet asserts a given txid can be found in the node's\n// wallet.",
      "length": 1357,
      "tokens": 147,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertTransactionInWallet(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertTransactionInWallet(hn *node.HarnessNode,\n\ttxid chainhash.Hash) {\n\n\treq := &lnrpc.GetTransactionsRequest{}\n\terr := wait.NoError(func() error {\n\t\ttxResp := hn.RPC.GetTransactions(req)\n\t\tfor _, txn := range txResp.Transactions {\n\t\t\tif txn.TxHash == txid.String() {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\n\t\treturn fmt.Errorf(\"%s: expected txid=%v not found in wallet\",\n\t\t\thn.Name(), txid)\n\t}, DefaultTimeout)\n\n\trequire.NoError(h, err, \"failed to find tx\")\n}\n\n// AssertTransactionNotInWallet asserts a given txid can NOT be found in the\n// node's wallet.",
      "length": 475,
      "tokens": 64,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertTransactionNotInWallet(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertTransactionNotInWallet(hn *node.HarnessNode,\n\ttxid chainhash.Hash) {\n\n\treq := &lnrpc.GetTransactionsRequest{}\n\terr := wait.NoError(func() error {\n\t\ttxResp := hn.RPC.GetTransactions(req)\n\t\tfor _, txn := range txResp.Transactions {\n\t\t\tif txn.TxHash == txid.String() {\n\t\t\t\treturn fmt.Errorf(\"expected txid=%v to be \"+\n\t\t\t\t\t\"not found\", txid)\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}, DefaultTimeout)\n\n\trequire.NoErrorf(h, err, \"%s: failed to assert tx not found\", hn.Name())\n}\n\n// WaitForNodeBlockHeight queries the node for its current block height until\n// it reaches the passed height.",
      "length": 506,
      "tokens": 69,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) WaitForNodeBlockHeight(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) WaitForNodeBlockHeight(hn *node.HarnessNode,\n\theight int32) {\n\n\terr := wait.NoError(func() error {\n\t\tinfo := hn.RPC.GetInfo()\n\t\tif int32(info.BlockHeight) != height {\n\t\t\treturn fmt.Errorf(\"expected block height to \"+\n\t\t\t\t\"be %v, was %v\", height, info.BlockHeight)\n\t\t}\n\n\t\treturn nil\n\t}, DefaultTimeout)\n\n\trequire.NoErrorf(h, err, \"%s: timeout while waiting for height\",\n\t\thn.Name())\n}\n\n// AssertChannelCommitHeight asserts the given channel for the node has the\n// expected commit height(`NumUpdates`).",
      "length": 439,
      "tokens": 58,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertChannelCommitHeight(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertChannelCommitHeight(hn *node.HarnessNode,\n\tcp *lnrpc.ChannelPoint, height int) {\n\n\terr := wait.NoError(func() error {\n\t\tc, err := h.findChannel(hn, cp)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif int(c.NumUpdates) == height {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn fmt.Errorf(\"expected commit height to be %v, was %v\",\n\t\t\theight, c.NumUpdates)\n\t}, DefaultTimeout)\n\n\trequire.NoError(h, err, \"timeout while waiting for commit height\")\n}\n\n// AssertNumInvoices asserts that the number of invoices made within the test\n// scope is as expected.",
      "length": 463,
      "tokens": 70,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertNumInvoices(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertNumInvoices(hn *node.HarnessNode,\n\tnum int) []*lnrpc.Invoice {\n\n\thave := hn.State.Invoice.Total\n\treq := &lnrpc.ListInvoiceRequest{\n\t\tNumMaxInvoices: math.MaxUint64,\n\t\tIndexOffset:    hn.State.Invoice.LastIndexOffset,\n\t}\n\n\tvar invoices []*lnrpc.Invoice\n\terr := wait.NoError(func() error {\n\t\tresp := hn.RPC.ListInvoices(req)\n\n\t\tinvoices = resp.Invoices\n\t\tif len(invoices) == num {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn errNumNotMatched(hn.Name(), \"num of invoices\",\n\t\t\tnum, len(invoices), have+len(invoices), have)\n\t}, DefaultTimeout)\n\trequire.NoError(h, err, \"timeout checking num of invoices\")\n\n\treturn invoices\n}\n\n// ReceiveSendToRouteUpdate waits until a message is received on the\n// SendToRoute client stream or the timeout is reached.",
      "length": 669,
      "tokens": 77,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) ReceiveSendToRouteUpdate(",
      "content": "func (h *HarnessTest) ReceiveSendToRouteUpdate(\n\tstream rpc.SendToRouteClient) (*lnrpc.SendResponse, error) {\n\n\tchanMsg := make(chan *lnrpc.SendResponse, 1)\n\terrChan := make(chan error, 1)\n\tgo func() {\n\t\t// Consume one message. This will block until the message is\n\t\t// received.\n\t\tresp, err := stream.Recv()\n\t\tif err != nil {\n\t\t\terrChan <- err\n\n\t\t\treturn\n\t\t}\n\t\tchanMsg <- resp\n\t}()\n\n\tselect {\n\tcase <-time.After(DefaultTimeout):\n\t\trequire.Fail(h, \"timeout\", \"timeout waiting for send resp\")\n\t\treturn nil, nil\n\n\tcase err := <-errChan:\n\t\treturn nil, err\n\n\tcase updateMsg := <-chanMsg:\n\t\treturn updateMsg, nil\n\t}\n}\n\n// AssertInvoiceEqual asserts that two lnrpc.Invoices are equivalent. A custom\n// comparison function is defined for these tests, since proto message returned\n// from unary and streaming RPCs (as of protobuf 1.23.0 and grpc 1.29.1) aren't\n// consistent with the private fields set on the messages. As a result, we\n// avoid using require.Equal and test only the actual data members.",
      "length": 914,
      "tokens": 140,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertInvoiceEqual(a, b *lnrpc.Invoice) {",
      "content": "func (h *HarnessTest) AssertInvoiceEqual(a, b *lnrpc.Invoice) {\n\t// Ensure the HTLCs are sorted properly before attempting to compare.\n\tsort.Slice(a.Htlcs, func(i, j int) bool {\n\t\treturn a.Htlcs[i].ChanId < a.Htlcs[j].ChanId\n\t})\n\tsort.Slice(b.Htlcs, func(i, j int) bool {\n\t\treturn b.Htlcs[i].ChanId < b.Htlcs[j].ChanId\n\t})\n\n\trequire.Equal(h, a.Memo, b.Memo)\n\trequire.Equal(h, a.RPreimage, b.RPreimage)\n\trequire.Equal(h, a.RHash, b.RHash)\n\trequire.Equal(h, a.Value, b.Value)\n\trequire.Equal(h, a.ValueMsat, b.ValueMsat)\n\trequire.Equal(h, a.CreationDate, b.CreationDate)\n\trequire.Equal(h, a.SettleDate, b.SettleDate)\n\trequire.Equal(h, a.PaymentRequest, b.PaymentRequest)\n\trequire.Equal(h, a.DescriptionHash, b.DescriptionHash)\n\trequire.Equal(h, a.Expiry, b.Expiry)\n\trequire.Equal(h, a.FallbackAddr, b.FallbackAddr)\n\trequire.Equal(h, a.CltvExpiry, b.CltvExpiry)\n\trequire.Equal(h, a.RouteHints, b.RouteHints)\n\trequire.Equal(h, a.Private, b.Private)\n\trequire.Equal(h, a.AddIndex, b.AddIndex)\n\trequire.Equal(h, a.SettleIndex, b.SettleIndex)\n\trequire.Equal(h, a.AmtPaidSat, b.AmtPaidSat)\n\trequire.Equal(h, a.AmtPaidMsat, b.AmtPaidMsat)\n\trequire.Equal(h, a.State, b.State)\n\trequire.Equal(h, a.Features, b.Features)\n\trequire.Equal(h, a.IsKeysend, b.IsKeysend)\n\trequire.Equal(h, a.PaymentAddr, b.PaymentAddr)\n\trequire.Equal(h, a.IsAmp, b.IsAmp)\n\n\trequire.Equal(h, len(a.Htlcs), len(b.Htlcs))\n\tfor i := range a.Htlcs {\n\t\thtlcA, htlcB := a.Htlcs[i], b.Htlcs[i]\n\t\trequire.Equal(h, htlcA.ChanId, htlcB.ChanId)\n\t\trequire.Equal(h, htlcA.HtlcIndex, htlcB.HtlcIndex)\n\t\trequire.Equal(h, htlcA.AmtMsat, htlcB.AmtMsat)\n\t\trequire.Equal(h, htlcA.AcceptHeight, htlcB.AcceptHeight)\n\t\trequire.Equal(h, htlcA.AcceptTime, htlcB.AcceptTime)\n\t\trequire.Equal(h, htlcA.ResolveTime, htlcB.ResolveTime)\n\t\trequire.Equal(h, htlcA.ExpiryHeight, htlcB.ExpiryHeight)\n\t\trequire.Equal(h, htlcA.State, htlcB.State)\n\t\trequire.Equal(h, htlcA.CustomRecords, htlcB.CustomRecords)\n\t\trequire.Equal(h, htlcA.MppTotalAmtMsat, htlcB.MppTotalAmtMsat)\n\t\trequire.Equal(h, htlcA.Amp, htlcB.Amp)\n\t}\n}\n\n// AssertUTXOInWallet asserts that a given UTXO can be found in the node's\n// wallet.",
      "length": 2016,
      "tokens": 166,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertUTXOInWallet(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertUTXOInWallet(hn *node.HarnessNode,\n\top *lnrpc.OutPoint, account string) {\n\n\terr := wait.NoError(func() error {\n\t\tutxos := h.GetUTXOs(hn, account)\n\n\t\terr := fmt.Errorf(\"tx with hash %x not found\", op.TxidBytes)\n\t\tfor _, utxo := range utxos {\n\t\t\tif !bytes.Equal(utxo.Outpoint.TxidBytes, op.TxidBytes) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\terr = fmt.Errorf(\"tx with output index %v not found\",\n\t\t\t\top.OutputIndex)\n\t\t\tif utxo.Outpoint.OutputIndex != op.OutputIndex {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\treturn nil\n\t\t}\n\n\t\treturn err\n\t}, DefaultTimeout)\n\n\trequire.NoErrorf(h, err, \"outpoint %v not found in %s's wallet\",\n\t\top, hn.Name())\n}\n\n// AssertWalletAccountBalance asserts that the unconfirmed and confirmed\n// balance for the given account is satisfied by the WalletBalance and\n// ListUnspent RPCs. The unconfirmed balance is not checked for neutrino nodes.",
      "length": 766,
      "tokens": 104,
      "embedding": []
    },
    {
      "slug": "func (h *HarnessTest) AssertWalletAccountBalance(hn *node.HarnessNode,",
      "content": "func (h *HarnessTest) AssertWalletAccountBalance(hn *node.HarnessNode,\n\taccount string, confirmedBalance, unconfirmedBalance int64) {\n\n\terr := wait.NoError(func() error {\n\t\tbalanceResp := hn.RPC.WalletBalance()\n\t\trequire.Contains(h, balanceResp.AccountBalance, account)\n\t\taccountBalance := balanceResp.AccountBalance[account]\n\n\t\t// Check confirmed balance.\n\t\tif accountBalance.ConfirmedBalance != confirmedBalance {\n\t\t\treturn fmt.Errorf(\"expected confirmed balance %v, \"+\n\t\t\t\t\"got %v\", confirmedBalance,\n\t\t\t\taccountBalance.ConfirmedBalance)\n\t\t}\n\n\t\tutxos := h.GetUTXOsConfirmed(hn, account)\n\t\tvar totalConfirmedVal int64\n\t\tfor _, utxo := range utxos {\n\t\t\ttotalConfirmedVal += utxo.AmountSat\n\t\t}\n\t\tif totalConfirmedVal != confirmedBalance {\n\t\t\treturn fmt.Errorf(\"expected total confirmed utxo \"+\n\t\t\t\t\"balance %v, got %v\", confirmedBalance,\n\t\t\t\ttotalConfirmedVal)\n\t\t}\n\n\t\t// Skip unconfirmed balance checks for neutrino nodes.\n\t\tif h.IsNeutrinoBackend() {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Check unconfirmed balance.\n\t\tif accountBalance.UnconfirmedBalance != unconfirmedBalance {\n\t\t\treturn fmt.Errorf(\"expected unconfirmed balance %v, \"+\n\t\t\t\t\"got %v\", unconfirmedBalance,\n\t\t\t\taccountBalance.UnconfirmedBalance)\n\t\t}\n\n\t\tutxos = h.GetUTXOsUnconfirmed(hn, account)\n\t\tvar totalUnconfirmedVal int64\n\t\tfor _, utxo := range utxos {\n\t\t\ttotalUnconfirmedVal += utxo.AmountSat\n\t\t}\n\t\tif totalUnconfirmedVal != unconfirmedBalance {\n\t\t\treturn fmt.Errorf(\"expected total unconfirmed utxo \"+\n\t\t\t\t\"balance %v, got %v\", unconfirmedBalance,\n\t\t\t\ttotalUnconfirmedVal)\n\t\t}\n\n\t\treturn nil\n\t}, DefaultTimeout)\n\trequire.NoError(h, err, \"timeout checking wallet account balance\")\n}\n",
      "length": 1517,
      "tokens": 158,
      "embedding": []
    }
  ]
}