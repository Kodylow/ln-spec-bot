{
  "filepath": "../implementations/go/lnd/blockcache/blockcache.go",
  "package": "blockcache",
  "sections": [
    {
      "slug": "type BlockCache struct {",
      "content": "type BlockCache struct {\n\tCache     *lru.Cache[wire.InvVect, *neutrino.CacheableBlock]\n\tHashMutex *multimutex.HashMutex\n}\n\n// NewBlockCache creates a new BlockCache with the given maximum capacity.",
      "length": 168,
      "tokens": 17,
      "embedding": []
    },
    {
      "slug": "func NewBlockCache(capacity uint64) *BlockCache {",
      "content": "func NewBlockCache(capacity uint64) *BlockCache {\n\treturn &BlockCache{\n\t\tCache: lru.NewCache[wire.InvVect, *neutrino.CacheableBlock](\n\t\t\tcapacity,\n\t\t),\n\t\tHashMutex: multimutex.NewHashMutex(),\n\t}\n}\n\n// GetBlock first checks to see if the BlockCache already contains the block\n// with the given hash. If it does then the block is fetched from the cache and\n// returned. Otherwise the getBlockImpl function is used in order to fetch the\n// new block and then it is stored in the block cache and returned.",
      "length": 440,
      "tokens": 68,
      "embedding": []
    },
    {
      "slug": "func (bc *BlockCache) GetBlock(hash *chainhash.Hash,",
      "content": "func (bc *BlockCache) GetBlock(hash *chainhash.Hash,\n\tgetBlockImpl func(hash *chainhash.Hash) (*wire.MsgBlock,\n\t\terror)) (*wire.MsgBlock, error) {\n\n\tbc.HashMutex.Lock(lntypes.Hash(*hash))\n\tdefer bc.HashMutex.Unlock(lntypes.Hash(*hash))\n\n\t// Create an inv vector for getting the block.\n\tinv := wire.NewInvVect(wire.InvTypeWitnessBlock, hash)\n\n\t// Check if the block corresponding to the given hash is already\n\t// stored in the blockCache and return it if it is.\n\tcacheBlock, err := bc.Cache.Get(*inv)\n\tif err != nil && err != cache.ErrElementNotFound {\n\t\treturn nil, err\n\t}\n\tif cacheBlock != nil {\n\t\treturn cacheBlock.MsgBlock(), nil\n\t}\n\n\t// Fetch the block from the chain backends.\n\tblock, err := getBlockImpl(hash)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Add the new block to blockCache. If the Cache is at its maximum\n\t// capacity then the LFU item will be evicted in favour of this new\n\t// block.\n\t_, err = bc.Cache.Put(\n\t\t*inv, &neutrino.CacheableBlock{\n\t\t\tBlock: btcutil.NewBlock(block),\n\t\t},\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn block, nil\n}\n",
      "length": 972,
      "tokens": 147,
      "embedding": []
    }
  ]
}