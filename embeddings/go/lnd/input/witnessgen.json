{
  "filepath": "../implementations/go/lnd/input/witnessgen.go",
  "package": "input",
  "sections": [
    {
      "slug": "type WitnessGenerator func(tx *wire.MsgTx, hc *txscript.TxSigHashes,",
      "content": "type WitnessGenerator func(tx *wire.MsgTx, hc *txscript.TxSigHashes,\n\tinputIndex int) (*Script, error)\n\n// WitnessType determines how an output's witness will be generated. This\n// interface can be implemented to be used for custom sweep scripts if the\n// pre-defined StandardWitnessType list doesn't provide a suitable one.",
      "length": 251,
      "tokens": 38,
      "embedding": []
    },
    {
      "slug": "type WitnessType interface {",
      "content": "type WitnessType interface {\n\t// String returns a human readable version of the WitnessType.\n\tString() string\n\n\t// WitnessGenerator will return a WitnessGenerator function that an\n\t// output uses to generate the witness and optionally the sigScript for\n\t// a sweep transaction.\n\tWitnessGenerator(signer Signer,\n\t\tdescriptor *SignDescriptor) WitnessGenerator\n\n\t// SizeUpperBound returns the maximum length of the witness of this\n\t// WitnessType if it would be included in a tx. It also returns if the\n\t// output itself is a nested p2sh output, if so then we need to take\n\t// into account the extra sigScript data size.\n\tSizeUpperBound() (int, bool, error)\n\n\t// AddWeightEstimation adds the estimated size of the witness in bytes\n\t// to the given weight estimator.\n\tAddWeightEstimation(e *TxWeightEstimator) error\n}\n\n// StandardWitnessType is a numeric representation of standard pre-defined types\n// of witness configurations.",
      "length": 875,
      "tokens": 130,
      "embedding": []
    },
    {
      "slug": "type StandardWitnessType uint16",
      "content": "type StandardWitnessType uint16\n\n// A compile time check to ensure StandardWitnessType implements the\n// WitnessType interface.\nvar _ WitnessType = (StandardWitnessType)(0)\n\nconst (\n\t// CommitmentTimeLock is a witness that allows us to spend our output\n\t// on our local commitment transaction after a relative lock-time\n\t// lockout.\n\tCommitmentTimeLock StandardWitnessType = 0\n\n\t// CommitmentNoDelay is a witness that allows us to spend a settled\n\t// no-delay output immediately on a counterparty's commitment\n\t// transaction.\n\tCommitmentNoDelay StandardWitnessType = 1\n\n\t// CommitmentRevoke is a witness that allows us to sweep the settled\n\t// output of a malicious counterparty's who broadcasts a revoked\n\t// commitment transaction.\n\tCommitmentRevoke StandardWitnessType = 2\n\n\t// HtlcOfferedRevoke is a witness that allows us to sweep an HTLC which\n\t// we offered to the remote party in the case that they broadcast a\n\t// revoked commitment state.\n\tHtlcOfferedRevoke StandardWitnessType = 3\n\n\t// HtlcAcceptedRevoke is a witness that allows us to sweep an HTLC\n\t// output sent to us in the case that the remote party broadcasts a\n\t// revoked commitment state.\n\tHtlcAcceptedRevoke StandardWitnessType = 4\n\n\t// HtlcOfferedTimeoutSecondLevel is a witness that allows us to sweep\n\t// an HTLC output that we extended to a party, but was never fulfilled.\n\t// This HTLC output isn't directly on the commitment transaction, but\n\t// is the result of a confirmed second-level HTLC transaction. As a\n\t// result, we can only spend this after a CSV delay.\n\tHtlcOfferedTimeoutSecondLevel StandardWitnessType = 5\n\n\t// HtlcOfferedTimeoutSecondLevelInputConfirmed is a witness that allows\n\t// us to sweep an HTLC output that we extended to a party, but was\n\t// never fulfilled. This _is_ the HTLC output directly on our\n\t// commitment transaction, and the input to the second-level HTLC\n\t// timeout transaction. It can only be spent after CLTV expiry, and\n\t// commitment confirmation.\n\tHtlcOfferedTimeoutSecondLevelInputConfirmed StandardWitnessType = 15\n\n\t// HtlcAcceptedSuccessSecondLevel is a witness that allows us to sweep\n\t// an HTLC output that was offered to us, and for which we have a\n\t// payment preimage. This HTLC output isn't directly on our commitment\n\t// transaction, but is the result of confirmed second-level HTLC\n\t// transaction. As a result, we can only spend this after a CSV delay.\n\tHtlcAcceptedSuccessSecondLevel StandardWitnessType = 6\n\n\t// HtlcAcceptedSuccessSecondLevelInputConfirmed is a witness that\n\t// allows us to sweep an HTLC output that was offered to us, and for\n\t// which we have a payment preimage. This _is_ the HTLC output directly\n\t// on our commitment transaction, and the input to the second-level\n\t// HTLC success transaction.  It can only be spent after the commitment\n\t// has confirmed.\n\tHtlcAcceptedSuccessSecondLevelInputConfirmed StandardWitnessType = 16\n\n\t// HtlcOfferedRemoteTimeout is a witness that allows us to sweep an\n\t// HTLC that we offered to the remote party which lies in the\n\t// commitment transaction of the remote party. We can spend this output\n\t// after the absolute CLTV timeout of the HTLC as passed.\n\tHtlcOfferedRemoteTimeout StandardWitnessType = 7\n\n\t// HtlcAcceptedRemoteSuccess is a witness that allows us to sweep an\n\t// HTLC that was offered to us by the remote party. We use this witness\n\t// in the case that the remote party goes to chain, and we know the\n\t// pre-image to the HTLC. We can sweep this without any additional\n\t// timeout.\n\tHtlcAcceptedRemoteSuccess StandardWitnessType = 8\n\n\t// HtlcSecondLevelRevoke is a witness that allows us to sweep an HTLC\n\t// from the remote party's commitment transaction in the case that the\n\t// broadcast a revoked commitment, but then also immediately attempt to\n\t// go to the second level to claim the HTLC.\n\tHtlcSecondLevelRevoke StandardWitnessType = 9\n\n\t// WitnessKeyHash is a witness type that allows us to spend a regular\n\t// p2wkh output that's sent to an output which is under complete\n\t// control of the backing wallet.\n\tWitnessKeyHash StandardWitnessType = 10\n\n\t// NestedWitnessKeyHash is a witness type that allows us to sweep an\n\t// output that sends to a nested P2SH script that pays to a key solely\n\t// under our control. The witness generated needs to include the\n\tNestedWitnessKeyHash StandardWitnessType = 11\n\n\t// CommitSpendNoDelayTweakless is similar to the CommitSpendNoDelay\n\t// type, but it omits the tweak that randomizes the key we need to\n\t// spend with a channel peer supplied set of randomness.\n\tCommitSpendNoDelayTweakless StandardWitnessType = 12\n\n\t// CommitmentToRemoteConfirmed is a witness that allows us to spend our\n\t// output on the counterparty's commitment transaction after a\n\t// confirmation.\n\tCommitmentToRemoteConfirmed StandardWitnessType = 13\n\n\t// CommitmentAnchor is a witness that allows us to spend our anchor on\n\t// the commitment transaction.\n\tCommitmentAnchor StandardWitnessType = 14\n\n\t// LeaseCommitmentTimeLock is a witness that allows us to spend our\n\t// output on our local commitment transaction after a relative and\n\t// absolute lock-time lockout as part of the script enforced lease\n\t// commitment type.\n\tLeaseCommitmentTimeLock StandardWitnessType = 17\n\n\t// LeaseCommitmentToRemoteConfirmed is a witness that allows us to spend\n\t// our output on the counterparty's commitment transaction after a\n\t// confirmation and absolute locktime as part of the script enforced\n\t// lease commitment type.\n\tLeaseCommitmentToRemoteConfirmed StandardWitnessType = 18\n\n\t// LeaseHtlcOfferedTimeoutSecondLevel is a witness that allows us to\n\t// sweep an HTLC output that we extended to a party, but was never\n\t// fulfilled. This HTLC output isn't directly on the commitment\n\t// transaction, but is the result of a confirmed second-level HTLC\n\t// transaction. As a result, we can only spend this after a CSV delay\n\t// and CLTV locktime as part of the script enforced lease commitment\n\t// type.\n\tLeaseHtlcOfferedTimeoutSecondLevel StandardWitnessType = 19\n\n\t// LeaseHtlcAcceptedSuccessSecondLevel is a witness that allows us to\n\t// sweep an HTLC output that was offered to us, and for which we have a\n\t// payment preimage. This HTLC output isn't directly on our commitment\n\t// transaction, but is the result of confirmed second-level HTLC\n\t// transaction. As a result, we can only spend this after a CSV delay\n\t// and CLTV locktime as part of the script enforced lease commitment\n\t// type.\n\tLeaseHtlcAcceptedSuccessSecondLevel StandardWitnessType = 20\n\n\t// TaprootPubKeySpend is a witness type that allows us to spend a\n\t// regular p2tr output that's sent to an output which is under complete\n\t// control of the backing wallet.\n\tTaprootPubKeySpend StandardWitnessType = 21\n)\n\n// String returns a human readable version of the target WitnessType.\n//\n// NOTE: This is part of the WitnessType interface.",
      "length": 6666,
      "tokens": 1032,
      "embedding": []
    },
    {
      "slug": "func (wt StandardWitnessType) String() string {",
      "content": "func (wt StandardWitnessType) String() string {\n\tswitch wt {\n\tcase CommitmentTimeLock:\n\t\treturn \"CommitmentTimeLock\"\n\n\tcase CommitmentToRemoteConfirmed:\n\t\treturn \"CommitmentToRemoteConfirmed\"\n\n\tcase CommitmentAnchor:\n\t\treturn \"CommitmentAnchor\"\n\n\tcase CommitmentNoDelay:\n\t\treturn \"CommitmentNoDelay\"\n\n\tcase CommitSpendNoDelayTweakless:\n\t\treturn \"CommitmentNoDelayTweakless\"\n\n\tcase CommitmentRevoke:\n\t\treturn \"CommitmentRevoke\"\n\n\tcase HtlcOfferedRevoke:\n\t\treturn \"HtlcOfferedRevoke\"\n\n\tcase HtlcAcceptedRevoke:\n\t\treturn \"HtlcAcceptedRevoke\"\n\n\tcase HtlcOfferedTimeoutSecondLevel:\n\t\treturn \"HtlcOfferedTimeoutSecondLevel\"\n\n\tcase HtlcOfferedTimeoutSecondLevelInputConfirmed:\n\t\treturn \"HtlcOfferedTimeoutSecondLevelInputConfirmed\"\n\n\tcase HtlcAcceptedSuccessSecondLevel:\n\t\treturn \"HtlcAcceptedSuccessSecondLevel\"\n\n\tcase HtlcAcceptedSuccessSecondLevelInputConfirmed:\n\t\treturn \"HtlcAcceptedSuccessSecondLevelInputConfirmed\"\n\n\tcase HtlcOfferedRemoteTimeout:\n\t\treturn \"HtlcOfferedRemoteTimeout\"\n\n\tcase HtlcAcceptedRemoteSuccess:\n\t\treturn \"HtlcAcceptedRemoteSuccess\"\n\n\tcase HtlcSecondLevelRevoke:\n\t\treturn \"HtlcSecondLevelRevoke\"\n\n\tcase WitnessKeyHash:\n\t\treturn \"WitnessKeyHash\"\n\n\tcase NestedWitnessKeyHash:\n\t\treturn \"NestedWitnessKeyHash\"\n\n\tcase LeaseCommitmentTimeLock:\n\t\treturn \"LeaseCommitmentTimeLock\"\n\n\tcase LeaseCommitmentToRemoteConfirmed:\n\t\treturn \"LeaseCommitmentToRemoteConfirmed\"\n\n\tcase LeaseHtlcOfferedTimeoutSecondLevel:\n\t\treturn \"LeaseHtlcOfferedTimeoutSecondLevel\"\n\n\tcase LeaseHtlcAcceptedSuccessSecondLevel:\n\t\treturn \"LeaseHtlcAcceptedSuccessSecondLevel\"\n\n\tcase TaprootPubKeySpend:\n\t\treturn \"TaprootPubKeySpend\"\n\n\tdefault:\n\t\treturn fmt.Sprintf(\"Unknown WitnessType: %v\", uint32(wt))\n\t}\n}\n\n// WitnessGenerator will return a WitnessGenerator function that an output uses\n// to generate the witness and optionally the sigScript for a sweep\n// transaction. The sigScript will be generated if the witness type warrants\n// one for spending, such as the NestedWitnessKeyHash witness type.\n//\n// NOTE: This is part of the WitnessType interface.",
      "length": 1916,
      "tokens": 154,
      "embedding": []
    },
    {
      "slug": "func (wt StandardWitnessType) WitnessGenerator(signer Signer,",
      "content": "func (wt StandardWitnessType) WitnessGenerator(signer Signer,\n\tdescriptor *SignDescriptor) WitnessGenerator {\n\n\treturn func(tx *wire.MsgTx, hc *txscript.TxSigHashes,\n\t\tinputIndex int) (*Script, error) {\n\n\t\tdesc := descriptor\n\t\tdesc.SigHashes = hc\n\t\tdesc.InputIndex = inputIndex\n\n\t\tswitch wt {\n\t\tcase CommitmentTimeLock, LeaseCommitmentTimeLock:\n\t\t\twitness, err := CommitSpendTimeout(signer, desc, tx)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn &Script{\n\t\t\t\tWitness: witness,\n\t\t\t}, nil\n\n\t\tcase CommitmentToRemoteConfirmed, LeaseCommitmentToRemoteConfirmed:\n\t\t\twitness, err := CommitSpendToRemoteConfirmed(\n\t\t\t\tsigner, desc, tx,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn &Script{\n\t\t\t\tWitness: witness,\n\t\t\t}, nil\n\n\t\tcase CommitmentAnchor:\n\t\t\twitness, err := CommitSpendAnchor(signer, desc, tx)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn &Script{\n\t\t\t\tWitness: witness,\n\t\t\t}, nil\n\n\t\tcase CommitmentNoDelay:\n\t\t\twitness, err := CommitSpendNoDelay(signer, desc, tx, false)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn &Script{\n\t\t\t\tWitness: witness,\n\t\t\t}, nil\n\n\t\tcase CommitSpendNoDelayTweakless:\n\t\t\twitness, err := CommitSpendNoDelay(signer, desc, tx, true)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn &Script{\n\t\t\t\tWitness: witness,\n\t\t\t}, nil\n\n\t\tcase CommitmentRevoke:\n\t\t\twitness, err := CommitSpendRevoke(signer, desc, tx)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn &Script{\n\t\t\t\tWitness: witness,\n\t\t\t}, nil\n\n\t\tcase HtlcOfferedRevoke:\n\t\t\twitness, err := ReceiverHtlcSpendRevoke(signer, desc, tx)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn &Script{\n\t\t\t\tWitness: witness,\n\t\t\t}, nil\n\n\t\tcase HtlcAcceptedRevoke:\n\t\t\twitness, err := SenderHtlcSpendRevoke(signer, desc, tx)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn &Script{\n\t\t\t\tWitness: witness,\n\t\t\t}, nil\n\n\t\tcase HtlcOfferedTimeoutSecondLevel,\n\t\t\tLeaseHtlcOfferedTimeoutSecondLevel,\n\t\t\tHtlcAcceptedSuccessSecondLevel,\n\t\t\tLeaseHtlcAcceptedSuccessSecondLevel:\n\n\t\t\twitness, err := HtlcSecondLevelSpend(signer, desc, tx)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn &Script{\n\t\t\t\tWitness: witness,\n\t\t\t}, nil\n\n\t\tcase HtlcOfferedRemoteTimeout:\n\t\t\t// We pass in a value of -1 for the timeout, as we\n\t\t\t// expect the caller to have already set the lock time\n\t\t\t// value.\n\t\t\twitness, err := ReceiverHtlcSpendTimeout(signer, desc, tx, -1)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn &Script{\n\t\t\t\tWitness: witness,\n\t\t\t}, nil\n\n\t\tcase HtlcSecondLevelRevoke:\n\t\t\twitness, err := HtlcSpendRevoke(signer, desc, tx)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn &Script{\n\t\t\t\tWitness: witness,\n\t\t\t}, nil\n\n\t\tcase WitnessKeyHash:\n\t\t\tfallthrough\n\t\tcase TaprootPubKeySpend:\n\t\t\tfallthrough\n\t\tcase NestedWitnessKeyHash:\n\t\t\treturn signer.ComputeInputScript(tx, desc)\n\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"unknown witness type: %v\", wt)\n\t\t}\n\t}\n}\n\n// SizeUpperBound returns the maximum length of the witness of this witness\n// type if it would be included in a tx. We also return if the output itself is\n// a nested p2sh output, if so then we need to take into account the extra\n// sigScript data size.\n//\n// NOTE: This is part of the WitnessType interface.",
      "length": 2987,
      "tokens": 397,
      "embedding": []
    },
    {
      "slug": "func (wt StandardWitnessType) SizeUpperBound() (int, bool, error) {",
      "content": "func (wt StandardWitnessType) SizeUpperBound() (int, bool, error) {\n\tswitch wt {\n\t// Outputs on a remote commitment transaction that pay directly to us.\n\tcase CommitSpendNoDelayTweakless:\n\t\tfallthrough\n\tcase WitnessKeyHash:\n\t\tfallthrough\n\tcase CommitmentNoDelay:\n\t\treturn P2WKHWitnessSize, false, nil\n\n\t// Outputs on a past commitment transaction that pay directly\n\t// to us.\n\tcase CommitmentTimeLock:\n\t\treturn ToLocalTimeoutWitnessSize, false, nil\n\tcase LeaseCommitmentTimeLock:\n\t\tsize := ToLocalTimeoutWitnessSize +\n\t\t\tLeaseWitnessScriptSizeOverhead\n\t\treturn size, false, nil\n\n\t// 1 CSV time locked output to us on remote commitment.\n\tcase CommitmentToRemoteConfirmed:\n\t\treturn ToRemoteConfirmedWitnessSize, false, nil\n\tcase LeaseCommitmentToRemoteConfirmed:\n\t\tsize := ToRemoteConfirmedWitnessSize +\n\t\t\tLeaseWitnessScriptSizeOverhead\n\t\treturn size, false, nil\n\n\t// Anchor output on the commitment transaction.\n\tcase CommitmentAnchor:\n\t\treturn AnchorWitnessSize, false, nil\n\n\t// Outgoing second layer HTLC's that have confirmed within the\n\t// chain, and the output they produced is now mature enough to\n\t// sweep.\n\tcase HtlcOfferedTimeoutSecondLevel:\n\t\treturn ToLocalTimeoutWitnessSize, false, nil\n\tcase LeaseHtlcOfferedTimeoutSecondLevel:\n\t\tsize := ToLocalTimeoutWitnessSize +\n\t\t\tLeaseWitnessScriptSizeOverhead\n\t\treturn size, false, nil\n\n\t// Input to the outgoing HTLC second layer timeout transaction.\n\tcase HtlcOfferedTimeoutSecondLevelInputConfirmed:\n\t\treturn OfferedHtlcTimeoutWitnessSizeConfirmed, false, nil\n\n\t// Incoming second layer HTLC's that have confirmed within the\n\t// chain, and the output they produced is now mature enough to\n\t// sweep.\n\tcase HtlcAcceptedSuccessSecondLevel:\n\t\treturn ToLocalTimeoutWitnessSize, false, nil\n\tcase LeaseHtlcAcceptedSuccessSecondLevel:\n\t\tsize := ToLocalTimeoutWitnessSize +\n\t\t\tLeaseWitnessScriptSizeOverhead\n\t\treturn size, false, nil\n\n\t// Input to the incoming second-layer HTLC success transaction.\n\tcase HtlcAcceptedSuccessSecondLevelInputConfirmed:\n\t\treturn AcceptedHtlcSuccessWitnessSizeConfirmed, false, nil\n\n\t// An HTLC on the commitment transaction of the remote party,\n\t// that has had its absolute timelock expire.\n\tcase HtlcOfferedRemoteTimeout:\n\t\treturn AcceptedHtlcTimeoutWitnessSize, false, nil\n\n\t// An HTLC on the commitment transaction of the remote party,\n\t// that can be swept with the preimage.\n\tcase HtlcAcceptedRemoteSuccess:\n\t\treturn OfferedHtlcSuccessWitnessSize, false, nil\n\n\t// A nested P2SH input that has a p2wkh witness script. We'll mark this\n\t// as nested P2SH so the caller can estimate the weight properly\n\t// including the sigScript.\n\tcase NestedWitnessKeyHash:\n\t\treturn P2WKHWitnessSize, true, nil\n\n\t// The revocation output on a revoked commitment transaction.\n\tcase CommitmentRevoke:\n\t\treturn ToLocalPenaltyWitnessSize, false, nil\n\n\t// The revocation output on a revoked HTLC that we offered to the remote\n\t// party.\n\tcase HtlcOfferedRevoke:\n\t\treturn OfferedHtlcPenaltyWitnessSize, false, nil\n\n\t// The revocation output on a revoked HTLC that was sent to us.\n\tcase HtlcAcceptedRevoke:\n\t\treturn AcceptedHtlcPenaltyWitnessSize, false, nil\n\n\t// The revocation output of a second level output of an HTLC.\n\tcase HtlcSecondLevelRevoke:\n\t\treturn ToLocalPenaltyWitnessSize, false, nil\n\n\tcase TaprootPubKeySpend:\n\t\treturn TaprootKeyPathCustomSighashWitnessSize, false, nil\n\t}\n\n\treturn 0, false, fmt.Errorf(\"unexpected witness type: %v\", wt)\n}\n\n// AddWeightEstimation adds the estimated size of the witness in bytes to the\n// given weight estimator.\n//\n// NOTE: This is part of the WitnessType interface.",
      "length": 3408,
      "tokens": 414,
      "embedding": []
    },
    {
      "slug": "func (wt StandardWitnessType) AddWeightEstimation(e *TxWeightEstimator) error {",
      "content": "func (wt StandardWitnessType) AddWeightEstimation(e *TxWeightEstimator) error {\n\t// For fee estimation purposes, we'll now attempt to obtain an\n\t// upper bound on the weight this input will add when fully\n\t// populated.\n\tsize, isNestedP2SH, err := wt.SizeUpperBound()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// If this is a nested P2SH input, then we'll need to factor in\n\t// the additional data push within the sigScript.\n\tif isNestedP2SH {\n\t\te.AddNestedP2WSHInput(size)\n\t} else {\n\t\te.AddWitnessInput(size)\n\t}\n\n\treturn nil\n}\n",
      "length": 423,
      "tokens": 72,
      "embedding": []
    }
  ]
}