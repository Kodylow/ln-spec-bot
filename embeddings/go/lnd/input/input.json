{
  "filepath": "../implementations/go/lnd/input/input.go",
  "package": "input",
  "sections": [
    {
      "slug": "type Input interface {",
      "content": "type Input interface {\n\t// Outpoint returns the reference to the output being spent, used to\n\t// construct the corresponding transaction input.\n\tOutPoint() *wire.OutPoint\n\n\t// RequiredTxOut returns a non-nil TxOut if input commits to a certain\n\t// transaction output. This is used in the SINGLE|ANYONECANPAY case to\n\t// make sure any presigned input is still valid by including the\n\t// output.\n\tRequiredTxOut() *wire.TxOut\n\n\t// RequiredLockTime returns whether this input commits to a tx locktime\n\t// that must be used in the transaction including it.\n\tRequiredLockTime() (uint32, bool)\n\n\t// WitnessType returns an enum specifying the type of witness that must\n\t// be generated in order to spend this output.\n\tWitnessType() WitnessType\n\n\t// SignDesc returns a reference to a spendable output's sign\n\t// descriptor, which is used during signing to compute a valid witness\n\t// that spends this output.\n\tSignDesc() *SignDescriptor\n\n\t// CraftInputScript returns a valid set of input scripts allowing this\n\t// output to be spent. The returns input scripts should target the\n\t// input at location txIndex within the passed transaction. The input\n\t// scripts generated by this method support spending p2wkh, p2wsh, and\n\t// also nested p2sh outputs.\n\tCraftInputScript(signer Signer, txn *wire.MsgTx,\n\t\thashCache *txscript.TxSigHashes,\n\t\tprevOutputFetcher txscript.PrevOutputFetcher,\n\t\ttxinIdx int) (*Script, error)\n\n\t// BlocksToMaturity returns the relative timelock, as a number of\n\t// blocks, that must be built on top of the confirmation height before\n\t// the output can be spent. For non-CSV locked inputs this is always\n\t// zero.\n\tBlocksToMaturity() uint32\n\n\t// HeightHint returns the minimum height at which a confirmed spending\n\t// tx can occur.\n\tHeightHint() uint32\n\n\t// UnconfParent returns information about a possibly unconfirmed parent\n\t// tx.\n\tUnconfParent() *TxInfo\n}\n\n// TxInfo describes properties of a parent tx that are relevant for CPFP.",
      "length": 1877,
      "tokens": 281,
      "embedding": []
    },
    {
      "slug": "type TxInfo struct {",
      "content": "type TxInfo struct {\n\t// Fee is the fee of the tx.\n\tFee btcutil.Amount\n\n\t// Weight is the weight of the tx.\n\tWeight int64\n}\n\n// SignDetails is a struct containing information needed to resign certain\n// inputs. It is used to re-sign 2nd level HTLC transactions that uses the\n// SINGLE|ANYONECANPAY sighash type, as we have a signature provided by our\n// peer, but we can aggregate multiple of these 2nd level transactions into a\n// new transaction, that needs to be signed by us.",
      "length": 447,
      "tokens": 82,
      "embedding": []
    },
    {
      "slug": "type SignDetails struct {",
      "content": "type SignDetails struct {\n\t// SignDesc is the sign descriptor needed for us to sign the input.\n\tSignDesc SignDescriptor\n\n\t// PeerSig is the peer's signature for this input.\n\tPeerSig Signature\n\n\t// SigHashType is the sighash signed by the peer.\n\tSigHashType txscript.SigHashType\n}\n",
      "length": 245,
      "tokens": 38,
      "embedding": []
    },
    {
      "slug": "type inputKit struct {",
      "content": "type inputKit struct {\n\toutpoint        wire.OutPoint\n\twitnessType     WitnessType\n\tsignDesc        SignDescriptor\n\theightHint      uint32\n\tblockToMaturity uint32\n\tcltvExpiry      uint32\n\n\t// unconfParent contains information about a potential unconfirmed\n\t// parent transaction.\n\tunconfParent *TxInfo\n}\n\n// OutPoint returns the breached output's identifier that is to be included as\n// a transaction input.",
      "length": 371,
      "tokens": 43,
      "embedding": []
    },
    {
      "slug": "func (i *inputKit) OutPoint() *wire.OutPoint {",
      "content": "func (i *inputKit) OutPoint() *wire.OutPoint {\n\treturn &i.outpoint\n}\n\n// RequiredTxOut returns a nil for the base input type.",
      "length": 75,
      "tokens": 13,
      "embedding": []
    },
    {
      "slug": "func (i *inputKit) RequiredTxOut() *wire.TxOut {",
      "content": "func (i *inputKit) RequiredTxOut() *wire.TxOut {\n\treturn nil\n}\n\n// RequiredLockTime returns whether this input commits to a tx locktime that\n// must be used in the transaction including it. This will be false for the\n// base input type since we can re-sign for any lock time.",
      "length": 221,
      "tokens": 42,
      "embedding": []
    },
    {
      "slug": "func (i *inputKit) RequiredLockTime() (uint32, bool) {",
      "content": "func (i *inputKit) RequiredLockTime() (uint32, bool) {\n\treturn i.cltvExpiry, i.cltvExpiry > 0\n}\n\n// WitnessType returns the type of witness that must be generated to spend the\n// breached output.",
      "length": 136,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (i *inputKit) WitnessType() WitnessType {",
      "content": "func (i *inputKit) WitnessType() WitnessType {\n\treturn i.witnessType\n}\n\n// SignDesc returns the breached output's SignDescriptor, which is used during\n// signing to compute the witness.",
      "length": 134,
      "tokens": 20,
      "embedding": []
    },
    {
      "slug": "func (i *inputKit) SignDesc() *SignDescriptor {",
      "content": "func (i *inputKit) SignDesc() *SignDescriptor {\n\treturn &i.signDesc\n}\n\n// HeightHint returns the minimum height at which a confirmed spending\n// tx can occur.",
      "length": 106,
      "tokens": 18,
      "embedding": []
    },
    {
      "slug": "func (i *inputKit) HeightHint() uint32 {",
      "content": "func (i *inputKit) HeightHint() uint32 {\n\treturn i.heightHint\n}\n\n// BlocksToMaturity returns the relative timelock, as a number of blocks, that\n// must be built on top of the confirmation height before the output can be\n// spent. For non-CSV locked inputs this is always zero.",
      "length": 230,
      "tokens": 40,
      "embedding": []
    },
    {
      "slug": "func (i *inputKit) BlocksToMaturity() uint32 {",
      "content": "func (i *inputKit) BlocksToMaturity() uint32 {\n\treturn i.blockToMaturity\n}\n\n// Cpfp returns information about a possibly unconfirmed parent tx.",
      "length": 93,
      "tokens": 13,
      "embedding": []
    },
    {
      "slug": "func (i *inputKit) UnconfParent() *TxInfo {",
      "content": "func (i *inputKit) UnconfParent() *TxInfo {\n\treturn i.unconfParent\n}\n\n// BaseInput contains all the information needed to sweep a basic output\n// (CSV/CLTV/no time lock)",
      "length": 121,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "type BaseInput struct {",
      "content": "type BaseInput struct {\n\tinputKit\n}\n\n// MakeBaseInput assembles a new BaseInput that can be used to construct a\n// sweep transaction.",
      "length": 105,
      "tokens": 18,
      "embedding": []
    },
    {
      "slug": "func MakeBaseInput(outpoint *wire.OutPoint, witnessType WitnessType,",
      "content": "func MakeBaseInput(outpoint *wire.OutPoint, witnessType WitnessType,\n\tsignDescriptor *SignDescriptor, heightHint uint32,\n\tunconfParent *TxInfo) BaseInput {\n\n\treturn BaseInput{\n\t\tinputKit{\n\t\t\toutpoint:     *outpoint,\n\t\t\twitnessType:  witnessType,\n\t\t\tsignDesc:     *signDescriptor,\n\t\t\theightHint:   heightHint,\n\t\t\tunconfParent: unconfParent,\n\t\t},\n\t}\n}\n\n// NewBaseInput allocates and assembles a new *BaseInput that can be used to\n// construct a sweep transaction.",
      "length": 377,
      "tokens": 42,
      "embedding": []
    },
    {
      "slug": "func NewBaseInput(outpoint *wire.OutPoint, witnessType WitnessType,",
      "content": "func NewBaseInput(outpoint *wire.OutPoint, witnessType WitnessType,\n\tsignDescriptor *SignDescriptor, heightHint uint32) *BaseInput {\n\n\tinput := MakeBaseInput(\n\t\toutpoint, witnessType, signDescriptor, heightHint, nil,\n\t)\n\n\treturn &input\n}\n\n// NewCsvInput assembles a new csv-locked input that can be used to\n// construct a sweep transaction.",
      "length": 262,
      "tokens": 35,
      "embedding": []
    },
    {
      "slug": "func NewCsvInput(outpoint *wire.OutPoint, witnessType WitnessType,",
      "content": "func NewCsvInput(outpoint *wire.OutPoint, witnessType WitnessType,\n\tsignDescriptor *SignDescriptor, heightHint uint32,\n\tblockToMaturity uint32) *BaseInput {\n\n\treturn &BaseInput{\n\t\tinputKit{\n\t\t\toutpoint:        *outpoint,\n\t\t\twitnessType:     witnessType,\n\t\t\tsignDesc:        *signDescriptor,\n\t\t\theightHint:      heightHint,\n\t\t\tblockToMaturity: blockToMaturity,\n\t\t},\n\t}\n}\n\n// NewCsvInputWithCltv assembles a new csv and cltv locked input that can be\n// used to construct a sweep transaction.",
      "length": 407,
      "tokens": 44,
      "embedding": []
    },
    {
      "slug": "func NewCsvInputWithCltv(outpoint *wire.OutPoint, witnessType WitnessType,",
      "content": "func NewCsvInputWithCltv(outpoint *wire.OutPoint, witnessType WitnessType,\n\tsignDescriptor *SignDescriptor, heightHint uint32,\n\tcsvDelay uint32, cltvExpiry uint32) *BaseInput {\n\n\treturn &BaseInput{\n\t\tinputKit{\n\t\t\toutpoint:        *outpoint,\n\t\t\twitnessType:     witnessType,\n\t\t\tsignDesc:        *signDescriptor,\n\t\t\theightHint:      heightHint,\n\t\t\tblockToMaturity: csvDelay,\n\t\t\tcltvExpiry:      cltvExpiry,\n\t\t\tunconfParent:    nil,\n\t\t},\n\t}\n}\n\n// CraftInputScript returns a valid set of input scripts allowing this output\n// to be spent. The returned input scripts should target the input at location\n// txIndex within the passed transaction. The input scripts generated by this\n// method support spending p2wkh, p2wsh, and also nested p2sh outputs.",
      "length": 652,
      "tokens": 79,
      "embedding": []
    },
    {
      "slug": "func (bi *BaseInput) CraftInputScript(signer Signer, txn *wire.MsgTx,",
      "content": "func (bi *BaseInput) CraftInputScript(signer Signer, txn *wire.MsgTx,\n\thashCache *txscript.TxSigHashes,\n\tprevOutputFetcher txscript.PrevOutputFetcher, txinIdx int) (*Script,\n\terror) {\n\n\tsignDesc := bi.SignDesc()\n\tsignDesc.PrevOutputFetcher = prevOutputFetcher\n\twitnessFunc := bi.witnessType.WitnessGenerator(signer, signDesc)\n\n\treturn witnessFunc(txn, hashCache, txinIdx)\n}\n\n// HtlcSucceedInput constitutes a sweep input that needs a pre-image. The input\n// is expected to reside on the commitment tx of the remote party and should\n// not be a second level tx output.",
      "length": 484,
      "tokens": 59,
      "embedding": []
    },
    {
      "slug": "type HtlcSucceedInput struct {",
      "content": "type HtlcSucceedInput struct {\n\tinputKit\n\n\tpreimage []byte\n}\n\n// MakeHtlcSucceedInput assembles a new redeem input that can be used to\n// construct a sweep transaction.",
      "length": 131,
      "tokens": 21,
      "embedding": []
    },
    {
      "slug": "func MakeHtlcSucceedInput(outpoint *wire.OutPoint,",
      "content": "func MakeHtlcSucceedInput(outpoint *wire.OutPoint,\n\tsignDescriptor *SignDescriptor, preimage []byte, heightHint,\n\tblocksToMaturity uint32) HtlcSucceedInput {\n\n\treturn HtlcSucceedInput{\n\t\tinputKit: inputKit{\n\t\t\toutpoint:        *outpoint,\n\t\t\twitnessType:     HtlcAcceptedRemoteSuccess,\n\t\t\tsignDesc:        *signDescriptor,\n\t\t\theightHint:      heightHint,\n\t\t\tblockToMaturity: blocksToMaturity,\n\t\t},\n\t\tpreimage: preimage,\n\t}\n}\n\n// CraftInputScript returns a valid set of input scripts allowing this output\n// to be spent. The returns input scripts should target the input at location\n// txIndex within the passed transaction. The input scripts generated by this\n// method support spending p2wkh, p2wsh, and also nested p2sh outputs.",
      "length": 660,
      "tokens": 77,
      "embedding": []
    },
    {
      "slug": "func (h *HtlcSucceedInput) CraftInputScript(signer Signer, txn *wire.MsgTx,",
      "content": "func (h *HtlcSucceedInput) CraftInputScript(signer Signer, txn *wire.MsgTx,\n\thashCache *txscript.TxSigHashes,\n\tprevOutputFetcher txscript.PrevOutputFetcher, txinIdx int) (*Script,\n\terror) {\n\n\tdesc := h.signDesc\n\tdesc.SigHashes = hashCache\n\tdesc.InputIndex = txinIdx\n\tdesc.PrevOutputFetcher = prevOutputFetcher\n\n\twitness, err := SenderHtlcSpendRedeem(\n\t\tsigner, &desc, txn, h.preimage,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &Script{\n\t\tWitness: witness,\n\t}, nil\n}\n\n// HtlcsSecondLevelAnchorInput is an input type used to spend HTLC outputs\n// using a re-signed second level transaction, either via the timeout or success\n// paths.",
      "length": 541,
      "tokens": 72,
      "embedding": []
    },
    {
      "slug": "type HtlcSecondLevelAnchorInput struct {",
      "content": "type HtlcSecondLevelAnchorInput struct {\n\tinputKit\n\n\t// SignedTx is the original second level transaction signed by the\n\t// channel peer.\n\tSignedTx *wire.MsgTx\n\n\t// createWitness creates a witness allowing the passed transaction to\n\t// spend the input.\n\tcreateWitness func(signer Signer, txn *wire.MsgTx,\n\t\thashCache *txscript.TxSigHashes,\n\t\tprevOutputFetcher txscript.PrevOutputFetcher,\n\t\ttxinIdx int) (wire.TxWitness, error)\n}\n\n// RequiredTxOut returns the tx out needed to be present on the sweep tx for\n// the spend of the input to be valid.",
      "length": 489,
      "tokens": 69,
      "embedding": []
    },
    {
      "slug": "func (i *HtlcSecondLevelAnchorInput) RequiredTxOut() *wire.TxOut {",
      "content": "func (i *HtlcSecondLevelAnchorInput) RequiredTxOut() *wire.TxOut {\n\treturn i.SignedTx.TxOut[0]\n}\n\n// RequiredLockTime returns the locktime needed for the sweep tx for the spend\n// of the input to be valid. For a second level HTLC timeout this will be the\n// CLTV expiry, for HTLC success it will be zero.",
      "length": 232,
      "tokens": 43,
      "embedding": []
    },
    {
      "slug": "func (i *HtlcSecondLevelAnchorInput) RequiredLockTime() (uint32, bool) {",
      "content": "func (i *HtlcSecondLevelAnchorInput) RequiredLockTime() (uint32, bool) {\n\treturn i.SignedTx.LockTime, true\n}\n\n// CraftInputScript returns a valid set of input scripts allowing this output\n// to be spent. The returns input scripts should target the input at location\n// txIndex within the passed transaction. The input scripts generated by this\n// method support spending p2wkh, p2wsh, and also nested p2sh outputs.",
      "length": 335,
      "tokens": 53,
      "embedding": []
    },
    {
      "slug": "func (i *HtlcSecondLevelAnchorInput) CraftInputScript(signer Signer,",
      "content": "func (i *HtlcSecondLevelAnchorInput) CraftInputScript(signer Signer,\n\ttxn *wire.MsgTx, hashCache *txscript.TxSigHashes,\n\tprevOutputFetcher txscript.PrevOutputFetcher, txinIdx int) (*Script,\n\terror) {\n\n\twitness, err := i.createWitness(\n\t\tsigner, txn, hashCache, prevOutputFetcher, txinIdx,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &Script{\n\t\tWitness: witness,\n\t}, nil\n}\n\n// MakeHtlcSecondLevelTimeoutAnchorInput creates an input allowing the sweeper\n// to spend the HTLC output on our commit using the second level timeout\n// transaction.",
      "length": 459,
      "tokens": 61,
      "embedding": []
    },
    {
      "slug": "func MakeHtlcSecondLevelTimeoutAnchorInput(signedTx *wire.MsgTx,",
      "content": "func MakeHtlcSecondLevelTimeoutAnchorInput(signedTx *wire.MsgTx,\n\tsignDetails *SignDetails, heightHint uint32) HtlcSecondLevelAnchorInput {\n\n\t// Spend an HTLC output on our local commitment tx using the\n\t// 2nd timeout transaction.\n\tcreateWitness := func(signer Signer, txn *wire.MsgTx,\n\t\thashCache *txscript.TxSigHashes,\n\t\tprevOutputFetcher txscript.PrevOutputFetcher,\n\t\ttxinIdx int) (wire.TxWitness, error) {\n\n\t\tdesc := signDetails.SignDesc\n\t\tdesc.SigHashes = txscript.NewTxSigHashes(txn, prevOutputFetcher)\n\t\tdesc.InputIndex = txinIdx\n\t\tdesc.PrevOutputFetcher = prevOutputFetcher\n\n\t\treturn SenderHtlcSpendTimeout(\n\t\t\tsignDetails.PeerSig, signDetails.SigHashType, signer,\n\t\t\t&desc, txn,\n\t\t)\n\t}\n\n\treturn HtlcSecondLevelAnchorInput{\n\t\tinputKit: inputKit{\n\t\t\toutpoint:    signedTx.TxIn[0].PreviousOutPoint,\n\t\t\twitnessType: HtlcOfferedTimeoutSecondLevelInputConfirmed,\n\t\t\tsignDesc:    signDetails.SignDesc,\n\t\t\theightHint:  heightHint,\n\n\t\t\t// CSV delay is always 1 for these inputs.\n\t\t\tblockToMaturity: 1,\n\t\t},\n\t\tSignedTx:      signedTx,\n\t\tcreateWitness: createWitness,\n\t}\n}\n\n// MakeHtlcSecondLevelSuccessAnchorInput creates an input allowing the sweeper\n// to spend the HTLC output on our commit using the second level success\n// transaction.",
      "length": 1138,
      "tokens": 113,
      "embedding": []
    },
    {
      "slug": "func MakeHtlcSecondLevelSuccessAnchorInput(signedTx *wire.MsgTx,",
      "content": "func MakeHtlcSecondLevelSuccessAnchorInput(signedTx *wire.MsgTx,\n\tsignDetails *SignDetails, preimage lntypes.Preimage,\n\theightHint uint32) HtlcSecondLevelAnchorInput {\n\n\t// Spend an HTLC output on our local commitment tx using the 2nd\n\t// success transaction.\n\tcreateWitness := func(signer Signer, txn *wire.MsgTx,\n\t\thashCache *txscript.TxSigHashes,\n\t\tprevOutputFetcher txscript.PrevOutputFetcher,\n\t\ttxinIdx int) (wire.TxWitness, error) {\n\n\t\tdesc := signDetails.SignDesc\n\t\tdesc.SigHashes = hashCache\n\t\tdesc.InputIndex = txinIdx\n\t\tdesc.PrevOutputFetcher = prevOutputFetcher\n\n\t\treturn ReceiverHtlcSpendRedeem(\n\t\t\tsignDetails.PeerSig, signDetails.SigHashType,\n\t\t\tpreimage[:], signer, &desc, txn,\n\t\t)\n\t}\n\n\treturn HtlcSecondLevelAnchorInput{\n\t\tinputKit: inputKit{\n\t\t\toutpoint:    signedTx.TxIn[0].PreviousOutPoint,\n\t\t\twitnessType: HtlcAcceptedSuccessSecondLevelInputConfirmed,\n\t\t\tsignDesc:    signDetails.SignDesc,\n\t\t\theightHint:  heightHint,\n\n\t\t\t// CSV delay is always 1 for these inputs.\n\t\t\tblockToMaturity: 1,\n\t\t},\n\t\tSignedTx:      signedTx,\n\t\tcreateWitness: createWitness,\n\t}\n}\n\n// Compile-time constraints to ensure each input struct implement the Input\n// interface.\nvar _ Input = (*BaseInput)(nil)\nvar _ Input = (*HtlcSucceedInput)(nil)\nvar _ Input = (*HtlcSecondLevelAnchorInput)(nil)\n",
      "length": 1182,
      "tokens": 119,
      "embedding": []
    }
  ]
}