{
  "filepath": "../implementations/go/lnd/input/script_utils.go",
  "package": "input",
  "sections": [
    {
      "slug": "type Signature interface {",
      "content": "type Signature interface {\n\t// Serialize returns a DER-encoded ECDSA signature.\n\tSerialize() []byte\n\n\t// Verify return true if the ECDSA signature is valid for the passed\n\t// message digest under the provided public key.\n\tVerify([]byte, *btcec.PublicKey) bool\n}\n\n// WitnessScriptHash generates a pay-to-witness-script-hash public key script\n// paying to a version 0 witness program paying to the passed redeem script.",
      "length": 381,
      "tokens": 56,
      "embedding": []
    },
    {
      "slug": "func WitnessScriptHash(witnessScript []byte) ([]byte, error) {",
      "content": "func WitnessScriptHash(witnessScript []byte) ([]byte, error) {\n\tbldr := txscript.NewScriptBuilder()\n\n\tbldr.AddOp(txscript.OP_0)\n\tscriptHash := sha256.Sum256(witnessScript)\n\tbldr.AddData(scriptHash[:])\n\treturn bldr.Script()\n}\n\n// WitnessPubKeyHash generates a pay-to-witness-pubkey-hash public key script\n// paying to a version 0 witness program containing the passed serialized\n// public key.",
      "length": 319,
      "tokens": 34,
      "embedding": []
    },
    {
      "slug": "func WitnessPubKeyHash(pubkey []byte) ([]byte, error) {",
      "content": "func WitnessPubKeyHash(pubkey []byte) ([]byte, error) {\n\tbldr := txscript.NewScriptBuilder()\n\n\tbldr.AddOp(txscript.OP_0)\n\tpkhash := btcutil.Hash160(pubkey)\n\tbldr.AddData(pkhash)\n\treturn bldr.Script()\n}\n\n// GenerateP2SH generates a pay-to-script-hash public key script paying to the\n// passed redeem script.",
      "length": 241,
      "tokens": 26,
      "embedding": []
    },
    {
      "slug": "func GenerateP2SH(script []byte) ([]byte, error) {",
      "content": "func GenerateP2SH(script []byte) ([]byte, error) {\n\tbldr := txscript.NewScriptBuilder()\n\n\tbldr.AddOp(txscript.OP_HASH160)\n\tscripthash := btcutil.Hash160(script)\n\tbldr.AddData(scripthash)\n\tbldr.AddOp(txscript.OP_EQUAL)\n\treturn bldr.Script()\n}\n\n// GenerateP2PKH generates a pay-to-public-key-hash public key script paying to\n// the passed serialized public key.",
      "length": 298,
      "tokens": 28,
      "embedding": []
    },
    {
      "slug": "func GenerateP2PKH(pubkey []byte) ([]byte, error) {",
      "content": "func GenerateP2PKH(pubkey []byte) ([]byte, error) {\n\tbldr := txscript.NewScriptBuilder()\n\n\tbldr.AddOp(txscript.OP_DUP)\n\tbldr.AddOp(txscript.OP_HASH160)\n\tpkhash := btcutil.Hash160(pubkey)\n\tbldr.AddData(pkhash)\n\tbldr.AddOp(txscript.OP_EQUALVERIFY)\n\tbldr.AddOp(txscript.OP_CHECKSIG)\n\treturn bldr.Script()\n}\n\n// GenerateUnknownWitness generates the maximum-sized witness public key script\n// consisting of a version push and a 40-byte data push.",
      "length": 377,
      "tokens": 34,
      "embedding": []
    },
    {
      "slug": "func GenerateUnknownWitness() ([]byte, error) {",
      "content": "func GenerateUnknownWitness() ([]byte, error) {\n\tbldr := txscript.NewScriptBuilder()\n\n\tbldr.AddOp(txscript.OP_0)\n\twitnessScript := make([]byte, 40)\n\tbldr.AddData(witnessScript)\n\treturn bldr.Script()\n}\n\n// GenMultiSigScript generates the non-p2sh'd multisig script for 2 of 2\n// pubkeys.",
      "length": 229,
      "tokens": 25,
      "embedding": []
    },
    {
      "slug": "func GenMultiSigScript(aPub, bPub []byte) ([]byte, error) {",
      "content": "func GenMultiSigScript(aPub, bPub []byte) ([]byte, error) {\n\tif len(aPub) != 33 || len(bPub) != 33 {\n\t\treturn nil, fmt.Errorf(\"pubkey size error: compressed pubkeys only\")\n\t}\n\n\t// Swap to sort pubkeys if needed. Keys are sorted in lexicographical\n\t// order. The signatures within the scriptSig must also adhere to the\n\t// order, ensuring that the signatures for each public key appears in\n\t// the proper order on the stack.\n\tif bytes.Compare(aPub, bPub) == 1 {\n\t\taPub, bPub = bPub, aPub\n\t}\n\n\tbldr := txscript.NewScriptBuilder()\n\tbldr.AddOp(txscript.OP_2)\n\tbldr.AddData(aPub) // Add both pubkeys (sorted).\n\tbldr.AddData(bPub)\n\tbldr.AddOp(txscript.OP_2)\n\tbldr.AddOp(txscript.OP_CHECKMULTISIG)\n\treturn bldr.Script()\n}\n\n// GenFundingPkScript creates a redeem script, and its matching p2wsh\n// output for the funding transaction.",
      "length": 742,
      "tokens": 105,
      "embedding": []
    },
    {
      "slug": "func GenFundingPkScript(aPub, bPub []byte, amt int64) ([]byte, *wire.TxOut, error) {",
      "content": "func GenFundingPkScript(aPub, bPub []byte, amt int64) ([]byte, *wire.TxOut, error) {\n\t// As a sanity check, ensure that the passed amount is above zero.\n\tif amt <= 0 {\n\t\treturn nil, nil, fmt.Errorf(\"can't create FundTx script with \" +\n\t\t\t\"zero, or negative coins\")\n\t}\n\n\t// First, create the 2-of-2 multi-sig script itself.\n\twitnessScript, err := GenMultiSigScript(aPub, bPub)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// With the 2-of-2 script in had, generate a p2wsh script which pays\n\t// to the funding script.\n\tpkScript, err := WitnessScriptHash(witnessScript)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn witnessScript, wire.NewTxOut(amt, pkScript), nil\n}\n\n// SpendMultiSig generates the witness stack required to redeem the 2-of-2 p2wsh\n// multi-sig output.",
      "length": 665,
      "tokens": 109,
      "embedding": []
    },
    {
      "slug": "func SpendMultiSig(witnessScript, pubA []byte, sigA Signature,",
      "content": "func SpendMultiSig(witnessScript, pubA []byte, sigA Signature,\n\tpubB []byte, sigB Signature) [][]byte {\n\n\twitness := make([][]byte, 4)\n\n\t// When spending a p2wsh multi-sig script, rather than an OP_0, we add\n\t// a nil stack element to eat the extra pop.\n\twitness[0] = nil\n\n\t// When initially generating the witnessScript, we sorted the serialized\n\t// public keys in descending order. So we do a quick comparison in order\n\t// ensure the signatures appear on the Script Virtual Machine stack in\n\t// the correct order.\n\tif bytes.Compare(pubA, pubB) == 1 {\n\t\twitness[1] = append(sigB.Serialize(), byte(txscript.SigHashAll))\n\t\twitness[2] = append(sigA.Serialize(), byte(txscript.SigHashAll))\n\t} else {\n\t\twitness[1] = append(sigA.Serialize(), byte(txscript.SigHashAll))\n\t\twitness[2] = append(sigB.Serialize(), byte(txscript.SigHashAll))\n\t}\n\n\t// Finally, add the preimage as the last witness element.\n\twitness[3] = witnessScript\n\n\treturn witness\n}\n\n// FindScriptOutputIndex finds the index of the public key script output\n// matching 'script'. Additionally, a boolean is returned indicating if a\n// matching output was found at all.\n//\n// NOTE: The search stops after the first matching script is found.",
      "length": 1103,
      "tokens": 160,
      "embedding": []
    },
    {
      "slug": "func FindScriptOutputIndex(tx *wire.MsgTx, script []byte) (bool, uint32) {",
      "content": "func FindScriptOutputIndex(tx *wire.MsgTx, script []byte) (bool, uint32) {\n\tfound := false\n\tindex := uint32(0)\n\tfor i, txOut := range tx.TxOut {\n\t\tif bytes.Equal(txOut.PkScript, script) {\n\t\t\tfound = true\n\t\t\tindex = uint32(i)\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn found, index\n}\n\n// Ripemd160H calculates the ripemd160 of the passed byte slice. This is used to\n// calculate the intermediate hash for payment pre-images. Payment hashes are\n// the result of ripemd160(sha256(paymentPreimage)). As a result, the value\n// passed in should be the sha256 of the payment hash.",
      "length": 464,
      "tokens": 76,
      "embedding": []
    },
    {
      "slug": "func Ripemd160H(d []byte) []byte {",
      "content": "func Ripemd160H(d []byte) []byte {\n\th := ripemd160.New()\n\th.Write(d)\n\treturn h.Sum(nil)\n}\n\n// SenderHTLCScript constructs the public key script for an outgoing HTLC\n// output payment for the sender's version of the commitment transaction. The\n// possible script paths from this output include:\n//\n//   - The sender timing out the HTLC using the second level HTLC timeout\n//     transaction.\n//   - The receiver of the HTLC claiming the output on-chain with the payment\n//     preimage.\n//   - The receiver of the HTLC sweeping all the funds in the case that a\n//     revoked commitment transaction bearing this HTLC was broadcast.\n//\n// If confirmedSpend=true, a 1 OP_CSV check will be added to the non-revocation\n// cases, to allow sweeping only after confirmation.\n//\n// Possible Input Scripts:\n//\n//\tSENDR: <0> <sendr sig>  <recvr sig> <0> (spend using HTLC timeout transaction)\n//\tRECVR: <recvr sig>  <preimage>\n//\tREVOK: <revoke sig> <revoke key>\n//\t * receiver revoke\n//\n// Offered HTLC Output Script:\n//\n//\t OP_DUP OP_HASH160 <revocation key hash160> OP_EQUAL\n//\t OP_IF\n//\t\tOP_CHECKSIG\n//\t OP_ELSE\n//\t\t<recv htlc key>\n//\t\tOP_SWAP OP_SIZE 32 OP_EQUAL\n//\t\tOP_NOTIF\n//\t\t    OP_DROP 2 OP_SWAP <sender htlc key> 2 OP_CHECKMULTISIG\n//\t\tOP_ELSE\n//\t\t    OP_HASH160 <ripemd160(payment hash)> OP_EQUALVERIFY\n//\t\t    OP_CHECKSIG\n//\t\tOP_ENDIF\n//\t\t[1 OP_CHECKSEQUENCEVERIFY OP_DROP] <- if allowing confirmed\n//\t\tspend only.\n//\t OP_ENDIF",
      "length": 1353,
      "tokens": 216,
      "embedding": []
    },
    {
      "slug": "func SenderHTLCScript(senderHtlcKey, receiverHtlcKey,",
      "content": "func SenderHTLCScript(senderHtlcKey, receiverHtlcKey,\n\trevocationKey *btcec.PublicKey, paymentHash []byte,\n\tconfirmedSpend bool) ([]byte, error) {\n\n\tbuilder := txscript.NewScriptBuilder()\n\n\t// The opening operations are used to determine if this is the receiver\n\t// of the HTLC attempting to sweep all the funds due to a contract\n\t// breach. In this case, they'll place the revocation key at the top of\n\t// the stack.\n\tbuilder.AddOp(txscript.OP_DUP)\n\tbuilder.AddOp(txscript.OP_HASH160)\n\tbuilder.AddData(btcutil.Hash160(revocationKey.SerializeCompressed()))\n\tbuilder.AddOp(txscript.OP_EQUAL)\n\n\t// If the hash matches, then this is the revocation clause. The output\n\t// can be spent if the check sig operation passes.\n\tbuilder.AddOp(txscript.OP_IF)\n\tbuilder.AddOp(txscript.OP_CHECKSIG)\n\n\t// Otherwise, this may either be the receiver of the HTLC claiming with\n\t// the pre-image, or the sender of the HTLC sweeping the output after\n\t// it has timed out.\n\tbuilder.AddOp(txscript.OP_ELSE)\n\n\t// We'll do a bit of set up by pushing the receiver's key on the top of\n\t// the stack. This will be needed later if we decide that this is the\n\t// sender activating the time out clause with the HTLC timeout\n\t// transaction.\n\tbuilder.AddData(receiverHtlcKey.SerializeCompressed())\n\n\t// Atm, the top item of the stack is the receiverKey's so we use a swap\n\t// to expose what is either the payment pre-image or a signature.\n\tbuilder.AddOp(txscript.OP_SWAP)\n\n\t// With the top item swapped, check if it's 32 bytes. If so, then this\n\t// *may* be the payment pre-image.\n\tbuilder.AddOp(txscript.OP_SIZE)\n\tbuilder.AddInt64(32)\n\tbuilder.AddOp(txscript.OP_EQUAL)\n\n\t// If it isn't then this might be the sender of the HTLC activating the\n\t// time out clause.\n\tbuilder.AddOp(txscript.OP_NOTIF)\n\n\t// We'll drop the OP_IF return value off the top of the stack so we can\n\t// reconstruct the multi-sig script used as an off-chain covenant. If\n\t// two valid signatures are provided, ten then output will be deemed as\n\t// spendable.\n\tbuilder.AddOp(txscript.OP_DROP)\n\tbuilder.AddOp(txscript.OP_2)\n\tbuilder.AddOp(txscript.OP_SWAP)\n\tbuilder.AddData(senderHtlcKey.SerializeCompressed())\n\tbuilder.AddOp(txscript.OP_2)\n\tbuilder.AddOp(txscript.OP_CHECKMULTISIG)\n\n\t// Otherwise, then the only other case is that this is the receiver of\n\t// the HTLC sweeping it on-chain with the payment pre-image.\n\tbuilder.AddOp(txscript.OP_ELSE)\n\n\t// Hash the top item of the stack and compare it with the hash160 of\n\t// the payment hash, which is already the sha256 of the payment\n\t// pre-image. By using this little trick we're able save space on-chain\n\t// as the witness includes a 20-byte hash rather than a 32-byte hash.\n\tbuilder.AddOp(txscript.OP_HASH160)\n\tbuilder.AddData(Ripemd160H(paymentHash))\n\tbuilder.AddOp(txscript.OP_EQUALVERIFY)\n\n\t// This checks the receiver's signature so that a third party with\n\t// knowledge of the payment preimage still cannot steal the output.\n\tbuilder.AddOp(txscript.OP_CHECKSIG)\n\n\t// Close out the OP_IF statement above.\n\tbuilder.AddOp(txscript.OP_ENDIF)\n\n\t// Add 1 block CSV delay if a confirmation is required for the\n\t// non-revocation clauses.\n\tif confirmedSpend {\n\t\tbuilder.AddOp(txscript.OP_1)\n\t\tbuilder.AddOp(txscript.OP_CHECKSEQUENCEVERIFY)\n\t\tbuilder.AddOp(txscript.OP_DROP)\n\t}\n\n\t// Close out the OP_IF statement at the top of the script.\n\tbuilder.AddOp(txscript.OP_ENDIF)\n\n\treturn builder.Script()\n}\n\n// SenderHtlcSpendRevokeWithKey constructs a valid witness allowing the receiver of an\n// HTLC to claim the output with knowledge of the revocation private key in the\n// scenario that the sender of the HTLC broadcasts a previously revoked\n// commitment transaction. A valid spend requires knowledge of the private key\n// that corresponds to their revocation base point and also the private key from\n// the per commitment point, and a valid signature under the combined public\n// key.",
      "length": 3729,
      "tokens": 514,
      "embedding": []
    },
    {
      "slug": "func SenderHtlcSpendRevokeWithKey(signer Signer, signDesc *SignDescriptor,",
      "content": "func SenderHtlcSpendRevokeWithKey(signer Signer, signDesc *SignDescriptor,\n\trevokeKey *btcec.PublicKey, sweepTx *wire.MsgTx) (wire.TxWitness, error) {\n\n\tsweepSig, err := signer.SignOutputRaw(sweepTx, signDesc)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// The stack required to sweep a revoke HTLC output consists simply of\n\t// the exact witness stack as one of a regular p2wkh spend. The only\n\t// difference is that the keys used were derived in an adversarial\n\t// manner in order to encode the revocation contract into a sig+key\n\t// pair.\n\twitnessStack := wire.TxWitness(make([][]byte, 3))\n\twitnessStack[0] = append(sweepSig.Serialize(), byte(signDesc.HashType))\n\twitnessStack[1] = revokeKey.SerializeCompressed()\n\twitnessStack[2] = signDesc.WitnessScript\n\n\treturn witnessStack, nil\n}\n\n// SenderHtlcSpendRevoke constructs a valid witness allowing the receiver of an\n// HTLC to claim the output with knowledge of the revocation private key in the\n// scenario that the sender of the HTLC broadcasts a previously revoked\n// commitment transaction.  This method first derives the appropriate revocation\n// key, and requires that the provided SignDescriptor has a local revocation\n// basepoint and commitment secret in the PubKey and DoubleTweak fields,\n// respectively.",
      "length": 1163,
      "tokens": 165,
      "embedding": []
    },
    {
      "slug": "func SenderHtlcSpendRevoke(signer Signer, signDesc *SignDescriptor,",
      "content": "func SenderHtlcSpendRevoke(signer Signer, signDesc *SignDescriptor,\n\tsweepTx *wire.MsgTx) (wire.TxWitness, error) {\n\n\trevokeKey, err := deriveRevokePubKey(signDesc)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn SenderHtlcSpendRevokeWithKey(signer, signDesc, revokeKey, sweepTx)\n}\n\n// IsHtlcSpendRevoke is used to determine if the passed spend is spending a\n// HTLC output using the revocation key.",
      "length": 319,
      "tokens": 44,
      "embedding": []
    },
    {
      "slug": "func IsHtlcSpendRevoke(txIn *wire.TxIn, signDesc *SignDescriptor) (",
      "content": "func IsHtlcSpendRevoke(txIn *wire.TxIn, signDesc *SignDescriptor) (\n\tbool, error) {\n\n\trevokeKey, err := deriveRevokePubKey(signDesc)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tif len(txIn.Witness) == 3 &&\n\t\tbytes.Equal(txIn.Witness[1], revokeKey.SerializeCompressed()) {\n\n\t\treturn true, nil\n\t}\n\n\treturn false, nil\n}\n\n// SenderHtlcSpendRedeem constructs a valid witness allowing the receiver of an\n// HTLC to redeem the pending output in the scenario that the sender broadcasts\n// their version of the commitment transaction. A valid spend requires\n// knowledge of the payment preimage, and a valid signature under the receivers\n// public key.",
      "length": 553,
      "tokens": 84,
      "embedding": []
    },
    {
      "slug": "func SenderHtlcSpendRedeem(signer Signer, signDesc *SignDescriptor,",
      "content": "func SenderHtlcSpendRedeem(signer Signer, signDesc *SignDescriptor,\n\tsweepTx *wire.MsgTx, paymentPreimage []byte) (wire.TxWitness, error) {\n\n\tsweepSig, err := signer.SignOutputRaw(sweepTx, signDesc)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// The stack required to spend this output is simply the signature\n\t// generated above under the receiver's public key, and the payment\n\t// pre-image.\n\twitnessStack := wire.TxWitness(make([][]byte, 3))\n\twitnessStack[0] = append(sweepSig.Serialize(), byte(signDesc.HashType))\n\twitnessStack[1] = paymentPreimage\n\twitnessStack[2] = signDesc.WitnessScript\n\n\treturn witnessStack, nil\n}\n\n// SenderHtlcSpendTimeout constructs a valid witness allowing the sender of an\n// HTLC to activate the time locked covenant clause of a soon to be expired\n// HTLC.  This script simply spends the multi-sig output using the\n// pre-generated HTLC timeout transaction.",
      "length": 796,
      "tokens": 106,
      "embedding": []
    },
    {
      "slug": "func SenderHtlcSpendTimeout(receiverSig Signature,",
      "content": "func SenderHtlcSpendTimeout(receiverSig Signature,\n\treceiverSigHash txscript.SigHashType, signer Signer,\n\tsignDesc *SignDescriptor, htlcTimeoutTx *wire.MsgTx) (\n\twire.TxWitness, error) {\n\n\tsweepSig, err := signer.SignOutputRaw(htlcTimeoutTx, signDesc)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// We place a zero as the first item of the evaluated witness stack in\n\t// order to force Script execution to the HTLC timeout clause. The\n\t// second zero is required to consume the extra pop due to a bug in the\n\t// original OP_CHECKMULTISIG.\n\twitnessStack := wire.TxWitness(make([][]byte, 5))\n\twitnessStack[0] = nil\n\twitnessStack[1] = append(receiverSig.Serialize(), byte(receiverSigHash))\n\twitnessStack[2] = append(sweepSig.Serialize(), byte(signDesc.HashType))\n\twitnessStack[3] = nil\n\twitnessStack[4] = signDesc.WitnessScript\n\n\treturn witnessStack, nil\n}\n\n// ReceiverHTLCScript constructs the public key script for an incoming HTLC\n// output payment for the receiver's version of the commitment transaction. The\n// possible execution paths from this script include:\n//   - The receiver of the HTLC uses its second level HTLC transaction to\n//     advance the state of the HTLC into the delay+claim state.\n//   - The sender of the HTLC sweeps all the funds of the HTLC as a breached\n//     commitment was broadcast.\n//   - The sender of the HTLC sweeps the HTLC on-chain after the timeout period\n//     of the HTLC has passed.\n//\n// If confirmedSpend=true, a 1 OP_CSV check will be added to the non-revocation\n// cases, to allow sweeping only after confirmation.\n//\n// Possible Input Scripts:\n//\n//\tRECVR: <0> <sender sig> <recvr sig> <preimage> (spend using HTLC success transaction)\n//\tREVOK: <sig> <key>\n//\tSENDR: <sig> 0\n//\n// Received HTLC Output Script:\n//\n//\t OP_DUP OP_HASH160 <revocation key hash160> OP_EQUAL\n//\t OP_IF\n//\t \tOP_CHECKSIG\n//\t OP_ELSE\n//\t\t<sendr htlc key>\n//\t\tOP_SWAP OP_SIZE 32 OP_EQUAL\n//\t\tOP_IF\n//\t\t    OP_HASH160 <ripemd160(payment hash)> OP_EQUALVERIFY\n//\t\t    2 OP_SWAP <recvr htlc key> 2 OP_CHECKMULTISIG\n//\t\tOP_ELSE\n//\t\t    OP_DROP <cltv expiry> OP_CHECKLOCKTIMEVERIFY OP_DROP\n//\t\t    OP_CHECKSIG\n//\t\tOP_ENDIF\n//\t\t[1 OP_CHECKSEQUENCEVERIFY OP_DROP] <- if allowing confirmed\n//\t\tspend only.\n//\t OP_ENDIF",
      "length": 2117,
      "tokens": 313,
      "embedding": []
    },
    {
      "slug": "func ReceiverHTLCScript(cltvExpiry uint32, senderHtlcKey,",
      "content": "func ReceiverHTLCScript(cltvExpiry uint32, senderHtlcKey,\n\treceiverHtlcKey, revocationKey *btcec.PublicKey,\n\tpaymentHash []byte, confirmedSpend bool) ([]byte, error) {\n\n\tbuilder := txscript.NewScriptBuilder()\n\n\t// The opening operations are used to determine if this is the sender\n\t// of the HTLC attempting to sweep all the funds due to a contract\n\t// breach. In this case, they'll place the revocation key at the top of\n\t// the stack.\n\tbuilder.AddOp(txscript.OP_DUP)\n\tbuilder.AddOp(txscript.OP_HASH160)\n\tbuilder.AddData(btcutil.Hash160(revocationKey.SerializeCompressed()))\n\tbuilder.AddOp(txscript.OP_EQUAL)\n\n\t// If the hash matches, then this is the revocation clause. The output\n\t// can be spent if the check sig operation passes.\n\tbuilder.AddOp(txscript.OP_IF)\n\tbuilder.AddOp(txscript.OP_CHECKSIG)\n\n\t// Otherwise, this may either be the receiver of the HTLC starting the\n\t// claiming process via the second level HTLC success transaction and\n\t// the pre-image, or the sender of the HTLC sweeping the output after\n\t// it has timed out.\n\tbuilder.AddOp(txscript.OP_ELSE)\n\n\t// We'll do a bit of set up by pushing the sender's key on the top of\n\t// the stack. This will be needed later if we decide that this is the\n\t// receiver transitioning the output to the claim state using their\n\t// second-level HTLC success transaction.\n\tbuilder.AddData(senderHtlcKey.SerializeCompressed())\n\n\t// Atm, the top item of the stack is the sender's key so we use a swap\n\t// to expose what is either the payment pre-image or something else.\n\tbuilder.AddOp(txscript.OP_SWAP)\n\n\t// With the top item swapped, check if it's 32 bytes. If so, then this\n\t// *may* be the payment pre-image.\n\tbuilder.AddOp(txscript.OP_SIZE)\n\tbuilder.AddInt64(32)\n\tbuilder.AddOp(txscript.OP_EQUAL)\n\n\t// If the item on the top of the stack is 32-bytes, then it is the\n\t// proper size, so this indicates that the receiver of the HTLC is\n\t// attempting to claim the output on-chain by transitioning the state\n\t// of the HTLC to delay+claim.\n\tbuilder.AddOp(txscript.OP_IF)\n\n\t// Next we'll hash the item on the top of the stack, if it matches the\n\t// payment pre-image, then we'll continue. Otherwise, we'll end the\n\t// script here as this is the invalid payment pre-image.\n\tbuilder.AddOp(txscript.OP_HASH160)\n\tbuilder.AddData(Ripemd160H(paymentHash))\n\tbuilder.AddOp(txscript.OP_EQUALVERIFY)\n\n\t// If the payment hash matches, then we'll also need to satisfy the\n\t// multi-sig covenant by providing both signatures of the sender and\n\t// receiver. If the convenient is met, then we'll allow the spending of\n\t// this output, but only by the HTLC success transaction.\n\tbuilder.AddOp(txscript.OP_2)\n\tbuilder.AddOp(txscript.OP_SWAP)\n\tbuilder.AddData(receiverHtlcKey.SerializeCompressed())\n\tbuilder.AddOp(txscript.OP_2)\n\tbuilder.AddOp(txscript.OP_CHECKMULTISIG)\n\n\t// Otherwise, this might be the sender of the HTLC attempting to sweep\n\t// it on-chain after the timeout.\n\tbuilder.AddOp(txscript.OP_ELSE)\n\n\t// We'll drop the extra item (which is the output from evaluating the\n\t// OP_EQUAL) above from the stack.\n\tbuilder.AddOp(txscript.OP_DROP)\n\n\t// With that item dropped off, we can now enforce the absolute\n\t// lock-time required to timeout the HTLC. If the time has passed, then\n\t// we'll proceed with a checksig to ensure that this is actually the\n\t// sender of he original HTLC.\n\tbuilder.AddInt64(int64(cltvExpiry))\n\tbuilder.AddOp(txscript.OP_CHECKLOCKTIMEVERIFY)\n\tbuilder.AddOp(txscript.OP_DROP)\n\tbuilder.AddOp(txscript.OP_CHECKSIG)\n\n\t// Close out the inner if statement.\n\tbuilder.AddOp(txscript.OP_ENDIF)\n\n\t// Add 1 block CSV delay for non-revocation clauses if confirmation is\n\t// required.\n\tif confirmedSpend {\n\t\tbuilder.AddOp(txscript.OP_1)\n\t\tbuilder.AddOp(txscript.OP_CHECKSEQUENCEVERIFY)\n\t\tbuilder.AddOp(txscript.OP_DROP)\n\t}\n\n\t// Close out the outer if statement.\n\tbuilder.AddOp(txscript.OP_ENDIF)\n\n\treturn builder.Script()\n}\n\n// ReceiverHtlcSpendRedeem constructs a valid witness allowing the receiver of\n// an HTLC to redeem the conditional payment in the event that their commitment\n// transaction is broadcast. This clause transitions the state of the HLTC\n// output into the delay+claim state by activating the off-chain covenant bound\n// by the 2-of-2 multi-sig output. The HTLC success timeout transaction being\n// signed has a relative timelock delay enforced by its sequence number. This\n// delay give the sender of the HTLC enough time to revoke the output if this\n// is a breach commitment transaction.",
      "length": 4308,
      "tokens": 593,
      "embedding": []
    },
    {
      "slug": "func ReceiverHtlcSpendRedeem(senderSig Signature,",
      "content": "func ReceiverHtlcSpendRedeem(senderSig Signature,\n\tsenderSigHash txscript.SigHashType, paymentPreimage []byte,\n\tsigner Signer, signDesc *SignDescriptor, htlcSuccessTx *wire.MsgTx) (\n\twire.TxWitness, error) {\n\n\t// First, we'll generate a signature for the HTLC success transaction.\n\t// The signDesc should be signing with the public key used as the\n\t// receiver's public key and also the correct single tweak.\n\tsweepSig, err := signer.SignOutputRaw(htlcSuccessTx, signDesc)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// The final witness stack is used the provide the script with the\n\t// payment pre-image, and also execute the multi-sig clause after the\n\t// pre-images matches. We add a nil item at the bottom of the stack in\n\t// order to consume the extra pop within OP_CHECKMULTISIG.\n\twitnessStack := wire.TxWitness(make([][]byte, 5))\n\twitnessStack[0] = nil\n\twitnessStack[1] = append(senderSig.Serialize(), byte(senderSigHash))\n\twitnessStack[2] = append(sweepSig.Serialize(), byte(signDesc.HashType))\n\twitnessStack[3] = paymentPreimage\n\twitnessStack[4] = signDesc.WitnessScript\n\n\treturn witnessStack, nil\n}\n\n// ReceiverHtlcSpendRevokeWithKey constructs a valid witness allowing the sender of an\n// HTLC within a previously revoked commitment transaction to re-claim the\n// pending funds in the case that the receiver broadcasts this revoked\n// commitment transaction.",
      "length": 1287,
      "tokens": 172,
      "embedding": []
    },
    {
      "slug": "func ReceiverHtlcSpendRevokeWithKey(signer Signer, signDesc *SignDescriptor,",
      "content": "func ReceiverHtlcSpendRevokeWithKey(signer Signer, signDesc *SignDescriptor,\n\trevokeKey *btcec.PublicKey, sweepTx *wire.MsgTx) (wire.TxWitness, error) {\n\n\t// First, we'll generate a signature for the sweep transaction.  The\n\t// signDesc should be signing with the public key used as the fully\n\t// derived revocation public key and also the correct double tweak\n\t// value.\n\tsweepSig, err := signer.SignOutputRaw(sweepTx, signDesc)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// We place a zero, then one as the first items in the evaluated\n\t// witness stack in order to force script execution to the HTLC\n\t// revocation clause.\n\twitnessStack := wire.TxWitness(make([][]byte, 3))\n\twitnessStack[0] = append(sweepSig.Serialize(), byte(signDesc.HashType))\n\twitnessStack[1] = revokeKey.SerializeCompressed()\n\twitnessStack[2] = signDesc.WitnessScript\n\n\treturn witnessStack, nil\n}\n",
      "length": 771,
      "tokens": 105,
      "embedding": []
    },
    {
      "slug": "func deriveRevokePubKey(signDesc *SignDescriptor) (*btcec.PublicKey, error) {",
      "content": "func deriveRevokePubKey(signDesc *SignDescriptor) (*btcec.PublicKey, error) {\n\tif signDesc.KeyDesc.PubKey == nil {\n\t\treturn nil, fmt.Errorf(\"cannot generate witness with nil \" +\n\t\t\t\"KeyDesc pubkey\")\n\t}\n\n\t// Derive the revocation key using the local revocation base point and\n\t// commitment point.\n\trevokeKey := DeriveRevocationPubkey(\n\t\tsignDesc.KeyDesc.PubKey,\n\t\tsignDesc.DoubleTweak.PubKey(),\n\t)\n\n\treturn revokeKey, nil\n}\n\n// ReceiverHtlcSpendRevoke constructs a valid witness allowing the sender of an\n// HTLC within a previously revoked commitment transaction to re-claim the\n// pending funds in the case that the receiver broadcasts this revoked\n// commitment transaction. This method first derives the appropriate revocation\n// key, and requires that the provided SignDescriptor has a local revocation\n// basepoint and commitment secret in the PubKey and DoubleTweak fields,\n// respectively.",
      "length": 798,
      "tokens": 111,
      "embedding": []
    },
    {
      "slug": "func ReceiverHtlcSpendRevoke(signer Signer, signDesc *SignDescriptor,",
      "content": "func ReceiverHtlcSpendRevoke(signer Signer, signDesc *SignDescriptor,\n\tsweepTx *wire.MsgTx) (wire.TxWitness, error) {\n\n\trevokeKey, err := deriveRevokePubKey(signDesc)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn ReceiverHtlcSpendRevokeWithKey(signer, signDesc, revokeKey, sweepTx)\n}\n\n// ReceiverHtlcSpendTimeout constructs a valid witness allowing the sender of\n// an HTLC to recover the pending funds after an absolute timeout in the\n// scenario that the receiver of the HTLC broadcasts their version of the\n// commitment transaction. If the caller has already set the lock time on the\n// spending transaction, than a value of -1 can be passed for the cltvExpiry\n// value.\n//\n// NOTE: The target input of the passed transaction MUST NOT have a final\n// sequence number. Otherwise, the OP_CHECKLOCKTIMEVERIFY check will fail.",
      "length": 739,
      "tokens": 115,
      "embedding": []
    },
    {
      "slug": "func ReceiverHtlcSpendTimeout(signer Signer, signDesc *SignDescriptor,",
      "content": "func ReceiverHtlcSpendTimeout(signer Signer, signDesc *SignDescriptor,\n\tsweepTx *wire.MsgTx, cltvExpiry int32) (wire.TxWitness, error) {\n\n\t// If the caller set a proper timeout value, then we'll apply it\n\t// directly to the transaction.\n\tif cltvExpiry != -1 {\n\t\t// The HTLC output has an absolute time period before we are\n\t\t// permitted to recover the pending funds. Therefore we need to\n\t\t// set the locktime on this sweeping transaction in order to\n\t\t// pass Script verification.\n\t\tsweepTx.LockTime = uint32(cltvExpiry)\n\t}\n\n\t// With the lock time on the transaction set, we'll not generate a\n\t// signature for the sweep transaction. The passed sign descriptor\n\t// should be created using the raw public key of the sender (w/o the\n\t// single tweak applied), and the single tweak set to the proper value\n\t// taking into account the current state's point.\n\tsweepSig, err := signer.SignOutputRaw(sweepTx, signDesc)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\twitnessStack := wire.TxWitness(make([][]byte, 3))\n\twitnessStack[0] = append(sweepSig.Serialize(), byte(signDesc.HashType))\n\twitnessStack[1] = nil\n\twitnessStack[2] = signDesc.WitnessScript\n\n\treturn witnessStack, nil\n}\n\n// SecondLevelHtlcScript is the uniform script that's used as the output for\n// the second-level HTLC transactions. The second level transaction act as a\n// sort of covenant, ensuring that a 2-of-2 multi-sig output can only be\n// spent in a particular way, and to a particular output.\n//\n// Possible Input Scripts:\n//\n//   - To revoke an HTLC output that has been transitioned to the claim+delay\n//     state:\n//     <revoke sig> 1\n//\n//   - To claim and HTLC output, either with a pre-image or due to a timeout:\n//     <delay sig> 0\n//\n// Output Script:\n//\n//\t OP_IF\n//\t\t<revoke key>\n//\t OP_ELSE\n//\t\t<delay in blocks>\n//\t\tOP_CHECKSEQUENCEVERIFY\n//\t\tOP_DROP\n//\t\t<delay key>\n//\t OP_ENDIF\n//\t OP_CHECKSIG\n//\n// TODO(roasbeef): possible renames for second-level\n//   - transition?\n//   - covenant output",
      "length": 1843,
      "tokens": 298,
      "embedding": []
    },
    {
      "slug": "func SecondLevelHtlcScript(revocationKey, delayKey *btcec.PublicKey,",
      "content": "func SecondLevelHtlcScript(revocationKey, delayKey *btcec.PublicKey,\n\tcsvDelay uint32) ([]byte, error) {\n\n\tbuilder := txscript.NewScriptBuilder()\n\n\t// If this is the revocation clause for this script is to be executed,\n\t// the spender will push a 1, forcing us to hit the true clause of this\n\t// if statement.\n\tbuilder.AddOp(txscript.OP_IF)\n\n\t// If this this is the revocation case, then we'll push the revocation\n\t// public key on the stack.\n\tbuilder.AddData(revocationKey.SerializeCompressed())\n\n\t// Otherwise, this is either the sender or receiver of the HTLC\n\t// attempting to claim the HTLC output.\n\tbuilder.AddOp(txscript.OP_ELSE)\n\n\t// In order to give the other party time to execute the revocation\n\t// clause above, we require a relative timeout to pass before the\n\t// output can be spent.\n\tbuilder.AddInt64(int64(csvDelay))\n\tbuilder.AddOp(txscript.OP_CHECKSEQUENCEVERIFY)\n\tbuilder.AddOp(txscript.OP_DROP)\n\n\t// If the relative timelock passes, then we'll add the delay key to the\n\t// stack to ensure that we properly authenticate the spending party.\n\tbuilder.AddData(delayKey.SerializeCompressed())\n\n\t// Close out the if statement.\n\tbuilder.AddOp(txscript.OP_ENDIF)\n\n\t// In either case, we'll ensure that only either the party possessing\n\t// the revocation private key, or the delay private key is able to\n\t// spend this output.\n\tbuilder.AddOp(txscript.OP_CHECKSIG)\n\n\treturn builder.Script()\n}\n\n// LeaseSecondLevelHtlcScript is the uniform script that's used as the output for\n// the second-level HTLC transactions. The second level transaction acts as a\n// sort of covenant, ensuring that a 2-of-2 multi-sig output can only be\n// spent in a particular way, and to a particular output.\n//\n// Possible Input Scripts:\n//\n//   - To revoke an HTLC output that has been transitioned to the claim+delay\n//     state:\n//     <revoke sig> 1\n//\n//   - To claim an HTLC output, either with a pre-image or due to a timeout:\n//     <delay sig> 0\n//\n// Output Script:\n//\n//\t OP_IF\n//\t\t<revoke key>\n//\t OP_ELSE\n//\t\t<lease maturity in blocks>\n//\t\tOP_CHECKLOCKTIMEVERIFY\n//\t\tOP_DROP\n//\t\t<delay in blocks>\n//\t\tOP_CHECKSEQUENCEVERIFY\n//\t\tOP_DROP\n//\t\t<delay key>\n//\t OP_ENDIF\n//\t OP_CHECKSIG.",
      "length": 2046,
      "tokens": 312,
      "embedding": []
    },
    {
      "slug": "func LeaseSecondLevelHtlcScript(revocationKey, delayKey *btcec.PublicKey,",
      "content": "func LeaseSecondLevelHtlcScript(revocationKey, delayKey *btcec.PublicKey,\n\tcsvDelay, cltvExpiry uint32) ([]byte, error) {\n\n\tbuilder := txscript.NewScriptBuilder()\n\n\t// If this is the revocation clause for this script is to be executed,\n\t// the spender will push a 1, forcing us to hit the true clause of this\n\t// if statement.\n\tbuilder.AddOp(txscript.OP_IF)\n\n\t// If this this is the revocation case, then we'll push the revocation\n\t// public key on the stack.\n\tbuilder.AddData(revocationKey.SerializeCompressed())\n\n\t// Otherwise, this is either the sender or receiver of the HTLC\n\t// attempting to claim the HTLC output.\n\tbuilder.AddOp(txscript.OP_ELSE)\n\n\t// The channel initiator always has the additional channel lease\n\t// expiration constraint for outputs that pay to them which must be\n\t// satisfied.\n\tbuilder.AddInt64(int64(cltvExpiry))\n\tbuilder.AddOp(txscript.OP_CHECKLOCKTIMEVERIFY)\n\tbuilder.AddOp(txscript.OP_DROP)\n\n\t// In order to give the other party time to execute the revocation\n\t// clause above, we require a relative timeout to pass before the\n\t// output can be spent.\n\tbuilder.AddInt64(int64(csvDelay))\n\tbuilder.AddOp(txscript.OP_CHECKSEQUENCEVERIFY)\n\tbuilder.AddOp(txscript.OP_DROP)\n\n\t// If the relative timelock passes, then we'll add the delay key to the\n\t// stack to ensure that we properly authenticate the spending party.\n\tbuilder.AddData(delayKey.SerializeCompressed())\n\n\t// Close out the if statement.\n\tbuilder.AddOp(txscript.OP_ENDIF)\n\n\t// In either case, we'll ensure that only either the party possessing\n\t// the revocation private key, or the delay private key is able to\n\t// spend this output.\n\tbuilder.AddOp(txscript.OP_CHECKSIG)\n\n\treturn builder.Script()\n}\n\n// HtlcSpendSuccess spends a second-level HTLC output. This function is to be\n// used by the sender of an HTLC to claim the output after a relative timeout\n// or the receiver of the HTLC to claim on-chain with the pre-image.",
      "length": 1791,
      "tokens": 250,
      "embedding": []
    },
    {
      "slug": "func HtlcSpendSuccess(signer Signer, signDesc *SignDescriptor,",
      "content": "func HtlcSpendSuccess(signer Signer, signDesc *SignDescriptor,\n\tsweepTx *wire.MsgTx, csvDelay uint32) (wire.TxWitness, error) {\n\n\t// We're required to wait a relative period of time before we can sweep\n\t// the output in order to allow the other party to contest our claim of\n\t// validity to this version of the commitment transaction.\n\tsweepTx.TxIn[0].Sequence = LockTimeToSequence(false, csvDelay)\n\n\t// Finally, OP_CSV requires that the version of the transaction\n\t// spending a pkscript with OP_CSV within it *must* be >= 2.\n\tsweepTx.Version = 2\n\n\t// As we mutated the transaction, we'll re-calculate the sighashes for\n\t// this instance.\n\tsignDesc.SigHashes = NewTxSigHashesV0Only(sweepTx)\n\n\t// With the proper sequence and version set, we'll now sign the timeout\n\t// transaction using the passed signed descriptor. In order to generate\n\t// a valid signature, then signDesc should be using the base delay\n\t// public key, and the proper single tweak bytes.\n\tsweepSig, err := signer.SignOutputRaw(sweepTx, signDesc)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// We set a zero as the first element the witness stack (ignoring the\n\t// witness script), in order to force execution to the second portion\n\t// of the if clause.\n\twitnessStack := wire.TxWitness(make([][]byte, 3))\n\twitnessStack[0] = append(sweepSig.Serialize(), byte(signDesc.HashType))\n\twitnessStack[1] = nil\n\twitnessStack[2] = signDesc.WitnessScript\n\n\treturn witnessStack, nil\n}\n\n// HtlcSpendRevoke spends a second-level HTLC output. This function is to be\n// used by the sender or receiver of an HTLC to claim the HTLC after a revoked\n// commitment transaction was broadcast.",
      "length": 1534,
      "tokens": 233,
      "embedding": []
    },
    {
      "slug": "func HtlcSpendRevoke(signer Signer, signDesc *SignDescriptor,",
      "content": "func HtlcSpendRevoke(signer Signer, signDesc *SignDescriptor,\n\trevokeTx *wire.MsgTx) (wire.TxWitness, error) {\n\n\t// We don't need any spacial modifications to the transaction as this\n\t// is just sweeping a revoked HTLC output. So we'll generate a regular\n\t// witness signature.\n\tsweepSig, err := signer.SignOutputRaw(revokeTx, signDesc)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// We set a one as the first element the witness stack (ignoring the\n\t// witness script), in order to force execution to the revocation\n\t// clause in the second level HTLC script.\n\twitnessStack := wire.TxWitness(make([][]byte, 3))\n\twitnessStack[0] = append(sweepSig.Serialize(), byte(signDesc.HashType))\n\twitnessStack[1] = []byte{1}\n\twitnessStack[2] = signDesc.WitnessScript\n\n\treturn witnessStack, nil\n}\n\n// HtlcSecondLevelSpend exposes the public witness generation function for\n// spending an HTLC success transaction, either due to an expiring time lock or\n// having had the payment preimage. This method is able to spend any\n// second-level HTLC transaction, assuming the caller sets the locktime or\n// seqno properly.\n//\n// NOTE: The caller MUST set the txn version, sequence number, and sign\n// descriptor's sig hash cache before invocation.",
      "length": 1134,
      "tokens": 169,
      "embedding": []
    },
    {
      "slug": "func HtlcSecondLevelSpend(signer Signer, signDesc *SignDescriptor,",
      "content": "func HtlcSecondLevelSpend(signer Signer, signDesc *SignDescriptor,\n\tsweepTx *wire.MsgTx) (wire.TxWitness, error) {\n\n\t// With the proper sequence and version set, we'll now sign the timeout\n\t// transaction using the passed signed descriptor. In order to generate\n\t// a valid signature, then signDesc should be using the base delay\n\t// public key, and the proper single tweak bytes.\n\tsweepSig, err := signer.SignOutputRaw(sweepTx, signDesc)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// We set a zero as the first element the witness stack (ignoring the\n\t// witness script), in order to force execution to the second portion\n\t// of the if clause.\n\twitnessStack := wire.TxWitness(make([][]byte, 3))\n\twitnessStack[0] = append(sweepSig.Serialize(), byte(txscript.SigHashAll))\n\twitnessStack[1] = nil\n\twitnessStack[2] = signDesc.WitnessScript\n\n\treturn witnessStack, nil\n}\n\n// LockTimeToSequence converts the passed relative locktime to a sequence\n// number in accordance to BIP-68.\n// See: https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki\n//   - (Compatibility)",
      "length": 973,
      "tokens": 135,
      "embedding": []
    },
    {
      "slug": "func LockTimeToSequence(isSeconds bool, locktime uint32) uint32 {",
      "content": "func LockTimeToSequence(isSeconds bool, locktime uint32) uint32 {\n\tif !isSeconds {\n\t\t// The locktime is to be expressed in confirmations.\n\t\treturn locktime\n\t}\n\n\t// Set the 22nd bit which indicates the lock time is in seconds, then\n\t// shift the locktime over by 9 since the time granularity is in\n\t// 512-second intervals (2^9). This results in a max lock-time of\n\t// 33,554,431 seconds, or 1.06 years.\n\treturn SequenceLockTimeSeconds | (locktime >> 9)\n}\n\n// CommitScriptToSelf constructs the public key script for the output on the\n// commitment transaction paying to the \"owner\" of said commitment transaction.\n// If the other party learns of the preimage to the revocation hash, then they\n// can claim all the settled funds in the channel, plus the unsettled funds.\n//\n// Possible Input Scripts:\n//\n//\tREVOKE:     <sig> 1\n//\tSENDRSWEEP: <sig> <emptyvector>\n//\n// Output Script:\n//\n//\tOP_IF\n//\t    <revokeKey>\n//\tOP_ELSE\n//\t    <numRelativeBlocks> OP_CHECKSEQUENCEVERIFY OP_DROP\n//\t    <timeKey>\n//\tOP_ENDIF\n//\tOP_CHECKSIG",
      "length": 928,
      "tokens": 153,
      "embedding": []
    },
    {
      "slug": "func CommitScriptToSelf(csvTimeout uint32, selfKey, revokeKey *btcec.PublicKey) ([]byte, error) {",
      "content": "func CommitScriptToSelf(csvTimeout uint32, selfKey, revokeKey *btcec.PublicKey) ([]byte, error) {\n\t// This script is spendable under two conditions: either the\n\t// 'csvTimeout' has passed and we can redeem our funds, or they can\n\t// produce a valid signature with the revocation public key. The\n\t// revocation public key will *only* be known to the other party if we\n\t// have divulged the revocation hash, allowing them to homomorphically\n\t// derive the proper private key which corresponds to the revoke public\n\t// key.\n\tbuilder := txscript.NewScriptBuilder()\n\n\tbuilder.AddOp(txscript.OP_IF)\n\n\t// If a valid signature using the revocation key is presented, then\n\t// allow an immediate spend provided the proper signature.\n\tbuilder.AddData(revokeKey.SerializeCompressed())\n\n\tbuilder.AddOp(txscript.OP_ELSE)\n\n\t// Otherwise, we can re-claim our funds after a CSV delay of\n\t// 'csvTimeout' timeout blocks, and a valid signature.\n\tbuilder.AddInt64(int64(csvTimeout))\n\tbuilder.AddOp(txscript.OP_CHECKSEQUENCEVERIFY)\n\tbuilder.AddOp(txscript.OP_DROP)\n\tbuilder.AddData(selfKey.SerializeCompressed())\n\n\tbuilder.AddOp(txscript.OP_ENDIF)\n\n\t// Finally, we'll validate the signature against the public key that's\n\t// left on the top of the stack.\n\tbuilder.AddOp(txscript.OP_CHECKSIG)\n\n\treturn builder.Script()\n}\n\n// LeaseCommitScriptToSelf constructs the public key script for the output on the\n// commitment transaction paying to the \"owner\" of said commitment transaction.\n// If the other party learns of the preimage to the revocation hash, then they\n// can claim all the settled funds in the channel, plus the unsettled funds.\n//\n// Possible Input Scripts:\n//\n//\tREVOKE:     <sig> 1\n//\tSENDRSWEEP: <sig> <emptyvector>\n//\n// Output Script:\n//\n//\tOP_IF\n//\t    <revokeKey>\n//\tOP_ELSE\n//\t    <absoluteLeaseExpiry> OP_CHECKLOCKTIMEVERIFY OP_DROP\n//\t    <numRelativeBlocks> OP_CHECKSEQUENCEVERIFY OP_DROP\n//\t    <timeKey>\n//\tOP_ENDIF\n//\tOP_CHECKSIG",
      "length": 1783,
      "tokens": 238,
      "embedding": []
    },
    {
      "slug": "func LeaseCommitScriptToSelf(selfKey, revokeKey *btcec.PublicKey,",
      "content": "func LeaseCommitScriptToSelf(selfKey, revokeKey *btcec.PublicKey,\n\tcsvTimeout, leaseExpiry uint32) ([]byte, error) {\n\n\t// This script is spendable under two conditions: either the\n\t// 'csvTimeout' has passed and we can redeem our funds, or they can\n\t// produce a valid signature with the revocation public key. The\n\t// revocation public key will *only* be known to the other party if we\n\t// have divulged the revocation hash, allowing them to homomorphically\n\t// derive the proper private key which corresponds to the revoke public\n\t// key.\n\tbuilder := txscript.NewScriptBuilder()\n\n\tbuilder.AddOp(txscript.OP_IF)\n\n\t// If a valid signature using the revocation key is presented, then\n\t// allow an immediate spend provided the proper signature.\n\tbuilder.AddData(revokeKey.SerializeCompressed())\n\n\tbuilder.AddOp(txscript.OP_ELSE)\n\n\t// Otherwise, we can re-claim our funds after once the CLTV lease\n\t// maturity has been met, along with the CSV delay of 'csvTimeout'\n\t// timeout blocks, and a valid signature.\n\tbuilder.AddInt64(int64(leaseExpiry))\n\tbuilder.AddOp(txscript.OP_CHECKLOCKTIMEVERIFY)\n\tbuilder.AddOp(txscript.OP_DROP)\n\n\tbuilder.AddInt64(int64(csvTimeout))\n\tbuilder.AddOp(txscript.OP_CHECKSEQUENCEVERIFY)\n\tbuilder.AddOp(txscript.OP_DROP)\n\n\tbuilder.AddData(selfKey.SerializeCompressed())\n\n\tbuilder.AddOp(txscript.OP_ENDIF)\n\n\t// Finally, we'll validate the signature against the public key that's\n\t// left on the top of the stack.\n\tbuilder.AddOp(txscript.OP_CHECKSIG)\n\n\treturn builder.Script()\n}\n\n// CommitSpendTimeout constructs a valid witness allowing the owner of a\n// particular commitment transaction to spend the output returning settled\n// funds back to themselves after a relative block timeout.  In order to\n// properly spend the transaction, the target input's sequence number should be\n// set accordingly based off of the target relative block timeout within the\n// redeem script.  Additionally, OP_CSV requires that the version of the\n// transaction spending a pkscript with OP_CSV within it *must* be >= 2.",
      "length": 1911,
      "tokens": 250,
      "embedding": []
    },
    {
      "slug": "func CommitSpendTimeout(signer Signer, signDesc *SignDescriptor,",
      "content": "func CommitSpendTimeout(signer Signer, signDesc *SignDescriptor,\n\tsweepTx *wire.MsgTx) (wire.TxWitness, error) {\n\n\t// Ensure the transaction version supports the validation of sequence\n\t// locks and CSV semantics.\n\tif sweepTx.Version < 2 {\n\t\treturn nil, fmt.Errorf(\"version of passed transaction MUST \"+\n\t\t\t\"be >= 2, not %v\", sweepTx.Version)\n\t}\n\n\t// With the sequence number in place, we're now able to properly sign\n\t// off on the sweep transaction.\n\tsweepSig, err := signer.SignOutputRaw(sweepTx, signDesc)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Place an empty byte as the first item in the evaluated witness stack\n\t// to force script execution to the timeout spend clause. We need to\n\t// place an empty byte in order to ensure our script is still valid\n\t// from the PoV of nodes that are enforcing minimal OP_IF/OP_NOTIF.\n\twitnessStack := wire.TxWitness(make([][]byte, 3))\n\twitnessStack[0] = append(sweepSig.Serialize(), byte(signDesc.HashType))\n\twitnessStack[1] = nil\n\twitnessStack[2] = signDesc.WitnessScript\n\n\treturn witnessStack, nil\n}\n\n// CommitSpendRevoke constructs a valid witness allowing a node to sweep the\n// settled output of a malicious counterparty who broadcasts a revoked\n// commitment transaction.\n//\n// NOTE: The passed SignDescriptor should include the raw (untweaked)\n// revocation base public key of the receiver and also the proper double tweak\n// value based on the commitment secret of the revoked commitment.",
      "length": 1343,
      "tokens": 205,
      "embedding": []
    },
    {
      "slug": "func CommitSpendRevoke(signer Signer, signDesc *SignDescriptor,",
      "content": "func CommitSpendRevoke(signer Signer, signDesc *SignDescriptor,\n\tsweepTx *wire.MsgTx) (wire.TxWitness, error) {\n\n\tsweepSig, err := signer.SignOutputRaw(sweepTx, signDesc)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Place a 1 as the first item in the evaluated witness stack to\n\t// force script execution to the revocation clause.\n\twitnessStack := wire.TxWitness(make([][]byte, 3))\n\twitnessStack[0] = append(sweepSig.Serialize(), byte(signDesc.HashType))\n\twitnessStack[1] = []byte{1}\n\twitnessStack[2] = signDesc.WitnessScript\n\n\treturn witnessStack, nil\n}\n\n// CommitSpendNoDelay constructs a valid witness allowing a node to spend their\n// settled no-delay output on the counterparty's commitment transaction. If the\n// tweakless field is true, then we'll omit the set where we tweak the pubkey\n// with a random set of bytes, and use it directly in the witness stack.\n//\n// NOTE: The passed SignDescriptor should include the raw (untweaked) public\n// key of the receiver and also the proper single tweak value based on the\n// current commitment point.",
      "length": 960,
      "tokens": 143,
      "embedding": []
    },
    {
      "slug": "func CommitSpendNoDelay(signer Signer, signDesc *SignDescriptor,",
      "content": "func CommitSpendNoDelay(signer Signer, signDesc *SignDescriptor,\n\tsweepTx *wire.MsgTx, tweakless bool) (wire.TxWitness, error) {\n\n\tif signDesc.KeyDesc.PubKey == nil {\n\t\treturn nil, fmt.Errorf(\"cannot generate witness with nil \" +\n\t\t\t\"KeyDesc pubkey\")\n\t}\n\n\t// This is just a regular p2wkh spend which looks something like:\n\t//  * witness: <sig> <pubkey>\n\tsweepSig, err := signer.SignOutputRaw(sweepTx, signDesc)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Finally, we'll manually craft the witness. The witness here is the\n\t// exact same as a regular p2wkh witness, depending on the value of the\n\t// tweakless bool.\n\twitness := make([][]byte, 2)\n\twitness[0] = append(sweepSig.Serialize(), byte(signDesc.HashType))\n\n\tswitch tweakless {\n\t// If we're tweaking the key, then we use the tweaked public key as the\n\t// last item in the witness stack which was originally used to created\n\t// the pkScript we're spending.\n\tcase false:\n\t\twitness[1] = TweakPubKeyWithTweak(\n\t\t\tsignDesc.KeyDesc.PubKey, signDesc.SingleTweak,\n\t\t).SerializeCompressed()\n\n\t// Otherwise, we can just use the raw pubkey, since there's no random\n\t// value to be combined.\n\tcase true:\n\t\twitness[1] = signDesc.KeyDesc.PubKey.SerializeCompressed()\n\t}\n\n\treturn witness, nil\n}\n\n// CommitScriptUnencumbered constructs the public key script on the commitment\n// transaction paying to the \"other\" party. The constructed output is a normal\n// p2wkh output spendable immediately, requiring no contestation period.",
      "length": 1361,
      "tokens": 196,
      "embedding": []
    },
    {
      "slug": "func CommitScriptUnencumbered(key *btcec.PublicKey) ([]byte, error) {",
      "content": "func CommitScriptUnencumbered(key *btcec.PublicKey) ([]byte, error) {\n\t// This script goes to the \"other\" party, and is spendable immediately.\n\tbuilder := txscript.NewScriptBuilder()\n\tbuilder.AddOp(txscript.OP_0)\n\tbuilder.AddData(btcutil.Hash160(key.SerializeCompressed()))\n\n\treturn builder.Script()\n}\n\n// CommitScriptToRemoteConfirmed constructs the script for the output on the\n// commitment transaction paying to the remote party of said commitment\n// transaction. The money can only be spend after one confirmation.\n//\n// Possible Input Scripts:\n//\n//\tSWEEP: <sig>\n//\n// Output Script:\n//\n//\t<key> OP_CHECKSIGVERIFY\n//\t1 OP_CHECKSEQUENCEVERIFY",
      "length": 558,
      "tokens": 72,
      "embedding": []
    },
    {
      "slug": "func CommitScriptToRemoteConfirmed(key *btcec.PublicKey) ([]byte, error) {",
      "content": "func CommitScriptToRemoteConfirmed(key *btcec.PublicKey) ([]byte, error) {\n\tbuilder := txscript.NewScriptBuilder()\n\n\t// Only the given key can spend the output.\n\tbuilder.AddData(key.SerializeCompressed())\n\tbuilder.AddOp(txscript.OP_CHECKSIGVERIFY)\n\n\t// Check that the it has one confirmation.\n\tbuilder.AddOp(txscript.OP_1)\n\tbuilder.AddOp(txscript.OP_CHECKSEQUENCEVERIFY)\n\n\treturn builder.Script()\n}\n\n// LeaseCommitScriptToRemoteConfirmed constructs the script for the output on\n// the commitment transaction paying to the remote party of said commitment\n// transaction. The money can only be spend after one confirmation.\n//\n// Possible Input Scripts:\n//\n//\tSWEEP: <sig>\n//\n// Output Script:\n//\n//\t\t<key> OP_CHECKSIGVERIFY\n//\t     <lease maturity in blocks> OP_CHECKLOCKTIMEVERIFY OP_DROP\n//\t\t1 OP_CHECKSEQUENCEVERIFY",
      "length": 717,
      "tokens": 86,
      "embedding": []
    },
    {
      "slug": "func LeaseCommitScriptToRemoteConfirmed(key *btcec.PublicKey,",
      "content": "func LeaseCommitScriptToRemoteConfirmed(key *btcec.PublicKey,\n\tleaseExpiry uint32) ([]byte, error) {\n\n\tbuilder := txscript.NewScriptBuilder()\n\n\t// Only the given key can spend the output.\n\tbuilder.AddData(key.SerializeCompressed())\n\tbuilder.AddOp(txscript.OP_CHECKSIGVERIFY)\n\n\t// The channel initiator always has the additional channel lease\n\t// expiration constraint for outputs that pay to them which must be\n\t// satisfied.\n\tbuilder.AddInt64(int64(leaseExpiry))\n\tbuilder.AddOp(txscript.OP_CHECKLOCKTIMEVERIFY)\n\tbuilder.AddOp(txscript.OP_DROP)\n\n\t// Check that it has one confirmation.\n\tbuilder.AddOp(txscript.OP_1)\n\tbuilder.AddOp(txscript.OP_CHECKSEQUENCEVERIFY)\n\n\treturn builder.Script()\n}\n\n// CommitSpendToRemoteConfirmed constructs a valid witness allowing a node to\n// spend their settled output on the counterparty's commitment transaction when\n// it has one confirmetion. This is used for the anchor channel type. The\n// spending key will always be non-tweaked for this output type.",
      "length": 902,
      "tokens": 104,
      "embedding": []
    },
    {
      "slug": "func CommitSpendToRemoteConfirmed(signer Signer, signDesc *SignDescriptor,",
      "content": "func CommitSpendToRemoteConfirmed(signer Signer, signDesc *SignDescriptor,\n\tsweepTx *wire.MsgTx) (wire.TxWitness, error) {\n\n\tif signDesc.KeyDesc.PubKey == nil {\n\t\treturn nil, fmt.Errorf(\"cannot generate witness with nil \" +\n\t\t\t\"KeyDesc pubkey\")\n\t}\n\n\t// Similar to non delayed output, only a signature is needed.\n\tsweepSig, err := signer.SignOutputRaw(sweepTx, signDesc)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Finally, we'll manually craft the witness. The witness here is the\n\t// signature and the redeem script.\n\twitnessStack := make([][]byte, 2)\n\twitnessStack[0] = append(sweepSig.Serialize(), byte(signDesc.HashType))\n\twitnessStack[1] = signDesc.WitnessScript\n\n\treturn witnessStack, nil\n}\n\n// CommitScriptAnchor constructs the script for the anchor output spendable by\n// the given key immediately, or by anyone after 16 confirmations.\n//\n// Possible Input Scripts:\n//\n//\tBy owner:\t\t\t\t<sig>\n//\tBy anyone (after 16 conf):\t<emptyvector>\n//\n// Output Script:\n//\n//\t<funding_pubkey> OP_CHECKSIG OP_IFDUP\n//\tOP_NOTIF\n//\t  OP_16 OP_CSV\n//\tOP_ENDIF",
      "length": 938,
      "tokens": 135,
      "embedding": []
    },
    {
      "slug": "func CommitScriptAnchor(key *btcec.PublicKey) ([]byte, error) {",
      "content": "func CommitScriptAnchor(key *btcec.PublicKey) ([]byte, error) {\n\tbuilder := txscript.NewScriptBuilder()\n\n\t// Spend immediately with key.\n\tbuilder.AddData(key.SerializeCompressed())\n\tbuilder.AddOp(txscript.OP_CHECKSIG)\n\n\t// Duplicate the value if true, since it will be consumed by the NOTIF.\n\tbuilder.AddOp(txscript.OP_IFDUP)\n\n\t// Otherwise spendable by anyone after 16 confirmations.\n\tbuilder.AddOp(txscript.OP_NOTIF)\n\tbuilder.AddOp(txscript.OP_16)\n\tbuilder.AddOp(txscript.OP_CHECKSEQUENCEVERIFY)\n\tbuilder.AddOp(txscript.OP_ENDIF)\n\n\treturn builder.Script()\n}\n\n// CommitSpendAnchor constructs a valid witness allowing a node to spend their\n// anchor output on the commitment transaction using their funding key. This is\n// used for the anchor channel type.",
      "length": 672,
      "tokens": 72,
      "embedding": []
    },
    {
      "slug": "func CommitSpendAnchor(signer Signer, signDesc *SignDescriptor,",
      "content": "func CommitSpendAnchor(signer Signer, signDesc *SignDescriptor,\n\tsweepTx *wire.MsgTx) (wire.TxWitness, error) {\n\n\tif signDesc.KeyDesc.PubKey == nil {\n\t\treturn nil, fmt.Errorf(\"cannot generate witness with nil \" +\n\t\t\t\"KeyDesc pubkey\")\n\t}\n\n\t// Create a signature.\n\tsweepSig, err := signer.SignOutputRaw(sweepTx, signDesc)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// The witness here is just a signature and the redeem script.\n\twitnessStack := make([][]byte, 2)\n\twitnessStack[0] = append(sweepSig.Serialize(), byte(signDesc.HashType))\n\twitnessStack[1] = signDesc.WitnessScript\n\n\treturn witnessStack, nil\n}\n\n// CommitSpendAnchorAnyone constructs a witness allowing anyone to spend the\n// anchor output after it has gotten 16 confirmations. Since no signing is\n// required, only knowledge of the redeem script is necessary to spend it.",
      "length": 742,
      "tokens": 103,
      "embedding": []
    },
    {
      "slug": "func CommitSpendAnchorAnyone(script []byte) (wire.TxWitness, error) {",
      "content": "func CommitSpendAnchorAnyone(script []byte) (wire.TxWitness, error) {\n\t// The witness here is just the redeem script.\n\twitnessStack := make([][]byte, 2)\n\twitnessStack[0] = nil\n\twitnessStack[1] = script\n\n\treturn witnessStack, nil\n}\n\n// SingleTweakBytes computes set of bytes we call the single tweak. The purpose\n// of the single tweak is to randomize all regular delay and payment base\n// points. To do this, we generate a hash that binds the commitment point to\n// the pay/delay base point. The end end results is that the basePoint is\n// tweaked as follows:\n//\n//   - key = basePoint + sha256(commitPoint || basePoint)*G",
      "length": 538,
      "tokens": 93,
      "embedding": []
    },
    {
      "slug": "func SingleTweakBytes(commitPoint, basePoint *btcec.PublicKey) []byte {",
      "content": "func SingleTweakBytes(commitPoint, basePoint *btcec.PublicKey) []byte {\n\th := sha256.New()\n\th.Write(commitPoint.SerializeCompressed())\n\th.Write(basePoint.SerializeCompressed())\n\treturn h.Sum(nil)\n}\n\n// TweakPubKey tweaks a public base point given a per commitment point. The per\n// commitment point is a unique point on our target curve for each commitment\n// transaction. When tweaking a local base point for use in a remote commitment\n// transaction, the remote party's current per commitment point is to be used.\n// The opposite applies for when tweaking remote keys. Precisely, the following\n// operation is used to \"tweak\" public keys:\n//\n//\ttweakPub := basePoint + sha256(commitPoint || basePoint) * G\n//\t         := G*k + sha256(commitPoint || basePoint)*G\n//\t         := G*(k + sha256(commitPoint || basePoint))\n//\n// Therefore, if a party possess the value k, the private key of the base\n// point, then they are able to derive the proper private key for the\n// revokeKey by computing:\n//\n//\trevokePriv := k + sha256(commitPoint || basePoint) mod N\n//\n// Where N is the order of the sub-group.\n//\n// The rationale for tweaking all public keys used within the commitment\n// contracts is to ensure that all keys are properly delinearized to avoid any\n// funny business when jointly collaborating to compute public and private\n// keys. Additionally, the use of the per commitment point ensures that each\n// commitment state houses a unique set of keys which is useful when creating\n// blinded channel outsourcing protocols.\n//\n// TODO(roasbeef): should be using double-scalar mult here",
      "length": 1486,
      "tokens": 242,
      "embedding": []
    },
    {
      "slug": "func TweakPubKey(basePoint, commitPoint *btcec.PublicKey) *btcec.PublicKey {",
      "content": "func TweakPubKey(basePoint, commitPoint *btcec.PublicKey) *btcec.PublicKey {\n\ttweakBytes := SingleTweakBytes(commitPoint, basePoint)\n\treturn TweakPubKeyWithTweak(basePoint, tweakBytes)\n}\n\n// TweakPubKeyWithTweak is the exact same as the TweakPubKey function, however\n// it accepts the raw tweak bytes directly rather than the commitment point.",
      "length": 261,
      "tokens": 32,
      "embedding": []
    },
    {
      "slug": "func TweakPubKeyWithTweak(pubKey *btcec.PublicKey,",
      "content": "func TweakPubKeyWithTweak(pubKey *btcec.PublicKey,\n\ttweakBytes []byte) *btcec.PublicKey {\n\n\tvar (\n\t\tpubKeyJacobian btcec.JacobianPoint\n\t\ttweakJacobian  btcec.JacobianPoint\n\t\tresultJacobian btcec.JacobianPoint\n\t)\n\ttweakKey, _ := btcec.PrivKeyFromBytes(tweakBytes)\n\tbtcec.ScalarBaseMultNonConst(&tweakKey.Key, &tweakJacobian)\n\n\tpubKey.AsJacobian(&pubKeyJacobian)\n\tbtcec.AddNonConst(&pubKeyJacobian, &tweakJacobian, &resultJacobian)\n\n\tresultJacobian.ToAffine()\n\treturn btcec.NewPublicKey(&resultJacobian.X, &resultJacobian.Y)\n}\n\n// TweakPrivKey tweaks the private key of a public base point given a per\n// commitment point. The per commitment secret is the revealed revocation\n// secret for the commitment state in question. This private key will only need\n// to be generated in the case that a channel counter party broadcasts a\n// revoked state. Precisely, the following operation is used to derive a\n// tweaked private key:\n//\n//   - tweakPriv := basePriv + sha256(commitment || basePub) mod N\n//\n// Where N is the order of the sub-group.",
      "length": 961,
      "tokens": 119,
      "embedding": []
    },
    {
      "slug": "func TweakPrivKey(basePriv *btcec.PrivateKey,",
      "content": "func TweakPrivKey(basePriv *btcec.PrivateKey,\n\tcommitTweak []byte) *btcec.PrivateKey {\n\n\t// tweakInt := sha256(commitPoint || basePub)\n\ttweakScalar := new(btcec.ModNScalar)\n\ttweakScalar.SetByteSlice(commitTweak)\n\n\ttweakScalar.Add(&basePriv.Key)\n\n\treturn &btcec.PrivateKey{Key: *tweakScalar}\n}\n\n// DeriveRevocationPubkey derives the revocation public key given the\n// counterparty's commitment key, and revocation preimage derived via a\n// pseudo-random-function. In the event that we (for some reason) broadcast a\n// revoked commitment transaction, then if the other party knows the revocation\n// preimage, then they'll be able to derive the corresponding private key to\n// this private key by exploiting the homomorphism in the elliptic curve group:\n//   - https://en.wikipedia.org/wiki/Group_homomorphism#Homomorphisms_of_abelian_groups\n//\n// The derivation is performed as follows:\n//\n//\trevokeKey := revokeBase * sha256(revocationBase || commitPoint) +\n//\t             commitPoint * sha256(commitPoint || revocationBase)\n//\n//\t          := G*(revokeBasePriv * sha256(revocationBase || commitPoint)) +\n//\t             G*(commitSecret * sha256(commitPoint || revocationBase))\n//\n//\t          := G*(revokeBasePriv * sha256(revocationBase || commitPoint) +\n//\t                commitSecret * sha256(commitPoint || revocationBase))\n//\n// Therefore, once we divulge the revocation secret, the remote peer is able to\n// compute the proper private key for the revokeKey by computing:\n//\n//\trevokePriv := (revokeBasePriv * sha256(revocationBase || commitPoint)) +\n//\t              (commitSecret * sha256(commitPoint || revocationBase)) mod N\n//\n// Where N is the order of the sub-group.",
      "length": 1598,
      "tokens": 199,
      "embedding": []
    },
    {
      "slug": "func DeriveRevocationPubkey(revokeBase,",
      "content": "func DeriveRevocationPubkey(revokeBase,\n\tcommitPoint *btcec.PublicKey) *btcec.PublicKey {\n\n\t// R = revokeBase * sha256(revocationBase || commitPoint)\n\trevokeTweakBytes := SingleTweakBytes(revokeBase, commitPoint)\n\trevokeTweakScalar := new(btcec.ModNScalar)\n\trevokeTweakScalar.SetByteSlice(revokeTweakBytes)\n\n\tvar (\n\t\trevokeBaseJacobian btcec.JacobianPoint\n\t\trJacobian          btcec.JacobianPoint\n\t)\n\trevokeBase.AsJacobian(&revokeBaseJacobian)\n\tbtcec.ScalarMultNonConst(\n\t\trevokeTweakScalar, &revokeBaseJacobian, &rJacobian,\n\t)\n\n\t// C = commitPoint * sha256(commitPoint || revocationBase)\n\tcommitTweakBytes := SingleTweakBytes(commitPoint, revokeBase)\n\tcommitTweakScalar := new(btcec.ModNScalar)\n\tcommitTweakScalar.SetByteSlice(commitTweakBytes)\n\n\tvar (\n\t\tcommitPointJacobian btcec.JacobianPoint\n\t\tcJacobian           btcec.JacobianPoint\n\t)\n\tcommitPoint.AsJacobian(&commitPointJacobian)\n\tbtcec.ScalarMultNonConst(\n\t\tcommitTweakScalar, &commitPointJacobian, &cJacobian,\n\t)\n\n\t// Now that we have the revocation point, we add this to their commitment\n\t// public key in order to obtain the revocation public key.\n\t//\n\t// P = R + C\n\tvar resultJacobian btcec.JacobianPoint\n\tbtcec.AddNonConst(&rJacobian, &cJacobian, &resultJacobian)\n\n\tresultJacobian.ToAffine()\n\treturn btcec.NewPublicKey(&resultJacobian.X, &resultJacobian.Y)\n}\n\n// DeriveRevocationPrivKey derives the revocation private key given a node's\n// commitment private key, and the preimage to a previously seen revocation\n// hash. Using this derived private key, a node is able to claim the output\n// within the commitment transaction of a node in the case that they broadcast\n// a previously revoked commitment transaction.\n//\n// The private key is derived as follows:\n//\n//\trevokePriv := (revokeBasePriv * sha256(revocationBase || commitPoint)) +\n//\t              (commitSecret * sha256(commitPoint || revocationBase)) mod N\n//\n// Where N is the order of the sub-group.",
      "length": 1833,
      "tokens": 199,
      "embedding": []
    },
    {
      "slug": "func DeriveRevocationPrivKey(revokeBasePriv *btcec.PrivateKey,",
      "content": "func DeriveRevocationPrivKey(revokeBasePriv *btcec.PrivateKey,\n\tcommitSecret *btcec.PrivateKey) *btcec.PrivateKey {\n\n\t// r = sha256(revokeBasePub || commitPoint)\n\trevokeTweakBytes := SingleTweakBytes(\n\t\trevokeBasePriv.PubKey(), commitSecret.PubKey(),\n\t)\n\trevokeTweakScalar := new(btcec.ModNScalar)\n\trevokeTweakScalar.SetByteSlice(revokeTweakBytes)\n\n\t// c = sha256(commitPoint || revokeBasePub)\n\tcommitTweakBytes := SingleTweakBytes(\n\t\tcommitSecret.PubKey(), revokeBasePriv.PubKey(),\n\t)\n\tcommitTweakScalar := new(btcec.ModNScalar)\n\tcommitTweakScalar.SetByteSlice(commitTweakBytes)\n\n\t// Finally to derive the revocation secret key we'll perform the\n\t// following operation:\n\t//\n\t//  k = (revocationPriv * r) + (commitSecret * c) mod N\n\t//\n\t// This works since:\n\t//  P = (G*a)*b + (G*c)*d\n\t//  P = G*(a*b) + G*(c*d)\n\t//  P = G*(a*b + c*d)\n\trevokeHalfPriv := revokeTweakScalar.Mul(&revokeBasePriv.Key)\n\tcommitHalfPriv := commitTweakScalar.Mul(&commitSecret.Key)\n\n\trevocationPriv := revokeHalfPriv.Add(commitHalfPriv)\n\n\treturn &btcec.PrivateKey{Key: *revocationPriv}\n}\n\n// ComputeCommitmentPoint generates a commitment point given a commitment\n// secret. The commitment point for each state is used to randomize each key in\n// the key-ring and also to used as a tweak to derive new public+private keys\n// for the state.",
      "length": 1215,
      "tokens": 142,
      "embedding": []
    },
    {
      "slug": "func ComputeCommitmentPoint(commitSecret []byte) *btcec.PublicKey {",
      "content": "func ComputeCommitmentPoint(commitSecret []byte) *btcec.PublicKey {\n\t_, pubKey := btcec.PrivKeyFromBytes(commitSecret)\n\treturn pubKey\n}\n",
      "length": 65,
      "tokens": 7,
      "embedding": []
    }
  ]
}