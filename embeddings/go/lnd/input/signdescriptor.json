{
  "filepath": "../implementations/go/lnd/input/signdescriptor.go",
  "package": "input",
  "sections": [
    {
      "slug": "type SignDescriptor struct {",
      "content": "type SignDescriptor struct {\n\t// KeyDesc is a descriptor that precisely describes *which* key to use\n\t// for signing. This may provide the raw public key directly, or\n\t// require the Signer to re-derive the key according to the populated\n\t// derivation path.\n\tKeyDesc keychain.KeyDescriptor\n\n\t// SingleTweak is a scalar value that will be added to the private key\n\t// corresponding to the above public key to obtain the private key to\n\t// be used to sign this input. This value is typically derived via the\n\t// following computation:\n\t//\n\t//  * derivedKey = privkey + sha256(perCommitmentPoint || pubKey) mod N\n\t//\n\t// NOTE: If this value is nil, then the input can be signed using only\n\t// the above public key. Either a SingleTweak should be set or a\n\t// DoubleTweak, not both.\n\tSingleTweak []byte\n\n\t// DoubleTweak is a private key that will be used in combination with\n\t// its corresponding private key to derive the private key that is to\n\t// be used to sign the target input. Within the Lightning protocol,\n\t// this value is typically the commitment secret from a previously\n\t// revoked commitment transaction. This value is in combination with\n\t// two hash values, and the original private key to derive the private\n\t// key to be used when signing.\n\t//\n\t//  * k = (privKey*sha256(pubKey || tweakPub) +\n\t//        tweakPriv*sha256(tweakPub || pubKey)) mod N\n\t//\n\t// NOTE: If this value is nil, then the input can be signed using only\n\t// the above public key. Either a SingleTweak should be set or a\n\t// DoubleTweak, not both.\n\tDoubleTweak *btcec.PrivateKey\n\n\t// TapTweak is a 32-byte value that will be used to derive a taproot\n\t// output public key (or the corresponding private key) from an\n\t// internal key and this tweak. The transformation applied is:\n\t//  * outputKey = internalKey +\n\t//        tagged_hash(\"tapTweak\", internalKey || tapTweak)\n\t//\n\t// When attempting to sign an output derived via BIP 86, then this\n\t// field should be an empty byte array.\n\t//\n\t// When attempting to sign for the key spend path of an output key that\n\t// commits to an actual script tree, the script root should be used.\n\tTapTweak []byte\n\n\t// WitnessScript is the full script required to properly redeem the\n\t// output. This field should be set to the full script if a p2wsh\n\t// output is being signed. For p2wkh it should be set to the hashed\n\t// script (PkScript).\n\tWitnessScript []byte\n\n\t// SignMethod specifies how the input should be signed. Depending on the\n\t// selected method, either the TapTweak, WitnessScript or both need to\n\t// be specified.\n\tSignMethod SignMethod\n\n\t// Output is the target output which should be signed. The PkScript and\n\t// Value fields within the output should be properly populated,\n\t// otherwise an invalid signature may be generated.\n\tOutput *wire.TxOut\n\n\t// HashType is the target sighash type that should be used when\n\t// generating the final sighash, and signature.\n\tHashType txscript.SigHashType\n\n\t// SigHashes is the pre-computed sighash midstate to be used when\n\t// generating the final sighash for signing.\n\tSigHashes *txscript.TxSigHashes\n\n\t// PrevOutputFetcher is an interface that can return the output\n\t// information on all UTXOs that are being spent in this transaction.\n\t// This MUST be set when spending Taproot outputs.\n\tPrevOutputFetcher txscript.PrevOutputFetcher\n\n\t// InputIndex is the target input within the transaction that should be\n\t// signed.\n\tInputIndex int\n}\n\n// SignMethod defines the different ways a signer can sign, given a specific\n// input.",
      "length": 3392,
      "tokens": 571,
      "embedding": []
    },
    {
      "slug": "type SignMethod uint8",
      "content": "type SignMethod uint8\n\nconst (\n\t// WitnessV0SignMethod denotes that a SegWit v0 (p2wkh, np2wkh, p2wsh)\n\t// input script should be signed.\n\tWitnessV0SignMethod SignMethod = 0\n\n\t// TaprootKeySpendBIP0086SignMethod denotes that a SegWit v1 (p2tr)\n\t// input should be signed by using the BIP0086 method (commit to\n\t// internal key only).\n\tTaprootKeySpendBIP0086SignMethod SignMethod = 1\n\n\t// TaprootKeySpendSignMethod denotes that a SegWit v1 (p2tr)\n\t// input should be signed by using a given taproot hash to commit to in\n\t// addition to the internal key.\n\tTaprootKeySpendSignMethod SignMethod = 2\n\n\t// TaprootScriptSpendSignMethod denotes that a SegWit v1 (p2tr) input\n\t// should be spent using the script path and that a specific leaf script\n\t// should be signed for.\n\tTaprootScriptSpendSignMethod SignMethod = 3\n)\n\n// String returns a human-readable representation of the signing method.",
      "length": 843,
      "tokens": 126,
      "embedding": []
    },
    {
      "slug": "func (s SignMethod) String() string {",
      "content": "func (s SignMethod) String() string {\n\tswitch s {\n\tcase WitnessV0SignMethod:\n\t\treturn \"witness_v0\"\n\tcase TaprootKeySpendBIP0086SignMethod:\n\t\treturn \"taproot_key_spend_bip86\"\n\tcase TaprootKeySpendSignMethod:\n\t\treturn \"taproot_key_spend\"\n\tcase TaprootScriptSpendSignMethod:\n\t\treturn \"taproot_script_spend\"\n\tdefault:\n\t\treturn fmt.Sprintf(\"unknown<%d>\", s)\n\t}\n}\n\n// PkScriptCompatible returns true if the given public key script is compatible\n// with the sign method.",
      "length": 410,
      "tokens": 42,
      "embedding": []
    },
    {
      "slug": "func (s SignMethod) PkScriptCompatible(pkScript []byte) bool {",
      "content": "func (s SignMethod) PkScriptCompatible(pkScript []byte) bool {\n\tswitch s {\n\t// SegWit v0 can be p2wkh, np2wkh, p2wsh.\n\tcase WitnessV0SignMethod:\n\t\treturn txscript.IsPayToWitnessPubKeyHash(pkScript) ||\n\t\t\ttxscript.IsPayToWitnessScriptHash(pkScript) ||\n\t\t\ttxscript.IsPayToScriptHash(pkScript)\n\n\tcase TaprootKeySpendBIP0086SignMethod, TaprootKeySpendSignMethod,\n\t\tTaprootScriptSpendSignMethod:\n\n\t\treturn txscript.IsPayToTaproot(pkScript)\n\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// WriteSignDescriptor serializes a SignDescriptor struct into the passed\n// io.Writer stream.\n//\n// NOTE: We assume the SigHashes and InputIndex fields haven't been assigned\n// yet, since that is usually done just before broadcast by the witness\n// generator.",
      "length": 642,
      "tokens": 70,
      "embedding": []
    },
    {
      "slug": "func WriteSignDescriptor(w io.Writer, sd *SignDescriptor) error {",
      "content": "func WriteSignDescriptor(w io.Writer, sd *SignDescriptor) error {\n\terr := binary.Write(w, binary.BigEndian, sd.KeyDesc.Family)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = binary.Write(w, binary.BigEndian, sd.KeyDesc.Index)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = binary.Write(w, binary.BigEndian, sd.KeyDesc.PubKey != nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif sd.KeyDesc.PubKey != nil {\n\t\tserializedPubKey := sd.KeyDesc.PubKey.SerializeCompressed()\n\t\tif err := wire.WriteVarBytes(w, 0, serializedPubKey); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := wire.WriteVarBytes(w, 0, sd.SingleTweak); err != nil {\n\t\treturn err\n\t}\n\n\tvar doubleTweakBytes []byte\n\tif sd.DoubleTweak != nil {\n\t\tdoubleTweakBytes = sd.DoubleTweak.Serialize()\n\t}\n\tif err := wire.WriteVarBytes(w, 0, doubleTweakBytes); err != nil {\n\t\treturn err\n\t}\n\n\tif err := wire.WriteVarBytes(w, 0, sd.WitnessScript); err != nil {\n\t\treturn err\n\t}\n\n\tif err := writeTxOut(w, sd.Output); err != nil {\n\t\treturn err\n\t}\n\n\tvar scratch [4]byte\n\tbinary.BigEndian.PutUint32(scratch[:], uint32(sd.HashType))\n\tif _, err := w.Write(scratch[:]); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// ReadSignDescriptor deserializes a SignDescriptor struct from the passed\n// io.Reader stream.",
      "length": 1106,
      "tokens": 158,
      "embedding": []
    },
    {
      "slug": "func ReadSignDescriptor(r io.Reader, sd *SignDescriptor) error {",
      "content": "func ReadSignDescriptor(r io.Reader, sd *SignDescriptor) error {\n\terr := binary.Read(r, binary.BigEndian, &sd.KeyDesc.Family)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = binary.Read(r, binary.BigEndian, &sd.KeyDesc.Index)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar hasKey bool\n\terr = binary.Read(r, binary.BigEndian, &hasKey)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif hasKey {\n\t\tpubKeyBytes, err := wire.ReadVarBytes(r, 0, 34, \"pubkey\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsd.KeyDesc.PubKey, err = btcec.ParsePubKey(pubKeyBytes)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tsingleTweak, err := wire.ReadVarBytes(r, 0, 32, \"singleTweak\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Serializing a SignDescriptor with a nil-valued SingleTweak results\n\t// in deserializing a zero-length slice. Since a nil-valued SingleTweak\n\t// has special meaning and a zero-length slice for a SingleTweak is\n\t// invalid, we can use the zero-length slice as the flag for a\n\t// nil-valued SingleTweak.\n\tif len(singleTweak) == 0 {\n\t\tsd.SingleTweak = nil\n\t} else {\n\t\tsd.SingleTweak = singleTweak\n\t}\n\n\tdoubleTweakBytes, err := wire.ReadVarBytes(r, 0, 32, \"doubleTweak\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Serializing a SignDescriptor with a nil-valued DoubleTweak results\n\t// in deserializing a zero-length slice. Since a nil-valued DoubleTweak\n\t// has special meaning and a zero-length slice for a DoubleTweak is\n\t// invalid, we can use the zero-length slice as the flag for a\n\t// nil-valued DoubleTweak.\n\tif len(doubleTweakBytes) == 0 {\n\t\tsd.DoubleTweak = nil\n\t} else {\n\t\tsd.DoubleTweak, _ = btcec.PrivKeyFromBytes(doubleTweakBytes)\n\t}\n\n\t// Only one tweak should ever be set, fail if both are present.\n\tif sd.SingleTweak != nil && sd.DoubleTweak != nil {\n\t\treturn ErrTweakOverdose\n\t}\n\n\twitnessScript, err := wire.ReadVarBytes(r, 0, 500, \"witnessScript\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tsd.WitnessScript = witnessScript\n\n\ttxOut := &wire.TxOut{}\n\tif err := readTxOut(r, txOut); err != nil {\n\t\treturn err\n\t}\n\tsd.Output = txOut\n\n\tvar hashType [4]byte\n\tif _, err := io.ReadFull(r, hashType[:]); err != nil {\n\t\treturn err\n\t}\n\tsd.HashType = txscript.SigHashType(binary.BigEndian.Uint32(hashType[:]))\n\n\treturn nil\n}\n",
      "length": 2024,
      "tokens": 311,
      "embedding": []
    }
  ]
}