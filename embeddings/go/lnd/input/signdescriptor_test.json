{
  "filepath": "../implementations/go/lnd/input/signdescriptor_test.go",
  "package": "input",
  "sections": [
    {
      "slug": "func TestSignDescriptorSerialization(t *testing.T) {",
      "content": "func TestSignDescriptorSerialization(t *testing.T) {\n\tkeys := [][]byte{\n\t\t{0x04, 0x11, 0xdb, 0x93, 0xe1, 0xdc, 0xdb, 0x8a,\n\t\t\t0x01, 0x6b, 0x49, 0x84, 0x0f, 0x8c, 0x53, 0xbc, 0x1e,\n\t\t\t0xb6, 0x8a, 0x38, 0x2e, 0x97, 0xb1, 0x48, 0x2e, 0xca,\n\t\t\t0xd7, 0xb1, 0x48, 0xa6, 0x90, 0x9a, 0x5c, 0xb2, 0xe0,\n\t\t\t0xea, 0xdd, 0xfb, 0x84, 0xcc, 0xf9, 0x74, 0x44, 0x64,\n\t\t\t0xf8, 0x2e, 0x16, 0x0b, 0xfa, 0x9b, 0x8b, 0x64, 0xf9,\n\t\t\t0xd4, 0xc0, 0x3f, 0x99, 0x9b, 0x86, 0x43, 0xf6, 0x56,\n\t\t\t0xb4, 0x12, 0xa3,\n\t\t},\n\t\t{0x04, 0x11, 0xdb, 0x93, 0xe1, 0xdc, 0xdb, 0x8a,\n\t\t\t0x01, 0x6b, 0x49, 0x84, 0x0f, 0x8c, 0x53, 0xbc, 0x1e,\n\t\t\t0xb6, 0x8a, 0x38, 0x2e, 0x97, 0xb1, 0x48, 0x2e, 0xca,\n\t\t\t0xd7, 0xb1, 0x48, 0xa6, 0x90, 0x9a, 0x5c, 0xb2, 0xe0,\n\t\t\t0xea, 0xdd, 0xfb, 0x84, 0xcc, 0xf9, 0x74, 0x44, 0x64,\n\t\t\t0xf8, 0x2e, 0x16, 0x0b, 0xfa, 0x9b, 0x8b, 0x64, 0xf9,\n\t\t\t0xd4, 0xc0, 0x3f, 0x99, 0x9b, 0x86, 0x43, 0xf6, 0x56,\n\t\t\t0xb4, 0x12, 0xa3,\n\t\t},\n\t}\n\n\tsignDescriptors := []SignDescriptor{\n\t\t{\n\t\t\tSingleTweak: []byte{\n\t\t\t\t0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,\n\t\t\t\t0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,\n\t\t\t\t0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,\n\t\t\t\t0x02, 0x02, 0x02, 0x02, 0x02,\n\t\t\t},\n\t\t\tWitnessScript: []byte{\n\t\t\t\t0x00, 0x14, 0xee, 0x91, 0x41, 0x7e, 0x85, 0x6c, 0xde,\n\t\t\t\t0x10, 0xa2, 0x91, 0x1e, 0xdc, 0xbd, 0xbd, 0x69, 0xe2,\n\t\t\t\t0xef, 0xb5, 0x71, 0x48,\n\t\t\t},\n\t\t\tOutput: &wire.TxOut{\n\t\t\t\tValue: 5000000000,\n\t\t\t\tPkScript: []byte{\n\t\t\t\t\t0x41, // OP_DATA_65\n\t\t\t\t\t0x04, 0xd6, 0x4b, 0xdf, 0xd0, 0x9e, 0xb1, 0xc5,\n\t\t\t\t\t0xfe, 0x29, 0x5a, 0xbd, 0xeb, 0x1d, 0xca, 0x42,\n\t\t\t\t\t0x81, 0xbe, 0x98, 0x8e, 0x2d, 0xa0, 0xb6, 0xc1,\n\t\t\t\t\t0xc6, 0xa5, 0x9d, 0xc2, 0x26, 0xc2, 0x86, 0x24,\n\t\t\t\t\t0xe1, 0x81, 0x75, 0xe8, 0x51, 0xc9, 0x6b, 0x97,\n\t\t\t\t\t0x3d, 0x81, 0xb0, 0x1c, 0xc3, 0x1f, 0x04, 0x78,\n\t\t\t\t\t0x34, 0xbc, 0x06, 0xd6, 0xd6, 0xed, 0xf6, 0x20,\n\t\t\t\t\t0xd1, 0x84, 0x24, 0x1a, 0x6a, 0xed, 0x8b, 0x63,\n\t\t\t\t\t0xa6, // 65-byte signature\n\t\t\t\t\t0xac, // OP_CHECKSIG\n\t\t\t\t},\n\t\t\t},\n\t\t\tHashType: txscript.SigHashAll,\n\t\t},\n\n\t\t// Test serializing a SignDescriptor with a nil-valued PrivateTweak\n\t\t{\n\t\t\tSingleTweak: nil,\n\t\t\tWitnessScript: []byte{\n\t\t\t\t0x00, 0x14, 0xee, 0x91, 0x41, 0x7e, 0x85, 0x6c, 0xde,\n\t\t\t\t0x10, 0xa2, 0x91, 0x1e, 0xdc, 0xbd, 0xbd, 0x69, 0xe2,\n\t\t\t\t0xef, 0xb5, 0x71, 0x48,\n\t\t\t},\n\t\t\tOutput: &wire.TxOut{\n\t\t\t\tValue: 5000000000,\n\t\t\t\tPkScript: []byte{\n\t\t\t\t\t0x41, // OP_DATA_65\n\t\t\t\t\t0x04, 0xd6, 0x4b, 0xdf, 0xd0, 0x9e, 0xb1, 0xc5,\n\t\t\t\t\t0xfe, 0x29, 0x5a, 0xbd, 0xeb, 0x1d, 0xca, 0x42,\n\t\t\t\t\t0x81, 0xbe, 0x98, 0x8e, 0x2d, 0xa0, 0xb6, 0xc1,\n\t\t\t\t\t0xc6, 0xa5, 0x9d, 0xc2, 0x26, 0xc2, 0x86, 0x24,\n\t\t\t\t\t0xe1, 0x81, 0x75, 0xe8, 0x51, 0xc9, 0x6b, 0x97,\n\t\t\t\t\t0x3d, 0x81, 0xb0, 0x1c, 0xc3, 0x1f, 0x04, 0x78,\n\t\t\t\t\t0x34, 0xbc, 0x06, 0xd6, 0xd6, 0xed, 0xf6, 0x20,\n\t\t\t\t\t0xd1, 0x84, 0x24, 0x1a, 0x6a, 0xed, 0x8b, 0x63,\n\t\t\t\t\t0xa6, // 65-byte signature\n\t\t\t\t\t0xac, // OP_CHECKSIG\n\t\t\t\t},\n\t\t\t},\n\t\t\tHashType: txscript.SigHashAll,\n\t\t},\n\t}\n\n\tfor i := 0; i < len(signDescriptors); i++ {\n\t\t// Parse pubkeys for each sign descriptor.\n\t\tsd := &signDescriptors[i]\n\t\tpubkey, err := btcec.ParsePubKey(keys[i])\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to parse pubkey: %v\", err)\n\t\t}\n\t\tsd.KeyDesc = keychain.KeyDescriptor{\n\t\t\tKeyLocator: keychain.KeyLocator{\n\t\t\t\tFamily: 50,\n\t\t\t\tIndex:  99,\n\t\t\t},\n\t\t\tPubKey: pubkey,\n\t\t}\n\n\t\t// Test that serialize -> deserialize yields same result as original.\n\t\tvar buf bytes.Buffer\n\t\tif err := WriteSignDescriptor(&buf, sd); err != nil {\n\t\t\tt.Fatalf(\"unable to serialize sign descriptor[%v]: %v\", i, sd)\n\t\t}\n\n\t\tdesSd := &SignDescriptor{}\n\t\tif err := ReadSignDescriptor(&buf, desSd); err != nil {\n\t\t\tt.Fatalf(\"unable to deserialize sign descriptor[%v]: %v\", i, sd)\n\t\t}\n\n\t\tif !reflect.DeepEqual(sd, desSd) {\n\t\t\tt.Fatalf(\"original and deserialized sign descriptors not equal:\\n\"+\n\t\t\t\t\"original     : %+v\\n\"+\n\t\t\t\t\"deserialized : %+v\\n\",\n\t\t\t\tsd, desSd)\n\t\t}\n\t}\n}\n",
      "length": 3672,
      "tokens": 531,
      "embedding": []
    }
  ]
}