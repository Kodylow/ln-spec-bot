{
  "filepath": "../implementations/go/lnd/input/script_utils_test.go",
  "package": "input",
  "sections": [
    {
      "slug": "func assertEngineExecution(t *testing.T, testNum int, valid bool,",
      "content": "func assertEngineExecution(t *testing.T, testNum int, valid bool,\n\tnewEngine func() (*txscript.Engine, error)) {\n\n\tt.Helper()\n\n\t// Get a new VM to execute.\n\tvm, err := newEngine()\n\trequire.NoError(t, err, \"unable to create engine\")\n\n\t// Execute the VM, only go on to the step-by-step execution if\n\t// it doesn't validate as expected.\n\tvmErr := vm.Execute()\n\tif valid == (vmErr == nil) {\n\t\treturn\n\t}\n\n\t// Now that the execution didn't match what we expected, fetch a new VM\n\t// to step through.\n\tvm, err = newEngine()\n\trequire.NoError(t, err, \"unable to create engine\")\n\n\t// This buffer will trace execution of the Script, dumping out\n\t// to stdout.\n\tvar debugBuf bytes.Buffer\n\n\tdone := false\n\tfor !done {\n\t\tdis, err := vm.DisasmPC()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"stepping (%v)\\n\", err)\n\t\t}\n\t\tdebugBuf.WriteString(fmt.Sprintf(\"stepping %v\\n\", dis))\n\n\t\tdone, err = vm.Step()\n\t\tif err != nil && valid {\n\t\t\tt.Log(debugBuf.String())\n\t\t\tt.Fatalf(\"spend test case #%v failed, spend \"+\n\t\t\t\t\"should be valid: %v\", testNum, err)\n\t\t} else if err == nil && !valid && done {\n\t\t\tt.Log(debugBuf.String())\n\t\t\tt.Fatalf(\"spend test case #%v succeed, spend \"+\n\t\t\t\t\"should be invalid: %v\", testNum, err)\n\t\t}\n\n\t\tdebugBuf.WriteString(fmt.Sprintf(\"Stack: %v\", vm.GetStack()))\n\t\tdebugBuf.WriteString(fmt.Sprintf(\"AltStack: %v\", vm.GetAltStack()))\n\t}\n\n\t// If we get to this point the unexpected case was not reached\n\t// during step execution, which happens for some checks, like\n\t// the clean-stack rule.\n\tvalidity := \"invalid\"\n\tif valid {\n\t\tvalidity = \"valid\"\n\t}\n\n\tt.Log(debugBuf.String())\n\tt.Fatalf(\"%v spend test case #%v execution ended with: %v\", validity, testNum, vmErr)\n}\n\n// TestRevocationKeyDerivation tests that given a public key, and a revocation\n// hash, the homomorphic revocation public and private key derivation work\n// properly.",
      "length": 1696,
      "tokens": 253,
      "embedding": []
    },
    {
      "slug": "func TestRevocationKeyDerivation(t *testing.T) {",
      "content": "func TestRevocationKeyDerivation(t *testing.T) {\n\tt.Parallel()\n\n\t// First, we'll generate a commitment point, and a commitment secret.\n\t// These will be used to derive the ultimate revocation keys.\n\trevocationPreimage := testHdSeed.CloneBytes()\n\tcommitSecret, commitPoint := btcec.PrivKeyFromBytes(revocationPreimage)\n\n\t// With the commitment secrets generated, we'll now create the base\n\t// keys we'll use to derive the revocation key from.\n\tbasePriv, basePub := btcec.PrivKeyFromBytes(testWalletPrivKey)\n\n\t// With the point and key obtained, we can now derive the revocation\n\t// key itself.\n\trevocationPub := DeriveRevocationPubkey(basePub, commitPoint)\n\n\t// The revocation public key derived from the original public key, and\n\t// the one derived from the private key should be identical.\n\trevocationPriv := DeriveRevocationPrivKey(basePriv, commitSecret)\n\tif !revocationPub.IsEqual(revocationPriv.PubKey()) {\n\t\tt.Fatalf(\"derived public keys don't match!\")\n\t}\n}\n\n// TestTweakKeyDerivation tests that given a public key, and commitment tweak,\n// then we're able to properly derive a tweaked private key that corresponds to\n// the computed tweak public key. This scenario ensure that our key derivation\n// for any of the non revocation keys on the commitment transaction is correct.",
      "length": 1207,
      "tokens": 164,
      "embedding": []
    },
    {
      "slug": "func TestTweakKeyDerivation(t *testing.T) {",
      "content": "func TestTweakKeyDerivation(t *testing.T) {\n\tt.Parallel()\n\n\t// First, we'll generate a base public key that we'll be \"tweaking\".\n\tbaseSecret := testHdSeed.CloneBytes()\n\tbasePriv, basePub := btcec.PrivKeyFromBytes(baseSecret)\n\n\t// With the base key create, we'll now create a commitment point, and\n\t// from that derive the bytes we'll used to tweak the base public key.\n\tcommitPoint := ComputeCommitmentPoint(bobsPrivKey)\n\tcommitTweak := SingleTweakBytes(commitPoint, basePub)\n\n\t// Next, we'll modify the public key. When we apply the same operation\n\t// to the private key we should get a key that matches.\n\ttweakedPub := TweakPubKey(basePub, commitPoint)\n\n\t// Finally, attempt to re-generate the private key that matches the\n\t// tweaked public key. The derived key should match exactly.\n\tderivedPriv := TweakPrivKey(basePriv, commitTweak)\n\tif !derivedPriv.PubKey().IsEqual(tweakedPub) {\n\t\tt.Fatalf(\"pub keys don't match\")\n\t}\n}\n\n// makeWitnessTestCase is a helper function used within test cases involving\n// the validity of a crafted witness. This function is a wrapper function which\n// allows constructing table-driven tests. In the case of an error while\n// constructing the witness, the test fails fatally.",
      "length": 1140,
      "tokens": 162,
      "embedding": []
    },
    {
      "slug": "func makeWitnessTestCase(t *testing.T,",
      "content": "func makeWitnessTestCase(t *testing.T,\n\tf func() (wire.TxWitness, error)) func() wire.TxWitness {\n\n\treturn func() wire.TxWitness {\n\t\twitness, err := f()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to create witness test case: %v\", err)\n\t\t}\n\n\t\treturn witness\n\t}\n}\n\n// TestHTLCSenderSpendValidation tests all possible valid+invalid redemption\n// paths in the script used within the sender's commitment transaction for an\n// outgoing HTLC.\n//\n// The following cases are exercised by this test:\n// sender script:\n//   - receiver spends\n//   - revoke w/ sig\n//   - HTLC with invalid preimage size\n//   - HTLC with valid preimage size + sig\n//   - sender spends\n//   - invalid lock-time for CLTV\n//   - invalid sequence for CSV\n//   - valid lock-time+sequence, valid sig",
      "length": 694,
      "tokens": 116,
      "embedding": []
    },
    {
      "slug": "func TestHTLCSenderSpendValidation(t *testing.T) {",
      "content": "func TestHTLCSenderSpendValidation(t *testing.T) {\n\tt.Parallel()\n\n\t// We generate a fake output, and the corresponding txin. This output\n\t// doesn't need to exist, as we'll only be validating spending from the\n\t// transaction that references this.\n\ttxid, err := chainhash.NewHash(testHdSeed.CloneBytes())\n\trequire.NoError(t, err, \"unable to create txid\")\n\tfundingOut := &wire.OutPoint{\n\t\tHash:  *txid,\n\t\tIndex: 50,\n\t}\n\tfakeFundingTxIn := wire.NewTxIn(fundingOut, nil, nil)\n\n\t// Next we'll the commitment secret for our commitment tx and also the\n\t// revocation key that we'll use as well.\n\trevokePreimage := testHdSeed.CloneBytes()\n\tcommitSecret, commitPoint := btcec.PrivKeyFromBytes(revokePreimage)\n\n\t// Generate a payment preimage to be used below.\n\tpaymentPreimage := revokePreimage\n\tpaymentPreimage[0] ^= 1\n\tpaymentHash := sha256.Sum256(paymentPreimage[:])\n\n\t// We'll also need some tests keys for alice and bob, and metadata of\n\t// the HTLC output.\n\taliceKeyPriv, aliceKeyPub := btcec.PrivKeyFromBytes(testWalletPrivKey)\n\tbobKeyPriv, bobKeyPub := btcec.PrivKeyFromBytes(bobsPrivKey)\n\tpaymentAmt := btcutil.Amount(1 * 10e8)\n\n\taliceLocalKey := TweakPubKey(aliceKeyPub, commitPoint)\n\tbobLocalKey := TweakPubKey(bobKeyPub, commitPoint)\n\n\t// As we'll be modeling spends from Alice's commitment transaction,\n\t// we'll be using Bob's base point for the revocation key.\n\trevocationKey := DeriveRevocationPubkey(bobKeyPub, commitPoint)\n\n\tbobCommitTweak := SingleTweakBytes(commitPoint, bobKeyPub)\n\taliceCommitTweak := SingleTweakBytes(commitPoint, aliceKeyPub)\n\n\t// Finally, we'll create mock signers for both of them based on their\n\t// private keys. This test simplifies a bit and uses the same key as\n\t// the base point for all scripts and derivations.\n\tbobSigner := &MockSigner{Privkeys: []*btcec.PrivateKey{bobKeyPriv}}\n\taliceSigner := &MockSigner{Privkeys: []*btcec.PrivateKey{aliceKeyPriv}}\n\n\tvar (\n\t\thtlcWitnessScript, htlcPkScript []byte\n\t\thtlcOutput                      *wire.TxOut\n\t\tsweepTxSigHashes                *txscript.TxSigHashes\n\t\tsenderCommitTx, sweepTx         *wire.MsgTx\n\t\tbobRecvrSig                     *ecdsa.Signature\n\t\tbobSigHash                      txscript.SigHashType\n\t)\n\n\t// genCommitTx generates a commitment tx where the htlc output requires\n\t// confirmation to be spent according to 'confirmed'.\n\tgenCommitTx := func(confirmed bool) {\n\t\t// Generate the raw HTLC redemption scripts, and its p2wsh\n\t\t// counterpart.\n\t\thtlcWitnessScript, err = SenderHTLCScript(\n\t\t\taliceLocalKey, bobLocalKey, revocationKey,\n\t\t\tpaymentHash[:], confirmed,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to create htlc sender script: %v\", err)\n\t\t}\n\t\thtlcPkScript, err = WitnessScriptHash(htlcWitnessScript)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to create p2wsh htlc script: %v\", err)\n\t\t}\n\n\t\t// This will be Alice's commitment transaction. In this\n\t\t// scenario Alice is sending an HTLC to a node she has a path\n\t\t// to (could be Bob, could be multiple hops down, it doesn't\n\t\t// really matter).\n\t\thtlcOutput = &wire.TxOut{\n\t\t\tValue:    int64(paymentAmt),\n\t\t\tPkScript: htlcPkScript,\n\t\t}\n\t\tsenderCommitTx = wire.NewMsgTx(2)\n\t\tsenderCommitTx.AddTxIn(fakeFundingTxIn)\n\t\tsenderCommitTx.AddTxOut(htlcOutput)\n\t}\n\n\t// genSweepTx generates a sweep of the senderCommitTx, and sets the\n\t// sequence and sighash single|anyonecanspend if confirmed is true.\n\tgenSweepTx := func(confirmed bool) {\n\t\tprevOut := &wire.OutPoint{\n\t\t\tHash:  senderCommitTx.TxHash(),\n\t\t\tIndex: 0,\n\t\t}\n\n\t\tsweepTx = wire.NewMsgTx(2)\n\n\t\tsweepTx.AddTxIn(wire.NewTxIn(prevOut, nil, nil))\n\t\tif confirmed {\n\t\t\tsweepTx.TxIn[0].Sequence = LockTimeToSequence(false, 1)\n\t\t}\n\n\t\tsweepTx.AddTxOut(\n\t\t\t&wire.TxOut{\n\t\t\t\tPkScript: []byte(\"doesn't matter\"),\n\t\t\t\tValue:    1 * 10e8,\n\t\t\t},\n\t\t)\n\n\t\tsweepTxSigHashes = NewTxSigHashesV0Only(sweepTx)\n\n\t\tbobSigHash = txscript.SigHashAll\n\t\tif confirmed {\n\t\t\tbobSigHash = txscript.SigHashSingle | txscript.SigHashAnyOneCanPay\n\t\t}\n\n\t\t// We'll also generate a signature on the sweep transaction above\n\t\t// that will act as Bob's signature to Alice for the second level HTLC\n\t\t// transaction.\n\t\tbobSignDesc := SignDescriptor{\n\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\tPubKey: bobKeyPub,\n\t\t\t},\n\t\t\tSingleTweak:   bobCommitTweak,\n\t\t\tWitnessScript: htlcWitnessScript,\n\t\t\tOutput:        htlcOutput,\n\t\t\tHashType:      bobSigHash,\n\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\tInputIndex:    0,\n\t\t}\n\t\tbobSig, err := bobSigner.SignOutputRaw(sweepTx, &bobSignDesc)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to generate alice signature: %v\", err)\n\t\t}\n\n\t\tbobRecvrSig, err = ecdsa.ParseDERSignature(bobSig.Serialize())\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to parse signature: %v\", err)\n\t\t}\n\t}\n\n\ttestCases := []struct {\n\t\twitness func() wire.TxWitness\n\t\tvalid   bool\n\t}{\n\t\t{\n\t\t\t// revoke w/ sig\n\t\t\t// TODO(roasbeef): test invalid revoke\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\tgenCommitTx(false)\n\t\t\t\tgenSweepTx(false)\n\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: bobKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tDoubleTweak:   commitSecret,\n\t\t\t\t\tWitnessScript: htlcWitnessScript,\n\t\t\t\t\tOutput:        htlcOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn SenderHtlcSpendRevokeWithKey(bobSigner, signDesc,\n\t\t\t\t\trevocationKey, sweepTx)\n\t\t\t}),\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t// HTLC with invalid preimage size\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\tgenCommitTx(false)\n\t\t\t\tgenSweepTx(false)\n\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: bobKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tSingleTweak:   bobCommitTweak,\n\t\t\t\t\tWitnessScript: htlcWitnessScript,\n\t\t\t\t\tOutput:        htlcOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn SenderHtlcSpendRedeem(bobSigner, signDesc,\n\t\t\t\t\tsweepTx,\n\t\t\t\t\t// Invalid preimage length\n\t\t\t\t\tbytes.Repeat([]byte{1}, 45))\n\t\t\t}),\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t// HTLC with valid preimage size + sig\n\t\t\t// TODO(roasbeef): invalid preimage\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\tgenCommitTx(false)\n\t\t\t\tgenSweepTx(false)\n\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: bobKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tSingleTweak:   bobCommitTweak,\n\t\t\t\t\tWitnessScript: htlcWitnessScript,\n\t\t\t\t\tOutput:        htlcOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn SenderHtlcSpendRedeem(bobSigner, signDesc,\n\t\t\t\t\tsweepTx, paymentPreimage)\n\t\t\t}),\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t// HTLC with valid preimage size + sig, and with\n\t\t\t// enforced locktime in HTLC script.\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\t// Make a commit tx that needs confirmation for\n\t\t\t\t// HTLC output to be spent.\n\t\t\t\tgenCommitTx(true)\n\n\t\t\t\t// Generate a sweep with the locktime set.\n\t\t\t\tgenSweepTx(true)\n\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: bobKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tSingleTweak:   bobCommitTweak,\n\t\t\t\t\tWitnessScript: htlcWitnessScript,\n\t\t\t\t\tOutput:        htlcOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn SenderHtlcSpendRedeem(bobSigner, signDesc,\n\t\t\t\t\tsweepTx, paymentPreimage)\n\t\t\t}),\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t// HTLC with valid preimage size + sig, but trying to\n\t\t\t// spend CSV output without sequence set.\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\t// Generate commitment tx with 1 CSV locked\n\t\t\t\t// HTLC.\n\t\t\t\tgenCommitTx(true)\n\n\t\t\t\t// Generate sweep tx that doesn't have locktime\n\t\t\t\t// enabled.\n\t\t\t\tgenSweepTx(false)\n\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: bobKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tSingleTweak:   bobCommitTweak,\n\t\t\t\t\tWitnessScript: htlcWitnessScript,\n\t\t\t\t\tOutput:        htlcOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn SenderHtlcSpendRedeem(bobSigner, signDesc,\n\t\t\t\t\tsweepTx, paymentPreimage)\n\t\t\t}),\n\t\t\tfalse,\n\t\t},\n\n\t\t{\n\t\t\t// valid spend to the transition the state of the HTLC\n\t\t\t// output with the second level HTLC timeout\n\t\t\t// transaction.\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\tgenCommitTx(false)\n\t\t\t\tgenSweepTx(false)\n\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: aliceKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tSingleTweak:   aliceCommitTweak,\n\t\t\t\t\tWitnessScript: htlcWitnessScript,\n\t\t\t\t\tOutput:        htlcOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn SenderHtlcSpendTimeout(\n\t\t\t\t\tbobRecvrSig, bobSigHash, aliceSigner,\n\t\t\t\t\tsignDesc, sweepTx,\n\t\t\t\t)\n\t\t\t}),\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t// valid spend to the transition the state of the HTLC\n\t\t\t// output with the second level HTLC timeout\n\t\t\t// transaction.\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\t// Make a commit tx that needs confirmation for\n\t\t\t\t// HTLC output to be spent.\n\t\t\t\tgenCommitTx(true)\n\n\t\t\t\t// Generate a sweep with the locktime set.\n\t\t\t\tgenSweepTx(true)\n\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: aliceKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tSingleTweak:   aliceCommitTweak,\n\t\t\t\t\tWitnessScript: htlcWitnessScript,\n\t\t\t\t\tOutput:        htlcOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn SenderHtlcSpendTimeout(\n\t\t\t\t\tbobRecvrSig, bobSigHash, aliceSigner,\n\t\t\t\t\tsignDesc, sweepTx,\n\t\t\t\t)\n\t\t\t}),\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t// valid spend to the transition the state of the HTLC\n\t\t\t// output with the second level HTLC timeout\n\t\t\t// transaction.\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\t// Generate commitment tx with 1 CSV locked\n\t\t\t\t// HTLC.\n\t\t\t\tgenCommitTx(true)\n\n\t\t\t\t// Generate sweep tx that doesn't have locktime\n\t\t\t\t// enabled.\n\t\t\t\tgenSweepTx(false)\n\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: aliceKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tSingleTweak:   aliceCommitTweak,\n\t\t\t\t\tWitnessScript: htlcWitnessScript,\n\t\t\t\t\tOutput:        htlcOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn SenderHtlcSpendTimeout(\n\t\t\t\t\tbobRecvrSig, bobSigHash, aliceSigner,\n\t\t\t\t\tsignDesc, sweepTx,\n\t\t\t\t)\n\t\t\t}),\n\t\t\tfalse,\n\t\t},\n\t}\n\n\t// TODO(roasbeef): set of cases to ensure able to sign w/ keypath and\n\t// not\n\n\tfor i, testCase := range testCases {\n\t\tsweepTx.TxIn[0].Witness = testCase.witness()\n\n\t\tnewEngine := func() (*txscript.Engine, error) {\n\t\t\treturn txscript.NewEngine(\n\t\t\t\thtlcPkScript, sweepTx, 0,\n\t\t\t\ttxscript.StandardVerifyFlags, nil, nil,\n\t\t\t\tint64(paymentAmt),\n\t\t\t\ttxscript.NewCannedPrevOutputFetcher(\n\t\t\t\t\thtlcPkScript, int64(paymentAmt),\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\tassertEngineExecution(t, i, testCase.valid, newEngine)\n\t}\n}\n\n// TestHTLCReceiverSpendValidation tests all possible valid+invalid redemption\n// paths in the script used within the receiver's commitment transaction for an\n// incoming HTLC.\n//\n// The following cases are exercised by this test:\n//   - receiver spends\n//     1. HTLC redemption w/ invalid preimage size\n//     2. HTLC redemption w/ invalid sequence\n//     3. HTLC redemption w/ valid preimage size\n//   - sender spends\n//     1. revoke w/ sig\n//     2. refund w/ invalid lock time\n//     3. refund w/ valid lock time",
      "length": 10994,
      "tokens": 1185,
      "embedding": []
    },
    {
      "slug": "func TestHTLCReceiverSpendValidation(t *testing.T) {",
      "content": "func TestHTLCReceiverSpendValidation(t *testing.T) {\n\tt.Parallel()\n\n\t// We generate a fake output, and the corresponding txin. This output\n\t// doesn't need to exist, as we'll only be validating spending from the\n\t// transaction that references this.\n\ttxid, err := chainhash.NewHash(testHdSeed.CloneBytes())\n\trequire.NoError(t, err, \"unable to create txid\")\n\tfundingOut := &wire.OutPoint{\n\t\tHash:  *txid,\n\t\tIndex: 50,\n\t}\n\tfakeFundingTxIn := wire.NewTxIn(fundingOut, nil, nil)\n\n\t// Next we'll the commitment secret for our commitment tx and also the\n\t// revocation key that we'll use as well.\n\trevokePreimage := testHdSeed.CloneBytes()\n\tcommitSecret, commitPoint := btcec.PrivKeyFromBytes(revokePreimage)\n\n\t// Generate a payment preimage to be used below.\n\tpaymentPreimage := revokePreimage\n\tpaymentPreimage[0] ^= 1\n\tpaymentHash := sha256.Sum256(paymentPreimage[:])\n\n\t// We'll also need some tests keys for alice and bob, and metadata of\n\t// the HTLC output.\n\taliceKeyPriv, aliceKeyPub := btcec.PrivKeyFromBytes(testWalletPrivKey)\n\tbobKeyPriv, bobKeyPub := btcec.PrivKeyFromBytes(bobsPrivKey)\n\tpaymentAmt := btcutil.Amount(1 * 10e8)\n\tcltvTimeout := uint32(8)\n\n\taliceLocalKey := TweakPubKey(aliceKeyPub, commitPoint)\n\tbobLocalKey := TweakPubKey(bobKeyPub, commitPoint)\n\n\t// As we'll be modeling spends from Bob's commitment transaction, we'll\n\t// be using Alice's base point for the revocation key.\n\trevocationKey := DeriveRevocationPubkey(aliceKeyPub, commitPoint)\n\n\tbobCommitTweak := SingleTweakBytes(commitPoint, bobKeyPub)\n\taliceCommitTweak := SingleTweakBytes(commitPoint, aliceKeyPub)\n\n\t// Finally, we'll create mock signers for both of them based on their\n\t// private keys. This test simplifies a bit and uses the same key as\n\t// the base point for all scripts and derivations.\n\tbobSigner := &MockSigner{Privkeys: []*btcec.PrivateKey{bobKeyPriv}}\n\taliceSigner := &MockSigner{Privkeys: []*btcec.PrivateKey{aliceKeyPriv}}\n\n\tvar (\n\t\thtlcWitnessScript, htlcPkScript []byte\n\t\thtlcOutput                      *wire.TxOut\n\t\treceiverCommitTx, sweepTx       *wire.MsgTx\n\t\tsweepTxSigHashes                *txscript.TxSigHashes\n\t\taliceSenderSig                  *ecdsa.Signature\n\t\taliceSigHash                    txscript.SigHashType\n\t)\n\n\tgenCommitTx := func(confirmed bool) {\n\t\t// Generate the raw HTLC redemption scripts, and its p2wsh\n\t\t// counterpart.\n\t\thtlcWitnessScript, err = ReceiverHTLCScript(\n\t\t\tcltvTimeout, aliceLocalKey, bobLocalKey, revocationKey,\n\t\t\tpaymentHash[:], confirmed,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to create htlc sender script: %v\", err)\n\t\t}\n\t\thtlcPkScript, err = WitnessScriptHash(htlcWitnessScript)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to create p2wsh htlc script: %v\", err)\n\t\t}\n\n\t\t// This will be Bob's commitment transaction. In this scenario Alice is\n\t\t// sending an HTLC to a node she has a path to (could be Bob, could be\n\t\t// multiple hops down, it doesn't really matter).\n\t\thtlcOutput = &wire.TxOut{\n\t\t\tValue:    int64(paymentAmt),\n\t\t\tPkScript: htlcWitnessScript,\n\t\t}\n\n\t\treceiverCommitTx = wire.NewMsgTx(2)\n\t\treceiverCommitTx.AddTxIn(fakeFundingTxIn)\n\t\treceiverCommitTx.AddTxOut(htlcOutput)\n\t}\n\n\tgenSweepTx := func(confirmed bool) {\n\t\tprevOut := &wire.OutPoint{\n\t\t\tHash:  receiverCommitTx.TxHash(),\n\t\t\tIndex: 0,\n\t\t}\n\n\t\tsweepTx = wire.NewMsgTx(2)\n\t\tsweepTx.AddTxIn(&wire.TxIn{\n\t\t\tPreviousOutPoint: *prevOut,\n\t\t})\n\t\tif confirmed {\n\t\t\tsweepTx.TxIn[0].Sequence = LockTimeToSequence(false, 1)\n\t\t}\n\n\t\tsweepTx.AddTxOut(\n\t\t\t&wire.TxOut{\n\t\t\t\tPkScript: []byte(\"doesn't matter\"),\n\t\t\t\tValue:    1 * 10e8,\n\t\t\t},\n\t\t)\n\t\tsweepTxSigHashes = NewTxSigHashesV0Only(sweepTx)\n\n\t\taliceSigHash = txscript.SigHashAll\n\t\tif confirmed {\n\t\t\taliceSigHash = txscript.SigHashSingle | txscript.SigHashAnyOneCanPay\n\t\t}\n\n\t\t// We'll also generate a signature on the sweep transaction above\n\t\t// that will act as Alice's signature to Bob for the second level HTLC\n\t\t// transaction.\n\t\taliceSignDesc := SignDescriptor{\n\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\tPubKey: aliceKeyPub,\n\t\t\t},\n\t\t\tSingleTweak:   aliceCommitTweak,\n\t\t\tWitnessScript: htlcWitnessScript,\n\t\t\tOutput:        htlcOutput,\n\t\t\tHashType:      aliceSigHash,\n\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\tInputIndex:    0,\n\t\t}\n\t\taliceSig, err := aliceSigner.SignOutputRaw(sweepTx, &aliceSignDesc)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to generate alice signature: %v\", err)\n\t\t}\n\n\t\taliceSenderSig, err = ecdsa.ParseDERSignature(\n\t\t\taliceSig.Serialize(),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to parse signature: %v\", err)\n\t\t}\n\t}\n\n\t// TODO(roasbeef): modify valid to check precise script errors?\n\ttestCases := []struct {\n\t\twitness func() wire.TxWitness\n\t\tvalid   bool\n\t}{\n\t\t{\n\t\t\t// HTLC redemption w/ invalid preimage size\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\tgenCommitTx(false)\n\t\t\t\tgenSweepTx(false)\n\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: bobKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tSingleTweak:   bobCommitTweak,\n\t\t\t\t\tWitnessScript: htlcWitnessScript,\n\t\t\t\t\tOutput:        htlcOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn ReceiverHtlcSpendRedeem(\n\t\t\t\t\taliceSenderSig, aliceSigHash,\n\t\t\t\t\tbytes.Repeat([]byte{1}, 45), bobSigner,\n\t\t\t\t\tsignDesc, sweepTx,\n\t\t\t\t)\n\n\t\t\t}),\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t// HTLC redemption w/ valid preimage size\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\tgenCommitTx(false)\n\t\t\t\tgenSweepTx(false)\n\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: bobKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tSingleTweak:   bobCommitTweak,\n\t\t\t\t\tWitnessScript: htlcWitnessScript,\n\t\t\t\t\tOutput:        htlcOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn ReceiverHtlcSpendRedeem(\n\t\t\t\t\taliceSenderSig, aliceSigHash,\n\t\t\t\t\tpaymentPreimage, bobSigner,\n\t\t\t\t\tsignDesc, sweepTx,\n\t\t\t\t)\n\t\t\t}),\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t// revoke w/ sig\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\tgenCommitTx(false)\n\t\t\t\tgenSweepTx(false)\n\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: aliceKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tDoubleTweak:   commitSecret,\n\t\t\t\t\tWitnessScript: htlcWitnessScript,\n\t\t\t\t\tOutput:        htlcOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn ReceiverHtlcSpendRevokeWithKey(aliceSigner,\n\t\t\t\t\tsignDesc, revocationKey, sweepTx)\n\t\t\t}),\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t// HTLC redemption w/ valid preimage size, and with\n\t\t\t// enforced locktime in HTLC scripts.\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\t// Make a commit tx that needs confirmation for\n\t\t\t\t// HTLC output to be spent.\n\t\t\t\tgenCommitTx(true)\n\n\t\t\t\t// Generate a sweep with the locktime set.\n\t\t\t\tgenSweepTx(true)\n\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: bobKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tSingleTweak:   bobCommitTweak,\n\t\t\t\t\tWitnessScript: htlcWitnessScript,\n\t\t\t\t\tOutput:        htlcOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn ReceiverHtlcSpendRedeem(\n\t\t\t\t\taliceSenderSig, aliceSigHash,\n\t\t\t\t\tpaymentPreimage, bobSigner,\n\t\t\t\t\tsignDesc, sweepTx,\n\t\t\t\t)\n\t\t\t}),\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t// HTLC redemption w/ valid preimage size, but trying\n\t\t\t// to spend CSV output without sequence set.\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\t// Generate commitment tx with 1 CSV locked\n\t\t\t\t// HTLC.\n\t\t\t\tgenCommitTx(true)\n\n\t\t\t\t// Generate sweep tx that doesn't have locktime\n\t\t\t\t// enabled.\n\t\t\t\tgenSweepTx(false)\n\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: bobKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tSingleTweak:   bobCommitTweak,\n\t\t\t\t\tWitnessScript: htlcWitnessScript,\n\t\t\t\t\tOutput:        htlcOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn ReceiverHtlcSpendRedeem(\n\t\t\t\t\taliceSenderSig, aliceSigHash,\n\t\t\t\t\tpaymentPreimage, bobSigner, signDesc,\n\t\t\t\t\tsweepTx,\n\t\t\t\t)\n\t\t\t}),\n\t\t\tfalse,\n\t\t},\n\n\t\t{\n\t\t\t// refund w/ invalid lock time\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\tgenCommitTx(false)\n\t\t\t\tgenSweepTx(false)\n\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: aliceKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tSingleTweak:   aliceCommitTweak,\n\t\t\t\t\tWitnessScript: htlcWitnessScript,\n\t\t\t\t\tOutput:        htlcOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn ReceiverHtlcSpendTimeout(aliceSigner, signDesc,\n\t\t\t\t\tsweepTx, int32(cltvTimeout-2))\n\t\t\t}),\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t// refund w/ valid lock time\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\tgenCommitTx(false)\n\t\t\t\tgenSweepTx(false)\n\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: aliceKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tSingleTweak:   aliceCommitTweak,\n\t\t\t\t\tWitnessScript: htlcWitnessScript,\n\t\t\t\t\tOutput:        htlcOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn ReceiverHtlcSpendTimeout(aliceSigner, signDesc,\n\t\t\t\t\tsweepTx, int32(cltvTimeout))\n\t\t\t}),\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t// refund w/ valid lock time, and enforced locktime in\n\t\t\t// HTLC scripts.\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\t// Make a commit tx that needs confirmation for\n\t\t\t\t// HTLC output to be spent.\n\t\t\t\tgenCommitTx(true)\n\n\t\t\t\t// Generate a sweep with the locktime set.\n\t\t\t\tgenSweepTx(true)\n\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: aliceKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tSingleTweak:   aliceCommitTweak,\n\t\t\t\t\tWitnessScript: htlcWitnessScript,\n\t\t\t\t\tOutput:        htlcOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn ReceiverHtlcSpendTimeout(aliceSigner, signDesc,\n\t\t\t\t\tsweepTx, int32(cltvTimeout))\n\t\t\t}),\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t// refund w/ valid lock time, but no sequence set in\n\t\t\t// sweep tx trying to spend CSV locked HTLC output.\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\t// Generate commitment tx with 1 CSV locked\n\t\t\t\t// HTLC.\n\t\t\t\tgenCommitTx(true)\n\n\t\t\t\t// Generate sweep tx that doesn't have locktime\n\t\t\t\t// enabled.\n\t\t\t\tgenSweepTx(false)\n\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: aliceKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tSingleTweak:   aliceCommitTweak,\n\t\t\t\t\tWitnessScript: htlcWitnessScript,\n\t\t\t\t\tOutput:        htlcOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn ReceiverHtlcSpendTimeout(aliceSigner, signDesc,\n\t\t\t\t\tsweepTx, int32(cltvTimeout))\n\t\t\t}),\n\t\t\tfalse,\n\t\t},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tsweepTx.TxIn[0].Witness = testCase.witness()\n\n\t\tnewEngine := func() (*txscript.Engine, error) {\n\t\t\treturn txscript.NewEngine(\n\t\t\t\thtlcPkScript,\n\t\t\t\tsweepTx, 0, txscript.StandardVerifyFlags, nil,\n\t\t\t\tnil, int64(paymentAmt),\n\t\t\t\ttxscript.NewCannedPrevOutputFetcher(\n\t\t\t\t\thtlcPkScript, int64(paymentAmt),\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\tassertEngineExecution(t, i, testCase.valid, newEngine)\n\t}\n}\n\n// TestSecondLevelHtlcSpends tests all the possible redemption clauses from the\n// HTLC success and timeout covenant transactions.",
      "length": 10900,
      "tokens": 1092,
      "embedding": []
    },
    {
      "slug": "func TestSecondLevelHtlcSpends(t *testing.T) {",
      "content": "func TestSecondLevelHtlcSpends(t *testing.T) {\n\tt.Parallel()\n\n\t// We'll start be creating a creating a 2BTC HTLC.\n\tconst htlcAmt = btcutil.Amount(2 * 10e8)\n\n\t// In all of our scenarios, the CSV timeout to claim a self output will\n\t// be 5 blocks.\n\tconst claimDelay = 5\n\n\t// First we'll set up some initial key state for Alice and Bob that\n\t// will be used in the scripts we created below.\n\taliceKeyPriv, aliceKeyPub := btcec.PrivKeyFromBytes(testWalletPrivKey)\n\tbobKeyPriv, bobKeyPub := btcec.PrivKeyFromBytes(bobsPrivKey)\n\n\trevokePreimage := testHdSeed.CloneBytes()\n\tcommitSecret, commitPoint := btcec.PrivKeyFromBytes(revokePreimage)\n\n\t// As we're modeling this as Bob sweeping the HTLC on-chain from his\n\t// commitment transaction after a period of time, we'll be using a\n\t// revocation key derived from Alice's base point and his secret.\n\trevocationKey := DeriveRevocationPubkey(aliceKeyPub, commitPoint)\n\n\t// Next, craft a fake HTLC outpoint that we'll use to generate the\n\t// sweeping transaction using.\n\ttxid, err := chainhash.NewHash(testHdSeed.CloneBytes())\n\trequire.NoError(t, err, \"unable to create txid\")\n\thtlcOutPoint := &wire.OutPoint{\n\t\tHash:  *txid,\n\t\tIndex: 0,\n\t}\n\tsweepTx := wire.NewMsgTx(2)\n\tsweepTx.AddTxIn(wire.NewTxIn(htlcOutPoint, nil, nil))\n\tsweepTx.AddTxOut(\n\t\t&wire.TxOut{\n\t\t\tPkScript: []byte(\"doesn't matter\"),\n\t\t\tValue:    1 * 10e8,\n\t\t},\n\t)\n\tsweepTxSigHashes := NewTxSigHashesV0Only(sweepTx)\n\n\t// The delay key will be crafted using Bob's public key as the output\n\t// we created will be spending from Alice's commitment transaction.\n\tdelayKey := TweakPubKey(bobKeyPub, commitPoint)\n\n\t// The commit tweak will be required in order for Bob to derive the\n\t// proper key need to spend the output.\n\tcommitTweak := SingleTweakBytes(commitPoint, bobKeyPub)\n\n\t// Finally we'll generate the HTLC script itself that we'll be spending\n\t// from. The revocation clause can be claimed by Alice, while Bob can\n\t// sweep the output after a particular delay.\n\thtlcWitnessScript, err := SecondLevelHtlcScript(revocationKey,\n\t\tdelayKey, claimDelay)\n\trequire.NoError(t, err, \"unable to create htlc script\")\n\thtlcPkScript, err := WitnessScriptHash(htlcWitnessScript)\n\trequire.NoError(t, err, \"unable to create htlc output\")\n\n\thtlcOutput := &wire.TxOut{\n\t\tPkScript: htlcPkScript,\n\t\tValue:    int64(htlcAmt),\n\t}\n\n\t// TODO(roasbeef): make actually use timeout/success txns?\n\n\t// Finally, we'll create mock signers for both of them based on their\n\t// private keys. This test simplifies a bit and uses the same key as\n\t// the base point for all scripts and derivations.\n\tbobSigner := &MockSigner{Privkeys: []*btcec.PrivateKey{bobKeyPriv}}\n\taliceSigner := &MockSigner{Privkeys: []*btcec.PrivateKey{aliceKeyPriv}}\n\n\ttestCases := []struct {\n\t\twitness func() wire.TxWitness\n\t\tvalid   bool\n\t}{\n\t\t{\n\t\t\t// Sender of the HTLC attempts to activate the\n\t\t\t// revocation clause, but uses the wrong key (fails to\n\t\t\t// use the double tweak in this case).\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: aliceKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tWitnessScript: htlcWitnessScript,\n\t\t\t\t\tOutput:        htlcOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn HtlcSpendRevoke(aliceSigner, signDesc,\n\t\t\t\t\tsweepTx)\n\t\t\t}),\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t// Sender of HTLC activates the revocation clause.\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: aliceKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tDoubleTweak:   commitSecret,\n\t\t\t\t\tWitnessScript: htlcWitnessScript,\n\t\t\t\t\tOutput:        htlcOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn HtlcSpendRevoke(aliceSigner, signDesc,\n\t\t\t\t\tsweepTx)\n\t\t\t}),\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t// Receiver of the HTLC attempts to sweep, but tries to\n\t\t\t// do so pre-maturely with a smaller CSV delay (2\n\t\t\t// blocks instead of 5 blocks).\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: bobKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tSingleTweak:   commitTweak,\n\t\t\t\t\tWitnessScript: htlcWitnessScript,\n\t\t\t\t\tOutput:        htlcOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn HtlcSpendSuccess(bobSigner, signDesc,\n\t\t\t\t\tsweepTx, claimDelay-3)\n\t\t\t}),\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t// Receiver of the HTLC sweeps with the proper CSV\n\t\t\t// delay, but uses the wrong key (leaves off the single\n\t\t\t// tweak).\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: bobKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tWitnessScript: htlcWitnessScript,\n\t\t\t\t\tOutput:        htlcOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn HtlcSpendSuccess(bobSigner, signDesc,\n\t\t\t\t\tsweepTx, claimDelay)\n\t\t\t}),\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t// Receiver of the HTLC sweeps with the proper CSV\n\t\t\t// delay, and the correct key.\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: bobKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tSingleTweak:   commitTweak,\n\t\t\t\t\tWitnessScript: htlcWitnessScript,\n\t\t\t\t\tOutput:        htlcOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn HtlcSpendSuccess(bobSigner, signDesc,\n\t\t\t\t\tsweepTx, claimDelay)\n\t\t\t}),\n\t\t\ttrue,\n\t\t},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tsweepTx.TxIn[0].Witness = testCase.witness()\n\n\t\tnewEngine := func() (*txscript.Engine, error) {\n\t\t\treturn txscript.NewEngine(\n\t\t\t\thtlcPkScript,\n\t\t\t\tsweepTx, 0, txscript.StandardVerifyFlags, nil,\n\t\t\t\tnil, int64(htlcAmt),\n\t\t\t\ttxscript.NewCannedPrevOutputFetcher(\n\t\t\t\t\thtlcPkScript, int64(htlcAmt),\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\tassertEngineExecution(t, i, testCase.valid, newEngine)\n\t}\n}\n\n// TestLeaseSecondLevelHtlcSpends tests all the possible redemption clauses from\n// the HTLC success and timeout covenant transactions in script enforced lease\n// commitments.",
      "length": 6006,
      "tokens": 685,
      "embedding": []
    },
    {
      "slug": "func TestLeaseSecondLevelHtlcSpends(t *testing.T) {",
      "content": "func TestLeaseSecondLevelHtlcSpends(t *testing.T) {\n\tt.Parallel()\n\n\t// We'll start be creating a creating a 2BTC HTLC.\n\tconst htlcAmt = btcutil.Amount(2 * 10e8)\n\n\t// In all of our scenarios, the CSV timeout to claim a self output will\n\t// be 5 blocks.\n\tconst claimDelay = 5\n\n\t// In all of our scenarios, the CLTV timelock will expire at height\n\t// 1337.\n\tconst leaseExpiry = 1337\n\n\t// First we'll set up some initial key state for Alice and Bob that\n\t// will be used in the scripts we created below.\n\taliceKeyPriv, aliceKeyPub := btcec.PrivKeyFromBytes(testWalletPrivKey)\n\tbobKeyPriv, bobKeyPub := btcec.PrivKeyFromBytes(bobsPrivKey)\n\n\trevokePreimage := testHdSeed.CloneBytes()\n\tcommitSecret, commitPoint := btcec.PrivKeyFromBytes(revokePreimage)\n\n\t// As we're modeling this as Bob sweeping the HTLC on-chain from his\n\t// commitment transaction after a period of time, we'll be using a\n\t// revocation key derived from Alice's base point and his secret.\n\trevocationKey := DeriveRevocationPubkey(aliceKeyPub, commitPoint)\n\n\t// Next, craft a fake HTLC outpoint that we'll use to generate the\n\t// sweeping transaction using.\n\ttxid, err := chainhash.NewHash(testHdSeed.CloneBytes())\n\trequire.NoError(t, err)\n\thtlcOutPoint := &wire.OutPoint{\n\t\tHash:  *txid,\n\t\tIndex: 0,\n\t}\n\tsweepTx := wire.NewMsgTx(2)\n\tsweepTx.AddTxIn(wire.NewTxIn(htlcOutPoint, nil, nil))\n\tsweepTx.AddTxOut(\n\t\t&wire.TxOut{\n\t\t\tPkScript: []byte(\"doesn't matter\"),\n\t\t\tValue:    1 * 10e8,\n\t\t},\n\t)\n\tsweepTxSigHashes := NewTxSigHashesV0Only(sweepTx)\n\n\t// The delay key will be crafted using Bob's public key as the output\n\t// we created will be spending from Alice's commitment transaction.\n\tdelayKey := TweakPubKey(bobKeyPub, commitPoint)\n\n\t// The commit tweak will be required in order for Bob to derive the\n\t// proper key need to spend the output.\n\tcommitTweak := SingleTweakBytes(commitPoint, bobKeyPub)\n\n\t// Finally we'll generate the HTLC script itself that we'll be spending\n\t// from. The revocation clause can be claimed by Alice, while Bob can\n\t// sweep the output after a particular delay.\n\thtlcWitnessScript, err := LeaseSecondLevelHtlcScript(\n\t\trevocationKey, delayKey, claimDelay, leaseExpiry,\n\t)\n\trequire.NoError(t, err)\n\thtlcPkScript, err := WitnessScriptHash(htlcWitnessScript)\n\trequire.NoError(t, err)\n\n\thtlcOutput := &wire.TxOut{\n\t\tPkScript: htlcPkScript,\n\t\tValue:    int64(htlcAmt),\n\t}\n\n\t// Finally, we'll create mock signers for both of them based on their\n\t// private keys. This test simplifies a bit and uses the same key as\n\t// the base point for all scripts and derivations.\n\tbobSigner := &MockSigner{Privkeys: []*btcec.PrivateKey{bobKeyPriv}}\n\taliceSigner := &MockSigner{Privkeys: []*btcec.PrivateKey{aliceKeyPriv}}\n\n\ttestCases := []struct {\n\t\twitness func() wire.TxWitness\n\t\tvalid   bool\n\t}{\n\t\t{\n\t\t\t// Sender of the HTLC attempts to activate the\n\t\t\t// revocation clause, but uses the wrong key (fails to\n\t\t\t// use the double tweak in this case).\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: aliceKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tWitnessScript: htlcWitnessScript,\n\t\t\t\t\tOutput:        htlcOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn HtlcSpendRevoke(\n\t\t\t\t\taliceSigner, signDesc, sweepTx,\n\t\t\t\t)\n\t\t\t}),\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t// Sender of HTLC activates the revocation clause.\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: aliceKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tDoubleTweak:   commitSecret,\n\t\t\t\t\tWitnessScript: htlcWitnessScript,\n\t\t\t\t\tOutput:        htlcOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn HtlcSpendRevoke(\n\t\t\t\t\taliceSigner, signDesc, sweepTx,\n\t\t\t\t)\n\t\t\t}),\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t// Receiver of the HTLC attempts to sweep, but tries to\n\t\t\t// do so pre-maturely with a smaller CSV delay (2\n\t\t\t// blocks instead of 5 blocks), even after the CLTV\n\t\t\t// timelock expires.\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\tsweepTx.LockTime = leaseExpiry\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: bobKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tSingleTweak:   commitTweak,\n\t\t\t\t\tWitnessScript: htlcWitnessScript,\n\t\t\t\t\tOutput:        htlcOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn HtlcSpendSuccess(\n\t\t\t\t\tbobSigner, signDesc, sweepTx, claimDelay-3,\n\t\t\t\t)\n\t\t\t}),\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t// Receiver of the HTLC sweeps with the proper CSV delay\n\t\t\t// and after the CLTV timelock expires, but uses the\n\t\t\t// wrong key (leaves off the single tweak).\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\tsweepTx.LockTime = leaseExpiry\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: bobKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tWitnessScript: htlcWitnessScript,\n\t\t\t\t\tOutput:        htlcOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn HtlcSpendSuccess(\n\t\t\t\t\tbobSigner, signDesc, sweepTx, claimDelay,\n\t\t\t\t)\n\t\t\t}),\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t// Receiver of the HTLC sweeps with the proper CSV\n\t\t\t// delay, and the correct key, but before the CTLV\n\t\t\t// timelock expires.\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\tsweepTx.LockTime = 0\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: bobKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tSingleTweak:   commitTweak,\n\t\t\t\t\tWitnessScript: htlcWitnessScript,\n\t\t\t\t\tOutput:        htlcOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn HtlcSpendSuccess(\n\t\t\t\t\tbobSigner, signDesc, sweepTx, claimDelay,\n\t\t\t\t)\n\t\t\t}),\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t// Receiver of the HTLC sweeps with the proper CSV\n\t\t\t// delay, and the correct key after the CTLV timelock\n\t\t\t// expires.\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\tsweepTx.LockTime = leaseExpiry\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: bobKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tSingleTweak:   commitTweak,\n\t\t\t\t\tWitnessScript: htlcWitnessScript,\n\t\t\t\t\tOutput:        htlcOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn HtlcSpendSuccess(\n\t\t\t\t\tbobSigner, signDesc, sweepTx, claimDelay,\n\t\t\t\t)\n\t\t\t}),\n\t\t\ttrue,\n\t\t},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tsweepTx.TxIn[0].Witness = testCase.witness()\n\n\t\tnewEngine := func() (*txscript.Engine, error) {\n\t\t\treturn txscript.NewEngine(\n\t\t\t\thtlcPkScript, sweepTx, 0,\n\t\t\t\ttxscript.StandardVerifyFlags, nil, nil,\n\t\t\t\tint64(htlcAmt),\n\t\t\t\ttxscript.NewCannedPrevOutputFetcher(\n\t\t\t\t\thtlcPkScript, int64(htlcAmt),\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\tassertEngineExecution(t, i, testCase.valid, newEngine)\n\t}\n}\n\n// TestLeaseCommmitSpendToSelf tests all the possible redemption clauses from\n// the to_self output in a script enforced lease commitment transaction.",
      "length": 6822,
      "tokens": 784,
      "embedding": []
    },
    {
      "slug": "func TestLeaseCommmitSpendToSelf(t *testing.T) {",
      "content": "func TestLeaseCommmitSpendToSelf(t *testing.T) {\n\tt.Parallel()\n\n\tconst (\n\t\toutputVal   = btcutil.Amount(2 * 10e8)\n\t\tcsvDelay    = 5\n\t\tleaseExpiry = 1337\n\t)\n\n\t// Set up some initial key state for Alice and Bob that will be used in\n\t// the scripts we created below.\n\taliceKeyPriv, aliceKeyPub := btcec.PrivKeyFromBytes(testWalletPrivKey)\n\tbobKeyPriv, bobKeyPub := btcec.PrivKeyFromBytes(bobsPrivKey)\n\n\t// We'll have Bob take the revocation path in some cases.\n\trevokePreimage := testHdSeed.CloneBytes()\n\tcommitSecret, commitPoint := btcec.PrivKeyFromBytes(revokePreimage)\n\trevocationKey := DeriveRevocationPubkey(bobKeyPub, commitPoint)\n\n\t// Construct the script enforced lease to_self commitment transaction\n\t// output.\n\ttxid, err := chainhash.NewHash(testHdSeed.CloneBytes())\n\trequire.NoError(t, err)\n\tcommitOut := &wire.OutPoint{\n\t\tHash:  *txid,\n\t\tIndex: 0,\n\t}\n\tcommitScript, err := LeaseCommitScriptToSelf(\n\t\taliceKeyPub, revocationKey, csvDelay, leaseExpiry,\n\t)\n\trequire.NoError(t, err)\n\tcommitPkScript, err := WitnessScriptHash(commitScript)\n\trequire.NoError(t, err)\n\n\tcommitOutput := &wire.TxOut{\n\t\tPkScript: commitPkScript,\n\t\tValue:    int64(outputVal),\n\t}\n\n\tsweepTx := wire.NewMsgTx(2)\n\tsweepTx.AddTxIn(wire.NewTxIn(commitOut, nil, nil))\n\tsweepTx.AddTxOut(\n\t\t&wire.TxOut{\n\t\t\tPkScript: []byte(\"doesn't matter\"),\n\t\t\tValue:    1 * 10e8,\n\t\t},\n\t)\n\n\t// Create mock signers for both parties to ensure signatures are\n\t// produced and verified correctly.\n\taliceSigner := &MockSigner{Privkeys: []*btcec.PrivateKey{aliceKeyPriv}}\n\tbobSigner := &MockSigner{Privkeys: []*btcec.PrivateKey{bobKeyPriv}}\n\n\ttestCases := []struct {\n\t\twitness func() wire.TxWitness\n\t\tvalid   bool\n\t}{\n\t\t{\n\t\t\t// Bob can spend with his revocation key, but not\n\t\t\t// without the proper tweak.\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\tsweepTxSigHashes := NewTxSigHashesV0Only(sweepTx)\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: bobKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tWitnessScript: commitScript,\n\t\t\t\t\tOutput:        commitOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn CommitSpendRevoke(\n\t\t\t\t\tbobSigner, signDesc, sweepTx,\n\t\t\t\t)\n\t\t\t}),\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t// Bob can spend with his revocation key with the proper\n\t\t\t// tweak.\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\tsweepTxSigHashes := NewTxSigHashesV0Only(sweepTx)\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: bobKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tDoubleTweak:   commitSecret,\n\t\t\t\t\tWitnessScript: commitScript,\n\t\t\t\t\tOutput:        commitOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn CommitSpendRevoke(\n\t\t\t\t\tbobSigner, signDesc, sweepTx,\n\t\t\t\t)\n\t\t\t}),\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t// Alice cannot spend with the proper key before the CSV\n\t\t\t// delay and after the CLTV timelock has expired.\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\tsweepTx.LockTime = leaseExpiry\n\t\t\t\tsweepTx.TxIn[0].Sequence = LockTimeToSequence(\n\t\t\t\t\tfalse, csvDelay/2,\n\t\t\t\t)\n\t\t\t\tsweepTxSigHashes := NewTxSigHashesV0Only(sweepTx)\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: aliceKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tDoubleTweak:   commitSecret,\n\t\t\t\t\tWitnessScript: commitScript,\n\t\t\t\t\tOutput:        commitOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn CommitSpendTimeout(\n\t\t\t\t\taliceSigner, signDesc, sweepTx,\n\t\t\t\t)\n\t\t\t}),\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t// Alice cannot spend with the proper key after the CSV\n\t\t\t// delay and before the CLTV timelock has expired.\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\tsweepTx.LockTime = 0\n\t\t\t\tsweepTx.TxIn[0].Sequence = LockTimeToSequence(\n\t\t\t\t\tfalse, csvDelay,\n\t\t\t\t)\n\t\t\t\tsweepTxSigHashes := NewTxSigHashesV0Only(sweepTx)\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: aliceKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tDoubleTweak:   commitSecret,\n\t\t\t\t\tWitnessScript: commitScript,\n\t\t\t\t\tOutput:        commitOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn CommitSpendTimeout(\n\t\t\t\t\taliceSigner, signDesc, sweepTx,\n\t\t\t\t)\n\t\t\t}),\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t// Alice can spend with the proper key after the CSV\n\t\t\t// delay and CLTV timelock have expired.\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\tsweepTx.LockTime = leaseExpiry\n\t\t\t\tsweepTx.TxIn[0].Sequence = LockTimeToSequence(\n\t\t\t\t\tfalse, csvDelay,\n\t\t\t\t)\n\t\t\t\tsweepTxSigHashes := NewTxSigHashesV0Only(sweepTx)\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: aliceKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tWitnessScript: commitScript,\n\t\t\t\t\tOutput:        commitOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn CommitSpendTimeout(\n\t\t\t\t\taliceSigner, signDesc, sweepTx,\n\t\t\t\t)\n\t\t\t}),\n\t\t\ttrue,\n\t\t},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tsweepTx.TxIn[0].Witness = testCase.witness()\n\n\t\tnewEngine := func() (*txscript.Engine, error) {\n\t\t\treturn txscript.NewEngine(\n\t\t\t\tcommitPkScript,\n\t\t\t\tsweepTx, 0, txscript.StandardVerifyFlags, nil,\n\t\t\t\tnil, int64(outputVal),\n\t\t\t\ttxscript.NewCannedPrevOutputFetcher(\n\t\t\t\t\tcommitPkScript, int64(outputVal),\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\tassertEngineExecution(t, i, testCase.valid, newEngine)\n\t}\n}\n\n// TestCommitSpendToRemoteConfirmed checks that the delayed version of the\n// to_remote version can only be spent by the owner, and after one\n// confirmation.",
      "length": 5394,
      "tokens": 534,
      "embedding": []
    },
    {
      "slug": "func TestCommitSpendToRemoteConfirmed(t *testing.T) {",
      "content": "func TestCommitSpendToRemoteConfirmed(t *testing.T) {\n\tt.Parallel()\n\n\tconst outputVal = btcutil.Amount(2 * 10e8)\n\n\taliceKeyPriv, aliceKeyPub := btcec.PrivKeyFromBytes(testWalletPrivKey)\n\n\ttxid, err := chainhash.NewHash(testHdSeed.CloneBytes())\n\trequire.NoError(t, err, \"unable to create txid\")\n\tcommitOut := &wire.OutPoint{\n\t\tHash:  *txid,\n\t\tIndex: 0,\n\t}\n\tcommitScript, err := CommitScriptToRemoteConfirmed(aliceKeyPub)\n\trequire.NoError(t, err, \"unable to create htlc script\")\n\tcommitPkScript, err := WitnessScriptHash(commitScript)\n\trequire.NoError(t, err, \"unable to create htlc output\")\n\n\tcommitOutput := &wire.TxOut{\n\t\tPkScript: commitPkScript,\n\t\tValue:    int64(outputVal),\n\t}\n\n\tsweepTx := wire.NewMsgTx(2)\n\tsweepTx.AddTxIn(wire.NewTxIn(commitOut, nil, nil))\n\tsweepTx.AddTxOut(\n\t\t&wire.TxOut{\n\t\t\tPkScript: []byte(\"doesn't matter\"),\n\t\t\tValue:    1 * 10e8,\n\t\t},\n\t)\n\n\taliceSigner := &MockSigner{Privkeys: []*btcec.PrivateKey{aliceKeyPriv}}\n\n\ttestCases := []struct {\n\t\twitness func() wire.TxWitness\n\t\tvalid   bool\n\t}{\n\t\t{\n\t\t\t// Alice can spend after the a CSV delay has passed.\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\tsweepTx.TxIn[0].Sequence = LockTimeToSequence(false, 1)\n\t\t\t\tsweepTxSigHashes := NewTxSigHashesV0Only(sweepTx)\n\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: aliceKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tWitnessScript: commitScript,\n\t\t\t\t\tOutput:        commitOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn CommitSpendToRemoteConfirmed(aliceSigner, signDesc,\n\t\t\t\t\tsweepTx)\n\t\t\t}),\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t// Alice cannot spend output without sequence set.\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\tsweepTx.TxIn[0].Sequence = wire.MaxTxInSequenceNum\n\t\t\t\tsweepTxSigHashes := NewTxSigHashesV0Only(sweepTx)\n\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: aliceKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tWitnessScript: commitScript,\n\t\t\t\t\tOutput:        commitOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn CommitSpendToRemoteConfirmed(aliceSigner, signDesc,\n\t\t\t\t\tsweepTx)\n\t\t\t}),\n\t\t\tfalse,\n\t\t},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tsweepTx.TxIn[0].Witness = testCase.witness()\n\n\t\tnewEngine := func() (*txscript.Engine, error) {\n\t\t\treturn txscript.NewEngine(\n\t\t\t\tcommitPkScript, sweepTx, 0,\n\t\t\t\ttxscript.StandardVerifyFlags, nil, nil,\n\t\t\t\tint64(outputVal),\n\t\t\t\ttxscript.NewCannedPrevOutputFetcher(\n\t\t\t\t\tcommitPkScript, int64(outputVal),\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\tassertEngineExecution(t, i, testCase.valid, newEngine)\n\t}\n}\n\n// TestLeaseCommitSpendToRemoteConfirmed checks that the delayed version of the\n// to_remote version can only be spent by the owner, after one confirmation, and\n// after the lease expiration has been met.",
      "length": 2718,
      "tokens": 255,
      "embedding": []
    },
    {
      "slug": "func TestLeaseCommitSpendToRemoteConfirmed(t *testing.T) {",
      "content": "func TestLeaseCommitSpendToRemoteConfirmed(t *testing.T) {\n\tt.Parallel()\n\n\tconst (\n\t\toutputVal   = btcutil.Amount(2 * 10e8)\n\t\tleaseExpiry = 1337\n\t)\n\n\taliceKeyPriv, aliceKeyPub := btcec.PrivKeyFromBytes(\n\t\ttestWalletPrivKey,\n\t)\n\n\ttxid, err := chainhash.NewHash(testHdSeed.CloneBytes())\n\trequire.NoError(t, err)\n\tcommitOut := &wire.OutPoint{\n\t\tHash:  *txid,\n\t\tIndex: 0,\n\t}\n\tcommitScript, err := LeaseCommitScriptToRemoteConfirmed(\n\t\taliceKeyPub, leaseExpiry,\n\t)\n\trequire.NoError(t, err)\n\tcommitPkScript, err := WitnessScriptHash(commitScript)\n\trequire.NoError(t, err)\n\n\tcommitOutput := &wire.TxOut{\n\t\tPkScript: commitPkScript,\n\t\tValue:    int64(outputVal),\n\t}\n\n\tsweepTx := wire.NewMsgTx(2)\n\tsweepTx.AddTxIn(wire.NewTxIn(commitOut, nil, nil))\n\tsweepTx.AddTxOut(\n\t\t&wire.TxOut{\n\t\t\tPkScript: []byte(\"doesn't matter\"),\n\t\t\tValue:    1 * 10e8,\n\t\t},\n\t)\n\n\taliceSigner := &MockSigner{Privkeys: []*btcec.PrivateKey{aliceKeyPriv}}\n\n\ttestCases := []struct {\n\t\twitness func() wire.TxWitness\n\t\tvalid   bool\n\t}{\n\t\t{\n\t\t\t// Alice can spend after the CSV delay and CLTV timelock\n\t\t\t// has passed.\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\tsweepTx.LockTime = leaseExpiry\n\t\t\t\tsweepTx.TxIn[0].Sequence = LockTimeToSequence(\n\t\t\t\t\tfalse, 1,\n\t\t\t\t)\n\t\t\t\tsweepTxSigHashes := NewTxSigHashesV0Only(sweepTx)\n\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: aliceKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tWitnessScript: commitScript,\n\t\t\t\t\tOutput:        commitOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn CommitSpendToRemoteConfirmed(\n\t\t\t\t\taliceSigner, signDesc, sweepTx,\n\t\t\t\t)\n\t\t\t}),\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t// Alice cannot spend output without sequence set, even\n\t\t\t// once the CLTV timelock has expired.\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\tsweepTx.LockTime = leaseExpiry\n\t\t\t\tsweepTx.TxIn[0].Sequence = wire.MaxTxInSequenceNum\n\t\t\t\tsweepTxSigHashes := NewTxSigHashesV0Only(sweepTx)\n\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: aliceKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tWitnessScript: commitScript,\n\t\t\t\t\tOutput:        commitOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn CommitSpendToRemoteConfirmed(\n\t\t\t\t\taliceSigner, signDesc, sweepTx,\n\t\t\t\t)\n\t\t\t}),\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t// Alice cannot spend output without sequence or\n\t\t\t// locktime set.\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\tsweepTx.LockTime = 0\n\t\t\t\tsweepTx.TxIn[0].Sequence = wire.MaxTxInSequenceNum\n\t\t\t\tsweepTxSigHashes := NewTxSigHashesV0Only(sweepTx)\n\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: aliceKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tWitnessScript: commitScript,\n\t\t\t\t\tOutput:        commitOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn CommitSpendToRemoteConfirmed(\n\t\t\t\t\taliceSigner, signDesc, sweepTx,\n\t\t\t\t)\n\t\t\t}),\n\t\t\tfalse,\n\t\t},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tsweepTx.TxIn[0].Witness = testCase.witness()\n\n\t\tnewEngine := func() (*txscript.Engine, error) {\n\t\t\treturn txscript.NewEngine(\n\t\t\t\tcommitPkScript, sweepTx, 0,\n\t\t\t\ttxscript.StandardVerifyFlags, nil, nil,\n\t\t\t\tint64(outputVal),\n\t\t\t\ttxscript.NewCannedPrevOutputFetcher(\n\t\t\t\t\tcommitPkScript, int64(outputVal),\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\tassertEngineExecution(t, i, testCase.valid, newEngine)\n\t}\n}\n\n// TestSpendAnchor checks that we can spend the anchors using the various spend\n// paths.",
      "length": 3359,
      "tokens": 312,
      "embedding": []
    },
    {
      "slug": "func TestSpendAnchor(t *testing.T) {",
      "content": "func TestSpendAnchor(t *testing.T) {\n\tt.Parallel()\n\n\tconst anchorSize = 294\n\n\t// First we'll set up some initial key state for Alice.\n\taliceKeyPriv, aliceKeyPub := btcec.PrivKeyFromBytes(testWalletPrivKey)\n\n\t// Create a fake anchor outpoint that we'll use to generate the\n\t// sweeping transaction.\n\ttxid, err := chainhash.NewHash(testHdSeed.CloneBytes())\n\trequire.NoError(t, err, \"unable to create txid\")\n\tanchorOutPoint := &wire.OutPoint{\n\t\tHash:  *txid,\n\t\tIndex: 0,\n\t}\n\n\tsweepTx := wire.NewMsgTx(2)\n\tsweepTx.AddTxIn(wire.NewTxIn(anchorOutPoint, nil, nil))\n\tsweepTx.AddTxOut(\n\t\t&wire.TxOut{\n\t\t\tPkScript: []byte(\"doesn't matter\"),\n\t\t\tValue:    1 * 10e8,\n\t\t},\n\t)\n\n\t// Generate the anchor script that can be spent by Alice immediately,\n\t// or by anyone after 16 blocks.\n\tanchorScript, err := CommitScriptAnchor(aliceKeyPub)\n\trequire.NoError(t, err, \"unable to create htlc script\")\n\tanchorPkScript, err := WitnessScriptHash(anchorScript)\n\trequire.NoError(t, err, \"unable to create htlc output\")\n\n\tanchorOutput := &wire.TxOut{\n\t\tPkScript: anchorPkScript,\n\t\tValue:    int64(anchorSize),\n\t}\n\n\t// Create mock signer for Alice.\n\taliceSigner := &MockSigner{Privkeys: []*btcec.PrivateKey{aliceKeyPriv}}\n\n\ttestCases := []struct {\n\t\twitness func() wire.TxWitness\n\t\tvalid   bool\n\t}{\n\t\t{\n\t\t\t// Alice can spend immediately.\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\tsweepTx.TxIn[0].Sequence = wire.MaxTxInSequenceNum\n\t\t\t\tsweepTxSigHashes := NewTxSigHashesV0Only(sweepTx)\n\n\t\t\t\tsignDesc := &SignDescriptor{\n\t\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\t\tPubKey: aliceKeyPub,\n\t\t\t\t\t},\n\t\t\t\t\tWitnessScript: anchorScript,\n\t\t\t\t\tOutput:        anchorOutput,\n\t\t\t\t\tHashType:      txscript.SigHashAll,\n\t\t\t\t\tSigHashes:     sweepTxSigHashes,\n\t\t\t\t\tInputIndex:    0,\n\t\t\t\t}\n\n\t\t\t\treturn CommitSpendAnchor(aliceSigner, signDesc,\n\t\t\t\t\tsweepTx)\n\t\t\t}),\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t// Anyone can spend after 16 blocks.\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\tsweepTx.TxIn[0].Sequence = LockTimeToSequence(false, 16)\n\t\t\t\treturn CommitSpendAnchorAnyone(anchorScript)\n\t\t\t}),\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t// Anyone cannot spend before 16 blocks.\n\t\t\tmakeWitnessTestCase(t, func() (wire.TxWitness, error) {\n\t\t\t\tsweepTx.TxIn[0].Sequence = LockTimeToSequence(false, 15)\n\t\t\t\treturn CommitSpendAnchorAnyone(anchorScript)\n\t\t\t}),\n\t\t\tfalse,\n\t\t},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tsweepTx.TxIn[0].Witness = testCase.witness()\n\n\t\tnewEngine := func() (*txscript.Engine, error) {\n\t\t\treturn txscript.NewEngine(\n\t\t\t\tanchorPkScript,\n\t\t\t\tsweepTx, 0, txscript.StandardVerifyFlags, nil,\n\t\t\t\tnil, int64(anchorSize),\n\t\t\t\ttxscript.NewCannedPrevOutputFetcher(\n\t\t\t\t\tanchorPkScript, int64(anchorSize),\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\tassertEngineExecution(t, i, testCase.valid, newEngine)\n\t}\n}\n\n// TestSpecificationKeyDerivation implements the test vectors provided in\n// BOLT-03, Appendix E.",
      "length": 2708,
      "tokens": 276,
      "embedding": []
    },
    {
      "slug": "func TestSpecificationKeyDerivation(t *testing.T) {",
      "content": "func TestSpecificationKeyDerivation(t *testing.T) {\n\tconst (\n\t\tbaseSecretHex          = \"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\"\n\t\tperCommitmentSecretHex = \"1f1e1d1c1b1a191817161514131211100f0e0d0c0b0a09080706050403020100\"\n\t\tbasePointHex           = \"036d6caac248af96f6afa7f904f550253a0f3ef3f5aa2fe6838a95b216691468e2\"\n\t\tperCommitmentPointHex  = \"025f7117a78150fe2ef97db7cfc83bd57b2e2c0d0dd25eaf467a4a1c2a45ce1486\"\n\t)\n\n\tbaseSecret, err := privkeyFromHex(baseSecretHex)\n\trequire.NoError(t, err, \"Failed to parse serialized privkey\")\n\tperCommitmentSecret, err := privkeyFromHex(perCommitmentSecretHex)\n\trequire.NoError(t, err, \"Failed to parse serialized privkey\")\n\tbasePoint, err := pubkeyFromHex(basePointHex)\n\trequire.NoError(t, err, \"Failed to parse serialized pubkey\")\n\tperCommitmentPoint, err := pubkeyFromHex(perCommitmentPointHex)\n\trequire.NoError(t, err, \"Failed to parse serialized pubkey\")\n\n\t// name: derivation of key from basepoint and per_commitment_point\n\tconst expectedLocalKeyHex = \"0235f2dbfaa89b57ec7b055afe29849ef7ddfeb1cefdb9ebdc43f5494984db29e5\"\n\tactualLocalKey := TweakPubKey(basePoint, perCommitmentPoint)\n\tactualLocalKeyHex := pubkeyToHex(actualLocalKey)\n\tif actualLocalKeyHex != expectedLocalKeyHex {\n\t\tt.Errorf(\"Incorrect derivation of local public key: \"+\n\t\t\t\"expected %v, got %v\", expectedLocalKeyHex, actualLocalKeyHex)\n\t}\n\n\t// name: derivation of secret key from basepoint secret and per_commitment_secret\n\tconst expectedLocalPrivKeyHex = \"cbced912d3b21bf196a766651e436aff192362621ce317704ea2f75d87e7be0f\"\n\ttweak := SingleTweakBytes(perCommitmentPoint, basePoint)\n\tactualLocalPrivKey := TweakPrivKey(baseSecret, tweak)\n\tactualLocalPrivKeyHex := privkeyToHex(actualLocalPrivKey)\n\tif actualLocalPrivKeyHex != expectedLocalPrivKeyHex {\n\t\tt.Errorf(\"Incorrect derivation of local private key: \"+\n\t\t\t\"expected %v, got %v, %v\", expectedLocalPrivKeyHex,\n\t\t\tactualLocalPrivKeyHex, hex.EncodeToString(tweak))\n\t}\n\n\t// name: derivation of revocation key from basepoint and per_commitment_point\n\tconst expectedRevocationKeyHex = \"02916e326636d19c33f13e8c0c3a03dd157f332f3e99c317c141dd865eb01f8ff0\"\n\tactualRevocationKey := DeriveRevocationPubkey(basePoint, perCommitmentPoint)\n\tactualRevocationKeyHex := pubkeyToHex(actualRevocationKey)\n\tif actualRevocationKeyHex != expectedRevocationKeyHex {\n\t\tt.Errorf(\"Incorrect derivation of revocation public key: \"+\n\t\t\t\"expected %v, got %v\", expectedRevocationKeyHex,\n\t\t\tactualRevocationKeyHex)\n\t}\n\n\t// name: derivation of revocation secret from basepoint_secret and per_commitment_secret\n\tconst expectedRevocationPrivKeyHex = \"d09ffff62ddb2297ab000cc85bcb4283fdeb6aa052affbc9dddcf33b61078110\"\n\tactualRevocationPrivKey := DeriveRevocationPrivKey(baseSecret,\n\t\tperCommitmentSecret)\n\tactualRevocationPrivKeyHex := privkeyToHex(actualRevocationPrivKey)\n\tif actualRevocationPrivKeyHex != expectedRevocationPrivKeyHex {\n\t\tt.Errorf(\"Incorrect derivation of revocation private key: \"+\n\t\t\t\"expected %v, got %v\", expectedRevocationPrivKeyHex,\n\t\t\tactualRevocationPrivKeyHex)\n\t}\n}\n",
      "length": 2942,
      "tokens": 226,
      "embedding": []
    }
  ]
}