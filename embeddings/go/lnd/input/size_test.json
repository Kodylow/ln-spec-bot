{
  "filepath": "../implementations/go/lnd/input/size_test.go",
  "package": "input_test",
  "sections": [
    {
      "slug": "func TestTxWeightEstimator(t *testing.T) {",
      "content": "func TestTxWeightEstimator(t *testing.T) {\n\tnetParams := &chaincfg.MainNetParams\n\n\tp2pkhAddr, err := btcutil.NewAddressPubKeyHash(\n\t\tmake([]byte, 20), netParams)\n\trequire.NoError(t, err, \"Failed to generate address\")\n\tp2pkhScript, err := txscript.PayToAddrScript(p2pkhAddr)\n\trequire.NoError(t, err, \"Failed to generate scriptPubKey\")\n\n\tp2wkhAddr, err := btcutil.NewAddressWitnessPubKeyHash(\n\t\tmake([]byte, 20), netParams)\n\trequire.NoError(t, err, \"Failed to generate address\")\n\tp2wkhScript, err := txscript.PayToAddrScript(p2wkhAddr)\n\trequire.NoError(t, err, \"Failed to generate scriptPubKey\")\n\n\tp2wshAddr, err := btcutil.NewAddressWitnessScriptHash(\n\t\tmake([]byte, 32), netParams)\n\trequire.NoError(t, err, \"Failed to generate address\")\n\tp2wshScript, err := txscript.PayToAddrScript(p2wshAddr)\n\trequire.NoError(t, err, \"Failed to generate scriptPubKey\")\n\n\tp2shAddr, err := btcutil.NewAddressScriptHash([]byte{0}, netParams)\n\trequire.NoError(t, err, \"Failed to generate address\")\n\tp2shScript, err := txscript.PayToAddrScript(p2shAddr)\n\trequire.NoError(t, err, \"Failed to generate scriptPubKey\")\n\n\ttestCases := []struct {\n\t\tnumP2PKHInputs       int\n\t\tnumP2WKHInputs       int\n\t\tnumP2WSHInputs       int\n\t\tnumNestedP2WKHInputs int\n\t\tnumNestedP2WSHInputs int\n\t\tnumP2PKHOutputs      int\n\t\tnumP2WKHOutputs      int\n\t\tnumP2WSHOutputs      int\n\t\tnumP2SHOutputs       int\n\t}{\n\t\t// Assert base txn size.\n\t\t{},\n\n\t\t// Assert single input/output sizes.\n\t\t{\n\t\t\tnumP2PKHInputs: 1,\n\t\t},\n\t\t{\n\t\t\tnumP2WKHInputs: 1,\n\t\t},\n\t\t{\n\t\t\tnumP2WSHInputs: 1,\n\t\t},\n\t\t{\n\t\t\tnumNestedP2WKHInputs: 1,\n\t\t},\n\t\t{\n\t\t\tnumNestedP2WSHInputs: 1,\n\t\t},\n\t\t{\n\t\t\tnumP2WKHOutputs: 1,\n\t\t},\n\t\t{\n\t\t\tnumP2PKHOutputs: 1,\n\t\t},\n\t\t{\n\t\t\tnumP2WSHOutputs: 1,\n\t\t},\n\t\t{\n\t\t\tnumP2SHOutputs: 1,\n\t\t},\n\n\t\t// Assert each input/output increments input/output counts.\n\t\t{\n\t\t\tnumP2PKHInputs: 253,\n\t\t},\n\t\t{\n\t\t\tnumP2WKHInputs: 253,\n\t\t},\n\t\t{\n\t\t\tnumP2WSHInputs: 253,\n\t\t},\n\t\t{\n\t\t\tnumNestedP2WKHInputs: 253,\n\t\t},\n\t\t{\n\t\t\tnumNestedP2WSHInputs: 253,\n\t\t},\n\t\t{\n\t\t\tnumP2WKHOutputs: 253,\n\t\t},\n\t\t{\n\t\t\tnumP2PKHOutputs: 253,\n\t\t},\n\t\t{\n\t\t\tnumP2WSHOutputs: 253,\n\t\t},\n\t\t{\n\t\t\tnumP2SHOutputs: 253,\n\t\t},\n\n\t\t// Assert basic combinations of inputs and outputs.\n\t\t{\n\t\t\tnumP2PKHInputs:  1,\n\t\t\tnumP2PKHOutputs: 2,\n\t\t},\n\t\t{\n\t\t\tnumP2PKHInputs:  1,\n\t\t\tnumP2WKHInputs:  1,\n\t\t\tnumP2WKHOutputs: 1,\n\t\t\tnumP2WSHOutputs: 1,\n\t\t},\n\t\t{\n\t\t\tnumP2WKHInputs:  1,\n\t\t\tnumP2WKHOutputs: 1,\n\t\t\tnumP2WSHOutputs: 1,\n\t\t},\n\t\t{\n\t\t\tnumP2WKHInputs:  2,\n\t\t\tnumP2WKHOutputs: 1,\n\t\t\tnumP2WSHOutputs: 1,\n\t\t},\n\t\t{\n\t\t\tnumP2WSHInputs:  1,\n\t\t\tnumP2WKHOutputs: 1,\n\t\t},\n\t\t{\n\t\t\tnumP2PKHInputs: 1,\n\t\t\tnumP2SHOutputs: 1,\n\t\t},\n\t\t{\n\t\t\tnumNestedP2WKHInputs: 1,\n\t\t\tnumP2WKHOutputs:      1,\n\t\t},\n\t\t{\n\t\t\tnumNestedP2WSHInputs: 1,\n\t\t\tnumP2WKHOutputs:      1,\n\t\t},\n\n\t\t// Assert disparate input/output types increment total\n\t\t// input/output counts.\n\t\t{\n\t\t\tnumP2PKHInputs:       50,\n\t\t\tnumP2WKHInputs:       50,\n\t\t\tnumP2WSHInputs:       51,\n\t\t\tnumNestedP2WKHInputs: 51,\n\t\t\tnumNestedP2WSHInputs: 51,\n\t\t\tnumP2WKHOutputs:      1,\n\t\t},\n\t\t{\n\t\t\tnumP2WKHInputs:  1,\n\t\t\tnumP2WKHOutputs: 63,\n\t\t\tnumP2PKHOutputs: 63,\n\t\t\tnumP2WSHOutputs: 63,\n\t\t\tnumP2SHOutputs:  64,\n\t\t},\n\t\t{\n\t\t\tnumP2PKHInputs:       50,\n\t\t\tnumP2WKHInputs:       50,\n\t\t\tnumP2WSHInputs:       51,\n\t\t\tnumNestedP2WKHInputs: 51,\n\t\t\tnumNestedP2WSHInputs: 51,\n\t\t\tnumP2WKHOutputs:      63,\n\t\t\tnumP2PKHOutputs:      63,\n\t\t\tnumP2WSHOutputs:      63,\n\t\t\tnumP2SHOutputs:       64,\n\t\t},\n\t}\n\n\tfor i, test := range testCases {\n\t\tvar weightEstimate input.TxWeightEstimator\n\t\ttx := wire.NewMsgTx(1)\n\n\t\tfor j := 0; j < test.numP2PKHInputs; j++ {\n\t\t\tweightEstimate.AddP2PKHInput()\n\n\t\t\tsignature := make([]byte, maxDERSignatureSize+1)\n\t\t\tcompressedPubKey := make([]byte, 33)\n\t\t\tscriptSig, err := txscript.NewScriptBuilder().AddData(signature).\n\t\t\t\tAddData(compressedPubKey).Script()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Failed to generate scriptSig: %v\", err)\n\t\t\t}\n\n\t\t\ttx.AddTxIn(&wire.TxIn{SignatureScript: scriptSig})\n\t\t}\n\t\tfor j := 0; j < test.numP2WKHInputs; j++ {\n\t\t\tweightEstimate.AddP2WKHInput()\n\n\t\t\tsignature := make([]byte, maxDERSignatureSize+1)\n\t\t\tcompressedPubKey := make([]byte, 33)\n\t\t\twitness := wire.TxWitness{signature, compressedPubKey}\n\t\t\ttx.AddTxIn(&wire.TxIn{Witness: witness})\n\t\t}\n\t\tfor j := 0; j < test.numP2WSHInputs; j++ {\n\t\t\tweightEstimate.AddWitnessInput(42)\n\n\t\t\twitnessScript := make([]byte, 40)\n\t\t\twitness := wire.TxWitness{witnessScript}\n\t\t\ttx.AddTxIn(&wire.TxIn{Witness: witness})\n\t\t}\n\t\tfor j := 0; j < test.numNestedP2WKHInputs; j++ {\n\t\t\tweightEstimate.AddNestedP2WKHInput()\n\n\t\t\tsignature := make([]byte, maxDERSignatureSize+1)\n\t\t\tcompressedPubKey := make([]byte, 33)\n\t\t\twitness := wire.TxWitness{signature, compressedPubKey}\n\t\t\tscriptSig, err := txscript.NewScriptBuilder().AddData(p2wkhScript).\n\t\t\t\tScript()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Failed to generate scriptSig: %v\", err)\n\t\t\t}\n\n\t\t\ttx.AddTxIn(&wire.TxIn{SignatureScript: scriptSig, Witness: witness})\n\t\t}\n\t\tfor j := 0; j < test.numNestedP2WSHInputs; j++ {\n\t\t\tweightEstimate.AddNestedP2WSHInput(42)\n\n\t\t\twitnessScript := make([]byte, 40)\n\t\t\twitness := wire.TxWitness{witnessScript}\n\t\t\tscriptSig, err := txscript.NewScriptBuilder().AddData(p2wshScript).\n\t\t\t\tScript()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Failed to generate scriptSig: %v\", err)\n\t\t\t}\n\n\t\t\ttx.AddTxIn(&wire.TxIn{SignatureScript: scriptSig, Witness: witness})\n\t\t}\n\t\tfor j := 0; j < test.numP2PKHOutputs; j++ {\n\t\t\tweightEstimate.AddP2PKHOutput()\n\t\t\ttx.AddTxOut(&wire.TxOut{PkScript: p2pkhScript})\n\t\t}\n\t\tfor j := 0; j < test.numP2WKHOutputs; j++ {\n\t\t\tweightEstimate.AddP2WKHOutput()\n\t\t\ttx.AddTxOut(&wire.TxOut{PkScript: p2wkhScript})\n\t\t}\n\t\tfor j := 0; j < test.numP2WSHOutputs; j++ {\n\t\t\tweightEstimate.AddP2WSHOutput()\n\t\t\ttx.AddTxOut(&wire.TxOut{PkScript: p2wshScript})\n\t\t}\n\t\tfor j := 0; j < test.numP2SHOutputs; j++ {\n\t\t\tweightEstimate.AddP2SHOutput()\n\t\t\ttx.AddTxOut(&wire.TxOut{PkScript: p2shScript})\n\t\t}\n\n\t\texpectedWeight := blockchain.GetTransactionWeight(btcutil.NewTx(tx))\n\t\tif weightEstimate.Weight() != int(expectedWeight) {\n\t\t\tt.Errorf(\"Case %d: Got wrong weight: expected %d, got %d\",\n\t\t\t\ti, expectedWeight, weightEstimate.Weight())\n\t\t}\n\t}\n}\n",
      "length": 5785,
      "tokens": 581,
      "embedding": []
    },
    {
      "slug": "type maxDERSignature struct{}",
      "content": "type maxDERSignature struct{}\n",
      "length": 0,
      "tokens": 0,
      "embedding": []
    },
    {
      "slug": "func (s *maxDERSignature) Serialize() []byte {",
      "content": "func (s *maxDERSignature) Serialize() []byte {\n\t// Always return worst-case signature length, excluding the one byte\n\t// sighash flag.\n\treturn make([]byte, maxDERSignatureSize)\n}\n",
      "length": 128,
      "tokens": 17,
      "embedding": []
    },
    {
      "slug": "func (s *maxDERSignature) Verify(_ []byte, _ *btcec.PublicKey) bool {",
      "content": "func (s *maxDERSignature) Verify(_ []byte, _ *btcec.PublicKey) bool {\n\treturn true\n}\n\n// dummySigner is a fake signer used for size (upper bound) calculations.",
      "length": 86,
      "tokens": 15,
      "embedding": []
    },
    {
      "slug": "type dummySigner struct {",
      "content": "type dummySigner struct {\n\tinput.Signer\n}\n\n// SignOutputRaw generates a signature for the passed transaction according to\n// the data within the passed SignDescriptor.",
      "length": 137,
      "tokens": 20,
      "embedding": []
    },
    {
      "slug": "func (s *dummySigner) SignOutputRaw(tx *wire.MsgTx,",
      "content": "func (s *dummySigner) SignOutputRaw(tx *wire.MsgTx,\n\tsignDesc *input.SignDescriptor) (input.Signature, error) {\n\n\treturn &maxDERSignature{}, nil\n}\n",
      "length": 91,
      "tokens": 9,
      "embedding": []
    },
    {
      "slug": "type witnessSizeTest struct {",
      "content": "type witnessSizeTest struct {\n\tname       string\n\texpSize    int\n\tgenWitness func(t *testing.T) wire.TxWitness\n}\n\nvar witnessSizeTests = []witnessSizeTest{\n\t{\n\t\tname:    \"funding\",\n\t\texpSize: input.MultiSigWitnessSize,\n\t\tgenWitness: func(t *testing.T) wire.TxWitness {\n\t\t\twitnessScript, _, err := input.GenFundingPkScript(\n\t\t\t\ttestPubkeyBytes, testPubkeyBytes, 1,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\treturn input.SpendMultiSig(\n\t\t\t\twitnessScript,\n\t\t\t\ttestPubkeyBytes, &maxDERSignature{},\n\t\t\t\ttestPubkeyBytes, &maxDERSignature{},\n\t\t\t)\n\t\t},\n\t},\n\t{\n\t\tname:    \"to local timeout\",\n\t\texpSize: input.ToLocalTimeoutWitnessSize,\n\t\tgenWitness: func(t *testing.T) wire.TxWitness {\n\t\t\twitnessScript, err := input.CommitScriptToSelf(\n\t\t\t\ttestCSVDelay, testPubkey, testPubkey,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tsignDesc := &input.SignDescriptor{\n\t\t\t\tWitnessScript: witnessScript,\n\t\t\t}\n\n\t\t\twitness, err := input.CommitSpendTimeout(\n\t\t\t\t&dummySigner{}, signDesc, testTx,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\treturn witness\n\t\t},\n\t},\n\t{\n\t\tname:    \"to local revoke\",\n\t\texpSize: input.ToLocalPenaltyWitnessSize,\n\t\tgenWitness: func(t *testing.T) wire.TxWitness {\n\t\t\twitnessScript, err := input.CommitScriptToSelf(\n\t\t\t\ttestCSVDelay, testPubkey, testPubkey,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tsignDesc := &input.SignDescriptor{\n\t\t\t\tWitnessScript: witnessScript,\n\t\t\t}\n\n\t\t\twitness, err := input.CommitSpendRevoke(\n\t\t\t\t&dummySigner{}, signDesc, testTx,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\treturn witness\n\t\t},\n\t},\n\t{\n\t\tname:    \"to remote confirmed\",\n\t\texpSize: input.ToRemoteConfirmedWitnessSize,\n\t\tgenWitness: func(t *testing.T) wire.TxWitness {\n\t\t\twitScript, err := input.CommitScriptToRemoteConfirmed(\n\t\t\t\ttestPubkey,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tsignDesc := &input.SignDescriptor{\n\t\t\t\tWitnessScript: witScript,\n\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\tPubKey: testPubkey,\n\t\t\t\t},\n\t\t\t}\n\n\t\t\twitness, err := input.CommitSpendToRemoteConfirmed(\n\t\t\t\t&dummySigner{}, signDesc, testTx,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\treturn witness\n\t\t},\n\t},\n\t{\n\t\tname:    \"anchor\",\n\t\texpSize: input.AnchorWitnessSize,\n\t\tgenWitness: func(t *testing.T) wire.TxWitness {\n\t\t\twitScript, err := input.CommitScriptAnchor(\n\t\t\t\ttestPubkey,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tsignDesc := &input.SignDescriptor{\n\t\t\t\tWitnessScript: witScript,\n\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\tPubKey: testPubkey,\n\t\t\t\t},\n\t\t\t}\n\n\t\t\twitness, err := input.CommitSpendAnchor(\n\t\t\t\t&dummySigner{}, signDesc, testTx,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\treturn witness\n\t\t},\n\t},\n\t{\n\t\tname:    \"anchor anyone\",\n\t\texpSize: 43,\n\t\tgenWitness: func(t *testing.T) wire.TxWitness {\n\t\t\twitScript, err := input.CommitScriptAnchor(\n\t\t\t\ttestPubkey,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\twitness, _ := input.CommitSpendAnchorAnyone(witScript)\n\n\t\t\treturn witness\n\t\t},\n\t},\n\t{\n\t\tname:    \"offered htlc revoke\",\n\t\texpSize: input.OfferedHtlcPenaltyWitnessSize,\n\t\tgenWitness: func(t *testing.T) wire.TxWitness {\n\t\t\twitScript, err := input.SenderHTLCScript(\n\t\t\t\ttestPubkey, testPubkey, testPubkey,\n\t\t\t\ttestHash160, false,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tsignDesc := &input.SignDescriptor{\n\t\t\t\tWitnessScript: witScript,\n\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\tPubKey: testPubkey,\n\t\t\t\t},\n\t\t\t\tDoubleTweak: testPrivkey,\n\t\t\t}\n\n\t\t\twitness, err := input.SenderHtlcSpendRevoke(\n\t\t\t\t&dummySigner{}, signDesc, testTx,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\treturn witness\n\t\t},\n\t},\n\t{\n\t\tname:    \"offered htlc revoke confirmed\",\n\t\texpSize: input.OfferedHtlcPenaltyWitnessSizeConfirmed,\n\t\tgenWitness: func(t *testing.T) wire.TxWitness {\n\t\t\thash := make([]byte, 20)\n\n\t\t\twitScript, err := input.SenderHTLCScript(\n\t\t\t\ttestPubkey, testPubkey, testPubkey,\n\t\t\t\thash, true,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tsignDesc := &input.SignDescriptor{\n\t\t\t\tWitnessScript: witScript,\n\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\tPubKey: testPubkey,\n\t\t\t\t},\n\t\t\t\tDoubleTweak: testPrivkey,\n\t\t\t}\n\n\t\t\twitness, err := input.SenderHtlcSpendRevoke(\n\t\t\t\t&dummySigner{}, signDesc, testTx,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\treturn witness\n\t\t},\n\t},\n\t{\n\t\tname:    \"offered htlc timeout\",\n\t\texpSize: input.OfferedHtlcTimeoutWitnessSize,\n\t\tgenWitness: func(t *testing.T) wire.TxWitness {\n\t\t\twitScript, err := input.SenderHTLCScript(\n\t\t\t\ttestPubkey, testPubkey, testPubkey,\n\t\t\t\ttestHash160, false,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tsignDesc := &input.SignDescriptor{\n\t\t\t\tWitnessScript: witScript,\n\t\t\t}\n\n\t\t\twitness, err := input.SenderHtlcSpendTimeout(\n\t\t\t\t&maxDERSignature{}, txscript.SigHashAll,\n\t\t\t\t&dummySigner{}, signDesc, testTx,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\treturn witness\n\t\t},\n\t},\n\t{\n\t\tname:    \"offered htlc timeout confirmed\",\n\t\texpSize: input.OfferedHtlcTimeoutWitnessSizeConfirmed,\n\t\tgenWitness: func(t *testing.T) wire.TxWitness {\n\t\t\twitScript, err := input.SenderHTLCScript(\n\t\t\t\ttestPubkey, testPubkey, testPubkey,\n\t\t\t\ttestHash160, true,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tsignDesc := &input.SignDescriptor{\n\t\t\t\tWitnessScript: witScript,\n\t\t\t}\n\n\t\t\twitness, err := input.SenderHtlcSpendTimeout(\n\t\t\t\t&maxDERSignature{}, txscript.SigHashAll,\n\t\t\t\t&dummySigner{}, signDesc, testTx,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\treturn witness\n\t\t},\n\t},\n\t{\n\t\tname:    \"offered htlc success\",\n\t\texpSize: input.OfferedHtlcSuccessWitnessSize,\n\t\tgenWitness: func(t *testing.T) wire.TxWitness {\n\t\t\twitScript, err := input.SenderHTLCScript(\n\t\t\t\ttestPubkey, testPubkey, testPubkey,\n\t\t\t\ttestHash160, false,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tsignDesc := &input.SignDescriptor{\n\t\t\t\tWitnessScript: witScript,\n\t\t\t}\n\n\t\t\twitness, err := input.SenderHtlcSpendRedeem(\n\t\t\t\t&dummySigner{}, signDesc, testTx, testPreimage,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\treturn witness\n\t\t},\n\t},\n\t{\n\t\tname:    \"offered htlc success confirmed\",\n\t\texpSize: input.OfferedHtlcSuccessWitnessSizeConfirmed,\n\t\tgenWitness: func(t *testing.T) wire.TxWitness {\n\t\t\twitScript, err := input.SenderHTLCScript(\n\t\t\t\ttestPubkey, testPubkey, testPubkey,\n\t\t\t\ttestHash160, true,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tsignDesc := &input.SignDescriptor{\n\t\t\t\tWitnessScript: witScript,\n\t\t\t}\n\n\t\t\twitness, err := input.SenderHtlcSpendRedeem(\n\t\t\t\t&dummySigner{}, signDesc, testTx, testPreimage,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\treturn witness\n\t\t},\n\t},\n\t{\n\t\tname:    \"accepted htlc revoke\",\n\t\texpSize: input.AcceptedHtlcPenaltyWitnessSize,\n\t\tgenWitness: func(t *testing.T) wire.TxWitness {\n\t\t\twitScript, err := input.ReceiverHTLCScript(\n\t\t\t\ttestCLTVExpiry, testPubkey, testPubkey,\n\t\t\t\ttestPubkey, testHash160, false,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tsignDesc := &input.SignDescriptor{\n\t\t\t\tWitnessScript: witScript,\n\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\tPubKey: testPubkey,\n\t\t\t\t},\n\t\t\t\tDoubleTweak: testPrivkey,\n\t\t\t}\n\n\t\t\twitness, err := input.ReceiverHtlcSpendRevoke(\n\t\t\t\t&dummySigner{}, signDesc, testTx,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\treturn witness\n\t\t},\n\t},\n\t{\n\t\tname:    \"accepted htlc revoke confirmed\",\n\t\texpSize: input.AcceptedHtlcPenaltyWitnessSizeConfirmed,\n\t\tgenWitness: func(t *testing.T) wire.TxWitness {\n\t\t\twitScript, err := input.ReceiverHTLCScript(\n\t\t\t\ttestCLTVExpiry, testPubkey, testPubkey,\n\t\t\t\ttestPubkey, testHash160, true,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tsignDesc := &input.SignDescriptor{\n\t\t\t\tWitnessScript: witScript,\n\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\tPubKey: testPubkey,\n\t\t\t\t},\n\t\t\t\tDoubleTweak: testPrivkey,\n\t\t\t}\n\n\t\t\twitness, err := input.ReceiverHtlcSpendRevoke(\n\t\t\t\t&dummySigner{}, signDesc, testTx,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\treturn witness\n\t\t},\n\t},\n\t{\n\t\tname:    \"accepted htlc timeout\",\n\t\texpSize: input.AcceptedHtlcTimeoutWitnessSize,\n\t\tgenWitness: func(t *testing.T) wire.TxWitness {\n\n\t\t\twitScript, err := input.ReceiverHTLCScript(\n\t\t\t\ttestCLTVExpiry, testPubkey, testPubkey,\n\t\t\t\ttestPubkey, testHash160, false,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tsignDesc := &input.SignDescriptor{\n\t\t\t\tWitnessScript: witScript,\n\t\t\t}\n\n\t\t\twitness, err := input.ReceiverHtlcSpendTimeout(\n\t\t\t\t&dummySigner{}, signDesc, testTx,\n\t\t\t\ttestCLTVExpiry,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\treturn witness\n\t\t},\n\t},\n\t{\n\t\tname:    \"accepted htlc timeout confirmed\",\n\t\texpSize: input.AcceptedHtlcTimeoutWitnessSizeConfirmed,\n\t\tgenWitness: func(t *testing.T) wire.TxWitness {\n\t\t\twitScript, err := input.ReceiverHTLCScript(\n\t\t\t\ttestCLTVExpiry, testPubkey, testPubkey,\n\t\t\t\ttestPubkey, testHash160, true,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tsignDesc := &input.SignDescriptor{\n\t\t\t\tWitnessScript: witScript,\n\t\t\t}\n\n\t\t\twitness, err := input.ReceiverHtlcSpendTimeout(\n\t\t\t\t&dummySigner{}, signDesc, testTx,\n\t\t\t\ttestCLTVExpiry,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\treturn witness\n\t\t},\n\t},\n\t{\n\t\tname:    \"accepted htlc success\",\n\t\texpSize: input.AcceptedHtlcSuccessWitnessSize,\n\t\tgenWitness: func(t *testing.T) wire.TxWitness {\n\t\t\twitScript, err := input.ReceiverHTLCScript(\n\t\t\t\ttestCLTVExpiry, testPubkey, testPubkey,\n\t\t\t\ttestPubkey, testHash160, false,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tsignDesc := &input.SignDescriptor{\n\t\t\t\tWitnessScript: witScript,\n\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\tPubKey: testPubkey,\n\t\t\t\t},\n\t\t\t}\n\n\t\t\twitness, err := input.ReceiverHtlcSpendRedeem(\n\t\t\t\t&maxDERSignature{}, txscript.SigHashAll,\n\t\t\t\ttestPreimage, &dummySigner{}, signDesc, testTx,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\treturn witness\n\t\t},\n\t},\n\t{\n\t\tname:    \"accepted htlc success confirmed\",\n\t\texpSize: input.AcceptedHtlcSuccessWitnessSizeConfirmed,\n\t\tgenWitness: func(t *testing.T) wire.TxWitness {\n\t\t\twitScript, err := input.ReceiverHTLCScript(\n\t\t\t\ttestCLTVExpiry, testPubkey, testPubkey,\n\t\t\t\ttestPubkey, testHash160, true,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tsignDesc := &input.SignDescriptor{\n\t\t\t\tWitnessScript: witScript,\n\t\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\t\tPubKey: testPubkey,\n\t\t\t\t},\n\t\t\t}\n\n\t\t\twitness, err := input.ReceiverHtlcSpendRedeem(\n\t\t\t\t&maxDERSignature{}, txscript.SigHashAll,\n\t\t\t\ttestPreimage, &dummySigner{}, signDesc, testTx,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\treturn witness\n\t\t},\n\t},\n}\n\n// TestWitnessSizes asserts the correctness of our magic witness constants.\n// Witnesses involving signatures will have maxDERSignatures injected so that we\n// can determine upper bounds for the witness sizes. These constants are\n// predominately used for fee estimation, so we want to be certain that we\n// aren't under estimating or our transactions could get stuck.",
      "length": 10168,
      "tokens": 1067,
      "embedding": []
    },
    {
      "slug": "func TestWitnessSizes(t *testing.T) {",
      "content": "func TestWitnessSizes(t *testing.T) {\n\tfor _, test := range witnessSizeTests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tsize := test.genWitness(t).SerializeSize()\n\t\t\tif size != test.expSize {\n\t\t\t\tt.Fatalf(\"size mismatch, want: %v, got: %v\",\n\t\t\t\t\ttest.expSize, size)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// genTimeoutTx creates a signed HTLC second level timeout tx.",
      "length": 311,
      "tokens": 44,
      "embedding": []
    },
    {
      "slug": "func genTimeoutTx(chanType channeldb.ChannelType) (*wire.MsgTx, error) {",
      "content": "func genTimeoutTx(chanType channeldb.ChannelType) (*wire.MsgTx, error) {\n\t// Create the unsigned timeout tx.\n\ttimeoutTx, err := lnwallet.CreateHtlcTimeoutTx(\n\t\tchanType, false, testOutPoint, testAmt, testCLTVExpiry,\n\t\ttestCSVDelay, 0, testPubkey, testPubkey,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// In order to sign the transcation, generate the script for the output\n\t// it spends.\n\twitScript, err := input.SenderHTLCScript(\n\t\ttestPubkey, testPubkey, testPubkey, testHash160,\n\t\tchanType.HasAnchors(),\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsignDesc := &input.SignDescriptor{\n\t\tWitnessScript: witScript,\n\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\tPubKey: testPubkey,\n\t\t},\n\t}\n\n\t// Sign the timeout tx and add the witness.\n\tsigHashType := lnwallet.HtlcSigHashType(chanType)\n\ttimeoutWitness, err := input.SenderHtlcSpendTimeout(\n\t\t&maxDERSignature{}, sigHashType, &dummySigner{},\n\t\tsignDesc, timeoutTx,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttimeoutTx.TxIn[0].Witness = timeoutWitness\n\n\treturn timeoutTx, nil\n}\n\n// genSuccessTx creates a signed HTLC second level success tx.",
      "length": 966,
      "tokens": 123,
      "embedding": []
    },
    {
      "slug": "func genSuccessTx(chanType channeldb.ChannelType) (*wire.MsgTx, error) {",
      "content": "func genSuccessTx(chanType channeldb.ChannelType) (*wire.MsgTx, error) {\n\t// Create the unisgned success tx.\n\tsuccessTx, err := lnwallet.CreateHtlcSuccessTx(\n\t\tchanType, false, testOutPoint, testAmt, testCSVDelay, 0,\n\t\ttestPubkey, testPubkey,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// In order to sign the transcation, generate the script for the output\n\t// it spends.\n\twitScript, err := input.ReceiverHTLCScript(\n\t\ttestCLTVExpiry, testPubkey, testPubkey,\n\t\ttestPubkey, testHash160, chanType.HasAnchors(),\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsignDesc := &input.SignDescriptor{\n\t\tWitnessScript: witScript,\n\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\tPubKey: testPubkey,\n\t\t},\n\t}\n\n\t// Sign the success tx and add the witness.\n\tsigHashType := lnwallet.HtlcSigHashType(channeldb.SingleFunderBit)\n\tsuccessWitness, err := input.ReceiverHtlcSpendRedeem(\n\t\t&maxDERSignature{}, sigHashType, testPreimage,\n\t\t&dummySigner{}, signDesc, successTx,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tsuccessTx.TxIn[0].Witness = successWitness\n\n\treturn successTx, nil\n}\n",
      "length": 938,
      "tokens": 114,
      "embedding": []
    },
    {
      "slug": "type txSizeTest struct {",
      "content": "type txSizeTest struct {\n\tname      string\n\texpWeight int64\n\tgenTx     func(t *testing.T) *wire.MsgTx\n}\n\nvar txSizeTests = []txSizeTest{\n\t{\n\t\tname:      \"htlc timeout regular \",\n\t\texpWeight: input.HtlcTimeoutWeight,\n\t\tgenTx: func(t *testing.T) *wire.MsgTx {\n\t\t\ttx, err := genTimeoutTx(channeldb.SingleFunderBit)\n\t\t\trequire.NoError(t, err)\n\n\t\t\treturn tx\n\t\t},\n\t},\n\t{\n\t\tname:      \"htlc timeout confirmed\",\n\t\texpWeight: input.HtlcTimeoutWeightConfirmed,\n\t\tgenTx: func(t *testing.T) *wire.MsgTx {\n\t\t\ttx, err := genTimeoutTx(channeldb.AnchorOutputsBit)\n\t\t\trequire.NoError(t, err)\n\n\t\t\treturn tx\n\t\t},\n\t},\n\n\t{\n\t\tname: \"htlc success regular\",\n\t\t// The weight estimate from the spec is off by one, but it's\n\t\t// okay since we overestimate the weight.\n\t\texpWeight: input.HtlcSuccessWeight - 1,\n\t\tgenTx: func(t *testing.T) *wire.MsgTx {\n\t\t\ttx, err := genSuccessTx(channeldb.SingleFunderBit)\n\t\t\trequire.NoError(t, err)\n\n\t\t\treturn tx\n\t\t},\n\t},\n\t{\n\t\tname: \"htlc success confirmed\",\n\t\t// The weight estimate from the spec is off by one, but it's\n\t\t// okay since we overestimate the weight.\n\t\texpWeight: input.HtlcSuccessWeightConfirmed - 1,\n\t\tgenTx: func(t *testing.T) *wire.MsgTx {\n\t\t\ttx, err := genSuccessTx(channeldb.AnchorOutputsBit)\n\t\t\trequire.NoError(t, err)\n\n\t\t\treturn tx\n\t\t},\n\t},\n}\n\n// TestWitnessSizes asserts the correctness of our magic tx size constants.",
      "length": 1271,
      "tokens": 158,
      "embedding": []
    },
    {
      "slug": "func TestTxSizes(t *testing.T) {",
      "content": "func TestTxSizes(t *testing.T) {\n\tfor _, test := range txSizeTests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\ttx := test.genTx(t)\n\n\t\t\tweight := blockchain.GetTransactionWeight(btcutil.NewTx(tx))\n\t\t\tif weight != test.expWeight {\n\t\t\t\tt.Fatalf(\"size mismatch, want: %v, got: %v\",\n\t\t\t\t\ttest.expWeight, weight)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "length": 292,
      "tokens": 37,
      "embedding": []
    }
  ]
}