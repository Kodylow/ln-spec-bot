{
  "filepath": "../implementations/go/lnd/chanbackup/single_test.go",
  "package": "chanbackup",
  "sections": [
    {
      "slug": "func assertSingleEqual(t *testing.T, a, b Single) {",
      "content": "func assertSingleEqual(t *testing.T, a, b Single) {\n\tt.Helper()\n\n\tif a.Version != b.Version {\n\t\tt.Fatalf(\"versions don't match: %v vs %v\", a.Version,\n\t\t\tb.Version)\n\t}\n\tif a.IsInitiator != b.IsInitiator {\n\t\tt.Fatalf(\"initiators don't match: %v vs %v\", a.IsInitiator,\n\t\t\tb.IsInitiator)\n\t}\n\tif a.ChainHash != b.ChainHash {\n\t\tt.Fatalf(\"chainhash doesn't match: %v vs %v\", a.ChainHash,\n\t\t\tb.ChainHash)\n\t}\n\tif a.FundingOutpoint != b.FundingOutpoint {\n\t\tt.Fatalf(\"chan point doesn't match: %v vs %v\",\n\t\t\ta.FundingOutpoint, b.FundingOutpoint)\n\t}\n\tif a.ShortChannelID != b.ShortChannelID {\n\t\tt.Fatalf(\"chan id doesn't match: %v vs %v\",\n\t\t\ta.ShortChannelID, b.ShortChannelID)\n\t}\n\tif a.Capacity != b.Capacity {\n\t\tt.Fatalf(\"capacity doesn't match: %v vs %v\",\n\t\t\ta.Capacity, b.Capacity)\n\t}\n\tif !a.RemoteNodePub.IsEqual(b.RemoteNodePub) {\n\t\tt.Fatalf(\"node pubs don't match %x vs %x\",\n\t\t\ta.RemoteNodePub.SerializeCompressed(),\n\t\t\tb.RemoteNodePub.SerializeCompressed())\n\t}\n\tif !reflect.DeepEqual(a.LocalChanCfg, b.LocalChanCfg) {\n\t\tt.Fatalf(\"local chan config doesn't match: %v vs %v\",\n\t\t\tspew.Sdump(a.LocalChanCfg),\n\t\t\tspew.Sdump(b.LocalChanCfg))\n\t}\n\tif !reflect.DeepEqual(a.RemoteChanCfg, b.RemoteChanCfg) {\n\t\tt.Fatalf(\"remote chan config doesn't match: %v vs %v\",\n\t\t\tspew.Sdump(a.RemoteChanCfg),\n\t\t\tspew.Sdump(b.RemoteChanCfg))\n\t}\n\tif !reflect.DeepEqual(a.ShaChainRootDesc, b.ShaChainRootDesc) {\n\t\tt.Fatalf(\"sha chain point doesn't match: %v vs %v\",\n\t\t\tspew.Sdump(a.ShaChainRootDesc),\n\t\t\tspew.Sdump(b.ShaChainRootDesc))\n\t}\n\n\tif len(a.Addresses) != len(b.Addresses) {\n\t\tt.Fatalf(\"expected %v addrs got %v\", len(a.Addresses),\n\t\t\tlen(b.Addresses))\n\t}\n\tfor i := 0; i < len(a.Addresses); i++ {\n\t\tif a.Addresses[i].String() != b.Addresses[i].String() {\n\t\t\tt.Fatalf(\"addr mismatch: %v vs %v\",\n\t\t\t\ta.Addresses[i], b.Addresses[i])\n\t\t}\n\t}\n}\n",
      "length": 1708,
      "tokens": 182,
      "embedding": []
    },
    {
      "slug": "func genRandomOpenChannelShell() (*channeldb.OpenChannel, error) {",
      "content": "func genRandomOpenChannelShell() (*channeldb.OpenChannel, error) {\n\tvar testPriv [32]byte\n\tif _, err := rand.Read(testPriv[:]); err != nil {\n\t\treturn nil, err\n\t}\n\n\t_, pub := btcec.PrivKeyFromBytes(testPriv[:])\n\n\tvar chanPoint wire.OutPoint\n\tif _, err := rand.Read(chanPoint.Hash[:]); err != nil {\n\t\treturn nil, err\n\t}\n\n\tchanPoint.Index = uint32(rand.Intn(math.MaxUint16))\n\n\tvar shaChainRoot [32]byte\n\tif _, err := rand.Read(shaChainRoot[:]); err != nil {\n\t\treturn nil, err\n\t}\n\n\tshaChainProducer := shachain.NewRevocationProducer(shaChainRoot)\n\n\tvar isInitiator bool\n\tif rand.Int63()%2 == 0 {\n\t\tisInitiator = true\n\t}\n\n\tchanType := channeldb.ChannelType(rand.Intn(8))\n\n\treturn &channeldb.OpenChannel{\n\t\tChainHash:       chainHash,\n\t\tChanType:        chanType,\n\t\tIsInitiator:     isInitiator,\n\t\tFundingOutpoint: chanPoint,\n\t\tShortChannelID: lnwire.NewShortChanIDFromInt(\n\t\t\tuint64(rand.Int63()),\n\t\t),\n\t\tThawHeight:  rand.Uint32(),\n\t\tIdentityPub: pub,\n\t\tLocalChanCfg: channeldb.ChannelConfig{\n\t\t\tChannelConstraints: channeldb.ChannelConstraints{\n\t\t\t\tCsvDelay: uint16(rand.Int63()),\n\t\t\t},\n\t\t\tMultiSigKey: keychain.KeyDescriptor{\n\t\t\t\tKeyLocator: keychain.KeyLocator{\n\t\t\t\t\tFamily: keychain.KeyFamily(rand.Int63()),\n\t\t\t\t\tIndex:  uint32(rand.Int63()),\n\t\t\t\t},\n\t\t\t},\n\t\t\tRevocationBasePoint: keychain.KeyDescriptor{\n\t\t\t\tKeyLocator: keychain.KeyLocator{\n\t\t\t\t\tFamily: keychain.KeyFamily(rand.Int63()),\n\t\t\t\t\tIndex:  uint32(rand.Int63()),\n\t\t\t\t},\n\t\t\t},\n\t\t\tPaymentBasePoint: keychain.KeyDescriptor{\n\t\t\t\tKeyLocator: keychain.KeyLocator{\n\t\t\t\t\tFamily: keychain.KeyFamily(rand.Int63()),\n\t\t\t\t\tIndex:  uint32(rand.Int63()),\n\t\t\t\t},\n\t\t\t},\n\t\t\tDelayBasePoint: keychain.KeyDescriptor{\n\t\t\t\tKeyLocator: keychain.KeyLocator{\n\t\t\t\t\tFamily: keychain.KeyFamily(rand.Int63()),\n\t\t\t\t\tIndex:  uint32(rand.Int63()),\n\t\t\t\t},\n\t\t\t},\n\t\t\tHtlcBasePoint: keychain.KeyDescriptor{\n\t\t\t\tKeyLocator: keychain.KeyLocator{\n\t\t\t\t\tFamily: keychain.KeyFamily(rand.Int63()),\n\t\t\t\t\tIndex:  uint32(rand.Int63()),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tRemoteChanCfg: channeldb.ChannelConfig{\n\t\t\tChannelConstraints: channeldb.ChannelConstraints{\n\t\t\t\tCsvDelay: uint16(rand.Int63()),\n\t\t\t},\n\t\t\tMultiSigKey: keychain.KeyDescriptor{\n\t\t\t\tPubKey: pub,\n\t\t\t},\n\t\t\tRevocationBasePoint: keychain.KeyDescriptor{\n\t\t\t\tPubKey: pub,\n\t\t\t},\n\t\t\tPaymentBasePoint: keychain.KeyDescriptor{\n\t\t\t\tPubKey: pub,\n\t\t\t},\n\t\t\tDelayBasePoint: keychain.KeyDescriptor{\n\t\t\t\tPubKey: pub,\n\t\t\t},\n\t\t\tHtlcBasePoint: keychain.KeyDescriptor{\n\t\t\t\tPubKey: pub,\n\t\t\t},\n\t\t},\n\t\tRevocationProducer: shaChainProducer,\n\t}, nil\n}\n\n// TestSinglePackUnpack tests that we're able to unpack a previously packed\n// channel backup.",
      "length": 2422,
      "tokens": 201,
      "embedding": []
    },
    {
      "slug": "func TestSinglePackUnpack(t *testing.T) {",
      "content": "func TestSinglePackUnpack(t *testing.T) {\n\tt.Parallel()\n\n\t// Given our test pub key, we'll create an open channel shell that\n\t// contains all the information we need to create a static channel\n\t// backup.\n\tchannel, err := genRandomOpenChannelShell()\n\trequire.NoError(t, err, \"unable to gen open channel\")\n\n\tsingleChanBackup := NewSingle(channel, []net.Addr{addr1, addr2})\n\n\tkeyRing := &lnencrypt.MockKeyRing{}\n\n\tversionTestCases := []struct {\n\t\t// version is the pack/unpack version that we should use to\n\t\t// decode/encode the final SCB.\n\t\tversion SingleBackupVersion\n\n\t\t// valid tests us if this test case should pass or not.\n\t\tvalid bool\n\t}{\n\t\t// The default version, should pack/unpack with no problem.\n\t\t{\n\t\t\tversion: DefaultSingleVersion,\n\t\t\tvalid:   true,\n\t\t},\n\n\t\t// The new tweakless version, should pack/unpack with no\n\t\t// problem.\n\t\t{\n\t\t\tversion: TweaklessCommitVersion,\n\t\t\tvalid:   true,\n\t\t},\n\n\t\t// The new anchor version, should pack/unpack with no\n\t\t// problem.\n\t\t{\n\t\t\tversion: AnchorsCommitVersion,\n\t\t\tvalid:   true,\n\t\t},\n\n\t\t// The new script enforced channel lease version should\n\t\t// pack/unpack with no problem.\n\t\t{\n\t\t\tversion: ScriptEnforcedLeaseVersion,\n\t\t\tvalid:   true,\n\t\t},\n\n\t\t// A non-default version, atm this should result in a failure.\n\t\t{\n\t\t\tversion: 99,\n\t\t\tvalid:   false,\n\t\t},\n\t}\n\tfor i, versionCase := range versionTestCases {\n\t\t// First, we'll re-assign SCB version to what was indicated in\n\t\t// the test case.\n\t\tsingleChanBackup.Version = versionCase.version\n\n\t\tvar b bytes.Buffer\n\n\t\terr := singleChanBackup.PackToWriter(&b, keyRing)\n\t\tswitch {\n\t\t// If this is a valid test case, and we failed, then we'll\n\t\t// return an error.\n\t\tcase err != nil && versionCase.valid:\n\t\t\tt.Fatalf(\"#%v, unable to pack single: %v\", i, err)\n\n\t\t// If this is an invalid test case, and we passed it, then\n\t\t// we'll return an error.\n\t\tcase err == nil && !versionCase.valid:\n\t\t\tt.Fatalf(\"#%v got nil error for invalid pack: %v\",\n\t\t\t\ti, err)\n\t\t}\n\n\t\t// If this is a valid test case, then we'll continue to ensure\n\t\t// we can unpack it, and also that if we mutate the packed\n\t\t// version, then we trigger an error.\n\t\tif versionCase.valid {\n\t\t\tvar unpackedSingle Single\n\t\t\terr = unpackedSingle.UnpackFromReader(&b, keyRing)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"#%v unable to unpack single: %v\",\n\t\t\t\t\ti, err)\n\t\t\t}\n\n\t\t\tassertSingleEqual(t, singleChanBackup, unpackedSingle)\n\n\t\t\t// If this was a valid packing attempt, then we'll test\n\t\t\t// to ensure that if we mutate the version prepended to\n\t\t\t// the serialization, then unpacking will fail as well.\n\t\t\tvar rawSingle bytes.Buffer\n\t\t\terr := unpackedSingle.Serialize(&rawSingle)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to serialize single: %v\", err)\n\t\t\t}\n\n\t\t\t// Mutate the version byte to an unknown version.\n\t\t\trawBytes := rawSingle.Bytes()\n\t\t\trawBytes[0] = ^uint8(0)\n\n\t\t\tnewReader := bytes.NewReader(rawBytes)\n\t\t\terr = unpackedSingle.Deserialize(newReader)\n\t\t\tif err == nil {\n\t\t\t\tt.Fatalf(\"#%v unpack with unknown version \"+\n\t\t\t\t\t\"should have failed\", i)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// TestPackedSinglesUnpack tests that we're able to properly unpack a series of\n// packed singles.",
      "length": 2968,
      "tokens": 435,
      "embedding": []
    },
    {
      "slug": "func TestPackedSinglesUnpack(t *testing.T) {",
      "content": "func TestPackedSinglesUnpack(t *testing.T) {\n\tt.Parallel()\n\n\tkeyRing := &lnencrypt.MockKeyRing{}\n\n\t// To start, we'll create 10 new singles, and them assemble their\n\t// packed forms into a slice.\n\tnumSingles := 10\n\tpackedSingles := make([][]byte, 0, numSingles)\n\tunpackedSingles := make([]Single, 0, numSingles)\n\tfor i := 0; i < numSingles; i++ {\n\t\tchannel, err := genRandomOpenChannelShell()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to gen channel: %v\", err)\n\t\t}\n\n\t\tsingle := NewSingle(channel, nil)\n\n\t\tvar b bytes.Buffer\n\t\tif err := single.PackToWriter(&b, keyRing); err != nil {\n\t\t\tt.Fatalf(\"unable to pack single: %v\", err)\n\t\t}\n\n\t\tpackedSingles = append(packedSingles, b.Bytes())\n\t\tunpackedSingles = append(unpackedSingles, single)\n\t}\n\n\t// With all singles packed, we'll create the grouped type and attempt\n\t// to Unpack all of them in a single go.\n\tfreshSingles, err := PackedSingles(packedSingles).Unpack(keyRing)\n\trequire.NoError(t, err, \"unable to unpack singles\")\n\n\t// The set of freshly unpacked singles should exactly match the initial\n\t// set of singles that we packed before.\n\tfor i := 0; i < len(unpackedSingles); i++ {\n\t\tassertSingleEqual(t, unpackedSingles[i], freshSingles[i])\n\t}\n\n\t// If we mutate one of the packed singles, then the entire method\n\t// should fail.\n\tpackedSingles[0][0] ^= 1\n\t_, err = PackedSingles(packedSingles).Unpack(keyRing)\n\tif err == nil {\n\t\tt.Fatalf(\"unpack attempt should fail\")\n\t}\n}\n\n// TestSinglePackStaticChanBackups tests that we're able to batch pack a set of\n// Singles, and then unpack them obtaining the same set of unpacked singles.",
      "length": 1488,
      "tokens": 216,
      "embedding": []
    },
    {
      "slug": "func TestSinglePackStaticChanBackups(t *testing.T) {",
      "content": "func TestSinglePackStaticChanBackups(t *testing.T) {\n\tt.Parallel()\n\n\tkeyRing := &lnencrypt.MockKeyRing{}\n\n\t// First, we'll create a set of random single, and along the way,\n\t// create a map that will let us look up each single by its chan point.\n\tnumSingles := 10\n\tsingleMap := make(map[wire.OutPoint]Single, numSingles)\n\tunpackedSingles := make([]Single, 0, numSingles)\n\tfor i := 0; i < numSingles; i++ {\n\t\tchannel, err := genRandomOpenChannelShell()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to gen channel: %v\", err)\n\t\t}\n\n\t\tsingle := NewSingle(channel, nil)\n\n\t\tsingleMap[channel.FundingOutpoint] = single\n\t\tunpackedSingles = append(unpackedSingles, single)\n\t}\n\n\t// Now that we have all of our singles are created, we'll attempt to\n\t// pack them all in a single batch.\n\tpackedSingleMap, err := PackStaticChanBackups(unpackedSingles, keyRing)\n\trequire.NoError(t, err, \"unable to pack backups\")\n\n\t// With our packed singles obtained, we'll ensure that each of them\n\t// match their unpacked counterparts after they themselves have been\n\t// unpacked.\n\tfor chanPoint, single := range singleMap {\n\t\tpackedSingles, ok := packedSingleMap[chanPoint]\n\t\tif !ok {\n\t\t\tt.Fatalf(\"unable to find single %v\", chanPoint)\n\t\t}\n\n\t\tvar freshSingle Single\n\t\terr := freshSingle.UnpackFromReader(\n\t\t\tbytes.NewReader(packedSingles), keyRing,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to unpack single: %v\", err)\n\t\t}\n\n\t\tassertSingleEqual(t, single, freshSingle)\n\t}\n\n\t// If we attempt to pack again, but force the key ring to fail, then\n\t// the entire method should fail.\n\tkeyRing.Fail = true\n\t_, err = PackStaticChanBackups(\n\t\tunpackedSingles, &lnencrypt.MockKeyRing{Fail: true},\n\t)\n\tif err == nil {\n\t\tt.Fatalf(\"pack attempt should fail\")\n\t}\n}\n\n// TestSingleUnconfirmedChannel tests that unconfirmed channels get serialized\n// correctly by encoding the funding broadcast height as block height of the\n// short channel ID.",
      "length": 1780,
      "tokens": 253,
      "embedding": []
    },
    {
      "slug": "func TestSingleUnconfirmedChannel(t *testing.T) {",
      "content": "func TestSingleUnconfirmedChannel(t *testing.T) {\n\tt.Parallel()\n\n\tvar fundingBroadcastHeight = uint32(1234)\n\n\t// Let's create an open channel shell that contains all the information\n\t// we need to create a static channel backup but simulate an\n\t// unconfirmed channel by setting the block height to 0.\n\tchannel, err := genRandomOpenChannelShell()\n\trequire.NoError(t, err, \"unable to gen open channel\")\n\tchannel.ShortChannelID.BlockHeight = 0\n\tchannel.FundingBroadcastHeight = fundingBroadcastHeight\n\n\tsingleChanBackup := NewSingle(channel, []net.Addr{addr1, addr2})\n\tkeyRing := &lnencrypt.MockKeyRing{}\n\n\t// Pack it and then unpack it again to make sure everything is written\n\t// correctly, then check that the block height of the unpacked\n\t// is the funding broadcast height we set before.\n\tvar b bytes.Buffer\n\tif err := singleChanBackup.PackToWriter(&b, keyRing); err != nil {\n\t\tt.Fatalf(\"unable to pack single: %v\", err)\n\t}\n\tvar unpackedSingle Single\n\terr = unpackedSingle.UnpackFromReader(&b, keyRing)\n\trequire.NoError(t, err, \"unable to unpack single\")\n\tif unpackedSingle.ShortChannelID.BlockHeight != fundingBroadcastHeight {\n\t\tt.Fatalf(\"invalid block height. got %d expected %d.\",\n\t\t\tunpackedSingle.ShortChannelID.BlockHeight,\n\t\t\tfundingBroadcastHeight)\n\t}\n}\n\n// TODO(roasbsef): fuzz parsing\n",
      "length": 1216,
      "tokens": 150,
      "embedding": []
    }
  ]
}