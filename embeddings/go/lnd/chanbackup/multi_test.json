{
  "filepath": "../implementations/go/lnd/chanbackup/multi_test.go",
  "package": "chanbackup",
  "sections": [
    {
      "slug": "func TestMultiPackUnpack(t *testing.T) {",
      "content": "func TestMultiPackUnpack(t *testing.T) {\n\tt.Parallel()\n\n\tvar multi Multi\n\tnumSingles := 10\n\toriginalSingles := make([]Single, 0, numSingles)\n\tfor i := 0; i < numSingles; i++ {\n\t\tchannel, err := genRandomOpenChannelShell()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to gen channel: %v\", err)\n\t\t}\n\n\t\tsingle := NewSingle(channel, []net.Addr{addr1, addr2})\n\n\t\toriginalSingles = append(originalSingles, single)\n\t\tmulti.StaticBackups = append(multi.StaticBackups, single)\n\t}\n\n\tkeyRing := &lnencrypt.MockKeyRing{}\n\n\tversionTestCases := []struct {\n\t\t// version is the pack/unpack version that we should use to\n\t\t// decode/encode the final SCB.\n\t\tversion MultiBackupVersion\n\n\t\t// valid tests us if this test case should pass or not.\n\t\tvalid bool\n\t}{\n\t\t// The default version, should pack/unpack with no problem.\n\t\t{\n\t\t\tversion: DefaultSingleVersion,\n\t\t\tvalid:   true,\n\t\t},\n\n\t\t// A non-default version, atm this should result in a failure.\n\t\t{\n\t\t\tversion: 99,\n\t\t\tvalid:   false,\n\t\t},\n\t}\n\tfor i, versionCase := range versionTestCases {\n\t\tmulti.Version = versionCase.version\n\n\t\tvar b bytes.Buffer\n\t\terr := multi.PackToWriter(&b, keyRing)\n\t\tswitch {\n\t\t// If this is a valid test case, and we failed, then we'll\n\t\t// return an error.\n\t\tcase err != nil && versionCase.valid:\n\t\t\tt.Fatalf(\"#%v, unable to pack multi: %v\", i, err)\n\n\t\t// If this is an invalid test case, and we passed it, then\n\t\t// we'll return an error.\n\t\tcase err == nil && !versionCase.valid:\n\t\t\tt.Fatalf(\"#%v got nil error for invalid pack: %v\",\n\t\t\t\ti, err)\n\t\t}\n\n\t\t// If this is a valid test case, then we'll continue to ensure\n\t\t// we can unpack it, and also that if we mutate the packed\n\t\t// version, then we trigger an error.\n\t\tif versionCase.valid {\n\t\t\tvar unpackedMulti Multi\n\t\t\terr = unpackedMulti.UnpackFromReader(&b, keyRing)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"#%v unable to unpack multi: %v\",\n\t\t\t\t\ti, err)\n\t\t\t}\n\n\t\t\t// First, we'll ensure that the unpacked version of the\n\t\t\t// packed multi is the same as the original set.\n\t\t\tif len(originalSingles) !=\n\t\t\t\tlen(unpackedMulti.StaticBackups) {\n\t\t\t\tt.Fatalf(\"expected %v singles, got %v\",\n\t\t\t\t\tlen(originalSingles),\n\t\t\t\t\tlen(unpackedMulti.StaticBackups))\n\t\t\t}\n\t\t\tfor i := 0; i < numSingles; i++ {\n\t\t\t\tassertSingleEqual(\n\t\t\t\t\tt, originalSingles[i],\n\t\t\t\t\tunpackedMulti.StaticBackups[i],\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tencrypter, err := lnencrypt.KeyRingEncrypter(keyRing)\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// Next, we'll make a fake packed multi, it'll have an\n\t\t\t// unknown version relative to what's implemented atm.\n\t\t\tvar fakePackedMulti bytes.Buffer\n\t\t\tfakeRawMulti := bytes.NewBuffer(\n\t\t\t\tbytes.Repeat([]byte{99}, 20),\n\t\t\t)\n\t\t\terr = encrypter.EncryptPayloadToWriter(\n\t\t\t\tfakeRawMulti.Bytes(), &fakePackedMulti,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to pack fake multi; %v\", err)\n\t\t\t}\n\n\t\t\t// We should reject this fake multi as it contains an\n\t\t\t// unknown version.\n\t\t\terr = unpackedMulti.UnpackFromReader(\n\t\t\t\t&fakePackedMulti, keyRing,\n\t\t\t)\n\t\t\tif err == nil {\n\t\t\t\tt.Fatalf(\"#%v unpack with unknown version \"+\n\t\t\t\t\t\"should have failed\", i)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// TestPackedMultiUnpack tests that we're able to properly unpack a typed\n// packed multi.",
      "length": 2984,
      "tokens": 420,
      "embedding": []
    },
    {
      "slug": "func TestPackedMultiUnpack(t *testing.T) {",
      "content": "func TestPackedMultiUnpack(t *testing.T) {\n\tt.Parallel()\n\n\tkeyRing := &lnencrypt.MockKeyRing{}\n\n\t// First, we'll make a new unpacked multi with a random channel.\n\ttestChannel, err := genRandomOpenChannelShell()\n\trequire.NoError(t, err, \"unable to gen random channel\")\n\tvar multi Multi\n\tmulti.StaticBackups = append(\n\t\tmulti.StaticBackups, NewSingle(testChannel, nil),\n\t)\n\n\t// Now that we have our multi, we'll pack it into a new buffer.\n\tvar b bytes.Buffer\n\tif err := multi.PackToWriter(&b, keyRing); err != nil {\n\t\tt.Fatalf(\"unable to pack multi: %v\", err)\n\t}\n\n\t// We should be able to properly unpack this typed packed multi.\n\tpackedMulti := PackedMulti(b.Bytes())\n\tunpackedMulti, err := packedMulti.Unpack(keyRing)\n\trequire.NoError(t, err, \"unable to unpack multi\")\n\n\t// Finally, the versions should match, and the unpacked singles also\n\t// identical.\n\tif multi.Version != unpackedMulti.Version {\n\t\tt.Fatalf(\"version mismatch: expected %v got %v\",\n\t\t\tmulti.Version, unpackedMulti.Version)\n\t}\n\tassertSingleEqual(\n\t\tt, multi.StaticBackups[0], unpackedMulti.StaticBackups[0],\n\t)\n}\n",
      "length": 1005,
      "tokens": 128,
      "embedding": []
    }
  ]
}