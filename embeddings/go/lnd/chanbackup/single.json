{
  "filepath": "../implementations/go/lnd/chanbackup/single.go",
  "package": "chanbackup",
  "sections": [
    {
      "slug": "type SingleBackupVersion byte",
      "content": "type SingleBackupVersion byte\n\nconst (\n\t// DefaultSingleVersion is the default version of the single channel\n\t// backup. The serialized version of this static channel backup is\n\t// simply: version || SCB. Where SCB is the known format of the\n\t// version.\n\tDefaultSingleVersion = 0\n\n\t// TweaklessCommitVersion is the second SCB version. This version\n\t// implicitly denotes that this channel uses the new tweakless commit\n\t// format.\n\tTweaklessCommitVersion = 1\n\n\t// AnchorsCommitVersion is the third SCB version. This version\n\t// implicitly denotes that this channel uses the new anchor commitment\n\t// format.\n\tAnchorsCommitVersion = 2\n\n\t// AnchorsZeroFeeHtlcTxCommitVersion is a version that denotes this\n\t// channel is using the zero-fee second-level anchor commitment format.\n\tAnchorsZeroFeeHtlcTxCommitVersion = 3\n\n\t// ScriptEnforcedLeaseVersion is a version that denotes this channel is\n\t// using the zero-fee second-level anchor commitment format along with\n\t// an additional CLTV requirement of the channel lease maturity on any\n\t// commitment and HTLC outputs that pay directly to the channel\n\t// initiator.\n\tScriptEnforcedLeaseVersion = 4\n)\n\n// Single is a static description of an existing channel that can be used for\n// the purposes of backing up. The fields in this struct allow a node to\n// recover the settled funds within a channel in the case of partial or\n// complete data loss. We provide the network address that we last used to\n// connect to the peer as well, in case the node stops advertising the IP on\n// the network for whatever reason.\n//\n// TODO(roasbeef): suffix version into struct?",
      "length": 1543,
      "tokens": 248,
      "embedding": []
    },
    {
      "slug": "type Single struct {",
      "content": "type Single struct {\n\t// Version is the version that should be observed when attempting to\n\t// pack the single backup.\n\tVersion SingleBackupVersion\n\n\t// IsInitiator is true if we were the initiator of the channel, and\n\t// false otherwise. We'll need to know this information in order to\n\t// properly re-derive the state hint information.\n\tIsInitiator bool\n\n\t// ChainHash is a hash which represents the blockchain that this\n\t// channel will be opened within. This value is typically the genesis\n\t// hash. In the case that the original chain went through a contentious\n\t// hard-fork, then this value will be tweaked using the unique fork\n\t// point on each branch.\n\tChainHash chainhash.Hash\n\n\t// FundingOutpoint is the outpoint of the final funding transaction.\n\t// This value uniquely and globally identities the channel within the\n\t// target blockchain as specified by the chain hash parameter.\n\tFundingOutpoint wire.OutPoint\n\n\t// ShortChannelID encodes the exact location in the chain in which the\n\t// channel was initially confirmed. This includes: the block height,\n\t// transaction index, and the output within the target transaction.\n\t// Channels that were not confirmed at the time of backup creation will\n\t// have the funding TX broadcast height set as their block height in\n\t// the ShortChannelID.\n\tShortChannelID lnwire.ShortChannelID\n\n\t// RemoteNodePub is the identity public key of the remote node this\n\t// channel has been established with.\n\tRemoteNodePub *btcec.PublicKey\n\n\t// Addresses is a list of IP address in which either we were able to\n\t// reach the node over in the past, OR we received an incoming\n\t// authenticated connection for the stored identity public key.\n\tAddresses []net.Addr\n\n\t// Capacity is the size of the original channel.\n\tCapacity btcutil.Amount\n\n\t// LocalChanCfg is our local channel configuration. It contains all the\n\t// information we need to re-derive the keys we used within the\n\t// channel. Most importantly, it allows to derive the base public\n\t// that's used to deriving the key used within the non-delayed\n\t// pay-to-self output on the commitment transaction for a node. With\n\t// this information, we can re-derive the private key needed to sweep\n\t// the funds on-chain.\n\t//\n\t// NOTE: Of the items in the ChannelConstraints, we only write the CSV\n\t// delay.\n\tLocalChanCfg channeldb.ChannelConfig\n\n\t// RemoteChanCfg is the remote channel confirmation. We store this as\n\t// well since we'll need some of their keys to re-derive things like\n\t// the state hint obfuscator which will allow us to recognize the state\n\t// their broadcast on chain.\n\t//\n\t// NOTE: Of the items in the ChannelConstraints, we only write the CSV\n\t// delay.\n\tRemoteChanCfg channeldb.ChannelConfig\n\n\t// ShaChainRootDesc describes how to derive the private key that was\n\t// used as the shachain root for this channel.\n\tShaChainRootDesc keychain.KeyDescriptor\n\n\t// LeaseExpiry represents the absolute expiration as a height of the\n\t// chain of a channel lease that is applied to every output that pays\n\t// directly to the channel initiator in addition to the usual CSV\n\t// requirement.\n\t//\n\t// NOTE: This field will only be present for the following versions:\n\t//\n\t// - ScriptEnforcedLeaseVersion\n\tLeaseExpiry uint32\n}\n\n// NewSingle creates a new static channel backup based on an existing open\n// channel. We also pass in the set of addresses that we used in the past to\n// connect to the channel peer.",
      "length": 3315,
      "tokens": 541,
      "embedding": []
    },
    {
      "slug": "func NewSingle(channel *channeldb.OpenChannel,",
      "content": "func NewSingle(channel *channeldb.OpenChannel,\n\tnodeAddrs []net.Addr) Single {\n\n\tvar shaChainRootDesc keychain.KeyDescriptor\n\n\t// If the channel has a populated RevocationKeyLocator, then we can\n\t// just store that instead of the public key.\n\tif channel.RevocationKeyLocator.Family == keychain.KeyFamilyRevocationRoot {\n\t\tshaChainRootDesc = keychain.KeyDescriptor{\n\t\t\tKeyLocator: channel.RevocationKeyLocator,\n\t\t}\n\t} else {\n\t\t// If the RevocationKeyLocator is not populated, then we'll need\n\t\t// to obtain a public point for the shachain root and store that.\n\t\t// This is the legacy scheme.\n\t\tvar b bytes.Buffer\n\t\t_ = channel.RevocationProducer.Encode(&b) // Can't return an error.\n\n\t\t// Once we have the root, we'll make a public key from it, such that\n\t\t// the backups plaintext don't carry any private information. When\n\t\t// we go to recover, we'll present this in order to derive the\n\t\t// private key.\n\t\t_, shaChainPoint := btcec.PrivKeyFromBytes(b.Bytes())\n\n\t\tshaChainRootDesc = keychain.KeyDescriptor{\n\t\t\tPubKey: shaChainPoint,\n\t\t\tKeyLocator: keychain.KeyLocator{\n\t\t\t\tFamily: keychain.KeyFamilyRevocationRoot,\n\t\t\t},\n\t\t}\n\t}\n\n\t// If a channel is unconfirmed, the block height of the ShortChannelID\n\t// is zero. This will lead to problems when trying to restore that\n\t// channel as the spend notifier would get a height hint of zero.\n\t// To work around that problem, we add the channel broadcast height\n\t// to the channel ID so we can use that as height hint on restore.\n\tchanID := channel.ShortChanID()\n\tif chanID.BlockHeight == 0 {\n\t\tchanID.BlockHeight = channel.BroadcastHeight()\n\t}\n\n\t// If this is a zero-conf channel, we'll need to have separate logic\n\t// depending on whether it's confirmed or not. This is because the\n\t// ShortChanID is an alias.\n\tif channel.IsZeroConf() {\n\t\t// If the channel is confirmed, we'll use the confirmed SCID.\n\t\tif channel.ZeroConfConfirmed() {\n\t\t\tchanID = channel.ZeroConfRealScid()\n\t\t} else {\n\t\t\t// Else if the zero-conf channel is unconfirmed, we'll\n\t\t\t// need to use the broadcast height and zero out the\n\t\t\t// TxIndex and TxPosition fields. This is so\n\t\t\t// openChannelShell works properly.\n\t\t\tchanID.BlockHeight = channel.BroadcastHeight()\n\t\t\tchanID.TxIndex = 0\n\t\t\tchanID.TxPosition = 0\n\t\t}\n\t}\n\n\tsingle := Single{\n\t\tIsInitiator:      channel.IsInitiator,\n\t\tChainHash:        channel.ChainHash,\n\t\tFundingOutpoint:  channel.FundingOutpoint,\n\t\tShortChannelID:   chanID,\n\t\tRemoteNodePub:    channel.IdentityPub,\n\t\tAddresses:        nodeAddrs,\n\t\tCapacity:         channel.Capacity,\n\t\tLocalChanCfg:     channel.LocalChanCfg,\n\t\tRemoteChanCfg:    channel.RemoteChanCfg,\n\t\tShaChainRootDesc: shaChainRootDesc,\n\t}\n\n\tswitch {\n\tcase channel.ChanType.HasLeaseExpiration():\n\t\tsingle.Version = ScriptEnforcedLeaseVersion\n\t\tsingle.LeaseExpiry = channel.ThawHeight\n\n\tcase channel.ChanType.ZeroHtlcTxFee():\n\t\tsingle.Version = AnchorsZeroFeeHtlcTxCommitVersion\n\n\tcase channel.ChanType.HasAnchors():\n\t\tsingle.Version = AnchorsCommitVersion\n\n\tcase channel.ChanType.IsTweakless():\n\t\tsingle.Version = TweaklessCommitVersion\n\n\tdefault:\n\t\tsingle.Version = DefaultSingleVersion\n\t}\n\n\treturn single\n}\n\n// Serialize attempts to write out the serialized version of the target\n// StaticChannelBackup into the passed io.Writer.",
      "length": 3097,
      "tokens": 386,
      "embedding": []
    },
    {
      "slug": "func (s *Single) Serialize(w io.Writer) error {",
      "content": "func (s *Single) Serialize(w io.Writer) error {\n\t// Check to ensure that we'll only attempt to serialize a version that\n\t// we're aware of.\n\tswitch s.Version {\n\tcase DefaultSingleVersion:\n\tcase TweaklessCommitVersion:\n\tcase AnchorsCommitVersion:\n\tcase AnchorsZeroFeeHtlcTxCommitVersion:\n\tcase ScriptEnforcedLeaseVersion:\n\tdefault:\n\t\treturn fmt.Errorf(\"unable to serialize w/ unknown \"+\n\t\t\t\"version: %v\", s.Version)\n\t}\n\n\t// If the sha chain root has specified a public key (which is\n\t// optional), then we'll encode it now.\n\tvar shaChainPub [33]byte\n\tif s.ShaChainRootDesc.PubKey != nil {\n\t\tcopy(\n\t\t\tshaChainPub[:],\n\t\t\ts.ShaChainRootDesc.PubKey.SerializeCompressed(),\n\t\t)\n\t}\n\n\t// First we gather the SCB as is into a temporary buffer so we can\n\t// determine the total length. Before we write out the serialized SCB,\n\t// we write the length which allows us to skip any Singles that we\n\t// don't know of when decoding a multi.\n\tvar singleBytes bytes.Buffer\n\tif err := lnwire.WriteElements(\n\t\t&singleBytes,\n\t\ts.IsInitiator,\n\t\ts.ChainHash[:],\n\t\ts.FundingOutpoint,\n\t\ts.ShortChannelID,\n\t\ts.RemoteNodePub,\n\t\ts.Addresses,\n\t\ts.Capacity,\n\n\t\ts.LocalChanCfg.CsvDelay,\n\n\t\t// We only need to write out the KeyLocator portion of the\n\t\t// local channel config.\n\t\tuint32(s.LocalChanCfg.MultiSigKey.Family),\n\t\ts.LocalChanCfg.MultiSigKey.Index,\n\t\tuint32(s.LocalChanCfg.RevocationBasePoint.Family),\n\t\ts.LocalChanCfg.RevocationBasePoint.Index,\n\t\tuint32(s.LocalChanCfg.PaymentBasePoint.Family),\n\t\ts.LocalChanCfg.PaymentBasePoint.Index,\n\t\tuint32(s.LocalChanCfg.DelayBasePoint.Family),\n\t\ts.LocalChanCfg.DelayBasePoint.Index,\n\t\tuint32(s.LocalChanCfg.HtlcBasePoint.Family),\n\t\ts.LocalChanCfg.HtlcBasePoint.Index,\n\n\t\ts.RemoteChanCfg.CsvDelay,\n\n\t\t// We only need to write out the raw pubkey for the remote\n\t\t// channel config.\n\t\ts.RemoteChanCfg.MultiSigKey.PubKey,\n\t\ts.RemoteChanCfg.RevocationBasePoint.PubKey,\n\t\ts.RemoteChanCfg.PaymentBasePoint.PubKey,\n\t\ts.RemoteChanCfg.DelayBasePoint.PubKey,\n\t\ts.RemoteChanCfg.HtlcBasePoint.PubKey,\n\n\t\tshaChainPub[:],\n\t\tuint32(s.ShaChainRootDesc.KeyLocator.Family),\n\t\ts.ShaChainRootDesc.KeyLocator.Index,\n\t); err != nil {\n\t\treturn err\n\t}\n\tif s.Version == ScriptEnforcedLeaseVersion {\n\t\terr := lnwire.WriteElements(&singleBytes, s.LeaseExpiry)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// TODO(yy): remove the type assertion when we finished refactoring db\n\t// into using write buffer.\n\tbuf, ok := w.(*bytes.Buffer)\n\tif !ok {\n\t\treturn fmt.Errorf(\"expect io.Writer to be *bytes.Buffer\")\n\t}\n\n\treturn lnwire.WriteElements(\n\t\tbuf,\n\t\tbyte(s.Version),\n\t\tuint16(len(singleBytes.Bytes())),\n\t\tsingleBytes.Bytes(),\n\t)\n}\n\n// PackToWriter is similar to the Serialize method, but takes the operation a\n// step further by encryption the raw bytes of the static channel back up. For\n// encryption we use the chacah20poly1305 AEAD cipher with a 24 byte nonce and\n// 32-byte key size. We use a 24-byte nonce, as we can't ensure that we have a\n// global counter to use as a sequence number for nonces, and want to ensure\n// that we're able to decrypt these blobs without any additional context. We\n// derive the key that we use for encryption via a SHA2 operation of the with\n// the golden keychain.KeyFamilyBaseEncryption base encryption key.  We then\n// take the serialized resulting shared secret point, and hash it using sha256\n// to obtain the key that we'll use for encryption. When using the AEAD, we\n// pass the nonce as associated data such that we'll be able to package the two\n// together for storage. Before writing out the encrypted payload, we prepend\n// the nonce to the final blob.",
      "length": 3432,
      "tokens": 430,
      "embedding": []
    },
    {
      "slug": "func (s *Single) PackToWriter(w io.Writer, keyRing keychain.KeyRing) error {",
      "content": "func (s *Single) PackToWriter(w io.Writer, keyRing keychain.KeyRing) error {\n\t// First, we'll serialize the SCB (StaticChannelBackup) into a\n\t// temporary buffer so we can store it in a temporary place before we\n\t// go to encrypt the entire thing.\n\tvar rawBytes bytes.Buffer\n\tif err := s.Serialize(&rawBytes); err != nil {\n\t\treturn err\n\t}\n\n\t// Finally, we'll encrypt the raw serialized SCB (using the nonce as\n\t// associated data), and write out the ciphertext prepend with the\n\t// nonce that we used to the passed io.Reader.\n\te, err := lnencrypt.KeyRingEncrypter(keyRing)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to generate encrypt key %v\", err)\n\t}\n\treturn e.EncryptPayloadToWriter(rawBytes.Bytes(), w)\n}\n\n// readLocalKeyDesc reads a KeyDescriptor encoded within an unpacked Single.\n// For local KeyDescs, we only write out the KeyLocator information as we can\n// re-derive the pubkey from it.",
      "length": 802,
      "tokens": 128,
      "embedding": []
    },
    {
      "slug": "func readLocalKeyDesc(r io.Reader) (keychain.KeyDescriptor, error) {",
      "content": "func readLocalKeyDesc(r io.Reader) (keychain.KeyDescriptor, error) {\n\tvar keyDesc keychain.KeyDescriptor\n\n\tvar keyFam uint32\n\tif err := lnwire.ReadElements(r, &keyFam); err != nil {\n\t\treturn keyDesc, err\n\t}\n\tkeyDesc.Family = keychain.KeyFamily(keyFam)\n\n\tif err := lnwire.ReadElements(r, &keyDesc.Index); err != nil {\n\t\treturn keyDesc, err\n\t}\n\n\treturn keyDesc, nil\n}\n\n// readRemoteKeyDesc reads a remote KeyDescriptor encoded within an unpacked\n// Single. For remote KeyDescs, we write out only the PubKey since we don't\n// actually have the KeyLocator data.",
      "length": 471,
      "tokens": 69,
      "embedding": []
    },
    {
      "slug": "func readRemoteKeyDesc(r io.Reader) (keychain.KeyDescriptor, error) {",
      "content": "func readRemoteKeyDesc(r io.Reader) (keychain.KeyDescriptor, error) {\n\tvar (\n\t\tkeyDesc keychain.KeyDescriptor\n\t\tpub     [33]byte\n\t)\n\n\t_, err := io.ReadFull(r, pub[:])\n\tif err != nil {\n\t\treturn keychain.KeyDescriptor{}, err\n\t}\n\n\tkeyDesc.PubKey, err = btcec.ParsePubKey(pub[:])\n\tif err != nil {\n\t\treturn keychain.KeyDescriptor{}, err\n\t}\n\n\treturn keyDesc, nil\n}\n\n// Deserialize attempts to read the raw plaintext serialized SCB from the\n// passed io.Reader. If the method is successful, then the target\n// StaticChannelBackup will be fully populated.",
      "length": 457,
      "tokens": 67,
      "embedding": []
    },
    {
      "slug": "func (s *Single) Deserialize(r io.Reader) error {",
      "content": "func (s *Single) Deserialize(r io.Reader) error {\n\t// First, we'll need to read the version of this single-back up so we\n\t// can know how to unpack each of the SCB.\n\tvar version byte\n\terr := lnwire.ReadElements(r, &version)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.Version = SingleBackupVersion(version)\n\n\tswitch s.Version {\n\tcase DefaultSingleVersion:\n\tcase TweaklessCommitVersion:\n\tcase AnchorsCommitVersion:\n\tcase AnchorsZeroFeeHtlcTxCommitVersion:\n\tcase ScriptEnforcedLeaseVersion:\n\tdefault:\n\t\treturn fmt.Errorf(\"unable to de-serialize w/ unknown \"+\n\t\t\t\"version: %v\", s.Version)\n\t}\n\n\tvar length uint16\n\tif err := lnwire.ReadElements(r, &length); err != nil {\n\t\treturn err\n\t}\n\n\terr = lnwire.ReadElements(\n\t\tr, &s.IsInitiator, s.ChainHash[:], &s.FundingOutpoint,\n\t\t&s.ShortChannelID, &s.RemoteNodePub, &s.Addresses, &s.Capacity,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = lnwire.ReadElements(r, &s.LocalChanCfg.CsvDelay)\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.LocalChanCfg.MultiSigKey, err = readLocalKeyDesc(r)\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.LocalChanCfg.RevocationBasePoint, err = readLocalKeyDesc(r)\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.LocalChanCfg.PaymentBasePoint, err = readLocalKeyDesc(r)\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.LocalChanCfg.DelayBasePoint, err = readLocalKeyDesc(r)\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.LocalChanCfg.HtlcBasePoint, err = readLocalKeyDesc(r)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = lnwire.ReadElements(r, &s.RemoteChanCfg.CsvDelay)\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.RemoteChanCfg.MultiSigKey, err = readRemoteKeyDesc(r)\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.RemoteChanCfg.RevocationBasePoint, err = readRemoteKeyDesc(r)\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.RemoteChanCfg.PaymentBasePoint, err = readRemoteKeyDesc(r)\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.RemoteChanCfg.DelayBasePoint, err = readRemoteKeyDesc(r)\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.RemoteChanCfg.HtlcBasePoint, err = readRemoteKeyDesc(r)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Finally, we'll parse out the ShaChainRootDesc.\n\tvar (\n\t\tshaChainPub [33]byte\n\t\tzeroPub     [33]byte\n\t)\n\tif err := lnwire.ReadElements(r, shaChainPub[:]); err != nil {\n\t\treturn err\n\t}\n\n\t// Since this field is optional, we'll check to see if the pubkey has\n\t// been specified or not.\n\tif !bytes.Equal(shaChainPub[:], zeroPub[:]) {\n\t\ts.ShaChainRootDesc.PubKey, err = btcec.ParsePubKey(\n\t\t\tshaChainPub[:],\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tvar shaKeyFam uint32\n\tif err := lnwire.ReadElements(r, &shaKeyFam); err != nil {\n\t\treturn err\n\t}\n\ts.ShaChainRootDesc.KeyLocator.Family = keychain.KeyFamily(shaKeyFam)\n\terr = lnwire.ReadElements(r, &s.ShaChainRootDesc.KeyLocator.Index)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif s.Version == ScriptEnforcedLeaseVersion {\n\t\tif err := lnwire.ReadElement(r, &s.LeaseExpiry); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// UnpackFromReader is similar to Deserialize method, but it expects the passed\n// io.Reader to contain an encrypt SCB. Refer to the SerializeAndEncrypt method\n// for details w.r.t the encryption scheme used. If we're unable to decrypt the\n// payload for whatever reason (wrong key, wrong nonce, etc), then this method\n// will return an error.",
      "length": 3004,
      "tokens": 417,
      "embedding": []
    },
    {
      "slug": "func (s *Single) UnpackFromReader(r io.Reader, keyRing keychain.KeyRing) error {",
      "content": "func (s *Single) UnpackFromReader(r io.Reader, keyRing keychain.KeyRing) error {\n\te, err := lnencrypt.KeyRingEncrypter(keyRing)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to generate key decrypter %v\", err)\n\t}\n\tplaintext, err := e.DecryptPayloadFromReader(r)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Finally, we'll pack the bytes into a reader to we can deserialize\n\t// the plaintext bytes of the SCB.\n\tbackupReader := bytes.NewReader(plaintext)\n\treturn s.Deserialize(backupReader)\n}\n\n// PackStaticChanBackups accepts a set of existing open channels, and a\n// keychain.KeyRing, and returns a map of outpoints to the serialized+encrypted\n// static channel backups. The passed keyRing should be backed by the users\n// root HD seed in order to ensure full determinism.",
      "length": 665,
      "tokens": 101,
      "embedding": []
    },
    {
      "slug": "func PackStaticChanBackups(backups []Single,",
      "content": "func PackStaticChanBackups(backups []Single,\n\tkeyRing keychain.KeyRing) (map[wire.OutPoint][]byte, error) {\n\n\tpackedBackups := make(map[wire.OutPoint][]byte)\n\tfor _, chanBackup := range backups {\n\t\tchanPoint := chanBackup.FundingOutpoint\n\n\t\tvar b bytes.Buffer\n\t\terr := chanBackup.PackToWriter(&b, keyRing)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to pack chan backup \"+\n\t\t\t\t\"for %v: %v\", chanPoint, err)\n\t\t}\n\n\t\tpackedBackups[chanPoint] = b.Bytes()\n\t}\n\n\treturn packedBackups, nil\n}\n\n// PackedSingles represents a series of fully packed SCBs. This may be the\n// combination of a series of individual SCBs in order to batch their\n// unpacking.",
      "length": 585,
      "tokens": 80,
      "embedding": []
    },
    {
      "slug": "type PackedSingles [][]byte",
      "content": "type PackedSingles [][]byte\n\n// Unpack attempts to decrypt the passed set of encrypted SCBs and deserialize\n// each one into a new SCB struct. The passed keyRing should be backed by the\n// same HD seed as was used to encrypt the set of backups in the first place.\n// If we're unable to decrypt any of the back ups, then we'll return an error.",
      "length": 310,
      "tokens": 62,
      "embedding": []
    },
    {
      "slug": "func (p PackedSingles) Unpack(keyRing keychain.KeyRing) ([]Single, error) {",
      "content": "func (p PackedSingles) Unpack(keyRing keychain.KeyRing) ([]Single, error) {\n\n\tbackups := make([]Single, len(p))\n\tfor i, encryptedBackup := range p {\n\t\tvar backup Single\n\n\t\tbackupReader := bytes.NewReader(encryptedBackup)\n\t\terr := backup.UnpackFromReader(backupReader, keyRing)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tbackups[i] = backup\n\t}\n\n\treturn backups, nil\n}\n\n// TODO(roasbeef): make codec package?\n",
      "length": 314,
      "tokens": 43,
      "embedding": []
    }
  ]
}