{
  "filepath": "../implementations/go/lnd/chanbackup/backupfile_test.go",
  "package": "chanbackup",
  "sections": [
    {
      "slug": "func makeFakePackedMulti() (PackedMulti, error) {",
      "content": "func makeFakePackedMulti() (PackedMulti, error) {\n\tnewPackedMulti := make([]byte, 50)\n\tif _, err := rand.Read(newPackedMulti[:]); err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to make test backup: %v\", err)\n\t}\n\n\treturn PackedMulti(newPackedMulti), nil\n}\n",
      "length": 197,
      "tokens": 27,
      "embedding": []
    },
    {
      "slug": "func assertBackupMatches(t *testing.T, filePath string,",
      "content": "func assertBackupMatches(t *testing.T, filePath string,\n\tcurrentBackup PackedMulti) {\n\n\tt.Helper()\n\n\tpackedBackup, err := ioutil.ReadFile(filePath)\n\trequire.NoError(t, err, \"unable to test file\")\n\n\tif !bytes.Equal(packedBackup, currentBackup) {\n\t\tt.Fatalf(\"backups don't match after first swap: \"+\n\t\t\t\"expected %x got %x\", packedBackup[:],\n\t\t\tcurrentBackup)\n\t}\n}\n",
      "length": 294,
      "tokens": 33,
      "embedding": []
    },
    {
      "slug": "func assertFileDeleted(t *testing.T, filePath string) {",
      "content": "func assertFileDeleted(t *testing.T, filePath string) {\n\tt.Helper()\n\n\t_, err := os.Stat(filePath)\n\tif err == nil {\n\t\tt.Fatalf(\"file %v still exists: \", filePath)\n\t}\n}\n\n// TestUpdateAndSwap test that we're able to properly swap out old backups on\n// disk with new ones. Additionally, after a swap operation succeeds, then each\n// time we should only have the main backup file on disk, as the temporary file\n// has been removed.",
      "length": 359,
      "tokens": 64,
      "embedding": []
    },
    {
      "slug": "func TestUpdateAndSwap(t *testing.T) {",
      "content": "func TestUpdateAndSwap(t *testing.T) {\n\tt.Parallel()\n\n\ttempTestDir := t.TempDir()\n\n\ttestCases := []struct {\n\t\tfileName     string\n\t\ttempFileName string\n\n\t\toldTempExists bool\n\n\t\tvalid bool\n\t}{\n\t\t// Main file name is blank, should fail.\n\t\t{\n\t\t\tfileName: \"\",\n\t\t\tvalid:    false,\n\t\t},\n\n\t\t// Old temporary file still exists, should be removed. Only one\n\t\t// file should remain.\n\t\t{\n\t\t\tfileName: filepath.Join(\n\t\t\t\ttempTestDir, DefaultBackupFileName,\n\t\t\t),\n\t\t\ttempFileName: filepath.Join(\n\t\t\t\ttempTestDir, DefaultTempBackupFileName,\n\t\t\t),\n\t\t\toldTempExists: true,\n\t\t\tvalid:         true,\n\t\t},\n\n\t\t// Old temp doesn't exist, should swap out file, only a single\n\t\t// file remains.\n\t\t{\n\t\t\tfileName: filepath.Join(\n\t\t\t\ttempTestDir, DefaultBackupFileName,\n\t\t\t),\n\t\t\ttempFileName: filepath.Join(\n\t\t\t\ttempTestDir, DefaultTempBackupFileName,\n\t\t\t),\n\t\t\tvalid: true,\n\t\t},\n\t}\n\tfor i, testCase := range testCases {\n\t\tbackupFile := NewMultiFile(testCase.fileName)\n\n\t\t// To start with, we'll make a random byte slice that'll pose\n\t\t// as our packed multi backup.\n\t\tnewPackedMulti, err := makeFakePackedMulti()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to make test backup: %v\", err)\n\t\t}\n\n\t\t// If the old temporary file is meant to exist, then we'll\n\t\t// create it now as an empty file.\n\t\tif testCase.oldTempExists {\n\t\t\tf, err := os.Create(testCase.tempFileName)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to create temp file: %v\", err)\n\t\t\t}\n\t\t\trequire.NoError(t, f.Close())\n\n\t\t\t// TODO(roasbeef): mock out fs calls?\n\t\t}\n\n\t\t// With our backup created, we'll now attempt to swap out this\n\t\t// backup, for the old one.\n\t\terr = backupFile.UpdateAndSwap(PackedMulti(newPackedMulti))\n\t\tswitch {\n\t\t// If this is a valid test case, and we failed, then we'll\n\t\t// return an error.\n\t\tcase err != nil && testCase.valid:\n\t\t\tt.Fatalf(\"#%v, unable to swap file: %v\", i, err)\n\n\t\t// If this is an invalid test case, and we passed it, then\n\t\t// we'll return an error.\n\t\tcase err == nil && !testCase.valid:\n\t\t\tt.Fatalf(\"#%v file swap should have failed: %v\", i, err)\n\t\t}\n\n\t\tif !testCase.valid {\n\t\t\tcontinue\n\t\t}\n\n\t\t// If we read out the file on disk, then it should match\n\t\t// exactly what we wrote. The temp backup file should also be\n\t\t// gone.\n\t\tassertBackupMatches(t, testCase.fileName, newPackedMulti)\n\t\tassertFileDeleted(t, testCase.tempFileName)\n\n\t\t// Now that we know this is a valid test case, we'll make a new\n\t\t// packed multi to swap out this current one.\n\t\tnewPackedMulti2, err := makeFakePackedMulti()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to make test backup: %v\", err)\n\t\t}\n\n\t\t// We'll then attempt to swap the old version for this new one.\n\t\terr = backupFile.UpdateAndSwap(PackedMulti(newPackedMulti2))\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to swap file: %v\", err)\n\t\t}\n\n\t\t// Once again, the file written on disk should have been\n\t\t// properly swapped out with the new instance.\n\t\tassertBackupMatches(t, testCase.fileName, newPackedMulti2)\n\n\t\t// Additionally, we shouldn't be able to find the temp backup\n\t\t// file on disk, as it should be deleted each time.\n\t\tassertFileDeleted(t, testCase.tempFileName)\n\t}\n}\n",
      "length": 2924,
      "tokens": 428,
      "embedding": []
    },
    {
      "slug": "func assertMultiEqual(t *testing.T, a, b *Multi) {",
      "content": "func assertMultiEqual(t *testing.T, a, b *Multi) {\n\n\tif len(a.StaticBackups) != len(b.StaticBackups) {\n\t\tt.Fatalf(\"expected %v backups, got %v\", len(a.StaticBackups),\n\t\t\tlen(b.StaticBackups))\n\t}\n\n\tfor i := 0; i < len(a.StaticBackups); i++ {\n\t\tassertSingleEqual(t, a.StaticBackups[i], b.StaticBackups[i])\n\t}\n}\n\n// TestExtractMulti tests that given a valid packed multi file on disk, we're\n// able to read it multiple times repeatedly.",
      "length": 370,
      "tokens": 48,
      "embedding": []
    },
    {
      "slug": "func TestExtractMulti(t *testing.T) {",
      "content": "func TestExtractMulti(t *testing.T) {\n\tt.Parallel()\n\n\tkeyRing := &lnencrypt.MockKeyRing{}\n\n\t// First, as prep, we'll create a single chan backup, then pack that\n\t// fully into a multi backup.\n\tchannel, err := genRandomOpenChannelShell()\n\trequire.NoError(t, err, \"unable to gen chan\")\n\n\tsingleBackup := NewSingle(channel, nil)\n\n\tvar b bytes.Buffer\n\tunpackedMulti := Multi{\n\t\tStaticBackups: []Single{singleBackup},\n\t}\n\terr = unpackedMulti.PackToWriter(&b, keyRing)\n\trequire.NoError(t, err, \"unable to pack to writer\")\n\n\tpackedMulti := PackedMulti(b.Bytes())\n\n\t// Finally, we'll make a new temporary file, then write out the packed\n\t// multi directly to it.\n\ttempFile, err := os.CreateTemp(\"\", \"\")\n\trequire.NoError(t, err, \"unable to create temp file\")\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, tempFile.Close())\n\t\trequire.NoError(t, os.Remove(tempFile.Name()))\n\t})\n\n\t_, err = tempFile.Write(packedMulti)\n\trequire.NoError(t, err, \"unable to write temp file\")\n\tif err := tempFile.Sync(); err != nil {\n\t\tt.Fatalf(\"unable to sync temp file: %v\", err)\n\t}\n\n\ttestCases := []struct {\n\t\tfileName string\n\t\tpass     bool\n\t}{\n\t\t// Main file not read, file name not present.\n\t\t{\n\t\t\tfileName: \"\",\n\t\t\tpass:     false,\n\t\t},\n\n\t\t// Main file not read, file name is there, but file doesn't\n\t\t// exist.\n\t\t{\n\t\t\tfileName: \"kek\",\n\t\t\tpass:     false,\n\t\t},\n\n\t\t// Main file not read, should be able to read multiple times.\n\t\t{\n\t\t\tfileName: tempFile.Name(),\n\t\t\tpass:     true,\n\t\t},\n\t}\n\tfor i, testCase := range testCases {\n\t\t// First, we'll make our backup file with the specified name.\n\t\tbackupFile := NewMultiFile(testCase.fileName)\n\n\t\t// With our file made, we'll now attempt to read out the\n\t\t// multi-file.\n\t\tfreshUnpackedMulti, err := backupFile.ExtractMulti(keyRing)\n\t\tswitch {\n\t\t// If this is a valid test case, and we failed, then we'll\n\t\t// return an error.\n\t\tcase err != nil && testCase.pass:\n\t\t\tt.Fatalf(\"#%v, unable to extract file: %v\", i, err)\n\n\t\t\t// If this is an invalid test case, and we passed it, then\n\t\t\t// we'll return an error.\n\t\tcase err == nil && !testCase.pass:\n\t\t\tt.Fatalf(\"#%v file extraction should have \"+\n\t\t\t\t\"failed: %v\", i, err)\n\t\t}\n\n\t\tif !testCase.pass {\n\t\t\tcontinue\n\t\t}\n\n\t\t// We'll now ensure that the unpacked multi we read is\n\t\t// identical to the one we wrote out above.\n\t\tassertMultiEqual(t, &unpackedMulti, freshUnpackedMulti)\n\n\t\t// We should also be able to read the file again, as we have an\n\t\t// existing handle to it.\n\t\tfreshUnpackedMulti, err = backupFile.ExtractMulti(keyRing)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to unpack multi: %v\", err)\n\t\t}\n\n\t\tassertMultiEqual(t, &unpackedMulti, freshUnpackedMulti)\n\t}\n}\n",
      "length": 2492,
      "tokens": 363,
      "embedding": []
    }
  ]
}