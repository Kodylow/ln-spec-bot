{
  "filepath": "../implementations/go/lnd/chanbackup/pubsub.go",
  "package": "chanbackup",
  "sections": [
    {
      "slug": "type Swapper interface {",
      "content": "type Swapper interface {\n\t// UpdateAndSwap attempts to atomically update the main multi back up\n\t// file location with the new fully packed multi-channel backup.\n\tUpdateAndSwap(newBackup PackedMulti) error\n\n\t// ExtractMulti attempts to obtain and decode the current SCB instance\n\t// stored by the Swapper instance.\n\tExtractMulti(keychain keychain.KeyRing) (*Multi, error)\n}\n\n// ChannelWithAddrs bundles an open channel along with all the addresses for\n// the channel peer.",
      "length": 437,
      "tokens": 62,
      "embedding": []
    },
    {
      "slug": "type ChannelWithAddrs struct {",
      "content": "type ChannelWithAddrs struct {\n\t*channeldb.OpenChannel\n\n\t// Addrs is the set of addresses that we can use to reach the target\n\t// peer.\n\tAddrs []net.Addr\n}\n\n// ChannelEvent packages a new update of new channels since subscription, and\n// channels that have been opened since prior channel event.",
      "length": 256,
      "tokens": 43,
      "embedding": []
    },
    {
      "slug": "type ChannelEvent struct {",
      "content": "type ChannelEvent struct {\n\t// ClosedChans are the set of channels that have been closed since the\n\t// last event.\n\tClosedChans []wire.OutPoint\n\n\t// NewChans is the set of channels that have been opened since the last\n\t// event.\n\tNewChans []ChannelWithAddrs\n}\n\n// ChannelSubscription represents an intent to be notified of any updates to\n// the primary channel state.",
      "length": 330,
      "tokens": 54,
      "embedding": []
    },
    {
      "slug": "type ChannelSubscription struct {",
      "content": "type ChannelSubscription struct {\n\t// ChanUpdates is a channel that will be sent upon once the primary\n\t// channel state is updated.\n\tChanUpdates chan ChannelEvent\n\n\t// Cancel is a closure that allows the caller to cancel their\n\t// subscription and free up any resources allocated.\n\tCancel func()\n}\n\n// ChannelNotifier represents a system that allows the chanbackup.SubSwapper to\n// be notified of any changes to the primary channel state.",
      "length": 395,
      "tokens": 65,
      "embedding": []
    },
    {
      "slug": "type ChannelNotifier interface {",
      "content": "type ChannelNotifier interface {\n\t// SubscribeChans requests a new channel subscription relative to the\n\t// initial set of known channels. We use the knownChans as a\n\t// synchronization point to ensure that the chanbackup.SubSwapper does\n\t// not miss any channel open or close events in the period between when\n\t// it's created, and when it requests the channel subscription.\n\tSubscribeChans(map[wire.OutPoint]struct{}) (*ChannelSubscription, error)\n}\n\n// SubSwapper subscribes to new updates to the open channel state, and then\n// swaps out the on-disk channel backup state in response.  This sub-system\n// that will ensure that the multi chan backup file on disk will always be\n// updated with the latest channel back up state. We'll receive new\n// opened/closed channels from the ChannelNotifier, then use the Swapper to\n// update the file state on disk with the new set of open channels.  This can\n// be used to implement a system that always keeps the multi-chan backup file\n// on disk in a consistent state for safety purposes.",
      "length": 985,
      "tokens": 162,
      "embedding": []
    },
    {
      "slug": "type SubSwapper struct {",
      "content": "type SubSwapper struct {\n\tstarted sync.Once\n\tstopped sync.Once\n\n\t// backupState are the set of SCBs for all open channels we know of.\n\tbackupState map[wire.OutPoint]Single\n\n\t// chanEvents is an active subscription to receive new channel state\n\t// over.\n\tchanEvents *ChannelSubscription\n\n\t// keyRing is the main key ring that will allow us to pack the new\n\t// multi backup.\n\tkeyRing keychain.KeyRing\n\n\tSwapper\n\n\tquit chan struct{}\n\twg   sync.WaitGroup\n}\n\n// NewSubSwapper creates a new instance of the SubSwapper given the starting\n// set of channels, and the required interfaces to be notified of new channel\n// updates, pack a multi backup, and swap the current best backup from its\n// storage location.",
      "length": 656,
      "tokens": 105,
      "embedding": []
    },
    {
      "slug": "func NewSubSwapper(startingChans []Single, chanNotifier ChannelNotifier,",
      "content": "func NewSubSwapper(startingChans []Single, chanNotifier ChannelNotifier,\n\tkeyRing keychain.KeyRing, backupSwapper Swapper) (*SubSwapper, error) {\n\n\t// First, we'll subscribe to the latest set of channel updates given\n\t// the set of channels we already know of.\n\tknownChans := make(map[wire.OutPoint]struct{})\n\tfor _, chanBackup := range startingChans {\n\t\tknownChans[chanBackup.FundingOutpoint] = struct{}{}\n\t}\n\tchanEvents, err := chanNotifier.SubscribeChans(knownChans)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Next, we'll construct our own backup state so we can add/remove\n\t// channels that have been opened and closed.\n\tbackupState := make(map[wire.OutPoint]Single)\n\tfor _, chanBackup := range startingChans {\n\t\tbackupState[chanBackup.FundingOutpoint] = chanBackup\n\t}\n\n\treturn &SubSwapper{\n\t\tbackupState: backupState,\n\t\tchanEvents:  chanEvents,\n\t\tkeyRing:     keyRing,\n\t\tSwapper:     backupSwapper,\n\t\tquit:        make(chan struct{}),\n\t}, nil\n}\n\n// Start starts the chanbackup.SubSwapper.",
      "length": 891,
      "tokens": 110,
      "embedding": []
    },
    {
      "slug": "func (s *SubSwapper) Start() error {",
      "content": "func (s *SubSwapper) Start() error {\n\tvar startErr error\n\ts.started.Do(func() {\n\t\tlog.Infof(\"chanbackup.SubSwapper starting\")\n\n\t\t// Before we enter our main loop, we'll update the on-disk\n\t\t// state with the latest Single state, as nodes may have new\n\t\t// advertised addresses.\n\t\tif err := s.updateBackupFile(); err != nil {\n\t\t\tstartErr = fmt.Errorf(\"unable to refresh backup \"+\n\t\t\t\t\"file: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\ts.wg.Add(1)\n\t\tgo s.backupUpdater()\n\t})\n\n\treturn startErr\n}\n\n// Stop signals the SubSwapper to being a graceful shutdown.",
      "length": 480,
      "tokens": 70,
      "embedding": []
    },
    {
      "slug": "func (s *SubSwapper) Stop() error {",
      "content": "func (s *SubSwapper) Stop() error {\n\ts.stopped.Do(func() {\n\t\tlog.Infof(\"Stopping chanbackup.SubSwapper\")\n\n\t\tclose(s.quit)\n\t\ts.wg.Wait()\n\t})\n\treturn nil\n}\n\n// updateBackupFile updates the backup file in place given the current state of\n// the SubSwapper. We accept the set of channels that were closed between this\n// update and the last to make sure we leave them out of our backup set union.",
      "length": 345,
      "tokens": 54,
      "embedding": []
    },
    {
      "slug": "func (s *SubSwapper) updateBackupFile(closedChans ...wire.OutPoint) error {",
      "content": "func (s *SubSwapper) updateBackupFile(closedChans ...wire.OutPoint) error {\n\t// Before we pack the new set of SCBs, we'll first decode what we\n\t// already have on-disk, to make sure we can decode it (proper seed)\n\t// and that we're able to combine it with our new data.\n\tdiskMulti, err := s.Swapper.ExtractMulti(s.keyRing)\n\n\t// If the file doesn't exist on disk, then that's OK as it was never\n\t// created. In this case we'll continue onwards as it isn't a critical\n\t// error.\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn fmt.Errorf(\"unable to extract on disk encrypted \"+\n\t\t\t\"SCB: %v\", err)\n\t}\n\n\t// Now that we have channels stored on-disk, we'll create a new set of\n\t// the combined old and new channels to make sure we retain what's\n\t// already on-disk.\n\t//\n\t// NOTE: The ordering of this operations means that our in-memory\n\t// structure will replace what we read from disk.\n\tcombinedBackup := make(map[wire.OutPoint]Single)\n\tif diskMulti != nil {\n\t\tfor _, diskChannel := range diskMulti.StaticBackups {\n\t\t\tchanPoint := diskChannel.FundingOutpoint\n\t\t\tcombinedBackup[chanPoint] = diskChannel\n\t\t}\n\t}\n\tfor _, memChannel := range s.backupState {\n\t\tchanPoint := memChannel.FundingOutpoint\n\t\tif _, ok := combinedBackup[chanPoint]; ok {\n\t\t\tlog.Warnf(\"Replacing disk backup for ChannelPoint(%v) \"+\n\t\t\t\t\"w/ newer version\", chanPoint)\n\t\t}\n\n\t\tcombinedBackup[chanPoint] = memChannel\n\t}\n\n\t// Remove the set of closed channels from the final set of backups.\n\tfor _, closedChan := range closedChans {\n\t\tdelete(combinedBackup, closedChan)\n\t}\n\n\t// With our updated channel state obtained, we'll create a new multi\n\t// from our series of singles.\n\tvar newMulti Multi\n\tfor _, backup := range combinedBackup {\n\t\tnewMulti.StaticBackups = append(\n\t\t\tnewMulti.StaticBackups, backup,\n\t\t)\n\t}\n\n\t// Now that our multi has been assembled, we'll attempt to pack\n\t// (encrypt+encode) the new channel state to our target reader.\n\tvar b bytes.Buffer\n\terr = newMulti.PackToWriter(&b, s.keyRing)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to pack multi backup: %v\", err)\n\t}\n\n\t// Finally, we'll swap out the old backup for this new one in a single\n\t// atomic step, combining the file already on-disk with this set of new\n\t// channels.\n\terr = s.Swapper.UpdateAndSwap(PackedMulti(b.Bytes()))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to update multi backup: %v\", err)\n\t}\n\n\treturn nil\n}\n\n// backupFileUpdater is the primary goroutine of the SubSwapper which is\n// responsible for listening for changes to the channel, and updating the\n// persistent multi backup state with a new packed multi of the latest channel\n// state.",
      "length": 2450,
      "tokens": 388,
      "embedding": []
    },
    {
      "slug": "func (s *SubSwapper) backupUpdater() {",
      "content": "func (s *SubSwapper) backupUpdater() {\n\t// Ensure that once we exit, we'll cancel our active channel\n\t// subscription.\n\tdefer s.chanEvents.Cancel()\n\tdefer s.wg.Done()\n\n\tlog.Debugf(\"SubSwapper's backupUpdater is active!\")\n\n\tfor {\n\t\tselect {\n\t\t// The channel state has been modified! We'll evaluate all\n\t\t// changes, and swap out the old packed multi with a new one\n\t\t// with the latest channel state.\n\t\tcase chanUpdate := <-s.chanEvents.ChanUpdates:\n\t\t\toldStateSize := len(s.backupState)\n\n\t\t\t// For all new open channels, we'll create a new SCB\n\t\t\t// given the required information.\n\t\t\tfor _, newChan := range chanUpdate.NewChans {\n\t\t\t\tlog.Debugf(\"Adding channel %v to backup state\",\n\t\t\t\t\tnewChan.FundingOutpoint)\n\n\t\t\t\ts.backupState[newChan.FundingOutpoint] = NewSingle(\n\t\t\t\t\tnewChan.OpenChannel, newChan.Addrs,\n\t\t\t\t)\n\t\t\t}\n\n\t\t\t// For all closed channels, we'll remove the prior\n\t\t\t// backup state.\n\t\t\tclosedChans := make(\n\t\t\t\t[]wire.OutPoint, 0, len(chanUpdate.ClosedChans),\n\t\t\t)\n\t\t\tfor i, closedChan := range chanUpdate.ClosedChans {\n\t\t\t\tlog.Debugf(\"Removing channel %v from backup \"+\n\t\t\t\t\t\"state\", newLogClosure(func() string {\n\t\t\t\t\treturn chanUpdate.ClosedChans[i].String()\n\t\t\t\t}))\n\n\t\t\t\tdelete(s.backupState, closedChan)\n\n\t\t\t\tclosedChans = append(closedChans, closedChan)\n\t\t\t}\n\n\t\t\tnewStateSize := len(s.backupState)\n\n\t\t\tlog.Infof(\"Updating on-disk multi SCB backup: \"+\n\t\t\t\t\"num_old_chans=%v, num_new_chans=%v\",\n\t\t\t\toldStateSize, newStateSize)\n\n\t\t\t// With out new state constructed, we'll, atomically\n\t\t\t// update the on-disk backup state.\n\t\t\tif err := s.updateBackupFile(closedChans...); err != nil {\n\t\t\t\tlog.Errorf(\"unable to update backup file: %v\",\n\t\t\t\t\terr)\n\t\t\t}\n\n\t\t// TODO(roasbeef): refresh periodically on a time basis due to\n\t\t// possible addr changes from node\n\n\t\t// Exit at once if a quit signal is detected.\n\t\tcase <-s.quit:\n\t\t\treturn\n\t\t}\n\t}\n}\n",
      "length": 1754,
      "tokens": 219,
      "embedding": []
    }
  ]
}