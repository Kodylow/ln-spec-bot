{
  "filepath": "../implementations/go/lnd/chanbackup/backup.go",
  "package": "chanbackup",
  "sections": [
    {
      "slug": "type LiveChannelSource interface {",
      "content": "type LiveChannelSource interface {\n\t// FetchAllChannels returns all known live channels.\n\tFetchAllChannels() ([]*channeldb.OpenChannel, error)\n\n\t// FetchChannel attempts to locate a live channel identified by the\n\t// passed chanPoint. Optionally an existing db tx can be supplied.\n\tFetchChannel(tx kvdb.RTx, chanPoint wire.OutPoint) (\n\t\t*channeldb.OpenChannel, error)\n}\n\n// AddressSource is an interface that allows us to query for the set of\n// addresses a node can be connected to.",
      "length": 438,
      "tokens": 62,
      "embedding": []
    },
    {
      "slug": "type AddressSource interface {",
      "content": "type AddressSource interface {\n\t// AddrsForNode returns all known addresses for the target node public\n\t// key.\n\tAddrsForNode(nodePub *btcec.PublicKey) ([]net.Addr, error)\n}\n\n// assembleChanBackup attempts to assemble a static channel backup for the\n// passed open channel. The backup includes all information required to restore\n// the channel, as well as addressing information so we can find the peer and\n// reconnect to them to initiate the protocol.",
      "length": 415,
      "tokens": 64,
      "embedding": []
    },
    {
      "slug": "func assembleChanBackup(addrSource AddressSource,",
      "content": "func assembleChanBackup(addrSource AddressSource,\n\topenChan *channeldb.OpenChannel) (*Single, error) {\n\n\tlog.Debugf(\"Crafting backup for ChannelPoint(%v)\",\n\t\topenChan.FundingOutpoint)\n\n\t// First, we'll query the channel source to obtain all the addresses\n\t// that are associated with the peer for this channel.\n\tnodeAddrs, err := addrSource.AddrsForNode(openChan.IdentityPub)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsingle := NewSingle(openChan, nodeAddrs)\n\n\treturn &single, nil\n}\n\n// FetchBackupForChan attempts to create a plaintext static channel backup for\n// the target channel identified by its channel point. If we're unable to find\n// the target channel, then an error will be returned.",
      "length": 625,
      "tokens": 88,
      "embedding": []
    },
    {
      "slug": "func FetchBackupForChan(chanPoint wire.OutPoint, chanSource LiveChannelSource,",
      "content": "func FetchBackupForChan(chanPoint wire.OutPoint, chanSource LiveChannelSource,\n\taddrSource AddressSource) (*Single, error) {\n\n\t// First, we'll query the channel source to see if the channel is known\n\t// and open within the database.\n\ttargetChan, err := chanSource.FetchChannel(nil, chanPoint)\n\tif err != nil {\n\t\t// If we can't find the channel, then we return with an error,\n\t\t// as we have nothing to  backup.\n\t\treturn nil, fmt.Errorf(\"unable to find target channel\")\n\t}\n\n\t// Once we have the target channel, we can assemble the backup using\n\t// the source to obtain any extra information that we may need.\n\tstaticChanBackup, err := assembleChanBackup(addrSource, targetChan)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to create chan backup: %v\", err)\n\t}\n\n\treturn staticChanBackup, nil\n}\n\n// FetchStaticChanBackups will return a plaintext static channel back up for\n// all known active/open channels within the passed channel source.",
      "length": 840,
      "tokens": 133,
      "embedding": []
    },
    {
      "slug": "func FetchStaticChanBackups(chanSource LiveChannelSource,",
      "content": "func FetchStaticChanBackups(chanSource LiveChannelSource,\n\taddrSource AddressSource) ([]Single, error) {\n\n\t// First, we'll query the backup source for information concerning all\n\t// currently open and available channels.\n\topenChans, err := chanSource.FetchAllChannels()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Now that we have all the channels, we'll use the chanSource to\n\t// obtain any auxiliary information we need to craft a backup for each\n\t// channel.\n\tstaticChanBackups := make([]Single, 0, len(openChans))\n\tfor _, openChan := range openChans {\n\t\tchanBackup, err := assembleChanBackup(addrSource, openChan)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tstaticChanBackups = append(staticChanBackups, *chanBackup)\n\t}\n\n\treturn staticChanBackups, nil\n}\n",
      "length": 675,
      "tokens": 98,
      "embedding": []
    }
  ]
}