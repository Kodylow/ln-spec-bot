{
  "filepath": "../implementations/go/lnd/chanbackup/multi.go",
  "package": "chanbackup",
  "sections": [
    {
      "slug": "type MultiBackupVersion byte",
      "content": "type MultiBackupVersion byte\n\nconst (\n\t// DefaultMultiVersion is the default version of the multi channel\n\t// backup. The serialized format for this version is simply: version ||\n\t// numBackups || SCBs...\n\tDefaultMultiVersion = 0\n\n\t// NilMultiSizePacked is the size of a \"nil\" packed Multi (45 bytes).\n\t// This consists of the 24 byte chacha nonce, the 16 byte MAC, one byte\n\t// for the version, and 4 bytes to signal zero entries.\n\tNilMultiSizePacked = 24 + 16 + 1 + 4\n)\n\n// Multi is a form of static channel backup that is amenable to being\n// serialized in a single file. Rather than a series of ciphertexts, a\n// multi-chan backup is a single ciphertext of all static channel backups\n// concatenated. This form factor gives users a single blob that they can use\n// to safely copy/obtain at anytime to backup their channels.",
      "length": 781,
      "tokens": 142,
      "embedding": []
    },
    {
      "slug": "type Multi struct {",
      "content": "type Multi struct {\n\t// Version is the version that should be observed when attempting to\n\t// pack the multi backup.\n\tVersion MultiBackupVersion\n\n\t// StaticBackups is the set of single channel backups that this multi\n\t// backup is comprised of.\n\tStaticBackups []Single\n}\n\n// PackToWriter packs (encrypts+serializes) the target set of static channel\n// backups into a single AEAD ciphertext into the passed io.Writer. This is the\n// opposite of UnpackFromReader. The plaintext form of a multi-chan backup is\n// the following: a 4 byte integer denoting the number of serialized static\n// channel backups serialized, a series of serialized static channel backups\n// concatenated. To pack this payload, we then apply our chacha20 AEAD to the\n// entire payload, using the 24-byte nonce as associated data.",
      "length": 765,
      "tokens": 123,
      "embedding": []
    },
    {
      "slug": "func (m Multi) PackToWriter(w io.Writer, keyRing keychain.KeyRing) error {",
      "content": "func (m Multi) PackToWriter(w io.Writer, keyRing keychain.KeyRing) error {\n\t// The only version that we know how to pack atm is version 0. Attempts\n\t// to pack any other version will result in an error.\n\tswitch m.Version {\n\tcase DefaultMultiVersion:\n\t\tbreak\n\n\tdefault:\n\t\treturn fmt.Errorf(\"unable to pack unknown multi-version \"+\n\t\t\t\"of %v\", m.Version)\n\t}\n\n\tvar multiBackupBuffer bytes.Buffer\n\n\t// First, we'll write out the version of this multi channel baackup.\n\terr := lnwire.WriteElements(&multiBackupBuffer, byte(m.Version))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Now that we've written out the version of this multi-pack format,\n\t// we'll now write the total number of backups to expect after this\n\t// point.\n\tnumBackups := uint32(len(m.StaticBackups))\n\terr = lnwire.WriteElements(&multiBackupBuffer, numBackups)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Next, we'll serialize the raw plaintext version of each of the\n\t// backup into the intermediate buffer.\n\tfor _, chanBackup := range m.StaticBackups {\n\t\terr := chanBackup.Serialize(&multiBackupBuffer)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to serialize backup \"+\n\t\t\t\t\"for %v: %v\", chanBackup.FundingOutpoint, err)\n\t\t}\n\t}\n\n\t// With the plaintext multi backup assembled, we'll now encrypt it\n\t// directly to the passed writer.\n\te, err := lnencrypt.KeyRingEncrypter(keyRing)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to generate encrypt key %v\", err)\n\t}\n\n\treturn e.EncryptPayloadToWriter(multiBackupBuffer.Bytes(), w)\n}\n\n// UnpackFromReader attempts to unpack (decrypt+deserialize) a packed\n// multi-chan backup form the passed io.Reader. If we're unable to decrypt the\n// any portion of the multi-chan backup, an error will be returned.",
      "length": 1575,
      "tokens": 231,
      "embedding": []
    },
    {
      "slug": "func (m *Multi) UnpackFromReader(r io.Reader, keyRing keychain.KeyRing) error {",
      "content": "func (m *Multi) UnpackFromReader(r io.Reader, keyRing keychain.KeyRing) error {\n\t// We'll attempt to read the entire packed backup, and also decrypt it\n\t// using the passed key ring which is expected to be able to derive the\n\t// encryption keys.\n\te, err := lnencrypt.KeyRingEncrypter(keyRing)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to generate encrypt key %v\", err)\n\t}\n\tplaintextBackup, err := e.DecryptPayloadFromReader(r)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbackupReader := bytes.NewReader(plaintextBackup)\n\n\t// Now that we've decrypted the payload successfully, we can parse out\n\t// each of the individual static channel backups.\n\n\t// First, we'll need to read the version of this multi-back up so we\n\t// can know how to unpack each of the individual SCB's.\n\tvar multiVersion byte\n\terr = lnwire.ReadElements(backupReader, &multiVersion)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tm.Version = MultiBackupVersion(multiVersion)\n\tswitch m.Version {\n\n\t// The default version is simply a set of serialized SCB's with the\n\t// number of total SCB's prepended to the front of the byte slice.\n\tcase DefaultMultiVersion:\n\t\t// First, we'll need to read out the total number of backups\n\t\t// that've been serialized into this multi-chan backup. Each\n\t\t// backup is the same size, so we can continue until we've\n\t\t// parsed out everything.\n\t\tvar numBackups uint32\n\t\terr = lnwire.ReadElements(backupReader, &numBackups)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// We'll continue to parse out each backup until we've read all\n\t\t// that was indicated from the length prefix.\n\t\tfor ; numBackups != 0; numBackups-- {\n\t\t\t// Attempt to parse out the net static channel backup,\n\t\t\t// if it's been malformed, then we'll return with an\n\t\t\t// error\n\t\t\tvar chanBackup Single\n\t\t\terr := chanBackup.Deserialize(backupReader)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Collect the next valid chan backup into the main\n\t\t\t// multi backup slice.\n\t\t\tm.StaticBackups = append(m.StaticBackups, chanBackup)\n\t\t}\n\n\tdefault:\n\t\treturn fmt.Errorf(\"unable to unpack unknown multi-version \"+\n\t\t\t\"of %v\", multiVersion)\n\t}\n\n\treturn nil\n}\n\n// TODO(roasbeef): new key ring interface?\n//  * just returns key given params?\n\n// PackedMulti represents a raw fully packed (serialized+encrypted)\n// multi-channel static channel backup.",
      "length": 2132,
      "tokens": 333,
      "embedding": []
    },
    {
      "slug": "type PackedMulti []byte",
      "content": "type PackedMulti []byte\n\n// Unpack attempts to unpack (decrypt+desrialize) the target packed\n// multi-channel back up. If we're unable to fully unpack this back, then an\n// error will be returned.",
      "length": 169,
      "tokens": 28,
      "embedding": []
    },
    {
      "slug": "func (p *PackedMulti) Unpack(keyRing keychain.KeyRing) (*Multi, error) {",
      "content": "func (p *PackedMulti) Unpack(keyRing keychain.KeyRing) (*Multi, error) {\n\tvar m Multi\n\n\tpackedReader := bytes.NewReader(*p)\n\tif err := m.UnpackFromReader(packedReader, keyRing); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &m, nil\n}\n\n// TODO(roasbsef): fuzz parsing\n",
      "length": 180,
      "tokens": 27,
      "embedding": []
    }
  ]
}