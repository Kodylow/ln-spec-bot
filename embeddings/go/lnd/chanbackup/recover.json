{
  "filepath": "../implementations/go/lnd/chanbackup/recover.go",
  "package": "chanbackup",
  "sections": [
    {
      "slug": "type ChannelRestorer interface {",
      "content": "type ChannelRestorer interface {\n\t// RestoreChansFromSingles attempts to map the set of single channel\n\t// backups to channel shells that will be stored persistently. Once\n\t// these shells have been stored on disk, we'll be able to connect to\n\t// the channel peer an execute the data loss recovery protocol.\n\tRestoreChansFromSingles(...Single) error\n}\n\n// PeerConnector is an interface that allows the Recover method to connect to\n// the target node given the set of possible addresses.",
      "length": 445,
      "tokens": 72,
      "embedding": []
    },
    {
      "slug": "type PeerConnector interface {",
      "content": "type PeerConnector interface {\n\t// ConnectPeer attempts to connect to the target node at the set of\n\t// available addresses. Once this method returns with a non-nil error,\n\t// the connector should attempt to persistently connect to the target\n\t// peer in the background as a persistent attempt.\n\tConnectPeer(node *btcec.PublicKey, addrs []net.Addr) error\n}\n\n// Recover attempts to recover the static channel state from a set of static\n// channel backups. If successfully, the database will be populated with a\n// series of \"shell\" channels. These \"shell\" channels cannot be used to operate\n// the channel as normal, but instead are meant to be used to enter the data\n// loss recovery phase, and recover the settled funds within\n// the channel. In addition a LinkNode will be created for each new peer as\n// well, in order to expose the addressing information required to locate to\n// and connect to each peer in order to initiate the recovery protocol.",
      "length": 907,
      "tokens": 156,
      "embedding": []
    },
    {
      "slug": "func Recover(backups []Single, restorer ChannelRestorer,",
      "content": "func Recover(backups []Single, restorer ChannelRestorer,\n\tpeerConnector PeerConnector) error {\n\n\tfor i, backup := range backups {\n\t\tlog.Infof(\"Restoring ChannelPoint(%v) to disk: \",\n\t\t\tbackup.FundingOutpoint)\n\n\t\terr := restorer.RestoreChansFromSingles(backup)\n\n\t\t// If a channel is already present in the channel DB, we can\n\t\t// just continue. No reason to fail a whole set of multi backups\n\t\t// for example. This allows resume of a restore in case another\n\t\t// error happens.\n\t\tif err == channeldb.ErrChanAlreadyExists {\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tlog.Infof(\"Attempting to connect to node=%x (addrs=%v) to \"+\n\t\t\t\"restore ChannelPoint(%v)\",\n\t\t\tbackup.RemoteNodePub.SerializeCompressed(),\n\t\t\tnewLogClosure(func() string {\n\t\t\t\treturn spew.Sdump(backups[i].Addresses)\n\t\t\t}), backup.FundingOutpoint)\n\n\t\terr = peerConnector.ConnectPeer(\n\t\t\tbackup.RemoteNodePub, backup.Addresses,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// TODO(roasbeef): to handle case where node has changed addrs,\n\t\t// need to subscribe to new updates for target node pub to\n\t\t// attempt to connect to other addrs\n\t\t//\n\t\t//  * just to to fresh w/ call to node addrs and de-dup?\n\t}\n\n\treturn nil\n}\n\n// TODO(roasbeef): more specific keychain interface?\n\n// UnpackAndRecoverSingles is a one-shot method, that given a set of packed\n// single channel backups, will restore the channel state to a channel shell,\n// and also reach out to connect to any of the known node addresses for that\n// channel. It is assumes that after this method exists, if a connection we\n// able to be established, then then PeerConnector will continue to attempt to\n// re-establish a persistent connection in the background.",
      "length": 1584,
      "tokens": 237,
      "embedding": []
    },
    {
      "slug": "func UnpackAndRecoverSingles(singles PackedSingles,",
      "content": "func UnpackAndRecoverSingles(singles PackedSingles,\n\tkeyChain keychain.KeyRing, restorer ChannelRestorer,\n\tpeerConnector PeerConnector) error {\n\n\tchanBackups, err := singles.Unpack(keyChain)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn Recover(chanBackups, restorer, peerConnector)\n}\n\n// UnpackAndRecoverMulti is a one-shot method, that given a set of packed\n// multi-channel backups, will restore the channel states to channel shells,\n// and also reach out to connect to any of the known node addresses for that\n// channel. It is assumes that after this method exists, if a connection we\n// able to be established, then then PeerConnector will continue to attempt to\n// re-establish a persistent connection in the background.",
      "length": 655,
      "tokens": 99,
      "embedding": []
    },
    {
      "slug": "func UnpackAndRecoverMulti(packedMulti PackedMulti,",
      "content": "func UnpackAndRecoverMulti(packedMulti PackedMulti,\n\tkeyChain keychain.KeyRing, restorer ChannelRestorer,\n\tpeerConnector PeerConnector) error {\n\n\tchanBackups, err := packedMulti.Unpack(keyChain)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn Recover(chanBackups.StaticBackups, restorer, peerConnector)\n}\n",
      "length": 237,
      "tokens": 25,
      "embedding": []
    }
  ]
}