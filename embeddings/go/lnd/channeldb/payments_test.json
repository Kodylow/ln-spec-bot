{
  "filepath": "../implementations/go/lnd/channeldb/payments_test.go",
  "package": "channeldb",
  "sections": [
    {
      "slug": "func makeFakeInfo() (*PaymentCreationInfo, *HTLCAttemptInfo) {",
      "content": "func makeFakeInfo() (*PaymentCreationInfo, *HTLCAttemptInfo) {\n\tvar preimg lntypes.Preimage\n\tcopy(preimg[:], rev[:])\n\n\thash := preimg.Hash()\n\n\tc := &PaymentCreationInfo{\n\t\tPaymentIdentifier: hash,\n\t\tValue:             1000,\n\t\t// Use single second precision to avoid false positive test\n\t\t// failures due to the monotonic time component.\n\t\tCreationTime:   time.Unix(time.Now().Unix(), 0),\n\t\tPaymentRequest: []byte(\"\"),\n\t}\n\n\ta := NewHtlcAttemptInfo(\n\t\t44, priv, testRoute, time.Unix(100, 0), &hash,\n\t)\n\n\treturn c, a\n}\n",
      "length": 433,
      "tokens": 53,
      "embedding": []
    },
    {
      "slug": "func TestSentPaymentSerialization(t *testing.T) {",
      "content": "func TestSentPaymentSerialization(t *testing.T) {\n\tt.Parallel()\n\n\tc, s := makeFakeInfo()\n\n\tvar b bytes.Buffer\n\tif err := serializePaymentCreationInfo(&b, c); err != nil {\n\t\tt.Fatalf(\"unable to serialize creation info: %v\", err)\n\t}\n\n\tnewCreationInfo, err := deserializePaymentCreationInfo(&b)\n\trequire.NoError(t, err, \"unable to deserialize creation info\")\n\n\tif !reflect.DeepEqual(c, newCreationInfo) {\n\t\tt.Fatalf(\"Payments do not match after \"+\n\t\t\t\"serialization/deserialization %v vs %v\",\n\t\t\tspew.Sdump(c), spew.Sdump(newCreationInfo),\n\t\t)\n\t}\n\n\tb.Reset()\n\tif err := serializeHTLCAttemptInfo(&b, s); err != nil {\n\t\tt.Fatalf(\"unable to serialize info: %v\", err)\n\t}\n\n\tnewWireInfo, err := deserializeHTLCAttemptInfo(&b)\n\trequire.NoError(t, err, \"unable to deserialize info\")\n\tnewWireInfo.AttemptID = s.AttemptID\n\n\t// First we verify all the records match up porperly, as they aren't\n\t// able to be properly compared using reflect.DeepEqual.\n\terr = assertRouteEqual(&s.Route, &newWireInfo.Route)\n\tif err != nil {\n\t\tt.Fatalf(\"Routes do not match after \"+\n\t\t\t\"serialization/deserialization: %v\", err)\n\t}\n\n\t// Clear routes to allow DeepEqual to compare the remaining fields.\n\tnewWireInfo.Route = route.Route{}\n\ts.Route = route.Route{}\n\n\t// Call session key method to set our cached session key so we can use\n\t// DeepEqual, and assert that our key equals the original key.\n\trequire.Equal(t, s.cachedSessionKey, newWireInfo.SessionKey())\n\n\tif !reflect.DeepEqual(s, newWireInfo) {\n\t\tt.Fatalf(\"Payments do not match after \"+\n\t\t\t\"serialization/deserialization %v vs %v\",\n\t\t\tspew.Sdump(s), spew.Sdump(newWireInfo),\n\t\t)\n\t}\n}\n\n// assertRouteEquals compares to routes for equality and returns an error if\n// they are not equal.",
      "length": 1608,
      "tokens": 206,
      "embedding": []
    },
    {
      "slug": "func assertRouteEqual(a, b *route.Route) error {",
      "content": "func assertRouteEqual(a, b *route.Route) error {\n\tif !reflect.DeepEqual(a, b) {\n\t\treturn fmt.Errorf(\"HTLCAttemptInfos don't match: %v vs %v\",\n\t\t\tspew.Sdump(a), spew.Sdump(b))\n\t}\n\n\treturn nil\n}\n",
      "length": 137,
      "tokens": 17,
      "embedding": []
    },
    {
      "slug": "func TestRouteSerialization(t *testing.T) {",
      "content": "func TestRouteSerialization(t *testing.T) {\n\tt.Parallel()\n\n\tvar b bytes.Buffer\n\tif err := SerializeRoute(&b, testRoute); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tr := bytes.NewReader(b.Bytes())\n\troute2, err := DeserializeRoute(r)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// First we verify all the records match up porperly, as they aren't\n\t// able to be properly compared using reflect.DeepEqual.\n\terr = assertRouteEqual(&testRoute, &route2)\n\tif err != nil {\n\t\tt.Fatalf(\"routes not equal: \\n%v vs \\n%v\",\n\t\t\tspew.Sdump(testRoute), spew.Sdump(route2))\n\t}\n}\n\n// deletePayment removes a payment with paymentHash from the payments database.",
      "length": 558,
      "tokens": 80,
      "embedding": []
    },
    {
      "slug": "func deletePayment(t *testing.T, db *DB, paymentHash lntypes.Hash, seqNr uint64) {",
      "content": "func deletePayment(t *testing.T, db *DB, paymentHash lntypes.Hash, seqNr uint64) {\n\tt.Helper()\n\n\terr := kvdb.Update(db, func(tx kvdb.RwTx) error {\n\t\tpayments := tx.ReadWriteBucket(paymentsRootBucket)\n\n\t\t// Delete the payment bucket.\n\t\terr := payments.DeleteNestedBucket(paymentHash[:])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tkey := make([]byte, 8)\n\t\tbyteOrder.PutUint64(key, seqNr)\n\n\t\t// Delete the index that references this payment.\n\t\tindexes := tx.ReadWriteBucket(paymentsIndexBucket)\n\t\treturn indexes.Delete(key)\n\t}, func() {})\n\n\tif err != nil {\n\t\tt.Fatalf(\"could not delete \"+\n\t\t\t\"payment: %v\", err)\n\t}\n}\n\n// TestQueryPayments tests retrieval of payments with forwards and reversed\n// queries.",
      "length": 589,
      "tokens": 75,
      "embedding": []
    },
    {
      "slug": "func TestQueryPayments(t *testing.T) {",
      "content": "func TestQueryPayments(t *testing.T) {\n\t// Define table driven test for QueryPayments.\n\t// Test payments have sequence indices [1, 3, 4, 5, 6, 7].\n\t// Note that the payment with index 7 has the same payment hash as 6,\n\t// and is stored in a nested bucket within payment 6 rather than being\n\t// its own entry in the payments bucket. We do this to test retrieval\n\t// of legacy payments.\n\ttests := []struct {\n\t\tname       string\n\t\tquery      PaymentsQuery\n\t\tfirstIndex uint64\n\t\tlastIndex  uint64\n\n\t\t// expectedSeqNrs contains the set of sequence numbers we expect\n\t\t// our query to return.\n\t\texpectedSeqNrs []uint64\n\t}{\n\t\t{\n\t\t\tname: \"IndexOffset at the end of the payments range\",\n\t\t\tquery: PaymentsQuery{\n\t\t\t\tIndexOffset:       7,\n\t\t\t\tMaxPayments:       7,\n\t\t\t\tReversed:          false,\n\t\t\t\tIncludeIncomplete: true,\n\t\t\t},\n\t\t\tfirstIndex:     0,\n\t\t\tlastIndex:      0,\n\t\t\texpectedSeqNrs: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"query in forwards order, start at beginning\",\n\t\t\tquery: PaymentsQuery{\n\t\t\t\tIndexOffset:       0,\n\t\t\t\tMaxPayments:       2,\n\t\t\t\tReversed:          false,\n\t\t\t\tIncludeIncomplete: true,\n\t\t\t},\n\t\t\tfirstIndex:     1,\n\t\t\tlastIndex:      3,\n\t\t\texpectedSeqNrs: []uint64{1, 3},\n\t\t},\n\t\t{\n\t\t\tname: \"query in forwards order, start at end, overflow\",\n\t\t\tquery: PaymentsQuery{\n\t\t\t\tIndexOffset:       6,\n\t\t\t\tMaxPayments:       2,\n\t\t\t\tReversed:          false,\n\t\t\t\tIncludeIncomplete: true,\n\t\t\t},\n\t\t\tfirstIndex:     7,\n\t\t\tlastIndex:      7,\n\t\t\texpectedSeqNrs: []uint64{7},\n\t\t},\n\t\t{\n\t\t\tname: \"start at offset index outside of payments\",\n\t\t\tquery: PaymentsQuery{\n\t\t\t\tIndexOffset:       20,\n\t\t\t\tMaxPayments:       2,\n\t\t\t\tReversed:          false,\n\t\t\t\tIncludeIncomplete: true,\n\t\t\t},\n\t\t\tfirstIndex:     0,\n\t\t\tlastIndex:      0,\n\t\t\texpectedSeqNrs: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"overflow in forwards order\",\n\t\t\tquery: PaymentsQuery{\n\t\t\t\tIndexOffset:       4,\n\t\t\t\tMaxPayments:       math.MaxUint64,\n\t\t\t\tReversed:          false,\n\t\t\t\tIncludeIncomplete: true,\n\t\t\t},\n\t\t\tfirstIndex:     5,\n\t\t\tlastIndex:      7,\n\t\t\texpectedSeqNrs: []uint64{5, 6, 7},\n\t\t},\n\t\t{\n\t\t\tname: \"start at offset index outside of payments, \" +\n\t\t\t\t\"reversed order\",\n\t\t\tquery: PaymentsQuery{\n\t\t\t\tIndexOffset:       9,\n\t\t\t\tMaxPayments:       2,\n\t\t\t\tReversed:          true,\n\t\t\t\tIncludeIncomplete: true,\n\t\t\t},\n\t\t\tfirstIndex:     6,\n\t\t\tlastIndex:      7,\n\t\t\texpectedSeqNrs: []uint64{6, 7},\n\t\t},\n\t\t{\n\t\t\tname: \"query in reverse order, start at end\",\n\t\t\tquery: PaymentsQuery{\n\t\t\t\tIndexOffset:       0,\n\t\t\t\tMaxPayments:       2,\n\t\t\t\tReversed:          true,\n\t\t\t\tIncludeIncomplete: true,\n\t\t\t},\n\t\t\tfirstIndex:     6,\n\t\t\tlastIndex:      7,\n\t\t\texpectedSeqNrs: []uint64{6, 7},\n\t\t},\n\t\t{\n\t\t\tname: \"query in reverse order, starting in middle\",\n\t\t\tquery: PaymentsQuery{\n\t\t\t\tIndexOffset:       4,\n\t\t\t\tMaxPayments:       2,\n\t\t\t\tReversed:          true,\n\t\t\t\tIncludeIncomplete: true,\n\t\t\t},\n\t\t\tfirstIndex:     1,\n\t\t\tlastIndex:      3,\n\t\t\texpectedSeqNrs: []uint64{1, 3},\n\t\t},\n\t\t{\n\t\t\tname: \"query in reverse order, starting in middle, \" +\n\t\t\t\t\"with underflow\",\n\t\t\tquery: PaymentsQuery{\n\t\t\t\tIndexOffset:       4,\n\t\t\t\tMaxPayments:       5,\n\t\t\t\tReversed:          true,\n\t\t\t\tIncludeIncomplete: true,\n\t\t\t},\n\t\t\tfirstIndex:     1,\n\t\t\tlastIndex:      3,\n\t\t\texpectedSeqNrs: []uint64{1, 3},\n\t\t},\n\t\t{\n\t\t\tname: \"all payments in reverse, order maintained\",\n\t\t\tquery: PaymentsQuery{\n\t\t\t\tIndexOffset:       0,\n\t\t\t\tMaxPayments:       7,\n\t\t\t\tReversed:          true,\n\t\t\t\tIncludeIncomplete: true,\n\t\t\t},\n\t\t\tfirstIndex:     1,\n\t\t\tlastIndex:      7,\n\t\t\texpectedSeqNrs: []uint64{1, 3, 4, 5, 6, 7},\n\t\t},\n\t\t{\n\t\t\tname: \"exclude incomplete payments\",\n\t\t\tquery: PaymentsQuery{\n\t\t\t\tIndexOffset:       0,\n\t\t\t\tMaxPayments:       7,\n\t\t\t\tReversed:          false,\n\t\t\t\tIncludeIncomplete: false,\n\t\t\t},\n\t\t\tfirstIndex:     7,\n\t\t\tlastIndex:      7,\n\t\t\texpectedSeqNrs: []uint64{7},\n\t\t},\n\t\t{\n\t\t\tname: \"query payments at index gap\",\n\t\t\tquery: PaymentsQuery{\n\t\t\t\tIndexOffset:       1,\n\t\t\t\tMaxPayments:       7,\n\t\t\t\tReversed:          false,\n\t\t\t\tIncludeIncomplete: true,\n\t\t\t},\n\t\t\tfirstIndex:     3,\n\t\t\tlastIndex:      7,\n\t\t\texpectedSeqNrs: []uint64{3, 4, 5, 6, 7},\n\t\t},\n\t\t{\n\t\t\tname: \"query payments reverse before index gap\",\n\t\t\tquery: PaymentsQuery{\n\t\t\t\tIndexOffset:       3,\n\t\t\t\tMaxPayments:       7,\n\t\t\t\tReversed:          true,\n\t\t\t\tIncludeIncomplete: true,\n\t\t\t},\n\t\t\tfirstIndex:     1,\n\t\t\tlastIndex:      1,\n\t\t\texpectedSeqNrs: []uint64{1},\n\t\t},\n\t\t{\n\t\t\tname: \"query payments reverse on index gap\",\n\t\t\tquery: PaymentsQuery{\n\t\t\t\tIndexOffset:       2,\n\t\t\t\tMaxPayments:       7,\n\t\t\t\tReversed:          true,\n\t\t\t\tIncludeIncomplete: true,\n\t\t\t},\n\t\t\tfirstIndex:     1,\n\t\t\tlastIndex:      1,\n\t\t\texpectedSeqNrs: []uint64{1},\n\t\t},\n\t\t{\n\t\t\tname: \"query payments forward on index gap\",\n\t\t\tquery: PaymentsQuery{\n\t\t\t\tIndexOffset:       2,\n\t\t\t\tMaxPayments:       2,\n\t\t\t\tReversed:          false,\n\t\t\t\tIncludeIncomplete: true,\n\t\t\t},\n\t\t\tfirstIndex:     3,\n\t\t\tlastIndex:      4,\n\t\t\texpectedSeqNrs: []uint64{3, 4},\n\t\t},\n\t\t{\n\t\t\tname: \"query in forwards order, with start creation \" +\n\t\t\t\t\"time\",\n\t\t\tquery: PaymentsQuery{\n\t\t\t\tIndexOffset:       0,\n\t\t\t\tMaxPayments:       2,\n\t\t\t\tReversed:          false,\n\t\t\t\tIncludeIncomplete: true,\n\t\t\t\tCreationDateStart: time.Unix(0, 5),\n\t\t\t},\n\t\t\tfirstIndex:     5,\n\t\t\tlastIndex:      6,\n\t\t\texpectedSeqNrs: []uint64{5, 6},\n\t\t},\n\t\t{\n\t\t\tname: \"query in forwards order, with start creation \" +\n\t\t\t\t\"time at end, overflow\",\n\t\t\tquery: PaymentsQuery{\n\t\t\t\tIndexOffset:       0,\n\t\t\t\tMaxPayments:       2,\n\t\t\t\tReversed:          false,\n\t\t\t\tIncludeIncomplete: true,\n\t\t\t\tCreationDateStart: time.Unix(0, 7),\n\t\t\t},\n\t\t\tfirstIndex:     7,\n\t\t\tlastIndex:      7,\n\t\t\texpectedSeqNrs: []uint64{7},\n\t\t},\n\t\t{\n\t\t\tname: \"query with start and end creation time\",\n\t\t\tquery: PaymentsQuery{\n\t\t\t\tIndexOffset:       9,\n\t\t\t\tMaxPayments:       math.MaxUint64,\n\t\t\t\tReversed:          true,\n\t\t\t\tIncludeIncomplete: true,\n\t\t\t\tCreationDateStart: time.Unix(0, 3),\n\t\t\t\tCreationDateEnd:   time.Unix(0, 5),\n\t\t\t},\n\t\t\tfirstIndex:     3,\n\t\t\tlastIndex:      5,\n\t\t\texpectedSeqNrs: []uint64{3, 4, 5},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tdb, err := MakeTestDB(t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to init db: %v\", err)\n\t\t\t}\n\n\t\t\t// Make a preliminary query to make sure it's ok to\n\t\t\t// query when we have no payments.\n\t\t\tresp, err := db.QueryPayments(tt.query)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Len(t, resp.Payments, 0)\n\n\t\t\t// Populate the database with a set of test payments.\n\t\t\t// We create 6 original payments, deleting the payment\n\t\t\t// at index 2 so that we cover the case where sequence\n\t\t\t// numbers are missing. We also add a duplicate payment\n\t\t\t// to the last payment added to test the legacy case\n\t\t\t// where we have duplicates in the nested duplicates\n\t\t\t// bucket.\n\t\t\tnonDuplicatePayments := 6\n\t\t\tpControl := NewPaymentControl(db)\n\n\t\t\tfor i := 0; i < nonDuplicatePayments; i++ {\n\t\t\t\t// Generate a test payment.\n\t\t\t\tinfo, _, preimg, err := genInfo()\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"unable to create test \"+\n\t\t\t\t\t\t\"payment: %v\", err)\n\t\t\t\t}\n\t\t\t\t// Override creation time to allow for testing\n\t\t\t\t// of CreationDateStart and CreationDateEnd.\n\t\t\t\tinfo.CreationTime = time.Unix(0, int64(i+1))\n\n\t\t\t\t// Create a new payment entry in the database.\n\t\t\t\terr = pControl.InitPayment(info.PaymentIdentifier, info)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"unable to initialize \"+\n\t\t\t\t\t\t\"payment in database: %v\", err)\n\t\t\t\t}\n\n\t\t\t\t// Immediately delete the payment with index 2.\n\t\t\t\tif i == 1 {\n\t\t\t\t\tpmt, err := pControl.FetchPayment(\n\t\t\t\t\t\tinfo.PaymentIdentifier,\n\t\t\t\t\t)\n\t\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\t\tdeletePayment(t, db, info.PaymentIdentifier,\n\t\t\t\t\t\tpmt.SequenceNum)\n\t\t\t\t}\n\n\t\t\t\t// If we are on the last payment entry, add a\n\t\t\t\t// duplicate payment with sequence number equal\n\t\t\t\t// to the parent payment + 1. Note that\n\t\t\t\t// duplicate payments will always be succeeded.\n\t\t\t\tif i == (nonDuplicatePayments - 1) {\n\t\t\t\t\tpmt, err := pControl.FetchPayment(\n\t\t\t\t\t\tinfo.PaymentIdentifier,\n\t\t\t\t\t)\n\t\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\t\tappendDuplicatePayment(\n\t\t\t\t\t\tt, pControl.db,\n\t\t\t\t\t\tinfo.PaymentIdentifier,\n\t\t\t\t\t\tpmt.SequenceNum+1,\n\t\t\t\t\t\tpreimg,\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Fetch all payments in the database.\n\t\t\tallPayments, err := db.FetchPayments()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"payments could not be fetched from \"+\n\t\t\t\t\t\"database: %v\", err)\n\t\t\t}\n\n\t\t\tif len(allPayments) != 6 {\n\t\t\t\tt.Fatalf(\"Number of payments received does not \"+\n\t\t\t\t\t\"match expected one. Got %v, want %v.\",\n\t\t\t\t\tlen(allPayments), 6)\n\t\t\t}\n\n\t\t\tquerySlice, err := db.QueryPayments(tt.query)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t\t}\n\t\t\tif tt.firstIndex != querySlice.FirstIndexOffset ||\n\t\t\t\ttt.lastIndex != querySlice.LastIndexOffset {\n\n\t\t\t\tt.Errorf(\"First or last index does not match \"+\n\t\t\t\t\t\"expected index. Want (%d, %d), got (%d, %d).\",\n\t\t\t\t\ttt.firstIndex, tt.lastIndex,\n\t\t\t\t\tquerySlice.FirstIndexOffset,\n\t\t\t\t\tquerySlice.LastIndexOffset)\n\t\t\t}\n\n\t\t\tif len(querySlice.Payments) != len(tt.expectedSeqNrs) {\n\t\t\t\tt.Errorf(\"expected: %v payments, got: %v\",\n\t\t\t\t\tlen(tt.expectedSeqNrs), len(querySlice.Payments))\n\t\t\t}\n\n\t\t\tfor i, seqNr := range tt.expectedSeqNrs {\n\t\t\t\tq := querySlice.Payments[i]\n\t\t\t\tif seqNr != q.SequenceNum {\n\t\t\t\t\tt.Errorf(\"sequence numbers do not match, \"+\n\t\t\t\t\t\t\"got %v, want %v\", q.SequenceNum, seqNr)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestFetchPaymentWithSequenceNumber tests lookup of payments with their\n// sequence number. It sets up one payment with no duplicates, and another with\n// two duplicates in its duplicates bucket then uses these payments to test the\n// case where a specific duplicate is not found and the duplicates bucket is not\n// present when we expect it to be.",
      "length": 9203,
      "tokens": 1108,
      "embedding": []
    },
    {
      "slug": "func TestFetchPaymentWithSequenceNumber(t *testing.T) {",
      "content": "func TestFetchPaymentWithSequenceNumber(t *testing.T) {\n\tdb, err := MakeTestDB(t)\n\trequire.NoError(t, err)\n\n\tpControl := NewPaymentControl(db)\n\n\t// Generate a test payment which does not have duplicates.\n\tnoDuplicates, _, _, err := genInfo()\n\trequire.NoError(t, err)\n\n\t// Create a new payment entry in the database.\n\terr = pControl.InitPayment(noDuplicates.PaymentIdentifier, noDuplicates)\n\trequire.NoError(t, err)\n\n\t// Fetch the payment so we can get its sequence nr.\n\tnoDuplicatesPayment, err := pControl.FetchPayment(\n\t\tnoDuplicates.PaymentIdentifier,\n\t)\n\trequire.NoError(t, err)\n\n\t// Generate a test payment which we will add duplicates to.\n\thasDuplicates, _, preimg, err := genInfo()\n\trequire.NoError(t, err)\n\n\t// Create a new payment entry in the database.\n\terr = pControl.InitPayment(hasDuplicates.PaymentIdentifier, hasDuplicates)\n\trequire.NoError(t, err)\n\n\t// Fetch the payment so we can get its sequence nr.\n\thasDuplicatesPayment, err := pControl.FetchPayment(\n\t\thasDuplicates.PaymentIdentifier,\n\t)\n\trequire.NoError(t, err)\n\n\t// We declare the sequence numbers used here so that we can reference\n\t// them in tests.\n\tvar (\n\t\tduplicateOneSeqNr = hasDuplicatesPayment.SequenceNum + 1\n\t\tduplicateTwoSeqNr = hasDuplicatesPayment.SequenceNum + 2\n\t)\n\n\t// Add two duplicates to our second payment.\n\tappendDuplicatePayment(\n\t\tt, db, hasDuplicates.PaymentIdentifier, duplicateOneSeqNr, preimg,\n\t)\n\tappendDuplicatePayment(\n\t\tt, db, hasDuplicates.PaymentIdentifier, duplicateTwoSeqNr, preimg,\n\t)\n\n\ttests := []struct {\n\t\tname           string\n\t\tpaymentHash    lntypes.Hash\n\t\tsequenceNumber uint64\n\t\texpectedErr    error\n\t}{\n\t\t{\n\t\t\tname:           \"lookup payment without duplicates\",\n\t\t\tpaymentHash:    noDuplicates.PaymentIdentifier,\n\t\t\tsequenceNumber: noDuplicatesPayment.SequenceNum,\n\t\t\texpectedErr:    nil,\n\t\t},\n\t\t{\n\t\t\tname:           \"lookup payment with duplicates\",\n\t\t\tpaymentHash:    hasDuplicates.PaymentIdentifier,\n\t\t\tsequenceNumber: hasDuplicatesPayment.SequenceNum,\n\t\t\texpectedErr:    nil,\n\t\t},\n\t\t{\n\t\t\tname:           \"lookup first duplicate\",\n\t\t\tpaymentHash:    hasDuplicates.PaymentIdentifier,\n\t\t\tsequenceNumber: duplicateOneSeqNr,\n\t\t\texpectedErr:    nil,\n\t\t},\n\t\t{\n\t\t\tname:           \"lookup second duplicate\",\n\t\t\tpaymentHash:    hasDuplicates.PaymentIdentifier,\n\t\t\tsequenceNumber: duplicateTwoSeqNr,\n\t\t\texpectedErr:    nil,\n\t\t},\n\t\t{\n\t\t\tname:           \"lookup non-existent duplicate\",\n\t\t\tpaymentHash:    hasDuplicates.PaymentIdentifier,\n\t\t\tsequenceNumber: 999999,\n\t\t\texpectedErr:    ErrDuplicateNotFound,\n\t\t},\n\t\t{\n\t\t\tname:           \"lookup duplicate, no duplicates bucket\",\n\t\t\tpaymentHash:    noDuplicates.PaymentIdentifier,\n\t\t\tsequenceNumber: duplicateTwoSeqNr,\n\t\t\texpectedErr:    ErrNoDuplicateBucket,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\terr := kvdb.Update(\n\t\t\t\tdb, func(tx walletdb.ReadWriteTx) error {\n\t\t\t\t\tvar seqNrBytes [8]byte\n\t\t\t\t\tbyteOrder.PutUint64(\n\t\t\t\t\t\tseqNrBytes[:], test.sequenceNumber,\n\t\t\t\t\t)\n\n\t\t\t\t\t_, err := fetchPaymentWithSequenceNumber(\n\t\t\t\t\t\ttx, test.paymentHash, seqNrBytes[:],\n\t\t\t\t\t)\n\t\t\t\t\treturn err\n\t\t\t\t}, func() {},\n\t\t\t)\n\t\t\trequire.Equal(t, test.expectedErr, err)\n\t\t})\n\t}\n}\n\n// appendDuplicatePayment adds a duplicate payment to an existing payment. Note\n// that this function requires a unique sequence number.\n//\n// This code is *only* intended to replicate legacy duplicate payments in lnd,\n// our current schema does not allow duplicates.",
      "length": 3268,
      "tokens": 347,
      "embedding": []
    },
    {
      "slug": "func appendDuplicatePayment(t *testing.T, db *DB, paymentHash lntypes.Hash,",
      "content": "func appendDuplicatePayment(t *testing.T, db *DB, paymentHash lntypes.Hash,\n\tseqNr uint64, preImg lntypes.Preimage) {\n\n\terr := kvdb.Update(db, func(tx walletdb.ReadWriteTx) error {\n\t\tbucket, err := fetchPaymentBucketUpdate(\n\t\t\ttx, paymentHash,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Create the duplicates bucket if it is not\n\t\t// present.\n\t\tdup, err := bucket.CreateBucketIfNotExists(\n\t\t\tduplicatePaymentsBucket,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvar sequenceKey [8]byte\n\t\tbyteOrder.PutUint64(sequenceKey[:], seqNr)\n\n\t\t// Create duplicate payments for the two dup\n\t\t// sequence numbers we've setup.\n\t\tputDuplicatePayment(t, dup, sequenceKey[:], paymentHash, preImg)\n\n\t\t// Finally, once we have created our entry we add an index for\n\t\t// it.\n\t\terr = createPaymentIndexEntry(tx, sequenceKey[:], paymentHash)\n\t\trequire.NoError(t, err)\n\n\t\treturn nil\n\t}, func() {})\n\trequire.NoError(t, err, \"could not create payment\")\n}\n\n// putDuplicatePayment creates a duplicate payment in the duplicates bucket\n// provided with the minimal information required for successful reading.",
      "length": 969,
      "tokens": 129,
      "embedding": []
    },
    {
      "slug": "func putDuplicatePayment(t *testing.T, duplicateBucket kvdb.RwBucket,",
      "content": "func putDuplicatePayment(t *testing.T, duplicateBucket kvdb.RwBucket,\n\tsequenceKey []byte, paymentHash lntypes.Hash,\n\tpreImg lntypes.Preimage) {\n\n\tpaymentBucket, err := duplicateBucket.CreateBucketIfNotExists(\n\t\tsequenceKey,\n\t)\n\trequire.NoError(t, err)\n\n\terr = paymentBucket.Put(duplicatePaymentSequenceKey, sequenceKey)\n\trequire.NoError(t, err)\n\n\t// Generate fake information for the duplicate payment.\n\tinfo, _, _, err := genInfo()\n\trequire.NoError(t, err)\n\n\t// Write the payment info to disk under the creation info key. This code\n\t// is copied rather than using serializePaymentCreationInfo to ensure\n\t// we always write in the legacy format used by duplicate payments.\n\tvar b bytes.Buffer\n\tvar scratch [8]byte\n\t_, err = b.Write(paymentHash[:])\n\trequire.NoError(t, err)\n\n\tbyteOrder.PutUint64(scratch[:], uint64(info.Value))\n\t_, err = b.Write(scratch[:])\n\trequire.NoError(t, err)\n\n\terr = serializeTime(&b, info.CreationTime)\n\trequire.NoError(t, err)\n\n\tbyteOrder.PutUint32(scratch[:4], 0)\n\t_, err = b.Write(scratch[:4])\n\trequire.NoError(t, err)\n\n\t// Get the PaymentCreationInfo.\n\terr = paymentBucket.Put(duplicatePaymentCreationInfoKey, b.Bytes())\n\trequire.NoError(t, err)\n\n\t// Duolicate payments are only stored for successes, so add the\n\t// preimage.\n\terr = paymentBucket.Put(duplicatePaymentSettleInfoKey, preImg[:])\n\trequire.NoError(t, err)\n}\n",
      "length": 1236,
      "tokens": 136,
      "embedding": []
    }
  ]
}