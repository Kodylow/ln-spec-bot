{
  "filepath": "../implementations/go/lnd/channeldb/migration24/migration.go",
  "package": "migration24",
  "sections": [
    {
      "slug": "func MigrateFwdPkgCleanup(tx kvdb.RwTx) error {",
      "content": "func MigrateFwdPkgCleanup(tx kvdb.RwTx) error {\n\tlog.Infof(\"Deleting forwarding packages for closed channels\")\n\n\t// Find all closed channel summaries, which are stored in the\n\t// closeBucket.\n\tcloseBucket := tx.ReadBucket(closedChannelBucket)\n\tif closeBucket == nil {\n\t\treturn nil\n\t}\n\n\tvar chanSummaries []*mig.ChannelCloseSummary\n\n\t// appendSummary is a function closure to help put deserialized close\n\t// summeries into chanSummaries.\n\tappendSummary := func(_ []byte, summaryBytes []byte) error {\n\t\tsummaryReader := bytes.NewReader(summaryBytes)\n\t\tchanSummary, err := deserializeCloseChannelSummary(\n\t\t\tsummaryReader,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Skip pending channels\n\t\tif chanSummary.IsPending {\n\t\t\treturn nil\n\t\t}\n\n\t\tchanSummaries = append(chanSummaries, chanSummary)\n\t\treturn nil\n\t}\n\n\tif err := closeBucket.ForEach(appendSummary); err != nil {\n\t\treturn err\n\t}\n\n\t// Now we will load the forwarding packages bucket, delete all the\n\t// nested buckets whose source matches the ShortChanID found in the\n\t// closed channel summeraries.\n\tfwdPkgBkt := tx.ReadWriteBucket(fwdPackagesKey)\n\tif fwdPkgBkt == nil {\n\t\treturn nil\n\t}\n\n\t// Iterate over all close channels and remove their forwarding packages.\n\tfor _, summery := range chanSummaries {\n\t\tsourceBytes := MakeLogKey(summery.ShortChanID.ToUint64())\n\n\t\t// First, we will try to find the corresponding bucket. If there\n\t\t// is not a nested bucket matching the ShortChanID, we will skip\n\t\t// it.\n\t\tif fwdPkgBkt.NestedReadBucket(sourceBytes[:]) == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Otherwise, wipe all the forwarding packages.\n\t\tif err := fwdPkgBkt.DeleteNestedBucket(\n\t\t\tsourceBytes[:],\n\t\t); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tlog.Infof(\"Deletion of forwarding packages of closed channels \" +\n\t\t\"complete! DB compaction is recommended to free up the\" +\n\t\t\"disk space.\")\n\treturn nil\n}\n\n// deserializeCloseChannelSummary will decode a CloseChannelSummary with no\n// optional fields.",
      "length": 1822,
      "tokens": 249,
      "embedding": []
    },
    {
      "slug": "func deserializeCloseChannelSummary(",
      "content": "func deserializeCloseChannelSummary(\n\tr io.Reader) (*mig.ChannelCloseSummary, error) {\n\n\tc := &mig.ChannelCloseSummary{}\n\terr := mig.ReadElements(\n\t\tr,\n\t\t&c.ChanPoint, &c.ShortChanID, &c.ChainHash, &c.ClosingTXID,\n\t\t&c.CloseHeight, &c.RemotePub, &c.Capacity, &c.SettledBalance,\n\t\t&c.TimeLockedBalance, &c.CloseType, &c.IsPending,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn c, nil\n}\n\n// makeLogKey converts a uint64 into an 8 byte array.",
      "length": 390,
      "tokens": 47,
      "embedding": []
    },
    {
      "slug": "func MakeLogKey(updateNum uint64) [8]byte {",
      "content": "func MakeLogKey(updateNum uint64) [8]byte {\n\tvar key [8]byte\n\tbinary.BigEndian.PutUint64(key[:], updateNum)\n\treturn key\n}\n",
      "length": 74,
      "tokens": 8,
      "embedding": []
    }
  ]
}