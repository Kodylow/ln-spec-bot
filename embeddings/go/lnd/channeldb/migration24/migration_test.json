{
  "filepath": "../implementations/go/lnd/channeldb/migration24/migration_test.go",
  "package": "migration24",
  "sections": [
    {
      "slug": "func TestMigrateFwdPkgCleanup(t *testing.T) {",
      "content": "func TestMigrateFwdPkgCleanup(t *testing.T) {\n\tmigrationTests := []struct {\n\t\tname                string\n\t\tbeforeMigrationFunc func(kvdb.RwTx) error\n\t\tafterMigrationFunc  func(kvdb.RwTx) error\n\t}{\n\t\t{\n\t\t\t// No closed channels summeries in the db.\n\t\t\t// This leaves the fwdpkg untouched.\n\t\t\tname: \"no closed channel summeries\",\n\t\t\tbeforeMigrationFunc: genBeforeMigration(\n\t\t\t\tfalse, []int{}, []int{1},\n\t\t\t),\n\t\t\tafterMigrationFunc: genAfterMigration(\n\t\t\t\t[]int{}, []int{1},\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\t// One closed summery found, and the forwarding package\n\t\t\t// shares the same channel ID.\n\t\t\t// This makes the fwdpkg removed.\n\t\t\tname: \"remove one fwdpkg\",\n\t\t\tbeforeMigrationFunc: genBeforeMigration(\n\t\t\t\tfalse, []int{1}, []int{1},\n\t\t\t),\n\t\t\tafterMigrationFunc: genAfterMigration(\n\t\t\t\t[]int{1}, []int{},\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\t// One closed summery with pending status found, and the\n\t\t\t// forwarding package shares the same channel ID.\n\t\t\t// This leaves the fwdpkg untouched.\n\t\t\tname: \"no action if closed status is pending\",\n\t\t\tbeforeMigrationFunc: genBeforeMigration(\n\t\t\t\ttrue, []int{1}, []int{1},\n\t\t\t),\n\t\t\tafterMigrationFunc: genAfterMigration(\n\t\t\t\t[]int{}, []int{1},\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\t// One closed summery found, while the forwarding\n\t\t\t// package has a different channel ID.\n\t\t\t// This leaves the fwdpkg untouched.\n\t\t\tname: \"no fwdpkg removed\",\n\t\t\tbeforeMigrationFunc: genBeforeMigration(\n\t\t\t\tfalse, []int{1}, []int{2},\n\t\t\t),\n\t\t\tafterMigrationFunc: genAfterMigration(\n\t\t\t\t[]int{}, []int{2},\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\t// Multiple closed summeries and fwdpkg nested buckets\n\t\t\t// found. Only the matched fwdPkg nested buckets are\n\t\t\t// removed.\n\t\t\tname: \"only matching fwdpkg removed\",\n\t\t\tbeforeMigrationFunc: genBeforeMigration(false,\n\t\t\t\t[]int{1, 2, 3},\n\t\t\t\t[]int{1, 2, 4},\n\t\t\t),\n\t\t\tafterMigrationFunc: genAfterMigration(\n\t\t\t\t[]int{1, 2},\n\t\t\t\t[]int{4},\n\t\t\t),\n\t\t},\n\t}\n\n\tfor _, tt := range migrationTests {\n\t\ttest := tt\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tmigtest.ApplyMigration(\n\t\t\t\tt,\n\t\t\t\ttest.beforeMigrationFunc,\n\t\t\t\ttest.afterMigrationFunc,\n\t\t\t\tMigrateFwdPkgCleanup,\n\t\t\t\tfalse,\n\t\t\t)\n\t\t})\n\t}\n}\n",
      "length": 1959,
      "tokens": 232,
      "embedding": []
    },
    {
      "slug": "func genBeforeMigration(isPending bool,",
      "content": "func genBeforeMigration(isPending bool,\n\tcloseSummeryChanIDs, fwdPkgChanIDs []int) func(kvdb.RwTx) error {\n\n\treturn func(tx kvdb.RwTx) error {\n\t\t// Create closed channel summeries\n\t\tfor _, id := range closeSummeryChanIDs {\n\t\t\tchanID := lnwire.NewShortChanIDFromInt(uint64(id))\n\t\t\tif err := createTestCloseChannelSummery(\n\t\t\t\ttx, isPending, chanID,\n\t\t\t); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\t// Create fwdPkg nested buckets\n\t\tfor _, id := range fwdPkgChanIDs {\n\t\t\tchanID := lnwire.NewShortChanIDFromInt(uint64(id))\n\t\t\terr := createTestFwdPkgBucket(tx, chanID)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}\n}\n",
      "length": 559,
      "tokens": 74,
      "embedding": []
    },
    {
      "slug": "func genAfterMigration(deleted, untouched []int) func(kvdb.RwTx) error {",
      "content": "func genAfterMigration(deleted, untouched []int) func(kvdb.RwTx) error {\n\treturn func(tx kvdb.RwTx) error {\n\t\tfwdPkgBkt := tx.ReadBucket(fwdPackagesKey)\n\t\tif fwdPkgBkt == nil {\n\t\t\treturn errors.New(\"unable to find bucket\")\n\t\t}\n\n\t\t// Reading deleted buckets should return nil\n\t\tfor _, id := range deleted {\n\t\t\tchanID := lnwire.NewShortChanIDFromInt(uint64(id))\n\t\t\tsourceKey := MakeLogKey(chanID.ToUint64())\n\t\t\tsourceBkt := fwdPkgBkt.NestedReadBucket(sourceKey[:])\n\t\t\tif sourceBkt != nil {\n\t\t\t\treturn fmt.Errorf(\n\t\t\t\t\t\"expected bucket to be deleted: %v\",\n\t\t\t\t\tid,\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\n\t\t// Reading untouched buckets should return not nil\n\t\tfor _, id := range untouched {\n\t\t\tchanID := lnwire.NewShortChanIDFromInt(uint64(id))\n\t\t\tsourceKey := MakeLogKey(chanID.ToUint64())\n\t\t\tsourceBkt := fwdPkgBkt.NestedReadBucket(sourceKey[:])\n\t\t\tif sourceBkt == nil {\n\t\t\t\treturn fmt.Errorf(\n\t\t\t\t\t\"expected bucket to not be deleted: %v\",\n\t\t\t\t\tid,\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}\n}\n\n// createTestCloseChannelSummery creates a CloseChannelSummery for testing.",
      "length": 925,
      "tokens": 112,
      "embedding": []
    },
    {
      "slug": "func createTestCloseChannelSummery(tx kvdb.RwTx, isPending bool,",
      "content": "func createTestCloseChannelSummery(tx kvdb.RwTx, isPending bool,\n\tchanID lnwire.ShortChannelID) error {\n\n\tclosedChanBucket, err := tx.CreateTopLevelBucket(closedChannelBucket)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\toutputPoint := wire.OutPoint{Hash: key, Index: rand.Uint32()}\n\n\tccs := &mig.ChannelCloseSummary{\n\t\tChanPoint:      outputPoint,\n\t\tShortChanID:    chanID,\n\t\tChainHash:      key,\n\t\tClosingTXID:    testTx.TxHash(),\n\t\tCloseHeight:    100,\n\t\tRemotePub:      pubKey,\n\t\tCapacity:       btcutil.Amount(10000),\n\t\tSettledBalance: btcutil.Amount(50000),\n\t\tCloseType:      mig.RemoteForceClose,\n\t\tIsPending:      isPending,\n\t\t// Optional fields\n\t\tRemoteCurrentRevocation: pubKey,\n\t\tRemoteNextRevocation:    pubKey,\n\t}\n\tvar b bytes.Buffer\n\tif err := serializeChannelCloseSummary(&b, ccs); err != nil {\n\t\treturn err\n\t}\n\n\tvar chanPointBuf bytes.Buffer\n\tif err := writeOutpoint(&chanPointBuf, &outputPoint); err != nil {\n\t\treturn err\n\t}\n\n\treturn closedChanBucket.Put(chanPointBuf.Bytes(), b.Bytes())\n}\n",
      "length": 896,
      "tokens": 87,
      "embedding": []
    },
    {
      "slug": "func createTestFwdPkgBucket(tx kvdb.RwTx, chanID lnwire.ShortChannelID) error {",
      "content": "func createTestFwdPkgBucket(tx kvdb.RwTx, chanID lnwire.ShortChannelID) error {\n\tfwdPkgBkt, err := tx.CreateTopLevelBucket(fwdPackagesKey)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsource := MakeLogKey(chanID.ToUint64())\n\tif _, err := fwdPkgBkt.CreateBucketIfNotExists(source[:]); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n",
      "length": 226,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func serializeChannelCloseSummary(",
      "content": "func serializeChannelCloseSummary(\n\tw io.Writer, cs *mig.ChannelCloseSummary) error {\n\n\terr := mig.WriteElements(\n\t\tw,\n\t\tcs.ChanPoint, cs.ShortChanID, cs.ChainHash, cs.ClosingTXID,\n\t\tcs.CloseHeight, cs.RemotePub, cs.Capacity, cs.SettledBalance,\n\t\tcs.TimeLockedBalance, cs.CloseType, cs.IsPending,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// writeOutpoint writes an outpoint to the passed writer using the minimal\n// amount of bytes possible.",
      "length": 401,
      "tokens": 50,
      "embedding": []
    },
    {
      "slug": "func writeOutpoint(w io.Writer, o *wire.OutPoint) error {",
      "content": "func writeOutpoint(w io.Writer, o *wire.OutPoint) error {\n\tif _, err := w.Write(o.Hash[:]); err != nil {\n\t\treturn err\n\t}\n\tif err := binary.Write(w, binary.BigEndian, o.Index); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n",
      "length": 153,
      "tokens": 28,
      "embedding": []
    }
  ]
}