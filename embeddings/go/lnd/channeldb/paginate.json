{
  "filepath": "../implementations/go/lnd/channeldb/paginate.go",
  "package": "channeldb",
  "sections": [
    {
      "slug": "type paginator struct {",
      "content": "type paginator struct {\n\t// cursor is the cursor which we are using to iterate through a bucket.\n\tcursor kvdb.RCursor\n\n\t// reversed indicates whether we are paginating forwards or backwards.\n\treversed bool\n\n\t// indexOffset is the index from which we will begin querying.\n\tindexOffset uint64\n\n\t// totalItems is the total number of items we allow in our response.\n\ttotalItems uint64\n}\n\n// newPaginator returns a struct which can be used to query an indexed bucket\n// in pages.",
      "length": 436,
      "tokens": 74,
      "embedding": []
    },
    {
      "slug": "func newPaginator(c kvdb.RCursor, reversed bool,",
      "content": "func newPaginator(c kvdb.RCursor, reversed bool,\n\tindexOffset, totalItems uint64) paginator {\n\n\treturn paginator{\n\t\tcursor:      c,\n\t\treversed:    reversed,\n\t\tindexOffset: indexOffset,\n\t\ttotalItems:  totalItems,\n\t}\n}\n\n// keyValueForIndex seeks our cursor to a given index and returns the key and\n// value at that position.",
      "length": 262,
      "tokens": 36,
      "embedding": []
    },
    {
      "slug": "func (p paginator) keyValueForIndex(index uint64) ([]byte, []byte) {",
      "content": "func (p paginator) keyValueForIndex(index uint64) ([]byte, []byte) {\n\tvar keyIndex [8]byte\n\tbyteOrder.PutUint64(keyIndex[:], index)\n\treturn p.cursor.Seek(keyIndex[:])\n}\n\n// lastIndex returns the last value in our index, if our index is empty it\n// returns 0.",
      "length": 183,
      "tokens": 26,
      "embedding": []
    },
    {
      "slug": "func (p paginator) lastIndex() uint64 {",
      "content": "func (p paginator) lastIndex() uint64 {\n\tkeyIndex, _ := p.cursor.Last()\n\tif keyIndex == nil {\n\t\treturn 0\n\t}\n\n\treturn byteOrder.Uint64(keyIndex)\n}\n\n// nextKey is a helper closure to determine what key we should use next when\n// we are iterating, depending on whether we are iterating forwards or in\n// reverse.",
      "length": 259,
      "tokens": 45,
      "embedding": []
    },
    {
      "slug": "func (p paginator) nextKey() ([]byte, []byte) {",
      "content": "func (p paginator) nextKey() ([]byte, []byte) {\n\tif p.reversed {\n\t\treturn p.cursor.Prev()\n\t}\n\treturn p.cursor.Next()\n}\n\n// cursorStart gets the index key and value for the first item we are looking\n// up, taking into account that we may be paginating in reverse. The index\n// offset provided is *excusive* so we will start with the item after the offset\n// for forwards queries, and the item before the index for backwards queries.",
      "length": 374,
      "tokens": 66,
      "embedding": []
    },
    {
      "slug": "func (p paginator) cursorStart() ([]byte, []byte) {",
      "content": "func (p paginator) cursorStart() ([]byte, []byte) {\n\tindexKey, indexValue := p.keyValueForIndex(p.indexOffset + 1)\n\n\t// If the query is specifying reverse iteration, then we must\n\t// handle a few offset cases.\n\tif p.reversed {\n\t\tswitch {\n\t\t// This indicates the default case, where no offset was\n\t\t// specified. In that case we just start from the last\n\t\t// entry.\n\t\tcase p.indexOffset == 0:\n\t\t\tindexKey, indexValue = p.cursor.Last()\n\n\t\t// This indicates the offset being set to the very\n\t\t// first entry. Since there are no entries before\n\t\t// this offset, and the direction is reversed, we can\n\t\t// return without adding any invoices to the response.\n\t\tcase p.indexOffset == 1:\n\t\t\treturn nil, nil\n\n\t\t// If we have been given an index offset that is beyond our last\n\t\t// index value, we just return the last indexed value in our set\n\t\t// since we are querying in reverse. We do not cover the case\n\t\t// where our index offset equals our last index value, because\n\t\t// index offset is exclusive, so we would want to start at the\n\t\t// value before our last index.\n\t\tcase p.indexOffset > p.lastIndex():\n\t\t\treturn p.cursor.Last()\n\n\t\t// Otherwise we have an index offset which is within our set of\n\t\t// indexed keys, and we want to start at the item before our\n\t\t// offset. We seek to our index offset, then return the element\n\t\t// before it. We do this rather than p.indexOffset-1 to account\n\t\t// for indexes that have gaps.\n\t\tdefault:\n\t\t\tp.keyValueForIndex(p.indexOffset)\n\t\t\tindexKey, indexValue = p.cursor.Prev()\n\t\t}\n\t}\n\n\treturn indexKey, indexValue\n}\n\n// query gets the start point for our index offset and iterates through keys\n// in our index until we reach the total number of items required for the query\n// or we run out of cursor values. This function takes a fetchAndAppend function\n// which is responsible for looking up the entry at that index, adding the entry\n// to its set of return items (if desired) and return a boolean which indicates\n// whether the item was added. This is required to allow the paginator to\n// determine when the response has the maximum number of required items.",
      "length": 1996,
      "tokens": 347,
      "embedding": []
    },
    {
      "slug": "func (p paginator) query(fetchAndAppend func(k, v []byte) (bool, error)) error {",
      "content": "func (p paginator) query(fetchAndAppend func(k, v []byte) (bool, error)) error {\n\tindexKey, indexValue := p.cursorStart()\n\n\tvar totalItems int\n\tfor ; indexKey != nil; indexKey, indexValue = p.nextKey() {\n\t\t// If our current return payload exceeds the max number\n\t\t// of invoices, then we'll exit now.\n\t\tif uint64(totalItems) >= p.totalItems {\n\t\t\tbreak\n\t\t}\n\n\t\tadded, err := fetchAndAppend(indexKey, indexValue)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// If we added an item to our set in the latest fetch and append\n\t\t// we increment our total count.\n\t\tif added {\n\t\t\ttotalItems++\n\t\t}\n\t}\n\n\treturn nil\n}\n",
      "length": 495,
      "tokens": 84,
      "embedding": []
    }
  ]
}