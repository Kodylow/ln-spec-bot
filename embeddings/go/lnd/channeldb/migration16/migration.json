{
  "filepath": "../implementations/go/lnd/channeldb/migration16/migration.go",
  "package": "migration16",
  "sections": [
    {
      "slug": "type paymentIndexType uint8",
      "content": "type paymentIndexType uint8\n\n// paymentIndexTypeHash is a payment index type which indicates that we have\n// created an index of payment sequence number to payment hash.\nconst paymentIndexTypeHash paymentIndexType = 0\n\n// paymentIndex stores all the information we require to create an index by\n// sequence number for a payment.",
      "length": 294,
      "tokens": 47,
      "embedding": []
    },
    {
      "slug": "type paymentIndex struct {",
      "content": "type paymentIndex struct {\n\t// paymentHash is the hash of the payment, which is its key in the\n\t// payment root bucket.\n\tpaymentHash []byte\n\n\t// sequenceNumbers is the set of sequence numbers associated with this\n\t// payment hash. There will be more than one sequence number in the\n\t// case where duplicate payments are present.\n\tsequenceNumbers [][]byte\n}\n\n// MigrateSequenceIndex migrates the payments db to contain a new bucket which\n// provides an index from sequence number to payment hash. This is required\n// for more efficient sequential lookup of payments, which are keyed by payment\n// hash before this migration.",
      "length": 583,
      "tokens": 97,
      "embedding": []
    },
    {
      "slug": "func MigrateSequenceIndex(tx kvdb.RwTx) error {",
      "content": "func MigrateSequenceIndex(tx kvdb.RwTx) error {\n\tlog.Infof(\"Migrating payments to add sequence number index\")\n\n\t// Get a list of indices we need to write.\n\tindexList, err := getPaymentIndexList(tx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Create the top level bucket that we will use to index payments in.\n\tbucket, err := tx.CreateTopLevelBucket(paymentsIndexBucket)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Write an index for each of our payments.\n\tfor _, index := range indexList {\n\t\t// Write indexes for each of our sequence numbers.\n\t\tfor _, seqNr := range index.sequenceNumbers {\n\t\t\terr := putIndex(bucket, seqNr, index.paymentHash)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// putIndex performs a sanity check that ensures we are not writing duplicate\n// indexes to disk then creates the index provided.",
      "length": 746,
      "tokens": 127,
      "embedding": []
    },
    {
      "slug": "func putIndex(bucket kvdb.RwBucket, sequenceNr, paymentHash []byte) error {",
      "content": "func putIndex(bucket kvdb.RwBucket, sequenceNr, paymentHash []byte) error {\n\t// Add a sanity check that we do not already have an entry with\n\t// this sequence number.\n\texistingEntry := bucket.Get(sequenceNr)\n\tif existingEntry != nil {\n\t\treturn fmt.Errorf(\"sequence number: %x duplicated\",\n\t\t\tsequenceNr)\n\t}\n\n\tbytes, err := serializePaymentIndexEntry(paymentHash)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn bucket.Put(sequenceNr, bytes)\n}\n\n// serializePaymentIndexEntry serializes a payment hash typed index. The value\n// produced contains a payment index type (which can be used in future to\n// signal different payment index types) and the payment hash.",
      "length": 559,
      "tokens": 83,
      "embedding": []
    },
    {
      "slug": "func serializePaymentIndexEntry(hash []byte) ([]byte, error) {",
      "content": "func serializePaymentIndexEntry(hash []byte) ([]byte, error) {\n\tvar b bytes.Buffer\n\n\terr := binary.Write(&b, byteOrder, paymentIndexTypeHash)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := wire.WriteVarBytes(&b, 0, hash); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn b.Bytes(), nil\n}\n\n// getPaymentIndexList gets a list of indices we need to write for our current\n// set of payments.",
      "length": 306,
      "tokens": 53,
      "embedding": []
    },
    {
      "slug": "func getPaymentIndexList(tx kvdb.RTx) ([]paymentIndex, error) {",
      "content": "func getPaymentIndexList(tx kvdb.RTx) ([]paymentIndex, error) {\n\t// Iterate over all payments and store their indexing keys. This is\n\t// needed, because no modifications are allowed inside a Bucket.ForEach\n\t// loop.\n\tpaymentsBucket := tx.ReadBucket(paymentsRootBucket)\n\tif paymentsBucket == nil {\n\t\treturn nil, nil\n\t}\n\n\tvar indexList []paymentIndex\n\terr := paymentsBucket.ForEach(func(k, v []byte) error {\n\t\t// Get the bucket which contains the payment, fail if the key\n\t\t// does not have a bucket.\n\t\tbucket := paymentsBucket.NestedReadBucket(k)\n\t\tif bucket == nil {\n\t\t\treturn fmt.Errorf(\"non bucket element in \" +\n\t\t\t\t\"payments bucket\")\n\t\t}\n\t\tseqBytes := bucket.Get(paymentSequenceKey)\n\t\tif seqBytes == nil {\n\t\t\treturn fmt.Errorf(\"nil sequence number bytes\")\n\t\t}\n\n\t\tseqNrs, err := fetchSequenceNumbers(bucket)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Create an index object with our payment hash and sequence\n\t\t// numbers and append it to our set of indexes.\n\t\tindex := paymentIndex{\n\t\t\tpaymentHash:     k,\n\t\t\tsequenceNumbers: seqNrs,\n\t\t}\n\n\t\tindexList = append(indexList, index)\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn indexList, nil\n}\n\n// fetchSequenceNumbers fetches all the sequence numbers associated with a\n// payment, including those belonging to any duplicate payments.",
      "length": 1193,
      "tokens": 176,
      "embedding": []
    },
    {
      "slug": "func fetchSequenceNumbers(paymentBucket kvdb.RBucket) ([][]byte, error) {",
      "content": "func fetchSequenceNumbers(paymentBucket kvdb.RBucket) ([][]byte, error) {\n\tseqNum := paymentBucket.Get(paymentSequenceKey)\n\tif seqNum == nil {\n\t\treturn nil, errors.New(\"expected sequence number\")\n\t}\n\n\tsequenceNumbers := [][]byte{seqNum}\n\n\t// Get the duplicate payments bucket, if it has no duplicates, just\n\t// return early with the payment sequence number.\n\tduplicates := paymentBucket.NestedReadBucket(duplicatePaymentsBucket)\n\tif duplicates == nil {\n\t\treturn sequenceNumbers, nil\n\t}\n\n\t// If we do have duplicated, they are keyed by sequence number, so we\n\t// iterate through the duplicates bucket and add them to our set of\n\t// sequence numbers.\n\tif err := duplicates.ForEach(func(k, v []byte) error {\n\t\tsequenceNumbers = append(sequenceNumbers, k)\n\t\treturn nil\n\t}); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn sequenceNumbers, nil\n}\n",
      "length": 736,
      "tokens": 106,
      "embedding": []
    }
  ]
}