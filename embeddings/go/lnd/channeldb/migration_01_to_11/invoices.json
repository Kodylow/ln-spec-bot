{
  "filepath": "../implementations/go/lnd/channeldb/migration_01_to_11/invoices.go",
  "package": "migration_01_to_11",
  "sections": [
    {
      "slug": "type ContractState uint8",
      "content": "type ContractState uint8\n\nconst (\n\t// ContractOpen means the invoice has only been created.\n\tContractOpen ContractState = 0\n\n\t// ContractSettled means the htlc is settled and the invoice has been\n\t// paid.\n\tContractSettled ContractState = 1\n\n\t// ContractCanceled means the invoice has been canceled.\n\tContractCanceled ContractState = 2\n\n\t// ContractAccepted means the HTLC has been accepted but not settled\n\t// yet.\n\tContractAccepted ContractState = 3\n)\n\n// String returns a human readable identifier for the ContractState type.",
      "length": 486,
      "tokens": 74,
      "embedding": []
    },
    {
      "slug": "func (c ContractState) String() string {",
      "content": "func (c ContractState) String() string {\n\tswitch c {\n\tcase ContractOpen:\n\t\treturn \"Open\"\n\tcase ContractSettled:\n\t\treturn \"Settled\"\n\tcase ContractCanceled:\n\t\treturn \"Canceled\"\n\tcase ContractAccepted:\n\t\treturn \"Accepted\"\n\t}\n\n\treturn \"Unknown\"\n}\n\n// ContractTerm is a companion struct to the Invoice struct. This struct houses\n// the necessary conditions required before the invoice can be considered fully\n// settled by the payee.",
      "length": 371,
      "tokens": 53,
      "embedding": []
    },
    {
      "slug": "type ContractTerm struct {",
      "content": "type ContractTerm struct {\n\t// PaymentPreimage is the preimage which is to be revealed in the\n\t// occasion that an HTLC paying to the hash of this preimage is\n\t// extended.\n\tPaymentPreimage lntypes.Preimage\n\n\t// Value is the expected amount of milli-satoshis to be paid to an HTLC\n\t// which can be satisfied by the above preimage.\n\tValue lnwire.MilliSatoshi\n\n\t// State describes the state the invoice is in.\n\tState ContractState\n}\n\n// Invoice is a payment invoice generated by a payee in order to request\n// payment for some good or service. The inclusion of invoices within Lightning\n// creates a payment work flow for merchants very similar to that of the\n// existing financial system within PayPal, etc.  Invoices are added to the\n// database when a payment is requested, then can be settled manually once the\n// payment is received at the upper layer. For record keeping purposes,\n// invoices are never deleted from the database, instead a bit is toggled\n// denoting the invoice has been fully settled. Within the database, all\n// invoices must have a unique payment hash which is generated by taking the\n// sha256 of the payment preimage.",
      "length": 1094,
      "tokens": 190,
      "embedding": []
    },
    {
      "slug": "type Invoice struct {",
      "content": "type Invoice struct {\n\t// Memo is an optional memo to be stored along side an invoice.  The\n\t// memo may contain further details pertaining to the invoice itself,\n\t// or any other message which fits within the size constraints.\n\tMemo []byte\n\n\t// Receipt is an optional field dedicated for storing a\n\t// cryptographically binding receipt of payment.\n\t//\n\t// TODO(roasbeef): document scheme.\n\tReceipt []byte\n\n\t// PaymentRequest is an optional field where a payment request created\n\t// for this invoice can be stored.\n\tPaymentRequest []byte\n\n\t// FinalCltvDelta is the minimum required number of blocks before htlc\n\t// expiry when the invoice is accepted.\n\tFinalCltvDelta int32\n\n\t// Expiry defines how long after creation this invoice should expire.\n\tExpiry time.Duration\n\n\t// CreationDate is the exact time the invoice was created.\n\tCreationDate time.Time\n\n\t// SettleDate is the exact time the invoice was settled.\n\tSettleDate time.Time\n\n\t// Terms are the contractual payment terms of the invoice. Once all the\n\t// terms have been satisfied by the payer, then the invoice can be\n\t// considered fully fulfilled.\n\t//\n\t// TODO(roasbeef): later allow for multiple terms to fulfill the final\n\t// invoice: payment fragmentation, etc.\n\tTerms ContractTerm\n\n\t// AddIndex is an auto-incrementing integer that acts as a\n\t// monotonically increasing sequence number for all invoices created.\n\t// Clients can then use this field as a \"checkpoint\" of sorts when\n\t// implementing a streaming RPC to notify consumers of instances where\n\t// an invoice has been added before they re-connected.\n\t//\n\t// NOTE: This index starts at 1.\n\tAddIndex uint64\n\n\t// SettleIndex is an auto-incrementing integer that acts as a\n\t// monotonically increasing sequence number for all settled invoices.\n\t// Clients can then use this field as a \"checkpoint\" of sorts when\n\t// implementing a streaming RPC to notify consumers of instances where\n\t// an invoice has been settled before they re-connected.\n\t//\n\t// NOTE: This index starts at 1.\n\tSettleIndex uint64\n\n\t// AmtPaid is the final amount that we ultimately accepted for pay for\n\t// this invoice. We specify this value independently as it's possible\n\t// that the invoice originally didn't specify an amount, or the sender\n\t// overpaid.\n\tAmtPaid lnwire.MilliSatoshi\n\n\t// Htlcs records all htlcs that paid to this invoice. Some of these\n\t// htlcs may have been marked as canceled.\n\tHtlcs map[CircuitKey]*InvoiceHTLC\n}\n\n// HtlcState defines the states an htlc paying to an invoice can be in.",
      "length": 2414,
      "tokens": 389,
      "embedding": []
    },
    {
      "slug": "type HtlcState uint8",
      "content": "type HtlcState uint8\n\n// InvoiceHTLC contains details about an htlc paying to this invoice.",
      "length": 69,
      "tokens": 11,
      "embedding": []
    },
    {
      "slug": "type InvoiceHTLC struct {",
      "content": "type InvoiceHTLC struct {\n\t// Amt is the amount that is carried by this htlc.\n\tAmt lnwire.MilliSatoshi\n\n\t// AcceptHeight is the block height at which the invoice registry\n\t// decided to accept this htlc as a payment to the invoice. At this\n\t// height, the invoice cltv delay must have been met.\n\tAcceptHeight uint32\n\n\t// AcceptTime is the wall clock time at which the invoice registry\n\t// decided to accept the htlc.\n\tAcceptTime time.Time\n\n\t// ResolveTime is the wall clock time at which the invoice registry\n\t// decided to settle the htlc.\n\tResolveTime time.Time\n\n\t// Expiry is the expiry height of this htlc.\n\tExpiry uint32\n\n\t// State indicates the state the invoice htlc is currently in. A\n\t// canceled htlc isn't just removed from the invoice htlcs map, because\n\t// we need AcceptHeight to properly cancel the htlc back.\n\tState HtlcState\n}\n",
      "length": 794,
      "tokens": 138,
      "embedding": []
    },
    {
      "slug": "func validateInvoice(i *Invoice) error {",
      "content": "func validateInvoice(i *Invoice) error {\n\tif len(i.Memo) > MaxMemoSize {\n\t\treturn fmt.Errorf(\"max length a memo is %v, and invoice \"+\n\t\t\t\"of length %v was provided\", MaxMemoSize, len(i.Memo))\n\t}\n\tif len(i.Receipt) > MaxReceiptSize {\n\t\treturn fmt.Errorf(\"max length a receipt is %v, and invoice \"+\n\t\t\t\"of length %v was provided\", MaxReceiptSize,\n\t\t\tlen(i.Receipt))\n\t}\n\tif len(i.PaymentRequest) > MaxPaymentRequestSize {\n\t\treturn fmt.Errorf(\"max length of payment request is %v, length \"+\n\t\t\t\"provided was %v\", MaxPaymentRequestSize,\n\t\t\tlen(i.PaymentRequest))\n\t}\n\treturn nil\n}\n\n// FetchAllInvoices returns all invoices currently stored within the database.\n// If the pendingOnly param is true, then only unsettled invoices will be\n// returned, skipping all invoices that are fully settled.",
      "length": 727,
      "tokens": 102,
      "embedding": []
    },
    {
      "slug": "func (d *DB) FetchAllInvoices(pendingOnly bool) ([]Invoice, error) {",
      "content": "func (d *DB) FetchAllInvoices(pendingOnly bool) ([]Invoice, error) {\n\tvar invoices []Invoice\n\n\terr := kvdb.View(d, func(tx kvdb.RTx) error {\n\t\tinvoiceB := tx.ReadBucket(invoiceBucket)\n\t\tif invoiceB == nil {\n\t\t\treturn ErrNoInvoicesCreated\n\t\t}\n\n\t\t// Iterate through the entire key space of the top-level\n\t\t// invoice bucket. If key with a non-nil value stores the next\n\t\t// invoice ID which maps to the corresponding invoice.\n\t\treturn invoiceB.ForEach(func(k, v []byte) error {\n\t\t\tif v == nil {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tinvoiceReader := bytes.NewReader(v)\n\t\t\tinvoice, err := deserializeInvoice(invoiceReader)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif pendingOnly &&\n\t\t\t\tinvoice.Terms.State == ContractSettled {\n\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tinvoices = append(invoices, invoice)\n\n\t\t\treturn nil\n\t\t})\n\t}, func() {\n\t\tinvoices = nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn invoices, nil\n}\n\n// serializeInvoice serializes an invoice to a writer.\n//\n// Note: this function is in use for a migration. Before making changes that\n// would modify the on disk format, make a copy of the original code and store\n// it with the migration.",
      "length": 1016,
      "tokens": 162,
      "embedding": []
    },
    {
      "slug": "func serializeInvoice(w io.Writer, i *Invoice) error {",
      "content": "func serializeInvoice(w io.Writer, i *Invoice) error {\n\tif err := wire.WriteVarBytes(w, 0, i.Memo[:]); err != nil {\n\t\treturn err\n\t}\n\tif err := wire.WriteVarBytes(w, 0, i.Receipt[:]); err != nil {\n\t\treturn err\n\t}\n\tif err := wire.WriteVarBytes(w, 0, i.PaymentRequest[:]); err != nil {\n\t\treturn err\n\t}\n\n\tif err := binary.Write(w, byteOrder, i.FinalCltvDelta); err != nil {\n\t\treturn err\n\t}\n\n\tif err := binary.Write(w, byteOrder, int64(i.Expiry)); err != nil {\n\t\treturn err\n\t}\n\n\tbirthBytes, err := i.CreationDate.MarshalBinary()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := wire.WriteVarBytes(w, 0, birthBytes); err != nil {\n\t\treturn err\n\t}\n\n\tsettleBytes, err := i.SettleDate.MarshalBinary()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := wire.WriteVarBytes(w, 0, settleBytes); err != nil {\n\t\treturn err\n\t}\n\n\tif _, err := w.Write(i.Terms.PaymentPreimage[:]); err != nil {\n\t\treturn err\n\t}\n\n\tvar scratch [8]byte\n\tbyteOrder.PutUint64(scratch[:], uint64(i.Terms.Value))\n\tif _, err := w.Write(scratch[:]); err != nil {\n\t\treturn err\n\t}\n\n\tif err := binary.Write(w, byteOrder, i.Terms.State); err != nil {\n\t\treturn err\n\t}\n\n\tif err := binary.Write(w, byteOrder, i.AddIndex); err != nil {\n\t\treturn err\n\t}\n\tif err := binary.Write(w, byteOrder, i.SettleIndex); err != nil {\n\t\treturn err\n\t}\n\tif err := binary.Write(w, byteOrder, int64(i.AmtPaid)); err != nil {\n\t\treturn err\n\t}\n\n\tif err := serializeHtlcs(w, i.Htlcs); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// serializeHtlcs serializes a map containing circuit keys and invoice htlcs to\n// a writer.",
      "length": 1411,
      "tokens": 226,
      "embedding": []
    },
    {
      "slug": "func serializeHtlcs(w io.Writer, htlcs map[CircuitKey]*InvoiceHTLC) error {",
      "content": "func serializeHtlcs(w io.Writer, htlcs map[CircuitKey]*InvoiceHTLC) error {\n\tfor key, htlc := range htlcs {\n\t\t// Encode the htlc in a tlv stream.\n\t\tchanID := key.ChanID.ToUint64()\n\t\tamt := uint64(htlc.Amt)\n\t\tacceptTime := uint64(htlc.AcceptTime.UnixNano())\n\t\tresolveTime := uint64(htlc.ResolveTime.UnixNano())\n\t\tstate := uint8(htlc.State)\n\n\t\ttlvStream, err := tlv.NewStream(\n\t\t\ttlv.MakePrimitiveRecord(chanIDType, &chanID),\n\t\t\ttlv.MakePrimitiveRecord(htlcIDType, &key.HtlcID),\n\t\t\ttlv.MakePrimitiveRecord(amtType, &amt),\n\t\t\ttlv.MakePrimitiveRecord(\n\t\t\t\tacceptHeightType, &htlc.AcceptHeight,\n\t\t\t),\n\t\t\ttlv.MakePrimitiveRecord(acceptTimeType, &acceptTime),\n\t\t\ttlv.MakePrimitiveRecord(resolveTimeType, &resolveTime),\n\t\t\ttlv.MakePrimitiveRecord(expiryHeightType, &htlc.Expiry),\n\t\t\ttlv.MakePrimitiveRecord(stateType, &state),\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvar b bytes.Buffer\n\t\tif err := tlvStream.Encode(&b); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Write the length of the tlv stream followed by the stream\n\t\t// bytes.\n\t\terr = binary.Write(w, byteOrder, uint64(b.Len()))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif _, err := w.Write(b.Bytes()); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n",
      "length": 1076,
      "tokens": 118,
      "embedding": []
    },
    {
      "slug": "func deserializeInvoice(r io.Reader) (Invoice, error) {",
      "content": "func deserializeInvoice(r io.Reader) (Invoice, error) {\n\tvar err error\n\tinvoice := Invoice{}\n\n\t// TODO(roasbeef): use read full everywhere\n\tinvoice.Memo, err = wire.ReadVarBytes(r, 0, MaxMemoSize, \"\")\n\tif err != nil {\n\t\treturn invoice, err\n\t}\n\tinvoice.Receipt, err = wire.ReadVarBytes(r, 0, MaxReceiptSize, \"\")\n\tif err != nil {\n\t\treturn invoice, err\n\t}\n\n\tinvoice.PaymentRequest, err = wire.ReadVarBytes(r, 0, MaxPaymentRequestSize, \"\")\n\tif err != nil {\n\t\treturn invoice, err\n\t}\n\n\tif err := binary.Read(r, byteOrder, &invoice.FinalCltvDelta); err != nil {\n\t\treturn invoice, err\n\t}\n\n\tvar expiry int64\n\tif err := binary.Read(r, byteOrder, &expiry); err != nil {\n\t\treturn invoice, err\n\t}\n\tinvoice.Expiry = time.Duration(expiry)\n\n\tbirthBytes, err := wire.ReadVarBytes(r, 0, 300, \"birth\")\n\tif err != nil {\n\t\treturn invoice, err\n\t}\n\tif err := invoice.CreationDate.UnmarshalBinary(birthBytes); err != nil {\n\t\treturn invoice, err\n\t}\n\n\tsettledBytes, err := wire.ReadVarBytes(r, 0, 300, \"settled\")\n\tif err != nil {\n\t\treturn invoice, err\n\t}\n\tif err := invoice.SettleDate.UnmarshalBinary(settledBytes); err != nil {\n\t\treturn invoice, err\n\t}\n\n\tif _, err := io.ReadFull(r, invoice.Terms.PaymentPreimage[:]); err != nil {\n\t\treturn invoice, err\n\t}\n\tvar scratch [8]byte\n\tif _, err := io.ReadFull(r, scratch[:]); err != nil {\n\t\treturn invoice, err\n\t}\n\tinvoice.Terms.Value = lnwire.MilliSatoshi(byteOrder.Uint64(scratch[:]))\n\n\tif err := binary.Read(r, byteOrder, &invoice.Terms.State); err != nil {\n\t\treturn invoice, err\n\t}\n\n\tif err := binary.Read(r, byteOrder, &invoice.AddIndex); err != nil {\n\t\treturn invoice, err\n\t}\n\tif err := binary.Read(r, byteOrder, &invoice.SettleIndex); err != nil {\n\t\treturn invoice, err\n\t}\n\tif err := binary.Read(r, byteOrder, &invoice.AmtPaid); err != nil {\n\t\treturn invoice, err\n\t}\n\n\tinvoice.Htlcs, err = deserializeHtlcs(r)\n\tif err != nil {\n\t\treturn Invoice{}, err\n\t}\n\n\treturn invoice, nil\n}\n\n// deserializeHtlcs reads a list of invoice htlcs from a reader and returns it\n// as a map.",
      "length": 1863,
      "tokens": 275,
      "embedding": []
    },
    {
      "slug": "func deserializeHtlcs(r io.Reader) (map[CircuitKey]*InvoiceHTLC, error) {",
      "content": "func deserializeHtlcs(r io.Reader) (map[CircuitKey]*InvoiceHTLC, error) {\n\thtlcs := make(map[CircuitKey]*InvoiceHTLC, 0)\n\n\tfor {\n\t\t// Read the length of the tlv stream for this htlc.\n\t\tvar streamLen uint64\n\t\tif err := binary.Read(r, byteOrder, &streamLen); err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\treturn nil, err\n\t\t}\n\n\t\tstreamBytes := make([]byte, streamLen)\n\t\tif _, err := r.Read(streamBytes); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tstreamReader := bytes.NewReader(streamBytes)\n\n\t\t// Decode the contents into the htlc fields.\n\t\tvar (\n\t\t\thtlc                    InvoiceHTLC\n\t\t\tkey                     CircuitKey\n\t\t\tchanID                  uint64\n\t\t\tstate                   uint8\n\t\t\tacceptTime, resolveTime uint64\n\t\t\tamt                     uint64\n\t\t)\n\t\ttlvStream, err := tlv.NewStream(\n\t\t\ttlv.MakePrimitiveRecord(chanIDType, &chanID),\n\t\t\ttlv.MakePrimitiveRecord(htlcIDType, &key.HtlcID),\n\t\t\ttlv.MakePrimitiveRecord(amtType, &amt),\n\t\t\ttlv.MakePrimitiveRecord(\n\t\t\t\tacceptHeightType, &htlc.AcceptHeight,\n\t\t\t),\n\t\t\ttlv.MakePrimitiveRecord(acceptTimeType, &acceptTime),\n\t\t\ttlv.MakePrimitiveRecord(resolveTimeType, &resolveTime),\n\t\t\ttlv.MakePrimitiveRecord(expiryHeightType, &htlc.Expiry),\n\t\t\ttlv.MakePrimitiveRecord(stateType, &state),\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif err := tlvStream.Decode(streamReader); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tkey.ChanID = lnwire.NewShortChanIDFromInt(chanID)\n\t\thtlc.AcceptTime = time.Unix(0, int64(acceptTime))\n\t\thtlc.ResolveTime = time.Unix(0, int64(resolveTime))\n\t\thtlc.State = HtlcState(state)\n\t\thtlc.Amt = lnwire.MilliSatoshi(amt)\n\n\t\thtlcs[key] = &htlc\n\t}\n\n\treturn htlcs, nil\n}\n",
      "length": 1512,
      "tokens": 154,
      "embedding": []
    }
  ]
}