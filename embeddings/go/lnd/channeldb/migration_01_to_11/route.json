{
  "filepath": "../implementations/go/lnd/channeldb/migration_01_to_11/route.go",
  "package": "migration_01_to_11",
  "sections": [
    {
      "slug": "type Vertex [VertexSize]byte",
      "content": "type Vertex [VertexSize]byte\n\n// NewVertex returns a new Vertex given a public key.",
      "length": 53,
      "tokens": 10,
      "embedding": []
    },
    {
      "slug": "func NewVertex(pub *btcec.PublicKey) Vertex {",
      "content": "func NewVertex(pub *btcec.PublicKey) Vertex {\n\tvar v Vertex\n\tcopy(v[:], pub.SerializeCompressed())\n\treturn v\n}\n\n// NewVertexFromBytes returns a new Vertex based on a serialized pubkey in a\n// byte slice.",
      "length": 151,
      "tokens": 24,
      "embedding": []
    },
    {
      "slug": "func NewVertexFromBytes(b []byte) (Vertex, error) {",
      "content": "func NewVertexFromBytes(b []byte) (Vertex, error) {\n\tvertexLen := len(b)\n\tif vertexLen != VertexSize {\n\t\treturn Vertex{}, fmt.Errorf(\"invalid vertex length of %v, \"+\n\t\t\t\"want %v\", vertexLen, VertexSize)\n\t}\n\n\tvar v Vertex\n\tcopy(v[:], b)\n\treturn v, nil\n}\n\n// NewVertexFromStr returns a new Vertex given its hex-encoded string format.",
      "length": 268,
      "tokens": 41,
      "embedding": []
    },
    {
      "slug": "func NewVertexFromStr(v string) (Vertex, error) {",
      "content": "func NewVertexFromStr(v string) (Vertex, error) {\n\t// Return error if hex string is of incorrect length.\n\tif len(v) != VertexSize*2 {\n\t\treturn Vertex{}, fmt.Errorf(\"invalid vertex string length of \"+\n\t\t\t\"%v, want %v\", len(v), VertexSize*2)\n\t}\n\n\tvertex, err := hex.DecodeString(v)\n\tif err != nil {\n\t\treturn Vertex{}, err\n\t}\n\n\treturn NewVertexFromBytes(vertex)\n}\n\n// String returns a human readable version of the Vertex which is the\n// hex-encoding of the serialized compressed public key.",
      "length": 423,
      "tokens": 66,
      "embedding": []
    },
    {
      "slug": "func (v Vertex) String() string {",
      "content": "func (v Vertex) String() string {\n\treturn fmt.Sprintf(\"%x\", v[:])\n}\n\n// Hop represents an intermediate or final node of the route. This naming\n// is in line with the definition given in BOLT #4: Onion Routing Protocol.\n// The struct houses the channel along which this hop can be reached and\n// the values necessary to create the HTLC that needs to be sent to the\n// next hop. It is also used to encode the per-hop payload included within\n// the Sphinx packet.",
      "length": 418,
      "tokens": 78,
      "embedding": []
    },
    {
      "slug": "type Hop struct {",
      "content": "type Hop struct {\n\t// PubKeyBytes is the raw bytes of the public key of the target node.\n\tPubKeyBytes Vertex\n\n\t// ChannelID is the unique channel ID for the channel. The first 3\n\t// bytes are the block height, the next 3 the index within the block,\n\t// and the last 2 bytes are the output index for the channel.\n\tChannelID uint64\n\n\t// OutgoingTimeLock is the timelock value that should be used when\n\t// crafting the _outgoing_ HTLC from this hop.\n\tOutgoingTimeLock uint32\n\n\t// AmtToForward is the amount that this hop will forward to the next\n\t// hop. This value is less than the value that the incoming HTLC\n\t// carries as a fee will be subtracted by the hop.\n\tAmtToForward lnwire.MilliSatoshi\n\n\t// TLVRecords if non-nil are a set of additional TLV records that\n\t// should be included in the forwarding instructions for this node.\n\tTLVRecords []tlv.Record\n\n\t// LegacyPayload if true, then this signals that this node doesn't\n\t// understand the new TLV payload, so we must instead use the legacy\n\t// payload.\n\tLegacyPayload bool\n}\n\n// PackHopPayload writes to the passed io.Writer, the series of byes that can\n// be placed directly into the per-hop payload (EOB) for this hop. This will\n// include the required routing fields, as well as serializing any of the\n// passed optional TLVRecords.  nextChanID is the unique channel ID that\n// references the _outgoing_ channel ID that follows this hop. This field\n// follows the same semantics as the NextAddress field in the onion: it should\n// be set to zero to indicate the terminal hop.",
      "length": 1483,
      "tokens": 259,
      "embedding": []
    },
    {
      "slug": "func (h *Hop) PackHopPayload(w io.Writer, nextChanID uint64) error {",
      "content": "func (h *Hop) PackHopPayload(w io.Writer, nextChanID uint64) error {\n\t// If this is a legacy payload, then we'll exit here as this method\n\t// shouldn't be called.\n\tif h.LegacyPayload == true {\n\t\treturn fmt.Errorf(\"cannot pack hop payloads for legacy \" +\n\t\t\t\"payloads\")\n\t}\n\n\t// Otherwise, we'll need to make a new stream that includes our\n\t// required routing fields, as well as these optional values.\n\tvar records []tlv.Record\n\n\t// Every hop must have an amount to forward and CLTV expiry.\n\tamt := uint64(h.AmtToForward)\n\trecords = append(records,\n\t\trecord.NewAmtToFwdRecord(&amt),\n\t\trecord.NewLockTimeRecord(&h.OutgoingTimeLock),\n\t)\n\n\t// BOLT 04 says the next_hop_id should be omitted for the final hop,\n\t// but present for all others.\n\t//\n\t// TODO(conner): test using hop.Exit once available\n\tif nextChanID != 0 {\n\t\trecords = append(records,\n\t\t\trecord.NewNextHopIDRecord(&nextChanID),\n\t\t)\n\t}\n\n\t// Append any custom types destined for this hop.\n\trecords = append(records, h.TLVRecords...)\n\n\t// To ensure we produce a canonical stream, we'll sort the records\n\t// before encoding them as a stream in the hop payload.\n\ttlv.SortRecords(records)\n\n\ttlvStream, err := tlv.NewStream(records...)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn tlvStream.Encode(w)\n}\n\n// Route represents a path through the channel graph which runs over one or\n// more channels in succession. This struct carries all the information\n// required to craft the Sphinx onion packet, and send the payment along the\n// first hop in the path. A route is only selected as valid if all the channels\n// have sufficient capacity to carry the initial payment amount after fees are\n// accounted for.",
      "length": 1537,
      "tokens": 242,
      "embedding": []
    },
    {
      "slug": "type Route struct {",
      "content": "type Route struct {\n\t// TotalTimeLock is the cumulative (final) time lock across the entire\n\t// route. This is the CLTV value that should be extended to the first\n\t// hop in the route. All other hops will decrement the time-lock as\n\t// advertised, leaving enough time for all hops to wait for or present\n\t// the payment preimage to complete the payment.\n\tTotalTimeLock uint32\n\n\t// TotalAmount is the total amount of funds required to complete a\n\t// payment over this route. This value includes the cumulative fees at\n\t// each hop. As a result, the HTLC extended to the first-hop in the\n\t// route will need to have at least this many satoshis, otherwise the\n\t// route will fail at an intermediate node due to an insufficient\n\t// amount of fees.\n\tTotalAmount lnwire.MilliSatoshi\n\n\t// SourcePubKey is the pubkey of the node where this route originates\n\t// from.\n\tSourcePubKey Vertex\n\n\t// Hops contains details concerning the specific forwarding details at\n\t// each hop.\n\tHops []*Hop\n}\n\n// HopFee returns the fee charged by the route hop indicated by hopIndex.",
      "length": 1012,
      "tokens": 175,
      "embedding": []
    },
    {
      "slug": "func (r *Route) HopFee(hopIndex int) lnwire.MilliSatoshi {",
      "content": "func (r *Route) HopFee(hopIndex int) lnwire.MilliSatoshi {\n\tvar incomingAmt lnwire.MilliSatoshi\n\tif hopIndex == 0 {\n\t\tincomingAmt = r.TotalAmount\n\t} else {\n\t\tincomingAmt = r.Hops[hopIndex-1].AmtToForward\n\t}\n\n\t// Fee is calculated as difference between incoming and outgoing amount.\n\treturn incomingAmt - r.Hops[hopIndex].AmtToForward\n}\n\n// TotalFees is the sum of the fees paid at each hop within the final route. In\n// the case of a one-hop payment, this value will be zero as we don't need to\n// pay a fee to ourself.",
      "length": 447,
      "tokens": 74,
      "embedding": []
    },
    {
      "slug": "func (r *Route) TotalFees() lnwire.MilliSatoshi {",
      "content": "func (r *Route) TotalFees() lnwire.MilliSatoshi {\n\tif len(r.Hops) == 0 {\n\t\treturn 0\n\t}\n\n\treturn r.TotalAmount - r.Hops[len(r.Hops)-1].AmtToForward\n}\n\n// NewRouteFromHops creates a new Route structure from the minimally required\n// information to perform the payment. It infers fee amounts and populates the\n// node, chan and prev/next hop maps.",
      "length": 285,
      "tokens": 44,
      "embedding": []
    },
    {
      "slug": "func NewRouteFromHops(amtToSend lnwire.MilliSatoshi, timeLock uint32,",
      "content": "func NewRouteFromHops(amtToSend lnwire.MilliSatoshi, timeLock uint32,\n\tsourceVertex Vertex, hops []*Hop) (*Route, error) {\n\n\tif len(hops) == 0 {\n\t\treturn nil, ErrNoRouteHopsProvided\n\t}\n\n\t// First, we'll create a route struct and populate it with the fields\n\t// for which the values are provided as arguments of this function.\n\t// TotalFees is determined based on the difference between the amount\n\t// that is send from the source and the final amount that is received\n\t// by the destination.\n\troute := &Route{\n\t\tSourcePubKey:  sourceVertex,\n\t\tHops:          hops,\n\t\tTotalTimeLock: timeLock,\n\t\tTotalAmount:   amtToSend,\n\t}\n\n\treturn route, nil\n}\n\n// ToSphinxPath converts a complete route into a sphinx PaymentPath that\n// contains the per-hop paylods used to encoding the HTLC routing data for each\n// hop in the route. This method also accepts an optional EOB payload for the\n// final hop.",
      "length": 795,
      "tokens": 129,
      "embedding": []
    },
    {
      "slug": "func (r *Route) ToSphinxPath() (*sphinx.PaymentPath, error) {",
      "content": "func (r *Route) ToSphinxPath() (*sphinx.PaymentPath, error) {\n\tvar path sphinx.PaymentPath\n\n\t// For each hop encoded within the route, we'll convert the hop struct\n\t// to an OnionHop with matching per-hop payload within the path as used\n\t// by the sphinx package.\n\tfor i, hop := range r.Hops {\n\t\tpub, err := btcec.ParsePubKey(hop.PubKeyBytes[:])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// As a base case, the next hop is set to all zeroes in order\n\t\t// to indicate that the \"last hop\" as no further hops after it.\n\t\tnextHop := uint64(0)\n\n\t\t// If we aren't on the last hop, then we set the \"next address\"\n\t\t// field to be the channel that directly follows it.\n\t\tif i != len(r.Hops)-1 {\n\t\t\tnextHop = r.Hops[i+1].ChannelID\n\t\t}\n\n\t\tvar payload sphinx.HopPayload\n\n\t\t// If this is the legacy payload, then we can just include the\n\t\t// hop data as normal.\n\t\tif hop.LegacyPayload {\n\t\t\t// Before we encode this value, we'll pack the next hop\n\t\t\t// into the NextAddress field of the hop info to ensure\n\t\t\t// we point to the right now.\n\t\t\thopData := sphinx.HopData{\n\t\t\t\tForwardAmount: uint64(hop.AmtToForward),\n\t\t\t\tOutgoingCltv:  hop.OutgoingTimeLock,\n\t\t\t}\n\t\t\tbinary.BigEndian.PutUint64(\n\t\t\t\thopData.NextAddress[:], nextHop,\n\t\t\t)\n\n\t\t\tpayload, err = sphinx.NewHopPayload(&hopData, nil)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\t// For non-legacy payloads, we'll need to pack the\n\t\t\t// routing information, along with any extra TLV\n\t\t\t// information into the new per-hop payload format.\n\t\t\t// We'll also pass in the chan ID of the hop this\n\t\t\t// channel should be forwarded to so we can construct a\n\t\t\t// valid payload.\n\t\t\tvar b bytes.Buffer\n\t\t\terr := hop.PackHopPayload(&b, nextHop)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\t// TODO(roasbeef): make better API for NewHopPayload?\n\t\t\tpayload, err = sphinx.NewHopPayload(nil, b.Bytes())\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\tpath[i] = sphinx.OnionHop{\n\t\t\tNodePub:    *pub,\n\t\t\tHopPayload: payload,\n\t\t}\n\t}\n\n\treturn &path, nil\n}\n\n// String returns a human readable representation of the route.",
      "length": 1931,
      "tokens": 312,
      "embedding": []
    },
    {
      "slug": "func (r *Route) String() string {",
      "content": "func (r *Route) String() string {\n\tvar b strings.Builder\n\n\tfor i, hop := range r.Hops {\n\t\tif i > 0 {\n\t\t\tb.WriteString(\",\")\n\t\t}\n\t\tb.WriteString(strconv.FormatUint(hop.ChannelID, 10))\n\t}\n\n\treturn fmt.Sprintf(\"amt=%v, fees=%v, tl=%v, chans=%v\",\n\t\tr.TotalAmount-r.TotalFees(), r.TotalFees(), r.TotalTimeLock,\n\t\tb.String(),\n\t)\n}\n",
      "length": 276,
      "tokens": 31,
      "embedding": []
    }
  ]
}