{
  "filepath": "../implementations/go/lnd/channeldb/migration_01_to_11/codec.go",
  "package": "migration_01_to_11",
  "sections": [
    {
      "slug": "func WriteOutpoint(w io.Writer, o *wire.OutPoint) error {",
      "content": "func WriteOutpoint(w io.Writer, o *wire.OutPoint) error {\n\tif _, err := w.Write(o.Hash[:]); err != nil {\n\t\treturn err\n\t}\n\tif err := binary.Write(w, byteOrder, o.Index); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// ReadOutpoint reads an outpoint from the passed reader that was previously\n// written using the writeOutpoint struct.",
      "length": 264,
      "tokens": 46,
      "embedding": []
    },
    {
      "slug": "func ReadOutpoint(r io.Reader, o *wire.OutPoint) error {",
      "content": "func ReadOutpoint(r io.Reader, o *wire.OutPoint) error {\n\tif _, err := io.ReadFull(r, o.Hash[:]); err != nil {\n\t\treturn err\n\t}\n\tif err := binary.Read(r, byteOrder, &o.Index); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// UnknownElementType is an error returned when the codec is unable to encode or\n// decode a particular type.",
      "length": 261,
      "tokens": 48,
      "embedding": []
    },
    {
      "slug": "type UnknownElementType struct {",
      "content": "type UnknownElementType struct {\n\tmethod  string\n\telement interface{}\n}\n\n// Error returns the name of the method that encountered the error, as well as\n// the type that was unsupported.",
      "length": 147,
      "tokens": 26,
      "embedding": []
    },
    {
      "slug": "func (e UnknownElementType) Error() string {",
      "content": "func (e UnknownElementType) Error() string {\n\treturn fmt.Sprintf(\"Unknown type in %s: %T\", e.method, e.element)\n}\n\n// WriteElement is a one-stop shop to write the big endian representation of\n// any element which is to be serialized for storage on disk. The passed\n// io.Writer should be backed by an appropriately sized byte slice, or be able\n// to dynamically expand to accommodate additional data.",
      "length": 349,
      "tokens": 58,
      "embedding": []
    },
    {
      "slug": "func WriteElement(w io.Writer, element interface{}) error {",
      "content": "func WriteElement(w io.Writer, element interface{}) error {\n\tswitch e := element.(type) {\n\tcase keychain.KeyDescriptor:\n\t\tif err := binary.Write(w, byteOrder, e.Family); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := binary.Write(w, byteOrder, e.Index); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif e.PubKey != nil {\n\t\t\tif err := binary.Write(w, byteOrder, true); err != nil {\n\t\t\t\treturn fmt.Errorf(\"error writing serialized element: %s\", err)\n\t\t\t}\n\n\t\t\treturn WriteElement(w, e.PubKey)\n\t\t}\n\n\t\treturn binary.Write(w, byteOrder, false)\n\tcase ChannelType:\n\t\tif err := binary.Write(w, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase chainhash.Hash:\n\t\tif _, err := w.Write(e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase wire.OutPoint:\n\t\treturn WriteOutpoint(w, &e)\n\n\tcase lnwire.ShortChannelID:\n\t\tif err := binary.Write(w, byteOrder, e.ToUint64()); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase lnwire.ChannelID:\n\t\tif _, err := w.Write(e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase int64, uint64:\n\t\tif err := binary.Write(w, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase uint32:\n\t\tif err := binary.Write(w, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase int32:\n\t\tif err := binary.Write(w, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase uint16:\n\t\tif err := binary.Write(w, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase uint8:\n\t\tif err := binary.Write(w, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase bool:\n\t\tif err := binary.Write(w, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase btcutil.Amount:\n\t\tif err := binary.Write(w, byteOrder, uint64(e)); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase lnwire.MilliSatoshi:\n\t\tif err := binary.Write(w, byteOrder, uint64(e)); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *btcec.PrivateKey:\n\t\tb := e.Serialize()\n\t\tif _, err := w.Write(b); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *btcec.PublicKey:\n\t\tb := e.SerializeCompressed()\n\t\tif _, err := w.Write(b); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase shachain.Producer:\n\t\treturn e.Encode(w)\n\n\tcase shachain.Store:\n\t\treturn e.Encode(w)\n\n\tcase *wire.MsgTx:\n\t\treturn e.Serialize(w)\n\n\tcase [32]byte:\n\t\tif _, err := w.Write(e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase []byte:\n\t\tif err := wire.WriteVarBytes(w, 0, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase lnwire.Message:\n\t\tif _, err := lnwire.WriteMessage(w, e, 0); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase ChannelStatus:\n\t\tif err := binary.Write(w, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase ClosureType:\n\t\tif err := binary.Write(w, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase lnwire.FundingFlag:\n\t\tif err := binary.Write(w, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase net.Addr:\n\t\tif err := serializeAddr(w, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase []net.Addr:\n\t\tif err := WriteElement(w, uint32(len(e))); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfor _, addr := range e {\n\t\t\tif err := serializeAddr(w, addr); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\tdefault:\n\t\treturn UnknownElementType{\"WriteElement\", e}\n\t}\n\n\treturn nil\n}\n\n// WriteElements is writes each element in the elements slice to the passed\n// io.Writer using WriteElement.",
      "length": 2860,
      "tokens": 457,
      "embedding": []
    },
    {
      "slug": "func WriteElements(w io.Writer, elements ...interface{}) error {",
      "content": "func WriteElements(w io.Writer, elements ...interface{}) error {\n\tfor _, element := range elements {\n\t\terr := WriteElement(w, element)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// ReadElement is a one-stop utility function to deserialize any datastructure\n// encoded using the serialization format of the database.",
      "length": 251,
      "tokens": 43,
      "embedding": []
    },
    {
      "slug": "func ReadElement(r io.Reader, element interface{}) error {",
      "content": "func ReadElement(r io.Reader, element interface{}) error {\n\tswitch e := element.(type) {\n\tcase *keychain.KeyDescriptor:\n\t\tif err := binary.Read(r, byteOrder, &e.Family); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := binary.Read(r, byteOrder, &e.Index); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvar hasPubKey bool\n\t\tif err := binary.Read(r, byteOrder, &hasPubKey); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif hasPubKey {\n\t\t\treturn ReadElement(r, &e.PubKey)\n\t\t}\n\n\tcase *ChannelType:\n\t\tif err := binary.Read(r, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *chainhash.Hash:\n\t\tif _, err := io.ReadFull(r, e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *wire.OutPoint:\n\t\treturn ReadOutpoint(r, e)\n\n\tcase *lnwire.ShortChannelID:\n\t\tvar a uint64\n\t\tif err := binary.Read(r, byteOrder, &a); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*e = lnwire.NewShortChanIDFromInt(a)\n\n\tcase *lnwire.ChannelID:\n\t\tif _, err := io.ReadFull(r, e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *int64, *uint64:\n\t\tif err := binary.Read(r, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *uint32:\n\t\tif err := binary.Read(r, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *int32:\n\t\tif err := binary.Read(r, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *uint16:\n\t\tif err := binary.Read(r, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *uint8:\n\t\tif err := binary.Read(r, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *bool:\n\t\tif err := binary.Read(r, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *btcutil.Amount:\n\t\tvar a uint64\n\t\tif err := binary.Read(r, byteOrder, &a); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t*e = btcutil.Amount(a)\n\n\tcase *lnwire.MilliSatoshi:\n\t\tvar a uint64\n\t\tif err := binary.Read(r, byteOrder, &a); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t*e = lnwire.MilliSatoshi(a)\n\n\tcase **btcec.PrivateKey:\n\t\tvar b [btcec.PrivKeyBytesLen]byte\n\t\tif _, err := io.ReadFull(r, b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tpriv, _ := btcec.PrivKeyFromBytes(b[:])\n\t\t*e = priv\n\n\tcase **btcec.PublicKey:\n\t\tvar b [btcec.PubKeyBytesLenCompressed]byte\n\t\tif _, err := io.ReadFull(r, b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tpubKey, err := btcec.ParsePubKey(b[:])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*e = pubKey\n\n\tcase *shachain.Producer:\n\t\tvar root [32]byte\n\t\tif _, err := io.ReadFull(r, root[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// TODO(roasbeef): remove\n\t\tproducer, err := shachain.NewRevocationProducerFromBytes(root[:])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t*e = producer\n\n\tcase *shachain.Store:\n\t\tstore, err := shachain.NewRevocationStoreFromBytes(r)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t*e = store\n\n\tcase **wire.MsgTx:\n\t\ttx := wire.NewMsgTx(2)\n\t\tif err := tx.Deserialize(r); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t*e = tx\n\n\tcase *[32]byte:\n\t\tif _, err := io.ReadFull(r, e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *[]byte:\n\t\tbytes, err := wire.ReadVarBytes(r, 0, 66000, \"[]byte\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t*e = bytes\n\n\tcase *lnwire.Message:\n\t\tmsg, err := lnwire.ReadMessage(r, 0)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t*e = msg\n\n\tcase *ChannelStatus:\n\t\tif err := binary.Read(r, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *ClosureType:\n\t\tif err := binary.Read(r, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *lnwire.FundingFlag:\n\t\tif err := binary.Read(r, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *net.Addr:\n\t\taddr, err := deserializeAddr(r)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*e = addr\n\n\tcase *[]net.Addr:\n\t\tvar numAddrs uint32\n\t\tif err := ReadElement(r, &numAddrs); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t*e = make([]net.Addr, numAddrs)\n\t\tfor i := uint32(0); i < numAddrs; i++ {\n\t\t\taddr, err := deserializeAddr(r)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t(*e)[i] = addr\n\t\t}\n\n\tdefault:\n\t\treturn UnknownElementType{\"ReadElement\", e}\n\t}\n\n\treturn nil\n}\n\n// ReadElements deserializes a variable number of elements into the passed\n// io.Reader, with each element being deserialized according to the ReadElement\n// function.",
      "length": 3666,
      "tokens": 583,
      "embedding": []
    },
    {
      "slug": "func ReadElements(r io.Reader, elements ...interface{}) error {",
      "content": "func ReadElements(r io.Reader, elements ...interface{}) error {\n\tfor _, element := range elements {\n\t\terr := ReadElement(r, element)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n",
      "length": 114,
      "tokens": 23,
      "embedding": []
    }
  ]
}