{
  "filepath": "../implementations/go/lnd/channeldb/migration_01_to_11/migration_11_invoices.go",
  "package": "migration_01_to_11",
  "sections": [
    {
      "slug": "func MigrateInvoices(tx kvdb.RwTx) error {",
      "content": "func MigrateInvoices(tx kvdb.RwTx) error {\n\tlog.Infof(\"Migrating invoices to new invoice format\")\n\n\tinvoiceB := tx.ReadWriteBucket(invoiceBucket)\n\tif invoiceB == nil {\n\t\treturn nil\n\t}\n\n\t// Iterate through the entire key space of the top-level invoice bucket.\n\t// If key with a non-nil value stores the next invoice ID which maps to\n\t// the corresponding invoice. Store those keys first, because it isn't\n\t// safe to modify the bucket inside a ForEach loop.\n\tvar invoiceKeys [][]byte\n\terr := invoiceB.ForEach(func(k, v []byte) error {\n\t\tif v == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\tinvoiceKeys = append(invoiceKeys, k)\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tnets := []*bitcoinCfg.Params{\n\t\t&bitcoinCfg.MainNetParams, &bitcoinCfg.SimNetParams,\n\t\t&bitcoinCfg.RegressionNetParams, &bitcoinCfg.TestNet3Params,\n\t}\n\n\tltcNets := []*litecoinCfg.Params{\n\t\t&litecoinCfg.MainNetParams, &litecoinCfg.SimNetParams,\n\t\t&litecoinCfg.RegressionNetParams, &litecoinCfg.TestNet4Params,\n\t}\n\tfor _, net := range ltcNets {\n\t\tvar convertedNet bitcoinCfg.Params\n\t\tconvertedNet.Bech32HRPSegwit = net.Bech32HRPSegwit\n\t\tnets = append(nets, &convertedNet)\n\t}\n\n\t// Iterate over all stored keys and migrate the invoices.\n\tfor _, k := range invoiceKeys {\n\t\tv := invoiceB.Get(k)\n\n\t\t// Deserialize the invoice with the deserializing function that\n\t\t// was in use for this version of the database.\n\t\tinvoiceReader := bytes.NewReader(v)\n\t\tinvoice, err := deserializeInvoiceLegacy(invoiceReader)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif invoice.Terms.State == ContractAccepted {\n\t\t\treturn fmt.Errorf(\"cannot upgrade with invoice(s) \" +\n\t\t\t\t\"in accepted state, see release notes\")\n\t\t}\n\n\t\t// Try to decode the payment request for every possible net to\n\t\t// avoid passing a the active network to channeldb. This would\n\t\t// be a layering violation, while this migration is only running\n\t\t// once and will likely be removed in the future.\n\t\tvar payReq *zpay32.Invoice\n\t\tfor _, net := range nets {\n\t\t\tpayReq, err = zpay32.Decode(\n\t\t\t\tstring(invoice.PaymentRequest), net,\n\t\t\t)\n\t\t\tif err == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif payReq == nil {\n\t\t\treturn fmt.Errorf(\"cannot decode payreq\")\n\t\t}\n\t\tinvoice.FinalCltvDelta = int32(payReq.MinFinalCLTVExpiry())\n\t\tinvoice.Expiry = payReq.Expiry()\n\n\t\t// Serialize the invoice in the new format and use it to replace\n\t\t// the old invoice in the database.\n\t\tvar buf bytes.Buffer\n\t\tif err := serializeInvoice(&buf, &invoice); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = invoiceB.Put(k, buf.Bytes())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tlog.Infof(\"Migration of invoices completed!\")\n\treturn nil\n}\n",
      "length": 2453,
      "tokens": 345,
      "embedding": []
    },
    {
      "slug": "func deserializeInvoiceLegacy(r io.Reader) (Invoice, error) {",
      "content": "func deserializeInvoiceLegacy(r io.Reader) (Invoice, error) {\n\tvar err error\n\tinvoice := Invoice{}\n\n\t// TODO(roasbeef): use read full everywhere\n\tinvoice.Memo, err = wire.ReadVarBytes(r, 0, MaxMemoSize, \"\")\n\tif err != nil {\n\t\treturn invoice, err\n\t}\n\tinvoice.Receipt, err = wire.ReadVarBytes(r, 0, MaxReceiptSize, \"\")\n\tif err != nil {\n\t\treturn invoice, err\n\t}\n\n\tinvoice.PaymentRequest, err = wire.ReadVarBytes(r, 0, MaxPaymentRequestSize, \"\")\n\tif err != nil {\n\t\treturn invoice, err\n\t}\n\n\tbirthBytes, err := wire.ReadVarBytes(r, 0, 300, \"birth\")\n\tif err != nil {\n\t\treturn invoice, err\n\t}\n\tif err := invoice.CreationDate.UnmarshalBinary(birthBytes); err != nil {\n\t\treturn invoice, err\n\t}\n\n\tsettledBytes, err := wire.ReadVarBytes(r, 0, 300, \"settled\")\n\tif err != nil {\n\t\treturn invoice, err\n\t}\n\tif err := invoice.SettleDate.UnmarshalBinary(settledBytes); err != nil {\n\t\treturn invoice, err\n\t}\n\n\tif _, err := io.ReadFull(r, invoice.Terms.PaymentPreimage[:]); err != nil {\n\t\treturn invoice, err\n\t}\n\tvar scratch [8]byte\n\tif _, err := io.ReadFull(r, scratch[:]); err != nil {\n\t\treturn invoice, err\n\t}\n\tinvoice.Terms.Value = lnwire.MilliSatoshi(byteOrder.Uint64(scratch[:]))\n\n\tif err := binary.Read(r, byteOrder, &invoice.Terms.State); err != nil {\n\t\treturn invoice, err\n\t}\n\n\tif err := binary.Read(r, byteOrder, &invoice.AddIndex); err != nil {\n\t\treturn invoice, err\n\t}\n\tif err := binary.Read(r, byteOrder, &invoice.SettleIndex); err != nil {\n\t\treturn invoice, err\n\t}\n\tif err := binary.Read(r, byteOrder, &invoice.AmtPaid); err != nil {\n\t\treturn invoice, err\n\t}\n\n\treturn invoice, nil\n}\n\n// serializeInvoiceLegacy serializes an invoice in the format of the previous db\n// version.",
      "length": 1546,
      "tokens": 224,
      "embedding": []
    },
    {
      "slug": "func serializeInvoiceLegacy(w io.Writer, i *Invoice) error {",
      "content": "func serializeInvoiceLegacy(w io.Writer, i *Invoice) error {\n\tif err := wire.WriteVarBytes(w, 0, i.Memo[:]); err != nil {\n\t\treturn err\n\t}\n\tif err := wire.WriteVarBytes(w, 0, i.Receipt[:]); err != nil {\n\t\treturn err\n\t}\n\tif err := wire.WriteVarBytes(w, 0, i.PaymentRequest[:]); err != nil {\n\t\treturn err\n\t}\n\n\tbirthBytes, err := i.CreationDate.MarshalBinary()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := wire.WriteVarBytes(w, 0, birthBytes); err != nil {\n\t\treturn err\n\t}\n\n\tsettleBytes, err := i.SettleDate.MarshalBinary()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := wire.WriteVarBytes(w, 0, settleBytes); err != nil {\n\t\treturn err\n\t}\n\n\tif _, err := w.Write(i.Terms.PaymentPreimage[:]); err != nil {\n\t\treturn err\n\t}\n\n\tvar scratch [8]byte\n\tbyteOrder.PutUint64(scratch[:], uint64(i.Terms.Value))\n\tif _, err := w.Write(scratch[:]); err != nil {\n\t\treturn err\n\t}\n\n\tif err := binary.Write(w, byteOrder, i.Terms.State); err != nil {\n\t\treturn err\n\t}\n\n\tif err := binary.Write(w, byteOrder, i.AddIndex); err != nil {\n\t\treturn err\n\t}\n\tif err := binary.Write(w, byteOrder, i.SettleIndex); err != nil {\n\t\treturn err\n\t}\n\tif err := binary.Write(w, byteOrder, int64(i.AmtPaid)); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n",
      "length": 1090,
      "tokens": 173,
      "embedding": []
    }
  ]
}