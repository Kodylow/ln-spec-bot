{
  "filepath": "../implementations/go/lnd/channeldb/migration_01_to_11/payments_test.go",
  "package": "migration_01_to_11",
  "sections": [
    {
      "slug": "func makeFakePayment() *outgoingPayment {",
      "content": "func makeFakePayment() *outgoingPayment {\n\tfakeInvoice := &Invoice{\n\t\t// Use single second precision to avoid false positive test\n\t\t// failures due to the monotonic time component.\n\t\tCreationDate:   time.Unix(time.Now().Unix(), 0),\n\t\tMemo:           []byte(\"fake memo\"),\n\t\tReceipt:        []byte(\"fake receipt\"),\n\t\tPaymentRequest: []byte(\"\"),\n\t}\n\n\tcopy(fakeInvoice.Terms.PaymentPreimage[:], rev[:])\n\tfakeInvoice.Terms.Value = lnwire.NewMSatFromSatoshis(10000)\n\n\tfakePath := make([][33]byte, 3)\n\tfor i := 0; i < 3; i++ {\n\t\tcopy(fakePath[i][:], bytes.Repeat([]byte{byte(i)}, 33))\n\t}\n\n\tfakePayment := &outgoingPayment{\n\t\tInvoice:        *fakeInvoice,\n\t\tFee:            101,\n\t\tPath:           fakePath,\n\t\tTimeLockLength: 1000,\n\t}\n\tcopy(fakePayment.PaymentPreimage[:], rev[:])\n\treturn fakePayment\n}\n\n// randomBytes creates random []byte with length in range [minLen, maxLen)",
      "length": 800,
      "tokens": 83,
      "embedding": []
    },
    {
      "slug": "func randomBytes(minLen, maxLen int) ([]byte, error) {",
      "content": "func randomBytes(minLen, maxLen int) ([]byte, error) {\n\trandBuf := make([]byte, minLen+rand.Intn(maxLen-minLen))\n\n\tif _, err := rand.Read(randBuf); err != nil {\n\t\treturn nil, fmt.Errorf(\"Internal error. \"+\n\t\t\t\"Cannot generate random string: %v\", err)\n\t}\n\n\treturn randBuf, nil\n}\n",
      "length": 214,
      "tokens": 29,
      "embedding": []
    },
    {
      "slug": "func makeRandomFakePayment() (*outgoingPayment, error) {",
      "content": "func makeRandomFakePayment() (*outgoingPayment, error) {\n\tvar err error\n\tfakeInvoice := &Invoice{\n\t\t// Use single second precision to avoid false positive test\n\t\t// failures due to the monotonic time component.\n\t\tCreationDate: time.Unix(time.Now().Unix(), 0),\n\t}\n\n\tfakeInvoice.Memo, err = randomBytes(1, 50)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfakeInvoice.Receipt, err = randomBytes(1, 50)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfakeInvoice.PaymentRequest, err = randomBytes(1, 50)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpreImg, err := randomBytes(32, 33)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcopy(fakeInvoice.Terms.PaymentPreimage[:], preImg)\n\n\tfakeInvoice.Terms.Value = lnwire.MilliSatoshi(rand.Intn(10000))\n\n\tfakePathLen := 1 + rand.Intn(5)\n\tfakePath := make([][33]byte, fakePathLen)\n\tfor i := 0; i < fakePathLen; i++ {\n\t\tb, err := randomBytes(33, 34)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tcopy(fakePath[i][:], b)\n\t}\n\n\tfakePayment := &outgoingPayment{\n\t\tInvoice:        *fakeInvoice,\n\t\tFee:            lnwire.MilliSatoshi(rand.Intn(1001)),\n\t\tPath:           fakePath,\n\t\tTimeLockLength: uint32(rand.Intn(10000)),\n\t}\n\tcopy(fakePayment.PaymentPreimage[:], fakeInvoice.Terms.PaymentPreimage[:])\n\n\treturn fakePayment, nil\n}\n",
      "length": 1128,
      "tokens": 142,
      "embedding": []
    }
  ]
}