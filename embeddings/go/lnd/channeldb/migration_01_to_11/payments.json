{
  "filepath": "../implementations/go/lnd/channeldb/migration_01_to_11/payments.go",
  "package": "migration_01_to_11",
  "sections": [
    {
      "slug": "type FailureReason byte",
      "content": "type FailureReason byte\n\nconst (\n\t// FailureReasonTimeout indicates that the payment did timeout before a\n\t// successful payment attempt was made.\n\tFailureReasonTimeout FailureReason = 0\n\n\t// FailureReasonNoRoute indicates no successful route to the\n\t// destination was found during path finding.\n\tFailureReasonNoRoute FailureReason = 1\n\n\t// FailureReasonError indicates that an unexpected error happened during\n\t// payment.\n\tFailureReasonError FailureReason = 2\n\n\t// FailureReasonIncorrectPaymentDetails indicates that either the hash\n\t// is unknown or the final cltv delta or amount is incorrect.\n\tFailureReasonIncorrectPaymentDetails FailureReason = 3\n\n\t// TODO(halseth): cancel state.\n\n\t// TODO(joostjager): Add failure reasons for:\n\t// LocalLiquidityInsufficient, RemoteCapacityInsufficient.\n)\n\n// String returns a human readable FailureReason",
      "length": 800,
      "tokens": 100,
      "embedding": []
    },
    {
      "slug": "func (r FailureReason) String() string {",
      "content": "func (r FailureReason) String() string {\n\tswitch r {\n\tcase FailureReasonTimeout:\n\t\treturn \"timeout\"\n\tcase FailureReasonNoRoute:\n\t\treturn \"no_route\"\n\tcase FailureReasonError:\n\t\treturn \"error\"\n\tcase FailureReasonIncorrectPaymentDetails:\n\t\treturn \"incorrect_payment_details\"\n\t}\n\n\treturn \"unknown\"\n}\n\n// PaymentStatus represent current status of payment",
      "length": 294,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "type PaymentStatus byte",
      "content": "type PaymentStatus byte\n\nconst (\n\t// StatusUnknown is the status where a payment has never been initiated\n\t// and hence is unknown.\n\tStatusUnknown PaymentStatus = 0\n\n\t// StatusInFlight is the status where a payment has been initiated, but\n\t// a response has not been received.\n\tStatusInFlight PaymentStatus = 1\n\n\t// StatusSucceeded is the status where a payment has been initiated and\n\t// the payment was completed successfully.\n\tStatusSucceeded PaymentStatus = 2\n\n\t// StatusFailed is the status where a payment has been initiated and a\n\t// failure result has come back.\n\tStatusFailed PaymentStatus = 3\n)\n\n// Bytes returns status as slice of bytes.",
      "length": 605,
      "tokens": 100,
      "embedding": []
    },
    {
      "slug": "func (ps PaymentStatus) Bytes() []byte {",
      "content": "func (ps PaymentStatus) Bytes() []byte {\n\treturn []byte{byte(ps)}\n}\n\n// FromBytes sets status from slice of bytes.",
      "length": 70,
      "tokens": 11,
      "embedding": []
    },
    {
      "slug": "func (ps *PaymentStatus) FromBytes(status []byte) error {",
      "content": "func (ps *PaymentStatus) FromBytes(status []byte) error {\n\tif len(status) != 1 {\n\t\treturn errors.New(\"payment status is empty\")\n\t}\n\n\tswitch PaymentStatus(status[0]) {\n\tcase StatusUnknown, StatusInFlight, StatusSucceeded, StatusFailed:\n\t\t*ps = PaymentStatus(status[0])\n\tdefault:\n\t\treturn errors.New(\"unknown payment status\")\n\t}\n\n\treturn nil\n}\n\n// String returns readable representation of payment status.",
      "length": 331,
      "tokens": 39,
      "embedding": []
    },
    {
      "slug": "func (ps PaymentStatus) String() string {",
      "content": "func (ps PaymentStatus) String() string {\n\tswitch ps {\n\tcase StatusUnknown:\n\t\treturn \"Unknown\"\n\tcase StatusInFlight:\n\t\treturn \"In Flight\"\n\tcase StatusSucceeded:\n\t\treturn \"Succeeded\"\n\tcase StatusFailed:\n\t\treturn \"Failed\"\n\tdefault:\n\t\treturn \"Unknown\"\n\t}\n}\n\n// PaymentCreationInfo is the information necessary to have ready when\n// initiating a payment, moving it into state InFlight.",
      "length": 324,
      "tokens": 44,
      "embedding": []
    },
    {
      "slug": "type PaymentCreationInfo struct {",
      "content": "type PaymentCreationInfo struct {\n\t// PaymentHash is the hash this payment is paying to.\n\tPaymentHash lntypes.Hash\n\n\t// Value is the amount we are paying.\n\tValue lnwire.MilliSatoshi\n\n\t// CreatingDate is the time when this payment was initiated.\n\tCreationDate time.Time\n\n\t// PaymentRequest is the full payment request, if any.\n\tPaymentRequest []byte\n}\n\n// PaymentAttemptInfo contains information about a specific payment attempt for\n// a given payment. This information is used by the router to handle any errors\n// coming back after an attempt is made, and to query the switch about the\n// status of a payment. For settled payment this will be the information for\n// the succeeding payment attempt.",
      "length": 647,
      "tokens": 105,
      "embedding": []
    },
    {
      "slug": "type PaymentAttemptInfo struct {",
      "content": "type PaymentAttemptInfo struct {\n\t// PaymentID is the unique ID used for this attempt.\n\tPaymentID uint64\n\n\t// SessionKey is the ephemeral key used for this payment attempt.\n\tSessionKey *btcec.PrivateKey\n\n\t// Route is the route attempted to send the HTLC.\n\tRoute Route\n}\n\n// Payment is a wrapper around a payment's PaymentCreationInfo,\n// PaymentAttemptInfo, and preimage. All payments will have the\n// PaymentCreationInfo set, the PaymentAttemptInfo will be set only if at least\n// one payment attempt has been made, while only completed payments will have a\n// non-zero payment preimage.",
      "length": 541,
      "tokens": 86,
      "embedding": []
    },
    {
      "slug": "type Payment struct {",
      "content": "type Payment struct {\n\t// sequenceNum is a unique identifier used to sort the payments in\n\t// order of creation.\n\tsequenceNum uint64\n\n\t// Status is the current PaymentStatus of this payment.\n\tStatus PaymentStatus\n\n\t// Info holds all static information about this payment, and is\n\t// populated when the payment is initiated.\n\tInfo *PaymentCreationInfo\n\n\t// Attempt is the information about the last payment attempt made.\n\t//\n\t// NOTE: Can be nil if no attempt is yet made.\n\tAttempt *PaymentAttemptInfo\n\n\t// PaymentPreimage is the preimage of a successful payment. This serves\n\t// as a proof of payment. It will only be non-nil for settled payments.\n\t//\n\t// NOTE: Can be nil if payment is not settled.\n\tPaymentPreimage *lntypes.Preimage\n\n\t// Failure is a failure reason code indicating the reason the payment\n\t// failed. It is only non-nil for failed payments.\n\t//\n\t// NOTE: Can be nil if payment is not failed.\n\tFailure *FailureReason\n}\n\n// FetchPayments returns all sent payments found in the DB.",
      "length": 945,
      "tokens": 157,
      "embedding": []
    },
    {
      "slug": "func (db *DB) FetchPayments() ([]*Payment, error) {",
      "content": "func (db *DB) FetchPayments() ([]*Payment, error) {\n\tvar payments []*Payment\n\n\terr := kvdb.View(db, func(tx kvdb.RTx) error {\n\t\tpaymentsBucket := tx.ReadBucket(paymentsRootBucket)\n\t\tif paymentsBucket == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn paymentsBucket.ForEach(func(k, v []byte) error {\n\t\t\tbucket := paymentsBucket.NestedReadBucket(k)\n\t\t\tif bucket == nil {\n\t\t\t\t// We only expect sub-buckets to be found in\n\t\t\t\t// this top-level bucket.\n\t\t\t\treturn fmt.Errorf(\"non bucket element in \" +\n\t\t\t\t\t\"payments bucket\")\n\t\t\t}\n\n\t\t\tp, err := fetchPayment(bucket)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tpayments = append(payments, p)\n\n\t\t\t// For older versions of lnd, duplicate payments to a\n\t\t\t// payment has was possible. These will be found in a\n\t\t\t// sub-bucket indexed by their sequence number if\n\t\t\t// available.\n\t\t\tdup := bucket.NestedReadBucket(paymentDuplicateBucket)\n\t\t\tif dup == nil {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\treturn dup.ForEach(func(k, v []byte) error {\n\t\t\t\tsubBucket := dup.NestedReadBucket(k)\n\t\t\t\tif subBucket == nil {\n\t\t\t\t\t// We one bucket for each duplicate to\n\t\t\t\t\t// be found.\n\t\t\t\t\treturn fmt.Errorf(\"non bucket element\" +\n\t\t\t\t\t\t\"in duplicate bucket\")\n\t\t\t\t}\n\n\t\t\t\tp, err := fetchPayment(subBucket)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tpayments = append(payments, p)\n\t\t\t\treturn nil\n\t\t\t})\n\t\t})\n\t}, func() {\n\t\tpayments = nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Before returning, sort the payments by their sequence number.\n\tsort.Slice(payments, func(i, j int) bool {\n\t\treturn payments[i].sequenceNum < payments[j].sequenceNum\n\t})\n\n\treturn payments, nil\n}\n",
      "length": 1460,
      "tokens": 211,
      "embedding": []
    },
    {
      "slug": "func fetchPayment(bucket kvdb.RBucket) (*Payment, error) {",
      "content": "func fetchPayment(bucket kvdb.RBucket) (*Payment, error) {\n\tvar (\n\t\terr error\n\t\tp   = &Payment{}\n\t)\n\n\tseqBytes := bucket.Get(paymentSequenceKey)\n\tif seqBytes == nil {\n\t\treturn nil, fmt.Errorf(\"sequence number not found\")\n\t}\n\n\tp.sequenceNum = binary.BigEndian.Uint64(seqBytes)\n\n\t// Get the payment status.\n\tp.Status = fetchPaymentStatus(bucket)\n\n\t// Get the PaymentCreationInfo.\n\tb := bucket.Get(paymentCreationInfoKey)\n\tif b == nil {\n\t\treturn nil, fmt.Errorf(\"creation info not found\")\n\t}\n\n\tr := bytes.NewReader(b)\n\tp.Info, err = deserializePaymentCreationInfo(r)\n\tif err != nil {\n\t\treturn nil, err\n\n\t}\n\n\t// Get the PaymentAttemptInfo. This can be unset.\n\tb = bucket.Get(paymentAttemptInfoKey)\n\tif b != nil {\n\t\tr = bytes.NewReader(b)\n\t\tp.Attempt, err = deserializePaymentAttemptInfo(r)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Get the payment preimage. This is only found for\n\t// completed payments.\n\tb = bucket.Get(paymentSettleInfoKey)\n\tif b != nil {\n\t\tvar preimg lntypes.Preimage\n\t\tcopy(preimg[:], b[:])\n\t\tp.PaymentPreimage = &preimg\n\t}\n\n\t// Get failure reason if available.\n\tb = bucket.Get(paymentFailInfoKey)\n\tif b != nil {\n\t\treason := FailureReason(b[0])\n\t\tp.Failure = &reason\n\t}\n\n\treturn p, nil\n}\n",
      "length": 1097,
      "tokens": 157,
      "embedding": []
    },
    {
      "slug": "func serializePaymentCreationInfo(w io.Writer, c *PaymentCreationInfo) error {",
      "content": "func serializePaymentCreationInfo(w io.Writer, c *PaymentCreationInfo) error {\n\tvar scratch [8]byte\n\n\tif _, err := w.Write(c.PaymentHash[:]); err != nil {\n\t\treturn err\n\t}\n\n\tbyteOrder.PutUint64(scratch[:], uint64(c.Value))\n\tif _, err := w.Write(scratch[:]); err != nil {\n\t\treturn err\n\t}\n\n\tbyteOrder.PutUint64(scratch[:], uint64(c.CreationDate.Unix()))\n\tif _, err := w.Write(scratch[:]); err != nil {\n\t\treturn err\n\t}\n\n\tbyteOrder.PutUint32(scratch[:4], uint32(len(c.PaymentRequest)))\n\tif _, err := w.Write(scratch[:4]); err != nil {\n\t\treturn err\n\t}\n\n\tif _, err := w.Write(c.PaymentRequest[:]); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n",
      "length": 529,
      "tokens": 72,
      "embedding": []
    },
    {
      "slug": "func deserializePaymentCreationInfo(r io.Reader) (*PaymentCreationInfo, error) {",
      "content": "func deserializePaymentCreationInfo(r io.Reader) (*PaymentCreationInfo, error) {\n\tvar scratch [8]byte\n\n\tc := &PaymentCreationInfo{}\n\n\tif _, err := io.ReadFull(r, c.PaymentHash[:]); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif _, err := io.ReadFull(r, scratch[:]); err != nil {\n\t\treturn nil, err\n\t}\n\tc.Value = lnwire.MilliSatoshi(byteOrder.Uint64(scratch[:]))\n\n\tif _, err := io.ReadFull(r, scratch[:]); err != nil {\n\t\treturn nil, err\n\t}\n\tc.CreationDate = time.Unix(int64(byteOrder.Uint64(scratch[:])), 0)\n\n\tif _, err := io.ReadFull(r, scratch[:4]); err != nil {\n\t\treturn nil, err\n\t}\n\n\treqLen := uint32(byteOrder.Uint32(scratch[:4]))\n\tpayReq := make([]byte, reqLen)\n\tif reqLen > 0 {\n\t\tif _, err := io.ReadFull(r, payReq[:]); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tc.PaymentRequest = payReq\n\n\treturn c, nil\n}\n",
      "length": 687,
      "tokens": 103,
      "embedding": []
    },
    {
      "slug": "func serializePaymentAttemptInfo(w io.Writer, a *PaymentAttemptInfo) error {",
      "content": "func serializePaymentAttemptInfo(w io.Writer, a *PaymentAttemptInfo) error {\n\tif err := WriteElements(w, a.PaymentID, a.SessionKey); err != nil {\n\t\treturn err\n\t}\n\n\tif err := SerializeRoute(w, a.Route); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n",
      "length": 159,
      "tokens": 28,
      "embedding": []
    },
    {
      "slug": "func deserializePaymentAttemptInfo(r io.Reader) (*PaymentAttemptInfo, error) {",
      "content": "func deserializePaymentAttemptInfo(r io.Reader) (*PaymentAttemptInfo, error) {\n\ta := &PaymentAttemptInfo{}\n\terr := ReadElements(r, &a.PaymentID, &a.SessionKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ta.Route, err = DeserializeRoute(r)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn a, nil\n}\n",
      "length": 199,
      "tokens": 34,
      "embedding": []
    },
    {
      "slug": "func serializeHop(w io.Writer, h *Hop) error {",
      "content": "func serializeHop(w io.Writer, h *Hop) error {\n\tif err := WriteElements(w,\n\t\th.PubKeyBytes[:], h.ChannelID, h.OutgoingTimeLock,\n\t\th.AmtToForward,\n\t); err != nil {\n\t\treturn err\n\t}\n\n\tif err := binary.Write(w, byteOrder, h.LegacyPayload); err != nil {\n\t\treturn err\n\t}\n\n\t// For legacy payloads, we don't need to write any TLV records, so\n\t// we'll write a zero indicating the our serialized TLV map has no\n\t// records.\n\tif h.LegacyPayload {\n\t\treturn WriteElements(w, uint32(0))\n\t}\n\n\t// Otherwise, we'll transform our slice of records into a map of the\n\t// raw bytes, then serialize them in-line with a length (number of\n\t// elements) prefix.\n\tmapRecords, err := tlv.RecordsToMap(h.TLVRecords)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tnumRecords := uint32(len(mapRecords))\n\tif err := WriteElements(w, numRecords); err != nil {\n\t\treturn err\n\t}\n\n\tfor recordType, rawBytes := range mapRecords {\n\t\tif err := WriteElements(w, recordType); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := wire.WriteVarBytes(w, 0, rawBytes); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// maxOnionPayloadSize is the largest Sphinx payload possible, so we don't need\n// to read/write a TLV stream larger than this.\nconst maxOnionPayloadSize = 1300\n",
      "length": 1120,
      "tokens": 180,
      "embedding": []
    },
    {
      "slug": "func deserializeHop(r io.Reader) (*Hop, error) {",
      "content": "func deserializeHop(r io.Reader) (*Hop, error) {\n\th := &Hop{}\n\n\tvar pub []byte\n\tif err := ReadElements(r, &pub); err != nil {\n\t\treturn nil, err\n\t}\n\tcopy(h.PubKeyBytes[:], pub)\n\n\tif err := ReadElements(r,\n\t\t&h.ChannelID, &h.OutgoingTimeLock, &h.AmtToForward,\n\t); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// TODO(roasbeef): change field to allow LegacyPayload false to be the\n\t// legacy default?\n\terr := binary.Read(r, byteOrder, &h.LegacyPayload)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar numElements uint32\n\tif err := ReadElements(r, &numElements); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// If there're no elements, then we can return early.\n\tif numElements == 0 {\n\t\treturn h, nil\n\t}\n\n\ttlvMap := make(map[uint64][]byte)\n\tfor i := uint32(0); i < numElements; i++ {\n\t\tvar tlvType uint64\n\t\tif err := ReadElements(r, &tlvType); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\trawRecordBytes, err := wire.ReadVarBytes(\n\t\t\tr, 0, maxOnionPayloadSize, \"tlv\",\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\ttlvMap[tlvType] = rawRecordBytes\n\t}\n\n\th.TLVRecords = tlv.MapToRecords(tlvMap)\n\n\treturn h, nil\n}\n\n// SerializeRoute serializes a route.",
      "length": 1016,
      "tokens": 162,
      "embedding": []
    },
    {
      "slug": "func SerializeRoute(w io.Writer, r Route) error {",
      "content": "func SerializeRoute(w io.Writer, r Route) error {\n\tif err := WriteElements(w,\n\t\tr.TotalTimeLock, r.TotalAmount, r.SourcePubKey[:],\n\t); err != nil {\n\t\treturn err\n\t}\n\n\tif err := WriteElements(w, uint32(len(r.Hops))); err != nil {\n\t\treturn err\n\t}\n\n\tfor _, h := range r.Hops {\n\t\tif err := serializeHop(w, h); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// DeserializeRoute deserializes a route.",
      "length": 327,
      "tokens": 55,
      "embedding": []
    },
    {
      "slug": "func DeserializeRoute(r io.Reader) (Route, error) {",
      "content": "func DeserializeRoute(r io.Reader) (Route, error) {\n\trt := Route{}\n\tif err := ReadElements(r,\n\t\t&rt.TotalTimeLock, &rt.TotalAmount,\n\t); err != nil {\n\t\treturn rt, err\n\t}\n\n\tvar pub []byte\n\tif err := ReadElements(r, &pub); err != nil {\n\t\treturn rt, err\n\t}\n\tcopy(rt.SourcePubKey[:], pub)\n\n\tvar numHops uint32\n\tif err := ReadElements(r, &numHops); err != nil {\n\t\treturn rt, err\n\t}\n\n\tvar hops []*Hop\n\tfor i := uint32(0); i < numHops; i++ {\n\t\thop, err := deserializeHop(r)\n\t\tif err != nil {\n\t\t\treturn rt, err\n\t\t}\n\t\thops = append(hops, hop)\n\t}\n\trt.Hops = hops\n\n\treturn rt, nil\n}\n",
      "length": 489,
      "tokens": 89,
      "embedding": []
    }
  ]
}