{
  "filepath": "../implementations/go/lnd/channeldb/migration_01_to_11/db.go",
  "package": "migration_01_to_11",
  "sections": [
    {
      "slug": "type migration func(tx kvdb.RwTx) error",
      "content": "type migration func(tx kvdb.RwTx) error\n\nvar (\n\t// Big endian is the preferred byte order, due to cursor scans over\n\t// integer keys iterating in order.\n\tbyteOrder = binary.BigEndian\n)\n\n// DB is the primary datastore for the lnd daemon. The database stores\n// information related to nodes, routing data, open/closed channels, fee\n// schedules, and reputation data.",
      "length": 315,
      "tokens": 53,
      "embedding": []
    },
    {
      "slug": "type DB struct {",
      "content": "type DB struct {\n\tkvdb.Backend\n\tdbPath string\n\tgraph  *ChannelGraph\n\tnow    func() time.Time\n}\n\n// Open opens an existing channeldb. Any necessary schemas migrations due to\n// updates will take place as necessary.",
      "length": 189,
      "tokens": 28,
      "embedding": []
    },
    {
      "slug": "func Open(dbPath string, modifiers ...OptionModifier) (*DB, error) {",
      "content": "func Open(dbPath string, modifiers ...OptionModifier) (*DB, error) {\n\tpath := filepath.Join(dbPath, dbName)\n\n\tif !fileExists(path) {\n\t\tif err := createChannelDB(dbPath); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\topts := DefaultOptions()\n\tfor _, modifier := range modifiers {\n\t\tmodifier(&opts)\n\t}\n\n\t// Specify bbolt freelist options to reduce heap pressure in case the\n\t// freelist grows to be very large.\n\tbdb, err := kvdb.Open(\n\t\tkvdb.BoltBackendName, path,\n\t\topts.NoFreelistSync, opts.DBTimeout,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tchanDB := &DB{\n\t\tBackend: bdb,\n\t\tdbPath:  dbPath,\n\t\tnow:     time.Now,\n\t}\n\tchanDB.graph = newChannelGraph(\n\t\tchanDB, opts.RejectCacheSize, opts.ChannelCacheSize,\n\t)\n\n\treturn chanDB, nil\n}\n\n// createChannelDB creates and initializes a fresh version of channeldb. In\n// the case that the target path has not yet been created or doesn't yet exist,\n// then the path is created. Additionally, all required top-level buckets used\n// within the database are created.",
      "length": 892,
      "tokens": 135,
      "embedding": []
    },
    {
      "slug": "func createChannelDB(dbPath string) error {",
      "content": "func createChannelDB(dbPath string) error {\n\tif !fileExists(dbPath) {\n\t\tif err := os.MkdirAll(dbPath, 0700); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tpath := filepath.Join(dbPath, dbName)\n\tbdb, err := kvdb.Create(\n\t\tkvdb.BoltBackendName, path, false, kvdb.DefaultDBTimeout,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = kvdb.Update(bdb, func(tx kvdb.RwTx) error {\n\t\tif _, err := tx.CreateTopLevelBucket(openChannelBucket); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := tx.CreateTopLevelBucket(closedChannelBucket); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif _, err := tx.CreateTopLevelBucket(invoiceBucket); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif _, err := tx.CreateTopLevelBucket(paymentBucket); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tnodes, err := tx.CreateTopLevelBucket(nodeBucket)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = nodes.CreateBucket(aliasIndexBucket)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = nodes.CreateBucket(nodeUpdateIndexBucket)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tedges, err := tx.CreateTopLevelBucket(edgeBucket)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := edges.CreateBucket(edgeIndexBucket); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := edges.CreateBucket(edgeUpdateIndexBucket); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := edges.CreateBucket(channelPointBucket); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := edges.CreateBucket(zombieBucket); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tgraphMeta, err := tx.CreateTopLevelBucket(graphMetaBucket)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = graphMeta.CreateBucket(pruneLogBucket)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif _, err := tx.CreateTopLevelBucket(metaBucket); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tmeta := &Meta{\n\t\t\tDbVersionNumber: 0,\n\t\t}\n\t\treturn putMeta(meta, tx)\n\t}, func() {})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to create new channeldb\")\n\t}\n\n\treturn bdb.Close()\n}\n\n// fileExists returns true if the file exists, and false otherwise.",
      "length": 1793,
      "tokens": 262,
      "embedding": []
    },
    {
      "slug": "func fileExists(path string) bool {",
      "content": "func fileExists(path string) bool {\n\tif _, err := os.Stat(path); err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\n// FetchClosedChannels attempts to fetch all closed channels from the database.\n// The pendingOnly bool toggles if channels that aren't yet fully closed should\n// be returned in the response or not. When a channel was cooperatively closed,\n// it becomes fully closed after a single confirmation.  When a channel was\n// forcibly closed, it will become fully closed after _all_ the pending funds\n// (if any) have been swept.",
      "length": 516,
      "tokens": 89,
      "embedding": []
    },
    {
      "slug": "func (d *DB) FetchClosedChannels(pendingOnly bool) ([]*ChannelCloseSummary, error) {",
      "content": "func (d *DB) FetchClosedChannels(pendingOnly bool) ([]*ChannelCloseSummary, error) {\n\tvar chanSummaries []*ChannelCloseSummary\n\n\tif err := kvdb.View(d, func(tx kvdb.RTx) error {\n\t\tcloseBucket := tx.ReadBucket(closedChannelBucket)\n\t\tif closeBucket == nil {\n\t\t\treturn ErrNoClosedChannels\n\t\t}\n\n\t\treturn closeBucket.ForEach(func(chanID []byte, summaryBytes []byte) error {\n\t\t\tsummaryReader := bytes.NewReader(summaryBytes)\n\t\t\tchanSummary, err := deserializeCloseChannelSummary(summaryReader)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// If the query specified to only include pending\n\t\t\t// channels, then we'll skip any channels which aren't\n\t\t\t// currently pending.\n\t\t\tif !chanSummary.IsPending && pendingOnly {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tchanSummaries = append(chanSummaries, chanSummary)\n\t\t\treturn nil\n\t\t})\n\t}, func() {\n\t\tchanSummaries = nil\n\t}); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn chanSummaries, nil\n}\n\n// ChannelGraph returns a new instance of the directed channel graph.",
      "length": 859,
      "tokens": 110,
      "embedding": []
    },
    {
      "slug": "func (d *DB) ChannelGraph() *ChannelGraph {",
      "content": "func (d *DB) ChannelGraph() *ChannelGraph {\n\treturn d.graph\n}\n",
      "length": 16,
      "tokens": 3,
      "embedding": []
    }
  ]
}