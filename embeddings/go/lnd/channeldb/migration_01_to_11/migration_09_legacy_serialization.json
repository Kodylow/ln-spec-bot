{
  "filepath": "../implementations/go/lnd/channeldb/migration_01_to_11/migration_09_legacy_serialization.go",
  "package": "migration_01_to_11",
  "sections": [
    {
      "slug": "type outgoingPayment struct {",
      "content": "type outgoingPayment struct {\n\tInvoice\n\n\t// Fee is the total fee paid for the payment in milli-satoshis.\n\tFee lnwire.MilliSatoshi\n\n\t// TotalTimeLock is the total cumulative time-lock in the HTLC extended\n\t// from the second-to-last hop to the destination.\n\tTimeLockLength uint32\n\n\t// Path encodes the path the payment took through the network. The path\n\t// excludes the outgoing node and consists of the hex-encoded\n\t// compressed public key of each of the nodes involved in the payment.\n\tPath [][33]byte\n\n\t// PaymentPreimage is the preImage of a successful payment. This is used\n\t// to calculate the PaymentHash as well as serve as a proof of payment.\n\tPaymentPreimage [32]byte\n}\n\n// addPayment saves a successful payment to the database. It is assumed that\n// all payment are sent using unique payment hashes.\n//\n// NOTE: Deprecated. Kept around for migration purposes.",
      "length": 819,
      "tokens": 134,
      "embedding": []
    },
    {
      "slug": "func (db *DB) addPayment(payment *outgoingPayment) error {",
      "content": "func (db *DB) addPayment(payment *outgoingPayment) error {\n\t// Validate the field of the inner voice within the outgoing payment,\n\t// these must also adhere to the same constraints as regular invoices.\n\tif err := validateInvoice(&payment.Invoice); err != nil {\n\t\treturn err\n\t}\n\n\t// We first serialize the payment before starting the database\n\t// transaction so we can avoid creating a DB payment in the case of a\n\t// serialization error.\n\tvar b bytes.Buffer\n\tif err := serializeOutgoingPayment(&b, payment); err != nil {\n\t\treturn err\n\t}\n\tpaymentBytes := b.Bytes()\n\n\treturn kvdb.Update(db, func(tx kvdb.RwTx) error {\n\t\tpayments, err := tx.CreateTopLevelBucket(paymentBucket)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Obtain the new unique sequence number for this payment.\n\t\tpaymentID, err := payments.NextSequence()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// We use BigEndian for keys as it orders keys in\n\t\t// ascending order. This allows bucket scans to order payments\n\t\t// in the order in which they were created.\n\t\tpaymentIDBytes := make([]byte, 8)\n\t\tbinary.BigEndian.PutUint64(paymentIDBytes, paymentID)\n\n\t\treturn payments.Put(paymentIDBytes, paymentBytes)\n\t}, func() {})\n}\n\n// fetchAllPayments returns all outgoing payments in DB.\n//\n// NOTE: Deprecated. Kept around for migration purposes.",
      "length": 1197,
      "tokens": 181,
      "embedding": []
    },
    {
      "slug": "func (db *DB) fetchAllPayments() ([]*outgoingPayment, error) {",
      "content": "func (db *DB) fetchAllPayments() ([]*outgoingPayment, error) {\n\tvar payments []*outgoingPayment\n\n\terr := kvdb.View(db, func(tx kvdb.RTx) error {\n\t\tbucket := tx.ReadBucket(paymentBucket)\n\t\tif bucket == nil {\n\t\t\treturn ErrNoPaymentsCreated\n\t\t}\n\n\t\treturn bucket.ForEach(func(k, v []byte) error {\n\t\t\t// If the value is nil, then we ignore it as it may be\n\t\t\t// a sub-bucket.\n\t\t\tif v == nil {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tr := bytes.NewReader(v)\n\t\t\tpayment, err := deserializeOutgoingPayment(r)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tpayments = append(payments, payment)\n\t\t\treturn nil\n\t\t})\n\t}, func() {\n\t\tpayments = nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn payments, nil\n}\n\n// fetchPaymentStatus returns the payment status for outgoing payment.\n// If status of the payment isn't found, it will default to \"StatusUnknown\".\n//\n// NOTE: Deprecated. Kept around for migration purposes.",
      "length": 789,
      "tokens": 125,
      "embedding": []
    },
    {
      "slug": "func (db *DB) fetchPaymentStatus(paymentHash [32]byte) (PaymentStatus, error) {",
      "content": "func (db *DB) fetchPaymentStatus(paymentHash [32]byte) (PaymentStatus, error) {\n\tvar paymentStatus = StatusUnknown\n\terr := kvdb.View(db, func(tx kvdb.RTx) error {\n\t\tvar err error\n\t\tpaymentStatus, err = fetchPaymentStatusTx(tx, paymentHash)\n\t\treturn err\n\t}, func() {\n\t\tpaymentStatus = StatusUnknown\n\t})\n\tif err != nil {\n\t\treturn StatusUnknown, err\n\t}\n\n\treturn paymentStatus, nil\n}\n\n// fetchPaymentStatusTx is a helper method that returns the payment status for\n// outgoing payment.  If status of the payment isn't found, it will default to\n// \"StatusUnknown\". It accepts the boltdb transactions such that this method\n// can be composed into other atomic operations.\n//\n// NOTE: Deprecated. Kept around for migration purposes.",
      "length": 624,
      "tokens": 95,
      "embedding": []
    },
    {
      "slug": "func fetchPaymentStatusTx(tx kvdb.RTx, paymentHash [32]byte) (PaymentStatus, error) {",
      "content": "func fetchPaymentStatusTx(tx kvdb.RTx, paymentHash [32]byte) (PaymentStatus, error) {\n\t// The default status for all payments that aren't recorded in database.\n\tvar paymentStatus = StatusUnknown\n\n\tbucket := tx.ReadBucket(paymentStatusBucket)\n\tif bucket == nil {\n\t\treturn paymentStatus, nil\n\t}\n\n\tpaymentStatusBytes := bucket.Get(paymentHash[:])\n\tif paymentStatusBytes == nil {\n\t\treturn paymentStatus, nil\n\t}\n\n\tpaymentStatus.FromBytes(paymentStatusBytes)\n\n\treturn paymentStatus, nil\n}\n",
      "length": 380,
      "tokens": 45,
      "embedding": []
    },
    {
      "slug": "func serializeOutgoingPayment(w io.Writer, p *outgoingPayment) error {",
      "content": "func serializeOutgoingPayment(w io.Writer, p *outgoingPayment) error {\n\tvar scratch [8]byte\n\n\tif err := serializeInvoiceLegacy(w, &p.Invoice); err != nil {\n\t\treturn err\n\t}\n\n\tbyteOrder.PutUint64(scratch[:], uint64(p.Fee))\n\tif _, err := w.Write(scratch[:]); err != nil {\n\t\treturn err\n\t}\n\n\t// First write out the length of the bytes to prefix the value.\n\tpathLen := uint32(len(p.Path))\n\tbyteOrder.PutUint32(scratch[:4], pathLen)\n\tif _, err := w.Write(scratch[:4]); err != nil {\n\t\treturn err\n\t}\n\n\t// Then with the path written, we write out the series of public keys\n\t// involved in the path.\n\tfor _, hop := range p.Path {\n\t\tif _, err := w.Write(hop[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tbyteOrder.PutUint32(scratch[:4], p.TimeLockLength)\n\tif _, err := w.Write(scratch[:4]); err != nil {\n\t\treturn err\n\t}\n\n\tif _, err := w.Write(p.PaymentPreimage[:]); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n",
      "length": 785,
      "tokens": 127,
      "embedding": []
    },
    {
      "slug": "func deserializeOutgoingPayment(r io.Reader) (*outgoingPayment, error) {",
      "content": "func deserializeOutgoingPayment(r io.Reader) (*outgoingPayment, error) {\n\tvar scratch [8]byte\n\n\tp := &outgoingPayment{}\n\n\tinv, err := deserializeInvoiceLegacy(r)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tp.Invoice = inv\n\n\tif _, err := r.Read(scratch[:]); err != nil {\n\t\treturn nil, err\n\t}\n\tp.Fee = lnwire.MilliSatoshi(byteOrder.Uint64(scratch[:]))\n\n\tif _, err = r.Read(scratch[:4]); err != nil {\n\t\treturn nil, err\n\t}\n\tpathLen := byteOrder.Uint32(scratch[:4])\n\n\tpath := make([][33]byte, pathLen)\n\tfor i := uint32(0); i < pathLen; i++ {\n\t\tif _, err := r.Read(path[i][:]); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tp.Path = path\n\n\tif _, err = r.Read(scratch[:4]); err != nil {\n\t\treturn nil, err\n\t}\n\tp.TimeLockLength = byteOrder.Uint32(scratch[:4])\n\n\tif _, err := r.Read(p.PaymentPreimage[:]); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn p, nil\n}\n\n// serializePaymentAttemptInfoMigration9 is the serializePaymentAttemptInfo\n// version as existed when migration #9 was created. We keep this around, along\n// with the methods below to ensure that clients that upgrade will use the\n// correct version of this method.",
      "length": 987,
      "tokens": 156,
      "embedding": []
    },
    {
      "slug": "func serializePaymentAttemptInfoMigration9(w io.Writer, a *PaymentAttemptInfo) error {",
      "content": "func serializePaymentAttemptInfoMigration9(w io.Writer, a *PaymentAttemptInfo) error {\n\tif err := WriteElements(w, a.PaymentID, a.SessionKey); err != nil {\n\t\treturn err\n\t}\n\n\tif err := serializeRouteMigration9(w, a.Route); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n",
      "length": 169,
      "tokens": 28,
      "embedding": []
    },
    {
      "slug": "func serializeHopMigration9(w io.Writer, h *Hop) error {",
      "content": "func serializeHopMigration9(w io.Writer, h *Hop) error {\n\tif err := WriteElements(w,\n\t\th.PubKeyBytes[:], h.ChannelID, h.OutgoingTimeLock,\n\t\th.AmtToForward,\n\t); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n",
      "length": 138,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func serializeRouteMigration9(w io.Writer, r Route) error {",
      "content": "func serializeRouteMigration9(w io.Writer, r Route) error {\n\tif err := WriteElements(w,\n\t\tr.TotalTimeLock, r.TotalAmount, r.SourcePubKey[:],\n\t); err != nil {\n\t\treturn err\n\t}\n\n\tif err := WriteElements(w, uint32(len(r.Hops))); err != nil {\n\t\treturn err\n\t}\n\n\tfor _, h := range r.Hops {\n\t\tif err := serializeHopMigration9(w, h); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n",
      "length": 296,
      "tokens": 50,
      "embedding": []
    },
    {
      "slug": "func deserializePaymentAttemptInfoMigration9(r io.Reader) (*PaymentAttemptInfo, error) {",
      "content": "func deserializePaymentAttemptInfoMigration9(r io.Reader) (*PaymentAttemptInfo, error) {\n\ta := &PaymentAttemptInfo{}\n\terr := ReadElements(r, &a.PaymentID, &a.SessionKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ta.Route, err = deserializeRouteMigration9(r)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn a, nil\n}\n",
      "length": 209,
      "tokens": 34,
      "embedding": []
    },
    {
      "slug": "func deserializeRouteMigration9(r io.Reader) (Route, error) {",
      "content": "func deserializeRouteMigration9(r io.Reader) (Route, error) {\n\trt := Route{}\n\tif err := ReadElements(r,\n\t\t&rt.TotalTimeLock, &rt.TotalAmount,\n\t); err != nil {\n\t\treturn rt, err\n\t}\n\n\tvar pub []byte\n\tif err := ReadElements(r, &pub); err != nil {\n\t\treturn rt, err\n\t}\n\tcopy(rt.SourcePubKey[:], pub)\n\n\tvar numHops uint32\n\tif err := ReadElements(r, &numHops); err != nil {\n\t\treturn rt, err\n\t}\n\n\tvar hops []*Hop\n\tfor i := uint32(0); i < numHops; i++ {\n\t\thop, err := deserializeHopMigration9(r)\n\t\tif err != nil {\n\t\t\treturn rt, err\n\t\t}\n\t\thops = append(hops, hop)\n\t}\n\trt.Hops = hops\n\n\treturn rt, nil\n}\n",
      "length": 499,
      "tokens": 89,
      "embedding": []
    },
    {
      "slug": "func deserializeHopMigration9(r io.Reader) (*Hop, error) {",
      "content": "func deserializeHopMigration9(r io.Reader) (*Hop, error) {\n\th := &Hop{}\n\n\tvar pub []byte\n\tif err := ReadElements(r, &pub); err != nil {\n\t\treturn nil, err\n\t}\n\tcopy(h.PubKeyBytes[:], pub)\n\n\tif err := ReadElements(r,\n\t\t&h.ChannelID, &h.OutgoingTimeLock, &h.AmtToForward,\n\t); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn h, nil\n}\n\n// fetchPaymentsMigration9 returns all sent payments found in the DB using the\n// payment attempt info format that was present as of migration #9. We need\n// this as otherwise, the current FetchPayments version will use the latest\n// decoding format. Note that we only need this for the\n// TestOutgoingPaymentsMigration migration test case.",
      "length": 585,
      "tokens": 95,
      "embedding": []
    },
    {
      "slug": "func (db *DB) fetchPaymentsMigration9() ([]*Payment, error) {",
      "content": "func (db *DB) fetchPaymentsMigration9() ([]*Payment, error) {\n\tvar payments []*Payment\n\n\terr := kvdb.View(db, func(tx kvdb.RTx) error {\n\t\tpaymentsBucket := tx.ReadBucket(paymentsRootBucket)\n\t\tif paymentsBucket == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn paymentsBucket.ForEach(func(k, v []byte) error {\n\t\t\tbucket := paymentsBucket.NestedReadBucket(k)\n\t\t\tif bucket == nil {\n\t\t\t\t// We only expect sub-buckets to be found in\n\t\t\t\t// this top-level bucket.\n\t\t\t\treturn fmt.Errorf(\"non bucket element in \" +\n\t\t\t\t\t\"payments bucket\")\n\t\t\t}\n\n\t\t\tp, err := fetchPaymentMigration9(bucket)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tpayments = append(payments, p)\n\n\t\t\t// For older versions of lnd, duplicate payments to a\n\t\t\t// payment has was possible. These will be found in a\n\t\t\t// sub-bucket indexed by their sequence number if\n\t\t\t// available.\n\t\t\tdup := bucket.NestedReadBucket(paymentDuplicateBucket)\n\t\t\tif dup == nil {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\treturn dup.ForEach(func(k, v []byte) error {\n\t\t\t\tsubBucket := dup.NestedReadBucket(k)\n\t\t\t\tif subBucket == nil {\n\t\t\t\t\t// We one bucket for each duplicate to\n\t\t\t\t\t// be found.\n\t\t\t\t\treturn fmt.Errorf(\"non bucket element\" +\n\t\t\t\t\t\t\"in duplicate bucket\")\n\t\t\t\t}\n\n\t\t\t\tp, err := fetchPaymentMigration9(subBucket)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tpayments = append(payments, p)\n\t\t\t\treturn nil\n\t\t\t})\n\t\t})\n\t}, func() {\n\t\tpayments = nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Before returning, sort the payments by their sequence number.\n\tsort.Slice(payments, func(i, j int) bool {\n\t\treturn payments[i].sequenceNum < payments[j].sequenceNum\n\t})\n\n\treturn payments, nil\n}\n",
      "length": 1480,
      "tokens": 211,
      "embedding": []
    },
    {
      "slug": "func fetchPaymentMigration9(bucket kvdb.RBucket) (*Payment, error) {",
      "content": "func fetchPaymentMigration9(bucket kvdb.RBucket) (*Payment, error) {\n\tvar (\n\t\terr error\n\t\tp   = &Payment{}\n\t)\n\n\tseqBytes := bucket.Get(paymentSequenceKey)\n\tif seqBytes == nil {\n\t\treturn nil, fmt.Errorf(\"sequence number not found\")\n\t}\n\n\tp.sequenceNum = binary.BigEndian.Uint64(seqBytes)\n\n\t// Get the payment status.\n\tp.Status = fetchPaymentStatus(bucket)\n\n\t// Get the PaymentCreationInfo.\n\tb := bucket.Get(paymentCreationInfoKey)\n\tif b == nil {\n\t\treturn nil, fmt.Errorf(\"creation info not found\")\n\t}\n\n\tr := bytes.NewReader(b)\n\tp.Info, err = deserializePaymentCreationInfo(r)\n\tif err != nil {\n\t\treturn nil, err\n\n\t}\n\n\t// Get the PaymentAttemptInfo. This can be unset.\n\tb = bucket.Get(paymentAttemptInfoKey)\n\tif b != nil {\n\t\tr = bytes.NewReader(b)\n\t\tp.Attempt, err = deserializePaymentAttemptInfoMigration9(r)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Get the payment preimage. This is only found for\n\t// completed payments.\n\tb = bucket.Get(paymentSettleInfoKey)\n\tif b != nil {\n\t\tvar preimg lntypes.Preimage\n\t\tcopy(preimg[:], b[:])\n\t\tp.PaymentPreimage = &preimg\n\t}\n\n\t// Get failure reason if available.\n\tb = bucket.Get(paymentFailInfoKey)\n\tif b != nil {\n\t\treason := FailureReason(b[0])\n\t\tp.Failure = &reason\n\t}\n\n\treturn p, nil\n}\n",
      "length": 1107,
      "tokens": 157,
      "embedding": []
    }
  ]
}