{
  "filepath": "../implementations/go/lnd/channeldb/migration_01_to_11/channel.go",
  "package": "migration_01_to_11",
  "sections": [
    {
      "slug": "type ChannelType uint8",
      "content": "type ChannelType uint8\n\nconst (\n\t// NOTE: iota isn't used here for this enum needs to be stable\n\t// long-term as it will be persisted to the database.\n\n\t// SingleFunder represents a channel wherein one party solely funds the\n\t// entire capacity of the channel.\n\tSingleFunder ChannelType = 0\n)\n\n// ChannelConstraints represents a set of constraints meant to allow a node to\n// limit their exposure, enact flow control and ensure that all HTLCs are\n// economically relevant. This struct will be mirrored for both sides of the\n// channel, as each side will enforce various constraints that MUST be adhered\n// to for the life time of the channel. The parameters for each of these\n// constraints are static for the duration of the channel, meaning the channel\n// must be torn down for them to change.",
      "length": 756,
      "tokens": 136,
      "embedding": []
    },
    {
      "slug": "type ChannelConstraints struct {",
      "content": "type ChannelConstraints struct {\n\t// DustLimit is the threshold (in satoshis) below which any outputs\n\t// should be trimmed. When an output is trimmed, it isn't materialized\n\t// as an actual output, but is instead burned to miner's fees.\n\tDustLimit btcutil.Amount\n\n\t// ChanReserve is an absolute reservation on the channel for the\n\t// owner of this set of constraints. This means that the current\n\t// settled balance for this node CANNOT dip below the reservation\n\t// amount. This acts as a defense against costless attacks when\n\t// either side no longer has any skin in the game.\n\tChanReserve btcutil.Amount\n\n\t// MaxPendingAmount is the maximum pending HTLC value that the\n\t// owner of these constraints can offer the remote node at a\n\t// particular time.\n\tMaxPendingAmount lnwire.MilliSatoshi\n\n\t// MinHTLC is the minimum HTLC value that the owner of these\n\t// constraints can offer the remote node. If any HTLCs below this\n\t// amount are offered, then the HTLC will be rejected. This, in\n\t// tandem with the dust limit allows a node to regulate the\n\t// smallest HTLC that it deems economically relevant.\n\tMinHTLC lnwire.MilliSatoshi\n\n\t// MaxAcceptedHtlcs is the maximum number of HTLCs that the owner of\n\t// this set of constraints can offer the remote node. This allows each\n\t// node to limit their over all exposure to HTLCs that may need to be\n\t// acted upon in the case of a unilateral channel closure or a contract\n\t// breach.\n\tMaxAcceptedHtlcs uint16\n\n\t// CsvDelay is the relative time lock delay expressed in blocks. Any\n\t// settled outputs that pay to the owner of this channel configuration\n\t// MUST ensure that the delay branch uses this value as the relative\n\t// time lock. Similarly, any HTLC's offered by this node should use\n\t// this value as well.\n\tCsvDelay uint16\n}\n\n// ChannelConfig is a struct that houses the various configuration opens for\n// channels. Each side maintains an instance of this configuration file as it\n// governs: how the funding and commitment transaction to be created, the\n// nature of HTLC's allotted, the keys to be used for delivery, and relative\n// time lock parameters.",
      "length": 2039,
      "tokens": 350,
      "embedding": []
    },
    {
      "slug": "type ChannelConfig struct {",
      "content": "type ChannelConfig struct {\n\t// ChannelConstraints is the set of constraints that must be upheld for\n\t// the duration of the channel for the owner of this channel\n\t// configuration. Constraints govern a number of flow control related\n\t// parameters, also including the smallest HTLC that will be accepted\n\t// by a participant.\n\tChannelConstraints\n\n\t// MultiSigKey is the key to be used within the 2-of-2 output script\n\t// for the owner of this channel config.\n\tMultiSigKey keychain.KeyDescriptor\n\n\t// RevocationBasePoint is the base public key to be used when deriving\n\t// revocation keys for the remote node's commitment transaction. This\n\t// will be combined along with a per commitment secret to derive a\n\t// unique revocation key for each state.\n\tRevocationBasePoint keychain.KeyDescriptor\n\n\t// PaymentBasePoint is the base public key to be used when deriving\n\t// the key used within the non-delayed pay-to-self output on the\n\t// commitment transaction for a node. This will be combined with a\n\t// tweak derived from the per-commitment point to ensure unique keys\n\t// for each commitment transaction.\n\tPaymentBasePoint keychain.KeyDescriptor\n\n\t// DelayBasePoint is the base public key to be used when deriving the\n\t// key used within the delayed pay-to-self output on the commitment\n\t// transaction for a node. This will be combined with a tweak derived\n\t// from the per-commitment point to ensure unique keys for each\n\t// commitment transaction.\n\tDelayBasePoint keychain.KeyDescriptor\n\n\t// HtlcBasePoint is the base public key to be used when deriving the\n\t// local HTLC key. The derived key (combined with the tweak derived\n\t// from the per-commitment point) is used within the \"to self\" clause\n\t// within any HTLC output scripts.\n\tHtlcBasePoint keychain.KeyDescriptor\n}\n\n// ChannelCommitment is a snapshot of the commitment state at a particular\n// point in the commitment chain. With each state transition, a snapshot of the\n// current state along with all non-settled HTLCs are recorded. These snapshots\n// detail the state of the _remote_ party's commitment at a particular state\n// number.  For ourselves (the local node) we ONLY store our most recent\n// (unrevoked) state for safety purposes.",
      "length": 2133,
      "tokens": 339,
      "embedding": []
    },
    {
      "slug": "type ChannelCommitment struct {",
      "content": "type ChannelCommitment struct {\n\t// CommitHeight is the update number that this ChannelDelta represents\n\t// the total number of commitment updates to this point. This can be\n\t// viewed as sort of a \"commitment height\" as this number is\n\t// monotonically increasing.\n\tCommitHeight uint64\n\n\t// LocalLogIndex is the cumulative log index index of the local node at\n\t// this point in the commitment chain. This value will be incremented\n\t// for each _update_ added to the local update log.\n\tLocalLogIndex uint64\n\n\t// LocalHtlcIndex is the current local running HTLC index. This value\n\t// will be incremented for each outgoing HTLC the local node offers.\n\tLocalHtlcIndex uint64\n\n\t// RemoteLogIndex is the cumulative log index index of the remote node\n\t// at this point in the commitment chain. This value will be\n\t// incremented for each _update_ added to the remote update log.\n\tRemoteLogIndex uint64\n\n\t// RemoteHtlcIndex is the current remote running HTLC index. This value\n\t// will be incremented for each outgoing HTLC the remote node offers.\n\tRemoteHtlcIndex uint64\n\n\t// LocalBalance is the current available settled balance within the\n\t// channel directly spendable by us.\n\tLocalBalance lnwire.MilliSatoshi\n\n\t// RemoteBalance is the current available settled balance within the\n\t// channel directly spendable by the remote node.\n\tRemoteBalance lnwire.MilliSatoshi\n\n\t// CommitFee is the amount calculated to be paid in fees for the\n\t// current set of commitment transactions. The fee amount is persisted\n\t// with the channel in order to allow the fee amount to be removed and\n\t// recalculated with each channel state update, including updates that\n\t// happen after a system restart.\n\tCommitFee btcutil.Amount\n\n\t// FeePerKw is the min satoshis/kilo-weight that should be paid within\n\t// the commitment transaction for the entire duration of the channel's\n\t// lifetime. This field may be updated during normal operation of the\n\t// channel as on-chain conditions change.\n\t//\n\t// TODO(halseth): make this SatPerKWeight. Cannot be done atm because\n\t// this will cause the import cycle lnwallet<->channeldb. Fee\n\t// estimation stuff should be in its own package.\n\tFeePerKw btcutil.Amount\n\n\t// CommitTx is the latest version of the commitment state, broadcast\n\t// able by us.\n\tCommitTx *wire.MsgTx\n\n\t// CommitSig is one half of the signature required to fully complete\n\t// the script for the commitment transaction above. This is the\n\t// signature signed by the remote party for our version of the\n\t// commitment transactions.\n\tCommitSig []byte\n\n\t// Htlcs is the set of HTLC's that are pending at this particular\n\t// commitment height.\n\tHtlcs []HTLC\n\n\t// TODO(roasbeef): pending commit pointer?\n\t//  * lets just walk through\n}\n\n// ChannelStatus is a bit vector used to indicate whether an OpenChannel is in\n// the default usable state, or a state where it shouldn't be used.",
      "length": 2766,
      "tokens": 444,
      "embedding": []
    },
    {
      "slug": "type ChannelStatus uint8",
      "content": "type ChannelStatus uint8\n\nvar (\n\t// ChanStatusDefault is the normal state of an open channel.\n\tChanStatusDefault ChannelStatus\n\n\t// ChanStatusBorked indicates that the channel has entered an\n\t// irreconcilable state, triggered by a state desynchronization or\n\t// channel breach.  Channels in this state should never be added to the\n\t// htlc switch.\n\tChanStatusBorked ChannelStatus = 1\n\n\t// ChanStatusCommitBroadcasted indicates that a commitment for this\n\t// channel has been broadcasted.\n\tChanStatusCommitBroadcasted ChannelStatus = 1 << 1\n\n\t// ChanStatusLocalDataLoss indicates that we have lost channel state\n\t// for this channel, and broadcasting our latest commitment might be\n\t// considered a breach.\n\t//\n\t// TODO(halseh): actually enforce that we are not force closing such a\n\t// channel.\n\tChanStatusLocalDataLoss ChannelStatus = 1 << 2\n\n\t// ChanStatusRestored is a status flag that signals that the channel\n\t// has been restored, and doesn't have all the fields a typical channel\n\t// will have.\n\tChanStatusRestored ChannelStatus = 1 << 3\n)\n\n// chanStatusStrings maps a ChannelStatus to a human friendly string that\n// describes that status.\nvar chanStatusStrings = map[ChannelStatus]string{\n\tChanStatusDefault:           \"ChanStatusDefault\",\n\tChanStatusBorked:            \"ChanStatusBorked\",\n\tChanStatusCommitBroadcasted: \"ChanStatusCommitBroadcasted\",\n\tChanStatusLocalDataLoss:     \"ChanStatusLocalDataLoss\",\n\tChanStatusRestored:          \"ChanStatusRestored\",\n}\n\n// orderedChanStatusFlags is an in-order list of all that channel status flags.\nvar orderedChanStatusFlags = []ChannelStatus{\n\tChanStatusDefault,\n\tChanStatusBorked,\n\tChanStatusCommitBroadcasted,\n\tChanStatusLocalDataLoss,\n\tChanStatusRestored,\n}\n\n// String returns a human-readable representation of the ChannelStatus.",
      "length": 1716,
      "tokens": 211,
      "embedding": []
    },
    {
      "slug": "func (c ChannelStatus) String() string {",
      "content": "func (c ChannelStatus) String() string {\n\t// If no flags are set, then this is the default case.\n\tif c == 0 {\n\t\treturn chanStatusStrings[ChanStatusDefault]\n\t}\n\n\t// Add individual bit flags.\n\tstatusStr := \"\"\n\tfor _, flag := range orderedChanStatusFlags {\n\t\tif c&flag == flag {\n\t\t\tstatusStr += chanStatusStrings[flag] + \"|\"\n\t\t\tc -= flag\n\t\t}\n\t}\n\n\t// Remove anything to the right of the final bar, including it as well.\n\tstatusStr = strings.TrimRight(statusStr, \"|\")\n\n\t// Add any remaining flags which aren't accounted for as hex.\n\tif c != 0 {\n\t\tstatusStr += \"|0x\" + strconv.FormatUint(uint64(c), 16)\n\t}\n\n\t// If this was purely an unknown flag, then remove the extra bar at the\n\t// start of the string.\n\tstatusStr = strings.TrimLeft(statusStr, \"|\")\n\n\treturn statusStr\n}\n\n// OpenChannel encapsulates the persistent and dynamic state of an open channel\n// with a remote node. An open channel supports several options for on-disk\n// serialization depending on the exact context. Full (upon channel creation)\n// state commitments, and partial (due to a commitment update) writes are\n// supported. Each partial write due to a state update appends the new update\n// to an on-disk log, which can then subsequently be queried in order to\n// \"time-travel\" to a prior state.",
      "length": 1184,
      "tokens": 200,
      "embedding": []
    },
    {
      "slug": "type OpenChannel struct {",
      "content": "type OpenChannel struct {\n\t// ChanType denotes which type of channel this is.\n\tChanType ChannelType\n\n\t// ChainHash is a hash which represents the blockchain that this\n\t// channel will be opened within. This value is typically the genesis\n\t// hash. In the case that the original chain went through a contentious\n\t// hard-fork, then this value will be tweaked using the unique fork\n\t// point on each branch.\n\tChainHash chainhash.Hash\n\n\t// FundingOutpoint is the outpoint of the final funding transaction.\n\t// This value uniquely and globally identifies the channel within the\n\t// target blockchain as specified by the chain hash parameter.\n\tFundingOutpoint wire.OutPoint\n\n\t// ShortChannelID encodes the exact location in the chain in which the\n\t// channel was initially confirmed. This includes: the block height,\n\t// transaction index, and the output within the target transaction.\n\tShortChannelID lnwire.ShortChannelID\n\n\t// IsPending indicates whether a channel's funding transaction has been\n\t// confirmed.\n\tIsPending bool\n\n\t// IsInitiator is a bool which indicates if we were the original\n\t// initiator for the channel. This value may affect how higher levels\n\t// negotiate fees, or close the channel.\n\tIsInitiator bool\n\n\t// FundingBroadcastHeight is the height in which the funding\n\t// transaction was broadcast. This value can be used by higher level\n\t// sub-systems to determine if a channel is stale and/or should have\n\t// been confirmed before a certain height.\n\tFundingBroadcastHeight uint32\n\n\t// NumConfsRequired is the number of confirmations a channel's funding\n\t// transaction must have received in order to be considered available\n\t// for normal transactional use.\n\tNumConfsRequired uint16\n\n\t// ChannelFlags holds the flags that were sent as part of the\n\t// open_channel message.\n\tChannelFlags lnwire.FundingFlag\n\n\t// IdentityPub is the identity public key of the remote node this\n\t// channel has been established with.\n\tIdentityPub *btcec.PublicKey\n\n\t// Capacity is the total capacity of this channel.\n\tCapacity btcutil.Amount\n\n\t// TotalMSatSent is the total number of milli-satoshis we've sent\n\t// within this channel.\n\tTotalMSatSent lnwire.MilliSatoshi\n\n\t// TotalMSatReceived is the total number of milli-satoshis we've\n\t// received within this channel.\n\tTotalMSatReceived lnwire.MilliSatoshi\n\n\t// LocalChanCfg is the channel configuration for the local node.\n\tLocalChanCfg ChannelConfig\n\n\t// RemoteChanCfg is the channel configuration for the remote node.\n\tRemoteChanCfg ChannelConfig\n\n\t// LocalCommitment is the current local commitment state for the local\n\t// party. This is stored distinct from the state of the remote party\n\t// as there are certain asymmetric parameters which affect the\n\t// structure of each commitment.\n\tLocalCommitment ChannelCommitment\n\n\t// RemoteCommitment is the current remote commitment state for the\n\t// remote party. This is stored distinct from the state of the local\n\t// party as there are certain asymmetric parameters which affect the\n\t// structure of each commitment.\n\tRemoteCommitment ChannelCommitment\n\n\t// RemoteCurrentRevocation is the current revocation for their\n\t// commitment transaction. However, since this the derived public key,\n\t// we don't yet have the private key so we aren't yet able to verify\n\t// that it's actually in the hash chain.\n\tRemoteCurrentRevocation *btcec.PublicKey\n\n\t// RemoteNextRevocation is the revocation key to be used for the *next*\n\t// commitment transaction we create for the local node. Within the\n\t// specification, this value is referred to as the\n\t// per-commitment-point.\n\tRemoteNextRevocation *btcec.PublicKey\n\n\t// RevocationProducer is used to generate the revocation in such a way\n\t// that remote side might store it efficiently and have the ability to\n\t// restore the revocation by index if needed. Current implementation of\n\t// secret producer is shachain producer.\n\tRevocationProducer shachain.Producer\n\n\t// RevocationStore is used to efficiently store the revocations for\n\t// previous channels states sent to us by remote side. Current\n\t// implementation of secret store is shachain store.\n\tRevocationStore shachain.Store\n\n\t// FundingTxn is the transaction containing this channel's funding\n\t// outpoint. Upon restarts, this txn will be rebroadcast if the channel\n\t// is found to be pending.\n\t//\n\t// NOTE: This value will only be populated for single-funder channels\n\t// for which we are the initiator.\n\tFundingTxn *wire.MsgTx\n\n\t// TODO(roasbeef): eww\n\tDb *DB\n\n\t// TODO(roasbeef): just need to store local and remote HTLC's?\n\n\tsync.RWMutex\n}\n\n// ShortChanID returns the current ShortChannelID of this channel.",
      "length": 4470,
      "tokens": 664,
      "embedding": []
    },
    {
      "slug": "func (c *OpenChannel) ShortChanID() lnwire.ShortChannelID {",
      "content": "func (c *OpenChannel) ShortChanID() lnwire.ShortChannelID {\n\tc.RLock()\n\tdefer c.RUnlock()\n\n\treturn c.ShortChannelID\n}\n\n// HTLC is the on-disk representation of a hash time-locked contract. HTLCs are\n// contained within ChannelDeltas which encode the current state of the\n// commitment between state updates.\n//\n// TODO(roasbeef): save space by using smaller ints at tail end?",
      "length": 305,
      "tokens": 47,
      "embedding": []
    },
    {
      "slug": "type HTLC struct {",
      "content": "type HTLC struct {\n\t// Signature is the signature for the second level covenant transaction\n\t// for this HTLC. The second level transaction is a timeout tx in the\n\t// case that this is an outgoing HTLC, and a success tx in the case\n\t// that this is an incoming HTLC.\n\t//\n\t// TODO(roasbeef): make [64]byte instead?\n\tSignature []byte\n\n\t// RHash is the payment hash of the HTLC.\n\tRHash [32]byte\n\n\t// Amt is the amount of milli-satoshis this HTLC escrows.\n\tAmt lnwire.MilliSatoshi\n\n\t// RefundTimeout is the absolute timeout on the HTLC that the sender\n\t// must wait before reclaiming the funds in limbo.\n\tRefundTimeout uint32\n\n\t// OutputIndex is the output index for this particular HTLC output\n\t// within the commitment transaction.\n\tOutputIndex int32\n\n\t// Incoming denotes whether we're the receiver or the sender of this\n\t// HTLC.\n\tIncoming bool\n\n\t// OnionBlob is an opaque blob which is used to complete multi-hop\n\t// routing.\n\tOnionBlob []byte\n\n\t// HtlcIndex is the HTLC counter index of this active, outstanding\n\t// HTLC. This differs from the LogIndex, as the HtlcIndex is only\n\t// incremented for each offered HTLC, while they LogIndex is\n\t// incremented for each update (includes settle+fail).\n\tHtlcIndex uint64\n\n\t// LogIndex is the cumulative log index of this HTLC. This differs\n\t// from the HtlcIndex as this will be incremented for each new log\n\t// update added.\n\tLogIndex uint64\n}\n\n// CircuitKey is used by a channel to uniquely identify the HTLCs it receives\n// from the switch, and is used to purge our in-memory state of HTLCs that have\n// already been processed by a link. Two list of CircuitKeys are included in\n// each CommitDiff to allow a link to determine which in-memory htlcs directed\n// the opening and closing of circuits in the switch's circuit map.",
      "length": 1708,
      "tokens": 293,
      "embedding": []
    },
    {
      "slug": "type CircuitKey struct {",
      "content": "type CircuitKey struct {\n\t// ChanID is the short chanid indicating the HTLC's origin.\n\t//\n\t// NOTE: It is fine for this value to be blank, as this indicates a\n\t// locally-sourced payment.\n\tChanID lnwire.ShortChannelID\n\n\t// HtlcID is the unique htlc index predominately assigned by links,\n\t// though can also be assigned by switch in the case of locally-sourced\n\t// payments.\n\tHtlcID uint64\n}\n\n// String returns a string representation of the CircuitKey.",
      "length": 416,
      "tokens": 69,
      "embedding": []
    },
    {
      "slug": "func (k CircuitKey) String() string {",
      "content": "func (k CircuitKey) String() string {\n\treturn fmt.Sprintf(\"(Chan ID=%s, HTLC ID=%d)\", k.ChanID, k.HtlcID)\n}\n\n// ClosureType is an enum like structure that details exactly _how_ a channel\n// was closed. Three closure types are currently possible: none, cooperative,\n// local force close, remote force close, and (remote) breach.",
      "length": 284,
      "tokens": 42,
      "embedding": []
    },
    {
      "slug": "type ClosureType uint8",
      "content": "type ClosureType uint8\n\nconst (\n\t// RemoteForceClose indicates that the remote peer has unilaterally\n\t// broadcast their current commitment state on-chain.\n\tRemoteForceClose ClosureType = 4\n)\n\n// ChannelCloseSummary contains the final state of a channel at the point it\n// was closed. Once a channel is closed, all the information pertaining to that\n// channel within the openChannelBucket is deleted, and a compact summary is\n// put in place instead.",
      "length": 418,
      "tokens": 67,
      "embedding": []
    },
    {
      "slug": "type ChannelCloseSummary struct {",
      "content": "type ChannelCloseSummary struct {\n\t// ChanPoint is the outpoint for this channel's funding transaction,\n\t// and is used as a unique identifier for the channel.\n\tChanPoint wire.OutPoint\n\n\t// ShortChanID encodes the exact location in the chain in which the\n\t// channel was initially confirmed. This includes: the block height,\n\t// transaction index, and the output within the target transaction.\n\tShortChanID lnwire.ShortChannelID\n\n\t// ChainHash is the hash of the genesis block that this channel resides\n\t// within.\n\tChainHash chainhash.Hash\n\n\t// ClosingTXID is the txid of the transaction which ultimately closed\n\t// this channel.\n\tClosingTXID chainhash.Hash\n\n\t// RemotePub is the public key of the remote peer that we formerly had\n\t// a channel with.\n\tRemotePub *btcec.PublicKey\n\n\t// Capacity was the total capacity of the channel.\n\tCapacity btcutil.Amount\n\n\t// CloseHeight is the height at which the funding transaction was\n\t// spent.\n\tCloseHeight uint32\n\n\t// SettledBalance is our total balance settled balance at the time of\n\t// channel closure. This _does not_ include the sum of any outputs that\n\t// have been time-locked as a result of the unilateral channel closure.\n\tSettledBalance btcutil.Amount\n\n\t// TimeLockedBalance is the sum of all the time-locked outputs at the\n\t// time of channel closure. If we triggered the force closure of this\n\t// channel, then this value will be non-zero if our settled output is\n\t// above the dust limit. If we were on the receiving side of a channel\n\t// force closure, then this value will be non-zero if we had any\n\t// outstanding outgoing HTLC's at the time of channel closure.\n\tTimeLockedBalance btcutil.Amount\n\n\t// CloseType details exactly _how_ the channel was closed. Five closure\n\t// types are possible: cooperative, local force, remote force, breach\n\t// and funding canceled.\n\tCloseType ClosureType\n\n\t// IsPending indicates whether this channel is in the 'pending close'\n\t// state, which means the channel closing transaction has been\n\t// confirmed, but not yet been fully resolved. In the case of a channel\n\t// that has been cooperatively closed, it will go straight into the\n\t// fully resolved state as soon as the closing transaction has been\n\t// confirmed. However, for channels that have been force closed, they'll\n\t// stay marked as \"pending\" until _all_ the pending funds have been\n\t// swept.\n\tIsPending bool\n\n\t// RemoteCurrentRevocation is the current revocation for their\n\t// commitment transaction. However, since this is the derived public key,\n\t// we don't yet have the private key so we aren't yet able to verify\n\t// that it's actually in the hash chain.\n\tRemoteCurrentRevocation *btcec.PublicKey\n\n\t// RemoteNextRevocation is the revocation key to be used for the *next*\n\t// commitment transaction we create for the local node. Within the\n\t// specification, this value is referred to as the\n\t// per-commitment-point.\n\tRemoteNextRevocation *btcec.PublicKey\n\n\t// LocalChanCfg is the channel configuration for the local node.\n\tLocalChanConfig ChannelConfig\n\n\t// LastChanSyncMsg is the ChannelReestablish message for this channel\n\t// for the state at the point where it was closed.\n\tLastChanSyncMsg *lnwire.ChannelReestablish\n}\n",
      "length": 3079,
      "tokens": 481,
      "embedding": []
    },
    {
      "slug": "func serializeChannelCloseSummary(w io.Writer, cs *ChannelCloseSummary) error {",
      "content": "func serializeChannelCloseSummary(w io.Writer, cs *ChannelCloseSummary) error {\n\terr := WriteElements(w,\n\t\tcs.ChanPoint, cs.ShortChanID, cs.ChainHash, cs.ClosingTXID,\n\t\tcs.CloseHeight, cs.RemotePub, cs.Capacity, cs.SettledBalance,\n\t\tcs.TimeLockedBalance, cs.CloseType, cs.IsPending,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// If this is a close channel summary created before the addition of\n\t// the new fields, then we can exit here.\n\tif cs.RemoteCurrentRevocation == nil {\n\t\treturn WriteElements(w, false)\n\t}\n\n\t// If fields are present, write boolean to indicate this, and continue.\n\tif err := WriteElements(w, true); err != nil {\n\t\treturn err\n\t}\n\n\tif err := WriteElements(w, cs.RemoteCurrentRevocation); err != nil {\n\t\treturn err\n\t}\n\n\tif err := WriteChanConfig(w, &cs.LocalChanConfig); err != nil {\n\t\treturn err\n\t}\n\n\t// The RemoteNextRevocation field is optional, as it's possible for a\n\t// channel to be closed before we learn of the next unrevoked\n\t// revocation point for the remote party. Write a boolean indicating\n\t// whether this field is present or not.\n\tif err := WriteElements(w, cs.RemoteNextRevocation != nil); err != nil {\n\t\treturn err\n\t}\n\n\t// Write the field, if present.\n\tif cs.RemoteNextRevocation != nil {\n\t\tif err = WriteElements(w, cs.RemoteNextRevocation); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Write whether the channel sync message is present.\n\tif err := WriteElements(w, cs.LastChanSyncMsg != nil); err != nil {\n\t\treturn err\n\t}\n\n\t// Write the channel sync message, if present.\n\tif cs.LastChanSyncMsg != nil {\n\t\tif err := WriteElements(w, cs.LastChanSyncMsg); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n",
      "length": 1496,
      "tokens": 234,
      "embedding": []
    },
    {
      "slug": "func deserializeCloseChannelSummary(r io.Reader) (*ChannelCloseSummary, error) {",
      "content": "func deserializeCloseChannelSummary(r io.Reader) (*ChannelCloseSummary, error) {\n\tc := &ChannelCloseSummary{}\n\n\terr := ReadElements(r,\n\t\t&c.ChanPoint, &c.ShortChanID, &c.ChainHash, &c.ClosingTXID,\n\t\t&c.CloseHeight, &c.RemotePub, &c.Capacity, &c.SettledBalance,\n\t\t&c.TimeLockedBalance, &c.CloseType, &c.IsPending,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// We'll now check to see if the channel close summary was encoded with\n\t// any of the additional optional fields.\n\tvar hasNewFields bool\n\terr = ReadElements(r, &hasNewFields)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// If fields are not present, we can return.\n\tif !hasNewFields {\n\t\treturn c, nil\n\t}\n\n\t// Otherwise read the new fields.\n\tif err := ReadElements(r, &c.RemoteCurrentRevocation); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := ReadChanConfig(r, &c.LocalChanConfig); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Finally, we'll attempt to read the next unrevoked commitment point\n\t// for the remote party. If we closed the channel before receiving a\n\t// funding locked message then this might not be present. A boolean\n\t// indicating whether the field is present will come first.\n\tvar hasRemoteNextRevocation bool\n\terr = ReadElements(r, &hasRemoteNextRevocation)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// If this field was written, read it.\n\tif hasRemoteNextRevocation {\n\t\terr = ReadElements(r, &c.RemoteNextRevocation)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Check if we have a channel sync message to read.\n\tvar hasChanSyncMsg bool\n\terr = ReadElements(r, &hasChanSyncMsg)\n\tif err == io.EOF {\n\t\treturn c, nil\n\t} else if err != nil {\n\t\treturn nil, err\n\t}\n\n\t// If a chan sync message is present, read it.\n\tif hasChanSyncMsg {\n\t\t// We must pass in reference to a lnwire.Message for the codec\n\t\t// to support it.\n\t\tvar msg lnwire.Message\n\t\tif err := ReadElements(r, &msg); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tchanSync, ok := msg.(*lnwire.ChannelReestablish)\n\t\tif !ok {\n\t\t\treturn nil, errors.New(\"unable cast db Message to \" +\n\t\t\t\t\"ChannelReestablish\")\n\t\t}\n\t\tc.LastChanSyncMsg = chanSync\n\t}\n\n\treturn c, nil\n}\n",
      "length": 1917,
      "tokens": 307,
      "embedding": []
    },
    {
      "slug": "func WriteChanConfig(b io.Writer, c *ChannelConfig) error {",
      "content": "func WriteChanConfig(b io.Writer, c *ChannelConfig) error {\n\treturn WriteElements(b,\n\t\tc.DustLimit, c.MaxPendingAmount, c.ChanReserve, c.MinHTLC,\n\t\tc.MaxAcceptedHtlcs, c.CsvDelay, c.MultiSigKey,\n\t\tc.RevocationBasePoint, c.PaymentBasePoint, c.DelayBasePoint,\n\t\tc.HtlcBasePoint,\n\t)\n}\n",
      "length": 215,
      "tokens": 15,
      "embedding": []
    },
    {
      "slug": "func ReadChanConfig(b io.Reader, c *ChannelConfig) error {",
      "content": "func ReadChanConfig(b io.Reader, c *ChannelConfig) error {\n\treturn ReadElements(b,\n\t\t&c.DustLimit, &c.MaxPendingAmount, &c.ChanReserve,\n\t\t&c.MinHTLC, &c.MaxAcceptedHtlcs, &c.CsvDelay,\n\t\t&c.MultiSigKey, &c.RevocationBasePoint,\n\t\t&c.PaymentBasePoint, &c.DelayBasePoint,\n\t\t&c.HtlcBasePoint,\n\t)\n}\n",
      "length": 226,
      "tokens": 15,
      "embedding": []
    },
    {
      "slug": "func DeserializeChanCommit(r io.Reader) (ChannelCommitment, error) {",
      "content": "func DeserializeChanCommit(r io.Reader) (ChannelCommitment, error) {\n\tvar c ChannelCommitment\n\n\terr := ReadElements(r,\n\t\t&c.CommitHeight, &c.LocalLogIndex, &c.LocalHtlcIndex, &c.RemoteLogIndex,\n\t\t&c.RemoteHtlcIndex, &c.LocalBalance, &c.RemoteBalance,\n\t\t&c.CommitFee, &c.FeePerKw, &c.CommitTx, &c.CommitSig,\n\t)\n\tif err != nil {\n\t\treturn c, err\n\t}\n\n\tc.Htlcs, err = DeserializeHtlcs(r)\n\tif err != nil {\n\t\treturn c, err\n\t}\n\n\treturn c, nil\n}\n\n// DeserializeHtlcs attempts to read out a slice of HTLC's from the passed\n// io.Reader. The bytes within the passed reader MUST have been previously\n// written to using the SerializeHtlcs function.\n//\n// NOTE: This API is NOT stable, the on-disk format will likely change in the\n// future.",
      "length": 635,
      "tokens": 94,
      "embedding": []
    },
    {
      "slug": "func DeserializeHtlcs(r io.Reader) ([]HTLC, error) {",
      "content": "func DeserializeHtlcs(r io.Reader) ([]HTLC, error) {\n\tvar numHtlcs uint16\n\tif err := ReadElement(r, &numHtlcs); err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar htlcs []HTLC\n\tif numHtlcs == 0 {\n\t\treturn htlcs, nil\n\t}\n\n\thtlcs = make([]HTLC, numHtlcs)\n\tfor i := uint16(0); i < numHtlcs; i++ {\n\t\tif err := ReadElements(r,\n\t\t\t&htlcs[i].Signature, &htlcs[i].RHash, &htlcs[i].Amt,\n\t\t\t&htlcs[i].RefundTimeout, &htlcs[i].OutputIndex,\n\t\t\t&htlcs[i].Incoming, &htlcs[i].OnionBlob,\n\t\t\t&htlcs[i].HtlcIndex, &htlcs[i].LogIndex,\n\t\t); err != nil {\n\t\t\treturn htlcs, err\n\t\t}\n\t}\n\n\treturn htlcs, nil\n}\n",
      "length": 496,
      "tokens": 68,
      "embedding": []
    },
    {
      "slug": "func SerializeChanCommit(w io.Writer, c *ChannelCommitment) error {",
      "content": "func SerializeChanCommit(w io.Writer, c *ChannelCommitment) error {\n\tif err := WriteElements(w,\n\t\tc.CommitHeight, c.LocalLogIndex, c.LocalHtlcIndex,\n\t\tc.RemoteLogIndex, c.RemoteHtlcIndex, c.LocalBalance,\n\t\tc.RemoteBalance, c.CommitFee, c.FeePerKw, c.CommitTx,\n\t\tc.CommitSig,\n\t); err != nil {\n\t\treturn err\n\t}\n\n\treturn SerializeHtlcs(w, c.Htlcs...)\n}\n\n// SerializeHtlcs writes out the passed set of HTLC's into the passed writer\n// using the current default on-disk serialization format.\n//\n// NOTE: This API is NOT stable, the on-disk format will likely change in the\n// future.",
      "length": 493,
      "tokens": 66,
      "embedding": []
    },
    {
      "slug": "func SerializeHtlcs(b io.Writer, htlcs ...HTLC) error {",
      "content": "func SerializeHtlcs(b io.Writer, htlcs ...HTLC) error {\n\tnumHtlcs := uint16(len(htlcs))\n\tif err := WriteElement(b, numHtlcs); err != nil {\n\t\treturn err\n\t}\n\n\tfor _, htlc := range htlcs {\n\t\tif err := WriteElements(b,\n\t\t\thtlc.Signature, htlc.RHash, htlc.Amt, htlc.RefundTimeout,\n\t\t\thtlc.OutputIndex, htlc.Incoming, htlc.OnionBlob[:],\n\t\t\thtlc.HtlcIndex, htlc.LogIndex,\n\t\t); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n",
      "length": 346,
      "tokens": 47,
      "embedding": []
    }
  ]
}