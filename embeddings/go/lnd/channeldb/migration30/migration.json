{
  "filepath": "../implementations/go/lnd/channeldb/migration30/migration.go",
  "package": "migration30",
  "sections": [
    {
      "slug": "type MigrateRevLogConfig interface {",
      "content": "type MigrateRevLogConfig interface {\n\t// GetNoAmountData returns true if the amount data of revoked commitment\n\t// transactions should not be stored in the revocation log.\n\tGetNoAmountData() bool\n}\n\n// MigrateRevLogConfigImpl implements the MigrationRevLogConfig interface.",
      "length": 231,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "type MigrateRevLogConfigImpl struct {",
      "content": "type MigrateRevLogConfigImpl struct {\n\t// NoAmountData if set to true will result in the amount data of revoked\n\t// commitment transactions not being stored in the revocation log.\n\tNoAmountData bool\n}\n\n// GetNoAmountData returns true if the amount data of revoked commitment\n// transactions should not be stored in the revocation log.",
      "length": 290,
      "tokens": 48,
      "embedding": []
    },
    {
      "slug": "func (c *MigrateRevLogConfigImpl) GetNoAmountData() bool {",
      "content": "func (c *MigrateRevLogConfigImpl) GetNoAmountData() bool {\n\treturn c.NoAmountData\n}\n\n// MigrateRevocationLog migrates the old revocation logs into the newer format\n// and deletes them once finished, with the deletion only happens once ALL the\n// old logs have been migrates.",
      "length": 210,
      "tokens": 34,
      "embedding": []
    },
    {
      "slug": "func MigrateRevocationLog(db kvdb.Backend, cfg MigrateRevLogConfig) error {",
      "content": "func MigrateRevocationLog(db kvdb.Backend, cfg MigrateRevLogConfig) error {\n\tlog.Infof(\"Migrating revocation logs, might take a while...\")\n\n\tvar (\n\t\terr error\n\n\t\t// finished is used to exit the for loop.\n\t\tfinished bool\n\n\t\t// total is the number of total records.\n\t\ttotal uint64\n\n\t\t// migrated is the number of already migrated records.\n\t\tmigrated uint64\n\t)\n\n\t// First of all, read the stats of the revocation logs.\n\ttotal, migrated, err = logMigrationStat(db)\n\tif err != nil {\n\t\treturn err\n\t}\n\tlog.Infof(\"Total logs=%d, migrated=%d\", total, migrated)\n\n\t// Exit early if the old logs have already been migrated and deleted.\n\tif total == 0 {\n\t\tlog.Info(\"Migration already finished!\")\n\t\treturn nil\n\t}\n\n\tfor {\n\t\tif finished {\n\t\t\tlog.Infof(\"Migrating old revocation logs finished, \" +\n\t\t\t\t\"now checking the migration results...\")\n\t\t\tbreak\n\t\t}\n\n\t\t// Process the migration.\n\t\terr = kvdb.Update(db, func(tx kvdb.RwTx) error {\n\t\t\tfinished, err = processMigration(tx, cfg)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}, func() {})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Each time we finished the above process, we'd read the stats\n\t\t// again to understand the current progress.\n\t\ttotal, migrated, err = logMigrationStat(db)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Calculate and log the progress if the progress is less than\n\t\t// one.\n\t\tprogress := float64(migrated) / float64(total) * 100\n\t\tif progress >= 100 {\n\t\t\tcontinue\n\t\t}\n\n\t\tlog.Infof(\"Migration progress: %.3f%%, still have: %d\",\n\t\t\tprogress, total-migrated)\n\t}\n\n\t// Before we can safety delete the old buckets, we perform a check to\n\t// make sure the logs are migrated as expected.\n\terr = kvdb.Update(db, validateMigration, func() {})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"validate migration failed: %v\", err)\n\t}\n\n\tlog.Info(\"Migration check passed, now deleting the old logs...\")\n\n\t// Once the migration completes, we can now safety delete the old\n\t// revocation logs.\n\tif err := deleteOldBuckets(db); err != nil {\n\t\treturn fmt.Errorf(\"deleteOldBuckets err: %v\", err)\n\t}\n\n\tlog.Info(\"Old revocation log buckets removed!\")\n\treturn nil\n}\n\n// processMigration finds the next un-migrated revocation logs, reads a max\n// number of `recordsPerTx` records, converts them into the new revocation logs\n// and save them to disk.",
      "length": 2120,
      "tokens": 337,
      "embedding": []
    },
    {
      "slug": "func processMigration(tx kvdb.RwTx, cfg MigrateRevLogConfig) (bool, error) {",
      "content": "func processMigration(tx kvdb.RwTx, cfg MigrateRevLogConfig) (bool, error) {\n\topenChanBucket := tx.ReadWriteBucket(openChannelBucket)\n\n\t// If no bucket is found, we can exit early.\n\tif openChanBucket == nil {\n\t\treturn false, fmt.Errorf(\"root bucket not found\")\n\t}\n\n\t// Locate the next migration height.\n\tlocator, err := locateNextUpdateNum(openChanBucket)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"locator got error: %v\", err)\n\t}\n\n\t// If the returned locator is nil, we've done migrating the logs.\n\tif locator == nil {\n\t\treturn true, nil\n\t}\n\n\t// Read a list of old revocation logs.\n\tentryMap, err := readOldRevocationLogs(openChanBucket, locator, cfg)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"read old logs err: %v\", err)\n\t}\n\n\t// Migrate the revocation logs.\n\treturn false, writeRevocationLogs(openChanBucket, entryMap)\n}\n\n// deleteOldBuckets iterates all the channel buckets and deletes the old\n// revocation buckets.",
      "length": 819,
      "tokens": 121,
      "embedding": []
    },
    {
      "slug": "func deleteOldBuckets(db kvdb.Backend) error {",
      "content": "func deleteOldBuckets(db kvdb.Backend) error {\n\t// locators records all the chan buckets found in the database.\n\tvar locators []*updateLocator\n\n\t// reader is a helper closure that saves the locator found. Each\n\t// locator is relatively small(33+32+36+8=109 bytes), assuming 1 GB of\n\t// ram we can fit roughly 10 million records. Since each record\n\t// corresponds to a channel, we should have more than enough memory to\n\t// read them all.\n\treader := func(_ kvdb.RwBucket, l *updateLocator) error { // nolint:unparam\n\t\tlocators = append(locators, l)\n\t\treturn nil\n\t}\n\n\t// remover is a helper closure that removes the old revocation log\n\t// bucket under the specified chan bucket by the given locator.\n\tremover := func(rootBucket kvdb.RwBucket, l *updateLocator) error {\n\t\tchanBucket, err := l.locateChanBucket(rootBucket)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn chanBucket.DeleteNestedBucket(\n\t\t\trevocationLogBucketDeprecated,\n\t\t)\n\t}\n\n\t// Perform the deletion in one db transaction. This should not cause\n\t// any memory issue as the deletion doesn't load any data from the\n\t// buckets.\n\treturn kvdb.Update(db, func(tx kvdb.RwTx) error {\n\t\topenChanBucket := tx.ReadWriteBucket(openChannelBucket)\n\n\t\t// Exit early if there's no bucket.\n\t\tif openChanBucket == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Iterate the buckets to find all the locators.\n\t\terr := iterateBuckets(openChanBucket, nil, reader)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Iterate the locators and delete all the old revocation log\n\t\t// buckets.\n\t\tfor _, l := range locators {\n\t\t\terr := remover(openChanBucket, l)\n\t\t\t// If the bucket doesn't exist, we can exit safety.\n\t\t\tif err != nil && err != kvdb.ErrBucketNotFound {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}, func() {})\n}\n\n// writeRevocationLogs unwraps the entryMap and writes the new revocation logs.",
      "length": 1710,
      "tokens": 267,
      "embedding": []
    },
    {
      "slug": "func writeRevocationLogs(openChanBucket kvdb.RwBucket,",
      "content": "func writeRevocationLogs(openChanBucket kvdb.RwBucket,\n\tentryMap logEntries) error {\n\n\tfor locator, logs := range entryMap {\n\t\t// Find the channel bucket.\n\t\tchanBucket, err := locator.locateChanBucket(openChanBucket)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"locateChanBucket err: %v\", err)\n\t\t}\n\n\t\t// Create the new log bucket.\n\t\tlogBucket, err := chanBucket.CreateBucketIfNotExists(\n\t\t\trevocationLogBucket,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"create log bucket err: %v\", err)\n\t\t}\n\n\t\t// Write the new logs.\n\t\tfor _, entry := range logs {\n\t\t\tvar b bytes.Buffer\n\t\t\terr := serializeRevocationLog(&b, entry.log)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tlogEntrykey := mig24.MakeLogKey(entry.commitHeight)\n\t\t\terr = logBucket.Put(logEntrykey[:], b.Bytes())\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"putRevocationLog err: %v\",\n\t\t\t\t\terr)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// logMigrationStat reads the buckets to provide stats over current migration\n// progress. The returned values are the numbers of total records and already\n// migrated records.",
      "length": 948,
      "tokens": 133,
      "embedding": []
    },
    {
      "slug": "func logMigrationStat(db kvdb.Backend) (uint64, uint64, error) {",
      "content": "func logMigrationStat(db kvdb.Backend) (uint64, uint64, error) {\n\tvar (\n\t\terr error\n\n\t\t// total is the number of total records.\n\t\ttotal uint64\n\n\t\t// unmigrated is the number of unmigrated records.\n\t\tunmigrated uint64\n\t)\n\n\terr = kvdb.Update(db, func(tx kvdb.RwTx) error {\n\t\ttotal, unmigrated, err = fetchLogStats(tx)\n\t\treturn err\n\t}, func() {})\n\n\tlog.Debugf(\"Total logs=%d, unmigrated=%d\", total, unmigrated)\n\treturn total, total - unmigrated, err\n}\n\n// fetchLogStats iterates all the chan buckets to provide stats about the logs.\n// The returned values are num of total records, and num of un-migrated\n// records.",
      "length": 527,
      "tokens": 82,
      "embedding": []
    },
    {
      "slug": "func fetchLogStats(tx kvdb.RwTx) (uint64, uint64, error) {",
      "content": "func fetchLogStats(tx kvdb.RwTx) (uint64, uint64, error) {\n\tvar (\n\t\ttotal           uint64\n\t\ttotalUnmigrated uint64\n\t)\n\n\topenChanBucket := tx.ReadWriteBucket(openChannelBucket)\n\n\t// If no bucket is found, we can exit early.\n\tif openChanBucket == nil {\n\t\treturn 0, 0, fmt.Errorf(\"root bucket not found\")\n\t}\n\n\t// counter is a helper closure used to count the number of records\n\t// based on the given bucket.\n\tcounter := func(chanBucket kvdb.RwBucket, bucket []byte) uint64 {\n\t\t// Read the sub-bucket level 4.\n\t\tlogBucket := chanBucket.NestedReadBucket(bucket)\n\n\t\t// Exit early if we don't have the bucket.\n\t\tif logBucket == nil {\n\t\t\treturn 0\n\t\t}\n\n\t\t// Jump to the end of the cursor.\n\t\tkey, _ := logBucket.ReadCursor().Last()\n\n\t\t// Since the CommitHeight is a zero-based monotonically\n\t\t// increased index, its value plus one reflects the total\n\t\t// records under this chan bucket.\n\t\tlastHeight := binary.BigEndian.Uint64(key) + 1\n\n\t\treturn lastHeight\n\t}\n\n\t// countTotal is a callback function used to count the total number of\n\t// records.\n\tcountTotal := func(chanBucket kvdb.RwBucket, l *updateLocator) error {\n\t\ttotal += counter(chanBucket, revocationLogBucketDeprecated)\n\t\treturn nil\n\t}\n\n\t// countUnmigrated is a callback function used to count the total\n\t// number of un-migrated records.\n\tcountUnmigrated := func(chanBucket kvdb.RwBucket,\n\t\tl *updateLocator) error {\n\n\t\ttotalUnmigrated += counter(\n\t\t\tchanBucket, revocationLogBucketDeprecated,\n\t\t)\n\t\treturn nil\n\t}\n\n\t// Locate the next migration height.\n\tlocator, err := locateNextUpdateNum(openChanBucket)\n\tif err != nil {\n\t\treturn 0, 0, fmt.Errorf(\"locator got error: %v\", err)\n\t}\n\n\t// If the returned locator is not nil, we still have un-migrated\n\t// records so we need to count them. Otherwise we've done migrating the\n\t// logs.\n\tif locator != nil {\n\t\terr = iterateBuckets(openChanBucket, locator, countUnmigrated)\n\t\tif err != nil {\n\t\t\treturn 0, 0, err\n\t\t}\n\t}\n\n\t// Count the total number of records by supplying a nil locator.\n\terr = iterateBuckets(openChanBucket, nil, countTotal)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\treturn total, totalUnmigrated, err\n}\n\n// logEntry houses the info needed to write a new revocation log.",
      "length": 2046,
      "tokens": 309,
      "embedding": []
    },
    {
      "slug": "type logEntry struct {",
      "content": "type logEntry struct {\n\tlog          *RevocationLog\n\tcommitHeight uint64\n\tourIndex     uint32\n\ttheirIndex   uint32\n\tlocator      *updateLocator\n}\n\n// logEntries maps a bucket locator to a list of entries under that bucket.",
      "length": 192,
      "tokens": 25,
      "embedding": []
    },
    {
      "slug": "type logEntries map[*updateLocator][]*logEntry",
      "content": "type logEntries map[*updateLocator][]*logEntry\n\n// result is made of two channels that's used to send back the constructed new\n// revocation log or an error.",
      "length": 108,
      "tokens": 21,
      "embedding": []
    },
    {
      "slug": "type result struct {",
      "content": "type result struct {\n\tnewLog  chan *logEntry\n\terrChan chan error\n}\n\n// readOldRevocationLogs finds a list of old revocation logs and converts them\n// into the new revocation logs.",
      "length": 153,
      "tokens": 25,
      "embedding": []
    },
    {
      "slug": "func readOldRevocationLogs(openChanBucket kvdb.RwBucket,",
      "content": "func readOldRevocationLogs(openChanBucket kvdb.RwBucket,\n\tlocator *updateLocator, cfg MigrateRevLogConfig) (logEntries, error) {\n\n\tentries := make(logEntries)\n\tresults := make([]*result, 0)\n\n\tvar wg sync.WaitGroup\n\n\t// collectLogs is a helper closure that reads all newly created\n\t// revocation logs sent over the result channels.\n\t//\n\t// NOTE: the order of the logs cannot be guaranteed, which is fine as\n\t// boltdb will take care of the orders when saving them.\n\tcollectLogs := func() error {\n\t\twg.Wait()\n\n\t\tfor _, r := range results {\n\t\t\tselect {\n\t\t\tcase entry := <-r.newLog:\n\t\t\t\tentries[entry.locator] = append(\n\t\t\t\t\tentries[entry.locator], entry,\n\t\t\t\t)\n\n\t\t\tcase err := <-r.errChan:\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}\n\n\t// createLog is a helper closure that constructs a new revocation log.\n\t//\n\t// NOTE: used as a goroutine.\n\tcreateLog := func(chanState *mig26.OpenChannel,\n\t\tc mig.ChannelCommitment, l *updateLocator, r *result) {\n\n\t\tdefer wg.Done()\n\n\t\t// Find the output indexes.\n\t\tourIndex, theirIndex, err := findOutputIndexes(chanState, &c)\n\t\tif err != nil {\n\t\t\tr.errChan <- err\n\t\t}\n\n\t\t// Convert the old logs into the new logs. We do this early in\n\t\t// the read tx so the old large revocation log can be set to\n\t\t// nil here so save us some memory space.\n\t\tnewLog, err := convertRevocationLog(\n\t\t\t&c, ourIndex, theirIndex, cfg.GetNoAmountData(),\n\t\t)\n\t\tif err != nil {\n\t\t\tr.errChan <- err\n\t\t}\n\t\t// Create the entry that will be used to create the new log.\n\t\tentry := &logEntry{\n\t\t\tlog:          newLog,\n\t\t\tcommitHeight: c.CommitHeight,\n\t\t\tourIndex:     ourIndex,\n\t\t\ttheirIndex:   theirIndex,\n\t\t\tlocator:      l,\n\t\t}\n\n\t\tr.newLog <- entry\n\t}\n\n\t// innerCb is the stepping function used when iterating the old log\n\t// bucket.\n\tinnerCb := func(chanState *mig26.OpenChannel, l *updateLocator,\n\t\t_, v []byte) error {\n\n\t\treader := bytes.NewReader(v)\n\t\tc, err := mig.DeserializeChanCommit(reader)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tr := &result{\n\t\t\tnewLog:  make(chan *logEntry, 1),\n\t\t\terrChan: make(chan error, 1),\n\t\t}\n\t\tresults = append(results, r)\n\n\t\t// We perform the log creation in a goroutine as it takes some\n\t\t// time to compute and find output indexes.\n\t\twg.Add(1)\n\t\tgo createLog(chanState, c, l, r)\n\n\t\t// Check the records read so far and signals exit when we've\n\t\t// reached our memory cap.\n\t\tif len(results) >= recordsPerTx {\n\t\t\treturn errExit\n\t\t}\n\n\t\treturn nil\n\t}\n\n\t// cb is the callback function to be used when iterating the buckets.\n\tcb := func(chanBucket kvdb.RwBucket, l *updateLocator) error {\n\t\t// Read the open channel.\n\t\tc := &mig26.OpenChannel{}\n\t\terr := mig26.FetchChanInfo(chanBucket, c, false)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to fetch chan info: %v\", err)\n\t\t}\n\n\t\terr = fetchChanRevocationState(chanBucket, c)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to fetch revocation \"+\n\t\t\t\t\"state: %v\", err)\n\t\t}\n\n\t\t// Read the sub-bucket level 4.\n\t\tlogBucket := chanBucket.NestedReadBucket(\n\t\t\trevocationLogBucketDeprecated,\n\t\t)\n\t\t// Exit early if we don't have the old bucket.\n\t\tif logBucket == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Init the map key when needed.\n\t\t_, ok := entries[l]\n\t\tif !ok {\n\t\t\tentries[l] = make([]*logEntry, 0, recordsPerTx)\n\t\t}\n\n\t\treturn iterator(\n\t\t\tlogBucket, locator.nextHeight,\n\t\t\tfunc(k, v []byte) error {\n\t\t\t\t// Reset the nextHeight for following chan\n\t\t\t\t// buckets.\n\t\t\t\tlocator.nextHeight = nil\n\t\t\t\treturn innerCb(c, l, k, v)\n\t\t\t},\n\t\t)\n\t}\n\n\terr := iterateBuckets(openChanBucket, locator, cb)\n\t// If there's an error and it's not exit signal, we won't collect the\n\t// logs from the result channels.\n\tif err != nil && err != errExit {\n\t\treturn nil, err\n\t}\n\n\t// Otherwise, collect the logs.\n\terr = collectLogs()\n\n\treturn entries, err\n}\n\n// convertRevocationLog uses the fields `CommitTx` and `Htlcs` from a\n// ChannelCommitment to construct a revocation log entry.",
      "length": 3623,
      "tokens": 560,
      "embedding": []
    },
    {
      "slug": "func convertRevocationLog(commit *mig.ChannelCommitment,",
      "content": "func convertRevocationLog(commit *mig.ChannelCommitment,\n\tourOutputIndex, theirOutputIndex uint32,\n\tnoAmtData bool) (*RevocationLog, error) {\n\n\t// Sanity check that the output indexes can be safely converted.\n\tif ourOutputIndex > math.MaxUint16 {\n\t\treturn nil, ErrOutputIndexTooBig\n\t}\n\tif theirOutputIndex > math.MaxUint16 {\n\t\treturn nil, ErrOutputIndexTooBig\n\t}\n\n\trl := &RevocationLog{\n\t\tOurOutputIndex:   uint16(ourOutputIndex),\n\t\tTheirOutputIndex: uint16(theirOutputIndex),\n\t\tCommitTxHash:     commit.CommitTx.TxHash(),\n\t\tHTLCEntries:      make([]*HTLCEntry, 0, len(commit.Htlcs)),\n\t}\n\n\tif !noAmtData {\n\t\trl.TheirBalance = &commit.RemoteBalance\n\t\trl.OurBalance = &commit.LocalBalance\n\t}\n\n\tfor _, htlc := range commit.Htlcs {\n\t\t// Skip dust HTLCs.\n\t\tif htlc.OutputIndex < 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Sanity check that the output indexes can be safely\n\t\t// converted.\n\t\tif htlc.OutputIndex > math.MaxUint16 {\n\t\t\treturn nil, ErrOutputIndexTooBig\n\t\t}\n\n\t\tentry := &HTLCEntry{\n\t\t\tRHash:         htlc.RHash,\n\t\t\tRefundTimeout: htlc.RefundTimeout,\n\t\t\tIncoming:      htlc.Incoming,\n\t\t\tOutputIndex:   uint16(htlc.OutputIndex),\n\t\t\tAmt:           htlc.Amt.ToSatoshis(),\n\t\t}\n\t\trl.HTLCEntries = append(rl.HTLCEntries, entry)\n\t}\n\n\treturn rl, nil\n}\n\n// validateMigration checks that the data saved in the new buckets match those\n// saved in the old buckets. It does so by checking the last keys saved in both\n// buckets can match, given the assumption that the `CommitHeight` is\n// monotonically increased value so the last key represents the total number of\n// records saved.",
      "length": 1451,
      "tokens": 180,
      "embedding": []
    },
    {
      "slug": "func validateMigration(tx kvdb.RwTx) error {",
      "content": "func validateMigration(tx kvdb.RwTx) error {\n\topenChanBucket := tx.ReadWriteBucket(openChannelBucket)\n\n\t// If no bucket is found, we can exit early.\n\tif openChanBucket == nil {\n\t\treturn nil\n\t}\n\n\t// exitWithErr is a helper closure that prepends an error message with\n\t// the locator info.\n\texitWithErr := func(l *updateLocator, msg string) error {\n\t\treturn fmt.Errorf(\"unmatched records found under <nodePub=%x\"+\n\t\t\t\", chainHash=%x, fundingOutpoint=%x>: %v\", l.nodePub,\n\t\t\tl.chainHash, l.fundingOutpoint, msg)\n\t}\n\n\t// cb is the callback function to be used when iterating the buckets.\n\tcb := func(chanBucket kvdb.RwBucket, l *updateLocator) error {\n\t\t// Read both the old and new revocation log buckets.\n\t\toldBucket := chanBucket.NestedReadBucket(\n\t\t\trevocationLogBucketDeprecated,\n\t\t)\n\t\tnewBucket := chanBucket.NestedReadBucket(revocationLogBucket)\n\n\t\t// Exit early if the old bucket is nil.\n\t\t//\n\t\t// NOTE: the new bucket may not be nil here as new logs might\n\t\t// have been created using lnd@v0.15.0.\n\t\tif oldBucket == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Return an error if the expected new bucket cannot be found.\n\t\tif newBucket == nil {\n\t\t\treturn exitWithErr(l, \"expected new bucket\")\n\t\t}\n\n\t\t// Acquire the cursors.\n\t\toldCursor := oldBucket.ReadCursor()\n\t\tnewCursor := newBucket.ReadCursor()\n\n\t\t// Jump to the end of the cursors to do a quick check.\n\t\tnewKey, _ := oldCursor.Last()\n\t\toldKey, _ := newCursor.Last()\n\n\t\t// We expected the CommitHeights to be matched for nodes prior\n\t\t// to v0.15.0.\n\t\tif bytes.Equal(newKey, oldKey) {\n\t\t\treturn nil\n\t\t}\n\n\t\t// If the keys do not match, it's likely the node is running\n\t\t// v0.15.0 and have new logs created. In this case, we will\n\t\t// validate that every record in the old bucket can be found in\n\t\t// the new bucket.\n\t\toldKey, _ = oldCursor.First()\n\n\t\tfor {\n\t\t\t// Try to locate the old key in the new bucket and we\n\t\t\t// expect it to be found.\n\t\t\tnewKey, _ := newCursor.Seek(oldKey)\n\n\t\t\t// If the old key is not found in the new bucket,\n\t\t\t// return an error.\n\t\t\t//\n\t\t\t// NOTE: because Seek will return the next key when the\n\t\t\t// passed key cannot be found, we need to compare the\n\t\t\t// keys to deicde whether the old key is found or not.\n\t\t\tif !bytes.Equal(newKey, oldKey) {\n\t\t\t\terrMsg := fmt.Sprintf(\"old bucket has \"+\n\t\t\t\t\t\"CommitHeight=%v cannot be found in \"+\n\t\t\t\t\t\"new bucket\", oldKey)\n\t\t\t\treturn exitWithErr(l, errMsg)\n\t\t\t}\n\n\t\t\t// Otherwise, keep iterating the old bucket.\n\t\t\toldKey, _ = oldCursor.Next()\n\n\t\t\t// If we've done iterating, all keys have been matched\n\t\t\t// and we can safely exit.\n\t\t\tif oldKey == nil {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn iterateBuckets(openChanBucket, nil, cb)\n}\n",
      "length": 2514,
      "tokens": 399,
      "embedding": []
    }
  ]
}