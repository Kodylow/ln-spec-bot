{
  "filepath": "../implementations/go/lnd/channeldb/migration30/iterator_test.go",
  "package": "migration30",
  "sections": [
    {
      "slug": "func TestLocateChanBucket(t *testing.T) {",
      "content": "func TestLocateChanBucket(t *testing.T) {\n\tt.Parallel()\n\n\t// Create test database.\n\tcdb, err := migtest.MakeDB(t)\n\trequire.NoError(t, err)\n\n\t// Create a test channel.\n\tc := createTestChannel(nil)\n\n\tvar buf bytes.Buffer\n\trequire.NoError(t, mig.WriteOutpoint(&buf, &c.FundingOutpoint))\n\n\t// Prepare the info needed to query the bucket.\n\tnodePub := c.IdentityPub.SerializeCompressed()\n\tchainHash := c.ChainHash[:]\n\tcp := buf.Bytes()\n\n\t// Create test buckets.\n\terr = kvdb.Update(cdb, func(tx kvdb.RwTx) error {\n\t\t_, err := mig25.CreateChanBucket(tx, &c.OpenChannel)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}, func() {})\n\trequire.NoError(t, err)\n\n\t// testLocator is a helper closure that tests a given locator's\n\t// locateChanBucket method.\n\ttestLocator := func(l *updateLocator) error {\n\t\treturn kvdb.Update(cdb, func(tx kvdb.RwTx) error {\n\t\t\trootBucket := tx.ReadWriteBucket(openChannelBucket)\n\t\t\t_, err := l.locateChanBucket(rootBucket)\n\t\t\treturn err\n\t\t}, func() {})\n\t}\n\n\ttestCases := []struct {\n\t\tname        string\n\t\tlocator     *updateLocator\n\t\texpectedErr error\n\t}{\n\t\t{\n\t\t\tname:        \"empty node pub key\",\n\t\t\tlocator:     &updateLocator{},\n\t\t\texpectedErr: mig25.ErrNoActiveChannels,\n\t\t},\n\t\t{\n\t\t\tname: \"empty chainhash\",\n\t\t\tlocator: &updateLocator{\n\t\t\t\tnodePub: nodePub,\n\t\t\t},\n\t\t\texpectedErr: mig25.ErrNoActiveChannels,\n\t\t},\n\t\t{\n\t\t\tname: \"empty funding outpoint\",\n\t\t\tlocator: &updateLocator{\n\t\t\t\tnodePub:   nodePub,\n\t\t\t\tchainHash: chainHash,\n\t\t\t},\n\t\t\texpectedErr: mig25.ErrChannelNotFound,\n\t\t},\n\t\t{\n\t\t\tname: \"successful query\",\n\t\t\tlocator: &updateLocator{\n\t\t\t\tnodePub:         nodePub,\n\t\t\t\tchainHash:       chainHash,\n\t\t\t\tfundingOutpoint: cp,\n\t\t\t},\n\t\t\texpectedErr: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\terr := testLocator(tc.locator)\n\t\t\trequire.Equal(t, tc.expectedErr, err)\n\t\t})\n\t}\n}\n\n// TestFindNextMigrateHeight checks that given a channel bucket, we can\n// successfully find the next un-migrated commit height.",
      "length": 1862,
      "tokens": 220,
      "embedding": []
    },
    {
      "slug": "func TestFindNextMigrateHeight(t *testing.T) {",
      "content": "func TestFindNextMigrateHeight(t *testing.T) {\n\tt.Parallel()\n\n\t// Create test database.\n\tcdb, err := migtest.MakeDB(t)\n\trequire.NoError(t, err)\n\n\t// tester is a helper closure that finds the next migration height.\n\ttester := func(c *mig26.OpenChannel) []byte {\n\t\tvar height []byte\n\t\terr := kvdb.Update(cdb, func(tx kvdb.RwTx) error {\n\t\t\tchanBucket, err := mig25.FetchChanBucket(\n\t\t\t\ttx, &c.OpenChannel,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\theight = findNextMigrateHeight(chanBucket)\n\t\t\treturn nil\n\t\t}, func() {})\n\t\trequire.NoError(t, err)\n\n\t\treturn height\n\t}\n\n\ttestCases := []struct {\n\t\tname           string\n\t\toldLogs        []mig.ChannelCommitment\n\t\tnewLogs        []mig.ChannelCommitment\n\t\texpectedHeight []byte\n\t}{\n\t\t{\n\t\t\t// When we don't have any old logs, our next migration\n\t\t\t// height would be nil.\n\t\t\tname:           \"empty old logs\",\n\t\t\texpectedHeight: nil,\n\t\t},\n\t\t{\n\t\t\t// When we don't have any migrated logs, our next\n\t\t\t// migration height would be the first height found in\n\t\t\t// the old logs.\n\t\t\tname: \"empty migrated logs\",\n\t\t\toldLogs: []mig.ChannelCommitment{\n\t\t\t\tcreateDummyChannelCommit(1),\n\t\t\t\tcreateDummyChannelCommit(2),\n\t\t\t},\n\t\t\texpectedHeight: []byte{0, 0, 0, 0, 0, 0, 0, 1},\n\t\t},\n\t\t{\n\t\t\t// When we have migrated logs, the next migration\n\t\t\t// height should be the first height found in the old\n\t\t\t// logs but not in the migrated logs.\n\t\t\tname: \"have migrated logs\",\n\t\t\toldLogs: []mig.ChannelCommitment{\n\t\t\t\tcreateDummyChannelCommit(1),\n\t\t\t\tcreateDummyChannelCommit(2),\n\t\t\t},\n\t\t\tnewLogs: []mig.ChannelCommitment{\n\t\t\t\tcreateDummyChannelCommit(1),\n\t\t\t},\n\t\t\texpectedHeight: []byte{0, 0, 0, 0, 0, 0, 0, 2},\n\t\t},\n\t\t{\n\t\t\t// When both the logs have equal indexes, the next\n\t\t\t// migration should be nil as we've finished migrating\n\t\t\t// for this bucket.\n\t\t\tname: \"have finished logs\",\n\t\t\toldLogs: []mig.ChannelCommitment{\n\t\t\t\tcreateDummyChannelCommit(1),\n\t\t\t\tcreateDummyChannelCommit(2),\n\t\t\t},\n\t\t\tnewLogs: []mig.ChannelCommitment{\n\t\t\t\tcreateDummyChannelCommit(1),\n\t\t\t\tcreateDummyChannelCommit(2),\n\t\t\t},\n\t\t\texpectedHeight: nil,\n\t\t},\n\t\t{\n\t\t\t// When there are new logs saved in the new bucket,\n\t\t\t// which happens when the node is running with\n\t\t\t// v.0.15.0, and we don't have any migrated logs, the\n\t\t\t// next migration height should be the first height\n\t\t\t// found in the old bucket.\n\t\t\tname: \"have new logs but no migrated logs\",\n\t\t\toldLogs: []mig.ChannelCommitment{\n\t\t\t\tcreateDummyChannelCommit(1),\n\t\t\t\tcreateDummyChannelCommit(2),\n\t\t\t},\n\t\t\tnewLogs: []mig.ChannelCommitment{\n\t\t\t\tcreateDummyChannelCommit(3),\n\t\t\t\tcreateDummyChannelCommit(4),\n\t\t\t},\n\t\t\texpectedHeight: []byte{0, 0, 0, 0, 0, 0, 0, 1},\n\t\t},\n\t\t{\n\t\t\t// When there are new logs saved in the new bucket,\n\t\t\t// which happens when the node is running with\n\t\t\t// v.0.15.0, and we have migrated logs, the returned\n\t\t\t// value should be the next un-migrated height.\n\t\t\tname: \"have new logs and migrated logs\",\n\t\t\toldLogs: []mig.ChannelCommitment{\n\t\t\t\tcreateDummyChannelCommit(1),\n\t\t\t\tcreateDummyChannelCommit(2),\n\t\t\t},\n\t\t\tnewLogs: []mig.ChannelCommitment{\n\t\t\t\tcreateDummyChannelCommit(1),\n\t\t\t\tcreateDummyChannelCommit(3),\n\t\t\t\tcreateDummyChannelCommit(4),\n\t\t\t},\n\t\t\texpectedHeight: []byte{0, 0, 0, 0, 0, 0, 0, 2},\n\t\t},\n\t\t{\n\t\t\t// When there are new logs saved in the new bucket,\n\t\t\t// which happens when the node is running with\n\t\t\t// v.0.15.0, and we have corrupted logs, the returned\n\t\t\t// value should be the first height in the old bucket.\n\t\t\tname: \"have new logs but missing logs\",\n\t\t\toldLogs: []mig.ChannelCommitment{\n\t\t\t\tcreateDummyChannelCommit(1),\n\t\t\t\tcreateDummyChannelCommit(2),\n\t\t\t},\n\t\t\tnewLogs: []mig.ChannelCommitment{\n\t\t\t\tcreateDummyChannelCommit(2),\n\t\t\t\tcreateDummyChannelCommit(3),\n\t\t\t\tcreateDummyChannelCommit(4),\n\t\t\t},\n\t\t\texpectedHeight: []byte{0, 0, 0, 0, 0, 0, 0, 1},\n\t\t},\n\t\t{\n\t\t\t// When there are new logs saved in the new bucket,\n\t\t\t// which happens when the node is running with\n\t\t\t// v.0.15.0, and we have finished the migration, we\n\t\t\t// expect a nil height to be returned.\n\t\t\tname: \"have new logs and finished logs\",\n\t\t\toldLogs: []mig.ChannelCommitment{\n\t\t\t\tcreateDummyChannelCommit(1),\n\t\t\t\tcreateDummyChannelCommit(2),\n\t\t\t},\n\t\t\tnewLogs: []mig.ChannelCommitment{\n\t\t\t\tcreateDummyChannelCommit(1),\n\t\t\t\tcreateDummyChannelCommit(2),\n\t\t\t\tcreateDummyChannelCommit(3),\n\t\t\t\tcreateDummyChannelCommit(4),\n\t\t\t},\n\t\t\texpectedHeight: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Create a test channel.\n\t\t\tc := createTestChannel(nil)\n\n\t\t\t// Setup the database.\n\t\t\terr := setupTestLogs(cdb, c, tc.oldLogs, tc.newLogs)\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// Run the test and check the expected next migration\n\t\t\t// height is returned.\n\t\t\theight := tester(c)\n\t\t\trequire.Equal(t, tc.expectedHeight, height)\n\t\t})\n\t}\n}\n\n// TestIterator checks that the iterator iterate the given bucket correctly.",
      "length": 4621,
      "tokens": 579,
      "embedding": []
    },
    {
      "slug": "func TestIterator(t *testing.T) {",
      "content": "func TestIterator(t *testing.T) {\n\tt.Parallel()\n\n\t// Create test database.\n\tcdb, err := migtest.MakeDB(t)\n\trequire.NoError(t, err)\n\n\t// exitKey is used to signal exit when hitting this key.\n\texitKey := []byte{1}\n\n\t// seekKey is used to position the cursor.\n\tseekKey := []byte{2}\n\n\t// endKey is the last key saved in the test bucket.\n\tendKey := []byte{3}\n\n\t// Create test bucket.\n\tbucketName := []byte(\"test-bucket\")\n\terr = kvdb.Update(cdb, func(tx kvdb.RwTx) error {\n\t\tbucket, err := tx.CreateTopLevelBucket(bucketName)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := bucket.Put(exitKey, testRHash); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := bucket.Put(seekKey, testRHash); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn bucket.Put(endKey, testRHash)\n\t}, func() {})\n\trequire.NoError(t, err)\n\n\t// tester is a helper closure that tests the iterator.\n\ttester := func(seeker []byte, cb callback, expectedErr error) {\n\t\terr := kvdb.View(cdb, func(tx kvdb.RTx) error {\n\t\t\tbucket := tx.ReadBucket(bucketName)\n\t\t\treturn iterator(bucket, seeker, cb)\n\t\t}, func() {})\n\n\t\t// Check the err is returned as expected.\n\t\trequire.Equal(t, expectedErr, err)\n\t}\n\n\t// keysItered records the keys have been iterated.\n\tkeysItered := make([][]byte, 0)\n\n\t// testCb creates a dummy callback that saves the keys it have\n\t// iterated.\n\ttestCb := func(k, v []byte) error {\n\t\tkeysItered = append(keysItered, k)\n\t\tif bytes.Equal(k, exitKey) {\n\t\t\treturn errExit\n\t\t}\n\t\treturn nil\n\t}\n\n\t// Test that without a seeker, we would iterate from the beginning,\n\t// which will end up iterating only one key since we would exit on it.\n\ttester(nil, testCb, errExit)\n\trequire.Equal(t, [][]byte{exitKey}, keysItered)\n\n\t// Reset the keys.\n\tkeysItered = make([][]byte, 0)\n\n\t// Now test that when we use a seeker, we would start our iteration at\n\t// the seeker posisiton. This means we won't exit it early since we've\n\t// skipped the exitKey.\n\ttester(seekKey, testCb, nil)\n\trequire.Equal(t, [][]byte{seekKey, endKey}, keysItered)\n}\n\n// TestIterateBuckets checks that we can successfully iterate the buckets and\n// update the locator during the iteration.",
      "length": 1993,
      "tokens": 302,
      "embedding": []
    },
    {
      "slug": "func TestIterateBuckets(t *testing.T) {",
      "content": "func TestIterateBuckets(t *testing.T) {\n\tt.Parallel()\n\n\t// Create test database.\n\tcdb, err := migtest.MakeDB(t)\n\trequire.NoError(t, err)\n\n\t// Create three test channels.\n\tc1 := createTestChannel(nil)\n\tc2 := createTestChannel(nil)\n\tc3 := createTestChannel(nil)\n\n\t// Create test buckets.\n\terr = kvdb.Update(cdb, func(tx kvdb.RwTx) error {\n\t\t_, err := mig25.CreateChanBucket(tx, &c1.OpenChannel)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t_, err = mig25.CreateChanBucket(tx, &c2.OpenChannel)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t_, err = mig25.CreateChanBucket(tx, &c3.OpenChannel)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn nil\n\t}, func() {})\n\trequire.NoError(t, err)\n\n\t// testCb creates a dummy callback that saves the locator it received.\n\tlocators := make([]*updateLocator, 0)\n\ttestCb := func(_ kvdb.RwBucket, l *updateLocator) error { // nolint:unparam\n\t\tlocators = append(locators, l)\n\t\treturn nil\n\t}\n\n\t// Iterate the buckets with a nil locator.\n\terr = kvdb.Update(cdb, func(tx kvdb.RwTx) error {\n\t\tbucket := tx.ReadWriteBucket(openChannelBucket)\n\t\treturn iterateBuckets(bucket, nil, testCb)\n\t}, func() {})\n\trequire.NoError(t, err)\n\n\t// We should see three locators.\n\trequire.Len(t, locators, 3)\n\n\t// We now test we can iterate the buckets using a locator.\n\t//\n\t// Copy the locator which points to the second channel.\n\tlocator := &updateLocator{\n\t\tnodePub:         locators[1].nodePub,\n\t\tchainHash:       locators[1].chainHash,\n\t\tfundingOutpoint: locators[1].fundingOutpoint,\n\t}\n\n\t// Reset the locators.\n\tlocators = make([]*updateLocator, 0)\n\n\t// Iterate the buckets with a locator.\n\terr = kvdb.Update(cdb, func(tx kvdb.RwTx) error {\n\t\tbucket := tx.ReadWriteBucket(openChannelBucket)\n\t\treturn iterateBuckets(bucket, locator, testCb)\n\t}, func() {})\n\trequire.NoError(t, err)\n\n\t// We should see two locators.\n\trequire.Len(t, locators, 2)\n}\n\n// TestLocalNextUpdateNum checks that we can successfully locate the next\n// migration target record.",
      "length": 1830,
      "tokens": 242,
      "embedding": []
    },
    {
      "slug": "func TestLocalNextUpdateNum(t *testing.T) {",
      "content": "func TestLocalNextUpdateNum(t *testing.T) {\n\tt.Parallel()\n\n\t// assertLocator checks the locator has expected values in its fields.\n\tassertLocator := func(t *testing.T, c *mig26.OpenChannel,\n\t\theight []byte, l *updateLocator) {\n\n\t\tvar buf bytes.Buffer\n\t\trequire.NoError(\n\t\t\tt, mig.WriteOutpoint(&buf, &c.FundingOutpoint),\n\t\t)\n\n\t\t// Prepare the info needed to validate the locator.\n\t\tnodePub := c.IdentityPub.SerializeCompressed()\n\t\tchainHash := c.ChainHash[:]\n\t\tcp := buf.Bytes()\n\n\t\trequire.Equal(t, nodePub, l.nodePub, \"wrong nodePub\")\n\t\trequire.Equal(t, chainHash, l.chainHash, \"wrong chainhash\")\n\t\trequire.Equal(t, cp, l.fundingOutpoint, \"wrong outpoint\")\n\t\trequire.Equal(t, height, l.nextHeight, \"wrong nextHeight\")\n\t}\n\n\t// createTwoChannels is a helper closure that creates two testing\n\t// channels and returns the channels sorted by their nodePub to match\n\t// how they are stored in boltdb.\n\tcreateTwoChannels := func() (*mig26.OpenChannel, *mig26.OpenChannel) {\n\t\tc1 := createTestChannel(nil)\n\t\tc2 := createTestChannel(nil)\n\n\t\t// If c1 is greater than c2, boltdb will put c2 before c1.\n\t\tif bytes.Compare(\n\t\t\tc1.IdentityPub.SerializeCompressed(),\n\t\t\tc2.IdentityPub.SerializeCompressed(),\n\t\t) > 0 {\n\n\t\t\tc1, c2 = c2, c1\n\t\t}\n\n\t\treturn c1, c2\n\t}\n\n\t// createNotFinished will setup a situation where we have un-migrated\n\t// logs and return the next migration height.\n\tcreateNotFinished := func(cdb kvdb.Backend,\n\t\tc *mig26.OpenChannel) []byte {\n\n\t\t// Create test logs.\n\t\toldLogs := []mig.ChannelCommitment{\n\t\t\tcreateDummyChannelCommit(1),\n\t\t\tcreateDummyChannelCommit(2),\n\t\t}\n\t\tnewLogs := []mig.ChannelCommitment{\n\t\t\tcreateDummyChannelCommit(1),\n\t\t}\n\t\terr := setupTestLogs(cdb, c, oldLogs, newLogs)\n\t\trequire.NoError(t, err)\n\n\t\treturn []byte{0, 0, 0, 0, 0, 0, 0, 2}\n\t}\n\n\t// createFinished will setup a situation where all the old logs have\n\t// been migrated and return a nil.\n\tcreateFinished := func(cdb kvdb.Backend, c *mig26.OpenChannel) []byte { // nolint:unparam\n\t\t// Create test logs.\n\t\toldLogs := []mig.ChannelCommitment{\n\t\t\tcreateDummyChannelCommit(1),\n\t\t\tcreateDummyChannelCommit(2),\n\t\t}\n\t\tnewLogs := []mig.ChannelCommitment{\n\t\t\tcreateDummyChannelCommit(1),\n\t\t\tcreateDummyChannelCommit(2),\n\t\t}\n\t\terr := setupTestLogs(cdb, c, oldLogs, newLogs)\n\t\trequire.NoError(t, err)\n\n\t\treturn nil\n\t}\n\n\t// emptyChannel builds a test case where no channel buckets exist.\n\temptyChannel := func(cdb kvdb.Backend) (\n\t\t*mig26.OpenChannel, []byte) {\n\n\t\t// Create the root bucket.\n\t\terr := setupTestLogs(cdb, nil, nil, nil)\n\t\trequire.NoError(t, err)\n\n\t\treturn nil, nil\n\t}\n\n\t// singleChannelNoLogs builds a test case where we have a single\n\t// channel without any revocation logs.\n\tsingleChannelNoLogs := func(cdb kvdb.Backend) (\n\t\t*mig26.OpenChannel, []byte) {\n\n\t\t// Create a test channel.\n\t\tc := createTestChannel(nil)\n\n\t\t// Create test logs.\n\t\terr := setupTestLogs(cdb, c, nil, nil)\n\t\trequire.NoError(t, err)\n\n\t\treturn c, nil\n\t}\n\n\t// singleChannelNotFinished builds a test case where we have a single\n\t// channel and have unfinished old logs.\n\tsingleChannelNotFinished := func(cdb kvdb.Backend) (\n\t\t*mig26.OpenChannel, []byte) {\n\n\t\tc := createTestChannel(nil)\n\t\treturn c, createNotFinished(cdb, c)\n\t}\n\n\t// singleChannelFinished builds a test where we have a single channel\n\t// and have finished all the migration.\n\tsingleChannelFinished := func(cdb kvdb.Backend) (\n\t\t*mig26.OpenChannel, []byte) {\n\n\t\tc := createTestChannel(nil)\n\t\treturn c, createFinished(cdb, c)\n\t}\n\n\t// twoChannelsNotFinished builds a test case where we have two channels\n\t// and have unfinished old logs.\n\ttwoChannelsNotFinished := func(cdb kvdb.Backend) (\n\t\t*mig26.OpenChannel, []byte) {\n\n\t\tc1, c2 := createTwoChannels()\n\t\tcreateFinished(cdb, c1)\n\t\treturn c2, createNotFinished(cdb, c2)\n\t}\n\n\t// twoChannelsFinished builds a test case where we have two channels\n\t// and have finished the migration.\n\ttwoChannelsFinished := func(cdb kvdb.Backend) (\n\t\t*mig26.OpenChannel, []byte) {\n\n\t\tc1, c2 := createTwoChannels()\n\t\tcreateFinished(cdb, c1)\n\t\treturn c2, createFinished(cdb, c2)\n\t}\n\n\ttype setupFunc func(cdb kvdb.Backend) (*mig26.OpenChannel, []byte)\n\n\ttestCases := []struct {\n\t\tname         string\n\t\tsetup        setupFunc\n\t\texpectFinish bool\n\t}{\n\t\t{\n\t\t\tname:         \"empty buckets\",\n\t\t\tsetup:        emptyChannel,\n\t\t\texpectFinish: true,\n\t\t},\n\t\t{\n\t\t\tname:         \"single channel no logs\",\n\t\t\tsetup:        singleChannelNoLogs,\n\t\t\texpectFinish: true,\n\t\t},\n\t\t{\n\t\t\tname:         \"single channel not finished\",\n\t\t\tsetup:        singleChannelNotFinished,\n\t\t\texpectFinish: false,\n\t\t},\n\t\t{\n\t\t\tname:         \"single channel finished\",\n\t\t\tsetup:        singleChannelFinished,\n\t\t\texpectFinish: true,\n\t\t},\n\t\t{\n\t\t\tname:         \"two channels not finished\",\n\t\t\tsetup:        twoChannelsNotFinished,\n\t\t\texpectFinish: false,\n\t\t},\n\t\t{\n\t\t\tname:         \"two channels finished\",\n\t\t\tsetup:        twoChannelsFinished,\n\t\t\texpectFinish: true,\n\t\t},\n\t}\n\n\t// tester is a helper closure that finds the locator.\n\ttester := func(t *testing.T, cdb kvdb.Backend) *updateLocator {\n\t\tvar l *updateLocator\n\t\terr := kvdb.Update(cdb, func(tx kvdb.RwTx) error {\n\t\t\trootBucket := tx.ReadWriteBucket(openChannelBucket)\n\n\t\t\t// Find the locator.\n\t\t\tlocator, err := locateNextUpdateNum(rootBucket)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tl = locator\n\t\t\treturn nil\n\t\t}, func() {})\n\t\trequire.NoError(t, err)\n\n\t\treturn l\n\t}\n\n\tfor _, tc := range testCases {\n\t\t// Create a test database.\n\t\tcdb, err := migtest.MakeDB(t)\n\t\trequire.NoError(t, err)\n\n\t\ttc := tc\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Setup the test case.\n\t\t\tc, height := tc.setup(cdb)\n\n\t\t\t// Run the test and assert the locator.\n\t\t\tlocator := tester(t, cdb)\n\t\t\tif tc.expectFinish {\n\t\t\t\trequire.Nil(t, locator, \"expected nil locator\")\n\t\t\t} else {\n\t\t\t\tassertLocator(t, c, height, locator)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "length": 5519,
      "tokens": 687,
      "embedding": []
    },
    {
      "slug": "func createDummyChannelCommit(height uint64) mig.ChannelCommitment {",
      "content": "func createDummyChannelCommit(height uint64) mig.ChannelCommitment {\n\thtlc := mig.HTLC{\n\t\tAmt:           testHTLCAmt,\n\t\tRefundTimeout: testRefundTimeout,\n\t\tOutputIndex:   testOutputIndex,\n\t\tIncoming:      testIncoming,\n\t}\n\tcopy(htlc.RHash[:], testRHash)\n\tc := mig.ChannelCommitment{\n\t\tCommitHeight: height,\n\t\tHtlcs:        []mig.HTLC{htlc},\n\t\tCommitTx:     testTx,\n\t}\n\treturn c\n}\n",
      "length": 297,
      "tokens": 27,
      "embedding": []
    }
  ]
}