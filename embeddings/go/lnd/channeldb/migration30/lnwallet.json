{
  "filepath": "../implementations/go/lnd/channeldb/migration30/lnwallet.go",
  "package": "migration30",
  "sections": [
    {
      "slug": "type CommitmentKeyRing struct {",
      "content": "type CommitmentKeyRing struct {\n\t// CommitPoint is the \"per commitment point\" used to derive the tweak\n\t// for each base point.\n\tCommitPoint *btcec.PublicKey\n\n\t// LocalCommitKeyTweak is the tweak used to derive the local public key\n\t// from the local payment base point or the local private key from the\n\t// base point secret. This may be included in a SignDescriptor to\n\t// generate signatures for the local payment key.\n\t//\n\t// NOTE: This will always refer to \"our\" local key, regardless of\n\t// whether this is our commit or not.\n\tLocalCommitKeyTweak []byte\n\n\t// TODO(roasbeef): need delay tweak as well?\n\n\t// LocalHtlcKeyTweak is the tweak used to derive the local HTLC key\n\t// from the local HTLC base point. This value is needed in order to\n\t// derive the final key used within the HTLC scripts in the commitment\n\t// transaction.\n\t//\n\t// NOTE: This will always refer to \"our\" local HTLC key, regardless of\n\t// whether this is our commit or not.\n\tLocalHtlcKeyTweak []byte\n\n\t// LocalHtlcKey is the key that will be used in any clause paying to\n\t// our node of any HTLC scripts within the commitment transaction for\n\t// this key ring set.\n\t//\n\t// NOTE: This will always refer to \"our\" local HTLC key, regardless of\n\t// whether this is our commit or not.\n\tLocalHtlcKey *btcec.PublicKey\n\n\t// RemoteHtlcKey is the key that will be used in clauses within the\n\t// HTLC script that send money to the remote party.\n\t//\n\t// NOTE: This will always refer to \"their\" remote HTLC key, regardless\n\t// of whether this is our commit or not.\n\tRemoteHtlcKey *btcec.PublicKey\n\n\t// ToLocalKey is the commitment transaction owner's key which is\n\t// included in HTLC success and timeout transaction scripts. This is\n\t// the public key used for the to_local output of the commitment\n\t// transaction.\n\t//\n\t// NOTE: Who's key this is depends on the current perspective. If this\n\t// is our commitment this will be our key.\n\tToLocalKey *btcec.PublicKey\n\n\t// ToRemoteKey is the non-owner's payment key in the commitment tx.\n\t// This is the key used to generate the to_remote output within the\n\t// commitment transaction.\n\t//\n\t// NOTE: Who's key this is depends on the current perspective. If this\n\t// is our commitment this will be their key.\n\tToRemoteKey *btcec.PublicKey\n\n\t// RevocationKey is the key that can be used by the other party to\n\t// redeem outputs from a revoked commitment transaction if it were to\n\t// be published.\n\t//\n\t// NOTE: Who can sign for this key depends on the current perspective.\n\t// If this is our commitment, it means the remote node can sign for\n\t// this key in case of a breach.\n\tRevocationKey *btcec.PublicKey\n}\n\n// ScriptInfo holds a redeem script and hash.",
      "length": 2567,
      "tokens": 450,
      "embedding": []
    },
    {
      "slug": "type ScriptInfo struct {",
      "content": "type ScriptInfo struct {\n\t// PkScript is the output's PkScript.\n\tPkScript []byte\n\n\t// WitnessScript is the full script required to properly redeem the\n\t// output. This field should be set to the full script if a p2wsh\n\t// output is being signed. For p2wkh it should be set equal to the\n\t// PkScript.\n\tWitnessScript []byte\n}\n\n// findOutputIndexesFromRemote finds the index of our and their outputs from\n// the remote commitment transaction. It derives the key ring to compute the\n// output scripts and compares them against the outputs inside the commitment\n// to find the match.",
      "length": 540,
      "tokens": 93,
      "embedding": []
    },
    {
      "slug": "func findOutputIndexesFromRemote(revocationPreimage *chainhash.Hash,",
      "content": "func findOutputIndexesFromRemote(revocationPreimage *chainhash.Hash,\n\tchanState *mig26.OpenChannel,\n\toldLog *mig.ChannelCommitment) (uint32, uint32, error) {\n\n\t// Init the output indexes as empty.\n\tourIndex := uint32(OutputIndexEmpty)\n\ttheirIndex := uint32(OutputIndexEmpty)\n\n\tchanCommit := oldLog\n\t_, commitmentPoint := btcec.PrivKeyFromBytes(revocationPreimage[:])\n\n\t// With the commitment point generated, we can now derive the king ring\n\t// which will be used to generate the output scripts.\n\tkeyRing := DeriveCommitmentKeys(\n\t\tcommitmentPoint, false, chanState.ChanType,\n\t\t&chanState.LocalChanCfg, &chanState.RemoteChanCfg,\n\t)\n\n\t// Since it's remote commitment chain, we'd used the mirrored values.\n\t//\n\t// We use the remote's channel config for the csv delay.\n\ttheirDelay := uint32(chanState.RemoteChanCfg.CsvDelay)\n\n\t// If we are the initiator of this channel, then it's be false from the\n\t// remote's PoV.\n\tisRemoteInitiator := !chanState.IsInitiator\n\n\tvar leaseExpiry uint32\n\tif chanState.ChanType.HasLeaseExpiration() {\n\t\tleaseExpiry = chanState.ThawHeight\n\t}\n\n\t// Map the scripts from our PoV. When facing a local commitment, the to\n\t// local output belongs to us and the to remote output belongs to them.\n\t// When facing a remote commitment, the to local output belongs to them\n\t// and the to remote output belongs to us.\n\n\t// Compute the to local script. From our PoV, when facing a remote\n\t// commitment, the to local output belongs to them.\n\ttheirScript, err := CommitScriptToSelf(\n\t\tchanState.ChanType, isRemoteInitiator, keyRing.ToLocalKey,\n\t\tkeyRing.RevocationKey, theirDelay, leaseExpiry,\n\t)\n\tif err != nil {\n\t\treturn ourIndex, theirIndex, err\n\t}\n\n\t// Compute the to remote script. From our PoV, when facing a remote\n\t// commitment, the to remote output belongs to us.\n\tourScript, _, err := CommitScriptToRemote(\n\t\tchanState.ChanType, isRemoteInitiator, keyRing.ToRemoteKey,\n\t\tleaseExpiry,\n\t)\n\tif err != nil {\n\t\treturn ourIndex, theirIndex, err\n\t}\n\n\t// Now compare the scripts to find our/their output index.\n\tfor i, txOut := range chanCommit.CommitTx.TxOut {\n\t\tswitch {\n\t\tcase bytes.Equal(txOut.PkScript, ourScript.PkScript):\n\t\t\tourIndex = uint32(i)\n\t\tcase bytes.Equal(txOut.PkScript, theirScript.PkScript):\n\t\t\ttheirIndex = uint32(i)\n\t\t}\n\t}\n\n\treturn ourIndex, theirIndex, nil\n}\n\n// DeriveCommitmentKeys generates a new commitment key set using the base points\n// and commitment point. The keys are derived differently depending on the type\n// of channel, and whether the commitment transaction is ours or the remote\n// peer's.",
      "length": 2405,
      "tokens": 330,
      "embedding": []
    },
    {
      "slug": "func DeriveCommitmentKeys(commitPoint *btcec.PublicKey,",
      "content": "func DeriveCommitmentKeys(commitPoint *btcec.PublicKey,\n\tisOurCommit bool, chanType mig25.ChannelType,\n\tlocalChanCfg, remoteChanCfg *mig.ChannelConfig) *CommitmentKeyRing {\n\n\ttweaklessCommit := chanType.IsTweakless()\n\n\t// Depending on if this is our commit or not, we'll choose the correct\n\t// base point.\n\tlocalBasePoint := localChanCfg.PaymentBasePoint\n\tif isOurCommit {\n\t\tlocalBasePoint = localChanCfg.DelayBasePoint\n\t}\n\n\t// First, we'll derive all the keys that don't depend on the context of\n\t// whose commitment transaction this is.\n\tkeyRing := &CommitmentKeyRing{\n\t\tCommitPoint: commitPoint,\n\n\t\tLocalCommitKeyTweak: input.SingleTweakBytes(\n\t\t\tcommitPoint, localBasePoint.PubKey,\n\t\t),\n\t\tLocalHtlcKeyTweak: input.SingleTweakBytes(\n\t\t\tcommitPoint, localChanCfg.HtlcBasePoint.PubKey,\n\t\t),\n\t\tLocalHtlcKey: input.TweakPubKey(\n\t\t\tlocalChanCfg.HtlcBasePoint.PubKey, commitPoint,\n\t\t),\n\t\tRemoteHtlcKey: input.TweakPubKey(\n\t\t\tremoteChanCfg.HtlcBasePoint.PubKey, commitPoint,\n\t\t),\n\t}\n\n\t// We'll now compute the to_local, to_remote, and revocation key based\n\t// on the current commitment point. All keys are tweaked each state in\n\t// order to ensure the keys from each state are unlinkable. To create\n\t// the revocation key, we take the opposite party's revocation base\n\t// point and combine that with the current commitment point.\n\tvar (\n\t\ttoLocalBasePoint    *btcec.PublicKey\n\t\ttoRemoteBasePoint   *btcec.PublicKey\n\t\trevocationBasePoint *btcec.PublicKey\n\t)\n\tif isOurCommit {\n\t\ttoLocalBasePoint = localChanCfg.DelayBasePoint.PubKey\n\t\ttoRemoteBasePoint = remoteChanCfg.PaymentBasePoint.PubKey\n\t\trevocationBasePoint = remoteChanCfg.RevocationBasePoint.PubKey\n\t} else {\n\t\ttoLocalBasePoint = remoteChanCfg.DelayBasePoint.PubKey\n\t\ttoRemoteBasePoint = localChanCfg.PaymentBasePoint.PubKey\n\t\trevocationBasePoint = localChanCfg.RevocationBasePoint.PubKey\n\t}\n\n\t// With the base points assigned, we can now derive the actual keys\n\t// using the base point, and the current commitment tweak.\n\tkeyRing.ToLocalKey = input.TweakPubKey(toLocalBasePoint, commitPoint)\n\tkeyRing.RevocationKey = input.DeriveRevocationPubkey(\n\t\trevocationBasePoint, commitPoint,\n\t)\n\n\t// If this commitment should omit the tweak for the remote point, then\n\t// we'll use that directly, and ignore the commitPoint tweak.\n\tif tweaklessCommit {\n\t\tkeyRing.ToRemoteKey = toRemoteBasePoint\n\n\t\t// If this is not our commitment, the above ToRemoteKey will be\n\t\t// ours, and we blank out the local commitment tweak to\n\t\t// indicate that the key should not be tweaked when signing.\n\t\tif !isOurCommit {\n\t\t\tkeyRing.LocalCommitKeyTweak = nil\n\t\t}\n\t} else {\n\t\tkeyRing.ToRemoteKey = input.TweakPubKey(\n\t\t\ttoRemoteBasePoint, commitPoint,\n\t\t)\n\t}\n\n\treturn keyRing\n}\n\n// CommitScriptToRemote derives the appropriate to_remote script based on the\n// channel's commitment type. The `initiator` argument should correspond to the\n// owner of the commitment transaction which we are generating the to_remote\n// script for. The second return value is the CSV delay of the output script,\n// what must be satisfied in order to spend the output.",
      "length": 2934,
      "tokens": 352,
      "embedding": []
    },
    {
      "slug": "func CommitScriptToRemote(chanType mig25.ChannelType, initiator bool,",
      "content": "func CommitScriptToRemote(chanType mig25.ChannelType, initiator bool,\n\tkey *btcec.PublicKey, leaseExpiry uint32) (*ScriptInfo, uint32, error) {\n\n\tswitch {\n\t// If we are not the initiator of a leased channel, then the remote\n\t// party has an additional CLTV requirement in addition to the 1 block\n\t// CSV requirement.\n\tcase chanType.HasLeaseExpiration() && !initiator:\n\t\tscript, err := input.LeaseCommitScriptToRemoteConfirmed(\n\t\t\tkey, leaseExpiry,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, 0, err\n\t\t}\n\n\t\tp2wsh, err := input.WitnessScriptHash(script)\n\t\tif err != nil {\n\t\t\treturn nil, 0, err\n\t\t}\n\n\t\treturn &ScriptInfo{\n\t\t\tPkScript:      p2wsh,\n\t\t\tWitnessScript: script,\n\t\t}, 1, nil\n\n\t// If this channel type has anchors, we derive the delayed to_remote\n\t// script.\n\tcase chanType.HasAnchors():\n\t\tscript, err := input.CommitScriptToRemoteConfirmed(key)\n\t\tif err != nil {\n\t\t\treturn nil, 0, err\n\t\t}\n\n\t\tp2wsh, err := input.WitnessScriptHash(script)\n\t\tif err != nil {\n\t\t\treturn nil, 0, err\n\t\t}\n\n\t\treturn &ScriptInfo{\n\t\t\tPkScript:      p2wsh,\n\t\t\tWitnessScript: script,\n\t\t}, 1, nil\n\n\tdefault:\n\t\t// Otherwise the to_remote will be a simple p2wkh.\n\t\tp2wkh, err := input.CommitScriptUnencumbered(key)\n\t\tif err != nil {\n\t\t\treturn nil, 0, err\n\t\t}\n\n\t\t// Since this is a regular P2WKH, the WitnessScipt and PkScript\n\t\t// should both be set to the script hash.\n\t\treturn &ScriptInfo{\n\t\t\tWitnessScript: p2wkh,\n\t\t\tPkScript:      p2wkh,\n\t\t}, 0, nil\n\t}\n}\n\n// CommitScriptToSelf constructs the public key script for the output on the\n// commitment transaction paying to the \"owner\" of said commitment transaction.\n// The `initiator` argument should correspond to the owner of the commitment\n// transaction which we are generating the to_local script for. If the other\n// party learns of the preimage to the revocation hash, then they can claim all\n// the settled funds in the channel, plus the unsettled funds.",
      "length": 1749,
      "tokens": 266,
      "embedding": []
    },
    {
      "slug": "func CommitScriptToSelf(chanType mig25.ChannelType, initiator bool,",
      "content": "func CommitScriptToSelf(chanType mig25.ChannelType, initiator bool,\n\tselfKey, revokeKey *btcec.PublicKey, csvDelay, leaseExpiry uint32) (\n\t*ScriptInfo, error) {\n\n\tvar (\n\t\ttoLocalRedeemScript []byte\n\t\terr                 error\n\t)\n\tswitch {\n\t// If we are the initiator of a leased channel, then we have an\n\t// additional CLTV requirement in addition to the usual CSV requirement.\n\tcase initiator && chanType.HasLeaseExpiration():\n\t\ttoLocalRedeemScript, err = input.LeaseCommitScriptToSelf(\n\t\t\tselfKey, revokeKey, csvDelay, leaseExpiry,\n\t\t)\n\n\tdefault:\n\t\ttoLocalRedeemScript, err = input.CommitScriptToSelf(\n\t\t\tcsvDelay, selfKey, revokeKey,\n\t\t)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ttoLocalScriptHash, err := input.WitnessScriptHash(toLocalRedeemScript)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &ScriptInfo{\n\t\tPkScript:      toLocalScriptHash,\n\t\tWitnessScript: toLocalRedeemScript,\n\t}, nil\n}\n",
      "length": 797,
      "tokens": 98,
      "embedding": []
    }
  ]
}