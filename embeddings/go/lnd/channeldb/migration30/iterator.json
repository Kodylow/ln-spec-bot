{
  "filepath": "../implementations/go/lnd/channeldb/migration30/iterator.go",
  "package": "migration30",
  "sections": [
    {
      "slug": "type updateLocator struct {",
      "content": "type updateLocator struct {\n\t// nodePub, chainHash and fundingOutpoint are used to locate the\n\t// channel bucket.\n\tnodePub         []byte\n\tchainHash       []byte\n\tfundingOutpoint []byte\n\n\t// nextHeight is used to locate the next old revocation log to be\n\t// migrated. A nil value means we've finished the migration.\n\tnextHeight []byte\n}\n\n// fetchChanBucket is a helper function that returns the bucket where a\n// channel's data resides in given: the public key for the node, the outpoint,\n// and the chainhash that the channel resides on.",
      "length": 497,
      "tokens": 80,
      "embedding": []
    },
    {
      "slug": "func (ul *updateLocator) locateChanBucket(rootBucket kvdb.RwBucket) (",
      "content": "func (ul *updateLocator) locateChanBucket(rootBucket kvdb.RwBucket) (\n\tkvdb.RwBucket, error) {\n\n\t// Within this top level bucket, fetch the bucket dedicated to storing\n\t// open channel data specific to the remote node.\n\tnodeChanBucket := rootBucket.NestedReadWriteBucket(ul.nodePub)\n\tif nodeChanBucket == nil {\n\t\treturn nil, mig25.ErrNoActiveChannels\n\t}\n\n\t// We'll then recurse down an additional layer in order to fetch the\n\t// bucket for this particular chain.\n\tchainBucket := nodeChanBucket.NestedReadWriteBucket(ul.chainHash)\n\tif chainBucket == nil {\n\t\treturn nil, mig25.ErrNoActiveChannels\n\t}\n\n\t// With the bucket for the node and chain fetched, we can now go down\n\t// another level, for this channel itself.\n\tchanBucket := chainBucket.NestedReadWriteBucket(ul.fundingOutpoint)\n\tif chanBucket == nil {\n\t\treturn nil, mig25.ErrChannelNotFound\n\t}\n\n\treturn chanBucket, nil\n}\n\n// findNextMigrateHeight finds the next commit height that's not migrated. It\n// returns the commit height bytes found. A nil return value means the\n// migration has been completed for this particular channel bucket.",
      "length": 995,
      "tokens": 139,
      "embedding": []
    },
    {
      "slug": "func findNextMigrateHeight(chanBucket kvdb.RwBucket) []byte {",
      "content": "func findNextMigrateHeight(chanBucket kvdb.RwBucket) []byte {\n\t// Read the old log bucket. The old bucket doesn't exist, indicating\n\t// either we don't have any old logs for this channel, or the migration\n\t// has been finished and the old bucket has been deleted.\n\toldBucket := chanBucket.NestedReadBucket(\n\t\trevocationLogBucketDeprecated,\n\t)\n\tif oldBucket == nil {\n\t\treturn nil\n\t}\n\n\t// Acquire a read cursor for the old bucket.\n\toldCursor := oldBucket.ReadCursor()\n\n\t// Read the new log bucket. The sub-bucket hasn't been created yet,\n\t// indicating we haven't migrated any logs under this channel. In this\n\t// case, we'll return the first commit height found from the old\n\t// revocation log bucket as the next height.\n\tlogBucket := chanBucket.NestedReadBucket(revocationLogBucket)\n\tif logBucket == nil {\n\t\tnextHeight, _ := oldCursor.First()\n\t\treturn nextHeight\n\t}\n\n\t// Acquire a read cursor for the new bucket.\n\tcursor := logBucket.ReadCursor()\n\n\t// Read the last migrated record. If the key is nil, we haven't\n\t// migrated any logs yet. In this case we return the first commit\n\t// height found from the old revocation log bucket. For instance,\n\t// - old log: [1, 2]\n\t// - new log: []\n\t// We will return the first key [1].\n\tmigratedHeight, _ := cursor.Last()\n\tif migratedHeight == nil {\n\t\tnextHeight, _ := oldCursor.First()\n\t\treturn nextHeight\n\t}\n\n\t// Read the last height from the old log bucket.\n\tendHeight, _ := oldCursor.Last()\n\n\tswitch bytes.Compare(migratedHeight, endHeight) {\n\t// If the height of the last old revocation equals to the migrated\n\t// height, we've done migrating for this channel. For instance,\n\t// - old log: [1, 2]\n\t// - new log: [1, 2]\n\tcase 0:\n\t\treturn nil\n\n\t// If the migrated height is smaller, it means this is a resumed\n\t// migration. In this case we will return the next height found in the\n\t// old bucket. For instance,\n\t// - old log: [1, 2]\n\t// - new log: [1]\n\t// We will return the key [2].\n\tcase -1:\n\t\t// Now point the cursor to the migratedHeight. If we cannot\n\t\t// find this key from the old log bucket, the database might be\n\t\t// corrupted. In this case, we would return the first key so\n\t\t// that we would redo the migration for this chan bucket.\n\t\tmatchedHeight, _ := oldCursor.Seek(migratedHeight)\n\n\t\t// NOTE: because Seek will return the next key when the passed\n\t\t// key cannot be found, we need to compare the `matchedHeight`\n\t\t// to decide whether `migratedHeight` is found or not.\n\t\tif !bytes.Equal(matchedHeight, migratedHeight) {\n\t\t\tlog.Warnf(\"Old revocation bucket doesn't have \"+\n\t\t\t\t\"CommitHeight=%v yet it's found in the new \"+\n\t\t\t\t\"bucket. It's likely the new revocation log \"+\n\t\t\t\t\"bucket is corrupted. Migrations will be\"+\n\t\t\t\t\"applied again.\",\n\t\t\t\tbinary.BigEndian.Uint64(migratedHeight))\n\n\t\t\t// Now return the first height found in the old bucket\n\t\t\t// so we can redo the migration.\n\t\t\tnextHeight, _ := oldCursor.First()\n\t\t\treturn nextHeight\n\t\t}\n\n\t\t// Otherwise, find the next height to be migrated.\n\t\tnextHeight, _ := oldCursor.Next()\n\t\treturn nextHeight\n\n\t// If the migrated height is greater, it means this node has new logs\n\t// saved after v0.15.0. In this case, we need to further decide whether\n\t// the old logs have been migrated or not.\n\tcase 1:\n\t}\n\n\t// If we ever reached here, it means we have a mixed of new and old\n\t// logs saved. Suppose we have old logs as,\n\t//   - old log: [1, 2]\n\t// We'd have four possible scenarios,\n\t//   - new log: [      3, 4] <- no migration happened, return [1].\n\t//   - new log: [1,    3, 4] <- resumed migration, return [2].\n\t//   - new log: [   2, 3, 4] <- corrupted migration, return [1].\n\t//   - new log: [1, 2, 3, 4] <- finished migration, return nil.\n\t// To find the next migration height, we will iterate the old logs to\n\t// grab the heights and query them in the new bucket until an height\n\t// cannot be found, which is our next migration height. Or, if the old\n\t// heights can all be found, it indicates a finished migration.\n\n\t// Move the cursor to the first record.\n\toldKey, _ := oldCursor.First()\n\n\t// NOTE: this action can be time-consuming as we are iterating the\n\t// records and compare them. However, we would only ever hit here if\n\t// this is a resumed migration with new logs created after v.0.15.0.\n\tfor {\n\t\t// Try to locate the old key in the new bucket. If it cannot be\n\t\t// found, it will be the next migrate height.\n\t\tnewKey, _ := cursor.Seek(oldKey)\n\n\t\t// If the old key is not found in the new bucket, return it as\n\t\t// our next migration height.\n\t\t//\n\t\t// NOTE: because Seek will return the next key when the passed\n\t\t// key cannot be found, we need to compare the keys to deicde\n\t\t// whether the old key is found or not.\n\t\tif !bytes.Equal(newKey, oldKey) {\n\t\t\treturn oldKey\n\t\t}\n\n\t\t// Otherwise, keep iterating the old bucket.\n\t\toldKey, _ = oldCursor.Next()\n\n\t\t// If we've done iterating, yet all the old keys can be found\n\t\t// in the new bucket, this means the migration has been\n\t\t// finished.\n\t\tif oldKey == nil {\n\t\t\treturn nil\n\t\t}\n\t}\n}\n\n// locateNextUpdateNum returns a locator that's used to start our migration. A\n// nil locator means the migration has been finished.",
      "length": 4901,
      "tokens": 861,
      "embedding": []
    },
    {
      "slug": "func locateNextUpdateNum(openChanBucket kvdb.RwBucket) (*updateLocator, error) {",
      "content": "func locateNextUpdateNum(openChanBucket kvdb.RwBucket) (*updateLocator, error) {\n\tlocator := &updateLocator{}\n\n\t// cb is the callback function to be used when iterating the buckets.\n\tcb := func(chanBucket kvdb.RwBucket, l *updateLocator) error {\n\t\tlocator = l\n\n\t\tupdateNum := findNextMigrateHeight(chanBucket)\n\n\t\t// We've found the next commit height and can now exit.\n\t\tif updateNum != nil {\n\t\t\tlocator.nextHeight = updateNum\n\t\t\treturn errExit\n\t\t}\n\t\treturn nil\n\t}\n\n\t// Iterate the buckets. If we received an exit signal, return the\n\t// locator.\n\terr := iterateBuckets(openChanBucket, nil, cb)\n\tif err == errExit {\n\t\tlog.Debugf(\"found locator: nodePub=%x, fundingOutpoint=%x, \"+\n\t\t\t\"nextHeight=%x\", locator.nodePub, locator.chainHash,\n\t\t\tlocator.nextHeight)\n\t\treturn locator, nil\n\t}\n\n\t// If the err is nil, we've iterated all the sub-buckets and the\n\t// migration is finished.\n\treturn nil, err\n}\n\n// callback defines a type that's used by the iterator.",
      "length": 840,
      "tokens": 123,
      "embedding": []
    },
    {
      "slug": "type callback func(k, v []byte) error",
      "content": "type callback func(k, v []byte) error\n\n// iterator is a helper function that iterates a given bucket and performs the\n// callback function on each key. If a seeker is specified, it will move the\n// cursor to the given position otherwise it will start from the first item.",
      "length": 230,
      "tokens": 43,
      "embedding": []
    },
    {
      "slug": "func iterator(bucket kvdb.RBucket, seeker []byte, cb callback) error {",
      "content": "func iterator(bucket kvdb.RBucket, seeker []byte, cb callback) error {\n\tc := bucket.ReadCursor()\n\tk, v := c.First()\n\n\t// Move the cursor to the specified position if seeker is non-nil.\n\tif seeker != nil {\n\t\tk, v = c.Seek(seeker)\n\t}\n\n\t// Start the iteration and exit on condition.\n\tfor k, v := k, v; k != nil; k, v = c.Next() {\n\t\t// cb might return errExit to signal exiting the iteration.\n\t\tif err := cb(k, v); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// step defines the callback type that's used when iterating the buckets.",
      "length": 444,
      "tokens": 89,
      "embedding": []
    },
    {
      "slug": "type step func(bucket kvdb.RwBucket, l *updateLocator) error",
      "content": "type step func(bucket kvdb.RwBucket, l *updateLocator) error\n\n// iterateBuckets locates the cursor at a given position specified by the\n// updateLocator and starts the iteration. If a nil locator is passed, it will\n// start the iteration from the beginning. During each iteration, the callback\n// function is called and it may exit the iteration when the callback returns\n// an errExit to signal an exit condition.",
      "length": 348,
      "tokens": 60,
      "embedding": []
    },
    {
      "slug": "func iterateBuckets(openChanBucket kvdb.RwBucket,",
      "content": "func iterateBuckets(openChanBucket kvdb.RwBucket,\n\tl *updateLocator, cb step) error {\n\n\t// If the locator is nil, we will initiate an empty one, which is\n\t// further used by the iterator.\n\tif l == nil {\n\t\tl = &updateLocator{}\n\t}\n\n\t// iterChanBucket iterates the chain bucket to act on each of the\n\t// channel buckets.\n\titerChanBucket := func(chain kvdb.RwBucket,\n\t\tk1, k2, _ []byte, cb step) error {\n\n\t\treturn iterator(\n\t\t\tchain, l.fundingOutpoint,\n\t\t\tfunc(k3, _ []byte) error {\n\t\t\t\t// Read the sub-bucket level 3.\n\t\t\t\tchanBucket := chain.NestedReadWriteBucket(k3)\n\t\t\t\tif chanBucket == nil {\n\t\t\t\t\treturn fmt.Errorf(\"no bucket for \"+\n\t\t\t\t\t\t\"chanPoint=%x\", k3)\n\t\t\t\t}\n\n\t\t\t\t// Construct a new locator at this position.\n\t\t\t\tlocator := &updateLocator{\n\t\t\t\t\tnodePub:         k1,\n\t\t\t\t\tchainHash:       k2,\n\t\t\t\t\tfundingOutpoint: k3,\n\t\t\t\t}\n\n\t\t\t\t// Set the seeker to nil so it won't affect\n\t\t\t\t// other buckets.\n\t\t\t\tl.fundingOutpoint = nil\n\n\t\t\t\treturn cb(chanBucket, locator)\n\t\t\t})\n\t}\n\n\treturn iterator(openChanBucket, l.nodePub, func(k1, v []byte) error {\n\t\t// Read the sub-bucket level 1.\n\t\tnode := openChanBucket.NestedReadWriteBucket(k1)\n\t\tif node == nil {\n\t\t\treturn fmt.Errorf(\"no bucket for node %x\", k1)\n\t\t}\n\n\t\treturn iterator(node, l.chainHash, func(k2, v []byte) error {\n\t\t\t// Read the sub-bucket level 2.\n\t\t\tchain := node.NestedReadWriteBucket(k2)\n\t\t\tif chain == nil {\n\t\t\t\treturn fmt.Errorf(\"no bucket for chain=%x\", k2)\n\t\t\t}\n\n\t\t\t// Set the seeker to nil so it won't affect other\n\t\t\t// buckets.\n\t\t\tl.chainHash = nil\n\n\t\t\treturn iterChanBucket(chain, k1, k2, v, cb)\n\t\t})\n\t})\n}\n",
      "length": 1464,
      "tokens": 216,
      "embedding": []
    }
  ]
}