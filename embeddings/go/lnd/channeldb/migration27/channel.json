{
  "filepath": "../implementations/go/lnd/channeldb/migration27/channel.go",
  "package": "migration27",
  "sections": [
    {
      "slug": "type OpenChannel struct {",
      "content": "type OpenChannel struct {\n\tmig26.OpenChannel\n}\n\n// FetchChanInfo deserializes the channel info based on the legacy boolean.",
      "length": 94,
      "tokens": 13,
      "embedding": []
    },
    {
      "slug": "func FetchChanInfo(chanBucket kvdb.RBucket, c *OpenChannel, legacy bool) error {",
      "content": "func FetchChanInfo(chanBucket kvdb.RBucket, c *OpenChannel, legacy bool) error {\n\tinfoBytes := chanBucket.Get(chanInfoKey)\n\tif infoBytes == nil {\n\t\treturn ErrNoChanInfoFound\n\t}\n\tr := bytes.NewReader(infoBytes)\n\n\tvar (\n\t\tchanType   mig.ChannelType\n\t\tchanStatus mig.ChannelStatus\n\t)\n\n\tif err := mig.ReadElements(r,\n\t\t&chanType, &c.ChainHash, &c.FundingOutpoint,\n\t\t&c.ShortChannelID, &c.IsPending, &c.IsInitiator,\n\t\t&chanStatus, &c.FundingBroadcastHeight,\n\t\t&c.NumConfsRequired, &c.ChannelFlags,\n\t\t&c.IdentityPub, &c.Capacity, &c.TotalMSatSent,\n\t\t&c.TotalMSatReceived,\n\t); err != nil {\n\t\treturn fmt.Errorf(\"ReadElements got: %v\", err)\n\t}\n\n\tc.ChanType = mig25.ChannelType(chanType)\n\tc.ChanStatus = mig25.ChannelStatus(chanStatus)\n\n\t// For single funder channels that we initiated and have the funding\n\t// transaction to, read the funding txn.\n\tif c.FundingTxPresent() {\n\t\tif err := mig.ReadElement(r, &c.FundingTxn); err != nil {\n\t\t\treturn fmt.Errorf(\"read FundingTxn got: %v\", err)\n\t\t}\n\t}\n\n\tif err := mig.ReadChanConfig(r, &c.LocalChanCfg); err != nil {\n\t\treturn fmt.Errorf(\"read LocalChanCfg got: %v\", err)\n\t}\n\tif err := mig.ReadChanConfig(r, &c.RemoteChanCfg); err != nil {\n\t\treturn fmt.Errorf(\"read RemoteChanCfg got: %v\", err)\n\t}\n\n\t// Retrieve the boolean stored under lastWasRevokeKey.\n\tlastWasRevokeBytes := chanBucket.Get(lastWasRevokeKey)\n\tif lastWasRevokeBytes == nil {\n\t\t// If nothing has been stored under this key, we store false in\n\t\t// the OpenChannel struct.\n\t\tc.LastWasRevoke = false\n\t} else {\n\t\t// Otherwise, read the value into the LastWasRevoke field.\n\t\trevokeReader := bytes.NewReader(lastWasRevokeBytes)\n\t\terr := mig.ReadElements(revokeReader, &c.LastWasRevoke)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"read LastWasRevoke got: %v\", err)\n\t\t}\n\t}\n\n\t// Make the tlv stream based on the legacy param.\n\tvar (\n\t\tts            *tlv.Stream\n\t\terr           error\n\t\tlocalBalance  uint64\n\t\tremoteBalance uint64\n\t)\n\n\tkeyLocRecord := mig25.MakeKeyLocRecord(\n\t\tkeyLocType, &c.RevocationKeyLocator,\n\t)\n\n\t// If it's legacy, create the stream with a single tlv record.\n\tif legacy {\n\t\tts, err = tlv.NewStream(keyLocRecord)\n\t} else {\n\t\t// Otherwise, for the new format, we will encode the balance\n\t\t// fields in the tlv stream too.\n\t\tts, err = tlv.NewStream(\n\t\t\tkeyLocRecord,\n\t\t\ttlv.MakePrimitiveRecord(\n\t\t\t\tinitialLocalBalanceType, &localBalance,\n\t\t\t),\n\t\t\ttlv.MakePrimitiveRecord(\n\t\t\t\tinitialRemoteBalanceType, &remoteBalance,\n\t\t\t),\n\t\t)\n\t}\n\tif err != nil {\n\t\treturn fmt.Errorf(\"create tlv stream got: %v\", err)\n\t}\n\n\tif err := ts.Decode(r); err != nil {\n\t\treturn fmt.Errorf(\"decode tlv stream got: %v\", err)\n\t}\n\n\t// For the new format, attach the balance fields.\n\tif !legacy {\n\t\tc.InitialLocalBalance = lnwire.MilliSatoshi(localBalance)\n\t\tc.InitialRemoteBalance = lnwire.MilliSatoshi(remoteBalance)\n\t}\n\n\t// Finally, read the optional shutdown scripts.\n\tif err := mig25.GetOptionalUpfrontShutdownScript(\n\t\tchanBucket, localUpfrontShutdownKey, &c.LocalShutdownScript,\n\t); err != nil {\n\t\treturn fmt.Errorf(\"local shutdown script got: %v\", err)\n\t}\n\n\treturn mig25.GetOptionalUpfrontShutdownScript(\n\t\tchanBucket, remoteUpfrontShutdownKey, &c.RemoteShutdownScript,\n\t)\n}\n\n// PutChanInfo serializes the channel info based on the legacy boolean.",
      "length": 3042,
      "tokens": 369,
      "embedding": []
    },
    {
      "slug": "func PutChanInfo(chanBucket kvdb.RwBucket, c *OpenChannel, legacy bool) error {",
      "content": "func PutChanInfo(chanBucket kvdb.RwBucket, c *OpenChannel, legacy bool) error {\n\tvar w bytes.Buffer\n\tif err := mig.WriteElements(&w,\n\t\tmig.ChannelType(c.ChanType), c.ChainHash, c.FundingOutpoint,\n\t\tc.ShortChannelID, c.IsPending, c.IsInitiator,\n\t\tmig.ChannelStatus(c.ChanStatus), c.FundingBroadcastHeight,\n\t\tc.NumConfsRequired, c.ChannelFlags,\n\t\tc.IdentityPub, c.Capacity, c.TotalMSatSent,\n\t\tc.TotalMSatReceived,\n\t); err != nil {\n\t\treturn err\n\t}\n\n\t// For single funder channels that we initiated, and we have the\n\t// funding transaction, then write the funding txn.\n\tif c.FundingTxPresent() {\n\t\tif err := mig.WriteElement(&w, c.FundingTxn); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := mig.WriteChanConfig(&w, &c.LocalChanCfg); err != nil {\n\t\treturn err\n\t}\n\tif err := mig.WriteChanConfig(&w, &c.RemoteChanCfg); err != nil {\n\t\treturn err\n\t}\n\n\t// Make the tlv stream based on the legacy param.\n\ttlvStream, err := mig26.MakeTlvStream(&c.OpenChannel, legacy)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := tlvStream.Encode(&w); err != nil {\n\t\treturn err\n\t}\n\n\tif err := chanBucket.Put(chanInfoKey, w.Bytes()); err != nil {\n\t\treturn err\n\t}\n\n\t// Finally, add optional shutdown scripts for the local and remote peer\n\t// if they are present.\n\tif err := mig25.PutOptionalUpfrontShutdownScript(\n\t\tchanBucket, localUpfrontShutdownKey, c.LocalShutdownScript,\n\t); err != nil {\n\t\treturn err\n\t}\n\n\treturn mig25.PutOptionalUpfrontShutdownScript(\n\t\tchanBucket, remoteUpfrontShutdownKey, c.RemoteShutdownScript,\n\t)\n}\n",
      "length": 1362,
      "tokens": 174,
      "embedding": []
    }
  ]
}