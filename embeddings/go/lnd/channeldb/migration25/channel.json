{
  "filepath": "../implementations/go/lnd/channeldb/migration25/channel.go",
  "package": "migration25",
  "sections": [
    {
      "slug": "type ChannelType uint8",
      "content": "type ChannelType uint8\n\nconst (\n\t// NOTE: iota isn't used here for this enum needs to be stable\n\t// long-term as it will be persisted to the database.\n\n\t// SingleFunderBit represents a channel wherein one party solely funds\n\t// the entire capacity of the channel.\n\tSingleFunderBit ChannelType = 0\n\n\t// DualFunderBit represents a channel wherein both parties contribute\n\t// funds towards the total capacity of the channel. The channel may be\n\t// funded symmetrically or asymmetrically.\n\tDualFunderBit ChannelType = 1 << 0\n\n\t// SingleFunderTweaklessBit is similar to the basic SingleFunder channel\n\t// type, but it omits the tweak for one's key in the commitment\n\t// transaction of the remote party.\n\tSingleFunderTweaklessBit ChannelType = 1 << 1\n\n\t// NoFundingTxBit denotes if we have the funding transaction locally on\n\t// disk. This bit may be on if the funding transaction was crafted by a\n\t// wallet external to the primary daemon.\n\tNoFundingTxBit ChannelType = 1 << 2\n\n\t// AnchorOutputsBit indicates that the channel makes use of anchor\n\t// outputs to bump the commitment transaction's effective feerate. This\n\t// channel type also uses a delayed to_remote output script.\n\tAnchorOutputsBit ChannelType = 1 << 3\n\n\t// FrozenBit indicates that the channel is a frozen channel, meaning\n\t// that only the responder can decide to cooperatively close the\n\t// channel.\n\tFrozenBit ChannelType = 1 << 4\n\n\t// ZeroHtlcTxFeeBit indicates that the channel should use zero-fee\n\t// second-level HTLC transactions.\n\tZeroHtlcTxFeeBit ChannelType = 1 << 5\n\n\t// LeaseExpirationBit indicates that the channel has been leased for a\n\t// period of time, constraining every output that pays to the channel\n\t// initiator with an additional CLTV of the lease maturity.\n\tLeaseExpirationBit ChannelType = 1 << 6\n)\n\n// IsSingleFunder returns true if the channel type if one of the known single\n// funder variants.",
      "length": 1819,
      "tokens": 294,
      "embedding": []
    },
    {
      "slug": "func (c ChannelType) IsSingleFunder() bool {",
      "content": "func (c ChannelType) IsSingleFunder() bool {\n\treturn c&DualFunderBit == 0\n}\n\n// IsDualFunder returns true if the ChannelType has the DualFunderBit set.",
      "length": 103,
      "tokens": 16,
      "embedding": []
    },
    {
      "slug": "func (c ChannelType) IsDualFunder() bool {",
      "content": "func (c ChannelType) IsDualFunder() bool {\n\treturn c&DualFunderBit == DualFunderBit\n}\n\n// IsTweakless returns true if the target channel uses a commitment that\n// doesn't tweak the key for the remote party.",
      "length": 159,
      "tokens": 26,
      "embedding": []
    },
    {
      "slug": "func (c ChannelType) IsTweakless() bool {",
      "content": "func (c ChannelType) IsTweakless() bool {\n\treturn c&SingleFunderTweaklessBit == SingleFunderTweaklessBit\n}\n\n// HasFundingTx returns true if this channel type is one that has a funding\n// transaction stored locally.",
      "length": 168,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c ChannelType) HasFundingTx() bool {",
      "content": "func (c ChannelType) HasFundingTx() bool {\n\treturn c&NoFundingTxBit == 0\n}\n\n// HasAnchors returns true if this channel type has anchor outputs on its\n// commitment.",
      "length": 117,
      "tokens": 20,
      "embedding": []
    },
    {
      "slug": "func (c ChannelType) HasAnchors() bool {",
      "content": "func (c ChannelType) HasAnchors() bool {\n\treturn c&AnchorOutputsBit == AnchorOutputsBit\n}\n\n// ZeroHtlcTxFee returns true if this channel type uses second-level HTLC\n// transactions signed with zero-fee.",
      "length": 157,
      "tokens": 21,
      "embedding": []
    },
    {
      "slug": "func (c ChannelType) ZeroHtlcTxFee() bool {",
      "content": "func (c ChannelType) ZeroHtlcTxFee() bool {\n\treturn c&ZeroHtlcTxFeeBit == ZeroHtlcTxFeeBit\n}\n\n// IsFrozen returns true if the channel is considered to be \"frozen\". A frozen\n// channel means that only the responder can initiate a cooperative channel\n// closure.",
      "length": 211,
      "tokens": 33,
      "embedding": []
    },
    {
      "slug": "func (c ChannelType) IsFrozen() bool {",
      "content": "func (c ChannelType) IsFrozen() bool {\n\treturn c&FrozenBit == FrozenBit\n}\n\n// HasLeaseExpiration returns true if the channel originated from a lease.",
      "length": 107,
      "tokens": 16,
      "embedding": []
    },
    {
      "slug": "func (c ChannelType) HasLeaseExpiration() bool {",
      "content": "func (c ChannelType) HasLeaseExpiration() bool {\n\treturn c&LeaseExpirationBit == LeaseExpirationBit\n}\n\n// ChannelStatus is a bit vector used to indicate whether an OpenChannel is in\n// the default usable state, or a state where it shouldn't be used.",
      "length": 196,
      "tokens": 32,
      "embedding": []
    },
    {
      "slug": "type ChannelStatus uint8",
      "content": "type ChannelStatus uint8\n\nvar (\n\t// ChanStatusDefault is the normal state of an open channel.\n\tChanStatusDefault ChannelStatus\n\n\t// ChanStatusBorked indicates that the channel has entered an\n\t// irreconcilable state, triggered by a state desynchronization or\n\t// channel breach.  Channels in this state should never be added to the\n\t// htlc switch.\n\tChanStatusBorked ChannelStatus = 1\n\n\t// ChanStatusCommitBroadcasted indicates that a commitment for this\n\t// channel has been broadcasted.\n\tChanStatusCommitBroadcasted ChannelStatus = 1 << 1\n\n\t// ChanStatusLocalDataLoss indicates that we have lost channel state\n\t// for this channel, and broadcasting our latest commitment might be\n\t// considered a breach.\n\t//\n\t// TODO(halseh): actually enforce that we are not force closing such a\n\t// channel.\n\tChanStatusLocalDataLoss ChannelStatus = 1 << 2\n\n\t// ChanStatusRestored is a status flag that signals that the channel\n\t// has been restored, and doesn't have all the fields a typical channel\n\t// will have.\n\tChanStatusRestored ChannelStatus = 1 << 3\n\n\t// ChanStatusCoopBroadcasted indicates that a cooperative close for\n\t// this channel has been broadcasted. Older cooperatively closed\n\t// channels will only have this status set. Newer ones will also have\n\t// close initiator information stored using the local/remote initiator\n\t// status. This status is set in conjunction with the initiator status\n\t// so that we do not need to check multiple channel statues for\n\t// cooperative closes.\n\tChanStatusCoopBroadcasted ChannelStatus = 1 << 4\n\n\t// ChanStatusLocalCloseInitiator indicates that we initiated closing\n\t// the channel.\n\tChanStatusLocalCloseInitiator ChannelStatus = 1 << 5\n\n\t// ChanStatusRemoteCloseInitiator indicates that the remote node\n\t// initiated closing the channel.\n\tChanStatusRemoteCloseInitiator ChannelStatus = 1 << 6\n)\n\n// chanStatusStrings maps a ChannelStatus to a human friendly string that\n// describes that status.\nvar chanStatusStrings = map[ChannelStatus]string{\n\tChanStatusDefault:              \"ChanStatusDefault\",\n\tChanStatusBorked:               \"ChanStatusBorked\",\n\tChanStatusCommitBroadcasted:    \"ChanStatusCommitBroadcasted\",\n\tChanStatusLocalDataLoss:        \"ChanStatusLocalDataLoss\",\n\tChanStatusRestored:             \"ChanStatusRestored\",\n\tChanStatusCoopBroadcasted:      \"ChanStatusCoopBroadcasted\",\n\tChanStatusLocalCloseInitiator:  \"ChanStatusLocalCloseInitiator\",\n\tChanStatusRemoteCloseInitiator: \"ChanStatusRemoteCloseInitiator\",\n}\n\n// orderedChanStatusFlags is an in-order list of all that channel status flags.\nvar orderedChanStatusFlags = []ChannelStatus{\n\tChanStatusBorked,\n\tChanStatusCommitBroadcasted,\n\tChanStatusLocalDataLoss,\n\tChanStatusRestored,\n\tChanStatusCoopBroadcasted,\n\tChanStatusLocalCloseInitiator,\n\tChanStatusRemoteCloseInitiator,\n}\n\n// String returns a human-readable representation of the ChannelStatus.",
      "length": 2766,
      "tokens": 326,
      "embedding": []
    },
    {
      "slug": "func (c ChannelStatus) String() string {",
      "content": "func (c ChannelStatus) String() string {\n\t// If no flags are set, then this is the default case.\n\tif c == ChanStatusDefault {\n\t\treturn chanStatusStrings[ChanStatusDefault]\n\t}\n\n\t// Add individual bit flags.\n\tstatusStr := \"\"\n\tfor _, flag := range orderedChanStatusFlags {\n\t\tif c&flag == flag {\n\t\t\tstatusStr += chanStatusStrings[flag] + \"|\"\n\t\t\tc -= flag\n\t\t}\n\t}\n\n\t// Remove anything to the right of the final bar, including it as well.\n\tstatusStr = strings.TrimRight(statusStr, \"|\")\n\n\t// Add any remaining flags which aren't accounted for as hex.\n\tif c != 0 {\n\t\tstatusStr += \"|0x\" + strconv.FormatUint(uint64(c), 16)\n\t}\n\n\t// If this was purely an unknown flag, then remove the extra bar at the\n\t// start of the string.\n\tstatusStr = strings.TrimLeft(statusStr, \"|\")\n\n\treturn statusStr\n}\n\n// OpenChannel embeds a mig.OpenChannel with the extra update-to-date fields.\n//\n// NOTE: doesn't have the Packager field as it's not used in current migration.",
      "length": 871,
      "tokens": 143,
      "embedding": []
    },
    {
      "slug": "type OpenChannel struct {",
      "content": "type OpenChannel struct {\n\tmig.OpenChannel\n\n\t// ChanType denotes which type of channel this is.\n\tChanType ChannelType\n\n\t// ChanStatus is the current status of this channel. If it is not in\n\t// the state Default, it should not be used for forwarding payments.\n\t//\n\t// NOTE: In `channeldb.OpenChannel`, this field is private. We choose\n\t// to export this private field such that following migrations can\n\t// access this field directly.\n\tChanStatus ChannelStatus\n\n\t// InitialLocalBalance is the balance we have during the channel\n\t// opening. When we are not the initiator, this value represents the\n\t// push amount.\n\tInitialLocalBalance lnwire.MilliSatoshi\n\n\t// InitialRemoteBalance is the balance they have during the channel\n\t// opening.\n\tInitialRemoteBalance lnwire.MilliSatoshi\n\n\t// LocalShutdownScript is set to a pre-set script if the channel was\n\t// opened by the local node with option_upfront_shutdown_script set. If\n\t// the option was not set, the field is empty.\n\tLocalShutdownScript lnwire.DeliveryAddress\n\n\t// RemoteShutdownScript is set to a pre-set script if the channel was\n\t// opened by the remote node with option_upfront_shutdown_script set.\n\t// If the option was not set, the field is empty.\n\tRemoteShutdownScript lnwire.DeliveryAddress\n\n\t// ThawHeight is the height when a frozen channel once again becomes a\n\t// normal channel. If this is zero, then there're no restrictions on\n\t// this channel. If the value is lower than 500,000, then it's\n\t// interpreted as a relative height, or an absolute height otherwise.\n\tThawHeight uint32\n\n\t// LastWasRevoke is a boolean that determines if the last update we\n\t// sent was a revocation (true) or a commitment signature (false).\n\tLastWasRevoke bool\n\n\t// RevocationKeyLocator stores the KeyLocator information that we will\n\t// need to derive the shachain root for this channel. This allows us to\n\t// have private key isolation from lnd.\n\tRevocationKeyLocator keychain.KeyLocator\n}\n",
      "length": 1868,
      "tokens": 284,
      "embedding": []
    },
    {
      "slug": "func (c *OpenChannel) hasChanStatus(status ChannelStatus) bool {",
      "content": "func (c *OpenChannel) hasChanStatus(status ChannelStatus) bool {\n\t// Special case ChanStatusDefualt since it isn't actually flag, but a\n\t// particular combination (or lack-there-of) of flags.\n\tif status == ChanStatusDefault {\n\t\treturn c.ChanStatus == ChanStatusDefault\n\t}\n\n\treturn c.ChanStatus&status == status\n}\n\n// FundingTxPresent returns true if expect the funding transcation to be found\n// on disk or already populated within the passed open channel struct.",
      "length": 388,
      "tokens": 57,
      "embedding": []
    },
    {
      "slug": "func (c *OpenChannel) FundingTxPresent() bool {",
      "content": "func (c *OpenChannel) FundingTxPresent() bool {\n\tchanType := c.ChanType\n\n\treturn chanType.IsSingleFunder() && chanType.HasFundingTx() &&\n\t\tc.IsInitiator &&\n\t\t!c.hasChanStatus(ChanStatusRestored)\n}\n\n// fetchChanInfo deserializes the channel info based on the legacy boolean.",
      "length": 218,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func fetchChanInfo(chanBucket kvdb.RBucket, c *OpenChannel, legacy bool) error {",
      "content": "func fetchChanInfo(chanBucket kvdb.RBucket, c *OpenChannel, legacy bool) error {\n\tinfoBytes := chanBucket.Get(chanInfoKey)\n\tif infoBytes == nil {\n\t\treturn ErrNoChanInfoFound\n\t}\n\tr := bytes.NewReader(infoBytes)\n\n\tvar (\n\t\tchanType   mig.ChannelType\n\t\tchanStatus mig.ChannelStatus\n\t)\n\n\tif err := mig.ReadElements(r,\n\t\t&chanType, &c.ChainHash, &c.FundingOutpoint,\n\t\t&c.ShortChannelID, &c.IsPending, &c.IsInitiator,\n\t\t&chanStatus, &c.FundingBroadcastHeight,\n\t\t&c.NumConfsRequired, &c.ChannelFlags,\n\t\t&c.IdentityPub, &c.Capacity, &c.TotalMSatSent,\n\t\t&c.TotalMSatReceived,\n\t); err != nil {\n\t\treturn err\n\t}\n\n\tc.ChanType = ChannelType(chanType)\n\tc.ChanStatus = ChannelStatus(chanStatus)\n\n\t// If this is not the legacy format, we need to read the extra two new\n\t// fields.\n\tif !legacy {\n\t\tif err := mig.ReadElements(r,\n\t\t\t&c.InitialLocalBalance, &c.InitialRemoteBalance,\n\t\t); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// For single funder channels that we initiated and have the funding\n\t// transaction to, read the funding txn.\n\tif c.FundingTxPresent() {\n\t\tif err := mig.ReadElement(r, &c.FundingTxn); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := mig.ReadChanConfig(r, &c.LocalChanCfg); err != nil {\n\t\treturn err\n\t}\n\tif err := mig.ReadChanConfig(r, &c.RemoteChanCfg); err != nil {\n\t\treturn err\n\t}\n\n\t// Retrieve the boolean stored under lastWasRevokeKey.\n\tlastWasRevokeBytes := chanBucket.Get(lastWasRevokeKey)\n\tif lastWasRevokeBytes == nil {\n\t\t// If nothing has been stored under this key, we store false in\n\t\t// the OpenChannel struct.\n\t\tc.LastWasRevoke = false\n\t} else {\n\t\t// Otherwise, read the value into the LastWasRevoke field.\n\t\trevokeReader := bytes.NewReader(lastWasRevokeBytes)\n\t\terr := mig.ReadElements(revokeReader, &c.LastWasRevoke)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tkeyLocRecord := MakeKeyLocRecord(keyLocType, &c.RevocationKeyLocator)\n\ttlvStream, err := tlv.NewStream(keyLocRecord)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := tlvStream.Decode(r); err != nil {\n\t\treturn err\n\t}\n\n\t// Finally, read the optional shutdown scripts.\n\tif err := GetOptionalUpfrontShutdownScript(\n\t\tchanBucket, localUpfrontShutdownKey, &c.LocalShutdownScript,\n\t); err != nil {\n\t\treturn err\n\t}\n\n\treturn GetOptionalUpfrontShutdownScript(\n\t\tchanBucket, remoteUpfrontShutdownKey, &c.RemoteShutdownScript,\n\t)\n}\n\n// fetchChanInfo serializes the channel info based on the legacy boolean and\n// saves it to disk.",
      "length": 2218,
      "tokens": 284,
      "embedding": []
    },
    {
      "slug": "func putChanInfo(chanBucket kvdb.RwBucket, c *OpenChannel, legacy bool) error {",
      "content": "func putChanInfo(chanBucket kvdb.RwBucket, c *OpenChannel, legacy bool) error {\n\tvar w bytes.Buffer\n\tif err := mig.WriteElements(&w,\n\t\tmig.ChannelType(c.ChanType), c.ChainHash, c.FundingOutpoint,\n\t\tc.ShortChannelID, c.IsPending, c.IsInitiator,\n\t\tmig.ChannelStatus(c.ChanStatus), c.FundingBroadcastHeight,\n\t\tc.NumConfsRequired, c.ChannelFlags,\n\t\tc.IdentityPub, c.Capacity, c.TotalMSatSent,\n\t\tc.TotalMSatReceived,\n\t); err != nil {\n\t\treturn err\n\t}\n\n\t// If this is not legacy format, we need to write the extra two fields.\n\tif !legacy {\n\t\tif err := mig.WriteElements(&w,\n\t\t\tc.InitialLocalBalance, c.InitialRemoteBalance,\n\t\t); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// For single funder channels that we initiated, and we have the\n\t// funding transaction, then write the funding txn.\n\tif c.FundingTxPresent() {\n\t\tif err := mig.WriteElement(&w, c.FundingTxn); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := mig.WriteChanConfig(&w, &c.LocalChanCfg); err != nil {\n\t\treturn err\n\t}\n\tif err := mig.WriteChanConfig(&w, &c.RemoteChanCfg); err != nil {\n\t\treturn err\n\t}\n\n\t// Write the RevocationKeyLocator as the first entry in a tlv stream.\n\tkeyLocRecord := MakeKeyLocRecord(\n\t\tkeyLocType, &c.RevocationKeyLocator,\n\t)\n\n\ttlvStream, err := tlv.NewStream(keyLocRecord)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := tlvStream.Encode(&w); err != nil {\n\t\treturn err\n\t}\n\n\tif err := chanBucket.Put(chanInfoKey, w.Bytes()); err != nil {\n\t\treturn err\n\t}\n\n\t// Finally, add optional shutdown scripts for the local and remote peer\n\t// if they are present.\n\tif err := PutOptionalUpfrontShutdownScript(\n\t\tchanBucket, localUpfrontShutdownKey, c.LocalShutdownScript,\n\t); err != nil {\n\t\treturn err\n\t}\n\n\treturn PutOptionalUpfrontShutdownScript(\n\t\tchanBucket, remoteUpfrontShutdownKey, c.RemoteShutdownScript,\n\t)\n}\n\n// EKeyLocator is an encoder for keychain.KeyLocator.",
      "length": 1683,
      "tokens": 221,
      "embedding": []
    },
    {
      "slug": "func EKeyLocator(w io.Writer, val interface{}, buf *[8]byte) error {",
      "content": "func EKeyLocator(w io.Writer, val interface{}, buf *[8]byte) error {\n\tif v, ok := val.(*keychain.KeyLocator); ok {\n\t\terr := tlv.EUint32T(w, uint32(v.Family), buf)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn tlv.EUint32T(w, v.Index, buf)\n\t}\n\treturn tlv.NewTypeForEncodingErr(val, \"keychain.KeyLocator\")\n}\n\n// DKeyLocator is a decoder for keychain.KeyLocator.",
      "length": 279,
      "tokens": 36,
      "embedding": []
    },
    {
      "slug": "func DKeyLocator(r io.Reader, val interface{}, buf *[8]byte, l uint64) error {",
      "content": "func DKeyLocator(r io.Reader, val interface{}, buf *[8]byte, l uint64) error {\n\tif v, ok := val.(*keychain.KeyLocator); ok {\n\t\tvar family uint32\n\t\terr := tlv.DUint32(r, &family, buf, 4)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv.Family = keychain.KeyFamily(family)\n\n\t\treturn tlv.DUint32(r, &v.Index, buf, 4)\n\t}\n\treturn tlv.NewTypeForDecodingErr(val, \"keychain.KeyLocator\", l, 8)\n}\n\n// MakeKeyLocRecord creates a Record out of a KeyLocator using the passed\n// Type and the EKeyLocator and DKeyLocator functions. The size will always be\n// 8 as KeyFamily is uint32 and the Index is uint32.",
      "length": 490,
      "tokens": 75,
      "embedding": []
    },
    {
      "slug": "func MakeKeyLocRecord(typ tlv.Type, keyLoc *keychain.KeyLocator) tlv.Record {",
      "content": "func MakeKeyLocRecord(typ tlv.Type, keyLoc *keychain.KeyLocator) tlv.Record {\n\treturn tlv.MakeStaticRecord(typ, keyLoc, 8, EKeyLocator, DKeyLocator)\n}\n\n// PutOptionalUpfrontShutdownScript adds a shutdown script under the key\n// provided if it has a non-zero length.",
      "length": 183,
      "tokens": 24,
      "embedding": []
    },
    {
      "slug": "func PutOptionalUpfrontShutdownScript(chanBucket kvdb.RwBucket, key []byte,",
      "content": "func PutOptionalUpfrontShutdownScript(chanBucket kvdb.RwBucket, key []byte,\n\tscript []byte) error {\n\t// If the script is empty, we do not need to add anything.\n\tif len(script) == 0 {\n\t\treturn nil\n\t}\n\n\tvar w bytes.Buffer\n\tif err := mig.WriteElement(&w, script); err != nil {\n\t\treturn err\n\t}\n\n\treturn chanBucket.Put(key, w.Bytes())\n}\n\n// GetOptionalUpfrontShutdownScript reads the shutdown script stored under the\n// key provided if it is present. Upfront shutdown scripts are optional, so the\n// function returns with no error if the key is not present.",
      "length": 460,
      "tokens": 79,
      "embedding": []
    },
    {
      "slug": "func GetOptionalUpfrontShutdownScript(chanBucket kvdb.RBucket, key []byte,",
      "content": "func GetOptionalUpfrontShutdownScript(chanBucket kvdb.RBucket, key []byte,\n\tscript *lnwire.DeliveryAddress) error {\n\n\t// Return early if the bucket does not exit, a shutdown script was not\n\t// set.\n\tbs := chanBucket.Get(key)\n\tif bs == nil {\n\t\treturn nil\n\t}\n\n\tvar tempScript []byte\n\tr := bytes.NewReader(bs)\n\tif err := mig.ReadElement(r, &tempScript); err != nil {\n\t\treturn err\n\t}\n\t*script = tempScript\n\n\treturn nil\n}\n\n// FetchChanCommitments fetches both the local and remote commitments. This\n// function is exported so it can be used by later migrations.",
      "length": 461,
      "tokens": 77,
      "embedding": []
    },
    {
      "slug": "func FetchChanCommitments(chanBucket kvdb.RBucket, channel *OpenChannel) error {",
      "content": "func FetchChanCommitments(chanBucket kvdb.RBucket, channel *OpenChannel) error {\n\tvar err error\n\n\t// If this is a restored channel, then we don't have any commitments to\n\t// read.\n\tif channel.hasChanStatus(ChanStatusRestored) {\n\t\treturn nil\n\t}\n\n\tchannel.LocalCommitment, err = FetchChanCommitment(chanBucket, true)\n\tif err != nil {\n\t\treturn err\n\t}\n\tchannel.RemoteCommitment, err = FetchChanCommitment(chanBucket, false)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// FetchChanCommitment fetches a channel commitment. This function is exported\n// so it can be used by later migrations.",
      "length": 487,
      "tokens": 73,
      "embedding": []
    },
    {
      "slug": "func FetchChanCommitment(chanBucket kvdb.RBucket,",
      "content": "func FetchChanCommitment(chanBucket kvdb.RBucket,\n\tlocal bool) (mig.ChannelCommitment, error) {\n\n\tcommitKey := chanCommitmentKey\n\tif local {\n\t\tcommitKey = append(commitKey, byte(0x00))\n\t} else {\n\t\tcommitKey = append(commitKey, byte(0x01))\n\t}\n\n\tcommitBytes := chanBucket.Get(commitKey)\n\tif commitBytes == nil {\n\t\treturn mig.ChannelCommitment{}, ErrNoCommitmentsFound\n\t}\n\n\tr := bytes.NewReader(commitBytes)\n\treturn mig.DeserializeChanCommit(r)\n}\n",
      "length": 377,
      "tokens": 41,
      "embedding": []
    },
    {
      "slug": "func PutChanCommitment(chanBucket kvdb.RwBucket, c *mig.ChannelCommitment,",
      "content": "func PutChanCommitment(chanBucket kvdb.RwBucket, c *mig.ChannelCommitment,\n\tlocal bool) error {\n\n\tcommitKey := chanCommitmentKey\n\tif local {\n\t\tcommitKey = append(commitKey, byte(0x00))\n\t} else {\n\t\tcommitKey = append(commitKey, byte(0x01))\n\t}\n\n\tvar b bytes.Buffer\n\tif err := mig.SerializeChanCommit(&b, c); err != nil {\n\t\treturn err\n\t}\n\n\treturn chanBucket.Put(commitKey, b.Bytes())\n}\n",
      "length": 292,
      "tokens": 41,
      "embedding": []
    },
    {
      "slug": "func PutChanCommitments(chanBucket kvdb.RwBucket, channel *OpenChannel) error {",
      "content": "func PutChanCommitments(chanBucket kvdb.RwBucket, channel *OpenChannel) error {\n\t// If this is a restored channel, then we don't have any commitments to\n\t// write.\n\tif channel.hasChanStatus(ChanStatusRestored) {\n\t\treturn nil\n\t}\n\n\terr := PutChanCommitment(\n\t\tchanBucket, &channel.LocalCommitment, true,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn PutChanCommitment(\n\t\tchanBucket, &channel.RemoteCommitment, false,\n\t)\n}\n\n// balancesAtHeight returns the local and remote balances on our commitment\n// transactions as of a given height. This function is not exported as it's\n// deprecated.\n//\n// NOTE: these are our balances *after* subtracting the commitment fee and\n// anchor outputs.",
      "length": 580,
      "tokens": 87,
      "embedding": []
    },
    {
      "slug": "func (c *OpenChannel) balancesAtHeight(chanBucket kvdb.RBucket,",
      "content": "func (c *OpenChannel) balancesAtHeight(chanBucket kvdb.RBucket,\n\theight uint64) (lnwire.MilliSatoshi, lnwire.MilliSatoshi, error) {\n\n\t// If our current commit is as the desired height, we can return our\n\t// current balances.\n\tif c.LocalCommitment.CommitHeight == height {\n\t\treturn c.LocalCommitment.LocalBalance,\n\t\t\tc.LocalCommitment.RemoteBalance, nil\n\t}\n\n\t// If our current remote commit is at the desired height, we can return\n\t// the current balances.\n\tif c.RemoteCommitment.CommitHeight == height {\n\t\treturn c.RemoteCommitment.LocalBalance,\n\t\t\tc.RemoteCommitment.RemoteBalance, nil\n\t}\n\n\t// If we are not currently on the height requested, we need to look up\n\t// the previous height to obtain our balances at the given height.\n\tcommit, err := c.FindPreviousStateLegacy(chanBucket, height)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\treturn commit.LocalBalance, commit.RemoteBalance, nil\n}\n\n// FindPreviousStateLegacy scans through the append-only log in an attempt to\n// recover the previous channel state indicated by the update number. This\n// method is intended to be used for obtaining the relevant data needed to\n// claim all funds rightfully spendable in the case of an on-chain broadcast of\n// the commitment transaction.",
      "length": 1135,
      "tokens": 163,
      "embedding": []
    },
    {
      "slug": "func (c *OpenChannel) FindPreviousStateLegacy(chanBucket kvdb.RBucket,",
      "content": "func (c *OpenChannel) FindPreviousStateLegacy(chanBucket kvdb.RBucket,\n\tupdateNum uint64) (*mig.ChannelCommitment, error) {\n\n\tc.RLock()\n\tdefer c.RUnlock()\n\n\tlogBucket := chanBucket.NestedReadBucket(revocationLogBucketLegacy)\n\tif logBucket == nil {\n\t\treturn nil, ErrNoPastDeltas\n\t}\n\n\tcommit, err := fetchChannelLogEntry(logBucket, updateNum)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &commit, nil\n}\n",
      "length": 315,
      "tokens": 38,
      "embedding": []
    },
    {
      "slug": "func fetchChannelLogEntry(log kvdb.RBucket,",
      "content": "func fetchChannelLogEntry(log kvdb.RBucket,\n\tupdateNum uint64) (mig.ChannelCommitment, error) {\n\n\tlogEntrykey := mig24.MakeLogKey(updateNum)\n\tcommitBytes := log.Get(logEntrykey[:])\n\tif commitBytes == nil {\n\t\treturn mig.ChannelCommitment{}, ErrLogEntryNotFound\n\t}\n\n\tcommitReader := bytes.NewReader(commitBytes)\n\treturn mig.DeserializeChanCommit(commitReader)\n}\n",
      "length": 305,
      "tokens": 26,
      "embedding": []
    },
    {
      "slug": "func CreateChanBucket(tx kvdb.RwTx, c *OpenChannel) (kvdb.RwBucket, error) {",
      "content": "func CreateChanBucket(tx kvdb.RwTx, c *OpenChannel) (kvdb.RwBucket, error) {\n\t// First fetch the top level bucket which stores all data related to\n\t// current, active channels.\n\topenChanBucket, err := tx.CreateTopLevelBucket(openChannelBucket)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Within this top level bucket, fetch the bucket dedicated to storing\n\t// open channel data specific to the remote node.\n\tnodePub := c.IdentityPub.SerializeCompressed()\n\tnodeChanBucket, err := openChanBucket.CreateBucketIfNotExists(nodePub)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// We'll then recurse down an additional layer in order to fetch the\n\t// bucket for this particular chain.\n\tchainBucket, err := nodeChanBucket.CreateBucketIfNotExists(\n\t\tc.ChainHash[:],\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar chanPointBuf bytes.Buffer\n\terr = mig.WriteOutpoint(&chanPointBuf, &c.FundingOutpoint)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// With the bucket for the node fetched, we can now go down another\n\t// level, creating the bucket for this channel itself.\n\treturn chainBucket.CreateBucketIfNotExists(chanPointBuf.Bytes())\n}\n",
      "length": 1006,
      "tokens": 143,
      "embedding": []
    }
  ]
}