{
  "filepath": "../implementations/go/lnd/channeldb/migration25/migration.go",
  "package": "migration25",
  "sections": [
    {
      "slug": "func MigrateInitialBalances(tx kvdb.RwTx) error {",
      "content": "func MigrateInitialBalances(tx kvdb.RwTx) error {\n\tlog.Infof(\"Migrating initial local and remote balances...\")\n\n\topenChanBucket := tx.ReadWriteBucket(openChannelBucket)\n\n\t// If no bucket is found, we can exit early.\n\tif openChanBucket == nil {\n\t\treturn nil\n\t}\n\n\t// Read a list of open channels.\n\tchannels, err := findOpenChannels(openChanBucket)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Migrate the balances.\n\tfor _, c := range channels {\n\t\tif err := migrateBalances(tx, c); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn err\n}\n\n// findOpenChannels finds all open channels.",
      "length": 491,
      "tokens": 79,
      "embedding": []
    },
    {
      "slug": "func findOpenChannels(openChanBucket kvdb.RBucket) ([]*OpenChannel, error) {",
      "content": "func findOpenChannels(openChanBucket kvdb.RBucket) ([]*OpenChannel, error) {\n\tchannels := []*OpenChannel{}\n\n\t// readChannel is a helper closure that reads the channel info from the\n\t// channel bucket.\n\treadChannel := func(chainBucket kvdb.RBucket, cp []byte) error {\n\t\tc := &OpenChannel{}\n\n\t\t// Read the sub-bucket level 3.\n\t\tchanBucket := chainBucket.NestedReadBucket(\n\t\t\tcp,\n\t\t)\n\t\tif chanBucket == nil {\n\t\t\tlog.Errorf(\"unable to read bucket for chanPoint=%x\", cp)\n\t\t\treturn nil\n\t\t}\n\t\t// Get the old channel info.\n\t\tif err := fetchChanInfo(chanBucket, c, true); err != nil {\n\t\t\treturn fmt.Errorf(\"unable to fetch chan info: %v\", err)\n\t\t}\n\n\t\t// Fetch the channel commitments, which are useful for freshly\n\t\t// open channels as they don't have any revocation logs and\n\t\t// their current commitments reflect the initial balances.\n\t\tif err := FetchChanCommitments(chanBucket, c); err != nil {\n\t\t\treturn fmt.Errorf(\"unable to fetch chan commits: %v\",\n\t\t\t\terr)\n\t\t}\n\n\t\tchannels = append(channels, c)\n\n\t\treturn nil\n\t}\n\n\t// Iterate the root bucket.\n\terr := openChanBucket.ForEach(func(nodePub, v []byte) error {\n\t\t// Ensure that this is a key the same size as a pubkey, and\n\t\t// also that it leads directly to a bucket.\n\t\tif len(nodePub) != 33 || v != nil {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Read the sub-bucket level 1.\n\t\tnodeChanBucket := openChanBucket.NestedReadBucket(nodePub)\n\t\tif nodeChanBucket == nil {\n\t\t\tlog.Errorf(\"no bucket for node %x\", nodePub)\n\t\t\treturn nil\n\t\t}\n\n\t\t// Iterate the bucket.\n\t\treturn nodeChanBucket.ForEach(func(chainHash, _ []byte) error {\n\t\t\t// Read the sub-bucket level 2.\n\t\t\tchainBucket := nodeChanBucket.NestedReadBucket(\n\t\t\t\tchainHash,\n\t\t\t)\n\t\t\tif chainBucket == nil {\n\t\t\t\tlog.Errorf(\"unable to read bucket for chain=%x\",\n\t\t\t\t\tchainHash)\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Iterate the bucket.\n\t\t\treturn chainBucket.ForEach(func(cp, _ []byte) error {\n\t\t\t\treturn readChannel(chainBucket, cp)\n\t\t\t})\n\t\t})\n\t})\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn channels, nil\n}\n\n// migrateBalances queries the revocation log at height 0 to find the initial\n// balances and save them to the channel info.",
      "length": 1949,
      "tokens": 292,
      "embedding": []
    },
    {
      "slug": "func migrateBalances(tx kvdb.RwTx, c *OpenChannel) error {",
      "content": "func migrateBalances(tx kvdb.RwTx, c *OpenChannel) error {\n\t// Get the bucket.\n\tchanBucket, err := FetchChanBucket(tx, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Get the initial balances.\n\tlocalAmt, remoteAmt, err := c.balancesAtHeight(chanBucket, 0)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to get initial balances: %v\", err)\n\t}\n\n\tc.InitialLocalBalance = localAmt\n\tc.InitialRemoteBalance = remoteAmt\n\n\t// Update the channel info.\n\tif err := putChanInfo(chanBucket, c, false); err != nil {\n\t\treturn fmt.Errorf(\"unable to put chan info: %v\", err)\n\t}\n\n\treturn nil\n}\n\n// FetchChanBucket is a helper function that returns the bucket where a\n// channel's data resides in given: the public key for the node, the outpoint,\n// and the chainhash that the channel resides on.",
      "length": 683,
      "tokens": 110,
      "embedding": []
    },
    {
      "slug": "func FetchChanBucket(tx kvdb.RwTx, c *OpenChannel) (kvdb.RwBucket, error) {",
      "content": "func FetchChanBucket(tx kvdb.RwTx, c *OpenChannel) (kvdb.RwBucket, error) {\n\t// First fetch the top level bucket which stores all data related to\n\t// current, active channels.\n\topenChanBucket := tx.ReadWriteBucket(openChannelBucket)\n\tif openChanBucket == nil {\n\t\treturn nil, ErrNoChanDBExists\n\t}\n\n\t// Within this top level bucket, fetch the bucket dedicated to storing\n\t// open channel data specific to the remote node.\n\tnodePub := c.IdentityPub.SerializeCompressed()\n\tnodeChanBucket := openChanBucket.NestedReadWriteBucket(nodePub)\n\tif nodeChanBucket == nil {\n\t\treturn nil, ErrNoActiveChannels\n\t}\n\n\t// We'll then recurse down an additional layer in order to fetch the\n\t// bucket for this particular chain.\n\tchainBucket := nodeChanBucket.NestedReadWriteBucket(c.ChainHash[:])\n\tif chainBucket == nil {\n\t\treturn nil, ErrNoActiveChannels\n\t}\n\n\t// With the bucket for the node and chain fetched, we can now go down\n\t// another level, for this channel itself.\n\tvar chanPointBuf bytes.Buffer\n\terr := mig.WriteOutpoint(&chanPointBuf, &c.FundingOutpoint)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tchanBucket := chainBucket.NestedReadWriteBucket(chanPointBuf.Bytes())\n\tif chanBucket == nil {\n\t\treturn nil, ErrChannelNotFound\n\t}\n\n\treturn chanBucket, nil\n}\n",
      "length": 1130,
      "tokens": 150,
      "embedding": []
    }
  ]
}