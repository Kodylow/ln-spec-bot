{
  "filepath": "../implementations/go/lnd/channeldb/graph_cache.go",
  "package": "channeldb",
  "sections": [
    {
      "slug": "type GraphCacheNode interface {",
      "content": "type GraphCacheNode interface {\n\t// PubKey is the node's public identity key.\n\tPubKey() route.Vertex\n\n\t// Features returns the node's p2p features.\n\tFeatures() *lnwire.FeatureVector\n\n\t// ForEachChannel iterates through all channels of a given node,\n\t// executing the passed callback with an edge info structure and the\n\t// policies of each end of the channel. The first edge policy is the\n\t// outgoing edge *to* the connecting node, while the second is the\n\t// incoming edge *from* the connecting node. If the callback returns an\n\t// error, then the iteration is halted with the error propagated back up\n\t// to the caller.\n\tForEachChannel(kvdb.RTx,\n\t\tfunc(kvdb.RTx, *ChannelEdgeInfo, *ChannelEdgePolicy,\n\t\t\t*ChannelEdgePolicy) error) error\n}\n\n// CachedEdgePolicy is a struct that only caches the information of a\n// ChannelEdgePolicy that we actually use for pathfinding and therefore need to\n// store in the cache.",
      "length": 863,
      "tokens": 133,
      "embedding": []
    },
    {
      "slug": "type CachedEdgePolicy struct {",
      "content": "type CachedEdgePolicy struct {\n\t// ChannelID is the unique channel ID for the channel. The first 3\n\t// bytes are the block height, the next 3 the index within the block,\n\t// and the last 2 bytes are the output index for the channel.\n\tChannelID uint64\n\n\t// MessageFlags is a bitfield which indicates the presence of optional\n\t// fields (like max_htlc) in the policy.\n\tMessageFlags lnwire.ChanUpdateMsgFlags\n\n\t// ChannelFlags is a bitfield which signals the capabilities of the\n\t// channel as well as the directed edge this update applies to.\n\tChannelFlags lnwire.ChanUpdateChanFlags\n\n\t// TimeLockDelta is the number of blocks this node will subtract from\n\t// the expiry of an incoming HTLC. This value expresses the time buffer\n\t// the node would like to HTLC exchanges.\n\tTimeLockDelta uint16\n\n\t// MinHTLC is the smallest value HTLC this node will forward, expressed\n\t// in millisatoshi.\n\tMinHTLC lnwire.MilliSatoshi\n\n\t// MaxHTLC is the largest value HTLC this node will forward, expressed\n\t// in millisatoshi.\n\tMaxHTLC lnwire.MilliSatoshi\n\n\t// FeeBaseMSat is the base HTLC fee that will be charged for forwarding\n\t// ANY HTLC, expressed in mSAT's.\n\tFeeBaseMSat lnwire.MilliSatoshi\n\n\t// FeeProportionalMillionths is the rate that the node will charge for\n\t// HTLCs for each millionth of a satoshi forwarded.\n\tFeeProportionalMillionths lnwire.MilliSatoshi\n\n\t// ToNodePubKey is a function that returns the to node of a policy.\n\t// Since we only ever store the inbound policy, this is always the node\n\t// that we query the channels for in ForEachChannel(). Therefore, we can\n\t// save a lot of space by not storing this information in the memory and\n\t// instead just set this function when we copy the policy from cache in\n\t// ForEachChannel().\n\tToNodePubKey func() route.Vertex\n\n\t// ToNodeFeatures are the to node's features. They are never set while\n\t// the edge is in the cache, only on the copy that is returned in\n\t// ForEachChannel().\n\tToNodeFeatures *lnwire.FeatureVector\n}\n\n// ComputeFee computes the fee to forward an HTLC of `amt` milli-satoshis over\n// the passed active payment channel. This value is currently computed as\n// specified in BOLT07, but will likely change in the near future.",
      "length": 2115,
      "tokens": 341,
      "embedding": []
    },
    {
      "slug": "func (c *CachedEdgePolicy) ComputeFee(",
      "content": "func (c *CachedEdgePolicy) ComputeFee(\n\tamt lnwire.MilliSatoshi) lnwire.MilliSatoshi {\n\n\treturn c.FeeBaseMSat + (amt*c.FeeProportionalMillionths)/feeRateParts\n}\n\n// ComputeFeeFromIncoming computes the fee to forward an HTLC given the incoming\n// amount.",
      "length": 208,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *CachedEdgePolicy) ComputeFeeFromIncoming(",
      "content": "func (c *CachedEdgePolicy) ComputeFeeFromIncoming(\n\tincomingAmt lnwire.MilliSatoshi) lnwire.MilliSatoshi {\n\n\treturn incomingAmt - divideCeil(\n\t\tfeeRateParts*(incomingAmt-c.FeeBaseMSat),\n\t\tfeeRateParts+c.FeeProportionalMillionths,\n\t)\n}\n\n// NewCachedPolicy turns a full policy into a minimal one that can be cached.",
      "length": 254,
      "tokens": 26,
      "embedding": []
    },
    {
      "slug": "func NewCachedPolicy(policy *ChannelEdgePolicy) *CachedEdgePolicy {",
      "content": "func NewCachedPolicy(policy *ChannelEdgePolicy) *CachedEdgePolicy {\n\treturn &CachedEdgePolicy{\n\t\tChannelID:                 policy.ChannelID,\n\t\tMessageFlags:              policy.MessageFlags,\n\t\tChannelFlags:              policy.ChannelFlags,\n\t\tTimeLockDelta:             policy.TimeLockDelta,\n\t\tMinHTLC:                   policy.MinHTLC,\n\t\tMaxHTLC:                   policy.MaxHTLC,\n\t\tFeeBaseMSat:               policy.FeeBaseMSat,\n\t\tFeeProportionalMillionths: policy.FeeProportionalMillionths,\n\t}\n}\n\n// DirectedChannel is a type that stores the channel information as seen from\n// one side of the channel.",
      "length": 525,
      "tokens": 39,
      "embedding": []
    },
    {
      "slug": "type DirectedChannel struct {",
      "content": "type DirectedChannel struct {\n\t// ChannelID is the unique identifier of this channel.\n\tChannelID uint64\n\n\t// IsNode1 indicates if this is the node with the smaller public key.\n\tIsNode1 bool\n\n\t// OtherNode is the public key of the node on the other end of this\n\t// channel.\n\tOtherNode route.Vertex\n\n\t// Capacity is the announced capacity of this channel in satoshis.\n\tCapacity btcutil.Amount\n\n\t// OutPolicySet is a boolean that indicates whether the node has an\n\t// outgoing policy set. For pathfinding only the existence of the policy\n\t// is important to know, not the actual content.\n\tOutPolicySet bool\n\n\t// InPolicy is the incoming policy *from* the other node to this node.\n\t// In path finding, we're walking backward from the destination to the\n\t// source, so we're always interested in the edge that arrives to us\n\t// from the other node.\n\tInPolicy *CachedEdgePolicy\n}\n\n// DeepCopy creates a deep copy of the channel, including the incoming policy.",
      "length": 898,
      "tokens": 152,
      "embedding": []
    },
    {
      "slug": "func (c *DirectedChannel) DeepCopy() *DirectedChannel {",
      "content": "func (c *DirectedChannel) DeepCopy() *DirectedChannel {\n\tchannelCopy := *c\n\n\tif channelCopy.InPolicy != nil {\n\t\tinPolicyCopy := *channelCopy.InPolicy\n\t\tchannelCopy.InPolicy = &inPolicyCopy\n\n\t\t// The fields for the ToNode can be overwritten by the path\n\t\t// finding algorithm, which is why we need a deep copy in the\n\t\t// first place. So we always start out with nil values, just to\n\t\t// be sure they don't contain any old data.\n\t\tchannelCopy.InPolicy.ToNodePubKey = nil\n\t\tchannelCopy.InPolicy.ToNodeFeatures = nil\n\t}\n\n\treturn &channelCopy\n}\n\n// GraphCache is a type that holds a minimal set of information of the public\n// channel graph that can be used for pathfinding.",
      "length": 596,
      "tokens": 95,
      "embedding": []
    },
    {
      "slug": "type GraphCache struct {",
      "content": "type GraphCache struct {\n\tnodeChannels map[route.Vertex]map[uint64]*DirectedChannel\n\tnodeFeatures map[route.Vertex]*lnwire.FeatureVector\n\n\tmtx sync.RWMutex\n}\n\n// NewGraphCache creates a new graphCache.",
      "length": 170,
      "tokens": 13,
      "embedding": []
    },
    {
      "slug": "func NewGraphCache(preAllocNumNodes int) *GraphCache {",
      "content": "func NewGraphCache(preAllocNumNodes int) *GraphCache {\n\treturn &GraphCache{\n\t\tnodeChannels: make(\n\t\t\tmap[route.Vertex]map[uint64]*DirectedChannel,\n\t\t\t// A channel connects two nodes, so we can look it up\n\t\t\t// from both sides, meaning we get double the number of\n\t\t\t// entries.\n\t\t\tpreAllocNumNodes*2,\n\t\t),\n\t\tnodeFeatures: make(\n\t\t\tmap[route.Vertex]*lnwire.FeatureVector,\n\t\t\tpreAllocNumNodes,\n\t\t),\n\t}\n}\n\n// Stats returns statistics about the current cache size.",
      "length": 390,
      "tokens": 48,
      "embedding": []
    },
    {
      "slug": "func (c *GraphCache) Stats() string {",
      "content": "func (c *GraphCache) Stats() string {\n\tc.mtx.RLock()\n\tdefer c.mtx.RUnlock()\n\n\tnumChannels := 0\n\tfor node := range c.nodeChannels {\n\t\tnumChannels += len(c.nodeChannels[node])\n\t}\n\treturn fmt.Sprintf(\"num_node_features=%d, num_nodes=%d, \"+\n\t\t\"num_channels=%d\", len(c.nodeFeatures), len(c.nodeChannels),\n\t\tnumChannels)\n}\n\n// AddNodeFeatures adds a graph node and its features to the cache.",
      "length": 335,
      "tokens": 37,
      "embedding": []
    },
    {
      "slug": "func (c *GraphCache) AddNodeFeatures(node GraphCacheNode) {",
      "content": "func (c *GraphCache) AddNodeFeatures(node GraphCacheNode) {\n\tnodePubKey := node.PubKey()\n\n\t// Only hold the lock for a short time. The `ForEachChannel()` below is\n\t// possibly slow as it has to go to the backend, so we can unlock\n\t// between the calls. And the AddChannel() method will acquire its own\n\t// lock anyway.\n\tc.mtx.Lock()\n\tc.nodeFeatures[nodePubKey] = node.Features()\n\tc.mtx.Unlock()\n}\n\n// AddNode adds a graph node, including all the (directed) channels of that\n// node.",
      "length": 410,
      "tokens": 67,
      "embedding": []
    },
    {
      "slug": "func (c *GraphCache) AddNode(tx kvdb.RTx, node GraphCacheNode) error {",
      "content": "func (c *GraphCache) AddNode(tx kvdb.RTx, node GraphCacheNode) error {\n\tc.AddNodeFeatures(node)\n\n\treturn node.ForEachChannel(\n\t\ttx, func(tx kvdb.RTx, info *ChannelEdgeInfo,\n\t\t\toutPolicy *ChannelEdgePolicy,\n\t\t\tinPolicy *ChannelEdgePolicy) error {\n\n\t\t\tc.AddChannel(info, outPolicy, inPolicy)\n\n\t\t\treturn nil\n\t\t},\n\t)\n}\n\n// AddChannel adds a non-directed channel, meaning that the order of policy 1\n// and policy 2 does not matter, the directionality is extracted from the info\n// and policy flags automatically. The policy will be set as the outgoing policy\n// on one node and the incoming policy on the peer's side.",
      "length": 524,
      "tokens": 75,
      "embedding": []
    },
    {
      "slug": "func (c *GraphCache) AddChannel(info *ChannelEdgeInfo,",
      "content": "func (c *GraphCache) AddChannel(info *ChannelEdgeInfo,\n\tpolicy1 *ChannelEdgePolicy, policy2 *ChannelEdgePolicy) {\n\n\tif info == nil {\n\t\treturn\n\t}\n\n\tif policy1 != nil && policy1.IsDisabled() &&\n\t\tpolicy2 != nil && policy2.IsDisabled() {\n\n\t\treturn\n\t}\n\n\t// Create the edge entry for both nodes.\n\tc.mtx.Lock()\n\tc.updateOrAddEdge(info.NodeKey1Bytes, &DirectedChannel{\n\t\tChannelID: info.ChannelID,\n\t\tIsNode1:   true,\n\t\tOtherNode: info.NodeKey2Bytes,\n\t\tCapacity:  info.Capacity,\n\t})\n\tc.updateOrAddEdge(info.NodeKey2Bytes, &DirectedChannel{\n\t\tChannelID: info.ChannelID,\n\t\tIsNode1:   false,\n\t\tOtherNode: info.NodeKey1Bytes,\n\t\tCapacity:  info.Capacity,\n\t})\n\tc.mtx.Unlock()\n\n\t// The policy's node is always the to_node. So if policy 1 has to_node\n\t// of node 2 then we have the policy 1 as seen from node 1.\n\tif policy1 != nil {\n\t\tfromNode, toNode := info.NodeKey1Bytes, info.NodeKey2Bytes\n\t\tif policy1.Node.PubKeyBytes != info.NodeKey2Bytes {\n\t\t\tfromNode, toNode = toNode, fromNode\n\t\t}\n\t\tisEdge1 := policy1.ChannelFlags&lnwire.ChanUpdateDirection == 0\n\t\tc.UpdatePolicy(policy1, fromNode, toNode, isEdge1)\n\t}\n\tif policy2 != nil {\n\t\tfromNode, toNode := info.NodeKey2Bytes, info.NodeKey1Bytes\n\t\tif policy2.Node.PubKeyBytes != info.NodeKey1Bytes {\n\t\t\tfromNode, toNode = toNode, fromNode\n\t\t}\n\t\tisEdge1 := policy2.ChannelFlags&lnwire.ChanUpdateDirection == 0\n\t\tc.UpdatePolicy(policy2, fromNode, toNode, isEdge1)\n\t}\n}\n\n// updateOrAddEdge makes sure the edge information for a node is either updated\n// if it already exists or is added to that node's list of channels.",
      "length": 1445,
      "tokens": 178,
      "embedding": []
    },
    {
      "slug": "func (c *GraphCache) updateOrAddEdge(node route.Vertex, edge *DirectedChannel) {",
      "content": "func (c *GraphCache) updateOrAddEdge(node route.Vertex, edge *DirectedChannel) {\n\tif len(c.nodeChannels[node]) == 0 {\n\t\tc.nodeChannels[node] = make(map[uint64]*DirectedChannel)\n\t}\n\n\tc.nodeChannels[node][edge.ChannelID] = edge\n}\n\n// UpdatePolicy updates a single policy on both the from and to node. The order\n// of the from and to node is not strictly important. But we assume that a\n// channel edge was added beforehand so that the directed channel struct already\n// exists in the cache.",
      "length": 397,
      "tokens": 62,
      "embedding": []
    },
    {
      "slug": "func (c *GraphCache) UpdatePolicy(policy *ChannelEdgePolicy, fromNode,",
      "content": "func (c *GraphCache) UpdatePolicy(policy *ChannelEdgePolicy, fromNode,\n\ttoNode route.Vertex, edge1 bool) {\n\n\tc.mtx.Lock()\n\tdefer c.mtx.Unlock()\n\n\tupdatePolicy := func(nodeKey route.Vertex) {\n\t\tif len(c.nodeChannels[nodeKey]) == 0 {\n\t\t\treturn\n\t\t}\n\n\t\tchannel, ok := c.nodeChannels[nodeKey][policy.ChannelID]\n\t\tif !ok {\n\t\t\treturn\n\t\t}\n\n\t\t// Edge 1 is defined as the policy for the direction of node1 to\n\t\t// node2.\n\t\tswitch {\n\t\t// This is node 1, and it is edge 1, so this is the outgoing\n\t\t// policy for node 1.\n\t\tcase channel.IsNode1 && edge1:\n\t\t\tchannel.OutPolicySet = true\n\n\t\t// This is node 2, and it is edge 2, so this is the outgoing\n\t\t// policy for node 2.\n\t\tcase !channel.IsNode1 && !edge1:\n\t\t\tchannel.OutPolicySet = true\n\n\t\t// The other two cases left mean it's the inbound policy for the\n\t\t// node.\n\t\tdefault:\n\t\t\tchannel.InPolicy = NewCachedPolicy(policy)\n\t\t}\n\t}\n\n\tupdatePolicy(fromNode)\n\tupdatePolicy(toNode)\n}\n\n// RemoveNode completely removes a node and all its channels (including the\n// peer's side).",
      "length": 901,
      "tokens": 140,
      "embedding": []
    },
    {
      "slug": "func (c *GraphCache) RemoveNode(node route.Vertex) {",
      "content": "func (c *GraphCache) RemoveNode(node route.Vertex) {\n\tc.mtx.Lock()\n\tdefer c.mtx.Unlock()\n\n\tdelete(c.nodeFeatures, node)\n\n\t// First remove all channels from the other nodes' lists.\n\tfor _, channel := range c.nodeChannels[node] {\n\t\tc.removeChannelIfFound(channel.OtherNode, channel.ChannelID)\n\t}\n\n\t// Then remove our whole node completely.\n\tdelete(c.nodeChannels, node)\n}\n\n// RemoveChannel removes a single channel between two nodes.",
      "length": 364,
      "tokens": 44,
      "embedding": []
    },
    {
      "slug": "func (c *GraphCache) RemoveChannel(node1, node2 route.Vertex, chanID uint64) {",
      "content": "func (c *GraphCache) RemoveChannel(node1, node2 route.Vertex, chanID uint64) {\n\tc.mtx.Lock()\n\tdefer c.mtx.Unlock()\n\n\t// Remove that one channel from both sides.\n\tc.removeChannelIfFound(node1, chanID)\n\tc.removeChannelIfFound(node2, chanID)\n}\n\n// removeChannelIfFound removes a single channel from one side.",
      "length": 218,
      "tokens": 25,
      "embedding": []
    },
    {
      "slug": "func (c *GraphCache) removeChannelIfFound(node route.Vertex, chanID uint64) {",
      "content": "func (c *GraphCache) removeChannelIfFound(node route.Vertex, chanID uint64) {\n\tif len(c.nodeChannels[node]) == 0 {\n\t\treturn\n\t}\n\n\tdelete(c.nodeChannels[node], chanID)\n}\n\n// UpdateChannel updates the channel edge information for a specific edge. We\n// expect the edge to already exist and be known. If it does not yet exist, this\n// call is a no-op.",
      "length": 260,
      "tokens": 44,
      "embedding": []
    },
    {
      "slug": "func (c *GraphCache) UpdateChannel(info *ChannelEdgeInfo) {",
      "content": "func (c *GraphCache) UpdateChannel(info *ChannelEdgeInfo) {\n\tc.mtx.Lock()\n\tdefer c.mtx.Unlock()\n\n\tif len(c.nodeChannels[info.NodeKey1Bytes]) == 0 ||\n\t\tlen(c.nodeChannels[info.NodeKey2Bytes]) == 0 {\n\n\t\treturn\n\t}\n\n\tchannel, ok := c.nodeChannels[info.NodeKey1Bytes][info.ChannelID]\n\tif ok {\n\t\t// We only expect to be called when the channel is already\n\t\t// known.\n\t\tchannel.Capacity = info.Capacity\n\t\tchannel.OtherNode = info.NodeKey2Bytes\n\t}\n\n\tchannel, ok = c.nodeChannels[info.NodeKey2Bytes][info.ChannelID]\n\tif ok {\n\t\tchannel.Capacity = info.Capacity\n\t\tchannel.OtherNode = info.NodeKey1Bytes\n\t}\n}\n\n// getChannels returns a copy of the passed node's channels or nil if there\n// isn't any.",
      "length": 602,
      "tokens": 74,
      "embedding": []
    },
    {
      "slug": "func (c *GraphCache) getChannels(node route.Vertex) []*DirectedChannel {",
      "content": "func (c *GraphCache) getChannels(node route.Vertex) []*DirectedChannel {\n\tc.mtx.RLock()\n\tdefer c.mtx.RUnlock()\n\n\tchannels, ok := c.nodeChannels[node]\n\tif !ok {\n\t\treturn nil\n\t}\n\n\tfeatures, ok := c.nodeFeatures[node]\n\tif !ok {\n\t\t// If the features were set to nil explicitly, that's fine here.\n\t\t// The router will overwrite the features of the destination\n\t\t// node with those found in the invoice if necessary. But if we\n\t\t// didn't yet get a node announcement we want to mimic the\n\t\t// behavior of the old DB based code that would always set an\n\t\t// empty feature vector instead of leaving it nil.\n\t\tfeatures = lnwire.EmptyFeatureVector()\n\t}\n\n\ttoNodeCallback := func() route.Vertex {\n\t\treturn node\n\t}\n\n\ti := 0\n\tchannelsCopy := make([]*DirectedChannel, len(channels))\n\tfor _, channel := range channels {\n\t\t// We need to copy the channel and policy to avoid it being\n\t\t// updated in the cache if the path finding algorithm sets\n\t\t// fields on it (currently only the ToNodeFeatures of the\n\t\t// policy).\n\t\tchannelCopy := channel.DeepCopy()\n\t\tif channelCopy.InPolicy != nil {\n\t\t\tchannelCopy.InPolicy.ToNodePubKey = toNodeCallback\n\t\t\tchannelCopy.InPolicy.ToNodeFeatures = features\n\t\t}\n\n\t\tchannelsCopy[i] = channelCopy\n\t\ti++\n\t}\n\n\treturn channelsCopy\n}\n\n// ForEachChannel invokes the given callback for each channel of the given node.",
      "length": 1211,
      "tokens": 187,
      "embedding": []
    },
    {
      "slug": "func (c *GraphCache) ForEachChannel(node route.Vertex,",
      "content": "func (c *GraphCache) ForEachChannel(node route.Vertex,\n\tcb func(channel *DirectedChannel) error) error {\n\n\t// Obtain a copy of the node's channels. We need do this in order to\n\t// avoid deadlocks caused by interaction with the graph cache, channel\n\t// state and the graph database from multiple goroutines. This snapshot\n\t// is only used for path finding where being stale is acceptable since\n\t// the real world graph and our representation may always become\n\t// slightly out of sync for a short time and the actual channel state\n\t// is stored separately.\n\tchannels := c.getChannels(node)\n\tfor _, channel := range channels {\n\t\tif err := cb(channel); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// ForEachNode iterates over the adjacency list of the graph, executing the\n// call back for each node and the set of channels that emanate from the given\n// node.\n//\n// NOTE: This method should be considered _read only_, the channels or nodes\n// passed in MUST NOT be modified.",
      "length": 899,
      "tokens": 161,
      "embedding": []
    },
    {
      "slug": "func (c *GraphCache) ForEachNode(cb func(node route.Vertex,",
      "content": "func (c *GraphCache) ForEachNode(cb func(node route.Vertex,\n\tchannels map[uint64]*DirectedChannel) error) error {\n\n\tc.mtx.RLock()\n\tdefer c.mtx.RUnlock()\n\n\tfor node, channels := range c.nodeChannels {\n\t\t// We don't make a copy here since this is a read-only RPC\n\t\t// call. We also don't need the node features either for this\n\t\t// call.\n\t\tif err := cb(node, channels); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// GetFeatures returns the features of the node with the given ID. If no\n// features are known for the node, an empty feature vector is returned.",
      "length": 485,
      "tokens": 85,
      "embedding": []
    },
    {
      "slug": "func (c *GraphCache) GetFeatures(node route.Vertex) *lnwire.FeatureVector {",
      "content": "func (c *GraphCache) GetFeatures(node route.Vertex) *lnwire.FeatureVector {\n\tc.mtx.RLock()\n\tdefer c.mtx.RUnlock()\n\n\tfeatures, ok := c.nodeFeatures[node]\n\tif !ok || features == nil {\n\t\t// The router expects the features to never be nil, so we return\n\t\t// an empty feature set instead.\n\t\treturn lnwire.EmptyFeatureVector()\n\t}\n\n\treturn features\n}\n",
      "length": 256,
      "tokens": 39,
      "embedding": []
    }
  ]
}