{
  "filepath": "../implementations/go/lnd/channeldb/invoice_test.go",
  "package": "channeldb",
  "sections": [
    {
      "slug": "func randInvoice(value lnwire.MilliSatoshi) (*invpkg.Invoice, error) {",
      "content": "func randInvoice(value lnwire.MilliSatoshi) (*invpkg.Invoice, error) {\n\tvar (\n\t\tpre     lntypes.Preimage\n\t\tpayAddr [32]byte\n\t)\n\tif _, err := rand.Read(pre[:]); err != nil {\n\t\treturn nil, err\n\t}\n\tif _, err := rand.Read(payAddr[:]); err != nil {\n\t\treturn nil, err\n\t}\n\n\ti := &invpkg.Invoice{\n\t\tCreationDate: testNow,\n\t\tTerms: invpkg.ContractTerm{\n\t\t\tExpiry:          4000,\n\t\t\tPaymentPreimage: &pre,\n\t\t\tPaymentAddr:     payAddr,\n\t\t\tValue:           value,\n\t\t\tFeatures:        emptyFeatures,\n\t\t},\n\t\tHtlcs:    map[models.CircuitKey]*invpkg.InvoiceHTLC{},\n\t\tAMPState: map[invpkg.SetID]invpkg.InvoiceStateAMP{},\n\t}\n\ti.Memo = []byte(\"memo\")\n\n\t// Create a random byte slice of MaxPaymentRequestSize bytes to be used\n\t// as a dummy paymentrequest, and  determine if it should be set based\n\t// on one of the random bytes.\n\tvar r [invpkg.MaxPaymentRequestSize]byte\n\tif _, err := rand.Read(r[:]); err != nil {\n\t\treturn nil, err\n\t}\n\tif r[0]&1 == 0 {\n\t\ti.PaymentRequest = r[:]\n\t} else {\n\t\ti.PaymentRequest = []byte(\"\")\n\t}\n\n\treturn i, nil\n}\n\n// settleTestInvoice settles a test invoice.",
      "length": 957,
      "tokens": 132,
      "embedding": []
    },
    {
      "slug": "func settleTestInvoice(invoice *invpkg.Invoice, settleIndex uint64) {",
      "content": "func settleTestInvoice(invoice *invpkg.Invoice, settleIndex uint64) {\n\tinvoice.SettleDate = testNow\n\tinvoice.AmtPaid = invoice.Terms.Value\n\tinvoice.State = invpkg.ContractSettled\n\tinvoice.Htlcs[models.CircuitKey{}] = &invpkg.InvoiceHTLC{\n\t\tAmt:           invoice.Terms.Value,\n\t\tAcceptTime:    testNow,\n\t\tResolveTime:   testNow,\n\t\tState:         invpkg.HtlcStateSettled,\n\t\tCustomRecords: make(record.CustomSet),\n\t}\n\tinvoice.SettleIndex = settleIndex\n}\n\n// Tests that pending invoices are those which are either in ContractOpen or\n// in ContractAccepted state.",
      "length": 474,
      "tokens": 44,
      "embedding": []
    },
    {
      "slug": "func TestInvoiceIsPending(t *testing.T) {",
      "content": "func TestInvoiceIsPending(t *testing.T) {\n\tcontractStates := []invpkg.ContractState{\n\t\tinvpkg.ContractOpen, invpkg.ContractSettled,\n\t\tinvpkg.ContractCanceled, invpkg.ContractAccepted,\n\t}\n\n\tfor _, state := range contractStates {\n\t\tinvoice := invpkg.Invoice{\n\t\t\tState: state,\n\t\t}\n\n\t\t// We expect that an invoice is pending if it's either in\n\t\t// ContractOpen or ContractAccepted state.\n\t\topen := invpkg.ContractOpen\n\t\taccepted := invpkg.ContractAccepted\n\t\tpending := (state == open || state == accepted)\n\n\t\trequire.Equal(t, pending, invoice.IsPending())\n\t}\n}\n",
      "length": 496,
      "tokens": 58,
      "embedding": []
    },
    {
      "slug": "type invWorkflowTest struct {",
      "content": "type invWorkflowTest struct {\n\tname         string\n\tqueryPayHash bool\n\tqueryPayAddr bool\n}\n\nvar invWorkflowTests = []invWorkflowTest{\n\t{\n\t\tname:         \"unknown\",\n\t\tqueryPayHash: false,\n\t\tqueryPayAddr: false,\n\t},\n\t{\n\t\tname:         \"only payhash known\",\n\t\tqueryPayHash: true,\n\t\tqueryPayAddr: false,\n\t},\n\t{\n\t\tname:         \"payaddr and payhash known\",\n\t\tqueryPayHash: true,\n\t\tqueryPayAddr: true,\n\t},\n}\n\n// TestInvoiceWorkflow asserts the basic process of inserting, fetching, and\n// updating an invoice. We assert that the flow is successful using when\n// querying with various combinations of payment hash and payment address.",
      "length": 572,
      "tokens": 75,
      "embedding": []
    },
    {
      "slug": "func TestInvoiceWorkflow(t *testing.T) {",
      "content": "func TestInvoiceWorkflow(t *testing.T) {\n\tt.Parallel()\n\n\tfor _, test := range invWorkflowTests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\ttestInvoiceWorkflow(t, test)\n\t\t})\n\t}\n}\n",
      "length": 144,
      "tokens": 20,
      "embedding": []
    },
    {
      "slug": "func testInvoiceWorkflow(t *testing.T, test invWorkflowTest) {",
      "content": "func testInvoiceWorkflow(t *testing.T, test invWorkflowTest) {\n\tdb, err := MakeTestDB(t)\n\trequire.NoError(t, err, \"unable to make test db\")\n\n\t// Create a fake invoice which we'll use several times in the tests\n\t// below.\n\tfakeInvoice, err := randInvoice(10000)\n\trequire.NoError(t, err, \"unable to create invoice\")\n\tinvPayHash := fakeInvoice.Terms.PaymentPreimage.Hash()\n\n\t// Select the payment hash and payment address we will use to lookup or\n\t// update the invoice for the remainder of the test.\n\tvar (\n\t\tpayHash lntypes.Hash\n\t\tpayAddr *[32]byte\n\t\tref     invpkg.InvoiceRef\n\t)\n\tswitch {\n\tcase test.queryPayHash && test.queryPayAddr:\n\t\tpayHash = invPayHash\n\t\tpayAddr = &fakeInvoice.Terms.PaymentAddr\n\t\tref = invpkg.InvoiceRefByHashAndAddr(payHash, *payAddr)\n\tcase test.queryPayHash:\n\t\tpayHash = invPayHash\n\t\tref = invpkg.InvoiceRefByHash(payHash)\n\t}\n\n\t// Add the invoice to the database, this should succeed as there aren't\n\t// any existing invoices within the database with the same payment\n\t// hash.\n\tif _, err := db.AddInvoice(fakeInvoice, invPayHash); err != nil {\n\t\tt.Fatalf(\"unable to find invoice: %v\", err)\n\t}\n\n\t// Attempt to retrieve the invoice which was just added to the\n\t// database. It should be found, and the invoice returned should be\n\t// identical to the one created above.\n\tdbInvoice, err := db.LookupInvoice(ref)\n\tif !test.queryPayAddr && !test.queryPayHash {\n\t\trequire.ErrorIs(t, err, invpkg.ErrInvoiceNotFound)\n\t\treturn\n\t}\n\n\trequire.Equal(t,\n\t\t*fakeInvoice, dbInvoice,\n\t\t\"invoice fetched from db doesn't match original\",\n\t)\n\n\t// The add index of the invoice retrieved from the database should now\n\t// be fully populated. As this is the first index written to the DB,\n\t// the addIndex should be 1.\n\tif dbInvoice.AddIndex != 1 {\n\t\tt.Fatalf(\"wrong add index: expected %v, got %v\", 1,\n\t\t\tdbInvoice.AddIndex)\n\t}\n\n\t// Settle the invoice, the version retrieved from the database should\n\t// now have the settled bit toggle to true and a non-default\n\t// SettledDate\n\tpayAmt := fakeInvoice.Terms.Value * 2\n\t_, err = db.UpdateInvoice(ref, nil, getUpdateInvoice(payAmt))\n\trequire.NoError(t, err, \"unable to settle invoice\")\n\tdbInvoice2, err := db.LookupInvoice(ref)\n\trequire.NoError(t, err, \"unable to fetch invoice\")\n\tif dbInvoice2.State != invpkg.ContractSettled {\n\t\tt.Fatalf(\"invoice should now be settled but isn't\")\n\t}\n\tif dbInvoice2.SettleDate.IsZero() {\n\t\tt.Fatalf(\"invoice should have non-zero SettledDate but isn't\")\n\t}\n\n\t// Our 2x payment should be reflected, and also the settle index of 1\n\t// should also have been committed for this index.\n\tif dbInvoice2.AmtPaid != payAmt {\n\t\tt.Fatalf(\"wrong amt paid: expected %v, got %v\", payAmt,\n\t\t\tdbInvoice2.AmtPaid)\n\t}\n\tif dbInvoice2.SettleIndex != 1 {\n\t\tt.Fatalf(\"wrong settle index: expected %v, got %v\", 1,\n\t\t\tdbInvoice2.SettleIndex)\n\t}\n\n\t// Attempt to insert generated above again, this should fail as\n\t// duplicates are rejected by the processing logic.\n\t_, err = db.AddInvoice(fakeInvoice, payHash)\n\trequire.ErrorIs(t, err, invpkg.ErrDuplicateInvoice)\n\n\t// Attempt to look up a non-existent invoice, this should also fail but\n\t// with a \"not found\" error.\n\tvar fakeHash [32]byte\n\tfakeRef := invpkg.InvoiceRefByHash(fakeHash)\n\t_, err = db.LookupInvoice(fakeRef)\n\trequire.ErrorIs(t, err, invpkg.ErrInvoiceNotFound)\n\n\t// Add 10 random invoices.\n\tconst numInvoices = 10\n\tamt := lnwire.NewMSatFromSatoshis(1000)\n\tinvoices := make([]*invpkg.Invoice, numInvoices+1)\n\tinvoices[0] = &dbInvoice2\n\tfor i := 1; i < len(invoices); i++ {\n\t\tinvoice, err := randInvoice(amt)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to create invoice: %v\", err)\n\t\t}\n\n\t\thash := invoice.Terms.PaymentPreimage.Hash()\n\t\tif _, err := db.AddInvoice(invoice, hash); err != nil {\n\t\t\tt.Fatalf(\"unable to add invoice %v\", err)\n\t\t}\n\n\t\tinvoices[i] = invoice\n\t}\n\n\t// Perform a scan to collect all the active invoices.\n\tquery := invpkg.InvoiceQuery{\n\t\tIndexOffset:    0,\n\t\tNumMaxInvoices: math.MaxUint64,\n\t\tPendingOnly:    false,\n\t}\n\n\tresponse, err := db.QueryInvoices(query)\n\trequire.NoError(t, err, \"invoice query failed\")\n\n\t// The retrieve list of invoices should be identical as since we're\n\t// using big endian, the invoices should be retrieved in ascending\n\t// order (and the primary key should be incremented with each\n\t// insertion).\n\tfor i := 0; i < len(invoices); i++ {\n\t\trequire.Equal(t,\n\t\t\t*invoices[i], response.Invoices[i],\n\t\t\t\"retrieved invoice doesn't match\",\n\t\t)\n\t}\n}\n\n// TestAddDuplicatePayAddr asserts that the payment addresses of inserted\n// invoices are unique.",
      "length": 4305,
      "tokens": 597,
      "embedding": []
    },
    {
      "slug": "func TestAddDuplicatePayAddr(t *testing.T) {",
      "content": "func TestAddDuplicatePayAddr(t *testing.T) {\n\tdb, err := MakeTestDB(t)\n\trequire.NoError(t, err)\n\n\t// Create two invoices with the same payment addr.\n\tinvoice1, err := randInvoice(1000)\n\trequire.NoError(t, err)\n\n\tinvoice2, err := randInvoice(20000)\n\trequire.NoError(t, err)\n\tinvoice2.Terms.PaymentAddr = invoice1.Terms.PaymentAddr\n\n\t// First insert should succeed.\n\tinv1Hash := invoice1.Terms.PaymentPreimage.Hash()\n\t_, err = db.AddInvoice(invoice1, inv1Hash)\n\trequire.NoError(t, err)\n\n\t// Second insert should fail with duplicate payment addr.\n\tinv2Hash := invoice2.Terms.PaymentPreimage.Hash()\n\t_, err = db.AddInvoice(invoice2, inv2Hash)\n\trequire.Error(t, err, invpkg.ErrDuplicatePayAddr)\n}\n\n// TestAddDuplicateKeysendPayAddr asserts that we permit duplicate payment\n// addresses to be inserted if they are blank to support JIT legacy keysend\n// invoices.",
      "length": 787,
      "tokens": 90,
      "embedding": []
    },
    {
      "slug": "func TestAddDuplicateKeysendPayAddr(t *testing.T) {",
      "content": "func TestAddDuplicateKeysendPayAddr(t *testing.T) {\n\tdb, err := MakeTestDB(t)\n\trequire.NoError(t, err)\n\n\t// Create two invoices with the same _blank_ payment addr.\n\tinvoice1, err := randInvoice(1000)\n\trequire.NoError(t, err)\n\tinvoice1.Terms.PaymentAddr = invpkg.BlankPayAddr\n\n\tinvoice2, err := randInvoice(20000)\n\trequire.NoError(t, err)\n\tinvoice2.Terms.PaymentAddr = invpkg.BlankPayAddr\n\n\t// Inserting both should succeed without a duplicate payment address\n\t// failure.\n\tinv1Hash := invoice1.Terms.PaymentPreimage.Hash()\n\t_, err = db.AddInvoice(invoice1, inv1Hash)\n\trequire.NoError(t, err)\n\n\tinv2Hash := invoice2.Terms.PaymentPreimage.Hash()\n\t_, err = db.AddInvoice(invoice2, inv2Hash)\n\trequire.NoError(t, err)\n\n\t// Querying for each should succeed. Here we use hash+addr refs since\n\t// the lookup will fail if the hash and addr point to different\n\t// invoices, so if both succeed we can be assured they aren't included\n\t// in the payment address index.\n\tref1 := invpkg.InvoiceRefByHashAndAddr(inv1Hash, invpkg.BlankPayAddr)\n\tdbInv1, err := db.LookupInvoice(ref1)\n\trequire.NoError(t, err)\n\trequire.Equal(t, invoice1, &dbInv1)\n\n\tref2 := invpkg.InvoiceRefByHashAndAddr(inv2Hash, invpkg.BlankPayAddr)\n\tdbInv2, err := db.LookupInvoice(ref2)\n\trequire.NoError(t, err)\n\trequire.Equal(t, invoice2, &dbInv2)\n}\n\n// TestFailInvoiceLookupMPPPayAddrOnly asserts that looking up a MPP invoice\n// that matches _only_ by payment address fails with ErrInvoiceNotFound. This\n// ensures that the HTLC's payment hash always matches the payment hash in the\n// returned invoice.",
      "length": 1466,
      "tokens": 174,
      "embedding": []
    },
    {
      "slug": "func TestFailInvoiceLookupMPPPayAddrOnly(t *testing.T) {",
      "content": "func TestFailInvoiceLookupMPPPayAddrOnly(t *testing.T) {\n\tdb, err := MakeTestDB(t)\n\trequire.NoError(t, err)\n\n\t// Create and insert a random invoice.\n\tinvoice, err := randInvoice(1000)\n\trequire.NoError(t, err)\n\n\tpayHash := invoice.Terms.PaymentPreimage.Hash()\n\tpayAddr := invoice.Terms.PaymentAddr\n\t_, err = db.AddInvoice(invoice, payHash)\n\trequire.NoError(t, err)\n\n\t// Modify the queried payment hash to be invalid.\n\tpayHash[0] ^= 0x01\n\n\t// Lookup the invoice by (invalid) payment hash and payment address. The\n\t// lookup should fail since we require the payment hash to match for\n\t// legacy/MPP invoices, as this guarantees that the preimage is valid\n\t// for the given HTLC.\n\tref := invpkg.InvoiceRefByHashAndAddr(payHash, payAddr)\n\t_, err = db.LookupInvoice(ref)\n\trequire.Equal(t, invpkg.ErrInvoiceNotFound, err)\n}\n\n// TestInvRefEquivocation asserts that retrieving or updating an invoice using\n// an equivocating InvoiceRef results in ErrInvRefEquivocation.",
      "length": 878,
      "tokens": 114,
      "embedding": []
    },
    {
      "slug": "func TestInvRefEquivocation(t *testing.T) {",
      "content": "func TestInvRefEquivocation(t *testing.T) {\n\tdb, err := MakeTestDB(t)\n\trequire.NoError(t, err)\n\n\t// Add two random invoices.\n\tinvoice1, err := randInvoice(1000)\n\trequire.NoError(t, err)\n\n\tinv1Hash := invoice1.Terms.PaymentPreimage.Hash()\n\t_, err = db.AddInvoice(invoice1, inv1Hash)\n\trequire.NoError(t, err)\n\n\tinvoice2, err := randInvoice(2000)\n\trequire.NoError(t, err)\n\n\tinv2Hash := invoice2.Terms.PaymentPreimage.Hash()\n\t_, err = db.AddInvoice(invoice2, inv2Hash)\n\trequire.NoError(t, err)\n\n\t// Now, query using invoice 1's payment address, but invoice 2's payment\n\t// hash. We expect an error since the invref points to multiple\n\t// invoices.\n\tref := invpkg.InvoiceRefByHashAndAddr(\n\t\tinv2Hash, invoice1.Terms.PaymentAddr,\n\t)\n\t_, err = db.LookupInvoice(ref)\n\trequire.Error(t, err, invpkg.ErrInvRefEquivocation)\n\n\t// The same error should be returned when updating an equivocating\n\t// reference.\n\tnop := func(_ *invpkg.Invoice) (*invpkg.InvoiceUpdateDesc, error) {\n\t\treturn nil, nil\n\t}\n\t_, err = db.UpdateInvoice(ref, nil, nop)\n\trequire.Error(t, err, invpkg.ErrInvRefEquivocation)\n}\n\n// TestInvoiceCancelSingleHtlc tests that a single htlc can be canceled on the\n// invoice.",
      "length": 1093,
      "tokens": 130,
      "embedding": []
    },
    {
      "slug": "func TestInvoiceCancelSingleHtlc(t *testing.T) {",
      "content": "func TestInvoiceCancelSingleHtlc(t *testing.T) {\n\tt.Parallel()\n\n\tdb, err := MakeTestDB(t)\n\trequire.NoError(t, err, \"unable to make test db\")\n\n\tpreimage := lntypes.Preimage{1}\n\tpaymentHash := preimage.Hash()\n\n\ttestInvoice := &invpkg.Invoice{\n\t\tHtlcs: map[models.CircuitKey]*invpkg.InvoiceHTLC{},\n\t\tTerms: invpkg.ContractTerm{\n\t\t\tValue:           lnwire.NewMSatFromSatoshis(10000),\n\t\t\tFeatures:        emptyFeatures,\n\t\t\tPaymentPreimage: &preimage,\n\t\t},\n\t}\n\n\tif _, err := db.AddInvoice(testInvoice, paymentHash); err != nil {\n\t\tt.Fatalf(\"unable to find invoice: %v\", err)\n\t}\n\n\t// Accept an htlc on this invoice.\n\tkey := models.CircuitKey{\n\t\tChanID: lnwire.NewShortChanIDFromInt(1),\n\t\tHtlcID: 4,\n\t}\n\thtlc := invpkg.HtlcAcceptDesc{\n\t\tAmt:           500,\n\t\tCustomRecords: make(record.CustomSet),\n\t}\n\n\tcallback := func(\n\t\tinvoice *invpkg.Invoice) (*invpkg.InvoiceUpdateDesc, error) {\n\n\t\thtlcs := map[models.CircuitKey]*invpkg.HtlcAcceptDesc{\n\t\t\tkey: &htlc,\n\t\t}\n\n\t\treturn &invpkg.InvoiceUpdateDesc{\n\t\t\tAddHtlcs: htlcs,\n\t\t}, nil\n\t}\n\n\tref := invpkg.InvoiceRefByHash(paymentHash)\n\tinvoice, err := db.UpdateInvoice(ref, nil, callback)\n\trequire.NoError(t, err, \"unable to add invoice htlc\")\n\tif len(invoice.Htlcs) != 1 {\n\t\tt.Fatalf(\"expected the htlc to be added\")\n\t}\n\tif invoice.Htlcs[key].State != invpkg.HtlcStateAccepted {\n\t\tt.Fatalf(\"expected htlc in state accepted\")\n\t}\n\n\tcallback = func(\n\t\tinvoice *invpkg.Invoice) (*invpkg.InvoiceUpdateDesc, error) {\n\n\t\treturn &invpkg.InvoiceUpdateDesc{\n\t\t\tCancelHtlcs: map[models.CircuitKey]struct{}{\n\t\t\t\tkey: {},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Cancel the htlc again.\n\tinvoice, err = db.UpdateInvoice(ref, nil, callback)\n\trequire.NoError(t, err, \"unable to cancel htlc\")\n\tif len(invoice.Htlcs) != 1 {\n\t\tt.Fatalf(\"expected the htlc to be present\")\n\t}\n\tif invoice.Htlcs[key].State != invpkg.HtlcStateCanceled {\n\t\tt.Fatalf(\"expected htlc in state canceled\")\n\t}\n}\n\n// TestInvoiceCancelSingleHtlcAMP tests that it's possible to cancel a single\n// invoice of an AMP HTLC across multiple set IDs, and also have that update\n// the amount paid and other related fields as well.",
      "length": 1965,
      "tokens": 227,
      "embedding": []
    },
    {
      "slug": "func TestInvoiceCancelSingleHtlcAMP(t *testing.T) {",
      "content": "func TestInvoiceCancelSingleHtlcAMP(t *testing.T) {\n\tt.Parallel()\n\n\tdb, err := MakeTestDB(t, OptionClock(testClock))\n\trequire.NoError(t, err, \"unable to make test db: %v\", err)\n\n\t// We'll start out by creating an invoice and writing it to the DB.\n\tamt := lnwire.NewMSatFromSatoshis(1000)\n\tinvoice, err := randInvoice(amt)\n\trequire.Nil(t, err)\n\n\t// Set AMP-specific features so that we can settle with HTLC-level\n\t// preimages.\n\tinvoice.Terms.Features = ampFeatures\n\n\tpreimage := *invoice.Terms.PaymentPreimage\n\tpayHash := preimage.Hash()\n\t_, err = db.AddInvoice(invoice, payHash)\n\trequire.Nil(t, err)\n\n\t// Add two HTLC sets, one with one HTLC and the other with two.\n\tsetID1 := &[32]byte{1}\n\tsetID2 := &[32]byte{2}\n\n\tref := invpkg.InvoiceRefByHashAndAddr(\n\t\tpayHash, invoice.Terms.PaymentAddr,\n\t)\n\n\t// The first set ID with a single HTLC added.\n\t_, err = db.UpdateInvoice(\n\t\tref, (*invpkg.SetID)(setID1),\n\t\tupdateAcceptAMPHtlc(0, amt, setID1, true),\n\t)\n\trequire.Nil(t, err)\n\n\t// The second set ID with two HTLCs added.\n\t_, err = db.UpdateInvoice(\n\t\tref, (*invpkg.SetID)(setID2),\n\t\tupdateAcceptAMPHtlc(1, amt, setID2, true),\n\t)\n\trequire.Nil(t, err)\n\tdbInvoice, err := db.UpdateInvoice(\n\t\tref, (*invpkg.SetID)(setID2),\n\t\tupdateAcceptAMPHtlc(2, amt, setID2, true),\n\t)\n\trequire.Nil(t, err)\n\n\t// At this point, we should detect that 3k satoshis total has been\n\t// paid.\n\trequire.Equal(t, dbInvoice.AmtPaid, amt*3)\n\n\tcallback := func(\n\t\tinvoice *invpkg.Invoice) (*invpkg.InvoiceUpdateDesc, error) {\n\n\t\treturn &invpkg.InvoiceUpdateDesc{\n\t\t\tCancelHtlcs: map[models.CircuitKey]struct{}{\n\t\t\t\t{HtlcID: 0}: {},\n\t\t\t},\n\t\t\tSetID: (*invpkg.SetID)(setID1),\n\t\t}, nil\n\t}\n\n\t// Now we'll cancel a single invoice, and assert that the amount paid\n\t// is decremented, and the state for that HTLC set reflects that is\n\t// been cancelled.\n\t_, err = db.UpdateInvoice(ref, (*invpkg.SetID)(setID1), callback)\n\trequire.NoError(t, err, \"unable to cancel htlc\")\n\n\tfreshInvoice, err := db.LookupInvoice(ref)\n\trequire.Nil(t, err)\n\tdbInvoice = &freshInvoice\n\n\t// The amount paid should reflect that an invoice was cancelled.\n\trequire.Equal(t, dbInvoice.AmtPaid, amt*2)\n\n\t// The HTLC and AMP state should also show that only one HTLC set is\n\t// left.\n\tinvoice.State = invpkg.ContractOpen\n\tinvoice.AmtPaid = 2 * amt\n\tinvoice.SettleDate = dbInvoice.SettleDate\n\n\thtlc0 := models.CircuitKey{HtlcID: 0}\n\thtlc1 := models.CircuitKey{HtlcID: 1}\n\thtlc2 := models.CircuitKey{HtlcID: 2}\n\n\tinvoice.Htlcs = map[models.CircuitKey]*invpkg.InvoiceHTLC{\n\t\thtlc0: makeAMPInvoiceHTLC(amt, *setID1, payHash, &preimage),\n\t\thtlc1: makeAMPInvoiceHTLC(amt, *setID2, payHash, &preimage),\n\t\thtlc2: makeAMPInvoiceHTLC(amt, *setID2, payHash, &preimage),\n\t}\n\tinvoice.AMPState[*setID1] = invpkg.InvoiceStateAMP{\n\t\tState: invpkg.HtlcStateCanceled,\n\t\tInvoiceKeys: map[models.CircuitKey]struct{}{\n\t\t\t{HtlcID: 0}: {},\n\t\t},\n\t}\n\tinvoice.AMPState[*setID2] = invpkg.InvoiceStateAMP{\n\t\tState:   invpkg.HtlcStateAccepted,\n\t\tAmtPaid: amt * 2,\n\t\tInvoiceKeys: map[models.CircuitKey]struct{}{\n\t\t\t{HtlcID: 1}: {},\n\t\t\t{HtlcID: 2}: {},\n\t\t},\n\t}\n\n\tinvoice.Htlcs[htlc0].State = invpkg.HtlcStateCanceled\n\tinvoice.Htlcs[htlc0].ResolveTime = time.Unix(1, 0)\n\n\trequire.Equal(t, invoice, dbInvoice)\n\n\t// Next, we'll cancel the _other_ HTLCs active, but we'll do them one\n\t// by one.\n\t_, err = db.UpdateInvoice(ref, (*invpkg.SetID)(setID2),\n\t\tfunc(invoice *invpkg.Invoice) (*invpkg.InvoiceUpdateDesc,\n\t\t\terror) {\n\n\t\t\treturn &invpkg.InvoiceUpdateDesc{\n\t\t\t\tCancelHtlcs: map[models.CircuitKey]struct{}{\n\t\t\t\t\t{HtlcID: 1}: {},\n\t\t\t\t},\n\t\t\t\tSetID: (*invpkg.SetID)(setID2),\n\t\t\t}, nil\n\t\t})\n\trequire.NoError(t, err, \"unable to cancel htlc\")\n\n\tfreshInvoice, err = db.LookupInvoice(ref)\n\trequire.Nil(t, err)\n\tdbInvoice = &freshInvoice\n\n\tinvoice.Htlcs[htlc1].State = invpkg.HtlcStateCanceled\n\tinvoice.Htlcs[htlc1].ResolveTime = time.Unix(1, 0)\n\tinvoice.AmtPaid = amt\n\n\tampState := invoice.AMPState[*setID2]\n\tampState.State = invpkg.HtlcStateCanceled\n\tampState.AmtPaid = amt\n\tinvoice.AMPState[*setID2] = ampState\n\n\trequire.Equal(t, invoice, dbInvoice)\n\n\tcallback = func(\n\t\tinvoice *invpkg.Invoice) (*invpkg.InvoiceUpdateDesc, error) {\n\n\t\treturn &invpkg.InvoiceUpdateDesc{\n\t\t\tCancelHtlcs: map[models.CircuitKey]struct{}{\n\t\t\t\t{HtlcID: 2}: {},\n\t\t\t},\n\t\t\tSetID: (*invpkg.SetID)(setID2),\n\t\t}, nil\n\t}\n\n\t// Now we'll cancel the final HTLC, which should cause all the active\n\t// HTLCs to transition to the cancelled state.\n\t_, err = db.UpdateInvoice(ref, (*invpkg.SetID)(setID2), callback)\n\trequire.NoError(t, err, \"unable to cancel htlc\")\n\n\tfreshInvoice, err = db.LookupInvoice(ref)\n\trequire.Nil(t, err)\n\tdbInvoice = &freshInvoice\n\n\tampState = invoice.AMPState[*setID2]\n\tampState.AmtPaid = 0\n\tinvoice.AMPState[*setID2] = ampState\n\n\tinvoice.Htlcs[htlc2].State = invpkg.HtlcStateCanceled\n\tinvoice.Htlcs[htlc2].ResolveTime = time.Unix(1, 0)\n\tinvoice.AmtPaid = 0\n\n\trequire.Equal(t, invoice, dbInvoice)\n}\n\n// TestInvoiceTimeSeries tests that newly added invoices invoices, as well as\n// settled invoices are added to the database are properly placed in the add\n// add or settle index which serves as an event time series.",
      "length": 4877,
      "tokens": 556,
      "embedding": []
    },
    {
      "slug": "func TestInvoiceAddTimeSeries(t *testing.T) {",
      "content": "func TestInvoiceAddTimeSeries(t *testing.T) {\n\tt.Parallel()\n\n\tdb, err := MakeTestDB(t, OptionClock(testClock))\n\trequire.NoError(t, err, \"unable to make test db\")\n\n\t_, err = db.InvoicesAddedSince(0)\n\trequire.NoError(t, err)\n\n\t// We'll start off by creating 20 random invoices, and inserting them\n\t// into the database.\n\tconst numInvoices = 20\n\tamt := lnwire.NewMSatFromSatoshis(1000)\n\tinvoices := make([]invpkg.Invoice, numInvoices)\n\tfor i := 0; i < len(invoices); i++ {\n\t\tinvoice, err := randInvoice(amt)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to create invoice: %v\", err)\n\t\t}\n\n\t\tpaymentHash := invoice.Terms.PaymentPreimage.Hash()\n\n\t\tif _, err := db.AddInvoice(invoice, paymentHash); err != nil {\n\t\t\tt.Fatalf(\"unable to add invoice %v\", err)\n\t\t}\n\n\t\tinvoices[i] = *invoice\n\t}\n\n\t// With the invoices constructed, we'll now create a series of queries\n\t// that we'll use to assert expected return values of\n\t// InvoicesAddedSince.\n\taddQueries := []struct {\n\t\tsinceAddIndex uint64\n\n\t\tresp []invpkg.Invoice\n\t}{\n\t\t// If we specify a value of zero, we shouldn't get any invoices\n\t\t// back.\n\t\t{\n\t\t\tsinceAddIndex: 0,\n\t\t},\n\n\t\t// If we specify a value well beyond the number of inserted\n\t\t// invoices, we shouldn't get any invoices back.\n\t\t{\n\t\t\tsinceAddIndex: 99999999,\n\t\t},\n\n\t\t// Using an index of 1 should result in all values, but the\n\t\t// first one being returned.\n\t\t{\n\t\t\tsinceAddIndex: 1,\n\t\t\tresp:          invoices[1:],\n\t\t},\n\n\t\t// If we use an index of 10, then we should retrieve the\n\t\t// reaming 10 invoices.\n\t\t{\n\t\t\tsinceAddIndex: 10,\n\t\t\tresp:          invoices[10:],\n\t\t},\n\t}\n\n\tfor i, query := range addQueries {\n\t\tresp, err := db.InvoicesAddedSince(query.sinceAddIndex)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to query: %v\", err)\n\t\t}\n\n\t\trequire.Equal(t, len(query.resp), len(resp))\n\n\t\tfor j := 0; j < len(query.resp); j++ {\n\t\t\trequire.Equal(t,\n\t\t\t\tquery.resp[j], resp[j],\n\t\t\t\tfmt.Sprintf(\"test: #%v, item: #%v\", i, j),\n\t\t\t)\n\t\t}\n\t}\n\n\t_, err = db.InvoicesSettledSince(0)\n\trequire.NoError(t, err)\n\n\tvar settledInvoices []invpkg.Invoice\n\tvar settleIndex uint64 = 1\n\t// We'll now only settle the latter half of each of those invoices.\n\tfor i := 10; i < len(invoices); i++ {\n\t\tinvoice := &invoices[i]\n\n\t\tpaymentHash := invoice.Terms.PaymentPreimage.Hash()\n\n\t\tref := invpkg.InvoiceRefByHash(paymentHash)\n\t\t_, err := db.UpdateInvoice(\n\t\t\tref, nil, getUpdateInvoice(invoice.Terms.Value),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to settle invoice: %v\", err)\n\t\t}\n\n\t\t// Create the settled invoice for the expectation set.\n\t\tsettleTestInvoice(invoice, settleIndex)\n\t\tsettleIndex++\n\n\t\tsettledInvoices = append(settledInvoices, *invoice)\n\t}\n\n\t// We'll now prepare an additional set of queries to ensure the settle\n\t// time series has properly been maintained in the database.\n\tsettleQueries := []struct {\n\t\tsinceSettleIndex uint64\n\n\t\tresp []invpkg.Invoice\n\t}{\n\t\t// If we specify a value of zero, we shouldn't get any settled\n\t\t// invoices back.\n\t\t{\n\t\t\tsinceSettleIndex: 0,\n\t\t},\n\n\t\t// If we specify a value well beyond the number of settled\n\t\t// invoices, we shouldn't get any invoices back.\n\t\t{\n\t\t\tsinceSettleIndex: 99999999,\n\t\t},\n\n\t\t// Using an index of 1 should result in the final 10 invoices\n\t\t// being returned, as we only settled those.\n\t\t{\n\t\t\tsinceSettleIndex: 1,\n\t\t\tresp:             settledInvoices[1:],\n\t\t},\n\t}\n\n\tfor i, query := range settleQueries {\n\t\tresp, err := db.InvoicesSettledSince(query.sinceSettleIndex)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to query: %v\", err)\n\t\t}\n\n\t\trequire.Equal(t, len(query.resp), len(resp))\n\n\t\tfor j := 0; j < len(query.resp); j++ {\n\t\t\trequire.Equal(t,\n\t\t\t\tquery.resp[j], resp[j],\n\t\t\t\tfmt.Sprintf(\"test: #%v, item: #%v\", i, j),\n\t\t\t)\n\t\t}\n\t}\n}\n\n// TestSettleIndexAmpPayments tests that repeated settles of the same invoice\n// end up properly adding entries to the settle index, and the\n// InvoicesSettledSince will emit a \"projected\" version of the invoice w/\n// _just_ that HTLC information.",
      "length": 3717,
      "tokens": 536,
      "embedding": []
    },
    {
      "slug": "func TestSettleIndexAmpPayments(t *testing.T) {",
      "content": "func TestSettleIndexAmpPayments(t *testing.T) {\n\tt.Parallel()\n\n\ttestClock := clock.NewTestClock(testNow)\n\tdb, err := MakeTestDB(t, OptionClock(testClock))\n\trequire.Nil(t, err)\n\n\t// First, we'll make a sample invoice that'll be paid to several times\n\t// below.\n\tamt := lnwire.NewMSatFromSatoshis(1000)\n\ttestInvoice, err := randInvoice(amt)\n\trequire.Nil(t, err)\n\ttestInvoice.Terms.Features = ampFeatures\n\n\t// Add the invoice to the DB, we use a dummy payment hash here but the\n\t// invoice will have a valid payment address set.\n\tpreimage := *testInvoice.Terms.PaymentPreimage\n\tpayHash := preimage.Hash()\n\t_, err = db.AddInvoice(testInvoice, payHash)\n\trequire.Nil(t, err)\n\n\t// Now that we have the invoice, we'll simulate 3 different HTLC sets\n\t// being attached to the invoice. These represent 3 different\n\t// concurrent payments.\n\tsetID1 := &[32]byte{1}\n\tsetID2 := &[32]byte{2}\n\tsetID3 := &[32]byte{3}\n\n\tref := invpkg.InvoiceRefByHashAndAddr(\n\t\tpayHash, testInvoice.Terms.PaymentAddr,\n\t)\n\t_, err = db.UpdateInvoice(\n\t\tref, (*invpkg.SetID)(setID1),\n\t\tupdateAcceptAMPHtlc(1, amt, setID1, true),\n\t)\n\trequire.Nil(t, err)\n\t_, err = db.UpdateInvoice(\n\t\tref, (*invpkg.SetID)(setID2),\n\t\tupdateAcceptAMPHtlc(2, amt, setID2, true),\n\t)\n\trequire.Nil(t, err)\n\t_, err = db.UpdateInvoice(\n\t\tref, (*invpkg.SetID)(setID3),\n\t\tupdateAcceptAMPHtlc(3, amt, setID3, true),\n\t)\n\trequire.Nil(t, err)\n\n\t// Now that the invoices have been accepted, we'll exercise the\n\t// behavior of the LookupInvoice call that allows us to modify exactly\n\t// how we query for invoices.\n\t//\n\t// First, we'll query for the invoice with just the payment addr, but\n\t// specify no HTLcs are to be included.\n\trefNoHtlcs := invpkg.InvoiceRefByAddrBlankHtlc(\n\t\ttestInvoice.Terms.PaymentAddr,\n\t)\n\tinvoiceNoHTLCs, err := db.LookupInvoice(refNoHtlcs)\n\trequire.Nil(t, err)\n\n\trequire.Equal(t, 0, len(invoiceNoHTLCs.Htlcs))\n\n\t// We'll now look up the HTLCs based on the individual setIDs added\n\t// above.\n\tfor i, setID := range []*[32]byte{setID1, setID2, setID3} {\n\t\trefFiltered := invpkg.InvoiceRefBySetIDFiltered(*setID)\n\t\tinvoiceFiltered, err := db.LookupInvoice(refFiltered)\n\t\trequire.Nil(t, err)\n\n\t\t// Only a single HTLC should be present.\n\t\trequire.Equal(t, 1, len(invoiceFiltered.Htlcs))\n\n\t\t// The set ID for the HTLC should match the queried set ID.\n\t\tkey := models.CircuitKey{HtlcID: uint64(i + 1)}\n\t\thtlc := invoiceFiltered.Htlcs[key]\n\t\trequire.Equal(t, *setID, htlc.AMP.Record.SetID())\n\n\t\t// The HTLC should show that it's in the accepted state.\n\t\trequire.Equal(t, htlc.State, invpkg.HtlcStateAccepted)\n\t}\n\n\t// Now that we know the invoices are in the proper state, we'll settle\n\t// them on by one in distinct updates.\n\t_, err = db.UpdateInvoice(\n\t\tref, (*invpkg.SetID)(setID1),\n\t\tgetUpdateInvoiceAMPSettle(\n\t\t\tsetID1, preimage, models.CircuitKey{HtlcID: 1},\n\t\t),\n\t)\n\trequire.Nil(t, err)\n\t_, err = db.UpdateInvoice(\n\t\tref, (*invpkg.SetID)(setID2),\n\t\tgetUpdateInvoiceAMPSettle(\n\t\t\tsetID2, preimage, models.CircuitKey{HtlcID: 2},\n\t\t),\n\t)\n\trequire.Nil(t, err)\n\t_, err = db.UpdateInvoice(\n\t\tref, (*invpkg.SetID)(setID3),\n\t\tgetUpdateInvoiceAMPSettle(\n\t\t\tsetID3, preimage, models.CircuitKey{HtlcID: 3},\n\t\t),\n\t)\n\trequire.Nil(t, err)\n\n\t// Now that all the invoices have been settled, we'll ensure that the\n\t// settle index was updated properly by obtaining all the currently\n\t// settled invoices in the time series. We use a value of 1 here to\n\t// ensure we get _all_ the invoices back.\n\tsettledInvoices, err := db.InvoicesSettledSince(1)\n\trequire.Nil(t, err)\n\n\t// To get around the settle index quirk, we'll fetch the very first\n\t// invoice in the HTLC filtered mode and append it to the set of\n\t// invoices.\n\tfirstInvoice, err := db.LookupInvoice(\n\t\tinvpkg.InvoiceRefBySetIDFiltered(*setID1),\n\t)\n\trequire.Nil(t, err)\n\tsettledInvoices = append(\n\t\t[]invpkg.Invoice{firstInvoice}, settledInvoices...,\n\t)\n\n\t// There should be 3 invoices settled, as we created 3 \"sub-invoices\"\n\t// above.\n\tnumInvoices := 3\n\trequire.Equal(t, numInvoices, len(settledInvoices))\n\n\t// Each invoice should match the set of invoices we settled above, and\n\t// the AMPState should be set accordingly.\n\tfor i, settledInvoice := range settledInvoices {\n\t\t// Only one HTLC should be projected for this settled index.\n\t\trequire.Equal(t, 1, len(settledInvoice.Htlcs))\n\n\t\t// The invoice should show up as settled, and match the settle\n\t\t// index increment.\n\t\tinvSetID := &[32]byte{byte(i + 1)}\n\t\tsubInvoiceState, ok := settledInvoice.AMPState[*invSetID]\n\t\trequire.True(t, ok)\n\n\t\trequire.Equal(t, subInvoiceState.State, invpkg.HtlcStateSettled)\n\t\trequire.Equal(t, int(subInvoiceState.SettleIndex), i+1)\n\n\t\tinvoiceKey := models.CircuitKey{HtlcID: uint64(i + 1)}\n\t\t_, keyFound := subInvoiceState.InvoiceKeys[invoiceKey]\n\t\trequire.True(t, keyFound)\n\t}\n\n\t// If we attempt to look up the invoice by the payment addr, with all\n\t// the HTLCs, the main invoice should have 3 HTLCs present.\n\trefWithHtlcs := invpkg.InvoiceRefByAddr(testInvoice.Terms.PaymentAddr)\n\tinvoiceWithHTLCs, err := db.LookupInvoice(refWithHtlcs)\n\trequire.Nil(t, err)\n\trequire.Equal(t, numInvoices, len(invoiceWithHTLCs.Htlcs))\n\n\t// Finally, delete the invoice. If we query again, then nothing should\n\t// be found.\n\terr = db.DeleteInvoice([]invpkg.InvoiceDeleteRef{\n\t\t{\n\t\t\tPayHash:  payHash,\n\t\t\tPayAddr:  &testInvoice.Terms.PaymentAddr,\n\t\t\tAddIndex: testInvoice.AddIndex,\n\t\t},\n\t})\n\trequire.Nil(t, err)\n}\n\n// TestScanInvoices tests that ScanInvoices scans through all stored invoices\n// correctly.",
      "length": 5259,
      "tokens": 654,
      "embedding": []
    },
    {
      "slug": "func TestScanInvoices(t *testing.T) {",
      "content": "func TestScanInvoices(t *testing.T) {\n\tt.Parallel()\n\n\tdb, err := MakeTestDB(t)\n\trequire.NoError(t, err, \"unable to make test db\")\n\n\tvar invoices map[lntypes.Hash]*invpkg.Invoice\n\tcallCount := 0\n\tresetCount := 0\n\n\t// reset is used to reset/initialize results and is called once\n\t// upon calling ScanInvoices and when the underlying transaction is\n\t// retried.\n\treset := func() {\n\t\tinvoices = make(map[lntypes.Hash]*invpkg.Invoice)\n\t\tcallCount = 0\n\t\tresetCount++\n\t}\n\n\tscanFunc := func(paymentHash lntypes.Hash,\n\t\tinvoice *invpkg.Invoice) error {\n\n\t\tinvoices[paymentHash] = invoice\n\t\tcallCount++\n\n\t\treturn nil\n\t}\n\n\t// With an empty DB we expect to not scan any invoices.\n\trequire.NoError(t, db.ScanInvoices(scanFunc, reset))\n\trequire.Equal(t, 0, len(invoices))\n\trequire.Equal(t, 0, callCount)\n\trequire.Equal(t, 1, resetCount)\n\n\tnumInvoices := 5\n\ttestInvoices := make(map[lntypes.Hash]*invpkg.Invoice)\n\n\t// Now populate the DB and check if we can get all invoices with their\n\t// payment hashes as expected.\n\tfor i := 1; i <= numInvoices; i++ {\n\t\tinvoice, err := randInvoice(lnwire.MilliSatoshi(i))\n\t\trequire.NoError(t, err)\n\n\t\tpaymentHash := invoice.Terms.PaymentPreimage.Hash()\n\t\ttestInvoices[paymentHash] = invoice\n\n\t\t_, err = db.AddInvoice(invoice, paymentHash)\n\t\trequire.NoError(t, err)\n\t}\n\n\tresetCount = 0\n\trequire.NoError(t, db.ScanInvoices(scanFunc, reset))\n\trequire.Equal(t, numInvoices, callCount)\n\trequire.Equal(t, testInvoices, invoices)\n\trequire.Equal(t, 1, resetCount)\n}\n\n// TestDuplicateSettleInvoice tests that if we add a new invoice and settle it\n// twice, then the second time we also receive the invoice that we settled as a\n// return argument.",
      "length": 1563,
      "tokens": 198,
      "embedding": []
    },
    {
      "slug": "func TestDuplicateSettleInvoice(t *testing.T) {",
      "content": "func TestDuplicateSettleInvoice(t *testing.T) {\n\tt.Parallel()\n\n\tdb, err := MakeTestDB(t, OptionClock(testClock))\n\trequire.NoError(t, err, \"unable to make test db\")\n\n\t// We'll start out by creating an invoice and writing it to the DB.\n\tamt := lnwire.NewMSatFromSatoshis(1000)\n\tinvoice, err := randInvoice(amt)\n\trequire.NoError(t, err, \"unable to create invoice\")\n\n\tpayHash := invoice.Terms.PaymentPreimage.Hash()\n\n\tif _, err := db.AddInvoice(invoice, payHash); err != nil {\n\t\tt.Fatalf(\"unable to add invoice %v\", err)\n\t}\n\n\t// With the invoice in the DB, we'll now attempt to settle the invoice.\n\tref := invpkg.InvoiceRefByHash(payHash)\n\tdbInvoice, err := db.UpdateInvoice(ref, nil, getUpdateInvoice(amt))\n\trequire.NoError(t, err, \"unable to settle invoice\")\n\n\t// We'll update what we expect the settle invoice to be so that our\n\t// comparison below has the correct assumption.\n\tinvoice.SettleIndex = 1\n\tinvoice.State = invpkg.ContractSettled\n\tinvoice.AmtPaid = amt\n\tinvoice.SettleDate = dbInvoice.SettleDate\n\tinvoice.Htlcs = map[models.CircuitKey]*invpkg.InvoiceHTLC{\n\t\t{}: {\n\t\t\tAmt:           amt,\n\t\t\tAcceptTime:    time.Unix(1, 0),\n\t\t\tResolveTime:   time.Unix(1, 0),\n\t\t\tState:         invpkg.HtlcStateSettled,\n\t\t\tCustomRecords: make(record.CustomSet),\n\t\t},\n\t}\n\n\t// We should get back the exact same invoice that we just inserted.\n\trequire.Equal(t, invoice, dbInvoice, \"wrong invoice after settle\")\n\n\t// If we try to settle the invoice again, then we should get the very\n\t// same invoice back, but with an error this time.\n\tdbInvoice, err = db.UpdateInvoice(ref, nil, getUpdateInvoice(amt))\n\trequire.ErrorIs(t, err, invpkg.ErrInvoiceAlreadySettled)\n\n\tif dbInvoice == nil {\n\t\tt.Fatalf(\"invoice from db is nil after settle!\")\n\t}\n\n\tinvoice.SettleDate = dbInvoice.SettleDate\n\trequire.Equal(\n\t\tt, invoice, dbInvoice, \"wrong invoice after second settle\",\n\t)\n}\n\n// TestQueryInvoices ensures that we can properly query the invoice database for\n// invoices using different types of queries.",
      "length": 1877,
      "tokens": 241,
      "embedding": []
    },
    {
      "slug": "func TestQueryInvoices(t *testing.T) {",
      "content": "func TestQueryInvoices(t *testing.T) {\n\tt.Parallel()\n\n\tdb, err := MakeTestDB(t, OptionClock(testClock))\n\trequire.NoError(t, err, \"unable to make test db\")\n\n\t// To begin the test, we'll add 50 invoices to the database. We'll\n\t// assume that the index of the invoice within the database is the same\n\t// as the amount of the invoice itself.\n\tconst numInvoices = 50\n\tvar settleIndex uint64 = 1\n\tvar invoices []invpkg.Invoice\n\tvar pendingInvoices []invpkg.Invoice\n\n\tfor i := 1; i <= numInvoices; i++ {\n\t\tamt := lnwire.MilliSatoshi(i)\n\t\tinvoice, err := randInvoice(amt)\n\t\tinvoice.CreationDate = invoice.CreationDate.Add(\n\t\t\ttime.Duration(i-1) * time.Second,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to create invoice: %v\", err)\n\t\t}\n\n\t\tpaymentHash := invoice.Terms.PaymentPreimage.Hash()\n\n\t\tif _, err := db.AddInvoice(invoice, paymentHash); err != nil {\n\t\t\tt.Fatalf(\"unable to add invoice: %v\", err)\n\t\t}\n\n\t\t// We'll only settle half of all invoices created.\n\t\tif i%2 == 0 {\n\t\t\tref := invpkg.InvoiceRefByHash(paymentHash)\n\t\t\t_, err := db.UpdateInvoice(\n\t\t\t\tref, nil, getUpdateInvoice(amt),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to settle invoice: %v\", err)\n\t\t\t}\n\n\t\t\t// Create the settled invoice for the expectation set.\n\t\t\tsettleTestInvoice(invoice, settleIndex)\n\t\t\tsettleIndex++\n\t\t} else {\n\t\t\tpendingInvoices = append(pendingInvoices, *invoice)\n\t\t}\n\n\t\tinvoices = append(invoices, *invoice)\n\t}\n\n\t// The test will consist of several queries along with their respective\n\t// expected response. Each query response should match its expected one.\n\ttestCases := []struct {\n\t\tquery    invpkg.InvoiceQuery\n\t\texpected []invpkg.Invoice\n\t}{\n\t\t// Fetch all invoices with a single query.\n\t\t{\n\t\t\tquery: invpkg.InvoiceQuery{\n\t\t\t\tNumMaxInvoices: numInvoices,\n\t\t\t},\n\t\t\texpected: invoices,\n\t\t},\n\t\t// Fetch all invoices with a single query, reversed.\n\t\t{\n\t\t\tquery: invpkg.InvoiceQuery{\n\t\t\t\tReversed:       true,\n\t\t\t\tNumMaxInvoices: numInvoices,\n\t\t\t},\n\t\t\texpected: invoices,\n\t\t},\n\t\t// Fetch the first 25 invoices.\n\t\t{\n\t\t\tquery: invpkg.InvoiceQuery{\n\t\t\t\tNumMaxInvoices: numInvoices / 2,\n\t\t\t},\n\t\t\texpected: invoices[:numInvoices/2],\n\t\t},\n\t\t// Fetch the first 10 invoices, but this time iterating\n\t\t// backwards.\n\t\t{\n\t\t\tquery: invpkg.InvoiceQuery{\n\t\t\t\tIndexOffset:    11,\n\t\t\t\tReversed:       true,\n\t\t\t\tNumMaxInvoices: numInvoices,\n\t\t\t},\n\t\t\texpected: invoices[:10],\n\t\t},\n\t\t// Fetch the last 40 invoices.\n\t\t{\n\t\t\tquery: invpkg.InvoiceQuery{\n\t\t\t\tIndexOffset:    10,\n\t\t\t\tNumMaxInvoices: numInvoices,\n\t\t\t},\n\t\t\texpected: invoices[10:],\n\t\t},\n\t\t// Fetch all but the first invoice.\n\t\t{\n\t\t\tquery: invpkg.InvoiceQuery{\n\t\t\t\tIndexOffset:    1,\n\t\t\t\tNumMaxInvoices: numInvoices,\n\t\t\t},\n\t\t\texpected: invoices[1:],\n\t\t},\n\t\t// Fetch one invoice, reversed, with index offset 3. This\n\t\t// should give us the second invoice in the array.\n\t\t{\n\t\t\tquery: invpkg.InvoiceQuery{\n\t\t\t\tIndexOffset:    3,\n\t\t\t\tReversed:       true,\n\t\t\t\tNumMaxInvoices: 1,\n\t\t\t},\n\t\t\texpected: invoices[1:2],\n\t\t},\n\t\t// Same as above, at index 2.\n\t\t{\n\t\t\tquery: invpkg.InvoiceQuery{\n\t\t\t\tIndexOffset:    2,\n\t\t\t\tReversed:       true,\n\t\t\t\tNumMaxInvoices: 1,\n\t\t\t},\n\t\t\texpected: invoices[0:1],\n\t\t},\n\t\t// Fetch one invoice, at index 1, reversed. Since invoice#1 is\n\t\t// the very first, there won't be any left in a reverse search,\n\t\t// so we expect no invoices to be returned.\n\t\t{\n\t\t\tquery: invpkg.InvoiceQuery{\n\t\t\t\tIndexOffset:    1,\n\t\t\t\tReversed:       true,\n\t\t\t\tNumMaxInvoices: 1,\n\t\t\t},\n\t\t\texpected: nil,\n\t\t},\n\t\t// Same as above, but don't restrict the number of invoices to\n\t\t// 1.\n\t\t{\n\t\t\tquery: invpkg.InvoiceQuery{\n\t\t\t\tIndexOffset:    1,\n\t\t\t\tReversed:       true,\n\t\t\t\tNumMaxInvoices: numInvoices,\n\t\t\t},\n\t\t\texpected: nil,\n\t\t},\n\t\t// Fetch one invoice, reversed, with no offset set. We expect\n\t\t// the last invoice in the response.\n\t\t{\n\t\t\tquery: invpkg.InvoiceQuery{\n\t\t\t\tReversed:       true,\n\t\t\t\tNumMaxInvoices: 1,\n\t\t\t},\n\t\t\texpected: invoices[numInvoices-1:],\n\t\t},\n\t\t// Fetch one invoice, reversed, the offset set at numInvoices+1.\n\t\t// We expect this to return the last invoice.\n\t\t{\n\t\t\tquery: invpkg.InvoiceQuery{\n\t\t\t\tIndexOffset:    numInvoices + 1,\n\t\t\t\tReversed:       true,\n\t\t\t\tNumMaxInvoices: 1,\n\t\t\t},\n\t\t\texpected: invoices[numInvoices-1:],\n\t\t},\n\t\t// Same as above, at offset numInvoices.\n\t\t{\n\t\t\tquery: invpkg.InvoiceQuery{\n\t\t\t\tIndexOffset:    numInvoices,\n\t\t\t\tReversed:       true,\n\t\t\t\tNumMaxInvoices: 1,\n\t\t\t},\n\t\t\texpected: invoices[numInvoices-2 : numInvoices-1],\n\t\t},\n\t\t// Fetch one invoice, at no offset (same as offset 0). We\n\t\t// expect the first invoice only in the response.\n\t\t{\n\t\t\tquery: invpkg.InvoiceQuery{\n\t\t\t\tNumMaxInvoices: 1,\n\t\t\t},\n\t\t\texpected: invoices[:1],\n\t\t},\n\t\t// Same as above, at offset 1.\n\t\t{\n\t\t\tquery: invpkg.InvoiceQuery{\n\t\t\t\tIndexOffset:    1,\n\t\t\t\tNumMaxInvoices: 1,\n\t\t\t},\n\t\t\texpected: invoices[1:2],\n\t\t},\n\t\t// Same as above, at offset 2.\n\t\t{\n\t\t\tquery: invpkg.InvoiceQuery{\n\t\t\t\tIndexOffset:    2,\n\t\t\t\tNumMaxInvoices: 1,\n\t\t\t},\n\t\t\texpected: invoices[2:3],\n\t\t},\n\t\t// Same as above, at offset numInvoices-1. Expect the last\n\t\t// invoice to be returned.\n\t\t{\n\t\t\tquery: invpkg.InvoiceQuery{\n\t\t\t\tIndexOffset:    numInvoices - 1,\n\t\t\t\tNumMaxInvoices: 1,\n\t\t\t},\n\t\t\texpected: invoices[numInvoices-1:],\n\t\t},\n\t\t// Same as above, at offset numInvoices. No invoices should be\n\t\t// returned, as there are no invoices after this offset.\n\t\t{\n\t\t\tquery: invpkg.InvoiceQuery{\n\t\t\t\tIndexOffset:    numInvoices,\n\t\t\t\tNumMaxInvoices: 1,\n\t\t\t},\n\t\t\texpected: nil,\n\t\t},\n\t\t// Fetch all pending invoices with a single query.\n\t\t{\n\t\t\tquery: invpkg.InvoiceQuery{\n\t\t\t\tPendingOnly:    true,\n\t\t\t\tNumMaxInvoices: numInvoices,\n\t\t\t},\n\t\t\texpected: pendingInvoices,\n\t\t},\n\t\t// Fetch the first 12 pending invoices.\n\t\t{\n\t\t\tquery: invpkg.InvoiceQuery{\n\t\t\t\tPendingOnly:    true,\n\t\t\t\tNumMaxInvoices: numInvoices / 4,\n\t\t\t},\n\t\t\texpected: pendingInvoices[:len(pendingInvoices)/2],\n\t\t},\n\t\t// Fetch the first 5 pending invoices, but this time iterating\n\t\t// backwards.\n\t\t{\n\t\t\tquery: invpkg.InvoiceQuery{\n\t\t\t\tIndexOffset:    10,\n\t\t\t\tPendingOnly:    true,\n\t\t\t\tReversed:       true,\n\t\t\t\tNumMaxInvoices: numInvoices,\n\t\t\t},\n\t\t\t// Since we seek to the invoice with index 10 and\n\t\t\t// iterate backwards, there should only be 5 pending\n\t\t\t// invoices before it as every other invoice within the\n\t\t\t// index is settled.\n\t\t\texpected: pendingInvoices[:5],\n\t\t},\n\t\t// Fetch the last 15 invoices.\n\t\t{\n\t\t\tquery: invpkg.InvoiceQuery{\n\t\t\t\tIndexOffset:    20,\n\t\t\t\tPendingOnly:    true,\n\t\t\t\tNumMaxInvoices: numInvoices,\n\t\t\t},\n\t\t\t// Since we seek to the invoice with index 20, there are\n\t\t\t// 30 invoices left. From these 30, only 15 of them are\n\t\t\t// still pending.\n\t\t\texpected: pendingInvoices[len(pendingInvoices)-15:],\n\t\t},\n\t\t// Fetch all invoices paginating backwards, with an index offset\n\t\t// that is beyond our last offset. We expect all invoices to be\n\t\t// returned.\n\t\t{\n\t\t\tquery: invpkg.InvoiceQuery{\n\t\t\t\tIndexOffset:    numInvoices * 2,\n\t\t\t\tPendingOnly:    false,\n\t\t\t\tReversed:       true,\n\t\t\t\tNumMaxInvoices: numInvoices,\n\t\t\t},\n\t\t\texpected: invoices,\n\t\t},\n\t\t// Fetch invoices <= 25 by creation date.\n\t\t{\n\t\t\tquery: invpkg.InvoiceQuery{\n\t\t\t\tNumMaxInvoices:  numInvoices,\n\t\t\t\tCreationDateEnd: time.Unix(25, 0),\n\t\t\t},\n\t\t\texpected: invoices[:25],\n\t\t},\n\t\t// Fetch invoices >= 26 creation date.\n\t\t{\n\t\t\tquery: invpkg.InvoiceQuery{\n\t\t\t\tNumMaxInvoices:    numInvoices,\n\t\t\t\tCreationDateStart: time.Unix(26, 0),\n\t\t\t},\n\t\t\texpected: invoices[25:],\n\t\t},\n\t\t// Fetch pending invoices <= 25 by creation date.\n\t\t{\n\t\t\tquery: invpkg.InvoiceQuery{\n\t\t\t\tPendingOnly:     true,\n\t\t\t\tNumMaxInvoices:  numInvoices,\n\t\t\t\tCreationDateEnd: time.Unix(25, 0),\n\t\t\t},\n\t\t\texpected: pendingInvoices[:13],\n\t\t},\n\t\t// Fetch pending invoices >= 26 creation date.\n\t\t{\n\t\t\tquery: invpkg.InvoiceQuery{\n\t\t\t\tPendingOnly:       true,\n\t\t\t\tNumMaxInvoices:    numInvoices,\n\t\t\t\tCreationDateStart: time.Unix(26, 0),\n\t\t\t},\n\t\t\texpected: pendingInvoices[13:],\n\t\t},\n\t\t// Fetch pending invoices with offset and end creation date.\n\t\t{\n\t\t\tquery: invpkg.InvoiceQuery{\n\t\t\t\tIndexOffset:     20,\n\t\t\t\tNumMaxInvoices:  numInvoices,\n\t\t\t\tCreationDateEnd: time.Unix(30, 0),\n\t\t\t},\n\t\t\t// Since we're skipping to invoice 20 and iterating\n\t\t\t// to invoice 30, we'll expect those invoices.\n\t\t\texpected: invoices[20:30],\n\t\t},\n\t\t// Fetch pending invoices with offset and start creation date\n\t\t// in reversed order.\n\t\t{\n\t\t\tquery: invpkg.InvoiceQuery{\n\t\t\t\tIndexOffset:       21,\n\t\t\t\tReversed:          true,\n\t\t\t\tNumMaxInvoices:    numInvoices,\n\t\t\t\tCreationDateStart: time.Unix(11, 0),\n\t\t\t},\n\t\t\t// Since we're skipping to invoice 20 and iterating\n\t\t\t// backward to invoice 10, we'll expect those invoices.\n\t\t\texpected: invoices[10:20],\n\t\t},\n\t\t// Fetch invoices with start and end creation date.\n\t\t{\n\t\t\tquery: invpkg.InvoiceQuery{\n\t\t\t\tNumMaxInvoices:    numInvoices,\n\t\t\t\tCreationDateStart: time.Unix(11, 0),\n\t\t\t\tCreationDateEnd:   time.Unix(20, 0),\n\t\t\t},\n\t\t\texpected: invoices[10:20],\n\t\t},\n\t\t// Fetch pending invoices with start and end creation date.\n\t\t{\n\t\t\tquery: invpkg.InvoiceQuery{\n\t\t\t\tPendingOnly:       true,\n\t\t\t\tNumMaxInvoices:    numInvoices,\n\t\t\t\tCreationDateStart: time.Unix(11, 0),\n\t\t\t\tCreationDateEnd:   time.Unix(20, 0),\n\t\t\t},\n\t\t\texpected: pendingInvoices[5:10],\n\t\t},\n\t\t// Fetch invoices with start and end creation date in reverse\n\t\t// order.\n\t\t{\n\t\t\tquery: invpkg.InvoiceQuery{\n\t\t\t\tReversed:          true,\n\t\t\t\tNumMaxInvoices:    numInvoices,\n\t\t\t\tCreationDateStart: time.Unix(11, 0),\n\t\t\t\tCreationDateEnd:   time.Unix(20, 0),\n\t\t\t},\n\t\t\texpected: invoices[10:20],\n\t\t},\n\t\t// Fetch pending invoices with start and end creation date in\n\t\t// reverse order.\n\t\t{\n\t\t\tquery: invpkg.InvoiceQuery{\n\t\t\t\tPendingOnly:       true,\n\t\t\t\tReversed:          true,\n\t\t\t\tNumMaxInvoices:    numInvoices,\n\t\t\t\tCreationDateStart: time.Unix(11, 0),\n\t\t\t\tCreationDateEnd:   time.Unix(20, 0),\n\t\t\t},\n\t\t\texpected: pendingInvoices[5:10],\n\t\t},\n\t\t// Fetch invoices with a start date greater than end date\n\t\t// should result in an empty slice.\n\t\t{\n\t\t\tquery: invpkg.InvoiceQuery{\n\t\t\t\tNumMaxInvoices:    numInvoices,\n\t\t\t\tCreationDateStart: time.Unix(20, 0),\n\t\t\t\tCreationDateEnd:   time.Unix(11, 0),\n\t\t\t},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tresponse, err := db.QueryInvoices(testCase.query)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to query invoice database: %v\", err)\n\t\t}\n\n\t\trequire.Equal(t, len(testCase.expected), len(response.Invoices))\n\n\t\tfor j, expected := range testCase.expected {\n\t\t\trequire.Equal(t,\n\t\t\t\texpected, response.Invoices[j],\n\t\t\t\tfmt.Sprintf(\"test: #%v, item: #%v\", i, j),\n\t\t\t)\n\t\t}\n\t}\n}\n\n// getUpdateInvoice returns an invoice update callback that, when called,\n// settles the invoice with the given amount.",
      "length": 10097,
      "tokens": 1239,
      "embedding": []
    },
    {
      "slug": "func getUpdateInvoice(amt lnwire.MilliSatoshi) invpkg.InvoiceUpdateCallback {",
      "content": "func getUpdateInvoice(amt lnwire.MilliSatoshi) invpkg.InvoiceUpdateCallback {\n\treturn func(invoice *invpkg.Invoice) (*invpkg.InvoiceUpdateDesc,\n\t\terror) {\n\n\t\tif invoice.State == invpkg.ContractSettled {\n\t\t\treturn nil, invpkg.ErrInvoiceAlreadySettled\n\t\t}\n\n\t\tnoRecords := make(record.CustomSet)\n\t\thtlcs := map[models.CircuitKey]*invpkg.HtlcAcceptDesc{\n\t\t\t{}: {\n\t\t\t\tAmt:           amt,\n\t\t\t\tCustomRecords: noRecords,\n\t\t\t},\n\t\t}\n\t\tupdate := &invpkg.InvoiceUpdateDesc{\n\t\t\tState: &invpkg.InvoiceStateUpdateDesc{\n\t\t\t\tPreimage: invoice.Terms.PaymentPreimage,\n\t\t\t\tNewState: invpkg.ContractSettled,\n\t\t\t},\n\t\t\tAddHtlcs: htlcs,\n\t\t}\n\n\t\treturn update, nil\n\t}\n}\n\n// TestCustomRecords tests that custom records are properly recorded in the\n// invoice database.",
      "length": 636,
      "tokens": 61,
      "embedding": []
    },
    {
      "slug": "func TestCustomRecords(t *testing.T) {",
      "content": "func TestCustomRecords(t *testing.T) {\n\tt.Parallel()\n\n\tdb, err := MakeTestDB(t)\n\trequire.NoError(t, err, \"unable to make test db\")\n\n\tpreimage := lntypes.Preimage{1}\n\tpaymentHash := preimage.Hash()\n\n\ttestInvoice := &invpkg.Invoice{\n\t\tHtlcs: map[models.CircuitKey]*invpkg.InvoiceHTLC{},\n\t\tTerms: invpkg.ContractTerm{\n\t\t\tValue:           lnwire.NewMSatFromSatoshis(10000),\n\t\t\tFeatures:        emptyFeatures,\n\t\t\tPaymentPreimage: &preimage,\n\t\t},\n\t}\n\n\tif _, err := db.AddInvoice(testInvoice, paymentHash); err != nil {\n\t\tt.Fatalf(\"unable to add invoice: %v\", err)\n\t}\n\n\t// Accept an htlc with custom records on this invoice.\n\tkey := models.CircuitKey{\n\t\tChanID: lnwire.NewShortChanIDFromInt(1),\n\t\tHtlcID: 4,\n\t}\n\n\trecords := record.CustomSet{\n\t\t100000: []byte{},\n\t\t100001: []byte{1, 2},\n\t}\n\n\tref := invpkg.InvoiceRefByHash(paymentHash)\n\tcallback := func(invoice *invpkg.Invoice) (*invpkg.InvoiceUpdateDesc,\n\t\terror) {\n\n\t\thtlcs := map[models.CircuitKey]*invpkg.HtlcAcceptDesc{\n\t\t\tkey: {\n\t\t\t\tAmt:           500,\n\t\t\t\tCustomRecords: records,\n\t\t\t},\n\t\t}\n\n\t\treturn &invpkg.InvoiceUpdateDesc{AddHtlcs: htlcs}, nil\n\t}\n\n\t_, err = db.UpdateInvoice(ref, nil, callback)\n\trequire.NoError(t, err, \"unable to add invoice htlc\")\n\n\t// Retrieve the invoice from that database and verify that the custom\n\t// records are present.\n\tdbInvoice, err := db.LookupInvoice(ref)\n\trequire.NoError(t, err, \"unable to lookup invoice\")\n\n\tif len(dbInvoice.Htlcs) != 1 {\n\t\tt.Fatalf(\"expected the htlc to be added\")\n\t}\n\n\trequire.Equal(t,\n\t\trecords, dbInvoice.Htlcs[key].CustomRecords,\n\t\t\"invalid custom records\",\n\t)\n}\n\n// TestInvoiceHtlcAMPFields asserts that the set id and preimage fields are\n// properly recorded when updating an invoice.",
      "length": 1593,
      "tokens": 180,
      "embedding": []
    },
    {
      "slug": "func TestInvoiceHtlcAMPFields(t *testing.T) {",
      "content": "func TestInvoiceHtlcAMPFields(t *testing.T) {\n\tt.Run(\"amp\", func(t *testing.T) {\n\t\ttestInvoiceHtlcAMPFields(t, true)\n\t})\n\tt.Run(\"no amp\", func(t *testing.T) {\n\t\ttestInvoiceHtlcAMPFields(t, false)\n\t})\n}\n",
      "length": 149,
      "tokens": 16,
      "embedding": []
    },
    {
      "slug": "func testInvoiceHtlcAMPFields(t *testing.T, isAMP bool) {",
      "content": "func testInvoiceHtlcAMPFields(t *testing.T, isAMP bool) {\n\tdb, err := MakeTestDB(t)\n\trequire.Nil(t, err)\n\n\ttestInvoice, err := randInvoice(1000)\n\trequire.Nil(t, err)\n\n\tif isAMP {\n\t\ttestInvoice.Terms.Features = ampFeatures\n\t}\n\n\tpayHash := testInvoice.Terms.PaymentPreimage.Hash()\n\t_, err = db.AddInvoice(testInvoice, payHash)\n\trequire.Nil(t, err)\n\n\t// Accept an htlc with custom records on this invoice.\n\tkey := models.CircuitKey{\n\t\tChanID: lnwire.NewShortChanIDFromInt(1),\n\t\tHtlcID: 4,\n\t}\n\trecords := make(map[uint64][]byte)\n\n\tvar ampData *invpkg.InvoiceHtlcAMPData\n\tif isAMP {\n\t\tamp := record.NewAMP([32]byte{1}, [32]byte{2}, 3)\n\t\tpreimage := &lntypes.Preimage{4}\n\n\t\tampData = &invpkg.InvoiceHtlcAMPData{\n\t\t\tRecord:   *amp,\n\t\t\tHash:     preimage.Hash(),\n\t\t\tPreimage: preimage,\n\t\t}\n\t}\n\n\tcallback := func(invoice *invpkg.Invoice) (*invpkg.InvoiceUpdateDesc,\n\t\terror) {\n\n\t\thtlcs := map[models.CircuitKey]*invpkg.HtlcAcceptDesc{\n\t\t\tkey: {\n\t\t\t\tAmt:           500,\n\t\t\t\tAMP:           ampData,\n\t\t\t\tCustomRecords: records,\n\t\t\t},\n\t\t}\n\n\t\treturn &invpkg.InvoiceUpdateDesc{AddHtlcs: htlcs}, nil\n\t}\n\n\tref := invpkg.InvoiceRefByHash(payHash)\n\t_, err = db.UpdateInvoice(ref, nil, callback)\n\trequire.Nil(t, err)\n\n\t// Retrieve the invoice from that database and verify that the AMP\n\t// fields are as expected.\n\tdbInvoice, err := db.LookupInvoice(ref)\n\trequire.Nil(t, err)\n\n\trequire.Equal(t, 1, len(dbInvoice.Htlcs))\n\trequire.Equal(t, ampData, dbInvoice.Htlcs[key].AMP)\n}\n\n// TestInvoiceRef asserts that the proper identifiers are returned from an\n// InvoiceRef depending on the constructor used.",
      "length": 1460,
      "tokens": 159,
      "embedding": []
    },
    {
      "slug": "func TestInvoiceRef(t *testing.T) {",
      "content": "func TestInvoiceRef(t *testing.T) {\n\tpayHash := lntypes.Hash{0x01}\n\tpayAddr := [32]byte{0x02}\n\tsetID := [32]byte{0x03}\n\n\t// An InvoiceRef by hash should return the provided hash and a nil\n\t// payment addr.\n\trefByHash := invpkg.InvoiceRefByHash(payHash)\n\trequire.Equal(t, &payHash, refByHash.PayHash())\n\trequire.Equal(t, (*[32]byte)(nil), refByHash.PayAddr())\n\trequire.Equal(t, (*[32]byte)(nil), refByHash.SetID())\n\n\t// An InvoiceRef by hash and addr should return the payment hash and\n\t// payment addr passed to the constructor.\n\trefByHashAndAddr := invpkg.InvoiceRefByHashAndAddr(payHash, payAddr)\n\trequire.Equal(t, &payHash, refByHashAndAddr.PayHash())\n\trequire.Equal(t, &payAddr, refByHashAndAddr.PayAddr())\n\trequire.Equal(t, (*[32]byte)(nil), refByHashAndAddr.SetID())\n\n\t// An InvoiceRef by set id should return an empty pay hash, a nil pay\n\t// addr, and a reference to the given set id.\n\trefBySetID := invpkg.InvoiceRefBySetID(setID)\n\trequire.Equal(t, (*lntypes.Hash)(nil), refBySetID.PayHash())\n\trequire.Equal(t, (*[32]byte)(nil), refBySetID.PayAddr())\n\trequire.Equal(t, &setID, refBySetID.SetID())\n\n\t// An InvoiceRef by pay addr should only return a pay addr, but nil for\n\t// pay hash and set id.\n\trefByAddr := invpkg.InvoiceRefByAddr(payAddr)\n\trequire.Equal(t, (*lntypes.Hash)(nil), refByAddr.PayHash())\n\trequire.Equal(t, &payAddr, refByAddr.PayAddr())\n\trequire.Equal(t, (*[32]byte)(nil), refByAddr.SetID())\n}\n\n// TestHTLCSet asserts that HTLCSet returns the proper set of accepted HTLCs\n// that can be considered for settlement. It asserts that MPP and AMP HTLCs do\n// not comingle, and also that HTLCs with disjoint set ids appear in different\n// sets.",
      "length": 1590,
      "tokens": 184,
      "embedding": []
    },
    {
      "slug": "func TestHTLCSet(t *testing.T) {",
      "content": "func TestHTLCSet(t *testing.T) {\n\tinv := &invpkg.Invoice{\n\t\tHtlcs: make(map[models.CircuitKey]*invpkg.InvoiceHTLC),\n\t}\n\n\t// Construct two distinct set id's, in this test we'll also track the\n\t// nil set id as a third group.\n\tsetID1 := &[32]byte{1}\n\tsetID2 := &[32]byte{2}\n\n\t// Create the expected htlc sets for each group, these will be updated\n\t// as the invoice is modified.\n\n\texpSetNil := make(map[models.CircuitKey]*invpkg.InvoiceHTLC)\n\texpSet1 := make(map[models.CircuitKey]*invpkg.InvoiceHTLC)\n\texpSet2 := make(map[models.CircuitKey]*invpkg.InvoiceHTLC)\n\n\tcheckHTLCSets := func() {\n\t\trequire.Equal(\n\t\t\tt, expSetNil,\n\t\t\tinv.HTLCSet(nil, invpkg.HtlcStateAccepted),\n\t\t)\n\t\trequire.Equal(\n\t\t\tt, expSet1,\n\t\t\tinv.HTLCSet(setID1, invpkg.HtlcStateAccepted),\n\t\t)\n\t\trequire.Equal(\n\t\t\tt, expSet2,\n\t\t\tinv.HTLCSet(setID2, invpkg.HtlcStateAccepted),\n\t\t)\n\t}\n\n\t// All HTLC sets should be empty initially.\n\tcheckHTLCSets()\n\n\t// Add the following sequence of HTLCs to the invoice, sanity checking\n\t// all three HTLC sets after each transition. This sequence asserts:\n\t//   - both nil and non-nil set ids can have multiple htlcs.\n\t//   - there may be distinct htlc sets with non-nil set ids.\n\t//   - only accepted htlcs are returned as part of the set.\n\thtlcs := []struct {\n\t\tsetID *[32]byte\n\t\tstate invpkg.HtlcState\n\t}{\n\t\t{nil, invpkg.HtlcStateAccepted},\n\t\t{nil, invpkg.HtlcStateAccepted},\n\t\t{setID1, invpkg.HtlcStateAccepted},\n\t\t{setID1, invpkg.HtlcStateAccepted},\n\t\t{setID2, invpkg.HtlcStateAccepted},\n\t\t{setID2, invpkg.HtlcStateAccepted},\n\t\t{nil, invpkg.HtlcStateCanceled},\n\t\t{setID1, invpkg.HtlcStateCanceled},\n\t\t{setID2, invpkg.HtlcStateCanceled},\n\t\t{nil, invpkg.HtlcStateSettled},\n\t\t{setID1, invpkg.HtlcStateSettled},\n\t\t{setID2, invpkg.HtlcStateSettled},\n\t}\n\n\tfor i, h := range htlcs {\n\t\tvar ampData *invpkg.InvoiceHtlcAMPData\n\t\tif h.setID != nil {\n\t\t\tampData = &invpkg.InvoiceHtlcAMPData{\n\t\t\t\tRecord: *record.NewAMP(\n\t\t\t\t\t[32]byte{0}, *h.setID, 0,\n\t\t\t\t),\n\t\t\t}\n\t\t}\n\n\t\t// Add the HTLC to the invoice's set of HTLCs.\n\t\tkey := models.CircuitKey{HtlcID: uint64(i)}\n\t\thtlc := &invpkg.InvoiceHTLC{\n\t\t\tAMP:   ampData,\n\t\t\tState: h.state,\n\t\t}\n\t\tinv.Htlcs[key] = htlc\n\n\t\t// Update our expected htlc set if the htlc is accepted,\n\t\t// otherwise it shouldn't be reflected.\n\t\tif h.state == invpkg.HtlcStateAccepted {\n\t\t\tswitch h.setID {\n\t\t\tcase nil:\n\t\t\t\texpSetNil[key] = htlc\n\t\t\tcase setID1:\n\t\t\t\texpSet1[key] = htlc\n\t\t\tcase setID2:\n\t\t\t\texpSet2[key] = htlc\n\t\t\tdefault:\n\t\t\t\tt.Fatalf(\"unexpected set id\")\n\t\t\t}\n\t\t}\n\n\t\tcheckHTLCSets()\n\t}\n}\n\n// TestAddInvoiceWithHTLCs asserts that you can't insert an invoice that already\n// has HTLCs.",
      "length": 2481,
      "tokens": 300,
      "embedding": []
    },
    {
      "slug": "func TestAddInvoiceWithHTLCs(t *testing.T) {",
      "content": "func TestAddInvoiceWithHTLCs(t *testing.T) {\n\tdb, err := MakeTestDB(t)\n\trequire.Nil(t, err)\n\n\ttestInvoice, err := randInvoice(1000)\n\trequire.Nil(t, err)\n\n\tkey := models.CircuitKey{HtlcID: 1}\n\ttestInvoice.Htlcs[key] = &invpkg.InvoiceHTLC{}\n\n\tpayHash := testInvoice.Terms.PaymentPreimage.Hash()\n\t_, err = db.AddInvoice(testInvoice, payHash)\n\trequire.Equal(t, invpkg.ErrInvoiceHasHtlcs, err)\n}\n\n// TestSetIDIndex asserts that the set id index properly adds new invoices as we\n// accept HTLCs, that they can be queried by their set id after accepting, and\n// that invoices with duplicate set ids are disallowed.",
      "length": 546,
      "tokens": 69,
      "embedding": []
    },
    {
      "slug": "func TestSetIDIndex(t *testing.T) {",
      "content": "func TestSetIDIndex(t *testing.T) {\n\ttestClock := clock.NewTestClock(testNow)\n\tdb, err := MakeTestDB(t, OptionClock(testClock))\n\trequire.Nil(t, err)\n\n\t// We'll start out by creating an invoice and writing it to the DB.\n\tamt := lnwire.NewMSatFromSatoshis(1000)\n\tinvoice, err := randInvoice(amt)\n\trequire.Nil(t, err)\n\n\t// Set AMP-specific features so that we can settle with HTLC-level\n\t// preimages.\n\tinvoice.Terms.Features = ampFeatures\n\n\tpreimage := *invoice.Terms.PaymentPreimage\n\tpayHash := preimage.Hash()\n\t_, err = db.AddInvoice(invoice, payHash)\n\trequire.Nil(t, err)\n\n\tsetID := &[32]byte{1}\n\n\t// Update the invoice with an accepted HTLC that also accepts the\n\t// invoice.\n\tref := invpkg.InvoiceRefByHashAndAddr(\n\t\tpayHash, invoice.Terms.PaymentAddr,\n\t)\n\tdbInvoice, err := db.UpdateInvoice(\n\t\tref, (*invpkg.SetID)(setID),\n\t\tupdateAcceptAMPHtlc(0, amt, setID, true),\n\t)\n\trequire.Nil(t, err)\n\n\t// We'll update what we expect the accepted invoice to be so that our\n\t// comparison below has the correct assumption.\n\tinvoice.State = invpkg.ContractOpen\n\tinvoice.AmtPaid = amt\n\tinvoice.SettleDate = dbInvoice.SettleDate\n\thtlc0 := models.CircuitKey{HtlcID: 0}\n\tinvoice.Htlcs = map[models.CircuitKey]*invpkg.InvoiceHTLC{\n\t\thtlc0: makeAMPInvoiceHTLC(amt, *setID, payHash, &preimage),\n\t}\n\tinvoice.AMPState = map[invpkg.SetID]invpkg.InvoiceStateAMP{}\n\tinvoice.AMPState[*setID] = invpkg.InvoiceStateAMP{\n\t\tState:   invpkg.HtlcStateAccepted,\n\t\tAmtPaid: amt,\n\t\tInvoiceKeys: map[models.CircuitKey]struct{}{\n\t\t\thtlc0: {},\n\t\t},\n\t}\n\n\t// We should get back the exact same invoice that we just inserted.\n\trequire.Equal(t, invoice, dbInvoice)\n\n\t// Now lookup the invoice by set id and see that we get the same one.\n\trefBySetID := invpkg.InvoiceRefBySetID(*setID)\n\tdbInvoiceBySetID, err := db.LookupInvoice(refBySetID)\n\trequire.Nil(t, err)\n\trequire.Equal(t, invoice, &dbInvoiceBySetID)\n\n\t// Trying to accept an HTLC to a different invoice, but using the same\n\t// set id should fail.\n\tinvoice2, err := randInvoice(amt)\n\trequire.Nil(t, err)\n\n\t// Set AMP-specific features so that we can settle with HTLC-level\n\t// preimages.\n\tinvoice2.Terms.Features = ampFeatures\n\n\tpayHash2 := invoice2.Terms.PaymentPreimage.Hash()\n\t_, err = db.AddInvoice(invoice2, payHash2)\n\trequire.Nil(t, err)\n\n\tref2 := invpkg.InvoiceRefByHashAndAddr(\n\t\tpayHash2, invoice2.Terms.PaymentAddr,\n\t)\n\t_, err = db.UpdateInvoice(\n\t\tref2, (*invpkg.SetID)(setID),\n\t\tupdateAcceptAMPHtlc(0, amt, setID, true),\n\t)\n\trequire.Equal(t, invpkg.ErrDuplicateSetID{SetID: *setID}, err)\n\n\t// Now, begin constructing a second htlc set under a different set id.\n\t// This set will contain two distinct HTLCs.\n\tsetID2 := &[32]byte{2}\n\n\t_, err = db.UpdateInvoice(\n\t\tref, (*invpkg.SetID)(setID2),\n\t\tupdateAcceptAMPHtlc(1, amt, setID2, false),\n\t)\n\trequire.Nil(t, err)\n\tdbInvoice, err = db.UpdateInvoice(\n\t\tref, (*invpkg.SetID)(setID2),\n\t\tupdateAcceptAMPHtlc(2, amt, setID2, false),\n\t)\n\trequire.Nil(t, err)\n\n\t// We'll update what we expect the settle invoice to be so that our\n\t// comparison below has the correct assumption.\n\tinvoice.State = invpkg.ContractOpen\n\tinvoice.AmtPaid += 2 * amt\n\tinvoice.SettleDate = dbInvoice.SettleDate\n\thtlc1 := models.CircuitKey{HtlcID: 1}\n\thtlc2 := models.CircuitKey{HtlcID: 2}\n\tinvoice.Htlcs = map[models.CircuitKey]*invpkg.InvoiceHTLC{\n\t\thtlc0: makeAMPInvoiceHTLC(amt, *setID, payHash, &preimage),\n\t\thtlc1: makeAMPInvoiceHTLC(amt, *setID2, payHash, nil),\n\t\thtlc2: makeAMPInvoiceHTLC(amt, *setID2, payHash, nil),\n\t}\n\tinvoice.AMPState[*setID] = invpkg.InvoiceStateAMP{\n\t\tState:   invpkg.HtlcStateAccepted,\n\t\tAmtPaid: amt,\n\t\tInvoiceKeys: map[models.CircuitKey]struct{}{\n\t\t\thtlc0: {},\n\t\t},\n\t}\n\tinvoice.AMPState[*setID2] = invpkg.InvoiceStateAMP{\n\t\tState:   invpkg.HtlcStateAccepted,\n\t\tAmtPaid: amt * 2,\n\t\tInvoiceKeys: map[models.CircuitKey]struct{}{\n\t\t\thtlc1: {},\n\t\t\thtlc2: {},\n\t\t},\n\t}\n\n\t// Since UpdateInvoice will only return the sub-set of updated HTLcs,\n\t// we'll query again to ensure we get the full set of HTLCs returned.\n\tfreshInvoice, err := db.LookupInvoice(ref)\n\trequire.Nil(t, err)\n\tdbInvoice = &freshInvoice\n\n\t// We should get back the exact same invoice that we just inserted.\n\trequire.Equal(t, invoice, dbInvoice)\n\n\t// Now lookup the invoice by second set id and see that we get the same\n\t// index, including the htlcs under the first set id.\n\trefBySetID = invpkg.InvoiceRefBySetID(*setID2)\n\tdbInvoiceBySetID, err = db.LookupInvoice(refBySetID)\n\trequire.Nil(t, err)\n\trequire.Equal(t, invoice, &dbInvoiceBySetID)\n\n\t// Now attempt to settle a non-existent HTLC set, this set ID is the\n\t// zero setID so it isn't used for anything internally.\n\t_, err = db.UpdateInvoice(\n\t\tref, nil,\n\t\tgetUpdateInvoiceAMPSettle(\n\t\t\t&[32]byte{}, [32]byte{},\n\t\t\tmodels.CircuitKey{HtlcID: 99},\n\t\t),\n\t)\n\trequire.Equal(t, invpkg.ErrEmptyHTLCSet, err)\n\n\t// Now settle the first htlc set. The existing HTLCs should remain in\n\t// the accepted state and shouldn't be canceled, since we permit an\n\t// invoice to be settled multiple times.\n\t_, err = db.UpdateInvoice(\n\t\tref, (*invpkg.SetID)(setID),\n\t\tgetUpdateInvoiceAMPSettle(\n\t\t\tsetID, preimage, models.CircuitKey{HtlcID: 0},\n\t\t),\n\t)\n\trequire.Nil(t, err)\n\n\tfreshInvoice, err = db.LookupInvoice(ref)\n\trequire.Nil(t, err)\n\tdbInvoice = &freshInvoice\n\n\tinvoice.State = invpkg.ContractOpen\n\n\t// The amount paid should reflect that we have 3 present HTLCs, each\n\t// with an amount of the original invoice.\n\tinvoice.AmtPaid = amt * 3\n\n\tampState := invoice.AMPState[*setID]\n\tampState.State = invpkg.HtlcStateSettled\n\tampState.SettleDate = testNow\n\tampState.SettleIndex = 1\n\n\tinvoice.AMPState[*setID] = ampState\n\n\tinvoice.Htlcs[htlc0].State = invpkg.HtlcStateSettled\n\tinvoice.Htlcs[htlc0].ResolveTime = time.Unix(1, 0)\n\n\trequire.Equal(t, invoice, dbInvoice)\n\n\t// If we try to settle the same set ID again, then we should get an\n\t// error, as it's already been settled.\n\t_, err = db.UpdateInvoice(\n\t\tref, (*invpkg.SetID)(setID),\n\t\tgetUpdateInvoiceAMPSettle(\n\t\t\tsetID, preimage, models.CircuitKey{HtlcID: 0},\n\t\t),\n\t)\n\trequire.Equal(t, invpkg.ErrEmptyHTLCSet, err)\n\n\t// Next, let's attempt to settle the other active set ID for this\n\t// invoice. This will allow us to exercise the case where we go to\n\t// settle an invoice with a new setID after one has already been fully\n\t// settled.\n\t_, err = db.UpdateInvoice(\n\t\tref, (*invpkg.SetID)(setID2),\n\t\tgetUpdateInvoiceAMPSettle(\n\t\t\tsetID2, preimage, models.CircuitKey{HtlcID: 1},\n\t\t\tmodels.CircuitKey{HtlcID: 2},\n\t\t),\n\t)\n\trequire.Nil(t, err)\n\n\tfreshInvoice, err = db.LookupInvoice(ref)\n\trequire.Nil(t, err)\n\tdbInvoice = &freshInvoice\n\n\t// Now the rest of the HTLCs should show as fully settled.\n\tampState = invoice.AMPState[*setID2]\n\tampState.State = invpkg.HtlcStateSettled\n\tampState.SettleDate = testNow\n\tampState.SettleIndex = 2\n\n\tinvoice.AMPState[*setID2] = ampState\n\n\tinvoice.Htlcs[htlc1].State = invpkg.HtlcStateSettled\n\tinvoice.Htlcs[htlc1].ResolveTime = time.Unix(1, 0)\n\tinvoice.Htlcs[htlc1].AMP.Preimage = &preimage\n\n\tinvoice.Htlcs[htlc2].State = invpkg.HtlcStateSettled\n\tinvoice.Htlcs[htlc2].ResolveTime = time.Unix(1, 0)\n\tinvoice.Htlcs[htlc2].AMP.Preimage = &preimage\n\n\trequire.Equal(t, invoice, dbInvoice)\n\n\t// Lastly, querying for an unknown set id should fail.\n\trefUnknownSetID := invpkg.InvoiceRefBySetID([32]byte{})\n\t_, err = db.LookupInvoice(refUnknownSetID)\n\trequire.Equal(t, invpkg.ErrInvoiceNotFound, err)\n}\n",
      "length": 7084,
      "tokens": 829,
      "embedding": []
    },
    {
      "slug": "func makeAMPInvoiceHTLC(amt lnwire.MilliSatoshi, setID [32]byte,",
      "content": "func makeAMPInvoiceHTLC(amt lnwire.MilliSatoshi, setID [32]byte,\n\thash lntypes.Hash, preimage *lntypes.Preimage) *invpkg.InvoiceHTLC {\n\n\treturn &invpkg.InvoiceHTLC{\n\t\tAmt:           amt,\n\t\tAcceptTime:    testNow,\n\t\tResolveTime:   time.Time{},\n\t\tState:         invpkg.HtlcStateAccepted,\n\t\tCustomRecords: make(record.CustomSet),\n\t\tAMP: &invpkg.InvoiceHtlcAMPData{\n\t\t\tRecord:   *record.NewAMP([32]byte{}, setID, 0),\n\t\t\tHash:     hash,\n\t\t\tPreimage: preimage,\n\t\t},\n\t}\n}\n\n// updateAcceptAMPHtlc returns an invoice update callback that, when called,\n// settles the invoice with the given amount.",
      "length": 506,
      "tokens": 49,
      "embedding": []
    },
    {
      "slug": "func updateAcceptAMPHtlc(id uint64, amt lnwire.MilliSatoshi,",
      "content": "func updateAcceptAMPHtlc(id uint64, amt lnwire.MilliSatoshi,\n\tsetID *[32]byte, accept bool) invpkg.InvoiceUpdateCallback {\n\n\treturn func(invoice *invpkg.Invoice) (*invpkg.InvoiceUpdateDesc,\n\t\terror) {\n\n\t\tif invoice.State == invpkg.ContractSettled {\n\t\t\treturn nil, invpkg.ErrInvoiceAlreadySettled\n\t\t}\n\n\t\tnoRecords := make(record.CustomSet)\n\n\t\tvar (\n\t\t\tstate    *invpkg.InvoiceStateUpdateDesc\n\t\t\tpreimage *lntypes.Preimage\n\t\t)\n\t\tif accept {\n\t\t\tstate = &invpkg.InvoiceStateUpdateDesc{\n\t\t\t\tNewState: invpkg.ContractAccepted,\n\t\t\t\tSetID:    setID,\n\t\t\t}\n\t\t\tpre := *invoice.Terms.PaymentPreimage\n\t\t\tpreimage = &pre\n\t\t}\n\n\t\tampData := &invpkg.InvoiceHtlcAMPData{\n\t\t\tRecord:   *record.NewAMP([32]byte{}, *setID, 0),\n\t\t\tHash:     invoice.Terms.PaymentPreimage.Hash(),\n\t\t\tPreimage: preimage,\n\t\t}\n\n\t\thtlcs := map[models.CircuitKey]*invpkg.HtlcAcceptDesc{\n\t\t\t{HtlcID: id}: {\n\t\t\t\tAmt:           amt,\n\t\t\t\tCustomRecords: noRecords,\n\t\t\t\tAMP:           ampData,\n\t\t\t},\n\t\t}\n\n\t\tupdate := &invpkg.InvoiceUpdateDesc{\n\t\t\tState:    state,\n\t\t\tAddHtlcs: htlcs,\n\t\t}\n\n\t\treturn update, nil\n\t}\n}\n",
      "length": 956,
      "tokens": 88,
      "embedding": []
    },
    {
      "slug": "func getUpdateInvoiceAMPSettle(setID *[32]byte, preimage [32]byte,",
      "content": "func getUpdateInvoiceAMPSettle(setID *[32]byte, preimage [32]byte,\n\tcircuitKeys ...models.CircuitKey) invpkg.InvoiceUpdateCallback {\n\n\treturn func(invoice *invpkg.Invoice) (*invpkg.InvoiceUpdateDesc,\n\t\terror) {\n\n\t\tif invoice.State == invpkg.ContractSettled {\n\t\t\treturn nil, invpkg.ErrInvoiceAlreadySettled\n\t\t}\n\n\t\tpreImageSet := make(map[models.CircuitKey]lntypes.Preimage)\n\t\tfor _, key := range circuitKeys {\n\t\t\tpreImageSet[key] = preimage\n\t\t}\n\n\t\tupdate := &invpkg.InvoiceUpdateDesc{\n\t\t\tState: &invpkg.InvoiceStateUpdateDesc{\n\t\t\t\tPreimage:      nil,\n\t\t\t\tNewState:      invpkg.ContractSettled,\n\t\t\t\tSetID:         setID,\n\t\t\t\tHTLCPreimages: preImageSet,\n\t\t\t},\n\t\t}\n\n\t\treturn update, nil\n\t}\n}\n\n// TestUnexpectedInvoicePreimage asserts that legacy or MPP invoices cannot be\n// settled when referenced by payment address only. Since regular or MPP\n// payments do not store the payment hash explicitly (it is stored in the\n// index), this enforces that they can only be updated using a InvoiceRefByHash\n// or InvoiceRefByHashOrAddr.",
      "length": 926,
      "tokens": 105,
      "embedding": []
    },
    {
      "slug": "func TestUnexpectedInvoicePreimage(t *testing.T) {",
      "content": "func TestUnexpectedInvoicePreimage(t *testing.T) {\n\tt.Parallel()\n\n\tdb, err := MakeTestDB(t)\n\trequire.NoError(t, err, \"unable to make test db\")\n\n\tinvoice, err := randInvoice(lnwire.MilliSatoshi(100))\n\trequire.NoError(t, err)\n\n\t// Add a random invoice indexed by payment hash and payment addr.\n\tpaymentHash := invoice.Terms.PaymentPreimage.Hash()\n\t_, err = db.AddInvoice(invoice, paymentHash)\n\trequire.NoError(t, err)\n\n\t// Attempt to update the invoice by pay addr only. This will fail since,\n\t// in order to settle an MPP invoice, the InvoiceRef must present a\n\t// payment hash against which to validate the preimage.\n\t_, err = db.UpdateInvoice(\n\t\tinvpkg.InvoiceRefByAddr(invoice.Terms.PaymentAddr), nil,\n\t\tgetUpdateInvoice(invoice.Terms.Value),\n\t)\n\n\t// Assert that we get ErrUnexpectedInvoicePreimage.\n\trequire.Error(t, invpkg.ErrUnexpectedInvoicePreimage, err)\n}\n",
      "length": 789,
      "tokens": 94,
      "embedding": []
    },
    {
      "slug": "type updateHTLCPreimageTestCase struct {",
      "content": "type updateHTLCPreimageTestCase struct {\n\tname               string\n\tsettleSamePreimage bool\n\texpError           error\n}\n\n// TestUpdateHTLCPreimages asserts various properties of setting HTLC-level\n// preimages on invoice state transitions.",
      "length": 193,
      "tokens": 21,
      "embedding": []
    },
    {
      "slug": "func TestUpdateHTLCPreimages(t *testing.T) {",
      "content": "func TestUpdateHTLCPreimages(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []updateHTLCPreimageTestCase{\n\t\t{\n\t\t\tname:               \"same preimage on settle\",\n\t\t\tsettleSamePreimage: true,\n\t\t\texpError:           nil,\n\t\t},\n\t\t{\n\t\t\tname:               \"diff preimage on settle\",\n\t\t\tsettleSamePreimage: false,\n\t\t\texpError:           invpkg.ErrHTLCPreimageAlreadyExists,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\ttestUpdateHTLCPreimages(t, test)\n\t\t})\n\t}\n}\n",
      "length": 433,
      "tokens": 46,
      "embedding": []
    },
    {
      "slug": "func testUpdateHTLCPreimages(t *testing.T, test updateHTLCPreimageTestCase) {",
      "content": "func testUpdateHTLCPreimages(t *testing.T, test updateHTLCPreimageTestCase) {\n\tdb, err := MakeTestDB(t)\n\trequire.NoError(t, err, \"unable to make test db\")\n\n\t// We'll start out by creating an invoice and writing it to the DB.\n\tamt := lnwire.NewMSatFromSatoshis(1000)\n\tinvoice, err := randInvoice(amt)\n\trequire.Nil(t, err)\n\n\tpreimage := *invoice.Terms.PaymentPreimage\n\tpayHash := preimage.Hash()\n\n\t// Set AMP-specific features so that we can settle with HTLC-level\n\t// preimages.\n\tinvoice.Terms.Features = ampFeatures\n\n\t_, err = db.AddInvoice(invoice, payHash)\n\trequire.Nil(t, err)\n\n\tsetID := &[32]byte{1}\n\n\t// Update the invoice with an accepted HTLC that also accepts the\n\t// invoice.\n\tref := invpkg.InvoiceRefByAddr(invoice.Terms.PaymentAddr)\n\tdbInvoice, err := db.UpdateInvoice(\n\t\tref, (*invpkg.SetID)(setID),\n\t\tupdateAcceptAMPHtlc(0, amt, setID, true),\n\t)\n\trequire.Nil(t, err)\n\n\thtlcPreimages := make(map[models.CircuitKey]lntypes.Preimage)\n\tfor key := range dbInvoice.Htlcs {\n\t\t// Set the either the same preimage used to accept above, or a\n\t\t// blank preimage depending on the test case.\n\t\tvar pre lntypes.Preimage\n\t\tif test.settleSamePreimage {\n\t\t\tpre = preimage\n\t\t}\n\t\thtlcPreimages[key] = pre\n\t}\n\n\tupdateInvoice := func(\n\t\tinvoice *invpkg.Invoice) (*invpkg.InvoiceUpdateDesc, error) {\n\n\t\tupdate := &invpkg.InvoiceUpdateDesc{\n\t\t\tState: &invpkg.InvoiceStateUpdateDesc{\n\t\t\t\tPreimage:      nil,\n\t\t\t\tNewState:      invpkg.ContractSettled,\n\t\t\t\tHTLCPreimages: htlcPreimages,\n\t\t\t\tSetID:         setID,\n\t\t\t},\n\t\t}\n\n\t\treturn update, nil\n\t}\n\n\t// Now settle the HTLC set and assert the resulting error.\n\t_, err = db.UpdateInvoice(ref, (*invpkg.SetID)(setID), updateInvoice)\n\trequire.Equal(t, test.expError, err)\n}\n",
      "length": 1571,
      "tokens": 188,
      "embedding": []
    },
    {
      "slug": "type updateHTLCTest struct {",
      "content": "type updateHTLCTest struct {\n\tname     string\n\tinput    invpkg.InvoiceHTLC\n\tinvState invpkg.ContractState\n\tsetID    *[32]byte\n\toutput   invpkg.InvoiceHTLC\n\texpErr   error\n}\n\n// TestUpdateHTLC asserts the behavior of the updateHTLC method in various\n// scenarios for MPP and AMP.",
      "length": 240,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func TestUpdateHTLC(t *testing.T) {",
      "content": "func TestUpdateHTLC(t *testing.T) {\n\tt.Parallel()\n\n\tsetID := [32]byte{0x01}\n\tampRecord := record.NewAMP([32]byte{0x02}, setID, 3)\n\tpreimage := lntypes.Preimage{0x04}\n\thash := preimage.Hash()\n\n\tdiffSetID := [32]byte{0x05}\n\tfakePreimage := lntypes.Preimage{0x06}\n\ttestAlreadyNow := time.Now()\n\n\ttests := []updateHTLCTest{\n\t\t{\n\t\t\tname: \"MPP accept\",\n\t\t\tinput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   time.Time{},\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateAccepted,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP:           nil,\n\t\t\t},\n\t\t\tinvState: invpkg.ContractAccepted,\n\t\t\tsetID:    nil,\n\t\t\toutput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   time.Time{},\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateAccepted,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP:           nil,\n\t\t\t},\n\t\t\texpErr: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"MPP settle\",\n\t\t\tinput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   time.Time{},\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateAccepted,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP:           nil,\n\t\t\t},\n\t\t\tinvState: invpkg.ContractSettled,\n\t\t\tsetID:    nil,\n\t\t\toutput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   testNow,\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateSettled,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP:           nil,\n\t\t\t},\n\t\t\texpErr: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"MPP cancel\",\n\t\t\tinput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   time.Time{},\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateAccepted,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP:           nil,\n\t\t\t},\n\t\t\tinvState: invpkg.ContractCanceled,\n\t\t\tsetID:    nil,\n\t\t\toutput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   testNow,\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateCanceled,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP:           nil,\n\t\t\t},\n\t\t\texpErr: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"AMP accept missing preimage\",\n\t\t\tinput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   time.Time{},\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateAccepted,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP: &invpkg.InvoiceHtlcAMPData{\n\t\t\t\t\tRecord:   *ampRecord,\n\t\t\t\t\tHash:     hash,\n\t\t\t\t\tPreimage: nil,\n\t\t\t\t},\n\t\t\t},\n\t\t\tinvState: invpkg.ContractAccepted,\n\t\t\tsetID:    &setID,\n\t\t\toutput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   time.Time{},\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateAccepted,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP: &invpkg.InvoiceHtlcAMPData{\n\t\t\t\t\tRecord:   *ampRecord,\n\t\t\t\t\tHash:     hash,\n\t\t\t\t\tPreimage: nil,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpErr: invpkg.ErrHTLCPreimageMissing,\n\t\t},\n\t\t{\n\t\t\tname: \"AMP accept invalid preimage\",\n\t\t\tinput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   time.Time{},\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateAccepted,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP: &invpkg.InvoiceHtlcAMPData{\n\t\t\t\t\tRecord:   *ampRecord,\n\t\t\t\t\tHash:     hash,\n\t\t\t\t\tPreimage: &fakePreimage,\n\t\t\t\t},\n\t\t\t},\n\t\t\tinvState: invpkg.ContractAccepted,\n\t\t\tsetID:    &setID,\n\t\t\toutput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   time.Time{},\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateAccepted,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP: &invpkg.InvoiceHtlcAMPData{\n\t\t\t\t\tRecord:   *ampRecord,\n\t\t\t\t\tHash:     hash,\n\t\t\t\t\tPreimage: &fakePreimage,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpErr: invpkg.ErrHTLCPreimageMismatch,\n\t\t},\n\t\t{\n\t\t\tname: \"AMP accept valid preimage\",\n\t\t\tinput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   time.Time{},\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateAccepted,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP: &invpkg.InvoiceHtlcAMPData{\n\t\t\t\t\tRecord:   *ampRecord,\n\t\t\t\t\tHash:     hash,\n\t\t\t\t\tPreimage: &preimage,\n\t\t\t\t},\n\t\t\t},\n\t\t\tinvState: invpkg.ContractAccepted,\n\t\t\tsetID:    &setID,\n\t\t\toutput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   time.Time{},\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateAccepted,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP: &invpkg.InvoiceHtlcAMPData{\n\t\t\t\t\tRecord:   *ampRecord,\n\t\t\t\t\tHash:     hash,\n\t\t\t\t\tPreimage: &preimage,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpErr: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"AMP accept valid preimage different htlc set\",\n\t\t\tinput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   time.Time{},\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateAccepted,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP: &invpkg.InvoiceHtlcAMPData{\n\t\t\t\t\tRecord:   *ampRecord,\n\t\t\t\t\tHash:     hash,\n\t\t\t\t\tPreimage: &preimage,\n\t\t\t\t},\n\t\t\t},\n\t\t\tinvState: invpkg.ContractAccepted,\n\t\t\tsetID:    &diffSetID,\n\t\t\toutput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   time.Time{},\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateAccepted,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP: &invpkg.InvoiceHtlcAMPData{\n\t\t\t\t\tRecord:   *ampRecord,\n\t\t\t\t\tHash:     hash,\n\t\t\t\t\tPreimage: &preimage,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpErr: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"AMP settle missing preimage\",\n\t\t\tinput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   time.Time{},\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateAccepted,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP: &invpkg.InvoiceHtlcAMPData{\n\t\t\t\t\tRecord:   *ampRecord,\n\t\t\t\t\tHash:     hash,\n\t\t\t\t\tPreimage: nil,\n\t\t\t\t},\n\t\t\t},\n\t\t\tinvState: invpkg.ContractSettled,\n\t\t\tsetID:    &setID,\n\t\t\toutput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   time.Time{},\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateAccepted,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP: &invpkg.InvoiceHtlcAMPData{\n\t\t\t\t\tRecord:   *ampRecord,\n\t\t\t\t\tHash:     hash,\n\t\t\t\t\tPreimage: nil,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpErr: invpkg.ErrHTLCPreimageMissing,\n\t\t},\n\t\t{\n\t\t\tname: \"AMP settle invalid preimage\",\n\t\t\tinput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   time.Time{},\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateAccepted,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP: &invpkg.InvoiceHtlcAMPData{\n\t\t\t\t\tRecord:   *ampRecord,\n\t\t\t\t\tHash:     hash,\n\t\t\t\t\tPreimage: &fakePreimage,\n\t\t\t\t},\n\t\t\t},\n\t\t\tinvState: invpkg.ContractSettled,\n\t\t\tsetID:    &setID,\n\t\t\toutput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   time.Time{},\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateAccepted,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP: &invpkg.InvoiceHtlcAMPData{\n\t\t\t\t\tRecord:   *ampRecord,\n\t\t\t\t\tHash:     hash,\n\t\t\t\t\tPreimage: &fakePreimage,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpErr: invpkg.ErrHTLCPreimageMismatch,\n\t\t},\n\t\t{\n\t\t\tname: \"AMP settle valid preimage\",\n\t\t\tinput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   time.Time{},\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateAccepted,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP: &invpkg.InvoiceHtlcAMPData{\n\t\t\t\t\tRecord:   *ampRecord,\n\t\t\t\t\tHash:     hash,\n\t\t\t\t\tPreimage: &preimage,\n\t\t\t\t},\n\t\t\t},\n\t\t\tinvState: invpkg.ContractSettled,\n\t\t\tsetID:    &setID,\n\t\t\toutput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   testNow,\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateSettled,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP: &invpkg.InvoiceHtlcAMPData{\n\t\t\t\t\tRecord:   *ampRecord,\n\t\t\t\t\tHash:     hash,\n\t\t\t\t\tPreimage: &preimage,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpErr: nil,\n\t\t},\n\t\t{\n\t\t\t// With the newer AMP logic, this is now valid, as we\n\t\t\t// want to be able to accept multiple settle attempts\n\t\t\t// to a given pay_addr. In this case, the HTLC should\n\t\t\t// remain in the accepted state.\n\t\t\tname: \"AMP settle valid preimage different htlc set\",\n\t\t\tinput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   time.Time{},\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateAccepted,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP: &invpkg.InvoiceHtlcAMPData{\n\t\t\t\t\tRecord:   *ampRecord,\n\t\t\t\t\tHash:     hash,\n\t\t\t\t\tPreimage: &preimage,\n\t\t\t\t},\n\t\t\t},\n\t\t\tinvState: invpkg.ContractSettled,\n\t\t\tsetID:    &diffSetID,\n\t\t\toutput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   time.Time{},\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateAccepted,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP: &invpkg.InvoiceHtlcAMPData{\n\t\t\t\t\tRecord:   *ampRecord,\n\t\t\t\t\tHash:     hash,\n\t\t\t\t\tPreimage: &preimage,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpErr: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"accept invoice htlc already settled\",\n\t\t\tinput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   testAlreadyNow,\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateSettled,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP: &invpkg.InvoiceHtlcAMPData{\n\t\t\t\t\tRecord:   *ampRecord,\n\t\t\t\t\tHash:     hash,\n\t\t\t\t\tPreimage: &preimage,\n\t\t\t\t},\n\t\t\t},\n\t\t\tinvState: invpkg.ContractAccepted,\n\t\t\tsetID:    &setID,\n\t\t\toutput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   testAlreadyNow,\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateSettled,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP: &invpkg.InvoiceHtlcAMPData{\n\t\t\t\t\tRecord:   *ampRecord,\n\t\t\t\t\tHash:     hash,\n\t\t\t\t\tPreimage: &preimage,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpErr: invpkg.ErrHTLCAlreadySettled,\n\t\t},\n\t\t{\n\t\t\tname: \"cancel invoice htlc already settled\",\n\t\t\tinput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   testAlreadyNow,\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateSettled,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP: &invpkg.InvoiceHtlcAMPData{\n\t\t\t\t\tRecord:   *ampRecord,\n\t\t\t\t\tHash:     hash,\n\t\t\t\t\tPreimage: &preimage,\n\t\t\t\t},\n\t\t\t},\n\t\t\tinvState: invpkg.ContractCanceled,\n\t\t\tsetID:    &setID,\n\t\t\toutput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   testAlreadyNow,\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateSettled,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP: &invpkg.InvoiceHtlcAMPData{\n\t\t\t\t\tRecord:   *ampRecord,\n\t\t\t\t\tHash:     hash,\n\t\t\t\t\tPreimage: &preimage,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpErr: invpkg.ErrHTLCAlreadySettled,\n\t\t},\n\t\t{\n\t\t\tname: \"settle invoice htlc already settled\",\n\t\t\tinput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   testAlreadyNow,\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateSettled,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP: &invpkg.InvoiceHtlcAMPData{\n\t\t\t\t\tRecord:   *ampRecord,\n\t\t\t\t\tHash:     hash,\n\t\t\t\t\tPreimage: &preimage,\n\t\t\t\t},\n\t\t\t},\n\t\t\tinvState: invpkg.ContractSettled,\n\t\t\tsetID:    &setID,\n\t\t\toutput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   testAlreadyNow,\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateSettled,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP: &invpkg.InvoiceHtlcAMPData{\n\t\t\t\t\tRecord:   *ampRecord,\n\t\t\t\t\tHash:     hash,\n\t\t\t\t\tPreimage: &preimage,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpErr: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"cancel invoice\",\n\t\t\tinput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   time.Time{},\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateAccepted,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP: &invpkg.InvoiceHtlcAMPData{\n\t\t\t\t\tRecord:   *ampRecord,\n\t\t\t\t\tHash:     hash,\n\t\t\t\t\tPreimage: &preimage,\n\t\t\t\t},\n\t\t\t},\n\t\t\tinvState: invpkg.ContractCanceled,\n\t\t\tsetID:    &setID,\n\t\t\toutput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   testNow,\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateCanceled,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP: &invpkg.InvoiceHtlcAMPData{\n\t\t\t\t\tRecord:   *ampRecord,\n\t\t\t\t\tHash:     hash,\n\t\t\t\t\tPreimage: &preimage,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpErr: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"accept invoice htlc already canceled\",\n\t\t\tinput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   testAlreadyNow,\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateCanceled,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP: &invpkg.InvoiceHtlcAMPData{\n\t\t\t\t\tRecord:   *ampRecord,\n\t\t\t\t\tHash:     hash,\n\t\t\t\t\tPreimage: &preimage,\n\t\t\t\t},\n\t\t\t},\n\t\t\tinvState: invpkg.ContractAccepted,\n\t\t\tsetID:    &setID,\n\t\t\toutput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   testAlreadyNow,\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateCanceled,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP: &invpkg.InvoiceHtlcAMPData{\n\t\t\t\t\tRecord:   *ampRecord,\n\t\t\t\t\tHash:     hash,\n\t\t\t\t\tPreimage: &preimage,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpErr: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"cancel invoice htlc already canceled\",\n\t\t\tinput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   testAlreadyNow,\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateCanceled,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP: &invpkg.InvoiceHtlcAMPData{\n\t\t\t\t\tRecord:   *ampRecord,\n\t\t\t\t\tHash:     hash,\n\t\t\t\t\tPreimage: &preimage,\n\t\t\t\t},\n\t\t\t},\n\t\t\tinvState: invpkg.ContractCanceled,\n\t\t\tsetID:    &setID,\n\t\t\toutput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   testAlreadyNow,\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateCanceled,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP: &invpkg.InvoiceHtlcAMPData{\n\t\t\t\t\tRecord:   *ampRecord,\n\t\t\t\t\tHash:     hash,\n\t\t\t\t\tPreimage: &preimage,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpErr: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"settle invoice htlc already canceled\",\n\t\t\tinput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   testAlreadyNow,\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateCanceled,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP: &invpkg.InvoiceHtlcAMPData{\n\t\t\t\t\tRecord:   *ampRecord,\n\t\t\t\t\tHash:     hash,\n\t\t\t\t\tPreimage: &preimage,\n\t\t\t\t},\n\t\t\t},\n\t\t\tinvState: invpkg.ContractSettled,\n\t\t\tsetID:    &setID,\n\t\t\toutput: invpkg.InvoiceHTLC{\n\t\t\t\tAmt:           5000,\n\t\t\t\tMppTotalAmt:   5000,\n\t\t\t\tAcceptHeight:  100,\n\t\t\t\tAcceptTime:    testNow,\n\t\t\t\tResolveTime:   testAlreadyNow,\n\t\t\t\tExpiry:        40,\n\t\t\t\tState:         invpkg.HtlcStateCanceled,\n\t\t\t\tCustomRecords: make(record.CustomSet),\n\t\t\t\tAMP: &invpkg.InvoiceHtlcAMPData{\n\t\t\t\t\tRecord:   *ampRecord,\n\t\t\t\t\tHash:     hash,\n\t\t\t\t\tPreimage: &preimage,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpErr: nil,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\ttestUpdateHTLC(t, test)\n\t\t})\n\t}\n}\n",
      "length": 16187,
      "tokens": 1290,
      "embedding": []
    },
    {
      "slug": "func testUpdateHTLC(t *testing.T, test updateHTLCTest) {",
      "content": "func testUpdateHTLC(t *testing.T, test updateHTLCTest) {\n\thtlc := test.input.Copy()\n\t_, err := updateHtlc(testNow, htlc, test.invState, test.setID)\n\trequire.Equal(t, test.expErr, err)\n\trequire.Equal(t, test.output, *htlc)\n}\n\n// TestDeleteInvoices tests that deleting a list of invoices will succeed\n// if all delete references are valid, or will fail otherwise.",
      "length": 297,
      "tokens": 39,
      "embedding": []
    },
    {
      "slug": "func TestDeleteInvoices(t *testing.T) {",
      "content": "func TestDeleteInvoices(t *testing.T) {\n\tt.Parallel()\n\n\tdb, err := MakeTestDB(t)\n\trequire.NoError(t, err, \"unable to make test db\")\n\n\t// Add some invoices to the test db.\n\tnumInvoices := 3\n\tinvoicesToDelete := make([]invpkg.InvoiceDeleteRef, numInvoices)\n\n\tfor i := 0; i < numInvoices; i++ {\n\t\tinvoice, err := randInvoice(lnwire.MilliSatoshi(i + 1))\n\t\trequire.NoError(t, err)\n\n\t\tpaymentHash := invoice.Terms.PaymentPreimage.Hash()\n\t\taddIndex, err := db.AddInvoice(invoice, paymentHash)\n\t\trequire.NoError(t, err)\n\n\t\t// Settle the second invoice.\n\t\tif i == 1 {\n\t\t\tinvoice, err = db.UpdateInvoice(\n\t\t\t\tinvpkg.InvoiceRefByHash(paymentHash), nil,\n\t\t\t\tgetUpdateInvoice(invoice.Terms.Value),\n\t\t\t)\n\t\t\trequire.NoError(t, err, \"unable to settle invoice\")\n\t\t}\n\n\t\t// store the delete ref for later.\n\t\tinvoicesToDelete[i] = invpkg.InvoiceDeleteRef{\n\t\t\tPayHash:     paymentHash,\n\t\t\tPayAddr:     &invoice.Terms.PaymentAddr,\n\t\t\tAddIndex:    addIndex,\n\t\t\tSettleIndex: invoice.SettleIndex,\n\t\t}\n\t}\n\n\t// assertInvoiceCount asserts that the number of invoices equals\n\t// to the passed count.\n\tassertInvoiceCount := func(count int) {\n\t\t// Query to collect all invoices.\n\t\tquery := invpkg.InvoiceQuery{\n\t\t\tIndexOffset:    0,\n\t\t\tNumMaxInvoices: math.MaxUint64,\n\t\t}\n\n\t\t// Check that we really have 3 invoices.\n\t\tresponse, err := db.QueryInvoices(query)\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, count, len(response.Invoices))\n\t}\n\n\t// XOR one byte of one of the references' hash and attempt to delete.\n\tinvoicesToDelete[0].PayHash[2] ^= 3\n\trequire.Error(t, db.DeleteInvoice(invoicesToDelete))\n\tassertInvoiceCount(3)\n\n\t// Restore the hash.\n\tinvoicesToDelete[0].PayHash[2] ^= 3\n\n\t// XOR the second invoice's payment settle index as it is settled, and\n\t// attempt to delete.\n\tinvoicesToDelete[1].SettleIndex ^= 11\n\trequire.Error(t, db.DeleteInvoice(invoicesToDelete))\n\tassertInvoiceCount(3)\n\n\t// Restore the settle index.\n\tinvoicesToDelete[1].SettleIndex ^= 11\n\n\t// XOR the add index for one of the references and attempt to delete.\n\tinvoicesToDelete[2].AddIndex ^= 13\n\trequire.Error(t, db.DeleteInvoice(invoicesToDelete))\n\tassertInvoiceCount(3)\n\n\t// Restore the add index.\n\tinvoicesToDelete[2].AddIndex ^= 13\n\n\t// Delete should succeed with all the valid references.\n\trequire.NoError(t, db.DeleteInvoice(invoicesToDelete))\n\tassertInvoiceCount(0)\n}\n\n// TestAddInvoiceInvalidFeatureDeps asserts that inserting an invoice with\n// invalid transitive feature dependencies fails with the appropriate error.",
      "length": 2354,
      "tokens": 267,
      "embedding": []
    },
    {
      "slug": "func TestAddInvoiceInvalidFeatureDeps(t *testing.T) {",
      "content": "func TestAddInvoiceInvalidFeatureDeps(t *testing.T) {\n\tt.Parallel()\n\n\tdb, err := MakeTestDB(t)\n\trequire.NoError(t, err, \"unable to make test db\")\n\n\tinvoice, err := randInvoice(500)\n\trequire.NoError(t, err)\n\n\tinvoice.Terms.Features = lnwire.NewFeatureVector(\n\t\tlnwire.NewRawFeatureVector(\n\t\t\tlnwire.TLVOnionPayloadOptional,\n\t\t\tlnwire.MPPOptional,\n\t\t),\n\t\tlnwire.Features,\n\t)\n\n\thash := invoice.Terms.PaymentPreimage.Hash()\n\t_, err = db.AddInvoice(invoice, hash)\n\trequire.Error(t, err, feature.NewErrMissingFeatureDep(\n\t\tlnwire.PaymentAddrOptional,\n\t))\n}\n\n// TestEncodeDecodeAmpInvoiceState asserts that the nested TLV\n// encoding+decoding for the AMPInvoiceState struct works as expected.",
      "length": 607,
      "tokens": 57,
      "embedding": []
    },
    {
      "slug": "func TestEncodeDecodeAmpInvoiceState(t *testing.T) {",
      "content": "func TestEncodeDecodeAmpInvoiceState(t *testing.T) {\n\tt.Parallel()\n\n\tsetID1 := [32]byte{1}\n\tsetID2 := [32]byte{2}\n\tsetID3 := [32]byte{3}\n\n\tcircuitKey1 := models.CircuitKey{\n\t\tChanID: lnwire.NewShortChanIDFromInt(1), HtlcID: 1,\n\t}\n\tcircuitKey2 := models.CircuitKey{\n\t\tChanID: lnwire.NewShortChanIDFromInt(2), HtlcID: 2,\n\t}\n\tcircuitKey3 := models.CircuitKey{\n\t\tChanID: lnwire.NewShortChanIDFromInt(2), HtlcID: 3,\n\t}\n\n\t// Make a sample invoice state map that we'll encode then decode to\n\t// assert equality of.\n\tampState := invpkg.AMPInvoiceState{\n\t\tsetID1: invpkg.InvoiceStateAMP{\n\t\t\tState:       invpkg.HtlcStateSettled,\n\t\t\tSettleDate:  testNow,\n\t\t\tSettleIndex: 1,\n\t\t\tInvoiceKeys: map[models.CircuitKey]struct{}{\n\t\t\t\tcircuitKey1: {},\n\t\t\t\tcircuitKey2: {},\n\t\t\t},\n\t\t\tAmtPaid: 5,\n\t\t},\n\t\tsetID2: invpkg.InvoiceStateAMP{\n\t\t\tState:       invpkg.HtlcStateCanceled,\n\t\t\tSettleDate:  testNow,\n\t\t\tSettleIndex: 2,\n\t\t\tInvoiceKeys: map[models.CircuitKey]struct{}{\n\t\t\t\tcircuitKey1: {},\n\t\t\t},\n\t\t\tAmtPaid: 6,\n\t\t},\n\t\tsetID3: invpkg.InvoiceStateAMP{\n\t\t\tState:       invpkg.HtlcStateAccepted,\n\t\t\tSettleDate:  testNow,\n\t\t\tSettleIndex: 3,\n\t\t\tInvoiceKeys: map[models.CircuitKey]struct{}{\n\t\t\t\tcircuitKey1: {},\n\t\t\t\tcircuitKey2: {},\n\t\t\t\tcircuitKey3: {},\n\t\t\t},\n\t\t\tAmtPaid: 7,\n\t\t},\n\t}\n\n\t// We'll now make a sample invoice stream, and use that to encode the\n\t// amp state we created above.\n\ttlvStream, err := tlv.NewStream(\n\t\ttlv.MakeDynamicRecord(\n\t\t\tinvoiceAmpStateType, &ampState,\n\t\t\tampRecordSize(&ampState), ampStateEncoder,\n\t\t\tampStateDecoder,\n\t\t),\n\t)\n\trequire.Nil(t, err)\n\n\t// Next encode the stream into a set of raw bytes.\n\tvar b bytes.Buffer\n\terr = tlvStream.Encode(&b)\n\trequire.Nil(t, err)\n\n\t// Now create a new blank ampState map, which we'll use to decode the\n\t// bytes into.\n\tampState2 := make(invpkg.AMPInvoiceState)\n\n\t// Decode from the raw stream into this blank mpa.\n\ttlvStream, err = tlv.NewStream(\n\t\ttlv.MakeDynamicRecord(\n\t\t\tinvoiceAmpStateType, &ampState2, nil,\n\t\t\tampStateEncoder, ampStateDecoder,\n\t\t),\n\t)\n\trequire.Nil(t, err)\n\n\terr = tlvStream.Decode(&b)\n\trequire.Nil(t, err)\n\n\t// The two states should match.\n\trequire.Equal(t, ampState, ampState2)\n}\n",
      "length": 2005,
      "tokens": 221,
      "embedding": []
    }
  ]
}