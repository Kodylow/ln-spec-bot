{
  "filepath": "../implementations/go/lnd/channeldb/mp_payment.go",
  "package": "channeldb",
  "sections": [
    {
      "slug": "type HTLCAttemptInfo struct {",
      "content": "type HTLCAttemptInfo struct {\n\t// AttemptID is the unique ID used for this attempt.\n\tAttemptID uint64\n\n\t// sessionKey is the raw bytes ephemeral key used for this attempt.\n\t// These bytes are lazily read off disk to save ourselves the expensive\n\t// EC operations used by btcec.PrivKeyFromBytes.\n\tsessionKey [btcec.PrivKeyBytesLen]byte\n\n\t// cachedSessionKey is our fully deserialized sesionKey. This value\n\t// may be nil if the attempt has just been read from disk and its\n\t// session key has not been used yet.\n\tcachedSessionKey *btcec.PrivateKey\n\n\t// Route is the route attempted to send the HTLC.\n\tRoute route.Route\n\n\t// AttemptTime is the time at which this HTLC was attempted.\n\tAttemptTime time.Time\n\n\t// Hash is the hash used for this single HTLC attempt. For AMP payments\n\t// this will differ across attempts, for non-AMP payments each attempt\n\t// will use the same hash. This can be nil for older payment attempts,\n\t// in which the payment's PaymentHash in the PaymentCreationInfo should\n\t// be used.\n\tHash *lntypes.Hash\n}\n\n// NewHtlcAttemptInfo creates a htlc attempt.",
      "length": 1019,
      "tokens": 165,
      "embedding": []
    },
    {
      "slug": "func NewHtlcAttemptInfo(attemptID uint64, sessionKey *btcec.PrivateKey,",
      "content": "func NewHtlcAttemptInfo(attemptID uint64, sessionKey *btcec.PrivateKey,\n\troute route.Route, attemptTime time.Time,\n\thash *lntypes.Hash) *HTLCAttemptInfo {\n\n\tvar scratch [btcec.PrivKeyBytesLen]byte\n\tcopy(scratch[:], sessionKey.Serialize())\n\n\treturn &HTLCAttemptInfo{\n\t\tAttemptID:        attemptID,\n\t\tsessionKey:       scratch,\n\t\tcachedSessionKey: sessionKey,\n\t\tRoute:            route,\n\t\tAttemptTime:      attemptTime,\n\t\tHash:             hash,\n\t}\n}\n\n// SessionKey returns the ephemeral key used for a htlc attempt. This function\n// performs expensive ec-ops to obtain the session key if it is not cached.",
      "length": 515,
      "tokens": 56,
      "embedding": []
    },
    {
      "slug": "func (h *HTLCAttemptInfo) SessionKey() *btcec.PrivateKey {",
      "content": "func (h *HTLCAttemptInfo) SessionKey() *btcec.PrivateKey {\n\tif h.cachedSessionKey == nil {\n\t\th.cachedSessionKey, _ = btcec.PrivKeyFromBytes(\n\t\t\th.sessionKey[:],\n\t\t)\n\t}\n\n\treturn h.cachedSessionKey\n}\n\n// HTLCAttempt contains information about a specific HTLC attempt for a given\n// payment. It contains the HTLCAttemptInfo used to send the HTLC, as well\n// as a timestamp and any known outcome of the attempt.",
      "length": 337,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "type HTLCAttempt struct {",
      "content": "type HTLCAttempt struct {\n\tHTLCAttemptInfo\n\n\t// Settle is the preimage of a successful payment. This serves as a\n\t// proof of payment. It will only be non-nil for settled payments.\n\t//\n\t// NOTE: Can be nil if payment is not settled.\n\tSettle *HTLCSettleInfo\n\n\t// Fail is a failure reason code indicating the reason the payment\n\t// failed. It is only non-nil for failed payments.\n\t//\n\t// NOTE: Can be nil if payment is not failed.\n\tFailure *HTLCFailInfo\n}\n\n// HTLCSettleInfo encapsulates the information that augments an HTLCAttempt in\n// the event that the HTLC is successful.",
      "length": 533,
      "tokens": 92,
      "embedding": []
    },
    {
      "slug": "type HTLCSettleInfo struct {",
      "content": "type HTLCSettleInfo struct {\n\t// Preimage is the preimage of a successful HTLC. This serves as a proof\n\t// of payment.\n\tPreimage lntypes.Preimage\n\n\t// SettleTime is the time at which this HTLC was settled.\n\tSettleTime time.Time\n}\n\n// HTLCFailReason is the reason an htlc failed.",
      "length": 241,
      "tokens": 41,
      "embedding": []
    },
    {
      "slug": "type HTLCFailReason byte",
      "content": "type HTLCFailReason byte\n\nconst (\n\t// HTLCFailUnknown is recorded for htlcs that failed with an unknown\n\t// reason.\n\tHTLCFailUnknown HTLCFailReason = 0\n\n\t// HTLCFailUnknown is recorded for htlcs that had a failure message that\n\t// couldn't be decrypted.\n\tHTLCFailUnreadable HTLCFailReason = 1\n\n\t// HTLCFailInternal is recorded for htlcs that failed because of an\n\t// internal error.\n\tHTLCFailInternal HTLCFailReason = 2\n\n\t// HTLCFailMessage is recorded for htlcs that failed with a network\n\t// failure message.\n\tHTLCFailMessage HTLCFailReason = 3\n)\n\n// HTLCFailInfo encapsulates the information that augments an HTLCAttempt in the\n// event that the HTLC fails.",
      "length": 615,
      "tokens": 93,
      "embedding": []
    },
    {
      "slug": "type HTLCFailInfo struct {",
      "content": "type HTLCFailInfo struct {\n\t// FailTime is the time at which this HTLC was failed.\n\tFailTime time.Time\n\n\t// Message is the wire message that failed this HTLC. This field will be\n\t// populated when the failure reason is HTLCFailMessage.\n\tMessage lnwire.FailureMessage\n\n\t// Reason is the failure reason for this HTLC.\n\tReason HTLCFailReason\n\n\t// The position in the path of the intermediate or final node that\n\t// generated the failure message. Position zero is the sender node. This\n\t// field will be populated when the failure reason is either\n\t// HTLCFailMessage or HTLCFailUnknown.\n\tFailureSourceIndex uint32\n}\n\n// MPPayment is a wrapper around a payment's PaymentCreationInfo and\n// HTLCAttempts. All payments will have the PaymentCreationInfo set, any\n// HTLCs made in attempts to be completed will populated in the HTLCs slice.\n// Each populated HTLCAttempt represents an attempted HTLC, each of which may\n// have the associated Settle or Fail struct populated if the HTLC is no longer\n// in-flight.",
      "length": 955,
      "tokens": 154,
      "embedding": []
    },
    {
      "slug": "type MPPayment struct {",
      "content": "type MPPayment struct {\n\t// SequenceNum is a unique identifier used to sort the payments in\n\t// order of creation.\n\tSequenceNum uint64\n\n\t// Info holds all static information about this payment, and is\n\t// populated when the payment is initiated.\n\tInfo *PaymentCreationInfo\n\n\t// HTLCs holds the information about individual HTLCs that we send in\n\t// order to make the payment.\n\tHTLCs []HTLCAttempt\n\n\t// FailureReason is the failure reason code indicating the reason the\n\t// payment failed.\n\t//\n\t// NOTE: Will only be set once the daemon has given up on the payment\n\t// altogether.\n\tFailureReason *FailureReason\n\n\t// Status is the current PaymentStatus of this payment.\n\tStatus PaymentStatus\n}\n\n// TerminalInfo returns any HTLC settle info recorded. If no settle info is\n// recorded, any payment level failure will be returned. If neither a settle\n// nor a failure is recorded, both return values will be nil.",
      "length": 858,
      "tokens": 142,
      "embedding": []
    },
    {
      "slug": "func (m *MPPayment) TerminalInfo() (*HTLCSettleInfo, *FailureReason) {",
      "content": "func (m *MPPayment) TerminalInfo() (*HTLCSettleInfo, *FailureReason) {\n\tfor _, h := range m.HTLCs {\n\t\tif h.Settle != nil {\n\t\t\treturn h.Settle, nil\n\t\t}\n\t}\n\n\treturn nil, m.FailureReason\n}\n\n// SentAmt returns the sum of sent amount and fees for HTLCs that are either\n// settled or still in flight.",
      "length": 213,
      "tokens": 42,
      "embedding": []
    },
    {
      "slug": "func (m *MPPayment) SentAmt() (lnwire.MilliSatoshi, lnwire.MilliSatoshi) {",
      "content": "func (m *MPPayment) SentAmt() (lnwire.MilliSatoshi, lnwire.MilliSatoshi) {\n\tvar sent, fees lnwire.MilliSatoshi\n\tfor _, h := range m.HTLCs {\n\t\tif h.Failure != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\t// The attempt was not failed, meaning the amount was\n\t\t// potentially sent to the receiver.\n\t\tsent += h.Route.ReceiverAmt()\n\t\tfees += h.Route.TotalFees()\n\t}\n\n\treturn sent, fees\n}\n\n// InFlightHTLCs returns the HTLCs that are still in-flight, meaning they have\n// not been settled or failed.",
      "length": 382,
      "tokens": 63,
      "embedding": []
    },
    {
      "slug": "func (m *MPPayment) InFlightHTLCs() []HTLCAttempt {",
      "content": "func (m *MPPayment) InFlightHTLCs() []HTLCAttempt {\n\tvar inflights []HTLCAttempt\n\tfor _, h := range m.HTLCs {\n\t\tif h.Settle != nil || h.Failure != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tinflights = append(inflights, h)\n\t}\n\n\treturn inflights\n}\n\n// GetAttempt returns the specified htlc attempt on the payment.",
      "length": 230,
      "tokens": 39,
      "embedding": []
    },
    {
      "slug": "func (m *MPPayment) GetAttempt(id uint64) (*HTLCAttempt, error) {",
      "content": "func (m *MPPayment) GetAttempt(id uint64) (*HTLCAttempt, error) {\n\tfor _, htlc := range m.HTLCs {\n\t\thtlc := htlc\n\t\tif htlc.AttemptID == id {\n\t\t\treturn &htlc, nil\n\t\t}\n\t}\n\n\treturn nil, errors.New(\"htlc attempt not found on payment\")\n}\n\n// serializeHTLCSettleInfo serializes the details of a settled htlc.",
      "length": 226,
      "tokens": 38,
      "embedding": []
    },
    {
      "slug": "func serializeHTLCSettleInfo(w io.Writer, s *HTLCSettleInfo) error {",
      "content": "func serializeHTLCSettleInfo(w io.Writer, s *HTLCSettleInfo) error {\n\tif _, err := w.Write(s.Preimage[:]); err != nil {\n\t\treturn err\n\t}\n\n\tif err := serializeTime(w, s.SettleTime); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// deserializeHTLCSettleInfo deserializes the details of a settled htlc.",
      "length": 217,
      "tokens": 36,
      "embedding": []
    },
    {
      "slug": "func deserializeHTLCSettleInfo(r io.Reader) (*HTLCSettleInfo, error) {",
      "content": "func deserializeHTLCSettleInfo(r io.Reader) (*HTLCSettleInfo, error) {\n\ts := &HTLCSettleInfo{}\n\tif _, err := io.ReadFull(r, s.Preimage[:]); err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar err error\n\ts.SettleTime, err = deserializeTime(r)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s, nil\n}\n\n// serializeHTLCFailInfo serializes the details of a failed htlc including the\n// wire failure.",
      "length": 296,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func serializeHTLCFailInfo(w io.Writer, f *HTLCFailInfo) error {",
      "content": "func serializeHTLCFailInfo(w io.Writer, f *HTLCFailInfo) error {\n\tif err := serializeTime(w, f.FailTime); err != nil {\n\t\treturn err\n\t}\n\n\t// Write failure. If there is no failure message, write an empty\n\t// byte slice.\n\tvar messageBytes bytes.Buffer\n\tif f.Message != nil {\n\t\terr := lnwire.EncodeFailureMessage(&messageBytes, f.Message, 0)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := wire.WriteVarBytes(w, 0, messageBytes.Bytes()); err != nil {\n\t\treturn err\n\t}\n\n\treturn WriteElements(w, byte(f.Reason), f.FailureSourceIndex)\n}\n\n// deserializeHTLCFailInfo deserializes the details of a failed htlc including\n// the wire failure.",
      "length": 545,
      "tokens": 81,
      "embedding": []
    },
    {
      "slug": "func deserializeHTLCFailInfo(r io.Reader) (*HTLCFailInfo, error) {",
      "content": "func deserializeHTLCFailInfo(r io.Reader) (*HTLCFailInfo, error) {\n\tf := &HTLCFailInfo{}\n\tvar err error\n\tf.FailTime, err = deserializeTime(r)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Read failure.\n\tfailureBytes, err := wire.ReadVarBytes(\n\t\tr, 0, math.MaxUint16, \"failure\",\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(failureBytes) > 0 {\n\t\tf.Message, err = lnwire.DecodeFailureMessage(\n\t\t\tbytes.NewReader(failureBytes), 0,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tvar reason byte\n\terr = ReadElements(r, &reason, &f.FailureSourceIndex)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tf.Reason = HTLCFailReason(reason)\n\n\treturn f, nil\n}\n\n// deserializeTime deserializes time as unix nanoseconds.",
      "length": 599,
      "tokens": 93,
      "embedding": []
    },
    {
      "slug": "func deserializeTime(r io.Reader) (time.Time, error) {",
      "content": "func deserializeTime(r io.Reader) (time.Time, error) {\n\tvar scratch [8]byte\n\tif _, err := io.ReadFull(r, scratch[:]); err != nil {\n\t\treturn time.Time{}, err\n\t}\n\n\t// Convert to time.Time. Interpret unix nano time zero as a zero\n\t// time.Time value.\n\tunixNano := byteOrder.Uint64(scratch[:])\n\tif unixNano == 0 {\n\t\treturn time.Time{}, nil\n\t}\n\n\treturn time.Unix(0, int64(unixNano)), nil\n}\n\n// serializeTime serializes time as unix nanoseconds.",
      "length": 369,
      "tokens": 56,
      "embedding": []
    },
    {
      "slug": "func serializeTime(w io.Writer, t time.Time) error {",
      "content": "func serializeTime(w io.Writer, t time.Time) error {\n\tvar scratch [8]byte\n\n\t// Convert to unix nano seconds, but only if time is non-zero. Calling\n\t// UnixNano() on a zero time yields an undefined result.\n\tvar unixNano int64\n\tif !t.IsZero() {\n\t\tunixNano = t.UnixNano()\n\t}\n\n\tbyteOrder.PutUint64(scratch[:], uint64(unixNano))\n\t_, err := w.Write(scratch[:])\n\treturn err\n}\n",
      "length": 303,
      "tokens": 45,
      "embedding": []
    }
  ]
}