{
  "filepath": "../implementations/go/lnd/channeldb/invoices.go",
  "package": "channeldb",
  "sections": [
    {
      "slug": "func (d *DB) AddInvoice(newInvoice *invpkg.Invoice, paymentHash lntypes.Hash) (",
      "content": "func (d *DB) AddInvoice(newInvoice *invpkg.Invoice, paymentHash lntypes.Hash) (\n\tuint64, error) {\n\n\tif err := invpkg.ValidateInvoice(newInvoice, paymentHash); err != nil {\n\t\treturn 0, err\n\t}\n\n\tvar invoiceAddIndex uint64\n\terr := kvdb.Update(d, func(tx kvdb.RwTx) error {\n\t\tinvoices, err := tx.CreateTopLevelBucket(invoiceBucket)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tinvoiceIndex, err := invoices.CreateBucketIfNotExists(\n\t\t\tinvoiceIndexBucket,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\taddIndex, err := invoices.CreateBucketIfNotExists(\n\t\t\taddIndexBucket,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Ensure that an invoice an identical payment hash doesn't\n\t\t// already exist within the index.\n\t\tif invoiceIndex.Get(paymentHash[:]) != nil {\n\t\t\treturn invpkg.ErrDuplicateInvoice\n\t\t}\n\n\t\t// Check that we aren't inserting an invoice with a duplicate\n\t\t// payment address. The all-zeros payment address is\n\t\t// special-cased to support legacy keysend invoices which don't\n\t\t// assign one. This is safe since later we also will avoid\n\t\t// indexing them and avoid collisions.\n\t\tpayAddrIndex := tx.ReadWriteBucket(payAddrIndexBucket)\n\t\tif newInvoice.Terms.PaymentAddr != invpkg.BlankPayAddr {\n\t\t\tpaymentAddr := newInvoice.Terms.PaymentAddr[:]\n\t\t\tif payAddrIndex.Get(paymentAddr) != nil {\n\t\t\t\treturn invpkg.ErrDuplicatePayAddr\n\t\t\t}\n\t\t}\n\n\t\t// If the current running payment ID counter hasn't yet been\n\t\t// created, then create it now.\n\t\tvar invoiceNum uint32\n\t\tinvoiceCounter := invoiceIndex.Get(numInvoicesKey)\n\t\tif invoiceCounter == nil {\n\t\t\tvar scratch [4]byte\n\t\t\tbyteOrder.PutUint32(scratch[:], invoiceNum)\n\t\t\terr := invoiceIndex.Put(numInvoicesKey, scratch[:])\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\tinvoiceNum = byteOrder.Uint32(invoiceCounter)\n\t\t}\n\n\t\tnewIndex, err := putInvoice(\n\t\t\tinvoices, invoiceIndex, payAddrIndex, addIndex,\n\t\t\tnewInvoice, invoiceNum, paymentHash,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tinvoiceAddIndex = newIndex\n\t\treturn nil\n\t}, func() {\n\t\tinvoiceAddIndex = 0\n\t})\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn invoiceAddIndex, err\n}\n\n// InvoicesAddedSince can be used by callers to seek into the event time series\n// of all the invoices added in the database. The specified sinceAddIndex\n// should be the highest add index that the caller knows of. This method will\n// return all invoices with an add index greater than the specified\n// sinceAddIndex.\n//\n// NOTE: The index starts from 1, as a result. We enforce that specifying a\n// value below the starting index value is a noop.",
      "length": 2357,
      "tokens": 334,
      "embedding": []
    },
    {
      "slug": "func (d *DB) InvoicesAddedSince(sinceAddIndex uint64) ([]invpkg.Invoice,",
      "content": "func (d *DB) InvoicesAddedSince(sinceAddIndex uint64) ([]invpkg.Invoice,\n\terror) {\n\n\tvar newInvoices []invpkg.Invoice\n\n\t// If an index of zero was specified, then in order to maintain\n\t// backwards compat, we won't send out any new invoices.\n\tif sinceAddIndex == 0 {\n\t\treturn newInvoices, nil\n\t}\n\n\tvar startIndex [8]byte\n\tbyteOrder.PutUint64(startIndex[:], sinceAddIndex)\n\n\terr := kvdb.View(d, func(tx kvdb.RTx) error {\n\t\tinvoices := tx.ReadBucket(invoiceBucket)\n\t\tif invoices == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\taddIndex := invoices.NestedReadBucket(addIndexBucket)\n\t\tif addIndex == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\t// We'll now run through each entry in the add index starting\n\t\t// at our starting index. We'll continue until we reach the\n\t\t// very end of the current key space.\n\t\tinvoiceCursor := addIndex.ReadCursor()\n\n\t\t// We'll seek to the starting index, then manually advance the\n\t\t// cursor in order to skip the entry with the since add index.\n\t\tinvoiceCursor.Seek(startIndex[:])\n\t\taddSeqNo, invoiceKey := invoiceCursor.Next()\n\n\t\tfor ; addSeqNo != nil && bytes.Compare(addSeqNo, startIndex[:]) > 0; addSeqNo, invoiceKey = invoiceCursor.Next() {\n\n\t\t\t// For each key found, we'll look up the actual\n\t\t\t// invoice, then accumulate it into our return value.\n\t\t\tinvoice, err := fetchInvoice(invoiceKey, invoices)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tnewInvoices = append(newInvoices, invoice)\n\t\t}\n\n\t\treturn nil\n\t}, func() {\n\t\tnewInvoices = nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn newInvoices, nil\n}\n\n// LookupInvoice attempts to look up an invoice according to its 32 byte\n// payment hash. If an invoice which can settle the HTLC identified by the\n// passed payment hash isn't found, then an error is returned. Otherwise, the\n// full invoice is returned. Before setting the incoming HTLC, the values\n// SHOULD be checked to ensure the payer meets the agreed upon contractual\n// terms of the payment.",
      "length": 1777,
      "tokens": 278,
      "embedding": []
    },
    {
      "slug": "func (d *DB) LookupInvoice(ref invpkg.InvoiceRef) (invpkg.Invoice, error) {",
      "content": "func (d *DB) LookupInvoice(ref invpkg.InvoiceRef) (invpkg.Invoice, error) {\n\tvar invoice invpkg.Invoice\n\terr := kvdb.View(d, func(tx kvdb.RTx) error {\n\t\tinvoices := tx.ReadBucket(invoiceBucket)\n\t\tif invoices == nil {\n\t\t\treturn invpkg.ErrNoInvoicesCreated\n\t\t}\n\t\tinvoiceIndex := invoices.NestedReadBucket(invoiceIndexBucket)\n\t\tif invoiceIndex == nil {\n\t\t\treturn invpkg.ErrNoInvoicesCreated\n\t\t}\n\t\tpayAddrIndex := tx.ReadBucket(payAddrIndexBucket)\n\t\tsetIDIndex := tx.ReadBucket(setIDIndexBucket)\n\n\t\t// Retrieve the invoice number for this invoice using\n\t\t// the provided invoice reference.\n\t\tinvoiceNum, err := fetchInvoiceNumByRef(\n\t\t\tinvoiceIndex, payAddrIndex, setIDIndex, ref,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvar setID *invpkg.SetID\n\t\tswitch {\n\t\t// If this is a payment address ref, and the blank modified was\n\t\t// specified, then we'll use the zero set ID to indicate that\n\t\t// we won't want any HTLCs returned.\n\t\tcase ref.PayAddr() != nil &&\n\t\t\tref.Modifier() == invpkg.HtlcSetBlankModifier:\n\n\t\t\tvar zeroSetID invpkg.SetID\n\t\t\tsetID = &zeroSetID\n\n\t\t// If this is a set ID ref, and the htlc set only modified was\n\t\t// specified, then we'll pass through the specified setID so\n\t\t// only that will be returned.\n\t\tcase ref.SetID() != nil &&\n\t\t\tref.Modifier() == invpkg.HtlcSetOnlyModifier:\n\n\t\t\tsetID = (*invpkg.SetID)(ref.SetID())\n\t\t}\n\n\t\t// An invoice was found, retrieve the remainder of the invoice\n\t\t// body.\n\t\ti, err := fetchInvoice(invoiceNum, invoices, setID)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tinvoice = i\n\n\t\treturn nil\n\t}, func() {})\n\tif err != nil {\n\t\treturn invoice, err\n\t}\n\n\treturn invoice, nil\n}\n\n// fetchInvoiceNumByRef retrieve the invoice number for the provided invoice\n// reference. The payment address will be treated as the primary key, falling\n// back to the payment hash if nothing is found for the payment address. An\n// error is returned if the invoice is not found.",
      "length": 1762,
      "tokens": 259,
      "embedding": []
    },
    {
      "slug": "func fetchInvoiceNumByRef(invoiceIndex, payAddrIndex, setIDIndex kvdb.RBucket,",
      "content": "func fetchInvoiceNumByRef(invoiceIndex, payAddrIndex, setIDIndex kvdb.RBucket,\n\tref invpkg.InvoiceRef) ([]byte, error) {\n\n\t// If the set id is present, we only consult the set id index for this\n\t// invoice. This type of query is only used to facilitate user-facing\n\t// requests to lookup, settle or cancel an AMP invoice.\n\tsetID := ref.SetID()\n\tif setID != nil {\n\t\tinvoiceNumBySetID := setIDIndex.Get(setID[:])\n\t\tif invoiceNumBySetID == nil {\n\t\t\treturn nil, invpkg.ErrInvoiceNotFound\n\t\t}\n\n\t\treturn invoiceNumBySetID, nil\n\t}\n\n\tpayHash := ref.PayHash()\n\tpayAddr := ref.PayAddr()\n\n\tgetInvoiceNumByHash := func() []byte {\n\t\tif payHash != nil {\n\t\t\treturn invoiceIndex.Get(payHash[:])\n\t\t}\n\t\treturn nil\n\t}\n\n\tgetInvoiceNumByAddr := func() []byte {\n\t\tif payAddr != nil {\n\t\t\t// Only allow lookups for payment address if it is not a\n\t\t\t// blank payment address, which is a special-cased value\n\t\t\t// for legacy keysend invoices.\n\t\t\tif *payAddr != invpkg.BlankPayAddr {\n\t\t\t\treturn payAddrIndex.Get(payAddr[:])\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\n\tinvoiceNumByHash := getInvoiceNumByHash()\n\tinvoiceNumByAddr := getInvoiceNumByAddr()\n\tswitch {\n\t// If payment address and payment hash both reference an existing\n\t// invoice, ensure they reference the _same_ invoice.\n\tcase invoiceNumByAddr != nil && invoiceNumByHash != nil:\n\t\tif !bytes.Equal(invoiceNumByAddr, invoiceNumByHash) {\n\t\t\treturn nil, invpkg.ErrInvRefEquivocation\n\t\t}\n\n\t\treturn invoiceNumByAddr, nil\n\n\t// Return invoices by payment addr only.\n\t//\n\t// NOTE: We constrain this lookup to only apply if the invoice ref does\n\t// not contain a payment hash. Legacy and MPP payments depend on the\n\t// payment hash index to enforce that the HTLCs payment hash matches the\n\t// payment hash for the invoice, without this check we would\n\t// inadvertently assume the invoice contains the correct preimage for\n\t// the HTLC, which we only enforce via the lookup by the invoice index.\n\tcase invoiceNumByAddr != nil && payHash == nil:\n\t\treturn invoiceNumByAddr, nil\n\n\t// If we were only able to reference the invoice by hash, return the\n\t// corresponding invoice number. This can happen when no payment address\n\t// was provided, or if it didn't match anything in our records.\n\tcase invoiceNumByHash != nil:\n\t\treturn invoiceNumByHash, nil\n\n\t// Otherwise we don't know of the target invoice.\n\tdefault:\n\t\treturn nil, invpkg.ErrInvoiceNotFound\n\t}\n}\n\n// ScanInvoices scans through all invoices and calls the passed scanFunc for\n// for each invoice with its respective payment hash. Additionally a reset()\n// closure is passed which is used to reset/initialize partial results and also\n// to signal if the kvdb.View transaction has been retried.",
      "length": 2504,
      "tokens": 383,
      "embedding": []
    },
    {
      "slug": "func (d *DB) ScanInvoices(scanFunc invpkg.InvScanFunc, reset func()) error {",
      "content": "func (d *DB) ScanInvoices(scanFunc invpkg.InvScanFunc, reset func()) error {\n\treturn kvdb.View(d, func(tx kvdb.RTx) error {\n\t\tinvoices := tx.ReadBucket(invoiceBucket)\n\t\tif invoices == nil {\n\t\t\treturn invpkg.ErrNoInvoicesCreated\n\t\t}\n\n\t\tinvoiceIndex := invoices.NestedReadBucket(invoiceIndexBucket)\n\t\tif invoiceIndex == nil {\n\t\t\t// Mask the error if there's no invoice\n\t\t\t// index as that simply means there are no\n\t\t\t// invoices added yet to the DB. In this case\n\t\t\t// we simply return an empty list.\n\t\t\treturn nil\n\t\t}\n\n\t\treturn invoiceIndex.ForEach(func(k, v []byte) error {\n\t\t\t// Skip the special numInvoicesKey as that does not\n\t\t\t// point to a valid invoice.\n\t\t\tif bytes.Equal(k, numInvoicesKey) {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Skip sub-buckets.\n\t\t\tif v == nil {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tinvoice, err := fetchInvoice(v, invoices)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tvar paymentHash lntypes.Hash\n\t\t\tcopy(paymentHash[:], k)\n\n\t\t\treturn scanFunc(paymentHash, &invoice)\n\t\t})\n\t}, reset)\n}\n\n// QueryInvoices allows a caller to query the invoice database for invoices\n// within the specified add index range.",
      "length": 988,
      "tokens": 145,
      "embedding": []
    },
    {
      "slug": "func (d *DB) QueryInvoices(q invpkg.InvoiceQuery) (invpkg.InvoiceSlice,",
      "content": "func (d *DB) QueryInvoices(q invpkg.InvoiceQuery) (invpkg.InvoiceSlice,\n\terror) {\n\n\tvar (\n\t\tresp         invpkg.InvoiceSlice\n\t\tstartDateSet = !q.CreationDateStart.IsZero()\n\t\tendDateSet   = !q.CreationDateEnd.IsZero()\n\t)\n\n\terr := kvdb.View(d, func(tx kvdb.RTx) error {\n\t\t// If the bucket wasn't found, then there aren't any invoices\n\t\t// within the database yet, so we can simply exit.\n\t\tinvoices := tx.ReadBucket(invoiceBucket)\n\t\tif invoices == nil {\n\t\t\treturn invpkg.ErrNoInvoicesCreated\n\t\t}\n\n\t\t// Get the add index bucket which we will use to iterate through\n\t\t// our indexed invoices.\n\t\tinvoiceAddIndex := invoices.NestedReadBucket(addIndexBucket)\n\t\tif invoiceAddIndex == nil {\n\t\t\treturn invpkg.ErrNoInvoicesCreated\n\t\t}\n\n\t\t// Create a paginator which reads from our add index bucket with\n\t\t// the parameters provided by the invoice query.\n\t\tpaginator := newPaginator(\n\t\t\tinvoiceAddIndex.ReadCursor(), q.Reversed, q.IndexOffset,\n\t\t\tq.NumMaxInvoices,\n\t\t)\n\n\t\t// accumulateInvoices looks up an invoice based on the index we\n\t\t// are given, adds it to our set of invoices if it has the right\n\t\t// characteristics for our query and returns the number of items\n\t\t// we have added to our set of invoices.\n\t\taccumulateInvoices := func(_, indexValue []byte) (bool, error) {\n\t\t\tinvoice, err := fetchInvoice(indexValue, invoices)\n\t\t\tif err != nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\n\t\t\t// Skip any settled or canceled invoices if the caller\n\t\t\t// is only interested in pending ones.\n\t\t\tif q.PendingOnly && !invoice.IsPending() {\n\t\t\t\treturn false, nil\n\t\t\t}\n\n\t\t\t// Skip any invoices that were created before the\n\t\t\t// specified time.\n\t\t\tif startDateSet && invoice.CreationDate.Before(\n\t\t\t\tq.CreationDateStart,\n\t\t\t) {\n\n\t\t\t\treturn false, nil\n\t\t\t}\n\n\t\t\t// Skip any invoices that were created after the\n\t\t\t// specified time.\n\t\t\tif endDateSet && invoice.CreationDate.After(\n\t\t\t\tq.CreationDateEnd,\n\t\t\t) {\n\n\t\t\t\treturn false, nil\n\t\t\t}\n\n\t\t\t// At this point, we've exhausted the offset, so we'll\n\t\t\t// begin collecting invoices found within the range.\n\t\t\tresp.Invoices = append(resp.Invoices, invoice)\n\t\t\treturn true, nil\n\t\t}\n\n\t\t// Query our paginator using accumulateInvoices to build up a\n\t\t// set of invoices.\n\t\tif err := paginator.query(accumulateInvoices); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// If we iterated through the add index in reverse order, then\n\t\t// we'll need to reverse the slice of invoices to return them in\n\t\t// forward order.\n\t\tif q.Reversed {\n\t\t\tnumInvoices := len(resp.Invoices)\n\t\t\tfor i := 0; i < numInvoices/2; i++ {\n\t\t\t\treverse := numInvoices - i - 1\n\t\t\t\tresp.Invoices[i], resp.Invoices[reverse] =\n\t\t\t\t\tresp.Invoices[reverse], resp.Invoices[i]\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}, func() {\n\t\tresp = invpkg.InvoiceSlice{\n\t\t\tInvoiceQuery: q,\n\t\t}\n\t})\n\tif err != nil && !errors.Is(err, invpkg.ErrNoInvoicesCreated) {\n\t\treturn resp, err\n\t}\n\n\t// Finally, record the indexes of the first and last invoices returned\n\t// so that the caller can resume from this point later on.\n\tif len(resp.Invoices) > 0 {\n\t\tresp.FirstIndexOffset = resp.Invoices[0].AddIndex\n\t\tlastIdx := len(resp.Invoices) - 1\n\t\tresp.LastIndexOffset = resp.Invoices[lastIdx].AddIndex\n\t}\n\n\treturn resp, nil\n}\n\n// UpdateInvoice attempts to update an invoice corresponding to the passed\n// payment hash. If an invoice matching the passed payment hash doesn't exist\n// within the database, then the action will fail with a \"not found\" error.\n//\n// The update is performed inside the same database transaction that fetches the\n// invoice and is therefore atomic. The fields to update are controlled by the\n// supplied callback.",
      "length": 3380,
      "tokens": 494,
      "embedding": []
    },
    {
      "slug": "func (d *DB) UpdateInvoice(ref invpkg.InvoiceRef, setIDHint *invpkg.SetID,",
      "content": "func (d *DB) UpdateInvoice(ref invpkg.InvoiceRef, setIDHint *invpkg.SetID,\n\tcallback invpkg.InvoiceUpdateCallback) (*invpkg.Invoice, error) {\n\n\tvar updatedInvoice *invpkg.Invoice\n\terr := kvdb.Update(d, func(tx kvdb.RwTx) error {\n\t\tinvoices, err := tx.CreateTopLevelBucket(invoiceBucket)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tinvoiceIndex, err := invoices.CreateBucketIfNotExists(\n\t\t\tinvoiceIndexBucket,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsettleIndex, err := invoices.CreateBucketIfNotExists(\n\t\t\tsettleIndexBucket,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpayAddrIndex := tx.ReadBucket(payAddrIndexBucket)\n\t\tsetIDIndex := tx.ReadWriteBucket(setIDIndexBucket)\n\n\t\t// Retrieve the invoice number for this invoice using the\n\t\t// provided invoice reference.\n\t\tinvoiceNum, err := fetchInvoiceNumByRef(\n\t\t\tinvoiceIndex, payAddrIndex, setIDIndex, ref,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tpayHash := ref.PayHash()\n\t\tupdatedInvoice, err = d.updateInvoice(\n\t\t\tpayHash, setIDHint, invoices, settleIndex, setIDIndex,\n\t\t\tinvoiceNum, callback,\n\t\t)\n\n\t\treturn err\n\t}, func() {\n\t\tupdatedInvoice = nil\n\t})\n\n\treturn updatedInvoice, err\n}\n\n// InvoicesSettledSince can be used by callers to catch up any settled invoices\n// they missed within the settled invoice time series. We'll return all known\n// settled invoice that have a settle index higher than the passed\n// sinceSettleIndex.\n//\n// NOTE: The index starts from 1, as a result. We enforce that specifying a\n// value below the starting index value is a noop.",
      "length": 1381,
      "tokens": 186,
      "embedding": []
    },
    {
      "slug": "func (d *DB) InvoicesSettledSince(sinceSettleIndex uint64) ([]invpkg.Invoice,",
      "content": "func (d *DB) InvoicesSettledSince(sinceSettleIndex uint64) ([]invpkg.Invoice,\n\terror) {\n\n\tvar settledInvoices []invpkg.Invoice\n\n\t// If an index of zero was specified, then in order to maintain\n\t// backwards compat, we won't send out any new invoices.\n\tif sinceSettleIndex == 0 {\n\t\treturn settledInvoices, nil\n\t}\n\n\tvar startIndex [8]byte\n\tbyteOrder.PutUint64(startIndex[:], sinceSettleIndex)\n\n\terr := kvdb.View(d, func(tx kvdb.RTx) error {\n\t\tinvoices := tx.ReadBucket(invoiceBucket)\n\t\tif invoices == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\tsettleIndex := invoices.NestedReadBucket(settleIndexBucket)\n\t\tif settleIndex == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\t// We'll now run through each entry in the add index starting\n\t\t// at our starting index. We'll continue until we reach the\n\t\t// very end of the current key space.\n\t\tinvoiceCursor := settleIndex.ReadCursor()\n\n\t\t// We'll seek to the starting index, then manually advance the\n\t\t// cursor in order to skip the entry with the since add index.\n\t\tinvoiceCursor.Seek(startIndex[:])\n\t\tseqNo, indexValue := invoiceCursor.Next()\n\n\t\tfor ; seqNo != nil && bytes.Compare(seqNo, startIndex[:]) > 0; seqNo, indexValue = invoiceCursor.Next() {\n\t\t\t// Depending on the length of the index value, this may\n\t\t\t// or may not be an AMP invoice, so we'll extract the\n\t\t\t// invoice value into two components: the invoice num,\n\t\t\t// and the setID (may not be there).\n\t\t\tvar (\n\t\t\t\tinvoiceKey [4]byte\n\t\t\t\tsetID      *invpkg.SetID\n\t\t\t)\n\n\t\t\tvalueLen := copy(invoiceKey[:], indexValue)\n\t\t\tif len(indexValue) == invoiceSetIDKeyLen {\n\t\t\t\tsetID = new(invpkg.SetID)\n\t\t\t\tcopy(setID[:], indexValue[valueLen:])\n\t\t\t}\n\n\t\t\t// For each key found, we'll look up the actual\n\t\t\t// invoice, then accumulate it into our return value.\n\t\t\tinvoice, err := fetchInvoice(\n\t\t\t\tinvoiceKey[:], invoices, setID,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tsettledInvoices = append(settledInvoices, invoice)\n\t\t}\n\n\t\treturn nil\n\t}, func() {\n\t\tsettledInvoices = nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn settledInvoices, nil\n}\n",
      "length": 1868,
      "tokens": 273,
      "embedding": []
    },
    {
      "slug": "func putInvoice(invoices, invoiceIndex, payAddrIndex, addIndex kvdb.RwBucket,",
      "content": "func putInvoice(invoices, invoiceIndex, payAddrIndex, addIndex kvdb.RwBucket,\n\ti *invpkg.Invoice, invoiceNum uint32, paymentHash lntypes.Hash) (\n\tuint64, error) {\n\n\t// Create the invoice key which is just the big-endian representation\n\t// of the invoice number.\n\tvar invoiceKey [4]byte\n\tbyteOrder.PutUint32(invoiceKey[:], invoiceNum)\n\n\t// Increment the num invoice counter index so the next invoice bares\n\t// the proper ID.\n\tvar scratch [4]byte\n\tinvoiceCounter := invoiceNum + 1\n\tbyteOrder.PutUint32(scratch[:], invoiceCounter)\n\tif err := invoiceIndex.Put(numInvoicesKey, scratch[:]); err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Add the payment hash to the invoice index. This will let us quickly\n\t// identify if we can settle an incoming payment, and also to possibly\n\t// allow a single invoice to have multiple payment installations.\n\terr := invoiceIndex.Put(paymentHash[:], invoiceKey[:])\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Add the invoice to the payment address index, but only if the invoice\n\t// has a non-zero payment address. The all-zero payment address is still\n\t// in use by legacy keysend, so we special-case here to avoid\n\t// collisions.\n\tif i.Terms.PaymentAddr != invpkg.BlankPayAddr {\n\t\terr = payAddrIndex.Put(i.Terms.PaymentAddr[:], invoiceKey[:])\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Next, we'll obtain the next add invoice index (sequence\n\t// number), so we can properly place this invoice within this\n\t// event stream.\n\tnextAddSeqNo, err := addIndex.NextSequence()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// With the next sequence obtained, we'll updating the event series in\n\t// the add index bucket to map this current add counter to the index of\n\t// this new invoice.\n\tvar seqNoBytes [8]byte\n\tbyteOrder.PutUint64(seqNoBytes[:], nextAddSeqNo)\n\tif err := addIndex.Put(seqNoBytes[:], invoiceKey[:]); err != nil {\n\t\treturn 0, err\n\t}\n\n\ti.AddIndex = nextAddSeqNo\n\n\t// Finally, serialize the invoice itself to be written to the disk.\n\tvar buf bytes.Buffer\n\tif err := serializeInvoice(&buf, i); err != nil {\n\t\treturn 0, err\n\t}\n\n\tif err := invoices.Put(invoiceKey[:], buf.Bytes()); err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn nextAddSeqNo, nil\n}\n\n// recordSize returns the amount of bytes this TLV record will occupy when\n// encoded.",
      "length": 2102,
      "tokens": 328,
      "embedding": []
    },
    {
      "slug": "func ampRecordSize(a *invpkg.AMPInvoiceState) func() uint64 {",
      "content": "func ampRecordSize(a *invpkg.AMPInvoiceState) func() uint64 {\n\tvar (\n\t\tb   bytes.Buffer\n\t\tbuf [8]byte\n\t)\n\n\t// We know that encoding works since the tests pass in the build this\n\t// file is checked into, so we'll simplify things and simply encode it\n\t// ourselves then report the total amount of bytes used.\n\tif err := ampStateEncoder(&b, a, &buf); err != nil {\n\t\t// This should never error out, but we log it just in case it\n\t\t// does.\n\t\tlog.Errorf(\"encoding the amp invoice state failed: %v\", err)\n\t}\n\n\treturn func() uint64 {\n\t\treturn uint64(len(b.Bytes()))\n\t}\n}\n\n// serializeInvoice serializes an invoice to a writer.\n//\n// Note: this function is in use for a migration. Before making changes that\n// would modify the on disk format, make a copy of the original code and store\n// it with the migration.",
      "length": 719,
      "tokens": 131,
      "embedding": []
    },
    {
      "slug": "func serializeInvoice(w io.Writer, i *invpkg.Invoice) error {",
      "content": "func serializeInvoice(w io.Writer, i *invpkg.Invoice) error {\n\tcreationDateBytes, err := i.CreationDate.MarshalBinary()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsettleDateBytes, err := i.SettleDate.MarshalBinary()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar fb bytes.Buffer\n\terr = i.Terms.Features.EncodeBase256(&fb)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfeatureBytes := fb.Bytes()\n\n\tpreimage := [32]byte(invpkg.UnknownPreimage)\n\tif i.Terms.PaymentPreimage != nil {\n\t\tpreimage = *i.Terms.PaymentPreimage\n\t\tif preimage == invpkg.UnknownPreimage {\n\t\t\treturn errors.New(\"cannot use all-zeroes preimage\")\n\t\t}\n\t}\n\tvalue := uint64(i.Terms.Value)\n\tcltvDelta := uint32(i.Terms.FinalCltvDelta)\n\texpiry := uint64(i.Terms.Expiry)\n\n\tamtPaid := uint64(i.AmtPaid)\n\tstate := uint8(i.State)\n\n\tvar hodlInvoice uint8\n\tif i.HodlInvoice {\n\t\thodlInvoice = 1\n\t}\n\n\ttlvStream, err := tlv.NewStream(\n\t\t// Memo and payreq.\n\t\ttlv.MakePrimitiveRecord(memoType, &i.Memo),\n\t\ttlv.MakePrimitiveRecord(payReqType, &i.PaymentRequest),\n\n\t\t// Add/settle metadata.\n\t\ttlv.MakePrimitiveRecord(createTimeType, &creationDateBytes),\n\t\ttlv.MakePrimitiveRecord(settleTimeType, &settleDateBytes),\n\t\ttlv.MakePrimitiveRecord(addIndexType, &i.AddIndex),\n\t\ttlv.MakePrimitiveRecord(settleIndexType, &i.SettleIndex),\n\n\t\t// Terms.\n\t\ttlv.MakePrimitiveRecord(preimageType, &preimage),\n\t\ttlv.MakePrimitiveRecord(valueType, &value),\n\t\ttlv.MakePrimitiveRecord(cltvDeltaType, &cltvDelta),\n\t\ttlv.MakePrimitiveRecord(expiryType, &expiry),\n\t\ttlv.MakePrimitiveRecord(paymentAddrType, &i.Terms.PaymentAddr),\n\t\ttlv.MakePrimitiveRecord(featuresType, &featureBytes),\n\n\t\t// Invoice state.\n\t\ttlv.MakePrimitiveRecord(invStateType, &state),\n\t\ttlv.MakePrimitiveRecord(amtPaidType, &amtPaid),\n\n\t\ttlv.MakePrimitiveRecord(hodlInvoiceType, &hodlInvoice),\n\n\t\t// Invoice AMP state.\n\t\ttlv.MakeDynamicRecord(\n\t\t\tinvoiceAmpStateType, &i.AMPState,\n\t\t\tampRecordSize(&i.AMPState),\n\t\t\tampStateEncoder, ampStateDecoder,\n\t\t),\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar b bytes.Buffer\n\tif err = tlvStream.Encode(&b); err != nil {\n\t\treturn err\n\t}\n\n\terr = binary.Write(w, byteOrder, uint64(b.Len()))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif _, err = w.Write(b.Bytes()); err != nil {\n\t\treturn err\n\t}\n\n\t// Only if this is a _non_ AMP invoice do we serialize the HTLCs\n\t// in-line with the rest of the invoice.\n\tif i.IsAMP() {\n\t\treturn nil\n\t}\n\n\treturn serializeHtlcs(w, i.Htlcs)\n}\n\n// serializeHtlcs serializes a map containing circuit keys and invoice htlcs to\n// a writer.",
      "length": 2305,
      "tokens": 241,
      "embedding": []
    },
    {
      "slug": "func serializeHtlcs(w io.Writer,",
      "content": "func serializeHtlcs(w io.Writer,\n\thtlcs map[models.CircuitKey]*invpkg.InvoiceHTLC) error {\n\n\tfor key, htlc := range htlcs {\n\t\t// Encode the htlc in a tlv stream.\n\t\tchanID := key.ChanID.ToUint64()\n\t\tamt := uint64(htlc.Amt)\n\t\tmppTotalAmt := uint64(htlc.MppTotalAmt)\n\t\tacceptTime := putNanoTime(htlc.AcceptTime)\n\t\tresolveTime := putNanoTime(htlc.ResolveTime)\n\t\tstate := uint8(htlc.State)\n\n\t\tvar records []tlv.Record\n\t\trecords = append(records,\n\t\t\ttlv.MakePrimitiveRecord(chanIDType, &chanID),\n\t\t\ttlv.MakePrimitiveRecord(htlcIDType, &key.HtlcID),\n\t\t\ttlv.MakePrimitiveRecord(amtType, &amt),\n\t\t\ttlv.MakePrimitiveRecord(\n\t\t\t\tacceptHeightType, &htlc.AcceptHeight,\n\t\t\t),\n\t\t\ttlv.MakePrimitiveRecord(acceptTimeType, &acceptTime),\n\t\t\ttlv.MakePrimitiveRecord(resolveTimeType, &resolveTime),\n\t\t\ttlv.MakePrimitiveRecord(expiryHeightType, &htlc.Expiry),\n\t\t\ttlv.MakePrimitiveRecord(htlcStateType, &state),\n\t\t\ttlv.MakePrimitiveRecord(mppTotalAmtType, &mppTotalAmt),\n\t\t)\n\n\t\tif htlc.AMP != nil {\n\t\t\tsetIDRecord := tlv.MakeDynamicRecord(\n\t\t\t\thtlcAMPType, &htlc.AMP.Record,\n\t\t\t\thtlc.AMP.Record.PayloadSize,\n\t\t\t\trecord.AMPEncoder, record.AMPDecoder,\n\t\t\t)\n\t\t\trecords = append(records, setIDRecord)\n\n\t\t\thash32 := [32]byte(htlc.AMP.Hash)\n\t\t\thashRecord := tlv.MakePrimitiveRecord(\n\t\t\t\thtlcHashType, &hash32,\n\t\t\t)\n\t\t\trecords = append(records, hashRecord)\n\n\t\t\tif htlc.AMP.Preimage != nil {\n\t\t\t\tpreimage32 := [32]byte(*htlc.AMP.Preimage)\n\t\t\t\tpreimageRecord := tlv.MakePrimitiveRecord(\n\t\t\t\t\thtlcPreimageType, &preimage32,\n\t\t\t\t)\n\t\t\t\trecords = append(records, preimageRecord)\n\t\t\t}\n\t\t}\n\n\t\t// Convert the custom records to tlv.Record types that are ready\n\t\t// for serialization.\n\t\tcustomRecords := tlv.MapToRecords(htlc.CustomRecords)\n\n\t\t// Append the custom records. Their ids are in the experimental\n\t\t// range and sorted, so there is no need to sort again.\n\t\trecords = append(records, customRecords...)\n\n\t\ttlvStream, err := tlv.NewStream(records...)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvar b bytes.Buffer\n\t\tif err := tlvStream.Encode(&b); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Write the length of the tlv stream followed by the stream\n\t\t// bytes.\n\t\terr = binary.Write(w, byteOrder, uint64(b.Len()))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif _, err := w.Write(b.Bytes()); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// putNanoTime returns the unix nano time for the passed timestamp. A zero-value\n// timestamp will be mapped to 0, since calling UnixNano in that case is\n// undefined.",
      "length": 2341,
      "tokens": 257,
      "embedding": []
    },
    {
      "slug": "func putNanoTime(t time.Time) uint64 {",
      "content": "func putNanoTime(t time.Time) uint64 {\n\tif t.IsZero() {\n\t\treturn 0\n\t}\n\treturn uint64(t.UnixNano())\n}\n\n// getNanoTime returns a timestamp for the given number of nano seconds. If zero\n// is provided, an zero-value time stamp is returned.",
      "length": 190,
      "tokens": 32,
      "embedding": []
    },
    {
      "slug": "func getNanoTime(ns uint64) time.Time {",
      "content": "func getNanoTime(ns uint64) time.Time {\n\tif ns == 0 {\n\t\treturn time.Time{}\n\t}\n\treturn time.Unix(0, int64(ns))\n}\n\n// fetchFilteredAmpInvoices retrieves only a select set of AMP invoices\n// identified by the setID value.",
      "length": 171,
      "tokens": 28,
      "embedding": []
    },
    {
      "slug": "func fetchFilteredAmpInvoices(invoiceBucket kvdb.RBucket, invoiceNum []byte,",
      "content": "func fetchFilteredAmpInvoices(invoiceBucket kvdb.RBucket, invoiceNum []byte,\n\tsetIDs ...*invpkg.SetID) (map[models.CircuitKey]*invpkg.InvoiceHTLC,\n\terror) {\n\n\thtlcs := make(map[models.CircuitKey]*invpkg.InvoiceHTLC)\n\tfor _, setID := range setIDs {\n\t\tinvoiceSetIDKey := makeInvoiceSetIDKey(invoiceNum, setID[:])\n\n\t\thtlcSetBytes := invoiceBucket.Get(invoiceSetIDKey[:])\n\t\tif htlcSetBytes == nil {\n\t\t\t// A set ID was passed in, but we don't have this\n\t\t\t// stored yet, meaning that the setID is being added\n\t\t\t// for the first time.\n\t\t\treturn htlcs, invpkg.ErrInvoiceNotFound\n\t\t}\n\n\t\thtlcSetReader := bytes.NewReader(htlcSetBytes)\n\t\thtlcsBySetID, err := deserializeHtlcs(htlcSetReader)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tfor key, htlc := range htlcsBySetID {\n\t\t\thtlcs[key] = htlc\n\t\t}\n\t}\n\n\treturn htlcs, nil\n}\n\n// forEachAMPInvoice is a helper function that attempts to iterate over each of\n// the HTLC sets (based on their set ID) for the given AMP invoice identified\n// by its invoiceNum. The callback closure is called for each key within the\n// prefix range.",
      "length": 957,
      "tokens": 135,
      "embedding": []
    },
    {
      "slug": "func forEachAMPInvoice(invoiceBucket kvdb.RBucket, invoiceNum []byte,",
      "content": "func forEachAMPInvoice(invoiceBucket kvdb.RBucket, invoiceNum []byte,\n\tcallback func(key, htlcSet []byte) error) error {\n\n\tinvoiceCursor := invoiceBucket.ReadCursor()\n\n\t// Seek to the first key that includes the invoice data itself.\n\tinvoiceCursor.Seek(invoiceNum)\n\n\t// Advance to the very first key _after_ the invoice data, as this is\n\t// where we'll encounter our first HTLC (if any are present).\n\tcursorKey, htlcSet := invoiceCursor.Next()\n\n\t// If at this point, the cursor key doesn't match the invoice num\n\t// prefix, then we know that this HTLC doesn't have any set ID HTLCs\n\t// associated with it.\n\tif !bytes.HasPrefix(cursorKey, invoiceNum) {\n\t\treturn nil\n\t}\n\n\t// Otherwise continue to iterate until we no longer match the prefix,\n\t// executing the call back at each step.\n\tfor ; cursorKey != nil && bytes.HasPrefix(cursorKey, invoiceNum); cursorKey, htlcSet = invoiceCursor.Next() {\n\t\terr := callback(cursorKey, htlcSet)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// fetchAmpSubInvoices attempts to use the invoiceNum as a prefix  within the\n// AMP bucket to find all the individual HTLCs (by setID) associated with a\n// given invoice. If a list of set IDs are specified, then only HTLCs\n// associated with that setID will be retrieved.",
      "length": 1155,
      "tokens": 187,
      "embedding": []
    },
    {
      "slug": "func fetchAmpSubInvoices(invoiceBucket kvdb.RBucket, invoiceNum []byte,",
      "content": "func fetchAmpSubInvoices(invoiceBucket kvdb.RBucket, invoiceNum []byte,\n\tsetIDs ...*invpkg.SetID) (map[models.CircuitKey]*invpkg.InvoiceHTLC,\n\terror) {\n\n\t// If a set of setIDs was specified, then we can skip the cursor and\n\t// just read out exactly what we need.\n\tif len(setIDs) != 0 && setIDs[0] != nil {\n\t\treturn fetchFilteredAmpInvoices(\n\t\t\tinvoiceBucket, invoiceNum, setIDs...,\n\t\t)\n\t}\n\n\t// Otherwise, iterate over all the htlc sets that are prefixed beside\n\t// this invoice in the main invoice bucket.\n\thtlcs := make(map[models.CircuitKey]*invpkg.InvoiceHTLC)\n\terr := forEachAMPInvoice(invoiceBucket, invoiceNum,\n\t\tfunc(key, htlcSet []byte) error {\n\t\t\thtlcSetReader := bytes.NewReader(htlcSet)\n\t\t\thtlcsBySetID, err := deserializeHtlcs(htlcSetReader)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tfor key, htlc := range htlcsBySetID {\n\t\t\t\thtlcs[key] = htlc\n\t\t\t}\n\n\t\t\treturn nil\n\t\t},\n\t)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn htlcs, nil\n}\n\n// fetchInvoice attempts to read out the relevant state for the invoice as\n// specified by the invoice number. If the setID fields are set, then only the\n// HTLC information pertaining to those set IDs is returned.",
      "length": 1050,
      "tokens": 157,
      "embedding": []
    },
    {
      "slug": "func fetchInvoice(invoiceNum []byte, invoices kvdb.RBucket,",
      "content": "func fetchInvoice(invoiceNum []byte, invoices kvdb.RBucket,\n\tsetIDs ...*invpkg.SetID) (invpkg.Invoice, error) {\n\n\tinvoiceBytes := invoices.Get(invoiceNum)\n\tif invoiceBytes == nil {\n\t\treturn invpkg.Invoice{}, invpkg.ErrInvoiceNotFound\n\t}\n\n\tinvoiceReader := bytes.NewReader(invoiceBytes)\n\n\tinvoice, err := deserializeInvoice(invoiceReader)\n\tif err != nil {\n\t\treturn invpkg.Invoice{}, err\n\t}\n\n\t// If this is an AMP invoice we'll also attempt to read out the set of\n\t// HTLCs that were paid to prior set IDs, if needed.\n\tif !invoice.IsAMP() {\n\t\treturn invoice, nil\n\t}\n\n\tif shouldFetchAMPHTLCs(invoice, setIDs) {\n\t\tinvoice.Htlcs, err = fetchAmpSubInvoices(\n\t\t\tinvoices, invoiceNum, setIDs...,\n\t\t)\n\t\t// TODO(positiveblue): we should fail when we are not able to\n\t\t// fetch all the HTLCs for an AMP invoice. Multiple tests in\n\t\t// the invoice and channeldb package break if we return this\n\t\t// error. We need to update them when we migrate this logic to\n\t\t// the sql implementation.\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"unable to fetch amp htlcs for inv \"+\n\t\t\t\t\"%v and setIDs %v: %w\", invoiceNum, setIDs, err)\n\t\t}\n\t}\n\n\treturn invoice, nil\n}\n\n// shouldFetchAMPHTLCs returns true if we need to fetch the set of HTLCs that\n// were paid to the relevant set IDs.",
      "length": 1147,
      "tokens": 179,
      "embedding": []
    },
    {
      "slug": "func shouldFetchAMPHTLCs(invoice invpkg.Invoice, setIDs []*invpkg.SetID) bool {",
      "content": "func shouldFetchAMPHTLCs(invoice invpkg.Invoice, setIDs []*invpkg.SetID) bool {\n\t// For AMP invoice that already have HTLCs populated (created before\n\t// recurring invoices), then we don't need to read from the prefix\n\t// keyed section of the bucket.\n\tif len(invoice.Htlcs) != 0 {\n\t\treturn false\n\t}\n\n\t// If the \"zero\" setID was specified, then this means that no HTLC data\n\t// should be returned alongside of it.\n\tif len(setIDs) != 0 && setIDs[0] != nil &&\n\t\t*setIDs[0] == invpkg.BlankPayAddr {\n\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// fetchInvoiceStateAMP retrieves the state of all the relevant sub-invoice for\n// an AMP invoice. This methods only decode the relevant state vs the entire\n// invoice.",
      "length": 599,
      "tokens": 104,
      "embedding": []
    },
    {
      "slug": "func fetchInvoiceStateAMP(invoiceNum []byte,",
      "content": "func fetchInvoiceStateAMP(invoiceNum []byte,\n\tinvoices kvdb.RBucket) (invpkg.AMPInvoiceState, error) {\n\n\t// Fetch the raw invoice bytes.\n\tinvoiceBytes := invoices.Get(invoiceNum)\n\tif invoiceBytes == nil {\n\t\treturn nil, invpkg.ErrInvoiceNotFound\n\t}\n\n\tr := bytes.NewReader(invoiceBytes)\n\n\tvar bodyLen int64\n\terr := binary.Read(r, byteOrder, &bodyLen)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Next, we'll make a new TLV stream that only attempts to decode the\n\t// bytes we actually need.\n\tampState := make(invpkg.AMPInvoiceState)\n\ttlvStream, err := tlv.NewStream(\n\t\t// Invoice AMP state.\n\t\ttlv.MakeDynamicRecord(\n\t\t\tinvoiceAmpStateType, &ampState, nil,\n\t\t\tampStateEncoder, ampStateDecoder,\n\t\t),\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tinvoiceReader := io.LimitReader(r, bodyLen)\n\tif err = tlvStream.Decode(invoiceReader); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn ampState, nil\n}\n",
      "length": 801,
      "tokens": 110,
      "embedding": []
    },
    {
      "slug": "func deserializeInvoice(r io.Reader) (invpkg.Invoice, error) {",
      "content": "func deserializeInvoice(r io.Reader) (invpkg.Invoice, error) {\n\tvar (\n\t\tpreimageBytes [32]byte\n\t\tvalue         uint64\n\t\tcltvDelta     uint32\n\t\texpiry        uint64\n\t\tamtPaid       uint64\n\t\tstate         uint8\n\t\thodlInvoice   uint8\n\n\t\tcreationDateBytes []byte\n\t\tsettleDateBytes   []byte\n\t\tfeatureBytes      []byte\n\t)\n\n\tvar i invpkg.Invoice\n\ti.AMPState = make(invpkg.AMPInvoiceState)\n\ttlvStream, err := tlv.NewStream(\n\t\t// Memo and payreq.\n\t\ttlv.MakePrimitiveRecord(memoType, &i.Memo),\n\t\ttlv.MakePrimitiveRecord(payReqType, &i.PaymentRequest),\n\n\t\t// Add/settle metadata.\n\t\ttlv.MakePrimitiveRecord(createTimeType, &creationDateBytes),\n\t\ttlv.MakePrimitiveRecord(settleTimeType, &settleDateBytes),\n\t\ttlv.MakePrimitiveRecord(addIndexType, &i.AddIndex),\n\t\ttlv.MakePrimitiveRecord(settleIndexType, &i.SettleIndex),\n\n\t\t// Terms.\n\t\ttlv.MakePrimitiveRecord(preimageType, &preimageBytes),\n\t\ttlv.MakePrimitiveRecord(valueType, &value),\n\t\ttlv.MakePrimitiveRecord(cltvDeltaType, &cltvDelta),\n\t\ttlv.MakePrimitiveRecord(expiryType, &expiry),\n\t\ttlv.MakePrimitiveRecord(paymentAddrType, &i.Terms.PaymentAddr),\n\t\ttlv.MakePrimitiveRecord(featuresType, &featureBytes),\n\n\t\t// Invoice state.\n\t\ttlv.MakePrimitiveRecord(invStateType, &state),\n\t\ttlv.MakePrimitiveRecord(amtPaidType, &amtPaid),\n\n\t\ttlv.MakePrimitiveRecord(hodlInvoiceType, &hodlInvoice),\n\n\t\t// Invoice AMP state.\n\t\ttlv.MakeDynamicRecord(\n\t\t\tinvoiceAmpStateType, &i.AMPState, nil,\n\t\t\tampStateEncoder, ampStateDecoder,\n\t\t),\n\t)\n\tif err != nil {\n\t\treturn i, err\n\t}\n\n\tvar bodyLen int64\n\terr = binary.Read(r, byteOrder, &bodyLen)\n\tif err != nil {\n\t\treturn i, err\n\t}\n\n\tlr := io.LimitReader(r, bodyLen)\n\tif err = tlvStream.Decode(lr); err != nil {\n\t\treturn i, err\n\t}\n\n\tpreimage := lntypes.Preimage(preimageBytes)\n\tif preimage != invpkg.UnknownPreimage {\n\t\ti.Terms.PaymentPreimage = &preimage\n\t}\n\n\ti.Terms.Value = lnwire.MilliSatoshi(value)\n\ti.Terms.FinalCltvDelta = int32(cltvDelta)\n\ti.Terms.Expiry = time.Duration(expiry)\n\ti.AmtPaid = lnwire.MilliSatoshi(amtPaid)\n\ti.State = invpkg.ContractState(state)\n\n\tif hodlInvoice != 0 {\n\t\ti.HodlInvoice = true\n\t}\n\n\terr = i.CreationDate.UnmarshalBinary(creationDateBytes)\n\tif err != nil {\n\t\treturn i, err\n\t}\n\n\terr = i.SettleDate.UnmarshalBinary(settleDateBytes)\n\tif err != nil {\n\t\treturn i, err\n\t}\n\n\trawFeatures := lnwire.NewRawFeatureVector()\n\terr = rawFeatures.DecodeBase256(\n\t\tbytes.NewReader(featureBytes), len(featureBytes),\n\t)\n\tif err != nil {\n\t\treturn i, err\n\t}\n\n\ti.Terms.Features = lnwire.NewFeatureVector(\n\t\trawFeatures, lnwire.Features,\n\t)\n\n\ti.Htlcs, err = deserializeHtlcs(r)\n\treturn i, err\n}\n",
      "length": 2409,
      "tokens": 221,
      "embedding": []
    },
    {
      "slug": "func encodeCircuitKeys(w io.Writer, val interface{}, buf *[8]byte) error {",
      "content": "func encodeCircuitKeys(w io.Writer, val interface{}, buf *[8]byte) error {\n\tif v, ok := val.(*map[models.CircuitKey]struct{}); ok {\n\t\t// We encode the set of circuit keys as a varint length prefix.\n\t\t// followed by a series of fixed sized uint8 integers.\n\t\tnumKeys := uint64(len(*v))\n\n\t\tif err := tlv.WriteVarInt(w, numKeys, buf); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfor key := range *v {\n\t\t\tscidInt := key.ChanID.ToUint64()\n\n\t\t\tif err := tlv.EUint64(w, &scidInt, buf); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := tlv.EUint64(w, &key.HtlcID, buf); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}\n\n\treturn tlv.NewTypeForEncodingErr(val, \"*map[CircuitKey]struct{}\")\n}\n",
      "length": 572,
      "tokens": 89,
      "embedding": []
    },
    {
      "slug": "func decodeCircuitKeys(r io.Reader, val interface{}, buf *[8]byte,",
      "content": "func decodeCircuitKeys(r io.Reader, val interface{}, buf *[8]byte,\n\tl uint64) error {\n\n\tif v, ok := val.(*map[models.CircuitKey]struct{}); ok {\n\t\t// First, we'll read out the varint that encodes the number of\n\t\t// circuit keys encoded.\n\t\tnumKeys, err := tlv.ReadVarInt(r, buf)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Now that we know how many keys to expect, iterate reading\n\t\t// each one until we're done.\n\t\tfor i := uint64(0); i < numKeys; i++ {\n\t\t\tvar (\n\t\t\t\tkey  models.CircuitKey\n\t\t\t\tscid uint64\n\t\t\t)\n\n\t\t\tif err := tlv.DUint64(r, &scid, buf, 8); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tkey.ChanID = lnwire.NewShortChanIDFromInt(scid)\n\n\t\t\terr := tlv.DUint64(r, &key.HtlcID, buf, 8)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t(*v)[key] = struct{}{}\n\t\t}\n\n\t\treturn nil\n\t}\n\n\treturn tlv.NewTypeForDecodingErr(val, \"*map[CircuitKey]struct{}\", l, l)\n}\n\n// ampStateEncoder is a custom TLV encoder for the AMPInvoiceState record.",
      "length": 817,
      "tokens": 129,
      "embedding": []
    },
    {
      "slug": "func ampStateEncoder(w io.Writer, val interface{}, buf *[8]byte) error {",
      "content": "func ampStateEncoder(w io.Writer, val interface{}, buf *[8]byte) error {\n\tif v, ok := val.(*invpkg.AMPInvoiceState); ok {\n\t\t// We'll encode the AMP state as a series of KV pairs on the\n\t\t// wire with a length prefix.\n\t\tnumRecords := uint64(len(*v))\n\n\t\t// First, we'll write out the number of records as a var int.\n\t\tif err := tlv.WriteVarInt(w, numRecords, buf); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// With that written out, we'll now encode the entries\n\t\t// themselves as a sub-TLV record, which includes its _own_\n\t\t// inner length prefix.\n\t\tfor setID, ampState := range *v {\n\t\t\tsetID := [32]byte(setID)\n\t\t\tampState := ampState\n\n\t\t\thtlcState := uint8(ampState.State)\n\t\t\tsettleDate := ampState.SettleDate\n\t\t\tsettleDateBytes, err := settleDate.MarshalBinary()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tamtPaid := uint64(ampState.AmtPaid)\n\n\t\t\tvar ampStateTlvBytes bytes.Buffer\n\t\t\ttlvStream, err := tlv.NewStream(\n\t\t\t\ttlv.MakePrimitiveRecord(\n\t\t\t\t\tampStateSetIDType, &setID,\n\t\t\t\t),\n\t\t\t\ttlv.MakePrimitiveRecord(\n\t\t\t\t\tampStateHtlcStateType, &htlcState,\n\t\t\t\t),\n\t\t\t\ttlv.MakePrimitiveRecord(\n\t\t\t\t\tampStateSettleIndexType,\n\t\t\t\t\t&ampState.SettleIndex,\n\t\t\t\t),\n\t\t\t\ttlv.MakePrimitiveRecord(\n\t\t\t\t\tampStateSettleDateType,\n\t\t\t\t\t&settleDateBytes,\n\t\t\t\t),\n\t\t\t\ttlv.MakeDynamicRecord(\n\t\t\t\t\tampStateCircuitKeysType,\n\t\t\t\t\t&ampState.InvoiceKeys,\n\t\t\t\t\tfunc() uint64 {\n\t\t\t\t\t\t// The record takes 8 bytes to\n\t\t\t\t\t\t// encode the set of circuits,\n\t\t\t\t\t\t// 8 bytes for the scid for the\n\t\t\t\t\t\t// key, and 8 bytes for the HTLC\n\t\t\t\t\t\t// index.\n\t\t\t\t\t\tkeys := ampState.InvoiceKeys\n\t\t\t\t\t\tnumKeys := uint64(len(keys))\n\t\t\t\t\t\tsize := tlv.VarIntSize(numKeys)\n\t\t\t\t\t\tdataSize := (numKeys * 16)\n\n\t\t\t\t\t\treturn size + dataSize\n\t\t\t\t\t},\n\t\t\t\t\tencodeCircuitKeys, decodeCircuitKeys,\n\t\t\t\t),\n\t\t\t\ttlv.MakePrimitiveRecord(\n\t\t\t\t\tampStateAmtPaidType, &amtPaid,\n\t\t\t\t),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\terr = tlvStream.Encode(&ampStateTlvBytes)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// We encode the record with a varint length followed by\n\t\t\t// the _raw_ TLV bytes.\n\t\t\ttlvLen := uint64(len(ampStateTlvBytes.Bytes()))\n\t\t\tif err := tlv.WriteVarInt(w, tlvLen, buf); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t_, err = w.Write(ampStateTlvBytes.Bytes())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}\n\n\treturn tlv.NewTypeForEncodingErr(val, \"channeldb.AMPInvoiceState\")\n}\n\n// ampStateDecoder is a custom TLV decoder for the AMPInvoiceState record.",
      "length": 2246,
      "tokens": 283,
      "embedding": []
    },
    {
      "slug": "func ampStateDecoder(r io.Reader, val interface{}, buf *[8]byte,",
      "content": "func ampStateDecoder(r io.Reader, val interface{}, buf *[8]byte,\n\tl uint64) error {\n\n\tif v, ok := val.(*invpkg.AMPInvoiceState); ok {\n\t\t// First, we'll decode the varint that encodes how many set IDs\n\t\t// are encoded within the greater map.\n\t\tnumRecords, err := tlv.ReadVarInt(r, buf)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Now that we know how many records we'll need to read, we can\n\t\t// iterate and read them all out in series.\n\t\tfor i := uint64(0); i < numRecords; i++ {\n\t\t\t// Read out the varint that encodes the size of this\n\t\t\t// inner TLV record.\n\t\t\tstateRecordSize, err := tlv.ReadVarInt(r, buf)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Using this information, we'll create a new limited\n\t\t\t// reader that'll return an EOF once the end has been\n\t\t\t// reached so the stream stops consuming bytes.\n\t\t\tinnerTlvReader := io.LimitedReader{\n\t\t\t\tR: r,\n\t\t\t\tN: int64(stateRecordSize),\n\t\t\t}\n\n\t\t\tvar (\n\t\t\t\tsetID           [32]byte\n\t\t\t\thtlcState       uint8\n\t\t\t\tsettleIndex     uint64\n\t\t\t\tsettleDateBytes []byte\n\t\t\t\tinvoiceKeys     = make(\n\t\t\t\t\tmap[models.CircuitKey]struct{},\n\t\t\t\t)\n\t\t\t\tamtPaid uint64\n\t\t\t)\n\t\t\ttlvStream, err := tlv.NewStream(\n\t\t\t\ttlv.MakePrimitiveRecord(\n\t\t\t\t\tampStateSetIDType, &setID,\n\t\t\t\t),\n\t\t\t\ttlv.MakePrimitiveRecord(\n\t\t\t\t\tampStateHtlcStateType, &htlcState,\n\t\t\t\t),\n\t\t\t\ttlv.MakePrimitiveRecord(\n\t\t\t\t\tampStateSettleIndexType, &settleIndex,\n\t\t\t\t),\n\t\t\t\ttlv.MakePrimitiveRecord(\n\t\t\t\t\tampStateSettleDateType,\n\t\t\t\t\t&settleDateBytes,\n\t\t\t\t),\n\t\t\t\ttlv.MakeDynamicRecord(\n\t\t\t\t\tampStateCircuitKeysType,\n\t\t\t\t\t&invoiceKeys, nil,\n\t\t\t\t\tencodeCircuitKeys, decodeCircuitKeys,\n\t\t\t\t),\n\t\t\t\ttlv.MakePrimitiveRecord(\n\t\t\t\t\tampStateAmtPaidType, &amtPaid,\n\t\t\t\t),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\terr = tlvStream.Decode(&innerTlvReader)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tvar settleDate time.Time\n\t\t\terr = settleDate.UnmarshalBinary(settleDateBytes)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t(*v)[setID] = invpkg.InvoiceStateAMP{\n\t\t\t\tState:       invpkg.HtlcState(htlcState),\n\t\t\t\tSettleIndex: settleIndex,\n\t\t\t\tSettleDate:  settleDate,\n\t\t\t\tInvoiceKeys: invoiceKeys,\n\t\t\t\tAmtPaid:     lnwire.MilliSatoshi(amtPaid),\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}\n\n\treturn tlv.NewTypeForDecodingErr(\n\t\tval, \"channeldb.AMPInvoiceState\", l, l,\n\t)\n}\n\n// deserializeHtlcs reads a list of invoice htlcs from a reader and returns it\n// as a map.",
      "length": 2177,
      "tokens": 266,
      "embedding": []
    },
    {
      "slug": "func deserializeHtlcs(r io.Reader) (map[models.CircuitKey]*invpkg.InvoiceHTLC,",
      "content": "func deserializeHtlcs(r io.Reader) (map[models.CircuitKey]*invpkg.InvoiceHTLC,\n\terror) {\n\n\thtlcs := make(map[models.CircuitKey]*invpkg.InvoiceHTLC)\n\tfor {\n\t\t// Read the length of the tlv stream for this htlc.\n\t\tvar streamLen int64\n\t\tif err := binary.Read(r, byteOrder, &streamLen); err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Limit the reader so that it stops at the end of this htlc's\n\t\t// stream.\n\t\thtlcReader := io.LimitReader(r, streamLen)\n\n\t\t// Decode the contents into the htlc fields.\n\t\tvar (\n\t\t\thtlc                    invpkg.InvoiceHTLC\n\t\t\tkey                     models.CircuitKey\n\t\t\tchanID                  uint64\n\t\t\tstate                   uint8\n\t\t\tacceptTime, resolveTime uint64\n\t\t\tamt, mppTotalAmt        uint64\n\t\t\tamp                     = &record.AMP{}\n\t\t\thash32                  = &[32]byte{}\n\t\t\tpreimage32              = &[32]byte{}\n\t\t)\n\t\ttlvStream, err := tlv.NewStream(\n\t\t\ttlv.MakePrimitiveRecord(chanIDType, &chanID),\n\t\t\ttlv.MakePrimitiveRecord(htlcIDType, &key.HtlcID),\n\t\t\ttlv.MakePrimitiveRecord(amtType, &amt),\n\t\t\ttlv.MakePrimitiveRecord(\n\t\t\t\tacceptHeightType, &htlc.AcceptHeight,\n\t\t\t),\n\t\t\ttlv.MakePrimitiveRecord(acceptTimeType, &acceptTime),\n\t\t\ttlv.MakePrimitiveRecord(resolveTimeType, &resolveTime),\n\t\t\ttlv.MakePrimitiveRecord(expiryHeightType, &htlc.Expiry),\n\t\t\ttlv.MakePrimitiveRecord(htlcStateType, &state),\n\t\t\ttlv.MakePrimitiveRecord(mppTotalAmtType, &mppTotalAmt),\n\t\t\ttlv.MakeDynamicRecord(\n\t\t\t\thtlcAMPType, amp, amp.PayloadSize,\n\t\t\t\trecord.AMPEncoder, record.AMPDecoder,\n\t\t\t),\n\t\t\ttlv.MakePrimitiveRecord(htlcHashType, hash32),\n\t\t\ttlv.MakePrimitiveRecord(htlcPreimageType, preimage32),\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tparsedTypes, err := tlvStream.DecodeWithParsedTypes(htlcReader)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif _, ok := parsedTypes[htlcAMPType]; !ok {\n\t\t\tamp = nil\n\t\t}\n\n\t\tvar preimage *lntypes.Preimage\n\t\tif _, ok := parsedTypes[htlcPreimageType]; ok {\n\t\t\tpimg := lntypes.Preimage(*preimage32)\n\t\t\tpreimage = &pimg\n\t\t}\n\n\t\tvar hash *lntypes.Hash\n\t\tif _, ok := parsedTypes[htlcHashType]; ok {\n\t\t\th := lntypes.Hash(*hash32)\n\t\t\thash = &h\n\t\t}\n\n\t\tkey.ChanID = lnwire.NewShortChanIDFromInt(chanID)\n\t\thtlc.AcceptTime = getNanoTime(acceptTime)\n\t\thtlc.ResolveTime = getNanoTime(resolveTime)\n\t\thtlc.State = invpkg.HtlcState(state)\n\t\thtlc.Amt = lnwire.MilliSatoshi(amt)\n\t\thtlc.MppTotalAmt = lnwire.MilliSatoshi(mppTotalAmt)\n\t\tif amp != nil && hash != nil {\n\t\t\thtlc.AMP = &invpkg.InvoiceHtlcAMPData{\n\t\t\t\tRecord:   *amp,\n\t\t\t\tHash:     *hash,\n\t\t\t\tPreimage: preimage,\n\t\t\t}\n\t\t}\n\n\t\t// Reconstruct the custom records fields from the parsed types\n\t\t// map return from the tlv parser.\n\t\thtlc.CustomRecords = hop.NewCustomRecords(parsedTypes)\n\n\t\thtlcs[key] = &htlc\n\t}\n\n\treturn htlcs, nil\n}\n\n// invoiceSetIDKeyLen is the length of the key that's used to store the\n// individual HTLCs prefixed by their ID along side the main invoice within the\n// invoiceBytes. We use 4 bytes for the invoice number, and 32 bytes for the\n// set ID.\nconst invoiceSetIDKeyLen = 4 + 32\n\n// makeInvoiceSetIDKey returns the prefix key, based on the set ID and invoice\n// number where the HTLCs for this setID will be stored udner.",
      "length": 3002,
      "tokens": 341,
      "embedding": []
    },
    {
      "slug": "func makeInvoiceSetIDKey(invoiceNum, setID []byte) [invoiceSetIDKeyLen]byte {",
      "content": "func makeInvoiceSetIDKey(invoiceNum, setID []byte) [invoiceSetIDKeyLen]byte {\n\t// Construct the prefix key we need to obtain the invoice information:\n\t// invoiceNum || setID.\n\tvar invoiceSetIDKey [invoiceSetIDKeyLen]byte\n\tcopy(invoiceSetIDKey[:], invoiceNum)\n\tcopy(invoiceSetIDKey[len(invoiceNum):], setID)\n\n\treturn invoiceSetIDKey\n}\n\n// updateAMPInvoices updates the set of AMP invoices in-place. For AMP, rather\n// then continually write the invoices to the end of the invoice value, we\n// instead write the invoices into a new key preifx that follows the main\n// invoice number. This ensures that we don't need to continually decode a\n// potentially massive HTLC set, and also allows us to quickly find the HLTCs\n// associated with a particular HTLC set.",
      "length": 665,
      "tokens": 100,
      "embedding": []
    },
    {
      "slug": "func updateAMPInvoices(invoiceBucket kvdb.RwBucket, invoiceNum []byte,",
      "content": "func updateAMPInvoices(invoiceBucket kvdb.RwBucket, invoiceNum []byte,\n\thtlcsToUpdate map[invpkg.SetID]map[models.CircuitKey]*invpkg.InvoiceHTLC) error { //nolint:lll\n\n\tfor setID, htlcSet := range htlcsToUpdate {\n\t\t// First write out the set of HTLCs including all the relevant\n\t\t// TLV values.\n\t\tvar b bytes.Buffer\n\t\tif err := serializeHtlcs(&b, htlcSet); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Next store each HTLC in-line, using a prefix based off the\n\t\t// invoice number.\n\t\tinvoiceSetIDKey := makeInvoiceSetIDKey(invoiceNum, setID[:])\n\n\t\terr := invoiceBucket.Put(invoiceSetIDKey[:], b.Bytes())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// updateHtlcsAmp takes an invoice, and a new HTLC to be added (along with its\n// set ID), and update sthe internal AMP state of an invoice, and also tallies\n// the set of HTLCs to be updated on disk.",
      "length": 755,
      "tokens": 117,
      "embedding": []
    },
    {
      "slug": "func updateHtlcsAmp(invoice *invpkg.Invoice,",
      "content": "func updateHtlcsAmp(invoice *invpkg.Invoice,\n\tupdateMap map[invpkg.SetID]map[models.CircuitKey]*invpkg.InvoiceHTLC,\n\thtlc *invpkg.InvoiceHTLC, setID invpkg.SetID,\n\tcircuitKey models.CircuitKey) {\n\n\tampState, ok := invoice.AMPState[setID]\n\tif !ok {\n\t\t// If an entry for this set ID doesn't already exist, then\n\t\t// we'll need to create it.\n\t\tampState = invpkg.InvoiceStateAMP{\n\t\t\tState:       invpkg.HtlcStateAccepted,\n\t\t\tInvoiceKeys: make(map[models.CircuitKey]struct{}),\n\t\t}\n\t}\n\n\tampState.AmtPaid += htlc.Amt\n\tampState.InvoiceKeys[circuitKey] = struct{}{}\n\n\t// Due to the way maps work, we need to read out the value, update it,\n\t// then re-assign it into the map.\n\tinvoice.AMPState[setID] = ampState\n\n\t// Now that we've updated the invoice state, we'll inform the caller of\n\t// the _neitre_ HTLC set they need to write for this new set ID.\n\tif _, ok := updateMap[setID]; !ok {\n\t\t// If we're just now creating the HTLCs for this set then we'll\n\t\t// also pull in the existing HTLCs are part of this set, so we\n\t\t// can write them all to disk together (same value)\n\t\tupdateMap[setID] = invoice.HTLCSet(\n\t\t\t(*[32]byte)(&setID), invpkg.HtlcStateAccepted,\n\t\t)\n\t}\n\tupdateMap[setID][circuitKey] = htlc\n}\n\n// cancelHtlcsAmp processes a cancellation of an HTLC that belongs to an AMP\n// HTLC set. We'll need to update the meta data in the  main invoice, and also\n// apply the new update to the update MAP, since all the HTLCs for a given HTLC\n// set need to be written in-line with each other.",
      "length": 1403,
      "tokens": 213,
      "embedding": []
    },
    {
      "slug": "func cancelHtlcsAmp(invoice *invpkg.Invoice,",
      "content": "func cancelHtlcsAmp(invoice *invpkg.Invoice,\n\tupdateMap map[invpkg.SetID]map[models.CircuitKey]*invpkg.InvoiceHTLC,\n\thtlc *invpkg.InvoiceHTLC, circuitKey models.CircuitKey) {\n\n\tsetID := htlc.AMP.Record.SetID()\n\n\t// First, we'll update the state of the entire HTLC set to cancelled.\n\tampState := invoice.AMPState[setID]\n\tampState.State = invpkg.HtlcStateCanceled\n\n\tampState.InvoiceKeys[circuitKey] = struct{}{}\n\tampState.AmtPaid -= htlc.Amt\n\n\t// With the state update,d we'll set the new value so the struct\n\t// changes are propagated.\n\tinvoice.AMPState[setID] = ampState\n\n\tif _, ok := updateMap[setID]; !ok {\n\t\t// Only HTLCs in the accepted state, can be cancelled, but we\n\t\t// also want to merge that with HTLCs that may be canceled as\n\t\t// well since it can be cancelled one by one.\n\t\tupdateMap[setID] = invoice.HTLCSet(\n\t\t\t&setID, invpkg.HtlcStateAccepted,\n\t\t)\n\n\t\tcancelledHtlcs := invoice.HTLCSet(\n\t\t\t&setID, invpkg.HtlcStateCanceled,\n\t\t)\n\t\tfor htlcKey, htlc := range cancelledHtlcs {\n\t\t\tupdateMap[setID][htlcKey] = htlc\n\t\t}\n\t}\n\n\t// Finally, include the newly cancelled HTLC in the set of HTLCs we\n\t// need to cancel.\n\tupdateMap[setID][circuitKey] = htlc\n\n\t// We'll only decrement the total amount paid if the invoice was\n\t// already in the accepted state.\n\tif invoice.AmtPaid != 0 {\n\t\tinvoice.AmtPaid -= htlc.Amt\n\t}\n}\n\n// settleHtlcsAmp processes a new settle operation on an HTLC set for an AMP\n// invoice. We'll update some meta data in the main invoice, and also signal\n// that this HTLC set needs to be re-written back to disk.",
      "length": 1446,
      "tokens": 209,
      "embedding": []
    },
    {
      "slug": "func settleHtlcsAmp(invoice *invpkg.Invoice,",
      "content": "func settleHtlcsAmp(invoice *invpkg.Invoice,\n\tsettledSetIDs map[invpkg.SetID]struct{},\n\tupdateMap map[invpkg.SetID]map[models.CircuitKey]*invpkg.InvoiceHTLC,\n\thtlc *invpkg.InvoiceHTLC, circuitKey models.CircuitKey) {\n\n\t// First, add the set ID to the set that was settled in this invoice\n\t// update. We'll use this later to update the settle index.\n\tsetID := htlc.AMP.Record.SetID()\n\tsettledSetIDs[setID] = struct{}{}\n\n\t// Next update the main AMP meta-data to indicate that this HTLC set\n\t// has been fully settled.\n\tampState := invoice.AMPState[setID]\n\tampState.State = invpkg.HtlcStateSettled\n\n\tampState.InvoiceKeys[circuitKey] = struct{}{}\n\n\tinvoice.AMPState[setID] = ampState\n\n\t// Finally, we'll add this to the set of HTLCs that need to be updated.\n\tif _, ok := updateMap[setID]; !ok {\n\t\tmapEntry := make(map[models.CircuitKey]*invpkg.InvoiceHTLC)\n\t\tupdateMap[setID] = mapEntry\n\t}\n\tupdateMap[setID][circuitKey] = htlc\n}\n\n// updateInvoice fetches the invoice, obtains the update descriptor from the\n// callback and applies the updates in a single db transaction.",
      "length": 995,
      "tokens": 126,
      "embedding": []
    },
    {
      "slug": "func (d *DB) updateInvoice(hash *lntypes.Hash, refSetID *invpkg.SetID, invoices, //nolint:lll,funlen",
      "content": "func (d *DB) updateInvoice(hash *lntypes.Hash, refSetID *invpkg.SetID, invoices, //nolint:lll,funlen\n\tsettleIndex, setIDIndex kvdb.RwBucket, invoiceNum []byte,\n\tcallback invpkg.InvoiceUpdateCallback) (*invpkg.Invoice, error) {\n\n\t// If the set ID is non-nil, then we'll use that to filter out the\n\t// HTLCs for AMP invoice so we don't need to read them all out to\n\t// satisfy the invoice callback below. If it's nil, then we pass in the\n\t// zero set ID which means no HTLCs will be read out.\n\tvar invSetID invpkg.SetID\n\tif refSetID != nil {\n\t\tinvSetID = *refSetID\n\t}\n\tinvoice, err := fetchInvoice(invoiceNum, invoices, &invSetID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create deep copy to prevent any accidental modification in the\n\t// callback.\n\tinvoiceCopy, err := invpkg.CopyInvoice(&invoice)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Call the callback and obtain the update descriptor.\n\tupdate, err := callback(invoiceCopy)\n\tif err != nil {\n\t\treturn &invoice, err\n\t}\n\n\t// If there is nothing to update, return early.\n\tif update == nil {\n\t\treturn &invoice, nil\n\t}\n\n\tvar (\n\t\tnewState = invoice.State\n\t\tsetID    *[32]byte\n\t)\n\n\t// We can either get the set ID from the main state update (if the\n\t// state is changing), or via the hint passed in returned by the update\n\t// call back.\n\tif update.State != nil {\n\t\tsetID = update.State.SetID\n\t\tnewState = update.State.NewState\n\t} else if update.SetID != nil {\n\t\t// When we go to cancel HTLCs, there's no new state, but the\n\t\t// set of HTLCs to be cancelled along with the setID affected\n\t\t// will be passed in.\n\t\tsetID = (*[32]byte)(update.SetID)\n\t}\n\n\tnow := d.clock.Now()\n\n\tinvoiceIsAMP := invoiceCopy.IsAMP()\n\n\t// Process add actions from update descriptor.\n\thtlcsAmpUpdate := make(map[invpkg.SetID]map[models.CircuitKey]*invpkg.InvoiceHTLC) //nolint:lll\n\tfor key, htlcUpdate := range update.AddHtlcs {\n\t\tif _, exists := invoice.Htlcs[key]; exists {\n\t\t\treturn nil, fmt.Errorf(\"duplicate add of htlc %v\", key)\n\t\t}\n\n\t\t// Force caller to supply htlc without custom records in a\n\t\t// consistent way.\n\t\tif htlcUpdate.CustomRecords == nil {\n\t\t\treturn nil, errors.New(\"nil custom records map\")\n\t\t}\n\n\t\t// If a newly added HTLC has an associated set id, use it to\n\t\t// index this invoice in the set id index. An error is returned\n\t\t// if we find the index already points to a different invoice.\n\t\tvar setID [32]byte\n\t\tif htlcUpdate.AMP != nil {\n\t\t\tsetID = htlcUpdate.AMP.Record.SetID()\n\t\t\tsetIDInvNum := setIDIndex.Get(setID[:])\n\t\t\tif setIDInvNum == nil {\n\t\t\t\terr = setIDIndex.Put(setID[:], invoiceNum)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t} else if !bytes.Equal(setIDInvNum, invoiceNum) {\n\t\t\t\terr = invpkg.ErrDuplicateSetID{SetID: setID}\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\thtlc := &invpkg.InvoiceHTLC{\n\t\t\tAmt:           htlcUpdate.Amt,\n\t\t\tMppTotalAmt:   htlcUpdate.MppTotalAmt,\n\t\t\tExpiry:        htlcUpdate.Expiry,\n\t\t\tAcceptHeight:  uint32(htlcUpdate.AcceptHeight),\n\t\t\tAcceptTime:    now,\n\t\t\tState:         invpkg.HtlcStateAccepted,\n\t\t\tCustomRecords: htlcUpdate.CustomRecords,\n\t\t\tAMP:           htlcUpdate.AMP.Copy(),\n\t\t}\n\n\t\tinvoice.Htlcs[key] = htlc\n\n\t\t// Collect the set of new HTLCs so we can write them properly\n\t\t// below, but only if this is an AMP invoice.\n\t\tif invoiceIsAMP {\n\t\t\tupdateHtlcsAmp(\n\t\t\t\t&invoice, htlcsAmpUpdate, htlc, setID, key,\n\t\t\t)\n\t\t}\n\t}\n\n\t// Process cancel actions from update descriptor.\n\tcancelHtlcs := update.CancelHtlcs\n\tfor key, htlc := range invoice.Htlcs {\n\t\thtlc := htlc\n\n\t\t// Check whether this htlc needs to be canceled. If it does,\n\t\t// update the htlc state to Canceled.\n\t\t_, cancel := cancelHtlcs[key]\n\t\tif !cancel {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Consistency check to verify that there is no overlap between\n\t\t// the add and cancel sets.\n\t\tif _, added := update.AddHtlcs[key]; added {\n\t\t\treturn nil, fmt.Errorf(\"added htlc %v canceled\", key)\n\t\t}\n\n\t\terr := cancelSingleHtlc(now, htlc, newState)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Delete processed cancel action, so that we can check later\n\t\t// that there are no actions left.\n\t\tdelete(cancelHtlcs, key)\n\n\t\t// Tally this into the set of HTLCs that need to be updated on\n\t\t// disk, but once again, only if this is an AMP invoice.\n\t\tif invoiceIsAMP {\n\t\t\tcancelHtlcsAmp(\n\t\t\t\t&invoice, htlcsAmpUpdate, htlc, key,\n\t\t\t)\n\t\t}\n\t}\n\n\t// Verify that we didn't get an action for htlcs that are not present on\n\t// the invoice.\n\tif len(cancelHtlcs) > 0 {\n\t\treturn nil, errors.New(\"cancel action on non-existent htlc(s)\")\n\t}\n\n\t// At this point, the set of accepted HTLCs should be fully\n\t// populated with added HTLCs or removed of canceled ones. Update\n\t// invoice state if the update descriptor indicates an invoice state\n\t// change, which depends on having an accurate view of the accepted\n\t// HTLCs.\n\tif update.State != nil {\n\t\tnewState, err := updateInvoiceState(\n\t\t\t&invoice, hash, *update.State,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// If this isn't an AMP invoice, then we'll go ahead and update\n\t\t// the invoice state directly here. For AMP invoices, we\n\t\t// instead will keep the top-level invoice open, and instead\n\t\t// update the state of each _htlc set_ instead. However, we'll\n\t\t// allow the invoice to transition to the cancelled state\n\t\t// regardless.\n\t\tif !invoiceIsAMP || *newState == invpkg.ContractCanceled {\n\t\t\tinvoice.State = *newState\n\t\t}\n\n\t\t// If this is a non-AMP invoice, then the state can eventually\n\t\t// go to ContractSettled, so we pass in  nil value as part of\n\t\t// setSettleMetaFields.\n\t\tisSettled := update.State.NewState == invpkg.ContractSettled\n\t\tif !invoiceIsAMP && isSettled {\n\t\t\terr := setSettleMetaFields(\n\t\t\t\tsettleIndex, invoiceNum, &invoice, now, nil,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\t// The set of HTLC pre-images will only be set if we were actually able\n\t// to reconstruct all the AMP pre-images.\n\tvar settleEligibleAMP bool\n\tif update.State != nil {\n\t\tsettleEligibleAMP = len(update.State.HTLCPreimages) != 0\n\t}\n\n\t// With any invoice level state transitions recorded, we'll now\n\t// finalize the process by updating the state transitions for\n\t// individual HTLCs\n\tvar (\n\t\tsettledSetIDs = make(map[invpkg.SetID]struct{})\n\t\tamtPaid       lnwire.MilliSatoshi\n\t)\n\tfor key, htlc := range invoice.Htlcs {\n\t\t// Set the HTLC preimage for any AMP HTLCs.\n\t\tif setID != nil && update.State != nil {\n\t\t\tpreimage, ok := update.State.HTLCPreimages[key]\n\t\t\tswitch {\n\t\t\t// If we don't already have a preimage for this HTLC, we\n\t\t\t// can set it now.\n\t\t\tcase ok && htlc.AMP.Preimage == nil:\n\t\t\t\thtlc.AMP.Preimage = &preimage\n\n\t\t\t// Otherwise, prevent over-writing an existing\n\t\t\t// preimage.  Ignore the case where the preimage is\n\t\t\t// identical.\n\t\t\tcase ok && *htlc.AMP.Preimage != preimage:\n\t\t\t\treturn nil, invpkg.ErrHTLCPreimageAlreadyExists\n\t\t\t}\n\t\t}\n\n\t\t// The invoice state may have changed and this could have\n\t\t// implications for the states of the individual htlcs. Align\n\t\t// the htlc state with the current invoice state.\n\t\t//\n\t\t// If we have all the pre-images for an AMP invoice, then we'll\n\t\t// act as if we're able to settle the entire invoice. We need\n\t\t// to do this since it's possible for us to settle AMP invoices\n\t\t// while the contract state (on disk) is still in the accept\n\t\t// state.\n\t\thtlcContextState := invoice.State\n\t\tif settleEligibleAMP {\n\t\t\thtlcContextState = invpkg.ContractSettled\n\t\t}\n\t\thtlcSettled, err := updateHtlc(\n\t\t\tnow, htlc, htlcContextState, setID,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// If the HTLC has being settled for the first time, and this\n\t\t// is an AMP invoice, then we'll need to update some additional\n\t\t// meta data state.\n\t\tif htlcSettled && invoiceIsAMP {\n\t\t\tsettleHtlcsAmp(\n\t\t\t\t&invoice, settledSetIDs, htlcsAmpUpdate, htlc,\n\t\t\t\tkey,\n\t\t\t)\n\t\t}\n\n\t\taccepted := htlc.State == invpkg.HtlcStateAccepted\n\t\tsettled := htlc.State == invpkg.HtlcStateSettled\n\t\tinvoiceStateReady := accepted || settled\n\n\t\tif !invoiceIsAMP {\n\t\t\t// Update the running amount paid to this invoice. We\n\t\t\t// don't include accepted htlcs when the invoice is\n\t\t\t// still open.\n\t\t\tif invoice.State != invpkg.ContractOpen &&\n\t\t\t\tinvoiceStateReady {\n\n\t\t\t\tamtPaid += htlc.Amt\n\t\t\t}\n\t\t} else {\n\t\t\t// For AMP invoices, since we won't always be reading\n\t\t\t// out the total invoice set each time, we'll instead\n\t\t\t// accumulate newly added invoices to the total amount\n\t\t\t// paid.\n\t\t\tif _, ok := update.AddHtlcs[key]; !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Update the running amount paid to this invoice. AMP\n\t\t\t// invoices never go to the settled state, so if it's\n\t\t\t// open, then we tally the HTLC.\n\t\t\tif invoice.State == invpkg.ContractOpen &&\n\t\t\t\tinvoiceStateReady {\n\n\t\t\t\tamtPaid += htlc.Amt\n\t\t\t}\n\t\t}\n\t}\n\n\t// For non-AMP invoices we recalculate the amount paid from scratch\n\t// each time, while for AMP invoices, we'll accumulate only based on\n\t// newly added HTLCs.\n\tif !invoiceIsAMP {\n\t\tinvoice.AmtPaid = amtPaid\n\t} else {\n\t\tinvoice.AmtPaid += amtPaid\n\t}\n\n\t// As we don't update the settle index above for AMP invoices, we'll do\n\t// it here for each sub-AMP invoice that was settled.\n\tfor settledSetID := range settledSetIDs {\n\t\tsettledSetID := settledSetID\n\t\terr := setSettleMetaFields(\n\t\t\tsettleIndex, invoiceNum, &invoice, now, &settledSetID,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Reserialize and update invoice.\n\tvar buf bytes.Buffer\n\tif err := serializeInvoice(&buf, &invoice); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := invoices.Put(invoiceNum[:], buf.Bytes()); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// If this is an AMP invoice, then we'll actually store the rest of the\n\t// HTLCs in-line with the invoice, using the invoice ID as a prefix,\n\t// and the AMP key as a suffix: invoiceNum || setID.\n\tif invoiceIsAMP {\n\t\terr := updateAMPInvoices(invoices, invoiceNum, htlcsAmpUpdate)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn &invoice, nil\n}\n\n// updateInvoiceState validates and processes an invoice state update. The new\n// state to transition to is returned, so the caller is able to select exactly\n// how the invoice state is updated.",
      "length": 9554,
      "tokens": 1498,
      "embedding": []
    },
    {
      "slug": "func updateInvoiceState(invoice *invpkg.Invoice, hash *lntypes.Hash,",
      "content": "func updateInvoiceState(invoice *invpkg.Invoice, hash *lntypes.Hash,\n\tupdate invpkg.InvoiceStateUpdateDesc) (*invpkg.ContractState, error) {\n\n\t// Returning to open is never allowed from any state.\n\tif update.NewState == invpkg.ContractOpen {\n\t\treturn nil, invpkg.ErrInvoiceCannotOpen\n\t}\n\n\tswitch invoice.State {\n\t// Once a contract is accepted, we can only transition to settled or\n\t// canceled. Forbid transitioning back into this state. Otherwise this\n\t// state is identical to ContractOpen, so we fallthrough to apply the\n\t// same checks that we apply to open invoices.\n\tcase invpkg.ContractAccepted:\n\t\tif update.NewState == invpkg.ContractAccepted {\n\t\t\treturn nil, invpkg.ErrInvoiceCannotAccept\n\t\t}\n\n\t\tfallthrough\n\n\t// If a contract is open, permit a state transition to accepted, settled\n\t// or canceled. The only restriction is on transitioning to settled\n\t// where we ensure the preimage is valid.\n\tcase invpkg.ContractOpen:\n\t\tif update.NewState == invpkg.ContractCanceled {\n\t\t\treturn &update.NewState, nil\n\t\t}\n\n\t\t// Sanity check that the user isn't trying to settle or accept a\n\t\t// non-existent HTLC set.\n\t\tset := invoice.HTLCSet(update.SetID, invpkg.HtlcStateAccepted)\n\t\tif len(set) == 0 {\n\t\t\treturn nil, invpkg.ErrEmptyHTLCSet\n\t\t}\n\n\t\t// For AMP invoices, there are no invoice-level preimage checks.\n\t\t// However, we still sanity check that we aren't trying to\n\t\t// settle an AMP invoice with a preimage.\n\t\tif update.SetID != nil {\n\t\t\tif update.Preimage != nil {\n\t\t\t\treturn nil, errors.New(\"AMP set cannot have \" +\n\t\t\t\t\t\"preimage\")\n\t\t\t}\n\t\t\treturn &update.NewState, nil\n\t\t}\n\n\t\tswitch {\n\t\t// If an invoice-level preimage was supplied, but the InvoiceRef\n\t\t// doesn't specify a hash (e.g. AMP invoices) we fail.\n\t\tcase update.Preimage != nil && hash == nil:\n\t\t\treturn nil, invpkg.ErrUnexpectedInvoicePreimage\n\n\t\t// Validate the supplied preimage for non-AMP invoices.\n\t\tcase update.Preimage != nil:\n\t\t\tif update.Preimage.Hash() != *hash {\n\t\t\t\treturn nil, invpkg.ErrInvoicePreimageMismatch\n\t\t\t}\n\t\t\tinvoice.Terms.PaymentPreimage = update.Preimage\n\n\t\t// Permit non-AMP invoices to be accepted without knowing the\n\t\t// preimage. When trying to settle we'll have to pass through\n\t\t// the above check in order to not hit the one below.\n\t\tcase update.NewState == invpkg.ContractAccepted:\n\n\t\t// Fail if we still don't have a preimage when transitioning to\n\t\t// settle the non-AMP invoice.\n\t\tcase update.NewState == invpkg.ContractSettled &&\n\t\t\tinvoice.Terms.PaymentPreimage == nil:\n\n\t\t\treturn nil, errors.New(\"unknown preimage\")\n\t\t}\n\n\t\treturn &update.NewState, nil\n\n\t// Once settled, we are in a terminal state.\n\tcase invpkg.ContractSettled:\n\t\treturn nil, invpkg.ErrInvoiceAlreadySettled\n\n\t// Once canceled, we are in a terminal state.\n\tcase invpkg.ContractCanceled:\n\t\treturn nil, invpkg.ErrInvoiceAlreadyCanceled\n\n\tdefault:\n\t\treturn nil, errors.New(\"unknown state transition\")\n\t}\n}\n\n// cancelSingleHtlc validates cancellation of a single htlc and update its\n// state.",
      "length": 2811,
      "tokens": 385,
      "embedding": []
    },
    {
      "slug": "func cancelSingleHtlc(resolveTime time.Time, htlc *invpkg.InvoiceHTLC,",
      "content": "func cancelSingleHtlc(resolveTime time.Time, htlc *invpkg.InvoiceHTLC,\n\tinvState invpkg.ContractState) error {\n\n\t// It is only possible to cancel individual htlcs on an open invoice.\n\tif invState != invpkg.ContractOpen {\n\t\treturn fmt.Errorf(\"htlc canceled on invoice in \"+\n\t\t\t\"state %v\", invState)\n\t}\n\n\t// It is only possible if the htlc is still pending.\n\tif htlc.State != invpkg.HtlcStateAccepted {\n\t\treturn fmt.Errorf(\"htlc canceled in state %v\",\n\t\t\thtlc.State)\n\t}\n\n\thtlc.State = invpkg.HtlcStateCanceled\n\thtlc.ResolveTime = resolveTime\n\n\treturn nil\n}\n\n// updateHtlc aligns the state of an htlc with the given invoice state. A\n// boolean is returned if the HTLC was settled.",
      "length": 585,
      "tokens": 89,
      "embedding": []
    },
    {
      "slug": "func updateHtlc(resolveTime time.Time, htlc *invpkg.InvoiceHTLC,",
      "content": "func updateHtlc(resolveTime time.Time, htlc *invpkg.InvoiceHTLC,\n\tinvState invpkg.ContractState, setID *[32]byte) (bool, error) {\n\n\ttrySettle := func(persist bool) (bool, error) {\n\t\tif htlc.State != invpkg.HtlcStateAccepted {\n\t\t\treturn false, nil\n\t\t}\n\n\t\t// Settle the HTLC if it matches the settled set id. If\n\t\t// there're other HTLCs with distinct setIDs, then we'll leave\n\t\t// them, as they may eventually be settled as we permit\n\t\t// multiple settles to a single pay_addr for AMP.\n\t\tvar htlcState invpkg.HtlcState\n\t\tif htlc.IsInHTLCSet(setID) {\n\t\t\t// Non-AMP HTLCs can be settled immediately since we\n\t\t\t// already know the preimage is valid due to checks at\n\t\t\t// the invoice level. For AMP HTLCs, verify that the\n\t\t\t// per-HTLC preimage-hash pair is valid.\n\t\t\tswitch {\n\t\t\t// Non-AMP HTLCs can be settle immediately since we\n\t\t\t// already know the preimage is valid due to checks at\n\t\t\t// the invoice level.\n\t\t\tcase setID == nil:\n\n\t\t\t// At this point, the setID is non-nil, meaning this is\n\t\t\t// an AMP HTLC. We know that htlc.AMP cannot be nil,\n\t\t\t// otherwise IsInHTLCSet would have returned false.\n\t\t\t//\n\t\t\t// Fail if an accepted AMP HTLC has no preimage.\n\t\t\tcase htlc.AMP.Preimage == nil:\n\t\t\t\treturn false, invpkg.ErrHTLCPreimageMissing\n\n\t\t\t// Fail if the accepted AMP HTLC has an invalid\n\t\t\t// preimage.\n\t\t\tcase !htlc.AMP.Preimage.Matches(htlc.AMP.Hash):\n\t\t\t\treturn false, invpkg.ErrHTLCPreimageMismatch\n\t\t\t}\n\n\t\t\thtlcState = invpkg.HtlcStateSettled\n\t\t}\n\n\t\t// Only persist the changes if the invoice is moving to the\n\t\t// settled state, and we're actually updating the state to\n\t\t// settled.\n\t\tif persist && htlcState == invpkg.HtlcStateSettled {\n\t\t\thtlc.State = htlcState\n\t\t\thtlc.ResolveTime = resolveTime\n\t\t}\n\n\t\treturn persist && htlcState == invpkg.HtlcStateSettled, nil\n\t}\n\n\tif invState == invpkg.ContractSettled {\n\t\t// Check that we can settle the HTLCs. For legacy and MPP HTLCs\n\t\t// this will be a NOP, but for AMP HTLCs this asserts that we\n\t\t// have a valid hash/preimage pair. Passing true permits the\n\t\t// method to update the HTLC to HtlcStateSettled.\n\t\treturn trySettle(true)\n\t}\n\n\t// We should never find a settled HTLC on an invoice that isn't in\n\t// ContractSettled.\n\tif htlc.State == invpkg.HtlcStateSettled {\n\t\treturn false, invpkg.ErrHTLCAlreadySettled\n\t}\n\n\tswitch invState {\n\tcase invpkg.ContractCanceled:\n\t\tif htlc.State == invpkg.HtlcStateAccepted {\n\t\t\thtlc.State = invpkg.HtlcStateCanceled\n\t\t\thtlc.ResolveTime = resolveTime\n\t\t}\n\t\treturn false, nil\n\n\t// TODO(roasbeef): never fully passed thru now?\n\tcase invpkg.ContractAccepted:\n\t\t// Check that we can settle the HTLCs. For legacy and MPP HTLCs\n\t\t// this will be a NOP, but for AMP HTLCs this asserts that we\n\t\t// have a valid hash/preimage pair. Passing false prevents the\n\t\t// method from putting the HTLC in HtlcStateSettled, leaving it\n\t\t// in HtlcStateAccepted.\n\t\treturn trySettle(false)\n\n\tcase invpkg.ContractOpen:\n\t\treturn false, nil\n\n\tdefault:\n\t\treturn false, errors.New(\"unknown state transition\")\n\t}\n}\n\n// setSettleMetaFields updates the metadata associated with settlement of an\n// invoice. If a non-nil setID is passed in, then the value will be append to\n// the invoice number as well, in order to allow us to detect repeated payments\n// to the same AMP invoices \"across time\".",
      "length": 3113,
      "tokens": 473,
      "embedding": []
    },
    {
      "slug": "func setSettleMetaFields(settleIndex kvdb.RwBucket, invoiceNum []byte,",
      "content": "func setSettleMetaFields(settleIndex kvdb.RwBucket, invoiceNum []byte,\n\tinvoice *invpkg.Invoice, now time.Time, setID *invpkg.SetID) error {\n\n\t// Now that we know the invoice hasn't already been settled, we'll\n\t// update the settle index so we can place this settle event in the\n\t// proper location within our time series.\n\tnextSettleSeqNo, err := settleIndex.NextSequence()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Make a new byte array on the stack that can potentially store the 4\n\t// byte invoice number along w/ the 32 byte set ID. We capture valueLen\n\t// here which is the number of bytes copied so we can only store the 4\n\t// bytes if this is a non-AMP invoice.\n\tvar indexKey [invoiceSetIDKeyLen]byte\n\tvalueLen := copy(indexKey[:], invoiceNum)\n\n\tif setID != nil {\n\t\tvalueLen += copy(indexKey[valueLen:], setID[:])\n\t}\n\n\tvar seqNoBytes [8]byte\n\tbyteOrder.PutUint64(seqNoBytes[:], nextSettleSeqNo)\n\terr = settleIndex.Put(seqNoBytes[:], indexKey[:valueLen])\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// If the setID is nil, then this means that this is a non-AMP settle,\n\t// so we'll update the invoice settle index directly.\n\tif setID == nil {\n\t\tinvoice.SettleDate = now\n\t\tinvoice.SettleIndex = nextSettleSeqNo\n\t} else {\n\t\t// If the set ID isn't blank, we'll update the AMP state map\n\t\t// which tracks when each of the setIDs associated with a given\n\t\t// AMP invoice are settled.\n\t\tampState := invoice.AMPState[*setID]\n\n\t\tampState.SettleDate = now\n\t\tampState.SettleIndex = nextSettleSeqNo\n\n\t\tinvoice.AMPState[*setID] = ampState\n\t}\n\n\treturn nil\n}\n\n// delAMPInvoices attempts to delete all the \"sub\" invoices associated with a\n// greater AMP invoices. We do this by deleting the set of keys that share the\n// invoice number as a prefix.",
      "length": 1607,
      "tokens": 258,
      "embedding": []
    },
    {
      "slug": "func delAMPInvoices(invoiceNum []byte, invoiceBucket kvdb.RwBucket) error {",
      "content": "func delAMPInvoices(invoiceNum []byte, invoiceBucket kvdb.RwBucket) error {\n\t// Since it isn't safe to delete using an active cursor, we'll use the\n\t// cursor simply to collect the set of keys we need to delete, _then_\n\t// delete them in another pass.\n\tvar keysToDel [][]byte\n\terr := forEachAMPInvoice(\n\t\tinvoiceBucket, invoiceNum,\n\t\tfunc(cursorKey, v []byte) error {\n\t\t\tkeysToDel = append(keysToDel, cursorKey)\n\t\t\treturn nil\n\t\t},\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// In this next phase, we'll then delete all the relevant invoices.\n\tfor _, keyToDel := range keysToDel {\n\t\tif err := invoiceBucket.Delete(keyToDel); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// delAMPSettleIndex removes all the entries in the settle index associated\n// with a given AMP invoice.",
      "length": 671,
      "tokens": 114,
      "embedding": []
    },
    {
      "slug": "func delAMPSettleIndex(invoiceNum []byte, invoices,",
      "content": "func delAMPSettleIndex(invoiceNum []byte, invoices,\n\tsettleIndex kvdb.RwBucket) error {\n\n\t// First, we need to grab the AMP invoice state to see if there's\n\t// anything that we even need to delete.\n\tampState, err := fetchInvoiceStateAMP(invoiceNum, invoices)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// If there's no AMP state at all (non-AMP invoice), then we can return\n\t// early.\n\tif len(ampState) == 0 {\n\t\treturn nil\n\t}\n\n\t// Otherwise, we'll need to iterate and delete each settle index within\n\t// the set of returned entries.\n\tvar settleIndexKey [8]byte\n\tfor _, subState := range ampState {\n\t\tbyteOrder.PutUint64(\n\t\t\tsettleIndexKey[:], subState.SettleIndex,\n\t\t)\n\n\t\tif err := settleIndex.Delete(settleIndexKey[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// DeleteInvoice attempts to delete the passed invoices from the database in\n// one transaction. The passed delete references hold all keys required to\n// delete the invoices without also needing to deserialze them.",
      "length": 893,
      "tokens": 144,
      "embedding": []
    },
    {
      "slug": "func (d *DB) DeleteInvoice(invoicesToDelete []invpkg.InvoiceDeleteRef) error {",
      "content": "func (d *DB) DeleteInvoice(invoicesToDelete []invpkg.InvoiceDeleteRef) error {\n\terr := kvdb.Update(d, func(tx kvdb.RwTx) error {\n\t\tinvoices := tx.ReadWriteBucket(invoiceBucket)\n\t\tif invoices == nil {\n\t\t\treturn invpkg.ErrNoInvoicesCreated\n\t\t}\n\n\t\tinvoiceIndex := invoices.NestedReadWriteBucket(\n\t\t\tinvoiceIndexBucket,\n\t\t)\n\t\tif invoiceIndex == nil {\n\t\t\treturn invpkg.ErrNoInvoicesCreated\n\t\t}\n\n\t\tinvoiceAddIndex := invoices.NestedReadWriteBucket(\n\t\t\taddIndexBucket,\n\t\t)\n\t\tif invoiceAddIndex == nil {\n\t\t\treturn invpkg.ErrNoInvoicesCreated\n\t\t}\n\n\t\t// settleIndex can be nil, as the bucket is created lazily\n\t\t// when the first invoice is settled.\n\t\tsettleIndex := invoices.NestedReadWriteBucket(settleIndexBucket)\n\n\t\tpayAddrIndex := tx.ReadWriteBucket(payAddrIndexBucket)\n\n\t\tfor _, ref := range invoicesToDelete {\n\t\t\t// Fetch the invoice key for using it to check for\n\t\t\t// consistency and also to delete from the invoice\n\t\t\t// index.\n\t\t\tinvoiceKey := invoiceIndex.Get(ref.PayHash[:])\n\t\t\tif invoiceKey == nil {\n\t\t\t\treturn invpkg.ErrInvoiceNotFound\n\t\t\t}\n\n\t\t\terr := invoiceIndex.Delete(ref.PayHash[:])\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Delete payment address index reference if there's a\n\t\t\t// valid payment address passed.\n\t\t\tif ref.PayAddr != nil {\n\t\t\t\t// To ensure consistency check that the already\n\t\t\t\t// fetched invoice key matches the one in the\n\t\t\t\t// payment address index.\n\t\t\t\tkey := payAddrIndex.Get(ref.PayAddr[:])\n\t\t\t\tif bytes.Equal(key, invoiceKey) {\n\t\t\t\t\t// Delete from the payment address\n\t\t\t\t\t// index. Note that since the payment\n\t\t\t\t\t// address index has been introduced\n\t\t\t\t\t// with an empty migration it may be\n\t\t\t\t\t// possible that the index doesn't have\n\t\t\t\t\t// an entry for this invoice.\n\t\t\t\t\t// ref: https://github.com/lightningnetwork/lnd/pull/4285/commits/cbf71b5452fa1d3036a43309e490787c5f7f08dc#r426368127\n\t\t\t\t\tif err := payAddrIndex.Delete(\n\t\t\t\t\t\tref.PayAddr[:],\n\t\t\t\t\t); err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar addIndexKey [8]byte\n\t\t\tbyteOrder.PutUint64(addIndexKey[:], ref.AddIndex)\n\n\t\t\t// To ensure consistency check that the key stored in\n\t\t\t// the add index also matches the previously fetched\n\t\t\t// invoice key.\n\t\t\tkey := invoiceAddIndex.Get(addIndexKey[:])\n\t\t\tif !bytes.Equal(key, invoiceKey) {\n\t\t\t\treturn fmt.Errorf(\"unknown invoice \" +\n\t\t\t\t\t\"in add index\")\n\t\t\t}\n\n\t\t\t// Remove from the add index.\n\t\t\terr = invoiceAddIndex.Delete(addIndexKey[:])\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Remove from the settle index if available and\n\t\t\t// if the invoice is settled.\n\t\t\tif settleIndex != nil && ref.SettleIndex > 0 {\n\t\t\t\tvar settleIndexKey [8]byte\n\t\t\t\tbyteOrder.PutUint64(\n\t\t\t\t\tsettleIndexKey[:], ref.SettleIndex,\n\t\t\t\t)\n\n\t\t\t\t// To ensure consistency check that the already\n\t\t\t\t// fetched invoice key matches the one in the\n\t\t\t\t// settle index\n\t\t\t\tkey := settleIndex.Get(settleIndexKey[:])\n\t\t\t\tif !bytes.Equal(key, invoiceKey) {\n\t\t\t\t\treturn fmt.Errorf(\"unknown invoice \" +\n\t\t\t\t\t\t\"in settle index\")\n\t\t\t\t}\n\n\t\t\t\terr = settleIndex.Delete(settleIndexKey[:])\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// In addition to deleting the main invoice state, if\n\t\t\t// this is an AMP invoice, then we'll also need to\n\t\t\t// delete the set HTLC set stored as a key prefix. For\n\t\t\t// non-AMP invoices, this'll be a noop.\n\t\t\terr = delAMPSettleIndex(\n\t\t\t\tinvoiceKey, invoices, settleIndex,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\terr = delAMPInvoices(invoiceKey, invoices)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Finally remove the serialized invoice from the\n\t\t\t// invoice bucket.\n\t\t\terr = invoices.Delete(invoiceKey)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}, func() {})\n\n\treturn err\n}\n",
      "length": 3456,
      "tokens": 461,
      "embedding": []
    }
  ]
}