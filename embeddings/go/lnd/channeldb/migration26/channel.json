{
  "filepath": "../implementations/go/lnd/channeldb/migration26/channel.go",
  "package": "migration26",
  "sections": [
    {
      "slug": "type OpenChannel struct {",
      "content": "type OpenChannel struct {\n\tmig25.OpenChannel\n}\n\n// FetchChanInfo deserializes the channel info based on the legacy boolean.\n// After migration25, the legacy format would have the fields\n// `InitialLocalBalance` and `InitialRemoteBalance` directly encoded as bytes.\n// For the new format, they will be put inside a tlv stream.",
      "length": 293,
      "tokens": 44,
      "embedding": []
    },
    {
      "slug": "func FetchChanInfo(chanBucket kvdb.RBucket, c *OpenChannel, legacy bool) error {",
      "content": "func FetchChanInfo(chanBucket kvdb.RBucket, c *OpenChannel, legacy bool) error {\n\tinfoBytes := chanBucket.Get(chanInfoKey)\n\tif infoBytes == nil {\n\t\treturn ErrNoChanInfoFound\n\t}\n\tr := bytes.NewReader(infoBytes)\n\n\tvar (\n\t\tchanType   mig.ChannelType\n\t\tchanStatus mig.ChannelStatus\n\t)\n\n\tif err := mig.ReadElements(r,\n\t\t&chanType, &c.ChainHash, &c.FundingOutpoint,\n\t\t&c.ShortChannelID, &c.IsPending, &c.IsInitiator,\n\t\t&chanStatus, &c.FundingBroadcastHeight,\n\t\t&c.NumConfsRequired, &c.ChannelFlags,\n\t\t&c.IdentityPub, &c.Capacity, &c.TotalMSatSent,\n\t\t&c.TotalMSatReceived,\n\t); err != nil {\n\t\treturn err\n\t}\n\n\tc.ChanType = mig25.ChannelType(chanType)\n\tc.ChanStatus = mig25.ChannelStatus(chanStatus)\n\n\t// If this is the legacy format, we need to read the extra two new\n\t// fields.\n\tif legacy {\n\t\tif err := mig.ReadElements(r,\n\t\t\t&c.InitialLocalBalance, &c.InitialRemoteBalance,\n\t\t); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// For single funder channels that we initiated and have the funding\n\t// transaction to, read the funding txn.\n\tif c.FundingTxPresent() {\n\t\tif err := mig.ReadElement(r, &c.FundingTxn); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := mig.ReadChanConfig(r, &c.LocalChanCfg); err != nil {\n\t\treturn err\n\t}\n\tif err := mig.ReadChanConfig(r, &c.RemoteChanCfg); err != nil {\n\t\treturn err\n\t}\n\n\t// Retrieve the boolean stored under lastWasRevokeKey.\n\tlastWasRevokeBytes := chanBucket.Get(lastWasRevokeKey)\n\tif lastWasRevokeBytes == nil {\n\t\t// If nothing has been stored under this key, we store false in\n\t\t// the OpenChannel struct.\n\t\tc.LastWasRevoke = false\n\t} else {\n\t\t// Otherwise, read the value into the LastWasRevoke field.\n\t\trevokeReader := bytes.NewReader(lastWasRevokeBytes)\n\t\terr := mig.ReadElements(revokeReader, &c.LastWasRevoke)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Make the tlv stream based on the legacy param.\n\tvar (\n\t\tts            *tlv.Stream\n\t\terr           error\n\t\tlocalBalance  uint64\n\t\tremoteBalance uint64\n\t)\n\n\tkeyLocRecord := mig25.MakeKeyLocRecord(\n\t\tkeyLocType, &c.RevocationKeyLocator,\n\t)\n\n\t// If it's legacy, create the stream with a single tlv record.\n\tif legacy {\n\t\tts, err = tlv.NewStream(keyLocRecord)\n\t} else {\n\t\t// Otherwise, for the new format, we will encode the balance\n\t\t// fields in the tlv stream too.\n\t\tts, err = tlv.NewStream(\n\t\t\tkeyLocRecord,\n\t\t\ttlv.MakePrimitiveRecord(\n\t\t\t\tinitialLocalBalanceType, &localBalance,\n\t\t\t),\n\t\t\ttlv.MakePrimitiveRecord(\n\t\t\t\tinitialRemoteBalanceType, &remoteBalance,\n\t\t\t),\n\t\t)\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := ts.Decode(r); err != nil {\n\t\treturn err\n\t}\n\n\t// For the new format, attach the balance fields.\n\tif !legacy {\n\t\tc.InitialLocalBalance = lnwire.MilliSatoshi(localBalance)\n\t\tc.InitialRemoteBalance = lnwire.MilliSatoshi(remoteBalance)\n\t}\n\n\t// Finally, read the optional shutdown scripts.\n\tif err := mig25.GetOptionalUpfrontShutdownScript(\n\t\tchanBucket, localUpfrontShutdownKey, &c.LocalShutdownScript,\n\t); err != nil {\n\t\treturn err\n\t}\n\n\treturn mig25.GetOptionalUpfrontShutdownScript(\n\t\tchanBucket, remoteUpfrontShutdownKey, &c.RemoteShutdownScript,\n\t)\n}\n\n// MakeTlvStream creates a tlv stream based on whether we are deadling with\n// legacy format or not. For the legacy format, we have a single record in the\n// stream. For the new format, we have the extra balance records.",
      "length": 3069,
      "tokens": 400,
      "embedding": []
    },
    {
      "slug": "func MakeTlvStream(c *OpenChannel, legacy bool) (*tlv.Stream, error) {",
      "content": "func MakeTlvStream(c *OpenChannel, legacy bool) (*tlv.Stream, error) {\n\tkeyLocRecord := mig25.MakeKeyLocRecord(\n\t\tkeyLocType, &c.RevocationKeyLocator,\n\t)\n\n\t// If it's legacy, return the stream with a single tlv record.\n\tif legacy {\n\t\treturn tlv.NewStream(keyLocRecord)\n\t}\n\n\t// Otherwise, for the new format, we will encode the balance fields in\n\t// the tlv stream too.\n\tlocalBalance := uint64(c.InitialLocalBalance)\n\tremoteBalance := uint64(c.InitialRemoteBalance)\n\n\t// Create the tlv stream.\n\treturn tlv.NewStream(\n\t\tkeyLocRecord,\n\t\ttlv.MakePrimitiveRecord(\n\t\t\tinitialLocalBalanceType, &localBalance,\n\t\t),\n\t\ttlv.MakePrimitiveRecord(\n\t\t\tinitialRemoteBalanceType, &remoteBalance,\n\t\t),\n\t)\n}\n\n// PutChanInfo serializes the channel info based on the legacy boolean. After\n// migration25, the legacy format would have the fields `InitialLocalBalance`\n// and `InitialRemoteBalance` directly encoded as bytes. For the new format,\n// they will be put inside a tlv stream.",
      "length": 863,
      "tokens": 108,
      "embedding": []
    },
    {
      "slug": "func PutChanInfo(chanBucket kvdb.RwBucket, c *OpenChannel, legacy bool) error {",
      "content": "func PutChanInfo(chanBucket kvdb.RwBucket, c *OpenChannel, legacy bool) error {\n\tvar w bytes.Buffer\n\tif err := mig.WriteElements(&w,\n\t\tmig.ChannelType(c.ChanType), c.ChainHash, c.FundingOutpoint,\n\t\tc.ShortChannelID, c.IsPending, c.IsInitiator,\n\t\tmig.ChannelStatus(c.ChanStatus), c.FundingBroadcastHeight,\n\t\tc.NumConfsRequired, c.ChannelFlags,\n\t\tc.IdentityPub, c.Capacity, c.TotalMSatSent,\n\t\tc.TotalMSatReceived,\n\t); err != nil {\n\t\treturn err\n\t}\n\n\t// If this is legacy format, we need to write the extra two fields.\n\tif legacy {\n\t\tif err := mig.WriteElements(&w,\n\t\t\tc.InitialLocalBalance, c.InitialRemoteBalance,\n\t\t); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// For single funder channels that we initiated, and we have the\n\t// funding transaction, then write the funding txn.\n\tif c.FundingTxPresent() {\n\t\tif err := mig.WriteElement(&w, c.FundingTxn); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := mig.WriteChanConfig(&w, &c.LocalChanCfg); err != nil {\n\t\treturn err\n\t}\n\tif err := mig.WriteChanConfig(&w, &c.RemoteChanCfg); err != nil {\n\t\treturn err\n\t}\n\n\t// Make the tlv stream based on the legacy param.\n\ttlvStream, err := MakeTlvStream(c, legacy)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := tlvStream.Encode(&w); err != nil {\n\t\treturn err\n\t}\n\n\tif err := chanBucket.Put(chanInfoKey, w.Bytes()); err != nil {\n\t\treturn err\n\t}\n\n\t// Finally, add optional shutdown scripts for the local and remote peer\n\t// if they are present.\n\tif err := mig25.PutOptionalUpfrontShutdownScript(\n\t\tchanBucket, localUpfrontShutdownKey, c.LocalShutdownScript,\n\t); err != nil {\n\t\treturn err\n\t}\n\n\treturn mig25.PutOptionalUpfrontShutdownScript(\n\t\tchanBucket, remoteUpfrontShutdownKey, c.RemoteShutdownScript,\n\t)\n}\n",
      "length": 1540,
      "tokens": 206,
      "embedding": []
    }
  ]
}