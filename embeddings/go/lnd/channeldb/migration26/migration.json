{
  "filepath": "../implementations/go/lnd/channeldb/migration26/migration.go",
  "package": "migration26",
  "sections": [
    {
      "slug": "func MigrateBalancesToTlvRecords(tx kvdb.RwTx) error {",
      "content": "func MigrateBalancesToTlvRecords(tx kvdb.RwTx) error {\n\tlog.Infof(\"Migrating local and remote balances into tlv records...\")\n\n\topenChanBucket := tx.ReadWriteBucket(openChannelBucket)\n\n\t// If no bucket is found, we can exit early.\n\tif openChanBucket == nil {\n\t\treturn nil\n\t}\n\n\t// Read a list of open channels.\n\tchannels, err := findOpenChannels(openChanBucket)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Migrate the balances.\n\tfor _, c := range channels {\n\t\tif err := migrateBalances(tx, c); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn err\n}\n\n// findOpenChannels finds all open channels.",
      "length": 500,
      "tokens": 81,
      "embedding": []
    },
    {
      "slug": "func findOpenChannels(openChanBucket kvdb.RBucket) ([]*OpenChannel, error) {",
      "content": "func findOpenChannels(openChanBucket kvdb.RBucket) ([]*OpenChannel, error) {\n\tchannels := []*OpenChannel{}\n\n\t// readChannel is a helper closure that reads the channel info from the\n\t// channel bucket.\n\treadChannel := func(chainBucket kvdb.RBucket, cp []byte) error {\n\t\tc := &OpenChannel{}\n\n\t\t// Read the sub-bucket level 3.\n\t\tchanBucket := chainBucket.NestedReadBucket(\n\t\t\tcp,\n\t\t)\n\t\tif chanBucket == nil {\n\t\t\tlog.Errorf(\"unable to read bucket for chanPoint=%x\", cp)\n\t\t\treturn nil\n\t\t}\n\n\t\t// Get the old channel info.\n\t\tif err := FetchChanInfo(chanBucket, c, true); err != nil {\n\t\t\treturn fmt.Errorf(\"unable to fetch chan info: %v\", err)\n\t\t}\n\n\t\tchannels = append(channels, c)\n\n\t\treturn nil\n\t}\n\n\t// Iterate the root bucket.\n\terr := openChanBucket.ForEach(func(nodePub, v []byte) error {\n\t\t// Ensure that this is a key the same size as a pubkey, and\n\t\t// also that it leads directly to a bucket.\n\t\tif len(nodePub) != 33 || v != nil {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Read the sub-bucket level 1.\n\t\tnodeChanBucket := openChanBucket.NestedReadBucket(nodePub)\n\t\tif nodeChanBucket == nil {\n\t\t\tlog.Errorf(\"no bucket for node %x\", nodePub)\n\t\t\treturn nil\n\t\t}\n\n\t\t// Iterate the bucket.\n\t\treturn nodeChanBucket.ForEach(func(chainHash, _ []byte) error {\n\t\t\t// Read the sub-bucket level 2.\n\t\t\tchainBucket := nodeChanBucket.NestedReadBucket(\n\t\t\t\tchainHash,\n\t\t\t)\n\t\t\tif chainBucket == nil {\n\t\t\t\tlog.Errorf(\"unable to read bucket for chain=%x\",\n\t\t\t\t\tchainHash)\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Iterate the bucket.\n\t\t\treturn chainBucket.ForEach(func(cp, _ []byte) error {\n\t\t\t\treturn readChannel(chainBucket, cp)\n\t\t\t})\n\t\t})\n\t})\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn channels, nil\n}\n\n// migrateBalances creates a new tlv stream which adds two more records to hold\n// the balances info.",
      "length": 1613,
      "tokens": 241,
      "embedding": []
    },
    {
      "slug": "func migrateBalances(tx kvdb.RwTx, c *OpenChannel) error {",
      "content": "func migrateBalances(tx kvdb.RwTx, c *OpenChannel) error {\n\t// Get the bucket.\n\tchanBucket, err := mig25.FetchChanBucket(tx, &c.OpenChannel)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Update the channel info. There isn't much to do here as the\n\t// `PutChanInfo` will read the values from `c.InitialLocalBalance` and\n\t// `c.InitialRemoteBalance` then create the new tlv stream as\n\t// requested.\n\tif err := PutChanInfo(chanBucket, c, false); err != nil {\n\t\treturn fmt.Errorf(\"unable to put chan info: %v\", err)\n\t}\n\n\treturn nil\n}\n",
      "length": 447,
      "tokens": 72,
      "embedding": []
    }
  ]
}