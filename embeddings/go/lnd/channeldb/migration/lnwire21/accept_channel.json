{
  "filepath": "../implementations/go/lnd/channeldb/migration/lnwire21/accept_channel.go",
  "package": "lnwire",
  "sections": [
    {
      "slug": "type AcceptChannel struct {",
      "content": "type AcceptChannel struct {\n\t// PendingChannelID serves to uniquely identify the future channel\n\t// created by the initiated single funder workflow.\n\tPendingChannelID [32]byte\n\n\t// DustLimit is the specific dust limit the sender of this message\n\t// would like enforced on their version of the commitment transaction.\n\t// Any output below this value will be \"trimmed\" from the commitment\n\t// transaction, with the amount of the HTLC going to dust.\n\tDustLimit btcutil.Amount\n\n\t// MaxValueInFlight represents the maximum amount of coins that can be\n\t// pending within the channel at any given time. If the amount of funds\n\t// in limbo exceeds this amount, then the channel will be failed.\n\tMaxValueInFlight MilliSatoshi\n\n\t// ChannelReserve is the amount of BTC that the receiving party MUST\n\t// maintain a balance above at all times. This is a safety mechanism to\n\t// ensure that both sides always have skin in the game during the\n\t// channel's lifetime.\n\tChannelReserve btcutil.Amount\n\n\t// HtlcMinimum is the smallest HTLC that the sender of this message\n\t// will accept.\n\tHtlcMinimum MilliSatoshi\n\n\t// MinAcceptDepth is the minimum depth that the initiator of the\n\t// channel should wait before considering the channel open.\n\tMinAcceptDepth uint32\n\n\t// CsvDelay is the number of blocks to use for the relative time lock\n\t// in the pay-to-self output of both commitment transactions.\n\tCsvDelay uint16\n\n\t// MaxAcceptedHTLCs is the total number of incoming HTLC's that the\n\t// sender of this channel will accept.\n\t//\n\t// TODO(roasbeef): acks the initiator's, same with max in flight?\n\tMaxAcceptedHTLCs uint16\n\n\t// FundingKey is the key that should be used on behalf of the sender\n\t// within the 2-of-2 multi-sig output that it contained within the\n\t// funding transaction.\n\tFundingKey *btcec.PublicKey\n\n\t// RevocationPoint is the base revocation point for the sending party.\n\t// Any commitment transaction belonging to the receiver of this message\n\t// should use this key and their per-commitment point to derive the\n\t// revocation key for the commitment transaction.\n\tRevocationPoint *btcec.PublicKey\n\n\t// PaymentPoint is the base payment point for the sending party. This\n\t// key should be combined with the per commitment point for a\n\t// particular commitment state in order to create the key that should\n\t// be used in any output that pays directly to the sending party, and\n\t// also within the HTLC covenant transactions.\n\tPaymentPoint *btcec.PublicKey\n\n\t// DelayedPaymentPoint is the delay point for the sending party. This\n\t// key should be combined with the per commitment point to derive the\n\t// keys that are used in outputs of the sender's commitment transaction\n\t// where they claim funds.\n\tDelayedPaymentPoint *btcec.PublicKey\n\n\t// HtlcPoint is the base point used to derive the set of keys for this\n\t// party that will be used within the HTLC public key scripts.  This\n\t// value is combined with the receiver's revocation base point in order\n\t// to derive the keys that are used within HTLC scripts.\n\tHtlcPoint *btcec.PublicKey\n\n\t// FirstCommitmentPoint is the first commitment point for the sending\n\t// party. This value should be combined with the receiver's revocation\n\t// base point in order to derive the revocation keys that are placed\n\t// within the commitment transaction of the sender.\n\tFirstCommitmentPoint *btcec.PublicKey\n\n\t// UpfrontShutdownScript is the script to which the channel funds should\n\t// be paid when mutually closing the channel. This field is optional, and\n\t// and has a length prefix, so a zero will be written if it is not set\n\t// and its length followed by the script will be written if it is set.\n\tUpfrontShutdownScript DeliveryAddress\n}\n\n// A compile time check to ensure AcceptChannel implements the lnwire.Message\n// interface.\nvar _ Message = (*AcceptChannel)(nil)\n\n// Encode serializes the target AcceptChannel into the passed io.Writer\n// implementation. Serialization will observe the rules defined by the passed\n// protocol version.\n//\n// This is part of the lnwire.Message interface.",
      "length": 3915,
      "tokens": 627,
      "embedding": []
    },
    {
      "slug": "func (a *AcceptChannel) Encode(w io.Writer, pver uint32) error {",
      "content": "func (a *AcceptChannel) Encode(w io.Writer, pver uint32) error {\n\treturn WriteElements(w,\n\t\ta.PendingChannelID[:],\n\t\ta.DustLimit,\n\t\ta.MaxValueInFlight,\n\t\ta.ChannelReserve,\n\t\ta.HtlcMinimum,\n\t\ta.MinAcceptDepth,\n\t\ta.CsvDelay,\n\t\ta.MaxAcceptedHTLCs,\n\t\ta.FundingKey,\n\t\ta.RevocationPoint,\n\t\ta.PaymentPoint,\n\t\ta.DelayedPaymentPoint,\n\t\ta.HtlcPoint,\n\t\ta.FirstCommitmentPoint,\n\t\ta.UpfrontShutdownScript,\n\t)\n}\n\n// Decode deserializes the serialized AcceptChannel stored in the passed\n// io.Reader into the target AcceptChannel using the deserialization rules\n// defined by the passed protocol version.\n//\n// This is part of the lnwire.Message interface.",
      "length": 553,
      "tokens": 55,
      "embedding": []
    },
    {
      "slug": "func (a *AcceptChannel) Decode(r io.Reader, pver uint32) error {",
      "content": "func (a *AcceptChannel) Decode(r io.Reader, pver uint32) error {\n\t// Read all the mandatory fields in the accept message.\n\terr := ReadElements(r,\n\t\ta.PendingChannelID[:],\n\t\t&a.DustLimit,\n\t\t&a.MaxValueInFlight,\n\t\t&a.ChannelReserve,\n\t\t&a.HtlcMinimum,\n\t\t&a.MinAcceptDepth,\n\t\t&a.CsvDelay,\n\t\t&a.MaxAcceptedHTLCs,\n\t\t&a.FundingKey,\n\t\t&a.RevocationPoint,\n\t\t&a.PaymentPoint,\n\t\t&a.DelayedPaymentPoint,\n\t\t&a.HtlcPoint,\n\t\t&a.FirstCommitmentPoint,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check for the optional upfront shutdown script field. If it is not there,\n\t// silence the EOF error.\n\terr = ReadElement(r, &a.UpfrontShutdownScript)\n\tif err != nil && err != io.EOF {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// MsgType returns the MessageType code which uniquely identifies this message\n// as an AcceptChannel on the wire.\n//\n// This is part of the lnwire.Message interface.",
      "length": 758,
      "tokens": 101,
      "embedding": []
    },
    {
      "slug": "func (a *AcceptChannel) MsgType() MessageType {",
      "content": "func (a *AcceptChannel) MsgType() MessageType {\n\treturn MsgAcceptChannel\n}\n\n// MaxPayloadLength returns the maximum allowed payload length for a\n// AcceptChannel message.\n//\n// This is part of the lnwire.Message interface.",
      "length": 168,
      "tokens": 25,
      "embedding": []
    },
    {
      "slug": "func (a *AcceptChannel) MaxPayloadLength(uint32) uint32 {",
      "content": "func (a *AcceptChannel) MaxPayloadLength(uint32) uint32 {\n\t// 32 + (8 * 4) + (4 * 1) + (2 * 2) + (33 * 6)\n\tvar length uint32 = 270 // base length\n\n\t// Upfront shutdown script max length.\n\tlength += 2 + deliveryAddressMaxSize\n\n\treturn length\n}\n",
      "length": 177,
      "tokens": 40,
      "embedding": []
    }
  ]
}