{
  "filepath": "../implementations/go/lnd/channeldb/migration/lnwire21/error.go",
  "package": "lnwire",
  "sections": [
    {
      "slug": "type FundingError uint8",
      "content": "type FundingError uint8\n\nconst (\n\t// ErrMaxPendingChannels is returned by remote peer when the number of\n\t// active pending channels exceeds their maximum policy limit.\n\tErrMaxPendingChannels FundingError = 1\n\n\t// ErrSynchronizingChain is returned by a remote peer that receives a\n\t// channel update or a funding request while it's still syncing to the\n\t// latest state of the blockchain.\n\tErrSynchronizingChain FundingError = 2\n\n\t// ErrChanTooLarge is returned by a remote peer that receives a\n\t// FundingOpen request for a channel that is above their current\n\t// soft-limit.\n\tErrChanTooLarge FundingError = 3\n)\n\n// String returns a human readable version of the target FundingError.",
      "length": 643,
      "tokens": 100,
      "embedding": []
    },
    {
      "slug": "func (e FundingError) String() string {",
      "content": "func (e FundingError) String() string {\n\tswitch e {\n\tcase ErrMaxPendingChannels:\n\t\treturn \"Number of pending channels exceed maximum\"\n\tcase ErrSynchronizingChain:\n\t\treturn \"Synchronizing blockchain\"\n\tcase ErrChanTooLarge:\n\t\treturn \"channel too large\"\n\tdefault:\n\t\treturn \"unknown error\"\n\t}\n}\n\n// Error returns the human readable version of the target FundingError.\n//\n// NOTE: Satisfies the Error interface.",
      "length": 352,
      "tokens": 47,
      "embedding": []
    },
    {
      "slug": "func (e FundingError) Error() string {",
      "content": "func (e FundingError) Error() string {\n\treturn e.String()\n}\n\n// ErrorData is a set of bytes associated with a particular sent error. A\n// receiving node SHOULD only print out data verbatim if the string is composed\n// solely of printable ASCII characters. For reference, the printable character\n// set includes byte values 32 through 127 inclusive.",
      "length": 303,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "type ErrorData []byte",
      "content": "type ErrorData []byte\n\n// Error represents a generic error bound to an exact channel. The message\n// format is purposefully general in order to allow expression of a wide array\n// of possible errors. Each Error message is directed at a particular open\n// channel referenced by ChannelPoint.",
      "length": 264,
      "tokens": 45,
      "embedding": []
    },
    {
      "slug": "type Error struct {",
      "content": "type Error struct {\n\t// ChanID references the active channel in which the error occurred\n\t// within. If the ChanID is all zeros, then this error applies to the\n\t// entire established connection.\n\tChanID ChannelID\n\n\t// Data is the attached error data that describes the exact failure\n\t// which caused the error message to be sent.\n\tData ErrorData\n}\n\n// NewError creates a new Error message.",
      "length": 359,
      "tokens": 62,
      "embedding": []
    },
    {
      "slug": "func NewError() *Error {",
      "content": "func NewError() *Error {\n\treturn &Error{}\n}\n\n// A compile time check to ensure Error implements the lnwire.Message\n// interface.\nvar _ Message = (*Error)(nil)\n\n// Error returns the string representation to Error.\n//\n// NOTE: Satisfies the error interface.",
      "length": 221,
      "tokens": 36,
      "embedding": []
    },
    {
      "slug": "func (c *Error) Error() string {",
      "content": "func (c *Error) Error() string {\n\terrMsg := \"non-ascii data\"\n\tif isASCII(c.Data) {\n\t\terrMsg = string(c.Data)\n\t}\n\n\treturn fmt.Sprintf(\"chan_id=%v, err=%v\", c.ChanID, errMsg)\n}\n\n// Decode deserializes a serialized Error message stored in the passed\n// io.Reader observing the specified protocol version.\n//\n// This is part of the lnwire.Message interface.",
      "length": 309,
      "tokens": 44,
      "embedding": []
    },
    {
      "slug": "func (c *Error) Decode(r io.Reader, pver uint32) error {",
      "content": "func (c *Error) Decode(r io.Reader, pver uint32) error {\n\treturn ReadElements(r,\n\t\t&c.ChanID,\n\t\t&c.Data,\n\t)\n}\n\n// Encode serializes the target Error into the passed io.Writer observing the\n// protocol version specified.\n//\n// This is part of the lnwire.Message interface.",
      "length": 205,
      "tokens": 31,
      "embedding": []
    },
    {
      "slug": "func (c *Error) Encode(w io.Writer, pver uint32) error {",
      "content": "func (c *Error) Encode(w io.Writer, pver uint32) error {\n\treturn WriteElements(w,\n\t\tc.ChanID,\n\t\tc.Data,\n\t)\n}\n\n// MsgType returns the integer uniquely identifying an Error message on the\n// wire.\n//\n// This is part of the lnwire.Message interface.",
      "length": 180,
      "tokens": 29,
      "embedding": []
    },
    {
      "slug": "func (c *Error) MsgType() MessageType {",
      "content": "func (c *Error) MsgType() MessageType {\n\treturn MsgError\n}\n\n// MaxPayloadLength returns the maximum allowed payload size for an Error\n// complete message observing the specified protocol version.\n//\n// This is part of the lnwire.Message interface.",
      "length": 201,
      "tokens": 31,
      "embedding": []
    },
    {
      "slug": "func (c *Error) MaxPayloadLength(uint32) uint32 {",
      "content": "func (c *Error) MaxPayloadLength(uint32) uint32 {\n\t// 32 + 2 + 65501\n\treturn MaxMessagePayload\n}\n\n// isASCII is a helper method that checks whether all bytes in `data` would be\n// printable ASCII characters if interpreted as a string.",
      "length": 179,
      "tokens": 33,
      "embedding": []
    },
    {
      "slug": "func isASCII(data []byte) bool {",
      "content": "func isASCII(data []byte) bool {\n\tfor _, c := range data {\n\t\tif c < 32 || c > 126 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n",
      "length": 82,
      "tokens": 23,
      "embedding": []
    }
  ]
}