{
  "filepath": "../implementations/go/lnd/channeldb/migration/lnwire21/message.go",
  "package": "lnwire",
  "sections": [
    {
      "slug": "type MessageType uint16",
      "content": "type MessageType uint16\n\n// The currently defined message types within this current version of the\n// Lightning protocol.\nconst (\n\tMsgInit                    MessageType = 16\n\tMsgError                               = 17\n\tMsgPing                                = 18\n\tMsgPong                                = 19\n\tMsgOpenChannel                         = 32\n\tMsgAcceptChannel                       = 33\n\tMsgFundingCreated                      = 34\n\tMsgFundingSigned                       = 35\n\tMsgFundingLocked                       = 36\n\tMsgShutdown                            = 38\n\tMsgClosingSigned                       = 39\n\tMsgUpdateAddHTLC                       = 128\n\tMsgUpdateFulfillHTLC                   = 130\n\tMsgUpdateFailHTLC                      = 131\n\tMsgCommitSig                           = 132\n\tMsgRevokeAndAck                        = 133\n\tMsgUpdateFee                           = 134\n\tMsgUpdateFailMalformedHTLC             = 135\n\tMsgChannelReestablish                  = 136\n\tMsgChannelAnnouncement                 = 256\n\tMsgNodeAnnouncement                    = 257\n\tMsgChannelUpdate                       = 258\n\tMsgAnnounceSignatures                  = 259\n\tMsgQueryShortChanIDs                   = 261\n\tMsgReplyShortChanIDsEnd                = 262\n\tMsgQueryChannelRange                   = 263\n\tMsgReplyChannelRange                   = 264\n\tMsgGossipTimestampRange                = 265\n)\n\n// String return the string representation of message type.",
      "length": 1411,
      "tokens": 112,
      "embedding": []
    },
    {
      "slug": "func (t MessageType) String() string {",
      "content": "func (t MessageType) String() string {\n\tswitch t {\n\tcase MsgInit:\n\t\treturn \"Init\"\n\tcase MsgOpenChannel:\n\t\treturn \"MsgOpenChannel\"\n\tcase MsgAcceptChannel:\n\t\treturn \"MsgAcceptChannel\"\n\tcase MsgFundingCreated:\n\t\treturn \"MsgFundingCreated\"\n\tcase MsgFundingSigned:\n\t\treturn \"MsgFundingSigned\"\n\tcase MsgFundingLocked:\n\t\treturn \"FundingLocked\"\n\tcase MsgShutdown:\n\t\treturn \"Shutdown\"\n\tcase MsgClosingSigned:\n\t\treturn \"ClosingSigned\"\n\tcase MsgUpdateAddHTLC:\n\t\treturn \"UpdateAddHTLC\"\n\tcase MsgUpdateFailHTLC:\n\t\treturn \"UpdateFailHTLC\"\n\tcase MsgUpdateFulfillHTLC:\n\t\treturn \"UpdateFulfillHTLC\"\n\tcase MsgCommitSig:\n\t\treturn \"CommitSig\"\n\tcase MsgRevokeAndAck:\n\t\treturn \"RevokeAndAck\"\n\tcase MsgUpdateFailMalformedHTLC:\n\t\treturn \"UpdateFailMalformedHTLC\"\n\tcase MsgChannelReestablish:\n\t\treturn \"ChannelReestablish\"\n\tcase MsgError:\n\t\treturn \"Error\"\n\tcase MsgChannelAnnouncement:\n\t\treturn \"ChannelAnnouncement\"\n\tcase MsgChannelUpdate:\n\t\treturn \"ChannelUpdate\"\n\tcase MsgNodeAnnouncement:\n\t\treturn \"NodeAnnouncement\"\n\tcase MsgPing:\n\t\treturn \"Ping\"\n\tcase MsgAnnounceSignatures:\n\t\treturn \"AnnounceSignatures\"\n\tcase MsgPong:\n\t\treturn \"Pong\"\n\tcase MsgUpdateFee:\n\t\treturn \"UpdateFee\"\n\tcase MsgQueryShortChanIDs:\n\t\treturn \"QueryShortChanIDs\"\n\tcase MsgReplyShortChanIDsEnd:\n\t\treturn \"ReplyShortChanIDsEnd\"\n\tcase MsgQueryChannelRange:\n\t\treturn \"QueryChannelRange\"\n\tcase MsgReplyChannelRange:\n\t\treturn \"ReplyChannelRange\"\n\tcase MsgGossipTimestampRange:\n\t\treturn \"GossipTimestampRange\"\n\tdefault:\n\t\treturn \"<unknown>\"\n\t}\n}\n\n// UnknownMessage is an implementation of the error interface that allows the\n// creation of an error in response to an unknown message.",
      "length": 1526,
      "tokens": 143,
      "embedding": []
    },
    {
      "slug": "type UnknownMessage struct {",
      "content": "type UnknownMessage struct {\n\tmessageType MessageType\n}\n\n// Error returns a human readable string describing the error.\n//\n// This is part of the error interface.",
      "length": 128,
      "tokens": 22,
      "embedding": []
    },
    {
      "slug": "func (u *UnknownMessage) Error() string {",
      "content": "func (u *UnknownMessage) Error() string {\n\treturn fmt.Sprintf(\"unable to parse message of unknown type: %v\",\n\t\tu.messageType)\n}\n\n// Serializable is an interface which defines a lightning wire serializable\n// object.",
      "length": 168,
      "tokens": 24,
      "embedding": []
    },
    {
      "slug": "type Serializable interface {",
      "content": "type Serializable interface {\n\t// Decode reads the bytes stream and converts it to the object.\n\tDecode(io.Reader, uint32) error\n\n\t// Encode converts object to the bytes stream and write it into the\n\t// writer.\n\tEncode(io.Writer, uint32) error\n}\n\n// Message is an interface that defines a lightning wire protocol message. The\n// interface is general in order to allow implementing types full control over\n// the representation of its data.",
      "length": 398,
      "tokens": 66,
      "embedding": []
    },
    {
      "slug": "type Message interface {",
      "content": "type Message interface {\n\tSerializable\n\tMsgType() MessageType\n\tMaxPayloadLength(uint32) uint32\n}\n\n// makeEmptyMessage creates a new empty message of the proper concrete type\n// based on the passed message type.",
      "length": 179,
      "tokens": 25,
      "embedding": []
    },
    {
      "slug": "func makeEmptyMessage(msgType MessageType) (Message, error) {",
      "content": "func makeEmptyMessage(msgType MessageType) (Message, error) {\n\tvar msg Message\n\n\tswitch msgType {\n\tcase MsgInit:\n\t\tmsg = &Init{}\n\tcase MsgOpenChannel:\n\t\tmsg = &OpenChannel{}\n\tcase MsgAcceptChannel:\n\t\tmsg = &AcceptChannel{}\n\tcase MsgFundingCreated:\n\t\tmsg = &FundingCreated{}\n\tcase MsgFundingSigned:\n\t\tmsg = &FundingSigned{}\n\tcase MsgFundingLocked:\n\t\tmsg = &FundingLocked{}\n\tcase MsgShutdown:\n\t\tmsg = &Shutdown{}\n\tcase MsgClosingSigned:\n\t\tmsg = &ClosingSigned{}\n\tcase MsgUpdateAddHTLC:\n\t\tmsg = &UpdateAddHTLC{}\n\tcase MsgUpdateFailHTLC:\n\t\tmsg = &UpdateFailHTLC{}\n\tcase MsgUpdateFulfillHTLC:\n\t\tmsg = &UpdateFulfillHTLC{}\n\tcase MsgCommitSig:\n\t\tmsg = &CommitSig{}\n\tcase MsgRevokeAndAck:\n\t\tmsg = &RevokeAndAck{}\n\tcase MsgUpdateFee:\n\t\tmsg = &UpdateFee{}\n\tcase MsgUpdateFailMalformedHTLC:\n\t\tmsg = &UpdateFailMalformedHTLC{}\n\tcase MsgChannelReestablish:\n\t\tmsg = &ChannelReestablish{}\n\tcase MsgError:\n\t\tmsg = &Error{}\n\tcase MsgChannelAnnouncement:\n\t\tmsg = &ChannelAnnouncement{}\n\tcase MsgChannelUpdate:\n\t\tmsg = &ChannelUpdate{}\n\tcase MsgNodeAnnouncement:\n\t\tmsg = &NodeAnnouncement{}\n\tcase MsgPing:\n\t\tmsg = &Ping{}\n\tcase MsgAnnounceSignatures:\n\t\tmsg = &AnnounceSignatures{}\n\tcase MsgPong:\n\t\tmsg = &Pong{}\n\tcase MsgQueryShortChanIDs:\n\t\tmsg = &QueryShortChanIDs{}\n\tcase MsgReplyShortChanIDsEnd:\n\t\tmsg = &ReplyShortChanIDsEnd{}\n\tcase MsgQueryChannelRange:\n\t\tmsg = &QueryChannelRange{}\n\tcase MsgReplyChannelRange:\n\t\tmsg = &ReplyChannelRange{}\n\tcase MsgGossipTimestampRange:\n\t\tmsg = &GossipTimestampRange{}\n\tdefault:\n\t\treturn nil, &UnknownMessage{msgType}\n\t}\n\n\treturn msg, nil\n}\n\n// WriteMessage writes a lightning Message to w including the necessary header\n// information and returns the number of bytes written.",
      "length": 1568,
      "tokens": 176,
      "embedding": []
    },
    {
      "slug": "func WriteMessage(w io.Writer, msg Message, pver uint32) (int, error) {",
      "content": "func WriteMessage(w io.Writer, msg Message, pver uint32) (int, error) {\n\ttotalBytes := 0\n\n\t// Encode the message payload itself into a temporary buffer.\n\t// TODO(roasbeef): create buffer pool\n\tvar bw bytes.Buffer\n\tif err := msg.Encode(&bw, pver); err != nil {\n\t\treturn totalBytes, err\n\t}\n\tpayload := bw.Bytes()\n\tlenp := len(payload)\n\n\t// Enforce maximum overall message payload.\n\tif lenp > MaxMessagePayload {\n\t\treturn totalBytes, fmt.Errorf(\"message payload is too large - \"+\n\t\t\t\"encoded %d bytes, but maximum message payload is %d bytes\",\n\t\t\tlenp, MaxMessagePayload)\n\t}\n\n\t// Enforce maximum message payload on the message type.\n\tmpl := msg.MaxPayloadLength(pver)\n\tif uint32(lenp) > mpl {\n\t\treturn totalBytes, fmt.Errorf(\"message payload is too large - \"+\n\t\t\t\"encoded %d bytes, but maximum message payload of \"+\n\t\t\t\"type %v is %d bytes\", lenp, msg.MsgType(), mpl)\n\t}\n\n\t// With the initial sanity checks complete, we'll now write out the\n\t// message type itself.\n\tvar mType [2]byte\n\tbinary.BigEndian.PutUint16(mType[:], uint16(msg.MsgType()))\n\tn, err := w.Write(mType[:])\n\ttotalBytes += n\n\tif err != nil {\n\t\treturn totalBytes, err\n\t}\n\n\t// With the message type written, we'll now write out the raw payload\n\t// itself.\n\tn, err = w.Write(payload)\n\ttotalBytes += n\n\n\treturn totalBytes, err\n}\n\n// ReadMessage reads, validates, and parses the next Lightning message from r\n// for the provided protocol version.",
      "length": 1288,
      "tokens": 198,
      "embedding": []
    },
    {
      "slug": "func ReadMessage(r io.Reader, pver uint32) (Message, error) {",
      "content": "func ReadMessage(r io.Reader, pver uint32) (Message, error) {\n\t// First, we'll read out the first two bytes of the message so we can\n\t// create the proper empty message.\n\tvar mType [2]byte\n\tif _, err := io.ReadFull(r, mType[:]); err != nil {\n\t\treturn nil, err\n\t}\n\n\tmsgType := MessageType(binary.BigEndian.Uint16(mType[:]))\n\n\t// Now that we know the target message type, we can create the proper\n\t// empty message type and decode the message into it.\n\tmsg, err := makeEmptyMessage(msgType)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err := msg.Decode(r, pver); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn msg, nil\n}\n",
      "length": 530,
      "tokens": 95,
      "embedding": []
    }
  ]
}