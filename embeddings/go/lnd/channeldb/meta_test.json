{
  "filepath": "../implementations/go/lnd/channeldb/meta_test.go",
  "package": "channeldb",
  "sections": [
    {
      "slug": "func applyMigration(t *testing.T, beforeMigration, afterMigration func(d *DB),",
      "content": "func applyMigration(t *testing.T, beforeMigration, afterMigration func(d *DB),\n\tmigrationFunc migration, shouldFail bool, dryRun bool) {\n\n\tcdb, err := MakeTestDB(t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcdb.dryRun = dryRun\n\n\t// Create a test node that will be our source node.\n\ttestNode, err := createTestVertex(cdb)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tgraph := cdb.ChannelGraph()\n\tif err := graph.SetSourceNode(testNode); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// beforeMigration usually used for populating the database\n\t// with test data.\n\tbeforeMigration(cdb)\n\n\t// Create test meta info with zero database version and put it on disk.\n\t// Than creating the version list pretending that new version was added.\n\tmeta := &Meta{DbVersionNumber: 0}\n\tif err := cdb.PutMeta(meta); err != nil {\n\t\tt.Fatalf(\"unable to store meta data: %v\", err)\n\t}\n\n\tversions := []mandatoryVersion{\n\t\t{\n\t\t\tnumber:    0,\n\t\t\tmigration: nil,\n\t\t},\n\t\t{\n\t\t\tnumber:    1,\n\t\t\tmigration: migrationFunc,\n\t\t},\n\t}\n\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tif dryRun && r != ErrDryRunMigrationOK {\n\t\t\t\tt.Fatalf(\"expected dry run migration OK\")\n\t\t\t}\n\t\t\terr = errors.New(r)\n\t\t}\n\n\t\tif err == nil && shouldFail {\n\t\t\tt.Fatal(\"error wasn't received on migration stage\")\n\t\t} else if err != nil && !shouldFail {\n\t\t\tt.Fatalf(\"error was received on migration stage: %v\", err)\n\t\t}\n\n\t\t// afterMigration usually used for checking the database state and\n\t\t// throwing the error if something went wrong.\n\t\tafterMigration(cdb)\n\t}()\n\n\t// Sync with the latest version - applying migration function.\n\terr = cdb.syncVersions(versions)\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n}\n\n// TestVersionFetchPut checks the propernces of fetch/put methods\n// and also initialization of meta data in case if don't have any in\n// database.",
      "length": 1621,
      "tokens": 255,
      "embedding": []
    },
    {
      "slug": "func TestVersionFetchPut(t *testing.T) {",
      "content": "func TestVersionFetchPut(t *testing.T) {\n\tt.Parallel()\n\n\tdb, err := MakeTestDB(t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tmeta, err := db.FetchMeta()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif meta.DbVersionNumber != getLatestDBVersion(dbVersions) {\n\t\tt.Fatal(\"initialization of meta information wasn't performed\")\n\t}\n\n\tnewVersion := getLatestDBVersion(dbVersions) + 1\n\tmeta.DbVersionNumber = newVersion\n\n\tif err := db.PutMeta(meta); err != nil {\n\t\tt.Fatalf(\"update of meta failed %v\", err)\n\t}\n\n\tmeta, err = db.FetchMeta()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif meta.DbVersionNumber != newVersion {\n\t\tt.Fatal(\"update of meta information wasn't performed\")\n\t}\n}\n\n// TestOrderOfMigrations checks that migrations are applied in proper order.",
      "length": 659,
      "tokens": 92,
      "embedding": []
    },
    {
      "slug": "func TestOrderOfMigrations(t *testing.T) {",
      "content": "func TestOrderOfMigrations(t *testing.T) {\n\tt.Parallel()\n\n\tappliedMigration := -1\n\tversions := []mandatoryVersion{\n\t\t{0, nil},\n\t\t{1, nil},\n\t\t{2, func(tx kvdb.RwTx) error {\n\t\t\tappliedMigration = 2\n\t\t\treturn nil\n\t\t}},\n\t\t{3, func(tx kvdb.RwTx) error {\n\t\t\tappliedMigration = 3\n\t\t\treturn nil\n\t\t}},\n\t}\n\n\t// Retrieve the migration that should be applied to db, as far as\n\t// current version is 1, we skip zero and first versions.\n\tmigrations, _ := getMigrationsToApply(versions, 1)\n\n\tif len(migrations) != 2 {\n\t\tt.Fatal(\"incorrect number of migrations to apply\")\n\t}\n\n\t// Apply first migration.\n\tmigrations[0](nil)\n\n\t// Check that first migration corresponds to the second version.\n\tif appliedMigration != 2 {\n\t\tt.Fatal(\"incorrect order of applying migrations\")\n\t}\n\n\t// Apply second migration.\n\tmigrations[1](nil)\n\n\t// Check that second migration corresponds to the third version.\n\tif appliedMigration != 3 {\n\t\tt.Fatal(\"incorrect order of applying migrations\")\n\t}\n}\n\n// TestGlobalVersionList checks that there is no mistake in global version list\n// in terms of version ordering.",
      "length": 986,
      "tokens": 146,
      "embedding": []
    },
    {
      "slug": "func TestGlobalVersionList(t *testing.T) {",
      "content": "func TestGlobalVersionList(t *testing.T) {\n\tt.Parallel()\n\n\tif dbVersions == nil {\n\t\tt.Fatal(\"can't find versions list\")\n\t}\n\n\tif len(dbVersions) == 0 {\n\t\tt.Fatal(\"db versions list is empty\")\n\t}\n\n\tprev := dbVersions[0].number\n\tfor i := 1; i < len(dbVersions); i++ {\n\t\tversion := dbVersions[i].number\n\n\t\tif version == prev {\n\t\t\tt.Fatal(\"duplicates db versions\")\n\t\t}\n\t\tif version < prev {\n\t\t\tt.Fatal(\"order of db versions is wrong\")\n\t\t}\n\n\t\tprev = version\n\t}\n}\n\n// TestMigrationWithPanic asserts that if migration logic panics, we will return\n// to the original state unaltered.",
      "length": 504,
      "tokens": 80,
      "embedding": []
    },
    {
      "slug": "func TestMigrationWithPanic(t *testing.T) {",
      "content": "func TestMigrationWithPanic(t *testing.T) {\n\tt.Parallel()\n\n\tbucketPrefix := []byte(\"somebucket\")\n\tkeyPrefix := []byte(\"someprefix\")\n\tbeforeMigration := []byte(\"beforemigration\")\n\tafterMigration := []byte(\"aftermigration\")\n\n\tbeforeMigrationFunc := func(d *DB) {\n\t\t// Insert data in database and in order then make sure that the\n\t\t// key isn't changes in case of panic or fail.\n\t\terr := kvdb.Update(d, func(tx kvdb.RwTx) error {\n\t\t\tbucket, err := tx.CreateTopLevelBucket(bucketPrefix)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\treturn bucket.Put(keyPrefix, beforeMigration)\n\t\t}, func() {})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to insert: %v\", err)\n\t\t}\n\t}\n\n\t// Create migration function which changes the initially created data and\n\t// throw the panic, in this case we pretending that something goes.\n\tmigrationWithPanic := func(tx kvdb.RwTx) error {\n\t\tbucket, err := tx.CreateTopLevelBucket(bucketPrefix)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tbucket.Put(keyPrefix, afterMigration)\n\t\tpanic(\"panic!\")\n\t}\n\n\t// Check that version of database and data wasn't changed.\n\tafterMigrationFunc := func(d *DB) {\n\t\tmeta, err := d.FetchMeta()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif meta.DbVersionNumber != 0 {\n\t\t\tt.Fatal(\"migration panicked but version is changed\")\n\t\t}\n\n\t\terr = kvdb.Update(d, func(tx kvdb.RwTx) error {\n\t\t\tbucket, err := tx.CreateTopLevelBucket(bucketPrefix)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tvalue := bucket.Get(keyPrefix)\n\t\t\tif !bytes.Equal(value, beforeMigration) {\n\t\t\t\treturn errors.New(\"migration failed but data is \" +\n\t\t\t\t\t\"changed\")\n\t\t\t}\n\n\t\t\treturn nil\n\t\t}, func() {})\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\tapplyMigration(t,\n\t\tbeforeMigrationFunc,\n\t\tafterMigrationFunc,\n\t\tmigrationWithPanic,\n\t\ttrue,\n\t\tfalse)\n}\n\n// TestMigrationWithFatal asserts that migrations which fail do not modify the\n// database.",
      "length": 1716,
      "tokens": 230,
      "embedding": []
    },
    {
      "slug": "func TestMigrationWithFatal(t *testing.T) {",
      "content": "func TestMigrationWithFatal(t *testing.T) {\n\tt.Parallel()\n\n\tbucketPrefix := []byte(\"somebucket\")\n\tkeyPrefix := []byte(\"someprefix\")\n\tbeforeMigration := []byte(\"beforemigration\")\n\tafterMigration := []byte(\"aftermigration\")\n\n\tbeforeMigrationFunc := func(d *DB) {\n\t\terr := kvdb.Update(d, func(tx kvdb.RwTx) error {\n\t\t\tbucket, err := tx.CreateTopLevelBucket(bucketPrefix)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\treturn bucket.Put(keyPrefix, beforeMigration)\n\t\t}, func() {})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to insert pre migration key: %v\", err)\n\t\t}\n\t}\n\n\t// Create migration function which changes the initially created data and\n\t// return the error, in this case we pretending that something goes\n\t// wrong.\n\tmigrationWithFatal := func(tx kvdb.RwTx) error {\n\t\tbucket, err := tx.CreateTopLevelBucket(bucketPrefix)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tbucket.Put(keyPrefix, afterMigration)\n\t\treturn errors.New(\"some error\")\n\t}\n\n\t// Check that version of database and initial data wasn't changed.\n\tafterMigrationFunc := func(d *DB) {\n\t\tmeta, err := d.FetchMeta()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif meta.DbVersionNumber != 0 {\n\t\t\tt.Fatal(\"migration failed but version is changed\")\n\t\t}\n\n\t\terr = kvdb.Update(d, func(tx kvdb.RwTx) error {\n\t\t\tbucket, err := tx.CreateTopLevelBucket(bucketPrefix)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tvalue := bucket.Get(keyPrefix)\n\t\t\tif !bytes.Equal(value, beforeMigration) {\n\t\t\t\treturn errors.New(\"migration failed but data is \" +\n\t\t\t\t\t\"changed\")\n\t\t\t}\n\n\t\t\treturn nil\n\t\t}, func() {})\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\tapplyMigration(t,\n\t\tbeforeMigrationFunc,\n\t\tafterMigrationFunc,\n\t\tmigrationWithFatal,\n\t\ttrue,\n\t\tfalse)\n}\n\n// TestMigrationWithoutErrors asserts that a successful migration has its\n// changes applied to the database.",
      "length": 1671,
      "tokens": 217,
      "embedding": []
    },
    {
      "slug": "func TestMigrationWithoutErrors(t *testing.T) {",
      "content": "func TestMigrationWithoutErrors(t *testing.T) {\n\tt.Parallel()\n\n\tbucketPrefix := []byte(\"somebucket\")\n\tkeyPrefix := []byte(\"someprefix\")\n\tbeforeMigration := []byte(\"beforemigration\")\n\tafterMigration := []byte(\"aftermigration\")\n\n\t// Populate database with initial data.\n\tbeforeMigrationFunc := func(d *DB) {\n\t\terr := kvdb.Update(d, func(tx kvdb.RwTx) error {\n\t\t\tbucket, err := tx.CreateTopLevelBucket(bucketPrefix)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\treturn bucket.Put(keyPrefix, beforeMigration)\n\t\t}, func() {})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to update db pre migration: %v\", err)\n\t\t}\n\t}\n\n\t// Create migration function which changes the initially created data.\n\tmigrationWithoutErrors := func(tx kvdb.RwTx) error {\n\t\tbucket, err := tx.CreateTopLevelBucket(bucketPrefix)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tbucket.Put(keyPrefix, afterMigration)\n\t\treturn nil\n\t}\n\n\t// Check that version of database and data was properly changed.\n\tafterMigrationFunc := func(d *DB) {\n\t\tmeta, err := d.FetchMeta()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif meta.DbVersionNumber != 1 {\n\t\t\tt.Fatal(\"version number isn't changed after \" +\n\t\t\t\t\"successfully applied migration\")\n\t\t}\n\n\t\terr = kvdb.Update(d, func(tx kvdb.RwTx) error {\n\t\t\tbucket, err := tx.CreateTopLevelBucket(bucketPrefix)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tvalue := bucket.Get(keyPrefix)\n\t\t\tif !bytes.Equal(value, afterMigration) {\n\t\t\t\treturn errors.New(\"migration wasn't applied \" +\n\t\t\t\t\t\"properly\")\n\t\t\t}\n\n\t\t\treturn nil\n\t\t}, func() {})\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\tapplyMigration(t,\n\t\tbeforeMigrationFunc,\n\t\tafterMigrationFunc,\n\t\tmigrationWithoutErrors,\n\t\tfalse,\n\t\tfalse)\n}\n\n// TestMigrationReversion tests after performing a migration to a higher\n// database version, opening the database with a lower latest db version returns\n// ErrDBReversion.",
      "length": 1707,
      "tokens": 219,
      "embedding": []
    },
    {
      "slug": "func TestMigrationReversion(t *testing.T) {",
      "content": "func TestMigrationReversion(t *testing.T) {\n\tt.Parallel()\n\n\ttempDirName := t.TempDir()\n\n\tbackend, cleanup, err := kvdb.GetTestBackend(tempDirName, \"cdb\")\n\trequire.NoError(t, err, \"unable to get test db backend\")\n\n\tcdb, err := CreateWithBackend(backend)\n\tif err != nil {\n\t\tcleanup()\n\t\tt.Fatalf(\"unable to open channeldb: %v\", err)\n\t}\n\n\t// Update the database metadata to point to one more than the highest\n\t// known version.\n\terr = kvdb.Update(cdb, func(tx kvdb.RwTx) error {\n\t\tnewMeta := &Meta{\n\t\t\tDbVersionNumber: getLatestDBVersion(dbVersions) + 1,\n\t\t}\n\n\t\treturn putMeta(newMeta, tx)\n\t}, func() {})\n\n\t// Close the database. Even if we succeeded, our next step is to reopen.\n\tcdb.Close()\n\tcleanup()\n\n\trequire.NoError(t, err, \"unable to increase db version\")\n\n\tbackend, cleanup, err = kvdb.GetTestBackend(tempDirName, \"cdb\")\n\trequire.NoError(t, err, \"unable to get test db backend\")\n\tt.Cleanup(cleanup)\n\n\t_, err = CreateWithBackend(backend)\n\tif err != ErrDBReversion {\n\t\tt.Fatalf(\"unexpected error when opening channeldb, \"+\n\t\t\t\"want: %v, got: %v\", ErrDBReversion, err)\n\t}\n}\n\n// TestMigrationDryRun ensures that opening the database in dry run migration\n// mode will fail and not commit the migration.",
      "length": 1116,
      "tokens": 153,
      "embedding": []
    },
    {
      "slug": "func TestMigrationDryRun(t *testing.T) {",
      "content": "func TestMigrationDryRun(t *testing.T) {\n\tt.Parallel()\n\n\t// Nothing to do, will inspect version number.\n\tbeforeMigrationFunc := func(d *DB) {}\n\n\t// Check that version of database version is not modified.\n\tafterMigrationFunc := func(d *DB) {\n\t\terr := kvdb.View(d, func(tx kvdb.RTx) error {\n\t\t\tmeta, err := d.FetchMeta()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tif meta.DbVersionNumber != 0 {\n\t\t\t\tt.Fatal(\"dry run migration was not aborted\")\n\t\t\t}\n\n\t\t\treturn nil\n\t\t}, func() {})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to apply after func: %v\", err)\n\t\t}\n\t}\n\n\tapplyMigration(t,\n\t\tbeforeMigrationFunc,\n\t\tafterMigrationFunc,\n\t\tfunc(kvdb.RwTx) error { return nil },\n\t\ttrue,\n\t\ttrue)\n}\n\n// TestOptionalMeta checks the basic read and write for the optional meta.",
      "length": 681,
      "tokens": 102,
      "embedding": []
    },
    {
      "slug": "func TestOptionalMeta(t *testing.T) {",
      "content": "func TestOptionalMeta(t *testing.T) {\n\tt.Parallel()\n\n\tdb, err := MakeTestDB(t)\n\trequire.NoError(t, err)\n\n\t// Test read an empty optional meta.\n\tom, err := db.fetchOptionalMeta()\n\trequire.NoError(t, err, \"error getting optional meta\")\n\trequire.Empty(t, om.Versions, \"expected empty versions\")\n\n\t// Test write an optional meta.\n\tom = &OptionalMeta{\n\t\tVersions: map[uint64]string{\n\t\t\t0: optionalVersions[0].name,\n\t\t},\n\t}\n\terr = db.putOptionalMeta(om)\n\trequire.NoError(t, err, \"error putting optional meta\")\n\n\tom1, err := db.fetchOptionalMeta()\n\trequire.NoError(t, err, \"error getting optional meta\")\n\trequire.Equal(t, om, om1, \"unexpected empty versions\")\n\trequire.Equal(t, \"0: prune revocation log\", om.String())\n}\n\n// TestApplyOptionalVersions checks that the optional migration is applied as\n// expected based on the config.",
      "length": 760,
      "tokens": 92,
      "embedding": []
    },
    {
      "slug": "func TestApplyOptionalVersions(t *testing.T) {",
      "content": "func TestApplyOptionalVersions(t *testing.T) {\n\tt.Parallel()\n\n\tdb, err := MakeTestDB(t)\n\trequire.NoError(t, err)\n\n\t// Overwrite the migration function so we can count how many times the\n\t// migration has happened.\n\tmigrateCount := 0\n\toptionalVersions[0].migration = func(_ kvdb.Backend,\n\t\t_ MigrationConfig) error {\n\n\t\tmigrateCount++\n\t\treturn nil\n\t}\n\n\t// Test that when the flag is false, no migration happens.\n\tcfg := OptionalMiragtionConfig{}\n\terr = db.applyOptionalVersions(cfg)\n\trequire.NoError(t, err, \"failed to apply optional migration\")\n\trequire.Equal(t, 0, migrateCount, \"expected no migration\")\n\n\t// Check the optional meta is not updated.\n\tom, err := db.fetchOptionalMeta()\n\trequire.NoError(t, err, \"error getting optional meta\")\n\trequire.Empty(t, om.Versions, \"expected empty versions\")\n\n\t// Test that when specified, the optional migration is applied.\n\tcfg.PruneRevocationLog = true\n\terr = db.applyOptionalVersions(cfg)\n\trequire.NoError(t, err, \"failed to apply optional migration\")\n\trequire.Equal(t, 1, migrateCount, \"expected migration\")\n\n\t// Fetch the updated optional meta.\n\tom, err = db.fetchOptionalMeta()\n\trequire.NoError(t, err, \"error getting optional meta\")\n\n\t// Verify that the optional meta is updated as expected.\n\tomExpected := &OptionalMeta{\n\t\tVersions: map[uint64]string{\n\t\t\t0: optionalVersions[0].name,\n\t\t},\n\t}\n\trequire.Equal(t, omExpected, om, \"unexpected empty versions\")\n\n\t// Test that though specified, the optional migration is not run since\n\t// it's already been applied.\n\tcfg.PruneRevocationLog = true\n\terr = db.applyOptionalVersions(cfg)\n\trequire.NoError(t, err, \"failed to apply optional migration\")\n\trequire.Equal(t, 1, migrateCount, \"expected no migration\")\n}\n\n// TestFetchMeta tests that the FetchMeta returns the latest DB version for a\n// freshly created DB instance.",
      "length": 1711,
      "tokens": 216,
      "embedding": []
    },
    {
      "slug": "func TestFetchMeta(t *testing.T) {",
      "content": "func TestFetchMeta(t *testing.T) {\n\tt.Parallel()\n\n\tdb, err := MakeTestDB(t)\n\trequire.NoError(t, err)\n\n\tmeta := &Meta{}\n\terr = db.View(func(tx walletdb.ReadTx) error {\n\t\treturn FetchMeta(meta, tx)\n\t}, func() {\n\t\tmeta = &Meta{}\n\t})\n\trequire.NoError(t, err)\n\n\trequire.Equal(t, LatestDBVersion(), meta.DbVersionNumber)\n}\n\n// TestMarkerAndTombstone tests that markers like a tombstone can be added to a\n// DB.",
      "length": 352,
      "tokens": 47,
      "embedding": []
    },
    {
      "slug": "func TestMarkerAndTombstone(t *testing.T) {",
      "content": "func TestMarkerAndTombstone(t *testing.T) {\n\tt.Parallel()\n\n\tdb, err := MakeTestDB(t)\n\trequire.NoError(t, err)\n\n\t// Test that a generic marker is not present in a fresh DB.\n\tvar marker []byte\n\terr = db.View(func(tx walletdb.ReadTx) error {\n\t\tvar err error\n\t\tmarker, err = CheckMarkerPresent(tx, []byte(\"foo\"))\n\t\treturn err\n\t}, func() {\n\t\tmarker = nil\n\t})\n\trequire.ErrorIs(t, err, ErrMarkerNotPresent)\n\trequire.Nil(t, marker)\n\n\t// Only adding the marker bucket should not be enough to be counted as\n\t// a marker, we explicitly also want the value to be set.\n\terr = db.Update(func(tx walletdb.ReadWriteTx) error {\n\t\t_, err := tx.CreateTopLevelBucket([]byte(\"foo\"))\n\t\treturn err\n\t}, func() {})\n\trequire.NoError(t, err)\n\n\terr = db.View(func(tx walletdb.ReadTx) error {\n\t\tvar err error\n\t\tmarker, err = CheckMarkerPresent(tx, []byte(\"foo\"))\n\t\treturn err\n\t}, func() {\n\t\tmarker = nil\n\t})\n\trequire.ErrorIs(t, err, ErrMarkerNotPresent)\n\trequire.Nil(t, marker)\n\n\t// Test that a tombstone marker is not present in a fresh DB.\n\terr = db.View(EnsureNoTombstone, func() {})\n\trequire.NoError(t, err)\n\n\t// Add a generic marker now and assert that it can be read.\n\terr = db.Update(func(tx walletdb.ReadWriteTx) error {\n\t\treturn AddMarker(tx, []byte(\"foo\"), []byte(\"bar\"))\n\t}, func() {})\n\trequire.NoError(t, err)\n\n\terr = db.View(func(tx walletdb.ReadTx) error {\n\t\tvar err error\n\t\tmarker, err = CheckMarkerPresent(tx, []byte(\"foo\"))\n\t\treturn err\n\t}, func() {\n\t\tmarker = nil\n\t})\n\trequire.NoError(t, err)\n\trequire.Equal(t, []byte(\"bar\"), marker)\n\n\t// A tombstone should still not be present.\n\terr = db.View(EnsureNoTombstone, func() {})\n\trequire.NoError(t, err)\n\n\t// Finally, add a tombstone.\n\ttombstoneText := []byte(\"RIP test DB\")\n\terr = db.Update(func(tx walletdb.ReadWriteTx) error {\n\t\treturn AddMarker(tx, TombstoneKey, tombstoneText)\n\t}, func() {})\n\trequire.NoError(t, err)\n\n\t// We can read it as a normal marker.\n\terr = db.View(func(tx walletdb.ReadTx) error {\n\t\tvar err error\n\t\tmarker, err = CheckMarkerPresent(tx, TombstoneKey)\n\t\treturn err\n\t}, func() {\n\t\tmarker = nil\n\t})\n\trequire.NoError(t, err)\n\trequire.Equal(t, tombstoneText, marker)\n\n\t// But also as a tombstone, and now we should get an error that the DB\n\t// cannot be used anymore.\n\terr = db.View(EnsureNoTombstone, func() {})\n\trequire.ErrorContains(t, err, string(tombstoneText))\n\n\t// Now that the DB has a tombstone, we should no longer be able to open\n\t// it once we close it.\n\t_, err = CreateWithBackend(db.Backend)\n\trequire.ErrorContains(t, err, string(tombstoneText))\n}\n",
      "length": 2389,
      "tokens": 334,
      "embedding": []
    }
  ]
}