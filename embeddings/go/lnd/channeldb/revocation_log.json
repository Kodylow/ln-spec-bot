{
  "filepath": "../implementations/go/lnd/channeldb/revocation_log.go",
  "package": "channeldb",
  "sections": [
    {
      "slug": "type HTLCEntry struct {",
      "content": "type HTLCEntry struct {\n\t// RHash is the payment hash of the HTLC.\n\tRHash [32]byte\n\n\t// RefundTimeout is the absolute timeout on the HTLC that the sender\n\t// must wait before reclaiming the funds in limbo.\n\tRefundTimeout uint32\n\n\t// OutputIndex is the output index for this particular HTLC output\n\t// within the commitment transaction.\n\t//\n\t// NOTE: we use uint16 instead of int32 here to save us 2 bytes, which\n\t// gives us a max number of HTLCs of 65K.\n\tOutputIndex uint16\n\n\t// Incoming denotes whether we're the receiver or the sender of this\n\t// HTLC.\n\t//\n\t// NOTE: this field is the memory representation of the field\n\t// incomingUint.\n\tIncoming bool\n\n\t// Amt is the amount of satoshis this HTLC escrows.\n\t//\n\t// NOTE: this field is the memory representation of the field amtUint.\n\tAmt btcutil.Amount\n\n\t// amtTlv is the uint64 format of Amt. This field is created so we can\n\t// easily make it into a tlv record and save it to disk.\n\t//\n\t// NOTE: we keep this field for accounting purpose only. If the disk\n\t// space becomes an issue, we could delete this field to save us extra\n\t// 8 bytes.\n\tamtTlv uint64\n\n\t// incomingTlv is the uint8 format of Incoming. This field is created\n\t// so we can easily make it into a tlv record and save it to disk.\n\tincomingTlv uint8\n}\n\n// RHashLen is used by MakeDynamicRecord to return the size of the RHash.\n//\n// NOTE: for zero hash, we return a length 0.",
      "length": 1330,
      "tokens": 249,
      "embedding": []
    },
    {
      "slug": "func (h *HTLCEntry) RHashLen() uint64 {",
      "content": "func (h *HTLCEntry) RHashLen() uint64 {\n\tif h.RHash == lntypes.ZeroHash {\n\t\treturn 0\n\t}\n\treturn 32\n}\n\n// RHashEncoder is the customized encoder which skips encoding the empty hash.",
      "length": 134,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func RHashEncoder(w io.Writer, val interface{}, buf *[8]byte) error {",
      "content": "func RHashEncoder(w io.Writer, val interface{}, buf *[8]byte) error {\n\tv, ok := val.(*[32]byte)\n\tif !ok {\n\t\treturn tlv.NewTypeForEncodingErr(val, \"RHash\")\n\t}\n\n\t// If the value is an empty hash, we will skip encoding it.\n\tif *v == lntypes.ZeroHash {\n\t\treturn nil\n\t}\n\n\treturn tlv.EBytes32(w, v, buf)\n}\n\n// RHashDecoder is the customized decoder which skips decoding the empty hash.",
      "length": 296,
      "tokens": 49,
      "embedding": []
    },
    {
      "slug": "func RHashDecoder(r io.Reader, val interface{}, buf *[8]byte, l uint64) error {",
      "content": "func RHashDecoder(r io.Reader, val interface{}, buf *[8]byte, l uint64) error {\n\tv, ok := val.(*[32]byte)\n\tif !ok {\n\t\treturn tlv.NewTypeForEncodingErr(val, \"RHash\")\n\t}\n\n\t// If the length is zero, we will skip encoding the empty hash.\n\tif l == 0 {\n\t\treturn nil\n\t}\n\n\treturn tlv.DBytes32(r, v, buf, 32)\n}\n\n// toTlvStream converts an HTLCEntry record into a tlv representation.",
      "length": 280,
      "tokens": 48,
      "embedding": []
    },
    {
      "slug": "func (h *HTLCEntry) toTlvStream() (*tlv.Stream, error) {",
      "content": "func (h *HTLCEntry) toTlvStream() (*tlv.Stream, error) {\n\tconst (\n\t\t// A set of tlv type definitions used to serialize htlc entries\n\t\t// to the database. We define it here instead of the head of\n\t\t// the file to avoid naming conflicts.\n\t\t//\n\t\t// NOTE: A migration should be added whenever this list\n\t\t// changes.\n\t\trHashType         tlv.Type = 0\n\t\trefundTimeoutType tlv.Type = 1\n\t\toutputIndexType   tlv.Type = 2\n\t\tincomingType      tlv.Type = 3\n\t\tamtType           tlv.Type = 4\n\t)\n\n\treturn tlv.NewStream(\n\t\ttlv.MakeDynamicRecord(\n\t\t\trHashType, &h.RHash, h.RHashLen,\n\t\t\tRHashEncoder, RHashDecoder,\n\t\t),\n\t\ttlv.MakePrimitiveRecord(\n\t\t\trefundTimeoutType, &h.RefundTimeout,\n\t\t),\n\t\ttlv.MakePrimitiveRecord(\n\t\t\toutputIndexType, &h.OutputIndex,\n\t\t),\n\t\ttlv.MakePrimitiveRecord(incomingType, &h.incomingTlv),\n\t\t// We will save 3 bytes if the amount is less or equal to\n\t\t// 4,294,967,295 msat, or roughly 0.043 bitcoin.\n\t\ttlv.MakeBigSizeRecord(amtType, &h.amtTlv),\n\t)\n}\n\n// RevocationLog stores the info needed to construct a breach retribution. Its\n// fields can be viewed as a subset of a ChannelCommitment's. In the database,\n// all historical versions of the RevocationLog are saved using the\n// CommitHeight as the key.",
      "length": 1122,
      "tokens": 154,
      "embedding": []
    },
    {
      "slug": "type RevocationLog struct {",
      "content": "type RevocationLog struct {\n\t// OurOutputIndex specifies our output index in this commitment. In a\n\t// remote commitment transaction, this is the to remote output index.\n\tOurOutputIndex uint16\n\n\t// TheirOutputIndex specifies their output index in this commitment. In\n\t// a remote commitment transaction, this is the to local output index.\n\tTheirOutputIndex uint16\n\n\t// CommitTxHash is the hash of the latest version of the commitment\n\t// state, broadcast able by us.\n\tCommitTxHash [32]byte\n\n\t// HTLCEntries is the set of HTLCEntry's that are pending at this\n\t// particular commitment height.\n\tHTLCEntries []*HTLCEntry\n\n\t// OurBalance is the current available balance within the channel\n\t// directly spendable by us. In other words, it is the value of the\n\t// to_remote output on the remote parties' commitment transaction.\n\t//\n\t// NOTE: this is a pointer so that it is clear if the value is zero or\n\t// nil. Since migration 30 of the channeldb initially did not include\n\t// this field, it could be the case that the field is not present for\n\t// all revocation logs.\n\tOurBalance *lnwire.MilliSatoshi\n\n\t// TheirBalance is the current available balance within the channel\n\t// directly spendable by the remote node. In other words, it is the\n\t// value of the to_local output on the remote parties' commitment.\n\t//\n\t// NOTE: this is a pointer so that it is clear if the value is zero or\n\t// nil. Since migration 30 of the channeldb initially did not include\n\t// this field, it could be the case that the field is not present for\n\t// all revocation logs.\n\tTheirBalance *lnwire.MilliSatoshi\n}\n\n// putRevocationLog uses the fields `CommitTx` and `Htlcs` from a\n// ChannelCommitment to construct a revocation log entry and saves them to\n// disk. It also saves our output index and their output index, which are\n// useful when creating breach retribution.",
      "length": 1777,
      "tokens": 298,
      "embedding": []
    },
    {
      "slug": "func putRevocationLog(bucket kvdb.RwBucket, commit *ChannelCommitment,",
      "content": "func putRevocationLog(bucket kvdb.RwBucket, commit *ChannelCommitment,\n\tourOutputIndex, theirOutputIndex uint32, noAmtData bool) error {\n\n\t// Sanity check that the output indexes can be safely converted.\n\tif ourOutputIndex > math.MaxUint16 {\n\t\treturn ErrOutputIndexTooBig\n\t}\n\tif theirOutputIndex > math.MaxUint16 {\n\t\treturn ErrOutputIndexTooBig\n\t}\n\n\trl := &RevocationLog{\n\t\tOurOutputIndex:   uint16(ourOutputIndex),\n\t\tTheirOutputIndex: uint16(theirOutputIndex),\n\t\tCommitTxHash:     commit.CommitTx.TxHash(),\n\t\tHTLCEntries:      make([]*HTLCEntry, 0, len(commit.Htlcs)),\n\t}\n\n\tif !noAmtData {\n\t\trl.OurBalance = &commit.LocalBalance\n\t\trl.TheirBalance = &commit.RemoteBalance\n\t}\n\n\tfor _, htlc := range commit.Htlcs {\n\t\t// Skip dust HTLCs.\n\t\tif htlc.OutputIndex < 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Sanity check that the output indexes can be safely\n\t\t// converted.\n\t\tif htlc.OutputIndex > math.MaxUint16 {\n\t\t\treturn ErrOutputIndexTooBig\n\t\t}\n\n\t\tentry := &HTLCEntry{\n\t\t\tRHash:         htlc.RHash,\n\t\t\tRefundTimeout: htlc.RefundTimeout,\n\t\t\tIncoming:      htlc.Incoming,\n\t\t\tOutputIndex:   uint16(htlc.OutputIndex),\n\t\t\tAmt:           htlc.Amt.ToSatoshis(),\n\t\t}\n\t\trl.HTLCEntries = append(rl.HTLCEntries, entry)\n\t}\n\n\tvar b bytes.Buffer\n\terr := serializeRevocationLog(&b, rl)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlogEntrykey := makeLogKey(commit.CommitHeight)\n\treturn bucket.Put(logEntrykey[:], b.Bytes())\n}\n\n// fetchRevocationLog queries the revocation log bucket to find an log entry.\n// Return an error if not found.",
      "length": 1369,
      "tokens": 156,
      "embedding": []
    },
    {
      "slug": "func fetchRevocationLog(log kvdb.RBucket,",
      "content": "func fetchRevocationLog(log kvdb.RBucket,\n\tupdateNum uint64) (RevocationLog, error) {\n\n\tlogEntrykey := makeLogKey(updateNum)\n\tcommitBytes := log.Get(logEntrykey[:])\n\tif commitBytes == nil {\n\t\treturn RevocationLog{}, ErrLogEntryNotFound\n\t}\n\n\tcommitReader := bytes.NewReader(commitBytes)\n\n\treturn deserializeRevocationLog(commitReader)\n}\n\n// serializeRevocationLog serializes a RevocationLog record based on tlv\n// format.",
      "length": 364,
      "tokens": 37,
      "embedding": []
    },
    {
      "slug": "func serializeRevocationLog(w io.Writer, rl *RevocationLog) error {",
      "content": "func serializeRevocationLog(w io.Writer, rl *RevocationLog) error {\n\t// Add the tlv records for all non-optional fields.\n\trecords := []tlv.Record{\n\t\ttlv.MakePrimitiveRecord(\n\t\t\trevLogOurOutputIndexType, &rl.OurOutputIndex,\n\t\t),\n\t\ttlv.MakePrimitiveRecord(\n\t\t\trevLogTheirOutputIndexType, &rl.TheirOutputIndex,\n\t\t),\n\t\ttlv.MakePrimitiveRecord(\n\t\t\trevLogCommitTxHashType, &rl.CommitTxHash,\n\t\t),\n\t}\n\n\t// Now we add any optional fields that are non-nil.\n\tif rl.OurBalance != nil {\n\t\tlb := uint64(*rl.OurBalance)\n\t\trecords = append(records, tlv.MakeBigSizeRecord(\n\t\t\trevLogOurBalanceType, &lb,\n\t\t))\n\t}\n\n\tif rl.TheirBalance != nil {\n\t\trb := uint64(*rl.TheirBalance)\n\t\trecords = append(records, tlv.MakeBigSizeRecord(\n\t\t\trevLogTheirBalanceType, &rb,\n\t\t))\n\t}\n\n\t// Create the tlv stream.\n\ttlvStream, err := tlv.NewStream(records...)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Write the tlv stream.\n\tif err := writeTlvStream(w, tlvStream); err != nil {\n\t\treturn err\n\t}\n\n\t// Write the HTLCs.\n\treturn serializeHTLCEntries(w, rl.HTLCEntries)\n}\n\n// serializeHTLCEntries serializes a list of HTLCEntry records based on tlv\n// format.",
      "length": 998,
      "tokens": 122,
      "embedding": []
    },
    {
      "slug": "func serializeHTLCEntries(w io.Writer, htlcs []*HTLCEntry) error {",
      "content": "func serializeHTLCEntries(w io.Writer, htlcs []*HTLCEntry) error {\n\tfor _, htlc := range htlcs {\n\t\t// Patch the incomingTlv field.\n\t\tif htlc.Incoming {\n\t\t\thtlc.incomingTlv = 1\n\t\t}\n\n\t\t// Patch the amtTlv field.\n\t\thtlc.amtTlv = uint64(htlc.Amt)\n\n\t\t// Create the tlv stream.\n\t\ttlvStream, err := htlc.toTlvStream()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Write the tlv stream.\n\t\tif err := writeTlvStream(w, tlvStream); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// deserializeRevocationLog deserializes a RevocationLog based on tlv format.",
      "length": 453,
      "tokens": 74,
      "embedding": []
    },
    {
      "slug": "func deserializeRevocationLog(r io.Reader) (RevocationLog, error) {",
      "content": "func deserializeRevocationLog(r io.Reader) (RevocationLog, error) {\n\tvar (\n\t\trl           RevocationLog\n\t\tourBalance   uint64\n\t\ttheirBalance uint64\n\t)\n\n\t// Create the tlv stream.\n\ttlvStream, err := tlv.NewStream(\n\t\ttlv.MakePrimitiveRecord(\n\t\t\trevLogOurOutputIndexType, &rl.OurOutputIndex,\n\t\t),\n\t\ttlv.MakePrimitiveRecord(\n\t\t\trevLogTheirOutputIndexType, &rl.TheirOutputIndex,\n\t\t),\n\t\ttlv.MakePrimitiveRecord(\n\t\t\trevLogCommitTxHashType, &rl.CommitTxHash,\n\t\t),\n\t\ttlv.MakeBigSizeRecord(revLogOurBalanceType, &ourBalance),\n\t\ttlv.MakeBigSizeRecord(\n\t\t\trevLogTheirBalanceType, &theirBalance,\n\t\t),\n\t)\n\tif err != nil {\n\t\treturn rl, err\n\t}\n\n\t// Read the tlv stream.\n\tparsedTypes, err := readTlvStream(r, tlvStream)\n\tif err != nil {\n\t\treturn rl, err\n\t}\n\n\tif t, ok := parsedTypes[revLogOurBalanceType]; ok && t == nil {\n\t\tlb := lnwire.MilliSatoshi(ourBalance)\n\t\trl.OurBalance = &lb\n\t}\n\n\tif t, ok := parsedTypes[revLogTheirBalanceType]; ok && t == nil {\n\t\trb := lnwire.MilliSatoshi(theirBalance)\n\t\trl.TheirBalance = &rb\n\t}\n\n\t// Read the HTLC entries.\n\trl.HTLCEntries, err = deserializeHTLCEntries(r)\n\n\treturn rl, err\n}\n\n// deserializeHTLCEntries deserializes a list of HTLC entries based on tlv\n// format.",
      "length": 1073,
      "tokens": 127,
      "embedding": []
    },
    {
      "slug": "func deserializeHTLCEntries(r io.Reader) ([]*HTLCEntry, error) {",
      "content": "func deserializeHTLCEntries(r io.Reader) ([]*HTLCEntry, error) {\n\tvar htlcs []*HTLCEntry\n\n\tfor {\n\t\tvar htlc HTLCEntry\n\n\t\t// Create the tlv stream.\n\t\ttlvStream, err := htlc.toTlvStream()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Read the HTLC entry.\n\t\tif _, err := readTlvStream(r, tlvStream); err != nil {\n\t\t\t// We've reached the end when hitting an EOF.\n\t\t\tif err == io.ErrUnexpectedEOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Patch the Incoming field.\n\t\tif htlc.incomingTlv == 1 {\n\t\t\thtlc.Incoming = true\n\t\t}\n\n\t\t// Patch the Amt field.\n\t\thtlc.Amt = btcutil.Amount(htlc.amtTlv)\n\n\t\t// Append the entry.\n\t\thtlcs = append(htlcs, &htlc)\n\t}\n\n\treturn htlcs, nil\n}\n\n// writeTlvStream is a helper function that encodes the tlv stream into the\n// writer.",
      "length": 656,
      "tokens": 111,
      "embedding": []
    },
    {
      "slug": "func writeTlvStream(w io.Writer, s *tlv.Stream) error {",
      "content": "func writeTlvStream(w io.Writer, s *tlv.Stream) error {\n\tvar b bytes.Buffer\n\tif err := s.Encode(&b); err != nil {\n\t\treturn err\n\t}\n\t// Write the stream's length as a varint.\n\terr := tlv.WriteVarInt(w, uint64(b.Len()), &[8]byte{})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif _, err = w.Write(b.Bytes()); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// readTlvStream is a helper function that decodes the tlv stream from the\n// reader.",
      "length": 352,
      "tokens": 65,
      "embedding": []
    },
    {
      "slug": "func readTlvStream(r io.Reader, s *tlv.Stream) (tlv.TypeMap, error) {",
      "content": "func readTlvStream(r io.Reader, s *tlv.Stream) (tlv.TypeMap, error) {\n\tvar bodyLen uint64\n\n\t// Read the stream's length.\n\tbodyLen, err := tlv.ReadVarInt(r, &[8]byte{})\n\tswitch {\n\t// We'll convert any EOFs to ErrUnexpectedEOF, since this results in an\n\t// invalid record.\n\tcase err == io.EOF:\n\t\treturn nil, io.ErrUnexpectedEOF\n\n\t// Other unexpected errors.\n\tcase err != nil:\n\t\treturn nil, err\n\t}\n\n\t// TODO(yy): add overflow check.\n\tlr := io.LimitReader(r, int64(bodyLen))\n\n\treturn s.DecodeWithParsedTypes(lr)\n}\n\n// fetchOldRevocationLog finds the revocation log from the deprecated\n// sub-bucket.",
      "length": 503,
      "tokens": 72,
      "embedding": []
    },
    {
      "slug": "func fetchOldRevocationLog(log kvdb.RBucket,",
      "content": "func fetchOldRevocationLog(log kvdb.RBucket,\n\tupdateNum uint64) (ChannelCommitment, error) {\n\n\tlogEntrykey := makeLogKey(updateNum)\n\tcommitBytes := log.Get(logEntrykey[:])\n\tif commitBytes == nil {\n\t\treturn ChannelCommitment{}, ErrLogEntryNotFound\n\t}\n\n\tcommitReader := bytes.NewReader(commitBytes)\n\treturn deserializeChanCommit(commitReader)\n}\n\n// fetchRevocationLogCompatible finds the revocation log from both the\n// revocationLogBucket and revocationLogBucketDeprecated for compatibility\n// concern. It returns three values,\n//   - RevocationLog, if this is non-nil, it means we've found the log in the\n//     new bucket.\n//   - ChannelCommitment, if this is non-nil, it means we've found the log in the\n//     old bucket.\n//   - error, this can happen if the log cannot be found in neither buckets.",
      "length": 737,
      "tokens": 98,
      "embedding": []
    },
    {
      "slug": "func fetchRevocationLogCompatible(chanBucket kvdb.RBucket,",
      "content": "func fetchRevocationLogCompatible(chanBucket kvdb.RBucket,\n\tupdateNum uint64) (*RevocationLog, *ChannelCommitment, error) {\n\n\t// Look into the new bucket first.\n\tlogBucket := chanBucket.NestedReadBucket(revocationLogBucket)\n\tif logBucket != nil {\n\t\trl, err := fetchRevocationLog(logBucket, updateNum)\n\t\t// We've found the record, no need to visit the old bucket.\n\t\tif err == nil {\n\t\t\treturn &rl, nil, nil\n\t\t}\n\n\t\t// Return the error if it doesn't say the log cannot be found.\n\t\tif err != ErrLogEntryNotFound {\n\t\t\treturn nil, nil, err\n\t\t}\n\t}\n\n\t// Otherwise, look into the old bucket and try to find the log there.\n\toldBucket := chanBucket.NestedReadBucket(revocationLogBucketDeprecated)\n\tif oldBucket != nil {\n\t\tc, err := fetchOldRevocationLog(oldBucket, updateNum)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\n\t\t// Found an old record and return it.\n\t\treturn nil, &c, nil\n\t}\n\n\t// If both the buckets are nil, then the sub-buckets haven't been\n\t// created yet.\n\tif logBucket == nil && oldBucket == nil {\n\t\treturn nil, nil, ErrNoPastDeltas\n\t}\n\n\t// Otherwise, we've tried to query the new bucket but the log cannot be\n\t// found.\n\treturn nil, nil, ErrLogEntryNotFound\n}\n\n// fetchLogBucket returns a read bucket by visiting both the new and the old\n// bucket.",
      "length": 1155,
      "tokens": 188,
      "embedding": []
    },
    {
      "slug": "func fetchLogBucket(chanBucket kvdb.RBucket) (kvdb.RBucket, error) {",
      "content": "func fetchLogBucket(chanBucket kvdb.RBucket) (kvdb.RBucket, error) {\n\tlogBucket := chanBucket.NestedReadBucket(revocationLogBucket)\n\tif logBucket == nil {\n\t\tlogBucket = chanBucket.NestedReadBucket(\n\t\t\trevocationLogBucketDeprecated,\n\t\t)\n\t\tif logBucket == nil {\n\t\t\treturn nil, ErrNoPastDeltas\n\t\t}\n\t}\n\n\treturn logBucket, nil\n}\n\n// deleteLogBucket deletes the both the new and old revocation log buckets.",
      "length": 318,
      "tokens": 39,
      "embedding": []
    },
    {
      "slug": "func deleteLogBucket(chanBucket kvdb.RwBucket) error {",
      "content": "func deleteLogBucket(chanBucket kvdb.RwBucket) error {\n\t// Check if the bucket exists and delete it.\n\tlogBucket := chanBucket.NestedReadWriteBucket(\n\t\trevocationLogBucket,\n\t)\n\tif logBucket != nil {\n\t\terr := chanBucket.DeleteNestedBucket(revocationLogBucket)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// We also check whether the old revocation log bucket exists\n\t// and delete it if so.\n\toldLogBucket := chanBucket.NestedReadWriteBucket(\n\t\trevocationLogBucketDeprecated,\n\t)\n\tif oldLogBucket != nil {\n\t\terr := chanBucket.DeleteNestedBucket(\n\t\t\trevocationLogBucketDeprecated,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n",
      "length": 549,
      "tokens": 75,
      "embedding": []
    }
  ]
}