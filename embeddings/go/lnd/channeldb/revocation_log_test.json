{
  "filepath": "../implementations/go/lnd/channeldb/revocation_log_test.go",
  "package": "channeldb",
  "sections": [
    {
      "slug": "func TestWriteTLVStream(t *testing.T) {",
      "content": "func TestWriteTLVStream(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a dummy tlv stream for testing.\n\tts, err := tlv.NewStream(\n\t\ttlv.MakePrimitiveRecord(testType, &testValue),\n\t)\n\trequire.NoError(t, err)\n\n\t// Write the tlv stream.\n\tbuf := bytes.NewBuffer([]byte{})\n\terr = writeTlvStream(buf, ts)\n\trequire.NoError(t, err)\n\n\t// Check the bytes are written as expected.\n\trequire.Equal(t, testValueBytes, buf.Bytes())\n}\n",
      "length": 358,
      "tokens": 44,
      "embedding": []
    },
    {
      "slug": "func TestReadTLVStream(t *testing.T) {",
      "content": "func TestReadTLVStream(t *testing.T) {\n\tt.Parallel()\n\n\tvar valueRead uint8\n\n\t// Create a dummy tlv stream for testing.\n\tts, err := tlv.NewStream(\n\t\ttlv.MakePrimitiveRecord(testType, &valueRead),\n\t)\n\trequire.NoError(t, err)\n\n\t// Read the tlv stream.\n\tbuf := bytes.NewBuffer(testValueBytes)\n\t_, err = readTlvStream(buf, ts)\n\trequire.NoError(t, err)\n\n\t// Check the bytes are read as expected.\n\trequire.Equal(t, testValue, valueRead)\n}\n",
      "length": 375,
      "tokens": 48,
      "embedding": []
    },
    {
      "slug": "func TestReadTLVStreamErr(t *testing.T) {",
      "content": "func TestReadTLVStreamErr(t *testing.T) {\n\tt.Parallel()\n\n\tvar valueRead uint8\n\n\t// Create a dummy tlv stream for testing.\n\tts, err := tlv.NewStream(\n\t\ttlv.MakePrimitiveRecord(testType, &valueRead),\n\t)\n\trequire.NoError(t, err)\n\n\t// Use empty bytes to cause an EOF.\n\tb := []byte{}\n\n\t// Read the tlv stream.\n\tbuf := bytes.NewBuffer(b)\n\t_, err = readTlvStream(buf, ts)\n\trequire.ErrorIs(t, err, io.ErrUnexpectedEOF)\n\n\t// Check the bytes are not read.\n\trequire.Zero(t, valueRead)\n}\n",
      "length": 413,
      "tokens": 58,
      "embedding": []
    },
    {
      "slug": "func TestSerializeHTLCEntriesEmptyRHash(t *testing.T) {",
      "content": "func TestSerializeHTLCEntriesEmptyRHash(t *testing.T) {\n\tt.Parallel()\n\n\t// Copy the testHTLCEntry.\n\tentry := testHTLCEntry\n\n\t// Set the internal fields to empty values so we can test the bytes are\n\t// padded.\n\tentry.incomingTlv = 0\n\tentry.amtTlv = 0\n\n\t// Write the tlv stream.\n\tbuf := bytes.NewBuffer([]byte{})\n\terr := serializeHTLCEntries(buf, []*HTLCEntry{&entry})\n\trequire.NoError(t, err)\n\n\t// Check the bytes are read as expected.\n\trequire.Equal(t, testHTLCEntryBytes, buf.Bytes())\n}\n",
      "length": 414,
      "tokens": 57,
      "embedding": []
    },
    {
      "slug": "func TestSerializeHTLCEntries(t *testing.T) {",
      "content": "func TestSerializeHTLCEntries(t *testing.T) {\n\tt.Parallel()\n\n\t// Copy the testHTLCEntry.\n\tentry := testHTLCEntry\n\n\t// Create a fake rHash.\n\trHashBytes := bytes.Repeat([]byte{10}, 32)\n\tcopy(entry.RHash[:], rHashBytes)\n\n\t// Construct the serialized bytes.\n\t//\n\t// Exclude the first 3 bytes, which are total length, RHash type and\n\t// RHash length(0).\n\tpartialBytes := testHTLCEntryBytes[3:]\n\n\t// Write the total length and RHash tlv.\n\texpectedBytes := []byte{0x36, 0x0, 0x20}\n\texpectedBytes = append(expectedBytes, rHashBytes...)\n\n\t// Append the rest.\n\texpectedBytes = append(expectedBytes, partialBytes...)\n\n\tbuf := bytes.NewBuffer([]byte{})\n\terr := serializeHTLCEntries(buf, []*HTLCEntry{&entry})\n\trequire.NoError(t, err)\n\n\t// Check the bytes are read as expected.\n\trequire.Equal(t, expectedBytes, buf.Bytes())\n}\n\n// TestSerializeAndDeserializeRevLog tests the serialization and deserialization\n// of various forms of the revocation log.",
      "length": 860,
      "tokens": 105,
      "embedding": []
    },
    {
      "slug": "func TestSerializeAndDeserializeRevLog(t *testing.T) {",
      "content": "func TestSerializeAndDeserializeRevLog(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tname        string\n\t\trevLog      RevocationLog\n\t\trevLogBytes []byte\n\t}{\n\t\t{\n\t\t\tname:        \"with no amount fields\",\n\t\t\trevLog:      testRevocationLogNoAmts,\n\t\t\trevLogBytes: testRevocationLogNoAmtsBytes,\n\t\t},\n\t\t{\n\t\t\tname:        \"with amount fields\",\n\t\t\trevLog:      testRevocationLogWithAmts,\n\t\t\trevLogBytes: testRevocationLogWithAmtsBytes,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\ttestSerializeRevocationLog(\n\t\t\t\tt, &test.revLog, test.revLogBytes,\n\t\t\t)\n\n\t\t\ttestDerializeRevocationLog(\n\t\t\t\tt, &test.revLog, test.revLogBytes,\n\t\t\t)\n\t\t})\n\t}\n}\n",
      "length": 618,
      "tokens": 62,
      "embedding": []
    },
    {
      "slug": "func testSerializeRevocationLog(t *testing.T, rl *RevocationLog,",
      "content": "func testSerializeRevocationLog(t *testing.T, rl *RevocationLog,\n\trevLogBytes []byte) {\n\n\t// Copy the testRevocationLogWithAmts and testHTLCEntry.\n\thtlc := testHTLCEntry\n\trl.HTLCEntries = []*HTLCEntry{&htlc}\n\n\t// Write the tlv stream.\n\tbuf := bytes.NewBuffer([]byte{})\n\terr := serializeRevocationLog(buf, rl)\n\trequire.NoError(t, err)\n\n\t// Check the expected bytes on the body of the revocation log.\n\tbodyIndex := buf.Len() - len(testHTLCEntryBytes)\n\trequire.Equal(t, revLogBytes, buf.Bytes()[:bodyIndex])\n}\n",
      "length": 427,
      "tokens": 50,
      "embedding": []
    },
    {
      "slug": "func testDerializeRevocationLog(t *testing.T, revLog *RevocationLog,",
      "content": "func testDerializeRevocationLog(t *testing.T, revLog *RevocationLog,\n\trevLogBytes []byte) {\n\n\t// Construct the full bytes.\n\trevLogBytes = append(revLogBytes, testHTLCEntryBytes...)\n\n\t// Read the tlv stream.\n\tbuf := bytes.NewBuffer(revLogBytes)\n\trl, err := deserializeRevocationLog(buf)\n\trequire.NoError(t, err)\n\n\t// Check the bytes are read as expected.\n\trequire.Len(t, rl.HTLCEntries, 1)\n\trequire.Equal(t, *revLog, rl)\n}\n",
      "length": 339,
      "tokens": 41,
      "embedding": []
    },
    {
      "slug": "func TestDerializeHTLCEntriesEmptyRHash(t *testing.T) {",
      "content": "func TestDerializeHTLCEntriesEmptyRHash(t *testing.T) {\n\tt.Parallel()\n\n\t// Read the tlv stream.\n\tbuf := bytes.NewBuffer(testHTLCEntryBytes)\n\thtlcs, err := deserializeHTLCEntries(buf)\n\trequire.NoError(t, err)\n\n\t// Check the bytes are read as expected.\n\trequire.Len(t, htlcs, 1)\n\trequire.Equal(t, &testHTLCEntry, htlcs[0])\n}\n",
      "length": 256,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func TestDerializeHTLCEntries(t *testing.T) {",
      "content": "func TestDerializeHTLCEntries(t *testing.T) {\n\tt.Parallel()\n\n\t// Copy the testHTLCEntry.\n\tentry := testHTLCEntry\n\n\t// Create a fake rHash.\n\trHashBytes := bytes.Repeat([]byte{10}, 32)\n\tcopy(entry.RHash[:], rHashBytes)\n\n\t// Construct the serialized bytes.\n\t//\n\t// Exclude the first 3 bytes, which are total length, RHash type and\n\t// RHash length(0).\n\tpartialBytes := testHTLCEntryBytes[3:]\n\n\t// Write the total length and RHash tlv.\n\ttestBytes := append([]byte{0x36, 0x0, 0x20}, rHashBytes...)\n\n\t// Append the rest.\n\ttestBytes = append(testBytes, partialBytes...)\n\n\t// Read the tlv stream.\n\tbuf := bytes.NewBuffer(testBytes)\n\thtlcs, err := deserializeHTLCEntries(buf)\n\trequire.NoError(t, err)\n\n\t// Check the bytes are read as expected.\n\trequire.Len(t, htlcs, 1)\n\trequire.Equal(t, &entry, htlcs[0])\n}\n",
      "length": 723,
      "tokens": 95,
      "embedding": []
    },
    {
      "slug": "func TestFetchLogBucket(t *testing.T) {",
      "content": "func TestFetchLogBucket(t *testing.T) {\n\tt.Parallel()\n\n\tfullDB, err := MakeTestDB(t)\n\trequire.NoError(t, err)\n\n\tbackend := fullDB.ChannelStateDB().backend\n\n\t// Test that when neither of the buckets exists, an error is returned.\n\terr = kvdb.Update(backend, func(tx kvdb.RwTx) error {\n\t\tchanBucket, err := tx.CreateTopLevelBucket(openChannelBucket)\n\t\trequire.NoError(t, err)\n\n\t\t// Check an error is returned when there's no sub bucket.\n\t\t_, err = fetchLogBucket(chanBucket)\n\t\treturn err\n\t}, func() {})\n\trequire.ErrorIs(t, err, ErrNoPastDeltas)\n\n\t// Test a successful fetch.\n\terr = kvdb.Update(backend, func(tx kvdb.RwTx) error {\n\t\tchanBucket, err := tx.CreateTopLevelBucket(openChannelBucket)\n\t\trequire.NoError(t, err)\n\n\t\t_, err = chanBucket.CreateBucket(revocationLogBucket)\n\t\trequire.NoError(t, err)\n\n\t\t// Check an error is returned when there's no sub bucket.\n\t\t_, err = fetchLogBucket(chanBucket)\n\t\treturn err\n\t}, func() {})\n\trequire.NoError(t, err)\n}\n",
      "length": 882,
      "tokens": 106,
      "embedding": []
    },
    {
      "slug": "func TestDeleteLogBucket(t *testing.T) {",
      "content": "func TestDeleteLogBucket(t *testing.T) {\n\tt.Parallel()\n\n\tfullDB, err := MakeTestDB(t)\n\trequire.NoError(t, err)\n\n\tbackend := fullDB.ChannelStateDB().backend\n\n\terr = kvdb.Update(backend, func(tx kvdb.RwTx) error {\n\t\t// Create the buckets.\n\t\tchanBucket, _, err := createTestRevocatoinLogBuckets(tx)\n\t\trequire.NoError(t, err)\n\n\t\t// Create the buckets again should give us an error.\n\t\t_, _, err = createTestRevocatoinLogBuckets(tx)\n\t\trequire.ErrorIs(t, err, kvdb.ErrBucketExists)\n\n\t\t// Delete both buckets.\n\t\terr = deleteLogBucket(chanBucket)\n\t\trequire.NoError(t, err)\n\n\t\t// Create the buckets again should give us NO error.\n\t\t_, _, err = createTestRevocatoinLogBuckets(tx)\n\t\treturn err\n\t}, func() {})\n\trequire.NoError(t, err)\n}\n",
      "length": 657,
      "tokens": 78,
      "embedding": []
    },
    {
      "slug": "func TestPutRevocationLog(t *testing.T) {",
      "content": "func TestPutRevocationLog(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a test commit that has a large htlc output index.\n\ttestHtlc := HTLC{OutputIndex: math.MaxUint16 + 1}\n\ttestCommit := testChannelCommit\n\ttestCommit.Htlcs = []HTLC{testHtlc}\n\n\t// Create a test commit that has a dust HTLC.\n\ttestHtlcDust := HTLC{OutputIndex: -1}\n\ttestCommitDust := testChannelCommit\n\ttestCommitDust.Htlcs = append(testCommitDust.Htlcs, testHtlcDust)\n\n\ttestCases := []struct {\n\t\tname        string\n\t\tcommit      ChannelCommitment\n\t\tourIndex    uint32\n\t\ttheirIndex  uint32\n\t\tnoAmtData   bool\n\t\texpectedErr error\n\t\texpectedLog RevocationLog\n\t}{\n\t\t{\n\t\t\t// Test a normal put operation.\n\t\t\tname:        \"successful put with amount data\",\n\t\t\tcommit:      testChannelCommit,\n\t\t\tourIndex:    0,\n\t\t\ttheirIndex:  1,\n\t\t\texpectedErr: nil,\n\t\t\texpectedLog: testRevocationLogWithAmts,\n\t\t},\n\t\t{\n\t\t\t// Test a normal put operation.\n\t\t\tname:        \"successful put with no amount data\",\n\t\t\tcommit:      testChannelCommit,\n\t\t\tourIndex:    0,\n\t\t\ttheirIndex:  1,\n\t\t\tnoAmtData:   true,\n\t\t\texpectedErr: nil,\n\t\t\texpectedLog: testRevocationLogNoAmts,\n\t\t},\n\t\t{\n\t\t\t// Test our index too big.\n\t\t\tname:        \"our index too big\",\n\t\t\tcommit:      testChannelCommit,\n\t\t\tourIndex:    math.MaxUint16 + 1,\n\t\t\ttheirIndex:  1,\n\t\t\texpectedErr: ErrOutputIndexTooBig,\n\t\t\texpectedLog: RevocationLog{},\n\t\t},\n\t\t{\n\t\t\t// Test their index too big.\n\t\t\tname:        \"their index too big\",\n\t\t\tcommit:      testChannelCommit,\n\t\t\tourIndex:    0,\n\t\t\ttheirIndex:  math.MaxUint16 + 1,\n\t\t\texpectedErr: ErrOutputIndexTooBig,\n\t\t\texpectedLog: RevocationLog{},\n\t\t},\n\t\t{\n\t\t\t// Test htlc output index too big.\n\t\t\tname:        \"htlc index too big\",\n\t\t\tcommit:      testCommit,\n\t\t\tourIndex:    0,\n\t\t\ttheirIndex:  1,\n\t\t\texpectedErr: ErrOutputIndexTooBig,\n\t\t\texpectedLog: RevocationLog{},\n\t\t},\n\t\t{\n\t\t\t// Test dust htlc is not saved.\n\t\t\tname:        \"dust htlc not saved with amout data\",\n\t\t\tcommit:      testCommitDust,\n\t\t\tourIndex:    0,\n\t\t\ttheirIndex:  1,\n\t\t\texpectedErr: nil,\n\t\t\texpectedLog: testRevocationLogWithAmts,\n\t\t},\n\t\t{\n\t\t\t// Test dust htlc is not saved.\n\t\t\tname:        \"dust htlc not saved with no amount data\",\n\t\t\tcommit:      testCommitDust,\n\t\t\tourIndex:    0,\n\t\t\ttheirIndex:  1,\n\t\t\tnoAmtData:   true,\n\t\t\texpectedErr: nil,\n\t\t\texpectedLog: testRevocationLogNoAmts,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\n\t\tfullDB, err := MakeTestDB(t)\n\t\trequire.NoError(t, err)\n\n\t\tbackend := fullDB.ChannelStateDB().backend\n\n\t\t// Construct the testing db transaction.\n\t\tdbTx := func(tx kvdb.RwTx) (RevocationLog, error) {\n\t\t\t// Create the buckets.\n\t\t\t_, bucket, err := createTestRevocatoinLogBuckets(tx)\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// Save the log.\n\t\t\terr = putRevocationLog(\n\t\t\t\tbucket, &tc.commit, tc.ourIndex, tc.theirIndex,\n\t\t\t\ttc.noAmtData,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn RevocationLog{}, err\n\t\t\t}\n\n\t\t\t// Read the saved log.\n\t\t\treturn fetchRevocationLog(\n\t\t\t\tbucket, tc.commit.CommitHeight,\n\t\t\t)\n\t\t}\n\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tvar rl RevocationLog\n\t\t\terr := kvdb.Update(backend, func(tx kvdb.RwTx) error {\n\t\t\t\trecord, err := dbTx(tx)\n\t\t\t\trl = record\n\t\t\t\treturn err\n\t\t\t}, func() {})\n\n\t\t\trequire.Equal(t, tc.expectedErr, err)\n\t\t\trequire.Equal(t, tc.expectedLog, rl)\n\t\t})\n\t}\n}\n",
      "length": 3055,
      "tokens": 359,
      "embedding": []
    },
    {
      "slug": "func TestFetchRevocationLogCompatible(t *testing.T) {",
      "content": "func TestFetchRevocationLogCompatible(t *testing.T) {\n\tt.Parallel()\n\n\tknownHeight := testChannelCommit.CommitHeight\n\tunknownHeight := knownHeight + 1\n\tlogKey := makeLogKey(knownHeight)\n\n\ttestCases := []struct {\n\t\tname         string\n\t\tupdateNum    uint64\n\t\texpectedErr  error\n\t\tcreateRl     bool\n\t\tcreateCommit bool\n\t\texpectRl     bool\n\t\texpectCommit bool\n\t}{\n\t\t{\n\t\t\t// Test we can fetch the new log.\n\t\t\tname:        \"fetch new log\",\n\t\t\tupdateNum:   knownHeight,\n\t\t\texpectedErr: nil,\n\t\t\tcreateRl:    true,\n\t\t\texpectRl:    true,\n\t\t},\n\t\t{\n\t\t\t// Test we can fetch the legacy log.\n\t\t\tname:         \"fetch legacy log\",\n\t\t\tupdateNum:    knownHeight,\n\t\t\texpectedErr:  nil,\n\t\t\tcreateCommit: true,\n\t\t\texpectCommit: true,\n\t\t},\n\t\t{\n\t\t\t// Test we only fetch the new log when both logs exist.\n\t\t\tname:         \"fetch new log only\",\n\t\t\tupdateNum:    knownHeight,\n\t\t\texpectedErr:  nil,\n\t\t\tcreateRl:     true,\n\t\t\tcreateCommit: true,\n\t\t\texpectRl:     true,\n\t\t},\n\t\t{\n\t\t\t// Test no past deltas when the buckets do not exist.\n\t\t\tname:        \"no buckets created\",\n\t\t\tupdateNum:   unknownHeight,\n\t\t\texpectedErr: ErrNoPastDeltas,\n\t\t},\n\t\t{\n\t\t\t// Test no logs found when the height is unknown.\n\t\t\tname:         \"no log found\",\n\t\t\tupdateNum:    unknownHeight,\n\t\t\texpectedErr:  ErrLogEntryNotFound,\n\t\t\tcreateRl:     true,\n\t\t\tcreateCommit: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\n\t\tfullDB, err := MakeTestDB(t)\n\t\trequire.NoError(t, err)\n\n\t\tbackend := fullDB.ChannelStateDB().backend\n\n\t\tvar (\n\t\t\trl     *RevocationLog\n\t\t\tcommit *ChannelCommitment\n\t\t)\n\n\t\t// Setup the buckets and fill the test data if specified.\n\t\terr = kvdb.Update(backend, func(tx kvdb.RwTx) error {\n\t\t\t// Create the root bucket.\n\t\t\tcb, err := tx.CreateTopLevelBucket(openChannelBucket)\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// Create the revocation log if specified.\n\t\t\tif tc.createRl {\n\t\t\t\tlb, err := cb.CreateBucket(revocationLogBucket)\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\terr = putRevocationLog(\n\t\t\t\t\tlb, &testChannelCommit, 0, 1, false,\n\t\t\t\t)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t}\n\n\t\t\t// Create the channel commit if specified.\n\t\t\tif tc.createCommit {\n\t\t\t\tlegacyBucket, err := cb.CreateBucket(\n\t\t\t\t\trevocationLogBucketDeprecated,\n\t\t\t\t)\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tbuf := bytes.NewBuffer([]byte{})\n\t\t\t\terr = serializeChanCommit(\n\t\t\t\t\tbuf, &testChannelCommit,\n\t\t\t\t)\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\terr = legacyBucket.Put(logKey[:], buf.Bytes())\n\t\t\t\trequire.NoError(t, err)\n\t\t\t}\n\n\t\t\treturn nil\n\t\t}, func() {})\n\n\t\t// Construct the testing db transaction.\n\t\tdbTx := func(tx kvdb.RTx) error {\n\t\t\tcb := tx.ReadBucket(openChannelBucket)\n\n\t\t\trl, commit, err = fetchRevocationLogCompatible(\n\t\t\t\tcb, tc.updateNum,\n\t\t\t)\n\t\t\treturn err\n\t\t}\n\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\terr := kvdb.View(backend, dbTx, func() {})\n\t\t\trequire.Equal(t, tc.expectedErr, err)\n\n\t\t\t// Check the expected revocation log is returned.\n\t\t\tif tc.expectRl {\n\t\t\t\trequire.NotNil(t, rl)\n\t\t\t} else {\n\t\t\t\trequire.Nil(t, rl)\n\t\t\t}\n\n\t\t\t// Check the expected channel commit is returned.\n\t\t\tif tc.expectCommit {\n\t\t\t\trequire.NotNil(t, commit)\n\t\t\t} else {\n\t\t\t\trequire.Nil(t, commit)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "length": 2919,
      "tokens": 354,
      "embedding": []
    },
    {
      "slug": "func createTestRevocatoinLogBuckets(tx kvdb.RwTx) (kvdb.RwBucket,",
      "content": "func createTestRevocatoinLogBuckets(tx kvdb.RwTx) (kvdb.RwBucket,\n\tkvdb.RwBucket, error) {\n\n\tchanBucket, err := tx.CreateTopLevelBucket(openChannelBucket)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tlogBucket, err := chanBucket.CreateBucket(revocationLogBucket)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t_, err = chanBucket.CreateBucket(revocationLogBucketDeprecated)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn chanBucket, logBucket, nil\n}\n",
      "length": 368,
      "tokens": 50,
      "embedding": []
    }
  ]
}