{
  "filepath": "../implementations/go/lnd/channeldb/migration21/current/current_codec.go",
  "package": "current",
  "sections": [
    {
      "slug": "func writeOutpoint(w io.Writer, o *wire.OutPoint) error {",
      "content": "func writeOutpoint(w io.Writer, o *wire.OutPoint) error {\n\tif _, err := w.Write(o.Hash[:]); err != nil {\n\t\treturn err\n\t}\n\tif err := binary.Write(w, byteOrder, o.Index); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// readOutpoint reads an outpoint from the passed reader that was previously\n// written using the writeOutpoint struct.",
      "length": 264,
      "tokens": 46,
      "embedding": []
    },
    {
      "slug": "func readOutpoint(r io.Reader, o *wire.OutPoint) error {",
      "content": "func readOutpoint(r io.Reader, o *wire.OutPoint) error {\n\tif _, err := io.ReadFull(r, o.Hash[:]); err != nil {\n\t\treturn err\n\t}\n\tif err := binary.Read(r, byteOrder, &o.Index); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// UnknownElementType is an error returned when the codec is unable to encode or\n// decode a particular type.",
      "length": 261,
      "tokens": 48,
      "embedding": []
    },
    {
      "slug": "type UnknownElementType struct {",
      "content": "type UnknownElementType struct {\n\tmethod  string\n\telement interface{}\n}\n\n// NewUnknownElementType creates a new UnknownElementType error from the passed\n// method name and element.",
      "length": 142,
      "tokens": 20,
      "embedding": []
    },
    {
      "slug": "func NewUnknownElementType(method string, el interface{}) UnknownElementType {",
      "content": "func NewUnknownElementType(method string, el interface{}) UnknownElementType {\n\treturn UnknownElementType{method: method, element: el}\n}\n\n// Error returns the name of the method that encountered the error, as well as\n// the type that was unsupported.",
      "length": 167,
      "tokens": 27,
      "embedding": []
    },
    {
      "slug": "func (e UnknownElementType) Error() string {",
      "content": "func (e UnknownElementType) Error() string {\n\treturn fmt.Sprintf(\"Unknown type in %s: %T\", e.method, e.element)\n}\n\n// WriteElement is a one-stop shop to write the big endian representation of\n// any element which is to be serialized for storage on disk. The passed\n// io.Writer should be backed by an appropriately sized byte slice, or be able\n// to dynamically expand to accommodate additional data.",
      "length": 349,
      "tokens": 58,
      "embedding": []
    },
    {
      "slug": "func WriteElement(w io.Writer, element interface{}) error {",
      "content": "func WriteElement(w io.Writer, element interface{}) error {\n\tswitch e := element.(type) {\n\tcase keychain.KeyDescriptor:\n\t\tif err := binary.Write(w, byteOrder, e.Family); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := binary.Write(w, byteOrder, e.Index); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif e.PubKey != nil {\n\t\t\tif err := binary.Write(w, byteOrder, true); err != nil {\n\t\t\t\treturn fmt.Errorf(\"error writing serialized element: %s\", err)\n\t\t\t}\n\n\t\t\treturn WriteElement(w, e.PubKey)\n\t\t}\n\n\t\treturn binary.Write(w, byteOrder, false)\n\n\tcase chainhash.Hash:\n\t\tif _, err := w.Write(e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase wire.OutPoint:\n\t\treturn writeOutpoint(w, &e)\n\n\tcase lnwire.ShortChannelID:\n\t\tif err := binary.Write(w, byteOrder, e.ToUint64()); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase lnwire.ChannelID:\n\t\tif _, err := w.Write(e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase int64, uint64:\n\t\tif err := binary.Write(w, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase uint32:\n\t\tif err := binary.Write(w, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase int32:\n\t\tif err := binary.Write(w, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase uint16:\n\t\tif err := binary.Write(w, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase uint8:\n\t\tif err := binary.Write(w, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase bool:\n\t\tif err := binary.Write(w, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase btcutil.Amount:\n\t\tif err := binary.Write(w, byteOrder, uint64(e)); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase lnwire.MilliSatoshi:\n\t\tif err := binary.Write(w, byteOrder, uint64(e)); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *btcec.PrivateKey:\n\t\tb := e.Serialize()\n\t\tif _, err := w.Write(b); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *btcec.PublicKey:\n\t\tb := e.SerializeCompressed()\n\t\tif _, err := w.Write(b); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase shachain.Producer:\n\t\treturn e.Encode(w)\n\n\tcase shachain.Store:\n\t\treturn e.Encode(w)\n\n\tcase *wire.MsgTx:\n\t\treturn e.Serialize(w)\n\n\tcase [32]byte:\n\t\tif _, err := w.Write(e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase []byte:\n\t\tif err := wire.WriteVarBytes(w, 0, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase lnwire.Message:\n\t\tvar msgBuf bytes.Buffer\n\t\tif _, err := lnwire.WriteMessage(&msgBuf, e, 0); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tmsgLen := uint16(len(msgBuf.Bytes()))\n\t\tif err := WriteElements(w, msgLen); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif _, err := w.Write(msgBuf.Bytes()); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase common.ClosureType:\n\t\tif err := binary.Write(w, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase lnwire.FundingFlag:\n\t\tif err := binary.Write(w, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tdefault:\n\t\treturn UnknownElementType{\"WriteElement\", e}\n\t}\n\n\treturn nil\n}\n\n// WriteElements is writes each element in the elements slice to the passed\n// io.Writer using WriteElement.",
      "length": 2629,
      "tokens": 409,
      "embedding": []
    },
    {
      "slug": "func WriteElements(w io.Writer, elements ...interface{}) error {",
      "content": "func WriteElements(w io.Writer, elements ...interface{}) error {\n\tfor _, element := range elements {\n\t\terr := WriteElement(w, element)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// ReadElement is a one-stop utility function to deserialize any datastructure\n// encoded using the serialization format of the database.",
      "length": 251,
      "tokens": 43,
      "embedding": []
    },
    {
      "slug": "func ReadElement(r io.Reader, element interface{}) error {",
      "content": "func ReadElement(r io.Reader, element interface{}) error {\n\tswitch e := element.(type) {\n\tcase *keychain.KeyDescriptor:\n\t\tif err := binary.Read(r, byteOrder, &e.Family); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := binary.Read(r, byteOrder, &e.Index); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvar hasPubKey bool\n\t\tif err := binary.Read(r, byteOrder, &hasPubKey); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif hasPubKey {\n\t\t\treturn ReadElement(r, &e.PubKey)\n\t\t}\n\n\tcase *chainhash.Hash:\n\t\tif _, err := io.ReadFull(r, e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *wire.OutPoint:\n\t\treturn readOutpoint(r, e)\n\n\tcase *lnwire.ShortChannelID:\n\t\tvar a uint64\n\t\tif err := binary.Read(r, byteOrder, &a); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*e = lnwire.NewShortChanIDFromInt(a)\n\n\tcase *lnwire.ChannelID:\n\t\tif _, err := io.ReadFull(r, e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *int64, *uint64:\n\t\tif err := binary.Read(r, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *uint32:\n\t\tif err := binary.Read(r, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *int32:\n\t\tif err := binary.Read(r, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *uint16:\n\t\tif err := binary.Read(r, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *uint8:\n\t\tif err := binary.Read(r, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *bool:\n\t\tif err := binary.Read(r, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *btcutil.Amount:\n\t\tvar a uint64\n\t\tif err := binary.Read(r, byteOrder, &a); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t*e = btcutil.Amount(a)\n\n\tcase *lnwire.MilliSatoshi:\n\t\tvar a uint64\n\t\tif err := binary.Read(r, byteOrder, &a); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t*e = lnwire.MilliSatoshi(a)\n\n\tcase **btcec.PrivateKey:\n\t\tvar b [btcec.PrivKeyBytesLen]byte\n\t\tif _, err := io.ReadFull(r, b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tpriv, _ := btcec.PrivKeyFromBytes(b[:])\n\t\t*e = priv\n\n\tcase **btcec.PublicKey:\n\t\tvar b [btcec.PubKeyBytesLenCompressed]byte\n\t\tif _, err := io.ReadFull(r, b[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tpubKey, err := btcec.ParsePubKey(b[:])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*e = pubKey\n\n\tcase *shachain.Producer:\n\t\tvar root [32]byte\n\t\tif _, err := io.ReadFull(r, root[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// TODO(roasbeef): remove\n\t\tproducer, err := shachain.NewRevocationProducerFromBytes(root[:])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t*e = producer\n\n\tcase *shachain.Store:\n\t\tstore, err := shachain.NewRevocationStoreFromBytes(r)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t*e = store\n\n\tcase **wire.MsgTx:\n\t\ttx := wire.NewMsgTx(2)\n\t\tif err := tx.Deserialize(r); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t*e = tx\n\n\tcase *[32]byte:\n\t\tif _, err := io.ReadFull(r, e[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *[]byte:\n\t\tbytes, err := wire.ReadVarBytes(r, 0, 66000, \"[]byte\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t*e = bytes\n\n\tcase *lnwire.Message:\n\t\tvar msgLen uint16\n\t\tif err := ReadElement(r, &msgLen); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tmsgReader := io.LimitReader(r, int64(msgLen))\n\t\tmsg, err := lnwire.ReadMessage(msgReader, 0)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t*e = msg\n\n\tcase *common.ClosureType:\n\t\tif err := binary.Read(r, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *lnwire.FundingFlag:\n\t\tif err := binary.Read(r, byteOrder, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tdefault:\n\t\treturn UnknownElementType{\"ReadElement\", e}\n\t}\n\n\treturn nil\n}\n\n// ReadElements deserializes a variable number of elements into the passed\n// io.Reader, with each element being deserialized according to the ReadElement\n// function.",
      "length": 3269,
      "tokens": 509,
      "embedding": []
    },
    {
      "slug": "func ReadElements(r io.Reader, elements ...interface{}) error {",
      "content": "func ReadElements(r io.Reader, elements ...interface{}) error {\n\tfor _, element := range elements {\n\t\terr := ReadElement(r, element)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n",
      "length": 114,
      "tokens": 23,
      "embedding": []
    }
  ]
}