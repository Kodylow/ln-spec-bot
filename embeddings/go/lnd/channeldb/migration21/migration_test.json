{
  "filepath": "../implementations/go/lnd/channeldb/migration21/migration_test.go",
  "package": "migration21",
  "sections": [
    {
      "slug": "func TestMigrateDatabaseWireMessages(t *testing.T) {",
      "content": "func TestMigrateDatabaseWireMessages(t *testing.T) {\n\tvar pub [33]byte\n\tcopy(pub[:], key[:])\n\n\tmigtest.ApplyMigration(\n\t\tt,\n\t\tfunc(tx kvdb.RwTx) error {\n\t\t\tt.Helper()\n\n\t\t\t// First, we'll insert a new fake channel (well just\n\t\t\t// the commitment diff) at the expected location\n\t\t\t// on-disk.\n\t\t\topenChanBucket, err := tx.CreateTopLevelBucket(\n\t\t\t\topenChannelBucket,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tnodeBucket, err := openChanBucket.CreateBucket(pub[:])\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tchainBucket, err := nodeBucket.CreateBucket(key[:])\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tchanBucket, err := chainBucket.CreateBucket(key[:])\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tvar b bytes.Buffer\n\t\t\terr = legacy.SerializeCommitDiff(&b, testCommitDiff)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\terr = chanBucket.Put(commitDiffKey, b.Bytes())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tvar logUpdateBuf bytes.Buffer\n\t\t\terr = legacy.SerializeLogUpdates(\n\t\t\t\t&logUpdateBuf, testCommitDiff.LogUpdates,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// We'll re-use the same log updates to insert as a set\n\t\t\t// of un-acked and unsigned pending log updateas as well.\n\t\t\terr = chanBucket.Put(\n\t\t\t\tunsignedAckedUpdatesKey, logUpdateBuf.Bytes(),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\terr = chanBucket.Put(\n\t\t\t\tremoteUnsignedLocalUpdatesKey, logUpdateBuf.Bytes(),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Next, we'll insert a sample closed channel summary\n\t\t\t// for the 2nd part of our migration.\n\t\t\tclosedChanBucket, err := tx.CreateTopLevelBucket(\n\t\t\t\tclosedChannelBucket,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tvar summaryBuf bytes.Buffer\n\t\t\terr = legacy.SerializeChannelCloseSummary(\n\t\t\t\t&summaryBuf, testChanCloseSummary,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\terr = closedChanBucket.Put(key[:], summaryBuf.Bytes())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Create a few forwarding packages to migrate.\n\t\t\tfor i := uint64(100); i < 200; i++ {\n\t\t\t\tshortChanID := lnwire.NewShortChanIDFromInt(i)\n\t\t\t\tpackager := legacy.NewChannelPackager(shortChanID)\n\t\t\t\tfwdPkg := common.NewFwdPkg(shortChanID, 0, adds, settleFails)\n\n\t\t\t\tif err := packager.AddFwdPkg(tx, fwdPkg); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Finally, we need to insert a sample network result\n\t\t\t// as well for the final component of our migration.\n\t\t\tvar netResBuf bytes.Buffer\n\t\t\terr = legacy.SerializeNetworkResult(\n\t\t\t\t&netResBuf, testNetworkResult,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tnetworkResults, err := tx.CreateTopLevelBucket(\n\t\t\t\tnetworkResultStoreBucketKey,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\treturn networkResults.Put(\n\t\t\t\tnetResultKey, netResBuf.Bytes(),\n\t\t\t)\n\t\t},\n\t\tfunc(tx kvdb.RwTx) error {\n\t\t\tt.Helper()\n\n\t\t\t// We'll now read the commit diff from disk using the\n\t\t\t// _new_ decoding method. This should match the commit\n\t\t\t// diff we inserted in the pre-migration step.\n\t\t\topenChanBucket := tx.ReadWriteBucket(openChannelBucket)\n\t\t\tnodeBucket := openChanBucket.NestedReadWriteBucket(\n\t\t\t\tpub[:],\n\t\t\t)\n\t\t\tchainBucket := nodeBucket.NestedReadWriteBucket(key[:])\n\t\t\tchanBucket := chainBucket.NestedReadWriteBucket(key[:])\n\n\t\t\tcommitDiffBytes := chanBucket.Get(commitDiffKey)\n\t\t\tif commitDiffBytes == nil {\n\t\t\t\treturn fmt.Errorf(\"no commit diff found\")\n\t\t\t}\n\n\t\t\tnewCommitDiff, err := current.DeserializeCommitDiff(\n\t\t\t\tbytes.NewReader(commitDiffBytes),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"unable to decode commit \"+\n\t\t\t\t\t\"diff: %v\", err)\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(newCommitDiff, testCommitDiff) {\n\t\t\t\treturn fmt.Errorf(\"diff mismatch: expected \"+\n\t\t\t\t\t\"%v, got %v\", spew.Sdump(testCommitDiff),\n\t\t\t\t\tspew.Sdump(newCommitDiff))\n\t\t\t}\n\n\t\t\t// Next, we'll ensure that the un-acked updates match\n\t\t\t// up as well.\n\t\t\tupdateBytes := chanBucket.Get(unsignedAckedUpdatesKey)\n\t\t\tif updateBytes == nil {\n\t\t\t\treturn fmt.Errorf(\"no update bytes found\")\n\t\t\t}\n\n\t\t\tnewUpdates, err := current.DeserializeLogUpdates(\n\t\t\t\tbytes.NewReader(updateBytes),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(\n\t\t\t\tnewUpdates, testCommitDiff.LogUpdates,\n\t\t\t) {\n\n\t\t\t\treturn fmt.Errorf(\"updates mismatch: expected \"+\n\t\t\t\t\t\"%v, got %v\",\n\t\t\t\t\tspew.Sdump(testCommitDiff.LogUpdates),\n\t\t\t\t\tspew.Sdump(newUpdates))\n\t\t\t}\n\n\t\t\tupdateBytes = chanBucket.Get(remoteUnsignedLocalUpdatesKey)\n\t\t\tif updateBytes == nil {\n\t\t\t\treturn fmt.Errorf(\"no update bytes found\")\n\t\t\t}\n\n\t\t\tnewUpdates, err = current.DeserializeLogUpdates(\n\t\t\t\tbytes.NewReader(updateBytes),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(\n\t\t\t\tnewUpdates, testCommitDiff.LogUpdates,\n\t\t\t) {\n\n\t\t\t\treturn fmt.Errorf(\"updates mismatch: expected \"+\n\t\t\t\t\t\"%v, got %v\",\n\t\t\t\t\tspew.Sdump(testCommitDiff.LogUpdates),\n\t\t\t\t\tspew.Sdump(newUpdates))\n\t\t\t}\n\n\t\t\t// Next, we'll ensure that the inserted close channel\n\t\t\t// summary bytes also mach up with what we inserted in\n\t\t\t// the prior step.\n\t\t\tclosedChanBucket := tx.ReadWriteBucket(\n\t\t\t\tclosedChannelBucket,\n\t\t\t)\n\t\t\tif closedChannelBucket == nil {\n\t\t\t\treturn fmt.Errorf(\"no closed channels found\")\n\t\t\t}\n\n\t\t\tchanSummaryBytes := closedChanBucket.Get(key[:])\n\t\t\tnewChanCloseSummary, err := current.DeserializeCloseChannelSummary(\n\t\t\t\tbytes.NewReader(chanSummaryBytes),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(\n\t\t\t\tnewChanCloseSummary, testChanCloseSummary,\n\t\t\t) {\n\n\t\t\t\treturn fmt.Errorf(\"summary mismatch: expected \"+\n\t\t\t\t\t\"%v, got %v\",\n\t\t\t\t\tspew.Sdump(testChanCloseSummary),\n\t\t\t\t\tspew.Sdump(newChanCloseSummary))\n\t\t\t}\n\n\t\t\t// Fetch all forwarding packages.\n\t\t\tfor i := uint64(100); i < 200; i++ {\n\t\t\t\tshortChanID := lnwire.NewShortChanIDFromInt(i)\n\t\t\t\tpackager := current.NewChannelPackager(shortChanID)\n\n\t\t\t\tfwdPkgs, err := packager.LoadFwdPkgs(tx)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tif len(fwdPkgs) != 1 {\n\t\t\t\t\treturn fmt.Errorf(\"expected 1 pkg\")\n\t\t\t\t}\n\n\t\t\t\tog := common.NewFwdPkg(shortChanID, 0, adds, settleFails)\n\n\t\t\t\t// Check that we deserialized the packages correctly.\n\t\t\t\tif !reflect.DeepEqual(fwdPkgs[0], og) {\n\t\t\t\t\treturn fmt.Errorf(\"res mismatch: expected \"+\n\t\t\t\t\t\t\"%v, got %v\",\n\t\t\t\t\t\tspew.Sdump(fwdPkgs[0]),\n\t\t\t\t\t\tspew.Sdump(og))\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Finally, we'll check the network results to ensure\n\t\t\t// that was migrated properly as well.\n\t\t\tnetworkResults := tx.ReadBucket(\n\t\t\t\tnetworkResultStoreBucketKey,\n\t\t\t)\n\t\t\tif networkResults == nil {\n\t\t\t\treturn fmt.Errorf(\"no net results found\")\n\t\t\t}\n\n\t\t\tnetResBytes := networkResults.Get(netResultKey)\n\t\t\tif netResBytes == nil {\n\t\t\t\treturn fmt.Errorf(\"no network res found\")\n\t\t\t}\n\n\t\t\tnewNetRes, err := current.DeserializeNetworkResult(\n\t\t\t\tbytes.NewReader(netResBytes),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(newNetRes, testNetworkResult) {\n\t\t\t\treturn fmt.Errorf(\"res mismatch: expected \"+\n\t\t\t\t\t\"%v, got %v\",\n\t\t\t\t\tspew.Sdump(testNetworkResult),\n\t\t\t\t\tspew.Sdump(newNetRes))\n\t\t\t}\n\n\t\t\treturn nil\n\t\t},\n\t\tMigrateDatabaseWireMessages,\n\t\tfalse,\n\t)\n}\n",
      "length": 6622,
      "tokens": 763,
      "embedding": []
    }
  ]
}