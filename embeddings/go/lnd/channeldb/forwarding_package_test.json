{
  "filepath": "../implementations/go/lnd/channeldb/forwarding_package_test.go",
  "package": "channeldb_test",
  "sections": [
    {
      "slug": "func TestPkgFilterBruteForce(t *testing.T) {",
      "content": "func TestPkgFilterBruteForce(t *testing.T) {\n\tt.Parallel()\n\n\tcheckPkgFilterRange(t, 1000)\n}\n\n// checkPkgFilterRange verifies the behavior of a pkg filter when doing a linear\n// insertion of `high` elements. This is primarily to test that IsFull functions\n// properly for all relevant sizes of `high`.",
      "length": 248,
      "tokens": 38,
      "embedding": []
    },
    {
      "slug": "func checkPkgFilterRange(t *testing.T, high int) {",
      "content": "func checkPkgFilterRange(t *testing.T, high int) {\n\tfor i := uint16(0); i < uint16(high); i++ {\n\t\tf := channeldb.NewPkgFilter(i)\n\n\t\tif f.Count() != i {\n\t\t\tt.Fatalf(\"pkg filter count=%d is actually %d\",\n\t\t\t\ti, f.Count())\n\t\t}\n\t\tcheckPkgFilterEncodeDecode(t, i, f)\n\n\t\tfor j := uint16(0); j < i; j++ {\n\t\t\tif f.Contains(j) {\n\t\t\t\tt.Fatalf(\"pkg filter count=%d contains %d \"+\n\t\t\t\t\t\"before being added\", i, j)\n\t\t\t}\n\n\t\t\tf.Set(j)\n\t\t\tcheckPkgFilterEncodeDecode(t, i, f)\n\n\t\t\tif !f.Contains(j) {\n\t\t\t\tt.Fatalf(\"pkg filter count=%d missing %d \"+\n\t\t\t\t\t\"after being added\", i, j)\n\t\t\t}\n\n\t\t\tif j < i-1 && f.IsFull() {\n\t\t\t\tt.Fatalf(\"pkg filter count=%d already full\", i)\n\t\t\t}\n\t\t}\n\n\t\tif !f.IsFull() {\n\t\t\tt.Fatalf(\"pkg filter count=%d not full\", i)\n\t\t}\n\t\tcheckPkgFilterEncodeDecode(t, i, f)\n\t}\n}\n\n// TestPkgFilterRand uses a random permutation to verify the proper behavior of\n// the pkg filter if the entries are not inserted in-order.",
      "length": 827,
      "tokens": 125,
      "embedding": []
    },
    {
      "slug": "func TestPkgFilterRand(t *testing.T) {",
      "content": "func TestPkgFilterRand(t *testing.T) {\n\tt.Parallel()\n\n\tcheckPkgFilterRand(t, 3, 17)\n}\n\n// checkPkgFilterRand checks the behavior of a pkg filter by randomly inserting\n// indices and asserting the invariants. The order in which indices are inserted\n// is parameterized by a base `b` coprime to `p`, and using modular\n// exponentiation to generate all elements in [1,p).",
      "length": 321,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func checkPkgFilterRand(t *testing.T, b, p uint16) {",
      "content": "func checkPkgFilterRand(t *testing.T, b, p uint16) {\n\tf := channeldb.NewPkgFilter(p)\n\tvar j = b\n\tfor i := uint16(1); i < p; i++ {\n\t\tif f.Contains(j) {\n\t\t\tt.Fatalf(\"pkg filter contains %d-%d \"+\n\t\t\t\t\"before being added\", i, j)\n\t\t}\n\n\t\tf.Set(j)\n\t\tcheckPkgFilterEncodeDecode(t, i, f)\n\n\t\tif !f.Contains(j) {\n\t\t\tt.Fatalf(\"pkg filter missing %d-%d \"+\n\t\t\t\t\"after being added\", i, j)\n\t\t}\n\n\t\tif i < p-1 && f.IsFull() {\n\t\t\tt.Fatalf(\"pkg filter %d already full\", i)\n\t\t}\n\t\tcheckPkgFilterEncodeDecode(t, i, f)\n\n\t\tj = (b * j) % p\n\t}\n\n\t// Set 0 independently, since it will never be emitted by the generator.\n\tf.Set(0)\n\tcheckPkgFilterEncodeDecode(t, p, f)\n\n\tif !f.IsFull() {\n\t\tt.Fatalf(\"pkg filter count=%d not full\", p)\n\t}\n\tcheckPkgFilterEncodeDecode(t, p, f)\n}\n\n// checkPkgFilterEncodeDecode tests the serialization of a pkg filter by:\n//  1. writing it to a buffer\n//  2. verifying the number of bytes written matches the filter's Size()\n//  3. reconstructing the filter decoding the bytes\n//  4. checking that the two filters are the same according to Equal",
      "length": 953,
      "tokens": 154,
      "embedding": []
    },
    {
      "slug": "func checkPkgFilterEncodeDecode(t *testing.T, i uint16, f *channeldb.PkgFilter) {",
      "content": "func checkPkgFilterEncodeDecode(t *testing.T, i uint16, f *channeldb.PkgFilter) {\n\tvar b bytes.Buffer\n\tif err := f.Encode(&b); err != nil {\n\t\tt.Fatalf(\"unable to serialize pkg filter: %v\", err)\n\t}\n\n\t// +2 for uint16 length\n\tsize := uint16(len(b.Bytes()))\n\tif size != f.Size() {\n\t\tt.Fatalf(\"pkg filter count=%d serialized size differs, \"+\n\t\t\t\"Size(): %d, len(bytes): %v\", i, f.Size(), size)\n\t}\n\n\treader := bytes.NewReader(b.Bytes())\n\n\tf2 := &channeldb.PkgFilter{}\n\tif err := f2.Decode(reader); err != nil {\n\t\tt.Fatalf(\"unable to deserialize pkg filter: %v\", err)\n\t}\n\n\tif !f.Equal(f2) {\n\t\tt.Fatalf(\"pkg filter count=%v does is not equal \"+\n\t\t\t\"after deserialization, want: %v, got %v\",\n\t\t\ti, f, f2)\n\t}\n}\n\nvar (\n\tchanID = lnwire.NewChanIDFromOutPoint(&wire.OutPoint{})\n\n\tadds = []channeldb.LogUpdate{\n\t\t{\n\t\t\tLogIndex: 0,\n\t\t\tUpdateMsg: &lnwire.UpdateAddHTLC{\n\t\t\t\tChanID:      chanID,\n\t\t\t\tID:          1,\n\t\t\t\tAmount:      100,\n\t\t\t\tExpiry:      1000,\n\t\t\t\tPaymentHash: [32]byte{0},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tLogIndex: 1,\n\t\t\tUpdateMsg: &lnwire.UpdateAddHTLC{\n\t\t\t\tChanID:      chanID,\n\t\t\t\tID:          1,\n\t\t\t\tAmount:      101,\n\t\t\t\tExpiry:      1001,\n\t\t\t\tPaymentHash: [32]byte{1},\n\t\t\t},\n\t\t},\n\t}\n\n\tsettleFails = []channeldb.LogUpdate{\n\t\t{\n\t\t\tLogIndex: 2,\n\t\t\tUpdateMsg: &lnwire.UpdateFulfillHTLC{\n\t\t\t\tChanID:          chanID,\n\t\t\t\tID:              0,\n\t\t\t\tPaymentPreimage: [32]byte{0},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tLogIndex: 3,\n\t\t\tUpdateMsg: &lnwire.UpdateFailHTLC{\n\t\t\t\tChanID: chanID,\n\t\t\t\tID:     1,\n\t\t\t\tReason: []byte{},\n\t\t\t},\n\t\t},\n\t}\n)\n\n// TestPackagerEmptyFwdPkg checks that the state transitions exhibited by a\n// forwarding package that contains no adds, fails or settles. We expect that\n// the fwdpkg reaches FwdStateCompleted immediately after writing the forwarding\n// decision via SetFwdFilter.",
      "length": 1614,
      "tokens": 202,
      "embedding": []
    },
    {
      "slug": "func TestPackagerEmptyFwdPkg(t *testing.T) {",
      "content": "func TestPackagerEmptyFwdPkg(t *testing.T) {\n\tt.Parallel()\n\n\tdb := makeFwdPkgDB(t, \"\")\n\n\tshortChanID := lnwire.NewShortChanIDFromInt(1)\n\tpackager := channeldb.NewChannelPackager(shortChanID)\n\n\t// To begin, there should be no forwarding packages on disk.\n\tfwdPkgs := loadFwdPkgs(t, db, packager)\n\tif len(fwdPkgs) != 0 {\n\t\tt.Fatalf(\"no forwarding packages should exist, found %d\", len(fwdPkgs))\n\t}\n\n\t// Next, create and write a new forwarding package with no htlcs.\n\tfwdPkg := channeldb.NewFwdPkg(shortChanID, 0, nil, nil)\n\n\tif err := kvdb.Update(db, func(tx kvdb.RwTx) error {\n\t\treturn packager.AddFwdPkg(tx, fwdPkg)\n\t}, func() {}); err != nil {\n\t\tt.Fatalf(\"unable to add fwd pkg: %v\", err)\n\t}\n\n\t// There should now be one fwdpkg on disk. Since no forwarding decision\n\t// has been written, we expect it to be FwdStateLockedIn. With no HTLCs,\n\t// the ack filter will have no elements, and should always return true.\n\tfwdPkgs = loadFwdPkgs(t, db, packager)\n\tif len(fwdPkgs) != 1 {\n\t\tt.Fatalf(\"expected 1 fwdpkg, instead found %d\", len(fwdPkgs))\n\t}\n\tassertFwdPkgState(t, fwdPkgs[0], channeldb.FwdStateLockedIn)\n\tassertFwdPkgNumAddsSettleFails(t, fwdPkgs[0], 0, 0)\n\tassertAckFilterIsFull(t, fwdPkgs[0], true)\n\n\t// Now, write the forwarding decision. In this case, its just an empty\n\t// fwd filter.\n\tif err := kvdb.Update(db, func(tx kvdb.RwTx) error {\n\t\treturn packager.SetFwdFilter(tx, fwdPkg.Height, fwdPkg.FwdFilter)\n\t}, func() {}); err != nil {\n\t\tt.Fatalf(\"unable to set fwdfiter: %v\", err)\n\t}\n\n\t// We should still have one package on disk. Since the forwarding\n\t// decision has been written, it will minimally be in FwdStateProcessed.\n\t// However with no htlcs, it should leap frog to FwdStateCompleted.\n\tfwdPkgs = loadFwdPkgs(t, db, packager)\n\tif len(fwdPkgs) != 1 {\n\t\tt.Fatalf(\"expected 1 fwdpkg, instead found %d\", len(fwdPkgs))\n\t}\n\tassertFwdPkgState(t, fwdPkgs[0], channeldb.FwdStateCompleted)\n\tassertFwdPkgNumAddsSettleFails(t, fwdPkgs[0], 0, 0)\n\tassertAckFilterIsFull(t, fwdPkgs[0], true)\n\n\t// Lastly, remove the completed forwarding package from disk.\n\tif err := kvdb.Update(db, func(tx kvdb.RwTx) error {\n\t\treturn packager.RemovePkg(tx, fwdPkg.Height)\n\t}, func() {}); err != nil {\n\t\tt.Fatalf(\"unable to remove fwdpkg: %v\", err)\n\t}\n\n\t// Check that the fwd package was actually removed.\n\tfwdPkgs = loadFwdPkgs(t, db, packager)\n\tif len(fwdPkgs) != 0 {\n\t\tt.Fatalf(\"no forwarding packages should exist, found %d\", len(fwdPkgs))\n\t}\n}\n\n// TestPackagerOnlyAdds checks that the fwdpkg does not reach FwdStateCompleted\n// as soon as all the adds in the package have been acked using AckAddHtlcs.",
      "length": 2481,
      "tokens": 344,
      "embedding": []
    },
    {
      "slug": "func TestPackagerOnlyAdds(t *testing.T) {",
      "content": "func TestPackagerOnlyAdds(t *testing.T) {\n\tt.Parallel()\n\n\tdb := makeFwdPkgDB(t, \"\")\n\n\tshortChanID := lnwire.NewShortChanIDFromInt(1)\n\tpackager := channeldb.NewChannelPackager(shortChanID)\n\n\t// To begin, there should be no forwarding packages on disk.\n\tfwdPkgs := loadFwdPkgs(t, db, packager)\n\tif len(fwdPkgs) != 0 {\n\t\tt.Fatalf(\"no forwarding packages should exist, found %d\", len(fwdPkgs))\n\t}\n\n\t// Next, create and write a new forwarding package that only has add\n\t// htlcs.\n\tfwdPkg := channeldb.NewFwdPkg(shortChanID, 0, adds, nil)\n\n\tnAdds := len(adds)\n\n\tif err := kvdb.Update(db, func(tx kvdb.RwTx) error {\n\t\treturn packager.AddFwdPkg(tx, fwdPkg)\n\t}, func() {}); err != nil {\n\t\tt.Fatalf(\"unable to add fwd pkg: %v\", err)\n\t}\n\n\t// There should now be one fwdpkg on disk. Since no forwarding decision\n\t// has been written, we expect it to be FwdStateLockedIn. The package\n\t// has unacked add HTLCs, so the ack filter should not be full.\n\tfwdPkgs = loadFwdPkgs(t, db, packager)\n\tif len(fwdPkgs) != 1 {\n\t\tt.Fatalf(\"expected 1 fwdpkg, instead found %d\", len(fwdPkgs))\n\t}\n\tassertFwdPkgState(t, fwdPkgs[0], channeldb.FwdStateLockedIn)\n\tassertFwdPkgNumAddsSettleFails(t, fwdPkgs[0], nAdds, 0)\n\tassertAckFilterIsFull(t, fwdPkgs[0], false)\n\n\t// Now, write the forwarding decision. Since we have not explicitly\n\t// added any adds to the fwdfilter, this would indicate that all of the\n\t// adds were 1) settled locally by this link (exit hop), or 2) the htlc\n\t// was failed locally.\n\tif err := kvdb.Update(db, func(tx kvdb.RwTx) error {\n\t\treturn packager.SetFwdFilter(tx, fwdPkg.Height, fwdPkg.FwdFilter)\n\t}, func() {}); err != nil {\n\t\tt.Fatalf(\"unable to set fwdfiter: %v\", err)\n\t}\n\n\tfor i := range adds {\n\t\t// We should still have one package on disk. Since the forwarding\n\t\t// decision has been written, it will minimally be in FwdStateProcessed.\n\t\t// However not allf of the HTLCs have been acked, so should not\n\t\t// have advanced further.\n\t\tfwdPkgs = loadFwdPkgs(t, db, packager)\n\t\tif len(fwdPkgs) != 1 {\n\t\t\tt.Fatalf(\"expected 1 fwdpkg, instead found %d\", len(fwdPkgs))\n\t\t}\n\t\tassertFwdPkgState(t, fwdPkgs[0], channeldb.FwdStateProcessed)\n\t\tassertFwdPkgNumAddsSettleFails(t, fwdPkgs[0], nAdds, 0)\n\t\tassertAckFilterIsFull(t, fwdPkgs[0], false)\n\n\t\taddRef := channeldb.AddRef{\n\t\t\tHeight: fwdPkg.Height,\n\t\t\tIndex:  uint16(i),\n\t\t}\n\n\t\tif err := kvdb.Update(db, func(tx kvdb.RwTx) error {\n\t\t\treturn packager.AckAddHtlcs(tx, addRef)\n\t\t}, func() {}); err != nil {\n\t\t\tt.Fatalf(\"unable to ack add htlc: %v\", err)\n\t\t}\n\t}\n\n\t// We should still have one package on disk. Now that all adds have been\n\t// acked, the ack filter should return true and the package should be\n\t// FwdStateCompleted since there are no other settle/fail packets.\n\tfwdPkgs = loadFwdPkgs(t, db, packager)\n\tif len(fwdPkgs) != 1 {\n\t\tt.Fatalf(\"expected 1 fwdpkg, instead found %d\", len(fwdPkgs))\n\t}\n\tassertFwdPkgState(t, fwdPkgs[0], channeldb.FwdStateCompleted)\n\tassertFwdPkgNumAddsSettleFails(t, fwdPkgs[0], nAdds, 0)\n\tassertAckFilterIsFull(t, fwdPkgs[0], true)\n\n\t// Lastly, remove the completed forwarding package from disk.\n\tif err := kvdb.Update(db, func(tx kvdb.RwTx) error {\n\t\treturn packager.RemovePkg(tx, fwdPkg.Height)\n\t}, func() {}); err != nil {\n\t\tt.Fatalf(\"unable to remove fwdpkg: %v\", err)\n\t}\n\n\t// Check that the fwd package was actually removed.\n\tfwdPkgs = loadFwdPkgs(t, db, packager)\n\tif len(fwdPkgs) != 0 {\n\t\tt.Fatalf(\"no forwarding packages should exist, found %d\", len(fwdPkgs))\n\t}\n}\n\n// TestPackagerOnlySettleFails asserts that the fwdpkg remains in\n// FwdStateProcessed after writing the forwarding decision when there are no\n// adds in the fwdpkg. We expect this because an empty FwdFilter will always\n// return true, but we are still waiting for the remaining fails and settles to\n// be deleted.",
      "length": 3624,
      "tokens": 515,
      "embedding": []
    },
    {
      "slug": "func TestPackagerOnlySettleFails(t *testing.T) {",
      "content": "func TestPackagerOnlySettleFails(t *testing.T) {\n\tt.Parallel()\n\n\tdb := makeFwdPkgDB(t, \"\")\n\n\tshortChanID := lnwire.NewShortChanIDFromInt(1)\n\tpackager := channeldb.NewChannelPackager(shortChanID)\n\n\t// To begin, there should be no forwarding packages on disk.\n\tfwdPkgs := loadFwdPkgs(t, db, packager)\n\tif len(fwdPkgs) != 0 {\n\t\tt.Fatalf(\"no forwarding packages should exist, found %d\", len(fwdPkgs))\n\t}\n\n\t// Next, create and write a new forwarding package that only has add\n\t// htlcs.\n\tfwdPkg := channeldb.NewFwdPkg(shortChanID, 0, nil, settleFails)\n\n\tnSettleFails := len(settleFails)\n\n\tif err := kvdb.Update(db, func(tx kvdb.RwTx) error {\n\t\treturn packager.AddFwdPkg(tx, fwdPkg)\n\t}, func() {}); err != nil {\n\t\tt.Fatalf(\"unable to add fwd pkg: %v\", err)\n\t}\n\n\t// There should now be one fwdpkg on disk. Since no forwarding decision\n\t// has been written, we expect it to be FwdStateLockedIn. The package\n\t// has unacked add HTLCs, so the ack filter should not be full.\n\tfwdPkgs = loadFwdPkgs(t, db, packager)\n\tif len(fwdPkgs) != 1 {\n\t\tt.Fatalf(\"expected 1 fwdpkg, instead found %d\", len(fwdPkgs))\n\t}\n\tassertFwdPkgState(t, fwdPkgs[0], channeldb.FwdStateLockedIn)\n\tassertFwdPkgNumAddsSettleFails(t, fwdPkgs[0], 0, nSettleFails)\n\tassertAckFilterIsFull(t, fwdPkgs[0], true)\n\n\t// Now, write the forwarding decision. Since we have not explicitly\n\t// added any adds to the fwdfilter, this would indicate that all of the\n\t// adds were 1) settled locally by this link (exit hop), or 2) the htlc\n\t// was failed locally.\n\tif err := kvdb.Update(db, func(tx kvdb.RwTx) error {\n\t\treturn packager.SetFwdFilter(tx, fwdPkg.Height, fwdPkg.FwdFilter)\n\t}, func() {}); err != nil {\n\t\tt.Fatalf(\"unable to set fwdfiter: %v\", err)\n\t}\n\n\tfor i := range settleFails {\n\t\t// We should still have one package on disk. Since the\n\t\t// forwarding decision has been written, it will minimally be in\n\t\t// FwdStateProcessed. However, not all of the HTLCs have been\n\t\t// acked, so should not have advanced further.\n\t\tfwdPkgs = loadFwdPkgs(t, db, packager)\n\t\tif len(fwdPkgs) != 1 {\n\t\t\tt.Fatalf(\"expected 1 fwdpkg, instead found %d\", len(fwdPkgs))\n\t\t}\n\t\tassertFwdPkgState(t, fwdPkgs[0], channeldb.FwdStateProcessed)\n\t\tassertFwdPkgNumAddsSettleFails(t, fwdPkgs[0], 0, nSettleFails)\n\t\tassertSettleFailFilterIsFull(t, fwdPkgs[0], false)\n\t\tassertAckFilterIsFull(t, fwdPkgs[0], true)\n\n\t\tfailSettleRef := channeldb.SettleFailRef{\n\t\t\tSource: shortChanID,\n\t\t\tHeight: fwdPkg.Height,\n\t\t\tIndex:  uint16(i),\n\t\t}\n\n\t\tif err := kvdb.Update(db, func(tx kvdb.RwTx) error {\n\t\t\treturn packager.AckSettleFails(tx, failSettleRef)\n\t\t}, func() {}); err != nil {\n\t\t\tt.Fatalf(\"unable to ack add htlc: %v\", err)\n\t\t}\n\t}\n\n\t// We should still have one package on disk. Now that all settles and\n\t// fails have been removed, package should be FwdStateCompleted since\n\t// there are no other add packets.\n\tfwdPkgs = loadFwdPkgs(t, db, packager)\n\tif len(fwdPkgs) != 1 {\n\t\tt.Fatalf(\"expected 1 fwdpkg, instead found %d\", len(fwdPkgs))\n\t}\n\tassertFwdPkgState(t, fwdPkgs[0], channeldb.FwdStateCompleted)\n\tassertFwdPkgNumAddsSettleFails(t, fwdPkgs[0], 0, nSettleFails)\n\tassertSettleFailFilterIsFull(t, fwdPkgs[0], true)\n\tassertAckFilterIsFull(t, fwdPkgs[0], true)\n\n\t// Lastly, remove the completed forwarding package from disk.\n\tif err := kvdb.Update(db, func(tx kvdb.RwTx) error {\n\t\treturn packager.RemovePkg(tx, fwdPkg.Height)\n\t}, func() {}); err != nil {\n\t\tt.Fatalf(\"unable to remove fwdpkg: %v\", err)\n\t}\n\n\t// Check that the fwd package was actually removed.\n\tfwdPkgs = loadFwdPkgs(t, db, packager)\n\tif len(fwdPkgs) != 0 {\n\t\tt.Fatalf(\"no forwarding packages should exist, found %d\", len(fwdPkgs))\n\t}\n}\n\n// TestPackagerAddsThenSettleFails writes a fwdpkg containing both adds and\n// settle/fails, then checks the behavior when the adds are acked before any of\n// the settle fails. Here we expect pkg to remain in FwdStateProcessed while the\n// remainder of the fail/settles are being deleted.",
      "length": 3760,
      "tokens": 511,
      "embedding": []
    },
    {
      "slug": "func TestPackagerAddsThenSettleFails(t *testing.T) {",
      "content": "func TestPackagerAddsThenSettleFails(t *testing.T) {\n\tt.Parallel()\n\n\tdb := makeFwdPkgDB(t, \"\")\n\n\tshortChanID := lnwire.NewShortChanIDFromInt(1)\n\tpackager := channeldb.NewChannelPackager(shortChanID)\n\n\t// To begin, there should be no forwarding packages on disk.\n\tfwdPkgs := loadFwdPkgs(t, db, packager)\n\tif len(fwdPkgs) != 0 {\n\t\tt.Fatalf(\"no forwarding packages should exist, found %d\", len(fwdPkgs))\n\t}\n\n\t// Next, create and write a new forwarding package that only has add\n\t// htlcs.\n\tfwdPkg := channeldb.NewFwdPkg(shortChanID, 0, adds, settleFails)\n\n\tnAdds := len(adds)\n\tnSettleFails := len(settleFails)\n\n\tif err := kvdb.Update(db, func(tx kvdb.RwTx) error {\n\t\treturn packager.AddFwdPkg(tx, fwdPkg)\n\t}, func() {}); err != nil {\n\t\tt.Fatalf(\"unable to add fwd pkg: %v\", err)\n\t}\n\n\t// There should now be one fwdpkg on disk. Since no forwarding decision\n\t// has been written, we expect it to be FwdStateLockedIn. The package\n\t// has unacked add HTLCs, so the ack filter should not be full.\n\tfwdPkgs = loadFwdPkgs(t, db, packager)\n\tif len(fwdPkgs) != 1 {\n\t\tt.Fatalf(\"expected 1 fwdpkg, instead found %d\", len(fwdPkgs))\n\t}\n\tassertFwdPkgState(t, fwdPkgs[0], channeldb.FwdStateLockedIn)\n\tassertFwdPkgNumAddsSettleFails(t, fwdPkgs[0], nAdds, nSettleFails)\n\tassertAckFilterIsFull(t, fwdPkgs[0], false)\n\n\t// Now, write the forwarding decision. Since we have not explicitly\n\t// added any adds to the fwdfilter, this would indicate that all of the\n\t// adds were 1) settled locally by this link (exit hop), or 2) the htlc\n\t// was failed locally.\n\tif err := kvdb.Update(db, func(tx kvdb.RwTx) error {\n\t\treturn packager.SetFwdFilter(tx, fwdPkg.Height, fwdPkg.FwdFilter)\n\t}, func() {}); err != nil {\n\t\tt.Fatalf(\"unable to set fwdfiter: %v\", err)\n\t}\n\n\tfor i := range adds {\n\t\t// We should still have one package on disk. Since the forwarding\n\t\t// decision has been written, it will minimally be in FwdStateProcessed.\n\t\t// However not allf of the HTLCs have been acked, so should not\n\t\t// have advanced further.\n\t\tfwdPkgs = loadFwdPkgs(t, db, packager)\n\t\tif len(fwdPkgs) != 1 {\n\t\t\tt.Fatalf(\"expected 1 fwdpkg, instead found %d\", len(fwdPkgs))\n\t\t}\n\t\tassertFwdPkgState(t, fwdPkgs[0], channeldb.FwdStateProcessed)\n\t\tassertFwdPkgNumAddsSettleFails(t, fwdPkgs[0], nAdds, nSettleFails)\n\t\tassertSettleFailFilterIsFull(t, fwdPkgs[0], false)\n\t\tassertAckFilterIsFull(t, fwdPkgs[0], false)\n\n\t\taddRef := channeldb.AddRef{\n\t\t\tHeight: fwdPkg.Height,\n\t\t\tIndex:  uint16(i),\n\t\t}\n\n\t\tif err := kvdb.Update(db, func(tx kvdb.RwTx) error {\n\t\t\treturn packager.AckAddHtlcs(tx, addRef)\n\t\t}, func() {}); err != nil {\n\t\t\tt.Fatalf(\"unable to ack add htlc: %v\", err)\n\t\t}\n\t}\n\n\tfor i := range settleFails {\n\t\t// We should still have one package on disk. Since the\n\t\t// forwarding decision has been written, it will minimally be in\n\t\t// FwdStateProcessed.  However not allf of the HTLCs have been\n\t\t// acked, so should not have advanced further.\n\t\tfwdPkgs = loadFwdPkgs(t, db, packager)\n\t\tif len(fwdPkgs) != 1 {\n\t\t\tt.Fatalf(\"expected 1 fwdpkg, instead found %d\", len(fwdPkgs))\n\t\t}\n\t\tassertFwdPkgState(t, fwdPkgs[0], channeldb.FwdStateProcessed)\n\t\tassertFwdPkgNumAddsSettleFails(t, fwdPkgs[0], nAdds, nSettleFails)\n\t\tassertSettleFailFilterIsFull(t, fwdPkgs[0], false)\n\t\tassertAckFilterIsFull(t, fwdPkgs[0], true)\n\n\t\tfailSettleRef := channeldb.SettleFailRef{\n\t\t\tSource: shortChanID,\n\t\t\tHeight: fwdPkg.Height,\n\t\t\tIndex:  uint16(i),\n\t\t}\n\n\t\tif err := kvdb.Update(db, func(tx kvdb.RwTx) error {\n\t\t\treturn packager.AckSettleFails(tx, failSettleRef)\n\t\t}, func() {}); err != nil {\n\t\t\tt.Fatalf(\"unable to remove settle/fail htlc: %v\", err)\n\t\t}\n\t}\n\n\t// We should still have one package on disk. Now that all settles and\n\t// fails have been removed, package should be FwdStateCompleted since\n\t// there are no other add packets.\n\tfwdPkgs = loadFwdPkgs(t, db, packager)\n\tif len(fwdPkgs) != 1 {\n\t\tt.Fatalf(\"expected 1 fwdpkg, instead found %d\", len(fwdPkgs))\n\t}\n\tassertFwdPkgState(t, fwdPkgs[0], channeldb.FwdStateCompleted)\n\tassertFwdPkgNumAddsSettleFails(t, fwdPkgs[0], nAdds, nSettleFails)\n\tassertSettleFailFilterIsFull(t, fwdPkgs[0], true)\n\tassertAckFilterIsFull(t, fwdPkgs[0], true)\n\n\t// Lastly, remove the completed forwarding package from disk.\n\tif err := kvdb.Update(db, func(tx kvdb.RwTx) error {\n\t\treturn packager.RemovePkg(tx, fwdPkg.Height)\n\t}, func() {}); err != nil {\n\t\tt.Fatalf(\"unable to remove fwdpkg: %v\", err)\n\t}\n\n\t// Check that the fwd package was actually removed.\n\tfwdPkgs = loadFwdPkgs(t, db, packager)\n\tif len(fwdPkgs) != 0 {\n\t\tt.Fatalf(\"no forwarding packages should exist, found %d\", len(fwdPkgs))\n\t}\n}\n\n// TestPackagerSettleFailsThenAdds writes a fwdpkg with both adds and\n// settle/fails, then checks the behavior when the settle/fails are removed\n// before any of the adds have been acked. This should cause the fwdpkg to\n// remain in FwdStateProcessed until the final ack is recorded, at which point\n// it should be promoted directly to FwdStateCompleted.since all adds have been\n// removed.",
      "length": 4774,
      "tokens": 643,
      "embedding": []
    },
    {
      "slug": "func TestPackagerSettleFailsThenAdds(t *testing.T) {",
      "content": "func TestPackagerSettleFailsThenAdds(t *testing.T) {\n\tt.Parallel()\n\n\tdb := makeFwdPkgDB(t, \"\")\n\n\tshortChanID := lnwire.NewShortChanIDFromInt(1)\n\tpackager := channeldb.NewChannelPackager(shortChanID)\n\n\t// To begin, there should be no forwarding packages on disk.\n\tfwdPkgs := loadFwdPkgs(t, db, packager)\n\tif len(fwdPkgs) != 0 {\n\t\tt.Fatalf(\"no forwarding packages should exist, found %d\", len(fwdPkgs))\n\t}\n\n\t// Next, create and write a new forwarding package that has both add\n\t// and settle/fail htlcs.\n\tfwdPkg := channeldb.NewFwdPkg(shortChanID, 0, adds, settleFails)\n\n\tnAdds := len(adds)\n\tnSettleFails := len(settleFails)\n\n\tif err := kvdb.Update(db, func(tx kvdb.RwTx) error {\n\t\treturn packager.AddFwdPkg(tx, fwdPkg)\n\t}, func() {}); err != nil {\n\t\tt.Fatalf(\"unable to add fwd pkg: %v\", err)\n\t}\n\n\t// There should now be one fwdpkg on disk. Since no forwarding decision\n\t// has been written, we expect it to be FwdStateLockedIn. The package\n\t// has unacked add HTLCs, so the ack filter should not be full.\n\tfwdPkgs = loadFwdPkgs(t, db, packager)\n\tif len(fwdPkgs) != 1 {\n\t\tt.Fatalf(\"expected 1 fwdpkg, instead found %d\", len(fwdPkgs))\n\t}\n\tassertFwdPkgState(t, fwdPkgs[0], channeldb.FwdStateLockedIn)\n\tassertFwdPkgNumAddsSettleFails(t, fwdPkgs[0], nAdds, nSettleFails)\n\tassertAckFilterIsFull(t, fwdPkgs[0], false)\n\n\t// Now, write the forwarding decision. Since we have not explicitly\n\t// added any adds to the fwdfilter, this would indicate that all of the\n\t// adds were 1) settled locally by this link (exit hop), or 2) the htlc\n\t// was failed locally.\n\tif err := kvdb.Update(db, func(tx kvdb.RwTx) error {\n\t\treturn packager.SetFwdFilter(tx, fwdPkg.Height, fwdPkg.FwdFilter)\n\t}, func() {}); err != nil {\n\t\tt.Fatalf(\"unable to set fwdfiter: %v\", err)\n\t}\n\n\t// Simulate another channel deleting the settle/fails it received from\n\t// the original fwd pkg.\n\t// TODO(conner): use different packager/s?\n\tfor i := range settleFails {\n\t\t// We should still have one package on disk. Since the\n\t\t// forwarding decision has been written, it will minimally be in\n\t\t// FwdStateProcessed.  However none all of the add HTLCs have\n\t\t// been acked, so should not have advanced further.\n\t\tfwdPkgs = loadFwdPkgs(t, db, packager)\n\t\tif len(fwdPkgs) != 1 {\n\t\t\tt.Fatalf(\"expected 1 fwdpkg, instead found %d\", len(fwdPkgs))\n\t\t}\n\t\tassertFwdPkgState(t, fwdPkgs[0], channeldb.FwdStateProcessed)\n\t\tassertFwdPkgNumAddsSettleFails(t, fwdPkgs[0], nAdds, nSettleFails)\n\t\tassertSettleFailFilterIsFull(t, fwdPkgs[0], false)\n\t\tassertAckFilterIsFull(t, fwdPkgs[0], false)\n\n\t\tfailSettleRef := channeldb.SettleFailRef{\n\t\t\tSource: shortChanID,\n\t\t\tHeight: fwdPkg.Height,\n\t\t\tIndex:  uint16(i),\n\t\t}\n\n\t\tif err := kvdb.Update(db, func(tx kvdb.RwTx) error {\n\t\t\treturn packager.AckSettleFails(tx, failSettleRef)\n\t\t}, func() {}); err != nil {\n\t\t\tt.Fatalf(\"unable to remove settle/fail htlc: %v\", err)\n\t\t}\n\t}\n\n\t// Now simulate this channel receiving a fail/settle for the adds in the\n\t// fwdpkg.\n\tfor i := range adds {\n\t\t// Again, we should still have one package on disk and be in\n\t\t// FwdStateProcessed. This should not change until all of the\n\t\t// add htlcs have been acked.\n\t\tfwdPkgs = loadFwdPkgs(t, db, packager)\n\t\tif len(fwdPkgs) != 1 {\n\t\t\tt.Fatalf(\"expected 1 fwdpkg, instead found %d\", len(fwdPkgs))\n\t\t}\n\t\tassertFwdPkgState(t, fwdPkgs[0], channeldb.FwdStateProcessed)\n\t\tassertFwdPkgNumAddsSettleFails(t, fwdPkgs[0], nAdds, nSettleFails)\n\t\tassertSettleFailFilterIsFull(t, fwdPkgs[0], true)\n\t\tassertAckFilterIsFull(t, fwdPkgs[0], false)\n\n\t\taddRef := channeldb.AddRef{\n\t\t\tHeight: fwdPkg.Height,\n\t\t\tIndex:  uint16(i),\n\t\t}\n\n\t\tif err := kvdb.Update(db, func(tx kvdb.RwTx) error {\n\t\t\treturn packager.AckAddHtlcs(tx, addRef)\n\t\t}, func() {}); err != nil {\n\t\t\tt.Fatalf(\"unable to ack add htlc: %v\", err)\n\t\t}\n\t}\n\n\t// We should still have one package on disk. Now that all settles and\n\t// fails have been removed, package should be FwdStateCompleted since\n\t// there are no other add packets.\n\tfwdPkgs = loadFwdPkgs(t, db, packager)\n\tif len(fwdPkgs) != 1 {\n\t\tt.Fatalf(\"expected 1 fwdpkg, instead found %d\", len(fwdPkgs))\n\t}\n\tassertFwdPkgState(t, fwdPkgs[0], channeldb.FwdStateCompleted)\n\tassertFwdPkgNumAddsSettleFails(t, fwdPkgs[0], nAdds, nSettleFails)\n\tassertSettleFailFilterIsFull(t, fwdPkgs[0], true)\n\tassertAckFilterIsFull(t, fwdPkgs[0], true)\n\n\t// Lastly, remove the completed forwarding package from disk.\n\tif err := kvdb.Update(db, func(tx kvdb.RwTx) error {\n\t\treturn packager.RemovePkg(tx, fwdPkg.Height)\n\t}, func() {}); err != nil {\n\t\tt.Fatalf(\"unable to remove fwdpkg: %v\", err)\n\t}\n\n\t// Check that the fwd package was actually removed.\n\tfwdPkgs = loadFwdPkgs(t, db, packager)\n\tif len(fwdPkgs) != 0 {\n\t\tt.Fatalf(\"no forwarding packages should exist, found %d\", len(fwdPkgs))\n\t}\n}\n\n// TestPackagerWipeAll checks that when the method is called, all the related\n// forwarding packages will be removed.",
      "length": 4670,
      "tokens": 626,
      "embedding": []
    },
    {
      "slug": "func TestPackagerWipeAll(t *testing.T) {",
      "content": "func TestPackagerWipeAll(t *testing.T) {\n\tt.Parallel()\n\n\tdb := makeFwdPkgDB(t, \"\")\n\n\tshortChanID := lnwire.NewShortChanIDFromInt(1)\n\tpackager := channeldb.NewChannelPackager(shortChanID)\n\n\t// To begin, there should be no forwarding packages on disk.\n\tfwdPkgs := loadFwdPkgs(t, db, packager)\n\trequire.Empty(t, fwdPkgs, \"no forwarding packages should exist\")\n\n\t// Now, check we can wipe without error since it's a noop.\n\terr := kvdb.Update(db, packager.Wipe, func() {})\n\trequire.NoError(t, err, \"unable to wipe fwdpkg\")\n\n\t// Next, create and write two forwarding packages with no htlcs.\n\tfwdPkg1 := channeldb.NewFwdPkg(shortChanID, 0, nil, nil)\n\tfwdPkg2 := channeldb.NewFwdPkg(shortChanID, 1, nil, nil)\n\n\terr = kvdb.Update(db, func(tx kvdb.RwTx) error {\n\t\tif err := packager.AddFwdPkg(tx, fwdPkg2); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn packager.AddFwdPkg(tx, fwdPkg1)\n\t}, func() {})\n\trequire.NoError(t, err, \"unable to add fwd pkg\")\n\n\t// There should now be two fwdpkgs on disk.\n\tfwdPkgs = loadFwdPkgs(t, db, packager)\n\trequire.Equal(t, 2, len(fwdPkgs), \"expected 2 fwdpkg\")\n\n\t// Now, wipe all forwarding packages from disk.\n\terr = kvdb.Update(db, packager.Wipe, func() {})\n\trequire.NoError(t, err, \"unable to wipe fwdpkg\")\n\n\t// Check that the packages were actually removed.\n\tfwdPkgs = loadFwdPkgs(t, db, packager)\n\trequire.Empty(t, fwdPkgs, \"no forwarding packages should exist\")\n}\n\n// assertFwdPkgState checks the current state of a fwdpkg meets our\n// expectations.",
      "length": 1388,
      "tokens": 187,
      "embedding": []
    },
    {
      "slug": "func assertFwdPkgState(t *testing.T, fwdPkg *channeldb.FwdPkg,",
      "content": "func assertFwdPkgState(t *testing.T, fwdPkg *channeldb.FwdPkg,\n\tstate channeldb.FwdState) {\n\t_, _, line, _ := runtime.Caller(1)\n\tif fwdPkg.State != state {\n\t\tt.Fatalf(\"line %d: expected fwdpkg in state %v, found %v\",\n\t\t\tline, state, fwdPkg.State)\n\t}\n}\n\n// assertFwdPkgNumAddsSettleFails checks that the number of adds and\n// settle/fail log updates are correct.",
      "length": 289,
      "tokens": 43,
      "embedding": []
    },
    {
      "slug": "func assertFwdPkgNumAddsSettleFails(t *testing.T, fwdPkg *channeldb.FwdPkg,",
      "content": "func assertFwdPkgNumAddsSettleFails(t *testing.T, fwdPkg *channeldb.FwdPkg,\n\texpectedNumAdds, expectedNumSettleFails int) {\n\t_, _, line, _ := runtime.Caller(1)\n\tif len(fwdPkg.Adds) != expectedNumAdds {\n\t\tt.Fatalf(\"line %d: expected fwdpkg to have %d adds, found %d\",\n\t\t\tline, expectedNumAdds, len(fwdPkg.Adds))\n\t}\n\n\tif len(fwdPkg.SettleFails) != expectedNumSettleFails {\n\t\tt.Fatalf(\"line %d: expected fwdpkg to have %d settle/fails, found %d\",\n\t\t\tline, expectedNumSettleFails, len(fwdPkg.SettleFails))\n\t}\n}\n\n// assertAckFilterIsFull checks whether or not a fwdpkg's ack filter matches our\n// expected full-ness.",
      "length": 521,
      "tokens": 64,
      "embedding": []
    },
    {
      "slug": "func assertAckFilterIsFull(t *testing.T, fwdPkg *channeldb.FwdPkg, expected bool) {",
      "content": "func assertAckFilterIsFull(t *testing.T, fwdPkg *channeldb.FwdPkg, expected bool) {\n\t_, _, line, _ := runtime.Caller(1)\n\tif fwdPkg.AckFilter.IsFull() != expected {\n\t\tt.Fatalf(\"line %d: expected fwdpkg ack filter IsFull to be %v, \"+\n\t\t\t\"found %v\", line, expected, fwdPkg.AckFilter.IsFull())\n\t}\n}\n\n// assertSettleFailFilterIsFull checks whether or not a fwdpkg's settle fail\n// filter matches our expected full-ness.",
      "length": 322,
      "tokens": 45,
      "embedding": []
    },
    {
      "slug": "func assertSettleFailFilterIsFull(t *testing.T, fwdPkg *channeldb.FwdPkg, expected bool) {",
      "content": "func assertSettleFailFilterIsFull(t *testing.T, fwdPkg *channeldb.FwdPkg, expected bool) {\n\t_, _, line, _ := runtime.Caller(1)\n\tif fwdPkg.SettleFailFilter.IsFull() != expected {\n\t\tt.Fatalf(\"line %d: expected fwdpkg settle/fail filter IsFull to be %v, \"+\n\t\t\t\"found %v\", line, expected, fwdPkg.SettleFailFilter.IsFull())\n\t}\n}\n\n// loadFwdPkgs is a helper method that reads all forwarding packages for a\n// particular packager.",
      "length": 324,
      "tokens": 45,
      "embedding": []
    },
    {
      "slug": "func loadFwdPkgs(t *testing.T, db kvdb.Backend,",
      "content": "func loadFwdPkgs(t *testing.T, db kvdb.Backend,\n\tpackager channeldb.FwdPackager) []*channeldb.FwdPkg {\n\n\tvar fwdPkgs []*channeldb.FwdPkg\n\tif err := kvdb.View(db, func(tx kvdb.RTx) error {\n\t\tvar err error\n\t\tfwdPkgs, err = packager.LoadFwdPkgs(tx)\n\t\treturn err\n\t}, func() {\n\t\tfwdPkgs = nil\n\t}); err != nil {\n\t\tt.Fatalf(\"unable to load fwd pkgs: %v\", err)\n\t}\n\n\treturn fwdPkgs\n}\n\n// makeFwdPkgDB initializes a test database for forwarding packages. If the\n// provided path is an empty, it will create a temp dir/file to use.",
      "length": 455,
      "tokens": 71,
      "embedding": []
    },
    {
      "slug": "func makeFwdPkgDB(t *testing.T, path string) kvdb.Backend { // nolint:unparam",
      "content": "func makeFwdPkgDB(t *testing.T, path string) kvdb.Backend { // nolint:unparam\n\tif path == \"\" {\n\t\tpath = filepath.Join(t.TempDir(), \"fwdpkg.db\")\n\t}\n\n\tbdb, err := kvdb.Create(\n\t\tkvdb.BoltBackendName, path, true, kvdb.DefaultDBTimeout,\n\t)\n\trequire.NoError(t, err, \"unable to open boltdb\")\n\n\treturn bdb\n}\n",
      "length": 212,
      "tokens": 28,
      "embedding": []
    }
  ]
}