{
  "filepath": "../implementations/go/lnd/channeldb/witness_cache.go",
  "package": "channeldb",
  "sections": [
    {
      "slug": "type WitnessType uint8",
      "content": "type WitnessType uint8\n\nvar (\n\t// Sha256HashWitness is a witness that is simply the pre image to a\n\t// hash image. In order to map to its key, we'll use sha256.\n\tSha256HashWitness WitnessType = 1\n)\n\n// toDBKey is a helper method that maps a witness type to the key that we'll\n// use to store it within the database.",
      "length": 284,
      "tokens": 57,
      "embedding": []
    },
    {
      "slug": "func (w WitnessType) toDBKey() ([]byte, error) {",
      "content": "func (w WitnessType) toDBKey() ([]byte, error) {\n\tswitch w {\n\n\tcase Sha256HashWitness:\n\t\treturn []byte{byte(w)}, nil\n\n\tdefault:\n\t\treturn nil, ErrUnknownWitnessType\n\t}\n}\n\nvar (\n\t// witnessBucketKey is the name of the bucket that we use to store all\n\t// witnesses encountered. Within this bucket, we'll create a sub-bucket for\n\t// each witness type.\n\twitnessBucketKey = []byte(\"byte\")\n)\n\n// WitnessCache is a persistent cache of all witnesses we've encountered on the\n// network. In the case of multi-hop, multi-step contracts, a cache of all\n// witnesses can be useful in the case of partial contract resolution. If\n// negotiations break down, we may be forced to locate the witness for a\n// portion of the contract on-chain. In this case, we'll then add that witness\n// to the cache so the incoming contract can fully resolve witness.\n// Additionally, as one MUST always use a unique witness on the network, we may\n// use this cache to detect duplicate witnesses.\n//\n// TODO(roasbeef): need expiry policy?\n//   - encrypt?",
      "length": 945,
      "tokens": 160,
      "embedding": []
    },
    {
      "slug": "type WitnessCache struct {",
      "content": "type WitnessCache struct {\n\tdb *DB\n}\n\n// NewWitnessCache returns a new instance of the witness cache.",
      "length": 71,
      "tokens": 13,
      "embedding": []
    },
    {
      "slug": "func (d *DB) NewWitnessCache() *WitnessCache {",
      "content": "func (d *DB) NewWitnessCache() *WitnessCache {\n\treturn &WitnessCache{\n\t\tdb: d,\n\t}\n}\n\n// witnessEntry is a key-value struct that holds each key -> witness pair, used\n// when inserting records into the cache.",
      "length": 153,
      "tokens": 27,
      "embedding": []
    },
    {
      "slug": "type witnessEntry struct {",
      "content": "type witnessEntry struct {\n\tkey     []byte\n\twitness []byte\n}\n\n// AddSha256Witnesses adds a batch of new sha256 preimages into the witness\n// cache. This is an alias for AddWitnesses that uses Sha256HashWitness as the\n// preimages' witness type.",
      "length": 211,
      "tokens": 34,
      "embedding": []
    },
    {
      "slug": "func (w *WitnessCache) AddSha256Witnesses(preimages ...lntypes.Preimage) error {",
      "content": "func (w *WitnessCache) AddSha256Witnesses(preimages ...lntypes.Preimage) error {\n\t// Optimistically compute the preimages' hashes before attempting to\n\t// start the db transaction.\n\tentries := make([]witnessEntry, 0, len(preimages))\n\tfor i := range preimages {\n\t\thash := preimages[i].Hash()\n\t\tentries = append(entries, witnessEntry{\n\t\t\tkey:     hash[:],\n\t\t\twitness: preimages[i][:],\n\t\t})\n\t}\n\n\treturn w.addWitnessEntries(Sha256HashWitness, entries)\n}\n\n// addWitnessEntries inserts the witnessEntry key-value pairs into the cache,\n// using the appropriate witness type to segment the namespace of possible\n// witness types.",
      "length": 524,
      "tokens": 67,
      "embedding": []
    },
    {
      "slug": "func (w *WitnessCache) addWitnessEntries(wType WitnessType,",
      "content": "func (w *WitnessCache) addWitnessEntries(wType WitnessType,\n\tentries []witnessEntry) error {\n\n\t// Exit early if there are no witnesses to add.\n\tif len(entries) == 0 {\n\t\treturn nil\n\t}\n\n\treturn kvdb.Batch(w.db.Backend, func(tx kvdb.RwTx) error {\n\t\twitnessBucket, err := tx.CreateTopLevelBucket(witnessBucketKey)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\twitnessTypeBucketKey, err := wType.toDBKey()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\twitnessTypeBucket, err := witnessBucket.CreateBucketIfNotExists(\n\t\t\twitnessTypeBucketKey,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfor _, entry := range entries {\n\t\t\terr = witnessTypeBucket.Put(entry.key, entry.witness)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t})\n}\n\n// LookupSha256Witness attempts to lookup the preimage for a sha256 hash. If\n// the witness isn't found, ErrNoWitnesses will be returned.",
      "length": 759,
      "tokens": 111,
      "embedding": []
    },
    {
      "slug": "func (w *WitnessCache) LookupSha256Witness(hash lntypes.Hash) (lntypes.Preimage, error) {",
      "content": "func (w *WitnessCache) LookupSha256Witness(hash lntypes.Hash) (lntypes.Preimage, error) {\n\twitness, err := w.lookupWitness(Sha256HashWitness, hash[:])\n\tif err != nil {\n\t\treturn lntypes.Preimage{}, err\n\t}\n\n\treturn lntypes.MakePreimage(witness)\n}\n\n// lookupWitness attempts to lookup a witness according to its type and also\n// its witness key. In the case that the witness isn't found, ErrNoWitnesses\n// will be returned.",
      "length": 320,
      "tokens": 47,
      "embedding": []
    },
    {
      "slug": "func (w *WitnessCache) lookupWitness(wType WitnessType, witnessKey []byte) ([]byte, error) {",
      "content": "func (w *WitnessCache) lookupWitness(wType WitnessType, witnessKey []byte) ([]byte, error) {\n\tvar witness []byte\n\terr := kvdb.View(w.db, func(tx kvdb.RTx) error {\n\t\twitnessBucket := tx.ReadBucket(witnessBucketKey)\n\t\tif witnessBucket == nil {\n\t\t\treturn ErrNoWitnesses\n\t\t}\n\n\t\twitnessTypeBucketKey, err := wType.toDBKey()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\twitnessTypeBucket := witnessBucket.NestedReadBucket(witnessTypeBucketKey)\n\t\tif witnessTypeBucket == nil {\n\t\t\treturn ErrNoWitnesses\n\t\t}\n\n\t\tdbWitness := witnessTypeBucket.Get(witnessKey)\n\t\tif dbWitness == nil {\n\t\t\treturn ErrNoWitnesses\n\t\t}\n\n\t\twitness = make([]byte, len(dbWitness))\n\t\tcopy(witness[:], dbWitness)\n\n\t\treturn nil\n\t}, func() {\n\t\twitness = nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn witness, nil\n}\n\n// DeleteSha256Witness attempts to delete a sha256 preimage identified by hash.",
      "length": 728,
      "tokens": 94,
      "embedding": []
    },
    {
      "slug": "func (w *WitnessCache) DeleteSha256Witness(hash lntypes.Hash) error {",
      "content": "func (w *WitnessCache) DeleteSha256Witness(hash lntypes.Hash) error {\n\treturn w.deleteWitness(Sha256HashWitness, hash[:])\n}\n\n// deleteWitness attempts to delete a particular witness from the database.",
      "length": 127,
      "tokens": 15,
      "embedding": []
    },
    {
      "slug": "func (w *WitnessCache) deleteWitness(wType WitnessType, witnessKey []byte) error {",
      "content": "func (w *WitnessCache) deleteWitness(wType WitnessType, witnessKey []byte) error {\n\treturn kvdb.Batch(w.db.Backend, func(tx kvdb.RwTx) error {\n\t\twitnessBucket, err := tx.CreateTopLevelBucket(witnessBucketKey)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\twitnessTypeBucketKey, err := wType.toDBKey()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\twitnessTypeBucket, err := witnessBucket.CreateBucketIfNotExists(\n\t\t\twitnessTypeBucketKey,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn witnessTypeBucket.Delete(witnessKey)\n\t})\n}\n\n// DeleteWitnessClass attempts to delete an *entire* class of witnesses. After\n// this function return with a non-nil error,",
      "length": 534,
      "tokens": 67,
      "embedding": []
    },
    {
      "slug": "func (w *WitnessCache) DeleteWitnessClass(wType WitnessType) error {",
      "content": "func (w *WitnessCache) DeleteWitnessClass(wType WitnessType) error {\n\treturn kvdb.Batch(w.db.Backend, func(tx kvdb.RwTx) error {\n\t\twitnessBucket, err := tx.CreateTopLevelBucket(witnessBucketKey)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\twitnessTypeBucketKey, err := wType.toDBKey()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn witnessBucket.DeleteNestedBucket(witnessTypeBucketKey)\n\t})\n}\n",
      "length": 303,
      "tokens": 34,
      "embedding": []
    }
  ]
}