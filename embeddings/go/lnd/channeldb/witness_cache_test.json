{
  "filepath": "../implementations/go/lnd/channeldb/witness_cache_test.go",
  "package": "channeldb",
  "sections": [
    {
      "slug": "func TestWitnessCacheSha256Retrieval(t *testing.T) {",
      "content": "func TestWitnessCacheSha256Retrieval(t *testing.T) {\n\tt.Parallel()\n\n\tcdb, err := MakeTestDB(t)\n\trequire.NoError(t, err, \"unable to make test database\")\n\n\twCache := cdb.NewWitnessCache()\n\n\t// We'll be attempting to add then lookup two simple sha256 preimages\n\t// within this test.\n\tpreimage1 := lntypes.Preimage(rev)\n\tpreimage2 := lntypes.Preimage(key)\n\n\tpreimages := []lntypes.Preimage{preimage1, preimage2}\n\thashes := []lntypes.Hash{preimage1.Hash(), preimage2.Hash()}\n\n\t// First, we'll attempt to add the preimages to the database.\n\terr = wCache.AddSha256Witnesses(preimages...)\n\trequire.NoError(t, err, \"unable to add witness\")\n\n\t// With the preimages stored, we'll now attempt to look them up.\n\tfor i, hash := range hashes {\n\t\tpreimage := preimages[i]\n\n\t\t// We should get back the *exact* same preimage as we originally\n\t\t// stored.\n\t\tdbPreimage, err := wCache.LookupSha256Witness(hash)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to look up witness: %v\", err)\n\t\t}\n\n\t\tif preimage != dbPreimage {\n\t\t\tt.Fatalf(\"witnesses don't match: expected %x, got %x\",\n\t\t\t\tpreimage[:], dbPreimage[:])\n\t\t}\n\t}\n}\n\n// TestWitnessCacheSha256Deletion tests that we're able to delete a single\n// sha256 preimage, and also a class of witnesses from the cache.",
      "length": 1143,
      "tokens": 157,
      "embedding": []
    },
    {
      "slug": "func TestWitnessCacheSha256Deletion(t *testing.T) {",
      "content": "func TestWitnessCacheSha256Deletion(t *testing.T) {\n\tt.Parallel()\n\n\tcdb, err := MakeTestDB(t)\n\trequire.NoError(t, err, \"unable to make test database\")\n\n\twCache := cdb.NewWitnessCache()\n\n\t// We'll start by adding two preimages to the cache.\n\tpreimage1 := lntypes.Preimage(key)\n\thash1 := preimage1.Hash()\n\n\tpreimage2 := lntypes.Preimage(rev)\n\thash2 := preimage2.Hash()\n\n\tif err := wCache.AddSha256Witnesses(preimage1); err != nil {\n\t\tt.Fatalf(\"unable to add witness: %v\", err)\n\t}\n\n\tif err := wCache.AddSha256Witnesses(preimage2); err != nil {\n\t\tt.Fatalf(\"unable to add witness: %v\", err)\n\t}\n\n\t// We'll now delete the first preimage. If we attempt to look it up, we\n\t// should get ErrNoWitnesses.\n\terr = wCache.DeleteSha256Witness(hash1)\n\trequire.NoError(t, err, \"unable to delete witness\")\n\t_, err = wCache.LookupSha256Witness(hash1)\n\tif err != ErrNoWitnesses {\n\t\tt.Fatalf(\"expected ErrNoWitnesses instead got: %v\", err)\n\t}\n\n\t// Next, we'll attempt to delete the entire witness class itself. When\n\t// we try to lookup the second preimage, we should again get\n\t// ErrNoWitnesses.\n\tif err := wCache.DeleteWitnessClass(Sha256HashWitness); err != nil {\n\t\tt.Fatalf(\"unable to delete witness class: %v\", err)\n\t}\n\t_, err = wCache.LookupSha256Witness(hash2)\n\tif err != ErrNoWitnesses {\n\t\tt.Fatalf(\"expected ErrNoWitnesses instead got: %v\", err)\n\t}\n}\n\n// TestWitnessCacheUnknownWitness tests that we get an error if we attempt to\n// query/add/delete an unknown witness.",
      "length": 1362,
      "tokens": 187,
      "embedding": []
    },
    {
      "slug": "func TestWitnessCacheUnknownWitness(t *testing.T) {",
      "content": "func TestWitnessCacheUnknownWitness(t *testing.T) {\n\tt.Parallel()\n\n\tcdb, err := MakeTestDB(t)\n\trequire.NoError(t, err, \"unable to make test database\")\n\n\twCache := cdb.NewWitnessCache()\n\n\t// We'll attempt to add a new, undefined witness type to the database.\n\t// We should get an error.\n\terr = wCache.legacyAddWitnesses(234, key[:])\n\tif err != ErrUnknownWitnessType {\n\t\tt.Fatalf(\"expected ErrUnknownWitnessType, got %v\", err)\n\t}\n}\n\n// TestAddSha256Witnesses tests that insertion using AddSha256Witnesses behaves\n// identically to the insertion via the generalized interface.",
      "length": 505,
      "tokens": 67,
      "embedding": []
    },
    {
      "slug": "func TestAddSha256Witnesses(t *testing.T) {",
      "content": "func TestAddSha256Witnesses(t *testing.T) {\n\tcdb, err := MakeTestDB(t)\n\trequire.NoError(t, err, \"unable to make test database\")\n\n\twCache := cdb.NewWitnessCache()\n\n\t// We'll start by adding a witnesses to the cache using the generic\n\t// AddWitnesses method.\n\twitness1 := rev[:]\n\tpreimage1 := lntypes.Preimage(rev)\n\thash1 := preimage1.Hash()\n\n\twitness2 := key[:]\n\tpreimage2 := lntypes.Preimage(key)\n\thash2 := preimage2.Hash()\n\n\tvar (\n\t\twitnesses = [][]byte{witness1, witness2}\n\t\tpreimages = []lntypes.Preimage{preimage1, preimage2}\n\t\thashes    = []lntypes.Hash{hash1, hash2}\n\t)\n\n\terr = wCache.legacyAddWitnesses(Sha256HashWitness, witnesses...)\n\trequire.NoError(t, err, \"unable to add witness\")\n\n\tfor i, hash := range hashes {\n\t\tpreimage := preimages[i]\n\n\t\tdbPreimage, err := wCache.LookupSha256Witness(hash)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to lookup witness: %v\", err)\n\t\t}\n\n\t\t// Assert that the retrieved witness matches the original.\n\t\tif dbPreimage != preimage {\n\t\t\tt.Fatalf(\"retrieved witness mismatch, want: %x, \"+\n\t\t\t\t\"got: %x\", preimage, dbPreimage)\n\t\t}\n\n\t\t// We'll now delete the witness, as we'll be reinserting it\n\t\t// using the specialized AddSha256Witnesses method.\n\t\terr = wCache.DeleteSha256Witness(hash)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to delete witness: %v\", err)\n\t\t}\n\t}\n\n\t// Now, add the same witnesses using the type-safe interface for\n\t// lntypes.Preimages..\n\terr = wCache.AddSha256Witnesses(preimages...)\n\trequire.NoError(t, err, \"unable to add sha256 preimage\")\n\n\t// Finally, iterate over the keys and assert that the returned witnesses\n\t// match the original witnesses. This asserts that the specialized\n\t// insertion method behaves identically to the generalized interface.\n\tfor i, hash := range hashes {\n\t\tpreimage := preimages[i]\n\n\t\tdbPreimage, err := wCache.LookupSha256Witness(hash)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to lookup witness: %v\", err)\n\t\t}\n\n\t\t// Assert that the retrieved witness matches the original.\n\t\tif dbPreimage != preimage {\n\t\t\tt.Fatalf(\"retrieved witness mismatch, want: %x, \"+\n\t\t\t\t\"got: %x\", preimage, dbPreimage)\n\t\t}\n\t}\n}\n\n// legacyAddWitnesses adds a batch of new witnesses of wType to the witness\n// cache. The type of the witness will be used to map each witness to the key\n// that will be used to look it up. All witnesses should be of the same\n// WitnessType.\n//\n// NOTE: Previously this method exposed a generic interface for adding\n// witnesses, which has since been deprecated in favor of a strongly typed\n// interface for each witness class. We keep this method around to assert the\n// correctness of specialized witness adding methods.",
      "length": 2484,
      "tokens": 358,
      "embedding": []
    },
    {
      "slug": "func (w *WitnessCache) legacyAddWitnesses(wType WitnessType,",
      "content": "func (w *WitnessCache) legacyAddWitnesses(wType WitnessType,\n\twitnesses ...[]byte) error {\n\n\t// Optimistically compute the witness keys before attempting to start\n\t// the db transaction.\n\tentries := make([]witnessEntry, 0, len(witnesses))\n\tfor _, witness := range witnesses {\n\t\t// Map each witness to its key by applying the appropriate\n\t\t// transformation for the given witness type.\n\t\tswitch wType {\n\t\tcase Sha256HashWitness:\n\t\t\tkey := sha256.Sum256(witness)\n\t\t\tentries = append(entries, witnessEntry{\n\t\t\t\tkey:     key[:],\n\t\t\t\twitness: witness,\n\t\t\t})\n\t\tdefault:\n\t\t\treturn ErrUnknownWitnessType\n\t\t}\n\t}\n\n\treturn w.addWitnessEntries(wType, entries)\n}\n",
      "length": 567,
      "tokens": 74,
      "embedding": []
    }
  ]
}