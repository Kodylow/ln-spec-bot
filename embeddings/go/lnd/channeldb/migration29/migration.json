{
  "filepath": "../implementations/go/lnd/channeldb/migration29/migration.go",
  "package": "migration29",
  "sections": [
    {
      "slug": "func MigrateChanID(tx kvdb.RwTx) error {",
      "content": "func MigrateChanID(tx kvdb.RwTx) error {\n\tlog.Info(\"Populating ChannelID index\")\n\n\t// First we'll retrieve the set of outpoints we know about.\n\tops, err := fetchOutPoints(tx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn populateChanIDIndex(tx, ops)\n}\n\n// fetchOutPoints loops through the outpointBucket and returns each stored\n// outpoint.",
      "length": 283,
      "tokens": 42,
      "embedding": []
    },
    {
      "slug": "func fetchOutPoints(tx kvdb.RwTx) ([]*wire.OutPoint, error) {",
      "content": "func fetchOutPoints(tx kvdb.RwTx) ([]*wire.OutPoint, error) {\n\tvar ops []*wire.OutPoint\n\n\tbucket := tx.ReadBucket(outpointBucket)\n\n\terr := bucket.ForEach(func(k, _ []byte) error {\n\t\tvar op wire.OutPoint\n\t\tr := bytes.NewReader(k)\n\t\tif err := readOutpoint(r, &op); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tops = append(ops, &op)\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn ops, nil\n}\n\n// populateChanIDIndex uses the set of retrieved outpoints and populates the\n// ChannelID index.",
      "length": 408,
      "tokens": 65,
      "embedding": []
    },
    {
      "slug": "func populateChanIDIndex(tx kvdb.RwTx, ops []*wire.OutPoint) error {",
      "content": "func populateChanIDIndex(tx kvdb.RwTx, ops []*wire.OutPoint) error {\n\tbucket := tx.ReadWriteBucket(chanIDBucket)\n\n\tfor _, op := range ops {\n\t\tchanID := NewChanIDFromOutPoint(op)\n\n\t\tif err := bucket.Put(chanID[:], []byte{}); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n",
      "length": 192,
      "tokens": 29,
      "embedding": []
    }
  ]
}