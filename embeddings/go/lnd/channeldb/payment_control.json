{
  "filepath": "../implementations/go/lnd/channeldb/payment_control.go",
  "package": "channeldb",
  "sections": [
    {
      "slug": "type PaymentControl struct {",
      "content": "type PaymentControl struct {\n\tpaymentSeqMx     sync.Mutex\n\tcurrPaymentSeq   uint64\n\tstoredPaymentSeq uint64\n\tdb               *DB\n}\n\n// NewPaymentControl creates a new instance of the PaymentControl.",
      "length": 164,
      "tokens": 18,
      "embedding": []
    },
    {
      "slug": "func NewPaymentControl(db *DB) *PaymentControl {",
      "content": "func NewPaymentControl(db *DB) *PaymentControl {\n\treturn &PaymentControl{\n\t\tdb: db,\n\t}\n}\n\n// InitPayment checks or records the given PaymentCreationInfo with the DB,\n// making sure it does not already exist as an in-flight payment. When this\n// method returns successfully, the payment is guaranteed to be in the InFlight\n// state.",
      "length": 274,
      "tokens": 46,
      "embedding": []
    },
    {
      "slug": "func (p *PaymentControl) InitPayment(paymentHash lntypes.Hash,",
      "content": "func (p *PaymentControl) InitPayment(paymentHash lntypes.Hash,\n\tinfo *PaymentCreationInfo) error {\n\n\t// Obtain a new sequence number for this payment. This is used\n\t// to sort the payments in order of creation, and also acts as\n\t// a unique identifier for each payment.\n\tsequenceNum, err := p.nextPaymentSequence()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar b bytes.Buffer\n\tif err := serializePaymentCreationInfo(&b, info); err != nil {\n\t\treturn err\n\t}\n\tinfoBytes := b.Bytes()\n\n\tvar updateErr error\n\terr = kvdb.Batch(p.db.Backend, func(tx kvdb.RwTx) error {\n\t\t// Reset the update error, to avoid carrying over an error\n\t\t// from a previous execution of the batched db transaction.\n\t\tupdateErr = nil\n\n\t\tprefetchPayment(tx, paymentHash)\n\t\tbucket, err := createPaymentBucket(tx, paymentHash)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Get the existing status of this payment, if any.\n\t\tpaymentStatus, err := fetchPaymentStatus(bucket)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tswitch paymentStatus {\n\n\t\t// We allow retrying failed payments.\n\t\tcase StatusFailed:\n\n\t\t// This is a new payment that is being initialized for the\n\t\t// first time.\n\t\tcase StatusUnknown:\n\n\t\t// We already have an InFlight payment on the network. We will\n\t\t// disallow any new payments.\n\t\tcase StatusInFlight:\n\t\t\tupdateErr = ErrPaymentInFlight\n\t\t\treturn nil\n\n\t\t// We've already succeeded a payment to this payment hash,\n\t\t// forbid the switch from sending another.\n\t\tcase StatusSucceeded:\n\t\t\tupdateErr = ErrAlreadyPaid\n\t\t\treturn nil\n\n\t\tdefault:\n\t\t\tupdateErr = ErrUnknownPaymentStatus\n\t\t\treturn nil\n\t\t}\n\n\t\t// Before we set our new sequence number, we check whether this\n\t\t// payment has a previously set sequence number and remove its\n\t\t// index entry if it exists. This happens in the case where we\n\t\t// have a previously attempted payment which was left in a state\n\t\t// where we can retry.\n\t\tseqBytes := bucket.Get(paymentSequenceKey)\n\t\tif seqBytes != nil {\n\t\t\tindexBucket := tx.ReadWriteBucket(paymentsIndexBucket)\n\t\t\tif err := indexBucket.Delete(seqBytes); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\t// Once we have obtained a sequence number, we add an entry\n\t\t// to our index bucket which will map the sequence number to\n\t\t// our payment identifier.\n\t\terr = createPaymentIndexEntry(\n\t\t\ttx, sequenceNum, info.PaymentIdentifier,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = bucket.Put(paymentSequenceKey, sequenceNum)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Add the payment info to the bucket, which contains the\n\t\t// static information for this payment\n\t\terr = bucket.Put(paymentCreationInfoKey, infoBytes)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// We'll delete any lingering HTLCs to start with, in case we\n\t\t// are initializing a payment that was attempted earlier, but\n\t\t// left in a state where we could retry.\n\t\terr = bucket.DeleteNestedBucket(paymentHtlcsBucket)\n\t\tif err != nil && err != kvdb.ErrBucketNotFound {\n\t\t\treturn err\n\t\t}\n\n\t\t// Also delete any lingering failure info now that we are\n\t\t// re-attempting.\n\t\treturn bucket.Delete(paymentFailInfoKey)\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn updateErr\n}\n\n// DeleteFailedAttempts deletes all failed htlcs for a payment if configured\n// by the PaymentControl db.",
      "length": 3018,
      "tokens": 469,
      "embedding": []
    },
    {
      "slug": "func (p *PaymentControl) DeleteFailedAttempts(hash lntypes.Hash) error {",
      "content": "func (p *PaymentControl) DeleteFailedAttempts(hash lntypes.Hash) error {\n\tif !p.db.keepFailedPaymentAttempts {\n\t\tconst failedHtlcsOnly = true\n\t\terr := p.db.DeletePayment(hash, failedHtlcsOnly)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// paymentIndexTypeHash is a payment index type which indicates that we have\n// created an index of payment sequence number to payment hash.",
      "length": 303,
      "tokens": 46,
      "embedding": []
    },
    {
      "slug": "type paymentIndexType uint8",
      "content": "type paymentIndexType uint8\n\n// paymentIndexTypeHash is a payment index type which indicates that we have\n// created an index of payment sequence number to payment hash.\nconst paymentIndexTypeHash paymentIndexType = 0\n\n// createPaymentIndexEntry creates a payment hash typed index for a payment. The\n// index produced contains a payment index type (which can be used in future to\n// signal different payment index types) and the payment identifier.",
      "length": 413,
      "tokens": 65,
      "embedding": []
    },
    {
      "slug": "func createPaymentIndexEntry(tx kvdb.RwTx, sequenceNumber []byte,",
      "content": "func createPaymentIndexEntry(tx kvdb.RwTx, sequenceNumber []byte,\n\tid lntypes.Hash) error {\n\n\tvar b bytes.Buffer\n\tif err := WriteElements(&b, paymentIndexTypeHash, id[:]); err != nil {\n\t\treturn err\n\t}\n\n\tindexes := tx.ReadWriteBucket(paymentsIndexBucket)\n\treturn indexes.Put(sequenceNumber, b.Bytes())\n}\n\n// deserializePaymentIndex deserializes a payment index entry. This function\n// currently only supports deserialization of payment hash indexes, and will\n// fail for other types.",
      "length": 403,
      "tokens": 52,
      "embedding": []
    },
    {
      "slug": "func deserializePaymentIndex(r io.Reader) (lntypes.Hash, error) {",
      "content": "func deserializePaymentIndex(r io.Reader) (lntypes.Hash, error) {\n\tvar (\n\t\tindexType   paymentIndexType\n\t\tpaymentHash []byte\n\t)\n\n\tif err := ReadElements(r, &indexType, &paymentHash); err != nil {\n\t\treturn lntypes.Hash{}, err\n\t}\n\n\t// While we only have on payment index type, we do not need to use our\n\t// index type to deserialize the index. However, we sanity check that\n\t// this type is as expected, since we had to read it out anyway.\n\tif indexType != paymentIndexTypeHash {\n\t\treturn lntypes.Hash{}, fmt.Errorf(\"unknown payment index \"+\n\t\t\t\"type: %v\", indexType)\n\t}\n\n\thash, err := lntypes.MakeHash(paymentHash)\n\tif err != nil {\n\t\treturn lntypes.Hash{}, err\n\t}\n\n\treturn hash, nil\n}\n\n// RegisterAttempt atomically records the provided HTLCAttemptInfo to the\n// DB.",
      "length": 673,
      "tokens": 106,
      "embedding": []
    },
    {
      "slug": "func (p *PaymentControl) RegisterAttempt(paymentHash lntypes.Hash,",
      "content": "func (p *PaymentControl) RegisterAttempt(paymentHash lntypes.Hash,\n\tattempt *HTLCAttemptInfo) (*MPPayment, error) {\n\n\t// Serialize the information before opening the db transaction.\n\tvar a bytes.Buffer\n\terr := serializeHTLCAttemptInfo(&a, attempt)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\thtlcInfoBytes := a.Bytes()\n\n\thtlcIDBytes := make([]byte, 8)\n\tbinary.BigEndian.PutUint64(htlcIDBytes, attempt.AttemptID)\n\n\tvar payment *MPPayment\n\terr = kvdb.Batch(p.db.Backend, func(tx kvdb.RwTx) error {\n\t\tprefetchPayment(tx, paymentHash)\n\t\tbucket, err := fetchPaymentBucketUpdate(tx, paymentHash)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tp, err := fetchPayment(bucket)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// We cannot register a new attempt if the payment already has\n\t\t// reached a terminal condition. We check this before\n\t\t// ensureInFlight because it is a more general check.\n\t\tsettle, fail := p.TerminalInfo()\n\t\tif settle != nil || fail != nil {\n\t\t\treturn ErrPaymentTerminal\n\t\t}\n\n\t\t// Ensure the payment is in-flight.\n\t\tif err := ensureInFlight(p); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Make sure any existing shards match the new one with regards\n\t\t// to MPP options.\n\t\tmpp := attempt.Route.FinalHop().MPP\n\t\tfor _, h := range p.InFlightHTLCs() {\n\t\t\thMpp := h.Route.FinalHop().MPP\n\n\t\t\tswitch {\n\t\t\t// We tried to register a non-MPP attempt for a MPP\n\t\t\t// payment.\n\t\t\tcase mpp == nil && hMpp != nil:\n\t\t\t\treturn ErrMPPayment\n\n\t\t\t// We tried to register a MPP shard for a non-MPP\n\t\t\t// payment.\n\t\t\tcase mpp != nil && hMpp == nil:\n\t\t\t\treturn ErrNonMPPayment\n\n\t\t\t// Non-MPP payment, nothing more to validate.\n\t\t\tcase mpp == nil:\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Check that MPP options match.\n\t\t\tif mpp.PaymentAddr() != hMpp.PaymentAddr() {\n\t\t\t\treturn ErrMPPPaymentAddrMismatch\n\t\t\t}\n\n\t\t\tif mpp.TotalMsat() != hMpp.TotalMsat() {\n\t\t\t\treturn ErrMPPTotalAmountMismatch\n\t\t\t}\n\t\t}\n\n\t\t// If this is a non-MPP attempt, it must match the total amount\n\t\t// exactly.\n\t\tamt := attempt.Route.ReceiverAmt()\n\t\tif mpp == nil && amt != p.Info.Value {\n\t\t\treturn ErrValueMismatch\n\t\t}\n\n\t\t// Ensure we aren't sending more than the total payment amount.\n\t\tsentAmt, _ := p.SentAmt()\n\t\tif sentAmt+amt > p.Info.Value {\n\t\t\treturn ErrValueExceedsAmt\n\t\t}\n\n\t\thtlcsBucket, err := bucket.CreateBucketIfNotExists(\n\t\t\tpaymentHtlcsBucket,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = htlcsBucket.Put(\n\t\t\thtlcBucketKey(htlcAttemptInfoKey, htlcIDBytes),\n\t\t\thtlcInfoBytes,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Retrieve attempt info for the notification.\n\t\tpayment, err = fetchPayment(bucket)\n\t\treturn err\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn payment, err\n}\n\n// SettleAttempt marks the given attempt settled with the preimage. If this is\n// a multi shard payment, this might implicitly mean that the full payment\n// succeeded.\n//\n// After invoking this method, InitPayment should always return an error to\n// prevent us from making duplicate payments to the same payment hash. The\n// provided preimage is atomically saved to the DB for record keeping.",
      "length": 2835,
      "tokens": 427,
      "embedding": []
    },
    {
      "slug": "func (p *PaymentControl) SettleAttempt(hash lntypes.Hash,",
      "content": "func (p *PaymentControl) SettleAttempt(hash lntypes.Hash,\n\tattemptID uint64, settleInfo *HTLCSettleInfo) (*MPPayment, error) {\n\n\tvar b bytes.Buffer\n\tif err := serializeHTLCSettleInfo(&b, settleInfo); err != nil {\n\t\treturn nil, err\n\t}\n\tsettleBytes := b.Bytes()\n\n\treturn p.updateHtlcKey(hash, attemptID, htlcSettleInfoKey, settleBytes)\n}\n\n// FailAttempt marks the given payment attempt failed.",
      "length": 322,
      "tokens": 40,
      "embedding": []
    },
    {
      "slug": "func (p *PaymentControl) FailAttempt(hash lntypes.Hash,",
      "content": "func (p *PaymentControl) FailAttempt(hash lntypes.Hash,\n\tattemptID uint64, failInfo *HTLCFailInfo) (*MPPayment, error) {\n\n\tvar b bytes.Buffer\n\tif err := serializeHTLCFailInfo(&b, failInfo); err != nil {\n\t\treturn nil, err\n\t}\n\tfailBytes := b.Bytes()\n\n\treturn p.updateHtlcKey(hash, attemptID, htlcFailInfoKey, failBytes)\n}\n\n// updateHtlcKey updates a database key for the specified htlc.",
      "length": 317,
      "tokens": 42,
      "embedding": []
    },
    {
      "slug": "func (p *PaymentControl) updateHtlcKey(paymentHash lntypes.Hash,",
      "content": "func (p *PaymentControl) updateHtlcKey(paymentHash lntypes.Hash,\n\tattemptID uint64, key, value []byte) (*MPPayment, error) {\n\n\taid := make([]byte, 8)\n\tbinary.BigEndian.PutUint64(aid, attemptID)\n\n\tvar payment *MPPayment\n\terr := kvdb.Batch(p.db.Backend, func(tx kvdb.RwTx) error {\n\t\tpayment = nil\n\n\t\tprefetchPayment(tx, paymentHash)\n\t\tbucket, err := fetchPaymentBucketUpdate(tx, paymentHash)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tp, err := fetchPayment(bucket)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// We can only update keys of in-flight payments. We allow\n\t\t// updating keys even if the payment has reached a terminal\n\t\t// condition, since the HTLC outcomes must still be updated.\n\t\tif err := ensureInFlight(p); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\thtlcsBucket := bucket.NestedReadWriteBucket(paymentHtlcsBucket)\n\t\tif htlcsBucket == nil {\n\t\t\treturn fmt.Errorf(\"htlcs bucket not found\")\n\t\t}\n\n\t\tif htlcsBucket.Get(htlcBucketKey(htlcAttemptInfoKey, aid)) == nil {\n\t\t\treturn fmt.Errorf(\"HTLC with ID %v not registered\",\n\t\t\t\tattemptID)\n\t\t}\n\n\t\t// Make sure the shard is not already failed or settled.\n\t\tif htlcsBucket.Get(htlcBucketKey(htlcFailInfoKey, aid)) != nil {\n\t\t\treturn ErrAttemptAlreadyFailed\n\t\t}\n\n\t\tif htlcsBucket.Get(htlcBucketKey(htlcSettleInfoKey, aid)) != nil {\n\t\t\treturn ErrAttemptAlreadySettled\n\t\t}\n\n\t\t// Add or update the key for this htlc.\n\t\terr = htlcsBucket.Put(htlcBucketKey(key, aid), value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Retrieve attempt info for the notification.\n\t\tpayment, err = fetchPayment(bucket)\n\t\treturn err\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn payment, err\n}\n\n// Fail transitions a payment into the Failed state, and records the reason the\n// payment failed. After invoking this method, InitPayment should return nil on\n// its next call for this payment hash, allowing the switch to make a\n// subsequent payment.",
      "length": 1732,
      "tokens": 247,
      "embedding": []
    },
    {
      "slug": "func (p *PaymentControl) Fail(paymentHash lntypes.Hash,",
      "content": "func (p *PaymentControl) Fail(paymentHash lntypes.Hash,\n\treason FailureReason) (*MPPayment, error) {\n\n\tvar (\n\t\tupdateErr error\n\t\tpayment   *MPPayment\n\t)\n\terr := kvdb.Batch(p.db.Backend, func(tx kvdb.RwTx) error {\n\t\t// Reset the update error, to avoid carrying over an error\n\t\t// from a previous execution of the batched db transaction.\n\t\tupdateErr = nil\n\t\tpayment = nil\n\n\t\tprefetchPayment(tx, paymentHash)\n\t\tbucket, err := fetchPaymentBucketUpdate(tx, paymentHash)\n\t\tif err == ErrPaymentNotInitiated {\n\t\t\tupdateErr = ErrPaymentNotInitiated\n\t\t\treturn nil\n\t\t} else if err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// We mark the payment as failed as long as it is known. This\n\t\t// lets the last attempt to fail with a terminal write its\n\t\t// failure to the PaymentControl without synchronizing with\n\t\t// other attempts.\n\t\tpaymentStatus, err := fetchPaymentStatus(bucket)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif paymentStatus == StatusUnknown {\n\t\t\tupdateErr = ErrPaymentNotInitiated\n\t\t\treturn nil\n\t\t}\n\n\t\t// Put the failure reason in the bucket for record keeping.\n\t\tv := []byte{byte(reason)}\n\t\terr = bucket.Put(paymentFailInfoKey, v)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Retrieve attempt info for the notification, if available.\n\t\tpayment, err = fetchPayment(bucket)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn payment, updateErr\n}\n\n// FetchPayment returns information about a payment from the database.",
      "length": 1339,
      "tokens": 206,
      "embedding": []
    },
    {
      "slug": "func (p *PaymentControl) FetchPayment(paymentHash lntypes.Hash) (",
      "content": "func (p *PaymentControl) FetchPayment(paymentHash lntypes.Hash) (\n\t*MPPayment, error) {\n\n\tvar payment *MPPayment\n\terr := kvdb.View(p.db, func(tx kvdb.RTx) error {\n\t\tprefetchPayment(tx, paymentHash)\n\t\tbucket, err := fetchPaymentBucket(tx, paymentHash)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tpayment, err = fetchPayment(bucket)\n\n\t\treturn err\n\t}, func() {\n\t\tpayment = nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn payment, nil\n}\n\n// prefetchPayment attempts to prefetch as much of the payment as possible to\n// reduce DB roundtrips.",
      "length": 448,
      "tokens": 71,
      "embedding": []
    },
    {
      "slug": "func prefetchPayment(tx kvdb.RTx, paymentHash lntypes.Hash) {",
      "content": "func prefetchPayment(tx kvdb.RTx, paymentHash lntypes.Hash) {\n\trb := kvdb.RootBucket(tx)\n\tkvdb.Prefetch(\n\t\trb,\n\t\t[]string{\n\t\t\t// Prefetch all keys in the payment's bucket.\n\t\t\tstring(paymentsRootBucket),\n\t\t\tstring(paymentHash[:]),\n\t\t},\n\t\t[]string{\n\t\t\t// Prefetch all keys in the payment's htlc bucket.\n\t\t\tstring(paymentsRootBucket),\n\t\t\tstring(paymentHash[:]),\n\t\t\tstring(paymentHtlcsBucket),\n\t\t},\n\t)\n}\n\n// createPaymentBucket creates or fetches the sub-bucket assigned to this\n// payment hash.",
      "length": 411,
      "tokens": 46,
      "embedding": []
    },
    {
      "slug": "func createPaymentBucket(tx kvdb.RwTx, paymentHash lntypes.Hash) (",
      "content": "func createPaymentBucket(tx kvdb.RwTx, paymentHash lntypes.Hash) (\n\tkvdb.RwBucket, error) {\n\n\tpayments, err := tx.CreateTopLevelBucket(paymentsRootBucket)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn payments.CreateBucketIfNotExists(paymentHash[:])\n}\n\n// fetchPaymentBucket fetches the sub-bucket assigned to this payment hash. If\n// the bucket does not exist, it returns ErrPaymentNotInitiated.",
      "length": 319,
      "tokens": 39,
      "embedding": []
    },
    {
      "slug": "func fetchPaymentBucket(tx kvdb.RTx, paymentHash lntypes.Hash) (",
      "content": "func fetchPaymentBucket(tx kvdb.RTx, paymentHash lntypes.Hash) (\n\tkvdb.RBucket, error) {\n\n\tpayments := tx.ReadBucket(paymentsRootBucket)\n\tif payments == nil {\n\t\treturn nil, ErrPaymentNotInitiated\n\t}\n\n\tbucket := payments.NestedReadBucket(paymentHash[:])\n\tif bucket == nil {\n\t\treturn nil, ErrPaymentNotInitiated\n\t}\n\n\treturn bucket, nil\n\n}\n\n// fetchPaymentBucketUpdate is identical to fetchPaymentBucket, but it returns a\n// bucket that can be written to.",
      "length": 370,
      "tokens": 48,
      "embedding": []
    },
    {
      "slug": "func fetchPaymentBucketUpdate(tx kvdb.RwTx, paymentHash lntypes.Hash) (",
      "content": "func fetchPaymentBucketUpdate(tx kvdb.RwTx, paymentHash lntypes.Hash) (\n\tkvdb.RwBucket, error) {\n\n\tpayments := tx.ReadWriteBucket(paymentsRootBucket)\n\tif payments == nil {\n\t\treturn nil, ErrPaymentNotInitiated\n\t}\n\n\tbucket := payments.NestedReadWriteBucket(paymentHash[:])\n\tif bucket == nil {\n\t\treturn nil, ErrPaymentNotInitiated\n\t}\n\n\treturn bucket, nil\n}\n\n// nextPaymentSequence returns the next sequence number to store for a new\n// payment.",
      "length": 353,
      "tokens": 45,
      "embedding": []
    },
    {
      "slug": "func (p *PaymentControl) nextPaymentSequence() ([]byte, error) {",
      "content": "func (p *PaymentControl) nextPaymentSequence() ([]byte, error) {\n\tp.paymentSeqMx.Lock()\n\tdefer p.paymentSeqMx.Unlock()\n\n\t// Set a new upper bound in the DB every 1000 payments to avoid\n\t// conflicts on the sequence when using etcd.\n\tif p.currPaymentSeq == p.storedPaymentSeq {\n\t\tvar currPaymentSeq, newUpperBound uint64\n\t\tif err := kvdb.Update(p.db.Backend, func(tx kvdb.RwTx) error {\n\t\t\tpaymentsBucket, err := tx.CreateTopLevelBucket(\n\t\t\t\tpaymentsRootBucket,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tcurrPaymentSeq = paymentsBucket.Sequence()\n\t\t\tnewUpperBound = currPaymentSeq + paymentSeqBlockSize\n\t\t\treturn paymentsBucket.SetSequence(newUpperBound)\n\t\t}, func() {}); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// We lazy initialize the cached currPaymentSeq here using the\n\t\t// first nextPaymentSequence() call. This if statement will auto\n\t\t// initialize our stored currPaymentSeq, since by default both\n\t\t// this variable and storedPaymentSeq are zero which in turn\n\t\t// will have us fetch the current values from the DB.\n\t\tif p.currPaymentSeq == 0 {\n\t\t\tp.currPaymentSeq = currPaymentSeq\n\t\t}\n\n\t\tp.storedPaymentSeq = newUpperBound\n\t}\n\n\tp.currPaymentSeq++\n\tb := make([]byte, 8)\n\tbinary.BigEndian.PutUint64(b, p.currPaymentSeq)\n\n\treturn b, nil\n}\n\n// fetchPaymentStatus fetches the payment status of the payment. If the payment\n// isn't found, it will default to \"StatusUnknown\".",
      "length": 1275,
      "tokens": 170,
      "embedding": []
    },
    {
      "slug": "func fetchPaymentStatus(bucket kvdb.RBucket) (PaymentStatus, error) {",
      "content": "func fetchPaymentStatus(bucket kvdb.RBucket) (PaymentStatus, error) {\n\t// Creation info should be set for all payments, regardless of state.\n\t// If not, it is unknown.\n\tif bucket.Get(paymentCreationInfoKey) == nil {\n\t\treturn StatusUnknown, nil\n\t}\n\n\tpayment, err := fetchPayment(bucket)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn payment.Status, nil\n}\n\n// ensureInFlight checks whether the payment found in the given bucket has\n// status InFlight, and returns an error otherwise. This should be used to\n// ensure we only mark in-flight payments as succeeded or failed.",
      "length": 483,
      "tokens": 80,
      "embedding": []
    },
    {
      "slug": "func ensureInFlight(payment *MPPayment) error {",
      "content": "func ensureInFlight(payment *MPPayment) error {\n\tpaymentStatus := payment.Status\n\n\tswitch {\n\n\t// The payment was indeed InFlight.\n\tcase paymentStatus == StatusInFlight:\n\t\treturn nil\n\n\t// Our records show the payment as unknown, meaning it never\n\t// should have left the switch.\n\tcase paymentStatus == StatusUnknown:\n\t\treturn ErrPaymentNotInitiated\n\n\t// The payment succeeded previously.\n\tcase paymentStatus == StatusSucceeded:\n\t\treturn ErrPaymentAlreadySucceeded\n\n\t// The payment was already failed.\n\tcase paymentStatus == StatusFailed:\n\t\treturn ErrPaymentAlreadyFailed\n\n\tdefault:\n\t\treturn ErrUnknownPaymentStatus\n\t}\n}\n\n// FetchInFlightPayments returns all payments with status InFlight.",
      "length": 613,
      "tokens": 76,
      "embedding": []
    },
    {
      "slug": "func (p *PaymentControl) FetchInFlightPayments() ([]*MPPayment, error) {",
      "content": "func (p *PaymentControl) FetchInFlightPayments() ([]*MPPayment, error) {\n\tvar inFlights []*MPPayment\n\terr := kvdb.View(p.db, func(tx kvdb.RTx) error {\n\t\tpayments := tx.ReadBucket(paymentsRootBucket)\n\t\tif payments == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn payments.ForEach(func(k, _ []byte) error {\n\t\t\tbucket := payments.NestedReadBucket(k)\n\t\t\tif bucket == nil {\n\t\t\t\treturn fmt.Errorf(\"non bucket element\")\n\t\t\t}\n\n\t\t\t// If the status is not InFlight, we can return early.\n\t\t\tpaymentStatus, err := fetchPaymentStatus(bucket)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif paymentStatus != StatusInFlight {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tp, err := fetchPayment(bucket)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tinFlights = append(inFlights, p)\n\t\t\treturn nil\n\t\t})\n\t}, func() {\n\t\tinFlights = nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn inFlights, nil\n}\n",
      "length": 733,
      "tokens": 110,
      "embedding": []
    }
  ]
}