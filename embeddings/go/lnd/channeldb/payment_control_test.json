{
  "filepath": "../implementations/go/lnd/channeldb/payment_control_test.go",
  "package": "channeldb",
  "sections": [
    {
      "slug": "func genPreimage() ([32]byte, error) {",
      "content": "func genPreimage() ([32]byte, error) {\n\tvar preimage [32]byte\n\tif _, err := io.ReadFull(rand.Reader, preimage[:]); err != nil {\n\t\treturn preimage, err\n\t}\n\treturn preimage, nil\n}\n",
      "length": 133,
      "tokens": 21,
      "embedding": []
    },
    {
      "slug": "func genInfo() (*PaymentCreationInfo, *HTLCAttemptInfo,",
      "content": "func genInfo() (*PaymentCreationInfo, *HTLCAttemptInfo,\n\tlntypes.Preimage, error) {\n\n\tpreimage, err := genPreimage()\n\tif err != nil {\n\t\treturn nil, nil, preimage, fmt.Errorf(\"unable to \"+\n\t\t\t\"generate preimage: %v\", err)\n\t}\n\n\trhash := sha256.Sum256(preimage[:])\n\tattempt := NewHtlcAttemptInfo(\n\t\t0, priv, *testRoute.Copy(), time.Time{}, nil,\n\t)\n\treturn &PaymentCreationInfo{\n\t\tPaymentIdentifier: rhash,\n\t\tValue:             testRoute.ReceiverAmt(),\n\t\tCreationTime:      time.Unix(time.Now().Unix(), 0),\n\t\tPaymentRequest:    []byte(\"hola\"),\n\t}, attempt, preimage, nil\n}\n\n// TestPaymentControlSwitchFail checks that payment status returns to Failed\n// status after failing, and that InitPayment allows another HTLC for the\n// same payment hash.",
      "length": 664,
      "tokens": 77,
      "embedding": []
    },
    {
      "slug": "func TestPaymentControlSwitchFail(t *testing.T) {",
      "content": "func TestPaymentControlSwitchFail(t *testing.T) {\n\tt.Parallel()\n\n\tdb, err := MakeTestDB(t)\n\trequire.NoError(t, err, \"unable to init db\")\n\n\tpControl := NewPaymentControl(db)\n\n\tinfo, attempt, preimg, err := genInfo()\n\trequire.NoError(t, err, \"unable to generate htlc message\")\n\n\t// Sends base htlc message which initiate StatusInFlight.\n\terr = pControl.InitPayment(info.PaymentIdentifier, info)\n\trequire.NoError(t, err, \"unable to send htlc message\")\n\n\tassertPaymentIndex(t, pControl, info.PaymentIdentifier)\n\tassertPaymentStatus(t, pControl, info.PaymentIdentifier, StatusInFlight)\n\tassertPaymentInfo(\n\t\tt, pControl, info.PaymentIdentifier, info, nil, nil,\n\t)\n\n\t// Fail the payment, which should moved it to Failed.\n\tfailReason := FailureReasonNoRoute\n\t_, err = pControl.Fail(info.PaymentIdentifier, failReason)\n\trequire.NoError(t, err, \"unable to fail payment hash\")\n\n\t// Verify the status is indeed Failed.\n\tassertPaymentStatus(t, pControl, info.PaymentIdentifier, StatusFailed)\n\tassertPaymentInfo(\n\t\tt, pControl, info.PaymentIdentifier, info, &failReason, nil,\n\t)\n\n\t// Lookup the payment so we can get its old sequence number before it is\n\t// overwritten.\n\tpayment, err := pControl.FetchPayment(info.PaymentIdentifier)\n\trequire.NoError(t, err)\n\n\t// Sends the htlc again, which should succeed since the prior payment\n\t// failed.\n\terr = pControl.InitPayment(info.PaymentIdentifier, info)\n\trequire.NoError(t, err, \"unable to send htlc message\")\n\n\t// Check that our index has been updated, and the old index has been\n\t// removed.\n\tassertPaymentIndex(t, pControl, info.PaymentIdentifier)\n\tassertNoIndex(t, pControl, payment.SequenceNum)\n\n\tassertPaymentStatus(t, pControl, info.PaymentIdentifier, StatusInFlight)\n\tassertPaymentInfo(\n\t\tt, pControl, info.PaymentIdentifier, info, nil, nil,\n\t)\n\n\t// Record a new attempt. In this test scenario, the attempt fails.\n\t// However, this is not communicated to control tower in the current\n\t// implementation. It only registers the initiation of the attempt.\n\t_, err = pControl.RegisterAttempt(info.PaymentIdentifier, attempt)\n\trequire.NoError(t, err, \"unable to register attempt\")\n\n\thtlcReason := HTLCFailUnreadable\n\t_, err = pControl.FailAttempt(\n\t\tinfo.PaymentIdentifier, attempt.AttemptID,\n\t\t&HTLCFailInfo{\n\t\t\tReason: htlcReason,\n\t\t},\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tassertPaymentStatus(t, pControl, info.PaymentIdentifier, StatusInFlight)\n\n\thtlc := &htlcStatus{\n\t\tHTLCAttemptInfo: attempt,\n\t\tfailure:         &htlcReason,\n\t}\n\n\tassertPaymentInfo(t, pControl, info.PaymentIdentifier, info, nil, htlc)\n\n\t// Record another attempt.\n\tattempt.AttemptID = 1\n\t_, err = pControl.RegisterAttempt(info.PaymentIdentifier, attempt)\n\trequire.NoError(t, err, \"unable to send htlc message\")\n\tassertPaymentStatus(t, pControl, info.PaymentIdentifier, StatusInFlight)\n\n\thtlc = &htlcStatus{\n\t\tHTLCAttemptInfo: attempt,\n\t}\n\n\tassertPaymentInfo(\n\t\tt, pControl, info.PaymentIdentifier, info, nil, htlc,\n\t)\n\n\t// Settle the attempt and verify that status was changed to\n\t// StatusSucceeded.\n\tpayment, err = pControl.SettleAttempt(\n\t\tinfo.PaymentIdentifier, attempt.AttemptID,\n\t\t&HTLCSettleInfo{\n\t\t\tPreimage: preimg,\n\t\t},\n\t)\n\trequire.NoError(t, err, \"error shouldn't have been received, got\")\n\n\tif len(payment.HTLCs) != 2 {\n\t\tt.Fatalf(\"payment should have two htlcs, got: %d\",\n\t\t\tlen(payment.HTLCs))\n\t}\n\n\terr = assertRouteEqual(&payment.HTLCs[0].Route, &attempt.Route)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected route returned: %v vs %v: %v\",\n\t\t\tspew.Sdump(attempt.Route),\n\t\t\tspew.Sdump(payment.HTLCs[0].Route), err)\n\t}\n\n\tassertPaymentStatus(t, pControl, info.PaymentIdentifier, StatusSucceeded)\n\n\thtlc.settle = &preimg\n\tassertPaymentInfo(\n\t\tt, pControl, info.PaymentIdentifier, info, nil, htlc,\n\t)\n\n\t// Attempt a final payment, which should now fail since the prior\n\t// payment succeed.\n\terr = pControl.InitPayment(info.PaymentIdentifier, info)\n\tif err != ErrAlreadyPaid {\n\t\tt.Fatalf(\"unable to send htlc message: %v\", err)\n\t}\n}\n\n// TestPaymentControlSwitchDoubleSend checks the ability of payment control to\n// prevent double sending of htlc message, when message is in StatusInFlight.",
      "length": 3927,
      "tokens": 443,
      "embedding": []
    },
    {
      "slug": "func TestPaymentControlSwitchDoubleSend(t *testing.T) {",
      "content": "func TestPaymentControlSwitchDoubleSend(t *testing.T) {\n\tt.Parallel()\n\n\tdb, err := MakeTestDB(t)\n\trequire.NoError(t, err, \"unable to init db\")\n\n\tpControl := NewPaymentControl(db)\n\n\tinfo, attempt, preimg, err := genInfo()\n\trequire.NoError(t, err, \"unable to generate htlc message\")\n\n\t// Sends base htlc message which initiate base status and move it to\n\t// StatusInFlight and verifies that it was changed.\n\terr = pControl.InitPayment(info.PaymentIdentifier, info)\n\trequire.NoError(t, err, \"unable to send htlc message\")\n\n\tassertPaymentIndex(t, pControl, info.PaymentIdentifier)\n\tassertPaymentStatus(t, pControl, info.PaymentIdentifier, StatusInFlight)\n\tassertPaymentInfo(\n\t\tt, pControl, info.PaymentIdentifier, info, nil, nil,\n\t)\n\n\t// Try to initiate double sending of htlc message with the same\n\t// payment hash, should result in error indicating that payment has\n\t// already been sent.\n\terr = pControl.InitPayment(info.PaymentIdentifier, info)\n\tif err != ErrPaymentInFlight {\n\t\tt.Fatalf(\"payment control wrong behaviour: \" +\n\t\t\t\"double sending must trigger ErrPaymentInFlight error\")\n\t}\n\n\t// Record an attempt.\n\t_, err = pControl.RegisterAttempt(info.PaymentIdentifier, attempt)\n\trequire.NoError(t, err, \"unable to send htlc message\")\n\tassertPaymentStatus(t, pControl, info.PaymentIdentifier, StatusInFlight)\n\n\thtlc := &htlcStatus{\n\t\tHTLCAttemptInfo: attempt,\n\t}\n\tassertPaymentInfo(\n\t\tt, pControl, info.PaymentIdentifier, info, nil, htlc,\n\t)\n\n\t// Sends base htlc message which initiate StatusInFlight.\n\terr = pControl.InitPayment(info.PaymentIdentifier, info)\n\tif err != ErrPaymentInFlight {\n\t\tt.Fatalf(\"payment control wrong behaviour: \" +\n\t\t\t\"double sending must trigger ErrPaymentInFlight error\")\n\t}\n\n\t// After settling, the error should be ErrAlreadyPaid.\n\t_, err = pControl.SettleAttempt(\n\t\tinfo.PaymentIdentifier, attempt.AttemptID,\n\t\t&HTLCSettleInfo{\n\t\t\tPreimage: preimg,\n\t\t},\n\t)\n\trequire.NoError(t, err, \"error shouldn't have been received, got\")\n\tassertPaymentStatus(t, pControl, info.PaymentIdentifier, StatusSucceeded)\n\n\thtlc.settle = &preimg\n\tassertPaymentInfo(t, pControl, info.PaymentIdentifier, info, nil, htlc)\n\n\terr = pControl.InitPayment(info.PaymentIdentifier, info)\n\tif err != ErrAlreadyPaid {\n\t\tt.Fatalf(\"unable to send htlc message: %v\", err)\n\t}\n}\n\n// TestPaymentControlSuccessesWithoutInFlight checks that the payment\n// control will disallow calls to Success when no payment is in flight.",
      "length": 2288,
      "tokens": 264,
      "embedding": []
    },
    {
      "slug": "func TestPaymentControlSuccessesWithoutInFlight(t *testing.T) {",
      "content": "func TestPaymentControlSuccessesWithoutInFlight(t *testing.T) {\n\tt.Parallel()\n\n\tdb, err := MakeTestDB(t)\n\trequire.NoError(t, err, \"unable to init db\")\n\n\tpControl := NewPaymentControl(db)\n\n\tinfo, _, preimg, err := genInfo()\n\trequire.NoError(t, err, \"unable to generate htlc message\")\n\n\t// Attempt to complete the payment should fail.\n\t_, err = pControl.SettleAttempt(\n\t\tinfo.PaymentIdentifier, 0,\n\t\t&HTLCSettleInfo{\n\t\t\tPreimage: preimg,\n\t\t},\n\t)\n\tif err != ErrPaymentNotInitiated {\n\t\tt.Fatalf(\"expected ErrPaymentNotInitiated, got %v\", err)\n\t}\n\n\tassertPaymentStatus(t, pControl, info.PaymentIdentifier, StatusUnknown)\n}\n\n// TestPaymentControlFailsWithoutInFlight checks that a strict payment\n// control will disallow calls to Fail when no payment is in flight.",
      "length": 669,
      "tokens": 82,
      "embedding": []
    },
    {
      "slug": "func TestPaymentControlFailsWithoutInFlight(t *testing.T) {",
      "content": "func TestPaymentControlFailsWithoutInFlight(t *testing.T) {\n\tt.Parallel()\n\n\tdb, err := MakeTestDB(t)\n\trequire.NoError(t, err, \"unable to init db\")\n\n\tpControl := NewPaymentControl(db)\n\n\tinfo, _, _, err := genInfo()\n\trequire.NoError(t, err, \"unable to generate htlc message\")\n\n\t// Calling Fail should return an error.\n\t_, err = pControl.Fail(info.PaymentIdentifier, FailureReasonNoRoute)\n\tif err != ErrPaymentNotInitiated {\n\t\tt.Fatalf(\"expected ErrPaymentNotInitiated, got %v\", err)\n\t}\n\n\tassertPaymentStatus(t, pControl, info.PaymentIdentifier, StatusUnknown)\n}\n\n// TestPaymentControlDeleteNonInFlight checks that calling DeletePayments only\n// deletes payments from the database that are not in-flight.",
      "length": 621,
      "tokens": 72,
      "embedding": []
    },
    {
      "slug": "func TestPaymentControlDeleteNonInFlight(t *testing.T) {",
      "content": "func TestPaymentControlDeleteNonInFlight(t *testing.T) {\n\tt.Parallel()\n\n\tdb, err := MakeTestDB(t)\n\trequire.NoError(t, err, \"unable to init db\")\n\n\t// Create a sequence number for duplicate payments that will not collide\n\t// with the sequence numbers for the payments we create. These values\n\t// start at 1, so 9999 is a safe bet for this test.\n\tvar duplicateSeqNr = 9999\n\n\tpControl := NewPaymentControl(db)\n\n\tpayments := []struct {\n\t\tfailed       bool\n\t\tsuccess      bool\n\t\thasDuplicate bool\n\t}{\n\t\t{\n\t\t\tfailed:       true,\n\t\t\tsuccess:      false,\n\t\t\thasDuplicate: false,\n\t\t},\n\t\t{\n\t\t\tfailed:       false,\n\t\t\tsuccess:      true,\n\t\t\thasDuplicate: false,\n\t\t},\n\t\t{\n\t\t\tfailed:       false,\n\t\t\tsuccess:      false,\n\t\t\thasDuplicate: false,\n\t\t},\n\t\t{\n\t\t\tfailed:       false,\n\t\t\tsuccess:      true,\n\t\t\thasDuplicate: true,\n\t\t},\n\t}\n\n\tvar numSuccess, numInflight int\n\n\tfor _, p := range payments {\n\t\tinfo, attempt, preimg, err := genInfo()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to generate htlc message: %v\", err)\n\t\t}\n\n\t\t// Sends base htlc message which initiate StatusInFlight.\n\t\terr = pControl.InitPayment(info.PaymentIdentifier, info)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to send htlc message: %v\", err)\n\t\t}\n\t\t_, err = pControl.RegisterAttempt(info.PaymentIdentifier, attempt)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to send htlc message: %v\", err)\n\t\t}\n\n\t\thtlc := &htlcStatus{\n\t\t\tHTLCAttemptInfo: attempt,\n\t\t}\n\n\t\tif p.failed {\n\t\t\t// Fail the payment attempt.\n\t\t\thtlcFailure := HTLCFailUnreadable\n\t\t\t_, err := pControl.FailAttempt(\n\t\t\t\tinfo.PaymentIdentifier, attempt.AttemptID,\n\t\t\t\t&HTLCFailInfo{\n\t\t\t\t\tReason: htlcFailure,\n\t\t\t\t},\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to fail htlc: %v\", err)\n\t\t\t}\n\n\t\t\t// Fail the payment, which should moved it to Failed.\n\t\t\tfailReason := FailureReasonNoRoute\n\t\t\t_, err = pControl.Fail(info.PaymentIdentifier, failReason)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to fail payment hash: %v\", err)\n\t\t\t}\n\n\t\t\t// Verify the status is indeed Failed.\n\t\t\tassertPaymentStatus(t, pControl, info.PaymentIdentifier, StatusFailed)\n\n\t\t\thtlc.failure = &htlcFailure\n\t\t\tassertPaymentInfo(\n\t\t\t\tt, pControl, info.PaymentIdentifier, info,\n\t\t\t\t&failReason, htlc,\n\t\t\t)\n\t\t} else if p.success {\n\t\t\t// Verifies that status was changed to StatusSucceeded.\n\t\t\t_, err := pControl.SettleAttempt(\n\t\t\t\tinfo.PaymentIdentifier, attempt.AttemptID,\n\t\t\t\t&HTLCSettleInfo{\n\t\t\t\t\tPreimage: preimg,\n\t\t\t\t},\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"error shouldn't have been received, got: %v\", err)\n\t\t\t}\n\n\t\t\tassertPaymentStatus(t, pControl, info.PaymentIdentifier, StatusSucceeded)\n\n\t\t\thtlc.settle = &preimg\n\t\t\tassertPaymentInfo(\n\t\t\t\tt, pControl, info.PaymentIdentifier, info, nil, htlc,\n\t\t\t)\n\n\t\t\tnumSuccess++\n\t\t} else {\n\t\t\tassertPaymentStatus(t, pControl, info.PaymentIdentifier, StatusInFlight)\n\t\t\tassertPaymentInfo(\n\t\t\t\tt, pControl, info.PaymentIdentifier, info, nil, htlc,\n\t\t\t)\n\n\t\t\tnumInflight++\n\t\t}\n\n\t\t// If the payment is intended to have a duplicate payment, we\n\t\t// add one.\n\t\tif p.hasDuplicate {\n\t\t\tappendDuplicatePayment(\n\t\t\t\tt, pControl.db, info.PaymentIdentifier,\n\t\t\t\tuint64(duplicateSeqNr), preimg,\n\t\t\t)\n\t\t\tduplicateSeqNr++\n\t\t\tnumSuccess++\n\t\t}\n\t}\n\n\t// Delete all failed payments.\n\tif err := db.DeletePayments(true, false); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// This should leave the succeeded and in-flight payments.\n\tdbPayments, err := db.FetchPayments()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif len(dbPayments) != numSuccess+numInflight {\n\t\tt.Fatalf(\"expected %d payments, got %d\",\n\t\t\tnumSuccess+numInflight, len(dbPayments))\n\t}\n\n\tvar s, i int\n\tfor _, p := range dbPayments {\n\t\tt.Log(\"fetch payment has status\", p.Status)\n\t\tswitch p.Status {\n\t\tcase StatusSucceeded:\n\t\t\ts++\n\t\tcase StatusInFlight:\n\t\t\ti++\n\t\t}\n\t}\n\n\tif s != numSuccess {\n\t\tt.Fatalf(\"expected %d succeeded payments , got %d\",\n\t\t\tnumSuccess, s)\n\t}\n\tif i != numInflight {\n\t\tt.Fatalf(\"expected %d in-flight payments, got %d\",\n\t\t\tnumInflight, i)\n\t}\n\n\t// Now delete all payments except in-flight.\n\tif err := db.DeletePayments(false, false); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// This should leave the in-flight payment.\n\tdbPayments, err = db.FetchPayments()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif len(dbPayments) != numInflight {\n\t\tt.Fatalf(\"expected %d payments, got %d\", numInflight,\n\t\t\tlen(dbPayments))\n\t}\n\n\tfor _, p := range dbPayments {\n\t\tif p.Status != StatusInFlight {\n\t\t\tt.Fatalf(\"expected in-fligth status, got %v\", p.Status)\n\t\t}\n\t}\n\n\t// Finally, check that we only have a single index left in the payment\n\t// index bucket.\n\tvar indexCount int\n\terr = kvdb.View(db, func(tx walletdb.ReadTx) error {\n\t\tindex := tx.ReadBucket(paymentsIndexBucket)\n\n\t\treturn index.ForEach(func(k, v []byte) error {\n\t\t\tindexCount++\n\t\t\treturn nil\n\t\t})\n\t}, func() { indexCount = 0 })\n\trequire.NoError(t, err)\n\n\trequire.Equal(t, 1, indexCount)\n}\n\n// TestPaymentControlDeletePayments tests that DeletePayments correctly deletes\n// information about completed payments from the database.",
      "length": 4654,
      "tokens": 607,
      "embedding": []
    },
    {
      "slug": "func TestPaymentControlDeletePayments(t *testing.T) {",
      "content": "func TestPaymentControlDeletePayments(t *testing.T) {\n\tt.Parallel()\n\n\tdb, err := MakeTestDB(t)\n\trequire.NoError(t, err, \"unable to init db\")\n\n\tpControl := NewPaymentControl(db)\n\n\t// Register three payments:\n\t// 1. A payment with two failed attempts.\n\t// 2. A payment with one failed and one settled attempt.\n\t// 3. A payment with one failed and one in-flight attempt.\n\tpayments := []*payment{\n\t\t{status: StatusFailed},\n\t\t{status: StatusSucceeded},\n\t\t{status: StatusInFlight},\n\t}\n\n\t// Use helper function to register the test payments in the data and\n\t// populate the data to the payments slice.\n\tcreateTestPayments(t, pControl, payments)\n\n\t// Check that all payments are there as we added them.\n\tassertPayments(t, db, payments)\n\n\t// Delete HTLC attempts for failed payments only.\n\trequire.NoError(t, db.DeletePayments(true, true))\n\n\t// The failed payment is the only altered one.\n\tpayments[0].htlcs = 0\n\tassertPayments(t, db, payments)\n\n\t// Delete failed attempts for all payments.\n\trequire.NoError(t, db.DeletePayments(false, true))\n\n\t// The failed attempts should be deleted, except for the in-flight\n\t// payment, that shouldn't be altered until it has completed.\n\tpayments[1].htlcs = 1\n\tassertPayments(t, db, payments)\n\n\t// Now delete all failed payments.\n\trequire.NoError(t, db.DeletePayments(true, false))\n\n\tassertPayments(t, db, payments[1:])\n\n\t// Finally delete all completed payments.\n\trequire.NoError(t, db.DeletePayments(false, false))\n\n\tassertPayments(t, db, payments[2:])\n}\n\n// TestPaymentControlDeleteSinglePayment tests that DeletePayment correctly\n// deletes information about a completed payment from the database.",
      "length": 1525,
      "tokens": 200,
      "embedding": []
    },
    {
      "slug": "func TestPaymentControlDeleteSinglePayment(t *testing.T) {",
      "content": "func TestPaymentControlDeleteSinglePayment(t *testing.T) {\n\tt.Parallel()\n\n\tdb, err := MakeTestDB(t)\n\trequire.NoError(t, err, \"unable to init db\")\n\n\tpControl := NewPaymentControl(db)\n\n\t// Register four payments:\n\t// All payments will have one failed HTLC attempt and one HTLC attempt\n\t// according to its final status.\n\t// 1. A payment with two failed attempts.\n\t// 2. Another payment with two failed attempts.\n\t// 3. A payment with one failed and one settled attempt.\n\t// 4. A payment with one failed and one in-flight attempt.\n\n\t// Initiate payments, which is a slice of payment that is used as\n\t// template to create the corresponding test payments in the database.\n\t//\n\t// Note: The payment id and number of htlc attempts of each payment will\n\t// be added to this slice when creating the payments below.\n\t// This allows the slice to be used directly for testing purposes.\n\tpayments := []*payment{\n\t\t{status: StatusFailed},\n\t\t{status: StatusFailed},\n\t\t{status: StatusSucceeded},\n\t\t{status: StatusInFlight},\n\t}\n\n\t// Use helper function to register the test payments in the data and\n\t// populate the data to the payments slice.\n\tcreateTestPayments(t, pControl, payments)\n\n\t// Check that all payments are there as we added them.\n\tassertPayments(t, db, payments)\n\n\t// Delete HTLC attempts for first payment only.\n\trequire.NoError(t, db.DeletePayment(payments[0].id, true))\n\n\t// The first payment is the only altered one as its failed HTLC should\n\t// have been removed but is still present as payment.\n\tpayments[0].htlcs = 0\n\tassertPayments(t, db, payments)\n\n\t// Delete the first payment completely.\n\trequire.NoError(t, db.DeletePayment(payments[0].id, false))\n\n\t// The first payment should have been deleted.\n\tassertPayments(t, db, payments[1:])\n\n\t// Now delete the second payment completely.\n\trequire.NoError(t, db.DeletePayment(payments[1].id, false))\n\n\t// The Second payment should have been deleted.\n\tassertPayments(t, db, payments[2:])\n\n\t// Delete failed HTLC attempts for the third payment.\n\trequire.NoError(t, db.DeletePayment(payments[2].id, true))\n\n\t// Only the successful HTLC attempt should be left for the third payment.\n\tpayments[2].htlcs = 1\n\tassertPayments(t, db, payments[2:])\n\n\t// Now delete the third payment completely.\n\trequire.NoError(t, db.DeletePayment(payments[2].id, false))\n\n\t// Only the last payment should be left.\n\tassertPayments(t, db, payments[3:])\n\n\t// Deleting HTLC attempts from InFlight payments should not work and an\n\t// error returned.\n\trequire.Error(t, db.DeletePayment(payments[3].id, true))\n\n\t// The payment is InFlight and therefore should not have been altered.\n\tassertPayments(t, db, payments[3:])\n\n\t// Finally deleting the InFlight payment should also not work and an\n\t// error returned.\n\trequire.Error(t, db.DeletePayment(payments[3].id, false))\n\n\t// The payment is InFlight and therefore should not have been altered.\n\tassertPayments(t, db, payments[3:])\n}\n\n// TestPaymentControlMultiShard checks the ability of payment control to\n// have multiple in-flight HTLCs for a single payment.",
      "length": 2887,
      "tokens": 406,
      "embedding": []
    },
    {
      "slug": "func TestPaymentControlMultiShard(t *testing.T) {",
      "content": "func TestPaymentControlMultiShard(t *testing.T) {\n\tt.Parallel()\n\n\t// We will register three HTLC attempts, and always fail the second\n\t// one. We'll generate all combinations of settling/failing the first\n\t// and third HTLC, and assert that the payment status end up as we\n\t// expect.\n\ttype testCase struct {\n\t\tsettleFirst bool\n\t\tsettleLast  bool\n\t}\n\n\tvar tests []testCase\n\tfor _, f := range []bool{true, false} {\n\t\tfor _, l := range []bool{true, false} {\n\t\t\ttests = append(tests, testCase{f, l})\n\t\t}\n\t}\n\n\trunSubTest := func(t *testing.T, test testCase) {\n\t\tdb, err := MakeTestDB(t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to init db: %v\", err)\n\t\t}\n\n\t\tpControl := NewPaymentControl(db)\n\n\t\tinfo, attempt, preimg, err := genInfo()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to generate htlc message: %v\", err)\n\t\t}\n\n\t\t// Init the payment, moving it to the StatusInFlight state.\n\t\terr = pControl.InitPayment(info.PaymentIdentifier, info)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to send htlc message: %v\", err)\n\t\t}\n\n\t\tassertPaymentIndex(t, pControl, info.PaymentIdentifier)\n\t\tassertPaymentStatus(t, pControl, info.PaymentIdentifier, StatusInFlight)\n\t\tassertPaymentInfo(\n\t\t\tt, pControl, info.PaymentIdentifier, info, nil, nil,\n\t\t)\n\n\t\t// Create three unique attempts we'll use for the test, and\n\t\t// register them with the payment control. We set each\n\t\t// attempts's value to one third of the payment amount, and\n\t\t// populate the MPP options.\n\t\tshardAmt := info.Value / 3\n\t\tattempt.Route.FinalHop().AmtToForward = shardAmt\n\t\tattempt.Route.FinalHop().MPP = record.NewMPP(\n\t\t\tinfo.Value, [32]byte{1},\n\t\t)\n\n\t\tvar attempts []*HTLCAttemptInfo\n\t\tfor i := uint64(0); i < 3; i++ {\n\t\t\ta := *attempt\n\t\t\ta.AttemptID = i\n\t\t\tattempts = append(attempts, &a)\n\n\t\t\t_, err = pControl.RegisterAttempt(info.PaymentIdentifier, &a)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to send htlc message: %v\", err)\n\t\t\t}\n\t\t\tassertPaymentStatus(\n\t\t\t\tt, pControl, info.PaymentIdentifier, StatusInFlight,\n\t\t\t)\n\n\t\t\thtlc := &htlcStatus{\n\t\t\t\tHTLCAttemptInfo: &a,\n\t\t\t}\n\t\t\tassertPaymentInfo(\n\t\t\t\tt, pControl, info.PaymentIdentifier, info, nil, htlc,\n\t\t\t)\n\t\t}\n\n\t\t// For a fourth attempt, check that attempting to\n\t\t// register it will fail since the total sent amount\n\t\t// will be too large.\n\t\tb := *attempt\n\t\tb.AttemptID = 3\n\t\t_, err = pControl.RegisterAttempt(info.PaymentIdentifier, &b)\n\t\tif err != ErrValueExceedsAmt {\n\t\t\tt.Fatalf(\"expected ErrValueExceedsAmt, got: %v\",\n\t\t\t\terr)\n\t\t}\n\n\t\t// Fail the second attempt.\n\t\ta := attempts[1]\n\t\thtlcFail := HTLCFailUnreadable\n\t\t_, err = pControl.FailAttempt(\n\t\t\tinfo.PaymentIdentifier, a.AttemptID,\n\t\t\t&HTLCFailInfo{\n\t\t\t\tReason: htlcFail,\n\t\t\t},\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\thtlc := &htlcStatus{\n\t\t\tHTLCAttemptInfo: a,\n\t\t\tfailure:         &htlcFail,\n\t\t}\n\t\tassertPaymentInfo(\n\t\t\tt, pControl, info.PaymentIdentifier, info, nil, htlc,\n\t\t)\n\n\t\t// Payment should still be in-flight.\n\t\tassertPaymentStatus(t, pControl, info.PaymentIdentifier, StatusInFlight)\n\n\t\t// Depending on the test case, settle or fail the first attempt.\n\t\ta = attempts[0]\n\t\thtlc = &htlcStatus{\n\t\t\tHTLCAttemptInfo: a,\n\t\t}\n\n\t\tvar firstFailReason *FailureReason\n\t\tif test.settleFirst {\n\t\t\t_, err := pControl.SettleAttempt(\n\t\t\t\tinfo.PaymentIdentifier, a.AttemptID,\n\t\t\t\t&HTLCSettleInfo{\n\t\t\t\t\tPreimage: preimg,\n\t\t\t\t},\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"error shouldn't have been \"+\n\t\t\t\t\t\"received, got: %v\", err)\n\t\t\t}\n\n\t\t\t// Assert that the HTLC has had the preimage recorded.\n\t\t\thtlc.settle = &preimg\n\t\t\tassertPaymentInfo(\n\t\t\t\tt, pControl, info.PaymentIdentifier, info, nil, htlc,\n\t\t\t)\n\t\t} else {\n\t\t\t_, err := pControl.FailAttempt(\n\t\t\t\tinfo.PaymentIdentifier, a.AttemptID,\n\t\t\t\t&HTLCFailInfo{\n\t\t\t\t\tReason: htlcFail,\n\t\t\t\t},\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"error shouldn't have been \"+\n\t\t\t\t\t\"received, got: %v\", err)\n\t\t\t}\n\n\t\t\t// Assert the failure was recorded.\n\t\t\thtlc.failure = &htlcFail\n\t\t\tassertPaymentInfo(\n\t\t\t\tt, pControl, info.PaymentIdentifier, info, nil, htlc,\n\t\t\t)\n\n\t\t\t// We also record a payment level fail, to move it into\n\t\t\t// a terminal state.\n\t\t\tfailReason := FailureReasonNoRoute\n\t\t\t_, err = pControl.Fail(info.PaymentIdentifier, failReason)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to fail payment hash: %v\", err)\n\t\t\t}\n\n\t\t\t// Record the reason we failed the payment, such that\n\t\t\t// we can assert this later in the test.\n\t\t\tfirstFailReason = &failReason\n\t\t}\n\n\t\t// The payment should still be considered in-flight, since there\n\t\t// is still an active HTLC.\n\t\tassertPaymentStatus(t, pControl, info.PaymentIdentifier, StatusInFlight)\n\n\t\t// Try to register yet another attempt. This should fail now\n\t\t// that the payment has reached a terminal condition.\n\t\tb = *attempt\n\t\tb.AttemptID = 3\n\t\t_, err = pControl.RegisterAttempt(info.PaymentIdentifier, &b)\n\t\tif err != ErrPaymentTerminal {\n\t\t\tt.Fatalf(\"expected ErrPaymentTerminal, got: %v\", err)\n\t\t}\n\n\t\tassertPaymentStatus(t, pControl, info.PaymentIdentifier, StatusInFlight)\n\n\t\t// Settle or fail the remaining attempt based on the testcase.\n\t\ta = attempts[2]\n\t\thtlc = &htlcStatus{\n\t\t\tHTLCAttemptInfo: a,\n\t\t}\n\t\tif test.settleLast {\n\t\t\t// Settle the last outstanding attempt.\n\t\t\t_, err = pControl.SettleAttempt(\n\t\t\t\tinfo.PaymentIdentifier, a.AttemptID,\n\t\t\t\t&HTLCSettleInfo{\n\t\t\t\t\tPreimage: preimg,\n\t\t\t\t},\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"error shouldn't have been \"+\n\t\t\t\t\t\"received, got: %v\", err)\n\t\t\t}\n\n\t\t\thtlc.settle = &preimg\n\t\t\tassertPaymentInfo(\n\t\t\t\tt, pControl, info.PaymentIdentifier, info,\n\t\t\t\tfirstFailReason, htlc,\n\t\t\t)\n\t\t} else {\n\t\t\t// Fail the attempt.\n\t\t\t_, err := pControl.FailAttempt(\n\t\t\t\tinfo.PaymentIdentifier, a.AttemptID,\n\t\t\t\t&HTLCFailInfo{\n\t\t\t\t\tReason: htlcFail,\n\t\t\t\t},\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"error shouldn't have been \"+\n\t\t\t\t\t\"received, got: %v\", err)\n\t\t\t}\n\n\t\t\t// Assert the failure was recorded.\n\t\t\thtlc.failure = &htlcFail\n\t\t\tassertPaymentInfo(\n\t\t\t\tt, pControl, info.PaymentIdentifier, info,\n\t\t\t\tfirstFailReason, htlc,\n\t\t\t)\n\n\t\t\t// Check that we can override any perevious terminal\n\t\t\t// failure. This is to allow multiple concurrent shard\n\t\t\t// write a terminal failure to the database without\n\t\t\t// syncing.\n\t\t\tfailReason := FailureReasonPaymentDetails\n\t\t\t_, err = pControl.Fail(info.PaymentIdentifier, failReason)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to fail payment hash: %v\", err)\n\t\t\t}\n\t\t}\n\n\t\t// If any of the two attempts settled, the payment should end\n\t\t// up in the Succeeded state. If both failed the payment should\n\t\t// also be Failed at this poinnt.\n\t\tfinalStatus := StatusFailed\n\t\tif test.settleFirst || test.settleLast {\n\t\t\tfinalStatus = StatusSucceeded\n\t\t}\n\n\t\tassertPaymentStatus(t, pControl, info.PaymentIdentifier, finalStatus)\n\n\t\t// Finally assert we cannot register more attempts.\n\t\t_, err = pControl.RegisterAttempt(info.PaymentIdentifier, &b)\n\t\trequire.Equal(t, ErrPaymentTerminal, err)\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tsubTest := fmt.Sprintf(\"first=%v, second=%v\",\n\t\t\ttest.settleFirst, test.settleLast)\n\n\t\tt.Run(subTest, func(t *testing.T) {\n\t\t\trunSubTest(t, test)\n\t\t})\n\t}\n}\n",
      "length": 6678,
      "tokens": 876,
      "embedding": []
    },
    {
      "slug": "func TestPaymentControlMPPRecordValidation(t *testing.T) {",
      "content": "func TestPaymentControlMPPRecordValidation(t *testing.T) {\n\tt.Parallel()\n\n\tdb, err := MakeTestDB(t)\n\trequire.NoError(t, err, \"unable to init db\")\n\n\tpControl := NewPaymentControl(db)\n\n\tinfo, attempt, _, err := genInfo()\n\trequire.NoError(t, err, \"unable to generate htlc message\")\n\n\t// Init the payment.\n\terr = pControl.InitPayment(info.PaymentIdentifier, info)\n\trequire.NoError(t, err, \"unable to send htlc message\")\n\n\t// Create three unique attempts we'll use for the test, and\n\t// register them with the payment control. We set each\n\t// attempts's value to one third of the payment amount, and\n\t// populate the MPP options.\n\tshardAmt := info.Value / 3\n\tattempt.Route.FinalHop().AmtToForward = shardAmt\n\tattempt.Route.FinalHop().MPP = record.NewMPP(\n\t\tinfo.Value, [32]byte{1},\n\t)\n\n\t_, err = pControl.RegisterAttempt(info.PaymentIdentifier, attempt)\n\trequire.NoError(t, err, \"unable to send htlc message\")\n\n\t// Now try to register a non-MPP attempt, which should fail.\n\tb := *attempt\n\tb.AttemptID = 1\n\tb.Route.FinalHop().MPP = nil\n\t_, err = pControl.RegisterAttempt(info.PaymentIdentifier, &b)\n\tif err != ErrMPPayment {\n\t\tt.Fatalf(\"expected ErrMPPayment, got: %v\", err)\n\t}\n\n\t// Try to register attempt one with a different payment address.\n\tb.Route.FinalHop().MPP = record.NewMPP(\n\t\tinfo.Value, [32]byte{2},\n\t)\n\t_, err = pControl.RegisterAttempt(info.PaymentIdentifier, &b)\n\tif err != ErrMPPPaymentAddrMismatch {\n\t\tt.Fatalf(\"expected ErrMPPPaymentAddrMismatch, got: %v\", err)\n\t}\n\n\t// Try registering one with a different total amount.\n\tb.Route.FinalHop().MPP = record.NewMPP(\n\t\tinfo.Value/2, [32]byte{1},\n\t)\n\t_, err = pControl.RegisterAttempt(info.PaymentIdentifier, &b)\n\tif err != ErrMPPTotalAmountMismatch {\n\t\tt.Fatalf(\"expected ErrMPPTotalAmountMismatch, got: %v\", err)\n\t}\n\n\t// Create and init a new payment. This time we'll check that we cannot\n\t// register an MPP attempt if we already registered a non-MPP one.\n\tinfo, attempt, _, err = genInfo()\n\trequire.NoError(t, err, \"unable to generate htlc message\")\n\n\terr = pControl.InitPayment(info.PaymentIdentifier, info)\n\trequire.NoError(t, err, \"unable to send htlc message\")\n\n\tattempt.Route.FinalHop().MPP = nil\n\t_, err = pControl.RegisterAttempt(info.PaymentIdentifier, attempt)\n\trequire.NoError(t, err, \"unable to send htlc message\")\n\n\t// Attempt to register an MPP attempt, which should fail.\n\tb = *attempt\n\tb.AttemptID = 1\n\tb.Route.FinalHop().MPP = record.NewMPP(\n\t\tinfo.Value, [32]byte{1},\n\t)\n\n\t_, err = pControl.RegisterAttempt(info.PaymentIdentifier, &b)\n\tif err != ErrNonMPPayment {\n\t\tt.Fatalf(\"expected ErrNonMPPayment, got: %v\", err)\n\t}\n}\n\n// TestDeleteFailedAttempts checks that DeleteFailedAttempts properly removes\n// failed HTLCs from finished payments.",
      "length": 2579,
      "tokens": 322,
      "embedding": []
    },
    {
      "slug": "func TestDeleteFailedAttempts(t *testing.T) {",
      "content": "func TestDeleteFailedAttempts(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"keep failed payment attempts\", func(t *testing.T) {\n\t\ttestDeleteFailedAttempts(t, true)\n\t})\n\tt.Run(\"remove failed payment attempts\", func(t *testing.T) {\n\t\ttestDeleteFailedAttempts(t, false)\n\t})\n}\n",
      "length": 211,
      "tokens": 22,
      "embedding": []
    },
    {
      "slug": "func testDeleteFailedAttempts(t *testing.T, keepFailedPaymentAttempts bool) {",
      "content": "func testDeleteFailedAttempts(t *testing.T, keepFailedPaymentAttempts bool) {\n\tdb, err := MakeTestDB(t)\n\n\trequire.NoError(t, err, \"unable to init db\")\n\tdb.keepFailedPaymentAttempts = keepFailedPaymentAttempts\n\n\tpControl := NewPaymentControl(db)\n\n\t// Register three payments:\n\t// All payments will have one failed HTLC attempt and one HTLC attempt\n\t// according to its final status.\n\t// 1. A payment with two failed attempts.\n\t// 2. A payment with one failed and one in-flight attempt.\n\t// 3. A payment with one failed and one settled attempt.\n\n\t// Initiate payments, which is a slice of payment that is used as\n\t// template to create the corresponding test payments in the database.\n\t//\n\t// Note: The payment id and number of htlc attempts of each payment will\n\t// be added to this slice when creating the payments below.\n\t// This allows the slice to be used directly for testing purposes.\n\tpayments := []*payment{\n\t\t{status: StatusFailed},\n\t\t{status: StatusInFlight},\n\t\t{status: StatusSucceeded},\n\t}\n\n\t// Use helper function to register the test payments in the data and\n\t// populate the data to the payments slice.\n\tcreateTestPayments(t, pControl, payments)\n\n\t// Check that all payments are there as we added them.\n\tassertPayments(t, db, payments)\n\n\t// Calling DeleteFailedAttempts on a failed payment should delete all\n\t// HTLCs.\n\trequire.NoError(t, pControl.DeleteFailedAttempts(payments[0].id))\n\n\t// Expect all HTLCs to be deleted if the config is set to delete them.\n\tif !keepFailedPaymentAttempts {\n\t\tpayments[0].htlcs = 0\n\t}\n\tassertPayments(t, db, payments)\n\n\t// Calling DeleteFailedAttempts on an in-flight payment should return\n\t// an error.\n\tif keepFailedPaymentAttempts {\n\t\trequire.NoError(t, pControl.DeleteFailedAttempts(payments[1].id))\n\t} else {\n\t\trequire.Error(t, pControl.DeleteFailedAttempts(payments[1].id))\n\t}\n\n\t// Since DeleteFailedAttempts returned an error, we should expect the\n\t// payment to be unchanged.\n\tassertPayments(t, db, payments)\n\n\t// Cleaning up a successful payment should remove failed htlcs.\n\trequire.NoError(t, pControl.DeleteFailedAttempts(payments[2].id))\n\t// Expect all HTLCs except for the settled one to be deleted if the\n\t// config is set to delete them.\n\tif !keepFailedPaymentAttempts {\n\t\tpayments[2].htlcs = 1\n\t}\n\tassertPayments(t, db, payments)\n\n\tif keepFailedPaymentAttempts {\n\t\t// DeleteFailedAttempts is ignored, even for non-existent\n\t\t// payments, if the control tower is configured to keep failed\n\t\t// HTLCs.\n\t\trequire.NoError(t, pControl.DeleteFailedAttempts(lntypes.ZeroHash))\n\t} else {\n\t\t// Attempting to cleanup a non-existent payment returns an error.\n\t\trequire.Error(t, pControl.DeleteFailedAttempts(lntypes.ZeroHash))\n\t}\n}\n\n// assertPaymentStatus retrieves the status of the payment referred to by hash\n// and compares it with the expected state.",
      "length": 2654,
      "tokens": 364,
      "embedding": []
    },
    {
      "slug": "func assertPaymentStatus(t *testing.T, p *PaymentControl,",
      "content": "func assertPaymentStatus(t *testing.T, p *PaymentControl,\n\thash lntypes.Hash, expStatus PaymentStatus) {\n\n\tt.Helper()\n\n\tpayment, err := p.FetchPayment(hash)\n\tif expStatus == StatusUnknown && err == ErrPaymentNotInitiated {\n\t\treturn\n\t}\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif payment.Status != expStatus {\n\t\tt.Fatalf(\"payment status mismatch: expected %v, got %v\",\n\t\t\texpStatus, payment.Status)\n\t}\n}\n",
      "length": 324,
      "tokens": 44,
      "embedding": []
    },
    {
      "slug": "type htlcStatus struct {",
      "content": "type htlcStatus struct {\n\t*HTLCAttemptInfo\n\tsettle  *lntypes.Preimage\n\tfailure *HTLCFailReason\n}\n\n// assertPaymentInfo retrieves the payment referred to by hash and verifies the\n// expected values.",
      "length": 166,
      "tokens": 21,
      "embedding": []
    },
    {
      "slug": "func assertPaymentInfo(t *testing.T, p *PaymentControl, hash lntypes.Hash,",
      "content": "func assertPaymentInfo(t *testing.T, p *PaymentControl, hash lntypes.Hash,\n\tc *PaymentCreationInfo, f *FailureReason, a *htlcStatus) {\n\n\tt.Helper()\n\n\tpayment, err := p.FetchPayment(hash)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !reflect.DeepEqual(payment.Info, c) {\n\t\tt.Fatalf(\"PaymentCreationInfos don't match: %v vs %v\",\n\t\t\tspew.Sdump(payment.Info), spew.Sdump(c))\n\t}\n\n\tif f != nil {\n\t\tif *payment.FailureReason != *f {\n\t\t\tt.Fatal(\"unexpected failure reason\")\n\t\t}\n\t} else {\n\t\tif payment.FailureReason != nil {\n\t\t\tt.Fatal(\"unexpected failure reason\")\n\t\t}\n\t}\n\n\tif a == nil {\n\t\tif len(payment.HTLCs) > 0 {\n\t\t\tt.Fatal(\"expected no htlcs\")\n\t\t}\n\t\treturn\n\t}\n\n\thtlc := payment.HTLCs[a.AttemptID]\n\tif err := assertRouteEqual(&htlc.Route, &a.Route); err != nil {\n\t\tt.Fatal(\"routes do not match\")\n\t}\n\n\tif htlc.AttemptID != a.AttemptID {\n\t\tt.Fatalf(\"unnexpected attempt ID %v, expected %v\",\n\t\t\thtlc.AttemptID, a.AttemptID)\n\t}\n\n\tif a.failure != nil {\n\t\tif htlc.Failure == nil {\n\t\t\tt.Fatalf(\"expected HTLC to be failed\")\n\t\t}\n\n\t\tif htlc.Failure.Reason != *a.failure {\n\t\t\tt.Fatalf(\"expected HTLC failure %v, had %v\",\n\t\t\t\t*a.failure, htlc.Failure.Reason)\n\t\t}\n\t} else if htlc.Failure != nil {\n\t\tt.Fatalf(\"expected no HTLC failure\")\n\t}\n\n\tif a.settle != nil {\n\t\tif htlc.Settle.Preimage != *a.settle {\n\t\t\tt.Fatalf(\"Preimages don't match: %x vs %x\",\n\t\t\t\thtlc.Settle.Preimage, a.settle)\n\t\t}\n\t} else if htlc.Settle != nil {\n\t\tt.Fatal(\"expected no settle info\")\n\t}\n}\n\n// fetchPaymentIndexEntry gets the payment hash for the sequence number provided\n// from our payment indexes bucket.",
      "length": 1420,
      "tokens": 197,
      "embedding": []
    },
    {
      "slug": "func fetchPaymentIndexEntry(_ *testing.T, p *PaymentControl,",
      "content": "func fetchPaymentIndexEntry(_ *testing.T, p *PaymentControl,\n\tsequenceNumber uint64) (*lntypes.Hash, error) {\n\n\tvar hash lntypes.Hash\n\n\tif err := kvdb.View(p.db, func(tx walletdb.ReadTx) error {\n\t\tindexBucket := tx.ReadBucket(paymentsIndexBucket)\n\t\tkey := make([]byte, 8)\n\t\tbyteOrder.PutUint64(key, sequenceNumber)\n\n\t\tindexValue := indexBucket.Get(key)\n\t\tif indexValue == nil {\n\t\t\treturn errNoSequenceNrIndex\n\t\t}\n\n\t\tr := bytes.NewReader(indexValue)\n\n\t\tvar err error\n\t\thash, err = deserializePaymentIndex(r)\n\t\treturn err\n\t}, func() {\n\t\thash = lntypes.Hash{}\n\t}); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &hash, nil\n}\n\n// assertPaymentIndex looks up the index for a payment in the db and checks\n// that its payment hash matches the expected hash passed in.",
      "length": 666,
      "tokens": 92,
      "embedding": []
    },
    {
      "slug": "func assertPaymentIndex(t *testing.T, p *PaymentControl,",
      "content": "func assertPaymentIndex(t *testing.T, p *PaymentControl,\n\texpectedHash lntypes.Hash) {\n\n\t// Lookup the payment so that we have its sequence number and check\n\t// that is has correctly been indexed in the payment indexes bucket.\n\tpmt, err := p.FetchPayment(expectedHash)\n\trequire.NoError(t, err)\n\n\thash, err := fetchPaymentIndexEntry(t, p, pmt.SequenceNum)\n\trequire.NoError(t, err)\n\tassert.Equal(t, expectedHash, *hash)\n}\n\n// assertNoIndex checks that an index for the sequence number provided does not\n// exist.",
      "length": 440,
      "tokens": 61,
      "embedding": []
    },
    {
      "slug": "func assertNoIndex(t *testing.T, p *PaymentControl, seqNr uint64) {",
      "content": "func assertNoIndex(t *testing.T, p *PaymentControl, seqNr uint64) {\n\t_, err := fetchPaymentIndexEntry(t, p, seqNr)\n\trequire.Equal(t, errNoSequenceNrIndex, err)\n}\n\n// payment is a helper structure that holds basic information on a test payment,\n// such as the payment id, the status and the total number of HTLCs attempted.",
      "length": 249,
      "tokens": 39,
      "embedding": []
    },
    {
      "slug": "type payment struct {",
      "content": "type payment struct {\n\tid     lntypes.Hash\n\tstatus PaymentStatus\n\thtlcs  int\n}\n\n// createTestPayments registers payments depending on the provided statuses in\n// the payments slice. Each payment will receive one failed HTLC and another\n// HTLC depending on the final status of the payment provided.",
      "length": 269,
      "tokens": 41,
      "embedding": []
    },
    {
      "slug": "func createTestPayments(t *testing.T, p *PaymentControl, payments []*payment) {",
      "content": "func createTestPayments(t *testing.T, p *PaymentControl, payments []*payment) {\n\tattemptID := uint64(0)\n\n\tfor i := 0; i < len(payments); i++ {\n\t\tinfo, attempt, preimg, err := genInfo()\n\t\trequire.NoError(t, err, \"unable to generate htlc message\")\n\n\t\t// Set the payment id accordingly in the payments slice.\n\t\tpayments[i].id = info.PaymentIdentifier\n\n\t\tattempt.AttemptID = attemptID\n\t\tattemptID++\n\n\t\t// Init the payment.\n\t\terr = p.InitPayment(info.PaymentIdentifier, info)\n\t\trequire.NoError(t, err, \"unable to send htlc message\")\n\n\t\t// Register and fail the first attempt for all payments.\n\t\t_, err = p.RegisterAttempt(info.PaymentIdentifier, attempt)\n\t\trequire.NoError(t, err, \"unable to send htlc message\")\n\n\t\thtlcFailure := HTLCFailUnreadable\n\t\t_, err = p.FailAttempt(\n\t\t\tinfo.PaymentIdentifier, attempt.AttemptID,\n\t\t\t&HTLCFailInfo{\n\t\t\t\tReason: htlcFailure,\n\t\t\t},\n\t\t)\n\t\trequire.NoError(t, err, \"unable to fail htlc\")\n\n\t\t// Increase the HTLC counter in the payments slice for the\n\t\t// failed attempt.\n\t\tpayments[i].htlcs++\n\n\t\t// Depending on the test case, fail or succeed the next\n\t\t// attempt.\n\t\tattempt.AttemptID = attemptID\n\t\tattemptID++\n\n\t\t_, err = p.RegisterAttempt(info.PaymentIdentifier, attempt)\n\t\trequire.NoError(t, err, \"unable to send htlc message\")\n\n\t\tswitch payments[i].status {\n\t\t// Fail the attempt and the payment overall.\n\t\tcase StatusFailed:\n\t\t\thtlcFailure := HTLCFailUnreadable\n\t\t\t_, err = p.FailAttempt(\n\t\t\t\tinfo.PaymentIdentifier, attempt.AttemptID,\n\t\t\t\t&HTLCFailInfo{\n\t\t\t\t\tReason: htlcFailure,\n\t\t\t\t},\n\t\t\t)\n\t\t\trequire.NoError(t, err, \"unable to fail htlc\")\n\n\t\t\tfailReason := FailureReasonNoRoute\n\t\t\t_, err = p.Fail(info.PaymentIdentifier,\n\t\t\t\tfailReason)\n\t\t\trequire.NoError(t, err, \"unable to fail payment hash\")\n\n\t\t// Settle the attempt\n\t\tcase StatusSucceeded:\n\t\t\t_, err := p.SettleAttempt(\n\t\t\t\tinfo.PaymentIdentifier, attempt.AttemptID,\n\t\t\t\t&HTLCSettleInfo{\n\t\t\t\t\tPreimage: preimg,\n\t\t\t\t},\n\t\t\t)\n\t\t\trequire.NoError(t, err, \"no error should have been \"+\n\t\t\t\t\"received from settling a htlc attempt\")\n\n\t\t// We leave the attempt in-flight by doing nothing.\n\t\tcase StatusInFlight:\n\t\t}\n\n\t\t// Increase the HTLC counter in the payments slice for any\n\t\t// attempt above.\n\t\tpayments[i].htlcs++\n\t}\n}\n\n// assertPayments is a helper function that given a slice of payment and\n// indices for the slice asserts that exactly the same payments in the\n// slice for the provided indices exist when fetching payments from the\n// database.",
      "length": 2277,
      "tokens": 291,
      "embedding": []
    },
    {
      "slug": "func assertPayments(t *testing.T, db *DB, payments []*payment) {",
      "content": "func assertPayments(t *testing.T, db *DB, payments []*payment) {\n\tt.Helper()\n\n\tdbPayments, err := db.FetchPayments()\n\trequire.NoError(t, err, \"could not fetch payments from db\")\n\n\t// Make sure that the number of fetched payments is the same\n\t// as expected.\n\trequire.Len(t, dbPayments, len(payments), \"unexpected number of payments\")\n\n\t// Convert fetched payments of type MPPayment to our helper structure.\n\tp := make([]*payment, len(dbPayments))\n\tfor i, dbPayment := range dbPayments {\n\t\tp[i] = &payment{\n\t\t\tid:     dbPayment.Info.PaymentIdentifier,\n\t\t\tstatus: dbPayment.Status,\n\t\t\thtlcs:  len(dbPayment.HTLCs),\n\t\t}\n\t}\n\n\t// Check that each payment we want to assert exists in the database.\n\trequire.Equal(t, payments, p)\n}\n",
      "length": 637,
      "tokens": 85,
      "embedding": []
    }
  ]
}