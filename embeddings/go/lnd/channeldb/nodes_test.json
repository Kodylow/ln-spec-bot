{
  "filepath": "../implementations/go/lnd/channeldb/nodes_test.go",
  "package": "channeldb",
  "sections": [
    {
      "slug": "func TestLinkNodeEncodeDecode(t *testing.T) {",
      "content": "func TestLinkNodeEncodeDecode(t *testing.T) {\n\tt.Parallel()\n\n\tfullDB, err := MakeTestDB(t)\n\trequire.NoError(t, err, \"unable to make test database\")\n\n\tcdb := fullDB.ChannelStateDB()\n\n\t// First we'll create some initial data to use for populating our test\n\t// LinkNode instances.\n\t_, pub1 := btcec.PrivKeyFromBytes(key[:])\n\t_, pub2 := btcec.PrivKeyFromBytes(rev[:])\n\taddr1, err := net.ResolveTCPAddr(\"tcp\", \"10.0.0.1:9000\")\n\trequire.NoError(t, err, \"unable to create test addr\")\n\taddr2, err := net.ResolveTCPAddr(\"tcp\", \"10.0.0.2:9000\")\n\trequire.NoError(t, err, \"unable to create test addr\")\n\n\t// Create two fresh link node instances with the above dummy data, then\n\t// fully sync both instances to disk.\n\tnode1 := NewLinkNode(cdb.linkNodeDB, wire.MainNet, pub1, addr1)\n\tnode2 := NewLinkNode(cdb.linkNodeDB, wire.TestNet3, pub2, addr2)\n\tif err := node1.Sync(); err != nil {\n\t\tt.Fatalf(\"unable to sync node: %v\", err)\n\t}\n\tif err := node2.Sync(); err != nil {\n\t\tt.Fatalf(\"unable to sync node: %v\", err)\n\t}\n\n\t// Fetch all current link nodes from the database, they should exactly\n\t// match the two created above.\n\toriginalNodes := []*LinkNode{node2, node1}\n\tlinkNodes, err := cdb.linkNodeDB.FetchAllLinkNodes()\n\trequire.NoError(t, err, \"unable to fetch nodes\")\n\tfor i, node := range linkNodes {\n\t\tif originalNodes[i].Network != node.Network {\n\t\t\tt.Fatalf(\"node networks don't match: expected %v, got %v\",\n\t\t\t\toriginalNodes[i].Network, node.Network)\n\t\t}\n\n\t\toriginalPubkey := originalNodes[i].IdentityPub.SerializeCompressed()\n\t\tdbPubkey := node.IdentityPub.SerializeCompressed()\n\t\tif !bytes.Equal(originalPubkey, dbPubkey) {\n\t\t\tt.Fatalf(\"node pubkeys don't match: expected %x, got %x\",\n\t\t\t\toriginalPubkey, dbPubkey)\n\t\t}\n\t\tif originalNodes[i].LastSeen.Unix() != node.LastSeen.Unix() {\n\t\t\tt.Fatalf(\"last seen timestamps don't match: expected %v got %v\",\n\t\t\t\toriginalNodes[i].LastSeen.Unix(), node.LastSeen.Unix())\n\t\t}\n\t\tif originalNodes[i].Addresses[0].String() != node.Addresses[0].String() {\n\t\t\tt.Fatalf(\"addresses don't match: expected %v, got %v\",\n\t\t\t\toriginalNodes[i].Addresses, node.Addresses)\n\t\t}\n\t}\n\n\t// Next, we'll exercise the methods to append additional IP\n\t// addresses, and also to update the last seen time.\n\tif err := node1.UpdateLastSeen(time.Now()); err != nil {\n\t\tt.Fatalf(\"unable to update last seen: %v\", err)\n\t}\n\tif err := node1.AddAddress(addr2); err != nil {\n\t\tt.Fatalf(\"unable to update addr: %v\", err)\n\t}\n\n\t// Fetch the same node from the database according to its public key.\n\tnode1DB, err := cdb.linkNodeDB.FetchLinkNode(pub1)\n\trequire.NoError(t, err, \"unable to find node\")\n\n\t// Both the last seen timestamp and the list of reachable addresses for\n\t// the node should be updated.\n\tif node1DB.LastSeen.Unix() != node1.LastSeen.Unix() {\n\t\tt.Fatalf(\"last seen timestamps don't match: expected %v got %v\",\n\t\t\tnode1.LastSeen.Unix(), node1DB.LastSeen.Unix())\n\t}\n\tif len(node1DB.Addresses) != 2 {\n\t\tt.Fatalf(\"wrong length for node1 addresses: expected %v, got %v\",\n\t\t\t2, len(node1DB.Addresses))\n\t}\n\tif node1DB.Addresses[0].String() != addr1.String() {\n\t\tt.Fatalf(\"wrong address for node: expected %v, got %v\",\n\t\t\taddr1.String(), node1DB.Addresses[0].String())\n\t}\n\tif node1DB.Addresses[1].String() != addr2.String() {\n\t\tt.Fatalf(\"wrong address for node: expected %v, got %v\",\n\t\t\taddr2.String(), node1DB.Addresses[1].String())\n\t}\n}\n",
      "length": 3212,
      "tokens": 394,
      "embedding": []
    },
    {
      "slug": "func TestDeleteLinkNode(t *testing.T) {",
      "content": "func TestDeleteLinkNode(t *testing.T) {\n\tt.Parallel()\n\n\tfullDB, err := MakeTestDB(t)\n\trequire.NoError(t, err, \"unable to make test database\")\n\n\tcdb := fullDB.ChannelStateDB()\n\n\t_, pubKey := btcec.PrivKeyFromBytes(key[:])\n\taddr := &net.TCPAddr{\n\t\tIP:   net.ParseIP(\"127.0.0.1\"),\n\t\tPort: 1337,\n\t}\n\tlinkNode := NewLinkNode(cdb.linkNodeDB, wire.TestNet3, pubKey, addr)\n\tif err := linkNode.Sync(); err != nil {\n\t\tt.Fatalf(\"unable to write link node to db: %v\", err)\n\t}\n\n\tif _, err := cdb.linkNodeDB.FetchLinkNode(pubKey); err != nil {\n\t\tt.Fatalf(\"unable to find link node: %v\", err)\n\t}\n\n\tif err := cdb.linkNodeDB.DeleteLinkNode(pubKey); err != nil {\n\t\tt.Fatalf(\"unable to delete link node from db: %v\", err)\n\t}\n\n\tif _, err := cdb.linkNodeDB.FetchLinkNode(pubKey); err == nil {\n\t\tt.Fatal(\"should not have found link node in db, but did\")\n\t}\n}\n",
      "length": 768,
      "tokens": 107,
      "embedding": []
    }
  ]
}