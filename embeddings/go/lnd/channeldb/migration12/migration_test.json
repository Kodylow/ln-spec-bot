{
  "filepath": "../implementations/go/lnd/channeldb/migration12/migration_test.go",
  "package": "migration12_test",
  "sections": [
    {
      "slug": "type migrationTest struct {",
      "content": "type migrationTest struct {\n\tname            string\n\tbeforeMigration func(kvdb.RwTx) error\n\tafterMigration  func(kvdb.RwTx) error\n}\n\nvar migrationTests = []migrationTest{\n\t{\n\t\tname:            \"no invoices\",\n\t\tbeforeMigration: func(kvdb.RwTx) error { return nil },\n\t\tafterMigration:  func(kvdb.RwTx) error { return nil },\n\t},\n\t{\n\t\tname:            \"zero htlcs\",\n\t\tbeforeMigration: genBeforeMigration(beforeInvoice0Htlcs),\n\t\tafterMigration:  genAfterMigration(afterInvoice0Htlcs),\n\t},\n\t{\n\t\tname:            \"one htlc\",\n\t\tbeforeMigration: genBeforeMigration(beforeInvoice1Htlc),\n\t\tafterMigration:  genAfterMigration(afterInvoice1Htlc),\n\t},\n}\n\n// genBeforeMigration creates a closure that inserts an invoice serialized under\n// the old format under the test payment hash.",
      "length": 716,
      "tokens": 71,
      "embedding": []
    },
    {
      "slug": "func genBeforeMigration(beforeBytes []byte) func(kvdb.RwTx) error {",
      "content": "func genBeforeMigration(beforeBytes []byte) func(kvdb.RwTx) error {\n\treturn func(tx kvdb.RwTx) error {\n\t\tinvoices, err := tx.CreateTopLevelBucket(\n\t\t\tinvoiceBucket,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn invoices.Put(hash[:], beforeBytes)\n\t}\n}\n\n// genAfterMigration creates a closure that verifies the tlv invoice migration\n// succeeded, but comparing the resulting encoding of the invoice to the\n// expected serialization. In addition, the decoded invoice is compared against\n// the expected invoice for equality.",
      "length": 442,
      "tokens": 64,
      "embedding": []
    },
    {
      "slug": "func genAfterMigration(afterBytes []byte) func(kvdb.RwTx) error {",
      "content": "func genAfterMigration(afterBytes []byte) func(kvdb.RwTx) error {\n\treturn func(tx kvdb.RwTx) error {\n\t\tinvoices := tx.ReadWriteBucket(invoiceBucket)\n\t\tif invoices == nil {\n\t\t\treturn fmt.Errorf(\"invoice bucket not found\")\n\t\t}\n\n\t\t// Fetch the new invoice bytes and check that they match our\n\t\t// expected serialization.\n\t\tinvoiceBytes := invoices.Get(hash[:])\n\t\tif !bytes.Equal(invoiceBytes, afterBytes) {\n\t\t\treturn fmt.Errorf(\"invoice bytes mismatch, \"+\n\t\t\t\t\"want: %x, got: %x\",\n\t\t\t\tinvoiceBytes, afterBytes)\n\t\t}\n\n\t\treturn nil\n\t}\n}\n\n// TestTLVInvoiceMigration executes a suite of migration tests for moving\n// invoices to use TLV for their bodies. In the process, feature bits and\n// payment addresses are added to the invoice while the receipt field is\n// dropped. We test a few different invoices with a varying number of HTLCs, as\n// well as the case where there are no invoices present.\n//\n// NOTE: The test vectors each include a receipt that is not present on the\n// final struct, but verifies that the field is properly removed.",
      "length": 942,
      "tokens": 147,
      "embedding": []
    },
    {
      "slug": "func TestTLVInvoiceMigration(t *testing.T) {",
      "content": "func TestTLVInvoiceMigration(t *testing.T) {\n\tfor _, test := range migrationTests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tmigtest.ApplyMigration(\n\t\t\t\tt,\n\t\t\t\ttest.beforeMigration,\n\t\t\t\ttest.afterMigration,\n\t\t\t\tmigration12.MigrateInvoiceTLV,\n\t\t\t\tfalse,\n\t\t\t)\n\t\t})\n\t}\n}\n",
      "length": 227,
      "tokens": 24,
      "embedding": []
    }
  ]
}