{
  "filepath": "../implementations/go/lnd/channeldb/migration12/invoices.go",
  "package": "migration12",
  "sections": [
    {
      "slug": "type ContractState uint8",
      "content": "type ContractState uint8\n\n// ContractTerm is a companion struct to the Invoice struct. This struct houses\n// the necessary conditions required before the invoice can be considered fully\n// settled by the payee.",
      "length": 182,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "type ContractTerm struct {",
      "content": "type ContractTerm struct {\n\t// PaymentPreimage is the preimage which is to be revealed in the\n\t// occasion that an HTLC paying to the hash of this preimage is\n\t// extended.\n\tPaymentPreimage lntypes.Preimage\n\n\t// Value is the expected amount of milli-satoshis to be paid to an HTLC\n\t// which can be satisfied by the above preimage.\n\tValue lnwire.MilliSatoshi\n\n\t// State describes the state the invoice is in.\n\tState ContractState\n\n\t// PaymentAddr is a randomly generated value include in the MPP record\n\t// by the sender to prevent probing of the receiver.\n\tPaymentAddr [32]byte\n\n\t// Features is the feature vectors advertised on the payment request.\n\tFeatures *lnwire.FeatureVector\n}\n\n// Invoice is a payment invoice generated by a payee in order to request\n// payment for some good or service. The inclusion of invoices within Lightning\n// creates a payment work flow for merchants very similar to that of the\n// existing financial system within PayPal, etc.  Invoices are added to the\n// database when a payment is requested, then can be settled manually once the\n// payment is received at the upper layer. For record keeping purposes,\n// invoices are never deleted from the database, instead a bit is toggled\n// denoting the invoice has been fully settled. Within the database, all\n// invoices must have a unique payment hash which is generated by taking the\n// sha256 of the payment preimage.",
      "length": 1340,
      "tokens": 227,
      "embedding": []
    },
    {
      "slug": "type Invoice struct {",
      "content": "type Invoice struct {\n\t// Memo is an optional memo to be stored along side an invoice.  The\n\t// memo may contain further details pertaining to the invoice itself,\n\t// or any other message which fits within the size constraints.\n\tMemo []byte\n\n\t// PaymentRequest is an optional field where a payment request created\n\t// for this invoice can be stored.\n\tPaymentRequest []byte\n\n\t// FinalCltvDelta is the minimum required number of blocks before htlc\n\t// expiry when the invoice is accepted.\n\tFinalCltvDelta int32\n\n\t// Expiry defines how long after creation this invoice should expire.\n\tExpiry time.Duration\n\n\t// CreationDate is the exact time the invoice was created.\n\tCreationDate time.Time\n\n\t// SettleDate is the exact time the invoice was settled.\n\tSettleDate time.Time\n\n\t// Terms are the contractual payment terms of the invoice. Once all the\n\t// terms have been satisfied by the payer, then the invoice can be\n\t// considered fully fulfilled.\n\t//\n\t// TODO(roasbeef): later allow for multiple terms to fulfill the final\n\t// invoice: payment fragmentation, etc.\n\tTerms ContractTerm\n\n\t// AddIndex is an auto-incrementing integer that acts as a\n\t// monotonically increasing sequence number for all invoices created.\n\t// Clients can then use this field as a \"checkpoint\" of sorts when\n\t// implementing a streaming RPC to notify consumers of instances where\n\t// an invoice has been added before they re-connected.\n\t//\n\t// NOTE: This index starts at 1.\n\tAddIndex uint64\n\n\t// SettleIndex is an auto-incrementing integer that acts as a\n\t// monotonically increasing sequence number for all settled invoices.\n\t// Clients can then use this field as a \"checkpoint\" of sorts when\n\t// implementing a streaming RPC to notify consumers of instances where\n\t// an invoice has been settled before they re-connected.\n\t//\n\t// NOTE: This index starts at 1.\n\tSettleIndex uint64\n\n\t// AmtPaid is the final amount that we ultimately accepted for pay for\n\t// this invoice. We specify this value independently as it's possible\n\t// that the invoice originally didn't specify an amount, or the sender\n\t// overpaid.\n\tAmtPaid lnwire.MilliSatoshi\n\n\t// Htlcs records all htlcs that paid to this invoice. Some of these\n\t// htlcs may have been marked as canceled.\n\tHtlcs []byte\n}\n\n// LegacyDeserializeInvoice decodes an invoice from the passed io.Reader using\n// the pre-TLV serialization.",
      "length": 2270,
      "tokens": 366,
      "embedding": []
    },
    {
      "slug": "func LegacyDeserializeInvoice(r io.Reader) (Invoice, error) {",
      "content": "func LegacyDeserializeInvoice(r io.Reader) (Invoice, error) {\n\tvar err error\n\tinvoice := Invoice{}\n\n\t// TODO(roasbeef): use read full everywhere\n\tinvoice.Memo, err = wire.ReadVarBytes(r, 0, MaxMemoSize, \"\")\n\tif err != nil {\n\t\treturn invoice, err\n\t}\n\t_, err = wire.ReadVarBytes(r, 0, maxReceiptSize, \"\")\n\tif err != nil {\n\t\treturn invoice, err\n\t}\n\n\tinvoice.PaymentRequest, err = wire.ReadVarBytes(r, 0, MaxPaymentRequestSize, \"\")\n\tif err != nil {\n\t\treturn invoice, err\n\t}\n\n\tif err := binary.Read(r, byteOrder, &invoice.FinalCltvDelta); err != nil {\n\t\treturn invoice, err\n\t}\n\n\tvar expiry int64\n\tif err := binary.Read(r, byteOrder, &expiry); err != nil {\n\t\treturn invoice, err\n\t}\n\tinvoice.Expiry = time.Duration(expiry)\n\n\tbirthBytes, err := wire.ReadVarBytes(r, 0, 300, \"birth\")\n\tif err != nil {\n\t\treturn invoice, err\n\t}\n\tif err := invoice.CreationDate.UnmarshalBinary(birthBytes); err != nil {\n\t\treturn invoice, err\n\t}\n\n\tsettledBytes, err := wire.ReadVarBytes(r, 0, 300, \"settled\")\n\tif err != nil {\n\t\treturn invoice, err\n\t}\n\tif err := invoice.SettleDate.UnmarshalBinary(settledBytes); err != nil {\n\t\treturn invoice, err\n\t}\n\n\tif _, err := io.ReadFull(r, invoice.Terms.PaymentPreimage[:]); err != nil {\n\t\treturn invoice, err\n\t}\n\tvar scratch [8]byte\n\tif _, err := io.ReadFull(r, scratch[:]); err != nil {\n\t\treturn invoice, err\n\t}\n\tinvoice.Terms.Value = lnwire.MilliSatoshi(byteOrder.Uint64(scratch[:]))\n\n\tif err := binary.Read(r, byteOrder, &invoice.Terms.State); err != nil {\n\t\treturn invoice, err\n\t}\n\n\tif err := binary.Read(r, byteOrder, &invoice.AddIndex); err != nil {\n\t\treturn invoice, err\n\t}\n\tif err := binary.Read(r, byteOrder, &invoice.SettleIndex); err != nil {\n\t\treturn invoice, err\n\t}\n\tif err := binary.Read(r, byteOrder, &invoice.AmtPaid); err != nil {\n\t\treturn invoice, err\n\t}\n\n\tinvoice.Htlcs, err = deserializeHtlcs(r)\n\tif err != nil {\n\t\treturn Invoice{}, err\n\t}\n\n\treturn invoice, nil\n}\n\n// deserializeHtlcs reads a list of invoice htlcs from a reader and returns it\n// as a flattened byte slice.",
      "length": 1866,
      "tokens": 277,
      "embedding": []
    },
    {
      "slug": "func deserializeHtlcs(r io.Reader) ([]byte, error) {",
      "content": "func deserializeHtlcs(r io.Reader) ([]byte, error) {\n\tvar b bytes.Buffer\n\t_, err := io.Copy(&b, r)\n\treturn b.Bytes(), err\n}\n\n// SerializeInvoice serializes an invoice to a writer.\n//\n// nolint: dupl",
      "length": 138,
      "tokens": 24,
      "embedding": []
    },
    {
      "slug": "func SerializeInvoice(w io.Writer, i *Invoice) error {",
      "content": "func SerializeInvoice(w io.Writer, i *Invoice) error {\n\tcreationDateBytes, err := i.CreationDate.MarshalBinary()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsettleDateBytes, err := i.SettleDate.MarshalBinary()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar fb bytes.Buffer\n\terr = i.Terms.Features.EncodeBase256(&fb)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfeatureBytes := fb.Bytes()\n\n\tpreimage := [32]byte(i.Terms.PaymentPreimage)\n\tvalue := uint64(i.Terms.Value)\n\tcltvDelta := uint32(i.FinalCltvDelta)\n\texpiry := uint64(i.Expiry)\n\n\tamtPaid := uint64(i.AmtPaid)\n\tstate := uint8(i.Terms.State)\n\n\ttlvStream, err := tlv.NewStream(\n\t\t// Memo and payreq.\n\t\ttlv.MakePrimitiveRecord(memoType, &i.Memo),\n\t\ttlv.MakePrimitiveRecord(payReqType, &i.PaymentRequest),\n\n\t\t// Add/settle metadata.\n\t\ttlv.MakePrimitiveRecord(createTimeType, &creationDateBytes),\n\t\ttlv.MakePrimitiveRecord(settleTimeType, &settleDateBytes),\n\t\ttlv.MakePrimitiveRecord(addIndexType, &i.AddIndex),\n\t\ttlv.MakePrimitiveRecord(settleIndexType, &i.SettleIndex),\n\n\t\t// Terms.\n\t\ttlv.MakePrimitiveRecord(preimageType, &preimage),\n\t\ttlv.MakePrimitiveRecord(valueType, &value),\n\t\ttlv.MakePrimitiveRecord(cltvDeltaType, &cltvDelta),\n\t\ttlv.MakePrimitiveRecord(expiryType, &expiry),\n\t\ttlv.MakePrimitiveRecord(paymentAddrType, &i.Terms.PaymentAddr),\n\t\ttlv.MakePrimitiveRecord(featuresType, &featureBytes),\n\n\t\t// Invoice state.\n\t\ttlv.MakePrimitiveRecord(invStateType, &state),\n\t\ttlv.MakePrimitiveRecord(amtPaidType, &amtPaid),\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar b bytes.Buffer\n\tif err = tlvStream.Encode(&b); err != nil {\n\t\treturn err\n\t}\n\n\terr = binary.Write(w, byteOrder, uint64(b.Len()))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif _, err = w.Write(b.Bytes()); err != nil {\n\t\treturn err\n\t}\n\n\treturn serializeHtlcs(w, i.Htlcs)\n}\n\n// serializeHtlcs writes a serialized list of invoice htlcs into a writer.",
      "length": 1705,
      "tokens": 167,
      "embedding": []
    },
    {
      "slug": "func serializeHtlcs(w io.Writer, htlcs []byte) error {",
      "content": "func serializeHtlcs(w io.Writer, htlcs []byte) error {\n\t_, err := w.Write(htlcs)\n\treturn err\n}\n",
      "length": 37,
      "tokens": 7,
      "embedding": []
    }
  ]
}