{
  "filepath": "../implementations/go/lnd/channeldb/nodes.go",
  "package": "channeldb",
  "sections": [
    {
      "slug": "type LinkNode struct {",
      "content": "type LinkNode struct {\n\t// Network indicates the Bitcoin network that the LinkNode advertises\n\t// for incoming channel creation.\n\tNetwork wire.BitcoinNet\n\n\t// IdentityPub is the node's current identity public key. Any\n\t// channel/topology related information received by this node MUST be\n\t// signed by this public key.\n\tIdentityPub *btcec.PublicKey\n\n\t// LastSeen tracks the last time this node was seen within the network.\n\t// A node should be marked as seen if the daemon either is able to\n\t// establish an outgoing connection to the node or receives a new\n\t// incoming connection from the node. This timestamp (stored in unix\n\t// epoch) may be used within a heuristic which aims to determine when a\n\t// channel should be unilaterally closed due to inactivity.\n\t//\n\t// TODO(roasbeef): replace with block hash/height?\n\t//  * possibly add a time-value metric into the heuristic?\n\tLastSeen time.Time\n\n\t// Addresses is a list of IP address in which either we were able to\n\t// reach the node over in the past, OR we received an incoming\n\t// authenticated connection for the stored identity public key.\n\tAddresses []net.Addr\n\n\t// db is the database instance this node was fetched from. This is used\n\t// to sync back the node's state if it is updated.\n\tdb *LinkNodeDB\n}\n\n// NewLinkNode creates a new LinkNode from the provided parameters, which is\n// backed by an instance of a link node DB.",
      "length": 1332,
      "tokens": 227,
      "embedding": []
    },
    {
      "slug": "func NewLinkNode(db *LinkNodeDB, bitNet wire.BitcoinNet, pub *btcec.PublicKey,",
      "content": "func NewLinkNode(db *LinkNodeDB, bitNet wire.BitcoinNet, pub *btcec.PublicKey,\n\taddrs ...net.Addr) *LinkNode {\n\n\treturn &LinkNode{\n\t\tNetwork:     bitNet,\n\t\tIdentityPub: pub,\n\t\tLastSeen:    time.Now(),\n\t\tAddresses:   addrs,\n\t\tdb:          db,\n\t}\n}\n\n// UpdateLastSeen updates the last time this node was directly encountered on\n// the Lightning Network.",
      "length": 260,
      "tokens": 34,
      "embedding": []
    },
    {
      "slug": "func (l *LinkNode) UpdateLastSeen(lastSeen time.Time) error {",
      "content": "func (l *LinkNode) UpdateLastSeen(lastSeen time.Time) error {\n\tl.LastSeen = lastSeen\n\n\treturn l.Sync()\n}\n\n// AddAddress appends the specified TCP address to the list of known addresses\n// this node is/was known to be reachable at.",
      "length": 162,
      "tokens": 28,
      "embedding": []
    },
    {
      "slug": "func (l *LinkNode) AddAddress(addr net.Addr) error {",
      "content": "func (l *LinkNode) AddAddress(addr net.Addr) error {\n\tfor _, a := range l.Addresses {\n\t\tif a.String() == addr.String() {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tl.Addresses = append(l.Addresses, addr)\n\n\treturn l.Sync()\n}\n\n// Sync performs a full database sync which writes the current up-to-date data\n// within the struct to the database.",
      "length": 256,
      "tokens": 43,
      "embedding": []
    },
    {
      "slug": "func (l *LinkNode) Sync() error {",
      "content": "func (l *LinkNode) Sync() error {\n\t// Finally update the database by storing the link node and updating\n\t// any relevant indexes.\n\treturn kvdb.Update(l.db.backend, func(tx kvdb.RwTx) error {\n\t\tnodeMetaBucket := tx.ReadWriteBucket(nodeInfoBucket)\n\t\tif nodeMetaBucket == nil {\n\t\t\treturn ErrLinkNodesNotFound\n\t\t}\n\n\t\treturn putLinkNode(nodeMetaBucket, l)\n\t}, func() {})\n}\n\n// putLinkNode serializes then writes the encoded version of the passed link\n// node into the nodeMetaBucket. This function is provided in order to allow\n// the ability to re-use a database transaction across many operations.",
      "length": 546,
      "tokens": 76,
      "embedding": []
    },
    {
      "slug": "func putLinkNode(nodeMetaBucket kvdb.RwBucket, l *LinkNode) error {",
      "content": "func putLinkNode(nodeMetaBucket kvdb.RwBucket, l *LinkNode) error {\n\t// First serialize the LinkNode into its raw-bytes encoding.\n\tvar b bytes.Buffer\n\tif err := serializeLinkNode(&b, l); err != nil {\n\t\treturn err\n\t}\n\n\t// Finally insert the link-node into the node metadata bucket keyed\n\t// according to the its pubkey serialized in compressed form.\n\tnodePub := l.IdentityPub.SerializeCompressed()\n\treturn nodeMetaBucket.Put(nodePub, b.Bytes())\n}\n\n// LinkNodeDB is a database that keeps track of all link nodes.",
      "length": 430,
      "tokens": 64,
      "embedding": []
    },
    {
      "slug": "type LinkNodeDB struct {",
      "content": "type LinkNodeDB struct {\n\tbackend kvdb.Backend\n}\n\n// DeleteLinkNode removes the link node with the given identity from the\n// database.",
      "length": 106,
      "tokens": 17,
      "embedding": []
    },
    {
      "slug": "func (l *LinkNodeDB) DeleteLinkNode(identity *btcec.PublicKey) error {",
      "content": "func (l *LinkNodeDB) DeleteLinkNode(identity *btcec.PublicKey) error {\n\treturn kvdb.Update(l.backend, func(tx kvdb.RwTx) error {\n\t\treturn deleteLinkNode(tx, identity)\n\t}, func() {})\n}\n",
      "length": 109,
      "tokens": 13,
      "embedding": []
    },
    {
      "slug": "func deleteLinkNode(tx kvdb.RwTx, identity *btcec.PublicKey) error {",
      "content": "func deleteLinkNode(tx kvdb.RwTx, identity *btcec.PublicKey) error {\n\tnodeMetaBucket := tx.ReadWriteBucket(nodeInfoBucket)\n\tif nodeMetaBucket == nil {\n\t\treturn ErrLinkNodesNotFound\n\t}\n\n\tpubKey := identity.SerializeCompressed()\n\treturn nodeMetaBucket.Delete(pubKey)\n}\n\n// FetchLinkNode attempts to lookup the data for a LinkNode based on a target\n// identity public key. If a particular LinkNode for the passed identity public\n// key cannot be found, then ErrNodeNotFound if returned.",
      "length": 403,
      "tokens": 53,
      "embedding": []
    },
    {
      "slug": "func (l *LinkNodeDB) FetchLinkNode(identity *btcec.PublicKey) (*LinkNode, error) {",
      "content": "func (l *LinkNodeDB) FetchLinkNode(identity *btcec.PublicKey) (*LinkNode, error) {\n\tvar linkNode *LinkNode\n\terr := kvdb.View(l.backend, func(tx kvdb.RTx) error {\n\t\tnode, err := fetchLinkNode(tx, identity)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tlinkNode = node\n\t\treturn nil\n\t}, func() {\n\t\tlinkNode = nil\n\t})\n\n\treturn linkNode, err\n}\n",
      "length": 234,
      "tokens": 39,
      "embedding": []
    },
    {
      "slug": "func fetchLinkNode(tx kvdb.RTx, targetPub *btcec.PublicKey) (*LinkNode, error) {",
      "content": "func fetchLinkNode(tx kvdb.RTx, targetPub *btcec.PublicKey) (*LinkNode, error) {\n\t// First fetch the bucket for storing node metadata, bailing out early\n\t// if it hasn't been created yet.\n\tnodeMetaBucket := tx.ReadBucket(nodeInfoBucket)\n\tif nodeMetaBucket == nil {\n\t\treturn nil, ErrLinkNodesNotFound\n\t}\n\n\t// If a link node for that particular public key cannot be located,\n\t// then exit early with an ErrNodeNotFound.\n\tpubKey := targetPub.SerializeCompressed()\n\tnodeBytes := nodeMetaBucket.Get(pubKey)\n\tif nodeBytes == nil {\n\t\treturn nil, ErrNodeNotFound\n\t}\n\n\t// Finally, decode and allocate a fresh LinkNode object to be returned\n\t// to the caller.\n\tnodeReader := bytes.NewReader(nodeBytes)\n\treturn deserializeLinkNode(nodeReader)\n}\n\n// TODO(roasbeef): update link node addrs in server upon connection\n\n// FetchAllLinkNodes starts a new database transaction to fetch all nodes with\n// whom we have active channels with.",
      "length": 815,
      "tokens": 117,
      "embedding": []
    },
    {
      "slug": "func (l *LinkNodeDB) FetchAllLinkNodes() ([]*LinkNode, error) {",
      "content": "func (l *LinkNodeDB) FetchAllLinkNodes() ([]*LinkNode, error) {\n\tvar linkNodes []*LinkNode\n\terr := kvdb.View(l.backend, func(tx kvdb.RTx) error {\n\t\tnodes, err := fetchAllLinkNodes(tx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tlinkNodes = nodes\n\t\treturn nil\n\t}, func() {\n\t\tlinkNodes = nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn linkNodes, nil\n}\n\n// fetchAllLinkNodes uses an existing database transaction to fetch all nodes\n// with whom we have active channels with.",
      "length": 390,
      "tokens": 66,
      "embedding": []
    },
    {
      "slug": "func fetchAllLinkNodes(tx kvdb.RTx) ([]*LinkNode, error) {",
      "content": "func fetchAllLinkNodes(tx kvdb.RTx) ([]*LinkNode, error) {\n\tnodeMetaBucket := tx.ReadBucket(nodeInfoBucket)\n\tif nodeMetaBucket == nil {\n\t\treturn nil, ErrLinkNodesNotFound\n\t}\n\n\tvar linkNodes []*LinkNode\n\terr := nodeMetaBucket.ForEach(func(k, v []byte) error {\n\t\tif v == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\tnodeReader := bytes.NewReader(v)\n\t\tlinkNode, err := deserializeLinkNode(nodeReader)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tlinkNodes = append(linkNodes, linkNode)\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn linkNodes, nil\n}\n",
      "length": 455,
      "tokens": 65,
      "embedding": []
    },
    {
      "slug": "func serializeLinkNode(w io.Writer, l *LinkNode) error {",
      "content": "func serializeLinkNode(w io.Writer, l *LinkNode) error {\n\tvar buf [8]byte\n\n\tbyteOrder.PutUint32(buf[:4], uint32(l.Network))\n\tif _, err := w.Write(buf[:4]); err != nil {\n\t\treturn err\n\t}\n\n\tserializedID := l.IdentityPub.SerializeCompressed()\n\tif _, err := w.Write(serializedID); err != nil {\n\t\treturn err\n\t}\n\n\tseenUnix := uint64(l.LastSeen.Unix())\n\tbyteOrder.PutUint64(buf[:], seenUnix)\n\tif _, err := w.Write(buf[:]); err != nil {\n\t\treturn err\n\t}\n\n\tnumAddrs := uint32(len(l.Addresses))\n\tbyteOrder.PutUint32(buf[:4], numAddrs)\n\tif _, err := w.Write(buf[:4]); err != nil {\n\t\treturn err\n\t}\n\n\tfor _, addr := range l.Addresses {\n\t\tif err := serializeAddr(w, addr); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n",
      "length": 617,
      "tokens": 89,
      "embedding": []
    },
    {
      "slug": "func deserializeLinkNode(r io.Reader) (*LinkNode, error) {",
      "content": "func deserializeLinkNode(r io.Reader) (*LinkNode, error) {\n\tvar (\n\t\terr error\n\t\tbuf [8]byte\n\t)\n\n\tnode := &LinkNode{}\n\n\tif _, err := io.ReadFull(r, buf[:4]); err != nil {\n\t\treturn nil, err\n\t}\n\tnode.Network = wire.BitcoinNet(byteOrder.Uint32(buf[:4]))\n\n\tvar pub [33]byte\n\tif _, err := io.ReadFull(r, pub[:]); err != nil {\n\t\treturn nil, err\n\t}\n\tnode.IdentityPub, err = btcec.ParsePubKey(pub[:])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif _, err := io.ReadFull(r, buf[:]); err != nil {\n\t\treturn nil, err\n\t}\n\tnode.LastSeen = time.Unix(int64(byteOrder.Uint64(buf[:])), 0)\n\n\tif _, err := io.ReadFull(r, buf[:4]); err != nil {\n\t\treturn nil, err\n\t}\n\tnumAddrs := byteOrder.Uint32(buf[:4])\n\n\tnode.Addresses = make([]net.Addr, numAddrs)\n\tfor i := uint32(0); i < numAddrs; i++ {\n\t\taddr, err := deserializeAddr(r)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tnode.Addresses[i] = addr\n\t}\n\n\treturn node, nil\n}\n",
      "length": 791,
      "tokens": 126,
      "embedding": []
    }
  ]
}