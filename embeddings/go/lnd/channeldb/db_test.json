{
  "filepath": "../implementations/go/lnd/channeldb/db_test.go",
  "package": "channeldb",
  "sections": [
    {
      "slug": "func TestOpenWithCreate(t *testing.T) {",
      "content": "func TestOpenWithCreate(t *testing.T) {\n\tt.Parallel()\n\n\t// Checking for db file existence is not possible with postgres.\n\tif kvdb.PostgresBackend {\n\t\tt.Skip()\n\t}\n\n\t// First, create a temporary directory to be used for the duration of\n\t// this test.\n\ttempDirName := t.TempDir()\n\n\t// Next, open thereby creating channeldb for the first time.\n\tdbPath := filepath.Join(tempDirName, \"cdb\")\n\tbackend, cleanup, err := kvdb.GetTestBackend(dbPath, \"cdb\")\n\trequire.NoError(t, err, \"unable to get test db backend\")\n\tt.Cleanup(cleanup)\n\n\tcdb, err := CreateWithBackend(backend)\n\trequire.NoError(t, err, \"unable to create channeldb\")\n\tif err := cdb.Close(); err != nil {\n\t\tt.Fatalf(\"unable to close channeldb: %v\", err)\n\t}\n\n\t// The path should have been successfully created.\n\tif !fileExists(dbPath) {\n\t\tt.Fatalf(\"channeldb failed to create data directory\")\n\t}\n\n\t// Now, reopen the same db in dry run migration mode. Since we have not\n\t// applied any migrations, this should ignore the flag and not fail.\n\tcdb, err = Open(dbPath, OptionDryRunMigration(true))\n\trequire.NoError(t, err, \"unable to create channeldb\")\n\tif err := cdb.Close(); err != nil {\n\t\tt.Fatalf(\"unable to close channeldb: %v\", err)\n\t}\n}\n\n// TestWipe tests that the database wipe operation completes successfully\n// and that the buckets are deleted. It also checks that attempts to fetch\n// information while the buckets are not set return the correct errors.",
      "length": 1333,
      "tokens": 198,
      "embedding": []
    },
    {
      "slug": "func TestWipe(t *testing.T) {",
      "content": "func TestWipe(t *testing.T) {\n\tt.Parallel()\n\n\t// First, create a temporary directory to be used for the duration of\n\t// this test.\n\ttempDirName := t.TempDir()\n\n\t// Next, open thereby creating channeldb for the first time.\n\tdbPath := filepath.Join(tempDirName, \"cdb\")\n\tbackend, cleanup, err := kvdb.GetTestBackend(dbPath, \"cdb\")\n\trequire.NoError(t, err, \"unable to get test db backend\")\n\tt.Cleanup(cleanup)\n\n\tfullDB, err := CreateWithBackend(backend)\n\trequire.NoError(t, err, \"unable to create channeldb\")\n\tdefer fullDB.Close()\n\n\tif err := fullDB.Wipe(); err != nil {\n\t\tt.Fatalf(\"unable to wipe channeldb: %v\", err)\n\t}\n\n\tcdb := fullDB.ChannelStateDB()\n\n\t// Check correct errors are returned\n\topenChannels, err := cdb.FetchAllOpenChannels()\n\trequire.NoError(t, err, \"fetching open channels\")\n\trequire.Equal(t, 0, len(openChannels))\n\n\tclosedChannels, err := cdb.FetchClosedChannels(false)\n\trequire.NoError(t, err, \"fetching closed channels\")\n\trequire.Equal(t, 0, len(closedChannels))\n}\n\n// TestFetchClosedChannelForID tests that we are able to properly retrieve a\n// ChannelCloseSummary from the DB given a ChannelID.",
      "length": 1051,
      "tokens": 129,
      "embedding": []
    },
    {
      "slug": "func TestFetchClosedChannelForID(t *testing.T) {",
      "content": "func TestFetchClosedChannelForID(t *testing.T) {\n\tt.Parallel()\n\n\tconst numChans = 101\n\n\tfullDB, err := MakeTestDB(t)\n\trequire.NoError(t, err, \"unable to make test database\")\n\n\tcdb := fullDB.ChannelStateDB()\n\n\t// Create the test channel state, that we will mutate the index of the\n\t// funding point.\n\tstate := createTestChannelState(t, cdb)\n\n\t// Now run through the number of channels, and modify the outpoint index\n\t// to create new channel IDs.\n\tfor i := uint32(0); i < numChans; i++ {\n\t\t// Save the open channel to disk.\n\t\tstate.FundingOutpoint.Index = i\n\n\t\t// Write the channel to disk in a pending state.\n\t\tcreateTestChannel(\n\t\t\tt, cdb,\n\t\t\tfundingPointOption(state.FundingOutpoint),\n\t\t\topenChannelOption(),\n\t\t)\n\n\t\t// Close the channel. To make sure we retrieve the correct\n\t\t// summary later, we make them differ in the SettledBalance.\n\t\tcloseSummary := &ChannelCloseSummary{\n\t\t\tChanPoint:      state.FundingOutpoint,\n\t\t\tRemotePub:      state.IdentityPub,\n\t\t\tSettledBalance: btcutil.Amount(500 + i),\n\t\t}\n\t\tif err := state.CloseChannel(closeSummary); err != nil {\n\t\t\tt.Fatalf(\"unable to close channel: %v\", err)\n\t\t}\n\t}\n\n\t// Now run though them all again and make sure we are able to retrieve\n\t// summaries from the DB.\n\tfor i := uint32(0); i < numChans; i++ {\n\t\tstate.FundingOutpoint.Index = i\n\n\t\t// We calculate the ChannelID and use it to fetch the summary.\n\t\tcid := lnwire.NewChanIDFromOutPoint(&state.FundingOutpoint)\n\t\tfetchedSummary, err := cdb.FetchClosedChannelForID(cid)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to fetch close summary: %v\", err)\n\t\t}\n\n\t\t// Make sure we retrieved the correct one by checking the\n\t\t// SettledBalance.\n\t\tif fetchedSummary.SettledBalance != btcutil.Amount(500+i) {\n\t\t\tt.Fatalf(\"summaries don't match: expected %v got %v\",\n\t\t\t\tbtcutil.Amount(500+i),\n\t\t\t\tfetchedSummary.SettledBalance)\n\t\t}\n\t}\n\n\t// As a final test we make sure that we get ErrClosedChannelNotFound\n\t// for a ChannelID we didn't add to the DB.\n\tstate.FundingOutpoint.Index++\n\tcid := lnwire.NewChanIDFromOutPoint(&state.FundingOutpoint)\n\t_, err = cdb.FetchClosedChannelForID(cid)\n\tif err != ErrClosedChannelNotFound {\n\t\tt.Fatalf(\"expected ErrClosedChannelNotFound, instead got: %v\", err)\n\t}\n}\n\n// TestAddrsForNode tests the we're able to properly obtain all the addresses\n// for a target node.",
      "length": 2174,
      "tokens": 296,
      "embedding": []
    },
    {
      "slug": "func TestAddrsForNode(t *testing.T) {",
      "content": "func TestAddrsForNode(t *testing.T) {\n\tt.Parallel()\n\n\tfullDB, err := MakeTestDB(t)\n\trequire.NoError(t, err, \"unable to make test database\")\n\n\tgraph := fullDB.ChannelGraph()\n\n\t// We'll make a test vertex to insert into the database, as the source\n\t// node, but this node will only have half the number of addresses it\n\t// usually does.\n\ttestNode, err := createTestVertex(fullDB)\n\trequire.NoError(t, err, \"unable to create test node\")\n\ttestNode.Addresses = []net.Addr{testAddr}\n\tif err := graph.SetSourceNode(testNode); err != nil {\n\t\tt.Fatalf(\"unable to set source node: %v\", err)\n\t}\n\n\t// Next, we'll make a link node with the same pubkey, but with an\n\t// additional address.\n\tnodePub, err := testNode.PubKey()\n\trequire.NoError(t, err, \"unable to recv node pub\")\n\tlinkNode := NewLinkNode(\n\t\tfullDB.channelStateDB.linkNodeDB, wire.MainNet, nodePub,\n\t\tanotherAddr,\n\t)\n\tif err := linkNode.Sync(); err != nil {\n\t\tt.Fatalf(\"unable to sync link node: %v\", err)\n\t}\n\n\t// Now that we've created a link node, as well as a vertex for the\n\t// node, we'll query for all its addresses.\n\tnodeAddrs, err := fullDB.AddrsForNode(nodePub)\n\trequire.NoError(t, err, \"unable to obtain node addrs\")\n\n\texpectedAddrs := make(map[string]struct{})\n\texpectedAddrs[testAddr.String()] = struct{}{}\n\texpectedAddrs[anotherAddr.String()] = struct{}{}\n\n\t// Finally, ensure that all the expected addresses are found.\n\tif len(nodeAddrs) != len(expectedAddrs) {\n\t\tt.Fatalf(\"expected %v addrs, got %v\",\n\t\t\tlen(expectedAddrs), len(nodeAddrs))\n\t}\n\tfor _, addr := range nodeAddrs {\n\t\tif _, ok := expectedAddrs[addr.String()]; !ok {\n\t\t\tt.Fatalf(\"unexpected addr: %v\", addr)\n\t\t}\n\t}\n}\n\n// TestFetchChannel tests that we're able to fetch an arbitrary channel from\n// disk.",
      "length": 1637,
      "tokens": 229,
      "embedding": []
    },
    {
      "slug": "func TestFetchChannel(t *testing.T) {",
      "content": "func TestFetchChannel(t *testing.T) {\n\tt.Parallel()\n\n\tfullDB, err := MakeTestDB(t)\n\trequire.NoError(t, err, \"unable to make test database\")\n\n\tcdb := fullDB.ChannelStateDB()\n\n\t// Create an open channel.\n\tchannelState := createTestChannel(t, cdb, openChannelOption())\n\n\t// Next, attempt to fetch the channel by its chan point.\n\tdbChannel, err := cdb.FetchChannel(nil, channelState.FundingOutpoint)\n\trequire.NoError(t, err, \"unable to fetch channel\")\n\n\t// The decoded channel state should be identical to what we stored\n\t// above.\n\tif !reflect.DeepEqual(channelState, dbChannel) {\n\t\tt.Fatalf(\"channel state doesn't match:: %v vs %v\",\n\t\t\tspew.Sdump(channelState), spew.Sdump(dbChannel))\n\t}\n\n\t// If we attempt to query for a non-existent channel, then we should\n\t// get an error.\n\tchannelState2 := createTestChannelState(t, cdb)\n\trequire.NoError(t, err, \"unable to create channel state\")\n\n\tuniqueOutputIndex.Add(1)\n\tchannelState2.FundingOutpoint.Index = uniqueOutputIndex.Load()\n\n\t_, err = cdb.FetchChannel(nil, channelState2.FundingOutpoint)\n\tif err == nil {\n\t\tt.Fatalf(\"expected query to fail\")\n\t}\n}\n",
      "length": 1025,
      "tokens": 123,
      "embedding": []
    },
    {
      "slug": "func genRandomChannelShell() (*ChannelShell, error) {",
      "content": "func genRandomChannelShell() (*ChannelShell, error) {\n\tvar testPriv [32]byte\n\tif _, err := rand.Read(testPriv[:]); err != nil {\n\t\treturn nil, err\n\t}\n\n\t_, pub := btcec.PrivKeyFromBytes(testPriv[:])\n\n\tvar chanPoint wire.OutPoint\n\tif _, err := rand.Read(chanPoint.Hash[:]); err != nil {\n\t\treturn nil, err\n\t}\n\n\tchanPoint.Index = uint32(rand.Intn(math.MaxUint16))\n\n\tchanStatus := ChanStatusDefault | ChanStatusRestored\n\n\tvar shaChainPriv [32]byte\n\tif _, err := rand.Read(testPriv[:]); err != nil {\n\t\treturn nil, err\n\t}\n\trevRoot, err := chainhash.NewHash(shaChainPriv[:])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tshaChainProducer := shachain.NewRevocationProducer(*revRoot)\n\n\treturn &ChannelShell{\n\t\tNodeAddrs: []net.Addr{&net.TCPAddr{\n\t\t\tIP:   net.ParseIP(\"127.0.0.1\"),\n\t\t\tPort: 18555,\n\t\t}},\n\t\tChan: &OpenChannel{\n\t\t\tchanStatus:      chanStatus,\n\t\t\tChainHash:       rev,\n\t\t\tFundingOutpoint: chanPoint,\n\t\t\tShortChannelID: lnwire.NewShortChanIDFromInt(\n\t\t\t\tuint64(rand.Int63()),\n\t\t\t),\n\t\t\tIdentityPub: pub,\n\t\t\tLocalChanCfg: ChannelConfig{\n\t\t\t\tChannelConstraints: ChannelConstraints{\n\t\t\t\t\tCsvDelay: uint16(rand.Int63()),\n\t\t\t\t},\n\t\t\t\tPaymentBasePoint: keychain.KeyDescriptor{\n\t\t\t\t\tKeyLocator: keychain.KeyLocator{\n\t\t\t\t\t\tFamily: keychain.KeyFamily(rand.Int63()),\n\t\t\t\t\t\tIndex:  uint32(rand.Int63()),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tRemoteCurrentRevocation: pub,\n\t\t\tIsPending:               false,\n\t\t\tRevocationStore:         shachain.NewRevocationStore(),\n\t\t\tRevocationProducer:      shaChainProducer,\n\t\t},\n\t}, nil\n}\n\n// TestRestoreChannelShells tests that we're able to insert a partially channel\n// populated to disk. This is useful for channel recovery purposes. We should\n// find the new channel shell on disk, and also the db should be populated with\n// an edge for that channel.",
      "length": 1646,
      "tokens": 175,
      "embedding": []
    },
    {
      "slug": "func TestRestoreChannelShells(t *testing.T) {",
      "content": "func TestRestoreChannelShells(t *testing.T) {\n\tt.Parallel()\n\n\tfullDB, err := MakeTestDB(t)\n\trequire.NoError(t, err, \"unable to make test database\")\n\n\tcdb := fullDB.ChannelStateDB()\n\n\t// First, we'll make our channel shell, it will only have the minimal\n\t// amount of information required for us to initiate the data loss\n\t// protection feature.\n\tchannelShell, err := genRandomChannelShell()\n\trequire.NoError(t, err, \"unable to gen channel shell\")\n\n\t// With the channel shell constructed, we'll now insert it into the\n\t// database with the restoration method.\n\tif err := cdb.RestoreChannelShells(channelShell); err != nil {\n\t\tt.Fatalf(\"unable to restore channel shell: %v\", err)\n\t}\n\n\t// Now that the channel has been inserted, we'll attempt to query for\n\t// it to ensure we can properly locate it via various means.\n\t//\n\t// First, we'll attempt to query for all channels that we have with the\n\t// node public key that was restored.\n\tnodeChans, err := cdb.FetchOpenChannels(channelShell.Chan.IdentityPub)\n\trequire.NoError(t, err, \"unable find channel\")\n\n\t// We should now find a single channel from the database.\n\tif len(nodeChans) != 1 {\n\t\tt.Fatalf(\"unable to find restored channel by node \"+\n\t\t\t\"pubkey: %v\", err)\n\t}\n\n\t// Ensure that it isn't possible to modify the commitment state machine\n\t// of this restored channel.\n\tchannel := nodeChans[0]\n\t_, err = channel.UpdateCommitment(nil, nil)\n\tif err != ErrNoRestoredChannelMutation {\n\t\tt.Fatalf(\"able to mutate restored channel\")\n\t}\n\terr = channel.AppendRemoteCommitChain(nil)\n\tif err != ErrNoRestoredChannelMutation {\n\t\tt.Fatalf(\"able to mutate restored channel\")\n\t}\n\terr = channel.AdvanceCommitChainTail(\n\t\tnil, nil, dummyLocalOutputIndex, dummyRemoteOutIndex,\n\t)\n\tif err != ErrNoRestoredChannelMutation {\n\t\tt.Fatalf(\"able to mutate restored channel\")\n\t}\n\n\t// That single channel should have the proper channel point, and also\n\t// the expected set of flags to indicate that it was a restored\n\t// channel.\n\tif nodeChans[0].FundingOutpoint != channelShell.Chan.FundingOutpoint {\n\t\tt.Fatalf(\"wrong funding outpoint: expected %v, got %v\",\n\t\t\tnodeChans[0].FundingOutpoint,\n\t\t\tchannelShell.Chan.FundingOutpoint)\n\t}\n\tif !nodeChans[0].HasChanStatus(ChanStatusRestored) {\n\t\tt.Fatalf(\"node has wrong status flags: %v\",\n\t\t\tnodeChans[0].chanStatus)\n\t}\n\n\t// We should also be able to find the channel if we query for it\n\t// directly.\n\t_, err = cdb.FetchChannel(nil, channelShell.Chan.FundingOutpoint)\n\trequire.NoError(t, err, \"unable to fetch channel\")\n\n\t// We should also be able to find the link node that was inserted by\n\t// its public key.\n\tlinkNode, err := fullDB.channelStateDB.linkNodeDB.FetchLinkNode(\n\t\tchannelShell.Chan.IdentityPub,\n\t)\n\trequire.NoError(t, err, \"unable to fetch link node\")\n\n\t// The node should have the same address, as specified in the channel\n\t// shell.\n\tif reflect.DeepEqual(linkNode.Addresses, channelShell.NodeAddrs) {\n\t\tt.Fatalf(\"addr mismatch: expected %v, got %v\",\n\t\t\tlinkNode.Addresses, channelShell.NodeAddrs)\n\t}\n}\n\n// TestAbandonChannel tests that the AbandonChannel method is able to properly\n// remove a channel from the database and add a close channel summary. If\n// called after a channel has already been removed, the method shouldn't return\n// an error.",
      "length": 3103,
      "tokens": 424,
      "embedding": []
    },
    {
      "slug": "func TestAbandonChannel(t *testing.T) {",
      "content": "func TestAbandonChannel(t *testing.T) {\n\tt.Parallel()\n\n\tfullDB, err := MakeTestDB(t)\n\trequire.NoError(t, err, \"unable to make test database\")\n\n\tcdb := fullDB.ChannelStateDB()\n\n\t// If we attempt to abandon the state of a channel that doesn't exist\n\t// in the open or closed channel bucket, then we should receive an\n\t// error.\n\terr = cdb.AbandonChannel(&wire.OutPoint{}, 0)\n\tif err == nil {\n\t\tt.Fatalf(\"removing non-existent channel should have failed\")\n\t}\n\n\t// We'll now create a new channel in a pending state to abandon\n\t// shortly.\n\tchanState := createTestChannel(t, cdb)\n\n\t// We should now be able to abandon the channel without any errors.\n\tcloseHeight := uint32(11)\n\terr = cdb.AbandonChannel(&chanState.FundingOutpoint, closeHeight)\n\trequire.NoError(t, err, \"unable to abandon channel\")\n\n\t// At this point, the channel should no longer be found in the set of\n\t// open channels.\n\t_, err = cdb.FetchChannel(nil, chanState.FundingOutpoint)\n\tif err != ErrChannelNotFound {\n\t\tt.Fatalf(\"channel should not have been found: %v\", err)\n\t}\n\n\t// However we should be able to retrieve a close channel summary for\n\t// the channel.\n\t_, err = cdb.FetchClosedChannel(&chanState.FundingOutpoint)\n\trequire.NoError(t, err, \"unable to fetch closed channel\")\n\n\t// Finally, if we attempt to abandon the channel again, we should get a\n\t// nil error as the channel has already been abandoned.\n\terr = cdb.AbandonChannel(&chanState.FundingOutpoint, closeHeight)\n\trequire.NoError(t, err, \"unable to abandon channel\")\n}\n\n// TestFetchChannels tests the filtering of open channels in fetchChannels.\n// It tests the case where no filters are provided (which is equivalent to\n// FetchAllOpenChannels) and every combination of pending and waiting close.",
      "length": 1642,
      "tokens": 238,
      "embedding": []
    },
    {
      "slug": "func TestFetchChannels(t *testing.T) {",
      "content": "func TestFetchChannels(t *testing.T) {\n\t// Create static channel IDs for each kind of channel retrieved by\n\t// fetchChannels so that the expected channel IDs can be set in tests.\n\tvar (\n\t\t// Pending is a channel that is pending open, and has not had\n\t\t// a close initiated.\n\t\tpendingChan = lnwire.NewShortChanIDFromInt(1)\n\n\t\t// pendingWaitingClose is a channel that is pending open and\n\t\t// has has its closing transaction broadcast.\n\t\tpendingWaitingChan = lnwire.NewShortChanIDFromInt(2)\n\n\t\t// openChan is a channel that has confirmed on chain.\n\t\topenChan = lnwire.NewShortChanIDFromInt(3)\n\n\t\t// openWaitingChan is a channel that has confirmed on chain,\n\t\t// and it waiting for its close transaction to confirm.\n\t\topenWaitingChan = lnwire.NewShortChanIDFromInt(4)\n\t)\n\n\ttests := []struct {\n\t\tname             string\n\t\tfilters          []fetchChannelsFilter\n\t\texpectedChannels map[lnwire.ShortChannelID]bool\n\t}{\n\t\t{\n\t\t\tname:    \"get all channels\",\n\t\t\tfilters: []fetchChannelsFilter{},\n\t\t\texpectedChannels: map[lnwire.ShortChannelID]bool{\n\t\t\t\tpendingChan:        true,\n\t\t\t\tpendingWaitingChan: true,\n\t\t\t\topenChan:           true,\n\t\t\t\topenWaitingChan:    true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"pending channels\",\n\t\t\tfilters: []fetchChannelsFilter{\n\t\t\t\tpendingChannelFilter(true),\n\t\t\t},\n\t\t\texpectedChannels: map[lnwire.ShortChannelID]bool{\n\t\t\t\tpendingChan:        true,\n\t\t\t\tpendingWaitingChan: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"open channels\",\n\t\t\tfilters: []fetchChannelsFilter{\n\t\t\t\tpendingChannelFilter(false),\n\t\t\t},\n\t\t\texpectedChannels: map[lnwire.ShortChannelID]bool{\n\t\t\t\topenChan:        true,\n\t\t\t\topenWaitingChan: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"waiting close channels\",\n\t\t\tfilters: []fetchChannelsFilter{\n\t\t\t\twaitingCloseFilter(true),\n\t\t\t},\n\t\t\texpectedChannels: map[lnwire.ShortChannelID]bool{\n\t\t\t\tpendingWaitingChan: true,\n\t\t\t\topenWaitingChan:    true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"not waiting close channels\",\n\t\t\tfilters: []fetchChannelsFilter{\n\t\t\t\twaitingCloseFilter(false),\n\t\t\t},\n\t\t\texpectedChannels: map[lnwire.ShortChannelID]bool{\n\t\t\t\tpendingChan: true,\n\t\t\t\topenChan:    true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"pending waiting\",\n\t\t\tfilters: []fetchChannelsFilter{\n\t\t\t\tpendingChannelFilter(true),\n\t\t\t\twaitingCloseFilter(true),\n\t\t\t},\n\t\t\texpectedChannels: map[lnwire.ShortChannelID]bool{\n\t\t\t\tpendingWaitingChan: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"pending, not waiting\",\n\t\t\tfilters: []fetchChannelsFilter{\n\t\t\t\tpendingChannelFilter(true),\n\t\t\t\twaitingCloseFilter(false),\n\t\t\t},\n\t\t\texpectedChannels: map[lnwire.ShortChannelID]bool{\n\t\t\t\tpendingChan: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"open waiting\",\n\t\t\tfilters: []fetchChannelsFilter{\n\t\t\t\tpendingChannelFilter(false),\n\t\t\t\twaitingCloseFilter(true),\n\t\t\t},\n\t\t\texpectedChannels: map[lnwire.ShortChannelID]bool{\n\t\t\t\topenWaitingChan: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"open, not waiting\",\n\t\t\tfilters: []fetchChannelsFilter{\n\t\t\t\tpendingChannelFilter(false),\n\t\t\t\twaitingCloseFilter(false),\n\t\t\t},\n\t\t\texpectedChannels: map[lnwire.ShortChannelID]bool{\n\t\t\t\topenChan: true,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tfullDB, err := MakeTestDB(t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to make test \"+\n\t\t\t\t\t\"database: %v\", err)\n\t\t\t}\n\n\t\t\tcdb := fullDB.ChannelStateDB()\n\n\t\t\t// Create a pending channel that is not awaiting close.\n\t\t\tcreateTestChannel(\n\t\t\t\tt, cdb, channelIDOption(pendingChan),\n\t\t\t)\n\n\t\t\t// Create a pending channel which has has been marked as\n\t\t\t// broadcast, indicating that its closing transaction is\n\t\t\t// waiting to confirm.\n\t\t\tpendingClosing := createTestChannel(\n\t\t\t\tt, cdb,\n\t\t\t\tchannelIDOption(pendingWaitingChan),\n\t\t\t)\n\n\t\t\terr = pendingClosing.MarkCoopBroadcasted(nil, true)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t\t}\n\n\t\t\t// Create a open channel that is not awaiting close.\n\t\t\tcreateTestChannel(\n\t\t\t\tt, cdb,\n\t\t\t\tchannelIDOption(openChan),\n\t\t\t\topenChannelOption(),\n\t\t\t)\n\n\t\t\t// Create a open channel which has has been marked as\n\t\t\t// broadcast, indicating that its closing transaction is\n\t\t\t// waiting to confirm.\n\t\t\topenClosing := createTestChannel(\n\t\t\t\tt, cdb,\n\t\t\t\tchannelIDOption(openWaitingChan),\n\t\t\t\topenChannelOption(),\n\t\t\t)\n\t\t\terr = openClosing.MarkCoopBroadcasted(nil, true)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t\t}\n\n\t\t\tchannels, err := fetchChannels(cdb, test.filters...)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t\t}\n\n\t\t\tif len(channels) != len(test.expectedChannels) {\n\t\t\t\tt.Fatalf(\"expected: %v channels, \"+\n\t\t\t\t\t\"got: %v\", len(test.expectedChannels),\n\t\t\t\t\tlen(channels))\n\t\t\t}\n\n\t\t\tfor _, ch := range channels {\n\t\t\t\t_, ok := test.expectedChannels[ch.ShortChannelID]\n\t\t\t\tif !ok {\n\t\t\t\t\tt.Fatalf(\"fetch channels unexpected \"+\n\t\t\t\t\t\t\"channel: %v\", ch.ShortChannelID)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestFetchHistoricalChannel tests lookup of historical channels.",
      "length": 4600,
      "tokens": 482,
      "embedding": []
    },
    {
      "slug": "func TestFetchHistoricalChannel(t *testing.T) {",
      "content": "func TestFetchHistoricalChannel(t *testing.T) {\n\tfullDB, err := MakeTestDB(t)\n\trequire.NoError(t, err, \"unable to make test database\")\n\n\tcdb := fullDB.ChannelStateDB()\n\n\t// Create a an open channel in the database.\n\tchannel := createTestChannel(t, cdb, openChannelOption())\n\n\t// First, try to lookup a channel when nothing is in the bucket. As the\n\t// bucket is auto-created (on start up), we'll get a channel not found\n\t// error.\n\t_, err = cdb.FetchHistoricalChannel(&channel.FundingOutpoint)\n\tif err != ErrChannelNotFound {\n\t\tt.Fatalf(\"expected no bucket, got: %v\", err)\n\t}\n\n\t// Close the channel so that it will be written to the historical\n\t// bucket. The values provided in the channel close summary are the\n\t// minimum required for this call to run without panicking.\n\tif err := channel.CloseChannel(&ChannelCloseSummary{\n\t\tChanPoint:      channel.FundingOutpoint,\n\t\tRemotePub:      channel.IdentityPub,\n\t\tSettledBalance: btcutil.Amount(500),\n\t}); err != nil {\n\t\tt.Fatalf(\"unexpected error closing channel: %v\", err)\n\t}\n\n\thistChannel, err := cdb.FetchHistoricalChannel(&channel.FundingOutpoint)\n\trequire.NoError(t, err, \"unexpected error getting channel\")\n\n\t// FetchHistoricalChannel will attach the cdb to channel.Db, we set it\n\t// here so that we can check that all other fields on the channel equal\n\t// those on the historical channel.\n\tchannel.Db = cdb\n\n\tif !reflect.DeepEqual(histChannel, channel) {\n\t\tt.Fatalf(\"expected: %v, got: %v\", channel, histChannel)\n\t}\n\n\t// Create an outpoint that will not be in the db and look it up.\n\tbadOutpoint := &wire.OutPoint{\n\t\tHash:  channel.FundingOutpoint.Hash,\n\t\tIndex: channel.FundingOutpoint.Index + 1,\n\t}\n\t_, err = cdb.FetchHistoricalChannel(badOutpoint)\n\tif err != ErrChannelNotFound {\n\t\tt.Fatalf(\"expected chan not found, got: %v\", err)\n\t}\n}\n",
      "length": 1699,
      "tokens": 230,
      "embedding": []
    }
  ]
}