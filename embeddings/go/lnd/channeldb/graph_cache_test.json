{
  "filepath": "../implementations/go/lnd/channeldb/graph_cache_test.go",
  "package": "channeldb",
  "sections": [
    {
      "slug": "type node struct {",
      "content": "type node struct {\n\tpubKey   route.Vertex\n\tfeatures *lnwire.FeatureVector\n\n\tedgeInfos   []*ChannelEdgeInfo\n\toutPolicies []*ChannelEdgePolicy\n\tinPolicies  []*ChannelEdgePolicy\n}\n",
      "length": 151,
      "tokens": 11,
      "embedding": []
    },
    {
      "slug": "func (n *node) PubKey() route.Vertex {",
      "content": "func (n *node) PubKey() route.Vertex {\n\treturn n.pubKey\n}",
      "length": 17,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (n *node) Features() *lnwire.FeatureVector {",
      "content": "func (n *node) Features() *lnwire.FeatureVector {\n\treturn n.features\n}\n",
      "length": 19,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (n *node) ForEachChannel(tx kvdb.RTx,",
      "content": "func (n *node) ForEachChannel(tx kvdb.RTx,\n\tcb func(kvdb.RTx, *ChannelEdgeInfo, *ChannelEdgePolicy,\n\t\t*ChannelEdgePolicy) error) error {\n\n\tfor idx := range n.edgeInfos {\n\t\terr := cb(\n\t\t\ttx, n.edgeInfos[idx], n.outPolicies[idx],\n\t\t\tn.inPolicies[idx],\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// TestGraphCacheAddNode tests that a channel going from node A to node B can be\n// cached correctly, independent of the direction we add the channel as.",
      "length": 402,
      "tokens": 61,
      "embedding": []
    },
    {
      "slug": "func TestGraphCacheAddNode(t *testing.T) {",
      "content": "func TestGraphCacheAddNode(t *testing.T) {\n\tt.Parallel()\n\n\trunTest := func(nodeA, nodeB route.Vertex) {\n\t\tt.Helper()\n\n\t\tchannelFlagA, channelFlagB := 0, 1\n\t\tif nodeA == pubKey2 {\n\t\t\tchannelFlagA, channelFlagB = 1, 0\n\t\t}\n\n\t\toutPolicy1 := &ChannelEdgePolicy{\n\t\t\tChannelID:    1000,\n\t\t\tChannelFlags: lnwire.ChanUpdateChanFlags(channelFlagA),\n\t\t\tNode: &LightningNode{\n\t\t\t\tPubKeyBytes: nodeB,\n\t\t\t\tFeatures:    lnwire.EmptyFeatureVector(),\n\t\t\t},\n\t\t}\n\t\tinPolicy1 := &ChannelEdgePolicy{\n\t\t\tChannelID:    1000,\n\t\t\tChannelFlags: lnwire.ChanUpdateChanFlags(channelFlagB),\n\t\t\tNode: &LightningNode{\n\t\t\t\tPubKeyBytes: nodeA,\n\t\t\t\tFeatures:    lnwire.EmptyFeatureVector(),\n\t\t\t},\n\t\t}\n\t\tnode := &node{\n\t\t\tpubKey:   nodeA,\n\t\t\tfeatures: lnwire.EmptyFeatureVector(),\n\t\t\tedgeInfos: []*ChannelEdgeInfo{{\n\t\t\t\tChannelID: 1000,\n\t\t\t\t// Those are direction independent!\n\t\t\t\tNodeKey1Bytes: pubKey1,\n\t\t\t\tNodeKey2Bytes: pubKey2,\n\t\t\t\tCapacity:      500,\n\t\t\t}},\n\t\t\toutPolicies: []*ChannelEdgePolicy{outPolicy1},\n\t\t\tinPolicies:  []*ChannelEdgePolicy{inPolicy1},\n\t\t}\n\t\tcache := NewGraphCache(10)\n\t\trequire.NoError(t, cache.AddNode(nil, node))\n\n\t\tvar fromChannels, toChannels []*DirectedChannel\n\t\t_ = cache.ForEachChannel(nodeA, func(c *DirectedChannel) error {\n\t\t\tfromChannels = append(fromChannels, c)\n\t\t\treturn nil\n\t\t})\n\t\t_ = cache.ForEachChannel(nodeB, func(c *DirectedChannel) error {\n\t\t\ttoChannels = append(toChannels, c)\n\t\t\treturn nil\n\t\t})\n\n\t\trequire.Len(t, fromChannels, 1)\n\t\trequire.Len(t, toChannels, 1)\n\n\t\trequire.Equal(t, outPolicy1 != nil, fromChannels[0].OutPolicySet)\n\t\tassertCachedPolicyEqual(t, inPolicy1, fromChannels[0].InPolicy)\n\n\t\trequire.Equal(t, inPolicy1 != nil, toChannels[0].OutPolicySet)\n\t\tassertCachedPolicyEqual(t, outPolicy1, toChannels[0].InPolicy)\n\n\t\t// Now that we've inserted two nodes into the graph, check that\n\t\t// we'll recover the same set of channels during ForEachNode.\n\t\tnodes := make(map[route.Vertex]struct{})\n\t\tchans := make(map[uint64]struct{})\n\t\t_ = cache.ForEachNode(func(node route.Vertex,\n\t\t\tedges map[uint64]*DirectedChannel) error {\n\n\t\t\tnodes[node] = struct{}{}\n\t\t\tfor chanID := range edges {\n\t\t\t\tchans[chanID] = struct{}{}\n\t\t\t}\n\n\t\t\treturn nil\n\t\t})\n\n\t\trequire.Len(t, nodes, 2)\n\t\trequire.Len(t, chans, 1)\n\t}\n\n\trunTest(pubKey1, pubKey2)\n\trunTest(pubKey2, pubKey1)\n}\n",
      "length": 2153,
      "tokens": 206,
      "embedding": []
    },
    {
      "slug": "func assertCachedPolicyEqual(t *testing.T, original *ChannelEdgePolicy,",
      "content": "func assertCachedPolicyEqual(t *testing.T, original *ChannelEdgePolicy,\n\tcached *CachedEdgePolicy) {\n\n\trequire.Equal(t, original.ChannelID, cached.ChannelID)\n\trequire.Equal(t, original.MessageFlags, cached.MessageFlags)\n\trequire.Equal(t, original.ChannelFlags, cached.ChannelFlags)\n\trequire.Equal(t, original.TimeLockDelta, cached.TimeLockDelta)\n\trequire.Equal(t, original.MinHTLC, cached.MinHTLC)\n\trequire.Equal(t, original.MaxHTLC, cached.MaxHTLC)\n\trequire.Equal(t, original.FeeBaseMSat, cached.FeeBaseMSat)\n\trequire.Equal(\n\t\tt, original.FeeProportionalMillionths,\n\t\tcached.FeeProportionalMillionths,\n\t)\n\trequire.Equal(\n\t\tt,\n\t\troute.Vertex(original.Node.PubKeyBytes),\n\t\tcached.ToNodePubKey(),\n\t)\n\trequire.Equal(t, original.Node.Features, cached.ToNodeFeatures)\n}\n",
      "length": 673,
      "tokens": 38,
      "embedding": []
    }
  ]
}