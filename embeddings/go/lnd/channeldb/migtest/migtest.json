{
  "filepath": "../implementations/go/lnd/channeldb/migtest/migtest.go",
  "package": "migtest",
  "sections": [
    {
      "slug": "func MakeDB(t testing.TB) (kvdb.Backend, error) {",
      "content": "func MakeDB(t testing.TB) (kvdb.Backend, error) {\n\t// Create temporary database for mission control.\n\tfile, err := os.CreateTemp(\"\", \"*.db\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdbPath := file.Name()\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, file.Close())\n\t\trequire.NoError(t, os.Remove(dbPath))\n\t})\n\n\tdb, err := kvdb.Open(\n\t\tkvdb.BoltBackendName, dbPath, true, kvdb.DefaultDBTimeout,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, db.Close())\n\t})\n\n\treturn db, nil\n}\n\n// ApplyMigration is a helper test function that encapsulates the general steps\n// which are needed to properly check the result of applying migration function.",
      "length": 589,
      "tokens": 83,
      "embedding": []
    },
    {
      "slug": "func ApplyMigration(t *testing.T,",
      "content": "func ApplyMigration(t *testing.T,\n\tbeforeMigration, afterMigration, migrationFunc func(tx kvdb.RwTx) error,\n\tshouldFail bool) {\n\n\tt.Helper()\n\n\tcdb, err := MakeDB(t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// beforeMigration usually used for populating the database\n\t// with test data.\n\terr = kvdb.Update(cdb, beforeMigration, func() {})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdefer func() {\n\t\tt.Helper()\n\n\t\tif r := recover(); r != nil {\n\t\t\terr = newError(r)\n\t\t}\n\n\t\tif err == nil && shouldFail {\n\t\t\tt.Fatal(\"error wasn't received on migration stage\")\n\t\t} else if err != nil && !shouldFail {\n\t\t\tt.Fatalf(\"error was received on migration stage: %v\", err)\n\t\t}\n\n\t\t// afterMigration usually used for checking the database state and\n\t\t// throwing the error if something went wrong.\n\t\terr = kvdb.Update(cdb, afterMigration, func() {})\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}()\n\n\t// Apply migration.\n\terr = kvdb.Update(cdb, migrationFunc, func() {})\n\tif err != nil {\n\t\tt.Logf(\"migration error: %v\", err)\n\t}\n}\n\n// ApplyMigrationWithDB is a helper test function that encapsulates the general\n// steps which are needed to properly check the result of applying migration\n// function. This function differs from ApplyMigration as it requires the\n// supplied migration functions to take a db instance and construct their own\n// database transactions.",
      "length": 1248,
      "tokens": 196,
      "embedding": []
    },
    {
      "slug": "func ApplyMigrationWithDB(t testing.TB, beforeMigration,",
      "content": "func ApplyMigrationWithDB(t testing.TB, beforeMigration,\n\tafterMigration func(db kvdb.Backend) error,\n\tmigrationFunc func(db kvdb.Backend) error, shouldFail bool) {\n\n\tt.Helper()\n\n\tcdb, err := MakeDB(t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// beforeMigration usually used for populating the database\n\t// with test data.\n\tif err := beforeMigration(cdb); err != nil {\n\t\tt.Fatalf(\"beforeMigration error: %v\", err)\n\t}\n\n\t// Apply migration.\n\terr = migrationFunc(cdb)\n\tif shouldFail {\n\t\trequire.Error(t, err)\n\t} else {\n\t\trequire.NoError(t, err)\n\t}\n\n\t// If there's no afterMigration, exit here.\n\tif afterMigration == nil {\n\t\treturn\n\t}\n\n\t// afterMigration usually used for checking the database state\n\t// and throwing the error if something went wrong.\n\tif err := afterMigration(cdb); err != nil {\n\t\tt.Fatalf(\"afterMigration error: %v\", err)\n\t}\n}\n",
      "length": 746,
      "tokens": 111,
      "embedding": []
    },
    {
      "slug": "func newError(e interface{}) error {",
      "content": "func newError(e interface{}) error {\n\tvar err error\n\tswitch e := e.(type) {\n\tcase error:\n\t\terr = e\n\tdefault:\n\t\terr = fmt.Errorf(\"%v\", e)\n\t}\n\n\treturn err\n}\n",
      "length": 108,
      "tokens": 22,
      "embedding": []
    }
  ]
}