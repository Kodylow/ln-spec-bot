{
  "filepath": "../implementations/go/lnd/channeldb/migtest/raw_db.go",
  "package": "migtest",
  "sections": [
    {
      "slug": "func DumpDB(tx kvdb.RTx, rootKey []byte) error {",
      "content": "func DumpDB(tx kvdb.RTx, rootKey []byte) error {\n\tbucket := tx.ReadBucket(rootKey)\n\tif bucket == nil {\n\t\treturn fmt.Errorf(\"bucket %v not found\", string(rootKey))\n\t}\n\n\treturn dumpBucket(bucket)\n}\n",
      "length": 140,
      "tokens": 18,
      "embedding": []
    },
    {
      "slug": "func dumpBucket(bucket kvdb.RBucket) error {",
      "content": "func dumpBucket(bucket kvdb.RBucket) error {\n\tfmt.Printf(\"map[string]interface{} {\\n\")\n\terr := bucket.ForEach(func(k, v []byte) error {\n\t\tkey := toString(k)\n\t\tfmt.Printf(\"%v: \", key)\n\n\t\tsubBucket := bucket.NestedReadBucket(k)\n\t\tif subBucket != nil {\n\t\t\terr := dumpBucket(subBucket)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\tfmt.Print(toHex(v))\n\t\t}\n\t\tfmt.Printf(\",\\n\")\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tfmt.Printf(\"}\")\n\n\treturn nil\n}\n\n// RestoreDB primes the database with the given data set.",
      "length": 449,
      "tokens": 65,
      "embedding": []
    },
    {
      "slug": "func RestoreDB(tx kvdb.RwTx, rootKey []byte, data map[string]interface{}) error {",
      "content": "func RestoreDB(tx kvdb.RwTx, rootKey []byte, data map[string]interface{}) error {\n\tbucket, err := tx.CreateTopLevelBucket(rootKey)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn restoreDB(bucket, data)\n}\n",
      "length": 110,
      "tokens": 16,
      "embedding": []
    },
    {
      "slug": "func restoreDB(bucket kvdb.RwBucket, data map[string]interface{}) error {",
      "content": "func restoreDB(bucket kvdb.RwBucket, data map[string]interface{}) error {\n\tfor k, v := range data {\n\t\tkey := []byte(k)\n\n\t\tswitch value := v.(type) {\n\t\t// Key contains value.\n\t\tcase string:\n\t\t\terr := bucket.Put(key, []byte(value))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t// Key contains a sub-bucket.\n\t\tcase map[string]interface{}:\n\t\t\tsubBucket, err := bucket.CreateBucket(key)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif err := restoreDB(subBucket, value); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\treturn errors.New(\"invalid type\")\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// VerifyDB verifies the database against the given data set.",
      "length": 523,
      "tokens": 83,
      "embedding": []
    },
    {
      "slug": "func VerifyDB(tx kvdb.RTx, rootKey []byte, data map[string]interface{}) error {",
      "content": "func VerifyDB(tx kvdb.RTx, rootKey []byte, data map[string]interface{}) error {\n\tbucket := tx.ReadBucket(rootKey)\n\tif bucket == nil {\n\t\treturn fmt.Errorf(\"bucket %v not found\", string(rootKey))\n\t}\n\n\treturn verifyDB(bucket, data)\n}\n",
      "length": 144,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func verifyDB(bucket kvdb.RBucket, data map[string]interface{}) error {",
      "content": "func verifyDB(bucket kvdb.RBucket, data map[string]interface{}) error {\n\tfor k, v := range data {\n\t\tkey := []byte(k)\n\n\t\tswitch value := v.(type) {\n\t\t// Key contains value.\n\t\tcase string:\n\t\t\texpectedValue := []byte(value)\n\t\t\tdbValue := bucket.Get(key)\n\n\t\t\tif !bytes.Equal(dbValue, expectedValue) {\n\t\t\t\treturn errors.New(\"value mismatch\")\n\t\t\t}\n\n\t\t// Key contains a sub-bucket.\n\t\tcase map[string]interface{}:\n\t\t\tsubBucket := bucket.NestedReadBucket(key)\n\t\t\tif subBucket == nil {\n\t\t\t\treturn fmt.Errorf(\"bucket %v not found\", k)\n\t\t\t}\n\n\t\t\terr := verifyDB(subBucket, value)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\treturn errors.New(\"invalid type\")\n\t\t}\n\t}\n\n\tkeyCount := 0\n\terr := bucket.ForEach(func(k, v []byte) error {\n\t\tkeyCount++\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif keyCount != len(data) {\n\t\treturn errors.New(\"unexpected keys in database\")\n\t}\n\n\treturn nil\n}\n",
      "length": 771,
      "tokens": 111,
      "embedding": []
    },
    {
      "slug": "func toHex(v []byte) string {",
      "content": "func toHex(v []byte) string {\n\tif len(v) == 0 {\n\t\treturn \"nil\"\n\t}\n\n\treturn \"hex(\\\"\" + hex.EncodeToString(v) + \"\\\")\"\n}\n",
      "length": 82,
      "tokens": 15,
      "embedding": []
    },
    {
      "slug": "func toString(v []byte) string {",
      "content": "func toString(v []byte) string {\n\treadableChars := \"abcdefghijklmnopqrstuvwxyz0123456789-\"\n\n\tfor _, c := range v {\n\t\tif !strings.Contains(readableChars, string(c)) {\n\t\t\treturn toHex(v)\n\t\t}\n\t}\n\n\treturn \"\\\"\" + string(v) + \"\\\"\"\n}\n\n// Hex is a test helper function to convert readable hex arrays to raw byte\n// strings.",
      "length": 270,
      "tokens": 42,
      "embedding": []
    },
    {
      "slug": "func Hex(value string) string {",
      "content": "func Hex(value string) string {\n\tb, err := hex.DecodeString(value)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn string(b)\n}\n",
      "length": 82,
      "tokens": 14,
      "embedding": []
    }
  ]
}