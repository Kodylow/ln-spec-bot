{
  "filepath": "../implementations/go/lnd/subrpcserver_config.go",
  "package": "lnd",
  "sections": [
    {
      "slug": "type subRPCServerConfigs struct {",
      "content": "type subRPCServerConfigs struct {\n\t// SignRPC is a sub-RPC server that exposes signing of arbitrary inputs\n\t// as a gRPC service.\n\tSignRPC *signrpc.Config `group:\"signrpc\" namespace:\"signrpc\"`\n\n\t// WalletKitRPC is a sub-RPC server that exposes functionality allowing\n\t// a client to send transactions through a wallet, publish them, and\n\t// also requests keys and addresses under control of the backing\n\t// wallet.\n\tWalletKitRPC *walletrpc.Config `group:\"walletrpc\" namespace:\"walletrpc\"`\n\n\t// AutopilotRPC is a sub-RPC server that exposes methods on the running\n\t// autopilot as a gRPC service.\n\tAutopilotRPC *autopilotrpc.Config `group:\"autopilotrpc\" namespace:\"autopilotrpc\"`\n\n\t// ChainRPC is a sub-RPC server that exposes functionality allowing a\n\t// client to be notified of certain on-chain events (new blocks,\n\t// confirmations, spends).\n\tChainRPC *chainrpc.Config `group:\"chainrpc\" namespace:\"chainrpc\"`\n\n\t// InvoicesRPC is a sub-RPC server that exposes invoice related methods\n\t// as a gRPC service.\n\tInvoicesRPC *invoicesrpc.Config `group:\"invoicesrpc\" namespace:\"invoicesrpc\"`\n\n\t// PeersRPC is a sub-RPC server that exposes peer related methods\n\t// as a gRPC service.\n\tPeersRPC *peersrpc.Config `group:\"peersrpc\" namespace:\"peersrpc\"`\n\n\t// NeutrinoKitRPC is a sub-RPC server that exposes functionality allowing\n\t// a client to interact with a running neutrino node.\n\tNeutrinoKitRPC *neutrinorpc.Config `group:\"neutrinorpc\" namespace:\"neutrinorpc\"`\n\n\t// RouterRPC is a sub-RPC server the exposes functionality that allows\n\t// clients to send payments on the network, and perform Lightning\n\t// payment related queries such as requests for estimates of off-chain\n\t// fees.\n\tRouterRPC *routerrpc.Config `group:\"routerrpc\" namespace:\"routerrpc\"`\n\n\t// WatchtowerRPC is a sub-RPC server that exposes functionality allowing\n\t// clients to monitor and control their embedded watchtower.\n\tWatchtowerRPC *watchtowerrpc.Config `group:\"watchtowerrpc\" namespace:\"watchtowerrpc\"`\n\n\t// WatchtowerClientRPC is a sub-RPC server that exposes functionality\n\t// that allows clients to interact with the active watchtower client\n\t// instance within lnd in order to add, remove, list registered client\n\t// towers, etc.\n\tWatchtowerClientRPC *wtclientrpc.Config `group:\"wtclientrpc\" namespace:\"wtclientrpc\"`\n\n\t// DevRPC is a sub-RPC server that exposes functionality that allows\n\t// developers manipulate LND state that is normally not possible.\n\t// Should only be used for development purposes.\n\tDevRPC *devrpc.Config `group:\"devrpc\" namespace:\"devrpc\"`\n}\n\n// PopulateDependencies attempts to iterate through all the sub-server configs\n// within this struct, and populate the items it requires based on the main\n// configuration file, and the chain control.\n//\n// NOTE: This MUST be called before any callers are permitted to execute the\n// FetchConfig method.",
      "length": 2755,
      "tokens": 359,
      "embedding": []
    },
    {
      "slug": "func (s *subRPCServerConfigs) PopulateDependencies(cfg *Config,",
      "content": "func (s *subRPCServerConfigs) PopulateDependencies(cfg *Config,\n\tcc *chainreg.ChainControl,\n\tnetworkDir string, macService *macaroons.Service,\n\tatpl *autopilot.Manager,\n\tinvoiceRegistry *invoices.InvoiceRegistry,\n\thtlcSwitch *htlcswitch.Switch,\n\tactiveNetParams *chaincfg.Params,\n\tchanRouter *routing.ChannelRouter,\n\trouterBackend *routerrpc.RouterBackend,\n\tnodeSigner *netann.NodeSigner,\n\tgraphDB *channeldb.ChannelGraph,\n\tchanStateDB *channeldb.ChannelStateDB,\n\tsweeper *sweep.UtxoSweeper,\n\ttower *watchtower.Standalone,\n\ttowerClient wtclient.Client,\n\tanchorTowerClient wtclient.Client,\n\ttcpResolver lncfg.TCPResolver,\n\tgenInvoiceFeatures func() *lnwire.FeatureVector,\n\tgenAmpInvoiceFeatures func() *lnwire.FeatureVector,\n\tgetNodeAnnouncement func() (lnwire.NodeAnnouncement, error),\n\tupdateNodeAnnouncement func(modifiers ...netann.NodeAnnModifier) error,\n\tparseAddr func(addr string) (net.Addr, error),\n\trpcLogger btclog.Logger,\n\tgetAlias func(lnwire.ChannelID) (lnwire.ShortChannelID, error)) error {\n\n\t// First, we'll use reflect to obtain a version of the config struct\n\t// that allows us to programmatically inspect its fields.\n\tselfVal := extractReflectValue(s)\n\tselfType := selfVal.Type()\n\n\tnumFields := selfVal.NumField()\n\tfor i := 0; i < numFields; i++ {\n\t\tfield := selfVal.Field(i)\n\t\tfieldElem := field.Elem()\n\t\tfieldName := selfType.Field(i).Name\n\n\t\tltndLog.Debugf(\"Populating dependencies for sub RPC \"+\n\t\t\t\"server: %v\", fieldName)\n\n\t\t// If this sub-config doesn't actually have any fields, then we\n\t\t// can skip it, as the build tag for it is likely off.\n\t\tif fieldElem.NumField() == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif !fieldElem.CanSet() {\n\t\t\tcontinue\n\t\t}\n\n\t\tswitch subCfg := field.Interface().(type) {\n\t\tcase *signrpc.Config:\n\t\t\tsubCfgValue := extractReflectValue(subCfg)\n\n\t\t\tsubCfgValue.FieldByName(\"MacService\").Set(\n\t\t\t\treflect.ValueOf(macService),\n\t\t\t)\n\t\t\tsubCfgValue.FieldByName(\"NetworkDir\").Set(\n\t\t\t\treflect.ValueOf(networkDir),\n\t\t\t)\n\t\t\tsubCfgValue.FieldByName(\"Signer\").Set(\n\t\t\t\treflect.ValueOf(cc.Signer),\n\t\t\t)\n\t\t\tsubCfgValue.FieldByName(\"KeyRing\").Set(\n\t\t\t\treflect.ValueOf(cc.KeyRing),\n\t\t\t)\n\n\t\tcase *walletrpc.Config:\n\t\t\tsubCfgValue := extractReflectValue(subCfg)\n\n\t\t\tsubCfgValue.FieldByName(\"NetworkDir\").Set(\n\t\t\t\treflect.ValueOf(networkDir),\n\t\t\t)\n\t\t\tsubCfgValue.FieldByName(\"MacService\").Set(\n\t\t\t\treflect.ValueOf(macService),\n\t\t\t)\n\t\t\tsubCfgValue.FieldByName(\"FeeEstimator\").Set(\n\t\t\t\treflect.ValueOf(cc.FeeEstimator),\n\t\t\t)\n\t\t\tsubCfgValue.FieldByName(\"Wallet\").Set(\n\t\t\t\treflect.ValueOf(cc.Wallet),\n\t\t\t)\n\t\t\tsubCfgValue.FieldByName(\"CoinSelectionLocker\").Set(\n\t\t\t\treflect.ValueOf(cc.Wallet),\n\t\t\t)\n\t\t\tsubCfgValue.FieldByName(\"KeyRing\").Set(\n\t\t\t\treflect.ValueOf(cc.KeyRing),\n\t\t\t)\n\t\t\tsubCfgValue.FieldByName(\"Sweeper\").Set(\n\t\t\t\treflect.ValueOf(sweeper),\n\t\t\t)\n\t\t\tsubCfgValue.FieldByName(\"Chain\").Set(\n\t\t\t\treflect.ValueOf(cc.ChainIO),\n\t\t\t)\n\t\t\tsubCfgValue.FieldByName(\"ChainParams\").Set(\n\t\t\t\treflect.ValueOf(activeNetParams),\n\t\t\t)\n\t\t\tsubCfgValue.FieldByName(\"CurrentNumAnchorChans\").Set(\n\t\t\t\treflect.ValueOf(cc.Wallet.CurrentNumAnchorChans),\n\t\t\t)\n\n\t\tcase *autopilotrpc.Config:\n\t\t\tsubCfgValue := extractReflectValue(subCfg)\n\n\t\t\tsubCfgValue.FieldByName(\"Manager\").Set(\n\t\t\t\treflect.ValueOf(atpl),\n\t\t\t)\n\n\t\tcase *chainrpc.Config:\n\t\t\tsubCfgValue := extractReflectValue(subCfg)\n\n\t\t\tsubCfgValue.FieldByName(\"NetworkDir\").Set(\n\t\t\t\treflect.ValueOf(networkDir),\n\t\t\t)\n\t\t\tsubCfgValue.FieldByName(\"MacService\").Set(\n\t\t\t\treflect.ValueOf(macService),\n\t\t\t)\n\t\t\tsubCfgValue.FieldByName(\"ChainNotifier\").Set(\n\t\t\t\treflect.ValueOf(cc.ChainNotifier),\n\t\t\t)\n\t\t\tsubCfgValue.FieldByName(\"Chain\").Set(\n\t\t\t\treflect.ValueOf(cc.ChainIO),\n\t\t\t)\n\n\t\tcase *invoicesrpc.Config:\n\t\t\tsubCfgValue := extractReflectValue(subCfg)\n\n\t\t\tsubCfgValue.FieldByName(\"NetworkDir\").Set(\n\t\t\t\treflect.ValueOf(networkDir),\n\t\t\t)\n\t\t\tsubCfgValue.FieldByName(\"MacService\").Set(\n\t\t\t\treflect.ValueOf(macService),\n\t\t\t)\n\t\t\tsubCfgValue.FieldByName(\"InvoiceRegistry\").Set(\n\t\t\t\treflect.ValueOf(invoiceRegistry),\n\t\t\t)\n\t\t\tsubCfgValue.FieldByName(\"IsChannelActive\").Set(\n\t\t\t\treflect.ValueOf(htlcSwitch.HasActiveLink),\n\t\t\t)\n\t\t\tsubCfgValue.FieldByName(\"ChainParams\").Set(\n\t\t\t\treflect.ValueOf(activeNetParams),\n\t\t\t)\n\t\t\tsubCfgValue.FieldByName(\"NodeSigner\").Set(\n\t\t\t\treflect.ValueOf(nodeSigner),\n\t\t\t)\n\t\t\tdefaultDelta := cfg.Bitcoin.TimeLockDelta\n\t\t\tif cfg.registeredChains.PrimaryChain() == chainreg.LitecoinChain {\n\t\t\t\tdefaultDelta = cfg.Litecoin.TimeLockDelta\n\t\t\t}\n\t\t\tsubCfgValue.FieldByName(\"DefaultCLTVExpiry\").Set(\n\t\t\t\treflect.ValueOf(defaultDelta),\n\t\t\t)\n\t\t\tsubCfgValue.FieldByName(\"GraphDB\").Set(\n\t\t\t\treflect.ValueOf(graphDB),\n\t\t\t)\n\t\t\tsubCfgValue.FieldByName(\"ChanStateDB\").Set(\n\t\t\t\treflect.ValueOf(chanStateDB),\n\t\t\t)\n\t\t\tsubCfgValue.FieldByName(\"GenInvoiceFeatures\").Set(\n\t\t\t\treflect.ValueOf(genInvoiceFeatures),\n\t\t\t)\n\t\t\tsubCfgValue.FieldByName(\"GenAmpInvoiceFeatures\").Set(\n\t\t\t\treflect.ValueOf(genAmpInvoiceFeatures),\n\t\t\t)\n\t\t\tsubCfgValue.FieldByName(\"GetAlias\").Set(\n\t\t\t\treflect.ValueOf(getAlias),\n\t\t\t)\n\n\t\tcase *neutrinorpc.Config:\n\t\t\tsubCfgValue := extractReflectValue(subCfg)\n\n\t\t\tsubCfgValue.FieldByName(\"NeutrinoCS\").Set(\n\t\t\t\treflect.ValueOf(cc.Cfg.NeutrinoCS),\n\t\t\t)\n\n\t\t// RouterRPC isn't conditionally compiled and doesn't need to be\n\t\t// populated using reflection.\n\t\tcase *routerrpc.Config:\n\n\t\tcase *watchtowerrpc.Config:\n\t\t\tsubCfgValue := extractReflectValue(subCfg)\n\n\t\t\tsubCfgValue.FieldByName(\"Active\").Set(\n\t\t\t\treflect.ValueOf(tower != nil),\n\t\t\t)\n\t\t\tsubCfgValue.FieldByName(\"Tower\").Set(\n\t\t\t\treflect.ValueOf(tower),\n\t\t\t)\n\n\t\tcase *wtclientrpc.Config:\n\t\t\tsubCfgValue := extractReflectValue(subCfg)\n\n\t\t\tif towerClient != nil && anchorTowerClient != nil {\n\t\t\t\tsubCfgValue.FieldByName(\"Active\").Set(\n\t\t\t\t\treflect.ValueOf(towerClient != nil),\n\t\t\t\t)\n\t\t\t\tsubCfgValue.FieldByName(\"Client\").Set(\n\t\t\t\t\treflect.ValueOf(towerClient),\n\t\t\t\t)\n\t\t\t\tsubCfgValue.FieldByName(\"AnchorClient\").Set(\n\t\t\t\t\treflect.ValueOf(anchorTowerClient),\n\t\t\t\t)\n\t\t\t}\n\t\t\tsubCfgValue.FieldByName(\"Resolver\").Set(\n\t\t\t\treflect.ValueOf(tcpResolver),\n\t\t\t)\n\t\t\tsubCfgValue.FieldByName(\"Log\").Set(\n\t\t\t\treflect.ValueOf(rpcLogger),\n\t\t\t)\n\n\t\tcase *devrpc.Config:\n\t\t\tsubCfgValue := extractReflectValue(subCfg)\n\n\t\t\tsubCfgValue.FieldByName(\"ActiveNetParams\").Set(\n\t\t\t\treflect.ValueOf(activeNetParams),\n\t\t\t)\n\n\t\t\tsubCfgValue.FieldByName(\"GraphDB\").Set(\n\t\t\t\treflect.ValueOf(graphDB),\n\t\t\t)\n\n\t\tcase *peersrpc.Config:\n\t\t\tsubCfgValue := extractReflectValue(subCfg)\n\n\t\t\tsubCfgValue.FieldByName(\"GetNodeAnnouncement\").Set(\n\t\t\t\treflect.ValueOf(getNodeAnnouncement),\n\t\t\t)\n\n\t\t\tsubCfgValue.FieldByName(\"ParseAddr\").Set(\n\t\t\t\treflect.ValueOf(parseAddr),\n\t\t\t)\n\n\t\t\tsubCfgValue.FieldByName(\"UpdateNodeAnnouncement\").Set(\n\t\t\t\treflect.ValueOf(updateNodeAnnouncement),\n\t\t\t)\n\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"unknown field: %v, %T\", fieldName,\n\t\t\t\tcfg)\n\t\t}\n\t}\n\n\t// Populate routerrpc dependencies.\n\ts.RouterRPC.NetworkDir = networkDir\n\ts.RouterRPC.MacService = macService\n\ts.RouterRPC.Router = chanRouter\n\ts.RouterRPC.RouterBackend = routerBackend\n\n\treturn nil\n}\n\n// FetchConfig attempts to locate an existing configuration file mapped to the\n// target sub-server. If we're unable to find a config file matching the\n// subServerName name, then false will be returned for the second parameter.\n//\n// NOTE: Part of the lnrpc.SubServerConfigDispatcher interface.",
      "length": 6919,
      "tokens": 458,
      "embedding": []
    },
    {
      "slug": "func (s *subRPCServerConfigs) FetchConfig(subServerName string) (interface{}, bool) {",
      "content": "func (s *subRPCServerConfigs) FetchConfig(subServerName string) (interface{}, bool) {\n\t// First, we'll use reflect to obtain a version of the config struct\n\t// that allows us to programmatically inspect its fields.\n\tselfVal := extractReflectValue(s)\n\n\t// Now that we have the value of the struct, we can check to see if it\n\t// has an attribute with the same name as the subServerName.\n\tconfigVal := selfVal.FieldByName(subServerName)\n\n\t// We'll now ensure that this field actually exists in this value. If\n\t// not, then we'll return false for the ok value to indicate to the\n\t// caller that this field doesn't actually exist.\n\tif !configVal.IsValid() {\n\t\treturn nil, false\n\t}\n\n\tconfigValElem := configVal.Elem()\n\n\t// If a config of this type is found, it doesn't have any fields, then\n\t// it's the same as if it wasn't present. This can happen if the build\n\t// tag for the sub-server is inactive.\n\tif configValElem.NumField() == 0 {\n\t\treturn nil, false\n\t}\n\n\t// At this pint, we know that the field is actually present in the\n\t// config struct, so we can return it directly.\n\treturn configVal.Interface(), true\n}\n\n// extractReflectValue attempts to extract the value from an interface using\n// the reflect package. The resulting reflect.Value allows the caller to\n// programmatically examine and manipulate the underlying value.",
      "length": 1210,
      "tokens": 204,
      "embedding": []
    },
    {
      "slug": "func extractReflectValue(instance interface{}) reflect.Value {",
      "content": "func extractReflectValue(instance interface{}) reflect.Value {\n\tvar val reflect.Value\n\n\t// If the type of the instance is a pointer, then we need to deference\n\t// the pointer one level to get its value. Otherwise, we can access the\n\t// value directly.\n\tif reflect.TypeOf(instance).Kind() == reflect.Ptr {\n\t\tval = reflect.ValueOf(instance).Elem()\n\t} else {\n\t\tval = reflect.ValueOf(instance)\n\t}\n\n\treturn val\n}\n",
      "length": 332,
      "tokens": 53,
      "embedding": []
    }
  ]
}