{
  "filepath": "../implementations/go/lnd/sweep/tx_input_set.go",
  "package": "sweep",
  "sections": [
    {
      "slug": "type addConstraints uint8",
      "content": "type addConstraints uint8\n\nconst (\n\t// constraintsRegular is for regular input sweeps that should have a positive\n\t// yield.\n\tconstraintsRegular addConstraints = iota\n\n\t// constraintsWallet is for wallet inputs that are only added to bring up the tx\n\t// output value.\n\tconstraintsWallet\n\n\t// constraintsForce is for inputs that should be swept even with a negative\n\t// yield at the set fee rate.\n\tconstraintsForce\n)\n",
      "length": 376,
      "tokens": 61,
      "embedding": []
    },
    {
      "slug": "type txInputSetState struct {",
      "content": "type txInputSetState struct {\n\t// feeRate is the fee rate to use for the sweep transaction.\n\tfeeRate chainfee.SatPerKWeight\n\n\t// inputTotal is the total value of all inputs.\n\tinputTotal btcutil.Amount\n\n\t// requiredOutput is the sum of the outputs committed to by the inputs.\n\trequiredOutput btcutil.Amount\n\n\t// changeOutput is the value of the change output. This will be what is\n\t// left over after subtracting the requiredOutput and the tx fee from\n\t// the inputTotal.\n\t//\n\t// NOTE: This might be below the dust limit, or even negative since it\n\t// is the change remaining in csse we pay the fee for a change output.\n\tchangeOutput btcutil.Amount\n\n\t// inputs is the set of tx inputs.\n\tinputs []input.Input\n\n\t// walletInputTotal is the total value of inputs coming from the wallet.\n\twalletInputTotal btcutil.Amount\n\n\t// force indicates that this set must be swept even if the total yield\n\t// is negative.\n\tforce bool\n}\n\n// weightEstimate is the (worst case) tx weight with the current set of\n// inputs. It takes a parameter whether to add a change output or not.",
      "length": 1003,
      "tokens": 172,
      "embedding": []
    },
    {
      "slug": "func (t *txInputSetState) weightEstimate(change bool) *weightEstimator {",
      "content": "func (t *txInputSetState) weightEstimate(change bool) *weightEstimator {\n\tweightEstimate := newWeightEstimator(t.feeRate)\n\tfor _, i := range t.inputs {\n\t\t// Can ignore error, because it has already been checked when\n\t\t// calculating the yields.\n\t\t_ = weightEstimate.add(i)\n\n\t\tr := i.RequiredTxOut()\n\t\tif r != nil {\n\t\t\tweightEstimate.addOutput(r)\n\t\t}\n\t}\n\n\t// Add a change output to the weight estimate if requested.\n\tif change {\n\t\tweightEstimate.addP2WKHOutput()\n\t}\n\n\treturn weightEstimate\n}\n\n// totalOutput is the total amount left for us after paying fees.\n//\n// NOTE: This might be dust.",
      "length": 494,
      "tokens": 77,
      "embedding": []
    },
    {
      "slug": "func (t *txInputSetState) totalOutput() btcutil.Amount {",
      "content": "func (t *txInputSetState) totalOutput() btcutil.Amount {\n\treturn t.requiredOutput + t.changeOutput\n}\n",
      "length": 42,
      "tokens": 5,
      "embedding": []
    },
    {
      "slug": "func (t *txInputSetState) clone() txInputSetState {",
      "content": "func (t *txInputSetState) clone() txInputSetState {\n\ts := txInputSetState{\n\t\tfeeRate:          t.feeRate,\n\t\tinputTotal:       t.inputTotal,\n\t\tchangeOutput:     t.changeOutput,\n\t\trequiredOutput:   t.requiredOutput,\n\t\twalletInputTotal: t.walletInputTotal,\n\t\tforce:            t.force,\n\t\tinputs:           make([]input.Input, len(t.inputs)),\n\t}\n\tcopy(s.inputs, t.inputs)\n\n\treturn s\n}\n\n// txInputSet is an object that accumulates tx inputs and keeps running counters\n// on various properties of the tx.",
      "length": 431,
      "tokens": 44,
      "embedding": []
    },
    {
      "slug": "type txInputSet struct {",
      "content": "type txInputSet struct {\n\ttxInputSetState\n\n\t// maxInputs is the maximum number of inputs that will be accepted in\n\t// the set.\n\tmaxInputs int\n\n\t// wallet contains wallet functionality required by the input set to\n\t// retrieve utxos.\n\twallet Wallet\n}\n\n// newTxInputSet constructs a new, empty input set.",
      "length": 266,
      "tokens": 44,
      "embedding": []
    },
    {
      "slug": "func newTxInputSet(wallet Wallet, feePerKW chainfee.SatPerKWeight,",
      "content": "func newTxInputSet(wallet Wallet, feePerKW chainfee.SatPerKWeight,\n\tmaxInputs int) *txInputSet {\n\n\tstate := txInputSetState{\n\t\tfeeRate: feePerKW,\n\t}\n\n\tb := txInputSet{\n\t\tmaxInputs:       maxInputs,\n\t\twallet:          wallet,\n\t\ttxInputSetState: state,\n\t}\n\n\treturn &b\n}\n\n// enoughInput returns true if we've accumulated enough inputs to pay the fees\n// and have at least one output that meets the dust limit.",
      "length": 323,
      "tokens": 48,
      "embedding": []
    },
    {
      "slug": "func (t *txInputSet) enoughInput() bool {",
      "content": "func (t *txInputSet) enoughInput() bool {\n\t// If we have a change output above dust, then we certainly have enough\n\t// inputs to the transaction.\n\tif t.changeOutput >= lnwallet.DustLimitForSize(input.P2TRSize) {\n\t\treturn true\n\t}\n\n\t// We did not have enough input for a change output. Check if we have\n\t// enough input to pay the fees for a transaction with no change\n\t// output.\n\tfee := t.weightEstimate(false).fee()\n\tif t.inputTotal < t.requiredOutput+fee {\n\t\treturn false\n\t}\n\n\t// We could pay the fees, but we still need at least one output to be\n\t// above the dust limit for the tx to be valid (we assume that these\n\t// required outputs only get added if they are above dust)\n\tfor _, inp := range t.inputs {\n\t\tif inp.RequiredTxOut() != nil {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// add adds a new input to the set. It returns a bool indicating whether the\n// input was added to the set. An input is rejected if it decreases the tx\n// output value after paying fees.",
      "length": 901,
      "tokens": 167,
      "embedding": []
    },
    {
      "slug": "func (t *txInputSet) addToState(inp input.Input, constraints addConstraints) *txInputSetState {",
      "content": "func (t *txInputSet) addToState(inp input.Input, constraints addConstraints) *txInputSetState {\n\t// Stop if max inputs is reached. Do not count additional wallet inputs,\n\t// because we don't know in advance how many we may need.\n\tif constraints != constraintsWallet &&\n\t\tlen(t.inputs) >= t.maxInputs {\n\n\t\treturn nil\n\t}\n\n\t// If the input comes with a required tx out that is below dust, we\n\t// won't add it.\n\treqOut := inp.RequiredTxOut()\n\tif reqOut != nil {\n\t\t// Fetch the dust limit for this output.\n\t\tdustLimit := lnwallet.DustLimitForSize(len(reqOut.PkScript))\n\t\tif btcutil.Amount(reqOut.Value) < dustLimit {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// Clone the current set state.\n\ts := t.clone()\n\n\t// Add the new input.\n\ts.inputs = append(s.inputs, inp)\n\n\t// Add the value of the new input.\n\tvalue := btcutil.Amount(inp.SignDesc().Output.Value)\n\ts.inputTotal += value\n\n\t// Recalculate the tx fee.\n\tfee := s.weightEstimate(true).fee()\n\n\t// Calculate the new output value.\n\tif reqOut != nil {\n\t\ts.requiredOutput += btcutil.Amount(reqOut.Value)\n\t}\n\ts.changeOutput = s.inputTotal - s.requiredOutput - fee\n\n\t// Calculate the yield of this input from the change in total tx output\n\t// value.\n\tinputYield := s.totalOutput() - t.totalOutput()\n\n\tswitch constraints {\n\t// Don't sweep inputs that cost us more to sweep than they give us.\n\tcase constraintsRegular:\n\t\tif inputYield <= 0 {\n\t\t\treturn nil\n\t\t}\n\n\t// For force adds, no further constraints apply.\n\tcase constraintsForce:\n\t\ts.force = true\n\n\t// We are attaching a wallet input to raise the tx output value above\n\t// the dust limit.\n\tcase constraintsWallet:\n\t\t// Skip this wallet input if adding it would lower the output\n\t\t// value.\n\t\tif inputYield <= 0 {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Calculate the total value that we spend in this tx from the\n\t\t// wallet if we'd add this wallet input.\n\t\ts.walletInputTotal += value\n\n\t\t// In any case, we don't want to lose money by sweeping. If we\n\t\t// don't get more out of the tx then we put in ourselves, do not\n\t\t// add this wallet input. If there is at least one force sweep\n\t\t// in the set, this does no longer apply.\n\t\t//\n\t\t// We should only add wallet inputs to get the tx output value\n\t\t// above the dust limit, otherwise we'd only burn into fees.\n\t\t// This is guarded by tryAddWalletInputsIfNeeded.\n\t\t//\n\t\t// TODO(joostjager): Possibly require a max ratio between the\n\t\t// value of the wallet input and what we get out of this\n\t\t// transaction. To prevent attaching and locking a big utxo for\n\t\t// very little benefit.\n\t\tif !s.force && s.walletInputTotal >= s.totalOutput() {\n\t\t\tlog.Debugf(\"Rejecting wallet input of %v, because it \"+\n\t\t\t\t\"would make a negative yielding transaction \"+\n\t\t\t\t\"(%v)\",\n\t\t\t\tvalue, s.totalOutput()-s.walletInputTotal)\n\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn &s\n}\n\n// add adds a new input to the set. It returns a bool indicating whether the\n// input was added to the set. An input is rejected if it decreases the tx\n// output value after paying fees.",
      "length": 2752,
      "tokens": 463,
      "embedding": []
    },
    {
      "slug": "func (t *txInputSet) add(input input.Input, constraints addConstraints) bool {",
      "content": "func (t *txInputSet) add(input input.Input, constraints addConstraints) bool {\n\tnewState := t.addToState(input, constraints)\n\tif newState == nil {\n\t\treturn false\n\t}\n\n\tt.txInputSetState = *newState\n\n\treturn true\n}\n\n// addPositiveYieldInputs adds sweepableInputs that have a positive yield to the\n// input set. This function assumes that the list of inputs is sorted descending\n// by yield.\n//\n// TODO(roasbeef): Consider including some negative yield inputs too to clean\n// up the utxo set even if it costs us some fees up front.  In the spirit of\n// minimizing any negative externalities we cause for the Bitcoin system as a\n// whole.",
      "length": 538,
      "tokens": 91,
      "embedding": []
    },
    {
      "slug": "func (t *txInputSet) addPositiveYieldInputs(sweepableInputs []txInput) {",
      "content": "func (t *txInputSet) addPositiveYieldInputs(sweepableInputs []txInput) {\n\tfor i, inp := range sweepableInputs {\n\t\t// Apply relaxed constraints for force sweeps.\n\t\tconstraints := constraintsRegular\n\t\tif inp.parameters().Force {\n\t\t\tconstraints = constraintsForce\n\t\t}\n\n\t\t// Try to add the input to the transaction. If that doesn't\n\t\t// succeed because it wouldn't increase the output value,\n\t\t// return. Assuming inputs are sorted by yield, any further\n\t\t// inputs wouldn't increase the output value either.\n\t\tif !t.add(inp, constraints) {\n\t\t\tvar rem []input.Input\n\t\t\tfor j := i; j < len(sweepableInputs); j++ {\n\t\t\t\trem = append(rem, sweepableInputs[j])\n\t\t\t}\n\t\t\tlog.Debugf(\"%d negative yield inputs not added to \"+\n\t\t\t\t\"input set: %v\", len(rem),\n\t\t\t\tinputTypeSummary(rem))\n\t\t\treturn\n\t\t}\n\n\t\tlog.Debugf(\"Added positive yield input %v to input set\",\n\t\t\tinputTypeSummary([]input.Input{inp}))\n\t}\n\n\t// We managed to add all inputs to the set.\n}\n\n// tryAddWalletInputsIfNeeded retrieves utxos from the wallet and tries adding\n// as many as required to bring the tx output value above the given minimum.",
      "length": 989,
      "tokens": 145,
      "embedding": []
    },
    {
      "slug": "func (t *txInputSet) tryAddWalletInputsIfNeeded() error {",
      "content": "func (t *txInputSet) tryAddWalletInputsIfNeeded() error {\n\t// If we've already have enough to pay the transaction fees and have at\n\t// least one output materialize, no action is needed.\n\tif t.enoughInput() {\n\t\treturn nil\n\t}\n\n\t// Retrieve wallet utxos. Only consider confirmed utxos to prevent\n\t// problems around RBF rules for unconfirmed inputs. This currently\n\t// ignores the configured coin selection strategy.\n\tutxos, err := t.wallet.ListUnspentWitnessFromDefaultAccount(\n\t\t1, math.MaxInt32,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, utxo := range utxos {\n\t\tinput, err := createWalletTxInput(utxo)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// If the wallet input isn't positively-yielding at this fee\n\t\t// rate, skip it.\n\t\tif !t.add(input, constraintsWallet) {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Return if we've reached the minimum output amount.\n\t\tif t.enoughInput() {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// We were not able to reach the minimum output amount.\n\treturn nil\n}\n\n// createWalletTxInput converts a wallet utxo into an object that can be added\n// to the other inputs to sweep.",
      "length": 969,
      "tokens": 160,
      "embedding": []
    },
    {
      "slug": "func createWalletTxInput(utxo *lnwallet.Utxo) (input.Input, error) {",
      "content": "func createWalletTxInput(utxo *lnwallet.Utxo) (input.Input, error) {\n\tsignDesc := &input.SignDescriptor{\n\t\tOutput: &wire.TxOut{\n\t\t\tPkScript: utxo.PkScript,\n\t\t\tValue:    int64(utxo.Value),\n\t\t},\n\t\tHashType: txscript.SigHashAll,\n\t}\n\n\tvar witnessType input.WitnessType\n\tswitch utxo.AddressType {\n\tcase lnwallet.WitnessPubKey:\n\t\twitnessType = input.WitnessKeyHash\n\tcase lnwallet.NestedWitnessPubKey:\n\t\twitnessType = input.NestedWitnessKeyHash\n\tcase lnwallet.TaprootPubkey:\n\t\twitnessType = input.TaprootPubKeySpend\n\t\tsignDesc.HashType = txscript.SigHashDefault\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unknown address type %v\",\n\t\t\tutxo.AddressType)\n\t}\n\n\t// A height hint doesn't need to be set, because we don't monitor these\n\t// inputs for spend.\n\theightHint := uint32(0)\n\n\treturn input.NewBaseInput(\n\t\t&utxo.OutPoint, witnessType, signDesc, heightHint,\n\t), nil\n}\n",
      "length": 755,
      "tokens": 76,
      "embedding": []
    }
  ]
}