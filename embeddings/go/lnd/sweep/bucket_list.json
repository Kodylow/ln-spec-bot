{
  "filepath": "../implementations/go/lnd/sweep/bucket_list.go",
  "package": "sweep",
  "sections": [
    {
      "slug": "type bucket pendingInputs",
      "content": "type bucket pendingInputs\n\n// tryAdd tries to add a new input to this bucket.",
      "length": 50,
      "tokens": 11,
      "embedding": []
    },
    {
      "slug": "func (b bucket) tryAdd(input *pendingInput) bool {",
      "content": "func (b bucket) tryAdd(input *pendingInput) bool {\n\texclusiveGroup := input.params.ExclusiveGroup\n\tif exclusiveGroup != nil {\n\t\tfor _, input := range b {\n\t\t\texistingGroup := input.params.ExclusiveGroup\n\n\t\t\t// Don't add an exclusive group input if other inputs\n\t\t\t// are non-exclusive. The exclusive group input may be\n\t\t\t// invalid (for example in the case of commitment\n\t\t\t// anchors) and could thereby block sweeping of the\n\t\t\t// other inputs.\n\t\t\tif existingGroup == nil {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\t// Don't combine inputs from the same exclusive group.\n\t\t\t// Because only one input is valid, this may result in\n\t\t\t// txes that are always invalid.\n\t\t\tif *existingGroup == *exclusiveGroup {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\n\tb[*input.OutPoint()] = input\n\n\treturn true\n}\n\n// bucketList is a list of buckets that contain non-mutually exclusive inputs.",
      "length": 768,
      "tokens": 120,
      "embedding": []
    },
    {
      "slug": "type bucketList struct {",
      "content": "type bucketList struct {\n\tbuckets []bucket\n}\n\n// add adds a new input. If the input is not accepted by any of the existing\n// buckets, a new bucket will be created.",
      "length": 135,
      "tokens": 28,
      "embedding": []
    },
    {
      "slug": "func (b *bucketList) add(input *pendingInput) {",
      "content": "func (b *bucketList) add(input *pendingInput) {\n\tfor _, existingBucket := range b.buckets {\n\t\tif existingBucket.tryAdd(input) {\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Create a new bucket and add the input. It is not necessary to check\n\t// the return value of tryAdd because it will always succeed on an empty\n\t// bucket.\n\tnewBucket := make(bucket)\n\tnewBucket.tryAdd(input)\n\tb.buckets = append(b.buckets, newBucket)\n}\n",
      "length": 339,
      "tokens": 53,
      "embedding": []
    }
  ]
}