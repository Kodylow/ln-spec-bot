{
  "filepath": "../implementations/go/lnd/sweep/sweeper_test.go",
  "package": "sweep",
  "sections": [
    {
      "slug": "type sweeperTestContext struct {",
      "content": "type sweeperTestContext struct {\n\tt *testing.T\n\n\tsweeper   *UtxoSweeper\n\tnotifier  *MockNotifier\n\testimator *mockFeeEstimator\n\tbackend   *mockBackend\n\tstore     *MockSweeperStore\n\n\ttimeoutChan chan chan time.Time\n\tpublishChan chan wire.MsgTx\n}\n\nvar (\n\tspendableInputs []*input.BaseInput\n\ttestInputCount  int\n\n\ttestPubKey, _ = btcec.ParsePubKey([]byte{\n\t\t0x04, 0x11, 0xdb, 0x93, 0xe1, 0xdc, 0xdb, 0x8a,\n\t\t0x01, 0x6b, 0x49, 0x84, 0x0f, 0x8c, 0x53, 0xbc, 0x1e,\n\t\t0xb6, 0x8a, 0x38, 0x2e, 0x97, 0xb1, 0x48, 0x2e, 0xca,\n\t\t0xd7, 0xb1, 0x48, 0xa6, 0x90, 0x9a, 0x5c, 0xb2, 0xe0,\n\t\t0xea, 0xdd, 0xfb, 0x84, 0xcc, 0xf9, 0x74, 0x44, 0x64,\n\t\t0xf8, 0x2e, 0x16, 0x0b, 0xfa, 0x9b, 0x8b, 0x64, 0xf9,\n\t\t0xd4, 0xc0, 0x3f, 0x99, 0x9b, 0x86, 0x43, 0xf6, 0x56,\n\t\t0xb4, 0x12, 0xa3,\n\t})\n)\n",
      "length": 704,
      "tokens": 97,
      "embedding": []
    },
    {
      "slug": "func createTestInput(value int64, witnessType input.WitnessType) input.BaseInput {",
      "content": "func createTestInput(value int64, witnessType input.WitnessType) input.BaseInput {\n\thash := chainhash.Hash{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\tbyte(testInputCount + 1)}\n\n\tinput := input.MakeBaseInput(\n\t\t&wire.OutPoint{\n\t\t\tHash: hash,\n\t\t},\n\t\twitnessType,\n\t\t&input.SignDescriptor{\n\t\t\tOutput: &wire.TxOut{\n\t\t\t\tValue: value,\n\t\t\t},\n\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\tPubKey: testPubKey,\n\t\t\t},\n\t\t},\n\t\t0,\n\t\tnil,\n\t)\n\n\ttestInputCount++\n\n\treturn input\n}\n",
      "length": 402,
      "tokens": 63,
      "embedding": []
    },
    {
      "slug": "func init() {",
      "content": "func init() {\n\t// Create a set of test spendable inputs.\n\tfor i := 0; i < 20; i++ {\n\t\tinput := createTestInput(int64(10000+i*500),\n\t\t\tinput.CommitmentTimeLock)\n\n\t\tspendableInputs = append(spendableInputs, &input)\n\t}\n}\n",
      "length": 196,
      "tokens": 27,
      "embedding": []
    },
    {
      "slug": "func createSweeperTestContext(t *testing.T) *sweeperTestContext {",
      "content": "func createSweeperTestContext(t *testing.T) *sweeperTestContext {\n\tnotifier := NewMockNotifier(t)\n\n\tstore := NewMockSweeperStore()\n\n\tbackend := newMockBackend(t, notifier)\n\tbackend.walletUtxos = []*lnwallet.Utxo{\n\t\t{\n\t\t\tValue:       btcutil.Amount(1_000_000),\n\t\t\tAddressType: lnwallet.WitnessPubKey,\n\t\t},\n\t}\n\n\testimator := newMockFeeEstimator(10000, chainfee.FeePerKwFloor)\n\n\tctx := &sweeperTestContext{\n\t\tnotifier:    notifier,\n\t\tpublishChan: backend.publishChan,\n\t\tt:           t,\n\t\testimator:   estimator,\n\t\tbackend:     backend,\n\t\tstore:       store,\n\t\ttimeoutChan: make(chan chan time.Time, 1),\n\t}\n\n\tctx.sweeper = New(&UtxoSweeperConfig{\n\t\tNotifier: notifier,\n\t\tWallet:   backend,\n\t\tNewBatchTimer: func() <-chan time.Time {\n\t\t\tc := make(chan time.Time, 1)\n\t\t\tctx.timeoutChan <- c\n\t\t\treturn c\n\t\t},\n\t\tStore:  store,\n\t\tSigner: &mock.DummySigner{},\n\t\tGenSweepScript: func() ([]byte, error) {\n\t\t\tscript := make([]byte, input.P2WPKHSize)\n\t\t\tscript[0] = 0\n\t\t\tscript[1] = 20\n\t\t\treturn script, nil\n\t\t},\n\t\tFeeEstimator:     estimator,\n\t\tMaxInputsPerTx:   testMaxInputsPerTx,\n\t\tMaxSweepAttempts: testMaxSweepAttempts,\n\t\tNextAttemptDeltaFunc: func(attempts int) int32 {\n\t\t\t// Use delta func without random factor.\n\t\t\treturn 1 << uint(attempts-1)\n\t\t},\n\t\tMaxFeeRate:        DefaultMaxFeeRate,\n\t\tFeeRateBucketSize: DefaultFeeRateBucketSize,\n\t})\n\n\tctx.sweeper.Start()\n\n\treturn ctx\n}\n",
      "length": 1251,
      "tokens": 123,
      "embedding": []
    },
    {
      "slug": "func (ctx *sweeperTestContext) restartSweeper() {",
      "content": "func (ctx *sweeperTestContext) restartSweeper() {\n\tctx.t.Helper()\n\n\tctx.sweeper.Stop()\n\tctx.sweeper = New(ctx.sweeper.cfg)\n\tctx.sweeper.Start()\n}\n",
      "length": 90,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "func (ctx *sweeperTestContext) tick() {",
      "content": "func (ctx *sweeperTestContext) tick() {\n\ttestLog.Trace(\"Waiting for tick to be consumed\")\n\tselect {\n\tcase c := <-ctx.timeoutChan:\n\t\tselect {\n\t\tcase c <- time.Time{}:\n\t\t\ttestLog.Trace(\"Tick\")\n\t\tcase <-time.After(defaultTestTimeout):\n\t\t\tdebug.PrintStack()\n\t\t\tctx.t.Fatal(\"tick timeout - tick not consumed\")\n\t\t}\n\tcase <-time.After(defaultTestTimeout):\n\t\tdebug.PrintStack()\n\t\tctx.t.Fatal(\"tick timeout - no new timer created\")\n\t}\n}\n\n// assertNoTick asserts that the sweeper does not wait for a tick.",
      "length": 439,
      "tokens": 53,
      "embedding": []
    },
    {
      "slug": "func (ctx *sweeperTestContext) assertNoTick() {",
      "content": "func (ctx *sweeperTestContext) assertNoTick() {\n\tctx.t.Helper()\n\n\tselect {\n\tcase <-ctx.timeoutChan:\n\t\tctx.t.Fatal(\"unexpected tick\")\n\n\tcase <-time.After(processingDelay):\n\t}\n}\n",
      "length": 119,
      "tokens": 11,
      "embedding": []
    },
    {
      "slug": "func (ctx *sweeperTestContext) assertNoNewTimer() {",
      "content": "func (ctx *sweeperTestContext) assertNoNewTimer() {\n\tselect {\n\tcase <-ctx.timeoutChan:\n\t\tctx.t.Fatal(\"no new timer expected\")\n\tdefault:\n\t}\n}\n",
      "length": 83,
      "tokens": 11,
      "embedding": []
    },
    {
      "slug": "func (ctx *sweeperTestContext) finish(expectedGoroutineCount int) {",
      "content": "func (ctx *sweeperTestContext) finish(expectedGoroutineCount int) {\n\t// We assume that when finish is called, sweeper has finished all its\n\t// goroutines. This implies that the waitgroup is empty.\n\tsignalChan := make(chan struct{})\n\tgo func() {\n\t\tctx.sweeper.wg.Wait()\n\t\tclose(signalChan)\n\t}()\n\n\t// Simulate exits of the expected number of running goroutines.\n\tfor i := 0; i < expectedGoroutineCount; i++ {\n\t\tctx.sweeper.wg.Done()\n\t}\n\n\t// We now expect the Wait to succeed.\n\tselect {\n\tcase <-signalChan:\n\tcase <-time.After(time.Second):\n\t\tpprof.Lookup(\"goroutine\").WriteTo(os.Stdout, 1)\n\n\t\tctx.t.Fatalf(\"lingering goroutines detected after test \" +\n\t\t\t\"is finished\")\n\t}\n\n\t// Restore waitgroup state to what it was before.\n\tctx.sweeper.wg.Add(expectedGoroutineCount)\n\n\t// Stop sweeper.\n\tctx.sweeper.Stop()\n\n\t// We should have consumed and asserted all published transactions in\n\t// our unit tests.\n\tctx.assertNoTx()\n\tctx.assertNoNewTimer()\n\tif !ctx.backend.isDone() {\n\t\tctx.t.Fatal(\"unconfirmed txes remaining\")\n\t}\n}\n",
      "length": 911,
      "tokens": 118,
      "embedding": []
    },
    {
      "slug": "func (ctx *sweeperTestContext) assertNoTx() {",
      "content": "func (ctx *sweeperTestContext) assertNoTx() {\n\tctx.t.Helper()\n\tselect {\n\tcase <-ctx.publishChan:\n\t\tctx.t.Fatalf(\"unexpected transactions published\")\n\tdefault:\n\t}\n}\n",
      "length": 111,
      "tokens": 11,
      "embedding": []
    },
    {
      "slug": "func (ctx *sweeperTestContext) receiveTx() wire.MsgTx {",
      "content": "func (ctx *sweeperTestContext) receiveTx() wire.MsgTx {\n\tctx.t.Helper()\n\tvar tx wire.MsgTx\n\tselect {\n\tcase tx = <-ctx.publishChan:\n\t\treturn tx\n\tcase <-time.After(5 * time.Second):\n\t\tpprof.Lookup(\"goroutine\").WriteTo(os.Stdout, 1)\n\n\t\tctx.t.Fatalf(\"tx not published\")\n\t}\n\treturn tx\n}\n",
      "length": 214,
      "tokens": 25,
      "embedding": []
    },
    {
      "slug": "func (ctx *sweeperTestContext) expectResult(c chan Result, expected error) {",
      "content": "func (ctx *sweeperTestContext) expectResult(c chan Result, expected error) {\n\tctx.t.Helper()\n\tselect {\n\tcase result := <-c:\n\t\tif result.Err != expected {\n\t\t\tctx.t.Fatalf(\"expected %v result, but got %v\",\n\t\t\t\texpected, result.Err,\n\t\t\t)\n\t\t}\n\tcase <-time.After(defaultTestTimeout):\n\t\tctx.t.Fatalf(\"no result received\")\n\t}\n}\n",
      "length": 232,
      "tokens": 29,
      "embedding": []
    },
    {
      "slug": "func (ctx *sweeperTestContext) assertPendingInputs(inputs ...input.Input) {",
      "content": "func (ctx *sweeperTestContext) assertPendingInputs(inputs ...input.Input) {\n\tctx.t.Helper()\n\n\tinputSet := make(map[wire.OutPoint]struct{}, len(inputs))\n\tfor _, input := range inputs {\n\t\tinputSet[*input.OutPoint()] = struct{}{}\n\t}\n\n\tpendingInputs, err := ctx.sweeper.PendingInputs()\n\tif err != nil {\n\t\tctx.t.Fatal(err)\n\t}\n\tif len(pendingInputs) != len(inputSet) {\n\t\tctx.t.Fatalf(\"expected %d pending inputs, got %d\",\n\t\t\tlen(inputSet), len(pendingInputs))\n\t}\n\tfor input := range pendingInputs {\n\t\tif _, ok := inputSet[input]; !ok {\n\t\t\tctx.t.Fatalf(\"found unexpected input %v\", input)\n\t\t}\n\t}\n}\n\n// assertTxSweepsInputs ensures that the transaction returned within the value\n// received from resultChan spends the given inputs.",
      "length": 624,
      "tokens": 80,
      "embedding": []
    },
    {
      "slug": "func assertTxSweepsInputs(t *testing.T, sweepTx *wire.MsgTx,",
      "content": "func assertTxSweepsInputs(t *testing.T, sweepTx *wire.MsgTx,\n\tinputs ...input.Input) {\n\n\tt.Helper()\n\n\tif len(sweepTx.TxIn) != len(inputs) {\n\t\tt.Fatalf(\"expected sweep tx to contain %d inputs, got %d\",\n\t\t\tlen(inputs), len(sweepTx.TxIn))\n\t}\n\tm := make(map[wire.OutPoint]struct{}, len(inputs))\n\tfor _, input := range inputs {\n\t\tm[*input.OutPoint()] = struct{}{}\n\t}\n\tfor _, txIn := range sweepTx.TxIn {\n\t\tif _, ok := m[txIn.PreviousOutPoint]; !ok {\n\t\t\tt.Fatalf(\"expected tx %v to spend input %v\",\n\t\t\t\ttxIn.PreviousOutPoint, sweepTx.TxHash())\n\t\t}\n\t}\n}\n\n// assertTxFeeRate asserts that the transaction was created with the given\n// inputs and fee rate.\n//\n// NOTE: This assumes that transactions only have one output, as this is the\n// only type of transaction the UtxoSweeper can create at the moment.",
      "length": 711,
      "tokens": 105,
      "embedding": []
    },
    {
      "slug": "func assertTxFeeRate(t *testing.T, tx *wire.MsgTx,",
      "content": "func assertTxFeeRate(t *testing.T, tx *wire.MsgTx,\n\texpectedFeeRate chainfee.SatPerKWeight, changePk []byte,\n\tinputs ...input.Input) {\n\n\tt.Helper()\n\n\tif len(tx.TxIn) != len(inputs) {\n\t\tt.Fatalf(\"expected %d inputs, got %d\", len(tx.TxIn), len(inputs))\n\t}\n\n\tm := make(map[wire.OutPoint]input.Input, len(inputs))\n\tfor _, input := range inputs {\n\t\tm[*input.OutPoint()] = input\n\t}\n\n\tvar inputAmt int64\n\tfor _, txIn := range tx.TxIn {\n\t\tinput, ok := m[txIn.PreviousOutPoint]\n\t\tif !ok {\n\t\t\tt.Fatalf(\"expected input %v to be provided\",\n\t\t\t\ttxIn.PreviousOutPoint)\n\t\t}\n\t\tinputAmt += input.SignDesc().Output.Value\n\t}\n\toutputAmt := tx.TxOut[0].Value\n\n\tfee := btcutil.Amount(inputAmt - outputAmt)\n\t_, estimator, err := getWeightEstimate(inputs, nil, 0, changePk)\n\trequire.NoError(t, err)\n\n\ttxWeight := estimator.weight()\n\n\texpectedFee := expectedFeeRate.FeeForWeight(int64(txWeight))\n\tif fee != expectedFee {\n\t\tt.Fatalf(\"expected fee rate %v results in %v fee, got %v fee\",\n\t\t\texpectedFeeRate, expectedFee, fee)\n\t}\n}\n\n// TestSuccess tests the sweeper happy flow.",
      "length": 960,
      "tokens": 117,
      "embedding": []
    },
    {
      "slug": "func TestSuccess(t *testing.T) {",
      "content": "func TestSuccess(t *testing.T) {\n\tctx := createSweeperTestContext(t)\n\n\t// Sweeping an input without a fee preference should result in an error.\n\t_, err := ctx.sweeper.SweepInput(spendableInputs[0], Params{})\n\tif err != ErrNoFeePreference {\n\t\tt.Fatalf(\"expected ErrNoFeePreference, got %v\", err)\n\t}\n\n\tresultChan, err := ctx.sweeper.SweepInput(\n\t\tspendableInputs[0], defaultFeePref,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tctx.tick()\n\n\tsweepTx := ctx.receiveTx()\n\n\tctx.backend.mine()\n\n\tselect {\n\tcase result := <-resultChan:\n\t\tif result.Err != nil {\n\t\t\tt.Fatalf(\"expected successful spend, but received \"+\n\t\t\t\t\"error %v instead\", result.Err)\n\t\t}\n\t\tif result.Tx.TxHash() != sweepTx.TxHash() {\n\t\t\tt.Fatalf(\"expected sweep tx \")\n\t\t}\n\tcase <-time.After(5 * time.Second):\n\t\tt.Fatalf(\"no result received\")\n\t}\n\n\tctx.finish(1)\n\n\t// Assert that last tx is stored in the database so we can republish\n\t// on restart.\n\tlastTx, err := ctx.store.GetLastPublishedTx()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif lastTx == nil || sweepTx.TxHash() != lastTx.TxHash() {\n\t\tt.Fatalf(\"last tx not stored\")\n\t}\n}\n\n// TestDust asserts that inputs that are not big enough to raise above the dust\n// limit, are held back until the total set does surpass the limit.",
      "length": 1150,
      "tokens": 163,
      "embedding": []
    },
    {
      "slug": "func TestDust(t *testing.T) {",
      "content": "func TestDust(t *testing.T) {\n\tctx := createSweeperTestContext(t)\n\n\t// Sweeping a single output produces a tx of 486 weight units. With the\n\t// test fee rate, the sweep tx will pay 4860 sat in fees.\n\t//\n\t// Create an input so that the output after paying fees is still\n\t// positive (400 sat), but less than the dust limit (537 sat) for the\n\t// sweep tx output script (P2WPKH).\n\tdustInput := createTestInput(5260, input.CommitmentTimeLock)\n\n\t_, err := ctx.sweeper.SweepInput(&dustInput, defaultFeePref)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// No sweep transaction is expected now. The sweeper should recognize\n\t// that the sweep output will not be relayed and not generate the tx. It\n\t// isn't possible to attach a wallet utxo either, because the added\n\t// weight would create a negatively yielding transaction at this fee\n\t// rate.\n\n\t// Sweep another input that brings the tx output above the dust limit.\n\tlargeInput := createTestInput(100000, input.CommitmentTimeLock)\n\n\t_, err = ctx.sweeper.SweepInput(&largeInput, defaultFeePref)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tctx.tick()\n\n\t// The second input brings the sweep output above the dust limit. We\n\t// expect a sweep tx now.\n\n\tsweepTx := ctx.receiveTx()\n\tif len(sweepTx.TxIn) != 2 {\n\t\tt.Fatalf(\"Expected tx to sweep 2 inputs, but contains %v \"+\n\t\t\t\"inputs instead\", len(sweepTx.TxIn))\n\t}\n\n\tctx.backend.mine()\n\n\tctx.finish(1)\n}\n\n// TestWalletUtxo asserts that inputs that are not big enough to raise above the\n// dust limit are accompanied by a wallet utxo to make them sweepable.",
      "length": 1457,
      "tokens": 232,
      "embedding": []
    },
    {
      "slug": "func TestWalletUtxo(t *testing.T) {",
      "content": "func TestWalletUtxo(t *testing.T) {\n\tctx := createSweeperTestContext(t)\n\n\t// Sweeping a single output produces a tx of 439 weight units. At the\n\t// fee floor, the sweep tx will pay 439*253/1000 = 111 sat in fees.\n\t//\n\t// Create an input so that the output after paying fees is still\n\t// positive (183 sat), but less than the dust limit (537 sat) for the\n\t// sweep tx output script (P2WPKH).\n\t//\n\t// What we now expect is that the sweeper will attach a utxo from the\n\t// wallet. This increases the tx weight to 712 units with a fee of 180\n\t// sats. The tx yield becomes then 294-180 = 114 sats.\n\tdustInput := createTestInput(294, input.WitnessKeyHash)\n\n\t_, err := ctx.sweeper.SweepInput(\n\t\t&dustInput,\n\t\tParams{Fee: FeePreference{FeeRate: chainfee.FeePerKwFloor}},\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tctx.tick()\n\n\tsweepTx := ctx.receiveTx()\n\tif len(sweepTx.TxIn) != 2 {\n\t\tt.Fatalf(\"Expected tx to sweep 2 inputs, but contains %v \"+\n\t\t\t\"inputs instead\", len(sweepTx.TxIn))\n\t}\n\n\t// Calculate expected output value based on wallet utxo of 1_000_000\n\t// sats.\n\texpectedOutputValue := int64(294 + 1_000_000 - 180)\n\tif sweepTx.TxOut[0].Value != expectedOutputValue {\n\t\tt.Fatalf(\"Expected output value of %v, but got %v\",\n\t\t\texpectedOutputValue, sweepTx.TxOut[0].Value)\n\t}\n\n\tctx.backend.mine()\n\tctx.finish(1)\n}\n\n// TestNegativeInput asserts that no inputs with a negative yield are swept.\n// Negative yield means that the value minus the added fee is negative.",
      "length": 1377,
      "tokens": 214,
      "embedding": []
    },
    {
      "slug": "func TestNegativeInput(t *testing.T) {",
      "content": "func TestNegativeInput(t *testing.T) {\n\tctx := createSweeperTestContext(t)\n\n\t// Sweep an input large enough to cover fees, so in any case the tx\n\t// output will be above the dust limit.\n\tlargeInput := createTestInput(100000, input.CommitmentNoDelay)\n\tlargeInputResult, err := ctx.sweeper.SweepInput(\n\t\t&largeInput, defaultFeePref,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Sweep an additional input with a negative net yield. The weight of\n\t// the HtlcAcceptedRemoteSuccess input type adds more in fees than its\n\t// value at the current fee level.\n\tnegInput := createTestInput(2900, input.HtlcOfferedRemoteTimeout)\n\tnegInputResult, err := ctx.sweeper.SweepInput(&negInput, defaultFeePref)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Sweep a third input that has a smaller output than the previous one,\n\t// but yields positively because of its lower weight.\n\tpositiveInput := createTestInput(2800, input.CommitmentNoDelay)\n\tpositiveInputResult, err := ctx.sweeper.SweepInput(\n\t\t&positiveInput, defaultFeePref,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tctx.tick()\n\n\t// We expect that a sweep tx is published now, but it should only\n\t// contain the large input. The negative input should stay out of sweeps\n\t// until fees come down to get a positive net yield.\n\tsweepTx1 := ctx.receiveTx()\n\tassertTxSweepsInputs(t, &sweepTx1, &largeInput, &positiveInput)\n\n\tctx.backend.mine()\n\n\tctx.expectResult(largeInputResult, nil)\n\tctx.expectResult(positiveInputResult, nil)\n\n\t// Lower fee rate so that the negative input is no longer negative.\n\tctx.estimator.updateFees(1000, 1000)\n\n\t// Create another large input.\n\tsecondLargeInput := createTestInput(100000, input.CommitmentNoDelay)\n\tsecondLargeInputResult, err := ctx.sweeper.SweepInput(\n\t\t&secondLargeInput, defaultFeePref,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tctx.tick()\n\n\tsweepTx2 := ctx.receiveTx()\n\tassertTxSweepsInputs(t, &sweepTx2, &secondLargeInput, &negInput)\n\n\tctx.backend.mine()\n\n\tctx.expectResult(secondLargeInputResult, nil)\n\tctx.expectResult(negInputResult, nil)\n\n\tctx.finish(1)\n}\n\n// TestChunks asserts that large sets of inputs are split into multiple txes.",
      "length": 2001,
      "tokens": 249,
      "embedding": []
    },
    {
      "slug": "func TestChunks(t *testing.T) {",
      "content": "func TestChunks(t *testing.T) {\n\tctx := createSweeperTestContext(t)\n\n\t// Sweep five inputs.\n\tfor _, input := range spendableInputs[:5] {\n\t\t_, err := ctx.sweeper.SweepInput(input, defaultFeePref)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\tctx.tick()\n\n\t// We expect two txes to be published because of the max input count of\n\t// three.\n\tsweepTx1 := ctx.receiveTx()\n\tif len(sweepTx1.TxIn) != 3 {\n\t\tt.Fatalf(\"Expected first tx to sweep 3 inputs, but contains %v \"+\n\t\t\t\"inputs instead\", len(sweepTx1.TxIn))\n\t}\n\n\tsweepTx2 := ctx.receiveTx()\n\tif len(sweepTx2.TxIn) != 2 {\n\t\tt.Fatalf(\"Expected first tx to sweep 2 inputs, but contains %v \"+\n\t\t\t\"inputs instead\", len(sweepTx1.TxIn))\n\t}\n\n\tctx.backend.mine()\n\n\tctx.finish(1)\n}\n\n// TestRemoteSpend asserts that remote spends are properly detected and handled\n// both before the sweep is published as well as after.",
      "length": 788,
      "tokens": 116,
      "embedding": []
    },
    {
      "slug": "func TestRemoteSpend(t *testing.T) {",
      "content": "func TestRemoteSpend(t *testing.T) {\n\tt.Run(\"pre-sweep\", func(t *testing.T) {\n\t\ttestRemoteSpend(t, false)\n\t})\n\tt.Run(\"post-sweep\", func(t *testing.T) {\n\t\ttestRemoteSpend(t, true)\n\t})\n}\n",
      "length": 141,
      "tokens": 15,
      "embedding": []
    },
    {
      "slug": "func testRemoteSpend(t *testing.T, postSweep bool) {",
      "content": "func testRemoteSpend(t *testing.T, postSweep bool) {\n\tctx := createSweeperTestContext(t)\n\n\tresultChan1, err := ctx.sweeper.SweepInput(\n\t\tspendableInputs[0], defaultFeePref,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tresultChan2, err := ctx.sweeper.SweepInput(\n\t\tspendableInputs[1], defaultFeePref,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Spend the input with an unknown tx.\n\tremoteTx := &wire.MsgTx{\n\t\tTxIn: []*wire.TxIn{\n\t\t\t{\n\t\t\t\tPreviousOutPoint: *(spendableInputs[0].OutPoint()),\n\t\t\t},\n\t\t},\n\t}\n\terr = ctx.backend.publishTransaction(remoteTx)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif postSweep {\n\t\tctx.tick()\n\n\t\t// Tx publication by sweeper returns ErrDoubleSpend. Sweeper\n\t\t// will retry the inputs without reporting a result. It could be\n\t\t// spent by the remote party.\n\t\tctx.receiveTx()\n\t}\n\n\tctx.backend.mine()\n\n\tselect {\n\tcase result := <-resultChan1:\n\t\tif result.Err != ErrRemoteSpend {\n\t\t\tt.Fatalf(\"expected remote spend\")\n\t\t}\n\t\tif result.Tx.TxHash() != remoteTx.TxHash() {\n\t\t\tt.Fatalf(\"expected remote spend tx\")\n\t\t}\n\tcase <-time.After(5 * time.Second):\n\t\tt.Fatalf(\"no result received\")\n\t}\n\n\tif !postSweep {\n\t\t// Assert that the sweeper sweeps the remaining input.\n\t\tctx.tick()\n\t\tsweepTx := ctx.receiveTx()\n\n\t\tif len(sweepTx.TxIn) != 1 {\n\t\t\tt.Fatal(\"expected sweep to only sweep the one remaining output\")\n\t\t}\n\n\t\tctx.backend.mine()\n\n\t\tctx.expectResult(resultChan2, nil)\n\n\t\tctx.finish(1)\n\t} else {\n\t\t// Expected sweeper to be still listening for spend of the\n\t\t// error input.\n\t\tctx.finish(2)\n\n\t\tselect {\n\t\tcase <-resultChan2:\n\t\t\tt.Fatalf(\"no result expected for error input\")\n\t\tdefault:\n\t\t}\n\t}\n}\n\n// TestIdempotency asserts that offering the same input multiple times is\n// handled correctly.",
      "length": 1567,
      "tokens": 207,
      "embedding": []
    },
    {
      "slug": "func TestIdempotency(t *testing.T) {",
      "content": "func TestIdempotency(t *testing.T) {\n\tctx := createSweeperTestContext(t)\n\n\tinput := spendableInputs[0]\n\tresultChan1, err := ctx.sweeper.SweepInput(input, defaultFeePref)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tresultChan2, err := ctx.sweeper.SweepInput(input, defaultFeePref)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tctx.tick()\n\n\tctx.receiveTx()\n\n\tresultChan3, err := ctx.sweeper.SweepInput(input, defaultFeePref)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Spend the input of the sweep tx.\n\tctx.backend.mine()\n\n\tctx.expectResult(resultChan1, nil)\n\tctx.expectResult(resultChan2, nil)\n\tctx.expectResult(resultChan3, nil)\n\n\t// Offer the same input again. The sweeper will register a spend ntfn\n\t// for this input. Because the input has already been spent, it will\n\t// immediately receive the spend notification with a spending tx hash.\n\t// Because the sweeper kept track of all of its sweep txes, it will\n\t// recognize the spend as its own.\n\tresultChan4, err := ctx.sweeper.SweepInput(input, defaultFeePref)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tctx.expectResult(resultChan4, nil)\n\n\t// Timer is still running, but spend notification was delivered before\n\t// it expired.\n\tctx.tick()\n\n\tctx.finish(1)\n}\n\n// TestNoInputs asserts that nothing happens if nothing happens.",
      "length": 1166,
      "tokens": 157,
      "embedding": []
    },
    {
      "slug": "func TestNoInputs(t *testing.T) {",
      "content": "func TestNoInputs(t *testing.T) {\n\tctx := createSweeperTestContext(t)\n\n\t// No tx should appear. This is asserted in finish().\n\tctx.finish(1)\n}\n\n// TestRestart asserts that the sweeper picks up sweeping properly after\n// a restart.",
      "length": 189,
      "tokens": 29,
      "embedding": []
    },
    {
      "slug": "func TestRestart(t *testing.T) {",
      "content": "func TestRestart(t *testing.T) {\n\tctx := createSweeperTestContext(t)\n\n\t// Sweep input and expect sweep tx.\n\tinput1 := spendableInputs[0]\n\tif _, err := ctx.sweeper.SweepInput(input1, defaultFeePref); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tctx.tick()\n\n\tctx.receiveTx()\n\n\t// Restart sweeper.\n\tctx.restartSweeper()\n\n\t// Expect last tx to be republished.\n\tctx.receiveTx()\n\n\t// Simulate other subsystem (e.g. contract resolver) re-offering inputs.\n\tspendChan1, err := ctx.sweeper.SweepInput(input1, defaultFeePref)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tinput2 := spendableInputs[1]\n\tspendChan2, err := ctx.sweeper.SweepInput(input2, defaultFeePref)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Spend inputs of sweep txes and verify that spend channels signal\n\t// spends.\n\tctx.backend.mine()\n\n\t// Sweeper should recognize that its sweep tx of the previous run is\n\t// spending the input.\n\tselect {\n\tcase result := <-spendChan1:\n\t\tif result.Err != nil {\n\t\t\tt.Fatalf(\"expected successful sweep\")\n\t\t}\n\tcase <-time.After(defaultTestTimeout):\n\t\tt.Fatalf(\"no result received\")\n\t}\n\n\t// Timer tick should trigger republishing a sweep for the remaining\n\t// input.\n\tctx.tick()\n\n\tctx.receiveTx()\n\n\tctx.backend.mine()\n\n\tselect {\n\tcase result := <-spendChan2:\n\t\tif result.Err != nil {\n\t\t\tt.Fatalf(\"expected successful sweep\")\n\t\t}\n\tcase <-time.After(defaultTestTimeout):\n\t\tt.Fatalf(\"no result received\")\n\t}\n\n\t// Restart sweeper again. No action is expected.\n\tctx.restartSweeper()\n\n\t// Expect last tx to be republished.\n\tctx.receiveTx()\n\n\tctx.finish(1)\n}\n\n// TestRestartRemoteSpend asserts that the sweeper picks up sweeping properly after\n// a restart with remote spend.",
      "length": 1531,
      "tokens": 201,
      "embedding": []
    },
    {
      "slug": "func TestRestartRemoteSpend(t *testing.T) {",
      "content": "func TestRestartRemoteSpend(t *testing.T) {\n\n\tctx := createSweeperTestContext(t)\n\n\t// Sweep input.\n\tinput1 := spendableInputs[0]\n\tif _, err := ctx.sweeper.SweepInput(input1, defaultFeePref); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Sweep another input.\n\tinput2 := spendableInputs[1]\n\tif _, err := ctx.sweeper.SweepInput(input2, defaultFeePref); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tctx.tick()\n\n\tsweepTx := ctx.receiveTx()\n\n\t// Restart sweeper.\n\tctx.restartSweeper()\n\n\t// Expect last tx to be republished.\n\tctx.receiveTx()\n\n\t// Replace the sweep tx with a remote tx spending input 1.\n\tctx.backend.deleteUnconfirmed(sweepTx.TxHash())\n\n\tremoteTx := &wire.MsgTx{\n\t\tTxIn: []*wire.TxIn{\n\t\t\t{\n\t\t\t\tPreviousOutPoint: *(input2.OutPoint()),\n\t\t\t},\n\t\t},\n\t}\n\tif err := ctx.backend.publishTransaction(remoteTx); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Mine remote spending tx.\n\tctx.backend.mine()\n\n\t// Simulate other subsystem (e.g. contract resolver) re-offering input 0.\n\tspendChan, err := ctx.sweeper.SweepInput(input1, defaultFeePref)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Expect sweeper to construct a new tx, because input 1 was spend\n\t// remotely.\n\tctx.tick()\n\n\tctx.receiveTx()\n\n\tctx.backend.mine()\n\n\tctx.expectResult(spendChan, nil)\n\n\tctx.finish(1)\n}\n\n// TestRestartConfirmed asserts that the sweeper picks up sweeping properly after\n// a restart with a confirm of our own sweep tx.",
      "length": 1258,
      "tokens": 162,
      "embedding": []
    },
    {
      "slug": "func TestRestartConfirmed(t *testing.T) {",
      "content": "func TestRestartConfirmed(t *testing.T) {\n\tctx := createSweeperTestContext(t)\n\n\t// Sweep input.\n\tinput := spendableInputs[0]\n\tif _, err := ctx.sweeper.SweepInput(input, defaultFeePref); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tctx.tick()\n\n\tctx.receiveTx()\n\n\t// Restart sweeper.\n\tctx.restartSweeper()\n\n\t// Expect last tx to be republished.\n\tctx.receiveTx()\n\n\t// Mine the sweep tx.\n\tctx.backend.mine()\n\n\t// Simulate other subsystem (e.g. contract resolver) re-offering input 0.\n\tspendChan, err := ctx.sweeper.SweepInput(input, defaultFeePref)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Here we expect again a successful sweep.\n\tctx.expectResult(spendChan, nil)\n\n\t// Timer started but not needed because spend ntfn was sent.\n\tctx.tick()\n\n\tctx.finish(1)\n}\n\n// TestRestartRepublish asserts that sweeper republishes the last published\n// tx on restart.",
      "length": 756,
      "tokens": 100,
      "embedding": []
    },
    {
      "slug": "func TestRestartRepublish(t *testing.T) {",
      "content": "func TestRestartRepublish(t *testing.T) {\n\tctx := createSweeperTestContext(t)\n\n\t_, err := ctx.sweeper.SweepInput(spendableInputs[0], defaultFeePref)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tctx.tick()\n\n\tsweepTx := ctx.receiveTx()\n\n\t// Restart sweeper again. No action is expected.\n\tctx.restartSweeper()\n\n\trepublishedTx := ctx.receiveTx()\n\n\tif sweepTx.TxHash() != republishedTx.TxHash() {\n\t\tt.Fatalf(\"last tx not republished\")\n\t}\n\n\t// Mine the tx to conclude the test properly.\n\tctx.backend.mine()\n\n\tctx.finish(1)\n}\n\n// TestRetry tests the sweeper retry flow.",
      "length": 486,
      "tokens": 60,
      "embedding": []
    },
    {
      "slug": "func TestRetry(t *testing.T) {",
      "content": "func TestRetry(t *testing.T) {\n\tctx := createSweeperTestContext(t)\n\n\tresultChan0, err := ctx.sweeper.SweepInput(\n\t\tspendableInputs[0], defaultFeePref,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tctx.tick()\n\n\t// We expect a sweep to be published.\n\tctx.receiveTx()\n\n\t// New block arrives. This should trigger a new sweep attempt timer\n\t// start.\n\tctx.notifier.NotifyEpoch(1000)\n\n\t// Offer a fresh input.\n\tresultChan1, err := ctx.sweeper.SweepInput(\n\t\tspendableInputs[1], defaultFeePref,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tctx.tick()\n\n\t// Two txes are expected to be published, because new and retry inputs\n\t// are separated.\n\tctx.receiveTx()\n\tctx.receiveTx()\n\n\tctx.backend.mine()\n\n\tctx.expectResult(resultChan0, nil)\n\tctx.expectResult(resultChan1, nil)\n\n\tctx.finish(1)\n}\n\n// TestGiveUp asserts that the sweeper gives up on an input if it can't be swept\n// after a configured number of attempts.a",
      "length": 821,
      "tokens": 110,
      "embedding": []
    },
    {
      "slug": "func TestGiveUp(t *testing.T) {",
      "content": "func TestGiveUp(t *testing.T) {\n\tctx := createSweeperTestContext(t)\n\n\tresultChan0, err := ctx.sweeper.SweepInput(\n\t\tspendableInputs[0], defaultFeePref,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tctx.tick()\n\n\t// We expect a sweep to be published at height 100 (mockChainIOHeight).\n\tctx.receiveTx()\n\n\t// Because of MaxSweepAttemps, two more sweeps will be attempted. We\n\t// configured exponential back-off without randomness for the test. The\n\t// second attempt, we expect to happen at 101. The third attempt at 103.\n\t// At that point, the input is expected to be failed.\n\n\t// Second attempt\n\tctx.notifier.NotifyEpoch(101)\n\tctx.tick()\n\tctx.receiveTx()\n\n\t// Third attempt\n\tctx.notifier.NotifyEpoch(103)\n\tctx.tick()\n\tctx.receiveTx()\n\n\tctx.expectResult(resultChan0, ErrTooManyAttempts)\n\n\tctx.backend.mine()\n\n\tctx.finish(1)\n}\n\n// TestDifferentFeePreferences ensures that the sweeper can have different\n// transactions for different fee preferences. These transactions should be\n// broadcast from highest to lowest fee rate.",
      "length": 944,
      "tokens": 121,
      "embedding": []
    },
    {
      "slug": "func TestDifferentFeePreferences(t *testing.T) {",
      "content": "func TestDifferentFeePreferences(t *testing.T) {\n\tctx := createSweeperTestContext(t)\n\n\t// Throughout this test, we'll be attempting to sweep three inputs, two\n\t// with the higher fee preference, and the last with the lower. We do\n\t// this to ensure the sweeper can broadcast distinct transactions for\n\t// each sweep with a different fee preference.\n\tlowFeePref := FeePreference{ConfTarget: 12}\n\tlowFeeRate := chainfee.SatPerKWeight(5000)\n\tctx.estimator.blocksToFee[lowFeePref.ConfTarget] = lowFeeRate\n\n\thighFeePref := FeePreference{ConfTarget: 6}\n\thighFeeRate := chainfee.SatPerKWeight(10000)\n\tctx.estimator.blocksToFee[highFeePref.ConfTarget] = highFeeRate\n\n\tinput1 := spendableInputs[0]\n\tresultChan1, err := ctx.sweeper.SweepInput(\n\t\tinput1, Params{Fee: highFeePref},\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tinput2 := spendableInputs[1]\n\tresultChan2, err := ctx.sweeper.SweepInput(\n\t\tinput2, Params{Fee: highFeePref},\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tinput3 := spendableInputs[2]\n\tresultChan3, err := ctx.sweeper.SweepInput(\n\t\tinput3, Params{Fee: lowFeePref},\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Start the sweeper's batch ticker, which should cause the sweep\n\t// transactions to be broadcast in order of high to low fee preference.\n\tctx.tick()\n\n\t// Generate the same type of sweep script that was used for weight\n\t// estimation.\n\tchangePk, err := ctx.sweeper.cfg.GenSweepScript()\n\trequire.NoError(t, err)\n\n\t// The first transaction broadcast should be the one spending the higher\n\t// fee rate inputs.\n\tsweepTx1 := ctx.receiveTx()\n\tassertTxFeeRate(t, &sweepTx1, highFeeRate, changePk, input1, input2)\n\n\t// The second should be the one spending the lower fee rate inputs.\n\tsweepTx2 := ctx.receiveTx()\n\tassertTxFeeRate(t, &sweepTx2, lowFeeRate, changePk, input3)\n\n\t// With the transactions broadcast, we'll mine a block to so that the\n\t// result is delivered to each respective client.\n\tctx.backend.mine()\n\tresultChans := []chan Result{resultChan1, resultChan2, resultChan3}\n\tfor _, resultChan := range resultChans {\n\t\tctx.expectResult(resultChan, nil)\n\t}\n\n\tctx.finish(1)\n}\n\n// TestPendingInputs ensures that the sweeper correctly determines the inputs\n// pending to be swept.",
      "length": 2072,
      "tokens": 269,
      "embedding": []
    },
    {
      "slug": "func TestPendingInputs(t *testing.T) {",
      "content": "func TestPendingInputs(t *testing.T) {\n\tctx := createSweeperTestContext(t)\n\n\t// Throughout this test, we'll be attempting to sweep three inputs, two\n\t// with the higher fee preference, and the last with the lower. We do\n\t// this to ensure the sweeper can return all pending inputs, even those\n\t// with different fee preferences.\n\tconst (\n\t\tlowFeeRate  = 5000\n\t\thighFeeRate = 10000\n\t)\n\n\tlowFeePref := FeePreference{\n\t\tConfTarget: 12,\n\t}\n\tctx.estimator.blocksToFee[lowFeePref.ConfTarget] = lowFeeRate\n\n\thighFeePref := FeePreference{\n\t\tConfTarget: 6,\n\t}\n\tctx.estimator.blocksToFee[highFeePref.ConfTarget] = highFeeRate\n\n\tinput1 := spendableInputs[0]\n\tresultChan1, err := ctx.sweeper.SweepInput(\n\t\tinput1, Params{Fee: highFeePref},\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tinput2 := spendableInputs[1]\n\t_, err = ctx.sweeper.SweepInput(\n\t\tinput2, Params{Fee: highFeePref},\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tinput3 := spendableInputs[2]\n\tresultChan3, err := ctx.sweeper.SweepInput(\n\t\tinput3, Params{Fee: lowFeePref},\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// We should expect to see all inputs pending.\n\tctx.assertPendingInputs(input1, input2, input3)\n\n\t// We should expect to see both sweep transactions broadcast. The higher\n\t// fee rate sweep should be broadcast first. We'll remove the lower fee\n\t// rate sweep to ensure we can detect pending inputs after a sweep.\n\t// Once the higher fee rate sweep confirms, we should no longer see\n\t// those inputs pending.\n\tctx.tick()\n\tctx.receiveTx()\n\tlowFeeRateTx := ctx.receiveTx()\n\tctx.backend.deleteUnconfirmed(lowFeeRateTx.TxHash())\n\tctx.backend.mine()\n\tctx.expectResult(resultChan1, nil)\n\tctx.assertPendingInputs(input3)\n\n\t// We'll then trigger a new block to rebroadcast the lower fee rate\n\t// sweep. Once again we'll ensure those inputs are no longer pending\n\t// once the sweep transaction confirms.\n\tctx.backend.notifier.NotifyEpoch(101)\n\tctx.tick()\n\tctx.receiveTx()\n\tctx.backend.mine()\n\tctx.expectResult(resultChan3, nil)\n\tctx.assertPendingInputs()\n\n\tctx.finish(1)\n}\n\n// TestBumpFeeRBF ensures that the UtxoSweeper can properly handle a fee bump\n// request for an input it is currently attempting to sweep. When sweeping the\n// input with the higher fee rate, a replacement transaction is created.",
      "length": 2134,
      "tokens": 283,
      "embedding": []
    },
    {
      "slug": "func TestBumpFeeRBF(t *testing.T) {",
      "content": "func TestBumpFeeRBF(t *testing.T) {\n\tctx := createSweeperTestContext(t)\n\n\tlowFeePref := FeePreference{ConfTarget: 144}\n\tlowFeeRate := chainfee.FeePerKwFloor\n\tctx.estimator.blocksToFee[lowFeePref.ConfTarget] = lowFeeRate\n\n\t// We'll first try to bump the fee of an output currently unknown to the\n\t// UtxoSweeper. Doing so should result in a lnwallet.ErrNotMine error.\n\t_, err := ctx.sweeper.UpdateParams(\n\t\twire.OutPoint{}, ParamsUpdate{Fee: lowFeePref},\n\t)\n\tif err != lnwallet.ErrNotMine {\n\t\tt.Fatalf(\"expected error lnwallet.ErrNotMine, got \\\"%v\\\"\", err)\n\t}\n\n\t// We'll then attempt to sweep an input, which we'll use to bump its fee\n\t// later on.\n\tinput := createTestInput(\n\t\tbtcutil.SatoshiPerBitcoin, input.CommitmentTimeLock,\n\t)\n\tsweepResult, err := ctx.sweeper.SweepInput(\n\t\t&input, Params{Fee: lowFeePref},\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Generate the same type of change script used so we can have accurate\n\t// weight estimation.\n\tchangePk, err := ctx.sweeper.cfg.GenSweepScript()\n\trequire.NoError(t, err)\n\n\t// Ensure that a transaction is broadcast with the lower fee preference.\n\tctx.tick()\n\tlowFeeTx := ctx.receiveTx()\n\tassertTxFeeRate(t, &lowFeeTx, lowFeeRate, changePk, &input)\n\n\t// We'll then attempt to bump its fee rate.\n\thighFeePref := FeePreference{ConfTarget: 6}\n\thighFeeRate := DefaultMaxFeeRate\n\tctx.estimator.blocksToFee[highFeePref.ConfTarget] = highFeeRate\n\n\t// We should expect to see an error if a fee preference isn't provided.\n\t_, err = ctx.sweeper.UpdateParams(*input.OutPoint(), ParamsUpdate{})\n\tif err != ErrNoFeePreference {\n\t\tt.Fatalf(\"expected ErrNoFeePreference, got %v\", err)\n\t}\n\n\tbumpResult, err := ctx.sweeper.UpdateParams(\n\t\t*input.OutPoint(), ParamsUpdate{Fee: highFeePref},\n\t)\n\trequire.NoError(t, err, \"unable to bump input's fee\")\n\n\t// A higher fee rate transaction should be immediately broadcast.\n\tctx.tick()\n\thighFeeTx := ctx.receiveTx()\n\tassertTxFeeRate(t, &highFeeTx, highFeeRate, changePk, &input)\n\n\t// We'll finish our test by mining the sweep transaction.\n\tctx.backend.mine()\n\tctx.expectResult(sweepResult, nil)\n\tctx.expectResult(bumpResult, nil)\n\n\tctx.finish(1)\n}\n\n// TestExclusiveGroup tests the sweeper exclusive group functionality.",
      "length": 2094,
      "tokens": 249,
      "embedding": []
    },
    {
      "slug": "func TestExclusiveGroup(t *testing.T) {",
      "content": "func TestExclusiveGroup(t *testing.T) {\n\tctx := createSweeperTestContext(t)\n\n\t// Sweep three inputs in the same exclusive group.\n\tvar results []chan Result\n\tfor i := 0; i < 3; i++ {\n\t\texclusiveGroup := uint64(1)\n\t\tresult, err := ctx.sweeper.SweepInput(\n\t\t\tspendableInputs[i], Params{\n\t\t\t\tFee:            FeePreference{ConfTarget: 6},\n\t\t\t\tExclusiveGroup: &exclusiveGroup,\n\t\t\t},\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tresults = append(results, result)\n\t}\n\n\t// We expect all inputs to be published in separate transactions, even\n\t// though they share the same fee preference.\n\tctx.tick()\n\tfor i := 0; i < 3; i++ {\n\t\tsweepTx := ctx.receiveTx()\n\t\tif len(sweepTx.TxOut) != 1 {\n\t\t\tt.Fatal(\"expected a single tx out in the sweep tx\")\n\t\t}\n\n\t\t// Remove all txes except for the one that sweeps the first\n\t\t// input. This simulates the sweeps being conflicting.\n\t\tif sweepTx.TxIn[0].PreviousOutPoint !=\n\t\t\t*spendableInputs[0].OutPoint() {\n\n\t\t\tctx.backend.deleteUnconfirmed(sweepTx.TxHash())\n\t\t}\n\t}\n\n\t// Mine the first sweep tx.\n\tctx.backend.mine()\n\n\t// Expect the first input to be swept by the confirmed sweep tx.\n\tresult0 := <-results[0]\n\tif result0.Err != nil {\n\t\tt.Fatal(\"expected first input to be swept\")\n\t}\n\n\t// Expect the other two inputs to return an error. They have no chance\n\t// of confirming.\n\tresult1 := <-results[1]\n\tif result1.Err != ErrExclusiveGroupSpend {\n\t\tt.Fatal(\"expected second input to be canceled\")\n\t}\n\n\tresult2 := <-results[2]\n\tif result2.Err != ErrExclusiveGroupSpend {\n\t\tt.Fatal(\"expected third input to be canceled\")\n\t}\n}\n\n// TestCpfp tests that the sweeper spends cpfp inputs at a fee rate that exceeds\n// the parent tx fee rate.",
      "length": 1554,
      "tokens": 233,
      "embedding": []
    },
    {
      "slug": "func TestCpfp(t *testing.T) {",
      "content": "func TestCpfp(t *testing.T) {\n\tctx := createSweeperTestContext(t)\n\n\tctx.estimator.updateFees(1000, chainfee.FeePerKwFloor)\n\n\t// Offer an input with an unconfirmed parent tx to the sweeper. The\n\t// parent tx pays 3000 sat/kw.\n\thash := chainhash.Hash{1}\n\tinput := input.MakeBaseInput(\n\t\t&wire.OutPoint{Hash: hash},\n\t\tinput.CommitmentTimeLock,\n\t\t&input.SignDescriptor{\n\t\t\tOutput: &wire.TxOut{\n\t\t\t\tValue: 330,\n\t\t\t},\n\t\t\tKeyDesc: keychain.KeyDescriptor{\n\t\t\t\tPubKey: testPubKey,\n\t\t\t},\n\t\t},\n\t\t0,\n\t\t&input.TxInfo{\n\t\t\tWeight: 300,\n\t\t\tFee:    900,\n\t\t},\n\t)\n\n\tfeePref := FeePreference{ConfTarget: 6}\n\tresult, err := ctx.sweeper.SweepInput(\n\t\t&input, Params{Fee: feePref, Force: true},\n\t)\n\trequire.NoError(t, err)\n\n\t// Because we sweep at 1000 sat/kw, the parent cannot be paid for. We\n\t// expect the sweeper to remain idle.\n\tctx.assertNoTick()\n\n\t// Increase the fee estimate to above the parent tx fee rate.\n\tctx.estimator.updateFees(5000, chainfee.FeePerKwFloor)\n\n\t// Signal a new block. This is a trigger for the sweeper to refresh fee\n\t// estimates.\n\tctx.notifier.NotifyEpoch(1000)\n\n\t// Now we do expect a sweep transaction to be published with our input\n\t// and an attached wallet utxo.\n\tctx.tick()\n\ttx := ctx.receiveTx()\n\trequire.Len(t, tx.TxIn, 2)\n\trequire.Len(t, tx.TxOut, 1)\n\n\t// As inputs we have 10000 sats from the wallet and 330 sats from the\n\t// cpfp input. The sweep tx is weight expected to be 759 units. There is\n\t// an additional 300 weight units from the parent to include in the\n\t// package, making a total of 1059. At 5000 sat/kw, the required fee for\n\t// the package is 5295 sats. The parent already paid 900 sats, so there\n\t// is 4395 sat remaining to be paid. The expected output value is\n\t// therefore: 1_000_000 + 330 - 4395 = 995\u00a0935.\n\trequire.Equal(t, int64(995_935), tx.TxOut[0].Value)\n\n\t// Mine the tx and assert that the result is passed back.\n\tctx.backend.mine()\n\tctx.expectResult(result, nil)\n\n\tctx.finish(1)\n}\n\nvar (\n\ttestInputsA = pendingInputs{\n\t\twire.OutPoint{Hash: chainhash.Hash{}, Index: 0}: &pendingInput{},\n\t\twire.OutPoint{Hash: chainhash.Hash{}, Index: 1}: &pendingInput{},\n\t\twire.OutPoint{Hash: chainhash.Hash{}, Index: 2}: &pendingInput{},\n\t}\n\n\ttestInputsB = pendingInputs{\n\t\twire.OutPoint{Hash: chainhash.Hash{}, Index: 10}: &pendingInput{},\n\t\twire.OutPoint{Hash: chainhash.Hash{}, Index: 11}: &pendingInput{},\n\t\twire.OutPoint{Hash: chainhash.Hash{}, Index: 12}: &pendingInput{},\n\t}\n\n\ttestInputsC = pendingInputs{\n\t\twire.OutPoint{Hash: chainhash.Hash{}, Index: 0}:  &pendingInput{},\n\t\twire.OutPoint{Hash: chainhash.Hash{}, Index: 1}:  &pendingInput{},\n\t\twire.OutPoint{Hash: chainhash.Hash{}, Index: 2}:  &pendingInput{},\n\t\twire.OutPoint{Hash: chainhash.Hash{}, Index: 10}: &pendingInput{},\n\t\twire.OutPoint{Hash: chainhash.Hash{}, Index: 11}: &pendingInput{},\n\t\twire.OutPoint{Hash: chainhash.Hash{}, Index: 12}: &pendingInput{},\n\t}\n)\n\n// TestMergeClusters check that we properly can merge clusters together,\n// according to their required locktime.",
      "length": 2860,
      "tokens": 358,
      "embedding": []
    },
    {
      "slug": "func TestMergeClusters(t *testing.T) {",
      "content": "func TestMergeClusters(t *testing.T) {\n\tt.Parallel()\n\n\tlockTime1 := uint32(100)\n\tlockTime2 := uint32(200)\n\n\ttestCases := []struct {\n\t\tname string\n\t\ta    inputCluster\n\t\tb    inputCluster\n\t\tres  []inputCluster\n\t}{\n\t\t{\n\t\t\tname: \"max fee rate\",\n\t\t\ta: inputCluster{\n\t\t\t\tsweepFeeRate: 5000,\n\t\t\t\tinputs:       testInputsA,\n\t\t\t},\n\t\t\tb: inputCluster{\n\t\t\t\tsweepFeeRate: 7000,\n\t\t\t\tinputs:       testInputsB,\n\t\t\t},\n\t\t\tres: []inputCluster{\n\t\t\t\t{\n\t\t\t\t\tsweepFeeRate: 7000,\n\t\t\t\t\tinputs:       testInputsC,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"same locktime\",\n\t\t\ta: inputCluster{\n\t\t\t\tlockTime:     &lockTime1,\n\t\t\t\tsweepFeeRate: 5000,\n\t\t\t\tinputs:       testInputsA,\n\t\t\t},\n\t\t\tb: inputCluster{\n\t\t\t\tlockTime:     &lockTime1,\n\t\t\t\tsweepFeeRate: 7000,\n\t\t\t\tinputs:       testInputsB,\n\t\t\t},\n\t\t\tres: []inputCluster{\n\t\t\t\t{\n\t\t\t\t\tlockTime:     &lockTime1,\n\t\t\t\t\tsweepFeeRate: 7000,\n\t\t\t\t\tinputs:       testInputsC,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"diff locktime\",\n\t\t\ta: inputCluster{\n\t\t\t\tlockTime:     &lockTime1,\n\t\t\t\tsweepFeeRate: 5000,\n\t\t\t\tinputs:       testInputsA,\n\t\t\t},\n\t\t\tb: inputCluster{\n\t\t\t\tlockTime:     &lockTime2,\n\t\t\t\tsweepFeeRate: 7000,\n\t\t\t\tinputs:       testInputsB,\n\t\t\t},\n\t\t\tres: []inputCluster{\n\t\t\t\t{\n\t\t\t\t\tlockTime:     &lockTime1,\n\t\t\t\t\tsweepFeeRate: 5000,\n\t\t\t\t\tinputs:       testInputsA,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tlockTime:     &lockTime2,\n\t\t\t\t\tsweepFeeRate: 7000,\n\t\t\t\t\tinputs:       testInputsB,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range testCases {\n\t\tmerged := mergeClusters(test.a, test.b)\n\t\tif !reflect.DeepEqual(merged, test.res) {\n\t\t\tt.Fatalf(\"[%s] unexpected result: %v\",\n\t\t\t\ttest.name, spew.Sdump(merged))\n\t\t}\n\t}\n}\n\n// TestZipClusters tests that we can merge lists of inputs clusters correctly.",
      "length": 1551,
      "tokens": 162,
      "embedding": []
    },
    {
      "slug": "func TestZipClusters(t *testing.T) {",
      "content": "func TestZipClusters(t *testing.T) {\n\tt.Parallel()\n\n\tcreateCluster := func(inp pendingInputs, f chainfee.SatPerKWeight) inputCluster {\n\t\treturn inputCluster{\n\t\t\tsweepFeeRate: f,\n\t\t\tinputs:       inp,\n\t\t}\n\t}\n\n\ttestCases := []struct {\n\t\tname string\n\t\tas   []inputCluster\n\t\tbs   []inputCluster\n\t\tres  []inputCluster\n\t}{\n\t\t{\n\t\t\tname: \"merge A into B\",\n\t\t\tas: []inputCluster{\n\t\t\t\tcreateCluster(testInputsA, 5000),\n\t\t\t},\n\t\t\tbs: []inputCluster{\n\t\t\t\tcreateCluster(testInputsB, 7000),\n\t\t\t},\n\t\t\tres: []inputCluster{\n\t\t\t\tcreateCluster(testInputsC, 7000),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"A can't merge with B\",\n\t\t\tas: []inputCluster{\n\t\t\t\tcreateCluster(testInputsA, 7000),\n\t\t\t},\n\t\t\tbs: []inputCluster{\n\t\t\t\tcreateCluster(testInputsB, 5000),\n\t\t\t},\n\t\t\tres: []inputCluster{\n\t\t\t\tcreateCluster(testInputsA, 7000),\n\t\t\t\tcreateCluster(testInputsB, 5000),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"empty bs\",\n\t\t\tas: []inputCluster{\n\t\t\t\tcreateCluster(testInputsA, 7000),\n\t\t\t},\n\t\t\tbs: []inputCluster{},\n\t\t\tres: []inputCluster{\n\t\t\t\tcreateCluster(testInputsA, 7000),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"empty as\",\n\t\t\tas:   []inputCluster{},\n\t\t\tbs: []inputCluster{\n\t\t\t\tcreateCluster(testInputsB, 5000),\n\t\t\t},\n\t\t\tres: []inputCluster{\n\t\t\t\tcreateCluster(testInputsB, 5000),\n\t\t\t},\n\t\t},\n\n\t\t{\n\t\t\tname: \"zip 3xA into 3xB\",\n\t\t\tas: []inputCluster{\n\t\t\t\tcreateCluster(testInputsA, 5000),\n\t\t\t\tcreateCluster(testInputsA, 5000),\n\t\t\t\tcreateCluster(testInputsA, 5000),\n\t\t\t},\n\t\t\tbs: []inputCluster{\n\t\t\t\tcreateCluster(testInputsB, 7000),\n\t\t\t\tcreateCluster(testInputsB, 7000),\n\t\t\t\tcreateCluster(testInputsB, 7000),\n\t\t\t},\n\t\t\tres: []inputCluster{\n\t\t\t\tcreateCluster(testInputsC, 7000),\n\t\t\t\tcreateCluster(testInputsC, 7000),\n\t\t\t\tcreateCluster(testInputsC, 7000),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"zip A into 3xB\",\n\t\t\tas: []inputCluster{\n\t\t\t\tcreateCluster(testInputsA, 2500),\n\t\t\t},\n\t\t\tbs: []inputCluster{\n\t\t\t\tcreateCluster(testInputsB, 3000),\n\t\t\t\tcreateCluster(testInputsB, 2000),\n\t\t\t\tcreateCluster(testInputsB, 1000),\n\t\t\t},\n\t\t\tres: []inputCluster{\n\t\t\t\tcreateCluster(testInputsC, 3000),\n\t\t\t\tcreateCluster(testInputsB, 2000),\n\t\t\t\tcreateCluster(testInputsB, 1000),\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range testCases {\n\t\tzipped := zipClusters(test.as, test.bs)\n\t\tif !reflect.DeepEqual(zipped, test.res) {\n\t\t\tt.Fatalf(\"[%s] unexpected result: %v\",\n\t\t\t\ttest.name, spew.Sdump(zipped))\n\t\t}\n\t}\n}\n",
      "length": 2146,
      "tokens": 200,
      "embedding": []
    },
    {
      "slug": "type testInput struct {",
      "content": "type testInput struct {\n\t*input.BaseInput\n\n\tlocktime *uint32\n\treqTxOut *wire.TxOut\n}\n",
      "length": 56,
      "tokens": 6,
      "embedding": []
    },
    {
      "slug": "func (i *testInput) RequiredLockTime() (uint32, bool) {",
      "content": "func (i *testInput) RequiredLockTime() (uint32, bool) {\n\tif i.locktime != nil {\n\t\treturn *i.locktime, true\n\t}\n\n\treturn 0, false\n}\n",
      "length": 68,
      "tokens": 13,
      "embedding": []
    },
    {
      "slug": "func (i *testInput) RequiredTxOut() *wire.TxOut {",
      "content": "func (i *testInput) RequiredTxOut() *wire.TxOut {\n\treturn i.reqTxOut\n}\n\n// CraftInputScript is a custom sign method for the testInput type that will\n// encode the spending outpoint and the tx input index as part of the returned\n// witness.",
      "length": 184,
      "tokens": 33,
      "embedding": []
    },
    {
      "slug": "func (i *testInput) CraftInputScript(_ input.Signer, txn *wire.MsgTx,",
      "content": "func (i *testInput) CraftInputScript(_ input.Signer, txn *wire.MsgTx,\n\thashCache *txscript.TxSigHashes,\n\tprevOutputFetcher txscript.PrevOutputFetcher,\n\ttxinIdx int) (*input.Script, error) {\n\n\t// We'll encode the outpoint in the witness, so we can assert that the\n\t// expected input was signed at the correct index.\n\top := i.OutPoint()\n\treturn &input.Script{\n\t\tWitness: [][]byte{\n\t\t\t// We encode the hash of the outpoint...\n\t\t\top.Hash[:],\n\t\t\t// ..the outpoint index...\n\t\t\t{byte(op.Index)},\n\t\t\t// ..and finally the tx input index.\n\t\t\t{byte(txinIdx)},\n\t\t},\n\t}, nil\n}\n\n// assertSignedIndex goes through all inputs to the tx and checks that all\n// testInputs have witnesses corresponding to the outpoints they are spending,\n// and are signed at the correct tx input index. All found testInputs are\n// returned such that we can sum up and sanity check that all testInputs were\n// part of the sweep.",
      "length": 799,
      "tokens": 123,
      "embedding": []
    },
    {
      "slug": "func assertSignedIndex(t *testing.T, tx *wire.MsgTx,",
      "content": "func assertSignedIndex(t *testing.T, tx *wire.MsgTx,\n\ttestInputs map[wire.OutPoint]*testInput) map[wire.OutPoint]struct{} {\n\n\tfound := make(map[wire.OutPoint]struct{})\n\tfor idx, txIn := range tx.TxIn {\n\t\top := txIn.PreviousOutPoint\n\n\t\t// Not a testInput, it won't have the test encoding we require\n\t\t// to check outpoint and index.\n\t\tif _, ok := testInputs[op]; !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tif _, ok := found[op]; ok {\n\t\t\tt.Fatalf(\"input already used\")\n\t\t}\n\n\t\t// Check it was signes spending the correct outpoint, and at\n\t\t// the expected tx input index.\n\t\trequire.Equal(t, txIn.Witness[0], op.Hash[:])\n\t\trequire.Equal(t, txIn.Witness[1], []byte{byte(op.Index)})\n\t\trequire.Equal(t, txIn.Witness[2], []byte{byte(idx)})\n\t\tfound[op] = struct{}{}\n\t}\n\n\treturn found\n}\n\n// TestLockTimes checks that the sweeper properly groups inputs requiring the\n// same locktime together into sweep transactions.",
      "length": 807,
      "tokens": 106,
      "embedding": []
    },
    {
      "slug": "func TestLockTimes(t *testing.T) {",
      "content": "func TestLockTimes(t *testing.T) {\n\tctx := createSweeperTestContext(t)\n\n\t// We increase the number of max inputs to a tx so that won't\n\t// impact our test.\n\tctx.sweeper.cfg.MaxInputsPerTx = 100\n\n\t// We will set up the lock times in such a way that we expect the\n\t// sweeper to divide the inputs into 4 diffeerent transactions.\n\tconst numSweeps = 4\n\n\t// Sweep 8 inputs, using 4 different lock times.\n\tvar (\n\t\tresults []chan Result\n\t\tinputs  = make(map[wire.OutPoint]input.Input)\n\t)\n\tfor i := 0; i < numSweeps*2; i++ {\n\t\tlt := uint32(10 + (i % numSweeps))\n\t\tinp := &testInput{\n\t\t\tBaseInput: spendableInputs[i],\n\t\t\tlocktime:  &lt,\n\t\t}\n\n\t\tresult, err := ctx.sweeper.SweepInput(\n\t\t\tinp, Params{\n\t\t\t\tFee: FeePreference{ConfTarget: 6},\n\t\t\t},\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tresults = append(results, result)\n\n\t\top := inp.OutPoint()\n\t\tinputs[*op] = inp\n\t}\n\n\t// We also add 3 regular inputs that don't require any specific lock\n\t// time.\n\tfor i := 0; i < 3; i++ {\n\t\tinp := spendableInputs[i+numSweeps*2]\n\t\tresult, err := ctx.sweeper.SweepInput(\n\t\t\tinp, Params{\n\t\t\t\tFee: FeePreference{ConfTarget: 6},\n\t\t\t},\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tresults = append(results, result)\n\n\t\top := inp.OutPoint()\n\t\tinputs[*op] = inp\n\t}\n\n\t// We expect all inputs to be published in separate transactions, even\n\t// though they share the same fee preference.\n\tctx.tick()\n\n\t// Check the sweeps transactions, ensuring all inputs are there, and\n\t// all the locktimes are satisfied.\n\tfor i := 0; i < numSweeps; i++ {\n\t\tsweepTx := ctx.receiveTx()\n\t\tif len(sweepTx.TxOut) != 1 {\n\t\t\tt.Fatal(\"expected a single tx out in the sweep tx\")\n\t\t}\n\n\t\tfor _, txIn := range sweepTx.TxIn {\n\t\t\top := txIn.PreviousOutPoint\n\t\t\tinp, ok := inputs[op]\n\t\t\tif !ok {\n\t\t\t\tt.Fatalf(\"Unexpected outpoint: %v\", op)\n\t\t\t}\n\n\t\t\tdelete(inputs, op)\n\n\t\t\t// If this input had a required locktime, ensure the tx\n\t\t\t// has that set correctly.\n\t\t\tlt, ok := inp.RequiredLockTime()\n\t\t\tif !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif lt != sweepTx.LockTime {\n\t\t\t\tt.Fatalf(\"Input required locktime %v, sweep \"+\n\t\t\t\t\t\"tx had locktime %v\", lt, sweepTx.LockTime)\n\t\t\t}\n\t\t}\n\t}\n\n\t// The should be no inputs not foud in any of the sweeps.\n\tif len(inputs) != 0 {\n\t\tt.Fatalf(\"had unsweeped inputs\")\n\t}\n\n\t// Mine the first sweeps\n\tctx.backend.mine()\n\n\t// Results should all come back.\n\tfor i := range results {\n\t\tresult := <-results[i]\n\t\tif result.Err != nil {\n\t\t\tt.Fatal(\"expected input to be swept\")\n\t\t}\n\t}\n}\n\n// TestRequiredTxOuts checks that inputs having a required TxOut gets swept with\n// sweep transactions paying into these outputs.",
      "length": 2423,
      "tokens": 390,
      "embedding": []
    },
    {
      "slug": "func TestRequiredTxOuts(t *testing.T) {",
      "content": "func TestRequiredTxOuts(t *testing.T) {\n\t// Create some test inputs and locktime vars.\n\tvar inputs []*input.BaseInput\n\tfor i := 0; i < 20; i++ {\n\t\tinput := createTestInput(\n\t\t\tint64(btcutil.SatoshiPerBitcoin+i*500),\n\t\t\tinput.CommitmentTimeLock,\n\t\t)\n\n\t\tinputs = append(inputs, &input)\n\t}\n\n\tlocktime1 := uint32(51)\n\tlocktime2 := uint32(52)\n\tlocktime3 := uint32(53)\n\n\taPkScript := make([]byte, input.P2WPKHSize)\n\taPkScript[0] = 'a'\n\n\tbPkScript := make([]byte, input.P2WSHSize)\n\tbPkScript[0] = 'b'\n\n\tcPkScript := make([]byte, input.P2PKHSize)\n\tcPkScript[0] = 'c'\n\n\tdPkScript := make([]byte, input.P2SHSize)\n\tdPkScript[0] = 'd'\n\n\tePkScript := make([]byte, input.UnknownWitnessSize)\n\tePkScript[0] = 'e'\n\n\tfPkScript := make([]byte, input.P2WSHSize)\n\tfPkScript[0] = 'f'\n\n\ttestCases := []struct {\n\t\tname         string\n\t\tinputs       []*testInput\n\t\tassertSweeps func(*testing.T, map[wire.OutPoint]*testInput,\n\t\t\t[]*wire.MsgTx)\n\t}{\n\t\t{\n\t\t\t// Single input with a required TX out that is smaller.\n\t\t\t// We expect a change output to be added.\n\t\t\tname: \"single input, leftover change\",\n\t\t\tinputs: []*testInput{\n\t\t\t\t{\n\t\t\t\t\tBaseInput: inputs[0],\n\t\t\t\t\treqTxOut: &wire.TxOut{\n\t\t\t\t\t\tPkScript: aPkScript,\n\t\t\t\t\t\tValue:    100000,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\n\t\t\t// Since the required output value is small, we expect\n\t\t\t// the rest after fees to go into a change output.\n\t\t\tassertSweeps: func(t *testing.T,\n\t\t\t\t_ map[wire.OutPoint]*testInput,\n\t\t\t\ttxs []*wire.MsgTx) {\n\n\t\t\t\trequire.Equal(t, 1, len(txs))\n\n\t\t\t\ttx := txs[0]\n\t\t\t\trequire.Equal(t, 1, len(tx.TxIn))\n\n\t\t\t\t// We should have two outputs, the required\n\t\t\t\t// output must be the first one.\n\t\t\t\trequire.Equal(t, 2, len(tx.TxOut))\n\t\t\t\tout := tx.TxOut[0]\n\t\t\t\trequire.Equal(t, aPkScript, out.PkScript)\n\t\t\t\trequire.Equal(t, int64(100000), out.Value)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t// An input committing to a slightly smaller output, so\n\t\t\t// it will pay its own fees.\n\t\t\tname: \"single input, no change\",\n\t\t\tinputs: []*testInput{\n\t\t\t\t{\n\t\t\t\t\tBaseInput: inputs[0],\n\t\t\t\t\treqTxOut: &wire.TxOut{\n\t\t\t\t\t\tPkScript: aPkScript,\n\n\t\t\t\t\t\t// Fee will be about 5340 sats.\n\t\t\t\t\t\t// Subtract a bit more to\n\t\t\t\t\t\t// ensure no dust change output\n\t\t\t\t\t\t// is manifested.\n\t\t\t\t\t\tValue: inputs[0].SignDesc().Output.Value - 6300,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\n\t\t\t// We expect this single input/output pair.\n\t\t\tassertSweeps: func(t *testing.T,\n\t\t\t\t_ map[wire.OutPoint]*testInput,\n\t\t\t\ttxs []*wire.MsgTx) {\n\n\t\t\t\trequire.Equal(t, 1, len(txs))\n\n\t\t\t\ttx := txs[0]\n\t\t\t\trequire.Equal(t, 1, len(tx.TxIn))\n\n\t\t\t\trequire.Equal(t, 1, len(tx.TxOut))\n\t\t\t\tout := tx.TxOut[0]\n\t\t\t\trequire.Equal(t, aPkScript, out.PkScript)\n\t\t\t\trequire.Equal(\n\t\t\t\t\tt,\n\t\t\t\t\tinputs[0].SignDesc().Output.Value-6300,\n\t\t\t\t\tout.Value,\n\t\t\t\t)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t// Two inputs, where the first one required no tx out.\n\t\t\tname: \"two inputs, one with required tx out\",\n\t\t\tinputs: []*testInput{\n\t\t\t\t{\n\n\t\t\t\t\t// We add a normal, non-requiredTxOut\n\t\t\t\t\t// input. We use test input 10, to make\n\t\t\t\t\t// sure this has a higher yield than\n\t\t\t\t\t// the other input, and will be\n\t\t\t\t\t// attempted added first to the sweep\n\t\t\t\t\t// tx.\n\t\t\t\t\tBaseInput: inputs[10],\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t// The second input requires a TxOut.\n\t\t\t\t\tBaseInput: inputs[0],\n\t\t\t\t\treqTxOut: &wire.TxOut{\n\t\t\t\t\t\tPkScript: aPkScript,\n\t\t\t\t\t\tValue:    inputs[0].SignDesc().Output.Value,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\n\t\t\t// We expect the inputs to have been reordered.\n\t\t\tassertSweeps: func(t *testing.T,\n\t\t\t\t_ map[wire.OutPoint]*testInput,\n\t\t\t\ttxs []*wire.MsgTx) {\n\n\t\t\t\trequire.Equal(t, 1, len(txs))\n\n\t\t\t\ttx := txs[0]\n\t\t\t\trequire.Equal(t, 2, len(tx.TxIn))\n\t\t\t\trequire.Equal(t, 2, len(tx.TxOut))\n\n\t\t\t\t// The required TxOut should be the first one.\n\t\t\t\tout := tx.TxOut[0]\n\t\t\t\trequire.Equal(t, aPkScript, out.PkScript)\n\t\t\t\trequire.Equal(\n\t\t\t\t\tt, inputs[0].SignDesc().Output.Value,\n\t\t\t\t\tout.Value,\n\t\t\t\t)\n\n\t\t\t\t// The first input should be the one having the\n\t\t\t\t// required TxOut.\n\t\t\t\trequire.Len(t, tx.TxIn, 2)\n\t\t\t\trequire.Equal(\n\t\t\t\t\tt, inputs[0].OutPoint(),\n\t\t\t\t\t&tx.TxIn[0].PreviousOutPoint,\n\t\t\t\t)\n\n\t\t\t\t// Second one is the one without a required tx\n\t\t\t\t// out.\n\t\t\t\trequire.Equal(\n\t\t\t\t\tt, inputs[10].OutPoint(),\n\t\t\t\t\t&tx.TxIn[1].PreviousOutPoint,\n\t\t\t\t)\n\t\t\t},\n\t\t},\n\n\t\t{\n\t\t\t// An input committing to an output of equal value, just\n\t\t\t// add input to pay fees.\n\t\t\tname: \"single input, extra fee input\",\n\t\t\tinputs: []*testInput{\n\t\t\t\t{\n\t\t\t\t\tBaseInput: inputs[0],\n\t\t\t\t\treqTxOut: &wire.TxOut{\n\t\t\t\t\t\tPkScript: aPkScript,\n\t\t\t\t\t\tValue:    inputs[0].SignDesc().Output.Value,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\n\t\t\t// We expect an extra input and output.\n\t\t\tassertSweeps: func(t *testing.T,\n\t\t\t\t_ map[wire.OutPoint]*testInput,\n\t\t\t\ttxs []*wire.MsgTx) {\n\n\t\t\t\trequire.Equal(t, 1, len(txs))\n\n\t\t\t\ttx := txs[0]\n\t\t\t\trequire.Equal(t, 2, len(tx.TxIn))\n\n\t\t\t\trequire.Equal(t, 2, len(tx.TxOut))\n\t\t\t\tout := tx.TxOut[0]\n\t\t\t\trequire.Equal(t, aPkScript, out.PkScript)\n\t\t\t\trequire.Equal(\n\t\t\t\t\tt, inputs[0].SignDesc().Output.Value,\n\t\t\t\t\tout.Value,\n\t\t\t\t)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t// Three inputs added, should be combined into a single\n\t\t\t// sweep.\n\t\t\tname: \"three inputs\",\n\t\t\tinputs: []*testInput{\n\t\t\t\t{\n\t\t\t\t\tBaseInput: inputs[0],\n\t\t\t\t\treqTxOut: &wire.TxOut{\n\t\t\t\t\t\tPkScript: aPkScript,\n\t\t\t\t\t\tValue:    inputs[0].SignDesc().Output.Value,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tBaseInput: inputs[1],\n\t\t\t\t\treqTxOut: &wire.TxOut{\n\t\t\t\t\t\tPkScript: bPkScript,\n\t\t\t\t\t\tValue:    inputs[1].SignDesc().Output.Value,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tBaseInput: inputs[2],\n\t\t\t\t\treqTxOut: &wire.TxOut{\n\t\t\t\t\t\tPkScript: cPkScript,\n\t\t\t\t\t\tValue:    inputs[2].SignDesc().Output.Value,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\n\t\t\t// We expect an extra input and output to pay fees.\n\t\t\tassertSweeps: func(t *testing.T,\n\t\t\t\ttestInputs map[wire.OutPoint]*testInput,\n\t\t\t\ttxs []*wire.MsgTx) {\n\n\t\t\t\trequire.Equal(t, 1, len(txs))\n\n\t\t\t\ttx := txs[0]\n\t\t\t\trequire.Equal(t, 4, len(tx.TxIn))\n\t\t\t\trequire.Equal(t, 4, len(tx.TxOut))\n\n\t\t\t\t// The inputs and outputs must be in the same\n\t\t\t\t// order.\n\t\t\t\tfor i, in := range tx.TxIn {\n\t\t\t\t\t// Last one is the change input/output\n\t\t\t\t\t// pair, so we'll skip it.\n\t\t\t\t\tif i == 3 {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get this input to ensure the output\n\t\t\t\t\t// on index i coresponsd to this one.\n\t\t\t\t\tinp := testInputs[in.PreviousOutPoint]\n\t\t\t\t\trequire.NotNil(t, inp)\n\n\t\t\t\t\trequire.Equal(\n\t\t\t\t\t\tt, tx.TxOut[i].Value,\n\t\t\t\t\t\tinp.SignDesc().Output.Value,\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t// Six inputs added, which 3 different locktimes.\n\t\t\t// Should result in 3 sweeps.\n\t\t\tname: \"six inputs\",\n\t\t\tinputs: []*testInput{\n\t\t\t\t{\n\t\t\t\t\tBaseInput: inputs[0],\n\t\t\t\t\tlocktime:  &locktime1,\n\t\t\t\t\treqTxOut: &wire.TxOut{\n\t\t\t\t\t\tPkScript: aPkScript,\n\t\t\t\t\t\tValue:    inputs[0].SignDesc().Output.Value,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tBaseInput: inputs[1],\n\t\t\t\t\tlocktime:  &locktime1,\n\t\t\t\t\treqTxOut: &wire.TxOut{\n\t\t\t\t\t\tPkScript: bPkScript,\n\t\t\t\t\t\tValue:    inputs[1].SignDesc().Output.Value,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tBaseInput: inputs[2],\n\t\t\t\t\tlocktime:  &locktime2,\n\t\t\t\t\treqTxOut: &wire.TxOut{\n\t\t\t\t\t\tPkScript: cPkScript,\n\t\t\t\t\t\tValue:    inputs[2].SignDesc().Output.Value,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tBaseInput: inputs[3],\n\t\t\t\t\tlocktime:  &locktime2,\n\t\t\t\t\treqTxOut: &wire.TxOut{\n\t\t\t\t\t\tPkScript: dPkScript,\n\t\t\t\t\t\tValue:    inputs[3].SignDesc().Output.Value,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tBaseInput: inputs[4],\n\t\t\t\t\tlocktime:  &locktime3,\n\t\t\t\t\treqTxOut: &wire.TxOut{\n\t\t\t\t\t\tPkScript: ePkScript,\n\t\t\t\t\t\tValue:    inputs[4].SignDesc().Output.Value,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tBaseInput: inputs[5],\n\t\t\t\t\tlocktime:  &locktime3,\n\t\t\t\t\treqTxOut: &wire.TxOut{\n\t\t\t\t\t\tPkScript: fPkScript,\n\t\t\t\t\t\tValue:    inputs[5].SignDesc().Output.Value,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\n\t\t\t// We expect three sweeps, each having two of our\n\t\t\t// inputs, one extra input and output to pay fees.\n\t\t\tassertSweeps: func(t *testing.T,\n\t\t\t\ttestInputs map[wire.OutPoint]*testInput,\n\t\t\t\ttxs []*wire.MsgTx) {\n\n\t\t\t\trequire.Equal(t, 3, len(txs))\n\n\t\t\t\tfor _, tx := range txs {\n\t\t\t\t\trequire.Equal(t, 3, len(tx.TxIn))\n\t\t\t\t\trequire.Equal(t, 3, len(tx.TxOut))\n\n\t\t\t\t\t// The inputs and outputs must be in\n\t\t\t\t\t// the same order.\n\t\t\t\t\tfor i, in := range tx.TxIn {\n\t\t\t\t\t\t// Last one is the change\n\t\t\t\t\t\t// output, so we'll skip it.\n\t\t\t\t\t\tif i == 2 {\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Get this input to ensure the\n\t\t\t\t\t\t// output on index i coresponsd\n\t\t\t\t\t\t// to this one.\n\t\t\t\t\t\tinp := testInputs[in.PreviousOutPoint]\n\t\t\t\t\t\trequire.NotNil(t, inp)\n\n\t\t\t\t\t\trequire.Equal(\n\t\t\t\t\t\t\tt, tx.TxOut[i].Value,\n\t\t\t\t\t\t\tinp.SignDesc().Output.Value,\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\t// Check that the locktimes are\n\t\t\t\t\t\t// kept intact.\n\t\t\t\t\t\trequire.Equal(\n\t\t\t\t\t\t\tt, tx.LockTime,\n\t\t\t\t\t\t\t*inp.locktime,\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\ttestCase := testCase\n\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tctx := createSweeperTestContext(t)\n\n\t\t\t// We increase the number of max inputs to a tx so that\n\t\t\t// won't impact our test.\n\t\t\tctx.sweeper.cfg.MaxInputsPerTx = 100\n\n\t\t\t// Sweep all test inputs.\n\t\t\tvar (\n\t\t\t\tinputs  = make(map[wire.OutPoint]*testInput)\n\t\t\t\tresults = make(map[wire.OutPoint]chan Result)\n\t\t\t)\n\t\t\tfor _, inp := range testCase.inputs {\n\t\t\t\tresult, err := ctx.sweeper.SweepInput(\n\t\t\t\t\tinp, Params{\n\t\t\t\t\t\tFee: FeePreference{ConfTarget: 6},\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\n\t\t\t\top := inp.OutPoint()\n\t\t\t\tresults[*op] = result\n\t\t\t\tinputs[*op] = inp\n\t\t\t}\n\n\t\t\t// Tick, which should trigger a sweep of all inputs.\n\t\t\tctx.tick()\n\n\t\t\t// Check the sweeps transactions, ensuring all inputs\n\t\t\t// are there, and all the locktimes are satisfied.\n\t\t\tvar sweeps []*wire.MsgTx\n\t\tLoop:\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase tx := <-ctx.publishChan:\n\t\t\t\t\tsweeps = append(sweeps, &tx)\n\t\t\t\tcase <-time.After(200 * time.Millisecond):\n\t\t\t\t\tbreak Loop\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Mine the sweeps.\n\t\t\tctx.backend.mine()\n\n\t\t\t// Results should all come back.\n\t\t\tfor _, resultChan := range results {\n\t\t\t\tresult := <-resultChan\n\t\t\t\tif result.Err != nil {\n\t\t\t\t\tt.Fatalf(\"expected input to be \"+\n\t\t\t\t\t\t\"swept: %v\", result.Err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Assert the transactions are what we expect.\n\t\t\ttestCase.assertSweeps(t, inputs, sweeps)\n\n\t\t\t// Finally we assert that all our test inputs were part\n\t\t\t// of the sweeps, and that they were signed correctly.\n\t\t\tsweptInputs := make(map[wire.OutPoint]struct{})\n\t\t\tfor _, sweep := range sweeps {\n\t\t\t\tswept := assertSignedIndex(t, sweep, inputs)\n\t\t\t\tfor op := range swept {\n\t\t\t\t\tif _, ok := sweptInputs[op]; ok {\n\t\t\t\t\t\tt.Fatalf(\"outpoint %v part of \"+\n\t\t\t\t\t\t\t\"previous sweep\", op)\n\t\t\t\t\t}\n\n\t\t\t\t\tsweptInputs[op] = struct{}{}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trequire.Equal(t, len(inputs), len(sweptInputs))\n\t\t\tfor op := range sweptInputs {\n\t\t\t\t_, ok := inputs[op]\n\t\t\t\tif !ok {\n\t\t\t\t\tt.Fatalf(\"swept input %v not part of \"+\n\t\t\t\t\t\t\"test inputs\", op)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestSweeperShutdownHandling tests that we notify callers when the sweeper\n// cannot handle requests since it's in the process of shutting down.",
      "length": 10235,
      "tokens": 1236,
      "embedding": []
    },
    {
      "slug": "func TestSweeperShutdownHandling(t *testing.T) {",
      "content": "func TestSweeperShutdownHandling(t *testing.T) {\n\tctx := createSweeperTestContext(t)\n\n\t// Make the backing notifier break down. This is what happens during\n\t// lnd shut down, since the notifier is stopped before the sweeper.\n\trequire.Len(t, ctx.notifier.epochChan, 1)\n\tfor epochChan := range ctx.notifier.epochChan {\n\t\tclose(epochChan)\n\t}\n\n\t// Give the collector some time to exit.\n\ttime.Sleep(50 * time.Millisecond)\n\n\t// Now trying to sweep inputs should return an error on the error\n\t// channel.\n\tresultChan, err := ctx.sweeper.SweepInput(\n\t\tspendableInputs[0], defaultFeePref,\n\t)\n\trequire.NoError(t, err)\n\n\tselect {\n\tcase res := <-resultChan:\n\t\trequire.Equal(t, ErrSweeperShuttingDown, res.Err)\n\n\tcase <-time.After(defaultTestTimeout):\n\t\tt.Fatalf(\"no result arrived\")\n\t}\n\n\t// Stop the sweeper properly.\n\terr = ctx.sweeper.Stop()\n\trequire.NoError(t, err)\n\n\t// Now attempting to sweep an input should error out immediately.\n\t_, err = ctx.sweeper.SweepInput(\n\t\tspendableInputs[0], defaultFeePref,\n\t)\n\trequire.Error(t, err)\n}\n",
      "length": 939,
      "tokens": 119,
      "embedding": []
    }
  ]
}