{
  "filepath": "../implementations/go/lnd/sweep/store_test.go",
  "package": "sweep",
  "sections": [
    {
      "slug": "func TestStore(t *testing.T) {",
      "content": "func TestStore(t *testing.T) {\n\tt.Run(\"bolt\", func(t *testing.T) {\n\n\t\t// Create new store.\n\t\tcdb, err := channeldb.MakeTestDB(t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to open channel db: %v\", err)\n\t\t}\n\n\t\ttestStore(t, func() (SweeperStore, error) {\n\t\t\tvar chain chainhash.Hash\n\t\t\treturn NewSweeperStore(cdb, &chain)\n\t\t})\n\t})\n\tt.Run(\"mock\", func(t *testing.T) {\n\t\tstore := NewMockSweeperStore()\n\n\t\ttestStore(t, func() (SweeperStore, error) {\n\t\t\t// Return same store, because the mock has no real\n\t\t\t// persistence.\n\t\t\treturn store, nil\n\t\t})\n\t})\n}\n",
      "length": 491,
      "tokens": 68,
      "embedding": []
    },
    {
      "slug": "func testStore(t *testing.T, createStore func() (SweeperStore, error)) {",
      "content": "func testStore(t *testing.T, createStore func() (SweeperStore, error)) {\n\tstore, err := createStore()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Initially we expect the store not to have a last published tx.\n\tretrievedTx, err := store.GetLastPublishedTx()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif retrievedTx != nil {\n\t\tt.Fatal(\"expected no last published tx\")\n\t}\n\n\t// Notify publication of tx1\n\ttx1 := wire.MsgTx{}\n\ttx1.AddTxIn(&wire.TxIn{\n\t\tPreviousOutPoint: wire.OutPoint{\n\t\t\tIndex: 1,\n\t\t},\n\t})\n\n\terr = store.NotifyPublishTx(&tx1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Notify publication of tx2\n\ttx2 := wire.MsgTx{}\n\ttx2.AddTxIn(&wire.TxIn{\n\t\tPreviousOutPoint: wire.OutPoint{\n\t\t\tIndex: 2,\n\t\t},\n\t})\n\n\terr = store.NotifyPublishTx(&tx2)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Recreate the sweeper store\n\tstore, err = createStore()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Assert that last published tx2 is present.\n\tretrievedTx, err = store.GetLastPublishedTx()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif tx2.TxHash() != retrievedTx.TxHash() {\n\t\tt.Fatal(\"txes do not match\")\n\t}\n\n\t// Assert that both txes are recognized as our own.\n\tours, err := store.IsOurTx(tx1.TxHash())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !ours {\n\t\tt.Fatal(\"expected tx to be ours\")\n\t}\n\n\tours, err = store.IsOurTx(tx2.TxHash())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !ours {\n\t\tt.Fatal(\"expected tx to be ours\")\n\t}\n\n\t// An different hash should be reported as not being ours.\n\tvar unknownHash chainhash.Hash\n\tours, err = store.IsOurTx(unknownHash)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif ours {\n\t\tt.Fatal(\"expected tx to be not ours\")\n\t}\n\n\ttxns, err := store.ListSweeps()\n\trequire.NoError(t, err, \"unexpected error\")\n\n\t// Create a map containing the sweeps we expect to be returned by list\n\t// sweeps.\n\texpected := map[chainhash.Hash]bool{\n\t\ttx1.TxHash(): true,\n\t\ttx2.TxHash(): true,\n\t}\n\n\tif len(txns) != len(expected) {\n\t\tt.Fatalf(\"expected: %v sweeps, got: %v\", len(expected),\n\t\t\tlen(txns))\n\t}\n\n\tfor _, tx := range txns {\n\t\t_, ok := expected[tx]\n\t\tif !ok {\n\t\t\tt.Fatalf(\"unexpected tx: %v\", tx)\n\t\t}\n\t}\n}\n",
      "length": 1893,
      "tokens": 292,
      "embedding": []
    }
  ]
}