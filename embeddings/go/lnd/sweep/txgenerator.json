{
  "filepath": "../implementations/go/lnd/sweep/txgenerator.go",
  "package": "sweep",
  "sections": [
    {
      "slug": "type txInput interface {",
      "content": "type txInput interface {\n\tinput.Input\n\tparameters() Params\n}\n\n// inputSet is a set of inputs that can be used as the basis to generate a tx\n// on.",
      "length": 116,
      "tokens": 24,
      "embedding": []
    },
    {
      "slug": "type inputSet []input.Input",
      "content": "type inputSet []input.Input\n\n// generateInputPartitionings goes through all given inputs and constructs sets\n// of inputs that can be used to generate a sensible transaction. Each set\n// contains up to the configured maximum number of inputs. Negative yield\n// inputs are skipped. No input sets with a total value after fees below the\n// dust limit are returned.",
      "length": 329,
      "tokens": 56,
      "embedding": []
    },
    {
      "slug": "func generateInputPartitionings(sweepableInputs []txInput,",
      "content": "func generateInputPartitionings(sweepableInputs []txInput,\n\tfeePerKW chainfee.SatPerKWeight, maxInputsPerTx int,\n\twallet Wallet) ([]inputSet, error) {\n\n\t// Sort input by yield. We will start constructing input sets starting\n\t// with the highest yield inputs. This is to prevent the construction\n\t// of a set with an output below the dust limit, causing the sweep\n\t// process to stop, while there are still higher value inputs\n\t// available. It also allows us to stop evaluating more inputs when the\n\t// first input in this ordering is encountered with a negative yield.\n\t//\n\t// Yield is calculated as the difference between value and added fee\n\t// for this input. The fee calculation excludes fee components that are\n\t// common to all inputs, as those wouldn't influence the order. The\n\t// single component that is differentiating is witness size.\n\t//\n\t// For witness size, the upper limit is taken. The actual size depends\n\t// on the signature length, which is not known yet at this point.\n\tyields := make(map[wire.OutPoint]int64)\n\tfor _, input := range sweepableInputs {\n\t\tsize, _, err := input.WitnessType().SizeUpperBound()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\n\t\t\t\t\"failed adding input weight: %v\", err)\n\t\t}\n\n\t\tyields[*input.OutPoint()] = input.SignDesc().Output.Value -\n\t\t\tint64(feePerKW.FeeForWeight(int64(size)))\n\t}\n\n\tsort.Slice(sweepableInputs, func(i, j int) bool {\n\t\t// Because of the specific ordering and termination condition\n\t\t// that is described above, we place force sweeps at the start\n\t\t// of the list. Otherwise we can't be sure that they will be\n\t\t// included in an input set.\n\t\tif sweepableInputs[i].parameters().Force {\n\t\t\treturn true\n\t\t}\n\n\t\treturn yields[*sweepableInputs[i].OutPoint()] >\n\t\t\tyields[*sweepableInputs[j].OutPoint()]\n\t})\n\n\t// Select blocks of inputs up to the configured maximum number.\n\tvar sets []inputSet\n\tfor len(sweepableInputs) > 0 {\n\t\t// Start building a set of positive-yield tx inputs under the\n\t\t// condition that the tx will be published with the specified\n\t\t// fee rate.\n\t\ttxInputs := newTxInputSet(wallet, feePerKW, maxInputsPerTx)\n\n\t\t// From the set of sweepable inputs, keep adding inputs to the\n\t\t// input set until the tx output value no longer goes up or the\n\t\t// maximum number of inputs is reached.\n\t\ttxInputs.addPositiveYieldInputs(sweepableInputs)\n\n\t\t// If there are no positive yield inputs, we can stop here.\n\t\tinputCount := len(txInputs.inputs)\n\t\tif inputCount == 0 {\n\t\t\treturn sets, nil\n\t\t}\n\n\t\t// Check the current output value and add wallet utxos if\n\t\t// needed to push the output value to the lower limit.\n\t\tif err := txInputs.tryAddWalletInputsIfNeeded(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// If the output value of this block of inputs does not reach\n\t\t// the dust limit, stop sweeping. Because of the sorting,\n\t\t// continuing with the remaining inputs will only lead to sets\n\t\t// with an even lower output value.\n\t\tif !txInputs.enoughInput() {\n\t\t\t// The change output is always a p2tr here.\n\t\t\tdl := lnwallet.DustLimitForSize(input.P2TRSize)\n\t\t\tlog.Debugf(\"Set value %v (r=%v, c=%v) below dust \"+\n\t\t\t\t\"limit of %v\", txInputs.totalOutput(),\n\t\t\t\ttxInputs.requiredOutput, txInputs.changeOutput,\n\t\t\t\tdl)\n\t\t\treturn sets, nil\n\t\t}\n\n\t\tlog.Infof(\"Candidate sweep set of size=%v (+%v wallet inputs), \"+\n\t\t\t\"has yield=%v, weight=%v\",\n\t\t\tinputCount, len(txInputs.inputs)-inputCount,\n\t\t\ttxInputs.totalOutput()-txInputs.walletInputTotal,\n\t\t\ttxInputs.weightEstimate(true).weight())\n\n\t\tsets = append(sets, txInputs.inputs)\n\t\tsweepableInputs = sweepableInputs[inputCount:]\n\t}\n\n\treturn sets, nil\n}\n\n// createSweepTx builds a signed tx spending the inputs to the given outputs,\n// sending any leftover change to the change script.",
      "length": 3540,
      "tokens": 515,
      "embedding": []
    },
    {
      "slug": "func createSweepTx(inputs []input.Input, outputs []*wire.TxOut,",
      "content": "func createSweepTx(inputs []input.Input, outputs []*wire.TxOut,\n\tchangePkScript []byte, currentBlockHeight uint32,\n\tfeePerKw chainfee.SatPerKWeight, signer input.Signer) (*wire.MsgTx,\n\terror) {\n\n\tinputs, estimator, err := getWeightEstimate(\n\t\tinputs, outputs, feePerKw, changePkScript,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ttxFee := estimator.fee()\n\n\tvar (\n\t\t// Create the sweep transaction that we will be building. We\n\t\t// use version 2 as it is required for CSV.\n\t\tsweepTx = wire.NewMsgTx(2)\n\n\t\t// Track whether any of the inputs require a certain locktime.\n\t\tlocktime = int32(-1)\n\n\t\t// We keep track of total input amount, and required output\n\t\t// amount to use for calculating the change amount below.\n\t\ttotalInput     btcutil.Amount\n\t\trequiredOutput btcutil.Amount\n\n\t\t// We'll add the inputs as we go so we know the final ordering\n\t\t// of inputs to sign.\n\t\tidxs []input.Input\n\t)\n\n\t// We start by adding all inputs that commit to an output. We do this\n\t// since the input and output index must stay the same for the\n\t// signatures to be valid.\n\tfor _, o := range inputs {\n\t\tif o.RequiredTxOut() == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tidxs = append(idxs, o)\n\t\tsweepTx.AddTxIn(&wire.TxIn{\n\t\t\tPreviousOutPoint: *o.OutPoint(),\n\t\t\tSequence:         o.BlocksToMaturity(),\n\t\t})\n\t\tsweepTx.AddTxOut(o.RequiredTxOut())\n\n\t\tif lt, ok := o.RequiredLockTime(); ok {\n\t\t\t// If another input commits to a different locktime,\n\t\t\t// they cannot be combined in the same transcation.\n\t\t\tif locktime != -1 && locktime != int32(lt) {\n\t\t\t\treturn nil, fmt.Errorf(\"incompatible locktime\")\n\t\t\t}\n\n\t\t\tlocktime = int32(lt)\n\t\t}\n\n\t\ttotalInput += btcutil.Amount(o.SignDesc().Output.Value)\n\t\trequiredOutput += btcutil.Amount(o.RequiredTxOut().Value)\n\t}\n\n\t// Sum up the value contained in the remaining inputs, and add them to\n\t// the sweep transaction.\n\tfor _, o := range inputs {\n\t\tif o.RequiredTxOut() != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tidxs = append(idxs, o)\n\t\tsweepTx.AddTxIn(&wire.TxIn{\n\t\t\tPreviousOutPoint: *o.OutPoint(),\n\t\t\tSequence:         o.BlocksToMaturity(),\n\t\t})\n\n\t\tif lt, ok := o.RequiredLockTime(); ok {\n\t\t\tif locktime != -1 && locktime != int32(lt) {\n\t\t\t\treturn nil, fmt.Errorf(\"incompatible locktime\")\n\t\t\t}\n\n\t\t\tlocktime = int32(lt)\n\t\t}\n\n\t\ttotalInput += btcutil.Amount(o.SignDesc().Output.Value)\n\t}\n\n\t// Add the outputs given, if any.\n\tfor _, o := range outputs {\n\t\tsweepTx.AddTxOut(o)\n\t\trequiredOutput += btcutil.Amount(o.Value)\n\t}\n\n\tif requiredOutput+txFee > totalInput {\n\t\treturn nil, fmt.Errorf(\"insufficient input to create sweep \"+\n\t\t\t\"tx: input_sum=%v, output_sum=%v\", totalInput,\n\t\t\trequiredOutput+txFee)\n\t}\n\n\t// The value remaining after the required output and fees, go to\n\t// change. Not that this fee is what we would have to pay in case the\n\t// sweep tx has a change output.\n\tchangeAmt := totalInput - requiredOutput - txFee\n\n\t// We'll calculate the dust limit for the given changePkScript since it\n\t// is variable.\n\tchangeLimit := lnwallet.DustLimitForSize(len(changePkScript))\n\n\t// The txn will sweep the amount after fees to the pkscript generated\n\t// above.\n\tif changeAmt >= changeLimit {\n\t\tsweepTx.AddTxOut(&wire.TxOut{\n\t\t\tPkScript: changePkScript,\n\t\t\tValue:    int64(changeAmt),\n\t\t})\n\t} else {\n\t\tlog.Infof(\"Change amt %v below dustlimit %v, not adding \"+\n\t\t\t\"change output\", changeAmt, changeLimit)\n\t}\n\n\t// We'll default to using the current block height as locktime, if none\n\t// of the inputs commits to a different locktime.\n\tsweepTx.LockTime = currentBlockHeight\n\tif locktime != -1 {\n\t\tsweepTx.LockTime = uint32(locktime)\n\t}\n\n\t// Before signing the transaction, check to ensure that it meets some\n\t// basic validity requirements.\n\t//\n\t// TODO(conner): add more control to sanity checks, allowing us to\n\t// delay spending \"problem\" outputs, e.g. possibly batching with other\n\t// classes if fees are too low.\n\tbtx := btcutil.NewTx(sweepTx)\n\tif err := blockchain.CheckTransactionSanity(btx); err != nil {\n\t\treturn nil, err\n\t}\n\n\tprevInputFetcher, err := input.MultiPrevOutFetcher(inputs)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error creating prev input fetcher \"+\n\t\t\t\"for hash cache: %v\", err)\n\t}\n\thashCache := txscript.NewTxSigHashes(sweepTx, prevInputFetcher)\n\n\t// With all the inputs in place, use each output's unique input script\n\t// function to generate the final witness required for spending.\n\taddInputScript := func(idx int, tso input.Input) error {\n\t\tinputScript, err := tso.CraftInputScript(\n\t\t\tsigner, sweepTx, hashCache, prevInputFetcher, idx,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tsweepTx.TxIn[idx].Witness = inputScript.Witness\n\n\t\tif len(inputScript.SigScript) != 0 {\n\t\t\tsweepTx.TxIn[idx].SignatureScript = inputScript.SigScript\n\t\t}\n\n\t\treturn nil\n\t}\n\n\tfor idx, inp := range idxs {\n\t\tif err := addInputScript(idx, inp); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tlog.Infof(\"Creating sweep transaction %v for %v inputs (%s) \"+\n\t\t\"using %v sat/kw, tx_weight=%v, tx_fee=%v, parents_count=%v, \"+\n\t\t\"parents_fee=%v, parents_weight=%v\",\n\t\tsweepTx.TxHash(), len(inputs),\n\t\tinputTypeSummary(inputs), int64(feePerKw),\n\t\testimator.weight(), txFee,\n\t\tlen(estimator.parents), estimator.parentsFee,\n\t\testimator.parentsWeight,\n\t)\n\n\treturn sweepTx, nil\n}\n\n// getWeightEstimate returns a weight estimate for the given inputs.\n// Additionally, it returns counts for the number of csv and cltv inputs.",
      "length": 5051,
      "tokens": 701,
      "embedding": []
    },
    {
      "slug": "func getWeightEstimate(inputs []input.Input, outputs []*wire.TxOut,",
      "content": "func getWeightEstimate(inputs []input.Input, outputs []*wire.TxOut,\n\tfeeRate chainfee.SatPerKWeight, outputPkScript []byte) ([]input.Input,\n\t*weightEstimator, error) {\n\n\t// We initialize a weight estimator so we can accurately asses the\n\t// amount of fees we need to pay for this sweep transaction.\n\t//\n\t// TODO(roasbeef): can be more intelligent about buffering outputs to\n\t// be more efficient on-chain.\n\tweightEstimate := newWeightEstimator(feeRate)\n\n\t// Our sweep transaction will always pay to the given set of outputs.\n\tfor _, o := range outputs {\n\t\tweightEstimate.addOutput(o)\n\t}\n\n\t// If there is any leftover change after paying to the given outputs\n\t// and required outputs, it will go to a single segwit p2wkh or p2tr\n\t// address. This will be our change address, so ensure it contributes to\n\t// our weight estimate. Note that if we have other outputs, we might end\n\t// up creating a sweep tx without a change output. It is okay to add the\n\t// change output to the weight estimate regardless, since the estimated\n\t// fee will just be subtracted from this already dust output, and\n\t// trimmed.\n\tswitch {\n\tcase txscript.IsPayToTaproot(outputPkScript):\n\t\tweightEstimate.addP2TROutput()\n\n\tcase txscript.IsPayToWitnessScriptHash(outputPkScript):\n\t\tweightEstimate.addP2WSHOutput()\n\n\tcase txscript.IsPayToWitnessPubKeyHash(outputPkScript):\n\t\tweightEstimate.addP2WKHOutput()\n\n\tcase txscript.IsPayToPubKeyHash(outputPkScript):\n\t\tweightEstimate.estimator.AddP2PKHOutput()\n\n\tcase txscript.IsPayToScriptHash(outputPkScript):\n\t\tweightEstimate.estimator.AddP2SHOutput()\n\n\tdefault:\n\t\t// Unknown script type.\n\t\treturn nil, nil, errors.New(\"unknown script type\")\n\t}\n\n\t// For each output, use its witness type to determine the estimate\n\t// weight of its witness, and add it to the proper set of spendable\n\t// outputs.\n\tvar sweepInputs []input.Input\n\tfor i := range inputs {\n\t\tinp := inputs[i]\n\n\t\terr := weightEstimate.add(inp)\n\t\tif err != nil {\n\t\t\tlog.Warn(err)\n\n\t\t\t// Skip inputs for which no weight estimate can be\n\t\t\t// given.\n\t\t\tcontinue\n\t\t}\n\n\t\t// If this input comes with a committed output, add that as\n\t\t// well.\n\t\tif inp.RequiredTxOut() != nil {\n\t\t\tweightEstimate.addOutput(inp.RequiredTxOut())\n\t\t}\n\n\t\tsweepInputs = append(sweepInputs, inp)\n\t}\n\n\treturn sweepInputs, weightEstimate, nil\n}\n\n// inputSummary returns a string containing a human readable summary about the\n// witness types of a list of inputs.",
      "length": 2264,
      "tokens": 311,
      "embedding": []
    },
    {
      "slug": "func inputTypeSummary(inputs []input.Input) string {",
      "content": "func inputTypeSummary(inputs []input.Input) string {\n\t// Sort inputs by witness type.\n\tsortedInputs := make([]input.Input, len(inputs))\n\tcopy(sortedInputs, inputs)\n\tsort.Slice(sortedInputs, func(i, j int) bool {\n\t\treturn sortedInputs[i].WitnessType().String() <\n\t\t\tsortedInputs[j].WitnessType().String()\n\t})\n\n\tvar parts []string\n\tfor _, i := range sortedInputs {\n\t\tpart := fmt.Sprintf(\"%v (%v)\",\n\t\t\t*i.OutPoint(), i.WitnessType())\n\n\t\tparts = append(parts, part)\n\t}\n\treturn strings.Join(parts, \", \")\n}\n",
      "length": 431,
      "tokens": 49,
      "embedding": []
    }
  ]
}