{
  "filepath": "../implementations/go/lnd/sweep/sweeper.go",
  "package": "sweep",
  "sections": [
    {
      "slug": "type Params struct {",
      "content": "type Params struct {\n\t// Fee is the fee preference of the client who requested the input to be\n\t// swept. If a confirmation target is specified, then we'll map it into\n\t// a fee rate whenever we attempt to cluster inputs for a sweep.\n\tFee FeePreference\n\n\t// Force indicates whether the input should be swept regardless of\n\t// whether it is economical to do so.\n\tForce bool\n\n\t// ExclusiveGroup is an identifier that, if set, prevents other inputs\n\t// with the same identifier from being batched together.\n\tExclusiveGroup *uint64\n}\n\n// ParamsUpdate contains a new set of parameters to update a pending sweep with.",
      "length": 576,
      "tokens": 101,
      "embedding": []
    },
    {
      "slug": "type ParamsUpdate struct {",
      "content": "type ParamsUpdate struct {\n\t// Fee is the fee preference of the client who requested the input to be\n\t// swept. If a confirmation target is specified, then we'll map it into\n\t// a fee rate whenever we attempt to cluster inputs for a sweep.\n\tFee FeePreference\n\n\t// Force indicates whether the input should be swept regardless of\n\t// whether it is economical to do so.\n\tForce bool\n}\n\n// String returns a human readable interpretation of the sweep parameters.",
      "length": 419,
      "tokens": 76,
      "embedding": []
    },
    {
      "slug": "func (p Params) String() string {",
      "content": "func (p Params) String() string {\n\treturn fmt.Sprintf(\"fee=%v, force=%v, exclusive_group=%v\",\n\t\tp.Fee, p.Force, p.ExclusiveGroup)\n}\n\n// pendingInput is created when an input reaches the main loop for the first\n// time. It wraps the input and tracks all relevant state that is needed for\n// sweeping.",
      "length": 259,
      "tokens": 39,
      "embedding": []
    },
    {
      "slug": "type pendingInput struct {",
      "content": "type pendingInput struct {\n\tinput.Input\n\n\t// listeners is a list of channels over which the final outcome of the\n\t// sweep needs to be broadcasted.\n\tlisteners []chan Result\n\n\t// ntfnRegCancel is populated with a function that cancels the chain\n\t// notifier spend registration.\n\tntfnRegCancel func()\n\n\t// minPublishHeight indicates the minimum block height at which this\n\t// input may be (re)published.\n\tminPublishHeight int32\n\n\t// publishAttempts records the number of attempts that have already been\n\t// made to sweep this tx.\n\tpublishAttempts int\n\n\t// params contains the parameters that control the sweeping process.\n\tparams Params\n\n\t// lastFeeRate is the most recent fee rate used for this input within a\n\t// transaction broadcast to the network.\n\tlastFeeRate chainfee.SatPerKWeight\n}\n\n// parameters returns the sweep parameters for this input.\n//\n// NOTE: Part of the txInput interface.",
      "length": 836,
      "tokens": 129,
      "embedding": []
    },
    {
      "slug": "func (p *pendingInput) parameters() Params {",
      "content": "func (p *pendingInput) parameters() Params {\n\treturn p.params\n}\n\n// pendingInputs is a type alias for a set of pending inputs.",
      "length": 78,
      "tokens": 15,
      "embedding": []
    },
    {
      "slug": "type pendingInputs = map[wire.OutPoint]*pendingInput",
      "content": "type pendingInputs = map[wire.OutPoint]*pendingInput\n\n// inputCluster is a helper struct to gather a set of pending inputs that should\n// be swept with the specified fee rate.",
      "length": 120,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "type inputCluster struct {",
      "content": "type inputCluster struct {\n\tlockTime     *uint32\n\tsweepFeeRate chainfee.SatPerKWeight\n\tinputs       pendingInputs\n}\n\n// pendingSweepsReq is an internal message we'll use to represent an external\n// caller's intent to retrieve all of the pending inputs the UtxoSweeper is\n// attempting to sweep.",
      "length": 260,
      "tokens": 36,
      "embedding": []
    },
    {
      "slug": "type pendingSweepsReq struct {",
      "content": "type pendingSweepsReq struct {\n\trespChan chan map[wire.OutPoint]*PendingInput\n\terrChan  chan error\n}\n\n// PendingInput contains information about an input that is currently being\n// swept by the UtxoSweeper.",
      "length": 170,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "type PendingInput struct {",
      "content": "type PendingInput struct {\n\t// OutPoint is the identify outpoint of the input being swept.\n\tOutPoint wire.OutPoint\n\n\t// WitnessType is the witness type of the input being swept.\n\tWitnessType input.WitnessType\n\n\t// Amount is the amount of the input being swept.\n\tAmount btcutil.Amount\n\n\t// LastFeeRate is the most recent fee rate used for the input being\n\t// swept within a transaction broadcast to the network.\n\tLastFeeRate chainfee.SatPerKWeight\n\n\t// BroadcastAttempts is the number of attempts we've made to sweept the\n\t// input.\n\tBroadcastAttempts int\n\n\t// NextBroadcastHeight is the next height of the chain at which we'll\n\t// attempt to broadcast a transaction sweeping the input.\n\tNextBroadcastHeight uint32\n\n\t// Params contains the sweep parameters for this pending request.\n\tParams Params\n}\n\n// updateReq is an internal message we'll use to represent an external caller's\n// intent to update the sweep parameters of a given input.",
      "length": 885,
      "tokens": 138,
      "embedding": []
    },
    {
      "slug": "type updateReq struct {",
      "content": "type updateReq struct {\n\tinput        wire.OutPoint\n\tparams       ParamsUpdate\n\tresponseChan chan *updateResp\n}\n\n// updateResp is an internal message we'll use to hand off the response of a\n// updateReq from the UtxoSweeper's main event loop back to the caller.",
      "length": 231,
      "tokens": 35,
      "embedding": []
    },
    {
      "slug": "type updateResp struct {",
      "content": "type updateResp struct {\n\tresultChan chan Result\n\terr        error\n}\n\n// UtxoSweeper is responsible for sweeping outputs back into the wallet",
      "length": 112,
      "tokens": 17,
      "embedding": []
    },
    {
      "slug": "type UtxoSweeper struct {",
      "content": "type UtxoSweeper struct {\n\tstarted uint32 // To be used atomically.\n\tstopped uint32 // To be used atomically.\n\n\tcfg *UtxoSweeperConfig\n\n\tnewInputs chan *sweepInputMessage\n\tspendChan chan *chainntnfs.SpendDetail\n\n\t// pendingSweepsReq is a channel that will be sent requests by external\n\t// callers in order to retrieve the set of pending inputs the\n\t// UtxoSweeper is attempting to sweep.\n\tpendingSweepsReqs chan *pendingSweepsReq\n\n\t// updateReqs is a channel that will be sent requests by external\n\t// callers who wish to bump the fee rate of a given input.\n\tupdateReqs chan *updateReq\n\n\t// pendingInputs is the total set of inputs the UtxoSweeper has been\n\t// requested to sweep.\n\tpendingInputs pendingInputs\n\n\t// timer is the channel that signals expiry of the sweep batch timer.\n\ttimer <-chan time.Time\n\n\ttestSpendChan chan wire.OutPoint\n\n\tcurrentOutputScript []byte\n\n\trelayFeeRate chainfee.SatPerKWeight\n\n\tquit chan struct{}\n\twg   sync.WaitGroup\n}\n\n// UtxoSweeperConfig contains dependencies of UtxoSweeper.",
      "length": 951,
      "tokens": 136,
      "embedding": []
    },
    {
      "slug": "type UtxoSweeperConfig struct {",
      "content": "type UtxoSweeperConfig struct {\n\t// GenSweepScript generates a P2WKH script belonging to the wallet where\n\t// funds can be swept.\n\tGenSweepScript func() ([]byte, error)\n\n\t// FeeEstimator is used when crafting sweep transactions to estimate\n\t// the necessary fee relative to the expected size of the sweep\n\t// transaction.\n\tFeeEstimator chainfee.Estimator\n\n\t// Wallet contains the wallet functions that sweeper requires.\n\tWallet Wallet\n\n\t// NewBatchTimer creates a channel that will be sent on when a certain\n\t// time window has passed. During this time window, new inputs can still\n\t// be added to the sweep tx that is about to be generated.\n\tNewBatchTimer func() <-chan time.Time\n\n\t// Notifier is an instance of a chain notifier we'll use to watch for\n\t// certain on-chain events.\n\tNotifier chainntnfs.ChainNotifier\n\n\t// Store stores the published sweeper txes.\n\tStore SweeperStore\n\n\t// Signer is used by the sweeper to generate valid witnesses at the\n\t// time the incubated outputs need to be spent.\n\tSigner input.Signer\n\n\t// MaxInputsPerTx specifies the default maximum number of inputs allowed\n\t// in a single sweep tx. If more need to be swept, multiple txes are\n\t// created and published.\n\tMaxInputsPerTx int\n\n\t// MaxSweepAttempts specifies the maximum number of times an input is\n\t// included in a publish attempt before giving up and returning an error\n\t// to the caller.\n\tMaxSweepAttempts int\n\n\t// NextAttemptDeltaFunc returns given the number of already attempted\n\t// sweeps, how many blocks to wait before retrying to sweep.\n\tNextAttemptDeltaFunc func(int) int32\n\n\t// MaxFeeRate is the the maximum fee rate allowed within the\n\t// UtxoSweeper.\n\tMaxFeeRate chainfee.SatPerKWeight\n\n\t// FeeRateBucketSize is the default size of fee rate buckets we'll use\n\t// when clustering inputs into buckets with similar fee rates within the\n\t// UtxoSweeper.\n\t//\n\t// Given a minimum relay fee rate of 1 sat/vbyte, a fee rate bucket size\n\t// of 10 would result in the following fee rate buckets up to the\n\t// maximum fee rate:\n\t//\n\t//   #1: min = 1 sat/vbyte, max (exclusive) = 11 sat/vbyte\n\t//   #2: min = 11 sat/vbyte, max (exclusive) = 21 sat/vbyte...\n\tFeeRateBucketSize int\n}\n\n// Result is the struct that is pushed through the result channel. Callers can\n// use this to be informed of the final sweep result. In case of a remote\n// spend, Err will be ErrRemoteSpend.",
      "length": 2271,
      "tokens": 374,
      "embedding": []
    },
    {
      "slug": "type Result struct {",
      "content": "type Result struct {\n\t// Err is the final result of the sweep. It is nil when the input is\n\t// swept successfully by us. ErrRemoteSpend is returned when another\n\t// party took the input.\n\tErr error\n\n\t// Tx is the transaction that spent the input.\n\tTx *wire.MsgTx\n}\n\n// sweepInputMessage structs are used in the internal channel between the\n// SweepInput call and the sweeper main loop.",
      "length": 354,
      "tokens": 64,
      "embedding": []
    },
    {
      "slug": "type sweepInputMessage struct {",
      "content": "type sweepInputMessage struct {\n\tinput      input.Input\n\tparams     Params\n\tresultChan chan Result\n}\n\n// New returns a new Sweeper instance.",
      "length": 103,
      "tokens": 15,
      "embedding": []
    },
    {
      "slug": "func New(cfg *UtxoSweeperConfig) *UtxoSweeper {",
      "content": "func New(cfg *UtxoSweeperConfig) *UtxoSweeper {\n\treturn &UtxoSweeper{\n\t\tcfg:               cfg,\n\t\tnewInputs:         make(chan *sweepInputMessage),\n\t\tspendChan:         make(chan *chainntnfs.SpendDetail),\n\t\tupdateReqs:        make(chan *updateReq),\n\t\tpendingSweepsReqs: make(chan *pendingSweepsReq),\n\t\tquit:              make(chan struct{}),\n\t\tpendingInputs:     make(pendingInputs),\n\t}\n}\n\n// Start starts the process of constructing and publish sweep txes.",
      "length": 398,
      "tokens": 34,
      "embedding": []
    },
    {
      "slug": "func (s *UtxoSweeper) Start() error {",
      "content": "func (s *UtxoSweeper) Start() error {\n\tif !atomic.CompareAndSwapUint32(&s.started, 0, 1) {\n\t\treturn nil\n\t}\n\n\tlog.Info(\"Sweeper starting\")\n\n\t// Retrieve last published tx from database.\n\tlastTx, err := s.cfg.Store.GetLastPublishedTx()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"get last published tx: %v\", err)\n\t}\n\n\t// Republish in case the previous call crashed lnd. We don't care about\n\t// the return value, because inputs will be re-offered and retried\n\t// anyway. The only reason we republish here is to prevent the corner\n\t// case where lnd goes into a restart loop because of a crashing publish\n\t// tx where we keep deriving new output script. By publishing and\n\t// possibly crashing already now, we haven't derived a new output script\n\t// yet.\n\tif lastTx != nil {\n\t\tlog.Debugf(\"Publishing last tx %v\", lastTx.TxHash())\n\n\t\t// Error can be ignored. Because we are starting up, there are\n\t\t// no pending inputs to update based on the publish result.\n\t\terr := s.cfg.Wallet.PublishTransaction(lastTx, \"\")\n\t\tif err != nil && err != lnwallet.ErrDoubleSpend {\n\t\t\tlog.Errorf(\"last tx publish: %v\", err)\n\t\t}\n\t}\n\n\t// Retrieve relay fee for dust limit calculation. Assume that this will\n\t// not change from here on.\n\ts.relayFeeRate = s.cfg.FeeEstimator.RelayFeePerKW()\n\n\t// We need to register for block epochs and retry sweeping every block.\n\t// We should get a notification with the current best block immediately\n\t// if we don't provide any epoch. We'll wait for that in the collector.\n\tblockEpochs, err := s.cfg.Notifier.RegisterBlockEpochNtfn(nil)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"register block epoch ntfn: %v\", err)\n\t}\n\n\t// Start sweeper main loop.\n\ts.wg.Add(1)\n\tgo func() {\n\t\tdefer blockEpochs.Cancel()\n\t\tdefer s.wg.Done()\n\n\t\ts.collector(blockEpochs.Epochs)\n\n\t\t// The collector exited and won't longer handle incoming\n\t\t// requests. This can happen on shutdown, when the block\n\t\t// notifier shuts down before the sweeper and its clients. In\n\t\t// order to not deadlock the clients waiting for their requests\n\t\t// being handled, we handle them here and immediately return an\n\t\t// error. When the sweeper finally is shut down we can exit as\n\t\t// the clients will be notified.\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase inp := <-s.newInputs:\n\t\t\t\tinp.resultChan <- Result{\n\t\t\t\t\tErr: ErrSweeperShuttingDown,\n\t\t\t\t}\n\n\t\t\tcase req := <-s.pendingSweepsReqs:\n\t\t\t\treq.errChan <- ErrSweeperShuttingDown\n\n\t\t\tcase req := <-s.updateReqs:\n\t\t\t\treq.responseChan <- &updateResp{\n\t\t\t\t\terr: ErrSweeperShuttingDown,\n\t\t\t\t}\n\n\t\t\tcase <-s.quit:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}\n\n// RelayFeePerKW returns the minimum fee rate required for transactions to be\n// relayed.",
      "length": 2514,
      "tokens": 380,
      "embedding": []
    },
    {
      "slug": "func (s *UtxoSweeper) RelayFeePerKW() chainfee.SatPerKWeight {",
      "content": "func (s *UtxoSweeper) RelayFeePerKW() chainfee.SatPerKWeight {\n\treturn s.relayFeeRate\n}\n\n// Stop stops sweeper from listening to block epochs and constructing sweep\n// txes.",
      "length": 106,
      "tokens": 17,
      "embedding": []
    },
    {
      "slug": "func (s *UtxoSweeper) Stop() error {",
      "content": "func (s *UtxoSweeper) Stop() error {\n\tif !atomic.CompareAndSwapUint32(&s.stopped, 0, 1) {\n\t\treturn nil\n\t}\n\n\tlog.Info(\"Sweeper shutting down\")\n\n\tclose(s.quit)\n\ts.wg.Wait()\n\n\tlog.Debugf(\"Sweeper shut down\")\n\n\treturn nil\n}\n\n// SweepInput sweeps inputs back into the wallet. The inputs will be batched and\n// swept after the batch time window ends. A custom fee preference can be\n// provided to determine what fee rate should be used for the input. Note that\n// the input may not always be swept with this exact value, as its possible for\n// it to be batched under the same transaction with other similar fee rate\n// inputs.\n//\n// NOTE: Extreme care needs to be taken that input isn't changed externally.\n// Because it is an interface and we don't know what is exactly behind it, we\n// cannot make a local copy in sweeper.",
      "length": 758,
      "tokens": 132,
      "embedding": []
    },
    {
      "slug": "func (s *UtxoSweeper) SweepInput(input input.Input,",
      "content": "func (s *UtxoSweeper) SweepInput(input input.Input,\n\tparams Params) (chan Result, error) {\n\n\tif input == nil || input.OutPoint() == nil || input.SignDesc() == nil {\n\t\treturn nil, errors.New(\"nil input received\")\n\t}\n\n\t// Ensure the client provided a sane fee preference.\n\tif _, err := s.feeRateForPreference(params.Fee); err != nil {\n\t\treturn nil, err\n\t}\n\n\tabsoluteTimeLock, _ := input.RequiredLockTime()\n\tlog.Infof(\"Sweep request received: out_point=%v, witness_type=%v, \"+\n\t\t\"relative_time_lock=%v, absolute_time_lock=%v, amount=%v, \"+\n\t\t\"params=(%v)\", input.OutPoint(), input.WitnessType(),\n\t\tinput.BlocksToMaturity(), absoluteTimeLock,\n\t\tbtcutil.Amount(input.SignDesc().Output.Value), params)\n\n\tsweeperInput := &sweepInputMessage{\n\t\tinput:      input,\n\t\tparams:     params,\n\t\tresultChan: make(chan Result, 1),\n\t}\n\n\t// Deliver input to the main event loop.\n\tselect {\n\tcase s.newInputs <- sweeperInput:\n\tcase <-s.quit:\n\t\treturn nil, ErrSweeperShuttingDown\n\t}\n\n\treturn sweeperInput.resultChan, nil\n}\n\n// feeRateForPreference returns a fee rate for the given fee preference. It\n// ensures that the fee rate respects the bounds of the UtxoSweeper.",
      "length": 1058,
      "tokens": 128,
      "embedding": []
    },
    {
      "slug": "func (s *UtxoSweeper) feeRateForPreference(",
      "content": "func (s *UtxoSweeper) feeRateForPreference(\n\tfeePreference FeePreference) (chainfee.SatPerKWeight, error) {\n\n\t// Ensure a type of fee preference is specified to prevent using a\n\t// default below.\n\tif feePreference.FeeRate == 0 && feePreference.ConfTarget == 0 {\n\t\treturn 0, ErrNoFeePreference\n\t}\n\n\tfeeRate, err := DetermineFeePerKw(s.cfg.FeeEstimator, feePreference)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif feeRate < s.relayFeeRate {\n\t\treturn 0, fmt.Errorf(\"fee preference resulted in invalid fee \"+\n\t\t\t\"rate %v, minimum is %v\", feeRate, s.relayFeeRate)\n\t}\n\tif feeRate > s.cfg.MaxFeeRate {\n\t\treturn 0, fmt.Errorf(\"fee preference resulted in invalid fee \"+\n\t\t\t\"rate %v, maximum is %v\", feeRate, s.cfg.MaxFeeRate)\n\t}\n\n\treturn feeRate, nil\n}\n\n// removeLastSweepDescendants removes any transactions from the wallet that\n// spend outputs produced by the passed spendingTx. This needs to be done in\n// cases where we're not the only ones that can sweep an output, but there may\n// exist unconfirmed spends that spend outputs created by a sweep transaction.\n// The most common case for this is when someone sweeps our anchor outputs\n// after 16 blocks.",
      "length": 1072,
      "tokens": 165,
      "embedding": []
    },
    {
      "slug": "func (s *UtxoSweeper) removeLastSweepDescendants(spendingTx *wire.MsgTx) error {",
      "content": "func (s *UtxoSweeper) removeLastSweepDescendants(spendingTx *wire.MsgTx) error {\n\t// Obtain all the past sweeps that we've done so far. We'll need these\n\t// to ensure that if the spendingTx spends any of the same inputs, then\n\t// we remove any transaction that may be spending those inputs from the\n\t// wallet.\n\t//\n\t// TODO(roasbeef): can be last sweep here if we remove anything confirmed\n\t// from the store?\n\tpastSweepHashes, err := s.cfg.Store.ListSweeps()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlog.Debugf(\"Attempting to remove descendant txns invalidated by \"+\n\t\t\"(txid=%v): %v\", spendingTx.TxHash(), spew.Sdump(spendingTx))\n\n\t// Construct a map of the inputs this transaction spends for each look\n\t// up.\n\tinputsSpent := make(map[wire.OutPoint]struct{}, len(spendingTx.TxIn))\n\tfor _, txIn := range spendingTx.TxIn {\n\t\tinputsSpent[txIn.PreviousOutPoint] = struct{}{}\n\t}\n\n\t// We'll now go through each past transaction we published during this\n\t// epoch and cross reference the spent inputs. If there're any inputs\n\t// in common with the inputs the spendingTx spent, then we'll remove\n\t// those.\n\t//\n\t// TODO(roasbeef): need to start to remove all transaction hashes after\n\t// every N blocks (assumed point of no return)\n\tfor _, sweepHash := range pastSweepHashes {\n\t\tsweepTx, err := s.cfg.Wallet.FetchTx(sweepHash)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Transaction wasn't found in the wallet, may have already\n\t\t// been replaced/removed.\n\t\tif sweepTx == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Check to see if this past sweep transaction spent any of the\n\t\t// same inputs as spendingTx.\n\t\tvar isConflicting bool\n\t\tfor _, txIn := range sweepTx.TxIn {\n\t\t\tif _, ok := inputsSpent[txIn.PreviousOutPoint]; ok {\n\t\t\t\tisConflicting = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// If it did, then we'll signal the wallet to remove all the\n\t\t// transactions that are descendants of outputs created by the\n\t\t// sweepTx.\n\t\tif isConflicting {\n\t\t\tlog.Debugf(\"Removing sweep txid=%v from wallet: %v\",\n\t\t\t\tsweepTx.TxHash(), spew.Sdump(sweepTx))\n\n\t\t\terr := s.cfg.Wallet.RemoveDescendants(sweepTx)\n\t\t\tif err != nil {\n\t\t\t\tlog.Warnf(\"unable to remove descendants: %v\", err)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// collector is the sweeper main loop. It processes new inputs, spend\n// notifications and counts down to publication of the sweep tx.",
      "length": 2143,
      "tokens": 332,
      "embedding": []
    },
    {
      "slug": "func (s *UtxoSweeper) collector(blockEpochs <-chan *chainntnfs.BlockEpoch) {",
      "content": "func (s *UtxoSweeper) collector(blockEpochs <-chan *chainntnfs.BlockEpoch) {\n\t// We registered for the block epochs with a nil request. The notifier\n\t// should send us the current best block immediately. So we need to wait\n\t// for it here because we need to know the current best height.\n\tvar bestHeight int32\n\tselect {\n\tcase bestBlock := <-blockEpochs:\n\t\tbestHeight = bestBlock.Height\n\n\tcase <-s.quit:\n\t\treturn\n\t}\n\n\tfor {\n\t\tselect {\n\t\t// A new inputs is offered to the sweeper. We check to see if we\n\t\t// are already trying to sweep this input and if not, set up a\n\t\t// listener to spend and schedule a sweep.\n\t\tcase input := <-s.newInputs:\n\t\t\toutpoint := *input.input.OutPoint()\n\t\t\tpendInput, pending := s.pendingInputs[outpoint]\n\t\t\tif pending {\n\t\t\t\tlog.Debugf(\"Already pending input %v received\",\n\t\t\t\t\toutpoint)\n\n\t\t\t\t// Before updating the input details, check if\n\t\t\t\t// an exclusive group was set, and if so, assume\n\t\t\t\t// this input as finalized and remove all other\n\t\t\t\t// inputs belonging to the same exclusive group.\n\t\t\t\tvar prevExclGroup *uint64\n\t\t\t\tif pendInput.params.ExclusiveGroup != nil &&\n\t\t\t\t\tinput.params.ExclusiveGroup == nil {\n\n\t\t\t\t\tprevExclGroup = new(uint64)\n\t\t\t\t\t*prevExclGroup = *pendInput.params.ExclusiveGroup\n\t\t\t\t}\n\n\t\t\t\t// Update input details and sweep parameters.\n\t\t\t\t// The re-offered input details may contain a\n\t\t\t\t// change to the unconfirmed parent tx info.\n\t\t\t\tpendInput.params = input.params\n\t\t\t\tpendInput.Input = input.input\n\n\t\t\t\t// Add additional result channel to signal\n\t\t\t\t// spend of this input.\n\t\t\t\tpendInput.listeners = append(\n\t\t\t\t\tpendInput.listeners, input.resultChan,\n\t\t\t\t)\n\n\t\t\t\tif prevExclGroup != nil {\n\t\t\t\t\ts.removeExclusiveGroup(*prevExclGroup)\n\t\t\t\t}\n\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Create a new pendingInput and initialize the\n\t\t\t// listeners slice with the passed in result channel. If\n\t\t\t// this input is offered for sweep again, the result\n\t\t\t// channel will be appended to this slice.\n\t\t\tpendInput = &pendingInput{\n\t\t\t\tlisteners:        []chan Result{input.resultChan},\n\t\t\t\tInput:            input.input,\n\t\t\t\tminPublishHeight: bestHeight,\n\t\t\t\tparams:           input.params,\n\t\t\t}\n\t\t\ts.pendingInputs[outpoint] = pendInput\n\t\t\tlog.Tracef(\"input %v added to pendingInputs\", outpoint)\n\n\t\t\t// Start watching for spend of this input, either by us\n\t\t\t// or the remote party.\n\t\t\tcancel, err := s.waitForSpend(\n\t\t\t\toutpoint,\n\t\t\t\tinput.input.SignDesc().Output.PkScript,\n\t\t\t\tinput.input.HeightHint(),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\terr := fmt.Errorf(\"wait for spend: %v\", err)\n\t\t\t\ts.signalAndRemove(&outpoint, Result{Err: err})\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tpendInput.ntfnRegCancel = cancel\n\n\t\t\t// Check to see if with this new input a sweep tx can be\n\t\t\t// formed.\n\t\t\tif err := s.scheduleSweep(bestHeight); err != nil {\n\t\t\t\tlog.Errorf(\"schedule sweep: %v\", err)\n\t\t\t}\n\t\t\tlog.Tracef(\"input %v scheduled\", outpoint)\n\n\t\t// A spend of one of our inputs is detected. Signal sweep\n\t\t// results to the caller(s).\n\t\tcase spend := <-s.spendChan:\n\t\t\t// For testing purposes.\n\t\t\tif s.testSpendChan != nil {\n\t\t\t\ts.testSpendChan <- *spend.SpentOutPoint\n\t\t\t}\n\n\t\t\t// Query store to find out if we ever published this\n\t\t\t// tx.\n\t\t\tspendHash := *spend.SpenderTxHash\n\t\t\tisOurTx, err := s.cfg.Store.IsOurTx(spendHash)\n\t\t\tif err != nil {\n\t\t\t\tlog.Errorf(\"cannot determine if tx %v \"+\n\t\t\t\t\t\"is ours: %v\", spendHash, err,\n\t\t\t\t)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// If this isn't our transaction, it means someone else\n\t\t\t// swept outputs that we were attempting to sweep. This\n\t\t\t// can happen for anchor outputs as well as justice\n\t\t\t// transactions. In this case, we'll notify the wallet\n\t\t\t// to remove any spends that a descent from this\n\t\t\t// output.\n\t\t\tif !isOurTx {\n\t\t\t\terr := s.removeLastSweepDescendants(\n\t\t\t\t\tspend.SpendingTx,\n\t\t\t\t)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Warnf(\"unable to remove descendant \"+\n\t\t\t\t\t\t\"transactions due to tx %v: \",\n\t\t\t\t\t\tspendHash)\n\t\t\t\t}\n\n\t\t\t\tlog.Debugf(\"Detected spend related to in flight inputs \"+\n\t\t\t\t\t\"(is_ours=%v): %v\",\n\t\t\t\t\tnewLogClosure(func() string {\n\t\t\t\t\t\treturn spew.Sdump(spend.SpendingTx)\n\t\t\t\t\t}), isOurTx,\n\t\t\t\t)\n\t\t\t}\n\n\t\t\t// Signal sweep results for inputs in this confirmed\n\t\t\t// tx.\n\t\t\tfor _, txIn := range spend.SpendingTx.TxIn {\n\t\t\t\toutpoint := txIn.PreviousOutPoint\n\n\t\t\t\t// Check if this input is known to us. It could\n\t\t\t\t// probably be unknown if we canceled the\n\t\t\t\t// registration, deleted from pendingInputs but\n\t\t\t\t// the ntfn was in-flight already. Or this could\n\t\t\t\t// be not one of our inputs.\n\t\t\t\tinput, ok := s.pendingInputs[outpoint]\n\t\t\t\tif !ok {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\t// Return either a nil or a remote spend result.\n\t\t\t\tvar err error\n\t\t\t\tif !isOurTx {\n\t\t\t\t\terr = ErrRemoteSpend\n\t\t\t\t}\n\n\t\t\t\t// Signal result channels.\n\t\t\t\ts.signalAndRemove(&outpoint, Result{\n\t\t\t\t\tTx:  spend.SpendingTx,\n\t\t\t\t\tErr: err,\n\t\t\t\t})\n\n\t\t\t\t// Remove all other inputs in this exclusive\n\t\t\t\t// group.\n\t\t\t\tif input.params.ExclusiveGroup != nil {\n\t\t\t\t\ts.removeExclusiveGroup(\n\t\t\t\t\t\t*input.params.ExclusiveGroup,\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Now that an input of ours is spent, we can try to\n\t\t\t// resweep the remaining inputs.\n\t\t\tif err := s.scheduleSweep(bestHeight); err != nil {\n\t\t\t\tlog.Errorf(\"schedule sweep: %v\", err)\n\t\t\t}\n\n\t\t// A new external request has been received to retrieve all of\n\t\t// the inputs we're currently attempting to sweep.\n\t\tcase req := <-s.pendingSweepsReqs:\n\t\t\treq.respChan <- s.handlePendingSweepsReq(req)\n\n\t\t// A new external request has been received to bump the fee rate\n\t\t// of a given input.\n\t\tcase req := <-s.updateReqs:\n\t\t\tresultChan, err := s.handleUpdateReq(req, bestHeight)\n\t\t\treq.responseChan <- &updateResp{\n\t\t\t\tresultChan: resultChan,\n\t\t\t\terr:        err,\n\t\t\t}\n\n\t\t// The timer expires and we are going to (re)sweep.\n\t\tcase <-s.timer:\n\t\t\tlog.Debugf(\"Sweep timer expired\")\n\n\t\t\t// Set timer to nil so we know that a new timer needs to\n\t\t\t// be started when new inputs arrive.\n\t\t\ts.timer = nil\n\n\t\t\t// We'll attempt to cluster all of our inputs with\n\t\t\t// similar fee rates. Before attempting to sweep them,\n\t\t\t// we'll sort them in descending fee rate order. We do\n\t\t\t// this to ensure any inputs which have had their fee\n\t\t\t// rate bumped are broadcast first in order enforce the\n\t\t\t// RBF policy.\n\t\t\tinputClusters := s.createInputClusters()\n\t\t\tsort.Slice(inputClusters, func(i, j int) bool {\n\t\t\t\treturn inputClusters[i].sweepFeeRate >\n\t\t\t\t\tinputClusters[j].sweepFeeRate\n\t\t\t})\n\t\t\tfor _, cluster := range inputClusters {\n\t\t\t\terr := s.sweepCluster(cluster, bestHeight)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Errorf(\"input cluster sweep: %v\",\n\t\t\t\t\t\terr)\n\t\t\t\t}\n\t\t\t}\n\n\t\t// A new block comes in. Things may have changed, so we retry a\n\t\t// sweep.\n\t\tcase epoch, ok := <-blockEpochs:\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tbestHeight = epoch.Height\n\n\t\t\tlog.Debugf(\"New block: height=%v, sha=%v\",\n\t\t\t\tepoch.Height, epoch.Hash)\n\n\t\t\tif err := s.scheduleSweep(bestHeight); err != nil {\n\t\t\t\tlog.Errorf(\"schedule sweep: %v\", err)\n\t\t\t}\n\n\t\tcase <-s.quit:\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// removeExclusiveGroup removes all inputs in the given exclusive group. This\n// function is called when one of the exclusive group inputs has been spent. The\n// other inputs won't ever be spendable and can be removed. This also prevents\n// them from being part of future sweep transactions that would fail.",
      "length": 6893,
      "tokens": 982,
      "embedding": []
    },
    {
      "slug": "func (s *UtxoSweeper) removeExclusiveGroup(group uint64) {",
      "content": "func (s *UtxoSweeper) removeExclusiveGroup(group uint64) {\n\tfor outpoint, input := range s.pendingInputs {\n\t\toutpoint := outpoint\n\n\t\t// Skip inputs that aren't exclusive.\n\t\tif input.params.ExclusiveGroup == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Skip inputs from other exclusive groups.\n\t\tif *input.params.ExclusiveGroup != group {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Signal result channels.\n\t\ts.signalAndRemove(&outpoint, Result{\n\t\t\tErr: ErrExclusiveGroupSpend,\n\t\t})\n\t}\n}\n\n// sweepCluster tries to sweep the given input cluster.",
      "length": 425,
      "tokens": 57,
      "embedding": []
    },
    {
      "slug": "func (s *UtxoSweeper) sweepCluster(cluster inputCluster,",
      "content": "func (s *UtxoSweeper) sweepCluster(cluster inputCluster,\n\tcurrentHeight int32) error {\n\n\t// Execute the sweep within a coin select lock. Otherwise the coins that\n\t// we are going to spend may be selected for other transactions like\n\t// funding of a channel.\n\treturn s.cfg.Wallet.WithCoinSelectLock(func() error {\n\t\t// Examine pending inputs and try to construct\n\t\t// lists of inputs.\n\t\tinputLists, err := s.getInputLists(cluster, currentHeight)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to examine pending inputs: %v\", err)\n\t\t}\n\n\t\t// Sweep selected inputs.\n\t\tfor _, inputs := range inputLists {\n\t\t\terr := s.sweep(inputs, cluster.sweepFeeRate, currentHeight)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"unable to sweep inputs: %v\", err)\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t})\n}\n\n// bucketForFeeReate determines the proper bucket for a fee rate. This is done\n// in order to batch inputs with similar fee rates together.",
      "length": 825,
      "tokens": 128,
      "embedding": []
    },
    {
      "slug": "func (s *UtxoSweeper) bucketForFeeRate(",
      "content": "func (s *UtxoSweeper) bucketForFeeRate(\n\tfeeRate chainfee.SatPerKWeight) int {\n\n\t// Create an isolated bucket for sweeps at the minimum fee rate. This is\n\t// to prevent very small outputs (anchors) from becoming uneconomical if\n\t// their fee rate would be averaged with higher fee rate inputs in a\n\t// regular bucket.\n\tif feeRate == s.relayFeeRate {\n\t\treturn 0\n\t}\n\n\treturn 1 + int(feeRate-s.relayFeeRate)/s.cfg.FeeRateBucketSize\n}\n\n// createInputClusters creates a list of input clusters from the set of pending\n// inputs known by the UtxoSweeper. It clusters inputs by\n// 1) Required tx locktime\n// 2) Similar fee rates.",
      "length": 565,
      "tokens": 92,
      "embedding": []
    },
    {
      "slug": "func (s *UtxoSweeper) createInputClusters() []inputCluster {",
      "content": "func (s *UtxoSweeper) createInputClusters() []inputCluster {\n\tinputs := s.pendingInputs\n\n\t// We start by getting the inputs clusters by locktime. Since the\n\t// inputs commit to the locktime, they can only be clustered together\n\t// if the locktime is equal.\n\tlockTimeClusters, nonLockTimeInputs := s.clusterByLockTime(inputs)\n\n\t// Cluster the the remaining inputs by sweep fee rate.\n\tfeeClusters := s.clusterBySweepFeeRate(nonLockTimeInputs)\n\n\t// Since the inputs that we clustered by fee rate don't commit to a\n\t// specific locktime, we can try to merge a locktime cluster with a fee\n\t// cluster.\n\treturn zipClusters(lockTimeClusters, feeClusters)\n}\n\n// clusterByLockTime takes the given set of pending inputs and clusters those\n// with equal locktime together. Each cluster contains a sweep fee rate, which\n// is determined by calculating the average fee rate of all inputs within that\n// cluster. In addition to the created clusters, inputs that did not specify a\n// required lock time are returned.",
      "length": 920,
      "tokens": 143,
      "embedding": []
    },
    {
      "slug": "func (s *UtxoSweeper) clusterByLockTime(inputs pendingInputs) ([]inputCluster,",
      "content": "func (s *UtxoSweeper) clusterByLockTime(inputs pendingInputs) ([]inputCluster,\n\tpendingInputs) {\n\n\tlocktimes := make(map[uint32]pendingInputs)\n\tinputFeeRates := make(map[wire.OutPoint]chainfee.SatPerKWeight)\n\trem := make(pendingInputs)\n\n\t// Go through all inputs and check if they require a certain locktime.\n\tfor op, input := range inputs {\n\t\tlt, ok := input.RequiredLockTime()\n\t\tif !ok {\n\t\t\trem[op] = input\n\t\t\tcontinue\n\t\t}\n\n\t\t// Check if we already have inputs with this locktime.\n\t\tp, ok := locktimes[lt]\n\t\tif !ok {\n\t\t\tp = make(pendingInputs)\n\t\t}\n\n\t\tp[op] = input\n\t\tlocktimes[lt] = p\n\n\t\t// We also get the preferred fee rate for this input.\n\t\tfeeRate, err := s.feeRateForPreference(input.params.Fee)\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"Skipping input %v: %v\", op, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tinput.lastFeeRate = feeRate\n\t\tinputFeeRates[op] = feeRate\n\t}\n\n\t// We'll then determine the sweep fee rate for each set of inputs by\n\t// calculating the average fee rate of the inputs within each set.\n\tinputClusters := make([]inputCluster, 0, len(locktimes))\n\tfor lt, inputs := range locktimes {\n\t\tlt := lt\n\n\t\tvar sweepFeeRate chainfee.SatPerKWeight\n\t\tfor op := range inputs {\n\t\t\tsweepFeeRate += inputFeeRates[op]\n\t\t}\n\n\t\tsweepFeeRate /= chainfee.SatPerKWeight(len(inputs))\n\t\tinputClusters = append(inputClusters, inputCluster{\n\t\t\tlockTime:     &lt,\n\t\t\tsweepFeeRate: sweepFeeRate,\n\t\t\tinputs:       inputs,\n\t\t})\n\t}\n\n\treturn inputClusters, rem\n}\n\n// clusterBySweepFeeRate takes the set of pending inputs within the UtxoSweeper\n// and clusters those together with similar fee rates. Each cluster contains a\n// sweep fee rate, which is determined by calculating the average fee rate of\n// all inputs within that cluster.",
      "length": 1563,
      "tokens": 222,
      "embedding": []
    },
    {
      "slug": "func (s *UtxoSweeper) clusterBySweepFeeRate(inputs pendingInputs) []inputCluster {",
      "content": "func (s *UtxoSweeper) clusterBySweepFeeRate(inputs pendingInputs) []inputCluster {\n\tbucketInputs := make(map[int]*bucketList)\n\tinputFeeRates := make(map[wire.OutPoint]chainfee.SatPerKWeight)\n\n\t// First, we'll group together all inputs with similar fee rates. This\n\t// is done by determining the fee rate bucket they should belong in.\n\tfor op, input := range inputs {\n\t\tfeeRate, err := s.feeRateForPreference(input.params.Fee)\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"Skipping input %v: %v\", op, err)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Only try to sweep inputs with an unconfirmed parent if the\n\t\t// current sweep fee rate exceeds the parent tx fee rate. This\n\t\t// assumes that such inputs are offered to the sweeper solely\n\t\t// for the purpose of anchoring down the parent tx using cpfp.\n\t\tparentTx := input.UnconfParent()\n\t\tif parentTx != nil {\n\t\t\tparentFeeRate :=\n\t\t\t\tchainfee.SatPerKWeight(parentTx.Fee*1000) /\n\t\t\t\t\tchainfee.SatPerKWeight(parentTx.Weight)\n\n\t\t\tif parentFeeRate >= feeRate {\n\t\t\t\tlog.Debugf(\"Skipping cpfp input %v: fee_rate=%v, \"+\n\t\t\t\t\t\"parent_fee_rate=%v\", op, feeRate,\n\t\t\t\t\tparentFeeRate)\n\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tfeeGroup := s.bucketForFeeRate(feeRate)\n\n\t\t// Create a bucket list for this fee rate if there isn't one\n\t\t// yet.\n\t\tbuckets, ok := bucketInputs[feeGroup]\n\t\tif !ok {\n\t\t\tbuckets = &bucketList{}\n\t\t\tbucketInputs[feeGroup] = buckets\n\t\t}\n\n\t\t// Request the bucket list to add this input. The bucket list\n\t\t// will take into account exclusive group constraints.\n\t\tbuckets.add(input)\n\n\t\tinput.lastFeeRate = feeRate\n\t\tinputFeeRates[op] = feeRate\n\t}\n\n\t// We'll then determine the sweep fee rate for each set of inputs by\n\t// calculating the average fee rate of the inputs within each set.\n\tinputClusters := make([]inputCluster, 0, len(bucketInputs))\n\tfor _, buckets := range bucketInputs {\n\t\tfor _, inputs := range buckets.buckets {\n\t\t\tvar sweepFeeRate chainfee.SatPerKWeight\n\t\t\tfor op := range inputs {\n\t\t\t\tsweepFeeRate += inputFeeRates[op]\n\t\t\t}\n\t\t\tsweepFeeRate /= chainfee.SatPerKWeight(len(inputs))\n\t\t\tinputClusters = append(inputClusters, inputCluster{\n\t\t\t\tsweepFeeRate: sweepFeeRate,\n\t\t\t\tinputs:       inputs,\n\t\t\t})\n\t\t}\n\t}\n\n\treturn inputClusters\n}\n\n// zipClusters merges pairwise clusters from as and bs such that cluster a from\n// as is merged with a cluster from bs that has at least the fee rate of a.\n// This to ensure we don't delay confirmation by decreasing the fee rate (the\n// lock time inputs are typically second level HTLC transactions, that are time\n// sensitive).",
      "length": 2328,
      "tokens": 329,
      "embedding": []
    },
    {
      "slug": "func zipClusters(as, bs []inputCluster) []inputCluster {",
      "content": "func zipClusters(as, bs []inputCluster) []inputCluster {\n\t// Sort the clusters by decreasing fee rates.\n\tsort.Slice(as, func(i, j int) bool {\n\t\treturn as[i].sweepFeeRate >\n\t\t\tas[j].sweepFeeRate\n\t})\n\tsort.Slice(bs, func(i, j int) bool {\n\t\treturn bs[i].sweepFeeRate >\n\t\t\tbs[j].sweepFeeRate\n\t})\n\n\tvar (\n\t\tfinalClusters []inputCluster\n\t\tj             int\n\t)\n\n\t// Go through each cluster in as, and merge with the next one from bs\n\t// if it has at least the fee rate needed.\n\tfor i := range as {\n\t\ta := as[i]\n\n\t\tswitch {\n\t\t// If the fee rate for the next one from bs is at least a's, we\n\t\t// merge.\n\t\tcase j < len(bs) && bs[j].sweepFeeRate >= a.sweepFeeRate:\n\t\t\tmerged := mergeClusters(a, bs[j])\n\t\t\tfinalClusters = append(finalClusters, merged...)\n\n\t\t\t// Increment j for the next round.\n\t\t\tj++\n\n\t\t// We did not merge, meaning all the remaining clusters from bs\n\t\t// have lower fee rate. Instead we add a directly to the final\n\t\t// clusters.\n\t\tdefault:\n\t\t\tfinalClusters = append(finalClusters, a)\n\t\t}\n\t}\n\n\t// Add any remaining clusters from bs.\n\tfor ; j < len(bs); j++ {\n\t\tb := bs[j]\n\t\tfinalClusters = append(finalClusters, b)\n\t}\n\n\treturn finalClusters\n}\n\n// mergeClusters attempts to merge cluster a and b if they are compatible. The\n// new cluster will have the locktime set if a or b had a locktime set, and a\n// sweep fee rate that is the maximum of a and b's. If the two clusters are not\n// compatible, they will be returned unchanged.",
      "length": 1327,
      "tokens": 231,
      "embedding": []
    },
    {
      "slug": "func mergeClusters(a, b inputCluster) []inputCluster {",
      "content": "func mergeClusters(a, b inputCluster) []inputCluster {\n\tnewCluster := inputCluster{}\n\n\tswitch {\n\t// Incompatible locktimes, return the sets without merging them.\n\tcase a.lockTime != nil && b.lockTime != nil && *a.lockTime != *b.lockTime:\n\t\treturn []inputCluster{a, b}\n\n\tcase a.lockTime != nil:\n\t\tnewCluster.lockTime = a.lockTime\n\n\tcase b.lockTime != nil:\n\t\tnewCluster.lockTime = b.lockTime\n\t}\n\n\tif a.sweepFeeRate > b.sweepFeeRate {\n\t\tnewCluster.sweepFeeRate = a.sweepFeeRate\n\t} else {\n\t\tnewCluster.sweepFeeRate = b.sweepFeeRate\n\t}\n\n\tnewCluster.inputs = make(pendingInputs)\n\n\tfor op, in := range a.inputs {\n\t\tnewCluster.inputs[op] = in\n\t}\n\n\tfor op, in := range b.inputs {\n\t\tnewCluster.inputs[op] = in\n\t}\n\n\treturn []inputCluster{newCluster}\n}\n\n// scheduleSweep starts the sweep timer to create an opportunity for more inputs\n// to be added.",
      "length": 749,
      "tokens": 104,
      "embedding": []
    },
    {
      "slug": "func (s *UtxoSweeper) scheduleSweep(currentHeight int32) error {",
      "content": "func (s *UtxoSweeper) scheduleSweep(currentHeight int32) error {\n\t// The timer is already ticking, no action needed for the sweep to\n\t// happen.\n\tif s.timer != nil {\n\t\tlog.Debugf(\"Timer still ticking at height=%v\", currentHeight)\n\t\treturn nil\n\t}\n\n\t// We'll only start our timer once we have inputs we're able to sweep.\n\tstartTimer := false\n\tfor _, cluster := range s.createInputClusters() {\n\t\t// Examine pending inputs and try to construct lists of inputs.\n\t\t// We don't need to obtain the coin selection lock, because we\n\t\t// just need an indication as to whether we can sweep. More\n\t\t// inputs may be added until we publish the transaction and\n\t\t// coins that we select now may be used in other transactions.\n\t\tinputLists, err := s.getInputLists(cluster, currentHeight)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"get input lists: %v\", err)\n\t\t}\n\n\t\tlog.Infof(\"Sweep candidates at height=%v with fee_rate=%v, \"+\n\t\t\t\"yield %v distinct txns\", currentHeight,\n\t\t\tcluster.sweepFeeRate, len(inputLists))\n\n\t\tif len(inputLists) != 0 {\n\t\t\tstartTimer = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !startTimer {\n\t\treturn nil\n\t}\n\n\t// Start sweep timer to create opportunity for more inputs to be added\n\t// before a tx is constructed.\n\ts.timer = s.cfg.NewBatchTimer()\n\n\tlog.Debugf(\"Sweep timer started\")\n\n\treturn nil\n}\n\n// signalAndRemove notifies the listeners of the final result of the input\n// sweep. It cancels any pending spend notification and removes the input from\n// the list of pending inputs. When this function returns, the sweeper has\n// completely forgotten about the input.",
      "length": 1443,
      "tokens": 231,
      "embedding": []
    },
    {
      "slug": "func (s *UtxoSweeper) signalAndRemove(outpoint *wire.OutPoint, result Result) {",
      "content": "func (s *UtxoSweeper) signalAndRemove(outpoint *wire.OutPoint, result Result) {\n\tpendInput := s.pendingInputs[*outpoint]\n\tlisteners := pendInput.listeners\n\n\tif result.Err == nil {\n\t\tlog.Debugf(\"Dispatching sweep success for %v to %v listeners\",\n\t\t\toutpoint, len(listeners),\n\t\t)\n\t} else {\n\t\tlog.Debugf(\"Dispatching sweep error for %v to %v listeners: %v\",\n\t\t\toutpoint, len(listeners), result.Err,\n\t\t)\n\t}\n\n\t// Signal all listeners. Channel is buffered. Because we only send once\n\t// on every channel, it should never block.\n\tfor _, resultChan := range listeners {\n\t\tresultChan <- result\n\t}\n\n\t// Cancel spend notification with chain notifier. This is not necessary\n\t// in case of a success, except for that a reorg could still happen.\n\tif pendInput.ntfnRegCancel != nil {\n\t\tlog.Debugf(\"Canceling spend ntfn for %v\", outpoint)\n\n\t\tpendInput.ntfnRegCancel()\n\t}\n\n\t// Inputs are no longer pending after result has been sent.\n\tdelete(s.pendingInputs, *outpoint)\n}\n\n// getInputLists goes through the given inputs and constructs multiple distinct\n// sweep lists with the given fee rate, each up to the configured maximum number\n// of inputs. Negative yield inputs are skipped. Transactions with an output\n// below the dust limit are not published. Those inputs remain pending and will\n// be bundled with future inputs if possible.",
      "length": 1204,
      "tokens": 182,
      "embedding": []
    },
    {
      "slug": "func (s *UtxoSweeper) getInputLists(cluster inputCluster,",
      "content": "func (s *UtxoSweeper) getInputLists(cluster inputCluster,\n\tcurrentHeight int32) ([]inputSet, error) {\n\n\t// Filter for inputs that need to be swept. Create two lists: all\n\t// sweepable inputs and a list containing only the new, never tried\n\t// inputs.\n\t//\n\t// We want to create as large a tx as possible, so we return a final set\n\t// list that starts with sets created from all inputs. However, there is\n\t// a chance that those txes will not publish, because they already\n\t// contain inputs that failed before. Therefore we also add sets\n\t// consisting of only new inputs to the list, to make sure that new\n\t// inputs are given a good, isolated chance of being published.\n\tvar newInputs, retryInputs []txInput\n\tfor _, input := range cluster.inputs {\n\t\t// Skip inputs that have a minimum publish height that is not\n\t\t// yet reached.\n\t\tif input.minPublishHeight > currentHeight {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Add input to the either one of the lists.\n\t\tif input.publishAttempts == 0 {\n\t\t\tnewInputs = append(newInputs, input)\n\t\t} else {\n\t\t\tretryInputs = append(retryInputs, input)\n\t\t}\n\t}\n\n\t// If there is anything to retry, combine it with the new inputs and\n\t// form input sets.\n\tvar allSets []inputSet\n\tif len(retryInputs) > 0 {\n\t\tvar err error\n\t\tallSets, err = generateInputPartitionings(\n\t\t\tappend(retryInputs, newInputs...),\n\t\t\tcluster.sweepFeeRate, s.cfg.MaxInputsPerTx,\n\t\t\ts.cfg.Wallet,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"input partitionings: %v\", err)\n\t\t}\n\t}\n\n\t// Create sets for just the new inputs.\n\tnewSets, err := generateInputPartitionings(\n\t\tnewInputs, cluster.sweepFeeRate, s.cfg.MaxInputsPerTx,\n\t\ts.cfg.Wallet,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"input partitionings: %v\", err)\n\t}\n\n\tlog.Debugf(\"Sweep candidates at height=%v: total_num_pending=%v, \"+\n\t\t\"total_num_new=%v\", currentHeight, len(allSets), len(newSets))\n\n\t// Append the new sets at the end of the list, because those tx likely\n\t// have a higher fee per input.\n\treturn append(allSets, newSets...), nil\n}\n\n// sweep takes a set of preselected inputs, creates a sweep tx and publishes the\n// tx. The output address is only marked as used if the publish succeeds.",
      "length": 2030,
      "tokens": 319,
      "embedding": []
    },
    {
      "slug": "func (s *UtxoSweeper) sweep(inputs inputSet, feeRate chainfee.SatPerKWeight,",
      "content": "func (s *UtxoSweeper) sweep(inputs inputSet, feeRate chainfee.SatPerKWeight,\n\tcurrentHeight int32) error {\n\n\t// Generate an output script if there isn't an unused script available.\n\tif s.currentOutputScript == nil {\n\t\tpkScript, err := s.cfg.GenSweepScript()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"gen sweep script: %v\", err)\n\t\t}\n\t\ts.currentOutputScript = pkScript\n\t}\n\n\t// Create sweep tx.\n\ttx, err := createSweepTx(\n\t\tinputs, nil, s.currentOutputScript, uint32(currentHeight),\n\t\tfeeRate, s.cfg.Signer,\n\t)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"create sweep tx: %v\", err)\n\t}\n\n\t// Add tx before publication, so that we will always know that a spend\n\t// by this tx is ours. Otherwise if the publish doesn't return, but did\n\t// publish, we loose track of this tx. Even republication on startup\n\t// doesn't prevent this, because that call returns a double spend error\n\t// then and would also not add the hash to the store.\n\terr = s.cfg.Store.NotifyPublishTx(tx)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"notify publish tx: %v\", err)\n\t}\n\n\t// Publish sweep tx.\n\tlog.Debugf(\"Publishing sweep tx %v, num_inputs=%v, height=%v\",\n\t\ttx.TxHash(), len(tx.TxIn), currentHeight)\n\n\tlog.Tracef(\"Sweep tx at height=%v: %v\", currentHeight,\n\t\tnewLogClosure(func() string {\n\t\t\treturn spew.Sdump(tx)\n\t\t}),\n\t)\n\n\terr = s.cfg.Wallet.PublishTransaction(\n\t\ttx, labels.MakeLabel(labels.LabelTypeSweepTransaction, nil),\n\t)\n\n\t// In case of an unexpected error, don't try to recover.\n\tif err != nil && err != lnwallet.ErrDoubleSpend {\n\t\treturn fmt.Errorf(\"publish tx: %v\", err)\n\t}\n\n\t// Otherwise log the error.\n\tif err != nil {\n\t\tlog.Errorf(\"Publish sweep tx %v got error: %v\", tx.TxHash(),\n\t\t\terr)\n\t} else {\n\t\t// If there's no error, remove the output script. Otherwise\n\t\t// keep it so that it can be reused for the next transaction\n\t\t// and causes no address inflation.\n\t\ts.currentOutputScript = nil\n\t}\n\n\t// Reschedule sweep.\n\tfor _, input := range tx.TxIn {\n\t\tpi, ok := s.pendingInputs[input.PreviousOutPoint]\n\t\tif !ok {\n\t\t\t// It can be that the input has been removed because it\n\t\t\t// exceed the maximum number of attempts in a previous\n\t\t\t// input set. It could also be that this input is an\n\t\t\t// additional wallet input that was attached. In that\n\t\t\t// case there also isn't a pending input to update.\n\t\t\tcontinue\n\t\t}\n\n\t\t// Record another publish attempt.\n\t\tpi.publishAttempts++\n\n\t\t// We don't care what the result of the publish call was. Even\n\t\t// if it is published successfully, it can still be that it\n\t\t// needs to be retried. Call NextAttemptDeltaFunc to calculate\n\t\t// when to resweep this input.\n\t\tnextAttemptDelta := s.cfg.NextAttemptDeltaFunc(\n\t\t\tpi.publishAttempts,\n\t\t)\n\n\t\tpi.minPublishHeight = currentHeight + nextAttemptDelta\n\n\t\tlog.Debugf(\"Rescheduling input %v after %v attempts at \"+\n\t\t\t\"height %v (delta %v)\", input.PreviousOutPoint,\n\t\t\tpi.publishAttempts, pi.minPublishHeight,\n\t\t\tnextAttemptDelta)\n\n\t\tif pi.publishAttempts >= s.cfg.MaxSweepAttempts {\n\t\t\tlog.Warnf(\"input %v: publishAttempts(%v) exceeds \"+\n\t\t\t\t\"MaxSweepAttempts(%v), removed\",\n\t\t\t\tinput.PreviousOutPoint, pi.publishAttempts,\n\t\t\t\ts.cfg.MaxSweepAttempts)\n\n\t\t\t// Signal result channels sweep result.\n\t\t\ts.signalAndRemove(&input.PreviousOutPoint, Result{\n\t\t\t\tErr: ErrTooManyAttempts,\n\t\t\t})\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// waitForSpend registers a spend notification with the chain notifier. It\n// returns a cancel function that can be used to cancel the registration.",
      "length": 3228,
      "tokens": 460,
      "embedding": []
    },
    {
      "slug": "func (s *UtxoSweeper) waitForSpend(outpoint wire.OutPoint,",
      "content": "func (s *UtxoSweeper) waitForSpend(outpoint wire.OutPoint,\n\tscript []byte, heightHint uint32) (func(), error) {\n\n\tlog.Tracef(\"Wait for spend of %v at heightHint=%v\",\n\t\toutpoint, heightHint)\n\n\tspendEvent, err := s.cfg.Notifier.RegisterSpendNtfn(\n\t\t&outpoint, script, heightHint,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"register spend ntfn: %v\", err)\n\t}\n\n\ts.wg.Add(1)\n\tgo func() {\n\t\tdefer s.wg.Done()\n\n\t\tselect {\n\t\tcase spend, ok := <-spendEvent.Spend:\n\t\t\tif !ok {\n\t\t\t\tlog.Debugf(\"Spend ntfn for %v canceled\",\n\t\t\t\t\toutpoint)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tlog.Debugf(\"Delivering spend ntfn for %v\",\n\t\t\t\toutpoint)\n\t\t\tselect {\n\t\t\tcase s.spendChan <- spend:\n\t\t\t\tlog.Debugf(\"Delivered spend ntfn for %v\",\n\t\t\t\t\toutpoint)\n\n\t\t\tcase <-s.quit:\n\t\t\t}\n\t\tcase <-s.quit:\n\t\t}\n\t}()\n\n\treturn spendEvent.Cancel, nil\n}\n\n// PendingInputs returns the set of inputs that the UtxoSweeper is currently\n// attempting to sweep.",
      "length": 794,
      "tokens": 106,
      "embedding": []
    },
    {
      "slug": "func (s *UtxoSweeper) PendingInputs() (map[wire.OutPoint]*PendingInput, error) {",
      "content": "func (s *UtxoSweeper) PendingInputs() (map[wire.OutPoint]*PendingInput, error) {\n\trespChan := make(chan map[wire.OutPoint]*PendingInput, 1)\n\terrChan := make(chan error, 1)\n\tselect {\n\tcase s.pendingSweepsReqs <- &pendingSweepsReq{\n\t\trespChan: respChan,\n\t\terrChan:  errChan,\n\t}:\n\tcase <-s.quit:\n\t\treturn nil, ErrSweeperShuttingDown\n\t}\n\n\tselect {\n\tcase pendingSweeps := <-respChan:\n\t\treturn pendingSweeps, nil\n\tcase err := <-errChan:\n\t\treturn nil, err\n\tcase <-s.quit:\n\t\treturn nil, ErrSweeperShuttingDown\n\t}\n}\n\n// handlePendingSweepsReq handles a request to retrieve all pending inputs the\n// UtxoSweeper is attempting to sweep.",
      "length": 522,
      "tokens": 67,
      "embedding": []
    },
    {
      "slug": "func (s *UtxoSweeper) handlePendingSweepsReq(",
      "content": "func (s *UtxoSweeper) handlePendingSweepsReq(\n\treq *pendingSweepsReq) map[wire.OutPoint]*PendingInput {\n\n\tpendingInputs := make(map[wire.OutPoint]*PendingInput, len(s.pendingInputs))\n\tfor _, pendingInput := range s.pendingInputs {\n\t\t// Only the exported fields are set, as we expect the response\n\t\t// to only be consumed externally.\n\t\top := *pendingInput.OutPoint()\n\t\tpendingInputs[op] = &PendingInput{\n\t\t\tOutPoint:    op,\n\t\t\tWitnessType: pendingInput.WitnessType(),\n\t\t\tAmount: btcutil.Amount(\n\t\t\t\tpendingInput.SignDesc().Output.Value,\n\t\t\t),\n\t\t\tLastFeeRate:         pendingInput.lastFeeRate,\n\t\t\tBroadcastAttempts:   pendingInput.publishAttempts,\n\t\t\tNextBroadcastHeight: uint32(pendingInput.minPublishHeight),\n\t\t\tParams:              pendingInput.params,\n\t\t}\n\t}\n\n\treturn pendingInputs\n}\n\n// UpdateParams allows updating the sweep parameters of a pending input in the\n// UtxoSweeper. This function can be used to provide an updated fee preference\n// and force flag that will be used for a new sweep transaction of the input\n// that will act as a replacement transaction (RBF) of the original sweeping\n// transaction, if any. The exclusive group is left unchanged.\n//\n// NOTE: This currently doesn't do any fee rate validation to ensure that a bump\n// is actually successful. The responsibility of doing so should be handled by\n// the caller.",
      "length": 1262,
      "tokens": 157,
      "embedding": []
    },
    {
      "slug": "func (s *UtxoSweeper) UpdateParams(input wire.OutPoint,",
      "content": "func (s *UtxoSweeper) UpdateParams(input wire.OutPoint,\n\tparams ParamsUpdate) (chan Result, error) {\n\n\t// Ensure the client provided a sane fee preference.\n\tif _, err := s.feeRateForPreference(params.Fee); err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponseChan := make(chan *updateResp, 1)\n\tselect {\n\tcase s.updateReqs <- &updateReq{\n\t\tinput:        input,\n\t\tparams:       params,\n\t\tresponseChan: responseChan,\n\t}:\n\tcase <-s.quit:\n\t\treturn nil, ErrSweeperShuttingDown\n\t}\n\n\tselect {\n\tcase response := <-responseChan:\n\t\treturn response.resultChan, response.err\n\tcase <-s.quit:\n\t\treturn nil, ErrSweeperShuttingDown\n\t}\n}\n\n// handleUpdateReq handles an update request by simply updating the sweep\n// parameters of the pending input. Currently, no validation is done on the new\n// fee preference to ensure it will properly create a replacement transaction.\n//\n// TODO(wilmer):\n//   - Validate fee preference to ensure we'll create a valid replacement\n//     transaction to allow the new fee rate to propagate throughout the\n//     network.\n//   - Ensure we don't combine this input with any other unconfirmed inputs that\n//     did not exist in the original sweep transaction, resulting in an invalid\n//     replacement transaction.",
      "length": 1128,
      "tokens": 164,
      "embedding": []
    },
    {
      "slug": "func (s *UtxoSweeper) handleUpdateReq(req *updateReq, bestHeight int32) (",
      "content": "func (s *UtxoSweeper) handleUpdateReq(req *updateReq, bestHeight int32) (\n\tchan Result, error) {\n\n\t// If the UtxoSweeper is already trying to sweep this input, then we can\n\t// simply just increase its fee rate. This will allow the input to be\n\t// batched with others which also have a similar fee rate, creating a\n\t// higher fee rate transaction that replaces the original input's\n\t// sweeping transaction.\n\tpendingInput, ok := s.pendingInputs[req.input]\n\tif !ok {\n\t\treturn nil, lnwallet.ErrNotMine\n\t}\n\n\t// Create the updated parameters struct. Leave the exclusive group\n\t// unchanged.\n\tnewParams := pendingInput.params\n\tnewParams.Fee = req.params.Fee\n\tnewParams.Force = req.params.Force\n\n\tlog.Debugf(\"Updating sweep parameters for %v from %v to %v\", req.input,\n\t\tpendingInput.params, newParams)\n\n\tpendingInput.params = newParams\n\n\t// We'll reset the input's publish height to the current so that a new\n\t// transaction can be created that replaces the transaction currently\n\t// spending the input. We only do this for inputs that have been\n\t// broadcast at least once to ensure we don't spend an input before its\n\t// maturity height.\n\t//\n\t// NOTE: The UtxoSweeper is not yet offered time-locked inputs, so the\n\t// check for broadcast attempts is redundant at the moment.\n\tif pendingInput.publishAttempts > 0 {\n\t\tpendingInput.minPublishHeight = bestHeight\n\t}\n\n\tif err := s.scheduleSweep(bestHeight); err != nil {\n\t\tlog.Errorf(\"Unable to schedule sweep: %v\", err)\n\t}\n\n\tresultChan := make(chan Result, 1)\n\tpendingInput.listeners = append(pendingInput.listeners, resultChan)\n\n\treturn resultChan, nil\n}\n\n// CreateSweepTx accepts a list of inputs and signs and generates a txn that\n// spends from them. This method also makes an accurate fee estimate before\n// generating the required witnesses.\n//\n// The created transaction has a single output sending all the funds back to\n// the source wallet, after accounting for the fee estimate.\n//\n// The value of currentBlockHeight argument will be set as the tx locktime.\n// This function assumes that all CLTV inputs will be unlocked after\n// currentBlockHeight. Reasons not to use the maximum of all actual CLTV expiry\n// values of the inputs:\n//\n// - Make handling re-orgs easier.\n// - Thwart future possible fee sniping attempts.\n// - Make us blend in with the bitcoind wallet.",
      "length": 2186,
      "tokens": 345,
      "embedding": []
    },
    {
      "slug": "func (s *UtxoSweeper) CreateSweepTx(inputs []input.Input, feePref FeePreference,",
      "content": "func (s *UtxoSweeper) CreateSweepTx(inputs []input.Input, feePref FeePreference,\n\tcurrentBlockHeight uint32) (*wire.MsgTx, error) {\n\n\tfeePerKw, err := DetermineFeePerKw(s.cfg.FeeEstimator, feePref)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Generate the receiving script to which the funds will be swept.\n\tpkScript, err := s.cfg.GenSweepScript()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn createSweepTx(\n\t\tinputs, nil, pkScript, currentBlockHeight, feePerKw,\n\t\ts.cfg.Signer,\n\t)\n}\n\n// DefaultNextAttemptDeltaFunc is the default calculation for next sweep attempt\n// scheduling. It implements exponential back-off with some randomness. This is\n// to prevent a stuck tx (for example because fee is too low and can't be bumped\n// in btcd) from blocking all other retried inputs in the same tx.",
      "length": 690,
      "tokens": 105,
      "embedding": []
    },
    {
      "slug": "func DefaultNextAttemptDeltaFunc(attempts int) int32 {",
      "content": "func DefaultNextAttemptDeltaFunc(attempts int) int32 {\n\treturn 1 + rand.Int31n(1<<uint(attempts-1))\n}\n\n// ListSweeps returns a list of the the sweeps recorded by the sweep store.",
      "length": 120,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func (s *UtxoSweeper) ListSweeps() ([]chainhash.Hash, error) {",
      "content": "func (s *UtxoSweeper) ListSweeps() ([]chainhash.Hash, error) {\n\treturn s.cfg.Store.ListSweeps()\n}\n\n// init initializes the random generator for random input rescheduling.",
      "length": 104,
      "tokens": 13,
      "embedding": []
    },
    {
      "slug": "func init() {",
      "content": "func init() {\n\trand.Seed(time.Now().Unix())\n}\n",
      "length": 30,
      "tokens": 2,
      "embedding": []
    }
  ]
}