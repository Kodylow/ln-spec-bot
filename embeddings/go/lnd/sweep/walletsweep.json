{
  "filepath": "../implementations/go/lnd/sweep/walletsweep.go",
  "package": "sweep",
  "sections": [
    {
      "slug": "type FeePreference struct {",
      "content": "type FeePreference struct {\n\t// ConfTarget if non-zero, signals a fee preference expressed in the\n\t// number of desired blocks between first broadcast, and confirmation.\n\tConfTarget uint32\n\n\t// FeeRate if non-zero, signals a fee pre fence expressed in the fee\n\t// rate expressed in sat/kw for a particular transaction.\n\tFeeRate chainfee.SatPerKWeight\n}\n\n// String returns a human-readable string of the fee preference.",
      "length": 381,
      "tokens": 58,
      "embedding": []
    },
    {
      "slug": "func (p FeePreference) String() string {",
      "content": "func (p FeePreference) String() string {\n\tif p.ConfTarget != 0 {\n\t\treturn fmt.Sprintf(\"%v blocks\", p.ConfTarget)\n\t}\n\treturn p.FeeRate.String()\n}\n\n// DetermineFeePerKw will determine the fee in sat/kw that should be paid given\n// an estimator, a confirmation target, and a manual value for sat/byte. A\n// value is chosen based on the two free parameters as one, or both of them can\n// be zero.",
      "length": 342,
      "tokens": 59,
      "embedding": []
    },
    {
      "slug": "func DetermineFeePerKw(feeEstimator chainfee.Estimator,",
      "content": "func DetermineFeePerKw(feeEstimator chainfee.Estimator,\n\tfeePref FeePreference) (chainfee.SatPerKWeight, error) {\n\n\tswitch {\n\t// If both values are set, then we'll return an error as we require a\n\t// strict directive.\n\tcase feePref.FeeRate != 0 && feePref.ConfTarget != 0:\n\t\treturn 0, fmt.Errorf(\"only FeeRate or ConfTarget should \" +\n\t\t\t\"be set for FeePreferences\")\n\n\t// If the target number of confirmations is set, then we'll use that to\n\t// consult our fee estimator for an adequate fee.\n\tcase feePref.ConfTarget != 0:\n\t\tfeePerKw, err := feeEstimator.EstimateFeePerKW(\n\t\t\tuint32(feePref.ConfTarget),\n\t\t)\n\t\tif err != nil {\n\t\t\treturn 0, fmt.Errorf(\"unable to query fee \"+\n\t\t\t\t\"estimator: %v\", err)\n\t\t}\n\n\t\treturn feePerKw, nil\n\n\t// If a manual sat/byte fee rate is set, then we'll use that directly.\n\t// We'll need to convert it to sat/kw as this is what we use\n\t// internally.\n\tcase feePref.FeeRate != 0:\n\t\tfeePerKW := feePref.FeeRate\n\t\tif feePerKW < chainfee.FeePerKwFloor {\n\t\t\tlog.Infof(\"Manual fee rate input of %d sat/kw is \"+\n\t\t\t\t\"too low, using %d sat/kw instead\", feePerKW,\n\t\t\t\tchainfee.FeePerKwFloor)\n\n\t\t\tfeePerKW = chainfee.FeePerKwFloor\n\t\t}\n\n\t\treturn feePerKW, nil\n\n\t// Otherwise, we'll attempt a relaxed confirmation target for the\n\t// transaction\n\tdefault:\n\t\tfeePerKw, err := feeEstimator.EstimateFeePerKW(\n\t\t\tdefaultNumBlocksEstimate,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn 0, fmt.Errorf(\"unable to query fee estimator: \"+\n\t\t\t\t\"%v\", err)\n\t\t}\n\n\t\treturn feePerKw, nil\n\t}\n}\n\n// UtxoSource is an interface that allows a caller to access a source of UTXOs\n// to use when crafting sweep transactions.",
      "length": 1493,
      "tokens": 226,
      "embedding": []
    },
    {
      "slug": "type UtxoSource interface {",
      "content": "type UtxoSource interface {\n\t// ListUnspentWitness returns all UTXOs from the default wallet account\n\t// that have between minConfs and maxConfs number of confirmations.\n\tListUnspentWitnessFromDefaultAccount(minConfs, maxConfs int32) (\n\t\t[]*lnwallet.Utxo, error)\n}\n\n// CoinSelectionLocker is an interface that allows the caller to perform an\n// operation, which is synchronized with all coin selection attempts. This can\n// be used when an operation requires that all coin selection operations cease\n// forward progress. Think of this as an exclusive lock on coin selection\n// operations.",
      "length": 550,
      "tokens": 79,
      "embedding": []
    },
    {
      "slug": "type CoinSelectionLocker interface {",
      "content": "type CoinSelectionLocker interface {\n\t// WithCoinSelectLock will execute the passed function closure in a\n\t// synchronized manner preventing any coin selection operations from\n\t// proceeding while the closure is executing. This can be seen as the\n\t// ability to execute a function closure under an exclusive coin\n\t// selection lock.\n\tWithCoinSelectLock(func() error) error\n}\n\n// OutpointLocker allows a caller to lock/unlock an outpoint. When locked, the\n// outpoints shouldn't be used for any sort of channel funding of coin\n// selection. Locked outpoints are not expected to be persisted between restarts.",
      "length": 560,
      "tokens": 87,
      "embedding": []
    },
    {
      "slug": "type OutpointLocker interface {",
      "content": "type OutpointLocker interface {\n\t// LockOutpoint locks a target outpoint, rendering it unusable for coin\n\t// selection.\n\tLockOutpoint(o wire.OutPoint)\n\n\t// UnlockOutpoint unlocks a target outpoint, allowing it to be used for\n\t// coin selection once again.\n\tUnlockOutpoint(o wire.OutPoint)\n}\n\n// WalletSweepPackage is a package that gives the caller the ability to sweep\n// ALL funds from a wallet in a single transaction. We also package a function\n// closure that allows one to abort the operation.",
      "length": 456,
      "tokens": 72,
      "embedding": []
    },
    {
      "slug": "type WalletSweepPackage struct {",
      "content": "type WalletSweepPackage struct {\n\t// SweepTx is a fully signed, and valid transaction that is broadcast,\n\t// will sweep ALL confirmed coins in the wallet with a single\n\t// transaction.\n\tSweepTx *wire.MsgTx\n\n\t// CancelSweepAttempt allows the caller to cancel the sweep attempt.\n\t//\n\t// NOTE: If the sweeping transaction isn't or cannot be broadcast, then\n\t// this closure MUST be called, otherwise all selected utxos will be\n\t// unable to be used.\n\tCancelSweepAttempt func()\n}\n\n// DeliveryAddr is a pair of (address, amount) used to craft a transaction\n// paying to more than one specified address.",
      "length": 550,
      "tokens": 92,
      "embedding": []
    },
    {
      "slug": "type DeliveryAddr struct {",
      "content": "type DeliveryAddr struct {\n\t// Addr is the address to pay to.\n\tAddr btcutil.Address\n\n\t// Amt is the amount to pay to the given address.\n\tAmt btcutil.Amount\n}\n\n// CraftSweepAllTx attempts to craft a WalletSweepPackage which will allow the\n// caller to sweep ALL outputs within the wallet to a list of outputs. Any\n// leftover amount after these outputs and transaction fee, is sent to a single\n// output, as specified by the change address. The sweep transaction will be\n// crafted with the target fee rate, and will use the utxoSource and\n// outpointLocker as sources for wallet funds.",
      "length": 546,
      "tokens": 97,
      "embedding": []
    },
    {
      "slug": "func CraftSweepAllTx(feeRate chainfee.SatPerKWeight, blockHeight uint32,",
      "content": "func CraftSweepAllTx(feeRate chainfee.SatPerKWeight, blockHeight uint32,\n\tdeliveryAddrs []DeliveryAddr, changeAddr btcutil.Address,\n\tcoinSelectLocker CoinSelectionLocker, utxoSource UtxoSource,\n\toutpointLocker OutpointLocker, feeEstimator chainfee.Estimator,\n\tsigner input.Signer, minConfs int32) (*WalletSweepPackage, error) {\n\n\t// TODO(roasbeef): turn off ATPL as well when available?\n\n\tvar allOutputs []*lnwallet.Utxo\n\n\t// We'll make a function closure up front that allows us to unlock all\n\t// selected outputs to ensure that they become available again in the\n\t// case of an error after the outputs have been locked, but before we\n\t// can actually craft a sweeping transaction.\n\tunlockOutputs := func() {\n\t\tfor _, utxo := range allOutputs {\n\t\t\toutpointLocker.UnlockOutpoint(utxo.OutPoint)\n\t\t}\n\t}\n\n\t// Next, we'll use the coinSelectLocker to ensure that no coin\n\t// selection takes place while we fetch and lock all outputs the wallet\n\t// knows of.  Otherwise, it may be possible for a new funding flow to\n\t// lock an output while we fetch the set of unspent witnesses.\n\terr := coinSelectLocker.WithCoinSelectLock(func() error {\n\t\t// Now that we can be sure that no other coin selection\n\t\t// operations are going on, we can grab a clean snapshot of the\n\t\t// current UTXO state of the wallet.\n\t\tutxos, err := utxoSource.ListUnspentWitnessFromDefaultAccount(\n\t\t\tminConfs, math.MaxInt32,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// We'll now lock each UTXO to ensure that other callers don't\n\t\t// attempt to use these UTXOs in transactions while we're\n\t\t// crafting out sweep all transaction.\n\t\tfor _, utxo := range utxos {\n\t\t\toutpointLocker.LockOutpoint(utxo.OutPoint)\n\t\t}\n\n\t\tallOutputs = append(allOutputs, utxos...)\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\t// If we failed at all, we'll unlock any outputs selected just\n\t\t// in case we had any lingering outputs.\n\t\tunlockOutputs()\n\n\t\treturn nil, fmt.Errorf(\"unable to fetch+lock wallet \"+\n\t\t\t\"utxos: %v\", err)\n\t}\n\n\t// Now that we've locked all the potential outputs to sweep, we'll\n\t// assemble an input for each of them, so we can hand it off to the\n\t// sweeper to generate and sign a transaction for us.\n\tvar inputsToSweep []input.Input\n\tfor _, output := range allOutputs {\n\t\t// As we'll be signing for outputs under control of the wallet,\n\t\t// we only need to populate the output value and output script.\n\t\t// The rest of the items will be populated internally within\n\t\t// the sweeper via the witness generation function.\n\t\tsignDesc := &input.SignDescriptor{\n\t\t\tOutput: &wire.TxOut{\n\t\t\t\tPkScript: output.PkScript,\n\t\t\t\tValue:    int64(output.Value),\n\t\t\t},\n\t\t\tHashType: txscript.SigHashAll,\n\t\t}\n\n\t\tpkScript := output.PkScript\n\n\t\t// Based on the output type, we'll map it to the proper witness\n\t\t// type so we can generate the set of input scripts needed to\n\t\t// sweep the output.\n\t\tvar witnessType input.WitnessType\n\t\tswitch output.AddressType {\n\n\t\t// If this is a p2wkh output, then we'll assume it's a witness\n\t\t// key hash witness type.\n\t\tcase lnwallet.WitnessPubKey:\n\t\t\twitnessType = input.WitnessKeyHash\n\n\t\t// If this is a p2sh output, then as since it's under control\n\t\t// of the wallet, we'll assume it's a nested p2sh output.\n\t\tcase lnwallet.NestedWitnessPubKey:\n\t\t\twitnessType = input.NestedWitnessKeyHash\n\n\t\tcase lnwallet.TaprootPubkey:\n\t\t\twitnessType = input.TaprootPubKeySpend\n\t\t\tsignDesc.HashType = txscript.SigHashDefault\n\n\t\t// All other output types we count as unknown and will fail to\n\t\t// sweep.\n\t\tdefault:\n\t\t\tunlockOutputs()\n\n\t\t\treturn nil, fmt.Errorf(\"unable to sweep coins, \"+\n\t\t\t\t\"unknown script: %x\", pkScript[:])\n\t\t}\n\n\t\t// Now that we've constructed the items required, we'll make an\n\t\t// input which can be passed to the sweeper for ultimate\n\t\t// sweeping.\n\t\tinput := input.MakeBaseInput(\n\t\t\t&output.OutPoint, witnessType, signDesc, 0, nil,\n\t\t)\n\t\tinputsToSweep = append(inputsToSweep, &input)\n\t}\n\n\t// Create a list of TxOuts from the given delivery addresses.\n\tvar txOuts []*wire.TxOut\n\tfor _, d := range deliveryAddrs {\n\t\tpkScript, err := txscript.PayToAddrScript(d.Addr)\n\t\tif err != nil {\n\t\t\tunlockOutputs()\n\n\t\t\treturn nil, err\n\t\t}\n\n\t\ttxOuts = append(txOuts, &wire.TxOut{\n\t\t\tPkScript: pkScript,\n\t\t\tValue:    int64(d.Amt),\n\t\t})\n\t}\n\n\t// Next, we'll convert the change addr to a pkScript that we can use\n\t// to create the sweep transaction.\n\tchangePkScript, err := txscript.PayToAddrScript(changeAddr)\n\tif err != nil {\n\t\tunlockOutputs()\n\n\t\treturn nil, err\n\t}\n\n\t// Finally, we'll ask the sweeper to craft a sweep transaction which\n\t// respects our fee preference and targets all the UTXOs of the wallet.\n\tsweepTx, err := createSweepTx(\n\t\tinputsToSweep, txOuts, changePkScript, blockHeight, feeRate,\n\t\tsigner,\n\t)\n\tif err != nil {\n\t\tunlockOutputs()\n\n\t\treturn nil, err\n\t}\n\n\treturn &WalletSweepPackage{\n\t\tSweepTx:            sweepTx,\n\t\tCancelSweepAttempt: unlockOutputs,\n\t}, nil\n}\n",
      "length": 4627,
      "tokens": 679,
      "embedding": []
    }
  ]
}