{
  "filepath": "../implementations/go/lnd/sweep/test_utils.go",
  "package": "sweep",
  "sections": [
    {
      "slug": "type MockNotifier struct {",
      "content": "type MockNotifier struct {\n\tconfChannel map[chainhash.Hash]chan *chainntnfs.TxConfirmation\n\tepochChan   map[chan *chainntnfs.BlockEpoch]int32\n\tspendChan   map[wire.OutPoint][]chan *chainntnfs.SpendDetail\n\tspends      map[wire.OutPoint]*wire.MsgTx\n\tmutex       sync.RWMutex\n\tt           *testing.T\n}\n\n// NewMockNotifier instantiates a new mock notifier.",
      "length": 317,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func NewMockNotifier(t *testing.T) *MockNotifier {",
      "content": "func NewMockNotifier(t *testing.T) *MockNotifier {\n\treturn &MockNotifier{\n\t\tconfChannel: make(map[chainhash.Hash]chan *chainntnfs.TxConfirmation),\n\t\tepochChan:   make(map[chan *chainntnfs.BlockEpoch]int32),\n\t\tspendChan:   make(map[wire.OutPoint][]chan *chainntnfs.SpendDetail),\n\t\tspends:      make(map[wire.OutPoint]*wire.MsgTx),\n\t\tt:           t,\n\t}\n}\n\n// NotifyEpoch simulates a new epoch arriving.",
      "length": 340,
      "tokens": 24,
      "embedding": []
    },
    {
      "slug": "func (m *MockNotifier) NotifyEpoch(height int32) {",
      "content": "func (m *MockNotifier) NotifyEpoch(height int32) {\n\tm.t.Helper()\n\n\tfor epochChan, chanHeight := range m.epochChan {\n\t\t// Only send notifications if the height is greater than the\n\t\t// height the caller passed into the register call.\n\t\tif chanHeight >= height {\n\t\t\tcontinue\n\t\t}\n\n\t\tlog.Debugf(\"Notifying height %v to listener\", height)\n\n\t\tselect {\n\t\tcase epochChan <- &chainntnfs.BlockEpoch{\n\t\t\tHeight: height,\n\t\t}:\n\t\tcase <-time.After(defaultTestTimeout):\n\t\t\tm.t.Fatal(\"epoch event not consumed\")\n\t\t}\n\t}\n}\n\n// ConfirmTx simulates a tx confirming.",
      "length": 473,
      "tokens": 65,
      "embedding": []
    },
    {
      "slug": "func (m *MockNotifier) ConfirmTx(txid *chainhash.Hash, height uint32) error {",
      "content": "func (m *MockNotifier) ConfirmTx(txid *chainhash.Hash, height uint32) error {\n\tconfirm := &chainntnfs.TxConfirmation{\n\t\tBlockHeight: height,\n\t}\n\tselect {\n\tcase m.getConfChannel(txid) <- confirm:\n\tcase <-time.After(defaultTestTimeout):\n\t\treturn fmt.Errorf(\"confirmation not consumed\")\n\t}\n\treturn nil\n}\n\n// SpendOutpoint simulates a utxo being spent.",
      "length": 259,
      "tokens": 29,
      "embedding": []
    },
    {
      "slug": "func (m *MockNotifier) SpendOutpoint(outpoint wire.OutPoint,",
      "content": "func (m *MockNotifier) SpendOutpoint(outpoint wire.OutPoint,\n\tspendingTx wire.MsgTx) {\n\n\tlog.Debugf(\"Spending outpoint %v\", outpoint)\n\n\tm.mutex.Lock()\n\tdefer m.mutex.Unlock()\n\n\tchannels, ok := m.spendChan[outpoint]\n\tif ok {\n\t\tfor _, channel := range channels {\n\t\t\tm.sendSpend(channel, &outpoint, &spendingTx)\n\t\t}\n\t}\n\n\tm.spends[outpoint] = &spendingTx\n}\n",
      "length": 276,
      "tokens": 33,
      "embedding": []
    },
    {
      "slug": "func (m *MockNotifier) sendSpend(channel chan *chainntnfs.SpendDetail,",
      "content": "func (m *MockNotifier) sendSpend(channel chan *chainntnfs.SpendDetail,\n\toutpoint *wire.OutPoint,\n\tspendingTx *wire.MsgTx) {\n\n\tspenderTxHash := spendingTx.TxHash()\n\tchannel <- &chainntnfs.SpendDetail{\n\t\tSpenderTxHash: &spenderTxHash,\n\t\tSpendingTx:    spendingTx,\n\t\tSpentOutPoint: outpoint,\n\t}\n}\n\n// RegisterConfirmationsNtfn registers for tx confirm notifications.",
      "length": 281,
      "tokens": 26,
      "embedding": []
    },
    {
      "slug": "func (m *MockNotifier) RegisterConfirmationsNtfn(txid *chainhash.Hash,",
      "content": "func (m *MockNotifier) RegisterConfirmationsNtfn(txid *chainhash.Hash,\n\t_ []byte, numConfs, heightHint uint32,\n\topt ...chainntnfs.NotifierOption) (*chainntnfs.ConfirmationEvent, error) {\n\n\treturn &chainntnfs.ConfirmationEvent{\n\t\tConfirmed: m.getConfChannel(txid),\n\t}, nil\n}\n",
      "length": 196,
      "tokens": 17,
      "embedding": []
    },
    {
      "slug": "func (m *MockNotifier) getConfChannel(",
      "content": "func (m *MockNotifier) getConfChannel(\n\ttxid *chainhash.Hash) chan *chainntnfs.TxConfirmation {\n\n\tm.mutex.Lock()\n\tdefer m.mutex.Unlock()\n\n\tchannel, ok := m.confChannel[*txid]\n\tif ok {\n\t\treturn channel\n\t}\n\tchannel = make(chan *chainntnfs.TxConfirmation)\n\tm.confChannel[*txid] = channel\n\n\treturn channel\n}\n\n// RegisterBlockEpochNtfn registers a block notification.",
      "length": 308,
      "tokens": 34,
      "embedding": []
    },
    {
      "slug": "func (m *MockNotifier) RegisterBlockEpochNtfn(",
      "content": "func (m *MockNotifier) RegisterBlockEpochNtfn(\n\tbestBlock *chainntnfs.BlockEpoch) (*chainntnfs.BlockEpochEvent, error) {\n\n\tlog.Tracef(\"Mock block ntfn registered\")\n\n\tm.mutex.Lock()\n\tepochChan := make(chan *chainntnfs.BlockEpoch, 1)\n\n\t// The real notifier returns a notification with the current block hash\n\t// and height immediately if no best block hash or height is specified\n\t// in the request. We want to emulate this behaviour as well for the\n\t// mock.\n\tswitch {\n\tcase bestBlock == nil:\n\t\tepochChan <- &chainntnfs.BlockEpoch{\n\t\t\tHash:   mockChainHash,\n\t\t\tHeight: mockChainHeight,\n\t\t}\n\t\tm.epochChan[epochChan] = mockChainHeight\n\tdefault:\n\t\tm.epochChan[epochChan] = bestBlock.Height\n\t}\n\tm.mutex.Unlock()\n\n\treturn &chainntnfs.BlockEpochEvent{\n\t\tEpochs: epochChan,\n\t\tCancel: func() {\n\t\t\tlog.Tracef(\"Mock block ntfn canceled\")\n\t\t\tm.mutex.Lock()\n\t\t\tdelete(m.epochChan, epochChan)\n\t\t\tm.mutex.Unlock()\n\t\t},\n\t}, nil\n}\n\n// Start the notifier.",
      "length": 856,
      "tokens": 102,
      "embedding": []
    },
    {
      "slug": "func (m *MockNotifier) Start() error {",
      "content": "func (m *MockNotifier) Start() error {\n\treturn nil\n}\n\n// Started checks if started.",
      "length": 41,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (m *MockNotifier) Started() bool {",
      "content": "func (m *MockNotifier) Started() bool {\n\treturn true\n}\n\n// Stop the notifier.",
      "length": 34,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "func (m *MockNotifier) Stop() error {",
      "content": "func (m *MockNotifier) Stop() error {\n\treturn nil\n}\n\n// RegisterSpendNtfn registers for spend notifications.",
      "length": 67,
      "tokens": 9,
      "embedding": []
    },
    {
      "slug": "func (m *MockNotifier) RegisterSpendNtfn(outpoint *wire.OutPoint,",
      "content": "func (m *MockNotifier) RegisterSpendNtfn(outpoint *wire.OutPoint,\n\t_ []byte, heightHint uint32) (*chainntnfs.SpendEvent, error) {\n\n\t// Add channel to global spend ntfn map.\n\tm.mutex.Lock()\n\n\tchannels, ok := m.spendChan[*outpoint]\n\tif !ok {\n\t\tchannels = make([]chan *chainntnfs.SpendDetail, 0)\n\t}\n\n\tchannel := make(chan *chainntnfs.SpendDetail, 1)\n\tchannels = append(channels, channel)\n\tm.spendChan[*outpoint] = channels\n\n\t// Check if this output has already been spent.\n\tspendingTx, spent := m.spends[*outpoint]\n\n\tm.mutex.Unlock()\n\n\t// If output has been spent already, signal now. Do this outside the\n\t// lock to prevent a deadlock.\n\tif spent {\n\t\tm.sendSpend(channel, outpoint, spendingTx)\n\t}\n\n\treturn &chainntnfs.SpendEvent{\n\t\tSpend: channel,\n\t\tCancel: func() {\n\t\t\tlog.Infof(\"Cancelling RegisterSpendNtfn for %v\",\n\t\t\t\toutpoint)\n\n\t\t\tm.mutex.Lock()\n\t\t\tdefer m.mutex.Unlock()\n\t\t\tchannels := m.spendChan[*outpoint]\n\t\t\tfor i, c := range channels {\n\t\t\t\tif c == channel {\n\t\t\t\t\tchannels[i] = channels[len(channels)-1]\n\t\t\t\t\tm.spendChan[*outpoint] =\n\t\t\t\t\t\tchannels[:len(channels)-1]\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tclose(channel)\n\n\t\t\tlog.Infof(\"Spend ntfn channel closed for %v\",\n\t\t\t\toutpoint)\n\t\t},\n\t}, nil\n}\n",
      "length": 1069,
      "tokens": 131,
      "embedding": []
    }
  ]
}