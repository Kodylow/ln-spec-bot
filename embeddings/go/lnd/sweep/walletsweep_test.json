{
  "filepath": "../implementations/go/lnd/sweep/walletsweep_test.go",
  "package": "sweep",
  "sections": [
    {
      "slug": "func TestDetermineFeePerKw(t *testing.T) {",
      "content": "func TestDetermineFeePerKw(t *testing.T) {\n\tt.Parallel()\n\n\tdefaultFee := chainfee.SatPerKWeight(999)\n\trelayFee := chainfee.SatPerKWeight(300)\n\n\tfeeEstimator := newMockFeeEstimator(defaultFee, relayFee)\n\n\t// We'll populate two items in the internal map which is used to query\n\t// a fee based on a confirmation target: the default conf target, and\n\t// an arbitrary conf target. We'll ensure below that both of these are\n\t// properly\n\tfeeEstimator.blocksToFee[50] = 300\n\tfeeEstimator.blocksToFee[defaultNumBlocksEstimate] = 1000\n\n\ttestCases := []struct {\n\t\t// feePref is the target fee preference for this case.\n\t\tfeePref FeePreference\n\n\t\t// fee is the value the DetermineFeePerKw should return given\n\t\t// the FeePreference above\n\t\tfee chainfee.SatPerKWeight\n\n\t\t// fail determines if this test case should fail or not.\n\t\tfail bool\n\t}{\n\t\t// A fee rate below the fee rate floor should output the floor.\n\t\t{\n\t\t\tfeePref: FeePreference{\n\t\t\t\tFeeRate: chainfee.SatPerKWeight(99),\n\t\t\t},\n\t\t\tfee: chainfee.FeePerKwFloor,\n\t\t},\n\n\t\t// A fee rate above the floor, should pass through and return\n\t\t// the target fee rate.\n\t\t{\n\t\t\tfeePref: FeePreference{\n\t\t\t\tFeeRate: 900,\n\t\t\t},\n\t\t\tfee: 900,\n\t\t},\n\n\t\t// A specified confirmation target should cause the function to\n\t\t// query the estimator which will return our value specified\n\t\t// above.\n\t\t{\n\t\t\tfeePref: FeePreference{\n\t\t\t\tConfTarget: 50,\n\t\t\t},\n\t\t\tfee: 300,\n\t\t},\n\n\t\t// If the caller doesn't specify any values at all, then we\n\t\t// should query for the default conf target.\n\t\t{\n\t\t\tfeePref: FeePreference{},\n\t\t\tfee:     1000,\n\t\t},\n\n\t\t// Both conf target and fee rate are set, we should return with\n\t\t// an error.\n\t\t{\n\t\t\tfeePref: FeePreference{\n\t\t\t\tConfTarget: 50,\n\t\t\t\tFeeRate:    90000,\n\t\t\t},\n\t\t\tfee:  300,\n\t\t\tfail: true,\n\t\t},\n\t}\n\tfor i, testCase := range testCases {\n\t\ttargetFee, err := DetermineFeePerKw(\n\t\t\tfeeEstimator, testCase.feePref,\n\t\t)\n\t\tswitch {\n\t\tcase testCase.fail && err != nil:\n\t\t\tcontinue\n\n\t\tcase testCase.fail && err == nil:\n\t\t\tt.Fatalf(\"expected failure for #%v\", i)\n\n\t\tcase !testCase.fail && err != nil:\n\t\t\tt.Fatalf(\"unable to estimate fee; %v\", err)\n\t\t}\n\n\t\tif targetFee != testCase.fee {\n\t\t\tt.Fatalf(\"#%v: wrong fee: expected %v got %v\", i,\n\t\t\t\ttestCase.fee, targetFee)\n\t\t}\n\t}\n}\n",
      "length": 2094,
      "tokens": 305,
      "embedding": []
    },
    {
      "slug": "type mockUtxoSource struct {",
      "content": "type mockUtxoSource struct {\n\toutputs []*lnwallet.Utxo\n}\n",
      "length": 26,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func newMockUtxoSource(utxos []*lnwallet.Utxo) *mockUtxoSource {",
      "content": "func newMockUtxoSource(utxos []*lnwallet.Utxo) *mockUtxoSource {\n\treturn &mockUtxoSource{\n\t\toutputs: utxos,\n\t}\n}\n",
      "length": 44,
      "tokens": 6,
      "embedding": []
    },
    {
      "slug": "func (m *mockUtxoSource) ListUnspentWitnessFromDefaultAccount(minConfs int32,",
      "content": "func (m *mockUtxoSource) ListUnspentWitnessFromDefaultAccount(minConfs int32,\n\tmaxConfs int32) ([]*lnwallet.Utxo, error) {\n\n\treturn m.outputs, nil\n}\n",
      "length": 67,
      "tokens": 9,
      "embedding": []
    },
    {
      "slug": "type mockCoinSelectionLocker struct {",
      "content": "type mockCoinSelectionLocker struct {\n\tfail bool\n}\n",
      "length": 11,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (m *mockCoinSelectionLocker) WithCoinSelectLock(f func() error) error {",
      "content": "func (m *mockCoinSelectionLocker) WithCoinSelectLock(f func() error) error {\n\tif err := f(); err != nil {\n\t\treturn err\n\t}\n\n\tif m.fail {\n\t\treturn fmt.Errorf(\"kek\")\n\t}\n\n\treturn nil\n\n}\n",
      "length": 94,
      "tokens": 20,
      "embedding": []
    },
    {
      "slug": "type mockOutpointLocker struct {",
      "content": "type mockOutpointLocker struct {\n\tlockedOutpoints map[wire.OutPoint]struct{}\n\n\tunlockedOutpoints map[wire.OutPoint]struct{}\n}\n",
      "length": 89,
      "tokens": 5,
      "embedding": []
    },
    {
      "slug": "func newMockOutpointLocker() *mockOutpointLocker {",
      "content": "func newMockOutpointLocker() *mockOutpointLocker {\n\treturn &mockOutpointLocker{\n\t\tlockedOutpoints: make(map[wire.OutPoint]struct{}),\n\n\t\tunlockedOutpoints: make(map[wire.OutPoint]struct{}),\n\t}\n}\n",
      "length": 137,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "func (m *mockOutpointLocker) LockOutpoint(o wire.OutPoint) {",
      "content": "func (m *mockOutpointLocker) LockOutpoint(o wire.OutPoint) {\n\tm.lockedOutpoints[o] = struct{}{}\n}",
      "length": 35,
      "tokens": 4,
      "embedding": []
    },
    {
      "slug": "func (m *mockOutpointLocker) UnlockOutpoint(o wire.OutPoint) {",
      "content": "func (m *mockOutpointLocker) UnlockOutpoint(o wire.OutPoint) {\n\tm.unlockedOutpoints[o] = struct{}{}\n}\n\nvar sweepScript = []byte{\n\t0x0, 0x14, 0x64, 0x3d, 0x8b, 0x15, 0x69, 0x4a, 0x54,\n\t0x7d, 0x57, 0x33, 0x6e, 0x51, 0xdf, 0xfd, 0x38, 0xe3,\n\t0xe, 0x6e, 0xf8, 0xef,\n}\n\nvar deliveryAddr = func() btcutil.Address {\n\t_, addrs, _, err := txscript.ExtractPkScriptAddrs(\n\t\tsweepScript, &chaincfg.TestNet3Params,\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn addrs[0]\n}()\n\nvar testUtxos = []*lnwallet.Utxo{\n\t{\n\t\t// A p2wkh output.\n\t\tAddressType: lnwallet.WitnessPubKey,\n\t\tPkScript: []byte{\n\t\t\t0x0, 0x14, 0x64, 0x3d, 0x8b, 0x15, 0x69, 0x4a, 0x54,\n\t\t\t0x7d, 0x57, 0x33, 0x6e, 0x51, 0xdf, 0xfd, 0x38, 0xe3,\n\t\t\t0xe, 0x6e, 0xf7, 0xef,\n\t\t},\n\t\tValue: 1000,\n\t\tOutPoint: wire.OutPoint{\n\t\t\tIndex: 1,\n\t\t},\n\t},\n\n\t{\n\t\t// A np2wkh output.\n\t\tAddressType: lnwallet.NestedWitnessPubKey,\n\t\tPkScript: []byte{\n\t\t\t0xa9, 0x14, 0x97, 0x17, 0xf7, 0xd1, 0x5f, 0x6f, 0x8b,\n\t\t\t0x7, 0xe3, 0x58, 0x43, 0x19, 0xb9, 0x7e, 0xa9, 0x20,\n\t\t\t0x18, 0xc3, 0x17, 0xd7, 0x87,\n\t\t},\n\t\tValue: 2000,\n\t\tOutPoint: wire.OutPoint{\n\t\t\tIndex: 2,\n\t\t},\n\t},\n\n\t// A p2wsh output.\n\t{\n\t\tAddressType: lnwallet.UnknownAddressType,\n\t\tPkScript: []byte{\n\t\t\t0x0, 0x20, 0x70, 0x1a, 0x8d, 0x40, 0x1c, 0x84, 0xfb, 0x13,\n\t\t\t0xe6, 0xba, 0xf1, 0x69, 0xd5, 0x96, 0x84, 0xe2, 0x7a, 0xbd,\n\t\t\t0x9f, 0xa2, 0x16, 0xc8, 0xbc, 0x5b, 0x9f, 0xc6, 0x3d, 0x62,\n\t\t\t0x2f, 0xf8, 0xc5, 0x8c,\n\t\t},\n\t\tValue: 3000,\n\t\tOutPoint: wire.OutPoint{\n\t\t\tIndex: 3,\n\t\t},\n\t},\n}\n",
      "length": 1339,
      "tokens": 194,
      "embedding": []
    },
    {
      "slug": "func assertUtxosLocked(t *testing.T, utxoLocker *mockOutpointLocker,",
      "content": "func assertUtxosLocked(t *testing.T, utxoLocker *mockOutpointLocker,\n\tutxos []*lnwallet.Utxo) {\n\n\tt.Helper()\n\n\tfor _, utxo := range utxos {\n\t\tif _, ok := utxoLocker.lockedOutpoints[utxo.OutPoint]; !ok {\n\t\t\tt.Fatalf(\"utxo %v was never locked\", utxo.OutPoint)\n\t\t}\n\t}\n\n}\n",
      "length": 188,
      "tokens": 27,
      "embedding": []
    },
    {
      "slug": "func assertNoUtxosUnlocked(t *testing.T, utxoLocker *mockOutpointLocker,",
      "content": "func assertNoUtxosUnlocked(t *testing.T, utxoLocker *mockOutpointLocker,\n\tutxos []*lnwallet.Utxo) {\n\n\tt.Helper()\n\n\tif len(utxoLocker.unlockedOutpoints) != 0 {\n\t\tt.Fatalf(\"outputs have been locked, but shouldn't have been\")\n\t}\n}\n",
      "length": 147,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func assertUtxosUnlocked(t *testing.T, utxoLocker *mockOutpointLocker,",
      "content": "func assertUtxosUnlocked(t *testing.T, utxoLocker *mockOutpointLocker,\n\tutxos []*lnwallet.Utxo) {\n\n\tt.Helper()\n\n\tfor _, utxo := range utxos {\n\t\tif _, ok := utxoLocker.unlockedOutpoints[utxo.OutPoint]; !ok {\n\t\t\tt.Fatalf(\"utxo %v was never unlocked\", utxo.OutPoint)\n\t\t}\n\t}\n}\n",
      "length": 192,
      "tokens": 27,
      "embedding": []
    },
    {
      "slug": "func assertUtxosLockedAndUnlocked(t *testing.T, utxoLocker *mockOutpointLocker,",
      "content": "func assertUtxosLockedAndUnlocked(t *testing.T, utxoLocker *mockOutpointLocker,\n\tutxos []*lnwallet.Utxo) {\n\n\tt.Helper()\n\n\tfor _, utxo := range utxos {\n\t\tif _, ok := utxoLocker.lockedOutpoints[utxo.OutPoint]; !ok {\n\t\t\tt.Fatalf(\"utxo %v was never locked\", utxo.OutPoint)\n\t\t}\n\n\t\tif _, ok := utxoLocker.unlockedOutpoints[utxo.OutPoint]; !ok {\n\t\t\tt.Fatalf(\"utxo %v was never unlocked\", utxo.OutPoint)\n\t\t}\n\t}\n}\n\n// TestCraftSweepAllTxCoinSelectFail tests that if coin selection fails, then\n// we unlock any outputs we may have locked in the passed closure.",
      "length": 454,
      "tokens": 63,
      "embedding": []
    },
    {
      "slug": "func TestCraftSweepAllTxCoinSelectFail(t *testing.T) {",
      "content": "func TestCraftSweepAllTxCoinSelectFail(t *testing.T) {\n\tt.Parallel()\n\n\tutxoSource := newMockUtxoSource(testUtxos)\n\tcoinSelectLocker := &mockCoinSelectionLocker{\n\t\tfail: true,\n\t}\n\tutxoLocker := newMockOutpointLocker()\n\n\t_, err := CraftSweepAllTx(\n\t\t0, 10, nil, nil, coinSelectLocker, utxoSource, utxoLocker, nil,\n\t\tnil, 0,\n\t)\n\n\t// Since we instructed the coin select locker to fail above, we should\n\t// get an error.\n\tif err == nil {\n\t\tt.Fatalf(\"sweep tx should have failed: %v\", err)\n\t}\n\n\t// At this point, we'll now verify that all outputs were initially\n\t// locked, and then also unlocked due to the failure.\n\tassertUtxosLockedAndUnlocked(t, utxoLocker, testUtxos)\n}\n\n// TestCraftSweepAllTxUnknownWitnessType tests that if one of the inputs we\n// encounter is of an unknown witness type, then we fail and unlock any prior\n// locked outputs.",
      "length": 761,
      "tokens": 112,
      "embedding": []
    },
    {
      "slug": "func TestCraftSweepAllTxUnknownWitnessType(t *testing.T) {",
      "content": "func TestCraftSweepAllTxUnknownWitnessType(t *testing.T) {\n\tt.Parallel()\n\n\tutxoSource := newMockUtxoSource(testUtxos)\n\tcoinSelectLocker := &mockCoinSelectionLocker{}\n\tutxoLocker := newMockOutpointLocker()\n\n\t_, err := CraftSweepAllTx(\n\t\t0, 10, nil, nil, coinSelectLocker, utxoSource, utxoLocker, nil,\n\t\tnil, 0,\n\t)\n\n\t// Since passed in a p2wsh output, which is unknown, we should fail to\n\t// map the output to a witness type.\n\tif err == nil {\n\t\tt.Fatalf(\"sweep tx should have failed: %v\", err)\n\t}\n\n\t// At this point, we'll now verify that all outputs were initially\n\t// locked, and then also unlocked since we weren't able to find a\n\t// witness type for the last output.\n\tassertUtxosLockedAndUnlocked(t, utxoLocker, testUtxos)\n}\n\n// TestCraftSweepAllTx tests that we'll properly lock all available outputs\n// within the wallet, and craft a single sweep transaction that pays to the\n// target output.",
      "length": 813,
      "tokens": 123,
      "embedding": []
    },
    {
      "slug": "func TestCraftSweepAllTx(t *testing.T) {",
      "content": "func TestCraftSweepAllTx(t *testing.T) {\n\tt.Parallel()\n\n\t// First, we'll make a mock signer along with a fee estimator, We'll\n\t// use zero fees to we can assert a precise output value.\n\tsigner := &mock.DummySigner{}\n\tfeeEstimator := newMockFeeEstimator(0, 0)\n\n\t// For our UTXO source, we'll pass in all the UTXOs that we know of,\n\t// other than the final one which is of an unknown witness type.\n\ttargetUTXOs := testUtxos[:2]\n\tutxoSource := newMockUtxoSource(targetUTXOs)\n\tcoinSelectLocker := &mockCoinSelectionLocker{}\n\tutxoLocker := newMockOutpointLocker()\n\n\tsweepPkg, err := CraftSweepAllTx(\n\t\t0, 10, nil, deliveryAddr, coinSelectLocker, utxoSource,\n\t\tutxoLocker, feeEstimator, signer, 0,\n\t)\n\trequire.NoError(t, err, \"unable to make sweep tx\")\n\n\t// At this point, all of the UTXOs that we made above should be locked\n\t// and none of them unlocked.\n\tassertUtxosLocked(t, utxoLocker, testUtxos[:2])\n\tassertNoUtxosUnlocked(t, utxoLocker, testUtxos[:2])\n\n\t// Now that we have our sweep transaction, we should find that we have\n\t// a UTXO for each input, and also that our final output value is the\n\t// sum of all our inputs.\n\tsweepTx := sweepPkg.SweepTx\n\tif len(sweepTx.TxIn) != len(targetUTXOs) {\n\t\tt.Fatalf(\"expected %v utxo, got %v\", len(targetUTXOs),\n\t\t\tlen(sweepTx.TxIn))\n\t}\n\n\t// We should have a single output that pays to our sweep script\n\t// generated above.\n\texpectedSweepValue := int64(3000)\n\tif len(sweepTx.TxOut) != 1 {\n\t\tt.Fatalf(\"should have %v outputs, instead have %v\", 1,\n\t\t\tlen(sweepTx.TxOut))\n\t}\n\toutput := sweepTx.TxOut[0]\n\tswitch {\n\tcase output.Value != expectedSweepValue:\n\t\tt.Fatalf(\"expected %v sweep value, instead got %v\",\n\t\t\texpectedSweepValue, output.Value)\n\n\tcase !bytes.Equal(sweepScript, output.PkScript):\n\t\tt.Fatalf(\"expected %x sweep script, instead got %x\", sweepScript,\n\t\t\toutput.PkScript)\n\t}\n\n\t// If we cancel the sweep attempt, then we should find that all the\n\t// UTXOs within the sweep transaction are now unlocked.\n\tsweepPkg.CancelSweepAttempt()\n\tassertUtxosUnlocked(t, utxoLocker, testUtxos[:2])\n}\n",
      "length": 1940,
      "tokens": 266,
      "embedding": []
    }
  ]
}