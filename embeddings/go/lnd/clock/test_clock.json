{
  "filepath": "../implementations/go/lnd/clock/test_clock.go",
  "package": "clock",
  "sections": [
    {
      "slug": "type TestClock struct {",
      "content": "type TestClock struct {\n\tcurrentTime time.Time\n\ttimeChanMap map[time.Time][]chan time.Time\n\ttimeLock    sync.Mutex\n\ttickSignal  chan time.Duration\n}\n\n// NewTestClock returns a new test clock.",
      "length": 161,
      "tokens": 18,
      "embedding": []
    },
    {
      "slug": "func NewTestClock(startTime time.Time) *TestClock {",
      "content": "func NewTestClock(startTime time.Time) *TestClock {\n\treturn &TestClock{\n\t\tcurrentTime: startTime,\n\t\ttimeChanMap: make(map[time.Time][]chan time.Time),\n\t}\n}\n\n// NewTestClockWithTickSignal will create a new test clock with an added\n// channel which will be used to signal when a new ticker is registered.\n// This is useful when creating a ticker on a separate goroutine and we'd\n// like to wait for that to happen before advancing the test case.",
      "length": 382,
      "tokens": 61,
      "embedding": []
    },
    {
      "slug": "func NewTestClockWithTickSignal(startTime time.Time,",
      "content": "func NewTestClockWithTickSignal(startTime time.Time,\n\ttickSignal chan time.Duration) *TestClock {\n\n\ttestClock := NewTestClock(startTime)\n\ttestClock.tickSignal = tickSignal\n\n\treturn testClock\n}\n\n// Now returns the current (test) time.",
      "length": 172,
      "tokens": 21,
      "embedding": []
    },
    {
      "slug": "func (c *TestClock) Now() time.Time {",
      "content": "func (c *TestClock) Now() time.Time {\n\tc.timeLock.Lock()\n\tdefer c.timeLock.Unlock()\n\n\treturn c.currentTime\n}\n\n// TickAfter returns a channel that will receive a tick after the specified\n// duration has passed passed by the user set test time.",
      "length": 197,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func (c *TestClock) TickAfter(duration time.Duration) <-chan time.Time {",
      "content": "func (c *TestClock) TickAfter(duration time.Duration) <-chan time.Time {\n\tc.timeLock.Lock()\n\tdefer func() {\n\t\tc.timeLock.Unlock()\n\n\t\t// Signal that the ticker has been added.\n\t\tif c.tickSignal != nil {\n\t\t\tc.tickSignal <- duration\n\t\t}\n\t}()\n\n\ttriggerTime := c.currentTime.Add(duration)\n\tch := make(chan time.Time, 1)\n\n\t// If already expired, tick immediately.\n\tif !triggerTime.After(c.currentTime) {\n\t\tch <- c.currentTime\n\t\treturn ch\n\t}\n\n\t// Otherwise store the channel until the trigger time is there.\n\tchans := c.timeChanMap[triggerTime]\n\tchans = append(chans, ch)\n\tc.timeChanMap[triggerTime] = chans\n\n\treturn ch\n}\n\n// SetTime sets the (test) time and triggers tick channels when they expire.",
      "length": 592,
      "tokens": 83,
      "embedding": []
    },
    {
      "slug": "func (c *TestClock) SetTime(now time.Time) {",
      "content": "func (c *TestClock) SetTime(now time.Time) {\n\tc.timeLock.Lock()\n\tdefer c.timeLock.Unlock()\n\n\tc.currentTime = now\n\tremainingChans := make(map[time.Time][]chan time.Time)\n\tfor triggerTime, chans := range c.timeChanMap {\n\t\t// If the trigger time is still in the future, keep this channel\n\t\t// in the channel map for later.\n\t\tif triggerTime.After(now) {\n\t\t\tremainingChans[triggerTime] = chans\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, c := range chans {\n\t\t\tc <- now\n\t\t}\n\t}\n\n\tc.timeChanMap = remainingChans\n}\n",
      "length": 423,
      "tokens": 61,
      "embedding": []
    }
  ]
}