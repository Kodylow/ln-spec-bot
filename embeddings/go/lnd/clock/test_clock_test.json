{
  "filepath": "../implementations/go/lnd/clock/test_clock_test.go",
  "package": "clock",
  "sections": [
    {
      "slug": "func TestNow(t *testing.T) {",
      "content": "func TestNow(t *testing.T) {\n\tc := NewTestClock(testTime)\n\tnow := c.Now()\n\trequire.Equal(t, testTime, now)\n\n\tnow = now.Add(time.Hour)\n\tc.SetTime(now)\n\trequire.Equal(t, now, c.Now())\n}\n",
      "length": 147,
      "tokens": 17,
      "embedding": []
    },
    {
      "slug": "func TestTickAfter(t *testing.T) {",
      "content": "func TestTickAfter(t *testing.T) {\n\tc := NewTestClock(testTime)\n\n\t// Should be ticking immediately.\n\tticker0 := c.TickAfter(0)\n\n\t// Both should be ticking after SetTime\n\tticker1 := c.TickAfter(time.Hour)\n\tticker2 := c.TickAfter(time.Hour)\n\n\t// We don't expect this one to tick.\n\tticker3 := c.TickAfter(2 * time.Hour)\n\n\ttickOrTimeOut := func(ticker <-chan time.Time, expectTick bool) {\n\t\ttick := false\n\t\tselect {\n\t\tcase <-ticker:\n\t\t\ttick = true\n\n\t\tcase <-time.After(time.Millisecond):\n\t\t}\n\n\t\trequire.Equal(t, expectTick, tick)\n\t}\n\n\ttickOrTimeOut(ticker0, true)\n\ttickOrTimeOut(ticker1, false)\n\ttickOrTimeOut(ticker2, false)\n\ttickOrTimeOut(ticker3, false)\n\n\tc.SetTime(c.Now().Add(time.Hour))\n\n\ttickOrTimeOut(ticker1, true)\n\ttickOrTimeOut(ticker2, true)\n\ttickOrTimeOut(ticker3, false)\n}\n\n// TestTickSignal tests that TickAfter signals registration allowing\n// safe time advancement.",
      "length": 806,
      "tokens": 90,
      "embedding": []
    },
    {
      "slug": "func TestTickSignal(t *testing.T) {",
      "content": "func TestTickSignal(t *testing.T) {\n\tconst interval = time.Second\n\n\tch := make(chan time.Duration)\n\tc := NewTestClockWithTickSignal(testTime, ch)\n\terr := make(chan error, 1)\n\n\tgo func() {\n\t\tselect {\n\t\t// TickAfter will signal registration but will not\n\t\t// tick, unless we read the signal and set the time.\n\t\tcase <-c.TickAfter(interval):\n\t\t\terr <- nil\n\n\t\t// Signal timeout if tick didn't happen.\n\t\tcase <-time.After(time.Second):\n\t\t\terr <- fmt.Errorf(\"timeout\")\n\t\t}\n\t}()\n\n\ttick := <-ch\n\t// Expect that the interval is correctly passed over the channel.\n\trequire.Equal(t, interval, tick)\n\n\t// Once the ticker is registered, set the time to make it fire.\n\tc.SetTime(testTime.Add(time.Second))\n\trequire.NoError(t, <-err)\n}\n",
      "length": 658,
      "tokens": 94,
      "embedding": []
    }
  ]
}