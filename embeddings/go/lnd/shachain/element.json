{
  "filepath": "../implementations/go/lnd/shachain/element.go",
  "package": "shachain",
  "sections": [
    {
      "slug": "type element struct {",
      "content": "type element struct {\n\tindex index\n\thash  chainhash.Hash\n}\n\n// newElementFromStr creates new element from the given hash string.",
      "length": 102,
      "tokens": 15,
      "embedding": []
    },
    {
      "slug": "func newElementFromStr(s string, index index) (*element, error) {",
      "content": "func newElementFromStr(s string, index index) (*element, error) {\n\thash, err := hashFromString(s)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &element{\n\t\tindex: index,\n\t\thash:  *hash,\n\t}, nil\n}\n\n// derive computes one shachain element from another by applying a series of\n// bit flips and hashing operations based on the starting and ending index.",
      "length": 272,
      "tokens": 48,
      "embedding": []
    },
    {
      "slug": "func (e *element) derive(toIndex index) (*element, error) {",
      "content": "func (e *element) derive(toIndex index) (*element, error) {\n\tfromIndex := e.index\n\n\tpositions, err := fromIndex.deriveBitTransformations(toIndex)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbuf := e.hash.CloneBytes()\n\tfor _, position := range positions {\n\t\t// Flip the bit and then hash the current state.\n\t\tbyteNumber := position / 8\n\t\tbitNumber := position % 8\n\n\t\tbuf[byteNumber] ^= (1 << bitNumber)\n\n\t\th := sha256.Sum256(buf)\n\t\tbuf = h[:]\n\t}\n\n\thash, err := chainhash.NewHash(buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &element{\n\t\tindex: toIndex,\n\t\thash:  *hash,\n\t}, nil\n}\n\n// isEqual returns true if two elements are identical and false otherwise.",
      "length": 565,
      "tokens": 92,
      "embedding": []
    },
    {
      "slug": "func (e *element) isEqual(e2 *element) bool {",
      "content": "func (e *element) isEqual(e2 *element) bool {\n\treturn (e.index == e2.index) &&\n\t\t(&e.hash).IsEqual(&e2.hash)\n}\n\nconst (\n\t// maxHeight is used to determine the maximum allowable index and the\n\t// length of the array required to order to derive all previous hashes\n\t// by index. The entries of this array as also known as buckets.\n\tmaxHeight uint8 = 48\n\n\t// rootIndex is an index which corresponds to the root hash.\n\trootIndex index = 0\n)\n\n// startIndex is the index of first element in the shachain PRF.\nvar startIndex index = (1 << maxHeight) - 1\n\n// index is a number which identifies the hash number and serves as a way to\n// determine the hashing operation required  to derive one hash from another.\n// index is initialized with the startIndex and decreases down to zero with\n// successive derivations.",
      "length": 739,
      "tokens": 132,
      "embedding": []
    },
    {
      "slug": "type index uint64",
      "content": "type index uint64\n\n// newIndex is used to create index instance. The inner operations with index\n// implies that index decreasing from some max number to zero, but for\n// simplicity and backward compatibility with previous logic it was transformed\n// to work in opposite way.",
      "length": 253,
      "tokens": 43,
      "embedding": []
    },
    {
      "slug": "func newIndex(v uint64) index {",
      "content": "func newIndex(v uint64) index {\n\treturn startIndex - index(v)\n}\n\n// deriveBitTransformations function checks that the 'to' index is derivable\n// from the 'from' index by checking the indexes are prefixes of another. The\n// bit positions where the zeroes should be changed to ones in order for the\n// indexes to become the same are returned. This set of bits is needed in order\n// to derive one hash from another.\n//\n// NOTE: The index 'to' is derivable from index 'from' iff index 'from' lies\n// left and above index 'to' on graph below, for example:\n// 1. 7(0b111) -> 7\n// 2. 6(0b110) -> 6,7\n// 3. 5(0b101) -> 5\n// 4. 4(0b100) -> 4,5,6,7\n// 5. 3(0b011) -> 3\n// 6. 2(0b010) -> 2, 3\n// 7. 1(0b001) -> 1\n//\n//\t  ^ bucket number\n//\t  |\n//\t3 |   x\n//\t  |   |\n//\t2 |   |               x\n//\t  |   |               |\n//\t1 |   |       x       |       x\n//\t  |   |       |       |       |\n//\t0 |   |   x   |   x   |   x   |   x\n//\t  |   |   |   |   |   |   |   |   |\n//\t  +---|---|---|---|---|---|---|---|---> index\n//\t      0   1   2   3   4   5   6   7",
      "length": 982,
      "tokens": 198,
      "embedding": []
    },
    {
      "slug": "func (from index) deriveBitTransformations(to index) ([]uint8, error) {",
      "content": "func (from index) deriveBitTransformations(to index) ([]uint8, error) {\n\tvar positions []uint8\n\n\tif from == to {\n\t\treturn positions, nil\n\t}\n\n\t//\t+ --------------- +\n\t// \t| \u2116  | from | to  |\n\t//\t+ -- + ---- + --- +\n\t//\t| 48 |\t 1  |  1  |\n\t//\t| 47 |\t 0  |  0  | [48-5] - same part of 'from' and 'to'\n\t//\t| 46 |   0  |  0  |\t    indexes which also is called prefix.\n\t//\t\t....\n\t//\t|  5 |\t 1  |  1  |\n\t//\t|  4 |\t 0  |  1  | <--- position after which indexes becomes\n\t//\t|  3 |   0  |  0  |\t different, after this position\n\t//\t|  2 |   0  |  1  |\t bits in 'from' index all should be\n\t//\t|  1 |   0  |  0  |\t zeros or such indexes considered to be\n\t//\t|  0 |   0  |  1  |\t not derivable.\n\t//\t+ -- + ---- + --- +\n\tzeros := countTrailingZeros(from)\n\tif uint64(from) != getPrefix(to, zeros) {\n\t\treturn nil, errors.New(\"prefixes are different - indexes \" +\n\t\t\t\"aren't derivable\")\n\t}\n\n\t// The remaining part of 'to' index represents the positions which we\n\t// will use then in order to derive one element from another.\n\tfor position := zeros - 1; ; position-- {\n\t\tif getBit(to, position) == 1 {\n\t\t\tpositions = append(positions, position)\n\t\t}\n\n\t\tif position == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn positions, nil\n}\n",
      "length": 1082,
      "tokens": 231,
      "embedding": []
    }
  ]
}