{
  "filepath": "../implementations/go/lnd/shachain/store.go",
  "package": "shachain",
  "sections": [
    {
      "slug": "type Store interface {",
      "content": "type Store interface {\n\t// LookUp function is used to restore/lookup/fetch the previous secret\n\t// by its index.\n\tLookUp(uint64) (*chainhash.Hash, error)\n\n\t// AddNextEntry attempts to store the given hash within its internal\n\t// storage in an efficient manner.\n\t//\n\t// NOTE: The hashes derived from the shachain MUST be inserted in the\n\t// order they're produced by a shachain.Producer.\n\tAddNextEntry(*chainhash.Hash) error\n\n\t// Encode writes a binary serialization of the shachain elements\n\t// currently saved by implementation of shachain.Store to the passed\n\t// io.Writer.\n\tEncode(io.Writer) error\n}\n\n// RevocationStore is a concrete implementation of the Store interface. The\n// revocation store is able to efficiently store N derived shachain elements in\n// a space efficient manner with a space complexity of O(log N). The original\n// description of the storage methodology can be found here:\n// https://github.com/lightningnetwork/lightning-rfc/blob/master/03-transactions.md#efficient-per-commitment-secret-storage",
      "length": 978,
      "tokens": 132,
      "embedding": []
    },
    {
      "slug": "type RevocationStore struct {",
      "content": "type RevocationStore struct {\n\t// lenBuckets stores the number of currently active buckets.\n\tlenBuckets uint8\n\n\t// buckets is an array of elements from which we may derive all\n\t// previous elements, each bucket corresponds to the element with the\n\t// particular number of trailing zeros.\n\tbuckets [maxHeight]element\n\n\t// index is an available index which will be assigned to the new\n\t// element.\n\tindex index\n}\n\n// A compile time check to ensure RevocationStore implements the Store\n// interface.\nvar _ Store = (*RevocationStore)(nil)\n\n// NewRevocationStore creates the new shachain store.",
      "length": 542,
      "tokens": 86,
      "embedding": []
    },
    {
      "slug": "func NewRevocationStore() *RevocationStore {",
      "content": "func NewRevocationStore() *RevocationStore {\n\treturn &RevocationStore{\n\t\tlenBuckets: 0,\n\t\tindex:      startIndex,\n\t}\n}\n\n// NewRevocationStoreFromBytes recreates the initial store state from the given\n// binary shachain store representation.",
      "length": 188,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func NewRevocationStoreFromBytes(r io.Reader) (*RevocationStore, error) {",
      "content": "func NewRevocationStoreFromBytes(r io.Reader) (*RevocationStore, error) {\n\tstore := &RevocationStore{}\n\n\tif err := binary.Read(r, binary.BigEndian, &store.lenBuckets); err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor i := uint8(0); i < store.lenBuckets; i++ {\n\t\tvar hashIndex index\n\t\terr := binary.Read(r, binary.BigEndian, &hashIndex)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tvar nextHash chainhash.Hash\n\t\tif _, err := io.ReadFull(r, nextHash[:]); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tstore.buckets[i] = element{\n\t\t\tindex: hashIndex,\n\t\t\thash:  nextHash,\n\t\t}\n\t}\n\n\tif err := binary.Read(r, binary.BigEndian, &store.index); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn store, nil\n}\n\n// LookUp function is used to restore/lookup/fetch the previous secret by its\n// index. If secret which corresponds to given index was not previously placed\n// in store we will not able to derive it and function will fail.\n//\n// NOTE: This function is part of the Store interface.",
      "length": 846,
      "tokens": 137,
      "embedding": []
    },
    {
      "slug": "func (store *RevocationStore) LookUp(v uint64) (*chainhash.Hash, error) {",
      "content": "func (store *RevocationStore) LookUp(v uint64) (*chainhash.Hash, error) {\n\tind := newIndex(v)\n\n\t// Trying to derive the index from one of the existing buckets elements.\n\tfor i := uint8(0); i < store.lenBuckets; i++ {\n\t\telement, err := store.buckets[i].derive(ind)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\treturn &element.hash, nil\n\t}\n\n\treturn nil, errors.Errorf(\"unable to derive hash #%v\", ind)\n}\n\n// AddNextEntry attempts to store the given hash within its internal storage in\n// an efficient manner.\n//\n// NOTE: The hashes derived from the shachain MUST be inserted in the order\n// they're produced by a shachain.Producer.\n//\n// NOTE: This function is part of the Store interface.",
      "length": 584,
      "tokens": 98,
      "embedding": []
    },
    {
      "slug": "func (store *RevocationStore) AddNextEntry(hash *chainhash.Hash) error {",
      "content": "func (store *RevocationStore) AddNextEntry(hash *chainhash.Hash) error {\n\tnewElement := &element{\n\t\tindex: store.index,\n\t\thash:  *hash,\n\t}\n\n\tbucket := countTrailingZeros(newElement.index)\n\n\tfor i := uint8(0); i < bucket; i++ {\n\t\te, err := newElement.derive(store.buckets[i].index)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif !e.isEqual(&store.buckets[i]) {\n\t\t\treturn errors.New(\"hash isn't derivable from \" +\n\t\t\t\t\"previous ones\")\n\t\t}\n\t}\n\n\tstore.buckets[bucket] = *newElement\n\tif bucket+1 > store.lenBuckets {\n\t\tstore.lenBuckets = bucket + 1\n\t}\n\n\tstore.index--\n\treturn nil\n}\n\n// Encode writes a binary serialization of the shachain elements currently\n// saved by implementation of shachain.Store to the passed io.Writer.\n//\n// NOTE: This function is part of the Store interface.",
      "length": 671,
      "tokens": 96,
      "embedding": []
    },
    {
      "slug": "func (store *RevocationStore) Encode(w io.Writer) error {",
      "content": "func (store *RevocationStore) Encode(w io.Writer) error {\n\terr := binary.Write(w, binary.BigEndian, store.lenBuckets)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor i := uint8(0); i < store.lenBuckets; i++ {\n\t\telement := store.buckets[i]\n\n\t\terr := binary.Write(w, binary.BigEndian, element.index)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif _, err = w.Write(element.hash[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t}\n\n\treturn binary.Write(w, binary.BigEndian, store.index)\n}\n",
      "length": 380,
      "tokens": 56,
      "embedding": []
    }
  ]
}