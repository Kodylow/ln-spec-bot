{
  "filepath": "../implementations/go/lnd/chanrestore.go",
  "package": "lnd",
  "sections": [
    {
      "slug": "type chanDBRestorer struct {",
      "content": "type chanDBRestorer struct {\n\tdb *channeldb.ChannelStateDB\n\n\tsecretKeys keychain.SecretKeyRing\n\n\tchainArb *contractcourt.ChainArbitrator\n}\n\n// openChannelShell maps the static channel back up into an open channel\n// \"shell\". We say shell as this doesn't include all the information required\n// to continue to use the channel, only the minimal amount of information to\n// insert this shell channel back into the database.",
      "length": 381,
      "tokens": 55,
      "embedding": []
    },
    {
      "slug": "func (c *chanDBRestorer) openChannelShell(backup chanbackup.Single) (",
      "content": "func (c *chanDBRestorer) openChannelShell(backup chanbackup.Single) (\n\t*channeldb.ChannelShell, error) {\n\n\tvar err error\n\n\t// Each of the keys in our local channel config only have their\n\t// locators populate, so we'll re-derive the raw key now as we'll need\n\t// it in order to carry out the DLP protocol.\n\tbackup.LocalChanCfg.MultiSigKey, err = c.secretKeys.DeriveKey(\n\t\tbackup.LocalChanCfg.MultiSigKey.KeyLocator,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to derive multi sig key: %v\", err)\n\t}\n\tbackup.LocalChanCfg.RevocationBasePoint, err = c.secretKeys.DeriveKey(\n\t\tbackup.LocalChanCfg.RevocationBasePoint.KeyLocator,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to derive revocation key: %v\", err)\n\t}\n\tbackup.LocalChanCfg.PaymentBasePoint, err = c.secretKeys.DeriveKey(\n\t\tbackup.LocalChanCfg.PaymentBasePoint.KeyLocator,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to derive payment key: %v\", err)\n\t}\n\tbackup.LocalChanCfg.DelayBasePoint, err = c.secretKeys.DeriveKey(\n\t\tbackup.LocalChanCfg.DelayBasePoint.KeyLocator,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to derive delay key: %v\", err)\n\t}\n\tbackup.LocalChanCfg.HtlcBasePoint, err = c.secretKeys.DeriveKey(\n\t\tbackup.LocalChanCfg.HtlcBasePoint.KeyLocator,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to derive htlc key: %v\", err)\n\t}\n\n\t// The shachain root that seeds RevocationProducer for this channel.\n\t// It currently has two possible formats.\n\tvar revRoot *chainhash.Hash\n\n\t// If the PubKey field is non-nil, then this shachain root is using the\n\t// legacy non-ECDH scheme.\n\tif backup.ShaChainRootDesc.PubKey != nil {\n\t\tltndLog.Debugf(\"Using legacy revocation producer format for \"+\n\t\t\t\"channel point %v\", backup.FundingOutpoint)\n\n\t\t// Obtain the private key for the shachain root from the\n\t\t// encoded public key.\n\t\tprivKey, err := c.secretKeys.DerivePrivKey(\n\t\t\tbackup.ShaChainRootDesc,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not derive private key \"+\n\t\t\t\t\"for legacy channel revocation root format: \"+\n\t\t\t\t\"%v\", err)\n\t\t}\n\n\t\trevRoot, err = chainhash.NewHash(privKey.Serialize())\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\tltndLog.Debugf(\"Using new ECDH revocation producer format \"+\n\t\t\t\"for channel point %v\", backup.FundingOutpoint)\n\n\t\t// This is the scheme in which the shachain root is derived via\n\t\t// an ECDH operation on the private key of ShaChainRootDesc and\n\t\t// our public multisig key.\n\t\tecdh, err := c.secretKeys.ECDH(\n\t\t\tbackup.ShaChainRootDesc,\n\t\t\tbackup.LocalChanCfg.MultiSigKey.PubKey,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to derive shachain \"+\n\t\t\t\t\"root: %v\", err)\n\t\t}\n\n\t\tch := chainhash.Hash(ecdh)\n\t\trevRoot = &ch\n\t}\n\n\tshaChainProducer := shachain.NewRevocationProducer(*revRoot)\n\n\tvar chanType channeldb.ChannelType\n\tswitch backup.Version {\n\tcase chanbackup.DefaultSingleVersion:\n\t\tchanType = channeldb.SingleFunderBit\n\n\tcase chanbackup.TweaklessCommitVersion:\n\t\tchanType = channeldb.SingleFunderTweaklessBit\n\n\tcase chanbackup.AnchorsCommitVersion:\n\t\tchanType = channeldb.AnchorOutputsBit\n\t\tchanType |= channeldb.SingleFunderTweaklessBit\n\n\tcase chanbackup.AnchorsZeroFeeHtlcTxCommitVersion:\n\t\tchanType = channeldb.ZeroHtlcTxFeeBit\n\t\tchanType |= channeldb.AnchorOutputsBit\n\t\tchanType |= channeldb.SingleFunderTweaklessBit\n\n\tcase chanbackup.ScriptEnforcedLeaseVersion:\n\t\tchanType = channeldb.LeaseExpirationBit\n\t\tchanType |= channeldb.ZeroHtlcTxFeeBit\n\t\tchanType |= channeldb.AnchorOutputsBit\n\t\tchanType |= channeldb.SingleFunderTweaklessBit\n\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unknown Single version: %v\", err)\n\t}\n\n\tltndLog.Infof(\"SCB Recovery: created channel shell for ChannelPoint\"+\n\t\t\"(%v), chan_type=%v\", backup.FundingOutpoint, chanType)\n\n\tchanShell := channeldb.ChannelShell{\n\t\tNodeAddrs: backup.Addresses,\n\t\tChan: &channeldb.OpenChannel{\n\t\t\tChanType:                chanType,\n\t\t\tChainHash:               backup.ChainHash,\n\t\t\tIsInitiator:             backup.IsInitiator,\n\t\t\tCapacity:                backup.Capacity,\n\t\t\tFundingOutpoint:         backup.FundingOutpoint,\n\t\t\tShortChannelID:          backup.ShortChannelID,\n\t\t\tIdentityPub:             backup.RemoteNodePub,\n\t\t\tIsPending:               false,\n\t\t\tLocalChanCfg:            backup.LocalChanCfg,\n\t\t\tRemoteChanCfg:           backup.RemoteChanCfg,\n\t\t\tRemoteCurrentRevocation: backup.RemoteNodePub,\n\t\t\tRevocationStore:         shachain.NewRevocationStore(),\n\t\t\tRevocationProducer:      shaChainProducer,\n\t\t\tThawHeight:              backup.LeaseExpiry,\n\t\t},\n\t}\n\n\treturn &chanShell, nil\n}\n\n// RestoreChansFromSingles attempts to map the set of single channel backups to\n// channel shells that will be stored persistently. Once these shells have been\n// stored on disk, we'll be able to connect to the channel peer an execute the\n// data loss recovery protocol.\n//\n// NOTE: Part of the chanbackup.ChannelRestorer interface.",
      "length": 4642,
      "tokens": 500,
      "embedding": []
    },
    {
      "slug": "func (c *chanDBRestorer) RestoreChansFromSingles(backups ...chanbackup.Single) error {",
      "content": "func (c *chanDBRestorer) RestoreChansFromSingles(backups ...chanbackup.Single) error {\n\tchannelShells := make([]*channeldb.ChannelShell, 0, len(backups))\n\tfirstChanHeight := uint32(math.MaxUint32)\n\tfor _, backup := range backups {\n\t\tchanShell, err := c.openChannelShell(backup)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Find the block height of the earliest channel in this backup.\n\t\tchanHeight := chanShell.Chan.ShortChanID().BlockHeight\n\t\tif chanHeight != 0 && chanHeight < firstChanHeight {\n\t\t\tfirstChanHeight = chanHeight\n\t\t}\n\n\t\tchannelShells = append(channelShells, chanShell)\n\t}\n\n\t// In case there were only unconfirmed channels, we will have to scan\n\t// the chain beginning from the launch date of SCBs.\n\tif firstChanHeight == math.MaxUint32 {\n\t\tchainHash := channelShells[0].Chan.ChainHash\n\t\tswitch {\n\t\tcase chainHash.IsEqual(chaincfg.MainNetParams.GenesisHash):\n\t\t\tfirstChanHeight = mainnetSCBLaunchBlock\n\n\t\tcase chainHash.IsEqual(chaincfg.TestNet3Params.GenesisHash):\n\t\t\tfirstChanHeight = testnetSCBLaunchBlock\n\n\t\tdefault:\n\t\t\t// Worst case: We have no height hint and start at\n\t\t\t// block 1. Should only happen for SCBs in regtest,\n\t\t\t// simnet and litecoin.\n\t\t\tfirstChanHeight = 1\n\t\t}\n\t}\n\n\t// If there were channels in the backup that were not confirmed at the\n\t// time of the backup creation, they won't have a block height in the\n\t// ShortChanID which would lead to an error in the chain watcher.\n\t// We want to at least set the funding broadcast height that the chain\n\t// watcher can use instead. We have two possible fallback values for\n\t// the broadcast height that we are going to try here.\n\tfor _, chanShell := range channelShells {\n\t\tchannel := chanShell.Chan\n\n\t\tswitch {\n\t\t// Fallback case 1: This is an unconfirmed channel from an old\n\t\t// backup file where we didn't have any workaround in place and\n\t\t// the short channel ID is 0:0:0. Best we can do here is set the\n\t\t// funding broadcast height to a reasonable value that we\n\t\t// determined earlier.\n\t\tcase channel.ShortChanID().BlockHeight == 0:\n\t\t\tchannel.SetBroadcastHeight(firstChanHeight)\n\n\t\t// Fallback case 2: It is extremely unlikely at this point that\n\t\t// a channel we are trying to restore has a coinbase funding TX.\n\t\t// Therefore we can be quite certain that if the TxIndex is\n\t\t// zero but the block height wasn't, it was an unconfirmed\n\t\t// channel where we used the BlockHeight to encode the funding\n\t\t// TX broadcast height. To not end up with an invalid short\n\t\t// channel ID that looks valid, we restore the \"original\"\n\t\t// unconfirmed one here.\n\t\tcase channel.ShortChannelID.TxIndex == 0:\n\t\t\tbroadcastHeight := channel.ShortChannelID.BlockHeight\n\t\t\tchannel.SetBroadcastHeight(broadcastHeight)\n\t\t\tchannel.ShortChannelID.BlockHeight = 0\n\t\t}\n\t}\n\n\tltndLog.Infof(\"Inserting %v SCB channel shells into DB\",\n\t\tlen(channelShells))\n\n\t// Now that we have all the backups mapped into a series of Singles,\n\t// we'll insert them all into the database.\n\tif err := c.db.RestoreChannelShells(channelShells...); err != nil {\n\t\treturn err\n\t}\n\n\tltndLog.Infof(\"Informing chain watchers of new restored channels\")\n\n\t// Finally, we'll need to inform the chain arbitrator of these new\n\t// channels so we'll properly watch for their ultimate closure on chain\n\t// and sweep them via the DLP.\n\tfor _, restoredChannel := range channelShells {\n\t\terr := c.chainArb.WatchNewChannel(restoredChannel.Chan)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// A compile-time constraint to ensure chanDBRestorer implements\n// chanbackup.ChannelRestorer.\nvar _ chanbackup.ChannelRestorer = (*chanDBRestorer)(nil)\n\n// ConnectPeer attempts to connect to the target node at the set of available\n// addresses. Once this method returns with a non-nil error, the connector\n// should attempt to persistently connect to the target peer in the background\n// as a persistent attempt.\n//\n// NOTE: Part of the chanbackup.PeerConnector interface.",
      "length": 3708,
      "tokens": 546,
      "embedding": []
    },
    {
      "slug": "func (s *server) ConnectPeer(nodePub *btcec.PublicKey, addrs []net.Addr) error {",
      "content": "func (s *server) ConnectPeer(nodePub *btcec.PublicKey, addrs []net.Addr) error {\n\t// Before we connect to the remote peer, we'll remove any connections\n\t// to ensure the new connection is created after this new link/channel\n\t// is known.\n\tif err := s.DisconnectPeer(nodePub); err != nil {\n\t\tltndLog.Infof(\"Peer(%v) is already connected, proceeding \"+\n\t\t\t\"with chan restore\", nodePub.SerializeCompressed())\n\t}\n\n\t// For each of the known addresses, we'll attempt to launch a\n\t// persistent connection to the (pub, addr) pair. In the event that any\n\t// of them connect, all the other stale requests will be canceled.\n\tfor _, addr := range addrs {\n\t\tnetAddr := &lnwire.NetAddress{\n\t\t\tIdentityKey: nodePub,\n\t\t\tAddress:     addr,\n\t\t}\n\n\t\tltndLog.Infof(\"Attempting to connect to %v for SCB restore \"+\n\t\t\t\"DLP\", netAddr)\n\n\t\t// Attempt to connect to the peer using this full address. If\n\t\t// we're unable to connect to them, then we'll try the next\n\t\t// address in place of it.\n\t\terr := s.ConnectToPeer(netAddr, true, s.cfg.ConnectionTimeout)\n\n\t\t// If we're already connected to this peer, then we don't\n\t\t// consider this an error, so we'll exit here.\n\t\tif _, ok := err.(*errPeerAlreadyConnected); ok {\n\t\t\treturn nil\n\n\t\t} else if err != nil {\n\t\t\t// Otherwise, something else happened, so we'll try the\n\t\t\t// next address.\n\t\t\tltndLog.Errorf(\"unable to connect to %v to \"+\n\t\t\t\t\"complete SCB restore: %v\", netAddr, err)\n\t\t\tcontinue\n\t\t}\n\n\t\t// If we connected no problem, then we can exit early as our\n\t\t// job here is done.\n\t\treturn nil\n\t}\n\n\treturn fmt.Errorf(\"unable to connect to peer %x for SCB restore\",\n\t\tnodePub.SerializeCompressed())\n}\n",
      "length": 1503,
      "tokens": 240,
      "embedding": []
    }
  ]
}