{
  "filepath": "../implementations/go/lnd/config_builder.go",
  "package": "lnd",
  "sections": [
    {
      "slug": "type GrpcRegistrar interface {",
      "content": "type GrpcRegistrar interface {\n\t// RegisterGrpcSubserver is called for each net.Listener on which lnd\n\t// creates a grpc.Server instance. External subservers implementing this\n\t// method can then register their own gRPC server structs to the main\n\t// server instance.\n\tRegisterGrpcSubserver(*grpc.Server) error\n}\n\n// RestRegistrar is an interface that must be satisfied by an external subserver\n// that wants to be able to register its own REST mux onto lnd's main\n// proxy.ServeMux instance.",
      "length": 452,
      "tokens": 69,
      "embedding": []
    },
    {
      "slug": "type RestRegistrar interface {",
      "content": "type RestRegistrar interface {\n\t// RegisterRestSubserver is called after lnd creates the main\n\t// proxy.ServeMux instance. External subservers implementing this method\n\t// can then register their own REST proxy stubs to the main server\n\t// instance.\n\tRegisterRestSubserver(context.Context, *proxy.ServeMux, string,\n\t\t[]grpc.DialOption) error\n}\n\n// ExternalValidator is an interface that must be satisfied by an external\n// macaroon validator.",
      "length": 402,
      "tokens": 53,
      "embedding": []
    },
    {
      "slug": "type ExternalValidator interface {",
      "content": "type ExternalValidator interface {\n\tmacaroons.MacaroonValidator\n\n\t// Permissions returns the permissions that the external validator is\n\t// validating. It is a map between the full HTTP URI of each RPC and its\n\t// required macaroon permissions. If multiple action/entity tuples are\n\t// specified per URI, they are all required. See rpcserver.go for a list\n\t// of valid action and entity values.\n\tPermissions() map[string][]bakery.Op\n}\n\n// DatabaseBuilder is an interface that must be satisfied by the implementation\n// that provides lnd's main database backend instances.",
      "length": 525,
      "tokens": 79,
      "embedding": []
    },
    {
      "slug": "type DatabaseBuilder interface {",
      "content": "type DatabaseBuilder interface {\n\t// BuildDatabase extracts the current databases that we'll use for\n\t// normal operation in the daemon. A function closure that closes all\n\t// opened databases is also returned.\n\tBuildDatabase(ctx context.Context) (*DatabaseInstances, func(), error)\n}\n\n// WalletConfigBuilder is an interface that must be satisfied by a custom wallet\n// implementation.",
      "length": 345,
      "tokens": 49,
      "embedding": []
    },
    {
      "slug": "type WalletConfigBuilder interface {",
      "content": "type WalletConfigBuilder interface {\n\t// BuildWalletConfig is responsible for creating or unlocking and then\n\t// fully initializing a wallet.\n\tBuildWalletConfig(context.Context, *DatabaseInstances,\n\t\t*rpcperms.InterceptorChain,\n\t\t[]*ListenerWithSignal) (*chainreg.PartialChainControl,\n\t\t*btcwallet.Config, func(), error)\n}\n\n// ChainControlBuilder is an interface that must be satisfied by a custom wallet\n// implementation.",
      "length": 377,
      "tokens": 39,
      "embedding": []
    },
    {
      "slug": "type ChainControlBuilder interface {",
      "content": "type ChainControlBuilder interface {\n\t// BuildChainControl is responsible for creating a fully populated chain\n\t// control instance from a wallet.\n\tBuildChainControl(*chainreg.PartialChainControl,\n\t\t*btcwallet.Config) (*chainreg.ChainControl, func(), error)\n}\n\n// ImplementationCfg is a struct that holds all configuration items for\n// components that can be implemented outside lnd itself.",
      "length": 346,
      "tokens": 42,
      "embedding": []
    },
    {
      "slug": "type ImplementationCfg struct {",
      "content": "type ImplementationCfg struct {\n\t// GrpcRegistrar is a type that can register additional gRPC subservers\n\t// before the main gRPC server is started.\n\tGrpcRegistrar\n\n\t// RestRegistrar is a type that can register additional REST subservers\n\t// before the main REST proxy is started.\n\tRestRegistrar\n\n\t// ExternalValidator is a type that can provide external macaroon\n\t// validation.\n\tExternalValidator\n\n\t// DatabaseBuilder is a type that can provide lnd's main database\n\t// backend instances.\n\tDatabaseBuilder\n\n\t// WalletConfigBuilder is a type that can provide a wallet configuration\n\t// with a fully loaded and unlocked wallet.\n\tWalletConfigBuilder\n\n\t// ChainControlBuilder is a type that can provide a custom wallet\n\t// implementation.\n\tChainControlBuilder\n}\n\n// DefaultWalletImpl is the default implementation of our normal, btcwallet\n// backed configuration.",
      "length": 802,
      "tokens": 116,
      "embedding": []
    },
    {
      "slug": "type DefaultWalletImpl struct {",
      "content": "type DefaultWalletImpl struct {\n\tcfg         *Config\n\tlogger      btclog.Logger\n\tinterceptor signal.Interceptor\n\n\twatchOnly        bool\n\tmigrateWatchOnly bool\n\tpwService        *walletunlocker.UnlockerService\n}\n\n// NewDefaultWalletImpl creates a new default wallet implementation.",
      "length": 239,
      "tokens": 21,
      "embedding": []
    },
    {
      "slug": "func NewDefaultWalletImpl(cfg *Config, logger btclog.Logger,",
      "content": "func NewDefaultWalletImpl(cfg *Config, logger btclog.Logger,\n\tinterceptor signal.Interceptor, watchOnly bool) *DefaultWalletImpl {\n\n\treturn &DefaultWalletImpl{\n\t\tcfg:         cfg,\n\t\tlogger:      logger,\n\t\tinterceptor: interceptor,\n\t\twatchOnly:   watchOnly,\n\t\tpwService:   createWalletUnlockerService(cfg),\n\t}\n}\n\n// RegisterRestSubserver is called after lnd creates the main proxy.ServeMux\n// instance. External subservers implementing this method can then register\n// their own REST proxy stubs to the main server instance.\n//\n// NOTE: This is part of the GrpcRegistrar interface.",
      "length": 504,
      "tokens": 61,
      "embedding": []
    },
    {
      "slug": "func (d *DefaultWalletImpl) RegisterRestSubserver(ctx context.Context,",
      "content": "func (d *DefaultWalletImpl) RegisterRestSubserver(ctx context.Context,\n\tmux *proxy.ServeMux, restProxyDest string,\n\trestDialOpts []grpc.DialOption) error {\n\n\treturn lnrpc.RegisterWalletUnlockerHandlerFromEndpoint(\n\t\tctx, mux, restProxyDest, restDialOpts,\n\t)\n}\n\n// RegisterGrpcSubserver is called for each net.Listener on which lnd creates a\n// grpc.Server instance. External subservers implementing this method can then\n// register their own gRPC server structs to the main server instance.\n//\n// NOTE: This is part of the GrpcRegistrar interface.",
      "length": 464,
      "tokens": 60,
      "embedding": []
    },
    {
      "slug": "func (d *DefaultWalletImpl) RegisterGrpcSubserver(s *grpc.Server) error {",
      "content": "func (d *DefaultWalletImpl) RegisterGrpcSubserver(s *grpc.Server) error {\n\tlnrpc.RegisterWalletUnlockerServer(s, d.pwService)\n\n\treturn nil\n}\n\n// ValidateMacaroon extracts the macaroon from the context's gRPC metadata,\n// checks its signature, makes sure all specified permissions for the called\n// method are contained within and finally ensures all caveat conditions are\n// met. A non-nil error is returned if any of the checks fail.\n//\n// NOTE: This is part of the ExternalValidator interface.",
      "length": 411,
      "tokens": 62,
      "embedding": []
    },
    {
      "slug": "func (d *DefaultWalletImpl) ValidateMacaroon(ctx context.Context,",
      "content": "func (d *DefaultWalletImpl) ValidateMacaroon(ctx context.Context,\n\trequiredPermissions []bakery.Op, fullMethod string) error {\n\n\t// Because the default implementation does not return any permissions,\n\t// we shouldn't be registered as an external validator at all and this\n\t// should never be invoked.\n\treturn fmt.Errorf(\"default implementation does not support external \" +\n\t\t\"macaroon validation\")\n}\n\n// Permissions returns the permissions that the external validator is\n// validating. It is a map between the full HTTP URI of each RPC and its\n// required macaroon permissions. If multiple action/entity tuples are specified\n// per URI, they are all required. See rpcserver.go for a list of valid action\n// and entity values.\n//\n// NOTE: This is part of the ExternalValidator interface.",
      "length": 706,
      "tokens": 111,
      "embedding": []
    },
    {
      "slug": "func (d *DefaultWalletImpl) Permissions() map[string][]bakery.Op {",
      "content": "func (d *DefaultWalletImpl) Permissions() map[string][]bakery.Op {\n\treturn nil\n}\n\n// BuildWalletConfig is responsible for creating or unlocking and then\n// fully initializing a wallet.\n//\n// NOTE: This is part of the WalletConfigBuilder interface.",
      "length": 174,
      "tokens": 28,
      "embedding": []
    },
    {
      "slug": "func (d *DefaultWalletImpl) BuildWalletConfig(ctx context.Context,",
      "content": "func (d *DefaultWalletImpl) BuildWalletConfig(ctx context.Context,\n\tdbs *DatabaseInstances, interceptorChain *rpcperms.InterceptorChain,\n\tgrpcListeners []*ListenerWithSignal) (*chainreg.PartialChainControl,\n\t*btcwallet.Config, func(), error) {\n\n\t// Keep track of our various cleanup functions. We use a defer function\n\t// as well to not repeat ourselves with every return statement.\n\tvar (\n\t\tcleanUpTasks []func()\n\t\tearlyExit    = true\n\t\tcleanUp      = func() {\n\t\t\tfor _, fn := range cleanUpTasks {\n\t\t\t\tif fn == nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tfn()\n\t\t\t}\n\t\t}\n\t)\n\tdefer func() {\n\t\tif earlyExit {\n\t\t\tcleanUp()\n\t\t}\n\t}()\n\n\t// Initialize a new block cache.\n\tblockCache := blockcache.NewBlockCache(d.cfg.BlockCacheSize)\n\n\t// Before starting the wallet, we'll create and start our Neutrino\n\t// light client instance, if enabled, in order to allow it to sync\n\t// while the rest of the daemon continues startup.\n\tmainChain := d.cfg.Bitcoin\n\tif d.cfg.registeredChains.PrimaryChain() == chainreg.LitecoinChain {\n\t\tmainChain = d.cfg.Litecoin\n\t}\n\tvar neutrinoCS *neutrino.ChainService\n\tif mainChain.Node == \"neutrino\" {\n\t\tneutrinoBackend, neutrinoCleanUp, err := initNeutrinoBackend(\n\t\t\tctx, d.cfg, mainChain.ChainDir, blockCache,\n\t\t)\n\t\tif err != nil {\n\t\t\terr := fmt.Errorf(\"unable to initialize neutrino \"+\n\t\t\t\t\"backend: %v\", err)\n\t\t\td.logger.Error(err)\n\t\t\treturn nil, nil, nil, err\n\t\t}\n\t\tcleanUpTasks = append(cleanUpTasks, neutrinoCleanUp)\n\t\tneutrinoCS = neutrinoBackend\n\t}\n\n\tvar (\n\t\twalletInitParams = walletunlocker.WalletUnlockParams{\n\t\t\t// In case we do auto-unlock, we need to be able to send\n\t\t\t// into the channel without blocking so we buffer it.\n\t\t\tMacResponseChan: make(chan []byte, 1),\n\t\t}\n\t\tprivateWalletPw = lnwallet.DefaultPrivatePassphrase\n\t\tpublicWalletPw  = lnwallet.DefaultPublicPassphrase\n\t)\n\n\t// If the user didn't request a seed, then we'll manually assume a\n\t// wallet birthday of now, as otherwise the seed would've specified\n\t// this information.\n\twalletInitParams.Birthday = time.Now()\n\n\td.pwService.SetLoaderOpts([]btcwallet.LoaderOption{dbs.WalletDB})\n\td.pwService.SetMacaroonDB(dbs.MacaroonDB)\n\twalletExists, err := d.pwService.WalletExists()\n\tif err != nil {\n\t\treturn nil, nil, nil, err\n\t}\n\n\tif !walletExists {\n\t\tinterceptorChain.SetWalletNotCreated()\n\t} else {\n\t\tinterceptorChain.SetWalletLocked()\n\t}\n\n\t// If we've started in auto unlock mode, then a wallet should already\n\t// exist because we don't want to enable the RPC unlocker in that case\n\t// for security reasons (an attacker could inject their seed since the\n\t// RPC is unauthenticated). Only if the user explicitly wants to allow\n\t// wallet creation we don't error out here.\n\tif d.cfg.WalletUnlockPasswordFile != \"\" && !walletExists &&\n\t\t!d.cfg.WalletUnlockAllowCreate {\n\n\t\treturn nil, nil, nil, fmt.Errorf(\"wallet unlock password file \" +\n\t\t\t\"was specified but wallet does not exist; initialize \" +\n\t\t\t\"the wallet before using auto unlocking\")\n\t}\n\n\t// What wallet mode are we running in? We've already made sure the no\n\t// seed backup and auto unlock aren't both set during config parsing.\n\tswitch {\n\t// No seed backup means we're also using the default password.\n\tcase d.cfg.NoSeedBackup:\n\t\t// We continue normally, the default password has already been\n\t\t// set above.\n\n\t// A password for unlocking is provided in a file.\n\tcase d.cfg.WalletUnlockPasswordFile != \"\" && walletExists:\n\t\td.logger.Infof(\"Attempting automatic wallet unlock with \" +\n\t\t\t\"password provided in file\")\n\t\tpwBytes, err := ioutil.ReadFile(d.cfg.WalletUnlockPasswordFile)\n\t\tif err != nil {\n\t\t\treturn nil, nil, nil, fmt.Errorf(\"error reading \"+\n\t\t\t\t\"password from file %s: %v\",\n\t\t\t\td.cfg.WalletUnlockPasswordFile, err)\n\t\t}\n\n\t\t// Remove any newlines at the end of the file. The lndinit tool\n\t\t// won't ever write a newline but maybe the file was provisioned\n\t\t// by another process or user.\n\t\tpwBytes = bytes.TrimRight(pwBytes, \"\\r\\n\")\n\n\t\t// We have the password now, we can ask the unlocker service to\n\t\t// do the unlock for us.\n\t\tunlockedWallet, unloadWalletFn, err := d.pwService.LoadAndUnlock(\n\t\t\tpwBytes, 0,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, nil, nil, fmt.Errorf(\"error unlocking \"+\n\t\t\t\t\"wallet with password from file: %v\", err)\n\t\t}\n\n\t\tcleanUpTasks = append(cleanUpTasks, func() {\n\t\t\tif err := unloadWalletFn(); err != nil {\n\t\t\t\td.logger.Errorf(\"Could not unload wallet: %v\",\n\t\t\t\t\terr)\n\t\t\t}\n\t\t})\n\n\t\tprivateWalletPw = pwBytes\n\t\tpublicWalletPw = pwBytes\n\t\twalletInitParams.Wallet = unlockedWallet\n\t\twalletInitParams.UnloadWallet = unloadWalletFn\n\n\t// If none of the automatic startup options are selected, we fall back\n\t// to the default behavior of waiting for the wallet creation/unlocking\n\t// over RPC.\n\tdefault:\n\t\tif err := d.interceptor.Notifier.NotifyReady(false); err != nil {\n\t\t\treturn nil, nil, nil, err\n\t\t}\n\n\t\tparams, err := waitForWalletPassword(\n\t\t\td.cfg, d.pwService, []btcwallet.LoaderOption{dbs.WalletDB},\n\t\t\td.interceptor.ShutdownChannel(),\n\t\t)\n\t\tif err != nil {\n\t\t\terr := fmt.Errorf(\"unable to set up wallet password \"+\n\t\t\t\t\"listeners: %v\", err)\n\t\t\td.logger.Error(err)\n\t\t\treturn nil, nil, nil, err\n\t\t}\n\n\t\twalletInitParams = *params\n\t\tprivateWalletPw = walletInitParams.Password\n\t\tpublicWalletPw = walletInitParams.Password\n\t\tcleanUpTasks = append(cleanUpTasks, func() {\n\t\t\tif err := walletInitParams.UnloadWallet(); err != nil {\n\t\t\t\td.logger.Errorf(\"Could not unload wallet: %v\",\n\t\t\t\t\terr)\n\t\t\t}\n\t\t})\n\n\t\tif walletInitParams.RecoveryWindow > 0 {\n\t\t\td.logger.Infof(\"Wallet recovery mode enabled with \"+\n\t\t\t\t\"address lookahead of %d addresses\",\n\t\t\t\twalletInitParams.RecoveryWindow)\n\t\t}\n\t}\n\n\tvar macaroonService *macaroons.Service\n\tif !d.cfg.NoMacaroons {\n\t\t// Create the macaroon authentication/authorization service.\n\t\trootKeyStore, err := macaroons.NewRootKeyStorage(dbs.MacaroonDB)\n\t\tif err != nil {\n\t\t\treturn nil, nil, nil, err\n\t\t}\n\t\tmacaroonService, err = macaroons.NewService(\n\t\t\trootKeyStore, \"lnd\", walletInitParams.StatelessInit,\n\t\t\tmacaroons.IPLockChecker,\n\t\t\tmacaroons.CustomChecker(interceptorChain),\n\t\t)\n\t\tif err != nil {\n\t\t\terr := fmt.Errorf(\"unable to set up macaroon \"+\n\t\t\t\t\"authentication: %v\", err)\n\t\t\td.logger.Error(err)\n\t\t\treturn nil, nil, nil, err\n\t\t}\n\t\tcleanUpTasks = append(cleanUpTasks, func() {\n\t\t\tif err := macaroonService.Close(); err != nil {\n\t\t\t\td.logger.Errorf(\"Could not close macaroon \"+\n\t\t\t\t\t\"service: %v\", err)\n\t\t\t}\n\t\t})\n\n\t\t// Try to unlock the macaroon store with the private password.\n\t\t// Ignore ErrAlreadyUnlocked since it could be unlocked by the\n\t\t// wallet unlocker.\n\t\terr = macaroonService.CreateUnlock(&privateWalletPw)\n\t\tif err != nil && err != macaroons.ErrAlreadyUnlocked {\n\t\t\terr := fmt.Errorf(\"unable to unlock macaroons: %v\", err)\n\t\t\td.logger.Error(err)\n\t\t\treturn nil, nil, nil, err\n\t\t}\n\n\t\t// If we have a macaroon root key from the init wallet params,\n\t\t// set the root key before baking any macaroons.\n\t\tif len(walletInitParams.MacRootKey) > 0 {\n\t\t\terr := macaroonService.SetRootKey(\n\t\t\t\twalletInitParams.MacRootKey,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, nil, err\n\t\t\t}\n\t\t}\n\n\t\t// Send an admin macaroon to all our listeners that requested\n\t\t// one by setting a non-nil macaroon channel.\n\t\tadminMacBytes, err := bakeMacaroon(\n\t\t\tctx, macaroonService, adminPermissions(),\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, nil, nil, err\n\t\t}\n\t\tfor _, lis := range grpcListeners {\n\t\t\tif lis.MacChan != nil {\n\t\t\t\tlis.MacChan <- adminMacBytes\n\t\t\t}\n\t\t}\n\n\t\t// In case we actually needed to unlock the wallet, we now need\n\t\t// to create an instance of the admin macaroon and send it to\n\t\t// the unlocker so it can forward it to the user. In no seed\n\t\t// backup mode, there's nobody listening on the channel and we'd\n\t\t// block here forever.\n\t\tif !d.cfg.NoSeedBackup {\n\t\t\t// The channel is buffered by one element so writing\n\t\t\t// should not block here.\n\t\t\twalletInitParams.MacResponseChan <- adminMacBytes\n\t\t}\n\n\t\t// If the user requested a stateless initialization, no macaroon\n\t\t// files should be created.\n\t\tif !walletInitParams.StatelessInit &&\n\t\t\t!lnrpc.FileExists(d.cfg.AdminMacPath) &&\n\t\t\t!lnrpc.FileExists(d.cfg.ReadMacPath) &&\n\t\t\t!lnrpc.FileExists(d.cfg.InvoiceMacPath) {\n\n\t\t\t// Create macaroon files for lncli to use if they don't\n\t\t\t// exist.\n\t\t\terr = genMacaroons(\n\t\t\t\tctx, macaroonService, d.cfg.AdminMacPath,\n\t\t\t\td.cfg.ReadMacPath, d.cfg.InvoiceMacPath,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\terr := fmt.Errorf(\"unable to create macaroons \"+\n\t\t\t\t\t\"%v\", err)\n\t\t\t\td.logger.Error(err)\n\t\t\t\treturn nil, nil, nil, err\n\t\t\t}\n\t\t}\n\n\t\t// As a security service to the user, if they requested\n\t\t// stateless initialization and there are macaroon files on disk\n\t\t// we log a warning.\n\t\tif walletInitParams.StatelessInit {\n\t\t\tmsg := \"Found %s macaroon on disk (%s) even though \" +\n\t\t\t\t\"--stateless_init was requested. Unencrypted \" +\n\t\t\t\t\"state is accessible by the host system. You \" +\n\t\t\t\t\"should change the password and use \" +\n\t\t\t\t\"--new_mac_root_key with --stateless_init to \" +\n\t\t\t\t\"clean up and invalidate old macaroons.\"\n\n\t\t\tif lnrpc.FileExists(d.cfg.AdminMacPath) {\n\t\t\t\td.logger.Warnf(msg, \"admin\", d.cfg.AdminMacPath)\n\t\t\t}\n\t\t\tif lnrpc.FileExists(d.cfg.ReadMacPath) {\n\t\t\t\td.logger.Warnf(msg, \"readonly\", d.cfg.ReadMacPath)\n\t\t\t}\n\t\t\tif lnrpc.FileExists(d.cfg.InvoiceMacPath) {\n\t\t\t\td.logger.Warnf(msg, \"invoice\", d.cfg.InvoiceMacPath)\n\t\t\t}\n\t\t}\n\n\t\t// We add the macaroon service to our RPC interceptor. This\n\t\t// will start checking macaroons against permissions on every\n\t\t// RPC invocation.\n\t\tinterceptorChain.AddMacaroonService(macaroonService)\n\t}\n\n\t// Now that the wallet password has been provided, transition the RPC\n\t// state into Unlocked.\n\tinterceptorChain.SetWalletUnlocked()\n\n\t// Since calls to the WalletUnlocker service wait for a response on the\n\t// macaroon channel, we close it here to make sure they return in case\n\t// we did not return the admin macaroon above. This will be the case if\n\t// --no-macaroons is used.\n\tclose(walletInitParams.MacResponseChan)\n\n\t// We'll also close all the macaroon channels since lnd is done sending\n\t// macaroon data over it.\n\tfor _, lis := range grpcListeners {\n\t\tif lis.MacChan != nil {\n\t\t\tclose(lis.MacChan)\n\t\t}\n\t}\n\n\t// With the information parsed from the configuration, create valid\n\t// instances of the pertinent interfaces required to operate the\n\t// Lightning Network Daemon.\n\t//\n\t// When we create the chain control, we need storage for the height\n\t// hints and also the wallet itself, for these two we want them to be\n\t// replicated, so we'll pass in the remote channel DB instance.\n\tchainControlCfg := &chainreg.Config{\n\t\tBitcoin:                     d.cfg.Bitcoin,\n\t\tLitecoin:                    d.cfg.Litecoin,\n\t\tPrimaryChain:                d.cfg.registeredChains.PrimaryChain,\n\t\tHeightHintCacheQueryDisable: d.cfg.HeightHintCacheQueryDisable,\n\t\tNeutrinoMode:                d.cfg.NeutrinoMode,\n\t\tBitcoindMode:                d.cfg.BitcoindMode,\n\t\tLitecoindMode:               d.cfg.LitecoindMode,\n\t\tBtcdMode:                    d.cfg.BtcdMode,\n\t\tLtcdMode:                    d.cfg.LtcdMode,\n\t\tHeightHintDB:                dbs.HeightHintDB,\n\t\tChanStateDB:                 dbs.ChanStateDB.ChannelStateDB(),\n\t\tNeutrinoCS:                  neutrinoCS,\n\t\tActiveNetParams:             d.cfg.ActiveNetParams,\n\t\tFeeURL:                      d.cfg.FeeURL,\n\t\tDialer: func(addr string) (net.Conn, error) {\n\t\t\treturn d.cfg.net.Dial(\n\t\t\t\t\"tcp\", addr, d.cfg.ConnectionTimeout,\n\t\t\t)\n\t\t},\n\t\tBlockCache:         blockCache,\n\t\tWalletUnlockParams: &walletInitParams,\n\t}\n\n\t// Let's go ahead and create the partial chain control now that is only\n\t// dependent on our configuration and doesn't require any wallet\n\t// specific information.\n\tpartialChainControl, pccCleanup, err := chainreg.NewPartialChainControl(\n\t\tchainControlCfg,\n\t)\n\tcleanUpTasks = append(cleanUpTasks, pccCleanup)\n\tif err != nil {\n\t\terr := fmt.Errorf(\"unable to create partial chain control: %v\",\n\t\t\terr)\n\t\td.logger.Error(err)\n\t\treturn nil, nil, nil, err\n\t}\n\n\twalletConfig := &btcwallet.Config{\n\t\tPrivatePass:      privateWalletPw,\n\t\tPublicPass:       publicWalletPw,\n\t\tBirthday:         walletInitParams.Birthday,\n\t\tRecoveryWindow:   walletInitParams.RecoveryWindow,\n\t\tNetParams:        d.cfg.ActiveNetParams.Params,\n\t\tCoinType:         d.cfg.ActiveNetParams.CoinType,\n\t\tWallet:           walletInitParams.Wallet,\n\t\tLoaderOptions:    []btcwallet.LoaderOption{dbs.WalletDB},\n\t\tChainSource:      partialChainControl.ChainSource,\n\t\tWatchOnly:        d.watchOnly,\n\t\tMigrateWatchOnly: d.migrateWatchOnly,\n\t}\n\n\t// Parse coin selection strategy.\n\tswitch d.cfg.CoinSelectionStrategy {\n\tcase \"largest\":\n\t\twalletConfig.CoinSelectionStrategy = wallet.CoinSelectionLargest\n\n\tcase \"random\":\n\t\twalletConfig.CoinSelectionStrategy = wallet.CoinSelectionRandom\n\n\tdefault:\n\t\treturn nil, nil, nil, fmt.Errorf(\"unknown coin selection \"+\n\t\t\t\"strategy %v\", d.cfg.CoinSelectionStrategy)\n\t}\n\n\tearlyExit = false\n\treturn partialChainControl, walletConfig, cleanUp, nil\n}\n\n// BuildChainControl is responsible for creating a fully populated chain\n// control instance from a wallet.\n//\n// NOTE: This is part of the ChainControlBuilder interface.",
      "length": 12566,
      "tokens": 1574,
      "embedding": []
    },
    {
      "slug": "func (d *DefaultWalletImpl) BuildChainControl(",
      "content": "func (d *DefaultWalletImpl) BuildChainControl(\n\tpartialChainControl *chainreg.PartialChainControl,\n\twalletConfig *btcwallet.Config) (*chainreg.ChainControl, func(), error) {\n\n\twalletController, err := btcwallet.New(\n\t\t*walletConfig, partialChainControl.Cfg.BlockCache,\n\t)\n\tif err != nil {\n\t\terr := fmt.Errorf(\"unable to create wallet controller: %v\", err)\n\t\td.logger.Error(err)\n\t\treturn nil, nil, err\n\t}\n\n\tkeyRing := keychain.NewBtcWalletKeyRing(\n\t\twalletController.InternalWallet(), walletConfig.CoinType,\n\t)\n\n\t// Create, and start the lnwallet, which handles the core payment\n\t// channel logic, and exposes control via proxy state machines.\n\tlnWalletConfig := lnwallet.Config{\n\t\tDatabase:           partialChainControl.Cfg.ChanStateDB,\n\t\tNotifier:           partialChainControl.ChainNotifier,\n\t\tWalletController:   walletController,\n\t\tSigner:             walletController,\n\t\tFeeEstimator:       partialChainControl.FeeEstimator,\n\t\tSecretKeyRing:      keyRing,\n\t\tChainIO:            walletController,\n\t\tDefaultConstraints: partialChainControl.ChannelConstraints,\n\t\tNetParams:          *walletConfig.NetParams,\n\t}\n\n\t// We've created the wallet configuration now, so we can finish\n\t// initializing the main chain control.\n\tactiveChainControl, cleanUp, err := chainreg.NewChainControl(\n\t\tlnWalletConfig, walletController, partialChainControl,\n\t)\n\tif err != nil {\n\t\terr := fmt.Errorf(\"unable to create chain control: %v\", err)\n\t\td.logger.Error(err)\n\t\treturn nil, nil, err\n\t}\n\n\treturn activeChainControl, cleanUp, nil\n}\n\n// RPCSignerWalletImpl is a wallet implementation that uses a remote signer over\n// an RPC interface.",
      "length": 1526,
      "tokens": 151,
      "embedding": []
    },
    {
      "slug": "type RPCSignerWalletImpl struct {",
      "content": "type RPCSignerWalletImpl struct {\n\t// DefaultWalletImpl is the embedded instance of the default\n\t// implementation that the remote signer uses as its watch-only wallet\n\t// for keeping track of addresses and UTXOs.\n\t*DefaultWalletImpl\n}\n\n// NewRPCSignerWalletImpl creates a new instance of the remote signing wallet\n// implementation.",
      "length": 292,
      "tokens": 43,
      "embedding": []
    },
    {
      "slug": "func NewRPCSignerWalletImpl(cfg *Config, logger btclog.Logger,",
      "content": "func NewRPCSignerWalletImpl(cfg *Config, logger btclog.Logger,\n\tinterceptor signal.Interceptor,\n\tmigrateWatchOnly bool) *RPCSignerWalletImpl {\n\n\treturn &RPCSignerWalletImpl{\n\t\tDefaultWalletImpl: &DefaultWalletImpl{\n\t\t\tcfg:              cfg,\n\t\t\tlogger:           logger,\n\t\t\tinterceptor:      interceptor,\n\t\t\twatchOnly:        true,\n\t\t\tmigrateWatchOnly: migrateWatchOnly,\n\t\t\tpwService:        createWalletUnlockerService(cfg),\n\t\t},\n\t}\n}\n\n// BuildChainControl is responsible for creating or unlocking and then fully\n// initializing a wallet and returning it as part of a fully populated chain\n// control instance.\n//\n// NOTE: This is part of the ChainControlBuilder interface.",
      "length": 591,
      "tokens": 63,
      "embedding": []
    },
    {
      "slug": "func (d *RPCSignerWalletImpl) BuildChainControl(",
      "content": "func (d *RPCSignerWalletImpl) BuildChainControl(\n\tpartialChainControl *chainreg.PartialChainControl,\n\twalletConfig *btcwallet.Config) (*chainreg.ChainControl, func(), error) {\n\n\twalletController, err := btcwallet.New(\n\t\t*walletConfig, partialChainControl.Cfg.BlockCache,\n\t)\n\tif err != nil {\n\t\terr := fmt.Errorf(\"unable to create wallet controller: %v\", err)\n\t\td.logger.Error(err)\n\t\treturn nil, nil, err\n\t}\n\n\tbaseKeyRing := keychain.NewBtcWalletKeyRing(\n\t\twalletController.InternalWallet(), walletConfig.CoinType,\n\t)\n\n\trpcKeyRing, err := rpcwallet.NewRPCKeyRing(\n\t\tbaseKeyRing, walletController,\n\t\td.DefaultWalletImpl.cfg.RemoteSigner, walletConfig.NetParams,\n\t)\n\tif err != nil {\n\t\terr := fmt.Errorf(\"unable to create RPC remote signing wallet \"+\n\t\t\t\"%v\", err)\n\t\td.logger.Error(err)\n\t\treturn nil, nil, err\n\t}\n\n\t// Create, and start the lnwallet, which handles the core payment\n\t// channel logic, and exposes control via proxy state machines.\n\tlnWalletConfig := lnwallet.Config{\n\t\tDatabase:           partialChainControl.Cfg.ChanStateDB,\n\t\tNotifier:           partialChainControl.ChainNotifier,\n\t\tWalletController:   rpcKeyRing,\n\t\tSigner:             rpcKeyRing,\n\t\tFeeEstimator:       partialChainControl.FeeEstimator,\n\t\tSecretKeyRing:      rpcKeyRing,\n\t\tChainIO:            walletController,\n\t\tDefaultConstraints: partialChainControl.ChannelConstraints,\n\t\tNetParams:          *walletConfig.NetParams,\n\t}\n\n\t// We've created the wallet configuration now, so we can finish\n\t// initializing the main chain control.\n\tactiveChainControl, cleanUp, err := chainreg.NewChainControl(\n\t\tlnWalletConfig, rpcKeyRing, partialChainControl,\n\t)\n\tif err != nil {\n\t\terr := fmt.Errorf(\"unable to create chain control: %v\", err)\n\t\td.logger.Error(err)\n\t\treturn nil, nil, err\n\t}\n\n\treturn activeChainControl, cleanUp, nil\n}\n\n// DatabaseInstances is a struct that holds all instances to the actual\n// databases that are used in lnd.",
      "length": 1801,
      "tokens": 186,
      "embedding": []
    },
    {
      "slug": "type DatabaseInstances struct {",
      "content": "type DatabaseInstances struct {\n\t// GraphDB is the database that stores the channel graph used for path\n\t// finding.\n\t//\n\t// NOTE/TODO: This currently _needs_ to be the same instance as the\n\t// ChanStateDB below until the separation of the two databases is fully\n\t// complete!\n\tGraphDB *channeldb.DB\n\n\t// ChanStateDB is the database that stores all of our node's channel\n\t// state.\n\t//\n\t// NOTE/TODO: This currently _needs_ to be the same instance as the\n\t// GraphDB above until the separation of the two databases is fully\n\t// complete!\n\tChanStateDB *channeldb.DB\n\n\t// HeightHintDB is the database that stores height hints for spends.\n\tHeightHintDB kvdb.Backend\n\n\t// InvoiceDB is the database that stores information about invoices.\n\tInvoiceDB invoices.InvoiceDB\n\n\t// MacaroonDB is the database that stores macaroon root keys.\n\tMacaroonDB kvdb.Backend\n\n\t// DecayedLogDB is the database that stores p2p related encryption\n\t// information.\n\tDecayedLogDB kvdb.Backend\n\n\t// TowerClientDB is the database that stores the watchtower client's\n\t// configuration.\n\tTowerClientDB wtclient.DB\n\n\t// TowerServerDB is the database that stores the watchtower server's\n\t// configuration.\n\tTowerServerDB watchtower.DB\n\n\t// WalletDB is the configuration for loading the wallet database using\n\t// the btcwallet's loader.\n\tWalletDB btcwallet.LoaderOption\n}\n\n// DefaultDatabaseBuilder is a type that builds the default database backends\n// for lnd, using the given configuration to decide what actual implementation\n// to use.",
      "length": 1430,
      "tokens": 210,
      "embedding": []
    },
    {
      "slug": "type DefaultDatabaseBuilder struct {",
      "content": "type DefaultDatabaseBuilder struct {\n\tcfg    *Config\n\tlogger btclog.Logger\n}\n\n// NewDefaultDatabaseBuilder returns a new instance of the default database\n// builder.",
      "length": 123,
      "tokens": 17,
      "embedding": []
    },
    {
      "slug": "func NewDefaultDatabaseBuilder(cfg *Config,",
      "content": "func NewDefaultDatabaseBuilder(cfg *Config,\n\tlogger btclog.Logger) *DefaultDatabaseBuilder {\n\n\treturn &DefaultDatabaseBuilder{\n\t\tcfg:    cfg,\n\t\tlogger: logger,\n\t}\n}\n\n// BuildDatabase extracts the current databases that we'll use for normal\n// operation in the daemon. A function closure that closes all opened databases\n// is also returned.",
      "length": 286,
      "tokens": 40,
      "embedding": []
    },
    {
      "slug": "func (d *DefaultDatabaseBuilder) BuildDatabase(",
      "content": "func (d *DefaultDatabaseBuilder) BuildDatabase(\n\tctx context.Context) (*DatabaseInstances, func(), error) {\n\n\td.logger.Infof(\"Opening the main database, this might take a few \" +\n\t\t\"minutes...\")\n\n\tcfg := d.cfg\n\tif cfg.DB.Backend == lncfg.BoltBackend {\n\t\td.logger.Infof(\"Opening bbolt database, sync_freelist=%v, \"+\n\t\t\t\"auto_compact=%v\", !cfg.DB.Bolt.NoFreelistSync,\n\t\t\tcfg.DB.Bolt.AutoCompact)\n\t}\n\n\tstartOpenTime := time.Now()\n\n\tdatabaseBackends, err := cfg.DB.GetBackends(\n\t\tctx, cfg.graphDatabaseDir(), cfg.networkDir, filepath.Join(\n\t\t\tcfg.Watchtower.TowerDir,\n\t\t\tcfg.registeredChains.PrimaryChain().String(),\n\t\t\tlncfg.NormalizeNetwork(cfg.ActiveNetParams.Name),\n\t\t), cfg.WtClient.Active, cfg.Watchtower.Active, d.logger,\n\t)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"unable to obtain database \"+\n\t\t\t\"backends: %v\", err)\n\t}\n\n\t// With the full remote mode we made sure both the graph and channel\n\t// state DB point to the same local or remote DB and the same namespace\n\t// within that DB.\n\tdbs := &DatabaseInstances{\n\t\tHeightHintDB: databaseBackends.HeightHintDB,\n\t\tMacaroonDB:   databaseBackends.MacaroonDB,\n\t\tDecayedLogDB: databaseBackends.DecayedLogDB,\n\t\tWalletDB:     databaseBackends.WalletDB,\n\t}\n\tcleanUp := func() {\n\t\t// We can just close the returned close functions directly. Even\n\t\t// if we decorate the channel DB with an additional struct, its\n\t\t// close function still just points to the kvdb backend.\n\t\tfor name, closeFunc := range databaseBackends.CloseFuncs {\n\t\t\tif err := closeFunc(); err != nil {\n\t\t\t\td.logger.Errorf(\"Error closing %s \"+\n\t\t\t\t\t\"database: %v\", name, err)\n\t\t\t}\n\t\t}\n\t}\n\tif databaseBackends.Remote {\n\t\td.logger.Infof(\"Using remote %v database! Creating \"+\n\t\t\t\"graph and channel state DB instances\", cfg.DB.Backend)\n\t} else {\n\t\td.logger.Infof(\"Creating local graph and channel state DB \" +\n\t\t\t\"instances\")\n\t}\n\n\tdbOptions := []channeldb.OptionModifier{\n\t\tchanneldb.OptionSetRejectCacheSize(cfg.Caches.RejectCacheSize),\n\t\tchanneldb.OptionSetChannelCacheSize(\n\t\t\tcfg.Caches.ChannelCacheSize,\n\t\t),\n\t\tchanneldb.OptionSetBatchCommitInterval(\n\t\t\tcfg.DB.BatchCommitInterval,\n\t\t),\n\t\tchanneldb.OptionDryRunMigration(cfg.DryRunMigration),\n\t\tchanneldb.OptionSetUseGraphCache(!cfg.DB.NoGraphCache),\n\t\tchanneldb.OptionKeepFailedPaymentAttempts(\n\t\t\tcfg.KeepFailedPaymentAttempts,\n\t\t),\n\t\tchanneldb.OptionStoreFinalHtlcResolutions(\n\t\t\tcfg.StoreFinalHtlcResolutions,\n\t\t),\n\t\tchanneldb.OptionPruneRevocationLog(cfg.DB.PruneRevocation),\n\t\tchanneldb.OptionNoRevLogAmtData(cfg.DB.NoRevLogAmtData),\n\t}\n\n\t// We want to pre-allocate the channel graph cache according to what we\n\t// expect for mainnet to speed up memory allocation.\n\tif cfg.ActiveNetParams.Name == chaincfg.MainNetParams.Name {\n\t\tdbOptions = append(\n\t\t\tdbOptions, channeldb.OptionSetPreAllocCacheNumNodes(\n\t\t\t\tchanneldb.DefaultPreAllocCacheNumNodes,\n\t\t\t),\n\t\t)\n\t}\n\n\t// Otherwise, we'll open two instances, one for the state we only need\n\t// locally, and the other for things we want to ensure are replicated.\n\tdbs.GraphDB, err = channeldb.CreateWithBackend(\n\t\tdatabaseBackends.GraphDB, dbOptions...,\n\t)\n\tswitch {\n\t// Give the DB a chance to dry run the migration. Since we know that\n\t// both the channel state and graph DBs are still always behind the same\n\t// backend, we know this would be applied to both of those DBs.\n\tcase err == channeldb.ErrDryRunMigrationOK:\n\t\td.logger.Infof(\"Graph DB dry run migration successful\")\n\t\treturn nil, nil, err\n\n\tcase err != nil:\n\t\tcleanUp()\n\n\t\terr := fmt.Errorf(\"unable to open graph DB: %v\", err)\n\t\td.logger.Error(err)\n\t\treturn nil, nil, err\n\t}\n\n\t// For now, we don't _actually_ split the graph and channel state DBs on\n\t// the code level. Since they both are based upon the *channeldb.DB\n\t// struct it will require more refactoring to fully separate them. With\n\t// the full remote mode we at least know for now that they both point to\n\t// the same DB backend (and also namespace within that) so we only need\n\t// to apply any migration once.\n\t//\n\t// TODO(guggero): Once the full separation of anything graph related\n\t// from the channeldb.DB is complete, the decorated instance of the\n\t// channel state DB should be created here individually instead of just\n\t// using the same struct (and DB backend) instance.\n\tdbs.ChanStateDB = dbs.GraphDB\n\n\t// For now the only InvoiceDB implementation is the *channeldb.DB.\n\t//\n\t// TODO(positiveblue): use a sql first implementation for this\n\t// interface.\n\tdbs.InvoiceDB = dbs.GraphDB\n\n\t// Wrap the watchtower client DB and make sure we clean up.\n\tif cfg.WtClient.Active {\n\t\tdbs.TowerClientDB, err = wtdb.OpenClientDB(\n\t\t\tdatabaseBackends.TowerClientDB,\n\t\t)\n\t\tif err != nil {\n\t\t\tcleanUp()\n\n\t\t\terr := fmt.Errorf(\"unable to open %s database: %v\",\n\t\t\t\tlncfg.NSTowerClientDB, err)\n\t\t\td.logger.Error(err)\n\t\t\treturn nil, nil, err\n\t\t}\n\t}\n\n\t// Wrap the watchtower server DB and make sure we clean up.\n\tif cfg.Watchtower.Active {\n\t\tdbs.TowerServerDB, err = wtdb.OpenTowerDB(\n\t\t\tdatabaseBackends.TowerServerDB,\n\t\t)\n\t\tif err != nil {\n\t\t\tcleanUp()\n\n\t\t\terr := fmt.Errorf(\"unable to open %s database: %v\",\n\t\t\t\tlncfg.NSTowerServerDB, err)\n\t\t\td.logger.Error(err)\n\t\t\treturn nil, nil, err\n\t\t}\n\t}\n\n\topenTime := time.Since(startOpenTime)\n\td.logger.Infof(\"Database(s) now open (time_to_open=%v)!\", openTime)\n\n\treturn dbs, cleanUp, nil\n}\n\n// waitForWalletPassword blocks until a password is provided by the user to\n// this RPC server.",
      "length": 5155,
      "tokens": 639,
      "embedding": []
    },
    {
      "slug": "func waitForWalletPassword(cfg *Config,",
      "content": "func waitForWalletPassword(cfg *Config,\n\tpwService *walletunlocker.UnlockerService,\n\tloaderOpts []btcwallet.LoaderOption, shutdownChan <-chan struct{}) (\n\t*walletunlocker.WalletUnlockParams, error) {\n\n\t// Wait for user to provide the password.\n\tltndLog.Infof(\"Waiting for wallet encryption password. Use `lncli \" +\n\t\t\"create` to create a wallet, `lncli unlock` to unlock an \" +\n\t\t\"existing wallet, or `lncli changepassword` to change the \" +\n\t\t\"password of an existing wallet and unlock it.\")\n\n\t// We currently don't distinguish between getting a password to be used\n\t// for creation or unlocking, as a new wallet db will be created if\n\t// none exists when creating the chain control.\n\tselect {\n\t// The wallet is being created for the first time, we'll check to see\n\t// if the user provided any entropy for seed creation. If so, then\n\t// we'll create the wallet early to load the seed.\n\tcase initMsg := <-pwService.InitMsgs:\n\t\tpassword := initMsg.Passphrase\n\t\tcipherSeed := initMsg.WalletSeed\n\t\textendedKey := initMsg.WalletExtendedKey\n\t\twatchOnlyAccounts := initMsg.WatchOnlyAccounts\n\t\trecoveryWindow := initMsg.RecoveryWindow\n\n\t\t// Before we proceed, we'll check the internal version of the\n\t\t// seed. If it's greater than the current key derivation\n\t\t// version, then we'll return an error as we don't understand\n\t\t// this.\n\t\tif cipherSeed != nil &&\n\t\t\t!keychain.IsKnownVersion(cipherSeed.InternalVersion) {\n\n\t\t\treturn nil, fmt.Errorf(\"invalid internal \"+\n\t\t\t\t\"seed version %v, current max version is %v\",\n\t\t\t\tcipherSeed.InternalVersion,\n\t\t\t\tkeychain.CurrentKeyDerivationVersion)\n\t\t}\n\n\t\tloader, err := btcwallet.NewWalletLoader(\n\t\t\tcfg.ActiveNetParams.Params, recoveryWindow,\n\t\t\tloaderOpts...,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// With the seed, we can now use the wallet loader to create\n\t\t// the wallet, then pass it back to avoid unlocking it again.\n\t\tvar (\n\t\t\tbirthday  time.Time\n\t\t\tnewWallet *wallet.Wallet\n\t\t)\n\t\tswitch {\n\t\t// A normal cipher seed was given, use the birthday encoded in\n\t\t// it and create the wallet from that.\n\t\tcase cipherSeed != nil:\n\t\t\tbirthday = cipherSeed.BirthdayTime()\n\t\t\tnewWallet, err = loader.CreateNewWallet(\n\t\t\t\tpassword, password, cipherSeed.Entropy[:],\n\t\t\t\tbirthday,\n\t\t\t)\n\n\t\t// No seed was given, we're importing a wallet from its extended\n\t\t// private key.\n\t\tcase extendedKey != nil:\n\t\t\tbirthday = initMsg.ExtendedKeyBirthday\n\t\t\tnewWallet, err = loader.CreateNewWalletExtendedKey(\n\t\t\t\tpassword, password, extendedKey, birthday,\n\t\t\t)\n\n\t\t// Neither seed nor extended private key was given, so maybe the\n\t\t// third option was chosen, the watch-only initialization. In\n\t\t// this case we need to import each of the xpubs individually.\n\t\tcase watchOnlyAccounts != nil:\n\t\t\tif !cfg.RemoteSigner.Enable {\n\t\t\t\treturn nil, fmt.Errorf(\"cannot initialize \" +\n\t\t\t\t\t\"watch only wallet with remote \" +\n\t\t\t\t\t\"signer config disabled\")\n\t\t\t}\n\n\t\t\tbirthday = initMsg.WatchOnlyBirthday\n\t\t\tnewWallet, err = loader.CreateNewWatchingOnlyWallet(\n\t\t\t\tpassword, birthday,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\terr = importWatchOnlyAccounts(newWallet, initMsg)\n\n\t\tdefault:\n\t\t\t// The unlocker service made sure either the cipher seed\n\t\t\t// or the extended key is set so, we shouldn't get here.\n\t\t\t// The default case is just here for readability and\n\t\t\t// completeness.\n\t\t\terr = fmt.Errorf(\"cannot create wallet, neither seed \" +\n\t\t\t\t\"nor extended key was given\")\n\t\t}\n\t\tif err != nil {\n\t\t\t// Don't leave the file open in case the new wallet\n\t\t\t// could not be created for whatever reason.\n\t\t\tif err := loader.UnloadWallet(); err != nil {\n\t\t\t\tltndLog.Errorf(\"Could not unload new \"+\n\t\t\t\t\t\"wallet: %v\", err)\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// For new wallets, the ResetWalletTransactions flag is a no-op.\n\t\tif cfg.ResetWalletTransactions {\n\t\t\tltndLog.Warnf(\"Ignoring reset-wallet-transactions \" +\n\t\t\t\t\"flag for new wallet as it has no effect\")\n\t\t}\n\n\t\treturn &walletunlocker.WalletUnlockParams{\n\t\t\tPassword:        password,\n\t\t\tBirthday:        birthday,\n\t\t\tRecoveryWindow:  recoveryWindow,\n\t\t\tWallet:          newWallet,\n\t\t\tChansToRestore:  initMsg.ChanBackups,\n\t\t\tUnloadWallet:    loader.UnloadWallet,\n\t\t\tStatelessInit:   initMsg.StatelessInit,\n\t\t\tMacResponseChan: pwService.MacResponseChan,\n\t\t\tMacRootKey:      initMsg.MacRootKey,\n\t\t}, nil\n\n\t// The wallet has already been created in the past, and is simply being\n\t// unlocked. So we'll just return these passphrases.\n\tcase unlockMsg := <-pwService.UnlockMsgs:\n\t\t// Resetting the transactions is something the user likely only\n\t\t// wants to do once so we add a prominent warning to the log to\n\t\t// remind the user to turn off the setting again after\n\t\t// successful completion.\n\t\tif cfg.ResetWalletTransactions {\n\t\t\tltndLog.Warnf(\"Dropped all transaction history from \" +\n\t\t\t\t\"on-chain wallet. Remember to disable \" +\n\t\t\t\t\"reset-wallet-transactions flag for next \" +\n\t\t\t\t\"start of lnd\")\n\t\t}\n\n\t\treturn &walletunlocker.WalletUnlockParams{\n\t\t\tPassword:        unlockMsg.Passphrase,\n\t\t\tRecoveryWindow:  unlockMsg.RecoveryWindow,\n\t\t\tWallet:          unlockMsg.Wallet,\n\t\t\tChansToRestore:  unlockMsg.ChanBackups,\n\t\t\tUnloadWallet:    unlockMsg.UnloadWallet,\n\t\t\tStatelessInit:   unlockMsg.StatelessInit,\n\t\t\tMacResponseChan: pwService.MacResponseChan,\n\t\t}, nil\n\n\t// If we got a shutdown signal we just return with an error immediately\n\tcase <-shutdownChan:\n\t\treturn nil, fmt.Errorf(\"shutting down\")\n\t}\n}\n\n// importWatchOnlyAccounts imports all individual account xpubs into our wallet\n// which we created as watch-only.",
      "length": 5291,
      "tokens": 695,
      "embedding": []
    },
    {
      "slug": "func importWatchOnlyAccounts(wallet *wallet.Wallet,",
      "content": "func importWatchOnlyAccounts(wallet *wallet.Wallet,\n\tinitMsg *walletunlocker.WalletInitMsg) error {\n\n\tscopes := make([]waddrmgr.ScopedIndex, 0, len(initMsg.WatchOnlyAccounts))\n\tfor scope := range initMsg.WatchOnlyAccounts {\n\t\tscopes = append(scopes, scope)\n\t}\n\n\t// We need to import the accounts in the correct order, otherwise the\n\t// indices will be incorrect.\n\tsort.Slice(scopes, func(i, j int) bool {\n\t\treturn scopes[i].Scope.Purpose < scopes[j].Scope.Purpose ||\n\t\t\tscopes[i].Index < scopes[j].Index\n\t})\n\n\tfor _, scope := range scopes {\n\t\taddrSchema := waddrmgr.ScopeAddrMap[waddrmgr.KeyScopeBIP0084]\n\n\t\t// We want witness pubkey hash by default, except for BIP49\n\t\t// where we want mixed and BIP86 where we want taproot address\n\t\t// formats.\n\t\tswitch scope.Scope.Purpose {\n\t\tcase waddrmgr.KeyScopeBIP0049Plus.Purpose,\n\t\t\twaddrmgr.KeyScopeBIP0086.Purpose:\n\n\t\t\taddrSchema = waddrmgr.ScopeAddrMap[scope.Scope]\n\t\t}\n\n\t\t// We want a human-readable account name. But for the default\n\t\t// on-chain wallet we actually need to call it \"default\" to make\n\t\t// sure everything works correctly.\n\t\tname := fmt.Sprintf(\"%s/%d'\", scope.Scope.String(), scope.Index)\n\t\tif scope.Index == 0 {\n\t\t\tname = \"default\"\n\t\t}\n\n\t\t_, err := wallet.ImportAccountWithScope(\n\t\t\tname, initMsg.WatchOnlyAccounts[scope],\n\t\t\tinitMsg.WatchOnlyMasterFingerprint, scope.Scope,\n\t\t\taddrSchema,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"could not import account %v: %v\",\n\t\t\t\tname, err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// initNeutrinoBackend inits a new instance of the neutrino light client\n// backend given a target chain directory to store the chain state.",
      "length": 1509,
      "tokens": 192,
      "embedding": []
    },
    {
      "slug": "func initNeutrinoBackend(ctx context.Context, cfg *Config, chainDir string,",
      "content": "func initNeutrinoBackend(ctx context.Context, cfg *Config, chainDir string,\n\tblockCache *blockcache.BlockCache) (*neutrino.ChainService,\n\tfunc(), error) {\n\n\t// Both channel validation flags are false by default but their meaning\n\t// is the inverse of each other. Therefore both cannot be true. For\n\t// every other case, the neutrino.validatechannels overwrites the\n\t// routing.assumechanvalid value.\n\tif cfg.NeutrinoMode.ValidateChannels && cfg.Routing.AssumeChannelValid {\n\t\treturn nil, nil, fmt.Errorf(\"can't set both \" +\n\t\t\t\"neutrino.validatechannels and routing.\" +\n\t\t\t\"assumechanvalid to true at the same time\")\n\t}\n\tcfg.Routing.AssumeChannelValid = !cfg.NeutrinoMode.ValidateChannels\n\n\t// First we'll open the database file for neutrino, creating the\n\t// database if needed. We append the normalized network name here to\n\t// match the behavior of btcwallet.\n\tdbPath := filepath.Join(\n\t\tchainDir, lncfg.NormalizeNetwork(cfg.ActiveNetParams.Name),\n\t)\n\n\t// Ensure that the neutrino db path exists.\n\tif err := os.MkdirAll(dbPath, 0700); err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar (\n\t\tdb  walletdb.DB\n\t\terr error\n\t)\n\tswitch {\n\tcase cfg.DB.Backend == kvdb.SqliteBackendName:\n\t\tdb, err = kvdb.Open(\n\t\t\tkvdb.SqliteBackendName, ctx, cfg.DB.Sqlite, dbPath,\n\t\t\tlncfg.SqliteNeutrinoDBName, lncfg.NSNeutrinoDB,\n\t\t)\n\n\tdefault:\n\t\tdbName := filepath.Join(dbPath, \"neutrino.db\")\n\t\tdb, err = walletdb.Create(\n\t\t\t\"bdb\", dbName, !cfg.SyncFreelist, cfg.DB.Bolt.DBTimeout,\n\t\t)\n\t}\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"unable to create \"+\n\t\t\t\"neutrino database: %v\", err)\n\t}\n\n\theaderStateAssertion, err := parseHeaderStateAssertion(\n\t\tcfg.NeutrinoMode.AssertFilterHeader,\n\t)\n\tif err != nil {\n\t\tdb.Close()\n\t\treturn nil, nil, err\n\t}\n\n\t// With the database open, we can now create an instance of the\n\t// neutrino light client. We pass in relevant configuration parameters\n\t// required.\n\tconfig := neutrino.Config{\n\t\tDataDir:      dbPath,\n\t\tDatabase:     db,\n\t\tChainParams:  *cfg.ActiveNetParams.Params,\n\t\tAddPeers:     cfg.NeutrinoMode.AddPeers,\n\t\tConnectPeers: cfg.NeutrinoMode.ConnectPeers,\n\t\tDialer: func(addr net.Addr) (net.Conn, error) {\n\t\t\treturn cfg.net.Dial(\n\t\t\t\taddr.Network(), addr.String(),\n\t\t\t\tcfg.ConnectionTimeout,\n\t\t\t)\n\t\t},\n\t\tNameResolver: func(host string) ([]net.IP, error) {\n\t\t\taddrs, err := cfg.net.LookupHost(host)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tips := make([]net.IP, 0, len(addrs))\n\t\t\tfor _, strIP := range addrs {\n\t\t\t\tip := net.ParseIP(strIP)\n\t\t\t\tif ip == nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tips = append(ips, ip)\n\t\t\t}\n\n\t\t\treturn ips, nil\n\t\t},\n\t\tAssertFilterHeader: headerStateAssertion,\n\t\tBlockCache:         blockCache.Cache,\n\t\tBroadcastTimeout:   cfg.NeutrinoMode.BroadcastTimeout,\n\t\tPersistToDisk:      cfg.NeutrinoMode.PersistFilters,\n\t}\n\n\tneutrino.MaxPeers = 8\n\tneutrino.BanDuration = time.Hour * 48\n\tneutrino.UserAgentName = cfg.NeutrinoMode.UserAgentName\n\tneutrino.UserAgentVersion = cfg.NeutrinoMode.UserAgentVersion\n\n\tneutrinoCS, err := neutrino.NewChainService(config)\n\tif err != nil {\n\t\tdb.Close()\n\t\treturn nil, nil, fmt.Errorf(\"unable to create neutrino light \"+\n\t\t\t\"client: %v\", err)\n\t}\n\n\tif err := neutrinoCS.Start(); err != nil {\n\t\tdb.Close()\n\t\treturn nil, nil, err\n\t}\n\n\tcleanUp := func() {\n\t\tif err := neutrinoCS.Stop(); err != nil {\n\t\t\tltndLog.Infof(\"Unable to stop neutrino light client: \"+\n\t\t\t\t\"%v\", err)\n\t\t}\n\t\tdb.Close()\n\t}\n\n\treturn neutrinoCS, cleanUp, nil\n}\n\n// parseHeaderStateAssertion parses the user-specified neutrino header state\n// into a headerfs.FilterHeader.",
      "length": 3316,
      "tokens": 402,
      "embedding": []
    },
    {
      "slug": "func parseHeaderStateAssertion(state string) (*headerfs.FilterHeader, error) {",
      "content": "func parseHeaderStateAssertion(state string) (*headerfs.FilterHeader, error) {\n\tif len(state) == 0 {\n\t\treturn nil, nil\n\t}\n\n\tsplit := strings.Split(state, \":\")\n\tif len(split) != 2 {\n\t\treturn nil, fmt.Errorf(\"header state assertion %v in \"+\n\t\t\t\"unexpected format, expected format height:hash\", state)\n\t}\n\n\theight, err := strconv.ParseUint(split[0], 10, 32)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"invalid filter header height: %v\", err)\n\t}\n\n\thash, err := chainhash.NewHashFromStr(split[1])\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"invalid filter header hash: %v\", err)\n\t}\n\n\treturn &headerfs.FilterHeader{\n\t\tHeight:     uint32(height),\n\t\tFilterHash: *hash,\n\t}, nil\n}\n",
      "length": 565,
      "tokens": 80,
      "embedding": []
    }
  ]
}