{
  "filepath": "../implementations/go/lnd/chanfitness/chaneventstore_test.go",
  "package": "chanfitness",
  "sections": [
    {
      "slug": "func TestStartStoreError(t *testing.T) {",
      "content": "func TestStartStoreError(t *testing.T) {\n\t// Ok and erroring subscribe functions are defined here to de-clutter\n\t// tests.\n\tokSubscribeFunc := func() (subscribe.Subscription, error) {\n\t\treturn newMockSubscription(t), nil\n\t}\n\n\terrSubscribeFunc := func() (subscribe.Subscription, error) {\n\t\treturn nil, errors.New(\"intentional test err\")\n\t}\n\n\ttests := []struct {\n\t\tname          string\n\t\tChannelEvents func() (subscribe.Subscription, error)\n\t\tPeerEvents    func() (subscribe.Subscription, error)\n\t\tGetChannels   func() ([]*channeldb.OpenChannel, error)\n\t}{\n\t\t{\n\t\t\tname:          \"Channel events fail\",\n\t\t\tChannelEvents: errSubscribeFunc,\n\t\t},\n\t\t{\n\t\t\tname:          \"Peer events fail\",\n\t\t\tChannelEvents: okSubscribeFunc,\n\t\t\tPeerEvents:    errSubscribeFunc,\n\t\t},\n\t\t{\n\t\t\tname:          \"Get open channels fails\",\n\t\t\tChannelEvents: okSubscribeFunc,\n\t\t\tPeerEvents:    okSubscribeFunc,\n\t\t\tGetChannels: func() ([]*channeldb.OpenChannel, error) {\n\t\t\t\treturn nil, errors.New(\"intentional test err\")\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tclock := clock.NewTestClock(testNow)\n\n\t\t\tstore := NewChannelEventStore(&Config{\n\t\t\t\tSubscribeChannelEvents: test.ChannelEvents,\n\t\t\t\tSubscribePeerEvents:    test.PeerEvents,\n\t\t\t\tGetOpenChannels:        test.GetChannels,\n\t\t\t\tClock:                  clock,\n\t\t\t})\n\n\t\t\terr := store.Start()\n\t\t\t// Check that we receive an error, because the test only\n\t\t\t// checks for error cases.\n\t\t\tif err == nil {\n\t\t\t\tt.Fatalf(\"Expected error on startup, got: nil\")\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestMonitorChannelEvents tests the store's handling of channel and peer\n// events. It tests for the unexpected cases where we receive a channel open for\n// an already known channel and but does not test for closing an unknown channel\n// because it would require custom logic in the test to prevent iterating\n// through an eventLog which does not exist. This test does not test handling\n// of uptime and lifespan requests, as they are tested in their own tests.",
      "length": 1913,
      "tokens": 239,
      "embedding": []
    },
    {
      "slug": "func TestMonitorChannelEvents(t *testing.T) {",
      "content": "func TestMonitorChannelEvents(t *testing.T) {\n\tvar (\n\t\tpubKey = btcec.NewPublicKey(\n\t\t\tnew(btcec.FieldVal).SetInt(0),\n\t\t\tnew(btcec.FieldVal).SetInt(1),\n\t\t)\n\n\t\tchan1 = wire.OutPoint{Index: 1}\n\t\tchan2 = wire.OutPoint{Index: 2}\n\t)\n\n\tpeer1, err := route.NewVertexFromBytes(pubKey.SerializeCompressed())\n\trequire.NoError(t, err)\n\n\tt.Run(\"peer comes online after channel open\", func(t *testing.T) {\n\t\tgen := func(ctx *chanEventStoreTestCtx) {\n\t\t\tctx.sendChannelOpenedUpdate(pubKey, chan1)\n\t\t\tctx.peerEvent(peer1, true)\n\t\t}\n\n\t\ttestEventStore(t, gen, peer1, 1)\n\t})\n\n\tt.Run(\"duplicate channel open events\", func(t *testing.T) {\n\t\tgen := func(ctx *chanEventStoreTestCtx) {\n\t\t\tctx.sendChannelOpenedUpdate(pubKey, chan1)\n\t\t\tctx.sendChannelOpenedUpdate(pubKey, chan1)\n\t\t\tctx.peerEvent(peer1, true)\n\t\t}\n\n\t\ttestEventStore(t, gen, peer1, 1)\n\t})\n\n\tt.Run(\"peer online before channel created\", func(t *testing.T) {\n\t\tgen := func(ctx *chanEventStoreTestCtx) {\n\t\t\tctx.peerEvent(peer1, true)\n\t\t\tctx.sendChannelOpenedUpdate(pubKey, chan1)\n\t\t}\n\n\t\ttestEventStore(t, gen, peer1, 1)\n\t})\n\n\tt.Run(\"multiple channels for peer\", func(t *testing.T) {\n\t\tgen := func(ctx *chanEventStoreTestCtx) {\n\t\t\tctx.peerEvent(peer1, true)\n\t\t\tctx.sendChannelOpenedUpdate(pubKey, chan1)\n\n\t\t\tctx.peerEvent(peer1, false)\n\t\t\tctx.sendChannelOpenedUpdate(pubKey, chan2)\n\t\t}\n\n\t\ttestEventStore(t, gen, peer1, 2)\n\t})\n\n\tt.Run(\"multiple channels for peer, one closed\", func(t *testing.T) {\n\t\tgen := func(ctx *chanEventStoreTestCtx) {\n\t\t\tctx.peerEvent(peer1, true)\n\t\t\tctx.sendChannelOpenedUpdate(pubKey, chan1)\n\n\t\t\tctx.peerEvent(peer1, false)\n\t\t\tctx.sendChannelOpenedUpdate(pubKey, chan2)\n\n\t\t\tctx.closeChannel(chan1, pubKey)\n\t\t\tctx.peerEvent(peer1, true)\n\t\t}\n\n\t\ttestEventStore(t, gen, peer1, 1)\n\t})\n}\n\n// testEventStore creates a new test contexts, generates a set of events for it\n// and tests that it has the number of channels we expect.",
      "length": 1765,
      "tokens": 179,
      "embedding": []
    },
    {
      "slug": "func testEventStore(t *testing.T, generateEvents func(*chanEventStoreTestCtx),",
      "content": "func testEventStore(t *testing.T, generateEvents func(*chanEventStoreTestCtx),\n\tpeer route.Vertex, expectedChannels int) {\n\n\ttestCtx := newChanEventStoreTestCtx(t)\n\ttestCtx.start()\n\n\tgenerateEvents(testCtx)\n\n\t// Shutdown the store so that we can safely access the maps in our event\n\t// store.\n\ttestCtx.stop()\n\n\t// Get our peer and check that it has the channels we expect.\n\tmonitor, ok := testCtx.store.peers[peer]\n\trequire.True(t, ok)\n\n\trequire.Equal(t, expectedChannels, monitor.channelCount())\n}\n\n// TestStoreFlapCount tests flushing of flap counts to disk on timer ticks and\n// on store shutdown.",
      "length": 502,
      "tokens": 68,
      "embedding": []
    },
    {
      "slug": "func TestStoreFlapCount(t *testing.T) {",
      "content": "func TestStoreFlapCount(t *testing.T) {\n\ttestCtx := newChanEventStoreTestCtx(t)\n\ttestCtx.start()\n\n\tpubkey, _, _ := testCtx.createChannel()\n\ttestCtx.peerEvent(pubkey, false)\n\n\t// Now, we tick our flap count ticker. We expect our main goroutine to\n\t// flush our tick count to disk.\n\ttestCtx.tickFlapCount()\n\n\t// Since we just tracked a offline event, we expect a single flap for\n\t// our peer.\n\texpectedUpdate := peerFlapCountMap{\n\t\tpubkey: {\n\t\t\tCount:    1,\n\t\t\tLastFlap: testCtx.clock.Now(),\n\t\t},\n\t}\n\n\ttestCtx.assertFlapCountUpdated()\n\ttestCtx.assertFlapCountUpdates(expectedUpdate)\n\n\t// Create three events for out peer, online/offline/online.\n\ttestCtx.peerEvent(pubkey, true)\n\ttestCtx.peerEvent(pubkey, false)\n\ttestCtx.peerEvent(pubkey, true)\n\n\t// Trigger another write.\n\ttestCtx.tickFlapCount()\n\n\t// Since we have processed 3 more events for our peer, we update our\n\t// expected online map to have a flap count of 4 for this peer.\n\texpectedUpdate[pubkey] = &channeldb.FlapCount{\n\t\tCount:    4,\n\t\tLastFlap: testCtx.clock.Now(),\n\t}\n\ttestCtx.assertFlapCountUpdated()\n\ttestCtx.assertFlapCountUpdates(expectedUpdate)\n\n\ttestCtx.stop()\n}\n\n// TestGetChanInfo tests the GetChanInfo function for the cases where a channel\n// is known and unknown to the store.",
      "length": 1167,
      "tokens": 142,
      "embedding": []
    },
    {
      "slug": "func TestGetChanInfo(t *testing.T) {",
      "content": "func TestGetChanInfo(t *testing.T) {\n\tctx := newChanEventStoreTestCtx(t)\n\tctx.start()\n\n\t// Make a note of the time that our mocked clock starts on.\n\tnow := ctx.clock.Now()\n\n\t// Create mock vars for a channel but do not add them to our store yet.\n\tpeer, pk, channel := ctx.newChannel()\n\n\t// Send an online event for our peer, although we do not yet have an\n\t// open channel.\n\tctx.peerEvent(peer, true)\n\n\t// Try to get info for a channel that has not been opened yet, we\n\t// expect to get an error.\n\t_, err := ctx.store.GetChanInfo(channel, peer)\n\trequire.Equal(t, ErrChannelNotFound, err)\n\n\t// Now we send our store a notification that a channel has been opened.\n\tctx.sendChannelOpenedUpdate(pk, channel)\n\n\t// Wait for our channel to be recognized by our store. We need to wait\n\t// for the channel to be created so that we do not update our time\n\t// before the channel open is processed.\n\trequire.Eventually(t, func() bool {\n\t\t_, err = ctx.store.GetChanInfo(channel, peer)\n\t\treturn err == nil\n\t}, timeout, time.Millisecond*20)\n\n\t// Increment our test clock by an hour.\n\tnow = now.Add(time.Hour)\n\tctx.clock.SetTime(now)\n\n\t// At this stage our channel has been open and online for an hour.\n\tinfo, err := ctx.store.GetChanInfo(channel, peer)\n\trequire.NoError(t, err)\n\trequire.Equal(t, time.Hour, info.Lifetime)\n\trequire.Equal(t, time.Hour, info.Uptime)\n\n\t// Now we send a peer offline event for our channel.\n\tctx.peerEvent(peer, false)\n\n\t// Since we have not bumped our mocked time, our uptime calculations\n\t// should be the same, even though we've just processed an offline\n\t// event.\n\tinfo, err = ctx.store.GetChanInfo(channel, peer)\n\trequire.NoError(t, err)\n\trequire.Equal(t, time.Hour, info.Lifetime)\n\trequire.Equal(t, time.Hour, info.Uptime)\n\n\t// Progress our time again. This time, our peer is currently tracked as\n\t// being offline, so we expect our channel info to reflect that the peer\n\t// has been offline for this period.\n\tnow = now.Add(time.Hour)\n\tctx.clock.SetTime(now)\n\n\tinfo, err = ctx.store.GetChanInfo(channel, peer)\n\trequire.NoError(t, err)\n\trequire.Equal(t, time.Hour*2, info.Lifetime)\n\trequire.Equal(t, time.Hour, info.Uptime)\n\n\tctx.stop()\n}\n\n// TestFlapCount tests querying the store for peer flap counts, covering the\n// case where the peer is tracked in memory, and the case where we need to\n// lookup the peer on disk.",
      "length": 2235,
      "tokens": 337,
      "embedding": []
    },
    {
      "slug": "func TestFlapCount(t *testing.T) {",
      "content": "func TestFlapCount(t *testing.T) {\n\tclock := clock.NewTestClock(testNow)\n\n\tvar (\n\t\tpeer          = route.Vertex{9, 9, 9}\n\t\tpeerFlapCount = 3\n\t\tlastFlap      = clock.Now()\n\t)\n\n\t// Create a test context with one peer's flap count already recorded,\n\t// which mocks it already having its flap count stored on disk.\n\tctx := newChanEventStoreTestCtx(t)\n\tctx.flapUpdates[peer] = &channeldb.FlapCount{\n\t\tCount:    uint32(peerFlapCount),\n\t\tLastFlap: lastFlap,\n\t}\n\n\tctx.start()\n\n\t// Create test variables for a peer and channel, but do not add it to\n\t// our store yet.\n\tpeer1 := route.Vertex{1, 2, 3}\n\n\t// First, query for a peer that we have no record of in memory or on\n\t// disk and confirm that we indicate that the peer was not found.\n\t_, ts, err := ctx.store.FlapCount(peer1)\n\trequire.NoError(t, err)\n\trequire.Nil(t, ts)\n\n\t// Send an online event for our peer.\n\tctx.peerEvent(peer1, true)\n\n\t// Assert that we now find a record of the peer with flap count = 1.\n\tcount, ts, err := ctx.store.FlapCount(peer1)\n\trequire.NoError(t, err)\n\trequire.Equal(t, lastFlap, *ts)\n\trequire.Equal(t, 1, count)\n\n\t// Make a request for our peer that not tracked in memory, but does\n\t// have its flap count stored on disk.\n\tcount, ts, err = ctx.store.FlapCount(peer)\n\trequire.NoError(t, err)\n\trequire.Equal(t, lastFlap, *ts)\n\trequire.Equal(t, peerFlapCount, count)\n\n\tctx.stop()\n}\n",
      "length": 1273,
      "tokens": 191,
      "embedding": []
    }
  ]
}