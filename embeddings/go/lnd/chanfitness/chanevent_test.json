{
  "filepath": "../implementations/go/lnd/chanfitness/chanevent_test.go",
  "package": "chanfitness",
  "sections": [
    {
      "slug": "func TestPeerLog(t *testing.T) {",
      "content": "func TestPeerLog(t *testing.T) {\n\tclock := clock.NewTestClock(testNow)\n\tpeerLog := newPeerLog(clock, 0, nil)\n\n\t// assertFlapCount is a helper that asserts that our peer's flap count\n\t// and timestamp is set to expected values.\n\tassertFlapCount := func(expectedCount int, expectedTs *time.Time) {\n\t\tflapCount, flapTs := peerLog.getFlapCount()\n\t\trequire.Equal(t, expectedCount, flapCount)\n\t\trequire.Equal(t, expectedTs, flapTs)\n\t}\n\n\trequire.Zero(t, peerLog.channelCount())\n\trequire.False(t, peerLog.online)\n\tassertFlapCount(0, nil)\n\n\t// Test that looking up an unknown channel fails.\n\t_, _, err := peerLog.channelUptime(wire.OutPoint{Index: 1})\n\trequire.Error(t, err)\n\n\tlastFlap := clock.Now()\n\n\t// Add an offline event, since we have no channels, we do not expect\n\t// to have any online periods recorded for our peer. However, we should\n\t// increment our flap count for the peer.\n\tpeerLog.onlineEvent(false)\n\trequire.Len(t, peerLog.getOnlinePeriods(), 0)\n\tassertFlapCount(1, &lastFlap)\n\n\t// Bump our test clock's time by an hour so that we can create an online\n\t// event with a distinct time.\n\tlastFlap = testNow.Add(time.Hour)\n\tclock.SetTime(lastFlap)\n\n\t// Likewise, if we have an online event, nothing beyond the online state\n\t// of our peer log should change, but our flap count should change.\n\tpeerLog.onlineEvent(true)\n\trequire.Len(t, peerLog.getOnlinePeriods(), 0)\n\tassertFlapCount(2, &lastFlap)\n\n\t// Add a channel and assert that we have one channel listed. Since this\n\t// is the first channel we track for the peer, we expect an online\n\t// event to be added, however, our flap count should not change because\n\t// this is not a new online event, we are just copying one into our log\n\t// for our purposes.\n\tchan1 := wire.OutPoint{\n\t\tIndex: 1,\n\t}\n\trequire.NoError(t, peerLog.addChannel(chan1))\n\trequire.Equal(t, 1, peerLog.channelCount())\n\tassertFlapCount(2, &lastFlap)\n\n\t// Assert that we can now successfully get our added channel.\n\t_, _, err = peerLog.channelUptime(chan1)\n\trequire.NoError(t, err)\n\n\t// Bump our test clock's time so that our current time is different to\n\t// channel open time.\n\tlastFlap = clock.Now().Add(time.Hour)\n\tclock.SetTime(lastFlap)\n\n\t// Now that we have added a channel and an hour has passed, we expect\n\t// our uptime and lifetime to both equal an hour.\n\tlifetime, uptime, err := peerLog.channelUptime(chan1)\n\trequire.NoError(t, err)\n\trequire.Equal(t, time.Hour, lifetime)\n\trequire.Equal(t, time.Hour, uptime)\n\n\t// Add an offline event for our peer and assert that our flap count is\n\t// incremented.\n\tpeerLog.onlineEvent(false)\n\tassertFlapCount(3, &lastFlap)\n\n\t// Now we add another channel to our store and assert that we now report\n\t// two channels for this peer.\n\tchan2 := wire.OutPoint{\n\t\tIndex: 2,\n\t}\n\trequire.NoError(t, peerLog.addChannel(chan2))\n\trequire.Equal(t, 2, peerLog.channelCount())\n\n\t// Progress our time again, so that our peer has now been offline for\n\t// two hours.\n\tnow := lastFlap.Add(time.Hour * 2)\n\tclock.SetTime(now)\n\n\t// Our first channel should report as having been monitored for three\n\t// hours, but only online for one of those hours.\n\tlifetime, uptime, err = peerLog.channelUptime(chan1)\n\trequire.NoError(t, err)\n\trequire.Equal(t, time.Hour*3, lifetime)\n\trequire.Equal(t, time.Hour, uptime)\n\n\t// Remove our first channel and check that we can still correctly query\n\t// uptime for the second channel.\n\trequire.NoError(t, peerLog.removeChannel(chan1))\n\trequire.Equal(t, 1, peerLog.channelCount())\n\n\t// Our second channel, which was created when our peer was offline,\n\t// should report as having been monitored for two hours, but have zero\n\t// uptime.\n\tlifetime, uptime, err = peerLog.channelUptime(chan2)\n\trequire.NoError(t, err)\n\trequire.Equal(t, time.Hour*2, lifetime)\n\trequire.Equal(t, time.Duration(0), uptime)\n\n\t// Finally, remove our second channel and assert that our peer cleans\n\t// up its in memory set of events but keeps its flap count record.\n\trequire.NoError(t, peerLog.removeChannel(chan2))\n\trequire.Equal(t, 0, peerLog.channelCount())\n\trequire.Len(t, peerLog.onlineEvents, 0)\n\tassertFlapCount(3, &lastFlap)\n\n\trequire.Len(t, peerLog.listEvents(), 0)\n\trequire.Nil(t, peerLog.stagedEvent)\n}\n\n// TestRateLimitAdd tests the addition of events to the event log with rate\n// limiting in place.",
      "length": 4113,
      "tokens": 556,
      "embedding": []
    },
    {
      "slug": "func TestRateLimitAdd(t *testing.T) {",
      "content": "func TestRateLimitAdd(t *testing.T) {\n\t// Create a mock clock specifically for this test so that we can\n\t// progress time without affecting the other tests.\n\tmockedClock := clock.NewTestClock(testNow)\n\n\t// Create a new peer log.\n\tpeerLog := newPeerLog(mockedClock, 0, nil)\n\trequire.Nil(t, peerLog.stagedEvent)\n\n\t// Create a channel for our peer log, otherwise it will not track online\n\t// events.\n\trequire.NoError(t, peerLog.addChannel(wire.OutPoint{}))\n\n\t// First, we add an event to the event log. Since we have no previous\n\t// events, we expect this event to staged immediately.\n\tpeerEvent := &event{\n\t\ttimestamp: testNow,\n\t\teventType: peerOfflineEvent,\n\t}\n\n\tpeerLog.onlineEvent(false)\n\trequire.Equal(t, peerEvent, peerLog.stagedEvent)\n\n\t// We immediately add another event to our event log. We expect our\n\t// staged event to be replaced with this new event, because insufficient\n\t// time has passed since our last event.\n\tpeerEvent = &event{\n\t\ttimestamp: testNow,\n\t\teventType: peerOnlineEvent,\n\t}\n\n\tpeerLog.onlineEvent(true)\n\trequire.Equal(t, peerEvent, peerLog.stagedEvent)\n\n\t// We get the amount of time that we need to pass before we record an\n\t// event from our rate limiting tiers. We then progress our test clock\n\t// to just after this point.\n\tdelta := getRateLimit(peerLog.flapCount)\n\tnewNow := testNow.Add(delta + 1)\n\tmockedClock.SetTime(newNow)\n\n\t// Now, when we add an event, we expect our staged event to be added\n\t// to our events list and for our new event to be staged.\n\tnewEvent := &event{\n\t\ttimestamp: newNow,\n\t\teventType: peerOfflineEvent,\n\t}\n\tpeerLog.onlineEvent(false)\n\n\trequire.Equal(t, []*event{peerEvent}, peerLog.onlineEvents)\n\trequire.Equal(t, newEvent, peerLog.stagedEvent)\n\n\t// Now, we test the case where we add many events to our log. We expect\n\t// our set of events to be untouched, but for our staged event to be\n\t// updated.\n\tnextEvent := &event{\n\t\ttimestamp: newNow,\n\t\teventType: peerOnlineEvent,\n\t}\n\n\tfor i := 0; i < 5; i++ {\n\t\t// We flip the kind of event for each type so that we can check\n\t\t// that our staged event is definitely changing each time.\n\t\tif i%2 == 0 {\n\t\t\tnextEvent.eventType = peerOfflineEvent\n\t\t} else {\n\t\t\tnextEvent.eventType = peerOnlineEvent\n\t\t}\n\n\t\tonline := nextEvent.eventType == peerOnlineEvent\n\n\t\tpeerLog.onlineEvent(online)\n\t\trequire.Equal(t, []*event{peerEvent}, peerLog.onlineEvents)\n\t\trequire.Equal(t, nextEvent, peerLog.stagedEvent)\n\t}\n\n\t// Now, we test the case where a peer's flap count is cooled down\n\t// because it has not flapped for a while. Set our peer's flap count so\n\t// that we fall within our second rate limiting tier and assert that we\n\t// are at this level.\n\tpeerLog.flapCount = rateLimitScale + 1\n\trateLimit := getRateLimit(peerLog.flapCount)\n\trequire.Equal(t, rateLimits[1], rateLimit)\n\n\t// Progress our clock to the point where we will have our flap count\n\t// cooled.\n\tnewNow = mockedClock.Now().Add(flapCountCooldownPeriod)\n\tmockedClock.SetTime(newNow)\n\n\t// Add an online event, and expect it to be staged.\n\tonlineEvent := &event{\n\t\ttimestamp: newNow,\n\t\teventType: peerOnlineEvent,\n\t}\n\tpeerLog.onlineEvent(true)\n\trequire.Equal(t, onlineEvent, peerLog.stagedEvent)\n\n\t// Progress our clock by the rate limit level that we will be on if\n\t// our flap rate is cooled down to a lower level.\n\tnewNow = mockedClock.Now().Add(rateLimits[0] + 1)\n\tmockedClock.SetTime(newNow)\n\n\t// Add another event. We expect this event to be staged and our previous\n\t// event to be flushed to the event log (because our cooldown has been\n\t// applied).\n\tofflineEvent := &event{\n\t\ttimestamp: newNow,\n\t\teventType: peerOfflineEvent,\n\t}\n\tpeerLog.onlineEvent(false)\n\trequire.Equal(t, offlineEvent, peerLog.stagedEvent)\n\n\tflushedEventIdx := len(peerLog.onlineEvents) - 1\n\trequire.Equal(\n\t\tt, onlineEvent, peerLog.onlineEvents[flushedEventIdx],\n\t)\n}\n\n// TestGetOnlinePeriod tests the getOnlinePeriod function. It tests the case\n// where no events present, and the case where an additional online period\n// must be added because the event log ends on an online event.",
      "length": 3861,
      "tokens": 549,
      "embedding": []
    },
    {
      "slug": "func TestGetOnlinePeriod(t *testing.T) {",
      "content": "func TestGetOnlinePeriod(t *testing.T) {\n\tfourHoursAgo := testNow.Add(time.Hour * -4)\n\tthreeHoursAgo := testNow.Add(time.Hour * -3)\n\ttwoHoursAgo := testNow.Add(time.Hour * -2)\n\n\ttests := []struct {\n\t\tname           string\n\t\tevents         []*event\n\t\texpectedOnline []*onlinePeriod\n\t}{\n\t\t{\n\t\t\tname: \"no events\",\n\t\t},\n\t\t{\n\t\t\tname: \"start on online period\",\n\t\t\tevents: []*event{\n\t\t\t\t{\n\t\t\t\t\ttimestamp: threeHoursAgo,\n\t\t\t\t\teventType: peerOnlineEvent,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttimestamp: twoHoursAgo,\n\t\t\t\t\teventType: peerOfflineEvent,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedOnline: []*onlinePeriod{\n\t\t\t\t{\n\t\t\t\t\tstart: threeHoursAgo,\n\t\t\t\t\tend:   twoHoursAgo,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"start on offline period\",\n\t\t\tevents: []*event{\n\t\t\t\t{\n\t\t\t\t\ttimestamp: fourHoursAgo,\n\t\t\t\t\teventType: peerOfflineEvent,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"end on an online period\",\n\t\t\tevents: []*event{\n\t\t\t\t{\n\t\t\t\t\ttimestamp: fourHoursAgo,\n\t\t\t\t\teventType: peerOnlineEvent,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedOnline: []*onlinePeriod{\n\t\t\t\t{\n\t\t\t\t\tstart: fourHoursAgo,\n\t\t\t\t\tend:   testNow,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"duplicate online events\",\n\t\t\tevents: []*event{\n\t\t\t\t{\n\t\t\t\t\ttimestamp: fourHoursAgo,\n\t\t\t\t\teventType: peerOnlineEvent,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttimestamp: threeHoursAgo,\n\t\t\t\t\teventType: peerOnlineEvent,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedOnline: []*onlinePeriod{\n\t\t\t\t{\n\t\t\t\t\tstart: fourHoursAgo,\n\t\t\t\t\tend:   testNow,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"duplicate offline events\",\n\t\t\tevents: []*event{\n\t\t\t\t{\n\t\t\t\t\ttimestamp: fourHoursAgo,\n\t\t\t\t\teventType: peerOfflineEvent,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttimestamp: threeHoursAgo,\n\t\t\t\t\teventType: peerOfflineEvent,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedOnline: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"duplicate online then offline\",\n\t\t\tevents: []*event{\n\t\t\t\t{\n\t\t\t\t\ttimestamp: fourHoursAgo,\n\t\t\t\t\teventType: peerOnlineEvent,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttimestamp: threeHoursAgo,\n\t\t\t\t\teventType: peerOnlineEvent,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttimestamp: twoHoursAgo,\n\t\t\t\t\teventType: peerOfflineEvent,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedOnline: []*onlinePeriod{\n\t\t\t\t{\n\t\t\t\t\tstart: fourHoursAgo,\n\t\t\t\t\tend:   twoHoursAgo,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"duplicate offline then online\",\n\t\t\tevents: []*event{\n\t\t\t\t{\n\t\t\t\t\ttimestamp: fourHoursAgo,\n\t\t\t\t\teventType: peerOfflineEvent,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttimestamp: threeHoursAgo,\n\t\t\t\t\teventType: peerOfflineEvent,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttimestamp: twoHoursAgo,\n\t\t\t\t\teventType: peerOnlineEvent,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedOnline: []*onlinePeriod{\n\t\t\t\t{\n\t\t\t\t\tstart: twoHoursAgo,\n\t\t\t\t\tend:   testNow,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tscore := &peerLog{\n\t\t\t\tonlineEvents: test.events,\n\t\t\t\tclock:        clock.NewTestClock(testNow),\n\t\t\t}\n\n\t\t\tonline := score.getOnlinePeriods()\n\n\t\t\trequire.Equal(t, test.expectedOnline, online)\n\t\t})\n\t}\n}\n\n// TestUptime tests channel uptime calculation based on its event log.",
      "length": 2634,
      "tokens": 275,
      "embedding": []
    },
    {
      "slug": "func TestUptime(t *testing.T) {",
      "content": "func TestUptime(t *testing.T) {\n\tfourHoursAgo := testNow.Add(time.Hour * -4)\n\tthreeHoursAgo := testNow.Add(time.Hour * -3)\n\ttwoHoursAgo := testNow.Add(time.Hour * -2)\n\toneHourAgo := testNow.Add(time.Hour * -1)\n\n\ttests := []struct {\n\t\tname string\n\n\t\t// events is the set of event log that we are calculating uptime\n\t\t// for.\n\t\tevents []*event\n\n\t\t// startTime is the beginning of the period that we are\n\t\t// calculating uptime for, it cannot have a zero value.\n\t\tstartTime time.Time\n\n\t\t// endTime is the end of the period that we are calculating\n\t\t// uptime for, it cannot have a zero value.\n\t\tendTime time.Time\n\n\t\t// expectedUptime is the amount of uptime we expect to be\n\t\t// calculated over the period specified by startTime and\n\t\t// endTime.\n\t\texpectedUptime time.Duration\n\n\t\t// expectErr is set to true if we expect an error to be returned\n\t\t// when calling the uptime function.\n\t\texpectErr bool\n\t}{\n\t\t{\n\t\t\tname:      \"End before start\",\n\t\t\tendTime:   threeHoursAgo,\n\t\t\tstartTime: testNow,\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"Zero end time\",\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"online event and no offline\",\n\t\t\tevents: []*event{\n\t\t\t\t{\n\t\t\t\t\ttimestamp: fourHoursAgo,\n\t\t\t\t\teventType: peerOnlineEvent,\n\t\t\t\t},\n\t\t\t},\n\t\t\tstartTime:      fourHoursAgo,\n\t\t\tendTime:        testNow,\n\t\t\texpectedUptime: time.Hour * 4,\n\t\t},\n\t\t{\n\t\t\tname: \"online then offline event\",\n\t\t\tevents: []*event{\n\t\t\t\t{\n\t\t\t\t\ttimestamp: threeHoursAgo,\n\t\t\t\t\teventType: peerOnlineEvent,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttimestamp: twoHoursAgo,\n\t\t\t\t\teventType: peerOfflineEvent,\n\t\t\t\t},\n\t\t\t},\n\t\t\tstartTime:      fourHoursAgo,\n\t\t\tendTime:        testNow,\n\t\t\texpectedUptime: time.Hour,\n\t\t},\n\t\t{\n\t\t\tname: \"online event before uptime period\",\n\t\t\tevents: []*event{\n\t\t\t\t{\n\t\t\t\t\ttimestamp: threeHoursAgo,\n\t\t\t\t\teventType: peerOnlineEvent,\n\t\t\t\t},\n\t\t\t},\n\t\t\tstartTime:      twoHoursAgo,\n\t\t\tendTime:        testNow,\n\t\t\texpectedUptime: time.Hour * 2,\n\t\t},\n\t\t{\n\t\t\tname: \"offline event after uptime period\",\n\t\t\tevents: []*event{\n\t\t\t\t{\n\t\t\t\t\ttimestamp: fourHoursAgo,\n\t\t\t\t\teventType: peerOnlineEvent,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttimestamp: testNow.Add(time.Hour),\n\t\t\t\t\teventType: peerOfflineEvent,\n\t\t\t\t},\n\t\t\t},\n\t\t\tstartTime:      twoHoursAgo,\n\t\t\tendTime:        testNow,\n\t\t\texpectedUptime: time.Hour * 2,\n\t\t},\n\t\t{\n\t\t\tname: \"all events within period\",\n\t\t\tevents: []*event{\n\t\t\t\t{\n\t\t\t\t\ttimestamp: twoHoursAgo,\n\t\t\t\t\teventType: peerOnlineEvent,\n\t\t\t\t},\n\t\t\t},\n\t\t\tstartTime:      threeHoursAgo,\n\t\t\tendTime:        oneHourAgo,\n\t\t\texpectedUptime: time.Hour,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple online and offline\",\n\t\t\tevents: []*event{\n\t\t\t\t{\n\t\t\t\t\ttimestamp: testNow.Add(time.Hour * -7),\n\t\t\t\t\teventType: peerOnlineEvent,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttimestamp: testNow.Add(time.Hour * -6),\n\t\t\t\t\teventType: peerOfflineEvent,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttimestamp: testNow.Add(time.Hour * -5),\n\t\t\t\t\teventType: peerOnlineEvent,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttimestamp: testNow.Add(time.Hour * -4),\n\t\t\t\t\teventType: peerOfflineEvent,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttimestamp: testNow.Add(time.Hour * -3),\n\t\t\t\t\teventType: peerOnlineEvent,\n\t\t\t\t},\n\t\t\t},\n\t\t\tstartTime:      testNow.Add(time.Hour * -8),\n\t\t\tendTime:        oneHourAgo,\n\t\t\texpectedUptime: time.Hour * 4,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tscore := &peerLog{\n\t\t\t\tonlineEvents: test.events,\n\t\t\t\tclock:        clock.NewTestClock(testNow),\n\t\t\t}\n\n\t\t\tuptime, err := score.uptime(\n\t\t\t\ttest.startTime, test.endTime,\n\t\t\t)\n\t\t\trequire.Equal(t, test.expectErr, err != nil)\n\t\t\trequire.Equal(t, test.expectedUptime, uptime)\n\t\t})\n\t}\n}\n",
      "length": 3312,
      "tokens": 388,
      "embedding": []
    }
  ]
}