{
  "filepath": "../implementations/go/lnd/feature/manager.go",
  "package": "feature",
  "sections": [
    {
      "slug": "type Config struct {",
      "content": "type Config struct {\n\t// NoTLVOnion unsets any optional or required TLVOnionPaylod bits from\n\t// all feature sets.\n\tNoTLVOnion bool\n\n\t// NoStaticRemoteKey unsets any optional or required StaticRemoteKey\n\t// bits from all feature sets.\n\tNoStaticRemoteKey bool\n\n\t// NoAnchors unsets any bits signaling support for anchor outputs.\n\tNoAnchors bool\n\n\t// NoWumbo unsets any bits signalling support for wumbo channels.\n\tNoWumbo bool\n\n\t// NoScriptEnforcementLease unsets any bits signaling support for script\n\t// enforced leases.\n\tNoScriptEnforcementLease bool\n\n\t// NoKeysend unsets any bits signaling support for accepting keysend\n\t// payments.\n\tNoKeysend bool\n\n\t// NoOptionScidAlias unsets any bits signalling support for\n\t// option_scid_alias. This also implicitly disables zero-conf channels.\n\tNoOptionScidAlias bool\n\n\t// NoZeroConf unsets any bits signalling support for zero-conf\n\t// channels. This should be used instead of NoOptionScidAlias to still\n\t// keep option-scid-alias support.\n\tNoZeroConf bool\n\n\t// NoAnySegwit unsets any bits that signal support for using other\n\t// segwit witness versions for co-op closes.\n\tNoAnySegwit bool\n}\n\n// Manager is responsible for generating feature vectors for different requested\n// feature sets.",
      "length": 1178,
      "tokens": 163,
      "embedding": []
    },
    {
      "slug": "type Manager struct {",
      "content": "type Manager struct {\n\t// fsets is a static map of feature set to raw feature vectors. Requests\n\t// are fulfilled by cloning these internal feature vectors.\n\tfsets map[Set]*lnwire.RawFeatureVector\n}\n\n// NewManager creates a new feature Manager, applying any custom modifications\n// to its feature sets before returning.",
      "length": 291,
      "tokens": 44,
      "embedding": []
    },
    {
      "slug": "func NewManager(cfg Config) (*Manager, error) {",
      "content": "func NewManager(cfg Config) (*Manager, error) {\n\treturn newManager(cfg, defaultSetDesc)\n}\n\n// newManager creates a new feature Manager, applying any custom modifications\n// to its feature sets before returning. This method accepts the setDesc as its\n// own parameter so that it can be unit tested.",
      "length": 244,
      "tokens": 39,
      "embedding": []
    },
    {
      "slug": "func newManager(cfg Config, desc setDesc) (*Manager, error) {",
      "content": "func newManager(cfg Config, desc setDesc) (*Manager, error) {\n\t// First build the default feature vector for all known sets.\n\tfsets := make(map[Set]*lnwire.RawFeatureVector)\n\tfor bit, sets := range desc {\n\t\tfor set := range sets {\n\t\t\t// Fetch the feature vector for this set, allocating a\n\t\t\t// new one if it doesn't exist.\n\t\t\tfv, ok := fsets[set]\n\t\t\tif !ok {\n\t\t\t\tfv = lnwire.NewRawFeatureVector()\n\t\t\t}\n\n\t\t\t// Set the configured bit on the feature vector,\n\t\t\t// ensuring that we don't set two feature bits for the\n\t\t\t// same pair.\n\t\t\terr := fv.SafeSet(bit)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"unable to set \"+\n\t\t\t\t\t\"%v in %v: %v\", bit, set, err)\n\t\t\t}\n\n\t\t\t// Write the updated feature vector under its set.\n\t\t\tfsets[set] = fv\n\t\t}\n\t}\n\n\t// Now, remove any features as directed by the config.\n\tfor set, raw := range fsets {\n\t\tif cfg.NoTLVOnion {\n\t\t\traw.Unset(lnwire.TLVOnionPayloadOptional)\n\t\t\traw.Unset(lnwire.TLVOnionPayloadRequired)\n\t\t\traw.Unset(lnwire.PaymentAddrOptional)\n\t\t\traw.Unset(lnwire.PaymentAddrRequired)\n\t\t\traw.Unset(lnwire.MPPOptional)\n\t\t\traw.Unset(lnwire.MPPRequired)\n\t\t\traw.Unset(lnwire.AMPOptional)\n\t\t\traw.Unset(lnwire.AMPRequired)\n\t\t\traw.Unset(lnwire.KeysendOptional)\n\t\t\traw.Unset(lnwire.KeysendRequired)\n\t\t}\n\t\tif cfg.NoStaticRemoteKey {\n\t\t\traw.Unset(lnwire.StaticRemoteKeyOptional)\n\t\t\traw.Unset(lnwire.StaticRemoteKeyRequired)\n\t\t}\n\t\tif cfg.NoAnchors {\n\t\t\traw.Unset(lnwire.AnchorsZeroFeeHtlcTxOptional)\n\t\t\traw.Unset(lnwire.AnchorsZeroFeeHtlcTxRequired)\n\n\t\t\t// If anchors are disabled, then we also need to\n\t\t\t// disable all other features that depend on it as\n\t\t\t// well, as otherwise we may create an invalid feature\n\t\t\t// bit set.\n\t\t\tfor bit, depFeatures := range deps {\n\t\t\t\tfor depFeature := range depFeatures {\n\t\t\t\t\tswitch {\n\t\t\t\t\tcase depFeature == lnwire.AnchorsZeroFeeHtlcTxRequired:\n\t\t\t\t\t\tfallthrough\n\t\t\t\t\tcase depFeature == lnwire.AnchorsZeroFeeHtlcTxOptional:\n\t\t\t\t\t\traw.Unset(bit)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif cfg.NoWumbo {\n\t\t\traw.Unset(lnwire.WumboChannelsOptional)\n\t\t\traw.Unset(lnwire.WumboChannelsRequired)\n\t\t}\n\t\tif cfg.NoScriptEnforcementLease {\n\t\t\traw.Unset(lnwire.ScriptEnforcedLeaseOptional)\n\t\t\traw.Unset(lnwire.ScriptEnforcedLeaseRequired)\n\t\t}\n\t\tif cfg.NoKeysend {\n\t\t\traw.Unset(lnwire.KeysendOptional)\n\t\t\traw.Unset(lnwire.KeysendRequired)\n\t\t}\n\t\tif cfg.NoOptionScidAlias {\n\t\t\traw.Unset(lnwire.ScidAliasOptional)\n\t\t\traw.Unset(lnwire.ScidAliasRequired)\n\t\t}\n\t\tif cfg.NoZeroConf {\n\t\t\traw.Unset(lnwire.ZeroConfOptional)\n\t\t\traw.Unset(lnwire.ZeroConfRequired)\n\t\t}\n\t\tif cfg.NoAnySegwit {\n\t\t\traw.Unset(lnwire.ShutdownAnySegwitOptional)\n\t\t\traw.Unset(lnwire.ShutdownAnySegwitRequired)\n\t\t}\n\n\t\t// Ensure that all of our feature sets properly set any\n\t\t// dependent features.\n\t\tfv := lnwire.NewFeatureVector(raw, lnwire.Features)\n\t\terr := ValidateDeps(fv)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"invalid feature set %v: %v\",\n\t\t\t\tset, err)\n\t\t}\n\t}\n\n\treturn &Manager{\n\t\tfsets: fsets,\n\t}, nil\n}\n\n// GetRaw returns a raw feature vector for the passed set. If no set is known,\n// an empty raw feature vector is returned.",
      "length": 2880,
      "tokens": 322,
      "embedding": []
    },
    {
      "slug": "func (m *Manager) GetRaw(set Set) *lnwire.RawFeatureVector {",
      "content": "func (m *Manager) GetRaw(set Set) *lnwire.RawFeatureVector {\n\tif fv, ok := m.fsets[set]; ok {\n\t\treturn fv.Clone()\n\t}\n\n\treturn lnwire.NewRawFeatureVector()\n}\n\n// SetRaw sets a new raw feature vector for the given set.",
      "length": 148,
      "tokens": 25,
      "embedding": []
    },
    {
      "slug": "func (m *Manager) SetRaw(set Set, raw *lnwire.RawFeatureVector) {",
      "content": "func (m *Manager) SetRaw(set Set, raw *lnwire.RawFeatureVector) {\n\tm.fsets[set] = raw\n}\n\n// Get returns a feature vector for the passed set. If no set is known, an empty\n// feature vector is returned.",
      "length": 130,
      "tokens": 26,
      "embedding": []
    },
    {
      "slug": "func (m *Manager) Get(set Set) *lnwire.FeatureVector {",
      "content": "func (m *Manager) Get(set Set) *lnwire.FeatureVector {\n\traw := m.GetRaw(set)\n\treturn lnwire.NewFeatureVector(raw, lnwire.Features)\n}\n\n// ListSets returns a list of the feature sets that our node supports.",
      "length": 145,
      "tokens": 20,
      "embedding": []
    },
    {
      "slug": "func (m *Manager) ListSets() []Set {",
      "content": "func (m *Manager) ListSets() []Set {\n\tvar sets []Set\n\n\tfor set := range m.fsets {\n\t\tsets = append(sets, set)\n\t}\n\n\treturn sets\n}\n",
      "length": 83,
      "tokens": 17,
      "embedding": []
    }
  ]
}