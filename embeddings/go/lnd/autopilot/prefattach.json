{
  "filepath": "../implementations/go/lnd/autopilot/prefattach.go",
  "package": "autopilot",
  "sections": [
    {
      "slug": "type PrefAttachment struct {",
      "content": "type PrefAttachment struct {\n}\n\n// NewPrefAttachment creates a new instance of a PrefAttachment heuristic.",
      "length": 75,
      "tokens": 11,
      "embedding": []
    },
    {
      "slug": "func NewPrefAttachment() *PrefAttachment {",
      "content": "func NewPrefAttachment() *PrefAttachment {\n\tprand.Seed(time.Now().Unix())\n\treturn &PrefAttachment{}\n}\n\n// A compile time assertion to ensure PrefAttachment meets the\n// AttachmentHeuristic interface.\nvar _ AttachmentHeuristic = (*PrefAttachment)(nil)\n\n// NodeID is a simple type that holds an EC public key serialized in compressed\n// format.",
      "length": 290,
      "tokens": 39,
      "embedding": []
    },
    {
      "slug": "type NodeID [33]byte",
      "content": "type NodeID [33]byte\n\n// NewNodeID creates a new nodeID from a passed public key.",
      "length": 59,
      "tokens": 11,
      "embedding": []
    },
    {
      "slug": "func NewNodeID(pub *btcec.PublicKey) NodeID {",
      "content": "func NewNodeID(pub *btcec.PublicKey) NodeID {\n\tvar n NodeID\n\tcopy(n[:], pub.SerializeCompressed())\n\treturn n\n}\n\n// Name returns the name of this heuristic.\n//\n// NOTE: This is a part of the AttachmentHeuristic interface.",
      "length": 167,
      "tokens": 27,
      "embedding": []
    },
    {
      "slug": "func (p *PrefAttachment) Name() string {",
      "content": "func (p *PrefAttachment) Name() string {\n\treturn \"preferential\"\n}\n\n// NodeScores is a method that given the current channel graph and current set\n// of local channels, scores the given nodes according to the preference of\n// opening a channel of the given size with them. The returned channel\n// candidates maps the NodeID to a NodeScore for the node.\n//\n// The heuristic employed by this method is one that attempts to promote a\n// scale-free network globally, via local attachment preferences for new nodes\n// joining the network with an amount of available funds to be allocated to\n// channels. Specifically, we consider the degree of each node (and the flow\n// in/out of the node available via its open channels) and utilize the\n// Barab\u00e1si\u2013Albert model to drive our recommended attachment heuristics. If\n// implemented globally for each new participant, this results in a channel\n// graph that is scale-free and follows a power law distribution with k=-3.\n//\n// To avoid assigning a high score to nodes with a large number of small\n// channels, we only count channels at least as large as a given fraction of\n// the graph's median channel size.\n//\n// The returned scores will be in the range [0.0, 1.0], where higher scores are\n// given to nodes already having high connectivity in the graph.\n//\n// NOTE: This is a part of the AttachmentHeuristic interface.",
      "length": 1297,
      "tokens": 230,
      "embedding": []
    },
    {
      "slug": "func (p *PrefAttachment) NodeScores(g ChannelGraph, chans []LocalChannel,",
      "content": "func (p *PrefAttachment) NodeScores(g ChannelGraph, chans []LocalChannel,\n\tchanSize btcutil.Amount, nodes map[NodeID]struct{}) (\n\tmap[NodeID]*NodeScore, error) {\n\n\t// We first run though the graph once in order to find the median\n\t// channel size.\n\tvar (\n\t\tallChans  []btcutil.Amount\n\t\tseenChans = make(map[uint64]struct{})\n\t)\n\tif err := g.ForEachNode(func(n Node) error {\n\t\terr := n.ForEachChannel(func(e ChannelEdge) error {\n\t\t\tif _, ok := seenChans[e.ChanID.ToUint64()]; ok {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tseenChans[e.ChanID.ToUint64()] = struct{}{}\n\t\t\tallChans = append(allChans, e.Capacity)\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn nil\n\t}); err != nil {\n\t\treturn nil, err\n\t}\n\n\tmedianChanSize := Median(allChans)\n\tlog.Tracef(\"Found channel median %v for preferential score heuristic\",\n\t\tmedianChanSize)\n\n\t// Count the number of large-ish channels for each particular node in\n\t// the graph.\n\tvar maxChans int\n\tnodeChanNum := make(map[NodeID]int)\n\tif err := g.ForEachNode(func(n Node) error {\n\t\tvar nodeChans int\n\t\terr := n.ForEachChannel(func(e ChannelEdge) error {\n\t\t\t// Since connecting to nodes with a lot of small\n\t\t\t// channels actually worsens our connectivity in the\n\t\t\t// graph (we will potentially waste time trying to use\n\t\t\t// these useless channels in path finding), we decrease\n\t\t\t// the counter for such channels.\n\t\t\tif e.Capacity < medianChanSize/minMedianChanSizeFraction {\n\t\t\t\tnodeChans--\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Larger channels we count.\n\t\t\tnodeChans++\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// We keep track of the highest-degree node we've seen, as this\n\t\t// will be given the max score.\n\t\tif nodeChans > maxChans {\n\t\t\tmaxChans = nodeChans\n\t\t}\n\n\t\t// If this node is not among our nodes to score, we can return\n\t\t// early.\n\t\tnID := NodeID(n.PubKey())\n\t\tif _, ok := nodes[nID]; !ok {\n\t\t\tlog.Tracef(\"Node %x not among nodes to score, \"+\n\t\t\t\t\"ignoring\", nID[:])\n\t\t\treturn nil\n\t\t}\n\n\t\t// Otherwise we'll record the number of channels.\n\t\tnodeChanNum[nID] = nodeChans\n\t\tlog.Tracef(\"Counted %v channels for node %x\", nodeChans, nID[:])\n\n\t\treturn nil\n\t}); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// If there are no channels in the graph we cannot determine any\n\t// preferences, so we return, indicating all candidates get a score of\n\t// zero.\n\tif maxChans == 0 {\n\t\tlog.Tracef(\"No channels in the graph\")\n\t\treturn nil, nil\n\t}\n\n\texistingPeers := make(map[NodeID]struct{})\n\tfor _, c := range chans {\n\t\texistingPeers[c.Node] = struct{}{}\n\t}\n\n\t// For each node in the set of nodes, count their fraction of channels\n\t// in the graph, and use that as the score.\n\tcandidates := make(map[NodeID]*NodeScore)\n\tfor nID, nodeChans := range nodeChanNum {\n\n\t\t// If the node is among or existing channel peers, we don't\n\t\t// need another channel.\n\t\tif _, ok := existingPeers[nID]; ok {\n\t\t\tlog.Tracef(\"Node %x among existing peers for pref \"+\n\t\t\t\t\"attach heuristic, giving zero score\", nID[:])\n\t\t\tcontinue\n\t\t}\n\n\t\t// If the node had no large channels, we skip it, since it\n\t\t// would have gotten a zero score anyway.\n\t\tif nodeChans <= 0 {\n\t\t\tlog.Tracef(\"Skipping node %x with channel count %v\",\n\t\t\t\tnID[:], nodeChans)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Otherwise we score the node according to its fraction of\n\t\t// channels in the graph, scaled such that the highest-degree\n\t\t// node will be given a score of 1.0.\n\t\tscore := float64(nodeChans) / float64(maxChans)\n\t\tlog.Tracef(\"Giving node %x a pref attach score of %v\",\n\t\t\tnID[:], score)\n\n\t\tcandidates[nID] = &NodeScore{\n\t\t\tNodeID: nID,\n\t\t\tScore:  score,\n\t\t}\n\t}\n\n\treturn candidates, nil\n}\n",
      "length": 3354,
      "tokens": 524,
      "embedding": []
    }
  ]
}