{
  "filepath": "../implementations/go/lnd/autopilot/agent_test.go",
  "package": "autopilot",
  "sections": [
    {
      "slug": "type moreChansResp struct {",
      "content": "type moreChansResp struct {\n\tnumMore uint32\n\tamt     btcutil.Amount\n}\n",
      "length": 39,
      "tokens": 5,
      "embedding": []
    },
    {
      "slug": "type moreChanArg struct {",
      "content": "type moreChanArg struct {\n\tchans   []LocalChannel\n\tbalance btcutil.Amount\n}\n",
      "length": 47,
      "tokens": 5,
      "embedding": []
    },
    {
      "slug": "type mockConstraints struct {",
      "content": "type mockConstraints struct {\n\tmoreChansResps chan moreChansResp\n\tmoreChanArgs   chan moreChanArg\n\tquit           chan struct{}\n}\n",
      "length": 96,
      "tokens": 10,
      "embedding": []
    },
    {
      "slug": "func (m *mockConstraints) ChannelBudget(chans []LocalChannel,",
      "content": "func (m *mockConstraints) ChannelBudget(chans []LocalChannel,\n\tbalance btcutil.Amount) (btcutil.Amount, uint32) {\n\n\tif m.moreChanArgs != nil {\n\t\tmoreChan := moreChanArg{\n\t\t\tchans:   chans,\n\t\t\tbalance: balance,\n\t\t}\n\n\t\tselect {\n\t\tcase m.moreChanArgs <- moreChan:\n\t\tcase <-m.quit:\n\t\t\treturn 0, 0\n\t\t}\n\t}\n\n\tselect {\n\tcase resp := <-m.moreChansResps:\n\t\treturn resp.amt, resp.numMore\n\tcase <-m.quit:\n\t\treturn 0, 0\n\t}\n}\n",
      "length": 328,
      "tokens": 47,
      "embedding": []
    },
    {
      "slug": "func (m *mockConstraints) MaxPendingOpens() uint16 {",
      "content": "func (m *mockConstraints) MaxPendingOpens() uint16 {\n\treturn 10\n}\n",
      "length": 11,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (m *mockConstraints) MinChanSize() btcutil.Amount {",
      "content": "func (m *mockConstraints) MinChanSize() btcutil.Amount {\n\treturn 1e7\n}",
      "length": 12,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (m *mockConstraints) MaxChanSize() btcutil.Amount {",
      "content": "func (m *mockConstraints) MaxChanSize() btcutil.Amount {\n\treturn 1e8\n}\n\nvar _ AgentConstraints = (*mockConstraints)(nil)\n",
      "length": 60,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "type mockHeuristic struct {",
      "content": "type mockHeuristic struct {\n\tnodeScoresResps chan map[NodeID]*NodeScore\n\tnodeScoresArgs  chan directiveArg\n\n\tquit chan struct{}\n}\n",
      "length": 97,
      "tokens": 10,
      "embedding": []
    },
    {
      "slug": "type directiveArg struct {",
      "content": "type directiveArg struct {\n\tgraph ChannelGraph\n\tamt   btcutil.Amount\n\tchans []LocalChannel\n\tnodes map[NodeID]struct{}\n}\n",
      "length": 88,
      "tokens": 9,
      "embedding": []
    },
    {
      "slug": "func (m *mockHeuristic) Name() string {",
      "content": "func (m *mockHeuristic) Name() string {\n\treturn \"mock\"\n}\n",
      "length": 15,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (m *mockHeuristic) NodeScores(g ChannelGraph, chans []LocalChannel,",
      "content": "func (m *mockHeuristic) NodeScores(g ChannelGraph, chans []LocalChannel,\n\tchanSize btcutil.Amount, nodes map[NodeID]struct{}) (\n\tmap[NodeID]*NodeScore, error) {\n\n\tif m.nodeScoresArgs != nil {\n\t\tdirective := directiveArg{\n\t\t\tgraph: g,\n\t\t\tamt:   chanSize,\n\t\t\tchans: chans,\n\t\t\tnodes: nodes,\n\t\t}\n\n\t\tselect {\n\t\tcase m.nodeScoresArgs <- directive:\n\t\tcase <-m.quit:\n\t\t\treturn nil, errors.New(\"exiting\")\n\t\t}\n\t}\n\n\tselect {\n\tcase resp := <-m.nodeScoresResps:\n\t\treturn resp, nil\n\tcase <-m.quit:\n\t\treturn nil, errors.New(\"exiting\")\n\t}\n}\n\nvar _ AttachmentHeuristic = (*mockHeuristic)(nil)\n",
      "length": 476,
      "tokens": 59,
      "embedding": []
    },
    {
      "slug": "type openChanIntent struct {",
      "content": "type openChanIntent struct {\n\ttarget  *btcec.PublicKey\n\tamt     btcutil.Amount\n\tprivate bool\n}\n",
      "length": 62,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "type mockChanController struct {",
      "content": "type mockChanController struct {\n\topenChanSignals chan openChanIntent\n\tprivate         bool\n}\n",
      "length": 58,
      "tokens": 6,
      "embedding": []
    },
    {
      "slug": "func (m *mockChanController) OpenChannel(target *btcec.PublicKey,",
      "content": "func (m *mockChanController) OpenChannel(target *btcec.PublicKey,\n\tamt btcutil.Amount) error {\n\n\tm.openChanSignals <- openChanIntent{\n\t\ttarget:  target,\n\t\tamt:     amt,\n\t\tprivate: m.private,\n\t}\n\n\treturn nil\n}\n",
      "length": 133,
      "tokens": 17,
      "embedding": []
    },
    {
      "slug": "func (m *mockChanController) CloseChannel(chanPoint *wire.OutPoint) error {",
      "content": "func (m *mockChanController) CloseChannel(chanPoint *wire.OutPoint) error {\n\treturn nil\n}\n\nvar _ ChannelController = (*mockChanController)(nil)\n",
      "length": 64,
      "tokens": 8,
      "embedding": []
    },
    {
      "slug": "type testContext struct {",
      "content": "type testContext struct {\n\tconstraints    *mockConstraints\n\theuristic      *mockHeuristic\n\tchanController ChannelController\n\tgraph          testGraph\n\tagent          *Agent\n\twalletBalance  btcutil.Amount\n\n\tquit chan struct{}\n\tsync.Mutex\n}\n",
      "length": 203,
      "tokens": 17,
      "embedding": []
    },
    {
      "slug": "func setup(t *testing.T, initialChans []LocalChannel) *testContext {",
      "content": "func setup(t *testing.T, initialChans []LocalChannel) *testContext {\n\tt.Helper()\n\n\t// First, we'll create all the dependencies that we'll need in order to\n\t// create the autopilot agent.\n\tself, err := randKey()\n\trequire.NoError(t, err, \"unable to generate key\")\n\n\tquit := make(chan struct{})\n\theuristic := &mockHeuristic{\n\t\tnodeScoresArgs:  make(chan directiveArg),\n\t\tnodeScoresResps: make(chan map[NodeID]*NodeScore),\n\t\tquit:            quit,\n\t}\n\tconstraints := &mockConstraints{\n\t\tmoreChansResps: make(chan moreChansResp),\n\t\tmoreChanArgs:   make(chan moreChanArg),\n\t\tquit:           quit,\n\t}\n\n\tchanController := &mockChanController{\n\t\topenChanSignals: make(chan openChanIntent, 10),\n\t}\n\tmemGraph, _ := newMemChanGraph(t)\n\n\t// We'll keep track of the funds available to the agent, to make sure\n\t// it correctly uses this value when querying the ChannelBudget.\n\tvar availableFunds btcutil.Amount = 10 * btcutil.SatoshiPerBitcoin\n\n\tctx := &testContext{\n\t\tconstraints:    constraints,\n\t\theuristic:      heuristic,\n\t\tchanController: chanController,\n\t\tgraph:          memGraph,\n\t\twalletBalance:  availableFunds,\n\t\tquit:           quit,\n\t}\n\n\t// With the dependencies we created, we can now create the initial\n\t// agent itself.\n\ttestCfg := Config{\n\t\tSelf:           self,\n\t\tHeuristic:      heuristic,\n\t\tChanController: chanController,\n\t\tWalletBalance: func() (btcutil.Amount, error) {\n\t\t\tctx.Lock()\n\t\t\tdefer ctx.Unlock()\n\t\t\treturn ctx.walletBalance, nil\n\t\t},\n\t\tConnectToPeer: func(*btcec.PublicKey, []net.Addr) (bool, error) {\n\t\t\treturn false, nil\n\t\t},\n\t\tDisconnectPeer: func(*btcec.PublicKey) error {\n\t\t\treturn nil\n\t\t},\n\t\tGraph:       memGraph,\n\t\tConstraints: constraints,\n\t}\n\n\tagent, err := New(testCfg, initialChans)\n\trequire.NoError(t, err, \"unable to create agent\")\n\tctx.agent = agent\n\n\t// With the autopilot agent and all its dependencies we'll start the\n\t// primary controller goroutine.\n\tif err := agent.Start(); err != nil {\n\t\tt.Fatalf(\"unable to start agent: %v\", err)\n\t}\n\n\tt.Cleanup(func() {\n\t\t// We must close quit before agent.Stop(), to make sure\n\t\t// ChannelBudget won't block preventing the agent from exiting.\n\t\tclose(quit)\n\t\tagent.Stop()\n\t})\n\n\treturn ctx\n}\n\n// respondMoreChans consumes the moreChanArgs element and responds to the agent\n// with the given moreChansResp.",
      "length": 2134,
      "tokens": 262,
      "embedding": []
    },
    {
      "slug": "func respondMoreChans(t *testing.T, testCtx *testContext, resp moreChansResp) {",
      "content": "func respondMoreChans(t *testing.T, testCtx *testContext, resp moreChansResp) {\n\tt.Helper()\n\n\t// The agent should now query the heuristic.\n\tselect {\n\tcase <-testCtx.constraints.moreChanArgs:\n\tcase <-time.After(time.Second * 3):\n\t\tt.Fatalf(\"heuristic wasn't queried in time\")\n\t}\n\n\t// We'll send the response.\n\tselect {\n\tcase testCtx.constraints.moreChansResps <- resp:\n\tcase <-time.After(time.Second * 10):\n\t\tt.Fatalf(\"response wasn't sent in time\")\n\t}\n}\n\n// respondMoreChans consumes the nodeScoresArgs element and responds to the\n// agent with the given node scores.",
      "length": 469,
      "tokens": 62,
      "embedding": []
    },
    {
      "slug": "func respondNodeScores(t *testing.T, testCtx *testContext,",
      "content": "func respondNodeScores(t *testing.T, testCtx *testContext,\n\tresp map[NodeID]*NodeScore) {\n\tt.Helper()\n\n\t// Send over an empty list of attachment directives, which should cause\n\t// the agent to return to waiting on a new signal.\n\tselect {\n\tcase <-testCtx.heuristic.nodeScoresArgs:\n\tcase <-time.After(time.Second * 3):\n\t\tt.Fatalf(\"node scores weren't queried in time\")\n\t}\n\tselect {\n\tcase testCtx.heuristic.nodeScoresResps <- resp:\n\tcase <-time.After(time.Second * 10):\n\t\tt.Fatalf(\"node scores were not sent in time\")\n\t}\n}\n\n// TestAgentChannelOpenSignal tests that upon receipt of a chanOpenUpdate, then\n// agent modifies its local state accordingly, and reconsults the heuristic.",
      "length": 600,
      "tokens": 82,
      "embedding": []
    },
    {
      "slug": "func TestAgentChannelOpenSignal(t *testing.T) {",
      "content": "func TestAgentChannelOpenSignal(t *testing.T) {\n\tt.Parallel()\n\n\ttestCtx := setup(t, nil)\n\n\t// We'll send an initial \"no\" response to advance the agent past its\n\t// initial check.\n\trespondMoreChans(t, testCtx, moreChansResp{0, 0})\n\n\t// Next we'll signal a new channel being opened by the backing LN node,\n\t// with a capacity of 1 BTC.\n\tnewChan := LocalChannel{\n\t\tChanID:  randChanID(),\n\t\tBalance: btcutil.SatoshiPerBitcoin,\n\t}\n\ttestCtx.agent.OnChannelOpen(newChan)\n\n\t// The agent should now query the heuristic in order to determine its\n\t// next action as it local state has now been modified.\n\trespondMoreChans(t, testCtx, moreChansResp{0, 0})\n\n\t// At this point, the local state of the agent should\n\t// have also been updated to reflect that the LN node\n\t// now has an additional channel with one BTC.\n\tif _, ok := testCtx.agent.chanState[newChan.ChanID]; !ok {\n\t\tt.Fatalf(\"internal channel state wasn't updated\")\n\t}\n\n\t// There shouldn't be a call to the Select method as we've returned\n\t// \"false\" for NeedMoreChans above.\n\tselect {\n\n\t// If this send success, then Select was erroneously called and the\n\t// test should be failed.\n\tcase testCtx.heuristic.nodeScoresResps <- map[NodeID]*NodeScore{}:\n\t\tt.Fatalf(\"Select was called but shouldn't have been\")\n\n\t// This is the correct path as Select should've be called.\n\tdefault:\n\t}\n}\n\n// TestAgentHeuristicUpdateSignal tests that upon notification about a\n// heuristic update, the agent reconsults the heuristic.",
      "length": 1370,
      "tokens": 205,
      "embedding": []
    },
    {
      "slug": "func TestAgentHeuristicUpdateSignal(t *testing.T) {",
      "content": "func TestAgentHeuristicUpdateSignal(t *testing.T) {\n\tt.Parallel()\n\n\ttestCtx := setup(t, nil)\n\n\tpub, err := testCtx.graph.addRandNode()\n\trequire.NoError(t, err, \"unable to generate key\")\n\n\t// We'll send an initial \"no\" response to advance the agent past its\n\t// initial check.\n\trespondMoreChans(t, testCtx, moreChansResp{0, 0})\n\n\t// Next we'll signal that one of the heuristics have been updated.\n\ttestCtx.agent.OnHeuristicUpdate(testCtx.heuristic)\n\n\t// The update should trigger the agent to ask for a channel budget.so\n\t// we'll respond that there is a budget for opening 1 more channel.\n\trespondMoreChans(t, testCtx,\n\t\tmoreChansResp{\n\t\t\tnumMore: 1,\n\t\t\tamt:     1 * btcutil.SatoshiPerBitcoin,\n\t\t},\n\t)\n\n\t// At this point, the agent should now be querying the heuristic for\n\t// scores. We'll respond.\n\tnodeID := NewNodeID(pub)\n\tscores := map[NodeID]*NodeScore{\n\t\tnodeID: {\n\t\t\tNodeID: nodeID,\n\t\t\tScore:  0.5,\n\t\t},\n\t}\n\trespondNodeScores(t, testCtx, scores)\n\n\t// Finally, this should result in the agent opening a channel.\n\tchanController := testCtx.chanController.(*mockChanController)\n\tselect {\n\tcase <-chanController.openChanSignals:\n\tcase <-time.After(time.Second * 10):\n\t\tt.Fatalf(\"channel not opened in time\")\n\t}\n}\n\n// A mockFailingChanController always fails to open a channel.",
      "length": 1185,
      "tokens": 157,
      "embedding": []
    },
    {
      "slug": "type mockFailingChanController struct {",
      "content": "type mockFailingChanController struct {\n}\n",
      "length": 1,
      "tokens": 1,
      "embedding": []
    },
    {
      "slug": "func (m *mockFailingChanController) OpenChannel(target *btcec.PublicKey,",
      "content": "func (m *mockFailingChanController) OpenChannel(target *btcec.PublicKey,\n\tamt btcutil.Amount) error {\n\treturn errors.New(\"failure\")\n}\n",
      "length": 58,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "func (m *mockFailingChanController) CloseChannel(chanPoint *wire.OutPoint) error {",
      "content": "func (m *mockFailingChanController) CloseChannel(chanPoint *wire.OutPoint) error {\n\treturn nil\n}\n\nvar _ ChannelController = (*mockFailingChanController)(nil)\n\n// TestAgentChannelFailureSignal tests that if an autopilot channel fails to\n// open, the agent is signalled to make a new decision.",
      "length": 202,
      "tokens": 29,
      "embedding": []
    },
    {
      "slug": "func TestAgentChannelFailureSignal(t *testing.T) {",
      "content": "func TestAgentChannelFailureSignal(t *testing.T) {\n\tt.Parallel()\n\n\ttestCtx := setup(t, nil)\n\n\ttestCtx.chanController = &mockFailingChanController{}\n\n\tnode, err := testCtx.graph.addRandNode()\n\trequire.NoError(t, err, \"unable to add node\")\n\n\t// First ensure the agent will attempt to open a new channel. Return\n\t// that we need more channels, and have 5BTC to use.\n\trespondMoreChans(t, testCtx, moreChansResp{1, 5 * btcutil.SatoshiPerBitcoin})\n\n\t// At this point, the agent should now be querying the heuristic to\n\t// request attachment directives, return a fake so the agent will\n\t// attempt to open a channel.\n\tvar fakeDirective = &NodeScore{\n\t\tNodeID: NewNodeID(node),\n\t\tScore:  0.5,\n\t}\n\n\trespondNodeScores(\n\t\tt, testCtx, map[NodeID]*NodeScore{\n\t\t\tNewNodeID(node): fakeDirective,\n\t\t},\n\t)\n\n\t// At this point the agent will attempt to create a channel and fail.\n\n\t// Now ensure that the controller loop is re-executed.\n\trespondMoreChans(t, testCtx, moreChansResp{1, 5 * btcutil.SatoshiPerBitcoin})\n\trespondNodeScores(t, testCtx, map[NodeID]*NodeScore{})\n}\n\n// TestAgentChannelCloseSignal ensures that once the agent receives an outside\n// signal of a channel belonging to the backing LN node being closed, then it\n// will query the heuristic to make its next decision.",
      "length": 1180,
      "tokens": 163,
      "embedding": []
    },
    {
      "slug": "func TestAgentChannelCloseSignal(t *testing.T) {",
      "content": "func TestAgentChannelCloseSignal(t *testing.T) {\n\tt.Parallel()\n\t// We'll start the agent with two channels already being active.\n\tinitialChans := []LocalChannel{\n\t\t{\n\t\t\tChanID:  randChanID(),\n\t\t\tBalance: btcutil.SatoshiPerBitcoin,\n\t\t},\n\t\t{\n\t\t\tChanID:  randChanID(),\n\t\t\tBalance: btcutil.SatoshiPerBitcoin * 2,\n\t\t},\n\t}\n\n\ttestCtx := setup(t, initialChans)\n\n\t// We'll send an initial \"no\" response to advance the agent past its\n\t// initial check.\n\trespondMoreChans(t, testCtx, moreChansResp{0, 0})\n\n\t// Next, we'll close both channels which should force the agent to\n\t// re-query the heuristic.\n\ttestCtx.agent.OnChannelClose(initialChans[0].ChanID, initialChans[1].ChanID)\n\n\t// The agent should now query the heuristic in order to determine its\n\t// next action as it local state has now been modified.\n\trespondMoreChans(t, testCtx, moreChansResp{0, 0})\n\n\t// At this point, the local state of the agent should\n\t// have also been updated to reflect that the LN node\n\t// has no existing open channels.\n\tif len(testCtx.agent.chanState) != 0 {\n\t\tt.Fatalf(\"internal channel state wasn't updated\")\n\t}\n\n\t// There shouldn't be a call to the Select method as we've returned\n\t// \"false\" for NeedMoreChans above.\n\tselect {\n\n\t// If this send success, then Select was erroneously called and the\n\t// test should be failed.\n\tcase testCtx.heuristic.nodeScoresResps <- map[NodeID]*NodeScore{}:\n\t\tt.Fatalf(\"Select was called but shouldn't have been\")\n\n\t// This is the correct path as Select should've be called.\n\tdefault:\n\t}\n}\n\n// TestAgentBalanceUpdateIncrease ensures that once the agent receives an\n// outside signal concerning a balance update, then it will re-query the\n// heuristic to determine its next action.",
      "length": 1595,
      "tokens": 229,
      "embedding": []
    },
    {
      "slug": "func TestAgentBalanceUpdate(t *testing.T) {",
      "content": "func TestAgentBalanceUpdate(t *testing.T) {\n\tt.Parallel()\n\n\ttestCtx := setup(t, nil)\n\n\t// We'll send an initial \"no\" response to advance the agent past its\n\t// initial check.\n\trespondMoreChans(t, testCtx, moreChansResp{0, 0})\n\n\t// Next we'll send a new balance update signal to the agent, adding 5\n\t// BTC to the amount of available funds.\n\ttestCtx.Lock()\n\ttestCtx.walletBalance += btcutil.SatoshiPerBitcoin * 5\n\ttestCtx.Unlock()\n\n\ttestCtx.agent.OnBalanceChange()\n\n\t// The agent should now query the heuristic in order to determine its\n\t// next action as it local state has now been modified.\n\trespondMoreChans(t, testCtx, moreChansResp{0, 0})\n\n\t// At this point, the local state of the agent should\n\t// have also been updated to reflect that the LN node\n\t// now has an additional 5BTC available.\n\tif testCtx.agent.totalBalance != testCtx.walletBalance {\n\t\tt.Fatalf(\"expected %v wallet balance \"+\n\t\t\t\"instead have %v\", testCtx.agent.totalBalance,\n\t\t\ttestCtx.walletBalance)\n\t}\n\n\t// There shouldn't be a call to the Select method as we've returned\n\t// \"false\" for NeedMoreChans above.\n\tselect {\n\n\t// If this send success, then Select was erroneously called and the\n\t// test should be failed.\n\tcase testCtx.heuristic.nodeScoresResps <- map[NodeID]*NodeScore{}:\n\t\tt.Fatalf(\"Select was called but shouldn't have been\")\n\n\t// This is the correct path as Select should've be called.\n\tdefault:\n\t}\n}\n\n// TestAgentImmediateAttach tests that if an autopilot agent is created, and it\n// has enough funds available to create channels, then it does so immediately.",
      "length": 1461,
      "tokens": 215,
      "embedding": []
    },
    {
      "slug": "func TestAgentImmediateAttach(t *testing.T) {",
      "content": "func TestAgentImmediateAttach(t *testing.T) {\n\tt.Parallel()\n\n\ttestCtx := setup(t, nil)\n\n\tconst numChans = 5\n\n\t// We'll generate 5 mock directives so it can progress within its loop.\n\tdirectives := make(map[NodeID]*NodeScore)\n\tnodeKeys := make(map[NodeID]struct{})\n\tfor i := 0; i < numChans; i++ {\n\t\tpub, err := testCtx.graph.addRandNode()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to generate key: %v\", err)\n\t\t}\n\t\tnodeID := NewNodeID(pub)\n\t\tdirectives[nodeID] = &NodeScore{\n\t\t\tNodeID: nodeID,\n\t\t\tScore:  0.5,\n\t\t}\n\t\tnodeKeys[nodeID] = struct{}{}\n\t}\n\t// The very first thing the agent should do is query the NeedMoreChans\n\t// method on the passed heuristic. So we'll provide it with a response\n\t// that will kick off the main loop.\n\trespondMoreChans(t, testCtx,\n\t\tmoreChansResp{\n\t\t\tnumMore: numChans,\n\t\t\tamt:     5 * btcutil.SatoshiPerBitcoin,\n\t\t},\n\t)\n\n\t// At this point, the agent should now be querying the heuristic to\n\t// requests attachment directives.  With our fake directives created,\n\t// we'll now send then to the agent as a return value for the Select\n\t// function.\n\trespondNodeScores(t, testCtx, directives)\n\n\t// Finally, we should receive 5 calls to the OpenChannel method with\n\t// the exact same parameters that we specified within the attachment\n\t// directives.\n\tchanController := testCtx.chanController.(*mockChanController)\n\tfor i := 0; i < numChans; i++ {\n\t\tselect {\n\t\tcase openChan := <-chanController.openChanSignals:\n\t\t\tif openChan.amt != btcutil.SatoshiPerBitcoin {\n\t\t\t\tt.Fatalf(\"invalid chan amt: expected %v, got %v\",\n\t\t\t\t\tbtcutil.SatoshiPerBitcoin, openChan.amt)\n\t\t\t}\n\t\t\tnodeID := NewNodeID(openChan.target)\n\t\t\t_, ok := nodeKeys[nodeID]\n\t\t\tif !ok {\n\t\t\t\tt.Fatalf(\"unexpected key: %v, not found\",\n\t\t\t\t\tnodeID)\n\t\t\t}\n\t\t\tdelete(nodeKeys, nodeID)\n\n\t\tcase <-time.After(time.Second * 10):\n\t\t\tt.Fatalf(\"channel not opened in time\")\n\t\t}\n\t}\n}\n\n// TestAgentPrivateChannels ensure that only requests for private channels are\n// sent if set.",
      "length": 1837,
      "tokens": 258,
      "embedding": []
    },
    {
      "slug": "func TestAgentPrivateChannels(t *testing.T) {",
      "content": "func TestAgentPrivateChannels(t *testing.T) {\n\tt.Parallel()\n\n\ttestCtx := setup(t, nil)\n\n\t// The chanController should be initialized such that all of its open\n\t// channel requests are for private channels.\n\ttestCtx.chanController.(*mockChanController).private = true\n\n\tconst numChans = 5\n\n\t// We'll generate 5 mock directives so the pubkeys will be found in the\n\t// agent's graph, and it can progress within its loop.\n\tdirectives := make(map[NodeID]*NodeScore)\n\tfor i := 0; i < numChans; i++ {\n\t\tpub, err := testCtx.graph.addRandNode()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to generate key: %v\", err)\n\t\t}\n\t\tdirectives[NewNodeID(pub)] = &NodeScore{\n\t\t\tNodeID: NewNodeID(pub),\n\t\t\tScore:  0.5,\n\t\t}\n\t}\n\n\t// The very first thing the agent should do is query the NeedMoreChans\n\t// method on the passed heuristic. So we'll provide it with a response\n\t// that will kick off the main loop.  We'll send over a response\n\t// indicating that it should establish more channels, and give it a\n\t// budget of 5 BTC to do so.\n\tresp := moreChansResp{\n\t\tnumMore: numChans,\n\t\tamt:     5 * btcutil.SatoshiPerBitcoin,\n\t}\n\trespondMoreChans(t, testCtx, resp)\n\n\t// At this point, the agent should now be querying the heuristic to\n\t// requests attachment directives.  With our fake directives created,\n\t// we'll now send then to the agent as a return value for the Select\n\t// function.\n\trespondNodeScores(t, testCtx, directives)\n\n\t// Finally, we should receive 5 calls to the OpenChannel method, each\n\t// specifying that it's for a private channel.\n\tchanController := testCtx.chanController.(*mockChanController)\n\tfor i := 0; i < numChans; i++ {\n\t\tselect {\n\t\tcase openChan := <-chanController.openChanSignals:\n\t\t\tif !openChan.private {\n\t\t\t\tt.Fatal(\"expected open channel request to be private\")\n\t\t\t}\n\t\tcase <-time.After(10 * time.Second):\n\t\t\tt.Fatal(\"channel not opened in time\")\n\t\t}\n\t}\n}\n\n// TestAgentPendingChannelState ensures that the agent properly factors in its\n// pending channel state when making decisions w.r.t if it needs more channels\n// or not, and if so, who is eligible to open new channels to.",
      "length": 1979,
      "tokens": 304,
      "embedding": []
    },
    {
      "slug": "func TestAgentPendingChannelState(t *testing.T) {",
      "content": "func TestAgentPendingChannelState(t *testing.T) {\n\tt.Parallel()\n\n\ttestCtx := setup(t, nil)\n\n\t// We'll only return a single directive for a pre-chosen node.\n\tnodeKey, err := testCtx.graph.addRandNode()\n\trequire.NoError(t, err, \"unable to generate key\")\n\tnodeID := NewNodeID(nodeKey)\n\tnodeDirective := &NodeScore{\n\t\tNodeID: nodeID,\n\t\tScore:  0.5,\n\t}\n\n\t// Once again, we'll start by telling the agent as part of its first\n\t// query, that it needs more channels and has 3 BTC available for\n\t// attachment.  We'll send over a response indicating that it should\n\t// establish more channels, and give it a budget of 1 BTC to do so.\n\trespondMoreChans(t, testCtx,\n\t\tmoreChansResp{\n\t\t\tnumMore: 1,\n\t\t\tamt:     btcutil.SatoshiPerBitcoin,\n\t\t},\n\t)\n\n\trespondNodeScores(t, testCtx,\n\t\tmap[NodeID]*NodeScore{\n\t\t\tnodeID: nodeDirective,\n\t\t},\n\t)\n\n\t// A request to open the channel should've also been sent.\n\tchanController := testCtx.chanController.(*mockChanController)\n\tselect {\n\tcase openChan := <-chanController.openChanSignals:\n\t\tchanAmt := testCtx.constraints.MaxChanSize()\n\t\tif openChan.amt != chanAmt {\n\t\t\tt.Fatalf(\"invalid chan amt: expected %v, got %v\",\n\t\t\t\tchanAmt, openChan.amt)\n\t\t}\n\t\tif !openChan.target.IsEqual(nodeKey) {\n\t\t\tt.Fatalf(\"unexpected key: expected %x, got %x\",\n\t\t\t\tnodeKey.SerializeCompressed(),\n\t\t\t\topenChan.target.SerializeCompressed())\n\t\t}\n\tcase <-time.After(time.Second * 10):\n\t\tt.Fatalf(\"channel wasn't opened in time\")\n\t}\n\n\t// Now, in order to test that the pending state was properly updated,\n\t// we'll trigger a balance update in order to trigger a query to the\n\t// heuristic.\n\ttestCtx.Lock()\n\ttestCtx.walletBalance += 0.4 * btcutil.SatoshiPerBitcoin\n\ttestCtx.Unlock()\n\n\ttestCtx.agent.OnBalanceChange()\n\n\t// The heuristic should be queried, and the argument for the set of\n\t// channels passed in should include the pending channels that\n\t// should've been created above.\n\tselect {\n\t// The request that we get should include a pending channel for the\n\t// one that we just created, otherwise the agent isn't properly\n\t// updating its internal state.\n\tcase req := <-testCtx.constraints.moreChanArgs:\n\t\tchanAmt := testCtx.constraints.MaxChanSize()\n\t\tif len(req.chans) != 1 {\n\t\t\tt.Fatalf(\"should include pending chan in current \"+\n\t\t\t\t\"state, instead have %v chans\", len(req.chans))\n\t\t}\n\t\tif req.chans[0].Balance != chanAmt {\n\t\t\tt.Fatalf(\"wrong chan balance: expected %v, got %v\",\n\t\t\t\treq.chans[0].Balance, chanAmt)\n\t\t}\n\t\tif req.chans[0].Node != nodeID {\n\t\t\tt.Fatalf(\"wrong node ID: expected %x, got %x\",\n\t\t\t\tnodeID, req.chans[0].Node[:])\n\t\t}\n\tcase <-time.After(time.Second * 10):\n\t\tt.Fatalf(\"need more chans wasn't queried in time\")\n\t}\n\n\t// We'll send across a response indicating that it *does* need more\n\t// channels.\n\tselect {\n\tcase testCtx.constraints.moreChansResps <- moreChansResp{1, btcutil.SatoshiPerBitcoin}:\n\tcase <-time.After(time.Second * 10):\n\t\tt.Fatalf(\"need more chans wasn't queried in time\")\n\t}\n\n\t// The response above should prompt the agent to make a query to the\n\t// Select method. The arguments passed should reflect the fact that the\n\t// node we have a pending channel to, should be ignored.\n\tselect {\n\tcase req := <-testCtx.heuristic.nodeScoresArgs:\n\t\tif len(req.chans) == 0 {\n\t\t\tt.Fatalf(\"expected to skip %v nodes, instead \"+\n\t\t\t\t\"skipping %v\", 1, len(req.chans))\n\t\t}\n\t\tif req.chans[0].Node != nodeID {\n\t\t\tt.Fatalf(\"pending node not included in skip arguments\")\n\t\t}\n\tcase <-time.After(time.Second * 10):\n\t\tt.Fatalf(\"select wasn't queried in time\")\n\t}\n}\n\n// TestAgentPendingOpenChannel ensures that the agent queries its heuristic once\n// it detects a channel is pending open. This allows the agent to use its own\n// change outputs that have yet to confirm for funding transactions.",
      "length": 3557,
      "tokens": 484,
      "embedding": []
    },
    {
      "slug": "func TestAgentPendingOpenChannel(t *testing.T) {",
      "content": "func TestAgentPendingOpenChannel(t *testing.T) {\n\tt.Parallel()\n\n\ttestCtx := setup(t, nil)\n\n\t// We'll send an initial \"no\" response to advance the agent past its\n\t// initial check.\n\trespondMoreChans(t, testCtx, moreChansResp{0, 0})\n\n\t// Next, we'll signal that a new channel has been opened, but it is\n\t// still pending.\n\ttestCtx.agent.OnChannelPendingOpen()\n\n\t// The agent should now query the heuristic in order to determine its\n\t// next action as its local state has now been modified.\n\trespondMoreChans(t, testCtx, moreChansResp{0, 0})\n\n\t// There shouldn't be a call to the Select method as we've returned\n\t// \"false\" for NeedMoreChans above.\n\tselect {\n\tcase testCtx.heuristic.nodeScoresResps <- map[NodeID]*NodeScore{}:\n\t\tt.Fatalf(\"Select was called but shouldn't have been\")\n\tdefault:\n\t}\n}\n\n// TestAgentOnNodeUpdates tests that the agent will wake up in response to the\n// OnNodeUpdates signal. This is useful in ensuring that autopilot is always\n// pulling in the latest graph updates into its decision making. It also\n// prevents the agent from stalling after an initial attempt that finds no nodes\n// in the graph.",
      "length": 1044,
      "tokens": 161,
      "embedding": []
    },
    {
      "slug": "func TestAgentOnNodeUpdates(t *testing.T) {",
      "content": "func TestAgentOnNodeUpdates(t *testing.T) {\n\tt.Parallel()\n\n\ttestCtx := setup(t, nil)\n\n\t// We'll send an initial \"yes\" response to advance the agent past its\n\t// initial check. This will cause it to try to get directives from an\n\t// empty graph.\n\trespondMoreChans(\n\t\tt, testCtx,\n\t\tmoreChansResp{\n\t\t\tnumMore: 2,\n\t\t\tamt:     testCtx.walletBalance,\n\t\t},\n\t)\n\n\t// Send over an empty list of attachment directives, which should cause\n\t// the agent to return to waiting on a new signal.\n\trespondNodeScores(t, testCtx, map[NodeID]*NodeScore{})\n\n\t// Simulate more nodes being added to the graph by informing the agent\n\t// that we have node updates.\n\ttestCtx.agent.OnNodeUpdates()\n\n\t// In response, the agent should wake up and see if it needs more\n\t// channels. Since we haven't done anything, we will send the same\n\t// response as before since we are still trying to open channels.\n\trespondMoreChans(\n\t\tt, testCtx,\n\t\tmoreChansResp{\n\t\t\tnumMore: 2,\n\t\t\tamt:     testCtx.walletBalance,\n\t\t},\n\t)\n\n\t// Again the agent should pull in the next set of attachment directives.\n\t// It's not important that this list is also empty, so long as the node\n\t// updates signal is causing the agent to make this attempt.\n\trespondNodeScores(t, testCtx, map[NodeID]*NodeScore{})\n}\n\n// TestAgentSkipPendingConns asserts that the agent will not try to make\n// duplicate connection requests to the same node, even if the attachment\n// heuristic instructs the agent to do so. It also asserts that the agent\n// stops tracking the pending connection once it finishes. Note that in\n// practice, a failed connection would be inserted into the skip map passed to\n// the attachment heuristic, though this does not assert that case.",
      "length": 1600,
      "tokens": 256,
      "embedding": []
    },
    {
      "slug": "func TestAgentSkipPendingConns(t *testing.T) {",
      "content": "func TestAgentSkipPendingConns(t *testing.T) {\n\tt.Parallel()\n\n\ttestCtx := setup(t, nil)\n\n\tconnect := make(chan chan error)\n\ttestCtx.agent.cfg.ConnectToPeer = func(*btcec.PublicKey, []net.Addr) (bool, error) {\n\t\terrChan := make(chan error)\n\n\t\tselect {\n\t\tcase connect <- errChan:\n\t\tcase <-testCtx.quit:\n\t\t\treturn false, errors.New(\"quit\")\n\t\t}\n\n\t\tselect {\n\t\tcase err := <-errChan:\n\t\t\treturn false, err\n\t\tcase <-testCtx.quit:\n\t\t\treturn false, errors.New(\"quit\")\n\t\t}\n\t}\n\n\t// We'll only return a single directive for a pre-chosen node.\n\tnodeKey, err := testCtx.graph.addRandNode()\n\trequire.NoError(t, err, \"unable to generate key\")\n\tnodeID := NewNodeID(nodeKey)\n\tnodeDirective := &NodeScore{\n\t\tNodeID: nodeID,\n\t\tScore:  0.5,\n\t}\n\n\t// We'll also add a second node to the graph, to keep the first one\n\t// company.\n\tnodeKey2, err := testCtx.graph.addRandNode()\n\trequire.NoError(t, err, \"unable to generate key\")\n\tnodeID2 := NewNodeID(nodeKey2)\n\n\t// We'll send an initial \"yes\" response to advance the agent past its\n\t// initial check. This will cause it to try to get directives from the\n\t// graph.\n\trespondMoreChans(t, testCtx,\n\t\tmoreChansResp{\n\t\t\tnumMore: 1,\n\t\t\tamt:     testCtx.walletBalance,\n\t\t},\n\t)\n\n\t// Both nodes should be part of the arguments.\n\tselect {\n\tcase req := <-testCtx.heuristic.nodeScoresArgs:\n\t\tif len(req.nodes) != 2 {\n\t\t\tt.Fatalf(\"expected %v nodes, instead \"+\n\t\t\t\t\"had %v\", 2, len(req.nodes))\n\t\t}\n\t\tif _, ok := req.nodes[nodeID]; !ok {\n\t\t\tt.Fatalf(\"node not included in arguments\")\n\t\t}\n\t\tif _, ok := req.nodes[nodeID2]; !ok {\n\t\t\tt.Fatalf(\"node not included in arguments\")\n\t\t}\n\tcase <-time.After(time.Second * 10):\n\t\tt.Fatalf(\"select wasn't queried in time\")\n\t}\n\n\t// Respond with a scored directive. We skip node2 for now, implicitly\n\t// giving it a zero-score.\n\tselect {\n\tcase testCtx.heuristic.nodeScoresResps <- map[NodeID]*NodeScore{\n\t\tNewNodeID(nodeKey): nodeDirective,\n\t}:\n\tcase <-time.After(time.Second * 10):\n\t\tt.Fatalf(\"heuristic wasn't queried in time\")\n\t}\n\n\t// The agent should attempt connection to the node.\n\tvar errChan chan error\n\tselect {\n\tcase errChan = <-connect:\n\tcase <-time.After(time.Second * 10):\n\t\tt.Fatalf(\"agent did not attempt connection\")\n\t}\n\n\t// Signal the agent to go again, now that we've tried to connect.\n\ttestCtx.agent.OnNodeUpdates()\n\n\t// The heuristic again informs the agent that we need more channels.\n\trespondMoreChans(t, testCtx,\n\t\tmoreChansResp{\n\t\t\tnumMore: 1,\n\t\t\tamt:     testCtx.walletBalance,\n\t\t},\n\t)\n\n\t// Since the node now has a pending connection, it should be skipped\n\t// and not part of the nodes attempting to be scored.\n\tselect {\n\tcase req := <-testCtx.heuristic.nodeScoresArgs:\n\t\tif len(req.nodes) != 1 {\n\t\t\tt.Fatalf(\"expected %v nodes, instead \"+\n\t\t\t\t\"had %v\", 1, len(req.nodes))\n\t\t}\n\t\tif _, ok := req.nodes[nodeID2]; !ok {\n\t\t\tt.Fatalf(\"node not included in arguments\")\n\t\t}\n\tcase <-time.After(time.Second * 10):\n\t\tt.Fatalf(\"select wasn't queried in time\")\n\t}\n\n\t// Respond with an emtpty score set.\n\tselect {\n\tcase testCtx.heuristic.nodeScoresResps <- map[NodeID]*NodeScore{}:\n\tcase <-time.After(time.Second * 10):\n\t\tt.Fatalf(\"heuristic wasn't queried in time\")\n\t}\n\n\t// The agent should not attempt any connection, since no nodes were\n\t// scored.\n\tselect {\n\tcase <-connect:\n\t\tt.Fatalf(\"agent should not have attempted connection\")\n\tcase <-time.After(time.Second * 3):\n\t}\n\n\t// Now, timeout the original request, which should still be waiting for\n\t// a response.\n\tselect {\n\tcase errChan <- fmt.Errorf(\"connection timeout\"):\n\tcase <-time.After(time.Second * 10):\n\t\tt.Fatalf(\"agent did not receive connection timeout\")\n\t}\n\n\t// The agent will now retry since the last connection attempt failed.\n\t// The heuristic again informs the agent that we need more channels.\n\trespondMoreChans(t, testCtx,\n\t\tmoreChansResp{\n\t\t\tnumMore: 1,\n\t\t\tamt:     testCtx.walletBalance,\n\t\t},\n\t)\n\n\t// The node should now be marked as \"failed\", which should make it\n\t// being skipped during scoring. Again check that it won't be among the\n\t// score request.\n\tselect {\n\tcase req := <-testCtx.heuristic.nodeScoresArgs:\n\t\tif len(req.nodes) != 1 {\n\t\t\tt.Fatalf(\"expected %v nodes, instead \"+\n\t\t\t\t\"had %v\", 1, len(req.nodes))\n\t\t}\n\t\tif _, ok := req.nodes[nodeID2]; !ok {\n\t\t\tt.Fatalf(\"node not included in arguments\")\n\t\t}\n\tcase <-time.After(time.Second * 10):\n\t\tt.Fatalf(\"select wasn't queried in time\")\n\t}\n\n\t// Send a directive for the second node.\n\tnodeDirective2 := &NodeScore{\n\t\tNodeID: nodeID2,\n\t\tScore:  0.5,\n\t}\n\tselect {\n\tcase testCtx.heuristic.nodeScoresResps <- map[NodeID]*NodeScore{\n\t\tnodeID2: nodeDirective2,\n\t}:\n\tcase <-time.After(time.Second * 10):\n\t\tt.Fatalf(\"heuristic wasn't queried in time\")\n\t}\n\n\t// This time, the agent should try the connection to the second node.\n\tselect {\n\tcase <-connect:\n\tcase <-time.After(time.Second * 10):\n\t\tt.Fatalf(\"agent should have attempted connection\")\n\t}\n}\n\n// TestAgentQuitWhenPendingConns tests that we are able to stop the autopilot\n// agent even though there are pending connections to nodes.",
      "length": 4745,
      "tokens": 658,
      "embedding": []
    },
    {
      "slug": "func TestAgentQuitWhenPendingConns(t *testing.T) {",
      "content": "func TestAgentQuitWhenPendingConns(t *testing.T) {\n\tt.Parallel()\n\n\ttestCtx := setup(t, nil)\n\n\tconnect := make(chan chan error)\n\n\ttestCtx.agent.cfg.ConnectToPeer = func(*btcec.PublicKey, []net.Addr) (bool, error) {\n\t\terrChan := make(chan error)\n\n\t\tselect {\n\t\tcase connect <- errChan:\n\t\tcase <-testCtx.quit:\n\t\t\treturn false, errors.New(\"quit\")\n\t\t}\n\n\t\tselect {\n\t\tcase err := <-errChan:\n\t\t\treturn false, err\n\t\tcase <-testCtx.quit:\n\t\t\treturn false, errors.New(\"quit\")\n\t\t}\n\t}\n\n\t// We'll only return a single directive for a pre-chosen node.\n\tnodeKey, err := testCtx.graph.addRandNode()\n\trequire.NoError(t, err, \"unable to generate key\")\n\tnodeID := NewNodeID(nodeKey)\n\tnodeDirective := &NodeScore{\n\t\tNodeID: nodeID,\n\t\tScore:  0.5,\n\t}\n\n\t// We'll send an initial \"yes\" response to advance the agent past its\n\t// initial check. This will cause it to try to get directives from the\n\t// graph.\n\trespondMoreChans(t, testCtx,\n\t\tmoreChansResp{\n\t\t\tnumMore: 1,\n\t\t\tamt:     testCtx.walletBalance,\n\t\t},\n\t)\n\n\t// Check the args.\n\tselect {\n\tcase req := <-testCtx.heuristic.nodeScoresArgs:\n\t\tif len(req.nodes) != 1 {\n\t\t\tt.Fatalf(\"expected %v nodes, instead \"+\n\t\t\t\t\"had %v\", 1, len(req.nodes))\n\t\t}\n\t\tif _, ok := req.nodes[nodeID]; !ok {\n\t\t\tt.Fatalf(\"node not included in arguments\")\n\t\t}\n\tcase <-time.After(time.Second * 10):\n\t\tt.Fatalf(\"select wasn't queried in time\")\n\t}\n\n\t// Respond with a scored directive.\n\tselect {\n\tcase testCtx.heuristic.nodeScoresResps <- map[NodeID]*NodeScore{\n\t\tNewNodeID(nodeKey): nodeDirective,\n\t}:\n\tcase <-time.After(time.Second * 10):\n\t\tt.Fatalf(\"heuristic wasn't queried in time\")\n\t}\n\n\t// The agent should attempt connection to the node.\n\tselect {\n\tcase <-connect:\n\tcase <-time.After(time.Second * 10):\n\t\tt.Fatalf(\"agent did not attempt connection\")\n\t}\n\n\t// Make sure that we are able to stop the agent, even though there is a\n\t// pending connection.\n\tstopped := make(chan error)\n\tgo func() {\n\t\tstopped <- testCtx.agent.Stop()\n\t}()\n\n\tselect {\n\tcase err := <-stopped:\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"error stopping agent: %v\", err)\n\t\t}\n\tcase <-time.After(2 * time.Second):\n\t\tt.Fatalf(\"unable to stop agent\")\n\t}\n}\n\n// respondWithScores checks that the moreChansRequest contains what we expect,\n// and responds with the given node scores.",
      "length": 2100,
      "tokens": 290,
      "embedding": []
    },
    {
      "slug": "func respondWithScores(t *testing.T, testCtx *testContext,",
      "content": "func respondWithScores(t *testing.T, testCtx *testContext,\n\tchannelBudget btcutil.Amount, existingChans, newChans int,\n\tnodeScores map[NodeID]*NodeScore) {\n\n\tt.Helper()\n\n\tselect {\n\tcase testCtx.constraints.moreChansResps <- moreChansResp{\n\t\tnumMore: uint32(newChans),\n\t\tamt:     channelBudget,\n\t}:\n\tcase <-time.After(time.Second * 3):\n\t\tt.Fatalf(\"heuristic wasn't queried in time\")\n\t}\n\n\t// The agent should query for scores using the constraints returned\n\t// above. We expect the agent to use the maximum channel size when\n\t// opening channels.\n\tchanSize := testCtx.constraints.MaxChanSize()\n\n\tselect {\n\tcase req := <-testCtx.heuristic.nodeScoresArgs:\n\t\t// All nodes in the graph should be potential channel\n\t\t// candidates.\n\t\tif len(req.nodes) != len(nodeScores) {\n\t\t\tt.Fatalf(\"expected %v nodes, instead had %v\",\n\t\t\t\tlen(nodeScores), len(req.nodes))\n\t\t}\n\n\t\t// 'existingChans' is already open.\n\t\tif len(req.chans) != existingChans {\n\t\t\tt.Fatalf(\"expected %d existing channel, got %v\",\n\t\t\t\texistingChans, len(req.chans))\n\t\t}\n\t\tif req.amt != chanSize {\n\t\t\tt.Fatalf(\"expected channel size of %v, got %v\",\n\t\t\t\tchanSize, req.amt)\n\t\t}\n\n\tcase <-time.After(time.Second * 3):\n\t\tt.Fatalf(\"select wasn't queried in time\")\n\t}\n\n\t// Respond with the given scores.\n\tselect {\n\tcase testCtx.heuristic.nodeScoresResps <- nodeScores:\n\tcase <-time.After(time.Second * 3):\n\t\tt.Fatalf(\"NodeScores wasn't queried in time\")\n\t}\n}\n\n// checkChannelOpens asserts that the channel controller attempts open the\n// number of channels we expect, and with the exact total allocation.",
      "length": 1441,
      "tokens": 181,
      "embedding": []
    },
    {
      "slug": "func checkChannelOpens(t *testing.T, testCtx *testContext,",
      "content": "func checkChannelOpens(t *testing.T, testCtx *testContext,\n\tallocation btcutil.Amount, numChans int) []NodeID {\n\n\tvar nodes []NodeID\n\n\t// The agent should attempt to open channels, totaling what we expect.\n\tvar totalAllocation btcutil.Amount\n\tchanController := testCtx.chanController.(*mockChanController)\n\tfor i := 0; i < numChans; i++ {\n\t\tselect {\n\t\tcase openChan := <-chanController.openChanSignals:\n\t\t\ttotalAllocation += openChan.amt\n\n\t\t\ttestCtx.Lock()\n\t\t\ttestCtx.walletBalance -= openChan.amt\n\t\t\ttestCtx.Unlock()\n\n\t\t\tnodes = append(nodes, NewNodeID(openChan.target))\n\n\t\tcase <-time.After(time.Second * 3):\n\t\t\tt.Fatalf(\"channel not opened in time\")\n\t\t}\n\t}\n\n\tif totalAllocation != allocation {\n\t\tt.Fatalf(\"expected agent to open channels totalling %v, \"+\n\t\t\t\"instead was %v\", allocation, totalAllocation)\n\t}\n\n\t// Finally, make sure the agent won't try opening more channels.\n\tselect {\n\tcase <-chanController.openChanSignals:\n\t\tt.Fatalf(\"agent unexpectedly opened channel\")\n\n\tcase <-time.After(50 * time.Millisecond):\n\t}\n\n\treturn nodes\n}\n\n// TestAgentChannelSizeAllocation tests that the autopilot agent opens channel\n// of size that stays within the channel budget and size restrictions.",
      "length": 1091,
      "tokens": 132,
      "embedding": []
    },
    {
      "slug": "func TestAgentChannelSizeAllocation(t *testing.T) {",
      "content": "func TestAgentChannelSizeAllocation(t *testing.T) {\n\tt.Parallel()\n\n\t// Total number of nodes in our mock graph.\n\tconst numNodes = 20\n\n\ttestCtx := setup(t, nil)\n\n\tnodeScores := make(map[NodeID]*NodeScore)\n\tfor i := 0; i < numNodes; i++ {\n\t\tnodeKey, err := testCtx.graph.addRandNode()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to generate key: %v\", err)\n\t\t}\n\t\tnodeID := NewNodeID(nodeKey)\n\t\tnodeScores[nodeID] = &NodeScore{\n\t\t\tNodeID: nodeID,\n\t\t\tScore:  0.5,\n\t\t}\n\t}\n\n\t// The agent should now query the heuristic in order to determine its\n\t// next action as it local state has now been modified.\n\tselect {\n\tcase arg := <-testCtx.constraints.moreChanArgs:\n\t\tif len(arg.chans) != 0 {\n\t\t\tt.Fatalf(\"expected agent to have no channels open, \"+\n\t\t\t\t\"had %v\", len(arg.chans))\n\t\t}\n\t\tif arg.balance != testCtx.walletBalance {\n\t\t\tt.Fatalf(\"expected agent to have %v balance, had %v\",\n\t\t\t\ttestCtx.walletBalance, arg.balance)\n\t\t}\n\tcase <-time.After(time.Second * 3):\n\t\tt.Fatalf(\"heuristic wasn't queried in time\")\n\t}\n\n\t// We'll return a response telling the agent to open 5 channels, with a\n\t// total channel budget of 5 BTC.\n\tvar channelBudget btcutil.Amount = 5 * btcutil.SatoshiPerBitcoin\n\tnumExistingChannels := 0\n\tnumNewChannels := 5\n\trespondWithScores(\n\t\tt, testCtx, channelBudget, numExistingChannels,\n\t\tnumNewChannels, nodeScores,\n\t)\n\n\t// We expect the autopilot to have allocated all funds towards\n\t// channels.\n\texpectedAllocation := testCtx.constraints.MaxChanSize() * btcutil.Amount(numNewChannels)\n\tnodes := checkChannelOpens(\n\t\tt, testCtx, expectedAllocation, numNewChannels,\n\t)\n\n\t// Delete the selected nodes from our set of scores, to avoid scoring\n\t// nodes we already have channels to.\n\tfor _, node := range nodes {\n\t\tdelete(nodeScores, node)\n\t}\n\n\t// TODO(halseth): this loop is a hack to ensure all the attempted\n\t// channels are accounted for. This happens because the agent will\n\t// query the ChannelBudget before all the pending channels are added to\n\t// the map. Fix by adding them to the pending channels map before\n\t// executing directives in goroutines?\n\twaitForNumChans := func(expChans int) {\n\t\tt.Helper()\n\n\t\tvar (\n\t\t\tnumChans int\n\t\t\tbalance  btcutil.Amount\n\t\t)\n\n\tLoop:\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase arg := <-testCtx.constraints.moreChanArgs:\n\t\t\t\tnumChans = len(arg.chans)\n\t\t\t\tbalance = arg.balance\n\n\t\t\t\t// As long as the number of existing channels\n\t\t\t\t// is below our expected number of channels,\n\t\t\t\t// and the balance is not what we expect, we'll\n\t\t\t\t// keep responding with \"no more channels\".\n\t\t\t\tif numChans == expChans &&\n\t\t\t\t\tbalance == testCtx.walletBalance {\n\t\t\t\t\tbreak Loop\n\t\t\t\t}\n\n\t\t\t\tselect {\n\t\t\t\tcase testCtx.constraints.moreChansResps <- moreChansResp{0, 0}:\n\t\t\t\tcase <-time.After(time.Second * 3):\n\t\t\t\t\tt.Fatalf(\"heuristic wasn't queried \" +\n\t\t\t\t\t\t\"in time\")\n\t\t\t\t}\n\n\t\t\tcase <-time.After(time.Second * 3):\n\t\t\t\tt.Fatalf(\"did not receive expected \"+\n\t\t\t\t\t\"channels(%d) and balance(%d), \"+\n\t\t\t\t\t\"instead got %d and %d\", expChans,\n\t\t\t\t\ttestCtx.walletBalance, numChans,\n\t\t\t\t\tbalance)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Wait for the agent to have 5 channels.\n\twaitForNumChans(numNewChannels)\n\n\t// Set the channel budget to 1.5 BTC.\n\tchannelBudget = btcutil.SatoshiPerBitcoin * 3 / 2\n\n\t// We'll return a response telling the agent to open 3 channels, with a\n\t// total channel budget of 1.5 BTC.\n\tnumExistingChannels = 5\n\tnumNewChannels = 3\n\trespondWithScores(\n\t\tt, testCtx, channelBudget, numExistingChannels,\n\t\tnumNewChannels, nodeScores,\n\t)\n\n\t// To stay within the budget, we expect the autopilot to open 2\n\t// channels.\n\texpectedAllocation = channelBudget\n\tnodes = checkChannelOpens(t, testCtx, expectedAllocation, 2)\n\tnumExistingChannels = 7\n\n\tfor _, node := range nodes {\n\t\tdelete(nodeScores, node)\n\t}\n\n\twaitForNumChans(numExistingChannels)\n\n\t// Finally check that we make maximum channels if we are well within\n\t// our budget.\n\tchannelBudget = btcutil.SatoshiPerBitcoin * 5\n\tnumNewChannels = 2\n\trespondWithScores(\n\t\tt, testCtx, channelBudget, numExistingChannels,\n\t\tnumNewChannels, nodeScores,\n\t)\n\n\t// We now expect the autopilot to open 2 channels, and since it has\n\t// more than enough balance within the budget, they should both be of\n\t// maximum size.\n\texpectedAllocation = testCtx.constraints.MaxChanSize() *\n\t\tbtcutil.Amount(numNewChannels)\n\n\tcheckChannelOpens(t, testCtx, expectedAllocation, numNewChannels)\n}\n",
      "length": 4119,
      "tokens": 570,
      "embedding": []
    }
  ]
}