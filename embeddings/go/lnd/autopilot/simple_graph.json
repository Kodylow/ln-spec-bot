{
  "filepath": "../implementations/go/lnd/autopilot/simple_graph.go",
  "package": "autopilot",
  "sections": [
    {
      "slug": "type SimpleGraph struct {",
      "content": "type SimpleGraph struct {\n\t// Nodes is a map from node index to NodeID.\n\tNodes []NodeID\n\n\t// Adj stores nodes and neighbors in an adjacency list.\n\tAdj [][]int\n}\n\n// NewSimpleGraph creates a simplified graph from the current channel graph.\n// Returns an error if the channel graph iteration fails due to underlying\n// failure.",
      "length": 290,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func NewSimpleGraph(g ChannelGraph) (*SimpleGraph, error) {",
      "content": "func NewSimpleGraph(g ChannelGraph) (*SimpleGraph, error) {\n\tnodes := make(map[NodeID]int)\n\tadj := make(map[int][]int)\n\tnextIndex := 0\n\n\t// getNodeIndex returns the integer index of the passed node.\n\t// The returned index is then used to create a simplifed adjacency list\n\t// where each node is identified by its index instead of its pubkey, and\n\t// also to create a mapping from node index to node pubkey.\n\tgetNodeIndex := func(node Node) int {\n\t\tkey := NodeID(node.PubKey())\n\t\tnodeIndex, ok := nodes[key]\n\n\t\tif !ok {\n\t\t\tnodes[key] = nextIndex\n\t\t\tnodeIndex = nextIndex\n\t\t\tnextIndex++\n\t\t}\n\n\t\treturn nodeIndex\n\t}\n\n\t// Iterate over each node and each channel and update the adj and the node\n\t// index.\n\terr := g.ForEachNode(func(node Node) error {\n\t\tu := getNodeIndex(node)\n\n\t\treturn node.ForEachChannel(func(edge ChannelEdge) error {\n\t\t\tv := getNodeIndex(edge.Peer)\n\n\t\t\tadj[u] = append(adj[u], v)\n\t\t\treturn nil\n\t\t})\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tgraph := &SimpleGraph{\n\t\tNodes: make([]NodeID, len(nodes)),\n\t\tAdj:   make([][]int, len(nodes)),\n\t}\n\n\t// Fill the adj and the node index to node pubkey mapping.\n\tfor nodeID, nodeIndex := range nodes {\n\t\tgraph.Adj[nodeIndex] = adj[nodeIndex]\n\t\tgraph.Nodes[nodeIndex] = nodeID\n\t}\n\n\t// We prepare to give some debug output about the size of the graph.\n\ttotalChannels := 0\n\tfor _, channels := range graph.Adj {\n\t\ttotalChannels += len(channels)\n\t}\n\n\t// The number of channels is double counted, so divide by two.\n\tlog.Debugf(\"Initialized simple graph with %d nodes and %d \"+\n\t\t\"channels\", len(graph.Adj), totalChannels/2)\n\treturn graph, nil\n}\n\n// maxVal is a helper function to get the maximal value of all values of a map.",
      "length": 1556,
      "tokens": 245,
      "embedding": []
    },
    {
      "slug": "func maxVal(mapping map[int]uint32) uint32 {",
      "content": "func maxVal(mapping map[int]uint32) uint32 {\n\tmaxValue := uint32(0)\n\tfor _, value := range mapping {\n\t\tif maxValue < value {\n\t\t\tmaxValue = value\n\t\t}\n\t}\n\treturn maxValue\n}\n\n// degree determines the number of edges for a node in the graph.",
      "length": 183,
      "tokens": 36,
      "embedding": []
    },
    {
      "slug": "func (graph *SimpleGraph) degree(node int) int {",
      "content": "func (graph *SimpleGraph) degree(node int) int {\n\treturn len(graph.Adj[node])\n}\n\n// nodeMaxDegree determines the node with the max degree and its degree.",
      "length": 101,
      "tokens": 15,
      "embedding": []
    },
    {
      "slug": "func (graph *SimpleGraph) nodeMaxDegree() (int, int) {",
      "content": "func (graph *SimpleGraph) nodeMaxDegree() (int, int) {\n\tvar maxNode, maxDegree int\n\tfor node := range graph.Adj {\n\t\tdegree := graph.degree(node)\n\t\tif degree > maxDegree {\n\t\t\tmaxNode = node\n\t\t\tmaxDegree = degree\n\t\t}\n\t}\n\treturn maxNode, maxDegree\n}\n\n// shortestPathLengths performs a breadth-first-search from a node to all other\n// nodes, returning the lengths of the paths.",
      "length": 306,
      "tokens": 49,
      "embedding": []
    },
    {
      "slug": "func (graph *SimpleGraph) shortestPathLengths(node int) map[int]uint32 {",
      "content": "func (graph *SimpleGraph) shortestPathLengths(node int) map[int]uint32 {\n\t// level indicates the shell of the search around the root node.\n\tvar level uint32\n\tgraphOrder := len(graph.Adj)\n\n\t// nextLevel tracks which nodes should be visited in the next round.\n\tnextLevel := make([]int, 0, graphOrder)\n\n\t// The root node is put as a starting point for the exploration.\n\tnextLevel = append(nextLevel, node)\n\n\t// Seen tracks already visited nodes and tracks how far away they are.\n\tseen := make(map[int]uint32, graphOrder)\n\n\t// Mark the root node as seen.\n\tseen[node] = level\n\n\t// thisLevel contains the nodes that are explored in the round.\n\tthisLevel := make([]int, 0, graphOrder)\n\n\t// Abort if we have an empty graph.\n\tif len(graph.Adj) == 0 {\n\t\treturn seen\n\t}\n\n\t// We discover other nodes in a ring-like structure as long as we don't\n\t// have more nodes to explore.\n\tfor len(nextLevel) > 0 {\n\t\tlevel++\n\n\t\t// We swap the queues for efficient memory management.\n\t\tthisLevel, nextLevel = nextLevel, thisLevel\n\n\t\t// Visit all neighboring nodes of the level and mark them as\n\t\t// seen if they were not discovered before.\n\t\tfor _, thisNode := range thisLevel {\n\t\t\tfor _, neighbor := range graph.Adj[thisNode] {\n\t\t\t\t_, ok := seen[neighbor]\n\t\t\t\tif !ok {\n\t\t\t\t\tnextLevel = append(nextLevel, neighbor)\n\t\t\t\t\tseen[neighbor] = level\n\t\t\t\t}\n\n\t\t\t\t// If we have seen all nodes, we return early.\n\t\t\t\tif len(seen) == graphOrder {\n\t\t\t\t\treturn seen\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Empty the queue to be used in the next level.\n\t\tthisLevel = thisLevel[:0:cap(thisLevel)]\n\t}\n\n\treturn seen\n}\n\n// nodeEccentricity calculates the eccentricity (longest shortest path to all\n// other nodes) of a node.",
      "length": 1530,
      "tokens": 254,
      "embedding": []
    },
    {
      "slug": "func (graph *SimpleGraph) nodeEccentricity(node int) uint32 {",
      "content": "func (graph *SimpleGraph) nodeEccentricity(node int) uint32 {\n\tpathLengths := graph.shortestPathLengths(node)\n\treturn maxVal(pathLengths)\n}\n\n// nodeEccentricities calculates the eccentricities for the given nodes.",
      "length": 147,
      "tokens": 15,
      "embedding": []
    },
    {
      "slug": "func (graph *SimpleGraph) nodeEccentricities(nodes []int) map[int]uint32 {",
      "content": "func (graph *SimpleGraph) nodeEccentricities(nodes []int) map[int]uint32 {\n\teccentricities := make(map[int]uint32, len(graph.Adj))\n\tfor _, node := range nodes {\n\t\teccentricities[node] = graph.nodeEccentricity(node)\n\t}\n\treturn eccentricities\n}\n\n// Diameter returns the maximal eccentricity (longest shortest path\n// between any node pair) in the graph.\n//\n// Note: This method is exact but expensive, use DiameterRadialCutoff instead.",
      "length": 348,
      "tokens": 47,
      "embedding": []
    },
    {
      "slug": "func (graph *SimpleGraph) Diameter() uint32 {",
      "content": "func (graph *SimpleGraph) Diameter() uint32 {\n\tnodes := make([]int, len(graph.Adj))\n\tfor a := range nodes {\n\t\tnodes[a] = a\n\t}\n\teccentricities := graph.nodeEccentricities(nodes)\n\treturn maxVal(eccentricities)\n}\n\n// DiameterRadialCutoff is a method to efficiently evaluate the diameter of a\n// graph. The highest-degree node is usually central in the graph. We can\n// determine its eccentricity (shortest-longest path length to any other node)\n// and use it as an approximation for the radius of the network. We then\n// use this radius to compute a cutoff. All the nodes within a distance of the\n// cutoff are discarded, as they represent the inside of the graph. We then\n// loop over all outer nodes and determine their eccentricities, from which we\n// get the diameter.",
      "length": 708,
      "tokens": 118,
      "embedding": []
    },
    {
      "slug": "func (graph *SimpleGraph) DiameterRadialCutoff() uint32 {",
      "content": "func (graph *SimpleGraph) DiameterRadialCutoff() uint32 {\n\t// Determine the reference node as the node with the highest degree.\n\tnodeMaxDegree, _ := graph.nodeMaxDegree()\n\n\tdistances := graph.shortestPathLengths(nodeMaxDegree)\n\teccentricityMaxDegreeNode := maxVal(distances)\n\n\t// We use the eccentricity to define a cutoff for the interior of the\n\t// graph from the reference node.\n\tcutoff := uint32(float32(eccentricityMaxDegreeNode) * diameterCutoff)\n\tlog.Debugf(\"Cutoff radius is %d hops (max-degree node's \"+\n\t\t\"eccentricity is %d)\", cutoff, eccentricityMaxDegreeNode)\n\n\t// Remove the nodes that are close to the reference node.\n\tvar nodes []int\n\tfor node, distance := range distances {\n\t\tif distance > cutoff {\n\t\t\tnodes = append(nodes, node)\n\t\t}\n\t}\n\tlog.Debugf(\"Evaluated nodes: %d, discarded nodes %d\",\n\t\tlen(nodes), len(graph.Adj)-len(nodes))\n\n\t// Compute the diameter of the remaining nodes.\n\teccentricities := graph.nodeEccentricities(nodes)\n\treturn maxVal(eccentricities)\n}\n",
      "length": 900,
      "tokens": 114,
      "embedding": []
    }
  ]
}