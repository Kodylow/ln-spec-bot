{
  "filepath": "../implementations/go/lnd/autopilot/agent_constraints_test.go",
  "package": "autopilot",
  "sections": [
    {
      "slug": "func TestConstraintsChannelBudget(t *testing.T) {",
      "content": "func TestConstraintsChannelBudget(t *testing.T) {\n\tt.Parallel()\n\n\tprand.Seed(time.Now().Unix())\n\n\tconst (\n\t\tminChanSize = 0\n\t\tmaxChanSize = btcutil.Amount(btcutil.SatoshiPerBitcoin)\n\n\t\tchanLimit = 3\n\n\t\tthreshold = 0.5\n\t)\n\n\tconstraints := NewConstraints(\n\t\tminChanSize,\n\t\tmaxChanSize,\n\t\tchanLimit,\n\t\t0,\n\t\tthreshold,\n\t)\n\n\trandChanID := func() lnwire.ShortChannelID {\n\t\treturn lnwire.NewShortChanIDFromInt(uint64(prand.Int63()))\n\t}\n\n\ttestCases := []struct {\n\t\tchannels  []LocalChannel\n\t\twalletAmt btcutil.Amount\n\n\t\tneedMore     bool\n\t\tamtAvailable btcutil.Amount\n\t\tnumMore      uint32\n\t}{\n\t\t// Many available funds, but already have too many active open\n\t\t// channels.\n\t\t{\n\t\t\t[]LocalChannel{\n\t\t\t\t{\n\t\t\t\t\tChanID:  randChanID(),\n\t\t\t\t\tBalance: btcutil.Amount(prand.Int31()),\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tChanID:  randChanID(),\n\t\t\t\t\tBalance: btcutil.Amount(prand.Int31()),\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tChanID:  randChanID(),\n\t\t\t\t\tBalance: btcutil.Amount(prand.Int31()),\n\t\t\t\t},\n\t\t\t},\n\t\t\tbtcutil.Amount(btcutil.SatoshiPerBitcoin * 10),\n\t\t\tfalse,\n\t\t\t0,\n\t\t\t0,\n\t\t},\n\n\t\t// Ratio of funds in channels and total funds meets the\n\t\t// threshold.\n\t\t{\n\t\t\t[]LocalChannel{\n\t\t\t\t{\n\t\t\t\t\tChanID:  randChanID(),\n\t\t\t\t\tBalance: btcutil.Amount(btcutil.SatoshiPerBitcoin),\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tChanID:  randChanID(),\n\t\t\t\t\tBalance: btcutil.Amount(btcutil.SatoshiPerBitcoin),\n\t\t\t\t},\n\t\t\t},\n\t\t\tbtcutil.Amount(btcutil.SatoshiPerBitcoin * 2),\n\t\t\tfalse,\n\t\t\t0,\n\t\t\t0,\n\t\t},\n\n\t\t// Ratio of funds in channels and total funds is below the\n\t\t// threshold. We have 10 BTC allocated amongst channels and\n\t\t// funds, atm. We're targeting 50%, so 5 BTC should be\n\t\t// allocated. Only 1 BTC is atm, so 4 BTC should be\n\t\t// recommended. We should also request 2 more channels as the\n\t\t// limit is 3.\n\t\t{\n\t\t\t[]LocalChannel{\n\t\t\t\t{\n\t\t\t\t\tChanID:  randChanID(),\n\t\t\t\t\tBalance: btcutil.Amount(btcutil.SatoshiPerBitcoin),\n\t\t\t\t},\n\t\t\t},\n\t\t\tbtcutil.Amount(btcutil.SatoshiPerBitcoin * 9),\n\t\t\ttrue,\n\t\t\tbtcutil.Amount(btcutil.SatoshiPerBitcoin * 4),\n\t\t\t2,\n\t\t},\n\n\t\t// Ratio of funds in channels and total funds is below the\n\t\t// threshold. We have 14 BTC total amongst the wallet's\n\t\t// balance, and our currently opened channels. Since we're\n\t\t// targeting a 50% allocation, we should commit 7 BTC. The\n\t\t// current channels commit 4 BTC, so we should expected 3 BTC\n\t\t// to be committed. We should only request a single additional\n\t\t// channel as the limit is 3.\n\t\t{\n\t\t\t[]LocalChannel{\n\t\t\t\t{\n\t\t\t\t\tChanID:  randChanID(),\n\t\t\t\t\tBalance: btcutil.Amount(btcutil.SatoshiPerBitcoin),\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tChanID:  randChanID(),\n\t\t\t\t\tBalance: btcutil.Amount(btcutil.SatoshiPerBitcoin * 3),\n\t\t\t\t},\n\t\t\t},\n\t\t\tbtcutil.Amount(btcutil.SatoshiPerBitcoin * 10),\n\t\t\ttrue,\n\t\t\tbtcutil.Amount(btcutil.SatoshiPerBitcoin * 3),\n\t\t\t1,\n\t\t},\n\n\t\t// Ratio of funds in channels and total funds is above the\n\t\t// threshold.\n\t\t{\n\t\t\t[]LocalChannel{\n\t\t\t\t{\n\t\t\t\t\tChanID:  randChanID(),\n\t\t\t\t\tBalance: btcutil.Amount(btcutil.SatoshiPerBitcoin),\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tChanID:  randChanID(),\n\t\t\t\t\tBalance: btcutil.Amount(btcutil.SatoshiPerBitcoin),\n\t\t\t\t},\n\t\t\t},\n\t\t\tbtcutil.Amount(btcutil.SatoshiPerBitcoin),\n\t\t\tfalse,\n\t\t\t0,\n\t\t\t0,\n\t\t},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tamtToAllocate, numMore := constraints.ChannelBudget(\n\t\t\ttestCase.channels, testCase.walletAmt,\n\t\t)\n\n\t\tif amtToAllocate != testCase.amtAvailable {\n\t\t\tt.Fatalf(\"test #%v: expected %v, got %v\",\n\t\t\t\ti, testCase.amtAvailable, amtToAllocate)\n\t\t}\n\t\tif numMore != testCase.numMore {\n\t\t\tt.Fatalf(\"test #%v: expected %v, got %v\",\n\t\t\t\ti, testCase.numMore, numMore)\n\t\t}\n\t}\n}\n",
      "length": 3304,
      "tokens": 382,
      "embedding": []
    }
  ]
}