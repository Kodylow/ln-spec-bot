{
  "filepath": "../implementations/go/lnd/autopilot/graph.go",
  "package": "autopilot",
  "sections": [
    {
      "slug": "type databaseChannelGraph struct {",
      "content": "type databaseChannelGraph struct {\n\tdb *channeldb.ChannelGraph\n}\n\n// A compile time assertion to ensure databaseChannelGraph meets the\n// autopilot.ChannelGraph interface.\nvar _ ChannelGraph = (*databaseChannelGraph)(nil)\n\n// ChannelGraphFromDatabase returns an instance of the autopilot.ChannelGraph\n// backed by a live, open channeldb instance.",
      "length": 303,
      "tokens": 37,
      "embedding": []
    },
    {
      "slug": "func ChannelGraphFromDatabase(db *channeldb.ChannelGraph) ChannelGraph {",
      "content": "func ChannelGraphFromDatabase(db *channeldb.ChannelGraph) ChannelGraph {\n\treturn &databaseChannelGraph{\n\t\tdb: db,\n\t}\n}\n\n// type dbNode is a wrapper struct around a database transaction an\n// channeldb.LightningNode. The wrapper method implement the autopilot.Node\n// interface.",
      "length": 197,
      "tokens": 28,
      "embedding": []
    },
    {
      "slug": "type dbNode struct {",
      "content": "type dbNode struct {\n\ttx kvdb.RTx\n\n\tnode *channeldb.LightningNode\n}\n\n// A compile time assertion to ensure dbNode meets the autopilot.Node\n// interface.\nvar _ Node = (*dbNode)(nil)\n\n// PubKey is the identity public key of the node. This will be used to attempt\n// to target a node for channel opening by the main autopilot agent. The key\n// will be returned in serialized compressed format.\n//\n// NOTE: Part of the autopilot.Node interface.",
      "length": 406,
      "tokens": 70,
      "embedding": []
    },
    {
      "slug": "func (d dbNode) PubKey() [33]byte {",
      "content": "func (d dbNode) PubKey() [33]byte {\n\treturn d.node.PubKeyBytes\n}\n\n// Addrs returns a slice of publicly reachable public TCP addresses that the\n// peer is known to be listening on.\n//\n// NOTE: Part of the autopilot.Node interface.",
      "length": 187,
      "tokens": 32,
      "embedding": []
    },
    {
      "slug": "func (d dbNode) Addrs() []net.Addr {",
      "content": "func (d dbNode) Addrs() []net.Addr {\n\treturn d.node.Addresses\n}\n\n// ForEachChannel is a higher-order function that will be used to iterate\n// through all edges emanating from/to the target node. For each active\n// channel, this function should be called with the populated ChannelEdge that\n// describes the active channel.\n//\n// NOTE: Part of the autopilot.Node interface.",
      "length": 327,
      "tokens": 52,
      "embedding": []
    },
    {
      "slug": "func (d dbNode) ForEachChannel(cb func(ChannelEdge) error) error {",
      "content": "func (d dbNode) ForEachChannel(cb func(ChannelEdge) error) error {\n\treturn d.node.ForEachChannel(d.tx, func(tx kvdb.RTx,\n\t\tei *channeldb.ChannelEdgeInfo, ep, _ *channeldb.ChannelEdgePolicy) error {\n\n\t\t// Skip channels for which no outgoing edge policy is available.\n\t\t//\n\t\t// TODO(joostjager): Ideally the case where channels have a nil\n\t\t// policy should be supported, as autopilot is not looking at\n\t\t// the policies. For now, it is not easily possible to get a\n\t\t// reference to the other end LightningNode object without\n\t\t// retrieving the policy.\n\t\tif ep == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\tedge := ChannelEdge{\n\t\t\tChanID:   lnwire.NewShortChanIDFromInt(ep.ChannelID),\n\t\t\tCapacity: ei.Capacity,\n\t\t\tPeer: dbNode{\n\t\t\t\ttx:   tx,\n\t\t\t\tnode: ep.Node,\n\t\t\t},\n\t\t}\n\n\t\treturn cb(edge)\n\t})\n}\n\n// ForEachNode is a higher-order function that should be called once for each\n// connected node within the channel graph. If the passed callback returns an\n// error, then execution should be terminated.\n//\n// NOTE: Part of the autopilot.ChannelGraph interface.",
      "length": 943,
      "tokens": 138,
      "embedding": []
    },
    {
      "slug": "func (d *databaseChannelGraph) ForEachNode(cb func(Node) error) error {",
      "content": "func (d *databaseChannelGraph) ForEachNode(cb func(Node) error) error {\n\treturn d.db.ForEachNode(func(tx kvdb.RTx, n *channeldb.LightningNode) error {\n\t\t// We'll skip over any node that doesn't have any advertised\n\t\t// addresses. As we won't be able to reach them to actually\n\t\t// open any channels.\n\t\tif len(n.Addresses) == 0 {\n\t\t\treturn nil\n\t\t}\n\n\t\tnode := dbNode{\n\t\t\ttx:   tx,\n\t\t\tnode: n,\n\t\t}\n\t\treturn cb(node)\n\t})\n}\n\n// addRandChannel creates a new channel two target nodes. This function is\n// meant to aide in the generation of random graphs for use within test cases\n// the exercise the autopilot package.",
      "length": 521,
      "tokens": 87,
      "embedding": []
    },
    {
      "slug": "func (d *databaseChannelGraph) addRandChannel(node1, node2 *btcec.PublicKey,",
      "content": "func (d *databaseChannelGraph) addRandChannel(node1, node2 *btcec.PublicKey,\n\tcapacity btcutil.Amount) (*ChannelEdge, *ChannelEdge, error) {\n\n\tfetchNode := func(pub *btcec.PublicKey) (*channeldb.LightningNode, error) {\n\t\tif pub != nil {\n\t\t\tvertex, err := route.NewVertexFromBytes(\n\t\t\t\tpub.SerializeCompressed(),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tdbNode, err := d.db.FetchLightningNode(vertex)\n\t\t\tswitch {\n\t\t\tcase err == channeldb.ErrGraphNodeNotFound:\n\t\t\t\tfallthrough\n\t\t\tcase err == channeldb.ErrGraphNotFound:\n\t\t\t\tgraphNode := &channeldb.LightningNode{\n\t\t\t\t\tHaveNodeAnnouncement: true,\n\t\t\t\t\tAddresses: []net.Addr{\n\t\t\t\t\t\t&net.TCPAddr{\n\t\t\t\t\t\t\tIP: bytes.Repeat([]byte(\"a\"), 16),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tFeatures: lnwire.NewFeatureVector(\n\t\t\t\t\t\tnil, lnwire.Features,\n\t\t\t\t\t),\n\t\t\t\t\tAuthSigBytes: testSig.Serialize(),\n\t\t\t\t}\n\t\t\t\tgraphNode.AddPubKey(pub)\n\t\t\t\tif err := d.db.AddLightningNode(graphNode); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\tcase err != nil:\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn dbNode, nil\n\t\t}\n\n\t\tnodeKey, err := randKey()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdbNode := &channeldb.LightningNode{\n\t\t\tHaveNodeAnnouncement: true,\n\t\t\tAddresses: []net.Addr{\n\t\t\t\t&net.TCPAddr{\n\t\t\t\t\tIP: bytes.Repeat([]byte(\"a\"), 16),\n\t\t\t\t},\n\t\t\t},\n\t\t\tFeatures: lnwire.NewFeatureVector(\n\t\t\t\tnil, lnwire.Features,\n\t\t\t),\n\t\t\tAuthSigBytes: testSig.Serialize(),\n\t\t}\n\t\tdbNode.AddPubKey(nodeKey)\n\t\tif err := d.db.AddLightningNode(dbNode); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn dbNode, nil\n\t}\n\n\tvertex1, err := fetchNode(node1)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvertex2, err := fetchNode(node2)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar lnNode1, lnNode2 *btcec.PublicKey\n\tif bytes.Compare(vertex1.PubKeyBytes[:], vertex2.PubKeyBytes[:]) == -1 {\n\t\tlnNode1, _ = vertex1.PubKey()\n\t\tlnNode2, _ = vertex2.PubKey()\n\t} else {\n\t\tlnNode1, _ = vertex2.PubKey()\n\t\tlnNode2, _ = vertex1.PubKey()\n\t}\n\n\tchanID := randChanID()\n\tedge := &channeldb.ChannelEdgeInfo{\n\t\tChannelID: chanID.ToUint64(),\n\t\tCapacity:  capacity,\n\t}\n\tedge.AddNodeKeys(lnNode1, lnNode2, lnNode1, lnNode2)\n\tif err := d.db.AddChannelEdge(edge); err != nil {\n\t\treturn nil, nil, err\n\t}\n\tedgePolicy := &channeldb.ChannelEdgePolicy{\n\t\tSigBytes:                  testSig.Serialize(),\n\t\tChannelID:                 chanID.ToUint64(),\n\t\tLastUpdate:                time.Now(),\n\t\tTimeLockDelta:             10,\n\t\tMinHTLC:                   1,\n\t\tMaxHTLC:                   lnwire.NewMSatFromSatoshis(capacity),\n\t\tFeeBaseMSat:               10,\n\t\tFeeProportionalMillionths: 10000,\n\t\tMessageFlags:              1,\n\t\tChannelFlags:              0,\n\t}\n\n\tif err := d.db.UpdateEdgePolicy(edgePolicy); err != nil {\n\t\treturn nil, nil, err\n\t}\n\tedgePolicy = &channeldb.ChannelEdgePolicy{\n\t\tSigBytes:                  testSig.Serialize(),\n\t\tChannelID:                 chanID.ToUint64(),\n\t\tLastUpdate:                time.Now(),\n\t\tTimeLockDelta:             10,\n\t\tMinHTLC:                   1,\n\t\tMaxHTLC:                   lnwire.NewMSatFromSatoshis(capacity),\n\t\tFeeBaseMSat:               10,\n\t\tFeeProportionalMillionths: 10000,\n\t\tMessageFlags:              1,\n\t\tChannelFlags:              1,\n\t}\n\tif err := d.db.UpdateEdgePolicy(edgePolicy); err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn &ChannelEdge{\n\t\t\tChanID:   chanID,\n\t\t\tCapacity: capacity,\n\t\t\tPeer: dbNode{\n\t\t\t\tnode: vertex1,\n\t\t\t},\n\t\t},\n\t\t&ChannelEdge{\n\t\t\tChanID:   chanID,\n\t\t\tCapacity: capacity,\n\t\t\tPeer: dbNode{\n\t\t\t\tnode: vertex2,\n\t\t\t},\n\t\t},\n\t\tnil\n}\n",
      "length": 3253,
      "tokens": 330,
      "embedding": []
    },
    {
      "slug": "func (d *databaseChannelGraph) addRandNode() (*btcec.PublicKey, error) {",
      "content": "func (d *databaseChannelGraph) addRandNode() (*btcec.PublicKey, error) {\n\tnodeKey, err := randKey()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdbNode := &channeldb.LightningNode{\n\t\tHaveNodeAnnouncement: true,\n\t\tAddresses: []net.Addr{\n\t\t\t&net.TCPAddr{\n\t\t\t\tIP: bytes.Repeat([]byte(\"a\"), 16),\n\t\t\t},\n\t\t},\n\t\tFeatures: lnwire.NewFeatureVector(\n\t\t\tnil, lnwire.Features,\n\t\t),\n\t\tAuthSigBytes: testSig.Serialize(),\n\t}\n\tdbNode.AddPubKey(nodeKey)\n\tif err := d.db.AddLightningNode(dbNode); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn nodeKey, nil\n\n}\n\n// memChannelGraph is an implementation of the autopilot.ChannelGraph backed by\n// an in-memory graph.",
      "length": 536,
      "tokens": 65,
      "embedding": []
    },
    {
      "slug": "type memChannelGraph struct {",
      "content": "type memChannelGraph struct {\n\tgraph map[NodeID]*memNode\n}\n\n// A compile time assertion to ensure memChannelGraph meets the\n// autopilot.ChannelGraph interface.\nvar _ ChannelGraph = (*memChannelGraph)(nil)\n\n// newMemChannelGraph creates a new blank in-memory channel graph\n// implementation.",
      "length": 253,
      "tokens": 32,
      "embedding": []
    },
    {
      "slug": "func newMemChannelGraph() *memChannelGraph {",
      "content": "func newMemChannelGraph() *memChannelGraph {\n\treturn &memChannelGraph{\n\t\tgraph: make(map[NodeID]*memNode),\n\t}\n}\n\n// ForEachNode is a higher-order function that should be called once for each\n// connected node within the channel graph. If the passed callback returns an\n// error, then execution should be terminated.\n//\n// NOTE: Part of the autopilot.ChannelGraph interface.",
      "length": 319,
      "tokens": 47,
      "embedding": []
    },
    {
      "slug": "func (m memChannelGraph) ForEachNode(cb func(Node) error) error {",
      "content": "func (m memChannelGraph) ForEachNode(cb func(Node) error) error {\n\tfor _, node := range m.graph {\n\t\tif err := cb(node); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// randChanID generates a new random channel ID.",
      "length": 143,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func randChanID() lnwire.ShortChannelID {",
      "content": "func randChanID() lnwire.ShortChannelID {\n\tid := atomic.AddUint64(&chanIDCounter, 1)\n\treturn lnwire.NewShortChanIDFromInt(id)\n}\n\n// randKey returns a random public key.",
      "length": 122,
      "tokens": 14,
      "embedding": []
    },
    {
      "slug": "func randKey() (*btcec.PublicKey, error) {",
      "content": "func randKey() (*btcec.PublicKey, error) {\n\tpriv, err := btcec.NewPrivateKey()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn priv.PubKey(), nil\n}\n\n// addRandChannel creates a new channel two target nodes. This function is\n// meant to aide in the generation of random graphs for use within test cases\n// the exercise the autopilot package.",
      "length": 286,
      "tokens": 50,
      "embedding": []
    },
    {
      "slug": "func (m *memChannelGraph) addRandChannel(node1, node2 *btcec.PublicKey,",
      "content": "func (m *memChannelGraph) addRandChannel(node1, node2 *btcec.PublicKey,\n\tcapacity btcutil.Amount) (*ChannelEdge, *ChannelEdge, error) {\n\n\tvar (\n\t\tvertex1, vertex2 *memNode\n\t\tok               bool\n\t)\n\n\tif node1 != nil {\n\t\tvertex1, ok = m.graph[NewNodeID(node1)]\n\t\tif !ok {\n\t\t\tvertex1 = &memNode{\n\t\t\t\tpub: node1,\n\t\t\t\taddrs: []net.Addr{\n\t\t\t\t\t&net.TCPAddr{\n\t\t\t\t\t\tIP: bytes.Repeat([]byte(\"a\"), 16),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t} else {\n\t\tnewPub, err := randKey()\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\tvertex1 = &memNode{\n\t\t\tpub: newPub,\n\t\t\taddrs: []net.Addr{\n\t\t\t\t&net.TCPAddr{\n\t\t\t\t\tIP: bytes.Repeat([]byte(\"a\"), 16),\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t}\n\n\tif node2 != nil {\n\t\tvertex2, ok = m.graph[NewNodeID(node2)]\n\t\tif !ok {\n\t\t\tvertex2 = &memNode{\n\t\t\t\tpub: node2,\n\t\t\t\taddrs: []net.Addr{\n\t\t\t\t\t&net.TCPAddr{\n\t\t\t\t\t\tIP: bytes.Repeat([]byte(\"a\"), 16),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t} else {\n\t\tnewPub, err := randKey()\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\tvertex2 = &memNode{\n\t\t\tpub: newPub,\n\t\t\taddrs: []net.Addr{\n\t\t\t\t&net.TCPAddr{\n\t\t\t\t\tIP: bytes.Repeat([]byte(\"a\"), 16),\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t}\n\n\tedge1 := ChannelEdge{\n\t\tChanID:   randChanID(),\n\t\tCapacity: capacity,\n\t\tPeer:     vertex2,\n\t}\n\tvertex1.chans = append(vertex1.chans, edge1)\n\n\tedge2 := ChannelEdge{\n\t\tChanID:   randChanID(),\n\t\tCapacity: capacity,\n\t\tPeer:     vertex1,\n\t}\n\tvertex2.chans = append(vertex2.chans, edge2)\n\n\tm.graph[NewNodeID(vertex1.pub)] = vertex1\n\tm.graph[NewNodeID(vertex2.pub)] = vertex2\n\n\treturn &edge1, &edge2, nil\n}\n",
      "length": 1329,
      "tokens": 171,
      "embedding": []
    },
    {
      "slug": "func (m *memChannelGraph) addRandNode() (*btcec.PublicKey, error) {",
      "content": "func (m *memChannelGraph) addRandNode() (*btcec.PublicKey, error) {\n\tnewPub, err := randKey()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvertex := &memNode{\n\t\tpub: newPub,\n\t\taddrs: []net.Addr{\n\t\t\t&net.TCPAddr{\n\t\t\t\tIP: bytes.Repeat([]byte(\"a\"), 16),\n\t\t\t},\n\t\t},\n\t}\n\tm.graph[NewNodeID(newPub)] = vertex\n\n\treturn newPub, nil\n}\n\n// databaseChannelGraphCached wraps a channeldb.ChannelGraph instance with the\n// necessary API to properly implement the autopilot.ChannelGraph interface.",
      "length": 389,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "type databaseChannelGraphCached struct {",
      "content": "type databaseChannelGraphCached struct {\n\tdb *channeldb.ChannelGraph\n}\n\n// A compile time assertion to ensure databaseChannelGraphCached meets the\n// autopilot.ChannelGraph interface.\nvar _ ChannelGraph = (*databaseChannelGraphCached)(nil)\n\n// ChannelGraphFromCachedDatabase returns an instance of the\n// autopilot.ChannelGraph backed by a live, open channeldb instance.",
      "length": 321,
      "tokens": 37,
      "embedding": []
    },
    {
      "slug": "func ChannelGraphFromCachedDatabase(db *channeldb.ChannelGraph) ChannelGraph {",
      "content": "func ChannelGraphFromCachedDatabase(db *channeldb.ChannelGraph) ChannelGraph {\n\treturn &databaseChannelGraphCached{\n\t\tdb: db,\n\t}\n}\n\n// dbNodeCached is a wrapper struct around a database transaction for a\n// channeldb.LightningNode. The wrapper methods implement the autopilot.Node\n// interface.",
      "length": 208,
      "tokens": 28,
      "embedding": []
    },
    {
      "slug": "type dbNodeCached struct {",
      "content": "type dbNodeCached struct {\n\tnode     route.Vertex\n\tchannels map[uint64]*channeldb.DirectedChannel\n}\n\n// A compile time assertion to ensure dbNodeCached meets the autopilot.Node\n// interface.\nvar _ Node = (*dbNodeCached)(nil)\n\n// PubKey is the identity public key of the node.\n//\n// NOTE: Part of the autopilot.Node interface.",
      "length": 288,
      "tokens": 41,
      "embedding": []
    },
    {
      "slug": "func (nc dbNodeCached) PubKey() [33]byte {",
      "content": "func (nc dbNodeCached) PubKey() [33]byte {\n\treturn nc.node\n}\n\n// Addrs returns a slice of publicly reachable public TCP addresses that the\n// peer is known to be listening on.\n//\n// NOTE: Part of the autopilot.Node interface.",
      "length": 176,
      "tokens": 32,
      "embedding": []
    },
    {
      "slug": "func (nc dbNodeCached) Addrs() []net.Addr {",
      "content": "func (nc dbNodeCached) Addrs() []net.Addr {\n\t// TODO: Add addresses to be usable by autopilot.\n\treturn []net.Addr{}\n}\n\n// ForEachChannel is a higher-order function that will be used to iterate\n// through all edges emanating from/to the target node. For each active\n// channel, this function should be called with the populated ChannelEdge that\n// describes the active channel.\n//\n// NOTE: Part of the autopilot.Node interface.",
      "length": 373,
      "tokens": 61,
      "embedding": []
    },
    {
      "slug": "func (nc dbNodeCached) ForEachChannel(cb func(ChannelEdge) error) error {",
      "content": "func (nc dbNodeCached) ForEachChannel(cb func(ChannelEdge) error) error {\n\tfor cid, channel := range nc.channels {\n\t\tedge := ChannelEdge{\n\t\t\tChanID:   lnwire.NewShortChanIDFromInt(cid),\n\t\t\tCapacity: channel.Capacity,\n\t\t\tPeer: dbNodeCached{\n\t\t\t\tnode: channel.OtherNode,\n\t\t\t},\n\t\t}\n\n\t\tif err := cb(edge); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// ForEachNode is a higher-order function that should be called once for each\n// connected node within the channel graph. If the passed callback returns an\n// error, then execution should be terminated.\n//\n// NOTE: Part of the autopilot.ChannelGraph interface.",
      "length": 517,
      "tokens": 76,
      "embedding": []
    },
    {
      "slug": "func (dc *databaseChannelGraphCached) ForEachNode(cb func(Node) error) error {",
      "content": "func (dc *databaseChannelGraphCached) ForEachNode(cb func(Node) error) error {\n\treturn dc.db.ForEachNodeCached(func(n route.Vertex,\n\t\tchannels map[uint64]*channeldb.DirectedChannel) error {\n\n\t\tif len(channels) > 0 {\n\t\t\tnode := dbNodeCached{\n\t\t\t\tnode:     n,\n\t\t\t\tchannels: channels,\n\t\t\t}\n\t\t\treturn cb(node)\n\t\t}\n\t\treturn nil\n\t})\n}\n\n// memNode is a purely in-memory implementation of the autopilot.Node\n// interface.",
      "length": 319,
      "tokens": 39,
      "embedding": []
    },
    {
      "slug": "type memNode struct {",
      "content": "type memNode struct {\n\tpub *btcec.PublicKey\n\n\tchans []ChannelEdge\n\n\taddrs []net.Addr\n}\n\n// A compile time assertion to ensure memNode meets the autopilot.Node\n// interface.\nvar _ Node = (*memNode)(nil)\n\n// PubKey is the identity public key of the node. This will be used to attempt\n// to target a node for channel opening by the main autopilot agent.\n//\n// NOTE: Part of the autopilot.Node interface.",
      "length": 364,
      "tokens": 62,
      "embedding": []
    },
    {
      "slug": "func (m memNode) PubKey() [33]byte {",
      "content": "func (m memNode) PubKey() [33]byte {\n\tvar n [33]byte\n\tcopy(n[:], m.pub.SerializeCompressed())\n\n\treturn n\n}\n\n// Addrs returns a slice of publicly reachable public TCP addresses that the\n// peer is known to be listening on.\n//\n// NOTE: Part of the autopilot.Node interface.",
      "length": 225,
      "tokens": 37,
      "embedding": []
    },
    {
      "slug": "func (m memNode) Addrs() []net.Addr {",
      "content": "func (m memNode) Addrs() []net.Addr {\n\treturn m.addrs\n}\n\n// ForEachChannel is a higher-order function that will be used to iterate\n// through all edges emanating from/to the target node. For each active\n// channel, this function should be called with the populated ChannelEdge that\n// describes the active channel.\n//\n// NOTE: Part of the autopilot.Node interface.",
      "length": 318,
      "tokens": 52,
      "embedding": []
    },
    {
      "slug": "func (m memNode) ForEachChannel(cb func(ChannelEdge) error) error {",
      "content": "func (m memNode) ForEachChannel(cb func(ChannelEdge) error) error {\n\tfor _, channel := range m.chans {\n\t\tif err := cb(channel); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Median returns the median value in the slice of Amounts.",
      "length": 160,
      "tokens": 33,
      "embedding": []
    },
    {
      "slug": "func Median(vals []btcutil.Amount) btcutil.Amount {",
      "content": "func Median(vals []btcutil.Amount) btcutil.Amount {\n\tsort.Slice(vals, func(i, j int) bool {\n\t\treturn vals[i] < vals[j]\n\t})\n\n\tnum := len(vals)\n\tswitch {\n\tcase num == 0:\n\t\treturn 0\n\n\tcase num%2 == 0:\n\t\treturn (vals[num/2-1] + vals[num/2]) / 2\n\n\tdefault:\n\t\treturn vals[num/2]\n\t}\n}\n",
      "length": 210,
      "tokens": 37,
      "embedding": []
    }
  ]
}