{
  "filepath": "../implementations/go/lnd/autopilot/choice.go",
  "package": "autopilot",
  "sections": [
    {
      "slug": "func weightedChoice(w []float64) (int, error) {",
      "content": "func weightedChoice(w []float64) (int, error) {\n\t// Calculate the sum of weights.\n\tvar sum float64\n\tfor _, v := range w {\n\t\tsum += v\n\t}\n\n\tif sum <= 0 {\n\t\treturn 0, ErrNoPositive\n\t}\n\n\t// Pick a random number in the range [0.0, 1.0) and multiply it with\n\t// the sum of weights. Then we'll iterate the weights until the number\n\t// goes below 0. This means that each index is picked with a probability\n\t// equal to their normalized score.\n\t//\n\t// Example:\n\t// Items with scores [1, 5, 2, 2]\n\t// Normalized scores [0.1, 0.5, 0.2, 0.2]\n\t// Imagine they each occupy a \"range\" equal to their normalized score\n\t// in [0, 1.0]:\n\t// [|-0.1-||-----0.5-----||--0.2--||--0.2--|]\n\t// The following loop is now equivalent to \"hitting\" the intervals.\n\tr := rand.Float64() * sum\n\tfor i := range w {\n\t\tr -= w[i]\n\t\tif r <= 0 {\n\t\t\treturn i, nil\n\t\t}\n\t}\n\n\treturn 0, fmt.Errorf(\"unable to make choice\")\n}\n\n// chooseN picks at random min[n, len(s)] nodes if from the NodeScore map, with\n// a probability weighted by their score.",
      "length": 921,
      "tokens": 175,
      "embedding": []
    },
    {
      "slug": "func chooseN(n uint32, s map[NodeID]*NodeScore) (",
      "content": "func chooseN(n uint32, s map[NodeID]*NodeScore) (\n\tmap[NodeID]*NodeScore, error) {\n\n\t// Keep track of the number of nodes not yet chosen, in addition to\n\t// their scores and NodeIDs.\n\trem := len(s)\n\tscores := make([]float64, len(s))\n\tnodeIDs := make([]NodeID, len(s))\n\ti := 0\n\tfor k, v := range s {\n\t\tscores[i] = v.Score\n\t\tnodeIDs[i] = k\n\t\ti++\n\t}\n\n\t// Pick a weighted choice from the remaining nodes as long as there are\n\t// nodes left, and we haven't already picked n.\n\tchosen := make(map[NodeID]*NodeScore)\n\tfor len(chosen) < int(n) && rem > 0 {\n\t\tchoice, err := weightedChoice(scores)\n\t\tif err == ErrNoPositive {\n\t\t\treturn chosen, nil\n\t\t} else if err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tnID := nodeIDs[choice]\n\n\t\tchosen[nID] = s[nID]\n\n\t\t// We set the score of the chosen node to 0, so it won't be\n\t\t// picked the next iteration.\n\t\tscores[choice] = 0\n\t}\n\n\treturn chosen, nil\n}\n",
      "length": 792,
      "tokens": 143,
      "embedding": []
    }
  ]
}