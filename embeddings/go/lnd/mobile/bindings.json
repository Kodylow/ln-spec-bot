{
  "filepath": "../implementations/go/lnd/mobile/bindings.go",
  "package": "lndmobile",
  "sections": [
    {
      "slug": "//go:build mobile",
      "content": "//go:build mobile\n// +build mobile\n\npackage lndmobile\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\t\"sync/atomic\"\n\n\tflags \"github.com/jessevdk/go-flags\"\n\t\"github.com/lightningnetwork/lnd\"\n\t\"github.com/lightningnetwork/lnd/signal\"\n\t\"google.golang.org/grpc\"\n)\n\n// lndStarted will be used atomically to ensure only a single lnd instance is\n// attempted to be started at once.\nvar lndStarted int32\n\n// Start starts lnd in a new goroutine.\n//\n// extraArgs can be used to pass command line arguments to lnd that will\n// override what is found in the config file. Example:\n//\n//\textraArgs = \"--bitcoin.testnet --lnddir=\\\"/tmp/folder name/\\\" --profile=5050\"\n//\n// The rpcReady is called lnd is ready to accept RPC calls.\n//\n// NOTE: On mobile platforms the '--lnddir` argument should be set to the\n// current app directory in order to ensure lnd has the permissions needed to\n// write to it.",
      "length": 832,
      "tokens": 128,
      "embedding": []
    },
    {
      "slug": "func Start(extraArgs string, rpcReady Callback) {",
      "content": "func Start(extraArgs string, rpcReady Callback) {\n\t// We only support a single lnd instance at a time (singleton) for now,\n\t// so we make sure to return immediately if it has already been\n\t// started.\n\tif !atomic.CompareAndSwapInt32(&lndStarted, 0, 1) {\n\t\terr := errors.New(\"lnd already started\")\n\t\trpcReady.OnError(err)\n\t\treturn\n\t}\n\n\t// (Re-)initialize the in-mem gRPC listeners we're going to give to lnd.\n\t// This is required each time lnd is started, because when lnd shuts\n\t// down, the in-mem listeners are closed.\n\tRecreateListeners()\n\n\t// Split the argument string on \"--\" to get separated command line\n\t// arguments.\n\tvar splitArgs []string\n\tfor _, a := range strings.Split(extraArgs, \"--\") {\n\t\t// Trim any whitespace space, and ignore empty params.\n\t\ta := strings.TrimSpace(a)\n\t\tif a == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Finally we prefix any non-empty string with -- to mimic the\n\t\t// regular command line arguments.\n\t\tsplitArgs = append(splitArgs, \"--\"+a)\n\t}\n\n\t// Add the extra arguments to os.Args, as that will be parsed in\n\t// LoadConfig below.\n\tos.Args = append(os.Args, splitArgs...)\n\n\t// Hook interceptor for os signals.\n\tshutdownInterceptor, err := signal.Intercept()\n\tif err != nil {\n\t\tatomic.StoreInt32(&lndStarted, 0)\n\t\t_, _ = fmt.Fprintln(os.Stderr, err)\n\t\trpcReady.OnError(err)\n\t\treturn\n\t}\n\n\t// Load the configuration, and parse the extra arguments as command\n\t// line options. This function will also set up logging properly.\n\tloadedConfig, err := lnd.LoadConfig(shutdownInterceptor)\n\tif err != nil {\n\t\tatomic.StoreInt32(&lndStarted, 0)\n\t\t_, _ = fmt.Fprintln(os.Stderr, err)\n\t\trpcReady.OnError(err)\n\t\treturn\n\t}\n\n\t// Set a channel that will be notified when the RPC server is ready to\n\t// accept calls.\n\tvar (\n\t\trpcListening = make(chan struct{})\n\t\tquit         = make(chan struct{})\n\t)\n\n\t// We call the main method with the custom in-memory listener called by\n\t// the mobile APIs, such that the grpc server will use it.\n\tcfg := lnd.ListenerCfg{\n\t\tRPCListeners: []*lnd.ListenerWithSignal{{\n\t\t\tListener: lightningLis,\n\t\t\tReady:    rpcListening,\n\t\t}},\n\t}\n\timplCfg := loadedConfig.ImplementationConfig(shutdownInterceptor)\n\n\t// Call the \"real\" main in a nested manner so the defers will properly\n\t// be executed in the case of a graceful shutdown.\n\tgo func() {\n\t\tdefer atomic.StoreInt32(&lndStarted, 0)\n\t\tdefer close(quit)\n\n\t\tif err := lnd.Main(\n\t\t\tloadedConfig, cfg, implCfg, shutdownInterceptor,\n\t\t); err != nil {\n\t\t\tif e, ok := err.(*flags.Error); ok &&\n\t\t\t\te.Type == flags.ErrHelp {\n\t\t\t} else {\n\t\t\t\tfmt.Fprintln(os.Stderr, err)\n\t\t\t}\n\t\t\trpcReady.OnError(err)\n\t\t\treturn\n\t\t}\n\t}()\n\n\t// By default we'll apply the admin auth options, which will include\n\t// macaroons.\n\tsetDefaultDialOption(\n\t\tfunc() ([]grpc.DialOption, error) {\n\t\t\treturn lnd.AdminAuthOptions(loadedConfig, false)\n\t\t},\n\t)\n\n\t// For the WalletUnlocker and StateService, the macaroons might not be\n\t// available yet when called, so we use a more restricted set of\n\t// options that don't include them.\n\tsetWalletUnlockerDialOption(\n\t\tfunc() ([]grpc.DialOption, error) {\n\t\t\treturn lnd.AdminAuthOptions(loadedConfig, true)\n\t\t},\n\t)\n\tsetStateDialOption(\n\t\tfunc() ([]grpc.DialOption, error) {\n\t\t\treturn lnd.AdminAuthOptions(loadedConfig, true)\n\t\t},\n\t)\n\n\t// Finally we start a go routine that will call the provided callback\n\t// when the RPC server is ready to accept calls.\n\tgo func() {\n\t\tselect {\n\t\tcase <-rpcListening:\n\t\tcase <-quit:\n\t\t\treturn\n\t\t}\n\n\t\trpcReady.OnResponse([]byte{})\n\t}()\n}\n",
      "length": 3289,
      "tokens": 472,
      "embedding": []
    }
  ]
}