{
  "filepath": "../implementations/go/lnd/chainreg/chainregistry.go",
  "package": "chainreg",
  "sections": [
    {
      "slug": "type Config struct {",
      "content": "type Config struct {\n\t// Bitcoin defines settings for the Bitcoin chain.\n\tBitcoin *lncfg.Chain\n\n\t// Litecoin defines settings for the Litecoin chain.\n\tLitecoin *lncfg.Chain\n\n\t// PrimaryChain is a function that returns our primary chain via its\n\t// ChainCode.\n\tPrimaryChain func() ChainCode\n\n\t// HeightHintCacheQueryDisable is a boolean that disables height hint\n\t// queries if true.\n\tHeightHintCacheQueryDisable bool\n\n\t// NeutrinoMode defines settings for connecting to a neutrino\n\t// light-client.\n\tNeutrinoMode *lncfg.Neutrino\n\n\t// BitcoindMode defines settings for connecting to a bitcoind node.\n\tBitcoindMode *lncfg.Bitcoind\n\n\t// LitecoindMode defines settings for connecting to a litecoind node.\n\tLitecoindMode *lncfg.Bitcoind\n\n\t// BtcdMode defines settings for connecting to a btcd node.\n\tBtcdMode *lncfg.Btcd\n\n\t// LtcdMode defines settings for connecting to an ltcd node.\n\tLtcdMode *lncfg.Btcd\n\n\t// HeightHintDB is a pointer to the database that stores the height\n\t// hints.\n\tHeightHintDB kvdb.Backend\n\n\t// ChanStateDB is a pointer to the database that stores the channel\n\t// state.\n\tChanStateDB *channeldb.ChannelStateDB\n\n\t// BlockCache is the main cache for storing block information.\n\tBlockCache *blockcache.BlockCache\n\n\t// WalletUnlockParams are the parameters that were used for unlocking\n\t// the main wallet.\n\tWalletUnlockParams *walletunlocker.WalletUnlockParams\n\n\t// NeutrinoCS is a pointer to a neutrino ChainService. Must be non-nil\n\t// if using neutrino.\n\tNeutrinoCS *neutrino.ChainService\n\n\t// ActiveNetParams details the current chain we are on.\n\tActiveNetParams BitcoinNetParams\n\n\t// FeeURL defines the URL for fee estimation we will use. This field is\n\t// optional.\n\tFeeURL string\n\n\t// Dialer is a function closure that will be used to establish outbound\n\t// TCP connections to Bitcoin peers in the event of a pruned block being\n\t// requested.\n\tDialer chain.Dialer\n}\n\nconst (\n\t// DefaultBitcoinMinHTLCInMSat is the default smallest value htlc this\n\t// node will accept. This value is proposed in the channel open sequence\n\t// and cannot be changed during the life of the channel. It is 1 msat by\n\t// default to allow maximum flexibility in deciding what size payments\n\t// to forward.\n\t//\n\t// All forwarded payments are subjected to the min htlc constraint of\n\t// the routing policy of the outgoing channel. This implicitly controls\n\t// the minimum htlc value on the incoming channel too.\n\tDefaultBitcoinMinHTLCInMSat = lnwire.MilliSatoshi(1)\n\n\t// DefaultBitcoinMinHTLCOutMSat is the default minimum htlc value that\n\t// we require for sending out htlcs. Our channel peer may have a lower\n\t// min htlc channel parameter, but we - by default - don't forward\n\t// anything under the value defined here.\n\tDefaultBitcoinMinHTLCOutMSat = lnwire.MilliSatoshi(1000)\n\n\t// DefaultBitcoinBaseFeeMSat is the default forwarding base fee.\n\tDefaultBitcoinBaseFeeMSat = lnwire.MilliSatoshi(1000)\n\n\t// DefaultBitcoinFeeRate is the default forwarding fee rate.\n\tDefaultBitcoinFeeRate = lnwire.MilliSatoshi(1)\n\n\t// DefaultBitcoinTimeLockDelta is the default forwarding time lock\n\t// delta.\n\tDefaultBitcoinTimeLockDelta = 40\n\n\tDefaultLitecoinMinHTLCInMSat  = lnwire.MilliSatoshi(1)\n\tDefaultLitecoinMinHTLCOutMSat = lnwire.MilliSatoshi(1000)\n\tDefaultLitecoinBaseFeeMSat    = lnwire.MilliSatoshi(1000)\n\tDefaultLitecoinFeeRate        = lnwire.MilliSatoshi(1)\n\tDefaultLitecoinTimeLockDelta  = 576\n\tDefaultLitecoinDustLimit      = btcutil.Amount(54600)\n\n\t// DefaultBitcoinStaticFeePerKW is the fee rate of 50 sat/vbyte\n\t// expressed in sat/kw.\n\tDefaultBitcoinStaticFeePerKW = chainfee.SatPerKWeight(12500)\n\n\t// DefaultBitcoinStaticMinRelayFeeRate is the min relay fee used for\n\t// static estimators.\n\tDefaultBitcoinStaticMinRelayFeeRate = chainfee.FeePerKwFloor\n\n\t// DefaultLitecoinStaticFeePerKW is the fee rate of 200 sat/vbyte\n\t// expressed in sat/kw.\n\tDefaultLitecoinStaticFeePerKW = chainfee.SatPerKWeight(50000)\n\n\t// BtcToLtcConversionRate is a fixed ratio used in order to scale up\n\t// payments when running on the Litecoin chain.\n\tBtcToLtcConversionRate = 60\n)\n\n// DefaultLtcChannelConstraints is the default set of channel constraints that\n// are meant to be used when initially funding a Litecoin channel.\nvar DefaultLtcChannelConstraints = channeldb.ChannelConstraints{\n\tDustLimit:        DefaultLitecoinDustLimit,\n\tMaxAcceptedHtlcs: input.MaxHTLCNumber / 2,\n}\n\n// PartialChainControl contains all the primary interfaces of the chain control\n// that can be purely constructed from the global configuration. No wallet\n// instance is required for constructing this partial state.",
      "length": 4439,
      "tokens": 578,
      "embedding": []
    },
    {
      "slug": "type PartialChainControl struct {",
      "content": "type PartialChainControl struct {\n\t// Cfg is the configuration that was used to create the partial chain\n\t// control.\n\tCfg *Config\n\n\t// HealthCheck is a function which can be used to send a low-cost, fast\n\t// query to the chain backend to ensure we still have access to our\n\t// node.\n\tHealthCheck func() error\n\n\t// FeeEstimator is used to estimate an optimal fee for transactions\n\t// important to us.\n\tFeeEstimator chainfee.Estimator\n\n\t// ChainNotifier is used to receive blockchain events that we are\n\t// interested in.\n\tChainNotifier chainntnfs.ChainNotifier\n\n\t// ChainView is used in the router for maintaining an up-to-date graph.\n\tChainView chainview.FilteredChainView\n\n\t// ChainSource is the primary chain interface. This is used to operate\n\t// the wallet and do things such as rescanning, sending transactions,\n\t// notifications for received funds, etc.\n\tChainSource chain.Interface\n\n\t// RoutingPolicy is the routing policy we have decided to use.\n\tRoutingPolicy htlcswitch.ForwardingPolicy\n\n\t// MinHtlcIn is the minimum HTLC we will accept.\n\tMinHtlcIn lnwire.MilliSatoshi\n\n\t// ChannelConstraints is the set of default constraints that will be\n\t// used for any incoming or outgoing channel reservation requests.\n\tChannelConstraints channeldb.ChannelConstraints\n}\n\n// ChainControl couples the three primary interfaces lnd utilizes for a\n// particular chain together. A single ChainControl instance will exist for all\n// the chains lnd is currently active on.",
      "length": 1392,
      "tokens": 207,
      "embedding": []
    },
    {
      "slug": "type ChainControl struct {",
      "content": "type ChainControl struct {\n\t// PartialChainControl is the part of the chain control that was\n\t// initialized purely from the configuration and doesn't contain any\n\t// wallet related elements.\n\t*PartialChainControl\n\n\t// ChainIO represents an abstraction over a source that can query the\n\t// blockchain.\n\tChainIO lnwallet.BlockChainIO\n\n\t// Signer is used to provide signatures over things like transactions.\n\tSigner input.Signer\n\n\t// KeyRing represents a set of keys that we have the private keys to.\n\tKeyRing keychain.SecretKeyRing\n\n\t// Wc is an abstraction over some basic wallet commands. This base set\n\t// of commands will be provided to the Wallet *LightningWallet raw\n\t// pointer below.\n\tWc lnwallet.WalletController\n\n\t// MsgSigner is used to sign arbitrary messages.\n\tMsgSigner lnwallet.MessageSigner\n\n\t// Wallet is our LightningWallet that also contains the abstract Wc\n\t// above. This wallet handles all of the lightning operations.\n\tWallet *lnwallet.LightningWallet\n}\n\n// GenDefaultBtcConstraints generates the default set of channel constraints\n// that are to be used when funding a Bitcoin channel.",
      "length": 1052,
      "tokens": 154,
      "embedding": []
    },
    {
      "slug": "func GenDefaultBtcConstraints() channeldb.ChannelConstraints {",
      "content": "func GenDefaultBtcConstraints() channeldb.ChannelConstraints {\n\t// We use the dust limit for the maximally sized witness program with\n\t// a 40-byte data push.\n\tdustLimit := lnwallet.DustLimitForSize(input.UnknownWitnessSize)\n\n\treturn channeldb.ChannelConstraints{\n\t\tDustLimit:        dustLimit,\n\t\tMaxAcceptedHtlcs: input.MaxHTLCNumber / 2,\n\t}\n}\n\n// NewPartialChainControl creates a new partial chain control that contains all\n// the parts that can be purely constructed from the passed in global\n// configuration and doesn't need any wallet instance yet.",
      "length": 479,
      "tokens": 64,
      "embedding": []
    },
    {
      "slug": "func NewPartialChainControl(cfg *Config) (*PartialChainControl, func(), error) {",
      "content": "func NewPartialChainControl(cfg *Config) (*PartialChainControl, func(), error) {\n\t// Set the RPC config from the \"home\" chain. Multi-chain isn't yet\n\t// active, so we'll restrict usage to a particular chain for now.\n\thomeChainConfig := cfg.Bitcoin\n\tif cfg.PrimaryChain() == LitecoinChain {\n\t\thomeChainConfig = cfg.Litecoin\n\t}\n\tlog.Infof(\"Primary chain is set to: %v\", cfg.PrimaryChain())\n\n\tcc := &PartialChainControl{\n\t\tCfg: cfg,\n\t}\n\n\tswitch cfg.PrimaryChain() {\n\tcase BitcoinChain:\n\t\tcc.RoutingPolicy = htlcswitch.ForwardingPolicy{\n\t\t\tMinHTLCOut:    cfg.Bitcoin.MinHTLCOut,\n\t\t\tBaseFee:       cfg.Bitcoin.BaseFee,\n\t\t\tFeeRate:       cfg.Bitcoin.FeeRate,\n\t\t\tTimeLockDelta: cfg.Bitcoin.TimeLockDelta,\n\t\t}\n\t\tcc.MinHtlcIn = cfg.Bitcoin.MinHTLCIn\n\t\tcc.FeeEstimator = chainfee.NewStaticEstimator(\n\t\t\tDefaultBitcoinStaticFeePerKW,\n\t\t\tDefaultBitcoinStaticMinRelayFeeRate,\n\t\t)\n\tcase LitecoinChain:\n\t\tcc.RoutingPolicy = htlcswitch.ForwardingPolicy{\n\t\t\tMinHTLCOut:    cfg.Litecoin.MinHTLCOut,\n\t\t\tBaseFee:       cfg.Litecoin.BaseFee,\n\t\t\tFeeRate:       cfg.Litecoin.FeeRate,\n\t\t\tTimeLockDelta: cfg.Litecoin.TimeLockDelta,\n\t\t}\n\t\tcc.MinHtlcIn = cfg.Litecoin.MinHTLCIn\n\t\tcc.FeeEstimator = chainfee.NewStaticEstimator(\n\t\t\tDefaultLitecoinStaticFeePerKW, 0,\n\t\t)\n\tdefault:\n\t\treturn nil, nil, fmt.Errorf(\"default routing policy for chain \"+\n\t\t\t\"%v is unknown\", cfg.PrimaryChain())\n\t}\n\n\tvar err error\n\theightHintCacheConfig := channeldb.CacheConfig{\n\t\tQueryDisable: cfg.HeightHintCacheQueryDisable,\n\t}\n\tif cfg.HeightHintCacheQueryDisable {\n\t\tlog.Infof(\"Height Hint Cache Queries disabled\")\n\t}\n\n\t// Initialize the height hint cache within the chain directory.\n\thintCache, err := channeldb.NewHeightHintCache(\n\t\theightHintCacheConfig, cfg.HeightHintDB,\n\t)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"unable to initialize height hint \"+\n\t\t\t\"cache: %v\", err)\n\t}\n\n\t// If spv mode is active, then we'll be using a distinct set of\n\t// chainControl interfaces that interface directly with the p2p network\n\t// of the selected chain.\n\tswitch homeChainConfig.Node {\n\tcase \"neutrino\":\n\t\t// We'll create ChainNotifier and FilteredChainView instances,\n\t\t// along with the wallet's ChainSource, which are all backed by\n\t\t// the neutrino light client.\n\t\tcc.ChainNotifier = neutrinonotify.New(\n\t\t\tcfg.NeutrinoCS, hintCache, hintCache, cfg.BlockCache,\n\t\t)\n\t\tcc.ChainView, err = chainview.NewCfFilteredChainView(\n\t\t\tcfg.NeutrinoCS, cfg.BlockCache,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\n\t\t// Map the deprecated neutrino feeurl flag to the general fee\n\t\t// url.\n\t\tif cfg.NeutrinoMode.FeeURL != \"\" {\n\t\t\tif cfg.FeeURL != \"\" {\n\t\t\t\treturn nil, nil, errors.New(\"feeurl and \" +\n\t\t\t\t\t\"neutrino.feeurl are mutually \" +\n\t\t\t\t\t\"exclusive\")\n\t\t\t}\n\n\t\t\tcfg.FeeURL = cfg.NeutrinoMode.FeeURL\n\t\t}\n\n\t\tcc.ChainSource = chain.NewNeutrinoClient(\n\t\t\tcfg.ActiveNetParams.Params, cfg.NeutrinoCS,\n\t\t)\n\n\t\t// Get our best block as a health check.\n\t\tcc.HealthCheck = func() error {\n\t\t\t_, _, err := cc.ChainSource.GetBestBlock()\n\t\t\treturn err\n\t\t}\n\n\tcase \"bitcoind\", \"litecoind\":\n\t\tvar bitcoindMode *lncfg.Bitcoind\n\t\tswitch {\n\t\tcase cfg.Bitcoin.Active:\n\t\t\tbitcoindMode = cfg.BitcoindMode\n\t\tcase cfg.Litecoin.Active:\n\t\t\tbitcoindMode = cfg.LitecoindMode\n\t\t}\n\t\t// Otherwise, we'll be speaking directly via RPC and ZMQ to a\n\t\t// bitcoind node. If the specified host for the btcd/ltcd RPC\n\t\t// server already has a port specified, then we use that\n\t\t// directly. Otherwise, we assume the default port according to\n\t\t// the selected chain parameters.\n\t\tvar bitcoindHost string\n\t\tif strings.Contains(bitcoindMode.RPCHost, \":\") {\n\t\t\tbitcoindHost = bitcoindMode.RPCHost\n\t\t} else {\n\t\t\t// The RPC ports specified in chainparams.go assume\n\t\t\t// btcd, which picks a different port so that btcwallet\n\t\t\t// can use the same RPC port as bitcoind. We convert\n\t\t\t// this back to the btcwallet/bitcoind port.\n\t\t\trpcPort, err := strconv.Atoi(cfg.ActiveNetParams.RPCPort)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t\trpcPort -= 2\n\t\t\tbitcoindHost = fmt.Sprintf(\"%v:%d\",\n\t\t\t\tbitcoindMode.RPCHost, rpcPort)\n\t\t\tif (cfg.Bitcoin.Active &&\n\t\t\t\t(cfg.Bitcoin.RegTest || cfg.Bitcoin.SigNet)) ||\n\t\t\t\t(cfg.Litecoin.Active && cfg.Litecoin.RegTest) {\n\n\t\t\t\tconn, err := net.Dial(\"tcp\", bitcoindHost)\n\t\t\t\tif err != nil || conn == nil {\n\t\t\t\t\tswitch {\n\t\t\t\t\tcase cfg.Bitcoin.Active && cfg.Bitcoin.RegTest:\n\t\t\t\t\t\trpcPort = 18443\n\t\t\t\t\tcase cfg.Litecoin.Active && cfg.Litecoin.RegTest:\n\t\t\t\t\t\trpcPort = 19443\n\t\t\t\t\tcase cfg.Bitcoin.Active && cfg.Bitcoin.SigNet:\n\t\t\t\t\t\trpcPort = 38332\n\t\t\t\t\t}\n\t\t\t\t\tbitcoindHost = fmt.Sprintf(\"%v:%d\",\n\t\t\t\t\t\tbitcoindMode.RPCHost,\n\t\t\t\t\t\trpcPort)\n\t\t\t\t} else {\n\t\t\t\t\tconn.Close()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbitcoindCfg := &chain.BitcoindConfig{\n\t\t\tChainParams:        cfg.ActiveNetParams.Params,\n\t\t\tHost:               bitcoindHost,\n\t\t\tUser:               bitcoindMode.RPCUser,\n\t\t\tPass:               bitcoindMode.RPCPass,\n\t\t\tDialer:             cfg.Dialer,\n\t\t\tPrunedModeMaxPeers: bitcoindMode.PrunedNodeMaxPeers,\n\t\t}\n\n\t\tif bitcoindMode.RPCPolling {\n\t\t\tbitcoindCfg.PollingConfig = &chain.PollingConfig{\n\t\t\t\tBlockPollingInterval: bitcoindMode.BlockPollingInterval,\n\t\t\t\tTxPollingInterval:    bitcoindMode.TxPollingInterval,\n\t\t\t}\n\t\t} else {\n\t\t\tbitcoindCfg.ZMQConfig = &chain.ZMQConfig{\n\t\t\t\tZMQBlockHost:    bitcoindMode.ZMQPubRawBlock,\n\t\t\t\tZMQTxHost:       bitcoindMode.ZMQPubRawTx,\n\t\t\t\tZMQReadDeadline: bitcoindMode.ZMQReadDeadline,\n\t\t\t}\n\t\t}\n\n\t\t// Establish the connection to bitcoind and create the clients\n\t\t// required for our relevant subsystems.\n\t\tbitcoindConn, err := chain.NewBitcoindConn(bitcoindCfg)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\n\t\tif err := bitcoindConn.Start(); err != nil {\n\t\t\treturn nil, nil, fmt.Errorf(\"unable to connect to \"+\n\t\t\t\t\"bitcoind: %v\", err)\n\t\t}\n\n\t\tcc.ChainNotifier = bitcoindnotify.New(\n\t\t\tbitcoindConn, cfg.ActiveNetParams.Params, hintCache,\n\t\t\thintCache, cfg.BlockCache,\n\t\t)\n\t\tcc.ChainView = chainview.NewBitcoindFilteredChainView(\n\t\t\tbitcoindConn, cfg.BlockCache,\n\t\t)\n\t\tcc.ChainSource = bitcoindConn.NewBitcoindClient()\n\n\t\t// If we're not in regtest mode, then we'll attempt to use a\n\t\t// proper fee estimator for testnet.\n\t\trpcConfig := &rpcclient.ConnConfig{\n\t\t\tHost:                 bitcoindHost,\n\t\t\tUser:                 bitcoindMode.RPCUser,\n\t\t\tPass:                 bitcoindMode.RPCPass,\n\t\t\tDisableConnectOnNew:  true,\n\t\t\tDisableAutoReconnect: false,\n\t\t\tDisableTLS:           true,\n\t\t\tHTTPPostMode:         true,\n\t\t}\n\t\tif cfg.Bitcoin.Active && !cfg.Bitcoin.RegTest {\n\t\t\tlog.Infof(\"Initializing bitcoind backed fee estimator \"+\n\t\t\t\t\"in %s mode\", bitcoindMode.EstimateMode)\n\n\t\t\t// Finally, we'll re-initialize the fee estimator, as\n\t\t\t// if we're using bitcoind as a backend, then we can\n\t\t\t// use live fee estimates, rather than a statically\n\t\t\t// coded value.\n\t\t\tfallBackFeeRate := chainfee.SatPerKVByte(25 * 1000)\n\t\t\tcc.FeeEstimator, err = chainfee.NewBitcoindEstimator(\n\t\t\t\t*rpcConfig, bitcoindMode.EstimateMode,\n\t\t\t\tfallBackFeeRate.FeePerKWeight(),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t} else if cfg.Litecoin.Active && !cfg.Litecoin.RegTest {\n\t\t\tlog.Infof(\"Initializing litecoind backed fee \"+\n\t\t\t\t\"estimator in %s mode\",\n\t\t\t\tbitcoindMode.EstimateMode)\n\n\t\t\t// Finally, we'll re-initialize the fee estimator, as\n\t\t\t// if we're using litecoind as a backend, then we can\n\t\t\t// use live fee estimates, rather than a statically\n\t\t\t// coded value.\n\t\t\tfallBackFeeRate := chainfee.SatPerKVByte(25 * 1000)\n\t\t\tcc.FeeEstimator, err = chainfee.NewBitcoindEstimator(\n\t\t\t\t*rpcConfig, bitcoindMode.EstimateMode,\n\t\t\t\tfallBackFeeRate.FeePerKWeight(),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t}\n\n\t\t// We need to use some apis that are not exposed by btcwallet,\n\t\t// for a health check function so we create an ad-hoc bitcoind\n\t\t// connection.\n\t\tchainConn, err := rpcclient.New(rpcConfig, nil)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\n\t\t// Before we continue any further, we'll ensure that the\n\t\t// backend understands Taproot. If not, then all the default\n\t\t// features can't be used.\n\t\tif !backendSupportsTaproot(chainConn) {\n\t\t\treturn nil, nil, fmt.Errorf(\"node backend does not \" +\n\t\t\t\t\"support taproot\")\n\t\t}\n\n\t\t// The api we will use for our health check depends on the\n\t\t// bitcoind version.\n\t\tcmd, ver, err := getBitcoindHealthCheckCmd(chainConn)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\n\t\t// If the getzmqnotifications api is available (was added in\n\t\t// version 0.17.0) we make sure lnd subscribes to the correct\n\t\t// zmq events. We do this to avoid a situation in which we are\n\t\t// not notified of new transactions or blocks.\n\t\tif ver >= 170000 && !bitcoindMode.RPCPolling {\n\t\t\tzmqPubRawBlockURL, err := url.Parse(bitcoindMode.ZMQPubRawBlock)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t\tzmqPubRawTxURL, err := url.Parse(bitcoindMode.ZMQPubRawTx)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\n\t\t\t// Fetch all active zmq notifications from the bitcoind client.\n\t\t\tresp, err := chainConn.RawRequest(\"getzmqnotifications\", nil)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\n\t\t\tzmq := []struct {\n\t\t\t\tType    string `json:\"type\"`\n\t\t\t\tAddress string `json:\"address\"`\n\t\t\t}{}\n\n\t\t\tif err = json.Unmarshal([]byte(resp), &zmq); err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\n\t\t\tpubRawBlockActive := false\n\t\t\tpubRawTxActive := false\n\n\t\t\tfor i := range zmq {\n\t\t\t\tif zmq[i].Type == \"pubrawblock\" {\n\t\t\t\t\turl, err := url.Parse(zmq[i].Address)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, nil, err\n\t\t\t\t\t}\n\t\t\t\t\tif url.Port() != zmqPubRawBlockURL.Port() {\n\t\t\t\t\t\tlog.Warnf(\n\t\t\t\t\t\t\t\"unable to subscribe to zmq block events on \"+\n\t\t\t\t\t\t\t\t\"%s (bitcoind is running on %s)\",\n\t\t\t\t\t\t\tzmqPubRawBlockURL.Host,\n\t\t\t\t\t\t\turl.Host,\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\tpubRawBlockActive = true\n\t\t\t\t}\n\t\t\t\tif zmq[i].Type == \"pubrawtx\" {\n\t\t\t\t\turl, err := url.Parse(zmq[i].Address)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, nil, err\n\t\t\t\t\t}\n\t\t\t\t\tif url.Port() != zmqPubRawTxURL.Port() {\n\t\t\t\t\t\tlog.Warnf(\n\t\t\t\t\t\t\t\"unable to subscribe to zmq tx events on \"+\n\t\t\t\t\t\t\t\t\"%s (bitcoind is running on %s)\",\n\t\t\t\t\t\t\tzmqPubRawTxURL.Host,\n\t\t\t\t\t\t\turl.Host,\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\tpubRawTxActive = true\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Return an error if raw tx or raw block notification over\n\t\t\t// zmq is inactive.\n\t\t\tif !pubRawBlockActive {\n\t\t\t\treturn nil, nil, errors.New(\n\t\t\t\t\t\"block notification over zmq is inactive on \" +\n\t\t\t\t\t\t\"bitcoind\",\n\t\t\t\t)\n\t\t\t}\n\t\t\tif !pubRawTxActive {\n\t\t\t\treturn nil, nil, errors.New(\n\t\t\t\t\t\"tx notification over zmq is inactive on \" +\n\t\t\t\t\t\t\"bitcoind\",\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\n\t\tcc.HealthCheck = func() error {\n\t\t\t_, err := chainConn.RawRequest(cmd, nil)\n\t\t\treturn err\n\t\t}\n\n\tcase \"btcd\", \"ltcd\":\n\t\t// Otherwise, we'll be speaking directly via RPC to a node.\n\t\t//\n\t\t// So first we'll load btcd/ltcd's TLS cert for the RPC\n\t\t// connection. If a raw cert was specified in the config, then\n\t\t// we'll set that directly. Otherwise, we attempt to read the\n\t\t// cert from the path specified in the config.\n\t\tvar btcdMode *lncfg.Btcd\n\t\tswitch {\n\t\tcase cfg.Bitcoin.Active:\n\t\t\tbtcdMode = cfg.BtcdMode\n\t\tcase cfg.Litecoin.Active:\n\t\t\tbtcdMode = cfg.LtcdMode\n\t\t}\n\t\tvar rpcCert []byte\n\t\tif btcdMode.RawRPCCert != \"\" {\n\t\t\trpcCert, err = hex.DecodeString(btcdMode.RawRPCCert)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t} else {\n\t\t\tcertFile, err := os.Open(btcdMode.RPCCert)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t\trpcCert, err = ioutil.ReadAll(certFile)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t\tif err := certFile.Close(); err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t}\n\n\t\t// If the specified host for the btcd/ltcd RPC server already\n\t\t// has a port specified, then we use that directly. Otherwise,\n\t\t// we assume the default port according to the selected chain\n\t\t// parameters.\n\t\tvar btcdHost string\n\t\tif strings.Contains(btcdMode.RPCHost, \":\") {\n\t\t\tbtcdHost = btcdMode.RPCHost\n\t\t} else {\n\t\t\tbtcdHost = fmt.Sprintf(\"%v:%v\", btcdMode.RPCHost,\n\t\t\t\tcfg.ActiveNetParams.RPCPort)\n\t\t}\n\n\t\tbtcdUser := btcdMode.RPCUser\n\t\tbtcdPass := btcdMode.RPCPass\n\t\trpcConfig := &rpcclient.ConnConfig{\n\t\t\tHost:                 btcdHost,\n\t\t\tEndpoint:             \"ws\",\n\t\t\tUser:                 btcdUser,\n\t\t\tPass:                 btcdPass,\n\t\t\tCertificates:         rpcCert,\n\t\t\tDisableTLS:           false,\n\t\t\tDisableConnectOnNew:  true,\n\t\t\tDisableAutoReconnect: false,\n\t\t}\n\t\tcc.ChainNotifier, err = btcdnotify.New(\n\t\t\trpcConfig, cfg.ActiveNetParams.Params, hintCache,\n\t\t\thintCache, cfg.BlockCache,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\n\t\t// Finally, we'll create an instance of the default chain view\n\t\t// to be used within the routing layer.\n\t\tcc.ChainView, err = chainview.NewBtcdFilteredChainView(\n\t\t\t*rpcConfig, cfg.BlockCache,\n\t\t)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"unable to create chain view: %v\", err)\n\t\t\treturn nil, nil, err\n\t\t}\n\n\t\t// Create a special websockets rpc client for btcd which will be\n\t\t// used by the wallet for notifications, calls, etc.\n\t\tchainRPC, err := chain.NewRPCClient(\n\t\t\tcfg.ActiveNetParams.Params, btcdHost, btcdUser,\n\t\t\tbtcdPass, rpcCert, false, 20,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\n\t\t// Before we continue any further, we'll ensure that the\n\t\t// backend understands Taproot. If not, then all the default\n\t\t// features can't be used.\n\t\trestConfCopy := *rpcConfig\n\t\trestConfCopy.Endpoint = \"\"\n\t\trestConfCopy.HTTPPostMode = true\n\t\tchainConn, err := rpcclient.New(&restConfCopy, nil)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\tif !backendSupportsTaproot(chainConn) {\n\t\t\treturn nil, nil, fmt.Errorf(\"node backend does not \" +\n\t\t\t\t\"support taproot\")\n\t\t}\n\n\t\tcc.ChainSource = chainRPC\n\n\t\t// Use a query for our best block as a health check.\n\t\tcc.HealthCheck = func() error {\n\t\t\t_, _, err := cc.ChainSource.GetBestBlock()\n\t\t\treturn err\n\t\t}\n\n\t\t// If we're not in simnet or regtest mode, then we'll attempt\n\t\t// to use a proper fee estimator for testnet.\n\t\tif !cfg.Bitcoin.SimNet && !cfg.Litecoin.SimNet &&\n\t\t\t!cfg.Bitcoin.RegTest && !cfg.Litecoin.RegTest {\n\n\t\t\tlog.Info(\"Initializing btcd backed fee estimator\")\n\n\t\t\t// Finally, we'll re-initialize the fee estimator, as\n\t\t\t// if we're using btcd as a backend, then we can use\n\t\t\t// live fee estimates, rather than a statically coded\n\t\t\t// value.\n\t\t\tfallBackFeeRate := chainfee.SatPerKVByte(25 * 1000)\n\t\t\tcc.FeeEstimator, err = chainfee.NewBtcdEstimator(\n\t\t\t\t*rpcConfig, fallBackFeeRate.FeePerKWeight(),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t}\n\n\tcase \"nochainbackend\":\n\t\tbackend := &NoChainBackend{}\n\t\tsource := &NoChainSource{\n\t\t\tBestBlockTime: time.Now(),\n\t\t}\n\n\t\tcc.ChainNotifier = backend\n\t\tcc.ChainView = backend\n\t\tcc.FeeEstimator = backend\n\n\t\tcc.ChainSource = source\n\t\tcc.HealthCheck = func() error {\n\t\t\treturn nil\n\t\t}\n\n\tdefault:\n\t\treturn nil, nil, fmt.Errorf(\"unknown node type: %s\",\n\t\t\thomeChainConfig.Node)\n\t}\n\n\tswitch {\n\t// If the fee URL isn't set, and the user is running mainnet, then\n\t// we'll return an error to instruct them to set a proper fee\n\t// estimator.\n\tcase cfg.FeeURL == \"\" && cfg.Bitcoin.MainNet &&\n\t\thomeChainConfig.Node == \"neutrino\":\n\n\t\treturn nil, nil, fmt.Errorf(\"--feeurl parameter required \" +\n\t\t\t\"when running neutrino on mainnet\")\n\n\t// Override default fee estimator if an external service is specified.\n\tcase cfg.FeeURL != \"\":\n\t\t// Do not cache fees on regtest to make it easier to execute\n\t\t// manual or automated test cases.\n\t\tcacheFees := !cfg.Bitcoin.RegTest\n\n\t\tlog.Infof(\"Using external fee estimator %v: cached=%v\",\n\t\t\tcfg.FeeURL, cacheFees)\n\n\t\tcc.FeeEstimator = chainfee.NewWebAPIEstimator(\n\t\t\tchainfee.SparseConfFeeSource{\n\t\t\t\tURL: cfg.FeeURL,\n\t\t\t},\n\t\t\t!cacheFees,\n\t\t)\n\t}\n\n\tccCleanup := func() {\n\t\tif cc.FeeEstimator != nil {\n\t\t\tif err := cc.FeeEstimator.Stop(); err != nil {\n\t\t\t\tlog.Errorf(\"Failed to stop feeEstimator: %v\",\n\t\t\t\t\terr)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Start fee estimator.\n\tif err := cc.FeeEstimator.Start(); err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// Select the default channel constraints for the primary chain.\n\tcc.ChannelConstraints = GenDefaultBtcConstraints()\n\tif cfg.PrimaryChain() == LitecoinChain {\n\t\tcc.ChannelConstraints = DefaultLtcChannelConstraints\n\t}\n\n\treturn cc, ccCleanup, nil\n}\n\n// NewChainControl attempts to create a ChainControl instance according\n// to the parameters in the passed configuration. Currently three\n// branches of ChainControl instances exist: one backed by a running btcd\n// full-node, another backed by a running bitcoind full-node, and the other\n// backed by a running neutrino light client instance. When running with a\n// neutrino light client instance, `neutrinoCS` must be non-nil.",
      "length": 15802,
      "tokens": 2015,
      "embedding": []
    },
    {
      "slug": "func NewChainControl(walletConfig lnwallet.Config,",
      "content": "func NewChainControl(walletConfig lnwallet.Config,\n\tmsgSigner lnwallet.MessageSigner,\n\tpcc *PartialChainControl) (*ChainControl, func(), error) {\n\n\tcc := &ChainControl{\n\t\tPartialChainControl: pcc,\n\t\tMsgSigner:           msgSigner,\n\t\tSigner:              walletConfig.Signer,\n\t\tChainIO:             walletConfig.ChainIO,\n\t\tWc:                  walletConfig.WalletController,\n\t\tKeyRing:             walletConfig.SecretKeyRing,\n\t}\n\n\tccCleanup := func() {\n\t\tif cc.Wallet != nil {\n\t\t\tif err := cc.Wallet.Shutdown(); err != nil {\n\t\t\t\tlog.Errorf(\"Failed to shutdown wallet: %v\", err)\n\t\t\t}\n\t\t}\n\t}\n\n\tlnWallet, err := lnwallet.NewLightningWallet(walletConfig)\n\tif err != nil {\n\t\treturn nil, ccCleanup, fmt.Errorf(\"unable to create wallet: %v\",\n\t\t\terr)\n\t}\n\tif err := lnWallet.Startup(); err != nil {\n\t\treturn nil, ccCleanup, fmt.Errorf(\"unable to create wallet: %v\",\n\t\t\terr)\n\t}\n\n\tlog.Info(\"LightningWallet opened\")\n\tcc.Wallet = lnWallet\n\n\treturn cc, ccCleanup, nil\n}\n\n// getBitcoindHealthCheckCmd queries bitcoind for its version to decide which\n// api we should use for our health check. We prefer to use the uptime\n// command, because it has no locking and is an inexpensive call, which was\n// added in version 0.15. If we are on an earlier version, we fallback to using\n// getblockchaininfo.",
      "length": 1192,
      "tokens": 154,
      "embedding": []
    },
    {
      "slug": "func getBitcoindHealthCheckCmd(client *rpcclient.Client) (string, int64, error) {",
      "content": "func getBitcoindHealthCheckCmd(client *rpcclient.Client) (string, int64, error) {\n\t// Query bitcoind to get our current version.\n\tresp, err := client.RawRequest(\"getnetworkinfo\", nil)\n\tif err != nil {\n\t\treturn \"\", 0, err\n\t}\n\n\t// Parse the response to retrieve bitcoind's version.\n\tinfo := struct {\n\t\tVersion int64 `json:\"version\"`\n\t}{}\n\tif err := json.Unmarshal(resp, &info); err != nil {\n\t\treturn \"\", 0, err\n\t}\n\n\t// Bitcoind returns a single value representing the semantic version:\n\t// 1000000 * CLIENT_VERSION_MAJOR + 10000 * CLIENT_VERSION_MINOR\n\t// + 100 * CLIENT_VERSION_REVISION + 1 * CLIENT_VERSION_BUILD\n\t//\n\t// The uptime call was added in version 0.15.0, so we return it for\n\t// any version value >= 150000, as per the above calculation.\n\tif info.Version >= 150000 {\n\t\treturn \"uptime\", info.Version, nil\n\t}\n\n\treturn \"getblockchaininfo\", info.Version, nil\n}\n\nvar (\n\t// BitcoinTestnetGenesis is the genesis hash of Bitcoin's testnet\n\t// chain.\n\tBitcoinTestnetGenesis = chainhash.Hash([chainhash.HashSize]byte{\n\t\t0x43, 0x49, 0x7f, 0xd7, 0xf8, 0x26, 0x95, 0x71,\n\t\t0x08, 0xf4, 0xa3, 0x0f, 0xd9, 0xce, 0xc3, 0xae,\n\t\t0xba, 0x79, 0x97, 0x20, 0x84, 0xe9, 0x0e, 0xad,\n\t\t0x01, 0xea, 0x33, 0x09, 0x00, 0x00, 0x00, 0x00,\n\t})\n\n\t// BitcoinSignetGenesis is the genesis hash of Bitcoin's signet chain.\n\tBitcoinSignetGenesis = chainhash.Hash([chainhash.HashSize]byte{\n\t\t0xf6, 0x1e, 0xee, 0x3b, 0x63, 0xa3, 0x80, 0xa4,\n\t\t0x77, 0xa0, 0x63, 0xaf, 0x32, 0xb2, 0xbb, 0xc9,\n\t\t0x7c, 0x9f, 0xf9, 0xf0, 0x1f, 0x2c, 0x42, 0x25,\n\t\t0xe9, 0x73, 0x98, 0x81, 0x08, 0x00, 0x00, 0x00,\n\t})\n\n\t// BitcoinMainnetGenesis is the genesis hash of Bitcoin's main chain.\n\tBitcoinMainnetGenesis = chainhash.Hash([chainhash.HashSize]byte{\n\t\t0x6f, 0xe2, 0x8c, 0x0a, 0xb6, 0xf1, 0xb3, 0x72,\n\t\t0xc1, 0xa6, 0xa2, 0x46, 0xae, 0x63, 0xf7, 0x4f,\n\t\t0x93, 0x1e, 0x83, 0x65, 0xe1, 0x5a, 0x08, 0x9c,\n\t\t0x68, 0xd6, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t})\n\n\t// LitecoinTestnetGenesis is the genesis hash of Litecoin's testnet4\n\t// chain.\n\tLitecoinTestnetGenesis = chainhash.Hash([chainhash.HashSize]byte{\n\t\t0xa0, 0x29, 0x3e, 0x4e, 0xeb, 0x3d, 0xa6, 0xe6,\n\t\t0xf5, 0x6f, 0x81, 0xed, 0x59, 0x5f, 0x57, 0x88,\n\t\t0x0d, 0x1a, 0x21, 0x56, 0x9e, 0x13, 0xee, 0xfd,\n\t\t0xd9, 0x51, 0x28, 0x4b, 0x5a, 0x62, 0x66, 0x49,\n\t})\n\n\t// LitecoinMainnetGenesis is the genesis hash of Litecoin's main chain.\n\tLitecoinMainnetGenesis = chainhash.Hash([chainhash.HashSize]byte{\n\t\t0xe2, 0xbf, 0x04, 0x7e, 0x7e, 0x5a, 0x19, 0x1a,\n\t\t0xa4, 0xef, 0x34, 0xd3, 0x14, 0x97, 0x9d, 0xc9,\n\t\t0x98, 0x6e, 0x0f, 0x19, 0x25, 0x1e, 0xda, 0xba,\n\t\t0x59, 0x40, 0xfd, 0x1f, 0xe3, 0x65, 0xa7, 0x12,\n\t})\n\n\t// chainMap is a simple index that maps a chain's genesis hash to the\n\t// ChainCode enum for that chain.\n\tchainMap = map[chainhash.Hash]ChainCode{\n\t\tBitcoinTestnetGenesis:  BitcoinChain,\n\t\tLitecoinTestnetGenesis: LitecoinChain,\n\n\t\tBitcoinMainnetGenesis:  BitcoinChain,\n\t\tLitecoinMainnetGenesis: LitecoinChain,\n\t}\n\n\t// ChainDNSSeeds is a map of a chain's hash to the set of DNS seeds\n\t// that will be use to bootstrap peers upon first startup.\n\t//\n\t// The first item in the array is the primary host we'll use to attempt\n\t// the SRV lookup we require. If we're unable to receive a response\n\t// over UDP, then we'll fall back to manual TCP resolution. The second\n\t// item in the array is a special A record that we'll query in order to\n\t// receive the IP address of the current authoritative DNS server for\n\t// the network seed.\n\t//\n\t// TODO(roasbeef): extend and collapse these and chainparams.go into\n\t// struct like chaincfg.Params.\n\tChainDNSSeeds = map[chainhash.Hash][][2]string{\n\t\tBitcoinMainnetGenesis: {\n\t\t\t{\n\t\t\t\t\"nodes.lightning.directory\",\n\t\t\t\t\"soa.nodes.lightning.directory\",\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"lseed.bitcoinstats.com\",\n\t\t\t},\n\t\t},\n\n\t\tBitcoinTestnetGenesis: {\n\t\t\t{\n\t\t\t\t\"test.nodes.lightning.directory\",\n\t\t\t\t\"soa.nodes.lightning.directory\",\n\t\t\t},\n\t\t},\n\n\t\tBitcoinSignetGenesis: {\n\t\t\t{\n\t\t\t\t\"ln.signet.secp.tech\",\n\t\t\t},\n\t\t},\n\n\t\tLitecoinMainnetGenesis: {\n\t\t\t{\n\t\t\t\t\"ltc.nodes.lightning.directory\",\n\t\t\t\t\"soa.nodes.lightning.directory\",\n\t\t\t},\n\t\t},\n\t}\n)\n\n// ChainRegistry keeps track of the current chains.",
      "length": 3902,
      "tokens": 544,
      "embedding": []
    },
    {
      "slug": "type ChainRegistry struct {",
      "content": "type ChainRegistry struct {\n\tsync.RWMutex\n\n\tactiveChains map[ChainCode]*ChainControl\n\tnetParams    map[ChainCode]*BitcoinNetParams\n\n\tprimaryChain ChainCode\n}\n\n// NewChainRegistry creates a new ChainRegistry.",
      "length": 171,
      "tokens": 14,
      "embedding": []
    },
    {
      "slug": "func NewChainRegistry() *ChainRegistry {",
      "content": "func NewChainRegistry() *ChainRegistry {\n\treturn &ChainRegistry{\n\t\tactiveChains: make(map[ChainCode]*ChainControl),\n\t\tnetParams:    make(map[ChainCode]*BitcoinNetParams),\n\t}\n}\n\n// RegisterChain assigns an active ChainControl instance to a target chain\n// identified by its ChainCode.",
      "length": 235,
      "tokens": 24,
      "embedding": []
    },
    {
      "slug": "func (c *ChainRegistry) RegisterChain(newChain ChainCode,",
      "content": "func (c *ChainRegistry) RegisterChain(newChain ChainCode,\n\tcc *ChainControl) {\n\n\tc.Lock()\n\tc.activeChains[newChain] = cc\n\tc.Unlock()\n}\n\n// LookupChain attempts to lookup an active ChainControl instance for the\n// target chain.",
      "length": 160,
      "tokens": 23,
      "embedding": []
    },
    {
      "slug": "func (c *ChainRegistry) LookupChain(targetChain ChainCode) (",
      "content": "func (c *ChainRegistry) LookupChain(targetChain ChainCode) (\n\t*ChainControl, bool) {\n\n\tc.RLock()\n\tcc, ok := c.activeChains[targetChain]\n\tc.RUnlock()\n\treturn cc, ok\n}\n\n// LookupChainByHash attempts to look up an active ChainControl which\n// corresponds to the passed genesis hash.",
      "length": 209,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func (c *ChainRegistry) LookupChainByHash(",
      "content": "func (c *ChainRegistry) LookupChainByHash(\n\tchainHash chainhash.Hash) (*ChainControl, bool) {\n\n\tc.RLock()\n\tdefer c.RUnlock()\n\n\ttargetChain, ok := chainMap[chainHash]\n\tif !ok {\n\t\treturn nil, ok\n\t}\n\n\tcc, ok := c.activeChains[targetChain]\n\treturn cc, ok\n}\n\n// RegisterPrimaryChain sets a target chain as the \"home chain\" for lnd.",
      "length": 269,
      "tokens": 39,
      "embedding": []
    },
    {
      "slug": "func (c *ChainRegistry) RegisterPrimaryChain(cc ChainCode) {",
      "content": "func (c *ChainRegistry) RegisterPrimaryChain(cc ChainCode) {\n\tc.Lock()\n\tdefer c.Unlock()\n\n\tc.primaryChain = cc\n}\n\n// PrimaryChain returns the primary chain for this running lnd instance. The\n// primary chain is considered the \"home base\" while the other registered\n// chains are treated as secondary chains.",
      "length": 238,
      "tokens": 38,
      "embedding": []
    },
    {
      "slug": "func (c *ChainRegistry) PrimaryChain() ChainCode {",
      "content": "func (c *ChainRegistry) PrimaryChain() ChainCode {\n\tc.RLock()\n\tdefer c.RUnlock()\n\n\treturn c.primaryChain\n}\n\n// ActiveChains returns a slice containing the active chains.",
      "length": 112,
      "tokens": 15,
      "embedding": []
    },
    {
      "slug": "func (c *ChainRegistry) ActiveChains() []ChainCode {",
      "content": "func (c *ChainRegistry) ActiveChains() []ChainCode {\n\tc.RLock()\n\tdefer c.RUnlock()\n\n\tchains := make([]ChainCode, 0, len(c.activeChains))\n\tfor activeChain := range c.activeChains {\n\t\tchains = append(chains, activeChain)\n\t}\n\n\treturn chains\n}\n\n// NumActiveChains returns the total number of active chains.",
      "length": 238,
      "tokens": 31,
      "embedding": []
    },
    {
      "slug": "func (c *ChainRegistry) NumActiveChains() uint32 {",
      "content": "func (c *ChainRegistry) NumActiveChains() uint32 {\n\tc.RLock()\n\tdefer c.RUnlock()\n\n\treturn uint32(len(c.activeChains))\n}\n",
      "length": 64,
      "tokens": 6,
      "embedding": []
    }
  ]
}