{
  "filepath": "../implementations/go/lnd/invoices/invoiceregistry.go",
  "package": "invoices",
  "sections": [
    {
      "slug": "type RegistryConfig struct {",
      "content": "type RegistryConfig struct {\n\t// FinalCltvRejectDelta defines the number of blocks before the expiry\n\t// of the htlc where we no longer settle it as an exit hop and instead\n\t// cancel it back. Normally this value should be lower than the cltv\n\t// expiry of any invoice we create and the code effectuating this should\n\t// not be hit.\n\tFinalCltvRejectDelta int32\n\n\t// HtlcHoldDuration defines for how long mpp htlcs are held while\n\t// waiting for the other set members to arrive.\n\tHtlcHoldDuration time.Duration\n\n\t// Clock holds the clock implementation that is used to provide\n\t// Now() and TickAfter() and is useful to stub out the clock functions\n\t// during testing.\n\tClock clock.Clock\n\n\t// AcceptKeySend indicates whether we want to accept spontaneous key\n\t// send payments.\n\tAcceptKeySend bool\n\n\t// AcceptAMP indicates whether we want to accept spontaneous AMP\n\t// payments.\n\tAcceptAMP bool\n\n\t// GcCanceledInvoicesOnStartup if set, we'll attempt to garbage collect\n\t// all canceled invoices upon start.\n\tGcCanceledInvoicesOnStartup bool\n\n\t// GcCanceledInvoicesOnTheFly if set, we'll garbage collect all newly\n\t// canceled invoices on the fly.\n\tGcCanceledInvoicesOnTheFly bool\n\n\t// KeysendHoldTime indicates for how long we want to accept and hold\n\t// spontaneous keysend payments.\n\tKeysendHoldTime time.Duration\n}\n\n// htlcReleaseEvent describes an htlc auto-release event. It is used to release\n// mpp htlcs for which the complete set didn't arrive in time.",
      "length": 1393,
      "tokens": 215,
      "embedding": []
    },
    {
      "slug": "type htlcReleaseEvent struct {",
      "content": "type htlcReleaseEvent struct {\n\t// invoiceRef identifiers the invoice this htlc belongs to.\n\tinvoiceRef InvoiceRef\n\n\t// key is the circuit key of the htlc to release.\n\tkey CircuitKey\n\n\t// releaseTime is the time at which to release the htlc.\n\treleaseTime time.Time\n}\n\n// Less is used to order PriorityQueueItem's by their release time such that\n// items with the older release time are at the top of the queue.\n//\n// NOTE: Part of the queue.PriorityQueueItem interface.",
      "length": 425,
      "tokens": 73,
      "embedding": []
    },
    {
      "slug": "func (r *htlcReleaseEvent) Less(other queue.PriorityQueueItem) bool {",
      "content": "func (r *htlcReleaseEvent) Less(other queue.PriorityQueueItem) bool {\n\treturn r.releaseTime.Before(other.(*htlcReleaseEvent).releaseTime)\n}\n\n// InvoiceRegistry is a central registry of all the outstanding invoices\n// created by the daemon. The registry is a thin wrapper around a map in order\n// to ensure that all updates/reads are thread safe.",
      "length": 270,
      "tokens": 39,
      "embedding": []
    },
    {
      "slug": "type InvoiceRegistry struct {",
      "content": "type InvoiceRegistry struct {\n\tsync.RWMutex\n\n\tnextClientID uint32 // must be used atomically\n\n\tidb InvoiceDB\n\n\t// cfg contains the registry's configuration parameters.\n\tcfg *RegistryConfig\n\n\t// notificationClientMux locks notificationClients and\n\t// singleNotificationClients. Using a separate mutex for these maps is\n\t// necessary to avoid deadlocks in the registry when processing invoice\n\t// events.\n\tnotificationClientMux sync.RWMutex\n\n\tnotificationClients map[uint32]*InvoiceSubscription\n\n\t// TODO(yy): use map[lntypes.Hash]*SingleInvoiceSubscription for better\n\t// performance.\n\tsingleNotificationClients map[uint32]*SingleInvoiceSubscription\n\n\t// invoiceEvents is a single channel over which invoice updates are\n\t// carried.\n\tinvoiceEvents chan *invoiceEvent\n\n\t// hodlSubscriptionsMux locks the hodlSubscriptions and\n\t// hodlReverseSubscriptions. Using a separate mutex for these maps is\n\t// necessary to avoid deadlocks in the registry when processing invoice\n\t// events.\n\thodlSubscriptionsMux sync.RWMutex\n\n\t// hodlSubscriptions is a map from a circuit key to a list of\n\t// subscribers. It is used for efficient notification of links.\n\thodlSubscriptions map[CircuitKey]map[chan<- interface{}]struct{}\n\n\t// reverseSubscriptions tracks circuit keys subscribed to per\n\t// subscriber. This is used to unsubscribe from all hashes efficiently.\n\thodlReverseSubscriptions map[chan<- interface{}]map[CircuitKey]struct{}\n\n\t// htlcAutoReleaseChan contains the new htlcs that need to be\n\t// auto-released.\n\thtlcAutoReleaseChan chan *htlcReleaseEvent\n\n\texpiryWatcher *InvoiceExpiryWatcher\n\n\twg   sync.WaitGroup\n\tquit chan struct{}\n}\n\n// NewRegistry creates a new invoice registry. The invoice registry\n// wraps the persistent on-disk invoice storage with an additional in-memory\n// layer. The in-memory layer is in place such that debug invoices can be added\n// which are volatile yet available system wide within the daemon.",
      "length": 1839,
      "tokens": 226,
      "embedding": []
    },
    {
      "slug": "func NewRegistry(idb InvoiceDB, expiryWatcher *InvoiceExpiryWatcher,",
      "content": "func NewRegistry(idb InvoiceDB, expiryWatcher *InvoiceExpiryWatcher,\n\tcfg *RegistryConfig) *InvoiceRegistry {\n\n\tnotificationClients := make(map[uint32]*InvoiceSubscription)\n\tsingleNotificationClients := make(map[uint32]*SingleInvoiceSubscription)\n\treturn &InvoiceRegistry{\n\t\tidb:                       idb,\n\t\tnotificationClients:       notificationClients,\n\t\tsingleNotificationClients: singleNotificationClients,\n\t\tinvoiceEvents:             make(chan *invoiceEvent, 100),\n\t\thodlSubscriptions: make(\n\t\t\tmap[CircuitKey]map[chan<- interface{}]struct{},\n\t\t),\n\t\thodlReverseSubscriptions: make(\n\t\t\tmap[chan<- interface{}]map[CircuitKey]struct{},\n\t\t),\n\t\tcfg:                 cfg,\n\t\thtlcAutoReleaseChan: make(chan *htlcReleaseEvent),\n\t\texpiryWatcher:       expiryWatcher,\n\t\tquit:                make(chan struct{}),\n\t}\n}\n\n// scanInvoicesOnStart will scan all invoices on start and add active invoices\n// to the invoice expiry watcher while also attempting to delete all canceled\n// invoices.",
      "length": 891,
      "tokens": 71,
      "embedding": []
    },
    {
      "slug": "func (i *InvoiceRegistry) scanInvoicesOnStart() error {",
      "content": "func (i *InvoiceRegistry) scanInvoicesOnStart() error {\n\tvar (\n\t\tpending   []invoiceExpiry\n\t\tremovable []InvoiceDeleteRef\n\t)\n\n\treset := func() {\n\t\t// Zero out our results on start and if the scan is ever run\n\t\t// more than once. This latter case can happen if the kvdb\n\t\t// layer needs to retry the View transaction underneath (eg.\n\t\t// using the etcd driver, where all transactions are allowed\n\t\t// to retry for serializability).\n\t\tpending = nil\n\t\tremovable = make([]InvoiceDeleteRef, 0)\n\t}\n\n\tscanFunc := func(paymentHash lntypes.Hash,\n\t\tinvoice *Invoice) error {\n\n\t\tif invoice.IsPending() {\n\t\t\texpiryRef := makeInvoiceExpiry(paymentHash, invoice)\n\t\t\tif expiryRef != nil {\n\t\t\t\tpending = append(pending, expiryRef)\n\t\t\t}\n\t\t} else if i.cfg.GcCanceledInvoicesOnStartup &&\n\t\t\tinvoice.State == ContractCanceled {\n\n\t\t\t// Consider invoice for removal if it is already\n\t\t\t// canceled. Invoices that are expired but not yet\n\t\t\t// canceled, will be queued up for cancellation after\n\t\t\t// startup and will be deleted afterwards.\n\t\t\tref := InvoiceDeleteRef{\n\t\t\t\tPayHash:     paymentHash,\n\t\t\t\tAddIndex:    invoice.AddIndex,\n\t\t\t\tSettleIndex: invoice.SettleIndex,\n\t\t\t}\n\n\t\t\tif invoice.Terms.PaymentAddr != BlankPayAddr {\n\t\t\t\tref.PayAddr = &invoice.Terms.PaymentAddr\n\t\t\t}\n\n\t\t\tremovable = append(removable, ref)\n\t\t}\n\t\treturn nil\n\t}\n\n\terr := i.idb.ScanInvoices(scanFunc, reset)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlog.Debugf(\"Adding %d pending invoices to the expiry watcher\",\n\t\tlen(pending))\n\ti.expiryWatcher.AddInvoices(pending...)\n\n\tif len(removable) > 0 {\n\t\tlog.Infof(\"Attempting to delete %v canceled invoices\",\n\t\t\tlen(removable))\n\t\tif err := i.idb.DeleteInvoice(removable); err != nil {\n\t\t\tlog.Warnf(\"Deleting canceled invoices failed: %v\", err)\n\t\t} else {\n\t\t\tlog.Infof(\"Deleted %v canceled invoices\",\n\t\t\t\tlen(removable))\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Start starts the registry and all goroutines it needs to carry out its task.",
      "length": 1786,
      "tokens": 241,
      "embedding": []
    },
    {
      "slug": "func (i *InvoiceRegistry) Start() error {",
      "content": "func (i *InvoiceRegistry) Start() error {\n\t// Start InvoiceExpiryWatcher and prepopulate it with existing active\n\t// invoices.\n\terr := i.expiryWatcher.Start(i.cancelInvoiceImpl)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlog.Info(\"InvoiceRegistry starting\")\n\n\ti.wg.Add(1)\n\tgo i.invoiceEventLoop()\n\n\t// Now scan all pending and removable invoices to the expiry watcher or\n\t// delete them.\n\terr = i.scanInvoicesOnStart()\n\tif err != nil {\n\t\t_ = i.Stop()\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Stop signals the registry for a graceful shutdown.",
      "length": 463,
      "tokens": 69,
      "embedding": []
    },
    {
      "slug": "func (i *InvoiceRegistry) Stop() error {",
      "content": "func (i *InvoiceRegistry) Stop() error {\n\tlog.Info(\"InvoiceRegistry shutting down\")\n\n\ti.expiryWatcher.Stop()\n\n\tclose(i.quit)\n\n\ti.wg.Wait()\n\treturn nil\n}\n\n// invoiceEvent represents a new event that has modified on invoice on disk.\n// Only two event types are currently supported: newly created invoices, and\n// instance where invoices are settled.",
      "length": 294,
      "tokens": 40,
      "embedding": []
    },
    {
      "slug": "type invoiceEvent struct {",
      "content": "type invoiceEvent struct {\n\thash    lntypes.Hash\n\tinvoice *Invoice\n\tsetID   *[32]byte\n}\n\n// tickAt returns a channel that ticks at the specified time. If the time has\n// already passed, it will tick immediately.",
      "length": 178,
      "tokens": 29,
      "embedding": []
    },
    {
      "slug": "func (i *InvoiceRegistry) tickAt(t time.Time) <-chan time.Time {",
      "content": "func (i *InvoiceRegistry) tickAt(t time.Time) <-chan time.Time {\n\tnow := i.cfg.Clock.Now()\n\treturn i.cfg.Clock.TickAfter(t.Sub(now))\n}\n\n// invoiceEventLoop is the dedicated goroutine responsible for accepting\n// new notification subscriptions, cancelling old subscriptions, and\n// dispatching new invoice events.",
      "length": 241,
      "tokens": 28,
      "embedding": []
    },
    {
      "slug": "func (i *InvoiceRegistry) invoiceEventLoop() {",
      "content": "func (i *InvoiceRegistry) invoiceEventLoop() {\n\tdefer i.wg.Done()\n\n\t// Set up a heap for htlc auto-releases.\n\tautoReleaseHeap := &queue.PriorityQueue{}\n\n\tfor {\n\t\t// If there is something to release, set up a release tick\n\t\t// channel.\n\t\tvar nextReleaseTick <-chan time.Time\n\t\tif autoReleaseHeap.Len() > 0 {\n\t\t\thead := autoReleaseHeap.Top().(*htlcReleaseEvent)\n\t\t\tnextReleaseTick = i.tickAt(head.releaseTime)\n\t\t}\n\n\t\tselect {\n\t\t// A sub-systems has just modified the invoice state, so we'll\n\t\t// dispatch notifications to all registered clients.\n\t\tcase event := <-i.invoiceEvents:\n\t\t\t// For backwards compatibility, do not notify all\n\t\t\t// invoice subscribers of cancel and accept events.\n\t\t\tstate := event.invoice.State\n\t\t\tif state != ContractCanceled &&\n\t\t\t\tstate != ContractAccepted {\n\n\t\t\t\ti.dispatchToClients(event)\n\t\t\t}\n\t\t\ti.dispatchToSingleClients(event)\n\n\t\t// A new htlc came in for auto-release.\n\t\tcase event := <-i.htlcAutoReleaseChan:\n\t\t\tlog.Debugf(\"Scheduling auto-release for htlc: \"+\n\t\t\t\t\"ref=%v, key=%v at %v\",\n\t\t\t\tevent.invoiceRef, event.key, event.releaseTime)\n\n\t\t\t// We use an independent timer for every htlc rather\n\t\t\t// than a set timer that is reset with every htlc coming\n\t\t\t// in. Otherwise the sender could keep resetting the\n\t\t\t// timer until the broadcast window is entered and our\n\t\t\t// channel is force closed.\n\t\t\tautoReleaseHeap.Push(event)\n\n\t\t// The htlc at the top of the heap needs to be auto-released.\n\t\tcase <-nextReleaseTick:\n\t\t\tevent := autoReleaseHeap.Pop().(*htlcReleaseEvent)\n\t\t\terr := i.cancelSingleHtlc(\n\t\t\t\tevent.invoiceRef, event.key, ResultMppTimeout,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tlog.Errorf(\"HTLC timer: %v\", err)\n\t\t\t}\n\n\t\tcase <-i.quit:\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// dispatchToSingleClients passes the supplied event to all notification\n// clients that subscribed to all the invoice this event applies to.",
      "length": 1735,
      "tokens": 233,
      "embedding": []
    },
    {
      "slug": "func (i *InvoiceRegistry) dispatchToSingleClients(event *invoiceEvent) {",
      "content": "func (i *InvoiceRegistry) dispatchToSingleClients(event *invoiceEvent) {\n\t// Dispatch to single invoice subscribers.\n\tclients := i.copySingleClients()\n\tfor _, client := range clients {\n\t\tpayHash := client.invoiceRef.PayHash()\n\n\t\tif payHash == nil || *payHash != event.hash {\n\t\t\tcontinue\n\t\t}\n\n\t\tselect {\n\t\tcase <-client.backlogDelivered:\n\t\t\t// We won't deliver any events until the backlog has\n\t\t\t// went through first.\n\t\tcase <-i.quit:\n\t\t\treturn\n\t\t}\n\n\t\tclient.notify(event)\n\t}\n}\n\n// dispatchToClients passes the supplied event to all notification clients that\n// subscribed to all invoices. Add and settle indices are used to make sure\n// that clients don't receive duplicate or unwanted events.",
      "length": 599,
      "tokens": 89,
      "embedding": []
    },
    {
      "slug": "func (i *InvoiceRegistry) dispatchToClients(event *invoiceEvent) {",
      "content": "func (i *InvoiceRegistry) dispatchToClients(event *invoiceEvent) {\n\tinvoice := event.invoice\n\n\tclients := i.copyClients()\n\tfor clientID, client := range clients {\n\t\t// Before we dispatch this event, we'll check\n\t\t// to ensure that this client hasn't already\n\t\t// received this notification in order to\n\t\t// ensure we don't duplicate any events.\n\n\t\t// TODO(joostjager): Refactor switches.\n\t\tstate := event.invoice.State\n\t\tswitch {\n\t\t// If we've already sent this settle event to\n\t\t// the client, then we can skip this.\n\t\tcase state == ContractSettled &&\n\t\t\tclient.settleIndex >= invoice.SettleIndex:\n\t\t\tcontinue\n\n\t\t// Similarly, if we've already sent this add to\n\t\t// the client then we can skip this one, but only if this isn't\n\t\t// an AMP invoice. AMP invoices always remain in the settle\n\t\t// state as a base invoice.\n\t\tcase event.setID == nil && state == ContractOpen &&\n\t\t\tclient.addIndex >= invoice.AddIndex:\n\t\t\tcontinue\n\n\t\t// These two states should never happen, but we\n\t\t// log them just in case so we can detect this\n\t\t// instance.\n\t\tcase state == ContractOpen &&\n\t\t\tclient.addIndex+1 != invoice.AddIndex:\n\t\t\tlog.Warnf(\"client=%v for invoice \"+\n\t\t\t\t\"notifications missed an update, \"+\n\t\t\t\t\"add_index=%v, new add event index=%v\",\n\t\t\t\tclientID, client.addIndex,\n\t\t\t\tinvoice.AddIndex)\n\n\t\tcase state == ContractSettled &&\n\t\t\tclient.settleIndex+1 != invoice.SettleIndex:\n\t\t\tlog.Warnf(\"client=%v for invoice \"+\n\t\t\t\t\"notifications missed an update, \"+\n\t\t\t\t\"settle_index=%v, new settle event index=%v\",\n\t\t\t\tclientID, client.settleIndex,\n\t\t\t\tinvoice.SettleIndex)\n\t\t}\n\n\t\tselect {\n\t\tcase <-client.backlogDelivered:\n\t\t\t// We won't deliver any events until the backlog has\n\t\t\t// been processed.\n\t\tcase <-i.quit:\n\t\t\treturn\n\t\t}\n\n\t\terr := client.notify(&invoiceEvent{\n\t\t\tinvoice: invoice,\n\t\t\tsetID:   event.setID,\n\t\t})\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Failed dispatching to client: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\t// Each time we send a notification to a client, we'll record\n\t\t// the latest add/settle index it has. We'll use this to ensure\n\t\t// we don't send a notification twice, which can happen if a new\n\t\t// event is added while we're catching up a new client.\n\t\tinvState := event.invoice.State\n\t\tswitch {\n\t\tcase invState == ContractSettled:\n\t\t\tclient.settleIndex = invoice.SettleIndex\n\n\t\tcase invState == ContractOpen && event.setID == nil:\n\t\t\tclient.addIndex = invoice.AddIndex\n\n\t\t// If this is an AMP invoice, then we'll need to use the set ID\n\t\t// to keep track of the settle index of the client. AMP\n\t\t// invoices never go to the open state, but if a setID is\n\t\t// passed, then we know it was just settled and will track the\n\t\t// highest settle index so far.\n\t\tcase invState == ContractOpen && event.setID != nil:\n\t\t\tsetID := *event.setID\n\t\t\tclient.settleIndex = invoice.AMPState[setID].SettleIndex\n\n\t\tdefault:\n\t\t\tlog.Errorf(\"unexpected invoice state: %v\",\n\t\t\t\tevent.invoice.State)\n\t\t}\n\t}\n}\n\n// deliverBacklogEvents will attempts to query the invoice database for any\n// notifications that the client has missed since it reconnected last.",
      "length": 2878,
      "tokens": 421,
      "embedding": []
    },
    {
      "slug": "func (i *InvoiceRegistry) deliverBacklogEvents(",
      "content": "func (i *InvoiceRegistry) deliverBacklogEvents(\n\tclient *InvoiceSubscription) error {\n\n\taddEvents, err := i.idb.InvoicesAddedSince(client.addIndex)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsettleEvents, err := i.idb.InvoicesSettledSince(client.settleIndex)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// If we have any to deliver, then we'll append them to the end of the\n\t// notification queue in order to catch up the client before delivering\n\t// any new notifications.\n\tfor _, addEvent := range addEvents {\n\t\t// We re-bind the loop variable to ensure we don't hold onto\n\t\t// the loop reference causing is to point to the same item.\n\t\taddEvent := addEvent\n\n\t\tselect {\n\t\tcase client.ntfnQueue.ChanIn() <- &invoiceEvent{\n\t\t\tinvoice: &addEvent,\n\t\t}:\n\t\tcase <-i.quit:\n\t\t\treturn ErrShuttingDown\n\t\t}\n\t}\n\n\tfor _, settleEvent := range settleEvents {\n\t\t// We re-bind the loop variable to ensure we don't hold onto\n\t\t// the loop reference causing is to point to the same item.\n\t\tsettleEvent := settleEvent\n\n\t\tselect {\n\t\tcase client.ntfnQueue.ChanIn() <- &invoiceEvent{\n\t\t\tinvoice: &settleEvent,\n\t\t}:\n\t\tcase <-i.quit:\n\t\t\treturn ErrShuttingDown\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// deliverSingleBacklogEvents will attempt to query the invoice database to\n// retrieve the current invoice state and deliver this to the subscriber. Single\n// invoice subscribers will always receive the current state right after\n// subscribing. Only in case the invoice does not yet exist, nothing is sent\n// yet.",
      "length": 1359,
      "tokens": 211,
      "embedding": []
    },
    {
      "slug": "func (i *InvoiceRegistry) deliverSingleBacklogEvents(",
      "content": "func (i *InvoiceRegistry) deliverSingleBacklogEvents(\n\tclient *SingleInvoiceSubscription) error {\n\n\tinvoice, err := i.idb.LookupInvoice(client.invoiceRef)\n\n\t// It is possible that the invoice does not exist yet, but the client is\n\t// already watching it in anticipation.\n\tisNotFound := errors.Is(err, ErrInvoiceNotFound)\n\tisNotCreated := errors.Is(err, ErrNoInvoicesCreated)\n\tif isNotFound || isNotCreated {\n\t\treturn nil\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpayHash := client.invoiceRef.PayHash()\n\tif payHash == nil {\n\t\treturn nil\n\t}\n\n\terr = client.notify(&invoiceEvent{\n\t\thash:    *payHash,\n\t\tinvoice: &invoice,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlog.Debugf(\"Client(id=%v) delivered single backlog event: payHash=%v\",\n\t\tclient.id, payHash)\n\n\treturn nil\n}\n\n// AddInvoice adds a regular invoice for the specified amount, identified by\n// the passed preimage. Additionally, any memo or receipt data provided will\n// also be stored on-disk. Once this invoice is added, subsystems within the\n// daemon add/forward HTLCs are able to obtain the proper preimage required for\n// redemption in the case that we're the final destination. We also return the\n// addIndex of the newly created invoice which monotonically increases for each\n// new invoice added.  A side effect of this function is that it also sets\n// AddIndex on the invoice argument.",
      "length": 1248,
      "tokens": 188,
      "embedding": []
    },
    {
      "slug": "func (i *InvoiceRegistry) AddInvoice(invoice *Invoice,",
      "content": "func (i *InvoiceRegistry) AddInvoice(invoice *Invoice,\n\tpaymentHash lntypes.Hash) (uint64, error) {\n\n\ti.Lock()\n\n\tref := InvoiceRefByHash(paymentHash)\n\tlog.Debugf(\"Invoice%v: added with terms %v\", ref, invoice.Terms)\n\n\taddIndex, err := i.idb.AddInvoice(invoice, paymentHash)\n\tif err != nil {\n\t\ti.Unlock()\n\t\treturn 0, err\n\t}\n\n\t// Now that we've added the invoice, we'll send dispatch a message to\n\t// notify the clients of this new invoice.\n\ti.notifyClients(paymentHash, invoice, nil)\n\ti.Unlock()\n\n\t// InvoiceExpiryWatcher.AddInvoice must not be locked by InvoiceRegistry\n\t// to avoid deadlock when a new invoice is added while an other is being\n\t// canceled.\n\tinvoiceExpiryRef := makeInvoiceExpiry(paymentHash, invoice)\n\tif invoiceExpiryRef != nil {\n\t\ti.expiryWatcher.AddInvoices(invoiceExpiryRef)\n\t}\n\n\treturn addIndex, nil\n}\n\n// LookupInvoice looks up an invoice by its payment hash (R-Hash), if found\n// then we're able to pull the funds pending within an HTLC.\n//\n// TODO(roasbeef): ignore if settled?",
      "length": 916,
      "tokens": 127,
      "embedding": []
    },
    {
      "slug": "func (i *InvoiceRegistry) LookupInvoice(rHash lntypes.Hash) (Invoice, error) {",
      "content": "func (i *InvoiceRegistry) LookupInvoice(rHash lntypes.Hash) (Invoice, error) {\n\t// We'll check the database to see if there's an existing matching\n\t// invoice.\n\tref := InvoiceRefByHash(rHash)\n\treturn i.idb.LookupInvoice(ref)\n}\n\n// LookupInvoiceByRef looks up an invoice by the given reference, if found\n// then we're able to pull the funds pending within an HTLC.",
      "length": 277,
      "tokens": 44,
      "embedding": []
    },
    {
      "slug": "func (i *InvoiceRegistry) LookupInvoiceByRef(ref InvoiceRef) (Invoice, error) {",
      "content": "func (i *InvoiceRegistry) LookupInvoiceByRef(ref InvoiceRef) (Invoice, error) {\n\treturn i.idb.LookupInvoice(ref)\n}\n\n// startHtlcTimer starts a new timer via the invoice registry main loop that\n// cancels a single htlc on an invoice when the htlc hold duration has passed.",
      "length": 187,
      "tokens": 31,
      "embedding": []
    },
    {
      "slug": "func (i *InvoiceRegistry) startHtlcTimer(invoiceRef InvoiceRef,",
      "content": "func (i *InvoiceRegistry) startHtlcTimer(invoiceRef InvoiceRef,\n\tkey CircuitKey, acceptTime time.Time) error {\n\n\treleaseTime := acceptTime.Add(i.cfg.HtlcHoldDuration)\n\tevent := &htlcReleaseEvent{\n\t\tinvoiceRef:  invoiceRef,\n\t\tkey:         key,\n\t\treleaseTime: releaseTime,\n\t}\n\n\tselect {\n\tcase i.htlcAutoReleaseChan <- event:\n\t\treturn nil\n\n\tcase <-i.quit:\n\t\treturn ErrShuttingDown\n\t}\n}\n\n// cancelSingleHtlc cancels a single accepted htlc on an invoice. It takes\n// a resolution result which will be used to notify subscribed links and\n// resolvers of the details of the htlc cancellation.",
      "length": 501,
      "tokens": 67,
      "embedding": []
    },
    {
      "slug": "func (i *InvoiceRegistry) cancelSingleHtlc(invoiceRef InvoiceRef,",
      "content": "func (i *InvoiceRegistry) cancelSingleHtlc(invoiceRef InvoiceRef,\n\tkey CircuitKey, result FailResolutionResult) error {\n\n\tupdateInvoice := func(invoice *Invoice) (*InvoiceUpdateDesc, error) {\n\t\t// Only allow individual htlc cancellation on open invoices.\n\t\tif invoice.State != ContractOpen {\n\t\t\tlog.Debugf(\"cancelSingleHtlc: invoice %v no longer \"+\n\t\t\t\t\"open\", invoiceRef)\n\n\t\t\treturn nil, nil\n\t\t}\n\n\t\t// Lookup the current status of the htlc in the database.\n\t\tvar (\n\t\t\thtlcState HtlcState\n\t\t\tsetID     *SetID\n\t\t)\n\t\thtlc, ok := invoice.Htlcs[key]\n\t\tif !ok {\n\t\t\t// If this is an AMP invoice, then all the HTLCs won't\n\t\t\t// be read out, so we'll consult the other mapping to\n\t\t\t// try to find the HTLC state in question here.\n\t\t\tvar found bool\n\t\t\tfor ampSetID, htlcSet := range invoice.AMPState {\n\t\t\t\tampSetID := ampSetID\n\t\t\t\tfor htlcKey := range htlcSet.InvoiceKeys {\n\t\t\t\t\tif htlcKey == key {\n\t\t\t\t\t\thtlcState = htlcSet.State\n\t\t\t\t\t\tsetID = &ampSetID\n\n\t\t\t\t\t\tfound = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif !found {\n\t\t\t\treturn nil, fmt.Errorf(\"htlc %v not found\", key)\n\t\t\t}\n\t\t} else {\n\t\t\thtlcState = htlc.State\n\t\t}\n\n\t\t// Cancellation is only possible if the htlc wasn't already\n\t\t// resolved.\n\t\tif htlcState != HtlcStateAccepted {\n\t\t\tlog.Debugf(\"cancelSingleHtlc: htlc %v on invoice %v \"+\n\t\t\t\t\"is already resolved\", key, invoiceRef)\n\n\t\t\treturn nil, nil\n\t\t}\n\n\t\tlog.Debugf(\"cancelSingleHtlc: cancelling htlc %v on invoice %v\",\n\t\t\tkey, invoiceRef)\n\n\t\t// Return an update descriptor that cancels htlc and keeps\n\t\t// invoice open.\n\t\tcanceledHtlcs := map[CircuitKey]struct{}{\n\t\t\tkey: {},\n\t\t}\n\n\t\treturn &InvoiceUpdateDesc{\n\t\t\tCancelHtlcs: canceledHtlcs,\n\t\t\tSetID:       setID,\n\t\t}, nil\n\t}\n\n\t// Try to mark the specified htlc as canceled in the invoice database.\n\t// Intercept the update descriptor to set the local updated variable. If\n\t// no invoice update is performed, we can return early.\n\tsetID := (*SetID)(invoiceRef.SetID())\n\tvar updated bool\n\tinvoice, err := i.idb.UpdateInvoice(invoiceRef, setID,\n\t\tfunc(invoice *Invoice) (\n\t\t\t*InvoiceUpdateDesc, error) {\n\n\t\t\tupdateDesc, err := updateInvoice(invoice)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tupdated = updateDesc != nil\n\n\t\t\treturn updateDesc, err\n\t\t},\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !updated {\n\t\treturn nil\n\t}\n\n\t// The invoice has been updated. Notify subscribers of the htlc\n\t// resolution.\n\thtlc, ok := invoice.Htlcs[key]\n\tif !ok {\n\t\treturn fmt.Errorf(\"htlc %v not found\", key)\n\t}\n\tif htlc.State == HtlcStateCanceled {\n\t\tresolution := NewFailResolution(\n\t\t\tkey, int32(htlc.AcceptHeight), result,\n\t\t)\n\n\t\ti.notifyHodlSubscribers(resolution)\n\t}\n\treturn nil\n}\n\n// processKeySend just-in-time inserts an invoice if this htlc is a keysend\n// htlc.",
      "length": 2534,
      "tokens": 369,
      "embedding": []
    },
    {
      "slug": "func (i *InvoiceRegistry) processKeySend(ctx invoiceUpdateCtx) error {",
      "content": "func (i *InvoiceRegistry) processKeySend(ctx invoiceUpdateCtx) error {\n\t// Retrieve keysend record if present.\n\tpreimageSlice, ok := ctx.customRecords[record.KeySendType]\n\tif !ok {\n\t\treturn nil\n\t}\n\n\t// Cancel htlc is preimage is invalid.\n\tpreimage, err := lntypes.MakePreimage(preimageSlice)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif preimage.Hash() != ctx.hash {\n\t\treturn fmt.Errorf(\"invalid keysend preimage %v for hash %v\",\n\t\t\tpreimage, ctx.hash)\n\t}\n\n\t// Only allow keysend for non-mpp payments.\n\tif ctx.mpp != nil {\n\t\treturn errors.New(\"no mpp keysend supported\")\n\t}\n\n\t// Create an invoice for the htlc amount.\n\tamt := ctx.amtPaid\n\n\t// Set tlv optional feature vector on the invoice. Otherwise we wouldn't\n\t// be able to pay to it with keysend.\n\trawFeatures := lnwire.NewRawFeatureVector(\n\t\tlnwire.TLVOnionPayloadOptional,\n\t)\n\tfeatures := lnwire.NewFeatureVector(rawFeatures, lnwire.Features)\n\n\t// Use the minimum block delta that we require for settling htlcs.\n\tfinalCltvDelta := i.cfg.FinalCltvRejectDelta\n\n\t// Pre-check expiry here to prevent inserting an invoice that will not\n\t// be settled.\n\tif ctx.expiry < uint32(ctx.currentHeight+finalCltvDelta) {\n\t\treturn errors.New(\"final expiry too soon\")\n\t}\n\n\t// The invoice database indexes all invoices by payment address, however\n\t// legacy keysend payment do not have one. In order to avoid a new\n\t// payment type on-disk wrt. to indexing, we'll continue to insert a\n\t// blank payment address which is special cased in the insertion logic\n\t// to not be indexed. In the future, once AMP is merged, this should be\n\t// replaced by generating a random payment address on the behalf of the\n\t// sender.\n\tpayAddr := BlankPayAddr\n\n\t// Create placeholder invoice.\n\tinvoice := &Invoice{\n\t\tCreationDate: i.cfg.Clock.Now(),\n\t\tTerms: ContractTerm{\n\t\t\tFinalCltvDelta:  finalCltvDelta,\n\t\t\tValue:           amt,\n\t\t\tPaymentPreimage: &preimage,\n\t\t\tPaymentAddr:     payAddr,\n\t\t\tFeatures:        features,\n\t\t},\n\t}\n\n\tif i.cfg.KeysendHoldTime != 0 {\n\t\tinvoice.HodlInvoice = true\n\t\tinvoice.Terms.Expiry = i.cfg.KeysendHoldTime\n\t}\n\n\t// Insert invoice into database. Ignore duplicates, because this\n\t// may be a replay.\n\t_, err = i.AddInvoice(invoice, ctx.hash)\n\tif err != nil && !errors.Is(err, ErrDuplicateInvoice) {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// processAMP just-in-time inserts an invoice if this htlc is a keysend\n// htlc.",
      "length": 2208,
      "tokens": 315,
      "embedding": []
    },
    {
      "slug": "func (i *InvoiceRegistry) processAMP(ctx invoiceUpdateCtx) error {",
      "content": "func (i *InvoiceRegistry) processAMP(ctx invoiceUpdateCtx) error {\n\t// AMP payments MUST also include an MPP record.\n\tif ctx.mpp == nil {\n\t\treturn errors.New(\"no MPP record for AMP\")\n\t}\n\n\t// Create an invoice for the total amount expected, provided in the MPP\n\t// record.\n\tamt := ctx.mpp.TotalMsat()\n\n\t// Set the TLV and MPP optional features on the invoice. We'll also make\n\t// the AMP features required so that it can't be paid by legacy or MPP\n\t// htlcs.\n\trawFeatures := lnwire.NewRawFeatureVector(\n\t\tlnwire.TLVOnionPayloadOptional,\n\t\tlnwire.PaymentAddrOptional,\n\t\tlnwire.AMPRequired,\n\t)\n\tfeatures := lnwire.NewFeatureVector(rawFeatures, lnwire.Features)\n\n\t// Use the minimum block delta that we require for settling htlcs.\n\tfinalCltvDelta := i.cfg.FinalCltvRejectDelta\n\n\t// Pre-check expiry here to prevent inserting an invoice that will not\n\t// be settled.\n\tif ctx.expiry < uint32(ctx.currentHeight+finalCltvDelta) {\n\t\treturn errors.New(\"final expiry too soon\")\n\t}\n\n\t// We'll use the sender-generated payment address provided in the HTLC\n\t// to create our AMP invoice.\n\tpayAddr := ctx.mpp.PaymentAddr()\n\n\t// Create placeholder invoice.\n\tinvoice := &Invoice{\n\t\tCreationDate: i.cfg.Clock.Now(),\n\t\tTerms: ContractTerm{\n\t\t\tFinalCltvDelta:  finalCltvDelta,\n\t\t\tValue:           amt,\n\t\t\tPaymentPreimage: nil,\n\t\t\tPaymentAddr:     payAddr,\n\t\t\tFeatures:        features,\n\t\t},\n\t}\n\n\t// Insert invoice into database. Ignore duplicates payment hashes and\n\t// payment addrs, this may be a replay or a different HTLC for the AMP\n\t// invoice.\n\t_, err := i.AddInvoice(invoice, ctx.hash)\n\tisDuplicatedInvoice := errors.Is(err, ErrDuplicateInvoice)\n\tisDuplicatedPayAddr := errors.Is(err, ErrDuplicatePayAddr)\n\tswitch {\n\tcase isDuplicatedInvoice || isDuplicatedPayAddr:\n\t\treturn nil\n\tdefault:\n\t\treturn err\n\t}\n}\n\n// NotifyExitHopHtlc attempts to mark an invoice as settled. The return value\n// describes how the htlc should be resolved.\n//\n// When the preimage of the invoice is not yet known (hodl invoice), this\n// function moves the invoice to the accepted state. When SettleHoldInvoice is\n// called later, a resolution message will be send back to the caller via the\n// provided hodlChan. Invoice registry sends on this channel what action needs\n// to be taken on the htlc (settle or cancel). The caller needs to ensure that\n// the channel is either buffered or received on from another goroutine to\n// prevent deadlock.\n//\n// In the case that the htlc is part of a larger set of htlcs that pay to the\n// same invoice (multi-path payment), the htlc is held until the set is\n// complete. If the set doesn't fully arrive in time, a timer will cancel the\n// held htlc.",
      "length": 2513,
      "tokens": 375,
      "embedding": []
    },
    {
      "slug": "func (i *InvoiceRegistry) NotifyExitHopHtlc(rHash lntypes.Hash,",
      "content": "func (i *InvoiceRegistry) NotifyExitHopHtlc(rHash lntypes.Hash,\n\tamtPaid lnwire.MilliSatoshi, expiry uint32, currentHeight int32,\n\tcircuitKey CircuitKey, hodlChan chan<- interface{},\n\tpayload Payload) (HtlcResolution, error) {\n\n\t// Create the update context containing the relevant details of the\n\t// incoming htlc.\n\tctx := invoiceUpdateCtx{\n\t\thash:                 rHash,\n\t\tcircuitKey:           circuitKey,\n\t\tamtPaid:              amtPaid,\n\t\texpiry:               expiry,\n\t\tcurrentHeight:        currentHeight,\n\t\tfinalCltvRejectDelta: i.cfg.FinalCltvRejectDelta,\n\t\tcustomRecords:        payload.CustomRecords(),\n\t\tmpp:                  payload.MultiPath(),\n\t\tamp:                  payload.AMPRecord(),\n\t\tmetadata:             payload.Metadata(),\n\t}\n\n\tswitch {\n\t// If we are accepting spontaneous AMP payments and this payload\n\t// contains an AMP record, create an AMP invoice that will be settled\n\t// below.\n\tcase i.cfg.AcceptAMP && ctx.amp != nil:\n\t\terr := i.processAMP(ctx)\n\t\tif err != nil {\n\t\t\tctx.log(fmt.Sprintf(\"amp error: %v\", err))\n\n\t\t\treturn NewFailResolution(\n\t\t\t\tcircuitKey, currentHeight, ResultAmpError,\n\t\t\t), nil\n\t\t}\n\n\t// If we are accepting spontaneous keysend payments, create a regular\n\t// invoice that will be settled below. We also enforce that this is only\n\t// done when no AMP payload is present since it will only be settle-able\n\t// by regular HTLCs.\n\tcase i.cfg.AcceptKeySend && ctx.amp == nil:\n\t\terr := i.processKeySend(ctx)\n\t\tif err != nil {\n\t\t\tctx.log(fmt.Sprintf(\"keysend error: %v\", err))\n\n\t\t\treturn NewFailResolution(\n\t\t\t\tcircuitKey, currentHeight, ResultKeySendError,\n\t\t\t), nil\n\t\t}\n\t}\n\n\t// Execute locked notify exit hop logic.\n\ti.Lock()\n\tresolution, invoiceToExpire, err := i.notifyExitHopHtlcLocked(\n\t\t&ctx, hodlChan,\n\t)\n\ti.Unlock()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif invoiceToExpire != nil {\n\t\ti.expiryWatcher.AddInvoices(invoiceToExpire)\n\t}\n\n\tswitch r := resolution.(type) {\n\t// The htlc is held. Start a timer outside the lock if the htlc should\n\t// be auto-released, because otherwise a deadlock may happen with the\n\t// main event loop.\n\tcase *htlcAcceptResolution:\n\t\tif r.autoRelease {\n\t\t\tvar invRef InvoiceRef\n\t\t\tif ctx.amp != nil {\n\t\t\t\tinvRef = InvoiceRefBySetID(*ctx.setID())\n\t\t\t} else {\n\t\t\t\tinvRef = ctx.invoiceRef()\n\t\t\t}\n\n\t\t\terr := i.startHtlcTimer(\n\t\t\t\tinvRef, circuitKey, r.acceptTime,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\t// We return a nil resolution because htlc acceptances are\n\t\t// represented as nil resolutions externally.\n\t\t// TODO(carla) update calling code to handle accept resolutions.\n\t\treturn nil, nil\n\n\t// A direct resolution was received for this htlc.\n\tcase HtlcResolution:\n\t\treturn r, nil\n\n\t// Fail if an unknown resolution type was received.\n\tdefault:\n\t\treturn nil, errors.New(\"invalid resolution type\")\n\t}\n}\n\n// notifyExitHopHtlcLocked is the internal implementation of NotifyExitHopHtlc\n// that should be executed inside the registry lock. The returned invoiceExpiry\n// (if not nil) needs to be added to the expiry watcher outside of the lock.",
      "length": 2872,
      "tokens": 381,
      "embedding": []
    },
    {
      "slug": "func (i *InvoiceRegistry) notifyExitHopHtlcLocked(",
      "content": "func (i *InvoiceRegistry) notifyExitHopHtlcLocked(\n\tctx *invoiceUpdateCtx, hodlChan chan<- interface{}) (\n\tHtlcResolution, invoiceExpiry, error) {\n\n\t// We'll attempt to settle an invoice matching this rHash on disk (if\n\t// one exists). The callback will update the invoice state and/or htlcs.\n\tvar (\n\t\tresolution        HtlcResolution\n\t\tupdateSubscribers bool\n\t)\n\n\tcallback := func(inv *Invoice) (*InvoiceUpdateDesc, error) {\n\t\tupdateDesc, res, err := updateInvoice(ctx, inv)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Only send an update if the invoice state was changed.\n\t\tupdateSubscribers = updateDesc != nil &&\n\t\t\tupdateDesc.State != nil\n\n\t\t// Assign resolution to outer scope variable.\n\t\tresolution = res\n\n\t\treturn updateDesc, nil\n\t}\n\n\tinvoiceRef := ctx.invoiceRef()\n\tsetID := (*SetID)(ctx.setID())\n\tinvoice, err := i.idb.UpdateInvoice(invoiceRef, setID, callback)\n\n\tvar duplicateSetIDErr ErrDuplicateSetID\n\tif errors.As(err, &duplicateSetIDErr) {\n\t\treturn NewFailResolution(\n\t\t\tctx.circuitKey, ctx.currentHeight,\n\t\t\tResultInvoiceNotFound,\n\t\t), nil, nil\n\t}\n\n\tswitch err {\n\tcase ErrInvoiceNotFound:\n\t\t// If the invoice was not found, return a failure resolution\n\t\t// with an invoice not found result.\n\t\treturn NewFailResolution(\n\t\t\tctx.circuitKey, ctx.currentHeight,\n\t\t\tResultInvoiceNotFound,\n\t\t), nil, nil\n\n\tcase ErrInvRefEquivocation:\n\t\treturn NewFailResolution(\n\t\t\tctx.circuitKey, ctx.currentHeight,\n\t\t\tResultInvoiceNotFound,\n\t\t), nil, nil\n\n\tcase nil:\n\n\tdefault:\n\t\tctx.log(err.Error())\n\t\treturn nil, nil, err\n\t}\n\n\tvar invoiceToExpire invoiceExpiry\n\n\tswitch res := resolution.(type) {\n\tcase *HtlcFailResolution:\n\t\t// Inspect latest htlc state on the invoice. If it is found,\n\t\t// we will update the accept height as it was recorded in the\n\t\t// invoice database (which occurs in the case where the htlc\n\t\t// reached the database in a previous call). If the htlc was\n\t\t// not found on the invoice, it was immediately failed so we\n\t\t// send the failure resolution as is, which has the current\n\t\t// height set as the accept height.\n\t\tinvoiceHtlc, ok := invoice.Htlcs[ctx.circuitKey]\n\t\tif ok {\n\t\t\tres.AcceptHeight = int32(invoiceHtlc.AcceptHeight)\n\t\t}\n\n\t\tctx.log(fmt.Sprintf(\"failure resolution result \"+\n\t\t\t\"outcome: %v, at accept height: %v\",\n\t\t\tres.Outcome, res.AcceptHeight))\n\n\t\t// Some failures apply to the entire HTLC set. Break here if\n\t\t// this isn't one of them.\n\t\tif !res.Outcome.IsSetFailure() {\n\t\t\tbreak\n\t\t}\n\n\t\t// Also cancel any HTLCs in the HTLC set that are also in the\n\t\t// canceled state with the same failure result.\n\t\tsetID := ctx.setID()\n\t\tcanceledHtlcSet := invoice.HTLCSet(setID, HtlcStateCanceled)\n\t\tfor key, htlc := range canceledHtlcSet {\n\t\t\thtlcFailResolution := NewFailResolution(\n\t\t\t\tkey, int32(htlc.AcceptHeight), res.Outcome,\n\t\t\t)\n\n\t\t\ti.notifyHodlSubscribers(htlcFailResolution)\n\t\t}\n\n\t// If the htlc was settled, we will settle any previously accepted\n\t// htlcs and notify our peer to settle them.\n\tcase *HtlcSettleResolution:\n\t\tctx.log(fmt.Sprintf(\"settle resolution result \"+\n\t\t\t\"outcome: %v, at accept height: %v\",\n\t\t\tres.Outcome, res.AcceptHeight))\n\n\t\t// Also settle any previously accepted htlcs. If a htlc is\n\t\t// marked as settled, we should follow now and settle the htlc\n\t\t// with our peer.\n\t\tsetID := ctx.setID()\n\t\tsettledHtlcSet := invoice.HTLCSet(setID, HtlcStateSettled)\n\t\tfor key, htlc := range settledHtlcSet {\n\t\t\tpreimage := res.Preimage\n\t\t\tif htlc.AMP != nil && htlc.AMP.Preimage != nil {\n\t\t\t\tpreimage = *htlc.AMP.Preimage\n\t\t\t}\n\n\t\t\t// Notify subscribers that the htlcs should be settled\n\t\t\t// with our peer. Note that the outcome of the\n\t\t\t// resolution is set based on the outcome of the single\n\t\t\t// htlc that we just settled, so may not be accurate\n\t\t\t// for all htlcs.\n\t\t\thtlcSettleResolution := NewSettleResolution(\n\t\t\t\tpreimage, key,\n\t\t\t\tint32(htlc.AcceptHeight), res.Outcome,\n\t\t\t)\n\n\t\t\t// Notify subscribers that the htlc should be settled\n\t\t\t// with our peer.\n\t\t\ti.notifyHodlSubscribers(htlcSettleResolution)\n\t\t}\n\n\t\t// If concurrent payments were attempted to this invoice before\n\t\t// the current one was ultimately settled, cancel back any of\n\t\t// the HTLCs immediately. As a result of the settle, the HTLCs\n\t\t// in other HTLC sets are automatically converted to a canceled\n\t\t// state when updating the invoice.\n\t\t//\n\t\t// TODO(roasbeef): can remove now??\n\t\tcanceledHtlcSet := invoice.HTLCSetCompliment(\n\t\t\tsetID, HtlcStateCanceled,\n\t\t)\n\t\tfor key, htlc := range canceledHtlcSet {\n\t\t\thtlcFailResolution := NewFailResolution(\n\t\t\t\tkey, int32(htlc.AcceptHeight),\n\t\t\t\tResultInvoiceAlreadySettled,\n\t\t\t)\n\n\t\t\ti.notifyHodlSubscribers(htlcFailResolution)\n\t\t}\n\n\t// If we accepted the htlc, subscribe to the hodl invoice and return\n\t// an accept resolution with the htlc's accept time on it.\n\tcase *htlcAcceptResolution:\n\t\tinvoiceHtlc, ok := invoice.Htlcs[ctx.circuitKey]\n\t\tif !ok {\n\t\t\treturn nil, nil, fmt.Errorf(\"accepted htlc: %v not\"+\n\t\t\t\t\" present on invoice: %x\", ctx.circuitKey,\n\t\t\t\tctx.hash[:])\n\t\t}\n\n\t\t// Determine accepted height of this htlc. If the htlc reached\n\t\t// the invoice database (possibly in a previous call to the\n\t\t// invoice registry), we'll take the original accepted height\n\t\t// as it was recorded in the database.\n\t\tacceptHeight := int32(invoiceHtlc.AcceptHeight)\n\n\t\tctx.log(fmt.Sprintf(\"accept resolution result \"+\n\t\t\t\"outcome: %v, at accept height: %v\",\n\t\t\tres.outcome, acceptHeight))\n\n\t\t// Auto-release the htlc if the invoice is still open. It can\n\t\t// only happen for mpp payments that there are htlcs in state\n\t\t// Accepted while the invoice is Open.\n\t\tif invoice.State == ContractOpen {\n\t\t\tres.acceptTime = invoiceHtlc.AcceptTime\n\t\t\tres.autoRelease = true\n\t\t}\n\n\t\t// If we have fully accepted the set of htlcs for this invoice,\n\t\t// we can now add it to our invoice expiry watcher. We do not\n\t\t// add invoices before they are fully accepted, because it is\n\t\t// possible that we MppTimeout the htlcs, and then our relevant\n\t\t// expiry height could change.\n\t\tif res.outcome == resultAccepted {\n\t\t\tinvoiceToExpire = makeInvoiceExpiry(ctx.hash, invoice)\n\t\t}\n\n\t\ti.hodlSubscribe(hodlChan, ctx.circuitKey)\n\n\tdefault:\n\t\tpanic(\"unknown action\")\n\t}\n\n\t// Now that the links have been notified of any state changes to their\n\t// HTLCs, we'll go ahead and notify any clients wiaiting on the invoice\n\t// state changes.\n\tif updateSubscribers {\n\t\t// We'll add a setID onto the notification, but only if this is\n\t\t// an AMP invoice being settled.\n\t\tvar setID *[32]byte\n\t\tif _, ok := resolution.(*HtlcSettleResolution); ok {\n\t\t\tsetID = ctx.setID()\n\t\t}\n\n\t\ti.notifyClients(ctx.hash, invoice, setID)\n\t}\n\n\treturn resolution, invoiceToExpire, nil\n}\n\n// SettleHodlInvoice sets the preimage of a hodl invoice.",
      "length": 6403,
      "tokens": 892,
      "embedding": []
    },
    {
      "slug": "func (i *InvoiceRegistry) SettleHodlInvoice(preimage lntypes.Preimage) error {",
      "content": "func (i *InvoiceRegistry) SettleHodlInvoice(preimage lntypes.Preimage) error {\n\ti.Lock()\n\tdefer i.Unlock()\n\n\tupdateInvoice := func(invoice *Invoice) (\n\t\t*InvoiceUpdateDesc, error) {\n\n\t\tswitch invoice.State {\n\t\tcase ContractOpen:\n\t\t\treturn nil, ErrInvoiceStillOpen\n\n\t\tcase ContractCanceled:\n\t\t\treturn nil, ErrInvoiceAlreadyCanceled\n\n\t\tcase ContractSettled:\n\t\t\treturn nil, ErrInvoiceAlreadySettled\n\t\t}\n\n\t\treturn &InvoiceUpdateDesc{\n\t\t\tState: &InvoiceStateUpdateDesc{\n\t\t\t\tNewState: ContractSettled,\n\t\t\t\tPreimage: &preimage,\n\t\t\t},\n\t\t}, nil\n\t}\n\n\thash := preimage.Hash()\n\tinvoiceRef := InvoiceRefByHash(hash)\n\tinvoice, err := i.idb.UpdateInvoice(invoiceRef, nil, updateInvoice)\n\tif err != nil {\n\t\tlog.Errorf(\"SettleHodlInvoice with preimage %v: %v\",\n\t\t\tpreimage, err)\n\n\t\treturn err\n\t}\n\n\tlog.Debugf(\"Invoice%v: settled with preimage %v\", invoiceRef,\n\t\tinvoice.Terms.PaymentPreimage)\n\n\t// In the callback, we marked the invoice as settled. UpdateInvoice will\n\t// have seen this and should have moved all htlcs that were accepted to\n\t// the settled state. In the loop below, we go through all of these and\n\t// notify links and resolvers that are waiting for resolution. Any htlcs\n\t// that were already settled before, will be notified again. This isn't\n\t// necessary but doesn't hurt either.\n\tfor key, htlc := range invoice.Htlcs {\n\t\tif htlc.State != HtlcStateSettled {\n\t\t\tcontinue\n\t\t}\n\n\t\tresolution := NewSettleResolution(\n\t\t\tpreimage, key, int32(htlc.AcceptHeight), ResultSettled,\n\t\t)\n\n\t\ti.notifyHodlSubscribers(resolution)\n\t}\n\ti.notifyClients(hash, invoice, nil)\n\n\treturn nil\n}\n\n// CancelInvoice attempts to cancel the invoice corresponding to the passed\n// payment hash.",
      "length": 1525,
      "tokens": 191,
      "embedding": []
    },
    {
      "slug": "func (i *InvoiceRegistry) CancelInvoice(payHash lntypes.Hash) error {",
      "content": "func (i *InvoiceRegistry) CancelInvoice(payHash lntypes.Hash) error {\n\treturn i.cancelInvoiceImpl(payHash, true)\n}\n\n// shouldCancel examines the state of an invoice and whether we want to\n// cancel already accepted invoices, taking our force cancel boolean into\n// account. This is pulled out into its own function so that tests that mock\n// cancelInvoiceImpl can reuse this logic.",
      "length": 305,
      "tokens": 49,
      "embedding": []
    },
    {
      "slug": "func shouldCancel(state ContractState, cancelAccepted bool) bool {",
      "content": "func shouldCancel(state ContractState, cancelAccepted bool) bool {\n\tif state != ContractAccepted {\n\t\treturn true\n\t}\n\n\t// If the invoice is accepted, we should only cancel if we want to\n\t// force cancellation of accepted invoices.\n\treturn cancelAccepted\n}\n\n// cancelInvoice attempts to cancel the invoice corresponding to the passed\n// payment hash. Accepted invoices will only be canceled if explicitly\n// requested to do so. It notifies subscribing links and resolvers that\n// the associated htlcs were canceled if they change state.",
      "length": 455,
      "tokens": 75,
      "embedding": []
    },
    {
      "slug": "func (i *InvoiceRegistry) cancelInvoiceImpl(payHash lntypes.Hash,",
      "content": "func (i *InvoiceRegistry) cancelInvoiceImpl(payHash lntypes.Hash,\n\tcancelAccepted bool) error {\n\n\ti.Lock()\n\tdefer i.Unlock()\n\n\tref := InvoiceRefByHash(payHash)\n\tlog.Debugf(\"Invoice%v: canceling invoice\", ref)\n\n\tupdateInvoice := func(invoice *Invoice) (*InvoiceUpdateDesc, error) {\n\t\tif !shouldCancel(invoice.State, cancelAccepted) {\n\t\t\treturn nil, nil\n\t\t}\n\n\t\t// Move invoice to the canceled state. Rely on validation in\n\t\t// channeldb to return an error if the invoice is already\n\t\t// settled or canceled.\n\t\treturn &InvoiceUpdateDesc{\n\t\t\tState: &InvoiceStateUpdateDesc{\n\t\t\t\tNewState: ContractCanceled,\n\t\t\t},\n\t\t}, nil\n\t}\n\n\tinvoiceRef := InvoiceRefByHash(payHash)\n\tinvoice, err := i.idb.UpdateInvoice(invoiceRef, nil, updateInvoice)\n\n\t// Implement idempotency by returning success if the invoice was already\n\t// canceled.\n\tif errors.Is(err, ErrInvoiceAlreadyCanceled) {\n\t\tlog.Debugf(\"Invoice%v: already canceled\", ref)\n\t\treturn nil\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Return without cancellation if the invoice state is ContractAccepted.\n\tif invoice.State == ContractAccepted {\n\t\tlog.Debugf(\"Invoice%v: remains accepted as cancel wasn't\"+\n\t\t\t\"explicitly requested.\", ref)\n\t\treturn nil\n\t}\n\n\tlog.Debugf(\"Invoice%v: canceled\", ref)\n\n\t// In the callback, some htlcs may have been moved to the canceled\n\t// state. We now go through all of these and notify links and resolvers\n\t// that are waiting for resolution. Any htlcs that were already canceled\n\t// before, will be notified again. This isn't necessary but doesn't hurt\n\t// either.\n\tfor key, htlc := range invoice.Htlcs {\n\t\tif htlc.State != HtlcStateCanceled {\n\t\t\tcontinue\n\t\t}\n\n\t\ti.notifyHodlSubscribers(\n\t\t\tNewFailResolution(\n\t\t\t\tkey, int32(htlc.AcceptHeight), ResultCanceled,\n\t\t\t),\n\t\t)\n\t}\n\ti.notifyClients(payHash, invoice, nil)\n\n\t// Attempt to also delete the invoice if requested through the registry\n\t// config.\n\tif i.cfg.GcCanceledInvoicesOnTheFly {\n\t\t// Assemble the delete reference and attempt to delete through\n\t\t// the invocice from the DB.\n\t\tdeleteRef := InvoiceDeleteRef{\n\t\t\tPayHash:     payHash,\n\t\t\tAddIndex:    invoice.AddIndex,\n\t\t\tSettleIndex: invoice.SettleIndex,\n\t\t}\n\t\tif invoice.Terms.PaymentAddr != BlankPayAddr {\n\t\t\tdeleteRef.PayAddr = &invoice.Terms.PaymentAddr\n\t\t}\n\n\t\terr = i.idb.DeleteInvoice([]InvoiceDeleteRef{deleteRef})\n\t\t// If by any chance deletion failed, then log it instead of\n\t\t// returning the error, as the invoice itself has already been\n\t\t// canceled.\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"Invoice %v could not be deleted: %v\", ref,\n\t\t\t\terr)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// notifyClients notifies all currently registered invoice notification clients\n// of a newly added/settled invoice.",
      "length": 2508,
      "tokens": 328,
      "embedding": []
    },
    {
      "slug": "func (i *InvoiceRegistry) notifyClients(hash lntypes.Hash,",
      "content": "func (i *InvoiceRegistry) notifyClients(hash lntypes.Hash,\n\tinvoice *Invoice, setID *[32]byte) {\n\n\tevent := &invoiceEvent{\n\t\tinvoice: invoice,\n\t\thash:    hash,\n\t\tsetID:   setID,\n\t}\n\n\tselect {\n\tcase i.invoiceEvents <- event:\n\tcase <-i.quit:\n\t}\n}\n\n// invoiceSubscriptionKit defines that are common to both all invoice\n// subscribers and single invoice subscribers.",
      "length": 288,
      "tokens": 41,
      "embedding": []
    },
    {
      "slug": "type invoiceSubscriptionKit struct {",
      "content": "type invoiceSubscriptionKit struct {\n\tid uint32 // nolint:structcheck\n\n\t// quit is a chan mouted to InvoiceRegistry that signals a shutdown.\n\tquit chan struct{}\n\n\tntfnQueue *queue.ConcurrentQueue\n\n\tcanceled   uint32 // To be used atomically.\n\tcancelChan chan struct{}\n\n\t// backlogDelivered is closed when the backlog events have been\n\t// delivered.\n\tbacklogDelivered chan struct{}\n}\n\n// InvoiceSubscription represents an intent to receive updates for newly added\n// or settled invoices. For each newly added invoice, a copy of the invoice\n// will be sent over the NewInvoices channel. Similarly, for each newly settled\n// invoice, a copy of the invoice will be sent over the SettledInvoices\n// channel.",
      "length": 646,
      "tokens": 100,
      "embedding": []
    },
    {
      "slug": "type InvoiceSubscription struct {",
      "content": "type InvoiceSubscription struct {\n\tinvoiceSubscriptionKit\n\n\t// NewInvoices is a channel that we'll use to send all newly created\n\t// invoices with an invoice index greater than the specified\n\t// StartingInvoiceIndex field.\n\tNewInvoices chan *Invoice\n\n\t// SettledInvoices is a channel that we'll use to send all settled\n\t// invoices with an invoices index greater than the specified\n\t// StartingInvoiceIndex field.\n\tSettledInvoices chan *Invoice\n\n\t// addIndex is the highest add index the caller knows of. We'll use\n\t// this information to send out an event backlog to the notifications\n\t// subscriber. Any new add events with an index greater than this will\n\t// be dispatched before any new notifications are sent out.\n\taddIndex uint64\n\n\t// settleIndex is the highest settle index the caller knows of. We'll\n\t// use this information to send out an event backlog to the\n\t// notifications subscriber. Any new settle events with an index\n\t// greater than this will be dispatched before any new notifications\n\t// are sent out.\n\tsettleIndex uint64\n}\n\n// SingleInvoiceSubscription represents an intent to receive updates for a\n// specific invoice.",
      "length": 1080,
      "tokens": 173,
      "embedding": []
    },
    {
      "slug": "type SingleInvoiceSubscription struct {",
      "content": "type SingleInvoiceSubscription struct {\n\tinvoiceSubscriptionKit\n\n\tinvoiceRef InvoiceRef\n\n\t// Updates is a channel that we'll use to send all invoice events for\n\t// the invoice that is subscribed to.\n\tUpdates chan *Invoice\n}\n\n// PayHash returns the optional payment hash of the target invoice.\n//\n// TODO(positiveblue): This method is only supposed to be used in tests. It will\n// be deleted as soon as invoiceregistery_test is in the same module.",
      "length": 394,
      "tokens": 66,
      "embedding": []
    },
    {
      "slug": "func (s *SingleInvoiceSubscription) PayHash() *lntypes.Hash {",
      "content": "func (s *SingleInvoiceSubscription) PayHash() *lntypes.Hash {\n\treturn s.invoiceRef.PayHash()\n}\n\n// Cancel unregisters the InvoiceSubscription, freeing any previously allocated\n// resources.",
      "length": 123,
      "tokens": 14,
      "embedding": []
    },
    {
      "slug": "func (i *invoiceSubscriptionKit) Cancel() {",
      "content": "func (i *invoiceSubscriptionKit) Cancel() {\n\tif !atomic.CompareAndSwapUint32(&i.canceled, 0, 1) {\n\t\treturn\n\t}\n\n\ti.ntfnQueue.Stop()\n\tclose(i.cancelChan)\n}\n",
      "length": 103,
      "tokens": 10,
      "embedding": []
    },
    {
      "slug": "func (i *invoiceSubscriptionKit) notify(event *invoiceEvent) error {",
      "content": "func (i *invoiceSubscriptionKit) notify(event *invoiceEvent) error {\n\tselect {\n\tcase i.ntfnQueue.ChanIn() <- event:\n\n\tcase <-i.cancelChan:\n\t\t// This can only be triggered by delivery of non-backlog\n\t\t// events.\n\t\treturn ErrShuttingDown\n\tcase <-i.quit:\n\t\treturn ErrShuttingDown\n\t}\n\n\treturn nil\n}\n\n// SubscribeNotifications returns an InvoiceSubscription which allows the\n// caller to receive async notifications when any invoices are settled or\n// added. The invoiceIndex parameter is a streaming \"checkpoint\". We'll start\n// by first sending out all new events with an invoice index _greater_ than\n// this value. Afterwards, we'll send out real-time notifications.",
      "length": 577,
      "tokens": 84,
      "embedding": []
    },
    {
      "slug": "func (i *InvoiceRegistry) SubscribeNotifications(",
      "content": "func (i *InvoiceRegistry) SubscribeNotifications(\n\taddIndex, settleIndex uint64) (*InvoiceSubscription, error) {\n\n\tclient := &InvoiceSubscription{\n\t\tNewInvoices:     make(chan *Invoice),\n\t\tSettledInvoices: make(chan *Invoice),\n\t\taddIndex:        addIndex,\n\t\tsettleIndex:     settleIndex,\n\t\tinvoiceSubscriptionKit: invoiceSubscriptionKit{\n\t\t\tquit:             i.quit,\n\t\t\tntfnQueue:        queue.NewConcurrentQueue(20),\n\t\t\tcancelChan:       make(chan struct{}),\n\t\t\tbacklogDelivered: make(chan struct{}),\n\t\t},\n\t}\n\tclient.ntfnQueue.Start()\n\n\t// This notifies other goroutines that the backlog phase is over.\n\tdefer close(client.backlogDelivered)\n\n\t// Always increment by 1 first, and our client ID will start with 1,\n\t// not 0.\n\tclient.id = atomic.AddUint32(&i.nextClientID, 1)\n\n\t// Before we register this new invoice subscription, we'll launch a new\n\t// goroutine that will proxy all notifications appended to the end of\n\t// the concurrent queue to the two client-side channels the caller will\n\t// feed off of.\n\ti.wg.Add(1)\n\tgo func() {\n\t\tdefer i.wg.Done()\n\t\tdefer i.deleteClient(client.id)\n\n\t\tfor {\n\t\t\tselect {\n\t\t\t// A new invoice event has been sent by the\n\t\t\t// invoiceRegistry! We'll figure out if this is an add\n\t\t\t// event or a settle event, then dispatch the event to\n\t\t\t// the client.\n\t\t\tcase ntfn := <-client.ntfnQueue.ChanOut():\n\t\t\t\tinvoiceEvent := ntfn.(*invoiceEvent)\n\n\t\t\t\tvar targetChan chan *Invoice\n\t\t\t\tstate := invoiceEvent.invoice.State\n\t\t\t\tswitch {\n\t\t\t\t// AMP invoices never move to settled, but will\n\t\t\t\t// be sent with a set ID if an HTLC set is\n\t\t\t\t// being settled.\n\t\t\t\tcase state == ContractOpen &&\n\t\t\t\t\tinvoiceEvent.setID != nil:\n\t\t\t\t\tfallthrough\n\n\t\t\t\tcase state == ContractSettled:\n\t\t\t\t\ttargetChan = client.SettledInvoices\n\n\t\t\t\tcase state == ContractOpen:\n\t\t\t\t\ttargetChan = client.NewInvoices\n\n\t\t\t\tdefault:\n\t\t\t\t\tlog.Errorf(\"unknown invoice state: %v\",\n\t\t\t\t\t\tstate)\n\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tselect {\n\t\t\t\tcase targetChan <- invoiceEvent.invoice:\n\n\t\t\t\tcase <-client.cancelChan:\n\t\t\t\t\treturn\n\n\t\t\t\tcase <-i.quit:\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\tcase <-client.cancelChan:\n\t\t\t\treturn\n\n\t\t\tcase <-i.quit:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\ti.notificationClientMux.Lock()\n\ti.notificationClients[client.id] = client\n\ti.notificationClientMux.Unlock()\n\n\t// Query the database to see if based on the provided addIndex and\n\t// settledIndex we need to deliver any backlog notifications.\n\terr := i.deliverBacklogEvents(client)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tlog.Infof(\"New invoice subscription client: id=%v\", client.id)\n\n\treturn client, nil\n}\n\n// SubscribeSingleInvoice returns an SingleInvoiceSubscription which allows the\n// caller to receive async notifications for a specific invoice.",
      "length": 2536,
      "tokens": 314,
      "embedding": []
    },
    {
      "slug": "func (i *InvoiceRegistry) SubscribeSingleInvoice(",
      "content": "func (i *InvoiceRegistry) SubscribeSingleInvoice(\n\thash lntypes.Hash) (*SingleInvoiceSubscription, error) {\n\n\tclient := &SingleInvoiceSubscription{\n\t\tUpdates: make(chan *Invoice),\n\t\tinvoiceSubscriptionKit: invoiceSubscriptionKit{\n\t\t\tquit:             i.quit,\n\t\t\tntfnQueue:        queue.NewConcurrentQueue(20),\n\t\t\tcancelChan:       make(chan struct{}),\n\t\t\tbacklogDelivered: make(chan struct{}),\n\t\t},\n\t\tinvoiceRef: InvoiceRefByHash(hash),\n\t}\n\tclient.ntfnQueue.Start()\n\n\t// This notifies other goroutines that the backlog phase is done.\n\tdefer close(client.backlogDelivered)\n\n\t// Always increment by 1 first, and our client ID will start with 1,\n\t// not 0.\n\tclient.id = atomic.AddUint32(&i.nextClientID, 1)\n\n\t// Before we register this new invoice subscription, we'll launch a new\n\t// goroutine that will proxy all notifications appended to the end of\n\t// the concurrent queue to the two client-side channels the caller will\n\t// feed off of.\n\ti.wg.Add(1)\n\tgo func() {\n\t\tdefer i.wg.Done()\n\t\tdefer i.deleteClient(client.id)\n\n\t\tfor {\n\t\t\tselect {\n\t\t\t// A new invoice event has been sent by the\n\t\t\t// invoiceRegistry. We will dispatch the event to the\n\t\t\t// client.\n\t\t\tcase ntfn := <-client.ntfnQueue.ChanOut():\n\t\t\t\tinvoiceEvent := ntfn.(*invoiceEvent)\n\n\t\t\t\tselect {\n\t\t\t\tcase client.Updates <- invoiceEvent.invoice:\n\n\t\t\t\tcase <-client.cancelChan:\n\t\t\t\t\treturn\n\n\t\t\t\tcase <-i.quit:\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\tcase <-client.cancelChan:\n\t\t\t\treturn\n\n\t\t\tcase <-i.quit:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\ti.notificationClientMux.Lock()\n\ti.singleNotificationClients[client.id] = client\n\ti.notificationClientMux.Unlock()\n\n\terr := i.deliverSingleBacklogEvents(client)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tlog.Infof(\"New single invoice subscription client: id=%v, ref=%v\",\n\t\tclient.id, client.invoiceRef)\n\n\treturn client, nil\n}\n\n// notifyHodlSubscribers sends out the htlc resolution to all current\n// subscribers.",
      "length": 1761,
      "tokens": 206,
      "embedding": []
    },
    {
      "slug": "func (i *InvoiceRegistry) notifyHodlSubscribers(htlcResolution HtlcResolution) {",
      "content": "func (i *InvoiceRegistry) notifyHodlSubscribers(htlcResolution HtlcResolution) {\n\ti.hodlSubscriptionsMux.Lock()\n\tdefer i.hodlSubscriptionsMux.Unlock()\n\n\tsubscribers, ok := i.hodlSubscriptions[htlcResolution.CircuitKey()]\n\tif !ok {\n\t\treturn\n\t}\n\n\t// Notify all interested subscribers and remove subscription from both\n\t// maps. The subscription can be removed as there only ever will be a\n\t// single resolution for each hash.\n\tfor subscriber := range subscribers {\n\t\tselect {\n\t\tcase subscriber <- htlcResolution:\n\t\tcase <-i.quit:\n\t\t\treturn\n\t\t}\n\n\t\tdelete(\n\t\t\ti.hodlReverseSubscriptions[subscriber],\n\t\t\thtlcResolution.CircuitKey(),\n\t\t)\n\t}\n\n\tdelete(i.hodlSubscriptions, htlcResolution.CircuitKey())\n}\n\n// hodlSubscribe adds a new invoice subscription.",
      "length": 638,
      "tokens": 73,
      "embedding": []
    },
    {
      "slug": "func (i *InvoiceRegistry) hodlSubscribe(subscriber chan<- interface{},",
      "content": "func (i *InvoiceRegistry) hodlSubscribe(subscriber chan<- interface{},\n\tcircuitKey CircuitKey) {\n\n\ti.hodlSubscriptionsMux.Lock()\n\tdefer i.hodlSubscriptionsMux.Unlock()\n\n\tlog.Debugf(\"Hodl subscribe for %v\", circuitKey)\n\n\tsubscriptions, ok := i.hodlSubscriptions[circuitKey]\n\tif !ok {\n\t\tsubscriptions = make(map[chan<- interface{}]struct{})\n\t\ti.hodlSubscriptions[circuitKey] = subscriptions\n\t}\n\tsubscriptions[subscriber] = struct{}{}\n\n\treverseSubscriptions, ok := i.hodlReverseSubscriptions[subscriber]\n\tif !ok {\n\t\treverseSubscriptions = make(map[CircuitKey]struct{})\n\t\ti.hodlReverseSubscriptions[subscriber] = reverseSubscriptions\n\t}\n\treverseSubscriptions[circuitKey] = struct{}{}\n}\n\n// HodlUnsubscribeAll cancels the subscription.",
      "length": 637,
      "tokens": 52,
      "embedding": []
    },
    {
      "slug": "func (i *InvoiceRegistry) HodlUnsubscribeAll(subscriber chan<- interface{}) {",
      "content": "func (i *InvoiceRegistry) HodlUnsubscribeAll(subscriber chan<- interface{}) {\n\ti.hodlSubscriptionsMux.Lock()\n\tdefer i.hodlSubscriptionsMux.Unlock()\n\n\thashes := i.hodlReverseSubscriptions[subscriber]\n\tfor hash := range hashes {\n\t\tdelete(i.hodlSubscriptions[hash], subscriber)\n\t}\n\n\tdelete(i.hodlReverseSubscriptions, subscriber)\n}\n\n// copySingleClients copies i.SingleInvoiceSubscription inside a lock. This is\n// useful when we need to iterate the map to send notifications.",
      "length": 383,
      "tokens": 39,
      "embedding": []
    },
    {
      "slug": "func (i *InvoiceRegistry) copySingleClients() map[uint32]*SingleInvoiceSubscription { //nolint:lll",
      "content": "func (i *InvoiceRegistry) copySingleClients() map[uint32]*SingleInvoiceSubscription { //nolint:lll\n\ti.notificationClientMux.RLock()\n\tdefer i.notificationClientMux.RUnlock()\n\n\tclients := make(map[uint32]*SingleInvoiceSubscription)\n\tfor k, v := range i.singleNotificationClients {\n\t\tclients[k] = v\n\t}\n\treturn clients\n}\n\n// copyClients copies i.notificationClients inside a lock. This is useful when\n// we need to iterate the map to send notifications.",
      "length": 339,
      "tokens": 41,
      "embedding": []
    },
    {
      "slug": "func (i *InvoiceRegistry) copyClients() map[uint32]*InvoiceSubscription {",
      "content": "func (i *InvoiceRegistry) copyClients() map[uint32]*InvoiceSubscription {\n\ti.notificationClientMux.RLock()\n\tdefer i.notificationClientMux.RUnlock()\n\n\tclients := make(map[uint32]*InvoiceSubscription)\n\tfor k, v := range i.notificationClients {\n\t\tclients[k] = v\n\t}\n\treturn clients\n}\n\n// deleteClient removes a client by its ID inside a lock. Noop if the client is\n// not found.",
      "length": 289,
      "tokens": 39,
      "embedding": []
    },
    {
      "slug": "func (i *InvoiceRegistry) deleteClient(clientID uint32) {",
      "content": "func (i *InvoiceRegistry) deleteClient(clientID uint32) {\n\ti.notificationClientMux.Lock()\n\tdefer i.notificationClientMux.Unlock()\n\n\tlog.Infof(\"Cancelling invoice subscription for client=%v\", clientID)\n\tdelete(i.notificationClients, clientID)\n\tdelete(i.singleNotificationClients, clientID)\n}\n",
      "length": 226,
      "tokens": 14,
      "embedding": []
    }
  ]
}