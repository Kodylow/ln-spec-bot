{
  "filepath": "../implementations/go/lnd/invoices/invoiceregistry_test.go",
  "package": "invoices_test",
  "sections": [
    {
      "slug": "func TestSettleInvoice(t *testing.T) {",
      "content": "func TestSettleInvoice(t *testing.T) {\n\tctx := newTestContext(t, nil)\n\n\tallSubscriptions, err := ctx.registry.SubscribeNotifications(0, 0)\n\trequire.Nil(t, err)\n\tdefer allSubscriptions.Cancel()\n\n\t// Subscribe to the not yet existing invoice.\n\tsubscription, err := ctx.registry.SubscribeSingleInvoice(\n\t\ttestInvoicePaymentHash,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer subscription.Cancel()\n\n\trequire.Equal(t, subscription.PayHash(), &testInvoicePaymentHash)\n\n\t// Add the invoice.\n\taddIdx, err := ctx.registry.AddInvoice(\n\t\ttestInvoice, testInvoicePaymentHash,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif addIdx != 1 {\n\t\tt.Fatalf(\"expected addIndex to start with 1, but got %v\",\n\t\t\taddIdx)\n\t}\n\n\t// We expect the open state to be sent to the single invoice subscriber.\n\tselect {\n\tcase update := <-subscription.Updates:\n\t\tif update.State != invpkg.ContractOpen {\n\t\t\tt.Fatalf(\"expected state ContractOpen, but got %v\",\n\t\t\t\tupdate.State)\n\t\t}\n\tcase <-time.After(testTimeout):\n\t\tt.Fatal(\"no update received\")\n\t}\n\n\t// We expect a new invoice notification to be sent out.\n\tselect {\n\tcase newInvoice := <-allSubscriptions.NewInvoices:\n\t\tif newInvoice.State != invpkg.ContractOpen {\n\t\t\tt.Fatalf(\"expected state ContractOpen, but got %v\",\n\t\t\t\tnewInvoice.State)\n\t\t}\n\tcase <-time.After(testTimeout):\n\t\tt.Fatal(\"no update received\")\n\t}\n\n\thodlChan := make(chan interface{}, 1)\n\n\t// Try to settle invoice with an htlc that expires too soon.\n\tresolution, err := ctx.registry.NotifyExitHopHtlc(\n\t\ttestInvoicePaymentHash, testInvoice.Terms.Value,\n\t\tuint32(testCurrentHeight)+testInvoiceCltvDelta-1,\n\t\ttestCurrentHeight, getCircuitKey(10), hodlChan, testPayload,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\trequire.NotNil(t, resolution)\n\tfailResolution := checkFailResolution(\n\t\tt, resolution, invpkg.ResultExpiryTooSoon,\n\t)\n\trequire.Equal(t, testCurrentHeight, failResolution.AcceptHeight)\n\n\t// Settle invoice with a slightly higher amount.\n\tamtPaid := lnwire.MilliSatoshi(100500)\n\tresolution, err = ctx.registry.NotifyExitHopHtlc(\n\t\ttestInvoicePaymentHash, amtPaid, testHtlcExpiry,\n\t\ttestCurrentHeight, getCircuitKey(0), hodlChan,\n\t\ttestPayload,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\trequire.NotNil(t, resolution)\n\tsettleResolution := checkSettleResolution(\n\t\tt, resolution, testInvoicePreimage,\n\t)\n\trequire.Equal(t, invpkg.ResultSettled, settleResolution.Outcome)\n\n\t// We expect the settled state to be sent to the single invoice\n\t// subscriber.\n\tselect {\n\tcase update := <-subscription.Updates:\n\t\tif update.State != invpkg.ContractSettled {\n\t\t\tt.Fatalf(\"expected state ContractOpen, but got %v\",\n\t\t\t\tupdate.State)\n\t\t}\n\t\tif update.AmtPaid != amtPaid {\n\t\t\tt.Fatal(\"invoice AmtPaid incorrect\")\n\t\t}\n\tcase <-time.After(testTimeout):\n\t\tt.Fatal(\"no update received\")\n\t}\n\n\t// We expect a settled notification to be sent out.\n\tselect {\n\tcase settledInvoice := <-allSubscriptions.SettledInvoices:\n\t\tif settledInvoice.State != invpkg.ContractSettled {\n\t\t\tt.Fatalf(\"expected state ContractOpen, but got %v\",\n\t\t\t\tsettledInvoice.State)\n\t\t}\n\tcase <-time.After(testTimeout):\n\t\tt.Fatal(\"no update received\")\n\t}\n\n\t// Try to settle again with the same htlc id. We need this idempotent\n\t// behaviour after a restart.\n\tresolution, err = ctx.registry.NotifyExitHopHtlc(\n\t\ttestInvoicePaymentHash, amtPaid, testHtlcExpiry,\n\t\ttestCurrentHeight, getCircuitKey(0), hodlChan, testPayload,\n\t)\n\trequire.NoError(t, err, \"unexpected NotifyExitHopHtlc error\")\n\trequire.NotNil(t, resolution)\n\tsettleResolution = checkSettleResolution(\n\t\tt, resolution, testInvoicePreimage,\n\t)\n\trequire.Equal(t, invpkg.ResultReplayToSettled, settleResolution.Outcome)\n\n\t// Try to settle again with a new higher-valued htlc. This payment\n\t// should also be accepted, to prevent any change in behaviour for a\n\t// paid invoice that may open up a probe vector.\n\tresolution, err = ctx.registry.NotifyExitHopHtlc(\n\t\ttestInvoicePaymentHash, amtPaid+600, testHtlcExpiry,\n\t\ttestCurrentHeight, getCircuitKey(1), hodlChan, testPayload,\n\t)\n\trequire.NoError(t, err, \"unexpected NotifyExitHopHtlc error\")\n\trequire.NotNil(t, resolution)\n\tsettleResolution = checkSettleResolution(\n\t\tt, resolution, testInvoicePreimage,\n\t)\n\trequire.Equal(\n\t\tt, invpkg.ResultDuplicateToSettled, settleResolution.Outcome,\n\t)\n\n\t// Try to settle again with a lower amount. This should fail just as it\n\t// would have failed if it were the first payment.\n\tresolution, err = ctx.registry.NotifyExitHopHtlc(\n\t\ttestInvoicePaymentHash, amtPaid-600, testHtlcExpiry,\n\t\ttestCurrentHeight, getCircuitKey(2), hodlChan, testPayload,\n\t)\n\trequire.NoError(t, err, \"unexpected NotifyExitHopHtlc error\")\n\trequire.NotNil(t, resolution)\n\tcheckFailResolution(t, resolution, invpkg.ResultAmountTooLow)\n\n\t// Check that settled amount is equal to the sum of values of the htlcs\n\t// 0 and 1.\n\tinv, err := ctx.registry.LookupInvoice(testInvoicePaymentHash)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif inv.AmtPaid != amtPaid+amtPaid+600 {\n\t\tt.Fatalf(\"amount incorrect: expected %v got %v\",\n\t\t\tamtPaid+amtPaid+600, inv.AmtPaid)\n\t}\n\n\t// Try to cancel.\n\terr = ctx.registry.CancelInvoice(testInvoicePaymentHash)\n\trequire.ErrorIs(t, err, invpkg.ErrInvoiceAlreadySettled)\n\n\t// As this is a direct settle, we expect nothing on the hodl chan.\n\tselect {\n\tcase <-hodlChan:\n\t\tt.Fatal(\"unexpected resolution\")\n\tdefault:\n\t}\n}\n",
      "length": 5062,
      "tokens": 560,
      "embedding": []
    },
    {
      "slug": "func testCancelInvoice(t *testing.T, gc bool) {",
      "content": "func testCancelInvoice(t *testing.T, gc bool) {\n\tcfg := defaultRegistryConfig()\n\n\t// If set to true, then also delete the invoice from the DB after\n\t// cancellation.\n\tcfg.GcCanceledInvoicesOnTheFly = gc\n\tctx := newTestContext(t, &cfg)\n\n\tallSubscriptions, err := ctx.registry.SubscribeNotifications(0, 0)\n\trequire.Nil(t, err)\n\tdefer allSubscriptions.Cancel()\n\n\t// Try to cancel the not yet existing invoice. This should fail.\n\terr = ctx.registry.CancelInvoice(testInvoicePaymentHash)\n\trequire.ErrorIs(t, err, invpkg.ErrInvoiceNotFound)\n\n\t// Subscribe to the not yet existing invoice.\n\tsubscription, err := ctx.registry.SubscribeSingleInvoice(\n\t\ttestInvoicePaymentHash,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer subscription.Cancel()\n\n\trequire.Equal(t, subscription.PayHash(), &testInvoicePaymentHash)\n\n\t// Add the invoice.\n\tamt := lnwire.MilliSatoshi(100000)\n\t_, err = ctx.registry.AddInvoice(testInvoice, testInvoicePaymentHash)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// We expect the open state to be sent to the single invoice subscriber.\n\tselect {\n\tcase update := <-subscription.Updates:\n\t\tif update.State != invpkg.ContractOpen {\n\t\t\tt.Fatalf(\n\t\t\t\t\"expected state ContractOpen, but got %v\",\n\t\t\t\tupdate.State,\n\t\t\t)\n\t\t}\n\tcase <-time.After(testTimeout):\n\t\tt.Fatal(\"no update received\")\n\t}\n\n\t// We expect a new invoice notification to be sent out.\n\tselect {\n\tcase newInvoice := <-allSubscriptions.NewInvoices:\n\t\tif newInvoice.State != invpkg.ContractOpen {\n\t\t\tt.Fatalf(\n\t\t\t\t\"expected state ContractOpen, but got %v\",\n\t\t\t\tnewInvoice.State,\n\t\t\t)\n\t\t}\n\tcase <-time.After(testTimeout):\n\t\tt.Fatal(\"no update received\")\n\t}\n\n\t// Cancel invoice.\n\terr = ctx.registry.CancelInvoice(testInvoicePaymentHash)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// We expect the canceled state to be sent to the single invoice\n\t// subscriber.\n\tselect {\n\tcase update := <-subscription.Updates:\n\t\tif update.State != invpkg.ContractCanceled {\n\t\t\tt.Fatalf(\n\t\t\t\t\"expected state ContractCanceled, but got %v\",\n\t\t\t\tupdate.State,\n\t\t\t)\n\t\t}\n\tcase <-time.After(testTimeout):\n\t\tt.Fatal(\"no update received\")\n\t}\n\n\tif gc {\n\t\t// Check that the invoice has been deleted from the db.\n\t\t_, err = ctx.idb.LookupInvoice(\n\t\t\tinvpkg.InvoiceRefByHash(testInvoicePaymentHash),\n\t\t)\n\t\trequire.Error(t, err)\n\t}\n\n\t// We expect no cancel notification to be sent to all invoice\n\t// subscribers (backwards compatibility).\n\n\t// Try to cancel again. Expect that we report ErrInvoiceNotFound if the\n\t// invoice has been garbage collected (since the invoice has been\n\t// deleted when it was canceled), and no error otherwise.\n\terr = ctx.registry.CancelInvoice(testInvoicePaymentHash)\n\n\tif gc {\n\t\trequire.Error(t, err, invpkg.ErrInvoiceNotFound)\n\t} else {\n\t\trequire.NoError(t, err)\n\t}\n\n\t// Notify arrival of a new htlc paying to this invoice. This should\n\t// result in a cancel resolution.\n\thodlChan := make(chan interface{})\n\tresolution, err := ctx.registry.NotifyExitHopHtlc(\n\t\ttestInvoicePaymentHash, amt, testHtlcExpiry, testCurrentHeight,\n\t\tgetCircuitKey(0), hodlChan, testPayload,\n\t)\n\tif err != nil {\n\t\tt.Fatal(\"expected settlement of a canceled invoice to succeed\")\n\t}\n\trequire.NotNil(t, resolution)\n\n\t// If the invoice has been deleted (or not present) then we expect the\n\t// outcome to be ResultInvoiceNotFound instead of when the invoice is\n\t// in our database in which case we expect ResultInvoiceAlreadyCanceled.\n\tvar failResolution *invpkg.HtlcFailResolution\n\tif gc {\n\t\tfailResolution = checkFailResolution(\n\t\t\tt, resolution, invpkg.ResultInvoiceNotFound,\n\t\t)\n\t} else {\n\t\tfailResolution = checkFailResolution(\n\t\t\tt, resolution, invpkg.ResultInvoiceAlreadyCanceled,\n\t\t)\n\t}\n\n\trequire.Equal(t, testCurrentHeight, failResolution.AcceptHeight)\n}\n\n// TestCancelInvoice tests cancellation of an invoice and related notifications.",
      "length": 3591,
      "tokens": 443,
      "embedding": []
    },
    {
      "slug": "func TestCancelInvoice(t *testing.T) {",
      "content": "func TestCancelInvoice(t *testing.T) {\n\t// Test cancellation both with garbage collection (meaning that canceled\n\t// invoice will be deleted) and without (meaning it'll be kept).\n\tt.Run(\"garbage collect\", func(t *testing.T) {\n\t\ttestCancelInvoice(t, true)\n\t})\n\n\tt.Run(\"no garbage collect\", func(t *testing.T) {\n\t\ttestCancelInvoice(t, false)\n\t})\n}\n\n// TestSettleHoldInvoice tests settling of a hold invoice and related\n// notifications.",
      "length": 383,
      "tokens": 51,
      "embedding": []
    },
    {
      "slug": "func TestSettleHoldInvoice(t *testing.T) {",
      "content": "func TestSettleHoldInvoice(t *testing.T) {\n\tdefer timeout()()\n\n\tidb, err := newTestChannelDB(t, clock.NewTestClock(time.Time{}))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Instantiate and start the invoice ctx.registry.\n\tcfg := invpkg.RegistryConfig{\n\t\tFinalCltvRejectDelta: testFinalCltvRejectDelta,\n\t\tClock:                clock.NewTestClock(testTime),\n\t}\n\n\texpiryWatcher := invpkg.NewInvoiceExpiryWatcher(\n\t\tcfg.Clock, 0, uint32(testCurrentHeight), nil, newMockNotifier(),\n\t)\n\tregistry := invpkg.NewRegistry(idb, expiryWatcher, &cfg)\n\n\terr = registry.Start()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer registry.Stop()\n\n\tallSubscriptions, err := registry.SubscribeNotifications(0, 0)\n\trequire.Nil(t, err)\n\tdefer allSubscriptions.Cancel()\n\n\t// Subscribe to the not yet existing invoice.\n\tsubscription, err := registry.SubscribeSingleInvoice(\n\t\ttestInvoicePaymentHash,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer subscription.Cancel()\n\n\trequire.Equal(t, subscription.PayHash(), &testInvoicePaymentHash)\n\n\t// Add the invoice.\n\t_, err = registry.AddInvoice(testHodlInvoice, testInvoicePaymentHash)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// We expect the open state to be sent to the single invoice subscriber.\n\tupdate := <-subscription.Updates\n\tif update.State != invpkg.ContractOpen {\n\t\tt.Fatalf(\"expected state ContractOpen, but got %v\",\n\t\t\tupdate.State)\n\t}\n\n\t// We expect a new invoice notification to be sent out.\n\tnewInvoice := <-allSubscriptions.NewInvoices\n\tif newInvoice.State != invpkg.ContractOpen {\n\t\tt.Fatalf(\"expected state ContractOpen, but got %v\",\n\t\t\tnewInvoice.State)\n\t}\n\n\t// Use slightly higher amount for accept/settle.\n\tamtPaid := lnwire.MilliSatoshi(100500)\n\n\thodlChan := make(chan interface{}, 1)\n\n\t// NotifyExitHopHtlc without a preimage present in the invoice registry\n\t// should be possible.\n\tresolution, err := registry.NotifyExitHopHtlc(\n\t\ttestInvoicePaymentHash, amtPaid, testHtlcExpiry,\n\t\ttestCurrentHeight, getCircuitKey(0), hodlChan, testPayload,\n\t)\n\tif err != nil {\n\t\tt.Fatalf(\"expected settle to succeed but got %v\", err)\n\t}\n\tif resolution != nil {\n\t\tt.Fatalf(\"expected htlc to be held\")\n\t}\n\n\t// Test idempotency.\n\tresolution, err = registry.NotifyExitHopHtlc(\n\t\ttestInvoicePaymentHash, amtPaid, testHtlcExpiry,\n\t\ttestCurrentHeight, getCircuitKey(0), hodlChan, testPayload,\n\t)\n\tif err != nil {\n\t\tt.Fatalf(\"expected settle to succeed but got %v\", err)\n\t}\n\tif resolution != nil {\n\t\tt.Fatalf(\"expected htlc to be held\")\n\t}\n\n\t// Test replay at a higher height. We expect the same result because it\n\t// is a replay.\n\tresolution, err = registry.NotifyExitHopHtlc(\n\t\ttestInvoicePaymentHash, amtPaid, testHtlcExpiry,\n\t\ttestCurrentHeight+10, getCircuitKey(0), hodlChan, testPayload,\n\t)\n\tif err != nil {\n\t\tt.Fatalf(\"expected settle to succeed but got %v\", err)\n\t}\n\tif resolution != nil {\n\t\tt.Fatalf(\"expected htlc to be held\")\n\t}\n\n\t// Test a new htlc coming in that doesn't meet the final cltv delta\n\t// requirement. It should be rejected.\n\tresolution, err = registry.NotifyExitHopHtlc(\n\t\ttestInvoicePaymentHash, amtPaid, 1, testCurrentHeight,\n\t\tgetCircuitKey(1), hodlChan, testPayload,\n\t)\n\tif err != nil {\n\t\tt.Fatalf(\"expected settle to succeed but got %v\", err)\n\t}\n\trequire.NotNil(t, resolution)\n\tcheckFailResolution(t, resolution, invpkg.ResultExpiryTooSoon)\n\n\t// We expect the accepted state to be sent to the single invoice\n\t// subscriber. For all invoice subscribers, we don't expect an update.\n\t// Those only get notified on settle.\n\tupdate = <-subscription.Updates\n\tif update.State != invpkg.ContractAccepted {\n\t\tt.Fatalf(\"expected state ContractAccepted, but got %v\",\n\t\t\tupdate.State)\n\t}\n\tif update.AmtPaid != amtPaid {\n\t\tt.Fatal(\"invoice AmtPaid incorrect\")\n\t}\n\n\t// Settling with preimage should succeed.\n\terr = registry.SettleHodlInvoice(testInvoicePreimage)\n\tif err != nil {\n\t\tt.Fatal(\"expected set preimage to succeed\")\n\t}\n\n\thtlcResolution, _ := (<-hodlChan).(invpkg.HtlcResolution)\n\trequire.NotNil(t, htlcResolution)\n\tsettleResolution := checkSettleResolution(\n\t\tt, htlcResolution, testInvoicePreimage,\n\t)\n\trequire.Equal(t, testCurrentHeight, settleResolution.AcceptHeight)\n\trequire.Equal(t, invpkg.ResultSettled, settleResolution.Outcome)\n\n\t// We expect a settled notification to be sent out for both all and\n\t// single invoice subscribers.\n\tsettledInvoice := <-allSubscriptions.SettledInvoices\n\tif settledInvoice.State != invpkg.ContractSettled {\n\t\tt.Fatalf(\"expected state ContractSettled, but got %v\",\n\t\t\tsettledInvoice.State)\n\t}\n\tif settledInvoice.AmtPaid != amtPaid {\n\t\tt.Fatalf(\"expected amount to be %v, but got %v\",\n\t\t\tamtPaid, settledInvoice.AmtPaid)\n\t}\n\n\tupdate = <-subscription.Updates\n\tif update.State != invpkg.ContractSettled {\n\t\tt.Fatalf(\"expected state ContractSettled, but got %v\",\n\t\t\tupdate.State)\n\t}\n\n\t// Idempotency.\n\terr = registry.SettleHodlInvoice(testInvoicePreimage)\n\trequire.ErrorIs(t, err, invpkg.ErrInvoiceAlreadySettled)\n\n\t// Try to cancel.\n\terr = registry.CancelInvoice(testInvoicePaymentHash)\n\tif err == nil {\n\t\tt.Fatal(\"expected cancellation of a settled invoice to fail\")\n\t}\n}\n\n// TestCancelHoldInvoice tests canceling of a hold invoice and related\n// notifications.",
      "length": 4917,
      "tokens": 578,
      "embedding": []
    },
    {
      "slug": "func TestCancelHoldInvoice(t *testing.T) {",
      "content": "func TestCancelHoldInvoice(t *testing.T) {\n\tdefer timeout()()\n\n\ttestClock := clock.NewTestClock(testTime)\n\tidb, err := newTestChannelDB(t, testClock)\n\trequire.NoError(t, err)\n\n\t// Instantiate and start the invoice ctx.registry.\n\tcfg := invpkg.RegistryConfig{\n\t\tFinalCltvRejectDelta: testFinalCltvRejectDelta,\n\t\tClock:                testClock,\n\t}\n\texpiryWatcher := invpkg.NewInvoiceExpiryWatcher(\n\t\tcfg.Clock, 0, uint32(testCurrentHeight), nil, newMockNotifier(),\n\t)\n\tregistry := invpkg.NewRegistry(idb, expiryWatcher, &cfg)\n\n\terr = registry.Start()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, registry.Stop())\n\t})\n\n\t// Add the invoice.\n\t_, err = registry.AddInvoice(testHodlInvoice, testInvoicePaymentHash)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tamtPaid := lnwire.MilliSatoshi(100000)\n\thodlChan := make(chan interface{}, 1)\n\n\t// NotifyExitHopHtlc without a preimage present in the invoice registry\n\t// should be possible.\n\tresolution, err := registry.NotifyExitHopHtlc(\n\t\ttestInvoicePaymentHash, amtPaid, testHtlcExpiry,\n\t\ttestCurrentHeight, getCircuitKey(0), hodlChan, testPayload,\n\t)\n\tif err != nil {\n\t\tt.Fatalf(\"expected settle to succeed but got %v\", err)\n\t}\n\tif resolution != nil {\n\t\tt.Fatalf(\"expected htlc to be held\")\n\t}\n\n\t// Cancel invoice.\n\terr = registry.CancelInvoice(testInvoicePaymentHash)\n\tif err != nil {\n\t\tt.Fatal(\"cancel invoice failed\")\n\t}\n\n\thtlcResolution, _ := (<-hodlChan).(invpkg.HtlcResolution)\n\trequire.NotNil(t, htlcResolution)\n\tcheckFailResolution(t, htlcResolution, invpkg.ResultCanceled)\n\n\t// Offering the same htlc again at a higher height should still result\n\t// in a rejection. The accept height is expected to be the original\n\t// accept height.\n\tresolution, err = registry.NotifyExitHopHtlc(\n\t\ttestInvoicePaymentHash, amtPaid, testHtlcExpiry,\n\t\ttestCurrentHeight+1, getCircuitKey(0), hodlChan, testPayload,\n\t)\n\tif err != nil {\n\t\tt.Fatalf(\"expected settle to succeed but got %v\", err)\n\t}\n\trequire.NotNil(t, resolution)\n\tfailResolution := checkFailResolution(\n\t\tt, resolution, invpkg.ResultReplayToCanceled,\n\t)\n\trequire.Equal(t, testCurrentHeight, failResolution.AcceptHeight)\n}\n\n// TestUnknownInvoice tests that invoice registry returns an error when the\n// invoice is unknown. This is to guard against returning a cancel htlc\n// resolution for forwarded htlcs. In the link, NotifyExitHopHtlc is only called\n// if we are the exit hop, but in htlcIncomingContestResolver it is called with\n// forwarded htlc hashes as well.",
      "length": 2364,
      "tokens": 279,
      "embedding": []
    },
    {
      "slug": "func TestUnknownInvoice(t *testing.T) {",
      "content": "func TestUnknownInvoice(t *testing.T) {\n\tctx := newTestContext(t, nil)\n\n\t// Notify arrival of a new htlc paying to this invoice. This should\n\t// succeed.\n\thodlChan := make(chan interface{})\n\tamt := lnwire.MilliSatoshi(100000)\n\tresolution, err := ctx.registry.NotifyExitHopHtlc(\n\t\ttestInvoicePaymentHash, amt, testHtlcExpiry, testCurrentHeight,\n\t\tgetCircuitKey(0), hodlChan, testPayload,\n\t)\n\tif err != nil {\n\t\tt.Fatal(\"unexpected error\")\n\t}\n\trequire.NotNil(t, resolution)\n\tcheckFailResolution(t, resolution, invpkg.ResultInvoiceNotFound)\n}\n\n// TestKeySend tests receiving a spontaneous payment with and without keysend\n// enabled.",
      "length": 571,
      "tokens": 65,
      "embedding": []
    },
    {
      "slug": "func TestKeySend(t *testing.T) {",
      "content": "func TestKeySend(t *testing.T) {\n\tt.Run(\"enabled\", func(t *testing.T) {\n\t\ttestKeySend(t, true)\n\t})\n\tt.Run(\"disabled\", func(t *testing.T) {\n\t\ttestKeySend(t, false)\n\t})\n}\n\n// testKeySend is the inner test function that tests keysend for a particular\n// enabled state on the receiver end.",
      "length": 243,
      "tokens": 35,
      "embedding": []
    },
    {
      "slug": "func testKeySend(t *testing.T, keySendEnabled bool) {",
      "content": "func testKeySend(t *testing.T, keySendEnabled bool) {\n\tdefer timeout()()\n\n\tcfg := defaultRegistryConfig()\n\tcfg.AcceptKeySend = keySendEnabled\n\tctx := newTestContext(t, &cfg)\n\n\tallSubscriptions, err := ctx.registry.SubscribeNotifications(0, 0)\n\trequire.Nil(t, err)\n\tdefer allSubscriptions.Cancel()\n\n\thodlChan := make(chan interface{}, 1)\n\n\tamt := lnwire.MilliSatoshi(1000)\n\texpiry := uint32(testCurrentHeight + 20)\n\n\t// Create key for keysend.\n\tpreimage := lntypes.Preimage{1, 2, 3}\n\thash := preimage.Hash()\n\n\t// Try to settle invoice with an invalid keysend htlc.\n\tinvalidKeySendPayload := &mockPayload{\n\t\tcustomRecords: map[uint64][]byte{\n\t\t\trecord.KeySendType: {1, 2, 3},\n\t\t},\n\t}\n\n\tresolution, err := ctx.registry.NotifyExitHopHtlc(\n\t\thash, amt, expiry,\n\t\ttestCurrentHeight, getCircuitKey(10), hodlChan,\n\t\tinvalidKeySendPayload,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\trequire.NotNil(t, resolution)\n\n\tif !keySendEnabled {\n\t\tcheckFailResolution(t, resolution, invpkg.ResultInvoiceNotFound)\n\t} else {\n\t\tcheckFailResolution(t, resolution, invpkg.ResultKeySendError)\n\t}\n\n\t// Try to settle invoice with a valid keysend htlc.\n\tkeySendPayload := &mockPayload{\n\t\tcustomRecords: map[uint64][]byte{\n\t\t\trecord.KeySendType: preimage[:],\n\t\t},\n\t}\n\n\tresolution, err = ctx.registry.NotifyExitHopHtlc(\n\t\thash, amt, expiry,\n\t\ttestCurrentHeight, getCircuitKey(10), hodlChan, keySendPayload,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Expect a cancel resolution if keysend is disabled.\n\tif !keySendEnabled {\n\t\tcheckFailResolution(t, resolution, invpkg.ResultInvoiceNotFound)\n\t\treturn\n\t}\n\n\tcheckSubscription := func() {\n\t\t// We expect a new invoice notification to be sent out.\n\t\tnewInvoice := <-allSubscriptions.NewInvoices\n\t\trequire.Equal(t, newInvoice.State, invpkg.ContractOpen)\n\n\t\t// We expect a settled notification to be sent out.\n\t\tsettledInvoice := <-allSubscriptions.SettledInvoices\n\t\trequire.Equal(t, settledInvoice.State, invpkg.ContractSettled)\n\t}\n\n\tcheckSettleResolution(t, resolution, preimage)\n\tcheckSubscription()\n\n\t// Replay the same keysend payment. We expect an identical resolution,\n\t// but no event should be generated.\n\tresolution, err = ctx.registry.NotifyExitHopHtlc(\n\t\thash, amt, expiry,\n\t\ttestCurrentHeight, getCircuitKey(10), hodlChan, keySendPayload,\n\t)\n\trequire.Nil(t, err)\n\tcheckSettleResolution(t, resolution, preimage)\n\n\tselect {\n\tcase <-allSubscriptions.NewInvoices:\n\t\tt.Fatalf(\"replayed keysend should not generate event\")\n\tcase <-time.After(time.Second):\n\t}\n\n\t// Finally, test that we can properly fulfill a second keysend payment\n\t// with a unique preiamge.\n\tpreimage2 := lntypes.Preimage{1, 2, 3, 4}\n\thash2 := preimage2.Hash()\n\n\tkeySendPayload2 := &mockPayload{\n\t\tcustomRecords: map[uint64][]byte{\n\t\t\trecord.KeySendType: preimage2[:],\n\t\t},\n\t}\n\n\tresolution, err = ctx.registry.NotifyExitHopHtlc(\n\t\thash2, amt, expiry,\n\t\ttestCurrentHeight, getCircuitKey(20), hodlChan, keySendPayload2,\n\t)\n\trequire.Nil(t, err)\n\n\tcheckSettleResolution(t, resolution, preimage2)\n\tcheckSubscription()\n}\n\n// TestHoldKeysend tests receiving a spontaneous payment that is held.",
      "length": 2904,
      "tokens": 311,
      "embedding": []
    },
    {
      "slug": "func TestHoldKeysend(t *testing.T) {",
      "content": "func TestHoldKeysend(t *testing.T) {\n\tt.Run(\"settle\", func(t *testing.T) {\n\t\ttestHoldKeysend(t, false)\n\t})\n\tt.Run(\"timeout\", func(t *testing.T) {\n\t\ttestHoldKeysend(t, true)\n\t})\n}\n\n// testHoldKeysend is the inner test function that tests hold-keysend.",
      "length": 205,
      "tokens": 25,
      "embedding": []
    },
    {
      "slug": "func testHoldKeysend(t *testing.T, timeoutKeysend bool) {",
      "content": "func testHoldKeysend(t *testing.T, timeoutKeysend bool) {\n\tdefer timeout()()\n\n\tconst holdDuration = time.Minute\n\n\tcfg := defaultRegistryConfig()\n\tcfg.AcceptKeySend = true\n\tcfg.KeysendHoldTime = holdDuration\n\tctx := newTestContext(t, &cfg)\n\n\tallSubscriptions, err := ctx.registry.SubscribeNotifications(0, 0)\n\trequire.Nil(t, err)\n\tdefer allSubscriptions.Cancel()\n\n\thodlChan := make(chan interface{}, 1)\n\n\tamt := lnwire.MilliSatoshi(1000)\n\texpiry := uint32(testCurrentHeight + 20)\n\n\t// Create key for keysend.\n\tpreimage := lntypes.Preimage{1, 2, 3}\n\thash := preimage.Hash()\n\n\t// Try to settle invoice with a valid keysend htlc.\n\tkeysendPayload := &mockPayload{\n\t\tcustomRecords: map[uint64][]byte{\n\t\t\trecord.KeySendType: preimage[:],\n\t\t},\n\t}\n\n\tresolution, err := ctx.registry.NotifyExitHopHtlc(\n\t\thash, amt, expiry,\n\t\ttestCurrentHeight, getCircuitKey(10), hodlChan, keysendPayload,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// No immediate resolution is expected.\n\trequire.Nil(t, resolution, \"expected hold resolution\")\n\n\t// We expect a new invoice notification to be sent out.\n\tnewInvoice := <-allSubscriptions.NewInvoices\n\tif newInvoice.State != invpkg.ContractOpen {\n\t\tt.Fatalf(\"expected state ContractOpen, but got %v\",\n\t\t\tnewInvoice.State)\n\t}\n\n\t// We expect no further invoice notifications yet (on the all invoices\n\t// subscription).\n\tselect {\n\tcase <-allSubscriptions.NewInvoices:\n\t\tt.Fatalf(\"no invoice update expected\")\n\tcase <-time.After(100 * time.Millisecond):\n\t}\n\n\tif timeoutKeysend {\n\t\t// Advance the clock to just past the hold duration.\n\t\tctx.clock.SetTime(ctx.clock.Now().Add(\n\t\t\tholdDuration + time.Millisecond),\n\t\t)\n\n\t\t// Expect the keysend payment to be failed.\n\t\tres := <-hodlChan\n\t\tfailResolution, ok := res.(*invpkg.HtlcFailResolution)\n\t\trequire.Truef(\n\t\t\tt, ok, \"expected fail resolution, got: %T\",\n\t\t\tresolution,\n\t\t)\n\t\trequire.Equal(\n\t\t\tt, invpkg.ResultCanceled, failResolution.Outcome,\n\t\t\t\"expected keysend payment to be failed\",\n\t\t)\n\n\t\treturn\n\t}\n\n\t// Settle keysend payment manually.\n\trequire.Nil(t, ctx.registry.SettleHodlInvoice(\n\t\t*newInvoice.Terms.PaymentPreimage,\n\t))\n\n\t// We expect a settled notification to be sent out.\n\tsettledInvoice := <-allSubscriptions.SettledInvoices\n\trequire.Equal(t, settledInvoice.State, invpkg.ContractSettled)\n}\n\n// TestMppPayment tests settling of an invoice with multiple partial payments.\n// It covers the case where there is a mpp timeout before the whole invoice is\n// paid and the case where the invoice is settled in time.",
      "length": 2340,
      "tokens": 278,
      "embedding": []
    },
    {
      "slug": "func TestMppPayment(t *testing.T) {",
      "content": "func TestMppPayment(t *testing.T) {\n\tdefer timeout()()\n\n\tctx := newTestContext(t, nil)\n\n\t// Add the invoice.\n\t_, err := ctx.registry.AddInvoice(testInvoice, testInvoicePaymentHash)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tmppPayload := &mockPayload{\n\t\tmpp: record.NewMPP(testInvoiceAmt, [32]byte{}),\n\t}\n\n\t// Send htlc 1.\n\thodlChan1 := make(chan interface{}, 1)\n\tresolution, err := ctx.registry.NotifyExitHopHtlc(\n\t\ttestInvoicePaymentHash, testInvoice.Terms.Value/2,\n\t\ttestHtlcExpiry,\n\t\ttestCurrentHeight, getCircuitKey(10), hodlChan1, mppPayload,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif resolution != nil {\n\t\tt.Fatal(\"expected no direct resolution\")\n\t}\n\n\t// Simulate mpp timeout releasing htlc 1.\n\tctx.clock.SetTime(testTime.Add(30 * time.Second))\n\n\thtlcResolution, _ := (<-hodlChan1).(invpkg.HtlcResolution)\n\tfailResolution, ok := htlcResolution.(*invpkg.HtlcFailResolution)\n\tif !ok {\n\t\tt.Fatalf(\"expected fail resolution, got: %T\",\n\t\t\tresolution)\n\t}\n\tif failResolution.Outcome != invpkg.ResultMppTimeout {\n\t\tt.Fatalf(\"expected mpp timeout, got: %v\",\n\t\t\tfailResolution.Outcome)\n\t}\n\n\t// Send htlc 2.\n\thodlChan2 := make(chan interface{}, 1)\n\tresolution, err = ctx.registry.NotifyExitHopHtlc(\n\t\ttestInvoicePaymentHash, testInvoice.Terms.Value/2,\n\t\ttestHtlcExpiry,\n\t\ttestCurrentHeight, getCircuitKey(11), hodlChan2, mppPayload,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif resolution != nil {\n\t\tt.Fatal(\"expected no direct resolution\")\n\t}\n\n\t// Send htlc 3.\n\thodlChan3 := make(chan interface{}, 1)\n\tresolution, err = ctx.registry.NotifyExitHopHtlc(\n\t\ttestInvoicePaymentHash, testInvoice.Terms.Value/2,\n\t\ttestHtlcExpiry,\n\t\ttestCurrentHeight, getCircuitKey(12), hodlChan3, mppPayload,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tsettleResolution, ok := resolution.(*invpkg.HtlcSettleResolution)\n\tif !ok {\n\t\tt.Fatalf(\"expected settle resolution, got: %T\",\n\t\t\thtlcResolution)\n\t}\n\tif settleResolution.Outcome != invpkg.ResultSettled {\n\t\tt.Fatalf(\"expected result settled, got: %v\",\n\t\t\tsettleResolution.Outcome)\n\t}\n\n\t// Check that settled amount is equal to the sum of values of the htlcs\n\t// 2 and 3.\n\tinv, err := ctx.registry.LookupInvoice(testInvoicePaymentHash)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif inv.State != invpkg.ContractSettled {\n\t\tt.Fatal(\"expected invoice to be settled\")\n\t}\n\tif inv.AmtPaid != testInvoice.Terms.Value {\n\t\tt.Fatalf(\"amount incorrect, expected %v but got %v\",\n\t\t\ttestInvoice.Terms.Value, inv.AmtPaid)\n\t}\n}\n\n// Tests that invoices are canceled after expiration.",
      "length": 2343,
      "tokens": 264,
      "embedding": []
    },
    {
      "slug": "func TestInvoiceExpiryWithRegistry(t *testing.T) {",
      "content": "func TestInvoiceExpiryWithRegistry(t *testing.T) {\n\tt.Parallel()\n\n\ttestClock := clock.NewTestClock(testTime)\n\tidb, err := newTestChannelDB(t, testClock)\n\trequire.NoError(t, err)\n\n\tcfg := invpkg.RegistryConfig{\n\t\tFinalCltvRejectDelta: testFinalCltvRejectDelta,\n\t\tClock:                testClock,\n\t}\n\n\texpiryWatcher := invpkg.NewInvoiceExpiryWatcher(\n\t\tcfg.Clock, 0, uint32(testCurrentHeight), nil, newMockNotifier(),\n\t)\n\tregistry := invpkg.NewRegistry(idb, expiryWatcher, &cfg)\n\n\t// First prefill the Channel DB with some pre-existing invoices,\n\t// half of them still pending, half of them expired.\n\tconst numExpired = 5\n\tconst numPending = 5\n\texistingInvoices := generateInvoiceExpiryTestData(\n\t\tt, testTime, 0, numExpired, numPending,\n\t)\n\n\tvar expectedCancellations []lntypes.Hash\n\texpiredInvoices := existingInvoices.expiredInvoices\n\tfor paymentHash, expiredInvoice := range expiredInvoices {\n\t\t_, err := idb.AddInvoice(expiredInvoice, paymentHash)\n\t\trequire.NoError(t, err)\n\t\texpectedCancellations = append(\n\t\t\texpectedCancellations, paymentHash,\n\t\t)\n\t}\n\n\tpendingInvoices := existingInvoices.pendingInvoices\n\tfor paymentHash, pendingInvoice := range pendingInvoices {\n\t\t_, err := idb.AddInvoice(pendingInvoice, paymentHash)\n\t\trequire.NoError(t, err)\n\t}\n\n\tif err := registry.Start(); err != nil {\n\t\tt.Fatalf(\"cannot start registry: %v\", err)\n\t}\n\n\t// Now generate pending and invoices and add them to the registry while\n\t// it is up and running. We'll manipulate the clock to let them expire.\n\tnewInvoices := generateInvoiceExpiryTestData(\n\t\tt, testTime, numExpired+numPending, 0, numPending,\n\t)\n\n\tvar invoicesThatWillCancel []lntypes.Hash\n\tfor paymentHash, pendingInvoice := range newInvoices.pendingInvoices {\n\t\t_, err := registry.AddInvoice(pendingInvoice, paymentHash)\n\t\tinvoicesThatWillCancel = append(\n\t\t\tinvoicesThatWillCancel, paymentHash,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\t// Check that they are really not canceled until before the clock is\n\t// advanced.\n\tfor i := range invoicesThatWillCancel {\n\t\tinvoice, err := registry.LookupInvoice(\n\t\t\tinvoicesThatWillCancel[i],\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot find invoice: %v\", err)\n\t\t}\n\n\t\tif invoice.State == invpkg.ContractCanceled {\n\t\t\tt.Fatalf(\"expected pending invoice, got canceled\")\n\t\t}\n\t}\n\n\t// Fwd time 1 day.\n\ttestClock.SetTime(testTime.Add(24 * time.Hour))\n\n\t// Create the expected cancellation set before the final check.\n\texpectedCancellations = append(\n\t\texpectedCancellations, invoicesThatWillCancel...,\n\t)\n\n\t// canceled returns a bool to indicate whether all the invoices are\n\t// canceled.\n\tcanceled := func() bool {\n\t\tfor i := range expectedCancellations {\n\t\t\tinvoice, err := registry.LookupInvoice(\n\t\t\t\texpectedCancellations[i],\n\t\t\t)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tif invoice.State != invpkg.ContractCanceled {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\n\t\treturn true\n\t}\n\n\t// Retrospectively check that all invoices that were expected to be\n\t// canceled are indeed canceled.\n\trequire.Eventually(t, canceled, testTimeout, 10*time.Millisecond)\n\n\t// Finally stop the registry.\n\trequire.NoError(t, registry.Stop(), \"failed to stop invoice registry\")\n}\n\n// TestOldInvoiceRemovalOnStart tests that we'll attempt to remove old canceled\n// invoices upon start while keeping all settled ones.",
      "length": 3098,
      "tokens": 365,
      "embedding": []
    },
    {
      "slug": "func TestOldInvoiceRemovalOnStart(t *testing.T) {",
      "content": "func TestOldInvoiceRemovalOnStart(t *testing.T) {\n\tt.Parallel()\n\n\ttestClock := clock.NewTestClock(testTime)\n\tidb, err := newTestChannelDB(t, testClock)\n\trequire.NoError(t, err)\n\n\tcfg := invpkg.RegistryConfig{\n\t\tFinalCltvRejectDelta:        testFinalCltvRejectDelta,\n\t\tClock:                       testClock,\n\t\tGcCanceledInvoicesOnStartup: true,\n\t}\n\n\texpiryWatcher := invpkg.NewInvoiceExpiryWatcher(\n\t\tcfg.Clock, 0, uint32(testCurrentHeight), nil, newMockNotifier(),\n\t)\n\tregistry := invpkg.NewRegistry(idb, expiryWatcher, &cfg)\n\n\t// First prefill the Channel DB with some pre-existing expired invoices.\n\tconst numExpired = 5\n\tconst numPending = 0\n\texistingInvoices := generateInvoiceExpiryTestData(\n\t\tt, testTime, 0, numExpired, numPending,\n\t)\n\n\ti := 0\n\tfor paymentHash, invoice := range existingInvoices.expiredInvoices {\n\t\t// Mark half of the invoices as settled, the other half as\n\t\t// canceled.\n\t\tif i%2 == 0 {\n\t\t\tinvoice.State = invpkg.ContractSettled\n\t\t} else {\n\t\t\tinvoice.State = invpkg.ContractCanceled\n\t\t}\n\n\t\t_, err := idb.AddInvoice(invoice, paymentHash)\n\t\trequire.NoError(t, err)\n\t\ti++\n\t}\n\n\t// Collect all settled invoices for our expectation set.\n\tvar expected []invpkg.Invoice\n\n\t// Perform a scan query to collect all invoices.\n\tquery := invpkg.InvoiceQuery{\n\t\tIndexOffset:    0,\n\t\tNumMaxInvoices: math.MaxUint64,\n\t}\n\n\tresponse, err := idb.QueryInvoices(query)\n\trequire.NoError(t, err)\n\n\t// Save all settled invoices for our expectation set.\n\tfor _, invoice := range response.Invoices {\n\t\tif invoice.State == invpkg.ContractSettled {\n\t\t\texpected = append(expected, invoice)\n\t\t}\n\t}\n\n\t// Start the registry which should collect and delete all canceled\n\t// invoices upon start.\n\terr = registry.Start()\n\trequire.NoError(t, err, \"cannot start the registry\")\n\n\t// Perform a scan query to collect all invoices.\n\tresponse, err = idb.QueryInvoices(query)\n\trequire.NoError(t, err)\n\n\t// Check that we really only kept the settled invoices after the\n\t// registry start.\n\trequire.Equal(t, expected, response.Invoices)\n}\n\n// TestHeightExpiryWithRegistry tests our height-based invoice expiry for\n// invoices paid with single and multiple htlcs, testing the case where the\n// invoice is settled before expiry (and thus not canceled), and the case\n// where the invoice is expired.",
      "length": 2151,
      "tokens": 271,
      "embedding": []
    },
    {
      "slug": "func TestHeightExpiryWithRegistry(t *testing.T) {",
      "content": "func TestHeightExpiryWithRegistry(t *testing.T) {\n\tt.Run(\"single shot settled before expiry\", func(t *testing.T) {\n\t\ttestHeightExpiryWithRegistry(t, 1, true)\n\t})\n\n\tt.Run(\"single shot expires\", func(t *testing.T) {\n\t\ttestHeightExpiryWithRegistry(t, 1, false)\n\t})\n\n\tt.Run(\"mpp settled before expiry\", func(t *testing.T) {\n\t\ttestHeightExpiryWithRegistry(t, 2, true)\n\t})\n\n\tt.Run(\"mpp expires\", func(t *testing.T) {\n\t\ttestHeightExpiryWithRegistry(t, 2, false)\n\t})\n}\n",
      "length": 395,
      "tokens": 43,
      "embedding": []
    },
    {
      "slug": "func testHeightExpiryWithRegistry(t *testing.T, numParts int, settle bool) {",
      "content": "func testHeightExpiryWithRegistry(t *testing.T, numParts int, settle bool) {\n\tt.Parallel()\n\tdefer timeout()()\n\n\tctx := newTestContext(t, nil)\n\n\trequire.Greater(t, numParts, 0, \"test requires at least one part\")\n\n\t// Add a hold invoice, we set a non-nil payment request so that this\n\t// invoice is not considered a keysend by the expiry watcher.\n\tinvoice := *testInvoice\n\tinvoice.HodlInvoice = true\n\tinvoice.PaymentRequest = []byte{1, 2, 3}\n\n\t_, err := ctx.registry.AddInvoice(&invoice, testInvoicePaymentHash)\n\trequire.NoError(t, err)\n\n\tpayLoad := testPayload\n\tif numParts > 1 {\n\t\tpayLoad = &mockPayload{\n\t\t\tmpp: record.NewMPP(testInvoiceAmt, [32]byte{}),\n\t\t}\n\t}\n\n\thtlcAmt := invoice.Terms.Value / lnwire.MilliSatoshi(numParts)\n\thodlChan := make(chan interface{}, numParts)\n\tfor i := 0; i < numParts; i++ {\n\t\t// We bump our expiry height for each htlc so that we can test\n\t\t// that the lowest expiry height is used.\n\t\texpiry := testHtlcExpiry + uint32(i)\n\n\t\tresolution, err := ctx.registry.NotifyExitHopHtlc(\n\t\t\ttestInvoicePaymentHash, htlcAmt, expiry,\n\t\t\ttestCurrentHeight, getCircuitKey(uint64(i)), hodlChan,\n\t\t\tpayLoad,\n\t\t)\n\t\trequire.NoError(t, err)\n\t\trequire.Nil(t, resolution, \"did not expect direct resolution\")\n\t}\n\n\trequire.Eventually(t, func() bool {\n\t\tinv, err := ctx.registry.LookupInvoice(testInvoicePaymentHash)\n\t\trequire.NoError(t, err)\n\n\t\treturn inv.State == invpkg.ContractAccepted\n\t}, time.Second, time.Millisecond*100)\n\n\t// Now that we've added our htlc(s), we tick our test clock to our\n\t// invoice expiry time. We don't expect the invoice to be canceled\n\t// based on its expiry time now that we have active htlcs.\n\tctx.clock.SetTime(invoice.CreationDate.Add(invoice.Terms.Expiry + 1))\n\n\t// The expiry watcher loop takes some time to process the new clock\n\t// time. We mine the block before our expiry height, our mock will block\n\t// until the expiry watcher consumes this height, so we can be sure\n\t// that the expiry loop has run at least once after this block is\n\t// consumed.\n\tctx.notifier.blockChan <- &chainntnfs.BlockEpoch{\n\t\tHeight: int32(testHtlcExpiry - 1),\n\t}\n\n\t// If we want to settle our invoice in this test, we do so now.\n\tif settle {\n\t\terr = ctx.registry.SettleHodlInvoice(testInvoicePreimage)\n\t\trequire.NoError(t, err)\n\n\t\tfor i := 0; i < numParts; i++ {\n\t\t\tresolution, _ := (<-hodlChan).(invpkg.HtlcResolution)\n\t\t\trequire.NotNil(t, resolution)\n\t\t\tsettleResolution := checkSettleResolution(\n\t\t\t\tt, resolution, testInvoicePreimage,\n\t\t\t)\n\t\t\toutcome := settleResolution.Outcome\n\t\t\trequire.Equal(t, invpkg.ResultSettled, outcome)\n\t\t}\n\t}\n\n\t// Now we mine our htlc's expiry height.\n\tctx.notifier.blockChan <- &chainntnfs.BlockEpoch{\n\t\tHeight: int32(testHtlcExpiry),\n\t}\n\n\t// If we did not settle the invoice before its expiry, we now expect\n\t// a cancellation.\n\texpectedState := invpkg.ContractSettled\n\tif !settle {\n\t\texpectedState = invpkg.ContractCanceled\n\n\t\thtlcResolution, _ := (<-hodlChan).(invpkg.HtlcResolution)\n\t\trequire.NotNil(t, htlcResolution)\n\t\tcheckFailResolution(\n\t\t\tt, htlcResolution, invpkg.ResultCanceled,\n\t\t)\n\t}\n\n\t// Finally, lookup the invoice and assert that we have the state we\n\t// expect.\n\tinv, err := ctx.registry.LookupInvoice(testInvoicePaymentHash)\n\trequire.NoError(t, err)\n\trequire.Equal(t, expectedState, inv.State, \"expected \"+\n\t\t\"hold invoice: %v, got: %v\", expectedState, inv.State)\n}\n\n// TestMultipleSetHeightExpiry pays a hold invoice with two mpp sets, testing\n// that the invoice expiry watcher only uses the expiry height of the second,\n// successful set to cancel the invoice, and does not cancel early using the\n// expiry height of the first set that was canceled back due to mpp timeout.",
      "length": 3472,
      "tokens": 458,
      "embedding": []
    },
    {
      "slug": "func TestMultipleSetHeightExpiry(t *testing.T) {",
      "content": "func TestMultipleSetHeightExpiry(t *testing.T) {\n\tt.Parallel()\n\tdefer timeout()()\n\n\tctx := newTestContext(t, nil)\n\n\t// Add a hold invoice.\n\tinvoice := *testInvoice\n\tinvoice.HodlInvoice = true\n\n\t_, err := ctx.registry.AddInvoice(&invoice, testInvoicePaymentHash)\n\trequire.NoError(t, err)\n\n\tmppPayload := &mockPayload{\n\t\tmpp: record.NewMPP(testInvoiceAmt, [32]byte{}),\n\t}\n\n\t// Send htlc 1.\n\thodlChan1 := make(chan interface{}, 1)\n\tresolution, err := ctx.registry.NotifyExitHopHtlc(\n\t\ttestInvoicePaymentHash, invoice.Terms.Value/2,\n\t\ttestHtlcExpiry,\n\t\ttestCurrentHeight, getCircuitKey(10), hodlChan1, mppPayload,\n\t)\n\trequire.NoError(t, err)\n\trequire.Nil(t, resolution, \"did not expect direct resolution\")\n\n\t// Simulate mpp timeout releasing htlc 1.\n\tctx.clock.SetTime(testTime.Add(30 * time.Second))\n\n\thtlcResolution, _ := (<-hodlChan1).(invpkg.HtlcResolution)\n\tfailResolution, ok := htlcResolution.(*invpkg.HtlcFailResolution)\n\trequire.True(t, ok, \"expected fail resolution, got: %T\", resolution)\n\trequire.Equal(t, invpkg.ResultMppTimeout, failResolution.Outcome,\n\t\t\"expected MPP Timeout, got: %v\", failResolution.Outcome)\n\n\t// Notify the expiry height for our first htlc. We don't expect the\n\t// invoice to be expired based on block height because the htlc set\n\t// was never completed.\n\tctx.notifier.blockChan <- &chainntnfs.BlockEpoch{\n\t\tHeight: int32(testHtlcExpiry),\n\t}\n\n\t// Now we will send a full set of htlcs for the invoice with a higher\n\t// expiry height. We expect the invoice to move into the accepted state.\n\texpiry := testHtlcExpiry + 5\n\n\t// Send htlc 2.\n\thodlChan2 := make(chan interface{}, 1)\n\tresolution, err = ctx.registry.NotifyExitHopHtlc(\n\t\ttestInvoicePaymentHash, invoice.Terms.Value/2, expiry,\n\t\ttestCurrentHeight, getCircuitKey(11), hodlChan2, mppPayload,\n\t)\n\trequire.NoError(t, err)\n\trequire.Nil(t, resolution, \"did not expect direct resolution\")\n\n\t// Send htlc 3.\n\thodlChan3 := make(chan interface{}, 1)\n\tresolution, err = ctx.registry.NotifyExitHopHtlc(\n\t\ttestInvoicePaymentHash, invoice.Terms.Value/2, expiry,\n\t\ttestCurrentHeight, getCircuitKey(12), hodlChan3, mppPayload,\n\t)\n\trequire.NoError(t, err)\n\trequire.Nil(t, resolution, \"did not expect direct resolution\")\n\n\t// Assert that we've reached an accepted state because the invoice has\n\t// been paid with a complete set.\n\tinv, err := ctx.registry.LookupInvoice(testInvoicePaymentHash)\n\trequire.NoError(t, err)\n\trequire.Equal(t, invpkg.ContractAccepted, inv.State, \"expected \"+\n\t\t\"hold invoice accepted\")\n\n\t// Now we will notify the expiry height for the new set of htlcs. We\n\t// expect the invoice to be canceled by the expiry watcher.\n\tctx.notifier.blockChan <- &chainntnfs.BlockEpoch{\n\t\tHeight: int32(expiry),\n\t}\n\n\trequire.Eventuallyf(t, func() bool {\n\t\tinv, err := ctx.registry.LookupInvoice(testInvoicePaymentHash)\n\t\trequire.NoError(t, err)\n\n\t\treturn inv.State == invpkg.ContractCanceled\n\t}, testTimeout, time.Millisecond*100, \"invoice not canceled\")\n}\n\n// TestSettleInvoicePaymentAddrRequired tests that if an incoming payment has\n// an invoice that requires the payment addr bit to be set, and the incoming\n// payment doesn't include an mpp payload, then the payment is rejected.",
      "length": 3026,
      "tokens": 349,
      "embedding": []
    },
    {
      "slug": "func TestSettleInvoicePaymentAddrRequired(t *testing.T) {",
      "content": "func TestSettleInvoicePaymentAddrRequired(t *testing.T) {\n\tt.Parallel()\n\n\tctx := newTestContext(t, nil)\n\n\tallSubscriptions, err := ctx.registry.SubscribeNotifications(0, 0)\n\trequire.Nil(t, err)\n\tdefer allSubscriptions.Cancel()\n\n\t// Subscribe to the not yet existing invoice.\n\tsubscription, err := ctx.registry.SubscribeSingleInvoice(\n\t\ttestInvoicePaymentHash,\n\t)\n\trequire.NoError(t, err)\n\tdefer subscription.Cancel()\n\n\trequire.Equal(t, subscription.PayHash(), &testInvoicePaymentHash)\n\n\t// Add the invoice, which requires the MPP payload to always be\n\t// included due to its set of feature bits.\n\taddIdx, err := ctx.registry.AddInvoice(\n\t\ttestPayAddrReqInvoice, testInvoicePaymentHash,\n\t)\n\trequire.NoError(t, err)\n\trequire.Equal(t, int(addIdx), 1)\n\n\t// We expect the open state to be sent to the single invoice subscriber.\n\tselect {\n\tcase update := <-subscription.Updates:\n\t\tif update.State != invpkg.ContractOpen {\n\t\t\tt.Fatalf(\"expected state ContractOpen, but got %v\",\n\t\t\t\tupdate.State)\n\t\t}\n\tcase <-time.After(testTimeout):\n\t\tt.Fatal(\"no update received\")\n\t}\n\n\t// We expect a new invoice notification to be sent out.\n\tselect {\n\tcase newInvoice := <-allSubscriptions.NewInvoices:\n\t\tif newInvoice.State != invpkg.ContractOpen {\n\t\t\tt.Fatalf(\"expected state ContractOpen, but got %v\",\n\t\t\t\tnewInvoice.State)\n\t\t}\n\tcase <-time.After(testTimeout):\n\t\tt.Fatal(\"no update received\")\n\t}\n\n\thodlChan := make(chan interface{}, 1)\n\n\t// Now try to settle the invoice, the testPayload doesn't have any mpp\n\t// information, so it should be forced to the updateLegacy path then\n\t// fail as a required feature bit exists.\n\tresolution, err := ctx.registry.NotifyExitHopHtlc(\n\t\ttestInvoicePaymentHash, testInvoice.Terms.Value,\n\t\tuint32(testCurrentHeight)+testInvoiceCltvDelta-1,\n\t\ttestCurrentHeight, getCircuitKey(10), hodlChan, testPayload,\n\t)\n\trequire.NoError(t, err)\n\n\tfailResolution, ok := resolution.(*invpkg.HtlcFailResolution)\n\tif !ok {\n\t\tt.Fatalf(\"expected fail resolution, got: %T\",\n\t\t\tresolution)\n\t}\n\trequire.Equal(t, failResolution.AcceptHeight, testCurrentHeight)\n\trequire.Equal(t, failResolution.Outcome, invpkg.ResultAddressMismatch)\n}\n\n// TestSettleInvoicePaymentAddrRequiredOptionalGrace tests that if an invoice\n// in the database has an optional payment addr required bit set, then we'll\n// still allow it to be paid by an incoming HTLC that doesn't include the MPP\n// payload. This ensures we don't break payment for any invoices in the wild.",
      "length": 2311,
      "tokens": 267,
      "embedding": []
    },
    {
      "slug": "func TestSettleInvoicePaymentAddrRequiredOptionalGrace(t *testing.T) {",
      "content": "func TestSettleInvoicePaymentAddrRequiredOptionalGrace(t *testing.T) {\n\tt.Parallel()\n\n\tctx := newTestContext(t, nil)\n\n\tallSubscriptions, err := ctx.registry.SubscribeNotifications(0, 0)\n\trequire.Nil(t, err)\n\tdefer allSubscriptions.Cancel()\n\n\t// Subscribe to the not yet existing invoice.\n\tsubscription, err := ctx.registry.SubscribeSingleInvoice(\n\t\ttestInvoicePaymentHash,\n\t)\n\trequire.NoError(t, err)\n\tdefer subscription.Cancel()\n\n\trequire.Equal(t, subscription.PayHash(), &testInvoicePaymentHash)\n\n\t// Add the invoice, which requires the MPP payload to always be\n\t// included due to its set of feature bits.\n\taddIdx, err := ctx.registry.AddInvoice(\n\t\ttestPayAddrOptionalInvoice, testInvoicePaymentHash,\n\t)\n\trequire.NoError(t, err)\n\trequire.Equal(t, int(addIdx), 1)\n\n\t// We expect the open state to be sent to the single invoice\n\t// subscriber.\n\tselect {\n\tcase update := <-subscription.Updates:\n\t\tif update.State != invpkg.ContractOpen {\n\t\t\tt.Fatalf(\"expected state ContractOpen, but got %v\",\n\t\t\t\tupdate.State)\n\t\t}\n\tcase <-time.After(testTimeout):\n\t\tt.Fatal(\"no update received\")\n\t}\n\n\t// We expect a new invoice notification to be sent out.\n\tselect {\n\tcase newInvoice := <-allSubscriptions.NewInvoices:\n\t\tif newInvoice.State != invpkg.ContractOpen {\n\t\t\tt.Fatalf(\"expected state ContractOpen, but got %v\",\n\t\t\t\tnewInvoice.State)\n\t\t}\n\tcase <-time.After(testTimeout):\n\t\tt.Fatal(\"no update received\")\n\t}\n\n\t// We'll now attempt to settle the invoice as normal, this should work\n\t// no problem as we should allow these existing invoices to be settled.\n\thodlChan := make(chan interface{}, 1)\n\tresolution, err := ctx.registry.NotifyExitHopHtlc(\n\t\ttestInvoicePaymentHash, testInvoiceAmt,\n\t\ttestHtlcExpiry, testCurrentHeight,\n\t\tgetCircuitKey(10), hodlChan, testPayload,\n\t)\n\trequire.NoError(t, err)\n\n\tsettleResolution, ok := resolution.(*invpkg.HtlcSettleResolution)\n\tif !ok {\n\t\tt.Fatalf(\"expected settle resolution, got: %T\",\n\t\t\tresolution)\n\t}\n\trequire.Equal(t, settleResolution.Outcome, invpkg.ResultSettled)\n\n\t// We expect the settled state to be sent to the single invoice\n\t// subscriber.\n\tselect {\n\tcase update := <-subscription.Updates:\n\t\tif update.State != invpkg.ContractSettled {\n\t\t\tt.Fatalf(\"expected state ContractOpen, but got %v\",\n\t\t\t\tupdate.State)\n\t\t}\n\t\tif update.AmtPaid != testInvoice.Terms.Value {\n\t\t\tt.Fatal(\"invoice AmtPaid incorrect\")\n\t\t}\n\tcase <-time.After(testTimeout):\n\t\tt.Fatal(\"no update received\")\n\t}\n\n\t// We expect a settled notification to be sent out.\n\tselect {\n\tcase settledInvoice := <-allSubscriptions.SettledInvoices:\n\t\tif settledInvoice.State != invpkg.ContractSettled {\n\t\t\tt.Fatalf(\"expected state ContractOpen, but got %v\",\n\t\t\t\tsettledInvoice.State)\n\t\t}\n\tcase <-time.After(testTimeout):\n\t\tt.Fatal(\"no update received\")\n\t}\n}\n\n// TestAMPWithoutMPPPayload asserts that we correctly reject an AMP HTLC that\n// does not include an MPP record.",
      "length": 2697,
      "tokens": 309,
      "embedding": []
    },
    {
      "slug": "func TestAMPWithoutMPPPayload(t *testing.T) {",
      "content": "func TestAMPWithoutMPPPayload(t *testing.T) {\n\tdefer timeout()()\n\n\tcfg := defaultRegistryConfig()\n\tcfg.AcceptAMP = true\n\tctx := newTestContext(t, &cfg)\n\n\tconst (\n\t\tshardAmt = lnwire.MilliSatoshi(10)\n\t\texpiry   = uint32(testCurrentHeight + 20)\n\t)\n\n\t// Create payload with missing MPP field.\n\tpayload := &mockPayload{\n\t\tamp: record.NewAMP([32]byte{}, [32]byte{}, 0),\n\t}\n\n\thodlChan := make(chan interface{}, 1)\n\tresolution, err := ctx.registry.NotifyExitHopHtlc(\n\t\tlntypes.Hash{}, shardAmt, expiry,\n\t\ttestCurrentHeight, getCircuitKey(uint64(10)), hodlChan,\n\t\tpayload,\n\t)\n\trequire.NoError(t, err)\n\n\t// We should receive the ResultAmpError failure.\n\trequire.NotNil(t, resolution)\n\tcheckFailResolution(t, resolution, invpkg.ResultAmpError)\n}\n\n// TestSpontaneousAmpPayment tests receiving a spontaneous AMP payment with both\n// valid and invalid reconstructions.",
      "length": 779,
      "tokens": 85,
      "embedding": []
    },
    {
      "slug": "func TestSpontaneousAmpPayment(t *testing.T) {",
      "content": "func TestSpontaneousAmpPayment(t *testing.T) {\n\ttests := []struct {\n\t\tname               string\n\t\tampEnabled         bool\n\t\tfailReconstruction bool\n\t\tnumShards          int\n\t}{\n\t\t{\n\t\t\tname:               \"enabled valid one shard\",\n\t\t\tampEnabled:         true,\n\t\t\tfailReconstruction: false,\n\t\t\tnumShards:          1,\n\t\t},\n\t\t{\n\t\t\tname:               \"enabled valid multiple shards\",\n\t\t\tampEnabled:         true,\n\t\t\tfailReconstruction: false,\n\t\t\tnumShards:          3,\n\t\t},\n\t\t{\n\t\t\tname:               \"enabled invalid one shard\",\n\t\t\tampEnabled:         true,\n\t\t\tfailReconstruction: true,\n\t\t\tnumShards:          1,\n\t\t},\n\t\t{\n\t\t\tname:               \"enabled invalid multiple shards\",\n\t\t\tampEnabled:         true,\n\t\t\tfailReconstruction: true,\n\t\t\tnumShards:          3,\n\t\t},\n\t\t{\n\t\t\tname:               \"disabled valid multiple shards\",\n\t\t\tampEnabled:         false,\n\t\t\tfailReconstruction: false,\n\t\t\tnumShards:          3,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\ttestSpontaneousAmpPayment(\n\t\t\t\tt, test.ampEnabled, test.failReconstruction,\n\t\t\t\ttest.numShards,\n\t\t\t)\n\t\t})\n\t}\n}\n\n// testSpontaneousAmpPayment runs a specific spontaneous AMP test case.",
      "length": 1098,
      "tokens": 111,
      "embedding": []
    },
    {
      "slug": "func testSpontaneousAmpPayment(",
      "content": "func testSpontaneousAmpPayment(\n\tt *testing.T, ampEnabled, failReconstruction bool, numShards int) {\n\n\tdefer timeout()()\n\n\tcfg := defaultRegistryConfig()\n\tcfg.AcceptAMP = ampEnabled\n\tctx := newTestContext(t, &cfg)\n\n\tallSubscriptions, err := ctx.registry.SubscribeNotifications(0, 0)\n\trequire.Nil(t, err)\n\tdefer allSubscriptions.Cancel()\n\n\tconst (\n\t\ttotalAmt = lnwire.MilliSatoshi(360)\n\t\texpiry   = uint32(testCurrentHeight + 20)\n\t)\n\n\tvar (\n\t\tshardAmt = totalAmt / lnwire.MilliSatoshi(numShards)\n\t\tpayAddr  [32]byte\n\t\tsetID    [32]byte\n\t)\n\t_, err = rand.Read(payAddr[:])\n\trequire.NoError(t, err)\n\t_, err = rand.Read(setID[:])\n\trequire.NoError(t, err)\n\n\tvar sharer amp.Sharer\n\tsharer, err = amp.NewSeedSharer()\n\trequire.NoError(t, err)\n\n\t// Asserts that a new invoice is published on the NewInvoices channel.\n\tcheckOpenSubscription := func() {\n\t\tt.Helper()\n\t\tnewInvoice := <-allSubscriptions.NewInvoices\n\t\trequire.Equal(t, newInvoice.State, invpkg.ContractOpen)\n\t}\n\n\t// Asserts that a settled invoice is published on the SettledInvoices\n\t// channel.\n\tcheckSettleSubscription := func() {\n\t\tt.Helper()\n\t\tsettledInvoice := <-allSubscriptions.SettledInvoices\n\n\t\t// Since this is an AMP invoice, the invoice state never\n\t\t// changes, but the AMP state should show that the setID has\n\t\t// been settled.\n\t\thtlcState := settledInvoice.AMPState[setID].State\n\t\trequire.Equal(t, htlcState, invpkg.HtlcStateSettled)\n\t}\n\n\t// Asserts that no invoice is published on the SettledInvoices channel\n\t// w/in two seconds.\n\tcheckNoSettleSubscription := func() {\n\t\tt.Helper()\n\t\tselect {\n\t\tcase <-allSubscriptions.SettledInvoices:\n\t\t\tt.Fatal(\"no settle ntfn expected\")\n\t\tcase <-time.After(2 * time.Second):\n\t\t}\n\t}\n\n\t// Record the hodl channels of all HTLCs but the last one, which\n\t// received its resolution directly from NotifyExistHopHtlc.\n\thodlChans := make(map[lntypes.Preimage]chan interface{})\n\tfor i := 0; i < numShards; i++ {\n\t\tisFinalShard := i == numShards-1\n\n\t\thodlChan := make(chan interface{}, 1)\n\n\t\tvar child *amp.Child\n\t\tif !isFinalShard {\n\t\t\tvar left amp.Sharer\n\t\t\tleft, sharer, err = sharer.Split()\n\t\t\trequire.NoError(t, err)\n\n\t\t\tchild = left.Child(uint32(i))\n\n\t\t\t// Only store the first numShards-1 hodlChans.\n\t\t\thodlChans[child.Preimage] = hodlChan\n\t\t} else {\n\t\t\tchild = sharer.Child(uint32(i))\n\t\t}\n\n\t\t// Send a blank share when the set should fail reconstruction,\n\t\t// otherwise send the derived share.\n\t\tvar share [32]byte\n\t\tif !failReconstruction {\n\t\t\tshare = child.Share\n\t\t}\n\n\t\tpayload := &mockPayload{\n\t\t\tmpp: record.NewMPP(totalAmt, payAddr),\n\t\t\tamp: record.NewAMP(share, setID, uint32(i)),\n\t\t}\n\n\t\tresolution, err := ctx.registry.NotifyExitHopHtlc(\n\t\t\tchild.Hash, shardAmt, expiry,\n\t\t\ttestCurrentHeight, getCircuitKey(uint64(i)), hodlChan,\n\t\t\tpayload,\n\t\t)\n\t\trequire.NoError(t, err)\n\n\t\t// When keysend is disabled all HTLC should fail with invoice\n\t\t// not found, since one is not inserted before executing\n\t\t// UpdateInvoice.\n\t\tif !ampEnabled {\n\t\t\trequire.NotNil(t, resolution)\n\t\t\tcheckFailResolution(\n\t\t\t\tt, resolution, invpkg.ResultInvoiceNotFound,\n\t\t\t)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Check that resolutions are properly formed.\n\t\tif !isFinalShard {\n\t\t\t// Non-final shares should always return a nil\n\t\t\t// resolution, theirs will be delivered via the\n\t\t\t// hodlChan.\n\t\t\trequire.Nil(t, resolution)\n\t\t} else {\n\t\t\t// The final share should receive a non-nil resolution.\n\t\t\t// Also assert that it is the proper type based on the\n\t\t\t// test case.\n\t\t\trequire.NotNil(t, resolution)\n\t\t\tif failReconstruction {\n\t\t\t\tcheckFailResolution(\n\t\t\t\t\tt, resolution,\n\t\t\t\t\tinvpkg.ResultAmpReconstruction,\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tcheckSettleResolution(\n\t\t\t\t\tt, resolution, child.Preimage,\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\n\t\t// Assert the behavior of the Open and Settle notifications.\n\t\t// There should always be an open (keysend is enabled) followed\n\t\t// by settle for valid AMP payments.\n\t\t//\n\t\t// NOTE: The cases are split in separate if conditions, rather\n\t\t// than else-if, to properly handle the case when there is only\n\t\t// one shard.\n\t\tif i == 0 {\n\t\t\tcheckOpenSubscription()\n\t\t}\n\t\tif isFinalShard {\n\t\t\tif failReconstruction {\n\t\t\t\tcheckNoSettleSubscription()\n\t\t\t} else {\n\t\t\t\tcheckSettleSubscription()\n\t\t\t}\n\t\t}\n\t}\n\n\t// No need to check the hodl chans when keysend is not enabled.\n\tif !ampEnabled {\n\t\treturn\n\t}\n\n\t// For the non-final hodl chans, assert that they receive the expected\n\t// failure or preimage.\n\tfor preimage, hodlChan := range hodlChans {\n\t\tresolution, ok := (<-hodlChan).(invpkg.HtlcResolution)\n\t\trequire.True(t, ok)\n\t\trequire.NotNil(t, resolution)\n\t\tif failReconstruction {\n\t\t\tcheckFailResolution(\n\t\t\t\tt, resolution, invpkg.ResultAmpReconstruction,\n\t\t\t)\n\t\t} else {\n\t\t\tcheckSettleResolution(t, resolution, preimage)\n\t\t}\n\t}\n}\n",
      "length": 4491,
      "tokens": 570,
      "embedding": []
    }
  ]
}