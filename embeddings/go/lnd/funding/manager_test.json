{
  "filepath": "../implementations/go/lnd/funding/manager_test.go",
  "package": "funding",
  "sections": [
    {
      "slug": "type mockAliasMgr struct{}",
      "content": "type mockAliasMgr struct{}\n",
      "length": 0,
      "tokens": 0,
      "embedding": []
    },
    {
      "slug": "func (m *mockAliasMgr) RequestAlias() (lnwire.ShortChannelID, error) {",
      "content": "func (m *mockAliasMgr) RequestAlias() (lnwire.ShortChannelID, error) {\n\treturn alias, nil\n}\n",
      "length": 19,
      "tokens": 4,
      "embedding": []
    },
    {
      "slug": "func (m *mockAliasMgr) PutPeerAlias(lnwire.ChannelID,",
      "content": "func (m *mockAliasMgr) PutPeerAlias(lnwire.ChannelID,\n\tlnwire.ShortChannelID) error {\n\n\treturn nil\n}\n",
      "length": 43,
      "tokens": 6,
      "embedding": []
    },
    {
      "slug": "func (m *mockAliasMgr) GetPeerAlias(lnwire.ChannelID) (lnwire.ShortChannelID,",
      "content": "func (m *mockAliasMgr) GetPeerAlias(lnwire.ChannelID) (lnwire.ShortChannelID,\n\terror) {\n\n\treturn alias, nil\n}\n",
      "length": 28,
      "tokens": 6,
      "embedding": []
    },
    {
      "slug": "func (m *mockAliasMgr) AddLocalAlias(lnwire.ShortChannelID,",
      "content": "func (m *mockAliasMgr) AddLocalAlias(lnwire.ShortChannelID,\n\tlnwire.ShortChannelID, bool) error {\n\n\treturn nil\n}\n",
      "length": 49,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "func (m *mockAliasMgr) GetAliases(",
      "content": "func (m *mockAliasMgr) GetAliases(\n\tlnwire.ShortChannelID) []lnwire.ShortChannelID {\n\n\treturn []lnwire.ShortChannelID{alias}\n}\n",
      "length": 88,
      "tokens": 6,
      "embedding": []
    },
    {
      "slug": "func (m *mockAliasMgr) DeleteSixConfs(lnwire.ShortChannelID) error {",
      "content": "func (m *mockAliasMgr) DeleteSixConfs(lnwire.ShortChannelID) error {\n\treturn nil\n}\n",
      "length": 12,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "type mockNotifier struct {",
      "content": "type mockNotifier struct {\n\toneConfChannel chan *chainntnfs.TxConfirmation\n\tsixConfChannel chan *chainntnfs.TxConfirmation\n\tepochChan      chan *chainntnfs.BlockEpoch\n}\n",
      "length": 138,
      "tokens": 10,
      "embedding": []
    },
    {
      "slug": "func (m *mockNotifier) RegisterConfirmationsNtfn(txid *chainhash.Hash,",
      "content": "func (m *mockNotifier) RegisterConfirmationsNtfn(txid *chainhash.Hash,\n\t_ []byte, numConfs, heightHint uint32,\n\topts ...chainntnfs.NotifierOption) (*chainntnfs.ConfirmationEvent,\n\terror) {\n\n\tif numConfs == 6 {\n\t\treturn &chainntnfs.ConfirmationEvent{\n\t\t\tConfirmed: m.sixConfChannel,\n\t\t}, nil\n\t}\n\treturn &chainntnfs.ConfirmationEvent{\n\t\tConfirmed: m.oneConfChannel,\n\t}, nil\n}\n",
      "length": 290,
      "tokens": 29,
      "embedding": []
    },
    {
      "slug": "func (m *mockNotifier) RegisterBlockEpochNtfn(",
      "content": "func (m *mockNotifier) RegisterBlockEpochNtfn(\n\tbestBlock *chainntnfs.BlockEpoch) (*chainntnfs.BlockEpochEvent, error) {\n\treturn &chainntnfs.BlockEpochEvent{\n\t\tEpochs: m.epochChan,\n\t\tCancel: func() {},\n\t}, nil\n}\n",
      "length": 159,
      "tokens": 15,
      "embedding": []
    },
    {
      "slug": "func (m *mockNotifier) Start() error {",
      "content": "func (m *mockNotifier) Start() error {\n\treturn nil\n}\n",
      "length": 12,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (m *mockNotifier) Started() bool {",
      "content": "func (m *mockNotifier) Started() bool {\n\treturn true\n}\n",
      "length": 13,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (m *mockNotifier) Stop() error {",
      "content": "func (m *mockNotifier) Stop() error {\n\treturn nil\n}\n",
      "length": 12,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (m *mockNotifier) RegisterSpendNtfn(outpoint *wire.OutPoint, _ []byte,",
      "content": "func (m *mockNotifier) RegisterSpendNtfn(outpoint *wire.OutPoint, _ []byte,\n\theightHint uint32) (*chainntnfs.SpendEvent, error) {\n\treturn &chainntnfs.SpendEvent{\n\t\tSpend:  make(chan *chainntnfs.SpendDetail),\n\t\tCancel: func() {},\n\t}, nil\n}\n",
      "length": 157,
      "tokens": 16,
      "embedding": []
    },
    {
      "slug": "type mockChanEvent struct {",
      "content": "type mockChanEvent struct {\n\topenEvent        chan wire.OutPoint\n\tpendingOpenEvent chan channelnotifier.PendingOpenChannelEvent\n}\n",
      "length": 99,
      "tokens": 7,
      "embedding": []
    },
    {
      "slug": "func (m *mockChanEvent) NotifyOpenChannelEvent(outpoint wire.OutPoint) {",
      "content": "func (m *mockChanEvent) NotifyOpenChannelEvent(outpoint wire.OutPoint) {\n\tm.openEvent <- outpoint\n}\n",
      "length": 25,
      "tokens": 4,
      "embedding": []
    },
    {
      "slug": "func (m *mockChanEvent) NotifyPendingOpenChannelEvent(outpoint wire.OutPoint,",
      "content": "func (m *mockChanEvent) NotifyPendingOpenChannelEvent(outpoint wire.OutPoint,\n\tpendingChannel *channeldb.OpenChannel) {\n\n\tm.pendingOpenEvent <- channelnotifier.PendingOpenChannelEvent{\n\t\tChannelPoint:   &outpoint,\n\t\tPendingChannel: pendingChannel,\n\t}\n}\n\n// mockZeroConfAcceptor always accepts the channel open request for zero-conf\n// channels. It will set the ZeroConf bool in the ChannelAcceptResponse. This\n// is needed to properly unit test the zero-conf logic in the funding manager.",
      "length": 400,
      "tokens": 48,
      "embedding": []
    },
    {
      "slug": "type mockZeroConfAcceptor struct{}",
      "content": "type mockZeroConfAcceptor struct{}\n",
      "length": 0,
      "tokens": 0,
      "embedding": []
    },
    {
      "slug": "func (m *mockZeroConfAcceptor) Accept(",
      "content": "func (m *mockZeroConfAcceptor) Accept(\n\treq *acpt.ChannelAcceptRequest) *acpt.ChannelAcceptResponse {\n\n\treturn &acpt.ChannelAcceptResponse{\n\t\tZeroConf: true,\n\t}\n}\n",
      "length": 118,
      "tokens": 10,
      "embedding": []
    },
    {
      "slug": "type newChannelMsg struct {",
      "content": "type newChannelMsg struct {\n\tchannel *channeldb.OpenChannel\n\terr     chan error\n}\n",
      "length": 51,
      "tokens": 6,
      "embedding": []
    },
    {
      "slug": "type testNode struct {",
      "content": "type testNode struct {\n\tprivKey         *btcec.PrivateKey\n\taddr            *lnwire.NetAddress\n\tmsgChan         chan lnwire.Message\n\tannounceChan    chan lnwire.Message\n\tpublTxChan      chan *wire.MsgTx\n\tfundingMgr      *Manager\n\tnewChannels     chan *newChannelMsg\n\tmockNotifier    *mockNotifier\n\tmockChanEvent   *mockChanEvent\n\ttestDir         string\n\tshutdownChannel chan struct{}\n\treportScidChan  chan struct{}\n\tlocalFeatures   []lnwire.FeatureBit\n\tremoteFeatures  []lnwire.FeatureBit\n\n\tremotePeer  *testNode\n\tsendMessage func(lnwire.Message) error\n}\n\nvar _ lnpeer.Peer = (*testNode)(nil)\n",
      "length": 549,
      "tokens": 45,
      "embedding": []
    },
    {
      "slug": "func (n *testNode) IdentityKey() *btcec.PublicKey {",
      "content": "func (n *testNode) IdentityKey() *btcec.PublicKey {\n\treturn n.addr.IdentityKey\n}\n",
      "length": 27,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (n *testNode) Address() net.Addr {",
      "content": "func (n *testNode) Address() net.Addr {\n\treturn n.addr.Address\n}\n",
      "length": 23,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (n *testNode) PubKey() [33]byte {",
      "content": "func (n *testNode) PubKey() [33]byte {\n\treturn newSerializedKey(n.addr.IdentityKey)\n}\n",
      "length": 45,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (n *testNode) SendMessage(_ bool, msg ...lnwire.Message) error {",
      "content": "func (n *testNode) SendMessage(_ bool, msg ...lnwire.Message) error {\n\treturn n.sendMessage(msg[0])\n}\n",
      "length": 30,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (n *testNode) SendMessageLazy(sync bool, msgs ...lnwire.Message) error {",
      "content": "func (n *testNode) SendMessageLazy(sync bool, msgs ...lnwire.Message) error {\n\treturn n.SendMessage(sync, msgs...)\n}\n",
      "length": 37,
      "tokens": 4,
      "embedding": []
    },
    {
      "slug": "func (n *testNode) WipeChannel(_ *wire.OutPoint) {}",
      "content": "func (n *testNode) WipeChannel(_ *wire.OutPoint) {}\n",
      "length": 0,
      "tokens": 0,
      "embedding": []
    },
    {
      "slug": "func (n *testNode) QuitSignal() <-chan struct{} {",
      "content": "func (n *testNode) QuitSignal() <-chan struct{} {\n\treturn n.shutdownChannel\n}\n",
      "length": 26,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func (n *testNode) LocalFeatures() *lnwire.FeatureVector {",
      "content": "func (n *testNode) LocalFeatures() *lnwire.FeatureVector {\n\treturn lnwire.NewFeatureVector(\n\t\tlnwire.NewRawFeatureVector(n.localFeatures...), nil,\n\t)\n}\n",
      "length": 89,
      "tokens": 6,
      "embedding": []
    },
    {
      "slug": "func (n *testNode) RemoteFeatures() *lnwire.FeatureVector {",
      "content": "func (n *testNode) RemoteFeatures() *lnwire.FeatureVector {\n\treturn lnwire.NewFeatureVector(\n\t\tlnwire.NewRawFeatureVector(n.remoteFeatures...), nil,\n\t)\n}\n",
      "length": 90,
      "tokens": 6,
      "embedding": []
    },
    {
      "slug": "func (n *testNode) AddNewChannel(channel *channeldb.OpenChannel,",
      "content": "func (n *testNode) AddNewChannel(channel *channeldb.OpenChannel,\n\tquit <-chan struct{}) error {\n\n\terrChan := make(chan error)\n\tmsg := &newChannelMsg{\n\t\tchannel: channel,\n\t\terr:     errChan,\n\t}\n\n\tselect {\n\tcase n.newChannels <- msg:\n\tcase <-quit:\n\t\treturn ErrFundingManagerShuttingDown\n\t}\n\n\tselect {\n\tcase err := <-errChan:\n\t\treturn err\n\tcase <-quit:\n\t\treturn ErrFundingManagerShuttingDown\n\t}\n}\n",
      "length": 308,
      "tokens": 42,
      "embedding": []
    },
    {
      "slug": "func createTestWallet(cdb *channeldb.ChannelStateDB, netParams *chaincfg.Params,",
      "content": "func createTestWallet(cdb *channeldb.ChannelStateDB, netParams *chaincfg.Params,\n\tnotifier chainntnfs.ChainNotifier, wc lnwallet.WalletController,\n\tsigner input.Signer, keyRing keychain.SecretKeyRing,\n\tbio lnwallet.BlockChainIO,\n\testimator chainfee.Estimator) (*lnwallet.LightningWallet, error) {\n\n\twallet, err := lnwallet.NewLightningWallet(lnwallet.Config{\n\t\tDatabase:           cdb,\n\t\tNotifier:           notifier,\n\t\tSecretKeyRing:      keyRing,\n\t\tWalletController:   wc,\n\t\tSigner:             signer,\n\t\tChainIO:            bio,\n\t\tFeeEstimator:       estimator,\n\t\tNetParams:          *netParams,\n\t\tDefaultConstraints: chainreg.GenDefaultBtcConstraints(),\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := wallet.Startup(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn wallet, nil\n}\n",
      "length": 680,
      "tokens": 63,
      "embedding": []
    },
    {
      "slug": "func createTestFundingManager(t *testing.T, privKey *btcec.PrivateKey,",
      "content": "func createTestFundingManager(t *testing.T, privKey *btcec.PrivateKey,\n\taddr *lnwire.NetAddress, tempTestDir string,\n\toptions ...cfgOption) (*testNode, error) {\n\n\tnetParams := fundingNetParams.Params\n\testimator := chainfee.NewStaticEstimator(62500, 0)\n\n\tchainNotifier := &mockNotifier{\n\t\toneConfChannel: make(chan *chainntnfs.TxConfirmation, 1),\n\t\tsixConfChannel: make(chan *chainntnfs.TxConfirmation, 1),\n\t\tepochChan:      make(chan *chainntnfs.BlockEpoch, 2),\n\t}\n\n\taliasMgr := &mockAliasMgr{}\n\n\tsentMessages := make(chan lnwire.Message)\n\tsentAnnouncements := make(chan lnwire.Message)\n\tpublTxChan := make(chan *wire.MsgTx, 1)\n\tshutdownChan := make(chan struct{})\n\treportScidChan := make(chan struct{})\n\n\twc := &mock.WalletController{\n\t\tRootKey: alicePrivKey,\n\t}\n\tsigner := &mock.SingleSigner{\n\t\tPrivkey: alicePrivKey,\n\t}\n\tbio := &mock.ChainIO{\n\t\tBestHeight: fundingBroadcastHeight,\n\t}\n\n\t// The mock channel event notifier will receive events for each pending\n\t// open and open channel. Because some tests will create multiple\n\t// channels in a row before advancing to the next step, these channels\n\t// need to be buffered.\n\tevt := &mockChanEvent{\n\t\topenEvent: make(chan wire.OutPoint, maxPending),\n\t\tpendingOpenEvent: make(\n\t\t\tchan channelnotifier.PendingOpenChannelEvent,\n\t\t\tmaxPending,\n\t\t),\n\t}\n\n\tdbDir := filepath.Join(tempTestDir, \"cdb\")\n\tfullDB, err := channeldb.Open(dbDir)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcdb := fullDB.ChannelStateDB()\n\n\tkeyRing := &mock.SecretKeyRing{\n\t\tRootKey: alicePrivKey,\n\t}\n\n\tlnw, err := createTestWallet(\n\t\tcdb, netParams, chainNotifier, wc, signer, keyRing, bio,\n\t\testimator,\n\t)\n\trequire.NoError(t, err, \"unable to create test ln wallet\")\n\n\tvar chanIDSeed [32]byte\n\n\tchainedAcceptor := acpt.NewChainedAcceptor()\n\n\tfundingCfg := Config{\n\t\tIDKey:        privKey.PubKey(),\n\t\tIDKeyLoc:     testKeyLoc,\n\t\tWallet:       lnw,\n\t\tNotifier:     chainNotifier,\n\t\tFeeEstimator: estimator,\n\t\tSignMessage: func(_ keychain.KeyLocator,\n\t\t\t_ []byte, _ bool) (*ecdsa.Signature, error) {\n\n\t\t\treturn testSig, nil\n\t\t},\n\t\tSendAnnouncement: func(msg lnwire.Message,\n\t\t\t_ ...discovery.OptionalMsgField) chan error {\n\n\t\t\terrChan := make(chan error, 1)\n\t\t\tselect {\n\t\t\tcase sentAnnouncements <- msg:\n\t\t\t\terrChan <- nil\n\t\t\tcase <-shutdownChan:\n\t\t\t\terrChan <- fmt.Errorf(\"shutting down\")\n\t\t\t}\n\t\t\treturn errChan\n\t\t},\n\t\tCurrentNodeAnnouncement: func() (lnwire.NodeAnnouncement,\n\t\t\terror) {\n\n\t\t\treturn lnwire.NodeAnnouncement{}, nil\n\t\t},\n\t\tTempChanIDSeed: chanIDSeed,\n\t\tFindChannel: func(node *btcec.PublicKey,\n\t\t\tchanID lnwire.ChannelID) (*channeldb.OpenChannel,\n\t\t\terror) {\n\n\t\t\tnodeChans, err := cdb.FetchOpenChannels(node)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tfor _, channel := range nodeChans {\n\t\t\t\tif chanID.IsChanPoint(\n\t\t\t\t\t&channel.FundingOutpoint,\n\t\t\t\t) {\n\n\t\t\t\t\treturn channel, nil\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn nil, fmt.Errorf(\"unable to find channel\")\n\t\t},\n\t\tDefaultRoutingPolicy: htlcswitch.ForwardingPolicy{\n\t\t\tMinHTLCOut:    5,\n\t\t\tBaseFee:       100,\n\t\t\tFeeRate:       1000,\n\t\t\tTimeLockDelta: 10,\n\t\t},\n\t\tDefaultMinHtlcIn: 5,\n\t\tNumRequiredConfs: func(chanAmt btcutil.Amount,\n\t\t\tpushAmt lnwire.MilliSatoshi) uint16 {\n\t\t\treturn 3\n\t\t},\n\t\tRequiredRemoteDelay: func(amt btcutil.Amount) uint16 {\n\t\t\treturn 4\n\t\t},\n\t\tRequiredRemoteChanReserve: func(chanAmt,\n\t\t\tdustLimit btcutil.Amount) btcutil.Amount {\n\n\t\t\treserve := chanAmt / 100\n\t\t\tif reserve < dustLimit {\n\t\t\t\treserve = dustLimit\n\t\t\t}\n\n\t\t\treturn reserve\n\t\t},\n\t\tRequiredRemoteMaxValue: func(chanAmt btcutil.Amount) lnwire.MilliSatoshi {\n\t\t\treserve := lnwire.NewMSatFromSatoshis(chanAmt / 100)\n\t\t\treturn lnwire.NewMSatFromSatoshis(chanAmt) - reserve\n\t\t},\n\t\tRequiredRemoteMaxHTLCs: func(chanAmt btcutil.Amount) uint16 {\n\t\t\treturn uint16(input.MaxHTLCNumber / 2)\n\t\t},\n\t\tWatchNewChannel: func(*channeldb.OpenChannel,\n\t\t\t*btcec.PublicKey) error {\n\n\t\t\treturn nil\n\t\t},\n\t\tReportShortChanID: func(wire.OutPoint) error {\n\t\t\treportScidChan <- struct{}{}\n\t\t\treturn nil\n\t\t},\n\t\tPublishTransaction: func(txn *wire.MsgTx, _ string) error {\n\t\t\tpublTxChan <- txn\n\t\t\treturn nil\n\t\t},\n\t\tUpdateLabel: func(chainhash.Hash, string) error {\n\t\t\treturn nil\n\t\t},\n\t\tZombieSweeperInterval:         1 * time.Hour,\n\t\tReservationTimeout:            1 * time.Nanosecond,\n\t\tMaxChanSize:                   MaxBtcFundingAmount,\n\t\tMaxLocalCSVDelay:              defaultMaxLocalCSVDelay,\n\t\tMaxPendingChannels:            lncfg.DefaultMaxPendingChannels,\n\t\tNotifyOpenChannelEvent:        evt.NotifyOpenChannelEvent,\n\t\tOpenChannelPredicate:          chainedAcceptor,\n\t\tNotifyPendingOpenChannelEvent: evt.NotifyPendingOpenChannelEvent,\n\t\tRegisteredChains:              chainreg.NewChainRegistry(),\n\t\tDeleteAliasEdge: func(scid lnwire.ShortChannelID) (\n\t\t\t*channeldb.ChannelEdgePolicy, error) {\n\n\t\t\treturn nil, nil\n\t\t},\n\t\tAliasManager: aliasMgr,\n\t}\n\n\tfor _, op := range options {\n\t\top(&fundingCfg)\n\t}\n\n\tf, err := NewFundingManager(fundingCfg)\n\trequire.NoError(t, err, \"failed creating fundingManager\")\n\tif err = f.Start(); err != nil {\n\t\tt.Fatalf(\"failed starting fundingManager: %v\", err)\n\t}\n\n\ttestNode := &testNode{\n\t\tprivKey:         privKey,\n\t\tmsgChan:         sentMessages,\n\t\tnewChannels:     make(chan *newChannelMsg),\n\t\tannounceChan:    sentAnnouncements,\n\t\tpublTxChan:      publTxChan,\n\t\tfundingMgr:      f,\n\t\tmockNotifier:    chainNotifier,\n\t\tmockChanEvent:   evt,\n\t\ttestDir:         tempTestDir,\n\t\tshutdownChannel: shutdownChan,\n\t\treportScidChan:  reportScidChan,\n\t\taddr:            addr,\n\t}\n\n\tf.cfg.NotifyWhenOnline = func(peer [33]byte,\n\t\tconnectedChan chan<- lnpeer.Peer) {\n\n\t\tconnectedChan <- testNode.remotePeer\n\t}\n\n\treturn testNode, nil\n}\n",
      "length": 5303,
      "tokens": 528,
      "embedding": []
    },
    {
      "slug": "func recreateAliceFundingManager(t *testing.T, alice *testNode) {",
      "content": "func recreateAliceFundingManager(t *testing.T, alice *testNode) {\n\t// Stop the old fundingManager before creating a new one.\n\tclose(alice.shutdownChannel)\n\tif err := alice.fundingMgr.Stop(); err != nil {\n\t\tt.Fatalf(\"failed stop funding manager: %v\", err)\n\t}\n\n\taliceMsgChan := make(chan lnwire.Message)\n\taliceAnnounceChan := make(chan lnwire.Message)\n\tshutdownChan := make(chan struct{})\n\tpublishChan := make(chan *wire.MsgTx, 10)\n\n\toldCfg := alice.fundingMgr.cfg\n\n\tchainedAcceptor := acpt.NewChainedAcceptor()\n\n\tf, err := NewFundingManager(Config{\n\t\tIDKey:        oldCfg.IDKey,\n\t\tIDKeyLoc:     oldCfg.IDKeyLoc,\n\t\tWallet:       oldCfg.Wallet,\n\t\tNotifier:     oldCfg.Notifier,\n\t\tFeeEstimator: oldCfg.FeeEstimator,\n\t\tSignMessage: func(_ keychain.KeyLocator,\n\t\t\t_ []byte, _ bool) (*ecdsa.Signature, error) {\n\n\t\t\treturn testSig, nil\n\t\t},\n\t\tSendAnnouncement: func(msg lnwire.Message,\n\t\t\t_ ...discovery.OptionalMsgField) chan error {\n\n\t\t\terrChan := make(chan error, 1)\n\t\t\tselect {\n\t\t\tcase aliceAnnounceChan <- msg:\n\t\t\t\terrChan <- nil\n\t\t\tcase <-shutdownChan:\n\t\t\t\terrChan <- fmt.Errorf(\"shutting down\")\n\t\t\t}\n\t\t\treturn errChan\n\t\t},\n\t\tCurrentNodeAnnouncement: func() (lnwire.NodeAnnouncement,\n\t\t\terror) {\n\n\t\t\treturn lnwire.NodeAnnouncement{}, nil\n\t\t},\n\t\tNotifyWhenOnline: func(peer [33]byte,\n\t\t\tconnectedChan chan<- lnpeer.Peer) {\n\n\t\t\tconnectedChan <- alice.remotePeer\n\t\t},\n\t\tTempChanIDSeed: oldCfg.TempChanIDSeed,\n\t\tFindChannel:    oldCfg.FindChannel,\n\t\tDefaultRoutingPolicy: htlcswitch.ForwardingPolicy{\n\t\t\tMinHTLCOut:    5,\n\t\t\tBaseFee:       100,\n\t\t\tFeeRate:       1000,\n\t\t\tTimeLockDelta: 10,\n\t\t},\n\t\tDefaultMinHtlcIn:       5,\n\t\tRequiredRemoteMaxValue: oldCfg.RequiredRemoteMaxValue,\n\t\tReportShortChanID:      oldCfg.ReportShortChanID,\n\t\tPublishTransaction: func(txn *wire.MsgTx, _ string) error {\n\t\t\tpublishChan <- txn\n\t\t\treturn nil\n\t\t},\n\t\tUpdateLabel: func(chainhash.Hash, string) error {\n\t\t\treturn nil\n\t\t},\n\t\tZombieSweeperInterval: oldCfg.ZombieSweeperInterval,\n\t\tReservationTimeout:    oldCfg.ReservationTimeout,\n\t\tOpenChannelPredicate:  chainedAcceptor,\n\t\tDeleteAliasEdge:       oldCfg.DeleteAliasEdge,\n\t\tAliasManager:          oldCfg.AliasManager,\n\t})\n\trequire.NoError(t, err, \"failed recreating aliceFundingManager\")\n\n\talice.fundingMgr = f\n\talice.msgChan = aliceMsgChan\n\talice.announceChan = aliceAnnounceChan\n\talice.publTxChan = publishChan\n\talice.shutdownChannel = shutdownChan\n\n\tif err = f.Start(); err != nil {\n\t\tt.Fatalf(\"failed starting fundingManager: %v\", err)\n\t}\n}\n",
      "length": 2323,
      "tokens": 217,
      "embedding": []
    },
    {
      "slug": "type cfgOption func(*Config)",
      "content": "type cfgOption func(*Config)\n",
      "length": 0,
      "tokens": 0,
      "embedding": []
    },
    {
      "slug": "func setupFundingManagers(t *testing.T,",
      "content": "func setupFundingManagers(t *testing.T,\n\toptions ...cfgOption) (*testNode, *testNode) {\n\n\talice, err := createTestFundingManager(\n\t\tt, alicePrivKey, aliceAddr, t.TempDir(), options...,\n\t)\n\trequire.NoError(t, err, \"failed creating fundingManager\")\n\n\tbob, err := createTestFundingManager(\n\t\tt, bobPrivKey, bobAddr, t.TempDir(), options...,\n\t)\n\trequire.NoError(t, err, \"failed creating fundingManager\")\n\n\t// With the funding manager's created, we'll now attempt to mimic a\n\t// connection pipe between them. In order to intercept the messages\n\t// within it, we'll redirect all messages back to the msgChan of the\n\t// sender. Since the fundingManager now has a reference to peers itself,\n\t// alice.sendMessage will be triggered when Bob's funding manager\n\t// attempts to send a message to Alice and vice versa.\n\talice.remotePeer = bob\n\talice.sendMessage = func(msg lnwire.Message) error {\n\t\tselect {\n\t\tcase alice.remotePeer.msgChan <- msg:\n\t\tcase <-alice.shutdownChannel:\n\t\t\treturn errors.New(\"shutting down\")\n\t\t}\n\t\treturn nil\n\t}\n\n\tbob.remotePeer = alice\n\tbob.sendMessage = func(msg lnwire.Message) error {\n\t\tselect {\n\t\tcase bob.remotePeer.msgChan <- msg:\n\t\tcase <-bob.shutdownChannel:\n\t\t\treturn errors.New(\"shutting down\")\n\t\t}\n\t\treturn nil\n\t}\n\n\treturn alice, bob\n}\n",
      "length": 1181,
      "tokens": 155,
      "embedding": []
    },
    {
      "slug": "func tearDownFundingManagers(t *testing.T, a, b *testNode) {",
      "content": "func tearDownFundingManagers(t *testing.T, a, b *testNode) {\n\tclose(a.shutdownChannel)\n\tclose(b.shutdownChannel)\n\n\tif err := a.fundingMgr.Stop(); err != nil {\n\t\tt.Fatalf(\"failed stop funding manager: %v\", err)\n\t}\n\tif err := b.fundingMgr.Stop(); err != nil {\n\t\tt.Fatalf(\"failed stop funding manager: %v\", err)\n\t}\n}\n\n// openChannel takes the funding process to the point where the funding\n// transaction is confirmed on-chain. Returns the funding out point.",
      "length": 382,
      "tokens": 55,
      "embedding": []
    },
    {
      "slug": "func openChannel(t *testing.T, alice, bob *testNode, localFundingAmt,",
      "content": "func openChannel(t *testing.T, alice, bob *testNode, localFundingAmt,\n\tpushAmt btcutil.Amount, numConfs uint32,\n\tupdateChan chan *lnrpc.OpenStatusUpdate, announceChan bool) (\n\t*wire.OutPoint, *wire.MsgTx) {\n\n\tpubl := fundChannel(\n\t\tt, alice, bob, localFundingAmt, pushAmt, false, numConfs,\n\t\tupdateChan, announceChan, nil,\n\t)\n\tfundingOutPoint := &wire.OutPoint{\n\t\tHash:  publ.TxHash(),\n\t\tIndex: 0,\n\t}\n\treturn fundingOutPoint, publ\n}\n\n// fundChannel takes the funding process to the point where the funding\n// transaction is confirmed on-chain. Returns the funding tx.",
      "length": 481,
      "tokens": 60,
      "embedding": []
    },
    {
      "slug": "func fundChannel(t *testing.T, alice, bob *testNode, localFundingAmt,",
      "content": "func fundChannel(t *testing.T, alice, bob *testNode, localFundingAmt,\n\tpushAmt btcutil.Amount, subtractFees bool, numConfs uint32,\n\tupdateChan chan *lnrpc.OpenStatusUpdate, announceChan bool,\n\tchanType *lnwire.ChannelType) *wire.MsgTx {\n\n\t// Create a funding request and start the workflow.\n\terrChan := make(chan error, 1)\n\tinitReq := &InitFundingMsg{\n\t\tPeer:            bob,\n\t\tTargetPubkey:    bob.privKey.PubKey(),\n\t\tChainHash:       *fundingNetParams.GenesisHash,\n\t\tSubtractFees:    subtractFees,\n\t\tLocalFundingAmt: localFundingAmt,\n\t\tPushAmt:         lnwire.NewMSatFromSatoshis(pushAmt),\n\t\tFundingFeePerKw: 1000,\n\t\tPrivate:         !announceChan,\n\t\tChannelType:     chanType,\n\t\tUpdates:         updateChan,\n\t\tErr:             errChan,\n\t}\n\n\talice.fundingMgr.InitFundingWorkflow(initReq)\n\n\t// Alice should have sent the OpenChannel message to Bob.\n\tvar aliceMsg lnwire.Message\n\tselect {\n\tcase aliceMsg = <-alice.msgChan:\n\tcase err := <-initReq.Err:\n\t\tt.Fatalf(\"error init funding workflow: %v\", err)\n\tcase <-time.After(time.Second * 5):\n\t\tt.Fatalf(\"alice did not send OpenChannel message\")\n\t}\n\n\topenChannelReq, ok := aliceMsg.(*lnwire.OpenChannel)\n\tif !ok {\n\t\terrorMsg, gotError := aliceMsg.(*lnwire.Error)\n\t\tif gotError {\n\t\t\tt.Fatalf(\"expected OpenChannel to be sent \"+\n\t\t\t\t\"from bob, instead got error: %v\",\n\t\t\t\terrorMsg.Error())\n\t\t}\n\t\tt.Fatalf(\"expected OpenChannel to be sent from \"+\n\t\t\t\"alice, instead got %T\", aliceMsg)\n\t}\n\n\t// Let Bob handle the init message.\n\tbob.fundingMgr.ProcessFundingMsg(openChannelReq, alice)\n\n\t// Bob should answer with an AcceptChannel message.\n\tacceptChannelResponse := assertFundingMsgSent(\n\t\tt, bob.msgChan, \"AcceptChannel\",\n\t).(*lnwire.AcceptChannel)\n\n\t// They now should both have pending reservations for this channel\n\t// active.\n\tassertNumPendingReservations(t, alice, bobPubKey, 1)\n\tassertNumPendingReservations(t, bob, alicePubKey, 1)\n\n\t// Forward the response to Alice.\n\talice.fundingMgr.ProcessFundingMsg(acceptChannelResponse, bob)\n\n\t// Check that sending warning messages does not abort the funding\n\t// process.\n\twarningMsg := &lnwire.Warning{\n\t\tData: []byte(\"random warning\"),\n\t}\n\talice.fundingMgr.ProcessFundingMsg(warningMsg, bob)\n\tbob.fundingMgr.ProcessFundingMsg(warningMsg, alice)\n\n\t// Alice responds with a FundingCreated message.\n\tfundingCreated := assertFundingMsgSent(\n\t\tt, alice.msgChan, \"FundingCreated\",\n\t).(*lnwire.FundingCreated)\n\n\t// Give the message to Bob.\n\tbob.fundingMgr.ProcessFundingMsg(fundingCreated, alice)\n\n\t// Finally, Bob should send the FundingSigned message.\n\tfundingSigned := assertFundingMsgSent(\n\t\tt, bob.msgChan, \"FundingSigned\",\n\t).(*lnwire.FundingSigned)\n\n\t// Forward the signature to Alice.\n\talice.fundingMgr.ProcessFundingMsg(fundingSigned, bob)\n\n\t// After Alice processes the singleFundingSignComplete message, she will\n\t// broadcast the funding transaction to the network. We expect to get a\n\t// channel update saying the channel is pending.\n\tvar pendingUpdate *lnrpc.OpenStatusUpdate\n\tselect {\n\tcase pendingUpdate = <-updateChan:\n\tcase <-time.After(time.Second * 5):\n\t\tt.Fatalf(\"alice did not send OpenStatusUpdate_ChanPending\")\n\t}\n\n\t_, ok = pendingUpdate.Update.(*lnrpc.OpenStatusUpdate_ChanPending)\n\tif !ok {\n\t\tt.Fatal(\"OpenStatusUpdate was not OpenStatusUpdate_ChanPending\")\n\t}\n\n\t// Get and return the transaction Alice published to the network.\n\tvar publ *wire.MsgTx\n\tselect {\n\tcase publ = <-alice.publTxChan:\n\tcase <-time.After(time.Second * 5):\n\t\tt.Fatalf(\"alice did not publish funding tx\")\n\t}\n\n\t// Make sure the notification about the pending channel was sent out.\n\tselect {\n\tcase <-alice.mockChanEvent.pendingOpenEvent:\n\tcase <-time.After(time.Second * 5):\n\t\tt.Fatalf(\"alice did not send pending channel event\")\n\t}\n\tselect {\n\tcase <-bob.mockChanEvent.pendingOpenEvent:\n\tcase <-time.After(time.Second * 5):\n\t\tt.Fatalf(\"bob did not send pending channel event\")\n\t}\n\n\t// Finally, make sure neither have active reservation for the channel\n\t// now pending open in the database.\n\tassertNumPendingReservations(t, alice, bobPubKey, 0)\n\tassertNumPendingReservations(t, bob, alicePubKey, 0)\n\n\treturn publ\n}\n",
      "length": 3898,
      "tokens": 424,
      "embedding": []
    },
    {
      "slug": "func assertErrorNotSent(t *testing.T, msgChan chan lnwire.Message) {",
      "content": "func assertErrorNotSent(t *testing.T, msgChan chan lnwire.Message) {\n\tt.Helper()\n\n\tselect {\n\tcase <-msgChan:\n\t\tt.Fatalf(\"error sent unexpectedly\")\n\tcase <-time.After(100 * time.Millisecond):\n\t\t// Expected, return.\n\t}\n}\n",
      "length": 141,
      "tokens": 17,
      "embedding": []
    },
    {
      "slug": "func assertErrorSent(t *testing.T, msgChan chan lnwire.Message) {",
      "content": "func assertErrorSent(t *testing.T, msgChan chan lnwire.Message) {\n\tt.Helper()\n\n\tvar msg lnwire.Message\n\tselect {\n\tcase msg = <-msgChan:\n\tcase <-time.After(time.Second * 5):\n\t\tt.Fatalf(\"node did not send Error message\")\n\t}\n\t_, ok := msg.(*lnwire.Error)\n\tif !ok {\n\t\tt.Fatalf(\"expected Error to be sent from \"+\n\t\t\t\"node, instead got %T\", msg)\n\t}\n}\n",
      "length": 265,
      "tokens": 42,
      "embedding": []
    },
    {
      "slug": "func assertFundingMsgSent(t *testing.T, msgChan chan lnwire.Message,",
      "content": "func assertFundingMsgSent(t *testing.T, msgChan chan lnwire.Message,\n\tmsgType string) lnwire.Message {\n\n\tt.Helper()\n\n\tvar msg lnwire.Message\n\tselect {\n\tcase msg = <-msgChan:\n\tcase <-time.After(time.Second * 5):\n\t\tt.Fatalf(\"peer did not send %s message\", msgType)\n\t}\n\n\tvar (\n\t\tsentMsg lnwire.Message\n\t\tok      bool\n\t)\n\tswitch msgType {\n\tcase \"AcceptChannel\":\n\t\tsentMsg, ok = msg.(*lnwire.AcceptChannel)\n\tcase \"FundingCreated\":\n\t\tsentMsg, ok = msg.(*lnwire.FundingCreated)\n\tcase \"FundingSigned\":\n\t\tsentMsg, ok = msg.(*lnwire.FundingSigned)\n\tcase \"FundingLocked\":\n\t\tsentMsg, ok = msg.(*lnwire.FundingLocked)\n\tcase \"Error\":\n\t\tsentMsg, ok = msg.(*lnwire.Error)\n\tdefault:\n\t\tt.Fatalf(\"unknown message type: %s\", msgType)\n\t}\n\n\tif !ok {\n\t\terrorMsg, gotError := msg.(*lnwire.Error)\n\t\tif gotError {\n\t\t\tt.Fatalf(\"expected %s to be sent, instead got \"+\n\t\t\t\t\"error: %v\", msgType, errorMsg.Error())\n\t\t}\n\n\t\t_, _, line, _ := runtime.Caller(1)\n\t\tt.Fatalf(\"expected %s to be sent, instead got %T at %v\",\n\t\t\tmsgType, msg, line)\n\t}\n\n\treturn sentMsg\n}\n",
      "length": 917,
      "tokens": 119,
      "embedding": []
    },
    {
      "slug": "func assertNumPendingReservations(t *testing.T, node *testNode,",
      "content": "func assertNumPendingReservations(t *testing.T, node *testNode,\n\tpeerPubKey *btcec.PublicKey, expectedNum int) {\n\n\tt.Helper()\n\n\tserializedPubKey := newSerializedKey(peerPubKey)\n\tactualNum := len(node.fundingMgr.activeReservations[serializedPubKey])\n\tif actualNum == expectedNum {\n\t\t// Success, return.\n\t\treturn\n\t}\n\n\tt.Fatalf(\"Expected node to have %d pending reservations, had %v\",\n\t\texpectedNum, actualNum)\n}\n",
      "length": 332,
      "tokens": 34,
      "embedding": []
    },
    {
      "slug": "func assertNumPendingChannelsBecomes(t *testing.T, node *testNode,",
      "content": "func assertNumPendingChannelsBecomes(t *testing.T, node *testNode,\n\texpectedNum int) {\n\n\tt.Helper()\n\n\tvar numPendingChans int\n\tfor i := 0; i < testPollNumTries; i++ {\n\t\t// If this is not the first try, sleep before retrying.\n\t\tif i > 0 {\n\t\t\ttime.Sleep(testPollSleepMs * time.Millisecond)\n\t\t}\n\t\tpendingChannels, err := node.fundingMgr.\n\t\t\tcfg.Wallet.Cfg.Database.FetchPendingChannels()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to fetch pending channels: %v\", err)\n\t\t}\n\n\t\tnumPendingChans = len(pendingChannels)\n\t\tif numPendingChans == expectedNum {\n\t\t\t// Success, return.\n\t\t\treturn\n\t\t}\n\t}\n\n\tt.Fatalf(\"Expected node to have %d pending channels, had %v\",\n\t\texpectedNum, numPendingChans)\n}\n",
      "length": 589,
      "tokens": 80,
      "embedding": []
    },
    {
      "slug": "func assertNumPendingChannelsRemains(t *testing.T, node *testNode,",
      "content": "func assertNumPendingChannelsRemains(t *testing.T, node *testNode,\n\texpectedNum int) {\n\n\tt.Helper()\n\n\tvar numPendingChans int\n\tfor i := 0; i < 5; i++ {\n\t\t// If this is not the first try, sleep before retrying.\n\t\tif i > 0 {\n\t\t\ttime.Sleep(200 * time.Millisecond)\n\t\t}\n\t\tpendingChannels, err := node.fundingMgr.\n\t\t\tcfg.Wallet.Cfg.Database.FetchPendingChannels()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to fetch pending channels: %v\", err)\n\t\t}\n\n\t\tnumPendingChans = len(pendingChannels)\n\t\tif numPendingChans != expectedNum {\n\n\t\t\tt.Fatalf(\"Expected node to have %d pending channels, had %v\",\n\t\t\t\texpectedNum, numPendingChans)\n\t\t}\n\t}\n}\n",
      "length": 535,
      "tokens": 76,
      "embedding": []
    },
    {
      "slug": "func assertDatabaseState(t *testing.T, node *testNode,",
      "content": "func assertDatabaseState(t *testing.T, node *testNode,\n\tfundingOutPoint *wire.OutPoint, expectedState channelOpeningState) {\n\n\tt.Helper()\n\n\tvar state channelOpeningState\n\tvar err error\n\tfor i := 0; i < testPollNumTries; i++ {\n\t\t// If this is not the first try, sleep before retrying.\n\t\tif i > 0 {\n\t\t\ttime.Sleep(testPollSleepMs * time.Millisecond)\n\t\t}\n\t\tstate, _, err = node.fundingMgr.getChannelOpeningState(\n\t\t\tfundingOutPoint)\n\t\tif err != nil && err != channeldb.ErrChannelNotFound {\n\t\t\tt.Fatalf(\"unable to get channel state: %v\", err)\n\t\t}\n\n\t\t// If we found the channel, check if it had the expected state.\n\t\tif !errors.Is(err, channeldb.ErrChannelNotFound) &&\n\t\t\tstate == expectedState {\n\n\t\t\t// Got expected state, return with success.\n\t\t\treturn\n\t\t}\n\t}\n\n\t// 10 tries without success.\n\tif err != nil {\n\t\tt.Fatalf(\"error getting channelOpeningState: %v\", err)\n\t} else {\n\t\tt.Fatalf(\"expected state to be %v, was %v\", expectedState,\n\t\t\tstate)\n\t}\n}\n",
      "length": 858,
      "tokens": 124,
      "embedding": []
    },
    {
      "slug": "func assertMarkedOpen(t *testing.T, alice, bob *testNode,",
      "content": "func assertMarkedOpen(t *testing.T, alice, bob *testNode,\n\tfundingOutPoint *wire.OutPoint) {\n\n\tt.Helper()\n\n\t// Make sure the notification about the pending channel was sent out.\n\tselect {\n\tcase <-alice.mockChanEvent.openEvent:\n\tcase <-time.After(time.Second * 5):\n\t\tt.Fatalf(\"alice did not send open channel event\")\n\t}\n\tselect {\n\tcase <-bob.mockChanEvent.openEvent:\n\tcase <-time.After(time.Second * 5):\n\t\tt.Fatalf(\"bob did not send open channel event\")\n\t}\n\n\tassertDatabaseState(t, alice, fundingOutPoint, markedOpen)\n\tassertDatabaseState(t, bob, fundingOutPoint, markedOpen)\n}\n",
      "length": 500,
      "tokens": 57,
      "embedding": []
    },
    {
      "slug": "func assertFundingLockedSent(t *testing.T, alice, bob *testNode,",
      "content": "func assertFundingLockedSent(t *testing.T, alice, bob *testNode,\n\tfundingOutPoint *wire.OutPoint) {\n\n\tt.Helper()\n\n\tassertDatabaseState(t, alice, fundingOutPoint, fundingLockedSent)\n\tassertDatabaseState(t, bob, fundingOutPoint, fundingLockedSent)\n}\n",
      "length": 176,
      "tokens": 13,
      "embedding": []
    },
    {
      "slug": "func assertAddedToRouterGraph(t *testing.T, alice, bob *testNode,",
      "content": "func assertAddedToRouterGraph(t *testing.T, alice, bob *testNode,\n\tfundingOutPoint *wire.OutPoint) {\n\n\tt.Helper()\n\n\tassertDatabaseState(t, alice, fundingOutPoint, addedToRouterGraph)\n\tassertDatabaseState(t, bob, fundingOutPoint, addedToRouterGraph)\n}\n\n// assertChannelAnnouncements checks that alice and bob both sends the expected\n// announcements (ChannelAnnouncement, ChannelUpdate) after the funding tx has\n// confirmed. The last arguments can be set if we expect the nodes to advertise\n// custom min_htlc values as part of their ChannelUpdate. We expect Alice to\n// advertise the value required by Bob and vice versa. If they are not set the\n// advertised value will be checked against the other node's default min_htlc,\n// base fee and fee rate values.",
      "length": 678,
      "tokens": 96,
      "embedding": []
    },
    {
      "slug": "func assertChannelAnnouncements(t *testing.T, alice, bob *testNode,",
      "content": "func assertChannelAnnouncements(t *testing.T, alice, bob *testNode,\n\tcapacity btcutil.Amount, customMinHtlc []lnwire.MilliSatoshi,\n\tcustomMaxHtlc []lnwire.MilliSatoshi, baseFees []lnwire.MilliSatoshi,\n\tfeeRates []lnwire.MilliSatoshi) {\n\n\tt.Helper()\n\n\t// After the FundingLocked message is sent, Alice and Bob will each send\n\t// the following messages to their gossiper:\n\t//\t1) ChannelAnnouncement\n\t//\t2) ChannelUpdate\n\t// The ChannelAnnouncement is kept locally, while the ChannelUpdate is\n\t// sent directly to the other peer, so the edge policies are known to\n\t// both peers.\n\tnodes := []*testNode{alice, bob}\n\tfor j, node := range nodes {\n\t\tannouncements := make([]lnwire.Message, 2)\n\t\tfor i := 0; i < len(announcements); i++ {\n\t\t\tselect {\n\t\t\tcase announcements[i] = <-node.announceChan:\n\t\t\tcase <-time.After(time.Second * 5):\n\t\t\t\tt.Fatalf(\"node didn't send announcement: %v\", i)\n\t\t\t}\n\t\t}\n\n\t\tgotChannelAnnouncement := false\n\t\tgotChannelUpdate := false\n\t\tfor _, msg := range announcements {\n\t\t\tswitch m := msg.(type) {\n\t\t\tcase *lnwire.ChannelAnnouncement:\n\t\t\t\tgotChannelAnnouncement = true\n\t\t\tcase *lnwire.ChannelUpdate:\n\n\t\t\t\t// The channel update sent by the node should\n\t\t\t\t// advertise the MinHTLC value required by the\n\t\t\t\t// _other_ node.\n\t\t\t\tother := (j + 1) % 2\n\t\t\t\tminHtlc := nodes[other].fundingMgr.cfg.\n\t\t\t\t\tDefaultMinHtlcIn\n\n\t\t\t\t// We might expect a custom MinHTLC value.\n\t\t\t\tif len(customMinHtlc) > 0 {\n\t\t\t\t\tif len(customMinHtlc) != 2 {\n\t\t\t\t\t\tt.Fatalf(\"only 0 or 2 custom \" +\n\t\t\t\t\t\t\t\"min htlc values \" +\n\t\t\t\t\t\t\t\"currently supported\")\n\t\t\t\t\t}\n\n\t\t\t\t\tminHtlc = customMinHtlc[j]\n\t\t\t\t}\n\n\t\t\t\tif m.HtlcMinimumMsat != minHtlc {\n\t\t\t\t\tt.Fatalf(\"expected ChannelUpdate to \"+\n\t\t\t\t\t\t\"advertise min HTLC %v, had %v\",\n\t\t\t\t\t\tminHtlc, m.HtlcMinimumMsat)\n\t\t\t\t}\n\n\t\t\t\tmaxHtlc := alice.fundingMgr.cfg.RequiredRemoteMaxValue(\n\t\t\t\t\tcapacity,\n\t\t\t\t)\n\t\t\t\t// We might expect a custom MaxHltc value.\n\t\t\t\tif len(customMaxHtlc) > 0 {\n\t\t\t\t\tif len(customMaxHtlc) != 2 {\n\t\t\t\t\t\tt.Fatalf(\"only 0 or 2 custom \" +\n\t\t\t\t\t\t\t\"min htlc values \" +\n\t\t\t\t\t\t\t\"currently supported\")\n\t\t\t\t\t}\n\n\t\t\t\t\tmaxHtlc = customMaxHtlc[j]\n\t\t\t\t}\n\t\t\t\tif m.MessageFlags != 1 {\n\t\t\t\t\tt.Fatalf(\"expected message flags to \"+\n\t\t\t\t\t\t\"be 1, was %v\", m.MessageFlags)\n\t\t\t\t}\n\n\t\t\t\tif maxHtlc != m.HtlcMaximumMsat {\n\t\t\t\t\tt.Fatalf(\"expected ChannelUpdate to \"+\n\t\t\t\t\t\t\"advertise max HTLC %v, had %v\",\n\t\t\t\t\t\tmaxHtlc,\n\t\t\t\t\t\tm.HtlcMaximumMsat)\n\t\t\t\t}\n\n\t\t\t\tbaseFee := alice.fundingMgr.cfg.DefaultRoutingPolicy.BaseFee\n\n\t\t\t\t// We might expect a custom baseFee value.\n\t\t\t\tif len(baseFees) > 0 {\n\t\t\t\t\tif len(baseFees) != 2 {\n\t\t\t\t\t\tt.Fatalf(\"only 0 or 2 custom \" +\n\t\t\t\t\t\t\t\"base fee values \" +\n\t\t\t\t\t\t\t\"currently supported\")\n\t\t\t\t\t}\n\n\t\t\t\t\tbaseFee = baseFees[j]\n\t\t\t\t}\n\n\t\t\t\tif uint32(baseFee) != m.BaseFee {\n\t\t\t\t\tt.Fatalf(\"expected ChannelUpdate to \"+\n\t\t\t\t\t\t\"advertise base fee %v, had %v\",\n\t\t\t\t\t\tbaseFee,\n\t\t\t\t\t\tm.BaseFee)\n\t\t\t\t}\n\n\t\t\t\tfeeRate := alice.fundingMgr.cfg.DefaultRoutingPolicy.FeeRate\n\n\t\t\t\t// We might expect a custom feeRate value.\n\t\t\t\tif len(feeRates) > 0 {\n\t\t\t\t\tif len(feeRates) != 2 {\n\t\t\t\t\t\tt.Fatalf(\"only 0 or 2 custom \" +\n\t\t\t\t\t\t\t\"fee rate values \" +\n\t\t\t\t\t\t\t\"currently supported\")\n\t\t\t\t\t}\n\n\t\t\t\t\tfeeRate = feeRates[j]\n\t\t\t\t}\n\n\t\t\t\tif uint32(feeRate) != m.FeeRate {\n\t\t\t\t\tt.Fatalf(\"expected ChannelUpdate to \"+\n\t\t\t\t\t\t\"advertise base fee %v, had %v\",\n\t\t\t\t\t\tfeeRate,\n\t\t\t\t\t\tm.FeeRate)\n\t\t\t\t}\n\n\t\t\t\tgotChannelUpdate = true\n\t\t\t}\n\t\t}\n\n\t\tif !gotChannelAnnouncement {\n\t\t\tt.Fatalf(\"did not get ChannelAnnouncement from node %d\",\n\t\t\t\tj)\n\t\t}\n\t\tif !gotChannelUpdate {\n\t\t\tt.Fatalf(\"did not get ChannelUpdate from node %d\", j)\n\t\t}\n\n\t\t// Make sure no other message is sent.\n\t\tselect {\n\t\tcase <-node.announceChan:\n\t\t\tt.Fatalf(\"received unexpected announcement\")\n\t\tcase <-time.After(300 * time.Millisecond):\n\t\t\t// Expected\n\t\t}\n\t}\n}\n",
      "length": 3529,
      "tokens": 463,
      "embedding": []
    },
    {
      "slug": "func assertAnnouncementSignatures(t *testing.T, alice, bob *testNode) {",
      "content": "func assertAnnouncementSignatures(t *testing.T, alice, bob *testNode) {\n\tt.Helper()\n\n\t// After the FundingLocked message is sent and six confirmations have\n\t// been reached, the channel will be announced to the greater network\n\t// by having the nodes exchange announcement signatures.\n\t// Two distinct messages will be sent:\n\t//\t1) AnnouncementSignatures\n\t//\t2) NodeAnnouncement\n\t// These may arrive in no particular order.\n\t// Note that sending the NodeAnnouncement at this point is an\n\t// implementation detail, and not something required by the LN spec.\n\tfor j, node := range []*testNode{alice, bob} {\n\t\tannouncements := make([]lnwire.Message, 2)\n\t\tfor i := 0; i < len(announcements); i++ {\n\t\t\tselect {\n\t\t\tcase announcements[i] = <-node.announceChan:\n\t\t\tcase <-time.After(time.Second * 5):\n\t\t\t\tt.Fatalf(\"node did not send announcement %v\", i)\n\t\t\t}\n\t\t}\n\n\t\tgotAnnounceSignatures := false\n\t\tgotNodeAnnouncement := false\n\t\tfor _, msg := range announcements {\n\t\t\tswitch msg.(type) {\n\t\t\tcase *lnwire.AnnounceSignatures:\n\t\t\t\tgotAnnounceSignatures = true\n\t\t\tcase *lnwire.NodeAnnouncement:\n\t\t\t\tgotNodeAnnouncement = true\n\t\t\t}\n\t\t}\n\n\t\tif !gotAnnounceSignatures {\n\t\t\tt.Fatalf(\"did not get AnnounceSignatures from node %d\",\n\t\t\t\tj)\n\t\t}\n\t\tif !gotNodeAnnouncement {\n\t\t\tt.Fatalf(\"did not get NodeAnnouncement from node %d\", j)\n\t\t}\n\t}\n}\n",
      "length": 1209,
      "tokens": 169,
      "embedding": []
    },
    {
      "slug": "func waitForOpenUpdate(t *testing.T, updateChan chan *lnrpc.OpenStatusUpdate) {",
      "content": "func waitForOpenUpdate(t *testing.T, updateChan chan *lnrpc.OpenStatusUpdate) {\n\tvar openUpdate *lnrpc.OpenStatusUpdate\n\tselect {\n\tcase openUpdate = <-updateChan:\n\tcase <-time.After(time.Second * 5):\n\t\tt.Fatalf(\"alice did not send OpenStatusUpdate\")\n\t}\n\n\t_, ok := openUpdate.Update.(*lnrpc.OpenStatusUpdate_ChanOpen)\n\tif !ok {\n\t\tt.Fatal(\"OpenStatusUpdate was not OpenStatusUpdate_ChanOpen\")\n\t}\n}\n",
      "length": 304,
      "tokens": 32,
      "embedding": []
    },
    {
      "slug": "func assertNoChannelState(t *testing.T, alice, bob *testNode,",
      "content": "func assertNoChannelState(t *testing.T, alice, bob *testNode,\n\tfundingOutPoint *wire.OutPoint) {\n\tt.Helper()\n\n\tassertErrChannelNotFound(t, alice, fundingOutPoint)\n\tassertErrChannelNotFound(t, bob, fundingOutPoint)\n}\n",
      "length": 148,
      "tokens": 11,
      "embedding": []
    },
    {
      "slug": "func assertNoFwdingPolicy(t *testing.T, alice, bob *testNode,",
      "content": "func assertNoFwdingPolicy(t *testing.T, alice, bob *testNode,\n\tfundingOutPoint *wire.OutPoint) {\n\n\tt.Helper()\n\n\tchandID := lnwire.NewChanIDFromOutPoint(fundingOutPoint)\n\tassertInitialFwdingPolicyNotFound(t, alice, &chandID)\n\tassertInitialFwdingPolicyNotFound(t, bob, &chandID)\n}\n",
      "length": 209,
      "tokens": 14,
      "embedding": []
    },
    {
      "slug": "func assertErrChannelNotFound(t *testing.T, node *testNode,",
      "content": "func assertErrChannelNotFound(t *testing.T, node *testNode,\n\tfundingOutPoint *wire.OutPoint) {\n\tt.Helper()\n\n\tvar state channelOpeningState\n\tvar err error\n\tfor i := 0; i < testPollNumTries; i++ {\n\t\t// If this is not the first try, sleep before retrying.\n\t\tif i > 0 {\n\t\t\ttime.Sleep(testPollSleepMs * time.Millisecond)\n\t\t}\n\t\tstate, _, err = node.fundingMgr.getChannelOpeningState(\n\t\t\tfundingOutPoint)\n\t\tif err == channeldb.ErrChannelNotFound {\n\t\t\t// Got expected state, return with success.\n\t\t\treturn\n\t\t} else if err != nil {\n\t\t\tt.Fatalf(\"unable to get channel state: %v\", err)\n\t\t}\n\t}\n\n\t// 10 tries without success.\n\tt.Fatalf(\"expected to not find state, found state %v\", state)\n}\n",
      "length": 595,
      "tokens": 89,
      "embedding": []
    },
    {
      "slug": "func assertInitialFwdingPolicyNotFound(t *testing.T, node *testNode,",
      "content": "func assertInitialFwdingPolicyNotFound(t *testing.T, node *testNode,\n\tchanID *lnwire.ChannelID) {\n\n\tt.Helper()\n\n\tvar fwdingPolicy *htlcswitch.ForwardingPolicy\n\tvar err error\n\tfor i := 0; i < testPollNumTries; i++ {\n\t\t// If this is not the first try, sleep before retrying.\n\t\tif i > 0 {\n\t\t\ttime.Sleep(testPollSleepMs * time.Millisecond)\n\t\t}\n\t\tfwdingPolicy, err = node.fundingMgr.getInitialFwdingPolicy(\n\t\t\t*chanID)\n\t\tif err == channeldb.ErrChannelNotFound {\n\t\t\t// Got expected result, return with success.\n\t\t\treturn\n\t\t} else if err != nil {\n\t\t\tt.Fatalf(\"unable to get forwarding policy from db: %v\",\n\t\t\t\terr)\n\t\t}\n\t}\n\n\t// 10 tries without success.\n\tt.Fatalf(\"expected to not find a forwarding policy, found policy %v\",\n\t\tfwdingPolicy)\n}\n",
      "length": 640,
      "tokens": 92,
      "embedding": []
    },
    {
      "slug": "func assertHandleFundingLocked(t *testing.T, alice, bob *testNode) {",
      "content": "func assertHandleFundingLocked(t *testing.T, alice, bob *testNode) {\n\tt.Helper()\n\n\t// They should both send the new channel state to their peer.\n\tselect {\n\tcase c := <-alice.newChannels:\n\t\tclose(c.err)\n\tcase <-time.After(time.Second * 15):\n\t\tt.Fatalf(\"alice did not send new channel to peer\")\n\t}\n\n\tselect {\n\tcase c := <-bob.newChannels:\n\t\tclose(c.err)\n\tcase <-time.After(time.Second * 15):\n\t\tt.Fatalf(\"bob did not send new channel to peer\")\n\t}\n}\n",
      "length": 360,
      "tokens": 54,
      "embedding": []
    },
    {
      "slug": "func TestFundingManagerNormalWorkflow(t *testing.T) {",
      "content": "func TestFundingManagerNormalWorkflow(t *testing.T) {\n\tt.Parallel()\n\n\talice, bob := setupFundingManagers(t)\n\tt.Cleanup(func() {\n\t\ttearDownFundingManagers(t, alice, bob)\n\t})\n\n\t// We will consume the channel updates as we go, so no buffering is\n\t// needed.\n\tupdateChan := make(chan *lnrpc.OpenStatusUpdate)\n\n\t// Run through the process of opening the channel, up until the funding\n\t// transaction is broadcasted.\n\tlocalAmt := btcutil.Amount(500000)\n\tpushAmt := btcutil.Amount(0)\n\tcapacity := localAmt + pushAmt\n\tfundingOutPoint, fundingTx := openChannel(\n\t\tt, alice, bob, localAmt, pushAmt, 1, updateChan, true,\n\t)\n\n\t// Check that neither Alice nor Bob sent an error message.\n\tassertErrorNotSent(t, alice.msgChan)\n\tassertErrorNotSent(t, bob.msgChan)\n\n\t// Notify that transaction was mined.\n\talice.mockNotifier.oneConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\tbob.mockNotifier.oneConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\n\t// The funding transaction was mined, so assert that both funding\n\t// managers now have the state of this channel 'markedOpen' in their\n\t// internal state machine.\n\tassertMarkedOpen(t, alice, bob, fundingOutPoint)\n\n\t// After the funding transaction is mined, Alice will send\n\t// fundingLocked to Bob.\n\tfundingLockedAlice := assertFundingMsgSent(\n\t\tt, alice.msgChan, \"FundingLocked\",\n\t).(*lnwire.FundingLocked)\n\n\t// And similarly Bob will send funding locked to Alice.\n\tfundingLockedBob := assertFundingMsgSent(\n\t\tt, bob.msgChan, \"FundingLocked\",\n\t).(*lnwire.FundingLocked)\n\n\t// Check that the state machine is updated accordingly\n\tassertFundingLockedSent(t, alice, bob, fundingOutPoint)\n\n\t// Exchange the fundingLocked messages.\n\talice.fundingMgr.ProcessFundingMsg(fundingLockedBob, bob)\n\tbob.fundingMgr.ProcessFundingMsg(fundingLockedAlice, alice)\n\n\t// Check that they notify the breach arbiter and peer about the new\n\t// channel.\n\tassertHandleFundingLocked(t, alice, bob)\n\n\t// Make sure both fundingManagers send the expected channel\n\t// announcements.\n\tassertChannelAnnouncements(t, alice, bob, capacity, nil, nil, nil, nil)\n\n\t// Check that the state machine is updated accordingly\n\tassertAddedToRouterGraph(t, alice, bob, fundingOutPoint)\n\n\t// The funding transaction is now confirmed, wait for the\n\t// OpenStatusUpdate_ChanOpen update\n\twaitForOpenUpdate(t, updateChan)\n\n\t// Notify that six confirmations has been reached on funding\n\t// transaction.\n\talice.mockNotifier.sixConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\tbob.mockNotifier.sixConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\n\t// Make sure the fundingManagers exchange announcement signatures.\n\tassertAnnouncementSignatures(t, alice, bob)\n\n\t// The internal state-machine should now have deleted the channelStates\n\t// from the database, as the channel is announced.\n\tassertNoChannelState(t, alice, bob, fundingOutPoint)\n\n\t// The forwarding policy for the channel announcement should\n\t// have been deleted from the database, as the channel is announced.\n\tassertNoFwdingPolicy(t, alice, bob, fundingOutPoint)\n}\n\n// TestFundingManagerRejectCSV tests checking of local CSV values against our\n// local CSV limit for incoming and outgoing channels.",
      "length": 3054,
      "tokens": 364,
      "embedding": []
    },
    {
      "slug": "func TestFundingManagerRejectCSV(t *testing.T) {",
      "content": "func TestFundingManagerRejectCSV(t *testing.T) {\n\tt.Run(\"csv too high\", func(t *testing.T) {\n\t\ttestLocalCSVLimit(t, 400, 500)\n\t})\n\tt.Run(\"csv within limit\", func(t *testing.T) {\n\t\ttestLocalCSVLimit(t, 600, 500)\n\t})\n}\n\n// testLocalCSVLimit creates two funding managers, alice and bob, where alice\n// has a limit on her maximum local CSV and bob sets his required CSV for alice.\n// We test an incoming and outgoing channel, ensuring that alice accepts csvs\n// below her maximum, and rejects those above it.",
      "length": 444,
      "tokens": 71,
      "embedding": []
    },
    {
      "slug": "func testLocalCSVLimit(t *testing.T, aliceMaxCSV, bobRequiredCSV uint16) {",
      "content": "func testLocalCSVLimit(t *testing.T, aliceMaxCSV, bobRequiredCSV uint16) {\n\tt.Parallel()\n\n\talice, bob := setupFundingManagers(t)\n\tt.Cleanup(func() {\n\t\ttearDownFundingManagers(t, alice, bob)\n\t})\n\n\t// Set a maximum local delay in alice's config to aliceMaxCSV and\n\t// overwrite bob's required remote delay function to return\n\t// bobRequiredCSV.\n\talice.fundingMgr.cfg.MaxLocalCSVDelay = aliceMaxCSV\n\tbob.fundingMgr.cfg.RequiredRemoteDelay = func(_ btcutil.Amount) uint16 {\n\t\treturn bobRequiredCSV\n\t}\n\n\t// For convenience, we bump our max pending channels to 2 so that we\n\t// can test incoming and outgoing channels without needing to step\n\t// through the full funding process.\n\talice.fundingMgr.cfg.MaxPendingChannels = 2\n\tbob.fundingMgr.cfg.MaxPendingChannels = 2\n\n\t// If our maximum is less than the value bob sets, we expect this test\n\t// to fail.\n\texpectFail := aliceMaxCSV < bobRequiredCSV\n\n\t// First, we will initiate an outgoing channel from Alice -> Bob.\n\terrChan := make(chan error, 1)\n\tupdateChan := make(chan *lnrpc.OpenStatusUpdate)\n\tinitReq := &InitFundingMsg{\n\t\tPeer:            bob,\n\t\tTargetPubkey:    bob.privKey.PubKey(),\n\t\tChainHash:       *fundingNetParams.GenesisHash,\n\t\tLocalFundingAmt: 200000,\n\t\tFundingFeePerKw: 1000,\n\t\tUpdates:         updateChan,\n\t\tErr:             errChan,\n\t}\n\n\t// Alice should have sent the OpenChannel message to Bob.\n\talice.fundingMgr.InitFundingWorkflow(initReq)\n\tvar aliceMsg lnwire.Message\n\tselect {\n\tcase aliceMsg = <-alice.msgChan:\n\n\tcase err := <-initReq.Err:\n\t\tt.Fatalf(\"error init funding workflow: %v\", err)\n\n\tcase <-time.After(time.Second * 5):\n\t\tt.Fatalf(\"alice did not send OpenChannel message\")\n\t}\n\n\topenChannelReq, ok := aliceMsg.(*lnwire.OpenChannel)\n\trequire.True(t, ok)\n\n\t// Let Bob handle the init message.\n\tbob.fundingMgr.ProcessFundingMsg(openChannelReq, alice)\n\n\t// Bob should answer with an AcceptChannel message.\n\tacceptChannelResponse := assertFundingMsgSent(\n\t\tt, bob.msgChan, \"AcceptChannel\",\n\t).(*lnwire.AcceptChannel)\n\n\t// They now should both have pending reservations for this channel\n\t// active.\n\tassertNumPendingReservations(t, alice, bobPubKey, 1)\n\tassertNumPendingReservations(t, bob, alicePubKey, 1)\n\n\t// Forward the response to Alice.\n\talice.fundingMgr.ProcessFundingMsg(acceptChannelResponse, bob)\n\n\t// At this point, Alice has received an AcceptChannel message from\n\t// bob with the CSV value that he has set for her, and has to evaluate\n\t// whether she wants to accept this channel. If we get an error, we\n\t// assert that we expected the channel to fail, otherwise we assert that\n\t// she proceeded with the channel open as usual.\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.Error(t, err)\n\t\trequire.True(t, expectFail)\n\n\tcase msg := <-alice.msgChan:\n\t\t_, ok := msg.(*lnwire.FundingCreated)\n\t\trequire.True(t, ok)\n\t\trequire.False(t, expectFail)\n\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"funding flow was not failed\")\n\t}\n\n\t// We do not need to complete the rest of the funding flow (it is\n\t// covered in other tests). So now we test that Alice will appropriately\n\t// handle incoming channels, opening a channel from Bob->Alice.\n\terrChan = make(chan error, 1)\n\tupdateChan = make(chan *lnrpc.OpenStatusUpdate)\n\tinitReq = &InitFundingMsg{\n\t\tPeer:            alice,\n\t\tTargetPubkey:    alice.privKey.PubKey(),\n\t\tChainHash:       *fundingNetParams.GenesisHash,\n\t\tLocalFundingAmt: 200000,\n\t\tFundingFeePerKw: 1000,\n\t\tUpdates:         updateChan,\n\t\tErr:             errChan,\n\t}\n\n\tbob.fundingMgr.InitFundingWorkflow(initReq)\n\n\t// Bob should have sent the OpenChannel message to Alice.\n\tvar bobMsg lnwire.Message\n\tselect {\n\tcase bobMsg = <-bob.msgChan:\n\n\tcase err := <-initReq.Err:\n\t\tt.Fatalf(\"bob OpenChannel message failed: %v\", err)\n\n\tcase <-time.After(time.Second * 5):\n\t\tt.Fatalf(\"bob did not send OpenChannel message\")\n\t}\n\n\topenChannelReq, ok = bobMsg.(*lnwire.OpenChannel)\n\trequire.True(t, ok)\n\n\t// Let Alice handle the init message.\n\talice.fundingMgr.ProcessFundingMsg(openChannelReq, bob)\n\n\t// We expect a error message from Alice if we're expecting the channel\n\t// to fail, otherwise we expect her to proceed with the channel as\n\t// usual.\n\tselect {\n\tcase msg := <-alice.msgChan:\n\t\tvar ok bool\n\t\tif expectFail {\n\t\t\t_, ok = msg.(*lnwire.Error)\n\t\t} else {\n\t\t\t_, ok = msg.(*lnwire.AcceptChannel)\n\t\t}\n\t\trequire.True(t, ok)\n\n\tcase <-time.After(time.Second * 5):\n\t\tt.Fatal(\"funding flow was not failed\")\n\t}\n}\n",
      "length": 4167,
      "tokens": 523,
      "embedding": []
    },
    {
      "slug": "func TestFundingManagerRestartBehavior(t *testing.T) {",
      "content": "func TestFundingManagerRestartBehavior(t *testing.T) {\n\tt.Parallel()\n\n\talice, bob := setupFundingManagers(t)\n\tt.Cleanup(func() {\n\t\ttearDownFundingManagers(t, alice, bob)\n\t})\n\n\t// Run through the process of opening the channel, up until the funding\n\t// transaction is broadcasted.\n\tlocalAmt := btcutil.Amount(500000)\n\tpushAmt := btcutil.Amount(0)\n\tcapacity := localAmt + pushAmt\n\tupdateChan := make(chan *lnrpc.OpenStatusUpdate)\n\tfundingOutPoint, fundingTx := openChannel(\n\t\tt, alice, bob, localAmt, pushAmt, 1, updateChan, true,\n\t)\n\n\t// After the funding transaction gets mined, both nodes will send the\n\t// fundingLocked message to the other peer. If the funding node fails\n\t// before this message has been successfully sent, it should retry\n\t// sending it on restart. We mimic this behavior by letting the\n\t// SendToPeer method return an error, as if the message was not\n\t// successfully sent. We then recreate the fundingManager and make sure\n\t// it continues the process as expected. We'll save the current\n\t// implementation of sendMessage to restore the original behavior later\n\t// on.\n\tworkingSendMessage := bob.sendMessage\n\tbob.sendMessage = func(msg lnwire.Message) error {\n\t\treturn fmt.Errorf(\"intentional error in SendToPeer\")\n\t}\n\tnotifyWhenOnline := func(peer [33]byte, con chan<- lnpeer.Peer) {\n\t\t// Intentionally empty\n\t}\n\talice.fundingMgr.cfg.NotifyWhenOnline = notifyWhenOnline\n\n\t// Notify that transaction was mined\n\talice.mockNotifier.oneConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\tbob.mockNotifier.oneConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\n\t// The funding transaction was mined, so assert that both funding\n\t// managers now have the state of this channel 'markedOpen' in their\n\t// internal state machine.\n\tassertMarkedOpen(t, alice, bob, fundingOutPoint)\n\n\t// After the funding transaction was mined, Bob should have successfully\n\t// sent the fundingLocked message, while Alice failed sending it. In\n\t// Alice's case this means that there should be no messages for Bob, and\n\t// the channel should still be in state 'markedOpen'\n\tselect {\n\tcase msg := <-alice.msgChan:\n\t\tt.Fatalf(\"did not expect any message from Alice: %v\", msg)\n\tdefault:\n\t\t// Expected.\n\t}\n\n\t// Bob will send funding locked to Alice.\n\tfundingLockedBob := assertFundingMsgSent(\n\t\tt, bob.msgChan, \"FundingLocked\",\n\t).(*lnwire.FundingLocked)\n\n\t// Alice should still be markedOpen\n\tassertDatabaseState(t, alice, fundingOutPoint, markedOpen)\n\n\t// While Bob successfully sent fundingLocked.\n\tassertDatabaseState(t, bob, fundingOutPoint, fundingLockedSent)\n\n\t// We now recreate Alice's fundingManager with the correct sendMessage\n\t// implementation, and expect it to retry sending the fundingLocked\n\t// message. We'll explicitly shut down Alice's funding manager to\n\t// prevent a race when overriding the sendMessage implementation.\n\tif err := alice.fundingMgr.Stop(); err != nil {\n\t\tt.Fatalf(\"failed stop funding manager: %v\", err)\n\t}\n\tbob.sendMessage = workingSendMessage\n\trecreateAliceFundingManager(t, alice)\n\n\t// Intentionally make the channel announcements fail\n\talice.fundingMgr.cfg.SendAnnouncement = func(msg lnwire.Message,\n\t\t_ ...discovery.OptionalMsgField) chan error {\n\n\t\terrChan := make(chan error, 1)\n\t\terrChan <- fmt.Errorf(\"intentional error in SendAnnouncement\")\n\t\treturn errChan\n\t}\n\n\tfundingLockedAlice := assertFundingMsgSent(\n\t\tt, alice.msgChan, \"FundingLocked\",\n\t).(*lnwire.FundingLocked)\n\n\t// The state should now be fundingLockedSent\n\tassertDatabaseState(t, alice, fundingOutPoint, fundingLockedSent)\n\n\t// Check that the channel announcements were never sent\n\tselect {\n\tcase ann := <-alice.announceChan:\n\t\tt.Fatalf(\"unexpectedly got channel announcement message: %v\",\n\t\t\tann)\n\tdefault:\n\t\t// Expected\n\t}\n\n\t// Exchange the fundingLocked messages.\n\talice.fundingMgr.ProcessFundingMsg(fundingLockedBob, bob)\n\tbob.fundingMgr.ProcessFundingMsg(fundingLockedAlice, alice)\n\n\t// Check that they notify the breach arbiter and peer about the new\n\t// channel.\n\tassertHandleFundingLocked(t, alice, bob)\n\n\t// Next up, we check that Alice rebroadcasts the announcement\n\t// messages on restart. Bob should as expected send announcements.\n\trecreateAliceFundingManager(t, alice)\n\ttime.Sleep(300 * time.Millisecond)\n\n\t// Make sure both fundingManagers send the expected channel\n\t// announcements.\n\tassertChannelAnnouncements(t, alice, bob, capacity, nil, nil, nil, nil)\n\n\t// Check that the state machine is updated accordingly\n\tassertAddedToRouterGraph(t, alice, bob, fundingOutPoint)\n\n\t// Next, we check that Alice sends the announcement signatures\n\t// on restart after six confirmations. Bob should as expected send\n\t// them as well.\n\trecreateAliceFundingManager(t, alice)\n\ttime.Sleep(300 * time.Millisecond)\n\n\t// Notify that six confirmations has been reached on funding\n\t// transaction.\n\talice.mockNotifier.sixConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\tbob.mockNotifier.sixConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\n\t// Make sure the fundingManagers exchange announcement signatures.\n\tassertAnnouncementSignatures(t, alice, bob)\n\n\t// The internal state-machine should now have deleted the channelStates\n\t// from the database, as the channel is announced.\n\tassertNoChannelState(t, alice, bob, fundingOutPoint)\n\n\t// The forwarding policy for the channel announcement should\n\t// have been deleted from the database, as the channel is announced.\n\tassertNoFwdingPolicy(t, alice, bob, fundingOutPoint)\n}\n\n// TestFundingManagerOfflinePeer checks that the fundingManager waits for the\n// server to notify when the peer comes online, in case sending the\n// fundingLocked message fails the first time.",
      "length": 5457,
      "tokens": 687,
      "embedding": []
    },
    {
      "slug": "func TestFundingManagerOfflinePeer(t *testing.T) {",
      "content": "func TestFundingManagerOfflinePeer(t *testing.T) {\n\tt.Parallel()\n\n\talice, bob := setupFundingManagers(t)\n\tt.Cleanup(func() {\n\t\ttearDownFundingManagers(t, alice, bob)\n\t})\n\n\t// Run through the process of opening the channel, up until the funding\n\t// transaction is broadcasted.\n\tlocalAmt := btcutil.Amount(500000)\n\tpushAmt := btcutil.Amount(0)\n\tcapacity := localAmt + pushAmt\n\tupdateChan := make(chan *lnrpc.OpenStatusUpdate)\n\tfundingOutPoint, fundingTx := openChannel(\n\t\tt, alice, bob, localAmt, pushAmt, 1, updateChan, true,\n\t)\n\n\t// After the funding transaction gets mined, both nodes will send the\n\t// fundingLocked message to the other peer. If the funding node fails\n\t// to send the fundingLocked message to the peer, it should wait for\n\t// the server to notify it that the peer is back online, and try again.\n\t// We'll save the current implementation of sendMessage to restore the\n\t// original behavior later on.\n\tworkingSendMessage := bob.sendMessage\n\tbob.sendMessage = func(msg lnwire.Message) error {\n\t\treturn fmt.Errorf(\"intentional error in SendToPeer\")\n\t}\n\tpeerChan := make(chan [33]byte, 1)\n\tconChan := make(chan chan<- lnpeer.Peer, 1)\n\talice.fundingMgr.cfg.NotifyWhenOnline = func(peer [33]byte,\n\t\tconnected chan<- lnpeer.Peer) {\n\n\t\tpeerChan <- peer\n\t\tconChan <- connected\n\t}\n\n\t// Notify that transaction was mined\n\talice.mockNotifier.oneConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\tbob.mockNotifier.oneConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\n\t// The funding transaction was mined, so assert that both funding\n\t// managers now have the state of this channel 'markedOpen' in their\n\t// internal state machine.\n\tassertMarkedOpen(t, alice, bob, fundingOutPoint)\n\n\t// After the funding transaction was mined, Bob should have successfully\n\t// sent the fundingLocked message, while Alice failed sending it. In\n\t// Alice's case this means that there should be no messages for Bob, and\n\t// the channel should still be in state 'markedOpen'\n\tselect {\n\tcase msg := <-alice.msgChan:\n\t\tt.Fatalf(\"did not expect any message from Alice: %v\", msg)\n\tdefault:\n\t\t// Expected.\n\t}\n\n\t// Bob will send funding locked to Alice\n\tfundingLockedBob := assertFundingMsgSent(\n\t\tt, bob.msgChan, \"FundingLocked\",\n\t).(*lnwire.FundingLocked)\n\n\t// Alice should still be markedOpen\n\tassertDatabaseState(t, alice, fundingOutPoint, markedOpen)\n\n\t// While Bob successfully sent fundingLocked.\n\tassertDatabaseState(t, bob, fundingOutPoint, fundingLockedSent)\n\n\t// Alice should be waiting for the server to notify when Bob comes back\n\t// online.\n\tvar peer [33]byte\n\tvar con chan<- lnpeer.Peer\n\tselect {\n\tcase peer = <-peerChan:\n\t\t// Expected\n\tcase <-time.After(time.Second * 3):\n\t\tt.Fatalf(\"alice did not register peer with server\")\n\t}\n\n\tselect {\n\tcase con = <-conChan:\n\t\t// Expected\n\tcase <-time.After(time.Second * 3):\n\t\tt.Fatalf(\"alice did not register connectedChan with server\")\n\t}\n\n\tif !bytes.Equal(peer[:], bobPubKey.SerializeCompressed()) {\n\t\tt.Fatalf(\"expected to receive Bob's pubkey (%v), instead \"+\n\t\t\t\"got %v\", bobPubKey, peer)\n\t}\n\n\t// Before sending on the con chan, update Alice's NotifyWhenOnline\n\t// function so that the next invocation in receivedFundingLocked will\n\t// use this new function.\n\talice.fundingMgr.cfg.NotifyWhenOnline = func(peer [33]byte,\n\t\tconnected chan<- lnpeer.Peer) {\n\n\t\tconnected <- bob\n\t}\n\n\t// Restore the correct sendMessage implementation, and notify that Bob\n\t// is back online.\n\tbob.sendMessage = workingSendMessage\n\tcon <- bob\n\n\t// This should make Alice send the fundingLocked.\n\tfundingLockedAlice := assertFundingMsgSent(\n\t\tt, alice.msgChan, \"FundingLocked\",\n\t).(*lnwire.FundingLocked)\n\n\t// The state should now be fundingLockedSent\n\tassertDatabaseState(t, alice, fundingOutPoint, fundingLockedSent)\n\n\t// Exchange the fundingLocked messages.\n\talice.fundingMgr.ProcessFundingMsg(fundingLockedBob, bob)\n\tbob.fundingMgr.ProcessFundingMsg(fundingLockedAlice, alice)\n\n\t// Check that they notify the breach arbiter and peer about the new\n\t// channel.\n\tassertHandleFundingLocked(t, alice, bob)\n\n\t// Make sure both fundingManagers send the expected channel\n\t// announcements.\n\tassertChannelAnnouncements(t, alice, bob, capacity, nil, nil, nil, nil)\n\n\t// Check that the state machine is updated accordingly\n\tassertAddedToRouterGraph(t, alice, bob, fundingOutPoint)\n\n\t// The funding transaction is now confirmed, wait for the\n\t// OpenStatusUpdate_ChanOpen update\n\twaitForOpenUpdate(t, updateChan)\n\n\t// Notify that six confirmations has been reached on funding\n\t// transaction.\n\talice.mockNotifier.sixConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\tbob.mockNotifier.sixConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\n\t// Make sure both fundingManagers send the expected announcement\n\t// signatures.\n\tassertAnnouncementSignatures(t, alice, bob)\n\n\t// The internal state-machine should now have deleted the channelStates\n\t// from the database, as the channel is announced.\n\tassertNoChannelState(t, alice, bob, fundingOutPoint)\n\n\t// The forwarding policy for the channel announcement should\n\t// have been deleted from the database, as the channel is announced.\n\tassertNoFwdingPolicy(t, alice, bob, fundingOutPoint)\n}\n\n// TestFundingManagerPeerTimeoutAfterInitFunding checks that the zombie sweeper\n// will properly clean up a zombie reservation that times out after the\n// InitFundingMsg has been handled.",
      "length": 5174,
      "tokens": 662,
      "embedding": []
    },
    {
      "slug": "func TestFundingManagerPeerTimeoutAfterInitFunding(t *testing.T) {",
      "content": "func TestFundingManagerPeerTimeoutAfterInitFunding(t *testing.T) {\n\tt.Parallel()\n\n\talice, bob := setupFundingManagers(t)\n\tt.Cleanup(func() {\n\t\ttearDownFundingManagers(t, alice, bob)\n\t})\n\n\t// We will consume the channel updates as we go, so no buffering is\n\t// needed.\n\tupdateChan := make(chan *lnrpc.OpenStatusUpdate)\n\n\t// Create a funding request and start the workflow.\n\terrChan := make(chan error, 1)\n\tinitReq := &InitFundingMsg{\n\t\tPeer:            bob,\n\t\tTargetPubkey:    bob.privKey.PubKey(),\n\t\tChainHash:       *fundingNetParams.GenesisHash,\n\t\tLocalFundingAmt: 500000,\n\t\tPushAmt:         lnwire.NewMSatFromSatoshis(0),\n\t\tPrivate:         false,\n\t\tUpdates:         updateChan,\n\t\tErr:             errChan,\n\t}\n\n\talice.fundingMgr.InitFundingWorkflow(initReq)\n\n\t// Alice should have sent the OpenChannel message to Bob.\n\tvar aliceMsg lnwire.Message\n\tselect {\n\tcase aliceMsg = <-alice.msgChan:\n\tcase err := <-initReq.Err:\n\t\tt.Fatalf(\"error init funding workflow: %v\", err)\n\tcase <-time.After(time.Second * 5):\n\t\tt.Fatalf(\"alice did not send OpenChannel message\")\n\t}\n\n\t_, ok := aliceMsg.(*lnwire.OpenChannel)\n\tif !ok {\n\t\terrorMsg, gotError := aliceMsg.(*lnwire.Error)\n\t\tif gotError {\n\t\t\tt.Fatalf(\"expected OpenChannel to be sent \"+\n\t\t\t\t\"from bob, instead got error: %v\",\n\t\t\t\terrorMsg.Error())\n\t\t}\n\t\tt.Fatalf(\"expected OpenChannel to be sent from \"+\n\t\t\t\"alice, instead got %T\", aliceMsg)\n\t}\n\n\t// Alice should have a new pending reservation.\n\tassertNumPendingReservations(t, alice, bobPubKey, 1)\n\n\t// Make sure Alice's reservation times out and then run her zombie\n\t// sweeper.\n\ttime.Sleep(1 * time.Millisecond)\n\tgo alice.fundingMgr.pruneZombieReservations()\n\n\t// Alice should have sent an Error message to Bob.\n\tassertErrorSent(t, alice.msgChan)\n\n\t// Alice's zombie reservation should have been pruned.\n\tassertNumPendingReservations(t, alice, bobPubKey, 0)\n}\n\n// TestFundingManagerPeerTimeoutAfterFundingOpen checks that the zombie sweeper\n// will properly clean up a zombie reservation that times out after the\n// fundingOpenMsg has been handled.",
      "length": 1913,
      "tokens": 228,
      "embedding": []
    },
    {
      "slug": "func TestFundingManagerPeerTimeoutAfterFundingOpen(t *testing.T) {",
      "content": "func TestFundingManagerPeerTimeoutAfterFundingOpen(t *testing.T) {\n\tt.Parallel()\n\n\talice, bob := setupFundingManagers(t)\n\tt.Cleanup(func() {\n\t\ttearDownFundingManagers(t, alice, bob)\n\t})\n\n\t// We will consume the channel updates as we go, so no buffering is\n\t// needed.\n\tupdateChan := make(chan *lnrpc.OpenStatusUpdate)\n\n\t// Create a funding request and start the workflow.\n\terrChan := make(chan error, 1)\n\tinitReq := &InitFundingMsg{\n\t\tPeer:            bob,\n\t\tTargetPubkey:    bob.privKey.PubKey(),\n\t\tChainHash:       *fundingNetParams.GenesisHash,\n\t\tLocalFundingAmt: 500000,\n\t\tPushAmt:         lnwire.NewMSatFromSatoshis(0),\n\t\tPrivate:         false,\n\t\tUpdates:         updateChan,\n\t\tErr:             errChan,\n\t}\n\n\talice.fundingMgr.InitFundingWorkflow(initReq)\n\n\t// Alice should have sent the OpenChannel message to Bob.\n\tvar aliceMsg lnwire.Message\n\tselect {\n\tcase aliceMsg = <-alice.msgChan:\n\tcase err := <-initReq.Err:\n\t\tt.Fatalf(\"error init funding workflow: %v\", err)\n\tcase <-time.After(time.Second * 5):\n\t\tt.Fatalf(\"alice did not send OpenChannel message\")\n\t}\n\n\topenChannelReq, ok := aliceMsg.(*lnwire.OpenChannel)\n\tif !ok {\n\t\terrorMsg, gotError := aliceMsg.(*lnwire.Error)\n\t\tif gotError {\n\t\t\tt.Fatalf(\"expected OpenChannel to be sent \"+\n\t\t\t\t\"from bob, instead got error: %v\",\n\t\t\t\terrorMsg.Error())\n\t\t}\n\t\tt.Fatalf(\"expected OpenChannel to be sent from \"+\n\t\t\t\"alice, instead got %T\", aliceMsg)\n\t}\n\n\t// Alice should have a new pending reservation.\n\tassertNumPendingReservations(t, alice, bobPubKey, 1)\n\n\t// Let Bob handle the init message.\n\tbob.fundingMgr.ProcessFundingMsg(openChannelReq, alice)\n\n\t// Bob should answer with an AcceptChannel.\n\tassertFundingMsgSent(t, bob.msgChan, \"AcceptChannel\")\n\n\t// Bob should have a new pending reservation.\n\tassertNumPendingReservations(t, bob, alicePubKey, 1)\n\n\t// Make sure Bob's reservation times out and then run his zombie\n\t// sweeper.\n\ttime.Sleep(1 * time.Millisecond)\n\tgo bob.fundingMgr.pruneZombieReservations()\n\n\t// Bob should have sent an Error message to Alice.\n\tassertErrorSent(t, bob.msgChan)\n\n\t// Bob's zombie reservation should have been pruned.\n\tassertNumPendingReservations(t, bob, alicePubKey, 0)\n}\n\n// TestFundingManagerPeerTimeoutAfterFundingAccept checks that the zombie\n// sweeper will properly clean up a zombie reservation that times out after the\n// fundingAcceptMsg has been handled.",
      "length": 2211,
      "tokens": 259,
      "embedding": []
    },
    {
      "slug": "func TestFundingManagerPeerTimeoutAfterFundingAccept(t *testing.T) {",
      "content": "func TestFundingManagerPeerTimeoutAfterFundingAccept(t *testing.T) {\n\tt.Parallel()\n\n\talice, bob := setupFundingManagers(t)\n\tt.Cleanup(func() {\n\t\ttearDownFundingManagers(t, alice, bob)\n\t})\n\n\t// We will consume the channel updates as we go, so no buffering is\n\t// needed.\n\tupdateChan := make(chan *lnrpc.OpenStatusUpdate)\n\n\t// Create a funding request and start the workflow.\n\terrChan := make(chan error, 1)\n\tinitReq := &InitFundingMsg{\n\t\tPeer:            bob,\n\t\tTargetPubkey:    bob.privKey.PubKey(),\n\t\tChainHash:       *fundingNetParams.GenesisHash,\n\t\tLocalFundingAmt: 500000,\n\t\tPushAmt:         lnwire.NewMSatFromSatoshis(0),\n\t\tPrivate:         false,\n\t\tUpdates:         updateChan,\n\t\tErr:             errChan,\n\t}\n\n\talice.fundingMgr.InitFundingWorkflow(initReq)\n\n\t// Alice should have sent the OpenChannel message to Bob.\n\tvar aliceMsg lnwire.Message\n\tselect {\n\tcase aliceMsg = <-alice.msgChan:\n\tcase err := <-initReq.Err:\n\t\tt.Fatalf(\"error init funding workflow: %v\", err)\n\tcase <-time.After(time.Second * 5):\n\t\tt.Fatalf(\"alice did not send OpenChannel message\")\n\t}\n\n\topenChannelReq, ok := aliceMsg.(*lnwire.OpenChannel)\n\tif !ok {\n\t\terrorMsg, gotError := aliceMsg.(*lnwire.Error)\n\t\tif gotError {\n\t\t\tt.Fatalf(\"expected OpenChannel to be sent \"+\n\t\t\t\t\"from bob, instead got error: %v\",\n\t\t\t\terrorMsg.Error())\n\t\t}\n\t\tt.Fatalf(\"expected OpenChannel to be sent from \"+\n\t\t\t\"alice, instead got %T\", aliceMsg)\n\t}\n\n\t// Alice should have a new pending reservation.\n\tassertNumPendingReservations(t, alice, bobPubKey, 1)\n\n\t// Let Bob handle the init message.\n\tbob.fundingMgr.ProcessFundingMsg(openChannelReq, alice)\n\n\t// Bob should answer with an AcceptChannel.\n\tacceptChannelResponse := assertFundingMsgSent(\n\t\tt, bob.msgChan, \"AcceptChannel\",\n\t).(*lnwire.AcceptChannel)\n\n\t// Bob should have a new pending reservation.\n\tassertNumPendingReservations(t, bob, alicePubKey, 1)\n\n\t// Forward the response to Alice.\n\talice.fundingMgr.ProcessFundingMsg(acceptChannelResponse, bob)\n\n\t// Alice responds with a FundingCreated messages.\n\tassertFundingMsgSent(t, alice.msgChan, \"FundingCreated\")\n\n\t// Make sure Alice's reservation times out and then run her zombie\n\t// sweeper.\n\ttime.Sleep(1 * time.Millisecond)\n\tgo alice.fundingMgr.pruneZombieReservations()\n\n\t// Alice should have sent an Error message to Bob.\n\tassertErrorSent(t, alice.msgChan)\n\n\t// Alice's zombie reservation should have been pruned.\n\tassertNumPendingReservations(t, alice, bobPubKey, 0)\n}\n",
      "length": 2287,
      "tokens": 256,
      "embedding": []
    },
    {
      "slug": "func TestFundingManagerFundingTimeout(t *testing.T) {",
      "content": "func TestFundingManagerFundingTimeout(t *testing.T) {\n\tt.Parallel()\n\n\talice, bob := setupFundingManagers(t)\n\tt.Cleanup(func() {\n\t\ttearDownFundingManagers(t, alice, bob)\n\t})\n\n\t// We will consume the channel updates as we go, so no buffering is\n\t// needed.\n\tupdateChan := make(chan *lnrpc.OpenStatusUpdate)\n\n\t// Run through the process of opening the channel, up until the funding\n\t// transaction is broadcasted.\n\t_, _ = openChannel(t, alice, bob, 500000, 0, 1, updateChan, true)\n\n\t// Bob will at this point be waiting for the funding transaction to be\n\t// confirmed, so the channel should be considered pending.\n\tpendingChannels, err := bob.fundingMgr.cfg.Wallet.Cfg.Database.FetchPendingChannels()\n\trequire.NoError(t, err, \"unable to fetch pending channels\")\n\tif len(pendingChannels) != 1 {\n\t\tt.Fatalf(\"Expected Bob to have 1 pending channel, had  %v\",\n\t\t\tlen(pendingChannels))\n\t}\n\n\t// We expect Bob to forget the channel after 2016 blocks (2 weeks), so\n\t// mine 2016-1, and check that it is still pending.\n\tbob.mockNotifier.epochChan <- &chainntnfs.BlockEpoch{\n\t\tHeight: fundingBroadcastHeight + maxWaitNumBlocksFundingConf - 1,\n\t}\n\n\t// Bob should still be waiting for the channel to open.\n\tassertNumPendingChannelsRemains(t, bob, 1)\n\n\tbob.mockNotifier.epochChan <- &chainntnfs.BlockEpoch{\n\t\tHeight: fundingBroadcastHeight + maxWaitNumBlocksFundingConf,\n\t}\n\n\t// Bob should have sent an Error message to Alice.\n\tassertErrorSent(t, bob.msgChan)\n\n\t// Should not be pending anymore.\n\tassertNumPendingChannelsBecomes(t, bob, 0)\n}\n\n// TestFundingManagerFundingNotTimeoutInitiator checks that if the user was\n// the channel initiator, that it does not timeout when the lnd restarts.",
      "length": 1577,
      "tokens": 208,
      "embedding": []
    },
    {
      "slug": "func TestFundingManagerFundingNotTimeoutInitiator(t *testing.T) {",
      "content": "func TestFundingManagerFundingNotTimeoutInitiator(t *testing.T) {\n\tt.Parallel()\n\n\talice, bob := setupFundingManagers(t)\n\tt.Cleanup(func() {\n\t\ttearDownFundingManagers(t, alice, bob)\n\t})\n\n\t// We will consume the channel updates as we go, so no buffering is\n\t// needed.\n\tupdateChan := make(chan *lnrpc.OpenStatusUpdate)\n\n\t// Run through the process of opening the channel, up until the funding\n\t// transaction is broadcasted.\n\t_, _ = openChannel(t, alice, bob, 500000, 0, 1, updateChan, true)\n\n\t// Alice will at this point be waiting for the funding transaction to be\n\t// confirmed, so the channel should be considered pending.\n\tpendingChannels, err := alice.fundingMgr.cfg.Wallet.Cfg.Database.FetchPendingChannels()\n\trequire.NoError(t, err, \"unable to fetch pending channels\")\n\tif len(pendingChannels) != 1 {\n\t\tt.Fatalf(\"Expected Alice to have 1 pending channel, had  %v\",\n\t\t\tlen(pendingChannels))\n\t}\n\n\trecreateAliceFundingManager(t, alice)\n\n\t// We should receive the rebroadcasted funding txn.\n\tselect {\n\tcase <-alice.publTxChan:\n\tcase <-time.After(time.Second * 5):\n\t\tt.Fatalf(\"alice did not publish funding tx\")\n\t}\n\n\t// Increase the height to 1 minus the maxWaitNumBlocksFundingConf\n\t// height.\n\talice.mockNotifier.epochChan <- &chainntnfs.BlockEpoch{\n\t\tHeight: fundingBroadcastHeight + maxWaitNumBlocksFundingConf - 1,\n\t}\n\n\tbob.mockNotifier.epochChan <- &chainntnfs.BlockEpoch{\n\t\tHeight: fundingBroadcastHeight + maxWaitNumBlocksFundingConf - 1,\n\t}\n\n\t// Assert both and Alice and Bob still have 1 pending channels.\n\tassertNumPendingChannelsRemains(t, alice, 1)\n\n\tassertNumPendingChannelsRemains(t, bob, 1)\n\n\t// Increase both Alice and Bob to maxWaitNumBlocksFundingConf height.\n\talice.mockNotifier.epochChan <- &chainntnfs.BlockEpoch{\n\t\tHeight: fundingBroadcastHeight + maxWaitNumBlocksFundingConf,\n\t}\n\n\tbob.mockNotifier.epochChan <- &chainntnfs.BlockEpoch{\n\t\tHeight: fundingBroadcastHeight + maxWaitNumBlocksFundingConf,\n\t}\n\n\t// Since Alice was the initiator, the channel should not have timed out.\n\tassertNumPendingChannelsRemains(t, alice, 1)\n\n\t// Bob should have sent an Error message to Alice.\n\tassertErrorSent(t, bob.msgChan)\n\n\t// Since Bob was not the initiator, the channel should timeout.\n\tassertNumPendingChannelsBecomes(t, bob, 0)\n}\n\n// TestFundingManagerReceiveFundingLockedTwice checks that the fundingManager\n// continues to operate as expected in case we receive a duplicate fundingLocked\n// message.",
      "length": 2282,
      "tokens": 272,
      "embedding": []
    },
    {
      "slug": "func TestFundingManagerReceiveFundingLockedTwice(t *testing.T) {",
      "content": "func TestFundingManagerReceiveFundingLockedTwice(t *testing.T) {\n\tt.Parallel()\n\n\talice, bob := setupFundingManagers(t)\n\tt.Cleanup(func() {\n\t\ttearDownFundingManagers(t, alice, bob)\n\t})\n\n\t// We will consume the channel updates as we go, so no buffering is\n\t// needed.\n\tupdateChan := make(chan *lnrpc.OpenStatusUpdate)\n\n\t// Run through the process of opening the channel, up until the funding\n\t// transaction is broadcasted.\n\tlocalAmt := btcutil.Amount(500000)\n\tpushAmt := btcutil.Amount(0)\n\tcapacity := localAmt + pushAmt\n\tfundingOutPoint, fundingTx := openChannel(\n\t\tt, alice, bob, localAmt, pushAmt, 1, updateChan, true,\n\t)\n\n\t// Notify that transaction was mined\n\talice.mockNotifier.oneConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\tbob.mockNotifier.oneConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\n\t// The funding transaction was mined, so assert that both funding\n\t// managers now have the state of this channel 'markedOpen' in their\n\t// internal state machine.\n\tassertMarkedOpen(t, alice, bob, fundingOutPoint)\n\n\t// After the funding transaction is mined, Alice will send\n\t// fundingLocked to Bob.\n\tfundingLockedAlice := assertFundingMsgSent(\n\t\tt, alice.msgChan, \"FundingLocked\",\n\t).(*lnwire.FundingLocked)\n\n\t// And similarly Bob will send funding locked to Alice.\n\tfundingLockedBob := assertFundingMsgSent(\n\t\tt, bob.msgChan, \"FundingLocked\",\n\t).(*lnwire.FundingLocked)\n\n\t// Check that the state machine is updated accordingly\n\tassertFundingLockedSent(t, alice, bob, fundingOutPoint)\n\n\t// Send the fundingLocked message twice to Alice, and once to Bob.\n\talice.fundingMgr.ProcessFundingMsg(fundingLockedBob, bob)\n\talice.fundingMgr.ProcessFundingMsg(fundingLockedBob, bob)\n\tbob.fundingMgr.ProcessFundingMsg(fundingLockedAlice, alice)\n\n\t// Check that they notify the breach arbiter and peer about the new\n\t// channel.\n\tassertHandleFundingLocked(t, alice, bob)\n\n\t// Alice should not send the channel state the second time, as the\n\t// second funding locked should just be ignored.\n\tselect {\n\tcase <-alice.newChannels:\n\t\tt.Fatalf(\"alice sent new channel to peer a second time\")\n\tcase <-time.After(time.Millisecond * 300):\n\t\t// Expected\n\t}\n\n\t// Another fundingLocked should also be ignored, since Alice should\n\t// have updated her database at this point.\n\talice.fundingMgr.ProcessFundingMsg(fundingLockedBob, bob)\n\tselect {\n\tcase <-alice.newChannels:\n\t\tt.Fatalf(\"alice sent new channel to peer a second time\")\n\tcase <-time.After(time.Millisecond * 300):\n\t\t// Expected\n\t}\n\n\t// Make sure both fundingManagers send the expected channel\n\t// announcements.\n\tassertChannelAnnouncements(t, alice, bob, capacity, nil, nil, nil, nil)\n\n\t// Check that the state machine is updated accordingly\n\tassertAddedToRouterGraph(t, alice, bob, fundingOutPoint)\n\n\t// The funding transaction is now confirmed, wait for the\n\t// OpenStatusUpdate_ChanOpen update\n\twaitForOpenUpdate(t, updateChan)\n\n\t// Notify that six confirmations has been reached on funding\n\t// transaction.\n\talice.mockNotifier.sixConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\tbob.mockNotifier.sixConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\n\t// Make sure the fundingManagers exchange announcement signatures.\n\tassertAnnouncementSignatures(t, alice, bob)\n\n\t// The internal state-machine should now have deleted the channelStates\n\t// from the database, as the channel is announced.\n\tassertNoChannelState(t, alice, bob, fundingOutPoint)\n\n\t// The forwarding policy for the channel announcement should\n\t// have been deleted from the database, as the channel is announced.\n\tassertNoFwdingPolicy(t, alice, bob, fundingOutPoint)\n}\n\n// TestFundingManagerRestartAfterChanAnn checks that the fundingManager properly\n// handles receiving a fundingLocked after the its own fundingLocked and channel\n// announcement is sent and gets restarted.",
      "length": 3667,
      "tokens": 446,
      "embedding": []
    },
    {
      "slug": "func TestFundingManagerRestartAfterChanAnn(t *testing.T) {",
      "content": "func TestFundingManagerRestartAfterChanAnn(t *testing.T) {\n\tt.Parallel()\n\n\talice, bob := setupFundingManagers(t)\n\tt.Cleanup(func() {\n\t\ttearDownFundingManagers(t, alice, bob)\n\t})\n\n\t// We will consume the channel updates as we go, so no buffering is\n\t// needed.\n\tupdateChan := make(chan *lnrpc.OpenStatusUpdate)\n\n\t// Run through the process of opening the channel, up until the funding\n\t// transaction is broadcasted.\n\tlocalAmt := btcutil.Amount(500000)\n\tpushAmt := btcutil.Amount(0)\n\tcapacity := localAmt + pushAmt\n\tfundingOutPoint, fundingTx := openChannel(\n\t\tt, alice, bob, localAmt, pushAmt, 1, updateChan, true,\n\t)\n\n\t// Notify that transaction was mined\n\talice.mockNotifier.oneConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\tbob.mockNotifier.oneConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\n\t// The funding transaction was mined, so assert that both funding\n\t// managers now have the state of this channel 'markedOpen' in their\n\t// internal state machine.\n\tassertMarkedOpen(t, alice, bob, fundingOutPoint)\n\n\t// After the funding transaction is mined, Alice will send\n\t// fundingLocked to Bob.\n\tfundingLockedAlice := assertFundingMsgSent(\n\t\tt, alice.msgChan, \"FundingLocked\",\n\t).(*lnwire.FundingLocked)\n\n\t// And similarly Bob will send funding locked to Alice.\n\tfundingLockedBob := assertFundingMsgSent(\n\t\tt, bob.msgChan, \"FundingLocked\",\n\t).(*lnwire.FundingLocked)\n\n\t// Check that the state machine is updated accordingly\n\tassertFundingLockedSent(t, alice, bob, fundingOutPoint)\n\n\t// Exchange the fundingLocked messages.\n\talice.fundingMgr.ProcessFundingMsg(fundingLockedBob, bob)\n\tbob.fundingMgr.ProcessFundingMsg(fundingLockedAlice, alice)\n\n\t// Check that they notify the breach arbiter and peer about the new\n\t// channel.\n\tassertHandleFundingLocked(t, alice, bob)\n\n\t// Make sure both fundingManagers send the expected channel\n\t// announcements.\n\tassertChannelAnnouncements(t, alice, bob, capacity, nil, nil, nil, nil)\n\n\t// Check that the state machine is updated accordingly\n\tassertAddedToRouterGraph(t, alice, bob, fundingOutPoint)\n\n\t// The funding transaction is now confirmed, wait for the\n\t// OpenStatusUpdate_ChanOpen update\n\twaitForOpenUpdate(t, updateChan)\n\n\t// At this point we restart Alice's fundingManager, before she receives\n\t// the fundingLocked message. After restart, she will receive it, and\n\t// we expect her to be able to handle it correctly.\n\trecreateAliceFundingManager(t, alice)\n\n\t// Notify that six confirmations has been reached on funding\n\t// transaction.\n\talice.mockNotifier.sixConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\tbob.mockNotifier.sixConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\n\t// Make sure both fundingManagers send the expected channel\n\t// announcements.\n\tassertAnnouncementSignatures(t, alice, bob)\n\n\t// The internal state-machine should now have deleted the channelStates\n\t// from the database, as the channel is announced.\n\tassertNoChannelState(t, alice, bob, fundingOutPoint)\n\n\t// The forwarding policy for the channel announcement should\n\t// have been deleted from the database, as the channel is announced.\n\tassertNoFwdingPolicy(t, alice, bob, fundingOutPoint)\n}\n\n// TestFundingManagerRestartAfterReceivingFundingLocked checks that the\n// fundingManager continues to operate as expected after it has received\n// fundingLocked and then gets restarted.",
      "length": 3218,
      "tokens": 390,
      "embedding": []
    },
    {
      "slug": "func TestFundingManagerRestartAfterReceivingFundingLocked(t *testing.T) {",
      "content": "func TestFundingManagerRestartAfterReceivingFundingLocked(t *testing.T) {\n\tt.Parallel()\n\n\talice, bob := setupFundingManagers(t)\n\tt.Cleanup(func() {\n\t\ttearDownFundingManagers(t, alice, bob)\n\t})\n\n\t// We will consume the channel updates as we go, so no buffering is\n\t// needed.\n\tupdateChan := make(chan *lnrpc.OpenStatusUpdate)\n\n\t// Run through the process of opening the channel, up until the funding\n\t// transaction is broadcasted.\n\tlocalAmt := btcutil.Amount(500000)\n\tpushAmt := btcutil.Amount(0)\n\tcapacity := localAmt + pushAmt\n\tfundingOutPoint, fundingTx := openChannel(\n\t\tt, alice, bob, localAmt, pushAmt, 1, updateChan, true,\n\t)\n\n\t// Notify that transaction was mined\n\talice.mockNotifier.oneConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\tbob.mockNotifier.oneConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\n\t// The funding transaction was mined, so assert that both funding\n\t// managers now have the state of this channel 'markedOpen' in their\n\t// internal state machine.\n\tassertMarkedOpen(t, alice, bob, fundingOutPoint)\n\n\t// After the funding transaction is mined, Alice will send\n\t// fundingLocked to Bob.\n\tfundingLockedAlice := assertFundingMsgSent(\n\t\tt, alice.msgChan, \"FundingLocked\",\n\t).(*lnwire.FundingLocked)\n\n\t// And similarly Bob will send funding locked to Alice.\n\tfundingLockedBob := assertFundingMsgSent(\n\t\tt, bob.msgChan, \"FundingLocked\",\n\t).(*lnwire.FundingLocked)\n\n\t// Check that the state machine is updated accordingly\n\tassertFundingLockedSent(t, alice, bob, fundingOutPoint)\n\n\t// Let Alice immediately get the fundingLocked message.\n\talice.fundingMgr.ProcessFundingMsg(fundingLockedBob, bob)\n\n\t// Also let Bob get the fundingLocked message.\n\tbob.fundingMgr.ProcessFundingMsg(fundingLockedAlice, alice)\n\n\t// Check that they notify the breach arbiter and peer about the new\n\t// channel.\n\tassertHandleFundingLocked(t, alice, bob)\n\n\t// At this point we restart Alice's fundingManager.\n\trecreateAliceFundingManager(t, alice)\n\n\t// Make sure both fundingManagers send the expected channel\n\t// announcements.\n\tassertChannelAnnouncements(t, alice, bob, capacity, nil, nil, nil, nil)\n\n\t// Check that the state machine is updated accordingly\n\tassertAddedToRouterGraph(t, alice, bob, fundingOutPoint)\n\n\t// Notify that six confirmations has been reached on funding\n\t// transaction.\n\talice.mockNotifier.sixConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\tbob.mockNotifier.sixConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\n\t// Make sure both fundingManagers send the expected channel\n\t// announcements.\n\tassertAnnouncementSignatures(t, alice, bob)\n\n\t// The internal state-machine should now have deleted the channelStates\n\t// from the database, as the channel is announced.\n\tassertNoChannelState(t, alice, bob, fundingOutPoint)\n\n\t// The forwarding policy for the channel announcement should\n\t// have been deleted from the database, as the channel is announced.\n\tassertNoFwdingPolicy(t, alice, bob, fundingOutPoint)\n}\n\n// TestFundingManagerPrivateChannel tests that if we open a private channel\n// (a channel not supposed to be announced to the rest of the network),\n// the announcementSignatures nor the nodeAnnouncement messages are sent.",
      "length": 3047,
      "tokens": 372,
      "embedding": []
    },
    {
      "slug": "func TestFundingManagerPrivateChannel(t *testing.T) {",
      "content": "func TestFundingManagerPrivateChannel(t *testing.T) {\n\tt.Parallel()\n\n\talice, bob := setupFundingManagers(t)\n\tt.Cleanup(func() {\n\t\ttearDownFundingManagers(t, alice, bob)\n\t})\n\n\t// We will consume the channel updates as we go, so no buffering is\n\t// needed.\n\tupdateChan := make(chan *lnrpc.OpenStatusUpdate)\n\n\t// Run through the process of opening the channel, up until the funding\n\t// transaction is broadcasted.\n\tlocalAmt := btcutil.Amount(500000)\n\tpushAmt := btcutil.Amount(0)\n\tcapacity := localAmt + pushAmt\n\tfundingOutPoint, fundingTx := openChannel(\n\t\tt, alice, bob, localAmt, pushAmt, 1, updateChan, false,\n\t)\n\n\t// Notify that transaction was mined\n\talice.mockNotifier.oneConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\tbob.mockNotifier.oneConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\n\t// The funding transaction was mined, so assert that both funding\n\t// managers now have the state of this channel 'markedOpen' in their\n\t// internal state machine.\n\tassertMarkedOpen(t, alice, bob, fundingOutPoint)\n\n\t// After the funding transaction is mined, Alice will send\n\t// fundingLocked to Bob.\n\tfundingLockedAlice := assertFundingMsgSent(\n\t\tt, alice.msgChan, \"FundingLocked\",\n\t).(*lnwire.FundingLocked)\n\n\t// And similarly Bob will send funding locked to Alice.\n\tfundingLockedBob := assertFundingMsgSent(\n\t\tt, bob.msgChan, \"FundingLocked\",\n\t).(*lnwire.FundingLocked)\n\n\t// Check that the state machine is updated accordingly\n\tassertFundingLockedSent(t, alice, bob, fundingOutPoint)\n\n\t// Exchange the fundingLocked messages.\n\talice.fundingMgr.ProcessFundingMsg(fundingLockedBob, bob)\n\tbob.fundingMgr.ProcessFundingMsg(fundingLockedAlice, alice)\n\n\t// Check that they notify the breach arbiter and peer about the new\n\t// channel.\n\tassertHandleFundingLocked(t, alice, bob)\n\n\t// Make sure both fundingManagers send the expected channel\n\t// announcements.\n\tassertChannelAnnouncements(t, alice, bob, capacity, nil, nil, nil, nil)\n\n\t// The funding transaction is now confirmed, wait for the\n\t// OpenStatusUpdate_ChanOpen update\n\twaitForOpenUpdate(t, updateChan)\n\n\t// Notify that six confirmations has been reached on funding\n\t// transaction.\n\talice.mockNotifier.sixConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\tbob.mockNotifier.sixConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\n\t// Since this is a private channel, we shouldn't receive the\n\t// announcement signatures.\n\tselect {\n\tcase ann := <-alice.announceChan:\n\t\tt.Fatalf(\"unexpectedly got channel announcement message: %v\",\n\t\t\tann)\n\tcase <-time.After(300 * time.Millisecond):\n\t\t// Expected\n\t}\n\n\tselect {\n\tcase ann := <-bob.announceChan:\n\t\tt.Fatalf(\"unexpectedly got channel announcement message: %v\",\n\t\t\tann)\n\tcase <-time.After(300 * time.Millisecond):\n\t\t// Expected\n\t}\n\n\t// We should however receive each side's node announcement.\n\tselect {\n\tcase msg := <-alice.msgChan:\n\t\tif _, ok := msg.(*lnwire.NodeAnnouncement); !ok {\n\t\t\tt.Fatalf(\"expected to receive node announcement\")\n\t\t}\n\tcase <-time.After(time.Second):\n\t\tt.Fatalf(\"expected to receive node announcement\")\n\t}\n\n\tselect {\n\tcase msg := <-bob.msgChan:\n\t\tif _, ok := msg.(*lnwire.NodeAnnouncement); !ok {\n\t\t\tt.Fatalf(\"expected to receive node announcement\")\n\t\t}\n\tcase <-time.After(time.Second):\n\t\tt.Fatalf(\"expected to receive node announcement\")\n\t}\n\n\t// The internal state-machine should now have deleted the channelStates\n\t// from the database, as the channel is announced.\n\tassertNoChannelState(t, alice, bob, fundingOutPoint)\n\n\t// The forwarding policy for the channel announcement should\n\t// have been deleted from the database.\n\tassertNoFwdingPolicy(t, alice, bob, fundingOutPoint)\n}\n\n// TestFundingManagerPrivateRestart tests that the privacy guarantees granted\n// by the private channel persist even on restart. This means that the\n// announcement signatures nor the node announcement messages are sent upon\n// restart.",
      "length": 3718,
      "tokens": 452,
      "embedding": []
    },
    {
      "slug": "func TestFundingManagerPrivateRestart(t *testing.T) {",
      "content": "func TestFundingManagerPrivateRestart(t *testing.T) {\n\tt.Parallel()\n\n\talice, bob := setupFundingManagers(t)\n\tt.Cleanup(func() {\n\t\ttearDownFundingManagers(t, alice, bob)\n\t})\n\n\t// We will consume the channel updates as we go, so no buffering is\n\t// needed.\n\tupdateChan := make(chan *lnrpc.OpenStatusUpdate)\n\n\t// Run through the process of opening the channel, up until the funding\n\t// transaction is broadcasted.\n\tlocalAmt := btcutil.Amount(500000)\n\tpushAmt := btcutil.Amount(0)\n\tcapacity := localAmt + pushAmt\n\tfundingOutPoint, fundingTx := openChannel(\n\t\tt, alice, bob, localAmt, pushAmt, 1, updateChan, false,\n\t)\n\n\t// Notify that transaction was mined\n\talice.mockNotifier.oneConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\tbob.mockNotifier.oneConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\n\t// The funding transaction was mined, so assert that both funding\n\t// managers now have the state of this channel 'markedOpen' in their\n\t// internal state machine.\n\tassertMarkedOpen(t, alice, bob, fundingOutPoint)\n\n\t// After the funding transaction is mined, Alice will send\n\t// fundingLocked to Bob.\n\tfundingLockedAlice := assertFundingMsgSent(\n\t\tt, alice.msgChan, \"FundingLocked\",\n\t).(*lnwire.FundingLocked)\n\n\t// And similarly Bob will send funding locked to Alice.\n\tfundingLockedBob := assertFundingMsgSent(\n\t\tt, bob.msgChan, \"FundingLocked\",\n\t).(*lnwire.FundingLocked)\n\n\t// Check that the state machine is updated accordingly\n\tassertFundingLockedSent(t, alice, bob, fundingOutPoint)\n\n\t// Exchange the fundingLocked messages.\n\talice.fundingMgr.ProcessFundingMsg(fundingLockedBob, bob)\n\tbob.fundingMgr.ProcessFundingMsg(fundingLockedAlice, alice)\n\n\t// Check that they notify the breach arbiter and peer about the new\n\t// channel.\n\tassertHandleFundingLocked(t, alice, bob)\n\n\t// Make sure both fundingManagers send the expected channel\n\t// announcements.\n\tassertChannelAnnouncements(t, alice, bob, capacity, nil, nil, nil, nil)\n\n\t// Note: We don't check for the addedToRouterGraph state because in\n\t// the private channel mode, the state is quickly changed from\n\t// addedToRouterGraph to deleted from the database since the public\n\t// announcement phase is skipped.\n\n\t// The funding transaction is now confirmed, wait for the\n\t// OpenStatusUpdate_ChanOpen update\n\twaitForOpenUpdate(t, updateChan)\n\n\t// Notify that six confirmations has been reached on funding\n\t// transaction.\n\talice.mockNotifier.sixConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\tbob.mockNotifier.sixConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\n\t// Since this is a private channel, we shouldn't receive the public\n\t// channel announcement messages.\n\tselect {\n\tcase ann := <-alice.announceChan:\n\t\tt.Fatalf(\"unexpectedly got channel announcement message: %v\",\n\t\t\tann)\n\tcase <-time.After(300 * time.Millisecond):\n\t}\n\n\tselect {\n\tcase ann := <-bob.announceChan:\n\t\tt.Fatalf(\"unexpectedly got channel announcement message: %v\",\n\t\t\tann)\n\tcase <-time.After(300 * time.Millisecond):\n\t}\n\n\t// We should however receive each side's node announcement.\n\tselect {\n\tcase msg := <-alice.msgChan:\n\t\tif _, ok := msg.(*lnwire.NodeAnnouncement); !ok {\n\t\t\tt.Fatalf(\"expected to receive node announcement\")\n\t\t}\n\tcase <-time.After(time.Second):\n\t\tt.Fatalf(\"expected to receive node announcement\")\n\t}\n\n\tselect {\n\tcase msg := <-bob.msgChan:\n\t\tif _, ok := msg.(*lnwire.NodeAnnouncement); !ok {\n\t\t\tt.Fatalf(\"expected to receive node announcement\")\n\t\t}\n\tcase <-time.After(time.Second):\n\t\tt.Fatalf(\"expected to receive node announcement\")\n\t}\n\n\t// Restart Alice's fundingManager so we can prove that the public\n\t// channel announcements are not sent upon restart and that the private\n\t// setting persists upon restart.\n\trecreateAliceFundingManager(t, alice)\n\n\tselect {\n\tcase ann := <-alice.announceChan:\n\t\tt.Fatalf(\"unexpectedly got channel announcement message: %v\",\n\t\t\tann)\n\tcase <-time.After(300 * time.Millisecond):\n\t\t// Expected\n\t}\n\n\tselect {\n\tcase ann := <-bob.announceChan:\n\t\tt.Fatalf(\"unexpectedly got channel announcement message: %v\",\n\t\t\tann)\n\tcase <-time.After(300 * time.Millisecond):\n\t\t// Expected\n\t}\n\n\t// The internal state-machine should now have deleted the channelStates\n\t// from the database, as the channel is announced.\n\tassertNoChannelState(t, alice, bob, fundingOutPoint)\n\n\t// The forwarding policy for the channel announcement should\n\t// have been deleted from the database.\n\tassertNoFwdingPolicy(t, alice, bob, fundingOutPoint)\n}\n\n// TestFundingManagerCustomChannelParameters checks that custom requirements we\n// specify during the channel funding flow is preserved correctly on both sides.",
      "length": 4414,
      "tokens": 543,
      "embedding": []
    },
    {
      "slug": "func TestFundingManagerCustomChannelParameters(t *testing.T) {",
      "content": "func TestFundingManagerCustomChannelParameters(t *testing.T) {\n\tt.Parallel()\n\n\talice, bob := setupFundingManagers(t)\n\tt.Cleanup(func() {\n\t\ttearDownFundingManagers(t, alice, bob)\n\t})\n\n\t// This is the custom parameters we'll use.\n\tconst csvDelay = 67\n\tconst minHtlcIn = 1234\n\tconst maxValueInFlight = 50000\n\tconst fundingAmt = 5000000\n\tconst chanReserve = 100000\n\n\t// Use custom channel fees.\n\t// These will show up in the channel reservation context\n\tvar baseFee uint64\n\tvar feeRate uint64\n\tbaseFee = 42\n\tfeeRate = 1337\n\n\t// We will consume the channel updates as we go, so no buffering is\n\t// needed.\n\tupdateChan := make(chan *lnrpc.OpenStatusUpdate)\n\n\tlocalAmt := btcutil.Amount(5000000)\n\tpushAmt := btcutil.Amount(0)\n\tcapacity := localAmt + pushAmt\n\n\t// Create a funding request with the custom parameters and start the\n\t// workflow.\n\terrChan := make(chan error, 1)\n\tinitReq := &InitFundingMsg{\n\t\tPeer:              bob,\n\t\tTargetPubkey:      bob.privKey.PubKey(),\n\t\tChainHash:         *fundingNetParams.GenesisHash,\n\t\tLocalFundingAmt:   localAmt,\n\t\tPushAmt:           lnwire.NewMSatFromSatoshis(pushAmt),\n\t\tPrivate:           false,\n\t\tMaxValueInFlight:  maxValueInFlight,\n\t\tMinHtlcIn:         minHtlcIn,\n\t\tRemoteCsvDelay:    csvDelay,\n\t\tRemoteChanReserve: chanReserve,\n\t\tUpdates:           updateChan,\n\t\tErr:               errChan,\n\t\tBaseFee:           &baseFee,\n\t\tFeeRate:           &feeRate,\n\t}\n\n\talice.fundingMgr.InitFundingWorkflow(initReq)\n\n\t// Alice should have sent the OpenChannel message to Bob.\n\tvar aliceMsg lnwire.Message\n\tselect {\n\tcase aliceMsg = <-alice.msgChan:\n\tcase err := <-initReq.Err:\n\t\tt.Fatalf(\"error init funding workflow: %v\", err)\n\tcase <-time.After(time.Second * 5):\n\t\tt.Fatalf(\"alice did not send OpenChannel message\")\n\t}\n\n\topenChannelReq, ok := aliceMsg.(*lnwire.OpenChannel)\n\tif !ok {\n\t\terrorMsg, gotError := aliceMsg.(*lnwire.Error)\n\t\tif gotError {\n\t\t\tt.Fatalf(\"expected OpenChannel to be sent \"+\n\t\t\t\t\"from bob, instead got error: %v\",\n\t\t\t\terrorMsg.Error())\n\t\t}\n\t\tt.Fatalf(\"expected OpenChannel to be sent from \"+\n\t\t\t\"alice, instead got %T\", aliceMsg)\n\t}\n\n\t// Check that the custom CSV delay is sent as part of OpenChannel.\n\tif openChannelReq.CsvDelay != csvDelay {\n\t\tt.Fatalf(\"expected OpenChannel to have CSV delay %v, got %v\",\n\t\t\tcsvDelay, openChannelReq.CsvDelay)\n\t}\n\n\t// Check that the custom minHTLC value is sent.\n\tif openChannelReq.HtlcMinimum != minHtlcIn {\n\t\tt.Fatalf(\"expected OpenChannel to have minHtlc %v, got %v\",\n\t\t\tminHtlcIn, openChannelReq.HtlcMinimum)\n\t}\n\n\t// Check that the max value in flight is sent as part of OpenChannel.\n\tif openChannelReq.MaxValueInFlight != maxValueInFlight {\n\t\tt.Fatalf(\"expected OpenChannel to have MaxValueInFlight %v, \"+\n\t\t\t\"got %v\", maxValueInFlight,\n\t\t\topenChannelReq.MaxValueInFlight)\n\t}\n\n\t// Check that the custom remoteChanReserve value is sent.\n\tif openChannelReq.ChannelReserve != chanReserve {\n\t\tt.Fatalf(\"expected OpenChannel to have chanReserve %v, got %v\",\n\t\t\tchanReserve, openChannelReq.ChannelReserve)\n\t}\n\n\tchanID := openChannelReq.PendingChannelID\n\n\t// Let Bob handle the init message.\n\tbob.fundingMgr.ProcessFundingMsg(openChannelReq, alice)\n\n\t// Bob should answer with an AcceptChannel message.\n\tacceptChannelResponse := assertFundingMsgSent(\n\t\tt, bob.msgChan, \"AcceptChannel\",\n\t).(*lnwire.AcceptChannel)\n\n\t// Bob should require the default delay of 4.\n\tif acceptChannelResponse.CsvDelay != 4 {\n\t\tt.Fatalf(\"expected AcceptChannel to have CSV delay %v, got %v\",\n\t\t\t4, acceptChannelResponse.CsvDelay)\n\t}\n\n\t// And the default MinHTLC value of 5.\n\tif acceptChannelResponse.HtlcMinimum != 5 {\n\t\tt.Fatalf(\"expected AcceptChannel to have minHtlc %v, got %v\",\n\t\t\t5, acceptChannelResponse.HtlcMinimum)\n\t}\n\n\treserve := lnwire.NewMSatFromSatoshis(fundingAmt / 100)\n\tmaxValueAcceptChannel := lnwire.NewMSatFromSatoshis(fundingAmt) - reserve\n\n\tif acceptChannelResponse.MaxValueInFlight != maxValueAcceptChannel {\n\t\tt.Fatalf(\"expected AcceptChannel to have MaxValueInFlight %v, \"+\n\t\t\t\"got %v\", maxValueAcceptChannel,\n\t\t\tacceptChannelResponse.MaxValueInFlight)\n\t}\n\n\t// Forward the response to Alice.\n\talice.fundingMgr.ProcessFundingMsg(acceptChannelResponse, bob)\n\n\t// Alice responds with a FundingCreated message.\n\tfundingCreated := assertFundingMsgSent(\n\t\tt, alice.msgChan, \"FundingCreated\",\n\t).(*lnwire.FundingCreated)\n\n\t// Helper method for checking the CSV delay stored for a reservation.\n\tassertDelay := func(resCtx *reservationWithCtx,\n\t\tourDelay, theirDelay uint16) error {\n\n\t\tourCsvDelay := resCtx.reservation.OurContribution().CsvDelay\n\t\tif ourCsvDelay != ourDelay {\n\t\t\treturn fmt.Errorf(\"expected our CSV delay to be %v, \"+\n\t\t\t\t\"was %v\", ourDelay, ourCsvDelay)\n\t\t}\n\n\t\ttheirCsvDelay := resCtx.reservation.TheirContribution().CsvDelay\n\t\tif theirCsvDelay != theirDelay {\n\t\t\treturn fmt.Errorf(\"expected their CSV delay to be %v, \"+\n\t\t\t\t\"was %v\", theirDelay, theirCsvDelay)\n\t\t}\n\t\treturn nil\n\t}\n\n\t// Helper method for checking the MinHtlc value stored for a\n\t// reservation.\n\tassertMinHtlc := func(resCtx *reservationWithCtx,\n\t\texpOurMinHtlc, expTheirMinHtlc lnwire.MilliSatoshi) error {\n\n\t\tourMinHtlc := resCtx.reservation.OurContribution().MinHTLC\n\t\tif ourMinHtlc != expOurMinHtlc {\n\t\t\treturn fmt.Errorf(\"expected our minHtlc to be %v, \"+\n\t\t\t\t\"was %v\", expOurMinHtlc, ourMinHtlc)\n\t\t}\n\n\t\ttheirMinHtlc := resCtx.reservation.TheirContribution().MinHTLC\n\t\tif theirMinHtlc != expTheirMinHtlc {\n\t\t\treturn fmt.Errorf(\"expected their minHtlc to be %v, \"+\n\t\t\t\t\"was %v\", expTheirMinHtlc, theirMinHtlc)\n\t\t}\n\t\treturn nil\n\t}\n\n\t// Helper method for checking the MaxValueInFlight stored for a\n\t// reservation.\n\tassertMaxHtlc := func(resCtx *reservationWithCtx,\n\t\texpOurMaxValue, expTheirMaxValue lnwire.MilliSatoshi) error {\n\n\t\tourMaxValue :=\n\t\t\tresCtx.reservation.OurContribution().MaxPendingAmount\n\t\tif ourMaxValue != expOurMaxValue {\n\t\t\treturn fmt.Errorf(\"expected our maxValue to be %v, \"+\n\t\t\t\t\"was %v\", expOurMaxValue, ourMaxValue)\n\t\t}\n\n\t\ttheirMaxValue :=\n\t\t\tresCtx.reservation.TheirContribution().MaxPendingAmount\n\t\tif theirMaxValue != expTheirMaxValue {\n\t\t\treturn fmt.Errorf(\"expected their MaxPendingAmount to \"+\n\t\t\t\t\"be %v, was %v\", expTheirMaxValue,\n\t\t\t\ttheirMaxValue)\n\t\t}\n\t\treturn nil\n\t}\n\n\t// Helper method for checking baseFee and feeRate stored for a\n\t// reservation.\n\tassertFees := func(forwardingPolicy *htlcswitch.ForwardingPolicy,\n\t\tbaseFee, feeRate lnwire.MilliSatoshi) error {\n\n\t\tif forwardingPolicy.BaseFee != baseFee {\n\t\t\treturn fmt.Errorf(\"expected baseFee to be %v, \"+\n\t\t\t\t\"was %v\", baseFee, forwardingPolicy.BaseFee)\n\t\t}\n\n\t\tif forwardingPolicy.FeeRate != feeRate {\n\t\t\treturn fmt.Errorf(\"expected feeRate to be %v, \"+\n\t\t\t\t\"was %v\", feeRate, forwardingPolicy.FeeRate)\n\t\t}\n\t\treturn nil\n\t}\n\n\t// Check that the custom channel parameters were properly set in the\n\t// channel reservation.\n\tresCtx, err := alice.fundingMgr.getReservationCtx(bobPubKey, chanID)\n\trequire.NoError(t, err, \"unable to find ctx\")\n\n\t// Alice's CSV delay should be 4 since Bob sent the default value, and\n\t// Bob's should be 67 since Alice sent the custom value.\n\tif err := assertDelay(resCtx, 4, csvDelay); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// The minimum HTLC value Alice can offer should be 5, and the minimum\n\t// Bob can offer should be 1234.\n\tif err := assertMinHtlc(resCtx, 5, minHtlcIn); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// The max value in flight Alice can have should be\n\t// maxValueAcceptChannel, which is the default value and the maximum Bob\n\t// can offer should be maxValueInFlight.\n\tif err := assertMaxHtlc(resCtx,\n\t\tmaxValueAcceptChannel, maxValueInFlight); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// The optional channel fees that will be applied in the channel\n\t// announcement phase. Both base fee and fee rate were provided\n\t// in the channel open request.\n\tif err := assertFees(&resCtx.forwardingPolicy, 42, 1337); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Also make sure the parameters are properly set on Bob's end.\n\tresCtx, err = bob.fundingMgr.getReservationCtx(alicePubKey, chanID)\n\trequire.NoError(t, err, \"unable to find ctx\")\n\n\tif err := assertDelay(resCtx, csvDelay, 4); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := assertMinHtlc(resCtx, minHtlcIn, 5); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := assertMaxHtlc(resCtx,\n\t\tmaxValueInFlight, maxValueAcceptChannel); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := assertFees(&resCtx.forwardingPolicy, 100, 1000); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Give the message to Bob.\n\tbob.fundingMgr.ProcessFundingMsg(fundingCreated, alice)\n\n\t// Finally, Bob should send the FundingSigned message.\n\tfundingSigned := assertFundingMsgSent(\n\t\tt, bob.msgChan, \"FundingSigned\",\n\t).(*lnwire.FundingSigned)\n\n\t// Forward the signature to Alice.\n\talice.fundingMgr.ProcessFundingMsg(fundingSigned, bob)\n\n\t// After Alice processes the singleFundingSignComplete message, she will\n\t// broadcast the funding transaction to the network. We expect to get a\n\t// channel update saying the channel is pending.\n\tvar pendingUpdate *lnrpc.OpenStatusUpdate\n\tselect {\n\tcase pendingUpdate = <-updateChan:\n\tcase <-time.After(time.Second * 5):\n\t\tt.Fatalf(\"alice did not send OpenStatusUpdate_ChanPending\")\n\t}\n\n\t_, ok = pendingUpdate.Update.(*lnrpc.OpenStatusUpdate_ChanPending)\n\tif !ok {\n\t\tt.Fatal(\"OpenStatusUpdate was not OpenStatusUpdate_ChanPending\")\n\t}\n\n\t// After the funding is sigend and before the channel announcement\n\t// we expect Alice and Bob to store their respective fees in the\n\t// database.\n\tforwardingPolicy, err := alice.fundingMgr.getInitialFwdingPolicy(\n\t\tfundingSigned.ChanID,\n\t)\n\trequire.NoError(t, err)\n\trequire.NoError(t, assertFees(forwardingPolicy, 42, 1337))\n\n\tforwardingPolicy, err = bob.fundingMgr.getInitialFwdingPolicy(\n\t\tfundingSigned.ChanID,\n\t)\n\trequire.NoError(t, err)\n\trequire.NoError(t, assertFees(forwardingPolicy, 100, 1000))\n\n\t// Wait for Alice to published the funding tx to the network.\n\tvar fundingTx *wire.MsgTx\n\tselect {\n\tcase fundingTx = <-alice.publTxChan:\n\tcase <-time.After(time.Second * 5):\n\t\tt.Fatalf(\"alice did not publish funding tx\")\n\t}\n\n\t// Notify that transaction was mined.\n\talice.mockNotifier.oneConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\tbob.mockNotifier.oneConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\n\t// After the funding transaction is mined, Alice will send\n\t// fundingLocked to Bob.\n\tfundingLockedAlice := assertFundingMsgSent(\n\t\tt, alice.msgChan, \"FundingLocked\",\n\t).(*lnwire.FundingLocked)\n\n\t// And similarly Bob will send funding locked to Alice.\n\tfundingLockedBob := assertFundingMsgSent(\n\t\tt, bob.msgChan, \"FundingLocked\",\n\t).(*lnwire.FundingLocked)\n\n\t// Exchange the fundingLocked messages.\n\talice.fundingMgr.ProcessFundingMsg(fundingLockedBob, bob)\n\tbob.fundingMgr.ProcessFundingMsg(fundingLockedAlice, alice)\n\n\t// Check that they notify the breach arbiter and peer about the new\n\t// channel.\n\tassertHandleFundingLocked(t, alice, bob)\n\n\t// Make sure both fundingManagers send the expected channel\n\t// announcements.\n\t// Alice should advertise the default MinHTLC value of\n\t// 5, while bob should advertise the value minHtlc, since Alice\n\t// required him to use it.\n\tminHtlcArr := []lnwire.MilliSatoshi{5, minHtlcIn}\n\n\t// For maxHltc Alice should advertise the default MaxHtlc value of\n\t// maxValueAcceptChannel, while bob should advertise the value\n\t// maxValueInFlight since Alice required him to use it.\n\tmaxHtlcArr := []lnwire.MilliSatoshi{\n\t\tmaxValueAcceptChannel, maxValueInFlight,\n\t}\n\n\t// Alice should have custom fees set whereas Bob should see his\n\t// configured default fees announced.\n\tdefaultBaseFee := bob.fundingMgr.cfg.DefaultRoutingPolicy.BaseFee\n\tdefaultFeerate := bob.fundingMgr.cfg.DefaultRoutingPolicy.FeeRate\n\tbaseFees := []lnwire.MilliSatoshi{\n\t\tlnwire.MilliSatoshi(baseFee), defaultBaseFee,\n\t}\n\tfeeRates := []lnwire.MilliSatoshi{\n\t\tlnwire.MilliSatoshi(feeRate), defaultFeerate,\n\t}\n\n\tassertChannelAnnouncements(\n\t\tt, alice, bob, capacity, minHtlcArr, maxHtlcArr, baseFees,\n\t\tfeeRates,\n\t)\n\n\t// The funding transaction is now confirmed, wait for the\n\t// OpenStatusUpdate_ChanOpen update\n\twaitForOpenUpdate(t, updateChan)\n\n\t// Send along the 6-confirmation channel so that announcement sigs can\n\t// be exchanged.\n\talice.mockNotifier.sixConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\tbob.mockNotifier.sixConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\n\tassertAnnouncementSignatures(t, alice, bob)\n\n\t// After the announcement we expect Alice and Bob to have cleared\n\t// the fees for the channel from the database.\n\t_, err = alice.fundingMgr.getInitialFwdingPolicy(fundingSigned.ChanID)\n\tif err != channeldb.ErrChannelNotFound {\n\t\terr = fmt.Errorf(\"channel fees were expected to be deleted\" +\n\t\t\t\" but were not\")\n\t\tt.Fatal(err)\n\t}\n\t_, err = bob.fundingMgr.getInitialFwdingPolicy(fundingSigned.ChanID)\n\tif err != channeldb.ErrChannelNotFound {\n\t\terr = fmt.Errorf(\"channel fees were expected to be deleted\" +\n\t\t\t\" but were not\")\n\t\tt.Fatal(err)\n\t}\n}\n\n// TestFundingManagerInvalidChanReserve ensures proper validation is done on\n// remoteChanReserve parameter sent to open channel.",
      "length": 12551,
      "tokens": 1483,
      "embedding": []
    },
    {
      "slug": "func TestFundingManagerInvalidChanReserve(t *testing.T) {",
      "content": "func TestFundingManagerInvalidChanReserve(t *testing.T) {\n\tt.Parallel()\n\n\tvar (\n\t\tfundingAmt  = btcutil.Amount(500000)\n\t\tpushAmt     = lnwire.NewMSatFromSatoshis(10)\n\t\tgenesisHash = *fundingNetParams.GenesisHash\n\t)\n\n\ttests := []struct {\n\t\tname          string\n\t\tchanReserve   btcutil.Amount\n\t\texpectErr     bool\n\t\terrorContains string\n\t}{\n\t\t{\n\t\t\tname:        \"Use default chan reserve\",\n\t\t\tchanReserve: 0,\n\t\t},\n\t\t{\n\t\t\tname:        \"Above dust but below 1% of the capacity\",\n\t\t\tchanReserve: 400,\n\t\t},\n\t\t{\n\t\t\tname:        \"Channel reserve below dust\",\n\t\t\tchanReserve: 300,\n\t\t\texpectErr:   true,\n\t\t\terrorContains: \"channel reserve of 300 sat is too \" +\n\t\t\t\t\"small\",\n\t\t},\n\t\t{\n\t\t\tname: \"Channel reserve more than 20% of the \" +\n\t\t\t\t\"channel capacity\",\n\t\t\tchanReserve:   fundingAmt,\n\t\t\texpectErr:     true,\n\t\t\terrorContains: \"channel reserve is too large\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\talice, bob := setupFundingManagers(t)\n\t\t\tdefer tearDownFundingManagers(t, alice, bob)\n\n\t\t\t// Create a funding request and start the workflow.\n\t\t\tupdateChan := make(chan *lnrpc.OpenStatusUpdate)\n\t\t\terrChan := make(chan error, 1)\n\t\t\tinitReq := &InitFundingMsg{\n\t\t\t\tPeer:              bob,\n\t\t\t\tTargetPubkey:      bob.privKey.PubKey(),\n\t\t\t\tChainHash:         genesisHash,\n\t\t\t\tLocalFundingAmt:   fundingAmt,\n\t\t\t\tPushAmt:           pushAmt,\n\t\t\t\tUpdates:           updateChan,\n\t\t\t\tRemoteChanReserve: test.chanReserve,\n\t\t\t\tErr:               errChan,\n\t\t\t}\n\n\t\t\talice.fundingMgr.InitFundingWorkflow(initReq)\n\n\t\t\tvar err error\n\t\t\tselect {\n\t\t\tcase <-alice.msgChan:\n\t\t\tcase err = <-initReq.Err:\n\t\t\tcase <-time.After(time.Second * 5):\n\t\t\t\tt.Fatalf(\"no message or error received\")\n\t\t\t}\n\n\t\t\tif !test.expectErr {\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\trequire.ErrorContains(t, err, test.errorContains)\n\t\t})\n\t}\n}\n\n// TestFundingManagerMaxPendingChannels checks that trying to open another\n// channel with the same peer when MaxPending channels are pending fails.",
      "length": 1879,
      "tokens": 211,
      "embedding": []
    },
    {
      "slug": "func TestFundingManagerMaxPendingChannels(t *testing.T) {",
      "content": "func TestFundingManagerMaxPendingChannels(t *testing.T) {\n\tt.Parallel()\n\n\talice, bob := setupFundingManagers(\n\t\tt, func(cfg *Config) {\n\t\t\tcfg.MaxPendingChannels = maxPending\n\t\t},\n\t)\n\tt.Cleanup(func() {\n\t\ttearDownFundingManagers(t, alice, bob)\n\t})\n\n\t// Create InitFundingMsg structs for maxPending+1 channels.\n\tvar initReqs []*InitFundingMsg\n\tfor i := 0; i < maxPending+1; i++ {\n\t\tupdateChan := make(chan *lnrpc.OpenStatusUpdate)\n\t\terrChan := make(chan error, 1)\n\t\tinitReq := &InitFundingMsg{\n\t\t\tPeer:            bob,\n\t\t\tTargetPubkey:    bob.privKey.PubKey(),\n\t\t\tChainHash:       *fundingNetParams.GenesisHash,\n\t\t\tLocalFundingAmt: 5000000,\n\t\t\tPushAmt:         lnwire.NewMSatFromSatoshis(0),\n\t\t\tPrivate:         false,\n\t\t\tUpdates:         updateChan,\n\t\t\tErr:             errChan,\n\t\t}\n\t\tinitReqs = append(initReqs, initReq)\n\t}\n\n\t// Kick of maxPending+1 funding workflows.\n\tvar accepts []*lnwire.AcceptChannel\n\tvar lastOpen *lnwire.OpenChannel\n\tfor i, initReq := range initReqs {\n\t\talice.fundingMgr.InitFundingWorkflow(initReq)\n\n\t\t// Alice should have sent the OpenChannel message to Bob.\n\t\tvar aliceMsg lnwire.Message\n\t\tselect {\n\t\tcase aliceMsg = <-alice.msgChan:\n\t\tcase err := <-initReq.Err:\n\t\t\tt.Fatalf(\"error init funding workflow: %v\", err)\n\t\tcase <-time.After(time.Second * 5):\n\t\t\tt.Fatalf(\"alice did not send OpenChannel message\")\n\t\t}\n\n\t\topenChannelReq, ok := aliceMsg.(*lnwire.OpenChannel)\n\t\tif !ok {\n\t\t\terrorMsg, gotError := aliceMsg.(*lnwire.Error)\n\t\t\tif gotError {\n\t\t\t\tt.Fatalf(\"expected OpenChannel to be sent \"+\n\t\t\t\t\t\"from bob, instead got error: %v\",\n\t\t\t\t\terrorMsg.Error())\n\t\t\t}\n\t\t\tt.Fatalf(\"expected OpenChannel to be sent from \"+\n\t\t\t\t\"alice, instead got %T\", aliceMsg)\n\t\t}\n\n\t\t// Let Bob handle the init message.\n\t\tbob.fundingMgr.ProcessFundingMsg(openChannelReq, alice)\n\n\t\t// Bob should answer with an AcceptChannel message for the\n\t\t// first maxPending channels.\n\t\tif i < maxPending {\n\t\t\tacceptChannelResponse := assertFundingMsgSent(\n\t\t\t\tt, bob.msgChan, \"AcceptChannel\",\n\t\t\t).(*lnwire.AcceptChannel)\n\t\t\taccepts = append(accepts, acceptChannelResponse)\n\t\t\tcontinue\n\t\t}\n\n\t\t// For the last channel, Bob should answer with an error.\n\t\tlastOpen = openChannelReq\n\t\t_ = assertFundingMsgSent(\n\t\t\tt, bob.msgChan, \"Error\",\n\t\t).(*lnwire.Error)\n\n\t}\n\n\t// Forward the responses to Alice.\n\tvar signs []*lnwire.FundingSigned\n\tfor _, accept := range accepts {\n\t\talice.fundingMgr.ProcessFundingMsg(accept, bob)\n\n\t\t// Alice responds with a FundingCreated message.\n\t\tfundingCreated := assertFundingMsgSent(\n\t\t\tt, alice.msgChan, \"FundingCreated\",\n\t\t).(*lnwire.FundingCreated)\n\n\t\t// Give the message to Bob.\n\t\tbob.fundingMgr.ProcessFundingMsg(fundingCreated, alice)\n\n\t\t// Finally, Bob should send the FundingSigned message.\n\t\tfundingSigned := assertFundingMsgSent(\n\t\t\tt, bob.msgChan, \"FundingSigned\",\n\t\t).(*lnwire.FundingSigned)\n\n\t\tsigns = append(signs, fundingSigned)\n\t}\n\n\t// Sending another init request from Alice should still make Bob\n\t// respond with an error.\n\tbob.fundingMgr.ProcessFundingMsg(lastOpen, alice)\n\t_ = assertFundingMsgSent(\n\t\tt, bob.msgChan, \"Error\",\n\t).(*lnwire.Error)\n\n\t// Give the FundingSigned messages to Alice.\n\tvar txs []*wire.MsgTx\n\tfor i, sign := range signs {\n\t\talice.fundingMgr.ProcessFundingMsg(sign, bob)\n\n\t\t// Alice should send a status update for each channel, and\n\t\t// publish a funding tx to the network.\n\t\tvar pendingUpdate *lnrpc.OpenStatusUpdate\n\t\tselect {\n\t\tcase pendingUpdate = <-initReqs[i].Updates:\n\t\tcase <-time.After(time.Second * 5):\n\t\t\tt.Fatalf(\"alice did not send \" +\n\t\t\t\t\"OpenStatusUpdate_ChanPending\")\n\t\t}\n\n\t\t_, ok := pendingUpdate.Update.(*lnrpc.OpenStatusUpdate_ChanPending)\n\t\tif !ok {\n\t\t\tt.Fatal(\"OpenStatusUpdate was not \" +\n\t\t\t\t\"OpenStatusUpdate_ChanPending\")\n\t\t}\n\n\t\tselect {\n\t\tcase tx := <-alice.publTxChan:\n\t\t\ttxs = append(txs, tx)\n\t\tcase <-time.After(time.Second * 5):\n\t\t\tt.Fatalf(\"alice did not publish funding tx\")\n\t\t}\n\n\t}\n\n\t// Sending another init request from Alice should still make Bob\n\t// respond with an error, since the funding transactions are not\n\t// confirmed yet,\n\tbob.fundingMgr.ProcessFundingMsg(lastOpen, alice)\n\t_ = assertFundingMsgSent(\n\t\tt, bob.msgChan, \"Error\",\n\t).(*lnwire.Error)\n\n\t// Notify that the transactions were mined.\n\tfor i := 0; i < maxPending; i++ {\n\t\talice.mockNotifier.oneConfChannel <- &chainntnfs.TxConfirmation{\n\t\t\tTx: txs[i],\n\t\t}\n\t\tbob.mockNotifier.oneConfChannel <- &chainntnfs.TxConfirmation{\n\t\t\tTx: txs[i],\n\t\t}\n\n\t\t// Expect both to be sending FundingLocked.\n\t\t_ = assertFundingMsgSent(\n\t\t\tt, alice.msgChan, \"FundingLocked\",\n\t\t).(*lnwire.FundingLocked)\n\n\t\t_ = assertFundingMsgSent(\n\t\t\tt, bob.msgChan, \"FundingLocked\",\n\t\t).(*lnwire.FundingLocked)\n\n\t}\n\n\t// Now opening another channel should work.\n\tbob.fundingMgr.ProcessFundingMsg(lastOpen, alice)\n\n\t// Bob should answer with an AcceptChannel message.\n\t_ = assertFundingMsgSent(\n\t\tt, bob.msgChan, \"AcceptChannel\",\n\t).(*lnwire.AcceptChannel)\n}\n\n// TestFundingManagerRejectPush checks behaviour of 'rejectpush'\n// option, namely that non-zero incoming push amounts are disabled.",
      "length": 4784,
      "tokens": 542,
      "embedding": []
    },
    {
      "slug": "func TestFundingManagerRejectPush(t *testing.T) {",
      "content": "func TestFundingManagerRejectPush(t *testing.T) {\n\tt.Parallel()\n\n\t// Enable 'rejectpush' option and initialize funding managers.\n\talice, bob := setupFundingManagers(\n\t\tt, func(cfg *Config) {\n\t\t\tcfg.RejectPush = true\n\t\t},\n\t)\n\tt.Cleanup(func() {\n\t\ttearDownFundingManagers(t, alice, bob)\n\t})\n\n\t// Create a funding request and start the workflow.\n\tupdateChan := make(chan *lnrpc.OpenStatusUpdate)\n\terrChan := make(chan error, 1)\n\tinitReq := &InitFundingMsg{\n\t\tPeer:            bob,\n\t\tTargetPubkey:    bob.privKey.PubKey(),\n\t\tChainHash:       *fundingNetParams.GenesisHash,\n\t\tLocalFundingAmt: 500000,\n\t\tPushAmt:         lnwire.NewMSatFromSatoshis(10),\n\t\tPrivate:         true,\n\t\tUpdates:         updateChan,\n\t\tErr:             errChan,\n\t}\n\n\talice.fundingMgr.InitFundingWorkflow(initReq)\n\n\t// Alice should have sent the OpenChannel message to Bob.\n\tvar aliceMsg lnwire.Message\n\tselect {\n\tcase aliceMsg = <-alice.msgChan:\n\tcase err := <-initReq.Err:\n\t\tt.Fatalf(\"error init funding workflow: %v\", err)\n\tcase <-time.After(time.Second * 5):\n\t\tt.Fatalf(\"alice did not send OpenChannel message\")\n\t}\n\n\topenChannelReq, ok := aliceMsg.(*lnwire.OpenChannel)\n\tif !ok {\n\t\terrorMsg, gotError := aliceMsg.(*lnwire.Error)\n\t\tif gotError {\n\t\t\tt.Fatalf(\"expected OpenChannel to be sent \"+\n\t\t\t\t\"from bob, instead got error: %v\",\n\t\t\t\terrorMsg.Error())\n\t\t}\n\t\tt.Fatalf(\"expected OpenChannel to be sent from \"+\n\t\t\t\"alice, instead got %T\", aliceMsg)\n\t}\n\n\t// Let Bob handle the init message.\n\tbob.fundingMgr.ProcessFundingMsg(openChannelReq, alice)\n\n\t// Assert Bob responded with an ErrNonZeroPushAmount error.\n\terr := assertFundingMsgSent(t, bob.msgChan, \"Error\").(*lnwire.Error)\n\trequire.ErrorContains(\n\t\tt, err, \"non-zero push amounts are disabled\",\n\t\t\"expected ErrNonZeroPushAmount error, got \\\"%v\\\"\", err.Error(),\n\t)\n}\n\n// TestFundingManagerMaxConfs ensures that we don't accept a funding proposal\n// that proposes a MinAcceptDepth greater than the maximum number of\n// confirmations we're willing to accept.",
      "length": 1869,
      "tokens": 213,
      "embedding": []
    },
    {
      "slug": "func TestFundingManagerMaxConfs(t *testing.T) {",
      "content": "func TestFundingManagerMaxConfs(t *testing.T) {\n\tt.Parallel()\n\n\talice, bob := setupFundingManagers(t)\n\tt.Cleanup(func() {\n\t\ttearDownFundingManagers(t, alice, bob)\n\t})\n\n\t// Create a funding request and start the workflow.\n\tupdateChan := make(chan *lnrpc.OpenStatusUpdate)\n\terrChan := make(chan error, 1)\n\tinitReq := &InitFundingMsg{\n\t\tPeer:            bob,\n\t\tTargetPubkey:    bob.privKey.PubKey(),\n\t\tChainHash:       *fundingNetParams.GenesisHash,\n\t\tLocalFundingAmt: 500000,\n\t\tPushAmt:         lnwire.NewMSatFromSatoshis(10),\n\t\tPrivate:         false,\n\t\tUpdates:         updateChan,\n\t\tErr:             errChan,\n\t}\n\n\talice.fundingMgr.InitFundingWorkflow(initReq)\n\n\t// Alice should have sent the OpenChannel message to Bob.\n\tvar aliceMsg lnwire.Message\n\tselect {\n\tcase aliceMsg = <-alice.msgChan:\n\tcase err := <-initReq.Err:\n\t\tt.Fatalf(\"error init funding workflow: %v\", err)\n\tcase <-time.After(time.Second * 5):\n\t\tt.Fatalf(\"alice did not send OpenChannel message\")\n\t}\n\n\topenChannelReq, ok := aliceMsg.(*lnwire.OpenChannel)\n\tif !ok {\n\t\terrorMsg, gotError := aliceMsg.(*lnwire.Error)\n\t\tif gotError {\n\t\t\tt.Fatalf(\"expected OpenChannel to be sent \"+\n\t\t\t\t\"from bob, instead got error: %v\",\n\t\t\t\terrorMsg.Error())\n\t\t}\n\t\tt.Fatalf(\"expected OpenChannel to be sent from \"+\n\t\t\t\"alice, instead got %T\", aliceMsg)\n\t}\n\n\t// Let Bob handle the init message.\n\tbob.fundingMgr.ProcessFundingMsg(openChannelReq, alice)\n\n\t// Bob should answer with an AcceptChannel message.\n\tacceptChannelResponse := assertFundingMsgSent(\n\t\tt, bob.msgChan, \"AcceptChannel\",\n\t).(*lnwire.AcceptChannel)\n\n\t// Modify the AcceptChannel message Bob is proposing to including a\n\t// MinAcceptDepth Alice won't be willing to accept.\n\tacceptChannelResponse.MinAcceptDepth = chainntnfs.MaxNumConfs + 1\n\n\talice.fundingMgr.ProcessFundingMsg(acceptChannelResponse, bob)\n\n\t// Alice should respond back with an error indicating MinAcceptDepth is\n\t// too large.\n\terr := assertFundingMsgSent(t, alice.msgChan, \"Error\").(*lnwire.Error)\n\tif !strings.Contains(err.Error(), \"minimum depth\") {\n\t\tt.Fatalf(\"expected ErrNumConfsTooLarge, got \\\"%v\\\"\",\n\t\t\terr.Error())\n\t}\n}\n\n// TestFundingManagerFundAll tests that we can initiate a funding request to\n// use the funds remaining in the wallet. This should produce a funding tx with\n// no change output.",
      "length": 2167,
      "tokens": 242,
      "embedding": []
    },
    {
      "slug": "func TestFundingManagerFundAll(t *testing.T) {",
      "content": "func TestFundingManagerFundAll(t *testing.T) {\n\tt.Parallel()\n\n\t// We set up our mock wallet to control a list of UTXOs that sum to\n\t// less than the max channel size.\n\tallCoins := []*lnwallet.Utxo{\n\t\t{\n\t\t\tAddressType: lnwallet.WitnessPubKey,\n\t\t\tValue: btcutil.Amount(\n\t\t\t\t0.05 * btcutil.SatoshiPerBitcoin,\n\t\t\t),\n\t\t\tPkScript: mock.CoinPkScript,\n\t\t\tOutPoint: wire.OutPoint{\n\t\t\t\tHash:  chainhash.Hash{},\n\t\t\t\tIndex: 0,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tAddressType: lnwallet.WitnessPubKey,\n\t\t\tValue: btcutil.Amount(\n\t\t\t\t0.06 * btcutil.SatoshiPerBitcoin,\n\t\t\t),\n\t\t\tPkScript: mock.CoinPkScript,\n\t\t\tOutPoint: wire.OutPoint{\n\t\t\t\tHash:  chainhash.Hash{},\n\t\t\t\tIndex: 1,\n\t\t\t},\n\t\t},\n\t}\n\n\ttests := []struct {\n\t\tspendAmt btcutil.Amount\n\t\tchange   bool\n\t}{\n\t\t{\n\t\t\t// We will spend all the funds in the wallet, and\n\t\t\t// expects no change output.\n\t\t\tspendAmt: btcutil.Amount(\n\t\t\t\t0.11 * btcutil.SatoshiPerBitcoin,\n\t\t\t),\n\t\t\tchange: false,\n\t\t},\n\t\t{\n\t\t\t// We spend a little less than the funds in the wallet,\n\t\t\t// so a change output should be created.\n\t\t\tspendAmt: btcutil.Amount(\n\t\t\t\t0.10 * btcutil.SatoshiPerBitcoin,\n\t\t\t),\n\t\t\tchange: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\talice, bob := setupFundingManagers(t)\n\t\tt.Cleanup(func() {\n\t\t\ttearDownFundingManagers(t, alice, bob)\n\t\t})\n\n\t\talice.fundingMgr.cfg.Wallet.WalletController.(*mock.WalletController).Utxos = allCoins\n\n\t\t// We will consume the channel updates as we go, so no\n\t\t// buffering is needed.\n\t\tupdateChan := make(chan *lnrpc.OpenStatusUpdate)\n\n\t\t// Initiate a fund channel, and inspect the funding tx.\n\t\tpushAmt := btcutil.Amount(0)\n\t\tfundingTx := fundChannel(\n\t\t\tt, alice, bob, test.spendAmt, pushAmt, true, 1,\n\t\t\tupdateChan, true, nil,\n\t\t)\n\n\t\t// Check whether the expected change output is present.\n\t\tif test.change && len(fundingTx.TxOut) != 2 {\n\t\t\tt.Fatalf(\"expected 2 outputs, had %v\",\n\t\t\t\tlen(fundingTx.TxOut))\n\t\t}\n\n\t\tif !test.change && len(fundingTx.TxOut) != 1 {\n\t\t\tt.Fatalf(\"expected 1 output, had %v\",\n\t\t\t\tlen(fundingTx.TxOut))\n\t\t}\n\n\t\t// Inputs should be all funds in the wallet.\n\t\tif len(fundingTx.TxIn) != len(allCoins) {\n\t\t\tt.Fatalf(\"Had %d inputs, expected %d\",\n\t\t\t\tlen(fundingTx.TxIn), len(allCoins))\n\t\t}\n\n\t\tfor i, txIn := range fundingTx.TxIn {\n\t\t\tif txIn.PreviousOutPoint != allCoins[i].OutPoint {\n\t\t\t\tt.Fatalf(\"expected outpoint to be %v, was %v\",\n\t\t\t\t\tallCoins[i].OutPoint,\n\t\t\t\t\ttxIn.PreviousOutPoint)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// TestGetUpfrontShutdown tests different combinations of inputs for getting a\n// shutdown script. It varies whether the peer has the feature set, whether\n// the user has provided a script and our local configuration to test that\n// GetUpfrontShutdownScript returns the expected outcome.",
      "length": 2512,
      "tokens": 326,
      "embedding": []
    },
    {
      "slug": "func TestGetUpfrontShutdownScript(t *testing.T) {",
      "content": "func TestGetUpfrontShutdownScript(t *testing.T) {\n\tupfrontScript := []byte(\"upfront script\")\n\tgeneratedScript := []byte(\"generated script\")\n\n\tgetScript := func(_ bool) (lnwire.DeliveryAddress, error) {\n\t\treturn generatedScript, nil\n\t}\n\n\ttests := []struct {\n\t\tname           string\n\t\tgetScript      func(bool) (lnwire.DeliveryAddress, error)\n\t\tupfrontScript  lnwire.DeliveryAddress\n\t\tpeerEnabled    bool\n\t\tlocalEnabled   bool\n\t\texpectedScript lnwire.DeliveryAddress\n\t\texpectedErr    error\n\t}{\n\t\t{\n\t\t\tname:      \"peer disabled, no shutdown\",\n\t\t\tgetScript: getScript,\n\t\t},\n\t\t{\n\t\t\tname:          \"peer disabled, upfront provided\",\n\t\t\tupfrontScript: upfrontScript,\n\t\t\texpectedErr:   errUpfrontShutdownScriptNotSupported,\n\t\t},\n\t\t{\n\t\t\tname:           \"peer enabled, upfront provided\",\n\t\t\tupfrontScript:  upfrontScript,\n\t\t\tpeerEnabled:    true,\n\t\t\texpectedScript: upfrontScript,\n\t\t},\n\t\t{\n\t\t\tname:        \"peer enabled, local disabled\",\n\t\t\tpeerEnabled: true,\n\t\t},\n\t\t{\n\t\t\tname:           \"local enabled, no upfront script\",\n\t\t\tgetScript:      getScript,\n\t\t\tpeerEnabled:    true,\n\t\t\tlocalEnabled:   true,\n\t\t\texpectedScript: generatedScript,\n\t\t},\n\t\t{\n\t\t\tname:           \"local enabled, upfront script\",\n\t\t\tpeerEnabled:    true,\n\t\t\tupfrontScript:  upfrontScript,\n\t\t\tlocalEnabled:   true,\n\t\t\texpectedScript: upfrontScript,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar mockPeer testNode\n\n\t\t\t// If the remote peer in the test should support\n\t\t\t// upfront shutdown, add the feature bit.\n\t\t\tif test.peerEnabled {\n\t\t\t\tmockPeer.remoteFeatures = []lnwire.FeatureBit{\n\t\t\t\t\tlnwire.UpfrontShutdownScriptOptional,\n\t\t\t\t}\n\t\t\t}\n\n\t\t\taddr, err := getUpfrontShutdownScript(\n\t\t\t\ttest.localEnabled, &mockPeer, test.upfrontScript,\n\t\t\t\ttest.getScript,\n\t\t\t)\n\t\t\tif err != test.expectedErr {\n\t\t\t\tt.Fatalf(\"got: %v, expected error: %v\", err,\n\t\t\t\t\ttest.expectedErr)\n\t\t\t}\n\n\t\t\tif !bytes.Equal(addr, test.expectedScript) {\n\t\t\t\tt.Fatalf(\"expected address: %x, got: %x\",\n\t\t\t\t\ttest.expectedScript, addr)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "length": 1899,
      "tokens": 194,
      "embedding": []
    },
    {
      "slug": "func expectOpenChannelMsg(t *testing.T,",
      "content": "func expectOpenChannelMsg(t *testing.T,\n\tmsgChan chan lnwire.Message) *lnwire.OpenChannel {\n\n\tvar msg lnwire.Message\n\tselect {\n\tcase msg = <-msgChan:\n\tcase <-time.After(time.Second * 5):\n\t\tt.Fatalf(\"node did not send OpenChannel message\")\n\t}\n\n\topenChannelReq, ok := msg.(*lnwire.OpenChannel)\n\tif !ok {\n\t\terrorMsg, gotError := msg.(*lnwire.Error)\n\t\tif gotError {\n\t\t\tt.Fatalf(\"expected OpenChannel to be sent \"+\n\t\t\t\t\"from bob, instead got error: %v\",\n\t\t\t\terrorMsg.Error())\n\t\t}\n\t\tt.Fatalf(\"expected OpenChannel to be sent, instead got %T\",\n\t\t\tmsg)\n\t}\n\n\treturn openChannelReq\n}\n",
      "length": 511,
      "tokens": 66,
      "embedding": []
    },
    {
      "slug": "func TestMaxChannelSizeConfig(t *testing.T) {",
      "content": "func TestMaxChannelSizeConfig(t *testing.T) {\n\tt.Parallel()\n\n\t// Create a set of funding managers that will reject wumbo\n\t// channels but set --maxchansize explicitly lower than soft-limit.\n\t// Verify that wumbo rejecting funding managers will respect\n\t// --maxchansize below 16777215 satoshi (MaxBtcFundingAmount) limit.\n\talice, bob := setupFundingManagers(t, func(cfg *Config) {\n\t\tcfg.NoWumboChans = true\n\t\tcfg.MaxChanSize = MaxBtcFundingAmount - 1\n\t})\n\n\t// Attempt to create a channel above the limit\n\t// imposed by --maxchansize, which should be rejected.\n\tupdateChan := make(chan *lnrpc.OpenStatusUpdate)\n\terrChan := make(chan error, 1)\n\tinitReq := &InitFundingMsg{\n\t\tPeer:            bob,\n\t\tTargetPubkey:    bob.privKey.PubKey(),\n\t\tChainHash:       *fundingNetParams.GenesisHash,\n\t\tLocalFundingAmt: MaxBtcFundingAmount,\n\t\tPushAmt:         lnwire.NewMSatFromSatoshis(0),\n\t\tPrivate:         false,\n\t\tUpdates:         updateChan,\n\t\tErr:             errChan,\n\t}\n\n\t// After processing the funding open message, bob should respond with\n\t// an error rejecting the channel that exceeds size limit.\n\talice.fundingMgr.InitFundingWorkflow(initReq)\n\topenChanMsg := expectOpenChannelMsg(t, alice.msgChan)\n\tbob.fundingMgr.ProcessFundingMsg(openChanMsg, alice)\n\tassertErrorSent(t, bob.msgChan)\n\n\t// Create a set of funding managers that will reject wumbo\n\t// channels but set --maxchansize explicitly higher than soft-limit\n\t// A --maxchansize greater than this limit should have no effect.\n\ttearDownFundingManagers(t, alice, bob)\n\talice, bob = setupFundingManagers(t, func(cfg *Config) {\n\t\tcfg.NoWumboChans = true\n\t\tcfg.MaxChanSize = MaxBtcFundingAmount + 1\n\t})\n\n\t// Reset the Peer to the newly created one.\n\tinitReq.Peer = bob\n\n\t// We expect Bob to respond with an Accept channel message.\n\talice.fundingMgr.InitFundingWorkflow(initReq)\n\topenChanMsg = expectOpenChannelMsg(t, alice.msgChan)\n\tbob.fundingMgr.ProcessFundingMsg(openChanMsg, alice)\n\tassertFundingMsgSent(t, bob.msgChan, \"AcceptChannel\")\n\n\t// Verify that wumbo accepting funding managers will respect\n\t// --maxchansize. Create the funding managers, this time allowing wumbo\n\t// channels but setting --maxchansize explicitly.\n\ttearDownFundingManagers(t, alice, bob)\n\talice, bob = setupFundingManagers(t, func(cfg *Config) {\n\t\tcfg.NoWumboChans = false\n\t\tcfg.MaxChanSize = btcutil.Amount(100000000)\n\t})\n\n\t// Reset the Peer to the newly created one.\n\tinitReq.Peer = bob\n\n\t// Attempt to create a channel above the limit\n\t// imposed by --maxchansize, which should be rejected.\n\tinitReq.LocalFundingAmt = btcutil.SatoshiPerBitcoin + 1\n\n\t// After processing the funding open message, bob should respond with\n\t// an error rejecting the channel that exceeds size limit.\n\talice.fundingMgr.InitFundingWorkflow(initReq)\n\topenChanMsg = expectOpenChannelMsg(t, alice.msgChan)\n\tbob.fundingMgr.ProcessFundingMsg(openChanMsg, alice)\n\tassertErrorSent(t, bob.msgChan)\n}\n\n// TestWumboChannelConfig tests that the funding manager will respect the wumbo\n// channel config param when creating or accepting new channels.",
      "length": 2927,
      "tokens": 340,
      "embedding": []
    },
    {
      "slug": "func TestWumboChannelConfig(t *testing.T) {",
      "content": "func TestWumboChannelConfig(t *testing.T) {\n\tt.Parallel()\n\n\t// First we'll create a set of funding managers that will reject wumbo\n\t// channels.\n\talice, bob := setupFundingManagers(t, func(cfg *Config) {\n\t\tcfg.NoWumboChans = true\n\t})\n\n\t// If we attempt to initiate a new funding open request to Alice,\n\t// that's below the wumbo channel mark, we should be able to start the\n\t// funding process w/o issue.\n\tupdateChan := make(chan *lnrpc.OpenStatusUpdate)\n\terrChan := make(chan error, 1)\n\tinitReq := &InitFundingMsg{\n\t\tPeer:            bob,\n\t\tTargetPubkey:    bob.privKey.PubKey(),\n\t\tChainHash:       *fundingNetParams.GenesisHash,\n\t\tLocalFundingAmt: MaxBtcFundingAmount,\n\t\tPushAmt:         lnwire.NewMSatFromSatoshis(0),\n\t\tPrivate:         false,\n\t\tUpdates:         updateChan,\n\t\tErr:             errChan,\n\t}\n\n\t// We expect Bob to respond with an Accept channel message.\n\talice.fundingMgr.InitFundingWorkflow(initReq)\n\topenChanMsg := expectOpenChannelMsg(t, alice.msgChan)\n\tbob.fundingMgr.ProcessFundingMsg(openChanMsg, alice)\n\tassertFundingMsgSent(t, bob.msgChan, \"AcceptChannel\")\n\n\t// We'll now attempt to create a channel above the wumbo mark, which\n\t// should be rejected.\n\tinitReq.LocalFundingAmt = btcutil.SatoshiPerBitcoin\n\n\t// After processing the funding open message, bob should respond with an\n\t// error rejecting the channel.\n\talice.fundingMgr.InitFundingWorkflow(initReq)\n\topenChanMsg = expectOpenChannelMsg(t, alice.msgChan)\n\tbob.fundingMgr.ProcessFundingMsg(openChanMsg, alice)\n\tassertErrorSent(t, bob.msgChan)\n\n\t// Next, we'll re-create the funding managers, but this time allowing\n\t// wumbo channels explicitly.\n\ttearDownFundingManagers(t, alice, bob)\n\talice, bob = setupFundingManagers(t, func(cfg *Config) {\n\t\tcfg.NoWumboChans = false\n\t\tcfg.MaxChanSize = MaxBtcFundingAmountWumbo\n\t})\n\n\t// Reset the Peer to the newly created one.\n\tinitReq.Peer = bob\n\n\t// We should now be able to initiate a wumbo channel funding w/o any\n\t// issues.\n\talice.fundingMgr.InitFundingWorkflow(initReq)\n\topenChanMsg = expectOpenChannelMsg(t, alice.msgChan)\n\tbob.fundingMgr.ProcessFundingMsg(openChanMsg, alice)\n\tassertFundingMsgSent(t, bob.msgChan, \"AcceptChannel\")\n}\n\n// TestFundingManagerUpfrontShutdown asserts that we'll properly fail out if\n// an invalid upfront shutdown script is sent in the open_channel message.\n// Since both the open_channel and accept_message logic validate the script\n// using the same validation function, it suffices to just check the\n// open_channel case.",
      "length": 2375,
      "tokens": 273,
      "embedding": []
    },
    {
      "slug": "func TestFundingManagerUpfrontShutdown(t *testing.T) {",
      "content": "func TestFundingManagerUpfrontShutdown(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tname      string\n\t\tpkscript  []byte\n\t\texpectErr bool\n\t}{\n\t\t{\n\t\t\tname: \"p2pk script\",\n\t\t\tpkscript: []byte(\"\\x21\\x02\\xd3\\x00\\x50\\x2f\\x61\\x15\" +\n\t\t\t\t\"\\x0d\\x58\\x0a\\x42\\xa0\\x99\\x63\\xe3\\x47\\xa2\" +\n\t\t\t\t\"\\xad\\x3c\\xe5\\x1f\\x11\\x96\\x0d\\x35\\x8d\\xf8\" +\n\t\t\t\t\"\\xf3\\x94\\xf9\\x67\\x2a\\x67\\xac\"),\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"op return script\",\n\t\t\tpkscript: []byte(\"\\x6a\\x24\\xaa\\x21\\xa9\\xed\\x18\\xa9\" +\n\t\t\t\t\"\\x93\\x58\\x94\\xbd\\x48\\x9b\\xeb\\x87\\x66\\x13\" +\n\t\t\t\t\"\\x60\\xbc\\x80\\x92\\xab\\xf6\\xdd\\xe9\\x1e\\x82\" +\n\t\t\t\t\"\\x0c\\x7d\\x91\\x89\\x9d\\x0a\\x02\\x34\\x14\\x3f\"),\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"standard (non-p2sh) 2-of-3 multisig\",\n\t\t\tpkscript: []byte(\"\\x51\\x41\\x04\\xcc\\x71\\xeb\\x30\\xd6\" +\n\t\t\t\t\"\\x53\\xc0\\xc3\\x16\\x39\\x90\\xc4\\x7b\\x97\\x6f\" +\n\t\t\t\t\"\\x3f\\xb3\\xf3\\x7c\\xcc\\xdc\\xbe\\xdb\\x16\\x9a\" +\n\t\t\t\t\"\\x1d\\xfe\\xf5\\x8b\\xbf\\xbf\\xaf\\xf7\\xd8\\xa4\" +\n\t\t\t\t\"\\x73\\xe7\\xe2\\xe6\\xd3\\x17\\xb8\\x7b\\xaf\\xe8\" +\n\t\t\t\t\"\\xbd\\xe9\\x7e\\x3c\\xf8\\xf0\\x65\\xde\\xc0\\x22\" +\n\t\t\t\t\"\\xb5\\x1d\\x11\\xfc\\xdd\\x0d\\x34\\x8a\\xc4\\x41\" +\n\t\t\t\t\"\\x04\\x61\\xcb\\xdc\\xc5\\x40\\x9f\\xb4\\xb4\\xd4\" +\n\t\t\t\t\"\\x2b\\x51\\xd3\\x33\\x81\\x35\\x4d\\x80\\xe5\\x50\" +\n\t\t\t\t\"\\x07\\x8c\\xb5\\x32\\xa3\\x4b\\xfa\\x2f\\xcf\\xde\" +\n\t\t\t\t\"\\xb7\\xd7\\x65\\x19\\xae\\xcc\\x62\\x77\\x0f\\x5b\" +\n\t\t\t\t\"\\x0e\\x4e\\xf8\\x55\\x19\\x46\\xd8\\xa5\\x40\\x91\" +\n\t\t\t\t\"\\x1a\\xbe\\x3e\\x78\\x54\\xa2\\x6f\\x39\\xf5\\x8b\" +\n\t\t\t\t\"\\x25\\xc1\\x53\\x42\\xaf\\x52\\xae\"),\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"nonstandard script\",\n\t\t\tpkscript:  []byte(\"\\x99\"),\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"p2sh script\",\n\t\t\tpkscript: []byte(\"\\xa9\\x14\\xfe\\x44\\x10\\x65\\xb6\\x53\" +\n\t\t\t\t\"\\x22\\x31\\xde\\x2f\\xac\\x56\\x31\\x52\\x20\\x5e\" +\n\t\t\t\t\"\\xc4\\xf5\\x9c\\x74\\x87\"),\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"p2pkh script\",\n\t\t\tpkscript: []byte(\"\\x76\\xa9\\x14\\x64\\x1a\\xd5\\x05\\x1e\" +\n\t\t\t\t\"\\xdd\\x97\\x02\\x9a\\x00\\x3f\\xe9\\xef\\xb2\\x93\" +\n\t\t\t\t\"\\x59\\xfc\\xee\\x40\\x9d\\x88\\xac\"),\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"p2wpkh script\",\n\t\t\tpkscript: []byte(\"\\x00\\x14\\x4b\\xfe\\x98\\x3f\\x16\\xaa\" +\n\t\t\t\t\"\\xde\\x1b\\x1c\\xb1\\x54\\x5a\\xa5\\xa4\\x88\\xd5\" +\n\t\t\t\t\"\\xe3\\x68\\xb5\\xdc\"),\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"p2wsh script\",\n\t\t\tpkscript: []byte(\"\\x00\\x20\\x1d\\xd6\\x3c\\x20\\x13\\x89\" +\n\t\t\t\t\"\\x3a\\x8b\\x41\\x5e\\xb2\\xe7\\x41\\x8f\\x07\\x5d\" +\n\t\t\t\t\"\\x4f\\x3b\\xf1\\x81\\x34\\x99\\xef\\x31\\xfb\\xd7\" +\n\t\t\t\t\"\\x8c\\xa8\\xc4\\x5d\\x8f\\xf0\"),\n\t\t\texpectErr: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\ttestUpfrontFailure(t, test.pkscript, test.expectErr)\n\t\t})\n\t}\n}\n",
      "length": 2342,
      "tokens": 164,
      "embedding": []
    },
    {
      "slug": "func testUpfrontFailure(t *testing.T, pkscript []byte, expectErr bool) {",
      "content": "func testUpfrontFailure(t *testing.T, pkscript []byte, expectErr bool) {\n\talice, bob := setupFundingManagers(t)\n\tt.Cleanup(func() {\n\t\ttearDownFundingManagers(t, alice, bob)\n\t})\n\n\terrChan := make(chan error, 1)\n\tupdateChan := make(chan *lnrpc.OpenStatusUpdate)\n\n\tfundingAmt := btcutil.Amount(500000)\n\tpushAmt := lnwire.NewMSatFromSatoshis(btcutil.Amount(0))\n\n\tinitReq := &InitFundingMsg{\n\t\tPeer:            alice,\n\t\tTargetPubkey:    alice.privKey.PubKey(),\n\t\tChainHash:       *fundingNetParams.GenesisHash,\n\t\tSubtractFees:    false,\n\t\tLocalFundingAmt: fundingAmt,\n\t\tPushAmt:         pushAmt,\n\t\tFundingFeePerKw: 1000,\n\t\tPrivate:         false,\n\t\tUpdates:         updateChan,\n\t\tErr:             errChan,\n\t}\n\tbob.fundingMgr.InitFundingWorkflow(initReq)\n\n\t// Bob should send an open_channel message to Alice.\n\tvar bobMsg lnwire.Message\n\tselect {\n\tcase bobMsg = <-bob.msgChan:\n\tcase err := <-initReq.Err:\n\t\tt.Fatalf(\"received unexpected error: %v\", err)\n\tcase <-time.After(time.Second * 5):\n\t\tt.Fatalf(\"timed out waiting for bob's message\")\n\t}\n\n\tbobOpenChan, ok := bobMsg.(*lnwire.OpenChannel)\n\trequire.True(t, ok, \"did not receive OpenChannel\")\n\n\t// Set the UpfrontShutdownScript in OpenChannel.\n\tbobOpenChan.UpfrontShutdownScript = lnwire.DeliveryAddress(pkscript)\n\n\t// Send the OpenChannel message to Alice now. If we expected an error,\n\t// check that we received it.\n\talice.fundingMgr.ProcessFundingMsg(bobOpenChan, bob)\n\n\tvar aliceMsg lnwire.Message\n\tselect {\n\tcase aliceMsg = <-alice.msgChan:\n\tcase <-time.After(time.Second * 5):\n\t\tt.Fatalf(\"timed out waiting for alice's message\")\n\t}\n\n\tif expectErr {\n\t\t// Assert that Error was received.\n\t\t_, ok = aliceMsg.(*lnwire.Error)\n\t\trequire.True(t, ok, \"did not receive Error\")\n\t} else {\n\t\t// Assert that AcceptChannel was received.\n\t\t_, ok = aliceMsg.(*lnwire.AcceptChannel)\n\t\trequire.True(t, ok, \"did not receive AcceptChannel\")\n\t}\n}\n\n// TestFundingManagerZeroConf tests that the fundingmanager properly handles\n// the whole flow for zero-conf channels.",
      "length": 1861,
      "tokens": 203,
      "embedding": []
    },
    {
      "slug": "func TestFundingManagerZeroConf(t *testing.T) {",
      "content": "func TestFundingManagerZeroConf(t *testing.T) {\n\tt.Parallel()\n\n\talice, bob := setupFundingManagers(t)\n\tt.Cleanup(func() {\n\t\ttearDownFundingManagers(t, alice, bob)\n\t})\n\n\t// Alice and Bob will have the same set of feature bits in our test.\n\tfeatureBits := []lnwire.FeatureBit{\n\t\tlnwire.ZeroConfOptional,\n\t\tlnwire.ScidAliasOptional,\n\t\tlnwire.ExplicitChannelTypeOptional,\n\t\tlnwire.StaticRemoteKeyOptional,\n\t\tlnwire.AnchorsZeroFeeHtlcTxOptional,\n\t}\n\talice.localFeatures = featureBits\n\talice.remoteFeatures = featureBits\n\tbob.localFeatures = featureBits\n\tbob.remoteFeatures = featureBits\n\n\tfundingAmt := btcutil.Amount(500000)\n\tpushAmt := btcutil.Amount(0)\n\tupdateChan := make(chan *lnrpc.OpenStatusUpdate)\n\n\t// Construct the zero-conf ChannelType for use in open_channel.\n\tchannelTypeBits := []lnwire.FeatureBit{\n\t\tlnwire.ZeroConfRequired,\n\t\tlnwire.StaticRemoteKeyRequired,\n\t\tlnwire.AnchorsZeroFeeHtlcTxRequired,\n\t}\n\tchannelType := lnwire.ChannelType(\n\t\t*lnwire.NewRawFeatureVector(channelTypeBits...),\n\t)\n\n\t// Create a default-accept channelacceptor so that the test passes and\n\t// we don't have to use any goroutines.\n\tmockAcceptor := &mockZeroConfAcceptor{}\n\tbob.fundingMgr.cfg.OpenChannelPredicate = mockAcceptor\n\n\t// Call fundChannel with the zero-conf ChannelType.\n\tfundingTx := fundChannel(\n\t\tt, alice, bob, fundingAmt, pushAmt, false, 1, updateChan, true,\n\t\t&channelType,\n\t)\n\tfundingOp := &wire.OutPoint{\n\t\tHash:  fundingTx.TxHash(),\n\t\tIndex: 0,\n\t}\n\n\t// Assert that Bob's funding_locked message has an AliasScid.\n\tbobFundingLocked := assertFundingMsgSent(\n\t\tt, bob.msgChan, \"FundingLocked\",\n\t).(*lnwire.FundingLocked)\n\trequire.NotNil(t, bobFundingLocked.AliasScid)\n\trequire.Equal(t, *bobFundingLocked.AliasScid, alias)\n\n\t// Do the same for Alice as well.\n\taliceFundingLocked := assertFundingMsgSent(\n\t\tt, alice.msgChan, \"FundingLocked\",\n\t).(*lnwire.FundingLocked)\n\trequire.NotNil(t, aliceFundingLocked.AliasScid)\n\trequire.Equal(t, *aliceFundingLocked.AliasScid, alias)\n\n\t// Exchange the funding_locked messages.\n\talice.fundingMgr.ProcessFundingMsg(bobFundingLocked, bob)\n\tbob.fundingMgr.ProcessFundingMsg(aliceFundingLocked, alice)\n\n\t// We'll assert that they both create new links.\n\tassertHandleFundingLocked(t, alice, bob)\n\n\t// We'll now assert that both sides send ChannelAnnouncement and\n\t// ChannelUpdate messages.\n\tassertChannelAnnouncements(\n\t\tt, alice, bob, fundingAmt, nil, nil, nil, nil,\n\t)\n\n\t// We'll now wait for the OpenStatusUpdate_ChanOpen update.\n\twaitForOpenUpdate(t, updateChan)\n\n\t// Assert that both Alice & Bob are in the addedToRouterGraph state.\n\tassertAddedToRouterGraph(t, alice, bob, fundingOp)\n\n\t// We'll now restart Alice's funding manager and assert that the tx\n\t// is rebroadcast.\n\trecreateAliceFundingManager(t, alice)\n\n\tselect {\n\tcase <-alice.publTxChan:\n\tcase <-time.After(time.Second * 5):\n\t\tt.Fatalf(\"timed out waiting for alice to rebroadcast tx\")\n\t}\n\n\t// We'll now confirm the funding transaction.\n\talice.mockNotifier.sixConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\tbob.mockNotifier.sixConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\n\tassertChannelAnnouncements(\n\t\tt, alice, bob, fundingAmt, nil, nil, nil, nil,\n\t)\n\n\t// Both Alice and Bob should send on reportScidChan.\n\tselect {\n\tcase <-alice.reportScidChan:\n\tcase <-time.After(time.Second * 5):\n\t\tt.Fatalf(\"did not call ReportShortChanID in time\")\n\t}\n\n\tselect {\n\tcase <-bob.reportScidChan:\n\tcase <-time.After(time.Second * 5):\n\t\tt.Fatalf(\"did not call ReportShortChanID in time\")\n\t}\n\n\t// Send along the 6-confirmation channel so that announcement sigs can\n\t// be exchanged.\n\talice.mockNotifier.sixConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\tbob.mockNotifier.sixConfChannel <- &chainntnfs.TxConfirmation{\n\t\tTx: fundingTx,\n\t}\n\n\tassertAnnouncementSignatures(t, alice, bob)\n\n\t// Assert that the channel state is deleted from the fundingmanager's\n\t// datastore.\n\tassertNoChannelState(t, alice, bob, fundingOp)\n\n\t// The forwarding policy for the channel announcement should\n\t// have been deleted from the database, as the channel is announced.\n\tassertNoFwdingPolicy(t, alice, bob, fundingOp)\n}\n",
      "length": 3950,
      "tokens": 417,
      "embedding": []
    }
  ]
}