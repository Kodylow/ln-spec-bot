{
  "filepath": "../implementations/go/lnd/funding/commitment_type_negotiation.go",
  "package": "funding",
  "sections": [
    {
      "slug": "func negotiateCommitmentType(channelType *lnwire.ChannelType, local,",
      "content": "func negotiateCommitmentType(channelType *lnwire.ChannelType, local,\n\tremote *lnwire.FeatureVector, mustBeExplicit bool) (bool,\n\t*lnwire.ChannelType, lnwallet.CommitmentType, error) {\n\n\tif channelType != nil {\n\t\t// If the peer does know explicit negotiation, let's attempt\n\t\t// that now.\n\t\tif hasFeatures(\n\t\t\tlocal, remote, lnwire.ExplicitChannelTypeOptional,\n\t\t) {\n\n\t\t\tchanType, err := explicitNegotiateCommitmentType(\n\t\t\t\t*channelType, local, remote,\n\t\t\t)\n\t\t\treturn true, channelType, chanType, err\n\t\t}\n\n\t\t// If we're the funder, and we are attempting to use an\n\t\t// explicit channel type, but the remote party doesn't signal\n\t\t// the bit, then we actually want to exit here, to ensure the\n\t\t// user doesn't end up with an unexpected channel type via\n\t\t// implicit negotiation.\n\t\tif mustBeExplicit {\n\t\t\treturn false, nil, 0, errUnsupportedExplicitNegotiation\n\t\t}\n\t}\n\n\tchanType, commitType := implicitNegotiateCommitmentType(local, remote)\n\treturn false, chanType, commitType, nil\n}\n\n// explicitNegotiateCommitmentType attempts to explicitly negotiate for a\n// specific channel type. Since the channel type is comprised of a set of even\n// feature bits, we also make sure each feature is supported by both peers. An\n// error is returned if either peer does not support said channel type.",
      "length": 1186,
      "tokens": 169,
      "embedding": []
    },
    {
      "slug": "func explicitNegotiateCommitmentType(channelType lnwire.ChannelType, local,",
      "content": "func explicitNegotiateCommitmentType(channelType lnwire.ChannelType, local,\n\tremote *lnwire.FeatureVector) (lnwallet.CommitmentType, error) {\n\n\tchannelFeatures := lnwire.RawFeatureVector(channelType)\n\n\tswitch {\n\t// Lease script enforcement + anchors zero fee + static remote key +\n\t// zero conf + scid alias features only.\n\tcase channelFeatures.OnlyContains(\n\t\tlnwire.ZeroConfRequired,\n\t\tlnwire.ScidAliasRequired,\n\t\tlnwire.ScriptEnforcedLeaseRequired,\n\t\tlnwire.AnchorsZeroFeeHtlcTxRequired,\n\t\tlnwire.StaticRemoteKeyRequired,\n\t):\n\t\tif !hasFeatures(\n\t\t\tlocal, remote,\n\t\t\tlnwire.ZeroConfOptional,\n\t\t\tlnwire.ScriptEnforcedLeaseOptional,\n\t\t\tlnwire.AnchorsZeroFeeHtlcTxOptional,\n\t\t\tlnwire.StaticRemoteKeyOptional,\n\t\t) {\n\n\t\t\treturn 0, errUnsupportedChannelType\n\t\t}\n\t\treturn lnwallet.CommitmentTypeScriptEnforcedLease, nil\n\n\t// Anchors zero fee + static remote key + zero conf + scid alias\n\t// features only.\n\tcase channelFeatures.OnlyContains(\n\t\tlnwire.ZeroConfRequired,\n\t\tlnwire.ScidAliasRequired,\n\t\tlnwire.AnchorsZeroFeeHtlcTxRequired,\n\t\tlnwire.StaticRemoteKeyRequired,\n\t):\n\t\tif !hasFeatures(\n\t\t\tlocal, remote,\n\t\t\tlnwire.ZeroConfOptional,\n\t\t\tlnwire.AnchorsZeroFeeHtlcTxOptional,\n\t\t\tlnwire.StaticRemoteKeyOptional,\n\t\t) {\n\n\t\t\treturn 0, errUnsupportedChannelType\n\t\t}\n\t\treturn lnwallet.CommitmentTypeAnchorsZeroFeeHtlcTx, nil\n\n\t// Lease script enforcement + anchors zero fee + static remote key +\n\t// zero conf features only.\n\tcase channelFeatures.OnlyContains(\n\t\tlnwire.ZeroConfRequired,\n\t\tlnwire.ScriptEnforcedLeaseRequired,\n\t\tlnwire.AnchorsZeroFeeHtlcTxRequired,\n\t\tlnwire.StaticRemoteKeyRequired,\n\t):\n\t\tif !hasFeatures(\n\t\t\tlocal, remote,\n\t\t\tlnwire.ZeroConfOptional,\n\t\t\tlnwire.ScriptEnforcedLeaseOptional,\n\t\t\tlnwire.AnchorsZeroFeeHtlcTxOptional,\n\t\t\tlnwire.StaticRemoteKeyOptional,\n\t\t) {\n\n\t\t\treturn 0, errUnsupportedChannelType\n\t\t}\n\t\treturn lnwallet.CommitmentTypeScriptEnforcedLease, nil\n\n\t// Anchors zero fee + static remote key + zero conf features only.\n\tcase channelFeatures.OnlyContains(\n\t\tlnwire.ZeroConfRequired,\n\t\tlnwire.AnchorsZeroFeeHtlcTxRequired,\n\t\tlnwire.StaticRemoteKeyRequired,\n\t):\n\t\tif !hasFeatures(\n\t\t\tlocal, remote,\n\t\t\tlnwire.ZeroConfOptional,\n\t\t\tlnwire.AnchorsZeroFeeHtlcTxOptional,\n\t\t\tlnwire.StaticRemoteKeyOptional,\n\t\t) {\n\n\t\t\treturn 0, errUnsupportedChannelType\n\t\t}\n\t\treturn lnwallet.CommitmentTypeAnchorsZeroFeeHtlcTx, nil\n\n\t// Lease script enforcement + anchors zero fee + static remote key +\n\t// option-scid-alias features only.\n\tcase channelFeatures.OnlyContains(\n\t\tlnwire.ScidAliasRequired,\n\t\tlnwire.ScriptEnforcedLeaseRequired,\n\t\tlnwire.AnchorsZeroFeeHtlcTxRequired,\n\t\tlnwire.StaticRemoteKeyRequired,\n\t):\n\t\tif !hasFeatures(\n\t\t\tlocal, remote,\n\t\t\tlnwire.ScidAliasOptional,\n\t\t\tlnwire.ScriptEnforcedLeaseOptional,\n\t\t\tlnwire.AnchorsZeroFeeHtlcTxOptional,\n\t\t\tlnwire.StaticRemoteKeyOptional,\n\t\t) {\n\n\t\t\treturn 0, errUnsupportedChannelType\n\t\t}\n\t\treturn lnwallet.CommitmentTypeScriptEnforcedLease, nil\n\n\t// Anchors zero fee + static remote key + option-scid-alias features\n\t// only.\n\tcase channelFeatures.OnlyContains(\n\t\tlnwire.ScidAliasRequired,\n\t\tlnwire.AnchorsZeroFeeHtlcTxRequired,\n\t\tlnwire.StaticRemoteKeyRequired,\n\t):\n\t\tif !hasFeatures(\n\t\t\tlocal, remote,\n\t\t\tlnwire.ScidAliasOptional,\n\t\t\tlnwire.AnchorsZeroFeeHtlcTxOptional,\n\t\t\tlnwire.StaticRemoteKeyOptional,\n\t\t) {\n\n\t\t\treturn 0, errUnsupportedChannelType\n\t\t}\n\t\treturn lnwallet.CommitmentTypeAnchorsZeroFeeHtlcTx, nil\n\n\t// Lease script enforcement + anchors zero fee + static remote key\n\t// features only.\n\tcase channelFeatures.OnlyContains(\n\t\tlnwire.ScriptEnforcedLeaseRequired,\n\t\tlnwire.AnchorsZeroFeeHtlcTxRequired,\n\t\tlnwire.StaticRemoteKeyRequired,\n\t):\n\t\tif !hasFeatures(\n\t\t\tlocal, remote,\n\t\t\tlnwire.ScriptEnforcedLeaseOptional,\n\t\t\tlnwire.AnchorsZeroFeeHtlcTxOptional,\n\t\t\tlnwire.StaticRemoteKeyOptional,\n\t\t) {\n\n\t\t\treturn 0, errUnsupportedChannelType\n\t\t}\n\t\treturn lnwallet.CommitmentTypeScriptEnforcedLease, nil\n\n\t// Anchors zero fee + static remote key features only.\n\tcase channelFeatures.OnlyContains(\n\t\tlnwire.AnchorsZeroFeeHtlcTxRequired,\n\t\tlnwire.StaticRemoteKeyRequired,\n\t):\n\t\tif !hasFeatures(\n\t\t\tlocal, remote,\n\t\t\tlnwire.AnchorsZeroFeeHtlcTxOptional,\n\t\t\tlnwire.StaticRemoteKeyOptional,\n\t\t) {\n\n\t\t\treturn 0, errUnsupportedChannelType\n\t\t}\n\t\treturn lnwallet.CommitmentTypeAnchorsZeroFeeHtlcTx, nil\n\n\t// Static remote key feature only.\n\tcase channelFeatures.OnlyContains(lnwire.StaticRemoteKeyRequired):\n\t\tif !hasFeatures(local, remote, lnwire.StaticRemoteKeyOptional) {\n\t\t\treturn 0, errUnsupportedChannelType\n\t\t}\n\t\treturn lnwallet.CommitmentTypeTweakless, nil\n\n\t// No features, use legacy commitment type.\n\tcase channelFeatures.IsEmpty():\n\t\treturn lnwallet.CommitmentTypeLegacy, nil\n\n\tdefault:\n\t\treturn 0, errUnsupportedChannelType\n\t}\n}\n\n// implicitNegotiateCommitmentType negotiates the commitment type of a channel\n// implicitly by choosing the latest type supported by the local and remote\n// features.",
      "length": 4630,
      "tokens": 378,
      "embedding": []
    },
    {
      "slug": "func implicitNegotiateCommitmentType(local,",
      "content": "func implicitNegotiateCommitmentType(local,\n\tremote *lnwire.FeatureVector) (*lnwire.ChannelType,\n\tlnwallet.CommitmentType) {\n\n\t// If both peers are signalling support for anchor commitments with\n\t// zero-fee HTLC transactions, we'll use this type.\n\tif hasFeatures(local, remote, lnwire.AnchorsZeroFeeHtlcTxOptional) {\n\t\tchanType := lnwire.ChannelType(*lnwire.NewRawFeatureVector(\n\t\t\tlnwire.AnchorsZeroFeeHtlcTxRequired,\n\t\t\tlnwire.StaticRemoteKeyRequired,\n\t\t))\n\n\t\treturn &chanType, lnwallet.CommitmentTypeAnchorsZeroFeeHtlcTx\n\t}\n\n\t// Since we don't want to support the \"legacy\" anchor type, we will fall\n\t// back to static remote key if the nodes don't support the zero fee\n\t// HTLC tx anchor type.\n\t//\n\t// If both nodes are signaling the proper feature bit for tweakless\n\t// commitments, we'll use that.\n\tif hasFeatures(local, remote, lnwire.StaticRemoteKeyOptional) {\n\t\tchanType := lnwire.ChannelType(*lnwire.NewRawFeatureVector(\n\t\t\tlnwire.StaticRemoteKeyRequired,\n\t\t))\n\n\t\treturn &chanType, lnwallet.CommitmentTypeTweakless\n\t}\n\n\t// Otherwise we'll fall back to the legacy type.\n\tchanType := lnwire.ChannelType(*lnwire.NewRawFeatureVector())\n\treturn &chanType, lnwallet.CommitmentTypeLegacy\n}\n\n// hasFeatures determines whether a set of features is supported by both the set\n// of local and remote features.",
      "length": 1229,
      "tokens": 140,
      "embedding": []
    },
    {
      "slug": "func hasFeatures(local, remote *lnwire.FeatureVector,",
      "content": "func hasFeatures(local, remote *lnwire.FeatureVector,\n\tfeatures ...lnwire.FeatureBit) bool {\n\n\tfor _, feature := range features {\n\t\tif !local.HasFeature(feature) || !remote.HasFeature(feature) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n",
      "length": 170,
      "tokens": 23,
      "embedding": []
    }
  ]
}