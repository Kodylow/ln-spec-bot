{
  "filepath": "../implementations/go/lnd/subscribe/subscribe_test.go",
  "package": "subscribe_test",
  "sections": [
    {
      "slug": "func TestSubscribe(t *testing.T) {",
      "content": "func TestSubscribe(t *testing.T) {\n\tt.Parallel()\n\n\tserver := subscribe.NewServer()\n\tif err := server.Start(); err != nil {\n\t\tt.Fatalf(\"unable to start server\")\n\t}\n\n\tconst numClients = 300\n\tconst numUpdates = 1000\n\n\tvar clients [numClients]*subscribe.Client\n\n\t// Start by registering two thirds the clients.\n\tfor i := 0; i < numClients*2/3; i++ {\n\t\tc, err := server.Subscribe()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to subscribe: %v\", err)\n\t\t}\n\n\t\tclients[i] = c\n\t}\n\n\t// Send half the updates.\n\tfor i := 0; i < numUpdates/2; i++ {\n\t\tif err := server.SendUpdate(i); err != nil {\n\t\t\tt.Fatalf(\"unable to send update\")\n\t\t}\n\t}\n\n\t// Register the rest of the clients.\n\tfor i := numClients * 2 / 3; i < numClients; i++ {\n\t\tc, err := server.Subscribe()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to subscribe: %v\", err)\n\t\t}\n\n\t\tclients[i] = c\n\t}\n\n\t// Cancel one third of the clients.\n\tfor i := 0; i < numClients/3; i++ {\n\t\tclients[i].Cancel()\n\t}\n\n\t// Send the rest of the updates.\n\tfor i := numUpdates / 2; i < numUpdates; i++ {\n\t\tif err := server.SendUpdate(i); err != nil {\n\t\t\tt.Fatalf(\"unable to send update\")\n\t\t}\n\t}\n\n\t// Now ensure the clients got the updates we expect.\n\tfor i, c := range clients {\n\n\t\tvar from, to int\n\t\tswitch {\n\n\t\t// We expect the first third of the clients to quit, since they\n\t\t// were canceled.\n\t\tcase i < numClients/3:\n\t\t\tselect {\n\t\t\tcase <-c.Quit():\n\t\t\t\tcontinue\n\t\t\tcase <-time.After(1 * time.Second):\n\t\t\t\tt.Fatalf(\"canceled client %v did not quit\", i)\n\t\t\t}\n\n\t\t// The next third should receive all updates.\n\t\tcase i < numClients*2/3:\n\t\t\tfrom = 0\n\t\t\tto = numUpdates\n\n\t\t// And finally the last third should receive the last half of\n\t\t// the updates.\n\t\tdefault:\n\t\t\tfrom = numUpdates / 2\n\t\t\tto = numUpdates\n\t\t}\n\n\t\tfor cnt := from; cnt < to; cnt++ {\n\t\t\tselect {\n\t\t\tcase upd := <-c.Updates():\n\t\t\t\tj := upd.(int)\n\t\t\t\tif j != cnt {\n\t\t\t\t\tt.Fatalf(\"expected %v, got %v, for \"+\n\t\t\t\t\t\t\"client %v\", cnt, j, i)\n\t\t\t\t}\n\n\t\t\tcase <-time.After(1 * time.Second):\n\t\t\t\tt.Fatalf(\"did not receive expected update %v \"+\n\t\t\t\t\t\"for client %v\", cnt, i)\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n",
      "length": 1921,
      "tokens": 339,
      "embedding": []
    }
  ]
}