{
  "filepath": "../implementations/go/lnd/lnd.go",
  "package": "lnd",
  "sections": [
    {
      "slug": "func AdminAuthOptions(cfg *Config, skipMacaroons bool) ([]grpc.DialOption,",
      "content": "func AdminAuthOptions(cfg *Config, skipMacaroons bool) ([]grpc.DialOption,\n\terror) {\n\n\tcreds, err := credentials.NewClientTLSFromFile(cfg.TLSCertPath, \"\")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to read TLS cert: %v\", err)\n\t}\n\n\t// Create a dial options array.\n\topts := []grpc.DialOption{\n\t\tgrpc.WithTransportCredentials(creds),\n\t}\n\n\t// Get the admin macaroon if macaroons are active.\n\tif !skipMacaroons && !cfg.NoMacaroons {\n\t\t// Load the admin macaroon file.\n\t\tmacBytes, err := ioutil.ReadFile(cfg.AdminMacPath)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to read macaroon \"+\n\t\t\t\t\"path (check the network setting!): %v\", err)\n\t\t}\n\n\t\tmac := &macaroon.Macaroon{}\n\t\tif err = mac.UnmarshalBinary(macBytes); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to decode macaroon: %v\",\n\t\t\t\terr)\n\t\t}\n\n\t\t// Now we append the macaroon credentials to the dial options.\n\t\tcred, err := macaroons.NewMacaroonCredential(mac)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"error cloning mac: %v\", err)\n\t\t}\n\t\topts = append(opts, grpc.WithPerRPCCredentials(cred))\n\t}\n\n\treturn opts, nil\n}\n\n// ListenerWithSignal is a net.Listener that has an additional Ready channel\n// that will be closed when a server starts listening.",
      "length": 1101,
      "tokens": 155,
      "embedding": []
    },
    {
      "slug": "type ListenerWithSignal struct {",
      "content": "type ListenerWithSignal struct {\n\tnet.Listener\n\n\t// Ready will be closed by the server listening on Listener.\n\tReady chan struct{}\n\n\t// MacChan is an optional way to pass the admin macaroon to the program\n\t// that started lnd. The channel should be buffered to avoid lnd being\n\t// blocked on sending to the channel.\n\tMacChan chan []byte\n}\n\n// ListenerCfg is a wrapper around custom listeners that can be passed to lnd\n// when calling its main method.",
      "length": 405,
      "tokens": 73,
      "embedding": []
    },
    {
      "slug": "type ListenerCfg struct {",
      "content": "type ListenerCfg struct {\n\t// RPCListeners can be set to the listeners to use for the RPC server.\n\t// If empty a regular network listener will be created.\n\tRPCListeners []*ListenerWithSignal\n}\n\nvar errStreamIsolationWithProxySkip = errors.New(\n\t\"while stream isolation is enabled, the TOR proxy may not be skipped\",\n)\n\n// Main is the true entry point for lnd. It accepts a fully populated and\n// validated main configuration struct and an optional listener config struct.\n// This function starts all main system components then blocks until a signal\n// is received on the shutdownChan at which point everything is shut down again.",
      "length": 592,
      "tokens": 97,
      "embedding": []
    },
    {
      "slug": "func Main(cfg *Config, lisCfg ListenerCfg, implCfg *ImplementationCfg,",
      "content": "func Main(cfg *Config, lisCfg ListenerCfg, implCfg *ImplementationCfg,\n\tinterceptor signal.Interceptor) error {\n\n\tdefer func() {\n\t\tltndLog.Info(\"Shutdown complete\\n\")\n\t\terr := cfg.LogWriter.Close()\n\t\tif err != nil {\n\t\t\tltndLog.Errorf(\"Could not close log rotator: %v\", err)\n\t\t}\n\t}()\n\n\tmkErr := func(format string, args ...interface{}) error {\n\t\tltndLog.Errorf(\"Shutting down because error in main \"+\n\t\t\t\"method: \"+format, args...)\n\t\treturn fmt.Errorf(format, args...)\n\t}\n\n\t// Show version at startup.\n\tltndLog.Infof(\"Version: %s commit=%s, build=%s, logging=%s, \"+\n\t\t\"debuglevel=%s\", build.Version(), build.Commit,\n\t\tbuild.Deployment, build.LoggingType, cfg.DebugLevel)\n\n\tvar network string\n\tswitch {\n\tcase cfg.Bitcoin.TestNet3 || cfg.Litecoin.TestNet3:\n\t\tnetwork = \"testnet\"\n\n\tcase cfg.Bitcoin.MainNet || cfg.Litecoin.MainNet:\n\t\tnetwork = \"mainnet\"\n\n\tcase cfg.Bitcoin.SimNet || cfg.Litecoin.SimNet:\n\t\tnetwork = \"simnet\"\n\n\tcase cfg.Bitcoin.RegTest || cfg.Litecoin.RegTest:\n\t\tnetwork = \"regtest\"\n\n\tcase cfg.Bitcoin.SigNet:\n\t\tnetwork = \"signet\"\n\t}\n\n\tltndLog.Infof(\"Active chain: %v (network=%v)\",\n\t\tstrings.Title(cfg.registeredChains.PrimaryChain().String()),\n\t\tnetwork,\n\t)\n\n\t// Enable http profiling server if requested.\n\tif cfg.Profile != \"\" {\n\t\tgo func() {\n\t\t\tprofileRedirect := http.RedirectHandler(\"/debug/pprof\",\n\t\t\t\thttp.StatusSeeOther)\n\t\t\thttp.Handle(\"/\", profileRedirect)\n\t\t\tltndLog.Infof(\"Pprof listening on %v\", cfg.Profile)\n\t\t\tfmt.Println(http.ListenAndServe(cfg.Profile, nil))\n\t\t}()\n\t}\n\n\t// Write cpu profile if requested.\n\tif cfg.CPUProfile != \"\" {\n\t\tf, err := os.Create(cfg.CPUProfile)\n\t\tif err != nil {\n\t\t\treturn mkErr(\"unable to create CPU profile: %v\", err)\n\t\t}\n\t\tpprof.StartCPUProfile(f)\n\t\tdefer f.Close()\n\t\tdefer pprof.StopCPUProfile()\n\t}\n\n\tctx := context.Background()\n\tctx, cancel := context.WithCancel(ctx)\n\tdefer cancel()\n\n\t// Run configuration dependent DB pre-initialization. Note that this\n\t// needs to be done early and once during the startup process, before\n\t// any DB access.\n\tif err := cfg.DB.Init(ctx, cfg.graphDatabaseDir()); err != nil {\n\t\treturn mkErr(\"error initializing DBs: %v\", err)\n\t}\n\n\ttlsManagerCfg := &TLSManagerCfg{\n\t\tTLSCertPath:        cfg.TLSCertPath,\n\t\tTLSKeyPath:         cfg.TLSKeyPath,\n\t\tTLSEncryptKey:      cfg.TLSEncryptKey,\n\t\tTLSExtraIPs:        cfg.TLSExtraIPs,\n\t\tTLSExtraDomains:    cfg.TLSExtraDomains,\n\t\tTLSAutoRefresh:     cfg.TLSAutoRefresh,\n\t\tTLSDisableAutofill: cfg.TLSDisableAutofill,\n\t\tTLSCertDuration:    cfg.TLSCertDuration,\n\n\t\tLetsEncryptDir:    cfg.LetsEncryptDir,\n\t\tLetsEncryptDomain: cfg.LetsEncryptDomain,\n\t\tLetsEncryptListen: cfg.LetsEncryptListen,\n\n\t\tDisableRestTLS: cfg.DisableRestTLS,\n\t}\n\ttlsManager := NewTLSManager(tlsManagerCfg)\n\tserverOpts, restDialOpts, restListen, cleanUp,\n\t\terr := tlsManager.SetCertificateBeforeUnlock()\n\tif err != nil {\n\t\treturn mkErr(\"error setting cert before unlock: %v\", err)\n\t}\n\tif cleanUp != nil {\n\t\tdefer cleanUp()\n\t}\n\n\t// If we have chosen to start with a dedicated listener for the\n\t// rpc server, we set it directly.\n\tgrpcListeners := append([]*ListenerWithSignal{}, lisCfg.RPCListeners...)\n\tif len(grpcListeners) == 0 {\n\t\t// Otherwise we create listeners from the RPCListeners defined\n\t\t// in the config.\n\t\tfor _, grpcEndpoint := range cfg.RPCListeners {\n\t\t\t// Start a gRPC server listening for HTTP/2\n\t\t\t// connections.\n\t\t\tlis, err := lncfg.ListenOnAddress(grpcEndpoint)\n\t\t\tif err != nil {\n\t\t\t\treturn mkErr(\"unable to listen on %s: %v\",\n\t\t\t\t\tgrpcEndpoint, err)\n\t\t\t}\n\t\t\tdefer lis.Close()\n\n\t\t\tgrpcListeners = append(\n\t\t\t\tgrpcListeners, &ListenerWithSignal{\n\t\t\t\t\tListener: lis,\n\t\t\t\t\tReady:    make(chan struct{}),\n\t\t\t\t},\n\t\t\t)\n\t\t}\n\t}\n\n\t// Create a new RPC interceptor that we'll add to the GRPC server. This\n\t// will be used to log the API calls invoked on the GRPC server.\n\tinterceptorChain := rpcperms.NewInterceptorChain(\n\t\trpcsLog, cfg.NoMacaroons, cfg.RPCMiddleware.Mandatory,\n\t)\n\tif err := interceptorChain.Start(); err != nil {\n\t\treturn mkErr(\"error starting interceptor chain: %v\", err)\n\t}\n\tdefer func() {\n\t\terr := interceptorChain.Stop()\n\t\tif err != nil {\n\t\t\tltndLog.Warnf(\"error stopping RPC interceptor \"+\n\t\t\t\t\"chain: %v\", err)\n\t\t}\n\t}()\n\n\trpcServerOpts := interceptorChain.CreateServerOpts()\n\tserverOpts = append(serverOpts, rpcServerOpts...)\n\tserverOpts = append(\n\t\tserverOpts, grpc.MaxRecvMsgSize(lnrpc.MaxGrpcMsgSize),\n\t)\n\n\tgrpcServer := grpc.NewServer(serverOpts...)\n\tdefer grpcServer.Stop()\n\n\t// We'll also register the RPC interceptor chain as the StateServer, as\n\t// it can be used to query for the current state of the wallet.\n\tlnrpc.RegisterStateServer(grpcServer, interceptorChain)\n\n\t// Initialize, and register our implementation of the gRPC interface\n\t// exported by the rpcServer.\n\trpcServer := newRPCServer(cfg, interceptorChain, implCfg, interceptor)\n\terr = rpcServer.RegisterWithGrpcServer(grpcServer)\n\tif err != nil {\n\t\treturn mkErr(\"error registering gRPC server: %v\", err)\n\t}\n\n\t// Now that both the WalletUnlocker and LightningService have been\n\t// registered with the GRPC server, we can start listening.\n\terr = startGrpcListen(cfg, grpcServer, grpcListeners)\n\tif err != nil {\n\t\treturn mkErr(\"error starting gRPC listener: %v\", err)\n\t}\n\n\t// Now start the REST proxy for our gRPC server above. We'll ensure\n\t// we direct LND to connect to its loopback address rather than a\n\t// wildcard to prevent certificate issues when accessing the proxy\n\t// externally.\n\tstopProxy, err := startRestProxy(\n\t\tcfg, rpcServer, restDialOpts, restListen,\n\t)\n\tif err != nil {\n\t\treturn mkErr(\"error starting REST proxy: %v\", err)\n\t}\n\tdefer stopProxy()\n\n\t// Start leader election if we're running on etcd. Continuation will be\n\t// blocked until this instance is elected as the current leader or\n\t// shutting down.\n\telected := false\n\tif cfg.Cluster.EnableLeaderElection {\n\t\telectionCtx, cancelElection := context.WithCancel(ctx)\n\n\t\tgo func() {\n\t\t\t<-interceptor.ShutdownChannel()\n\t\t\tcancelElection()\n\t\t}()\n\n\t\tltndLog.Infof(\"Using %v leader elector\",\n\t\t\tcfg.Cluster.LeaderElector)\n\n\t\tleaderElector, err := cfg.Cluster.MakeLeaderElector(\n\t\t\telectionCtx, cfg.DB,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tdefer func() {\n\t\t\tif !elected {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tltndLog.Infof(\"Attempting to resign from leader role \"+\n\t\t\t\t\"(%v)\", cfg.Cluster.ID)\n\n\t\t\tif err := leaderElector.Resign(); err != nil {\n\t\t\t\tltndLog.Errorf(\"Leader elector failed to \"+\n\t\t\t\t\t\"resign: %v\", err)\n\t\t\t}\n\t\t}()\n\n\t\tltndLog.Infof(\"Starting leadership campaign (%v)\",\n\t\t\tcfg.Cluster.ID)\n\n\t\tif err := leaderElector.Campaign(electionCtx); err != nil {\n\t\t\treturn mkErr(\"leadership campaign failed: %v\", err)\n\t\t}\n\n\t\telected = true\n\t\tltndLog.Infof(\"Elected as leader (%v)\", cfg.Cluster.ID)\n\t}\n\n\tdbs, cleanUp, err := implCfg.DatabaseBuilder.BuildDatabase(ctx)\n\tswitch {\n\tcase err == channeldb.ErrDryRunMigrationOK:\n\t\tltndLog.Infof(\"%v, exiting\", err)\n\t\treturn nil\n\tcase err != nil:\n\t\treturn mkErr(\"unable to open databases: %v\", err)\n\t}\n\n\tdefer cleanUp()\n\n\tpartialChainControl, walletConfig, cleanUp, err := implCfg.BuildWalletConfig(\n\t\tctx, dbs, interceptorChain, grpcListeners,\n\t)\n\tif err != nil {\n\t\treturn mkErr(\"error creating wallet config: %v\", err)\n\t}\n\n\tdefer cleanUp()\n\n\tactiveChainControl, cleanUp, err := implCfg.BuildChainControl(\n\t\tpartialChainControl, walletConfig,\n\t)\n\tif err != nil {\n\t\treturn mkErr(\"error loading chain control: %v\", err)\n\t}\n\n\tdefer cleanUp()\n\n\t// Finally before we start the server, we'll register the \"holy\n\t// trinity\" of interface for our current \"home chain\" with the active\n\t// chainRegistry interface.\n\tprimaryChain := cfg.registeredChains.PrimaryChain()\n\tcfg.registeredChains.RegisterChain(primaryChain, activeChainControl)\n\n\t// TODO(roasbeef): add rotation\n\tidKeyDesc, err := activeChainControl.KeyRing.DeriveKey(\n\t\tkeychain.KeyLocator{\n\t\t\tFamily: keychain.KeyFamilyNodeKey,\n\t\t\tIndex:  0,\n\t\t},\n\t)\n\tif err != nil {\n\t\treturn mkErr(\"error deriving node key: %v\", err)\n\t}\n\n\tif cfg.Tor.StreamIsolation && cfg.Tor.SkipProxyForClearNetTargets {\n\t\treturn errStreamIsolationWithProxySkip\n\t}\n\n\tif cfg.Tor.Active {\n\t\tif cfg.Tor.SkipProxyForClearNetTargets {\n\t\t\tsrvrLog.Info(\"Onion services are accessible via Tor! \" +\n\t\t\t\t\"NOTE: Traffic to clearnet services is not \" +\n\t\t\t\t\"routed via Tor.\")\n\t\t} else {\n\t\t\tsrvrLog.Infof(\"Proxying all network traffic via Tor \"+\n\t\t\t\t\"(stream_isolation=%v)! NOTE: Ensure the \"+\n\t\t\t\t\"backend node is proxying over Tor as well\",\n\t\t\t\tcfg.Tor.StreamIsolation)\n\t\t}\n\t}\n\n\t// If tor is active and either v2 or v3 onion services have been\n\t// specified, make a tor controller and pass it into both the watchtower\n\t// server and the regular lnd server.\n\tvar torController *tor.Controller\n\tif cfg.Tor.Active && (cfg.Tor.V2 || cfg.Tor.V3) {\n\t\ttorController = tor.NewController(\n\t\t\tcfg.Tor.Control, cfg.Tor.TargetIPAddress,\n\t\t\tcfg.Tor.Password,\n\t\t)\n\n\t\t// Start the tor controller before giving it to any other\n\t\t// subsystems.\n\t\tif err := torController.Start(); err != nil {\n\t\t\treturn mkErr(\"unable to initialize tor controller: %v\",\n\t\t\t\terr)\n\t\t}\n\t\tdefer func() {\n\t\t\tif err := torController.Stop(); err != nil {\n\t\t\t\tltndLog.Errorf(\"error stopping tor \"+\n\t\t\t\t\t\"controller: %v\", err)\n\t\t\t}\n\t\t}()\n\t}\n\n\tvar tower *watchtower.Standalone\n\tif cfg.Watchtower.Active {\n\t\ttowerKeyDesc, err := activeChainControl.KeyRing.DeriveKey(\n\t\t\tkeychain.KeyLocator{\n\t\t\t\tFamily: keychain.KeyFamilyTowerID,\n\t\t\t\tIndex:  0,\n\t\t\t},\n\t\t)\n\t\tif err != nil {\n\t\t\treturn mkErr(\"error deriving tower key: %v\", err)\n\t\t}\n\n\t\twtCfg := &watchtower.Config{\n\t\t\tBlockFetcher:   activeChainControl.ChainIO,\n\t\t\tDB:             dbs.TowerServerDB,\n\t\t\tEpochRegistrar: activeChainControl.ChainNotifier,\n\t\t\tNet:            cfg.net,\n\t\t\tNewAddress: func() (btcutil.Address, error) {\n\t\t\t\treturn activeChainControl.Wallet.NewAddress(\n\t\t\t\t\tlnwallet.TaprootPubkey, false,\n\t\t\t\t\tlnwallet.DefaultAccountName,\n\t\t\t\t)\n\t\t\t},\n\t\t\tNodeKeyECDH: keychain.NewPubKeyECDH(\n\t\t\t\ttowerKeyDesc, activeChainControl.KeyRing,\n\t\t\t),\n\t\t\tPublishTx: activeChainControl.Wallet.PublishTransaction,\n\t\t\tChainHash: *cfg.ActiveNetParams.GenesisHash,\n\t\t}\n\n\t\t// If there is a tor controller (user wants auto hidden\n\t\t// services), then store a pointer in the watchtower config.\n\t\tif torController != nil {\n\t\t\twtCfg.TorController = torController\n\t\t\twtCfg.WatchtowerKeyPath = cfg.Tor.WatchtowerKeyPath\n\t\t\twtCfg.EncryptKey = cfg.Tor.EncryptKey\n\t\t\twtCfg.KeyRing = activeChainControl.KeyRing\n\n\t\t\tswitch {\n\t\t\tcase cfg.Tor.V2:\n\t\t\t\twtCfg.Type = tor.V2\n\t\t\tcase cfg.Tor.V3:\n\t\t\t\twtCfg.Type = tor.V3\n\t\t\t}\n\t\t}\n\n\t\twtConfig, err := cfg.Watchtower.Apply(\n\t\t\twtCfg, lncfg.NormalizeAddresses,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn mkErr(\"unable to configure watchtower: %v\", err)\n\t\t}\n\n\t\ttower, err = watchtower.New(wtConfig)\n\t\tif err != nil {\n\t\t\treturn mkErr(\"unable to create watchtower: %v\", err)\n\t\t}\n\t}\n\n\t// Initialize the MultiplexAcceptor. If lnd was started with the\n\t// zero-conf feature bit, then this will be a ZeroConfAcceptor.\n\t// Otherwise, this will be a ChainedAcceptor.\n\tvar multiAcceptor chanacceptor.MultiplexAcceptor\n\tif cfg.ProtocolOptions.ZeroConf() {\n\t\tmultiAcceptor = chanacceptor.NewZeroConfAcceptor()\n\t} else {\n\t\tmultiAcceptor = chanacceptor.NewChainedAcceptor()\n\t}\n\n\t// Set up the core server which will listen for incoming peer\n\t// connections.\n\tserver, err := newServer(\n\t\tcfg, cfg.Listeners, dbs, activeChainControl, &idKeyDesc,\n\t\tactiveChainControl.Cfg.WalletUnlockParams.ChansToRestore,\n\t\tmultiAcceptor, torController, tlsManager,\n\t)\n\tif err != nil {\n\t\treturn mkErr(\"unable to create server: %v\", err)\n\t}\n\n\t// Set up an autopilot manager from the current config. This will be\n\t// used to manage the underlying autopilot agent, starting and stopping\n\t// it at will.\n\tatplCfg, err := initAutoPilot(\n\t\tserver, cfg.Autopilot, activeChainControl.MinHtlcIn,\n\t\tcfg.ActiveNetParams,\n\t)\n\tif err != nil {\n\t\treturn mkErr(\"unable to initialize autopilot: %v\", err)\n\t}\n\n\tatplManager, err := autopilot.NewManager(atplCfg)\n\tif err != nil {\n\t\treturn mkErr(\"unable to create autopilot manager: %v\", err)\n\t}\n\tif err := atplManager.Start(); err != nil {\n\t\treturn mkErr(\"unable to start autopilot manager: %v\", err)\n\t}\n\tdefer atplManager.Stop()\n\n\terr = tlsManager.LoadPermanentCertificate(activeChainControl.KeyRing)\n\tif err != nil {\n\t\treturn mkErr(\"unable to load permanent TLS certificate: %v\",\n\t\t\terr)\n\t}\n\n\t// Now we have created all dependencies necessary to populate and\n\t// start the RPC server.\n\terr = rpcServer.addDeps(\n\t\tserver, interceptorChain.MacaroonService(), cfg.SubRPCServers,\n\t\tatplManager, server.invoices, tower, multiAcceptor,\n\t)\n\tif err != nil {\n\t\treturn mkErr(\"unable to add deps to RPC server: %v\", err)\n\t}\n\tif err := rpcServer.Start(); err != nil {\n\t\treturn mkErr(\"unable to start RPC server: %v\", err)\n\t}\n\tdefer rpcServer.Stop()\n\n\t// We transition the RPC state to Active, as the RPC server is up.\n\tinterceptorChain.SetRPCActive()\n\n\tif err := interceptor.Notifier.NotifyReady(true); err != nil {\n\t\treturn mkErr(\"error notifying ready: %v\", err)\n\t}\n\n\t// We'll wait until we're fully synced to continue the start up of the\n\t// remainder of the daemon. This ensures that we don't accept any\n\t// possibly invalid state transitions, or accept channels with spent\n\t// funds.\n\t_, bestHeight, err := activeChainControl.ChainIO.GetBestBlock()\n\tif err != nil {\n\t\treturn mkErr(\"unable to determine chain tip: %v\", err)\n\t}\n\n\tltndLog.Infof(\"Waiting for chain backend to finish sync, \"+\n\t\t\"start_height=%v\", bestHeight)\n\n\tfor {\n\t\tif !interceptor.Alive() {\n\t\t\treturn nil\n\t\t}\n\n\t\tsynced, _, err := activeChainControl.Wallet.IsSynced()\n\t\tif err != nil {\n\t\t\treturn mkErr(\"unable to determine if wallet is \"+\n\t\t\t\t\"synced: %v\", err)\n\t\t}\n\n\t\tif synced {\n\t\t\tbreak\n\t\t}\n\n\t\ttime.Sleep(time.Second * 1)\n\t}\n\n\t_, bestHeight, err = activeChainControl.ChainIO.GetBestBlock()\n\tif err != nil {\n\t\treturn mkErr(\"unable to determine chain tip: %v\", err)\n\t}\n\n\tltndLog.Infof(\"Chain backend is fully synced (end_height=%v)!\",\n\t\tbestHeight)\n\n\t// With all the relevant chains initialized, we can finally start the\n\t// server itself.\n\tif err := server.Start(); err != nil {\n\t\treturn mkErr(\"unable to start server: %v\", err)\n\t}\n\tdefer server.Stop()\n\n\t// We transition the server state to Active, as the server is up.\n\tinterceptorChain.SetServerActive()\n\n\t// Now that the server has started, if the autopilot mode is currently\n\t// active, then we'll start the autopilot agent immediately. It will be\n\t// stopped together with the autopilot service.\n\tif cfg.Autopilot.Active {\n\t\tif err := atplManager.StartAgent(); err != nil {\n\t\t\treturn mkErr(\"unable to start autopilot agent: %v\", err)\n\t\t}\n\t}\n\n\tif cfg.Watchtower.Active {\n\t\tif err := tower.Start(); err != nil {\n\t\t\treturn mkErr(\"unable to start watchtower: %v\", err)\n\t\t}\n\t\tdefer tower.Stop()\n\t}\n\n\t// Wait for shutdown signal from either a graceful server stop or from\n\t// the interrupt handler.\n\t<-interceptor.ShutdownChannel()\n\treturn nil\n}\n\n// bakeMacaroon creates a new macaroon with newest version and the given\n// permissions then returns it binary serialized.",
      "length": 14319,
      "tokens": 1791,
      "embedding": []
    },
    {
      "slug": "func bakeMacaroon(ctx context.Context, svc *macaroons.Service,",
      "content": "func bakeMacaroon(ctx context.Context, svc *macaroons.Service,\n\tpermissions []bakery.Op) ([]byte, error) {\n\n\tmac, err := svc.NewMacaroon(\n\t\tctx, macaroons.DefaultRootKeyID, permissions...,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn mac.M().MarshalBinary()\n}\n\n// genMacaroons generates three macaroon files; one admin-level, one for\n// invoice access and one read-only. These can also be used to generate more\n// granular macaroons.",
      "length": 361,
      "tokens": 52,
      "embedding": []
    },
    {
      "slug": "func genMacaroons(ctx context.Context, svc *macaroons.Service,",
      "content": "func genMacaroons(ctx context.Context, svc *macaroons.Service,\n\tadmFile, roFile, invoiceFile string) error {\n\n\t// First, we'll generate a macaroon that only allows the caller to\n\t// access invoice related calls. This is useful for merchants and other\n\t// services to allow an isolated instance that can only query and\n\t// modify invoices.\n\tinvoiceMacBytes, err := bakeMacaroon(ctx, svc, invoicePermissions)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = ioutil.WriteFile(invoiceFile, invoiceMacBytes, 0644)\n\tif err != nil {\n\t\t_ = os.Remove(invoiceFile)\n\t\treturn err\n\t}\n\n\t// Generate the read-only macaroon and write it to a file.\n\troBytes, err := bakeMacaroon(ctx, svc, readPermissions)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err = ioutil.WriteFile(roFile, roBytes, 0644); err != nil {\n\t\t_ = os.Remove(roFile)\n\t\treturn err\n\t}\n\n\t// Generate the admin macaroon and write it to a file.\n\tadmBytes, err := bakeMacaroon(ctx, svc, adminPermissions())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = ioutil.WriteFile(admFile, admBytes, adminMacaroonFilePermissions)\n\tif err != nil {\n\t\t_ = os.Remove(admFile)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// adminPermissions returns a list of all permissions in a safe way that doesn't\n// modify any of the source lists.",
      "length": 1126,
      "tokens": 181,
      "embedding": []
    },
    {
      "slug": "func adminPermissions() []bakery.Op {",
      "content": "func adminPermissions() []bakery.Op {\n\tadmin := make([]bakery.Op, len(readPermissions)+len(writePermissions))\n\tcopy(admin[:len(readPermissions)], readPermissions)\n\tcopy(admin[len(readPermissions):], writePermissions)\n\treturn admin\n}\n\n// createWalletUnlockerService creates a WalletUnlockerService from the passed\n// config.",
      "length": 278,
      "tokens": 21,
      "embedding": []
    },
    {
      "slug": "func createWalletUnlockerService(cfg *Config) *walletunlocker.UnlockerService {",
      "content": "func createWalletUnlockerService(cfg *Config) *walletunlocker.UnlockerService {\n\t// The macaroonFiles are passed to the wallet unlocker so they can be\n\t// deleted and recreated in case the root macaroon key is also changed\n\t// during the change password operation.\n\tmacaroonFiles := []string{\n\t\tcfg.AdminMacPath, cfg.ReadMacPath, cfg.InvoiceMacPath,\n\t}\n\n\treturn walletunlocker.New(\n\t\tcfg.ActiveNetParams.Params, macaroonFiles,\n\t\tcfg.ResetWalletTransactions, nil,\n\t)\n}\n\n// startGrpcListen starts the GRPC server on the passed listeners.",
      "length": 442,
      "tokens": 57,
      "embedding": []
    },
    {
      "slug": "func startGrpcListen(cfg *Config, grpcServer *grpc.Server,",
      "content": "func startGrpcListen(cfg *Config, grpcServer *grpc.Server,\n\tlisteners []*ListenerWithSignal) error {\n\n\t// Use a WaitGroup so we can be sure the instructions on how to input the\n\t// password is the last thing to be printed to the console.\n\tvar wg sync.WaitGroup\n\n\tfor _, lis := range listeners {\n\t\twg.Add(1)\n\t\tgo func(lis *ListenerWithSignal) {\n\t\t\trpcsLog.Infof(\"RPC server listening on %s\", lis.Addr())\n\n\t\t\t// Close the ready chan to indicate we are listening.\n\t\t\tclose(lis.Ready)\n\n\t\t\twg.Done()\n\t\t\t_ = grpcServer.Serve(lis)\n\t\t}(lis)\n\t}\n\n\t// If Prometheus monitoring is enabled, start the Prometheus exporter.\n\tif cfg.Prometheus.Enabled() {\n\t\terr := monitoring.ExportPrometheusMetrics(\n\t\t\tgrpcServer, cfg.Prometheus,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Wait for gRPC servers to be up running.\n\twg.Wait()\n\n\treturn nil\n}\n\n// startRestProxy starts the given REST proxy on the listeners found in the\n// config.",
      "length": 822,
      "tokens": 126,
      "embedding": []
    },
    {
      "slug": "func startRestProxy(cfg *Config, rpcServer *rpcServer, restDialOpts []grpc.DialOption,",
      "content": "func startRestProxy(cfg *Config, rpcServer *rpcServer, restDialOpts []grpc.DialOption,\n\trestListen func(net.Addr) (net.Listener, error)) (func(), error) {\n\n\t// We use the first RPC listener as the destination for our REST proxy.\n\t// If the listener is set to listen on all interfaces, we replace it\n\t// with localhost, as we cannot dial it directly.\n\trestProxyDest := cfg.RPCListeners[0].String()\n\tswitch {\n\tcase strings.Contains(restProxyDest, \"0.0.0.0\"):\n\t\trestProxyDest = strings.Replace(\n\t\t\trestProxyDest, \"0.0.0.0\", \"127.0.0.1\", 1,\n\t\t)\n\n\tcase strings.Contains(restProxyDest, \"[::]\"):\n\t\trestProxyDest = strings.Replace(\n\t\t\trestProxyDest, \"[::]\", \"[::1]\", 1,\n\t\t)\n\t}\n\n\tvar shutdownFuncs []func()\n\tshutdown := func() {\n\t\tfor _, shutdownFn := range shutdownFuncs {\n\t\t\tshutdownFn()\n\t\t}\n\t}\n\n\t// Start a REST proxy for our gRPC server.\n\tctx := context.Background()\n\tctx, cancel := context.WithCancel(ctx)\n\tshutdownFuncs = append(shutdownFuncs, cancel)\n\n\t// We'll set up a proxy that will forward REST calls to the GRPC\n\t// server.\n\t//\n\t// The default JSON marshaler of the REST proxy only sets OrigName to\n\t// true, which instructs it to use the same field names as specified in\n\t// the proto file and not switch to camel case. What we also want is\n\t// that the marshaler prints all values, even if they are falsey.\n\tcustomMarshalerOption := proxy.WithMarshalerOption(\n\t\tproxy.MIMEWildcard, &proxy.JSONPb{\n\t\t\tMarshalOptions: protojson.MarshalOptions{\n\t\t\t\tUseProtoNames:   true,\n\t\t\t\tEmitUnpopulated: true,\n\t\t\t},\n\t\t},\n\t)\n\tmux := proxy.NewServeMux(\n\t\tcustomMarshalerOption,\n\n\t\t// Don't allow falling back to other HTTP methods, we want exact\n\t\t// matches only. The actual method to be used can be overwritten\n\t\t// by setting X-HTTP-Method-Override so there should be no\n\t\t// reason for not specifying the correct method in the first\n\t\t// place.\n\t\tproxy.WithDisablePathLengthFallback(),\n\t)\n\n\t// Register our services with the REST proxy.\n\terr := lnrpc.RegisterStateHandlerFromEndpoint(\n\t\tctx, mux, restProxyDest, restDialOpts,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = rpcServer.RegisterWithRestProxy(\n\t\tctx, mux, restDialOpts, restProxyDest,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Wrap the default grpc-gateway handler with the WebSocket handler.\n\trestHandler := lnrpc.NewWebSocketProxy(\n\t\tmux, rpcsLog, cfg.WSPingInterval, cfg.WSPongWait,\n\t\tlnrpc.LndClientStreamingURIs,\n\t)\n\n\t// Use a WaitGroup so we can be sure the instructions on how to input the\n\t// password is the last thing to be printed to the console.\n\tvar wg sync.WaitGroup\n\n\t// Now spin up a network listener for each requested port and start a\n\t// goroutine that serves REST with the created mux there.\n\tfor _, restEndpoint := range cfg.RESTListeners {\n\t\tlis, err := restListen(restEndpoint)\n\t\tif err != nil {\n\t\t\tltndLog.Errorf(\"gRPC proxy unable to listen on %s\",\n\t\t\t\trestEndpoint)\n\t\t\treturn nil, err\n\t\t}\n\n\t\tshutdownFuncs = append(shutdownFuncs, func() {\n\t\t\terr := lis.Close()\n\t\t\tif err != nil {\n\t\t\t\trpcsLog.Errorf(\"Error closing listener: %v\",\n\t\t\t\t\terr)\n\t\t\t}\n\t\t})\n\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\trpcsLog.Infof(\"gRPC proxy started at %s\", lis.Addr())\n\n\t\t\t// Create our proxy chain now. A request will pass\n\t\t\t// through the following chain:\n\t\t\t// req ---> CORS handler --> WS proxy --->\n\t\t\t//   REST proxy --> gRPC endpoint\n\t\t\tcorsHandler := allowCORS(restHandler, cfg.RestCORS)\n\n\t\t\twg.Done()\n\t\t\terr := http.Serve(lis, corsHandler)\n\t\t\tif err != nil && !lnrpc.IsClosedConnError(err) {\n\t\t\t\trpcsLog.Error(err)\n\t\t\t}\n\t\t}()\n\t}\n\n\t// Wait for REST servers to be up running.\n\twg.Wait()\n\n\treturn shutdown, nil\n}\n",
      "length": 3363,
      "tokens": 484,
      "embedding": []
    }
  ]
}