{
  "filepath": "../implementations/go/lnd/chanacceptor/merge_test.go",
  "package": "chanacceptor",
  "sections": [
    {
      "slug": "func TestMergeResponse(t *testing.T) {",
      "content": "func TestMergeResponse(t *testing.T) {\n\tvar (\n\t\taddr1 = lnwire.DeliveryAddress{1}\n\t\taddr2 = lnwire.DeliveryAddress{2}\n\n\t\tpopulatedResp = ChannelAcceptResponse{\n\t\t\tUpfrontShutdown: addr1,\n\t\t\tCSVDelay:        2,\n\t\t\tReserve:         3,\n\t\t\tInFlightTotal:   4,\n\t\t\tHtlcLimit:       5,\n\t\t\tMinHtlcIn:       6,\n\t\t\tMinAcceptDepth:  7,\n\t\t}\n\t)\n\n\ttests := []struct {\n\t\tname    string\n\t\tcurrent ChannelAcceptResponse\n\t\tnew     ChannelAcceptResponse\n\t\tmerged  ChannelAcceptResponse\n\t\terr     error\n\t}{\n\t\t{\n\t\t\tname:    \"same response\",\n\t\t\tcurrent: populatedResp,\n\t\t\tnew:     populatedResp,\n\t\t\tmerged:  populatedResp,\n\t\t\terr:     nil,\n\t\t},\n\t\t{\n\t\t\tname: \"different upfront\",\n\t\t\tcurrent: ChannelAcceptResponse{\n\t\t\t\tUpfrontShutdown: addr1,\n\t\t\t},\n\t\t\tnew: ChannelAcceptResponse{\n\t\t\t\tUpfrontShutdown: addr2,\n\t\t\t},\n\t\t\terr: fieldMismatchError(fieldUpfrontShutdown, addr1, addr2),\n\t\t},\n\t\t{\n\t\t\tname: \"different csv\",\n\t\t\tcurrent: ChannelAcceptResponse{\n\t\t\t\tCSVDelay: 1,\n\t\t\t},\n\t\t\tnew: ChannelAcceptResponse{\n\t\t\t\tCSVDelay: 2,\n\t\t\t},\n\t\t\terr: fieldMismatchError(fieldCSV, 1, 2),\n\t\t},\n\t\t{\n\t\t\tname: \"different reserve\",\n\t\t\tcurrent: ChannelAcceptResponse{\n\t\t\t\tReserve: 1,\n\t\t\t},\n\t\t\tnew: ChannelAcceptResponse{\n\t\t\t\tReserve: 2,\n\t\t\t},\n\t\t\terr: fieldMismatchError(fieldReserve, 1, 2),\n\t\t},\n\t\t{\n\t\t\tname: \"different in flight\",\n\t\t\tcurrent: ChannelAcceptResponse{\n\t\t\t\tInFlightTotal: 1,\n\t\t\t},\n\t\t\tnew: ChannelAcceptResponse{\n\t\t\t\tInFlightTotal: 2,\n\t\t\t},\n\t\t\terr: fieldMismatchError(\n\t\t\t\tfieldInFlightTotal, lnwire.MilliSatoshi(1),\n\t\t\t\tlnwire.MilliSatoshi(2),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname: \"different htlc limit\",\n\t\t\tcurrent: ChannelAcceptResponse{\n\t\t\t\tHtlcLimit: 1,\n\t\t\t},\n\t\t\tnew: ChannelAcceptResponse{\n\t\t\t\tHtlcLimit: 2,\n\t\t\t},\n\t\t\terr: fieldMismatchError(fieldHtlcLimit, 1, 2),\n\t\t},\n\t\t{\n\t\t\tname: \"different min in\",\n\t\t\tcurrent: ChannelAcceptResponse{\n\t\t\t\tMinHtlcIn: 1,\n\t\t\t},\n\t\t\tnew: ChannelAcceptResponse{\n\t\t\t\tMinHtlcIn: 2,\n\t\t\t},\n\t\t\terr: fieldMismatchError(\n\t\t\t\tfieldMinIn, lnwire.MilliSatoshi(1),\n\t\t\t\tlnwire.MilliSatoshi(2),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname: \"different depth\",\n\t\t\tcurrent: ChannelAcceptResponse{\n\t\t\t\tMinAcceptDepth: 1,\n\t\t\t},\n\t\t\tnew: ChannelAcceptResponse{\n\t\t\t\tMinAcceptDepth: 2,\n\t\t\t},\n\t\t\terr: fieldMismatchError(fieldMinDep, 1, 2),\n\t\t},\n\t\t{\n\t\t\tname: \"merge all values\",\n\t\t\tcurrent: ChannelAcceptResponse{\n\t\t\t\tUpfrontShutdown: lnwire.DeliveryAddress{1},\n\t\t\t\tCSVDelay:        1,\n\t\t\t\tReserve:         0,\n\t\t\t\tInFlightTotal:   3,\n\t\t\t\tHtlcLimit:       0,\n\t\t\t\tMinHtlcIn:       5,\n\t\t\t\tMinAcceptDepth:  0,\n\t\t\t},\n\t\t\tnew: ChannelAcceptResponse{\n\t\t\t\tUpfrontShutdown: nil,\n\t\t\t\tCSVDelay:        0,\n\t\t\t\tReserve:         2,\n\t\t\t\tInFlightTotal:   0,\n\t\t\t\tHtlcLimit:       4,\n\t\t\t\tMinHtlcIn:       0,\n\t\t\t\tMinAcceptDepth:  6,\n\t\t\t},\n\t\t\tmerged: ChannelAcceptResponse{\n\t\t\t\tUpfrontShutdown: lnwire.DeliveryAddress{1},\n\t\t\t\tCSVDelay:        1,\n\t\t\t\tReserve:         2,\n\t\t\t\tInFlightTotal:   3,\n\t\t\t\tHtlcLimit:       4,\n\t\t\t\tMinHtlcIn:       5,\n\t\t\t\tMinAcceptDepth:  6,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\t// Test the case where fields have the same non-zero\n\t\t\t// value, and the case where only response value is\n\t\t\t// non-zero.\n\t\t\tname: \"empty and identical\",\n\t\t\tcurrent: ChannelAcceptResponse{\n\t\t\t\tCSVDelay:      1,\n\t\t\t\tReserve:       2,\n\t\t\t\tInFlightTotal: 0,\n\t\t\t},\n\t\t\tnew: ChannelAcceptResponse{\n\t\t\t\tCSVDelay:      0,\n\t\t\t\tReserve:       2,\n\t\t\t\tInFlightTotal: 3,\n\t\t\t},\n\t\t\tmerged: ChannelAcceptResponse{\n\t\t\t\tCSVDelay:      1,\n\t\t\t\tReserve:       2,\n\t\t\t\tInFlightTotal: 3,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\t// Test the case where one response has ZeroConf set\n\t\t\t// and another has a non-zero min depth set.\n\t\t\tname: \"zero conf conflict\",\n\t\t\tcurrent: ChannelAcceptResponse{\n\t\t\t\tZeroConf: true,\n\t\t\t},\n\t\t\tnew: ChannelAcceptResponse{\n\t\t\t\tMinAcceptDepth: 5,\n\t\t\t},\n\t\t\terr: errZeroConf,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tresp, err := mergeResponse(test.current, test.new)\n\t\t\trequire.Equal(t, test.err, err)\n\n\t\t\t// If we expect an error, exit early rather than compare\n\t\t\t// our result.\n\t\t\tif test.err != nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\trequire.Equal(t, test.merged, resp)\n\t\t})\n\t}\n}\n",
      "length": 3815,
      "tokens": 398,
      "embedding": []
    }
  ]
}