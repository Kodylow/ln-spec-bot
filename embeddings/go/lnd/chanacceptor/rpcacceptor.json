{
  "filepath": "../implementations/go/lnd/chanacceptor/rpcacceptor.go",
  "package": "chanacceptor",
  "sections": [
    {
      "slug": "type chanAcceptInfo struct {",
      "content": "type chanAcceptInfo struct {\n\trequest  *ChannelAcceptRequest\n\tresponse chan *ChannelAcceptResponse\n}\n\n// RPCAcceptor represents the RPC-controlled variant of the ChannelAcceptor.\n// One RPCAcceptor allows one RPC client.",
      "length": 186,
      "tokens": 22,
      "embedding": []
    },
    {
      "slug": "type RPCAcceptor struct {",
      "content": "type RPCAcceptor struct {\n\t// receive is a function from which we receive channel acceptance\n\t// decisions. Note that this function is expected to block.\n\treceive func() (*lnrpc.ChannelAcceptResponse, error)\n\n\t// send is a function which sends requests for channel acceptance\n\t// decisions into our rpc stream.\n\tsend func(request *lnrpc.ChannelAcceptRequest) error\n\n\t// requests is a channel that we send requests for a acceptor response\n\t// into.\n\trequests chan *chanAcceptInfo\n\n\t// timeout is the amount of time we allow the channel acceptance\n\t// decision to take. This time includes the time to send a query to the\n\t// acceptor, and the time it takes to receive a response.\n\ttimeout time.Duration\n\n\t// params are our current chain params.\n\tparams *chaincfg.Params\n\n\t// done is closed when the rpc client terminates.\n\tdone chan struct{}\n\n\t// quit is closed when lnd is shutting down.\n\tquit chan struct{}\n\n\twg sync.WaitGroup\n}\n\n// Accept is a predicate on the ChannelAcceptRequest which is sent to the RPC\n// client who will respond with the ultimate decision. This function passes the\n// request into the acceptor's requests channel, and returns the response it\n// receives, failing the request if the timeout elapses.\n//\n// NOTE: Part of the ChannelAcceptor interface.",
      "length": 1212,
      "tokens": 196,
      "embedding": []
    },
    {
      "slug": "func (r *RPCAcceptor) Accept(req *ChannelAcceptRequest) *ChannelAcceptResponse {",
      "content": "func (r *RPCAcceptor) Accept(req *ChannelAcceptRequest) *ChannelAcceptResponse {\n\trespChan := make(chan *ChannelAcceptResponse, 1)\n\n\tnewRequest := &chanAcceptInfo{\n\t\trequest:  req,\n\t\tresponse: respChan,\n\t}\n\n\t// timeout is the time after which ChannelAcceptRequests expire.\n\ttimeout := time.After(r.timeout)\n\n\t// Create a rejection response which we can use for the cases where we\n\t// reject the channel.\n\trejectChannel := NewChannelAcceptResponse(\n\t\tfalse, errChannelRejected, nil, 0, 0, 0, 0, 0, 0, false,\n\t)\n\n\t// Send the request to the newRequests channel.\n\tselect {\n\tcase r.requests <- newRequest:\n\n\tcase <-timeout:\n\t\tlog.Errorf(\"RPCAcceptor returned false - reached timeout of %v\",\n\t\t\tr.timeout)\n\t\treturn rejectChannel\n\n\tcase <-r.done:\n\t\treturn rejectChannel\n\n\tcase <-r.quit:\n\t\treturn rejectChannel\n\t}\n\n\t// Receive the response and return it. If no response has been received\n\t// in AcceptorTimeout, then return false.\n\tselect {\n\tcase resp := <-respChan:\n\t\treturn resp\n\n\tcase <-timeout:\n\t\tlog.Errorf(\"RPCAcceptor returned false - reached timeout of %v\",\n\t\t\tr.timeout)\n\t\treturn rejectChannel\n\n\tcase <-r.done:\n\t\treturn rejectChannel\n\n\tcase <-r.quit:\n\t\treturn rejectChannel\n\t}\n}\n\n// NewRPCAcceptor creates and returns an instance of the RPCAcceptor.",
      "length": 1119,
      "tokens": 153,
      "embedding": []
    },
    {
      "slug": "func NewRPCAcceptor(receive func() (*lnrpc.ChannelAcceptResponse, error),",
      "content": "func NewRPCAcceptor(receive func() (*lnrpc.ChannelAcceptResponse, error),\n\tsend func(*lnrpc.ChannelAcceptRequest) error, timeout time.Duration,\n\tparams *chaincfg.Params, quit chan struct{}) *RPCAcceptor {\n\n\treturn &RPCAcceptor{\n\t\treceive:  receive,\n\t\tsend:     send,\n\t\trequests: make(chan *chanAcceptInfo),\n\t\ttimeout:  timeout,\n\t\tparams:   params,\n\t\tdone:     make(chan struct{}),\n\t\tquit:     quit,\n\t}\n}\n\n// Run is the main loop for the RPC Acceptor. This function will block until\n// it receives the signal that lnd is shutting down, or the rpc stream is\n// cancelled by the client.",
      "length": 493,
      "tokens": 67,
      "embedding": []
    },
    {
      "slug": "func (r *RPCAcceptor) Run() error {",
      "content": "func (r *RPCAcceptor) Run() error {\n\t// Wait for our goroutines to exit before we return.\n\tdefer r.wg.Wait()\n\n\t// Create a channel that responses from acceptors are sent into.\n\tresponses := make(chan *lnrpc.ChannelAcceptResponse)\n\n\t// errChan is used by the receive loop to signal any errors that occur\n\t// during reading from the stream. This is primarily used to shutdown\n\t// the send loop in the case of an RPC client disconnecting.\n\terrChan := make(chan error, 1)\n\n\t// Start a goroutine to receive responses from the channel acceptor.\n\t// We expect the receive function to block, so it must be run in a\n\t// goroutine (otherwise we could not send more than one channel accept\n\t// request to the client).\n\tr.wg.Add(1)\n\tgo func() {\n\t\tr.receiveResponses(errChan, responses)\n\t\tr.wg.Done()\n\t}()\n\n\treturn r.sendAcceptRequests(errChan, responses)\n}\n\n// receiveResponses receives responses for our channel accept requests and\n// dispatches them into the responses channel provided, sending any errors that\n// occur into the error channel provided.",
      "length": 980,
      "tokens": 154,
      "embedding": []
    },
    {
      "slug": "func (r *RPCAcceptor) receiveResponses(errChan chan error,",
      "content": "func (r *RPCAcceptor) receiveResponses(errChan chan error,\n\tresponses chan *lnrpc.ChannelAcceptResponse) {\n\n\tfor {\n\t\tresp, err := r.receive()\n\t\tif err != nil {\n\t\t\terrChan <- err\n\t\t\treturn\n\t\t}\n\n\t\tvar pendingID [32]byte\n\t\tcopy(pendingID[:], resp.PendingChanId)\n\n\t\topenChanResp := &lnrpc.ChannelAcceptResponse{\n\t\t\tAccept:          resp.Accept,\n\t\t\tPendingChanId:   pendingID[:],\n\t\t\tError:           resp.Error,\n\t\t\tUpfrontShutdown: resp.UpfrontShutdown,\n\t\t\tCsvDelay:        resp.CsvDelay,\n\t\t\tReserveSat:      resp.ReserveSat,\n\t\t\tInFlightMaxMsat: resp.InFlightMaxMsat,\n\t\t\tMaxHtlcCount:    resp.MaxHtlcCount,\n\t\t\tMinHtlcIn:       resp.MinHtlcIn,\n\t\t\tMinAcceptDepth:  resp.MinAcceptDepth,\n\t\t\tZeroConf:        resp.ZeroConf,\n\t\t}\n\n\t\t// We have received a decision for one of our channel\n\t\t// acceptor requests.\n\t\tselect {\n\t\tcase responses <- openChanResp:\n\n\t\tcase <-r.done:\n\t\t\treturn\n\n\t\tcase <-r.quit:\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// sendAcceptRequests handles channel acceptor requests sent to us by our\n// Accept() function, dispatching them to our acceptor stream and coordinating\n// return of responses to their callers.",
      "length": 1002,
      "tokens": 109,
      "embedding": []
    },
    {
      "slug": "func (r *RPCAcceptor) sendAcceptRequests(errChan chan error,",
      "content": "func (r *RPCAcceptor) sendAcceptRequests(errChan chan error,\n\tresponses chan *lnrpc.ChannelAcceptResponse) error {\n\n\t// Close the done channel to indicate that the acceptor is no longer\n\t// listening and any in-progress requests should be terminated.\n\tdefer close(r.done)\n\n\t// Create a map of pending channel IDs to our original open channel\n\t// request and a response channel. We keep the original channel open\n\t// message so that we can validate our response against it.\n\tacceptRequests := make(map[[32]byte]*chanAcceptInfo)\n\n\tfor {\n\t\tselect {\n\t\t// Consume requests passed to us from our Accept() function and\n\t\t// send them into our stream.\n\t\tcase newRequest := <-r.requests:\n\n\t\t\treq := newRequest.request\n\t\t\tpendingChanID := req.OpenChanMsg.PendingChannelID\n\n\t\t\t// Map the channel commitment type to its RPC\n\t\t\t// counterpart. Also determine whether the zero-conf or\n\t\t\t// scid-alias channel types are set.\n\t\t\tvar (\n\t\t\t\tcommitmentType lnrpc.CommitmentType\n\t\t\t\twantsZeroConf  bool\n\t\t\t\twantsScidAlias bool\n\t\t\t)\n\n\t\t\tif req.OpenChanMsg.ChannelType != nil {\n\t\t\t\tchannelFeatures := lnwire.RawFeatureVector(\n\t\t\t\t\t*req.OpenChanMsg.ChannelType,\n\t\t\t\t)\n\t\t\t\tswitch {\n\t\t\t\tcase channelFeatures.OnlyContains(\n\t\t\t\t\tlnwire.ZeroConfRequired,\n\t\t\t\t\tlnwire.ScidAliasRequired,\n\t\t\t\t\tlnwire.ScriptEnforcedLeaseRequired,\n\t\t\t\t\tlnwire.AnchorsZeroFeeHtlcTxRequired,\n\t\t\t\t\tlnwire.StaticRemoteKeyRequired,\n\t\t\t\t):\n\t\t\t\t\tcommitmentType = lnrpc.CommitmentType_SCRIPT_ENFORCED_LEASE\n\n\t\t\t\tcase channelFeatures.OnlyContains(\n\t\t\t\t\tlnwire.ZeroConfRequired,\n\t\t\t\t\tlnwire.ScriptEnforcedLeaseRequired,\n\t\t\t\t\tlnwire.AnchorsZeroFeeHtlcTxRequired,\n\t\t\t\t\tlnwire.StaticRemoteKeyRequired,\n\t\t\t\t):\n\t\t\t\t\tcommitmentType = lnrpc.CommitmentType_SCRIPT_ENFORCED_LEASE\n\n\t\t\t\tcase channelFeatures.OnlyContains(\n\t\t\t\t\tlnwire.ScidAliasRequired,\n\t\t\t\t\tlnwire.ScriptEnforcedLeaseRequired,\n\t\t\t\t\tlnwire.AnchorsZeroFeeHtlcTxRequired,\n\t\t\t\t\tlnwire.StaticRemoteKeyRequired,\n\t\t\t\t):\n\t\t\t\t\tcommitmentType = lnrpc.CommitmentType_SCRIPT_ENFORCED_LEASE\n\n\t\t\t\tcase channelFeatures.OnlyContains(\n\t\t\t\t\tlnwire.ScriptEnforcedLeaseRequired,\n\t\t\t\t\tlnwire.AnchorsZeroFeeHtlcTxRequired,\n\t\t\t\t\tlnwire.StaticRemoteKeyRequired,\n\t\t\t\t):\n\t\t\t\t\tcommitmentType = lnrpc.CommitmentType_SCRIPT_ENFORCED_LEASE\n\n\t\t\t\tcase channelFeatures.OnlyContains(\n\t\t\t\t\tlnwire.ZeroConfRequired,\n\t\t\t\t\tlnwire.ScidAliasRequired,\n\t\t\t\t\tlnwire.AnchorsZeroFeeHtlcTxRequired,\n\t\t\t\t\tlnwire.StaticRemoteKeyRequired,\n\t\t\t\t):\n\t\t\t\t\tcommitmentType = lnrpc.CommitmentType_ANCHORS\n\n\t\t\t\tcase channelFeatures.OnlyContains(\n\t\t\t\t\tlnwire.ZeroConfRequired,\n\t\t\t\t\tlnwire.AnchorsZeroFeeHtlcTxRequired,\n\t\t\t\t\tlnwire.StaticRemoteKeyRequired,\n\t\t\t\t):\n\t\t\t\t\tcommitmentType = lnrpc.CommitmentType_ANCHORS\n\n\t\t\t\tcase channelFeatures.OnlyContains(\n\t\t\t\t\tlnwire.ScidAliasRequired,\n\t\t\t\t\tlnwire.AnchorsZeroFeeHtlcTxRequired,\n\t\t\t\t\tlnwire.StaticRemoteKeyRequired,\n\t\t\t\t):\n\t\t\t\t\tcommitmentType = lnrpc.CommitmentType_ANCHORS\n\n\t\t\t\tcase channelFeatures.OnlyContains(\n\t\t\t\t\tlnwire.AnchorsZeroFeeHtlcTxRequired,\n\t\t\t\t\tlnwire.StaticRemoteKeyRequired,\n\t\t\t\t):\n\t\t\t\t\tcommitmentType = lnrpc.CommitmentType_ANCHORS\n\n\t\t\t\tcase channelFeatures.OnlyContains(\n\t\t\t\t\tlnwire.StaticRemoteKeyRequired,\n\t\t\t\t):\n\t\t\t\t\tcommitmentType = lnrpc.CommitmentType_STATIC_REMOTE_KEY\n\n\t\t\t\tcase channelFeatures.OnlyContains():\n\t\t\t\t\tcommitmentType = lnrpc.CommitmentType_LEGACY\n\n\t\t\t\tdefault:\n\t\t\t\t\tlog.Warnf(\"Unhandled commitment type \"+\n\t\t\t\t\t\t\"in channel acceptor request: %v\",\n\t\t\t\t\t\treq.OpenChanMsg.ChannelType)\n\t\t\t\t}\n\n\t\t\t\tif channelFeatures.IsSet(\n\t\t\t\t\tlnwire.ZeroConfRequired,\n\t\t\t\t) {\n\n\t\t\t\t\twantsZeroConf = true\n\t\t\t\t}\n\n\t\t\t\tif channelFeatures.IsSet(\n\t\t\t\t\tlnwire.ScidAliasRequired,\n\t\t\t\t) {\n\n\t\t\t\t\twantsScidAlias = true\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tacceptRequests[pendingChanID] = newRequest\n\n\t\t\t// A ChannelAcceptRequest has been received, send it to the client.\n\t\t\tchanAcceptReq := &lnrpc.ChannelAcceptRequest{\n\t\t\t\tNodePubkey:       req.Node.SerializeCompressed(),\n\t\t\t\tChainHash:        req.OpenChanMsg.ChainHash[:],\n\t\t\t\tPendingChanId:    req.OpenChanMsg.PendingChannelID[:],\n\t\t\t\tFundingAmt:       uint64(req.OpenChanMsg.FundingAmount),\n\t\t\t\tPushAmt:          uint64(req.OpenChanMsg.PushAmount),\n\t\t\t\tDustLimit:        uint64(req.OpenChanMsg.DustLimit),\n\t\t\t\tMaxValueInFlight: uint64(req.OpenChanMsg.MaxValueInFlight),\n\t\t\t\tChannelReserve:   uint64(req.OpenChanMsg.ChannelReserve),\n\t\t\t\tMinHtlc:          uint64(req.OpenChanMsg.HtlcMinimum),\n\t\t\t\tFeePerKw:         uint64(req.OpenChanMsg.FeePerKiloWeight),\n\t\t\t\tCsvDelay:         uint32(req.OpenChanMsg.CsvDelay),\n\t\t\t\tMaxAcceptedHtlcs: uint32(req.OpenChanMsg.MaxAcceptedHTLCs),\n\t\t\t\tChannelFlags:     uint32(req.OpenChanMsg.ChannelFlags),\n\t\t\t\tCommitmentType:   commitmentType,\n\t\t\t\tWantsZeroConf:    wantsZeroConf,\n\t\t\t\tWantsScidAlias:   wantsScidAlias,\n\t\t\t}\n\n\t\t\tif err := r.send(chanAcceptReq); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t// Process newly received responses from our channel acceptor,\n\t\t// looking the original request up in our map of requests and\n\t\t// dispatching the response.\n\t\tcase resp := <-responses:\n\t\t\t// Look up the appropriate channel to send on given the\n\t\t\t// pending ID. If a channel is found, send the response\n\t\t\t// over it.\n\t\t\tvar pendingID [32]byte\n\t\t\tcopy(pendingID[:], resp.PendingChanId)\n\t\t\trequestInfo, ok := acceptRequests[pendingID]\n\t\t\tif !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Validate the response we have received. If it is not\n\t\t\t// valid, we log our error and proceed to deliver the\n\t\t\t// rejection.\n\t\t\taccept, acceptErr, shutdown, err := r.validateAcceptorResponse(\n\t\t\t\trequestInfo.request.OpenChanMsg.DustLimit, resp,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tlog.Errorf(\"Invalid acceptor response: %v\", err)\n\t\t\t}\n\n\t\t\trequestInfo.response <- NewChannelAcceptResponse(\n\t\t\t\taccept, acceptErr, shutdown,\n\t\t\t\tuint16(resp.CsvDelay),\n\t\t\t\tuint16(resp.MaxHtlcCount),\n\t\t\t\tuint16(resp.MinAcceptDepth),\n\t\t\t\tbtcutil.Amount(resp.ReserveSat),\n\t\t\t\tlnwire.MilliSatoshi(resp.InFlightMaxMsat),\n\t\t\t\tlnwire.MilliSatoshi(resp.MinHtlcIn),\n\t\t\t\tresp.ZeroConf,\n\t\t\t)\n\n\t\t\t// Delete the channel from the acceptRequests map.\n\t\t\tdelete(acceptRequests, pendingID)\n\n\t\t// If we failed to receive from our acceptor, we exit.\n\t\tcase err := <-errChan:\n\t\t\tlog.Errorf(\"Received an error: %v, shutting down\", err)\n\t\t\treturn err\n\n\t\t// Exit if we are shutting down.\n\t\tcase <-r.quit:\n\t\t\treturn errShuttingDown\n\t\t}\n\t}\n}\n\n// validateAcceptorResponse validates the response we get from the channel\n// acceptor, returning a boolean indicating whether to accept the channel, an\n// error to send to the peer, and any validation errors that occurred.",
      "length": 6182,
      "tokens": 532,
      "embedding": []
    },
    {
      "slug": "func (r *RPCAcceptor) validateAcceptorResponse(dustLimit btcutil.Amount,",
      "content": "func (r *RPCAcceptor) validateAcceptorResponse(dustLimit btcutil.Amount,\n\treq *lnrpc.ChannelAcceptResponse) (bool, error, lnwire.DeliveryAddress,\n\terror) {\n\n\tchannelStr := hex.EncodeToString(req.PendingChanId)\n\n\t// Check that the max htlc count is within the BOLT 2 hard-limit of 483.\n\t// The initiating side should fail values above this anyway, but we\n\t// catch the invalid user input here.\n\tif req.MaxHtlcCount > input.MaxHTLCNumber/2 {\n\t\tlog.Errorf(\"Max htlc count: %v for channel: %v is greater \"+\n\t\t\t\"than limit of: %v\", req.MaxHtlcCount, channelStr,\n\t\t\tinput.MaxHTLCNumber/2)\n\n\t\treturn false, errChannelRejected, nil, errMaxHtlcTooHigh\n\t}\n\n\t// Ensure that the reserve that has been proposed, if it is set, is at\n\t// least the dust limit that was proposed by the remote peer. This is\n\t// required by BOLT 2.\n\treserveSat := btcutil.Amount(req.ReserveSat)\n\tif reserveSat != 0 && reserveSat < dustLimit {\n\t\tlog.Errorf(\"Remote reserve: %v sat for channel: %v must be \"+\n\t\t\t\"at least equal to proposed dust limit: %v\",\n\t\t\treq.ReserveSat, channelStr, dustLimit)\n\n\t\treturn false, errChannelRejected, nil, errInsufficientReserve\n\t}\n\n\t// Attempt to parse the upfront shutdown address provided.\n\tupfront, err := chancloser.ParseUpfrontShutdownAddress(\n\t\treq.UpfrontShutdown, r.params,\n\t)\n\tif err != nil {\n\t\tlog.Errorf(\"Could not parse upfront shutdown for \"+\n\t\t\t\"%v: %v\", channelStr, err)\n\n\t\treturn false, errChannelRejected, nil, errInvalidUpfrontShutdown\n\t}\n\n\t// Check that the custom error provided is valid.\n\tif len(req.Error) > maxErrorLength {\n\t\treturn false, errChannelRejected, nil, errCustomLength\n\t}\n\n\tvar haveCustomError = len(req.Error) != 0\n\n\tswitch {\n\t// If accept is true, but we also have an error specified, we fail\n\t// because this result is ambiguous.\n\tcase req.Accept && haveCustomError:\n\t\treturn false, errChannelRejected, nil, errAcceptWithError\n\n\t// If we accept without an error message, we can just return a nil\n\t// error.\n\tcase req.Accept:\n\t\treturn true, nil, upfront, nil\n\n\t// If we reject the channel, and have a custom error, then we use it.\n\tcase haveCustomError:\n\t\treturn false, fmt.Errorf(req.Error), nil, nil\n\n\t// Otherwise, we have rejected the channel with no custom error, so we\n\t// just use a generic error to fail the channel.\n\tdefault:\n\t\treturn false, errChannelRejected, nil, nil\n\t}\n}\n\n// A compile-time constraint to ensure RPCAcceptor implements the ChannelAcceptor\n// interface.\nvar _ ChannelAcceptor = (*RPCAcceptor)(nil)\n",
      "length": 2318,
      "tokens": 333,
      "embedding": []
    }
  ]
}