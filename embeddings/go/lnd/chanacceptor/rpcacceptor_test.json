{
  "filepath": "../implementations/go/lnd/chanacceptor/rpcacceptor_test.go",
  "package": "chanacceptor",
  "sections": [
    {
      "slug": "func TestValidateAcceptorResponse(t *testing.T) {",
      "content": "func TestValidateAcceptorResponse(t *testing.T) {\n\tvar (\n\t\tcustomError = errors.New(\"custom error\")\n\t\tvalidAddr   = \"bcrt1qwrmq9uca0t3dy9t9wtuq5tm4405r7tfzyqn9pp\"\n\t\taddr, _     = chancloser.ParseUpfrontShutdownAddress(\n\t\t\tvalidAddr, &chaincfg.RegressionNetParams,\n\t\t)\n\t)\n\n\ttests := []struct {\n\t\tname        string\n\t\tdustLimit   btcutil.Amount\n\t\tresponse    *lnrpc.ChannelAcceptResponse\n\t\taccept      bool\n\t\tacceptorErr error\n\t\terror       error\n\t\tshutdown    lnwire.DeliveryAddress\n\t}{\n\t\t{\n\t\t\tname: \"accepted with error\",\n\t\t\tresponse: &lnrpc.ChannelAcceptResponse{\n\t\t\t\tAccept: true,\n\t\t\t\tError:  customError.Error(),\n\t\t\t},\n\t\t\taccept:      false,\n\t\t\tacceptorErr: errChannelRejected,\n\t\t\terror:       errAcceptWithError,\n\t\t},\n\t\t{\n\t\t\tname: \"custom error too long\",\n\t\t\tresponse: &lnrpc.ChannelAcceptResponse{\n\t\t\t\tAccept: false,\n\t\t\t\tError:  strings.Repeat(\" \", maxErrorLength+1),\n\t\t\t},\n\t\t\taccept:      false,\n\t\t\tacceptorErr: errChannelRejected,\n\t\t\terror:       errCustomLength,\n\t\t},\n\t\t{\n\t\t\tname: \"accepted\",\n\t\t\tresponse: &lnrpc.ChannelAcceptResponse{\n\t\t\t\tAccept:          true,\n\t\t\t\tUpfrontShutdown: validAddr,\n\t\t\t},\n\t\t\taccept:      true,\n\t\t\tacceptorErr: nil,\n\t\t\terror:       nil,\n\t\t\tshutdown:    addr,\n\t\t},\n\t\t{\n\t\t\tname: \"rejected with error\",\n\t\t\tresponse: &lnrpc.ChannelAcceptResponse{\n\t\t\t\tAccept: false,\n\t\t\t\tError:  customError.Error(),\n\t\t\t},\n\t\t\taccept:      false,\n\t\t\tacceptorErr: customError,\n\t\t\terror:       nil,\n\t\t},\n\t\t{\n\t\t\tname: \"rejected with no error\",\n\t\t\tresponse: &lnrpc.ChannelAcceptResponse{\n\t\t\t\tAccept: false,\n\t\t\t},\n\t\t\taccept:      false,\n\t\t\tacceptorErr: errChannelRejected,\n\t\t\terror:       nil,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid upfront shutdown\",\n\t\t\tresponse: &lnrpc.ChannelAcceptResponse{\n\t\t\t\tAccept:          true,\n\t\t\t\tUpfrontShutdown: \"invalid addr\",\n\t\t\t},\n\t\t\taccept:      false,\n\t\t\tacceptorErr: errChannelRejected,\n\t\t\terror:       errInvalidUpfrontShutdown,\n\t\t},\n\t\t{\n\t\t\tname:      \"reserve too low\",\n\t\t\tdustLimit: 100,\n\t\t\tresponse: &lnrpc.ChannelAcceptResponse{\n\t\t\t\tAccept:     true,\n\t\t\t\tReserveSat: 10,\n\t\t\t},\n\t\t\taccept:      false,\n\t\t\tacceptorErr: errChannelRejected,\n\t\t\terror:       errInsufficientReserve,\n\t\t},\n\t\t{\n\t\t\tname:      \"max htlcs too high\",\n\t\t\tdustLimit: 100,\n\t\t\tresponse: &lnrpc.ChannelAcceptResponse{\n\t\t\t\tAccept:       true,\n\t\t\t\tMaxHtlcCount: 1 + input.MaxHTLCNumber/2,\n\t\t\t},\n\t\t\taccept:      false,\n\t\t\tacceptorErr: errChannelRejected,\n\t\t\terror:       errMaxHtlcTooHigh,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t// Create an acceptor, everything can be nil because\n\t\t\t// we just need the params.\n\t\t\tacceptor := NewRPCAcceptor(\n\t\t\t\tnil, nil, 0, &chaincfg.RegressionNetParams, nil,\n\t\t\t)\n\n\t\t\taccept, acceptErr, shutdown, err := acceptor.validateAcceptorResponse(\n\t\t\t\ttest.dustLimit, test.response,\n\t\t\t)\n\t\t\trequire.Equal(t, test.accept, accept)\n\t\t\trequire.Equal(t, test.acceptorErr, acceptErr)\n\t\t\trequire.Equal(t, test.error, err)\n\t\t\trequire.Equal(t, test.shutdown, shutdown)\n\t\t})\n\t}\n}\n",
      "length": 2787,
      "tokens": 261,
      "embedding": []
    }
  ]
}