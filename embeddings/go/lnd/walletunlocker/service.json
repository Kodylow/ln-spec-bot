{
  "filepath": "../implementations/go/lnd/walletunlocker/service.go",
  "package": "walletunlocker",
  "sections": [
    {
      "slug": "type WalletUnlockParams struct {",
      "content": "type WalletUnlockParams struct {\n\t// Password is the public and private wallet passphrase.\n\tPassword []byte\n\n\t// Birthday specifies the approximate time that this wallet was created.\n\t// This is used to bound any rescans on startup.\n\tBirthday time.Time\n\n\t// RecoveryWindow specifies the address lookahead when entering recovery\n\t// mode. A recovery will be attempted if this value is non-zero.\n\tRecoveryWindow uint32\n\n\t// Wallet is the loaded and unlocked Wallet. This is returned\n\t// from the unlocker service to avoid it being unlocked twice (once in\n\t// the unlocker service to check if the password is correct and again\n\t// later when lnd actually uses it). Because unlocking involves scrypt\n\t// which is resource intensive, we want to avoid doing it twice.\n\tWallet *wallet.Wallet\n\n\t// ChansToRestore a set of static channel backups that should be\n\t// restored before the main server instance starts up.\n\tChansToRestore ChannelsToRecover\n\n\t// UnloadWallet is a function for unloading the wallet, which should\n\t// be called on shutdown.\n\tUnloadWallet func() error\n\n\t// StatelessInit signals that the user requested the daemon to be\n\t// initialized stateless, which means no unencrypted macaroons should be\n\t// written to disk.\n\tStatelessInit bool\n\n\t// MacResponseChan is the channel for sending back the admin macaroon to\n\t// the WalletUnlocker service.\n\tMacResponseChan chan []byte\n\n\t// MacRootKey is the 32 byte macaroon root key specified by the user\n\t// during wallet initialization.\n\tMacRootKey []byte\n}\n\n// ChannelsToRecover wraps any set of packed (serialized+encrypted) channel\n// back ups together. These can be passed in when unlocking the wallet, or\n// creating a new wallet for the first time with an existing seed.",
      "length": 1655,
      "tokens": 262,
      "embedding": []
    },
    {
      "slug": "type ChannelsToRecover struct {",
      "content": "type ChannelsToRecover struct {\n\t// PackedMultiChanBackup is an encrypted and serialized multi-channel\n\t// backup.\n\tPackedMultiChanBackup chanbackup.PackedMulti\n\n\t// PackedSingleChanBackups is a series of encrypted and serialized\n\t// single-channel backup for one or more channels.\n\tPackedSingleChanBackups chanbackup.PackedSingles\n}\n\n// WalletInitMsg is a message sent by the UnlockerService when a user wishes to\n// set up the internal wallet for the first time. The user MUST provide a\n// passphrase, but is also able to provide their own source of entropy. If\n// provided, then this source of entropy will be used to generate the wallet's\n// HD seed. Otherwise, the wallet will generate one itself.",
      "length": 657,
      "tokens": 99,
      "embedding": []
    },
    {
      "slug": "type WalletInitMsg struct {",
      "content": "type WalletInitMsg struct {\n\t// Passphrase is the passphrase that will be used to encrypt the wallet\n\t// itself. This MUST be at least 8 characters.\n\tPassphrase []byte\n\n\t// WalletSeed is the deciphered cipher seed that the wallet should use\n\t// to initialize itself. The seed might be nil if the wallet should be\n\t// created from an extended master root key instead.\n\tWalletSeed *aezeed.CipherSeed\n\n\t// WalletExtendedKey is the wallet's extended master root key that\n\t// should be used instead of the seed, if non-nil. The extended key is\n\t// mutually exclusive to the wallet seed, but one of both is always set.\n\tWalletExtendedKey *hdkeychain.ExtendedKey\n\n\t// ExtendedKeyBirthday is the birthday of a wallet that's being restored\n\t// through an extended key instead of an aezeed.\n\tExtendedKeyBirthday time.Time\n\n\t// WatchOnlyAccounts is a map of scoped account extended public keys\n\t// that should be imported to create a watch-only wallet.\n\tWatchOnlyAccounts map[waddrmgr.ScopedIndex]*hdkeychain.ExtendedKey\n\n\t// WatchOnlyBirthday is the birthday of the master root key the above\n\t// watch-only account xpubs were derived from.\n\tWatchOnlyBirthday time.Time\n\n\t// WatchOnlyMasterFingerprint is the fingerprint of the master root key\n\t// the above watch-only account xpubs were derived from.\n\tWatchOnlyMasterFingerprint uint32\n\n\t// RecoveryWindow is the address look-ahead used when restoring a seed\n\t// with existing funds. A recovery window zero indicates that no\n\t// recovery should be attempted, such as after the wallet's initial\n\t// creation.\n\tRecoveryWindow uint32\n\n\t// ChanBackups a set of static channel backups that should be received\n\t// after the wallet has been initialized.\n\tChanBackups ChannelsToRecover\n\n\t// StatelessInit signals that the user requested the daemon to be\n\t// initialized stateless, which means no unencrypted macaroons should be\n\t// written to disk.\n\tStatelessInit bool\n\n\t// MacRootKey is the 32 byte macaroon root key specified by the user\n\t// during wallet initialization.\n\tMacRootKey []byte\n}\n\n// WalletUnlockMsg is a message sent by the UnlockerService when a user wishes\n// to unlock the internal wallet after initial setup. The user can optionally\n// specify a recovery window, which will resume an interrupted rescan for used\n// addresses.",
      "length": 2196,
      "tokens": 334,
      "embedding": []
    },
    {
      "slug": "type WalletUnlockMsg struct {",
      "content": "type WalletUnlockMsg struct {\n\t// Passphrase is the passphrase that will be used to encrypt the wallet\n\t// itself. This MUST be at least 8 characters.\n\tPassphrase []byte\n\n\t// RecoveryWindow is the address look-ahead used when restoring a seed\n\t// with existing funds. A recovery window zero indicates that no\n\t// recovery should be attempted, such as after the wallet's initial\n\t// creation, but before any addresses have been created.\n\tRecoveryWindow uint32\n\n\t// Wallet is the loaded and unlocked Wallet. This is returned through\n\t// the channel to avoid it being unlocked twice (once to check if the\n\t// password is correct, here in the WalletUnlocker and again later when\n\t// lnd actually uses it). Because unlocking involves scrypt which is\n\t// resource intensive, we want to avoid doing it twice.\n\tWallet *wallet.Wallet\n\n\t// ChanBackups a set of static channel backups that should be received\n\t// after the wallet has been unlocked.\n\tChanBackups ChannelsToRecover\n\n\t// UnloadWallet is a function for unloading the wallet, which should\n\t// be called on shutdown.\n\tUnloadWallet func() error\n\n\t// StatelessInit signals that the user requested the daemon to be\n\t// initialized stateless, which means no unencrypted macaroons should be\n\t// written to disk.\n\tStatelessInit bool\n}\n\n// UnlockerService implements the WalletUnlocker service used to provide lnd\n// with a password for wallet encryption at startup. Additionally, during\n// initial setup, users can provide their own source of entropy which will be\n// used to generate the seed that's ultimately used within the wallet.",
      "length": 1515,
      "tokens": 244,
      "embedding": []
    },
    {
      "slug": "type UnlockerService struct {",
      "content": "type UnlockerService struct {\n\t// Required by the grpc-gateway/v2 library for forward compatibility.\n\tlnrpc.UnimplementedWalletUnlockerServer\n\n\t// InitMsgs is a channel that carries all wallet init messages.\n\tInitMsgs chan *WalletInitMsg\n\n\t// UnlockMsgs is a channel where unlock parameters provided by the rpc\n\t// client to be used to unlock and decrypt an existing wallet will be\n\t// sent.\n\tUnlockMsgs chan *WalletUnlockMsg\n\n\t// MacResponseChan is the channel for sending back the admin macaroon to\n\t// the WalletUnlocker service.\n\tMacResponseChan chan []byte\n\n\tnetParams *chaincfg.Params\n\n\t// macaroonFiles is the path to the three generated macaroons with\n\t// different access permissions. These might not exist in a stateless\n\t// initialization of lnd.\n\tmacaroonFiles []string\n\n\t// resetWalletTransactions indicates that the wallet state should be\n\t// reset on unlock to force a full chain rescan.\n\tresetWalletTransactions bool\n\n\t// LoaderOpts holds the functional options for the wallet loader.\n\tloaderOpts []btcwallet.LoaderOption\n\n\t// macaroonDB is an instance of a database backend that stores all\n\t// macaroon root keys. This will be nil on initialization and must be\n\t// set using the SetMacaroonDB method as soon as it's available.\n\tmacaroonDB kvdb.Backend\n}\n\n// New creates and returns a new UnlockerService.",
      "length": 1256,
      "tokens": 184,
      "embedding": []
    },
    {
      "slug": "func New(params *chaincfg.Params, macaroonFiles []string,",
      "content": "func New(params *chaincfg.Params, macaroonFiles []string,\n\tresetWalletTransactions bool,\n\tloaderOpts []btcwallet.LoaderOption) *UnlockerService {\n\n\treturn &UnlockerService{\n\t\tInitMsgs:   make(chan *WalletInitMsg, 1),\n\t\tUnlockMsgs: make(chan *WalletUnlockMsg, 1),\n\n\t\t// Make sure we buffer the channel is buffered so the main lnd\n\t\t// goroutine isn't blocking on writing to it.\n\t\tMacResponseChan:         make(chan []byte, 1),\n\t\tnetParams:               params,\n\t\tmacaroonFiles:           macaroonFiles,\n\t\tresetWalletTransactions: resetWalletTransactions,\n\t\tloaderOpts:              loaderOpts,\n\t}\n}\n\n// SetLoaderOpts can be used to inject wallet loader options after the unlocker\n// service has been hooked to the main RPC server.",
      "length": 654,
      "tokens": 74,
      "embedding": []
    },
    {
      "slug": "func (u *UnlockerService) SetLoaderOpts(loaderOpts []btcwallet.LoaderOption) {",
      "content": "func (u *UnlockerService) SetLoaderOpts(loaderOpts []btcwallet.LoaderOption) {\n\tu.loaderOpts = loaderOpts\n}\n\n// SetMacaroonDB can be used to inject the macaroon database after the unlocker\n// service has been hooked to the main RPC server.",
      "length": 156,
      "tokens": 27,
      "embedding": []
    },
    {
      "slug": "func (u *UnlockerService) SetMacaroonDB(macaroonDB kvdb.Backend) {",
      "content": "func (u *UnlockerService) SetMacaroonDB(macaroonDB kvdb.Backend) {\n\tu.macaroonDB = macaroonDB\n}\n",
      "length": 27,
      "tokens": 4,
      "embedding": []
    },
    {
      "slug": "func (u *UnlockerService) newLoader(recoveryWindow uint32) (*wallet.Loader,",
      "content": "func (u *UnlockerService) newLoader(recoveryWindow uint32) (*wallet.Loader,\n\terror) {\n\n\treturn btcwallet.NewWalletLoader(\n\t\tu.netParams, recoveryWindow, u.loaderOpts...,\n\t)\n}\n\n// WalletExists returns whether a wallet exists on the file path the\n// UnlockerService is using.",
      "length": 189,
      "tokens": 25,
      "embedding": []
    },
    {
      "slug": "func (u *UnlockerService) WalletExists() (bool, error) {",
      "content": "func (u *UnlockerService) WalletExists() (bool, error) {\n\tloader, err := u.newLoader(0)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn loader.WalletExists()\n}\n\n// GenSeed is the first method that should be used to instantiate a new lnd\n// instance. This method allows a caller to generate a new aezeed cipher seed\n// given an optional passphrase. If provided, the passphrase will be necessary\n// to decrypt the cipherseed to expose the internal wallet seed.\n//\n// Once the cipherseed is obtained and verified by the user, the InitWallet\n// method should be used to commit the newly generated seed, and create the\n// wallet.",
      "length": 553,
      "tokens": 98,
      "embedding": []
    },
    {
      "slug": "func (u *UnlockerService) GenSeed(_ context.Context,",
      "content": "func (u *UnlockerService) GenSeed(_ context.Context,\n\tin *lnrpc.GenSeedRequest) (*lnrpc.GenSeedResponse, error) {\n\n\t// Before we start, we'll ensure that the wallet hasn't already created\n\t// so we don't show a *new* seed to the user if one already exists.\n\tloader, err := u.newLoader(0)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\twalletExists, err := loader.WalletExists()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif walletExists {\n\t\treturn nil, fmt.Errorf(\"wallet already exists\")\n\t}\n\n\tvar entropy [aezeed.EntropySize]byte\n\n\tswitch {\n\t// If the user provided any entropy, then we'll make sure it's sized\n\t// properly.\n\tcase len(in.SeedEntropy) != 0 && len(in.SeedEntropy) != aezeed.EntropySize:\n\t\treturn nil, fmt.Errorf(\"incorrect entropy length: expected \"+\n\t\t\t\"16 bytes, instead got %v bytes\", len(in.SeedEntropy))\n\n\t// If the user provided the correct number of bytes, then we'll copy it\n\t// over into our buffer for usage.\n\tcase len(in.SeedEntropy) == aezeed.EntropySize:\n\t\tcopy(entropy[:], in.SeedEntropy[:])\n\n\t// Otherwise, we'll generate a fresh new set of bytes to use as entropy\n\t// to generate the seed.\n\tdefault:\n\t\tif _, err := rand.Read(entropy[:]); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Now that we have our set of entropy, we'll create a new cipher seed\n\t// instance.\n\t//\n\tcipherSeed, err := aezeed.New(\n\t\tkeychain.CurrentKeyDerivationVersion, &entropy, time.Now(),\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// With our raw cipher seed obtained, we'll convert it into an encoded\n\t// mnemonic using the user specified pass phrase.\n\tmnemonic, err := cipherSeed.ToMnemonic(in.AezeedPassphrase)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Additionally, we'll also obtain the raw enciphered cipher seed as\n\t// well to return to the user.\n\tencipheredSeed, err := cipherSeed.Encipher(in.AezeedPassphrase)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &lnrpc.GenSeedResponse{\n\t\tCipherSeedMnemonic: mnemonic[:],\n\t\tEncipheredSeed:     encipheredSeed[:],\n\t}, nil\n}\n\n// extractChanBackups is a helper function that extracts the set of channel\n// backups from the proto into a format that we'll pass to higher level\n// sub-systems.",
      "length": 2012,
      "tokens": 307,
      "embedding": []
    },
    {
      "slug": "func extractChanBackups(chanBackups *lnrpc.ChanBackupSnapshot) *ChannelsToRecover {",
      "content": "func extractChanBackups(chanBackups *lnrpc.ChanBackupSnapshot) *ChannelsToRecover {\n\t// If there aren't any populated channel backups, then we can exit\n\t// early as there's nothing to extract.\n\tif chanBackups == nil || (chanBackups.SingleChanBackups == nil &&\n\t\tchanBackups.MultiChanBackup == nil) {\n\t\treturn nil\n\t}\n\n\t// Now that we know there's at least a single back up populated, we'll\n\t// extract the multi-chan backup (if it's there).\n\tvar backups ChannelsToRecover\n\tif chanBackups.MultiChanBackup != nil {\n\t\tmultiBackup := chanBackups.MultiChanBackup\n\t\tbackups.PackedMultiChanBackup = multiBackup.MultiChanBackup\n\t}\n\n\tif chanBackups.SingleChanBackups == nil {\n\t\treturn &backups\n\t}\n\n\t// Finally, we can extract all the single chan backups as well.\n\tfor _, backup := range chanBackups.SingleChanBackups.ChanBackups {\n\t\tsingleChanBackup := backup.ChanBackup\n\n\t\tbackups.PackedSingleChanBackups = append(\n\t\t\tbackups.PackedSingleChanBackups, singleChanBackup,\n\t\t)\n\t}\n\n\treturn &backups\n}\n\n// InitWallet is used when lnd is starting up for the first time to fully\n// initialize the daemon and its internal wallet. At the very least a wallet\n// password must be provided. This will be used to encrypt sensitive material\n// on disk.\n//\n// In the case of a recovery scenario, the user can also specify their aezeed\n// mnemonic and passphrase. If set, then the daemon will use this prior state\n// to initialize its internal wallet.\n//\n// Alternatively, this can be used along with the GenSeed RPC to obtain a\n// seed, then present it to the user. Once it has been verified by the user,\n// the seed can be fed into this RPC in order to commit the new wallet.",
      "length": 1525,
      "tokens": 240,
      "embedding": []
    },
    {
      "slug": "func (u *UnlockerService) InitWallet(ctx context.Context,",
      "content": "func (u *UnlockerService) InitWallet(ctx context.Context,\n\tin *lnrpc.InitWalletRequest) (*lnrpc.InitWalletResponse, error) {\n\n\t// Make sure the password meets our constraints.\n\tpassword := in.WalletPassword\n\tif err := ValidatePassword(password); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Require that the recovery window be non-negative.\n\trecoveryWindow := in.RecoveryWindow\n\tif recoveryWindow < 0 {\n\t\treturn nil, fmt.Errorf(\"recovery window %d must be \"+\n\t\t\t\"non-negative\", recoveryWindow)\n\t}\n\n\t// Ensure that the macaroon root key is *exactly* 32-bytes.\n\tmacaroonRootKey := in.MacaroonRootKey\n\tif len(macaroonRootKey) > 0 &&\n\t\tlen(macaroonRootKey) != macaroons.RootKeyLen {\n\n\t\treturn nil, fmt.Errorf(\"macaroon root key must be exactly \"+\n\t\t\t\"%v bytes, is instead %v\",\n\t\t\tmacaroons.RootKeyLen, len(macaroonRootKey),\n\t\t)\n\t}\n\n\t// We'll then open up the directory that will be used to store the\n\t// wallet's files so we can check if the wallet already exists.\n\tloader, err := u.newLoader(uint32(recoveryWindow))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\twalletExists, err := loader.WalletExists()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// If the wallet already exists, then we'll exit early as we can't\n\t// create the wallet if it already exists!\n\tif walletExists {\n\t\treturn nil, fmt.Errorf(\"wallet already exists\")\n\t}\n\n\t// At this point, we know the wallet doesn't already exist so we can\n\t// prepare the message that we'll send over the channel later.\n\tinitMsg := &WalletInitMsg{\n\t\tPassphrase:     password,\n\t\tRecoveryWindow: uint32(recoveryWindow),\n\t\tStatelessInit:  in.StatelessInit,\n\t\tMacRootKey:     macaroonRootKey,\n\t}\n\n\t// There are two supported ways to initialize the wallet. Either from\n\t// the aezeed or the final extended master key directly.\n\tswitch {\n\t// Don't allow the user to specify both as that would be ambiguous.\n\tcase len(in.CipherSeedMnemonic) > 0 && len(in.ExtendedMasterKey) > 0:\n\t\treturn nil, fmt.Errorf(\"cannot specify both the cipher \" +\n\t\t\t\"seed mnemonic and the extended master key\")\n\n\t// The aezeed is the preferred and default way of initializing a wallet.\n\tcase len(in.CipherSeedMnemonic) > 0:\n\t\t// We'll map the user provided aezeed and passphrase into a\n\t\t// decoded cipher seed instance.\n\t\tvar mnemonic aezeed.Mnemonic\n\t\tcopy(mnemonic[:], in.CipherSeedMnemonic)\n\n\t\t// If we're unable to map it back into the ciphertext, then\n\t\t// either the mnemonic is wrong, or the passphrase is wrong.\n\t\tcipherSeed, err := mnemonic.ToCipherSeed(in.AezeedPassphrase)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tinitMsg.WalletSeed = cipherSeed\n\n\t// To support restoring a wallet where the seed isn't known or a wallet\n\t// created externally to lnd, we also allow the extended master key\n\t// (xprv) to be imported directly. This is what'll be stored in the\n\t// btcwallet database anyway.\n\tcase len(in.ExtendedMasterKey) > 0:\n\t\textendedKey, err := hdkeychain.NewKeyFromString(\n\t\t\tin.ExtendedMasterKey,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// The on-chain wallet of lnd is going to derive keys based on\n\t\t// the BIP49/84 key derivation paths from this root key. To make\n\t\t// sure we use default derivation paths, we want to avoid\n\t\t// deriving keys from something other than the master key (at\n\t\t// depth 0, denoted with \"m/\" in BIP32 notation).\n\t\tif extendedKey.Depth() != 0 {\n\t\t\treturn nil, fmt.Errorf(\"extended master key must \" +\n\t\t\t\t\"be at depth 0 not a child key\")\n\t\t}\n\n\t\t// Because we need the master key (at depth 0), it must be an\n\t\t// extended private key as the first levels of BIP49/84\n\t\t// derivation paths are hardened, which isn't possible with\n\t\t// extended public keys.\n\t\tif !extendedKey.IsPrivate() {\n\t\t\treturn nil, fmt.Errorf(\"extended master key must \" +\n\t\t\t\t\"contain private keys\")\n\t\t}\n\n\t\t// To avoid using the wrong master key, we check that it was\n\t\t// issued for the correct network. This will cause problems if\n\t\t// someone tries to import a \"new\" BIP84 zprv key because with\n\t\t// this we only support the \"legacy\" zprv prefix. But it is\n\t\t// trivial to convert between those formats, as long as the user\n\t\t// knows what they're doing.\n\t\tif !extendedKey.IsForNet(u.netParams) {\n\t\t\treturn nil, fmt.Errorf(\"extended master key must be \"+\n\t\t\t\t\"for network %s\", u.netParams.Name)\n\t\t}\n\n\t\t// When importing a wallet from its extended private key we\n\t\t// don't know the birthday as that information is not encoded in\n\t\t// that format. We therefore must set an arbitrary date to start\n\t\t// rescanning at if the user doesn't provide an explicit value\n\t\t// for it. Since lnd only uses SegWit addresses, we pick the\n\t\t// date of the first block that contained SegWit transactions\n\t\t// (481824).\n\t\tinitMsg.ExtendedKeyBirthday = time.Date(\n\t\t\t2017, time.August, 24, 1, 57, 37, 0, time.UTC,\n\t\t)\n\t\tif in.ExtendedMasterKeyBirthdayTimestamp != 0 {\n\t\t\tinitMsg.ExtendedKeyBirthday = time.Unix(\n\t\t\t\tint64(in.ExtendedMasterKeyBirthdayTimestamp), 0,\n\t\t\t)\n\t\t}\n\n\t\tinitMsg.WalletExtendedKey = extendedKey\n\n\t// The third option for creating a wallet is the watch-only mode:\n\t// Instead of providing the master root key directly, each individual\n\t// account is passed as an extended public key only. Because of the\n\t// hardened derivation path up to the account (depth 3), it is not\n\t// possible to create a master root extended _public_ key. Therefore, an\n\t// xpub must be derived and passed into the unlocker for _every_ account\n\t// lnd expects.\n\tcase in.WatchOnly != nil && len(in.WatchOnly.Accounts) > 0:\n\t\tinitMsg.WatchOnlyAccounts = make(\n\t\t\tmap[waddrmgr.ScopedIndex]*hdkeychain.ExtendedKey,\n\t\t\tlen(in.WatchOnly.Accounts),\n\t\t)\n\n\t\tfor _, acct := range in.WatchOnly.Accounts {\n\t\t\tscopedIndex := waddrmgr.ScopedIndex{\n\t\t\t\tScope: waddrmgr.KeyScope{\n\t\t\t\t\tPurpose: acct.Purpose,\n\t\t\t\t\tCoin:    acct.CoinType,\n\t\t\t\t},\n\t\t\t\tIndex: acct.Account,\n\t\t\t}\n\t\t\tacctKey, err := hdkeychain.NewKeyFromString(acct.Xpub)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"error parsing xpub \"+\n\t\t\t\t\t\"%v: %v\", acct.Xpub, err)\n\t\t\t}\n\n\t\t\t// Just to make sure the user is doing the right thing,\n\t\t\t// we expect the public key to be at derivation depth\n\t\t\t// three (which is the account level) and the key not to\n\t\t\t// contain any private key material.\n\t\t\tif acctKey.Depth() != 3 {\n\t\t\t\treturn nil, fmt.Errorf(\"xpub must be at \" +\n\t\t\t\t\t\"depth 3\")\n\t\t\t}\n\t\t\tif acctKey.IsPrivate() {\n\t\t\t\treturn nil, fmt.Errorf(\"xpub is not really \" +\n\t\t\t\t\t\"an xpub, contains private key\")\n\t\t\t}\n\n\t\t\tinitMsg.WatchOnlyAccounts[scopedIndex] = acctKey\n\t\t}\n\n\t\t// When importing a wallet from its extended public keys we\n\t\t// don't know the birthday as that information is not encoded in\n\t\t// that format. We therefore must set an arbitrary date to start\n\t\t// rescanning at if the user doesn't provide an explicit value\n\t\t// for it. Since lnd only uses SegWit addresses, we pick the\n\t\t// date of the first block that contained SegWit transactions\n\t\t// (481824).\n\t\tinitMsg.WatchOnlyBirthday = time.Date(\n\t\t\t2017, time.August, 24, 1, 57, 37, 0, time.UTC,\n\t\t)\n\t\tif in.WatchOnly.MasterKeyBirthdayTimestamp != 0 {\n\t\t\tinitMsg.WatchOnlyBirthday = time.Unix(\n\t\t\t\tint64(in.WatchOnly.MasterKeyBirthdayTimestamp),\n\t\t\t\t0,\n\t\t\t)\n\t\t}\n\n\t// No key material was set, no wallet can be created.\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"must either specify cipher seed \" +\n\t\t\t\"mnemonic or the extended master key\")\n\t}\n\n\t// Before we return the unlock payload, we'll check if we can extract\n\t// any channel backups to pass up to the higher level sub-system.\n\tchansToRestore := extractChanBackups(in.ChannelBackups)\n\tif chansToRestore != nil {\n\t\tinitMsg.ChanBackups = *chansToRestore\n\t}\n\n\t// Deliver the initialization message back to the main daemon.\n\tselect {\n\tcase u.InitMsgs <- initMsg:\n\t\t// We need to read from the channel to let the daemon continue\n\t\t// its work and to get the admin macaroon. Once the response\n\t\t// arrives, we directly forward it to the client.\n\t\tselect {\n\t\tcase adminMac := <-u.MacResponseChan:\n\t\t\treturn &lnrpc.InitWalletResponse{\n\t\t\t\tAdminMacaroon: adminMac,\n\t\t\t}, nil\n\n\t\tcase <-ctx.Done():\n\t\t\treturn nil, ErrUnlockTimeout\n\t\t}\n\n\tcase <-ctx.Done():\n\t\treturn nil, ErrUnlockTimeout\n\t}\n}\n\n// LoadAndUnlock creates a loader for the wallet and tries to unlock the wallet\n// with the given password and recovery window. If the drop wallet transactions\n// flag is set, the history state drop is performed before unlocking the wallet\n// yet again.",
      "length": 8012,
      "tokens": 1209,
      "embedding": []
    },
    {
      "slug": "func (u *UnlockerService) LoadAndUnlock(password []byte,",
      "content": "func (u *UnlockerService) LoadAndUnlock(password []byte,\n\trecoveryWindow uint32) (*wallet.Wallet, func() error, error) {\n\n\tloader, err := u.newLoader(recoveryWindow)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// Check if wallet already exists.\n\twalletExists, err := loader.WalletExists()\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tif !walletExists {\n\t\t// Cannot unlock a wallet that does not exist!\n\t\treturn nil, nil, fmt.Errorf(\"wallet not found\")\n\t}\n\n\t// Try opening the existing wallet with the provided password.\n\tunlockedWallet, err := loader.OpenExistingWallet(password, false)\n\tif err != nil {\n\t\t// Could not open wallet, most likely this means that provided\n\t\t// password was incorrect.\n\t\treturn nil, nil, err\n\t}\n\n\t// The user requested to drop their whole wallet transaction state to\n\t// force a full chain rescan for wallet addresses. Dropping the state\n\t// only properly takes effect after opening the wallet. That's why we\n\t// start, drop, stop and start again.\n\tif u.resetWalletTransactions {\n\t\tdropErr := wallet.DropTransactionHistory(\n\t\t\tunlockedWallet.Database(), true,\n\t\t)\n\n\t\t// Even if dropping the history fails, we'll want to unload the\n\t\t// wallet. If unloading fails, that error is probably more\n\t\t// important to be returned to the user anyway.\n\t\tif err := loader.UnloadWallet(); err != nil {\n\t\t\treturn nil, nil, fmt.Errorf(\"could not unload \"+\n\t\t\t\t\"wallet (tx history drop err: %v): %v\", dropErr,\n\t\t\t\terr)\n\t\t}\n\n\t\t// If dropping failed but unloading didn't, we'll still abort\n\t\t// and inform the user.\n\t\tif dropErr != nil {\n\t\t\treturn nil, nil, dropErr\n\t\t}\n\n\t\t// All looks good, let's now open the wallet again. The loader\n\t\t// was unloaded and might have removed its remote DB connection,\n\t\t// so let's re-create it as well.\n\t\tloader, err = u.newLoader(recoveryWindow)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\tunlockedWallet, err = loader.OpenExistingWallet(password, false)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t}\n\n\treturn unlockedWallet, loader.UnloadWallet, nil\n}\n\n// UnlockWallet sends the password provided by the incoming UnlockWalletRequest\n// over the UnlockMsgs channel in case it successfully decrypts an existing\n// wallet found in the chain's wallet database directory.",
      "length": 2099,
      "tokens": 329,
      "embedding": []
    },
    {
      "slug": "func (u *UnlockerService) UnlockWallet(ctx context.Context,",
      "content": "func (u *UnlockerService) UnlockWallet(ctx context.Context,\n\tin *lnrpc.UnlockWalletRequest) (*lnrpc.UnlockWalletResponse, error) {\n\n\tpassword := in.WalletPassword\n\trecoveryWindow := uint32(in.RecoveryWindow)\n\n\tunlockedWallet, unloadFn, err := u.LoadAndUnlock(\n\t\tpassword, recoveryWindow,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// We successfully opened the wallet and pass the instance back to\n\t// avoid it needing to be unlocked again.\n\twalletUnlockMsg := &WalletUnlockMsg{\n\t\tPassphrase:     password,\n\t\tRecoveryWindow: recoveryWindow,\n\t\tWallet:         unlockedWallet,\n\t\tUnloadWallet:   unloadFn,\n\t\tStatelessInit:  in.StatelessInit,\n\t}\n\n\t// Before we return the unlock payload, we'll check if we can extract\n\t// any channel backups to pass up to the higher level sub-system.\n\tchansToRestore := extractChanBackups(in.ChannelBackups)\n\tif chansToRestore != nil {\n\t\twalletUnlockMsg.ChanBackups = *chansToRestore\n\t}\n\n\t// At this point we were able to open the existing wallet with the\n\t// provided password. We send the password over the UnlockMsgs\n\t// channel, such that it can be used by lnd to open the wallet.\n\tselect {\n\tcase u.UnlockMsgs <- walletUnlockMsg:\n\t\t// We need to read from the channel to let the daemon continue\n\t\t// its work. But we don't need the returned macaroon for this\n\t\t// operation, so we read it but then discard it.\n\t\tselect {\n\t\tcase <-u.MacResponseChan:\n\t\t\treturn &lnrpc.UnlockWalletResponse{}, nil\n\n\t\tcase <-ctx.Done():\n\t\t\treturn nil, ErrUnlockTimeout\n\t\t}\n\n\tcase <-ctx.Done():\n\t\treturn nil, ErrUnlockTimeout\n\t}\n}\n\n// ChangePassword changes the password of the wallet and sends the new password\n// across the UnlockPasswords channel to automatically unlock the wallet if\n// successful.",
      "length": 1602,
      "tokens": 224,
      "embedding": []
    },
    {
      "slug": "func (u *UnlockerService) ChangePassword(ctx context.Context,",
      "content": "func (u *UnlockerService) ChangePassword(ctx context.Context,\n\tin *lnrpc.ChangePasswordRequest) (*lnrpc.ChangePasswordResponse, error) {\n\n\tloader, err := u.newLoader(0)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// First, we'll make sure the wallet exists for the specific chain and\n\t// network.\n\twalletExists, err := loader.WalletExists()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif !walletExists {\n\t\treturn nil, errors.New(\"wallet not found\")\n\t}\n\n\tpublicPw := in.CurrentPassword\n\tprivatePw := in.CurrentPassword\n\n\t// If the current password is blank, we'll assume the user is coming\n\t// from a --noseedbackup state, so we'll use the default passwords.\n\tif len(in.CurrentPassword) == 0 {\n\t\tpublicPw = lnwallet.DefaultPublicPassphrase\n\t\tprivatePw = lnwallet.DefaultPrivatePassphrase\n\t}\n\n\t// Make sure the new password meets our constraints.\n\tif err := ValidatePassword(in.NewPassword); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Load the existing wallet in order to proceed with the password change.\n\tw, err := loader.OpenExistingWallet(publicPw, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Now that we've opened the wallet, we need to close it in case of an\n\t// error. But not if we succeed, then the caller must close it.\n\torderlyReturn := false\n\tdefer func() {\n\t\tif !orderlyReturn {\n\t\t\t_ = loader.UnloadWallet()\n\t\t}\n\t}()\n\n\t// Before we actually change the password, we need to check if all flags\n\t// were set correctly. The content of the previously generated macaroon\n\t// files will become invalid after we generate a new root key. So we try\n\t// to delete them here and they will be recreated during normal startup\n\t// later. If they are missing, this is only an error if the\n\t// stateless_init flag was not set.\n\tif in.NewMacaroonRootKey || in.StatelessInit {\n\t\tfor _, file := range u.macaroonFiles {\n\t\t\terr := os.Remove(file)\n\t\t\tif err != nil && !in.StatelessInit {\n\t\t\t\treturn nil, fmt.Errorf(\"could not remove \"+\n\t\t\t\t\t\"macaroon file: %v. if the wallet \"+\n\t\t\t\t\t\"was initialized stateless please \"+\n\t\t\t\t\t\"add the --stateless_init \"+\n\t\t\t\t\t\"flag\", err)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Attempt to change both the public and private passphrases for the\n\t// wallet. This will be done atomically in order to prevent one\n\t// passphrase change from being successful and not the other.\n\terr = w.ChangePassphrases(\n\t\tpublicPw, in.NewPassword, privatePw, in.NewPassword,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to change wallet passphrase: \"+\n\t\t\t\"%v\", err)\n\t}\n\n\t// The next step is to load the macaroon database, change the password\n\t// then close it again.\n\t// Attempt to open the macaroon DB, unlock it and then change\n\t// the passphrase.\n\trootKeyStore, err := macaroons.NewRootKeyStorage(u.macaroonDB)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tmacaroonService, err := macaroons.NewService(\n\t\trootKeyStore, \"lnd\", in.StatelessInit,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = macaroonService.CreateUnlock(&privatePw)\n\tif err != nil {\n\t\tcloseErr := macaroonService.Close()\n\t\tif closeErr != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not create unlock: %v \"+\n\t\t\t\t\"--> follow-up error when closing: %v\", err,\n\t\t\t\tcloseErr)\n\t\t}\n\t\treturn nil, err\n\t}\n\terr = macaroonService.ChangePassword(privatePw, in.NewPassword)\n\tif err != nil {\n\t\tcloseErr := macaroonService.Close()\n\t\tif closeErr != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not change password: %v \"+\n\t\t\t\t\"--> follow-up error when closing: %v\", err,\n\t\t\t\tcloseErr)\n\t\t}\n\t\treturn nil, err\n\t}\n\n\t// If requested by the user, attempt to replace the existing\n\t// macaroon root key with a new one.\n\tif in.NewMacaroonRootKey {\n\t\terr = macaroonService.GenerateNewRootKey()\n\t\tif err != nil {\n\t\t\tcloseErr := macaroonService.Close()\n\t\t\tif closeErr != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"could not generate \"+\n\t\t\t\t\t\"new root key: %v --> follow-up error \"+\n\t\t\t\t\t\"when closing: %v\", err, closeErr)\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\terr = macaroonService.Close()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not close macaroon service: %v\",\n\t\t\terr)\n\t}\n\n\t// Finally, send the new password across the UnlockPasswords channel to\n\t// automatically unlock the wallet.\n\twalletUnlockMsg := &WalletUnlockMsg{\n\t\tPassphrase:    in.NewPassword,\n\t\tWallet:        w,\n\t\tStatelessInit: in.StatelessInit,\n\t\tUnloadWallet:  loader.UnloadWallet,\n\t}\n\tselect {\n\tcase u.UnlockMsgs <- walletUnlockMsg:\n\t\t// We need to read from the channel to let the daemon continue\n\t\t// its work and to get the admin macaroon. Once the response\n\t\t// arrives, we directly forward it to the client.\n\t\torderlyReturn = true\n\t\tselect {\n\t\tcase adminMac := <-u.MacResponseChan:\n\t\t\treturn &lnrpc.ChangePasswordResponse{\n\t\t\t\tAdminMacaroon: adminMac,\n\t\t\t}, nil\n\n\t\tcase <-ctx.Done():\n\t\t\treturn nil, ErrUnlockTimeout\n\t\t}\n\n\tcase <-ctx.Done():\n\t\treturn nil, ErrUnlockTimeout\n\t}\n}\n\n// ValidatePassword assures the password meets all of our constraints.",
      "length": 4594,
      "tokens": 692,
      "embedding": []
    },
    {
      "slug": "func ValidatePassword(password []byte) error {",
      "content": "func ValidatePassword(password []byte) error {\n\t// Passwords should have a length of at least 8 characters.\n\tif len(password) < 8 {\n\t\treturn errors.New(\"password must have at least 8 characters\")\n\t}\n\n\treturn nil\n}\n",
      "length": 160,
      "tokens": 28,
      "embedding": []
    }
  ]
}