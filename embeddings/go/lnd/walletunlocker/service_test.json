{
  "filepath": "../implementations/go/lnd/walletunlocker/service_test.go",
  "package": "walletunlocker_test",
  "sections": [
    {
      "slug": "func testLoaderOpts(testDir string) []btcwallet.LoaderOption {",
      "content": "func testLoaderOpts(testDir string) []btcwallet.LoaderOption {\n\tdbDir := btcwallet.NetworkDir(testDir, testNetParams)\n\treturn []btcwallet.LoaderOption{\n\t\tbtcwallet.LoaderWithLocalWalletDB(dbDir, true, time.Minute),\n\t}\n}\n",
      "length": 152,
      "tokens": 11,
      "embedding": []
    },
    {
      "slug": "func createTestWallet(t *testing.T, dir string, netParams *chaincfg.Params) {",
      "content": "func createTestWallet(t *testing.T, dir string, netParams *chaincfg.Params) {\n\tcreateTestWalletWithPw(t, testPassword, testPassword, dir, netParams)\n}\n",
      "length": 71,
      "tokens": 6,
      "embedding": []
    },
    {
      "slug": "func createTestWalletWithPw(t *testing.T, pubPw, privPw []byte, dir string,",
      "content": "func createTestWalletWithPw(t *testing.T, pubPw, privPw []byte, dir string,\n\tnetParams *chaincfg.Params) {\n\n\t// Instruct waddrmgr to use the cranked down scrypt parameters when\n\t// creating new wallet encryption keys.\n\tfastScrypt := waddrmgr.FastScryptOptions\n\tkeyGen := func(passphrase *[]byte, config *waddrmgr.ScryptOptions) (\n\t\t*snacl.SecretKey, error) {\n\n\t\treturn snacl.NewSecretKey(\n\t\t\tpassphrase, fastScrypt.N, fastScrypt.R, fastScrypt.P,\n\t\t)\n\t}\n\twaddrmgr.SetSecretKeyGen(keyGen)\n\n\t// Create a new test wallet that uses fast scrypt as KDF.\n\tnetDir := btcwallet.NetworkDir(dir, netParams)\n\tloader := wallet.NewLoader(\n\t\tnetParams, netDir, true, kvdb.DefaultDBTimeout, 0,\n\t)\n\t_, err := loader.CreateNewWallet(\n\t\tpubPw, privPw, testSeed, time.Time{},\n\t)\n\trequire.NoError(t, err)\n\terr = loader.UnloadWallet()\n\trequire.NoError(t, err)\n}\n",
      "length": 737,
      "tokens": 84,
      "embedding": []
    },
    {
      "slug": "func createSeedAndMnemonic(t *testing.T,",
      "content": "func createSeedAndMnemonic(t *testing.T,\n\tpass []byte) (*aezeed.CipherSeed, aezeed.Mnemonic) {\n\n\tcipherSeed, err := aezeed.New(\n\t\tkeychain.CurrentKeyDerivationVersion, &testEntropy, time.Now(),\n\t)\n\trequire.NoError(t, err)\n\n\t// With the new seed created, we'll convert it into a mnemonic phrase\n\t// that we'll send over to initialize the wallet.\n\tmnemonic, err := cipherSeed.ToMnemonic(pass)\n\trequire.NoError(t, err)\n\treturn cipherSeed, mnemonic\n}\n\n// openOrCreateTestMacStore opens or creates a bbolt DB and then initializes a\n// root key storage for that DB and then unlocks it, creating a root key in the\n// process.",
      "length": 561,
      "tokens": 78,
      "embedding": []
    },
    {
      "slug": "func openOrCreateTestMacStore(tempDir string, pw *[]byte,",
      "content": "func openOrCreateTestMacStore(tempDir string, pw *[]byte,\n\tnetParams *chaincfg.Params) (*macaroons.RootKeyStorage, error) {\n\n\tnetDir := btcwallet.NetworkDir(tempDir, netParams)\n\terr := os.MkdirAll(netDir, 0700)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdb, err := kvdb.Create(\n\t\tkvdb.BoltBackendName, path.Join(netDir, \"macaroons.db\"),\n\t\ttrue, kvdb.DefaultDBTimeout,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tstore, err := macaroons.NewRootKeyStorage(db)\n\tif err != nil {\n\t\t_ = db.Close()\n\t\treturn nil, err\n\t}\n\n\terr = store.CreateUnlock(pw)\n\tif err != nil {\n\t\t_ = store.Close()\n\t\treturn nil, err\n\t}\n\t_, _, err = store.RootKey(defaultRootKeyIDContext)\n\tif err != nil {\n\t\t_ = store.Close()\n\t\treturn nil, err\n\t}\n\n\treturn store, nil\n}\n\n// TestGenSeedUserEntropy tests that the gen seed method generates a valid\n// cipher seed mnemonic phrase and user provided source of entropy.",
      "length": 778,
      "tokens": 115,
      "embedding": []
    },
    {
      "slug": "func TestGenSeed(t *testing.T) {",
      "content": "func TestGenSeed(t *testing.T) {\n\tt.Parallel()\n\n\t// First, we'll create a new test directory and unlocker service for\n\t// that directory.\n\ttestDir := t.TempDir()\n\n\tservice := walletunlocker.New(\n\t\ttestNetParams, nil, false, testLoaderOpts(testDir),\n\t)\n\n\t// Now that the service has been created, we'll ask it to generate a\n\t// new seed for us given a test passphrase.\n\taezeedPass := []byte(\"kek\")\n\tgenSeedReq := &lnrpc.GenSeedRequest{\n\t\tAezeedPassphrase: aezeedPass,\n\t\tSeedEntropy:      testEntropy[:],\n\t}\n\n\tctx := context.Background()\n\tseedResp, err := service.GenSeed(ctx, genSeedReq)\n\trequire.NoError(t, err)\n\n\t// We should then be able to take the generated mnemonic, and properly\n\t// decipher both it.\n\tvar mnemonic aezeed.Mnemonic\n\tcopy(mnemonic[:], seedResp.CipherSeedMnemonic[:])\n\t_, err = mnemonic.ToCipherSeed(aezeedPass)\n\trequire.NoError(t, err)\n}\n\n// TestGenSeedInvalidEntropy tests that the gen seed method generates a valid\n// cipher seed mnemonic pass phrase even when the user doesn't provide its own\n// source of entropy.",
      "length": 973,
      "tokens": 129,
      "embedding": []
    },
    {
      "slug": "func TestGenSeedGenerateEntropy(t *testing.T) {",
      "content": "func TestGenSeedGenerateEntropy(t *testing.T) {\n\tt.Parallel()\n\n\t// First, we'll create a new test directory and unlocker service for\n\t// that directory.\n\ttestDir := t.TempDir()\n\tservice := walletunlocker.New(\n\t\ttestNetParams, nil, false, testLoaderOpts(testDir),\n\t)\n\n\t// Now that the service has been created, we'll ask it to generate a\n\t// new seed for us given a test passphrase. Note that we don't actually\n\taezeedPass := []byte(\"kek\")\n\tgenSeedReq := &lnrpc.GenSeedRequest{\n\t\tAezeedPassphrase: aezeedPass,\n\t}\n\n\tctx := context.Background()\n\tseedResp, err := service.GenSeed(ctx, genSeedReq)\n\trequire.NoError(t, err)\n\n\t// We should then be able to take the generated mnemonic, and properly\n\t// decipher both it.\n\tvar mnemonic aezeed.Mnemonic\n\tcopy(mnemonic[:], seedResp.CipherSeedMnemonic[:])\n\t_, err = mnemonic.ToCipherSeed(aezeedPass)\n\trequire.NoError(t, err)\n}\n\n// TestGenSeedInvalidEntropy tests that if a user attempt to create a seed with\n// the wrong number of bytes for the initial entropy, then the proper error is\n// returned.",
      "length": 959,
      "tokens": 133,
      "embedding": []
    },
    {
      "slug": "func TestGenSeedInvalidEntropy(t *testing.T) {",
      "content": "func TestGenSeedInvalidEntropy(t *testing.T) {\n\tt.Parallel()\n\n\t// First, we'll create a new test directory and unlocker service for\n\t// that directory.\n\ttestDir := t.TempDir()\n\tservice := walletunlocker.New(\n\t\ttestNetParams, nil, false, testLoaderOpts(testDir),\n\t)\n\n\t// Now that the service has been created, we'll ask it to generate a\n\t// new seed for us given a test passphrase. However, we'll be using an\n\t// invalid set of entropy that's 55 bytes, instead of 15 bytes.\n\taezeedPass := []byte(\"kek\")\n\tgenSeedReq := &lnrpc.GenSeedRequest{\n\t\tAezeedPassphrase: aezeedPass,\n\t\tSeedEntropy:      bytes.Repeat([]byte(\"a\"), 55),\n\t}\n\n\t// We should get an error now since the entropy source was invalid.\n\tctx := context.Background()\n\t_, err := service.GenSeed(ctx, genSeedReq)\n\trequire.Error(t, err)\n\trequire.Contains(t, err.Error(), \"incorrect entropy length\")\n}\n\n// TestInitWallet tests that the user is able to properly initialize the wallet\n// given an existing cipher seed passphrase.",
      "length": 908,
      "tokens": 128,
      "embedding": []
    },
    {
      "slug": "func TestInitWallet(t *testing.T) {",
      "content": "func TestInitWallet(t *testing.T) {\n\tt.Parallel()\n\n\t// testDir is empty, meaning wallet was not created from before.\n\ttestDir := t.TempDir()\n\n\t// Create new UnlockerService.\n\tservice := walletunlocker.New(\n\t\ttestNetParams, nil, false, testLoaderOpts(testDir),\n\t)\n\n\t// Once we have the unlocker service created, we'll now instantiate a\n\t// new cipher seed and its mnemonic.\n\tpass := []byte(\"test\")\n\tcipherSeed, mnemonic := createSeedAndMnemonic(t, pass)\n\n\t// Now that we have all the necessary items, we'll now issue the Init\n\t// command to the wallet. This should check the validity of the cipher\n\t// seed, then send over the initialization information over the init\n\t// channel.\n\tctx := context.Background()\n\treq := &lnrpc.InitWalletRequest{\n\t\tWalletPassword:     testPassword,\n\t\tCipherSeedMnemonic: mnemonic[:],\n\t\tAezeedPassphrase:   pass,\n\t\tRecoveryWindow:     int32(testRecoveryWindow),\n\t\tStatelessInit:      true,\n\t}\n\terrChan := make(chan error, 1)\n\tgo func() {\n\t\tresponse, err := service.InitWallet(ctx, req)\n\t\tif err != nil {\n\t\t\terrChan <- err\n\t\t\treturn\n\t\t}\n\n\t\tif !bytes.Equal(response.AdminMacaroon, testMac) {\n\t\t\terrChan <- fmt.Errorf(\"mismatched macaroon: \"+\n\t\t\t\t\"expected %x, got %x\", testMac,\n\t\t\t\tresponse.AdminMacaroon)\n\t\t}\n\t}()\n\n\t// The same user passphrase, and also the plaintext cipher seed\n\t// should be sent over and match exactly.\n\tselect {\n\tcase err := <-errChan:\n\t\tt.Fatalf(\"InitWallet call failed: %v\", err)\n\n\tcase msg := <-service.InitMsgs:\n\t\tmsgSeed := msg.WalletSeed\n\t\trequire.Equal(t, testPassword, msg.Passphrase)\n\t\trequire.Equal(\n\t\t\tt, cipherSeed.InternalVersion, msgSeed.InternalVersion,\n\t\t)\n\t\trequire.Equal(t, cipherSeed.Birthday, msgSeed.Birthday)\n\t\trequire.Equal(t, cipherSeed.Entropy, msgSeed.Entropy)\n\t\trequire.Equal(t, testRecoveryWindow, msg.RecoveryWindow)\n\t\trequire.Equal(t, true, msg.StatelessInit)\n\n\t\t// Send a fake macaroon that should be returned in the response\n\t\t// in the async code above.\n\t\tservice.MacResponseChan <- testMac\n\n\tcase <-time.After(defaultTestTimeout):\n\t\tt.Fatalf(\"password not received\")\n\t}\n\n\t// Create a wallet in testDir.\n\tcreateTestWallet(t, testDir, testNetParams)\n\n\t// Now calling InitWallet should fail, since a wallet already exists in\n\t// the directory.\n\t_, err := service.InitWallet(ctx, req)\n\trequire.Error(t, err)\n\n\t// Similarly, if we try to do GenSeed again, we should get an error as\n\t// the wallet already exists.\n\t_, err = service.GenSeed(ctx, &lnrpc.GenSeedRequest{})\n\trequire.Error(t, err)\n}\n\n// TestInitWalletInvalidCipherSeed tests that if we attempt to create a wallet\n// with an invalid cipher seed, then we'll receive an error.",
      "length": 2494,
      "tokens": 316,
      "embedding": []
    },
    {
      "slug": "func TestCreateWalletInvalidEntropy(t *testing.T) {",
      "content": "func TestCreateWalletInvalidEntropy(t *testing.T) {\n\tt.Parallel()\n\n\t// testDir is empty, meaning wallet was not created from before.\n\ttestDir := t.TempDir()\n\n\t// Create new UnlockerService.\n\tservice := walletunlocker.New(\n\t\ttestNetParams, nil, false, testLoaderOpts(testDir),\n\t)\n\n\t// We'll attempt to init the wallet with an invalid cipher seed and\n\t// passphrase.\n\treq := &lnrpc.InitWalletRequest{\n\t\tWalletPassword:     testPassword,\n\t\tCipherSeedMnemonic: []string{\"invalid\", \"seed\"},\n\t\tAezeedPassphrase:   []byte(\"fake pass\"),\n\t}\n\n\tctx := context.Background()\n\t_, err := service.InitWallet(ctx, req)\n\trequire.Error(t, err)\n}\n\n// TestUnlockWallet checks that trying to unlock non-existing wallet fail, that\n// unlocking existing wallet with wrong passphrase fails, and that unlocking\n// existing wallet with correct passphrase succeeds.",
      "length": 760,
      "tokens": 94,
      "embedding": []
    },
    {
      "slug": "func TestUnlockWallet(t *testing.T) {",
      "content": "func TestUnlockWallet(t *testing.T) {\n\tt.Parallel()\n\n\t// testDir is empty, meaning wallet was not created from before.\n\ttestDir := t.TempDir()\n\n\t// Create new UnlockerService that'll also drop the wallet's history on\n\t// unlock.\n\tservice := walletunlocker.New(\n\t\ttestNetParams, nil, true, testLoaderOpts(testDir),\n\t)\n\n\tctx := context.Background()\n\treq := &lnrpc.UnlockWalletRequest{\n\t\tWalletPassword: testPassword,\n\t\tRecoveryWindow: int32(testRecoveryWindow),\n\t\tStatelessInit:  true,\n\t}\n\n\t// Should fail to unlock non-existing wallet.\n\t_, err := service.UnlockWallet(ctx, req)\n\trequire.Error(t, err)\n\n\t// Create a wallet we can try to unlock.\n\tcreateTestWallet(t, testDir, testNetParams)\n\n\t// Try unlocking this wallet with the wrong passphrase.\n\twrongReq := &lnrpc.UnlockWalletRequest{\n\t\tWalletPassword: []byte(\"wrong-ofc\"),\n\t}\n\t_, err = service.UnlockWallet(ctx, wrongReq)\n\trequire.Error(t, err)\n\n\t// With the correct password, we should be able to unlock the wallet.\n\terrChan := make(chan error, 1)\n\tgo func() {\n\t\t// With the correct password, we should be able to unlock the\n\t\t// wallet.\n\t\t_, err := service.UnlockWallet(ctx, req)\n\t\tif err != nil {\n\t\t\terrChan <- err\n\t\t}\n\t}()\n\n\t// Password and recovery window should be sent over the channel.\n\tselect {\n\tcase err := <-errChan:\n\t\tt.Fatalf(\"UnlockWallet call failed: %v\", err)\n\n\tcase unlockMsg := <-service.UnlockMsgs:\n\t\trequire.Equal(t, testPassword, unlockMsg.Passphrase)\n\t\trequire.Equal(t, testRecoveryWindow, unlockMsg.RecoveryWindow)\n\t\trequire.Equal(t, true, unlockMsg.StatelessInit)\n\n\t\t// Send a fake macaroon that should be returned in the response\n\t\t// in the async code above.\n\t\tservice.MacResponseChan <- testMac\n\t\trequire.NoError(t, unlockMsg.UnloadWallet())\n\n\tcase <-time.After(defaultTestTimeout):\n\t\tt.Fatalf(\"password not received\")\n\t}\n}\n\n// TestChangeWalletPasswordNewRootKey tests that we can successfully change the\n// wallet's password needed to unlock it and rotate the root key for the\n// macaroons in the same process.",
      "length": 1888,
      "tokens": 241,
      "embedding": []
    },
    {
      "slug": "func TestChangeWalletPasswordNewRootKey(t *testing.T) {",
      "content": "func TestChangeWalletPasswordNewRootKey(t *testing.T) {\n\tt.Parallel()\n\n\t// testDir is empty, meaning wallet was not created from before.\n\ttestDir := t.TempDir()\n\n\t// Changing the password of the wallet will also try to change the\n\t// password of the macaroon DB. We create a default DB here but close it\n\t// immediately so the service does not fail when trying to open it.\n\tstore, err := openOrCreateTestMacStore(\n\t\ttestDir, &testPassword, testNetParams,\n\t)\n\trequire.NoError(t, err)\n\trequire.NoError(t, store.Close())\n\n\t// Create some files that will act as macaroon files that should be\n\t// deleted after a password change is successful with a new root key\n\t// requested.\n\tvar tempFiles []string\n\tfor i := 0; i < 3; i++ {\n\t\tfile, err := os.CreateTemp(testDir, \"\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to create temp file: %v\", err)\n\t\t}\n\t\ttempFiles = append(tempFiles, file.Name())\n\t\trequire.NoError(t, file.Close())\n\t}\n\n\t// Create a new UnlockerService with our temp files.\n\tservice := walletunlocker.New(\n\t\ttestNetParams, tempFiles, false, testLoaderOpts(testDir),\n\t)\n\tservice.SetMacaroonDB(store.Backend)\n\n\tctx := context.Background()\n\tnewPassword := []byte(\"hunter2???\")\n\n\treq := &lnrpc.ChangePasswordRequest{\n\t\tCurrentPassword:    testPassword,\n\t\tNewPassword:        newPassword,\n\t\tNewMacaroonRootKey: true,\n\t}\n\n\t// Changing the password to a non-existing wallet should fail.\n\t_, err = service.ChangePassword(ctx, req)\n\trequire.Error(t, err)\n\n\t// Create a wallet to test changing the password.\n\tcreateTestWallet(t, testDir, testNetParams)\n\n\t// Attempting to change the wallet's password using an incorrect\n\t// current password should fail.\n\twrongReq := &lnrpc.ChangePasswordRequest{\n\t\tCurrentPassword: []byte(\"wrong-ofc\"),\n\t\tNewPassword:     newPassword,\n\t}\n\t_, err = service.ChangePassword(ctx, wrongReq)\n\trequire.Error(t, err)\n\n\t// The files should still exist after an unsuccessful attempt to change\n\t// the wallet's password.\n\tfor _, tempFile := range tempFiles {\n\t\tif _, err := os.Stat(tempFile); os.IsNotExist(err) {\n\t\t\tt.Fatal(\"file does not exist but it should\")\n\t\t}\n\t}\n\n\t// Attempting to change the wallet's password using an invalid\n\t// new password should fail.\n\twrongReq.NewPassword = []byte(\"8\")\n\t_, err = service.ChangePassword(ctx, wrongReq)\n\trequire.Error(t, err)\n\n\t// When providing the correct wallet's current password and a new\n\t// password that meets the length requirement, the password change\n\t// should succeed.\n\terrChan := make(chan error, 1)\n\tgo doChangePassword(service, testDir, req, errChan)\n\n\t// The new password should be sent over the channel.\n\tselect {\n\tcase err := <-errChan:\n\t\tt.Fatalf(\"ChangePassword call failed: %v\", err)\n\n\tcase unlockMsg := <-service.UnlockMsgs:\n\t\trequire.Equal(t, newPassword, unlockMsg.Passphrase)\n\n\t\t// Send a fake macaroon that should be returned in the response\n\t\t// in the async code above.\n\t\tservice.MacResponseChan <- testMac\n\t\trequire.NoError(t, unlockMsg.UnloadWallet())\n\n\tcase <-time.After(defaultTestTimeout):\n\t\tt.Fatalf(\"password not received\")\n\t}\n\n\t// The files should no longer exist.\n\tfor _, tempFile := range tempFiles {\n\t\tf, err := os.Open(tempFile)\n\t\tif err == nil {\n\t\t\t_ = f.Close()\n\t\t\tt.Fatal(\"file exists but it shouldn't\")\n\t\t}\n\t}\n}\n\n// TestChangeWalletPasswordStateless checks that trying to change the password\n// of an existing wallet that was initialized stateless works when when the\n// --stateless_init flat is set. Also checks that if no password is given,\n// the default password is used.",
      "length": 3316,
      "tokens": 456,
      "embedding": []
    },
    {
      "slug": "func TestChangeWalletPasswordStateless(t *testing.T) {",
      "content": "func TestChangeWalletPasswordStateless(t *testing.T) {\n\tt.Parallel()\n\n\t// testDir is empty, meaning wallet was not created from before.\n\ttestDir := t.TempDir()\n\n\t// Changing the password of the wallet will also try to change the\n\t// password of the macaroon DB. We create a default DB here but close it\n\t// immediately so the service does not fail when trying to open it.\n\tstore, err := openOrCreateTestMacStore(\n\t\ttestDir, &lnwallet.DefaultPrivatePassphrase, testNetParams,\n\t)\n\trequire.NoError(t, err)\n\trequire.NoError(t, store.Close())\n\n\t// Create a temp file that will act as the macaroon DB file that will\n\t// be deleted by changing the password.\n\ttmpFile, err := os.CreateTemp(testDir, \"\")\n\trequire.NoError(t, err)\n\ttempMacFile := tmpFile.Name()\n\terr = tmpFile.Close()\n\trequire.NoError(t, err)\n\n\t// Create a file name that does not exist that will be used as a\n\t// macaroon file reference. The fact that the file does not exist should\n\t// not throw an error when --stateless_init is used.\n\tnonExistingFile := path.Join(testDir, \"does-not-exist\")\n\n\t// Create a new UnlockerService with our temp files.\n\tservice := walletunlocker.New(\n\t\ttestNetParams, []string{\n\t\t\ttempMacFile, nonExistingFile,\n\t\t}, false, testLoaderOpts(testDir),\n\t)\n\tservice.SetMacaroonDB(store.Backend)\n\n\t// Create a wallet we can try to unlock. We use the default password\n\t// so we can check that the unlocker service defaults to this when\n\t// we give it an empty CurrentPassword to indicate we come from a\n\t// --noencryptwallet state.\n\tcreateTestWalletWithPw(\n\t\tt, lnwallet.DefaultPublicPassphrase,\n\t\tlnwallet.DefaultPrivatePassphrase, testDir, testNetParams,\n\t)\n\n\t// We make sure that we get a proper error message if we forget to\n\t// add the --stateless_init flag but the macaroon files don't exist.\n\tbadReq := &lnrpc.ChangePasswordRequest{\n\t\tNewPassword:        testPassword,\n\t\tNewMacaroonRootKey: true,\n\t}\n\tctx := context.Background()\n\t_, err = service.ChangePassword(ctx, badReq)\n\trequire.Error(t, err)\n\n\t// Prepare the correct request we are going to send to the unlocker\n\t// service. We don't provide a current password to indicate there\n\t// was none set before.\n\treq := &lnrpc.ChangePasswordRequest{\n\t\tNewPassword:        testPassword,\n\t\tStatelessInit:      true,\n\t\tNewMacaroonRootKey: true,\n\t}\n\n\t// Since we indicated the wallet was initialized stateless, the service\n\t// will block until it receives the macaroon through the channel\n\t// provided in the message in UnlockMsgs. So we need to call the service\n\t// async and then wait for the unlock message to arrive so we can send\n\t// back a fake macaroon.\n\terrChan := make(chan error, 1)\n\tgo doChangePassword(service, testDir, req, errChan)\n\n\t// Password and recovery window should be sent over the channel.\n\tselect {\n\tcase err := <-errChan:\n\t\tt.Fatalf(\"ChangePassword call failed: %v\", err)\n\n\tcase unlockMsg := <-service.UnlockMsgs:\n\t\trequire.Equal(t, testPassword, unlockMsg.Passphrase)\n\n\t\t// Send a fake macaroon that should be returned in the response\n\t\t// in the async code above.\n\t\tservice.MacResponseChan <- testMac\n\t\trequire.NoError(t, unlockMsg.UnloadWallet())\n\n\tcase <-time.After(defaultTestTimeout):\n\t\tt.Fatalf(\"password not received\")\n\t}\n}\n",
      "length": 3044,
      "tokens": 425,
      "embedding": []
    },
    {
      "slug": "func doChangePassword(service *walletunlocker.UnlockerService, testDir string,",
      "content": "func doChangePassword(service *walletunlocker.UnlockerService, testDir string,\n\treq *lnrpc.ChangePasswordRequest, errChan chan error) {\n\n\t// When providing the correct wallet's current password and a new\n\t// password that meets the length requirement, the password change\n\t// should succeed.\n\tctx := context.Background()\n\tresponse, err := service.ChangePassword(ctx, req)\n\tif err != nil {\n\t\terrChan <- fmt.Errorf(\"could not change password: %w\", err)\n\t\treturn\n\t}\n\n\tif !bytes.Equal(response.AdminMacaroon, testMac) {\n\t\terrChan <- fmt.Errorf(\"mismatched macaroon: expected %x, got \"+\n\t\t\t\"%x\", testMac, response.AdminMacaroon)\n\t}\n\n\t// Close the macaroon DB and try to open it and read the root key with\n\t// the new password.\n\tstore, err := openOrCreateTestMacStore(\n\t\ttestDir, &testPassword, testNetParams,\n\t)\n\tif err != nil {\n\t\terrChan <- fmt.Errorf(\"could not create test store: %w\", err)\n\t\treturn\n\t}\n\t_, _, err = store.RootKey(defaultRootKeyIDContext)\n\tif err != nil {\n\t\terrChan <- fmt.Errorf(\"could not get root key: %w\", err)\n\t\treturn\n\t}\n\n\t// Do cleanup now. Since we are in a go func, the defer at the top of\n\t// the outer would not work, because it would delete the directory\n\t// before we could check the content in here.\n\terr = store.Close()\n\tif err != nil {\n\t\terrChan <- fmt.Errorf(\"could not close store: %w\", err)\n\t\treturn\n\t}\n\n\t// The backend database isn't closed automatically if the store is\n\t// closed, do that now manually.\n\terr = store.Backend.Close()\n\tif err != nil {\n\t\terrChan <- fmt.Errorf(\"could not close db: %w\", err)\n\t\treturn\n\t}\n}\n",
      "length": 1425,
      "tokens": 226,
      "embedding": []
    }
  ]
}