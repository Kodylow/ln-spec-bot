{
  "filepath": "../implementations/go/lnd/tls_manager_test.go",
  "package": "lnd",
  "sections": [
    {
      "slug": "func TestGenerateOrRenewCert(t *testing.T) {",
      "content": "func TestGenerateOrRenewCert(t *testing.T) {\n\tt.Parallel()\n\n\t// Write an expired certificate to disk.\n\tcertPath, keyPath, expiredCert := writeTestCertFiles(\n\t\tt, true, false, nil,\n\t)\n\n\t// Now let's run the TLSManager's getConfig. If it works properly, it\n\t// should delete the cert and create a new one.\n\tcfg := &TLSManagerCfg{\n\t\tTLSCertPath:     certPath,\n\t\tTLSKeyPath:      keyPath,\n\t\tTLSCertDuration: testTLSCertDuration,\n\t}\n\ttlsManager := NewTLSManager(cfg)\n\t_, cleanUp, err := tlsManager.generateOrRenewCert()\n\trequire.NoError(t, err)\n\t_, _, _, err = tlsManager.getConfig()\n\trequire.NoError(t, err, \"couldn't retrieve TLS config\")\n\tt.Cleanup(cleanUp)\n\n\t// Grab the certificate to test that getTLSConfig did its job correctly\n\t// and generated a new cert.\n\tnewCertData, err := tls.LoadX509KeyPair(certPath, keyPath)\n\trequire.NoError(t, err, \"couldn't grab new certificate\")\n\n\tnewCert, err := x509.ParseCertificate(newCertData.Certificate[0])\n\trequire.NoError(t, err, \"couldn't parse new certificate\")\n\n\t// Check that the expired certificate was successfully deleted and\n\t// replaced with a new one.\n\trequire.True(t, newCert.NotAfter.After(expiredCert.NotAfter),\n\t\t\"New certificate expiration is too old\")\n}\n\n// TestTLSManagerGenCert tests that the new TLS Manager loads correctly,\n// whether the encrypted TLS key flag is set or not.",
      "length": 1256,
      "tokens": 158,
      "embedding": []
    },
    {
      "slug": "func TestTLSManagerGenCert(t *testing.T) {",
      "content": "func TestTLSManagerGenCert(t *testing.T) {\n\tt.Parallel()\n\n\t_, certPath, keyPath := newTestDirectory(t)\n\n\tcfg := &TLSManagerCfg{\n\t\tTLSCertPath: certPath,\n\t\tTLSKeyPath:  keyPath,\n\t}\n\ttlsManager := NewTLSManager(cfg)\n\n\t_, _, err := tlsManager.generateOrRenewCert()\n\trequire.NoError(t, err, \"failed to generate new certificate\")\n\n\t// After this is run, a new certificate should be created and written\n\t// to disk. Since the TLSEncryptKey flag isn't set, we should be able\n\t// to read it in plaintext from disk.\n\t_, keyBytes, err := cert.GetCertBytesFromPath(\n\t\tcfg.TLSCertPath, cfg.TLSKeyPath,\n\t)\n\trequire.NoError(t, err, \"unable to load certificate\")\n\trequire.True(t, bytes.HasPrefix(keyBytes, privateKeyPrefix),\n\t\t\"key is encrypted, but shouldn't be\")\n\n\t// Now test that if the TLSEncryptKey flag is set, an encrypted key is\n\t// created and written to disk.\n\t_, certPath, keyPath = newTestDirectory(t)\n\n\tcfg = &TLSManagerCfg{\n\t\tTLSEncryptKey:   true,\n\t\tTLSCertPath:     certPath,\n\t\tTLSKeyPath:      keyPath,\n\t\tTLSCertDuration: testTLSCertDuration,\n\t}\n\ttlsManager = NewTLSManager(cfg)\n\tkeyRing := &mock.SecretKeyRing{\n\t\tRootKey: privKey,\n\t}\n\n\terr = tlsManager.generateCertPair(keyRing)\n\trequire.NoError(t, err, \"failed to generate new certificate\")\n\n\t_, keyBytes, err = cert.GetCertBytesFromPath(\n\t\tcertPath, keyPath,\n\t)\n\trequire.NoError(t, err, \"unable to load certificate\")\n\trequire.False(t, bytes.HasPrefix(keyBytes, privateKeyPrefix),\n\t\t\"key isn't encrypted, but should be\")\n}\n\n// TestEnsureEncryption tests that ensureEncryption does a couple of things:\n// 1) If we have cfg.TLSEncryptKey set, but the tls file saved to disk is not\n// encrypted, generateOrRenewCert encrypts the file and rewrites it to disk.\n// 2) If cfg.TLSEncryptKey is not set, but the file *is* encrypted, then we\n// need to return an error to the user.",
      "length": 1730,
      "tokens": 226,
      "embedding": []
    },
    {
      "slug": "func TestEnsureEncryption(t *testing.T) {",
      "content": "func TestEnsureEncryption(t *testing.T) {\n\tt.Parallel()\n\n\tkeyRing := &mock.SecretKeyRing{\n\t\tRootKey: privKey,\n\t}\n\n\t// Write an unencrypted cert file to disk.\n\tcertPath, keyPath, _ := writeTestCertFiles(\n\t\tt, false, false, keyRing,\n\t)\n\n\tcfg := &TLSManagerCfg{\n\t\tTLSEncryptKey: true,\n\t\tTLSCertPath:   certPath,\n\t\tTLSKeyPath:    keyPath,\n\t}\n\ttlsManager := NewTLSManager(cfg)\n\n\t// Check that the keyBytes are initially plaintext.\n\t_, newKeyBytes, err := cert.GetCertBytesFromPath(\n\t\tcfg.TLSCertPath, cfg.TLSKeyPath,\n\t)\n\n\trequire.NoError(t, err, \"unable to load certificate files\")\n\trequire.True(t, bytes.HasPrefix(newKeyBytes, privateKeyPrefix),\n\t\t\"key doesn't have correct plaintext prefix\")\n\n\t// ensureEncryption should detect that the TLS key is in plaintext,\n\t// encrypt it, and rewrite the encrypted version to disk.\n\terr = tlsManager.ensureEncryption(keyRing)\n\trequire.NoError(t, err, \"failed to generate new certificate\")\n\n\t// Grab the file from disk to check that the key is no longer\n\t// plaintext.\n\t_, newKeyBytes, err = cert.GetCertBytesFromPath(\n\t\tcfg.TLSCertPath, cfg.TLSKeyPath,\n\t)\n\trequire.NoError(t, err, \"unable to load certificate\")\n\trequire.False(t, bytes.HasPrefix(newKeyBytes, privateKeyPrefix),\n\t\t\"key isn't encrypted, but should be\")\n\n\t// Now let's flip the cfg.TLSEncryptKey to false. Since the key on file\n\t// is encrypted, ensureEncryption should error out.\n\ttlsManager.cfg.TLSEncryptKey = false\n\terr = tlsManager.ensureEncryption(keyRing)\n\trequire.Error(t, err)\n}\n\n// TestGenerateEphemeralCert tests that an ephemeral certificate is created and\n// stored to disk in a .tmp file and that LoadPermanentCertificate deletes\n// file and replaces it with a fresh certificate pair.",
      "length": 1605,
      "tokens": 201,
      "embedding": []
    },
    {
      "slug": "func TestGenerateEphemeralCert(t *testing.T) {",
      "content": "func TestGenerateEphemeralCert(t *testing.T) {\n\tt.Parallel()\n\n\t_, certPath, keyPath := newTestDirectory(t)\n\ttmpCertPath := certPath + \".tmp\"\n\n\tcfg := &TLSManagerCfg{\n\t\tTLSCertPath:     certPath,\n\t\tTLSKeyPath:      keyPath,\n\t\tTLSEncryptKey:   true,\n\t\tTLSCertDuration: testTLSCertDuration,\n\t}\n\ttlsManager := NewTLSManager(cfg)\n\n\tkeyBytes, err := tlsManager.loadEphemeralCertificate()\n\trequire.NoError(t, err, \"failed to generate new certificate\")\n\n\tcertBytes, err := ioutil.ReadFile(tmpCertPath)\n\trequire.NoError(t, err)\n\n\ttlsr, err := cert.NewTLSReloader(certBytes, keyBytes)\n\trequire.NoError(t, err)\n\ttlsManager.tlsReloader = tlsr\n\n\t// Make sure .tmp file is created at the tmp cert path.\n\t_, err = ioutil.ReadFile(tmpCertPath)\n\trequire.NoError(t, err, \"couldn't find temp cert file\")\n\n\t// But no key should be stored.\n\t_, err = ioutil.ReadFile(cfg.TLSKeyPath)\n\trequire.Error(t, err, \"shouldn't have found file\")\n\n\t// And no permanent cert file should be stored.\n\t_, err = ioutil.ReadFile(cfg.TLSCertPath)\n\trequire.Error(t, err, \"shouldn't have found a permanent cert file\")\n\n\t// Now test that when we reload the certificate it generates the new\n\t// certificate properly.\n\tkeyRing := &mock.SecretKeyRing{\n\t\tRootKey: privKey,\n\t}\n\terr = tlsManager.LoadPermanentCertificate(keyRing)\n\trequire.NoError(t, err, \"unable to reload certificate\")\n\n\t// Make sure .tmp file is deleted.\n\t_, _, err = cert.GetCertBytesFromPath(\n\t\ttmpCertPath, cfg.TLSKeyPath,\n\t)\n\trequire.Error(t, err, \".tmp file should have been deleted\")\n\n\t// Make sure a certificate now exists at the permanent cert path.\n\t_, _, err = cert.GetCertBytesFromPath(\n\t\tcfg.TLSCertPath, cfg.TLSKeyPath,\n\t)\n\trequire.NoError(t, err, \"error loading permanent certificate\")\n}\n\n// genCertPair generates a key/cert pair, with the option of generating expired\n// certificates to make sure they are being regenerated correctly.",
      "length": 1764,
      "tokens": 218,
      "embedding": []
    },
    {
      "slug": "func genCertPair(t *testing.T, expired bool) ([]byte, []byte) {",
      "content": "func genCertPair(t *testing.T, expired bool) ([]byte, []byte) {\n\tt.Helper()\n\n\t// Max serial number.\n\tserialNumberLimit := new(big.Int).Lsh(big.NewInt(1), 128)\n\n\t// Generate a serial number that's below the serialNumberLimit.\n\tserialNumber, err := rand.Int(rand.Reader, serialNumberLimit)\n\trequire.NoError(t, err, \"failed to generate serial number\")\n\n\thost := \"lightning\"\n\n\t// Create a simple ip address for the fake certificate.\n\tipAddresses := []net.IP{net.ParseIP(\"127.0.0.1\"), net.ParseIP(\"::1\")}\n\n\tdnsNames := []string{host, \"unix\", \"unixpacket\"}\n\n\tvar notBefore, notAfter time.Time\n\tif expired {\n\t\tnotBefore = time.Now().Add(-time.Hour * 24)\n\t\tnotAfter = time.Now()\n\t} else {\n\t\tnotBefore = time.Now()\n\t\tnotAfter = time.Now().Add(time.Hour * 24)\n\t}\n\n\t// Construct the certificate template.\n\ttemplate := x509.Certificate{\n\t\tSerialNumber: serialNumber,\n\t\tSubject: pkix.Name{\n\t\t\tOrganization: []string{\"lnd autogenerated cert\"},\n\t\t\tCommonName:   host,\n\t\t},\n\t\tNotBefore: notBefore,\n\t\tNotAfter:  notAfter,\n\t\tKeyUsage: x509.KeyUsageKeyEncipherment |\n\t\t\tx509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,\n\t\tIsCA:                  true, // so can sign self.\n\t\tBasicConstraintsValid: true,\n\t\tDNSNames:              dnsNames,\n\t\tIPAddresses:           ipAddresses,\n\t}\n\n\t// Generate a private key for the certificate.\n\tpriv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to generate a private key\")\n\t}\n\n\tcertDerBytes, err := x509.CreateCertificate(\n\t\trand.Reader, &template, &template, &priv.PublicKey, priv,\n\t)\n\trequire.NoError(t, err, \"failed to create certificate\")\n\n\tkeyBytes, err := x509.MarshalECPrivateKey(priv)\n\trequire.NoError(t, err, \"unable to encode privkey\")\n\n\treturn certDerBytes, keyBytes\n}\n\n// writeTestCertFiles creates test files and writes them to a temporary testing\n// directory.",
      "length": 1717,
      "tokens": 191,
      "embedding": []
    },
    {
      "slug": "func writeTestCertFiles(t *testing.T, expiredCert, encryptTLSKey bool,",
      "content": "func writeTestCertFiles(t *testing.T, expiredCert, encryptTLSKey bool,\n\tkeyRing keychain.KeyRing) (string, string, *x509.Certificate) {\n\n\tt.Helper()\n\n\ttempDir, certPath, keyPath := newTestDirectory(t)\n\n\tvar certDerBytes, keyBytes []byte\n\t// Either create a valid certificate or an expired certificate pair,\n\t// depending on the test.\n\tif expiredCert {\n\t\tcertDerBytes, keyBytes = genCertPair(t, true)\n\t} else {\n\t\tcertDerBytes, keyBytes = genCertPair(t, false)\n\t}\n\n\tparsedCert, err := x509.ParseCertificate(certDerBytes)\n\trequire.NoError(t, err, \"failed to parse certificate\")\n\n\tcertBuf := bytes.Buffer{}\n\terr = pem.Encode(\n\t\t&certBuf, &pem.Block{\n\t\t\tType:  \"CERTIFICATE\",\n\t\t\tBytes: certDerBytes,\n\t\t},\n\t)\n\trequire.NoError(t, err, \"failed to encode certificate\")\n\n\tvar keyBuf *bytes.Buffer\n\tif !encryptTLSKey {\n\t\tkeyBuf = &bytes.Buffer{}\n\t\terr = pem.Encode(\n\t\t\tkeyBuf, &pem.Block{\n\t\t\t\tType:  \"EC PRIVATE KEY\",\n\t\t\t\tBytes: keyBytes,\n\t\t\t},\n\t\t)\n\t\trequire.NoError(t, err, \"failed to encode private key\")\n\t} else {\n\t\te, err := lnencrypt.KeyRingEncrypter(keyRing)\n\t\trequire.NoError(t, err, \"unable to generate key encrypter\")\n\t\terr = e.EncryptPayloadToWriter(\n\t\t\tkeyBytes, keyBuf,\n\t\t)\n\t\trequire.NoError(t, err, \"failed to encrypt private key\")\n\t}\n\n\terr = ioutil.WriteFile(tempDir+\"/tls.cert\", certBuf.Bytes(), 0644)\n\trequire.NoError(t, err, \"failed to write cert file\")\n\terr = ioutil.WriteFile(tempDir+\"/tls.key\", keyBuf.Bytes(), 0600)\n\trequire.NoError(t, err, \"failed to write key file\")\n\n\treturn certPath, keyPath, parsedCert\n}\n\n// newTestDirectory creates a new test directory and returns the location of\n// the test tls.cert and tls.key files.",
      "length": 1511,
      "tokens": 184,
      "embedding": []
    },
    {
      "slug": "func newTestDirectory(t *testing.T) (string, string, string) {",
      "content": "func newTestDirectory(t *testing.T) (string, string, string) {\n\tt.Helper()\n\n\ttempDir := t.TempDir()\n\tcertPath := tempDir + \"/tls.cert\"\n\tkeyPath := tempDir + \"/tls.key\"\n\n\treturn tempDir, certPath, keyPath\n}\n",
      "length": 135,
      "tokens": 19,
      "embedding": []
    }
  ]
}