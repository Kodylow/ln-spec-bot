{
  "filepath": "../implementations/go/lnd/itest/lnd_single_hop_invoice_test.go",
  "package": "itest",
  "sections": [
    {
      "slug": "func testSingleHopInvoice(ht *lntest.HarnessTest) {",
      "content": "func testSingleHopInvoice(ht *lntest.HarnessTest) {\n\t// Open a channel with 100k satoshis between Alice and Bob with Alice\n\t// being the sole funder of the channel.\n\tchanAmt := btcutil.Amount(100000)\n\talice, bob := ht.Alice, ht.Bob\n\tcp := ht.OpenChannel(\n\t\talice, bob, lntest.OpenChannelParams{Amt: chanAmt},\n\t)\n\n\t// assertAmountPaid is a helper closure that asserts the amount paid by\n\t// Alice and received by Bob are expected.\n\tassertAmountPaid := func(expected int64) {\n\t\tht.AssertAmountPaid(\"alice -> bob\", alice, cp, expected, 0)\n\t\tht.AssertAmountPaid(\"bob <- alice\", bob, cp, 0, expected)\n\t}\n\n\t// Now that the channel is open, create an invoice for Bob which\n\t// expects a payment of 1000 satoshis from Alice paid via a particular\n\t// preimage.\n\tconst paymentAmt = 1000\n\tpreimage := bytes.Repeat([]byte(\"A\"), 32)\n\tinvoice := &lnrpc.Invoice{\n\t\tMemo:      \"testing\",\n\t\tRPreimage: preimage,\n\t\tValue:     paymentAmt,\n\t}\n\tinvoiceResp := bob.RPC.AddInvoice(invoice)\n\n\t// With the invoice for Bob added, send a payment towards Alice paying\n\t// to the above generated invoice.\n\tht.CompletePaymentRequests(alice, []string{invoiceResp.PaymentRequest})\n\n\t// Bob's invoice should now be found and marked as settled.\n\tdbInvoice := bob.RPC.LookupInvoice(invoiceResp.RHash)\n\trequire.Equal(ht, lnrpc.Invoice_SETTLED, dbInvoice.State,\n\t\t\"bob's invoice should be marked as settled\")\n\n\t// With the payment completed all balance related stats should be\n\t// properly updated.\n\tassertAmountPaid(paymentAmt)\n\n\t// Create another invoice for Bob, this time leaving off the preimage\n\t// to one will be randomly generated. We'll test the proper\n\t// encoding/decoding of the zpay32 payment requests.\n\tinvoice = &lnrpc.Invoice{\n\t\tMemo:  \"test3\",\n\t\tValue: paymentAmt,\n\t}\n\tinvoiceResp = bob.RPC.AddInvoice(invoice)\n\n\t// Next send another payment, but this time using a zpay32 encoded\n\t// invoice rather than manually specifying the payment details.\n\tht.CompletePaymentRequests(alice, []string{invoiceResp.PaymentRequest})\n\n\t// The second payment should also have succeeded, with the balances\n\t// being update accordingly.\n\tassertAmountPaid(paymentAmt * 2)\n\n\t// Next send a keysend payment.\n\tkeySendPreimage := lntypes.Preimage{3, 4, 5, 11}\n\tkeySendHash := keySendPreimage.Hash()\n\n\treq := &routerrpc.SendPaymentRequest{\n\t\tDest:           bob.PubKey[:],\n\t\tAmt:            paymentAmt,\n\t\tFinalCltvDelta: 40,\n\t\tPaymentHash:    keySendHash[:],\n\t\tDestCustomRecords: map[uint64][]byte{\n\t\t\trecord.KeySendType: keySendPreimage[:],\n\t\t},\n\t\tTimeoutSeconds: 60,\n\t\tFeeLimitMsat:   noFeeLimitMsat,\n\t}\n\tht.SendPaymentAssertSettled(alice, req)\n\n\t// The keysend payment should also have succeeded, with the balances\n\t// being update accordingly.\n\tassertAmountPaid(paymentAmt * 3)\n\n\t// Assert that the invoice has the proper AMP fields set, since the\n\t// legacy keysend payment should have been promoted into an AMP payment\n\t// internally.\n\tkeysendInvoice := bob.RPC.LookupInvoice(keySendHash[:])\n\trequire.Len(ht, keysendInvoice.Htlcs, 1)\n\thtlc := keysendInvoice.Htlcs[0]\n\trequire.Zero(ht, htlc.MppTotalAmtMsat)\n\trequire.Nil(ht, htlc.Amp)\n\n\t// Now create an invoice and specify routing hints.\n\t// We will test that the routing hints are encoded properly.\n\thintChannel := lnwire.ShortChannelID{BlockHeight: 10}\n\tbobPubKey := hex.EncodeToString(bob.PubKey[:])\n\thint := &lnrpc.HopHint{\n\t\tNodeId:                    bobPubKey,\n\t\tChanId:                    hintChannel.ToUint64(),\n\t\tFeeBaseMsat:               1,\n\t\tFeeProportionalMillionths: 1000000,\n\t\tCltvExpiryDelta:           20,\n\t}\n\thints := []*lnrpc.RouteHint{{HopHints: []*lnrpc.HopHint{hint}}}\n\n\tinvoice = &lnrpc.Invoice{\n\t\tMemo:       \"hints\",\n\t\tValue:      paymentAmt,\n\t\tRouteHints: hints,\n\t}\n\n\tinvoiceResp = bob.RPC.AddInvoice(invoice)\n\tpayreq := bob.RPC.DecodePayReq(invoiceResp.PaymentRequest)\n\trequire.Len(ht, payreq.RouteHints, 1, \"expected one routing hint\")\n\troutingHint := payreq.RouteHints[0]\n\trequire.Len(ht, routingHint.HopHints, 1, \"expected one hop hint\")\n\n\thopHint := routingHint.HopHints[0]\n\trequire.EqualValues(ht, 1000000, hopHint.FeeProportionalMillionths,\n\t\t\"wrong FeeProportionalMillionths\")\n\trequire.Equal(ht, bobPubKey, hopHint.NodeId, \"wrong NodeId\")\n\trequire.Equal(ht, hintChannel.ToUint64(), hopHint.ChanId,\n\t\t\"wrong ChanId\")\n\trequire.EqualValues(ht, 1, hopHint.FeeBaseMsat, \"wrong FeeBaseMsat\")\n\trequire.EqualValues(ht, 20, hopHint.CltvExpiryDelta,\n\t\t\"wrong CltvExpiryDelta\")\n\n\tht.CloseChannel(alice, cp)\n}\n",
      "length": 4268,
      "tokens": 473,
      "embedding": []
    }
  ]
}