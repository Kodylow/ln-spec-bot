{
  "filepath": "../implementations/go/lnd/itest/lnd_zero_conf_test.go",
  "package": "itest",
  "sections": [
    {
      "slug": "func testZeroConfChannelOpen(ht *lntest.HarnessTest) {",
      "content": "func testZeroConfChannelOpen(ht *lntest.HarnessTest) {\n\t// Since option-scid-alias is opt-in, the provided harness nodes will\n\t// not have the feature bit set. Also need to set anchors as those are\n\t// default-off in itests.\n\tscidAliasArgs := []string{\n\t\t\"--protocol.option-scid-alias\",\n\t\t\"--protocol.zero-conf\",\n\t\t\"--protocol.anchors\",\n\t}\n\n\tbob := ht.Bob\n\tcarol := ht.NewNode(\"Carol\", scidAliasArgs)\n\tht.EnsureConnected(bob, carol)\n\n\t// We'll open a regular public channel between Bob and Carol here.\n\tchanAmt := btcutil.Amount(1_000_000)\n\tp := lntest.OpenChannelParams{\n\t\tAmt: chanAmt,\n\t}\n\tchanPoint := ht.OpenChannel(bob, carol, p)\n\n\t// Spin-up Dave so Carol can open a zero-conf channel to him.\n\tdave := ht.NewNode(\"Dave\", scidAliasArgs)\n\n\t// We'll give Carol some coins in order to fund the channel.\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, carol)\n\n\t// Ensure that both Carol and Dave are connected.\n\tht.EnsureConnected(carol, dave)\n\n\t// Setup a ChannelAcceptor for Dave.\n\tacceptStream, cancel := dave.RPC.ChannelAcceptor()\n\tgo acceptChannel(ht.T, true, acceptStream)\n\n\t// Open a private zero-conf anchors channel of 1M satoshis.\n\tparams := lntest.OpenChannelParams{\n\t\tAmt:            chanAmt,\n\t\tPrivate:        true,\n\t\tCommitmentType: lnrpc.CommitmentType_ANCHORS,\n\t\tZeroConf:       true,\n\t}\n\tstream := ht.OpenChannelAssertStream(carol, dave, params)\n\n\t// Remove the ChannelAcceptor.\n\tcancel()\n\n\t// We should receive the OpenStatusUpdate_ChanOpen update without\n\t// having to mine any blocks.\n\tfundingPoint2 := ht.WaitForChannelOpenEvent(stream)\n\n\tht.AssertTopologyChannelOpen(carol, fundingPoint2)\n\tht.AssertTopologyChannelOpen(dave, fundingPoint2)\n\n\t// Attempt to send a 10K satoshi payment from Carol to Dave.\n\tdaveInvoiceParams := &lnrpc.Invoice{\n\t\tValue:   int64(10_000),\n\t\tPrivate: true,\n\t}\n\tdaveInvoiceResp := dave.RPC.AddInvoice(daveInvoiceParams)\n\tht.CompletePaymentRequests(\n\t\tcarol, []string{daveInvoiceResp.PaymentRequest},\n\t)\n\n\t// Now attempt to send a multi-hop payment from Bob to Dave. This tests\n\t// that Dave issues an invoice with an alias SCID that Carol knows and\n\t// uses to forward to Dave.\n\tdaveInvoiceResp2 := dave.RPC.AddInvoice(daveInvoiceParams)\n\tht.CompletePaymentRequests(\n\t\tbob, []string{daveInvoiceResp2.PaymentRequest},\n\t)\n\n\t// Check that Dave has a zero-conf alias SCID in the graph.\n\tdescReq := &lnrpc.ChannelGraphRequest{\n\t\tIncludeUnannounced: true,\n\t}\n\n\terr := waitForZeroConfGraphChange(dave, descReq, true)\n\trequire.NoError(ht, err)\n\n\t// We'll now confirm the zero-conf channel between Carol and Dave and\n\t// assert that sending is still possible.\n\tblock := ht.MineBlocksAndAssertNumTxes(6, 1)[0]\n\n\t// Dave should still have the alias edge in his db.\n\terr = waitForZeroConfGraphChange(dave, descReq, true)\n\trequire.NoError(ht, err)\n\n\tfundingTxID := ht.GetChanPointFundingTxid(fundingPoint2)\n\n\tht.Miner.AssertTxInBlock(block, fundingTxID)\n\n\tdaveInvoiceResp3 := dave.RPC.AddInvoice(daveInvoiceParams)\n\tht.CompletePaymentRequests(\n\t\tbob, []string{daveInvoiceResp3.PaymentRequest},\n\t)\n\n\t// Eve will now initiate a zero-conf channel with Carol. This tests\n\t// that the ChannelUpdates sent are correct since they will be\n\t// referring to different alias SCIDs.\n\teve := ht.NewNode(\"Eve\", scidAliasArgs)\n\tht.EnsureConnected(eve, carol)\n\n\t// Give Eve some coins to fund the channel.\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, eve)\n\n\t// Setup a ChannelAcceptor.\n\tacceptStream, cancel = carol.RPC.ChannelAcceptor()\n\tgo acceptChannel(ht.T, true, acceptStream)\n\n\t// We'll open a public zero-conf anchors channel of 1M satoshis.\n\tparams.Private = false\n\tstream = ht.OpenChannelAssertStream(eve, carol, params)\n\n\t// Remove the ChannelAcceptor.\n\tcancel()\n\n\t// Wait to receive the OpenStatusUpdate_ChanOpen update.\n\tfundingPoint3 := ht.WaitForChannelOpenEvent(stream)\n\n\tht.AssertTopologyChannelOpen(eve, fundingPoint3)\n\tht.AssertTopologyChannelOpen(carol, fundingPoint3)\n\n\t// Attempt to send a 20K satoshi payment from Eve to Dave.\n\tdaveInvoiceParams.Value = int64(20_000)\n\tdaveInvoiceResp4 := dave.RPC.AddInvoice(daveInvoiceParams)\n\tht.CompletePaymentRequests(\n\t\teve, []string{daveInvoiceResp4.PaymentRequest},\n\t)\n\n\t// Assert that Eve has stored the zero-conf alias in her graph.\n\terr = waitForZeroConfGraphChange(eve, descReq, true)\n\trequire.NoError(ht, err, \"expected to not receive error\")\n\n\t// We'll confirm the zero-conf channel between Eve and Carol and assert\n\t// that sending is still possible.\n\tblock = ht.MineBlocksAndAssertNumTxes(6, 1)[0]\n\n\tfundingTxID = ht.GetChanPointFundingTxid(fundingPoint3)\n\tht.Miner.AssertTxInBlock(block, fundingTxID)\n\n\t// Wait until Eve's ZeroConf channel is replaced by the confirmed SCID\n\t// in her graph.\n\terr = waitForZeroConfGraphChange(eve, descReq, false)\n\trequire.NoError(ht, err, \"expected to not receive error\")\n\n\t// Attempt to send a 6K satoshi payment from Dave to Eve.\n\teveInvoiceParams := &lnrpc.Invoice{\n\t\tValue:   int64(6_000),\n\t\tPrivate: true,\n\t}\n\teveInvoiceResp := eve.RPC.AddInvoice(eveInvoiceParams)\n\n\t// Assert that route hints is empty since the channel is public.\n\tpayReq := eve.RPC.DecodePayReq(eveInvoiceResp.PaymentRequest)\n\trequire.Len(ht, payReq.RouteHints, 0)\n\n\t// Make sure Dave is aware of this channel and send the payment.\n\tht.AssertTopologyChannelOpen(dave, fundingPoint3)\n\tht.CompletePaymentRequests(\n\t\tdave, []string{eveInvoiceResp.PaymentRequest},\n\t)\n\n\t// Close standby node's channels.\n\tht.CloseChannel(bob, chanPoint)\n}\n\n// testOptionScidAlias checks that opening an option_scid_alias channel-type\n// channel or w/o the channel-type works properly.",
      "length": 5331,
      "tokens": 606,
      "embedding": []
    },
    {
      "slug": "func testOptionScidAlias(ht *lntest.HarnessTest) {",
      "content": "func testOptionScidAlias(ht *lntest.HarnessTest) {\n\ttype scidTestCase struct {\n\t\tname string\n\n\t\t// If this is false, then the channel will be a regular non\n\t\t// channel-type option-scid-alias-feature-bit channel.\n\t\tchantype bool\n\n\t\tprivate bool\n\t}\n\n\tvar testCases = []scidTestCase{\n\t\t{\n\t\t\tname:     \"private chan-type\",\n\t\t\tchantype: true,\n\t\t\tprivate:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"public no chan-type\",\n\t\t\tchantype: false,\n\t\t\tprivate:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"private no chan-type\",\n\t\t\tchantype: false,\n\t\t\tprivate:  true,\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\ttestCase := testCase\n\t\tsuccess := ht.Run(testCase.name, func(t *testing.T) {\n\t\t\tst := ht.Subtest(t)\n\t\t\toptionScidAliasScenario(\n\t\t\t\tst, testCase.chantype, testCase.private,\n\t\t\t)\n\t\t})\n\t\tif !success {\n\t\t\tbreak\n\t\t}\n\t}\n}\n",
      "length": 702,
      "tokens": 94,
      "embedding": []
    },
    {
      "slug": "func optionScidAliasScenario(ht *lntest.HarnessTest, chantype, private bool) {",
      "content": "func optionScidAliasScenario(ht *lntest.HarnessTest, chantype, private bool) {\n\t// Option-scid-alias is opt-in, as is anchors.\n\tscidAliasArgs := []string{\n\t\t\"--protocol.option-scid-alias\",\n\t\t\"--protocol.anchors\",\n\t}\n\n\tbob := ht.Bob\n\tcarol := ht.NewNode(\"Carol\", scidAliasArgs)\n\tdave := ht.NewNode(\"Dave\", scidAliasArgs)\n\n\t// Ensure Bob, Carol are connected.\n\tht.EnsureConnected(bob, carol)\n\n\t// Ensure Carol, Dave are connected.\n\tht.EnsureConnected(carol, dave)\n\n\t// Give Carol some coins so she can open the channel.\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, carol)\n\n\tchanAmt := btcutil.Amount(1_000_000)\n\n\tparams := lntest.OpenChannelParams{\n\t\tAmt:            chanAmt,\n\t\tPrivate:        private,\n\t\tCommitmentType: lnrpc.CommitmentType_ANCHORS,\n\t\tScidAlias:      chantype,\n\t}\n\tfundingPoint := ht.OpenChannel(carol, dave, params)\n\n\t// Make sure Bob knows this channel if it's public.\n\tif !private {\n\t\tht.AssertTopologyChannelOpen(bob, fundingPoint)\n\t}\n\n\t// Assert that a payment from Carol to Dave works as expected.\n\tdaveInvoiceParams := &lnrpc.Invoice{\n\t\tValue:   int64(10_000),\n\t\tPrivate: true,\n\t}\n\tdaveInvoiceResp := dave.RPC.AddInvoice(daveInvoiceParams)\n\tht.CompletePaymentRequests(\n\t\tcarol, []string{daveInvoiceResp.PaymentRequest},\n\t)\n\n\t// We'll now open a regular public channel between Bob and Carol and\n\t// assert that Bob can pay Dave. We'll also assert that the invoice\n\t// Dave issues has the startingAlias as a hop hint.\n\tp := lntest.OpenChannelParams{\n\t\tAmt: chanAmt,\n\t}\n\tfundingPoint2 := ht.OpenChannel(bob, carol, p)\n\n\tdefer func() {\n\t\t// TODO(yy): remove the sleep once the following bug is fixed.\n\t\t// When the payment is reported as settled by Bob, it's\n\t\t// expected the commitment dance is finished and all subsequent\n\t\t// states have been updated. Yet we'd receive the error `cannot\n\t\t// co-op close channel with active htlcs` or `link failed to\n\t\t// shutdown` if we close the channel. We need to investigate\n\t\t// the order of settling the payments and updating commitments\n\t\t// to understand and fix.\n\t\ttime.Sleep(2 * time.Second)\n\n\t\t// Close standby node's channels.\n\t\tht.CloseChannel(bob, fundingPoint2)\n\t}()\n\n\t// Wait until Dave receives the Bob<->Carol channel.\n\tht.AssertTopologyChannelOpen(dave, fundingPoint2)\n\n\tdaveInvoiceResp2 := dave.RPC.AddInvoice(daveInvoiceParams)\n\tdecodedReq := dave.RPC.DecodePayReq(daveInvoiceResp2.PaymentRequest)\n\n\tif !private {\n\t\trequire.Len(ht, decodedReq.RouteHints, 0)\n\t\tpayReq := daveInvoiceResp2.PaymentRequest\n\t\tht.CompletePaymentRequests(bob, []string{payReq})\n\n\t\treturn\n\t}\n\n\trequire.Len(ht, decodedReq.RouteHints, 1)\n\trequire.Len(ht, decodedReq.RouteHints[0].HopHints, 1)\n\n\tstartingAlias := lnwire.ShortChannelID{\n\t\tBlockHeight: 16_000_000,\n\t\tTxIndex:     0,\n\t\tTxPosition:  0,\n\t}\n\n\tdaveHopHint := decodedReq.RouteHints[0].HopHints[0].ChanId\n\trequire.Equal(ht, startingAlias.ToUint64(), daveHopHint)\n\n\tht.CompletePaymentRequests(\n\t\tbob, []string{daveInvoiceResp2.PaymentRequest},\n\t)\n}\n\n// waitForZeroConfGraphChange waits for the zero-conf channel to be visible in\n// the graph after confirmation or not. The expect argument denotes whether the\n// zero-conf is expected in the graph or not. There should always be at least\n// one channel of the passed HarnessNode, zero-conf or not.",
      "length": 3069,
      "tokens": 362,
      "embedding": []
    },
    {
      "slug": "func waitForZeroConfGraphChange(hn *node.HarnessNode,",
      "content": "func waitForZeroConfGraphChange(hn *node.HarnessNode,\n\treq *lnrpc.ChannelGraphRequest, expect bool) error {\n\n\treturn wait.NoError(func() error {\n\t\tgraph := hn.RPC.DescribeGraph(req)\n\n\t\tif expect {\n\t\t\t// If we expect a zero-conf channel, we'll assert that\n\t\t\t// one exists, both policies exist, and we are party to\n\t\t\t// the channel.\n\t\t\tfor _, e := range graph.Edges {\n\t\t\t\t// The BlockHeight will be less than 16_000_000\n\t\t\t\t// if this is not a zero-conf channel.\n\t\t\t\tscid := lnwire.NewShortChanIDFromInt(\n\t\t\t\t\te.ChannelId,\n\t\t\t\t)\n\t\t\t\tif scid.BlockHeight < 16_000_000 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\t// Both edge policies must exist in the zero\n\t\t\t\t// conf case.\n\t\t\t\tif e.Node1Policy == nil ||\n\t\t\t\t\te.Node2Policy == nil {\n\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\t// Check if we are party to the zero-conf\n\t\t\t\t// channel.\n\t\t\t\tif e.Node1Pub == hn.PubKeyStr ||\n\t\t\t\t\te.Node2Pub == hn.PubKeyStr {\n\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn errors.New(\"failed to find zero-conf channel \" +\n\t\t\t\t\"in graph\")\n\t\t}\n\n\t\t// If we don't expect a zero-conf channel, we'll assert that\n\t\t// none exist, that we have a non-zero-conf channel with at\n\t\t// both policies, and one of the policies in the database is\n\t\t// ours.\n\t\tfor _, e := range graph.Edges {\n\t\t\tscid := lnwire.NewShortChanIDFromInt(e.ChannelId)\n\t\t\tif scid.BlockHeight == 16_000_000 {\n\t\t\t\treturn errors.New(\"found zero-conf channel\")\n\t\t\t}\n\n\t\t\t// One of the edge policies must exist.\n\t\t\tif e.Node1Policy == nil || e.Node2Policy == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// If we are part of this channel, exit gracefully.\n\t\t\tif e.Node1Pub == hn.PubKeyStr ||\n\t\t\t\te.Node2Pub == hn.PubKeyStr {\n\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\n\t\treturn errors.New(\n\t\t\t\"failed to find non-zero-conf channel in graph\",\n\t\t)\n\t}, defaultTimeout)\n}\n\n// testUpdateChannelPolicyScidAlias checks that option-scid-alias, zero-conf\n// channel-types, and option-scid-alias feature-bit-only channels have the\n// expected graph and that payments work when updating the channel policy.",
      "length": 1825,
      "tokens": 270,
      "embedding": []
    },
    {
      "slug": "func testUpdateChannelPolicyScidAlias(ht *lntest.HarnessTest) {",
      "content": "func testUpdateChannelPolicyScidAlias(ht *lntest.HarnessTest) {\n\ttests := []struct {\n\t\tname string\n\n\t\t// The option-scid-alias channel type.\n\t\tscidAliasType bool\n\n\t\t// The zero-conf channel type.\n\t\tzeroConf bool\n\n\t\tprivate bool\n\t}{\n\t\t{\n\t\t\tname:          \"private scid-alias chantype update\",\n\t\t\tscidAliasType: true,\n\t\t\tprivate:       true,\n\t\t},\n\t\t{\n\t\t\tname:     \"private zero-conf update\",\n\t\t\tzeroConf: true,\n\t\t\tprivate:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"public zero-conf update\",\n\t\t\tzeroConf: true,\n\t\t},\n\t\t{\n\t\t\tname: \"public no-chan-type update\",\n\t\t},\n\t\t{\n\t\t\tname:    \"private no-chan-type update\",\n\t\t\tprivate: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\n\t\tsuccess := ht.Run(test.name, func(t *testing.T) {\n\t\t\tst := ht.Subtest(t)\n\n\t\t\ttestPrivateUpdateAlias(\n\t\t\t\tst, test.zeroConf, test.scidAliasType,\n\t\t\t\ttest.private,\n\t\t\t)\n\t\t})\n\t\tif !success {\n\t\t\treturn\n\t\t}\n\t}\n}\n",
      "length": 764,
      "tokens": 100,
      "embedding": []
    },
    {
      "slug": "func testPrivateUpdateAlias(ht *lntest.HarnessTest,",
      "content": "func testPrivateUpdateAlias(ht *lntest.HarnessTest,\n\tzeroConf, scidAliasType, private bool) {\n\n\t// We'll create a new node Eve that will not have option-scid-alias\n\t// channels.\n\teve := ht.NewNode(\"Eve\", nil)\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, eve)\n\n\t// Since option-scid-alias is opt-in we'll need to specify the protocol\n\t// arguments when creating a new node.\n\tscidAliasArgs := []string{\n\t\t\"--protocol.option-scid-alias\",\n\t\t\"--protocol.zero-conf\",\n\t\t\"--protocol.anchors\",\n\t}\n\tcarol := ht.NewNode(\"Carol\", scidAliasArgs)\n\n\t// Spin-up Dave who will have an option-scid-alias feature-bit-only or\n\t// channel-type channel with Carol.\n\tdave := ht.NewNode(\"Dave\", scidAliasArgs)\n\n\t// We'll give Carol some coins in order to fund the channel.\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, carol)\n\n\t// Ensure that Carol and Dave are connected.\n\tht.EnsureConnected(carol, dave)\n\n\t// We'll open a regular public channel between Eve and Carol here. Eve\n\t// will be the one receiving the onion-encrypted ChannelUpdate.\n\tht.EnsureConnected(eve, carol)\n\n\tchanAmt := btcutil.Amount(1_000_000)\n\n\tp := lntest.OpenChannelParams{\n\t\tAmt:     chanAmt,\n\t\tPushAmt: chanAmt / 2,\n\t}\n\tfundingPoint := ht.OpenChannel(eve, carol, p)\n\n\t// Make sure Dave has seen this public channel.\n\tht.AssertTopologyChannelOpen(dave, fundingPoint)\n\n\t// Setup a ChannelAcceptor for Dave.\n\tacceptStream, cancel := dave.RPC.ChannelAcceptor()\n\tgo acceptChannel(ht.T, zeroConf, acceptStream)\n\n\t// Open a private channel, optionally specifying a channel-type.\n\tparams := lntest.OpenChannelParams{\n\t\tAmt:            chanAmt,\n\t\tPrivate:        private,\n\t\tCommitmentType: lnrpc.CommitmentType_ANCHORS,\n\t\tZeroConf:       zeroConf,\n\t\tScidAlias:      scidAliasType,\n\t\tPushAmt:        chanAmt / 2,\n\t}\n\tfundingPoint2 := ht.OpenChannelNoAnnounce(carol, dave, params)\n\n\t// Remove the ChannelAcceptor.\n\tcancel()\n\n\t// Carol will now update the channel edge policy for her channel with\n\t// Dave.\n\tbaseFeeMSat := 33000\n\tfeeRate := int64(5)\n\ttimeLockDelta := uint32(chainreg.DefaultBitcoinTimeLockDelta)\n\tupdateFeeReq := &lnrpc.PolicyUpdateRequest{\n\t\tBaseFeeMsat:   int64(baseFeeMSat),\n\t\tFeeRate:       float64(feeRate),\n\t\tTimeLockDelta: timeLockDelta,\n\t\tScope: &lnrpc.PolicyUpdateRequest_ChanPoint{\n\t\t\tChanPoint: fundingPoint2,\n\t\t},\n\t}\n\tcarol.RPC.UpdateChannelPolicy(updateFeeReq)\n\n\texpectedPolicy := &lnrpc.RoutingPolicy{\n\t\tFeeBaseMsat:      int64(baseFeeMSat),\n\t\tFeeRateMilliMsat: testFeeBase * feeRate,\n\t\tTimeLockDelta:    timeLockDelta,\n\t\tMinHtlc:          1000, // default value\n\t\tMaxHtlcMsat:      lntest.CalculateMaxHtlc(chanAmt),\n\t}\n\n\t// Assert that Dave receives Carol's policy update.\n\tht.AssertChannelPolicyUpdate(\n\t\tdave, carol, expectedPolicy, fundingPoint2, true,\n\t)\n\n\t// Have Dave also update his policy.\n\tbaseFeeMSat = 15000\n\tfeeRate = int64(4)\n\tupdateFeeReq = &lnrpc.PolicyUpdateRequest{\n\t\tBaseFeeMsat:   int64(baseFeeMSat),\n\t\tFeeRate:       float64(feeRate),\n\t\tTimeLockDelta: timeLockDelta,\n\t\tScope: &lnrpc.PolicyUpdateRequest_ChanPoint{\n\t\t\tChanPoint: fundingPoint2,\n\t\t},\n\t}\n\tdave.RPC.UpdateChannelPolicy(updateFeeReq)\n\n\texpectedPolicy = &lnrpc.RoutingPolicy{\n\t\tFeeBaseMsat:      int64(baseFeeMSat),\n\t\tFeeRateMilliMsat: testFeeBase * feeRate,\n\t\tTimeLockDelta:    timeLockDelta,\n\t\tMinHtlc:          1000,\n\t\tMaxHtlcMsat:      lntest.CalculateMaxHtlc(chanAmt),\n\t}\n\n\t// Assert that Carol receives Dave's policy update.\n\tht.AssertChannelPolicyUpdate(\n\t\tcarol, dave, expectedPolicy, fundingPoint2, true,\n\t)\n\n\t// Assert that if Dave disables the channel, Carol sees it.\n\tdisableReq := &routerrpc.UpdateChanStatusRequest{\n\t\tChanPoint: fundingPoint2,\n\t\tAction:    routerrpc.ChanStatusAction_DISABLE,\n\t}\n\tdave.RPC.UpdateChanStatus(disableReq)\n\n\texpectedPolicy.Disabled = true\n\tht.AssertChannelPolicyUpdate(\n\t\tcarol, dave, expectedPolicy, fundingPoint2, true,\n\t)\n\n\t// Assert that if Dave enables the channel, Carol sees it.\n\tenableReq := &routerrpc.UpdateChanStatusRequest{\n\t\tChanPoint: fundingPoint2,\n\t\tAction:    routerrpc.ChanStatusAction_ENABLE,\n\t}\n\tdave.RPC.UpdateChanStatus(enableReq)\n\n\texpectedPolicy.Disabled = false\n\tht.AssertChannelPolicyUpdate(\n\t\tcarol, dave, expectedPolicy, fundingPoint2, true,\n\t)\n\n\t// Create an invoice for Carol to pay.\n\tinvoiceParams := &lnrpc.Invoice{\n\t\tValue:   int64(10_000),\n\t\tPrivate: true,\n\t}\n\tdaveInvoiceResp := dave.RPC.AddInvoice(invoiceParams)\n\n\t// Carol will attempt to send Dave an HTLC.\n\tpayReqs := []string{daveInvoiceResp.PaymentRequest}\n\tht.CompletePaymentRequests(carol, payReqs)\n\n\t// Now Eve will create an invoice that Dave will pay.\n\teveInvoiceResp := eve.RPC.AddInvoice(invoiceParams)\n\tpayReqs = []string{eveInvoiceResp.PaymentRequest}\n\tht.CompletePaymentRequests(dave, payReqs)\n\n\t// If this is a public channel, it won't be included in the hop hints,\n\t// so we'll mine enough for 6 confs here. We only expect a tx in the\n\t// mempool for the zero-conf case.\n\tif !private {\n\t\tvar expectTx int\n\t\tif zeroConf {\n\t\t\texpectTx = 1\n\t\t}\n\t\tht.MineBlocksAndAssertNumTxes(6, expectTx)\n\n\t\t// Sleep here so that the edge can be deleted and re-inserted.\n\t\t// This is necessary since the edge may have a policy for the\n\t\t// peer that is \"correct\" but has an invalid signature from the\n\t\t// PoV of BOLT#7.\n\t\t//\n\t\t// TODO(yy): further investigate this sleep.\n\t\ttime.Sleep(time.Second * 5)\n\t}\n\n\t// Dave creates an invoice that Eve will pay.\n\tdaveInvoiceResp2 := dave.RPC.AddInvoice(invoiceParams)\n\n\t// Carol then updates the channel policy again.\n\tfeeRate = int64(2)\n\tupdateFeeReq = &lnrpc.PolicyUpdateRequest{\n\t\tBaseFeeMsat:   int64(baseFeeMSat),\n\t\tFeeRate:       float64(feeRate),\n\t\tTimeLockDelta: timeLockDelta,\n\t\tScope: &lnrpc.PolicyUpdateRequest_ChanPoint{\n\t\t\tChanPoint: fundingPoint2,\n\t\t},\n\t}\n\tcarol.RPC.UpdateChannelPolicy(updateFeeReq)\n\n\texpectedPolicy = &lnrpc.RoutingPolicy{\n\t\tFeeBaseMsat:      int64(baseFeeMSat),\n\t\tFeeRateMilliMsat: testFeeBase * feeRate,\n\t\tTimeLockDelta:    timeLockDelta,\n\t\tMinHtlc:          1000,\n\t\tMaxHtlcMsat:      lntest.CalculateMaxHtlc(chanAmt),\n\t}\n\n\t// Assert Dave receives Carol's policy update.\n\tht.AssertChannelPolicyUpdate(\n\t\tdave, carol, expectedPolicy, fundingPoint2, true,\n\t)\n\n\t// If the channel is public, check that Eve receives Carol's policy\n\t// update.\n\tif !private {\n\t\tht.AssertChannelPolicyUpdate(\n\t\t\teve, carol, expectedPolicy, fundingPoint2, true,\n\t\t)\n\t}\n\n\t// Eve will pay Dave's invoice and should use the updated base fee.\n\tpayReqs = []string{daveInvoiceResp2.PaymentRequest}\n\tht.CompletePaymentRequests(eve, payReqs)\n\n\t// Eve will issue an invoice that Dave will pay.\n\teveInvoiceResp2 := eve.RPC.AddInvoice(invoiceParams)\n\tpayReqs = []string{eveInvoiceResp2.PaymentRequest}\n\tht.CompletePaymentRequests(dave, payReqs)\n\n\t// If this is a private channel, we'll mine 6 blocks here to test the\n\t// funding manager logic that deals with ChannelUpdates. If this is not\n\t// a zero-conf channel, we don't expect a tx in the mempool.\n\tif private {\n\t\tvar expectTx int\n\t\tif zeroConf {\n\t\t\texpectTx = 1\n\t\t}\n\t\tht.MineBlocksAndAssertNumTxes(6, expectTx)\n\t}\n\n\t// Dave will issue an invoice and Eve will pay it.\n\tdaveInvoiceResp3 := dave.RPC.AddInvoice(invoiceParams)\n\tpayReqs = []string{daveInvoiceResp3.PaymentRequest}\n\tht.CompletePaymentRequests(eve, payReqs)\n\n\t// Carol will disable the channel, assert that Dave sees it and Eve as\n\t// well if the channel is public.\n\tcarol.RPC.UpdateChanStatus(disableReq)\n\n\texpectedPolicy.Disabled = true\n\tht.AssertChannelPolicyUpdate(\n\t\tdave, carol, expectedPolicy, fundingPoint2, true,\n\t)\n\n\tif !private {\n\t\tht.AssertChannelPolicyUpdate(\n\t\t\teve, carol, expectedPolicy, fundingPoint2, true,\n\t\t)\n\t}\n\n\t// Carol will enable the channel, assert the same as above.\n\tcarol.RPC.UpdateChanStatus(enableReq)\n\texpectedPolicy.Disabled = false\n\tht.AssertChannelPolicyUpdate(\n\t\tdave, carol, expectedPolicy, fundingPoint2, true,\n\t)\n\n\tif !private {\n\t\tht.AssertChannelPolicyUpdate(\n\t\t\teve, carol, expectedPolicy, fundingPoint2, true,\n\t\t)\n\t}\n\n\t// Dave will issue an invoice and Eve should pay it after Carol updates\n\t// her channel policy.\n\tdaveInvoiceResp4 := dave.RPC.AddInvoice(invoiceParams)\n\n\tfeeRate = int64(3)\n\tupdateFeeReq = &lnrpc.PolicyUpdateRequest{\n\t\tBaseFeeMsat:   int64(baseFeeMSat),\n\t\tFeeRate:       float64(feeRate),\n\t\tTimeLockDelta: timeLockDelta,\n\t\tScope: &lnrpc.PolicyUpdateRequest_ChanPoint{\n\t\t\tChanPoint: fundingPoint2,\n\t\t},\n\t}\n\tcarol.RPC.UpdateChannelPolicy(updateFeeReq)\n\n\texpectedPolicy = &lnrpc.RoutingPolicy{\n\t\tFeeBaseMsat:      int64(baseFeeMSat),\n\t\tFeeRateMilliMsat: testFeeBase * feeRate,\n\t\tTimeLockDelta:    timeLockDelta,\n\t\tMinHtlc:          1000,\n\t\tMaxHtlcMsat:      lntest.CalculateMaxHtlc(chanAmt),\n\t}\n\n\t// Assert Dave and optionally Eve receives Carol's update.\n\tht.AssertChannelPolicyUpdate(\n\t\tdave, carol, expectedPolicy, fundingPoint2, true,\n\t)\n\n\tif !private {\n\t\tht.AssertChannelPolicyUpdate(\n\t\t\teve, carol, expectedPolicy, fundingPoint2, true,\n\t\t)\n\t}\n\n\tpayReqs = []string{daveInvoiceResp4.PaymentRequest}\n\tht.CompletePaymentRequests(eve, payReqs)\n}\n\n// testOptionScidUpgrade tests that toggling the option-scid-alias feature bit\n// correctly upgrades existing channels.",
      "length": 8700,
      "tokens": 934,
      "embedding": []
    },
    {
      "slug": "func testOptionScidUpgrade(ht *lntest.HarnessTest) {",
      "content": "func testOptionScidUpgrade(ht *lntest.HarnessTest) {\n\tbob := ht.Bob\n\n\t// Start carol with anchors only.\n\tcarolArgs := []string{\n\t\t\"--protocol.anchors\",\n\t}\n\tcarol := ht.NewNode(\"carol\", carolArgs)\n\n\t// Start dave with anchors + scid-alias.\n\tdaveArgs := []string{\n\t\t\"--protocol.anchors\",\n\t\t\"--protocol.option-scid-alias\",\n\t}\n\tdave := ht.NewNode(\"dave\", daveArgs)\n\n\t// Give carol some coins.\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, carol)\n\n\t// Ensure carol and are connected.\n\tht.EnsureConnected(carol, dave)\n\n\tchanAmt := btcutil.Amount(1_000_000)\n\n\tp := lntest.OpenChannelParams{\n\t\tAmt:     chanAmt,\n\t\tPushAmt: chanAmt / 2,\n\t\tPrivate: true,\n\t}\n\tht.OpenChannel(carol, dave, p)\n\n\t// Bob will open a channel to Carol now.\n\tht.EnsureConnected(bob, carol)\n\n\tp = lntest.OpenChannelParams{\n\t\tAmt: chanAmt,\n\t}\n\tfundingPoint2 := ht.OpenChannel(bob, carol, p)\n\n\t// Make sure Dave knows this channel.\n\tht.AssertTopologyChannelOpen(dave, fundingPoint2)\n\n\t// Carol will now set the option-scid-alias feature bit and restart.\n\tcarolArgs = append(carolArgs, \"--protocol.option-scid-alias\")\n\tht.RestartNodeWithExtraArgs(carol, carolArgs)\n\n\t// Dave will create an invoice for Carol to pay, it should contain an\n\t// alias in the hop hints.\n\tdaveParams := &lnrpc.Invoice{\n\t\tValue:   int64(10_000),\n\t\tPrivate: true,\n\t}\n\n\tvar daveInvoice *lnrpc.AddInvoiceResponse\n\n\tvar startingAlias lnwire.ShortChannelID\n\tstartingAlias.BlockHeight = 16_000_000\n\n\t// TODO(yy): Carol and Dave will attempt to connect to each other\n\t// during restart. However, due to the race condition in peer\n\t// connection, they may both fail. Thus we need to ensure the\n\t// connection here. Once the race is fixed, we can remove this line.\n\tht.EnsureConnected(dave, carol)\n\n\terr := wait.NoError(func() error {\n\t\tinvoiceResp := dave.RPC.AddInvoice(daveParams)\n\t\tdecodedReq := dave.RPC.DecodePayReq(invoiceResp.PaymentRequest)\n\n\t\tif len(decodedReq.RouteHints) != 1 {\n\t\t\treturn fmt.Errorf(\"expected 1 route hint, got %v\",\n\t\t\t\tdecodedReq.RouteHints)\n\t\t}\n\n\t\tif len(decodedReq.RouteHints[0].HopHints) != 1 {\n\t\t\treturn fmt.Errorf(\"expected 1 hop hint, got %v\",\n\t\t\t\tlen(decodedReq.RouteHints[0].HopHints))\n\t\t}\n\n\t\thopHint := decodedReq.RouteHints[0].HopHints[0].ChanId\n\t\tif startingAlias.ToUint64() == hopHint {\n\t\t\tdaveInvoice = invoiceResp\n\t\t\treturn nil\n\t\t}\n\n\t\treturn fmt.Errorf(\"unmatched alias, expected %v, got %v\",\n\t\t\tstartingAlias.ToUint64(), hopHint)\n\t}, defaultTimeout)\n\trequire.NoError(ht, err)\n\n\t// Carol should be able to pay it.\n\tht.CompletePaymentRequests(carol, []string{daveInvoice.PaymentRequest})\n\n\t// TODO(yy): remove this connection once the following bug is fixed.\n\t// When Carol restarts, she will try to make a persistent connection to\n\t// Bob. Meanwhile, Bob will also make a conn request as he notices the\n\t// connection is broken. If they make these conn requests at the same\n\t// time, they both have an outbound conn request, and will close the\n\t// inbound conn they receives, which ends up in no conn.\n\tht.EnsureConnected(bob, carol)\n\n\tdaveInvoice2 := dave.RPC.AddInvoice(daveParams)\n\tht.CompletePaymentRequests(bob, []string{daveInvoice2.PaymentRequest})\n\n\t// TODO(yy): remove the sleep once the following bug is fixed.  When\n\t// the payment is reported as settled by Bob, it's expected the\n\t// commitment dance is finished and all subsequent states have been\n\t// updated. Yet we'd receive the error `cannot co-op close channel with\n\t// active htlcs` or `link failed to shutdown` if we close the channel.\n\t// We need to investigate the order of settling the payments and\n\t// updating commitments to understand and fix.\n\ttime.Sleep(2 * time.Second)\n\n\t// Close standby node's channels.\n\tht.CloseChannel(bob, fundingPoint2)\n}\n\n// acceptChannel is used to accept a single channel that comes across. This\n// should be run in a goroutine and is used to test nodes with the zero-conf\n// feature bit.",
      "length": 3689,
      "tokens": 483,
      "embedding": []
    },
    {
      "slug": "func acceptChannel(t *testing.T, zeroConf bool, stream rpc.AcceptorClient) {",
      "content": "func acceptChannel(t *testing.T, zeroConf bool, stream rpc.AcceptorClient) {\n\tt.Helper()\n\n\treq, err := stream.Recv()\n\trequire.NoError(t, err)\n\n\tresp := &lnrpc.ChannelAcceptResponse{\n\t\tAccept:        true,\n\t\tPendingChanId: req.PendingChanId,\n\t\tZeroConf:      zeroConf,\n\t}\n\terr = stream.Send(resp)\n\trequire.NoError(t, err)\n}\n\n// testZeroConfReorg tests that a reorg does not cause a zero-conf channel to\n// be deleted from the channel graph. This was previously the case due to logic\n// in the function DisconnectBlockAtHeight.",
      "length": 432,
      "tokens": 56,
      "embedding": []
    },
    {
      "slug": "func testZeroConfReorg(ht *lntest.HarnessTest) {",
      "content": "func testZeroConfReorg(ht *lntest.HarnessTest) {\n\tif ht.IsNeutrinoBackend() {\n\t\tht.Skipf(\"skipping zero-conf reorg test for neutrino backend\")\n\t}\n\n\tvar temp = \"temp\"\n\n\t// Since zero-conf is opt in, the harness nodes provided won't be able\n\t// to open zero-conf channels. In that case, we just spin up new nodes.\n\tzeroConfArgs := []string{\n\t\t\"--protocol.option-scid-alias\",\n\t\t\"--protocol.zero-conf\",\n\t\t\"--protocol.anchors\",\n\t}\n\n\tcarol := ht.NewNode(\"Carol\", zeroConfArgs)\n\n\t// Spin-up Dave so Carol can open a zero-conf channel to him.\n\tdave := ht.NewNode(\"Dave\", zeroConfArgs)\n\n\t// We'll give Carol some coins in order to fund the channel.\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, carol)\n\n\t// Ensure that both Carol and Dave are connected.\n\tht.EnsureConnected(carol, dave)\n\n\t// Setup a ChannelAcceptor for Dave.\n\tacceptStream, cancel := dave.RPC.ChannelAcceptor()\n\tgo acceptChannel(ht.T, true, acceptStream)\n\n\t// Open a private zero-conf anchors channel of 1M satoshis.\n\tparams := lntest.OpenChannelParams{\n\t\tAmt:            btcutil.Amount(1_000_000),\n\t\tCommitmentType: lnrpc.CommitmentType_ANCHORS,\n\t\tZeroConf:       true,\n\t}\n\t_ = ht.OpenChannelNoAnnounce(carol, dave, params)\n\n\t// Remove the ChannelAcceptor.\n\tcancel()\n\n\t// Attempt to send a 10K satoshi payment from Carol to Dave. This\n\t// requires that the edge exists in the graph.\n\tdaveInvoiceParams := &lnrpc.Invoice{\n\t\tValue: int64(10_000),\n\t}\n\tdaveInvoiceResp := dave.RPC.AddInvoice(daveInvoiceParams)\n\n\tpayReqs := []string{daveInvoiceResp.PaymentRequest}\n\tht.CompletePaymentRequests(carol, payReqs)\n\n\t// We will now attempt to query for the alias SCID in Carol's graph.\n\t// We will query for the starting alias, which is exported by the\n\t// aliasmgr package.\n\tcarol.RPC.GetChanInfo(&lnrpc.ChanInfoRequest{\n\t\tChanId: aliasmgr.StartingAlias.ToUint64(),\n\t})\n\n\t// Now we will trigger a reorg and we'll assert that the edge still\n\t// exists in the graph.\n\t//\n\t// First, we'll setup a new miner that we can use to cause a reorg.\n\ttempLogDir := \".tempminerlogs\"\n\tlogFilename := \"output-open_channel_reorg-temp_miner.log\"\n\ttempMiner := lntest.NewTempMiner(\n\t\tht.Context(), ht.T, tempLogDir, logFilename,\n\t)\n\tdefer tempMiner.Stop()\n\n\trequire.NoError(\n\t\tht.T, tempMiner.SetUp(false, 0), \"unable to setup mining node\",\n\t)\n\n\t// We start by connecting the new miner to our original miner, such\n\t// that it will sync to our original chain.\n\terr := ht.Miner.Client.Node(\n\t\tbtcjson.NConnect, tempMiner.P2PAddress(), &temp,\n\t)\n\trequire.NoError(ht.T, err, \"unable to connect node\")\n\n\tnodeSlice := []*rpctest.Harness{ht.Miner.Harness, tempMiner.Harness}\n\terr = rpctest.JoinNodes(nodeSlice, rpctest.Blocks)\n\trequire.NoError(ht.T, err, \"unable to join node on blocks\")\n\n\t// The two miners should be on the same block height.\n\tassertMinerBlockHeightDelta(ht, ht.Miner, tempMiner, 0)\n\n\t// We disconnect the two miners, such that we can mine two chains and\n\t// cause a reorg later.\n\terr = ht.Miner.Client.Node(\n\t\tbtcjson.NDisconnect, tempMiner.P2PAddress(), &temp,\n\t)\n\trequire.NoError(ht.T, err, \"unable to remove node\")\n\n\t// We now cause a fork, by letting our original miner mine 1 block and\n\t// our new miner will mine 2. We also expect the funding transition to\n\t// be mined.\n\tht.MineBlocksAndAssertNumTxes(1, 1)\n\ttempMiner.MineEmptyBlocks(2)\n\n\t// Ensure the temp miner is one block ahead.\n\tassertMinerBlockHeightDelta(ht, ht.Miner, tempMiner, 1)\n\n\t// Wait for Carol to sync to the original miner's chain.\n\t_, minerHeight := ht.Miner.GetBestBlock()\n\tht.WaitForNodeBlockHeight(carol, minerHeight)\n\n\t// Now we'll disconnect Carol's chain backend from the original miner\n\t// so that we can connect the two miners together and let the original\n\t// miner sync to the temp miner's chain.\n\tht.DisconnectMiner()\n\n\t// Connecting to the temporary miner should cause the original miner to\n\t// reorg to the longer chain.\n\terr = ht.Miner.Client.Node(\n\t\tbtcjson.NConnect, tempMiner.P2PAddress(), &temp,\n\t)\n\trequire.NoError(ht.T, err, \"unable to remove node\")\n\n\tnodes := []*rpctest.Harness{tempMiner.Harness, ht.Miner.Harness}\n\terr = rpctest.JoinNodes(nodes, rpctest.Blocks)\n\trequire.NoError(ht.T, err, \"unable to join node on blocks\")\n\n\t// They should now be on the same chain.\n\tassertMinerBlockHeightDelta(ht, ht.Miner, tempMiner, 0)\n\n\t// Now we disconnect the two miners and reconnect our original chain\n\t// backend.\n\terr = ht.Miner.Client.Node(\n\t\tbtcjson.NDisconnect, tempMiner.P2PAddress(), &temp,\n\t)\n\trequire.NoError(ht.T, err, \"unable to remove node\")\n\n\tht.ConnectMiner()\n\n\t// This should have caused a reorg and Carol should sync to the new\n\t// chain.\n\t_, tempMinerHeight := tempMiner.GetBestBlock()\n\tht.WaitForNodeBlockHeight(carol, tempMinerHeight)\n\n\t// Make sure all active nodes are synced.\n\tht.AssertActiveNodesSynced()\n\n\t// Carol should have the channel once synced.\n\tcarol.RPC.GetChanInfo(&lnrpc.ChanInfoRequest{\n\t\tChanId: aliasmgr.StartingAlias.ToUint64(),\n\t})\n\n\t// Mine the zero-conf funding transaction so the test doesn't fail.\n\tht.MineBlocksAndAssertNumTxes(1, 1)\n}\n",
      "length": 4812,
      "tokens": 611,
      "embedding": []
    }
  ]
}