{
  "filepath": "../implementations/go/lnd/itest/lnd_multi-hop-payments_test.go",
  "package": "itest",
  "sections": [
    {
      "slug": "func testMultiHopPayments(ht *lntest.HarnessTest) {",
      "content": "func testMultiHopPayments(ht *lntest.HarnessTest) {\n\tconst chanAmt = btcutil.Amount(100000)\n\n\t// As preliminary setup, we'll create two new nodes: Carol and Dave,\n\t// such that we now have a 4 node, 3 channel topology. Dave will make a\n\t// channel with Alice, and Carol with Dave. After this setup, the\n\t// network topology should now look like:\n\t//     Carol -> Dave -> Alice -> Bob\n\talice, bob := ht.Alice, ht.Bob\n\n\tdaveArgs := []string{\"--protocol.legacy.onion\"}\n\tdave := ht.NewNode(\"Dave\", daveArgs)\n\tcarol := ht.NewNode(\"Carol\", nil)\n\n\t// Subscribe events early so we don't miss it out.\n\taliceEvents := alice.RPC.SubscribeHtlcEvents()\n\tbobEvents := bob.RPC.SubscribeHtlcEvents()\n\tcarolEvents := carol.RPC.SubscribeHtlcEvents()\n\tdaveEvents := dave.RPC.SubscribeHtlcEvents()\n\n\t// Once subscribed, the first event will be UNKNOWN.\n\tht.AssertHtlcEventType(aliceEvents, routerrpc.HtlcEvent_UNKNOWN)\n\tht.AssertHtlcEventType(bobEvents, routerrpc.HtlcEvent_UNKNOWN)\n\tht.AssertHtlcEventType(carolEvents, routerrpc.HtlcEvent_UNKNOWN)\n\tht.AssertHtlcEventType(daveEvents, routerrpc.HtlcEvent_UNKNOWN)\n\n\t// Connect the nodes.\n\tht.ConnectNodes(dave, alice)\n\tht.ConnectNodes(carol, dave)\n\n\t// Open a channel with 100k satoshis between Alice and Bob with Alice\n\t// being the sole funder of the channel.\n\tchanPointAlice := ht.OpenChannel(\n\t\talice, bob, lntest.OpenChannelParams{Amt: chanAmt},\n\t)\n\n\t// We'll create Dave and establish a channel to Alice. Dave will be\n\t// running an older node that requires the legacy onion payload.\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, dave)\n\tchanPointDave := ht.OpenChannel(\n\t\tdave, alice, lntest.OpenChannelParams{Amt: chanAmt},\n\t)\n\n\t// Next, we'll create Carol and establish a channel to from her to\n\t// Dave.\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, carol)\n\tchanPointCarol := ht.OpenChannel(\n\t\tcarol, dave, lntest.OpenChannelParams{Amt: chanAmt},\n\t)\n\n\t// Create 5 invoices for Bob, which expect a payment from Carol for 1k\n\t// satoshis with a different preimage each time.\n\tconst numPayments = 5\n\tconst paymentAmt = 1000\n\tpayReqs, _, _ := ht.CreatePayReqs(bob, paymentAmt, numPayments)\n\n\t// Set the fee policies of the Alice -> Bob and the Dave -> Alice\n\t// channel edges to relatively large non default values. This makes it\n\t// possible to pick up more subtle fee calculation errors.\n\tmaxHtlc := lntest.CalculateMaxHtlc(chanAmt)\n\tconst aliceBaseFeeSat = 1\n\tconst aliceFeeRatePPM = 100000\n\tupdateChannelPolicy(\n\t\tht, alice, chanPointAlice, aliceBaseFeeSat*1000,\n\t\taliceFeeRatePPM, chainreg.DefaultBitcoinTimeLockDelta,\n\t\tmaxHtlc, carol,\n\t)\n\n\tconst daveBaseFeeSat = 5\n\tconst daveFeeRatePPM = 150000\n\tupdateChannelPolicy(\n\t\tht, dave, chanPointDave, daveBaseFeeSat*1000, daveFeeRatePPM,\n\t\tchainreg.DefaultBitcoinTimeLockDelta, maxHtlc, carol,\n\t)\n\n\t// Using Carol as the source, pay to the 5 invoices from Bob created\n\t// above.\n\tht.CompletePaymentRequests(carol, payReqs)\n\n\t// At this point all the channels within our proto network should be\n\t// shifted by 5k satoshis in the direction of Bob, the sink within the\n\t// payment flow generated above. The order of asserts corresponds to\n\t// increasing of time is needed to embed the HTLC in commitment\n\t// transaction, in channel Carol->David->Alice->Bob, order is Bob,\n\t// Alice, David, Carol.\n\n\t// The final node bob expects to get paid five times 1000 sat.\n\texpectedAmountPaidAtoB := int64(numPayments * paymentAmt)\n\n\tht.AssertAmountPaid(\"Alice(local) => Bob(remote)\", bob,\n\t\tchanPointAlice, int64(0), expectedAmountPaidAtoB)\n\tht.AssertAmountPaid(\"Alice(local) => Bob(remote)\", alice,\n\t\tchanPointAlice, expectedAmountPaidAtoB, int64(0))\n\n\t// To forward a payment of 1000 sat, Alice is charging a fee of\n\t// 1 sat + 10% = 101 sat.\n\tconst aliceFeePerPayment = aliceBaseFeeSat +\n\t\t(paymentAmt * aliceFeeRatePPM / 1_000_000)\n\tconst expectedFeeAlice = numPayments * aliceFeePerPayment\n\n\t// Dave needs to pay what Alice pays plus Alice's fee.\n\texpectedAmountPaidDtoA := expectedAmountPaidAtoB + expectedFeeAlice\n\n\tht.AssertAmountPaid(\"Dave(local) => Alice(remote)\", alice,\n\t\tchanPointDave, int64(0), expectedAmountPaidDtoA)\n\tht.AssertAmountPaid(\"Dave(local) => Alice(remote)\", dave,\n\t\tchanPointDave, expectedAmountPaidDtoA, int64(0))\n\n\t// To forward a payment of 1101 sat, Dave is charging a fee of\n\t// 5 sat + 15% = 170.15 sat. This is rounded down in rpcserver to 170.\n\tconst davePaymentAmt = paymentAmt + aliceFeePerPayment\n\tconst daveFeePerPayment = daveBaseFeeSat +\n\t\t(davePaymentAmt * daveFeeRatePPM / 1_000_000)\n\tconst expectedFeeDave = numPayments * daveFeePerPayment\n\n\t// Carol needs to pay what Dave pays plus Dave's fee.\n\texpectedAmountPaidCtoD := expectedAmountPaidDtoA + expectedFeeDave\n\n\tht.AssertAmountPaid(\"Carol(local) => Dave(remote)\", dave,\n\t\tchanPointCarol, int64(0), expectedAmountPaidCtoD)\n\tht.AssertAmountPaid(\"Carol(local) => Dave(remote)\", carol,\n\t\tchanPointCarol, expectedAmountPaidCtoD, int64(0))\n\n\t// Now that we know all the balances have been settled out properly,\n\t// we'll ensure that our internal record keeping for completed circuits\n\t// was properly updated.\n\n\t// First, check that the FeeReport response shows the proper fees\n\t// accrued over each time range. Dave should've earned 170 satoshi for\n\t// each of the forwarded payments.\n\tht.AssertFeeReport(\n\t\tdave, expectedFeeDave, expectedFeeDave, expectedFeeDave,\n\t)\n\n\t// Next, ensure that if we issue the vanilla query for the forwarding\n\t// history, it returns 5 values, and each entry is formatted properly.\n\t// From David's perspective he receives a payement from Carol and\n\t// forwards it to Alice. So let's ensure that the forwarding history\n\t// returns Carol's peer alias as inbound and Alice's alias as outbound.\n\tinfo := carol.RPC.GetInfo()\n\tcarolAlias := info.Alias\n\n\tinfo = alice.RPC.GetInfo()\n\taliceAlias := info.Alias\n\n\tfwdingHistory := dave.RPC.ForwardingHistory(nil)\n\trequire.Len(ht, fwdingHistory.ForwardingEvents, numPayments)\n\n\texpectedForwardingFee := uint64(expectedFeeDave / numPayments)\n\tfor _, event := range fwdingHistory.ForwardingEvents {\n\t\t// Each event should show a fee of 170 satoshi.\n\t\trequire.Equal(ht, expectedForwardingFee, event.Fee)\n\n\t\t// Check that peer aliases are empty since the\n\t\t// ForwardingHistoryRequest did not specify the PeerAliasLookup\n\t\t// flag.\n\t\trequire.Empty(ht, event.PeerAliasIn)\n\t\trequire.Empty(ht, event.PeerAliasOut)\n\t}\n\n\t// Lookup the forwarding history again but this time also lookup the\n\t// peers' alias names.\n\tfwdingHistory = dave.RPC.ForwardingHistory(\n\t\t&lnrpc.ForwardingHistoryRequest{\n\t\t\tPeerAliasLookup: true,\n\t\t},\n\t)\n\trequire.Len(ht, fwdingHistory.ForwardingEvents, numPayments)\n\tfor _, event := range fwdingHistory.ForwardingEvents {\n\t\t// Each event should show a fee of 170 satoshi.\n\t\trequire.Equal(ht, expectedForwardingFee, event.Fee)\n\n\t\t// Check that peer aliases adhere to payment flow, namely\n\t\t// Carol->Dave->Alice.\n\t\trequire.Equal(ht, carolAlias, event.PeerAliasIn)\n\t\trequire.Equal(ht, aliceAlias, event.PeerAliasOut)\n\t}\n\n\t// We expect Carol to have successful forwards and settles for\n\t// her sends.\n\tht.AssertHtlcEvents(\n\t\tcarolEvents, numPayments, 0, numPayments,\n\t\trouterrpc.HtlcEvent_SEND,\n\t)\n\n\t// Dave and Alice should both have forwards and settles for\n\t// their role as forwarding nodes.\n\tht.AssertHtlcEvents(\n\t\tdaveEvents, numPayments, 0, numPayments,\n\t\trouterrpc.HtlcEvent_FORWARD,\n\t)\n\tht.AssertHtlcEvents(\n\t\taliceEvents, numPayments, 0, numPayments,\n\t\trouterrpc.HtlcEvent_FORWARD,\n\t)\n\n\t// Bob should only have settle events for his receives.\n\tht.AssertHtlcEvents(\n\t\tbobEvents, 0, 0, numPayments, routerrpc.HtlcEvent_RECEIVE,\n\t)\n\n\t// Finally, close all channels.\n\tht.CloseChannel(alice, chanPointAlice)\n\tht.CloseChannel(dave, chanPointDave)\n\tht.CloseChannel(carol, chanPointCarol)\n}\n\n// updateChannelPolicy updates the channel policy of node to the given fees and\n// timelock delta. This function blocks until listenerNode has received the\n// policy update.\n//\n// NOTE: only used in current test.",
      "length": 7682,
      "tokens": 956,
      "embedding": []
    },
    {
      "slug": "func updateChannelPolicy(ht *lntest.HarnessTest, hn *node.HarnessNode,",
      "content": "func updateChannelPolicy(ht *lntest.HarnessTest, hn *node.HarnessNode,\n\tchanPoint *lnrpc.ChannelPoint, baseFee int64,\n\tfeeRate int64, timeLockDelta uint32,\n\tmaxHtlc uint64, listenerNode *node.HarnessNode) {\n\n\texpectedPolicy := &lnrpc.RoutingPolicy{\n\t\tFeeBaseMsat:      baseFee,\n\t\tFeeRateMilliMsat: feeRate,\n\t\tTimeLockDelta:    timeLockDelta,\n\t\tMinHtlc:          1000, // default value\n\t\tMaxHtlcMsat:      maxHtlc,\n\t}\n\n\tupdateFeeReq := &lnrpc.PolicyUpdateRequest{\n\t\tBaseFeeMsat:   baseFee,\n\t\tFeeRate:       float64(feeRate) / testFeeBase,\n\t\tTimeLockDelta: timeLockDelta,\n\t\tScope: &lnrpc.PolicyUpdateRequest_ChanPoint{\n\t\t\tChanPoint: chanPoint,\n\t\t},\n\t\tMaxHtlcMsat: maxHtlc,\n\t}\n\n\thn.RPC.UpdateChannelPolicy(updateFeeReq)\n\n\t// Wait for listener node to receive the channel update from node.\n\tht.AssertChannelPolicyUpdate(\n\t\tlistenerNode, hn, expectedPolicy, chanPoint, false,\n\t)\n}\n",
      "length": 776,
      "tokens": 70,
      "embedding": []
    }
  ]
}