{
  "filepath": "../implementations/go/lnd/itest/lnd_etcd_failover_test.go",
  "package": "itest",
  "sections": [
    {
      "slug": "//go:build kvdb_etcd",
      "content": "//go:build kvdb_etcd\n// +build kvdb_etcd\n\npackage itest\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/btcsuite/btcd/btcutil\"\n\t\"github.com/lightningnetwork/lnd/cluster\"\n\t\"github.com/lightningnetwork/lnd/kvdb\"\n\t\"github.com/lightningnetwork/lnd/lncfg\"\n\t\"github.com/lightningnetwork/lnd/lnrpc\"\n\t\"github.com/lightningnetwork/lnd/lntest\"\n\t\"github.com/lightningnetwork/lnd/lntest/node\"\n\t\"github.com/stretchr/testify/require\"\n)\n",
      "length": 379,
      "tokens": 18,
      "embedding": []
    },
    {
      "slug": "func assertLeader(ht *lntest.HarnessTest, observer cluster.LeaderElector,",
      "content": "func assertLeader(ht *lntest.HarnessTest, observer cluster.LeaderElector,\n\texpected string) {\n\n\tleader, err := observer.Leader(ht.Context())\n\trequire.NoError(ht, err, \"Unable to query leader\")\n\trequire.Equalf(ht, expected, leader,\n\t\t\"Leader should be '%v', got: '%v'\", expected, leader)\n}\n\n// testEtcdFailover tests that in a cluster setup where two LND nodes form a\n// single cluster (sharing the same identity) one can hand over the leader role\n// to the other (failing over after graceful shutdown or forceful abort).",
      "length": 436,
      "tokens": 65,
      "embedding": []
    },
    {
      "slug": "func testEtcdFailover(ht *lntest.HarnessTest) {",
      "content": "func testEtcdFailover(ht *lntest.HarnessTest) {\n\ttestCases := []struct {\n\t\tname string\n\t\tkill bool\n\t}{{\n\t\tname: \"failover after shutdown\",\n\t\tkill: false,\n\t}, {\n\t\tname: \"failover after abort\",\n\t\tkill: true,\n\t}}\n\n\tfor _, test := range testCases {\n\t\ttest := test\n\n\t\tsuccess := ht.Run(test.name, func(t1 *testing.T) {\n\t\t\tst := ht.Subtest(t1)\n\t\t\ttestEtcdFailoverCase(st, test.kill)\n\t\t})\n\t\tif !success {\n\t\t\treturn\n\t\t}\n\t}\n}\n",
      "length": 346,
      "tokens": 53,
      "embedding": []
    },
    {
      "slug": "func testEtcdFailoverCase(ht *lntest.HarnessTest, kill bool) {",
      "content": "func testEtcdFailoverCase(ht *lntest.HarnessTest, kill bool) {\n\tetcdCfg, cleanup, err := kvdb.StartEtcdTestBackend(\n\t\tht.T.TempDir(), uint16(node.NextAvailablePort()),\n\t\tuint16(node.NextAvailablePort()), \"\",\n\t)\n\trequire.NoError(ht, err, \"Failed to start etcd instance\")\n\tdefer cleanup()\n\n\talice := ht.NewNode(\"Alice\", nil)\n\n\t// Give Alice some coins to fund the channel.\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, alice)\n\n\t// Make leader election session TTL 5 sec to make the test run fast.\n\tconst leaderSessionTTL = 5\n\n\tobserver, err := cluster.MakeLeaderElector(\n\t\tht.Context(), cluster.EtcdLeaderElector, \"observer\",\n\t\tlncfg.DefaultEtcdElectionPrefix, leaderSessionTTL, etcdCfg,\n\t)\n\trequire.NoError(ht, err, \"Cannot start election observer\")\n\n\tpassword := []byte(\"the quick brown fox jumps the lazy dog\")\n\tentropy := [16]byte{1, 2, 3}\n\tstateless := false\n\tcluster := true\n\n\tcarol1, _, _ := ht.NewNodeWithSeedEtcd(\n\t\t\"Carol-1\", etcdCfg, password, entropy[:], stateless, cluster,\n\t\tleaderSessionTTL,\n\t)\n\tinfo1 := carol1.RPC.GetInfo()\n\tht.ConnectNodes(carol1, alice)\n\n\t// Open a channel with 100k satoshis between Carol and Alice with Alice\n\t// being the sole funder of the channel.\n\tchanAmt := btcutil.Amount(100_000)\n\tht.OpenChannel(alice, carol1, lntest.OpenChannelParams{Amt: chanAmt})\n\n\t// At this point Carol-1 is the elected leader, while Carol-2 will wait\n\t// to become the leader when Carol-1 stops.\n\tcarol2 := ht.NewNodeEtcd(\n\t\t\"Carol-2\", etcdCfg, password, cluster, leaderSessionTTL,\n\t)\n\tassertLeader(ht, observer, \"Carol-1\")\n\n\tamt := btcutil.Amount(1000)\n\tpayReqs, _, _ := ht.CreatePayReqs(carol1, amt, 2)\n\tht.CompletePaymentRequests(alice, []string{payReqs[0]})\n\n\t// Shut down or kill Carol-1 and wait for Carol-2 to become the leader.\n\tfailoverTimeout := time.Duration(2*leaderSessionTTL) * time.Second\n\tif kill {\n\t\tht.KillNode(carol1)\n\t} else {\n\t\tht.Shutdown(carol1)\n\t}\n\n\terr = carol2.WaitUntilLeader(failoverTimeout)\n\trequire.NoError(ht, err, \"Waiting for Carol-2 to become the leader \"+\n\t\t\"failed\")\n\tassertLeader(ht, observer, \"Carol-2\")\n\n\treq := &lnrpc.UnlockWalletRequest{WalletPassword: password}\n\terr = carol2.Unlock(req)\n\trequire.NoError(ht, err, \"Unlocking Carol-2 failed\")\n\n\t// Make sure Carol-1 and Carol-2 have the same identity.\n\tinfo2 := carol2.RPC.GetInfo()\n\trequire.Equal(ht, info1.IdentityPubkey, info2.IdentityPubkey,\n\t\t\"Carol-1 and Carol-2 must have the same identity\")\n\n\t// Make sure the nodes are connected before moving forward. Otherwise\n\t// we may get a link not found error.\n\tht.AssertConnected(alice, carol2)\n\n\t// Now let Alice pay the second invoice but this time we expect Carol-2\n\t// to receive the payment.\n\tht.CompletePaymentRequests(alice, []string{payReqs[1]})\n\n\t// Manually shutdown the node as it will mess up with our cleanup\n\t// process.\n\tht.Shutdown(carol2)\n}\n",
      "length": 2665,
      "tokens": 322,
      "embedding": []
    }
  ]
}