{
  "filepath": "../implementations/go/lnd/itest/lnd_custom_message.go",
  "package": "itest",
  "sections": [
    {
      "slug": "func testCustomMessage(ht *lntest.HarnessTest) {",
      "content": "func testCustomMessage(ht *lntest.HarnessTest) {\n\talice, bob := ht.Alice, ht.Bob\n\n\tvar (\n\t\toverrideType1  uint32 = 554\n\t\toverrideType2  uint32 = 555\n\t\tmsgOverrideArg        = \"--protocol.custom-message=%v\"\n\t)\n\n\t// Update Alice to accept custom protocol messages with type 1 but do\n\t// not allow Bob to handle them yet.\n\textraArgs := []string{\n\t\tfmt.Sprintf(msgOverrideArg, overrideType1),\n\t}\n\tht.RestartNodeWithExtraArgs(alice, extraArgs)\n\n\t// Subscribe Alice to custom messages before we send any, so that we\n\t// don't miss any.\n\tmsgClient, cancel := alice.RPC.SubscribeCustomMessages()\n\tdefer cancel()\n\n\t// Create a channel to receive custom messages on.\n\tmessages := make(chan *lnrpc.CustomMessage)\n\tgo func() {\n\t\tfor {\n\t\t\t// If we fail to receive, just exit. The test should\n\t\t\t// fail elsewhere if it doesn't get a message that it\n\t\t\t// was expecting.\n\t\t\tmsg, err := msgClient.Recv()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Deliver the message into our channel or exit if the\n\t\t\t// test is shutting down.\n\t\t\tselect {\n\t\t\tcase messages <- msg:\n\t\t\tcase <-ht.Context().Done():\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Connect alice and bob so that they can exchange messages.\n\tht.EnsureConnected(alice, bob)\n\n\t// Create a custom message that is within our allowed range.\n\tmsgType := uint32(lnwire.CustomTypeStart + 1)\n\tmsgData := []byte{1, 2, 3}\n\n\t// Send it from Bob to Alice.\n\tbobMsg := &lnrpc.SendCustomMessageRequest{\n\t\tPeer: alice.PubKey[:],\n\t\tType: msgType,\n\t\tData: msgData,\n\t}\n\tbob.RPC.SendCustomMessage(bobMsg)\n\n\t// Wait for Alice to receive the message. It should come through\n\t// because it is within our allowed range.\n\tselect {\n\tcase msg := <-messages:\n\t\t// Check our type and data and (sanity) check the peer we got\n\t\t// it from.\n\t\trequire.Equal(ht, msgType, msg.Type, \"first msg type wrong\")\n\t\trequire.Equal(ht, msgData, msg.Data, \"first msg data wrong\")\n\t\trequire.Equal(ht, bob.PubKey[:], msg.Peer, \"first msg \"+\n\t\t\t\"peer wrong\")\n\n\tcase <-time.After(lntest.DefaultTimeout):\n\t\tht.Fatalf(\"alice did not receive first custom message: %v\",\n\t\t\tmsgType)\n\t}\n\n\t// Try to send a message from Bob to Alice which has a message type\n\t// outside of the custom type range and assert that it fails.\n\tbobMsg = &lnrpc.SendCustomMessageRequest{\n\t\tPeer: alice.PubKey[:],\n\t\tType: overrideType1,\n\t\tData: msgData,\n\t}\n\t_, err := bob.RPC.LN.SendCustomMessage(ht.Context(), bobMsg)\n\trequire.Error(ht, err, \"bob should not be able to send type 1\")\n\n\t// Now, restart Bob with the ability to send two different custom\n\t// protocol messages.\n\textraArgs = []string{\n\t\tfmt.Sprintf(msgOverrideArg, overrideType1),\n\t\tfmt.Sprintf(msgOverrideArg, overrideType2),\n\t}\n\tht.RestartNodeWithExtraArgs(bob, extraArgs)\n\n\t// Make sure Bob and Alice are connected after his restart.\n\tht.EnsureConnected(alice, bob)\n\n\t// Send a message from Bob to Alice with a type that Bob is allowed to\n\t// send, but Alice will not handle as a custom message.\n\tbobMsg = &lnrpc.SendCustomMessageRequest{\n\t\tPeer: alice.PubKey[:],\n\t\tType: overrideType2,\n\t\tData: msgData,\n\t}\n\tbob.RPC.SendCustomMessage(bobMsg)\n\n\t// Do a quick check that Alice did not receive this message in her\n\t// stream. Note that this is an instant check, so could miss the\n\t// message being received. We'll also check below that she didn't get\n\t// it, this is just a sanity check.\n\tselect {\n\tcase msg := <-messages:\n\t\tht.Fatalf(\"unexpected message: %v\", msg)\n\tdefault:\n\t}\n\n\t// Finally, send a custom message with a type that Bob is allowed to\n\t// send and Alice is configured to receive.\n\tbobMsg = &lnrpc.SendCustomMessageRequest{\n\t\tPeer: alice.PubKey[:],\n\t\tType: overrideType1,\n\t\tData: msgData,\n\t}\n\tbob.RPC.SendCustomMessage(bobMsg)\n\n\t// Wait to receive a message from Bob. This check serves to ensure that\n\t// our message type 1 was delivered, and assert that the preceding one\n\t// was not (we could have missed it in our check above). When we\n\t// receive the second message, we know that the first one did not go\n\t// through, because we expect our messages to deliver in order.\n\tselect {\n\tcase msg := <-messages:\n\t\t// Check our type and data and (sanity) check the peer we got\n\t\t// it from.\n\t\trequire.Equal(ht, overrideType1, msg.Type, \"second message \"+\n\t\t\t\"type\")\n\t\trequire.Equal(ht, msgData, msg.Data, \"second message data\")\n\t\trequire.Equal(ht, bob.PubKey[:], msg.Peer, \"second \"+\n\t\t\t\"message peer\")\n\n\tcase <-time.After(lntest.DefaultTimeout):\n\t\tht.Fatalf(\"alice did not receive second custom message\")\n\t}\n}\n",
      "length": 4239,
      "tokens": 621,
      "embedding": []
    }
  ]
}