{
  "filepath": "../implementations/go/lnd/itest/lnd_mpp_test.go",
  "package": "itest",
  "sections": [
    {
      "slug": "func testSendToRouteMultiPath(ht *lntest.HarnessTest) {",
      "content": "func testSendToRouteMultiPath(ht *lntest.HarnessTest) {\n\tmts := newMppTestScenario(ht)\n\n\t// To ensure the payment goes through separate paths, we'll set a\n\t// channel size that can only carry one shard at a time. We'll divide\n\t// the payment into 3 shards.\n\tconst (\n\t\tpaymentAmt = btcutil.Amount(300000)\n\t\tshardAmt   = paymentAmt / 3\n\t\tchanAmt    = shardAmt * 3 / 2\n\t)\n\n\t// Set up a network with three different paths Alice <-> Bob.\n\t//              _ Eve _\n\t//             /       \\\n\t// Alice -- Carol ---- Bob\n\t//      \\              /\n\t//       \\__ Dave ____/\n\t//\n\treq := &mppOpenChannelRequest{\n\t\t// Since the channel Alice-> Carol will have to carry two\n\t\t// shards, we make it larger.\n\t\tamtAliceCarol: chanAmt + shardAmt,\n\t\tamtAliceDave:  chanAmt,\n\t\tamtCarolBob:   chanAmt,\n\t\tamtCarolEve:   chanAmt,\n\t\tamtDaveBob:    chanAmt,\n\t\tamtEveBob:     chanAmt,\n\t}\n\tmts.openChannels(req)\n\n\t// Make Bob create an invoice for Alice to pay.\n\tpayReqs, rHashes, invoices := ht.CreatePayReqs(mts.bob, paymentAmt, 1)\n\n\trHash := rHashes[0]\n\tpayReq := payReqs[0]\n\n\tdecodeResp := mts.bob.RPC.DecodePayReq(payReq)\n\tpayAddr := decodeResp.PaymentAddr\n\n\t// Subscribe the invoice.\n\tstream := mts.bob.RPC.SubscribeSingleInvoice(rHash)\n\n\t// We'll send shards along three routes from Alice.\n\tsendRoutes := [][]*node.HarnessNode{\n\t\t{mts.carol, mts.bob},\n\t\t{mts.dave, mts.bob},\n\t\t{mts.carol, mts.eve, mts.bob},\n\t}\n\n\tresponses := make(chan *lnrpc.HTLCAttempt, len(sendRoutes))\n\tfor _, hops := range sendRoutes {\n\t\t// Build a route for the specified hops.\n\t\tr := mts.buildRoute(shardAmt, mts.alice, hops)\n\n\t\t// Set the MPP records to indicate this is a payment shard.\n\t\thop := r.Hops[len(r.Hops)-1]\n\t\thop.TlvPayload = true\n\t\thop.MppRecord = &lnrpc.MPPRecord{\n\t\t\tPaymentAddr:  payAddr,\n\t\t\tTotalAmtMsat: int64(paymentAmt * 1000),\n\t\t}\n\n\t\t// Send the shard.\n\t\tsendReq := &routerrpc.SendToRouteRequest{\n\t\t\tPaymentHash: rHash,\n\t\t\tRoute:       r,\n\t\t}\n\n\t\t// We'll send all shards in their own goroutine, since\n\t\t// SendToRoute will block as long as the payment is in flight.\n\t\tgo func() {\n\t\t\tresp := mts.alice.RPC.SendToRouteV2(sendReq)\n\t\t\tresponses <- resp\n\t\t}()\n\t}\n\n\t// Wait for all responses to be back, and check that they all\n\t// succeeded.\n\ttimer := time.After(defaultTimeout)\n\tfor range sendRoutes {\n\t\tvar resp *lnrpc.HTLCAttempt\n\t\tselect {\n\t\tcase resp = <-responses:\n\t\tcase <-timer:\n\t\t\trequire.Fail(ht, \"response not received\")\n\t\t}\n\n\t\trequire.Nil(ht, resp.Failure, \"received payment failure\")\n\n\t\t// All shards should come back with the preimage.\n\t\trequire.Equal(ht, resp.Preimage, invoices[0].RPreimage,\n\t\t\t\"preimage doesn't match\")\n\t}\n\n\t// assertNumHtlcs is a helper that checks the node's latest payment,\n\t// and asserts it was split into num shards.\n\tassertNumHtlcs := func(hn *node.HarnessNode, num int) {\n\t\tvar preimage lntypes.Preimage\n\t\tcopy(preimage[:], invoices[0].RPreimage)\n\n\t\tpayment := ht.AssertPaymentStatus(\n\t\t\thn, preimage, lnrpc.Payment_SUCCEEDED,\n\t\t)\n\n\t\thtlcs := payment.Htlcs\n\t\trequire.NotEmpty(ht, htlcs, \"no htlcs\")\n\n\t\tsucceeded := 0\n\t\tfor _, htlc := range htlcs {\n\t\t\tif htlc.Status == lnrpc.HTLCAttempt_SUCCEEDED {\n\t\t\t\tsucceeded++\n\t\t\t}\n\t\t}\n\t\trequire.Equal(ht, num, succeeded, \"HTLCs not matched\")\n\t}\n\n\t// assertSettledInvoice checks that the invoice for the given payment\n\t// hash is settled, and has been paid using num HTLCs.\n\tassertSettledInvoice := func(rhash []byte, num int) {\n\t\tvar payHash lntypes.Hash\n\t\tcopy(payHash[:], rhash)\n\t\tinv := ht.AssertInvoiceState(stream, lnrpc.Invoice_SETTLED)\n\n\t\t// Assert that the amount paid to the invoice is correct.\n\t\trequire.EqualValues(ht, paymentAmt, inv.AmtPaidSat,\n\t\t\t\"incorrect payment amt\")\n\n\t\trequire.Len(ht, inv.Htlcs, num, \"wrong num of HTLCs\")\n\t}\n\n\t// Finally check that the payment shows up with three settled HTLCs in\n\t// Alice's list of payments...\n\tassertNumHtlcs(mts.alice, 3)\n\n\t// ...and in Bob's list of paid invoices.\n\tassertSettledInvoice(rHash, 3)\n\n\t// Finally, close all channels.\n\tmts.closeChannels()\n}\n\n// mppTestScenario defines a test scenario used for testing MPP-related tests.\n// It has two standby nodes, alice and bob, and three new nodes, carol, dave,\n// and eve.",
      "length": 3935,
      "tokens": 534,
      "embedding": []
    },
    {
      "slug": "type mppTestScenario struct {",
      "content": "type mppTestScenario struct {\n\tht *lntest.HarnessTest\n\n\talice, bob, carol, dave, eve *node.HarnessNode\n\tnodes                        []*node.HarnessNode\n\n\t// Keep a list of all our active channels.\n\tchannelPoints []*lnrpc.ChannelPoint\n}\n\n// newMppTestScenario initializes a new mpp test scenario with five funded\n// nodes and connects them to have the following topology,\n//\n//\t            _ Eve _\n//\t           /       \\\n//\tAlice -- Carol ---- Bob\n//\t    \\              /\n//\t     \\__ Dave ____/",
      "length": 449,
      "tokens": 64,
      "embedding": []
    },
    {
      "slug": "func newMppTestScenario(ht *lntest.HarnessTest) *mppTestScenario {",
      "content": "func newMppTestScenario(ht *lntest.HarnessTest) *mppTestScenario {\n\talice, bob := ht.Alice, ht.Bob\n\tht.RestartNodeWithExtraArgs(bob, []string{\n\t\t\"--maxpendingchannels=2\",\n\t\t\"--accept-amp\",\n\t})\n\n\t// Create a five-node context consisting of Alice, Bob and three new\n\t// nodes.\n\tcarol := ht.NewNode(\"carol\", []string{\n\t\t\"--maxpendingchannels=2\",\n\t\t\"--accept-amp\",\n\t})\n\tdave := ht.NewNode(\"dave\", nil)\n\teve := ht.NewNode(\"eve\", nil)\n\n\t// Connect nodes to ensure propagation of channels.\n\tht.EnsureConnected(alice, carol)\n\tht.EnsureConnected(alice, dave)\n\tht.EnsureConnected(carol, bob)\n\tht.EnsureConnected(carol, eve)\n\tht.EnsureConnected(dave, bob)\n\tht.EnsureConnected(eve, bob)\n\n\t// Send coins to the nodes and mine 1 blocks to confirm them.\n\tfor i := 0; i < 2; i++ {\n\t\tht.FundCoinsUnconfirmed(btcutil.SatoshiPerBitcoin, carol)\n\t\tht.FundCoinsUnconfirmed(btcutil.SatoshiPerBitcoin, dave)\n\t\tht.FundCoinsUnconfirmed(btcutil.SatoshiPerBitcoin, eve)\n\t\tht.MineBlocks(1)\n\t}\n\n\tmts := &mppTestScenario{\n\t\tht:    ht,\n\t\talice: alice,\n\t\tbob:   bob,\n\t\tcarol: carol,\n\t\tdave:  dave,\n\t\teve:   eve,\n\t\tnodes: []*node.HarnessNode{alice, bob, carol, dave, eve},\n\t}\n\n\treturn mts\n}\n\n// mppOpenChannelRequest defines the amounts used for each channel opening.",
      "length": 1122,
      "tokens": 124,
      "embedding": []
    },
    {
      "slug": "type mppOpenChannelRequest struct {",
      "content": "type mppOpenChannelRequest struct {\n\t// Channel Alice=>Carol.\n\tamtAliceCarol btcutil.Amount\n\n\t// Channel Alice=>Dave.\n\tamtAliceDave btcutil.Amount\n\n\t// Channel Carol=>Bob.\n\tamtCarolBob btcutil.Amount\n\n\t// Channel Carol=>Eve.\n\tamtCarolEve btcutil.Amount\n\n\t// Channel Dave=>Bob.\n\tamtDaveBob btcutil.Amount\n\n\t// Channel Eve=>Bob.\n\tamtEveBob btcutil.Amount\n}\n\n// openChannels is a helper to open channels that sets up a network topology\n// with three different paths Alice <-> Bob as following,\n//\n//\t\t _ Eve _\n//\t\t/       \\\n//\t Alice -- Carol ---- Bob\n//\t\t\\              /\n//\t\t \\__ Dave ____/\n//\n// NOTE: all the channels are open together to save blocks mined.",
      "length": 594,
      "tokens": 89,
      "embedding": []
    },
    {
      "slug": "func (m *mppTestScenario) openChannels(r *mppOpenChannelRequest) {",
      "content": "func (m *mppTestScenario) openChannels(r *mppOpenChannelRequest) {\n\treqs := []*lntest.OpenChannelRequest{\n\t\t{\n\t\t\tLocal:  m.alice,\n\t\t\tRemote: m.carol,\n\t\t\tParam:  lntest.OpenChannelParams{Amt: r.amtAliceCarol},\n\t\t},\n\t\t{\n\t\t\tLocal:  m.alice,\n\t\t\tRemote: m.dave,\n\t\t\tParam:  lntest.OpenChannelParams{Amt: r.amtAliceDave},\n\t\t},\n\t\t{\n\t\t\tLocal:  m.carol,\n\t\t\tRemote: m.bob,\n\t\t\tParam:  lntest.OpenChannelParams{Amt: r.amtCarolBob},\n\t\t},\n\t\t{\n\t\t\tLocal:  m.carol,\n\t\t\tRemote: m.eve,\n\t\t\tParam:  lntest.OpenChannelParams{Amt: r.amtCarolEve},\n\t\t},\n\t\t{\n\t\t\tLocal:  m.dave,\n\t\t\tRemote: m.bob,\n\t\t\tParam:  lntest.OpenChannelParams{Amt: r.amtDaveBob},\n\t\t},\n\t\t{\n\t\t\tLocal:  m.eve,\n\t\t\tRemote: m.bob,\n\t\t\tParam:  lntest.OpenChannelParams{Amt: r.amtEveBob},\n\t\t},\n\t}\n\n\tm.channelPoints = m.ht.OpenMultiChannelsAsync(reqs)\n\n\t// Make sure every node has heard every channel.\n\tfor _, hn := range m.nodes {\n\t\tfor _, cp := range m.channelPoints {\n\t\t\tm.ht.AssertTopologyChannelOpen(hn, cp)\n\t\t}\n\t}\n}\n\n// closeChannels closes all the open channels from `openChannels`.",
      "length": 915,
      "tokens": 98,
      "embedding": []
    },
    {
      "slug": "func (m *mppTestScenario) closeChannels() {",
      "content": "func (m *mppTestScenario) closeChannels() {\n\tif m.ht.Failed() {\n\t\tm.ht.Log(\"Skipped closing channels for failed test\")\n\t\treturn\n\t}\n\n\t// TODO(yy): remove the sleep once the following bug is fixed. When the\n\t// payment is reported as settled by Alice, it's expected the\n\t// commitment dance is finished and all subsequent states have been\n\t// updated. Yet we'd receive the error `cannot co-op close channel with\n\t// active htlcs` or `link failed to shutdown` if we close the channel.\n\t// We need to investigate the order of settling the payments and\n\t// updating commitments to understand and fix .\n\ttime.Sleep(5 * time.Second)\n\n\t// Close all channels without mining the closing transactions.\n\tm.ht.CloseChannelAssertPending(m.alice, m.channelPoints[0], false)\n\tm.ht.CloseChannelAssertPending(m.alice, m.channelPoints[1], false)\n\tm.ht.CloseChannelAssertPending(m.carol, m.channelPoints[2], false)\n\tm.ht.CloseChannelAssertPending(m.carol, m.channelPoints[3], false)\n\tm.ht.CloseChannelAssertPending(m.dave, m.channelPoints[4], false)\n\tm.ht.CloseChannelAssertPending(m.eve, m.channelPoints[5], false)\n\n\t// Now mine a block to include all the closing transactions.\n\tm.ht.MineBlocks(1)\n\n\t// Assert that the channels are closed.\n\tfor _, hn := range m.nodes {\n\t\tm.ht.AssertNumWaitingClose(hn, 0)\n\t}\n}\n\n// Helper function for Alice to build a route from pubkeys.",
      "length": 1277,
      "tokens": 162,
      "embedding": []
    },
    {
      "slug": "func (m *mppTestScenario) buildRoute(amt btcutil.Amount,",
      "content": "func (m *mppTestScenario) buildRoute(amt btcutil.Amount,\n\tsender *node.HarnessNode, hops []*node.HarnessNode) *lnrpc.Route {\n\n\trpcHops := make([][]byte, 0, len(hops))\n\tfor _, hop := range hops {\n\t\tk := hop.PubKeyStr\n\t\tpubkey, err := route.NewVertexFromStr(k)\n\t\trequire.NoErrorf(m.ht, err, \"error parsing %v: %v\", k, err)\n\t\trpcHops = append(rpcHops, pubkey[:])\n\t}\n\n\treq := &routerrpc.BuildRouteRequest{\n\t\tAmtMsat:        int64(amt * 1000),\n\t\tFinalCltvDelta: chainreg.DefaultBitcoinTimeLockDelta,\n\t\tHopPubkeys:     rpcHops,\n\t}\n\trouteResp := sender.RPC.BuildRoute(req)\n\n\treturn routeResp.Route\n}\n\n// updatePolicy updates a Dave's global channel policy and returns the expected\n// policy for further check. It changes Dave's `FeeBaseMsat` from 1000 msat to\n// 500,000 msat, and `FeeProportionalMillonths` from 1 msat to 1000 msat.",
      "length": 747,
      "tokens": 92,
      "embedding": []
    },
    {
      "slug": "func (m *mppTestScenario) updateDaveGlobalPolicy() *lnrpc.RoutingPolicy {",
      "content": "func (m *mppTestScenario) updateDaveGlobalPolicy() *lnrpc.RoutingPolicy {\n\tconst (\n\t\tbaseFeeMsat = 500_000\n\t\tfeeRate     = 0.001\n\t\tmaxHtlcMsat = 133_650_000\n\t)\n\n\texpectedPolicy := &lnrpc.RoutingPolicy{\n\t\tFeeBaseMsat:      baseFeeMsat,\n\t\tFeeRateMilliMsat: feeRate * testFeeBase,\n\t\tTimeLockDelta:    40,\n\t\tMinHtlc:          1000, // default value\n\t\tMaxHtlcMsat:      maxHtlcMsat,\n\t}\n\n\tupdateFeeReq := &lnrpc.PolicyUpdateRequest{\n\t\tBaseFeeMsat:   baseFeeMsat,\n\t\tFeeRate:       feeRate,\n\t\tTimeLockDelta: 40,\n\t\tScope:         &lnrpc.PolicyUpdateRequest_Global{Global: true},\n\t\tMaxHtlcMsat:   maxHtlcMsat,\n\t}\n\tm.dave.RPC.UpdateChannelPolicy(updateFeeReq)\n\n\treturn expectedPolicy\n}\n",
      "length": 576,
      "tokens": 50,
      "embedding": []
    }
  ]
}