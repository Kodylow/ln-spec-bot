{
  "filepath": "../implementations/go/lnd/itest/lnd_misc_test.go",
  "package": "itest",
  "sections": [
    {
      "slug": "func testDisconnectingTargetPeer(ht *lntest.HarnessTest) {",
      "content": "func testDisconnectingTargetPeer(ht *lntest.HarnessTest) {\n\t// We'll start both nodes with a high backoff so that they don't\n\t// reconnect automatically during our test.\n\targs := []string{\n\t\t\"--minbackoff=1m\",\n\t\t\"--maxbackoff=1m\",\n\t}\n\n\talice, bob := ht.Alice, ht.Bob\n\tht.RestartNodeWithExtraArgs(alice, args)\n\tht.RestartNodeWithExtraArgs(bob, args)\n\n\t// Start by connecting Alice and Bob with no channels.\n\tht.EnsureConnected(alice, bob)\n\n\tchanAmt := funding.MaxBtcFundingAmount\n\tpushAmt := btcutil.Amount(0)\n\n\t// Create a new channel that requires 1 confs before it's considered\n\t// open, then broadcast the funding transaction\n\tconst numConfs = 1\n\tp := lntest.OpenChannelParams{\n\t\tAmt:     chanAmt,\n\t\tPushAmt: pushAmt,\n\t}\n\tstream := ht.OpenChannelAssertStream(alice, bob, p)\n\n\t// At this point, the channel's funding transaction will have been\n\t// broadcast, but not confirmed. Alice and Bob's nodes should reflect\n\t// this when queried via RPC.\n\tht.AssertNumPendingOpenChannels(alice, 1)\n\tht.AssertNumPendingOpenChannels(bob, 1)\n\n\t// Disconnect Alice-peer from Bob-peer should have no error.\n\tht.DisconnectNodes(alice, bob)\n\n\t// Assert that the connection was torn down.\n\tht.AssertNotConnected(alice, bob)\n\n\t// Mine a block, then wait for Alice's node to notify us that the\n\t// channel has been opened.\n\tht.MineBlocksAndAssertNumTxes(numConfs, 1)\n\n\t// At this point, the channel should be fully opened and there should\n\t// be no pending channels remaining for either node.\n\tht.AssertNumPendingOpenChannels(alice, 0)\n\tht.AssertNumPendingOpenChannels(bob, 0)\n\n\t// Reconnect the nodes so that the channel can become active.\n\tht.ConnectNodes(alice, bob)\n\n\t// The channel should be listed in the peer information returned by\n\t// both peers.\n\tchanPoint := ht.WaitForChannelOpenEvent(stream)\n\n\t// Check both nodes to ensure that the channel is ready for operation.\n\tht.AssertChannelExists(alice, chanPoint)\n\tht.AssertChannelExists(bob, chanPoint)\n\n\t// Disconnect Alice-peer from Bob-peer should have no error.\n\tht.DisconnectNodes(alice, bob)\n\n\t// Check existing connection.\n\tht.AssertNotConnected(alice, bob)\n\n\t// Reconnect both nodes before force closing the channel.\n\tht.ConnectNodes(alice, bob)\n\n\t// Finally, immediately close the channel. This function will also\n\t// block until the channel is closed and will additionally assert the\n\t// relevant channel closing post conditions.\n\tht.ForceCloseChannel(alice, chanPoint)\n\n\t// Disconnect Alice-peer from Bob-peer should have no error.\n\tht.DisconnectNodes(alice, bob)\n\n\t// Check that the nodes not connected.\n\tht.AssertNotConnected(alice, bob)\n\n\t// Finally, re-connect both nodes.\n\tht.ConnectNodes(alice, bob)\n\n\t// Check existing connection.\n\tht.AssertConnected(alice, bob)\n}\n\n// testSphinxReplayPersistence verifies that replayed onion packets are\n// rejected by a remote peer after a restart. We use a combination of unsafe\n// configuration arguments to force Carol to replay the same sphinx packet\n// after reconnecting to Dave, and compare the returned failure message with\n// what we expect for replayed onion packets.",
      "length": 2922,
      "tokens": 383,
      "embedding": []
    },
    {
      "slug": "func testSphinxReplayPersistence(ht *lntest.HarnessTest) {",
      "content": "func testSphinxReplayPersistence(ht *lntest.HarnessTest) {\n\t// Open a channel with 100k satoshis between Carol and Dave with Carol\n\t// being the sole funder of the channel.\n\tchanAmt := btcutil.Amount(100000)\n\n\t// First, we'll create Dave, the receiver, and start him in hodl mode.\n\tdave := ht.NewNode(\"Dave\", []string{\"--hodl.exit-settle\"})\n\n\t// Next, we'll create Carol and establish a channel to from her to\n\t// Dave. Carol is started in both unsafe-replay which will cause her to\n\t// replay any pending Adds held in memory upon reconnection.\n\tcarol := ht.NewNode(\"Carol\", []string{\"--unsafe-replay\"})\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, carol)\n\n\tht.ConnectNodes(carol, dave)\n\tchanPoint := ht.OpenChannel(\n\t\tcarol, dave, lntest.OpenChannelParams{\n\t\t\tAmt: chanAmt,\n\t\t},\n\t)\n\n\t// Next, we'll create Fred who is going to initiate the payment and\n\t// establish a channel to from him to Carol. We can't perform this test\n\t// by paying from Carol directly to Dave, because the '--unsafe-replay'\n\t// setup doesn't apply to locally added htlcs. In that case, the\n\t// mailbox, that is responsible for generating the replay, is bypassed.\n\tfred := ht.NewNode(\"Fred\", nil)\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, fred)\n\n\tht.ConnectNodes(fred, carol)\n\tchanPointFC := ht.OpenChannel(\n\t\tfred, carol, lntest.OpenChannelParams{\n\t\t\tAmt: chanAmt,\n\t\t},\n\t)\n\tdefer ht.CloseChannel(fred, chanPointFC)\n\n\t// Now that the channel is open, create an invoice for Dave which\n\t// expects a payment of 1000 satoshis from Carol paid via a particular\n\t// preimage.\n\tconst paymentAmt = 1000\n\tpreimage := ht.Random32Bytes()\n\tinvoice := &lnrpc.Invoice{\n\t\tMemo:      \"testing\",\n\t\tRPreimage: preimage,\n\t\tValue:     paymentAmt,\n\t}\n\tinvoiceResp := dave.RPC.AddInvoice(invoice)\n\n\t// Wait for all channels to be recognized and advertized.\n\tht.AssertTopologyChannelOpen(carol, chanPoint)\n\tht.AssertTopologyChannelOpen(dave, chanPoint)\n\tht.AssertTopologyChannelOpen(carol, chanPointFC)\n\tht.AssertTopologyChannelOpen(fred, chanPointFC)\n\n\t// With the invoice for Dave added, send a payment from Fred paying\n\t// to the above generated invoice.\n\treq := &routerrpc.SendPaymentRequest{\n\t\tPaymentRequest: invoiceResp.PaymentRequest,\n\t\tTimeoutSeconds: 60,\n\t\tFeeLimitMsat:   noFeeLimitMsat,\n\t}\n\tpayStream := fred.RPC.SendPayment(req)\n\n\t// Dave's invoice should not be marked as settled.\n\tmsg := &invoicesrpc.LookupInvoiceMsg{\n\t\tInvoiceRef: &invoicesrpc.LookupInvoiceMsg_PaymentAddr{\n\t\t\tPaymentAddr: invoiceResp.PaymentAddr,\n\t\t},\n\t}\n\tdbInvoice := dave.RPC.LookupInvoiceV2(msg)\n\trequire.NotEqual(ht, lnrpc.InvoiceHTLCState_SETTLED, dbInvoice.State,\n\t\t\"dave's invoice should not be marked as settled\")\n\n\t// With the payment sent but hedl, all balance related stats should not\n\t// have changed.\n\tht.AssertAmountPaid(\"carol => dave\", carol, chanPoint, 0, 0)\n\tht.AssertAmountPaid(\"dave <= carol\", dave, chanPoint, 0, 0)\n\n\t// Before we restart Dave, make sure both Carol and Dave have added the\n\t// HTLC.\n\tht.AssertNumActiveHtlcs(carol, 2)\n\tht.AssertNumActiveHtlcs(dave, 1)\n\n\t// With the first payment sent, restart dave to make sure he is\n\t// persisting the information required to detect replayed sphinx\n\t// packets.\n\tht.RestartNode(dave)\n\n\t// Carol should retransmit the Add hedl in her mailbox on startup. Dave\n\t// should not accept the replayed Add, and actually fail back the\n\t// pending payment. Even though he still holds the original settle, if\n\t// he does fail, it is almost certainly caused by the sphinx replay\n\t// protection, as it is the only validation we do in hodl mode.\n\t//\n\t// Assert that Fred receives the expected failure after Carol sent a\n\t// duplicate packet that fails due to sphinx replay detection.\n\tht.AssertPaymentStatusFromStream(payStream, lnrpc.Payment_FAILED)\n\tht.AssertLastHTLCError(fred, lnrpc.Failure_INVALID_ONION_KEY)\n\n\t// Since the payment failed, the balance should still be left\n\t// unaltered.\n\tht.AssertAmountPaid(\"carol => dave\", carol, chanPoint, 0, 0)\n\tht.AssertAmountPaid(\"dave <= carol\", dave, chanPoint, 0, 0)\n\n\t// Cleanup by mining the force close and sweep transaction.\n\tht.ForceCloseChannel(carol, chanPoint)\n}\n\n// testListChannels checks that the response from ListChannels is correct. It\n// tests the values in all ChannelConstraints are returned as expected. Once\n// ListChannels becomes mature, a test against all fields in ListChannels\n// should be performed.",
      "length": 4192,
      "tokens": 550,
      "embedding": []
    },
    {
      "slug": "func testListChannels(ht *lntest.HarnessTest) {",
      "content": "func testListChannels(ht *lntest.HarnessTest) {\n\tconst aliceRemoteMaxHtlcs = 50\n\tconst bobRemoteMaxHtlcs = 100\n\n\t// Get the standby nodes and open a channel between them.\n\talice, bob := ht.Alice, ht.Bob\n\n\targs := []string{fmt.Sprintf(\n\t\t\"--default-remote-max-htlcs=%v\",\n\t\tbobRemoteMaxHtlcs,\n\t)}\n\tht.RestartNodeWithExtraArgs(bob, args)\n\n\t// Connect Alice to Bob.\n\tht.EnsureConnected(alice, bob)\n\n\t// Open a channel with 100k satoshis between Alice and Bob with Alice\n\t// being the sole funder of the channel. The minial HTLC amount is set\n\t// to 4200 msats.\n\tconst customizedMinHtlc = 4200\n\n\tchanAmt := btcutil.Amount(100000)\n\tpushAmt := btcutil.Amount(1000)\n\tp := lntest.OpenChannelParams{\n\t\tAmt:            chanAmt,\n\t\tPushAmt:        pushAmt,\n\t\tMinHtlc:        customizedMinHtlc,\n\t\tRemoteMaxHtlcs: aliceRemoteMaxHtlcs,\n\t}\n\tchanPoint := ht.OpenChannel(alice, bob, p)\n\tdefer ht.CloseChannel(alice, chanPoint)\n\n\t// Alice should have one channel opened with Bob.\n\tht.AssertNodeNumChannels(alice, 1)\n\t// Bob should have one channel opened with Alice.\n\tht.AssertNodeNumChannels(bob, 1)\n\n\t// Check the returned response is correct.\n\taliceChannel := ht.QueryChannelByChanPoint(alice, chanPoint)\n\n\t// Query the channel again, this time with peer alias lookup.\n\taliceChannelWithAlias := ht.QueryChannelByChanPoint(\n\t\talice, chanPoint, lntest.WithPeerAliasLookup(),\n\t)\n\n\t// Since Alice is the initiator, she pays the commit fee.\n\taliceBalance := int64(chanAmt) - aliceChannel.CommitFee - int64(pushAmt)\n\n\tbobAlias := bob.RPC.GetInfo().Alias\n\n\t// Check the balance related fields are correct.\n\trequire.Equal(ht, aliceBalance, aliceChannel.LocalBalance)\n\trequire.Empty(ht, aliceChannel.PeerAlias)\n\trequire.Equal(ht, bobAlias, aliceChannelWithAlias.PeerAlias)\n\trequire.EqualValues(ht, pushAmt, aliceChannel.RemoteBalance)\n\trequire.EqualValues(ht, pushAmt, aliceChannel.PushAmountSat)\n\n\t// Calculate the dust limit we'll use for the test.\n\tdustLimit := lnwallet.DustLimitForSize(input.UnknownWitnessSize)\n\n\t// defaultConstraints is a ChannelConstraints with default values. It\n\t// is used to test against Alice's local channel constraints.\n\tdefaultConstraints := &lnrpc.ChannelConstraints{\n\t\tCsvDelay:          4,\n\t\tChanReserveSat:    1000,\n\t\tDustLimitSat:      uint64(dustLimit),\n\t\tMaxPendingAmtMsat: 99000000,\n\t\tMinHtlcMsat:       1,\n\t\tMaxAcceptedHtlcs:  bobRemoteMaxHtlcs,\n\t}\n\tassertChannelConstraintsEqual(\n\t\tht, defaultConstraints, aliceChannel.LocalConstraints,\n\t)\n\n\t// customizedConstraints is a ChannelConstraints with customized\n\t// values. Ideally, all these values can be passed in when creating the\n\t// channel. Currently, only the MinHtlcMsat is customized. It is used\n\t// to check against Alice's remote channel constratins.\n\tcustomizedConstraints := &lnrpc.ChannelConstraints{\n\t\tCsvDelay:          4,\n\t\tChanReserveSat:    1000,\n\t\tDustLimitSat:      uint64(dustLimit),\n\t\tMaxPendingAmtMsat: 99000000,\n\t\tMinHtlcMsat:       customizedMinHtlc,\n\t\tMaxAcceptedHtlcs:  aliceRemoteMaxHtlcs,\n\t}\n\tassertChannelConstraintsEqual(\n\t\tht, customizedConstraints, aliceChannel.RemoteConstraints,\n\t)\n\n\t// Get the ListChannel response for Bob.\n\tbobChannel := ht.QueryChannelByChanPoint(bob, chanPoint)\n\trequire.Equal(ht, aliceChannel.ChannelPoint, bobChannel.ChannelPoint,\n\t\t\"Bob's channel point mismatched\")\n\n\t// Query the channel again, this time with node alias lookup.\n\tbobChannelWithAlias := ht.QueryChannelByChanPoint(\n\t\tbob, chanPoint, lntest.WithPeerAliasLookup(),\n\t)\n\n\taliceAlias := alice.RPC.GetInfo().Alias\n\n\t// Check the balance related fields are correct.\n\trequire.Equal(ht, aliceBalance, bobChannel.RemoteBalance)\n\trequire.Empty(ht, bobChannel.PeerAlias)\n\trequire.Equal(ht, aliceAlias, bobChannelWithAlias.PeerAlias)\n\trequire.EqualValues(ht, pushAmt, bobChannel.LocalBalance)\n\trequire.EqualValues(ht, pushAmt, bobChannel.PushAmountSat)\n\n\t// Check channel constraints match. Alice's local channel constraint\n\t// should be equal to Bob's remote channel constraint, and her remote\n\t// one should be equal to Bob's local one.\n\tassertChannelConstraintsEqual(\n\t\tht, aliceChannel.LocalConstraints, bobChannel.RemoteConstraints,\n\t)\n\tassertChannelConstraintsEqual(\n\t\tht, aliceChannel.RemoteConstraints, bobChannel.LocalConstraints,\n\t)\n}\n\n// testMaxPendingChannels checks that error is returned from remote peer if\n// max pending channel number was exceeded and that '--maxpendingchannels' flag\n// exists and works properly.",
      "length": 4239,
      "tokens": 436,
      "embedding": []
    },
    {
      "slug": "func testMaxPendingChannels(ht *lntest.HarnessTest) {",
      "content": "func testMaxPendingChannels(ht *lntest.HarnessTest) {\n\tmaxPendingChannels := lncfg.DefaultMaxPendingChannels + 1\n\tamount := funding.MaxBtcFundingAmount\n\n\t// Create a new node (Carol) with greater number of max pending\n\t// channels.\n\targs := []string{\n\t\tfmt.Sprintf(\"--maxpendingchannels=%v\", maxPendingChannels),\n\t}\n\tcarol := ht.NewNode(\"Carol\", args)\n\n\talice := ht.Alice\n\tht.ConnectNodes(alice, carol)\n\n\tcarolBalance := btcutil.Amount(maxPendingChannels) * amount\n\tht.FundCoins(carolBalance, carol)\n\n\t// Send open channel requests without generating new blocks thereby\n\t// increasing pool of pending channels. Then check that we can't open\n\t// the channel if the number of pending channels exceed max value.\n\topenStreams := make(\n\t\t[]lnrpc.Lightning_OpenChannelClient, maxPendingChannels,\n\t)\n\tfor i := 0; i < maxPendingChannels; i++ {\n\t\tstream := ht.OpenChannelAssertStream(\n\t\t\talice, carol, lntest.OpenChannelParams{\n\t\t\t\tAmt: amount,\n\t\t\t},\n\t\t)\n\t\topenStreams[i] = stream\n\t}\n\n\t// Carol exhausted available amount of pending channels, next open\n\t// channel request should cause ErrorGeneric to be sent back to Alice.\n\tht.OpenChannelAssertErr(\n\t\talice, carol, lntest.OpenChannelParams{\n\t\t\tAmt: amount,\n\t\t}, lnwire.ErrMaxPendingChannels,\n\t)\n\n\t// For now our channels are in pending state, in order to not interfere\n\t// with other tests we should clean up - complete opening of the\n\t// channel and then close it.\n\n\t// Mine 6 blocks, then wait for node's to notify us that the channel\n\t// has been opened. The funding transactions should be found within the\n\t// first newly mined block. 6 blocks make sure the funding transaction\n\t// has enough confirmations to be announced publicly.\n\tblock := ht.MineBlocksAndAssertNumTxes(6, maxPendingChannels)[0]\n\n\tchanPoints := make([]*lnrpc.ChannelPoint, maxPendingChannels)\n\tfor i, stream := range openStreams {\n\t\tfundingChanPoint := ht.WaitForChannelOpenEvent(stream)\n\n\t\tfundingTxID := ht.GetChanPointFundingTxid(fundingChanPoint)\n\n\t\t// Ensure that the funding transaction enters a block, and is\n\t\t// properly advertised by Alice.\n\t\tht.Miner.AssertTxInBlock(block, fundingTxID)\n\t\tht.AssertTopologyChannelOpen(alice, fundingChanPoint)\n\n\t\t// The channel should be listed in the peer information\n\t\t// returned by both peers.\n\t\tht.AssertChannelExists(alice, fundingChanPoint)\n\n\t\tchanPoints[i] = fundingChanPoint\n\t}\n\n\t// Next, close the channel between Alice and Carol, asserting that the\n\t// channel has been properly closed on-chain.\n\tfor _, chanPoint := range chanPoints {\n\t\tht.CloseChannel(alice, chanPoint)\n\t}\n}\n\n// testGarbageCollectLinkNodes tests that we properly garbage collect link\n// nodes from the database and the set of persistent connections within the\n// server.",
      "length": 2581,
      "tokens": 333,
      "embedding": []
    },
    {
      "slug": "func testGarbageCollectLinkNodes(ht *lntest.HarnessTest) {",
      "content": "func testGarbageCollectLinkNodes(ht *lntest.HarnessTest) {\n\tconst chanAmt = 1000000\n\n\talice, bob := ht.Alice, ht.Bob\n\n\t// Open a channel between Alice and Bob which will later be\n\t// cooperatively closed.\n\tcoopChanPoint := ht.OpenChannel(\n\t\talice, bob, lntest.OpenChannelParams{\n\t\t\tAmt: chanAmt,\n\t\t},\n\t)\n\n\t// Create Carol's node and connect Alice to her.\n\tcarol := ht.NewNode(\"Carol\", nil)\n\tht.ConnectNodes(alice, carol)\n\n\t// Open a channel between Alice and Carol which will later be force\n\t// closed.\n\tforceCloseChanPoint := ht.OpenChannel(\n\t\talice, carol, lntest.OpenChannelParams{\n\t\t\tAmt: chanAmt,\n\t\t},\n\t)\n\n\t// Now, create Dave's a node and also open a channel between Alice and\n\t// him. This link will serve as the only persistent link throughout\n\t// restarts in this test.\n\tdave := ht.NewNode(\"Dave\", nil)\n\n\tht.ConnectNodes(alice, dave)\n\tpersistentChanPoint := ht.OpenChannel(\n\t\talice, dave, lntest.OpenChannelParams{\n\t\t\tAmt: chanAmt,\n\t\t},\n\t)\n\n\t// Restart both Bob and Carol to ensure Alice is able to reconnect to\n\t// them.\n\tht.RestartNode(bob)\n\tht.RestartNode(carol)\n\n\tht.AssertConnected(alice, bob)\n\tht.AssertConnected(alice, carol)\n\n\t// We'll also restart Alice to ensure she can reconnect to her peers\n\t// with open channels.\n\tht.RestartNode(alice)\n\n\tht.AssertConnected(alice, bob)\n\tht.AssertConnected(alice, carol)\n\tht.AssertConnected(alice, dave)\n\n\t// testReconnection is a helper closure that restarts the nodes at both\n\t// ends of a channel to ensure they do not reconnect after restarting.\n\t// When restarting Alice, we'll first need to ensure she has\n\t// reestablished her connection with Dave, as they still have an open\n\t// channel together.\n\ttestReconnection := func(node *node.HarnessNode) {\n\t\t// Restart both nodes, to trigger the pruning logic.\n\t\tht.RestartNode(node)\n\t\tht.RestartNode(alice)\n\n\t\t// Now restart both nodes and make sure they don't reconnect.\n\t\tht.RestartNode(node)\n\t\tht.AssertNotConnected(alice, node)\n\n\t\tht.RestartNode(alice)\n\t\tht.AssertConnected(alice, dave)\n\t\tht.AssertNotConnected(alice, node)\n\t}\n\n\t// Now, we'll close the channel between Alice and Bob and ensure there\n\t// is no reconnection logic between the both once the channel is fully\n\t// closed.\n\tht.CloseChannel(alice, coopChanPoint)\n\n\ttestReconnection(bob)\n\n\t// We'll do the same with Alice and Carol, but this time we'll force\n\t// close the channel instead.\n\tht.ForceCloseChannel(alice, forceCloseChanPoint)\n\n\t// We'll need to mine some blocks in order to mark the channel fully\n\t// closed.\n\tht.MineBlocks(\n\t\tchainreg.DefaultBitcoinTimeLockDelta - defaultCSV,\n\t)\n\n\t// Before we test reconnection, we'll ensure that the channel has been\n\t// fully cleaned up for both Carol and Alice.\n\tht.AssertNumPendingForceClose(alice, 0)\n\tht.AssertNumPendingForceClose(carol, 0)\n\n\ttestReconnection(carol)\n\n\t// Finally, we'll ensure that Bob and Carol no longer show in Alice's\n\t// channel graph.\n\treq := &lnrpc.ChannelGraphRequest{IncludeUnannounced: true}\n\tchannelGraph := alice.RPC.DescribeGraph(req)\n\trequire.NotContains(ht, channelGraph.Nodes, bob.PubKeyStr,\n\t\t\"did not expect to find bob in the channel graph, but did\")\n\trequire.NotContains(ht, channelGraph.Nodes, carol.PubKeyStr,\n\t\t\"did not expect to find carol in the channel graph, but did\")\n\n\t// Now that the test is done, we can also close the persistent link.\n\tht.CloseChannel(alice, persistentChanPoint)\n}\n\n// testRejectHTLC tests that a node can be created with the flag --rejecthtlc.\n// This means that the node will reject all forwarded HTLCs but can still\n// accept direct HTLCs as well as send HTLCs.",
      "length": 3388,
      "tokens": 459,
      "embedding": []
    },
    {
      "slug": "func testRejectHTLC(ht *lntest.HarnessTest) {",
      "content": "func testRejectHTLC(ht *lntest.HarnessTest) {\n\t//             RejectHTLC\n\t// Alice ------> Carol ------> Bob\n\t//\n\tconst chanAmt = btcutil.Amount(1000000)\n\talice, bob := ht.Alice, ht.Bob\n\n\t// Create Carol with reject htlc flag.\n\tcarol := ht.NewNode(\"Carol\", []string{\"--rejecthtlc\"})\n\n\t// Connect Alice to Carol.\n\tht.ConnectNodes(alice, carol)\n\n\t// Connect Carol to Bob.\n\tht.ConnectNodes(carol, bob)\n\n\t// Send coins to Carol.\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, carol)\n\n\t// Open a channel between Alice and Carol.\n\tchanPointAlice := ht.OpenChannel(\n\t\talice, carol, lntest.OpenChannelParams{\n\t\t\tAmt: chanAmt,\n\t\t},\n\t)\n\n\t// Open a channel between Carol and Bob.\n\tchanPointCarol := ht.OpenChannel(\n\t\tcarol, bob, lntest.OpenChannelParams{\n\t\t\tAmt: chanAmt,\n\t\t},\n\t)\n\n\t// Channel should be ready for payments.\n\tconst payAmt = 100\n\n\t// Create an invoice from Carol of 100 satoshis.\n\t// We expect Alice to be able to pay this invoice.\n\tcarolInvoice := &lnrpc.Invoice{\n\t\tMemo:      \"testing - alice should pay carol\",\n\t\tRPreimage: ht.Random32Bytes(),\n\t\tValue:     payAmt,\n\t}\n\n\t// Carol adds the invoice to her database.\n\tresp := carol.RPC.AddInvoice(carolInvoice)\n\n\t// Alice pays Carols invoice.\n\tht.CompletePaymentRequests(alice, []string{resp.PaymentRequest})\n\n\t// Create an invoice from Bob of 100 satoshis.\n\t// We expect Carol to be able to pay this invoice.\n\tbobInvoice := &lnrpc.Invoice{\n\t\tMemo:      \"testing - carol should pay bob\",\n\t\tRPreimage: ht.Random32Bytes(),\n\t\tValue:     payAmt,\n\t}\n\n\t// Bob adds the invoice to his database.\n\tresp = bob.RPC.AddInvoice(bobInvoice)\n\n\t// Carol pays Bobs invoice.\n\tht.CompletePaymentRequests(carol, []string{resp.PaymentRequest})\n\n\t// Create an invoice from Bob of 100 satoshis.\n\t// Alice attempts to pay Bob but this should fail, since we are\n\t// using Carol as a hop and her node will reject onward HTLCs.\n\tbobInvoice = &lnrpc.Invoice{\n\t\tMemo:      \"testing - alice tries to pay bob\",\n\t\tRPreimage: ht.Random32Bytes(),\n\t\tValue:     payAmt,\n\t}\n\n\t// Bob adds the invoice to his database.\n\tresp = bob.RPC.AddInvoice(bobInvoice)\n\n\t// Alice attempts to pay Bobs invoice. This payment should be rejected\n\t// since we are using Carol as an intermediary hop, Carol is running\n\t// lnd with --rejecthtlc.\n\tpaymentReq := &routerrpc.SendPaymentRequest{\n\t\tPaymentRequest: resp.PaymentRequest,\n\t\tTimeoutSeconds: 60,\n\t\tFeeLimitMsat:   noFeeLimitMsat,\n\t}\n\tpayStream := alice.RPC.SendPayment(paymentReq)\n\tht.AssertPaymentStatusFromStream(payStream, lnrpc.Payment_FAILED)\n\n\tht.AssertLastHTLCError(alice, lnrpc.Failure_CHANNEL_DISABLED)\n\n\t// Close all channels.\n\tht.CloseChannel(alice, chanPointAlice)\n\tht.CloseChannel(carol, chanPointCarol)\n}\n\n// testNodeSignVerify checks that only connected nodes are allowed to perform\n// signing and verifying messages.",
      "length": 2638,
      "tokens": 336,
      "embedding": []
    },
    {
      "slug": "func testNodeSignVerify(ht *lntest.HarnessTest) {",
      "content": "func testNodeSignVerify(ht *lntest.HarnessTest) {\n\tchanAmt := funding.MaxBtcFundingAmount\n\tpushAmt := btcutil.Amount(100000)\n\talice, bob := ht.Alice, ht.Bob\n\n\t// Create a channel between alice and bob.\n\taliceBobCh := ht.OpenChannel(\n\t\talice, bob, lntest.OpenChannelParams{\n\t\t\tAmt:     chanAmt,\n\t\t\tPushAmt: pushAmt,\n\t\t},\n\t)\n\n\t// alice signs \"alice msg\" and sends her signature to bob.\n\taliceMsg := []byte(\"alice msg\")\n\tsigResp := alice.RPC.SignMessage(aliceMsg)\n\taliceSig := sigResp.Signature\n\n\t// bob verifying alice's signature should succeed since alice and bob\n\t// are connected.\n\tverifyResp := bob.RPC.VerifyMessage(aliceMsg, aliceSig)\n\trequire.True(ht, verifyResp.Valid, \"alice's signature didn't validate\")\n\trequire.Equal(ht, verifyResp.Pubkey, alice.PubKeyStr,\n\t\t\"alice's signature doesn't contain alice's pubkey.\")\n\n\t// carol is a new node that is unconnected to alice or bob.\n\tcarol := ht.NewNode(\"Carol\", nil)\n\n\t// carol signs \"carol msg\" and sends her signature to bob.\n\tcarolMsg := []byte(\"carol msg\")\n\tsigResp = carol.RPC.SignMessage(carolMsg)\n\tcarolSig := sigResp.Signature\n\n\t// bob verifying carol's signature should fail since they are not\n\t// connected.\n\tverifyResp = bob.RPC.VerifyMessage(carolMsg, carolSig)\n\trequire.False(ht, verifyResp.Valid, \"carol's signature didn't validate\")\n\trequire.Equal(ht, verifyResp.Pubkey, carol.PubKeyStr,\n\t\t\"carol's signature doesn't contain alice's pubkey.\")\n\n\t// Close the channel between alice and bob.\n\tht.CloseChannel(alice, aliceBobCh)\n}\n\n// testAbandonChannel abandons a channel and asserts that it is no longer open\n// and not in one of the pending closure states. It also verifies that the\n// abandoned channel is reported as closed with close type 'abandoned'.",
      "length": 1626,
      "tokens": 205,
      "embedding": []
    },
    {
      "slug": "func testAbandonChannel(ht *lntest.HarnessTest) {",
      "content": "func testAbandonChannel(ht *lntest.HarnessTest) {\n\talice, bob := ht.Alice, ht.Bob\n\n\t// First establish a channel between Alice and Bob.\n\tchannelParam := lntest.OpenChannelParams{\n\t\tAmt:     funding.MaxBtcFundingAmount,\n\t\tPushAmt: btcutil.Amount(100000),\n\t}\n\tchanPoint := ht.OpenChannel(alice, bob, channelParam)\n\n\t// Now that the channel is open, we'll obtain its channel ID real quick\n\t// so we can use it to query the graph below.\n\tchanID := ht.QueryChannelByChanPoint(alice, chanPoint).ChanId\n\n\t// To make sure the channel is removed from the backup file as well\n\t// when being abandoned, grab a backup snapshot so we can compare it\n\t// with the later state.\n\tbkupBefore, err := ioutil.ReadFile(alice.Cfg.ChanBackupPath())\n\trequire.NoError(ht, err, \"channel backup before abandoning channel\")\n\n\t// Send request to abandon channel.\n\tabandonChannelRequest := &lnrpc.AbandonChannelRequest{\n\t\tChannelPoint: chanPoint,\n\t}\n\talice.RPC.AbandonChannel(abandonChannelRequest)\n\n\t// Assert that channel in no longer open.\n\tht.AssertNodeNumChannels(alice, 0)\n\n\t// Assert that channel is not pending closure.\n\tht.AssertNumWaitingClose(alice, 0)\n\n\t// Assert that channel is listed as abandoned.\n\treq := &lnrpc.ClosedChannelsRequest{Abandoned: true}\n\taliceClosedList := alice.RPC.ClosedChannels(req)\n\trequire.Len(ht, aliceClosedList.Channels, 1, \"alice closed channels\")\n\n\t// Ensure that the channel can no longer be found in the channel graph.\n\tht.AssertZombieChannel(alice, chanID)\n\n\t// Make sure the channel is no longer in the channel backup list.\n\terr = wait.NoError(func() error {\n\t\tbkupAfter, err := ioutil.ReadFile(alice.Cfg.ChanBackupPath())\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"could not get channel backup \"+\n\t\t\t\t\"before abandoning channel: %v\", err)\n\t\t}\n\n\t\tif len(bkupAfter) >= len(bkupBefore) {\n\t\t\treturn fmt.Errorf(\"expected backups after to be less \"+\n\t\t\t\t\"than %d but was %d\", bkupBefore, bkupAfter)\n\t\t}\n\n\t\treturn nil\n\t}, defaultTimeout)\n\trequire.NoError(ht, err, \"channel removed from backup file\")\n\n\t// Calling AbandonChannel again, should result in no new errors, as the\n\t// channel has already been removed.\n\talice.RPC.AbandonChannel(abandonChannelRequest)\n\n\t// Now that we're done with the test, the channel can be closed. This\n\t// is necessary to avoid unexpected outcomes of other tests that use\n\t// Bob's lnd instance.\n\tht.ForceCloseChannel(bob, chanPoint)\n}\n\n// testSweepAllCoins tests that we're able to properly sweep all coins from the\n// wallet into a single target address at the specified fee rate.\n//\n// TODO(yy): expand this test to also use P2TR.",
      "length": 2451,
      "tokens": 328,
      "embedding": []
    },
    {
      "slug": "func testSweepAllCoins(ht *lntest.HarnessTest) {",
      "content": "func testSweepAllCoins(ht *lntest.HarnessTest) {\n\t// First, we'll make a new node, ainz who'll we'll use to test wallet\n\t// sweeping.\n\t//\n\t// NOTE: we won't use standby nodes here since the test will change\n\t// each of the node's wallet state.\n\tainz := ht.NewNode(\"Ainz\", nil)\n\n\t// Next, we'll give Ainz exactly 2 utxos of 1 BTC each, with one of\n\t// them being p2wkh and the other being a n2wpkh address.\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, ainz)\n\tht.FundCoinsNP2WKH(btcutil.SatoshiPerBitcoin, ainz)\n\n\t// Ensure that we can't send coins to our own Pubkey.\n\tinfo := ainz.RPC.GetInfo()\n\n\t// Create a label that we will used to label the transaction with.\n\tsendCoinsLabel := \"send all coins\"\n\n\tsweepReq := &lnrpc.SendCoinsRequest{\n\t\tAddr:    info.IdentityPubkey,\n\t\tSendAll: true,\n\t\tLabel:   sendCoinsLabel,\n\t}\n\tainz.RPC.SendCoinsAssertErr(sweepReq)\n\n\t// Ensure that we can't send coins to another user's Pubkey.\n\tinfo = ht.Alice.RPC.GetInfo()\n\n\tsweepReq = &lnrpc.SendCoinsRequest{\n\t\tAddr:    info.IdentityPubkey,\n\t\tSendAll: true,\n\t\tLabel:   sendCoinsLabel,\n\t}\n\tainz.RPC.SendCoinsAssertErr(sweepReq)\n\n\t// With the two coins above mined, we'll now instruct ainz to sweep all\n\t// the coins to an external address not under its control.  We will\n\t// first attempt to send the coins to addresses that are not compatible\n\t// with the current network. This is to test that the wallet will\n\t// prevent any onchain transactions to addresses that are not on the\n\t// same network as the user.\n\n\t// Send coins to a testnet3 address.\n\tsweepReq = &lnrpc.SendCoinsRequest{\n\t\tAddr:    \"tb1qfc8fusa98jx8uvnhzavxccqlzvg749tvjw82tg\",\n\t\tSendAll: true,\n\t\tLabel:   sendCoinsLabel,\n\t}\n\tainz.RPC.SendCoinsAssertErr(sweepReq)\n\n\t// Send coins to a mainnet address.\n\tsweepReq = &lnrpc.SendCoinsRequest{\n\t\tAddr:    \"1MPaXKp5HhsLNjVSqaL7fChE3TVyrTMRT3\",\n\t\tSendAll: true,\n\t\tLabel:   sendCoinsLabel,\n\t}\n\tainz.RPC.SendCoinsAssertErr(sweepReq)\n\n\t// Send coins to a compatible address.\n\tminerAddr := ht.Miner.NewMinerAddress()\n\tsweepReq = &lnrpc.SendCoinsRequest{\n\t\tAddr:    minerAddr.String(),\n\t\tSendAll: true,\n\t\tLabel:   sendCoinsLabel,\n\t}\n\tainz.RPC.SendCoins(sweepReq)\n\n\t// We'll mine a block which should include the sweep transaction we\n\t// generated above.\n\tblock := ht.MineBlocksAndAssertNumTxes(1, 1)[0]\n\n\t// The sweep transaction should have exactly two inputs as we only had\n\t// two UTXOs in the wallet.\n\tsweepTx := block.Transactions[1]\n\trequire.Len(ht, sweepTx.TxIn, 2, \"expected 2 inputs\")\n\n\t// assertTxLabel is a helper function which finds a target tx in our\n\t// set of transactions and checks that it has the desired label.\n\tassertTxLabel := func(targetTx, label string) error {\n\t\t// List all transactions relevant to our wallet, and find the\n\t\t// tx so that we can check the correct label has been set.\n\t\ttxResp := ainz.RPC.GetTransactions(nil)\n\n\t\tvar target *lnrpc.Transaction\n\n\t\t// First we need to find the target tx.\n\t\tfor _, txn := range txResp.Transactions {\n\t\t\tif txn.TxHash == targetTx {\n\t\t\t\ttarget = txn\n\t\t\t}\n\t\t}\n\n\t\t// If we cannot find it, return an error.\n\t\tif target == nil {\n\t\t\treturn fmt.Errorf(\"target tx %v not found\", targetTx)\n\t\t}\n\n\t\t// Otherwise, check the labels are matched.\n\t\tif target.Label == label {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn fmt.Errorf(\"labels not match, want: \"+\n\t\t\t\"%v, got %v\", label, target.Label)\n\t}\n\n\t// waitTxLabel waits until the desired tx label is found or timeout.\n\twaitTxLabel := func(targetTx, label string) {\n\t\terr := wait.NoError(func() error {\n\t\t\treturn assertTxLabel(targetTx, label)\n\t\t}, defaultTimeout)\n\n\t\trequire.NoError(ht, err, \"timeout assertTxLabel\")\n\t}\n\n\tsweepTxStr := sweepTx.TxHash().String()\n\twaitTxLabel(sweepTxStr, sendCoinsLabel)\n\n\t// While we are looking at labels, we test our label transaction\n\t// command to make sure it is behaving as expected. First, we try to\n\t// label our transaction with an empty label, and check that we fail as\n\t// expected.\n\tsweepHash := sweepTx.TxHash()\n\treq := &walletrpc.LabelTransactionRequest{\n\t\tTxid:      sweepHash[:],\n\t\tLabel:     \"\",\n\t\tOverwrite: false,\n\t}\n\terr := ainz.RPC.LabelTransactionAssertErr(req)\n\n\t// Our error will be wrapped in a rpc error, so we check that it\n\t// contains the error we expect.\n\terrZeroLabel := \"cannot label transaction with empty label\"\n\trequire.Contains(ht, err.Error(), errZeroLabel,\n\t\t\"expected: zero label errorv\")\n\n\t// Next, we try to relabel our transaction without setting the overwrite\n\t// boolean. We expect this to fail, because the wallet requires setting\n\t// of this param to prevent accidental overwrite of labels.\n\treq = &walletrpc.LabelTransactionRequest{\n\t\tTxid:      sweepHash[:],\n\t\tLabel:     \"label that will not work\",\n\t\tOverwrite: false,\n\t}\n\terr = ainz.RPC.LabelTransactionAssertErr(req)\n\n\t// Our error will be wrapped in a rpc error, so we check that it\n\t// contains the error we expect.\n\trequire.Contains(ht, err.Error(), wallet.ErrTxLabelExists.Error())\n\n\t// Finally, we overwrite our label with a new label, which should not\n\t// fail.\n\tnewLabel := \"new sweep tx label\"\n\treq = &walletrpc.LabelTransactionRequest{\n\t\tTxid:      sweepHash[:],\n\t\tLabel:     newLabel,\n\t\tOverwrite: true,\n\t}\n\tainz.RPC.LabelTransaction(req)\n\n\twaitTxLabel(sweepTxStr, newLabel)\n\n\t// Finally, Ainz should now have no coins at all within his wallet.\n\tresp := ainz.RPC.WalletBalance()\n\trequire.Zero(ht, resp.ConfirmedBalance, \"wrong confirmed balance\")\n\trequire.Zero(ht, resp.UnconfirmedBalance, \"wrong unconfirmed balance\")\n\n\t// If we try again, but this time specifying an amount, then the call\n\t// should fail.\n\tsweepReq.Amount = 10000\n\tainz.RPC.SendCoinsAssertErr(sweepReq)\n}\n\n// testListAddresses tests that we get all the addresses and their\n// corresponding balance correctly.",
      "length": 5470,
      "tokens": 755,
      "embedding": []
    },
    {
      "slug": "func testListAddresses(ht *lntest.HarnessTest) {",
      "content": "func testListAddresses(ht *lntest.HarnessTest) {\n\t// First, we'll make a new node - Alice, which will be generating\n\t// new addresses.\n\talice := ht.NewNode(\"Alice\", nil)\n\n\t// Next, we'll give Alice exactly 1 utxo of 1 BTC.\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, alice)\n\n\ttype addressDetails struct {\n\t\tBalance int64\n\t\tType    walletrpc.AddressType\n\t}\n\n\t// A map of generated address and its balance.\n\tgeneratedAddr := make(map[string]addressDetails)\n\n\t// Create an address generated from internal keys.\n\tkeyLoc := &walletrpc.KeyReq{KeyFamily: 123}\n\tkeyDesc := alice.RPC.DeriveNextKey(keyLoc)\n\n\t// Hex Encode the public key.\n\tpubkeyString := hex.EncodeToString(keyDesc.RawKeyBytes)\n\n\t// Create a p2tr address.\n\tresp := alice.RPC.NewAddress(&lnrpc.NewAddressRequest{\n\t\tType: lnrpc.AddressType_TAPROOT_PUBKEY,\n\t})\n\tgeneratedAddr[resp.Address] = addressDetails{\n\t\tBalance: 200_000,\n\t\tType:    walletrpc.AddressType_TAPROOT_PUBKEY,\n\t}\n\n\t// Create a p2wkh address.\n\tresp = alice.RPC.NewAddress(&lnrpc.NewAddressRequest{\n\t\tType: lnrpc.AddressType_WITNESS_PUBKEY_HASH,\n\t})\n\tgeneratedAddr[resp.Address] = addressDetails{\n\t\tBalance: 300_000,\n\t\tType:    walletrpc.AddressType_WITNESS_PUBKEY_HASH,\n\t}\n\n\t// Create a np2wkh address.\n\tresp = alice.RPC.NewAddress(&lnrpc.NewAddressRequest{\n\t\tType: lnrpc.AddressType_NESTED_PUBKEY_HASH,\n\t})\n\tgeneratedAddr[resp.Address] = addressDetails{\n\t\tBalance: 400_000,\n\t\tType: walletrpc.\n\t\t\tAddressType_HYBRID_NESTED_WITNESS_PUBKEY_HASH,\n\t}\n\n\tfor addr, addressDetail := range generatedAddr {\n\t\talice.RPC.SendCoins(&lnrpc.SendCoinsRequest{\n\t\t\tAddr:             addr,\n\t\t\tAmount:           addressDetail.Balance,\n\t\t\tSpendUnconfirmed: true,\n\t\t})\n\t}\n\n\tht.MineBlocksAndAssertNumTxes(1, 3)\n\n\t// Get all the accounts except LND's custom accounts.\n\taddressLists := alice.RPC.ListAddresses(\n\t\t&walletrpc.ListAddressesRequest{},\n\t)\n\n\tfoundAddresses := 0\n\tfor _, addressList := range addressLists.AccountWithAddresses {\n\t\taddresses := addressList.Addresses\n\t\tderivationPath, err := lntest.ParseDerivationPath(\n\t\t\taddressList.DerivationPath,\n\t\t)\n\t\trequire.NoError(ht, err)\n\n\t\t// Should not get an account with KeyFamily - 123.\n\t\trequire.NotEqual(\n\t\t\tht, uint32(keyLoc.KeyFamily), derivationPath[2],\n\t\t)\n\n\t\tfor _, address := range addresses {\n\t\t\tif _, ok := generatedAddr[address.Address]; ok {\n\t\t\t\taddrDetails := generatedAddr[address.Address]\n\t\t\t\trequire.Equal(\n\t\t\t\t\tht, addrDetails.Balance,\n\t\t\t\t\taddress.Balance,\n\t\t\t\t)\n\t\t\t\trequire.Equal(\n\t\t\t\t\tht, addrDetails.Type,\n\t\t\t\t\taddressList.AddressType,\n\t\t\t\t)\n\t\t\t\tfoundAddresses++\n\t\t\t}\n\t\t}\n\t}\n\n\trequire.Equal(ht, len(generatedAddr), foundAddresses)\n\tfoundAddresses = 0\n\n\t// Get all the accounts (including LND's custom accounts).\n\taddressLists = alice.RPC.ListAddresses(\n\t\t&walletrpc.ListAddressesRequest{\n\t\t\tShowCustomAccounts: true,\n\t\t},\n\t)\n\n\tfor _, addressList := range addressLists.AccountWithAddresses {\n\t\taddresses := addressList.Addresses\n\t\tderivationPath, err := lntest.ParseDerivationPath(\n\t\t\taddressList.DerivationPath,\n\t\t)\n\t\trequire.NoError(ht, err)\n\n\t\tfor _, address := range addresses {\n\t\t\t// Check if the KeyFamily in derivation path is 123.\n\t\t\tif uint32(keyLoc.KeyFamily) == derivationPath[2] {\n\t\t\t\t// For LND's custom accounts, the address\n\t\t\t\t// represents the public key.\n\t\t\t\tpubkey := address.Address\n\t\t\t\trequire.Equal(ht, pubkeyString, pubkey)\n\t\t\t} else if _, ok := generatedAddr[address.Address]; ok {\n\t\t\t\taddrDetails := generatedAddr[address.Address]\n\t\t\t\trequire.Equal(\n\t\t\t\t\tht, addrDetails.Balance,\n\t\t\t\t\taddress.Balance,\n\t\t\t\t)\n\t\t\t\trequire.Equal(\n\t\t\t\t\tht, addrDetails.Type,\n\t\t\t\t\taddressList.AddressType,\n\t\t\t\t)\n\t\t\t\tfoundAddresses++\n\t\t\t}\n\t\t}\n\t}\n\n\trequire.Equal(ht, len(generatedAddr), foundAddresses)\n}\n",
      "length": 3493,
      "tokens": 346,
      "embedding": []
    },
    {
      "slug": "func assertChannelConstraintsEqual(ht *lntest.HarnessTest,",
      "content": "func assertChannelConstraintsEqual(ht *lntest.HarnessTest,\n\twant, got *lnrpc.ChannelConstraints) {\n\n\trequire.Equal(ht, want.CsvDelay, got.CsvDelay, \"CsvDelay mismatched\")\n\n\trequire.Equal(ht, want.ChanReserveSat, got.ChanReserveSat,\n\t\t\"ChanReserveSat mismatched\")\n\n\trequire.Equal(ht, want.DustLimitSat, got.DustLimitSat,\n\t\t\"DustLimitSat mismatched\")\n\n\trequire.Equal(ht, want.MaxPendingAmtMsat, got.MaxPendingAmtMsat,\n\t\t\"MaxPendingAmtMsat mismatched\")\n\n\trequire.Equal(ht, want.MinHtlcMsat, got.MinHtlcMsat,\n\t\t\"MinHtlcMsat mismatched\")\n\n\trequire.Equal(ht, want.MaxAcceptedHtlcs, got.MaxAcceptedHtlcs,\n\t\t\"MaxAcceptedHtlcs mismatched\")\n}\n\n// testSignVerifyMessageWithAddr tests signing and also verifying a signature\n// on a message with a provided address.",
      "length": 672,
      "tokens": 52,
      "embedding": []
    },
    {
      "slug": "func testSignVerifyMessageWithAddr(ht *lntest.HarnessTest) {",
      "content": "func testSignVerifyMessageWithAddr(ht *lntest.HarnessTest) {\n\t// Using different nodes to sign the message and verify the signature.\n\talice, bob := ht.Alice, ht.Bob\n\n\t// Test an lnd wallet created P2WKH address.\n\trespAddr := alice.RPC.NewAddress(&lnrpc.NewAddressRequest{\n\t\tType: lnrpc.AddressType_WITNESS_PUBKEY_HASH,\n\t})\n\n\taliceMsg := []byte(\"alice msg\")\n\n\trespSig := alice.RPC.SignMessageWithAddr(\n\t\t&walletrpc.SignMessageWithAddrRequest{\n\t\t\tMsg:  aliceMsg,\n\t\t\tAddr: respAddr.Address,\n\t\t},\n\t)\n\n\trespValid := bob.RPC.VerifyMessageWithAddr(\n\t\t&walletrpc.VerifyMessageWithAddrRequest{\n\t\t\tMsg:       aliceMsg,\n\t\t\tSignature: respSig.Signature,\n\t\t\tAddr:      respAddr.Address,\n\t\t},\n\t)\n\n\trequire.True(ht, respValid.Valid, \"alice's signature didn't validate\")\n\n\t// Test an lnd wallet created NP2WKH address.\n\trespAddr = alice.RPC.NewAddress(&lnrpc.NewAddressRequest{\n\t\tType: lnrpc.AddressType_NESTED_PUBKEY_HASH,\n\t})\n\n\trespSig = alice.RPC.SignMessageWithAddr(\n\t\t&walletrpc.SignMessageWithAddrRequest{\n\t\t\tMsg:  aliceMsg,\n\t\t\tAddr: respAddr.Address,\n\t\t},\n\t)\n\n\trespValid = bob.RPC.VerifyMessageWithAddr(\n\t\t&walletrpc.VerifyMessageWithAddrRequest{\n\t\t\tMsg:       aliceMsg,\n\t\t\tSignature: respSig.Signature,\n\t\t\tAddr:      respAddr.Address,\n\t\t},\n\t)\n\n\trequire.True(ht, respValid.Valid, \"alice's signature didn't validate\")\n\n\t// Test an lnd wallet created P2TR address.\n\trespAddr = alice.RPC.NewAddress(&lnrpc.NewAddressRequest{\n\t\tType: lnrpc.AddressType_TAPROOT_PUBKEY,\n\t})\n\n\trespSig = alice.RPC.SignMessageWithAddr(\n\t\t&walletrpc.SignMessageWithAddrRequest{\n\t\t\tMsg:  aliceMsg,\n\t\t\tAddr: respAddr.Address,\n\t\t},\n\t)\n\n\trespValid = bob.RPC.VerifyMessageWithAddr(\n\t\t&walletrpc.VerifyMessageWithAddrRequest{\n\t\t\tMsg:       aliceMsg,\n\t\t\tSignature: respSig.Signature,\n\t\t\tAddr:      respAddr.Address,\n\t\t},\n\t)\n\n\trequire.True(ht, respValid.Valid, \"alice's signature didn't validate\")\n\n\t// Test verifying a signature with an external P2PKH address.\n\t// P2PKH address type is not supported by the lnd wallet therefore\n\t// using an external source (bitcoin-core) for address and\n\t// signature creation.\n\texternalMsg := []byte(\"external msg\")\n\texternalAddr := \"msS5c4VihSiJ64QzvMMEmWh6rYBnuWo2xH\"\n\n\t// Base64 encoded signature created with bitcoin-core regtest.\n\texternalSig := \"H5DqqM7Cc8xZnYBr7j3gD4XD+AuQsim9Un/IxBrrhBA7I9//\" +\n\t\t\"3exuQRg+u7HpwG65yobPsew6RMUteyuxyNkLF5E=\"\n\n\trespValid = alice.RPC.VerifyMessageWithAddr(\n\t\t&walletrpc.VerifyMessageWithAddrRequest{\n\t\t\tMsg:       externalMsg,\n\t\t\tSignature: externalSig,\n\t\t\tAddr:      externalAddr,\n\t\t},\n\t)\n\n\trequire.True(ht, respValid.Valid, \"external signature didn't validate\")\n\n\t// Test verifying a signature with a different address which\n\t// initially was used to create the following signature.\n\t// externalAddr is a valid legacy P2PKH bitcoin address created\n\t// with bitcoin-core.\n\texternalAddr = \"mugbg8CqFe9CbdrYjFTkMhmL3JxuEXkNbY\"\n\n\t// Base64 encoded signature created with bitcoin-core regtest but with\n\t// the address msS5c4VihSiJ64QzvMMEmWh6rYBnuWo2xH.\n\texternalSig = \"H5DqqM7Cc8xZnYBr7j3gD4XD+AuQsim9Un/IxBrrhBA7I9//\" +\n\t\t\"3exuQRg+u7HpwG65yobPsew6RMUteyuxyNkLF5E=\"\n\n\trespValid = alice.RPC.VerifyMessageWithAddr(\n\t\t&walletrpc.VerifyMessageWithAddrRequest{\n\t\t\tMsg:       externalMsg,\n\t\t\tSignature: externalSig,\n\t\t\tAddr:      externalAddr,\n\t\t},\n\t)\n\n\trequire.False(ht, respValid.Valid, \"external signature did validate\")\n}\n",
      "length": 3177,
      "tokens": 292,
      "embedding": []
    }
  ]
}