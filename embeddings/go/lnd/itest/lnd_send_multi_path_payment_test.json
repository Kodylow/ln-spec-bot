{
  "filepath": "../implementations/go/lnd/itest/lnd_send_multi_path_payment_test.go",
  "package": "itest",
  "sections": [
    {
      "slug": "func testSendMultiPathPayment(ht *lntest.HarnessTest) {",
      "content": "func testSendMultiPathPayment(ht *lntest.HarnessTest) {\n\tmts := newMppTestScenario(ht)\n\n\tconst paymentAmt = btcutil.Amount(300000)\n\n\t// Set up a network with three different paths Alice <-> Bob. Channel\n\t// capacities are set such that the payment can only succeed if (at\n\t// least) three paths are used.\n\t//\n\t//              _ Eve _\n\t//             /       \\\n\t// Alice -- Carol ---- Bob\n\t//      \\              /\n\t//       \\__ Dave ____/\n\t//\n\treq := &mppOpenChannelRequest{\n\t\tamtAliceCarol: 235000,\n\t\tamtAliceDave:  135000,\n\t\tamtCarolBob:   135000,\n\t\tamtCarolEve:   135000,\n\t\tamtDaveBob:    135000,\n\t\tamtEveBob:     135000,\n\t}\n\tmts.openChannels(req)\n\tchanPointAliceDave := mts.channelPoints[1]\n\n\t// Increase Dave's fee to make the test deterministic. Otherwise it\n\t// would be unpredictable whether pathfinding would go through Charlie\n\t// or Dave for the first shard.\n\texpectedPolicy := mts.updateDaveGlobalPolicy()\n\n\t// Make sure Alice has heard it.\n\tht.AssertChannelPolicyUpdate(\n\t\tmts.alice, mts.dave, expectedPolicy, chanPointAliceDave, false,\n\t)\n\n\t// Our first test will be Alice paying Bob using a SendPayment call.\n\t// Let Bob create an invoice for Alice to pay.\n\tpayReqs, rHashes, invoices := ht.CreatePayReqs(mts.bob, paymentAmt, 1)\n\n\trHash := rHashes[0]\n\tpayReq := payReqs[0]\n\n\tsendReq := &routerrpc.SendPaymentRequest{\n\t\tPaymentRequest: payReq,\n\t\tMaxParts:       10,\n\t\tTimeoutSeconds: 60,\n\t\tFeeLimitMsat:   noFeeLimitMsat,\n\t}\n\tpayment := ht.SendPaymentAssertSettled(mts.alice, sendReq)\n\n\t// Make sure we got the preimage.\n\trequire.Equal(ht, hex.EncodeToString(invoices[0].RPreimage),\n\t\tpayment.PaymentPreimage, \"preimage doesn't match\")\n\n\t// Check that Alice split the payment in at least three shards. Because\n\t// the hand-off of the htlc to the link is asynchronous (via a mailbox),\n\t// there is some non-determinism in the process. Depending on whether\n\t// the new pathfinding round is started before or after the htlc is\n\t// locked into the channel, different sharding may occur. Therefore we\n\t// can only check if the number of shards isn't below the theoretical\n\t// minimum.\n\tsucceeded := 0\n\tfor _, htlc := range payment.Htlcs {\n\t\tif htlc.Status == lnrpc.HTLCAttempt_SUCCEEDED {\n\t\t\tsucceeded++\n\t\t}\n\t}\n\n\tconst minExpectedShards = 3\n\trequire.GreaterOrEqual(ht, succeeded, minExpectedShards,\n\t\t\"expected shards not reached\")\n\n\t// Make sure Bob show the invoice as settled for the full amount.\n\tinv := mts.bob.RPC.LookupInvoice(rHash)\n\n\trequire.EqualValues(ht, paymentAmt, inv.AmtPaidSat,\n\t\t\"incorrect payment amt\")\n\n\trequire.Equal(ht, lnrpc.Invoice_SETTLED, inv.State,\n\t\t\"Invoice not settled\")\n\n\tsettled := 0\n\tfor _, htlc := range inv.Htlcs {\n\t\tif htlc.State == lnrpc.InvoiceHTLCState_SETTLED {\n\t\t\tsettled++\n\t\t}\n\t}\n\trequire.Equal(ht, succeeded, settled,\n\t\t\"num of HTLCs wrong\")\n\n\t// Finally, close all channels.\n\tmts.closeChannels()\n}\n",
      "length": 2702,
      "tokens": 357,
      "embedding": []
    }
  ]
}