{
  "filepath": "../implementations/go/lnd/itest/lnd_recovery_test.go",
  "package": "itest",
  "sections": [
    {
      "slug": "func testGetRecoveryInfo(ht *lntest.HarnessTest) {",
      "content": "func testGetRecoveryInfo(ht *lntest.HarnessTest) {\n\t// First, create a new node with strong passphrase and grab the mnemonic\n\t// used for key derivation. This will bring up Carol with an empty\n\t// wallet, and such that she is synced up.\n\tpassword := []byte(\"The Magic Words are Squeamish Ossifrage\")\n\tcarol, mnemonic, _ := ht.NewNodeWithSeed(\"Carol\", nil, password, false)\n\n\tcheckInfo := func(expectedRecoveryMode, expectedRecoveryFinished bool,\n\t\texpectedProgress float64, recoveryWindow int32) {\n\n\t\t// Restore Carol, passing in the password, mnemonic, and\n\t\t// desired recovery window.\n\t\tnode := ht.RestoreNodeWithSeed(\n\t\t\tcarol.Name(), nil, password, mnemonic, \"\",\n\t\t\trecoveryWindow, nil,\n\t\t)\n\n\t\t// Query carol for her current wallet recovery progress.\n\t\terr := wait.NoError(func() error {\n\t\t\t// Verify that recovery info gives the right response.\n\t\t\tresp := node.RPC.GetRecoveryInfo(nil)\n\n\t\t\tmode := resp.RecoveryMode\n\t\t\tfinished := resp.RecoveryFinished\n\t\t\tprogress := resp.Progress\n\n\t\t\tif mode != expectedRecoveryMode {\n\t\t\t\treturn fmt.Errorf(\"expected recovery mode %v \"+\n\t\t\t\t\t\"got %v\", expectedRecoveryMode, mode)\n\t\t\t}\n\t\t\tif finished != expectedRecoveryFinished {\n\t\t\t\treturn fmt.Errorf(\"expected finished %v \"+\n\t\t\t\t\t\"got %v\", expectedRecoveryFinished,\n\t\t\t\t\tfinished)\n\t\t\t}\n\t\t\tif progress != expectedProgress {\n\t\t\t\treturn fmt.Errorf(\"expected progress %v\"+\n\t\t\t\t\t\"got %v\", expectedProgress, progress)\n\t\t\t}\n\n\t\t\treturn nil\n\t\t}, defaultTimeout)\n\t\trequire.NoError(ht, err)\n\n\t\t// Lastly, shutdown this Carol so we can move on to the next\n\t\t// restoration.\n\t\tht.Shutdown(node)\n\t}\n\n\t// Restore Carol with a recovery window of 0. Since it's not in recovery\n\t// mode, the recovery info will give a response with recoveryMode=false,\n\t// recoveryFinished=false, and progress=0\n\tcheckInfo(false, false, 0, 0)\n\n\t// Change the recovery windown to be 1 to turn on recovery mode. Since\n\t// the current chain height is the same as the birthday height, it\n\t// should indicate the recovery process is finished.\n\tcheckInfo(true, true, 1, 1)\n\n\t// We now go ahead 5 blocks. Because the wallet's syncing process is\n\t// controlled by a goroutine in the background, it will catch up\n\t// quickly. This makes the recovery progress back to 1.\n\tht.MineBlocks(5)\n\tcheckInfo(true, true, 1, 1)\n}\n\n// testOnchainFundRecovery checks lnd's ability to rescan for onchain outputs\n// when providing a valid aezeed that owns outputs on the chain. This test\n// performs multiple restorations using the same seed and various recovery\n// windows to ensure we detect funds properly.",
      "length": 2424,
      "tokens": 344,
      "embedding": []
    },
    {
      "slug": "func testOnchainFundRecovery(ht *lntest.HarnessTest) {",
      "content": "func testOnchainFundRecovery(ht *lntest.HarnessTest) {\n\t// First, create a new node with strong passphrase and grab the mnemonic\n\t// used for key derivation. This will bring up Carol with an empty\n\t// wallet, and such that she is synced up.\n\tpassword := []byte(\"The Magic Words are Squeamish Ossifrage\")\n\tcarol, mnemonic, _ := ht.NewNodeWithSeed(\"Carol\", nil, password, false)\n\n\t// As long as the mnemonic is non-nil and the extended key is empty, the\n\t// closure below will always restore the node from the seed. The tests\n\t// need to manually overwrite this value to change that behavior.\n\trootKey := \"\"\n\n\t// Create a closure for testing the recovery of Carol's wallet. This\n\t// method takes the expected value of Carol's balance when using the\n\t// given recovery window. Additionally, the caller can specify an action\n\t// to perform on the restored node before the node is shutdown.\n\trestoreCheckBalance := func(expAmount int64, expectedNumUTXOs uint32,\n\t\trecoveryWindow int32, fn func(*node.HarnessNode)) {\n\n\t\tht.Helper()\n\n\t\t// Restore Carol, passing in the password, mnemonic, and\n\t\t// desired recovery window.\n\t\tnode := ht.RestoreNodeWithSeed(\n\t\t\tcarol.Name(), nil, password, mnemonic, rootKey,\n\t\t\trecoveryWindow, nil,\n\t\t)\n\n\t\t// Query carol for her current wallet balance, and also that we\n\t\t// gain the expected number of UTXOs.\n\t\tvar (\n\t\t\tcurrBalance  int64\n\t\t\tcurrNumUTXOs uint32\n\t\t)\n\t\terr := wait.NoError(func() error {\n\t\t\tresp := node.RPC.WalletBalance()\n\t\t\tcurrBalance = resp.ConfirmedBalance\n\n\t\t\treq := &walletrpc.ListUnspentRequest{\n\t\t\t\tAccount:  \"\",\n\t\t\t\tMaxConfs: math.MaxInt32,\n\t\t\t\tMinConfs: 0,\n\t\t\t}\n\t\t\tutxoResp := node.RPC.ListUnspent(req)\n\t\t\tcurrNumUTXOs = uint32(len(utxoResp.Utxos))\n\n\t\t\t// Verify that Carol's balance and number of UTXOs\n\t\t\t// matches what's expected.\n\t\t\tif expAmount != currBalance {\n\t\t\t\treturn fmt.Errorf(\"balance not matched, want \"+\n\t\t\t\t\t\"%d, got %d\", expAmount, currBalance)\n\t\t\t}\n\t\t\tif currNumUTXOs != expectedNumUTXOs {\n\t\t\t\treturn fmt.Errorf(\"num of UTXOs not matched, \"+\n\t\t\t\t\t\"want %d, got %d\", expectedNumUTXOs,\n\t\t\t\t\tcurrNumUTXOs)\n\t\t\t}\n\n\t\t\treturn nil\n\t\t}, defaultTimeout)\n\t\trequire.NoError(ht, err, \"timeout checking Carol\")\n\n\t\t// If the user provided a callback, execute the commands against\n\t\t// the restored Carol.\n\t\tif fn != nil {\n\t\t\tfn(node)\n\t\t}\n\n\t\t// Lastly, shutdown this Carol so we can move on to the next\n\t\t// restoration.\n\t\tht.Shutdown(node)\n\t}\n\n\t// Create a closure-factory for building closures that can generate and\n\t// skip a configurable number of addresses, before finally sending coins\n\t// to a next generated address. The returned closure will apply the same\n\t// behavior to both default P2WKH and NP2WKH scopes.\n\tskipAndSend := func(nskip int) func(*node.HarnessNode) {\n\t\treturn func(node *node.HarnessNode) {\n\t\t\tht.Helper()\n\n\t\t\t// Generate and skip the number of addresses requested.\n\t\t\tfor i := 0; i < nskip; i++ {\n\t\t\t\treq := &lnrpc.NewAddressRequest{}\n\n\t\t\t\treq.Type = AddrTypeWitnessPubkeyHash\n\t\t\t\tnode.RPC.NewAddress(req)\n\n\t\t\t\treq.Type = AddrTypeNestedPubkeyHash\n\t\t\t\tnode.RPC.NewAddress(req)\n\n\t\t\t\treq.Type = AddrTypeTaprootPubkey\n\t\t\t\tnode.RPC.NewAddress(req)\n\t\t\t}\n\n\t\t\t// Send one BTC to the next P2WKH address.\n\t\t\tht.FundCoins(btcutil.SatoshiPerBitcoin, node)\n\n\t\t\t// And another to the next NP2WKH address.\n\t\t\tht.FundCoinsNP2WKH(btcutil.SatoshiPerBitcoin, node)\n\n\t\t\t// Add another whole coin to the P2TR address.\n\t\t\tht.FundCoinsP2TR(btcutil.SatoshiPerBitcoin, node)\n\t\t}\n\t}\n\n\t// Restore Carol with a recovery window of 0. Since no coins have been\n\t// sent, her balance should be zero.\n\t//\n\t// After, one BTC is sent to both her first external P2WKH and NP2WKH\n\t// addresses.\n\trestoreCheckBalance(0, 0, 0, skipAndSend(0))\n\n\t// Check that restoring without a look-ahead results in having no funds\n\t// in the wallet, even though they exist on-chain.\n\trestoreCheckBalance(0, 0, 0, nil)\n\n\t// Now, check that using a look-ahead of 1 recovers the balance from\n\t// the two transactions above. We should also now have 2 UTXOs in the\n\t// wallet at the end of the recovery attempt.\n\t//\n\t// After, we will generate and skip 9 P2WKH, NP2WKH and P2TR addresses,\n\t// and send another BTC to the subsequent 10th address in each\n\t// derivation path.\n\trestoreCheckBalance(3*btcutil.SatoshiPerBitcoin, 3, 1, skipAndSend(9))\n\n\t// Check that using a recovery window of 9 does not find the two most\n\t// recent txns.\n\trestoreCheckBalance(3*btcutil.SatoshiPerBitcoin, 3, 9, nil)\n\n\t// Extending our recovery window to 10 should find the most recent\n\t// transactions, leaving the wallet with 6 BTC total. We should also\n\t// learn of the two additional UTXOs created above.\n\t//\n\t// After, we will skip 19 more addrs, sending to the 20th address past\n\t// our last found address, and repeat the same checks.\n\trestoreCheckBalance(6*btcutil.SatoshiPerBitcoin, 6, 10, skipAndSend(19))\n\n\t// Check that recovering with a recovery window of 19 fails to find the\n\t// most recent transactions.\n\trestoreCheckBalance(6*btcutil.SatoshiPerBitcoin, 6, 19, nil)\n\n\t// Ensure that using a recovery window of 20 succeeds with all UTXOs\n\t// found and the final balance reflected.\n\n\t// After these checks are done, we'll want to make sure we can also\n\t// recover change address outputs.  This is mainly motivated by a now\n\t// fixed bug in the wallet in which change addresses could at times be\n\t// created outside of the default key scopes. Recovery only used to be\n\t// performed on the default key scopes, so ideally this test case\n\t// would've caught the bug earlier. Carol has received 9 BTC so far from\n\t// the miner, we'll send 8 back to ensure all of her UTXOs get spent to\n\t// avoid fee discrepancies and a change output is formed.\n\tconst minerAmt = 8 * btcutil.SatoshiPerBitcoin\n\tconst finalBalance = 9 * btcutil.SatoshiPerBitcoin\n\tpromptChangeAddr := func(node *node.HarnessNode) {\n\t\tht.Helper()\n\n\t\tminerAddr := ht.Miner.NewMinerAddress()\n\t\treq := &lnrpc.SendCoinsRequest{\n\t\t\tAddr:   minerAddr.String(),\n\t\t\tAmount: minerAmt,\n\t\t}\n\t\tresp := node.RPC.SendCoins(req)\n\n\t\ttxid := ht.Miner.AssertNumTxsInMempool(1)[0]\n\t\trequire.Equal(ht, txid.String(), resp.Txid)\n\n\t\tblock := ht.MineBlocks(1)[0]\n\t\tht.Miner.AssertTxInBlock(block, txid)\n\t}\n\trestoreCheckBalance(finalBalance, 9, 20, promptChangeAddr)\n\n\t// We should expect a static fee of 36400 satoshis for spending 9\n\t// inputs (3 P2WPKH, 3 NP2WPKH, 3 P2TR) to two P2TR outputs. Carol\n\t// should therefore only have one UTXO present (the change output) of\n\t// 9 - 8 - fee BTC.\n\tconst fee = 37000\n\trestoreCheckBalance(finalBalance-minerAmt-fee, 1, 21, nil)\n\n\t// Last of all, make sure we can also restore a node from the extended\n\t// master root key directly instead of the seed.\n\tvar seedMnemonic aezeed.Mnemonic\n\tcopy(seedMnemonic[:], mnemonic)\n\tcipherSeed, err := seedMnemonic.ToCipherSeed(password)\n\trequire.NoError(ht, err)\n\textendedRootKey, err := hdkeychain.NewMaster(\n\t\tcipherSeed.Entropy[:], harnessNetParams,\n\t)\n\trequire.NoError(ht, err)\n\trootKey = extendedRootKey.String()\n\tmnemonic = nil\n\n\trestoreCheckBalance(finalBalance-minerAmt-fee, 1, 21, nil)\n}\n\n// testRescanAddressDetection makes sure that addresses created from internal\n// (m/1017' scope) keys aren't detected as UTXOs when re-scanning the wallet\n// with --reset-wallet-transactions to avoid showing them as un-spent ghost\n// UTXOs even if they are being spent. This is to test a fix in the wallet that\n// addresses the following scenario:\n//  1. A key is derived from the internal 1017' scope with a custom key family\n//     and a p2wkh address is derived from that key.\n//  2. Funds are sent to the address created above in a way that also creates a\n//     change output. The change output is recognized as belonging to the\n//     wallet, which is correct.\n//  3. The funds on the address created in step 1 are fully spent (without\n//     creating a change output) into an output that doesn't belong to the\n//     wallet (e.g. a channel funding output).\n//  4. At some point the user re-scans their wallet by using the\n//     --reset-wallet-transactions flag.\n//  5. The wallet re-scan detects the change output created in step 2 and flags\n//     the transaction as relevant.\n//  6. While adding the relevant TX to the wallet DB, the wallet also detects\n//     the address from step 1 as belonging to the wallet (because the internal\n//     key scope is defined as having the address type p2wkh) and adds that\n//     output as an UTXO as well (<- this is the bug). The wallet now has two\n//     UTXOs in its database.\n//  7. The transaction that spends the UTXO of the address from step 1 is not\n//     detected by the wallet as belonging to it (because the output is a\n//     channel output and the input (correctly) isn't recognized as belonging to\n//     the wallet in that part of the code, it is never marked as spent and\n//     stays in the wallet as a ghost UTXO forever.\n//\n// The fix in the wallet is simple: In step 6, don't detect addresses from\n// internal scopes while re-scanning to be in line with the logic in other areas\n// of the wallet code.",
      "length": 8725,
      "tokens": 1326,
      "embedding": []
    },
    {
      "slug": "func testRescanAddressDetection(ht *lntest.HarnessTest) {",
      "content": "func testRescanAddressDetection(ht *lntest.HarnessTest) {\n\t// We start off by creating a new node with the wallet re-scan flag\n\t// enabled. This won't have any effect on the first startup but will\n\t// come into effect after we re-start the node.\n\twalletPassword := []byte(\"some-password\")\n\tcarol, _, _ := ht.NewNodeWithSeed(\n\t\t\"carol\", []string{\"--reset-wallet-transactions\"},\n\t\twalletPassword, false,\n\t)\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, carol)\n\n\t// Create an address generated from internal keys.\n\tkeyDesc := carol.RPC.DeriveNextKey(&walletrpc.KeyReq{KeyFamily: 123})\n\tpubKeyHash := btcutil.Hash160(keyDesc.RawKeyBytes)\n\tghostUtxoAddr, err := btcutil.NewAddressWitnessPubKeyHash(\n\t\tpubKeyHash, harnessNetParams,\n\t)\n\trequire.NoError(ht, err)\n\n\t// Send funds to the (p2wkh!) address generated from the internal\n\t// (m/1017') key scope. Because the internal key scope is defined as\n\t// p2wkh address type, this might be incorrectly detected by the wallet\n\t// in some situations (which this test makes sure is fixed).\n\tconst ghostUtxoAmount = 456_000\n\tcarol.RPC.SendCoins(&lnrpc.SendCoinsRequest{\n\t\tAddr:        ghostUtxoAddr.String(),\n\t\tAmount:      ghostUtxoAmount,\n\t\tSatPerVbyte: 1,\n\t})\n\tht.MineBlocksAndAssertNumTxes(1, 1)\n\n\t// Make sure we see the change output in our list of unspent outputs.\n\t// We _don't_ expect to see the ghost UTXO here as in this step it's\n\t// ignored as an internal address correctly.\n\tht.AssertNumUTXOsConfirmed(carol, 1)\n\tunspent := carol.RPC.ListUnspent(&walletrpc.ListUnspentRequest{\n\t\tMinConfs: 1,\n\t})\n\n\t// Which one was the change output and which one the ghost UTXO output?\n\tvar ghostUtxoIndex uint32\n\tif unspent.Utxos[0].Outpoint.OutputIndex == 0 {\n\t\tghostUtxoIndex = 1\n\t}\n\n\tghostUtxoHash, err := chainhash.NewHash(\n\t\tunspent.Utxos[0].Outpoint.TxidBytes,\n\t)\n\trequire.NoError(ht, err)\n\n\tburnScript, _ := ht.CreateBurnAddr(AddrTypeWitnessPubkeyHash)\n\n\t// Create fee estimation for a p2wkh input and p2wkh output.\n\tfeeRate := chainfee.SatPerKWeight(12500)\n\testimator := input.TxWeightEstimator{}\n\testimator.AddP2WKHInput()\n\testimator.AddP2WKHOutput()\n\testimatedWeight := int64(estimator.Weight())\n\trequiredFee := feeRate.FeeForWeight(estimatedWeight)\n\n\ttx := wire.NewMsgTx(2)\n\ttx.TxIn = []*wire.TxIn{{\n\t\tPreviousOutPoint: wire.OutPoint{\n\t\t\tHash:  *ghostUtxoHash,\n\t\t\tIndex: ghostUtxoIndex,\n\t\t},\n\t}}\n\tvalue := int64(ghostUtxoAmount - requiredFee)\n\ttx.TxOut = []*wire.TxOut{{\n\t\tPkScript: burnScript,\n\t\tValue:    value,\n\t}}\n\n\tvar buf bytes.Buffer\n\trequire.NoError(ht, tx.Serialize(&buf))\n\n\tghostUtxoScript := ht.PayToAddrScript(ghostUtxoAddr)\n\tutxoInfo := []*signrpc.TxOut{{\n\t\tPkScript: ghostUtxoScript,\n\t\tValue:    ghostUtxoAmount,\n\t}}\n\n\t// Let's sign the input now.\n\tsignResp := carol.RPC.SignOutputRaw(&signrpc.SignReq{\n\t\tRawTxBytes: buf.Bytes(),\n\t\tSignDescs: []*signrpc.SignDescriptor{{\n\t\t\tOutput:        utxoInfo[0],\n\t\t\tInputIndex:    0,\n\t\t\tKeyDesc:       keyDesc,\n\t\t\tSighash:       uint32(txscript.SigHashAll),\n\t\t\tWitnessScript: utxoInfo[0].PkScript,\n\t\t}},\n\t})\n\n\t// Add the witness to the input and publish the tx.\n\ttx.TxIn[0].Witness = wire.TxWitness{\n\t\tappend(signResp.RawSigs[0], byte(txscript.SigHashAll)),\n\t\tkeyDesc.RawKeyBytes,\n\t}\n\tbuf.Reset()\n\trequire.NoError(ht, tx.Serialize(&buf))\n\tcarol.RPC.PublishTransaction(&walletrpc.Transaction{\n\t\tTxHex: buf.Bytes(),\n\t})\n\n\t// Wait until the spending tx is found and mine a block to confirm it.\n\tht.Miner.AssertNumTxsInMempool(1)\n\tht.MineBlocks(1)\n\n\t// The wallet should still just see a single UTXO of the change output\n\t// created earlier.\n\tht.AssertNumUTXOsConfirmed(carol, 1)\n\n\t// Let's now re-start the node, causing it to do the wallet re-scan.\n\tht.RestartNode(carol)\n\n\t// There should now still only be a single UTXO from the change output\n\t// instead of two (the ghost UTXO should be missing if the fix works).\n\tht.AssertNumUTXOsConfirmed(carol, 1)\n}\n",
      "length": 3673,
      "tokens": 416,
      "embedding": []
    }
  ]
}