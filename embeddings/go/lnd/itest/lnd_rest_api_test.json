{
  "filepath": "../implementations/go/lnd/itest/lnd_rest_api_test.go",
  "package": "itest",
  "sections": [
    {
      "slug": "func testRestAPI(ht *lntest.HarnessTest) {",
      "content": "func testRestAPI(ht *lntest.HarnessTest) {\n\ttestCases := []struct {\n\t\tname string\n\t\trun  func(*testing.T, *node.HarnessNode, *node.HarnessNode)\n\t}{{\n\t\tname: \"simple GET\",\n\t\trun: func(t *testing.T, a, b *node.HarnessNode) {\n\t\t\tt.Helper()\n\n\t\t\t// Check that the parsing into the response proto\n\t\t\t// message works.\n\t\t\tresp := &lnrpc.GetInfoResponse{}\n\t\t\terr := invokeGET(a, \"/v1/getinfo\", resp)\n\t\t\trequire.Nil(t, err, \"getinfo\")\n\t\t\trequire.Equal(t, \"#3399ff\", resp.Color, \"node color\")\n\n\t\t\t// Make sure we get the correct field names (snake\n\t\t\t// case).\n\t\t\t_, resp2, err := makeRequest(\n\t\t\t\ta, \"/v1/getinfo\", \"GET\", nil, nil,\n\t\t\t)\n\t\t\trequire.Nil(t, err, \"getinfo\")\n\t\t\trequire.Contains(\n\t\t\t\tt, string(resp2), \"best_header_timestamp\",\n\t\t\t\t\"getinfo\",\n\t\t\t)\n\t\t},\n\t}, {\n\t\tname: \"simple POST and GET with query param\",\n\t\trun: func(t *testing.T, a, b *node.HarnessNode) {\n\t\t\tt.Helper()\n\n\t\t\t// Add an invoice, testing POST in the process.\n\t\t\treq := &lnrpc.Invoice{Value: 1234}\n\t\t\tresp := &lnrpc.AddInvoiceResponse{}\n\t\t\terr := invokePOST(a, \"/v1/invoices\", req, resp)\n\t\t\trequire.Nil(t, err, \"add invoice\")\n\t\t\trequire.Equal(t, 32, len(resp.RHash), \"invoice rhash\")\n\n\t\t\t// Make sure we can call a GET endpoint with a hex\n\t\t\t// encoded URL part.\n\t\t\turl := fmt.Sprintf(\"/v1/invoice/%x\", resp.RHash)\n\t\t\tresp2 := &lnrpc.Invoice{}\n\t\t\terr = invokeGET(a, url, resp2)\n\t\t\trequire.Nil(t, err, \"query invoice\")\n\t\t\trequire.Equal(t, int64(1234), resp2.Value,\n\t\t\t\t\"invoice amt\")\n\t\t},\n\t}, {\n\t\tname: \"GET with base64 encoded byte slice in path\",\n\t\trun: func(t *testing.T, a, b *node.HarnessNode) {\n\t\t\tt.Helper()\n\n\t\t\turl := \"/v2/router/mc/probability/%s/%s/%d\"\n\t\t\turl = fmt.Sprintf(\n\t\t\t\turl, urlEnc.EncodeToString(a.PubKey[:]),\n\t\t\t\turlEnc.EncodeToString(b.PubKey[:]), 1234,\n\t\t\t)\n\t\t\tresp := &routerrpc.QueryProbabilityResponse{}\n\t\t\terr := invokeGET(a, url, resp)\n\t\t\trequire.Nil(t, err, \"query probability\")\n\t\t\trequire.Zero(t, resp.Probability)\n\t\t},\n\t}, {\n\t\tname: \"GET with map type query param\",\n\t\trun: func(t *testing.T, a, b *node.HarnessNode) {\n\t\t\tt.Helper()\n\n\t\t\t// Use a fake address.\n\t\t\taddr := \"bcrt1qlutnwklt4u2548cufrjmsjclewugr9lcpnkzag\"\n\n\t\t\t// Create the full URL with the map query param.\n\t\t\turl := \"/v1/transactions/fee?target_conf=%d&\" +\n\t\t\t\t\"AddrToAmount[%s]=%d\"\n\t\t\turl = fmt.Sprintf(url, 2, addr, 50000)\n\t\t\tresp := &lnrpc.EstimateFeeResponse{}\n\t\t\terr := invokeGET(a, url, resp)\n\t\t\trequire.Nil(t, err, \"estimate fee\")\n\t\t\trequire.Greater(t, resp.FeeSat, int64(253), \"fee\")\n\t\t},\n\t}, {\n\t\tname: \"sub RPC servers REST support\",\n\t\trun: func(t *testing.T, a, b *node.HarnessNode) {\n\t\t\tt.Helper()\n\n\t\t\t// Query autopilot status.\n\t\t\tres1 := &autopilotrpc.StatusResponse{}\n\t\t\terr := invokeGET(a, \"/v2/autopilot/status\", res1)\n\t\t\trequire.Nil(t, err, \"autopilot status\")\n\t\t\trequire.Equal(t, false, res1.Active, \"autopilot status\")\n\n\t\t\t// Query the version RPC.\n\t\t\tres2 := &verrpc.Version{}\n\t\t\terr = invokeGET(a, \"/v2/versioner/version\", res2)\n\t\t\trequire.Nil(t, err, \"version\")\n\t\t\trequire.Greater(\n\t\t\t\tt, res2.AppMinor, uint32(0), \"lnd minor version\",\n\t\t\t)\n\n\t\t\t// Request a new external address from the wallet kit.\n\t\t\treq1 := &walletrpc.AddrRequest{}\n\t\t\tres3 := &walletrpc.AddrResponse{}\n\t\t\terr = invokePOST(\n\t\t\t\ta, \"/v2/wallet/address/next\", req1, res3,\n\t\t\t)\n\t\t\trequire.Nil(t, err, \"address\")\n\t\t\trequire.NotEmpty(t, res3.Addr, \"address\")\n\t\t},\n\t}, {\n\t\tname: \"CORS headers\",\n\t\trun: func(t *testing.T, a, b *node.HarnessNode) {\n\t\t\tt.Helper()\n\n\t\t\t// Alice allows all origins. Make sure we get the same\n\t\t\t// value back in the CORS header that we send in the\n\t\t\t// Origin header.\n\t\t\treqHeaders := make(http.Header)\n\t\t\treqHeaders.Add(\"Origin\", \"https://foo.bar:9999\")\n\t\t\tresHeaders, body, err := makeRequest(\n\t\t\t\ta, \"/v1/getinfo\", \"OPTIONS\", nil, reqHeaders,\n\t\t\t)\n\t\t\trequire.Nil(t, err, \"getinfo\")\n\t\t\trequire.Equal(\n\t\t\t\tt, \"https://foo.bar:9999\",\n\t\t\t\tresHeaders.Get(\"Access-Control-Allow-Origin\"),\n\t\t\t\t\"CORS header\",\n\t\t\t)\n\t\t\trequire.Equal(t, 0, len(body))\n\n\t\t\t// Make sure that we don't get a value set for Bob which\n\t\t\t// doesn't allow any CORS origin.\n\t\t\tresHeaders, body, err = makeRequest(\n\t\t\t\tb, \"/v1/getinfo\", \"OPTIONS\", nil, reqHeaders,\n\t\t\t)\n\t\t\trequire.Nil(t, err, \"getinfo\")\n\t\t\trequire.Equal(\n\t\t\t\tt, \"\",\n\t\t\t\tresHeaders.Get(\"Access-Control-Allow-Origin\"),\n\t\t\t\t\"CORS header\",\n\t\t\t)\n\t\t\trequire.Equal(t, 0, len(body))\n\t\t},\n\t}}\n\twsTestCases := []struct {\n\t\tname string\n\t\trun  func(ht *lntest.HarnessTest)\n\t}{{\n\t\tname: \"websocket subscription\",\n\t\trun:  wsTestCaseSubscription,\n\t}, {\n\t\tname: \"websocket subscription with macaroon in protocol\",\n\t\trun:  wsTestCaseSubscriptionMacaroon,\n\t}, {\n\t\tname: \"websocket bi-directional subscription\",\n\t\trun:  wsTestCaseBiDirectionalSubscription,\n\t}, {\n\t\tname: \"websocket ping and pong timeout\",\n\t\trun:  wsTestPingPongTimeout,\n\t}}\n\n\t// Make sure Alice allows all CORS origins. Bob will keep the default.\n\t// We also make sure the ping/pong messages are sent very often, so we\n\t// can test them without waiting half a minute.\n\talice, bob := ht.Alice, ht.Bob\n\talice.Cfg.ExtraArgs = append(\n\t\talice.Cfg.ExtraArgs, \"--restcors=\\\"*\\\"\",\n\t\tfmt.Sprintf(\"--ws-ping-interval=%s\", pingInterval),\n\t\tfmt.Sprintf(\"--ws-pong-wait=%s\", pongWait),\n\t)\n\tht.RestartNode(alice)\n\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\t\tht.Run(tc.name, func(t *testing.T) {\n\t\t\ttc.run(t, alice, bob)\n\t\t})\n\t}\n\n\tfor _, tc := range wsTestCases {\n\t\ttc := tc\n\t\tht.Run(tc.name, func(t *testing.T) {\n\t\t\tst := ht.Subtest(t)\n\t\t\ttc.run(st)\n\t\t})\n\t}\n}\n",
      "length": 5177,
      "tokens": 620,
      "embedding": []
    },
    {
      "slug": "func wsTestCaseSubscription(ht *lntest.HarnessTest) {",
      "content": "func wsTestCaseSubscription(ht *lntest.HarnessTest) {\n\t// Find out the current best block so we can subscribe to the next one.\n\thash, height := ht.Miner.GetBestBlock()\n\n\t// Create a new subscription to get block epoch events.\n\treq := &chainrpc.BlockEpoch{\n\t\tHash:   hash.CloneBytes(),\n\t\tHeight: uint32(height),\n\t}\n\turl := \"/v2/chainnotifier/register/blocks\"\n\tc, err := openWebSocket(ht.Alice, url, \"POST\", req, nil)\n\trequire.NoError(ht, err, \"websocket\")\n\tdefer func() {\n\t\terr := c.WriteMessage(websocket.CloseMessage, closeMsg)\n\t\trequire.NoError(ht, err)\n\t\t_ = c.Close()\n\t}()\n\n\tmsgChan := make(chan *chainrpc.BlockEpoch)\n\terrChan := make(chan error)\n\ttimeout := time.After(defaultTimeout)\n\n\t// We want to read exactly one message.\n\tgo func() {\n\t\tdefer close(msgChan)\n\n\t\t_, msg, err := c.ReadMessage()\n\t\tif err != nil {\n\t\t\terrChan <- err\n\t\t\treturn\n\t\t}\n\n\t\t// The chunked/streamed responses come wrapped in either a\n\t\t// {\"result\":{}} or {\"error\":{}} wrapper which we'll get rid of\n\t\t// here.\n\t\tmsgStr := string(msg)\n\t\tif !strings.Contains(msgStr, \"\\\"result\\\":\") {\n\t\t\terrChan <- fmt.Errorf(\"invalid msg: %s\", msgStr)\n\t\t\treturn\n\t\t}\n\t\tmsgStr = resultPattern.ReplaceAllString(msgStr, \"${1}\")\n\n\t\t// Make sure we can parse the unwrapped message into the\n\t\t// expected proto message.\n\t\tprotoMsg := &chainrpc.BlockEpoch{}\n\t\terr = jsonpb.UnmarshalString(msgStr, protoMsg)\n\t\tif err != nil {\n\t\t\terrChan <- err\n\t\t\treturn\n\t\t}\n\n\t\tselect {\n\t\tcase msgChan <- protoMsg:\n\t\tcase <-timeout:\n\t\t}\n\t}()\n\n\t// Mine a block and make sure we get a message for it.\n\tblockHashes := ht.Miner.GenerateBlocks(1)\n\tselect {\n\tcase msg := <-msgChan:\n\t\trequire.Equal(\n\t\t\tht, blockHashes[0].CloneBytes(), msg.Hash,\n\t\t\t\"block hash\",\n\t\t)\n\n\tcase err := <-errChan:\n\t\tht.Fatalf(\"Received error from WS: %v\", err)\n\n\tcase <-timeout:\n\t\tht.Fatalf(\"Timeout before message was received\")\n\t}\n}\n",
      "length": 1717,
      "tokens": 233,
      "embedding": []
    },
    {
      "slug": "func wsTestCaseSubscriptionMacaroon(ht *lntest.HarnessTest) {",
      "content": "func wsTestCaseSubscriptionMacaroon(ht *lntest.HarnessTest) {\n\t// Find out the current best block so we can subscribe to the next one.\n\thash, height := ht.Miner.GetBestBlock()\n\n\t// Create a new subscription to get block epoch events.\n\treq := &chainrpc.BlockEpoch{\n\t\tHash:   hash.CloneBytes(),\n\t\tHeight: uint32(height),\n\t}\n\turl := \"/v2/chainnotifier/register/blocks\"\n\n\t// This time we send the macaroon in the special header\n\t// Sec-Websocket-Protocol which is the only header field available to\n\t// browsers when opening a WebSocket.\n\talice := ht.Alice\n\tmac, err := alice.ReadMacaroon(\n\t\talice.Cfg.AdminMacPath, defaultTimeout,\n\t)\n\trequire.NoError(ht, err, \"read admin mac\")\n\tmacBytes, err := mac.MarshalBinary()\n\trequire.NoError(ht, err, \"marshal admin mac\")\n\n\tcustomHeader := make(http.Header)\n\tcustomHeader.Set(lnrpc.HeaderWebSocketProtocol, fmt.Sprintf(\n\t\t\"Grpc-Metadata-Macaroon+%s\", hex.EncodeToString(macBytes),\n\t))\n\tc, err := openWebSocket(alice, url, \"POST\", req, customHeader)\n\trequire.Nil(ht, err, \"websocket\")\n\tdefer func() {\n\t\terr := c.WriteMessage(websocket.CloseMessage, closeMsg)\n\t\trequire.NoError(ht, err)\n\t\t_ = c.Close()\n\t}()\n\n\tmsgChan := make(chan *chainrpc.BlockEpoch)\n\terrChan := make(chan error)\n\ttimeout := time.After(defaultTimeout)\n\n\t// We want to read exactly one message.\n\tgo func() {\n\t\tdefer close(msgChan)\n\n\t\t_, msg, err := c.ReadMessage()\n\t\tif err != nil {\n\t\t\terrChan <- err\n\t\t\treturn\n\t\t}\n\n\t\t// The chunked/streamed responses come wrapped in either a\n\t\t// {\"result\":{}} or {\"error\":{}} wrapper which we'll get rid of\n\t\t// here.\n\t\tmsgStr := string(msg)\n\t\tif !strings.Contains(msgStr, \"\\\"result\\\":\") {\n\t\t\terrChan <- fmt.Errorf(\"invalid msg: %s\", msgStr)\n\t\t\treturn\n\t\t}\n\t\tmsgStr = resultPattern.ReplaceAllString(msgStr, \"${1}\")\n\n\t\t// Make sure we can parse the unwrapped message into the\n\t\t// expected proto message.\n\t\tprotoMsg := &chainrpc.BlockEpoch{}\n\t\terr = jsonpb.UnmarshalString(msgStr, protoMsg)\n\t\tif err != nil {\n\t\t\terrChan <- err\n\t\t\treturn\n\t\t}\n\n\t\tselect {\n\t\tcase msgChan <- protoMsg:\n\t\tcase <-timeout:\n\t\t}\n\t}()\n\n\t// Mine a block and make sure we get a message for it.\n\tblockHashes := ht.Miner.GenerateBlocks(1)\n\tselect {\n\tcase msg := <-msgChan:\n\t\trequire.Equal(\n\t\t\tht, blockHashes[0].CloneBytes(), msg.Hash,\n\t\t\t\"block hash\",\n\t\t)\n\n\tcase err := <-errChan:\n\t\tht.Fatalf(\"Received error from WS: %v\", err)\n\n\tcase <-timeout:\n\t\tht.Fatalf(\"Timeout before message was received\")\n\t}\n}\n",
      "length": 2260,
      "tokens": 292,
      "embedding": []
    },
    {
      "slug": "func wsTestCaseBiDirectionalSubscription(ht *lntest.HarnessTest) {",
      "content": "func wsTestCaseBiDirectionalSubscription(ht *lntest.HarnessTest) {\n\tinitialRequest := &lnrpc.ChannelAcceptResponse{}\n\turl := \"/v1/channels/acceptor\"\n\n\t// This time we send the macaroon in the special header\n\t// Sec-Websocket-Protocol which is the only header field available to\n\t// browsers when opening a WebSocket.\n\talice := ht.Alice\n\tmac, err := alice.ReadMacaroon(\n\t\talice.Cfg.AdminMacPath, defaultTimeout,\n\t)\n\trequire.NoError(ht, err, \"read admin mac\")\n\tmacBytes, err := mac.MarshalBinary()\n\trequire.NoError(ht, err, \"marshal admin mac\")\n\n\tcustomHeader := make(http.Header)\n\tcustomHeader.Set(lnrpc.HeaderWebSocketProtocol, fmt.Sprintf(\n\t\t\"Grpc-Metadata-Macaroon+%s\", hex.EncodeToString(macBytes),\n\t))\n\tconn, err := openWebSocket(\n\t\talice, url, \"POST\", initialRequest, customHeader,\n\t)\n\trequire.Nil(ht, err, \"websocket\")\n\tdefer func() {\n\t\terr := conn.WriteMessage(websocket.CloseMessage, closeMsg)\n\t\t_ = conn.Close()\n\t\trequire.NoError(ht, err)\n\t}()\n\n\t// Buffer the message channel to make sure we're always blocking on\n\t// conn.ReadMessage() to allow the ping/pong mechanism to work.\n\tmsgChan := make(chan *lnrpc.ChannelAcceptResponse, 1)\n\terrChan := make(chan error)\n\tdone := make(chan struct{})\n\ttimeout := time.After(defaultTimeout)\n\n\t// We want to read messages over and over again. We just accept any\n\t// channels that are opened.\n\tdefer close(done)\n\tgo func() {\n\t\tfor {\n\t\t\t_, msg, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tselect {\n\t\t\t\tcase errChan <- err:\n\t\t\t\tcase <-done:\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// The chunked/streamed responses come wrapped in either\n\t\t\t// a {\"result\":{}} or {\"error\":{}} wrapper which we'll\n\t\t\t// get rid of here.\n\t\t\tmsgStr := string(msg)\n\t\t\tif !strings.Contains(msgStr, \"\\\"result\\\":\") {\n\t\t\t\tselect {\n\t\t\t\tcase errChan <- fmt.Errorf(\"invalid msg: %s\",\n\t\t\t\t\tmsgStr):\n\t\t\t\tcase <-done:\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmsgStr = resultPattern.ReplaceAllString(msgStr, \"${1}\")\n\n\t\t\t// Make sure we can parse the unwrapped message into the\n\t\t\t// expected proto message.\n\t\t\tprotoMsg := &lnrpc.ChannelAcceptRequest{}\n\t\t\terr = jsonpb.UnmarshalString(msgStr, protoMsg)\n\t\t\tif err != nil {\n\t\t\t\tselect {\n\t\t\t\tcase errChan <- err:\n\t\t\t\tcase <-done:\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Send the response that we accept the channel.\n\t\t\tres := &lnrpc.ChannelAcceptResponse{\n\t\t\t\tAccept:        true,\n\t\t\t\tPendingChanId: protoMsg.PendingChanId,\n\t\t\t}\n\t\t\tresMsg, err := jsonMarshaler.MarshalToString(res)\n\t\t\tif err != nil {\n\t\t\t\tselect {\n\t\t\t\tcase errChan <- err:\n\t\t\t\tcase <-done:\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr = conn.WriteMessage(\n\t\t\t\twebsocket.TextMessage, []byte(resMsg),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tselect {\n\t\t\t\tcase errChan <- err:\n\t\t\t\tcase <-done:\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Also send the message on our message channel to make\n\t\t\t// sure we count it as successful.\n\t\t\tmsgChan <- res\n\n\t\t\t// Are we done or should there be more messages?\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Before we start opening channels, make sure the two nodes are\n\t// connected.\n\tbob := ht.Bob\n\tht.EnsureConnected(alice, bob)\n\n\t// Open 3 channels to make sure multiple requests and responses can be\n\t// sent over the web socket.\n\tconst numChannels = 3\n\tfor i := 0; i < numChannels; i++ {\n\t\tchanPoint := ht.OpenChannel(\n\t\t\tbob, alice, lntest.OpenChannelParams{Amt: 500000},\n\t\t)\n\t\tdefer ht.CloseChannel(bob, chanPoint)\n\n\t\tselect {\n\t\tcase <-msgChan:\n\t\tcase err := <-errChan:\n\t\t\tht.Fatalf(\"Received error from WS: %v\", err)\n\n\t\tcase <-timeout:\n\t\t\tht.Fatalf(\"Timeout before message was received\")\n\t\t}\n\t}\n}\n",
      "length": 3307,
      "tokens": 444,
      "embedding": []
    },
    {
      "slug": "func wsTestPingPongTimeout(ht *lntest.HarnessTest) {",
      "content": "func wsTestPingPongTimeout(ht *lntest.HarnessTest) {\n\tinitialRequest := &lnrpc.InvoiceSubscription{\n\t\tAddIndex: 1, SettleIndex: 1,\n\t}\n\turl := \"/v1/invoices/subscribe\"\n\n\t// This time we send the macaroon in the special header\n\t// Sec-Websocket-Protocol which is the only header field available to\n\t// browsers when opening a WebSocket.\n\talice := ht.Alice\n\tmac, err := alice.ReadMacaroon(\n\t\talice.Cfg.AdminMacPath, defaultTimeout,\n\t)\n\trequire.NoError(ht, err, \"read admin mac\")\n\tmacBytes, err := mac.MarshalBinary()\n\trequire.NoError(ht, err, \"marshal admin mac\")\n\n\tcustomHeader := make(http.Header)\n\tcustomHeader.Set(lnrpc.HeaderWebSocketProtocol, fmt.Sprintf(\n\t\t\"Grpc-Metadata-Macaroon+%s\", hex.EncodeToString(macBytes),\n\t))\n\tconn, err := openWebSocket(\n\t\talice, url, \"GET\", initialRequest, customHeader,\n\t)\n\trequire.Nil(ht, err, \"websocket\")\n\tdefer func() {\n\t\terr := conn.WriteMessage(websocket.CloseMessage, closeMsg)\n\t\t_ = conn.Close()\n\t\trequire.NoError(ht, err)\n\t}()\n\n\t// We want to be able to read invoices for a long time, making sure we\n\t// can continue to read even after we've gone through several ping/pong\n\t// cycles.\n\tinvoices := make(chan *lnrpc.Invoice, 1)\n\terrChan := make(chan error)\n\tdone := make(chan struct{})\n\ttimeout := time.After(defaultTimeout)\n\n\tdefer close(done)\n\tgo func() {\n\t\tfor {\n\t\t\t_, msg, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tselect {\n\t\t\t\tcase errChan <- err:\n\t\t\t\tcase <-done:\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// The chunked/streamed responses come wrapped in either\n\t\t\t// a {\"result\":{}} or {\"error\":{}} wrapper which we'll\n\t\t\t// get rid of here.\n\t\t\tmsgStr := string(msg)\n\t\t\tif !strings.Contains(msgStr, \"\\\"result\\\":\") {\n\t\t\t\tselect {\n\t\t\t\tcase errChan <- fmt.Errorf(\"invalid msg: %s\",\n\t\t\t\t\tmsgStr):\n\t\t\t\tcase <-done:\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmsgStr = resultPattern.ReplaceAllString(msgStr, \"${1}\")\n\n\t\t\t// Make sure we can parse the unwrapped message into the\n\t\t\t// expected proto message.\n\t\t\tprotoMsg := &lnrpc.Invoice{}\n\t\t\terr = jsonpb.UnmarshalString(msgStr, protoMsg)\n\t\t\tif err != nil {\n\t\t\t\tselect {\n\t\t\t\tcase errChan <- err:\n\t\t\t\tcase <-done:\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tinvoices <- protoMsg\n\n\t\t\t// Make sure we exit the loop once we've sent through\n\t\t\t// all expected test messages.\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t}()\n\n\t// The SubscribeInvoices call returns immediately after the gRPC/REST\n\t// connection is established. But it can happen that the goroutine in\n\t// lnd that actually registers the subscriber in the invoice backend\n\t// didn't get any CPU time just yet. So we can run into the situation\n\t// where we add our first invoice _before_ the subscription client is\n\t// registered. If that happens, we'll never get notified about the\n\t// invoice in question. So all we really can do is wait a bit here to\n\t// make sure the subscription is registered correctly.\n\ttime.Sleep(500 * time.Millisecond)\n\n\t// Let's create five invoices and wait for them to arrive. We'll wait\n\t// for at least one ping/pong cycle between each invoice.\n\tconst numInvoices = 5\n\tconst value = 123\n\tconst memo = \"websocket\"\n\tfor i := 0; i < numInvoices; i++ {\n\t\tinvoice := &lnrpc.Invoice{\n\t\t\tValue: value,\n\t\t\tMemo:  memo,\n\t\t}\n\t\talice.RPC.AddInvoice(invoice)\n\n\t\tselect {\n\t\tcase streamMsg := <-invoices:\n\t\t\trequire.Equal(ht, int64(value), streamMsg.Value)\n\t\t\trequire.Equal(ht, memo, streamMsg.Memo)\n\n\t\tcase err := <-errChan:\n\t\t\trequire.Fail(ht, \"Error reading invoice: %v\", err)\n\n\t\tcase <-timeout:\n\t\t\trequire.Fail(ht, \"No invoice msg received in time\")\n\t\t}\n\n\t\t// Let's wait for at least a whole ping/pong cycle to happen, so\n\t\t// we can be sure the read/write deadlines are set correctly.\n\t\t// We double the pong wait just to add some extra margin.\n\t\ttime.Sleep(pingInterval + 2*pongWait)\n\t}\n}\n\n// invokeGET calls the given URL with the GET method and appropriate macaroon\n// header fields then tries to unmarshal the response into the given response\n// proto message.",
      "length": 3726,
      "tokens": 534,
      "embedding": []
    },
    {
      "slug": "func invokeGET(node *node.HarnessNode, url string, resp proto.Message) error {",
      "content": "func invokeGET(node *node.HarnessNode, url string, resp proto.Message) error {\n\t_, rawResp, err := makeRequest(node, url, \"GET\", nil, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn jsonpb.Unmarshal(bytes.NewReader(rawResp), resp)\n}\n\n// invokePOST calls the given URL with the POST method, request body and\n// appropriate macaroon header fields then tries to unmarshal the response into\n// the given response proto message.",
      "length": 333,
      "tokens": 52,
      "embedding": []
    },
    {
      "slug": "func invokePOST(node *node.HarnessNode, url string, req,",
      "content": "func invokePOST(node *node.HarnessNode, url string, req,\n\tresp proto.Message) error {\n\n\t// Marshal the request to JSON using the jsonpb marshaler to get correct\n\t// field names.\n\tvar buf bytes.Buffer\n\tif err := jsonMarshaler.Marshal(&buf, req); err != nil {\n\t\treturn err\n\t}\n\n\t_, rawResp, err := makeRequest(node, url, \"POST\", &buf, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn jsonpb.Unmarshal(bytes.NewReader(rawResp), resp)\n}\n\n// makeRequest calls the given URL with the given method, request body and\n// appropriate macaroon header fields and returns the raw response body.",
      "length": 503,
      "tokens": 80,
      "embedding": []
    },
    {
      "slug": "func makeRequest(node *node.HarnessNode, url, method string,",
      "content": "func makeRequest(node *node.HarnessNode, url, method string,\n\trequest io.Reader, additionalHeaders http.Header) (http.Header, []byte,\n\terror) {\n\n\t// Assemble the full URL from the node's listening address then create\n\t// the request so we can set the macaroon on it.\n\tfullURL := fmt.Sprintf(\"https://%s%s\", node.Cfg.RESTAddr(), url)\n\treq, err := http.NewRequest(method, fullURL, request)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tif err := addAdminMacaroon(node, req.Header); err != nil {\n\t\treturn nil, nil, err\n\t}\n\tfor key, values := range additionalHeaders {\n\t\tfor _, value := range values {\n\t\t\treq.Header.Add(key, value)\n\t\t}\n\t}\n\n\t// Do the actual call with the completed request object now.\n\tresp, err := restClient.Do(req)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tdefer func() { _ = resp.Body.Close() }()\n\n\tdata, err := ioutil.ReadAll(resp.Body)\n\treturn resp.Header, data, err\n}\n\n// openWebSocket opens a new WebSocket connection to the given URL with the\n// appropriate macaroon headers and sends the request message over the socket.",
      "length": 951,
      "tokens": 150,
      "embedding": []
    },
    {
      "slug": "func openWebSocket(node *node.HarnessNode, url, method string,",
      "content": "func openWebSocket(node *node.HarnessNode, url, method string,\n\treq proto.Message, customHeader http.Header) (*websocket.Conn, error) {\n\n\t// Prepare our macaroon headers and assemble the full URL from the\n\t// node's listening address. WebSockets always work over GET so we need\n\t// to append the target request method as a query parameter.\n\theader := customHeader\n\tif header == nil {\n\t\theader = make(http.Header)\n\t\tif err := addAdminMacaroon(node, header); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tfullURL := fmt.Sprintf(\n\t\t\"wss://%s%s?method=%s\", node.Cfg.RESTAddr(), url, method,\n\t)\n\tconn, resp, err := webSocketDialer.Dial(fullURL, header)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer func() { _ = resp.Body.Close() }()\n\n\t// Send the given request message as the first message on the socket.\n\treqMsg, err := jsonMarshaler.MarshalToString(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = conn.WriteMessage(websocket.TextMessage, []byte(reqMsg))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn conn, nil\n}\n\n// addAdminMacaroon reads the admin macaroon from the node and appends it to\n// the HTTP header fields.",
      "length": 1012,
      "tokens": 158,
      "embedding": []
    },
    {
      "slug": "func addAdminMacaroon(node *node.HarnessNode, header http.Header) error {",
      "content": "func addAdminMacaroon(node *node.HarnessNode, header http.Header) error {\n\tmac, err := node.ReadMacaroon(node.Cfg.AdminMacPath, defaultTimeout)\n\tif err != nil {\n\t\treturn err\n\t}\n\tmacBytes, err := mac.MarshalBinary()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\theader.Set(\"Grpc-Metadata-Macaroon\", hex.EncodeToString(macBytes))\n\n\treturn nil\n}\n",
      "length": 245,
      "tokens": 30,
      "embedding": []
    }
  ]
}