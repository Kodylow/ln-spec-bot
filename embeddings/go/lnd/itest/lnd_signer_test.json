{
  "filepath": "../implementations/go/lnd/itest/lnd_signer_test.go",
  "package": "itest",
  "sections": [
    {
      "slug": "func testDeriveSharedKey(ht *lntest.HarnessTest) {",
      "content": "func testDeriveSharedKey(ht *lntest.HarnessTest) {\n\trunDeriveSharedKey(ht, ht.Alice)\n}\n\n// runDeriveSharedKey checks the ECDH performed by the endpoint\n// DeriveSharedKey. It creates an ephemeral private key, performing an ECDH with\n// the node's pubkey and a customized public key to check the validity of the\n// result.",
      "length": 264,
      "tokens": 41,
      "embedding": []
    },
    {
      "slug": "func runDeriveSharedKey(ht *lntest.HarnessTest, alice *node.HarnessNode) {",
      "content": "func runDeriveSharedKey(ht *lntest.HarnessTest, alice *node.HarnessNode) {\n\t// Create an ephemeral key, extracts its public key, and make a\n\t// PrivKeyECDH using the ephemeral key.\n\tephemeralPriv, err := btcec.NewPrivateKey()\n\trequire.NoError(ht, err, \"failed to create ephemeral key\")\n\n\tephemeralPubBytes := ephemeralPriv.PubKey().SerializeCompressed()\n\tprivKeyECDH := &keychain.PrivKeyECDH{PrivKey: ephemeralPriv}\n\n\t// assertECDHMatch checks the correctness of the ECDH between the\n\t// ephemeral key and the given public key.\n\tassertECDHMatch := func(pub *btcec.PublicKey,\n\t\treq *signrpc.SharedKeyRequest) {\n\n\t\tresp := alice.RPC.DeriveSharedKey(req)\n\n\t\tsharedKey, _ := privKeyECDH.ECDH(pub)\n\t\trequire.Equal(ht, sharedKey[:], resp.SharedKey,\n\t\t\t\"failed to derive the expected key\")\n\t}\n\n\tnodePub, err := btcec.ParsePubKey(alice.PubKey[:])\n\trequire.NoError(ht, err, \"failed to parse node pubkey\")\n\n\tcustomizedKeyFamily := int32(keychain.KeyFamilyMultiSig)\n\tcustomizedIndex := int32(1)\n\n\t// Derive a customized key.\n\tderiveReq := &signrpc.KeyLocator{\n\t\tKeyFamily: customizedKeyFamily,\n\t\tKeyIndex:  customizedIndex,\n\t}\n\tresp := alice.RPC.DeriveKey(deriveReq)\n\tcustomizedPub, err := btcec.ParsePubKey(resp.RawKeyBytes)\n\trequire.NoError(ht, err, \"failed to parse node pubkey\")\n\n\t// Test DeriveSharedKey with no optional arguments. It will result in\n\t// performing an ECDH between the ephemeral key and the node's pubkey.\n\treq := &signrpc.SharedKeyRequest{EphemeralPubkey: ephemeralPubBytes}\n\tassertECDHMatch(nodePub, req)\n\n\t// Test DeriveSharedKey with a KeyLoc which points to the node's pubkey.\n\treq = &signrpc.SharedKeyRequest{\n\t\tEphemeralPubkey: ephemeralPubBytes,\n\t\tKeyLoc: &signrpc.KeyLocator{\n\t\t\tKeyFamily: int32(keychain.KeyFamilyNodeKey),\n\t\t\tKeyIndex:  0,\n\t\t},\n\t}\n\tassertECDHMatch(nodePub, req)\n\n\t// Test DeriveSharedKey with a KeyLoc being set in KeyDesc. The KeyLoc\n\t// points to the node's pubkey.\n\treq = &signrpc.SharedKeyRequest{\n\t\tEphemeralPubkey: ephemeralPubBytes,\n\t\tKeyDesc: &signrpc.KeyDescriptor{\n\t\t\tKeyLoc: &signrpc.KeyLocator{\n\t\t\t\tKeyFamily: int32(keychain.KeyFamilyNodeKey),\n\t\t\t\tKeyIndex:  0,\n\t\t\t},\n\t\t},\n\t}\n\tassertECDHMatch(nodePub, req)\n\n\t// Test DeriveSharedKey with RawKeyBytes set in KeyDesc. The RawKeyBytes\n\t// is the node's pubkey bytes, and the KeyFamily is KeyFamilyNodeKey.\n\treq = &signrpc.SharedKeyRequest{\n\t\tEphemeralPubkey: ephemeralPubBytes,\n\t\tKeyDesc: &signrpc.KeyDescriptor{\n\t\t\tRawKeyBytes: alice.PubKey[:],\n\t\t\tKeyLoc: &signrpc.KeyLocator{\n\t\t\t\tKeyFamily: int32(keychain.KeyFamilyNodeKey),\n\t\t\t},\n\t\t},\n\t}\n\tassertECDHMatch(nodePub, req)\n\n\t// Test DeriveSharedKey with a KeyLoc which points to the customized\n\t// public key.\n\treq = &signrpc.SharedKeyRequest{\n\t\tEphemeralPubkey: ephemeralPubBytes,\n\t\tKeyLoc: &signrpc.KeyLocator{\n\t\t\tKeyFamily: customizedKeyFamily,\n\t\t\tKeyIndex:  customizedIndex,\n\t\t},\n\t}\n\tassertECDHMatch(customizedPub, req)\n\n\t// Test DeriveSharedKey with a KeyLoc being set in KeyDesc. The KeyLoc\n\t// points to the customized public key.\n\treq = &signrpc.SharedKeyRequest{\n\t\tEphemeralPubkey: ephemeralPubBytes,\n\t\tKeyDesc: &signrpc.KeyDescriptor{\n\t\t\tKeyLoc: &signrpc.KeyLocator{\n\t\t\t\tKeyFamily: customizedKeyFamily,\n\t\t\t\tKeyIndex:  customizedIndex,\n\t\t\t},\n\t\t},\n\t}\n\tassertECDHMatch(customizedPub, req)\n\n\t// Test DeriveSharedKey with RawKeyBytes set in KeyDesc. The RawKeyBytes\n\t// is the customized public key. The KeyLoc is also set with the family\n\t// being the customizedKeyFamily.\n\treq = &signrpc.SharedKeyRequest{\n\t\tEphemeralPubkey: ephemeralPubBytes,\n\t\tKeyDesc: &signrpc.KeyDescriptor{\n\t\t\tRawKeyBytes: customizedPub.SerializeCompressed(),\n\t\t\tKeyLoc: &signrpc.KeyLocator{\n\t\t\t\tKeyFamily: customizedKeyFamily,\n\t\t\t},\n\t\t},\n\t}\n\tassertECDHMatch(customizedPub, req)\n\n\t// assertErrorMatch checks when calling DeriveSharedKey with invalid\n\t// params, the expected error is returned.\n\tassertErrorMatch := func(match string, req *signrpc.SharedKeyRequest) {\n\t\terr := alice.RPC.DeriveSharedKeyErr(req)\n\t\trequire.Contains(ht, err.Error(), match, \"error not match\")\n\t}\n\n\t// Test that EphemeralPubkey must be supplied.\n\treq = &signrpc.SharedKeyRequest{}\n\tassertErrorMatch(\"must provide ephemeral pubkey\", req)\n\n\t// Test that cannot use both KeyDesc and KeyLoc.\n\treq = &signrpc.SharedKeyRequest{\n\t\tEphemeralPubkey: ephemeralPubBytes,\n\t\tKeyDesc: &signrpc.KeyDescriptor{\n\t\t\tRawKeyBytes: customizedPub.SerializeCompressed(),\n\t\t},\n\t\tKeyLoc: &signrpc.KeyLocator{\n\t\t\tKeyFamily: customizedKeyFamily,\n\t\t\tKeyIndex:  0,\n\t\t},\n\t}\n\tassertErrorMatch(\"use either key_desc or key_loc\", req)\n\n\t// Test when KeyDesc is used, KeyLoc must be set.\n\treq = &signrpc.SharedKeyRequest{\n\t\tEphemeralPubkey: ephemeralPubBytes,\n\t\tKeyDesc: &signrpc.KeyDescriptor{\n\t\t\tRawKeyBytes: alice.PubKey[:],\n\t\t},\n\t}\n\tassertErrorMatch(\"key_desc.key_loc must also be set\", req)\n\n\t// Test that cannot use both RawKeyBytes and KeyIndex.\n\treq = &signrpc.SharedKeyRequest{\n\t\tEphemeralPubkey: ephemeralPubBytes,\n\t\tKeyDesc: &signrpc.KeyDescriptor{\n\t\t\tRawKeyBytes: customizedPub.SerializeCompressed(),\n\t\t\tKeyLoc: &signrpc.KeyLocator{\n\t\t\t\tKeyFamily: customizedKeyFamily,\n\t\t\t\tKeyIndex:  1,\n\t\t\t},\n\t\t},\n\t}\n\tassertErrorMatch(\"use either raw_key_bytes or key_index\", req)\n}\n\n// testSignOutputRaw makes sure that the SignOutputRaw RPC can be used with all\n// custom ways of specifying the signing key in the key descriptor/locator.",
      "length": 5065,
      "tokens": 531,
      "embedding": []
    },
    {
      "slug": "func testSignOutputRaw(ht *lntest.HarnessTest) {",
      "content": "func testSignOutputRaw(ht *lntest.HarnessTest) {\n\trunSignOutputRaw(ht, ht.Alice)\n}\n\n// runSignOutputRaw makes sure that the SignOutputRaw RPC can be used with all\n// custom ways of specifying the signing key in the key descriptor/locator.",
      "length": 185,
      "tokens": 28,
      "embedding": []
    },
    {
      "slug": "func runSignOutputRaw(ht *lntest.HarnessTest, alice *node.HarnessNode) {",
      "content": "func runSignOutputRaw(ht *lntest.HarnessTest, alice *node.HarnessNode) {\n\t// For the next step, we need a public key. Let's use a special family\n\t// for this. We want this to be an index of zero.\n\tconst testCustomKeyFamily = 44\n\treq := &walletrpc.KeyReq{\n\t\tKeyFamily: testCustomKeyFamily,\n\t}\n\tkeyDesc := alice.RPC.DeriveNextKey(req)\n\trequire.Equal(ht, int32(0), keyDesc.KeyLoc.KeyIndex)\n\n\ttargetPubKey, err := btcec.ParsePubKey(keyDesc.RawKeyBytes)\n\trequire.NoError(ht, err)\n\n\t// First, try with a key descriptor that only sets the public key.\n\tassertSignOutputRaw(\n\t\tht, alice, targetPubKey, &signrpc.KeyDescriptor{\n\t\t\tRawKeyBytes: keyDesc.RawKeyBytes,\n\t\t}, txscript.SigHashAll,\n\t)\n\n\t// Now try again, this time only with the (0 index!) key locator.\n\tassertSignOutputRaw(\n\t\tht, alice, targetPubKey, &signrpc.KeyDescriptor{\n\t\t\tKeyLoc: &signrpc.KeyLocator{\n\t\t\t\tKeyFamily: keyDesc.KeyLoc.KeyFamily,\n\t\t\t\tKeyIndex:  keyDesc.KeyLoc.KeyIndex,\n\t\t\t},\n\t\t}, txscript.SigHashAll,\n\t)\n\n\t// And now test everything again with a new key where we know the index\n\t// is not 0.\n\treq = &walletrpc.KeyReq{\n\t\tKeyFamily: testCustomKeyFamily,\n\t}\n\tkeyDesc = alice.RPC.DeriveNextKey(req)\n\trequire.Equal(ht, int32(1), keyDesc.KeyLoc.KeyIndex)\n\n\ttargetPubKey, err = btcec.ParsePubKey(keyDesc.RawKeyBytes)\n\trequire.NoError(ht, err)\n\n\t// First, try with a key descriptor that only sets the public key.\n\tassertSignOutputRaw(\n\t\tht, alice, targetPubKey, &signrpc.KeyDescriptor{\n\t\t\tRawKeyBytes: keyDesc.RawKeyBytes,\n\t\t}, txscript.SigHashAll,\n\t)\n\n\t// Now try again, this time only with the key locator.\n\tassertSignOutputRaw(\n\t\tht, alice, targetPubKey, &signrpc.KeyDescriptor{\n\t\t\tKeyLoc: &signrpc.KeyLocator{\n\t\t\t\tKeyFamily: keyDesc.KeyLoc.KeyFamily,\n\t\t\t\tKeyIndex:  keyDesc.KeyLoc.KeyIndex,\n\t\t\t},\n\t\t}, txscript.SigHashAll,\n\t)\n\n\t// Finally, we'll try again, but this time with a non-default sighash.\n\tassertSignOutputRaw(\n\t\tht, alice, targetPubKey, &signrpc.KeyDescriptor{\n\t\t\tKeyLoc: &signrpc.KeyLocator{\n\t\t\t\tKeyFamily: keyDesc.KeyLoc.KeyFamily,\n\t\t\t\tKeyIndex:  keyDesc.KeyLoc.KeyIndex,\n\t\t\t},\n\t\t}, txscript.SigHashSingle,\n\t)\n}\n\n// assertSignOutputRaw sends coins to a p2wkh address derived from the given\n// target public key and then tries to spend that output again by invoking the\n// SignOutputRaw RPC with the key descriptor provided.",
      "length": 2157,
      "tokens": 249,
      "embedding": []
    },
    {
      "slug": "func assertSignOutputRaw(ht *lntest.HarnessTest,",
      "content": "func assertSignOutputRaw(ht *lntest.HarnessTest,\n\talice *node.HarnessNode, targetPubKey *btcec.PublicKey,\n\tkeyDesc *signrpc.KeyDescriptor,\n\tsigHash txscript.SigHashType) {\n\n\tpubKeyHash := btcutil.Hash160(targetPubKey.SerializeCompressed())\n\ttargetAddr, err := btcutil.NewAddressWitnessPubKeyHash(\n\t\tpubKeyHash, harnessNetParams,\n\t)\n\trequire.NoError(ht, err)\n\ttargetScript, err := txscript.PayToAddrScript(targetAddr)\n\trequire.NoError(ht, err)\n\n\t// Send some coins to the generated p2wpkh address.\n\treq := &lnrpc.SendCoinsRequest{\n\t\tAddr:   targetAddr.String(),\n\t\tAmount: 800_000,\n\t}\n\talice.RPC.SendCoins(req)\n\n\t// Wait until the TX is found in the mempool.\n\ttxid := ht.Miner.AssertNumTxsInMempool(1)[0]\n\n\ttargetOutputIndex := ht.GetOutputIndex(txid, targetAddr.String())\n\n\t// Clear the mempool.\n\tht.MineBlocksAndAssertNumTxes(1, 1)\n\n\t// Try to spend the output now to a new p2wkh address.\n\taddrReq := &lnrpc.NewAddressRequest{Type: AddrTypeWitnessPubkeyHash}\n\tp2wkhResp := alice.RPC.NewAddress(addrReq)\n\n\tp2wkhAdrr, err := btcutil.DecodeAddress(\n\t\tp2wkhResp.Address, harnessNetParams,\n\t)\n\trequire.NoError(ht, err)\n\n\tp2wkhPkScript, err := txscript.PayToAddrScript(p2wkhAdrr)\n\trequire.NoError(ht, err)\n\n\ttx := wire.NewMsgTx(2)\n\ttx.TxIn = []*wire.TxIn{{\n\t\tPreviousOutPoint: wire.OutPoint{\n\t\t\tHash:  *txid,\n\t\t\tIndex: uint32(targetOutputIndex),\n\t\t},\n\t}}\n\tvalue := int64(800_000 - 200)\n\ttx.TxOut = []*wire.TxOut{{\n\t\tPkScript: p2wkhPkScript,\n\t\tValue:    value,\n\t}}\n\n\tvar buf bytes.Buffer\n\trequire.NoError(ht, tx.Serialize(&buf))\n\n\tsignReq := &signrpc.SignReq{\n\t\tRawTxBytes: buf.Bytes(),\n\t\tSignDescs: []*signrpc.SignDescriptor{{\n\t\t\tOutput: &signrpc.TxOut{\n\t\t\t\tPkScript: targetScript,\n\t\t\t\tValue:    800_000,\n\t\t\t},\n\t\t\tInputIndex:    0,\n\t\t\tKeyDesc:       keyDesc,\n\t\t\tSighash:       uint32(sigHash),\n\t\t\tWitnessScript: targetScript,\n\t\t}},\n\t}\n\tsignResp := alice.RPC.SignOutputRaw(signReq)\n\n\ttx.TxIn[0].Witness = wire.TxWitness{\n\t\tappend(signResp.RawSigs[0], byte(sigHash)),\n\t\ttargetPubKey.SerializeCompressed(),\n\t}\n\n\tbuf.Reset()\n\trequire.NoError(ht, tx.Serialize(&buf))\n\n\talice.RPC.PublishTransaction(&walletrpc.Transaction{\n\t\tTxHex: buf.Bytes(),\n\t})\n\n\t// Wait until the spending tx is found.\n\ttxid = ht.Miner.AssertNumTxsInMempool(1)[0]\n\tp2wkhOutputIndex := ht.GetOutputIndex(txid, p2wkhAdrr.String())\n\n\top := &lnrpc.OutPoint{\n\t\tTxidBytes:   txid[:],\n\t\tOutputIndex: uint32(p2wkhOutputIndex),\n\t}\n\tht.AssertUTXOInWallet(alice, op, \"\")\n\n\t// Mine another block to clean up the mempool and to make sure the\n\t// spend tx is actually included in a block.\n\tht.MineBlocksAndAssertNumTxes(1, 1)\n}\n\n// testSignVerifyMessage makes sure that the SignMessage RPC can be used with\n// all custom flags by verifying with VerifyMessage. Tests both ECDSA and\n// Schnorr signatures.",
      "length": 2601,
      "tokens": 254,
      "embedding": []
    },
    {
      "slug": "func testSignVerifyMessage(ht *lntest.HarnessTest) {",
      "content": "func testSignVerifyMessage(ht *lntest.HarnessTest) {\n\trunSignVerifyMessage(ht, ht.Alice)\n}\n\n// runSignVerifyMessage makes sure that the SignMessage RPC can be used with\n// all custom flags by verifying with VerifyMessage. Tests both ECDSA and\n// Schnorr signatures.",
      "length": 207,
      "tokens": 30,
      "embedding": []
    },
    {
      "slug": "func runSignVerifyMessage(ht *lntest.HarnessTest, alice *node.HarnessNode) {",
      "content": "func runSignVerifyMessage(ht *lntest.HarnessTest, alice *node.HarnessNode) {\n\taliceMsg := []byte(\"alice msg\")\n\tkeyLoc := &signrpc.KeyLocator{\n\t\tKeyFamily: int32(keychain.KeyFamilyNodeKey),\n\t\tKeyIndex:  1,\n\t}\n\n\t// Sign a message with the default ECDSA.\n\tsignMsgReq := &signrpc.SignMessageReq{\n\t\tMsg:        aliceMsg,\n\t\tKeyLoc:     keyLoc,\n\t\tSchnorrSig: false,\n\t}\n\n\tsignMsgResp := alice.RPC.SignMessageSigner(signMsgReq)\n\n\tderiveCustomizedKey := func() *btcec.PublicKey {\n\t\tresp := alice.RPC.DeriveKey(keyLoc)\n\t\tpub, err := btcec.ParsePubKey(resp.RawKeyBytes)\n\t\trequire.NoError(ht, err, \"failed to parse node pubkey\")\n\n\t\treturn pub\n\t}\n\n\tcustomPubKey := deriveCustomizedKey()\n\n\tverifyReq := &signrpc.VerifyMessageReq{\n\t\tMsg:          aliceMsg,\n\t\tSignature:    signMsgResp.Signature,\n\t\tPubkey:       customPubKey.SerializeCompressed(),\n\t\tIsSchnorrSig: false,\n\t}\n\tverifyResp := alice.RPC.VerifyMessageSigner(verifyReq)\n\trequire.True(ht, verifyResp.Valid, \"failed to verify message\")\n\n\t// Use a different key locator.\n\tkeyLoc = &signrpc.KeyLocator{\n\t\tKeyFamily: int32(keychain.KeyFamilyNodeKey),\n\t\tKeyIndex:  2,\n\t}\n\n\t// Sign a message with Schnorr signature.\n\tsignMsgReq = &signrpc.SignMessageReq{\n\t\tMsg:        aliceMsg,\n\t\tKeyLoc:     keyLoc,\n\t\tSchnorrSig: true,\n\t}\n\tsignMsgResp = alice.RPC.SignMessageSigner(signMsgReq)\n\tcustomPubKey = deriveCustomizedKey()\n\n\t// Verify the Schnorr signature.\n\tverifyReq = &signrpc.VerifyMessageReq{\n\t\tMsg:          aliceMsg,\n\t\tSignature:    signMsgResp.Signature,\n\t\tPubkey:       schnorr.SerializePubKey(customPubKey),\n\t\tIsSchnorrSig: true,\n\t}\n\tverifyResp = alice.RPC.VerifyMessageSigner(verifyReq)\n\trequire.True(ht, verifyResp.Valid, \"failed to verify message\")\n\n\t// Also test that we can tweak a private key and verify the message\n\t// against the tweaked public key.\n\ttweakBytes := sha256.Sum256([]byte(\"some text\"))\n\ttweakedPubKey := txscript.ComputeTaprootOutputKey(\n\t\tcustomPubKey, tweakBytes[:],\n\t)\n\n\tsignMsgReq.SchnorrSigTapTweak = tweakBytes[:]\n\tsignMsgResp = alice.RPC.SignMessageSigner(signMsgReq)\n\n\tverifyReq = &signrpc.VerifyMessageReq{\n\t\tMsg:          aliceMsg,\n\t\tSignature:    signMsgResp.Signature,\n\t\tPubkey:       schnorr.SerializePubKey(tweakedPubKey),\n\t\tIsSchnorrSig: true,\n\t}\n\tverifyResp = alice.RPC.VerifyMessageSigner(verifyReq)\n\trequire.True(ht, verifyResp.Valid, \"failed to verify message\")\n}\n",
      "length": 2191,
      "tokens": 200,
      "embedding": []
    }
  ]
}