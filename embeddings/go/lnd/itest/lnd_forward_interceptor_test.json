{
  "filepath": "../implementations/go/lnd/itest/lnd_forward_interceptor_test.go",
  "package": "itest",
  "sections": [
    {
      "slug": "type interceptorTestCase struct {",
      "content": "type interceptorTestCase struct {\n\tamountMsat        int64\n\tpayAddr           []byte\n\tinvoice           *lnrpc.Invoice\n\tshouldHold        bool\n\tinterceptorAction routerrpc.ResolveHoldForwardAction\n}\n\n// testForwardInterceptorDedupHtlc tests that upon reconnection, duplicate\n// HTLCs aren't re-notified using the HTLC interceptor API.",
      "length": 292,
      "tokens": 27,
      "embedding": []
    },
    {
      "slug": "func testForwardInterceptorDedupHtlc(ht *lntest.HarnessTest) {",
      "content": "func testForwardInterceptorDedupHtlc(ht *lntest.HarnessTest) {\n\t// Initialize the test context with 3 connected nodes.\n\tts := newInterceptorTestScenario(ht)\n\n\talice, bob, carol := ts.alice, ts.bob, ts.carol\n\n\t// Open and wait for channels.\n\tconst chanAmt = btcutil.Amount(300000)\n\tp := lntest.OpenChannelParams{Amt: chanAmt}\n\treqs := []*lntest.OpenChannelRequest{\n\t\t{Local: alice, Remote: bob, Param: p},\n\t\t{Local: bob, Remote: carol, Param: p},\n\t}\n\tresp := ht.OpenMultiChannelsAsync(reqs)\n\tcpAB, cpBC := resp[0], resp[1]\n\n\t// Make sure Alice is aware of channel Bob=>Carol.\n\tht.AssertTopologyChannelOpen(alice, cpBC)\n\n\t// Connect the interceptor.\n\tinterceptor, cancelInterceptor := bob.RPC.HtlcInterceptor()\n\n\t// Prepare the test cases.\n\treq := &lnrpc.Invoice{ValueMsat: 1000}\n\taddResponse := carol.RPC.AddInvoice(req)\n\tinvoice := carol.RPC.LookupInvoice(addResponse.RHash)\n\ttc := &interceptorTestCase{\n\t\tamountMsat: 1000,\n\t\tinvoice:    invoice,\n\t\tpayAddr:    invoice.PaymentAddr,\n\t}\n\n\t// We initiate a payment from Alice.\n\tdone := make(chan struct{})\n\tgo func() {\n\t\t// Signal that all the payments have been sent.\n\t\tdefer close(done)\n\n\t\tts.sendPaymentAndAssertAction(tc)\n\t}()\n\n\t// We start the htlc interceptor with a simple implementation that\n\t// saves all intercepted packets. These packets are held to simulate a\n\t// pending payment.\n\tpacket := ht.ReceiveHtlcInterceptor(interceptor)\n\n\t// Here we should wait for the channel to contain a pending htlc, and\n\t// also be shown as being active.\n\terr := wait.NoError(func() error {\n\t\tchannel := ht.QueryChannelByChanPoint(bob, cpAB)\n\n\t\tif len(channel.PendingHtlcs) == 0 {\n\t\t\treturn fmt.Errorf(\"expect alice <> bob channel to \" +\n\t\t\t\t\"have pending htlcs\")\n\t\t}\n\t\tif channel.Active {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn fmt.Errorf(\"channel not active\")\n\t}, defaultTimeout)\n\trequire.NoError(\n\t\tht, err, \"alice <> bob channel pending htlc never arrived\",\n\t)\n\n\t// At this point we want to make bob's link send all pending htlcs to\n\t// the switch again. We force this behavior by disconnecting and\n\t// connecting to the peer.\n\tht.DisconnectNodes(bob, alice)\n\tht.EnsureConnected(bob, alice)\n\n\t// Here we wait for the channel to be active again.\n\tht.AssertChannelExists(alice, cpAB)\n\tht.AssertChannelExists(bob, cpAB)\n\n\t// Now that the channel is active we make sure the test passes as\n\t// expected.\n\n\t// We expect one in flight payment since we held the htlcs.\n\tvar preimage lntypes.Preimage\n\tcopy(preimage[:], invoice.RPreimage)\n\tht.AssertPaymentStatus(alice, preimage, lnrpc.Payment_IN_FLIGHT)\n\n\t// At this point if we have more than one held htlcs then we should\n\t// fail. This means we hold the same htlc twice which is a risk we want\n\t// to eliminate. If we don't have the same htlc twice in theory we can\n\t// cancel one and settle the other by mistake.\n\terrDone := make(chan struct{})\n\tgo func() {\n\t\tdefer close(errDone)\n\n\t\t_, err := interceptor.Recv()\n\t\trequire.Error(ht, err, \"expected an error from interceptor\")\n\n\t\tstatus, ok := status.FromError(err)\n\t\tswitch {\n\t\t// If it is just the error result of the context cancellation\n\t\t// the we exit silently.\n\t\tcase ok && status.Code() == codes.Canceled:\n\t\t\tfallthrough\n\n\t\t// When the test ends, during the node's shutdown it will close\n\t\t// the connection.\n\t\tcase strings.Contains(err.Error(), \"closed network connection\"):\n\t\t\tfallthrough\n\n\t\tcase strings.Contains(err.Error(), \"EOF\"):\n\t\t\treturn\n\t\t}\n\n\t\t// Otherwise we receive an unexpected error.\n\t\trequire.Failf(ht, \"interceptor\", \"unexpected err: %v\", err)\n\t}()\n\n\t// We now fail all htlcs to cancel the payment.\n\terr = interceptor.Send(&routerrpc.ForwardHtlcInterceptResponse{\n\t\tIncomingCircuitKey: packet.IncomingCircuitKey,\n\t\tAction:             routerrpc.ResolveHoldForwardAction_FAIL,\n\t})\n\trequire.NoError(ht, err, \"failed to send request\")\n\n\t// Cancel the context, which will disconnect the above interceptor.\n\tcancelInterceptor()\n\n\t// Make sure all goroutines are finished.\n\tselect {\n\tcase <-done:\n\tcase <-time.After(defaultTimeout):\n\t\trequire.Fail(ht, \"timeout waiting for sending payment\")\n\t}\n\n\tselect {\n\tcase <-errDone:\n\tcase <-time.After(defaultTimeout):\n\t\trequire.Fail(ht, \"timeout waiting for interceptor error\")\n\t}\n\n\t// Finally, close channels.\n\tht.CloseChannel(alice, cpAB)\n\tht.CloseChannel(bob, cpBC)\n}\n\n// testForwardInterceptorBasic tests the forward interceptor RPC layer.\n// The test creates a cluster of 3 connected nodes: Alice -> Bob -> Carol\n// Alice sends 4 different payments to Carol while the interceptor handles\n// differently the htlcs.\n// The test ensures that:\n//  1. Intercepted failed htlcs result in no payment (invoice is not settled).\n//  2. Intercepted resumed htlcs result in a payment (invoice is settled).\n//  3. Intercepted held htlcs result in no payment (invoice is not settled).\n//  4. When Interceptor disconnects it resumes all held htlcs, which result in\n//     valid payment (invoice is settled).",
      "length": 4673,
      "tokens": 638,
      "embedding": []
    },
    {
      "slug": "func testForwardInterceptorBasic(ht *lntest.HarnessTest) {",
      "content": "func testForwardInterceptorBasic(ht *lntest.HarnessTest) {\n\tts := newInterceptorTestScenario(ht)\n\n\talice, bob, carol := ts.alice, ts.bob, ts.carol\n\n\t// Open and wait for channels.\n\tconst chanAmt = btcutil.Amount(300000)\n\tp := lntest.OpenChannelParams{Amt: chanAmt}\n\treqs := []*lntest.OpenChannelRequest{\n\t\t{Local: alice, Remote: bob, Param: p},\n\t\t{Local: bob, Remote: carol, Param: p},\n\t}\n\tresp := ht.OpenMultiChannelsAsync(reqs)\n\tcpAB, cpBC := resp[0], resp[1]\n\n\t// Make sure Alice is aware of channel Bob=>Carol.\n\tht.AssertTopologyChannelOpen(alice, cpBC)\n\n\t// Connect the interceptor.\n\tinterceptor, cancelInterceptor := bob.RPC.HtlcInterceptor()\n\n\t// Prepare the test cases.\n\ttestCases := ts.prepareTestCases()\n\n\t// For each test case make sure we initiate a payment from Alice to\n\t// Carol routed through Bob. For each payment we also test its final\n\t// status according to the interceptorAction specified in the test\n\t// case.\n\tdone := make(chan struct{})\n\tgo func() {\n\t\t// Signal that all the payments have been sent.\n\t\tdefer close(done)\n\n\t\tfor _, tc := range testCases {\n\t\t\tattempt := ts.sendPaymentAndAssertAction(tc)\n\t\t\tts.assertAction(tc, attempt)\n\t\t}\n\t}()\n\n\t// We make sure here the interceptor has processed all packets before\n\t// we check the payment statuses.\n\tfor _, tc := range testCases {\n\t\trequest := ht.ReceiveHtlcInterceptor(interceptor)\n\n\t\t// Assert sanity of informational packet data.\n\t\trequire.NotZero(ht, request.OutgoingRequestedChanId)\n\t\trequire.NotZero(ht, request.IncomingExpiry)\n\t\trequire.NotZero(ht, request.IncomingAmountMsat)\n\n\t\trequire.Less(ht, request.OutgoingExpiry,\n\t\t\trequest.IncomingExpiry)\n\t\trequire.Less(ht, request.OutgoingAmountMsat,\n\t\t\trequest.IncomingAmountMsat)\n\n\t\tvalue, ok := request.CustomRecords[customTestKey]\n\t\trequire.True(ht, ok, \"expected custom record\")\n\t\trequire.Equal(ht, customTestValue, value)\n\n\t\t// For held packets we ignore, keeping them in hold status.\n\t\tif tc.shouldHold {\n\t\t\tcontinue\n\t\t}\n\n\t\t// For all other packets we resolve according to the test case.\n\t\terr := interceptor.Send(&routerrpc.ForwardHtlcInterceptResponse{\n\t\t\tIncomingCircuitKey: request.IncomingCircuitKey,\n\t\t\tAction:             tc.interceptorAction,\n\t\t\tPreimage:           tc.invoice.RPreimage,\n\t\t})\n\t\trequire.NoError(ht, err, \"failed to send request\")\n\t}\n\n\t// At this point we are left with the held packets, we want to make\n\t// sure each one of them has a corresponding 'in-flight' payment at\n\t// Alice's node.\n\tfor _, testCase := range testCases {\n\t\tif !testCase.shouldHold {\n\t\t\tcontinue\n\t\t}\n\n\t\tvar preimage lntypes.Preimage\n\t\tcopy(preimage[:], testCase.invoice.RPreimage)\n\n\t\tpayment := ht.AssertPaymentStatus(\n\t\t\talice, preimage, lnrpc.Payment_IN_FLIGHT,\n\t\t)\n\t\texpectedAmt := testCase.invoice.ValueMsat\n\t\trequire.Equal(ht, expectedAmt, payment.ValueMsat,\n\t\t\t\"incorrect in flight amount\")\n\t}\n\n\t// Cancel the context, which will disconnect the above interceptor.\n\tcancelInterceptor()\n\n\t// Disconnect interceptor should cause resume held packets. After that\n\t// we wait for all go routines to finish, including the one that tests\n\t// the payment final status for the held payment.\n\tselect {\n\tcase <-done:\n\tcase <-time.After(defaultTimeout):\n\t\trequire.Fail(ht, \"timeout waiting for sending payment\")\n\t}\n\n\t// Verify that we don't get notified about already completed HTLCs\n\t// We do that by restarting alice, the sender the HTLCs. Under\n\t// https://github.com/lightningnetwork/lnd/issues/5115\n\t// this should cause all HTLCs settled or failed by the interceptor to\n\t// renotify.\n\trestartAlice := ht.SuspendNode(alice)\n\trequire.NoError(ht, restartAlice(), \"failed to restart alice\")\n\n\t// Make sure the channel is active from both Alice and Bob's PoV.\n\tht.AssertChannelExists(alice, cpAB)\n\tht.AssertChannelExists(bob, cpAB)\n\n\t// Create a new interceptor as the old one has quit.\n\tinterceptor, cancelInterceptor = bob.RPC.HtlcInterceptor()\n\n\tdone = make(chan struct{})\n\tgo func() {\n\t\tdefer close(done)\n\n\t\t_, err := interceptor.Recv()\n\t\trequire.Error(ht, err, \"expected an error from interceptor\")\n\n\t\tstatus, ok := status.FromError(err)\n\t\tswitch {\n\t\t// If it is just the error result of the context cancellation\n\t\t// the we exit silently.\n\t\tcase ok && status.Code() == codes.Canceled:\n\t\t\tfallthrough\n\n\t\t// When the test ends, during the node's shutdown it will close\n\t\t// the connection.\n\t\tcase strings.Contains(err.Error(), \"closed network connection\"):\n\t\t\tfallthrough\n\n\t\tcase strings.Contains(err.Error(), \"EOF\"):\n\t\t\treturn\n\t\t}\n\n\t\t// Otherwise we receive an unexpected error.\n\t\trequire.Failf(ht, \"iinterceptor\", \"unexpected err: %v\", err)\n\t}()\n\n\t// Cancel the context, which will disconnect the above interceptor.\n\tcancelInterceptor()\n\tselect {\n\tcase <-done:\n\tcase <-time.After(defaultTimeout):\n\t\trequire.Fail(ht, \"timeout waiting for interceptor error\")\n\t}\n\n\t// Finally, close channels.\n\tht.CloseChannel(alice, cpAB)\n\tht.CloseChannel(bob, cpBC)\n}\n\n// interceptorTestScenario is a helper struct to hold the test context and\n// provide the needed functionality.",
      "length": 4774,
      "tokens": 593,
      "embedding": []
    },
    {
      "slug": "type interceptorTestScenario struct {",
      "content": "type interceptorTestScenario struct {\n\tht                *lntest.HarnessTest\n\talice, bob, carol *node.HarnessNode\n}\n\n// newInterceptorTestScenario initializes a new test scenario with three nodes\n// and connects them to have the following topology,\n//\n//\tAlice --> Bob --> Carol\n//\n// Among them, Alice and Bob are standby nodes and Carol is a new node.",
      "length": 306,
      "tokens": 49,
      "embedding": []
    },
    {
      "slug": "func newInterceptorTestScenario(",
      "content": "func newInterceptorTestScenario(\n\tht *lntest.HarnessTest) *interceptorTestScenario {\n\n\talice, bob := ht.Alice, ht.Bob\n\tcarol := ht.NewNode(\"carol\", nil)\n\n\tht.EnsureConnected(alice, bob)\n\tht.EnsureConnected(bob, carol)\n\n\treturn &interceptorTestScenario{\n\t\tht:    ht,\n\t\talice: alice,\n\t\tbob:   bob,\n\t\tcarol: carol,\n\t}\n}\n\n// prepareTestCases prepares 4 tests:\n// 1. failed htlc.\n// 2. resumed htlc.\n// 3. settling htlc externally.\n// 4. held htlc that is resumed later.",
      "length": 412,
      "tokens": 55,
      "embedding": []
    },
    {
      "slug": "func (c *interceptorTestScenario) prepareTestCases() []*interceptorTestCase {",
      "content": "func (c *interceptorTestScenario) prepareTestCases() []*interceptorTestCase {\n\tvar (\n\t\tactionFail   = routerrpc.ResolveHoldForwardAction_FAIL\n\t\tactionResume = routerrpc.ResolveHoldForwardAction_RESUME\n\t\tactionSettle = routerrpc.ResolveHoldForwardAction_SETTLE\n\t)\n\n\tcases := []*interceptorTestCase{\n\t\t{\n\t\t\tamountMsat: 1000, shouldHold: false,\n\t\t\tinterceptorAction: actionFail,\n\t\t},\n\t\t{\n\t\t\tamountMsat: 1000, shouldHold: false,\n\t\t\tinterceptorAction: actionResume,\n\t\t},\n\t\t{\n\t\t\tamountMsat: 1000, shouldHold: false,\n\t\t\tinterceptorAction: actionSettle,\n\t\t},\n\t\t{\n\t\t\tamountMsat: 1000, shouldHold: true,\n\t\t\tinterceptorAction: actionResume,\n\t\t},\n\t}\n\n\tfor _, t := range cases {\n\t\tinv := &lnrpc.Invoice{ValueMsat: t.amountMsat}\n\t\taddResponse := c.carol.RPC.AddInvoice(inv)\n\t\tinvoice := c.carol.RPC.LookupInvoice(addResponse.RHash)\n\n\t\t// We'll need to also decode the returned invoice so we can\n\t\t// grab the payment address which is now required for ALL\n\t\t// payments.\n\t\tpayReq := c.carol.RPC.DecodePayReq(invoice.PaymentRequest)\n\n\t\tt.invoice = invoice\n\t\tt.payAddr = payReq.PaymentAddr\n\t}\n\n\treturn cases\n}\n\n// sendPaymentAndAssertAction sends a payment from alice to carol and asserts\n// that the specified interceptor action is taken.",
      "length": 1101,
      "tokens": 122,
      "embedding": []
    },
    {
      "slug": "func (c *interceptorTestScenario) sendPaymentAndAssertAction(",
      "content": "func (c *interceptorTestScenario) sendPaymentAndAssertAction(\n\ttc *interceptorTestCase) *lnrpc.HTLCAttempt {\n\n\t// Build a route from alice to carol.\n\troute := c.buildRoute(\n\t\ttc.amountMsat, []*node.HarnessNode{c.bob, c.carol}, tc.payAddr,\n\t)\n\n\t// Send a custom record to the forwarding node.\n\troute.Hops[0].CustomRecords = map[uint64][]byte{\n\t\tcustomTestKey: customTestValue,\n\t}\n\n\t// Send the payment.\n\tsendReq := &routerrpc.SendToRouteRequest{\n\t\tPaymentHash: tc.invoice.RHash,\n\t\tRoute:       route,\n\t}\n\n\treturn c.alice.RPC.SendToRouteV2(sendReq)\n}\n",
      "length": 467,
      "tokens": 50,
      "embedding": []
    },
    {
      "slug": "func (c *interceptorTestScenario) assertAction(tc *interceptorTestCase,",
      "content": "func (c *interceptorTestScenario) assertAction(tc *interceptorTestCase,\n\tattempt *lnrpc.HTLCAttempt) {\n\n\t// Now check the expected action has been taken.\n\tswitch tc.interceptorAction {\n\t// For 'fail' interceptor action we make sure the payment failed.\n\tcase routerrpc.ResolveHoldForwardAction_FAIL:\n\t\trequire.Equal(c.ht, lnrpc.HTLCAttempt_FAILED, attempt.Status,\n\t\t\t\"expected payment to fail\")\n\n\t\t// Assert that we get a temporary channel failure which has a\n\t\t// channel update.\n\t\trequire.NotNil(c.ht, attempt.Failure)\n\t\trequire.NotNil(c.ht, attempt.Failure.ChannelUpdate)\n\n\t\trequire.Equal(c.ht, lnrpc.Failure_TEMPORARY_CHANNEL_FAILURE,\n\t\t\tattempt.Failure.Code)\n\n\t// For settle and resume we make sure the payment is successful.\n\tcase routerrpc.ResolveHoldForwardAction_SETTLE:\n\t\tfallthrough\n\n\tcase routerrpc.ResolveHoldForwardAction_RESUME:\n\t\trequire.Equal(c.ht, lnrpc.HTLCAttempt_SUCCEEDED,\n\t\t\tattempt.Status, \"expected payment to succeed\")\n\t}\n}\n\n// buildRoute is a helper function to build a route with given hops.",
      "length": 919,
      "tokens": 96,
      "embedding": []
    },
    {
      "slug": "func (c *interceptorTestScenario) buildRoute(amtMsat int64,",
      "content": "func (c *interceptorTestScenario) buildRoute(amtMsat int64,\n\thops []*node.HarnessNode, payAddr []byte) *lnrpc.Route {\n\n\trpcHops := make([][]byte, 0, len(hops))\n\tfor _, hop := range hops {\n\t\tk := hop.PubKeyStr\n\t\tpubkey, err := route.NewVertexFromStr(k)\n\t\trequire.NoErrorf(c.ht, err, \"error parsing %v: %v\", k, err)\n\t\trpcHops = append(rpcHops, pubkey[:])\n\t}\n\n\treq := &routerrpc.BuildRouteRequest{\n\t\tAmtMsat:        amtMsat,\n\t\tFinalCltvDelta: chainreg.DefaultBitcoinTimeLockDelta,\n\t\tHopPubkeys:     rpcHops,\n\t\tPaymentAddr:    payAddr,\n\t}\n\n\trouteResp := c.alice.RPC.BuildRoute(req)\n\n\treturn routeResp.Route\n}\n",
      "length": 524,
      "tokens": 56,
      "embedding": []
    }
  ]
}