{
  "filepath": "../implementations/go/lnd/itest/lnd_channel_balance_test.go",
  "package": "itest",
  "sections": [
    {
      "slug": "func testChannelBalance(ht *lntest.HarnessTest) {",
      "content": "func testChannelBalance(ht *lntest.HarnessTest) {\n\t// Open a channel with 0.16 BTC between Alice and Bob, ensuring the\n\t// channel has been opened properly.\n\tamount := funding.MaxBtcFundingAmount\n\n\t// Creates a helper closure to be used below which asserts the proper\n\t// response to a channel balance RPC.\n\tcheckChannelBalance := func(node *node.HarnessNode,\n\t\tlocal, remote btcutil.Amount) {\n\n\t\texpectedResponse := &lnrpc.ChannelBalanceResponse{\n\t\t\tLocalBalance: &lnrpc.Amount{\n\t\t\t\tSat:  uint64(local),\n\t\t\t\tMsat: uint64(lnwire.NewMSatFromSatoshis(local)),\n\t\t\t},\n\t\t\tRemoteBalance: &lnrpc.Amount{\n\t\t\t\tSat: uint64(remote),\n\t\t\t\tMsat: uint64(lnwire.NewMSatFromSatoshis(\n\t\t\t\t\tremote,\n\t\t\t\t)),\n\t\t\t},\n\t\t\tUnsettledLocalBalance:    &lnrpc.Amount{},\n\t\t\tUnsettledRemoteBalance:   &lnrpc.Amount{},\n\t\t\tPendingOpenLocalBalance:  &lnrpc.Amount{},\n\t\t\tPendingOpenRemoteBalance: &lnrpc.Amount{},\n\t\t\t// Deprecated fields.\n\t\t\tBalance: int64(local),\n\t\t}\n\t\tht.AssertChannelBalanceResp(node, expectedResponse)\n\t}\n\n\t// Before beginning, make sure alice and bob are connected.\n\talice, bob := ht.Alice, ht.Bob\n\tht.EnsureConnected(alice, bob)\n\n\tchanPoint := ht.OpenChannel(\n\t\talice, bob, lntest.OpenChannelParams{Amt: amount},\n\t)\n\tcType := ht.GetChannelCommitType(alice, chanPoint)\n\n\t// As this is a single funder channel, Alice's balance should be\n\t// exactly 0.5 BTC since now state transitions have taken place yet.\n\tcheckChannelBalance(alice, amount-lntest.CalcStaticFee(cType, 0), 0)\n\n\t// Ensure Bob currently has no available balance within the channel.\n\tcheckChannelBalance(bob, 0, amount-lntest.CalcStaticFee(cType, 0))\n\n\t// Finally close the channel between Alice and Bob, asserting that the\n\t// channel has been properly closed on-chain.\n\tht.CloseChannel(alice, chanPoint)\n}\n\n// testChannelUnsettledBalance will test that the UnsettledBalance field\n// is updated according to the number of Pending Htlcs.\n// Alice will send Htlcs to Carol while she is in hodl mode. This will result\n// in a build of pending Htlcs. We expect the channels unsettled balance to\n// equal the sum of all the Pending Htlcs.",
      "length": 1979,
      "tokens": 237,
      "embedding": []
    },
    {
      "slug": "func testChannelUnsettledBalance(ht *lntest.HarnessTest) {",
      "content": "func testChannelUnsettledBalance(ht *lntest.HarnessTest) {\n\tconst chanAmt = btcutil.Amount(1000000)\n\n\t// Creates a helper closure to be used below which asserts the proper\n\t// response to a channel balance RPC.\n\tcheckChannelBalance := func(node *node.HarnessNode,\n\t\tlocal, remote, unsettledLocal, unsettledRemote btcutil.Amount) {\n\n\t\texpectedResponse := &lnrpc.ChannelBalanceResponse{\n\t\t\tLocalBalance: &lnrpc.Amount{\n\t\t\t\tSat: uint64(local),\n\t\t\t\tMsat: uint64(lnwire.NewMSatFromSatoshis(\n\t\t\t\t\tlocal,\n\t\t\t\t)),\n\t\t\t},\n\t\t\tRemoteBalance: &lnrpc.Amount{\n\t\t\t\tSat: uint64(remote),\n\t\t\t\tMsat: uint64(lnwire.NewMSatFromSatoshis(\n\t\t\t\t\tremote,\n\t\t\t\t)),\n\t\t\t},\n\t\t\tUnsettledLocalBalance: &lnrpc.Amount{\n\t\t\t\tSat: uint64(unsettledLocal),\n\t\t\t\tMsat: uint64(lnwire.NewMSatFromSatoshis(\n\t\t\t\t\tunsettledLocal,\n\t\t\t\t)),\n\t\t\t},\n\t\t\tUnsettledRemoteBalance: &lnrpc.Amount{\n\t\t\t\tSat: uint64(unsettledRemote),\n\t\t\t\tMsat: uint64(lnwire.NewMSatFromSatoshis(\n\t\t\t\t\tunsettledRemote,\n\t\t\t\t)),\n\t\t\t},\n\t\t\tPendingOpenLocalBalance:  &lnrpc.Amount{},\n\t\t\tPendingOpenRemoteBalance: &lnrpc.Amount{},\n\t\t\t// Deprecated fields.\n\t\t\tBalance: int64(local),\n\t\t}\n\t\tht.AssertChannelBalanceResp(node, expectedResponse)\n\t}\n\n\t// Create carol in hodl mode.\n\tcarol := ht.NewNode(\"Carol\", []string{\"--hodl.exit-settle\"})\n\n\t// Connect Alice to Carol.\n\talice := ht.Alice\n\tht.ConnectNodes(alice, carol)\n\n\t// Open a channel between Alice and Carol.\n\tchanPointAlice := ht.OpenChannel(\n\t\talice, carol, lntest.OpenChannelParams{Amt: chanAmt},\n\t)\n\tcType := ht.GetChannelCommitType(alice, chanPointAlice)\n\n\t// Check alice's channel balance, which should have zero remote and zero\n\t// pending balance.\n\tcheckChannelBalance(\n\t\talice, chanAmt-lntest.CalcStaticFee(cType, 0), 0, 0, 0,\n\t)\n\n\t// Check carol's channel balance, which should have zero local and zero\n\t// pending balance.\n\tcheckChannelBalance(\n\t\tcarol, 0, chanAmt-lntest.CalcStaticFee(cType, 0), 0, 0,\n\t)\n\n\t// Channel should be ready for payments.\n\tconst (\n\t\tpayAmt      = 100\n\t\tnumInvoices = 6\n\t)\n\n\t// Simulateneously send numInvoices payments from Alice to Carol.\n\tfor i := 0; i < numInvoices; i++ {\n\t\tgo func() {\n\t\t\treq := &routerrpc.SendPaymentRequest{\n\t\t\t\tDest:           carol.PubKey[:],\n\t\t\t\tAmt:            int64(payAmt),\n\t\t\t\tPaymentHash:    ht.Random32Bytes(),\n\t\t\t\tFinalCltvDelta: finalCltvDelta,\n\t\t\t\tTimeoutSeconds: 60,\n\t\t\t\tFeeLimitMsat:   noFeeLimitMsat,\n\t\t\t}\n\t\t\talice.RPC.SendPayment(req)\n\t\t}()\n\t}\n\n\t// There should be a number of PendingHtlcs equal\n\t// to the amount of Invoices sent.\n\tht.AssertNumActiveHtlcs(alice, numInvoices)\n\tht.AssertNumActiveHtlcs(carol, numInvoices)\n\n\t// Set the amount expected for the Unsettled Balance for this channel.\n\texpectedBalance := numInvoices * payAmt\n\n\t// Test that the UnsettledBalance for both Alice and Carol\n\t// is equal to the amount of invoices * payAmt.\n\tcheckUnsettledBalance := func() error {\n\t\t// Get channel info for the Alice.\n\t\tchanInfo := ht.QueryChannelByChanPoint(alice, chanPointAlice)\n\n\t\t// Check that UnsettledBalance is what we expect.\n\t\tif int(chanInfo.UnsettledBalance) != expectedBalance {\n\t\t\treturn fmt.Errorf(\"unsettled balance failed \"+\n\t\t\t\t\"expected: %v, received: %v\", expectedBalance,\n\t\t\t\tchanInfo.UnsettledBalance)\n\t\t}\n\n\t\t// Get channel info for the Carol.\n\t\tchanInfo = ht.QueryChannelByChanPoint(carol, chanPointAlice)\n\n\t\t// Check that UnsettledBalance is what we expect.\n\t\tif int(chanInfo.UnsettledBalance) != expectedBalance {\n\t\t\treturn fmt.Errorf(\"unsettled balance failed \"+\n\t\t\t\t\"expected: %v, received: %v\", expectedBalance,\n\t\t\t\tchanInfo.UnsettledBalance)\n\t\t}\n\n\t\treturn nil\n\t}\n\trequire.NoError(ht, wait.NoError(checkUnsettledBalance, defaultTimeout),\n\t\t\"timeout while checking unsettled balance\")\n\n\t// Check alice's channel balance, which should have a remote unsettled\n\t// balance that equals to the amount of invoices * payAmt. The remote\n\t// balance remains zero.\n\tfee := lntest.CalcStaticFee(cType, 0)\n\taliceLocal := chanAmt - fee - numInvoices*payAmt\n\tcheckChannelBalance(alice, aliceLocal, 0, 0, numInvoices*payAmt)\n\n\t// Check carol's channel balance, which should have a local unsettled\n\t// balance that equals to the amount of invoices * payAmt. The local\n\t// balance remains zero.\n\tcheckChannelBalance(carol, 0, aliceLocal, numInvoices*payAmt, 0)\n\n\t// Force and assert the channel closure.\n\tht.ForceCloseChannel(alice, chanPointAlice)\n}\n",
      "length": 4114,
      "tokens": 460,
      "embedding": []
    }
  ]
}