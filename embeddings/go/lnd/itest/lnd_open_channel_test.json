{
  "filepath": "../implementations/go/lnd/itest/lnd_open_channel_test.go",
  "package": "itest",
  "sections": [
    {
      "slug": "func testOpenChannelAfterReorg(ht *lntest.HarnessTest) {",
      "content": "func testOpenChannelAfterReorg(ht *lntest.HarnessTest) {\n\t// Skip test for neutrino, as we cannot disconnect the miner at will.\n\t// TODO(halseth): remove when either can disconnect at will, or restart\n\t// node with connection to new miner.\n\tif ht.IsNeutrinoBackend() {\n\t\tht.Skipf(\"skipping reorg test for neutrino backend\")\n\t}\n\n\ttemp := \"temp\"\n\n\t// Set up a new miner that we can use to cause a reorg.\n\ttempLogDir := \".tempminerlogs\"\n\tlogFilename := \"output-open_channel_reorg-temp_miner.log\"\n\ttempMiner := lntest.NewTempMiner(\n\t\tht.Context(), ht.T, tempLogDir, logFilename,\n\t)\n\tdefer tempMiner.Stop()\n\n\t// Setup the temp miner\n\trequire.NoError(ht, tempMiner.SetUp(false, 0),\n\t\t\"unable to set up mining node\")\n\n\tminer := ht.Miner\n\talice, bob := ht.Alice, ht.Bob\n\n\t// We start by connecting the new miner to our original miner,\n\t// such that it will sync to our original chain.\n\terr := miner.Client.Node(\n\t\tbtcjson.NConnect, tempMiner.P2PAddress(), &temp,\n\t)\n\trequire.NoError(ht, err, \"unable to connect miners\")\n\n\tnodeSlice := []*rpctest.Harness{miner.Harness, tempMiner.Harness}\n\terr = rpctest.JoinNodes(nodeSlice, rpctest.Blocks)\n\trequire.NoError(ht, err, \"unable to join node on blocks\")\n\n\t// The two miners should be on the same blockheight.\n\tassertMinerBlockHeightDelta(ht, miner, tempMiner, 0)\n\n\t// We disconnect the two miners, such that we can mine two different\n\t// chains and can cause a reorg later.\n\terr = miner.Client.Node(\n\t\tbtcjson.NDisconnect, tempMiner.P2PAddress(), &temp,\n\t)\n\trequire.NoError(ht, err, \"unable to disconnect miners\")\n\n\t// Create a new channel that requires 1 confs before it's considered\n\t// open, then broadcast the funding transaction\n\tparams := lntest.OpenChannelParams{\n\t\tAmt:     funding.MaxBtcFundingAmount,\n\t\tPrivate: true,\n\t}\n\tpendingUpdate := ht.OpenChannelAssertPending(alice, bob, params)\n\n\t// Wait for miner to have seen the funding tx. The temporary miner is\n\t// disconnected, and won't see the transaction.\n\tht.Miner.AssertNumTxsInMempool(1)\n\n\t// At this point, the channel's funding transaction will have been\n\t// broadcast, but not confirmed, and the channel should be pending.\n\tht.AssertNodesNumPendingOpenChannels(alice, bob, 1)\n\n\tfundingTxID, err := chainhash.NewHash(pendingUpdate.Txid)\n\trequire.NoError(ht, err, \"convert funding txid into chainhash failed\")\n\n\t// We now cause a fork, by letting our original miner mine 10 blocks,\n\t// and our new miner mine 15. This will also confirm our pending\n\t// channel on the original miner's chain, which should be considered\n\t// open.\n\tblock := ht.MineBlocks(10)[0]\n\tht.Miner.AssertTxInBlock(block, fundingTxID)\n\t_, err = tempMiner.Client.Generate(15)\n\trequire.NoError(ht, err, \"unable to generate blocks\")\n\n\t// Ensure the chain lengths are what we expect, with the temp miner\n\t// being 5 blocks ahead.\n\tassertMinerBlockHeightDelta(ht, miner, tempMiner, 5)\n\n\tchanPoint := &lnrpc.ChannelPoint{\n\t\tFundingTxid: &lnrpc.ChannelPoint_FundingTxidBytes{\n\t\t\tFundingTxidBytes: pendingUpdate.Txid,\n\t\t},\n\t\tOutputIndex: pendingUpdate.OutputIndex,\n\t}\n\n\t// Ensure channel is no longer pending.\n\tht.AssertNodesNumPendingOpenChannels(alice, bob, 0)\n\n\t// Wait for Alice and Bob to recognize and advertise the new channel\n\t// generated above.\n\tht.AssertTopologyChannelOpen(alice, chanPoint)\n\tht.AssertTopologyChannelOpen(bob, chanPoint)\n\n\t// Alice should now have 1 edge in her graph.\n\tht.AssertNumEdges(alice, 1, true)\n\n\t// Now we disconnect Alice's chain backend from the original miner, and\n\t// connect the two miners together. Since the temporary miner knows\n\t// about a longer chain, both miners should sync to that chain.\n\tht.DisconnectMiner()\n\n\t// Connecting to the temporary miner should now cause our original\n\t// chain to be re-orged out.\n\terr = miner.Client.Node(btcjson.NConnect, tempMiner.P2PAddress(), &temp)\n\trequire.NoError(ht, err, \"unable to connect temp miner\")\n\n\tnodes := []*rpctest.Harness{tempMiner.Harness, miner.Harness}\n\terr = rpctest.JoinNodes(nodes, rpctest.Blocks)\n\trequire.NoError(ht, err, \"unable to join node on blocks\")\n\n\t// Once again they should be on the same chain.\n\tassertMinerBlockHeightDelta(ht, miner, tempMiner, 0)\n\n\t// Now we disconnect the two miners, and connect our original miner to\n\t// our chain backend once again.\n\terr = miner.Client.Node(\n\t\tbtcjson.NDisconnect, tempMiner.P2PAddress(), &temp,\n\t)\n\trequire.NoError(ht, err, \"unable to disconnect temp miner\")\n\n\tht.ConnectMiner()\n\n\t// This should have caused a reorg, and Alice should sync to the longer\n\t// chain, where the funding transaction is not confirmed.\n\t_, tempMinerHeight, err := tempMiner.Client.GetBestBlock()\n\trequire.NoError(ht, err, \"unable to get current blockheight\")\n\tht.WaitForNodeBlockHeight(alice, tempMinerHeight)\n\n\t// Since the fundingtx was reorged out, Alice should now have no edges\n\t// in her graph.\n\tht.AssertNumEdges(alice, 0, true)\n\n\t// Cleanup by mining the funding tx again, then closing the channel.\n\tblock = ht.MineBlocksAndAssertNumTxes(1, 1)[0]\n\tht.Miner.AssertTxInBlock(block, fundingTxID)\n\n\tht.CloseChannel(alice, chanPoint)\n}\n\n// testOpenChannelFeePolicy checks if different channel fee scenarios\n// are correctly handled when the optional channel fee parameters\n// baseFee and feeRate are provided. If the OpenChannelRequest is not\n// provided with a value for baseFee/feeRate the expectation is that the\n// default baseFee/feeRate is applied.\n// 1.) no params provided to OpenChannelRequest\n// ChannelUpdate --> defaultBaseFee, defaultFeeRate\n// 2.) only baseFee provided to OpenChannelRequest\n// ChannelUpdate --> provided baseFee, defaultFeeRate\n// 3.) only feeRate provided to OpenChannelRequest\n// ChannelUpdate --> defaultBaseFee, provided FeeRate\n// 4.) baseFee and feeRate provided to OpenChannelRequest\n// ChannelUpdate --> provided baseFee, provided feeRate.",
      "length": 5576,
      "tokens": 723,
      "embedding": []
    },
    {
      "slug": "func testOpenChannelUpdateFeePolicy(ht *lntest.HarnessTest) {",
      "content": "func testOpenChannelUpdateFeePolicy(ht *lntest.HarnessTest) {\n\tconst (\n\t\tdefaultBaseFee       = 1000\n\t\tdefaultFeeRate       = 1\n\t\tdefaultTimeLockDelta = chainreg.DefaultBitcoinTimeLockDelta\n\t\tdefaultMinHtlc       = 1000\n\t\toptionalBaseFee      = 1337\n\t\toptionalFeeRate      = 1337\n\t)\n\n\tdefaultMaxHtlc := lntest.CalculateMaxHtlc(funding.MaxBtcFundingAmount)\n\n\tchanAmt := funding.MaxBtcFundingAmount\n\tpushAmt := chanAmt / 2\n\n\tfeeScenarios := []lntest.OpenChannelParams{\n\t\t{\n\t\t\tAmt:        chanAmt,\n\t\t\tPushAmt:    pushAmt,\n\t\t\tUseBaseFee: false,\n\t\t\tUseFeeRate: false,\n\t\t},\n\t\t{\n\t\t\tAmt:        chanAmt,\n\t\t\tPushAmt:    pushAmt,\n\t\t\tBaseFee:    optionalBaseFee,\n\t\t\tUseBaseFee: true,\n\t\t\tUseFeeRate: false,\n\t\t},\n\t\t{\n\t\t\tAmt:        chanAmt,\n\t\t\tPushAmt:    pushAmt,\n\t\t\tFeeRate:    optionalFeeRate,\n\t\t\tUseBaseFee: false,\n\t\t\tUseFeeRate: true,\n\t\t},\n\t\t{\n\t\t\tAmt:        chanAmt,\n\t\t\tPushAmt:    pushAmt,\n\t\t\tBaseFee:    optionalBaseFee,\n\t\t\tFeeRate:    optionalFeeRate,\n\t\t\tUseBaseFee: true,\n\t\t\tUseFeeRate: true,\n\t\t},\n\t}\n\n\texpectedPolicies := []lnrpc.RoutingPolicy{\n\t\t{\n\t\t\tFeeBaseMsat:      defaultBaseFee,\n\t\t\tFeeRateMilliMsat: defaultFeeRate,\n\t\t\tTimeLockDelta:    defaultTimeLockDelta,\n\t\t\tMinHtlc:          defaultMinHtlc,\n\t\t\tMaxHtlcMsat:      defaultMaxHtlc,\n\t\t},\n\t\t{\n\t\t\tFeeBaseMsat:      optionalBaseFee,\n\t\t\tFeeRateMilliMsat: defaultFeeRate,\n\t\t\tTimeLockDelta:    defaultTimeLockDelta,\n\t\t\tMinHtlc:          defaultMinHtlc,\n\t\t\tMaxHtlcMsat:      defaultMaxHtlc,\n\t\t},\n\t\t{\n\t\t\tFeeBaseMsat:      defaultBaseFee,\n\t\t\tFeeRateMilliMsat: optionalFeeRate,\n\t\t\tTimeLockDelta:    defaultTimeLockDelta,\n\t\t\tMinHtlc:          defaultMinHtlc,\n\t\t\tMaxHtlcMsat:      defaultMaxHtlc,\n\t\t},\n\t\t{\n\t\t\tFeeBaseMsat:      optionalBaseFee,\n\t\t\tFeeRateMilliMsat: optionalFeeRate,\n\t\t\tTimeLockDelta:    defaultTimeLockDelta,\n\t\t\tMinHtlc:          defaultMinHtlc,\n\t\t\tMaxHtlcMsat:      defaultMaxHtlc,\n\t\t},\n\t}\n\n\tbobExpectedPolicy := lnrpc.RoutingPolicy{\n\t\tFeeBaseMsat:      defaultBaseFee,\n\t\tFeeRateMilliMsat: defaultFeeRate,\n\t\tTimeLockDelta:    defaultTimeLockDelta,\n\t\tMinHtlc:          defaultMinHtlc,\n\t\tMaxHtlcMsat:      defaultMaxHtlc,\n\t}\n\n\talice, bob := ht.Alice, ht.Bob\n\n\trunTestCase := func(ht *lntest.HarnessTest,\n\t\tfs lntest.OpenChannelParams,\n\t\talicePolicy, bobPolicy *lnrpc.RoutingPolicy) {\n\n\t\t// Create a channel Alice->Bob.\n\t\tchanPoint := ht.OpenChannel(alice, bob, fs)\n\t\tdefer ht.CloseChannel(alice, chanPoint)\n\n\t\t// We add all the nodes' update channels to a slice, such that\n\t\t// we can make sure they all receive the expected updates.\n\t\tnodes := []*node.HarnessNode{alice, bob}\n\n\t\t// Alice and Bob should see each other's ChannelUpdates,\n\t\t// advertising the preferred routing policies.\n\t\tassertNodesPolicyUpdate(\n\t\t\tht, nodes, alice, alicePolicy, chanPoint,\n\t\t)\n\t\tassertNodesPolicyUpdate(ht, nodes, bob, bobPolicy, chanPoint)\n\n\t\t// They should now know about the default policies.\n\t\tfor _, node := range nodes {\n\t\t\tht.AssertChannelPolicy(\n\t\t\t\tnode, alice.PubKeyStr, alicePolicy, chanPoint,\n\t\t\t)\n\t\t\tht.AssertChannelPolicy(\n\t\t\t\tnode, bob.PubKeyStr, bobPolicy, chanPoint,\n\t\t\t)\n\t\t}\n\t}\n\n\tfor i, feeScenario := range feeScenarios {\n\t\tht.Run(fmt.Sprintf(\"%d\", i), func(t *testing.T) {\n\t\t\tst := ht.Subtest(t)\n\t\t\tht.EnsureConnected(alice, bob)\n\n\t\t\trunTestCase(\n\t\t\t\tst, feeScenario,\n\t\t\t\t&expectedPolicies[i], &bobExpectedPolicy,\n\t\t\t)\n\t\t})\n\t}\n}\n\n// testBasicChannelCreationAndUpdates tests multiple channel opening and\n// closing, and ensures that if a node is subscribed to channel updates they\n// will be received correctly for both cooperative and force closed channels.",
      "length": 3327,
      "tokens": 322,
      "embedding": []
    },
    {
      "slug": "func testBasicChannelCreationAndUpdates(ht *lntest.HarnessTest) {",
      "content": "func testBasicChannelCreationAndUpdates(ht *lntest.HarnessTest) {\n\trunBasicChannelCreationAndUpdates(ht, ht.Alice, ht.Bob)\n}\n\n// runBasicChannelCreationAndUpdates tests multiple channel opening and closing,\n// and ensures that if a node is subscribed to channel updates they will be\n// received correctly for both cooperative and force closed channels.",
      "length": 281,
      "tokens": 37,
      "embedding": []
    },
    {
      "slug": "func runBasicChannelCreationAndUpdates(ht *lntest.HarnessTest,",
      "content": "func runBasicChannelCreationAndUpdates(ht *lntest.HarnessTest,\n\talice, bob *node.HarnessNode) {\n\n\tconst (\n\t\tnumChannels = 2\n\t\tamount      = funding.MaxBtcFundingAmount\n\t)\n\n\t// Subscribe Bob and Alice to channel event notifications.\n\tbobChanSub := bob.RPC.SubscribeChannelEvents()\n\taliceChanSub := alice.RPC.SubscribeChannelEvents()\n\n\t// Open the channels between Alice and Bob, asserting that the channels\n\t// have been properly opened on-chain.\n\tchanPoints := make([]*lnrpc.ChannelPoint, numChannels)\n\tfor i := 0; i < numChannels; i++ {\n\t\tchanPoints[i] = ht.OpenChannel(\n\t\t\talice, bob, lntest.OpenChannelParams{\n\t\t\t\tAmt: amount,\n\t\t\t},\n\t\t)\n\t}\n\n\t// Since each of the channels just became open, Bob and Alice should\n\t// each receive an open and an active notification for each channel.\n\tconst numExpectedOpenUpdates = 3 * numChannels\n\tverifyOpenUpdatesReceived := func(sub rpc.ChannelEventsClient) error {\n\t\tfor i := 0; i < numExpectedOpenUpdates; i++ {\n\t\t\tupdate := ht.ReceiveChannelEvent(sub)\n\n\t\t\tswitch update.Type {\n\t\t\tcase lnrpc.ChannelEventUpdate_PENDING_OPEN_CHANNEL:\n\t\t\t\tif i%3 == 0 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\treturn fmt.Errorf(\"expected open or active\" +\n\t\t\t\t\t\"channel ntfn, got pending open \" +\n\t\t\t\t\t\"channel ntfn instead\")\n\n\t\t\tcase lnrpc.ChannelEventUpdate_OPEN_CHANNEL:\n\t\t\t\tif i%3 == 1 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\treturn fmt.Errorf(\"expected pending open or \" +\n\t\t\t\t\t\"active channel ntfn, got open\" +\n\t\t\t\t\t\"channel ntfn instead\")\n\n\t\t\tcase lnrpc.ChannelEventUpdate_ACTIVE_CHANNEL:\n\t\t\t\tif i%3 == 2 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\treturn fmt.Errorf(\"expected pending open or \" +\n\t\t\t\t\t\"open channel ntfn, got active \" +\n\t\t\t\t\t\"channel ntfn instead\")\n\n\t\t\tdefault:\n\t\t\t\treturn fmt.Errorf(\"update type mismatch: \"+\n\t\t\t\t\t\"expected open or active channel \"+\n\t\t\t\t\t\"notification, got: %v\", update.Type)\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}\n\n\trequire.NoError(ht, verifyOpenUpdatesReceived(bobChanSub),\n\t\t\"bob open channels\")\n\trequire.NoError(ht, verifyOpenUpdatesReceived(aliceChanSub),\n\t\t\"alice open channels\")\n\n\t// Close the channels between Alice and Bob, asserting that the\n\t// channels have been properly closed on-chain.\n\tfor i, chanPoint := range chanPoints {\n\t\t// Force close the first of the two channels.\n\t\tforce := i%2 == 0\n\t\tif force {\n\t\t\tht.ForceCloseChannel(alice, chanPoint)\n\t\t} else {\n\t\t\tht.CloseChannel(alice, chanPoint)\n\t\t}\n\t}\n\n\t// verifyCloseUpdatesReceived is used to verify that Alice and Bob\n\t// receive the correct channel updates in order.\n\tconst numExpectedCloseUpdates = 3 * numChannels\n\tverifyCloseUpdatesReceived := func(sub rpc.ChannelEventsClient,\n\t\tforceType lnrpc.ChannelCloseSummary_ClosureType,\n\t\tcloseInitiator lnrpc.Initiator) error {\n\n\t\t// Ensure one inactive and one closed notification is received\n\t\t// for each closed channel.\n\t\tfor i := 0; i < numExpectedCloseUpdates; i++ {\n\t\t\texpectedCloseType := lnrpc.\n\t\t\t\tChannelCloseSummary_COOPERATIVE_CLOSE\n\n\t\t\t// Every other channel should be force closed. If this\n\t\t\t// channel was force closed, set the expected close type\n\t\t\t// to the type passed in.\n\t\t\tforce := (i/3)%2 == 0\n\t\t\tif force {\n\t\t\t\texpectedCloseType = forceType\n\t\t\t}\n\n\t\t\tchanUpdate := ht.ReceiveChannelEvent(sub)\n\t\t\terr := verifyCloseUpdate(\n\t\t\t\tchanUpdate, expectedCloseType,\n\t\t\t\tcloseInitiator,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}\n\n\t// Verify Bob receives all closed channel notifications. He should\n\t// receive a remote force close notification for force closed channels.\n\t// All channels (cooperatively and force closed) should have a remote\n\t// close initiator because Alice closed the channels.\n\trequire.NoError(\n\t\tht, verifyCloseUpdatesReceived(\n\t\t\tbobChanSub,\n\t\t\tlnrpc.ChannelCloseSummary_REMOTE_FORCE_CLOSE,\n\t\t\tlnrpc.Initiator_INITIATOR_REMOTE,\n\t\t), \"verifying bob close updates\",\n\t)\n\n\t// Verify Alice receives all closed channel notifications. She should\n\t// receive a remote force close notification for force closed channels.\n\t// All channels (cooperatively and force closed) should have a local\n\t// close initiator because Alice closed the channels.\n\trequire.NoError(\n\t\tht, verifyCloseUpdatesReceived(\n\t\t\taliceChanSub,\n\t\t\tlnrpc.ChannelCloseSummary_LOCAL_FORCE_CLOSE,\n\t\t\tlnrpc.Initiator_INITIATOR_LOCAL,\n\t\t), \"verifying alice close updates\",\n\t)\n}\n\n// assertMinerBlockHeightDelta ensures that tempMiner is 'delta' blocks ahead\n// of miner.",
      "length": 4099,
      "tokens": 519,
      "embedding": []
    },
    {
      "slug": "func assertMinerBlockHeightDelta(ht *lntest.HarnessTest,",
      "content": "func assertMinerBlockHeightDelta(ht *lntest.HarnessTest,\n\tminer, tempMiner *lntest.HarnessMiner, delta int32) {\n\n\t// Ensure the chain lengths are what we expect.\n\terr := wait.NoError(func() error {\n\t\t_, tempMinerHeight, err := tempMiner.Client.GetBestBlock()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to get current \"+\n\t\t\t\t\"blockheight %v\", err)\n\t\t}\n\n\t\t_, minerHeight, err := miner.Client.GetBestBlock()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to get current \"+\n\t\t\t\t\"blockheight %v\", err)\n\t\t}\n\n\t\tif tempMinerHeight != minerHeight+delta {\n\t\t\treturn fmt.Errorf(\"expected new miner(%d) to be %d \"+\n\t\t\t\t\"blocks ahead of original miner(%d)\",\n\t\t\t\ttempMinerHeight, delta, minerHeight)\n\t\t}\n\n\t\treturn nil\n\t}, defaultTimeout)\n\trequire.NoError(ht, err, \"failed to assert block height delta\")\n}\n\n// verifyCloseUpdate is used to verify that a closed channel update is of the\n// expected type.",
      "length": 806,
      "tokens": 112,
      "embedding": []
    },
    {
      "slug": "func verifyCloseUpdate(chanUpdate *lnrpc.ChannelEventUpdate,",
      "content": "func verifyCloseUpdate(chanUpdate *lnrpc.ChannelEventUpdate,\n\tcloseType lnrpc.ChannelCloseSummary_ClosureType,\n\tcloseInitiator lnrpc.Initiator) error {\n\n\t// We should receive one inactive and one closed notification\n\t// for each channel.\n\tswitch update := chanUpdate.Channel.(type) {\n\tcase *lnrpc.ChannelEventUpdate_InactiveChannel:\n\t\tif chanUpdate.Type !=\n\t\t\tlnrpc.ChannelEventUpdate_INACTIVE_CHANNEL {\n\n\t\t\treturn fmt.Errorf(\"update type mismatch: \"+\n\t\t\t\t\"expected %v, got %v\",\n\t\t\t\tlnrpc.ChannelEventUpdate_INACTIVE_CHANNEL,\n\t\t\t\tchanUpdate.Type)\n\t\t}\n\n\tcase *lnrpc.ChannelEventUpdate_ClosedChannel:\n\t\tif chanUpdate.Type !=\n\t\t\tlnrpc.ChannelEventUpdate_CLOSED_CHANNEL {\n\n\t\t\treturn fmt.Errorf(\"update type mismatch: \"+\n\t\t\t\t\"expected %v, got %v\",\n\t\t\t\tlnrpc.ChannelEventUpdate_CLOSED_CHANNEL,\n\t\t\t\tchanUpdate.Type)\n\t\t}\n\n\t\tif update.ClosedChannel.CloseType != closeType {\n\t\t\treturn fmt.Errorf(\"channel closure type \"+\n\t\t\t\t\"mismatch: expected %v, got %v\",\n\t\t\t\tcloseType,\n\t\t\t\tupdate.ClosedChannel.CloseType)\n\t\t}\n\n\t\tif update.ClosedChannel.CloseInitiator != closeInitiator {\n\t\t\treturn fmt.Errorf(\"expected close intiator: %v, \"+\n\t\t\t\t\"got: %v\", closeInitiator,\n\t\t\t\tupdate.ClosedChannel.CloseInitiator)\n\t\t}\n\n\tcase *lnrpc.ChannelEventUpdate_FullyResolvedChannel:\n\t\tif chanUpdate.Type !=\n\t\t\tlnrpc.ChannelEventUpdate_FULLY_RESOLVED_CHANNEL {\n\n\t\t\treturn fmt.Errorf(\"update type mismatch: \"+\n\t\t\t\t\"expected %v, got %v\",\n\t\t\t\tlnrpc.ChannelEventUpdate_FULLY_RESOLVED_CHANNEL,\n\t\t\t\tchanUpdate.Type)\n\t\t}\n\n\tdefault:\n\t\treturn fmt.Errorf(\"channel update channel of wrong type, \"+\n\t\t\t\"expected closed channel, got %T\",\n\t\t\tupdate)\n\t}\n\n\treturn nil\n}\n",
      "length": 1502,
      "tokens": 135,
      "embedding": []
    }
  ]
}