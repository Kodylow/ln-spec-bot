{
  "filepath": "../implementations/go/lnd/itest/lnd_multi-hop_test.go",
  "package": "itest",
  "sections": [
    {
      "slug": "type caseRunner func(ht *lntest.HarnessTest, alice, bob *node.HarnessNode,",
      "content": "type caseRunner func(ht *lntest.HarnessTest, alice, bob *node.HarnessNode,\n\tc lnrpc.CommitmentType, zeroConf bool)\n\n// runMultiHopHtlcClaimTest is a helper method to build test cases based on\n// different commitment types and zero-conf config and run them.",
      "length": 178,
      "tokens": 26,
      "embedding": []
    },
    {
      "slug": "func runMultiHopHtlcClaimTest(ht *lntest.HarnessTest, tester caseRunner) {",
      "content": "func runMultiHopHtlcClaimTest(ht *lntest.HarnessTest, tester caseRunner) {\n\tfor _, typeAndConf := range commitWithZeroConf {\n\t\ttypeAndConf := typeAndConf\n\t\tname := fmt.Sprintf(\"zeroconf=%v/committype=%v\",\n\t\t\ttypeAndConf.zeroConf, typeAndConf.commitType.String())\n\n\t\t// Create the nodes here so that separate logs will be created\n\t\t// for Alice and Bob.\n\t\targs := lntest.NodeArgsForCommitType(typeAndConf.commitType)\n\t\tif typeAndConf.zeroConf {\n\t\t\targs = append(\n\t\t\t\targs, \"--protocol.option-scid-alias\",\n\t\t\t\t\"--protocol.zero-conf\",\n\t\t\t)\n\t\t}\n\n\t\ts := ht.Run(name, func(t1 *testing.T) {\n\t\t\tst := ht.Subtest(t1)\n\n\t\t\talice := st.NewNode(\"Alice\", args)\n\t\t\tbob := st.NewNode(\"Bob\", args)\n\t\t\tst.ConnectNodes(alice, bob)\n\n\t\t\t// Start each test with the default static fee estimate.\n\t\t\tst.SetFeeEstimate(12500)\n\n\t\t\t// Add test name to the logs.\n\t\t\talice.AddToLogf(\"Running test case: %s\", name)\n\t\t\tbob.AddToLogf(\"Running test case: %s\", name)\n\n\t\t\ttester(\n\t\t\t\tst, alice, bob,\n\t\t\t\ttypeAndConf.commitType, typeAndConf.zeroConf,\n\t\t\t)\n\t\t})\n\t\tif !s {\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// testMultiHopHtlcLocalTimeout tests that in a multi-hop HTLC scenario, if the\n// outgoing HTLC is about to time out, then we'll go to chain in order to claim\n// it using the HTLC timeout transaction. Any dust HTLC's should be immediately\n// canceled backwards. Once the timeout has been reached, then we should sweep\n// it on-chain, and cancel the HTLC backwards.",
      "length": 1301,
      "tokens": 170,
      "embedding": []
    },
    {
      "slug": "func testMultiHopHtlcLocalTimeout(ht *lntest.HarnessTest) {",
      "content": "func testMultiHopHtlcLocalTimeout(ht *lntest.HarnessTest) {\n\trunMultiHopHtlcClaimTest(ht, runMultiHopHtlcLocalTimeout)\n}\n",
      "length": 59,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func runMultiHopHtlcLocalTimeout(ht *lntest.HarnessTest,",
      "content": "func runMultiHopHtlcLocalTimeout(ht *lntest.HarnessTest,\n\talice, bob *node.HarnessNode, c lnrpc.CommitmentType, zeroConf bool) {\n\n\t// First, we'll create a three hop network: Alice -> Bob -> Carol, with\n\t// Carol refusing to actually settle or directly cancel any HTLC's\n\t// self.\n\taliceChanPoint, bobChanPoint, carol := createThreeHopNetwork(\n\t\tht, alice, bob, true, c, zeroConf,\n\t)\n\n\t// Now that our channels are set up, we'll send two HTLC's from Alice\n\t// to Carol. The first HTLC will be universally considered \"dust\",\n\t// while the second will be a proper fully valued HTLC.\n\tconst (\n\t\tdustHtlcAmt = btcutil.Amount(100)\n\t\thtlcAmt     = btcutil.Amount(300_000)\n\t)\n\n\t// We'll create two random payment hashes unknown to carol, then send\n\t// each of them by manually specifying the HTLC details.\n\tcarolPubKey := carol.PubKey[:]\n\tdustPayHash := ht.Random32Bytes()\n\tpayHash := ht.Random32Bytes()\n\n\talice.RPC.SendPayment(&routerrpc.SendPaymentRequest{\n\t\tDest:           carolPubKey,\n\t\tAmt:            int64(dustHtlcAmt),\n\t\tPaymentHash:    dustPayHash,\n\t\tFinalCltvDelta: finalCltvDelta,\n\t\tTimeoutSeconds: 60,\n\t\tFeeLimitMsat:   noFeeLimitMsat,\n\t})\n\n\talice.RPC.SendPayment(&routerrpc.SendPaymentRequest{\n\t\tDest:           carolPubKey,\n\t\tAmt:            int64(htlcAmt),\n\t\tPaymentHash:    payHash,\n\t\tFinalCltvDelta: finalCltvDelta,\n\t\tTimeoutSeconds: 60,\n\t\tFeeLimitMsat:   noFeeLimitMsat,\n\t})\n\n\t// Verify that all nodes in the path now have two HTLC's with the\n\t// proper parameters.\n\tht.AssertActiveHtlcs(alice, dustPayHash, payHash)\n\tht.AssertActiveHtlcs(bob, dustPayHash, payHash)\n\tht.AssertActiveHtlcs(carol, dustPayHash, payHash)\n\n\t// Increase the fee estimate so that the following force close tx will\n\t// be cpfp'ed.\n\tht.SetFeeEstimate(30000)\n\n\t// We'll now mine enough blocks to trigger Bob's broadcast of his\n\t// commitment transaction due to the fact that the HTLC is about to\n\t// timeout. With the default outgoing broadcast delta of zero, this will\n\t// be the same height as the htlc expiry height.\n\tnumBlocks := padCLTV(\n\t\tuint32(finalCltvDelta - lncfg.DefaultOutgoingBroadcastDelta),\n\t)\n\tht.MineBlocks(numBlocks)\n\n\t// Bob's force close transaction should now be found in the mempool. If\n\t// there are anchors, we also expect Bob's anchor sweep.\n\texpectedTxes := 1\n\thasAnchors := lntest.CommitTypeHasAnchors(c)\n\tif hasAnchors {\n\t\texpectedTxes = 2\n\t}\n\tht.Miner.AssertNumTxsInMempool(expectedTxes)\n\n\top := ht.OutPointFromChannelPoint(bobChanPoint)\n\tcloseTx := ht.Miner.AssertOutpointInMempool(op)\n\n\t// Mine a block to confirm the closing transaction.\n\tht.MineBlocksAndAssertNumTxes(1, expectedTxes)\n\n\t// At this point, Bob should have canceled backwards the dust HTLC\n\t// that we sent earlier. This means Alice should now only have a single\n\t// HTLC on her channel.\n\tht.AssertActiveHtlcs(alice, payHash)\n\n\t// With the closing transaction confirmed, we should expect Bob's HTLC\n\t// timeout transaction to be broadcast due to the expiry being reached.\n\t// If there are anchors, we also expect Carol's anchor sweep now.\n\tht.Miner.AssertNumTxsInMempool(expectedTxes)\n\n\t// We'll also obtain the expected HTLC timeout transaction hash.\n\thtlcOutpoint := wire.OutPoint{Hash: closeTx.TxHash(), Index: 0}\n\tcommitOutpoint := wire.OutPoint{Hash: closeTx.TxHash(), Index: 1}\n\tif hasAnchors {\n\t\thtlcOutpoint.Index = 2\n\t\tcommitOutpoint.Index = 3\n\t}\n\thtlcTimeoutTxid := ht.Miner.AssertOutpointInMempool(\n\t\thtlcOutpoint,\n\t).TxHash()\n\n\t// Mine a block to confirm the expected transactions.\n\tht.MineBlocksAndAssertNumTxes(1, expectedTxes)\n\n\t// With Bob's HTLC timeout transaction confirmed, there should be no\n\t// active HTLC's on the commitment transaction from Alice -> Bob.\n\tht.AssertNumActiveHtlcs(alice, 0)\n\n\t// At this point, Bob should show that the pending HTLC has advanced to\n\t// the second stage and is ready to be swept once the timelock is up.\n\tpendingChanResp := bob.RPC.PendingChannels()\n\trequire.Equal(ht, 1, len(pendingChanResp.PendingForceClosingChannels))\n\tforceCloseChan := pendingChanResp.PendingForceClosingChannels[0]\n\trequire.NotZero(ht, forceCloseChan.LimboBalance)\n\trequire.Positive(ht, forceCloseChan.BlocksTilMaturity)\n\trequire.Equal(ht, 1, len(forceCloseChan.PendingHtlcs))\n\trequire.Equal(ht, uint32(2), forceCloseChan.PendingHtlcs[0].Stage)\n\n\thtlcTimeoutOutpoint := wire.OutPoint{Hash: htlcTimeoutTxid, Index: 0}\n\tif c == lnrpc.CommitmentType_SCRIPT_ENFORCED_LEASE {\n\t\t// Since Bob is the initiator of the script-enforced leased\n\t\t// channel between him and Carol, he will incur an additional\n\t\t// CLTV on top of the usual CSV delay on any outputs that he can\n\t\t// sweep back to his wallet.\n\t\tblocksTilMaturity := uint32(forceCloseChan.BlocksTilMaturity)\n\t\tht.MineBlocks(blocksTilMaturity)\n\n\t\t// Check that the sweep spends the expected inputs.\n\t\tht.Miner.AssertOutpointInMempool(commitOutpoint)\n\t\tht.Miner.AssertOutpointInMempool(htlcTimeoutOutpoint)\n\t} else {\n\t\t// Since Bob force closed the channel between him and Carol, he\n\t\t// will incur the usual CSV delay on any outputs that he can\n\t\t// sweep back to his wallet. We'll subtract one block from our\n\t\t// current maturity period to assert on the mempool.\n\t\tnumBlocks := uint32(forceCloseChan.BlocksTilMaturity - 1)\n\t\tht.MineBlocks(numBlocks)\n\n\t\t// Check that the sweep spends from the mined commitment.\n\t\tht.Miner.AssertOutpointInMempool(commitOutpoint)\n\n\t\t// Mine a block to confirm Bob's commit sweep tx and assert it\n\t\t// was in fact mined.\n\t\tht.MineBlocksAndAssertNumTxes(1, 1)\n\n\t\t// Mine an additional block to prompt Bob to broadcast their\n\t\t// second layer sweep due to the CSV on the HTLC timeout output.\n\t\tht.MineBlocksAndAssertNumTxes(1, 0)\n\t\tht.Miner.AssertOutpointInMempool(htlcTimeoutOutpoint)\n\t}\n\n\t// Next, we'll mine a final block that should confirm the sweeping\n\t// transactions left.\n\tht.MineBlocks(1)\n\n\t// Once this transaction has been confirmed, Bob should detect that he\n\t// no longer has any pending channels.\n\tht.AssertNumPendingForceClose(bob, 0)\n\n\t// Coop close channel, expect no anchors.\n\tht.CloseChannel(alice, aliceChanPoint)\n}\n\n// testMultiHopReceiverChainClaim tests that in the multi-hop setting, if the\n// receiver of an HTLC knows the preimage, but wasn't able to settle the HTLC\n// off-chain, then it goes on chain to claim the HTLC uing the HTLC success\n// transaction. In this scenario, the node that sent the outgoing HTLC should\n// extract the preimage from the sweep transaction, and finish settling the\n// HTLC backwards into the route.",
      "length": 6230,
      "tokens": 792,
      "embedding": []
    },
    {
      "slug": "func testMultiHopReceiverChainClaim(ht *lntest.HarnessTest) {",
      "content": "func testMultiHopReceiverChainClaim(ht *lntest.HarnessTest) {\n\trunMultiHopHtlcClaimTest(ht, runMultiHopReceiverChainClaim)\n}\n",
      "length": 61,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func runMultiHopReceiverChainClaim(ht *lntest.HarnessTest,",
      "content": "func runMultiHopReceiverChainClaim(ht *lntest.HarnessTest,\n\talice, bob *node.HarnessNode, c lnrpc.CommitmentType, zeroConf bool) {\n\n\t// First, we'll create a three hop network: Alice -> Bob -> Carol, with\n\t// Carol refusing to actually settle or directly cancel any HTLC's\n\t// self.\n\taliceChanPoint, bobChanPoint, carol := createThreeHopNetwork(\n\t\tht, alice, bob, false, c, zeroConf,\n\t)\n\n\t// With the network active, we'll now add a new hodl invoice at Carol's\n\t// end. Make sure the cltv expiry delta is large enough, otherwise Bob\n\t// won't send out the outgoing htlc.\n\tconst invoiceAmt = 100000\n\tvar preimage lntypes.Preimage\n\tcopy(preimage[:], ht.Random32Bytes())\n\tpayHash := preimage.Hash()\n\tinvoiceReq := &invoicesrpc.AddHoldInvoiceRequest{\n\t\tValue:      invoiceAmt,\n\t\tCltvExpiry: finalCltvDelta,\n\t\tHash:       payHash[:],\n\t}\n\tcarolInvoice := carol.RPC.AddHoldInvoice(invoiceReq)\n\n\t// Subscribe the invoice.\n\tstream := carol.RPC.SubscribeSingleInvoice(payHash[:])\n\n\t// Now that we've created the invoice, we'll send a single payment from\n\t// Alice to Carol. We won't wait for the response however, as Carol\n\t// will not immediately settle the payment.\n\treq := &routerrpc.SendPaymentRequest{\n\t\tPaymentRequest: carolInvoice.PaymentRequest,\n\t\tTimeoutSeconds: 60,\n\t\tFeeLimitMsat:   noFeeLimitMsat,\n\t}\n\talice.RPC.SendPayment(req)\n\n\t// At this point, all 3 nodes should now have an active channel with\n\t// the created HTLC pending on all of them.\n\tht.AssertActiveHtlcs(alice, payHash[:])\n\tht.AssertActiveHtlcs(bob, payHash[:])\n\tht.AssertActiveHtlcs(carol, payHash[:])\n\n\t// Wait for carol to mark invoice as accepted. There is a small gap to\n\t// bridge between adding the htlc to the channel and executing the exit\n\t// hop logic.\n\tht.AssertInvoiceState(stream, lnrpc.Invoice_ACCEPTED)\n\n\trestartBob := ht.SuspendNode(bob)\n\n\t// Settle invoice. This will just mark the invoice as settled, as there\n\t// is no link anymore to remove the htlc from the commitment tx. For\n\t// this test, it is important to actually settle and not leave the\n\t// invoice in the accepted state, because without a known preimage, the\n\t// channel arbitrator won't go to chain.\n\tcarol.RPC.SettleInvoice(preimage[:])\n\n\t// Increase the fee estimate so that the following force close tx will\n\t// be cpfp'ed.\n\tht.SetFeeEstimate(30000)\n\n\t// Now we'll mine enough blocks to prompt carol to actually go to the\n\t// chain in order to sweep her HTLC since the value is high enough.\n\tnumBlocks := padCLTV(uint32(\n\t\tinvoiceReq.CltvExpiry - lncfg.DefaultIncomingBroadcastDelta,\n\t))\n\tht.MineBlocks(numBlocks)\n\n\t// At this point, Carol should broadcast her active commitment\n\t// transaction in order to go to the chain and sweep her HTLC. If there\n\t// are anchors, Carol also sweeps hers.\n\texpectedTxes := 1\n\thasAnchors := lntest.CommitTypeHasAnchors(c)\n\tif hasAnchors {\n\t\texpectedTxes = 2\n\t}\n\tht.Miner.AssertNumTxsInMempool(expectedTxes)\n\n\tclosingTx := ht.Miner.AssertOutpointInMempool(\n\t\tht.OutPointFromChannelPoint(bobChanPoint),\n\t)\n\tclosingTxid := closingTx.TxHash()\n\n\t// Confirm the commitment.\n\tht.MineBlocksAndAssertNumTxes(1, expectedTxes)\n\n\t// Restart bob again.\n\trequire.NoError(ht, restartBob())\n\n\t// After the force close transaction is mined, a series of transactions\n\t// should be broadcast by Bob and Carol. When Bob notices Carol's second\n\t// level transaction in the mempool, he will extract the preimage and\n\t// settle the HTLC back off-chain.\n\tswitch c {\n\t// Carol should broadcast her second level HTLC transaction and Bob\n\t// should broadcast a sweep tx to sweep his output in the channel with\n\t// Carol.\n\tcase lnrpc.CommitmentType_LEGACY:\n\t\texpectedTxes = 2\n\n\t// Carol should broadcast her second level HTLC transaction and Bob\n\t// should broadcast a sweep tx to sweep his output in the channel with\n\t// Carol, and another sweep tx to sweep his anchor output.\n\tcase lnrpc.CommitmentType_ANCHORS:\n\t\texpectedTxes = 3\n\n\t// Carol should broadcast her second level HTLC transaction and Bob\n\t// should broadcast a sweep tx to sweep his anchor output. Bob's commit\n\t// output can't be swept yet as he's incurring an additional CLTV from\n\t// being the channel initiator of a script-enforced leased channel.\n\tcase lnrpc.CommitmentType_SCRIPT_ENFORCED_LEASE:\n\t\texpectedTxes = 2\n\n\tdefault:\n\t\tht.Fatalf(\"unhandled commitment type %v\", c)\n\t}\n\n\t// All transactions should be spending from the commitment transaction.\n\ttxes := ht.Miner.GetNumTxsFromMempool(expectedTxes)\n\tht.AssertAllTxesSpendFrom(txes, closingTxid)\n\n\t// We'll now mine an additional block which should confirm both the\n\t// second layer transactions.\n\tht.MineBlocks(1)\n\n\t// Carol's pending channel report should now show two outputs under\n\t// limbo: her commitment output, as well as the second-layer claim\n\t// output, and the pending HTLC should also now be in stage 2.\n\tht.AssertNumHTLCsAndStage(carol, bobChanPoint, 1, 2)\n\n\t// Once the second-level transaction confirmed, Bob should have\n\t// extracted the preimage from the chain, and sent it back to Alice,\n\t// clearing the HTLC off-chain.\n\tht.AssertNumActiveHtlcs(alice, 0)\n\n\t// If we mine 4 additional blocks, then Carol can sweep the second level\n\t// HTLC output.\n\tht.MineBlocks(defaultCSV)\n\n\t// We should have a new transaction in the mempool.\n\tht.Miner.AssertNumTxsInMempool(1)\n\n\t// Finally, if we mine an additional block to confirm these two sweep\n\t// transactions, Carol should not show a pending channel in her report\n\t// afterwards.\n\tht.MineBlocks(1)\n\tht.AssertNumPendingForceClose(carol, 0)\n\n\t// The invoice should show as settled for Carol, indicating that it was\n\t// swept on-chain.\n\tht.AssertInvoiceSettled(carol, carolInvoice.PaymentAddr)\n\n\t// Finally, check that the Alice's payment is correctly marked\n\t// succeeded.\n\tht.AssertPaymentStatus(alice, preimage, lnrpc.Payment_SUCCEEDED)\n\n\tif c == lnrpc.CommitmentType_SCRIPT_ENFORCED_LEASE {\n\t\t// Bob still has his commit output to sweep to since he incurred\n\t\t// an additional CLTV from being the channel initiator of a\n\t\t// script-enforced leased channel, regardless of whether he\n\t\t// forced closed the channel or not.\n\t\tpendingChanResp := bob.RPC.PendingChannels()\n\n\t\trequire.Len(ht, pendingChanResp.PendingForceClosingChannels, 1)\n\t\tforceCloseChan := pendingChanResp.PendingForceClosingChannels[0]\n\t\trequire.Positive(ht, forceCloseChan.LimboBalance)\n\t\trequire.Positive(ht, forceCloseChan.BlocksTilMaturity)\n\n\t\t// TODO: Bob still shows a pending HTLC at this point when he\n\t\t// shouldn't, as he already extracted the preimage from Carol's\n\t\t// claim.\n\t\t// require.Len(t.t, forceCloseChan.PendingHtlcs, 0)\n\n\t\t// Mine enough blocks for Bob's commit output's CLTV to expire\n\t\t// and sweep it.\n\t\tnumBlocks := uint32(forceCloseChan.BlocksTilMaturity)\n\t\tht.MineBlocks(numBlocks)\n\t\tcommitOutpoint := wire.OutPoint{Hash: closingTxid, Index: 3}\n\t\tht.Miner.AssertOutpointInMempool(commitOutpoint)\n\t\tht.MineBlocks(1)\n\t}\n\n\tht.AssertNumPendingForceClose(bob, 0)\n\n\t// We'll close out the channel between Alice and Bob, then shutdown\n\t// carol to conclude the test.\n\tht.CloseChannel(alice, aliceChanPoint)\n}\n\n// testMultiHopLocalForceCloseOnChainHtlcTimeout tests that in a multi-hop HTLC\n// scenario, if the node that extended the HTLC to the final node closes their\n// commitment on-chain early, then it eventually recognizes this HTLC as one\n// that's timed out. At this point, the node should timeout the HTLC using the\n// HTLC timeout transaction, then cancel it backwards as normal.",
      "length": 7171,
      "tokens": 968,
      "embedding": []
    },
    {
      "slug": "func testMultiHopLocalForceCloseOnChainHtlcTimeout(ht *lntest.HarnessTest) {",
      "content": "func testMultiHopLocalForceCloseOnChainHtlcTimeout(ht *lntest.HarnessTest) {\n\trunMultiHopHtlcClaimTest(\n\t\tht, runMultiHopLocalForceCloseOnChainHtlcTimeout,\n\t)\n}\n",
      "length": 80,
      "tokens": 5,
      "embedding": []
    },
    {
      "slug": "func runMultiHopLocalForceCloseOnChainHtlcTimeout(ht *lntest.HarnessTest,",
      "content": "func runMultiHopLocalForceCloseOnChainHtlcTimeout(ht *lntest.HarnessTest,\n\talice, bob *node.HarnessNode, c lnrpc.CommitmentType, zeroConf bool) {\n\n\t// First, we'll create a three hop network: Alice -> Bob -> Carol, with\n\t// Carol refusing to actually settle or directly cancel any HTLC's\n\t// self.\n\taliceChanPoint, bobChanPoint, carol := createThreeHopNetwork(\n\t\tht, alice, bob, true, c, zeroConf,\n\t)\n\n\t// With our channels set up, we'll then send a single HTLC from Alice\n\t// to Carol. As Carol is in hodl mode, she won't settle this HTLC which\n\t// opens up the base for out tests.\n\tconst htlcAmt = btcutil.Amount(300_000)\n\n\t// We'll now send a single HTLC across our multi-hop network.\n\tcarolPubKey := carol.PubKey[:]\n\tpayHash := ht.Random32Bytes()\n\treq := &routerrpc.SendPaymentRequest{\n\t\tDest:           carolPubKey,\n\t\tAmt:            int64(htlcAmt),\n\t\tPaymentHash:    payHash,\n\t\tFinalCltvDelta: finalCltvDelta,\n\t\tTimeoutSeconds: 60,\n\t\tFeeLimitMsat:   noFeeLimitMsat,\n\t}\n\talice.RPC.SendPayment(req)\n\n\t// Once the HTLC has cleared, all channels in our mini network should\n\t// have the it locked in.\n\tht.AssertActiveHtlcs(alice, payHash)\n\tht.AssertActiveHtlcs(bob, payHash)\n\tht.AssertActiveHtlcs(carol, payHash)\n\n\t// Increase the fee estimate so that the following force close tx will\n\t// be cpfp'ed.\n\tht.SetFeeEstimate(30000)\n\n\t// Now that all parties have the HTLC locked in, we'll immediately\n\t// force close the Bob -> Carol channel. This should trigger contract\n\t// resolution mode for both of them.\n\thasAnchors := lntest.CommitTypeHasAnchors(c)\n\tstream, _ := ht.CloseChannelAssertPending(bob, bobChanPoint, true)\n\tcloseTx := ht.AssertStreamChannelForceClosed(\n\t\tbob, bobChanPoint, hasAnchors, stream,\n\t)\n\n\t// Record how many blocks have mined. At this step\n\t// AssertStreamChannelForceClosed mines one block.\n\tblocksMined := uint32(1)\n\n\t// If the channel closed has anchors, we should expect to see a sweep\n\t// transaction for Carol's anchor.\n\thtlcOutpoint := wire.OutPoint{Hash: *closeTx, Index: 0}\n\tbobCommitOutpoint := wire.OutPoint{Hash: *closeTx, Index: 1}\n\tif hasAnchors {\n\t\thtlcOutpoint.Index = 2\n\t\tbobCommitOutpoint.Index = 3\n\t\tht.Miner.AssertNumTxsInMempool(1)\n\t}\n\n\t// Before the HTLC times out, we'll need to assert that Bob broadcasts a\n\t// sweep transaction for his commit output. Note that if the channel has\n\t// a script-enforced lease, then Bob will have to wait for an additional\n\t// CLTV before sweeping it.\n\tif c != lnrpc.CommitmentType_SCRIPT_ENFORCED_LEASE {\n\t\t// The sweep is broadcast on the block immediately before the\n\t\t// CSV expires and the commitment was already mined inside\n\t\t// AssertStreamChannelForceClosed(), so mine one block less\n\t\t// than defaultCSV in order to perform mempool assertions.\n\t\tht.MineBlocks(defaultCSV - blocksMined)\n\n\t\tcommitSweepTx := ht.Miner.AssertOutpointInMempool(\n\t\t\tbobCommitOutpoint,\n\t\t)\n\t\ttxid := commitSweepTx.TxHash()\n\t\tblock := ht.MineBlocksAndAssertNumTxes(1, 1)[0]\n\t\tht.Miner.AssertTxInBlock(block, &txid)\n\n\t\tblocksMined = defaultCSV + 1\n\t}\n\n\t// We'll now mine enough blocks for the HTLC to expire. After this, Bob\n\t// should hand off the now expired HTLC output to the utxo nursery.\n\tnumBlocks := padCLTV(finalCltvDelta)\n\tht.MineBlocks(numBlocks - blocksMined)\n\n\t// Bob's pending channel report should show that he has a single HTLC\n\t// that's now in stage one.\n\tht.AssertNumHTLCsAndStage(bob, bobChanPoint, 1, 1)\n\n\t// We should also now find a transaction in the mempool, as Bob should\n\t// have broadcast his second layer timeout transaction.\n\ttimeoutTx := ht.Miner.AssertOutpointInMempool(htlcOutpoint).TxHash()\n\n\t// Next, we'll mine an additional block. This should serve to confirm\n\t// the second layer timeout transaction.\n\tblock := ht.MineBlocksAndAssertNumTxes(1, 1)[0]\n\tht.Miner.AssertTxInBlock(block, &timeoutTx)\n\n\t// With the second layer timeout transaction confirmed, Bob should have\n\t// canceled backwards the HTLC that carol sent.\n\tht.AssertNumActiveHtlcs(bob, 0)\n\n\t// Additionally, Bob should now show that HTLC as being advanced to the\n\t// second stage.\n\tht.AssertNumHTLCsAndStage(bob, bobChanPoint, 1, 2)\n\n\t// Bob should now broadcast a transaction that sweeps certain inputs\n\t// depending on the commitment type. We'll need to mine some blocks\n\t// before the broadcast is possible.\n\tresp := bob.RPC.PendingChannels()\n\n\trequire.Len(ht, resp.PendingForceClosingChannels, 1)\n\tforceCloseChan := resp.PendingForceClosingChannels[0]\n\trequire.Len(ht, forceCloseChan.PendingHtlcs, 1)\n\tpendingHtlc := forceCloseChan.PendingHtlcs[0]\n\trequire.Positive(ht, pendingHtlc.BlocksTilMaturity)\n\tnumBlocks = uint32(pendingHtlc.BlocksTilMaturity)\n\n\tht.MineBlocks(numBlocks)\n\n\t// Now that the CSV/CLTV timelock has expired, the transaction should\n\t// either only sweep the HTLC timeout transaction, or sweep both the\n\t// HTLC timeout transaction and Bob's commit output depending on the\n\t// commitment type.\n\thtlcTimeoutOutpoint := wire.OutPoint{Hash: timeoutTx, Index: 0}\n\tsweepTx := ht.Miner.AssertOutpointInMempool(\n\t\thtlcTimeoutOutpoint,\n\t).TxHash()\n\tif c == lnrpc.CommitmentType_SCRIPT_ENFORCED_LEASE {\n\t\tht.Miner.AssertOutpointInMempool(bobCommitOutpoint)\n\t}\n\n\tblock = ht.MineBlocksAndAssertNumTxes(1, 1)[0]\n\tht.Miner.AssertTxInBlock(block, &sweepTx)\n\n\t// At this point, Bob should no longer show any channels as pending\n\t// close.\n\tht.AssertNumPendingForceClose(bob, 0)\n\n\t// Coop close, no anchors.\n\tht.CloseChannel(alice, aliceChanPoint)\n}\n\n// testMultiHopRemoteForceCloseOnChainHtlcTimeout tests that if we extend a\n// multi-hop HTLC, and the final destination of the HTLC force closes the\n// channel, then we properly timeout the HTLC directly on *their* commitment\n// transaction once the timeout has expired. Once we sweep the transaction, we\n// should also cancel back the initial HTLC.",
      "length": 5550,
      "tokens": 718,
      "embedding": []
    },
    {
      "slug": "func testMultiHopRemoteForceCloseOnChainHtlcTimeout(ht *lntest.HarnessTest) {",
      "content": "func testMultiHopRemoteForceCloseOnChainHtlcTimeout(ht *lntest.HarnessTest) {\n\trunMultiHopHtlcClaimTest(\n\t\tht, runMultiHopRemoteForceCloseOnChainHtlcTimeout,\n\t)\n}\n",
      "length": 81,
      "tokens": 5,
      "embedding": []
    },
    {
      "slug": "func runMultiHopRemoteForceCloseOnChainHtlcTimeout(ht *lntest.HarnessTest,",
      "content": "func runMultiHopRemoteForceCloseOnChainHtlcTimeout(ht *lntest.HarnessTest,\n\talice, bob *node.HarnessNode, c lnrpc.CommitmentType, zeroConf bool) {\n\n\t// First, we'll create a three hop network: Alice -> Bob -> Carol, with\n\t// Carol refusing to actually settle or directly cancel any HTLC's\n\t// self.\n\taliceChanPoint, bobChanPoint, carol := createThreeHopNetwork(\n\t\tht, alice, bob, true, c, zeroConf,\n\t)\n\n\t// With our channels set up, we'll then send a single HTLC from Alice\n\t// to Carol. As Carol is in hodl mode, she won't settle this HTLC which\n\t// opens up the base for out tests.\n\tconst htlcAmt = btcutil.Amount(30000)\n\n\t// We'll now send a single HTLC across our multi-hop network.\n\tvar preimage lntypes.Preimage\n\tcopy(preimage[:], ht.Random32Bytes())\n\tpayHash := preimage.Hash()\n\tinvoiceReq := &invoicesrpc.AddHoldInvoiceRequest{\n\t\tValue:      int64(htlcAmt),\n\t\tCltvExpiry: finalCltvDelta,\n\t\tHash:       payHash[:],\n\t}\n\tcarolInvoice := carol.RPC.AddHoldInvoice(invoiceReq)\n\n\t// Subscribe the invoice.\n\tstream := carol.RPC.SubscribeSingleInvoice(payHash[:])\n\n\treq := &routerrpc.SendPaymentRequest{\n\t\tPaymentRequest: carolInvoice.PaymentRequest,\n\t\tTimeoutSeconds: 60,\n\t\tFeeLimitMsat:   noFeeLimitMsat,\n\t}\n\talice.RPC.SendPayment(req)\n\n\t// Once the HTLC has cleared, all the nodes in our mini network should\n\t// show that the HTLC has been locked in.\n\tht.AssertActiveHtlcs(alice, payHash[:])\n\tht.AssertActiveHtlcs(bob, payHash[:])\n\tht.AssertActiveHtlcs(carol, payHash[:])\n\n\t// Increase the fee estimate so that the following force close tx will\n\t// be cpfp'ed.\n\tht.SetFeeEstimate(30000)\n\n\t// At this point, we'll now instruct Carol to force close the\n\t// transaction. This will let us exercise that Bob is able to sweep the\n\t// expired HTLC on Carol's version of the commitment transaction. If\n\t// Carol has an anchor, it will be swept too.\n\thasAnchors := lntest.CommitTypeHasAnchors(c)\n\tcloseStream, _ := ht.CloseChannelAssertPending(\n\t\tcarol, bobChanPoint, true,\n\t)\n\tcloseTx := ht.AssertStreamChannelForceClosed(\n\t\tcarol, bobChanPoint, hasAnchors, closeStream,\n\t)\n\n\t// At this point, Bob should have a pending force close channel as\n\t// Carol has gone directly to chain.\n\tht.AssertNumPendingForceClose(bob, 1)\n\n\tvar expectedTxes int\n\tswitch c {\n\t// Bob can sweep his commit output immediately.\n\tcase lnrpc.CommitmentType_LEGACY:\n\t\texpectedTxes = 1\n\n\t// Bob can sweep his commit and anchor outputs immediately.\n\tcase lnrpc.CommitmentType_ANCHORS:\n\t\texpectedTxes = 2\n\n\t// Bob can't sweep his commit output yet as he was the initiator of a\n\t// script-enforced leased channel, so he'll always incur the additional\n\t// CLTV. He can still sweep his anchor output however.\n\tcase lnrpc.CommitmentType_SCRIPT_ENFORCED_LEASE:\n\t\texpectedTxes = 1\n\n\tdefault:\n\t\tht.Fatalf(\"unhandled commitment type %v\", c)\n\t}\n\n\tht.Miner.AssertNumTxsInMempool(expectedTxes)\n\n\t// Next, we'll mine enough blocks for the HTLC to expire. At this\n\t// point, Bob should hand off the output to his internal utxo nursery,\n\t// which will broadcast a sweep transaction.\n\tnumBlocks := padCLTV(finalCltvDelta - 1)\n\tht.MineBlocks(numBlocks)\n\n\t// If we check Bob's pending channel report, it should show that he has\n\t// a single HTLC that's now in the second stage, as skip the initial\n\t// first stage since this is a direct HTLC.\n\tht.AssertNumHTLCsAndStage(bob, bobChanPoint, 1, 2)\n\n\t// We need to generate an additional block to trigger the sweep.\n\tht.MineBlocks(1)\n\n\t// Bob's sweeping transaction should now be found in the mempool at\n\t// this point.\n\tsweepTx := ht.Miner.AssertNumTxsInMempool(1)[0]\n\n\t// If we mine an additional block, then this should confirm Bob's\n\t// transaction which sweeps the direct HTLC output.\n\tblock := ht.MineBlocksAndAssertNumTxes(1, 1)[0]\n\tht.Miner.AssertTxInBlock(block, sweepTx)\n\n\t// Now that the sweeping transaction has been confirmed, Bob should\n\t// cancel back that HTLC. As a result, Alice should not know of any\n\t// active HTLC's.\n\tht.AssertNumActiveHtlcs(alice, 0)\n\n\t// Now we'll check Bob's pending channel report. Since this was Carol's\n\t// commitment, he doesn't have to wait for any CSV delays, but he may\n\t// still need to wait for a CLTV on his commit output to expire\n\t// depending on the commitment type.\n\tif c == lnrpc.CommitmentType_SCRIPT_ENFORCED_LEASE {\n\t\tresp := bob.RPC.PendingChannels()\n\n\t\trequire.Len(ht, resp.PendingForceClosingChannels, 1)\n\t\tforceCloseChan := resp.PendingForceClosingChannels[0]\n\t\trequire.Positive(ht, forceCloseChan.BlocksTilMaturity)\n\n\t\tnumBlocks := uint32(forceCloseChan.BlocksTilMaturity)\n\t\tht.MineBlocks(numBlocks)\n\n\t\tbobCommitOutpoint := wire.OutPoint{Hash: *closeTx, Index: 3}\n\t\tbobCommitSweep := ht.Miner.AssertOutpointInMempool(\n\t\t\tbobCommitOutpoint,\n\t\t)\n\t\tbobCommitSweepTxid := bobCommitSweep.TxHash()\n\t\tblock := ht.MineBlocksAndAssertNumTxes(1, 1)[0]\n\t\tht.Miner.AssertTxInBlock(block, &bobCommitSweepTxid)\n\t}\n\tht.AssertNumPendingForceClose(bob, 0)\n\n\t// While we're here, we assert that our expired invoice's state is\n\t// correctly updated, and can no longer be settled.\n\tht.AssertInvoiceState(stream, lnrpc.Invoice_CANCELED)\n\n\t// We'll close out the test by closing the channel from Alice to Bob,\n\t// and then shutting down the new node we created as its no longer\n\t// needed. Coop close, no anchors.\n\tht.CloseChannel(alice, aliceChanPoint)\n}\n\n// testMultiHopHtlcLocalChainClaim tests that in a multi-hop HTLC scenario, if\n// we force close a channel with an incoming HTLC, and later find out the\n// preimage via the witness beacon, we properly settle the HTLC on-chain using\n// the HTLC success transaction in order to ensure we don't lose any funds.",
      "length": 5377,
      "tokens": 722,
      "embedding": []
    },
    {
      "slug": "func testMultiHopHtlcLocalChainClaim(ht *lntest.HarnessTest) {",
      "content": "func testMultiHopHtlcLocalChainClaim(ht *lntest.HarnessTest) {\n\trunMultiHopHtlcClaimTest(ht, runMultiHopHtlcLocalChainClaim)\n}\n",
      "length": 62,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func runMultiHopHtlcLocalChainClaim(ht *lntest.HarnessTest,",
      "content": "func runMultiHopHtlcLocalChainClaim(ht *lntest.HarnessTest,\n\talice, bob *node.HarnessNode, c lnrpc.CommitmentType, zeroConf bool) {\n\n\t// First, we'll create a three hop network: Alice -> Bob -> Carol, with\n\t// Carol refusing to actually settle or directly cancel any HTLC's\n\t// self.\n\taliceChanPoint, bobChanPoint, carol := createThreeHopNetwork(\n\t\tht, alice, bob, false, c, zeroConf,\n\t)\n\n\t// With the network active, we'll now add a new hodl invoice at Carol's\n\t// end. Make sure the cltv expiry delta is large enough, otherwise Bob\n\t// won't send out the outgoing htlc.\n\tconst invoiceAmt = 100000\n\tvar preimage lntypes.Preimage\n\tcopy(preimage[:], ht.Random32Bytes())\n\tpayHash := preimage.Hash()\n\tinvoiceReq := &invoicesrpc.AddHoldInvoiceRequest{\n\t\tValue:      invoiceAmt,\n\t\tCltvExpiry: finalCltvDelta,\n\t\tHash:       payHash[:],\n\t}\n\tcarolInvoice := carol.RPC.AddHoldInvoice(invoiceReq)\n\n\t// Subscribe the invoice.\n\tstream := carol.RPC.SubscribeSingleInvoice(payHash[:])\n\n\t// Now that we've created the invoice, we'll send a single payment from\n\t// Alice to Carol. We won't wait for the response however, as Carol\n\t// will not immediately settle the payment.\n\treq := &routerrpc.SendPaymentRequest{\n\t\tPaymentRequest: carolInvoice.PaymentRequest,\n\t\tTimeoutSeconds: 60,\n\t\tFeeLimitMsat:   noFeeLimitMsat,\n\t}\n\talice.RPC.SendPayment(req)\n\n\t// At this point, all 3 nodes should now have an active channel with\n\t// the created HTLC pending on all of them.\n\tht.AssertActiveHtlcs(alice, payHash[:])\n\tht.AssertActiveHtlcs(bob, payHash[:])\n\tht.AssertActiveHtlcs(carol, payHash[:])\n\n\t// Wait for carol to mark invoice as accepted. There is a small gap to\n\t// bridge between adding the htlc to the channel and executing the exit\n\t// hop logic.\n\tht.AssertInvoiceState(stream, lnrpc.Invoice_ACCEPTED)\n\n\t// Increase the fee estimate so that the following force close tx will\n\t// be cpfp'ed.\n\tht.SetFeeEstimate(30000)\n\n\t// At this point, Bob decides that he wants to exit the channel\n\t// immediately, so he force closes his commitment transaction.\n\thasAnchors := lntest.CommitTypeHasAnchors(c)\n\tcloseStream, _ := ht.CloseChannelAssertPending(\n\t\tbob, aliceChanPoint, true,\n\t)\n\tbobForceClose := ht.AssertStreamChannelForceClosed(\n\t\tbob, aliceChanPoint, hasAnchors, closeStream,\n\t)\n\n\tvar expectedTxes int\n\tswitch c {\n\t// Alice will sweep her commitment output immediately.\n\tcase lnrpc.CommitmentType_LEGACY:\n\t\texpectedTxes = 1\n\n\t// Alice will sweep her commitment and anchor output immediately.\n\tcase lnrpc.CommitmentType_ANCHORS:\n\t\texpectedTxes = 2\n\n\t// Alice will sweep her anchor output immediately. Her commitment\n\t// output cannot be swept yet as it has incurred an additional CLTV due\n\t// to being the initiator of a script-enforced leased channel.\n\tcase lnrpc.CommitmentType_SCRIPT_ENFORCED_LEASE:\n\t\texpectedTxes = 1\n\n\tdefault:\n\t\tht.Fatalf(\"unhandled commitment type %v\", c)\n\t}\n\n\tht.Miner.AssertNumTxsInMempool(expectedTxes)\n\n\t// Suspend Bob to force Carol to go to chain.\n\trestartBob := ht.SuspendNode(bob)\n\n\t// Settle invoice. This will just mark the invoice as settled, as there\n\t// is no link anymore to remove the htlc from the commitment tx. For\n\t// this test, it is important to actually settle and not leave the\n\t// invoice in the accepted state, because without a known preimage, the\n\t// channel arbitrator won't go to chain.\n\tcarol.RPC.SettleInvoice(preimage[:])\n\n\t// We'll now mine enough blocks so Carol decides that she needs to go\n\t// on-chain to claim the HTLC as Bob has been inactive.\n\tnumBlocks := padCLTV(uint32(invoiceReq.CltvExpiry-\n\t\tlncfg.DefaultIncomingBroadcastDelta) - 1)\n\tht.MineBlocks(numBlocks)\n\n\t// Carol's commitment transaction should now be in the mempool. If\n\t// there is an anchor, Carol will sweep that too.\n\tif lntest.CommitTypeHasAnchors(c) {\n\t\texpectedTxes = 2\n\t}\n\tht.Miner.AssertNumTxsInMempool(expectedTxes)\n\n\t// Look up the closing transaction. It should be spending from the\n\t// funding transaction,\n\tclosingTx := ht.Miner.AssertOutpointInMempool(\n\t\tht.OutPointFromChannelPoint(bobChanPoint),\n\t)\n\tclosingTxid := closingTx.TxHash()\n\n\t// Mine a block that should confirm the commit tx, the anchor if\n\t// present and the coinbase.\n\tblock := ht.MineBlocksAndAssertNumTxes(1, expectedTxes)[0]\n\tht.Miner.AssertTxInBlock(block, &closingTxid)\n\n\t// Restart bob again.\n\trequire.NoError(ht, restartBob())\n\n\t// After the force close transaction is mined, transactions will be\n\t// broadcast by both Bob and Carol.\n\tswitch c {\n\t// Carol will broadcast her second level HTLC transaction and Bob will\n\t// sweep his commitment output.\n\tcase lnrpc.CommitmentType_LEGACY:\n\t\texpectedTxes = 2\n\n\t// Carol will broadcast her second level HTLC transaction and Bob will\n\t// sweep his commitment and anchor output.\n\tcase lnrpc.CommitmentType_ANCHORS:\n\t\texpectedTxes = 3\n\n\t// Carol will broadcast her second level HTLC transaction, and Bob will\n\t// sweep his anchor output. Bob can't sweep his commitment output yet\n\t// as it has incurred an additional CLTV due to being the initiator of\n\t// a script-enforced leased channel.\n\tcase lnrpc.CommitmentType_SCRIPT_ENFORCED_LEASE:\n\t\texpectedTxes = 2\n\n\tdefault:\n\t\tht.Fatalf(\"unhandled commitment type %v\", c)\n\t}\n\n\ttxes := ht.Miner.GetNumTxsFromMempool(expectedTxes)\n\n\t// Both Carol's second level transaction and Bob's sweep should be\n\t// spending from the commitment transaction.\n\tht.AssertAllTxesSpendFrom(txes, closingTxid)\n\n\t// At this point we suspend Alice to make sure she'll handle the\n\t// on-chain settle after a restart.\n\trestartAlice := ht.SuspendNode(alice)\n\n\t// Mine a block to confirm the expected transactions (+ the coinbase).\n\tblock = ht.MineBlocksAndAssertNumTxes(1, expectedTxes)[0]\n\trequire.Len(ht, block.Transactions, expectedTxes+1)\n\n\t// For non-anchor channel types, the nursery will handle sweeping the\n\t// second level output, and it will wait one extra block before\n\t// sweeping it.\n\tsecondLevelMaturity := uint32(defaultCSV)\n\n\t// If this is a channel of the anchor type, we will subtract one block\n\t// from the default CSV, as the Sweeper will handle the input, and the\n\t// Sweeper sweeps the input as soon as the lock expires.\n\tif hasAnchors {\n\t\tsecondLevelMaturity = defaultCSV - 1\n\t}\n\n\t// Keep track of the second level tx maturity.\n\tcarolSecondLevelCSV := secondLevelMaturity\n\n\t// When Bob notices Carol's second level transaction in the block, he\n\t// will extract the preimage and broadcast a second level tx to claim\n\t// the HTLC in his (already closed) channel with Alice.\n\tbobSecondLvlTx := ht.Miner.GetNumTxsFromMempool(1)[0]\n\n\t// It should spend from the commitment in the channel with Alice.\n\tht.AssertTxSpendFrom(bobSecondLvlTx, *bobForceClose)\n\n\t// At this point, Bob should have broadcast his second layer success\n\t// transaction, and should have sent it to the nursery for incubation.\n\tht.AssertNumHTLCsAndStage(bob, aliceChanPoint, 1, 1)\n\n\t// The channel between Bob and Carol will still be pending force close\n\t// if this is a leased channel. In that case, we'd also check the HTLC\n\t// stages are correct in that channel.\n\tif c == lnrpc.CommitmentType_SCRIPT_ENFORCED_LEASE {\n\t\tht.AssertNumPendingForceClose(bob, 2)\n\t\tht.AssertNumHTLCsAndStage(bob, bobChanPoint, 1, 1)\n\t} else {\n\t\tht.AssertNumPendingForceClose(bob, 1)\n\t}\n\n\t// We'll now mine a block which should confirm Bob's second layer\n\t// transaction.\n\tblock = ht.MineBlocksAndAssertNumTxes(1, 1)[0]\n\tbobSecondLvlTxid := bobSecondLvlTx.TxHash()\n\tht.Miner.AssertTxInBlock(block, &bobSecondLvlTxid)\n\n\t// Keep track of Bob's second level maturity, and decrement our track\n\t// of Carol's.\n\tbobSecondLevelCSV := secondLevelMaturity\n\tcarolSecondLevelCSV--\n\n\t// Now that the preimage from Bob has hit the chain, restart Alice to\n\t// ensure she'll pick it up.\n\trequire.NoError(ht, restartAlice())\n\n\t// If we then mine 3 additional blocks, Carol's second level tx should\n\t// mature, and she can pull the funds from it with a sweep tx.\n\tht.MineBlocks(carolSecondLevelCSV)\n\tcarolSweep := ht.Miner.AssertNumTxsInMempool(1)[0]\n\n\t// Mining one additional block, Bob's second level tx is mature, and he\n\t// can sweep the output.\n\tbobSecondLevelCSV -= carolSecondLevelCSV\n\tblock = ht.MineBlocksAndAssertNumTxes(bobSecondLevelCSV, 1)[0]\n\tht.Miner.AssertTxInBlock(block, carolSweep)\n\n\tbobSweep := ht.Miner.GetNumTxsFromMempool(1)[0]\n\tbobSweepTxid := bobSweep.TxHash()\n\n\t// Make sure it spends from the second level tx.\n\tht.AssertTxSpendFrom(bobSweep, bobSecondLvlTxid)\n\n\t// When we mine one additional block, that will confirm Bob's sweep.\n\t// Now Bob should have no pending channels anymore, as this just\n\t// resolved it by the confirmation of the sweep transaction.\n\tblock = ht.MineBlocksAndAssertNumTxes(1, 1)[0]\n\tht.Miner.AssertTxInBlock(block, &bobSweepTxid)\n\n\t// With the script-enforced lease commitment type, Alice and Bob still\n\t// haven't been able to sweep their respective commit outputs due to the\n\t// additional CLTV. We'll need to mine enough blocks for the timelock to\n\t// expire and prompt their sweep.\n\tif c == lnrpc.CommitmentType_SCRIPT_ENFORCED_LEASE {\n\t\tfor _, node := range []*node.HarnessNode{alice, bob} {\n\t\t\tht.AssertNumPendingForceClose(node, 1)\n\t\t}\n\n\t\t// Due to the way the test is set up, Alice and Bob share the\n\t\t// same CLTV for their commit outputs even though it's enforced\n\t\t// on different channels (Alice-Bob and Bob-Carol).\n\t\tresp := alice.RPC.PendingChannels()\n\t\trequire.Len(ht, resp.PendingForceClosingChannels, 1)\n\t\tforceCloseChan := resp.PendingForceClosingChannels[0]\n\t\trequire.Positive(ht, forceCloseChan.BlocksTilMaturity)\n\n\t\t// Mine enough blocks for the timelock to expire.\n\t\tnumBlocks := uint32(forceCloseChan.BlocksTilMaturity)\n\t\tht.MineBlocks(numBlocks)\n\n\t\t// Both Alice and Bob show broadcast their commit sweeps.\n\t\taliceCommitOutpoint := wire.OutPoint{\n\t\t\tHash: *bobForceClose, Index: 3,\n\t\t}\n\t\taliceCommitSweep := ht.Miner.AssertOutpointInMempool(\n\t\t\taliceCommitOutpoint,\n\t\t).TxHash()\n\t\tbobCommitOutpoint := wire.OutPoint{Hash: closingTxid, Index: 3}\n\t\tbobCommitSweep := ht.Miner.AssertOutpointInMempool(\n\t\t\tbobCommitOutpoint,\n\t\t).TxHash()\n\n\t\t// Confirm their sweeps.\n\t\tblock := ht.MineBlocksAndAssertNumTxes(1, 2)[0]\n\t\tht.Miner.AssertTxInBlock(block, &aliceCommitSweep)\n\t\tht.Miner.AssertTxInBlock(block, &bobCommitSweep)\n\t}\n\n\t// All nodes should show zero pending and open channels.\n\tfor _, node := range []*node.HarnessNode{alice, bob, carol} {\n\t\tht.AssertNumPendingForceClose(node, 0)\n\t\tht.AssertNodeNumChannels(node, 0)\n\t}\n\n\t// Finally, check that the Alice's payment is correctly marked\n\t// succeeded.\n\tht.AssertPaymentStatus(alice, preimage, lnrpc.Payment_SUCCEEDED)\n}\n\n// testMultiHopHtlcRemoteChainClaim tests that in the multi-hop HTLC scenario,\n// if the remote party goes to chain while we have an incoming HTLC, then when\n// we found out the preimage via the witness beacon, we properly settle the\n// HTLC directly on-chain using the preimage in order to ensure that we don't\n// lose any funds.",
      "length": 10537,
      "tokens": 1392,
      "embedding": []
    },
    {
      "slug": "func testMultiHopHtlcRemoteChainClaim(ht *lntest.HarnessTest) {",
      "content": "func testMultiHopHtlcRemoteChainClaim(ht *lntest.HarnessTest) {\n\trunMultiHopHtlcClaimTest(ht, runMultiHopHtlcRemoteChainClaim)\n}\n",
      "length": 63,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func runMultiHopHtlcRemoteChainClaim(ht *lntest.HarnessTest,",
      "content": "func runMultiHopHtlcRemoteChainClaim(ht *lntest.HarnessTest,\n\talice, bob *node.HarnessNode, c lnrpc.CommitmentType, zeroConf bool) {\n\n\t// First, we'll create a three hop network: Alice -> Bob -> Carol, with\n\t// Carol refusing to actually settle or directly cancel any HTLC's\n\t// self.\n\taliceChanPoint, bobChanPoint, carol := createThreeHopNetwork(\n\t\tht, alice, bob, false, c, zeroConf,\n\t)\n\n\t// With the network active, we'll now add a new hodl invoice at Carol's\n\t// end. Make sure the cltv expiry delta is large enough, otherwise Bob\n\t// won't send out the outgoing htlc.\n\tconst invoiceAmt = 100000\n\tvar preimage lntypes.Preimage\n\tcopy(preimage[:], ht.Random32Bytes())\n\tpayHash := preimage.Hash()\n\tinvoiceReq := &invoicesrpc.AddHoldInvoiceRequest{\n\t\tValue:      invoiceAmt,\n\t\tCltvExpiry: finalCltvDelta,\n\t\tHash:       payHash[:],\n\t}\n\tcarolInvoice := carol.RPC.AddHoldInvoice(invoiceReq)\n\n\t// Subscribe the invoice.\n\tstream := carol.RPC.SubscribeSingleInvoice(payHash[:])\n\n\t// Now that we've created the invoice, we'll send a single payment from\n\t// Alice to Carol. We won't wait for the response however, as Carol\n\t// will not immediately settle the payment.\n\treq := &routerrpc.SendPaymentRequest{\n\t\tPaymentRequest: carolInvoice.PaymentRequest,\n\t\tTimeoutSeconds: 60,\n\t\tFeeLimitMsat:   noFeeLimitMsat,\n\t}\n\talice.RPC.SendPayment(req)\n\n\t// At this point, all 3 nodes should now have an active channel with\n\t// the created HTLC pending on all of them.\n\tht.AssertActiveHtlcs(alice, payHash[:])\n\tht.AssertActiveHtlcs(bob, payHash[:])\n\tht.AssertActiveHtlcs(carol, payHash[:])\n\n\t// Wait for carol to mark invoice as accepted. There is a small gap to\n\t// bridge between adding the htlc to the channel and executing the exit\n\t// hop logic.\n\tht.AssertInvoiceState(stream, lnrpc.Invoice_ACCEPTED)\n\n\t// Increase the fee estimate so that the following force close tx will\n\t// be cpfp'ed.\n\tht.SetFeeEstimate(30000)\n\n\t// Next, Alice decides that she wants to exit the channel, so she'll\n\t// immediately force close the channel by broadcast her commitment\n\t// transaction.\n\thasAnchors := lntest.CommitTypeHasAnchors(c)\n\tcloseStream, _ := ht.CloseChannelAssertPending(\n\t\talice, aliceChanPoint, true,\n\t)\n\taliceForceClose := ht.AssertStreamChannelForceClosed(\n\t\talice, aliceChanPoint, hasAnchors, closeStream,\n\t)\n\n\t// Record how many blocks have mined. At this step\n\t// AssertStreamChannelForceClosed mines one block.\n\tblocksMined := uint32(1)\n\n\t// Wait for the channel to be marked pending force close.\n\tht.AssertChannelPendingForceClose(alice, aliceChanPoint)\n\n\t// After AssertStreamChannelForceClosed returns, it has mined a block\n\t// so now bob will attempt to redeem his anchor commitment (if the\n\t// channel type is of that type).\n\tif hasAnchors {\n\t\tht.Miner.AssertNumTxsInMempool(1)\n\t}\n\n\tif c != lnrpc.CommitmentType_SCRIPT_ENFORCED_LEASE {\n\t\t// Mine enough blocks for Alice to sweep her funds from the\n\t\t// force closed channel. AssertStreamChannelForceClosed()\n\t\t// already mined a block containing the commitment tx and the\n\t\t// commit sweep tx will be broadcast immediately before it can\n\t\t// be included in a block, so mine one less than defaultCSV in\n\t\t// order to perform mempool assertions.\n\t\tht.MineBlocks(defaultCSV - blocksMined)\n\t\tblocksMined = defaultCSV\n\n\t\t// Alice should now sweep her funds.\n\t\tht.Miner.AssertNumTxsInMempool(1)\n\t}\n\n\t// Suspend bob, so Carol is forced to go on chain.\n\trestartBob := ht.SuspendNode(bob)\n\n\t// Settle invoice. This will just mark the invoice as settled, as there\n\t// is no link anymore to remove the htlc from the commitment tx. For\n\t// this test, it is important to actually settle and not leave the\n\t// invoice in the accepted state, because without a known preimage, the\n\t// channel arbitrator won't go to chain.\n\tcarol.RPC.SettleInvoice(preimage[:])\n\n\t// We'll now mine enough blocks so Carol decides that she needs to go\n\t// on-chain to claim the HTLC as Bob has been inactive.\n\tnumBlocks := padCLTV(uint32(\n\t\tinvoiceReq.CltvExpiry - lncfg.DefaultIncomingBroadcastDelta,\n\t))\n\tht.MineBlocks(numBlocks - blocksMined)\n\n\texpectedTxes := 1\n\tif hasAnchors {\n\t\texpectedTxes = 2\n\t}\n\n\t// Carol's commitment transaction should now be in the mempool. If\n\t// there are anchors, Carol also sweeps her anchor.\n\tht.Miner.AssertNumTxsInMempool(expectedTxes)\n\n\t// The closing transaction should be spending from the funding\n\t// transaction.\n\tclosingTx := ht.Miner.AssertOutpointInMempool(\n\t\tht.OutPointFromChannelPoint(bobChanPoint),\n\t)\n\tclosingTxid := closingTx.TxHash()\n\n\t// Mine a block, which should contain: the commitment, possibly an\n\t// anchor sweep and the coinbase tx.\n\tblock := ht.MineBlocksAndAssertNumTxes(1, expectedTxes)[0]\n\tht.Miner.AssertTxInBlock(block, &closingTxid)\n\n\t// Restart bob again.\n\trequire.NoError(ht, restartBob())\n\n\t// After the force close transaction is mined, we should expect Bob and\n\t// Carol to broadcast some transactions depending on the channel\n\t// commitment type.\n\tswitch c {\n\t// Carol should broadcast her second level HTLC transaction and Bob\n\t// should broadcast a transaction to sweep his commitment output.\n\tcase lnrpc.CommitmentType_LEGACY:\n\t\texpectedTxes = 2\n\n\t// Carol should broadcast her second level HTLC transaction and Bob\n\t// should broadcast a transaction to sweep his commitment output and\n\t// another to sweep his anchor output.\n\tcase lnrpc.CommitmentType_ANCHORS:\n\t\texpectedTxes = 3\n\n\t// Carol should broadcast her second level HTLC transaction and Bob\n\t// should broadcast a transaction to sweep his anchor output. Bob can't\n\t// sweep his commitment output yet as he has incurred an additional CLTV\n\t// due to being the channel initiator of a force closed script-enforced\n\t// leased channel.\n\tcase lnrpc.CommitmentType_SCRIPT_ENFORCED_LEASE:\n\t\texpectedTxes = 2\n\n\tdefault:\n\t\tht.Fatalf(\"unhandled commitment type %v\", c)\n\t}\n\ttxes := ht.Miner.GetNumTxsFromMempool(expectedTxes)\n\n\t// All transactions should be pending from the commitment transaction.\n\tht.AssertAllTxesSpendFrom(txes, closingTxid)\n\n\t// Mine a block to confirm the two transactions (+ coinbase).\n\tht.MineBlocksAndAssertNumTxes(1, expectedTxes)\n\n\t// Keep track of the second level tx maturity.\n\tcarolSecondLevelCSV := uint32(defaultCSV)\n\n\t// When Bob notices Carol's second level transaction in the block, he\n\t// will extract the preimage and broadcast a sweep tx to directly claim\n\t// the HTLC in his (already closed) channel with Alice.\n\tbobHtlcSweep := ht.Miner.GetNumTxsFromMempool(1)[0]\n\tbobHtlcSweepTxid := bobHtlcSweep.TxHash()\n\n\t// It should spend from the commitment in the channel with Alice.\n\tht.AssertTxSpendFrom(bobHtlcSweep, *aliceForceClose)\n\n\t// We'll now mine a block which should confirm Bob's HTLC sweep\n\t// transaction.\n\tblock = ht.MineBlocksAndAssertNumTxes(1, 1)[0]\n\tht.Miner.AssertTxInBlock(block, &bobHtlcSweepTxid)\n\tcarolSecondLevelCSV--\n\n\t// Now that the sweeping transaction has been confirmed, Bob should now\n\t// recognize that all contracts for the Bob-Carol channel have been\n\t// fully resolved\n\taliceBobPendingChansLeft := 0\n\tif c == lnrpc.CommitmentType_SCRIPT_ENFORCED_LEASE {\n\t\taliceBobPendingChansLeft = 1\n\t}\n\tfor _, node := range []*node.HarnessNode{alice, bob} {\n\t\tht.AssertNumPendingForceClose(\n\t\t\tnode, aliceBobPendingChansLeft,\n\t\t)\n\t}\n\n\t// If we then mine 3 additional blocks, Carol's second level tx will\n\t// mature, and she should pull the funds.\n\tht.MineBlocks(carolSecondLevelCSV)\n\tcarolSweep := ht.Miner.AssertNumTxsInMempool(1)[0]\n\n\t// When Carol's sweep gets confirmed, she should have no more pending\n\t// channels.\n\tblock = ht.MineBlocksAndAssertNumTxes(1, 1)[0]\n\tht.Miner.AssertTxInBlock(block, carolSweep)\n\tht.AssertNumPendingForceClose(carol, 0)\n\n\t// With the script-enforced lease commitment type, Alice and Bob still\n\t// haven't been able to sweep their respective commit outputs due to the\n\t// additional CLTV. We'll need to mine enough blocks for the timelock to\n\t// expire and prompt their sweep.\n\tif c == lnrpc.CommitmentType_SCRIPT_ENFORCED_LEASE {\n\t\t// Due to the way the test is set up, Alice and Bob share the\n\t\t// same CLTV for their commit outputs even though it's enforced\n\t\t// on different channels (Alice-Bob and Bob-Carol).\n\t\tresp := alice.RPC.PendingChannels()\n\t\trequire.Len(ht, resp.PendingForceClosingChannels, 1)\n\t\tforceCloseChan := resp.PendingForceClosingChannels[0]\n\t\trequire.Positive(ht, forceCloseChan.BlocksTilMaturity)\n\n\t\t// Mine enough blocks for the timelock to expire.\n\t\tnumBlocks := uint32(forceCloseChan.BlocksTilMaturity)\n\t\tht.MineBlocks(numBlocks)\n\n\t\t// Both Alice and Bob show broadcast their commit sweeps.\n\t\taliceCommitOutpoint := wire.OutPoint{\n\t\t\tHash: *aliceForceClose, Index: 3,\n\t\t}\n\t\taliceCommitSweep := ht.Miner.AssertOutpointInMempool(\n\t\t\taliceCommitOutpoint,\n\t\t)\n\t\taliceCommitSweepTxid := aliceCommitSweep.TxHash()\n\t\tbobCommitOutpoint := wire.OutPoint{Hash: closingTxid, Index: 3}\n\t\tbobCommitSweep := ht.Miner.AssertOutpointInMempool(\n\t\t\tbobCommitOutpoint,\n\t\t)\n\t\tbobCommitSweepTxid := bobCommitSweep.TxHash()\n\n\t\t// Confirm their sweeps.\n\t\tblock := ht.MineBlocksAndAssertNumTxes(1, 2)[0]\n\t\tht.Miner.AssertTxInBlock(block, &aliceCommitSweepTxid)\n\t\tht.Miner.AssertTxInBlock(block, &bobCommitSweepTxid)\n\n\t\t// Alice and Bob should not show any pending channels anymore as\n\t\t// they have been fully resolved.\n\t\tfor _, node := range []*node.HarnessNode{alice, bob} {\n\t\t\tht.AssertNumPendingForceClose(node, 0)\n\t\t}\n\t}\n\n\t// The invoice should show as settled for Carol, indicating that it was\n\t// swept on-chain.\n\tinvoice := ht.AssertInvoiceState(stream, lnrpc.Invoice_SETTLED)\n\trequire.Equal(ht, int64(invoiceAmt), invoice.AmtPaidSat)\n\n\t// Finally, check that the Alice's payment is correctly marked\n\t// succeeded.\n\tht.AssertPaymentStatus(alice, preimage, lnrpc.Payment_SUCCEEDED)\n}\n\n// testMultiHopHtlcAggregation tests that in a multi-hop HTLC scenario, if we\n// force close a channel with both incoming and outgoing HTLCs, we can properly\n// resolve them using the second level timeout and success transactions. In\n// case of anchor channels, the second-level spends can also be aggregated and\n// properly feebumped, so we'll check that as well.",
      "length": 9754,
      "tokens": 1264,
      "embedding": []
    },
    {
      "slug": "func testMultiHopHtlcAggregation(ht *lntest.HarnessTest) {",
      "content": "func testMultiHopHtlcAggregation(ht *lntest.HarnessTest) {\n\trunMultiHopHtlcClaimTest(ht, runMultiHopHtlcAggregation)\n}\n",
      "length": 58,
      "tokens": 3,
      "embedding": []
    },
    {
      "slug": "func runMultiHopHtlcAggregation(ht *lntest.HarnessTest,",
      "content": "func runMultiHopHtlcAggregation(ht *lntest.HarnessTest,\n\talice, bob *node.HarnessNode, c lnrpc.CommitmentType, zeroConf bool) {\n\n\t// First, we'll create a three hop network: Alice -> Bob -> Carol.\n\taliceChanPoint, bobChanPoint, carol := createThreeHopNetwork(\n\t\tht, alice, bob, false, c, zeroConf,\n\t)\n\n\t// For neutrino backend, we need one additional UTXO to create\n\t// the sweeping tx for the second-level success txes.\n\tif ht.IsNeutrinoBackend() {\n\t\tht.FundCoins(btcutil.SatoshiPerBitcoin, bob)\n\t}\n\n\t// To ensure we have capacity in both directions of the route, we'll\n\t// make a fairly large payment Alice->Carol and settle it.\n\tconst reBalanceAmt = 500_000\n\tinvoice := &lnrpc.Invoice{Value: reBalanceAmt}\n\tresp := carol.RPC.AddInvoice(invoice)\n\tht.CompletePaymentRequests(alice, []string{resp.PaymentRequest})\n\n\t// With the network active, we'll now add a new hodl invoices at both\n\t// Alice's and Carol's end. Make sure the cltv expiry delta is large\n\t// enough, otherwise Bob won't send out the outgoing htlc.\n\tconst numInvoices = 5\n\tconst invoiceAmt = 50_000\n\n\tvar (\n\t\tcarolInvoices       []*invoicesrpc.AddHoldInvoiceResp\n\t\taliceInvoices       []*invoicesrpc.AddHoldInvoiceResp\n\t\talicePreimages      []lntypes.Preimage\n\t\tpayHashes           [][]byte\n\t\tinvoiceStreamsCarol []rpc.SingleInvoiceClient\n\t\tinvoiceStreamsAlice []rpc.SingleInvoiceClient\n\t)\n\n\t// Add Carol invoices.\n\tfor i := 0; i < numInvoices; i++ {\n\t\tvar preimage lntypes.Preimage\n\t\tcopy(preimage[:], ht.Random32Bytes())\n\t\tpayHash := preimage.Hash()\n\t\tinvoiceReq := &invoicesrpc.AddHoldInvoiceRequest{\n\t\t\tValue:      invoiceAmt,\n\t\t\tCltvExpiry: finalCltvDelta,\n\t\t\tHash:       payHash[:],\n\t\t}\n\t\tcarolInvoice := carol.RPC.AddHoldInvoice(invoiceReq)\n\n\t\tcarolInvoices = append(carolInvoices, carolInvoice)\n\t\tpayHashes = append(payHashes, payHash[:])\n\n\t\t// Subscribe the invoice.\n\t\tstream := carol.RPC.SubscribeSingleInvoice(payHash[:])\n\t\tinvoiceStreamsCarol = append(invoiceStreamsCarol, stream)\n\t}\n\n\t// We'll give Alice's invoices a longer CLTV expiry, to ensure the\n\t// channel Bob<->Carol will be closed first.\n\tfor i := 0; i < numInvoices; i++ {\n\t\tvar preimage lntypes.Preimage\n\t\tcopy(preimage[:], ht.Random32Bytes())\n\t\tpayHash := preimage.Hash()\n\t\tinvoiceReq := &invoicesrpc.AddHoldInvoiceRequest{\n\t\t\tValue:      invoiceAmt,\n\t\t\tCltvExpiry: thawHeightDelta - 4,\n\t\t\tHash:       payHash[:],\n\t\t}\n\t\taliceInvoice := alice.RPC.AddHoldInvoice(invoiceReq)\n\n\t\taliceInvoices = append(aliceInvoices, aliceInvoice)\n\t\talicePreimages = append(alicePreimages, preimage)\n\t\tpayHashes = append(payHashes, payHash[:])\n\n\t\t// Subscribe the invoice.\n\t\tstream := alice.RPC.SubscribeSingleInvoice(payHash[:])\n\t\tinvoiceStreamsAlice = append(invoiceStreamsAlice, stream)\n\t}\n\n\t// Now that we've created the invoices, we'll pay them all from\n\t// Alice<->Carol, going through Bob. We won't wait for the response\n\t// however, as neither will immediately settle the payment.\n\n\t// Alice will pay all of Carol's invoices.\n\tfor _, carolInvoice := range carolInvoices {\n\t\treq := &routerrpc.SendPaymentRequest{\n\t\t\tPaymentRequest: carolInvoice.PaymentRequest,\n\t\t\tTimeoutSeconds: 60,\n\t\t\tFeeLimitMsat:   noFeeLimitMsat,\n\t\t}\n\t\talice.RPC.SendPayment(req)\n\t}\n\n\t// And Carol will pay Alice's.\n\tfor _, aliceInvoice := range aliceInvoices {\n\t\treq := &routerrpc.SendPaymentRequest{\n\t\t\tPaymentRequest: aliceInvoice.PaymentRequest,\n\t\t\tTimeoutSeconds: 60,\n\t\t\tFeeLimitMsat:   noFeeLimitMsat,\n\t\t}\n\t\tcarol.RPC.SendPayment(req)\n\t}\n\n\t// At this point, all 3 nodes should now the HTLCs active on their\n\t// channels.\n\tht.AssertActiveHtlcs(alice, payHashes...)\n\tht.AssertActiveHtlcs(bob, payHashes...)\n\tht.AssertActiveHtlcs(carol, payHashes...)\n\n\t// Wait for Alice and Carol to mark the invoices as accepted. There is\n\t// a small gap to bridge between adding the htlc to the channel and\n\t// executing the exit hop logic.\n\tfor _, stream := range invoiceStreamsCarol {\n\t\tht.AssertInvoiceState(stream, lnrpc.Invoice_ACCEPTED)\n\t}\n\n\tfor _, stream := range invoiceStreamsAlice {\n\t\tht.AssertInvoiceState(stream, lnrpc.Invoice_ACCEPTED)\n\t}\n\n\t// Increase the fee estimate so that the following force close tx will\n\t// be cpfp'ed.\n\tht.SetFeeEstimate(30000)\n\n\t// We want Carol's htlcs to expire off-chain to demonstrate bob's force\n\t// close. However, Carol will cancel her invoices to prevent force\n\t// closes, so we shut her down for now.\n\trestartCarol := ht.SuspendNode(carol)\n\n\t// We'll now mine enough blocks to trigger Bob's broadcast of his\n\t// commitment transaction due to the fact that the Carol's HTLCs are\n\t// about to timeout. With the default outgoing broadcast delta of zero,\n\t// this will be the same height as the htlc expiry height.\n\tnumBlocks := padCLTV(\n\t\tuint32(finalCltvDelta - lncfg.DefaultOutgoingBroadcastDelta),\n\t)\n\tht.MineBlocks(numBlocks)\n\n\t// Bob's force close transaction should now be found in the mempool. If\n\t// there are anchors, we also expect Bob's anchor sweep.\n\thasAnchors := lntest.CommitTypeHasAnchors(c)\n\texpectedTxes := 1\n\tif hasAnchors {\n\t\texpectedTxes = 2\n\t}\n\tht.Miner.AssertNumTxsInMempool(expectedTxes)\n\n\tcloseTx := ht.Miner.AssertOutpointInMempool(\n\t\tht.OutPointFromChannelPoint(bobChanPoint),\n\t)\n\tcloseTxid := closeTx.TxHash()\n\n\t// Restart Bob to increase the batch window duration so the sweeper\n\t// will aggregate all the pending inputs.\n\tht.RestartNodeWithExtraArgs(\n\t\tbob, []string{\"--sweeper.batchwindowduration=15s\"},\n\t)\n\n\t// Go through the closing transaction outputs, and make an index for\n\t// the HTLC outputs.\n\tsuccessOuts := make(map[wire.OutPoint]struct{})\n\ttimeoutOuts := make(map[wire.OutPoint]struct{})\n\tfor i, txOut := range closeTx.TxOut {\n\t\top := wire.OutPoint{\n\t\t\tHash:  closeTxid,\n\t\t\tIndex: uint32(i),\n\t\t}\n\n\t\tswitch txOut.Value {\n\t\t// If this HTLC goes towards Carol, Bob will claim it with a\n\t\t// timeout Tx. In this case the value will be the invoice\n\t\t// amount.\n\t\tcase invoiceAmt:\n\t\t\ttimeoutOuts[op] = struct{}{}\n\n\t\t// If the HTLC has direction towards Alice, Bob will claim it\n\t\t// with the success TX when he learns the preimage. In this\n\t\t// case one extra sat will be on the output, because of the\n\t\t// routing fee.\n\t\tcase invoiceAmt + 1:\n\t\t\tsuccessOuts[op] = struct{}{}\n\t\t}\n\t}\n\n\t// Once bob has force closed, we can restart carol.\n\trequire.NoError(ht, restartCarol())\n\n\t// Mine a block to confirm the closing transaction.\n\tht.MineBlocksAndAssertNumTxes(1, expectedTxes)\n\n\t// Let Alice settle her invoices. When Bob now gets the preimages, he\n\t// has no other option than to broadcast his second-level transactions\n\t// to claim the money.\n\tfor _, preimage := range alicePreimages {\n\t\talice.RPC.SettleInvoice(preimage[:])\n\t}\n\n\tswitch c {\n\t// With the closing transaction confirmed, we should expect Bob's HTLC\n\t// timeout transactions to be broadcast due to the expiry being reached.\n\t// We will also expect the success transactions, since he learnt the\n\t// preimages from Alice. We also expect Carol to sweep her commitment\n\t// output.\n\tcase lnrpc.CommitmentType_LEGACY:\n\t\texpectedTxes = 2*numInvoices + 1\n\n\t// In case of anchors, all success transactions will be aggregated into\n\t// one, the same is the case for the timeout transactions. In this case\n\t// Carol will also sweep her commitment and anchor output as separate\n\t// txs (since it will be low fee).\n\tcase lnrpc.CommitmentType_ANCHORS,\n\t\tlnrpc.CommitmentType_SCRIPT_ENFORCED_LEASE:\n\t\texpectedTxes = 4\n\n\tdefault:\n\t\tht.Fatalf(\"unhandled commitment type %v\", c)\n\t}\n\ttxes := ht.Miner.GetNumTxsFromMempool(expectedTxes)\n\n\t// Since Bob can aggregate the transactions, we expect a single\n\t// transaction, that have multiple spends from the commitment.\n\tvar (\n\t\ttimeoutTxs []*chainhash.Hash\n\t\tsuccessTxs []*chainhash.Hash\n\t)\n\tfor _, tx := range txes {\n\t\ttxid := tx.TxHash()\n\n\t\tfor i := range tx.TxIn {\n\t\t\tprevOp := tx.TxIn[i].PreviousOutPoint\n\t\t\tif _, ok := successOuts[prevOp]; ok {\n\t\t\t\tsuccessTxs = append(successTxs, &txid)\n\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tif _, ok := timeoutOuts[prevOp]; ok {\n\t\t\t\ttimeoutTxs = append(timeoutTxs, &txid)\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// In case of anchor we expect all the timeout and success second\n\t// levels to be aggregated into one tx. For earlier channel types, they\n\t// will be separate transactions.\n\tif hasAnchors {\n\t\trequire.Len(ht, timeoutTxs, 1)\n\t\trequire.Len(ht, successTxs, 1)\n\t} else {\n\t\trequire.Len(ht, timeoutTxs, numInvoices)\n\t\trequire.Len(ht, successTxs, numInvoices)\n\t}\n\n\t// All mempool transactions should be spending from the commitment\n\t// transaction.\n\tht.AssertAllTxesSpendFrom(txes, closeTxid)\n\n\t// Mine a block to confirm the all the transactions, including Carol's\n\t// commitment tx, anchor tx(optional), and the second-level timeout and\n\t// success txes.\n\tht.MineBlocksAndAssertNumTxes(1, expectedTxes)\n\n\t// At this point, Bob should have broadcast his second layer success\n\t// transaction, and should have sent it to the nursery for incubation,\n\t// or to the sweeper for sweeping.\n\tht.AssertNumPendingForceClose(bob, 1)\n\n\t// For this channel, we also check the number of HTLCs and the stage\n\t// are correct.\n\tht.AssertNumHTLCsAndStage(bob, bobChanPoint, numInvoices*2, 2)\n\n\tif c != lnrpc.CommitmentType_SCRIPT_ENFORCED_LEASE {\n\t\t// If we then mine additional blocks, Bob can sweep his\n\t\t// commitment output.\n\t\tht.MineBlocks(defaultCSV - 2)\n\n\t\t// Find the commitment sweep.\n\t\tbobCommitSweep := ht.Miner.GetNumTxsFromMempool(1)[0]\n\t\tht.AssertTxSpendFrom(bobCommitSweep, closeTxid)\n\n\t\t// Also ensure it is not spending from any of the HTLC output.\n\t\tfor _, txin := range bobCommitSweep.TxIn {\n\t\t\tfor _, timeoutTx := range timeoutTxs {\n\t\t\t\trequire.NotEqual(ht, *timeoutTx,\n\t\t\t\t\ttxin.PreviousOutPoint.Hash,\n\t\t\t\t\t\"found unexpected spend of timeout tx\")\n\t\t\t}\n\n\t\t\tfor _, successTx := range successTxs {\n\t\t\t\trequire.NotEqual(ht, *successTx,\n\t\t\t\t\ttxin.PreviousOutPoint.Hash,\n\t\t\t\t\t\"found unexpected spend of success tx\")\n\t\t\t}\n\t\t}\n\t}\n\n\t// We now restart Bob with a much larger batch window duration since it\n\t// takes some time to aggregate all the 10 inputs below.\n\tht.RestartNodeWithExtraArgs(\n\t\tbob, []string{\"--sweeper.batchwindowduration=45s\"},\n\t)\n\n\tswitch c {\n\t// In case this is a non-anchor channel type, we must mine 2 blocks, as\n\t// the nursery waits an extra block before sweeping. Before the blocks\n\t// are mined, we should expect to see Bob's commit sweep in the mempool.\n\tcase lnrpc.CommitmentType_LEGACY:\n\t\tht.MineBlocksAndAssertNumTxes(2, 1)\n\n\t// Mining one additional block, Bob's second level tx is mature, and he\n\t// can sweep the output. Before the blocks are mined, we should expect\n\t// to see Bob's commit sweep in the mempool.\n\tcase lnrpc.CommitmentType_ANCHORS:\n\t\tht.MineBlocksAndAssertNumTxes(1, 1)\n\n\t// Since Bob is the initiator of the Bob-Carol script-enforced leased\n\t// channel, he incurs an additional CLTV when sweeping outputs back to\n\t// his wallet. We'll need to mine enough blocks for the timelock to\n\t// expire to prompt his broadcast.\n\tcase lnrpc.CommitmentType_SCRIPT_ENFORCED_LEASE:\n\t\tresp := bob.RPC.PendingChannels()\n\t\trequire.Len(ht, resp.PendingForceClosingChannels, 1)\n\t\tforceCloseChan := resp.PendingForceClosingChannels[0]\n\t\trequire.Positive(ht, forceCloseChan.BlocksTilMaturity)\n\t\tnumBlocks := uint32(forceCloseChan.BlocksTilMaturity)\n\n\t\t// Add debug log.\n\t\t_, height := ht.Miner.GetBestBlock()\n\t\tbob.AddToLogf(\"itest: now mine %d blocks at height %d\",\n\t\t\tnumBlocks, height)\n\t\tht.MineBlocks(numBlocks)\n\n\tdefault:\n\t\tht.Fatalf(\"unhandled commitment type %v\", c)\n\t}\n\n\t// Make sure it spends from the second level tx.\n\tsecondLevelSweep := ht.Miner.GetNumTxsFromMempool(1)[0]\n\tbobSweep := secondLevelSweep.TxHash()\n\n\t// It should be sweeping all the second-level outputs.\n\tvar secondLvlSpends int\n\tfor _, txin := range secondLevelSweep.TxIn {\n\t\tfor _, timeoutTx := range timeoutTxs {\n\t\t\tif *timeoutTx == txin.PreviousOutPoint.Hash {\n\t\t\t\tsecondLvlSpends++\n\t\t\t}\n\t\t}\n\n\t\tfor _, successTx := range successTxs {\n\t\t\tif *successTx == txin.PreviousOutPoint.Hash {\n\t\t\t\tsecondLvlSpends++\n\t\t\t}\n\t\t}\n\t}\n\n\trequire.Equal(ht, 2*numInvoices, secondLvlSpends)\n\n\t// When we mine one additional block, that will confirm Bob's second\n\t// level sweep.  Now Bob should have no pending channels anymore, as\n\t// this just resolved it by the confirmation of the sweep transaction.\n\tblock := ht.MineBlocksAndAssertNumTxes(1, 1)[0]\n\tht.Miner.AssertTxInBlock(block, &bobSweep)\n\tht.AssertNumPendingForceClose(bob, 0)\n\n\t// THe channel with Alice is still open.\n\tht.AssertNodeNumChannels(bob, 1)\n\n\t// Carol should have no channels left (open nor pending).\n\tht.AssertNumPendingForceClose(carol, 0)\n\tht.AssertNodeNumChannels(carol, 0)\n\n\t// Coop close, no anchors.\n\tht.CloseChannel(alice, aliceChanPoint)\n}\n\n// createThreeHopNetwork creates a topology of `Alice -> Bob -> Carol`.",
      "length": 12220,
      "tokens": 1586,
      "embedding": []
    },
    {
      "slug": "func createThreeHopNetwork(ht *lntest.HarnessTest,",
      "content": "func createThreeHopNetwork(ht *lntest.HarnessTest,\n\talice, bob *node.HarnessNode, carolHodl bool, c lnrpc.CommitmentType,\n\tzeroConf bool) (*lnrpc.ChannelPoint,\n\t*lnrpc.ChannelPoint, *node.HarnessNode) {\n\n\tht.EnsureConnected(alice, bob)\n\n\t// We'll create a new node \"carol\" and have Bob connect to her.\n\t// If the carolHodl flag is set, we'll make carol always hold onto the\n\t// HTLC, this way it'll force Bob to go to chain to resolve the HTLC.\n\tcarolFlags := lntest.NodeArgsForCommitType(c)\n\tif carolHodl {\n\t\tcarolFlags = append(carolFlags, \"--hodl.exit-settle\")\n\t}\n\n\tif zeroConf {\n\t\tcarolFlags = append(\n\t\t\tcarolFlags, \"--protocol.option-scid-alias\",\n\t\t\t\"--protocol.zero-conf\",\n\t\t)\n\t}\n\tcarol := ht.NewNode(\"Carol\", carolFlags)\n\n\tht.ConnectNodes(bob, carol)\n\n\t// Make sure there are enough utxos for anchoring. Because the anchor\n\t// by itself often doesn't meet the dust limit, a utxo from the wallet\n\t// needs to be attached as an additional input. This can still lead to\n\t// a positively-yielding transaction.\n\tfor i := 0; i < 2; i++ {\n\t\tht.FundCoinsUnconfirmed(btcutil.SatoshiPerBitcoin, alice)\n\t\tht.FundCoinsUnconfirmed(btcutil.SatoshiPerBitcoin, bob)\n\t\tht.FundCoinsUnconfirmed(btcutil.SatoshiPerBitcoin, carol)\n\n\t\t// Mine 1 block to get the above coins confirmed.\n\t\tht.MineBlocks(1)\n\t}\n\n\t// We'll start the test by creating a channel between Alice and Bob,\n\t// which will act as the first leg for out multi-hop HTLC.\n\tconst chanAmt = 1000000\n\tvar aliceFundingShim *lnrpc.FundingShim\n\tvar thawHeight uint32\n\tif c == lnrpc.CommitmentType_SCRIPT_ENFORCED_LEASE {\n\t\t_, minerHeight := ht.Miner.GetBestBlock()\n\t\tthawHeight = uint32(minerHeight + thawHeightDelta)\n\t\taliceFundingShim, _ = deriveFundingShim(\n\t\t\tht, alice, bob, chanAmt, thawHeight, true,\n\t\t)\n\t}\n\n\tvar (\n\t\tcancel       context.CancelFunc\n\t\tacceptStream rpc.AcceptorClient\n\t)\n\t// If a zero-conf channel is being opened, the nodes are signalling the\n\t// zero-conf feature bit. Setup a ChannelAcceptor for the fundee.\n\tif zeroConf {\n\t\tacceptStream, cancel = bob.RPC.ChannelAcceptor()\n\t\tgo acceptChannel(ht.T, true, acceptStream)\n\t}\n\n\taliceParams := lntest.OpenChannelParams{\n\t\tAmt:            chanAmt,\n\t\tCommitmentType: c,\n\t\tFundingShim:    aliceFundingShim,\n\t\tZeroConf:       zeroConf,\n\t}\n\taliceChanPoint := ht.OpenChannel(alice, bob, aliceParams)\n\n\t// Remove the ChannelAcceptor for Bob.\n\tif zeroConf {\n\t\tcancel()\n\t}\n\n\t// We'll then create a channel from Bob to Carol. After this channel is\n\t// open, our topology looks like:  A -> B -> C.\n\tvar bobFundingShim *lnrpc.FundingShim\n\tif c == lnrpc.CommitmentType_SCRIPT_ENFORCED_LEASE {\n\t\tbobFundingShim, _ = deriveFundingShim(\n\t\t\tht, bob, carol, chanAmt, thawHeight, true,\n\t\t)\n\t}\n\n\t// Setup a ChannelAcceptor for Carol if a zero-conf channel open is\n\t// being attempted.\n\tif zeroConf {\n\t\tacceptStream, cancel = carol.RPC.ChannelAcceptor()\n\t\tgo acceptChannel(ht.T, true, acceptStream)\n\t}\n\n\tbobParams := lntest.OpenChannelParams{\n\t\tAmt:            chanAmt,\n\t\tCommitmentType: c,\n\t\tFundingShim:    bobFundingShim,\n\t\tZeroConf:       zeroConf,\n\t}\n\tbobChanPoint := ht.OpenChannel(bob, carol, bobParams)\n\n\t// Remove the ChannelAcceptor for Carol.\n\tif zeroConf {\n\t\tcancel()\n\t}\n\n\t// Make sure alice and carol know each other's channels.\n\tht.AssertTopologyChannelOpen(alice, bobChanPoint)\n\tht.AssertTopologyChannelOpen(carol, aliceChanPoint)\n\n\treturn aliceChanPoint, bobChanPoint, carol\n}\n",
      "length": 3228,
      "tokens": 406,
      "embedding": []
    }
  ]
}