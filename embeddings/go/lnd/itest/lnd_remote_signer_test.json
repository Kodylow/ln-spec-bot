{
  "filepath": "../implementations/go/lnd/itest/lnd_remote_signer_test.go",
  "package": "itest",
  "sections": [
    {
      "slug": "func testRemoteSigner(ht *lntest.HarnessTest) {",
      "content": "func testRemoteSigner(ht *lntest.HarnessTest) {\n\ttype testCase struct {\n\t\tname       string\n\t\trandomSeed bool\n\t\tsendCoins  bool\n\t\tfn         func(tt *lntest.HarnessTest,\n\t\t\two, carol *node.HarnessNode)\n\t}\n\n\tsubTests := []testCase{{\n\t\tname:       \"random seed\",\n\t\trandomSeed: true,\n\t\tfn: func(tt *lntest.HarnessTest, wo, carol *node.HarnessNode) {\n\t\t\t// Nothing more to test here.\n\t\t},\n\t}, {\n\t\tname: \"account import\",\n\t\tfn: func(tt *lntest.HarnessTest, wo, carol *node.HarnessNode) {\n\t\t\trunWalletImportAccountScenario(\n\t\t\t\ttt, walletrpc.AddressType_WITNESS_PUBKEY_HASH,\n\t\t\t\tcarol, wo,\n\t\t\t)\n\t\t},\n\t}, {\n\t\tname:      \"basic channel open close\",\n\t\tsendCoins: true,\n\t\tfn: func(tt *lntest.HarnessTest, wo, carol *node.HarnessNode) {\n\t\t\trunBasicChannelCreationAndUpdates(tt, wo, carol)\n\t\t},\n\t}, {\n\t\tname:      \"channel funding input types\",\n\t\tsendCoins: false,\n\t\tfn: func(tt *lntest.HarnessTest, wo, carol *node.HarnessNode) {\n\t\t\trunChannelFundingInputTypes(tt, carol, wo)\n\t\t},\n\t}, {\n\t\tname:      \"async payments\",\n\t\tsendCoins: true,\n\t\tfn: func(tt *lntest.HarnessTest, wo, carol *node.HarnessNode) {\n\t\t\trunAsyncPayments(tt, wo, carol)\n\t\t},\n\t}, {\n\t\tname: \"shared key\",\n\t\tfn: func(tt *lntest.HarnessTest, wo, carol *node.HarnessNode) {\n\t\t\trunDeriveSharedKey(tt, wo)\n\t\t},\n\t}, {\n\t\tname:      \"cpfp\",\n\t\tsendCoins: true,\n\t\tfn: func(tt *lntest.HarnessTest, wo, carol *node.HarnessNode) {\n\t\t\trunCPFP(tt, wo, carol)\n\t\t},\n\t}, {\n\t\tname:       \"psbt\",\n\t\trandomSeed: true,\n\t\tfn: func(tt *lntest.HarnessTest, wo, carol *node.HarnessNode) {\n\t\t\trunPsbtChanFunding(tt, carol, wo)\n\t\t\trunSignPsbtSegWitV0P2WKH(tt, wo)\n\t\t\trunSignPsbtSegWitV1KeySpendBip86(tt, wo)\n\t\t\trunSignPsbtSegWitV1KeySpendRootHash(tt, wo)\n\t\t\trunSignPsbtSegWitV1ScriptSpend(tt, wo)\n\n\t\t\t// The above tests all make sure we can sign for keys\n\t\t\t// that aren't in the wallet. But we also want to make\n\t\t\t// sure we can fund and then sign PSBTs from our wallet.\n\t\t\trunFundAndSignPsbt(ht, wo)\n\t\t},\n\t}, {\n\t\tname:      \"sign output raw\",\n\t\tsendCoins: true,\n\t\tfn: func(tt *lntest.HarnessTest, wo, carol *node.HarnessNode) {\n\t\t\trunSignOutputRaw(tt, wo)\n\t\t},\n\t}, {\n\t\tname:      \"sign verify msg\",\n\t\tsendCoins: true,\n\t\tfn: func(tt *lntest.HarnessTest, wo, carol *node.HarnessNode) {\n\t\t\trunSignVerifyMessage(tt, wo)\n\t\t},\n\t}, {\n\t\tname:       \"taproot\",\n\t\tsendCoins:  true,\n\t\trandomSeed: true,\n\t\tfn: func(tt *lntest.HarnessTest, wo, carol *node.HarnessNode) {\n\t\t\ttestTaprootSendCoinsKeySpendBip86(tt, wo)\n\t\t\ttestTaprootComputeInputScriptKeySpendBip86(tt, wo)\n\t\t\ttestTaprootSignOutputRawScriptSpend(tt, wo)\n\t\t\ttestTaprootSignOutputRawKeySpendBip86(tt, wo)\n\t\t\ttestTaprootSignOutputRawKeySpendRootHash(tt, wo)\n\n\t\t\tmuSig2Versions := []signrpc.MuSig2Version{\n\t\t\t\tsignrpc.MuSig2Version_MUSIG2_VERSION_V040,\n\t\t\t\tsignrpc.MuSig2Version_MUSIG2_VERSION_V100RC2,\n\t\t\t}\n\t\t\tfor _, version := range muSig2Versions {\n\t\t\t\ttestTaprootMuSig2KeySpendRootHash(\n\t\t\t\t\ttt, wo, version,\n\t\t\t\t)\n\t\t\t\ttestTaprootMuSig2ScriptSpend(tt, wo, version)\n\t\t\t\ttestTaprootMuSig2KeySpendBip86(tt, wo, version)\n\t\t\t\ttestTaprootMuSig2CombinedLeafKeySpend(\n\t\t\t\t\ttt, wo, version,\n\t\t\t\t)\n\t\t\t}\n\t\t},\n\t}}\n\n\tprepareTest := func(st *lntest.HarnessTest,\n\t\tsubTest testCase) (*node.HarnessNode,\n\t\t*node.HarnessNode, *node.HarnessNode) {\n\n\t\t// Signer is our signing node and has the wallet with the full\n\t\t// master private key. We test that we can create the watch-only\n\t\t// wallet from the exported accounts but also from a static key\n\t\t// to make sure the derivation of the account public keys is\n\t\t// correct in both cases.\n\t\tpassword := []byte(\"itestpassword\")\n\t\tvar (\n\t\t\tsignerNodePubKey  = nodePubKey\n\t\t\twatchOnlyAccounts = deriveCustomScopeAccounts(ht.T)\n\t\t\tsigner            *node.HarnessNode\n\t\t\terr               error\n\t\t)\n\t\tif !subTest.randomSeed {\n\t\t\tsigner = st.RestoreNodeWithSeed(\n\t\t\t\t\"Signer\", nil, password, nil, rootKey, 0, nil,\n\t\t\t)\n\t\t} else {\n\t\t\tsigner = st.NewNode(\"Signer\", nil)\n\t\t\tsignerNodePubKey = signer.PubKeyStr\n\n\t\t\trpcAccts := signer.RPC.ListAccounts(\n\t\t\t\t&walletrpc.ListAccountsRequest{},\n\t\t\t)\n\n\t\t\twatchOnlyAccounts, err = walletrpc.AccountsToWatchOnly(\n\t\t\t\trpcAccts.Accounts,\n\t\t\t)\n\t\t\trequire.NoError(st, err)\n\t\t}\n\n\t\t// WatchOnly is the node that has a watch-only wallet and uses\n\t\t// the Signer node for any operation that requires access to\n\t\t// private keys.\n\t\twatchOnly := st.NewNodeRemoteSigner(\n\t\t\t\"WatchOnly\", []string{\n\t\t\t\t\"--remotesigner.enable\",\n\t\t\t\tfmt.Sprintf(\n\t\t\t\t\t\"--remotesigner.rpchost=localhost:%d\",\n\t\t\t\t\tsigner.Cfg.RPCPort,\n\t\t\t\t),\n\t\t\t\tfmt.Sprintf(\n\t\t\t\t\t\"--remotesigner.tlscertpath=%s\",\n\t\t\t\t\tsigner.Cfg.TLSCertPath,\n\t\t\t\t),\n\t\t\t\tfmt.Sprintf(\n\t\t\t\t\t\"--remotesigner.macaroonpath=%s\",\n\t\t\t\t\tsigner.Cfg.AdminMacPath,\n\t\t\t\t),\n\t\t\t}, password, &lnrpc.WatchOnly{\n\t\t\t\tMasterKeyBirthdayTimestamp: 0,\n\t\t\t\tMasterKeyFingerprint:       nil,\n\t\t\t\tAccounts:                   watchOnlyAccounts,\n\t\t\t},\n\t\t)\n\n\t\tresp := watchOnly.RPC.GetInfo()\n\t\trequire.Equal(st, signerNodePubKey, resp.IdentityPubkey)\n\n\t\tif subTest.sendCoins {\n\t\t\tst.FundCoins(btcutil.SatoshiPerBitcoin, watchOnly)\n\t\t\tht.AssertWalletAccountBalance(\n\t\t\t\twatchOnly, \"default\",\n\t\t\t\tbtcutil.SatoshiPerBitcoin, 0,\n\t\t\t)\n\t\t}\n\n\t\tcarol := st.NewNode(\"carol\", nil)\n\t\tst.EnsureConnected(watchOnly, carol)\n\n\t\treturn signer, watchOnly, carol\n\t}\n\n\tfor _, testCase := range subTests {\n\t\tsubTest := testCase\n\n\t\tsuccess := ht.Run(subTest.name, func(tt *testing.T) {\n\t\t\t// Skip the cleanup here as no standby node is used.\n\t\t\tst := ht.Subtest(tt)\n\n\t\t\t_, watchOnly, carol := prepareTest(st, subTest)\n\t\t\tsubTest.fn(st, watchOnly, carol)\n\t\t})\n\n\t\tif !success {\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// deriveCustomScopeAccounts derives the first 255 default accounts of the custom lnd\n// internal key scope.",
      "length": 5380,
      "tokens": 569,
      "embedding": []
    },
    {
      "slug": "func deriveCustomScopeAccounts(t *testing.T) []*lnrpc.WatchOnlyAccount {",
      "content": "func deriveCustomScopeAccounts(t *testing.T) []*lnrpc.WatchOnlyAccount {\n\tallAccounts := make([]*lnrpc.WatchOnlyAccount, 0, 255+len(accounts))\n\tallAccounts = append(allAccounts, accounts...)\n\n\textendedRootKey, err := hdkeychain.NewKeyFromString(rootKey)\n\trequire.NoError(t, err)\n\n\tpath := []uint32{\n\t\tkeychain.BIP0043Purpose + hdkeychain.HardenedKeyStart,\n\t\tharnessNetParams.HDCoinType + hdkeychain.HardenedKeyStart,\n\t}\n\tcoinTypeKey, err := derivePath(extendedRootKey, path)\n\trequire.NoError(t, err)\n\tfor idx := uint32(0); idx <= 255; idx++ {\n\t\taccountPath := []uint32{idx + hdkeychain.HardenedKeyStart}\n\t\taccountKey, err := derivePath(coinTypeKey, accountPath)\n\t\trequire.NoError(t, err)\n\n\t\taccountXPub, err := accountKey.Neuter()\n\t\trequire.NoError(t, err)\n\n\t\tallAccounts = append(allAccounts, &lnrpc.WatchOnlyAccount{\n\t\t\tPurpose:  keychain.BIP0043Purpose,\n\t\t\tCoinType: harnessNetParams.HDCoinType,\n\t\t\tAccount:  idx,\n\t\t\tXpub:     accountXPub.String(),\n\t\t})\n\t}\n\n\treturn allAccounts\n}\n\n// derivePath derives the given path from an extended key.",
      "length": 938,
      "tokens": 86,
      "embedding": []
    },
    {
      "slug": "func derivePath(key *hdkeychain.ExtendedKey, path []uint32) (",
      "content": "func derivePath(key *hdkeychain.ExtendedKey, path []uint32) (\n\t*hdkeychain.ExtendedKey, error) {\n\n\tvar (\n\t\tcurrentKey = key\n\t\terr        error\n\t)\n\tfor _, pathPart := range path {\n\t\tcurrentKey, err = currentKey.Derive(pathPart)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn currentKey, nil\n}\n",
      "length": 221,
      "tokens": 36,
      "embedding": []
    }
  ]
}