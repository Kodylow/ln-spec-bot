{
  "filepath": "../implementations/go/lnd/itest/lnd_switch_test.go",
  "package": "itest",
  "sections": [
    {
      "slug": "func testSwitchCircuitPersistence(ht *lntest.HarnessTest) {",
      "content": "func testSwitchCircuitPersistence(ht *lntest.HarnessTest) {\n\t// Setup our test scenario. We should now have four nodes running with\n\t// three channels.\n\ts := setupScenarioFourNodes(ht)\n\tdefer s.cleanUp()\n\n\t// Restart the intermediaries and the sender.\n\tht.RestartNode(s.dave)\n\tht.RestartNode(s.alice)\n\tht.RestartNode(s.bob)\n\n\t// Ensure all of the intermediate links are reconnected.\n\tht.EnsureConnected(s.alice, s.dave)\n\tht.EnsureConnected(s.bob, s.alice)\n\n\t// Ensure all nodes in the network still have 5 outstanding htlcs.\n\ts.assertHTLCs(ht, numPayments)\n\n\t// Now restart carol without hodl mode, to settle back the outstanding\n\t// payments.\n\ts.carol.SetExtraArgs(nil)\n\tht.RestartNode(s.carol)\n\n\tht.EnsureConnected(s.dave, s.carol)\n\n\t// After the payments settle, there should be no active htlcs on any of\n\t// the nodes in the network.\n\ts.assertHTLCs(ht, 0)\n\n\t// When asserting the amount of satoshis moved, we'll factor in the\n\t// default base fee, as we didn't modify the fee structure when\n\t// creating the seed nodes in the network.\n\n\t// At this point all the channels within our proto network should be\n\t// shifted by 5k satoshis in the direction of Carol, the sink within\n\t// the payment flow generated above. The order of asserts corresponds\n\t// to increasing of time is needed to embed the HTLC in commitment\n\t// transaction, in channel Bob->Alice->David->Carol, order is Carol,\n\t// David, Alice, Bob.\n\tvar amountPaid = int64(5000)\n\ts.assertAmoutPaid(ht, amountPaid, numPayments)\n\n\t// Lastly, we will send one more payment to ensure all channels are\n\t// still functioning properly.\n\tfinalInvoice := &lnrpc.Invoice{\n\t\tMemo:  \"testing\",\n\t\tValue: paymentAmt,\n\t}\n\tresp := s.carol.RPC.AddInvoice(finalInvoice)\n\tpayReqs := []string{resp.PaymentRequest}\n\n\t// Using Carol as the source, pay to the 5 invoices from Bob created\n\t// above.\n\tht.CompletePaymentRequests(s.bob, payReqs)\n\n\tamountPaid = int64(6000)\n\ts.assertAmoutPaid(ht, amountPaid, numPayments+1)\n}\n\n// testSwitchOfflineDelivery constructs a set of multihop payments, and tests\n// that the returning payments are not lost if a peer on the backwards path is\n// offline when the settle/fails are received. We expect the payments to be\n// buffered in memory, and transmitted as soon as the disconnect link comes back\n// online.\n//\n// The general flow of this test:\n//  1. Carol --> Dave --> Alice --> Bob  forward payment\n//  2. Carol --- Dave  X  Alice --- Bob  disconnect intermediaries\n//  3. Carol --- Dave  X  Alice <-- Bob  settle last hop\n//  4. Carol <-- Dave <-- Alice --- Bob  reconnect, expect settle to propagate",
      "length": 2456,
      "tokens": 366,
      "embedding": []
    },
    {
      "slug": "func testSwitchOfflineDelivery(ht *lntest.HarnessTest) {",
      "content": "func testSwitchOfflineDelivery(ht *lntest.HarnessTest) {\n\t// Setup our test scenario. We should now have four nodes running with\n\t// three channels.\n\ts := setupScenarioFourNodes(ht)\n\tdefer s.cleanUp()\n\n\t// First, disconnect Dave and Alice so that their link is broken.\n\tht.DisconnectNodes(s.dave, s.alice)\n\n\t// Then, reconnect them to ensure Dave doesn't just fail back the htlc.\n\tht.ConnectNodes(s.dave, s.alice)\n\n\t// Wait to ensure that the payment remain are not failed back after\n\t// reconnecting. All node should report the number payments initiated\n\t// for the duration of the interval.\n\ts.assertHTLCs(ht, numPayments)\n\n\t// Now, disconnect Dave from Alice again before settling back the\n\t// payment.\n\tht.DisconnectNodes(s.dave, s.alice)\n\n\t// Now restart carol without hodl mode, to settle back the outstanding\n\t// payments.\n\ts.carol.SetExtraArgs(nil)\n\tht.RestartNode(s.carol)\n\n\t// Wait for Carol to report no outstanding htlcs.\n\tht.AssertNumActiveHtlcs(s.carol, 0)\n\n\t// Now that the settles have reached Dave, reconnect him with Alice,\n\t// allowing the settles to return to the sender.\n\tht.EnsureConnected(s.dave, s.alice)\n\n\t// Wait until all outstanding htlcs in the network have been settled.\n\ts.assertHTLCs(ht, 0)\n\n\t// At this point all the channels within our proto network should be\n\t// shifted by 5k satoshis in the direction of Carol, the sink within the\n\t// payment flow generated above. The order of asserts corresponds to\n\t// increasing of time is needed to embed the HTLC in commitment\n\t// transaction, in channel Bob->Alice->David->Carol, order is Carol,\n\t// David, Alice, Bob.\n\tvar amountPaid = int64(5000)\n\ts.assertAmoutPaid(ht, amountPaid, numPayments)\n\n\t// Lastly, we will send one more payment to ensure all channels are\n\t// still functioning properly.\n\tfinalInvoice := &lnrpc.Invoice{\n\t\tMemo:  \"testing\",\n\t\tValue: paymentAmt,\n\t}\n\tresp := s.carol.RPC.AddInvoice(finalInvoice)\n\tpayReqs := []string{resp.PaymentRequest}\n\n\t// Using Carol as the source, pay to the 5 invoices from Bob created\n\t// above.\n\tht.CompletePaymentRequests(s.bob, payReqs)\n\n\tamountPaid = int64(6000)\n\ts.assertAmoutPaid(ht, amountPaid, numPayments+1)\n}\n\n// testSwitchOfflineDeliveryPersistence constructs a set of multihop payments,\n// and tests that the returning payments are not lost if a peer on the backwards\n// path is offline when the settle/fails are received AND the peer buffering the\n// responses is completely restarts. We expect the payments to be reloaded from\n// disk, and transmitted as soon as the intermediaries are reconnected.\n//\n// The general flow of this test:\n//  1. Carol --> Dave --> Alice --> Bob  forward payment\n//  2. Carol --- Dave  X  Alice --- Bob  disconnect intermediaries\n//  3. Carol --- Dave  X  Alice <-- Bob  settle last hop\n//  4. Carol --- Dave  X         X  Bob  restart Alice\n//  5. Carol <-- Dave <-- Alice --- Bob  expect settle to propagate\n//\n//nolint:dupword",
      "length": 2769,
      "tokens": 415,
      "embedding": []
    },
    {
      "slug": "func testSwitchOfflineDeliveryPersistence(ht *lntest.HarnessTest) {",
      "content": "func testSwitchOfflineDeliveryPersistence(ht *lntest.HarnessTest) {\n\t// Setup our test scenario. We should now have four nodes running with\n\t// three channels.\n\ts := setupScenarioFourNodes(ht)\n\tdefer s.cleanUp()\n\n\t// Disconnect the two intermediaries, Alice and Dave, by shutting down\n\t// Alice.\n\trestartAlice := ht.SuspendNode(s.alice)\n\n\t// Now restart carol without hodl mode, to settle back the outstanding\n\t// payments.\n\ts.carol.SetExtraArgs(nil)\n\tht.RestartNode(s.carol)\n\n\t// Make Carol and Dave are reconnected before waiting for the htlcs to\n\t// clear.\n\tht.EnsureConnected(s.dave, s.carol)\n\n\t// Wait for Carol to report no outstanding htlcs, and also for Dave to\n\t// receive all the settles from Carol.\n\tht.AssertNumActiveHtlcs(s.carol, 0)\n\t// As an intermediate node, Dave should now have zero outgoing HTLCs\n\t// and 5 incoming HTLCs from Alice.\n\tht.AssertNumActiveHtlcs(s.dave, numPayments)\n\n\t// Finally, restart dave who received the settles, but was unable to\n\t// deliver them to Alice since they were disconnected.\n\tht.RestartNode(s.dave)\n\trequire.NoError(ht, restartAlice(), \"restart alice failed\")\n\n\t// Force Dave and Alice to reconnect before waiting for the htlcs to\n\t// clear.\n\tht.EnsureConnected(s.dave, s.alice)\n\n\t// After reconnection succeeds, the settles should be propagated all\n\t// the way back to the sender. All nodes should report no active htlcs.\n\ts.assertHTLCs(ht, 0)\n\n\t// When asserting the amount of satoshis moved, we'll factor in the\n\t// default base fee, as we didn't modify the fee structure when\n\t// creating the seed nodes in the network.\n\n\t// At this point all the channels within our proto network should be\n\t// shifted by 5k satoshis in the direction of Carol, the sink within the\n\t// payment flow generated above. The order of asserts corresponds to\n\t// increasing of time is needed to embed the HTLC in commitment\n\t// transaction, in channel Bob->Alice->David->Carol, order is Carol,\n\t// David, Alice, Bob.\n\tvar amountPaid = int64(5000)\n\ts.assertAmoutPaid(ht, amountPaid, numPayments)\n\n\t// Lastly, we will send one more payment to ensure all channels are\n\t// still functioning properly.\n\tfinalInvoice := &lnrpc.Invoice{\n\t\tMemo:  \"testing\",\n\t\tValue: paymentAmt,\n\t}\n\tresp := s.carol.RPC.AddInvoice(finalInvoice)\n\tpayReqs := []string{resp.PaymentRequest}\n\n\t// Before completing the final payment request, ensure that the\n\t// connection between Dave and Carol has been healed.\n\tht.EnsureConnected(s.dave, s.carol)\n\n\t// Using Carol as the source, pay to the 5 invoices from Bob created\n\t// above.\n\tht.CompletePaymentRequests(s.bob, payReqs)\n\n\tamountPaid = int64(6000)\n\ts.assertAmoutPaid(ht, amountPaid, numPayments+1)\n}\n\n// testSwitchOfflineDeliveryOutgoingOffline constructs a set of multihop\n// payments, and tests that the returning payments are not lost if a peer on\n// the backwards path is offline when the settle/fails are received AND the\n// peer buffering the responses is completely restarts. We expect the payments\n// to be reloaded from disk, and transmitted as soon as the intermediaries are\n// reconnected.\n//\n// The general flow of this test:\n//  1. Carol --> Dave --> Alice --> Bob  forward payment\n//  2. Carol --- Dave  X  Alice --- Bob  disconnect intermediaries\n//  3. Carol --- Dave  X  Alice <-- Bob  settle last hop\n//  4. Carol --- Dave  X         X       shutdown Bob, restart Alice\n//  5. Carol <-- Dave <-- Alice  X       expect settle to propagate\n//\n//nolint:dupword",
      "length": 3278,
      "tokens": 492,
      "embedding": []
    },
    {
      "slug": "func testSwitchOfflineDeliveryOutgoingOffline(ht *lntest.HarnessTest) {",
      "content": "func testSwitchOfflineDeliveryOutgoingOffline(ht *lntest.HarnessTest) {\n\t// Setup our test scenario. We should now have four nodes running with\n\t// three channels. Note that we won't call the cleanUp function here as\n\t// we will manually stop the node Carol and her channel.\n\ts := setupScenarioFourNodes(ht)\n\n\t// Disconnect the two intermediaries, Alice and Dave, so that when carol\n\t// restarts, the response will be held by Dave.\n\trestartAlice := ht.SuspendNode(s.alice)\n\n\t// Now restart carol without hodl mode, to settle back the outstanding\n\t// payments.\n\ts.carol.SetExtraArgs(nil)\n\tht.RestartNode(s.carol)\n\n\t// Wait for Carol to report no outstanding htlcs.\n\tht.AssertNumActiveHtlcs(s.carol, 0)\n\t// As an intermediate node, Dave should now have zero outgoing HTLCs\n\t// and 5 incoming HTLCs from Alice.\n\tht.AssertNumActiveHtlcs(s.dave, numPayments)\n\n\t// Now check that the total amount was transferred from Dave to Carol.\n\t// The amount transferred should be exactly equal to the invoice total\n\t// payment amount, 5k satsohis.\n\tconst amountPaid = int64(5000)\n\tht.AssertAmountPaid(\n\t\t\"Dave(local) => Carol(remote)\", s.carol,\n\t\ts.chanPointCarolDave, int64(0), amountPaid,\n\t)\n\tht.AssertAmountPaid(\n\t\t\"Dave(local) => Carol(remote)\", s.dave,\n\t\ts.chanPointCarolDave, amountPaid, int64(0),\n\t)\n\n\t// Shutdown carol and leave her offline for the rest of the test. This\n\t// is critical, as we wish to see if Dave can propragate settles even if\n\t// the outgoing link is never revived.\n\tht.Shutdown(s.carol)\n\n\t// Now restart Dave, ensuring he is both persisting the settles, and is\n\t// able to reforward them to Alice after recovering from a restart.\n\tht.RestartNode(s.dave)\n\trequire.NoErrorf(ht, restartAlice(), \"restart alice failed\")\n\n\t// Ensure that Dave is reconnected to Alice before waiting for the\n\t// htlcs to clear.\n\tht.EnsureConnected(s.dave, s.alice)\n\n\t// Since Carol has been shutdown permanently, we will wait until all\n\t// other nodes in the network report no active htlcs.\n\tht.AssertNumActiveHtlcs(s.alice, 0)\n\tht.AssertNumActiveHtlcs(s.bob, 0)\n\tht.AssertNumActiveHtlcs(s.dave, 0)\n\n\t// When asserting the amount of satoshis moved, we'll factor in the\n\t// default base fee, as we didn't modify the fee structure when\n\t// creating the seed nodes in the network.\n\n\t// At this point, all channels (minus Carol, who is shutdown) should\n\t// show a shift of 5k satoshis towards Carol.  The order of asserts\n\t// corresponds to increasing of time is needed to embed the HTLC in\n\t// commitment transaction, in channel Bob->Alice->David, order is\n\t// David, Alice, Bob.\n\tht.AssertAmountPaid(\n\t\t\"Alice(local) => Dave(remote)\", s.dave, s.chanPointDaveAlice,\n\t\tint64(0), amountPaid+(baseFee*numPayments),\n\t)\n\tht.AssertAmountPaid(\n\t\t\"Alice(local) => Dave(remote)\", s.alice, s.chanPointDaveAlice,\n\t\tamountPaid+(baseFee*numPayments), int64(0),\n\t)\n\tht.AssertAmountPaid(\n\t\t\"Bob(local) => Alice(remote)\", s.alice, s.chanPointAliceBob,\n\t\tint64(0), amountPaid+((baseFee*numPayments)*2),\n\t)\n\tht.AssertAmountPaid(\n\t\t\"Bob(local) => Alice(remote)\", s.bob, s.chanPointAliceBob,\n\t\tamountPaid+(baseFee*numPayments)*2, int64(0),\n\t)\n\n\tht.CloseChannel(s.alice, s.chanPointAliceBob)\n\tht.CloseChannel(s.dave, s.chanPointDaveAlice)\n}\n\n// scenarioFourNodes specifies a scenario which we have a topology that has\n// four nodes and three channels.",
      "length": 3161,
      "tokens": 419,
      "embedding": []
    },
    {
      "slug": "type scenarioFourNodes struct {",
      "content": "type scenarioFourNodes struct {\n\talice *node.HarnessNode\n\tbob   *node.HarnessNode\n\tcarol *node.HarnessNode\n\tdave  *node.HarnessNode\n\n\tchanPointAliceBob  *lnrpc.ChannelPoint\n\tchanPointCarolDave *lnrpc.ChannelPoint\n\tchanPointDaveAlice *lnrpc.ChannelPoint\n\n\tcleanUp func()\n}\n\n// setupScenarioFourNodes creates a topology for switch tests. It will create\n// two new nodes: Carol and Dave, such that there will be a 4 nodes, 3 channel\n// topology. Dave will make a channel with Alice, and Carol with Dave. After\n// this setup, the network topology should now look like:\n//\n//\tCarol -> Dave -> Alice -> Bob\n//\n// Once the network is created, Carol will generate 5 invoices and Bob will pay\n// them using the above path.\n//\n// NOTE: caller needs to call cleanUp to clean the nodes and channels created\n// from this setup.",
      "length": 759,
      "tokens": 119,
      "embedding": []
    },
    {
      "slug": "func setupScenarioFourNodes(ht *lntest.HarnessTest) *scenarioFourNodes {",
      "content": "func setupScenarioFourNodes(ht *lntest.HarnessTest) *scenarioFourNodes {\n\tconst (\n\t\tchanAmt = btcutil.Amount(1000000)\n\t\tpushAmt = btcutil.Amount(900000)\n\t)\n\n\tparams := lntest.OpenChannelParams{\n\t\tAmt:     chanAmt,\n\t\tPushAmt: pushAmt,\n\t}\n\n\t// Grab the standby nodes.\n\talice, bob := ht.Alice, ht.Bob\n\n\t// As preliminary setup, we'll create two new nodes: Carol and Dave,\n\t// such that we now have a 4 node, 3 channel topology. Dave will make\n\t// a channel with Alice, and Carol with Dave. After this setup, the\n\t// network topology should now look like:\n\t//     Carol -> Dave -> Alice -> Bob\n\t//\n\t// First, we'll create Dave and establish a channel to Alice.\n\tdave := ht.NewNode(\"Dave\", nil)\n\tht.ConnectNodes(dave, alice)\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, dave)\n\n\t// Next, we'll create Carol and establish a channel to from her to\n\t// Dave. Carol is started in htlchodl mode so that we can disconnect\n\t// the intermediary hops before starting the settle.\n\tcarol := ht.NewNode(\"Carol\", []string{\"--hodl.exit-settle\"})\n\tht.ConnectNodes(carol, dave)\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, carol)\n\n\t// Open channels in batch to save blocks mined.\n\treqs := []*lntest.OpenChannelRequest{\n\t\t{Local: alice, Remote: bob, Param: params},\n\t\t{Local: dave, Remote: alice, Param: params},\n\t\t{Local: carol, Remote: dave, Param: params},\n\t}\n\tresp := ht.OpenMultiChannelsAsync(reqs)\n\n\t// Wait for all nodes to have seen all channels.\n\tnodes := []*node.HarnessNode{alice, bob, carol, dave}\n\tfor _, chanPoint := range resp {\n\t\tfor _, node := range nodes {\n\t\t\tht.AssertTopologyChannelOpen(node, chanPoint)\n\t\t}\n\t}\n\n\tchanPointAliceBob := resp[0]\n\tchanPointDaveAlice := resp[1]\n\tchanPointCarolDave := resp[2]\n\n\t// Create 5 invoices for Carol, which expect a payment from Bob for 1k\n\t// satoshis with a different preimage each time.\n\tpayReqs, _, _ := ht.CreatePayReqs(carol, paymentAmt, numPayments)\n\n\t// Using Carol as the source, pay to the 5 invoices from Bob created\n\t// above.\n\tht.CompletePaymentRequestsNoWait(bob, payReqs, chanPointAliceBob)\n\n\t// Create a cleanUp to wipe the states.\n\tcleanUp := func() {\n\t\tif ht.Failed() {\n\t\t\tht.Skip(\"Skipped cleanup for failed test\")\n\t\t\treturn\n\t\t}\n\n\t\tht.CloseChannel(alice, chanPointAliceBob)\n\t\tht.CloseChannel(dave, chanPointDaveAlice)\n\t\tht.CloseChannel(carol, chanPointCarolDave)\n\t}\n\n\ts := &scenarioFourNodes{\n\t\talice, bob, carol, dave, chanPointAliceBob,\n\t\tchanPointCarolDave, chanPointDaveAlice, cleanUp,\n\t}\n\n\t// Wait until all nodes in the network have 5 outstanding htlcs.\n\ts.assertHTLCs(ht, numPayments)\n\n\treturn s\n}\n\n// assertHTLCs is a helper function which asserts the desired num of\n// HTLCs has been seen in the nodes.",
      "length": 2500,
      "tokens": 347,
      "embedding": []
    },
    {
      "slug": "func (s *scenarioFourNodes) assertHTLCs(ht *lntest.HarnessTest, num int) {",
      "content": "func (s *scenarioFourNodes) assertHTLCs(ht *lntest.HarnessTest, num int) {\n\t// Alice should have both the same number of outgoing and\n\t// incoming HTLCs.\n\tht.AssertNumActiveHtlcs(s.alice, num*2)\n\t// Bob should have num of incoming HTLCs.\n\tht.AssertNumActiveHtlcs(s.bob, num)\n\t// Dave should have both the same number of outgoing and\n\t// incoming HTLCs.\n\tht.AssertNumActiveHtlcs(s.dave, num*2)\n\t// Carol should have the num of outgoing HTLCs.\n\tht.AssertNumActiveHtlcs(s.carol, num)\n}\n\n// assertAmoutPaid is a helper method which takes a given paid amount\n// and number of payments and asserts the desired payments are made in\n// the four nodes.",
      "length": 554,
      "tokens": 83,
      "embedding": []
    },
    {
      "slug": "func (s *scenarioFourNodes) assertAmoutPaid(ht *lntest.HarnessTest,",
      "content": "func (s *scenarioFourNodes) assertAmoutPaid(ht *lntest.HarnessTest,\n\tamt int64, num int64) {\n\n\tht.AssertAmountPaid(\n\t\t\"Dave(local) => Carol(remote)\", s.carol,\n\t\ts.chanPointCarolDave, int64(0), amt,\n\t)\n\tht.AssertAmountPaid(\n\t\t\"Dave(local) => Carol(remote)\", s.dave,\n\t\ts.chanPointCarolDave, amt, int64(0),\n\t)\n\tht.AssertAmountPaid(\n\t\t\"Alice(local) => Dave(remote)\", s.dave,\n\t\ts.chanPointDaveAlice,\n\t\tint64(0), amt+(baseFee*num),\n\t)\n\tht.AssertAmountPaid(\n\t\t\"Alice(local) => Dave(remote)\", s.alice,\n\t\ts.chanPointDaveAlice,\n\t\tamt+(baseFee*num), int64(0),\n\t)\n\tht.AssertAmountPaid(\n\t\t\"Bob(local) => Alice(remote)\", s.alice,\n\t\ts.chanPointAliceBob,\n\t\tint64(0), amt+((baseFee*num)*2),\n\t)\n\tht.AssertAmountPaid(\n\t\t\"Bob(local) => Alice(remote)\", s.bob,\n\t\ts.chanPointAliceBob,\n\t\tamt+(baseFee*num)*2, int64(0),\n\t)\n}\n",
      "length": 701,
      "tokens": 60,
      "embedding": []
    }
  ]
}