{
  "filepath": "../implementations/go/lnd/itest/lnd_psbt_test.go",
  "package": "itest",
  "sections": [
    {
      "slug": "func testPsbtChanFunding(ht *lntest.HarnessTest) {",
      "content": "func testPsbtChanFunding(ht *lntest.HarnessTest) {\n\t// First, we'll create two new nodes that we'll use to open channels\n\t// between for this test. Dave gets some coins that will be used to\n\t// fund the PSBT, just to make sure that Carol has an empty wallet.\n\tcarol := ht.NewNode(\"carol\", nil)\n\tdave := ht.NewNode(\"dave\", nil)\n\n\trunPsbtChanFunding(ht, carol, dave)\n}\n\n// runPsbtChanFunding makes sure a channel can be opened between carol and dave\n// by using a Partially Signed Bitcoin Transaction that funds the channel\n// multisig funding output.",
      "length": 487,
      "tokens": 82,
      "embedding": []
    },
    {
      "slug": "func runPsbtChanFunding(ht *lntest.HarnessTest, carol, dave *node.HarnessNode) {",
      "content": "func runPsbtChanFunding(ht *lntest.HarnessTest, carol, dave *node.HarnessNode) {\n\tconst chanSize = funding.MaxBtcFundingAmount\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, dave)\n\n\t// Before we start the test, we'll ensure both sides are connected so\n\t// the funding flow can be properly executed.\n\talice := ht.Alice\n\tht.EnsureConnected(carol, dave)\n\tht.EnsureConnected(carol, alice)\n\n\t// At this point, we can begin our PSBT channel funding workflow. We'll\n\t// start by generating a pending channel ID externally that will be used\n\t// to track this new funding type.\n\tpendingChanID := ht.Random32Bytes()\n\n\t// We'll also test batch funding of two channels so we need another ID.\n\tpendingChanID2 := ht.Random32Bytes()\n\n\t// Now that we have the pending channel ID, Carol will open the channel\n\t// by specifying a PSBT shim. We use the NoPublish flag here to avoid\n\t// publishing the whole batch TX too early.\n\tchanUpdates, tempPsbt := ht.OpenChannelPsbt(\n\t\tcarol, dave, lntest.OpenChannelParams{\n\t\t\tAmt: chanSize,\n\t\t\tFundingShim: &lnrpc.FundingShim{\n\t\t\t\tShim: &lnrpc.FundingShim_PsbtShim{\n\t\t\t\t\tPsbtShim: &lnrpc.PsbtShim{\n\t\t\t\t\t\tPendingChanId: pendingChanID,\n\t\t\t\t\t\tNoPublish:     true,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t)\n\n\t// Let's add a second channel to the batch. This time between Carol and\n\t// Alice. We will publish the batch TX once this channel funding is\n\t// complete.\n\tchanUpdates2, psbtBytes2 := ht.OpenChannelPsbt(\n\t\tcarol, alice, lntest.OpenChannelParams{\n\t\t\tAmt: chanSize,\n\t\t\tFundingShim: &lnrpc.FundingShim{\n\t\t\t\tShim: &lnrpc.FundingShim_PsbtShim{\n\t\t\t\t\tPsbtShim: &lnrpc.PsbtShim{\n\t\t\t\t\t\tPendingChanId: pendingChanID2,\n\t\t\t\t\t\tNoPublish:     false,\n\t\t\t\t\t\tBasePsbt:      tempPsbt,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t)\n\n\t// We'll now ask Dave's wallet to fund the PSBT for us. This will return\n\t// a packet with inputs and outputs set but without any witness data.\n\t// This is exactly what we need for the next step.\n\tfundReq := &walletrpc.FundPsbtRequest{\n\t\tTemplate: &walletrpc.FundPsbtRequest_Psbt{\n\t\t\tPsbt: psbtBytes2,\n\t\t},\n\t\tFees: &walletrpc.FundPsbtRequest_SatPerVbyte{\n\t\t\tSatPerVbyte: 2,\n\t\t},\n\t}\n\tfundResp := dave.RPC.FundPsbt(fundReq)\n\n\t// We have a PSBT that has no witness data yet, which is exactly what we\n\t// need for the next step: Verify the PSBT with the funding intents.\n\tcarol.RPC.FundingStateStep(&lnrpc.FundingTransitionMsg{\n\t\tTrigger: &lnrpc.FundingTransitionMsg_PsbtVerify{\n\t\t\tPsbtVerify: &lnrpc.FundingPsbtVerify{\n\t\t\t\tPendingChanId: pendingChanID,\n\t\t\t\tFundedPsbt:    fundResp.FundedPsbt,\n\t\t\t},\n\t\t},\n\t})\n\tcarol.RPC.FundingStateStep(&lnrpc.FundingTransitionMsg{\n\t\tTrigger: &lnrpc.FundingTransitionMsg_PsbtVerify{\n\t\t\tPsbtVerify: &lnrpc.FundingPsbtVerify{\n\t\t\t\tPendingChanId: pendingChanID2,\n\t\t\t\tFundedPsbt:    fundResp.FundedPsbt,\n\t\t\t},\n\t\t},\n\t})\n\n\t// Now we'll ask Dave's wallet to sign the PSBT so we can finish the\n\t// funding flow.\n\tfinalizeReq := &walletrpc.FinalizePsbtRequest{\n\t\tFundedPsbt: fundResp.FundedPsbt,\n\t}\n\tfinalizeRes := dave.RPC.FinalizePsbt(finalizeReq)\n\n\t// We've signed our PSBT now, let's pass it to the intent again.\n\tcarol.RPC.FundingStateStep(&lnrpc.FundingTransitionMsg{\n\t\tTrigger: &lnrpc.FundingTransitionMsg_PsbtFinalize{\n\t\t\tPsbtFinalize: &lnrpc.FundingPsbtFinalize{\n\t\t\t\tPendingChanId: pendingChanID,\n\t\t\t\tSignedPsbt:    finalizeRes.SignedPsbt,\n\t\t\t},\n\t\t},\n\t})\n\n\t// Consume the \"channel pending\" update. This waits until the funding\n\t// transaction was fully compiled.\n\tupdateResp := ht.ReceiveOpenChannelUpdate(chanUpdates)\n\tupd, ok := updateResp.Update.(*lnrpc.OpenStatusUpdate_ChanPending)\n\trequire.True(ht, ok)\n\tchanPoint := &lnrpc.ChannelPoint{\n\t\tFundingTxid: &lnrpc.ChannelPoint_FundingTxidBytes{\n\t\t\tFundingTxidBytes: upd.ChanPending.Txid,\n\t\t},\n\t\tOutputIndex: upd.ChanPending.OutputIndex,\n\t}\n\n\t// No transaction should have been published yet.\n\tht.Miner.AssertNumTxsInMempool(0)\n\n\t// Let's progress the second channel now. This time we'll use the raw\n\t// wire format transaction directly.\n\tcarol.RPC.FundingStateStep(&lnrpc.FundingTransitionMsg{\n\t\tTrigger: &lnrpc.FundingTransitionMsg_PsbtFinalize{\n\t\t\tPsbtFinalize: &lnrpc.FundingPsbtFinalize{\n\t\t\t\tPendingChanId: pendingChanID2,\n\t\t\t\tFinalRawTx:    finalizeRes.RawFinalTx,\n\t\t\t},\n\t\t},\n\t})\n\n\t// Consume the \"channel pending\" update for the second channel. This\n\t// waits until the funding transaction was fully compiled and in this\n\t// case published.\n\tupdateResp2 := ht.ReceiveOpenChannelUpdate(chanUpdates2)\n\tupd2, ok := updateResp2.Update.(*lnrpc.OpenStatusUpdate_ChanPending)\n\trequire.True(ht, ok)\n\tchanPoint2 := &lnrpc.ChannelPoint{\n\t\tFundingTxid: &lnrpc.ChannelPoint_FundingTxidBytes{\n\t\t\tFundingTxidBytes: upd2.ChanPending.Txid,\n\t\t},\n\t\tOutputIndex: upd2.ChanPending.OutputIndex,\n\t}\n\n\t// Great, now we can mine a block to get the transaction confirmed, then\n\t// wait for the new channel to be propagated through the network.\n\tvar finalTx wire.MsgTx\n\terr := finalTx.Deserialize(bytes.NewReader(finalizeRes.RawFinalTx))\n\trequire.NoError(ht, err)\n\n\ttxHash := finalTx.TxHash()\n\tblock := ht.MineBlocksAndAssertNumTxes(6, 1)[0]\n\tht.Miner.AssertTxInBlock(block, &txHash)\n\tht.AssertTopologyChannelOpen(carol, chanPoint)\n\tht.AssertTopologyChannelOpen(carol, chanPoint2)\n\n\t// With the channel open, ensure that it is counted towards Carol's\n\t// total channel balance.\n\tbalRes := carol.RPC.ChannelBalance()\n\trequire.NotZero(ht, balRes.LocalBalance.Sat)\n\n\t// Next, to make sure the channel functions as normal, we'll make some\n\t// payments within the channel.\n\tpayAmt := btcutil.Amount(100000)\n\tinvoice := &lnrpc.Invoice{\n\t\tMemo:  \"new chans\",\n\t\tValue: int64(payAmt),\n\t}\n\tresp := dave.RPC.AddInvoice(invoice)\n\tht.CompletePaymentRequests(carol, []string{resp.PaymentRequest})\n\n\t// TODO(yy): remove the sleep once the following bug is fixed. When the\n\t// payment is reported as settled by Carol, it's expected the\n\t// commitment dance is finished and all subsequent states have been\n\t// updated. Yet we'd receive the error `cannot co-op close channel with\n\t// active htlcs` or `link failed to shutdown` if we close the channel.\n\t// We need to investigate the order of settling the payments and\n\t// updating commitments to understand and fix .\n\ttime.Sleep(2 * time.Second)\n\n\t// To conclude, we'll close the newly created channel between Carol and\n\t// Dave. This function will also block until the channel is closed and\n\t// will additionally assert the relevant channel closing post\n\t// conditions.\n\tht.CloseChannel(carol, chanPoint)\n\tht.CloseChannel(carol, chanPoint2)\n}\n\n// testPsbtChanFundingExternal makes sure a channel can be opened between carol\n// and dave by using a Partially Signed Bitcoin Transaction that funds the\n// channel multisig funding output and is fully funded by an external third\n// party.",
      "length": 6416,
      "tokens": 750,
      "embedding": []
    },
    {
      "slug": "func testPsbtChanFundingExternal(ht *lntest.HarnessTest) {",
      "content": "func testPsbtChanFundingExternal(ht *lntest.HarnessTest) {\n\tconst chanSize = funding.MaxBtcFundingAmount\n\n\t// First, we'll create two new nodes that we'll use to open channels\n\t// between for this test. Both these nodes have an empty wallet as Alice\n\t// will be funding the channel.\n\tcarol := ht.NewNode(\"carol\", nil)\n\tdave := ht.NewNode(\"dave\", nil)\n\n\t// Before we start the test, we'll ensure both sides are connected so\n\t// the funding flow can be properly executed.\n\talice := ht.Alice\n\tht.EnsureConnected(carol, dave)\n\tht.EnsureConnected(carol, alice)\n\n\t// At this point, we can begin our PSBT channel funding workflow. We'll\n\t// start by generating a pending channel ID externally that will be used\n\t// to track this new funding type.\n\tpendingChanID := ht.Random32Bytes()\n\n\t// We'll also test batch funding of two channels so we need another ID.\n\tpendingChanID2 := ht.Random32Bytes()\n\n\t// Now that we have the pending channel ID, Carol will open the channel\n\t// by specifying a PSBT shim. We use the NoPublish flag here to avoid\n\t// publishing the whole batch TX too early.\n\tchanUpdates, tempPsbt := ht.OpenChannelPsbt(\n\t\tcarol, dave, lntest.OpenChannelParams{\n\t\t\tAmt: chanSize,\n\t\t\tFundingShim: &lnrpc.FundingShim{\n\t\t\t\tShim: &lnrpc.FundingShim_PsbtShim{\n\t\t\t\t\tPsbtShim: &lnrpc.PsbtShim{\n\t\t\t\t\t\tPendingChanId: pendingChanID,\n\t\t\t\t\t\tNoPublish:     true,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t)\n\n\t// Let's add a second channel to the batch. This time between Carol and\n\t// Alice. We will publish the batch TX once this channel funding is\n\t// complete.\n\tchanUpdates2, psbtBytes2 := ht.OpenChannelPsbt(\n\t\tcarol, alice, lntest.OpenChannelParams{\n\t\t\tAmt: chanSize,\n\t\t\tFundingShim: &lnrpc.FundingShim{\n\t\t\t\tShim: &lnrpc.FundingShim_PsbtShim{\n\t\t\t\t\tPsbtShim: &lnrpc.PsbtShim{\n\t\t\t\t\t\tPendingChanId: pendingChanID2,\n\t\t\t\t\t\tNoPublish:     true,\n\t\t\t\t\t\tBasePsbt:      tempPsbt,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t)\n\n\t// We'll now ask Alice's wallet to fund the PSBT for us. This will\n\t// return a packet with inputs and outputs set but without any witness\n\t// data. This is exactly what we need for the next step.\n\tfundReq := &walletrpc.FundPsbtRequest{\n\t\tTemplate: &walletrpc.FundPsbtRequest_Psbt{\n\t\t\tPsbt: psbtBytes2,\n\t\t},\n\t\tFees: &walletrpc.FundPsbtRequest_SatPerVbyte{\n\t\t\tSatPerVbyte: 2,\n\t\t},\n\t}\n\tfundResp := alice.RPC.FundPsbt(fundReq)\n\n\t// We have a PSBT that has no witness data yet, which is exactly what we\n\t// need for the next step: Verify the PSBT with the funding intents.\n\t// We tell the PSBT intent to skip the finalize step because we know the\n\t// final transaction will not be broadcast by Carol herself but by\n\t// Alice. And we assume that Alice is a third party that is not in\n\t// direct communication with Carol and won't send the signed TX to her\n\t// before broadcasting it. So we cannot call the finalize step but\n\t// instead just tell lnd to wait for a TX to be published/confirmed.\n\tcarol.RPC.FundingStateStep(&lnrpc.FundingTransitionMsg{\n\t\tTrigger: &lnrpc.FundingTransitionMsg_PsbtVerify{\n\t\t\tPsbtVerify: &lnrpc.FundingPsbtVerify{\n\t\t\t\tPendingChanId: pendingChanID,\n\t\t\t\tFundedPsbt:    fundResp.FundedPsbt,\n\t\t\t\tSkipFinalize:  true,\n\t\t\t},\n\t\t},\n\t})\n\tcarol.RPC.FundingStateStep(&lnrpc.FundingTransitionMsg{\n\t\tTrigger: &lnrpc.FundingTransitionMsg_PsbtVerify{\n\t\t\tPsbtVerify: &lnrpc.FundingPsbtVerify{\n\t\t\t\tPendingChanId: pendingChanID2,\n\t\t\t\tFundedPsbt:    fundResp.FundedPsbt,\n\t\t\t\tSkipFinalize:  true,\n\t\t\t},\n\t\t},\n\t})\n\n\t// Consume the \"channel pending\" update. This waits until the funding\n\t// transaction was fully compiled for both channels.\n\tupdateResp := ht.ReceiveOpenChannelUpdate(chanUpdates)\n\tupd, ok := updateResp.Update.(*lnrpc.OpenStatusUpdate_ChanPending)\n\trequire.True(ht, ok)\n\tchanPoint := &lnrpc.ChannelPoint{\n\t\tFundingTxid: &lnrpc.ChannelPoint_FundingTxidBytes{\n\t\t\tFundingTxidBytes: upd.ChanPending.Txid,\n\t\t},\n\t\tOutputIndex: upd.ChanPending.OutputIndex,\n\t}\n\tupdateResp2 := ht.ReceiveOpenChannelUpdate(chanUpdates2)\n\tupd2, ok := updateResp2.Update.(*lnrpc.OpenStatusUpdate_ChanPending)\n\trequire.True(ht, ok)\n\tchanPoint2 := &lnrpc.ChannelPoint{\n\t\tFundingTxid: &lnrpc.ChannelPoint_FundingTxidBytes{\n\t\t\tFundingTxidBytes: upd2.ChanPending.Txid,\n\t\t},\n\t\tOutputIndex: upd2.ChanPending.OutputIndex,\n\t}\n\tht.AssertNumPendingOpenChannels(carol, 2)\n\n\t// Now we'll ask Alice's wallet to sign the PSBT so we can finish the\n\t// funding flow.\n\tfinalizeReq := &walletrpc.FinalizePsbtRequest{\n\t\tFundedPsbt: fundResp.FundedPsbt,\n\t}\n\tfinalizeRes := alice.RPC.FinalizePsbt(finalizeReq)\n\n\t// No transaction should have been published yet.\n\tht.Miner.AssertNumTxsInMempool(0)\n\n\t// Great, now let's publish the final raw transaction.\n\tvar finalTx wire.MsgTx\n\terr := finalTx.Deserialize(bytes.NewReader(finalizeRes.RawFinalTx))\n\trequire.NoError(ht, err)\n\n\ttxHash := finalTx.TxHash()\n\t_, err = ht.Miner.Client.SendRawTransaction(&finalTx, false)\n\trequire.NoError(ht, err)\n\n\t// Now we can mine a block to get the transaction confirmed, then wait\n\t// for the new channel to be propagated through the network.\n\tblock := ht.MineBlocksAndAssertNumTxes(6, 1)[0]\n\tht.Miner.AssertTxInBlock(block, &txHash)\n\tht.AssertTopologyChannelOpen(carol, chanPoint)\n\tht.AssertTopologyChannelOpen(carol, chanPoint2)\n\n\t// With the channel open, ensure that it is counted towards Carol's\n\t// total channel balance.\n\tbalRes := carol.RPC.ChannelBalance()\n\trequire.NotZero(ht, balRes.LocalBalance.Sat)\n\n\t// Next, to make sure the channel functions as normal, we'll make some\n\t// payments within the channel.\n\tpayAmt := btcutil.Amount(100000)\n\tinvoice := &lnrpc.Invoice{\n\t\tMemo:  \"new chans\",\n\t\tValue: int64(payAmt),\n\t}\n\tresp := dave.RPC.AddInvoice(invoice)\n\tht.CompletePaymentRequests(carol, []string{resp.PaymentRequest})\n\n\t// TODO(yy): remove the sleep once the following bug is fixed. When the\n\t// payment is reported as settled by Carol, it's expected the\n\t// commitment dance is finished and all subsequent states have been\n\t// updated. Yet we'd receive the error `cannot co-op close channel with\n\t// active htlcs` or `link failed to shutdown` if we close the channel.\n\t// We need to investigate the order of settling the payments and\n\t// updating commitments to understand and fix .\n\ttime.Sleep(2 * time.Second)\n\n\t// To conclude, we'll close the newly created channel between Carol and\n\t// Dave. This function will also block until the channels are closed and\n\t// will additionally assert the relevant channel closing post\n\t// conditions.\n\tht.CloseChannel(carol, chanPoint)\n\tht.CloseChannel(carol, chanPoint2)\n}\n\n// testPsbtChanFundingSingleStep checks whether PSBT funding works also when\n// the wallet of both nodes are empty and one of them uses PSBT and an external\n// wallet to fund the channel while creating reserve output in the same\n// transaction.",
      "length": 6466,
      "tokens": 814,
      "embedding": []
    },
    {
      "slug": "func testPsbtChanFundingSingleStep(ht *lntest.HarnessTest) {",
      "content": "func testPsbtChanFundingSingleStep(ht *lntest.HarnessTest) {\n\tconst chanSize = funding.MaxBtcFundingAmount\n\n\targs := lntest.NodeArgsForCommitType(lnrpc.CommitmentType_ANCHORS)\n\n\t// First, we'll create two new nodes that we'll use to open channels\n\t// between for this test. But in this case both nodes have an empty\n\t// wallet.\n\tcarol := ht.NewNode(\"carol\", args)\n\tdave := ht.NewNode(\"dave\", args)\n\n\talice := ht.Alice\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, alice)\n\n\t// Get new address for anchor reserve.\n\treq := &lnrpc.NewAddressRequest{\n\t\tType: lnrpc.AddressType_WITNESS_PUBKEY_HASH,\n\t}\n\taddrResp := carol.RPC.NewAddress(req)\n\treserveAddr, err := btcutil.DecodeAddress(\n\t\taddrResp.Address, harnessNetParams,\n\t)\n\trequire.NoError(ht, err)\n\treserveAddrScript, err := txscript.PayToAddrScript(reserveAddr)\n\trequire.NoError(ht, err)\n\n\t// Before we start the test, we'll ensure both sides are connected so\n\t// the funding flow can be properly executed.\n\tht.EnsureConnected(carol, dave)\n\n\t// At this point, we can begin our PSBT channel funding workflow. We'll\n\t// start by generating a pending channel ID externally that will be used\n\t// to track this new funding type.\n\tpendingChanID := ht.Random32Bytes()\n\n\t// Now that we have the pending channel ID, Carol will open the channel\n\t// by specifying a PSBT shim.\n\tchanUpdates, tempPsbt := ht.OpenChannelPsbt(\n\t\tcarol, dave, lntest.OpenChannelParams{\n\t\t\tAmt: chanSize,\n\t\t\tFundingShim: &lnrpc.FundingShim{\n\t\t\t\tShim: &lnrpc.FundingShim_PsbtShim{\n\t\t\t\t\tPsbtShim: &lnrpc.PsbtShim{\n\t\t\t\t\t\tPendingChanId: pendingChanID,\n\t\t\t\t\t\tNoPublish:     false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t)\n\n\tdecodedPsbt, err := psbt.NewFromRawBytes(\n\t\tbytes.NewReader(tempPsbt), false,\n\t)\n\trequire.NoError(ht, err)\n\n\treserveTxOut := wire.TxOut{\n\t\tValue:    10000,\n\t\tPkScript: reserveAddrScript,\n\t}\n\n\tdecodedPsbt.UnsignedTx.TxOut = append(\n\t\tdecodedPsbt.UnsignedTx.TxOut, &reserveTxOut,\n\t)\n\tdecodedPsbt.Outputs = append(decodedPsbt.Outputs, psbt.POutput{})\n\n\tvar psbtBytes bytes.Buffer\n\terr = decodedPsbt.Serialize(&psbtBytes)\n\trequire.NoError(ht, err)\n\n\tfundReq := &walletrpc.FundPsbtRequest{\n\t\tTemplate: &walletrpc.FundPsbtRequest_Psbt{\n\t\t\tPsbt: psbtBytes.Bytes(),\n\t\t},\n\t\tFees: &walletrpc.FundPsbtRequest_SatPerVbyte{\n\t\t\tSatPerVbyte: 2,\n\t\t},\n\t}\n\tfundResp := alice.RPC.FundPsbt(fundReq)\n\n\t// Make sure the wallets are actually empty\n\tht.AssertNumUTXOsUnconfirmed(alice, 0)\n\tht.AssertNumUTXOsUnconfirmed(dave, 0)\n\n\t// We have a PSBT that has no witness data yet, which is exactly what we\n\t// need for the next step: Verify the PSBT with the funding intents.\n\tcarol.RPC.FundingStateStep(&lnrpc.FundingTransitionMsg{\n\t\tTrigger: &lnrpc.FundingTransitionMsg_PsbtVerify{\n\t\t\tPsbtVerify: &lnrpc.FundingPsbtVerify{\n\t\t\t\tPendingChanId: pendingChanID,\n\t\t\t\tFundedPsbt:    fundResp.FundedPsbt,\n\t\t\t},\n\t\t},\n\t})\n\n\t// Now we'll ask Alice's wallet to sign the PSBT so we can finish the\n\t// funding flow.\n\tfinalizeReq := &walletrpc.FinalizePsbtRequest{\n\t\tFundedPsbt: fundResp.FundedPsbt,\n\t}\n\tfinalizeRes := alice.RPC.FinalizePsbt(finalizeReq)\n\n\t// We've signed our PSBT now, let's pass it to the intent again.\n\tcarol.RPC.FundingStateStep(&lnrpc.FundingTransitionMsg{\n\t\tTrigger: &lnrpc.FundingTransitionMsg_PsbtFinalize{\n\t\t\tPsbtFinalize: &lnrpc.FundingPsbtFinalize{\n\t\t\t\tPendingChanId: pendingChanID,\n\t\t\t\tSignedPsbt:    finalizeRes.SignedPsbt,\n\t\t\t},\n\t\t},\n\t})\n\n\t// Consume the \"channel pending\" update. This waits until the funding\n\t// transaction was fully compiled.\n\tupdateResp := ht.ReceiveOpenChannelUpdate(chanUpdates)\n\tupd, ok := updateResp.Update.(*lnrpc.OpenStatusUpdate_ChanPending)\n\trequire.True(ht, ok)\n\tchanPoint := &lnrpc.ChannelPoint{\n\t\tFundingTxid: &lnrpc.ChannelPoint_FundingTxidBytes{\n\t\t\tFundingTxidBytes: upd.ChanPending.Txid,\n\t\t},\n\t\tOutputIndex: upd.ChanPending.OutputIndex,\n\t}\n\n\tvar finalTx wire.MsgTx\n\terr = finalTx.Deserialize(bytes.NewReader(finalizeRes.RawFinalTx))\n\trequire.NoError(ht, err)\n\n\ttxHash := finalTx.TxHash()\n\tblock := ht.MineBlocksAndAssertNumTxes(6, 1)[0]\n\tht.Miner.AssertTxInBlock(block, &txHash)\n\tht.AssertTopologyChannelOpen(carol, chanPoint)\n\n\t// Next, to make sure the channel functions as normal, we'll make some\n\t// payments within the channel.\n\tpayAmt := btcutil.Amount(100000)\n\tinvoice := &lnrpc.Invoice{\n\t\tMemo:  \"new chans\",\n\t\tValue: int64(payAmt),\n\t}\n\tresp := dave.RPC.AddInvoice(invoice)\n\tht.CompletePaymentRequests(carol, []string{resp.PaymentRequest})\n\n\t// TODO(yy): remove the sleep once the following bug is fixed. When the\n\t// payment is reported as settled by Carol, it's expected the\n\t// commitment dance is finished and all subsequent states have been\n\t// updated. Yet we'd receive the error `cannot co-op close channel with\n\t// active htlcs` or `link failed to shutdown` if we close the channel.\n\t// We need to investigate the order of settling the payments and\n\t// updating commitments to understand and fix .\n\ttime.Sleep(2 * time.Second)\n\n\t// To conclude, we'll close the newly created channel between Carol and\n\t// Dave. This function will also block until the channel is closed and\n\t// will additionally assert the relevant channel closing post\n\t// conditions.\n\tht.CloseChannel(carol, chanPoint)\n}\n\n// testSignPsbt tests that the SignPsbt RPC works correctly.",
      "length": 4990,
      "tokens": 561,
      "embedding": []
    },
    {
      "slug": "func testSignPsbt(ht *lntest.HarnessTest) {",
      "content": "func testSignPsbt(ht *lntest.HarnessTest) {\n\trunSignPsbtSegWitV0P2WKH(ht, ht.Alice)\n\trunSignPsbtSegWitV0NP2WKH(ht, ht.Alice)\n\trunSignPsbtSegWitV1KeySpendBip86(ht, ht.Alice)\n\trunSignPsbtSegWitV1KeySpendRootHash(ht, ht.Alice)\n\trunSignPsbtSegWitV1ScriptSpend(ht, ht.Alice)\n\n\t// The above tests all make sure we can sign for keys that aren't in\n\t// the wallet. But we also want to make sure we can fund and then sign\n\t// PSBTs from our wallet.\n\trunFundAndSignPsbt(ht, ht.Alice)\n}\n\n// runSignPsbtSegWitV0P2WKH tests that the SignPsbt RPC works correctly for a\n// SegWit v0 p2wkh input.",
      "length": 523,
      "tokens": 65,
      "embedding": []
    },
    {
      "slug": "func runSignPsbtSegWitV0P2WKH(ht *lntest.HarnessTest, alice *node.HarnessNode) {",
      "content": "func runSignPsbtSegWitV0P2WKH(ht *lntest.HarnessTest, alice *node.HarnessNode) {\n\t// We test that we can sign a PSBT that spends funds from an input that\n\t// the wallet doesn't know about. To set up that test case, we first\n\t// derive an address manually that the wallet won't be watching on\n\t// chain. We can do that by exporting the account xpub of lnd's main\n\t// account.\n\taccounts := alice.RPC.ListAccounts(&walletrpc.ListAccountsRequest{})\n\trequire.NotEmpty(ht, accounts.Accounts)\n\n\t// We also need to parse the accounts, so we have easy access to the\n\t// parsed derivation paths.\n\tparsedAccounts, err := walletrpc.AccountsToWatchOnly(accounts.Accounts)\n\trequire.NoError(ht, err)\n\n\taccount := parsedAccounts[0]\n\txpub, err := hdkeychain.NewKeyFromString(account.Xpub)\n\trequire.NoError(ht, err)\n\n\tconst (\n\t\tchangeIndex = 1\n\t\taddrIndex   = 1337\n\t)\n\tfullDerivationPath := []uint32{\n\t\thdkeychain.HardenedKeyStart + account.Purpose,\n\t\thdkeychain.HardenedKeyStart + account.CoinType,\n\t\thdkeychain.HardenedKeyStart + account.Account,\n\t\tchangeIndex,\n\t\taddrIndex,\n\t}\n\n\t// Let's simulate a change address.\n\tchange, err := xpub.DeriveNonStandard(changeIndex) // nolint:staticcheck\n\trequire.NoError(ht, err)\n\n\t// At an index that we are certainly not watching in the wallet.\n\taddrKey, err := change.DeriveNonStandard(addrIndex) // nolint:staticcheck\n\trequire.NoError(ht, err)\n\n\taddrPubKey, err := addrKey.ECPubKey()\n\trequire.NoError(ht, err)\n\tpubKeyHash := btcutil.Hash160(addrPubKey.SerializeCompressed())\n\twitnessAddr, err := btcutil.NewAddressWitnessPubKeyHash(\n\t\tpubKeyHash, harnessNetParams,\n\t)\n\trequire.NoError(ht, err)\n\n\tpkScript, err := txscript.PayToAddrScript(witnessAddr)\n\trequire.NoError(ht, err)\n\n\t// Send some funds to the output and then try to get a signature through\n\t// the SignPsbt RPC to spend that output again.\n\tassertPsbtSpend(\n\t\tht, alice, pkScript,\n\t\tfunc(packet *psbt.Packet) {\n\t\t\tin := &packet.Inputs[0]\n\t\t\tin.Bip32Derivation = []*psbt.Bip32Derivation{{\n\t\t\t\tPubKey:    addrPubKey.SerializeCompressed(),\n\t\t\t\tBip32Path: fullDerivationPath,\n\t\t\t}}\n\t\t\tin.SighashType = txscript.SigHashAll\n\t\t},\n\t\tfunc(packet *psbt.Packet) {\n\t\t\trequire.Len(ht, packet.Inputs, 1)\n\t\t\trequire.Len(ht, packet.Inputs[0].PartialSigs, 1)\n\n\t\t\tpartialSig := packet.Inputs[0].PartialSigs[0]\n\t\t\trequire.Equal(\n\t\t\t\tht, partialSig.PubKey,\n\t\t\t\taddrPubKey.SerializeCompressed(),\n\t\t\t)\n\t\t\trequire.Greater(\n\t\t\t\tht, len(partialSig.Signature), ecdsa.MinSigLen,\n\t\t\t)\n\t\t},\n\t)\n}\n\n// runSignPsbtSegWitV0NP2WKH tests that the SignPsbt RPC works correctly for a\n// SegWit v0 np2wkh input.",
      "length": 2400,
      "tokens": 267,
      "embedding": []
    },
    {
      "slug": "func runSignPsbtSegWitV0NP2WKH(ht *lntest.HarnessTest,",
      "content": "func runSignPsbtSegWitV0NP2WKH(ht *lntest.HarnessTest,\n\talice *node.HarnessNode) {\n\n\t// We test that we can sign a PSBT that spends funds from an input that\n\t// the wallet doesn't know about. To set up that test case, we first\n\t// derive an address manually that the wallet won't be watching on\n\t// chain. We can do that by exporting the account xpub of lnd's main\n\t// account.\n\taccounts := alice.RPC.ListAccounts(&walletrpc.ListAccountsRequest{})\n\trequire.NotEmpty(ht, accounts.Accounts)\n\n\t// We also need to parse the accounts, so we have easy access to the\n\t// parsed derivation paths.\n\tparsedAccounts, err := walletrpc.AccountsToWatchOnly(accounts.Accounts)\n\trequire.NoError(ht, err)\n\n\taccount := parsedAccounts[0]\n\txpub, err := hdkeychain.NewKeyFromString(account.Xpub)\n\trequire.NoError(ht, err)\n\n\tconst (\n\t\tchangeIndex = 1\n\t\taddrIndex   = 1337\n\t)\n\tfullDerivationPath := []uint32{\n\t\thdkeychain.HardenedKeyStart + account.Purpose,\n\t\thdkeychain.HardenedKeyStart + account.CoinType,\n\t\thdkeychain.HardenedKeyStart + account.Account,\n\t\tchangeIndex,\n\t\taddrIndex,\n\t}\n\n\t// Let's simulate a change address.\n\tchange, err := xpub.DeriveNonStandard(changeIndex) // nolint:staticcheck\n\trequire.NoError(ht, err)\n\n\t// At an index that we are certainly not watching in the wallet.\n\taddrKey, err := change.DeriveNonStandard(addrIndex) // nolint:staticcheck\n\trequire.NoError(ht, err)\n\n\taddrPubKey, err := addrKey.ECPubKey()\n\trequire.NoError(ht, err)\n\tpubKeyHash := btcutil.Hash160(addrPubKey.SerializeCompressed())\n\twitnessAddr, err := btcutil.NewAddressWitnessPubKeyHash(\n\t\tpubKeyHash, harnessNetParams,\n\t)\n\trequire.NoError(ht, err)\n\n\twitnessProgram, err := txscript.PayToAddrScript(witnessAddr)\n\trequire.NoError(ht, err)\n\tnp2wkhAddr, err := btcutil.NewAddressScriptHash(\n\t\twitnessProgram, harnessNetParams,\n\t)\n\trequire.NoError(ht, err)\n\n\tpkScript, err := txscript.PayToAddrScript(np2wkhAddr)\n\trequire.NoError(ht, err)\n\n\t// Send some funds to the output and then try to get a signature through\n\t// the SignPsbt RPC to spend that output again.\n\tassertPsbtSpend(\n\t\tht, alice, pkScript,\n\t\tfunc(packet *psbt.Packet) {\n\t\t\tin := &packet.Inputs[0]\n\t\t\tin.RedeemScript = witnessProgram\n\t\t\tin.Bip32Derivation = []*psbt.Bip32Derivation{{\n\t\t\t\tPubKey:    addrPubKey.SerializeCompressed(),\n\t\t\t\tBip32Path: fullDerivationPath,\n\t\t\t}}\n\t\t\tin.SighashType = txscript.SigHashAll\n\t\t},\n\t\tfunc(packet *psbt.Packet) {\n\t\t\trequire.Len(ht, packet.Inputs, 1)\n\t\t\trequire.Len(ht, packet.Inputs[0].PartialSigs, 1)\n\n\t\t\tpartialSig := packet.Inputs[0].PartialSigs[0]\n\t\t\trequire.Equal(\n\t\t\t\tht, partialSig.PubKey,\n\t\t\t\taddrPubKey.SerializeCompressed(),\n\t\t\t)\n\t\t\trequire.Greater(\n\t\t\t\tht, len(partialSig.Signature), ecdsa.MinSigLen,\n\t\t\t)\n\t\t},\n\t)\n}\n\n// runSignPsbtSegWitV1KeySpendBip86 tests that the SignPsbt RPC works correctly\n// for a SegWit v1 p2tr key spend BIP-0086 input.",
      "length": 2682,
      "tokens": 291,
      "embedding": []
    },
    {
      "slug": "func runSignPsbtSegWitV1KeySpendBip86(ht *lntest.HarnessTest,",
      "content": "func runSignPsbtSegWitV1KeySpendBip86(ht *lntest.HarnessTest,\n\talice *node.HarnessNode) {\n\n\t// Derive a key we can use for signing.\n\tkeyDesc, internalKey, fullDerivationPath := deriveInternalKey(ht, alice)\n\n\t// Our taproot key is a BIP0086 key spend only construction that just\n\t// commits to the internal key and no root hash.\n\ttaprootKey := txscript.ComputeTaprootKeyNoScript(internalKey)\n\ttapScriptAddr, err := btcutil.NewAddressTaproot(\n\t\tschnorr.SerializePubKey(taprootKey), harnessNetParams,\n\t)\n\trequire.NoError(ht, err)\n\tp2trPkScript, err := txscript.PayToAddrScript(tapScriptAddr)\n\trequire.NoError(ht, err)\n\n\t// Send some funds to the output and then try to get a signature through\n\t// the SignPsbt RPC to spend that output again.\n\tassertPsbtSpend(\n\t\tht, alice, p2trPkScript,\n\t\tfunc(packet *psbt.Packet) {\n\t\t\tin := &packet.Inputs[0]\n\t\t\tin.Bip32Derivation = []*psbt.Bip32Derivation{{\n\t\t\t\tPubKey:    keyDesc.RawKeyBytes,\n\t\t\t\tBip32Path: fullDerivationPath,\n\t\t\t}}\n\t\t\tin.TaprootBip32Derivation = []*psbt.TaprootBip32Derivation{{\n\t\t\t\tXOnlyPubKey: keyDesc.RawKeyBytes[1:],\n\t\t\t\tBip32Path:   fullDerivationPath,\n\t\t\t}}\n\t\t\tin.SighashType = txscript.SigHashDefault\n\t\t},\n\t\tfunc(packet *psbt.Packet) {\n\t\t\trequire.Len(ht, packet.Inputs, 1)\n\t\t\trequire.Len(\n\t\t\t\tht, packet.Inputs[0].TaprootKeySpendSig, 64,\n\t\t\t)\n\t\t},\n\t)\n}\n\n// runSignPsbtSegWitV1KeySpendRootHash tests that the SignPsbt RPC works\n// correctly for a SegWit v1 p2tr key spend that also commits to a script tree\n// root hash.",
      "length": 1375,
      "tokens": 154,
      "embedding": []
    },
    {
      "slug": "func runSignPsbtSegWitV1KeySpendRootHash(ht *lntest.HarnessTest,",
      "content": "func runSignPsbtSegWitV1KeySpendRootHash(ht *lntest.HarnessTest,\n\talice *node.HarnessNode) {\n\n\t// Derive a key we can use for signing.\n\tkeyDesc, internalKey, fullDerivationPath := deriveInternalKey(ht, alice)\n\n\t// Let's create a taproot script output now. This is a hash lock with a\n\t// simple preimage of \"foobar\".\n\tleaf1 := testScriptHashLock(ht.T, []byte(\"foobar\"))\n\n\trootHash := leaf1.TapHash()\n\ttaprootKey := txscript.ComputeTaprootOutputKey(internalKey, rootHash[:])\n\ttapScriptAddr, err := btcutil.NewAddressTaproot(\n\t\tschnorr.SerializePubKey(taprootKey), harnessNetParams,\n\t)\n\trequire.NoError(ht, err)\n\tp2trPkScript, err := txscript.PayToAddrScript(tapScriptAddr)\n\trequire.NoError(ht, err)\n\n\t// Send some funds to the output and then try to get a signature through\n\t// the SignPsbt RPC to spend that output again.\n\tassertPsbtSpend(\n\t\tht, alice, p2trPkScript,\n\t\tfunc(packet *psbt.Packet) {\n\t\t\tin := &packet.Inputs[0]\n\t\t\tin.Bip32Derivation = []*psbt.Bip32Derivation{{\n\t\t\t\tPubKey:    keyDesc.RawKeyBytes,\n\t\t\t\tBip32Path: fullDerivationPath,\n\t\t\t}}\n\t\t\tin.TaprootBip32Derivation = []*psbt.TaprootBip32Derivation{{\n\t\t\t\tXOnlyPubKey: keyDesc.RawKeyBytes[1:],\n\t\t\t\tBip32Path:   fullDerivationPath,\n\t\t\t}}\n\t\t\tin.TaprootMerkleRoot = rootHash[:]\n\t\t\tin.SighashType = txscript.SigHashDefault\n\t\t},\n\t\tfunc(packet *psbt.Packet) {\n\t\t\trequire.Len(ht, packet.Inputs, 1)\n\t\t\trequire.Len(\n\t\t\t\tht, packet.Inputs[0].TaprootKeySpendSig, 64,\n\t\t\t)\n\t\t},\n\t)\n}\n\n// runSignPsbtSegWitV1ScriptSpend tests that the SignPsbt RPC works correctly\n// for a SegWit v1 p2tr script spend.",
      "length": 1439,
      "tokens": 152,
      "embedding": []
    },
    {
      "slug": "func runSignPsbtSegWitV1ScriptSpend(ht *lntest.HarnessTest,",
      "content": "func runSignPsbtSegWitV1ScriptSpend(ht *lntest.HarnessTest,\n\talice *node.HarnessNode) {\n\n\t// Derive a key we can use for signing.\n\tkeyDesc, internalKey, fullDerivationPath := deriveInternalKey(ht, alice)\n\n\t// Let's create a taproot script output now. This is a hash lock with a\n\t// simple preimage of \"foobar\".\n\tleaf1 := testScriptSchnorrSig(ht.T, internalKey)\n\n\trootHash := leaf1.TapHash()\n\ttaprootKey := txscript.ComputeTaprootOutputKey(internalKey, rootHash[:])\n\ttapScriptAddr, err := btcutil.NewAddressTaproot(\n\t\tschnorr.SerializePubKey(taprootKey), harnessNetParams,\n\t)\n\trequire.NoError(ht, err)\n\tp2trPkScript, err := txscript.PayToAddrScript(tapScriptAddr)\n\trequire.NoError(ht, err)\n\n\t// We need to assemble the control block to be able to spend through the\n\t// script path.\n\ttapscript := input.TapscriptPartialReveal(internalKey, leaf1, nil)\n\tcontrolBlockBytes, err := tapscript.ControlBlock.ToBytes()\n\trequire.NoError(ht, err)\n\n\t// Send some funds to the output and then try to get a signature through\n\t// the SignPsbt RPC to spend that output again.\n\tassertPsbtSpend(\n\t\tht, alice, p2trPkScript,\n\t\tfunc(packet *psbt.Packet) {\n\t\t\tin := &packet.Inputs[0]\n\t\t\tin.Bip32Derivation = []*psbt.Bip32Derivation{{\n\t\t\t\tPubKey:    keyDesc.RawKeyBytes,\n\t\t\t\tBip32Path: fullDerivationPath,\n\t\t\t}}\n\t\t\tin.TaprootBip32Derivation = []*psbt.TaprootBip32Derivation{{\n\t\t\t\tXOnlyPubKey: keyDesc.RawKeyBytes[1:],\n\t\t\t\tBip32Path:   fullDerivationPath,\n\t\t\t\tLeafHashes:  [][]byte{rootHash[:]},\n\t\t\t}}\n\t\t\tin.SighashType = txscript.SigHashDefault\n\t\t\tin.TaprootLeafScript = []*psbt.TaprootTapLeafScript{{\n\t\t\t\tControlBlock: controlBlockBytes,\n\t\t\t\tScript:       leaf1.Script,\n\t\t\t\tLeafVersion:  leaf1.LeafVersion,\n\t\t\t}}\n\t\t},\n\t\tfunc(packet *psbt.Packet) {\n\t\t\trequire.Len(ht, packet.Inputs, 1)\n\t\t\trequire.Len(\n\t\t\t\tht, packet.Inputs[0].TaprootScriptSpendSig, 1,\n\t\t\t)\n\n\t\t\tscriptSpendSig := packet.Inputs[0].TaprootScriptSpendSig[0]\n\t\t\trequire.Len(ht, scriptSpendSig.Signature, 64)\n\t\t},\n\t)\n}\n\n// runFundAndSignPsbt makes sure we can sign PSBTs that were funded by our\n// internal wallet.",
      "length": 1933,
      "tokens": 195,
      "embedding": []
    },
    {
      "slug": "func runFundAndSignPsbt(ht *lntest.HarnessTest, alice *node.HarnessNode) {",
      "content": "func runFundAndSignPsbt(ht *lntest.HarnessTest, alice *node.HarnessNode) {\n\talice.AddToLogf(\"================ runFundAndSignPsbt ===============\")\n\n\t// We'll be using a \"main\" address where we send the funds to and from\n\t// several times.\n\tmainAddrResp := alice.RPC.NewAddress(&lnrpc.NewAddressRequest{\n\t\tType: lnrpc.AddressType_WITNESS_PUBKEY_HASH,\n\t})\n\n\tfundOutputs := map[string]uint64{\n\t\tmainAddrResp.Address: 999000,\n\t}\n\tspendAddrTypes := []lnrpc.AddressType{\n\t\tlnrpc.AddressType_NESTED_PUBKEY_HASH,\n\t\tlnrpc.AddressType_WITNESS_PUBKEY_HASH,\n\t\tlnrpc.AddressType_TAPROOT_PUBKEY,\n\t}\n\tchangeAddrTypes := []walletrpc.ChangeAddressType{\n\t\twalletrpc.ChangeAddressType_CHANGE_ADDRESS_TYPE_UNSPECIFIED,\n\t\twalletrpc.ChangeAddressType_CHANGE_ADDRESS_TYPE_P2TR,\n\t}\n\n\tfor _, addrType := range spendAddrTypes {\n\t\tfor _, changeType := range changeAddrTypes {\n\t\t\tht.Logf(\"testing with address type %s and\"+\n\t\t\t\t\"change address type %s\", addrType, changeType)\n\n\t\t\t// First, spend all the coins in the wallet to an\n\t\t\t// address of the given type so that UTXO will be picked\n\t\t\t// when funding a PSBT.\n\t\t\tsendAllCoinsToAddrType(ht, alice, addrType)\n\n\t\t\t// Let's fund a PSBT now where we want to send a few\n\t\t\t// sats to our main address.\n\t\t\tassertPsbtFundSignSpend(\n\t\t\t\tht, alice, fundOutputs, changeType, false,\n\t\t\t)\n\n\t\t\t// Send all coins back to a single address once again.\n\t\t\tsendAllCoinsToAddrType(ht, alice, addrType)\n\n\t\t\t// And now make sure the alternate way of signing a\n\t\t\t// PSBT, which is calling FinalizePsbt directly, also\n\t\t\t// works for this address type.\n\t\t\tassertPsbtFundSignSpend(\n\t\t\t\tht, alice, fundOutputs, changeType, true,\n\t\t\t)\n\t\t}\n\t}\n}\n\n// assertPsbtSpend creates an output with the given pkScript on chain and then\n// attempts to create a sweep transaction that is signed using the SignPsbt RPC\n// that spends that output again.",
      "length": 1713,
      "tokens": 211,
      "embedding": []
    },
    {
      "slug": "func assertPsbtSpend(ht *lntest.HarnessTest, alice *node.HarnessNode,",
      "content": "func assertPsbtSpend(ht *lntest.HarnessTest, alice *node.HarnessNode,\n\tpkScript []byte, decorateUnsigned func(*psbt.Packet),\n\tverifySigned func(*psbt.Packet)) {\n\n\t// Let's send some coins to that address now.\n\tutxo := &wire.TxOut{\n\t\tValue:    600_000,\n\t\tPkScript: pkScript,\n\t}\n\treq := &walletrpc.SendOutputsRequest{\n\t\tOutputs: []*signrpc.TxOut{{\n\t\t\tValue:    utxo.Value,\n\t\t\tPkScript: utxo.PkScript,\n\t\t}},\n\t\tMinConfs:         0,\n\t\tSpendUnconfirmed: true,\n\t\tSatPerKw:         2500,\n\t}\n\tresp := alice.RPC.SendOutputs(req)\n\n\tprevTx := wire.NewMsgTx(2)\n\terr := prevTx.Deserialize(bytes.NewReader(resp.RawTx))\n\trequire.NoError(ht, err)\n\n\tprevOut := -1\n\tfor idx, txOut := range prevTx.TxOut {\n\t\tif bytes.Equal(txOut.PkScript, pkScript) {\n\t\t\tprevOut = idx\n\t\t}\n\t}\n\trequire.Greater(ht, prevOut, -1)\n\n\t// Okay, we have everything we need to create a PSBT now.\n\tpendingTx := &wire.MsgTx{\n\t\tVersion: 2,\n\t\tTxIn: []*wire.TxIn{{\n\t\t\tPreviousOutPoint: wire.OutPoint{\n\t\t\t\tHash:  prevTx.TxHash(),\n\t\t\t\tIndex: uint32(prevOut),\n\t\t\t},\n\t\t}},\n\t\t// We send to the same address again, but deduct some fees.\n\t\tTxOut: []*wire.TxOut{{\n\t\t\tValue:    utxo.Value - 600,\n\t\t\tPkScript: utxo.PkScript,\n\t\t}},\n\t}\n\tpacket, err := psbt.NewFromUnsignedTx(pendingTx)\n\trequire.NoError(ht, err)\n\n\t// Now let's add the meta information that we need for signing.\n\tpacket.Inputs[0].WitnessUtxo = utxo\n\tpacket.Inputs[0].NonWitnessUtxo = prevTx\n\tdecorateUnsigned(packet)\n\n\t// That's it, we should be able to sign the PSBT now.\n\tvar buf bytes.Buffer\n\terr = packet.Serialize(&buf)\n\trequire.NoError(ht, err)\n\n\tsignReq := &walletrpc.SignPsbtRequest{FundedPsbt: buf.Bytes()}\n\tsignResp := alice.RPC.SignPsbt(signReq)\n\n\t// Let's make sure we have a partial signature.\n\tsignedPacket, err := psbt.NewFromRawBytes(\n\t\tbytes.NewReader(signResp.SignedPsbt), false,\n\t)\n\trequire.NoError(ht, err)\n\n\t// Allow the caller to also verify (and potentially move) some of the\n\t// returned fields.\n\tverifySigned(signedPacket)\n\n\t// We should be able to finalize the PSBT and extract the final TX now.\n\terr = psbt.MaybeFinalizeAll(signedPacket)\n\trequire.NoError(ht, err)\n\n\tfinalTx, err := psbt.Extract(signedPacket)\n\trequire.NoError(ht, err)\n\n\t// Make sure we can also sign a second time. This makes sure any key\n\t// tweaking that happened for the signing didn't affect any keys in the\n\t// cache.\n\tr := &walletrpc.SignPsbtRequest{FundedPsbt: buf.Bytes()}\n\tsignResp2 := alice.RPC.SignPsbt(r)\n\tsignedPacket2, err := psbt.NewFromRawBytes(\n\t\tbytes.NewReader(signResp2.SignedPsbt), false,\n\t)\n\trequire.NoError(ht, err)\n\tverifySigned(signedPacket2)\n\n\tbuf.Reset()\n\terr = finalTx.Serialize(&buf)\n\trequire.NoError(ht, err)\n\n\t// Publish the second transaction and then mine both of them.\n\ttxReq := &walletrpc.Transaction{TxHex: buf.Bytes()}\n\talice.RPC.PublishTransaction(txReq)\n\n\t// Mine one block which should contain two transactions.\n\tblock := ht.MineBlocksAndAssertNumTxes(1, 2)[0]\n\tfirstTxHash := prevTx.TxHash()\n\tsecondTxHash := finalTx.TxHash()\n\tht.Miner.AssertTxInBlock(block, &firstTxHash)\n\tht.Miner.AssertTxInBlock(block, &secondTxHash)\n}\n\n// assertPsbtFundSignSpend funds a PSBT from the internal wallet and then\n// attempts to sign it by using the SignPsbt or FinalizePsbt method.",
      "length": 3026,
      "tokens": 352,
      "embedding": []
    },
    {
      "slug": "func assertPsbtFundSignSpend(ht *lntest.HarnessTest, alice *node.HarnessNode,",
      "content": "func assertPsbtFundSignSpend(ht *lntest.HarnessTest, alice *node.HarnessNode,\n\tfundOutputs map[string]uint64, changeType walletrpc.ChangeAddressType,\n\tuseFinalize bool) {\n\n\tfundResp := alice.RPC.FundPsbt(&walletrpc.FundPsbtRequest{\n\t\tTemplate: &walletrpc.FundPsbtRequest_Raw{\n\t\t\tRaw: &walletrpc.TxTemplate{\n\t\t\t\tOutputs: fundOutputs,\n\t\t\t},\n\t\t},\n\t\tFees: &walletrpc.FundPsbtRequest_SatPerVbyte{\n\t\t\tSatPerVbyte: 2,\n\t\t},\n\t\tMinConfs:   1,\n\t\tChangeType: changeType,\n\t},\n\t)\n\trequire.GreaterOrEqual(ht, fundResp.ChangeOutputIndex, int32(-1))\n\n\tvar signedPsbt []byte\n\tif useFinalize {\n\t\tfinalizeResp := alice.RPC.FinalizePsbt(\n\t\t\t&walletrpc.FinalizePsbtRequest{\n\t\t\t\tFundedPsbt: fundResp.FundedPsbt,\n\t\t\t},\n\t\t)\n\n\t\tsignedPsbt = finalizeResp.SignedPsbt\n\t} else {\n\t\tsignResp := alice.RPC.SignPsbt(\n\t\t\t&walletrpc.SignPsbtRequest{\n\t\t\t\tFundedPsbt: fundResp.FundedPsbt,\n\t\t\t},\n\t\t)\n\n\t\tsignedPsbt = signResp.SignedPsbt\n\t}\n\n\t// Let's make sure we have a partial signature.\n\tsignedPacket, err := psbt.NewFromRawBytes(\n\t\tbytes.NewReader(signedPsbt), false,\n\t)\n\trequire.NoError(ht, err)\n\n\t// We should be able to finalize the PSBT and extract the final\n\t// TX now.\n\terr = psbt.MaybeFinalizeAll(signedPacket)\n\trequire.NoError(ht, err)\n\n\tfinalTx, err := psbt.Extract(signedPacket)\n\trequire.NoError(ht, err)\n\n\t// Check type of the change script depending on the change address\n\t// type we provided in FundPsbt.\n\tchangeScript := finalTx.TxOut[fundResp.ChangeOutputIndex].PkScript\n\tassertChangeScriptType(ht, changeScript, changeType)\n\n\tvar buf bytes.Buffer\n\terr = finalTx.Serialize(&buf)\n\trequire.NoError(ht, err)\n\n\t// Publish the second transaction and then mine both of them.\n\talice.RPC.PublishTransaction(&walletrpc.Transaction{\n\t\tTxHex: buf.Bytes(),\n\t})\n\n\t// Mine one block which should contain one transaction.\n\tblock := ht.MineBlocksAndAssertNumTxes(1, 1)[0]\n\tfinalTxHash := finalTx.TxHash()\n\tht.Miner.AssertTxInBlock(block, &finalTxHash)\n}\n\n// assertChangeScriptType checks if the given script has the right type given\n// the change address type we used in FundPsbt. By default, the script should\n// be a P2WPKH one.",
      "length": 1942,
      "tokens": 206,
      "embedding": []
    },
    {
      "slug": "func assertChangeScriptType(ht *lntest.HarnessTest, script []byte,",
      "content": "func assertChangeScriptType(ht *lntest.HarnessTest, script []byte,\n\tfundChangeType walletrpc.ChangeAddressType) {\n\n\tswitch fundChangeType {\n\tcase walletrpc.ChangeAddressType_CHANGE_ADDRESS_TYPE_P2TR:\n\t\trequire.True(ht, txscript.IsPayToTaproot(script))\n\n\tdefault:\n\t\trequire.True(ht, txscript.IsPayToWitnessPubKeyHash(script))\n\t}\n}\n\n// deriveInternalKey derives a signing key and returns its descriptor, full\n// derivation path and parsed public key.",
      "length": 369,
      "tokens": 33,
      "embedding": []
    },
    {
      "slug": "func deriveInternalKey(ht *lntest.HarnessTest,",
      "content": "func deriveInternalKey(ht *lntest.HarnessTest,\n\talice *node.HarnessNode) (*signrpc.KeyDescriptor, *btcec.PublicKey,\n\t[]uint32) {\n\n\t// For the next step, we need a public key. Let's use a special family\n\t// for this.\n\treq := &walletrpc.KeyReq{KeyFamily: testTaprootKeyFamily}\n\tkeyDesc := alice.RPC.DeriveNextKey(req)\n\n\t// The DeriveNextKey returns a key from the internal 1017 scope.\n\tfullDerivationPath := []uint32{\n\t\thdkeychain.HardenedKeyStart + keychain.BIP0043Purpose,\n\t\thdkeychain.HardenedKeyStart + harnessNetParams.HDCoinType,\n\t\thdkeychain.HardenedKeyStart + uint32(keyDesc.KeyLoc.KeyFamily),\n\t\t0,\n\t\tuint32(keyDesc.KeyLoc.KeyIndex),\n\t}\n\n\tparsedPubKey, err := btcec.ParsePubKey(keyDesc.RawKeyBytes)\n\trequire.NoError(ht, err)\n\n\treturn keyDesc, parsedPubKey, fullDerivationPath\n}\n\n// sendAllCoinsToAddrType sweeps all coins from the wallet and sends them to a\n// new address of the given type.",
      "length": 826,
      "tokens": 88,
      "embedding": []
    },
    {
      "slug": "func sendAllCoinsToAddrType(ht *lntest.HarnessTest,",
      "content": "func sendAllCoinsToAddrType(ht *lntest.HarnessTest,\n\thn *node.HarnessNode, addrType lnrpc.AddressType) {\n\n\tresp := hn.RPC.NewAddress(&lnrpc.NewAddressRequest{\n\t\tType: addrType,\n\t})\n\n\thn.RPC.SendCoins(&lnrpc.SendCoinsRequest{\n\t\tAddr:             resp.Address,\n\t\tSendAll:          true,\n\t\tSpendUnconfirmed: true,\n\t})\n\n\tht.MineBlocksAndAssertNumTxes(1, 1)\n\tht.WaitForBlockchainSync(hn)\n}\n",
      "length": 318,
      "tokens": 23,
      "embedding": []
    }
  ]
}