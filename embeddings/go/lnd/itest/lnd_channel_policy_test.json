{
  "filepath": "../implementations/go/lnd/itest/lnd_channel_policy_test.go",
  "package": "itest",
  "sections": [
    {
      "slug": "func testUpdateChannelPolicy(ht *lntest.HarnessTest) {",
      "content": "func testUpdateChannelPolicy(ht *lntest.HarnessTest) {\n\tconst (\n\t\tdefaultFeeBase       = 1000\n\t\tdefaultFeeRate       = 1\n\t\tdefaultTimeLockDelta = chainreg.DefaultBitcoinTimeLockDelta\n\t\tdefaultMinHtlc       = 1000\n\t)\n\tdefaultMaxHtlc := lntest.CalculateMaxHtlc(funding.MaxBtcFundingAmount)\n\n\tchanAmt := funding.MaxBtcFundingAmount\n\tpushAmt := chanAmt / 2\n\n\talice, bob := ht.Alice, ht.Bob\n\n\t// Create a channel Alice->Bob.\n\tchanPoint := ht.OpenChannel(\n\t\talice, bob, lntest.OpenChannelParams{\n\t\t\tAmt:     chanAmt,\n\t\t\tPushAmt: pushAmt,\n\t\t},\n\t)\n\n\t// We add all the nodes' update channels to a slice, such that we can\n\t// make sure they all receive the expected updates.\n\tnodes := []*node.HarnessNode{alice, bob}\n\n\t// Alice and Bob should see each other's ChannelUpdates, advertising the\n\t// default routing policies.\n\texpectedPolicy := &lnrpc.RoutingPolicy{\n\t\tFeeBaseMsat:      defaultFeeBase,\n\t\tFeeRateMilliMsat: defaultFeeRate,\n\t\tTimeLockDelta:    defaultTimeLockDelta,\n\t\tMinHtlc:          defaultMinHtlc,\n\t\tMaxHtlcMsat:      defaultMaxHtlc,\n\t}\n\n\tassertNodesPolicyUpdate(ht, nodes, alice, expectedPolicy, chanPoint)\n\tassertNodesPolicyUpdate(ht, nodes, bob, expectedPolicy, chanPoint)\n\n\t// They should now know about the default policies.\n\tfor _, node := range nodes {\n\t\tht.AssertChannelPolicy(\n\t\t\tnode, alice.PubKeyStr, expectedPolicy, chanPoint,\n\t\t)\n\t\tht.AssertChannelPolicy(\n\t\t\tnode, bob.PubKeyStr, expectedPolicy, chanPoint,\n\t\t)\n\t}\n\n\t// Create Carol with options to rate limit channel updates up to 2 per\n\t// day, and create a new channel Bob->Carol.\n\tcarol := ht.NewNode(\n\t\t\"Carol\", []string{\n\t\t\t\"--gossip.max-channel-update-burst=2\",\n\t\t\t\"--gossip.channel-update-interval=24h\",\n\t\t},\n\t)\n\tht.ConnectNodes(carol, bob)\n\tnodes = append(nodes, carol)\n\n\t// Send some coins to Carol that can be used for channel funding.\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, carol)\n\n\t// Open the channel Carol->Bob with a custom min_htlc value set. Since\n\t// Carol is opening the channel, she will require Bob to not forward\n\t// HTLCs smaller than this value, and hence he should advertise it as\n\t// part of his ChannelUpdate.\n\tconst customMinHtlc = 5000\n\tchanPoint2 := ht.OpenChannel(\n\t\tcarol, bob, lntest.OpenChannelParams{\n\t\t\tAmt:     chanAmt,\n\t\t\tPushAmt: pushAmt,\n\t\t\tMinHtlc: customMinHtlc,\n\t\t},\n\t)\n\n\texpectedPolicyBob := &lnrpc.RoutingPolicy{\n\t\tFeeBaseMsat:      defaultFeeBase,\n\t\tFeeRateMilliMsat: defaultFeeRate,\n\t\tTimeLockDelta:    defaultTimeLockDelta,\n\t\tMinHtlc:          customMinHtlc,\n\t\tMaxHtlcMsat:      defaultMaxHtlc,\n\t}\n\texpectedPolicyCarol := &lnrpc.RoutingPolicy{\n\t\tFeeBaseMsat:      defaultFeeBase,\n\t\tFeeRateMilliMsat: defaultFeeRate,\n\t\tTimeLockDelta:    defaultTimeLockDelta,\n\t\tMinHtlc:          defaultMinHtlc,\n\t\tMaxHtlcMsat:      defaultMaxHtlc,\n\t}\n\n\tassertNodesPolicyUpdate(ht, nodes, bob, expectedPolicyBob, chanPoint2)\n\tassertNodesPolicyUpdate(\n\t\tht, nodes, carol, expectedPolicyCarol, chanPoint2,\n\t)\n\n\t// Check that all nodes now know about the updated policies.\n\tfor _, node := range nodes {\n\t\tht.AssertChannelPolicy(\n\t\t\tnode, bob.PubKeyStr, expectedPolicyBob, chanPoint2,\n\t\t)\n\t\tht.AssertChannelPolicy(\n\t\t\tnode, carol.PubKeyStr, expectedPolicyCarol, chanPoint2,\n\t\t)\n\t}\n\n\t// Make sure Alice and Carol have seen each other's channels.\n\tht.AssertTopologyChannelOpen(alice, chanPoint2)\n\tht.AssertTopologyChannelOpen(carol, chanPoint)\n\n\t// First we'll try to send a payment from Alice to Carol with an amount\n\t// less than the min_htlc value required by Carol. This payment should\n\t// fail, as the channel Bob->Carol cannot carry HTLCs this small.\n\tpayAmt := btcutil.Amount(4)\n\tinvoice := &lnrpc.Invoice{\n\t\tMemo:  \"testing\",\n\t\tValue: int64(payAmt),\n\t}\n\tresp := carol.RPC.AddInvoice(invoice)\n\n\t// Alice knows about the channel policy of Carol and should therefore\n\t// not be able to find a path during routing.\n\tpayReq := &routerrpc.SendPaymentRequest{\n\t\tPaymentRequest: resp.PaymentRequest,\n\t\tTimeoutSeconds: 60,\n\t\tFeeLimitMsat:   noFeeLimitMsat,\n\t}\n\tht.SendPaymentAssertFail(\n\t\talice, payReq,\n\t\tlnrpc.PaymentFailureReason_FAILURE_REASON_NO_ROUTE,\n\t)\n\n\t// Now we try to send a payment over the channel with a value too low\n\t// to be accepted. First we query for a route to route a payment of\n\t// 5000 mSAT, as this is accepted.\n\tpayAmt = btcutil.Amount(5)\n\troutesReq := &lnrpc.QueryRoutesRequest{\n\t\tPubKey:         carol.PubKeyStr,\n\t\tAmt:            int64(payAmt),\n\t\tFinalCltvDelta: defaultTimeLockDelta,\n\t}\n\troutes := alice.RPC.QueryRoutes(routesReq)\n\trequire.Len(ht, routes.Routes, 1)\n\n\t// We change the route to carry a payment of 4000 mSAT instead of 5000\n\t// mSAT.\n\tpayAmt = btcutil.Amount(4)\n\tamtSat := int64(payAmt)\n\tamtMSat := int64(lnwire.NewMSatFromSatoshis(payAmt))\n\troutes.Routes[0].Hops[0].AmtToForward = amtSat\n\troutes.Routes[0].Hops[0].AmtToForwardMsat = amtMSat\n\troutes.Routes[0].Hops[1].AmtToForward = amtSat\n\troutes.Routes[0].Hops[1].AmtToForwardMsat = amtMSat\n\n\t// Send the payment with the modified value.\n\talicePayStream := alice.RPC.SendToRoute()\n\n\tsendReq := &lnrpc.SendToRouteRequest{\n\t\tPaymentHash: resp.RHash,\n\t\tRoute:       routes.Routes[0],\n\t}\n\terr := alicePayStream.Send(sendReq)\n\trequire.NoError(ht, err, \"unable to send payment\")\n\n\t// We expect this payment to fail, and that the min_htlc value is\n\t// communicated back to us, since the attempted HTLC value was too low.\n\tsendResp, err := ht.ReceiveSendToRouteUpdate(alicePayStream)\n\trequire.NoError(ht, err, \"unable to receive payment stream\")\n\n\t// Expected as part of the error message.\n\tsubstrs := []string{\n\t\t\"AmountBelowMinimum\",\n\t\t\"HtlcMinimumMsat: (lnwire.MilliSatoshi) 5000 mSAT\",\n\t}\n\tfor _, s := range substrs {\n\t\trequire.Contains(ht, sendResp.PaymentError, s)\n\t}\n\n\t// Make sure sending using the original value succeeds.\n\tpayAmt = btcutil.Amount(5)\n\tamtSat = int64(payAmt)\n\tamtMSat = int64(lnwire.NewMSatFromSatoshis(payAmt))\n\troutes.Routes[0].Hops[0].AmtToForward = amtSat\n\troutes.Routes[0].Hops[0].AmtToForwardMsat = amtMSat\n\troutes.Routes[0].Hops[1].AmtToForward = amtSat\n\troutes.Routes[0].Hops[1].AmtToForwardMsat = amtMSat\n\n\t// Manually set the MPP payload a new for each payment since\n\t// the payment addr will change with each invoice, although we\n\t// can re-use the route itself.\n\troute := routes.Routes[0]\n\troute.Hops[len(route.Hops)-1].TlvPayload = true\n\troute.Hops[len(route.Hops)-1].MppRecord = &lnrpc.MPPRecord{\n\t\tPaymentAddr:  resp.PaymentAddr,\n\t\tTotalAmtMsat: amtMSat,\n\t}\n\n\tsendReq = &lnrpc.SendToRouteRequest{\n\t\tPaymentHash: resp.RHash,\n\t\tRoute:       route,\n\t}\n\n\terr = alicePayStream.Send(sendReq)\n\trequire.NoError(ht, err, \"unable to send payment\")\n\n\tsendResp, err = ht.ReceiveSendToRouteUpdate(alicePayStream)\n\trequire.NoError(ht, err, \"unable to receive payment stream\")\n\trequire.Empty(ht, sendResp.PaymentError, \"expected payment to succeed\")\n\n\t// With our little cluster set up, we'll update the fees and the max\n\t// htlc size for the Bob side of the Alice->Bob channel, and make sure\n\t// all nodes learn about it.\n\tbaseFee := int64(1500)\n\tfeeRate := int64(12)\n\ttimeLockDelta := uint32(66)\n\tmaxHtlc := uint64(500000)\n\n\texpectedPolicy = &lnrpc.RoutingPolicy{\n\t\tFeeBaseMsat:      baseFee,\n\t\tFeeRateMilliMsat: testFeeBase * feeRate,\n\t\tTimeLockDelta:    timeLockDelta,\n\t\tMinHtlc:          defaultMinHtlc,\n\t\tMaxHtlcMsat:      maxHtlc,\n\t}\n\n\treq := &lnrpc.PolicyUpdateRequest{\n\t\tBaseFeeMsat:   baseFee,\n\t\tFeeRate:       float64(feeRate),\n\t\tTimeLockDelta: timeLockDelta,\n\t\tMaxHtlcMsat:   maxHtlc,\n\t\tScope: &lnrpc.PolicyUpdateRequest_ChanPoint{\n\t\t\tChanPoint: chanPoint,\n\t\t},\n\t}\n\tbob.RPC.UpdateChannelPolicy(req)\n\n\t// Wait for all nodes to have seen the policy update done by Bob.\n\tassertNodesPolicyUpdate(ht, nodes, bob, expectedPolicy, chanPoint)\n\n\t// Check that all nodes now know about Bob's updated policy.\n\tfor _, node := range nodes {\n\t\tht.AssertChannelPolicy(\n\t\t\tnode, bob.PubKeyStr, expectedPolicy, chanPoint,\n\t\t)\n\t}\n\n\t// Now that all nodes have received the new channel update, we'll try\n\t// to send a payment from Alice to Carol to ensure that Alice has\n\t// internalized this fee update. This shouldn't affect the route that\n\t// Alice takes though: we updated the Alice -> Bob channel and she\n\t// doesn't pay for transit over that channel as it's direct.\n\t// Note that the payment amount is >= the min_htlc value for the\n\t// channel Bob->Carol, so it should successfully be forwarded.\n\tpayAmt = btcutil.Amount(5)\n\tinvoice = &lnrpc.Invoice{\n\t\tMemo:  \"testing\",\n\t\tValue: int64(payAmt),\n\t}\n\tresp = carol.RPC.AddInvoice(invoice)\n\n\tht.CompletePaymentRequests(alice, []string{resp.PaymentRequest})\n\n\t// We'll now open a channel from Alice directly to Carol.\n\tht.ConnectNodes(alice, carol)\n\tchanPoint3 := ht.OpenChannel(\n\t\talice, carol, lntest.OpenChannelParams{\n\t\t\tAmt:     chanAmt,\n\t\t\tPushAmt: pushAmt,\n\t\t},\n\t)\n\n\t// Make sure Bob knows this channel.\n\tht.AssertTopologyChannelOpen(bob, chanPoint3)\n\n\t// Make a global update, and check that both channels' new policies get\n\t// propagated.\n\tbaseFee = int64(800)\n\tfeeRate = int64(123)\n\ttimeLockDelta = uint32(22)\n\tmaxHtlc *= 2\n\n\texpectedPolicy.FeeBaseMsat = baseFee\n\texpectedPolicy.FeeRateMilliMsat = testFeeBase * feeRate\n\texpectedPolicy.TimeLockDelta = timeLockDelta\n\texpectedPolicy.MaxHtlcMsat = maxHtlc\n\n\treq = &lnrpc.PolicyUpdateRequest{\n\t\tBaseFeeMsat:   baseFee,\n\t\tFeeRate:       float64(feeRate),\n\t\tTimeLockDelta: timeLockDelta,\n\t\tMaxHtlcMsat:   maxHtlc,\n\t}\n\treq.Scope = &lnrpc.PolicyUpdateRequest_Global{}\n\talice.RPC.UpdateChannelPolicy(req)\n\n\t// Wait for all nodes to have seen the policy updates for both of\n\t// Alice's channels.\n\tassertNodesPolicyUpdate(ht, nodes, alice, expectedPolicy, chanPoint)\n\tassertNodesPolicyUpdate(ht, nodes, alice, expectedPolicy, chanPoint3)\n\n\t// And finally check that all nodes remembers the policy update they\n\t// received.\n\tfor _, node := range nodes {\n\t\tht.AssertChannelPolicy(\n\t\t\tnode, alice.PubKeyStr, expectedPolicy, chanPoint,\n\t\t)\n\t\tht.AssertChannelPolicy(\n\t\t\tnode, alice.PubKeyStr, expectedPolicy, chanPoint3,\n\t\t)\n\t}\n\n\t// Now, to test that Carol is properly rate limiting incoming updates,\n\t// we'll send two more update from Alice. Carol should accept the first,\n\t// but not the second, as she only allows two updates per day and a day\n\t// has yet to elapse from the previous update.\n\n\t// assertAliceAndBob is a helper closure which updates Alice's policy\n\t// and asserts that both Alice and Bob have heard and updated the\n\t// policy in their graph.\n\tassertAliceAndBob := func(req *lnrpc.PolicyUpdateRequest,\n\t\texpectedPolicy *lnrpc.RoutingPolicy) {\n\n\t\talice.RPC.UpdateChannelPolicy(req)\n\n\t\t// Wait for all nodes to have seen the policy updates for both\n\t\t// of Alice's channels. Carol will not see the last update as\n\t\t// the limit has been reached.\n\t\tassertNodesPolicyUpdate(\n\t\t\tht, []*node.HarnessNode{alice, bob},\n\t\t\talice, expectedPolicy, chanPoint,\n\t\t)\n\t\tassertNodesPolicyUpdate(\n\t\t\tht, []*node.HarnessNode{alice, bob},\n\t\t\talice, expectedPolicy, chanPoint3,\n\t\t)\n\n\t\t// Check that all nodes remember the policy update\n\t\t// they received.\n\t\tht.AssertChannelPolicy(\n\t\t\talice, alice.PubKeyStr, expectedPolicy, chanPoint,\n\t\t)\n\t\tht.AssertChannelPolicy(\n\t\t\talice, alice.PubKeyStr, expectedPolicy, chanPoint3,\n\t\t)\n\t\tht.AssertChannelPolicy(\n\t\t\tbob, alice.PubKeyStr, expectedPolicy, chanPoint,\n\t\t)\n\t\tht.AssertChannelPolicy(\n\t\t\tbob, alice.PubKeyStr, expectedPolicy, chanPoint3,\n\t\t)\n\t}\n\n\t// Double the base fee and attach to the policy.\n\tbaseFee1 := baseFee * 2\n\texpectedPolicy.FeeBaseMsat = baseFee1\n\treq.BaseFeeMsat = baseFee1\n\tassertAliceAndBob(req, expectedPolicy)\n\n\t// Check that Carol has both heard the policy and updated it in her\n\t// graph.\n\tassertNodesPolicyUpdate(\n\t\tht, []*node.HarnessNode{carol},\n\t\talice, expectedPolicy, chanPoint,\n\t)\n\tassertNodesPolicyUpdate(\n\t\tht, []*node.HarnessNode{carol},\n\t\talice, expectedPolicy, chanPoint3,\n\t)\n\tht.AssertChannelPolicy(\n\t\tcarol, alice.PubKeyStr, expectedPolicy, chanPoint,\n\t)\n\tht.AssertChannelPolicy(\n\t\tcarol, alice.PubKeyStr, expectedPolicy, chanPoint3,\n\t)\n\n\t// Double the base fee and attach to the policy.\n\tbaseFee2 := baseFee1 * 2\n\texpectedPolicy.FeeBaseMsat = baseFee2\n\treq.BaseFeeMsat = baseFee2\n\tassertAliceAndBob(req, expectedPolicy)\n\n\t// Since Carol didn't receive the last update, she still has Alice's\n\t// old policy. We validate this by checking the base fee is the older\n\t// one.\n\texpectedPolicy.FeeBaseMsat = baseFee1\n\tht.AssertChannelPolicy(\n\t\tcarol, alice.PubKeyStr, expectedPolicy, chanPoint,\n\t)\n\tht.AssertChannelPolicy(\n\t\tcarol, alice.PubKeyStr, expectedPolicy, chanPoint3,\n\t)\n\n\t// Close all channels.\n\tht.CloseChannel(alice, chanPoint)\n\tht.CloseChannel(bob, chanPoint2)\n\tht.CloseChannel(alice, chanPoint3)\n}\n\n// testSendUpdateDisableChannel ensures that a channel update with the disable\n// flag set is sent once a channel has been either unilaterally or cooperatively\n// closed.\n//\n// NOTE: this test can be flaky as we are testing the chan-enable-timeout and\n// chan-disable-timeout flags here. For instance, if some operations take more\n// than 6 seconds to finish, the channel will be marked as disabled, thus a\n// following operation will fail if it relies on the channel being enabled.",
      "length": 12605,
      "tokens": 1495,
      "embedding": []
    },
    {
      "slug": "func testSendUpdateDisableChannel(ht *lntest.HarnessTest) {",
      "content": "func testSendUpdateDisableChannel(ht *lntest.HarnessTest) {\n\tconst chanAmt = 100000\n\n\talice, bob := ht.Alice, ht.Bob\n\n\t// Create a new node Eve, which will be restarted later with a config\n\t// that has an inactive channel timeout of just 6 seconds (down from\n\t// the default 20m). It will be used to test channel updates for\n\t// channels going inactive.\n\t//\n\t// NOTE: we don't create Eve with the chan-disable-timeout here because\n\t// the following channel openings might take longer than that timeout\n\t// value, which will cause the channel Eve=>Carol being marked as\n\t// disabled.\n\teve := ht.NewNode(\"Eve\", nil)\n\n\t// Create a new node Carol, which will later be restarted with the same\n\t// config as Eve's.\n\tcarol := ht.NewNode(\"Carol\", nil)\n\n\t// Launch a node for Dave which will connect to Bob in order to receive\n\t// graph updates from. This will ensure that the channel updates are\n\t// propagated throughout the network.\n\tdave := ht.NewNode(\"Dave\", nil)\n\n\t// We will start our test by creating the following topology,\n\t// Alice --- Bob --- Dave\n\t//   |       |\n\t// Carol --- Eve\n\tht.EnsureConnected(alice, bob)\n\tht.ConnectNodes(alice, carol)\n\tht.ConnectNodes(bob, dave)\n\tht.ConnectNodes(eve, carol)\n\n\t// Connect Eve and Bob using a persistent connection. Later after Eve\n\t// is restarted, they will connect again automatically.\n\tht.ConnectNodesPerm(bob, eve)\n\n\t// Give Eve some coins.\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, eve)\n\n\t// We now proceed to open channels: Alice=>Bob, Alice=>Carol and\n\t// Eve=>Carol.\n\tp := lntest.OpenChannelParams{Amt: chanAmt}\n\treqs := []*lntest.OpenChannelRequest{\n\t\t{Local: alice, Remote: bob, Param: p},\n\t\t{Local: alice, Remote: carol, Param: p},\n\t\t{Local: eve, Remote: carol, Param: p},\n\t}\n\tresp := ht.OpenMultiChannelsAsync(reqs)\n\n\t// Extract channel points from the response.\n\tchanPointAliceBob := resp[0]\n\tchanPointAliceCarol := resp[1]\n\tchanPointEveCarol := resp[2]\n\n\t// We will use 10 seconds as the disable timeout.\n\tchanDisableTimeout := 10\n\tchanEnableTimeout := 5\n\n\t// waitChanDisabled is a helper closure to wait the chanDisableTimeout\n\t// seconds such that the channel disable logic is taking effect.\n\twaitChanDisabled := func() {\n\t\ttime.Sleep(time.Duration(chanDisableTimeout) * time.Second)\n\t}\n\n\t// With the channels open, we now restart Carol and Eve to use\n\t// customized timeout values.\n\tnodeCfg := []string{\n\t\t\"--minbackoff=60s\",\n\t\tfmt.Sprintf(\"--chan-enable-timeout=%ds\", chanEnableTimeout),\n\t\tfmt.Sprintf(\"--chan-disable-timeout=%ds\", chanDisableTimeout),\n\t\t\"--chan-status-sample-interval=.5s\",\n\t}\n\tht.RestartNodeWithExtraArgs(carol, nodeCfg)\n\tht.RestartNodeWithExtraArgs(eve, nodeCfg)\n\n\t// Dave should know all the channels.\n\tht.AssertTopologyChannelOpen(dave, chanPointAliceBob)\n\tht.AssertTopologyChannelOpen(dave, chanPointAliceCarol)\n\tht.AssertTopologyChannelOpen(dave, chanPointEveCarol)\n\n\t// We should expect to see a channel update with the default routing\n\t// policy, except that it should indicate the channel is disabled.\n\texpectedPolicy := &lnrpc.RoutingPolicy{\n\t\tFeeBaseMsat:      int64(chainreg.DefaultBitcoinBaseFeeMSat),\n\t\tFeeRateMilliMsat: int64(chainreg.DefaultBitcoinFeeRate),\n\t\tTimeLockDelta:    chainreg.DefaultBitcoinTimeLockDelta,\n\t\tMinHtlc:          1000, // default value\n\t\tMaxHtlcMsat:      lntest.CalculateMaxHtlc(chanAmt),\n\t\tDisabled:         true,\n\t}\n\n\t// assertPolicyUpdate checks that the required policy update has\n\t// happened on the given node.\n\tassertPolicyUpdate := func(node *node.HarnessNode,\n\t\tpolicy *lnrpc.RoutingPolicy, chanPoint *lnrpc.ChannelPoint,\n\t\tnumUpdates int) {\n\n\t\tht.AssertNumPolicyUpdates(dave, chanPoint, node, numUpdates)\n\t\tht.AssertChannelPolicyUpdate(\n\t\t\tdave, node, policy, chanPoint, false,\n\t\t)\n\t}\n\n\t// Let Carol go offline. Since Eve has an inactive timeout of 6s, we\n\t// expect her to send an update disabling the channel.\n\trestartCarol := ht.SuspendNode(carol)\n\n\t// We expect to see a total of 2 channel policy updates from the\n\t// channel Carol <-> Eve and advertised by Eve using the route\n\t// Eve->Bob->Dave.\n\twaitChanDisabled()\n\tassertPolicyUpdate(eve, expectedPolicy, chanPointEveCarol, 2)\n\n\t// We restart Carol. Since the channel now becomes active again, Eve\n\t// should send a ChannelUpdate setting the channel no longer disabled.\n\trequire.NoError(ht, restartCarol(), \"unable to restart carol\")\n\n\texpectedPolicy.Disabled = false\n\t// We expect to see a total of 3 channel policy updates from the\n\t// channel Carol <-> Eve and advertised by Eve using the route\n\t// Eve->Bob->Dave.\n\tassertPolicyUpdate(eve, expectedPolicy, chanPointEveCarol, 3)\n\n\t// Wait until Carol and Eve are reconnected before we disconnect them\n\t// again.\n\tht.EnsureConnected(eve, carol)\n\n\t// Now we'll test a long disconnection. Disconnect Carol and Eve and\n\t// ensure they both detect each other as disabled. Their min backoffs\n\t// are high enough to not interfere with disabling logic.\n\tht.DisconnectNodes(carol, eve)\n\n\t// Wait for a disable from both Carol and Eve to come through.\n\texpectedPolicy.Disabled = true\n\t// We expect to see a total of 4 channel policy updates from the\n\t// channel Carol <-> Eve and advertised by Eve using the route\n\t// Eve->Bob->Dave.\n\twaitChanDisabled()\n\tassertPolicyUpdate(eve, expectedPolicy, chanPointEveCarol, 4)\n\n\t// Because Carol has restarted twice before, depending on how much time\n\t// it has taken, she might mark the channel disabled and enable it\n\t// multiple times.  Thus we could see a total of 2 or 4 or 6 channel\n\t// policy updates from the channel Carol <-> Eve and advertised by\n\t// Carol using the route Carol->Alice->Bob->Dave.\n\t//\n\t// Assume there are 2 channel policy updates from Carol, and update it\n\t// if more has found\n\tnumCarol := 2\n\top := ht.OutPointFromChannelPoint(chanPointEveCarol)\n\tpolicyMap := dave.Watcher.GetPolicyUpdates(op)\n\tnodePolicy, ok := policyMap[carol.PubKeyStr]\n\tswitch {\n\tcase !ok:\n\t\tbreak\n\tcase len(nodePolicy) > 2:\n\t\tnumCarol = 4\n\tcase len(nodePolicy) > 4:\n\t\tnumCarol = 6\n\t}\n\tassertPolicyUpdate(carol, expectedPolicy, chanPointEveCarol, numCarol)\n\n\t// Reconnect Carol and Eve, this should cause them to reenable the\n\t// channel from both ends after a short delay.\n\tht.EnsureConnected(carol, eve)\n\n\texpectedPolicy.Disabled = false\n\t// We expect to see a total of 5 channel policy updates from the\n\t// channel Carol <-> Eve and advertised by Eve using the route\n\t// Eve->Bob->Dave.\n\tassertPolicyUpdate(eve, expectedPolicy, chanPointEveCarol, 5)\n\t// We expect to see a total of 3 or 5 channel policy updates from the\n\t// channel Carol <-> Eve and advertised by Carol using the route\n\t// Carol->Alice->Bob->Dave.\n\tnumCarol++\n\tassertPolicyUpdate(carol, expectedPolicy, chanPointEveCarol, numCarol)\n\n\t// Now we'll test a short disconnection. Disconnect Carol and Eve, then\n\t// reconnect them after one second so that their scheduled disables are\n\t// aborted. One second is twice the status sample interval, so this\n\t// should allow for the disconnect to be detected, but still leave time\n\t// to cancel the announcement before the 6 second inactive timeout is\n\t// hit.\n\tht.DisconnectNodes(carol, eve)\n\ttime.Sleep(time.Second)\n\tht.EnsureConnected(eve, carol)\n\n\t// Since the disable should have been canceled by both Carol and Eve,\n\t// we expect no channel updates to appear on the network, which means\n\t// we expect the polices stay unchanged(Disable == false).\n\tassertPolicyUpdate(eve, expectedPolicy, chanPointEveCarol, 5)\n\tassertPolicyUpdate(carol, expectedPolicy, chanPointEveCarol, numCarol)\n\n\t// Close Alice's channels with Bob and Carol cooperatively and\n\t// unilaterally respectively. Note that the CloseChannel will mine a\n\t// block and check that the closing transaction can be found in both\n\t// the mempool and the block.\n\tht.CloseChannel(alice, chanPointAliceBob)\n\tht.ForceCloseChannel(alice, chanPointAliceCarol)\n\n\t// Now that the channel close processes have been started, we should\n\t// receive an update marking each as disabled.\n\texpectedPolicy.Disabled = true\n\t// We expect to see a total of 2 channel policy updates from the\n\t// channel Alice <-> Bob and advertised by Alice using the route\n\t// Alice->Bob->Dave.\n\tassertPolicyUpdate(alice, expectedPolicy, chanPointAliceBob, 2)\n\t// We expect to see a total of 2 channel policy updates from the\n\t// channel Alice <-> Carol and advertised by Alice using the route\n\t// Alice->Bob->Dave.\n\tassertPolicyUpdate(alice, expectedPolicy, chanPointAliceCarol, 2)\n\n\t// Also do this check for Eve's channel with Carol.\n\tht.CloseChannel(eve, chanPointEveCarol)\n\n\t// We expect to see a total of 5 channel policy updates from the\n\t// channel Carol <-> Eve and advertised by Eve using the route\n\t// Eve->Bob->Dave.\n\tassertPolicyUpdate(eve, expectedPolicy, chanPointEveCarol, 6)\n}\n\n// testUpdateChannelPolicyForPrivateChannel tests when a private channel\n// updates its channel edge policy, we will use the updated policy to send our\n// payment.\n// The topology is created as: Alice -> Bob -> Carol, where Alice -> Bob is\n// public and Bob -> Carol is private. After an invoice is created by Carol,\n// Bob will update the base fee via UpdateChannelPolicy, we will test that\n// Alice will not fail the payment and send it using the updated channel\n// policy.",
      "length": 8890,
      "tokens": 1242,
      "embedding": []
    },
    {
      "slug": "func testUpdateChannelPolicyForPrivateChannel(ht *lntest.HarnessTest) {",
      "content": "func testUpdateChannelPolicyForPrivateChannel(ht *lntest.HarnessTest) {\n\tconst (\n\t\tchanAmt     = btcutil.Amount(100000)\n\t\tpaymentAmt  = 20000\n\t\tbaseFeeMSat = 33000\n\t)\n\n\t// We'll create the following topology first,\n\t// Alice <--public:100k--> Bob <--private:100k--> Carol\n\talice, bob := ht.Alice, ht.Bob\n\n\t// Open a channel with 100k satoshis between Alice and Bob.\n\tchanPointAliceBob := ht.OpenChannel(\n\t\talice, bob, lntest.OpenChannelParams{\n\t\t\tAmt: chanAmt,\n\t\t},\n\t)\n\n\t// Create a new node Carol.\n\tcarol := ht.NewNode(\"Carol\", nil)\n\n\t// Connect Carol to Bob.\n\tht.ConnectNodes(carol, bob)\n\n\t// Open a channel with 100k satoshis between Bob and Carol.\n\tchanPointBobCarol := ht.OpenChannel(\n\t\tbob, carol, lntest.OpenChannelParams{\n\t\t\tAmt:     chanAmt,\n\t\t\tPrivate: true,\n\t\t},\n\t)\n\n\t// Carol should be aware of the channel between Alice and Bob.\n\tht.AssertTopologyChannelOpen(carol, chanPointAliceBob)\n\n\t// We should have the following topology now,\n\t// Alice <--public:100k--> Bob <--private:100k--> Carol\n\t//\n\t// Now we will create an invoice for Carol.\n\tinvoice := &lnrpc.Invoice{\n\t\tMemo:    \"routing hints\",\n\t\tValue:   paymentAmt,\n\t\tPrivate: true,\n\t}\n\tresp := carol.RPC.AddInvoice(invoice)\n\n\t// Bob now updates the channel edge policy for the private channel.\n\ttimeLockDelta := uint32(chainreg.DefaultBitcoinTimeLockDelta)\n\tupdateFeeReq := &lnrpc.PolicyUpdateRequest{\n\t\tBaseFeeMsat:   baseFeeMSat,\n\t\tTimeLockDelta: timeLockDelta,\n\t\tScope: &lnrpc.PolicyUpdateRequest_ChanPoint{\n\t\t\tChanPoint: chanPointBobCarol,\n\t\t},\n\t}\n\tbob.RPC.UpdateChannelPolicy(updateFeeReq)\n\n\t// Alice pays the invoices. She will use the updated baseFeeMSat in the\n\t// payment\n\t//\n\t// TODO(yy): we may get a flake saying the timeout checking the\n\t// payment's state, which is due to slow round of HTLC settlement. An\n\t// example log is shown below, where Alice sent RevokeAndAck to Bob,\n\t// but it took Bob 7 seconds to reply back the final UpdateFulfillHTLC.\n\t//\n\t// 2022-11-14 06:23:59.774 PEER: Peer(Bob): Sending UpdateAddHTLC\n\t// 2022-11-14 06:24:00.635 PEER: Peer(Bob): Sending CommitSig\n\t// 2022-11-14 06:24:01.784 PEER: Peer(Bob): Sending RevokeAndAck\n\t// 2022-11-14 06:24:08.464 PEER: Peer(Bob): Received UpdateFulfillHTLC\n\t//\n\t// 7 seconds is too long for a local test and this needs more\n\t// investigation.\n\tpayReqs := []string{resp.PaymentRequest}\n\tht.CompletePaymentRequests(alice, payReqs)\n\n\t// Check that Alice did make the payment with two HTLCs, one failed and\n\t// one succeeded.\n\tpayment := ht.AssertNumPayments(alice, 1)[0]\n\n\thtlcs := payment.Htlcs\n\trequire.Equal(ht, 2, len(htlcs), \"expected to have 2 HTLCs\")\n\trequire.Equal(ht, lnrpc.HTLCAttempt_FAILED, htlcs[0].Status,\n\t\t\"the first HTLC attempt should fail\")\n\trequire.Equal(ht, lnrpc.HTLCAttempt_SUCCEEDED, htlcs[1].Status,\n\t\t\"the second HTLC attempt should succeed\")\n\n\t// Carol should have received 20k satoshis from Bob.\n\tht.AssertAmountPaid(\"Carol(remote) [<=private] Bob(local)\",\n\t\tcarol, chanPointBobCarol, 0, paymentAmt)\n\n\t// Bob should have sent 20k satoshis to Carol.\n\tht.AssertAmountPaid(\"Bob(local) [private=>] Carol(remote)\",\n\t\tbob, chanPointBobCarol, paymentAmt, 0)\n\n\t// Calculate the amount in satoshis.\n\tamtExpected := int64(paymentAmt + baseFeeMSat/1000)\n\n\t// Bob should have received 20k satoshis + fee from Alice.\n\tht.AssertAmountPaid(\"Bob(remote) <= Alice(local)\",\n\t\tbob, chanPointAliceBob, 0, amtExpected)\n\n\t// Alice should have sent 20k satoshis + fee to Bob.\n\tht.AssertAmountPaid(\"Alice(local) => Bob(remote)\",\n\t\talice, chanPointAliceBob, amtExpected, 0)\n\n\t// Finally, close the channels.\n\tht.CloseChannel(alice, chanPointAliceBob)\n\tht.CloseChannel(bob, chanPointBobCarol)\n}\n\n// testUpdateChannelPolicyFeeRateAccuracy tests that updating the channel policy\n// rounds fee rate values correctly as well as setting fee rate with ppm works\n// as expected.",
      "length": 3632,
      "tokens": 454,
      "embedding": []
    },
    {
      "slug": "func testUpdateChannelPolicyFeeRateAccuracy(ht *lntest.HarnessTest) {",
      "content": "func testUpdateChannelPolicyFeeRateAccuracy(ht *lntest.HarnessTest) {\n\tchanAmt := funding.MaxBtcFundingAmount\n\tpushAmt := chanAmt / 2\n\n\t// Create a channel Alice -> Bob.\n\talice, bob := ht.Alice, ht.Bob\n\tchanPoint := ht.OpenChannel(\n\t\talice, bob, lntest.OpenChannelParams{\n\t\t\tAmt:     chanAmt,\n\t\t\tPushAmt: pushAmt,\n\t\t},\n\t)\n\n\t// Nodes that we need to make sure receive the channel updates.\n\tnodes := []*node.HarnessNode{alice, bob}\n\n\tbaseFee := int64(1500)\n\ttimeLockDelta := uint32(66)\n\tmaxHtlc := uint64(500000)\n\tdefaultMinHtlc := int64(1000)\n\n\t// Originally LND did not properly round up fee rates which caused\n\t// inaccuracy where fee rates were simply rounded down due to the\n\t// integer conversion.\n\t//\n\t// We'll use a fee rate of 0.031337 which without rounding up would\n\t// have resulted in a fee rate ppm of 31336.\n\tfeeRate := 0.031337\n\n\t// Expected fee rate will be rounded up.\n\texpectedFeeRateMilliMsat := int64(math.Round(testFeeBase * feeRate))\n\n\texpectedPolicy := &lnrpc.RoutingPolicy{\n\t\tFeeBaseMsat:      baseFee,\n\t\tFeeRateMilliMsat: expectedFeeRateMilliMsat,\n\t\tTimeLockDelta:    timeLockDelta,\n\t\tMinHtlc:          defaultMinHtlc,\n\t\tMaxHtlcMsat:      maxHtlc,\n\t}\n\n\treq := &lnrpc.PolicyUpdateRequest{\n\t\tBaseFeeMsat:   baseFee,\n\t\tFeeRate:       feeRate,\n\t\tTimeLockDelta: timeLockDelta,\n\t\tMaxHtlcMsat:   maxHtlc,\n\t\tScope: &lnrpc.PolicyUpdateRequest_ChanPoint{\n\t\t\tChanPoint: chanPoint,\n\t\t},\n\t}\n\talice.RPC.UpdateChannelPolicy(req)\n\n\t// Make sure that both Alice and Bob sees the same policy after update.\n\tassertNodesPolicyUpdate(ht, nodes, alice, expectedPolicy, chanPoint)\n\n\t// Now use the new PPM feerate field and make sure that the feerate is\n\t// correctly set.\n\tfeeRatePPM := uint32(32337)\n\treq.FeeRate = 0 // Can't set both at the same time.\n\treq.FeeRatePpm = feeRatePPM\n\texpectedPolicy.FeeRateMilliMsat = int64(feeRatePPM)\n\n\talice.RPC.UpdateChannelPolicy(req)\n\n\t// Make sure that both Alice and Bob sees the same policy after update.\n\tassertNodesPolicyUpdate(ht, nodes, alice, expectedPolicy, chanPoint)\n\n\tht.CloseChannel(alice, chanPoint)\n}\n\n// assertNodesPolicyUpdate checks that a given policy update has been received\n// by a list of given nodes.",
      "length": 2026,
      "tokens": 257,
      "embedding": []
    },
    {
      "slug": "func assertNodesPolicyUpdate(ht *lntest.HarnessTest, nodes []*node.HarnessNode,",
      "content": "func assertNodesPolicyUpdate(ht *lntest.HarnessTest, nodes []*node.HarnessNode,\n\tadvertisingNode *node.HarnessNode, policy *lnrpc.RoutingPolicy,\n\tchanPoint *lnrpc.ChannelPoint) {\n\n\tfor _, node := range nodes {\n\t\tht.AssertChannelPolicyUpdate(\n\t\t\tnode, advertisingNode, policy, chanPoint, false,\n\t\t)\n\t}\n}\n",
      "length": 214,
      "tokens": 23,
      "embedding": []
    }
  ]
}