{
  "filepath": "../implementations/go/lnd/itest/lnd_onchain_test.go",
  "package": "itest",
  "sections": [
    {
      "slug": "func testChainKit(ht *lntest.HarnessTest) {",
      "content": "func testChainKit(ht *lntest.HarnessTest) {\n\t// Test functions registered as test cases spin up separate nodes\n\t// during execution. By calling sub-test functions as seen below we\n\t// avoid the need to start separate nodes.\n\ttestChainKitGetBlock(ht)\n\ttestChainKitGetBlockHash(ht)\n}\n\n// testChainKitGetBlock ensures that given a block hash, the RPC endpoint\n// returns the correct target block.",
      "length": 341,
      "tokens": 50,
      "embedding": []
    },
    {
      "slug": "func testChainKitGetBlock(ht *lntest.HarnessTest) {",
      "content": "func testChainKitGetBlock(ht *lntest.HarnessTest) {\n\t// Get best block hash.\n\tbestBlockRes := ht.Alice.RPC.GetBestBlock(nil)\n\n\tvar bestBlockHash chainhash.Hash\n\terr := bestBlockHash.SetBytes(bestBlockRes.BlockHash)\n\trequire.NoError(ht, err)\n\n\t// Retrieve the best block by hash.\n\tgetBlockReq := &chainrpc.GetBlockRequest{\n\t\tBlockHash: bestBlockHash[:],\n\t}\n\tgetBlockRes := ht.Alice.RPC.GetBlock(getBlockReq)\n\n\t// Deserialize the block which was retrieved by hash.\n\tmsgBlock := &wire.MsgBlock{}\n\tblockReader := bytes.NewReader(getBlockRes.RawBlock)\n\terr = msgBlock.Deserialize(blockReader)\n\trequire.NoError(ht, err)\n\n\t// Ensure best block hash is the same as retrieved block hash.\n\texpected := bestBlockHash\n\tactual := msgBlock.BlockHash()\n\trequire.Equal(ht, expected, actual)\n}\n\n// testChainKitGetBlockHash ensures that given a block height, the RPC endpoint\n// returns the correct target block hash.",
      "length": 821,
      "tokens": 92,
      "embedding": []
    },
    {
      "slug": "func testChainKitGetBlockHash(ht *lntest.HarnessTest) {",
      "content": "func testChainKitGetBlockHash(ht *lntest.HarnessTest) {\n\t// Get best block hash.\n\tbestBlockRes := ht.Alice.RPC.GetBestBlock(nil)\n\n\t// Retrieve the block hash at best block height.\n\treq := &chainrpc.GetBlockHashRequest{\n\t\tBlockHeight: int64(bestBlockRes.BlockHeight),\n\t}\n\tgetBlockHashRes := ht.Alice.RPC.GetBlockHash(req)\n\n\t// Ensure best block hash is the same as retrieved block hash.\n\texpected := bestBlockRes.BlockHash\n\tactual := getBlockHashRes.BlockHash\n\trequire.Equal(ht, expected, actual)\n}\n\n// testCPFP ensures that the daemon can bump an unconfirmed  transaction's fee\n// rate by broadcasting a Child-Pays-For-Parent (CPFP) transaction.\n//\n// TODO(wilmer): Add RBF case once btcd supports it.",
      "length": 627,
      "tokens": 78,
      "embedding": []
    },
    {
      "slug": "func testCPFP(ht *lntest.HarnessTest) {",
      "content": "func testCPFP(ht *lntest.HarnessTest) {\n\trunCPFP(ht, ht.Alice, ht.Bob)\n}\n\n// runCPFP ensures that the daemon can bump an unconfirmed  transaction's fee\n// rate by broadcasting a Child-Pays-For-Parent (CPFP) transaction.",
      "length": 175,
      "tokens": 24,
      "embedding": []
    },
    {
      "slug": "func runCPFP(ht *lntest.HarnessTest, alice, bob *node.HarnessNode) {",
      "content": "func runCPFP(ht *lntest.HarnessTest, alice, bob *node.HarnessNode) {\n\t// Skip this test for neutrino, as it's not aware of mempool\n\t// transactions.\n\tif ht.IsNeutrinoBackend() {\n\t\tht.Skipf(\"skipping CPFP test for neutrino backend\")\n\t}\n\n\t// We'll start the test by sending Alice some coins, which she'll use\n\t// to send to Bob.\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, alice)\n\n\t// Create an address for Bob to send the coins to.\n\treq := &lnrpc.NewAddressRequest{\n\t\tType: lnrpc.AddressType_WITNESS_PUBKEY_HASH,\n\t}\n\tresp := bob.RPC.NewAddress(req)\n\n\t// Send the coins from Alice to Bob. We should expect a transaction to\n\t// be broadcast and seen in the mempool.\n\tsendReq := &lnrpc.SendCoinsRequest{\n\t\tAddr:   resp.Address,\n\t\tAmount: btcutil.SatoshiPerBitcoin,\n\t}\n\talice.RPC.SendCoins(sendReq)\n\ttxid := ht.Miner.AssertNumTxsInMempool(1)[0]\n\n\t// We'll then extract the raw transaction from the mempool in order to\n\t// determine the index of Bob's output.\n\ttx := ht.Miner.GetRawTransaction(txid)\n\tbobOutputIdx := -1\n\tfor i, txOut := range tx.MsgTx().TxOut {\n\t\t_, addrs, _, err := txscript.ExtractPkScriptAddrs(\n\t\t\ttxOut.PkScript, ht.Miner.ActiveNet,\n\t\t)\n\t\trequire.NoErrorf(ht, err, \"unable to extract address \"+\n\t\t\t\"from pkScript=%x: %v\", txOut.PkScript, err)\n\n\t\tif addrs[0].String() == resp.Address {\n\t\t\tbobOutputIdx = i\n\t\t}\n\t}\n\trequire.NotEqual(ht, -1, bobOutputIdx, \"bob's output was not found \"+\n\t\t\"within the transaction\")\n\n\t// Wait until bob has seen the tx and considers it as owned.\n\top := &lnrpc.OutPoint{\n\t\tTxidBytes:   txid[:],\n\t\tOutputIndex: uint32(bobOutputIdx),\n\t}\n\tht.AssertUTXOInWallet(bob, op, \"\")\n\n\t// We'll attempt to bump the fee of this transaction by performing a\n\t// CPFP from Alice's point of view.\n\tbumpFeeReq := &walletrpc.BumpFeeRequest{\n\t\tOutpoint: op,\n\t\tSatPerVbyte: uint64(\n\t\t\tsweep.DefaultMaxFeeRate.FeePerKVByte() / 2000,\n\t\t),\n\t}\n\tbob.RPC.BumpFee(bumpFeeReq)\n\n\t// We should now expect to see two transactions within the mempool, a\n\t// parent and its child.\n\tht.Miner.AssertNumTxsInMempool(2)\n\n\t// We should also expect to see the output being swept by the\n\t// UtxoSweeper. We'll ensure it's using the fee rate specified.\n\tpendingSweepsResp := bob.RPC.PendingSweeps()\n\trequire.Len(ht, pendingSweepsResp.PendingSweeps, 1,\n\t\t\"expected to find 1 pending sweep\")\n\tpendingSweep := pendingSweepsResp.PendingSweeps[0]\n\trequire.Equal(ht, pendingSweep.Outpoint.TxidBytes, op.TxidBytes,\n\t\t\"output txid not matched\")\n\trequire.Equal(ht, pendingSweep.Outpoint.OutputIndex, op.OutputIndex,\n\t\t\"output index not matched\")\n\trequire.Equal(ht, pendingSweep.SatPerVbyte, bumpFeeReq.SatPerVbyte,\n\t\t\"sweep sat per vbyte not matched\")\n\n\t// Mine a block to clean up the unconfirmed transactions.\n\tht.MineBlocksAndAssertNumTxes(1, 2)\n\n\t// The input used to CPFP should no longer be pending.\n\terr := wait.NoError(func() error {\n\t\tresp := bob.RPC.PendingSweeps()\n\t\tif len(resp.PendingSweeps) != 0 {\n\t\t\treturn fmt.Errorf(\"expected 0 pending sweeps, found %d\",\n\t\t\t\tlen(resp.PendingSweeps))\n\t\t}\n\n\t\treturn nil\n\t}, defaultTimeout)\n\trequire.NoError(ht, err, \"timeout checking bob's pending sweeps\")\n}\n\n// testAnchorReservedValue tests that we won't allow sending transactions when\n// that would take the value we reserve for anchor fee bumping out of our\n// wallet.",
      "length": 3094,
      "tokens": 395,
      "embedding": []
    },
    {
      "slug": "func testAnchorReservedValue(ht *lntest.HarnessTest) {",
      "content": "func testAnchorReservedValue(ht *lntest.HarnessTest) {\n\t// Start two nodes supporting anchor channels.\n\targs := lntest.NodeArgsForCommitType(lnrpc.CommitmentType_ANCHORS)\n\n\t// NOTE: we cannot reuse the standby node here as the test requires the\n\t// node to start with no UTXOs.\n\talice := ht.NewNode(\"Alice\", args)\n\tbob := ht.Bob\n\tht.RestartNodeWithExtraArgs(bob, args)\n\n\tht.ConnectNodes(alice, bob)\n\n\t// Send just enough coins for Alice to open a channel without a change\n\t// output.\n\tconst (\n\t\tchanAmt = 1000000\n\t\tfeeEst  = 8000\n\t)\n\n\tht.FundCoins(chanAmt+feeEst, alice)\n\n\t// wallet, without a change output. This should not be allowed.\n\tht.OpenChannelAssertErr(\n\t\talice, bob, lntest.OpenChannelParams{\n\t\t\tAmt: chanAmt,\n\t\t}, lnwallet.ErrReservedValueInvalidated,\n\t)\n\n\t// Alice opens a smaller channel. This works since it will have a\n\t// change output.\n\tchanPoint1 := ht.OpenChannel(\n\t\talice, bob, lntest.OpenChannelParams{Amt: chanAmt / 4},\n\t)\n\n\t// If Alice tries to open another anchor channel to Bob, Bob should not\n\t// reject it as he is not contributing any funds.\n\tchanPoint2 := ht.OpenChannel(\n\t\talice, bob, lntest.OpenChannelParams{Amt: chanAmt / 4},\n\t)\n\n\t// Similarly, if Alice tries to open a legacy channel to Bob, Bob\n\t// should not reject it as he is not contributing any funds. We'll\n\t// restart Bob to remove his support for anchors.\n\tht.RestartNode(bob)\n\n\t// Before opening the channel, make sure the nodes are connected.\n\tht.EnsureConnected(alice, bob)\n\n\tchanPoint3 := ht.OpenChannel(\n\t\talice, bob, lntest.OpenChannelParams{Amt: chanAmt / 4},\n\t)\n\tchanPoints := []*lnrpc.ChannelPoint{chanPoint1, chanPoint2, chanPoint3}\n\n\t// Alice tries to send all coins to an internal address. This is\n\t// allowed, since the final wallet balance will still be above the\n\t// reserved value.\n\treq := &lnrpc.NewAddressRequest{\n\t\tType: lnrpc.AddressType_WITNESS_PUBKEY_HASH,\n\t}\n\tresp := alice.RPC.NewAddress(req)\n\n\tsweepReq := &lnrpc.SendCoinsRequest{\n\t\tAddr:    resp.Address,\n\t\tSendAll: true,\n\t}\n\talice.RPC.SendCoins(sweepReq)\n\n\tblock := ht.MineBlocksAndAssertNumTxes(1, 1)[0]\n\n\tassertNumTxInAndTxOut := func(tx *wire.MsgTx, in, out int) {\n\t\trequire.Len(ht, tx.TxIn, in, \"num inputs not matched\")\n\t\trequire.Len(ht, tx.TxOut, out, \"num outputs not matched\")\n\t}\n\n\t// The sweep transaction should have exactly one input, the change from\n\t// the previous SendCoins call.\n\tsweepTx := block.Transactions[1]\n\n\t// It should have a single output.\n\tassertNumTxInAndTxOut(sweepTx, 1, 1)\n\n\t// Wait for Alice to see her balance as confirmed.\n\twaitForConfirmedBalance := func() int64 {\n\t\tvar balance int64\n\t\terr := wait.NoError(func() error {\n\t\t\tresp := alice.RPC.WalletBalance()\n\n\t\t\tif resp.TotalBalance == 0 {\n\t\t\t\treturn fmt.Errorf(\"no balance\")\n\t\t\t}\n\n\t\t\tif resp.UnconfirmedBalance > 0 {\n\t\t\t\treturn fmt.Errorf(\"unconfirmed balance\")\n\t\t\t}\n\n\t\t\tbalance = resp.TotalBalance\n\n\t\t\treturn nil\n\t\t}, defaultTimeout)\n\t\trequire.NoError(ht, err, \"timeout checking alice's balance\")\n\n\t\treturn balance\n\t}\n\n\twaitForConfirmedBalance()\n\n\t// Alice tries to send all funds to an external address, the reserved\n\t// value must stay in her wallet.\n\tminerAddr := ht.Miner.NewMinerAddress()\n\n\tsweepReq = &lnrpc.SendCoinsRequest{\n\t\tAddr:    minerAddr.String(),\n\t\tSendAll: true,\n\t}\n\talice.RPC.SendCoins(sweepReq)\n\n\t// We'll mine a block which should include the sweep transaction we\n\t// generated above.\n\tblock = ht.MineBlocksAndAssertNumTxes(1, 1)[0]\n\n\t// The sweep transaction should have exactly one inputs as we only had\n\t// the single output from above in the wallet.\n\tsweepTx = block.Transactions[1]\n\n\t// It should have two outputs, one being the miner address, the other\n\t// one being the reserve going back to our wallet.\n\tassertNumTxInAndTxOut(sweepTx, 1, 2)\n\n\t// The reserved value is now back in Alice's wallet.\n\taliceBalance := waitForConfirmedBalance()\n\n\t// Alice closes channel, should now be allowed to send everything to an\n\t// external address.\n\tfor _, chanPoint := range chanPoints {\n\t\tht.CloseChannel(alice, chanPoint)\n\t}\n\n\tnewBalance := waitForConfirmedBalance()\n\trequire.Greater(ht, newBalance, aliceBalance,\n\t\t\"Alice's balance did not increase after channel close\")\n\n\t// Assert there are no open or pending channels anymore.\n\tht.AssertNumWaitingClose(alice, 0)\n\tht.AssertNodeNumChannels(alice, 0)\n\n\t// We'll wait for the balance to reflect that the channel has been\n\t// closed and the funds are in the wallet.\n\tsweepReq = &lnrpc.SendCoinsRequest{\n\t\tAddr:    minerAddr.String(),\n\t\tSendAll: true,\n\t}\n\talice.RPC.SendCoins(sweepReq)\n\n\t// We'll mine a block which should include the sweep transaction we\n\t// generated above.\n\tblock = ht.MineBlocksAndAssertNumTxes(1, 1)[0]\n\n\t// The sweep transaction should have four inputs, the change output from\n\t// the previous sweep, and the outputs from the coop closed channels.\n\tsweepTx = block.Transactions[1]\n\n\t// It should have a single output.\n\tassertNumTxInAndTxOut(sweepTx, 4, 1)\n}\n\n// testAnchorThirdPartySpend tests that if we force close a channel, but then\n// don't sweep the anchor in time and a 3rd party spends it, that we remove any\n// transactions that are a descendent of that sweep.",
      "length": 4895,
      "tokens": 672,
      "embedding": []
    },
    {
      "slug": "func testAnchorThirdPartySpend(ht *lntest.HarnessTest) {",
      "content": "func testAnchorThirdPartySpend(ht *lntest.HarnessTest) {\n\t// First, we'll create two new nodes that both default to anchor\n\t// channels.\n\t//\n\t// NOTE: The itests differ here as anchors is default off vs the normal\n\t// lnd binary.\n\targs := lntest.NodeArgsForCommitType(lnrpc.CommitmentType_ANCHORS)\n\talice := ht.NewNode(\"Alice\", args)\n\tbob := ht.NewNode(\"Bob\", args)\n\n\tht.EnsureConnected(alice, bob)\n\n\t// We'll fund our Alice with coins, as she'll be opening the channel.\n\t// We'll fund her with *just* enough coins to open the channel and\n\t// sweep the anchor.\n\tconst (\n\t\tfirstChanSize   = 1_000_000\n\t\tanchorFeeBuffer = 500_000\n\t)\n\tht.FundCoins(firstChanSize+anchorFeeBuffer, alice)\n\n\t// Open the channel between the two nodes and wait for it to confirm\n\t// fully.\n\taliceChanPoint1 := ht.OpenChannel(\n\t\talice, bob, lntest.OpenChannelParams{\n\t\t\tAmt: firstChanSize,\n\t\t},\n\t)\n\n\t// Send another UTXO if this is a neutrino backend. When sweeping\n\t// anchors, there are two transactions created, `local_sweep_tx` for\n\t// sweeping Alice's anchor on the local commitment, `remote_sweep_tx`\n\t// for sweeping her anchor on the remote commitment. Whenever the force\n\t// close transaction is published, Alice will always create these two\n\t// transactions to sweep her anchor.\n\t// On the other hand, when creating the sweep txes, the anchor itself\n\t// is not able to cover the fee, so another wallet UTXO is needed. In\n\t// our test case, there's a change output that can be used from the\n\t// above funding process. And it's used by both sweep txes - when `lnd`\n\t// happens to create the `remote_sweep_tx` first, it will receive an\n\t// error since its parent tx, the remote commitment, is not known,\n\t// hence freeing the change output to be used by `local_sweep_tx`.\n\t// For neutrino client, however, it will consider the transaction which\n\t// sweeps the remote anchor as an orphan tx, and it will neither send\n\t// it to the mempool nor return an error to free the change output.\n\t// Thus, if the change output is already used in `remote_sweep_tx`, we\n\t// won't have UTXO to create `local_sweep_tx`.\n\t//\n\t// NOTE: the order of the sweep requests for the two anchors cannot be\n\t// guaranteed. If the sweeper happens to sweep the remote anchor first,\n\t// then the test won't pass without the extra UTXO, which is the source\n\t// of the flakeness.\n\t//\n\t// TODO(yy): make a RPC server for sweeper so we can explicitly check\n\t// and control its state.\n\tif ht.IsNeutrinoBackend() {\n\t\tht.FundCoins(anchorFeeBuffer, alice)\n\t}\n\n\t// With the channel open, we'll actually immediately force close it. We\n\t// don't care about network announcements here since there's no routing\n\t// in this test.\n\tht.CloseChannelAssertPending(alice, aliceChanPoint1, true)\n\n\t// Now that the channel has been force closed, it should show up in the\n\t// PendingChannels RPC under the waiting close section.\n\twaitingClose := ht.AssertChannelWaitingClose(alice, aliceChanPoint1)\n\n\t// At this point, the channel is waiting close, and we have both the\n\t// commitment transaction and anchor sweep in the mempool.\n\tconst expectedTxns = 2\n\tsweepTxns := ht.Miner.GetNumTxsFromMempool(expectedTxns)\n\taliceCloseTx := waitingClose.Commitments.LocalTxid\n\t_, aliceAnchor := ht.FindCommitAndAnchor(sweepTxns, aliceCloseTx)\n\n\t// We'll now mine _only_ the commitment force close transaction, as we\n\t// want the anchor sweep to stay unconfirmed.\n\tforceCloseTxID, _ := chainhash.NewHashFromStr(aliceCloseTx)\n\tcommitTxn := ht.Miner.GetRawTransaction(forceCloseTxID)\n\tht.Miner.MineBlockWithTxes([]*btcutil.Tx{commitTxn})\n\n\t// With the anchor output located, and the main commitment mined we'll\n\t// instruct the wallet to send all coins in the wallet to a new address\n\t// (to the miner), including unconfirmed change.\n\tminerAddr := ht.Miner.NewMinerAddress()\n\tsweepReq := &lnrpc.SendCoinsRequest{\n\t\tAddr:             minerAddr.String(),\n\t\tSendAll:          true,\n\t\tMinConfs:         0,\n\t\tSpendUnconfirmed: true,\n\t}\n\tsweepAllResp := alice.RPC.SendCoins(sweepReq)\n\n\t// Both the original anchor sweep transaction, as well as the\n\t// transaction we created to sweep all the coins from Alice's wallet\n\t// should be found in her transaction store.\n\tsweepAllTxID, _ := chainhash.NewHashFromStr(sweepAllResp.Txid)\n\tht.AssertTransactionInWallet(alice, aliceAnchor.SweepTx.TxHash())\n\tht.AssertTransactionInWallet(alice, *sweepAllTxID)\n\n\t// Next, we'll shutdown Alice, and allow 16 blocks to pass so that the\n\t// anchor output can be swept by anyone. Rather than use the normal API\n\t// call, we'll generate a series of _empty_ blocks here.\n\taliceRestart := ht.SuspendNode(alice)\n\tconst anchorCsv = 16\n\tht.MineEmptyBlocks(anchorCsv)\n\n\t// Before we sweep the anchor, we'll restart Alice.\n\trequire.NoErrorf(ht, aliceRestart(), \"unable to restart alice\")\n\n\t// Now that the channel has been closed, and Alice has an unconfirmed\n\t// transaction spending the output produced by her anchor sweep, we'll\n\t// mine a transaction that double spends the output.\n\tthirdPartyAnchorSweep := genAnchorSweep(ht, aliceAnchor, anchorCsv)\n\tht.Miner.MineBlockWithTxes([]*btcutil.Tx{thirdPartyAnchorSweep})\n\n\t// At this point, we should no longer find Alice's transaction that\n\t// tried to sweep the anchor in her wallet.\n\tht.AssertTransactionNotInWallet(alice, aliceAnchor.SweepTx.TxHash())\n\n\t// In addition, the transaction she sent to sweep all her coins to the\n\t// miner also should no longer be found.\n\tht.AssertTransactionNotInWallet(alice, *sweepAllTxID)\n\n\t// The anchor should now show as being \"lost\", while the force close\n\t// response is still present.\n\tassertAnchorOutputLost(ht, alice, aliceChanPoint1)\n\n\t// At this point Alice's CSV output should already be fully spent and\n\t// the channel marked as being resolved. We mine a block first, as so\n\t// far we've been generating custom blocks this whole time.\n\tcommitSweepOp := wire.OutPoint{\n\t\tHash:  *forceCloseTxID,\n\t\tIndex: 1,\n\t}\n\tht.Miner.AssertOutpointInMempool(commitSweepOp)\n\tht.MineBlocks(1)\n\n\tht.AssertNumWaitingClose(alice, 0)\n}\n\n// assertAnchorOutputLost asserts that the anchor output for the given channel\n// has the state of being lost.",
      "length": 5910,
      "tokens": 839,
      "embedding": []
    },
    {
      "slug": "func assertAnchorOutputLost(ht *lntest.HarnessTest, hn *node.HarnessNode,",
      "content": "func assertAnchorOutputLost(ht *lntest.HarnessTest, hn *node.HarnessNode,\n\tchanPoint *lnrpc.ChannelPoint) {\n\n\tcp := ht.OutPointFromChannelPoint(chanPoint)\n\n\texpected := lnrpc.PendingChannelsResponse_ForceClosedChannel_LOST\n\n\terr := wait.NoError(func() error {\n\t\tresp := hn.RPC.PendingChannels()\n\t\tchannels := resp.PendingForceClosingChannels\n\n\t\tfor _, c := range channels {\n\t\t\t// Not the wanted channel, skipped.\n\t\t\tif c.Channel.ChannelPoint != cp.String() {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Found the channel, check the anchor state.\n\t\t\tif c.Anchor == expected {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\treturn fmt.Errorf(\"unexpected anchor state, want %v, \"+\n\t\t\t\t\"got %v\", expected, c.Anchor)\n\t\t}\n\n\t\treturn fmt.Errorf(\"channel not found using cp=%v\", cp)\n\t}, defaultTimeout)\n\trequire.NoError(ht, err, \"anchor doesn't show as being lost\")\n}\n\n// genAnchorSweep generates a \"3rd party\" anchor sweeping from an existing one.\n// In practice, we just re-use the existing witness, and track on our own\n// output producing a 1-in-1-out transaction.",
      "length": 911,
      "tokens": 118,
      "embedding": []
    },
    {
      "slug": "func genAnchorSweep(ht *lntest.HarnessTest,",
      "content": "func genAnchorSweep(ht *lntest.HarnessTest,\n\taliceAnchor *lntest.SweptOutput, anchorCsv uint32) *btcutil.Tx {\n\n\t// At this point, we have the transaction that Alice used to try to\n\t// sweep her anchor. As this is actually just something anyone can\n\t// spend, just need to find the input spending the anchor output, then\n\t// we can swap the output address.\n\taliceAnchorTxIn := func() wire.TxIn {\n\t\tsweepCopy := aliceAnchor.SweepTx.Copy()\n\t\tfor _, txIn := range sweepCopy.TxIn {\n\t\t\tif txIn.PreviousOutPoint == aliceAnchor.OutPoint {\n\t\t\t\treturn *txIn\n\t\t\t}\n\t\t}\n\n\t\trequire.FailNow(ht, \"anchor op not found\")\n\n\t\treturn wire.TxIn{}\n\t}()\n\n\t// We'll set the signature on the input to nil, and then set the\n\t// sequence to 16 (the anchor CSV period).\n\taliceAnchorTxIn.Witness[0] = nil\n\taliceAnchorTxIn.Sequence = anchorCsv\n\n\tminerAddr := ht.Miner.NewMinerAddress()\n\taddrScript, err := txscript.PayToAddrScript(minerAddr)\n\trequire.NoError(ht, err, \"unable to gen addr script\")\n\n\t// Now that we have the txIn, we can just make a new transaction that\n\t// uses a different script for the output.\n\ttx := wire.NewMsgTx(2)\n\ttx.AddTxIn(&aliceAnchorTxIn)\n\ttx.AddTxOut(&wire.TxOut{\n\t\tPkScript: addrScript,\n\t\tValue:    anchorSize - 1,\n\t})\n\n\treturn btcutil.NewTx(tx)\n}\n",
      "length": 1164,
      "tokens": 164,
      "embedding": []
    }
  ]
}