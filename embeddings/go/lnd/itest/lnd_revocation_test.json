{
  "filepath": "../implementations/go/lnd/itest/lnd_revocation_test.go",
  "package": "itest",
  "sections": [
    {
      "slug": "func testRevokedCloseRetribution(ht *lntest.HarnessTest) {",
      "content": "func testRevokedCloseRetribution(ht *lntest.HarnessTest) {\n\tconst (\n\t\tchanAmt     = funding.MaxBtcFundingAmount\n\t\tpaymentAmt  = 10000\n\t\tnumInvoices = 6\n\t)\n\n\t// Carol will be the breached party. We set --nolisten to ensure Bob\n\t// won't be able to connect to her and trigger the channel data\n\t// protection logic automatically. We also can't have Carol\n\t// automatically re-connect too early, otherwise DLP would be initiated\n\t// instead of the breach we want to provoke.\n\tcarol := ht.NewNode(\n\t\t\"Carol\",\n\t\t[]string{\"--hodl.exit-settle\", \"--nolisten\", \"--minbackoff=1h\"},\n\t)\n\n\t// We must let Bob communicate with Carol before they are able to open\n\t// channel, so we connect Bob and Carol,\n\tbob := ht.Bob\n\tht.ConnectNodes(carol, bob)\n\n\t// Before we make a channel, we'll load up Carol with some coins sent\n\t// directly from the miner.\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, carol)\n\n\t// In order to test Carol's response to an uncooperative channel\n\t// closure by Bob, we'll first open up a channel between them with a\n\t// 0.5 BTC value.\n\tchanPoint := ht.OpenChannel(\n\t\tcarol, bob, lntest.OpenChannelParams{Amt: chanAmt},\n\t)\n\n\t// With the channel open, we'll create a few invoices for Bob that\n\t// Carol will pay to in order to advance the state of the channel.\n\tbobPayReqs, _, _ := ht.CreatePayReqs(bob, paymentAmt, numInvoices)\n\n\t// Send payments from Carol to Bob using 3 of Bob's payment hashes\n\t// generated above.\n\tht.CompletePaymentRequests(carol, bobPayReqs[:numInvoices/2])\n\n\t// Next query for Bob's channel state, as we sent 3 payments of 10k\n\t// satoshis each, Bob should now see his balance as being 30k satoshis.\n\tbobChan := ht.AssertChannelLocalBalance(bob, chanPoint, 30_000)\n\n\t// Grab Bob's current commitment height (update number), we'll later\n\t// revert him to this state after additional updates to force him to\n\t// broadcast this soon to be revoked state.\n\tbobStateNumPreCopy := bobChan.NumUpdates\n\n\t// With the temporary file created, copy Bob's current state into the\n\t// temporary file we created above. Later after more updates, we'll\n\t// restore this state.\n\tht.BackupDB(bob)\n\n\t// Reconnect the peers after the restart that was needed for the db\n\t// backup.\n\tht.EnsureConnected(carol, bob)\n\n\t// Because Bob has been restarted, we need to make sure Carol has\n\t// remarked the channel as active after that.\n\tht.AssertChannelExists(carol, chanPoint)\n\n\t// Finally, send payments from Carol to Bob, consuming Bob's remaining\n\t// payment hashes.\n\tht.CompletePaymentRequests(carol, bobPayReqs[numInvoices/2:])\n\n\t// Now we shutdown Bob, copying over the his temporary database state\n\t// which has the *prior* channel state over his current most up to date\n\t// state. With this, we essentially force Bob to travel back in time\n\t// within the channel's history.\n\tht.RestartNodeAndRestoreDB(bob)\n\n\t// Now query for Bob's channel state, it should show that he's at a\n\t// state number in the past, not the *latest* state.\n\tht.AssertChannelCommitHeight(bob, chanPoint, int(bobStateNumPreCopy))\n\n\t// Now force Bob to execute a *force* channel closure by unilaterally\n\t// broadcasting his current channel state. This is actually the\n\t// commitment transaction of a prior *revoked* state, so he'll soon\n\t// feel the wrath of Carol's retribution.\n\t_, breachTXID := ht.CloseChannelAssertPending(bob, chanPoint, true)\n\n\t// Here, Carol sees Bob's breach transaction in the mempool, but is\n\t// waiting for it to confirm before continuing her retribution. We\n\t// restart Carol to ensure that she is persisting her retribution state\n\t// and continues watching for the breach transaction to confirm even\n\t// after her node restarts.\n\tht.RestartNode(carol)\n\n\t// Finally, generate a single block, wait for the final close status\n\t// update, then ensure that the closing transaction was included in the\n\t// block.\n\tblock := ht.MineBlocksAndAssertNumTxes(1, 1)[0]\n\tht.Miner.AssertTxInBlock(block, breachTXID)\n\n\t// Query the mempool for Carol's justice transaction, this should be\n\t// broadcast as Bob's contract breaching transaction gets confirmed\n\t// above.\n\tjusticeTXID := ht.Miner.AssertNumTxsInMempool(1)[0]\n\n\t// Query for the mempool transaction found above. Then assert that all\n\t// the inputs of this transaction are spending outputs generated by\n\t// Bob's breach transaction above.\n\tjusticeTx := ht.Miner.GetRawTransaction(justiceTXID)\n\tfor _, txIn := range justiceTx.MsgTx().TxIn {\n\t\trequire.Equal(ht, breachTXID[:], txIn.PreviousOutPoint.Hash[:],\n\t\t\t\"justice tx not spending commitment utxo\")\n\t}\n\n\t// We restart Carol here to ensure that she persists her retribution\n\t// state and successfully continues exacting retribution after\n\t// restarting. At this point, Carol has broadcast the justice\n\t// transaction, but it hasn't been confirmed yet; when Carol restarts,\n\t// she should start waiting for the justice transaction to confirm\n\t// again.\n\tht.RestartNode(carol)\n\n\t// Now mine a block, this transaction should include Carol's justice\n\t// transaction which was just accepted into the mempool.\n\tblock = ht.MineBlocksAndAssertNumTxes(1, 1)[0]\n\n\t// The block should have exactly *two* transactions, one of which is\n\t// the justice transaction.\n\trequire.Len(ht, block.Transactions, 2, \"transaction wasn't mined\")\n\n\tjusticeSha := block.Transactions[1].TxHash()\n\trequire.Equal(ht, justiceTx.Hash()[:], justiceSha[:],\n\t\t\"justice tx wasn't mined\")\n\n\tht.AssertNodeNumChannels(carol, 0)\n\n\t// Mine enough blocks for Bob's channel arbitrator to wrap up the\n\t// references to the breached channel. The chanarb waits for commitment\n\t// tx's confHeight+CSV-1 blocks and since we've already mined one that\n\t// included the justice tx we only need to mine extra DefaultCSV-2\n\t// blocks to unlock it.\n\tht.MineBlocks(defaultCSV - 2)\n\n\tht.AssertNumPendingForceClose(bob, 0)\n}\n\n// testRevokedCloseRetributionZeroValueRemoteOutput tests that Dave is able\n// carry out retribution in the event that he fails in state where the remote\n// commitment output has zero-value.",
      "length": 5757,
      "tokens": 833,
      "embedding": []
    },
    {
      "slug": "func testRevokedCloseRetributionZeroValueRemoteOutput(ht *lntest.HarnessTest) {",
      "content": "func testRevokedCloseRetributionZeroValueRemoteOutput(ht *lntest.HarnessTest) {\n\tconst (\n\t\tchanAmt     = funding.MaxBtcFundingAmount\n\t\tpaymentAmt  = 10000\n\t\tnumInvoices = 6\n\t)\n\n\t// Since we'd like to test some multi-hop failure scenarios, we'll\n\t// introduce another node into our test network: Carol.\n\tcarol := ht.NewNode(\"Carol\", []string{\"--hodl.exit-settle\"})\n\n\t// Dave will be the breached party. We set --nolisten to ensure Carol\n\t// won't be able to connect to him and trigger the channel data\n\t// protection logic automatically. We also can't have Dave automatically\n\t// re-connect too early, otherwise DLP would be initiated instead of the\n\t// breach we want to provoke.\n\tdave := ht.NewNode(\n\t\t\"Dave\",\n\t\t[]string{\"--hodl.exit-settle\", \"--nolisten\", \"--minbackoff=1h\"},\n\t)\n\n\t// We must let Dave have an open channel before he can send a node\n\t// announcement, so we open a channel with Carol,\n\tht.ConnectNodes(dave, carol)\n\n\t// Before we make a channel, we'll load up Dave with some coins sent\n\t// directly from the miner.\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, dave)\n\n\t// In order to test Dave's response to an uncooperative channel\n\t// closure by Carol, we'll first open up a channel between them with a\n\t// 0.5 BTC value.\n\tchanPoint := ht.OpenChannel(\n\t\tdave, carol, lntest.OpenChannelParams{Amt: chanAmt},\n\t)\n\n\t// With the channel open, we'll create a few invoices for Carol that\n\t// Dave will pay to in order to advance the state of the channel.\n\tcarolPayReqs, _, _ := ht.CreatePayReqs(carol, paymentAmt, numInvoices)\n\n\t// Next query for Carol's channel state, as we sent 0 payments, Carol\n\t// should now see her balance as being 0 satoshis.\n\tcarolChan := ht.AssertChannelLocalBalance(carol, chanPoint, 0)\n\n\t// Grab Carol's current commitment height (update number), we'll later\n\t// revert her to this state after additional updates to force her to\n\t// broadcast this soon to be revoked state.\n\tcarolStateNumPreCopy := int(carolChan.NumUpdates)\n\n\t// With the temporary file created, copy Carol's current state into the\n\t// temporary file we created above. Later after more updates, we'll\n\t// restore this state.\n\tht.BackupDB(carol)\n\n\t// Reconnect the peers after the restart that was needed for the db\n\t// backup.\n\tht.EnsureConnected(dave, carol)\n\n\t// Once connected, give Dave some time to enable the channel again.\n\tht.AssertTopologyChannelOpen(dave, chanPoint)\n\n\t// Finally, send payments from Dave to Carol, consuming Carol's\n\t// remaining payment hashes.\n\tht.CompletePaymentRequestsNoWait(dave, carolPayReqs, chanPoint)\n\n\t// Now we shutdown Carol, copying over the her temporary database state\n\t// which has the *prior* channel state over her current most up to date\n\t// state. With this, we essentially force Carol to travel back in time\n\t// within the channel's history.\n\tht.RestartNodeAndRestoreDB(carol)\n\n\t// Now query for Carol's channel state, it should show that she's at a\n\t// state number in the past, not the *latest* state.\n\tht.AssertChannelCommitHeight(carol, chanPoint, carolStateNumPreCopy)\n\n\t// Now force Carol to execute a *force* channel closure by unilaterally\n\t// broadcasting her current channel state. This is actually the\n\t// commitment transaction of a prior *revoked* state, so she'll soon\n\t// feel the wrath of Dave's retribution.\n\tstream, closeTxID := ht.CloseChannelAssertPending(\n\t\tcarol, chanPoint, true,\n\t)\n\n\t// Finally, generate a single block, wait for the final close status\n\t// update, then ensure that the closing transaction was included in the\n\t// block.\n\tht.MineBlocksAndAssertNumTxes(1, 1)\n\n\t// Here, Dave receives a confirmation of Carol's breach transaction.\n\t// We restart Dave to ensure that he is persisting his retribution\n\t// state and continues exacting justice after his node restarts.\n\tht.RestartNode(dave)\n\n\t// The breachTXID should match the above closeTxID.\n\tbreachTXID := ht.WaitForChannelCloseEvent(stream)\n\trequire.EqualValues(ht, breachTXID, closeTxID)\n\n\t// Query the mempool for Dave's justice transaction, this should be\n\t// broadcast as Carol's contract breaching transaction gets confirmed\n\t// above.\n\tjusticeTXID := ht.Miner.AssertNumTxsInMempool(1)[0]\n\n\t// Query for the mempool transaction found above. Then assert that all\n\t// the inputs of this transaction are spending outputs generated by\n\t// Carol's breach transaction above.\n\tjusticeTx := ht.Miner.GetRawTransaction(justiceTXID)\n\tfor _, txIn := range justiceTx.MsgTx().TxIn {\n\t\trequire.Equal(ht, breachTXID[:], txIn.PreviousOutPoint.Hash[:],\n\t\t\t\"justice tx not spending commitment utxo \")\n\t}\n\n\t// We restart Dave here to ensure that he persists his retribution state\n\t// and successfully continues exacting retribution after restarting. At\n\t// this point, Dave has broadcast the justice transaction, but it hasn't\n\t// been confirmed yet; when Dave restarts, he should start waiting for\n\t// the justice transaction to confirm again.\n\tht.RestartNode(dave)\n\n\t// Now mine a block, this transaction should include Dave's justice\n\t// transaction which was just accepted into the mempool.\n\tblock := ht.MineBlocksAndAssertNumTxes(1, 1)[0]\n\n\t// The block should have exactly *two* transactions, one of which is\n\t// the justice transaction.\n\trequire.Len(ht, block.Transactions, 2, \"transaction wasn't mined\")\n\tjusticeSha := block.Transactions[1].TxHash()\n\trequire.Equal(ht, justiceTx.Hash()[:], justiceSha[:],\n\t\t\"justice tx wasn't mined\")\n\n\tht.AssertNodeNumChannels(dave, 0)\n}\n\n// testRevokedCloseRetributionRemoteHodl tests that Dave properly responds to a\n// channel breach made by the remote party, specifically in the case that the\n// remote party breaches before settling extended HTLCs.",
      "length": 5408,
      "tokens": 767,
      "embedding": []
    },
    {
      "slug": "func testRevokedCloseRetributionRemoteHodl(ht *lntest.HarnessTest) {",
      "content": "func testRevokedCloseRetributionRemoteHodl(ht *lntest.HarnessTest) {\n\tconst (\n\t\tchanAmt     = funding.MaxBtcFundingAmount\n\t\tpushAmt     = 200000\n\t\tpaymentAmt  = 10000\n\t\tnumInvoices = 6\n\t)\n\n\t// Since this test will result in the counterparty being left in a\n\t// weird state, we will introduce another node into our test network:\n\t// Carol.\n\tcarol := ht.NewNode(\"Carol\", []string{\"--hodl.exit-settle\"})\n\n\t// We'll also create a new node Dave, who will have a channel with\n\t// Carol, and also use similar settings so we can broadcast a commit\n\t// with active HTLCs. Dave will be the breached party. We set\n\t// --nolisten to ensure Carol won't be able to connect to him and\n\t// trigger the channel data protection logic automatically.\n\tdave := ht.NewNode(\n\t\t\"Dave\",\n\t\t[]string{\"--hodl.exit-settle\", \"--nolisten\"},\n\t)\n\n\t// We must let Dave communicate with Carol before they are able to open\n\t// channel, so we connect Dave and Carol,\n\tht.ConnectNodes(dave, carol)\n\n\t// Before we make a channel, we'll load up Dave with some coins sent\n\t// directly from the miner.\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, dave)\n\n\t// In order to test Dave's response to an uncooperative channel closure\n\t// by Carol, we'll first open up a channel between them with a\n\t// funding.MaxBtcFundingAmount (2^24) satoshis value.\n\tchanPoint := ht.OpenChannel(\n\t\tdave, carol, lntest.OpenChannelParams{\n\t\t\tAmt:     chanAmt,\n\t\t\tPushAmt: pushAmt,\n\t\t},\n\t)\n\n\t// With the channel open, we'll create a few invoices for Carol that\n\t// Dave will pay to in order to advance the state of the channel.\n\tcarolPayReqs, _, _ := ht.CreatePayReqs(carol, paymentAmt, numInvoices)\n\n\t// We'll introduce an closure to validate that Carol's current\n\t// number of updates is at least as large as the provided minimum\n\t// number.\n\tcheckCarolNumUpdatesAtLeast := func(carolChan *lnrpc.Channel,\n\t\tminimum int) {\n\n\t\trequire.GreaterOrEqual(ht, int(carolChan.NumUpdates), minimum,\n\t\t\t\"carol's numupdates is incorrect\")\n\t}\n\n\t// Ensure that carol's balance starts with the amount we pushed to her.\n\tht.AssertChannelLocalBalance(carol, chanPoint, pushAmt)\n\n\t// Send payments from Dave to Carol using 3 of Carol's payment hashes\n\t// generated above.\n\tht.CompletePaymentRequestsNoWait(\n\t\tdave, carolPayReqs[:numInvoices/2], chanPoint,\n\t)\n\n\t// At this point, we'll also send over a set of HTLC's from Carol to\n\t// Dave. This ensures that the final revoked transaction has HTLC's in\n\t// both directions.\n\tdavePayReqs, _, _ := ht.CreatePayReqs(dave, paymentAmt, numInvoices)\n\n\t// Send payments from Carol to Dave using 3 of Dave's payment hashes\n\t// generated above.\n\tht.CompletePaymentRequestsNoWait(\n\t\tcarol, davePayReqs[:numInvoices/2], chanPoint,\n\t)\n\n\t// Next query for Carol's channel state, as we sent 3 payments of 10k\n\t// satoshis each, however Carol should now see her balance as being\n\t// equal to the push amount in satoshis since she has not settled.\n\n\t// Ensure that carol's balance still reflects the original amount we\n\t// pushed to her, minus the HTLCs she just sent to Dave.\n\tcarolChan := ht.AssertChannelLocalBalance(\n\t\tcarol, chanPoint, pushAmt-3*paymentAmt,\n\t)\n\n\t// Grab Carol's current commitment height (update number), we'll later\n\t// revert her to this state after additional updates to force her to\n\t// broadcast this soon to be revoked state.\n\tcarolStateNumPreCopy := int(carolChan.NumUpdates)\n\n\t// Since Carol has not settled, she should only see at least one update\n\t// to her channel.\n\tcheckCarolNumUpdatesAtLeast(carolChan, 1)\n\n\t// With the temporary file created, copy Carol's current state into the\n\t// temporary file we created above. Later after more updates, we'll\n\t// restore this state.\n\tht.BackupDB(carol)\n\n\t// Reconnect the peers after the restart that was needed for the db\n\t// backup.\n\tht.EnsureConnected(dave, carol)\n\n\t// Once connected, give Dave some time to enable the channel again.\n\tht.AssertTopologyChannelOpen(dave, chanPoint)\n\n\t// Finally, send payments from Dave to Carol, consuming Carol's\n\t// remaining payment hashes.\n\tht.CompletePaymentRequestsNoWait(\n\t\tdave, carolPayReqs[numInvoices/2:], chanPoint,\n\t)\n\n\t// Ensure that carol's balance still shows the amount we originally\n\t// pushed to her (minus the HTLCs she sent to Bob), and that at least\n\t// one more update has occurred.\n\tcarolChan = ht.AssertChannelLocalBalance(\n\t\tcarol, chanPoint, pushAmt-3*paymentAmt,\n\t)\n\tcheckCarolNumUpdatesAtLeast(carolChan, carolStateNumPreCopy+1)\n\n\t// Suspend Dave, such that Carol won't reconnect at startup, triggering\n\t// the data loss protection.\n\trestartDave := ht.SuspendNode(dave)\n\n\t// Now we shutdown Carol, copying over the her temporary database state\n\t// which has the *prior* channel state over her current most up to date\n\t// state. With this, we essentially force Carol to travel back in time\n\t// within the channel's history.\n\tht.RestartNodeAndRestoreDB(carol)\n\n\t// Ensure that Carol's view of the channel is consistent with the state\n\t// of the channel just before it was snapshotted.\n\tcarolChan = ht.AssertChannelLocalBalance(\n\t\tcarol, chanPoint, pushAmt-3*paymentAmt,\n\t)\n\tcheckCarolNumUpdatesAtLeast(carolChan, 1)\n\n\t// Now query for Carol's channel state, it should show that she's at a\n\t// state number in the past, *not* the latest state.\n\tht.AssertChannelCommitHeight(carol, chanPoint, carolStateNumPreCopy)\n\n\t// Now force Carol to execute a *force* channel closure by unilaterally\n\t// broadcasting her current channel state. This is actually the\n\t// commitment transaction of a prior *revoked* state, so she'll soon\n\t// feel the wrath of Dave's retribution.\n\tcloseUpdates, closeTxID := ht.CloseChannelAssertPending(\n\t\tcarol, chanPoint, true,\n\t)\n\n\t// Generate a single block to mine the breach transaction.\n\tblock := ht.MineBlocksAndAssertNumTxes(1, 1)[0]\n\n\t// We resurrect Dave to ensure he will be exacting justice after his\n\t// node restarts.\n\trequire.NoError(ht, restartDave(), \"unable to restart Dave's node\")\n\n\t// Finally, wait for the final close status update, then ensure that\n\t// the closing transaction was included in the block.\n\tbreachTXID := ht.WaitForChannelCloseEvent(closeUpdates)\n\trequire.Equal(ht, closeTxID[:], breachTXID[:],\n\t\t\"expected breach ID to be equal to close ID\")\n\tht.Miner.AssertTxInBlock(block, breachTXID)\n\n\t// Query the mempool for Dave's justice transaction, this should be\n\t// broadcast as Carol's contract breaching transaction gets confirmed\n\t// above. Since Carol might have had the time to take some of the HTLC\n\t// outputs to the second level before Dave broadcasts his justice tx,\n\t// we'll search through the mempool for a tx that matches the number of\n\t// expected inputs in the justice tx.\n\tvar justiceTxid *chainhash.Hash\n\terrNotFound := errors.New(\"justice tx not found\")\n\tfindJusticeTx := func() (*chainhash.Hash, error) {\n\t\tmempool := ht.Miner.GetRawMempool()\n\n\t\tfor _, txid := range mempool {\n\t\t\t// Check that the justice tx has the appropriate number\n\t\t\t// of inputs.\n\t\t\t//\n\t\t\t// NOTE: We don't use `ht.Miner.GetRawTransaction`\n\t\t\t// which asserts a txid must be found as the HTLC\n\t\t\t// spending txes might be aggregated.\n\t\t\ttx, err := ht.Miner.Client.GetRawTransaction(txid)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\texNumInputs := 2 + numInvoices\n\t\t\tif len(tx.MsgTx().TxIn) == exNumInputs {\n\t\t\t\treturn txid, nil\n\t\t\t}\n\t\t}\n\t\treturn nil, errNotFound\n\t}\n\n\terr := wait.NoError(func() error {\n\t\ttxid, err := findJusticeTx()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjusticeTxid = txid\n\n\t\treturn nil\n\t}, defaultTimeout)\n\n\tif err != nil && errors.Is(err, errNotFound) {\n\t\t// If Dave is unable to broadcast his justice tx on first\n\t\t// attempt because of the second layer transactions, he will\n\t\t// wait until the next block epoch before trying again. Because\n\t\t// of this, we'll mine a block if we cannot find the justice tx\n\t\t// immediately. Since we cannot tell for sure how many\n\t\t// transactions will be in the mempool at this point, we pass 0\n\t\t// as the last argument, indicating we don't care what's in the\n\t\t// mempool.\n\t\tht.MineBlocks(1)\n\t\terr = wait.NoError(func() error {\n\t\t\ttxid, err := findJusticeTx()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tjusticeTxid = txid\n\n\t\t\treturn nil\n\t\t}, defaultTimeout)\n\t}\n\trequire.NoError(ht, err, \"timeout finding justice tx\")\n\n\tjusticeTx := ht.Miner.GetRawTransaction(justiceTxid)\n\n\t// isSecondLevelSpend checks that the passed secondLevelTxid is a\n\t// potentitial second level spend spending from the commit tx.\n\tisSecondLevelSpend := func(commitTxid,\n\t\tsecondLevelTxid *chainhash.Hash) bool {\n\n\t\tsecondLevel := ht.Miner.GetRawTransaction(secondLevelTxid)\n\n\t\t// A second level spend should have only one input, and one\n\t\t// output.\n\t\tif len(secondLevel.MsgTx().TxIn) != 1 {\n\t\t\treturn false\n\t\t}\n\t\tif len(secondLevel.MsgTx().TxOut) != 1 {\n\t\t\treturn false\n\t\t}\n\n\t\t// The sole input should be spending from the commit tx.\n\t\ttxIn := secondLevel.MsgTx().TxIn[0]\n\n\t\treturn bytes.Equal(txIn.PreviousOutPoint.Hash[:], commitTxid[:])\n\t}\n\n\t// Check that all the inputs of this transaction are spending outputs\n\t// generated by Carol's breach transaction above.\n\tfor _, txIn := range justiceTx.MsgTx().TxIn {\n\t\tif bytes.Equal(txIn.PreviousOutPoint.Hash[:], breachTXID[:]) {\n\t\t\tcontinue\n\t\t}\n\n\t\t// If the justice tx is spending from an output that was not on\n\t\t// the breach tx, Carol might have had the time to take an\n\t\t// output to the second level. In that case, check that the\n\t\t// justice tx is spending this second level output.\n\t\tif isSecondLevelSpend(breachTXID, &txIn.PreviousOutPoint.Hash) {\n\t\t\tcontinue\n\t\t}\n\t\trequire.Fail(ht, \"justice tx not spending commitment utxo \"+\n\t\t\t\"instead is: %v\", txIn.PreviousOutPoint)\n\t}\n\n\t// We restart Dave here to ensure that he persists he retribution state\n\t// and successfully continues exacting retribution after restarting. At\n\t// this point, Dave has broadcast the justice transaction, but it\n\t// hasn't been confirmed yet; when Dave restarts, he should start\n\t// waiting for the justice transaction to confirm again.\n\tht.RestartNode(dave)\n\n\t// Now mine a block, this transaction should include Dave's justice\n\t// transaction which was just accepted into the mempool.\n\tht.MineBlocksAndAssertNumTxes(1, 1)\n\n\t// Dave should have no open channels.\n\tht.AssertNodeNumChannels(dave, 0)\n}\n\n// testRevokedCloseRetributionAltruistWatchtower establishes a channel between\n// Carol and Dave, where Carol is using a third node Willy as her watchtower.\n// After sending some payments, Dave reverts his state and force closes to\n// trigger a breach. Carol is kept offline throughout the process and the test\n// asserts that Willy responds by broadcasting the justice transaction on\n// Carol's behalf sweeping her funds without a reward.",
      "length": 10286,
      "tokens": 1499,
      "embedding": []
    },
    {
      "slug": "func testRevokedCloseRetributionAltruistWatchtower(ht *lntest.HarnessTest) {",
      "content": "func testRevokedCloseRetributionAltruistWatchtower(ht *lntest.HarnessTest) {\n\ttestCases := []struct {\n\t\tname    string\n\t\tanchors bool\n\t}{{\n\t\tname:    \"anchors\",\n\t\tanchors: true,\n\t}, {\n\t\tname:    \"legacy\",\n\t\tanchors: false,\n\t}}\n\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\t\ttestFunc := func(ht *lntest.HarnessTest) {\n\t\t\ttestRevokedCloseRetributionAltruistWatchtowerCase(\n\t\t\t\tht, tc.anchors,\n\t\t\t)\n\t\t}\n\n\t\tsuccess := ht.Run(tc.name, func(tt *testing.T) {\n\t\t\tst := ht.Subtest(tt)\n\n\t\t\tst.RunTestCase(&lntest.TestCase{\n\t\t\t\tName:     tc.name,\n\t\t\t\tTestFunc: testFunc,\n\t\t\t})\n\t\t})\n\n\t\tif !success {\n\t\t\t// Log failure time to help relate the lnd logs to the\n\t\t\t// failure.\n\t\t\tht.Logf(\"Failure time: %v\", time.Now().Format(\n\t\t\t\t\"2006-01-02 15:04:05.000\",\n\t\t\t))\n\n\t\t\tbreak\n\t\t}\n\t}\n}\n",
      "length": 650,
      "tokens": 84,
      "embedding": []
    },
    {
      "slug": "func testRevokedCloseRetributionAltruistWatchtowerCase(ht *lntest.HarnessTest,",
      "content": "func testRevokedCloseRetributionAltruistWatchtowerCase(ht *lntest.HarnessTest,\n\tanchors bool) {\n\n\tconst (\n\t\tchanAmt     = funding.MaxBtcFundingAmount\n\t\tpaymentAmt  = 10000\n\t\tnumInvoices = 6\n\t\texternalIP  = \"1.2.3.4\"\n\t)\n\n\t// Since we'd like to test some multi-hop failure scenarios, we'll\n\t// introduce another node into our test network: Carol.\n\tcarolArgs := []string{\"--hodl.exit-settle\"}\n\tif anchors {\n\t\tcarolArgs = append(carolArgs, \"--protocol.anchors\")\n\t}\n\tcarol := ht.NewNode(\"Carol\", carolArgs)\n\n\t// Willy the watchtower will protect Dave from Carol's breach. He will\n\t// remain online in order to punish Carol on Dave's behalf, since the\n\t// breach will happen while Dave is offline.\n\twilly := ht.NewNode(\n\t\t\"Willy\", []string{\"--watchtower.active\",\n\t\t\t\"--watchtower.externalip=\" + externalIP},\n\t)\n\n\twillyInfo := willy.RPC.GetInfoWatchtower()\n\n\t// Assert that Willy has one listener and it is 0.0.0.0:9911 or\n\t// [::]:9911. Since no listener is explicitly specified, one of these\n\t// should be the default depending on whether the host supports IPv6 or\n\t// not.\n\trequire.Len(ht, willyInfo.Listeners, 1, \"Willy should have 1 listener\")\n\tlistener := willyInfo.Listeners[0]\n\tif listener != \"0.0.0.0:9911\" && listener != \"[::]:9911\" {\n\t\tht.Fatalf(\"expected listener on 0.0.0.0:9911 or [::]:9911, \"+\n\t\t\t\"got %v\", listener)\n\t}\n\n\t// Assert the Willy's URIs properly display the chosen external IP.\n\trequire.Len(ht, willyInfo.Uris, 1, \"Willy should have 1 uri\")\n\trequire.Contains(ht, willyInfo.Uris[0], externalIP)\n\n\t// Dave will be the breached party. We set --nolisten to ensure Carol\n\t// won't be able to connect to him and trigger the channel data\n\t// protection logic automatically.\n\tdaveArgs := []string{\n\t\t\"--nolisten\",\n\t\t\"--wtclient.active\",\n\t}\n\tif anchors {\n\t\tdaveArgs = append(daveArgs, \"--protocol.anchors\")\n\t}\n\tdave := ht.NewNode(\"Dave\", daveArgs)\n\n\taddTowerReq := &wtclientrpc.AddTowerRequest{\n\t\tPubkey:  willyInfo.Pubkey,\n\t\tAddress: listener,\n\t}\n\tdave.RPC.AddTower(addTowerReq)\n\n\t// We must let Dave have an open channel before she can send a node\n\t// announcement, so we open a channel with Carol,\n\tht.ConnectNodes(dave, carol)\n\n\t// Before we make a channel, we'll load up Dave with some coins sent\n\t// directly from the miner.\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, dave)\n\n\t// Send one more UTXOs if this is a neutrino backend.\n\tif ht.IsNeutrinoBackend() {\n\t\tht.FundCoins(btcutil.SatoshiPerBitcoin, dave)\n\t}\n\n\t// In order to test Dave's response to an uncooperative channel\n\t// closure by Carol, we'll first open up a channel between them with a\n\t// 0.5 BTC value.\n\tparams := lntest.OpenChannelParams{\n\t\tAmt:     3 * (chanAmt / 4),\n\t\tPushAmt: chanAmt / 4,\n\t}\n\tchanPoint := ht.OpenChannel(dave, carol, params)\n\n\t// With the channel open, we'll create a few invoices for Carol that\n\t// Dave will pay to in order to advance the state of the channel.\n\tcarolPayReqs, _, _ := ht.CreatePayReqs(carol, paymentAmt, numInvoices)\n\n\t// Next query for Carol's channel state, as we sent 0 payments, Carol\n\t// should still see her balance as the push amount, which is 1/4 of the\n\t// capacity.\n\tcarolChan := ht.AssertChannelLocalBalance(\n\t\tcarol, chanPoint, int64(chanAmt/4),\n\t)\n\n\t// Grab Carol's current commitment height (update number), we'll later\n\t// revert her to this state after additional updates to force him to\n\t// broadcast this soon to be revoked state.\n\tcarolStateNumPreCopy := int(carolChan.NumUpdates)\n\n\t// With the temporary file created, copy Carol's current state into the\n\t// temporary file we created above. Later after more updates, we'll\n\t// restore this state.\n\tht.BackupDB(carol)\n\n\t// Reconnect the peers after the restart that was needed for the db\n\t// backup.\n\tht.EnsureConnected(dave, carol)\n\n\t// Once connected, give Dave some time to enable the channel again.\n\tht.AssertTopologyChannelOpen(dave, chanPoint)\n\n\t// Finally, send payments from Dave to Carol, consuming Carol's\n\t// remaining payment hashes.\n\tht.CompletePaymentRequestsNoWait(dave, carolPayReqs, chanPoint)\n\n\tdaveBalResp := dave.RPC.WalletBalance()\n\tdavePreSweepBalance := daveBalResp.ConfirmedBalance\n\n\t// Wait until the backup has been accepted by the watchtower before\n\t// shutting down Dave.\n\terr := wait.NoError(func() error {\n\t\tbkpStats := dave.RPC.WatchtowerStats()\n\t\tif bkpStats == nil {\n\t\t\treturn errors.New(\"no active backup sessions\")\n\t\t}\n\t\tif bkpStats.NumBackups == 0 {\n\t\t\treturn errors.New(\"no backups accepted\")\n\t\t}\n\n\t\treturn nil\n\t}, defaultTimeout)\n\trequire.NoError(ht, err, \"unable to verify backup task completed\")\n\n\t// Shutdown Dave to simulate going offline for an extended period of\n\t// time. Once he's not watching, Carol will try to breach the channel.\n\trestart := ht.SuspendNode(dave)\n\n\t// Now we shutdown Carol, copying over the his temporary database state\n\t// which has the *prior* channel state over his current most up to date\n\t// state. With this, we essentially force Carol to travel back in time\n\t// within the channel's history.\n\tht.RestartNodeAndRestoreDB(carol)\n\n\t// Now query for Carol's channel state, it should show that he's at a\n\t// state number in the past, not the *latest* state.\n\tht.AssertChannelCommitHeight(carol, chanPoint, carolStateNumPreCopy)\n\n\t// Now force Carol to execute a *force* channel closure by unilaterally\n\t// broadcasting his current channel state. This is actually the\n\t// commitment transaction of a prior *revoked* state, so he'll soon\n\t// feel the wrath of Dave's retribution.\n\tcloseUpdates, closeTxID := ht.CloseChannelAssertPending(\n\t\tcarol, chanPoint, true,\n\t)\n\n\t// Finally, generate a single block, wait for the final close status\n\t// update, then ensure that the closing transaction was included in the\n\t// block.\n\tblock := ht.MineBlocksAndAssertNumTxes(1, 1)[0]\n\n\tbreachTXID := ht.WaitForChannelCloseEvent(closeUpdates)\n\tht.Miner.AssertTxInBlock(block, breachTXID)\n\n\t// The breachTXID should match the above closeTxID.\n\trequire.EqualValues(ht, breachTXID, closeTxID)\n\n\t// Query the mempool for Dave's justice transaction, this should be\n\t// broadcast as Carol's contract breaching transaction gets confirmed\n\t// above.\n\tjusticeTXID := ht.Miner.AssertNumTxsInMempool(1)[0]\n\n\t// Query for the mempool transaction found above. Then assert that all\n\t// the inputs of this transaction are spending outputs generated by\n\t// Carol's breach transaction above.\n\tjusticeTx := ht.Miner.GetRawTransaction(justiceTXID)\n\tfor _, txIn := range justiceTx.MsgTx().TxIn {\n\t\trequire.Equal(ht, breachTXID[:], txIn.PreviousOutPoint.Hash[:],\n\t\t\t\"justice tx not spending commitment utxo\")\n\t}\n\n\twillyBalResp := willy.RPC.WalletBalance()\n\trequire.Zero(ht, willyBalResp.ConfirmedBalance,\n\t\t\"willy should have 0 balance before mining justice transaction\")\n\n\t// Now mine a block, this transaction should include Dave's justice\n\t// transaction which was just accepted into the mempool.\n\tblock = ht.MineBlocksAndAssertNumTxes(1, 1)[0]\n\n\t// The block should have exactly *two* transactions, one of which is\n\t// the justice transaction.\n\trequire.Len(ht, block.Transactions, 2, \"transaction wasn't mined\")\n\tjusticeSha := block.Transactions[1].TxHash()\n\trequire.Equal(ht, justiceTx.Hash()[:], justiceSha[:],\n\t\t\"justice tx wasn't mined\")\n\n\t// Ensure that Willy doesn't get any funds, as he is acting as an\n\t// altruist watchtower.\n\terr = wait.NoError(func() error {\n\t\twillyBalResp := willy.RPC.WalletBalance()\n\n\t\tif willyBalResp.ConfirmedBalance != 0 {\n\t\t\treturn fmt.Errorf(\"Expected Willy to have no funds \"+\n\t\t\t\t\"after justice transaction was mined, found %v\",\n\t\t\t\twillyBalResp)\n\t\t}\n\n\t\treturn nil\n\t}, time.Second*5)\n\trequire.NoError(ht, err, \"timeout checking willy's balance\")\n\n\t// Before restarting Dave, shutdown Carol so Dave won't sync with her.\n\t// Otherwise, during the restart, Dave will realize Carol is falling\n\t// behind and return `ErrCommitSyncRemoteDataLoss`, thus force closing\n\t// the channel. Although this force close tx will be later replaced by\n\t// the breach tx, it will create two anchor sweeping txes for neutrino\n\t// backend, causing the confirmed wallet balance to be zero later on\n\t// because the utxos are used in sweeping.\n\tht.Shutdown(carol)\n\n\t// Restart Dave, who will still think his channel with Carol is open.\n\t// We should him to detect the breach, but realize that the funds have\n\t// then been swept to his wallet by Willy.\n\trequire.NoError(ht, restart(), \"unable to restart dave\")\n\n\terr = wait.NoError(func() error {\n\t\tdaveBalResp := dave.RPC.ChannelBalance()\n\t\tif daveBalResp.LocalBalance.Sat != 0 {\n\t\t\treturn fmt.Errorf(\"Dave should end up with zero \"+\n\t\t\t\t\"channel balance, instead has %d\",\n\t\t\t\tdaveBalResp.LocalBalance.Sat)\n\t\t}\n\n\t\treturn nil\n\t}, defaultTimeout)\n\trequire.NoError(ht, err, \"timeout checking dave's channel balance\")\n\n\tht.AssertNumPendingForceClose(dave, 0)\n\n\t// If this is an anchor channel, Dave would sweep the anchor.\n\tif anchors {\n\t\tht.MineBlocksAndAssertNumTxes(1, 1)\n\t}\n\n\t// Check that Dave's wallet balance is increased.\n\terr = wait.NoError(func() error {\n\t\tdaveBalResp := dave.RPC.WalletBalance()\n\n\t\tif daveBalResp.ConfirmedBalance <= davePreSweepBalance {\n\t\t\treturn fmt.Errorf(\"Dave should have more than %d \"+\n\t\t\t\t\"after sweep, instead has %d\",\n\t\t\t\tdavePreSweepBalance,\n\t\t\t\tdaveBalResp.ConfirmedBalance)\n\t\t}\n\n\t\treturn nil\n\t}, defaultTimeout)\n\trequire.NoError(ht, err, \"timeout checking dave's wallet balance\")\n\n\t// Dave should have no open channels.\n\tht.AssertNodeNumChannels(dave, 0)\n}\n",
      "length": 9042,
      "tokens": 1233,
      "embedding": []
    }
  ]
}