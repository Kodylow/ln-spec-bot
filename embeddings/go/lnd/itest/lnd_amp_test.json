{
  "filepath": "../implementations/go/lnd/itest/lnd_amp_test.go",
  "package": "itest",
  "sections": [
    {
      "slug": "func testSendPaymentAMPInvoice(ht *lntest.HarnessTest) {",
      "content": "func testSendPaymentAMPInvoice(ht *lntest.HarnessTest) {\n\tsucceed := ht.Run(\"native payaddr\", func(t *testing.T) {\n\t\ttt := ht.Subtest(t)\n\t\ttestSendPaymentAMPInvoiceCase(tt, false)\n\t})\n\n\t// Abort the test if failed.\n\tif !succeed {\n\t\treturn\n\t}\n\n\tht.Run(\"external payaddr\", func(t *testing.T) {\n\t\ttt := ht.Subtest(t)\n\t\ttestSendPaymentAMPInvoiceCase(tt, true)\n\t})\n}\n",
      "length": 290,
      "tokens": 36,
      "embedding": []
    },
    {
      "slug": "func testSendPaymentAMPInvoiceCase(ht *lntest.HarnessTest,",
      "content": "func testSendPaymentAMPInvoiceCase(ht *lntest.HarnessTest,\n\tuseExternalPayAddr bool) {\n\n\tmts := newMppTestScenario(ht)\n\n\t// Subscribe to bob's invoices. Do this early in the test to make sure\n\t// that the subscription has actually been completed when we add an\n\t// invoice. Otherwise the notification will be missed.\n\treq := &lnrpc.InvoiceSubscription{}\n\tbobInvoiceSubscription := mts.bob.RPC.SubscribeInvoices(req)\n\n\tconst paymentAmt = btcutil.Amount(300000)\n\n\t// Set up a network with three different paths Alice <-> Bob. Channel\n\t// capacities are set such that the payment can only succeed if (at\n\t// least) three paths are used.\n\t//\n\t//              _ Eve _\n\t//             /       \\\n\t// Alice -- Carol ---- Bob\n\t//      \\              /\n\t//       \\__ Dave ____/\n\t//\n\tmppReq := &mppOpenChannelRequest{\n\t\tamtAliceCarol: 235000,\n\t\tamtAliceDave:  135000,\n\t\tamtCarolBob:   135000,\n\t\tamtCarolEve:   135000,\n\t\tamtDaveBob:    135000,\n\t\tamtEveBob:     135000,\n\t}\n\tmts.openChannels(mppReq)\n\tchanPointAliceDave := mts.channelPoints[1]\n\tchanPointDaveBob := mts.channelPoints[4]\n\n\tinvoice := &lnrpc.Invoice{\n\t\tValue: int64(paymentAmt),\n\t\tIsAmp: true,\n\t}\n\taddInvoiceResp := mts.bob.RPC.AddInvoice(invoice)\n\n\t// Ensure we get a notification of the invoice being added by Bob.\n\trpcInvoice := ht.ReceiveInvoiceUpdate(bobInvoiceSubscription)\n\n\trequire.False(ht, rpcInvoice.Settled)\n\trequire.Equal(ht, lnrpc.Invoice_OPEN, rpcInvoice.State)\n\trequire.Equal(ht, int64(0), rpcInvoice.AmtPaidSat)\n\trequire.Equal(ht, int64(0), rpcInvoice.AmtPaidMsat)\n\trequire.Equal(ht, 0, len(rpcInvoice.Htlcs))\n\n\t// Increase Dave's fee to make the test deterministic. Otherwise it\n\t// would be unpredictable whether pathfinding would go through Charlie\n\t// or Dave for the first shard.\n\texpectedPolicy := mts.updateDaveGlobalPolicy()\n\n\t// Make sure Alice has heard it for both Dave's channels.\n\tht.AssertChannelPolicyUpdate(\n\t\tmts.alice, mts.dave, expectedPolicy, chanPointAliceDave, false,\n\t)\n\tht.AssertChannelPolicyUpdate(\n\t\tmts.alice, mts.dave, expectedPolicy, chanPointDaveBob, false,\n\t)\n\n\t// Generate an external payment address when attempting to pseudo-reuse\n\t// an AMP invoice. When using an external payment address, we'll also\n\t// expect an extra invoice to appear in the ListInvoices response, since\n\t// a new invoice will be JIT inserted under a different payment address\n\t// than the one in the invoice.\n\tvar (\n\t\texpNumInvoices  = 1\n\t\texternalPayAddr []byte\n\t)\n\tif useExternalPayAddr {\n\t\texpNumInvoices = 2\n\t\texternalPayAddr = ht.Random32Bytes()\n\t}\n\n\tsendReq := &routerrpc.SendPaymentRequest{\n\t\tPaymentRequest: addInvoiceResp.PaymentRequest,\n\t\tPaymentAddr:    externalPayAddr,\n\t\tTimeoutSeconds: 60,\n\t\tFeeLimitMsat:   noFeeLimitMsat,\n\t}\n\tpayment := ht.SendPaymentAssertSettled(mts.alice, sendReq)\n\n\t// Check that Alice split the payment in at least three shards. Because\n\t// the hand-off of the htlc to the link is asynchronous (via a mailbox),\n\t// there is some non-determinism in the process. Depending on whether\n\t// the new pathfinding round is started before or after the htlc is\n\t// locked into the channel, different sharding may occur. Therefore we\n\t// can only check if the number of shards isn't below the theoretical\n\t// minimum.\n\tsucceeded := 0\n\tfor _, htlc := range payment.Htlcs {\n\t\tif htlc.Status == lnrpc.HTLCAttempt_SUCCEEDED {\n\t\t\tsucceeded++\n\t\t}\n\t}\n\n\tconst minExpectedShards = 3\n\trequire.GreaterOrEqual(ht, succeeded, minExpectedShards,\n\t\t\"expected num of shards not reached\")\n\n\t// When an external payment address is supplied, we'll get an extra\n\t// notification for the JIT inserted invoice, since it differs from the\n\t// original.\n\tif useExternalPayAddr {\n\t\tht.ReceiveInvoiceUpdate(bobInvoiceSubscription)\n\t}\n\n\t// There should now be a settle event for the invoice.\n\trpcInvoice = ht.ReceiveInvoiceUpdate(bobInvoiceSubscription)\n\n\t// Also fetch Bob's invoice from ListInvoices and assert it is equal to\n\t// the one received via the subscription.\n\tinvoices := ht.AssertNumInvoices(mts.bob, expNumInvoices)\n\tht.AssertInvoiceEqual(rpcInvoice, invoices[expNumInvoices-1])\n\n\t// Assert that the invoice is settled for the total payment amount and\n\t// has the correct payment address.\n\trequire.True(ht, rpcInvoice.Settled)\n\trequire.Equal(ht, lnrpc.Invoice_SETTLED, rpcInvoice.State)\n\trequire.Equal(ht, int64(paymentAmt), rpcInvoice.AmtPaidSat)\n\trequire.Equal(ht, int64(paymentAmt*1000), rpcInvoice.AmtPaidMsat)\n\n\t// Finally, assert that the same set id is recorded for each htlc, and\n\t// that the preimage hash pair is valid.\n\tvar setID []byte\n\trequire.Equal(ht, succeeded, len(rpcInvoice.Htlcs))\n\tfor _, htlc := range rpcInvoice.Htlcs {\n\t\trequire.NotNil(ht, htlc.Amp)\n\t\tif setID == nil {\n\t\t\tsetID = make([]byte, 32)\n\t\t\tcopy(setID, htlc.Amp.SetId)\n\t\t}\n\t\trequire.Equal(ht, setID, htlc.Amp.SetId)\n\n\t\t// Parse the child hash and child preimage, and assert they are\n\t\t// well-formed.\n\t\tchildHash, err := lntypes.MakeHash(htlc.Amp.Hash)\n\t\trequire.NoError(ht, err)\n\t\tchildPreimage, err := lntypes.MakePreimage(htlc.Amp.Preimage)\n\t\trequire.NoError(ht, err)\n\n\t\t// Assert that the preimage actually matches the hashes.\n\t\tvalidPreimage := childPreimage.Matches(childHash)\n\t\trequire.True(ht, validPreimage)\n\t}\n\n\t// The set ID we extract above should be shown in the final settled\n\t// state.\n\tampState := rpcInvoice.AmpInvoiceState[hex.EncodeToString(setID)]\n\trequire.Equal(ht, lnrpc.InvoiceHTLCState_SETTLED, ampState.State)\n\n\t// Finally, close all channels.\n\tmts.closeChannels()\n}\n\n// testSendPaymentAMPInvoiceRepeat tests that it's possible to pay an AMP\n// invoice multiple times by having the client generate a new setID each time.",
      "length": 5398,
      "tokens": 667,
      "embedding": []
    },
    {
      "slug": "func testSendPaymentAMPInvoiceRepeat(ht *lntest.HarnessTest) {",
      "content": "func testSendPaymentAMPInvoiceRepeat(ht *lntest.HarnessTest) {\n\t// In this basic test, we'll only need two nodes as we want to\n\t// primarily test the recurring payment feature. So we'll re-use the\n\tcarol := ht.NewNode(\"Carol\", nil)\n\n\t// Send Carol enough coins to be able to open a channel to Dave.\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, carol)\n\n\tdave := ht.NewNode(\"Dave\", nil)\n\n\t// Set up an invoice subscription so we can be notified when Dave\n\t// receives his repeated payments.\n\treq := &lnrpc.InvoiceSubscription{}\n\tinvSubscription := dave.RPC.SubscribeInvoices(req)\n\n\t// Before we start the test, we'll ensure both sides are connected to\n\t// the funding flow can properly be executed.\n\tht.EnsureConnected(carol, dave)\n\n\t// Establish a channel between Carol and Dave.\n\tchanAmt := btcutil.Amount(100_000)\n\tht.OpenChannel(\n\t\tcarol, dave, lntest.OpenChannelParams{Amt: chanAmt},\n\t)\n\n\t// Create an AMP invoice of a trivial amount, that we'll pay repeatedly\n\t// in this integration test.\n\tpaymentAmt := 10000\n\tinvoice := &lnrpc.Invoice{\n\t\tValue: int64(paymentAmt),\n\t\tIsAmp: true,\n\t}\n\taddInvoiceResp := dave.RPC.AddInvoice(invoice)\n\n\t// We should get an initial notification that the HTLC has been added.\n\trpcInvoice := ht.ReceiveInvoiceUpdate(invSubscription)\n\trequire.False(ht, rpcInvoice.Settled)\n\trequire.Equal(ht, lnrpc.Invoice_OPEN, rpcInvoice.State)\n\trequire.Equal(ht, int64(0), rpcInvoice.AmtPaidSat)\n\trequire.Equal(ht, int64(0), rpcInvoice.AmtPaidMsat)\n\trequire.Equal(ht, 0, len(rpcInvoice.Htlcs))\n\n\t// Now we'll use Carol to pay the invoice that Dave created.\n\tht.CompletePaymentRequests(\n\t\tcarol, []string{addInvoiceResp.PaymentRequest},\n\t)\n\n\t// Dave should get a notification that the invoice has been settled.\n\tinvoiceNtfn := ht.ReceiveInvoiceUpdate(invSubscription)\n\n\t// The notification should signal that the invoice is now settled, and\n\t// should also include the set ID, and show the proper amount paid.\n\trequire.True(ht, invoiceNtfn.Settled)\n\trequire.Equal(ht, lnrpc.Invoice_SETTLED, invoiceNtfn.State)\n\trequire.Equal(ht, paymentAmt, int(invoiceNtfn.AmtPaidSat))\n\trequire.Equal(ht, 1, len(invoiceNtfn.AmpInvoiceState))\n\tvar firstSetID []byte\n\tfor setIDStr, ampState := range invoiceNtfn.AmpInvoiceState {\n\t\tfirstSetID, _ = hex.DecodeString(setIDStr)\n\t\trequire.Equal(ht, lnrpc.InvoiceHTLCState_SETTLED,\n\t\t\tampState.State)\n\t}\n\n\t// Pay the invoice again, we should get another notification that Dave\n\t// has received another payment.\n\tht.CompletePaymentRequests(\n\t\tcarol, []string{addInvoiceResp.PaymentRequest},\n\t)\n\n\t// Dave should get another notification.\n\tinvoiceNtfn = ht.ReceiveInvoiceUpdate(invSubscription)\n\n\t// The invoice should still be shown as settled, and also include the\n\t// information about this newly generated setID, showing 2x the amount\n\t// paid.\n\trequire.True(ht, invoiceNtfn.Settled)\n\trequire.Equal(ht, paymentAmt*2, int(invoiceNtfn.AmtPaidSat))\n\n\tvar secondSetID []byte\n\tfor setIDStr, ampState := range invoiceNtfn.AmpInvoiceState {\n\t\tsecondSetID, _ = hex.DecodeString(setIDStr)\n\t\trequire.Equal(ht, lnrpc.InvoiceHTLCState_SETTLED,\n\t\t\tampState.State)\n\t}\n\n\t// The returned invoice should only include a single HTLC since we\n\t// return the \"projected\" sub-invoice for a given setID.\n\trequire.Equal(ht, 1, len(invoiceNtfn.Htlcs))\n\n\t// However the AMP state index should show that there've been two\n\t// repeated payments to this invoice so far.\n\trequire.Equal(ht, 2, len(invoiceNtfn.AmpInvoiceState))\n\n\t// Now we'll look up the invoice using the new LookupInvoice2 RPC call\n\t// by the set ID of each of the invoices.\n\tmsg := &invoicesrpc.LookupInvoiceMsg{\n\t\tInvoiceRef: &invoicesrpc.LookupInvoiceMsg_SetId{\n\t\t\tSetId: firstSetID,\n\t\t},\n\t\tLookupModifier: invoicesrpc.LookupModifier_HTLC_SET_ONLY,\n\t}\n\tsubInvoice1 := dave.RPC.LookupInvoiceV2(msg)\n\tmsg = &invoicesrpc.LookupInvoiceMsg{\n\t\tInvoiceRef: &invoicesrpc.LookupInvoiceMsg_SetId{\n\t\t\tSetId: secondSetID,\n\t\t},\n\t\tLookupModifier: invoicesrpc.LookupModifier_HTLC_SET_ONLY,\n\t}\n\tsubInvoice2 := dave.RPC.LookupInvoiceV2(msg)\n\n\t// Each invoice should only show a single HTLC present, as we passed\n\t// the HTLC set only modifier.\n\trequire.Equal(ht, 1, len(subInvoice1.Htlcs))\n\trequire.Equal(ht, 1, len(subInvoice2.Htlcs))\n\n\t// If we look up the same invoice, by its payment address, but now with\n\t// the HTLC blank modifier, then none of them should be returned.\n\tmsg = &invoicesrpc.LookupInvoiceMsg{\n\t\tInvoiceRef: &invoicesrpc.LookupInvoiceMsg_PaymentAddr{\n\t\t\tPaymentAddr: addInvoiceResp.PaymentAddr,\n\t\t},\n\t\tLookupModifier: invoicesrpc.LookupModifier_HTLC_SET_BLANK,\n\t}\n\trootInvoice := dave.RPC.LookupInvoiceV2(msg)\n\trequire.Equal(ht, 0, len(rootInvoice.Htlcs))\n\n\t// If we look up the same invoice, by its payment address, but without\n\t// that modified, then we should get all the relevant HTLCs.\n\tmsg = &invoicesrpc.LookupInvoiceMsg{\n\t\tInvoiceRef: &invoicesrpc.LookupInvoiceMsg_PaymentAddr{\n\t\t\tPaymentAddr: addInvoiceResp.PaymentAddr,\n\t\t},\n\t}\n\trootInvoice = dave.RPC.LookupInvoiceV2(msg)\n\trequire.Equal(ht, 2, len(rootInvoice.Htlcs))\n\n\t// Finally, we'll test that if we subscribe for notifications of\n\t// settled invoices, we get a backlog, which includes the invoice we\n\t// settled last (since you can only fetch from index 1 onwards), and\n\t// only the relevant set of HTLCs.\n\treq = &lnrpc.InvoiceSubscription{\n\t\tSettleIndex: 1,\n\t}\n\tinvSub2 := dave.RPC.SubscribeInvoices(req)\n\n\t// The first invoice we get back should match the state of the invoice\n\t// after our second payment: amt updated, but only a single HTLC shown\n\t// through.\n\tbacklogInv := ht.ReceiveInvoiceUpdate(invSub2)\n\trequire.Equal(ht, 1, len(backlogInv.Htlcs))\n\trequire.Equal(ht, 2, len(backlogInv.AmpInvoiceState))\n\trequire.True(ht, backlogInv.Settled)\n\trequire.Equal(ht, paymentAmt*2, int(backlogInv.AmtPaidSat))\n}\n\n// testSendPaymentAMP tests that we can send an AMP payment to a specified\n// destination using SendPaymentV2.",
      "length": 5658,
      "tokens": 659,
      "embedding": []
    },
    {
      "slug": "func testSendPaymentAMP(ht *lntest.HarnessTest) {",
      "content": "func testSendPaymentAMP(ht *lntest.HarnessTest) {\n\tmts := newMppTestScenario(ht)\n\tconst paymentAmt = btcutil.Amount(300000)\n\n\t// Set up a network with three different paths Alice <-> Bob. Channel\n\t// capacities are set such that the payment can only succeed if (at\n\t// least) three paths are used.\n\t//\n\t//              _ Eve _\n\t//             /       \\\n\t// Alice -- Carol ---- Bob\n\t//      \\              /\n\t//       \\__ Dave ____/\n\t//\n\tmppReq := &mppOpenChannelRequest{\n\t\tamtAliceCarol: 235000,\n\t\tamtAliceDave:  135000,\n\t\tamtCarolBob:   135000,\n\t\tamtCarolEve:   135000,\n\t\tamtDaveBob:    135000,\n\t\tamtEveBob:     135000,\n\t}\n\tmts.openChannels(mppReq)\n\tchanPointAliceDave := mts.channelPoints[1]\n\n\t// Increase Dave's fee to make the test deterministic. Otherwise it\n\t// would be unpredictable whether pathfinding would go through Charlie\n\t// or Dave for the first shard.\n\texpectedPolicy := mts.updateDaveGlobalPolicy()\n\n\t// Make sure Alice has heard it.\n\tht.AssertChannelPolicyUpdate(\n\t\tmts.alice, mts.dave, expectedPolicy, chanPointAliceDave, false,\n\t)\n\n\tsendReq := &routerrpc.SendPaymentRequest{\n\t\tDest:           mts.bob.PubKey[:],\n\t\tAmt:            int64(paymentAmt),\n\t\tFinalCltvDelta: chainreg.DefaultBitcoinTimeLockDelta,\n\t\tTimeoutSeconds: 60,\n\t\tFeeLimitMsat:   noFeeLimitMsat,\n\t\tAmp:            true,\n\t}\n\tpayment := ht.SendPaymentAssertSettled(mts.alice, sendReq)\n\n\t// Check that Alice split the payment in at least three shards. Because\n\t// the hand-off of the htlc to the link is asynchronous (via a mailbox),\n\t// there is some non-determinism in the process. Depending on whether\n\t// the new pathfinding round is started before or after the htlc is\n\t// locked into the channel, different sharding may occur. Therefore we\n\t// can only check if the number of shards isn't below the theoretical\n\t// minimum.\n\tsucceeded := 0\n\tfor _, htlc := range payment.Htlcs {\n\t\tif htlc.Status == lnrpc.HTLCAttempt_SUCCEEDED {\n\t\t\tsucceeded++\n\t\t}\n\t}\n\n\tconst minExpectedShards = 3\n\trequire.GreaterOrEqual(ht, succeeded, minExpectedShards,\n\t\t\"expected num of shards not reached\")\n\n\t// Fetch Bob's invoices. There should only be one invoice.\n\tinvoices := ht.AssertNumInvoices(mts.bob, 1)\n\trpcInvoice := invoices[0]\n\n\t// Assert that the invoice is settled for the total payment amount and\n\t// has the correct payment address.\n\trequire.True(ht, rpcInvoice.Settled)\n\trequire.Equal(ht, lnrpc.Invoice_SETTLED, rpcInvoice.State)\n\trequire.Equal(ht, int64(paymentAmt), rpcInvoice.AmtPaidSat)\n\trequire.Equal(ht, int64(paymentAmt*1000), rpcInvoice.AmtPaidMsat)\n\n\t// Finally, assert that the same set id is recorded for each htlc, and\n\t// that the preimage hash pair is valid.\n\tvar setID []byte\n\trequire.Equal(ht, succeeded, len(rpcInvoice.Htlcs))\n\tfor _, htlc := range rpcInvoice.Htlcs {\n\t\trequire.NotNil(ht, htlc.Amp)\n\t\tif setID == nil {\n\t\t\tsetID = make([]byte, 32)\n\t\t\tcopy(setID, htlc.Amp.SetId)\n\t\t}\n\t\trequire.Equal(ht, setID, htlc.Amp.SetId)\n\n\t\t// Parse the child hash and child preimage, and assert they are\n\t\t// well-formed.\n\t\tchildHash, err := lntypes.MakeHash(htlc.Amp.Hash)\n\t\trequire.NoError(ht, err)\n\t\tchildPreimage, err := lntypes.MakePreimage(htlc.Amp.Preimage)\n\t\trequire.NoError(ht, err)\n\n\t\t// Assert that the preimage actually matches the hashes.\n\t\tvalidPreimage := childPreimage.Matches(childHash)\n\t\trequire.True(ht, validPreimage)\n\t}\n\n\t// The set ID we extract above should be shown in the final settled\n\t// state.\n\tampState := rpcInvoice.AmpInvoiceState[hex.EncodeToString(setID)]\n\trequire.Equal(ht, lnrpc.InvoiceHTLCState_SETTLED, ampState.State)\n\n\t// Finally, close all channels.\n\tmts.closeChannels()\n}\n",
      "length": 3442,
      "tokens": 423,
      "embedding": []
    },
    {
      "slug": "func testSendToRouteAMP(ht *lntest.HarnessTest) {",
      "content": "func testSendToRouteAMP(ht *lntest.HarnessTest) {\n\tmts := newMppTestScenario(ht)\n\tconst (\n\t\tpaymentAmt = btcutil.Amount(300000)\n\t\tnumShards  = 3\n\t\tshardAmt   = paymentAmt / numShards\n\t\tchanAmt    = shardAmt * 3 / 2\n\t)\n\n\t// Subscribe to bob's invoices.\n\treq := &lnrpc.InvoiceSubscription{}\n\tbobInvoiceSubscription := mts.bob.RPC.SubscribeInvoices(req)\n\n\t// Set up a network with three different paths Alice <-> Bob.\n\t//              _ Eve _\n\t//             /       \\\n\t// Alice -- Carol ---- Bob\n\t//      \\              /\n\t//       \\__ Dave ____/\n\t///\n\tmppReq := &mppOpenChannelRequest{\n\t\t// Since the channel Alice-> Carol will have to carry two\n\t\t// shards, we make it larger.\n\t\tamtAliceCarol: chanAmt + shardAmt,\n\t\tamtAliceDave:  chanAmt,\n\t\tamtCarolBob:   chanAmt,\n\t\tamtCarolEve:   chanAmt,\n\t\tamtDaveBob:    chanAmt,\n\t\tamtEveBob:     chanAmt,\n\t}\n\tmts.openChannels(mppReq)\n\n\t// We'll send shards along three routes from Alice.\n\tsendRoutes := [numShards][]*node.HarnessNode{\n\t\t{mts.carol, mts.bob},\n\t\t{mts.dave, mts.bob},\n\t\t{mts.carol, mts.eve, mts.bob},\n\t}\n\n\tpayAddr := ht.Random32Bytes()\n\tsetID := ht.Random32Bytes()\n\n\tvar sharer amp.Sharer\n\tsharer, err := amp.NewSeedSharer()\n\trequire.NoError(ht, err)\n\n\tchildPreimages := make(map[lntypes.Preimage]uint32)\n\tresponses := make(chan *lnrpc.HTLCAttempt, len(sendRoutes))\n\n\t// Define a closure for sending each of the three shards.\n\tsendShard := func(i int, hops []*node.HarnessNode) {\n\t\t// Build a route for the specified hops.\n\t\tr := mts.buildRoute(shardAmt, mts.alice, hops)\n\n\t\t// Set the MPP records to indicate this is a payment shard.\n\t\thop := r.Hops[len(r.Hops)-1]\n\t\thop.TlvPayload = true\n\t\thop.MppRecord = &lnrpc.MPPRecord{\n\t\t\tPaymentAddr:  payAddr,\n\t\t\tTotalAmtMsat: int64(paymentAmt * 1000),\n\t\t}\n\n\t\tvar child *amp.Child\n\t\tif i < len(sendRoutes)-1 {\n\t\t\tvar left amp.Sharer\n\t\t\tleft, sharer, err = sharer.Split()\n\t\t\trequire.NoError(ht, err)\n\n\t\t\tchild = left.Child(uint32(i))\n\t\t} else {\n\t\t\tchild = sharer.Child(uint32(i))\n\t\t}\n\t\tchildPreimages[child.Preimage] = child.Index\n\n\t\thop.AmpRecord = &lnrpc.AMPRecord{\n\t\t\tRootShare:  child.Share[:],\n\t\t\tSetId:      setID,\n\t\t\tChildIndex: child.Index,\n\t\t}\n\n\t\t// Send the shard.\n\t\tsendReq := &routerrpc.SendToRouteRequest{\n\t\t\tPaymentHash: child.Hash[:],\n\t\t\tRoute:       r,\n\t\t}\n\n\t\t// We'll send all shards in their own goroutine, since\n\t\t// SendToRoute will block as long as the payment is in flight.\n\t\tgo func() {\n\t\t\tresp := mts.alice.RPC.SendToRouteV2(sendReq)\n\t\t\tresponses <- resp\n\t\t}()\n\t}\n\n\t// Send the first shard, this cause Bob to JIT add an invoice.\n\tsendShard(0, sendRoutes[0])\n\n\t// Ensure we get a notification of the invoice being added by Bob.\n\trpcInvoice, err := bobInvoiceSubscription.Recv()\n\trequire.NoError(ht, err)\n\n\trequire.False(ht, rpcInvoice.Settled)\n\trequire.Equal(ht, lnrpc.Invoice_OPEN, rpcInvoice.State)\n\trequire.Equal(ht, int64(0), rpcInvoice.AmtPaidSat)\n\trequire.Equal(ht, int64(0), rpcInvoice.AmtPaidMsat)\n\trequire.Equal(ht, payAddr, rpcInvoice.PaymentAddr)\n\n\trequire.Equal(ht, 0, len(rpcInvoice.Htlcs))\n\n\tsendShard(1, sendRoutes[1])\n\tsendShard(2, sendRoutes[2])\n\n\t// Assert that all of the child preimages are unique.\n\trequire.Equal(ht, len(sendRoutes), len(childPreimages))\n\n\t// Make a copy of the childPreimages map for validating the resulting\n\t// invoice.\n\tchildPreimagesCopy := make(map[lntypes.Preimage]uint32)\n\tfor preimage, childIndex := range childPreimages {\n\t\tchildPreimagesCopy[preimage] = childIndex\n\t}\n\n\t// Wait for all responses to be back, and check that they all\n\t// succeeded.\n\ttimer := time.After(defaultTimeout)\n\tfor range sendRoutes {\n\t\tvar resp *lnrpc.HTLCAttempt\n\t\tselect {\n\t\tcase resp = <-responses:\n\t\tcase <-timer:\n\t\t\trequire.Fail(ht, \"response not received\")\n\t\t}\n\n\t\trequire.Nil(ht, resp.Failure, \"received payment failure\")\n\n\t\tpreimage, err := lntypes.MakePreimage(resp.Preimage)\n\t\trequire.NoError(ht, err)\n\n\t\t// Assert that the response includes one of our child preimages.\n\t\t_, ok := childPreimages[preimage]\n\t\trequire.True(ht, ok)\n\n\t\t// Remove this preimage from out set so that we ensure all\n\t\t// responses have a unique child preimage.\n\t\tdelete(childPreimages, preimage)\n\t}\n\tchildPreimages = childPreimagesCopy\n\n\t// There should now be a settle event for the invoice.\n\trpcInvoice, err = bobInvoiceSubscription.Recv()\n\trequire.NoError(ht, err)\n\n\t// Also fetch Bob's invoice from ListInvoices and assert it is equal to\n\t// the one received via the subscription.\n\tinvoices := ht.AssertNumInvoices(mts.bob, 1)\n\tht.AssertInvoiceEqual(rpcInvoice, invoices[0])\n\n\t// Assert that the invoice is settled for the total payment amount and\n\t// has the correct payment address.\n\trequire.True(ht, rpcInvoice.Settled)\n\trequire.Equal(ht, lnrpc.Invoice_SETTLED, rpcInvoice.State)\n\trequire.Equal(ht, int64(paymentAmt), rpcInvoice.AmtPaidSat)\n\trequire.Equal(ht, int64(paymentAmt*1000), rpcInvoice.AmtPaidMsat)\n\trequire.Equal(ht, payAddr, rpcInvoice.PaymentAddr)\n\n\t// Finally, assert that the proper set id is recorded for each htlc, and\n\t// that the preimage hash pair is valid.\n\trequire.Equal(ht, numShards, len(rpcInvoice.Htlcs))\n\tfor _, htlc := range rpcInvoice.Htlcs {\n\t\trequire.NotNil(ht, htlc.Amp)\n\t\trequire.Equal(ht, setID, htlc.Amp.SetId)\n\n\t\t// Parse the child hash and child preimage, and assert they are\n\t\t// well-formed.\n\t\tchildHash, err := lntypes.MakeHash(htlc.Amp.Hash)\n\t\trequire.NoError(ht, err)\n\t\tchildPreimage, err := lntypes.MakePreimage(htlc.Amp.Preimage)\n\t\trequire.NoError(ht, err)\n\n\t\t// Assert that the preimage actually matches the hashes.\n\t\tvalidPreimage := childPreimage.Matches(childHash)\n\t\trequire.True(ht, validPreimage)\n\n\t\t// Assert that the HTLC includes one of our child preimages.\n\t\tchildIndex, ok := childPreimages[childPreimage]\n\t\trequire.True(ht, ok)\n\n\t\t// Assert that the correct child index is reflected.\n\t\trequire.Equal(ht, childIndex, htlc.Amp.ChildIndex)\n\n\t\t// Remove this preimage from our set so that we ensure all HTLCs\n\t\t// have a unique child preimage.\n\t\tdelete(childPreimages, childPreimage)\n\t}\n\n\t// Finally, close all channels.\n\tmts.closeChannels()\n}\n",
      "length": 5779,
      "tokens": 690,
      "embedding": []
    }
  ]
}