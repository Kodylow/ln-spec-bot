{
  "filepath": "../implementations/go/lnd/itest/lnd_rpc_middleware_interceptor_test.go",
  "package": "itest",
  "sections": [
    {
      "slug": "func testRPCMiddlewareInterceptor(ht *lntest.HarnessTest) {",
      "content": "func testRPCMiddlewareInterceptor(ht *lntest.HarnessTest) {\n\t// Let's first enable the middleware interceptor.\n\t//\n\t// NOTE: we cannot use standby nodes here as the test messes with\n\t// middleware interceptor. Thus we also skip the calling of cleanup of\n\t// each of the following subtests because no standby nodes are used.\n\talice := ht.NewNode(\"alice\", []string{\"--rpcmiddleware.enable\"})\n\tbob := ht.NewNode(\"bob\", nil)\n\n\t// Let's set up a channel between Alice and Bob, just to get some useful\n\t// data to inspect when doing RPC calls to Alice later.\n\tht.EnsureConnected(alice, bob)\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, alice)\n\tht.OpenChannel(alice, bob, lntest.OpenChannelParams{Amt: 1_234_567})\n\n\t// Load or bake the macaroons that the simulated users will use to\n\t// access the RPC.\n\treadonlyMac, err := alice.ReadMacaroon(\n\t\talice.Cfg.ReadMacPath, defaultTimeout,\n\t)\n\trequire.NoError(ht, err)\n\tadminMac, err := alice.ReadMacaroon(\n\t\talice.Cfg.AdminMacPath, defaultTimeout,\n\t)\n\trequire.NoError(ht, err)\n\n\tcustomCaveatReadonlyMac, err := macaroons.SafeCopyMacaroon(readonlyMac)\n\trequire.NoError(ht, err)\n\taddConstraint := macaroons.CustomConstraint(\n\t\t\"itest-caveat\", \"itest-value\",\n\t)\n\trequire.NoError(ht, addConstraint(customCaveatReadonlyMac))\n\tcustomCaveatAdminMac, err := macaroons.SafeCopyMacaroon(adminMac)\n\trequire.NoError(ht, err)\n\trequire.NoError(ht, addConstraint(customCaveatAdminMac))\n\n\t// Run all sub-tests now. We can't run anything in parallel because that\n\t// would cause the main test function to exit and the nodes being\n\t// cleaned up.\n\tht.Run(\"registration restrictions\", func(tt *testing.T) {\n\t\tmiddlewareRegistrationRestrictionTests(tt, alice)\n\t})\n\n\tht.Run(\"read-only intercept\", func(tt *testing.T) {\n\t\tregistration := registerMiddleware(\n\t\t\ttt, alice, &lnrpc.MiddlewareRegistration{\n\t\t\t\tMiddlewareName: \"itest-interceptor-1\",\n\t\t\t\tReadOnlyMode:   true,\n\t\t\t}, true,\n\t\t)\n\t\tdefer registration.cancel()\n\n\t\tmiddlewareInterceptionTest(\n\t\t\ttt, alice, bob, registration, readonlyMac,\n\t\t\tcustomCaveatReadonlyMac, true,\n\t\t)\n\t})\n\n\t// We've manually disconnected Bob from Alice in the previous test, make\n\t// sure they're connected again.\n\t//\n\t// NOTE: we may get an error here saying \"interceptor RPC client quit\"\n\t// as it takes some time for the interceptor to fully quit. Thus we\n\t// restart the node here to make sure the old interceptor is removed\n\t// from registration.\n\tht.RestartNode(alice)\n\tht.EnsureConnected(alice, bob)\n\tht.Run(\"encumbered macaroon intercept\", func(tt *testing.T) {\n\t\tregistration := registerMiddleware(\n\t\t\ttt, alice, &lnrpc.MiddlewareRegistration{\n\t\t\t\tMiddlewareName:           \"itest-interceptor-2\",\n\t\t\t\tCustomMacaroonCaveatName: \"itest-caveat\",\n\t\t\t}, true,\n\t\t)\n\t\tdefer registration.cancel()\n\n\t\tmiddlewareInterceptionTest(\n\t\t\ttt, alice, bob, registration,\n\t\t\tcustomCaveatReadonlyMac, readonlyMac, false,\n\t\t)\n\t})\n\n\t// Next, run the response manipulation tests.\n\t//\n\t// NOTE: we may get an error here saying \"interceptor RPC client quit\"\n\t// as it takes some time for the interceptor to fully quit. Thus we\n\t// restart the node here to make sure the old interceptor is removed\n\t// from registration.\n\tht.RestartNode(alice)\n\tht.EnsureConnected(alice, bob)\n\tht.Run(\"read-only not allowed to manipulate\", func(tt *testing.T) {\n\t\tregistration := registerMiddleware(\n\t\t\ttt, alice, &lnrpc.MiddlewareRegistration{\n\t\t\t\tMiddlewareName: \"itest-interceptor-3\",\n\t\t\t\tReadOnlyMode:   true,\n\t\t\t}, true,\n\t\t)\n\t\tdefer registration.cancel()\n\n\t\tmiddlewareRequestManipulationTest(\n\t\t\ttt, alice, registration, adminMac, true,\n\t\t)\n\t\tmiddlewareResponseManipulationTest(\n\t\t\ttt, alice, bob, registration, readonlyMac, true,\n\t\t)\n\t})\n\n\t// NOTE: we may get an error here saying \"interceptor RPC client quit\"\n\t// as it takes some time for the interceptor to fully quit. Thus we\n\t// restart the node here to make sure the old interceptor is removed\n\t// from registration.\n\tht.RestartNode(alice)\n\tht.EnsureConnected(alice, bob)\n\tht.Run(\"encumbered macaroon manipulate\", func(tt *testing.T) {\n\t\tregistration := registerMiddleware(\n\t\t\ttt, alice, &lnrpc.MiddlewareRegistration{\n\t\t\t\tMiddlewareName:           \"itest-interceptor-4\",\n\t\t\t\tCustomMacaroonCaveatName: \"itest-caveat\",\n\t\t\t}, true,\n\t\t)\n\t\tdefer registration.cancel()\n\n\t\tmiddlewareRequestManipulationTest(\n\t\t\ttt, alice, registration, customCaveatAdminMac, false,\n\t\t)\n\t\tmiddlewareResponseManipulationTest(\n\t\t\ttt, alice, bob, registration,\n\t\t\tcustomCaveatReadonlyMac, false,\n\t\t)\n\t})\n\n\t// And finally make sure mandatory middleware is always checked for any\n\t// RPC request.\n\tht.Run(\"mandatory middleware\", func(tt *testing.T) {\n\t\tst := ht.Subtest(tt)\n\t\tmiddlewareMandatoryTest(st, alice)\n\t})\n}\n\n// middlewareRegistrationRestrictionTests tests all restrictions that apply to\n// registering a middleware.",
      "length": 4570,
      "tokens": 521,
      "embedding": []
    },
    {
      "slug": "func middlewareRegistrationRestrictionTests(t *testing.T,",
      "content": "func middlewareRegistrationRestrictionTests(t *testing.T,\n\tnode *node.HarnessNode) {\n\n\ttestCases := []struct {\n\t\tregistration *lnrpc.MiddlewareRegistration\n\t\texpectedErr  string\n\t}{{\n\t\tregistration: &lnrpc.MiddlewareRegistration{\n\t\t\tMiddlewareName: \"foo\",\n\t\t},\n\t\texpectedErr: \"invalid middleware name\",\n\t}, {\n\t\tregistration: &lnrpc.MiddlewareRegistration{\n\t\t\tMiddlewareName:           \"itest-interceptor\",\n\t\t\tCustomMacaroonCaveatName: \"foo\",\n\t\t},\n\t\texpectedErr: \"custom caveat name of at least\",\n\t}, {\n\t\tregistration: &lnrpc.MiddlewareRegistration{\n\t\t\tMiddlewareName:           \"itest-interceptor\",\n\t\t\tCustomMacaroonCaveatName: \"itest-caveat\",\n\t\t\tReadOnlyMode:             true,\n\t\t},\n\t\texpectedErr: \"cannot set read-only and custom caveat name\",\n\t}}\n\n\tfor idx, tc := range testCases {\n\t\ttc := tc\n\n\t\tt.Run(fmt.Sprintf(\"%d\", idx), func(tt *testing.T) {\n\t\t\tinvalidName := registerMiddleware(\n\t\t\t\ttt, node, tc.registration, false,\n\t\t\t)\n\t\t\t_, err := invalidName.stream.Recv()\n\t\t\trequire.Error(tt, err)\n\t\t\trequire.Contains(tt, err.Error(), tc.expectedErr)\n\n\t\t\tinvalidName.cancel()\n\t\t})\n\t}\n}\n\n// middlewareInterceptionTest tests that unary and streaming requests can be\n// intercepted. It also makes sure that depending on the mode (read-only or\n// custom macaroon caveat) a middleware only gets access to the requests it\n// should be allowed access to.",
      "length": 1244,
      "tokens": 135,
      "embedding": []
    },
    {
      "slug": "func middlewareInterceptionTest(t *testing.T,",
      "content": "func middlewareInterceptionTest(t *testing.T,\n\tnode, peer *node.HarnessNode, registration *middlewareHarness,\n\tuserMac *macaroon.Macaroon,\n\tdisallowedMac *macaroon.Macaroon, readOnly bool) {\n\n\tt.Helper()\n\n\t// Everything we test here should be executed in a matter of\n\t// milliseconds, so we can use one single timeout context for all calls.\n\tctxb := context.Background()\n\tctxc, cancel := context.WithTimeout(ctxb, defaultTimeout)\n\tdefer cancel()\n\n\t// Create a client connection that we'll use to simulate user requests\n\t// to lnd with.\n\tcleanup, client := macaroonClient(t, node, userMac)\n\tdefer cleanup()\n\n\t// We're going to send a simple RPC request to list all channels.\n\t// We need to invoke the intercept logic in a goroutine because we'd\n\t// block the execution of the main task otherwise.\n\treq := &lnrpc.ListChannelsRequest{ActiveOnly: true}\n\tgo registration.interceptUnary(\n\t\t\"/lnrpc.Lightning/ListChannels\", req, nil, readOnly, false,\n\t)\n\n\t// Do the actual call now and wait for the interceptor to do its thing.\n\tresp, err := client.ListChannels(ctxc, req)\n\trequire.NoError(t, err)\n\n\t// Did we receive the correct intercept message?\n\tassertInterceptedType(t, resp, <-registration.responsesChan)\n\n\t// Also try the interception of a request that is expected to result in\n\t// an error being returned from lnd.\n\texpectedErr := \"either `active_only` or `inactive_only` can be set\"\n\tinvalidReq := &lnrpc.ListChannelsRequest{\n\t\tActiveOnly:   true,\n\t\tInactiveOnly: true,\n\t}\n\tgo registration.interceptUnary(\n\t\t\"/lnrpc.Lightning/ListChannels\", invalidReq, nil, readOnly,\n\t\tfalse,\n\t)\n\n\t// Do the actual call now and wait for the interceptor to do its thing.\n\t_, err = client.ListChannels(ctxc, invalidReq)\n\trequire.Error(t, err)\n\trequire.Contains(t, err.Error(), expectedErr)\n\n\t// Did we receive the correct intercept message with the error?\n\tassertInterceptedErr(t, expectedErr, <-registration.responsesChan)\n\n\t// Let's test the same for a streaming endpoint.\n\treq2 := &lnrpc.PeerEventSubscription{}\n\tgo registration.interceptStream(\n\t\t\"/lnrpc.Lightning/SubscribePeerEvents\", req2, nil, readOnly,\n\t)\n\n\t// Do the actual call now and wait for the interceptor to do its thing.\n\tpeerCtx, peerCancel := context.WithCancel(ctxb)\n\tresp2, err := client.SubscribePeerEvents(peerCtx, req2)\n\trequire.NoError(t, err)\n\n\t// Disconnect Bob to trigger a peer event without using Alice's RPC\n\t// interface itself.\n\tpeer.RPC.DisconnectPeer(node.PubKeyStr)\n\tpeerEvent, err := resp2.Recv()\n\trequire.NoError(t, err)\n\trequire.Equal(t, lnrpc.PeerEvent_PEER_OFFLINE, peerEvent.GetType())\n\n\t// Stop the peer stream again, otherwise we'll produce more events.\n\tpeerCancel()\n\n\t// Did we receive the correct intercept message?\n\tassertInterceptedType(t, peerEvent, <-registration.responsesChan)\n\n\t// Make sure that with the other macaroon we aren't allowed to access\n\t// the interceptor. If we registered for read-only access then there is\n\t// no middleware that handles the custom macaroon caveat. If we\n\t// registered for a custom caveat then there is no middleware that\n\t// handles unencumbered read-only access.\n\tcleanup, client = macaroonClient(t, node, disallowedMac)\n\tdefer cleanup()\n\n\t// We need to make sure we don't get any interception messages for\n\t// requests made with the disallowed macaroon.\n\tvar (\n\t\terrChan = make(chan error, 1)\n\t\tmsgChan = make(chan *lnrpc.RPCMiddlewareRequest, 1)\n\t)\n\tgo func() {\n\t\treq, err := registration.stream.Recv()\n\t\tif err != nil {\n\t\t\terrChan <- err\n\t\t\treturn\n\t\t}\n\n\t\tmsgChan <- req\n\t}()\n\n\t// Let's invoke the same request again but with the other macaroon.\n\tresp, err = client.ListChannels(ctxc, req)\n\n\t// Depending on what mode we're in, we expect something different. If we\n\t// are in read-only mode then an encumbered macaroon cannot be used\n\t// since there is no middleware registered for it. If we registered for\n\t// a custom macaroon caveat and a request with anon-encumbered macaroon\n\t// comes in, we expect to just not get any intercept messages.\n\tif readOnly {\n\t\trequire.Error(t, err)\n\t\trequire.Contains(\n\t\t\tt, err.Error(), \"cannot accept macaroon with custom \"+\n\t\t\t\t\"caveat 'itest-caveat', no middleware \"+\n\t\t\t\t\"registered\",\n\t\t)\n\t} else {\n\t\trequire.NoError(t, err)\n\n\t\t// We disconnected Bob so there should be no active channels.\n\t\trequire.Len(t, resp.Channels, 0)\n\t}\n\n\t// There should be neither an error nor any interception messages in the\n\t// channels.\n\tselect {\n\tcase err := <-errChan:\n\t\tt.Fatalf(\"Unexpected error, not expecting messages: %v\", err)\n\n\tcase msg := <-msgChan:\n\t\tt.Fatalf(\"Unexpected intercept message: %v\", msg)\n\n\tcase <-time.After(time.Second):\n\t\t// Nothing came in for a second, we're fine.\n\t}\n}\n\n// middlewareResponseManipulationTest tests that unary and streaming responses\n// can be intercepted and also manipulated, at least if the middleware didn't\n// register for read-only access.",
      "length": 4649,
      "tokens": 640,
      "embedding": []
    },
    {
      "slug": "func middlewareResponseManipulationTest(t *testing.T,",
      "content": "func middlewareResponseManipulationTest(t *testing.T,\n\tnode, peer *node.HarnessNode, registration *middlewareHarness,\n\tuserMac *macaroon.Macaroon, readOnly bool) {\n\n\tt.Helper()\n\n\t// Everything we test here should be executed in a matter of\n\t// milliseconds, so we can use one single timeout context for all calls.\n\tctxb := context.Background()\n\tctxc, cancel := context.WithTimeout(ctxb, defaultTimeout)\n\tdefer cancel()\n\n\t// Create a client connection that we'll use to simulate user requests\n\t// to lnd with.\n\tcleanup, client := macaroonClient(t, node, userMac)\n\tdefer cleanup()\n\n\t// We're going to attempt to replace the response with our own. But\n\t// since we only registered for read-only access, our replacement should\n\t// just be ignored.\n\treplacementResponse := &lnrpc.ListChannelsResponse{\n\t\tChannels: []*lnrpc.Channel{{\n\t\t\tChannelPoint: \"f000:0\",\n\t\t}, {\n\t\t\tChannelPoint: \"f000:1\",\n\t\t}},\n\t}\n\n\t// We're going to send a simple RPC request to list all channels.\n\t// We need to invoke the intercept logic in a goroutine because we'd\n\t// block the execution of the main task otherwise.\n\treq := &lnrpc.ListChannelsRequest{ActiveOnly: true}\n\tgo registration.interceptUnary(\n\t\t\"/lnrpc.Lightning/ListChannels\", req, replacementResponse,\n\t\treadOnly, false,\n\t)\n\n\t// Do the actual call now and wait for the interceptor to do its thing.\n\tresp, err := client.ListChannels(ctxc, req)\n\trequire.NoError(t, err)\n\n\t// Did we get the manipulated response (2 fake channels) or the original\n\t// one (1 channel)?\n\tif readOnly {\n\t\trequire.Len(t, resp.Channels, 1)\n\t} else {\n\t\trequire.Len(t, resp.Channels, 2)\n\t}\n\n\t// Let's see if we can also replace an error message sent out by lnd\n\t// with a custom one.\n\tbetterError := fmt.Errorf(\"yo, this request is no good\")\n\tinvalidReq := &lnrpc.ListChannelsRequest{\n\t\tActiveOnly:   true,\n\t\tInactiveOnly: true,\n\t}\n\tgo registration.interceptUnary(\n\t\t\"/lnrpc.Lightning/ListChannels\", invalidReq, betterError,\n\t\treadOnly, false,\n\t)\n\n\t// Do the actual call now and wait for the interceptor to do its thing.\n\t_, err = client.ListChannels(ctxc, invalidReq)\n\trequire.Error(t, err)\n\n\t// Did we get the manipulated error or the original one?\n\tif readOnly {\n\t\trequire.Contains(\n\t\t\tt, err.Error(), \"either `active_only` or \"+\n\t\t\t\t\"`inactive_only` can be set\",\n\t\t)\n\t} else {\n\t\trequire.Contains(t, err.Error(), betterError.Error())\n\t}\n\n\t// Let's test the same for a streaming endpoint.\n\treplacementResponse2 := &lnrpc.PeerEvent{\n\t\tType:   lnrpc.PeerEvent_PEER_ONLINE,\n\t\tPubKey: \"foo\",\n\t}\n\treq2 := &lnrpc.PeerEventSubscription{}\n\tgo registration.interceptStream(\n\t\t\"/lnrpc.Lightning/SubscribePeerEvents\", req2,\n\t\treplacementResponse2, readOnly,\n\t)\n\n\t// Do the actual call now and wait for the interceptor to do its thing.\n\tpeerCtx, peerCancel := context.WithCancel(ctxb)\n\tresp2, err := client.SubscribePeerEvents(peerCtx, req2)\n\trequire.NoError(t, err)\n\n\t// Disconnect Bob to trigger a peer event without using Alice's RPC\n\t// interface itself.\n\tpeer.RPC.DisconnectPeer(node.PubKeyStr)\n\tpeerEvent, err := resp2.Recv()\n\trequire.NoError(t, err)\n\n\t// Did we get the correct, original response?\n\tif readOnly {\n\t\trequire.Equal(\n\t\t\tt, lnrpc.PeerEvent_PEER_OFFLINE, peerEvent.GetType(),\n\t\t)\n\t\trequire.Equal(t, peer.PubKeyStr, peerEvent.PubKey)\n\t} else {\n\t\trequire.Equal(\n\t\t\tt, lnrpc.PeerEvent_PEER_ONLINE, peerEvent.GetType(),\n\t\t)\n\t\trequire.Equal(t, \"foo\", peerEvent.PubKey)\n\t}\n\n\t// Stop the peer stream again, otherwise we'll produce more events.\n\tpeerCancel()\n}\n\n// middlewareRequestManipulationTest tests that unary and streaming requests\n// can be intercepted and also manipulated, at least if the middleware didn't\n// register for read-only access.",
      "length": 3486,
      "tokens": 454,
      "embedding": []
    },
    {
      "slug": "func middlewareRequestManipulationTest(t *testing.T, node *node.HarnessNode,",
      "content": "func middlewareRequestManipulationTest(t *testing.T, node *node.HarnessNode,\n\tregistration *middlewareHarness, userMac *macaroon.Macaroon,\n\treadOnly bool) {\n\n\tt.Helper()\n\n\t// Everything we test here should be executed in a matter of\n\t// milliseconds, so we can use one single timeout context for all calls.\n\tctxb := context.Background()\n\tctxc, cancel := context.WithTimeout(ctxb, defaultTimeout)\n\tdefer cancel()\n\n\t// Create a client connection that we'll use to simulate user requests\n\t// to lnd with.\n\tcleanup, client := macaroonClient(t, node, userMac)\n\tdefer cleanup()\n\n\t// We're going to attempt to replace the request with our own. But since\n\t// we only registered for read-only access, our replacement should just\n\t// be ignored.\n\treplacementRequest := &lnrpc.Invoice{\n\t\tMemo: \"This is the replaced memo\",\n\t}\n\n\t// We're going to send a simple RPC request to add an invoice. We need\n\t// to invoke the intercept logic in a goroutine because we'd block the\n\t// execution of the main task otherwise.\n\treq := &lnrpc.Invoice{\n\t\tMemo:  \"Plz pay me\",\n\t\tValue: 123456,\n\t}\n\tgo registration.interceptUnary(\n\t\t\"/lnrpc.Lightning/AddInvoice\", req, replacementRequest,\n\t\treadOnly, true,\n\t)\n\n\t// Do the actual call now and wait for the interceptor to do its thing.\n\tresp, err := client.AddInvoice(ctxc, req)\n\trequire.NoError(t, err)\n\n\t// Did we get the manipulated response or the original one?\n\tinvoice, err := zpay32.Decode(resp.PaymentRequest, harnessNetParams)\n\trequire.NoError(t, err)\n\tif readOnly {\n\t\trequire.Equal(t, req.Memo, *invoice.Description)\n\t} else {\n\t\trequire.Equal(t, replacementRequest.Memo, *invoice.Description)\n\t}\n\n\t// Read the message from the registration, otherwise we cannot check the\n\t// next one.\n\t<-registration.responsesChan\n\n\t// Make sure we also get errors intercepted for stream events. We do\n\t// this in the request manipulation test because only here we have a\n\t// macaroon with sufficient permissions (admin macaroon) to attempt to\n\t// call a streaming RPC that actually accepts request parameters that we\n\t// can use to provoke an error message.\n\texpectedErr := \"channel is too small\"\n\tinvalidReq := &lnrpc.OpenChannelRequest{\n\t\tLocalFundingAmount: 5,\n\t}\n\tgo registration.interceptStream(\n\t\t\"/lnrpc.Lightning/OpenChannel\", invalidReq, nil, readOnly,\n\t)\n\n\t// Do the actual call now and wait for the interceptor to do its thing.\n\t// We don't receive the error on the RPC call directly, because that\n\t// only returns the stream. We have to attempt to read a response first\n\t// to get the expected error.\n\tresponseStream, err := client.OpenChannel(ctxc, invalidReq)\n\trequire.NoError(t, err)\n\n\t_, err = responseStream.Recv()\n\trequire.Error(t, err)\n\trequire.Contains(t, err.Error(), expectedErr)\n\n\tassertInterceptedErr(t, expectedErr, <-registration.responsesChan)\n}\n\n// middlewareMandatoryTest tests that all RPC requests are blocked if there is\n// a mandatory middleware declared that's currently not registered.",
      "length": 2777,
      "tokens": 391,
      "embedding": []
    },
    {
      "slug": "func middlewareMandatoryTest(ht *lntest.HarnessTest, node *node.HarnessNode) {",
      "content": "func middlewareMandatoryTest(ht *lntest.HarnessTest, node *node.HarnessNode) {\n\t// Let's declare our itest interceptor as mandatory but don't register\n\t// it just yet. That should cause all RPC requests to fail, except for\n\t// the registration itself.\n\tnode.Cfg.SkipUnlock = true\n\tht.RestartNodeWithExtraArgs(node, []string{\n\t\t\"--noseedbackup\", \"--rpcmiddleware.enable\",\n\t\t\"--rpcmiddleware.addmandatory=itest-interceptor\",\n\t})\n\n\t// The \"wait for node to start\" flag of the above restart does too much\n\t// and has a call to GetInfo built in, which will fail in this special\n\t// test case. So we need to do the wait and client setup manually here.\n\tconn, err := node.ConnectRPC()\n\trequire.NoError(ht, err)\n\tnode.Initialize(conn)\n\terr = node.WaitUntilServerActive()\n\trequire.NoError(ht, err)\n\n\tctxb := context.Background()\n\tctxc, cancel := context.WithTimeout(ctxb, defaultTimeout)\n\tdefer cancel()\n\n\t// Test a unary request first.\n\t_, err = node.RPC.LN.ListChannels(ctxc, &lnrpc.ListChannelsRequest{})\n\trequire.Contains(ht, err.Error(), \"middleware 'itest-interceptor' is \"+\n\t\t\"currently not registered\")\n\n\t// Then a streaming one.\n\tstream := node.RPC.SubscribeInvoices(&lnrpc.InvoiceSubscription{})\n\t_, err = stream.Recv()\n\trequire.Error(ht, err)\n\trequire.Contains(ht, err.Error(), \"middleware 'itest-interceptor' is \"+\n\t\t\"currently not registered\")\n\n\t// Now let's register the middleware and try again.\n\tregistration := registerMiddleware(\n\t\tht.T, node, &lnrpc.MiddlewareRegistration{\n\t\t\tMiddlewareName:           \"itest-interceptor\",\n\t\t\tCustomMacaroonCaveatName: \"itest-caveat\",\n\t\t}, true,\n\t)\n\tdefer registration.cancel()\n\n\t// Both the unary and streaming requests should now be allowed.\n\ttime.Sleep(500 * time.Millisecond)\n\tnode.RPC.ListChannels(&lnrpc.ListChannelsRequest{})\n\tnode.RPC.SubscribeInvoices(&lnrpc.InvoiceSubscription{})\n\n\t// We now shut down the node manually to prevent the test from failing\n\t// because we can't call the stop RPC if we unregister the middleware\n\t// in the defer statement above.\n\tht.KillNode(node)\n}\n\n// assertInterceptedType makes sure that the intercept message sent by the RPC\n// interceptor is correct for a proto message that was sent or received over the\n// RPC interface.",
      "length": 2077,
      "tokens": 253,
      "embedding": []
    },
    {
      "slug": "func assertInterceptedType(t *testing.T, rpcMessage proto.Message,",
      "content": "func assertInterceptedType(t *testing.T, rpcMessage proto.Message,\n\tinterceptMessage *lnrpc.RPCMessage) {\n\n\tt.Helper()\n\n\trequire.Equal(\n\t\tt, string(proto.MessageName(rpcMessage)),\n\t\tinterceptMessage.TypeName,\n\t)\n\trawRequest, err := proto.Marshal(rpcMessage)\n\trequire.NoError(t, err)\n\n\t// Make sure we don't trip over nil vs. empty slice in the equality\n\t// check below.\n\tif len(rawRequest) == 0 {\n\t\trawRequest = nil\n\t}\n\n\trequire.Equal(t, rawRequest, interceptMessage.Serialized)\n}\n\n// assertInterceptedErr makes sure that the intercept message sent by the RPC\n// interceptor contains an error message instead of a serialized proto message.",
      "length": 551,
      "tokens": 69,
      "embedding": []
    },
    {
      "slug": "func assertInterceptedErr(t *testing.T, errString string,",
      "content": "func assertInterceptedErr(t *testing.T, errString string,\n\tinterceptMessage *lnrpc.RPCMessage) {\n\n\tt.Helper()\n\n\trequire.Equal(t, \"error\", interceptMessage.TypeName)\n\trequire.True(t, interceptMessage.IsError)\n\n\trequire.Contains(t, string(interceptMessage.Serialized), errString)\n}\n\n// middlewareStream is a type alias to shorten the long definition.",
      "length": 280,
      "tokens": 24,
      "embedding": []
    },
    {
      "slug": "type middlewareStream lnrpc.Lightning_RegisterRPCMiddlewareClient",
      "content": "type middlewareStream lnrpc.Lightning_RegisterRPCMiddlewareClient\n\n// middlewareHarness is a test harness that holds one instance of a simulated\n// middleware.",
      "length": 91,
      "tokens": 15,
      "embedding": []
    },
    {
      "slug": "type middlewareHarness struct {",
      "content": "type middlewareHarness struct {\n\tt      *testing.T\n\tcancel func()\n\tstream middlewareStream\n\n\tresponsesChan chan *lnrpc.RPCMessage\n}\n\n// registerMiddleware creates a new middleware harness and sends the initial\n// register message to the RPC server.",
      "length": 208,
      "tokens": 28,
      "embedding": []
    },
    {
      "slug": "func registerMiddleware(t *testing.T, node *node.HarnessNode,",
      "content": "func registerMiddleware(t *testing.T, node *node.HarnessNode,\n\tregistration *lnrpc.MiddlewareRegistration,\n\twaitForRegister bool) *middlewareHarness {\n\n\tt.Helper()\n\n\tmiddlewareStream, cancel := node.RPC.RegisterRPCMiddleware()\n\n\terrChan := make(chan error)\n\tgo func() {\n\t\tmsg := &lnrpc.RPCMiddlewareResponse_Register{\n\t\t\tRegister: registration,\n\t\t}\n\t\terr := middlewareStream.Send(&lnrpc.RPCMiddlewareResponse{\n\t\t\tMiddlewareMessage: msg,\n\t\t})\n\n\t\terrChan <- err\n\t}()\n\n\tselect {\n\tcase <-time.After(defaultTimeout):\n\t\trequire.Fail(t, \"registerMiddleware send timeout\")\n\tcase err := <-errChan:\n\t\trequire.NoError(t, err, \"registerMiddleware send failed\")\n\t}\n\n\tmh := &middlewareHarness{\n\t\tt:             t,\n\t\tcancel:        cancel,\n\t\tstream:        middlewareStream,\n\t\tresponsesChan: make(chan *lnrpc.RPCMessage),\n\t}\n\n\tif !waitForRegister {\n\t\treturn mh\n\t}\n\n\t// Wait for the registration complete message.\n\tmsg := make(chan *lnrpc.RPCMiddlewareRequest)\n\tgo func() {\n\t\tregCompleteMsg, err := middlewareStream.Recv()\n\t\trequire.NoError(t, err, \"registerMiddleware recv failed\")\n\n\t\tmsg <- regCompleteMsg\n\t}()\n\n\tselect {\n\tcase <-time.After(defaultTimeout):\n\t\trequire.Fail(t, \"registerMiddleware recv timeout\")\n\n\tcase m := <-msg:\n\t\trequire.True(t, m.GetRegComplete())\n\t}\n\n\treturn mh\n}\n\n// interceptUnary intercepts a unary call, optionally requesting to replace the\n// response sent to the client. A unary call is expected to receive one\n// intercept message for the request and one for the response.\n//\n// NOTE: Must be called in a goroutine as this will block until the response is\n// read from the response channel.",
      "length": 1480,
      "tokens": 175,
      "embedding": []
    },
    {
      "slug": "func (h *middlewareHarness) interceptUnary(methodURI string,",
      "content": "func (h *middlewareHarness) interceptUnary(methodURI string,\n\texpectedRequest proto.Message, responseReplacement interface{},\n\treadOnly bool, replaceRequest bool) {\n\n\t// Read intercept message and make sure it's for an RPC request.\n\treqIntercept, err := h.stream.Recv()\n\trequire.NoError(h.t, err)\n\n\t// Make sure the custom condition is populated correctly (if we're using\n\t// a macaroon with a custom condition).\n\tif !readOnly {\n\t\trequire.Equal(\n\t\t\th.t, \"itest-value\", reqIntercept.CustomCaveatCondition,\n\t\t)\n\t}\n\n\treq := reqIntercept.GetRequest()\n\trequire.NotNil(h.t, req)\n\n\t// We know the request we're going to send so make sure we get the right\n\t// type and content from the interceptor.\n\trequire.Equal(h.t, methodURI, req.MethodFullUri)\n\tassertInterceptedType(h.t, expectedRequest, req)\n\n\t// We need to accept the request.\n\tif replaceRequest {\n\t\th.sendAccept(reqIntercept.MsgId, responseReplacement)\n\t} else {\n\t\th.sendAccept(reqIntercept.MsgId, nil)\n\t}\n\n\t// Now read the intercept message for the response.\n\trespIntercept, err := h.stream.Recv()\n\trequire.NoError(h.t, err)\n\tres := respIntercept.GetResponse()\n\trequire.NotNil(h.t, res)\n\n\t// We expect the request ID to be the same for the request intercept\n\t// and the response intercept messages. But the message IDs must be\n\t// different/unique.\n\trequire.Equal(h.t, reqIntercept.RequestId, respIntercept.RequestId)\n\trequire.NotEqual(h.t, reqIntercept.MsgId, respIntercept.MsgId)\n\n\t// We need to accept the response as well.\n\tif replaceRequest {\n\t\th.sendAccept(respIntercept.MsgId, nil)\n\t} else {\n\t\th.sendAccept(respIntercept.MsgId, responseReplacement)\n\t}\n\n\th.responsesChan <- res\n}\n\n// interceptStream intercepts a streaming call, optionally requesting to replace\n// the (first) response sent to the client. A streaming call is expected to\n// receive one intercept message for the stream authentication, one for the\n// first request and one for the first response.\n//\n// NOTE: Must be called in a goroutine as this will block until the first\n// response is read from the response channel.",
      "length": 1925,
      "tokens": 254,
      "embedding": []
    },
    {
      "slug": "func (h *middlewareHarness) interceptStream(methodURI string,",
      "content": "func (h *middlewareHarness) interceptStream(methodURI string,\n\texpectedRequest proto.Message, responseReplacement proto.Message,\n\treadOnly bool) {\n\n\t// Read intercept message and make sure it's for an RPC stream auth.\n\tauthIntercept, err := h.stream.Recv()\n\trequire.NoError(h.t, err)\n\n\t// Make sure the custom condition is populated correctly (if we're using\n\t// a macaroon with a custom condition).\n\tif !readOnly {\n\t\trequire.Equal(\n\t\t\th.t, \"itest-value\", authIntercept.CustomCaveatCondition,\n\t\t)\n\t}\n\n\tauth := authIntercept.GetStreamAuth()\n\trequire.NotNil(h.t, auth)\n\n\t// This is just the authentication, so we can only look at the URI.\n\trequire.Equal(h.t, methodURI, auth.MethodFullUri)\n\n\t// We need to accept the auth.\n\th.sendAccept(authIntercept.MsgId, nil)\n\n\t// Read intercept message and make sure it's for an RPC request.\n\treqIntercept, err := h.stream.Recv()\n\trequire.NoError(h.t, err)\n\treq := reqIntercept.GetRequest()\n\trequire.NotNil(h.t, req)\n\n\t// We know the request we're going to send so make sure we get the right\n\t// type and content from the interceptor.\n\trequire.Equal(h.t, methodURI, req.MethodFullUri)\n\tassertInterceptedType(h.t, expectedRequest, req)\n\n\t// We need to accept the request.\n\th.sendAccept(reqIntercept.MsgId, nil)\n\n\t// Now read the intercept message for the response.\n\trespIntercept, err := h.stream.Recv()\n\trequire.NoError(h.t, err)\n\tres := respIntercept.GetResponse()\n\trequire.NotNil(h.t, res)\n\n\t// We expect the request ID to be the same for the auth intercept,\n\t// request intercept and the response intercept messages. But the\n\t// message IDs must be different/unique.\n\trequire.Equal(h.t, authIntercept.RequestId, respIntercept.RequestId)\n\trequire.Equal(h.t, reqIntercept.RequestId, respIntercept.RequestId)\n\trequire.NotEqual(h.t, authIntercept.MsgId, reqIntercept.MsgId)\n\trequire.NotEqual(h.t, authIntercept.MsgId, respIntercept.MsgId)\n\trequire.NotEqual(h.t, reqIntercept.MsgId, respIntercept.MsgId)\n\n\t// We need to accept the response as well.\n\th.sendAccept(respIntercept.MsgId, responseReplacement)\n\n\th.responsesChan <- res\n}\n\n// sendAccept sends an accept feedback to the RPC server.",
      "length": 2003,
      "tokens": 236,
      "embedding": []
    },
    {
      "slug": "func (h *middlewareHarness) sendAccept(msgID uint64,",
      "content": "func (h *middlewareHarness) sendAccept(msgID uint64,\n\tresponseReplacement interface{}) {\n\n\tvar replacementBytes []byte\n\tif responseReplacement != nil {\n\t\tvar err error\n\n\t\tswitch t := responseReplacement.(type) {\n\t\tcase proto.Message:\n\t\t\treplacementBytes, err = proto.Marshal(t)\n\t\t\trequire.NoError(h.t, err)\n\n\t\tcase error:\n\t\t\treplacementBytes = []byte(t.Error())\n\n\t\tdefault:\n\t\t\trequire.Fail(h.t, \"invalid replacement type\")\n\t\t}\n\t}\n\n\terr := h.stream.Send(&lnrpc.RPCMiddlewareResponse{\n\t\tMiddlewareMessage: &lnrpc.RPCMiddlewareResponse_Feedback{\n\t\t\tFeedback: &lnrpc.InterceptFeedback{\n\t\t\t\tReplaceResponse:       len(replacementBytes) > 0,\n\t\t\t\tReplacementSerialized: replacementBytes,\n\t\t\t},\n\t\t},\n\t\tRefMsgId: msgID,\n\t})\n\trequire.NoError(h.t, err)\n}\n",
      "length": 661,
      "tokens": 60,
      "embedding": []
    }
  ]
}