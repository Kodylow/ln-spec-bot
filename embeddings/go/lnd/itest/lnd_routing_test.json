{
  "filepath": "../implementations/go/lnd/itest/lnd_routing_test.go",
  "package": "itest",
  "sections": [
    {
      "slug": "type singleHopSendToRouteCase struct {",
      "content": "type singleHopSendToRouteCase struct {\n\tname string\n\n\t// streaming tests streaming SendToRoute if true, otherwise tests\n\t// synchronous SenToRoute.\n\tstreaming bool\n\n\t// routerrpc submits the request to the routerrpc subserver if true,\n\t// otherwise submits to the main rpc server.\n\trouterrpc bool\n}\n\nvar singleHopSendToRouteCases = []singleHopSendToRouteCase{\n\t{\n\t\tname: \"regular main sync\",\n\t},\n\t{\n\t\tname:      \"regular main stream\",\n\t\tstreaming: true,\n\t},\n\t{\n\t\tname:      \"regular routerrpc sync\",\n\t\trouterrpc: true,\n\t},\n\t{\n\t\tname: \"mpp main sync\",\n\t},\n\t{\n\t\tname:      \"mpp main stream\",\n\t\tstreaming: true,\n\t},\n\t{\n\t\tname:      \"mpp routerrpc sync\",\n\t\trouterrpc: true,\n\t},\n}\n\n// testSingleHopSendToRoute tests that payments are properly processed through a\n// provided route with a single hop. We'll create the following network\n// topology:\n//\n//\tCarol --100k--> Dave\n//\n// We'll query the daemon for routes from Carol to Dave and then send payments\n// by feeding the route back into the various SendToRoute RPC methods. Here we\n// test all three SendToRoute endpoints, forcing each to perform both a regular\n// payment and an MPP payment.",
      "length": 1057,
      "tokens": 165,
      "embedding": []
    },
    {
      "slug": "func testSingleHopSendToRoute(ht *lntest.HarnessTest) {",
      "content": "func testSingleHopSendToRoute(ht *lntest.HarnessTest) {\n\tfor _, test := range singleHopSendToRouteCases {\n\t\ttest := test\n\n\t\tht.Run(test.name, func(t1 *testing.T) {\n\t\t\tst := ht.Subtest(t1)\n\t\t\ttestSingleHopSendToRouteCase(st, test)\n\t\t})\n\t}\n}\n",
      "length": 175,
      "tokens": 22,
      "embedding": []
    },
    {
      "slug": "func testSingleHopSendToRouteCase(ht *lntest.HarnessTest,",
      "content": "func testSingleHopSendToRouteCase(ht *lntest.HarnessTest,\n\ttest singleHopSendToRouteCase) {\n\n\tconst chanAmt = btcutil.Amount(100000)\n\tconst paymentAmtSat = 1000\n\tconst numPayments = 5\n\tconst amountPaid = int64(numPayments * paymentAmtSat)\n\n\t// Create Carol and Dave, then establish a channel between them. Carol\n\t// is the sole funder of the channel with 100k satoshis. The network\n\t// topology should look like:\n\t// Carol -> 100k -> Dave\n\tcarol := ht.NewNode(\"Carol\", nil)\n\tdave := ht.NewNode(\"Dave\", nil)\n\n\tht.ConnectNodes(carol, dave)\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, carol)\n\n\t// Open a channel with 100k satoshis between Carol and Dave with Carol\n\t// being the sole funder of the channel.\n\tchanPointCarol := ht.OpenChannel(\n\t\tcarol, dave, lntest.OpenChannelParams{Amt: chanAmt},\n\t)\n\tdefer ht.CloseChannel(carol, chanPointCarol)\n\n\t// Create invoices for Dave, which expect a payment from Carol.\n\tpayReqs, rHashes, _ := ht.CreatePayReqs(\n\t\tdave, paymentAmtSat, numPayments,\n\t)\n\n\t// Reconstruct payment addresses.\n\tvar payAddrs [][]byte\n\tfor _, payReq := range payReqs {\n\t\tresp := dave.RPC.DecodePayReq(payReq)\n\t\tpayAddrs = append(payAddrs, resp.PaymentAddr)\n\t}\n\n\t// Assert Carol and Dave are synced to the chain before proceeding, to\n\t// ensure the queried route will have a valid final CLTV once the HTLC\n\t// reaches Dave.\n\t_, minerHeight := ht.Miner.GetBestBlock()\n\tht.WaitForNodeBlockHeight(carol, minerHeight)\n\tht.WaitForNodeBlockHeight(dave, minerHeight)\n\n\t// Query for routes to pay from Carol to Dave using the default CLTV\n\t// config.\n\troutesReq := &lnrpc.QueryRoutesRequest{\n\t\tPubKey: dave.PubKeyStr,\n\t\tAmt:    paymentAmtSat,\n\t}\n\troutes := carol.RPC.QueryRoutes(routesReq)\n\n\t// There should only be one route to try, so take the first item.\n\tr := routes.Routes[0]\n\n\t// Construct a closure that will set MPP fields on the route, which\n\t// allows us to test MPP payments.\n\tsetMPPFields := func(i int) {\n\t\thop := r.Hops[len(r.Hops)-1]\n\t\thop.TlvPayload = true\n\t\thop.MppRecord = &lnrpc.MPPRecord{\n\t\t\tPaymentAddr:  payAddrs[i],\n\t\t\tTotalAmtMsat: paymentAmtSat * 1000,\n\t\t}\n\t}\n\n\t// Construct closures for each of the payment types covered:\n\t//  - main rpc server sync\n\t//  - main rpc server streaming\n\t//  - routerrpc server sync\n\tsendToRouteSync := func() {\n\t\tfor i, rHash := range rHashes {\n\t\t\tsetMPPFields(i)\n\n\t\t\tsendReq := &lnrpc.SendToRouteRequest{\n\t\t\t\tPaymentHash: rHash,\n\t\t\t\tRoute:       r,\n\t\t\t}\n\t\t\tresp := carol.RPC.SendToRouteSync(sendReq)\n\t\t\trequire.Emptyf(ht, resp.PaymentError,\n\t\t\t\t\"received payment error from %s: %v\",\n\t\t\t\tcarol.Name(), resp.PaymentError)\n\t\t}\n\t}\n\tsendToRouteStream := func() {\n\t\talicePayStream := carol.RPC.SendToRoute()\n\n\t\tfor i, rHash := range rHashes {\n\t\t\tsetMPPFields(i)\n\n\t\t\tsendReq := &lnrpc.SendToRouteRequest{\n\t\t\t\tPaymentHash: rHash,\n\t\t\t\tRoute:       routes.Routes[0],\n\t\t\t}\n\t\t\terr := alicePayStream.Send(sendReq)\n\t\t\trequire.NoError(ht, err, \"unable to send payment\")\n\n\t\t\tresp, err := ht.ReceiveSendToRouteUpdate(alicePayStream)\n\t\t\trequire.NoError(ht, err, \"unable to receive stream\")\n\t\t\trequire.Emptyf(ht, resp.PaymentError,\n\t\t\t\t\"received payment error from %s: %v\",\n\t\t\t\tcarol.Name(), resp.PaymentError)\n\t\t}\n\t}\n\tsendToRouteRouterRPC := func() {\n\t\tfor i, rHash := range rHashes {\n\t\t\tsetMPPFields(i)\n\n\t\t\tsendReq := &routerrpc.SendToRouteRequest{\n\t\t\t\tPaymentHash: rHash,\n\t\t\t\tRoute:       r,\n\t\t\t}\n\t\t\tresp := carol.RPC.SendToRouteV2(sendReq)\n\t\t\trequire.Nilf(ht, resp.Failure, \"received payment \"+\n\t\t\t\t\"error from %s\", carol.Name())\n\t\t}\n\t}\n\n\t// Using Carol as the node as the source, send the payments\n\t// synchronously via the routerrpc's SendToRoute, or via the main RPC\n\t// server's SendToRoute streaming or sync calls.\n\tswitch {\n\tcase !test.routerrpc && test.streaming:\n\t\tsendToRouteStream()\n\tcase !test.routerrpc && !test.streaming:\n\t\tsendToRouteSync()\n\tcase test.routerrpc && !test.streaming:\n\t\tsendToRouteRouterRPC()\n\tdefault:\n\t\trequire.Fail(ht, \"routerrpc does not support \"+\n\t\t\t\"streaming send_to_route\")\n\t}\n\n\t// Verify that the payment's from Carol's PoV have the correct payment\n\t// hash and amount.\n\tpayments := ht.AssertNumPayments(carol, numPayments)\n\n\tfor i, p := range payments {\n\t\t// Assert that the payment hashes for each payment match up.\n\t\trHashHex := hex.EncodeToString(rHashes[i])\n\t\trequire.Equalf(ht, rHashHex, p.PaymentHash,\n\t\t\t\"incorrect payment hash for payment %d\", i)\n\n\t\t// Assert that each payment has no invoice since the payment\n\t\t// was completed using SendToRoute.\n\t\trequire.Emptyf(ht, p.PaymentRequest,\n\t\t\t\"incorrect payment request for payment: %d\", i)\n\n\t\t// Assert the payment amount is correct.\n\t\trequire.EqualValues(ht, paymentAmtSat, p.ValueSat,\n\t\t\t\"incorrect payment amt for payment %d, \", i)\n\n\t\t// Assert exactly one htlc was made.\n\t\trequire.Lenf(ht, p.Htlcs, 1,\n\t\t\t\"expected 1 htlc for payment %d\", i)\n\n\t\t// Assert the htlc's route is populated.\n\t\thtlc := p.Htlcs[0]\n\t\trequire.NotNilf(ht, htlc.Route,\n\t\t\t\"expected route for payment %d\", i)\n\n\t\t// Assert the hop has exactly one hop.\n\t\trequire.Lenf(ht, htlc.Route.Hops, 1,\n\t\t\t\"expected 1 hop for payment %d\", i)\n\n\t\t// If this is an MPP test, assert the MPP record's fields are\n\t\t// properly populated. Otherwise the hop should not have an MPP\n\t\t// record.\n\t\thop := htlc.Route.Hops[0]\n\t\trequire.NotNilf(ht, hop.MppRecord,\n\t\t\t\"expected mpp record for mpp payment %d\", i)\n\n\t\trequire.EqualValues(ht, paymentAmtSat*1000,\n\t\t\thop.MppRecord.TotalAmtMsat,\n\t\t\t\"incorrect mpp total msat for payment %d\", i)\n\n\t\texpAddr := payAddrs[i]\n\t\trequire.Equal(ht, expAddr, hop.MppRecord.PaymentAddr,\n\t\t\t\"incorrect mpp payment addr for payment %d \", i)\n\t}\n\n\t// Verify that the invoices's from Dave's PoV have the correct payment\n\t// hash and amount.\n\tinvoices := ht.AssertNumInvoices(dave, numPayments)\n\n\tfor i, inv := range invoices {\n\t\t// Assert that the payment hashes match up.\n\t\trequire.Equal(ht, rHashes[i], inv.RHash,\n\t\t\t\"incorrect payment hash for invoice %d\", i)\n\n\t\t// Assert that the amount paid to the invoice is correct.\n\t\trequire.EqualValues(ht, paymentAmtSat, inv.AmtPaidSat,\n\t\t\t\"incorrect payment amt for invoice %d, \", i)\n\t}\n\n\t// At this point all the channels within our proto network should be\n\t// shifted by 5k satoshis in the direction of Dave, the sink within the\n\t// payment flow generated above. The order of asserts corresponds to\n\t// increasing of time is needed to embed the HTLC in commitment\n\t// transaction, in channel Carol->Dave, order is Dave and then Carol.\n\tht.AssertAmountPaid(\"Carol(local) => Dave(remote)\", dave,\n\t\tchanPointCarol, int64(0), amountPaid)\n\tht.AssertAmountPaid(\"Carol(local) => Dave(remote)\", carol,\n\t\tchanPointCarol, amountPaid, int64(0))\n}\n\n// testMultiHopSendToRoute tests that payments are properly processed\n// through a provided route. We'll create the following network topology:\n//\n//\tAlice --100k--> Bob --100k--> Carol\n//\n// We'll query the daemon for routes from Alice to Carol and then\n// send payments through the routes.",
      "length": 6624,
      "tokens": 877,
      "embedding": []
    },
    {
      "slug": "func testMultiHopSendToRoute(ht *lntest.HarnessTest) {",
      "content": "func testMultiHopSendToRoute(ht *lntest.HarnessTest) {\n\tht.Run(\"with cache\", func(tt *testing.T) {\n\t\tst := ht.Subtest(tt)\n\t\trunMultiHopSendToRoute(st, true)\n\t})\n\tif *dbBackendFlag == \"bbolt\" {\n\t\tht.Run(\"without cache\", func(tt *testing.T) {\n\t\t\tst := ht.Subtest(tt)\n\t\t\trunMultiHopSendToRoute(st, false)\n\t\t})\n\t}\n}\n\n// runMultiHopSendToRoute tests that payments are properly processed\n// through a provided route. We'll create the following network topology:\n//\n//\tAlice --100k--> Bob --100k--> Carol\n//\n// We'll query the daemon for routes from Alice to Carol and then\n// send payments through the routes.",
      "length": 530,
      "tokens": 75,
      "embedding": []
    },
    {
      "slug": "func runMultiHopSendToRoute(ht *lntest.HarnessTest, useGraphCache bool) {",
      "content": "func runMultiHopSendToRoute(ht *lntest.HarnessTest, useGraphCache bool) {\n\tvar opts []string\n\tif !useGraphCache {\n\t\topts = append(opts, \"--db.no-graph-cache\")\n\t}\n\n\talice, bob := ht.Alice, ht.Bob\n\tht.RestartNodeWithExtraArgs(alice, opts)\n\n\tht.EnsureConnected(alice, bob)\n\n\tconst chanAmt = btcutil.Amount(100000)\n\n\t// Open a channel with 100k satoshis between Alice and Bob with Alice\n\t// being the sole funder of the channel.\n\tchanPointAlice := ht.OpenChannel(\n\t\talice, bob, lntest.OpenChannelParams{Amt: chanAmt},\n\t)\n\tdefer ht.CloseChannel(alice, chanPointAlice)\n\n\t// Create Carol and establish a channel from Bob. Bob is the sole\n\t// funder of the channel with 100k satoshis. The network topology\n\t// should look like:\n\t// Alice -> Bob -> Carol\n\tcarol := ht.NewNode(\"Carol\", nil)\n\tht.ConnectNodes(carol, bob)\n\n\tchanPointBob := ht.OpenChannel(\n\t\tbob, carol, lntest.OpenChannelParams{Amt: chanAmt},\n\t)\n\tdefer ht.CloseChannel(carol, chanPointBob)\n\n\t// Make sure Alice knows the channel between Bob and Carol.\n\tht.AssertTopologyChannelOpen(alice, chanPointBob)\n\n\t// Create 5 invoices for Carol, which expect a payment from Alice for\n\t// 1k satoshis with a different preimage each time.\n\tconst (\n\t\tnumPayments = 5\n\t\tpaymentAmt  = 1000\n\t)\n\t_, rHashes, invoices := ht.CreatePayReqs(carol, paymentAmt, numPayments)\n\n\t// Construct a route from Alice to Carol for each of the invoices\n\t// created above.  We set FinalCltvDelta to 40 since by default\n\t// QueryRoutes returns the last hop with a final cltv delta of 9 where\n\t// as the default in htlcswitch is 40.\n\troutesReq := &lnrpc.QueryRoutesRequest{\n\t\tPubKey:         carol.PubKeyStr,\n\t\tAmt:            paymentAmt,\n\t\tFinalCltvDelta: chainreg.DefaultBitcoinTimeLockDelta,\n\t}\n\troutes := alice.RPC.QueryRoutes(routesReq)\n\n\t// Using Alice as the source, pay to the 5 invoices from Carol created\n\t// above.\n\tfor i, rHash := range rHashes {\n\t\t// Manually set the MPP payload a new for each payment since\n\t\t// the payment addr will change with each invoice, although we\n\t\t// can re-use the route itself.\n\t\troute := routes.Routes[0]\n\t\troute.Hops[len(route.Hops)-1].TlvPayload = true\n\t\troute.Hops[len(route.Hops)-1].MppRecord = &lnrpc.MPPRecord{\n\t\t\tPaymentAddr: invoices[i].PaymentAddr,\n\t\t\tTotalAmtMsat: int64(\n\t\t\t\tlnwire.NewMSatFromSatoshis(paymentAmt),\n\t\t\t),\n\t\t}\n\n\t\tsendReq := &routerrpc.SendToRouteRequest{\n\t\t\tPaymentHash: rHash,\n\t\t\tRoute:       route,\n\t\t}\n\t\tresp := alice.RPC.SendToRouteV2(sendReq)\n\t\trequire.Nil(ht, resp.Failure, \"received payment error\")\n\t}\n\n\t// When asserting the amount of satoshis moved, we'll factor in the\n\t// default base fee, as we didn't modify the fee structure when\n\t// creating the seed nodes in the network.\n\tconst baseFee = 1\n\n\t// At this point all the channels within our proto network should be\n\t// shifted by 5k satoshis in the direction of Carol, the sink within\n\t// the payment flow generated above. The order of asserts corresponds\n\t// to increasing of time is needed to embed the HTLC in commitment\n\t// transaction, in channel Alice->Bob->Carol, order is Carol, Bob,\n\t// Alice.\n\tconst amountPaid = int64(5000)\n\tht.AssertAmountPaid(\"Bob(local) => Carol(remote)\", carol,\n\t\tchanPointBob, int64(0), amountPaid)\n\tht.AssertAmountPaid(\"Bob(local) => Carol(remote)\", bob,\n\t\tchanPointBob, amountPaid, int64(0))\n\tht.AssertAmountPaid(\"Alice(local) => Bob(remote)\", bob,\n\t\tchanPointAlice, int64(0), amountPaid+(baseFee*numPayments))\n\tht.AssertAmountPaid(\"Alice(local) => Bob(remote)\", alice,\n\t\tchanPointAlice, amountPaid+(baseFee*numPayments), int64(0))\n}\n\n// testSendToRouteErrorPropagation tests propagation of errors that occur\n// while processing a multi-hop payment through an unknown route.",
      "length": 3489,
      "tokens": 450,
      "embedding": []
    },
    {
      "slug": "func testSendToRouteErrorPropagation(ht *lntest.HarnessTest) {",
      "content": "func testSendToRouteErrorPropagation(ht *lntest.HarnessTest) {\n\tconst chanAmt = btcutil.Amount(100000)\n\n\t// Open a channel with 100k satoshis between Alice and Bob with Alice\n\t// being the sole funder of the channel.\n\talice, bob := ht.Alice, ht.Bob\n\tchanPointAlice := ht.OpenChannel(\n\t\talice, bob, lntest.OpenChannelParams{Amt: chanAmt},\n\t)\n\n\t// Create a new nodes (Carol and Charlie), load her with some funds,\n\t// then establish a connection between Carol and Charlie with a channel\n\t// that has identical capacity to the one created above.Then we will\n\t// get route via queryroutes call which will be fake route for Alice ->\n\t// Bob graph.\n\t//\n\t// The network topology should now look like:\n\t// Alice -> Bob; Carol -> Charlie.\n\tcarol := ht.NewNode(\"Carol\", nil)\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, carol)\n\n\tcharlie := ht.NewNode(\"Charlie\", nil)\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, charlie)\n\n\tht.ConnectNodes(carol, charlie)\n\tht.OpenChannel(carol, charlie, lntest.OpenChannelParams{Amt: chanAmt})\n\n\t// Query routes from Carol to Charlie which will be an invalid route\n\t// for Alice -> Bob.\n\tfakeReq := &lnrpc.QueryRoutesRequest{\n\t\tPubKey: charlie.PubKeyStr,\n\t\tAmt:    int64(1),\n\t}\n\tfakeRoute := carol.RPC.QueryRoutes(fakeReq)\n\n\t// Create 1 invoice for Bob, which expect a payment from Alice for 1k\n\t// satoshis.\n\tconst paymentAmt = 1000\n\n\tinvoice := &lnrpc.Invoice{\n\t\tMemo:  \"testing\",\n\t\tValue: paymentAmt,\n\t}\n\tresp := bob.RPC.AddInvoice(invoice)\n\trHash := resp.RHash\n\n\t// Using Alice as the source, pay to the invoice from Bob.\n\talicePayStream := alice.RPC.SendToRoute()\n\n\tsendReq := &lnrpc.SendToRouteRequest{\n\t\tPaymentHash: rHash,\n\t\tRoute:       fakeRoute.Routes[0],\n\t}\n\terr := alicePayStream.Send(sendReq)\n\trequire.NoError(ht, err, \"unable to send payment\")\n\n\t// At this place we should get an rpc error with notification\n\t// that edge is not found on hop(0)\n\tevent, err := ht.ReceiveSendToRouteUpdate(alicePayStream)\n\trequire.NoError(ht, err, \"payment stream has been closed but fake \"+\n\t\t\"route has consumed\")\n\trequire.Contains(ht, event.PaymentError, \"UnknownNextPeer\")\n\n\tht.CloseChannel(alice, chanPointAlice)\n}\n\n// testPrivateChannels tests that a private channel can be used for\n// routing by the two endpoints of the channel, but is not known by\n// the rest of the nodes in the graph.\n//\n//nolint:dupword",
      "length": 2195,
      "tokens": 300,
      "embedding": []
    },
    {
      "slug": "func testPrivateChannels(ht *lntest.HarnessTest) {",
      "content": "func testPrivateChannels(ht *lntest.HarnessTest) {\n\tconst chanAmt = btcutil.Amount(100000)\n\n\t// We create the following topology:\n\t//\n\t// Dave --100k--> Alice --200k--> Bob\n\t//  ^\t\t    ^\n\t//  |\t\t    |\n\t// 100k\t\t   100k\n\t//  |\t\t    |\n\t//  +---- Carol ----+\n\t//\n\t// where the 100k channel between Carol and Alice is private.\n\n\t// Open a channel with 200k satoshis between Alice and Bob.\n\talice, bob := ht.Alice, ht.Bob\n\tchanPointAlice := ht.OpenChannel(\n\t\talice, bob, lntest.OpenChannelParams{Amt: chanAmt * 2},\n\t)\n\n\t// Create Dave, and a channel to Alice of 100k.\n\tdave := ht.NewNode(\"Dave\", nil)\n\tht.ConnectNodes(dave, alice)\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, dave)\n\n\tchanPointDave := ht.OpenChannel(\n\t\tdave, alice, lntest.OpenChannelParams{Amt: chanAmt},\n\t)\n\n\t// Next, we'll create Carol and establish a channel from her to\n\t// Dave of 100k.\n\tcarol := ht.NewNode(\"Carol\", nil)\n\tht.ConnectNodes(carol, dave)\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, carol)\n\n\tchanPointCarol := ht.OpenChannel(\n\t\tcarol, dave, lntest.OpenChannelParams{Amt: chanAmt},\n\t)\n\n\t// Now create a _private_ channel directly between Carol and\n\t// Alice of 100k.\n\tht.ConnectNodes(carol, alice)\n\tchanPointPrivate := ht.OpenChannel(\n\t\tcarol, alice, lntest.OpenChannelParams{\n\t\t\tAmt:     chanAmt,\n\t\t\tPrivate: true,\n\t\t},\n\t)\n\tdefer ht.CloseChannel(carol, chanPointPrivate)\n\n\t// The channel should be available for payments between Carol and Alice.\n\t// We check this by sending payments from Carol to Bob, that\n\t// collectively would deplete at least one of Carol's channels.\n\n\t// Create 2 invoices for Bob, each of 70k satoshis. Since each of\n\t// Carol's channels is of size 100k, these payments cannot succeed\n\t// by only using one of the channels.\n\tconst numPayments = 2\n\tconst paymentAmt = 70000\n\tpayReqs, _, _ := ht.CreatePayReqs(bob, paymentAmt, numPayments)\n\n\t// Let Carol pay the invoices.\n\tht.CompletePaymentRequests(carol, payReqs)\n\n\t// When asserting the amount of satoshis moved, we'll factor in the\n\t// default base fee, as we didn't modify the fee structure when\n\t// creating the seed nodes in the network.\n\tconst baseFee = 1\n\n\t// Bob should have received 140k satoshis from Alice.\n\tht.AssertAmountPaid(\"Alice(local) => Bob(remote)\", bob,\n\t\tchanPointAlice, int64(0), 2*paymentAmt)\n\n\t// Alice sent 140k to Bob.\n\tht.AssertAmountPaid(\"Alice(local) => Bob(remote)\", alice,\n\t\tchanPointAlice, 2*paymentAmt, int64(0))\n\n\t// Alice received 70k + fee from Dave.\n\tht.AssertAmountPaid(\"Dave(local) => Alice(remote)\", alice,\n\t\tchanPointDave, int64(0), paymentAmt+baseFee)\n\n\t// Dave sent 70k+fee to Alice.\n\tht.AssertAmountPaid(\"Dave(local) => Alice(remote)\", dave,\n\t\tchanPointDave, paymentAmt+baseFee, int64(0))\n\n\t// Dave received 70k+fee of two hops from Carol.\n\tht.AssertAmountPaid(\"Carol(local) => Dave(remote)\", dave,\n\t\tchanPointCarol, int64(0), paymentAmt+baseFee*2)\n\n\t// Carol sent 70k+fee of two hops to Dave.\n\tht.AssertAmountPaid(\"Carol(local) => Dave(remote)\", carol,\n\t\tchanPointCarol, paymentAmt+baseFee*2, int64(0))\n\n\t// Alice received 70k+fee from Carol.\n\tht.AssertAmountPaid(\"Carol(local) [private=>] Alice(remote)\",\n\t\talice, chanPointPrivate, int64(0), paymentAmt+baseFee)\n\n\t// Carol sent 70k+fee to Alice.\n\tht.AssertAmountPaid(\"Carol(local) [private=>] Alice(remote)\",\n\t\tcarol, chanPointPrivate, paymentAmt+baseFee, int64(0))\n\n\t// Alice should also be able to route payments using this channel,\n\t// so send two payments of 60k back to Carol.\n\tconst paymentAmt60k = 60000\n\tpayReqs, _, _ = ht.CreatePayReqs(carol, paymentAmt60k, numPayments)\n\n\t// Let Bob pay the invoices.\n\tht.CompletePaymentRequests(alice, payReqs)\n\n\t// Carol and Alice should know about 4, while Bob and Dave should only\n\t// know about 3, since one channel is private.\n\tht.AssertNumEdges(alice, 4, true)\n\tht.AssertNumEdges(alice, 3, false)\n\tht.AssertNumEdges(bob, 3, true)\n\tht.AssertNumEdges(carol, 4, true)\n\tht.AssertNumEdges(carol, 3, false)\n\tht.AssertNumEdges(dave, 3, true)\n\n\t// Close all channels.\n\tht.CloseChannel(alice, chanPointAlice)\n\tht.CloseChannel(dave, chanPointDave)\n\tht.CloseChannel(carol, chanPointCarol)\n}\n\n// testInvoiceRoutingHints tests that the routing hints for an invoice are\n// created properly.",
      "length": 3996,
      "tokens": 507,
      "embedding": []
    },
    {
      "slug": "func testInvoiceRoutingHints(ht *lntest.HarnessTest) {",
      "content": "func testInvoiceRoutingHints(ht *lntest.HarnessTest) {\n\tconst chanAmt = btcutil.Amount(100000)\n\n\t// Throughout this test, we'll be opening a channel between Alice and\n\t// several other parties.\n\t//\n\t// First, we'll create a private channel between Alice and Bob. This\n\t// will be the only channel that will be considered as a routing hint\n\t// throughout this test. We'll include a push amount since we currently\n\t// require channels to have enough remote balance to cover the\n\t// invoice's payment.\n\talice, bob := ht.Alice, ht.Bob\n\tchanPointBob := ht.OpenChannel(\n\t\talice, bob, lntest.OpenChannelParams{\n\t\t\tAmt:     chanAmt,\n\t\t\tPushAmt: chanAmt / 2,\n\t\t\tPrivate: true,\n\t\t},\n\t)\n\n\t// Then, we'll create Carol's node and open a public channel between\n\t// her and Alice. This channel will not be considered as a routing hint\n\t// due to it being public.\n\tcarol := ht.NewNode(\"Carol\", nil)\n\n\tht.ConnectNodes(alice, carol)\n\tchanPointCarol := ht.OpenChannel(\n\t\talice, carol, lntest.OpenChannelParams{\n\t\t\tAmt:     chanAmt,\n\t\t\tPushAmt: chanAmt / 2,\n\t\t},\n\t)\n\n\t// We'll also create a public channel between Bob and Carol to ensure\n\t// that Bob gets selected as the only routing hint. We do this as we\n\t// should only include routing hints for nodes that are publicly\n\t// advertised, otherwise we'd end up leaking information about nodes\n\t// that wish to stay unadvertised.\n\tht.ConnectNodes(bob, carol)\n\tchanPointBobCarol := ht.OpenChannel(\n\t\tbob, carol, lntest.OpenChannelParams{\n\t\t\tAmt:     chanAmt,\n\t\t\tPushAmt: chanAmt / 2,\n\t\t},\n\t)\n\n\t// Then, we'll create Dave's node and open a private channel between\n\t// him and Alice. We will not include a push amount in order to not\n\t// consider this channel as a routing hint as it will not have enough\n\t// remote balance for the invoice's amount.\n\tdave := ht.NewNode(\"Dave\", nil)\n\n\tht.ConnectNodes(alice, dave)\n\tchanPointDave := ht.OpenChannel(\n\t\talice, dave, lntest.OpenChannelParams{\n\t\t\tAmt:     chanAmt,\n\t\t\tPrivate: true,\n\t\t},\n\t)\n\n\t// Finally, we'll create Eve's node and open a private channel between\n\t// her and Alice. This time though, we'll take Eve's node down after\n\t// the channel has been created to avoid populating routing hints for\n\t// inactive channels.\n\teve := ht.NewNode(\"Eve\", nil)\n\tht.ConnectNodes(alice, eve)\n\tchanPointEve := ht.OpenChannel(\n\t\talice, eve, lntest.OpenChannelParams{\n\t\t\tAmt:     chanAmt,\n\t\t\tPushAmt: chanAmt / 2,\n\t\t\tPrivate: true,\n\t\t},\n\t)\n\n\t// Now that the channels are open, we'll disconnect the connection\n\t// between Alice and Eve and then take down Eve's node.\n\tht.DisconnectNodes(alice, eve)\n\tht.Shutdown(eve)\n\n\t// We'll need the short channel ID of the channel between Alice and Bob\n\t// to make sure the routing hint is for this channel.\n\taliceBobChanID := ht.QueryChannelByChanPoint(alice, chanPointBob).ChanId\n\n\tcheckInvoiceHints := func(invoice *lnrpc.Invoice) {\n\t\t// Due to the way the channels were set up above, the channel\n\t\t// between Alice and Bob should be the only channel used as a\n\t\t// routing hint.\n\t\tvar decoded *lnrpc.PayReq\n\t\terr := wait.NoError(func() error {\n\t\t\tresp := alice.RPC.AddInvoice(invoice)\n\n\t\t\t// We'll decode the invoice's payment request to\n\t\t\t// determine which channels were used as routing hints.\n\t\t\tdecoded = alice.RPC.DecodePayReq(resp.PaymentRequest)\n\n\t\t\tif len(decoded.RouteHints) != 1 {\n\t\t\t\treturn fmt.Errorf(\"expected one route hint, \"+\n\t\t\t\t\t\"got %d\", len(decoded.RouteHints))\n\t\t\t}\n\n\t\t\treturn nil\n\t\t}, defaultTimeout)\n\t\trequire.NoError(ht, err, \"timeout checking invoice hints\")\n\n\t\thops := decoded.RouteHints[0].HopHints\n\t\trequire.Len(ht, hops, 1, \"expected one hop in route hint\")\n\n\t\tchanID := hops[0].ChanId\n\t\trequire.Equal(ht, aliceBobChanID, chanID, \"chanID mismatch\")\n\t}\n\n\t// Create an invoice for Alice that will populate the routing hints.\n\tinvoice := &lnrpc.Invoice{\n\t\tMemo:    \"routing hints\",\n\t\tValue:   int64(chanAmt / 4),\n\t\tPrivate: true,\n\t}\n\tcheckInvoiceHints(invoice)\n\n\t// Create another invoice for Alice with no value and ensure it still\n\t// populates routing hints.\n\tinvoice = &lnrpc.Invoice{\n\t\tMemo:    \"routing hints with no amount\",\n\t\tValue:   0,\n\t\tPrivate: true,\n\t}\n\tcheckInvoiceHints(invoice)\n\n\t// Now that we've confirmed the routing hints were added correctly, we\n\t// can close all the channels and shut down all the nodes created.\n\tht.CloseChannel(alice, chanPointBob)\n\tht.CloseChannel(alice, chanPointCarol)\n\tht.CloseChannel(bob, chanPointBobCarol)\n\tht.CloseChannel(alice, chanPointDave)\n\n\t// The channel between Alice and Eve should be force closed since Eve\n\t// is offline.\n\tht.ForceCloseChannel(alice, chanPointEve)\n}\n\n// testMultiHopOverPrivateChannels tests that private channels can be used as\n// intermediate hops in a route for payments.",
      "length": 4488,
      "tokens": 638,
      "embedding": []
    },
    {
      "slug": "func testMultiHopOverPrivateChannels(ht *lntest.HarnessTest) {",
      "content": "func testMultiHopOverPrivateChannels(ht *lntest.HarnessTest) {\n\t// We'll test that multi-hop payments over private channels work as\n\t// intended. To do so, we'll create the following topology:\n\t//         private        public           private\n\t// Alice <--100k--> Bob <--100k--> Carol <--100k--> Dave\n\tconst chanAmt = btcutil.Amount(100000)\n\n\t// First, we'll open a private channel between Alice and Bob with Alice\n\t// being the funder.\n\talice, bob := ht.Alice, ht.Bob\n\tchanPointAlice := ht.OpenChannel(\n\t\talice, bob, lntest.OpenChannelParams{\n\t\t\tAmt:     chanAmt,\n\t\t\tPrivate: true,\n\t\t},\n\t)\n\n\t// Next, we'll create Carol's node and open a public channel between\n\t// her and Bob with Bob being the funder.\n\tcarol := ht.NewNode(\"Carol\", nil)\n\tht.ConnectNodes(bob, carol)\n\tchanPointBob := ht.OpenChannel(\n\t\tbob, carol, lntest.OpenChannelParams{\n\t\t\tAmt: chanAmt,\n\t\t},\n\t)\n\n\t// Alice should know the new channel from Bob.\n\tht.AssertTopologyChannelOpen(alice, chanPointBob)\n\n\t// Next, we'll create Dave's node and open a private channel between\n\t// him and Carol with Carol being the funder.\n\tdave := ht.NewNode(\"Dave\", nil)\n\tht.ConnectNodes(carol, dave)\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, carol)\n\n\tchanPointCarol := ht.OpenChannel(\n\t\tcarol, dave, lntest.OpenChannelParams{\n\t\t\tAmt:     chanAmt,\n\t\t\tPrivate: true,\n\t\t},\n\t)\n\n\t// Dave should know the channel[Bob<->Carol] from Carol.\n\tht.AssertTopologyChannelOpen(dave, chanPointBob)\n\n\t// Now that all the channels are set up according to the topology from\n\t// above, we can proceed to test payments. We'll create an invoice for\n\t// Dave of 20k satoshis and pay it with Alice. Since there is no public\n\t// route from Alice to Dave, we'll need to use the private channel\n\t// between Carol and Dave as a routing hint encoded in the invoice.\n\tconst paymentAmt = 20000\n\n\t// Create the invoice for Dave.\n\tinvoice := &lnrpc.Invoice{\n\t\tMemo:    \"two hopz!\",\n\t\tValue:   paymentAmt,\n\t\tPrivate: true,\n\t}\n\tresp := dave.RPC.AddInvoice(invoice)\n\n\t// Let Alice pay the invoice.\n\tpayReqs := []string{resp.PaymentRequest}\n\tht.CompletePaymentRequests(alice, payReqs)\n\n\t// When asserting the amount of satoshis moved, we'll factor in the\n\t// default base fee, as we didn't modify the fee structure when opening\n\t// the channels.\n\tconst baseFee = 1\n\n\t// Dave should have received 20k satoshis from Carol.\n\tht.AssertAmountPaid(\"Carol(local) [private=>] Dave(remote)\",\n\t\tdave, chanPointCarol, 0, paymentAmt)\n\n\t// Carol should have sent 20k satoshis to Dave.\n\tht.AssertAmountPaid(\"Carol(local) [private=>] Dave(remote)\",\n\t\tcarol, chanPointCarol, paymentAmt, 0)\n\n\t// Carol should have received 20k satoshis + fee for one hop from Bob.\n\tht.AssertAmountPaid(\"Bob(local) => Carol(remote)\",\n\t\tcarol, chanPointBob, 0, paymentAmt+baseFee)\n\n\t// Bob should have sent 20k satoshis + fee for one hop to Carol.\n\tht.AssertAmountPaid(\"Bob(local) => Carol(remote)\",\n\t\tbob, chanPointBob, paymentAmt+baseFee, 0)\n\n\t// Bob should have received 20k satoshis + fee for two hops from Alice.\n\tht.AssertAmountPaid(\"Alice(local) [private=>] Bob(remote)\", bob,\n\t\tchanPointAlice, 0, paymentAmt+baseFee*2)\n\n\t// Alice should have sent 20k satoshis + fee for two hops to Bob.\n\tht.AssertAmountPaid(\"Alice(local) [private=>] Bob(remote)\", alice,\n\t\tchanPointAlice, paymentAmt+baseFee*2, 0)\n\n\t// At this point, the payment was successful. We can now close all the\n\t// channels and shutdown the nodes created throughout this test.\n\tht.CloseChannel(alice, chanPointAlice)\n\tht.CloseChannel(bob, chanPointBob)\n\tht.CloseChannel(carol, chanPointCarol)\n}\n\n// testQueryRoutes checks the response of queryroutes.\n// We'll create the following network topology:\n//\n//\tAlice --> Bob --> Carol --> Dave\n//\n// and query the daemon for routes from Alice to Dave.",
      "length": 3571,
      "tokens": 487,
      "embedding": []
    },
    {
      "slug": "func testQueryRoutes(ht *lntest.HarnessTest) {",
      "content": "func testQueryRoutes(ht *lntest.HarnessTest) {\n\tconst chanAmt = btcutil.Amount(100000)\n\n\t// Grab Alice and Bob from the standby nodes.\n\talice, bob := ht.Alice, ht.Bob\n\n\t// Create Carol and connect her to Bob. We also send her some coins for\n\t// channel opening.\n\tcarol := ht.NewNode(\"Carol\", nil)\n\tht.ConnectNodes(carol, bob)\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, carol)\n\n\t// Create Dave and connect him to Carol.\n\tdave := ht.NewNode(\"Dave\", nil)\n\tht.ConnectNodes(dave, carol)\n\n\t// We now proceed to open channels:\n\t//   Alice=>Bob, Bob=>Carol and Carol=>Dave.\n\tp := lntest.OpenChannelParams{Amt: chanAmt}\n\treqs := []*lntest.OpenChannelRequest{\n\t\t{Local: alice, Remote: bob, Param: p},\n\t\t{Local: bob, Remote: carol, Param: p},\n\t\t{Local: carol, Remote: dave, Param: p},\n\t}\n\tresp := ht.OpenMultiChannelsAsync(reqs)\n\n\t// Extract channel points from the response.\n\tchanPointAlice := resp[0]\n\tchanPointBob := resp[1]\n\tchanPointCarol := resp[2]\n\n\t// Before we continue, give Alice some time to catch up with the newly\n\t// opened channels.\n\tht.AssertTopologyChannelOpen(alice, chanPointBob)\n\tht.AssertTopologyChannelOpen(alice, chanPointCarol)\n\n\t// Query for routes to pay from Alice to Dave.\n\tconst paymentAmt = 1000\n\troutesReq := &lnrpc.QueryRoutesRequest{\n\t\tPubKey: dave.PubKeyStr,\n\t\tAmt:    paymentAmt,\n\t}\n\troutesRes := ht.QueryRoutesAndRetry(alice, routesReq)\n\n\tconst mSat = 1000\n\tfeePerHopMSat := computeFee(1000, 1, paymentAmt*mSat)\n\n\tfor i, route := range routesRes.Routes {\n\t\texpectedTotalFeesMSat :=\n\t\t\tlnwire.MilliSatoshi(len(route.Hops)-1) * feePerHopMSat\n\n\t\texpectedTotalAmtMSat :=\n\t\t\t(paymentAmt * mSat) + expectedTotalFeesMSat\n\n\t\tif route.TotalFees != route.TotalFeesMsat/mSat {\n\t\t\tht.Fatalf(\"route %v: total fees %v (msat) does not \"+\n\t\t\t\t\"round down to %v (sat)\",\n\t\t\t\ti, route.TotalFeesMsat, route.TotalFees)\n\t\t}\n\t\tif route.TotalFeesMsat != int64(expectedTotalFeesMSat) {\n\t\t\tht.Fatalf(\"route %v: total fees in msat expected %v \"+\n\t\t\t\t\"got %v\", i, expectedTotalFeesMSat,\n\t\t\t\troute.TotalFeesMsat)\n\t\t}\n\n\t\tif route.TotalAmt != route.TotalAmtMsat/mSat {\n\t\t\tht.Fatalf(\"route %v: total amt %v (msat) does not \"+\n\t\t\t\t\"round down to %v (sat)\",\n\t\t\t\ti, route.TotalAmtMsat, route.TotalAmt)\n\t\t}\n\t\tif route.TotalAmtMsat != int64(expectedTotalAmtMSat) {\n\t\t\tht.Fatalf(\"route %v: total amt in msat expected %v \"+\n\t\t\t\t\"got %v\", i, expectedTotalAmtMSat,\n\t\t\t\troute.TotalAmtMsat)\n\t\t}\n\n\t\t// For all hops except the last, we check that fee equals\n\t\t// feePerHop and amount to forward deducts feePerHop on each\n\t\t// hop.\n\t\texpectedAmtToForwardMSat := expectedTotalAmtMSat\n\t\tfor j, hop := range route.Hops[:len(route.Hops)-1] {\n\t\t\texpectedAmtToForwardMSat -= feePerHopMSat\n\n\t\t\tif hop.Fee != hop.FeeMsat/mSat {\n\t\t\t\tht.Fatalf(\"route %v hop %v: fee %v (msat) \"+\n\t\t\t\t\t\"does not round down to %v (sat)\",\n\t\t\t\t\ti, j, hop.FeeMsat, hop.Fee)\n\t\t\t}\n\t\t\tif hop.FeeMsat != int64(feePerHopMSat) {\n\t\t\t\tht.Fatalf(\"route %v hop %v: fee in msat \"+\n\t\t\t\t\t\"expected %v got %v\",\n\t\t\t\t\ti, j, feePerHopMSat, hop.FeeMsat)\n\t\t\t}\n\n\t\t\tif hop.AmtToForward != hop.AmtToForwardMsat/mSat {\n\t\t\t\tht.Fatalf(\"route %v hop %v: amt to forward %v\"+\n\t\t\t\t\t\"(msat) does not round down to %v(sat)\",\n\t\t\t\t\ti, j, hop.AmtToForwardMsat,\n\t\t\t\t\thop.AmtToForward)\n\t\t\t}\n\t\t\tif hop.AmtToForwardMsat !=\n\t\t\t\tint64(expectedAmtToForwardMSat) {\n\n\t\t\t\tht.Fatalf(\"route %v hop %v: amt to forward \"+\n\t\t\t\t\t\"in msat expected %v got %v\",\n\t\t\t\t\ti, j, expectedAmtToForwardMSat,\n\t\t\t\t\thop.AmtToForwardMsat)\n\t\t\t}\n\t\t}\n\n\t\t// Last hop should have zero fee and amount to forward should\n\t\t// equal payment amount.\n\t\thop := route.Hops[len(route.Hops)-1]\n\n\t\tif hop.Fee != 0 || hop.FeeMsat != 0 {\n\t\t\tht.Fatalf(\"route %v hop %v: fee expected 0 got %v \"+\n\t\t\t\t\"(sat) %v (msat)\", i, len(route.Hops)-1,\n\t\t\t\thop.Fee, hop.FeeMsat)\n\t\t}\n\n\t\tif hop.AmtToForward != hop.AmtToForwardMsat/mSat {\n\t\t\tht.Fatalf(\"route %v hop %v: amt to forward %v (msat) \"+\n\t\t\t\t\"does not round down to %v (sat)\", i,\n\t\t\t\tlen(route.Hops)-1, hop.AmtToForwardMsat,\n\t\t\t\thop.AmtToForward)\n\t\t}\n\t\tif hop.AmtToForwardMsat != paymentAmt*mSat {\n\t\t\tht.Fatalf(\"route %v hop %v: amt to forward in msat \"+\n\t\t\t\t\"expected %v got %v\", i, len(route.Hops)-1,\n\t\t\t\tpaymentAmt*mSat, hop.AmtToForwardMsat)\n\t\t}\n\t}\n\n\t// While we're here, we test updating mission control's config values\n\t// and assert that they are correctly updated and check that our mission\n\t// control import function updates appropriately.\n\ttestMissionControlCfg(ht.T, alice)\n\ttestMissionControlImport(ht, alice, bob.PubKey[:], carol.PubKey[:])\n\n\t// We clean up the test case by closing channels that were created for\n\t// the duration of the tests.\n\tht.CloseChannel(alice, chanPointAlice)\n\tht.CloseChannel(bob, chanPointBob)\n\tht.CloseChannel(carol, chanPointCarol)\n}\n\n// testMissionControlCfg tests getting and setting of a node's mission control\n// config, resetting to the original values after testing so that no other\n// tests are affected.",
      "length": 4666,
      "tokens": 599,
      "embedding": []
    },
    {
      "slug": "func testMissionControlCfg(t *testing.T, hn *node.HarnessNode) {",
      "content": "func testMissionControlCfg(t *testing.T, hn *node.HarnessNode) {\n\tt.Helper()\n\n\t// Getting and setting does not alter the configuration.\n\tstartCfg := hn.RPC.GetMissionControlConfig().Config\n\thn.RPC.SetMissionControlConfig(startCfg)\n\tresp := hn.RPC.GetMissionControlConfig()\n\trequire.True(t, proto.Equal(startCfg, resp.Config))\n\n\t// We test that setting and getting leads to the same config if all\n\t// fields are set.\n\tcfg := &routerrpc.MissionControlConfig{\n\t\tMaximumPaymentResults:       30,\n\t\tMinimumFailureRelaxInterval: 60,\n\t\tModel: routerrpc.\n\t\t\tMissionControlConfig_APRIORI,\n\t\tEstimatorConfig: &routerrpc.MissionControlConfig_Apriori{\n\t\t\tApriori: &routerrpc.AprioriParameters{\n\t\t\t\tHalfLifeSeconds:  8000,\n\t\t\t\tHopProbability:   0.8,\n\t\t\t\tWeight:           0.3,\n\t\t\t\tCapacityFraction: 0.8,\n\t\t\t},\n\t\t},\n\t}\n\thn.RPC.SetMissionControlConfig(cfg)\n\n\t// The deprecated fields should be populated.\n\tcfg.HalfLifeSeconds = 8000\n\tcfg.HopProbability = 0.8\n\tcfg.Weight = 0.3\n\trespCfg := hn.RPC.GetMissionControlConfig().Config\n\trequire.True(t, proto.Equal(cfg, respCfg))\n\n\t// Switching to another estimator is possible.\n\tcfg = &routerrpc.MissionControlConfig{\n\t\tModel: routerrpc.\n\t\t\tMissionControlConfig_BIMODAL,\n\t\tEstimatorConfig: &routerrpc.MissionControlConfig_Bimodal{\n\t\t\tBimodal: &routerrpc.BimodalParameters{\n\t\t\t\tScaleMsat: 1_000,\n\t\t\t\tDecayTime: 500,\n\t\t\t},\n\t\t},\n\t}\n\thn.RPC.SetMissionControlConfig(cfg)\n\trespCfg = hn.RPC.GetMissionControlConfig().Config\n\trequire.NotNil(t, respCfg.GetBimodal())\n\n\t// If parameters are not set in the request, they will have zero values\n\t// after.\n\trequire.Zero(t, respCfg.MaximumPaymentResults)\n\trequire.Zero(t, respCfg.MinimumFailureRelaxInterval)\n\trequire.Zero(t, respCfg.GetBimodal().NodeWeight)\n\n\t// Setting deprecated values will initialize the apriori estimator.\n\tcfg = &routerrpc.MissionControlConfig{\n\t\tMaximumPaymentResults:       30,\n\t\tMinimumFailureRelaxInterval: 60,\n\t\tHopProbability:              0.8,\n\t\tWeight:                      0.3,\n\t\tHalfLifeSeconds:             8000,\n\t}\n\thn.RPC.SetMissionControlConfig(cfg)\n\trespCfg = hn.RPC.GetMissionControlConfig().Config\n\trequire.NotNil(t, respCfg.GetApriori())\n\n\t// The default capacity fraction is set.\n\trequire.Equal(t, routing.DefaultCapacityFraction,\n\t\trespCfg.GetApriori().CapacityFraction)\n\n\t// Setting the wrong config results in an error.\n\tcfg = &routerrpc.MissionControlConfig{\n\t\tModel: routerrpc.\n\t\t\tMissionControlConfig_APRIORI,\n\t\tEstimatorConfig: &routerrpc.MissionControlConfig_Bimodal{\n\t\t\tBimodal: &routerrpc.BimodalParameters{\n\t\t\t\tScaleMsat: 1_000,\n\t\t\t},\n\t\t},\n\t}\n\thn.RPC.SetMissionControlConfigAssertErr(cfg)\n\n\t// Undo any changes.\n\thn.RPC.SetMissionControlConfig(startCfg)\n\tresp = hn.RPC.GetMissionControlConfig()\n\trequire.True(t, proto.Equal(startCfg, resp.Config))\n}\n\n// testMissionControlImport tests import of mission control results from an\n// external source.",
      "length": 2711,
      "tokens": 227,
      "embedding": []
    },
    {
      "slug": "func testMissionControlImport(ht *lntest.HarnessTest, hn *node.HarnessNode,",
      "content": "func testMissionControlImport(ht *lntest.HarnessTest, hn *node.HarnessNode,\n\tfromNode, toNode []byte) {\n\n\t// Reset mission control so that our query will return the default\n\t// probability for our first request.\n\thn.RPC.ResetMissionControl()\n\n\t// Get our baseline probability for a 10 msat hop between our target\n\t// nodes.\n\tvar amount int64 = 10\n\tprobReq := &routerrpc.QueryProbabilityRequest{\n\t\tFromNode: fromNode,\n\t\tToNode:   toNode,\n\t\tAmtMsat:  amount,\n\t}\n\n\timportHistory := &routerrpc.PairData{\n\t\tFailTime:    time.Now().Unix(),\n\t\tFailAmtMsat: amount,\n\t}\n\n\t// Assert that our history is not already equal to the value we want to\n\t// set. This should not happen because we have just cleared our state.\n\tresp1 := hn.RPC.QueryProbability(probReq)\n\trequire.Zero(ht, resp1.History.FailTime)\n\trequire.Zero(ht, resp1.History.FailAmtMsat)\n\n\t// Now, we import a single entry which tracks a failure of the amount\n\t// we want to query between our nodes.\n\treq := &routerrpc.XImportMissionControlRequest{\n\t\tPairs: []*routerrpc.PairHistory{\n\t\t\t{\n\t\t\t\tNodeFrom: fromNode,\n\t\t\t\tNodeTo:   toNode,\n\t\t\t\tHistory:  importHistory,\n\t\t\t},\n\t\t},\n\t}\n\thn.RPC.XImportMissionControl(req)\n\n\tresp2 := hn.RPC.QueryProbability(probReq)\n\trequire.Equal(ht, importHistory.FailTime, resp2.History.FailTime)\n\trequire.Equal(ht, importHistory.FailAmtMsat, resp2.History.FailAmtMsat)\n\n\t// Finally, check that we will fail if inconsistent sat/msat values are\n\t// set.\n\timportHistory.FailAmtSat = amount * 2\n\thn.RPC.XImportMissionControlAssertErr(req)\n}\n\n// testRouteFeeCutoff tests that we are able to prevent querying routes and\n// sending payments that incur a fee higher than the fee limit.",
      "length": 1527,
      "tokens": 188,
      "embedding": []
    },
    {
      "slug": "func testRouteFeeCutoff(ht *lntest.HarnessTest) {",
      "content": "func testRouteFeeCutoff(ht *lntest.HarnessTest) {\n\t// For this test, we'll create the following topology:\n\t//\n\t//              --- Bob ---\n\t//            /             \\\n\t// Alice ----                 ---- Dave\n\t//            \\             /\n\t//              -- Carol --\n\t//\n\t// Alice will attempt to send payments to Dave that should not incur a\n\t// fee greater than the fee limit expressed as a percentage of the\n\t// amount and as a fixed amount of satoshis.\n\tconst chanAmt = btcutil.Amount(100000)\n\n\t// Open a channel between Alice and Bob.\n\talice, bob := ht.Alice, ht.Bob\n\tchanPointAliceBob := ht.OpenChannel(\n\t\talice, bob, lntest.OpenChannelParams{Amt: chanAmt},\n\t)\n\n\t// Create Carol's node and open a channel between her and Alice with\n\t// Alice being the funder.\n\tcarol := ht.NewNode(\"Carol\", nil)\n\tht.ConnectNodes(carol, alice)\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, carol)\n\n\tchanPointAliceCarol := ht.OpenChannel(\n\t\talice, carol, lntest.OpenChannelParams{Amt: chanAmt},\n\t)\n\n\t// Create Dave's node and open a channel between him and Bob with Bob\n\t// being the funder.\n\tdave := ht.NewNode(\"Dave\", nil)\n\tht.ConnectNodes(dave, bob)\n\tchanPointBobDave := ht.OpenChannel(\n\t\tbob, dave, lntest.OpenChannelParams{Amt: chanAmt},\n\t)\n\n\t// Open a channel between Carol and Dave.\n\tht.ConnectNodes(carol, dave)\n\tchanPointCarolDave := ht.OpenChannel(\n\t\tcarol, dave, lntest.OpenChannelParams{Amt: chanAmt},\n\t)\n\n\t// Now that all the channels were set up, we'll wait for all the nodes\n\t// to have seen all the channels.\n\tnodes := []*node.HarnessNode{alice, bob, carol, dave}\n\tnetworkChans := []*lnrpc.ChannelPoint{\n\t\tchanPointAliceBob, chanPointAliceCarol, chanPointBobDave,\n\t\tchanPointCarolDave,\n\t}\n\tfor _, chanPoint := range networkChans {\n\t\tfor _, node := range nodes {\n\t\t\tht.AssertTopologyChannelOpen(node, chanPoint)\n\t\t}\n\t}\n\n\t// The payments should only be successful across the route:\n\t//\tAlice -> Bob -> Dave\n\t// Therefore, we'll update the fee policy on Carol's side for the\n\t// channel between her and Dave to invalidate the route:\n\t//\tAlice -> Carol -> Dave\n\tbaseFee := int64(10000)\n\tfeeRate := int64(5)\n\ttimeLockDelta := uint32(chainreg.DefaultBitcoinTimeLockDelta)\n\tmaxHtlc := lntest.CalculateMaxHtlc(chanAmt)\n\n\texpectedPolicy := &lnrpc.RoutingPolicy{\n\t\tFeeBaseMsat:      baseFee,\n\t\tFeeRateMilliMsat: testFeeBase * feeRate,\n\t\tTimeLockDelta:    timeLockDelta,\n\t\tMinHtlc:          1000, // default value\n\t\tMaxHtlcMsat:      maxHtlc,\n\t}\n\n\tupdateFeeReq := &lnrpc.PolicyUpdateRequest{\n\t\tBaseFeeMsat:   baseFee,\n\t\tFeeRate:       float64(feeRate),\n\t\tTimeLockDelta: timeLockDelta,\n\t\tMaxHtlcMsat:   maxHtlc,\n\t\tScope: &lnrpc.PolicyUpdateRequest_ChanPoint{\n\t\t\tChanPoint: chanPointCarolDave,\n\t\t},\n\t}\n\tcarol.RPC.UpdateChannelPolicy(updateFeeReq)\n\n\t// Wait for Alice to receive the channel update from Carol.\n\tht.AssertChannelPolicyUpdate(\n\t\talice, carol, expectedPolicy, chanPointCarolDave, false,\n\t)\n\n\t// We'll also need the channel IDs for Bob's channels in order to\n\t// confirm the route of the payments.\n\tchannel := ht.QueryChannelByChanPoint(bob, chanPointAliceBob)\n\taliceBobChanID := channel.ChanId\n\trequire.NotZero(ht, aliceBobChanID,\n\t\t\"channel between alice and bob not found\")\n\n\tchannel = ht.QueryChannelByChanPoint(bob, chanPointBobDave)\n\tbobDaveChanID := channel.ChanId\n\trequire.NotZero(ht, bobDaveChanID,\n\t\t\"channel between bob and dave not found\")\n\n\thopChanIDs := []uint64{aliceBobChanID, bobDaveChanID}\n\n\t// checkRoute is a helper closure to ensure the route contains the\n\t// correct intermediate hops.\n\tcheckRoute := func(route *lnrpc.Route) {\n\t\trequire.Len(ht, route.Hops, 2, \"expected two hops\")\n\n\t\tfor i, hop := range route.Hops {\n\t\t\trequire.Equal(ht, hopChanIDs[i], hop.ChanId,\n\t\t\t\t\"hop chan id not match\")\n\t\t}\n\t}\n\n\t// We'll be attempting to send two payments from Alice to Dave. One will\n\t// have a fee cutoff expressed as a percentage of the amount and the\n\t// other will have it expressed as a fixed amount of satoshis.\n\tconst paymentAmt = 100\n\tcarolFee := computeFee(lnwire.MilliSatoshi(baseFee), 1, paymentAmt)\n\n\t// testFeeCutoff is a helper closure that will ensure the different\n\t// types of fee limits work as intended when querying routes and sending\n\t// payments.\n\ttestFeeCutoff := func(feeLimit *lnrpc.FeeLimit) {\n\t\tqueryRoutesReq := &lnrpc.QueryRoutesRequest{\n\t\t\tPubKey:   dave.PubKeyStr,\n\t\t\tAmt:      paymentAmt,\n\t\t\tFeeLimit: feeLimit,\n\t\t}\n\t\troutesResp := alice.RPC.QueryRoutes(queryRoutesReq)\n\n\t\tcheckRoute(routesResp.Routes[0])\n\n\t\tinvoice := &lnrpc.Invoice{Value: paymentAmt}\n\t\tinvoiceResp := dave.RPC.AddInvoice(invoice)\n\n\t\tsendReq := &routerrpc.SendPaymentRequest{\n\t\t\tPaymentRequest: invoiceResp.PaymentRequest,\n\t\t\tTimeoutSeconds: 60,\n\t\t\tFeeLimitMsat:   noFeeLimitMsat,\n\t\t}\n\t\tswitch limit := feeLimit.Limit.(type) {\n\t\tcase *lnrpc.FeeLimit_Fixed:\n\t\t\tsendReq.FeeLimitMsat = 1000 * limit.Fixed\n\t\tcase *lnrpc.FeeLimit_Percent:\n\t\t\tsendReq.FeeLimitMsat = 1000 * paymentAmt *\n\t\t\t\tlimit.Percent / 100\n\t\t}\n\n\t\tresult := ht.SendPaymentAssertSettled(alice, sendReq)\n\n\t\tcheckRoute(result.Htlcs[0].Route)\n\t}\n\n\t// We'll start off using percentages first. Since the fee along the\n\t// route using Carol as an intermediate hop is 10% of the payment's\n\t// amount, we'll use a lower percentage in order to invalid that route.\n\tfeeLimitPercent := &lnrpc.FeeLimit{\n\t\tLimit: &lnrpc.FeeLimit_Percent{\n\t\t\tPercent: baseFee/1000 - 1,\n\t\t},\n\t}\n\ttestFeeCutoff(feeLimitPercent)\n\n\t// Now we'll test using fixed fee limit amounts. Since we computed the\n\t// fee for the route using Carol as an intermediate hop earlier, we can\n\t// use a smaller value in order to invalidate that route.\n\tfeeLimitFixed := &lnrpc.FeeLimit{\n\t\tLimit: &lnrpc.FeeLimit_Fixed{\n\t\t\tFixed: int64(carolFee.ToSatoshis()) - 1,\n\t\t},\n\t}\n\ttestFeeCutoff(feeLimitFixed)\n\n\t// TODO(yy): remove the sleep once the following bug is fixed. When the\n\t// payment is reported as settled by Carol, it's expected the\n\t// commitment dance is finished and all subsequent states have been\n\t// updated. Yet we'd receive the error `cannot co-op close channel with\n\t// active htlcs` or `link failed to shutdown` if we close the channel.\n\t// We need to investigate the order of settling the payments and\n\t// updating commitments to understand and fix .\n\ttime.Sleep(2 * time.Second)\n\n\t// Once we're done, close the channels and shut down the nodes created\n\t// throughout this test.\n\tht.CloseChannel(alice, chanPointAliceBob)\n\tht.CloseChannel(alice, chanPointAliceCarol)\n\tht.CloseChannel(bob, chanPointBobDave)\n\tht.CloseChannel(carol, chanPointCarolDave)\n}\n\n// computeFee calculates the payment fee as specified in BOLT07.",
      "length": 6319,
      "tokens": 800,
      "embedding": []
    },
    {
      "slug": "func computeFee(baseFee, feeRate, amt lnwire.MilliSatoshi) lnwire.MilliSatoshi {",
      "content": "func computeFee(baseFee, feeRate, amt lnwire.MilliSatoshi) lnwire.MilliSatoshi {\n\treturn baseFee + amt*feeRate/1000000\n}\n",
      "length": 38,
      "tokens": 5,
      "embedding": []
    }
  ]
}