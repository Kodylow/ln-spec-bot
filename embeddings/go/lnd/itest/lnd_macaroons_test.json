{
  "filepath": "../implementations/go/lnd/itest/lnd_macaroons_test.go",
  "package": "itest",
  "sections": [
    {
      "slug": "func testMacaroonAuthentication(ht *lntest.HarnessTest) {",
      "content": "func testMacaroonAuthentication(ht *lntest.HarnessTest) {\n\tvar (\n\t\tinfoReq    = &lnrpc.GetInfoRequest{}\n\t\tnewAddrReq = &lnrpc.NewAddressRequest{\n\t\t\tType: AddrTypeWitnessPubkeyHash,\n\t\t}\n\t\ttestNode   = ht.Alice\n\t\ttestClient = testNode.RPC.LN\n\t)\n\n\ttestCases := []struct {\n\t\tname string\n\t\trun  func(ctxt context.Context, t *testing.T)\n\t}{{\n\t\t// First test: Make sure we get an error if we use no macaroons\n\t\t// but try to connect to a node that has macaroon authentication\n\t\t// enabled.\n\t\tname: \"no macaroon\",\n\t\trun: func(ctxt context.Context, t *testing.T) {\n\t\t\tconn, err := testNode.ConnectRPCWithMacaroon(nil)\n\t\t\trequire.NoError(t, err)\n\t\t\tdefer func() { _ = conn.Close() }()\n\t\t\tclient := lnrpc.NewLightningClient(conn)\n\t\t\t_, err = client.GetInfo(ctxt, infoReq)\n\t\t\trequire.Error(t, err)\n\t\t\trequire.Contains(t, err.Error(), \"expected 1 macaroon\")\n\t\t},\n\t}, {\n\t\t// Second test: Ensure that an invalid macaroon also triggers an\n\t\t// error.\n\t\tname: \"invalid macaroon\",\n\t\trun: func(ctxt context.Context, t *testing.T) {\n\t\t\tinvalidMac, _ := macaroon.New(\n\t\t\t\t[]byte(\"dummy_root_key\"), []byte(\"0\"), \"itest\",\n\t\t\t\tmacaroon.LatestVersion,\n\t\t\t)\n\t\t\tcleanup, client := macaroonClient(\n\t\t\t\tt, testNode, invalidMac,\n\t\t\t)\n\t\t\tdefer cleanup()\n\t\t\t_, err := client.GetInfo(ctxt, infoReq)\n\t\t\trequire.Error(t, err)\n\t\t\trequire.Contains(t, err.Error(), \"cannot get macaroon\")\n\t\t},\n\t}, {\n\t\t// Third test: Try to access a write method with read-only\n\t\t// macaroon.\n\t\tname: \"read only macaroon\",\n\t\trun: func(ctxt context.Context, t *testing.T) {\n\t\t\treadonlyMac, err := testNode.ReadMacaroon(\n\t\t\t\ttestNode.Cfg.ReadMacPath, defaultTimeout,\n\t\t\t)\n\t\t\trequire.NoError(t, err)\n\t\t\tcleanup, client := macaroonClient(\n\t\t\t\tt, testNode, readonlyMac,\n\t\t\t)\n\t\t\tdefer cleanup()\n\t\t\t_, err = client.NewAddress(ctxt, newAddrReq)\n\t\t\trequire.Error(t, err)\n\t\t\trequire.Contains(t, err.Error(), \"permission denied\")\n\t\t},\n\t}, {\n\t\t// Fourth test: Check first-party caveat with timeout that\n\t\t// expired 30 seconds ago.\n\t\tname: \"expired macaroon\",\n\t\trun: func(ctxt context.Context, t *testing.T) {\n\t\t\treadonlyMac, err := testNode.ReadMacaroon(\n\t\t\t\ttestNode.Cfg.ReadMacPath, defaultTimeout,\n\t\t\t)\n\t\t\trequire.NoError(t, err)\n\t\t\ttimeoutMac, err := macaroons.AddConstraints(\n\t\t\t\treadonlyMac, macaroons.TimeoutConstraint(-30),\n\t\t\t)\n\t\t\trequire.NoError(t, err)\n\t\t\tcleanup, client := macaroonClient(\n\t\t\t\tt, testNode, timeoutMac,\n\t\t\t)\n\t\t\tdefer cleanup()\n\t\t\t_, err = client.GetInfo(ctxt, infoReq)\n\t\t\trequire.Error(t, err)\n\t\t\trequire.Contains(t, err.Error(), \"macaroon has expired\")\n\t\t},\n\t}, {\n\t\t// Fifth test: Check first-party caveat with invalid IP address.\n\t\tname: \"invalid IP macaroon\",\n\t\trun: func(ctxt context.Context, t *testing.T) {\n\t\t\treadonlyMac, err := testNode.ReadMacaroon(\n\t\t\t\ttestNode.Cfg.ReadMacPath, defaultTimeout,\n\t\t\t)\n\t\t\trequire.NoError(t, err)\n\t\t\tinvalidIPAddrMac, err := macaroons.AddConstraints(\n\t\t\t\treadonlyMac, macaroons.IPLockConstraint(\n\t\t\t\t\t\"1.1.1.1\",\n\t\t\t\t),\n\t\t\t)\n\t\t\trequire.NoError(t, err)\n\t\t\tcleanup, client := macaroonClient(\n\t\t\t\tt, testNode, invalidIPAddrMac,\n\t\t\t)\n\t\t\tdefer cleanup()\n\t\t\t_, err = client.GetInfo(ctxt, infoReq)\n\t\t\trequire.Error(t, err)\n\t\t\trequire.Contains(t, err.Error(), \"different IP address\")\n\t\t},\n\t}, {\n\t\t// Sixth test: Make sure that if we do everything correct and\n\t\t// send the admin macaroon with first-party caveats that we can\n\t\t// satisfy, we get a correct answer.\n\t\tname: \"correct macaroon\",\n\t\trun: func(ctxt context.Context, t *testing.T) {\n\t\t\tadminMac, err := testNode.ReadMacaroon(\n\t\t\t\ttestNode.Cfg.AdminMacPath, defaultTimeout,\n\t\t\t)\n\t\t\trequire.NoError(t, err)\n\t\t\tadminMac, err = macaroons.AddConstraints(\n\t\t\t\tadminMac, macaroons.TimeoutConstraint(30),\n\t\t\t\tmacaroons.IPLockConstraint(\"127.0.0.1\"),\n\t\t\t)\n\t\t\trequire.NoError(t, err)\n\t\t\tcleanup, client := macaroonClient(t, testNode, adminMac)\n\t\t\tdefer cleanup()\n\t\t\tres, err := client.NewAddress(ctxt, newAddrReq)\n\t\t\trequire.NoError(t, err, \"get new address\")\n\t\t\tassert.Contains(t, res.Address, \"bcrt1\")\n\t\t},\n\t}, {\n\t\t// Seventh test: Bake a macaroon that can only access exactly\n\t\t// two RPCs and make sure it works as expected.\n\t\tname: \"custom URI permissions\",\n\t\trun: func(ctxt context.Context, t *testing.T) {\n\t\t\tentity := macaroons.PermissionEntityCustomURI\n\t\t\treq := &lnrpc.BakeMacaroonRequest{\n\t\t\t\tPermissions: []*lnrpc.MacaroonPermission{{\n\t\t\t\t\tEntity: entity,\n\t\t\t\t\tAction: \"/lnrpc.Lightning/GetInfo\",\n\t\t\t\t}, {\n\t\t\t\t\tEntity: entity,\n\t\t\t\t\tAction: \"/lnrpc.Lightning/List\" +\n\t\t\t\t\t\t\"Permissions\",\n\t\t\t\t}},\n\t\t\t}\n\t\t\tbakeRes, err := testClient.BakeMacaroon(ctxt, req)\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// Create a connection that uses the custom macaroon.\n\t\t\tcustomMacBytes, err := hex.DecodeString(\n\t\t\t\tbakeRes.Macaroon,\n\t\t\t)\n\t\t\trequire.NoError(t, err)\n\t\t\tcustomMac := &macaroon.Macaroon{}\n\t\t\terr = customMac.UnmarshalBinary(customMacBytes)\n\t\t\trequire.NoError(t, err)\n\t\t\tcleanup, client := macaroonClient(\n\t\t\t\tt, testNode, customMac,\n\t\t\t)\n\t\t\tdefer cleanup()\n\n\t\t\t// Call GetInfo which should succeed.\n\t\t\t_, err = client.GetInfo(ctxt, infoReq)\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// Call ListPermissions which should also succeed.\n\t\t\tpermReq := &lnrpc.ListPermissionsRequest{}\n\t\t\tpermRes, err := client.ListPermissions(ctxt, permReq)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Greater(\n\t\t\t\tt, len(permRes.MethodPermissions), 10,\n\t\t\t\t\"permissions\",\n\t\t\t)\n\n\t\t\t// Try NewAddress which should be denied.\n\t\t\t_, err = client.NewAddress(ctxt, newAddrReq)\n\t\t\trequire.Error(t, err)\n\t\t\trequire.Contains(t, err.Error(), \"permission denied\")\n\t\t},\n\t}, {\n\t\t// Eighth test: check that with the CheckMacaroonPermissions\n\t\t// RPC, we can check that a macaroon follows (or doesn't)\n\t\t// permissions and constraints.\n\t\tname: \"unknown permissions\",\n\t\trun: func(ctxt context.Context, t *testing.T) {\n\t\t\t// A test macaroon created with permissions from pool,\n\t\t\t// to make sure CheckMacaroonPermissions RPC accepts\n\t\t\t// them.\n\t\t\trootKeyID := uint64(4200)\n\t\t\treq := &lnrpc.BakeMacaroonRequest{\n\t\t\t\tRootKeyId: rootKeyID,\n\t\t\t\tPermissions: []*lnrpc.MacaroonPermission{{\n\t\t\t\t\tEntity: \"account\",\n\t\t\t\t\tAction: \"read\",\n\t\t\t\t}, {\n\t\t\t\t\tEntity: \"recommendation\",\n\t\t\t\t\tAction: \"read\",\n\t\t\t\t}},\n\t\t\t\tAllowExternalPermissions: true,\n\t\t\t}\n\t\t\tbakeResp, err := testClient.BakeMacaroon(ctxt, req)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tmacBytes, err := hex.DecodeString(bakeResp.Macaroon)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tcheckReq := &lnrpc.CheckMacPermRequest{\n\t\t\t\tMacaroon:    macBytes,\n\t\t\t\tPermissions: req.Permissions,\n\t\t\t}\n\n\t\t\t// Test that CheckMacaroonPermissions accurately\n\t\t\t// characterizes macaroon as valid, even if the\n\t\t\t// permissions are not native to LND.\n\t\t\tcheckResp, err := testClient.CheckMacaroonPermissions(\n\t\t\t\tctxt, checkReq,\n\t\t\t)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, checkResp.Valid, true)\n\n\t\t\tmac, err := readMacaroonFromHex(bakeResp.Macaroon)\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// Test that CheckMacaroonPermissions responds that the\n\t\t\t// macaroon is invalid if timed out.\n\t\t\ttimeoutMac, err := macaroons.AddConstraints(\n\t\t\t\tmac, macaroons.TimeoutConstraint(-30),\n\t\t\t)\n\t\t\trequire.NoError(t, err)\n\n\t\t\ttimeoutMacBytes, err := timeoutMac.MarshalBinary()\n\t\t\trequire.NoError(t, err)\n\n\t\t\tcheckReq.Macaroon = timeoutMacBytes\n\n\t\t\t_, err = testClient.CheckMacaroonPermissions(\n\t\t\t\tctxt, checkReq,\n\t\t\t)\n\t\t\trequire.Error(t, err)\n\t\t\trequire.Contains(t, err.Error(), \"macaroon has expired\")\n\n\t\t\t// Test that CheckMacaroonPermissions labels macaroon\n\t\t\t// input with wrong permissions as invalid.\n\t\t\twrongPermissions := []*lnrpc.MacaroonPermission{{\n\t\t\t\tEntity: \"invoice\",\n\t\t\t\tAction: \"read\",\n\t\t\t}}\n\n\t\t\tcheckReq.Permissions = wrongPermissions\n\t\t\tcheckReq.Macaroon = macBytes\n\n\t\t\t_, err = testClient.CheckMacaroonPermissions(\n\t\t\t\tctxt, checkReq,\n\t\t\t)\n\t\t\trequire.Error(t, err)\n\t\t\trequire.Contains(t, err.Error(), \"permission denied\")\n\t\t},\n\t}}\n\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\t\tht.Run(tc.name, func(tt *testing.T) {\n\t\t\tctxt, cancel := context.WithTimeout(\n\t\t\t\tht.Context(), defaultTimeout,\n\t\t\t)\n\t\t\tdefer cancel()\n\n\t\t\ttc.run(ctxt, tt)\n\t\t})\n\t}\n}\n\n// testBakeMacaroon checks that when creating macaroons, the permissions param\n// in the request must be set correctly, and the baked macaroon has the intended\n// permissions.",
      "length": 7795,
      "tokens": 851,
      "embedding": []
    },
    {
      "slug": "func testBakeMacaroon(ht *lntest.HarnessTest) {",
      "content": "func testBakeMacaroon(ht *lntest.HarnessTest) {\n\tvar testNode = ht.Alice\n\n\ttestCases := []struct {\n\t\tname string\n\t\trun  func(ctxt context.Context, t *testing.T,\n\t\t\tadminClient lnrpc.LightningClient)\n\t}{{\n\t\t// First test: when the permission list is empty in the request,\n\t\t// an error should be returned.\n\t\tname: \"no permission list\",\n\t\trun: func(ctxt context.Context, t *testing.T,\n\t\t\tadminClient lnrpc.LightningClient) {\n\n\t\t\treq := &lnrpc.BakeMacaroonRequest{}\n\t\t\t_, err := adminClient.BakeMacaroon(ctxt, req)\n\t\t\trequire.Error(t, err)\n\t\t\tassert.Contains(\n\t\t\t\tt, err.Error(), \"permission list cannot be \"+\n\t\t\t\t\t\"empty\",\n\t\t\t)\n\t\t},\n\t}, {\n\t\t// Second test: when the action in the permission list is not\n\t\t// valid, an error should be returned.\n\t\tname: \"invalid permission list\",\n\t\trun: func(ctxt context.Context, t *testing.T,\n\t\t\tadminClient lnrpc.LightningClient) {\n\n\t\t\treq := &lnrpc.BakeMacaroonRequest{\n\t\t\t\tPermissions: []*lnrpc.MacaroonPermission{{\n\t\t\t\t\tEntity: \"macaroon\",\n\t\t\t\t\tAction: \"invalid123\",\n\t\t\t\t}},\n\t\t\t}\n\t\t\t_, err := adminClient.BakeMacaroon(ctxt, req)\n\t\t\trequire.Error(t, err)\n\t\t\tassert.Contains(\n\t\t\t\tt, err.Error(), \"invalid permission action\",\n\t\t\t)\n\t\t},\n\t}, {\n\t\t// Third test: when the entity in the permission list is not\n\t\t// valid, an error should be returned.\n\t\tname: \"invalid permission entity\",\n\t\trun: func(ctxt context.Context, t *testing.T,\n\t\t\tadminClient lnrpc.LightningClient) {\n\n\t\t\treq := &lnrpc.BakeMacaroonRequest{\n\t\t\t\tPermissions: []*lnrpc.MacaroonPermission{{\n\t\t\t\t\tEntity: \"invalid123\",\n\t\t\t\t\tAction: \"read\",\n\t\t\t\t}},\n\t\t\t}\n\t\t\t_, err := adminClient.BakeMacaroon(ctxt, req)\n\t\t\trequire.Error(t, err)\n\t\t\tassert.Contains(\n\t\t\t\tt, err.Error(), \"invalid permission entity\",\n\t\t\t)\n\t\t},\n\t}, {\n\t\t// Fourth test: check that when no root key ID is specified, the\n\t\t// default root keyID is used.\n\t\tname: \"default root key ID\",\n\t\trun: func(ctxt context.Context, t *testing.T,\n\t\t\tadminClient lnrpc.LightningClient) {\n\n\t\t\treq := &lnrpc.BakeMacaroonRequest{\n\t\t\t\tPermissions: []*lnrpc.MacaroonPermission{{\n\t\t\t\t\tEntity: \"macaroon\",\n\t\t\t\t\tAction: \"read\",\n\t\t\t\t}},\n\t\t\t}\n\t\t\t_, err := adminClient.BakeMacaroon(ctxt, req)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tlistReq := &lnrpc.ListMacaroonIDsRequest{}\n\t\t\tresp, err := adminClient.ListMacaroonIDs(ctxt, listReq)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, resp.RootKeyIds[0], uint64(0))\n\t\t},\n\t}, {\n\t\t// Fifth test: create a macaroon use a non-default root key ID.\n\t\tname: \"custom root key ID\",\n\t\trun: func(ctxt context.Context, t *testing.T,\n\t\t\tadminClient lnrpc.LightningClient) {\n\n\t\t\trootKeyID := uint64(4200)\n\t\t\treq := &lnrpc.BakeMacaroonRequest{\n\t\t\t\tRootKeyId: rootKeyID,\n\t\t\t\tPermissions: []*lnrpc.MacaroonPermission{{\n\t\t\t\t\tEntity: \"macaroon\",\n\t\t\t\t\tAction: \"read\",\n\t\t\t\t}},\n\t\t\t}\n\t\t\t_, err := adminClient.BakeMacaroon(ctxt, req)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tlistReq := &lnrpc.ListMacaroonIDsRequest{}\n\t\t\tresp, err := adminClient.ListMacaroonIDs(ctxt, listReq)\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// the ListMacaroonIDs should give a list of two IDs,\n\t\t\t// the default ID 0, and the newly created ID. The\n\t\t\t// returned response is sorted to guarantee the order so\n\t\t\t// that we can compare them one by one.\n\t\t\tsort.Slice(resp.RootKeyIds, func(i, j int) bool {\n\t\t\t\treturn resp.RootKeyIds[i] < resp.RootKeyIds[j]\n\t\t\t})\n\t\t\trequire.Equal(t, resp.RootKeyIds[0], uint64(0))\n\t\t\trequire.Equal(t, resp.RootKeyIds[1], rootKeyID)\n\t\t},\n\t}, {\n\t\t// Sixth test: check the baked macaroon has the intended\n\t\t// permissions. It should succeed in reading, and fail to write\n\t\t// a macaroon.\n\t\tname: \"custom macaroon permissions\",\n\t\trun: func(ctxt context.Context, t *testing.T,\n\t\t\tadminClient lnrpc.LightningClient) {\n\n\t\t\trootKeyID := uint64(4200)\n\t\t\treq := &lnrpc.BakeMacaroonRequest{\n\t\t\t\tRootKeyId: rootKeyID,\n\t\t\t\tPermissions: []*lnrpc.MacaroonPermission{{\n\t\t\t\t\tEntity: \"macaroon\",\n\t\t\t\t\tAction: \"read\",\n\t\t\t\t}},\n\t\t\t}\n\t\t\tbakeResp, err := adminClient.BakeMacaroon(ctxt, req)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tnewMac, err := readMacaroonFromHex(bakeResp.Macaroon)\n\t\t\trequire.NoError(t, err)\n\t\t\tcleanup, readOnlyClient := macaroonClient(\n\t\t\t\tt, testNode, newMac,\n\t\t\t)\n\t\t\tdefer cleanup()\n\n\t\t\t// BakeMacaroon requires a write permission, so this\n\t\t\t// call should return an error.\n\t\t\t_, err = readOnlyClient.BakeMacaroon(ctxt, req)\n\t\t\trequire.Error(t, err)\n\t\t\trequire.Contains(t, err.Error(), \"permission denied\")\n\n\t\t\t// ListMacaroon requires a read permission, so this call\n\t\t\t// should succeed.\n\t\t\tlistReq := &lnrpc.ListMacaroonIDsRequest{}\n\t\t\t_, err = readOnlyClient.ListMacaroonIDs(ctxt, listReq)\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// Current macaroon can only work on entity macaroon, so\n\t\t\t// a GetInfo request will fail.\n\t\t\tinfoReq := &lnrpc.GetInfoRequest{}\n\t\t\t_, err = readOnlyClient.GetInfo(ctxt, infoReq)\n\t\t\trequire.Error(t, err)\n\t\t\trequire.Contains(t, err.Error(), \"permission denied\")\n\t\t},\n\t}, {\n\t\t// Seventh test: check that if the allow_external_permissions\n\t\t// flag is set, we are able to feed BakeMacaroons permissions\n\t\t// that LND is not familiar with.\n\t\tname: \"allow external macaroon permissions\",\n\t\trun: func(ctxt context.Context, t *testing.T,\n\t\t\tadminClient lnrpc.LightningClient) {\n\n\t\t\t// We'll try permissions from Pool to test that the\n\t\t\t// allow_external_permissions flag properly allows it.\n\t\t\trootKeyID := uint64(4200)\n\t\t\treq := &lnrpc.BakeMacaroonRequest{\n\t\t\t\tRootKeyId: rootKeyID,\n\t\t\t\tPermissions: []*lnrpc.MacaroonPermission{{\n\t\t\t\t\tEntity: \"account\",\n\t\t\t\t\tAction: \"read\",\n\t\t\t\t}},\n\t\t\t\tAllowExternalPermissions: true,\n\t\t\t}\n\n\t\t\tresp, err := adminClient.BakeMacaroon(ctxt, req)\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// We'll also check that the external permission was\n\t\t\t// successfully added to the macaroon.\n\t\t\tmacBytes, err := hex.DecodeString(resp.Macaroon)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tmac := &macaroon.Macaroon{}\n\t\t\terr = mac.UnmarshalBinary(macBytes)\n\t\t\trequire.NoError(t, err)\n\n\t\t\trawID := mac.Id()\n\t\t\tdecodedID := &lnrpc.MacaroonId{}\n\t\t\tidProto := rawID[1:]\n\t\t\terr = proto.Unmarshal(idProto, decodedID)\n\t\t\trequire.NoError(t, err)\n\n\t\t\trequire.Equal(t, \"account\", decodedID.Ops[0].Entity)\n\t\t\trequire.Equal(t, \"read\", decodedID.Ops[0].Actions[0])\n\t\t},\n\t}}\n\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\t\tht.Run(tc.name, func(tt *testing.T) {\n\t\t\tctxt, cancel := context.WithTimeout(\n\t\t\t\tht.Context(), defaultTimeout,\n\t\t\t)\n\t\t\tdefer cancel()\n\n\t\t\tadminMac, err := testNode.ReadMacaroon(\n\t\t\t\ttestNode.Cfg.AdminMacPath, defaultTimeout,\n\t\t\t)\n\t\t\trequire.NoError(tt, err)\n\t\t\tcleanup, client := macaroonClient(tt, testNode, adminMac)\n\t\t\tdefer cleanup()\n\n\t\t\ttc.run(ctxt, tt, client)\n\t\t})\n\t}\n}\n\n// testDeleteMacaroonID checks that when deleting a macaroon ID, it removes the\n// specified ID and invalidates all macaroons derived from the key with that ID.\n// Also, it checks deleting the reserved marcaroon ID, DefaultRootKeyID or is\n// forbidden.",
      "length": 6511,
      "tokens": 746,
      "embedding": []
    },
    {
      "slug": "func testDeleteMacaroonID(ht *lntest.HarnessTest) {",
      "content": "func testDeleteMacaroonID(ht *lntest.HarnessTest) {\n\tvar (\n\t\tctxb     = ht.Context()\n\t\ttestNode = ht.Alice\n\t)\n\tctxt, cancel := context.WithTimeout(ctxb, defaultTimeout)\n\tdefer cancel()\n\n\t// Use admin macaroon to create a connection.\n\tadminMac, err := testNode.ReadMacaroon(\n\t\ttestNode.Cfg.AdminMacPath, defaultTimeout,\n\t)\n\trequire.NoError(ht, err)\n\tcleanup, client := macaroonClient(ht.T, testNode, adminMac)\n\tdefer cleanup()\n\n\t// Record the number of macaroon IDs before creation.\n\tlistReq := &lnrpc.ListMacaroonIDsRequest{}\n\tlistResp, err := client.ListMacaroonIDs(ctxt, listReq)\n\trequire.NoError(ht, err)\n\tnumMacIDs := len(listResp.RootKeyIds)\n\n\t// Create macaroons for testing.\n\trootKeyIDs := []uint64{1, 2, 3}\n\tmacList := make([]string, 0, len(rootKeyIDs))\n\tfor _, id := range rootKeyIDs {\n\t\treq := &lnrpc.BakeMacaroonRequest{\n\t\t\tRootKeyId: id,\n\t\t\tPermissions: []*lnrpc.MacaroonPermission{{\n\t\t\t\tEntity: \"macaroon\",\n\t\t\t\tAction: \"read\",\n\t\t\t}},\n\t\t}\n\t\tresp, err := client.BakeMacaroon(ctxt, req)\n\t\trequire.NoError(ht, err)\n\t\tmacList = append(macList, resp.Macaroon)\n\t}\n\n\t// Check that the creation is successful.\n\tlistReq = &lnrpc.ListMacaroonIDsRequest{}\n\tlistResp, err = client.ListMacaroonIDs(ctxt, listReq)\n\trequire.NoError(ht, err)\n\n\t// The number of macaroon IDs should be increased by len(rootKeyIDs).\n\trequire.Equal(ht, numMacIDs+len(rootKeyIDs), len(listResp.RootKeyIds))\n\n\t// First test: check deleting the DefaultRootKeyID returns an error.\n\tdefaultID, _ := strconv.ParseUint(\n\t\tstring(macaroons.DefaultRootKeyID), 10, 64,\n\t)\n\treq := &lnrpc.DeleteMacaroonIDRequest{\n\t\tRootKeyId: defaultID,\n\t}\n\t_, err = client.DeleteMacaroonID(ctxt, req)\n\trequire.Error(ht, err)\n\trequire.Contains(ht, err.Error(),\n\t\tmacaroons.ErrDeletionForbidden.Error())\n\n\t// Second test: check deleting the customized ID returns success.\n\treq = &lnrpc.DeleteMacaroonIDRequest{\n\t\tRootKeyId: rootKeyIDs[0],\n\t}\n\tresp, err := client.DeleteMacaroonID(ctxt, req)\n\trequire.NoError(ht, err)\n\trequire.True(ht, resp.Deleted)\n\n\t// Check that the deletion is successful.\n\tlistReq = &lnrpc.ListMacaroonIDsRequest{}\n\tlistResp, err = client.ListMacaroonIDs(ctxt, listReq)\n\trequire.NoError(ht, err)\n\n\t// The number of macaroon IDs should be decreased by 1.\n\trequire.Equal(ht, numMacIDs+len(rootKeyIDs)-1, len(listResp.RootKeyIds))\n\n\t// Check that the deleted macaroon can no longer access macaroon:read.\n\tdeletedMac, err := readMacaroonFromHex(macList[0])\n\trequire.NoError(ht, err)\n\tcleanup, client = macaroonClient(ht.T, testNode, deletedMac)\n\tdefer cleanup()\n\n\t// Because the macaroon is deleted, it will be treated as an invalid\n\t// one.\n\tlistReq = &lnrpc.ListMacaroonIDsRequest{}\n\t_, err = client.ListMacaroonIDs(ctxt, listReq)\n\trequire.Error(ht, err)\n\trequire.Contains(ht, err.Error(), \"cannot get macaroon\")\n}\n\n// testStatelessInit checks that the stateless initialization of the daemon\n// does not write any macaroon files to the daemon's file system and returns\n// the admin macaroon in the response. It then checks that the password\n// change of the wallet can also happen stateless.",
      "length": 2915,
      "tokens": 333,
      "embedding": []
    },
    {
      "slug": "func testStatelessInit(ht *lntest.HarnessTest) {",
      "content": "func testStatelessInit(ht *lntest.HarnessTest) {\n\tvar (\n\t\tinitPw     = []byte(\"stateless\")\n\t\tnewPw      = []byte(\"stateless-new\")\n\t\tnewAddrReq = &lnrpc.NewAddressRequest{\n\t\t\tType: AddrTypeWitnessPubkeyHash,\n\t\t}\n\t)\n\n\t// First, create a new node and request it to initialize stateless.\n\t// This should return us the binary serialized admin macaroon that we\n\t// can then use for further calls.\n\tcarol, _, macBytes := ht.NewNodeWithSeed(\"Carol\", nil, initPw, true)\n\trequire.NotEmpty(ht, macBytes,\n\t\t\"invalid macaroon returned in stateless init\")\n\n\t// Now make sure no macaroon files have been created by the node Carol.\n\t_, err := os.Stat(carol.Cfg.AdminMacPath)\n\trequire.Error(ht, err)\n\t_, err = os.Stat(carol.Cfg.ReadMacPath)\n\trequire.Error(ht, err)\n\t_, err = os.Stat(carol.Cfg.InvoiceMacPath)\n\trequire.Error(ht, err)\n\n\t// Then check that we can unmarshal the binary serialized macaroon.\n\tadminMac := &macaroon.Macaroon{}\n\terr = adminMac.UnmarshalBinary(macBytes)\n\trequire.NoError(ht, err)\n\n\t// Find out if we can actually use the macaroon that has been returned\n\t// to us for a RPC call.\n\tconn, err := carol.ConnectRPCWithMacaroon(adminMac)\n\trequire.NoError(ht, err)\n\tdefer conn.Close()\n\tadminMacClient := lnrpc.NewLightningClient(conn)\n\tctxt, cancel := context.WithTimeout(ht.Context(), defaultTimeout)\n\tdefer cancel()\n\tres, err := adminMacClient.NewAddress(ctxt, newAddrReq)\n\trequire.NoError(ht, err)\n\tif !strings.HasPrefix(res.Address, harnessNetParams.Bech32HRPSegwit) {\n\t\trequire.Fail(ht, \"returned address was not a regtest address\")\n\t}\n\n\t// As a second part, shut down the node and then try to change the\n\t// password when we start it up again.\n\tht.RestartNodeNoUnlock(carol)\n\tchangePwReq := &lnrpc.ChangePasswordRequest{\n\t\tCurrentPassword: initPw,\n\t\tNewPassword:     newPw,\n\t\tStatelessInit:   true,\n\t}\n\tresponse, err := carol.ChangePasswordAndInit(changePwReq)\n\trequire.NoError(ht, err)\n\n\t// Again, make  sure no macaroon files have been created by the node\n\t// Carol.\n\t_, err = os.Stat(carol.Cfg.AdminMacPath)\n\trequire.Error(ht, err)\n\t_, err = os.Stat(carol.Cfg.ReadMacPath)\n\trequire.Error(ht, err)\n\t_, err = os.Stat(carol.Cfg.InvoiceMacPath)\n\trequire.Error(ht, err)\n\n\t// Then check that we can unmarshal the new binary serialized macaroon\n\t// and that it really is a new macaroon.\n\terr = adminMac.UnmarshalBinary(response.AdminMacaroon)\n\trequire.NoError(ht, err, \"unable to unmarshal macaroon\")\n\trequire.NotEqual(ht, response.AdminMacaroon, macBytes,\n\t\t\"expected new macaroon to be different\")\n\n\t// Finally, find out if we can actually use the new macaroon that has\n\t// been returned to us for a RPC call.\n\tconn2, err := carol.ConnectRPCWithMacaroon(adminMac)\n\trequire.NoError(ht, err)\n\tdefer conn2.Close()\n\tadminMacClient = lnrpc.NewLightningClient(conn2)\n\n\t// Changing the password takes a while, so we use the default timeout\n\t// of 30 seconds to wait for the connection to be ready.\n\tctxt, cancel = context.WithTimeout(ht.Context(), defaultTimeout)\n\tdefer cancel()\n\tres, err = adminMacClient.NewAddress(ctxt, newAddrReq)\n\trequire.NoError(ht, err)\n\tif !strings.HasPrefix(res.Address, harnessNetParams.Bech32HRPSegwit) {\n\t\trequire.Fail(ht, \"returned address was not a regtest address\")\n\t}\n}\n\n// readMacaroonFromHex loads a macaroon from a hex string.",
      "length": 3125,
      "tokens": 380,
      "embedding": []
    },
    {
      "slug": "func readMacaroonFromHex(macHex string) (*macaroon.Macaroon, error) {",
      "content": "func readMacaroonFromHex(macHex string) (*macaroon.Macaroon, error) {\n\tmacBytes, err := hex.DecodeString(macHex)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tmac := &macaroon.Macaroon{}\n\tif err := mac.UnmarshalBinary(macBytes); err != nil {\n\t\treturn nil, err\n\t}\n\treturn mac, nil\n}\n",
      "length": 195,
      "tokens": 32,
      "embedding": []
    },
    {
      "slug": "func macaroonClient(t *testing.T, testNode *node.HarnessNode,",
      "content": "func macaroonClient(t *testing.T, testNode *node.HarnessNode,\n\tmac *macaroon.Macaroon) (func(), lnrpc.LightningClient) {\n\n\tt.Helper()\n\n\tconn, err := testNode.ConnectRPCWithMacaroon(mac)\n\trequire.NoError(t, err, \"connect to alice\")\n\n\tcleanup := func() {\n\t\terr := conn.Close()\n\t\trequire.NoError(t, err, \"close\")\n\t}\n\treturn cleanup, lnrpc.NewLightningClient(conn)\n}\n",
      "length": 288,
      "tokens": 30,
      "embedding": []
    }
  ]
}