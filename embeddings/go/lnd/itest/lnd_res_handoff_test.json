{
  "filepath": "../implementations/go/lnd/itest/lnd_res_handoff_test.go",
  "package": "itest",
  "sections": [
    {
      "slug": "func testResHandoff(ht *lntest.HarnessTest) {",
      "content": "func testResHandoff(ht *lntest.HarnessTest) {\n\tconst (\n\t\tchanAmt    = btcutil.Amount(1000000)\n\t\tpaymentAmt = 50000\n\t)\n\n\talice, bob := ht.Alice, ht.Bob\n\n\t// First we'll create a channel between Alice and Bob.\n\tht.EnsureConnected(alice, bob)\n\n\tparams := lntest.OpenChannelParams{Amt: chanAmt}\n\tchanPointAlice := ht.OpenChannel(alice, bob, params)\n\n\t// Create a new node Carol that will be in hodl mode. This is used to\n\t// trigger the behavior of checkRemoteDanglingActions in the\n\t// contractcourt. This will cause Bob to fail the HTLC back to Alice.\n\tcarol := ht.NewNode(\"Carol\", []string{\"--hodl.commit\"})\n\n\t// Connect Bob to Carol.\n\tht.ConnectNodes(bob, carol)\n\n\t// Open a channel between Bob and Carol.\n\tchanPointCarol := ht.OpenChannel(bob, carol, params)\n\n\t// Wait for Alice to see the channel edge in the graph.\n\tht.AssertTopologyChannelOpen(alice, chanPointCarol)\n\n\t// We'll create an invoice for Carol that Alice will attempt to pay.\n\t// Since Carol is in hodl.commit mode, she won't send back any commit\n\t// sigs.\n\tcarolPayReqs, _, _ := ht.CreatePayReqs(carol, paymentAmt, 1)\n\n\t// Alice will now attempt to fulfill the invoice.\n\tht.CompletePaymentRequestsNoWait(alice, carolPayReqs, chanPointAlice)\n\n\t// Wait until Carol has received the Add, CommitSig from Bob, and has\n\t// responded with a RevokeAndAck. We expect NumUpdates to be 1 meaning\n\t// Carol's CommitHeight is 1.\n\tht.AssertChannelCommitHeight(carol, chanPointCarol, 1)\n\n\t// Before we shutdown Alice, we'll assert that she only has 1 update.\n\tht.AssertChannelCommitHeight(alice, chanPointAlice, 1)\n\n\t// We'll shutdown Alice so that Bob can't connect to her.\n\trestartAlice := ht.SuspendNode(alice)\n\n\t// Bob will now force close his channel with Carol such that resolution\n\t// messages are created and forwarded backwards to Alice.\n\tht.CloseChannelAssertPending(bob, chanPointCarol, true)\n\n\t// The channel should be listed in the PendingChannels result.\n\tht.AssertNumWaitingClose(bob, 1)\n\n\t// Mine a block to confirm the closing tx.\n\tht.MineBlocks(1)\n\n\t// We sleep here so we can be sure that the hand-off has occurred from\n\t// Bob's contractcourt to Bob's htlcswitch. This sleep could be removed\n\t// if there was some feedback (i.e. API in switch) that allowed for\n\t// querying the state of resolution messages.\n\ttime.Sleep(10 * time.Second)\n\n\t// Mine blocks until Bob has no waiting close channels. This tests that\n\t// the circuit-deletion logic is skipped if a resolution message\n\t// exists.\n\tht.CleanupForceClose(bob, chanPointCarol)\n\n\t// We will now restart Bob so that we can test whether the resolution\n\t// messages are re-forwarded on start-up.\n\tht.RestartNode(bob)\n\n\t// We'll now also restart Alice and connect her with Bob.\n\trequire.NoError(ht, restartAlice())\n\n\tht.EnsureConnected(alice, bob)\n\n\t// We'll assert that Alice has received the failure resolution message.\n\tht.AssertChannelCommitHeight(alice, chanPointAlice, 2)\n\n\t// Assert that Alice's payment failed.\n\tht.AssertFirstHTLCError(alice, lnrpc.Failure_PERMANENT_CHANNEL_FAILURE)\n\n\tht.CloseChannel(alice, chanPointAlice)\n}\n",
      "length": 2928,
      "tokens": 404,
      "embedding": []
    }
  ]
}