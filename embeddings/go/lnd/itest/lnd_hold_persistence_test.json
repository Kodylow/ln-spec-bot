{
  "filepath": "../implementations/go/lnd/itest/lnd_hold_persistence_test.go",
  "package": "itest",
  "sections": [
    {
      "slug": "func testHoldInvoicePersistence(ht *lntest.HarnessTest) {",
      "content": "func testHoldInvoicePersistence(ht *lntest.HarnessTest) {\n\tconst (\n\t\tchanAmt     = btcutil.Amount(1000000)\n\t\tnumPayments = 10\n\t\treason      = lnrpc.PaymentFailureReason_FAILURE_REASON_INCORRECT_PAYMENT_DETAILS //nolint:lll\n\t)\n\n\t// Create carol, and clean up when the test finishes.\n\tcarol := ht.NewNode(\"Carol\", nil)\n\n\t// Connect Alice to Carol.\n\talice, bob := ht.Alice, ht.Bob\n\tht.ConnectNodes(alice, carol)\n\n\t// Open a channel between Alice and Carol which is private so that we\n\t// cover the addition of hop hints for hold invoices.\n\tchanPointAlice := ht.OpenChannel(\n\t\talice, carol, lntest.OpenChannelParams{\n\t\t\tAmt:     chanAmt,\n\t\t\tPrivate: true,\n\t\t},\n\t)\n\n\t// For Carol to include her private channel with Alice as a hop hint,\n\t// we need Alice to be perceived as a \"public\" node, meaning that she\n\t// has at least one public channel in the graph. We open a public\n\t// channel from Alice -> Bob and wait for Carol to see it.\n\tchanPointBob := ht.OpenChannel(\n\t\talice, bob, lntest.OpenChannelParams{\n\t\t\tAmt: chanAmt,\n\t\t},\n\t)\n\n\t// Wait for Carol to see the open channel Alice-Bob.\n\tht.AssertTopologyChannelOpen(carol, chanPointBob)\n\n\t// Create preimages for all payments we are going to initiate.\n\tvar preimages []lntypes.Preimage\n\tfor i := 0; i < numPayments; i++ {\n\t\tvar preimage lntypes.Preimage\n\t\tcopy(preimage[:], ht.Random32Bytes())\n\t\tpreimages = append(preimages, preimage)\n\t}\n\n\t// Let Carol create hold-invoices for all the payments.\n\tvar (\n\t\tpayAmt         = btcutil.Amount(4)\n\t\tpayReqs        []string\n\t\tinvoiceStreams []rpc.SingleInvoiceClient\n\t)\n\n\tassertInvoiceState := func(state lnrpc.Invoice_InvoiceState) {\n\t\tfor _, client := range invoiceStreams {\n\t\t\tht.AssertInvoiceState(client, state)\n\t\t}\n\t}\n\n\tfor _, preimage := range preimages {\n\t\tpayHash := preimage.Hash()\n\n\t\t// Make our invoices private so that we get coverage for adding\n\t\t// hop hints.\n\t\tinvoiceReq := &invoicesrpc.AddHoldInvoiceRequest{\n\t\t\tMemo:    \"testing\",\n\t\t\tValue:   int64(payAmt),\n\t\t\tHash:    payHash[:],\n\t\t\tPrivate: true,\n\t\t}\n\t\tresp := carol.RPC.AddHoldInvoice(invoiceReq)\n\t\tpayReqs = append(payReqs, resp.PaymentRequest)\n\n\t\t// We expect all of our invoices to have hop hints attached,\n\t\t// since Carol and Alice are connected with a private channel.\n\t\t// We assert that we have one hop hint present to ensure that\n\t\t// we've got coverage for hop hints.\n\t\tinvoice := alice.RPC.DecodePayReq(resp.PaymentRequest)\n\t\trequire.Len(ht, invoice.RouteHints, 1)\n\n\t\tstream := carol.RPC.SubscribeSingleInvoice(payHash[:])\n\t\tinvoiceStreams = append(invoiceStreams, stream)\n\t}\n\n\t// Wait for all the invoices to reach the OPEN state.\n\tassertInvoiceState(lnrpc.Invoice_OPEN)\n\n\t// Let Alice initiate payments for all the created invoices.\n\tfor _, payReq := range payReqs {\n\t\treq := &routerrpc.SendPaymentRequest{\n\t\t\tPaymentRequest: payReq,\n\t\t\tTimeoutSeconds: 60,\n\t\t\tFeeLimitSat:    1000000,\n\t\t}\n\n\t\t// Wait for inflight status update.\n\t\tht.SendPaymentAndAssertStatus(\n\t\t\talice, req, lnrpc.Payment_IN_FLIGHT,\n\t\t)\n\t}\n\n\t// The payments should now show up in Alice's ListPayments, with a zero\n\t// preimage, indicating they are not yet settled.\n\tvar zeroPreimg lntypes.Preimage\n\terr := wait.NoError(func() error {\n\t\tpayments := ht.AssertNumPayments(alice, numPayments)\n\n\t\t// Gather the payment hashes we are looking for in the\n\t\t// response.\n\t\tpayHashes := make(map[string]struct{})\n\t\tfor _, preimg := range preimages {\n\t\t\tpayHashes[preimg.Hash().String()] = struct{}{}\n\t\t}\n\n\t\tfor _, payment := range payments {\n\t\t\t_, ok := payHashes[payment.PaymentHash]\n\t\t\tif !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// The preimage should NEVER be non-zero at this point.\n\t\t\trequire.Equal(ht, zeroPreimg.String(),\n\t\t\t\tpayment.PaymentPreimage,\n\t\t\t\t\"expected zero preimage\")\n\n\t\t\t// We wait for the payment attempt to have been\n\t\t\t// properly recorded in the DB.\n\t\t\tif len(payment.Htlcs) == 0 {\n\t\t\t\treturn fmt.Errorf(\"no attempt recorded\")\n\t\t\t}\n\n\t\t\tdelete(payHashes, payment.PaymentHash)\n\t\t}\n\n\t\tif len(payHashes) != 0 {\n\t\t\treturn fmt.Errorf(\"payhash not found in response\")\n\t\t}\n\n\t\treturn nil\n\t}, defaultTimeout)\n\trequire.NoError(ht, err, \"timeout checking alice's payments\")\n\n\t// Wait for all invoices to be accepted.\n\tassertInvoiceState(lnrpc.Invoice_ACCEPTED)\n\n\t// Restart alice. This to ensure she will still be able to handle\n\t// settling the invoices after a restart.\n\tht.RestartNode(alice)\n\n\t// Ensure the connections are made.\n\t//\n\t// TODO(yy): we shouldn't need these two lines since the connections\n\t// are permanent, they'd reconnect automatically upon Alice's restart.\n\t// However, we'd sometimes see the error `unable to gracefully close\n\t// channel while peer is offline (try force closing it instead):\n\t// channel link not found` from closing the channels in the end,\n\t// indicating there's something wrong with the peer conn. We need to\n\t// investigate and fix it in peer conn management.\n\tht.EnsureConnected(alice, bob)\n\tht.EnsureConnected(alice, carol)\n\n\t// Now after a restart, we must re-track the payments. We set up a\n\t// goroutine for each to track their status updates.\n\tfor _, preimg := range preimages {\n\t\thash := preimg.Hash()\n\n\t\tpayStream := alice.RPC.TrackPaymentV2(hash[:])\n\t\tht.ReceiveTrackPayment(payStream)\n\n\t\tht.AssertPaymentStatus(\n\t\t\talice, preimg, lnrpc.Payment_IN_FLIGHT,\n\t\t)\n\t}\n\n\t// Settle invoices half the invoices, cancel the rest.\n\tfor i, preimage := range preimages {\n\t\tif i%2 == 0 {\n\t\t\tcarol.RPC.SettleInvoice(preimage[:])\n\t\t\tht.AssertInvoiceState(\n\t\t\t\tinvoiceStreams[i], lnrpc.Invoice_SETTLED,\n\t\t\t)\n\t\t} else {\n\t\t\thash := preimage.Hash()\n\t\t\tcarol.RPC.CancelInvoice(hash[:])\n\t\t\tht.AssertInvoiceState(\n\t\t\t\tinvoiceStreams[i], lnrpc.Invoice_CANCELED,\n\t\t\t)\n\t\t}\n\t}\n\n\t// Check that Alice's invoices to be shown as settled and failed\n\t// accordingly, and preimages matching up.\n\tfor i, preimg := range preimages {\n\t\tif i%2 == 0 {\n\t\t\tht.AssertPaymentStatus(\n\t\t\t\talice, preimg, lnrpc.Payment_SUCCEEDED,\n\t\t\t)\n\t\t} else {\n\t\t\tpayment := ht.AssertPaymentStatus(\n\t\t\t\talice, preimg, lnrpc.Payment_FAILED,\n\t\t\t)\n\t\t\trequire.Equal(ht, reason, payment.FailureReason,\n\t\t\t\t\"wrong failure reason\")\n\t\t}\n\t}\n\n\t// Finally, close all channels.\n\tht.CloseChannel(alice, chanPointBob)\n\tht.CloseChannel(alice, chanPointAlice)\n}\n",
      "length": 5907,
      "tokens": 776,
      "embedding": []
    }
  ]
}