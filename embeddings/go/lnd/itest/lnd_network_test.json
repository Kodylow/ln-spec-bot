{
  "filepath": "../implementations/go/lnd/itest/lnd_network_test.go",
  "package": "itest",
  "sections": [
    {
      "slug": "func testNetworkConnectionTimeout(ht *lntest.HarnessTest) {",
      "content": "func testNetworkConnectionTimeout(ht *lntest.HarnessTest) {\n\tvar (\n\t\t// testPub is a random public key for testing only.\n\t\ttestPub = \"0332bda7da70fefe4b6ab92f53b3c4f4ee7999\" +\n\t\t\t\"f312284a8e89c8670bb3f67dbee2\"\n\n\t\t// testHost is a reachable IP address with an unreachable port\n\t\t// that's used for testing only.\n\t\ttestHost = \"lightning.engineering:81\"\n\t)\n\n\t// First, test the global timeout settings.\n\t// Create Carol with a connection timeout of 1 millisecond.\n\tcarol := ht.NewNode(\"Carol\", []string{\"--connectiontimeout=1ms\"})\n\n\t// Try to connect Carol to a non-routable IP address, which should give\n\t// us a timeout error.\n\treq := &lnrpc.ConnectPeerRequest{\n\t\tAddr: &lnrpc.LightningAddress{\n\t\t\tPubkey: testPub,\n\t\t\tHost:   testHost,\n\t\t},\n\t}\n\n\t// assertTimeoutError asserts that a connection timeout error is\n\t// raised. A context with a default timeout is used to make the\n\t// request. If our customized connection timeout is less than the\n\t// default, we won't see the request context times out, instead a\n\t// network connection timeout will be returned.\n\tassertTimeoutError := func(hn *node.HarnessNode,\n\t\treq *lnrpc.ConnectPeerRequest) {\n\n\t\terr := hn.RPC.ConnectPeerAssertErr(req)\n\n\t\t// Check that the network returns a timeout error.\n\t\trequire.Containsf(ht, err.Error(), \"i/o timeout\",\n\t\t\t\"expected to get a timeout error, instead got: %v\", err)\n\t}\n\n\tassertTimeoutError(carol, req)\n\n\t// Second, test timeout on the connect peer request.\n\t// Create Dave with the default timeout setting.\n\tdave := ht.NewNode(\"Dave\", nil)\n\n\t// Try to connect Dave to a non-routable IP address, using a timeout\n\t// value of 1ms, which should give us a timeout error immediately.\n\treq = &lnrpc.ConnectPeerRequest{\n\t\tAddr: &lnrpc.LightningAddress{\n\t\t\tPubkey: testPub,\n\t\t\tHost:   testHost,\n\t\t},\n\t\tTimeout: 1,\n\t}\n\tassertTimeoutError(dave, req)\n}\n\n// testReconnectAfterIPChange verifies that if a persistent inbound node changes\n// its listening address then it's peer will still be able to reconnect to it.",
      "length": 1871,
      "tokens": 263,
      "embedding": []
    },
    {
      "slug": "func testReconnectAfterIPChange(ht *lntest.HarnessTest) {",
      "content": "func testReconnectAfterIPChange(ht *lntest.HarnessTest) {\n\t// In this test, the following network will be set up. A single\n\t// dash line represents a peer connection and a double dash line\n\t// represents a channel.\n\t// Charlie will create a connection to Dave so that Dave is the inbound\n\t// peer. This will be made a persistent connection for Charlie so that\n\t// Charlie will attempt to reconnect to Dave if Dave restarts.\n\t// A channel will be opened between Dave and Alice to ensure that any\n\t// NodeAnnouncements that Dave sends will reach Alice.\n\t// The connection between Alice and Charlie ensures that Charlie\n\t// receives all of Dave's NodeAnnouncements.\n\t// The desired behaviour is that if Dave changes his P2P IP address then\n\t// Charlie should still be able to reconnect to him.\n\t//\n\t//    /------- Charlie <-----\\\n\t//    |                      |\n\t//    v                      |\n\t//   Dave <===============> Alice\n\n\t// The first thing we will test is the case where Dave advertises two\n\t// external IP addresses and then switches from the first one listed\n\t// to the second one listed. The desired behaviour is that Charlie will\n\t// attempt both of Dave's advertised addresses when attempting to\n\t// reconnect.\n\n\t// Create a new node, Charlie.\n\tcharlie := ht.NewNode(\"Charlie\", nil)\n\n\t// We derive an extra port for Dave, and we initialise his node with\n\t// the port advertised as `--externalip` arguments.\n\tip2 := node.NextAvailablePort()\n\n\t// Create a new node, Dave, which will initialize a P2P port for him.\n\tdaveArgs := []string{fmt.Sprintf(\"--externalip=127.0.0.1:%d\", ip2)}\n\tdave := ht.NewNode(\"Dave\", daveArgs)\n\n\t// We now have two ports, the initial P2P port from creating the node,\n\t// and the `externalip` specified above.\n\tadvertisedAddrs := []string{\n\t\tfmt.Sprintf(\"127.0.0.1:%d\", dave.Cfg.P2PPort),\n\t\tfmt.Sprintf(\"127.0.0.1:%d\", ip2),\n\t}\n\n\t// Connect Alice to Dave and Charlie.\n\talice := ht.Alice\n\tht.ConnectNodes(alice, dave)\n\tht.ConnectNodes(alice, charlie)\n\n\t// We'll then go ahead and open a channel between Alice and Dave. This\n\t// ensures that Charlie receives the node announcement from Alice as\n\t// part of the announcement broadcast.\n\tchanPoint := ht.OpenChannel(\n\t\talice, dave, lntest.OpenChannelParams{Amt: 1000000},\n\t)\n\n\t// waitForNodeAnnouncement is a closure used to wait on the given graph\n\t// subscription for a node announcement from a node with the given\n\t// public key. It also waits for the node announcement that advertises\n\t// a particular set of addresses.\n\twaitForNodeAnnouncement := func(nodePubKey string, addrs []string) {\n\t\terr := wait.NoError(func() error {\n\t\t\t// Expect to have at least 1 node announcement now.\n\t\t\tupdates := ht.AssertNumNodeAnns(charlie, nodePubKey, 1)\n\n\t\t\t// Get latest node update from the node.\n\t\t\tupdate := updates[len(updates)-1]\n\n\t\t\taddrMap := make(map[string]bool)\n\t\t\tfor _, addr := range update.NodeAddresses {\n\t\t\t\taddrMap[addr.GetAddr()] = true\n\t\t\t}\n\n\t\t\t// Check that our wanted addresses can be found from\n\t\t\t// the node update.\n\t\t\tfor _, addr := range addrs {\n\t\t\t\tif !addrMap[addr] {\n\t\t\t\t\treturn fmt.Errorf(\"address %s not \"+\n\t\t\t\t\t\t\"found\", addr)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn nil\n\t\t}, defaultTimeout)\n\t\trequire.NoError(ht, err, \"timeout checking node ann\")\n\t}\n\n\t// Wait for Charlie to receive Dave's initial NodeAnnouncement.\n\twaitForNodeAnnouncement(dave.PubKeyStr, advertisedAddrs)\n\n\t// Now create a persistent connection between Charlie and Dave with no\n\t// channels. Charlie is the outbound node and Dave is the inbound node.\n\tht.ConnectNodesPerm(charlie, dave)\n\n\t// Change Dave's P2P port to the second IP address that he advertised\n\t// and restart his node.\n\tdave.Cfg.P2PPort = ip2\n\tht.RestartNode(dave)\n\n\t// assert that Dave and Charlie reconnect successfully after Dave\n\t// changes to his second advertised address.\n\tht.AssertConnected(dave, charlie)\n\n\t// Next we test the case where Dave changes his listening address to one\n\t// that was not listed in his original advertised addresses. The desired\n\t// behaviour is that Charlie will update his connection requests to Dave\n\t// when he receives the Node Announcement from Dave with his updated\n\t// address.\n\n\t// Change Dave's listening port and restart.\n\tdave.Cfg.P2PPort = node.NextAvailablePort()\n\tdave.Cfg.ExtraArgs = []string{\n\t\tfmt.Sprintf(\n\t\t\t\"--externalip=127.0.0.1:%d\", dave.Cfg.P2PPort,\n\t\t),\n\t}\n\tht.RestartNode(dave)\n\n\t// Show that Charlie does receive Dave's new listening address in\n\t// a Node Announcement.\n\twaitForNodeAnnouncement(\n\t\tdave.PubKeyStr,\n\t\t[]string{fmt.Sprintf(\"127.0.0.1:%d\", dave.Cfg.P2PPort)},\n\t)\n\n\t// assert that Dave and Charlie do reconnect after Dave changes his P2P\n\t// address to one not listed in Dave's original advertised list of\n\t// addresses.\n\tht.AssertConnected(dave, charlie)\n\n\t// Finally, close the channel.\n\tht.CloseChannel(alice, chanPoint)\n}\n\n// testAddPeerConfig tests that the \"--addpeer\" config flag successfully adds\n// a new peer.",
      "length": 4725,
      "tokens": 691,
      "embedding": []
    },
    {
      "slug": "func testAddPeerConfig(ht *lntest.HarnessTest) {",
      "content": "func testAddPeerConfig(ht *lntest.HarnessTest) {\n\talice := ht.Alice\n\tinfo := alice.RPC.GetInfo()\n\n\talicePeerAddress := info.Uris[0]\n\n\t// Create a new node (Carol) with Alice as a peer.\n\targs := []string{fmt.Sprintf(\"--addpeer=%v\", alicePeerAddress)}\n\tcarol := ht.NewNode(\"Carol\", args)\n\n\t// TODO(yy): remove this once the peer conn race is fixed.\n\ttime.Sleep(1 * time.Second)\n\n\tht.EnsureConnected(alice, carol)\n\n\t// If we list Carol's peers, Alice should already be\n\t// listed as one, since we specified her using the\n\t// addpeer flag.\n\tlistPeersResp := carol.RPC.ListPeers()\n\n\tparsedPeerAddr, err := lncfg.ParseLNAddressString(\n\t\talicePeerAddress, \"9735\", net.ResolveTCPAddr,\n\t)\n\trequire.NoError(ht, err)\n\n\tparsedKeyStr := fmt.Sprintf(\n\t\t\"%x\", parsedPeerAddr.IdentityKey.SerializeCompressed(),\n\t)\n\n\trequire.Equal(ht, parsedKeyStr, listPeersResp.Peers[0].PubKey)\n}\n",
      "length": 786,
      "tokens": 90,
      "embedding": []
    }
  ]
}