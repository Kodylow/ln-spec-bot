{
  "filepath": "../implementations/go/lnd/itest/lnd_channel_graph_test.go",
  "package": "itest",
  "sections": [
    {
      "slug": "func testUpdateChanStatus(ht *lntest.HarnessTest) {",
      "content": "func testUpdateChanStatus(ht *lntest.HarnessTest) {\n\t// Create two fresh nodes and open a channel between them.\n\talice, bob := ht.Alice, ht.Bob\n\targs := []string{\n\t\t\"--minbackoff=60s\",\n\t\t\"--chan-enable-timeout=3s\",\n\t\t\"--chan-disable-timeout=6s\",\n\t\t\"--chan-status-sample-interval=0.5s\",\n\t}\n\tht.RestartNodeWithExtraArgs(alice, args)\n\tht.RestartNodeWithExtraArgs(bob, args)\n\tht.EnsureConnected(alice, bob)\n\n\t// Open a channel with 100k satoshis between Alice and Bob with Alice\n\t// being the sole funder of the channel.\n\tchanAmt := btcutil.Amount(100000)\n\tchanPoint := ht.OpenChannel(\n\t\talice, bob, lntest.OpenChannelParams{Amt: chanAmt},\n\t)\n\tdefer ht.CloseChannel(alice, chanPoint)\n\n\t// assertEdgeDisabled ensures that Alice has the correct Disabled state\n\t// for given channel from her DescribeGraph.\n\tassertEdgeDisabled := func(disabled bool) {\n\t\toutPoint := ht.OutPointFromChannelPoint(chanPoint)\n\n\t\terr := wait.NoError(func() error {\n\t\t\tedge := ht.AssertNumEdges(alice, 1, true)[0]\n\t\t\tif edge.ChanPoint != outPoint.String() {\n\t\t\t\treturn fmt.Errorf(\"expected chan_point %v, \"+\n\t\t\t\t\t\"got %v\", outPoint, edge.ChanPoint)\n\t\t\t}\n\t\t\tvar policy *lnrpc.RoutingPolicy\n\t\t\tif alice.PubKeyStr == edge.Node1Pub {\n\t\t\t\tpolicy = edge.Node1Policy\n\t\t\t} else {\n\t\t\t\tpolicy = edge.Node2Policy\n\t\t\t}\n\t\t\tif disabled != policy.Disabled {\n\t\t\t\treturn fmt.Errorf(\"expected policy.Disabled \"+\n\t\t\t\t\t\"to be %v, but policy was %v\", disabled,\n\t\t\t\t\tpolicy.Disabled)\n\t\t\t}\n\n\t\t\treturn nil\n\t\t}, defaultTimeout)\n\t\trequire.NoError(ht, err, \"assert edge disabled timeout\")\n\t}\n\n\t// aliceSendReq sends an UpdateChanStatus request to Alice.\n\taliceSendReq := func(action routerrpc.ChanStatusAction) {\n\t\treq := &routerrpc.UpdateChanStatusRequest{\n\t\t\tChanPoint: chanPoint,\n\t\t\tAction:    action,\n\t\t}\n\t\talice.RPC.UpdateChanStatus(req)\n\t}\n\n\t// Initially, the channel between Alice and Bob should not be disabled.\n\t//\n\t// NOTE: This check should happen right after the channel openning as\n\t// we've used a short timeout value for `--chan-disable-timeout`. If we\n\t// wait longer than that we might get a flake saying the channel is\n\t// disabled.\n\tassertEdgeDisabled(false)\n\n\t// Launch a node for Carol which will connect to Alice and Bob in order\n\t// to receive graph updates. This will ensure that the channel updates\n\t// are propagated throughout the network.\n\tcarol := ht.NewNode(\"Carol\", nil)\n\n\t// assertChannelUpdate checks that the required policy update has been\n\t// heard in Carol's network.\n\tassertChannelUpdate := func(node *node.HarnessNode,\n\t\tpolicy *lnrpc.RoutingPolicy) {\n\n\t\tht.AssertChannelPolicyUpdate(\n\t\t\tcarol, node, policy, chanPoint, false,\n\t\t)\n\t}\n\n\t// Connect both Alice and Bob to the new node Carol, so she can sync\n\t// her graph.\n\tht.ConnectNodes(alice, carol)\n\tht.ConnectNodes(bob, carol)\n\tht.WaitForGraphSync(carol)\n\n\t// If the above waitForGraphSync takes more than 4 seconds, the channel\n\t// Alice=>Bob will be marked as disabled now. Thus we connect Alice and\n\t// Bob again to make sure the channel is alive.\n\tht.EnsureConnected(alice, bob)\n\n\t// When updating the state of the channel between Alice and Bob, we\n\t// should expect to see channel updates with the default routing\n\t// policy. The value of \"Disabled\" will depend on the specific scenario\n\t// being tested.\n\texpectedPolicy := &lnrpc.RoutingPolicy{\n\t\tFeeBaseMsat:      int64(chainreg.DefaultBitcoinBaseFeeMSat),\n\t\tFeeRateMilliMsat: int64(chainreg.DefaultBitcoinFeeRate),\n\t\tTimeLockDelta:    chainreg.DefaultBitcoinTimeLockDelta,\n\t\tMinHtlc:          1000, // default value\n\t\tMaxHtlcMsat:      lntest.CalculateMaxHtlc(chanAmt),\n\t}\n\n\t// Manually disable the channel and ensure that a \"Disabled = true\"\n\t// update is propagated.\n\taliceSendReq(routerrpc.ChanStatusAction_DISABLE)\n\texpectedPolicy.Disabled = true\n\tassertChannelUpdate(alice, expectedPolicy)\n\n\t// Re-enable the channel and ensure that a \"Disabled = false\" update is\n\t// propagated.\n\taliceSendReq(routerrpc.ChanStatusAction_ENABLE)\n\texpectedPolicy.Disabled = false\n\tassertChannelUpdate(alice, expectedPolicy)\n\n\t// Manually enabling a channel should NOT prevent subsequent\n\t// disconnections from automatically disabling the channel again (we\n\t// don't want to clutter the network with channels that are falsely\n\t// advertised as enabled when they don't work).\n\tht.DisconnectNodes(alice, bob)\n\texpectedPolicy.Disabled = true\n\tassertChannelUpdate(alice, expectedPolicy)\n\tassertChannelUpdate(bob, expectedPolicy)\n\n\t// Reconnecting the nodes should propagate a \"Disabled = false\" update.\n\tht.EnsureConnected(alice, bob)\n\texpectedPolicy.Disabled = false\n\tassertChannelUpdate(alice, expectedPolicy)\n\tassertChannelUpdate(bob, expectedPolicy)\n\n\t// Manually disabling the channel should prevent a subsequent\n\t// disconnect/reconnect from re-enabling the channel on Alice's end.\n\t// Note the asymmetry between manual enable and manual disable!\n\taliceSendReq(routerrpc.ChanStatusAction_DISABLE)\n\n\t// Alice sends out the \"Disabled = true\" update in response to the\n\t// ChanStatusAction_DISABLE request.\n\texpectedPolicy.Disabled = true\n\tassertChannelUpdate(alice, expectedPolicy)\n\n\tht.DisconnectNodes(alice, bob)\n\n\t// Bob sends a \"Disabled = true\" update upon detecting the disconnect.\n\texpectedPolicy.Disabled = true\n\tassertChannelUpdate(bob, expectedPolicy)\n\n\t// Bob sends a \"Disabled = false\" update upon detecting the reconnect.\n\tht.EnsureConnected(alice, bob)\n\texpectedPolicy.Disabled = false\n\tassertChannelUpdate(bob, expectedPolicy)\n\n\t// However, since we manually disabled the channel on Alice's end, the\n\t// policy on Alice's end should still be \"Disabled = true\". Again, note\n\t// the asymmetry between manual enable and manual disable!\n\tassertEdgeDisabled(true)\n\n\tht.DisconnectNodes(alice, bob)\n\n\t// Bob sends a \"Disabled = true\" update upon detecting the disconnect.\n\texpectedPolicy.Disabled = true\n\tassertChannelUpdate(bob, expectedPolicy)\n\n\t// After restoring automatic channel state management on Alice's end,\n\t// BOTH Alice and Bob should set the channel state back to \"enabled\" on\n\t// reconnect.\n\taliceSendReq(routerrpc.ChanStatusAction_AUTO)\n\tht.EnsureConnected(alice, bob)\n\n\texpectedPolicy.Disabled = false\n\tassertChannelUpdate(alice, expectedPolicy)\n\tassertChannelUpdate(bob, expectedPolicy)\n\tassertEdgeDisabled(false)\n}\n\n// testUnannouncedChannels checks unannounced channels are not returned by\n// describeGraph RPC request unless explicitly asked for.",
      "length": 6128,
      "tokens": 729,
      "embedding": []
    },
    {
      "slug": "func testUnannouncedChannels(ht *lntest.HarnessTest) {",
      "content": "func testUnannouncedChannels(ht *lntest.HarnessTest) {\n\tamount := funding.MaxBtcFundingAmount\n\talice, bob := ht.Alice, ht.Bob\n\n\t// Open a channel between Alice and Bob, ensuring the\n\t// channel has been opened properly.\n\tchanOpenUpdate := ht.OpenChannelAssertStream(\n\t\talice, bob, lntest.OpenChannelParams{Amt: amount},\n\t)\n\n\t// Mine 2 blocks, and check that the channel is opened but not yet\n\t// announced to the network.\n\tht.MineBlocksAndAssertNumTxes(2, 1)\n\n\t// One block is enough to make the channel ready for use, since the\n\t// nodes have defaultNumConfs=1 set.\n\tfundingChanPoint := ht.WaitForChannelOpenEvent(chanOpenUpdate)\n\n\t// Alice should have 1 edge in her graph.\n\tht.AssertNumEdges(alice, 1, true)\n\n\t// Channels should not be announced yet, hence Alice should have no\n\t// announced edges in her graph.\n\tht.AssertNumEdges(alice, 0, false)\n\n\t// Mine 4 more blocks, and check that the channel is now announced.\n\tht.MineBlocks(4)\n\n\t// Give the network a chance to learn that auth proof is confirmed.\n\tht.AssertNumEdges(alice, 1, false)\n\n\t// Close the channel used during the test.\n\tht.CloseChannel(alice, fundingChanPoint)\n}\n",
      "length": 1045,
      "tokens": 149,
      "embedding": []
    },
    {
      "slug": "func testGraphTopologyNotifications(ht *lntest.HarnessTest) {",
      "content": "func testGraphTopologyNotifications(ht *lntest.HarnessTest) {\n\tht.Run(\"pinned\", func(t *testing.T) {\n\t\tsubT := ht.Subtest(t)\n\t\ttestGraphTopologyNtfns(subT, true)\n\t})\n\tht.Run(\"unpinned\", func(t *testing.T) {\n\t\tsubT := ht.Subtest(t)\n\t\ttestGraphTopologyNtfns(subT, false)\n\t})\n}\n",
      "length": 204,
      "tokens": 21,
      "embedding": []
    },
    {
      "slug": "func testGraphTopologyNtfns(ht *lntest.HarnessTest, pinned bool) {",
      "content": "func testGraphTopologyNtfns(ht *lntest.HarnessTest, pinned bool) {\n\tconst chanAmt = funding.MaxBtcFundingAmount\n\n\t// Spin up Bob first, since we will need to grab his pubkey when\n\t// starting Alice to test pinned syncing.\n\tbob := ht.Bob\n\tbobInfo := bob.RPC.GetInfo()\n\tbobPubkey := bobInfo.IdentityPubkey\n\n\t// Restart Bob as he may have leftover announcements from previous\n\t// tests, causing the graph to be unsynced.\n\tht.RestartNodeWithExtraArgs(bob, nil)\n\n\t// For unpinned syncing, start Alice as usual. Otherwise grab Bob's\n\t// pubkey to include in his pinned syncer set.\n\tvar aliceArgs []string\n\tif pinned {\n\t\taliceArgs = []string{\n\t\t\t\"--numgraphsyncpeers=0\",\n\t\t\tfmt.Sprintf(\"--gossip.pinned-syncers=%s\", bobPubkey),\n\t\t}\n\t}\n\n\talice := ht.Alice\n\tht.RestartNodeWithExtraArgs(alice, aliceArgs)\n\n\t// Connect Alice and Bob.\n\tht.EnsureConnected(alice, bob)\n\n\t// Assert that Bob has the correct sync type before proceeding.\n\tif pinned {\n\t\tassertSyncType(ht, alice, bobPubkey, lnrpc.Peer_PINNED_SYNC)\n\t} else {\n\t\tassertSyncType(ht, alice, bobPubkey, lnrpc.Peer_ACTIVE_SYNC)\n\t}\n\n\t// Regardless of syncer type, ensure that both peers report having\n\t// completed their initial sync before continuing to make a channel.\n\tht.WaitForGraphSync(alice)\n\n\t// Open a new channel between Alice and Bob.\n\tchanPoint := ht.OpenChannel(\n\t\talice, bob, lntest.OpenChannelParams{Amt: chanAmt},\n\t)\n\n\t// The channel opening above should have triggered a few notifications\n\t// sent to the notification client. We'll expect two channel updates,\n\t// and two node announcements.\n\tht.AssertNumChannelUpdates(alice, chanPoint, 2)\n\tht.AssertNumNodeAnns(alice, alice.PubKeyStr, 1)\n\tht.AssertNumNodeAnns(alice, bob.PubKeyStr, 1)\n\n\t_, blockHeight := ht.Miner.GetBestBlock()\n\n\t// Now we'll test that updates are properly sent after channels are\n\t// closed within the network.\n\tht.CloseChannel(alice, chanPoint)\n\n\t// Now that the channel has been closed, we should receive a\n\t// notification indicating so.\n\tclosedChan := ht.AssertTopologyChannelClosed(alice, chanPoint)\n\n\trequire.Equal(ht, uint32(blockHeight+1), closedChan.ClosedHeight,\n\t\t\"close heights of channel mismatch\")\n\n\tfundingTxid := ht.OutPointFromChannelPoint(chanPoint)\n\tcloseTxid := ht.OutPointFromChannelPoint(closedChan.ChanPoint)\n\trequire.EqualValues(ht, fundingTxid, closeTxid,\n\t\t\"channel point hash mismatch\")\n\n\t// For the final portion of the test, we'll ensure that once a new node\n\t// appears in the network, the proper notification is dispatched. Note\n\t// that a node that does not have any channels open is ignored, so\n\t// first we disconnect Alice and Bob, open a channel between Bob and\n\t// Carol, and finally connect Alice to Bob again.\n\tht.DisconnectNodes(bob, alice)\n\n\t// Since Alice and Bob has a permanent connection, the above\n\t// disconnection won't be enough as Alice will try to reconnect to Bob\n\t// again. Atm, it seems nothing is stopping the reconnection. So we\n\t// need to shutdown Alice here.\n\t//\n\t// TODO(yy): clearly define what `disconnectpeer` rpc is responsible\n\t// for and its effect. If we disconnect a peer, we shouldn't allow the\n\t// peer to connect to us again.\n\trestartAlice := ht.SuspendNode(alice)\n\n\tcarol := ht.NewNode(\"Carol\", nil)\n\tht.ConnectNodes(bob, carol)\n\tchanPoint = ht.OpenChannel(\n\t\tbob, carol, lntest.OpenChannelParams{Amt: chanAmt},\n\t)\n\n\t// Restart Alice so she can receive the channel updates from Bob.\n\trequire.NoError(ht, restartAlice(), \"failed to restart Alice\")\n\n\t// Reconnect Alice and Bob. This should result in the nodes syncing up\n\t// their respective graph state, with the new addition being the\n\t// existence of Carol in the graph, and also the channel between Bob\n\t// and Carol. Note that we will also receive a node announcement from\n\t// Bob, since a node will update its node announcement after a new\n\t// channel is opened.\n\tht.EnsureConnected(alice, bob)\n\n\t// We should receive an update advertising the newly connected node,\n\t// Bob's new node announcement, and the channel between Bob and Carol.\n\tht.AssertNumChannelUpdates(alice, chanPoint, 2)\n\tht.AssertNumNodeAnns(alice, bob.PubKeyStr, 1)\n\n\t// Close the channel between Bob and Carol.\n\tht.CloseChannel(bob, chanPoint)\n}\n\n// testNodeAnnouncement ensures that when a node is started with one or more\n// external IP addresses specified on the command line, that those addresses\n// announced to the network and reported in the network graph.",
      "length": 4207,
      "tokens": 584,
      "embedding": []
    },
    {
      "slug": "func testNodeAnnouncement(ht *lntest.HarnessTest) {",
      "content": "func testNodeAnnouncement(ht *lntest.HarnessTest) {\n\talice, bob := ht.Alice, ht.Bob\n\n\tadvertisedAddrs := []string{\n\t\t\"192.168.1.1:8333\",\n\t\t\"[2001:db8:85a3:8d3:1319:8a2e:370:7348]:8337\",\n\t\t\"bkb6azqggsaiskzi.onion:9735\",\n\t\t\"fomvuglh6h6vcag73xo5t5gv56ombih3zr2xvplkpbfd7wrog4swj\" +\n\t\t\t\"wid.onion:1234\",\n\t}\n\n\tvar lndArgs []string\n\tfor _, addr := range advertisedAddrs {\n\t\tlndArgs = append(lndArgs, \"--externalip=\"+addr)\n\t}\n\n\tdave := ht.NewNode(\"Dave\", lndArgs)\n\n\t// We must let Dave have an open channel before he can send a node\n\t// announcement, so we open a channel with Bob,\n\tht.ConnectNodes(bob, dave)\n\n\t// We'll then go ahead and open a channel between Bob and Dave. This\n\t// ensures that Alice receives the node announcement from Bob as part of\n\t// the announcement broadcast.\n\tchanPoint := ht.OpenChannel(\n\t\tbob, dave, lntest.OpenChannelParams{Amt: 1000000},\n\t)\n\n\tassertAddrs := func(addrsFound []string, targetAddrs ...string) {\n\t\taddrs := make(map[string]struct{}, len(addrsFound))\n\t\tfor _, addr := range addrsFound {\n\t\t\taddrs[addr] = struct{}{}\n\t\t}\n\n\t\tfor _, addr := range targetAddrs {\n\t\t\t_, ok := addrs[addr]\n\t\t\trequire.True(ht, ok, \"address %v not found in node \"+\n\t\t\t\t\"announcement\", addr)\n\t\t}\n\t}\n\t// We'll then wait for Alice to receive Dave's node announcement\n\t// including the expected advertised addresses from Bob since they\n\t// should already be connected.\n\tallUpdates := ht.AssertNumNodeAnns(alice, dave.PubKeyStr, 1)\n\tnodeUpdate := allUpdates[len(allUpdates)-1]\n\tassertAddrs(nodeUpdate.Addresses, advertisedAddrs...)\n\n\t// Close the channel between Bob and Dave.\n\tht.CloseChannel(bob, chanPoint)\n}\n\n// testUpdateNodeAnnouncement ensures that the RPC endpoint validates\n// the requests correctly and that the new node announcement is brodcasted\n// with the right information after updating our node.",
      "length": 1712,
      "tokens": 221,
      "embedding": []
    },
    {
      "slug": "func testUpdateNodeAnnouncement(ht *lntest.HarnessTest) {",
      "content": "func testUpdateNodeAnnouncement(ht *lntest.HarnessTest) {\n\talice, bob := ht.Alice, ht.Bob\n\n\tvar lndArgs []string\n\n\t// Add some exta addresses to the default ones.\n\textraAddrs := []string{\n\t\t\"192.168.1.1:8333\",\n\t\t\"[2001:db8:85a3:8d3:1319:8a2e:370:7348]:8337\",\n\t\t\"bkb6azqggsaiskzi.onion:9735\",\n\t\t\"fomvuglh6h6vcag73xo5t5gv56ombih3zr2xvplkpbfd7wrog4swj\" +\n\t\t\t\"wid.onion:1234\",\n\t}\n\tfor _, addr := range extraAddrs {\n\t\tlndArgs = append(lndArgs, \"--externalip=\"+addr)\n\t}\n\tdave := ht.NewNode(\"Dave\", lndArgs)\n\n\t// assertNodeAnn is a helper closure that checks a given node update\n\t// from Dave is seen by Alice.\n\tassertNodeAnn := func(expected *lnrpc.NodeUpdate) {\n\t\terr := wait.NoError(func() error {\n\t\t\t// Get a list of node updates seen by Alice.\n\t\t\tupdates := alice.Watcher.GetNodeUpdates(dave.PubKeyStr)\n\n\t\t\t// Check at least one of the updates matches the given\n\t\t\t// node update.\n\t\t\tfor _, update := range updates {\n\t\t\t\terr := compareNodeAnns(update, expected)\n\t\t\t\t// Found a match, return nil.\n\t\t\t\tif err == nil {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// We've check all the updates and no match found.\n\t\t\treturn fmt.Errorf(\"alice didn't see the update: %v\",\n\t\t\t\texpected)\n\t\t}, defaultTimeout)\n\n\t\trequire.NoError(ht, err, \"assertNodeAnn failed\")\n\t}\n\n\t// Get dave default information so we can compare it lately with the\n\t// brodcasted updates.\n\tresp := dave.RPC.GetInfo()\n\tdefaultAddrs := make([]*lnrpc.NodeAddress, 0, len(resp.Uris))\n\tfor _, uri := range resp.GetUris() {\n\t\tvalues := strings.Split(uri, \"@\")\n\t\tdefaultAddrs = append(\n\t\t\tdefaultAddrs, &lnrpc.NodeAddress{\n\t\t\t\tAddr:    values[1],\n\t\t\t\tNetwork: \"tcp\",\n\t\t\t},\n\t\t)\n\t}\n\n\t// This feature bit is used to test that our endpoint sets/unsets\n\t// feature bits properly. If the current FeatureBit is set by default\n\t// update this one for another one unset by default at random.\n\tfeatureBit := lnrpc.FeatureBit_WUMBO_CHANNELS_REQ\n\tfeatureIdx := uint32(featureBit)\n\t_, ok := resp.Features[featureIdx]\n\trequire.False(ht, ok, \"unexpected feature bit enabled by default\")\n\n\tdefaultDaveNodeAnn := &lnrpc.NodeUpdate{\n\t\tAlias:         resp.Alias,\n\t\tColor:         resp.Color,\n\t\tNodeAddresses: defaultAddrs,\n\t}\n\n\t// Dave must have an open channel before he can send a node\n\t// announcement, so we open a channel with Bob.\n\tht.ConnectNodes(bob, dave)\n\n\t// Go ahead and open a channel between Bob and Dave. This\n\t// ensures that Alice receives the node announcement from Bob as part of\n\t// the announcement broadcast.\n\tchanPoint := ht.OpenChannel(\n\t\tbob, dave, lntest.OpenChannelParams{\n\t\t\tAmt: 1000000,\n\t\t},\n\t)\n\n\t// Wait for Alice to receive dave's node announcement with the default\n\t// values.\n\tassertNodeAnn(defaultDaveNodeAnn)\n\n\t// We cannot differentiate between requests with Alias = \"\" and\n\t// requests that do not provide that field. If a user sets Alias = \"\"\n\t// in the request the field will simply be ignored. The request must\n\t// fail because no modifiers are applied.\n\tinvalidNodeAnnReq := &peersrpc.NodeAnnouncementUpdateRequest{Alias: \"\"}\n\tdave.RPC.UpdateNodeAnnouncementErr(invalidNodeAnnReq)\n\n\t// Alias too long.\n\tinvalidNodeAnnReq = &peersrpc.NodeAnnouncementUpdateRequest{\n\t\tAlias: strings.Repeat(\"a\", 50),\n\t}\n\tdave.RPC.UpdateNodeAnnouncementErr(invalidNodeAnnReq)\n\n\t// Update Node.\n\tnewAlias := \"new-alias\"\n\tnewColor := \"#2288ee\"\n\n\tnewAddresses := []string{\n\t\t\"192.168.1.10:8333\",\n\t\t\"192.168.1.11:8333\",\n\t}\n\n\tupdateAddressActions := []*peersrpc.UpdateAddressAction{\n\t\t{\n\t\t\tAction:  peersrpc.UpdateAction_ADD,\n\t\t\tAddress: newAddresses[0],\n\t\t},\n\t\t{\n\t\t\tAction:  peersrpc.UpdateAction_ADD,\n\t\t\tAddress: newAddresses[1],\n\t\t},\n\t\t{\n\t\t\tAction:  peersrpc.UpdateAction_REMOVE,\n\t\t\tAddress: defaultAddrs[0].Addr,\n\t\t},\n\t}\n\n\tupdateFeatureActions := []*peersrpc.UpdateFeatureAction{\n\t\t{\n\t\t\tAction:     peersrpc.UpdateAction_ADD,\n\t\t\tFeatureBit: featureBit,\n\t\t},\n\t}\n\n\tnodeAnnReq := &peersrpc.NodeAnnouncementUpdateRequest{\n\t\tAlias:          newAlias,\n\t\tColor:          newColor,\n\t\tAddressUpdates: updateAddressActions,\n\t\tFeatureUpdates: updateFeatureActions,\n\t}\n\n\tresponse := dave.RPC.UpdateNodeAnnouncement(nodeAnnReq)\n\n\texpectedOps := map[string]int{\n\t\t\"features\":  1,\n\t\t\"color\":     1,\n\t\t\"alias\":     1,\n\t\t\"addresses\": 3,\n\t}\n\tassertUpdateNodeAnnouncementResponse(ht, response, expectedOps)\n\n\tnewNodeAddresses := []*lnrpc.NodeAddress{}\n\t// We removed the first address.\n\tnewNodeAddresses = append(newNodeAddresses, defaultAddrs[1:]...)\n\tnewNodeAddresses = append(\n\t\tnewNodeAddresses,\n\t\t&lnrpc.NodeAddress{Addr: newAddresses[0], Network: \"tcp\"},\n\t\t&lnrpc.NodeAddress{Addr: newAddresses[1], Network: \"tcp\"},\n\t)\n\n\t// After updating the node we expect the update to contain\n\t// the requested color, requested alias and the new added addresses.\n\tnewDaveNodeAnn := &lnrpc.NodeUpdate{\n\t\tAlias:         newAlias,\n\t\tColor:         newColor,\n\t\tNodeAddresses: newNodeAddresses,\n\t}\n\n\t// We'll then wait for Alice to receive dave's node announcement\n\t// with the new values.\n\tassertNodeAnn(newDaveNodeAnn)\n\n\t// Check that the feature bit was set correctly.\n\tresp = dave.RPC.GetInfo()\n\t_, ok = resp.Features[featureIdx]\n\trequire.True(ht, ok, \"failed to set feature bit\")\n\n\t// Check that we cannot set a feature bit that is already set.\n\tnodeAnnReq = &peersrpc.NodeAnnouncementUpdateRequest{\n\t\tFeatureUpdates: updateFeatureActions,\n\t}\n\tdave.RPC.UpdateNodeAnnouncementErr(nodeAnnReq)\n\n\t// Check that we can unset feature bits.\n\tupdateFeatureActions = []*peersrpc.UpdateFeatureAction{\n\t\t{\n\t\t\tAction:     peersrpc.UpdateAction_REMOVE,\n\t\t\tFeatureBit: featureBit,\n\t\t},\n\t}\n\n\tnodeAnnReq = &peersrpc.NodeAnnouncementUpdateRequest{\n\t\tFeatureUpdates: updateFeatureActions,\n\t}\n\tresponse = dave.RPC.UpdateNodeAnnouncement(nodeAnnReq)\n\n\texpectedOps = map[string]int{\n\t\t\"features\": 1,\n\t}\n\tassertUpdateNodeAnnouncementResponse(ht, response, expectedOps)\n\n\tresp = dave.RPC.GetInfo()\n\t_, ok = resp.Features[featureIdx]\n\trequire.False(ht, ok, \"failed to unset feature bit\")\n\n\t// Check that we cannot unset a feature bit that is already unset.\n\tnodeAnnReq = &peersrpc.NodeAnnouncementUpdateRequest{\n\t\tFeatureUpdates: updateFeatureActions,\n\t}\n\tdave.RPC.UpdateNodeAnnouncementErr(nodeAnnReq)\n\n\t// Close the channel between Bob and Dave.\n\tht.CloseChannel(bob, chanPoint)\n}\n\n// assertSyncType asserts that the peer has an expected syncType.\n//\n// NOTE: only made for tests in this file.",
      "length": 6016,
      "tokens": 698,
      "embedding": []
    },
    {
      "slug": "func assertSyncType(ht *lntest.HarnessTest, hn *node.HarnessNode,",
      "content": "func assertSyncType(ht *lntest.HarnessTest, hn *node.HarnessNode,\n\tpeer string, syncType lnrpc.Peer_SyncType) {\n\n\tresp := hn.RPC.ListPeers()\n\tfor _, rpcPeer := range resp.Peers {\n\t\tif rpcPeer.PubKey != peer {\n\t\t\tcontinue\n\t\t}\n\n\t\trequire.Equal(ht, syncType, rpcPeer.SyncType)\n\n\t\treturn\n\t}\n\n\tht.Fatalf(\"unable to find peer: %s\", peer)\n}\n\n// compareNodeAnns compares that two node announcements match or returns an\n// error.\n//\n// NOTE: only used for tests in this file.",
      "length": 381,
      "tokens": 57,
      "embedding": []
    },
    {
      "slug": "func compareNodeAnns(n1, n2 *lnrpc.NodeUpdate) error {",
      "content": "func compareNodeAnns(n1, n2 *lnrpc.NodeUpdate) error {\n\t// Alias should match.\n\tif n1.Alias != n2.Alias {\n\t\treturn fmt.Errorf(\"alias not match\")\n\t}\n\n\t// Color should match.\n\tif n1.Color != n2.Color {\n\t\treturn fmt.Errorf(\"color not match\")\n\t}\n\n\t// NodeAddresses should match.\n\tif len(n1.NodeAddresses) != len(n2.NodeAddresses) {\n\t\treturn fmt.Errorf(\"node addresses don't match\")\n\t}\n\n\taddrs := make(map[string]struct{}, len(n1.NodeAddresses))\n\tfor _, nodeAddr := range n1.NodeAddresses {\n\t\taddrs[nodeAddr.Addr] = struct{}{}\n\t}\n\n\tfor _, nodeAddr := range n2.NodeAddresses {\n\t\tif _, ok := addrs[nodeAddr.Addr]; !ok {\n\t\t\treturn fmt.Errorf(\"address %v not found in node \"+\n\t\t\t\t\"announcement\", nodeAddr.Addr)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// assertUpdateNodeAnnouncementResponse is a helper function to assert\n// the response expected values.\n//\n// NOTE: only used for tests in this file.",
      "length": 786,
      "tokens": 110,
      "embedding": []
    },
    {
      "slug": "func assertUpdateNodeAnnouncementResponse(ht *lntest.HarnessTest,",
      "content": "func assertUpdateNodeAnnouncementResponse(ht *lntest.HarnessTest,\n\tresponse *peersrpc.NodeAnnouncementUpdateResponse,\n\texpectedOps map[string]int) {\n\n\trequire.Equal(\n\t\tht, len(response.Ops), len(expectedOps),\n\t\t\"unexpected number of Ops updating dave's node announcement\",\n\t)\n\n\tops := make(map[string]int, len(response.Ops))\n\tfor _, op := range response.Ops {\n\t\tops[op.Entity] = len(op.Actions)\n\t}\n\n\tfor k, v := range expectedOps {\n\t\tif v != ops[k] {\n\t\t\tht.Fatalf(\"unexpected number of actions for operation \"+\n\t\t\t\t\"%s: got %d wanted %d\", k, ops[k], v)\n\t\t}\n\t}\n}\n",
      "length": 476,
      "tokens": 63,
      "embedding": []
    }
  ]
}