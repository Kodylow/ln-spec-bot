{
  "filepath": "../implementations/go/lnd/itest/lnd_multi-hop-error-propagation_test.go",
  "package": "itest",
  "sections": [
    {
      "slug": "func testHtlcErrorPropagation(ht *lntest.HarnessTest) {",
      "content": "func testHtlcErrorPropagation(ht *lntest.HarnessTest) {\n\t// In this test we wish to exercise the daemon's correct parsing,\n\t// handling, and propagation of errors that occur while processing a\n\t// multi-hop payment.\n\tconst chanAmt = funding.MaxBtcFundingAmount\n\n\talice, bob := ht.Alice, ht.Bob\n\n\t// Since we'd like to test some multi-hop failure scenarios, we'll\n\t// introduce another node into our test network: Carol.\n\tcarol := ht.NewNode(\"Carol\", nil)\n\tht.ConnectNodes(bob, carol)\n\n\t// Before we start sending payments, subscribe to htlc events for each\n\t// node.\n\taliceEvents := alice.RPC.SubscribeHtlcEvents()\n\tbobEvents := bob.RPC.SubscribeHtlcEvents()\n\tcarolEvents := carol.RPC.SubscribeHtlcEvents()\n\n\t// Once subscribed, the first event will be UNKNOWN.\n\tht.AssertHtlcEventType(aliceEvents, routerrpc.HtlcEvent_UNKNOWN)\n\tht.AssertHtlcEventType(bobEvents, routerrpc.HtlcEvent_UNKNOWN)\n\tht.AssertHtlcEventType(carolEvents, routerrpc.HtlcEvent_UNKNOWN)\n\n\t// First establish a channel with a capacity of 0.5 BTC between Alice\n\t// and Bob.\n\tchanPointAlice := ht.OpenChannel(\n\t\talice, bob,\n\t\tlntest.OpenChannelParams{Amt: chanAmt},\n\t)\n\n\t// Next, we'll create a connection from Bob to Carol, and open a\n\t// channel between them so we have the topology: Alice -> Bob -> Carol.\n\t// The channel created will be of lower capacity that the one created\n\t// above.\n\tchanPointBob := ht.OpenChannel(\n\t\tbob, carol, lntest.OpenChannelParams{Amt: chanAmt},\n\t)\n\n\t// Ensure that Alice has Carol in her routing table before proceeding.\n\tht.AssertTopologyChannelOpen(alice, chanPointBob)\n\n\tcType := ht.GetChannelCommitType(alice, chanPointAlice)\n\tcommitFee := lntest.CalcStaticFee(cType, 0)\n\n\tassertBaseBalance := func() {\n\t\t// Alice has opened a channel with Bob with zero push amount,\n\t\t// so it's remote balance is zero.\n\t\texpBalanceAlice := &lnrpc.ChannelBalanceResponse{\n\t\t\tLocalBalance: &lnrpc.Amount{\n\t\t\t\tSat: uint64(chanAmt - commitFee),\n\t\t\t\tMsat: uint64(lnwire.NewMSatFromSatoshis(\n\t\t\t\t\tchanAmt - commitFee,\n\t\t\t\t)),\n\t\t\t},\n\t\t\tRemoteBalance:            &lnrpc.Amount{},\n\t\t\tUnsettledLocalBalance:    &lnrpc.Amount{},\n\t\t\tUnsettledRemoteBalance:   &lnrpc.Amount{},\n\t\t\tPendingOpenLocalBalance:  &lnrpc.Amount{},\n\t\t\tPendingOpenRemoteBalance: &lnrpc.Amount{},\n\t\t\t// Deprecated fields.\n\t\t\tBalance: int64(chanAmt - commitFee),\n\t\t}\n\t\tht.AssertChannelBalanceResp(alice, expBalanceAlice)\n\n\t\t// Bob has a channel with Alice and another with Carol, so it's\n\t\t// local and remote balances are both chanAmt - commitFee.\n\t\texpBalanceBob := &lnrpc.ChannelBalanceResponse{\n\t\t\tLocalBalance: &lnrpc.Amount{\n\t\t\t\tSat: uint64(chanAmt - commitFee),\n\t\t\t\tMsat: uint64(lnwire.NewMSatFromSatoshis(\n\t\t\t\t\tchanAmt - commitFee,\n\t\t\t\t)),\n\t\t\t},\n\t\t\tRemoteBalance: &lnrpc.Amount{\n\t\t\t\tSat: uint64(chanAmt - commitFee),\n\t\t\t\tMsat: uint64(lnwire.NewMSatFromSatoshis(\n\t\t\t\t\tchanAmt - commitFee,\n\t\t\t\t)),\n\t\t\t},\n\t\t\tUnsettledLocalBalance:    &lnrpc.Amount{},\n\t\t\tUnsettledRemoteBalance:   &lnrpc.Amount{},\n\t\t\tPendingOpenLocalBalance:  &lnrpc.Amount{},\n\t\t\tPendingOpenRemoteBalance: &lnrpc.Amount{},\n\t\t\t// Deprecated fields.\n\t\t\tBalance: int64(chanAmt - commitFee),\n\t\t}\n\t\tht.AssertChannelBalanceResp(bob, expBalanceBob)\n\t}\n\n\t// assertLinkFailure checks that the stream provided has a single link\n\t// failure the failure detail provided.\n\tassertLinkFailure := func(event *routerrpc.HtlcEvent,\n\t\tfailureDetail routerrpc.FailureDetail) {\n\n\t\tlinkFail, ok := event.Event.(*routerrpc.HtlcEvent_LinkFailEvent)\n\t\trequire.Truef(ht, ok, \"expected forwarding failure, got: %T\",\n\t\t\tlinkFail)\n\n\t\trequire.Equal(ht, failureDetail,\n\t\t\tlinkFail.LinkFailEvent.FailureDetail,\n\t\t\t\"wrong link fail detail\")\n\t}\n\n\t// With the channels, open we can now start to test our multi-hop error\n\t// scenarios. First, we'll generate an invoice from carol that we'll\n\t// use to test some error cases.\n\tconst payAmt = 10000\n\tinvoiceReq := &lnrpc.Invoice{\n\t\tMemo:  \"kek99\",\n\t\tValue: payAmt,\n\t}\n\n\tcarolInvoice := carol.RPC.AddInvoice(invoiceReq)\n\tcarolPayReq := carol.RPC.DecodePayReq(carolInvoice.PaymentRequest)\n\n\t// For the first scenario, we'll test the cancellation of an HTLC with\n\t// an unknown payment hash.\n\tsendReq := &routerrpc.SendPaymentRequest{\n\t\tPaymentHash:    ht.Random32Bytes(),\n\t\tDest:           carol.PubKey[:],\n\t\tAmt:            payAmt,\n\t\tFinalCltvDelta: int32(carolPayReq.CltvExpiry),\n\t\tTimeoutSeconds: 60,\n\t\tFeeLimitMsat:   noFeeLimitMsat,\n\t\tMaxParts:       1,\n\t}\n\tht.SendPaymentAssertFail(\n\t\talice, sendReq,\n\t\tlnrpc.PaymentFailureReason_FAILURE_REASON_INCORRECT_PAYMENT_DETAILS, //nolint:lll\n\t)\n\tht.AssertLastHTLCError(\n\t\talice, lnrpc.Failure_INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS,\n\t)\n\n\t// assertAliceAndBob is a helper closure that asserts Alice and Bob\n\t// each has one forward and one forward fail event, and Bob has the\n\t// final htlc fail event.\n\tassertAliceAndBob := func() {\n\t\tht.AssertHtlcEventTypes(\n\t\t\taliceEvents, routerrpc.HtlcEvent_SEND,\n\t\t\tlntest.HtlcEventForward,\n\t\t)\n\t\tht.AssertHtlcEventTypes(\n\t\t\taliceEvents, routerrpc.HtlcEvent_SEND,\n\t\t\tlntest.HtlcEventForwardFail,\n\t\t)\n\n\t\tht.AssertHtlcEventTypes(\n\t\t\tbobEvents, routerrpc.HtlcEvent_FORWARD,\n\t\t\tlntest.HtlcEventForward,\n\t\t)\n\t\tht.AssertHtlcEventTypes(\n\t\t\tbobEvents, routerrpc.HtlcEvent_FORWARD,\n\t\t\tlntest.HtlcEventForwardFail,\n\t\t)\n\t\tht.AssertHtlcEventTypes(\n\t\t\tbobEvents, routerrpc.HtlcEvent_UNKNOWN,\n\t\t\tlntest.HtlcEventFinal,\n\t\t)\n\t}\n\n\t// We expect alice and bob to each have one forward and one forward\n\t// fail event at this stage.\n\tassertAliceAndBob()\n\n\t// Carol should have a link failure because the htlc failed on her\n\t// incoming link.\n\tevent := ht.AssertHtlcEventType(\n\t\tcarolEvents, routerrpc.HtlcEvent_RECEIVE,\n\t)\n\tassertLinkFailure(event, routerrpc.FailureDetail_UNKNOWN_INVOICE)\n\n\t// There's also a final htlc event that gives the final outcome of the\n\t// htlc.\n\tht.AssertHtlcEventTypes(\n\t\tcarolEvents, routerrpc.HtlcEvent_UNKNOWN, lntest.HtlcEventFinal,\n\t)\n\n\t// The balances of all parties should be the same as initially since\n\t// the HTLC was canceled.\n\tassertBaseBalance()\n\n\t// Next, we'll test the case of a recognized payHash but, an incorrect\n\t// value on the extended HTLC.\n\thtlcAmt := lnwire.NewMSatFromSatoshis(1000)\n\tsendReq = &routerrpc.SendPaymentRequest{\n\t\tPaymentHash: carolInvoice.RHash,\n\t\tDest:        carol.PubKey[:],\n\t\t// 10k satoshis are expected.\n\t\tAmt:            int64(htlcAmt.ToSatoshis()),\n\t\tFinalCltvDelta: int32(carolPayReq.CltvExpiry),\n\t\tTimeoutSeconds: 60,\n\t\tFeeLimitMsat:   noFeeLimitMsat,\n\t\tMaxParts:       1,\n\t}\n\tht.SendPaymentAssertFail(\n\t\talice, sendReq,\n\t\tlnrpc.PaymentFailureReason_FAILURE_REASON_INCORRECT_PAYMENT_DETAILS, //nolint:lll\n\t)\n\tht.AssertLastHTLCError(\n\t\talice, lnrpc.Failure_INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS,\n\t)\n\n\t// We expect alice and bob to each have one forward and one forward\n\t// fail event at this stage.\n\tassertAliceAndBob()\n\n\t// Carol should have a link failure because the htlc failed on her\n\t// incoming link.\n\tevent = ht.AssertHtlcEventType(carolEvents, routerrpc.HtlcEvent_RECEIVE)\n\tassertLinkFailure(event, routerrpc.FailureDetail_INVOICE_UNDERPAID)\n\n\t// There's also a final htlc event that gives the final outcome of the\n\t// htlc.\n\tht.AssertHtlcEventTypes(\n\t\tcarolEvents, routerrpc.HtlcEvent_UNKNOWN, lntest.HtlcEventFinal,\n\t)\n\n\t// The balances of all parties should be the same as initially since\n\t// the HTLC was canceled.\n\tassertBaseBalance()\n\n\t// Next we'll test an error that occurs mid-route due to an outgoing\n\t// link having insufficient capacity. In order to do so, we'll first\n\t// need to unbalance the link connecting Bob<->Carol.\n\t//\n\t// To do so, we'll push most of the funds in the channel over to\n\t// Alice's side, leaving on 10k satoshis of available balance for bob.\n\t// There's a max payment amount, so we'll have to do this\n\t// incrementally.\n\tchanReserve := int64(chanAmt / 100)\n\tamtToSend := int64(chanAmt) - chanReserve - 20000\n\tamtSent := int64(0)\n\tfor amtSent != amtToSend {\n\t\t// We'll send in chunks of the max payment amount. If we're\n\t\t// about to send too much, then we'll only send the amount\n\t\t// remaining.\n\t\ttoSend := int64(math.MaxUint32)\n\t\tif toSend+amtSent > amtToSend {\n\t\t\ttoSend = amtToSend - amtSent\n\t\t}\n\n\t\tinvoiceReq = &lnrpc.Invoice{\n\t\t\tValue: toSend,\n\t\t}\n\t\tcarolInvoice2 := carol.RPC.AddInvoice(invoiceReq)\n\n\t\treq := &routerrpc.SendPaymentRequest{\n\t\t\tPaymentRequest: carolInvoice2.PaymentRequest,\n\t\t\tTimeoutSeconds: 60,\n\t\t\tFeeLimitMsat:   noFeeLimitMsat,\n\t\t\tMaxParts:       1,\n\t\t}\n\t\tht.SendPaymentAndAssertStatus(bob, req, lnrpc.Payment_SUCCEEDED)\n\n\t\t// For each send bob makes, we need to check that bob has a\n\t\t// forward and settle event for his send, and carol has a\n\t\t// settle event and a final htlc event for her receive.\n\t\tht.AssertHtlcEventTypes(\n\t\t\tbobEvents, routerrpc.HtlcEvent_SEND,\n\t\t\tlntest.HtlcEventForward,\n\t\t)\n\t\tht.AssertHtlcEventTypes(\n\t\t\tbobEvents, routerrpc.HtlcEvent_SEND,\n\t\t\tlntest.HtlcEventSettle,\n\t\t)\n\t\tht.AssertHtlcEventTypes(\n\t\t\tcarolEvents, routerrpc.HtlcEvent_RECEIVE,\n\t\t\tlntest.HtlcEventSettle,\n\t\t)\n\t\tht.AssertHtlcEventTypes(\n\t\t\tcarolEvents, routerrpc.HtlcEvent_UNKNOWN,\n\t\t\tlntest.HtlcEventFinal,\n\t\t)\n\n\t\tamtSent += toSend\n\t}\n\n\t// At this point, Alice has 50mil satoshis on her side of the channel,\n\t// but Bob only has 10k available on his side of the channel. So a\n\t// payment from Alice to Carol worth 100k satoshis should fail.\n\tinvoiceReq = &lnrpc.Invoice{\n\t\tValue: 100000,\n\t}\n\tcarolInvoice3 := carol.RPC.AddInvoice(invoiceReq)\n\n\tsendReq = &routerrpc.SendPaymentRequest{\n\t\tPaymentRequest: carolInvoice3.PaymentRequest,\n\t\tTimeoutSeconds: 60,\n\t\tFeeLimitMsat:   noFeeLimitMsat,\n\t\tMaxParts:       1,\n\t}\n\tht.SendPaymentAssertFail(\n\t\talice, sendReq,\n\t\tlnrpc.PaymentFailureReason_FAILURE_REASON_NO_ROUTE,\n\t)\n\tht.AssertLastHTLCError(\n\t\talice, lnrpc.Failure_TEMPORARY_CHANNEL_FAILURE,\n\t)\n\n\t// Alice should have a forwarding event and a forwarding failure.\n\tht.AssertHtlcEventTypes(\n\t\taliceEvents, routerrpc.HtlcEvent_SEND,\n\t\tlntest.HtlcEventForward,\n\t)\n\tht.AssertHtlcEventTypes(\n\t\taliceEvents, routerrpc.HtlcEvent_SEND,\n\t\tlntest.HtlcEventForwardFail,\n\t)\n\n\t// Bob should have a link failure because the htlc failed on his\n\t// outgoing link.\n\tevent = ht.AssertHtlcEventType(bobEvents, routerrpc.HtlcEvent_FORWARD)\n\tassertLinkFailure(event, routerrpc.FailureDetail_INSUFFICIENT_BALANCE)\n\n\t// There's also a final htlc event that gives the final outcome of the\n\t// htlc.\n\tht.AssertHtlcEventTypes(\n\t\tbobEvents, routerrpc.HtlcEvent_UNKNOWN, lntest.HtlcEventFinal,\n\t)\n\n\t// Generate new invoice to not pay same invoice twice.\n\tcarolInvoice = carol.RPC.AddInvoice(invoiceReq)\n\n\t// For our final test, we'll ensure that if a target link isn't\n\t// available for what ever reason then the payment fails accordingly.\n\t//\n\t// We'll attempt to complete the original invoice we created with Carol\n\t// above, but before we do so, Carol will go offline, resulting in a\n\t// failed payment.\n\tht.Shutdown(carol)\n\n\t// Reset mission control to forget the temporary channel failure above.\n\talice.RPC.ResetMissionControl()\n\n\treq := &routerrpc.SendPaymentRequest{\n\t\tPaymentRequest: carolInvoice.PaymentRequest,\n\t\tTimeoutSeconds: 60,\n\t\tFeeLimitMsat:   noFeeLimitMsat,\n\t\tMaxParts:       1,\n\t}\n\tht.SendPaymentAssertFail(\n\t\talice, req, lnrpc.PaymentFailureReason_FAILURE_REASON_NO_ROUTE,\n\t)\n\tht.AssertLastHTLCError(alice, lnrpc.Failure_UNKNOWN_NEXT_PEER)\n\n\t// Alice should have a forwarding event and subsequent fail.\n\tht.AssertHtlcEventTypes(\n\t\taliceEvents, routerrpc.HtlcEvent_SEND,\n\t\tlntest.HtlcEventForward,\n\t)\n\tht.AssertHtlcEventTypes(\n\t\taliceEvents, routerrpc.HtlcEvent_SEND,\n\t\tlntest.HtlcEventForwardFail,\n\t)\n\n\t// Bob should have a link failure because he could not find the next\n\t// peer.\n\tevent = ht.AssertHtlcEventType(bobEvents, routerrpc.HtlcEvent_FORWARD)\n\tassertLinkFailure(event, routerrpc.FailureDetail_NO_DETAIL)\n\n\t// There's also a final htlc event that gives the final outcome of the\n\t// htlc.\n\tht.AssertHtlcEventTypes(\n\t\tbobEvents, routerrpc.HtlcEvent_UNKNOWN, lntest.HtlcEventFinal,\n\t)\n\n\t// Finally, immediately close the channel. This function will also\n\t// block until the channel is closed and will additionally assert the\n\t// relevant channel closing post conditions.\n\tht.CloseChannel(alice, chanPointAlice)\n\n\t// Force close Bob's final channel.\n\tht.ForceCloseChannel(bob, chanPointBob)\n}\n",
      "length": 11793,
      "tokens": 1303,
      "embedding": []
    }
  ]
}