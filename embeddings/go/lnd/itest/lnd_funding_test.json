{
  "filepath": "../implementations/go/lnd/itest/lnd_funding_test.go",
  "package": "itest",
  "sections": [
    {
      "slug": "func testBasicChannelFunding(ht *lntest.HarnessTest) {",
      "content": "func testBasicChannelFunding(ht *lntest.HarnessTest) {\n\t// Run through the test with combinations of all the different\n\t// commitment types.\n\tallTypes := []lnrpc.CommitmentType{\n\t\tlnrpc.CommitmentType_LEGACY,\n\t\tlnrpc.CommitmentType_STATIC_REMOTE_KEY,\n\t\tlnrpc.CommitmentType_ANCHORS,\n\t}\n\n\t// testFunding is a function closure that takes Carol and Dave's\n\t// commitment types and test the funding flow.\n\ttestFunding := func(ht *lntest.HarnessTest, carolCommitType,\n\t\tdaveCommitType lnrpc.CommitmentType) {\n\n\t\t// Based on the current tweak variable for Carol, we'll\n\t\t// preferentially signal the legacy commitment format.  We do\n\t\t// the same for Dave shortly below.\n\t\tcarolArgs := lntest.NodeArgsForCommitType(carolCommitType)\n\t\tcarol := ht.NewNode(\"Carol\", carolArgs)\n\n\t\t// Each time, we'll send Carol a new set of coins in order to\n\t\t// fund the channel.\n\t\tht.FundCoins(btcutil.SatoshiPerBitcoin, carol)\n\n\t\tdaveArgs := lntest.NodeArgsForCommitType(daveCommitType)\n\t\tdave := ht.NewNode(\"Dave\", daveArgs)\n\n\t\t// Before we start the test, we'll ensure both sides are\n\t\t// connected to the funding flow can properly be executed.\n\t\tht.EnsureConnected(carol, dave)\n\n\t\tcarolChan, daveChan, closeChan := basicChannelFundingTest(\n\t\t\tht, carol, dave, nil,\n\t\t)\n\n\t\t// Both nodes should report the same commitment\n\t\t// type.\n\t\tchansCommitType := carolChan.CommitmentType\n\t\trequire.Equal(ht, chansCommitType, daveChan.CommitmentType,\n\t\t\t\"commit types don't match\")\n\n\t\t// Now check that the commitment type reported by both nodes is\n\t\t// what we expect. It will be the minimum of the two nodes'\n\t\t// preference, in the order Legacy, Tweakless, Anchors.\n\t\texpType := carolCommitType\n\n\t\tswitch daveCommitType {\n\t\t// Dave supports anchors, type will be what Carol supports.\n\t\tcase lnrpc.CommitmentType_ANCHORS:\n\n\t\t// Dave only supports tweakless, channel will be downgraded to\n\t\t// this type if Carol supports anchors.\n\t\tcase lnrpc.CommitmentType_STATIC_REMOTE_KEY:\n\t\t\tif expType == lnrpc.CommitmentType_ANCHORS {\n\t\t\t\texpType = lnrpc.CommitmentType_STATIC_REMOTE_KEY\n\t\t\t}\n\n\t\t// Dave only supoprts legacy type, channel will be downgraded\n\t\t// to this type.\n\t\tcase lnrpc.CommitmentType_LEGACY:\n\t\t\texpType = lnrpc.CommitmentType_LEGACY\n\n\t\tdefault:\n\t\t\tht.Fatalf(\"invalid commit type %v\", daveCommitType)\n\t\t}\n\n\t\t// Check that the signalled type matches what we expect.\n\t\tswitch {\n\t\tcase expType == lnrpc.CommitmentType_ANCHORS &&\n\t\t\tchansCommitType == lnrpc.CommitmentType_ANCHORS:\n\n\t\tcase expType == lnrpc.CommitmentType_STATIC_REMOTE_KEY &&\n\t\t\tchansCommitType == lnrpc.CommitmentType_STATIC_REMOTE_KEY:\n\n\t\tcase expType == lnrpc.CommitmentType_LEGACY &&\n\t\t\tchansCommitType == lnrpc.CommitmentType_LEGACY:\n\n\t\tdefault:\n\t\t\tht.Fatalf(\"expected nodes to signal \"+\n\t\t\t\t\"commit type %v, instead got \"+\n\t\t\t\t\"%v\", expType, chansCommitType)\n\t\t}\n\n\t\t// As we've concluded this sub-test case we'll now close out\n\t\t// the channel for both sides.\n\t\tcloseChan()\n\t}\n\ntest:\n\t// We'll test all possible combinations of the feature bit presence\n\t// that both nodes can signal for this new channel type. We'll make a\n\t// new Carol+Dave for each test instance as well.\n\tfor _, carolCommitType := range allTypes {\n\t\tfor _, daveCommitType := range allTypes {\n\t\t\tcc := carolCommitType\n\t\t\tdc := daveCommitType\n\n\t\t\ttestName := fmt.Sprintf(\n\t\t\t\t\"carol_commit=%v,dave_commit=%v\", cc, dc,\n\t\t\t)\n\t\t\tsuccess := ht.Run(testName, func(t *testing.T) {\n\t\t\t\tst := ht.Subtest(t)\n\t\t\t\ttestFunding(st, cc, dc)\n\t\t\t})\n\n\t\t\tif !success {\n\t\t\t\tbreak test\n\t\t\t}\n\t\t}\n\t}\n}\n\n// basicChannelFundingTest is a sub-test of the main testBasicChannelFunding\n// test. Given two nodes: Alice and Bob, it'll assert proper channel creation,\n// then return a function closure that should be called to assert proper\n// channel closure.",
      "length": 3579,
      "tokens": 459,
      "embedding": []
    },
    {
      "slug": "func basicChannelFundingTest(ht *lntest.HarnessTest,",
      "content": "func basicChannelFundingTest(ht *lntest.HarnessTest,\n\talice, bob *node.HarnessNode,\n\tfundingShim *lnrpc.FundingShim) (*lnrpc.Channel,\n\t*lnrpc.Channel, func()) {\n\n\tchanAmt := funding.MaxBtcFundingAmount\n\tpushAmt := btcutil.Amount(100000)\n\tsatPerVbyte := btcutil.Amount(1)\n\n\t// Record nodes' channel balance before testing.\n\taliceChannelBalance := alice.RPC.ChannelBalance()\n\tbobChannelBalance := bob.RPC.ChannelBalance()\n\n\t// Creates a helper closure to be used below which asserts the proper\n\t// response to a channel balance RPC.\n\tcheckChannelBalance := func(node *node.HarnessNode,\n\t\toldChannelBalance *lnrpc.ChannelBalanceResponse,\n\t\tlocal, remote btcutil.Amount) {\n\n\t\tnewResp := oldChannelBalance\n\n\t\tnewResp.LocalBalance.Sat += uint64(local)\n\t\tnewResp.LocalBalance.Msat += uint64(\n\t\t\tlnwire.NewMSatFromSatoshis(local),\n\t\t)\n\t\tnewResp.RemoteBalance.Sat += uint64(remote)\n\t\tnewResp.RemoteBalance.Msat += uint64(\n\t\t\tlnwire.NewMSatFromSatoshis(remote),\n\t\t)\n\t\t// Deprecated fields.\n\t\tnewResp.Balance += int64(local) // nolint:staticcheck\n\t\tht.AssertChannelBalanceResp(node, newResp)\n\t}\n\n\t// First establish a channel with a capacity of 0.5 BTC between Alice\n\t// and Bob with Alice pushing 100k satoshis to Bob's side during\n\t// funding. This function will block until the channel itself is fully\n\t// open or an error occurs in the funding process. A series of\n\t// assertions will be executed to ensure the funding process completed\n\t// successfully.\n\tchanPoint := ht.OpenChannel(\n\t\talice, bob, lntest.OpenChannelParams{\n\t\t\tAmt:         chanAmt,\n\t\t\tPushAmt:     pushAmt,\n\t\t\tFundingShim: fundingShim,\n\t\t\tSatPerVByte: satPerVbyte,\n\t\t},\n\t)\n\n\tcType := ht.GetChannelCommitType(alice, chanPoint)\n\n\t// With the channel open, ensure that the amount specified above has\n\t// properly been pushed to Bob.\n\taliceLocalBalance := chanAmt - pushAmt - lntest.CalcStaticFee(cType, 0)\n\tcheckChannelBalance(\n\t\talice, aliceChannelBalance, aliceLocalBalance, pushAmt,\n\t)\n\tcheckChannelBalance(\n\t\tbob, bobChannelBalance, pushAmt, aliceLocalBalance,\n\t)\n\n\taliceChannel := ht.GetChannelByChanPoint(alice, chanPoint)\n\tbobChannel := ht.GetChannelByChanPoint(bob, chanPoint)\n\n\tcloseChan := func() {\n\t\t// Finally, immediately close the channel. This function will\n\t\t// also block until the channel is closed and will additionally\n\t\t// assert the relevant channel closing post conditions.\n\t\tht.CloseChannel(alice, chanPoint)\n\t}\n\n\treturn aliceChannel, bobChannel, closeChan\n}\n\n// testUnconfirmedChannelFunding tests that our unconfirmed change outputs can\n// be used to fund channels.",
      "length": 2422,
      "tokens": 275,
      "embedding": []
    },
    {
      "slug": "func testUnconfirmedChannelFunding(ht *lntest.HarnessTest) {",
      "content": "func testUnconfirmedChannelFunding(ht *lntest.HarnessTest) {\n\tconst (\n\t\tchanAmt = funding.MaxBtcFundingAmount\n\t\tpushAmt = btcutil.Amount(100000)\n\t)\n\n\t// We'll start off by creating a node for Carol.\n\tcarol := ht.NewNode(\"Carol\", nil)\n\n\talice := ht.Alice\n\n\t// We'll send her some unconfirmed funds.\n\tht.FundCoinsUnconfirmed(2*chanAmt, carol)\n\n\t// Now, we'll connect her to Alice so that they can open a channel\n\t// together. The funding flow should select Carol's unconfirmed output\n\t// as she doesn't have any other funds since it's a new node.\n\tht.ConnectNodes(carol, alice)\n\n\tchanOpenUpdate := ht.OpenChannelAssertStream(\n\t\tcarol, alice, lntest.OpenChannelParams{\n\t\t\tAmt:              chanAmt,\n\t\t\tPushAmt:          pushAmt,\n\t\t\tSpendUnconfirmed: true,\n\t\t},\n\t)\n\n\t// Creates a helper closure to be used below which asserts the proper\n\t// response to a channel balance RPC.\n\tcheckChannelBalance := func(node *node.HarnessNode,\n\t\tlocal, remote, pendingLocal, pendingRemote btcutil.Amount) {\n\n\t\texpectedResponse := &lnrpc.ChannelBalanceResponse{\n\t\t\tLocalBalance: &lnrpc.Amount{\n\t\t\t\tSat: uint64(local),\n\t\t\t\tMsat: uint64(lnwire.NewMSatFromSatoshis(\n\t\t\t\t\tlocal,\n\t\t\t\t)),\n\t\t\t},\n\t\t\tRemoteBalance: &lnrpc.Amount{\n\t\t\t\tSat: uint64(remote),\n\t\t\t\tMsat: uint64(lnwire.NewMSatFromSatoshis(\n\t\t\t\t\tremote,\n\t\t\t\t)),\n\t\t\t},\n\t\t\tPendingOpenLocalBalance: &lnrpc.Amount{\n\t\t\t\tSat: uint64(pendingLocal),\n\t\t\t\tMsat: uint64(lnwire.NewMSatFromSatoshis(\n\t\t\t\t\tpendingLocal,\n\t\t\t\t)),\n\t\t\t},\n\t\t\tPendingOpenRemoteBalance: &lnrpc.Amount{\n\t\t\t\tSat: uint64(pendingRemote),\n\t\t\t\tMsat: uint64(lnwire.NewMSatFromSatoshis(\n\t\t\t\t\tpendingRemote,\n\t\t\t\t)),\n\t\t\t},\n\t\t\tUnsettledLocalBalance:  &lnrpc.Amount{},\n\t\t\tUnsettledRemoteBalance: &lnrpc.Amount{},\n\t\t\t// Deprecated fields.\n\t\t\tBalance:            int64(local),\n\t\t\tPendingOpenBalance: int64(pendingLocal),\n\t\t}\n\t\tht.AssertChannelBalanceResp(node, expectedResponse)\n\t}\n\n\t// As the channel is pending open, it's expected Carol has both zero\n\t// local and remote balances, and pending local/remote should not be\n\t// zero.\n\t//\n\t// Note that atm we haven't obtained the chanPoint yet, so we use the\n\t// type directly.\n\tcType := lnrpc.CommitmentType_STATIC_REMOTE_KEY\n\tcarolLocalBalance := chanAmt - pushAmt - lntest.CalcStaticFee(cType, 0)\n\tcheckChannelBalance(carol, 0, 0, carolLocalBalance, pushAmt)\n\n\t// For Alice, her local/remote balances should be zero, and the\n\t// local/remote balances are the mirror of Carol's.\n\tcheckChannelBalance(alice, 0, 0, pushAmt, carolLocalBalance)\n\n\t// Confirm the channel and wait for it to be recognized by both\n\t// parties. For neutrino backend, the funding transaction should be\n\t// mined. Otherwise, two transactions should be mined, the unconfirmed\n\t// spend and the funding tx.\n\tif ht.IsNeutrinoBackend() {\n\t\tht.MineBlocksAndAssertNumTxes(6, 1)\n\t} else {\n\t\tht.MineBlocksAndAssertNumTxes(6, 2)\n\t}\n\n\tchanPoint := ht.WaitForChannelOpenEvent(chanOpenUpdate)\n\n\t// With the channel open, we'll check the balances on each side of the\n\t// channel as a sanity check to ensure things worked out as intended.\n\tcheckChannelBalance(carol, carolLocalBalance, pushAmt, 0, 0)\n\tcheckChannelBalance(alice, pushAmt, carolLocalBalance, 0, 0)\n\n\t// TODO(yy): remove the sleep once the following bug is fixed.\n\t//\n\t// We may get the error `unable to gracefully close channel while peer\n\t// is offline (try force closing it instead): channel link not found`.\n\t// This happens because the channel link hasn't been added yet but we\n\t// now proceed to closing the channel. We may need to revisit how the\n\t// channel open event is created and make sure the event is only sent\n\t// after all relevant states have been updated.\n\ttime.Sleep(2 * time.Second)\n\n\t// Now that we're done with the test, the channel can be closed.\n\tht.CloseChannel(carol, chanPoint)\n}\n\n// testChannelFundingInputTypes tests that any type of supported input type can\n// be used to fund channels.",
      "length": 3697,
      "tokens": 468,
      "embedding": []
    },
    {
      "slug": "func testChannelFundingInputTypes(ht *lntest.HarnessTest) {",
      "content": "func testChannelFundingInputTypes(ht *lntest.HarnessTest) {\n\tconst (\n\t\tchanAmt  = funding.MaxBtcFundingAmount\n\t\tburnAddr = \"bcrt1qxsnqpdc842lu8c0xlllgvejt6rhy49u6fmpgyz\"\n\t)\n\n\t// We'll start off by creating a node for Carol.\n\tcarol := ht.NewNode(\"Carol\", nil)\n\n\t// Now, we'll connect her to Alice so that they can open a\n\t// channel together.\n\tht.ConnectNodes(carol, ht.Alice)\n\n\trunChannelFundingInputTypes(ht, ht.Alice, carol)\n}\n\n// runChannelFundingInputTypes tests that any type of supported input type can\n// be used to fund channels.",
      "length": 461,
      "tokens": 62,
      "embedding": []
    },
    {
      "slug": "func runChannelFundingInputTypes(ht *lntest.HarnessTest, alice,",
      "content": "func runChannelFundingInputTypes(ht *lntest.HarnessTest, alice,\n\tcarol *node.HarnessNode) {\n\n\tconst (\n\t\tchanAmt  = funding.MaxBtcFundingAmount\n\t\tburnAddr = \"bcrt1qxsnqpdc842lu8c0xlllgvejt6rhy49u6fmpgyz\"\n\t)\n\n\tfundMixed := func(amt btcutil.Amount, target *node.HarnessNode) {\n\t\tht.FundCoins(amt/5, target)\n\t\tht.FundCoins(amt/5, target)\n\t\tht.FundCoinsP2TR(amt/5, target)\n\t\tht.FundCoinsP2TR(amt/5, target)\n\t\tht.FundCoinsP2TR(amt/5, target)\n\t}\n\tfundMultipleP2TR := func(amt btcutil.Amount, target *node.HarnessNode) {\n\t\tht.FundCoinsP2TR(amt/4, target)\n\t\tht.FundCoinsP2TR(amt/4, target)\n\t\tht.FundCoinsP2TR(amt/4, target)\n\t\tht.FundCoinsP2TR(amt/4, target)\n\t}\n\tfundWithTypes := []func(amt btcutil.Amount, target *node.HarnessNode){\n\t\tht.FundCoins, ht.FundCoinsNP2WKH, ht.FundCoinsP2TR, fundMixed,\n\t\tfundMultipleP2TR,\n\t}\n\n\t// Creates a helper closure to be used below which asserts the\n\t// proper response to a channel balance RPC.\n\tcheckChannelBalance := func(node *node.HarnessNode, local,\n\t\tremote, pendingLocal, pendingRemote btcutil.Amount) {\n\n\t\texpectedResponse := &lnrpc.ChannelBalanceResponse{\n\t\t\tLocalBalance: &lnrpc.Amount{\n\t\t\t\tSat:  uint64(local),\n\t\t\t\tMsat: uint64(lnwire.NewMSatFromSatoshis(local)),\n\t\t\t},\n\t\t\tRemoteBalance: &lnrpc.Amount{\n\t\t\t\tSat: uint64(remote),\n\t\t\t\tMsat: uint64(lnwire.NewMSatFromSatoshis(\n\t\t\t\t\tremote,\n\t\t\t\t)),\n\t\t\t},\n\t\t\tPendingOpenLocalBalance: &lnrpc.Amount{\n\t\t\t\tSat: uint64(pendingLocal),\n\t\t\t\tMsat: uint64(lnwire.NewMSatFromSatoshis(\n\t\t\t\t\tpendingLocal,\n\t\t\t\t)),\n\t\t\t},\n\t\t\tPendingOpenRemoteBalance: &lnrpc.Amount{\n\t\t\t\tSat: uint64(pendingRemote),\n\t\t\t\tMsat: uint64(lnwire.NewMSatFromSatoshis(\n\t\t\t\t\tpendingRemote,\n\t\t\t\t)),\n\t\t\t},\n\t\t\tUnsettledLocalBalance:  &lnrpc.Amount{},\n\t\t\tUnsettledRemoteBalance: &lnrpc.Amount{},\n\t\t\t// Deprecated fields.\n\t\t\tBalance:            int64(local),\n\t\t\tPendingOpenBalance: int64(pendingLocal),\n\t\t}\n\t\tht.AssertChannelBalanceResp(node, expectedResponse)\n\t}\n\n\tfor _, funder := range fundWithTypes {\n\t\t// We'll send her some confirmed funds. We send 10% more than\n\t\t// we need to account for fees.\n\t\tfunder((chanAmt*11)/10, carol)\n\n\t\tchanOpenUpdate := ht.OpenChannelAssertStream(\n\t\t\tcarol, alice, lntest.OpenChannelParams{\n\t\t\t\tAmt: chanAmt,\n\t\t\t},\n\t\t)\n\n\t\t// As the channel is pending open, it's expected Carol has both\n\t\t// zero local and remote balances, and pending local/remote\n\t\t// should not be zero.\n\t\t//\n\t\t// Note that atm we haven't obtained the chanPoint yet, so we\n\t\t// use the type directly.\n\t\tcType := lnrpc.CommitmentType_STATIC_REMOTE_KEY\n\t\tcarolLocalBalance := chanAmt - lntest.CalcStaticFee(cType, 0)\n\t\tcheckChannelBalance(carol, 0, 0, carolLocalBalance, 0)\n\n\t\t// For Alice, her local/remote balances should be zero, and the\n\t\t// local/remote balances are the mirror of Carol's.\n\t\tcheckChannelBalance(alice, 0, 0, 0, carolLocalBalance)\n\n\t\t// Confirm the channel and wait for it to be recognized by both\n\t\t// parties. Two transactions should be mined, the unconfirmed\n\t\t// spend and the funding tx.\n\t\tht.MineBlocksAndAssertNumTxes(1, 1)\n\t\tchanPoint := ht.WaitForChannelOpenEvent(chanOpenUpdate)\n\n\t\t// With the channel open, we'll check the balances on each side\n\t\t// of the channel as a sanity check to ensure things worked out\n\t\t// as intended.\n\t\tcheckChannelBalance(carol, carolLocalBalance, 0, 0, 0)\n\t\tcheckChannelBalance(alice, 0, carolLocalBalance, 0, 0)\n\n\t\t// TODO(yy): remove the sleep once the following bug is fixed.\n\t\t//\n\t\t// We may get the error `unable to gracefully close channel\n\t\t// while peer is offline (try force closing it instead):\n\t\t// channel link not found`. This happens because the channel\n\t\t// link hasn't been added yet but we now proceed to closing the\n\t\t// channel. We may need to revisit how the channel open event\n\t\t// is created and make sure the event is only sent after all\n\t\t// relevant states have been updated.\n\t\ttime.Sleep(2 * time.Second)\n\n\t\t// Now that we're done with the test, the channel can be closed.\n\t\tht.CloseChannel(carol, chanPoint)\n\n\t\t// Empty out the wallet so there aren't any lingering coins.\n\t\tsendAllCoinsConfirm(ht, carol, burnAddr)\n\t}\n}\n\n// sendAllCoinsConfirm sends all coins of the node's wallet to the given address\n// and awaits one confirmation.",
      "length": 3980,
      "tokens": 470,
      "embedding": []
    },
    {
      "slug": "func sendAllCoinsConfirm(ht *lntest.HarnessTest, node *node.HarnessNode,",
      "content": "func sendAllCoinsConfirm(ht *lntest.HarnessTest, node *node.HarnessNode,\n\taddr string) {\n\n\tsweepReq := &lnrpc.SendCoinsRequest{\n\t\tAddr:    addr,\n\t\tSendAll: true,\n\t}\n\tnode.RPC.SendCoins(sweepReq)\n\tht.MineBlocksAndAssertNumTxes(1, 1)\n}\n\n// testExternalFundingChanPoint tests that we're able to carry out a normal\n// channel funding workflow given a channel point that was constructed outside\n// the main daemon.",
      "length": 324,
      "tokens": 42,
      "embedding": []
    },
    {
      "slug": "func testExternalFundingChanPoint(ht *lntest.HarnessTest) {",
      "content": "func testExternalFundingChanPoint(ht *lntest.HarnessTest) {\n\t// First, we'll create two new nodes that we'll use to open channel\n\t// between for this test.\n\tcarol := ht.NewNode(\"carol\", nil)\n\tdave := ht.NewNode(\"dave\", nil)\n\n\t// Carol will be funding the channel, so we'll send some coins over to\n\t// her and ensure they have enough confirmations before we proceed.\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, carol)\n\n\t// Before we start the test, we'll ensure both sides are connected to\n\t// the funding flow can properly be executed.\n\tht.EnsureConnected(carol, dave)\n\n\t// At this point, we're ready to simulate our external channel funding\n\t// flow. To start with, we'll create a pending channel with a shim for\n\t// a transaction that will never be published.\n\tconst thawHeight uint32 = 10\n\tconst chanSize = funding.MaxBtcFundingAmount\n\tfundingShim1, chanPoint1 := deriveFundingShim(\n\t\tht, carol, dave, chanSize, thawHeight, false,\n\t)\n\tht.OpenChannelAssertPending(\n\t\tcarol, dave, lntest.OpenChannelParams{\n\t\t\tAmt:         chanSize,\n\t\t\tFundingShim: fundingShim1,\n\t\t},\n\t)\n\tht.AssertNodesNumPendingOpenChannels(carol, dave, 1)\n\n\t// That channel is now pending forever and normally would saturate the\n\t// max pending channel limit for both nodes. But because the channel is\n\t// externally funded, we should still be able to open another one. Let's\n\t// do exactly that now. For this one we publish the transaction so we\n\t// can mine it later.\n\tfundingShim2, chanPoint2 := deriveFundingShim(\n\t\tht, carol, dave, chanSize, thawHeight, true,\n\t)\n\n\t// At this point, we'll now carry out the normal basic channel funding\n\t// test as everything should now proceed as normal (a regular channel\n\t// funding flow).\n\tcarolChan, daveChan, _ := basicChannelFundingTest(\n\t\tht, carol, dave, fundingShim2,\n\t)\n\n\t// Both channels should be marked as frozen with the proper thaw\n\t// height.\n\trequire.Equal(ht, thawHeight, carolChan.ThawHeight,\n\t\t\"thaw height unmatched\")\n\trequire.Equal(ht, thawHeight, daveChan.ThawHeight,\n\t\t\"thaw height unmatched\")\n\n\t// Next, to make sure the channel functions as normal, we'll make some\n\t// payments within the channel.\n\tpayAmt := btcutil.Amount(100000)\n\tinvoice := &lnrpc.Invoice{\n\t\tMemo:  \"new chans\",\n\t\tValue: int64(payAmt),\n\t}\n\tresp := dave.RPC.AddInvoice(invoice)\n\tht.CompletePaymentRequests(carol, []string{resp.PaymentRequest})\n\n\t// Now that the channels are open, and we've confirmed that they're\n\t// operational, we'll now ensure that the channels are frozen as\n\t// intended (if requested).\n\t//\n\t// First, we'll try to close the channel as Carol, the initiator. This\n\t// should fail as a frozen channel only allows the responder to\n\t// initiate a channel close.\n\terr := ht.CloseChannelAssertErr(carol, chanPoint2, false)\n\trequire.Contains(ht, err.Error(), \"cannot co-op close frozen channel\")\n\n\t// Before Dave closes the channel, he needs to check the invoice is\n\t// settled to avoid an error saying cannot close channel due to active\n\t// HTLCs.\n\tht.AssertInvoiceSettled(dave, resp.PaymentAddr)\n\n\t// TODO(yy): remove the sleep once the following bug is fixed.\n\t// When the invoice is reported settled, the commitment dance is not\n\t// yet finished, which can cause an error when closing the channel,\n\t// saying there's active HTLCs. We need to investigate this issue and\n\t// reverse the order to, first finish the commitment dance, then report\n\t// the invoice as settled.\n\ttime.Sleep(2 * time.Second)\n\n\t// Next we'll try but this time with Dave (the responder) as the\n\t// initiator. This time the channel should be closed as normal.\n\tht.CloseChannel(dave, chanPoint2)\n\n\t// As a last step, we check if we still have the pending channel\n\t// hanging around because we never published the funding TX.\n\tht.AssertNodesNumPendingOpenChannels(carol, dave, 1)\n\n\t// Let's make sure we can abandon it.\n\tcarol.RPC.AbandonChannel(&lnrpc.AbandonChannelRequest{\n\t\tChannelPoint:           chanPoint1,\n\t\tPendingFundingShimOnly: true,\n\t})\n\tdave.RPC.AbandonChannel(&lnrpc.AbandonChannelRequest{\n\t\tChannelPoint:           chanPoint1,\n\t\tPendingFundingShimOnly: true,\n\t})\n\n\t// It should now not appear in the pending channels anymore.\n\tht.AssertNodesNumPendingOpenChannels(carol, dave, 0)\n}\n\n// testFundingPersistence is intended to ensure that the Funding Manager\n// persists the state of new channels prior to broadcasting the channel's\n// funding transaction. This ensures that the daemon maintains an up-to-date\n// representation of channels if the system is restarted or disconnected.\n// testFundingPersistence mirrors testBasicChannelFunding, but adds restarts\n// and checks for the state of channels with unconfirmed funding transactions.",
      "length": 4469,
      "tokens": 628,
      "embedding": []
    },
    {
      "slug": "func testChannelFundingPersistence(ht *lntest.HarnessTest) {",
      "content": "func testChannelFundingPersistence(ht *lntest.HarnessTest) {\n\tchanAmt := funding.MaxBtcFundingAmount\n\tpushAmt := btcutil.Amount(0)\n\n\t// As we need to create a channel that requires more than 1\n\t// confirmation before it's open, with the current set of defaults,\n\t// we'll need to create a new node instance.\n\tconst numConfs = 5\n\tcarolArgs := []string{\n\t\tfmt.Sprintf(\"--bitcoin.defaultchanconfs=%v\", numConfs),\n\t}\n\tcarol := ht.NewNode(\"Carol\", carolArgs)\n\n\talice := ht.Alice\n\tht.ConnectNodes(alice, carol)\n\n\t// Create a new channel that requires 5 confs before it's considered\n\t// open, then broadcast the funding transaction\n\tparam := lntest.OpenChannelParams{\n\t\tAmt:     chanAmt,\n\t\tPushAmt: pushAmt,\n\t}\n\tupdate := ht.OpenChannelAssertPending(alice, carol, param)\n\n\t// At this point, the channel's funding transaction will have been\n\t// broadcast, but not confirmed. Alice and Bob's nodes should reflect\n\t// this when queried via RPC.\n\tht.AssertNumPendingOpenChannels(alice, 1)\n\tht.AssertNumPendingOpenChannels(carol, 1)\n\n\t// Restart both nodes to test that the appropriate state has been\n\t// persisted and that both nodes recover gracefully.\n\tht.RestartNode(alice)\n\tht.RestartNode(carol)\n\n\tfundingTxID, err := chainhash.NewHash(update.Txid)\n\trequire.NoError(ht, err, \"unable to convert funding txid \"+\n\t\t\"into chainhash.Hash\")\n\n\t// Mine a block, then wait for Alice's node to notify us that the\n\t// channel has been opened. The funding transaction should be found\n\t// within the newly mined block.\n\tblock := ht.MineBlocksAndAssertNumTxes(1, 1)[0]\n\tht.Miner.AssertTxInBlock(block, fundingTxID)\n\n\t// Get the height that our transaction confirmed at.\n\t_, height := ht.Miner.GetBestBlock()\n\n\t// Restart both nodes to test that the appropriate state has been\n\t// persisted and that both nodes recover gracefully.\n\tht.RestartNode(alice)\n\tht.RestartNode(carol)\n\n\t// The following block ensures that after both nodes have restarted,\n\t// they have reconnected before the execution of the next test.\n\tht.EnsureConnected(alice, carol)\n\n\t// Next, mine enough blocks s.t the channel will open with a single\n\t// additional block mined.\n\tht.MineBlocks(3)\n\n\t// Assert that our wallet has our opening transaction with a label\n\t// that does not have a channel ID set yet, because we have not\n\t// reached our required confirmations.\n\ttx := ht.AssertTxAtHeight(alice, height, fundingTxID)\n\n\t// At this stage, we expect the transaction to be labelled, but not with\n\t// our channel ID because our transaction has not yet confirmed.\n\tlabel := labels.MakeLabel(labels.LabelTypeChannelOpen, nil)\n\trequire.Equal(ht, label, tx.Label, \"open channel label wrong\")\n\n\t// Both nodes should still show a single channel as pending.\n\tht.AssertNumPendingOpenChannels(alice, 1)\n\tht.AssertNumPendingOpenChannels(carol, 1)\n\n\t// Finally, mine the last block which should mark the channel as open.\n\tht.MineBlocks(1)\n\n\t// At this point, the channel should be fully opened and there should\n\t// be no pending channels remaining for either node.\n\tht.AssertNumPendingOpenChannels(alice, 0)\n\tht.AssertNumPendingOpenChannels(carol, 0)\n\n\t// The channel should be listed in the peer information returned by\n\t// both peers.\n\tchanPoint := lntest.ChanPointFromPendingUpdate(update)\n\n\t// Re-lookup our transaction in the block that it confirmed in.\n\ttx = ht.AssertTxAtHeight(alice, height, fundingTxID)\n\n\t// Check both nodes to ensure that the channel is ready for operation.\n\tchanAlice := ht.AssertChannelExists(alice, chanPoint)\n\tht.AssertChannelExists(carol, chanPoint)\n\n\t// Make sure Alice and Carol have seen the channel in their network\n\t// topology.\n\tht.AssertTopologyChannelOpen(alice, chanPoint)\n\tht.AssertTopologyChannelOpen(carol, chanPoint)\n\n\t// Create an additional check for our channel assertion that will\n\t// check that our label is as expected.\n\tshortChanID := lnwire.NewShortChanIDFromInt(chanAlice.ChanId)\n\tlabel = labels.MakeLabel(labels.LabelTypeChannelOpen, &shortChanID)\n\trequire.Equal(ht, label, tx.Label, \"open channel label not updated\")\n\n\t// Finally, immediately close the channel. This function will also\n\t// block until the channel is closed and will additionally assert the\n\t// relevant channel closing post conditions.\n\tht.CloseChannel(alice, chanPoint)\n}\n\n// testBatchChanFunding makes sure multiple channels can be opened in one batch\n// transaction in an atomic way.",
      "length": 4175,
      "tokens": 554,
      "embedding": []
    },
    {
      "slug": "func testBatchChanFunding(ht *lntest.HarnessTest) {",
      "content": "func testBatchChanFunding(ht *lntest.HarnessTest) {\n\t// First, we'll create two new nodes that we'll use to open channels\n\t// to during this test. Carol has a high minimum funding amount that\n\t// we'll use to trigger an error during the batch channel open.\n\tcarol := ht.NewNode(\"carol\", []string{\"--minchansize=200000\"})\n\tdave := ht.NewNode(\"dave\", nil)\n\n\talice, bob := ht.Alice, ht.Bob\n\n\t// Before we start the test, we'll ensure Alice is connected to Carol\n\t// and Dave so she can open channels to both of them (and Bob).\n\tht.EnsureConnected(alice, bob)\n\tht.EnsureConnected(alice, carol)\n\tht.EnsureConnected(alice, dave)\n\n\t// Let's create our batch TX request. This first one should fail as we\n\t// open a channel to Carol that is too small for her min chan size.\n\tbatchReq := &lnrpc.BatchOpenChannelRequest{\n\t\tSatPerVbyte: 12,\n\t\tMinConfs:    1,\n\t\tChannels: []*lnrpc.BatchOpenChannel{{\n\t\t\tNodePubkey:         bob.PubKey[:],\n\t\t\tLocalFundingAmount: 100_000,\n\t\t}, {\n\t\t\tNodePubkey:         carol.PubKey[:],\n\t\t\tLocalFundingAmount: 100_000,\n\t\t}, {\n\t\t\tNodePubkey:         dave.PubKey[:],\n\t\t\tLocalFundingAmount: 100_000,\n\t\t}},\n\t}\n\n\terr := alice.RPC.BatchOpenChannelAssertErr(batchReq)\n\trequire.Contains(ht, err.Error(), \"initial negotiation failed\")\n\n\t// Let's fix the minimum amount for Alice now and try again.\n\tbatchReq.Channels[1].LocalFundingAmount = 200_000\n\tbatchResp := alice.RPC.BatchOpenChannel(batchReq)\n\trequire.Len(ht, batchResp.PendingChannels, 3)\n\n\ttxHash, err := chainhash.NewHash(batchResp.PendingChannels[0].Txid)\n\trequire.NoError(ht, err)\n\n\tchanPoint1 := &lnrpc.ChannelPoint{\n\t\tFundingTxid: &lnrpc.ChannelPoint_FundingTxidBytes{\n\t\t\tFundingTxidBytes: batchResp.PendingChannels[0].Txid,\n\t\t},\n\t\tOutputIndex: batchResp.PendingChannels[0].OutputIndex,\n\t}\n\tchanPoint2 := &lnrpc.ChannelPoint{\n\t\tFundingTxid: &lnrpc.ChannelPoint_FundingTxidBytes{\n\t\t\tFundingTxidBytes: batchResp.PendingChannels[1].Txid,\n\t\t},\n\t\tOutputIndex: batchResp.PendingChannels[1].OutputIndex,\n\t}\n\tchanPoint3 := &lnrpc.ChannelPoint{\n\t\tFundingTxid: &lnrpc.ChannelPoint_FundingTxidBytes{\n\t\t\tFundingTxidBytes: batchResp.PendingChannels[2].Txid,\n\t\t},\n\t\tOutputIndex: batchResp.PendingChannels[2].OutputIndex,\n\t}\n\n\tblock := ht.MineBlocksAndAssertNumTxes(6, 1)[0]\n\tht.Miner.AssertTxInBlock(block, txHash)\n\tht.AssertTopologyChannelOpen(alice, chanPoint1)\n\tht.AssertTopologyChannelOpen(alice, chanPoint2)\n\tht.AssertTopologyChannelOpen(alice, chanPoint3)\n\n\t// With the channel open, ensure that it is counted towards Alice's\n\t// total channel balance.\n\tbalRes := alice.RPC.ChannelBalance()\n\trequire.NotEqual(ht, int64(0), balRes.LocalBalance.Sat)\n\n\t// Next, to make sure the channel functions as normal, we'll make some\n\t// payments within the channel.\n\tpayAmt := btcutil.Amount(100000)\n\tinvoice := &lnrpc.Invoice{\n\t\tMemo:  \"new chans\",\n\t\tValue: int64(payAmt),\n\t}\n\tresp := carol.RPC.AddInvoice(invoice)\n\tht.CompletePaymentRequests(alice, []string{resp.PaymentRequest})\n\n\t// To conclude, we'll close the newly created channel between Carol and\n\t// Dave. This function will also block until the channel is closed and\n\t// will additionally assert the relevant channel closing post\n\t// conditions.\n\tht.CloseChannel(alice, chanPoint1)\n\tht.CloseChannel(alice, chanPoint2)\n\tht.CloseChannel(alice, chanPoint3)\n}\n\n// deriveFundingShim creates a channel funding shim by deriving the necessary\n// keys on both sides.",
      "length": 3226,
      "tokens": 336,
      "embedding": []
    },
    {
      "slug": "func deriveFundingShim(ht *lntest.HarnessTest,",
      "content": "func deriveFundingShim(ht *lntest.HarnessTest,\n\tcarol, dave *node.HarnessNode, chanSize btcutil.Amount,\n\tthawHeight uint32, publish bool) (*lnrpc.FundingShim,\n\t*lnrpc.ChannelPoint) {\n\n\tkeyLoc := &signrpc.KeyLocator{KeyFamily: 9999}\n\tcarolFundingKey := carol.RPC.DeriveKey(keyLoc)\n\tdaveFundingKey := dave.RPC.DeriveKey(keyLoc)\n\n\t// Now that we have the multi-sig keys for each party, we can manually\n\t// construct the funding transaction. We'll instruct the backend to\n\t// immediately create and broadcast a transaction paying out an exact\n\t// amount. Normally this would reside in the mempool, but we just\n\t// confirm it now for simplicity.\n\t_, fundingOutput, err := input.GenFundingPkScript(\n\t\tcarolFundingKey.RawKeyBytes, daveFundingKey.RawKeyBytes,\n\t\tint64(chanSize),\n\t)\n\trequire.NoError(ht, err)\n\n\tvar txid *chainhash.Hash\n\ttargetOutputs := []*wire.TxOut{fundingOutput}\n\tif publish {\n\t\ttxid = ht.Miner.SendOutputsWithoutChange(targetOutputs, 5)\n\t} else {\n\t\ttx := ht.Miner.CreateTransaction(targetOutputs, 5)\n\n\t\ttxHash := tx.TxHash()\n\t\ttxid = &txHash\n\t}\n\n\t// At this point, we can being our external channel funding workflow.\n\t// We'll start by generating a pending channel ID externally that will\n\t// be used to track this new funding type.\n\tpendingChanID := ht.Random32Bytes()\n\n\t// Now that we have the pending channel ID, Dave (our responder) will\n\t// register the intent to receive a new channel funding workflow using\n\t// the pending channel ID.\n\tchanPoint := &lnrpc.ChannelPoint{\n\t\tFundingTxid: &lnrpc.ChannelPoint_FundingTxidBytes{\n\t\t\tFundingTxidBytes: txid[:],\n\t\t},\n\t}\n\tchanPointShim := &lnrpc.ChanPointShim{\n\t\tAmt:       int64(chanSize),\n\t\tChanPoint: chanPoint,\n\t\tLocalKey: &lnrpc.KeyDescriptor{\n\t\t\tRawKeyBytes: daveFundingKey.RawKeyBytes,\n\t\t\tKeyLoc: &lnrpc.KeyLocator{\n\t\t\t\tKeyFamily: daveFundingKey.KeyLoc.KeyFamily,\n\t\t\t\tKeyIndex:  daveFundingKey.KeyLoc.KeyIndex,\n\t\t\t},\n\t\t},\n\t\tRemoteKey:     carolFundingKey.RawKeyBytes,\n\t\tPendingChanId: pendingChanID,\n\t\tThawHeight:    thawHeight,\n\t}\n\tfundingShim := &lnrpc.FundingShim{\n\t\tShim: &lnrpc.FundingShim_ChanPointShim{\n\t\t\tChanPointShim: chanPointShim,\n\t\t},\n\t}\n\tdave.RPC.FundingStateStep(&lnrpc.FundingTransitionMsg{\n\t\tTrigger: &lnrpc.FundingTransitionMsg_ShimRegister{\n\t\t\tShimRegister: fundingShim,\n\t\t},\n\t})\n\n\t// If we attempt to register the same shim (has the same pending chan\n\t// ID), then we should get an error.\n\tdave.RPC.FundingStateStepAssertErr(&lnrpc.FundingTransitionMsg{\n\t\tTrigger: &lnrpc.FundingTransitionMsg_ShimRegister{\n\t\t\tShimRegister: fundingShim,\n\t\t},\n\t})\n\n\t// We'll take the chan point shim we just registered for Dave (the\n\t// responder), and swap the local/remote keys before we feed it in as\n\t// Carol's funding shim as the initiator.\n\tfundingShim.GetChanPointShim().LocalKey = &lnrpc.KeyDescriptor{\n\t\tRawKeyBytes: carolFundingKey.RawKeyBytes,\n\t\tKeyLoc: &lnrpc.KeyLocator{\n\t\t\tKeyFamily: carolFundingKey.KeyLoc.KeyFamily,\n\t\t\tKeyIndex:  carolFundingKey.KeyLoc.KeyIndex,\n\t\t},\n\t}\n\tfundingShim.GetChanPointShim().RemoteKey = daveFundingKey.RawKeyBytes\n\n\treturn fundingShim, chanPoint\n}\n",
      "length": 2924,
      "tokens": 312,
      "embedding": []
    }
  ]
}