{
  "filepath": "../implementations/go/lnd/itest/lnd_payment_test.go",
  "package": "itest",
  "sections": [
    {
      "slug": "func testListPayments(ht *lntest.HarnessTest) {",
      "content": "func testListPayments(ht *lntest.HarnessTest) {\n\talice, bob := ht.Alice, ht.Bob\n\n\t// Check that there are no payments before test.\n\tht.AssertNumPayments(alice, 0)\n\n\t// Open a channel with 100k satoshis between Alice and Bob with Alice\n\t// being the sole funder of the channel.\n\tchanAmt := btcutil.Amount(100000)\n\tchanPoint := ht.OpenChannel(\n\t\talice, bob, lntest.OpenChannelParams{Amt: chanAmt},\n\t)\n\n\t// Get the number of invoices Bob already has.\n\t//\n\t// TODO(yy): we can remove this check once the `DeleteAllInvoices` rpc\n\t// is added.\n\tinvResp := bob.RPC.ListInvoices(nil)\n\tnumOldInvoices := len(invResp.Invoices)\n\n\t// Now that the channel is open, create an invoice for Bob which\n\t// expects a payment of 1000 satoshis from Alice paid via a particular\n\t// preimage.\n\tconst paymentAmt = 1000\n\tpreimage := ht.Random32Bytes()\n\tinvoice := &lnrpc.Invoice{\n\t\tMemo:      \"testing\",\n\t\tRPreimage: preimage,\n\t\tValue:     paymentAmt,\n\t}\n\tinvoiceResp := bob.RPC.AddInvoice(invoice)\n\n\t// Check that Bob has added the invoice.\n\tnumInvoices := numOldInvoices + 1\n\tht.AssertNumInvoices(bob, 1)\n\n\t// With the invoice for Bob added, send a payment towards Alice paying\n\t// to the above generated invoice.\n\tpayReqs := []string{invoiceResp.PaymentRequest}\n\tht.CompletePaymentRequests(alice, payReqs)\n\n\t// Grab Alice's list of payments, she should show the existence of\n\t// exactly one payment.\n\tp := ht.AssertNumPayments(alice, 1)[0]\n\tpath := p.Htlcs[len(p.Htlcs)-1].Route.Hops\n\n\t// Ensure that the stored path shows a direct payment to Bob with no\n\t// other nodes in-between.\n\trequire.Len(ht, path, 1, \"wrong number of routes in path\")\n\trequire.Equal(ht, bob.PubKeyStr, path[0].PubKey, \"wrong pub key\")\n\n\t// The payment amount should also match our previous payment directly.\n\trequire.EqualValues(ht, paymentAmt, p.ValueSat, \"incorrect sat amount\")\n\trequire.EqualValues(ht, paymentAmt*1000, p.ValueMsat,\n\t\t\"incorrect msat amount\")\n\n\t// The payment hash (or r-hash) should have been stored correctly.\n\tcorrectRHash := hex.EncodeToString(invoiceResp.RHash)\n\trequire.Equal(ht, correctRHash, p.PaymentHash, \"incorrect RHash\")\n\n\t// As we made a single-hop direct payment, there should have been no\n\t// fee applied.\n\trequire.Zero(ht, p.FeeSat, \"fee should be 0\")\n\trequire.Zero(ht, p.FeeMsat, \"fee should be 0\")\n\n\t// Now verify that the payment request returned by the rpc matches the\n\t// invoice that we paid.\n\trequire.Equal(ht, invoiceResp.PaymentRequest, p.PaymentRequest,\n\t\t\"incorrect payreq\")\n\n\t// We now check the timestamp filters in `ListPayments`.\n\t//\n\t// Use a start date long time ago should return us the payment.\n\treq := &lnrpc.ListPaymentsRequest{\n\t\tCreationDateStart: 1227035905,\n\t}\n\tresp := alice.RPC.ListPayments(req)\n\trequire.Len(ht, resp.Payments, 1)\n\n\t// Use an end date long time ago should return us nothing.\n\treq = &lnrpc.ListPaymentsRequest{\n\t\tCreationDateEnd: 1227035905,\n\t}\n\tresp = alice.RPC.ListPayments(req)\n\trequire.Empty(ht, resp.Payments)\n\n\t// Use a start date far in the future should return us nothing.\n\treq = &lnrpc.ListPaymentsRequest{\n\t\tCreationDateStart: 5392552705,\n\t}\n\tresp = alice.RPC.ListPayments(req)\n\trequire.Empty(ht, resp.Payments)\n\n\t// Use an end date far in the future should return us the payment.\n\treq = &lnrpc.ListPaymentsRequest{\n\t\tCreationDateEnd: 5392552705,\n\t}\n\tresp = alice.RPC.ListPayments(req)\n\trequire.Len(ht, resp.Payments, 1)\n\n\t// We now do the same check for `ListInvoices`\n\t//\n\t// Use a start date long time ago should return us the invoice.\n\tinvReq := &lnrpc.ListInvoiceRequest{\n\t\tCreationDateStart: 1227035905,\n\t}\n\tinvResp = bob.RPC.ListInvoices(invReq)\n\trequire.Len(ht, invResp.Invoices, numInvoices)\n\n\t// Use an end date long time ago should return us nothing.\n\tinvReq = &lnrpc.ListInvoiceRequest{\n\t\tCreationDateEnd: 1227035905,\n\t}\n\tinvResp = bob.RPC.ListInvoices(invReq)\n\trequire.Empty(ht, invResp.Invoices)\n\n\t// Use a start date far in the future should return us nothing.\n\tinvReq = &lnrpc.ListInvoiceRequest{\n\t\tCreationDateStart: 5392552705,\n\t}\n\tinvResp = bob.RPC.ListInvoices(invReq)\n\trequire.Empty(ht, invResp.Invoices)\n\n\t// Use an end date far in the future should return us the invoice.\n\tinvReq = &lnrpc.ListInvoiceRequest{\n\t\tCreationDateEnd: 5392552705,\n\t}\n\tinvResp = bob.RPC.ListInvoices(invReq)\n\trequire.Len(ht, invResp.Invoices, numInvoices)\n\n\t// Delete all payments from Alice. DB should have no payments.\n\talice.RPC.DeleteAllPayments()\n\n\t// Check that there are no payments after test.\n\tht.AssertNumPayments(alice, 0)\n\n\t// TODO(yy): remove the sleep once the following bug is fixed.\n\t// When the invoice is reported settled, the commitment dance is not\n\t// yet finished, which can cause an error when closing the channel,\n\t// saying there's active HTLCs. We need to investigate this issue and\n\t// reverse the order to, first finish the commitment dance, then report\n\t// the invoice as settled.\n\ttime.Sleep(2 * time.Second)\n\n\t// Close the channel.\n\tht.CloseChannel(alice, chanPoint)\n}\n\n// testPaymentFollowingChannelOpen tests that the channel transition from\n// 'pending' to 'open' state does not cause any inconsistencies within other\n// subsystems trying to update the channel state in the db. We follow this\n// transition with a payment that updates the commitment state and verify that\n// the pending state is up to date.",
      "length": 5083,
      "tokens": 682,
      "embedding": []
    },
    {
      "slug": "func testPaymentFollowingChannelOpen(ht *lntest.HarnessTest) {",
      "content": "func testPaymentFollowingChannelOpen(ht *lntest.HarnessTest) {\n\tconst paymentAmt = btcutil.Amount(100)\n\tchannelCapacity := paymentAmt * 1000\n\n\t// We first establish a channel between Alice and Bob.\n\talice, bob := ht.Alice, ht.Bob\n\tp := lntest.OpenChannelParams{\n\t\tAmt: channelCapacity,\n\t}\n\tpendingUpdate := ht.OpenChannelAssertPending(alice, bob, p)\n\n\t// At this point, the channel's funding transaction will have been\n\t// broadcast, but not confirmed. Alice and Bob's nodes\n\t// should reflect this when queried via RPC.\n\tht.AssertNodesNumPendingOpenChannels(alice, bob, 1)\n\n\t// We are restarting Bob's node to let the link be created for the\n\t// pending channel.\n\tht.RestartNode(bob)\n\n\t// We ensure that Bob reconnects to Alice.\n\tht.EnsureConnected(bob, alice)\n\n\t// We mine six blocks for the channel to be confirmed.\n\tht.MineBlocksAndAssertNumTxes(6, 1)\n\n\t// We verify that the channel is open from both nodes point of view.\n\tchanPoint := lntest.ChanPointFromPendingUpdate(pendingUpdate)\n\tht.AssertNodesNumPendingOpenChannels(alice, bob, 0)\n\tht.AssertChannelExists(alice, chanPoint)\n\tht.AssertChannelExists(bob, chanPoint)\n\n\t// With the channel open, we'll create invoices for Bob that Alice will\n\t// pay to in order to advance the state of the channel.\n\tbobPayReqs, _, _ := ht.CreatePayReqs(bob, paymentAmt, 1)\n\n\t// Send payment to Bob so that a channel update to disk will be\n\t// executed.\n\tht.CompletePaymentRequests(alice, []string{bobPayReqs[0]})\n\n\t// TODO(yy): remove the sleep once the following bug is fixed.\n\t// When the invoice is reported settled, the commitment dance is not\n\t// yet finished, which can cause an error when closing the channel,\n\t// saying there's active HTLCs. We need to investigate this issue and\n\t// reverse the order to, first finish the commitment dance, then report\n\t// the invoice as settled.\n\ttime.Sleep(2 * time.Second)\n\n\t// Finally, immediately close the channel. This function will also\n\t// block until the channel is closed and will additionally assert the\n\t// relevant channel closing post conditions.\n\tht.CloseChannel(alice, chanPoint)\n}\n\n// testAsyncPayments tests the performance of the async payments.",
      "length": 2032,
      "tokens": 288,
      "embedding": []
    },
    {
      "slug": "func testAsyncPayments(ht *lntest.HarnessTest) {",
      "content": "func testAsyncPayments(ht *lntest.HarnessTest) {\n\t// We use new nodes here as the benchmark test creates lots of data\n\t// which can be costly to be carried on.\n\talice := ht.NewNode(\"Alice\", []string{\"--pending-commit-interval=3m\"})\n\tbob := ht.NewNode(\"Bob\", []string{\"--pending-commit-interval=3m\"})\n\n\tht.EnsureConnected(alice, bob)\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, alice)\n\n\trunAsyncPayments(ht, alice, bob)\n}\n\n// runAsyncPayments tests the performance of the async payments.",
      "length": 423,
      "tokens": 48,
      "embedding": []
    },
    {
      "slug": "func runAsyncPayments(ht *lntest.HarnessTest, alice, bob *node.HarnessNode) {",
      "content": "func runAsyncPayments(ht *lntest.HarnessTest, alice, bob *node.HarnessNode) {\n\tconst paymentAmt = 100\n\n\t// First establish a channel with a capacity equals to the overall\n\t// amount of payments, between Alice and Bob, at the end of the test\n\t// Alice should send all money from her side to Bob.\n\tchannelCapacity := btcutil.Amount(paymentAmt * 2000)\n\tchanPoint := ht.OpenChannel(\n\t\talice, bob, lntest.OpenChannelParams{Amt: channelCapacity},\n\t)\n\n\tinfo := ht.QueryChannelByChanPoint(alice, chanPoint)\n\n\t// We'll create a number of invoices equal the max number of HTLCs that\n\t// can be carried in one direction. The number on the commitment will\n\t// likely be lower, but we can't guarantee that any more HTLCs will\n\t// succeed due to the limited path diversity and inability of the router\n\t// to retry via another path.\n\tnumInvoices := int(input.MaxHTLCNumber / 2)\n\n\tbobAmt := int64(numInvoices * paymentAmt)\n\taliceAmt := info.LocalBalance - bobAmt\n\n\t// With the channel open, we'll create invoices for Bob that Alice\n\t// will pay to in order to advance the state of the channel.\n\tbobPayReqs, _, _ := ht.CreatePayReqs(bob, paymentAmt, numInvoices)\n\n\t// Simultaneously send payments from Alice to Bob using of Bob's\n\t// payment hashes generated above.\n\tnow := time.Now()\n\n\tsettled := make(chan struct{})\n\tdefer close(settled)\n\n\ttimeout := wait.AsyncBenchmarkTimeout\n\tfor i := 0; i < numInvoices; i++ {\n\t\tpayReq := bobPayReqs[i]\n\t\tgo func() {\n\t\t\treq := &routerrpc.SendPaymentRequest{\n\t\t\t\tPaymentRequest: payReq,\n\t\t\t\tTimeoutSeconds: int32(timeout.Seconds()),\n\t\t\t\tFeeLimitMsat:   noFeeLimitMsat,\n\t\t\t}\n\t\t\t// AssertPaymentStatusWithTimeout will assert that the\n\t\t\t// payment is settled.\n\t\t\tstream := alice.RPC.SendPayment(req)\n\t\t\tht.AssertPaymentSucceedWithTimeout(stream, timeout)\n\n\t\t\tsettled <- struct{}{}\n\t\t}()\n\t}\n\n\t// Wait until all the payments have settled.\n\ttimer := time.After(timeout)\n\tfor i := 0; i < numInvoices; i++ {\n\t\tselect {\n\t\tcase <-settled:\n\t\tcase <-timer:\n\t\t\trequire.Fail(ht, \"timeout\", \"wait payment failed\")\n\t\t}\n\t}\n\n\t// All payments have been sent, mark the finish time.\n\ttimeTaken := time.Since(now)\n\n\t// Wait for the revocation to be received so alice no longer has\n\t// pending htlcs listed and has correct balances. This is needed due to\n\t// the fact that we now pipeline the settles.\n\tassertChannelState(ht, alice, chanPoint, aliceAmt, bobAmt)\n\n\t// Wait for Bob to receive revocation from Alice.\n\tassertChannelState(ht, bob, chanPoint, bobAmt, aliceAmt)\n\n\tht.Log(\"\\tBenchmark info: Elapsed time: \", timeTaken)\n\tht.Log(\"\\tBenchmark info: TPS: \",\n\t\tfloat64(numInvoices)/timeTaken.Seconds())\n\n\t// Finally, immediately close the channel. This function will also\n\t// block until the channel is closed and will additionally assert the\n\t// relevant channel closing post conditions.\n\tht.CloseChannel(alice, chanPoint)\n}\n\n// testBidirectionalAsyncPayments tests that nodes are able to send the\n// payments to each other in async manner without blocking.",
      "length": 2800,
      "tokens": 399,
      "embedding": []
    },
    {
      "slug": "func testBidirectionalAsyncPayments(ht *lntest.HarnessTest) {",
      "content": "func testBidirectionalAsyncPayments(ht *lntest.HarnessTest) {\n\tconst paymentAmt = 1000\n\n\t// We use new nodes here as the benchmark test creates lots of data\n\t// which can be costly to be carried on.\n\targs := []string{\n\t\t// Increase the dust threshold to avoid the payments fail due\n\t\t// to threshold limit reached.\n\t\t\"--dust-threshold=5000000\",\n\n\t\t// Increase the pending commit interval since there are lots of\n\t\t// commitment dances.\n\t\t\"--pending-commit-interval=5m\",\n\n\t\t// Increase the mailbox delivery timeout as there are lots of\n\t\t// ADDs going on.\n\t\t\"--htlcswitch.mailboxdeliverytimeout=2m\",\n\t}\n\talice := ht.NewNode(\"Alice\", args)\n\tbob := ht.NewNode(\"Bob\", args)\n\n\tht.EnsureConnected(alice, bob)\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, alice)\n\n\t// First establish a channel with a capacity equals to the overall\n\t// amount of payments, between Alice and Bob, at the end of the test\n\t// Alice should send all money from her side to Bob.\n\tchanPoint := ht.OpenChannel(\n\t\talice, bob, lntest.OpenChannelParams{\n\t\t\tAmt:     paymentAmt * 2000,\n\t\t\tPushAmt: paymentAmt * 1000,\n\t\t},\n\t)\n\n\tinfo := ht.QueryChannelByChanPoint(alice, chanPoint)\n\n\t// We'll create a number of invoices equal the max number of HTLCs that\n\t// can be carried in one direction. The number on the commitment will\n\t// likely be lower, but we can't guarantee that any more HTLCs will\n\t// succeed due to the limited path diversity and inability of the router\n\t// to retry via another path.\n\tnumInvoices := int(input.MaxHTLCNumber / 2)\n\n\t// Nodes should exchange the same amount of money and because of this\n\t// at the end balances should remain the same.\n\taliceAmt := info.LocalBalance\n\tbobAmt := info.RemoteBalance\n\n\t// With the channel open, we'll create invoices for Bob that Alice\n\t// will pay to in order to advance the state of the channel.\n\tbobPayReqs, _, _ := ht.CreatePayReqs(bob, paymentAmt, numInvoices)\n\n\t// With the channel open, we'll create invoices for Alice that Bob\n\t// will pay to in order to advance the state of the channel.\n\talicePayReqs, _, _ := ht.CreatePayReqs(alice, paymentAmt, numInvoices)\n\n\t// Reset mission control to prevent previous payment results from\n\t// interfering with this test. A new channel has been opened, but\n\t// mission control operates on node pairs.\n\talice.RPC.ResetMissionControl()\n\n\t// Send payments from Alice to Bob and from Bob to Alice in async\n\t// manner.\n\tsettled := make(chan struct{})\n\tdefer close(settled)\n\n\ttimeout := wait.AsyncBenchmarkTimeout * 2\n\tsend := func(node *node.HarnessNode, payReq string) {\n\t\treq := &routerrpc.SendPaymentRequest{\n\t\t\tPaymentRequest: payReq,\n\t\t\tTimeoutSeconds: int32(timeout.Seconds()),\n\t\t\tFeeLimitMsat:   noFeeLimitMsat,\n\t\t}\n\t\t// AssertPaymentStatusWithTimeout will assert that the\n\t\t// payment is settled.\n\t\tstream := node.RPC.SendPayment(req)\n\t\tht.AssertPaymentSucceedWithTimeout(stream, timeout)\n\n\t\tsettled <- struct{}{}\n\t}\n\n\tfor i := 0; i < numInvoices; i++ {\n\t\tgo send(bob, alicePayReqs[i])\n\t\tgo send(alice, bobPayReqs[i])\n\t}\n\n\t// Expect all payments to succeed.\n\ttimer := time.After(timeout)\n\tfor i := 0; i < 2*numInvoices; i++ {\n\t\tselect {\n\t\tcase <-settled:\n\t\tcase <-timer:\n\t\t\trequire.Fail(ht, \"timeout\", \"wait payment failed\")\n\t\t}\n\t}\n\n\t// Wait for Alice and Bob to receive revocations messages, and update\n\t// states, i.e. balance info.\n\tassertChannelState(ht, alice, chanPoint, aliceAmt, bobAmt)\n\n\t// Next query for Bob's and Alice's channel states, in order to confirm\n\t// that all payment have been successful transmitted.\n\tassertChannelState(ht, bob, chanPoint, bobAmt, aliceAmt)\n\n\t// Finally, immediately close the channel. This function will also\n\t// block until the channel is closed and will additionally assert the\n\t// relevant channel closing post conditions.\n\tht.CloseChannel(alice, chanPoint)\n}\n",
      "length": 3602,
      "tokens": 523,
      "embedding": []
    },
    {
      "slug": "func testInvoiceSubscriptions(ht *lntest.HarnessTest) {",
      "content": "func testInvoiceSubscriptions(ht *lntest.HarnessTest) {\n\tconst chanAmt = btcutil.Amount(500000)\n\n\talice, bob := ht.Alice, ht.Bob\n\n\t// Create a new invoice subscription client for Bob, the notification\n\t// should be dispatched shortly below.\n\treq := &lnrpc.InvoiceSubscription{}\n\tbobInvoiceSubscription := bob.RPC.SubscribeInvoices(req)\n\n\t// Open a channel with 500k satoshis between Alice and Bob with Alice\n\t// being the sole funder of the channel.\n\tchanPoint := ht.OpenChannel(\n\t\talice, bob, lntest.OpenChannelParams{Amt: chanAmt},\n\t)\n\n\t// Next create a new invoice for Bob requesting 1k satoshis.\n\tconst paymentAmt = 1000\n\tinvoice := &lnrpc.Invoice{\n\t\tMemo:      \"testing\",\n\t\tRPreimage: ht.Random32Bytes(),\n\t\tValue:     paymentAmt,\n\t}\n\tinvoiceResp := bob.RPC.AddInvoice(invoice)\n\tlastAddIndex := invoiceResp.AddIndex\n\n\t// With the above invoice added, we should receive an update event.\n\tinvoiceUpdate := ht.ReceiveInvoiceUpdate(bobInvoiceSubscription)\n\trequire.NotEqual(ht, lnrpc.Invoice_SETTLED, invoiceUpdate.State,\n\t\t\"invoice should not be settled\")\n\n\t// With the assertion above set up, send a payment from Alice to Bob\n\t// which should finalize and settle the invoice.\n\tht.CompletePaymentRequests(alice, []string{invoiceResp.PaymentRequest})\n\n\t// The invoice update should exactly match the invoice created\n\t// above, but should now be settled and have SettleDate\n\tinvoiceUpdate = ht.ReceiveInvoiceUpdate(bobInvoiceSubscription)\n\trequire.Equal(ht, lnrpc.Invoice_SETTLED, invoiceUpdate.State,\n\t\t\"invoice not settled but should be\")\n\trequire.NotZero(ht, invoiceUpdate.SettleDate,\n\t\t\"invoice should have non zero settle date, but doesn't\")\n\trequire.Equal(ht, invoice.RPreimage, invoiceUpdate.RPreimage,\n\t\t\"payment preimages don't match\")\n\trequire.NotZero(ht, invoiceUpdate.SettleIndex,\n\t\t\"invoice should have settle index\")\n\tsettleIndex := invoiceUpdate.SettleIndex\n\n\t// We'll now add 3 more invoices to Bob's invoice registry.\n\tconst numInvoices = 3\n\tpayReqs, _, newInvoices := ht.CreatePayReqs(\n\t\tbob, paymentAmt, numInvoices,\n\t)\n\n\t// Now that the set of invoices has been added, we'll re-register for\n\t// streaming invoice notifications for Bob, this time specifying the\n\t// add invoice of the last prior invoice.\n\treq = &lnrpc.InvoiceSubscription{AddIndex: lastAddIndex}\n\tbobInvoiceSubscription = bob.RPC.SubscribeInvoices(req)\n\n\t// Since we specified a value of the prior add index above, we should\n\t// now immediately get the invoices we just added as we should get the\n\t// backlog of notifications.\n\tfor i := 0; i < numInvoices; i++ {\n\t\tinvoiceUpdate := ht.ReceiveInvoiceUpdate(bobInvoiceSubscription)\n\n\t\t// We should now get the ith invoice we added, as they should\n\t\t// be returned in order.\n\t\trequire.NotEqual(ht, lnrpc.Invoice_SETTLED, invoiceUpdate.State,\n\t\t\t\"should have only received add events\")\n\n\t\toriginalInvoice := newInvoices[i]\n\t\trHash := sha256.Sum256(originalInvoice.RPreimage)\n\t\trequire.Equal(ht, rHash[:], invoiceUpdate.RHash,\n\t\t\t\"invoices have mismatched payment hashes\")\n\t}\n\n\t// We'll now have Bob settle out the remainder of these invoices so we\n\t// can test that all settled invoices are properly notified.\n\tht.CompletePaymentRequests(alice, payReqs)\n\n\t// With the set of invoices paid, we'll now cancel the old\n\t// subscription, and create a new one for Bob, this time using the\n\t// settle index to obtain the backlog of settled invoices.\n\treq = &lnrpc.InvoiceSubscription{\n\t\tSettleIndex: settleIndex,\n\t}\n\tbobInvoiceSubscription = bob.RPC.SubscribeInvoices(req)\n\n\t// As we specified the index of the past settle index, we should now\n\t// receive notifications for the three HTLCs that we just settled. As\n\t// the order that the HTLCs will be settled in is partially randomized,\n\t// we'll use a map to assert that the proper set has been settled.\n\tsettledInvoices := make(map[[32]byte]struct{})\n\tfor _, invoice := range newInvoices {\n\t\trHash := sha256.Sum256(invoice.RPreimage)\n\t\tsettledInvoices[rHash] = struct{}{}\n\t}\n\tfor i := 0; i < numInvoices; i++ {\n\t\tinvoiceUpdate := ht.ReceiveInvoiceUpdate(bobInvoiceSubscription)\n\n\t\t// We should now get the ith invoice we added, as they should\n\t\t// be returned in order.\n\t\trequire.Equal(ht, lnrpc.Invoice_SETTLED, invoiceUpdate.State,\n\t\t\t\"should have only received settle events\")\n\n\t\tvar rHash [32]byte\n\t\tcopy(rHash[:], invoiceUpdate.RHash)\n\t\trequire.Contains(ht, settledInvoices, rHash,\n\t\t\t\"unknown invoice settled\")\n\n\t\tdelete(settledInvoices, rHash)\n\t}\n\n\t// At this point, all the invoices should be fully settled.\n\trequire.Empty(ht, settledInvoices, \"not all invoices settled\")\n\n\t// TODO(yy): remove the sleep once the following bug is fixed.\n\t// When the invoice is reported settled, the commitment dance is not\n\t// yet finished, which can cause an error when closing the channel,\n\t// saying there's active HTLCs. We need to investigate this issue and\n\t// reverse the order to, first finish the commitment dance, then report\n\t// the invoice as settled.\n\ttime.Sleep(2 * time.Second)\n\n\tht.CloseChannel(alice, chanPoint)\n}\n\n// assertChannelState asserts the channel state by checking the values in\n// fields, LocalBalance, RemoteBalance and num of PendingHtlcs.",
      "length": 4954,
      "tokens": 646,
      "embedding": []
    },
    {
      "slug": "func assertChannelState(ht *lntest.HarnessTest, hn *node.HarnessNode,",
      "content": "func assertChannelState(ht *lntest.HarnessTest, hn *node.HarnessNode,\n\tcp *lnrpc.ChannelPoint, localBalance, remoteBalance int64) {\n\n\t// Get the funding point.\n\terr := wait.NoError(func() error {\n\t\t// Find the target channel first.\n\t\ttarget := ht.GetChannelByChanPoint(hn, cp)\n\n\t\tif len(target.PendingHtlcs) != 0 {\n\t\t\treturn fmt.Errorf(\"pending htlcs is \"+\n\t\t\t\t\"incorrect, got %v, expected %v\",\n\t\t\t\tlen(target.PendingHtlcs), 0)\n\t\t}\n\n\t\tif target.LocalBalance != localBalance {\n\t\t\treturn fmt.Errorf(\"local balance is \"+\n\t\t\t\t\"incorrect, got %v, expected %v\",\n\t\t\t\ttarget.LocalBalance, localBalance)\n\t\t}\n\n\t\tif target.RemoteBalance != remoteBalance {\n\t\t\treturn fmt.Errorf(\"remote balance is \"+\n\t\t\t\t\"incorrect, got %v, expected %v\",\n\t\t\t\ttarget.RemoteBalance, remoteBalance)\n\t\t}\n\n\t\treturn nil\n\t}, lntest.DefaultTimeout)\n\trequire.NoError(ht, err, \"timeout while chekcing for balance\")\n}\n",
      "length": 779,
      "tokens": 92,
      "embedding": []
    }
  ]
}