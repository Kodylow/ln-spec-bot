{
  "filepath": "../implementations/go/lnd/itest/lnd_taproot_test.go",
  "package": "itest",
  "sections": [
    {
      "slug": "func testTaproot(ht *lntest.HarnessTest) {",
      "content": "func testTaproot(ht *lntest.HarnessTest) {\n\ttestTaprootSendCoinsKeySpendBip86(ht, ht.Alice)\n\ttestTaprootComputeInputScriptKeySpendBip86(ht, ht.Alice)\n\ttestTaprootSignOutputRawScriptSpend(ht, ht.Alice)\n\ttestTaprootSignOutputRawScriptSpend(\n\t\tht, ht.Alice, txscript.SigHashSingle,\n\t)\n\ttestTaprootSignOutputRawKeySpendBip86(ht, ht.Alice)\n\ttestTaprootSignOutputRawKeySpendBip86(\n\t\tht, ht.Alice, txscript.SigHashSingle,\n\t)\n\ttestTaprootSignOutputRawKeySpendRootHash(ht, ht.Alice)\n\n\tmuSig2Versions := []signrpc.MuSig2Version{\n\t\tsignrpc.MuSig2Version_MUSIG2_VERSION_V040,\n\t\tsignrpc.MuSig2Version_MUSIG2_VERSION_V100RC2,\n\t}\n\tfor _, version := range muSig2Versions {\n\t\ttestTaprootMuSig2KeySpendBip86(ht, ht.Alice, version)\n\t\ttestTaprootMuSig2KeySpendRootHash(ht, ht.Alice, version)\n\t\ttestTaprootMuSig2ScriptSpend(ht, ht.Alice, version)\n\t\ttestTaprootMuSig2CombinedLeafKeySpend(ht, ht.Alice, version)\n\t\ttestMuSig2CombineKey(ht, ht.Alice, version)\n\t}\n\n\ttestTaprootImportTapscriptFullTree(ht, ht.Alice)\n\ttestTaprootImportTapscriptPartialReveal(ht, ht.Alice)\n\ttestTaprootImportTapscriptRootHashOnly(ht, ht.Alice)\n\ttestTaprootImportTapscriptFullKey(ht, ht.Alice)\n}\n\n// testTaprootSendCoinsKeySpendBip86 tests sending to and spending from\n// p2tr key spend only (BIP-0086) addresses through the SendCoins RPC which\n// internally uses the ComputeInputScript method for signing.",
      "length": 1284,
      "tokens": 86,
      "embedding": []
    },
    {
      "slug": "func testTaprootSendCoinsKeySpendBip86(ht *lntest.HarnessTest,",
      "content": "func testTaprootSendCoinsKeySpendBip86(ht *lntest.HarnessTest,\n\talice *node.HarnessNode) {\n\n\t// We'll start the test by sending Alice some coins, which she'll use to\n\t// send to herself on a p2tr output.\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, alice)\n\n\t// Let's create a p2tr address now.\n\tp2trResp := alice.RPC.NewAddress(&lnrpc.NewAddressRequest{\n\t\tType: AddrTypeTaprootPubkey,\n\t})\n\n\t// Assert this is a segwit v1 address that starts with bcrt1p.\n\trequire.Contains(\n\t\tht, p2trResp.Address, ht.Miner.ActiveNet.Bech32HRPSegwit+\"1p\",\n\t)\n\n\t// Send the coins from Alice's wallet to her own, but to the new p2tr\n\t// address.\n\talice.RPC.SendCoins(&lnrpc.SendCoinsRequest{\n\t\tAddr:   p2trResp.Address,\n\t\tAmount: 0.5 * btcutil.SatoshiPerBitcoin,\n\t})\n\n\ttxid := ht.Miner.AssertNumTxsInMempool(1)[0]\n\n\t// Wait until bob has seen the tx and considers it as owned.\n\tp2trOutputIndex := ht.GetOutputIndex(txid, p2trResp.Address)\n\top := &lnrpc.OutPoint{\n\t\tTxidBytes:   txid[:],\n\t\tOutputIndex: uint32(p2trOutputIndex),\n\t}\n\tht.AssertUTXOInWallet(alice, op, \"\")\n\n\t// Mine a block to clean up the mempool.\n\tht.MineBlocksAndAssertNumTxes(1, 1)\n\n\t// Let's sweep the whole wallet to a new p2tr address, making sure we\n\t// can sign transactions with v0 and v1 inputs.\n\tp2trResp = alice.RPC.NewAddress(&lnrpc.NewAddressRequest{\n\t\tType: lnrpc.AddressType_TAPROOT_PUBKEY,\n\t})\n\n\talice.RPC.SendCoins(&lnrpc.SendCoinsRequest{\n\t\tAddr:    p2trResp.Address,\n\t\tSendAll: true,\n\t})\n\n\t// Make sure the coins sent to the address are confirmed correctly,\n\t// including the confirmation notification.\n\tconfirmAddress(ht, alice, p2trResp.Address)\n}\n\n// testTaprootComputeInputScriptKeySpendBip86 tests sending to and spending from\n// p2tr key spend only (BIP-0086) addresses through the SendCoins RPC which\n// internally uses the ComputeInputScript method for signing.",
      "length": 1711,
      "tokens": 208,
      "embedding": []
    },
    {
      "slug": "func testTaprootComputeInputScriptKeySpendBip86(ht *lntest.HarnessTest,",
      "content": "func testTaprootComputeInputScriptKeySpendBip86(ht *lntest.HarnessTest,\n\talice *node.HarnessNode) {\n\n\t// We'll start the test by sending Alice some coins, which she'll use\n\t// to send to herself on a p2tr output.\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, alice)\n\n\t// Let's create a p2tr address now.\n\tp2trAddr, p2trPkScript := newAddrWithScript(\n\t\tht, alice, lnrpc.AddressType_TAPROOT_PUBKEY,\n\t)\n\n\t// Send the coins from Alice's wallet to her own, but to the new p2tr\n\t// address.\n\treq := &lnrpc.SendCoinsRequest{\n\t\tAddr:   p2trAddr.String(),\n\t\tAmount: testAmount,\n\t}\n\talice.RPC.SendCoins(req)\n\n\t// Wait until bob has seen the tx and considers it as owned.\n\ttxid := ht.Miner.AssertNumTxsInMempool(1)[0]\n\tp2trOutputIndex := ht.GetOutputIndex(txid, p2trAddr.String())\n\top := &lnrpc.OutPoint{\n\t\tTxidBytes:   txid[:],\n\t\tOutputIndex: uint32(p2trOutputIndex),\n\t}\n\tht.AssertUTXOInWallet(alice, op, \"\")\n\n\tp2trOutpoint := wire.OutPoint{\n\t\tHash:  *txid,\n\t\tIndex: uint32(p2trOutputIndex),\n\t}\n\n\t// Mine a block to clean up the mempool.\n\tht.MineBlocksAndAssertNumTxes(1, 1)\n\n\t// We'll send the coins back to a p2wkh address.\n\tp2wkhAddr, p2wkhPkScript := newAddrWithScript(\n\t\tht, alice, lnrpc.AddressType_WITNESS_PUBKEY_HASH,\n\t)\n\n\t// Create fee estimation for a p2tr input and p2wkh output.\n\tfeeRate := chainfee.SatPerKWeight(12500)\n\testimator := input.TxWeightEstimator{}\n\testimator.AddTaprootKeySpendInput(txscript.SigHashDefault)\n\testimator.AddP2WKHOutput()\n\testimatedWeight := int64(estimator.Weight())\n\trequiredFee := feeRate.FeeForWeight(estimatedWeight)\n\n\ttx := wire.NewMsgTx(2)\n\ttx.TxIn = []*wire.TxIn{{\n\t\tPreviousOutPoint: p2trOutpoint,\n\t}}\n\tvalue := int64(testAmount - requiredFee)\n\ttx.TxOut = []*wire.TxOut{{\n\t\tPkScript: p2wkhPkScript,\n\t\tValue:    value,\n\t}}\n\n\tvar buf bytes.Buffer\n\trequire.NoError(ht, tx.Serialize(&buf))\n\n\tutxoInfo := []*signrpc.TxOut{{\n\t\tPkScript: p2trPkScript,\n\t\tValue:    testAmount,\n\t}}\n\tsignReq := &signrpc.SignReq{\n\t\tRawTxBytes: buf.Bytes(),\n\t\tSignDescs: []*signrpc.SignDescriptor{{\n\t\t\tOutput:     utxoInfo[0],\n\t\t\tInputIndex: 0,\n\t\t\tSighash:    uint32(txscript.SigHashDefault),\n\t\t}},\n\t\tPrevOutputs: utxoInfo,\n\t}\n\tsignResp := alice.RPC.ComputeInputScript(signReq)\n\n\ttx.TxIn[0].Witness = signResp.InputScripts[0].Witness\n\n\t// Serialize, weigh and publish the TX now, then make sure the\n\t// coins are sent and confirmed to the final sweep destination address.\n\tpublishTxAndConfirmSweep(\n\t\tht, alice, tx, estimatedWeight,\n\t\t&chainrpc.SpendRequest{\n\t\t\tOutpoint: &chainrpc.Outpoint{\n\t\t\t\tHash:  p2trOutpoint.Hash[:],\n\t\t\t\tIndex: p2trOutpoint.Index,\n\t\t\t},\n\t\t\tScript: p2trPkScript,\n\t\t},\n\t\tp2wkhAddr.String(),\n\t)\n}\n\n// testTaprootSignOutputRawScriptSpend tests sending to and spending from p2tr\n// script addresses using the script path with the SignOutputRaw RPC.",
      "length": 2606,
      "tokens": 282,
      "embedding": []
    },
    {
      "slug": "func testTaprootSignOutputRawScriptSpend(ht *lntest.HarnessTest,",
      "content": "func testTaprootSignOutputRawScriptSpend(ht *lntest.HarnessTest,\n\talice *node.HarnessNode, sigHashType ...txscript.SigHashType) {\n\n\t// For the next step, we need a public key. Let's use a special family\n\t// for this.\n\treq := &walletrpc.KeyReq{KeyFamily: testTaprootKeyFamily}\n\tkeyDesc := alice.RPC.DeriveNextKey(req)\n\n\tleafSigningKey, err := btcec.ParsePubKey(keyDesc.RawKeyBytes)\n\trequire.NoError(ht, err)\n\n\t// Let's create a taproot script output now. This is a hash lock with a\n\t// simple preimage of \"foobar\".\n\tleaf1 := testScriptHashLock(ht.T, []byte(\"foobar\"))\n\n\t// Let's add a second script output as well to test the partial reveal.\n\tleaf2 := testScriptSchnorrSig(ht.T, leafSigningKey)\n\n\tinclusionProof := leaf1.TapHash()\n\ttapscript := input.TapscriptPartialReveal(\n\t\tdummyInternalKey, leaf2, inclusionProof[:],\n\t)\n\ttaprootKey, err := tapscript.TaprootKey()\n\trequire.NoError(ht, err)\n\n\t// Send some coins to the generated tapscript address.\n\tp2trOutpoint, p2trPkScript := sendToTaprootOutput(ht, alice, taprootKey)\n\n\t// Spend the output again, this time back to a p2wkh address.\n\tp2wkhAddr, p2wkhPkScript := newAddrWithScript(\n\t\tht, alice, lnrpc.AddressType_WITNESS_PUBKEY_HASH,\n\t)\n\n\t// Create fee estimation for a p2tr input and p2wkh output.\n\tfeeRate := chainfee.SatPerKWeight(12500)\n\testimator := input.TxWeightEstimator{}\n\testimator.AddTapscriptInput(\n\t\tinput.TaprootSignatureWitnessSize, tapscript,\n\t)\n\testimator.AddP2WKHOutput()\n\n\testimatedWeight := int64(estimator.Weight())\n\tsigHash := txscript.SigHashDefault\n\tif len(sigHashType) != 0 {\n\t\tsigHash = sigHashType[0]\n\n\t\t// If a non-default sighash is used, then we'll need to add an\n\t\t// extra byte to account for the sighash that doesn't exist in\n\t\t// the default case.\n\t\testimatedWeight++\n\t}\n\n\trequiredFee := feeRate.FeeForWeight(estimatedWeight)\n\n\ttx := wire.NewMsgTx(2)\n\ttx.TxIn = []*wire.TxIn{{\n\t\tPreviousOutPoint: p2trOutpoint,\n\t}}\n\tvalue := int64(testAmount - requiredFee)\n\ttx.TxOut = []*wire.TxOut{{\n\t\tPkScript: p2wkhPkScript,\n\t\tValue:    value,\n\t}}\n\n\tvar buf bytes.Buffer\n\trequire.NoError(ht, tx.Serialize(&buf))\n\n\tutxoInfo := []*signrpc.TxOut{{\n\t\tPkScript: p2trPkScript,\n\t\tValue:    testAmount,\n\t}}\n\n\t// Before we actually sign, we want to make sure that we get an error\n\t// when we try to sign for a Taproot output without specifying all UTXO\n\t// information.\n\tsignReq := &signrpc.SignReq{\n\t\tRawTxBytes: buf.Bytes(),\n\t\tSignDescs: []*signrpc.SignDescriptor{{\n\t\t\tOutput:        utxoInfo[0],\n\t\t\tInputIndex:    0,\n\t\t\tKeyDesc:       keyDesc,\n\t\t\tSighash:       uint32(sigHash),\n\t\t\tWitnessScript: leaf2.Script,\n\t\t\tSignMethod:    signMethodTapscript,\n\t\t}},\n\t}\n\terr = alice.RPC.SignOutputRawErr(signReq)\n\trequire.Contains(\n\t\tht, err.Error(), \"error signing taproot output, transaction \"+\n\t\t\t\"input 0 is missing its previous outpoint information\",\n\t)\n\n\t// We also want to make sure we get an error when we don't specify the\n\t// correct signing method.\n\tsignReq = &signrpc.SignReq{\n\t\tRawTxBytes: buf.Bytes(),\n\t\tSignDescs: []*signrpc.SignDescriptor{{\n\t\t\tOutput:        utxoInfo[0],\n\t\t\tInputIndex:    0,\n\t\t\tKeyDesc:       keyDesc,\n\t\t\tSighash:       uint32(sigHash),\n\t\t\tWitnessScript: leaf2.Script,\n\t\t}},\n\t\tPrevOutputs: utxoInfo,\n\t}\n\terr = alice.RPC.SignOutputRawErr(signReq)\n\trequire.Contains(\n\t\tht, err.Error(), \"selected sign method witness_v0 is not \"+\n\t\t\t\"compatible with given pk script 5120\",\n\t)\n\n\t// Do the actual signing now.\n\tsignReq = &signrpc.SignReq{\n\t\tRawTxBytes: buf.Bytes(),\n\t\tSignDescs: []*signrpc.SignDescriptor{{\n\t\t\tOutput:        utxoInfo[0],\n\t\t\tInputIndex:    0,\n\t\t\tKeyDesc:       keyDesc,\n\t\t\tSighash:       uint32(sigHash),\n\t\t\tWitnessScript: leaf2.Script,\n\t\t\tSignMethod:    signMethodTapscript,\n\t\t}},\n\t\tPrevOutputs: utxoInfo,\n\t}\n\tsignResp := alice.RPC.SignOutputRaw(signReq)\n\n\t// We can now assemble the witness stack.\n\tcontrolBlockBytes, err := tapscript.ControlBlock.ToBytes()\n\trequire.NoError(ht, err)\n\n\tsig := signResp.RawSigs[0]\n\tif len(sigHashType) != 0 {\n\t\tsig = append(sig, byte(sigHashType[0]))\n\t}\n\ttx.TxIn[0].Witness = wire.TxWitness{\n\t\tsig, leaf2.Script, controlBlockBytes,\n\t}\n\n\t// Serialize, weigh and publish the TX now, then make sure the\n\t// coins are sent and confirmed to the final sweep destination address.\n\tpublishTxAndConfirmSweep(\n\t\tht, alice, tx, estimatedWeight,\n\t\t&chainrpc.SpendRequest{\n\t\t\tOutpoint: &chainrpc.Outpoint{\n\t\t\t\tHash:  p2trOutpoint.Hash[:],\n\t\t\t\tIndex: p2trOutpoint.Index,\n\t\t\t},\n\t\t\tScript: p2trPkScript,\n\t\t},\n\t\tp2wkhAddr.String(),\n\t)\n}\n\n// testTaprootSignOutputRawKeySpendBip86 tests that a tapscript address can\n// also be spent using the key spend path through the SignOutputRaw RPC using a\n// BIP0086 key spend only commitment.",
      "length": 4431,
      "tokens": 506,
      "embedding": []
    },
    {
      "slug": "func testTaprootSignOutputRawKeySpendBip86(ht *lntest.HarnessTest,",
      "content": "func testTaprootSignOutputRawKeySpendBip86(ht *lntest.HarnessTest,\n\talice *node.HarnessNode, sigHashType ...txscript.SigHashType) {\n\n\t// For the next step, we need a public key. Let's use a special family\n\t// for this.\n\treq := &walletrpc.KeyReq{KeyFamily: testTaprootKeyFamily}\n\tkeyDesc := alice.RPC.DeriveNextKey(req)\n\n\tinternalKey, err := btcec.ParsePubKey(keyDesc.RawKeyBytes)\n\trequire.NoError(ht, err)\n\n\t// We want to make sure we can still use a tweaked key, even if it ends\n\t// up being essentially double tweaked because of the taproot root hash.\n\tdummyKeyTweak := sha256.Sum256([]byte(\"this is a key tweak\"))\n\tinternalKey = input.TweakPubKeyWithTweak(internalKey, dummyKeyTweak[:])\n\n\t// Our taproot key is a BIP0086 key spend only construction that just\n\t// commits to the internal key and no root hash.\n\ttaprootKey := txscript.ComputeTaprootKeyNoScript(internalKey)\n\n\t// Send some coins to the generated tapscript address.\n\tp2trOutpoint, p2trPkScript := sendToTaprootOutput(ht, alice, taprootKey)\n\n\t// Spend the output again, this time back to a p2wkh address.\n\tp2wkhAddr, p2wkhPkScript := newAddrWithScript(\n\t\tht, alice, lnrpc.AddressType_WITNESS_PUBKEY_HASH,\n\t)\n\n\tsigHash := txscript.SigHashDefault\n\tif len(sigHashType) != 0 {\n\t\tsigHash = sigHashType[0]\n\t}\n\n\t// Create fee estimation for a p2tr input and p2wkh output.\n\tfeeRate := chainfee.SatPerKWeight(12500)\n\testimator := input.TxWeightEstimator{}\n\testimator.AddTaprootKeySpendInput(sigHash)\n\testimator.AddP2WKHOutput()\n\testimatedWeight := int64(estimator.Weight())\n\trequiredFee := feeRate.FeeForWeight(estimatedWeight)\n\n\ttx := wire.NewMsgTx(2)\n\ttx.TxIn = []*wire.TxIn{{\n\t\tPreviousOutPoint: p2trOutpoint,\n\t}}\n\tvalue := int64(testAmount - requiredFee)\n\ttx.TxOut = []*wire.TxOut{{\n\t\tPkScript: p2wkhPkScript,\n\t\tValue:    value,\n\t}}\n\n\tvar buf bytes.Buffer\n\trequire.NoError(ht, tx.Serialize(&buf))\n\n\tutxoInfo := []*signrpc.TxOut{{\n\t\tPkScript: p2trPkScript,\n\t\tValue:    testAmount,\n\t}}\n\tsignReq := &signrpc.SignReq{\n\t\tRawTxBytes: buf.Bytes(),\n\t\tSignDescs: []*signrpc.SignDescriptor{{\n\t\t\tOutput:      utxoInfo[0],\n\t\t\tInputIndex:  0,\n\t\t\tKeyDesc:     keyDesc,\n\t\t\tSingleTweak: dummyKeyTweak[:],\n\t\t\tSighash:     uint32(sigHash),\n\t\t\tSignMethod:  signMethodBip86,\n\t\t}},\n\t\tPrevOutputs: utxoInfo,\n\t}\n\tsignResp := alice.RPC.SignOutputRaw(signReq)\n\n\tsig := signResp.RawSigs[0]\n\tif len(sigHashType) != 0 {\n\t\tsig = append(sig, byte(sigHash))\n\t}\n\ttx.TxIn[0].Witness = wire.TxWitness{sig}\n\n\t// Serialize, weigh and publish the TX now, then make sure the\n\t// coins are sent and confirmed to the final sweep destination address.\n\tpublishTxAndConfirmSweep(\n\t\tht, alice, tx, estimatedWeight,\n\t\t&chainrpc.SpendRequest{\n\t\t\tOutpoint: &chainrpc.Outpoint{\n\t\t\t\tHash:  p2trOutpoint.Hash[:],\n\t\t\t\tIndex: p2trOutpoint.Index,\n\t\t\t},\n\t\t\tScript: p2trPkScript,\n\t\t},\n\t\tp2wkhAddr.String(),\n\t)\n}\n\n// testTaprootSignOutputRawKeySpendRootHash tests that a tapscript address can\n// also be spent using the key spend path through the SignOutputRaw RPC using a\n// tapscript root hash.",
      "length": 2839,
      "tokens": 321,
      "embedding": []
    },
    {
      "slug": "func testTaprootSignOutputRawKeySpendRootHash(ht *lntest.HarnessTest,",
      "content": "func testTaprootSignOutputRawKeySpendRootHash(ht *lntest.HarnessTest,\n\talice *node.HarnessNode) {\n\n\t// For the next step, we need a public key. Let's use a special family\n\t// for this.\n\treq := &walletrpc.KeyReq{KeyFamily: testTaprootKeyFamily}\n\tkeyDesc := alice.RPC.DeriveNextKey(req)\n\n\tinternalKey, err := btcec.ParsePubKey(keyDesc.RawKeyBytes)\n\trequire.NoError(ht, err)\n\n\t// We want to make sure we can still use a tweaked key, even if it ends\n\t// up being essentially double tweaked because of the taproot root hash.\n\tdummyKeyTweak := sha256.Sum256([]byte(\"this is a key tweak\"))\n\tinternalKey = input.TweakPubKeyWithTweak(internalKey, dummyKeyTweak[:])\n\n\t// Let's create a taproot script output now. This is a hash lock with a\n\t// simple preimage of \"foobar\".\n\tleaf1 := testScriptHashLock(ht.T, []byte(\"foobar\"))\n\n\trootHash := leaf1.TapHash()\n\ttaprootKey := txscript.ComputeTaprootOutputKey(internalKey, rootHash[:])\n\n\t// Send some coins to the generated tapscript address.\n\tp2trOutpoint, p2trPkScript := sendToTaprootOutput(ht, alice, taprootKey)\n\n\t// Spend the output again, this time back to a p2wkh address.\n\tp2wkhAddr, p2wkhPkScript := newAddrWithScript(\n\t\tht, alice, lnrpc.AddressType_WITNESS_PUBKEY_HASH,\n\t)\n\n\t// Create fee estimation for a p2tr input and p2wkh output.\n\tfeeRate := chainfee.SatPerKWeight(12500)\n\testimator := input.TxWeightEstimator{}\n\testimator.AddTaprootKeySpendInput(txscript.SigHashDefault)\n\testimator.AddP2WKHOutput()\n\testimatedWeight := int64(estimator.Weight())\n\trequiredFee := feeRate.FeeForWeight(estimatedWeight)\n\n\ttx := wire.NewMsgTx(2)\n\ttx.TxIn = []*wire.TxIn{{\n\t\tPreviousOutPoint: p2trOutpoint,\n\t}}\n\tvalue := int64(testAmount - requiredFee)\n\ttx.TxOut = []*wire.TxOut{{\n\t\tPkScript: p2wkhPkScript,\n\t\tValue:    value,\n\t}}\n\n\tvar buf bytes.Buffer\n\trequire.NoError(ht, tx.Serialize(&buf))\n\n\tutxoInfo := []*signrpc.TxOut{{\n\t\tPkScript: p2trPkScript,\n\t\tValue:    testAmount,\n\t}}\n\tsignReq := &signrpc.SignReq{\n\t\tRawTxBytes: buf.Bytes(),\n\t\tSignDescs: []*signrpc.SignDescriptor{{\n\t\t\tOutput:      utxoInfo[0],\n\t\t\tInputIndex:  0,\n\t\t\tKeyDesc:     keyDesc,\n\t\t\tSingleTweak: dummyKeyTweak[:],\n\t\t\tSighash:     uint32(txscript.SigHashDefault),\n\t\t\tTapTweak:    rootHash[:],\n\t\t\tSignMethod:  signMethodRootHash,\n\t\t}},\n\t\tPrevOutputs: utxoInfo,\n\t}\n\tsignResp := alice.RPC.SignOutputRaw(signReq)\n\ttx.TxIn[0].Witness = wire.TxWitness{\n\t\tsignResp.RawSigs[0],\n\t}\n\n\t// Serialize, weigh and publish the TX now, then make sure the\n\t// coins are sent and confirmed to the final sweep destination address.\n\tpublishTxAndConfirmSweep(\n\t\tht, alice, tx, estimatedWeight,\n\t\t&chainrpc.SpendRequest{\n\t\t\tOutpoint: &chainrpc.Outpoint{\n\t\t\t\tHash:  p2trOutpoint.Hash[:],\n\t\t\t\tIndex: p2trOutpoint.Index,\n\t\t\t},\n\t\t\tScript: p2trPkScript,\n\t\t},\n\t\tp2wkhAddr.String(),\n\t)\n}\n\n// testTaprootMuSig2KeySpendBip86 tests that a combined MuSig2 key can also be\n// used as a BIP-0086 key spend only key.",
      "length": 2720,
      "tokens": 296,
      "embedding": []
    },
    {
      "slug": "func testTaprootMuSig2KeySpendBip86(ht *lntest.HarnessTest,",
      "content": "func testTaprootMuSig2KeySpendBip86(ht *lntest.HarnessTest,\n\talice *node.HarnessNode, version signrpc.MuSig2Version) {\n\n\t// We're not going to commit to a script. So our taproot tweak will be\n\t// empty and just specify the necessary flag.\n\ttaprootTweak := &signrpc.TaprootTweakDesc{\n\t\tKeySpendOnly: true,\n\t}\n\n\tkeyDesc1, keyDesc2, keyDesc3, allPubKeys := deriveSigningKeys(\n\t\tht, alice, version,\n\t)\n\t_, taprootKey, sessResp1, sessResp2, sessResp3 := createMuSigSessions(\n\t\tht, alice, taprootTweak, keyDesc1, keyDesc2, keyDesc3,\n\t\tallPubKeys, version,\n\t)\n\n\t// Send some coins to the generated tapscript address.\n\tp2trOutpoint, p2trPkScript := sendToTaprootOutput(ht, alice, taprootKey)\n\n\t// Spend the output again, this time back to a p2wkh address.\n\tp2wkhAddr, p2wkhPkScript := newAddrWithScript(\n\t\tht, alice, lnrpc.AddressType_WITNESS_PUBKEY_HASH,\n\t)\n\n\t// Create fee estimation for a p2tr input and p2wkh output.\n\tfeeRate := chainfee.SatPerKWeight(12500)\n\testimator := input.TxWeightEstimator{}\n\testimator.AddTaprootKeySpendInput(txscript.SigHashDefault)\n\testimator.AddP2WKHOutput()\n\testimatedWeight := int64(estimator.Weight())\n\trequiredFee := feeRate.FeeForWeight(estimatedWeight)\n\n\ttx := wire.NewMsgTx(2)\n\ttx.TxIn = []*wire.TxIn{{\n\t\tPreviousOutPoint: p2trOutpoint,\n\t}}\n\tvalue := int64(testAmount - requiredFee)\n\ttx.TxOut = []*wire.TxOut{{\n\t\tPkScript: p2wkhPkScript,\n\t\tValue:    value,\n\t}}\n\n\tvar buf bytes.Buffer\n\trequire.NoError(ht, tx.Serialize(&buf))\n\n\tutxoInfo := []*signrpc.TxOut{{\n\t\tPkScript: p2trPkScript,\n\t\tValue:    testAmount,\n\t}}\n\n\t// We now need to create the raw sighash of the transaction, as that\n\t// will be the message we're signing collaboratively.\n\tprevOutputFetcher := txscript.NewCannedPrevOutputFetcher(\n\t\tutxoInfo[0].PkScript, utxoInfo[0].Value,\n\t)\n\tsighashes := txscript.NewTxSigHashes(tx, prevOutputFetcher)\n\n\tsigHash, err := txscript.CalcTaprootSignatureHash(\n\t\tsighashes, txscript.SigHashDefault, tx, 0, prevOutputFetcher,\n\t)\n\trequire.NoError(ht, err)\n\n\t// Now that we have the transaction prepared, we need to start with the\n\t// signing. We simulate all three parties here, so we need to do\n\t// everything three times. But because we're going to use session 1 to\n\t// combine everything, we don't need its response, as it will store its\n\t// own signature.\n\tsignReq := &signrpc.MuSig2SignRequest{\n\t\tSessionId:     sessResp1.SessionId,\n\t\tMessageDigest: sigHash,\n\t}\n\talice.RPC.MuSig2Sign(signReq)\n\n\tsignReq = &signrpc.MuSig2SignRequest{\n\t\tSessionId:     sessResp2.SessionId,\n\t\tMessageDigest: sigHash,\n\t\tCleanup:       true,\n\t}\n\tsignResp2 := alice.RPC.MuSig2Sign(signReq)\n\n\tsignReq = &signrpc.MuSig2SignRequest{\n\t\tSessionId:     sessResp3.SessionId,\n\t\tMessageDigest: sigHash,\n\t\tCleanup:       true,\n\t}\n\tsignResp3 := alice.RPC.MuSig2Sign(signReq)\n\n\t// Luckily only one of the signers needs to combine the signature, so\n\t// let's do that now.\n\tcombineReq := &signrpc.MuSig2CombineSigRequest{\n\t\tSessionId: sessResp1.SessionId,\n\t\tOtherPartialSignatures: [][]byte{\n\t\t\tsignResp2.LocalPartialSignature,\n\t\t\tsignResp3.LocalPartialSignature,\n\t\t},\n\t}\n\tcombineResp := alice.RPC.MuSig2CombineSig(combineReq)\n\trequire.Equal(ht, true, combineResp.HaveAllSignatures)\n\trequire.NotEmpty(ht, combineResp.FinalSignature)\n\n\tsig, err := schnorr.ParseSignature(combineResp.FinalSignature)\n\trequire.NoError(ht, err)\n\trequire.True(ht, sig.Verify(sigHash, taprootKey))\n\n\ttx.TxIn[0].Witness = wire.TxWitness{\n\t\tcombineResp.FinalSignature,\n\t}\n\n\t// Serialize, weigh and publish the TX now, then make sure the\n\t// coins are sent and confirmed to the final sweep destination address.\n\tpublishTxAndConfirmSweep(\n\t\tht, alice, tx, estimatedWeight,\n\t\t&chainrpc.SpendRequest{\n\t\t\tOutpoint: &chainrpc.Outpoint{\n\t\t\t\tHash:  p2trOutpoint.Hash[:],\n\t\t\t\tIndex: p2trOutpoint.Index,\n\t\t\t},\n\t\t\tScript: p2trPkScript,\n\t\t},\n\t\tp2wkhAddr.String(),\n\t)\n}\n\n// testTaprootMuSig2KeySpendRootHash tests that a tapscript address can also be\n// spent using a MuSig2 combined key.",
      "length": 3759,
      "tokens": 401,
      "embedding": []
    },
    {
      "slug": "func testTaprootMuSig2KeySpendRootHash(ht *lntest.HarnessTest,",
      "content": "func testTaprootMuSig2KeySpendRootHash(ht *lntest.HarnessTest,\n\talice *node.HarnessNode, version signrpc.MuSig2Version) {\n\n\t// We're going to commit to a script as well. This is a hash lock with a\n\t// simple preimage of \"foobar\". We need to know this upfront so, we can\n\t// specify the taproot tweak with the root hash when creating the Musig2\n\t// signing session.\n\tleaf1 := testScriptHashLock(ht.T, []byte(\"foobar\"))\n\trootHash := leaf1.TapHash()\n\ttaprootTweak := &signrpc.TaprootTweakDesc{\n\t\tScriptRoot: rootHash[:],\n\t}\n\n\tkeyDesc1, keyDesc2, keyDesc3, allPubKeys := deriveSigningKeys(\n\t\tht, alice, version,\n\t)\n\t_, taprootKey, sessResp1, sessResp2, sessResp3 := createMuSigSessions(\n\t\tht, alice, taprootTweak, keyDesc1, keyDesc2, keyDesc3,\n\t\tallPubKeys, version,\n\t)\n\n\t// Send some coins to the generated tapscript address.\n\tp2trOutpoint, p2trPkScript := sendToTaprootOutput(ht, alice, taprootKey)\n\n\t// Spend the output again, this time back to a p2wkh address.\n\tp2wkhAddr, p2wkhPkScript := newAddrWithScript(\n\t\tht, alice, lnrpc.AddressType_WITNESS_PUBKEY_HASH,\n\t)\n\n\t// Create fee estimation for a p2tr input and p2wkh output.\n\tfeeRate := chainfee.SatPerKWeight(12500)\n\testimator := input.TxWeightEstimator{}\n\testimator.AddTaprootKeySpendInput(txscript.SigHashDefault)\n\testimator.AddP2WKHOutput()\n\testimatedWeight := int64(estimator.Weight())\n\trequiredFee := feeRate.FeeForWeight(estimatedWeight)\n\n\ttx := wire.NewMsgTx(2)\n\ttx.TxIn = []*wire.TxIn{{\n\t\tPreviousOutPoint: p2trOutpoint,\n\t}}\n\tvalue := int64(testAmount - requiredFee)\n\ttx.TxOut = []*wire.TxOut{{\n\t\tPkScript: p2wkhPkScript,\n\t\tValue:    value,\n\t}}\n\n\tvar buf bytes.Buffer\n\trequire.NoError(ht, tx.Serialize(&buf))\n\n\tutxoInfo := []*signrpc.TxOut{{\n\t\tPkScript: p2trPkScript,\n\t\tValue:    testAmount,\n\t}}\n\n\t// We now need to create the raw sighash of the transaction, as that\n\t// will be the message we're signing collaboratively.\n\tprevOutputFetcher := txscript.NewCannedPrevOutputFetcher(\n\t\tutxoInfo[0].PkScript, utxoInfo[0].Value,\n\t)\n\tsighashes := txscript.NewTxSigHashes(tx, prevOutputFetcher)\n\n\tsigHash, err := txscript.CalcTaprootSignatureHash(\n\t\tsighashes, txscript.SigHashDefault, tx, 0, prevOutputFetcher,\n\t)\n\trequire.NoError(ht, err)\n\n\t// Now that we have the transaction prepared, we need to start with the\n\t// signing. We simulate all three parties here, so we need to do\n\t// everything three times. But because we're going to use session 1 to\n\t// combine everything, we don't need its response, as it will store its\n\t// own signature.\n\treq := &signrpc.MuSig2SignRequest{\n\t\tSessionId:     sessResp1.SessionId,\n\t\tMessageDigest: sigHash,\n\t}\n\talice.RPC.MuSig2Sign(req)\n\n\treq = &signrpc.MuSig2SignRequest{\n\t\tSessionId:     sessResp2.SessionId,\n\t\tMessageDigest: sigHash,\n\t\tCleanup:       true,\n\t}\n\tsignResp2 := alice.RPC.MuSig2Sign(req)\n\n\treq = &signrpc.MuSig2SignRequest{\n\t\tSessionId:     sessResp3.SessionId,\n\t\tMessageDigest: sigHash,\n\t\tCleanup:       true,\n\t}\n\tsignResp3 := alice.RPC.MuSig2Sign(req)\n\n\t// Luckily only one of the signers needs to combine the signature, so\n\t// let's do that now.\n\tcombineReq := &signrpc.MuSig2CombineSigRequest{\n\t\tSessionId: sessResp1.SessionId,\n\t\tOtherPartialSignatures: [][]byte{\n\t\t\tsignResp2.LocalPartialSignature,\n\t\t\tsignResp3.LocalPartialSignature,\n\t\t},\n\t}\n\tcombineResp := alice.RPC.MuSig2CombineSig(combineReq)\n\trequire.Equal(ht, true, combineResp.HaveAllSignatures)\n\trequire.NotEmpty(ht, combineResp.FinalSignature)\n\n\tsig, err := schnorr.ParseSignature(combineResp.FinalSignature)\n\trequire.NoError(ht, err)\n\trequire.True(ht, sig.Verify(sigHash, taprootKey))\n\n\ttx.TxIn[0].Witness = wire.TxWitness{\n\t\tcombineResp.FinalSignature,\n\t}\n\n\t// Serialize, weigh and publish the TX now, then make sure the\n\t// coins are sent and confirmed to the final sweep destination address.\n\tpublishTxAndConfirmSweep(\n\t\tht, alice, tx, estimatedWeight,\n\t\t&chainrpc.SpendRequest{\n\t\t\tOutpoint: &chainrpc.Outpoint{\n\t\t\t\tHash:  p2trOutpoint.Hash[:],\n\t\t\t\tIndex: p2trOutpoint.Index,\n\t\t\t},\n\t\t\tScript: p2trPkScript,\n\t\t},\n\t\tp2wkhAddr.String(),\n\t)\n}\n\n// testTaprootMuSig2ScriptSpend tests that a tapscript address with an internal\n// key that is a MuSig2 combined key can also be spent using the script path.",
      "length": 3981,
      "tokens": 441,
      "embedding": []
    },
    {
      "slug": "func testTaprootMuSig2ScriptSpend(ht *lntest.HarnessTest,",
      "content": "func testTaprootMuSig2ScriptSpend(ht *lntest.HarnessTest,\n\talice *node.HarnessNode, version signrpc.MuSig2Version) {\n\n\t// We're going to commit to a script and spend the output using the\n\t// script. This is a hash lock with a simple preimage of \"foobar\". We\n\t// need to know this upfront so, we can specify the taproot tweak with\n\t// the root hash when creating the Musig2 signing session.\n\tleaf1 := testScriptHashLock(ht.T, []byte(\"foobar\"))\n\trootHash := leaf1.TapHash()\n\ttaprootTweak := &signrpc.TaprootTweakDesc{\n\t\tScriptRoot: rootHash[:],\n\t}\n\n\tkeyDesc1, keyDesc2, keyDesc3, allPubKeys := deriveSigningKeys(\n\t\tht, alice, version,\n\t)\n\tinternalKey, taprootKey, _, _, _ := createMuSigSessions(\n\t\tht, alice, taprootTweak, keyDesc1, keyDesc2, keyDesc3,\n\t\tallPubKeys, version,\n\t)\n\n\t// Because we know the internal key and the script we want to spend, we\n\t// can now create the tapscript struct that's used for assembling the\n\t// control block and fee estimation.\n\ttapscript := input.TapscriptFullTree(internalKey, leaf1)\n\n\t// Send some coins to the generated tapscript address.\n\tp2trOutpoint, p2trPkScript := sendToTaprootOutput(ht, alice, taprootKey)\n\n\t// Spend the output again, this time back to a p2wkh address.\n\tp2wkhAddr, p2wkhPkScript := newAddrWithScript(\n\t\tht, alice, lnrpc.AddressType_WITNESS_PUBKEY_HASH,\n\t)\n\n\t// Create fee estimation for a p2tr input and p2wkh output.\n\tfeeRate := chainfee.SatPerKWeight(12500)\n\testimator := input.TxWeightEstimator{}\n\testimator.AddTapscriptInput(\n\t\tlen([]byte(\"foobar\"))+len(leaf1.Script)+1, tapscript,\n\t)\n\testimator.AddP2WKHOutput()\n\testimatedWeight := int64(estimator.Weight())\n\trequiredFee := feeRate.FeeForWeight(estimatedWeight)\n\n\ttx := wire.NewMsgTx(2)\n\ttx.TxIn = []*wire.TxIn{{\n\t\tPreviousOutPoint: p2trOutpoint,\n\t}}\n\tvalue := int64(testAmount - requiredFee)\n\ttx.TxOut = []*wire.TxOut{{\n\t\tPkScript: p2wkhPkScript,\n\t\tValue:    value,\n\t}}\n\n\t// We can now assemble the witness stack.\n\tcontrolBlockBytes, err := tapscript.ControlBlock.ToBytes()\n\trequire.NoError(ht, err)\n\n\ttx.TxIn[0].Witness = wire.TxWitness{\n\t\t[]byte(\"foobar\"),\n\t\tleaf1.Script,\n\t\tcontrolBlockBytes,\n\t}\n\n\t// Serialize, weigh and publish the TX now, then make sure the\n\t// coins are sent and confirmed to the final sweep destination address.\n\tpublishTxAndConfirmSweep(\n\t\tht, alice, tx, estimatedWeight,\n\t\t&chainrpc.SpendRequest{\n\t\t\tOutpoint: &chainrpc.Outpoint{\n\t\t\t\tHash:  p2trOutpoint.Hash[:],\n\t\t\t\tIndex: p2trOutpoint.Index,\n\t\t\t},\n\t\t\tScript: p2trPkScript,\n\t\t},\n\t\tp2wkhAddr.String(),\n\t)\n}\n\n// testTaprootMuSig2CombinedLeafKeySpend tests that a MuSig2 combined key can be\n// used for an OP_CHECKSIG inside a tap script leaf spend.",
      "length": 2503,
      "tokens": 303,
      "embedding": []
    },
    {
      "slug": "func testTaprootMuSig2CombinedLeafKeySpend(ht *lntest.HarnessTest,",
      "content": "func testTaprootMuSig2CombinedLeafKeySpend(ht *lntest.HarnessTest,\n\talice *node.HarnessNode, version signrpc.MuSig2Version) {\n\n\t// We're using the combined MuSig2 key in a script leaf. So we need to\n\t// derive the combined key first, before we can build the script.\n\tkeyDesc1, keyDesc2, keyDesc3, allPubKeys := deriveSigningKeys(\n\t\tht, alice, version,\n\t)\n\treq := &signrpc.MuSig2CombineKeysRequest{\n\t\tAllSignerPubkeys: allPubKeys,\n\t\tVersion:          version,\n\t}\n\tcombineResp := alice.RPC.MuSig2CombineKeys(req)\n\tcombinedPubKey, err := schnorr.ParsePubKey(combineResp.CombinedKey)\n\trequire.NoError(ht, err)\n\n\t// We're going to commit to a script and spend the output using the\n\t// script. This is just an OP_CHECKSIG with the combined MuSig2 public\n\t// key.\n\tleaf := testScriptSchnorrSig(ht.T, combinedPubKey)\n\ttapscript := input.TapscriptPartialReveal(dummyInternalKey, leaf, nil)\n\ttaprootKey, err := tapscript.TaprootKey()\n\trequire.NoError(ht, err)\n\n\t// Send some coins to the generated tapscript address.\n\tp2trOutpoint, p2trPkScript := sendToTaprootOutput(ht, alice, taprootKey)\n\n\t// Spend the output again, this time back to a p2wkh address.\n\tp2wkhAddr, p2wkhPkScript := newAddrWithScript(\n\t\tht, alice, lnrpc.AddressType_WITNESS_PUBKEY_HASH,\n\t)\n\n\t// Create fee estimation for a p2tr input and p2wkh output.\n\tfeeRate := chainfee.SatPerKWeight(12500)\n\testimator := input.TxWeightEstimator{}\n\testimator.AddTapscriptInput(\n\t\tinput.TaprootSignatureWitnessSize, tapscript,\n\t)\n\testimator.AddP2WKHOutput()\n\testimatedWeight := int64(estimator.Weight())\n\trequiredFee := feeRate.FeeForWeight(estimatedWeight)\n\n\ttx := wire.NewMsgTx(2)\n\ttx.TxIn = []*wire.TxIn{{\n\t\tPreviousOutPoint: p2trOutpoint,\n\t}}\n\tvalue := int64(testAmount - requiredFee)\n\ttx.TxOut = []*wire.TxOut{{\n\t\tPkScript: p2wkhPkScript,\n\t\tValue:    value,\n\t}}\n\n\tvar buf bytes.Buffer\n\trequire.NoError(ht, tx.Serialize(&buf))\n\n\tutxoInfo := []*signrpc.TxOut{{\n\t\tPkScript: p2trPkScript,\n\t\tValue:    testAmount,\n\t}}\n\n\t// Do the actual signing now.\n\t_, _, sessResp1, sessResp2, sessResp3 := createMuSigSessions(\n\t\tht, alice, nil, keyDesc1, keyDesc2, keyDesc3, allPubKeys,\n\t\tversion,\n\t)\n\trequire.NoError(ht, err)\n\n\t// We now need to create the raw sighash of the transaction, as that\n\t// will be the message we're signing collaboratively.\n\tprevOutputFetcher := txscript.NewCannedPrevOutputFetcher(\n\t\tutxoInfo[0].PkScript, utxoInfo[0].Value,\n\t)\n\tsighashes := txscript.NewTxSigHashes(tx, prevOutputFetcher)\n\n\tsigHash, err := txscript.CalcTapscriptSignaturehash(\n\t\tsighashes, txscript.SigHashDefault, tx, 0, prevOutputFetcher,\n\t\tleaf,\n\t)\n\trequire.NoError(ht, err)\n\n\t// Now that we have the transaction prepared, we need to start with the\n\t// signing. We simulate all three parties here, so we need to do\n\t// everything three times. But because we're going to use session 1 to\n\t// combine everything, we don't need its response, as it will store its\n\t// own signature.\n\tsignReq := &signrpc.MuSig2SignRequest{\n\t\tSessionId:     sessResp1.SessionId,\n\t\tMessageDigest: sigHash,\n\t}\n\talice.RPC.MuSig2Sign(signReq)\n\n\tsignReq = &signrpc.MuSig2SignRequest{\n\t\tSessionId:     sessResp2.SessionId,\n\t\tMessageDigest: sigHash,\n\t\tCleanup:       true,\n\t}\n\tsignResp2 := alice.RPC.MuSig2Sign(signReq)\n\n\t// Before we have all partial signatures, we shouldn't get a final\n\t// signature back.\n\tcombineReq := &signrpc.MuSig2CombineSigRequest{\n\t\tSessionId: sessResp1.SessionId,\n\t\tOtherPartialSignatures: [][]byte{\n\t\t\tsignResp2.LocalPartialSignature,\n\t\t},\n\t}\n\tcombineSigResp := alice.RPC.MuSig2CombineSig(combineReq)\n\trequire.False(ht, combineSigResp.HaveAllSignatures)\n\trequire.Empty(ht, combineSigResp.FinalSignature)\n\n\tsignReq = &signrpc.MuSig2SignRequest{\n\t\tSessionId:     sessResp3.SessionId,\n\t\tMessageDigest: sigHash,\n\t}\n\tsignResp3 := alice.RPC.MuSig2Sign(signReq)\n\n\t// We manually clean up session 3, just to make sure that works as well.\n\tcleanReq := &signrpc.MuSig2CleanupRequest{\n\t\tSessionId: sessResp3.SessionId,\n\t}\n\talice.RPC.MuSig2Cleanup(cleanReq)\n\n\t// A second call to that cleaned up session should now fail with a\n\t// specific error.\n\tsignReq = &signrpc.MuSig2SignRequest{\n\t\tSessionId:     sessResp3.SessionId,\n\t\tMessageDigest: sigHash,\n\t}\n\terr = alice.RPC.MuSig2SignErr(signReq)\n\trequire.Contains(ht, err.Error(), \"not found\")\n\n\t// Luckily only one of the signers needs to combine the signature, so\n\t// let's do that now.\n\tcombineReq = &signrpc.MuSig2CombineSigRequest{\n\t\tSessionId: sessResp1.SessionId,\n\t\tOtherPartialSignatures: [][]byte{\n\t\t\tsignResp3.LocalPartialSignature,\n\t\t},\n\t}\n\tcombineResp1 := alice.RPC.MuSig2CombineSig(combineReq)\n\trequire.Equal(ht, true, combineResp1.HaveAllSignatures)\n\trequire.NotEmpty(ht, combineResp1.FinalSignature)\n\n\tsig, err := schnorr.ParseSignature(combineResp1.FinalSignature)\n\trequire.NoError(ht, err)\n\trequire.True(ht, sig.Verify(sigHash, combinedPubKey))\n\n\t// We can now assemble the witness stack.\n\tcontrolBlockBytes, err := tapscript.ControlBlock.ToBytes()\n\trequire.NoError(ht, err)\n\n\ttx.TxIn[0].Witness = wire.TxWitness{\n\t\tcombineResp1.FinalSignature,\n\t\tleaf.Script,\n\t\tcontrolBlockBytes,\n\t}\n\n\t// Serialize, weigh and publish the TX now, then make sure the\n\t// coins are sent and confirmed to the final sweep destination address.\n\tpublishTxAndConfirmSweep(\n\t\tht, alice, tx, estimatedWeight,\n\t\t&chainrpc.SpendRequest{\n\t\t\tOutpoint: &chainrpc.Outpoint{\n\t\t\t\tHash:  p2trOutpoint.Hash[:],\n\t\t\t\tIndex: p2trOutpoint.Index,\n\t\t\t},\n\t\t\tScript: p2trPkScript,\n\t\t},\n\t\tp2wkhAddr.String(),\n\t)\n}\n\n// testTaprootImportTapscriptScriptSpend tests importing p2tr script addresses\n// using the script path with the full tree known.",
      "length": 5341,
      "tokens": 570,
      "embedding": []
    },
    {
      "slug": "func testTaprootImportTapscriptFullTree(ht *lntest.HarnessTest,",
      "content": "func testTaprootImportTapscriptFullTree(ht *lntest.HarnessTest,\n\talice *node.HarnessNode) {\n\n\t// For the next step, we need a public key. Let's use a special family\n\t// for this.\n\t_, internalKey, derivationPath := deriveInternalKey(ht, alice)\n\n\t// Let's create a taproot script output now. This is a hash lock with a\n\t// simple preimage of \"foobar\".\n\tleaf1 := testScriptHashLock(ht.T, []byte(\"foobar\"))\n\n\t// Let's add a second script output as well to test the partial reveal.\n\tleaf2 := testScriptSchnorrSig(ht.T, internalKey)\n\n\ttapscript := input.TapscriptFullTree(internalKey, leaf1, leaf2)\n\ttree := txscript.AssembleTaprootScriptTree(leaf1, leaf2)\n\trootHash := tree.RootNode.TapHash()\n\ttaprootKey, err := tapscript.TaprootKey()\n\trequire.NoError(ht, err)\n\n\t// Import the scripts and make sure we get the same address back as we\n\t// calculated ourselves.\n\treq := &walletrpc.ImportTapscriptRequest{\n\t\tInternalPublicKey: schnorr.SerializePubKey(internalKey),\n\t\tScript: &walletrpc.ImportTapscriptRequest_FullTree{\n\t\t\tFullTree: &walletrpc.TapscriptFullTree{\n\t\t\t\tAllLeaves: []*walletrpc.TapLeaf{{\n\t\t\t\t\tLeafVersion: uint32(\n\t\t\t\t\t\tleaf1.LeafVersion,\n\t\t\t\t\t),\n\t\t\t\t\tScript: leaf1.Script,\n\t\t\t\t}, {\n\t\t\t\t\tLeafVersion: uint32(\n\t\t\t\t\t\tleaf2.LeafVersion,\n\t\t\t\t\t),\n\t\t\t\t\tScript: leaf2.Script,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\timportResp := alice.RPC.ImportTapscript(req)\n\n\tcalculatedAddr, err := btcutil.NewAddressTaproot(\n\t\tschnorr.SerializePubKey(taprootKey), harnessNetParams,\n\t)\n\trequire.NoError(ht, err)\n\trequire.Equal(ht, calculatedAddr.String(), importResp.P2TrAddress)\n\n\t// Send some coins to the generated tapscript address.\n\tp2trOutpoint, p2trPkScript := sendToTaprootOutput(ht, alice, taprootKey)\n\tp2trOutputRPC := &lnrpc.OutPoint{\n\t\tTxidBytes:   p2trOutpoint.Hash[:],\n\t\tOutputIndex: p2trOutpoint.Index,\n\t}\n\tht.AssertUTXOInWallet(alice, p2trOutputRPC, \"imported\")\n\tht.AssertWalletAccountBalance(alice, \"imported\", testAmount, 0)\n\n\t// Funding a PSBT from an imported script is not yet possible. So we\n\t// basically need to add all information manually for the wallet to be\n\t// able to sign for it.\n\tutxo := &wire.TxOut{\n\t\tValue:    testAmount,\n\t\tPkScript: p2trPkScript,\n\t}\n\tclearWalletImportedTapscriptBalance(\n\t\tht, alice, utxo, p2trOutpoint, internalKey, derivationPath,\n\t\trootHash[:],\n\t)\n}\n\n// testTaprootImportTapscriptPartialReveal tests importing p2tr script addresses\n// for which we only know part of the tree.",
      "length": 2265,
      "tokens": 247,
      "embedding": []
    },
    {
      "slug": "func testTaprootImportTapscriptPartialReveal(ht *lntest.HarnessTest,",
      "content": "func testTaprootImportTapscriptPartialReveal(ht *lntest.HarnessTest,\n\talice *node.HarnessNode) {\n\n\t// For the next step, we need a public key. Let's use a special family\n\t// for this.\n\t_, internalKey, derivationPath := deriveInternalKey(ht, alice)\n\n\t// Let's create a taproot script output now. This is a hash lock with a\n\t// simple preimage of \"foobar\".\n\tleaf1 := testScriptHashLock(ht.T, []byte(\"foobar\"))\n\n\t// Let's add a second script output as well to test the partial reveal.\n\tleaf2 := testScriptSchnorrSig(ht.T, internalKey)\n\tleaf2Hash := leaf2.TapHash()\n\n\ttapscript := input.TapscriptPartialReveal(\n\t\tinternalKey, leaf1, leaf2Hash[:],\n\t)\n\trootHash := tapscript.ControlBlock.RootHash(leaf1.Script)\n\ttaprootKey, err := tapscript.TaprootKey()\n\trequire.NoError(ht, err)\n\n\t// Import the scripts and make sure we get the same address back as we\n\t// calculated ourselves.\n\treq := &walletrpc.ImportTapscriptRequest{\n\t\tInternalPublicKey: schnorr.SerializePubKey(internalKey),\n\t\tScript: &walletrpc.ImportTapscriptRequest_PartialReveal{\n\t\t\tPartialReveal: &walletrpc.TapscriptPartialReveal{\n\t\t\t\tRevealedLeaf: &walletrpc.TapLeaf{\n\t\t\t\t\tLeafVersion: uint32(leaf1.LeafVersion),\n\t\t\t\t\tScript:      leaf1.Script,\n\t\t\t\t},\n\t\t\t\tFullInclusionProof: leaf2Hash[:],\n\t\t\t},\n\t\t},\n\t}\n\timportResp := alice.RPC.ImportTapscript(req)\n\n\tcalculatedAddr, err := btcutil.NewAddressTaproot(\n\t\tschnorr.SerializePubKey(taprootKey), harnessNetParams,\n\t)\n\trequire.NoError(ht, err)\n\trequire.Equal(ht, calculatedAddr.String(), importResp.P2TrAddress)\n\n\t// Send some coins to the generated tapscript address.\n\tp2trOutpoint, p2trPkScript := sendToTaprootOutput(ht, alice, taprootKey)\n\n\tp2trOutputRPC := &lnrpc.OutPoint{\n\t\tTxidBytes:   p2trOutpoint.Hash[:],\n\t\tOutputIndex: p2trOutpoint.Index,\n\t}\n\tht.AssertUTXOInWallet(alice, p2trOutputRPC, \"imported\")\n\tht.AssertWalletAccountBalance(alice, \"imported\", testAmount, 0)\n\n\t// Funding a PSBT from an imported script is not yet possible. So we\n\t// basically need to add all information manually for the wallet to be\n\t// able to sign for it.\n\tutxo := &wire.TxOut{\n\t\tValue:    testAmount,\n\t\tPkScript: p2trPkScript,\n\t}\n\tclearWalletImportedTapscriptBalance(\n\t\tht, alice, utxo, p2trOutpoint, internalKey, derivationPath,\n\t\trootHash,\n\t)\n}\n\n// testTaprootImportTapscriptRootHashOnly tests importing p2tr script addresses\n// for which we only know the root hash.",
      "length": 2222,
      "tokens": 239,
      "embedding": []
    },
    {
      "slug": "func testTaprootImportTapscriptRootHashOnly(ht *lntest.HarnessTest,",
      "content": "func testTaprootImportTapscriptRootHashOnly(ht *lntest.HarnessTest,\n\talice *node.HarnessNode) {\n\n\t// For the next step, we need a public key. Let's use a special family\n\t// for this.\n\t_, internalKey, derivationPath := deriveInternalKey(ht, alice)\n\n\t// Let's create a taproot script output now. This is a hash lock with a\n\t// simple preimage of \"foobar\".\n\tleaf1 := testScriptHashLock(ht.T, []byte(\"foobar\"))\n\trootHash := leaf1.TapHash()\n\n\ttapscript := input.TapscriptRootHashOnly(internalKey, rootHash[:])\n\ttaprootKey, err := tapscript.TaprootKey()\n\trequire.NoError(ht, err)\n\n\t// Import the scripts and make sure we get the same address back as we\n\t// calculated ourselves.\n\treq := &walletrpc.ImportTapscriptRequest{\n\t\tInternalPublicKey: schnorr.SerializePubKey(internalKey),\n\t\tScript: &walletrpc.ImportTapscriptRequest_RootHashOnly{\n\t\t\tRootHashOnly: rootHash[:],\n\t\t},\n\t}\n\timportResp := alice.RPC.ImportTapscript(req)\n\n\tcalculatedAddr, err := btcutil.NewAddressTaproot(\n\t\tschnorr.SerializePubKey(taprootKey), harnessNetParams,\n\t)\n\trequire.NoError(ht, err)\n\trequire.Equal(ht, calculatedAddr.String(), importResp.P2TrAddress)\n\n\t// Send some coins to the generated tapscript address.\n\tp2trOutpoint, p2trPkScript := sendToTaprootOutput(ht, alice, taprootKey)\n\n\tp2trOutputRPC := &lnrpc.OutPoint{\n\t\tTxidBytes:   p2trOutpoint.Hash[:],\n\t\tOutputIndex: p2trOutpoint.Index,\n\t}\n\tht.AssertUTXOInWallet(alice, p2trOutputRPC, \"imported\")\n\tht.AssertWalletAccountBalance(alice, \"imported\", testAmount, 0)\n\n\t// Funding a PSBT from an imported script is not yet possible. So we\n\t// basically need to add all information manually for the wallet to be\n\t// able to sign for it.\n\tutxo := &wire.TxOut{\n\t\tValue:    testAmount,\n\t\tPkScript: p2trPkScript,\n\t}\n\tclearWalletImportedTapscriptBalance(\n\t\tht, alice, utxo, p2trOutpoint, internalKey, derivationPath,\n\t\trootHash[:],\n\t)\n}\n\n// testTaprootImportTapscriptFullKey tests importing p2tr script addresses for\n// which we only know the full Taproot key.",
      "length": 1850,
      "tokens": 206,
      "embedding": []
    },
    {
      "slug": "func testTaprootImportTapscriptFullKey(ht *lntest.HarnessTest,",
      "content": "func testTaprootImportTapscriptFullKey(ht *lntest.HarnessTest,\n\talice *node.HarnessNode) {\n\n\t// For the next step, we need a public key. Let's use a special family\n\t// for this.\n\t_, internalKey, derivationPath := deriveInternalKey(ht, alice)\n\n\t// Let's create a taproot script output now. This is a hash lock with a\n\t// simple preimage of \"foobar\".\n\tleaf1 := testScriptHashLock(ht.T, []byte(\"foobar\"))\n\n\ttapscript := input.TapscriptFullTree(internalKey, leaf1)\n\trootHash := leaf1.TapHash()\n\ttaprootKey, err := tapscript.TaprootKey()\n\trequire.NoError(ht, err)\n\n\t// Import the scripts and make sure we get the same address back as we\n\t// calculated ourselves.\n\treq := &walletrpc.ImportTapscriptRequest{\n\t\tInternalPublicKey: schnorr.SerializePubKey(taprootKey),\n\t\tScript: &walletrpc.ImportTapscriptRequest_FullKeyOnly{\n\t\t\tFullKeyOnly: true,\n\t\t},\n\t}\n\timportResp := alice.RPC.ImportTapscript(req)\n\n\tcalculatedAddr, err := btcutil.NewAddressTaproot(\n\t\tschnorr.SerializePubKey(taprootKey), harnessNetParams,\n\t)\n\trequire.NoError(ht, err)\n\trequire.Equal(ht, calculatedAddr.String(), importResp.P2TrAddress)\n\n\t// Send some coins to the generated tapscript address.\n\tp2trOutpoint, p2trPkScript := sendToTaprootOutput(ht, alice, taprootKey)\n\n\tp2trOutputRPC := &lnrpc.OutPoint{\n\t\tTxidBytes:   p2trOutpoint.Hash[:],\n\t\tOutputIndex: p2trOutpoint.Index,\n\t}\n\tht.AssertUTXOInWallet(alice, p2trOutputRPC, \"imported\")\n\tht.AssertWalletAccountBalance(alice, \"imported\", testAmount, 0)\n\n\t// Funding a PSBT from an imported script is not yet possible. So we\n\t// basically need to add all information manually for the wallet to be\n\t// able to sign for it.\n\tutxo := &wire.TxOut{\n\t\tValue:    testAmount,\n\t\tPkScript: p2trPkScript,\n\t}\n\tclearWalletImportedTapscriptBalance(\n\t\tht, alice, utxo, p2trOutpoint, internalKey, derivationPath,\n\t\trootHash[:],\n\t)\n}\n\n// clearWalletImportedTapscriptBalance manually assembles and then attempts to\n// sign a TX to sweep funds from an imported tapscript address.",
      "length": 1850,
      "tokens": 209,
      "embedding": []
    },
    {
      "slug": "func clearWalletImportedTapscriptBalance(ht *lntest.HarnessTest,",
      "content": "func clearWalletImportedTapscriptBalance(ht *lntest.HarnessTest,\n\thn *node.HarnessNode, utxo *wire.TxOut, outPoint wire.OutPoint,\n\tinternalKey *btcec.PublicKey, derivationPath []uint32,\n\trootHash []byte) {\n\n\t_, sweepPkScript := newAddrWithScript(\n\t\tht, hn, lnrpc.AddressType_WITNESS_PUBKEY_HASH,\n\t)\n\n\toutput := &wire.TxOut{\n\t\tPkScript: sweepPkScript,\n\t\tValue:    utxo.Value - 1000,\n\t}\n\tpacket, err := psbt.New(\n\t\t[]*wire.OutPoint{&outPoint}, []*wire.TxOut{output}, 2, 0,\n\t\t[]uint32{0},\n\t)\n\trequire.NoError(ht, err)\n\n\t// We have everything we need to know to sign the PSBT.\n\tin := &packet.Inputs[0]\n\tin.Bip32Derivation = []*psbt.Bip32Derivation{{\n\t\tPubKey:    internalKey.SerializeCompressed(),\n\t\tBip32Path: derivationPath,\n\t}}\n\tin.TaprootBip32Derivation = []*psbt.TaprootBip32Derivation{{\n\t\tXOnlyPubKey: schnorr.SerializePubKey(internalKey),\n\t\tBip32Path:   derivationPath,\n\t}}\n\tin.SighashType = txscript.SigHashDefault\n\tin.TaprootMerkleRoot = rootHash\n\tin.WitnessUtxo = utxo\n\n\tvar buf bytes.Buffer\n\trequire.NoError(ht, packet.Serialize(&buf))\n\n\t// Sign the manually funded PSBT now.\n\tsignResp := hn.RPC.SignPsbt(&walletrpc.SignPsbtRequest{\n\t\tFundedPsbt: buf.Bytes(),\n\t})\n\n\tsignedPacket, err := psbt.NewFromRawBytes(\n\t\tbytes.NewReader(signResp.SignedPsbt), false,\n\t)\n\trequire.NoError(ht, err)\n\n\t// We should be able to finalize the PSBT and extract the sweep TX now.\n\terr = psbt.MaybeFinalizeAll(signedPacket)\n\trequire.NoError(ht, err)\n\n\tsweepTx, err := psbt.Extract(signedPacket)\n\trequire.NoError(ht, err)\n\n\tbuf.Reset()\n\terr = sweepTx.Serialize(&buf)\n\trequire.NoError(ht, err)\n\n\t// Publish the sweep transaction and then mine it as well.\n\thn.RPC.PublishTransaction(&walletrpc.Transaction{\n\t\tTxHex: buf.Bytes(),\n\t})\n\n\t// Mine one block which should contain the sweep transaction.\n\tblock := ht.MineBlocksAndAssertNumTxes(1, 1)[0]\n\tsweepTxHash := sweepTx.TxHash()\n\tht.Miner.AssertTxInBlock(block, &sweepTxHash)\n}\n\n// testScriptHashLock returns a simple bitcoin script that locks the funds to\n// a hash lock of the given preimage.",
      "length": 1893,
      "tokens": 197,
      "embedding": []
    },
    {
      "slug": "func testScriptHashLock(t *testing.T, preimage []byte) txscript.TapLeaf {",
      "content": "func testScriptHashLock(t *testing.T, preimage []byte) txscript.TapLeaf {\n\tbuilder := txscript.NewScriptBuilder()\n\tbuilder.AddOp(txscript.OP_DUP)\n\tbuilder.AddOp(txscript.OP_HASH160)\n\tbuilder.AddData(btcutil.Hash160(preimage))\n\tbuilder.AddOp(txscript.OP_EQUALVERIFY)\n\tscript1, err := builder.Script()\n\trequire.NoError(t, err)\n\treturn txscript.NewBaseTapLeaf(script1)\n}\n\n// testScriptSchnorrSig returns a simple bitcoin script that locks the funds to\n// a Schnorr signature of the given public key.",
      "length": 411,
      "tokens": 37,
      "embedding": []
    },
    {
      "slug": "func testScriptSchnorrSig(t *testing.T,",
      "content": "func testScriptSchnorrSig(t *testing.T,\n\tpubKey *btcec.PublicKey) txscript.TapLeaf {\n\n\tbuilder := txscript.NewScriptBuilder()\n\tbuilder.AddData(schnorr.SerializePubKey(pubKey))\n\tbuilder.AddOp(txscript.OP_CHECKSIG)\n\tscript2, err := builder.Script()\n\trequire.NoError(t, err)\n\treturn txscript.NewBaseTapLeaf(script2)\n}\n\n// newAddrWithScript returns a new address and its pkScript.",
      "length": 326,
      "tokens": 27,
      "embedding": []
    },
    {
      "slug": "func newAddrWithScript(ht *lntest.HarnessTest, node *node.HarnessNode,",
      "content": "func newAddrWithScript(ht *lntest.HarnessTest, node *node.HarnessNode,\n\taddrType lnrpc.AddressType) (btcutil.Address, []byte) {\n\n\tp2wkhResp := node.RPC.NewAddress(&lnrpc.NewAddressRequest{\n\t\tType: addrType,\n\t})\n\tp2wkhAddr, err := btcutil.DecodeAddress(\n\t\tp2wkhResp.Address, harnessNetParams,\n\t)\n\trequire.NoError(ht, err)\n\n\tp2wkhPkScript, err := txscript.PayToAddrScript(p2wkhAddr)\n\trequire.NoError(ht, err)\n\n\treturn p2wkhAddr, p2wkhPkScript\n}\n\n// sendToTaprootOutput sends coins to a p2tr output of the given taproot key and\n// mines a block to confirm the coins.",
      "length": 475,
      "tokens": 52,
      "embedding": []
    },
    {
      "slug": "func sendToTaprootOutput(ht *lntest.HarnessTest, hn *node.HarnessNode,",
      "content": "func sendToTaprootOutput(ht *lntest.HarnessTest, hn *node.HarnessNode,\n\ttaprootKey *btcec.PublicKey) (wire.OutPoint, []byte) {\n\n\ttapScriptAddr, err := btcutil.NewAddressTaproot(\n\t\tschnorr.SerializePubKey(taprootKey), harnessNetParams,\n\t)\n\trequire.NoError(ht, err)\n\tp2trPkScript, err := txscript.PayToAddrScript(tapScriptAddr)\n\trequire.NoError(ht, err)\n\n\t// Send some coins to the generated tapscript address.\n\treq := &lnrpc.SendCoinsRequest{\n\t\tAddr:   tapScriptAddr.String(),\n\t\tAmount: testAmount,\n\t}\n\thn.RPC.SendCoins(req)\n\n\t// Wait until the TX is found in the mempool.\n\ttxid := ht.Miner.AssertNumTxsInMempool(1)[0]\n\tp2trOutputIndex := ht.GetOutputIndex(txid, tapScriptAddr.String())\n\tp2trOutpoint := wire.OutPoint{\n\t\tHash:  *txid,\n\t\tIndex: uint32(p2trOutputIndex),\n\t}\n\n\t// Make sure the transaction is recognized by our wallet and has the\n\t// correct output type.\n\tvar outputDetail *lnrpc.OutputDetail\n\twalletTxns := hn.RPC.GetTransactions(&lnrpc.GetTransactionsRequest{\n\t\tStartHeight: 0,\n\t\tEndHeight:   -1,\n\t})\n\trequire.NotEmpty(ht, walletTxns.Transactions)\n\tfor _, tx := range walletTxns.Transactions {\n\t\tif tx.TxHash != txid.String() {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor outputIdx, out := range tx.OutputDetails {\n\t\t\tif out.Address != tapScriptAddr.String() {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\toutputDetail = tx.OutputDetails[outputIdx]\n\t\t\tbreak\n\t\t}\n\t}\n\trequire.NotNil(ht, outputDetail, \"transaction not found in wallet\")\n\trequire.Equal(\n\t\tht, lnrpc.OutputScriptType_SCRIPT_TYPE_WITNESS_V1_TAPROOT,\n\t\toutputDetail.OutputType,\n\t)\n\n\t// Clear the mempool.\n\tht.MineBlocksAndAssertNumTxes(1, 1)\n\n\treturn p2trOutpoint, p2trPkScript\n}\n\n// publishTxAndConfirmSweep is a helper function that publishes a transaction\n// after checking its weight against an estimate. After asserting the given\n// spend request, the given sweep address' balance is verified to be seen as\n// funds belonging to the wallet.",
      "length": 1743,
      "tokens": 191,
      "embedding": []
    },
    {
      "slug": "func publishTxAndConfirmSweep(ht *lntest.HarnessTest, node *node.HarnessNode,",
      "content": "func publishTxAndConfirmSweep(ht *lntest.HarnessTest, node *node.HarnessNode,\n\ttx *wire.MsgTx, estimatedWeight int64,\n\tspendRequest *chainrpc.SpendRequest, sweepAddr string) {\n\n\tht.Helper()\n\n\t// Before we publish the tx that spends the p2tr transaction, we want to\n\t// register a spend listener that we expect to fire after mining the\n\t// block.\n\t_, currentHeight := ht.Miner.GetBestBlock()\n\n\t// For a Taproot output we cannot leave the outpoint empty. Let's make\n\t// sure the API returns the correct error here.\n\treq := &chainrpc.SpendRequest{\n\t\tScript:     spendRequest.Script,\n\t\tHeightHint: uint32(currentHeight),\n\t}\n\tspendClient := node.RPC.RegisterSpendNtfn(req)\n\n\t// The error is only thrown when trying to read a message.\n\t_, err := spendClient.Recv()\n\trequire.Contains(\n\t\tht, err.Error(),\n\t\t\"cannot register witness v1 spend request without outpoint\",\n\t)\n\n\t// Now try again, this time with the outpoint set.\n\treq = &chainrpc.SpendRequest{\n\t\tOutpoint:   spendRequest.Outpoint,\n\t\tScript:     spendRequest.Script,\n\t\tHeightHint: uint32(currentHeight),\n\t}\n\tspendClient = node.RPC.RegisterSpendNtfn(req)\n\n\tvar buf bytes.Buffer\n\trequire.NoError(ht, tx.Serialize(&buf))\n\n\t// Since Schnorr signatures are fixed size, we must be able to estimate\n\t// the size of this transaction exactly.\n\ttxWeight := blockchain.GetTransactionWeight(btcutil.NewTx(tx))\n\trequire.Equal(ht, estimatedWeight, txWeight)\n\n\ttxReq := &walletrpc.Transaction{\n\t\tTxHex: buf.Bytes(),\n\t}\n\tnode.RPC.PublishTransaction(txReq)\n\n\t// Make sure the coins sent to the address are confirmed correctly,\n\t// including the confirmation notification.\n\tconfirmAddress(ht, node, sweepAddr)\n\n\t// We now expect our spend event to go through.\n\tspendMsg, err := spendClient.Recv()\n\trequire.NoError(ht, err)\n\tspend := spendMsg.GetSpend()\n\trequire.NotNil(ht, spend)\n\trequire.Equal(ht, spend.SpendingHeight, uint32(currentHeight+1))\n}\n\n// confirmAddress makes sure that a transaction in the mempool spends funds to\n// the given address. It also checks that a confirmation notification for the\n// address is triggered when the transaction is mined.",
      "length": 1956,
      "tokens": 245,
      "embedding": []
    },
    {
      "slug": "func confirmAddress(ht *lntest.HarnessTest, hn *node.HarnessNode,",
      "content": "func confirmAddress(ht *lntest.HarnessTest, hn *node.HarnessNode,\n\taddrString string) {\n\n\t// Wait until the tx that sends to the address is found.\n\ttxid := ht.Miner.AssertNumTxsInMempool(1)[0]\n\n\t// Wait until bob has seen the tx and considers it as owned.\n\taddrOutputIndex := ht.GetOutputIndex(txid, addrString)\n\top := &lnrpc.OutPoint{\n\t\tTxidBytes:   txid[:],\n\t\tOutputIndex: uint32(addrOutputIndex),\n\t}\n\tht.AssertUTXOInWallet(hn, op, \"\")\n\n\t// Before we confirm the transaction, let's register a confirmation\n\t// listener for it, which we expect to fire after mining a block.\n\tparsedAddr, err := btcutil.DecodeAddress(addrString, harnessNetParams)\n\trequire.NoError(ht, err)\n\taddrPkScript, err := txscript.PayToAddrScript(parsedAddr)\n\trequire.NoError(ht, err)\n\n\t_, currentHeight := ht.Miner.GetBestBlock()\n\treq := &chainrpc.ConfRequest{\n\t\tScript:       addrPkScript,\n\t\tTxid:         txid[:],\n\t\tHeightHint:   uint32(currentHeight),\n\t\tNumConfs:     1,\n\t\tIncludeBlock: true,\n\t}\n\tconfClient := hn.RPC.RegisterConfirmationsNtfn(req)\n\n\t// Mine another block to clean up the mempool.\n\tht.MineBlocksAndAssertNumTxes(1, 1)\n\n\t// We now expect our confirmation to go through, and also that the\n\t// block was specified.\n\tconfMsg, err := confClient.Recv()\n\trequire.NoError(ht, err)\n\tconf := confMsg.GetConf()\n\trequire.NotNil(ht, conf)\n\trequire.Equal(ht, conf.BlockHeight, uint32(currentHeight+1))\n\trequire.NotNil(ht, conf.RawBlock)\n\n\t// We should also be able to decode the raw block.\n\tvar blk wire.MsgBlock\n\trequire.NoError(ht, blk.Deserialize(bytes.NewReader(conf.RawBlock)))\n}\n\n// deriveSigningKeys derives three signing keys and returns their descriptors,\n// as well as the public keys in the Schnorr serialized format.",
      "length": 1594,
      "tokens": 186,
      "embedding": []
    },
    {
      "slug": "func deriveSigningKeys(ht *lntest.HarnessTest, node *node.HarnessNode,",
      "content": "func deriveSigningKeys(ht *lntest.HarnessTest, node *node.HarnessNode,\n\tversion signrpc.MuSig2Version) (*signrpc.KeyDescriptor,\n\t*signrpc.KeyDescriptor, *signrpc.KeyDescriptor, [][]byte) {\n\n\t// For muSig2 we need multiple keys. We derive three of them from the\n\t// same wallet, just so we know we can also sign for them again.\n\treq := &walletrpc.KeyReq{KeyFamily: testTaprootKeyFamily}\n\tkeyDesc1 := node.RPC.DeriveNextKey(req)\n\tpubKey1, err := btcec.ParsePubKey(keyDesc1.RawKeyBytes)\n\trequire.NoError(ht, err)\n\n\tkeyDesc2 := node.RPC.DeriveNextKey(req)\n\tpubKey2, err := btcec.ParsePubKey(keyDesc2.RawKeyBytes)\n\trequire.NoError(ht, err)\n\n\tkeyDesc3 := node.RPC.DeriveNextKey(req)\n\tpubKey3, err := btcec.ParsePubKey(keyDesc3.RawKeyBytes)\n\trequire.NoError(ht, err)\n\n\t// Now that we have all three keys we can create three sessions, one\n\t// for each of the signers. This would of course normally not happen on\n\t// the same node.\n\tvar allPubKeys [][]byte\n\tswitch version {\n\tcase signrpc.MuSig2Version_MUSIG2_VERSION_V040:\n\t\tallPubKeys = [][]byte{\n\t\t\tschnorr.SerializePubKey(pubKey1),\n\t\t\tschnorr.SerializePubKey(pubKey2),\n\t\t\tschnorr.SerializePubKey(pubKey3),\n\t\t}\n\n\tcase signrpc.MuSig2Version_MUSIG2_VERSION_V100RC2:\n\t\tallPubKeys = [][]byte{\n\t\t\tpubKey1.SerializeCompressed(),\n\t\t\tpubKey2.SerializeCompressed(),\n\t\t\tpubKey3.SerializeCompressed(),\n\t\t}\n\t}\n\n\treturn keyDesc1, keyDesc2, keyDesc3, allPubKeys\n}\n\n// createMuSigSessions creates a MuSig2 session with three keys that are\n// combined into a single key. The same node is used for the three signing\n// participants but a separate key is generated for each session. So the result\n// should be the same as if it were three different nodes.",
      "length": 1566,
      "tokens": 181,
      "embedding": []
    },
    {
      "slug": "func createMuSigSessions(ht *lntest.HarnessTest, node *node.HarnessNode,",
      "content": "func createMuSigSessions(ht *lntest.HarnessTest, node *node.HarnessNode,\n\ttaprootTweak *signrpc.TaprootTweakDesc,\n\tkeyDesc1, keyDesc2, keyDesc3 *signrpc.KeyDescriptor,\n\tallPubKeys [][]byte, version signrpc.MuSig2Version) (*btcec.PublicKey,\n\t*btcec.PublicKey, *signrpc.MuSig2SessionResponse,\n\t*signrpc.MuSig2SessionResponse, *signrpc.MuSig2SessionResponse) {\n\n\t// Make sure that when not specifying a version we get an error, since\n\t// it is mandatory.\n\terr := node.RPC.MuSig2CreateSessionErr(&signrpc.MuSig2SessionRequest{})\n\trequire.ErrorContains(ht, err, \"unknown MuSig2 version\")\n\n\t// Create the actual session with the version specified.\n\tsessResp1 := node.RPC.MuSig2CreateSession(&signrpc.MuSig2SessionRequest{\n\t\tKeyLoc:           keyDesc1.KeyLoc,\n\t\tAllSignerPubkeys: allPubKeys,\n\t\tTaprootTweak:     taprootTweak,\n\t\tVersion:          version,\n\t})\n\trequire.Equal(ht, version, sessResp1.Version)\n\n\t// Make sure the version is returned correctly.\n\trequire.Equal(ht, version, sessResp1.Version)\n\n\t// Now that we have the three keys in a combined form, we want to make\n\t// sure the tweaking for the taproot key worked correctly. We first need\n\t// to parse the combined key without any tweaks applied to it. That will\n\t// be our internal key. Once we know that, we can tweak it with the\n\t// tapHash of the script root hash. We should arrive at the same result\n\t// as the API.\n\tcombinedKey, err := schnorr.ParsePubKey(sessResp1.CombinedKey)\n\trequire.NoError(ht, err)\n\n\t// When combining the key without creating a session, we expect the same\n\t// combined key to be created.\n\texpectedCombinedKey := combinedKey\n\n\t// Without a tweak, the internal key is equal to the combined key.\n\tinternalKey := combinedKey\n\n\t// If there is a tweak, then there is the internal, pre-tweaked combined\n\t// key and the taproot key which is fully tweaked.\n\tif taprootTweak != nil {\n\t\tinternalKey, err = schnorr.ParsePubKey(\n\t\t\tsessResp1.TaprootInternalKey,\n\t\t)\n\t\trequire.NoError(ht, err)\n\n\t\t// We now know the taproot key. The session with the tweak\n\t\t// applied should produce the same key!\n\t\texpectedCombinedKey = txscript.ComputeTaprootOutputKey(\n\t\t\tinternalKey, taprootTweak.ScriptRoot,\n\t\t)\n\t\trequire.Equal(\n\t\t\tht, schnorr.SerializePubKey(expectedCombinedKey),\n\t\t\tschnorr.SerializePubKey(combinedKey),\n\t\t)\n\t}\n\n\t// Same with the combine keys RPC, no version specified should give us\n\t// an error.\n\terr = node.RPC.MuSig2CombineKeysErr(&signrpc.MuSig2CombineKeysRequest{})\n\trequire.ErrorContains(ht, err, \"unknown MuSig2 version\")\n\n\t// We should also get the same keys when just calling the\n\t// MuSig2CombineKeys RPC.\n\tcombineReq := &signrpc.MuSig2CombineKeysRequest{\n\t\tAllSignerPubkeys: allPubKeys,\n\t\tTaprootTweak:     taprootTweak,\n\t\tVersion:          version,\n\t}\n\tcombineResp := node.RPC.MuSig2CombineKeys(combineReq)\n\trequire.Equal(\n\t\tht, schnorr.SerializePubKey(expectedCombinedKey),\n\t\tcombineResp.CombinedKey,\n\t)\n\trequire.Equal(\n\t\tht, schnorr.SerializePubKey(internalKey),\n\t\tcombineResp.TaprootInternalKey,\n\t)\n\trequire.Equal(ht, version, combineResp.Version)\n\n\t// Everything is good so far, let's continue with creating the signing\n\t// session for the other two participants.\n\treq := &signrpc.MuSig2SessionRequest{\n\t\tKeyLoc:           keyDesc2.KeyLoc,\n\t\tAllSignerPubkeys: allPubKeys,\n\t\tOtherSignerPublicNonces: [][]byte{\n\t\t\tsessResp1.LocalPublicNonces,\n\t\t},\n\t\tTaprootTweak: taprootTweak,\n\t\tVersion:      version,\n\t}\n\tsessResp2 := node.RPC.MuSig2CreateSession(req)\n\trequire.Equal(ht, sessResp1.CombinedKey, sessResp2.CombinedKey)\n\trequire.Equal(ht, version, sessResp2.Version)\n\n\treq = &signrpc.MuSig2SessionRequest{\n\t\tKeyLoc:           keyDesc3.KeyLoc,\n\t\tAllSignerPubkeys: allPubKeys,\n\t\tOtherSignerPublicNonces: [][]byte{\n\t\t\tsessResp1.LocalPublicNonces,\n\t\t\tsessResp2.LocalPublicNonces,\n\t\t},\n\t\tTaprootTweak: taprootTweak,\n\t\tVersion:      version,\n\t}\n\tsessResp3 := node.RPC.MuSig2CreateSession(req)\n\trequire.Equal(ht, sessResp2.CombinedKey, sessResp3.CombinedKey)\n\trequire.Equal(ht, version, sessResp3.Version)\n\trequire.Equal(ht, true, sessResp3.HaveAllNonces)\n\n\t// We need to distribute the rest of the nonces.\n\tnonceReq := &signrpc.MuSig2RegisterNoncesRequest{\n\t\tSessionId: sessResp1.SessionId,\n\t\tOtherSignerPublicNonces: [][]byte{\n\t\t\tsessResp2.LocalPublicNonces,\n\t\t\tsessResp3.LocalPublicNonces,\n\t\t},\n\t}\n\tnonceResp1 := node.RPC.MuSig2RegisterNonces(nonceReq)\n\trequire.True(ht, nonceResp1.HaveAllNonces)\n\n\tnonceReq = &signrpc.MuSig2RegisterNoncesRequest{\n\t\tSessionId: sessResp2.SessionId,\n\t\tOtherSignerPublicNonces: [][]byte{\n\t\t\tsessResp3.LocalPublicNonces,\n\t\t},\n\t}\n\tnonceResp2 := node.RPC.MuSig2RegisterNonces(nonceReq)\n\trequire.True(ht, nonceResp2.HaveAllNonces)\n\n\treturn internalKey, combinedKey, sessResp1, sessResp2, sessResp3\n}\n\n// testTaprootCoopClose asserts that if both peers signal ShutdownAnySegwit,\n// then a taproot closing addr is used. Otherwise, we shouldn't expect one to\n// be used.",
      "length": 4673,
      "tokens": 476,
      "embedding": []
    },
    {
      "slug": "func testTaprootCoopClose(ht *lntest.HarnessTest) {",
      "content": "func testTaprootCoopClose(ht *lntest.HarnessTest) {\n\t// We'll start by making two new nodes, and funding a channel between\n\t// them.\n\tcarol := ht.NewNode(\"Carol\", nil)\n\tht.FundCoins(btcutil.SatoshiPerBitcoin, carol)\n\n\tdave := ht.NewNode(\"Dave\", nil)\n\tht.EnsureConnected(carol, dave)\n\n\tchanAmt := funding.MaxBtcFundingAmount\n\tpushAmt := btcutil.Amount(100000)\n\tsatPerVbyte := btcutil.Amount(1)\n\n\t// We'll now open a channel between Carol and Dave.\n\tchanPoint := ht.OpenChannel(\n\t\tcarol, dave, lntest.OpenChannelParams{\n\t\t\tAmt:         chanAmt,\n\t\t\tPushAmt:     pushAmt,\n\t\t\tSatPerVByte: satPerVbyte,\n\t\t},\n\t)\n\n\t// We'll now close out the channel and obtain the closing TXID.\n\tclosingTxid := ht.CloseChannel(carol, chanPoint)\n\n\t// assertTaprootDeliveryUsed returns true if a Taproot addr was used in\n\t// the co-op close transaction.\n\tassertTaprootDeliveryUsed := func(closingTxid *chainhash.Hash) bool {\n\t\ttx := ht.Miner.GetRawTransaction(closingTxid)\n\t\tfor _, txOut := range tx.MsgTx().TxOut {\n\t\t\tif !txscript.IsPayToTaproot(txOut.PkScript) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\n\t\treturn true\n\t}\n\n\t// We expect that the closing transaction only has P2TR addresses.\n\trequire.True(ht, assertTaprootDeliveryUsed(closingTxid),\n\t\t\"taproot addr not used!\")\n\n\t// Now we'll bring Eve into the mix, Eve is running older software that\n\t// doesn't understand Taproot.\n\teveArgs := []string{\"--protocol.no-any-segwit\"}\n\teve := ht.NewNode(\"Eve\", eveArgs)\n\tht.EnsureConnected(carol, eve)\n\n\t// We'll now open up a chanel again between Carol and Eve.\n\tchanPoint = ht.OpenChannel(\n\t\tcarol, eve, lntest.OpenChannelParams{\n\t\t\tAmt:         chanAmt,\n\t\t\tPushAmt:     pushAmt,\n\t\t\tSatPerVByte: satPerVbyte,\n\t\t},\n\t)\n\n\t// We'll now close out this channel and expect that no Taproot\n\t// addresses are used in the co-op close transaction.\n\tclosingTxid = ht.CloseChannel(carol, chanPoint)\n\trequire.False(ht, assertTaprootDeliveryUsed(closingTxid),\n\t\t\"taproot addr shouldn't be used!\")\n}\n\n// testMuSig2CombineKey makes sure that combining a key with MuSig2 returns the\n// correct result according to the MuSig2 version specified.",
      "length": 1969,
      "tokens": 242,
      "embedding": []
    },
    {
      "slug": "func testMuSig2CombineKey(ht *lntest.HarnessTest, alice *node.HarnessNode,",
      "content": "func testMuSig2CombineKey(ht *lntest.HarnessTest, alice *node.HarnessNode,\n\tversion signrpc.MuSig2Version) {\n\n\ttestVector040Key1 := hexDecode(\n\t\t\"F9308A019258C31049344F85F89D5229B531C845836F99B08601F113BCE0\" +\n\t\t\t\"36F9\",\n\t)\n\ttestVector040Key2 := hexDecode(\n\t\t\"DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502B\" +\n\t\t\t\"A659\",\n\t)\n\ttestVector040Key3 := hexDecode(\n\t\t\"3590A94E768F8E1815C2F24B4D80A8E3149316C3518CE7B7AD338368D038\" +\n\t\t\t\"CA66\",\n\t)\n\n\ttestVector100Key1 := hexDecode(\n\t\t\"02F9308A019258C31049344F85F89D5229B531C845836F99B08601F113BC\" +\n\t\t\t\"E036F9\",\n\t)\n\ttestVector100Key2 := hexDecode(\n\t\t\"03DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B50\" +\n\t\t\t\"2BA659\",\n\t)\n\ttestVector100Key3 := hexDecode(\n\t\t\"023590A94E768F8E1815C2F24B4D80A8E3149316C3518CE7B7AD338368D0\" +\n\t\t\t\"38CA66\",\n\t)\n\n\tvar allPubKeys [][]byte\n\tswitch version {\n\tcase signrpc.MuSig2Version_MUSIG2_VERSION_V040:\n\t\tallPubKeys = [][]byte{\n\t\t\ttestVector040Key1, testVector040Key2, testVector040Key3,\n\t\t}\n\n\tcase signrpc.MuSig2Version_MUSIG2_VERSION_V100RC2:\n\t\tallPubKeys = [][]byte{\n\t\t\ttestVector100Key1, testVector100Key2, testVector100Key3,\n\t\t}\n\t}\n\n\tresp := alice.RPC.MuSig2CombineKeys(&signrpc.MuSig2CombineKeysRequest{\n\t\tAllSignerPubkeys: allPubKeys,\n\t\tTaprootTweak: &signrpc.TaprootTweakDesc{\n\t\t\tKeySpendOnly: true,\n\t\t},\n\t\tVersion: version,\n\t})\n\n\texpectedFinalKey040 := hexDecode(\n\t\t\"5b257b4e785d61157ef5303051f45184bd5cb47bc4b4069ed4dd453645\" +\n\t\t\t\"9cb83b\",\n\t)\n\texpectedPreTweakKey040 := hexDecode(\n\t\t\"d70cd69a2647f7390973df48cbfa2ccc407b8b2d60b08c5f1641185c79\" +\n\t\t\t\"98a290\",\n\t)\n\n\texpectedFinalKey100 := hexDecode(\n\t\t\"79e6c3e628c9bfbce91de6b7fb28e2aec7713d377cf260ab599dcbc40e54\" +\n\t\t\t\"2312\",\n\t)\n\texpectedPreTweakKey100 := hexDecode(\n\t\t\"789d937bade6673538f3e28d8368dda4d0512f94da44cf477a505716d26a\" +\n\t\t\t\"1575\",\n\t)\n\n\tswitch version {\n\tcase signrpc.MuSig2Version_MUSIG2_VERSION_V040:\n\t\trequire.Equal(ht, expectedFinalKey040, resp.CombinedKey)\n\t\trequire.Equal(\n\t\t\tht, expectedPreTweakKey040, resp.TaprootInternalKey,\n\t\t)\n\n\tcase signrpc.MuSig2Version_MUSIG2_VERSION_V100RC2:\n\t\trequire.Equal(ht, expectedFinalKey100, resp.CombinedKey)\n\t\trequire.Equal(\n\t\t\tht, expectedPreTweakKey100, resp.TaprootInternalKey,\n\t\t)\n\t}\n}\n",
      "length": 2042,
      "tokens": 136,
      "embedding": []
    }
  ]
}