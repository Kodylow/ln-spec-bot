{
  "filepath": "../implementations/go/lnd/itest/lnd_wallet_import_test.go",
  "package": "itest",
  "sections": [
    {
      "slug": "func walletToLNAddrType(t *testing.T,",
      "content": "func walletToLNAddrType(t *testing.T,\n\taddrType walletrpc.AddressType) lnrpc.AddressType {\n\n\tswitch addrType {\n\tcase walletrpc.AddressType_NESTED_WITNESS_PUBKEY_HASH,\n\t\twalletrpc.AddressType_HYBRID_NESTED_WITNESS_PUBKEY_HASH:\n\n\t\treturn lnrpc.AddressType_NESTED_PUBKEY_HASH\n\n\tcase walletrpc.AddressType_WITNESS_PUBKEY_HASH:\n\t\treturn lnrpc.AddressType_WITNESS_PUBKEY_HASH\n\n\tcase walletrpc.AddressType_TAPROOT_PUBKEY:\n\t\treturn lnrpc.AddressType_TAPROOT_PUBKEY\n\n\tdefault:\n\t\tt.Fatalf(\"unhandled addr type %v\", addrType)\n\t\treturn 0\n\t}\n}\n\n// newExternalAddr generates a new external address of an imported account for a\n// pair of nodes, where one acts as the funder and the other as the signer.",
      "length": 629,
      "tokens": 59,
      "embedding": []
    },
    {
      "slug": "func newExternalAddr(ht *lntest.HarnessTest, funder, signer *node.HarnessNode,",
      "content": "func newExternalAddr(ht *lntest.HarnessTest, funder, signer *node.HarnessNode,\n\timportedAccount string, addrType walletrpc.AddressType) string {\n\n\t// We'll generate a new address for Carol from Dave's node to receive\n\t// and fund a new channel.\n\treq := &lnrpc.NewAddressRequest{\n\t\tType:    walletToLNAddrType(ht.T, addrType),\n\t\tAccount: importedAccount,\n\t}\n\tfunderResp := funder.RPC.NewAddress(req)\n\n\t// Carol also needs to generate the address for the sake of this test\n\t// to be able to sign the channel funding input.\n\treq = &lnrpc.NewAddressRequest{\n\t\tType: walletToLNAddrType(ht.T, addrType),\n\t}\n\tsignerResp := signer.RPC.NewAddress(req)\n\n\t// Sanity check that the generated addresses match.\n\trequire.Equal(ht, funderResp.Address, signerResp.Address)\n\tassertExternalAddrType(ht.T, funderResp.Address, addrType)\n\n\treturn funderResp.Address\n}\n\n// assertExternalAddrType asserts that an external address generated for an\n// imported account is of the expected type.",
      "length": 863,
      "tokens": 106,
      "embedding": []
    },
    {
      "slug": "func assertExternalAddrType(t *testing.T, addrStr string,",
      "content": "func assertExternalAddrType(t *testing.T, addrStr string,\n\taccountAddrType walletrpc.AddressType) {\n\n\taddr, err := btcutil.DecodeAddress(addrStr, harnessNetParams)\n\trequire.NoError(t, err)\n\n\tswitch accountAddrType {\n\tcase walletrpc.AddressType_WITNESS_PUBKEY_HASH:\n\t\trequire.IsType(t, addr, &btcutil.AddressWitnessPubKeyHash{})\n\n\tcase walletrpc.AddressType_NESTED_WITNESS_PUBKEY_HASH,\n\t\twalletrpc.AddressType_HYBRID_NESTED_WITNESS_PUBKEY_HASH:\n\n\t\trequire.IsType(t, addr, &btcutil.AddressScriptHash{})\n\n\tcase walletrpc.AddressType_TAPROOT_PUBKEY:\n\t\trequire.IsType(t, addr, &btcutil.AddressTaproot{})\n\n\tdefault:\n\t\tt.Fatalf(\"unsupported account addr type %v\", accountAddrType)\n\t}\n}\n\n// assertOutputScriptType asserts that a transaction's output, indicated by the\n// output with the given amount, has a script of the expected type. This assumes\n// all transaction outputs have unique amounts.",
      "length": 806,
      "tokens": 70,
      "embedding": []
    },
    {
      "slug": "func assertOutputScriptType(t *testing.T, expType txscript.ScriptClass,",
      "content": "func assertOutputScriptType(t *testing.T, expType txscript.ScriptClass,\n\ttx *wire.MsgTx, outputAmt int64) {\n\n\tfor _, txOut := range tx.TxOut {\n\t\tif txOut.Value != outputAmt {\n\t\t\tcontinue\n\t\t}\n\n\t\tpkScript, err := txscript.ParsePkScript(txOut.PkScript)\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, expType, pkScript.Class())\n\t\treturn\n\t}\n\n\t// No output with the given amount was found.\n\tt.Fatalf(\"output with amount %v not found in transaction %v\", outputAmt,\n\t\tspew.Sdump(tx))\n}\n\n// psbtSendFromImportedAccount attempts to fund a PSBT from the given imported\n// account, originating from the source node to the destination.",
      "length": 529,
      "tokens": 72,
      "embedding": []
    },
    {
      "slug": "func psbtSendFromImportedAccount(ht *lntest.HarnessTest, srcNode, destNode,",
      "content": "func psbtSendFromImportedAccount(ht *lntest.HarnessTest, srcNode, destNode,\n\tsigner *node.HarnessNode, account string,\n\taccountAddrType walletrpc.AddressType) {\n\n\tbalanceResp := srcNode.RPC.WalletBalance()\n\trequire.Contains(ht, balanceResp.AccountBalance, account)\n\tconfBalance := balanceResp.AccountBalance[account].ConfirmedBalance\n\n\tdestAmt := confBalance - 10000\n\tdestAddrResp := destNode.RPC.NewAddress(&lnrpc.NewAddressRequest{\n\t\tType: lnrpc.AddressType_WITNESS_PUBKEY_HASH,\n\t})\n\n\tfundReq := &walletrpc.FundPsbtRequest{\n\t\tTemplate: &walletrpc.FundPsbtRequest_Raw{\n\t\t\tRaw: &walletrpc.TxTemplate{\n\t\t\t\tOutputs: map[string]uint64{\n\t\t\t\t\tdestAddrResp.Address: uint64(destAmt),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tFees: &walletrpc.FundPsbtRequest_SatPerVbyte{\n\t\t\tSatPerVbyte: 1,\n\t\t},\n\t\tAccount: account,\n\t}\n\tfundResp := srcNode.RPC.FundPsbt(fundReq)\n\n\t// Have Carol sign the PSBT input since Dave doesn't have any private\n\t// key information.\n\tfinalizeReq := &walletrpc.FinalizePsbtRequest{\n\t\tFundedPsbt: fundResp.FundedPsbt,\n\t}\n\tfinalizeResp := signer.RPC.FinalizePsbt(finalizeReq)\n\n\t// With the PSBT signed, we can broadcast the resulting transaction.\n\tpublishReq := &walletrpc.Transaction{\n\t\tTxHex: finalizeResp.RawFinalTx,\n\t}\n\tsrcNode.RPC.PublishTransaction(publishReq)\n\n\t// Carol's balance from Dave's perspective should update accordingly.\n\tvar (\n\t\texpTxFee            int64\n\t\texpChangeScriptType txscript.ScriptClass\n\t)\n\tswitch accountAddrType {\n\tcase walletrpc.AddressType_WITNESS_PUBKEY_HASH:\n\t\texpTxFee = 141\n\t\texpChangeScriptType = txscript.WitnessV0PubKeyHashTy\n\n\tcase walletrpc.AddressType_NESTED_WITNESS_PUBKEY_HASH:\n\t\tif account != defaultImportedAccount {\n\t\t\texpTxFee = 165\n\t\t\texpChangeScriptType = txscript.ScriptHashTy\n\t\t\tbreak\n\t\t}\n\n\t\t// Spends from the default NP2WKH imported account have the same\n\t\t// fee rate as the hybrid address type since a NP2WKH input is\n\t\t// spent and a P2WKH change output is created.\n\t\tfallthrough\n\n\tcase walletrpc.AddressType_HYBRID_NESTED_WITNESS_PUBKEY_HASH:\n\t\texpTxFee = 164\n\t\texpChangeScriptType = txscript.WitnessV0PubKeyHashTy\n\n\tcase walletrpc.AddressType_TAPROOT_PUBKEY:\n\t\tif account != defaultImportedAccount {\n\t\t\texpTxFee = 143\n\t\t\texpChangeScriptType = txscript.WitnessV1TaprootTy\n\t\t\tbreak\n\t\t}\n\n\t\t// Spends from the default imported account fall back to a P2WKH\n\t\t// change. We'll want to change that, but in a separate PR.\n\t\texpTxFee = 131\n\t\texpChangeScriptType = txscript.WitnessV0PubKeyHashTy\n\n\tdefault:\n\t\tht.Fatalf(\"unsupported addr type %v\", accountAddrType)\n\t}\n\tchangeUtxoAmt := confBalance - destAmt - expTxFee\n\n\t// If the transaction was created from the default imported account,\n\t// then any change produced is moved to the default wallet account.\n\taccountWithBalance := account\n\tif account == defaultImportedAccount {\n\t\taccountWithBalance = defaultAccount\n\t}\n\tht.AssertWalletAccountBalance(\n\t\tsrcNode, accountWithBalance, 0, changeUtxoAmt,\n\t)\n\tht.MineBlocksAndAssertNumTxes(1, 1)\n\tht.AssertWalletAccountBalance(\n\t\tsrcNode, accountWithBalance, changeUtxoAmt, 0,\n\t)\n\n\t// Finally, assert that the transaction has the expected change address\n\t// type based on the account.\n\tvar tx wire.MsgTx\n\terr := tx.Deserialize(bytes.NewReader(finalizeResp.RawFinalTx))\n\trequire.NoError(ht, err)\n\tassertOutputScriptType(ht.T, expChangeScriptType, &tx, changeUtxoAmt)\n}\n\n// fundChanAndCloseFromImportedAccount attempts to a fund a channel from the\n// given imported account, originating from the source node to the destination\n// node. To ensure the channel is operational before closing it, a test payment\n// is made. Several balance assertions are made along the way for the sake of\n// correctness.",
      "length": 3449,
      "tokens": 370,
      "embedding": []
    },
    {
      "slug": "func fundChanAndCloseFromImportedAccount(ht *lntest.HarnessTest, srcNode,",
      "content": "func fundChanAndCloseFromImportedAccount(ht *lntest.HarnessTest, srcNode,\n\tdestNode, signer *node.HarnessNode, account string,\n\taccountAddrType walletrpc.AddressType, utxoAmt, chanSize int64) {\n\n\t// Retrieve the current confirmed balance to make some assertions later\n\t// on.\n\tbalanceResp := srcNode.RPC.WalletBalance()\n\trequire.Contains(ht, balanceResp.AccountBalance, account)\n\taccountConfBalance := balanceResp.\n\t\tAccountBalance[account].ConfirmedBalance\n\tdefaultAccountConfBalance := balanceResp.\n\t\tAccountBalance[defaultAccount].ConfirmedBalance\n\n\t// Now, start the channel funding process. We'll need to connect both\n\t// nodes first.\n\tht.EnsureConnected(srcNode, destNode)\n\n\t// The source node will then fund the channel through a PSBT shim.\n\tpendingChanID := ht.Random32Bytes()\n\tchanUpdates, rawPsbt := ht.OpenChannelPsbt(\n\t\tsrcNode, destNode, lntest.OpenChannelParams{\n\t\t\tAmt: btcutil.Amount(chanSize),\n\t\t\tFundingShim: &lnrpc.FundingShim{\n\t\t\t\tShim: &lnrpc.FundingShim_PsbtShim{\n\t\t\t\t\tPsbtShim: &lnrpc.PsbtShim{\n\t\t\t\t\t\tPendingChanId: pendingChanID,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t)\n\n\tfundReq := &walletrpc.FundPsbtRequest{\n\t\tTemplate: &walletrpc.FundPsbtRequest_Psbt{\n\t\t\tPsbt: rawPsbt,\n\t\t},\n\t\tFees: &walletrpc.FundPsbtRequest_SatPerVbyte{\n\t\t\tSatPerVbyte: 1,\n\t\t},\n\t\tAccount: account,\n\t}\n\tfundResp := srcNode.RPC.FundPsbt(fundReq)\n\n\tsrcNode.RPC.FundingStateStep(&lnrpc.FundingTransitionMsg{\n\t\tTrigger: &lnrpc.FundingTransitionMsg_PsbtVerify{\n\t\t\tPsbtVerify: &lnrpc.FundingPsbtVerify{\n\t\t\t\tPendingChanId: pendingChanID,\n\t\t\t\tFundedPsbt:    fundResp.FundedPsbt,\n\t\t\t},\n\t\t},\n\t})\n\n\t// Now that we have a PSBT to fund the channel, our signer needs to sign\n\t// it.\n\tfinalizeReq := &walletrpc.FinalizePsbtRequest{\n\t\tFundedPsbt: fundResp.FundedPsbt,\n\t}\n\tfinalizeResp := signer.RPC.FinalizePsbt(finalizeReq)\n\n\t// The source node can then submit the signed PSBT and complete the\n\t// channel funding process.\n\tsrcNode.RPC.FundingStateStep(&lnrpc.FundingTransitionMsg{\n\t\tTrigger: &lnrpc.FundingTransitionMsg_PsbtFinalize{\n\t\t\tPsbtFinalize: &lnrpc.FundingPsbtFinalize{\n\t\t\t\tPendingChanId: pendingChanID,\n\t\t\t\tSignedPsbt:    finalizeResp.SignedPsbt,\n\t\t\t},\n\t\t},\n\t})\n\n\t// We should receive a notification of the channel funding transaction\n\t// being broadcast.\n\tupdateResp := ht.ReceiveOpenChannelUpdate(chanUpdates)\n\tupd, ok := updateResp.Update.(*lnrpc.OpenStatusUpdate_ChanPending)\n\trequire.True(ht, ok)\n\n\t// Mine enough blocks to announce the channel to the network, making\n\t// balance assertions along the way.\n\tvar (\n\t\texpChanTxFee        int64\n\t\texpChangeScriptType txscript.ScriptClass\n\t)\n\tswitch accountAddrType {\n\tcase walletrpc.AddressType_WITNESS_PUBKEY_HASH:\n\t\texpChanTxFee = 153\n\t\texpChangeScriptType = txscript.WitnessV0PubKeyHashTy\n\n\tcase walletrpc.AddressType_NESTED_WITNESS_PUBKEY_HASH:\n\t\tif account != defaultImportedAccount {\n\t\t\texpChanTxFee = 177\n\t\t\texpChangeScriptType = txscript.ScriptHashTy\n\t\t\tbreak\n\t\t}\n\n\t\t// Spends from the default NP2WKH imported account have the same\n\t\t// fee rate as the hybrid address type since a NP2WKH input is\n\t\t// spent and a P2WKH change output is created.\n\t\tfallthrough\n\n\tcase walletrpc.AddressType_HYBRID_NESTED_WITNESS_PUBKEY_HASH:\n\t\texpChanTxFee = 176\n\t\texpChangeScriptType = txscript.WitnessV0PubKeyHashTy\n\n\tcase walletrpc.AddressType_TAPROOT_PUBKEY:\n\t\tif account != defaultImportedAccount {\n\t\t\texpChanTxFee = 155\n\t\t\texpChangeScriptType = txscript.WitnessV1TaprootTy\n\t\t\tbreak\n\t\t}\n\n\t\t// Spends from the default imported account fall back to a P2WKH\n\t\t// change. We'll want to change that, but in a separate PR.\n\t\texpChanTxFee = 143\n\t\texpChangeScriptType = txscript.WitnessV0PubKeyHashTy\n\n\tdefault:\n\t\tht.Fatalf(\"unsupported addr type %v\", accountAddrType)\n\t}\n\tchanChangeUtxoAmt := utxoAmt - chanSize - expChanTxFee\n\ttxHash, err := chainhash.NewHash(upd.ChanPending.Txid)\n\trequire.NoError(ht, err)\n\n\t// If we're spending from the default imported account, then any change\n\t// outputs produced are moved to the default wallet account, so we\n\t// should expect to see balances there.\n\tvar confBalanceAfterChan int64\n\tif account == defaultImportedAccount {\n\t\tconfBalanceAfterChan = defaultAccountConfBalance\n\t\tht.AssertWalletAccountBalance(srcNode, account, 0, 0)\n\t\tht.AssertWalletAccountBalance(\n\t\t\tsrcNode, defaultAccount, defaultAccountConfBalance,\n\t\t\tchanChangeUtxoAmt,\n\t\t)\n\n\t\tblock := ht.MineBlocksAndAssertNumTxes(6, 1)[0]\n\t\tht.Miner.AssertTxInBlock(block, txHash)\n\n\t\tconfBalanceAfterChan += chanChangeUtxoAmt\n\t\tht.AssertWalletAccountBalance(srcNode, account, 0, 0)\n\t\tht.AssertWalletAccountBalance(\n\t\t\tsrcNode, defaultAccount, confBalanceAfterChan, 0,\n\t\t)\n\t} else {\n\t\t// Otherwise, all interactions remain within Carol's imported\n\t\t// account.\n\t\tconfBalanceAfterChan = accountConfBalance - utxoAmt\n\t\tht.AssertWalletAccountBalance(\n\t\t\tsrcNode, account, confBalanceAfterChan,\n\t\t\tchanChangeUtxoAmt,\n\t\t)\n\n\t\tblock := ht.MineBlocksAndAssertNumTxes(6, 1)[0]\n\t\tht.Miner.AssertTxInBlock(block, txHash)\n\n\t\tconfBalanceAfterChan += chanChangeUtxoAmt\n\t\tht.AssertWalletAccountBalance(\n\t\t\tsrcNode, account, confBalanceAfterChan, 0,\n\t\t)\n\t}\n\n\t// Assert that the transaction has the expected change address type\n\t// based on the account.\n\tvar tx wire.MsgTx\n\terr = tx.Deserialize(bytes.NewReader(finalizeResp.RawFinalTx))\n\trequire.NoError(ht, err)\n\tassertOutputScriptType(\n\t\tht.T, expChangeScriptType, &tx, chanChangeUtxoAmt,\n\t)\n\n\t// Wait for the channel to be announced by both parties.\n\tchanPoint := &lnrpc.ChannelPoint{\n\t\tFundingTxid: &lnrpc.ChannelPoint_FundingTxidBytes{\n\t\t\tFundingTxidBytes: upd.ChanPending.Txid,\n\t\t},\n\t\tOutputIndex: upd.ChanPending.OutputIndex,\n\t}\n\tht.AssertTopologyChannelOpen(srcNode, chanPoint)\n\tht.AssertTopologyChannelOpen(destNode, chanPoint)\n\n\t// Send a test payment to ensure the channel is operating as normal.\n\tconst invoiceAmt = 100000\n\tinvoice := &lnrpc.Invoice{\n\t\tMemo:  \"psbt import chan\",\n\t\tValue: invoiceAmt,\n\t}\n\tresp := destNode.RPC.AddInvoice(invoice)\n\n\tht.CompletePaymentRequests(srcNode, []string{resp.PaymentRequest})\n\n\t// TODO(yy): remove the sleep once the following bug is fixed. When the\n\t// payment is reported as settled by srcNode, it's expected the\n\t// commitment dance is finished and all subsequent states have been\n\t// updated. Yet we'd receive the error `cannot co-op close channel with\n\t// active htlcs` or `link failed to shutdown` if we close the channel.\n\t// We need to investigate the order of settling the payments and\n\t// updating commitments to understand and fix .\n\ttime.Sleep(2 * time.Second)\n\n\t// Now that we've confirmed the opened channel works, we'll close it.\n\tht.CloseChannel(srcNode, chanPoint)\n\n\t// Since the channel still had funds left on the source node's side,\n\t// they must've been redeemed after the close. Without a pre-negotiated\n\t// close address, the funds will go into the source node's wallet\n\t// instead of the imported account.\n\tconst chanCloseTxFee = 9650\n\tbalanceFromClosedChan := chanSize - invoiceAmt - chanCloseTxFee\n\n\tif account == defaultImportedAccount {\n\t\tht.AssertWalletAccountBalance(srcNode, account, 0, 0)\n\t\tht.AssertWalletAccountBalance(\n\t\t\tsrcNode, defaultAccount,\n\t\t\tconfBalanceAfterChan+balanceFromClosedChan, 0,\n\t\t)\n\t} else {\n\t\tht.AssertWalletAccountBalance(\n\t\t\tsrcNode, account, confBalanceAfterChan, 0,\n\t\t)\n\t\tht.AssertWalletAccountBalance(\n\t\t\tsrcNode, defaultAccount, balanceFromClosedChan, 0,\n\t\t)\n\t}\n}\n\n// testWalletImportAccount tests that an imported account can fund transactions\n// and channels through PSBTs, by having one node (the one with the imported\n// account) craft the transactions and another node act as the signer.",
      "length": 7254,
      "tokens": 778,
      "embedding": []
    },
    {
      "slug": "func testWalletImportAccount(ht *lntest.HarnessTest) {",
      "content": "func testWalletImportAccount(ht *lntest.HarnessTest) {\n\ttestCases := []struct {\n\t\tname     string\n\t\taddrType walletrpc.AddressType\n\t}{\n\t\t{\n\t\t\tname: \"standard BIP-0049\",\n\t\t\taddrType: walletrpc.\n\t\t\t\tAddressType_NESTED_WITNESS_PUBKEY_HASH,\n\t\t},\n\t\t{\n\t\t\tname: \"lnd BIP-0049 variant\",\n\t\t\taddrType: walletrpc.\n\t\t\t\tAddressType_HYBRID_NESTED_WITNESS_PUBKEY_HASH,\n\t\t},\n\t\t{\n\t\t\tname:     \"standard BIP-0084\",\n\t\t\taddrType: walletrpc.AddressType_WITNESS_PUBKEY_HASH,\n\t\t},\n\t\t{\n\t\t\tname:     \"standard BIP-0086\",\n\t\t\taddrType: walletrpc.AddressType_TAPROOT_PUBKEY,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\t\tsuccess := ht.Run(tc.name, func(tt *testing.T) {\n\t\t\ttestFunc := func(ht *lntest.HarnessTest) {\n\t\t\t\ttestWalletImportAccountScenario(\n\t\t\t\t\tht, tc.addrType,\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tst := ht.Subtest(tt)\n\n\t\t\tst.RunTestCase(&lntest.TestCase{\n\t\t\t\tName:     tc.name,\n\t\t\t\tTestFunc: testFunc,\n\t\t\t})\n\t\t})\n\t\tif !success {\n\t\t\t// Log failure time to help relate the lnd logs to the\n\t\t\t// failure.\n\t\t\tht.Logf(\"Failure time: %v\", time.Now().Format(\n\t\t\t\t\"2006-01-02 15:04:05.000\",\n\t\t\t))\n\t\t\tbreak\n\t\t}\n\t}\n}\n",
      "length": 975,
      "tokens": 105,
      "embedding": []
    },
    {
      "slug": "func testWalletImportAccountScenario(ht *lntest.HarnessTest,",
      "content": "func testWalletImportAccountScenario(ht *lntest.HarnessTest,\n\taddrType walletrpc.AddressType) {\n\n\t// We'll start our test by having two nodes, Carol and Dave. Carol's\n\t// default wallet account will be imported into Dave's node.\n\t//\n\t// NOTE: we won't use standby nodes here since the test will change\n\t// each of the node's wallet state.\n\tcarol := ht.NewNode(\"carol\", nil)\n\tdave := ht.NewNode(\"dave\", nil)\n\n\trunWalletImportAccountScenario(ht, addrType, carol, dave)\n}\n",
      "length": 396,
      "tokens": 60,
      "embedding": []
    },
    {
      "slug": "func runWalletImportAccountScenario(ht *lntest.HarnessTest,",
      "content": "func runWalletImportAccountScenario(ht *lntest.HarnessTest,\n\taddrType walletrpc.AddressType, carol, dave *node.HarnessNode) {\n\n\tconst utxoAmt int64 = btcutil.SatoshiPerBitcoin\n\n\tlistReq := &walletrpc.ListAccountsRequest{\n\t\tName:        \"default\",\n\t\tAddressType: addrType,\n\t}\n\tlistResp := carol.RPC.ListAccounts(listReq)\n\trequire.Len(ht, listResp.Accounts, 1)\n\tcarolAccount := listResp.Accounts[0]\n\n\tconst importedAccount = \"carol\"\n\timportReq := &walletrpc.ImportAccountRequest{\n\t\tName:              importedAccount,\n\t\tExtendedPublicKey: carolAccount.ExtendedPublicKey,\n\t\tAddressType:       addrType,\n\t}\n\tdave.RPC.ImportAccount(importReq)\n\n\t// We'll generate an address for Carol from Dave's node to receive some\n\t// funds.\n\texternalAddr := newExternalAddr(\n\t\tht, dave, carol, importedAccount, addrType,\n\t)\n\n\t// Send coins to Carol's address and confirm them, making sure the\n\t// balance updates accordingly.\n\talice := ht.Alice\n\treq := &lnrpc.SendCoinsRequest{\n\t\tAddr:       externalAddr,\n\t\tAmount:     utxoAmt,\n\t\tSatPerByte: 1,\n\t}\n\talice.RPC.SendCoins(req)\n\n\tht.AssertWalletAccountBalance(dave, importedAccount, 0, utxoAmt)\n\tht.MineBlocksAndAssertNumTxes(1, 1)\n\tht.AssertWalletAccountBalance(dave, importedAccount, utxoAmt, 0)\n\n\t// To ensure that Dave can use Carol's account as watch-only, we'll\n\t// construct a PSBT that sends funds to Alice, which we'll then hand\n\t// over to Carol to sign.\n\tpsbtSendFromImportedAccount(\n\t\tht, dave, alice, carol, importedAccount, addrType,\n\t)\n\n\t// We'll generate a new address for Carol from Dave's node to receive\n\t// and fund a new channel.\n\texternalAddr = newExternalAddr(\n\t\tht, dave, carol, importedAccount, addrType,\n\t)\n\n\t// Retrieve the current confirmed balance of the imported account for\n\t// some assertions we'll make later on.\n\tbalanceResp := dave.RPC.WalletBalance()\n\trequire.Contains(ht, balanceResp.AccountBalance, importedAccount)\n\tconfBalance := balanceResp.AccountBalance[importedAccount].\n\t\tConfirmedBalance\n\n\t// Send coins to Carol's address and confirm them, making sure the\n\t// balance updates accordingly.\n\treq = &lnrpc.SendCoinsRequest{\n\t\tAddr:       externalAddr,\n\t\tAmount:     utxoAmt,\n\t\tSatPerByte: 1,\n\t}\n\talice.RPC.SendCoins(req)\n\n\tht.AssertWalletAccountBalance(\n\t\tdave, importedAccount, confBalance, utxoAmt,\n\t)\n\tht.MineBlocksAndAssertNumTxes(1, 1)\n\tht.AssertWalletAccountBalance(\n\t\tdave, importedAccount, confBalance+utxoAmt, 0,\n\t)\n\n\t// Now that we have enough funds, it's time to fund the channel, make a\n\t// test payment, and close it. This contains several balance assertions\n\t// along the way.\n\tfundChanAndCloseFromImportedAccount(\n\t\tht, dave, alice, carol, importedAccount, addrType, utxoAmt,\n\t\tint64(funding.MaxBtcFundingAmount),\n\t)\n}\n\n// testWalletImportPubKey tests that an imported public keys can fund\n// transactions and channels through PSBTs, by having one node (the one with the\n// imported account) craft the transactions and another node act as the signer.",
      "length": 2790,
      "tokens": 321,
      "embedding": []
    },
    {
      "slug": "func testWalletImportPubKey(ht *lntest.HarnessTest) {",
      "content": "func testWalletImportPubKey(ht *lntest.HarnessTest) {\n\ttestCases := []struct {\n\t\tname     string\n\t\taddrType walletrpc.AddressType\n\t}{\n\t\t{\n\t\t\tname: \"BIP-0049\",\n\t\t\taddrType: walletrpc.\n\t\t\t\tAddressType_NESTED_WITNESS_PUBKEY_HASH,\n\t\t},\n\t\t{\n\t\t\tname:     \"BIP-0084\",\n\t\t\taddrType: walletrpc.AddressType_WITNESS_PUBKEY_HASH,\n\t\t},\n\t\t{\n\t\t\tname:     \"BIP-0086\",\n\t\t\taddrType: walletrpc.AddressType_TAPROOT_PUBKEY,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\t\tsuccess := ht.Run(tc.name, func(tt *testing.T) {\n\t\t\ttestFunc := func(ht *lntest.HarnessTest) {\n\t\t\t\ttestWalletImportPubKeyScenario(\n\t\t\t\t\tht, tc.addrType,\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tst := ht.Subtest(tt)\n\n\t\t\tst.RunTestCase(&lntest.TestCase{\n\t\t\t\tName:     tc.name,\n\t\t\t\tTestFunc: testFunc,\n\t\t\t})\n\t\t})\n\t\tif !success {\n\t\t\t// Log failure time to help relate the lnd logs to the\n\t\t\t// failure.\n\t\t\tht.Logf(\"Failure time: %v\", time.Now().Format(\n\t\t\t\t\"2006-01-02 15:04:05.000\",\n\t\t\t))\n\t\t\tbreak\n\t\t}\n\t}\n}\n",
      "length": 835,
      "tokens": 93,
      "embedding": []
    },
    {
      "slug": "func testWalletImportPubKeyScenario(ht *lntest.HarnessTest,",
      "content": "func testWalletImportPubKeyScenario(ht *lntest.HarnessTest,\n\taddrType walletrpc.AddressType) {\n\n\tconst utxoAmt int64 = btcutil.SatoshiPerBitcoin\n\talice := ht.Alice\n\n\t// We'll start our test by having two nodes, Carol and Dave.\n\t//\n\t// NOTE: we won't use standby nodes here since the test will change\n\t// each of the node's wallet state.\n\tcarol := ht.NewNode(\"carol\", nil)\n\tdave := ht.NewNode(\"dave\", nil)\n\n\t// We'll define a helper closure that we'll use throughout the test to\n\t// generate a new address of the given type from Carol's perspective,\n\t// import it into Dave's wallet, and fund it.\n\timportPubKey := func(keyIndex uint32, prevConfBalance,\n\t\tprevUnconfBalance int64) {\n\n\t\t// Retrieve Carol's account public key for the corresponding\n\t\t// address type.\n\t\tlistReq := &walletrpc.ListAccountsRequest{\n\t\t\tName:        \"default\",\n\t\t\tAddressType: addrType,\n\t\t}\n\t\tlistResp := carol.RPC.ListAccounts(listReq)\n\t\trequire.Len(ht, listResp.Accounts, 1)\n\t\tp2wkhAccount := listResp.Accounts[0]\n\n\t\t// Derive the external address at the given index.\n\t\taccountPubKey, err := hdkeychain.NewKeyFromString(\n\t\t\tp2wkhAccount.ExtendedPublicKey,\n\t\t)\n\t\trequire.NoError(ht, err)\n\t\texternalAccountExtKey, err := accountPubKey.Derive(0)\n\t\trequire.NoError(ht, err)\n\t\texternalAddrExtKey, err := externalAccountExtKey.Derive(\n\t\t\tkeyIndex,\n\t\t)\n\t\trequire.NoError(ht, err)\n\t\texternalAddrPubKey, err := externalAddrExtKey.ECPubKey()\n\t\trequire.NoError(ht, err)\n\n\t\t// Serialize as 32-byte x-only pubkey for Taproot addresses.\n\t\tserializedPubKey := externalAddrPubKey.SerializeCompressed()\n\t\tif addrType == walletrpc.AddressType_TAPROOT_PUBKEY {\n\t\t\tserializedPubKey = schnorr.SerializePubKey(\n\t\t\t\texternalAddrPubKey,\n\t\t\t)\n\t\t}\n\n\t\t// Import the public key into Dave.\n\t\timportReq := &walletrpc.ImportPublicKeyRequest{\n\t\t\tPublicKey:   serializedPubKey,\n\t\t\tAddressType: addrType,\n\t\t}\n\t\tdave.RPC.ImportPublicKey(importReq)\n\n\t\t// We'll also generate the same address for Carol, as it'll be\n\t\t// required later when signing.\n\t\tcarolAddrResp := carol.RPC.NewAddress(&lnrpc.NewAddressRequest{\n\t\t\tType: walletToLNAddrType(ht.T, addrType),\n\t\t})\n\n\t\t// Send coins to Carol's address and confirm them, making sure\n\t\t// the balance updates accordingly.\n\t\treq := &lnrpc.SendCoinsRequest{\n\t\t\tAddr:       carolAddrResp.Address,\n\t\t\tAmount:     utxoAmt,\n\t\t\tSatPerByte: 1,\n\t\t}\n\t\talice.RPC.SendCoins(req)\n\n\t\tht.AssertWalletAccountBalance(\n\t\t\tdave, defaultImportedAccount, prevConfBalance,\n\t\t\tprevUnconfBalance+utxoAmt,\n\t\t)\n\t\tht.MineBlocksAndAssertNumTxes(1, 1)\n\t\tht.AssertWalletAccountBalance(\n\t\t\tdave, defaultImportedAccount,\n\t\t\tprevConfBalance+utxoAmt, prevUnconfBalance,\n\t\t)\n\t}\n\n\t// We'll have Carol generate a new external address, which we'll import\n\t// into Dave.\n\timportPubKey(0, 0, 0)\n\n\t// To ensure that Dave can use Carol's public key as watch-only, we'll\n\t// construct a PSBT that sends funds to Alice, which we'll then hand\n\t// over to Carol to sign.\n\tpsbtSendFromImportedAccount(\n\t\tht, dave, alice, carol, defaultImportedAccount, addrType,\n\t)\n\n\t// We'll now attempt to fund a channel.\n\t//\n\t// We'll have Carol generate another external address, which we'll\n\t// import into Dave again.\n\tbalanceResp := dave.RPC.WalletBalance()\n\trequire.Contains(ht, balanceResp.AccountBalance, defaultImportedAccount)\n\tconfBalance := balanceResp.\n\t\tAccountBalance[defaultImportedAccount].ConfirmedBalance\n\timportPubKey(1, confBalance, 0)\n\n\t// Now that we have enough funds, it's time to fund the channel, make a\n\t// test payment, and close it. This contains several balance assertions\n\t// along the way.\n\tfundChanAndCloseFromImportedAccount(\n\t\tht, dave, alice, carol, defaultImportedAccount, addrType,\n\t\tutxoAmt, int64(funding.MaxBtcFundingAmount),\n\t)\n}\n",
      "length": 3527,
      "tokens": 401,
      "embedding": []
    }
  ]
}