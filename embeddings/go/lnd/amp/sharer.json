{
  "filepath": "../implementations/go/lnd/amp/sharer.go",
  "package": "amp",
  "sections": [
    {
      "slug": "type Sharer interface {",
      "content": "type Sharer interface {\n\t// Root returns the root share of the derivation tree. This is the value\n\t// that will be reconstructed when combining the set of all child\n\t// shares.\n\tRoot() Share\n\n\t// Child derives a child preimage and child hash given a 32-bit index.\n\t// Passing a different index will generate a unique preimage-hash pair\n\t// with high probability, allowing the payment hash carried on HTLCs to\n\t// be refreshed without needing to modify the share value. This would\n\t// typically be used when an partial payment needs to be retried if it\n\t// encounters routine network failures.\n\tChild(index uint32) *Child\n\n\t// Split returns a Sharer for the left and right child of the parent\n\t// Sharer. XORing the share values of both sharers always yields the\n\t// share value of the parent. The sender should use this to recursively\n\t// divide payments that are too large into smaller subpayments, knowing\n\t// that the shares of all nodes descending from the parent will XOR to\n\t// the parent's share.\n\tSplit() (Sharer, Sharer, error)\n\n\t// Merge takes the given Child and \"merges\" it into the Sharer by\n\t// XOR-ing its share with the Sharer's current share.\n\tMerge(*Child) Sharer\n\n\t// Zero returns a a new \"zero Sharer\" that has its current share set to\n\t// zero, while keeping the root share. Merging a Child from the\n\t// original Sharer into this zero-Sharer gives back the original\n\t// Sharer.\n\tZero() Sharer\n}\n\n// SeedSharer orchestrates the sharing of the root AMP seed along multiple\n// paths. It also supports derivation of the child payment hashes that get\n// attached to HTLCs, and the child preimages used by the receiver to settle\n// individual HTLCs in the set.",
      "length": 1616,
      "tokens": 283,
      "embedding": []
    },
    {
      "slug": "type SeedSharer struct {",
      "content": "type SeedSharer struct {\n\troot Share\n\tcurr Share\n}\n\n// NewSeedSharer generates a new SeedSharer instance with a seed drawn at\n// random.",
      "length": 106,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func NewSeedSharer() (*SeedSharer, error) {",
      "content": "func NewSeedSharer() (*SeedSharer, error) {\n\tvar root Share\n\tif _, err := rand.Read(root[:]); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn SeedSharerFromRoot(&root), nil\n}\n\n// SeedSharerFromRoot instantiates a SeedSharer with an externally provided\n// seed.",
      "length": 202,
      "tokens": 31,
      "embedding": []
    },
    {
      "slug": "func SeedSharerFromRoot(root *Share) *SeedSharer {",
      "content": "func SeedSharerFromRoot(root *Share) *SeedSharer {\n\treturn initSeedSharer(root, root)\n}\n",
      "length": 35,
      "tokens": 4,
      "embedding": []
    },
    {
      "slug": "func initSeedSharer(root, curr *Share) *SeedSharer {",
      "content": "func initSeedSharer(root, curr *Share) *SeedSharer {\n\treturn &SeedSharer{\n\t\troot: *root,\n\t\tcurr: *curr,\n\t}\n}\n\n// Seed returns the sharer's seed, the primary source of entropy for deriving\n// shares of the root.",
      "length": 150,
      "tokens": 26,
      "embedding": []
    },
    {
      "slug": "func (s *SeedSharer) Root() Share {",
      "content": "func (s *SeedSharer) Root() Share {\n\treturn s.root\n}\n\n// Split constructs two child Sharers whose shares sum to the parent Sharer.\n// This allows an HTLC whose payment amount could not be routed to be\n// recursively split into smaller subpayments. After splitting a sharer the\n// parent share should no longer be used, and the caller should use the Child\n// method on each to derive preimage/hash pairs for the HTLCs.",
      "length": 374,
      "tokens": 67,
      "embedding": []
    },
    {
      "slug": "func (s *SeedSharer) Split() (Sharer, Sharer, error) {",
      "content": "func (s *SeedSharer) Split() (Sharer, Sharer, error) {\n\t// We cannot split the zero-Sharer.\n\tif s.curr == zeroShare {\n\t\treturn nil, nil, fmt.Errorf(\"cannot split zero-Sharer\")\n\t}\n\n\tshareLeft, shareRight, err := split(&s.curr)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tleft := initSeedSharer(&s.root, &shareLeft)\n\tright := initSeedSharer(&s.root, &shareRight)\n\n\treturn left, right, nil\n}\n\n// Merge takes the given Child and \"merges\" it into the Sharer by XOR-ing its\n// share with the Sharer's current share.",
      "length": 438,
      "tokens": 68,
      "embedding": []
    },
    {
      "slug": "func (s *SeedSharer) Merge(child *Child) Sharer {",
      "content": "func (s *SeedSharer) Merge(child *Child) Sharer {\n\tvar curr Share\n\tcurr.Xor(&s.curr, &child.Share)\n\n\tsharer := initSeedSharer(&s.root, &curr)\n\treturn sharer\n}\n\n// Zero returns a a new \"zero Sharer\" that has its current share set to zero,\n// while keeping the root share. Merging a Child from the original Sharer into\n// this zero-Sharer gives back the original Sharer.",
      "length": 309,
      "tokens": 50,
      "embedding": []
    },
    {
      "slug": "func (s *SeedSharer) Zero() Sharer {",
      "content": "func (s *SeedSharer) Zero() Sharer {\n\treturn initSeedSharer(&s.root, &zeroShare)\n}\n\n// Child derives a preimage/hash pair to be used for an AMP HTLC.\n// All children of s will use the same underlying share, but have unique\n// preimage and hash. This can be used to rerandomize the preimage/hash pair for\n// a given HTLC if a new route is needed.",
      "length": 302,
      "tokens": 55,
      "embedding": []
    },
    {
      "slug": "func (s *SeedSharer) Child(index uint32) *Child {",
      "content": "func (s *SeedSharer) Child(index uint32) *Child {\n\tdesc := ChildDesc{\n\t\tShare: s.curr,\n\t\tIndex: index,\n\t}\n\n\treturn DeriveChild(s.root, desc)\n}\n\n// ReconstructChildren derives the set of children hashes and preimages from the\n// provided descriptors. The shares from each child descriptor are first used to\n// compute the root, afterwards the child hashes and preimages are\n// deterministically computed. For child descriptor at index i in the input,\n// it's derived child will occupy index i of the returned children.",
      "length": 455,
      "tokens": 72,
      "embedding": []
    },
    {
      "slug": "func ReconstructChildren(descs ...ChildDesc) []*Child {",
      "content": "func ReconstructChildren(descs ...ChildDesc) []*Child {\n\t// Recompute the root by XORing the provided shares.\n\tvar root Share\n\tfor _, desc := range descs {\n\t\troot.Xor(&root, &desc.Share)\n\t}\n\n\t// With the root computed, derive the child hashes and preimages from\n\t// the child descriptors.\n\tchildren := make([]*Child, len(descs))\n\tfor i, desc := range descs {\n\t\tchildren[i] = DeriveChild(root, desc)\n\t}\n\n\treturn children\n}\n\n// split splits a share into two random values, that when XOR'd reproduce the\n// original share. Given a share s, the two shares are derived as:\n//\n//\tleft <-$- random\n//\tright = parent ^ left.\n//\n// When reconstructed, we have that:\n//\n//\tleft ^ right = left ^ parent ^ left\n//\t             = parent.",
      "length": 643,
      "tokens": 116,
      "embedding": []
    },
    {
      "slug": "func split(parent *Share) (Share, Share, error) {",
      "content": "func split(parent *Share) (Share, Share, error) {\n\t// Generate a random share for the left child.\n\tvar left Share\n\tif _, err := rand.Read(left[:]); err != nil {\n\t\treturn Share{}, Share{}, err\n\t}\n\n\t// Compute right = parent ^ left.\n\tvar right Share\n\tright.Xor(parent, &left)\n\n\treturn left, right, nil\n}\n\nvar _ Sharer = (*SeedSharer)(nil)\n",
      "length": 273,
      "tokens": 48,
      "embedding": []
    }
  ]
}