{
  "filepath": "../implementations/go/lnd/healthcheck/healthcheck.go",
  "package": "Package",
  "sections": [
    {
      "slug": "type Config struct {",
      "content": "type Config struct {\n\t// Checks is a set of health checks that assert that lnd has access to\n\t// critical resources.\n\tChecks []*Observation\n\n\t// Shutdown should be called to request safe shutdown on failure of a\n\t// health check.\n\tShutdown shutdownFunc\n}\n\n// shutdownFunc is the signature we use for a shutdown function which allows us\n// to print our reason for shutdown.",
      "length": 341,
      "tokens": 60,
      "embedding": []
    },
    {
      "slug": "type shutdownFunc func(format string, params ...interface{})",
      "content": "type shutdownFunc func(format string, params ...interface{})\n\n// Monitor periodically checks a series of configured liveness checks to\n// ensure that lnd has access to all critical resources.",
      "length": 128,
      "tokens": 21,
      "embedding": []
    },
    {
      "slug": "type Monitor struct {",
      "content": "type Monitor struct {\n\tstarted int32 // To be used atomically.\n\tstopped int32 // To be used atomically.\n\n\tcfg *Config\n\n\tquit chan struct{}\n\twg   sync.WaitGroup\n}\n\n// NewMonitor returns a monitor with the provided config.",
      "length": 189,
      "tokens": 31,
      "embedding": []
    },
    {
      "slug": "func NewMonitor(cfg *Config) *Monitor {",
      "content": "func NewMonitor(cfg *Config) *Monitor {\n\treturn &Monitor{\n\t\tcfg:  cfg,\n\t\tquit: make(chan struct{}),\n\t}\n}\n\n// Start launches the goroutines required to run our monitor.",
      "length": 121,
      "tokens": 19,
      "embedding": []
    },
    {
      "slug": "func (m *Monitor) Start() error {",
      "content": "func (m *Monitor) Start() error {\n\tif !atomic.CompareAndSwapInt32(&m.started, 0, 1) {\n\t\treturn errors.New(\"monitor already started\")\n\t}\n\n\t// Run through all of the health checks that we have configured and\n\t// start a goroutine for each check.\n\tfor _, check := range m.cfg.Checks {\n\t\tcheck := check\n\n\t\t// Skip over health checks that are disabled by setting zero\n\t\t// attempts.\n\t\tif check.Attempts == 0 {\n\t\t\tlog.Warnf(\"check: %v configured with 0 attempts, \"+\n\t\t\t\t\"skipping it\", check.Name)\n\n\t\t\tcontinue\n\t\t}\n\n\t\tm.wg.Add(1)\n\t\tgo func(check *Observation) {\n\t\t\tdefer m.wg.Done()\n\n\t\t\tcheck.monitor(m.cfg.Shutdown, m.quit)\n\t\t}(check)\n\t}\n\n\treturn nil\n}\n\n// Stop sends all goroutines the signal to exit and waits for them to exit.",
      "length": 660,
      "tokens": 99,
      "embedding": []
    },
    {
      "slug": "func (m *Monitor) Stop() error {",
      "content": "func (m *Monitor) Stop() error {\n\tif !atomic.CompareAndSwapInt32(&m.stopped, 0, 1) {\n\t\treturn fmt.Errorf(\"monitor already stopped\")\n\t}\n\n\tlog.Info(\"Health monitor shutting down\")\n\n\tclose(m.quit)\n\tm.wg.Wait()\n\n\treturn nil\n}\n\n// CreateCheck is a helper function that takes a function that produces an error\n// and wraps it in a function that returns its result on an error channel.\n// We do not wait group the goroutine running our checkFunc because we expect\n// to be dealing with health checks that may block; if we wait group them, we\n// may wait forever. Ideally future health checks will allow callers to cancel\n// them early, and we can wait group this.",
      "length": 606,
      "tokens": 100,
      "embedding": []
    },
    {
      "slug": "func CreateCheck(checkFunc func() error) func() chan error {",
      "content": "func CreateCheck(checkFunc func() error) func() chan error {\n\treturn func() chan error {\n\t\terrChan := make(chan error, 1)\n\t\tgo func() {\n\t\t\terrChan <- checkFunc()\n\t\t}()\n\n\t\treturn errChan\n\t}\n}\n\n// Observation represents a liveness check that we periodically check.",
      "length": 191,
      "tokens": 31,
      "embedding": []
    },
    {
      "slug": "type Observation struct {",
      "content": "type Observation struct {\n\t// Name describes the health check.\n\tName string\n\n\t// Check runs the health check itself, returning an error channel that\n\t// is expected to receive nil or an error.\n\tCheck func() chan error\n\n\t// Interval is a ticker which triggers running our check function. This\n\t// ticker must be started and stopped by the observation.\n\tInterval ticker.Ticker\n\n\t// Attempts is the number of calls we make for a single check before\n\t// failing.\n\tAttempts int\n\n\t// Timeout is the amount of time we allow our check function to take\n\t// before we time it out.\n\tTimeout time.Duration\n\n\t// Backoff is the amount of time we back off between retries for failed\n\t// checks.\n\tBackoff time.Duration\n}\n\n// NewObservation creates an observation.",
      "length": 697,
      "tokens": 121,
      "embedding": []
    },
    {
      "slug": "func NewObservation(name string, check func() error, interval,",
      "content": "func NewObservation(name string, check func() error, interval,\n\ttimeout, backoff time.Duration, attempts int) *Observation {\n\n\treturn &Observation{\n\t\tName:     name,\n\t\tCheck:    CreateCheck(check),\n\t\tInterval: ticker.New(interval),\n\t\tAttempts: attempts,\n\t\tTimeout:  timeout,\n\t\tBackoff:  backoff,\n\t}\n}\n\n// String returns a string representation of an observation.",
      "length": 287,
      "tokens": 32,
      "embedding": []
    },
    {
      "slug": "func (o *Observation) String() string {",
      "content": "func (o *Observation) String() string {\n\treturn o.Name\n}\n\n// monitor executes a health check every time its interval ticks until the quit\n// channel signals that we should shutdown. This function is also responsible\n// for starting and stopping our ticker.",
      "length": 211,
      "tokens": 36,
      "embedding": []
    },
    {
      "slug": "func (o *Observation) monitor(shutdown shutdownFunc, quit chan struct{}) {",
      "content": "func (o *Observation) monitor(shutdown shutdownFunc, quit chan struct{}) {\n\tlog.Debugf(\"Monitoring: %v\", o)\n\n\to.Interval.Resume()\n\tdefer o.Interval.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-o.Interval.Ticks():\n\t\t\t// retryCheck will return errMaxAttemptsReached when\n\t\t\t// the max attempts are reached. In that case we will\n\t\t\t// stop the ticker and quit.\n\t\t\tif o.retryCheck(quit, shutdown) {\n\t\t\t\tlog.Debugf(\"Health check: max attempts \" +\n\t\t\t\t\t\"failed, monitor exiting\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t// Exit if we receive the instruction to shutdown.\n\t\tcase <-quit:\n\t\t\tlog.Debug(\"Health check: monitor quit\")\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// retryCheck calls a check function until it succeeds, or we reach our\n// configured number of attempts, waiting for our back off period between failed\n// calls. If we fail to obtain a passing health check after the allowed number\n// of calls, we will request shutdown. It returns a bool to indicate whether\n// the max number of attempts is reached.",
      "length": 858,
      "tokens": 132,
      "embedding": []
    },
    {
      "slug": "func (o *Observation) retryCheck(quit chan struct{},",
      "content": "func (o *Observation) retryCheck(quit chan struct{},\n\tshutdown shutdownFunc) bool {\n\n\tvar count int\n\n\tfor count < o.Attempts {\n\t\t// Increment our call count and call the health check endpoint.\n\t\tcount++\n\n\t\t// Wait for our check to return, timeout to elapse, or quit\n\t\t// signal to be received.\n\t\tvar err error\n\t\tselect {\n\t\tcase err = <-o.Check():\n\n\t\tcase <-time.After(o.Timeout):\n\t\t\terr = fmt.Errorf(\"health check: %v timed out after: \"+\n\t\t\t\t\"%v\", o, o.Timeout)\n\n\t\tcase <-quit:\n\t\t\tlog.Debug(\"Health check: monitor quit\")\n\t\t\treturn false\n\t\t}\n\n\t\t// If our error is nil, we have passed our health check, so we\n\t\t// can exit.\n\t\tif err == nil {\n\t\t\treturn false\n\t\t}\n\n\t\t// If we have reached our allowed number of attempts, this\n\t\t// check has failed so we request shutdown.\n\t\tif count == o.Attempts {\n\t\t\tshutdown(\"Health check: %v failed after %v \"+\n\t\t\t\t\"calls\", o, o.Attempts)\n\t\t\treturn true\n\t\t}\n\n\t\tlog.Infof(\"Health check: %v, call: %v failed with: %v, \"+\n\t\t\t\"backing off for: %v\", o, count, err, o.Backoff)\n\n\t\t// If we are still within the number of calls allowed for this\n\t\t// check, we wait for our back off period to elapse, or exit if\n\t\t// we get the signal to shutdown.\n\t\tselect {\n\t\tcase <-time.After(o.Backoff):\n\n\t\tcase <-quit:\n\t\t\tlog.Debug(\"Health check: monitor quit\")\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn false\n}\n",
      "length": 1207,
      "tokens": 203,
      "embedding": []
    }
  ]
}