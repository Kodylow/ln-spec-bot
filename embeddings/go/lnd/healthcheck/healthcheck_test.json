{
  "filepath": "../implementations/go/lnd/healthcheck/healthcheck_test.go",
  "package": "healthcheck",
  "sections": [
    {
      "slug": "type mockedCheck struct {",
      "content": "type mockedCheck struct {\n\tt       *testing.T\n\terrChan chan error\n}\n\n// newMockCheck creates a new mock.",
      "length": 74,
      "tokens": 12,
      "embedding": []
    },
    {
      "slug": "func newMockCheck(t *testing.T) *mockedCheck {",
      "content": "func newMockCheck(t *testing.T) *mockedCheck {\n\treturn &mockedCheck{\n\t\tt:       t,\n\t\terrChan: make(chan error),\n\t}\n}\n\n// call returns our mock's error channel, which we can send responses on.",
      "length": 138,
      "tokens": 22,
      "embedding": []
    },
    {
      "slug": "func (m *mockedCheck) call() chan error {",
      "content": "func (m *mockedCheck) call() chan error {\n\treturn m.errChan\n}\n\n// sendError sends an error into our mock's error channel, mocking the sending\n// of a response from our check function.",
      "length": 137,
      "tokens": 24,
      "embedding": []
    },
    {
      "slug": "func (m *mockedCheck) sendError(err error) {",
      "content": "func (m *mockedCheck) sendError(err error) {\n\tselect {\n\tcase m.errChan <- err:\n\tcase <-time.After(timeout):\n\t\tm.t.Fatalf(\"could not send error: %v\", err)\n\t}\n}\n\n// TestMonitor tests creation and triggering of a monitor with a health check.",
      "length": 186,
      "tokens": 29,
      "embedding": []
    },
    {
      "slug": "func TestMonitor(t *testing.T) {",
      "content": "func TestMonitor(t *testing.T) {\n\tintervalTicker := ticker.NewForce(time.Hour)\n\n\tmock := newMockCheck(t)\n\tshutdown := make(chan struct{})\n\n\t// Create our config for monitoring. We will use a 0 back off so that\n\t// out test does not need to wait.\n\tcfg := &Config{\n\t\tChecks: []*Observation{\n\t\t\t{\n\t\t\t\tCheck:    mock.call,\n\t\t\t\tInterval: intervalTicker,\n\t\t\t\tAttempts: 2,\n\t\t\t\tBackoff:  0,\n\t\t\t\tTimeout:  time.Hour,\n\t\t\t},\n\t\t},\n\t\tShutdown: func(string, ...interface{}) {\n\t\t\tshutdown <- struct{}{}\n\t\t},\n\t}\n\tmonitor := NewMonitor(cfg)\n\n\trequire.NoError(t, monitor.Start(), \"could not start monitor\")\n\n\t// Tick is a helper we will use to tick our interval.\n\ttick := func() {\n\t\tselect {\n\t\tcase intervalTicker.Force <- testTime:\n\t\tcase <-time.After(timeout):\n\t\t\tt.Fatal(\"could not tick timer\")\n\t\t}\n\t}\n\n\t// Tick our timer and provide our error channel with a nil error. This\n\t// mocks our check function succeeding on the first call.\n\ttick()\n\tmock.sendError(nil)\n\n\t// Now we tick our timer again. This time send a non-nil error, followed\n\t// by a nil error. This tests our retry logic, because we allow 2\n\t// retries, so should recover without needing to shutdown.\n\ttick()\n\tmock.sendError(errNonNil)\n\tmock.sendError(nil)\n\n\t// Finally, we tick our timer once more, and send two non-nil errors\n\t// into our error channel. This mocks our check function failing twice.\n\ttick()\n\tmock.sendError(errNonNil)\n\tmock.sendError(errNonNil)\n\n\t// Since we have failed within our allowed number of retries, we now\n\t// expect a call to our shutdown function.\n\tselect {\n\tcase <-shutdown:\n\tcase <-time.After(timeout):\n\t\tt.Fatal(\"expected shutdown\")\n\t}\n\n\trequire.NoError(t, monitor.Stop(), \"could not stop monitor\")\n}\n\n// TestRetryCheck tests our retry logic. It does not include a test for exiting\n// during the back off period.",
      "length": 1697,
      "tokens": 250,
      "embedding": []
    },
    {
      "slug": "func TestRetryCheck(t *testing.T) {",
      "content": "func TestRetryCheck(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\n\t\t// errors provides an in-order list of errors that we expect our\n\t\t// health check to respond with. The number of errors in this\n\t\t// list indicates the number of times we expect our check to\n\t\t// be called, because our test will fail if we do not consume\n\t\t// every error.\n\t\terrors []error\n\n\t\t// attempts is the number of times we call a check before\n\t\t// failing.\n\t\tattempts int\n\n\t\t// timeout is the time we allow our check to take before we\n\t\t// fail them.\n\t\ttimeout time.Duration\n\n\t\t// expectedShutdown is true if we expect a shutdown to be\n\t\t// triggered because all of our calls failed.\n\t\texpectedShutdown bool\n\n\t\t// maxAttemptsReached specifies whether the max allowed\n\t\t// attempts are reached from calling retryCheck.\n\t\tmaxAttemptsReached bool\n\t}{\n\t\t{\n\t\t\tname:               \"first call succeeds\",\n\t\t\terrors:             []error{nil},\n\t\t\tattempts:           2,\n\t\t\ttimeout:            time.Hour,\n\t\t\texpectedShutdown:   false,\n\t\t\tmaxAttemptsReached: false,\n\t\t},\n\t\t{\n\t\t\tname:               \"first call fails\",\n\t\t\terrors:             []error{errNonNil},\n\t\t\tattempts:           1,\n\t\t\ttimeout:            time.Hour,\n\t\t\texpectedShutdown:   true,\n\t\t\tmaxAttemptsReached: true,\n\t\t},\n\t\t{\n\t\t\tname:               \"fail then recover\",\n\t\t\terrors:             []error{errNonNil, nil},\n\t\t\tattempts:           2,\n\t\t\ttimeout:            time.Hour,\n\t\t\texpectedShutdown:   false,\n\t\t\tmaxAttemptsReached: false,\n\t\t},\n\t\t{\n\t\t\tname:               \"always fail\",\n\t\t\terrors:             []error{errNonNil, errNonNil},\n\t\t\tattempts:           2,\n\t\t\ttimeout:            time.Hour,\n\t\t\texpectedShutdown:   true,\n\t\t\tmaxAttemptsReached: true,\n\t\t},\n\t\t{\n\t\t\tname:               \"no calls\",\n\t\t\terrors:             nil,\n\t\t\tattempts:           0,\n\t\t\ttimeout:            time.Hour,\n\t\t\texpectedShutdown:   false,\n\t\t\tmaxAttemptsReached: false,\n\t\t},\n\t\t{\n\t\t\tname:               \"call times out\",\n\t\t\terrors:             nil,\n\t\t\tattempts:           1,\n\t\t\ttimeout:            1,\n\t\t\texpectedShutdown:   true,\n\t\t\tmaxAttemptsReached: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar shutdown bool\n\t\t\tshutdownFunc := func(string, ...interface{}) {\n\t\t\t\tshutdown = true\n\t\t\t}\n\n\t\t\tmock := newMockCheck(t)\n\n\t\t\t// Create an observation that calls our call counting\n\t\t\t// function. We set a zero back off so that the test\n\t\t\t// will not wait.\n\t\t\tobservation := &Observation{\n\t\t\t\tCheck:    mock.call,\n\t\t\t\tAttempts: test.attempts,\n\t\t\t\tTimeout:  test.timeout,\n\t\t\t\tBackoff:  0,\n\t\t\t}\n\t\t\tquit := make(chan struct{})\n\n\t\t\t// Run our retry check in a goroutine because it blocks\n\t\t\t// on us sending errors into the mocked caller's error\n\t\t\t// channel.\n\t\t\tdone := make(chan struct{})\n\t\t\tretryResult := false\n\t\t\tgo func() {\n\t\t\t\tretryResult = observation.retryCheck(\n\t\t\t\t\tquit, shutdownFunc,\n\t\t\t\t)\n\t\t\t\tclose(done)\n\t\t\t}()\n\n\t\t\t// Prompt our mock caller to send responses for calls\n\t\t\t// to our call function.\n\t\t\tfor _, err := range test.errors {\n\t\t\t\tmock.sendError(err)\n\t\t\t}\n\n\t\t\t// Make sure that we have finished running our retry\n\t\t\t// check function before we start checking results.\n\t\t\t<-done\n\n\t\t\trequire.Equal(t, test.maxAttemptsReached, retryResult,\n\t\t\t\t\"retryCheck returned unexpected error\")\n\t\t\trequire.Equal(t, test.expectedShutdown, shutdown,\n\t\t\t\t\"unexpected shutdown state\")\n\t\t})\n\t}\n}\n",
      "length": 3201,
      "tokens": 399,
      "embedding": []
    }
  ]
}