{
  "filepath": "../implementations/go/lnd/macaroons/service_test.go",
  "package": "macaroons_test",
  "sections": [
    {
      "slug": "func setupTestRootKeyStorage(t *testing.T) kvdb.Backend {",
      "content": "func setupTestRootKeyStorage(t *testing.T) kvdb.Backend {\n\tdb, err := kvdb.Create(\n\t\tkvdb.BoltBackendName, path.Join(t.TempDir(), \"macaroons.db\"), true,\n\t\tkvdb.DefaultDBTimeout,\n\t)\n\trequire.NoError(t, err, \"Error opening store DB\")\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, db.Close())\n\t})\n\n\tstore, err := macaroons.NewRootKeyStorage(db)\n\trequire.NoError(t, err, \"Error creating root key store\")\n\n\terr = store.CreateUnlock(&defaultPw)\n\trequire.NoError(t, store.Close())\n\trequire.NoError(t, err, \"error creating unlock\")\n\n\treturn db\n}\n\n// TestNewService tests the creation of the macaroon service.",
      "length": 518,
      "tokens": 54,
      "embedding": []
    },
    {
      "slug": "func TestNewService(t *testing.T) {",
      "content": "func TestNewService(t *testing.T) {\n\t// First, initialize a dummy DB file with a store that the service\n\t// can read from. Make sure the file is removed in the end.\n\tdb := setupTestRootKeyStorage(t)\n\n\trootKeyStore, err := macaroons.NewRootKeyStorage(db)\n\trequire.NoError(t, err)\n\n\t// Second, create the new service instance, unlock it and pass in a\n\t// checker that we expect it to add to the bakery.\n\tservice, err := macaroons.NewService(\n\t\trootKeyStore, \"lnd\", false, macaroons.IPLockChecker,\n\t)\n\trequire.NoError(t, err, \"Error creating new service\")\n\tdefer service.Close()\n\terr = service.CreateUnlock(&defaultPw)\n\trequire.NoError(t, err, \"Error unlocking root key storage\")\n\n\t// Third, check if the created service can bake macaroons.\n\t_, err = service.NewMacaroon(context.TODO(), nil, testOperation)\n\tif err != macaroons.ErrMissingRootKeyID {\n\t\tt.Fatalf(\"Received %v instead of ErrMissingRootKeyID\", err)\n\t}\n\n\tmacaroon, err := service.NewMacaroon(\n\t\tcontext.TODO(), macaroons.DefaultRootKeyID, testOperation,\n\t)\n\trequire.NoError(t, err, \"Error creating macaroon from service\")\n\tif macaroon.Namespace().String() != \"std:\" {\n\t\tt.Fatalf(\"The created macaroon has an invalid namespace: %s\",\n\t\t\tmacaroon.Namespace().String())\n\t}\n\n\t// Finally, check if the service has been initialized correctly and\n\t// the checker has been added.\n\tvar checkerFound = false\n\tchecker := service.Checker.FirstPartyCaveatChecker.(*checkers.Checker)\n\tfor _, info := range checker.Info() {\n\t\tif info.Name == \"ipaddr\" &&\n\t\t\tinfo.Prefix == \"\" &&\n\t\t\tinfo.Namespace == \"std\" {\n\t\t\tcheckerFound = true\n\t\t}\n\t}\n\tif !checkerFound {\n\t\tt.Fatalf(\"Checker '%s' not found in service.\", \"ipaddr\")\n\t}\n}\n\n// TestValidateMacaroon tests the validation of a macaroon that is in an\n// incoming context.",
      "length": 1673,
      "tokens": 220,
      "embedding": []
    },
    {
      "slug": "func TestValidateMacaroon(t *testing.T) {",
      "content": "func TestValidateMacaroon(t *testing.T) {\n\t// First, initialize the service and unlock it.\n\tdb := setupTestRootKeyStorage(t)\n\trootKeyStore, err := macaroons.NewRootKeyStorage(db)\n\trequire.NoError(t, err)\n\tservice, err := macaroons.NewService(\n\t\trootKeyStore, \"lnd\", false, macaroons.IPLockChecker,\n\t)\n\trequire.NoError(t, err, \"Error creating new service\")\n\tdefer service.Close()\n\n\terr = service.CreateUnlock(&defaultPw)\n\trequire.NoError(t, err, \"Error unlocking root key storage\")\n\n\t// Then, create a new macaroon that we can serialize.\n\tmacaroon, err := service.NewMacaroon(\n\t\tcontext.TODO(), macaroons.DefaultRootKeyID, testOperation,\n\t\ttestOperationURI,\n\t)\n\trequire.NoError(t, err, \"Error creating macaroon from service\")\n\tmacaroonBinary, err := macaroon.M().MarshalBinary()\n\trequire.NoError(t, err, \"Error serializing macaroon\")\n\n\t// Because the macaroons are always passed in a context, we need to\n\t// mock one that has just the serialized macaroon as a value.\n\tmd := metadata.New(map[string]string{\n\t\t\"macaroon\": hex.EncodeToString(macaroonBinary),\n\t})\n\tmockContext := metadata.NewIncomingContext(context.Background(), md)\n\n\t// Finally, validate the macaroon against the required permissions.\n\terr = service.ValidateMacaroon(\n\t\tmockContext, []bakery.Op{testOperation}, \"FooMethod\",\n\t)\n\trequire.NoError(t, err, \"Error validating the macaroon\")\n\n\t// If the macaroon has the method specific URI permission, the list of\n\t// required entity/action pairs is irrelevant.\n\terr = service.ValidateMacaroon(\n\t\tmockContext, []bakery.Op{{Entity: \"irrelevant\"}}, \"SomeMethod\",\n\t)\n\trequire.NoError(t, err, \"Error validating the macaroon\")\n}\n\n// TestListMacaroonIDs checks that ListMacaroonIDs returns the expected result.",
      "length": 1627,
      "tokens": 179,
      "embedding": []
    },
    {
      "slug": "func TestListMacaroonIDs(t *testing.T) {",
      "content": "func TestListMacaroonIDs(t *testing.T) {\n\t// First, initialize a dummy DB file with a store that the service\n\t// can read from. Make sure the file is removed in the end.\n\tdb := setupTestRootKeyStorage(t)\n\n\t// Second, create the new service instance, unlock it and pass in a\n\t// checker that we expect it to add to the bakery.\n\trootKeyStore, err := macaroons.NewRootKeyStorage(db)\n\trequire.NoError(t, err)\n\tservice, err := macaroons.NewService(\n\t\trootKeyStore, \"lnd\", false, macaroons.IPLockChecker,\n\t)\n\trequire.NoError(t, err, \"Error creating new service\")\n\tdefer service.Close()\n\n\terr = service.CreateUnlock(&defaultPw)\n\trequire.NoError(t, err, \"Error unlocking root key storage\")\n\n\t// Third, make 3 new macaroons with different root key IDs.\n\texpectedIDs := [][]byte{{1}, {2}, {3}}\n\tfor _, v := range expectedIDs {\n\t\t_, err := service.NewMacaroon(context.TODO(), v, testOperation)\n\t\trequire.NoError(t, err, \"Error creating macaroon from service\")\n\t}\n\n\t// Finally, check that calling List return the expected values.\n\tids, _ := service.ListMacaroonIDs(context.TODO())\n\trequire.Equal(t, expectedIDs, ids, \"root key IDs mismatch\")\n}\n\n// TestDeleteMacaroonID removes the specific root key ID.",
      "length": 1120,
      "tokens": 153,
      "embedding": []
    },
    {
      "slug": "func TestDeleteMacaroonID(t *testing.T) {",
      "content": "func TestDeleteMacaroonID(t *testing.T) {\n\tctxb := context.Background()\n\n\t// First, initialize a dummy DB file with a store that the service\n\t// can read from. Make sure the file is removed in the end.\n\tdb := setupTestRootKeyStorage(t)\n\n\t// Second, create the new service instance, unlock it and pass in a\n\t// checker that we expect it to add to the bakery.\n\trootKeyStore, err := macaroons.NewRootKeyStorage(db)\n\trequire.NoError(t, err)\n\tservice, err := macaroons.NewService(\n\t\trootKeyStore, \"lnd\", false, macaroons.IPLockChecker,\n\t)\n\trequire.NoError(t, err, \"Error creating new service\")\n\tdefer service.Close()\n\n\terr = service.CreateUnlock(&defaultPw)\n\trequire.NoError(t, err, \"Error unlocking root key storage\")\n\n\t// Third, checks that removing encryptedKeyID returns an error.\n\tencryptedKeyID := []byte(\"enckey\")\n\t_, err = service.DeleteMacaroonID(ctxb, encryptedKeyID)\n\trequire.Equal(t, macaroons.ErrDeletionForbidden, err)\n\n\t// Fourth, checks that removing DefaultKeyID returns an error.\n\t_, err = service.DeleteMacaroonID(ctxb, macaroons.DefaultRootKeyID)\n\trequire.Equal(t, macaroons.ErrDeletionForbidden, err)\n\n\t// Fifth, checks that removing empty key id returns an error.\n\t_, err = service.DeleteMacaroonID(ctxb, []byte{})\n\trequire.Equal(t, macaroons.ErrMissingRootKeyID, err)\n\n\t// Sixth, checks that removing a non-existed key id returns nil.\n\tnonExistedID := []byte(\"test-non-existed\")\n\tdeletedID, err := service.DeleteMacaroonID(ctxb, nonExistedID)\n\trequire.NoError(t, err, \"deleting macaroon ID got an error\")\n\trequire.Nil(t, deletedID, \"deleting non-existed ID should return nil\")\n\n\t// Seventh, make 3 new macaroons with different root key IDs, and delete\n\t// one.\n\texpectedIDs := [][]byte{{1}, {2}, {3}}\n\tfor _, v := range expectedIDs {\n\t\t_, err := service.NewMacaroon(ctxb, v, testOperation)\n\t\trequire.NoError(t, err, \"Error creating macaroon from service\")\n\t}\n\tdeletedID, err = service.DeleteMacaroonID(ctxb, expectedIDs[0])\n\trequire.NoError(t, err, \"deleting macaroon ID got an error\")\n\n\t// Finally, check that the ID is deleted.\n\trequire.Equal(t, expectedIDs[0], deletedID, \"expected ID to be removed\")\n\tids, _ := service.ListMacaroonIDs(ctxb)\n\trequire.Equal(t, expectedIDs[1:], ids, \"root key IDs mismatch\")\n}\n\n// TestCloneMacaroons tests that macaroons can be cloned correctly and that\n// modifications to the copy don't affect the original.",
      "length": 2265,
      "tokens": 282,
      "embedding": []
    },
    {
      "slug": "func TestCloneMacaroons(t *testing.T) {",
      "content": "func TestCloneMacaroons(t *testing.T) {\n\t// Get a configured version of the constraint function.\n\tconstraintFunc := macaroons.TimeoutConstraint(3)\n\n\t// Now we need a dummy macaroon that we can apply the constraint\n\t// function to.\n\ttestMacaroon := createDummyMacaroon(t)\n\terr := constraintFunc(testMacaroon)\n\trequire.NoError(t, err)\n\n\t// Check that the caveat has an empty location.\n\trequire.Equal(\n\t\tt, \"\", testMacaroon.Caveats()[0].Location,\n\t\t\"expected caveat location to be empty, found: %s\",\n\t\ttestMacaroon.Caveats()[0].Location,\n\t)\n\n\t// Make a copy of the macaroon.\n\tnewMacCred, err := macaroons.NewMacaroonCredential(testMacaroon)\n\trequire.NoError(t, err)\n\n\tnewMac := newMacCred.Macaroon\n\trequire.Equal(\n\t\tt, \"\", newMac.Caveats()[0].Location,\n\t\t\"expected new caveat location to be empty, found: %s\",\n\t\tnewMac.Caveats()[0].Location,\n\t)\n\n\t// They should be deep equal as well.\n\ttestMacaroonBytes, err := testMacaroon.MarshalBinary()\n\trequire.NoError(t, err)\n\tnewMacBytes, err := newMac.MarshalBinary()\n\trequire.NoError(t, err)\n\trequire.Equal(t, testMacaroonBytes, newMacBytes)\n\n\t// Modify the caveat location on the old macaroon.\n\ttestMacaroon.Caveats()[0].Location = \"mars\"\n\n\t// The old macaroon's caveat location should be changed.\n\trequire.Equal(\n\t\tt, \"mars\", testMacaroon.Caveats()[0].Location,\n\t\t\"expected caveat location to be empty, found: %s\",\n\t\ttestMacaroon.Caveats()[0].Location,\n\t)\n\n\t// The new macaroon's caveat location should stay untouched.\n\trequire.Equal(\n\t\tt, \"\", newMac.Caveats()[0].Location,\n\t\t\"expected new caveat location to be empty, found: %s\",\n\t\tnewMac.Caveats()[0].Location,\n\t)\n}\n",
      "length": 1519,
      "tokens": 173,
      "embedding": []
    }
  ]
}