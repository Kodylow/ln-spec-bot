{
  "filepath": "../implementations/go/lnd/peer/brontide_test.go",
  "package": "peer",
  "sections": [
    {
      "slug": "func TestPeerChannelClosureAcceptFeeResponder(t *testing.T) {",
      "content": "func TestPeerChannelClosureAcceptFeeResponder(t *testing.T) {\n\tt.Parallel()\n\n\tnotifier := &mock.ChainNotifier{\n\t\tSpendChan: make(chan *chainntnfs.SpendDetail),\n\t\tEpochChan: make(chan *chainntnfs.BlockEpoch),\n\t\tConfChan:  make(chan *chainntnfs.TxConfirmation),\n\t}\n\tbroadcastTxChan := make(chan *wire.MsgTx)\n\n\tmockSwitch := &mockMessageSwitch{}\n\n\talicePeer, bobChan, err := createTestPeer(\n\t\tt, notifier, broadcastTxChan, noUpdate, mockSwitch,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\tchanID := lnwire.NewChanIDFromOutPoint(bobChan.ChannelPoint())\n\n\tmockLink := newMockUpdateHandler(chanID)\n\tmockSwitch.links = append(mockSwitch.links, mockLink)\n\n\tdummyDeliveryScript := genScript(t, p2wshAddress)\n\n\t// We send a shutdown request to Alice. She will now be the responding\n\t// node in this shutdown procedure. We first expect Alice to answer\n\t// this shutdown request with a Shutdown message.\n\talicePeer.chanCloseMsgs <- &closeMsg{\n\t\tcid: chanID,\n\t\tmsg: lnwire.NewShutdown(chanID, dummyDeliveryScript),\n\t}\n\n\tvar msg lnwire.Message\n\tselect {\n\tcase outMsg := <-alicePeer.outgoingQueue:\n\t\tmsg = outMsg.msg\n\tcase <-time.After(timeout):\n\t\tt.Fatalf(\"did not receive shutdown message\")\n\t}\n\n\tshutdownMsg, ok := msg.(*lnwire.Shutdown)\n\tif !ok {\n\t\tt.Fatalf(\"expected Shutdown message, got %T\", msg)\n\t}\n\n\trespDeliveryScript := shutdownMsg.Address\n\n\t// Alice will then send a ClosingSigned message, indicating her proposed\n\t// closing transaction fee. Alice sends the ClosingSigned message as she is\n\t// the initiator of the channel.\n\tselect {\n\tcase outMsg := <-alicePeer.outgoingQueue:\n\t\tmsg = outMsg.msg\n\tcase <-time.After(timeout):\n\t\tt.Fatalf(\"did not receive ClosingSigned message\")\n\t}\n\n\trespClosingSigned, ok := msg.(*lnwire.ClosingSigned)\n\tif !ok {\n\t\tt.Fatalf(\"expected ClosingSigned message, got %T\", msg)\n\t}\n\n\t// We accept the fee, and send a ClosingSigned with the same fee back,\n\t// so she knows we agreed.\n\taliceFee := respClosingSigned.FeeSatoshis\n\tbobSig, _, _, err := bobChan.CreateCloseProposal(\n\t\taliceFee, dummyDeliveryScript, respDeliveryScript,\n\t)\n\trequire.NoError(t, err, \"error creating close proposal\")\n\n\tparsedSig, err := lnwire.NewSigFromSignature(bobSig)\n\trequire.NoError(t, err, \"error parsing signature\")\n\tclosingSigned := lnwire.NewClosingSigned(chanID, aliceFee, parsedSig)\n\talicePeer.chanCloseMsgs <- &closeMsg{\n\t\tcid: chanID,\n\t\tmsg: closingSigned,\n\t}\n\n\t// Alice should now see that we agreed on the fee, and should broadcast the\n\t// closing transaction.\n\tselect {\n\tcase <-broadcastTxChan:\n\tcase <-time.After(timeout):\n\t\tt.Fatalf(\"closing tx not broadcast\")\n\t}\n\n\t// Need to pull the remaining message off of Alice's outgoing queue.\n\tselect {\n\tcase outMsg := <-alicePeer.outgoingQueue:\n\t\tmsg = outMsg.msg\n\tcase <-time.After(timeout):\n\t\tt.Fatalf(\"did not receive ClosingSigned message\")\n\t}\n\tif _, ok := msg.(*lnwire.ClosingSigned); !ok {\n\t\tt.Fatalf(\"expected ClosingSigned message, got %T\", msg)\n\t}\n\n\t// Alice should be waiting in a goroutine for a confirmation.\n\tnotifier.ConfChan <- &chainntnfs.TxConfirmation{}\n}\n\n// TestPeerChannelClosureAcceptFeeInitiator tests the shutdown initiator's\n// behavior if we can agree on the fee immediately.",
      "length": 3015,
      "tokens": 357,
      "embedding": []
    },
    {
      "slug": "func TestPeerChannelClosureAcceptFeeInitiator(t *testing.T) {",
      "content": "func TestPeerChannelClosureAcceptFeeInitiator(t *testing.T) {\n\tt.Parallel()\n\n\tnotifier := &mock.ChainNotifier{\n\t\tSpendChan: make(chan *chainntnfs.SpendDetail),\n\t\tEpochChan: make(chan *chainntnfs.BlockEpoch),\n\t\tConfChan:  make(chan *chainntnfs.TxConfirmation),\n\t}\n\tbroadcastTxChan := make(chan *wire.MsgTx)\n\n\tmockSwitch := &mockMessageSwitch{}\n\n\talicePeer, bobChan, err := createTestPeer(\n\t\tt, notifier, broadcastTxChan, noUpdate, mockSwitch,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\tchanID := lnwire.NewChanIDFromOutPoint(bobChan.ChannelPoint())\n\tmockLink := newMockUpdateHandler(chanID)\n\tmockSwitch.links = append(mockSwitch.links, mockLink)\n\n\tdummyDeliveryScript := genScript(t, p2wshAddress)\n\n\t// We make Alice send a shutdown request.\n\tupdateChan := make(chan interface{}, 1)\n\terrChan := make(chan error, 1)\n\tcloseCommand := &htlcswitch.ChanClose{\n\t\tCloseType:      contractcourt.CloseRegular,\n\t\tChanPoint:      bobChan.ChannelPoint(),\n\t\tUpdates:        updateChan,\n\t\tTargetFeePerKw: 12500,\n\t\tErr:            errChan,\n\t}\n\talicePeer.localCloseChanReqs <- closeCommand\n\n\t// We can now pull a Shutdown message off of Alice's outgoingQueue.\n\tvar msg lnwire.Message\n\tselect {\n\tcase outMsg := <-alicePeer.outgoingQueue:\n\t\tmsg = outMsg.msg\n\tcase <-time.After(timeout):\n\t\tt.Fatalf(\"did not receive shutdown request\")\n\t}\n\n\tshutdownMsg, ok := msg.(*lnwire.Shutdown)\n\tif !ok {\n\t\tt.Fatalf(\"expected Shutdown message, got %T\", msg)\n\t}\n\n\taliceDeliveryScript := shutdownMsg.Address\n\n\t// Bob will respond with his own Shutdown message.\n\talicePeer.chanCloseMsgs <- &closeMsg{\n\t\tcid: chanID,\n\t\tmsg: lnwire.NewShutdown(chanID,\n\t\t\tdummyDeliveryScript),\n\t}\n\n\t// Alice will reply with a ClosingSigned here.\n\tselect {\n\tcase outMsg := <-alicePeer.outgoingQueue:\n\t\tmsg = outMsg.msg\n\tcase <-time.After(timeout):\n\t\tt.Fatalf(\"did not receive closing signed message\")\n\t}\n\tclosingSignedMsg, ok := msg.(*lnwire.ClosingSigned)\n\tif !ok {\n\t\tt.Fatalf(\"expected to receive closing signed message, got %T\", msg)\n\t}\n\n\t// Bob should reply with the exact same fee in his next ClosingSigned\n\t// message.\n\tbobFee := closingSignedMsg.FeeSatoshis\n\tbobSig, _, _, err := bobChan.CreateCloseProposal(\n\t\tbobFee, dummyDeliveryScript, aliceDeliveryScript,\n\t)\n\trequire.NoError(t, err, \"unable to create close proposal\")\n\tparsedSig, err := lnwire.NewSigFromSignature(bobSig)\n\trequire.NoError(t, err, \"unable to parse signature\")\n\n\tclosingSigned := lnwire.NewClosingSigned(shutdownMsg.ChannelID,\n\t\tbobFee, parsedSig)\n\talicePeer.chanCloseMsgs <- &closeMsg{\n\t\tcid: chanID,\n\t\tmsg: closingSigned,\n\t}\n\n\t// Alice should accept Bob's fee, broadcast the cooperative close tx, and\n\t// send a ClosingSigned message back to Bob.\n\n\t// Alice should now broadcast the closing transaction.\n\tselect {\n\tcase <-broadcastTxChan:\n\tcase <-time.After(timeout):\n\t\tt.Fatalf(\"closing tx not broadcast\")\n\t}\n\n\t// Alice should respond with the ClosingSigned they both agreed upon.\n\tselect {\n\tcase outMsg := <-alicePeer.outgoingQueue:\n\t\tmsg = outMsg.msg\n\tcase <-time.After(timeout):\n\t\tt.Fatalf(\"did not receive closing signed message\")\n\t}\n\n\tclosingSignedMsg, ok = msg.(*lnwire.ClosingSigned)\n\tif !ok {\n\t\tt.Fatalf(\"expected ClosingSigned message, got %T\", msg)\n\t}\n\n\tif closingSignedMsg.FeeSatoshis != bobFee {\n\t\tt.Fatalf(\"expected ClosingSigned fee to be %v, instead got %v\",\n\t\t\tbobFee, closingSignedMsg.FeeSatoshis)\n\t}\n\n\t// Alice should be waiting on a single confirmation for the coop close tx.\n\tnotifier.ConfChan <- &chainntnfs.TxConfirmation{}\n}\n\n// TestPeerChannelClosureFeeNegotiationsResponder tests the shutdown\n// responder's behavior in the case where we must do several rounds of fee\n// negotiation before we agree on a fee.",
      "length": 3497,
      "tokens": 400,
      "embedding": []
    },
    {
      "slug": "func TestPeerChannelClosureFeeNegotiationsResponder(t *testing.T) {",
      "content": "func TestPeerChannelClosureFeeNegotiationsResponder(t *testing.T) {\n\tt.Parallel()\n\n\tnotifier := &mock.ChainNotifier{\n\t\tSpendChan: make(chan *chainntnfs.SpendDetail),\n\t\tEpochChan: make(chan *chainntnfs.BlockEpoch),\n\t\tConfChan:  make(chan *chainntnfs.TxConfirmation),\n\t}\n\tbroadcastTxChan := make(chan *wire.MsgTx)\n\n\tmockSwitch := &mockMessageSwitch{}\n\n\talicePeer, bobChan, err := createTestPeer(\n\t\tt, notifier, broadcastTxChan, noUpdate, mockSwitch,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\tchanID := lnwire.NewChanIDFromOutPoint(bobChan.ChannelPoint())\n\n\tmockLink := newMockUpdateHandler(chanID)\n\tmockSwitch.links = append(mockSwitch.links, mockLink)\n\n\t// Bob sends a shutdown request to Alice. She will now be the responding\n\t// node in this shutdown procedure. We first expect Alice to answer this\n\t// Shutdown request with a Shutdown message.\n\tdummyDeliveryScript := genScript(t, p2wshAddress)\n\talicePeer.chanCloseMsgs <- &closeMsg{\n\t\tcid: chanID,\n\t\tmsg: lnwire.NewShutdown(chanID,\n\t\t\tdummyDeliveryScript),\n\t}\n\n\tvar msg lnwire.Message\n\tselect {\n\tcase outMsg := <-alicePeer.outgoingQueue:\n\t\tmsg = outMsg.msg\n\tcase <-time.After(timeout):\n\t\tt.Fatalf(\"did not receive shutdown message\")\n\t}\n\n\tshutdownMsg, ok := msg.(*lnwire.Shutdown)\n\tif !ok {\n\t\tt.Fatalf(\"expected Shutdown message, got %T\", msg)\n\t}\n\n\taliceDeliveryScript := shutdownMsg.Address\n\n\t// As Alice is the channel initiator, she will send her ClosingSigned\n\t// message.\n\tselect {\n\tcase outMsg := <-alicePeer.outgoingQueue:\n\t\tmsg = outMsg.msg\n\tcase <-time.After(timeout):\n\t\tt.Fatalf(\"did not receive closing signed message\")\n\t}\n\n\taliceClosingSigned, ok := msg.(*lnwire.ClosingSigned)\n\tif !ok {\n\t\tt.Fatalf(\"expected ClosingSigned message, got %T\", msg)\n\t}\n\n\t// Bob doesn't agree with the fee and will send one back that's 2.5x.\n\tpreferredRespFee := aliceClosingSigned.FeeSatoshis\n\tincreasedFee := btcutil.Amount(float64(preferredRespFee) * 2.5)\n\tbobSig, _, _, err := bobChan.CreateCloseProposal(\n\t\tincreasedFee, dummyDeliveryScript, aliceDeliveryScript,\n\t)\n\trequire.NoError(t, err, \"error creating close proposal\")\n\n\tparsedSig, err := lnwire.NewSigFromSignature(bobSig)\n\trequire.NoError(t, err, \"error parsing signature\")\n\tclosingSigned := lnwire.NewClosingSigned(chanID, increasedFee, parsedSig)\n\talicePeer.chanCloseMsgs <- &closeMsg{\n\t\tcid: chanID,\n\t\tmsg: closingSigned,\n\t}\n\n\t// Alice will now see the new fee we propose, but with current settings it\n\t// won't accept it immediately as it differs too much by its ideal fee. We\n\t// should get a new proposal back, which should have the average fee rate\n\t// proposed.\n\tselect {\n\tcase outMsg := <-alicePeer.outgoingQueue:\n\t\tmsg = outMsg.msg\n\tcase <-time.After(timeout):\n\t\tt.Fatalf(\"did not receive closing signed message\")\n\t}\n\n\taliceClosingSigned, ok = msg.(*lnwire.ClosingSigned)\n\tif !ok {\n\t\tt.Fatalf(\"expected ClosingSigned message, got %T\", msg)\n\t}\n\n\t// The fee sent by Alice should be less than the fee Bob just sent as Alice\n\t// should attempt to compromise.\n\taliceFee := aliceClosingSigned.FeeSatoshis\n\tif aliceFee > increasedFee {\n\t\tt.Fatalf(\"new fee should be less than our fee: new=%v, \"+\n\t\t\t\"prior=%v\", aliceFee, increasedFee)\n\t}\n\tlastFeeResponder := aliceFee\n\n\t// We try negotiating a 2.1x fee, which should also be rejected.\n\tincreasedFee = btcutil.Amount(float64(preferredRespFee) * 2.1)\n\tbobSig, _, _, err = bobChan.CreateCloseProposal(\n\t\tincreasedFee, dummyDeliveryScript, aliceDeliveryScript,\n\t)\n\trequire.NoError(t, err, \"error creating close proposal\")\n\n\tparsedSig, err = lnwire.NewSigFromSignature(bobSig)\n\trequire.NoError(t, err, \"error parsing signature\")\n\tclosingSigned = lnwire.NewClosingSigned(chanID, increasedFee, parsedSig)\n\talicePeer.chanCloseMsgs <- &closeMsg{\n\t\tcid: chanID,\n\t\tmsg: closingSigned,\n\t}\n\n\t// Bob's latest proposal still won't be accepted and Alice should send over\n\t// a new ClosingSigned message. It should be the average of what Bob and\n\t// Alice each proposed last time.\n\tselect {\n\tcase outMsg := <-alicePeer.outgoingQueue:\n\t\tmsg = outMsg.msg\n\tcase <-time.After(timeout):\n\t\tt.Fatalf(\"did not receive closing signed message\")\n\t}\n\n\taliceClosingSigned, ok = msg.(*lnwire.ClosingSigned)\n\tif !ok {\n\t\tt.Fatalf(\"expected ClosingSigned message, got %T\", msg)\n\t}\n\n\t// Alice should inch towards Bob's fee, in order to compromise.\n\t// Additionally, this fee should be less than the fee Bob sent before.\n\taliceFee = aliceClosingSigned.FeeSatoshis\n\tif aliceFee < lastFeeResponder {\n\t\tt.Fatalf(\"new fee should be greater than prior: new=%v, \"+\n\t\t\t\"prior=%v\", aliceFee, lastFeeResponder)\n\t}\n\tif aliceFee > increasedFee {\n\t\tt.Fatalf(\"new fee should be less than Bob's fee: new=%v, \"+\n\t\t\t\"prior=%v\", aliceFee, increasedFee)\n\t}\n\n\t// Finally, Bob will accept the fee by echoing back the same fee that Alice\n\t// just sent over.\n\tbobSig, _, _, err = bobChan.CreateCloseProposal(\n\t\taliceFee, dummyDeliveryScript, aliceDeliveryScript,\n\t)\n\trequire.NoError(t, err, \"error creating close proposal\")\n\n\tparsedSig, err = lnwire.NewSigFromSignature(bobSig)\n\trequire.NoError(t, err, \"error parsing signature\")\n\tclosingSigned = lnwire.NewClosingSigned(chanID, aliceFee, parsedSig)\n\talicePeer.chanCloseMsgs <- &closeMsg{\n\t\tcid: chanID,\n\t\tmsg: closingSigned,\n\t}\n\n\t// Alice will now see that Bob agreed on the fee, and broadcast the coop\n\t// close transaction.\n\tselect {\n\tcase <-broadcastTxChan:\n\tcase <-time.After(timeout):\n\t\tt.Fatalf(\"closing tx not broadcast\")\n\t}\n\n\t// Alice should respond with the ClosingSigned they both agreed upon.\n\tselect {\n\tcase outMsg := <-alicePeer.outgoingQueue:\n\t\tmsg = outMsg.msg\n\tcase <-time.After(timeout):\n\t\tt.Fatalf(\"did not receive closing signed message\")\n\t}\n\tif _, ok := msg.(*lnwire.ClosingSigned); !ok {\n\t\tt.Fatalf(\"expected to receive closing signed message, got %T\", msg)\n\t}\n\n\t// Alice should be waiting on a single confirmation for the coop close tx.\n\tnotifier.ConfChan <- &chainntnfs.TxConfirmation{}\n}\n\n// TestPeerChannelClosureFeeNegotiationsInitiator tests the shutdown\n// initiator's behavior in the case where we must do several rounds of fee\n// negotiation before we agree on a fee.",
      "length": 5819,
      "tokens": 725,
      "embedding": []
    },
    {
      "slug": "func TestPeerChannelClosureFeeNegotiationsInitiator(t *testing.T) {",
      "content": "func TestPeerChannelClosureFeeNegotiationsInitiator(t *testing.T) {\n\tt.Parallel()\n\n\tnotifier := &mock.ChainNotifier{\n\t\tSpendChan: make(chan *chainntnfs.SpendDetail),\n\t\tEpochChan: make(chan *chainntnfs.BlockEpoch),\n\t\tConfChan:  make(chan *chainntnfs.TxConfirmation),\n\t}\n\tbroadcastTxChan := make(chan *wire.MsgTx)\n\n\tmockSwitch := &mockMessageSwitch{}\n\n\talicePeer, bobChan, err := createTestPeer(\n\t\tt, notifier, broadcastTxChan, noUpdate, mockSwitch,\n\t)\n\trequire.NoError(t, err, \"unable to create test channels\")\n\n\tchanID := lnwire.NewChanIDFromOutPoint(bobChan.ChannelPoint())\n\tmockLink := newMockUpdateHandler(chanID)\n\tmockSwitch.links = append(mockSwitch.links, mockLink)\n\n\t// We make the initiator send a shutdown request.\n\tupdateChan := make(chan interface{}, 1)\n\terrChan := make(chan error, 1)\n\tcloseCommand := &htlcswitch.ChanClose{\n\t\tCloseType:      contractcourt.CloseRegular,\n\t\tChanPoint:      bobChan.ChannelPoint(),\n\t\tUpdates:        updateChan,\n\t\tTargetFeePerKw: 12500,\n\t\tErr:            errChan,\n\t}\n\n\talicePeer.localCloseChanReqs <- closeCommand\n\n\t// Alice should now send a Shutdown request to Bob.\n\tvar msg lnwire.Message\n\tselect {\n\tcase outMsg := <-alicePeer.outgoingQueue:\n\t\tmsg = outMsg.msg\n\tcase <-time.After(timeout):\n\t\tt.Fatalf(\"did not receive shutdown request\")\n\t}\n\n\tshutdownMsg, ok := msg.(*lnwire.Shutdown)\n\tif !ok {\n\t\tt.Fatalf(\"expected Shutdown message, got %T\", msg)\n\t}\n\n\taliceDeliveryScript := shutdownMsg.Address\n\n\t// Bob will answer the Shutdown message with his own Shutdown.\n\tdummyDeliveryScript := genScript(t, p2wshAddress)\n\trespShutdown := lnwire.NewShutdown(chanID, dummyDeliveryScript)\n\talicePeer.chanCloseMsgs <- &closeMsg{\n\t\tcid: chanID,\n\t\tmsg: respShutdown,\n\t}\n\n\t// Alice should now respond with a ClosingSigned message with her ideal\n\t// fee rate.\n\tselect {\n\tcase outMsg := <-alicePeer.outgoingQueue:\n\t\tmsg = outMsg.msg\n\tcase <-time.After(timeout):\n\t\tt.Fatalf(\"did not receive closing signed\")\n\t}\n\tclosingSignedMsg, ok := msg.(*lnwire.ClosingSigned)\n\tif !ok {\n\t\tt.Fatalf(\"expected ClosingSigned message, got %T\", msg)\n\t}\n\n\tidealFeeRate := closingSignedMsg.FeeSatoshis\n\tlastReceivedFee := idealFeeRate\n\n\tincreasedFee := btcutil.Amount(float64(idealFeeRate) * 2.1)\n\tlastSentFee := increasedFee\n\n\tbobSig, _, _, err := bobChan.CreateCloseProposal(\n\t\tincreasedFee, dummyDeliveryScript, aliceDeliveryScript,\n\t)\n\trequire.NoError(t, err, \"error creating close proposal\")\n\n\tparsedSig, err := lnwire.NewSigFromSignature(bobSig)\n\trequire.NoError(t, err, \"unable to parse signature\")\n\n\tclosingSigned := lnwire.NewClosingSigned(chanID, increasedFee, parsedSig)\n\talicePeer.chanCloseMsgs <- &closeMsg{\n\t\tcid: chanID,\n\t\tmsg: closingSigned,\n\t}\n\n\t// It still won't be accepted, and we should get a new proposal, the\n\t// average of what we proposed, and what they proposed last time.\n\tselect {\n\tcase outMsg := <-alicePeer.outgoingQueue:\n\t\tmsg = outMsg.msg\n\tcase <-time.After(timeout):\n\t\tt.Fatalf(\"did not receive closing signed\")\n\t}\n\tclosingSignedMsg, ok = msg.(*lnwire.ClosingSigned)\n\tif !ok {\n\t\tt.Fatalf(\"expected ClosingSigned message, got %T\", msg)\n\t}\n\n\taliceFee := closingSignedMsg.FeeSatoshis\n\tif aliceFee < lastReceivedFee {\n\t\tt.Fatalf(\"new fee should be greater than prior: new=%v, old=%v\",\n\t\t\taliceFee, lastReceivedFee)\n\t}\n\tif aliceFee > lastSentFee {\n\t\tt.Fatalf(\"new fee should be less than our fee: new=%v, old=%v\",\n\t\t\taliceFee, lastSentFee)\n\t}\n\n\tlastReceivedFee = aliceFee\n\n\t// We'll try negotiating a 1.5x fee, which should also be rejected.\n\tincreasedFee = btcutil.Amount(float64(idealFeeRate) * 1.5)\n\tlastSentFee = increasedFee\n\n\tbobSig, _, _, err = bobChan.CreateCloseProposal(\n\t\tincreasedFee, dummyDeliveryScript, aliceDeliveryScript,\n\t)\n\trequire.NoError(t, err, \"error creating close proposal\")\n\n\tparsedSig, err = lnwire.NewSigFromSignature(bobSig)\n\trequire.NoError(t, err, \"error parsing signature\")\n\n\tclosingSigned = lnwire.NewClosingSigned(chanID, increasedFee, parsedSig)\n\talicePeer.chanCloseMsgs <- &closeMsg{\n\t\tcid: chanID,\n\t\tmsg: closingSigned,\n\t}\n\n\t// Alice won't accept Bob's new proposal, and Bob should receive a new\n\t// proposal which is the average of what Bob proposed and Alice proposed\n\t// last time.\n\tselect {\n\tcase outMsg := <-alicePeer.outgoingQueue:\n\t\tmsg = outMsg.msg\n\tcase <-time.After(timeout):\n\t\tt.Fatalf(\"did not receive closing signed\")\n\t}\n\tclosingSignedMsg, ok = msg.(*lnwire.ClosingSigned)\n\tif !ok {\n\t\tt.Fatalf(\"expected ClosingSigned message, got %T\", msg)\n\t}\n\n\taliceFee = closingSignedMsg.FeeSatoshis\n\tif aliceFee < lastReceivedFee {\n\t\tt.Fatalf(\"new fee should be greater than prior: new=%v, old=%v\",\n\t\t\taliceFee, lastReceivedFee)\n\t}\n\tif aliceFee > lastSentFee {\n\t\tt.Fatalf(\"new fee should be less than Bob's fee: new=%v, old=%v\",\n\t\t\taliceFee, lastSentFee)\n\t}\n\n\t// Bob will now accept their fee by sending back a ClosingSigned message\n\t// with an identical fee.\n\tbobSig, _, _, err = bobChan.CreateCloseProposal(\n\t\taliceFee, dummyDeliveryScript, aliceDeliveryScript,\n\t)\n\trequire.NoError(t, err, \"error creating close proposal\")\n\n\tparsedSig, err = lnwire.NewSigFromSignature(bobSig)\n\trequire.NoError(t, err, \"error parsing signature\")\n\tclosingSigned = lnwire.NewClosingSigned(chanID, aliceFee, parsedSig)\n\talicePeer.chanCloseMsgs <- &closeMsg{\n\t\tcid: chanID,\n\t\tmsg: closingSigned,\n\t}\n\n\t// Wait for closing tx to be broadcasted.\n\tselect {\n\tcase <-broadcastTxChan:\n\tcase <-time.After(timeout):\n\t\tt.Fatalf(\"closing tx not broadcast\")\n\t}\n\n\t// Alice should respond with the ClosingSigned they both agreed upon.\n\tselect {\n\tcase outMsg := <-alicePeer.outgoingQueue:\n\t\tmsg = outMsg.msg\n\tcase <-time.After(timeout):\n\t\tt.Fatalf(\"did not receive closing signed message\")\n\t}\n\tif _, ok := msg.(*lnwire.ClosingSigned); !ok {\n\t\tt.Fatalf(\"expected to receive closing signed message, got %T\", msg)\n\t}\n\n\t// Alice should be waiting on a single confirmation for the coop close tx.\n\tnotifier.ConfChan <- &chainntnfs.TxConfirmation{}\n}\n\n// TestChooseDeliveryScript tests that chooseDeliveryScript correctly errors\n// when upfront and user set scripts that do not match are provided, allows\n// matching values and returns appropriate values in the case where one or none\n// are set.",
      "length": 5861,
      "tokens": 689,
      "embedding": []
    },
    {
      "slug": "func TestChooseDeliveryScript(t *testing.T) {",
      "content": "func TestChooseDeliveryScript(t *testing.T) {\n\t// generate non-zero scripts for testing.\n\tscript1 := genScript(t, p2SHAddress)\n\tscript2 := genScript(t, p2wshAddress)\n\n\ttests := []struct {\n\t\tname           string\n\t\tuserScript     lnwire.DeliveryAddress\n\t\tshutdownScript lnwire.DeliveryAddress\n\t\texpectedScript lnwire.DeliveryAddress\n\t\texpectedError  error\n\t}{\n\t\t{\n\t\t\tname:           \"Neither set\",\n\t\t\tuserScript:     nil,\n\t\t\tshutdownScript: nil,\n\t\t\texpectedScript: nil,\n\t\t\texpectedError:  nil,\n\t\t},\n\t\t{\n\t\t\tname:           \"Both set and equal\",\n\t\t\tuserScript:     script1,\n\t\t\tshutdownScript: script1,\n\t\t\texpectedScript: script1,\n\t\t\texpectedError:  nil,\n\t\t},\n\t\t{\n\t\t\tname:           \"Both set and not equal\",\n\t\t\tuserScript:     script1,\n\t\t\tshutdownScript: script2,\n\t\t\texpectedScript: nil,\n\t\t\texpectedError:  chancloser.ErrUpfrontShutdownScriptMismatch,\n\t\t},\n\t\t{\n\t\t\tname:           \"Only upfront script\",\n\t\t\tuserScript:     nil,\n\t\t\tshutdownScript: script1,\n\t\t\texpectedScript: script1,\n\t\t\texpectedError:  nil,\n\t\t},\n\t\t{\n\t\t\tname:           \"Only user script\",\n\t\t\tuserScript:     script2,\n\t\t\tshutdownScript: nil,\n\t\t\texpectedScript: script2,\n\t\t\texpectedError:  nil,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tscript, err := chooseDeliveryScript(\n\t\t\t\ttest.shutdownScript, test.userScript,\n\t\t\t)\n\t\t\tif err != test.expectedError {\n\t\t\t\tt.Fatalf(\"Expected: %v, got: %v\", test.expectedError, err)\n\t\t\t}\n\n\t\t\tif !bytes.Equal(script, test.expectedScript) {\n\t\t\t\tt.Fatalf(\"Expected: %x, got: %x\", test.expectedScript, script)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestCustomShutdownScript tests that the delivery script of a shutdown\n// message can be set to a specified address. It checks that setting a close\n// script fails for channels which have an upfront shutdown script already set.",
      "length": 1689,
      "tokens": 187,
      "embedding": []
    },
    {
      "slug": "func TestCustomShutdownScript(t *testing.T) {",
      "content": "func TestCustomShutdownScript(t *testing.T) {\n\tscript := genScript(t, p2SHAddress)\n\n\t// setShutdown is a function which sets the upfront shutdown address for\n\t// the local channel.\n\tsetShutdown := func(a, b *channeldb.OpenChannel) {\n\t\ta.LocalShutdownScript = script\n\t\tb.RemoteShutdownScript = script\n\t}\n\n\ttests := []struct {\n\t\tname string\n\n\t\t// update is a function used to set values on the channel set up for the\n\t\t// test. It is used to set values for upfront shutdown addresses.\n\t\tupdate func(a, b *channeldb.OpenChannel)\n\n\t\t// userCloseScript is the address specified by the user.\n\t\tuserCloseScript lnwire.DeliveryAddress\n\n\t\t// expectedScript is the address we expect to be set on the shutdown\n\t\t// message.\n\t\texpectedScript lnwire.DeliveryAddress\n\n\t\t// expectedError is the error we expect, if any.\n\t\texpectedError error\n\t}{\n\t\t{\n\t\t\tname:            \"User set script\",\n\t\t\tupdate:          noUpdate,\n\t\t\tuserCloseScript: script,\n\t\t\texpectedScript:  script,\n\t\t},\n\t\t{\n\t\t\tname:   \"No user set script\",\n\t\t\tupdate: noUpdate,\n\t\t},\n\t\t{\n\t\t\tname:           \"Shutdown set, no user script\",\n\t\t\tupdate:         setShutdown,\n\t\t\texpectedScript: script,\n\t\t},\n\t\t{\n\t\t\tname:            \"Shutdown set, user script matches\",\n\t\t\tupdate:          setShutdown,\n\t\t\tuserCloseScript: script,\n\t\t\texpectedScript:  script,\n\t\t},\n\t\t{\n\t\t\tname:            \"Shutdown set, user script different\",\n\t\t\tupdate:          setShutdown,\n\t\t\tuserCloseScript: []byte(\"different addr\"),\n\t\t\texpectedError:   chancloser.ErrUpfrontShutdownScriptMismatch,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tnotifier := &mock.ChainNotifier{\n\t\t\t\tSpendChan: make(chan *chainntnfs.SpendDetail),\n\t\t\t\tEpochChan: make(chan *chainntnfs.BlockEpoch),\n\t\t\t\tConfChan:  make(chan *chainntnfs.TxConfirmation),\n\t\t\t}\n\t\t\tbroadcastTxChan := make(chan *wire.MsgTx)\n\n\t\t\tmockSwitch := &mockMessageSwitch{}\n\n\t\t\t// Open a channel.\n\t\t\talicePeer, bobChan, err := createTestPeer(\n\t\t\t\tt, notifier, broadcastTxChan, test.update,\n\t\t\t\tmockSwitch,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to create test channels: %v\", err)\n\t\t\t}\n\n\t\t\tchanPoint := bobChan.ChannelPoint()\n\t\t\tchanID := lnwire.NewChanIDFromOutPoint(chanPoint)\n\t\t\tmockLink := newMockUpdateHandler(chanID)\n\t\t\tmockSwitch.links = append(mockSwitch.links, mockLink)\n\n\t\t\t// Request initiator to cooperatively close the channel, with\n\t\t\t// a specified delivery address.\n\t\t\tupdateChan := make(chan interface{}, 1)\n\t\t\terrChan := make(chan error, 1)\n\t\t\tcloseCommand := htlcswitch.ChanClose{\n\t\t\t\tCloseType:      contractcourt.CloseRegular,\n\t\t\t\tChanPoint:      chanPoint,\n\t\t\t\tUpdates:        updateChan,\n\t\t\t\tTargetFeePerKw: 12500,\n\t\t\t\tDeliveryScript: test.userCloseScript,\n\t\t\t\tErr:            errChan,\n\t\t\t}\n\n\t\t\t// Send the close command for the correct channel and check that a\n\t\t\t// shutdown message is sent.\n\t\t\talicePeer.localCloseChanReqs <- &closeCommand\n\n\t\t\tvar msg lnwire.Message\n\t\t\tselect {\n\t\t\tcase outMsg := <-alicePeer.outgoingQueue:\n\t\t\t\tmsg = outMsg.msg\n\t\t\tcase <-time.After(timeout):\n\t\t\t\tt.Fatalf(\"did not receive shutdown message\")\n\t\t\tcase err := <-errChan:\n\t\t\t\t// Fail if we do not expect an error.\n\t\t\t\tif err != test.expectedError {\n\t\t\t\t\tt.Fatalf(\"error closing channel: %v\", err)\n\t\t\t\t}\n\n\t\t\t\t// Terminate the test early if have received an error, no\n\t\t\t\t// further action is expected.\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Check that we have received a shutdown message.\n\t\t\tshutdownMsg, ok := msg.(*lnwire.Shutdown)\n\t\t\tif !ok {\n\t\t\t\tt.Fatalf(\"expected shutdown message, got %T\", msg)\n\t\t\t}\n\n\t\t\t// If the test has not specified an expected address, do not check\n\t\t\t// whether the shutdown address matches. This covers the case where\n\t\t\t// we expect shutdown to a random address and cannot match it.\n\t\t\tif len(test.expectedScript) == 0 {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Check that the Shutdown message includes the expected delivery\n\t\t\t// script.\n\t\t\tif !bytes.Equal(test.expectedScript, shutdownMsg.Address) {\n\t\t\t\tt.Fatalf(\"expected delivery script: %x, got: %x\",\n\t\t\t\t\ttest.expectedScript, shutdownMsg.Address)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestStaticRemoteDowngrade tests that we downgrade our static remote feature\n// bit to optional if we have legacy channels with a peer. This ensures that\n// we can stay connected to peers that don't support the feature bit that we\n// have channels with.",
      "length": 4102,
      "tokens": 509,
      "embedding": []
    },
    {
      "slug": "func TestStaticRemoteDowngrade(t *testing.T) {",
      "content": "func TestStaticRemoteDowngrade(t *testing.T) {\n\tt.Parallel()\n\n\tvar (\n\t\t// We set the same legacy feature bits for all tests, since\n\t\t// these are not relevant to our test scenario\n\t\trawLegacy = lnwire.NewRawFeatureVector(\n\t\t\tlnwire.UpfrontShutdownScriptOptional,\n\t\t)\n\t\tlegacy = lnwire.NewFeatureVector(rawLegacy, nil)\n\n\t\tlegacyCombinedOptional = lnwire.NewRawFeatureVector(\n\t\t\tlnwire.UpfrontShutdownScriptOptional,\n\t\t\tlnwire.StaticRemoteKeyOptional,\n\t\t)\n\n\t\trawFeatureOptional = lnwire.NewRawFeatureVector(\n\t\t\tlnwire.StaticRemoteKeyOptional,\n\t\t)\n\n\t\tfeatureOptional = lnwire.NewFeatureVector(\n\t\t\trawFeatureOptional, nil,\n\t\t)\n\n\t\trawFeatureRequired = lnwire.NewRawFeatureVector(\n\t\t\tlnwire.StaticRemoteKeyRequired,\n\t\t)\n\n\t\tfeatureRequired = lnwire.NewFeatureVector(\n\t\t\trawFeatureRequired, nil,\n\t\t)\n\t)\n\n\ttests := []struct {\n\t\tname         string\n\t\tlegacy       bool\n\t\tfeatures     *lnwire.FeatureVector\n\t\texpectedInit *lnwire.Init\n\t}{\n\t\t{\n\t\t\tname:     \"no legacy channel, static optional\",\n\t\t\tlegacy:   false,\n\t\t\tfeatures: featureOptional,\n\t\t\texpectedInit: &lnwire.Init{\n\t\t\t\tGlobalFeatures: rawLegacy,\n\t\t\t\tFeatures:       rawFeatureOptional,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:     \"legacy channel, static optional\",\n\t\t\tlegacy:   true,\n\t\t\tfeatures: featureOptional,\n\t\t\texpectedInit: &lnwire.Init{\n\t\t\t\tGlobalFeatures: rawLegacy,\n\t\t\t\tFeatures:       rawFeatureOptional,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:     \"no legacy channel, static required\",\n\t\t\tlegacy:   false,\n\t\t\tfeatures: featureRequired,\n\t\t\texpectedInit: &lnwire.Init{\n\t\t\t\tGlobalFeatures: rawLegacy,\n\t\t\t\tFeatures:       rawFeatureRequired,\n\t\t\t},\n\t\t},\n\n\t\t// In this case we need to flip our required bit to optional,\n\t\t// this should also propagate to the legacy set of feature bits\n\t\t// so we have proper consistency: a bit isn't set to optional\n\t\t// in one field and required in the other.\n\t\t{\n\t\t\tname:     \"legacy channel, static required\",\n\t\t\tlegacy:   true,\n\t\t\tfeatures: featureRequired,\n\t\t\texpectedInit: &lnwire.Init{\n\t\t\t\tGlobalFeatures: legacyCombinedOptional,\n\t\t\t\tFeatures:       rawFeatureOptional,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\twriteBufferPool := pool.NewWriteBuffer(\n\t\t\t\tpool.DefaultWriteBufferGCInterval,\n\t\t\t\tpool.DefaultWriteBufferExpiryInterval,\n\t\t\t)\n\n\t\t\twritePool := pool.NewWrite(\n\t\t\t\twriteBufferPool, 1, timeout,\n\t\t\t)\n\t\t\trequire.NoError(t, writePool.Start())\n\n\t\t\tmockConn := newMockConn(t, 1)\n\n\t\t\tp := Brontide{\n\t\t\t\tcfg: Config{\n\t\t\t\t\tLegacyFeatures: legacy,\n\t\t\t\t\tFeatures:       test.features,\n\t\t\t\t\tConn:           mockConn,\n\t\t\t\t\tWritePool:      writePool,\n\t\t\t\t\tPongBuf:        make([]byte, lnwire.MaxPongBytes),\n\t\t\t\t},\n\t\t\t\tlog: peerLog,\n\t\t\t}\n\n\t\t\tvar b bytes.Buffer\n\t\t\t_, err := lnwire.WriteMessage(&b, test.expectedInit, 0)\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// Send our init message, assert that we write our expected message\n\t\t\t// and shutdown our write pool.\n\t\t\trequire.NoError(t, p.sendInitMsg(test.legacy))\n\t\t\tmockConn.assertWrite(b.Bytes())\n\t\t\trequire.NoError(t, writePool.Stop())\n\t\t})\n\t}\n}\n\n// genScript creates a script paying out to the address provided, which must\n// be a valid address.",
      "length": 2942,
      "tokens": 304,
      "embedding": []
    },
    {
      "slug": "func genScript(t *testing.T, address string) lnwire.DeliveryAddress {",
      "content": "func genScript(t *testing.T, address string) lnwire.DeliveryAddress {\n\t// Generate an address which can be used for testing.\n\tdeliveryAddr, err := btcutil.DecodeAddress(\n\t\taddress,\n\t\t&chaincfg.TestNet3Params,\n\t)\n\trequire.NoError(t, err, \"invalid delivery address\")\n\n\tscript, err := txscript.PayToAddrScript(deliveryAddr)\n\trequire.NoError(t, err, \"cannot create script\")\n\n\treturn script\n}\n\n// TestPeerCustomMessage tests custom message exchange between peers.",
      "length": 375,
      "tokens": 42,
      "embedding": []
    },
    {
      "slug": "func TestPeerCustomMessage(t *testing.T) {",
      "content": "func TestPeerCustomMessage(t *testing.T) {\n\tt.Parallel()\n\n\t// Set up node Alice.\n\tdbAlice, err := channeldb.Open(t.TempDir())\n\trequire.NoError(t, err)\n\n\taliceKey, err := btcec.NewPrivateKey()\n\trequire.NoError(t, err)\n\n\twriteBufferPool := pool.NewWriteBuffer(\n\t\tpool.DefaultWriteBufferGCInterval,\n\t\tpool.DefaultWriteBufferExpiryInterval,\n\t)\n\n\twritePool := pool.NewWrite(\n\t\twriteBufferPool, 1, timeout,\n\t)\n\trequire.NoError(t, writePool.Start())\n\n\treadBufferPool := pool.NewReadBuffer(\n\t\tpool.DefaultReadBufferGCInterval,\n\t\tpool.DefaultReadBufferExpiryInterval,\n\t)\n\n\treadPool := pool.NewRead(\n\t\treadBufferPool, 1, timeout,\n\t)\n\trequire.NoError(t, readPool.Start())\n\n\tmockConn := newMockConn(t, 1)\n\n\treceivedCustomChan := make(chan *customMsg)\n\n\tremoteKey := [33]byte{8}\n\n\tnotifier := &mock.ChainNotifier{\n\t\tSpendChan: make(chan *chainntnfs.SpendDetail),\n\t\tEpochChan: make(chan *chainntnfs.BlockEpoch),\n\t\tConfChan:  make(chan *chainntnfs.TxConfirmation),\n\t}\n\n\t// TODO(yy): change ChannelNotifier to be an interface.\n\tchannelNotifier := channelnotifier.New(dbAlice.ChannelStateDB())\n\trequire.NoError(t, channelNotifier.Start())\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, channelNotifier.Stop(),\n\t\t\t\"stop channel notifier failed\")\n\t})\n\n\talicePeer := NewBrontide(Config{\n\t\tPubKeyBytes: remoteKey,\n\t\tChannelDB:   dbAlice.ChannelStateDB(),\n\t\tAddr: &lnwire.NetAddress{\n\t\t\tIdentityKey: aliceKey.PubKey(),\n\t\t},\n\t\tPrunePersistentPeerConnection: func([33]byte) {},\n\t\tFeatures:                      lnwire.EmptyFeatureVector(),\n\t\tLegacyFeatures:                lnwire.EmptyFeatureVector(),\n\t\tWritePool:                     writePool,\n\t\tReadPool:                      readPool,\n\t\tConn:                          mockConn,\n\t\tChainNotifier:                 notifier,\n\t\tHandleCustomMessage: func(\n\t\t\tpeer [33]byte, msg *lnwire.Custom) error {\n\n\t\t\treceivedCustomChan <- &customMsg{\n\t\t\t\tpeer: peer,\n\t\t\t\tmsg:  *msg,\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t\tPongBuf:         make([]byte, lnwire.MaxPongBytes),\n\t\tChannelNotifier: channelNotifier,\n\t})\n\n\t// Set up the init sequence.\n\tgo func() {\n\t\t// Read init message.\n\t\t<-mockConn.writtenMessages\n\n\t\t// Write the init reply message.\n\t\tinitReplyMsg := lnwire.NewInitMessage(\n\t\t\tlnwire.NewRawFeatureVector(\n\t\t\t\tlnwire.DataLossProtectRequired,\n\t\t\t),\n\t\t\tlnwire.NewRawFeatureVector(),\n\t\t)\n\t\tvar b bytes.Buffer\n\t\t_, err = lnwire.WriteMessage(&b, initReplyMsg, 0)\n\t\trequire.NoError(t, err)\n\n\t\tmockConn.readMessages <- b.Bytes()\n\t}()\n\n\t// Start the peer.\n\trequire.NoError(t, alicePeer.Start())\n\n\t// Send a custom message.\n\tcustomMsg, err := lnwire.NewCustom(\n\t\tlnwire.MessageType(40000), []byte{1, 2, 3},\n\t)\n\trequire.NoError(t, err)\n\n\trequire.NoError(t, alicePeer.SendMessageLazy(false, customMsg))\n\n\t// Verify that it is passed down to the noise layer correctly.\n\twrittenMsg := <-mockConn.writtenMessages\n\trequire.Equal(t, []byte{0x9c, 0x40, 0x1, 0x2, 0x3}, writtenMsg)\n\n\t// Receive a custom message.\n\treceivedCustomMsg, err := lnwire.NewCustom(\n\t\tlnwire.MessageType(40001), []byte{4, 5, 6},\n\t)\n\trequire.NoError(t, err)\n\n\treceivedData := []byte{0x9c, 0x41, 0x4, 0x5, 0x6}\n\tmockConn.readMessages <- receivedData\n\n\t// Verify that it is propagated up to the custom message handler.\n\treceivedCustom := <-receivedCustomChan\n\trequire.Equal(t, remoteKey, receivedCustom.peer)\n\trequire.Equal(t, receivedCustomMsg, &receivedCustom.msg)\n}\n",
      "length": 3164,
      "tokens": 284,
      "embedding": []
    }
  ]
}