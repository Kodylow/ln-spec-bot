{
  "BIP": "118",
  "Layer": "Consensus (soft fork)",
  "Title": "SIGHASH_ANYPREVOUT for Taproot Scripts",
  "Author": "Christian Decker <decker.christian@gmail.com>",
  "Comments-Summary": "No comments yet.",
  "Comments-URI": "https://github.com/bitcoin/bips/wiki/Comments:BIP-0118",
  "Status": "Draft",
  "Type": "Standards Track",
  "Created": "2017-02-28",
  "License": "BSD-3-Clause",
  "Requires": "340, 341, 342",
  "sections": [
    {
      "header": "Introduction",
      "content": "### Abstract\n\nThis BIP describes a new type of public key for tapscript ([BIP\n342](bip-0342.mediawiki \"wikilink\")) transactions. It allows signatures\nfor these public keys to not commit to the exact UTXO being spent. This\nenables dynamic binding of transactions to different UTXOs, provided\nthey have compatible scripts."
    },
    {
      "header": "Copyright",
      "content": "This document is licensed under the 3-clause BSD license."
    },
    {
      "header": "Motivation",
      "content": "Off-chain protocols make use of transactions that are not yet broadcast\nto the Bitcoin network in order to renegotiate the final state that\nshould be settled on-chain. In a number of cases it is desirable to\nrespond to a given transaction being seen on-chain with a predetermined\nreaction in the form of another transaction. Often the same reaction is\ndesired for a variety of different transactions that may be seen\non-chain, but because the input signatures in the response transaction\ncommit to the exact transaction that is being reacted to, this means a\nnew signature must be created for every possible transaction one wishes\nto be able to react to.\n\nThis proposal introduces a new public key type[^1] that modifies the\nbehavior of the transaction digest algorithm used in the signature\ncreation and verification, by excluding the commitment to the previous\noutput (and, optionally, the witness script[^2] and value [^3]).\nRemoving this commitment allows dynamic rebinding of a signed\ntransaction to another previous output that requires authorisation by\nthe same key.\n\nThe dynamic rebinding is opt-in due to using a separate public key type,\nand the breadth of transactions the signature can be rebound to can be\nfurther restricted by using different keys, committing to the script\nbeing spent in the signature, using different amounts between UTXOs,\nusing different nSequence values in the spending transaction, or using\nthe codeseparator opcode to commit to the position in the script."
    },
    {
      "header": "Specification",
      "content": "This BIP modifies the behaviour of the [BIP\n342](bip-0342.mediawiki \"wikilink\") signature opcodes[^4] (`CHECKSIG`,\n`CHECKSIGVERIFY`, and `CHECKSIGADD`) for public keys that have a length\nof 33 bytes and a first byte of `0x01` or the public key which is\nprecisely the single byte vector `0x01`[^5]. These keys are termed **BIP\n118 public keys**."
    },
    {
      "header": "Rules for signature opcodes {#rules_for_signature_opcodes}",
      "content": "The [BIP 342](bip-0342.mediawiki \"wikilink\") rules for signature opcodes\nare modified by removing keys with the first byte `0x01` and length of\neither 1-byte or 33-bytes from the list of unknown public key types, and\nadding the following rule prior to the handling of unknown public key\ntypes:\n\n-   If the public key is the single byte `0x01`, or if the public key is\n33 bytes and the first byte of the public key is `0x01`, it is\nconsidered to be a BIP 118 public key:\n-   If the signature is not the empty vector, the signature is\nvalidated according to the [BIP\n341](bip-0341.mediawiki \"wikilink\") signing validation rules\nwith the public key, allowable `hash_type` values, and\ntransaction digest modified as defined below."
    },
    {
      "header": "Public key {#public_key}",
      "content": "To convert the 1-byte BIP 118 public key for use with [BIP\n340](bip-0340.mediawiki \"wikilink\"), use the 32-byte taproot internal\nkey, `p`, as defined in [BIP 341](bip-0341.mediawiki \"wikilink\").\n\nTo convert a 33-byte BIP 118 public key for use with [BIP\n340](bip-0340.mediawiki \"wikilink\"), remove the `0x01` prefix and use\nthe remaining 32 bytes."
    },
    {
      "header": "Signature message {#signature_message}",
      "content": "We define the functions *Msg118(hash_type)* and *Ext118(hash_type)*\nwhich compute the message being signed as a byte array.\n\nThe parameter *hash_type* is an 8-bit unsigned value, reusing values\ndefined in [BIP 341](bip-0341.mediawiki \"wikilink\"), with the addition\nthat the values `0x41`, `0x42`, `0x43`, `0xc1`, `0xc2`, and `0xc3` are\nalso valid for BIP 118 public keys.\n\nWe define the following constants using bits 6 and 7 of `hash_type`:\n\n-   `SIGHASH_ANYPREVOUT = 0x40`\n-   `SIGHASH_ANYPREVOUTANYSCRIPT = 0xc0`\n\nThe following restrictions apply and cause validation failure if\nviolated:\n\n-   Using any undefined *hash_type* (not *0x00*, *0x01*, *0x02*, *0x03*,\n*0x41*, *0x42*, *0x43*, *0x81*, *0x82*, *0x83*, *0xc1*, *0xc2*, or\n*0xc3*).\n-   Using `SIGHASH_SINGLE` without a \\\"corresponding output\\\" (an output\nwith the same index as the input being verified).\n\nIf these restrictions are not violated, *Msg118(hash_type)* evaluates as\nfollows.\n\nIf *hash_type & 0x40 == 0*, then *Msg118(hash_type) = SigMsg(hash_type,\n1)*, where *SigMsg* is as defined in [BIP\n341](bip-0341.mediawiki \"wikilink\").\n\nIf *hash_type & 0x40 != 0*, then *Msg118(hash_type)* is the\nconcatenation of the following data, in order (with byte size of each\nitem listed in parentheses). Numerical values in 2, 4, or 8-byte items\nare encoded in little-endian.\n\n-   Control:\n-   *hash_type* (1).\n-   Transaction data:\n-   *nVersion* (4): the *nVersion* of the transaction.\n-   *nLockTime* (4): the *nLockTime* of the transaction.\n-   If *hash_type & 3* does not equal `SIGHASH_NONE` or\n`SIGHASH_SINGLE`:\n-   *sha_outputs* (32): the SHA256 of the serialization of all\noutputs in `CTxOut` format.\n-   Data about this input:\n-   *spend_type* (1): equal to 2 if no annex is present, or 3\notherwise (the original witness stack has two or more witness\nelements, and the first byte of the last element is *0x50*)\n-   If *hash_type & 0xc0* is `SIGHASH_ANYPREVOUT`:\n-   *amount* (8): value of the previous output spent by this\ninput.\n-   *scriptPubKey* (35): *scriptPubKey* of the previous output\nspent by this input, serialized as script inside `CTxOut`.\nIts size is always 35 bytes.\n-   *nSequence* (4): *nSequence* of this input.\n-   If an annex is present (the lowest bit of *spend_type* is set):\n-   *sha_annex* (32): the SHA256 of *(compact_size(size of\nannex) \\|\\| annex)*, where *annex* includes the mandatory\n*0x50* prefix.\n-   Data about this output:\n-   If *hash_type & 3* equals `SIGHASH_SINGLE`:\n-   *sha_single_output* (32): the SHA256 of the corresponding\noutput in `CTxOut` format.\n\nSimilarly, *Ext118(hash_type)* evaluates to the concatenation of the\nfollowing data, in order:\n\n-   Extension:\n-   If *hash_type & 0xc0* is not `SIGHASH_ANYPREVOUTANYSCRIPT`:\n-   *tapleaf_hash* (32): the tapleaf hash as defined in [BIP\n341](bip-0341.mediawiki \"wikilink\")\n-   *key_version* (1): a constant value *0x01* representing that\nthis is a signature for a BIP 118 public key.\n-   *codesep_pos* (4): the opcode position of the last executed\n`OP_CODESEPARATOR` before the currently executed signature\nopcode, with the value in little endian (or *0xffffffff* if none\nexecuted). The first opcode in a script has a position of 0. A\nmulti-byte push opcode is counted as one opcode, regardless of\nthe size of data being pushed.\n\nTo verify a signature *sig* for a BIP 118 public key *p*:\n\n-   If the *sig* is 64 bytes long, return *Verify(p,\nhash~TapSigHash~(0x00 \\|\\| Msg118(0x00) \\|\\| Ext118(0x00)), sig)*\n-   If the *sig* is 65 bytes long, return *sig\\[64\\] \u2260 0x00 and\nVerify(p, hash~TapSighash~(0x00 \\|\\| Msg118(sig\\[64\\]) \\|\\|\nExt118(sig\\[64\\])), sig\\[0:64\\])*.\n-   Otherwise, fail.\n\n*Verify* is as defined in [BIP 340](bip-0340.mediawiki \"wikilink\").\n\nThe key differences from [BIP 342](bip-0342.mediawiki \"wikilink\")\nsignature verification are:\n\n-   In all cases, `key_version` is set to the constant value `0x01`\ninstead of `0x00`.[^6]\n-   If `SIGHASH_ANYPREVOUT` is set, the digest is calculated as if\n`SIGHASH_ANYONECANPAY` was set, except `outpoint` is not included in\nthe digest.\n-   If `SIGHASH_ANYPREVOUTANYSCRIPT` is set, the digest is calculated as\nif `SIGHASH_ANYONECANPAY` was set, except `outpoint`, `amount`,\n`scriptPubKey` and `tapleaf_hash` are not included in the digest."
    },
    {
      "header": "Security",
      "content": "#### Signature replay {#signature_replay}\n\nBy design, `SIGHASH_ANYPREVOUT` and `SIGHASH_ANYPREVOUTANYSCRIPT`\nintroduce additional potential for signature replay (that is they allow\nthe same signature to be reused on a different transaction) when\ncompared to `SIGHASH_ALL` and `SIGHASH_ANYONECANPAY` signatures.\n\nBoth `SIGHASH_ALL` and `SIGHASH_ANYONECANPAY` signatures prevent\nsignature replay by committing to one or more inputs, so replay of the\nsignature is only possible if the same input can be spent multiple\ntimes, which is not possible on the Bitcoin blockchain (due to\nenforcement of [BIP 30](bip-0030.mediawiki \"wikilink\")). With\n`SIGHASH_ANYPREVOUT` signature replay is possible for different UTXOs\nwith the same `scriptPubKey` and the same value, while with\n`SIGHASH_ANYPREVOUTANYSCRIPT` signature replay is possible for any UTXOs\nthat reuse the same BIP 118 public key in one of their potential\nscripts.\n\nAs a consequence, implementors MUST ensure that BIP 118 public keys are\nonly reused when signature replay cannot cause loss of funds (eg due to\nother features of the protocol or other constraints on the transaction),\nor when such a loss of funds is acceptable."
    },
    {
      "header": "Malleability",
      "content": "Use of `SIGHASH_ANYPREVOUT` or `SIGHASH_ANYPREVOUTANYSCRIPT` may\nintroduce additional malleability vectors.\n\nIn particular, a transaction authenticated using only ANYPREVOUT\nsignatures is malleable to anyone able to provide an alternate input\nsatisfied by the signature \\-- an input changed in this way would\nproduce a new, valid transaction paying the same recipient, but with a\ndifferent txid. Depending on the changes to the inputs, this might\nconflict with the original transaction (if some inputs remain shared) or\nmight result in a double-payment to the recipient (if they do not).\n\nFurther, for a chain of transactions using the same `scriptPubKey` and\nvalue, and only authenticated via ANYPREVOUT signatures (as envisioned\nin eltoo for failure cases), it may be possible for any third party to\nmalleate the transactions (and their txids) without having access to any\nof the private keys, particularly by omitting intermediate transactions.\n\nThis form of malleation can be dealt with by the child transactions also\nusing ANYPREVOUT signatures \\-- when a parent transaction is malleated,\nits children can be adjusted to reference the new txid as the input and\nthe ANYPREVOUT signatures remain valid.\n\nHowever child transactions that are authorised by a `SIGHASH_ALL` or\n`SIGHASH_ANYONECANPAY` signature will need new signatures if their\ninputs are malleated in this way. This risk may be mitigated somewhat by\nusing [BIP 68](bip-0068.mediawiki \"wikilink\")/[BIP\n112](bip-0112.mediawiki \"wikilink\") relative time locks before spending\na UTXO that had been authorised via an ANYPREVOUT signature with\n`SIGHASH_ALL` or `SIGHASH_ANYONECANPAY`: a relative timelock can ensure\nthat the inputs have enough confirmations that they can only be replaced\nin the event of a large block reorg. Note that this approach has\ndrawbacks: relative timelocks prevent fee-bumping via\nchild-pays-for-parent, and have the obvious drawback of making the funds\ntemporarily unusable until the timelock expires."
    },
    {
      "header": "Privacy considerations {#privacy_considerations}",
      "content": "It is expected that ANYPREVOUT signatures will only be rarely used in\npractice. Protocol and wallet designers should aim to have their\ntransactions use Taproot key path spends whenever possible, both for\nefficiency reasons due to the lower transaction weight, but also for\nprivacy reasons to avoid third parties being able to distinguish their\ntransactions from those of other protocols.\n\nTransactions that do use ANYPREVOUT signatures will therefore reveal\ninformation about the transaction, potentially including that\ncooperation was impossible, or what protocol or software was used (due\nto the details of the script).\n\nIn order to maximise privacy, it is therefore recommended that protocol\ndesigners only use BIP 118 public keys in scripts that will be spent\nusing at least one ANYPREVOUT signature, and either use key path spends\nor alternate scripts in the taproot merkle tree for any spends that can\nbe authorised without ANYPREVOUT signatures. Following this\nrecommendation may require additional script branches, which may mean\ndisregarding this recommendation may result in a better tradeoff between\ncost and privacy in some circumstances."
    },
    {
      "header": "Rationale",
      "content": "```{=html}\n<references />\n```"
    },
    {
      "header": "Deployment",
      "content": "TODO\n\nThis may be deployed as a soft-fork either concurrent with, or\nsubsequent to the deployment of [BIP\n340](bip-0340.mediawiki \"wikilink\"), [BIP\n341](bip-0341.mediawiki \"wikilink\") and [BIP\n342](bip-0342.mediawiki \"wikilink\")."
    },
    {
      "header": "Backwards compatibility {#backwards_compatibility}",
      "content": "As a soft fork, older software will continue to operate without\nmodification. Nodes that have not upgraded to support [BIP\n341](bip-0341.mediawiki \"wikilink\") will see all taproot witness\nprograms as anyone-can-spend scripts, and nodes that have upgraded to\nsupport [BIP 341](bip-0341.mediawiki \"wikilink\") and [BIP\n342](bip-0342.mediawiki \"wikilink\") but not BIP 118 will simply treat\nany non-empty signature against a BIP 118 public key as valid. As such,\nnodes are strongly encourage to upgrade in order to fully validate\nsignatures for the new public key type.\n\nNon-upgraded wallets can receive and send bitcoin from non-upgraded and\nupgraded wallets using SegWit version 0 programs, traditional\npay-to-pubkey-hash, etc. Depending on the implementation, non-upgraded\nwallets may be able to send to SegWit version 1 programs if they support\nsending to [BIP350](bip-0350.mediawiki \"wikilink\") Bech32m addresses and\ndo not prevent the transaction from being broadcast due to considering\nthe outputs non-standard."
    },
    {
      "header": "Revisions",
      "content": "Apart from being based on Taproot rather than SegWit v0, the main\ndifferences to prior revisions of this BIP are:\n\n-   The sighash flag has been renamed from \\\"NOINPUT\\\" to \\\"ANYPREVOUT\\\"\nto reflect that while any prevout may potentially be used with the\nsignature, some aspects of the input are still committed to, namely\nthe input nSequence value, and (optionally) the spending conditions\nand amount.\n-   Previously NOINPUT would have worked for direct public key spends\n(assuming deployment was fleshed out in a way similar to BIP 141\nP2WPKH and P2WSH), however this proposal only applies to signatures\nvia tapscript, and not direct key path spends. This means that\naddresses must opt-in to the ability to be spent by a\n`SIGHASH_ANYPREVOUT` or `SIGHASH_ANYPREVOUTANYSCRIPT` signature by\nincluding an appropriate tapscript path when the address is created.\n-   NOINPUT signatures do not commit to the output\\'s spending\nconditions either via `scriptPubKey` or the redeem/witness script.\nThis behaviour is preserved when `SIGHASH_ANYPREVOUTANYSCRIPT` is\nused, but when `SIGHASH_ANYPREVOUT` is used, the signature now\ncommits to `scriptPubKey` and the tapscript.\n-   NOINPUT signatures did commit to the input\\'s amount. This behaviour\nis preserved when `SIGHASH_ANYPREVOUT` is used, but not when\n`SIGHASH_ANYPREVOUTANYSCRIPT` is used.\n-   `OP_CODESEPARATOR` in script will affect both `SIGHASH_ANYPREVOUT`\nand `SIGHASH_ANYPREVOUTANYSCRIPT` signatures, whereas it would not\nhave in the previous draft."
    },
    {
      "header": "Acknowledgements",
      "content": "The `SIGHASH_NOINPUT` flag was first proposed by Joseph Poon in\n[February\n2016](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-February/012460.html),\nafter being mentioned in the original [Lightning\npaper](http://lightning.network/lightning-network-paper.pdf) by Joseph\nPoon and Thaddeus Dryja. This document is the result of discussions with\nmany people and had direct input from Greg Maxwell, Jonas Nick, Pieter\nWuille and others.\n\n[^1]: **Why a new public key type?** New public key types for tapscript\ncan be introduced in a soft fork by specifying new rules for\n*unknown public key types* as specified in [BIP\n342](bip-0342.mediawiki \"wikilink\"), as this only requires adding\nrestrictions to the pre-existing signature opcodes. Possible\nalternative approaches would be to define new script opcodes, to use\na different taproot leaf version, or to use a different set of\nSegWit outputs than those specified by [BIP\n341](bip-0341.mediawiki \"wikilink\"); however all of these approaches\nare more complicated, and are better reserved for other upgrades\nwhere the additional flexibility is actually needed. In this case,\nwe specify a new transaction digest, but retain the same elliptic\ncurve and signature algorithm (ie, secp256k1 and [BIP\n340](bip-0340.mediawiki \"wikilink\")).\n\n[^2]: **Why (and why not) commit to the witness script?** The\n[eltoo](https://blockstream.com/eltoo.pdf) paper provides an example\nof why committing to the witness script is not always appropriate.\nIt uses script and the transaction `nLockTime` to make signatures\nasymmetric, so that a transaction with an earlier signature can be\nspent by a transaction with a later signature, but a transaction\nwith a later signature cannot be spent by a transaction with an\nearlier signature. As a result, a single signature for a third, even\nlater transaction must be able to spend both the prior transactions,\neven though they have a different tapscript. On the other hand,\nthese cases also provide a good reason to have the option to commit\nto the script: because each transaction has a new script, committing\nto the script allows you to produce a signature that applies to\nprecisely one of these transactions. In the eltoo case, this allows\nyou to have a signature for an update transaction that can be\napplied to any prior update, and a signature for a settlement\ntransaction that applies only to the corresponding update\ntransaction, while using the same key for both, which in turn allows\nfor a more compact script.\n\n[^3]: **Why (and why not) commit to the input value?** Committing to the\ninput value may provide additional safety that a signature can\\'t be\nmaliciously reused to claim funds that the signer does not intend to\nspend, so by default it seems sensible to commit to it. However,\ndoing so prevents being able to use a single signature to\nconsolidate a group of UTXOs with the same spending condition into a\nsingle UTXO which may be useful for some protocols, such as the\nproposal for [layered commitments with\neltoo](https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-January/002448.html).\n\n[^4]: **What about key path spends?** This proposal only supports\nANYPREVOUT signatures via script path spends, and does not support\nANYPREVOUT signatures for key path spends. This is for two reasons:\nfirst, not supporting key path spends allows this proposal to be\nindependent of the core changes included in [BIP\n341](bip-0341.mediawiki \"wikilink\") and [BIP\n342](bip-0342.mediawiki \"wikilink\"); second, it allows addresses to\nopt-in or opt-out of ANYPREVOUT support while remaining\nindistinguishable prior to being spent.\n\n[^5]: **Use of 0x01 public key type** Because `OP_0` leaves an empty\nvector on the stack it would not satisfy [BIP\n342](bip-0342.mediawiki \"wikilink\")\\'s rules for unknown public key\ntypes. As such, it is convenient to use one of `OP_1..OP_16` or\n`OP_1NEGATE` as a way to reference the taproot internal key. To keep\nthings as simple as possible, we use the first of these, and add the\nsame byte as a prefix to allow ANYPREVOUT signatures for explicitly\nspecified keys.\n\n[^6]: **Why change key_version?** Changing `key_version` ensures that if\nthe same private key is used to generate both a [BIP\n342](bip-0342.mediawiki \"wikilink\") key and a BIP 118 public key,\nthat a signature for the [BIP 342](bip-0342.mediawiki \"wikilink\")\nkey is not also valid for the BIP 118 public key (and vice-versa)."
    }
  ]
}