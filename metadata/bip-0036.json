{
  "BIP": "36",
  "Layer": "Peer Services",
  "Title": "Custom Services",
  "Author": "Stefan Thomas <justmoon@members.fsf.org>",
  "Comments-Summary": "No comments yet.",
  "Comments-URI": "https://github.com/bitcoin/bips/wiki/Comments:BIP-0036",
  "Status": "Rejected",
  "Type": "Standards Track",
  "Created": "2012-08-03",
  "License": "PD",
  "sections": [
    {
      "header": "Abstract",
      "content": "This BIP adds new fields to the `version` message which clients can use\nto announce custom services without polluting the limited 64-bit\n`services` field. It also makes some non-binding recommendations\nregarding the implementation of custom services."
    },
    {
      "header": "Motivation",
      "content": "We would like to encourage experimentation with custom services that\nextend the Bitcoin protocol with useful functionality. Examples include\nDistributed Hash Tables (DHT), distributed pools, lightweight client\nsupport protocols, directed message routing and support for custom\ntransports. However, without a general framework for protocol\nextensions, these custom services are likely to collide in various ways.\nThis BIP provides such a framework."
    },
    {
      "header": "Specification",
      "content": "Two new fields are added to the `version` command, after `extra_height`:\n\nField Size   Description     Data type                                                              Comments\n------------ --------------- ---------------------------------------------------------------------- -----------------------------\n1+           service_count   [var_int](Protocol_specification#Variable_length_integer \"wikilink\")   Number of extra services\n?            service_list    service\\[\\]                                                            List of service definitions\n\nThe service definitions `service[]` are given in the following format:\n\nField Size   Description       Data type                                       Comments\n------------ ----------------- ----------------------------------------------- ---------------------------------------------------\n?            service_name      [var_str](#Variable_length_string \"wikilink\")   Unique service identifier\n4            service_version   uint32_t                                        Identifies service version being used by the node\n?            service_data      [var_str](#Variable_length_string \"wikilink\")   Additional service-specific data\n\nA node MUST NOT announce two services with the same `service_name`. If a\nremote node sends such a `version` message the client MAY disconnect.\n\nThe `service_version` is service-specific and can be any integer. Higher\nversions SHOULD be higher integers. When a service is standardized, it\nis assigned a `NODE_*` constant for use with the `services` field and\nfuture iterations of the protocol depend on the Bitcoin protocol\nversion. Both the `NODE_*` flag and the custom service entry MAY be\nprovided for the duration of a transitional period.\n\nServices SHOULD pass an empty string (0x00) as `service_data` and use a\ncustom handshake to initialize their protocol, exchange information\nabout capabilities etc. Note that to become a standardized service, a\nservice MUST NOT rely on `service_data` since there is no corresponding\nmechanism for the standard services defined in the `services` field.\n\nHowever, services MAY use `service_data` if they do not intend to become\nstandard services and need a simple way to transmit a small amount of\ninitialization data. For example, a node offering a custom transport\nlike UDP or WebSocket, may choose to announce this as a service and\ninclude the port number in `service_data`. The format for `service_data`\nis service-specific and may be any binary or ASCII data. For ease of\ndebugging, a human-readable (ASCII) format is generally recommended."
    },
    {
      "header": "Service identifier {#service_identifier}",
      "content": "Each service SHOULD choose a new identifier that is not used by any\nother service. To register a new identifier, add it to the [Service\nidentifiers](Service_identifiers \"wikilink\") wiki page along with the\nname of the maintainer and a way to contact them. Please do not register\nidentifiers unless you are actually using them.\n\nService identifiers that are reserved or used by an accepted BIP MUST\nNOT be used except in the way specified by that BIP.\n\nService identifiers MUST be between five (5) and eleven (11) characters\nlong. Service identifiers MUST use only ASCII characters, excluding: /\n\\* \\_ :\n\nValid examples:\n\n-   `MySampleSvc`\n-   `smartserv`\n-   `P-Pool`\n\nValid, but discouraged examples:\n\n-   `MySVC 1.0` (use `service_version` to differentiate versions)\n-   `@@---.` (identifiers should be pronounceable)\n-   `lightweight` (avoid too generic names)\n\nInvalid examples:\n\n-   `Pppc` (too short)\n-   `SuperService` (too long)\n-   `Cool_Svc` (invalid character)"
    },
    {
      "header": "Optional: Custom commands {#optional_custom_commands}",
      "content": "Bitcoin command names are limited to 12 characters. That doesn\\'t leave\na lot of space for both the service identifier and the service command.\nTherefore we recommend that all service commands SHOULD be represented\nby a single \\\"command\\\" on the Bitcoin network. This command SHOULD\nconsist of the exact service identifier to avoid collisions with other\nservices, prefixed by an underscore to avoid collisions with current or\nfuture Bitcoin protocol messages. For example: `_MySampleSvc`\n\nThe service-specific command name SHOULD then be specified in an extra\nheader in the payload:\n\nField Size   Description   Data type    Comments\n------------ ------------- ------------ ---------------------------------------------------------------------------------------------------------\n12           subcommand    char\\[12\\]   ASCII string identifying the service command, NULL padded (non-NULL padding results in packet rejected)\n?            subpayload    uchar\\[\\]    The actual data\n\nThe length of `subpayload` is derived from the length of the total\npayload minus twelve (12) bytes for the `subcommand`. Implementations\nMUST NOT rely on this format to be used by unknown services. Clients\nSHOULD ignore any services or subcommands they don\\'t explicitly\nunderstand.\n\nThe recommended way to refer to messages following this format in\ndocumentation is by the service identifier, followed by a colon,\nfollowed by the subcommand. For example, the subcommand `search` for the\n`MySampleSvc` service would be referred to as: `MySampleSvc:search`\n\nFull hexdump of an example `MySampleSvc:search` message:\n\n0000   F9 BE B4 D9 5F 4D 79 53  61 6D 70 6C 65 53 76 63   ...._MySampleSvc\n0010   14 00 00 00 73 D5 56 77  73 65 61 72 63 68 00 00   ....s.Vwsearch..\n0020   00 00 00 00 12 34 56 78  9A BC DE F0               .....4Vx....\n\nMessage header:\nF9 BE B4 D9                                                                   - Main network magic bytes\n5F 4D 79 53 61 6D 70 6C 65 53 76 63                                           - \"_MySampleSvc\" command\n14 00 00 00                                                                   - Payload is 20 bytes long\n(includes 12 bytes for subcommand)\n73 D5 56 77                                                                   - Checksum\n\nService header:\n73 65 61 72 63 68 00 00 00 00 00 00                                           - \"search\" subcommand\n\nSearch message:\n12 34 56 78 9A BC DE F0                                                       - Payload"
    },
    {
      "header": "Standardization",
      "content": "Custom services may become standard parts of the protocol. Services\nwhich wish to become part of the Bitcoin protocol MUST fulfill the\nfollowing criteria:\n\n-   MUST NOT use `service_data`; Standard services have no corresponding\nfield\n-   MUST use a peer discovery mechanism which specifies one bit per\nnode, same as the `services` field in `addr` messages\n-   MUST NOT use any subcommands that conflict with current or planned\nBitcoin protocol commands\n\nThe standardization process will usually take place as follows:\n\n1.  The service is implemented and tested.\n2.  Once the API is known to be relatively stable it is formalized and\nsubmitted as a BIP.\n3.  Once the BIP is accepted, the service is assigned a `NODE_*`\nconstant and the transitional period starts:\n-   Clients MUST understand both the announcement of the service via\nthe `services` field and via `service_list` and include both\nmethods in their own `version` message.\n-   Clients MUST accept both the wrapped form messages like\n`MySampleSvc:search` as well as the corresponding non-namespaced\nmessages like `search`. Clients MUST only send wrapped messages.\n-   During the transitional period the API of the service MUST NOT\nchange.\n4.  After the transitional period:\n-   Clients MUST only announce the service via the `services` field.\n-   Clients MUST only send unwrapped messages.\n5.  Future changes to the service API now require a BIP and an increase\nin the Bitcoin protocol version.\n\nThis process of adding a service to the Bitcoin protocol should only be\nundertaken for services where there is a strong rationale for doing so.\nServices MAY also be standardized as custom services via a BIP while\nmaintaining the custom service format."
    },
    {
      "header": "Rationale",
      "content": "This BIP aims to fulfill the following goals:\n\n-   Minimize the risk of namespace collisions, ambiguities or other\nissues arising from conflicting custom services\n-   Provide an easy upgrade path for custom services to become\nstandardized services with their own `NODE_*` flag\n-   Place minimum restrictions on custom service authors\n-   Allow custom services to be created with minimum effort\n-   Allow clients to support multiple/many custom services at once\n\nTo achieve these goals this BIP adds two new fields to the `version`\nmessage. It would have been possible to avoid changes to `version` by\nadding a new message instead. However, it makes sense to keep both types\nof service announcements in the same message so that the life cycle of\nstandardized services and custom services remains exactly the same. This\nalso simplifies detecting a service which is in the transition from a\ncustom to a standardized service (and being announced using both\nmethods.)\n\nFinally, this BIP defines both explicitly and implicitly some useful\ncommon nomenclature that can be used when discussing custom services,\ne.g. \\\"subcommand\\\", \\\"subpayload\\\", \\\"service identifier\\\" and the\ncolon format for referring to subcommands."
    },
    {
      "header": "Copyright",
      "content": "This document is placed in the public domain."
    }
  ]
}