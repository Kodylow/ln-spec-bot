{
  "BIP": "324",
  "Layer": "Peer Services",
  "Title": "Version 2 P2P Encrypted Transport Protocol",
  "Author": "Dhruv Mehta <dhruv@bip324.com>",
  "Comments-URI": "https://github.com/bitcoin/bips/wiki/Comments:BIP-0324",
  "Status": "Draft",
  "Type": "Standards Track",
  "Created": "2019-03-08",
  "License": "BSD-3-Clause",
  "Replaces": "151",
  "sections": [
    {
      "header": "Introduction",
      "content": "### Abstract\n\nThis document proposes a new Bitcoin P2P transport protocol, which\nfeatures opportunistic encryption, a mild bandwidth reduction, and the\nability to negotiate upgrades before exchanging application messages."
    },
    {
      "header": "Copyright",
      "content": "This document is licensed under the 3-clause BSD license."
    },
    {
      "header": "Motivation",
      "content": "Bitcoin is a permissionless network whose purpose is to reach consensus\nover public data. Since all data relayed in the Bitcoin P2P network is\ninherently public, and the protocol lacks a notion of cryptographic\nidentities, peers talk to each other over unencrypted and\nunauthenticated connections. Nevertheless, this plaintext nature of the\ncurrent P2P protocol (referred to as v1 in this document) has severe\ndrawbacks in the presence of attackers:\n\n-   While the relayed data itself is public in nature, the associated\nmetadata may reveal private information and hamper privacy of users.\nFor example, a global passive attacker eavesdropping on all Bitcoin\nP2P connections can trivially identify the source and timing of a\ntransaction.\n-   Since connections are unauthenticated, they can be tampered with at\na low cost and often even with a low risk of detection. For example,\nan attacker can alter specific bytes of a connection (such as node\nflags) on-the-fly without the need to keep any state.\n-   The protocol is self-revealing. For example, deep packet inspection\ncan identify a P2P connection trivially because connections start\nwith a fixed sequence of magic bytes. The ability to detect\nconnections enables censorship and facilitates the aforementioned\nattacks as well as other attacks which require the attacker to\ncontrol the connections of victims, e.g., eclipse attacks targeted\nat miners.\n\nThis proposal for a new P2P protocol version (v2) aims to improve upon\nthis by raising the costs for performing these attacks substantially,\nprimarily through the use of unauthenticated, opportunistic transport\nencryption. In addition, the bytestream on the wire is made pseudorandom\n(i.e., indistinguishable from uniformly random bytes) to a passive\neavesdropper.\n\n-   Encryption, even when it is unauthenticated and only used when both\nendpoints support v2, impedes eavesdropping by forcing the attacker\nto become active: either by performing a persistent\nman-in-the-middle (MitM) attack, by downgrading connections to v1,\nor by spinning up their own nodes and getting honest nodes to make\nconnections to them. Active attacks at scale are more resource\nintensive in general, but in case of manual, deliberate connections\n(as opposed to automatic, random ones) they are also in principle\ndetectable: even very basic checks, e.g., operators manually\ncomparing protocol versions and session IDs (as supported by the\nproposed protocol), will expose the attacker.\n-   Tampering, while already an inherently active attack, is costlier if\nthe attacker is forced to maintain the state necessary for a full\nMitM interception.\n-   A pseudorandom bytestream excludes identification techniques based\non pattern matching, and makes it easier to shape the bytestream in\norder to mimic other protocols used on the Internet. This raises the\ncost of a connection censoring firewall, forcing them to either\nresort to a full MitM attack, or operate on a more obvious allowlist\nbasis, rather than a blocklist basis.\n\n**Why encrypt without authentication?**\n\nAs we have argued above, unauthenticated encryption[^1] (one in each\ndirection) using HKDF-SHA256."
    },
    {
      "header": "\\*\\* Send their 16-byte garbage terminator[^2] followed by a **garbage",
      "content": "authentication packet**[^3], an **encrypted packet** (see further) with\narbitrary **contents**, and **associated data** equal to the garbage."
    },
    {
      "header": "\\*\\* Receive up to 4111 bytes, stopping when encountering the garbage",
      "content": "terminator."
    },
    {
      "header": "\\*\\* Receive an encrypted packet, verify that it decrypts correctly",
      "content": "with associated data set to the garbage received, and then ignore its\ncontents."
    },
    {
      "header": "\\* At this point, both parties have the same keys, and all further",
      "content": "communication proceeds in the form of encrypted packets. Packets have an\n**ignore bit**, which makes them **decoy packets** if set. Decoy packets\nare to be ignored by the receiver apart from verifying they decrypt\ncorrectly. Either peer may send such decoy packets at any point after\nthis. These form the primary shapability mechanism in the protocol. How\nand when to use them is out of scope for this document.\n\n1.  The **Version negotiation phase**, where parties negotiate what\ntransport version they will use, as well as data defined by that\nversion.[^4]\n-   The responder:\n-   Sends a **version packet** with empty content, to indicate\nsupport for the v2 P2P protocol proposed by this document.\nAny other value for content is reserved for future versions.\n-   The initiator:\n-   Receives a packet, ignores its contents. The idea is that\nfeatures added by future versions get negotiated based on\nwhat is supported by both parties. Since there is just one\nversion so far, the contents here can simply be ignored. But\nin the future, receiving a non-empty contents here may\ntrigger other behavior; we defer specifying the encoding for\nsuch version content until there is a need for it.[^5]\n-   Sends a **version packet** with empty content as well, to\nindicate support for the v2 P2P protocol.\n-   The responder:\n-   Receives a packet, ignores its contents.\n2.  The **Application phase**, where the packets exchanged have contents\nto be interpreted as application data.\n-   Whenever either peer has a message to send, it sends a packet\nwith that application message as **contents**.\n\nIn order to provide a means of avoiding the recognizable pattern of\nfirst messages being at least 64 bytes, a future backwards-compatible\nupgrade to this protocol may allow both peers to send their public key +\ngarbage + garbage terminator in multiple rounds, slicing those bytes up\ninto messages arbitrarily, as long as progress is guaranteed.[^6]\n\nNote that the version negotiation phase does not need to wait for the\nkey exchange phase to complete; version packets can be sent immediately\nafter sending the garbage authentication packet. So the first two phases\ntogether, jointly called **the handshake**, comprise just 1.5\nroundtrips:\n\n-   the initiator sends public key + garbage\n-   the responder sends public key + garbage + garbage terminator +\ngarbage authentication packet + version packet\n-   the initiator sends garbage terminator + garbage authentication\npacket + version packet\n\n**Packet encryption overview**\n\nAll data on the wire after the garbage terminators takes the form of\nencrypted packets. Every packet encodes an encrypted variable-length\nbyte array, called the **contents**, as well as an **ignore bit** as\nmentioned before. The total size of a packet is 20 bytes plus the length\nof its contents.\n\nEach packet consists of:\n\n-   A 3-byte encrypted **length** field, encoding the length of the\n**contents** (between *0* and *2^24^-1*[^7], inclusive).\n-   An authenticated encryption of the **plaintext**, which consists of:\n-   A 1-byte **header** which consists of transport layer protocol\nflags. Currently only the highest bit is defined as the **ignore\nbit**. The other bits are ignored, but this may change in future\nversions[^8].\n-   The variable-length **contents**.\n\nThe encryption of the plaintext uses\n**[ChaCha20Poly1305](https://en.wikipedia.org/wiki/ChaCha20-Poly1305)**[^9],\nan [authenticated encryption with associated\ndata](https://en.wikipedia.org/wiki/Authenticated_encryption) (AEAD)\ncipher specified in [RFC\n8439](https://datatracker.ietf.org/doc/html/rfc8439). Every packet\\'s\nplaintext is treated as a separate AEAD message, with a different nonce\nfor each.\n\nThe length must be dealt with specially, as it is needed to determine\npacket boundaries before the whole packet is received and authenticated.\nAs we want a stream that is pseudorandom to a passive attacker, it still\nneeds encryption. We use unauthenticated[^10] **ChaCha20** encryption\nfor this, with an independent key. Note that the plaintext length is\nstill implicitly authenticated by the encryption of the plaintext, but\nthis can only be verified after receiving the whole packet. This design\nis inspired by that of the ChaCha20Poly1305 cipher suite in\n[OpenSSH](http://bxr.su/OpenBSD/usr.bin/ssh/PROTOCOL.chacha20poly1305).[^11]\nBecause only fixed-length chunks (3-byte length fields) are encrypted,\nwe do not need to treat all length chunks as separate messages. Instead,\na single cipher (with the same nonce) is used for multiple consecutive\nlength fields. This avoids wasting 61 pseudorandom bytes per packet, and\nmakes the cost of having a separate cipher for length encryption\nnegligible.[^12]\n\nIn order to provide forward security[^13][^14], the encryption keys for\nboth plaintext and length encryption are cycled every 224 messages, by\nswitching to a new key that is generated by the key stream using the old\nkey."
    },
    {
      "header": "Handshake: key exchange and version negotiation {#handshake_key_exchange_and_version_negotiation}",
      "content": "Next we specify the handshake of a connection in detail.\n\nAs explained before, these messages are sent to set up the connection:\n\n----------------------------------------------------------------------------------------------------\n| Initiator                         Responder                                                      |\n|                                                                                                  |\n| x, ellswift_X = ellswift_create(initiating=True)                                                 |\n|                                                                                                  |\n|           --- ellswift_X + initiator_garbage (initiator_garbage_len bytes; max 4095) --->        |\n|                                                                                                  |\n|                                   y, ellswift_Y = ellswift_create(initiating=False)              |\n|                                   ecdh_secret = v2_ecdh(                                         |\n|                                                     y, ellswift_X, ellswift_Y, initiating=False) |\n|                                   v2_initialize(initiator, ecdh_secret, initiating=False)        |\n|                                                                                                  |\n|           <-- ellswift_Y + responder_garbage (responder_garbage_len bytes; max 4095) +           |\n|                    responder_garbage_terminator (16 bytes) +                                     |\n|                    v2_enc_packet(initiator, b'', aad=responder_garbage) +                        |\n|                    v2_enc_packet(initiator, RESPONDER_TRANSPORT_VERSION) ---                     |\n|                                                                                                  |\n| ecdh_secret = v2_ecdh(x, ellswift_Y, ellswift_X, initiating=True)                                |\n| v2_initialize(responder, ecdh_secret, initiating=True)                                           |\n|                                                                                                  |\n|            --- initiator_garbage_terminator (16 bytes) +                                         |\n|                    v2_enc_packet(responder, b'', aad=initiator_garbage) +                        |\n|                    v2_enc_packet(responder, INITIATOR_TRANSPORT_VERSION) --->                    |\n|                                                                                                  |\n----------------------------------------------------------------------------------------------------"
    },
    {
      "header": "Shared secret computation {#shared_secret_computation}",
      "content": "The peers derive their shared secret through X-only ECDH, hashed\ntogether with the exactly 64-byte public keys\\' encodings sent over the\nwire.\n\ndef v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\necdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\nif initiating:"
    },
    {
      "header": "Initiating, place our public key encoding first.",
      "content": "return sha256_tagged(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\nelse:"
    },
    {
      "header": "Responding, place their public key encoding first.",
      "content": "return sha256_tagged(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n\nHere, `sha256_tagged(tag, x)` returns a tagged hash value\n`SHA256(SHA256(tag) || SHA256(tag) || x)` as in\n[BIP340](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification)."
    },
    {
      "header": "ElligatorSwift encoding of curve X coordinates {#elligatorswift_encoding_of_curve_x_coordinates}",
      "content": "The functions `ellswift_create` and `ellswift_ecdh_xonly` encapsulate\nthe construction of ElligatorSwift-encoded public keys, and the\ncomputation of X-only ECDH with ElligatorSwift-encoded public keys.\n\nFirst we define a constant:\n\n-   Let *c =\n0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852*.[^15]\n\nTo define the needed functions, we first introduce a helper function,\nmatching the `XSwiftEC` function from the\n[SwiftEC](https://eprint.iacr.org/2022/759.pdf) paper, instantiated for\nthe secp256k1 curve, with minor modifications. It maps pairs of integers\n*(u, t)* (both in range *0..p-1*) to valid X coordinates on the curve.\nNote that the specification here does not attempt to be constant time,\nas it does not operate on secret data. In what follows, we use the\nnotation from\n[BIP340](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification).\n\n-   *XSwiftEC(u, t)*:\n-   Alter the inputs to guarantee an X coordinate on the curve:[^16]\n-   If *u mod p = 0*, let *u = 1* instead.\n-   If *t mod p = 0*, let *t = 1* instead.\n-   If *(u^3^ + t^2^ + 7) mod p = 0*, let *t = 2t (mod p)*\ninstead.\n-   Let *X = (u^3^ + 7 - t^2^)/(2t) (mod p).*[^17]\n-   Let *Y = (X + t)/(cu) (mod p)*.\n-   For every *x* in *{u + 4Y^2^, (-X/Y - u)/2, (X/Y - u)/2}* (all\n*mod p*; the order matters):\n-   If *lift_x(x)* succeeds, return *x*. There is at least one\nsuch *x*.\n\nTo find encodings of a given X coordinate *x*, we first need the inverse\nof *XSwiftEC*. The function *XSwiftECInv(x, u, case)* either returns *t*\nsuch that *XSwiftEC(u, t) = x*, or *None*. The *case* variable is an\ninteger in range 0 to 7 inclusive, which selects which of the up to 8\nvalid such *t* values to return:\n\n-   *XSwiftECInv(x, u, case)*:\n-   If *case & 2 = 0*:\n-   If *lift_x(-x - u)* succeeds, return *None*.\n-   Let *v = x*.\n-   Let *s = -(u^3^ + 7)/(u^2^ + uv + v^2^) (mod p)*.\n-   If *case & 2 = 2*:\n-   Let *s = x - u (mod p)*.\n-   If *s = 0*, return *None*.\n-   Let *r* be the square root of *-s(4(u^3^ + 7) + 3u^2^s) (mod\np).*[^18] Return *None* if it does not exist.\n-   If *case & 1 = 1* and *r = 0*, return *None*.\n-   Let *v = (-u + r/s)/2*.\n-   Let *w* be the square root of *s (mod p)*. Return *None* if it\ndoes not exist.\n-   If *case & 5 = 0*, return *-w(u(1 - c)/2 + v)*.\n-   If *case & 5 = 1*, return *w(u(1 + c)/2 + v)*.\n-   If *case & 5 = 4*, return *w(u(1 - c)/2 + v)*.\n-   If *case & 5 = 5*, return *-w(u(1 + c)/2 + v)*.\n\nThe overall *XElligatorSwift* algorithm, matching the name used in the\npaper, then uses this inverse to randomly*[^19] sample encodings\nof*x\\'\\':\n\n-   *XElligatorSwift(x)*:\n-   Loop:\n-   Let *u* be a random non-zero integer in range *1..p-1*\ninclusive.\n-   Let *case* be a random integer in range *0..7* inclusive.\n-   Compute *t = XSwiftECInv(x, u, case)*.\n-   If *t* is not *None*, return *(u, t)*. Otherwise, restart\nloop.\n\nThis is used to define the `ellswift_create` algorithm used in the\nprevious section; it generates a random private key, along with a\nuniformly sampled 64-byte ElligatorSwift-encoded public key\ncorresponding to it:\n\n-   *ellswift_create()*:\n-   Generate a random private key *priv* in range *1..p-1*.\n-   Let *P = priv\u22c5G*, the corresponding public key point to *priv*.\n-   Let *(u, t) = XElligatorSwift(x(P))*, an encoding of *x(P)*.\n-   *ellswift_pub = bytes(u) \\|\\| bytes(t)*, its encoding as 64\nbytes.\n-   Return *(priv, ellswift_pub)*.\n\nFinally the `ellswift_ecdh_xonly` algorithm is:\n\n-   *ellswift_ecdh_xonly(ellswift_theirs, priv)*:\n-   Let *u = int(ellswift_theirs\\[:32\\]) mod p*.\n-   Let *t = int(ellswift_theirs\\[32:\\]) mod p*.\n-   Return *bytes(x(priv\u22c5lift_x(XSwiftEC(u, t))))*.[^20]"
    },
    {
      "header": "Keys and session ID derivation {#keys_and_session_id_derivation}",
      "content": "The authenticated encryption construction proposed here requires two\n32-byte keys per communication direction. These (in addition to a\nsession ID) are computed using HKDF[^21] as specified in [RFC\n5869](https://tools.ietf.org/html/rfc5869) with SHA256 as the hash\nfunction:\n\ndef initialize_v2_transport(peer, ecdh_secret, initiating):"
    },
    {
      "header": "Include NETWORK_MAGIC to ensure a connection between nodes on different networks will immediately fail",
      "content": "prk = HKDF_Extract(Hash=sha256, salt=b'bitcoin_v2_shared_secret' + NETWORK_MAGIC, ikm=ecdh_secret)\n\npeer.session_id = HKDF_Expand(Hash=sha256, PRK=prk, info=b'session_id', L=32)"
    },
    {
      "header": "Initialize the packet encryption ciphers.",
      "content": "initiator_L = HKDF_Expand(Hash=sha256, PRK=prk, info=b'initiator_L', L=32)\ninitiator_P = HKDF_Expand(Hash=sha256, PRK=prk, info=b'initiator_P', L=32)\nresponder_L = HKDF_Expand(Hash=sha256, PRK=prk, info=b'responder_L', L=32)\nresponder_P = HKDF_Expand(Hash=sha256, PRK=prk, info=b'responder_P', L=32)\ngarbage_terminators = HKDF_Expand(Hash=sha256, PRK=prk, info=b'garbage_terminators', L=32)\ninitiator_garbage_terminator = garbage_terminators[:16]\nresponder_garbage_terminator = garbage_terminators[16:]\n\nif initiating:\npeer.send_L = FSChaCha20(initiator_L)\npeer.send_P = FSChaCha20Poly1305(initiator_P)\npeer.send_garbage_terminator = initiator_garbage_terminator\npeer.recv_L = FSChaCha20(responder_L)\npeer.recv_P = FSChaCha20Poly1305(responder_P)\npeer.recv_garbage_terminator = responder_garbage_terminator\nelse:\npeer.send_L = FSChaCha20(responder_L)\npeer.send_P = FSChaCha20Poly1305(responder_P)\npeer.send_garbage_terminator = responder_garbage_terminator\npeer.recv_L = FSChaCha20(initiator_L)\npeer.recv_P = FSChaCha20Poly1305(initiator_P)\npeer.recv_garbage_terminator = initiator_garbage_terminator"
    },
    {
      "header": "To achieve forward secrecy we must wipe the key material used to initialize the ciphers:",
      "content": "memory_cleanse(ecdh_secret, prk, initiator_L, initiator_P, responder_L, responder_K)\n\nThe session ID uniquely identifies the encrypted channel. v2 clients\nsupporting this proposal may present the entire session ID (encoded as a\nhex string) to the node operator to allow for manual, out of band\ncomparison with the peer node operator. Future transport versions may\nintroduce optional authentication methods that compare the session ID as\nseen by the two endpoints in order to bind the encrypted channel to the\nauthentication."
    },
    {
      "header": "Overall handshake pseudocode {#overall_handshake_pseudocode}",
      "content": "To establish a v2 encrypted connection, the initiator generates an\nephemeral secp256k1 keypair and sends an unencrypted ElligatorSwift\nencoding of the public key to the responding peer followed by\nunencrypted pseudorandom bytes `initiator_garbage` of length\n`garbage_len < 4096`.\n\ndef initiate_v2_handshake(peer, garbage_len):\npeer.privkey_ours, peer.ellswift_ours = ellswift_create(initiating=True)\npeer.sent_garbage = rand_bytes(garbage_len)\nsend(peer, peer.ellswift_ours + peer.sent_garbage)\n\nThe responder generates an ephemeral keypair for itself and derives the\nshared ECDH secret (using the first 64 received bytes) which enables it\nto instantiate the encrypted transport. It then sends 64 bytes of the\nunencrypted ElligatorSwift encoding of its own public key and its own\n`responder_garbage` also of length `garbage_len < 4096`. If the first 12\nbytes received match the v1 prefix, the v1 protocol is used instead.\n\nTRANSPORT_VERSION = b''\nNETWORK_MAGIC = b'\\xf9\\xbe\\xb4\\xd9' # Mainnet network magic; differs on other networks.\nV1_PREFIX = NETWORK_MAGIC + b'version\\x00'\n\ndef respond_v2_handshake(peer, garbage_len):\npeer.received_prefix = b\"\"\nwhile len(peer.received_prefix) < 12:\npeer.received_prefix += receive(peer, 1)\nif peer.received_prefix[-1] != V1_PREFIX[len(peer.received_prefix) - 1]:\npeer.privkey_ours, peer.ellswift_ours = ellswift_create(initiating=False)\npeer.sent_garbage = rand_bytes(garbage_len)\nsend(peer, ellswift_Y + peer.sent_garbage)\nreturn\nuse_v1_protocol()\n\nUpon receiving the encoded responder public key, the initiator derives\nthe shared ECDH secret and instantiates the encrypted transport. It then\nsends the derived 16-byte `initiator_garbage_terminator` followed by an\nauthenticated, encrypted packet with empty contents[^22] to authenticate\nthe garbage, and its own version packet. It then receives the\nresponder\\'s garbage and garbage authentication packet (delimited by the\ngarbage terminator), and checks if the garbage is authenticated\ncorrectly. The responder performs very similar steps, but includes the\nearlier received prefix bytes in the public key. As mentioned before,\nthe encrypted packets for the **version negotiation phase** can be\npiggybacked with the garbage authentication packet to minimize\nroundtrips.\n\ndef complete_handshake(peer, initiating):\nreceived_prefix = b'' if initiating else peer.received_prefix\nellswift_theirs = receive(peer, 64 - len(received_prefix))\necdh_secret = v2_ecdh(peer.privkey_ours, ellswift_theirs, peer.ellswift_ours,\ninitiating=initiating)\ninitialize_v2_transport(peer, ecdh_secret, initiating=True)"
    },
    {
      "header": "Send garbage terminator + garbage authentication packet + version packet.",
      "content": "send(peer, peer.send_garbage_terminator +\nv2_enc_packet(peer, b'', aad=peer.sent_garbage) +\nv2_enc_packet(peer, TRANSPORT_VERSION))"
    },
    {
      "header": "Skip garbage, until encountering garbage terminator.",
      "content": "received_garbage = recv(peer, 16)\nfor i in range(4096):\nif received_garbage[-16:] == peer.recv_garbage_terminator:"
    },
    {
      "header": "Receive, decode, and ignore garbage authentication packet (decoy or not)",
      "content": "v2_receive_packet(peer, aad=received_garbage, skip_decoy=False)"
    },
    {
      "header": "Receive, decode, and ignore version packet, skipping decoys",
      "content": "v2_receive_packet(peer)\nreturn\nelse:\nreceived_garbage += recv(peer, 1)"
    },
    {
      "header": "Garbage terminator was not seen after 4 KiB of garbage.",
      "content": "disconnect(peer)"
    },
    {
      "header": "Packet encryption {#packet_encryption}",
      "content": "Lastly, we specify the packet encryption cipher in detail."
    },
    {
      "header": "Existing cryptographic primitives {#existing_cryptographic_primitives}",
      "content": "Packet encryption is built on two existing primitives:\n\n-   **ChaCha20Poly1305** is specified as `AEAD_CHACHA20_POLY1305` in\n[RFC 8439 section\n2.8](https://datatracker.ietf.org/doc/html/rfc8439#section-2.8). It\nis an authenticated encryption protocol with associated data (AEAD),\ntaking a 256-bit key, 96-bit nonce, and an arbitrary-length byte\narray of associated authenticated data (AAD). Due to the built-in\nauthentication tag, ciphertexts are 16 bytes longer than the\ncorresponding plaintext. In what follows:\n-   `aead_chacha20_poly1305_encrypt(key, nonce, aad, plaintext)`\nrefers to a function that takes as input a 32-byte array *key*,\na 12-byte array *nonce*, an arbitrary-length byte array *aad*,\nand an arbitrary-length byte array *plaintext*, and returns a\nbyte array *ciphertext*, 16 bytes longer than the plaintext.\n-   `aead_chacha20_poly1305_decrypt(key, nonce, aad, ciphertext)`\nrefers to a function that takes as input a 32-byte array *key*,\na 12-byte array *nonce*, an arbitrary-length byte array *aad*,\nand an arbitrary-length byte array *ciphertext*, and returns\neither a byte array *plaintext* (16 bytes shorter than the\nciphertext), or *None* in case the ciphertext was not a valid\nChaCha20Poly1305 encryption of any plaintext with the specified\n*key*, *nonce*, and *aad*.\n-   The **ChaCha20 Block Function** is specified in [RFC 8439 section\n2.3](https://datatracker.ietf.org/doc/html/rfc8439#section-2.8). It\nis a pseudorandom function (PRF) taking a 256-bit key, 96-bit nonce,\nand 32-bit counter, and outputs 64 pseudorandom bytes. It is the\nunderlying building block on which ChaCha20 (and ultimately,\nChaCha20Poly1305) is built. In what follows:\n-   `chacha20_block(key, nonce, count)` refers to a function that\ntakes as input a 32-byte array *key*, a 12-byte array *nonce*,\nand an integer *count* in range *0..2^32^-1*, and returns a byte\narray of length 64.\n\nThese will be used for plaintext encryption and length encryption,\nrespectively."
    },
    {
      "header": "Rekeying wrappers: FSChaCha20Poly1305 and FSChaCha20 {#rekeying_wrappers_fschacha20poly1305_and_fschacha20}",
      "content": "To provide re-keying every 224 packets, we specify two wrappers.\n\nThe first is **FSChaCha20Poly1305**, which represents a ChaCha20Poly1305\nAEAD, which automatically changes the nonce after every message, and\nrekeys every 224 messages by encrypting 32 zero bytes[^23], and using\nthe first 32 bytes of the result. Each message will be used for one\npacket. Note that in our protocol, any FSChaCha20Poly1305 instance is\nalways either exclusively encryption or exclusively decryption, as\nseparate instances are used for each direction of the protocol. The\nnonce used for a message is composed of the 32-bit little endian\nencoding of the number of messages with the current key, followed by the\n64-bit little endian encoding of the number of rekeyings performed. For\nrekeying, the first 32-bit integer is set to *0xffffffff*.\n\nREKEY_INTERVAL = 224\n\nclass FSChaCha20Poly1305:\n\"\"\"Rekeying wrapper AEAD around ChaCha20Poly1305.\"\"\"\n\ndef __init__(self, initial_key):\nself.key = initial_key\nself.packet_counter = 0\n\ndef crypt(self, aad, text, is_decrypt):\nnonce = ((self.packet_counter % REKEY_INTERVAL).to_bytes(4, 'little') +\n(self.packet_counter // REKEY_INTERVAL).to_bytes(8, 'little'))\nif is_decrypt:\nret = aead_chacha20_poly1305_decrypt(self.key, nonce, aad, text)\nelse:\nret = aead_chacha20_poly1305_encrypt(self.key, nonce, aad, text)\nif (self.packet_counter + 1) % REKEY_INTERVAL == 0:\nrekey_nonce = b\"\\xFF\\xFF\\xFF\\xFF\" + nonce[4:]\nself.key = aead_chacha20_poly1305_encrypt(self.key, rekey_nonce, b\"\", b\"\\x00\" * 32)[:32]\nself.packet_counter += 1\nreturn ret\n\ndef decrypt(self, aad, ciphertext):\nreturn self.crypt(aad, ciphertext, True)\n\ndef encrypt(self, aad, plaintext):\nreturn self.crypt(aad, plaintext, False)\n\nThe second is **FSChaCha20**, a (single) stream cipher which is used for\nthe lengths of all packets. Encryption and decryption are identical\nhere, so a single function `crypt` is exposed. It XORs the input with\nbytes generated using the ChaCha20 block function, rekeying every 224\nchunks using the next 32 bytes of the block function output as new key.\nA *chunk* refers here to a single invocation of `crypt`. As explained\nbefore, the same cipher is used for 224 consecutive chunks, to avoid\nwasting cipher output. The nonce used for these batches of 224 chunks is\ncomposed of 4 zero bytes followed by the 64-bit little endian encoding\nof the number of rekeyings performed. The block counter is reset to 0\nafter every rekeying.\n\nclass FSChaCha20:\n\"\"\"Rekeying wrapper stream cipher around ChaCha20.\"\"\"\n\ndef __init__(self, initial_key):\nself.key = initial_key\nself.block_counter = 0\nself.chunk_counter = 0\nself.keystream = b''\n\ndef get_keystream_bytes(self, nbytes):\nwhile len(self.keystream) < nbytes:\nnonce = ((0).to_bytes(4, 'little') +\n(self.chunk_counter // REKEY_INTERVAL).to_bytes(8, 'little'))\nself.keystream += chacha20_block(self.key, nonce, self.block_counter)\nself.block_counter += 1\nret = self.keystream[:nbytes]\nself.keystream = self.keystream[nbytes:]\nreturn ret\n\ndef crypt(self, chunk):\nks = self.get_keystream_bytes(len(chunk))\nret = bytes([ks[i] ^ chunk[i] for i in range(len(chunk))])\nif ((self.chunk_counter + 1) % REKEY_INTERVAL) == 0:\nself.key = self.get_keystream_bytes(32)\nself.block_counter = 0\nself.chunk_counter += 1\nreturn ret"
    },
    {
      "header": "Overall packet encryption and decryption pseudocode {#overall_packet_encryption_and_decryption_pseudocode}",
      "content": "Encryption and decryption of packets then follow by composing the\nciphers from the previous section as building blocks.\n\nLENGTH_FIELD_LEN = 3\nHEADER_LEN = 1\nIGNORE_BIT_POS = 7\n\ndef v2_enc_packet(peer, contents, aad=b'', ignore=False):\nassert len(contents) <= 2**24 - 1\nheader = (ignore << IGNORE_BIT_POS).to_bytes(HEADER_LEN, 'little')\nplaintext = header + contents\naead_ciphertext = peer.send_P.encrypt(aad, plaintext)\nenc_contents_len = peer.send_L.encrypt(len(contents).to_bytes(LENGTH_FIELD_LEN, 'little'))\nreturn enc_contents_len + aead_ciphertext\n\nCHACHA20POLY1305_EXPANSION = 16\n\ndef v2_receive_packet(peer, aad=b'', skip_decoy=True):\nwhile True:\nenc_contents_len = receive(peer, LENGTH_FIELD_LEN)\ncontents_len = int.from_bytes(peer.recv_L.crypt(enc_contents_len), 'little')\naead_ciphertext = receive(peer, HEADER_LEN + contents_len + CHACHA20POLY1305_EXPANSION)\nplaintext = peer.recv_P.decrypt(aead_ciphertext)\nif plaintext is None:\ndisconnect(peer)\nbreak\nheader = plaintext[:HEADER_LEN]\nif not (skip_decoy and header[0] & (1 << IGNORE_BIT_POS)):\nreturn plaintext[HEADER_LEN:]"
    },
    {
      "header": "Performance",
      "content": "Each v1 P2P message uses a double-SHA256 checksum truncated to 4 bytes.\nRoughly the same amount of computation power is required for encrypting\nand authenticating a v2 P2P message as proposed."
    },
    {
      "header": "Application layer specification {#application_layer_specification}",
      "content": "#### v2 Bitcoin P2P message structure {#v2_bitcoin_p2p_message_structure}\n\nv2 Bitcoin P2P transport layer packets use the encrypted message\nstructure shown above. An unencrypted application layer **contents** is\ncomposed of:\n\nField               Size in bytes      Comments\n------------------- ------------------ ---------------------------------------------------------------------\n`message_type`      *1..13*            either a one byte ID or an ASCII string prefixed with a length byte\n`message_payload`   `message_length`   message payload\n\nIf the first byte of `message_type` is in the range *1..12*, it is\ninterpreted as the number of ASCII bytes that follow for the message\ntype. If it is in the range *13..255*, it is interpreted as a message\ntype ID. This structure results in smaller messages than the v1 protocol\nas most messages sent/received will have a message type ID.[^24]\n\nThe following table lists currently defined message type IDs:\n\n0                  1                 2                  3\n----- ------------------ ----------------- ------------------ ------------------\n+0    (undefined)        (1 byte string)   (2 byte string)    (3 byte string)\n+4    (4 byte string)    (5 byte string)   (6 byte string)    (7 byte string)\n+8    (8 byte string)    (9 byte string)   (10 byte string)   (11 byte string)\n+12   (12 byte string)   `ADDR`            `BLOCK`            `BLOCKTXN`\n+16   `CMPCTBLOCK`       `FEEFILTER`       `FILTERADD`        `FILTERCLEAR`\n+20   `FILTERLOAD`       `GETADDR`         `GETBLOCKS`        `GETBLOCKTXN`\n+24   `GETDATA`          `GETHEADERS`      `HEADERS`          `INV`\n+28   `MEMPOOL`          `MERKLEBLOCK`     `NOTFOUND`         `PING`\n+32   `PONG`             `SENDCMPCT`       `SENDHEADERS`      `TX`\n+36   `VERACK`           `VERSION`         `GETCFILTERS`      `CFILTER`\n+40   `GETCFHEADERS`     `CFHEADERS`       `GETCFCHECKPT`     `CFCHECKPT`\n+44   `WTXIDRELAY`       `ADDRV2`          `SENDADDRV2`       `SENDTXRCNCL`\n+48   `REQRECON`         `SKETCH`          `REQSKETCHEXT`     `RECONCILDIFF`\n\u226552   (undefined)                                             \n\nThe message types may be updated separately after BIP finalization."
    },
    {
      "header": "Signaling specification {#signaling_specification}",
      "content": "#### Signaling v2 support {#signaling_v2_support}\n\nPeers supporting the v2 transport protocol signal support by advertising\nthe `NODE_P2P_V2 = (1 << 11)` service flag in addr relay. If met with\nimmediate disconnection when establishing a v2 connection, clients\nimplementing this proposal are encouraged to retry connecting using the\nv1 protocol.[^25]"
    },
    {
      "header": "Test Vectors {#test_vectors}",
      "content": "For development and testing purposes, we provide a collection of test\nvectors in CSV format, and a naive, highly inefficient, [reference\nimplementation](bip-0324/reference.py \"wikilink\") of the relevant\nalgorithms. This code is for demonstration purposes only:\n\n-   [XElligatorSwift decoding\nvectors](bip-0324/ellswift_decode_test_vectors.csv \"wikilink\") give\nexamples of ElligatorSwift-encoded public keys, and the X coordinate\nthey map to.\n-   [XSwiftECInv\nvectors](bip-0324/xswiftec_inv_test_vectors.csv \"wikilink\") give\nexamples of *(u, x)* pairs, and the various *t* values that\n*xswiftec_inv* maps them to.\n-   [Packet encoding\nvectors](bip-0324/packet_encoding_test_vectors.csv \"wikilink\")\nillustrate the lifecycle of the authenticated encryption scheme\nproposed in this document."
    },
    {
      "header": "Rationale and References {#rationale_and_references}",
      "content": "```{=html}\n<references/>\n```"
    },
    {
      "header": "Acknowledgements",
      "content": "Thanks to everyone (last name order) that helped invent and develop the\nideas in this proposal:\n\n-   Matt Corallo\n-   Lloyd Fournier\n-   Gregory Maxwell\n\n[^1]: **What does *authentication* mean in this context?**\nUnfortunately, the term authentication in the context of secure\nchannel protocols is ambiguous. It can refer to:\n\n-   The encryption scheme guaranteeing that a message obtained via\nsuccessful decryption was encrypted by someone having access to\nthe (symmetric) encryption key, and not modified after\nencryption by a third party. The proposal in this document\nachieves that property through the use of an AEAD.\n-   The communication protocol establishing that the communication\npartner\\'s identity matches who we expect them to be, through\nsome public key mechanism. The proposal in this document does\n**not** include such a mechanism.\n```{=html}\n</ref>\n```\nprovides strictly better security than no encryption. Thus all\nconnections should use encryption, even if they are\nunauthenticated.\n\nWhen it comes to authentication, the situation is not as clear as\nfor encryption. Due to Bitcoin\\'s permissionless nature,\nauthentication will always be restricted to specific scenarios\n(e.g., connections between peers belonging to the same operator),\nand whether some form of (possibly partially anonymous)\nauthentication is desired depends on the specific requirements of\nthe involved peers. As a consequence, we believe that authentication\nshould be addressed separately (if desired), and this proposal aims\nto provide a solid technical basis for future protocol upgrades,\nincluding the addition of optional authentication (see [Private\nauthentication\nprotocols](https://github.com/sipa/writeups/tree/main/private-authentication-protocols)).\n\n**Why have a pseudorandom bytestream when traffic analysis is still\npossible?**\n\nTraffic analysis, e.g., observing packet lengths and timing, as well\nas active attacks can still reveal that the Bitcoin v2 P2P protocol\nis in use. Nevertheless, a pseudorandom bytestream raises the cost\nof fingerprinting the protocol substantially, and may force some\nintermediaries to attack any protocol they cannot identify, causing\ncollateral cost.\n\nA pseudorandom bytestream is not self-identifying. Moreover, it is\nunopinionated and thus a canonical choice for similar protocols. As\na result, Bitcoin P2P traffic will be indistinguishable from traffic\nof other protocols which make the same choice (e.g.,\n[obfs4](https://gitlab.com/yawning/obfs4) and a recently proposed\n[cTLS\nextension](https://datatracker.ietf.org/doc/draft-cpbs-pseudorandom-ctls/)).\nMoreover, traffic shapers and protocol wrappers (for example, making\nthe traffic look like HTTPS or SSH) can further mitigate traffic\nanalysis and active attacks but are out of scope for this proposal.\n\n**Why not use a secure tunnel protocol?**\n\nOur goal includes making opportunistic encryption ubiquitously\navailable, as that provides the best defense against large-scale\nattacks. That implies protecting both the manual, deliberate\nconnections node operators instruct their software to make, as well\nas the the automatic connections Bitcoin nodes make with each other\nbased on IP addresses obtained via gossip. While encryption per se\nis already possible with proxy networks or VPN networks, these are\nnot desirable or applicable for automatic connections at scale:\n\n-   Proxy networks like Tor or I2P introduce a separate address\nspace, independent from network topology, with a very low cost\nper address making eclipse attacks cheaper. In comparison,\nclearnet IPv4 and IPv6 networks make obtaining multiple network\nidentities in distinct, well-known network partitions carry a\nnon-trivial cost. Thus, it is not desirable to have a\nsubstantial portion of nodes be exclusively connected this way,\nas this would significantly reduce Eclipse attack costs.[^26]\nAdditionally, Tor connections come with significant bandwidth\nand latency costs that may not be desirable for all network\nusers.\n-   VPN networks like WireGuard or OpenVPN inherently define a\nprivate network, which requires manual configuration and\ntherefore is not a realistic avenue for automatic connections.\n\nThus, to achieve our goal, we need a solution that has minimal\ncosts, works without configuration, and is always enabled -- on top\nof any network layer rather than be part of the network layer.\n\n**Why not use a general-purpose transport encryption protocol?**\n\nWhile it would be possible to rely on an off-the-shelf transport\nencryption protocol such as TLS or Noise, the specific requirements\nof the Bitcoin P2P network laid out above make these protocols an\nunsuitable choice.\n\nThe primary requirement which existing protocols fail to meet is a\nsufficiently modular treatment of encryption and authentication. As\nwe argue above, whether and which form of authentication is desired\nin the Bitcoin P2P network will depend on the specific requirements\nof the involved peers (resulting in a mix of authenticated and\nunauthenticated connections), and thus the question of\nauthentication should be decoupled from encryption. However, native\nsupport for a handful of standard authentication scenarios (e.g.,\nusing digital signatures and certificates) is at core of the design\nof existing general-purpose transport encryption protocols. This\nfocus on authentication would not provide clear benefits for the\nBitcoin P2P network but would come with a large amount of additional\ncomplexity.\n\nIn contrast, our proposal instead aims for simple modular design\nthat makes it possible to address authentication separately. Our\nproposal provides a foundation for authentication by exporting a\n*session ID* that uniquely identifies the encrypted channel. After\nan encrypted channel has been established, the two endpoints are\nable to use any authentication protocol to confirm that they have\nthe same session ID. (This is sometimes called *channel binding*\nbecause the session ID binds the encrypted channel to the\nauthentication protocol.) Since in our proposal, any authentication\nneeds to run after an encrypted connection has been established, the\nprice we pay for this modularity is a possibly higher number of\nroundtrips as opposed to other protocols that perform authentication\nalongside with the Diffie-Hellman key exchange.[^27] However, the\nresulting increase in connection establishment latency is a not a\nconcern for Bitcoin\\'s long-lived connections, [which typically live\nfor hours or even weeks](https://www.dsn.kastel.kit.edu/bitcoin/).\n\nBesides this fundamentally different treatment of authentication,\nfurther technical issues arise when applying TLS or Noise to our\ndesired use case:\n\n-   Neither offers a pseudorandom bytestream.\n-   Neither offers native support for elliptic curve cryptography on\nthe curve secp256k1 as otherwise used in Bitcoin. While using\nsecp256k1 is not strictly necessary, it is the obvious choice is\nfor any new asymmetric cryptography in Bitcoin because it\nminimizes the cryptographic hardness assumptions as well as the\ndependencies that Bitcoin software will need.\n-   Neither offers shapability of the bytestream.\n-   Both provide a stream-based interface to the application layer\nwhereas Bitcoin requires a packet-based interface, resulting in\nthe need for an additional thin layer to perform packet\nserialization and deserialization.\n\nWhile existing protocols could be amended to address all of the\naforementioned issues, this would negate the benefits of using them\nas off-the-shelf solution, e.g., the possibility to re-use existing\nimplementations and security analyses."
    },
    {
      "header": "Goals",
      "content": "This proposal aims to achieve the following properties:\n\n-   Confidentiality against passive attacks: A passive attacker\nhaving recorded a v2 P2P bytestream (without timing and\nfragmentation information) must not be able to determine the\nplaintext being exchanged by the nodes.\n-   Observability of active attacks: A session ID identifying the\nencrypted channel uniquely is derived deterministically from a\nDiffie-Hellman negotiation. An active man-in-the-middle attacker\nis forced to incur a risk of being detected as peer operators\ncan compare session IDs manually, or using optional\nauthentication methods possibly introduced in future protocol\nversions.\n-   Pseudorandom bytestream: A passive attacker having recorded a v2\nP2P bytestream (without timing information and fragmentation\ninformation) must not be able to distinguish it from a uniformly\nrandom bytestream.\n-   Shapable bytestream: It should be possible to shape the\nbytestream to increase resistance to traffic analysis (for\nexample, to conceal block propagation), or censorship\navoidance.[^28]\n-   Forward secrecy: An eavesdropping attacker who compromises a\npeer\\'s sessions secrets should not be able to decrypt past\nsession traffic, except for the latest few packets.\n-   Upgradability: The proposal provides an upgrade path using\ntransport versioning which can be used to add features like\nauthentication, PQC handshake upgrade, etc. in the future.\n-   Compatibility: v2 clients will allow inbound v1 connections to\nminimize risk of network partitions.\n-   Low overhead: the introduction of a new P2P transport protocol\nshould not substantially increase computational cost or\nbandwidth for nodes that implement it, compared to the current\nprotocol."
    },
    {
      "header": "Specification",
      "content": "The specification consists of three parts:\n\n-   The **Transport layer** concerns how to set up an encrypted\nconnection between two nodes, capable of transporting\napplication-level messages between them.\n-   The **Application layer** concerns how to encode Bitcoin P2P\nmessages and commands for transport by the Transport Layer.\n-   The **Signaling** concerns how v2 nodes advertise their support\nfor the v2 protocol to potential peers."
    },
    {
      "header": "Transport layer specification {#transport_layer_specification}",
      "content": "In this section we define the encryption protocol for messages\nbetween peers."
    },
    {
      "header": "Overview and design {#overview_and_design}",
      "content": "We first give an informal overview of the entire protocol flow and\npacket encryption.\n\n**Protocol flow overview**\n\nGiven a newly-established connection (typically TCP/IP) between two\nv2 P2P nodes, there are 3 phases the connection goes through. The\nfirst starts immediately, i.e. there are no v1 messages or any other\nbytes exchanged on the link beforehand. The two parties are called\nthe **initiator** (who established the connection) and the\n**responder** (who accepted the connection).\n\n1.  The **Key exchange phase**, where nodes exchange data to\nestablish shared secrets.\n-   The initiator:\n-   Generates a random ephemeral secp256k1 private key and\nsends a corresponding 64-byte\nElligatorSwift[^29][^30]-encoded public key to the\nresponder.\n-   May send up to 4095[^31] bytes of arbitrary data after\ntheir public key, called **garbage**, providing a form\nof shapability and avoiding a recognizable pattern of\nexactly 64 bytes.[^32]\n-   The responder:\n-   Waits until one byte is received which does not match\nthe 12 bytes consisting of the network magic followed by\n\\\"version\\\\x00\\\". If the first 12 bytes do match, the\nconnection is treated as using the v1 protocol\ninstead.[^33][^34]\n-   Similarly generates a random ephemeral private key and\nsends a corresponding 64-byte ElligatorSwift-encoded\npublic key to the initiator.\n-   Similarly may send up to 4095 bytes of garbage data\nafter their public key.\n-   Both parties:\n-   Receive (the remainder of) the full 64-byte public key\nfrom the other side.\n-   Use X-only[^35] ECDH to compute a shared secret from\ntheir private key and the exchanged public keys[^36],\nand deterministically derive from the secret 4\n**encryption keys** (two in each direction: one for\npacket lengths, one for content encryption), a **session\nid**, and two 16-byte **garbage\nterminators**[^37]`<ref>`{=html}**What does a garbage\nterminator in the wild look like?**\n```{=html}\n<div>\n```\n<figure>\n<img src=\"bip-0324/garbage_terminator.png\"\ntitle=\"A garbage terminator model TX-v2 in the wild... sent by the responder\"\nwidth=\"256\" />\n<figcaption>A garbage terminator model TX-v2 in the wild... sent by the\nresponder</figcaption>\n</figure>\n\n```{=html}\n</div>\n```\n\n[^2]: **Why does the protocol need a garbage terminator?** While it is\nin principle possible to use the garbage authentication packet\ndirectly as a terminator (scan until a valid authentication packet\nfollows), this would be significantly slower than just scanning for\na fixed byte sequence, as it would require recomputing a Poly1305\ntag after every received byte.\n\n[^3]: **Why does the protocol require a garbage authentication packet?**\nOtherwise the garbage would be modifiable by a third party without\nconsequences. We want to force any active attacker to have to\nmaintain a full protocol state. In addition, such malleability\nwithout the consequence of connection termination could enable\nprotocol fingerprinting.\n\n[^4]: **What features could be added in future protocol versions?**\nExamples of features that could be added in future versions include\npost-quantum cryptography upgrades to the handshake, and optional\nauthentication.\n\n[^5]: **How will future versions encode version numbers in the version\npacket?** Future versions could, for example, specify that the\ncontents of the version packet is to be interpreted as an integer\nversion number (with empty representing 0), and if the minimum of\nboth numbers is N, that being interpreted as choosing a \\\"v2.N\\\"\nprotocol version. Alternatively, certain bytes of the version packet\ncontents could be interpreted as a bitvector of optional features.\n\n[^6]: **How can progress be guaranteed in a backwards-compatible way?**\nIn order to guarantee progress, it must be ensured that no deadlock\noccurs, i.e., no state is reached in which each party waits for the\nother party indefinitely. For example, any upgrade that adheres to\nthe following conditions will guarantee progress:\n\n-   The initiator must start by sending at least as many bytes as\nnecessary to mismatch the magic/version 12 bytes prefix.\n-   The responder must start sending after having received at least\none byte that mismatches that 12-byte prefix.\n-   As soon as either party has received the other peer\\'s garbage\nterminator, or has received 4095 bytes of garbage, they must\nsend their own garbage terminator. (When either of these\nconditions is met, the other party has nothing to respond with\nanymore that would be needed to guarantee progress otherwise.)\n-   Whenever either party receives any nonzero number of bytes,\nwhile not having sent their garbage terminator completely yet,\nthey must send at least one byte in response without waiting for\nmore bytes.\n-   After either party has sent their garbage terminator, they must\nalso send the garbage authentication packet without waiting for\nmore bytes, and transition to the version negotiation phase.\n\nSince the protocol as specified here adheres to these conditions,\nany upgrade which also adheres to these conditions will be\nbackwards-compatible.\n\n[^7]: **Is *2^24^-1* bytes sufficient as maximum content size?** The\ncurrent Bitcoin P2P protocol has no messages which support more than\n4000000 bytes of application payload. By supporting up to *2^24^-1*\nwe can accommodate future evolutions needing more than 4 times that\nvalue. Hypothetical protocol changes that have even more data to\nexchange than that should probably use multiple separate messages\nanyway, because of the per-peer receive buffer sizes involved, and\nthe inability to start processing a message before it is fully\nreceived. Of course, future versions of the transport protocol could\nchange the size of the length field, if this were really needed.\n\n[^8]: **Why is the header a part of the plaintext and not included\nalongside the length field?** The packet length field is the minimum\ninformation that must be available before we can leverage the\nstandard RFC8439 AEAD. Any other data, including metadata like the\nheader being in the content encryption makes it easier to reason\nabout the protocol security w.r.t. data being used before it is\nauthenticated. If the ignore bit was not part of the content,\nanother mechanism would be needed to authenticate it; for example,\nit could be fed as AAD to the AEAD cipher. We feel the complexity of\nsuch an approach outweighs the benefit of saving one byte per\nmessage.\n\n[^9]: **Why is ChaCha20Poly1305 chosen as basis for packet encryption?**\nIt is a very widely used authenticated encryption cipher (used\namongst others in SSH, TLS 1.2, TLS 1.3,\n[QUIC](https://en.wikipedia.org/wiki/QUIC), Noise, and\n[WireGuard](https://www.wireguard.com/protocol/); in the latter it\nis currently even the only supported cipher), with very good\nperformance in general purpose software implementations. While\nAES-based ciphers (including the winners in the\n[CAESAR](https://competitions.cr.yp.to/caesar.html) competition in\nnon-lightweight categories) perform significantly better on systems\nwith AES hardware acceleration, they are also significantly slower\nin pure software implementations. We choose to optimize for the\nweakest hardware.\n\n[^10]: **Why is the length encryption not separately authenticated?**\nInformally, the relevant security goal we aim for is to hide the\nnumber of packets and their lengths (i.e., the packet boundaries)\nagainst a passive attacker that receives the bytestream without\ntiming or fragmentation information. (A formal definition can be\nfound for example in [Hansen 2016 (Definition\n22)](https://himsen.github.io/pdf/thesis.pdf) under the name\n\\\"boundary hiding against chosen-plaintext attacks (BH-CPA)\\\".)\nHowever, we do not aim to hide packet boundaries against active\nattackers because active attackers can always exploit the fact that\nthe Bitcoin P2P protocol is largely query-response based: they can\ntrickle the bytes on the stream one-by-one unmodified and observe\nwhen a response comes (see [Hansen 2016 (Section\n3.9)](https://himsen.github.io/pdf/thesis.pdf) for a in-depth\ndiscussion). With that in mind, we accept that an active (non-MitM)\nattacker is able to figure out some information about packet\nboundaries by flipping certain bits in the unauthenticated length\nfield, and observing the other side disconnecting immediately or\nlater. Thus, we choose to use unauthenticated encryption for the\nlength data, which is sufficient to achieve boundary hiding against\npassive attackers, and saves 16 bytes of bandwidth per packet.\n\n[^11]: **How does packet encryption differ from the OpenSSH design?**\nThe differences are:\n\n-   The length field is only 3 bytes instead of 4, as that is\nsufficient for our purposes.\n-   Length encryption keeps drawing pseudorandom bytes from the same\nChaCha20 cipher for multiple packets, rather than incrementing\nthe nonce for every packet.\n-   The Poly1305 authentication tag only covers the encrypted\nplaintext, and not the encrypted length field. This means that\nplaintext encryption uses the standard ChaCha20Poly1305\nconstruction without any modifications, maximizing applicability\nof analysis and review of that cipher. The length encryption can\nbe seen as a separate layer, using a separate key, and thus\ncannot affect any of the confidentiality or integrity guarantees\nof the plaintext encryption. On the other hand, this change\nw.r.t. OpenSSH also does not worsen any properties, as incorrect\nlengths will still trigger authentication failure for the\noverall packet (the plaintext length is implicitly authenticated\nby ChaCha20Poly1305).\n-   A hash step is performed every 224[^38] messages to rekey the\nthe encryption ciphers, in order to provide forward security.\n\n[^12]: **Is it acceptable to use a less standard construction for length\nencryption?** The fact that multiple (non-overlapping) bytes\ngenerated by a single ChaCha20 cipher are used for the encryption of\nmultiple consecutive length fields is uncommon. We feel the\nperformance cost gained by this deviation is worth it (especially\nfor small packets, which are very common in Bitcoin\\'s P2P\nprotocol), given the low guarantees that are feasible for length\nencryption in the first place, and the result is still sufficient to\nprovide pseudorandomness from the view of passive attackers. For\nplaintext encryption, we independently use a very standard\nconstruction, as the stakes for confidentiality and integrity there\nare much higher.\n\n[^13]: **What value does forward security provide?** Re-keying ensures\n[forward secrecy within a\nsession](https://eprint.iacr.org/2001/035.pdf), i.e., an attacker\ncompromising the current session secrets cannot derive past\nencryption keys in the same session.\n\n[^14]: **Why have a cipher with forward secrecy but no periodical\nrefresh of the ECDH key exchange?** Our cipher ratchets encryption\nkeys forward in order to protect messages encrypted under *past*\nencryption keys. In contrast, re-performing ECDH key exchange would\nprotect messages encrypted under *future* encryption keys, i.e., it\nwould re-establish security after the attacker had compromised one\nof the peers *temporarily* (e.g., the attacker obtains a memory\ndump). We do not believe protecting against that is a priority: an\nattacker that, for whatever reason, is capable of an attack that\nreveals encryption keys (or other session secrets) of a peer once is\nlikely capable of performing the same attack again after peers have\nre-performed the ECDH key exchange. Thus, we do not believe the\nbenefits of re-performing key exchange outweigh the additional\ncomplexity that comes with the necessary coordination between the\npeers. We note that the initiator could choose to close and re-open\nthe entire connection in order to force a refresh of the ECDH key\nexchange, but that introduces other issues: a connection slot needs\nto be kept open at the responder side, it is not cryptographically\nguaranteed that really the same initiator will use it, and the\nobservable TCP reset and handshake may create a detectable pattern.\n\n[^15]: **What is the *c* constant used in *XSwiftEC*?** The algorithm\nrequires a constant *\u221a-3 (mod p)*; in other words, a number *c* such\nthat *-c^2^ mod p = 3*. There are two solutions to this equation,\none which is itself a square modulo *p*, and its negation. We choose\nthe square one.\n\n[^16]: **Why do the inputs to the XSwiftEC algorithm need to be\naltered?** This step deviates from the paper, which maps a\nnegligibly small subset of inputs (around *3/2^256^*) to the point\nat infinity. To avoid the need to deal with the case where a peer\ncould craft encodings that intentionally trigger this edge case, we\nremap them to inputs that yield a valid X coordinate.\n\n[^17]: **What does the division (/) sign in modular arithmetic refer\nto?** Note that the division in these expressions corresponds to\nmultiplication with the modular inverse modulo *p*, i.e. *a / b (mod\np)* with nonzero *b* is the unique solution *x* for which *bx = a\n(mod p)*. It can be computed as *ab^p-2^ (mod p)*, but more\nefficient algorithms exist.\n\n[^18]: **How to compute a square root mod *p*?** Due to the structure of\n*p*, a candidate for the square root of *a* mod *p* can be computed\nas *x = a^(p+1)/4^ mod p*. If *a* is not a square mod *p*, this\nformula returns the square root of *-a mod p* instead, so it is\nnecessary to verify that *x^2^ mod p = a*. If that is the case *-x\nmod p* is a solution too, but we define \\\"the\\\" square root to be\nequal to that expression (the square root will therefore always be a\nsquare itself, as *(p+1)/4* is even). This algorithm is a\nspecialization of the [Tonelli-Shanks\nalgorithm](https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm).\n\n[^19]: **Can the ElligatorSwift encoding be used to construct public key\nencodings that satisfy a certain structure (and not pseudorandom)?**\nThe algorithm chooses the first 32 bytes (i.e., the value *u*) and\nthen computes a corresponding *t* such that the mapping to the curve\npoint holds. In general, picking *u* from a uniformly random\ndistribution provides pseudorandomness. But we can also fix any of\nthe 32 bytes in *u*, and the algorithm will still find a\ncorresponding *t*. The fact that it is possible to fix the first 32\nbytes, combined with the garbage bytes in the handshake, provides a\nlimited but very simple method of parroting other protocols such as\n[TLS 1.3](https://tls13.xargs.org/), which can be deployed by one of\nthe peers without explicit support from the other peer. More general\nmethods of parroting, e.g., introduced by defining new protocol or a\nprotocol upgrade, are not precluded.\n\n[^20]: **Does it matter which point *lift_x* maps to?** Either point is\nvalid, as they are negations of each other, and negations do not\naffect the output X coordinate.\n\n[^21]: **Why use HKDF for deriving key material?** The shared secret\nalready involves a hash function to make sure the public key\nencodings contribute to it, which negates some of the need for HKDF\nalready. We still use it as it is the standard mechanism for\nderiving many keys from a single secret, and its computational cost\nis low enough to be negligible compared to the rest of a connection\nsetup.\n\n[^22]: **Does the content of the garbage authentication packet need to\nbe empty?** The receiver ignores the content of the garbage\nauthentication packet, so its content can be anything, and it can in\nprinciple be used as a shaping mechanism too. There is however no\nneed for that, as immediately afterwards the initiator can start\nusing decoy packets as (much more flexible) shaping mechanism\ninstead.\n\n[^23]: **Why is rekeying implemented in terms of an invocation of the\nAEAD?** This means the FSChaCha20Poly1305 wrapper can be thought of\nas a pure layer around the ChaCha20Poly1305 AEAD. Actual\nimplementations can take advantage of the fact that this formulation\nis equivalent to using byte 64 through 95 of the keystream output of\nthe underlying ChaCha20 cipher as new key, avoiding the need for\nPoly1305 in the process.\n\n[^24]: **How do the length between v1 and v2 compare?** For messages\nthat use the 1-byte short message type ID, v2 packets use 3 bytes\nless per message than v1.\n\n[^25]: **Why are v2 clients met with immediate disconnection encouraged\nto retry with a v1 connection?** Service flags propagated through\nuntrusted intermediaries using ADDR and ADDRV2 P2P messages and are\nOR\\'ed when received from multiple sources. An untrusted\nintermediary could falsely advertise a potential peer as supportive\nof v2 connections. Connection downgrades to v1 mitigate the risk of\na network participant being blackholed via false advertising."
    }
  ]
}