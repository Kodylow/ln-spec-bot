{
  "BIP": "65",
  "Layer": "Consensus (soft fork)",
  "Title": "OP_CHECKLOCKTIMEVERIFY",
  "Author": "Peter Todd <pete@petertodd.org>",
  "Comments-Summary": "No comments yet.",
  "Comments-URI": "https://github.com/bitcoin/bips/wiki/Comments:BIP-0065",
  "Status": "Final",
  "Type": "Standards Track",
  "Created": "2014-10-01",
  "License": "PD",
  "sections": [
    {
      "header": "Abstract",
      "content": "This BIP describes a new opcode (OP_CHECKLOCKTIMEVERIFY) for the Bitcoin\nscripting system that allows a transaction output to be made unspendable\nuntil some point in the future."
    },
    {
      "header": "Summary",
      "content": "CHECKLOCKTIMEVERIFY redefines the existing NOP2 opcode. When executed,\nif any of the following conditions are true, the script interpreter will\nterminate with an error:\n\n-   the stack is empty; or\n-   the top item on the stack is less than 0; or\n-   the lock-time type (height vs. timestamp) of the top stack item and\nthe nLockTime field are not the same; or\n-   the top stack item is greater than the transaction\\'s nLockTime\nfield; or\n-   the nSequence field of the txin is 0xffffffff;\n\nOtherwise, script execution will continue as if a NOP had been executed.\n\nThe nLockTime field in a transaction prevents the transaction from being\nmined until either a certain block height, or block time, has been\nreached. By comparing the argument to CHECKLOCKTIMEVERIFY against the\nnLockTime field, we indirectly verify that the desired block height or\nblock time has been reached; until that block height or block time has\nbeen reached the transaction output remains unspendable."
    },
    {
      "header": "Motivation",
      "content": "The nLockTime field in transactions can be used to prove that it is\n*possible* to spend a transaction output in the future, by constructing\na valid transaction spending that output with the nLockTime field set.\n\nHowever, the nLockTime field can\\'t prove that it is *impossible* to\nspend a transaction output until some time in the future, as there is no\nway to know if a valid signature for a different transaction spending\nthat output has been created."
    },
    {
      "header": "Escrow",
      "content": "If Alice and Bob jointly operate a business they may want to ensure that\nall funds are kept in 2-of-2 multisig transaction outputs that require\nthe co-operation of both parties to spend. However, they recognise that\nin exceptional circumstances such as either party getting \\\"hit by a\nbus\\\" they need a backup plan to retrieve the funds. So they appoint\ntheir lawyer, Lenny, to act as a third-party.\n\nWith a standard 2-of-3 CHECKMULTISIG at any time Lenny could conspire\nwith either Alice or Bob to steal the funds illegitimately. Equally\nLenny may prefer not to have immediate access to the funds to discourage\nbad actors from attempting to get the secret keys from him by force.\n\nHowever, with CHECKLOCKTIMEVERIFY the funds can be stored in\nscriptPubKeys of the form:\n\n`\u00a0\u00a0\u00a0IF`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<now\u00a0+\u00a03\u00a0months>\u00a0CHECKLOCKTIMEVERIFY\u00a0DROP`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<Lenny's\u00a0pubkey>\u00a0CHECKSIGVERIFY`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01`\\\n`\u00a0\u00a0\u00a0ELSE`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02`\\\n`\u00a0\u00a0\u00a0ENDIF`\\\n`\u00a0\u00a0\u00a0<Alice's\u00a0pubkey>\u00a0<Bob's\u00a0pubkey>\u00a02\u00a0CHECKMULTISIG`\n\nAt any time the funds can be spent with the following scriptSig:\n\n`\u00a0\u00a0\u00a00\u00a0<Alice's\u00a0signature>\u00a0<Bob's\u00a0signature>\u00a00`\n\nAfter 3 months have passed Lenny and one of either Alice or Bob can\nspend the funds with the following scriptSig:\n\n`\u00a0\u00a0\u00a00\u00a0<Alice/Bob's\u00a0signature>\u00a0<Lenny's\u00a0signature>\u00a01`"
    },
    {
      "header": "Non-interactive time-locked refunds {#non_interactive_time_locked_refunds}",
      "content": "There exist a number of protocols where a transaction output is created\nthat requires the co-operation of both parties to spend the output. To\nensure the failure of one party does not result in the funds becoming\nlost, refund transactions are setup in advance using nLockTime. These\nrefund transactions need to be created interactively, and additionally,\nare currently vulnerable to transaction malleability.\nCHECKLOCKTIMEVERIFY can be used in these protocols, replacing the\ninteractive setup with a non-interactive setup, and additionally, making\ntransaction malleability a non-issue."
    },
    {
      "header": "Two-factor wallets {#two_factor_wallets}",
      "content": "Services like GreenAddress store bitcoins with 2-of-2 multisig\nscriptPubKey\\'s such that one keypair is controlled by the user, and the\nother keypair is controlled by the service. To spend funds the user uses\nlocally installed wallet software that generates one of the required\nsignatures, and then uses a 2nd-factor authentication method to\nauthorize the service to create the second SIGHASH_NONE signature that\nis locked until some time in the future and sends the user that\nsignature for storage. If the user needs to spend their funds and the\nservice is not available, they wait until the nLockTime expires.\n\nThe problem is there exist numerous occasions the user will not have a\nvalid signature for some or all of their transaction outputs. With\nCHECKLOCKTIMEVERIFY rather than creating refund signatures on demand\nscriptPubKeys of the following form are used instead:\n\n`\u00a0\u00a0\u00a0IF`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0``<service pubkey>`{=html}`\u00a0CHECKSIGVERIFY`\\\n`\u00a0\u00a0\u00a0ELSE`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0``<expiry time>`{=html}`\u00a0CHECKLOCKTIMEVERIFY\u00a0DROP`\\\n`\u00a0\u00a0\u00a0ENDIF`\\\n`\u00a0\u00a0\u00a0``<user pubkey>`{=html}`\u00a0CHECKSIG`\n\nNow the user is always able to spend their funds without the\nco-operation of the service by waiting for the expiry time to be\nreached."
    },
    {
      "header": "Payment Channels {#payment_channels}",
      "content": "Jeremy Spilman style payment channels first setup a deposit controlled\nby 2-of-2 multisig, tx1, and then adjust a second transaction, tx2, that\nspends the output of tx1 to payor and payee. Prior to publishing tx1 a\nrefund transaction is created, tx3, to ensure that should the payee\nvanish the payor can get their deposit back. The process by which the\nrefund transaction is created is currently vulnerable to transaction\nmalleability attacks, and additionally, requires the payor to store the\nrefund. Using the same scriptPubKey form as in the Two-factor wallets\nexample solves both these issues."
    },
    {
      "header": "Trustless Payments for Publishing Data {#trustless_payments_for_publishing_data}",
      "content": "The PayPub protocol makes it possible to pay for information in a\ntrustless way by first proving that an encrypted file contains the\ndesired data, and secondly crafting scriptPubKeys used for payment such\nthat spending them reveals the encryption keys to the data. However the\nexisting implementation has a significant flaw: the publisher can delay\nthe release of the keys indefinitely.\n\nThis problem can be solved interactively with the refund transaction\ntechnique; with CHECKLOCKTIMEVERIFY the problem can be non-interactively\nsolved using scriptPubKeys of the following form:\n\n`\u00a0\u00a0\u00a0IF`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0HASH160\u00a0<Hash160(encryption\u00a0key)>\u00a0EQUALVERIFY`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0``<publisher pubkey>`{=html}`\u00a0CHECKSIG`\\\n`\u00a0\u00a0\u00a0ELSE`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0``<expiry time>`{=html}`\u00a0CHECKLOCKTIMEVERIFY\u00a0DROP`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0``<buyer pubkey>`{=html}`\u00a0CHECKSIG`\\\n`\u00a0\u00a0\u00a0ENDIF`\n\nThe buyer of the data is now making a secure offer with an expiry time.\nIf the publisher fails to accept the offer before the expiry time is\nreached the buyer can cancel the offer by spending the output."
    },
    {
      "header": "Proving sacrifice to miners\\' fees {#proving_sacrifice_to_miners_fees}",
      "content": "Proving the sacrifice of some limited resource is a common technique in\na variety of cryptographic protocols. Proving sacrifices of coins to\nmining fees has been proposed as a *universal public good* to which the\nsacrifice could be directed, rather than simply destroying the coins.\nHowever doing so is non-trivial, and even the best existing technqiue -\nannounce-commit sacrifices - could encourage mining centralization.\nCHECKLOCKTIMEVERIFY can be used to create outputs that are provably\nspendable by anyone (thus to mining fees assuming miners behave\noptimally and rationally) but only at a time sufficiently far into the\nfuture that large miners can\\'t profitably sell the sacrifices at a\ndiscount."
    },
    {
      "header": "Freezing Funds {#freezing_funds}",
      "content": "In addition to using cold storage, hardware wallets, and P2SH multisig\noutputs to control funds, now funds can be frozen in UTXOs directly on\nthe blockchain. With the following scriptPubKey, nobody will be able to\nspend the encumbered output until the provided expiry time. This ability\nto freeze funds reliably may be useful in scenarios where reducing\nduress or confiscation risk is desired.\n\n`\u00a0\u00a0\u00a0``<expiry time>`{=html}`\u00a0CHECKLOCKTIMEVERIFY\u00a0DROP\u00a0DUP\u00a0HASH160\u00a0``<pubKeyHash>`{=html}`\u00a0EQUALVERIFY\u00a0CHECKSIG`"
    },
    {
      "header": "Replacing the nLockTime field entirely {#replacing_the_nlocktime_field_entirely}",
      "content": "As an aside, note how if the SignatureHash() algorithm could optionally\ncover part of the scriptSig the signature could require that the\nscriptSig contain CHECKLOCKTIMEVERIFY opcodes, and additionally, require\nthat they be executed. (the CODESEPARATOR opcode came very close to\nmaking this possible in v0.1 of Bitcoin) This per-signature capability\ncould replace the per-transaction nLockTime field entirely as a valid\nsignature would now be the proof that a transaction output *can* be\nspent."
    },
    {
      "header": "Detailed Specification {#detailed_specification}",
      "content": "Refer to the reference implementation, reproduced below, for the precise\nsemantics and detailed rationale for those semantics.\n\n`\u00a0\u00a0\u00a0case\u00a0OP_NOP2:`\\\n`\u00a0\u00a0\u00a0{`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0CHECKLOCKTIMEVERIFY`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0(nLockTime\u00a0--\u00a0nLockTime\u00a0)`\\\n`\u00a0\u00a0\u00a0`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if\u00a0(!(flags\u00a0&\u00a0SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY))`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\u00a0//\u00a0not\u00a0enabled;\u00a0treat\u00a0as\u00a0a\u00a0NOP`\\\n`\u00a0\u00a0\u00a0`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if\u00a0(stack.size()\u00a0<\u00a01)`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0false;`\\\n`\u00a0\u00a0\u00a0`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0Note\u00a0that\u00a0elsewhere\u00a0numeric\u00a0opcodes\u00a0are\u00a0limited\u00a0to`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0operands\u00a0in\u00a0the\u00a0range\u00a0-2**31+1\u00a0to\u00a02**31-1,\u00a0however\u00a0it\u00a0is`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0legal\u00a0for\u00a0opcodes\u00a0to\u00a0produce\u00a0results\u00a0exceeding\u00a0that`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0range.\u00a0This\u00a0limitation\u00a0is\u00a0implemented\u00a0by\u00a0CScriptNum's`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0default\u00a04-byte\u00a0limit.`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0If\u00a0we\u00a0kept\u00a0to\u00a0that\u00a0limit\u00a0we'd\u00a0have\u00a0a\u00a0year\u00a02038\u00a0problem,`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0even\u00a0though\u00a0the\u00a0nLockTime\u00a0field\u00a0in\u00a0transactions`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0themselves\u00a0is\u00a0uint32\u00a0which\u00a0only\u00a0becomes\u00a0meaningless`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0after\u00a0the\u00a0year\u00a02106.`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0Thus\u00a0as\u00a0a\u00a0special\u00a0case\u00a0we\u00a0tell\u00a0CScriptNum\u00a0to\u00a0accept\u00a0up`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0to\u00a05-byte\u00a0bignums,\u00a0which\u00a0are\u00a0good\u00a0until\u00a02**32-1,\u00a0the`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0same\u00a0limit\u00a0as\u00a0the\u00a0nLockTime\u00a0field\u00a0itself.`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const\u00a0CScriptNum\u00a0nLockTime(stacktop(-1),\u00a05);`\\\n`\u00a0\u00a0\u00a0`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0In\u00a0the\u00a0rare\u00a0event\u00a0that\u00a0the\u00a0argument\u00a0may\u00a0be\u00a0<\u00a00\u00a0due\u00a0to`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0some\u00a0arithmetic\u00a0being\u00a0done\u00a0first,\u00a0you\u00a0can\u00a0always\u00a0use`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a00\u00a0MAX\u00a0CHECKLOCKTIMEVERIFY.`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if\u00a0(nLockTime\u00a0<\u00a00)`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0false;`\\\n`\u00a0\u00a0\u00a0`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0There\u00a0are\u00a0two\u00a0types\u00a0of\u00a0nLockTime:\u00a0lock-by-blockheight`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0and\u00a0lock-by-blocktime,\u00a0distinguished\u00a0by\u00a0whether`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0nLockTime\u00a0<\u00a0LOCKTIME_THRESHOLD.`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0We\u00a0want\u00a0to\u00a0compare\u00a0apples\u00a0to\u00a0apples,\u00a0so\u00a0fail\u00a0the\u00a0script`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0unless\u00a0the\u00a0type\u00a0of\u00a0nLockTime\u00a0being\u00a0tested\u00a0is\u00a0the\u00a0same\u00a0as`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0the\u00a0nLockTime\u00a0in\u00a0the\u00a0transaction.`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if\u00a0(!(`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(txTo.nLockTime\u00a0<\u00a0\u00a0LOCKTIME_THRESHOLD\u00a0&&\u00a0nLockTime\u00a0<\u00a0\u00a0LOCKTIME_THRESHOLD)\u00a0||`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(txTo.nLockTime\u00a0>=\u00a0LOCKTIME_THRESHOLD\u00a0&&\u00a0nLockTime\u00a0>=\u00a0LOCKTIME_THRESHOLD)`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0))`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0false;`\\\n`\u00a0\u00a0\u00a0`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0Now\u00a0that\u00a0we\u00a0know\u00a0we're\u00a0comparing\u00a0apples-to-apples,\u00a0the`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0comparison\u00a0is\u00a0a\u00a0simple\u00a0numeric\u00a0one.`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if\u00a0(nLockTime\u00a0>\u00a0(int64_t)txTo.nLockTime)`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0false;`\\\n`\u00a0\u00a0\u00a0`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0Finally\u00a0the\u00a0nLockTime\u00a0feature\u00a0can\u00a0be\u00a0disabled\u00a0and\u00a0thus`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0CHECKLOCKTIMEVERIFY\u00a0bypassed\u00a0if\u00a0every\u00a0txin\u00a0has\u00a0been`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0finalized\u00a0by\u00a0setting\u00a0nSequence\u00a0to\u00a0maxint.\u00a0The`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0transaction\u00a0would\u00a0be\u00a0allowed\u00a0into\u00a0the\u00a0blockchain,\u00a0making`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0the\u00a0opcode\u00a0ineffective.`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0Testing\u00a0if\u00a0this\u00a0vin\u00a0is\u00a0not\u00a0final\u00a0is\u00a0sufficient\u00a0to`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0prevent\u00a0this\u00a0condition.\u00a0Alternatively\u00a0we\u00a0could\u00a0test\u00a0all`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0inputs,\u00a0but\u00a0testing\u00a0just\u00a0this\u00a0input\u00a0minimizes\u00a0the\u00a0data`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0required\u00a0to\u00a0prove\u00a0correct\u00a0CHECKLOCKTIMEVERIFY\u00a0execution.`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if\u00a0(txTo.vin[nIn].IsFinal())`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0false;`\\\n`\u00a0\u00a0\u00a0`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;`\\\n`\u00a0\u00a0\u00a0`\\\n`\u00a0\u00a0\u00a0}`\n\n<https://github.com/petertodd/bitcoin/commit/ab0f54f38e08ee1e50ff72f801680ee84d0f1bf4>"
    },
    {
      "header": "Deployment",
      "content": "We reuse the double-threshold IsSuperMajority() switchover mechanism\nused in BIP66 with the same thresholds, but for nVersion = 4. The new\nrules are in effect for every block (at height H) with nVersion = 4 and\nat least 750 out of 1000 blocks preceding it (with heights H-1000..H-1)\nalso have nVersion \\>= 4. Furthermore, when 950 out of the 1000 blocks\npreceding a block do have nVersion \\>= 4, nVersion \\< 4 blocks become\ninvalid, and all further blocks enforce the new rules.\n\nIt should be noted that BIP9 involves permanently setting a high-order\nbit to 1 which results in nVersion \\>= all prior IsSuperMajority()\nsoft-forks and thus no bits in nVersion are permanently lost."
    },
    {
      "header": "SPV Clients {#spv_clients}",
      "content": "While SPV clients are (currently) unable to validate blocks in general,\ntrusting miners to do validation for them, they are able to validate\nblock headers and thus can validate a subset of the deployment rules.\nSPV clients should reject nVersion \\< 4 blocks if 950 out of 1000\npreceding blocks have nVersion \\>= 4 to prevent false confirmations from\nthe remaining 5% of non-upgraded miners when the 95% threshold has been\nreached."
    },
    {
      "header": "Credits",
      "content": "Thanks goes to Gregory Maxwell for suggesting that the argument be\ncompared against the per-transaction nLockTime, rather than the current\nblock height and time."
    },
    {
      "header": "References",
      "content": "PayPub\n\n-   <https://github.com/unsystem/paypub>\n\nJeremy Spilman Payment Channels\n\n-   <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2013-April/002433.html>"
    },
    {
      "header": "Implementations",
      "content": "Python / python-bitcoinlib\n\n-   <https://github.com/petertodd/checklocktimeverify-demos>\n\nJavaScript / Node.js / bitcore\n\n-   <https://github.com/mruddy/bip65-demos>"
    },
    {
      "header": "Copyright",
      "content": "This document is placed in the public domain."
    }
  ]
}