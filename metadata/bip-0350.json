{
  "BIP": "350",
  "Layer": "Applications",
  "Title": "Bech32m format for v1+ witness addresses",
  "Author": "Pieter Wuille <pieter@wuille.net>",
  "Comments-Summary": "No comments yet.",
  "Comments-URI": "https://github.com/bitcoin/bips/wiki/Comments:BIP-0350",
  "Status": "Draft",
  "Type": "Standards Track",
  "Created": "2020-12-16",
  "License": "BSD-2-Clause",
  "Replaces": "173",
  "Post-History": "2021-01-05: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-January/018338.html [bitcoin-dev] Bech32m BIP: new checksum, and usage for segwit address",
  "sections": [
    {
      "header": "Introduction",
      "content": "### Abstract\n\nThis document defines an improved variant of Bech32 called **Bech32m**,\nand amends BIP173 to use Bech32m for native segregated witness outputs\nof version 1 and later. Bech32 remains in use for segregated witness\noutputs of version 0."
    },
    {
      "header": "Copyright",
      "content": "This BIP is licensed under the 2-clause BSD license."
    },
    {
      "header": "Motivation",
      "content": "[BIP173](bip-0173.mediawiki \"wikilink\") defined a generic checksummed\nbase 32 encoded format called Bech32. It is in use for segregated\nwitness outputs of version 0 (P2WPKH and P2WSH, see\n[BIP141](bip-0141.mediawiki \"wikilink\")), and other applications.\n\nBech32 has an unexpected\n[weakness](https://github.com/sipa/bech32/issues/51): whenever the final\ncharacter is a \\'p\\', inserting or deleting any number of \\'q\\'\ncharacters immediately preceding it does not invalidate the checksum.\nThis does not affect existing uses of witness version 0 BIP173 addresses\ndue to their restriction to two specific lengths, but may affect future\nuses and/or other applications using the Bech32 encoding.\n\nThis document addresses that by specifying Bech32m, a variant of Bech32\nthat mitigates this insertion weakness and related issues."
    },
    {
      "header": "Specification",
      "content": "We first specify the new checksum algorithm, and then document how it\nshould be used for future Bitcoin addresses."
    },
    {
      "header": "Bech32m",
      "content": "Bech32m modifies the checksum of the Bech32 specification, replacing the\nconstant *1* that is xored into the checksum at the end with\n*0x2bc830a3*. The resulting checksum verification and creation algorithm\n(in Python, cf. the code in [Bech32\nsection](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#Bech32%7CBIP173)):\n\nBECH32M_CONST = 0x2bc830a3\n\ndef bech32m_polymod(values):\nGEN = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3]\nchk = 1\nfor v in values:\nb = (chk >> 25)\nchk = (chk & 0x1ffffff) << 5 ^ v\nfor i in range(5):\nchk ^= GEN[i] if ((b >> i) & 1) else 0\nreturn chk\n\ndef bech32m_hrp_expand(s):\nreturn [ord(x) >> 5 for x in s] + [0] + [ord(x) & 31 for x in s]\n\ndef bech32m_verify_checksum(hrp, data):\nreturn bech32m_polymod(bech32m_hrp_expand(hrp) + data) == BECH32M_CONST\n\ndef bech32m_create_checksum(hrp, data):\nvalues = bech32m_hrp_expand(hrp) + data\npolymod = bech32m_polymod(values + [0,0,0,0,0,0]) ^ BECH32M_CONST\nreturn [(polymod >> 5 * (5 - i)) & 31 for i in range(6)]\n\nAll other aspects of Bech32 remain unchanged, including its\nhuman-readable parts (HRPs).\n\nA combined function to decode both Bech32 and Bech32m simultaneously\ncould be written using:\n\nclass Encoding(Enum):\nBECH32 = 1\nBECH32M = 2\n\ndef bech32_bech32m_verify_checksum(hrp, data):\ncheck = bech32_polymod(bech32_hrp_expand(hrp) + data)\nif check == 1:\nreturn Encoding.BECH32\nelif check == BECH32M_CONST:\nreturn Encoding.BECH32M\nelse:\nreturn None\n\nwhich returns either None for failure, or one of the BECH32 / BECH32M\nenumeration values to indicate successful decoding according to the\nrespective standard."
    },
    {
      "header": "Addresses for segregated witness outputs {#addresses_for_segregated_witness_outputs}",
      "content": "Version 0 outputs (specifically, P2WPKH and P2WSH addresses) continue to\nuse Bech32[^1] as specified in BIP173. Addresses for segregated witness\noutputs version 1 through 16 use Bech32m. Again, all other aspects of\nthe encoding remain the same, including the \\'bc\\' HRP.\n\nTo generate an address for a segregated witness output:\n\n-   If its witness version is 0, encode it using Bech32.\n-   If its witness version is 1 or higher, encode it using Bech32m.\n\nTo decode an address, client software should either decode with both a\nBech32 and a Bech32m decoder[^2], or use a decoder that supports both\nsimultaneously. In both cases, the address decoder has to verify that\nthe encoding matches what is expected for the decoded witness version\n(Bech32 for version 0, Bech32m for others).\n\nThe following code demonstrates the checks that need to be performed.\nRefer to the Python code linked in the reference implementation section\nbelow for full details of the called functions.\n\ndef decode(hrp, addr):\nhrpgot, data, spec = bech32_decode(addr)\nif hrpgot != hrp:\nreturn (None, None)\ndecoded = convertbits(data[1:], 5, 8, False)"
    },
    {
      "header": "Witness programs are between 2 and 40 bytes in length.",
      "content": "if decoded is None or len(decoded) < 2 or len(decoded) > 40:\nreturn (None, None)"
    },
    {
      "header": "Witness versions are in range 0..16.",
      "content": "if data[0] > 16:\nreturn (None, None)"
    },
    {
      "header": "Witness v0 programs must be exactly length 20 or 32.",
      "content": "if data[0] == 0 and len(decoded) != 20 and len(decoded) != 32:\nreturn (None, None)"
    },
    {
      "header": "Witness v0 uses Bech32; v1 through v16 use Bech32m.",
      "content": "if data[0] == 0 and spec != Encoding.BECH32 or data[0] != 0 and spec != Encoding.BECH32M:\nreturn (None, None)"
    },
    {
      "header": "Success.",
      "content": "return (data[0], decoded)\n\n**Error locating**\n\nBech32m, like Bech32, does support locating[^3] the positions of a few\nsubstitution errors. To combine this functionality with the segregated\nwitness addresses proposed by this document, simply try locating errors\nfor both Bech32 and Bech32m. If only one finds error locations, report\nthat one. If both do (which should be very rare), there are a number of\noptions:\n\n-   Report the one that needs fewer corrections (if they differ).\n-   Eliminate the response(s) that are inconsistent. Any symbol that\nisn\\'t on an error location can be checked. For example, if the\nwitness version symbol is not an error location, and it doesn\\'t\ncorrespond to the specification used (0 for Bech32, 1+ for Bech32m),\nthat response can be eliminated.\n\nSee the fancy Javascript decoder below for example of the above."
    },
    {
      "header": "Compatibility",
      "content": "This document introduces a new encoding for v1 segregated witness\noutputs and higher versions. There should not be any compatibility\nissues on the receiver side; no wallets are creating v1 segregated\nwitness addresses yet, as the output type is not usable on mainnet.\n\nOn the other hand, the Bech32m proposal breaks forward-compatibility for\nsending to v1 and higher version segregated witness addresses. This\nincompatibility is\n[intentional](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-October/018236.html).\nAn alternative design was\n[considered](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-November/017460.html)\nwhere Bech32 remained in use for certain subsets of future addresses,\nbut ultimately\n[discarded](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-December/018293.html).\nBy introducing a clean break, we protect not only new software but also\nexisting senders from the mutation issue, as new addresses will be\nincompatible with the existing Bech32 address validation.\n[Experiments](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-November/018268.html)\nby Taproot proponents had shown that hardly any wallets and services\nsupported sending to higher segregated witness output versions, so\nlittle is lost by\n[breaking](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-December/018298.html)\nforward-compatibility. Furthermore, those experiments identified cases\nin which segregated witness implementations would have caused wallets to\nburn funds when sending to version 1 addresses. In case it is still in\nuse, the chosen approach will prevent such software from destroying\nfunds when attempting to send to a Bech32m address."
    },
    {
      "header": "Reference implementations {#reference_implementations}",
      "content": "-   Reference encoder and decoder:\n-   [Reference Python\nimplementation](https://github.com/sipa/bech32/blob/master/ref/python)\n-   [Reference C\nimplementation](https://github.com/sipa/bech32/blob/master/ref/c)\n-   [Reference C++\nimplementation](https://github.com/sipa/bech32/blob/master/ref/c++)\n-   [Bitcoin Core C++\nimplementation](https://github.com/bitcoin/bitcoin/pull/20861)\n-   [Reference Javascript\nimplementation](https://github.com/sipa/bech32/blob/master/ref/javascript)\n\n```{=html}\n<!-- -->\n```\n-   Fancy decoder that localizes errors:\n-   [For\nJavaScript](https://github.com/sipa/bech32/blob/master/ecc/javascript)\n([demo website](http://bitcoin.sipa.be/bech32/demo/demo.html))"
    },
    {
      "header": "Test vectors {#test_vectors}",
      "content": "**Implementation advice** Experiments testing BIP173 implementations\nfound that many wallets and services did not support sending to higher\nversion segregated witness outputs. In anticipation of the proposed\n[Taproot](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki)\nsoft fork introducing v1 segregated witness outputs on the network, we\nemphatically recommend employing the complete set of test vectors\nprovided below as well as ensuring that your implementation supports\nsending to v1 **and higher versions**. All higher versions of native\nsegregated witness outputs should be recognized as valid recipients. As\nhigher versions are not defined on the network, no wallet should ever\ncreate them and no recipient should ever provide them to a sender. Nor\nshould a recipient ever want to falsely provide them as the recipient\nwould simply see a payment intended to themselves burned instead.\nHowever, by defining higher versions as valid recipients now, future\nsoft forks introducing higher versions of native segwit outputs will be\nforward-compatible to all wallets correctly implementing the Bech32m\nspecification."
    },
    {
      "header": "Test vectors for Bech32m {#test_vectors_for_bech32m}",
      "content": "The following strings are valid Bech32m:\n\n-   `A1LQFN3A`\n-   `a1lqfn3a`\n-   `an83characterlonghumanreadablepartthatcontainsthetheexcludedcharactersbioandnumber11sg7hg6`\n-   `abcdef1l7aum6echk45nj3s0wdvt2fg8x9yrzpqzd3ryx`\n-   `11llllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllludsr8`\n-   `split1checkupstagehandshakeupstreamerranterredcaperredlc445v`\n-   `?1v759aa`\n\nNo string can be simultaneously valid Bech32 and Bech32m, so the above\nexamples also serve as invalid test vectors for Bech32.\n\nThe following string are not valid Bech32m (with reason for invalidity):\n\n-   0x20 + `1xj0phk`: HRP character out of range\n-   0x7F + `1g6xzxy`: HRP character out of range\n-   0x80 + `1vctc34`: HRP character out of range\n-   `an84characterslonghumanreadablepartthatcontainsthetheexcludedcharactersbioandnumber11d6pts4`:\noverall max length exceeded\n-   `qyrz8wqd2c9m`: No separator character\n-   `1qyrz8wqd2c9m`: Empty HRP\n-   `y1b0jsk6g`: Invalid data character\n-   `lt1igcx5c0`: Invalid data character\n-   `in1muywd`: Too short checksum\n-   `mm1crxm3i`: Invalid character in checksum\n-   `au1s5cgom`: Invalid character in checksum\n-   `M1VUXWEZ`: checksum calculated with uppercase form of HRP\n-   `16plkw9`: empty HRP\n-   `1p2gdwpf`: empty HRP"
    },
    {
      "header": "Test vectors for v0-v16 native segregated witness addresses {#test_vectors_for_v0_v16_native_segregated_witness_addresses}",
      "content": "The following list gives valid segwit addresses and the scriptPubKey\nthat they translate to in hex.\n\n-   `BC1QW508D6QEJXTDG4Y5R3ZARVARY0C5XW7KV8F3T4`:\n`0014751e76e8199196d454941c45d1b3a323f1433bd6`\n-   `tb1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3q0sl5k7`:\n`00201863143c14c5166804bd19203356da136c985678cd4d27a1b8c6329604903262`\n-   `bc1pw508d6qejxtdg4y5r3zarvary0c5xw7kw508d6qejxtdg4y5r3zarvary0c5xw7kt5nd6y`:\n`5128751e76e8199196d454941c45d1b3a323f1433bd6751e76e8199196d454941c45d1b3a323f1433bd6`\n-   `BC1SW50QGDZ25J`: `6002751e`\n-   `bc1zw508d6qejxtdg4y5r3zarvaryvaxxpcs`:\n`5210751e76e8199196d454941c45d1b3a323`\n-   `tb1qqqqqp399et2xygdj5xreqhjjvcmzhxw4aywxecjdzew6hylgvsesrxh6hy`:\n`0020000000c4a5cad46221b2a187905e5266362b99d5e91c6ce24d165dab93e86433`\n-   `tb1pqqqqp399et2xygdj5xreqhjjvcmzhxw4aywxecjdzew6hylgvsesf3hn0c`:\n`5120000000c4a5cad46221b2a187905e5266362b99d5e91c6ce24d165dab93e86433`\n-   `bc1p0xlxvlhemja6c4dqv22uapctqupfhlxm9h8z3k2e72q4k9hcz7vqzk5jj0`:\n`512079be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798`\n\nThe following list gives invalid segwit addresses and the reason for\ntheir invalidity.\n\n-   `tc1p0xlxvlhemja6c4dqv22uapctqupfhlxm9h8z3k2e72q4k9hcz7vq5zuyut`:\nInvalid human-readable part\n-   `bc1p0xlxvlhemja6c4dqv22uapctqupfhlxm9h8z3k2e72q4k9hcz7vqh2y7hd`:\nInvalid checksum (Bech32 instead of Bech32m)\n-   `tb1z0xlxvlhemja6c4dqv22uapctqupfhlxm9h8z3k2e72q4k9hcz7vqglt7rf`:\nInvalid checksum (Bech32 instead of Bech32m)\n-   `BC1S0XLXVLHEMJA6C4DQV22UAPCTQUPFHLXM9H8Z3K2E72Q4K9HCZ7VQ54WELL`:\nInvalid checksum (Bech32 instead of Bech32m)\n-   `bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kemeawh`: Invalid checksum\n(Bech32m instead of Bech32)\n-   `tb1q0xlxvlhemja6c4dqv22uapctqupfhlxm9h8z3k2e72q4k9hcz7vq24jc47`:\nInvalid checksum (Bech32m instead of Bech32)\n-   `bc1p38j9r5y49hruaue7wxjce0updqjuyyx0kh56v8s25huc6995vvpql3jow4`:\nInvalid character in checksum\n-   `BC130XLXVLHEMJA6C4DQV22UAPCTQUPFHLXM9H8Z3K2E72Q4K9HCZ7VQ7ZWS8R`:\nInvalid witness version\n-   `bc1pw5dgrnzv`: Invalid program length (1 byte)\n-   `bc1p0xlxvlhemja6c4dqv22uapctqupfhlxm9h8z3k2e72q4k9hcz7v8n0nx0muaewav253zgeav`:\nInvalid program length (41 bytes)\n-   `BC1QR508D6QEJXTDG4Y5R3ZARVARYV98GJ9P`: Invalid program length for\nwitness version 0 (per BIP141)\n-   `tb1p0xlxvlhemja6c4dqv22uapctqupfhlxm9h8z3k2e72q4k9hcz7vq47Zagq`:\nMixed case\n-   `bc1p0xlxvlhemja6c4dqv22uapctqupfhlxm9h8z3k2e72q4k9hcz7v07qwwzcrf`:\nzero padding of more than 4 bits\n-   `tb1p0xlxvlhemja6c4dqv22uapctqupfhlxm9h8z3k2e72q4k9hcz7vpggkg4j`:\nNon-zero padding in 8-to-5 conversion\n-   `bc1gmk9yu`: Empty data section"
    },
    {
      "header": "Appendix: checksum design & properties {#appendix_checksum_design_properties}",
      "content": "Checksums are used to detect errors introduced into data during\ntransfer. A hash function-based checksum such as Base58Check detects any\ntype of error uniformly, but not all classes of errors are equally\nlikely to occur in practice. Bech32 prioritizes detection of\nsubstitution errors, but improving detection of one error class\ninevitably worsens detection of other error classes. During the design\nof Bech32, it was assumed that other simple error patterns beside\nsubstitutions would have a similar detection rate as in a hash\nfunction-based design, and detection would only be worse for complex,\nimpractical errors. The discovered insertion weakness shows that this is\nnot the case.\n\nFor Bech32m, we aim to retain Bech32\\'s guarantees for substitution\nerrors, but make sure that other common errors don\\'t perform worse than\na hash function-based checksum would. To make sure the new standard is\neasy to implement, we restrict the design space to only amending the\nfinal constant that is xored in, as it was\n[observed](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-December/017521.html)\nthat that is sufficient to mitigate the \\'q\\' insertion issue while\nretaining the intended substitution error detection. In what follows, we\nexplain how the new constant *0x2bc830a3* was chosen."
    },
    {
      "header": "Error patterns & detection probability {#error_patterns_detection_probability}",
      "content": "We define an error pattern as a sequence of first one or more deletions,\nthen swaps of adjacent characters, followed by substitutions,\ninsertions, and duplications, in that order, all in specific positions,\napplied to a string with valid checksum that is otherwise randomly\nchosen. For insertions and substitutions we assume a uniformly random\nnew character. For example, \\\"delete the 17th character, swap the 11th\ncharacter with the 12th character, and insert a random character in the\n24th position\\\" is an error pattern. \\\"Replace the 43rd through 48th\ncharacter with \\'aardvark\\'\\\" is not a valid error pattern, because the\nnew characters are not random and there is no reason why this particular\nstring is more likely than any other to be substituted.\n\nA hash function-based checksum design with a 30-bit hash would have a\nprobability of incorrectly accepting equal to *2^-30^*, for every error\npattern. Bech32 has a probability of 0 to incorrectly accept error\npatterns consisting of up to 4 substitutions---they are always detected.\nThe \\'q\\'-insertion issue shows that for Bech32 a simple error pattern\n(\\\"insert a random character in the penultimate position\\\") with\nprobability *2^-10^* exists: it requires the final character to be \\'p\\'\n(leaving only 1 in 32 strings), and requires the inserted character to\nbe \\'q\\' (permitting only 1 of 32 possible inserted characters).\n\nNote that the choice of *what* the error pattern is (which types of\nerrors, and where) isn\\'t part of our probabilities: we try to make sure\nthat *every* pattern behaves well, not just randomly chosen ones,\nbecause presumably humans make some kinds of errors more than others,\nand we cannot easily model which ones."
    },
    {
      "header": "Detection properties of Bech32m {#detection_properties_of_bech32m}",
      "content": "The table below shows the error detection properties of Bech32m, and a\ncomparison with Bech32. The code used for this analysis can be found\n[here](https://gist.github.com/sipa/14c248c288c3880a3b191f978a34508e#file-const_analysis-cpp).\nEvery row specifies one error pattern via the constraints in the left\nfour columns. The remaining columns report what percentage of those\npatterns have certain probabilities of not being detected. The columns\nare:\n\n-   **errors** The maximum number of individual errors considered\n-   **of type** What type of errors are considered (either \\\"subst.\nonly\\\" for just substitutions, or \\\"any\\\" to also include deletions,\nswaps, insertions, and duplications)\n-   **window** The maximum size of the window in which the errors have\nto occur[^4]\n-   **code/verifier** Whether this line is about Bech32 or Bech32m\nencoded strings, and whether those are evaluated regarding their\nprobability of being accepted by either a Bech32 or a Bech32m\nverifier.[^5][^6]\n-   **error patterns with failure probability** For each probability\n(*0*, *2^-30^*, *2^-25^*, *2^-20^*, *2^-15^*, and *2^-10^*) this\nreports what percentage of error patterns restricted by the\nconstraints in the previous columns have those probabilities of\nbeing incorrectly accepted.\n\nThe properties are divided into two classes: those that hold over all\nstrings when averaged over all possible HRPs (human readable parts), and\nthose specific to the \\\"bc1\\\" HRP with the length restrictions imposed\nby segregated witness addresses[^7].\n\nerrors                                                        of type       window     code/verifier     error patterns with failure probability\n------------------------------------------------------------- ------------- ---------- ----------------- -----------------------------------------\n*0*                                                           *2^-30^*      *2^-25^*   *2^-20^*          *2^-15^*\nProperties averaged over all HRPs                                                                        \n\u2264 4                                                           only subst.   any        Bech32m/Bech32m   100.00%\nany                                                           any           \u2264 4                          56.16%\n\u2264 2                                                           any           \u2264 68                         7.71%\n\u2264 2                                                           any           any                          7.79%\n\u2264 3                                                           any           \u2264 69                         7.73%\n\u2264 3                                                           any           any                          7.77%\n\u2264 4                                                           only subst.   any        Bech32/Bech32     100.00%\nany                                                           any           \u2264 4                          54.00%\n\u2264 2                                                           any           \u2264 68                         4.59%\n\u2264 2                                                           any           any                          4.58%\n\u2264 3                                                           any           \u2264 69                         6.69%\n\u2264 3                                                           any           any                          6.66%\n0                                                             \\-            \\-         Bech32m/Bech32    100.00%\n1                                                             any           \\-                           46.53%\n\u2264 2                                                           any           any                          22.18%\nProperties for segregated witness addresses with HRP \\\"bc\\\"                                              \n\u2264 4                                                           only subst.   any        Bech32m/Bech32m   100.00%\n1                                                             any           \\-                           24.34%\n\u2264 2                                                           any           \u2264 28                         16.85%\nany                                                           any           \u2264 4                          74.74%\n\u2264 2                                                           any           any                          15.72%\n\u2264 3                                                           any           any                          13.98%\n\u2264 4                                                           only subst.   any        Bech32/Bech32     100.00%\n1                                                             any           \\-                           14.63%\n\u2264 2                                                           any           \u2264 28                         14.22%\nany                                                           any           \u2264 4                          73.23%\n\u2264 2                                                           any           any                          12.79%\n\u2264 3                                                           any           any                          13.00%\n\u2264 3                                                           only subst.   any        Bech32m/Bech32    100.00%\n1                                                             any           \\-                           70.89%\n\u2264 2                                                           any           any                          36.12%\n\nThe numbers in this table, as well as a comparison with the numbers for\nthe ''1'' constant and earlier proposed improved constants, can be found\n[here](https://gist.github.com/sipa/14c248c288c3880a3b191f978a34508e#file-results_final-txt)."
    },
    {
      "header": "Selection process {#selection_process}",
      "content": "The details of the selection process can be found\n[here](https://gist.github.com/sipa/14c248c288c3880a3b191f978a34508e),\nbut in short:\n\n-   Start with the set of all *2^30^-1* constants different from\nBech32\\'s *1*. All of these satisfy the properties marked ^(a)^ in\nthe table above.\n-   Through exhaustive analysis, reject all constants that do not\nexhibit the properties[^8] marked ^(b)^ in the table above (e.g. all\nconstants that permit any error pattern of 2 errors or less in a\nwindow of 68 characters or less with a detection probability *\u2265\n2^-20^*). This selection leaves us with 12054 candidates.\n-   Reject all constants that do not exhibit the ^(c)^ properties in the\ntable above[^9]. This leaves us with 79 candidates.\n-   Finally, select the candidate that minimizes the number of error\nclasses matching ^(d)^ in the table above as a final tiebreaker. The\nresult is the single constant *0x2bc830a3*."
    },
    {
      "header": "Footnotes",
      "content": "```{=html}\n<references />\n```"
    },
    {
      "header": "Acknowledgements",
      "content": "Thanks to Greg Maxwell for doing most of the computation for code\nselection and analysis, and comments. Thanks to Mark Erhardt for help\nwith writing and editing this document. Thanks to Rusty Russell and\nothers on the bitcoin-dev list for the discussion around intentionally\nbreaking compatibility with existing senders, which is used in this\nspecification.\n\n[^1]: **Why not permit both Bech32 and Bech32m for v0 addresses?**\nPermitting both encodings reduces the error detection capabilities\n(it makes it equivalent to only have 29 bits of checksum).\n\n[^2]: **Can a single string simultaneously be valid as Bech32 and\nBech32m?** No, a valid Bech32 and Bech32m string will always differ\nby at least 3 characters if they are the same length.\n\n[^3]: **What about error correction?** As explained in BIP173,\nintroducing error correction reduces the ability to detect errors.\nWhile it is technically possible to correct a small number of errors\ndue to Bech32(m)\\'s nature as a BCH code, implementations should\nrefrain from using this for more than indicating where an error may\nbe present.\n\n[^4]: **What is an error pattern's window size?** The window size of an\nerror pattern is the length of the smallest consecutive range of\ncharacters that contains all modified characters (on input or\noutput; whichever is larger). For example, an error pattern that\nturns \\\"abcdef\\\" into \\\"accdbef\\\" has a window size of 4, as it is\nreplacing \\\"bcd\\\" with \\\"ccdb\\\", a 4 character string. Window size\nis only meaningful when the pattern consists of two or more errors.\n\n[^5]: **Why do we care about probability of accepting Bech32m strings in\nBech32 verifiers?** For applications where Bech32m replaces an\nexisting use of Bech32 (such as segregated witness addresses), we\nwant to make sure that a Bech32m string created by new software\nwon't be erroneously accepted by old software that assumes Bech32 -\neven when a small number of errors were introduced as well.\n\n[^6]: **Should we also take into account failures that occur due to\ntaking a valid Bech32m string, and after errors it becoming\nacceptable to a Bech32 verifier?** This situation may in theory\noccur for segregated witness addresses when errors occur that change\nthe version number in a v1+ address to v0. Due to the specificity of\nthis type of error, plus the additional constraints that apply for\nv0 addresses, this is both unlikely and hard to analyze.\n\n[^7]: **What restrictions were taken into account for the\n\\\"bc1\\\"-specific analysis?** The minimum length (due to witness\nprograms being at least 2 bytes), the maximum length (due to witness\nprograms being at most 40 bytes), and the fact that the witness\nprograms are a multiple of 8 bits. The fact that the first data\nsymbol cannot be over 16, or that the padding has to be 0, is not\ntaken into account.\n\n[^8]: **How were the properties to select for chosen?** All these\nproperties are as strong as they can be without rejecting every\nconstant: rejecting constants with lower probabilities, or more\nerrors, or wider windows all result in nothing left.\n\n[^9]: **Why optimize for segregated witness addresses (with HRP \\\"bc1\\\")\nspecifically?** Our analysis for generic HRP has limitations (see\nthe detailed description\n[here](https://gist.github.com/sipa/14c248c288c3880a3b191f978a34508e#file-bech32m_mail-txt),\nunder \\\"Technical details\\\"). We optimize for generic usage first,\nbut optimize for segregated witness addresses as a tiebreaker."
    }
  ]
}