{
  "BIP": "8",
  "Title": "Version bits with lock-in by height",
  "Author": "Shaolin Fry <shaolinfry@protonmail.ch>",
  "Comments-Summary": "No comments yet.",
  "Comments-URI": "https://github.com/bitcoin/bips/wiki/Comments:BIP-0008",
  "Status": "Draft",
  "Type": "Informational",
  "Created": "2017-02-01",
  "License": "BSD-3-Clause",
  "sections": [
    {
      "header": "Abstract",
      "content": "This document specifies an alternative to\n[BIP9](bip-0009.mediawiki \"wikilink\") that corrects for a number of\nperceived mistakes. Block heights are used for start and timeout rather\nthan POSIX timestamps. It additionally introduces an activation\nparameter that can guarantee activation of backward-compatible changes\n(further called \\\"soft forks\\\").\n\nThe key words \\\"MUST\\\", \\\"MUST NOT\\\", \\\"REQUIRED\\\", \\\"SHALL\\\", \\\"SHALL\nNOT\\\", \\\"SHOULD\\\", \\\"SHOULD NOT\\\", \\\"RECOMMENDED\\\", \\\"MAY\\\", and\n\\\"OPTIONAL\\\" in this document are to be interpreted as described in RFC\n2119."
    },
    {
      "header": "Motivation",
      "content": "BIP9 introduced a mechanism for doing parallel soft forking deployments\nbased on repurposing the block nVersion field. Activation is dependent\non near unanimous hashrate signalling which may be impractical and\nresult in veto by a small minority of non-signalling hashrate. Super\nmajority hashrate based activation triggers allow for accelerated\nactivation where the majority hash power enforces the new rules in lieu\nof full nodes upgrading. Since all consensus rules are ultimately\nenforced by full nodes, eventually any new soft fork will be enforced by\nthe economy. This proposal combines these two aspects to provide\noptional flag day activation after a reasonable time, as well as for\naccelerated activation by majority of hash rate before the flag date.\n\nDue to using timestamps rather than block heights, it was found to be a\nrisk that a sudden loss of significant hashrate could interfere with a\nlate activation.\n\nBlock time is somewhat unreliable and may be intentionally or\nunintentionally inaccurate, so thresholds based on block time are not\nideal. Secondly, BIP9 specified triggers based on the first retarget\nafter a given time, which is non-intuitive. Since each new block must\nincrease the height by one, thresholds based on block height are much\nmore reliable and intuitive and can be calculated exactly for difficulty\nretarget."
    },
    {
      "header": "Specification",
      "content": "### Parameters\n\nEach soft fork deployment is specified by the following per-chain\nparameters (further elaborated below):\n\n1.  The **name** specifies a very brief description of the soft fork,\nreasonable for use as an identifier.\n2.  The **bit** determines which bit in the nVersion field of the block\nis to be used to signal the soft fork lock-in and activation. It is\nchosen from the set {0,1,2,\\...,28}.\n3.  The **startheight** specifies the height of the first block at which\nthe bit gains its meaning.\n4.  The **timeoutheight** specifies a block height at which the miner\nsignalling ends. Once this height has been reached, if the soft fork\nhas not yet locked in (excluding this block\\'s bit state), the\ndeployment is considered failed on all descendants of the block.\n5.  The **threshold** specifies the minimum number of block per retarget\nperiod which indicate lock-in of the soft fork during the subsequent\nperiod.\n6.  The **minimum_activation_height** specifies the height of the first\nblock at which the soft fork is allowed to become active.\n7.  The **lockinontimeout** boolean if set to true, blocks are required\nto signal in the final period, ensuring the soft fork has locked in\nby timeoutheight."
    },
    {
      "header": "Selection guidelines {#selection_guidelines}",
      "content": "The following guidelines are suggested for selecting these parameters\nfor a soft fork:\n\n1.  **name** should be selected such that no two softforks, concurrent\nor otherwise, ever use the same name. For deployments described in a\nsingle BIP, it is recommended to use the name \\\"bipN\\\" where N is\nthe appropriate BIP number.\n2.  **bit** should be selected such that no two concurrent softforks use\nthe same bit. The bit chosen should not overlap with active usage\n(legitimately or otherwise) for other purposes.\n3.  **startheight** should be set to some block height in the future. If\n**minimum_activation_height** is not going to be set, then\n**startheight** should be set to a height when a majority of\neconomic activity is expected to have upgraded to software including\nthe activation parameters. Some allowance should be made for\npotential release delays. If **minimum_activation_height** is going\nto be set, then **startheight** can be set to be soon after software\nwith parameters is expected to be released. This shifts the time for\nupgrading from before signaling begins to during the LOCKED_IN\nstate.\n4.  **timeoutheight** should be set to a block height when it is\nconsidered reasonable to expect the entire economy to have upgraded\nby, probably at least 1 year, or 52416 blocks (26 retarget\nintervals) after **startheight**.\n5.  **threshold** should be 1815 blocks (90% of 2016), or 1512 (75%) for\ntestnet.\n6.  **minimum_activation_height** should be set to several retarget\nperiods in the future if the **startheight** is to be very soon\nafter software with parameters is expected to be released.\n**minimum_activation_height** should be set to a height when a\nmajority of economic activity is expected to have upgraded to\nsoftware including the activation parameters. This allows more time\nto be spent in the LOCKED_IN state so that nodes can upgrade. This\nmay be set to 0 to have the LOCKED_IN state be a single retarget\nperiod.\n7.  **lockinontimeout** should be set to true for any softfork that is\nexpected or found to have political opposition from a non-negligible\npercent of miners. (It can be set after the initial deployment, but\ncannot be cleared once set.)\n\nA later deployment using the same bit is possible as long as the\nstartheight is after the previous one\\'s timeoutheight or activation,\nbut it is discouraged until necessary, and even then recommended to have\na pause in between to detect buggy software.\n\n**startheight**, **timeoutheight**, and **minimum_activation_height**\nmust be an exact multiple of 2016 (ie, at a retarget boundary), and\n**timeoutheight** must be at least 4032 blocks (2 retarget intervals)\nafter **startheight**."
    },
    {
      "header": "States",
      "content": "With each block and soft fork, we associate a deployment state. The\npossible states are:\n\n1.  **DEFINED** is the first state that each soft fork starts out as.\nThe genesis block is by definition in this state for each\ndeployment.\n2.  **STARTED** for blocks at or beyond the startheight.\n3.  **MUST_SIGNAL** for one retarget period prior to the timeout, if\nLOCKED_IN was not reached and **lockinontimeout** is true.\n4.  **LOCKED_IN** for at least one retarget period after the first\nretarget period with STARTED (or MUST_SIGNAL) blocks of which at\nleast threshold have the associated bit set in nVersion. A soft fork\nremains in LOCKED_IN until at least **minimum_activation_height** is\nreached.\n5.  **ACTIVE** for all blocks after the LOCKED_IN state.\n6.  **FAILED** for all blocks after the timeoutheight if LOCKED_IN is\nnot reached."
    },
    {
      "header": "Bit flags {#bit_flags}",
      "content": "The nVersion block header field is to be interpreted as a 32-bit\nlittle-endian integer (as present), and bits are selected within this\ninteger as values (1 \\<\\< N) where N is the bit number.\n\nBlocks in the STARTED state get an nVersion whose bit position bit is\nset to 1. The top 3 bits of such blocks must be 001, so the range of\nactually possible nVersion values is \\[0x20000000\\...0x3FFFFFFF\\],\ninclusive.\n\nDue to the constraints set by BIP 34, BIP 66 and BIP 65, we only have\n0x7FFFFFFB possible nVersion values available. This restricts us to at\nmost 30 independent deployments. By restricting the top 3 bits to 001 we\nget 29 out of those for the purposes of this proposal, and support two\nfuture upgrades for different mechanisms (top bits 010 and 011). When a\nblock nVersion does not have top bits 001, it is treated as if all bits\nare 0 for the purposes of deployments.\n\nMiners should continue setting the bit in LOCKED_IN phase so uptake is\nvisible, though this has no effect on consensus rules."
    },
    {
      "header": "New consensus rules {#new_consensus_rules}",
      "content": "The new consensus rules for each soft fork are enforced for each block\nthat has ACTIVE state.\n\nDuring the MUST_SIGNAL phase, if **(2016 - threshold)** blocks in the\nretarget period have already failed to signal, any further blocks that\nfail to signal are invalid."
    },
    {
      "header": "State transitions {#state_transitions}",
      "content": "`<img src=\"bip-0008/states.png\" align=\"middle\">`{=html}`</img>`{=html}\n\nNote that when **lockinontimeout** is true, the LOCKED_IN state will be\nreached no later than at a height of **timeoutheight**. Regardless of\nthe value of **lockinontimeout**, if LOCKED_IN is reached, ACTIVE will\nbe reached either one retarget period later, or at\n**minimum_activation_height**, whichever comes later.\n\nThe genesis block has state DEFINED for each deployment, by definition.\n\n`\u00a0\u00a0\u00a0State\u00a0GetStateForBlock(block)\u00a0{`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if\u00a0(block.height\u00a0==\u00a00)\u00a0{`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0DEFINED;`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}`\n\nAll blocks within a retarget period have the same state. This means that\nif floor(block1.height / 2016) = floor(block2.height / 2016), they are\nguaranteed to have the same state for every deployment.\n\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if\u00a0((block.height\u00a0%\u00a02016)\u00a0!=\u00a00)\u00a0{`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0GetStateForBlock(block.parent);`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}`\n\nOtherwise, the next state depends on the previous state:\n\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0switch\u00a0(GetStateForBlock(GetAncestorAtHeight(block,\u00a0block.height\u00a0-\u00a02016)))\u00a0{`\n\nWe remain in the initial state until we reach the start block height.\n\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case\u00a0DEFINED:`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if\u00a0(block.height\u00a0>=\u00a0startheight)\u00a0{`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0STARTED;`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0DEFINED;`\n\nAfter a period in the STARTED state, we tally the bits set, and\ntransition to LOCKED_IN if a sufficient number of blocks in the past\nperiod set the deployment bit in their version numbers. If the threshold\nhasn\\'t been met, lockinontimeout is true, and we are at the last period\nbefore the timeout, then we transition to MUST_SIGNAL. If the threshold\nhasn\\'t been met and we reach the timeout, we transition directly to\nFAILED.\n\nNote that a block\\'s state never depends on its own nVersion; only on\nthat of its ancestors.\n\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case\u00a0STARTED:`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int\u00a0count\u00a0=\u00a00;`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0walk\u00a0=\u00a0block;`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for\u00a0(i\u00a0=\u00a00;\u00a0i\u00a0<\u00a02016;\u00a0i++)\u00a0{`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0walk\u00a0=\u00a0walk.parent;`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if\u00a0(walk.nVersion\u00a0&\u00a00xE0000000\u00a0==\u00a00x20000000\u00a0&&\u00a0(walk.nVersion\u00a0>>\u00a0bit)\u00a0&\u00a01\u00a0==\u00a01)\u00a0{`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0++count;`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if\u00a0(count\u00a0>=\u00a0threshold)\u00a0{`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0LOCKED_IN;`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\u00a0else\u00a0if\u00a0(lockinontimeout\u00a0&&\u00a0block.height\u00a0+\u00a02016\u00a0>=\u00a0timeoutheight)\u00a0{`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0MUST_SIGNAL;`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\u00a0else\u00a0if\u00a0(block.height\u00a0>=\u00a0timeoutheight)\u00a0{`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0FAILED;`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0STARTED;`\n\nIf we have finished a period of MUST_SIGNAL, we transition directly to\nLOCKED_IN.\n\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case\u00a0MUST_SIGNAL:`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0LOCKED_IN;`\n\nAfter at least one retarget period of LOCKED_IN, we automatically\ntransition to ACTIVE if the minimum activation height is reached.\nOtherwise LOCKED_IN continues.\n\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case\u00a0LOCKED_IN:`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if\u00a0(block.height\u00a0>=\u00a0minimum_activation_height)\u00a0{`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0ACTIVE;`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\u00a0else\u00a0{`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0LOCKED_IN;`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}`\n\nAnd ACTIVE and FAILED are terminal states, which a deployment stays in\nonce they\\'re reached.\n\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case\u00a0ACTIVE:`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0ACTIVE;`\n\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case\u00a0FAILED:`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0FAILED;`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}`\\\n`\u00a0\u00a0\u00a0}`\n\n**Implementation** It should be noted that the states are maintained\nalong block chain branches, but may need recomputation when a\nreorganization happens.\n\nGiven that the state for a specific block/deployment combination is\ncompletely determined by its ancestry before the current retarget period\n(i.e. up to and including its ancestor with height block.height - 1 -\n(block.height % 2016)), it is possible to implement the mechanism above\nefficiently and safely by caching the resulting state of every\nmultiple-of-2016 block, indexed by its parent."
    },
    {
      "header": "Mandatory signalling {#mandatory_signalling}",
      "content": "Blocks received while in the MUST_SIGNAL phase must be checked to ensure\nthat they signal as required. For example:\n\n`\u00a0\u00a0\u00a0if\u00a0(GetStateForBlock(block)\u00a0==\u00a0MUST_SIGNAL)\u00a0{`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int\u00a0nonsignal\u00a0=\u00a00;`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0walk\u00a0=\u00a0block;`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while\u00a0(true)\u00a0{`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if\u00a0((walk.nVersion\u00a0&\u00a00xE0000000)\u00a0!=\u00a00x20000000\u00a0||\u00a0((walk.nVersion\u00a0>>\u00a0bit)\u00a0&\u00a01)\u00a0!=\u00a01)\u00a0{`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0++nonsignal;`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if\u00a0(nonsignal\u00a0>\u00a02016\u00a0-\u00a0threshold)\u00a0{`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0state.Invalid(BlockValidationResult::RECENT_CONSENSUS_CHANGE,\u00a0\"bad-version-bip8-must-signal\");`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if\u00a0(walk.nHeight\u00a0%\u00a02016\u00a0==\u00a00)\u00a0{`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0checked\u00a0every\u00a0block\u00a0in\u00a0this\u00a0retarget\u00a0period`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0walk\u00a0=\u00a0walk.parent;`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}`\\\n`\u00a0\u00a0\u00a0}`\n\nImplementations should be careful not to ban peers that send blocks that\nare invalid due to not signalling (or blocks that build on those\nblocks), as that would allow an incompatible chain that is only briefly\nlonger than the compliant chain to cause a split of the p2p network. If\nthat occurred, nodes that have not set *lockinontimeout* may not see new\nblocks in the compliant chain, and thus not reorg to it at the point\nwhen it has more work, and would thus not be following the valid chain\nwith the most work.\n\nImplementations with *lockinontimeout* set to true may potentially\nfollow a lower work chain than nodes with *lockinontimeout* set to false\nfor an extended period. In order for this not to result in a net split\nnodes with *lockinontimeout* set to true, those nodes may need to\npreferentially connect to each other. Deployments proposing that\nimplementations set *lockinontimeout* to true should either use\nparameters that do not risk there being a higher work alternative chain,\nor specify a mechanism for implementations that support the deployment\nto preferentially peer with each other."
    },
    {
      "header": "Warning mechanism {#warning_mechanism}",
      "content": "To support upgrade warnings, an extra \\\"unknown upgrade\\\" is tracked,\nusing the \\\"implicit bit\\\" mask = (block.nVersion & \\~expectedVersion)\n!= 0. Mask will be non-zero whenever an unexpected bit is set in\nnVersion. Whenever LOCKED_IN for the unknown upgrade is detected, the\nsoftware should warn loudly about the upcoming soft fork. It should warn\neven more loudly after the next retarget period (when the unknown\nupgrade is in the ACTIVE state)."
    },
    {
      "header": "getblocktemplate changes {#getblocktemplate_changes}",
      "content": "The template request Object is extended to include a new item:\n\ntemplate request\n------------------\nKey\nrules\n\nThe template Object is also extended:\n\ntemplate\n-------------\nKey\nrules\nvbavailable\nvbrequired\n\nThe \\\"version\\\" key of the template is retained, and used to indicate\nthe server\\'s preference of deployments. If versionbits is being used,\n\\\"version\\\" MUST be within the versionbits range of\n\\[0x20000000\\...0x3FFFFFFF\\]. Miners MAY clear or set bits in the block\nversion WITHOUT any special \\\"mutable\\\" key, provided they are listed\namong the template\\'s \\\"vbavailable\\\" and (when clearing is desired) NOT\nincluded as a bit in \\\"vbrequired\\\". Servers MUST set bits in\n\\\"vbrequired\\\" for deployments in MUST_SIGNAL state, to ensure blocks\nproduced are valid.\n\nSoftfork deployment names listed in \\\"rules\\\" or as keys in\n\\\"vbavailable\\\" may be prefixed by a \\'!\\' character. Without this\nprefix, GBT clients may assume the rule will not impact usage of the\ntemplate as-is; typical examples of this would be when previously valid\ntransactions cease to be valid, such as BIPs 16, 65, 66, 68, 112, and\n113. If a client does not understand a rule without the prefix, it may\nuse it unmodified for mining. On the other hand, when this prefix is\nused, it indicates a more subtle change to the block structure or\ngeneration transaction; examples of this would be BIP 34 (because it\nmodifies coinbase construction) and 141 (since it modifies the txid\nhashing and adds a commitment to the generation transaction). A client\nthat does not understand a rule prefixed by \\'!\\' must not attempt to\nprocess the template, and must not attempt to use it for mining even\nunmodified."
    },
    {
      "header": "Reference implementation {#reference_implementation}",
      "content": "<https://github.com/bitcoin/bitcoin/compare/master>\\...luke-jr:bip8"
    },
    {
      "header": "Contrasted with BIP 9 {#contrasted_with_bip_9}",
      "content": "-   The **lockinontimeout** flag is added, providing a way to guarantee\ntransition to LOCKED_IN.\n-   Block heights are used for the deployment monotonic clock, rather\nthan median-time-past."
    },
    {
      "header": "Backwards compatibility {#backwards_compatibility}",
      "content": "BIP8 and BIP9 deployments should not share concurrent active deployment\nbits. Nodes that only implement BIP9 will not activate a BIP8 soft fork\nif hashpower threshold is not reached by **timeoutheight**, however,\nthose nodes will still accept the blocks generated by activated nodes."
    },
    {
      "header": "Deployments",
      "content": "A living list of deployment proposals can be found\n[here](bip-0008/assignments.mediawiki \"wikilink\")."
    },
    {
      "header": "References",
      "content": "[BIP9](bip-0009.mediawiki \"wikilink\")\n\n[Mailing list\ndiscussion](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-February/013643.html)"
    },
    {
      "header": "Copyright",
      "content": "This document is dual licensed as BSD 3-clause, and Creative Commons CC0\n1.0 Universal."
    }
  ]
}