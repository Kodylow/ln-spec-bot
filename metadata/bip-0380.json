{
  "BIP": "380",
  "Layer": "Applications",
  "Title": "Output Script Descriptors General Operation",
  "Author": "Pieter Wuille <pieter@wuille.net>",
  "Comments-Summary": "No comments yet.",
  "Comments-URI": "https://github.com/bitcoin/bips/wiki/Comments:BIP-0380",
  "Status": "Draft",
  "Type": "Informational",
  "Created": "2021-06-27",
  "License": "BSD-2-Clause",
  "sections": [
    {
      "header": "Abstract",
      "content": "Output Script Descriptors are a simple language which can be used to\ndescribe collections of output scripts. There can be many different\ndescriptor fragments and functions. This document describes the general\nsyntax for descriptors, descriptor checksums, and common expressions."
    },
    {
      "header": "Copyright",
      "content": "This BIP is licensed under the BSD 2-clause license."
    },
    {
      "header": "Motivation",
      "content": "Bitcoin wallets traditionally have stored a set of keys which are later\nserialized and mutated to produce the output scripts that the wallet\nwatches and the addresses it provides to users. Typically backups have\nconsisted of solely the private keys, nowadays primarily in the form of\nBIP 39 mnemonics. However this backup solution is insuffient, especially\nsince the introduction of Segregated Witness which added new output\ntypes. Given just the private keys, it is not possible for restored\nwallets to know which kinds of output scripts and addresses to produce.\nThis has lead to incompatibilities between wallets when restoring a\nbackup or exporting data for a watch only wallet.\n\nFurther complicating matters are BIP 32 derivation paths. Although BIPs\n44, 49, and 84 have specified standard BIP 32 derivation paths for\ndifferent output scripts and addresses, not all wallets support them nor\nuse those derivation paths. The lack of derivation path information in\nthese backups and exports leads to further incompatibilities between\nwallets.\n\nCurrent solutions to these issues have not been generic and can be\nviewed as being layer violations. Solutions such as introducing\ndifferent version bytes for extended key serialization both are a layer\nviolation (key derivation should be separate from script type meaning)\nand specific only to a particular derivation path and script type.\n\nOutput Script Descriptors introduces a generic solution to these issues.\nScript types are specified explicitly through the use of Script\nExpressions. Key derivation paths are specified explicitly in Key\nExpressions. These allow for creating wallet backups and exports which\nspecify the exact scripts, subscripts (redeemScript, witnessScript,\netc.), and keys to produce. With the general structure specified in this\nBIP, new Script Expressions can be introduced as new script types are\nadded. Lastly, the use of common terminology and existing standards\nallow for Output Script Descriptors to be engineer readable so that the\nresults can be understood at a glance."
    },
    {
      "header": "Specification",
      "content": "Descriptors consist of several types of expressions. The top level\nexpression is a `SCRIPT`. This expression may be followed by\n`#CHECKSUM`, where `CHECKSUM` is an 8 character alphanumeric descriptor\nchecksum. Although the checksum is optional for parsing, applications\nmay choose to reject descriptors that do not contain a checksum."
    },
    {
      "header": "Script Expressions {#script_expressions}",
      "content": "Script Expressions (denoted `SCRIPT`) are expressions which correspond\ndirectly with a Bitcoin script. These expressions are written as\nfunctions and take arguments. Such expressions have a script template\nwhich is filled with the arguments correspondingly. Expressions are\nwritten with a human readable identifier string with the arguments\nenclosed with parentheses. The identifier string should be alphanumeric\nand may include underscores.\n\nThe arguments to a script expression are defined by that expression\nitself. They could be a script expression, a key expression, or some\nother expression entirely."
    },
    {
      "header": "Key Expressions {#key_expressions}",
      "content": "A common expression used as an argument to script expressions are key\nexpressions (denoted `KEY`). These represent a public or private key\nand, optionally, information about the origin of that key. Key\nexpressions can only be used as arguments to script expressions.\n\nKey expressions consist of:\n\n-   Optionally, key origin information, consisting of:\n-   An open bracket `[`\n-   Exactly 8 hex characters for the fingerprint of the key where\nthe derivation starts (see BIP 32 for details)\n-   Followed by zero or more `/NUM` or `/NUMh` path elements to\nindicate the unhardened or hardened derivation steps between the\nfingerprint and the key that follows.\n-   A closing bracket `]`\n-   Followed by the actual key, which is either:\n-   A hex encoded public key, which depending the script expression,\nmay be either:\n-   66 hex character string beginning with `02` or `03`\nrepresenting a compressed public key\n-   130 hex character string beginning with `04` representing an\nuncompressed public key\n-   A\n[WIF](https://en.bitcoin.it/wiki/Wallet_import_format \"wikilink\")\nencoded private key\n-   `xpub` encoded extended public key or `xprv` encoded extended\nprivate key (as defined in BIP 32)\n-   Followed by zero or more `/NUM` or `/NUMh` path elements\nindicating BIP 32 derivation steps to be taken after the\ngiven extended key.\n-   Optionally followed by a single `/*` or `/*h` final step to\ndenote all direct unhardened or hardened children.\n\nIf the `KEY` is a BIP 32 extended key, before output scripts can be\ncreated, child keys must be derived using the derivation information\nthat follows the extended key. When the final step is `/*` or `/*'`, an\noutput script will be produced for every child key index. The derived\nkey must be not be serialized as an uncompressed public key. Script\nExpressions may have further requirements on how derived public keys are\nserialized for script creation.\n\nIn the above specification, the hardened indicator `h` may be replaced\nwith alternative hardened indicators of `H` or `'`."
    },
    {
      "header": "Normalization of Key Expressions with Hardened Derivation {#normalization_of_key_expressions_with_hardened_derivation}",
      "content": "When a descriptor is exported without private keys, it is necessary to\ndo additional derivation to remove any intermediate hardened derivation\nsteps for the exported descriptor to be useful. The exporter should\nderive the extended public key at the last hardened derivation step and\nuse that extended public key as the key in the descriptor. The\nderivation steps that were taken to get to that key must be added to the\nprevious key origin information. If there is no key origin information,\nthen one must be added for the newly derived extended public key. If the\nfinal derivation is hardened, then it is not necessary to do additional\nderivation."
    },
    {
      "header": "Character Set {#character_set}",
      "content": "The expressions used in descriptors must only contain characters within\nthis character set so that the descriptor checksum will work.\n\nThe allowed characters are:\n\n0123456789()[],'/*abcdefgh@:$%{}\nIJKLMNOPQRSTUVWXYZ&+-.;<=>?!^_|~\nijklmnopqrstuvwxyzABCDEFGH`#\"\\<space>\n\nNote that `<space>`{=html} on the last line is a space character.\n\nThis character set is written as 3 groups of 32 characters in this\nspecific order so that the checksum below can identify more errors. The\nfirst group are the most common \\\"unprotected\\\" characters (i.e. things\nsuch as hex and keypaths that do not already have their own checksums).\nCase errors cause an offset that is a multiple of 32 while as many\nalphabetic characters are in the same group while following the previous\nrestrictions."
    },
    {
      "header": "Checksum",
      "content": "Following the top level script expression is a single octothorpe (`#`)\nfollowed by the 8 character checksum. The checksum is an error\ncorrecting checksum similar to bech32.\n\nThe checksum has the following properties:\n\n-   Mistakes in a descriptor string are measured in \\\"symbol errors\\\".\nThe higher the number of symbol errors, the harder it is to detect:\n-   An error substituting a character from\n`0123456789()[],'/*abcdefgh@:$%{}` for another in that set\nalways counts as 1 symbol error.\n-   Note that hex encoded keys are covered by these characters.\nExtended keys (`xpub` and `xprv`) use other characters too,\nbut also have their own checksum mechanism.\n-   `SCRIPT` expression function names use other characters, but\nmistakes in these would generally result in an unparsable\ndescriptor.\n-   A case error always counts as 1 symbol error.\n-   Any other 1 character substitution error counts as 1 or 2 symbol\nerrors.\n-   Any 1 symbol error is always detected.\n-   Any 2 or 3 symbol error in a descriptor of up to 49154 characters is\nalways detected.\n-   Any 4 symbol error in a descriptor of up to 507 characters is always\ndetected.\n-   Any 5 symbol error in a descriptor of up to 77 characters is always\ndetected.\n-   Is optimized to minimize the chance of a 5 symbol error in a\ndescriptor up to 387 characters is undetected\n-   Random errors have a chance of 1 in\n2`<super>`{=html}40`</super>`{=html} of being undetected.\n\nThe checksum itself uses the same character set as bech32:\n`qpzry9x8gf2tvdw0s3jn54khce6mua7l`\n\nValid descriptor strings with a checksum must pass the criteria for\nvalidity specified by the Python3 code snippet below. The function\n`descsum_check` must return true when its argument `s` is a descriptor\nconsisting in the form `SCRIPT#CHECKSUM`.\n\nINPUT_CHARSET = \"0123456789()[],'/*abcdefgh@:$%{}IJKLMNOPQRSTUVWXYZ&+-.;<=>?!^_|~ijklmnopqrstuvwxyzABCDEFGH`#\\\"\\\\ \"\nCHECKSUM_CHARSET = \"qpzry9x8gf2tvdw0s3jn54khce6mua7l\"\nGENERATOR = [0xf5dee51989, 0xa9fdca3312, 0x1bab10e32d, 0x3706b1677a, 0x644d626ffd]\n\ndef descsum_polymod(symbols):\n\"\"\"Internal function that computes the descriptor checksum.\"\"\"\nchk = 1\nfor value in symbols:\ntop = chk >> 35\nchk = (chk & 0x7ffffffff) << 5 ^ value\nfor i in range(5):\nchk ^= GENERATOR[i] if ((top >> i) & 1) else 0\nreturn chk\n\ndef descsum_expand(s):\n\"\"\"Internal function that does the character to symbol expansion\"\"\"\ngroups = []\nsymbols = []\nfor c in s:\nif not c in INPUT_CHARSET:\nreturn None\nv = INPUT_CHARSET.find(c)\nsymbols.append(v & 31)\ngroups.append(v >> 5)\nif len(groups) == 3:\nsymbols.append(groups[0] * 9 + groups[1] * 3 + groups[2])\ngroups = []\nif len(groups) == 1:\nsymbols.append(groups[0])\nelif len(groups) == 2:\nsymbols.append(groups[0] * 3 + groups[1])\nreturn symbols\n\ndef descsum_check(s):\n\"\"\"Verify that the checksum is correct in a descriptor\"\"\"\nif s[-9] != '#':\nreturn False\nif not all(x in CHECKSUM_CHARSET for x in s[-8:]):\nreturn False\nsymbols = descsum_expand(s[:-9]) + [CHECKSUM_CHARSET.find(x) for x in s[-8:]]\nreturn descsum_polymod(symbols) == 1\n\nThis implements a BCH code that has the properties described above. The\nentire descriptor string is first processed into an array of symbols.\nThe symbol for each character is its position within its group. After\nevery 3rd symbol, a 4th symbol is inserted which represents the group\nnumbers combined together. This means that a change that only affects\nthe position within a group, or only a group number change, will only\naffect a single symbol.\n\nTo construct a valid checksum given a script expression, the code below\ncan be used:\n\ndef descsum_create(s):\n\"\"\"Add a checksum to a descriptor without\"\"\"\nsymbols = descsum_expand(s) + [0, 0, 0, 0, 0, 0, 0, 0]\nchecksum = descsum_polymod(symbols) ^ 1\nreturn s + '#' + ''.join(CHECKSUM_CHARSET[(checksum >> (5 * (7 - i))) & 31] for i in range(8))"
    },
    {
      "header": "Backwards Compatibility {#backwards_compatibility}",
      "content": "Output script descriptors are an entirely new language which is not\ncompatible with any existing software. However many components of the\nexpressions reuse encodings and serializations defined by previous BIPs.\n\nOutput script descriptors are designed for future extension with further\nfragment types and new script expressions. These will be specified in\nadditional BIPs."
    },
    {
      "header": "Reference Implementation {#reference_implementation}",
      "content": "Descriptors have been implemented in Bitcoin Core since version 0.17."
    },
    {
      "header": "Appendix A: Index of Expressions {#appendix_a_index_of_expressions}",
      "content": "Future BIPs may specify additional types of expressions. All available\nexpression types are listed in this table.\n\nName     Denoted As   BIP\n-------- ------------ --------------------------------------\nScript   `SCRIPT`     380\nKey      `KEY`        380\nTree     `TREE`       [386](bip-0386.mediawiki \"wikilink\")"
    },
    {
      "header": "Appendix B: Index of Script Expressions {#appendix_b_index_of_script_expressions}",
      "content": "Script expressions will be specified in additional BIPs. This Table\nlists all available Script expressions and the BIPs specifying them.\n\nExpression                          BIP\n----------------------------------- --------------------------------------\n`pk(KEY)`                           [381](bip-0381.mediawiki \"wikilink\")\n`pkh(KEY)`                          [381](bip-0381.mediawiki \"wikilink\")\n`sh(SCRIPT)`                        [381](bip-0381.mediawiki \"wikilink\")\n`wpkh(KEY)`                         [382](bip-0382.mediawiki \"wikilink\")\n`wsh(SCRIPT)`                       [382](bip-0382.mediawiki \"wikilink\")\n`multi(NUM, KEY, ..., KEY)`         [383](bip-0383.mediawiki \"wikilink\")\n`sortedmulti(NUM, KEY, ..., KEY)`   [383](bip-0383.mediawiki \"wikilink\")\n`combo(KEY)`                        [384](bip-0384.mediawiki \"wikilink\")\n`raw(HEX)`                          [385](bip-0385.mediawiki \"wikilink\")\n`addr(ADDR)`                        [385](bip-0385.mediawiki \"wikilink\")\n`tr(KEY)`, `tr(KEY, TREE)`          [386](bip-0386.mediawiki \"wikilink\")"
    }
  ]
}