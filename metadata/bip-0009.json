{
  "BIP": "9",
  "Title": "Version bits with timeout and delay",
  "Author": "Pieter Wuille <pieter.wuille@gmail.com>",
  "Comments-Summary": "No comments yet.",
  "Comments-URI": "https://github.com/bitcoin/bips/wiki/Comments:BIP-0009",
  "Status": "Final",
  "Type": "Informational",
  "Created": "2015-10-04",
  "License": "PD",
  "sections": [
    {
      "header": "Abstract",
      "content": "This document specifies a proposed change to the semantics of the\n\\'version\\' field in Bitcoin blocks, allowing multiple\nbackward-compatible changes (further called \\\"soft forks\\\") to be\ndeployed in parallel. It relies on interpreting the version field as a\nbit vector, where each bit can be used to track an independent change.\nThese are tallied each retarget period. Once the consensus change\nsucceeds or times out, there is a \\\"fallow\\\" pause after which the bit\ncan be reused for later changes."
    },
    {
      "header": "Motivation",
      "content": "[BIP 34](bip-0034.mediawiki \"wikilink\") introduced a mechanism for doing\nsoft-forking changes without a predefined flag timestamp (or flag block\nheight), instead relying on measuring miner support indicated by a\nhigher version number in block headers. As it relies on comparing\nversion numbers as integers however, it only supports one single change\nbeing rolled out at once, requiring coordination between proposals, and\ndoes not allow for permanent rejection: as long as one soft fork is not\nfully rolled out, no future one can be scheduled.\n\nIn addition, BIP 34 made the integer comparison (nVersion \\>= 2) a\nconsensus rule after its 95% threshold was reached, removing 2^31^+2\nvalues from the set of valid version numbers (all negative numbers, as\nnVersion is interpreted as a signed integer, as well as 0 and 1). This\nindicates another downside this approach: every upgrade permanently\nrestricts the set of allowed nVersion field values. This approach was\nlater reused in [BIP 66](bip-0066.mediawiki \"wikilink\") and [BIP\n65](bip-0065.mediawiki \"wikilink\"), which further removed nVersions 2\nand 3 as valid options. As will be shown further, this is unnecessary."
    },
    {
      "header": "Specification",
      "content": "Each soft fork deployment is specified by the following per-chain\nparameters (further elaborated below):\n\n1.  The **name** specifies a very brief description of the soft fork,\nreasonable for use as an identifier. For deployments described in a\nsingle BIP, it is recommended to use the name \\\"bipN\\\" where N is\nthe appropriate BIP number.\n2.  The **bit** determines which bit in the nVersion field of the block\nis to be used to signal the soft fork lock-in and activation. It is\nchosen from the set {0,1,2,\\...,28}.\n3.  The **starttime** specifies a minimum median time past of a block at\nwhich the bit gains its meaning.\n4.  The **timeout** specifies a time at which the deployment is\nconsidered failed. If the median time past of a block \\>= timeout\nand the soft fork has not yet locked in (including this block\\'s bit\nstate), the deployment is considered failed on all descendants of\nthe block."
    },
    {
      "header": "Selection guidelines {#selection_guidelines}",
      "content": "The following guidelines are suggested for selecting these parameters\nfor a soft fork:\n\n1.  **name** should be selected such that no two softforks, concurrent\nor otherwise, ever use the same name.\n2.  **bit** should be selected such that no two concurrent softforks use\nthe same bit.\n3.  **starttime** should be set to some date in the future,\napproximately one month after a software release date including the\nsoft fork. This allows for some release delays, while preventing\ntriggers as a result of parties running pre-release software.\n4.  **timeout** should be 1 year (31536000 seconds) after starttime.\n\nA later deployment using the same bit is possible as long as the\nstarttime is after the previous one\\'s timeout or activation, but it is\ndiscouraged until necessary, and even then recommended to have a pause\nin between to detect buggy software."
    },
    {
      "header": "States",
      "content": "With each block and soft fork, we associate a deployment state. The\npossible states are:\n\n1.  **DEFINED** is the first state that each soft fork starts out as.\nThe genesis block is by definition in this state for each\ndeployment.\n2.  **STARTED** for blocks past the starttime.\n3.  **LOCKED_IN** for one retarget period after the first retarget\nperiod with STARTED blocks of which at least threshold have the\nassociated bit set in nVersion.\n4.  **ACTIVE** for all blocks after the LOCKED_IN retarget period.\n5.  **FAILED** for one retarget period past the timeout time, if\nLOCKED_IN was not reached."
    },
    {
      "header": "Bit flags {#bit_flags}",
      "content": "The nVersion block header field is to be interpreted as a 32-bit\nlittle-endian integer (as present), and bits are selected within this\ninteger as values (1 \\<\\< N) where N is the bit number.\n\nBlocks in the STARTED state get an nVersion whose bit position bit is\nset to 1. The top 3 bits of such blocks must be 001, so the range of\nactually possible nVersion values is \\[0x20000000\\...0x3FFFFFFF\\],\ninclusive.\n\nDue to the constraints set by BIP 34, BIP 66 and BIP 65, we only have\n0x7FFFFFFB possible nVersion values available. This restricts us to at\nmost 30 independent deployments. By restricting the top 3 bits to 001 we\nget 29 out of those for the purposes of this proposal, and support two\nfuture upgrades for different mechanisms (top bits 010 and 011). When a\nblock nVersion does not have top bits 001, it is treated as if all bits\nare 0 for the purposes of deployments.\n\nMiners should continue setting the bit in LOCKED_IN phase so uptake is\nvisible, though this has no effect on consensus rules."
    },
    {
      "header": "New consensus rules {#new_consensus_rules}",
      "content": "The new consensus rules for each soft fork are enforced for each block\nthat has ACTIVE state."
    },
    {
      "header": "State transitions {#state_transitions}",
      "content": "`<img src=\"bip-0009/states.png\" align=\"middle\">`{=html}`</img>`{=html}\n\nThe genesis block has state DEFINED for each deployment, by definition.\n\n`\u00a0\u00a0\u00a0State\u00a0GetStateForBlock(block)\u00a0{`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if\u00a0(block.height\u00a0==\u00a00)\u00a0{`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0DEFINED;`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}`\n\nAll blocks within a retarget period have the same state. This means that\nif floor(block1.height / 2016) = floor(block2.height / 2016), they are\nguaranteed to have the same state for every deployment.\n\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if\u00a0((block.height\u00a0%\u00a02016)\u00a0!=\u00a00)\u00a0{`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0GetStateForBlock(block.parent);`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}`\n\nOtherwise, the next state depends on the previous state:\n\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0switch\u00a0(GetStateForBlock(GetAncestorAtHeight(block,\u00a0block.height\u00a0-\u00a02016)))\u00a0{`\n\nWe remain in the initial state until either we pass the start time or\nthe timeout. GetMedianTimePast in the code below refers to the median\nnTime of a block and its 10 predecessors. The expression\nGetMedianTimePast(block.parent) is referred to as MTP in the diagram\nabove, and is treated as a monotonic clock defined by the chain.\n\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case\u00a0DEFINED:`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if\u00a0(GetMedianTimePast(block.parent)\u00a0>=\u00a0timeout)\u00a0{`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0FAILED;`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if\u00a0(GetMedianTimePast(block.parent)\u00a0>=\u00a0starttime)\u00a0{`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0STARTED;`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0DEFINED;`\n\nAfter a period in the STARTED state, if we\\'re past the timeout, we\nswitch to FAILED. If not, we tally the bits set, and transition to\nLOCKED_IN if a sufficient number of blocks in the past period set the\ndeployment bit in their version numbers. The threshold is \u22651916 blocks\n(95% of 2016), or \u22651512 for testnet (75% of 2016). The transition to\nFAILED takes precedence, as otherwise an ambiguity can arise. There\ncould be two non-overlapping deployments on the same bit, where the\nfirst one transitions to LOCKED_IN while the other one simultaneously\ntransitions to STARTED, which would mean both would demand setting the\nbit.\n\nNote that a block\\'s state never depends on its own nVersion; only on\nthat of its ancestors.\n\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case\u00a0STARTED:\u00a0`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if\u00a0(GetMedianTimePast(block.parent)\u00a0>=\u00a0timeout)\u00a0{`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0FAILED;`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int\u00a0count\u00a0=\u00a00;`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0walk\u00a0=\u00a0block;`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for\u00a0(i\u00a0=\u00a00;\u00a0i\u00a0<\u00a02016;\u00a0i++)\u00a0{`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0walk\u00a0=\u00a0walk.parent;`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if\u00a0(walk.nVersion\u00a0&\u00a00xE0000000\u00a0==\u00a00x20000000\u00a0&&\u00a0(walk.nVersion\u00a0>>\u00a0bit)\u00a0&\u00a01\u00a0==\u00a01)\u00a0{`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count++;`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if\u00a0(count\u00a0>=\u00a0threshold)\u00a0{`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0LOCKED_IN;`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0STARTED;`\n\nAfter a retarget period of LOCKED_IN, we automatically transition to\nACTIVE.\n\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case\u00a0LOCKED_IN:`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0ACTIVE;`\n\nAnd ACTIVE and FAILED are terminal states, which a deployment stays in\nonce they\\'re reached.\n\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case\u00a0ACTIVE:`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0ACTIVE;`\n\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case\u00a0FAILED:`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0FAILED;`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}`\\\n`\u00a0\u00a0\u00a0}`\n\n**Implementation** It should be noted that the states are maintained\nalong block chain branches, but may need recomputation when a\nreorganization happens.\n\nGiven that the state for a specific block/deployment combination is\ncompletely determined by its ancestry before the current retarget period\n(i.e. up to and including its ancestor with height block.height - 1 -\n(block.height % 2016)), it is possible to implement the mechanism above\nefficiently and safely by caching the resulting state of every\nmultiple-of-2016 block, indexed by its parent."
    },
    {
      "header": "Warning mechanism {#warning_mechanism}",
      "content": "To support upgrade warnings, an extra \\\"unknown upgrade\\\" is tracked,\nusing the \\\"implicit bit\\\" mask = (block.nVersion & \\~expectedVersion)\n!= 0. Mask will be non-zero whenever an unexpected bit is set in\nnVersion. Whenever LOCKED_IN for the unknown upgrade is detected, the\nsoftware should warn loudly about the upcoming soft fork. It should warn\neven more loudly after the next retarget period (when the unknown\nupgrade is in the ACTIVE state)."
    },
    {
      "header": "getblocktemplate changes {#getblocktemplate_changes}",
      "content": "The template request Object is extended to include a new item:\n\ntemplate request\n------------------\nKey\nrules\n\nThe template Object is also extended:\n\ntemplate\n-------------\nKey\nrules\nvbavailable\nvbrequired\n\nThe \\\"version\\\" key of the template is retained, and used to indicate\nthe server\\'s preference of deployments. If versionbits is being used,\n\\\"version\\\" MUST be within the versionbits range of\n\\[0x20000000\\...0x3FFFFFFF\\]. Miners MAY clear or set bits in the block\nversion WITHOUT any special \\\"mutable\\\" key, provided they are listed\namong the template\\'s \\\"vbavailable\\\" and (when clearing is desired) NOT\nincluded as a bit in \\\"vbrequired\\\".\n\nSoftfork deployment names listed in \\\"rules\\\" or as keys in\n\\\"vbavailable\\\" may be prefixed by a \\'!\\' character. Without this\nprefix, GBT clients may assume the rule will not impact usage of the\ntemplate as-is; typical examples of this would be when previously valid\ntransactions cease to be valid, such as BIPs\n[16](bip-0016.mediawiki \"wikilink\"),\n[65](bip-0065.mediawiki \"wikilink\"),\n[66](bip-0066.mediawiki \"wikilink\"),\n[68](bip-0068.mediawiki \"wikilink\"),\n[112](bip-0112.mediawiki \"wikilink\"), and\n[113](bip-0113.mediawiki \"wikilink\"). If a client does not understand a\nrule without the prefix, it may use it unmodified for mining. On the\nother hand, when this prefix is used, it indicates a more subtle change\nto the block structure or generation transaction; examples of this would\nbe [BIP 34](bip-0034.mediawiki \"wikilink\") (because it modifies coinbase\nconstruction) and [141](bip-0141.mediawiki \"wikilink\") (since it\nmodifies the txid hashing and adds a commitment to the generation\ntransaction). A client that does not understand a rule prefixed by \\'!\\'\nmust not attempt to process the template, and must not attempt to use it\nfor mining even unmodified."
    },
    {
      "header": "Support for future changes {#support_for_future_changes}",
      "content": "The mechanism described above is very generic, and variations are\npossible for future soft forks. Here are some ideas that can be taken\ninto account.\n\n**Modified thresholds** The 1916 threshold (based on BIP 34\\'s 95%) does\nnot have to be maintained for eternity, but changes should take the\neffect on the warning system into account. In particular, having a\nlock-in threshold that is incompatible with the one used for the warning\nsystem may have long-term effects, as the warning system cannot rely on\na permanently detectable condition anymore.\n\n**Conflicting soft forks** At some point, two mutually exclusive soft\nforks may be proposed. The naive way to deal with this is to never\ncreate software that implements both, but that is making a bet that at\nleast one side is guaranteed to lose. Better would be to encode \\\"soft\nfork X cannot be locked-in\\\" as consensus rule for the conflicting soft\nfork - allowing software that supports both, but can never trigger\nconflicting changes.\n\n**Multi-stage soft forks** Soft forks right now are typically treated as\nbooleans: they go from an inactive to an active state in blocks. Perhaps\nat some point there is demand for a change that has a larger number of\nstages, with additional validation rules that get enabled one by one.\nThe above mechanism can be adapted to support this, by interpreting a\ncombination of bits as an integer, rather than as isolated bits. The\nwarning system is compatible with this, as (nVersion &\n\\~nExpectedVersion) will always be non-zero for increasing integers."
    },
    {
      "header": "Rationale",
      "content": "The failure timeout allows eventual reuse of bits even if a soft fork\nwas never activated, so it\\'s clear that the new use of the bit refers\nto a new BIP. It\\'s deliberately very coarse-grained, to take into\naccount reasonable development and deployment delays. There are unlikely\nto be enough failed proposals to cause a bit shortage.\n\nThe fallow period at the conclusion of a soft fork attempt allows some\ndetection of buggy clients, and allows time for warnings and software\nupgrades for successful soft forks."
    },
    {
      "header": "Deployments",
      "content": "A living list of deployment proposals can be found\n[here](bip-0009/assignments.mediawiki \"wikilink\")."
    },
    {
      "header": "Copyright",
      "content": "This document is placed in the public domain."
    }
  ]
}