{
  "BIP": "112",
  "Layer": "Consensus (soft fork)",
  "Title": "CHECKSEQUENCEVERIFY",
  "Author": "BtcDrak <btcdrak@gmail.com>",
  "Comments-Summary": "No comments yet.",
  "Comments-URI": "https://github.com/bitcoin/bips/wiki/Comments:BIP-0112",
  "Status": "Final",
  "Type": "Standards Track",
  "Created": "2015-08-10",
  "License": "PD",
  "sections": [
    {
      "header": "Abstract",
      "content": "This BIP describes a new opcode (CHECKSEQUENCEVERIFY) for the Bitcoin\nscripting system that in combination with BIP 68 allows execution\npathways of a script to be restricted based on the age of the output\nbeing spent."
    },
    {
      "header": "Summary",
      "content": "CHECKSEQUENCEVERIFY redefines the existing NOP3 opcode. When executed,\nif any of the following conditions are true, the script interpreter will\nterminate with an error:\n\n-   the stack is empty; or\n-   the top item on the stack is less than 0; or\n-   the top item on the stack has the disable flag (1 \\<\\< 31) unset;\nand\n-   the transaction version is less than 2; or\n-   the transaction input sequence number disable flag (1 \\<\\< 31)\nis set; or\n-   the relative lock-time type is not the same; or\n-   the top stack item is greater than the transaction input\nsequence (when masked according to the BIP68);\n\nOtherwise, script execution will continue as if a NOP had been executed.\n\nBIP 68 prevents a non-final transaction from being selected for\ninclusion in a block until the corresponding input has reached the\nspecified age, as measured in block-height or block-time. By comparing\nthe argument to CHECKSEQUENCEVERIFY against the nSequence field, we\nindirectly verify a desired minimum age of the the output being spent;\nuntil that relative age has been reached any script execution pathway\nincluding the CHECKSEQUENCEVERIFY will fail to validate, causing the\ntransaction not to be selected for inclusion in a block."
    },
    {
      "header": "Motivation",
      "content": "BIP 68 repurposes the transaction nSequence field meaning by giving\nsequence numbers new consensus-enforced semantics as a relative\nlock-time. However, there is no way to build Bitcoin scripts to make\ndecisions based on this field.\n\nBy making the nSequence field accessible to script, it becomes possible\nto construct code pathways that only become accessible some minimum time\nafter proof-of-publication. This enables a wide variety of applications\nin phased protocols such as escrow, payment channels, or bidirectional\npegs."
    },
    {
      "header": "Contracts With Expiration Deadlines {#contracts_with_expiration_deadlines}",
      "content": "#### Escrow with Timeout {#escrow_with_timeout}\n\nAn escrow that times out automatically 30 days after being funded can be\nestablished in the following way. Alice, Bob and Escrow create a 2-of-3\naddress with the following redeemscript.\n\n`\u00a0\u00a0\u00a0IF`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02\u00a0<Alice's\u00a0pubkey>\u00a0<Bob's\u00a0pubkey>\u00a0<Escrow's\u00a0pubkey>\u00a03\u00a0CHECKMULTISIG`\\\n`\u00a0\u00a0\u00a0ELSE`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"30d\"\u00a0CHECKSEQUENCEVERIFY\u00a0DROP`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<Alice's\u00a0pubkey>\u00a0CHECKSIG`\\\n`\u00a0\u00a0\u00a0ENDIF`\n\nAt any time funds can be spent using signatures from any two of Alice,\nBob or the Escrow.\n\nAfter 30 days Alice can sign alone.\n\nThe clock does not start ticking until the payment to the escrow address\nconfirms."
    },
    {
      "header": "Retroactive Invalidation {#retroactive_invalidation}",
      "content": "In many instances, we would like to create contracts that can be revoked\nin case of some future event. However, given the immutable nature of the\nblockchain, it is practically impossible to retroactively invalidate a\nprevious commitment that has already confirmed. The only mechanism we\nreally have for retroactive invalidation is blockchain reorganization\nwhich, for fundamental security reasons, is designed to be very hard and\nvery expensive to do.\n\nDespite this limitation, we do have a way to provide something\nfunctionally similar to retroactive invalidation while preserving\nirreversibility of past commitments using CHECKSEQUENCEVERIFY. By\nconstructing scripts with multiple branches of execution where one or\nmore of the branches are delayed we provide a time window in which\nsomeone can supply an invalidation condition that allows the output to\nbe spent, effectively invalidating the would-be delayed branch and\npotentially discouraging another party from broadcasting the transaction\nin the first place. If the invalidation condition does not occur before\nthe timeout, the delayed branch becomes spendable, honoring the original\ncontract.\n\nSome more specific applications of this idea:"
    },
    {
      "header": "Hash Time-Locked Contracts {#hash_time_locked_contracts}",
      "content": "Hash Time-Locked Contracts (HTLCs) provide a general mechanism for\noff-chain contract negotiation. An execution pathway can be made to\nrequire knowledge of a secret (a hash preimage) that can be presented\nwithin an invalidation time window. By sharing the secret it is possible\nto guarantee to the counterparty that the transaction will never be\nbroadcast since this would allow the counterparty to claim the output\nimmediately while one would have to wait for the time window to pass. If\nthe secret has not been shared, the counterparty will be unable to use\nthe instant pathway and the delayed pathway must be used instead."
    },
    {
      "header": "Bidirectional Payment Channels {#bidirectional_payment_channels}",
      "content": "Scriptable relative locktime provides a predictable amount of time to\nrespond in the event a counterparty broadcasts a revoked transaction:\nAbsolute locktime necessitates closing the channel and reopen it when\ngetting close to the timeout, whereas with relative locktime, the clock\nstarts ticking the moment the transactions confirms in a block. It also\nprovides a means to know exactly how long to wait (in number of blocks)\nbefore funds can be pulled out of the channel in the event of a\nnoncooperative counterparty."
    },
    {
      "header": "Lightning Network {#lightning_network}",
      "content": "The lightning network extends the bidirectional payment channel idea to\nallow for payments to be routed over multiple bidirectional payment\nchannel hops.\n\nThese channels are based on an anchor transaction that requires a 2-of-2\nmultisig from Alice and Bob, and a series of revocable commitment\ntransactions that spend the anchor transaction. The commitment\ntransaction splits the funds from the anchor between Alice and Bob and\nthe latest commitment transaction may be published by either party at\nany time, finalising the channel.\n\nIdeally then, a revoked commitment transaction would never be able to be\nsuccessfully spent; and the latest commitment transaction would be able\nto be spent very quickly.\n\nTo allow a commitment transaction to be effectively revoked, Alice and\nBob have slightly different versions of the latest commitment\ntransaction. In Alice\\'s version, any outputs in the commitment\ntransaction that pay Alice also include a forced delay, and an\nalternative branch that allows Bob to spend the output if he knows that\ntransaction\\'s revocation code. In Bob\\'s version, payments to Bob are\nsimilarly encumbered. When Alice and Bob negotiate new balances and new\ncommitment transactions, they also reveal the old revocation code, thus\ncommitting to not relaying the old transaction.\n\nA simple output, paying to Alice might then look like:\n\n`\u00a0\u00a0\u00a0HASH160\u00a0``<revokehash>`{=html}`\u00a0EQUAL`\\\n`\u00a0\u00a0\u00a0IF`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<Bob's\u00a0pubkey>`\\\n`\u00a0\u00a0\u00a0ELSE`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"24h\"\u00a0CHECKSEQUENCEVERIFY\u00a0DROP`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<Alice's\u00a0pubkey>`\\\n`\u00a0\u00a0\u00a0ENDIF`\\\n`\u00a0\u00a0\u00a0CHECKSIG`\n\nThis allows Alice to publish the latest commitment transaction at any\ntime and spend the funds after 24 hours, but also ensures that if Alice\nrelays a revoked transaction, that Bob has 24 hours to claim the funds.\n\nWith CHECKLOCKTIMEVERIFY, this would look like:\n\n`\u00a0\u00a0\u00a0HASH160\u00a0``<revokehash>`{=html}`\u00a0EQUAL`\\\n`\u00a0\u00a0\u00a0IF`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<Bob's\u00a0pubkey>`\\\n`\u00a0\u00a0\u00a0ELSE`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"2015/12/15\"\u00a0CHECKLOCKTIMEVERIFY\u00a0DROP`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<Alice's\u00a0pubkey>`\\\n`\u00a0\u00a0\u00a0ENDIF`\\\n`\u00a0\u00a0\u00a0CHECKSIG`\n\nThis form of transaction would mean that if the anchor is unspent on\n2015/12/16, Alice can use this commitment even if it has been revoked,\nsimply by spending it immediately, giving no time for Bob to claim it.\n\nThis means that the channel has a deadline that cannot be pushed back\nwithout hitting the blockchain; and also that funds may not be available\nuntil the deadline is hit. CHECKSEQUENCEVERIFY allows you to avoid\nmaking such a tradeoff.\n\nHashed Time-Lock Contracts (HTLCs) make this slightly more complicated,\nsince in principle they may pay either Alice or Bob, depending on\nwhether Alice discovers a secret R, or a timeout is reached, but the\nsame principle applies \\-- the branch paying Alice in Alice\\'s\ncommitment transaction gets a delay, and the entire output can be\nclaimed by the other party if the revocation secret is known. With\nCHECKSEQUENCEVERIFY, a HTLC payable to Alice might look like the\nfollowing in Alice\\'s commitment transaction:\n\n`\u00a0\u00a0\u00a0HASH160\u00a0DUP\u00a0``<R-HASH>`{=html}`\u00a0EQUAL`\\\n`\u00a0\u00a0\u00a0IF`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"24h\"\u00a0CHECKSEQUENCEVERIFY`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02DROP`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<Alice's\u00a0pubkey>`\\\n`\u00a0\u00a0\u00a0ELSE`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0``<Commit-Revocation-Hash>`{=html}`\u00a0EQUAL`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0NOTIF`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"2015/10/20\u00a010:33\"\u00a0CHECKLOCKTIMEVERIFY\u00a0DROP`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ENDIF`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<Bob's\u00a0pubkey>`\\\n`\u00a0\u00a0\u00a0ENDIF`\\\n`\u00a0\u00a0\u00a0CHECKSIG`\n\nand correspondingly in Bob\\'s commitment transaction:\n\n`\u00a0\u00a0HASH160\u00a0DUP\u00a0``<R-HASH>`{=html}`\u00a0EQUAL`\\\n`\u00a0\u00a0SWAP\u00a0``<Commit-Revocation-Hash>`{=html}`\u00a0EQUAL\u00a0ADD`\\\n`\u00a0\u00a0IF`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<Alice's\u00a0pubkey>`\\\n`\u00a0\u00a0ELSE`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"2015/10/20\u00a010:33\"\u00a0CHECKLOCKTIMEVERIFY`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"24h\"\u00a0CHECKSEQUENCEVERIFY`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02DROP`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<Bob's\u00a0pubkey>`\\\n`\u00a0\u00a0ENDIF`\\\n`\u00a0\u00a0CHECKSIG`\n\nNote that both CHECKSEQUENCEVERIFY and CHECKLOCKTIMEVERIFY are used in\nthe final branch of above to ensure Bob cannot spend the output until\nafter both the timeout is complete and Alice has had time to reveal the\nrevocation secret.\n\nSee the [Deployable\nLightning](https://github.com/ElementsProject/lightning/blob/master/doc/deployable-lightning.pdf)\npaper."
    },
    {
      "header": "2-Way Pegged Sidechains {#way_pegged_sidechains}",
      "content": "The 2-way pegged sidechain requires a new REORGPROOFVERIFY opcode, the\nsemantics of which are outside the scope of this BIP.\nCHECKSEQUENCEVERIFY is used to make sure that sufficient time has passed\nsince the return peg was posted to publish a reorg proof:\n\n`\u00a0\u00a0\u00a0IF`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0lockTxHeight\u00a0``<lockTxHash>`{=html}`\u00a0nlocktxOut\u00a0[``<workAmount>`{=html}`]\u00a0reorgBounty\u00a0Hash160(<...>)\u00a0``<genesisHash>`{=html}`\u00a0REORGPROOFVERIFY`\\\n`\u00a0\u00a0\u00a0ELSE`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0withdrawLockTime\u00a0CHECKSEQUENCEVERIFY\u00a0DROP\u00a0HASH160\u00a0p2shWithdrawDest\u00a0EQUAL`\\\n`\u00a0\u00a0\u00a0ENDIF`"
    },
    {
      "header": "Specification",
      "content": "Refer to the reference implementation, reproduced below, for the precise\nsemantics and detailed rationale for those semantics.\n\n/* Below flags apply in the context of BIP 68 */\n/* If this flag set, CTxIn::nSequence is NOT interpreted as a\n* relative lock-time. */\nstatic const uint32_t SEQUENCE_LOCKTIME_DISABLE_FLAG = (1 << 31);\n\n/* If CTxIn::nSequence encodes a relative lock-time and this flag\n* is set, the relative lock-time has units of 512 seconds,\n* otherwise it specifies blocks with a granularity of 1. */\nstatic const uint32_t SEQUENCE_LOCKTIME_TYPE_FLAG = (1 << 22);\n\n/* If CTxIn::nSequence encodes a relative lock-time, this mask is\n* applied to extract that lock-time from the sequence field. */\nstatic const uint32_t SEQUENCE_LOCKTIME_MASK = 0x0000ffff;\n\ncase OP_NOP3:\n{\nif (!(flags & SCRIPT_VERIFY_CHECKSEQUENCEVERIFY)) {\n// not enabled; treat as a NOP3\nif (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\nreturn set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS);\n}\nbreak;\n}\n\nif (stack.size() < 1)\nreturn set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n\n// Note that elsewhere numeric opcodes are limited to\n// operands in the range -2**31+1 to 2**31-1, however it is\n// legal for opcodes to produce results exceeding that\n// range. This limitation is implemented by CScriptNum's\n// default 4-byte limit.\n//\n// Thus as a special case we tell CScriptNum to accept up\n// to 5-byte bignums, which are good until 2**39-1, well\n// beyond the 2**32-1 limit of the nSequence field itself.\nconst CScriptNum nSequence(stacktop(-1), fRequireMinimal, 5);\n\n// In the rare event that the argument may be < 0 due to\n// some arithmetic being done first, you can always use\n// 0 MAX CHECKSEQUENCEVERIFY.\nif (nSequence < 0)\nreturn set_error(serror, SCRIPT_ERR_NEGATIVE_LOCKTIME);\n\n// To provide for future soft-fork extensibility, if the\n// operand has the disabled lock-time flag set,\n// CHECKSEQUENCEVERIFY behaves as a NOP.\nif ((nSequence & CTxIn::SEQUENCE_LOCKTIME_DISABLE_FLAG) != 0)\nbreak;\n\n// Compare the specified sequence number with the input.\nif (!checker.CheckSequence(nSequence))\nreturn set_error(serror, SCRIPT_ERR_UNSATISFIED_LOCKTIME);\n\nbreak;\n}\n\nbool TransactionSignatureChecker::CheckSequence(const CScriptNum& nSequence) const\n{\n// Relative lock times are supported by comparing the passed\n// in operand to the sequence number of the input.\nconst int64_t txToSequence = (int64_t)txTo->vin[nIn].nSequence;\n\n// Fail if the transaction's version number is not set high\n// enough to trigger BIP 68 rules.\nif (static_cast<uint32_t>(txTo->nVersion) < 2)\nreturn false;\n\n// Sequence numbers with their most significant bit set are not\n// consensus constrained. Testing that the transaction's sequence\n// number do not have this bit set prevents using this property\n// to get around a CHECKSEQUENCEVERIFY check.\nif (txToSequence & CTxIn::SEQUENCE_LOCKTIME_DISABLE_FLAG)\nreturn false;\n\n// Mask off any bits that do not have consensus-enforced meaning\n// before doing the integer comparisons\nconst uint32_t nLockTimeMask = CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG | CTxIn::SEQUENCE_LOCKTIME_MASK;\nconst int64_t txToSequenceMasked = txToSequence & nLockTimeMask;\nconst CScriptNum nSequenceMasked = nSequence & nLockTimeMask;\n\n// There are two kinds of nSequence: lock-by-blockheight\n// and lock-by-blocktime, distinguished by whether\n// nSequenceMasked < CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG.\n//\n// We want to compare apples to apples, so fail the script\n// unless the type of nSequenceMasked being tested is the same as\n// the nSequenceMasked in the transaction.\nif (!(\n(txToSequenceMasked <  CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG && nSequenceMasked <  CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG) ||\n(txToSequenceMasked >= CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG && nSequenceMasked >= CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG)\n))\nreturn false;\n\n// Now that we know we're comparing apples-to-apples, the\n// comparison is a simple numeric one.\nif (nSequenceMasked > txToSequenceMasked)\nreturn false;\n\nreturn true;\n}"
    },
    {
      "header": "Reference Implementation {#reference_implementation}",
      "content": "A reference implementation is provided by the following pull request:\n\n<https://github.com/bitcoin/bitcoin/pull/7524>"
    },
    {
      "header": "Deployment",
      "content": "This BIP is to be deployed by \\\"versionbits\\\" BIP9 using bit 0.\n\nFor Bitcoin **mainnet**, the BIP9 **starttime** will be midnight 1st May\n2016 UTC (Epoch timestamp 1462060800) and BIP9 **timeout** will be\nmidnight 1st May 2017 UTC (Epoch timestamp 1493596800).\n\nFor Bitcoin **testnet**, the BIP9 **starttime** will be midnight 1st\nMarch 2016 UTC (Epoch timestamp 1456790400) and BIP9 **timeout** will be\nmidnight 1st May 2017 UTC (Epoch timestamp 1493596800).\n\nThis BIP must be deployed simultaneously with BIP68 and BIP113 using the\nsame deployment mechanism."
    },
    {
      "header": "Credits",
      "content": "Mark Friedenbach invented the application of sequence numbers to achieve\nrelative lock-time, and wrote the reference implementation of\nCHECKSEQUENCEVERIFY.\n\nThe reference implementation and this BIP was based heavily on work done\nby Peter Todd for the closely related BIP 65.\n\nBtcDrak authored this BIP document.\n\nThanks to Eric Lombrozo and Anthony Towns for contributing example use\ncases."
    },
    {
      "header": "References",
      "content": "[BIP 9](https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki)\nVersionbits\n\n[BIP 68](https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki)\nRelative lock-time through consensus-enforced sequence numbers\n\n[BIP 65](https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki)\nOP_CHECKLOCKTIMEVERIFY\n\n[BIP\n113](https://github.com/bitcoin/bips/blob/master/bip-0113.mediawiki)\nMedian past block time for time-lock constraints\n\n[HTLCs using OP_CHECKSEQUENCEVERIFY/OP_LOCKTIMEVERIFY and revocation\nhashes](http://lists.linuxfoundation.org/pipermail/lightning-dev/2015-July/000021.html)\n\n[Lightning\nNetwork](http://lightning.network/lightning-network-paper.pdf)\n\n[Deployable\nLightning](https://github.com/ElementsProject/lightning/blob/master/doc/deployable-lightning.pdf)\n\n[Scaling Bitcoin to Billions of Transactions Per\nDay](http://diyhpl.us/diyhpluswiki/transcripts/sf-bitcoin-meetup/2015-02-23-scaling-bitcoin-to-billions-of-transactions-per-day/)\n\n[Softfork deployment\nconsiderations](http://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-August/010396.html)\n\n[Version\nbits](https://web.archive.org/web/20210925124425/https://gist.github.com/sipa/bf69659f43e763540550)\n\n[Jeremy Spilman Micropayment\nChannels](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2013-April/002433.html)"
    },
    {
      "header": "Copyright",
      "content": "This document is placed in the public domain."
    }
  ]
}