{
  "BIP": "127",
  "Layer": "Applications",
  "Title": "Simple Proof-of-Reserves Transactions",
  "Author": "Steven Roose <steven@stevenroose.org>",
  "Comments-Summary": "No comments yet.",
  "Comments-URI": "https://github.com/bitcoin/bips/wiki/Comments:BIP-0127",
  "Status": "Draft",
  "Type": "Standards Track",
  "Created": "2019-01-28",
  "License": "CC0-1.0",
  "sections": [
    {
      "header": "Abstract",
      "content": "This BIP describes a simple way to construct proof-of-reserves\ntransactions. This proposal formalizes a standard format for\nconstructing such proofs, easing their construction with existing wallet\ninfrastructure and enabling general proof-verification software. It\nrelies on existing standards such as regular Bitcoin transaction\nserialization/validation and the BIP 174 PSBT format. The proposal also\nincludes the description of a PSBT extension for a better user\nexperience."
    },
    {
      "header": "Copyright",
      "content": "This BIP is licensed under the Creative Commons CC0 1.0 Universal\nlicense."
    },
    {
      "header": "Motivation",
      "content": "From the very early days in the history of Bitcoin, there have been\ncompanies managing bitcoins for their users. These users give up control\nover their coins in return for a certain service. Inevitably, there have\nbeen many cases of companies losing their users\\' bitcoins without\ntimely disclosing such events to the public. Proofs of Reserves are a\nway for companies managing large amounts of bitcoins to prove ownership\nover a given amount of funds. The regular proof of control helps to\nensure that no significant loss has occurred.\n\nWhile the term proof-of-reserves is not new by any means, the procedure\nis not very common among high-value custodian companies. One of the\nreasons for this is that every company that wants to perform a\nproof-of-reserves has to construct its own way to do so. Accordingly,\ntheir users have to understand the construction of the proof in order to\nbe able to verify it. This raises the bar of entry both for custodians\nand for users."
    },
    {
      "header": "What this BIP is not doing {#what_this_bip_is_not_doing}",
      "content": "The proof-of-reserve construction described in this document has some\nknown shortcomings, mostly with regards to its privacy properties. While\nthere exists research about improved proof-of-reserves mechanisms that\nhave much better privacy properties[^1], this BIP intentionally only\nformalizes the de-facto existing method."
    },
    {
      "header": "Specification",
      "content": "Our specification consists of two parts:\n\n1.  the format for the actual proofs\n2.  a file format used to package a set of proofs and relevant metadata\n\nThe final construction should have the following properties:\n\n-   flexible proof construction to support complex wallet\ninfrastructures\n-   easy integration with existing wallet solutions (both hardware and\nsoftware wallets)\n-   support for verification via a standard procedure, regardless of\npublisher of the proof\n-   proof prevents reuse of proofs by other parties by committing to a\nmessage\n-   allow validating that the issuer had the funds under his control at\na certain block, regardless of what happened after that block"
    },
    {
      "header": "Proof Format {#proof_format}",
      "content": "To allow for maximal compatibility with existing systems, proofs are\nformatted as regular Bitcoin transactions. However, one small adaptation\nto the transaction is made that has two functions:\n\n1.  make the transaction unspendable to avoid putting funds at risk\n2.  link the proof to the issuer of the proof to prevent copying proofs\nfrom other custodians\n\nThe resulting construction is a Bitcoin transaction with the following\ncharacteristics:\n\n-   The first input (the \\\"commitment input\\\")\n-   MUST have the txid part of the previous outpoint set to the\nSHA-256 hash of the commitment message prefixed with\n\\\"Proof-of-Reserves: \\\"[^2] and index 0.\n-   The remaining inputs\n-   MUST have signatures that commit to the commitment input (e.g.\nusing `SIGHASH_ALL`).\n-   The transaction MUST have a single output that is the exact sum of\nall the inputs, assuming the commitment input to have 0 value; this\nmeans the transaction has no miner fee.\n\nThe existence of the first input (which is just a commitment hash)\nensures that this transaction is invalid and can never be confirmed."
    },
    {
      "header": "Proof File Format {#proof_file_format}",
      "content": "In theory, the first part of the specification would be sufficient as a\nminimum viable standard. However, there are a number of motivations to\nextend the standard with an extra layer of metadata:\n\n1.  constructing and combining multiple proofs\n\n:   Having thousands of UTXOs spread across different offline and\nonline wallets could make it difficult to construct a single\nproof transaction with all UTXOs. Allowing multiple proof\ntransactions with the same commitment message and block number\ngives extra flexibility to custodians with complex wallet\ninfrastructure without making the combined proof less secure.\n2.  metadata for verification\n\n:   Not all systems that will be used for verification have access\nto a full index of all transactions. However, proofs should be\neasily verifiable even after some of the UTXOs used in the proof\nare no longer unspent. Metadata present in the proof allows for\nrelatively efficient verification of proofs even if no\ntransaction index is available.\n3.  potential future improvements\n\n:   The extensible metadata format allows for amending the standard\nin the future. One potential improvement would be having UTXO\nset commitments. These would allow the proofs-of-reserves to\ncome with accompanying proofs-of-inclusion of all used UTXOs in\nthe UTXO set at the block of proof construction (making\nvalidation even more efficient).\n\nThe proposed proof-file format provides a standard way of combining\nmultiple proofs and associated metadata. The specification of the format\nis in the Protocol Buffers[^3] format.\n\nsyntax = \"proto3\";\nimport \"google/protobuf/any.proto\";\n\nmessage OutputMeta {\n// Identify the outpoint.\nbytes txid = 1;\nuint32 vout = 2;\n\n// The block hash of the block where this output was created.\nbytes block_hash = 3;\n}\n\nmessage FinalProof {\n// The proof transaction.  Should be able to be parsed like a regular\n// Bitcoin transaction.\nbytes proof_tx = 1;\n\n// The metadata of the ouputs used in the proof transaction.\nrepeated OutputMeta output_metadata = 2;\n}\n\nmessage ProofOfReserves {\n// A version number for this format to enable extending it with\n// additional fields.\nuint32 version = 1;\n\n// The network magic for the network in which the proofs are valid.\n// 0xD9B4BEF9 for mainnet, 0x0709110B for testnet\n//TODO consider BIP44 coin type ids instead:\n// https://github.com/satoshilabs/slips/blob/master/slip-0044.md\nuint32 network_magic = 2;\n\n// The commitment message for this proof-of-reserves.\n// This message is global for all the proofs.\nstring message = 3;\n\n// The block at which this proof is supposed to be validated.\n// Verification should take into account unspentness of outputs at this\n// block height.\nbytes block_hash = 4;\n\n// The set of final proof transactions with their output metadata.\nrepeated FinalProof final_proofs = 5;\n\n// Reserved field that can potentially be used by proof-construction tools.\n// It can be ignored for verification.\nrepeated google.protobuf.Any pending_proofs = 6;\n}\n\nThe last field, `pending_proofs`, leaves open some space in the same\nfile that can be used by proof-construction tools. This allows them to\nconstruct different proofs incrementally without having to switch\nbetween file formats."
    },
    {
      "header": "PSBT (BIP 174) extension {#psbt_bip_174_extension}",
      "content": "The \\\"commitment input\\\" detailed in the proof format section does not\nspend an existing UTXO and thus shouldn\\'t be signed (empty `scriptSig`\nand witness). This can cause some problems when signing this type of\ntransactions. For example, hardware wallets often require the signer to\nprovide information about all inputs of transactions they are signing,\nsuch as the previous output or previous transaction; this data obviously\ndoesn\\'t exist for the commitment inputs.\n\nFor most existing devices, it\\'s possible to circumvent these\nrequirements by providing dummy data or by instructing the device to\nignore this specific input. However, there is still a UX problem.\nBecause the hardware wallet device doesn\\'t recognize the transaction as\na proof-of-reserves transaction it will think it is signing a regular\ntransaction that is spending all the money in the UTXOs. Most devices\nwill ask for confirmation with a message along the lines of \\\"Are you\nsure you want to send XXX BTC to address \\[\\...\\]?\\\". This is not the\nbest user experience.\n\nAn addition to the BIP 174 PSBT format could help signing devices to\nrecognize proof-of-reserve transactions. The following field is added to\nthe BIP 174 `INPUT` map:\n\n-   Type: Proof-of-reserves commitment `PSBT_IN_POR_COMMITMENT = 0x09`\n-   Key: None. The key must only contain the 1 byte type.\n-   `{0x09}`\n-   Value: The UTF-8 encoded commitment message string for the\nproof-of-reserves.\n-   `{porCommitment}`\n\nWallets processing an input that has this field set\n\n-   MUST make sure the txid of the previous outpoint is set to the\nSHA-256 hash of the prefixed commitment message string, as detailed\nabove;\n-   MUST assume the input value to be 0 (without requiring the previous\noutput or transaction to be provided);\n-   SHOULD display the commitment message to ask the user for\nconfirmation before signing any inputs;\n-   SHOULD only provide signatures with a signature hash that commits to\nthis input;\n-   SHOULD accept an empty `scriptSig` for this input (as if the\n`scriptPubKey` was `OP_TRUE`)."
    },
    {
      "header": "Compatibility",
      "content": "The proof transaction specification is based on the Bitcoin transaction\nserialization protocol and will thus always be compatible with\nserializers that can interpret Bitcoin transactions. The protobuf file\nformat is custom to this BIP and has a version byte to enable updates\nwhile attempting to remain backwards compatible."
    },
    {
      "header": "Implementations",
      "content": "A proof-of-concept implementation of the PSBT extension in the\n[rust-bitcoin](https://github.com/rust-bitcoin/rust-bitcoin) project can\nbe found in the `psbt-por` branch here:\n<https://github.com/stevenroose/rust-bitcoin/tree/psbt-por>\n\nA work-in-progress implementation of a tool that produces and verifies\nproofs in the described format can be found here:\n<https://github.com/stevenroose/reserves>"
    },
    {
      "header": "Footnotes",
      "content": "```{=html}\n<references />\n```\n\n[^1]: Dagher, Gaby G., Benedikt B\u00fcnz, Joseph Bonneau, Jeremy Clark, and\nDan Boneh. \\\"Provisions: Privacy-preserving proofs of solvency for\nBitcoin exchanges.\\\" (2015).\n\n[^2]: If the message is \\\"Some Message\\\", the txid part should be\n`SHA-256(\"Proof-of-Reserves: Some Message\")` with the string encoded\nas UTF-8.\n\n[^3]: <https://github.com/protocolbuffers/protobuf/>"
    }
  ]
}