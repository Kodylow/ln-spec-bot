{
  "BIP": "88",
  "Layer": "Applications",
  "Title": "Hierarchical Deterministic Path Templates",
  "Author": "Dmitry Petukhov <dp@simplexum.com>",
  "Comments-Summary": "No comments yet.",
  "Comments-URI": "https://github.com/bitcoin/bips/wiki/Comments:BIP-0088",
  "Status": "Proposed",
  "Type": "Informational",
  "Created": "2020-06-23",
  "License": "BSD-2-Clause",
  "sections": [
    {
      "header": "Abstract",
      "content": "This document describes a format for the representation of the templates\nthat specify the constraints that can be imposed on BIP32 derivation\npaths.\n\nThe constraints specified by the templates allow to easily discern\n\\'valid\\' paths, that match the constraints, and \\'invalid\\' paths, that\nexceed the constraints."
    },
    {
      "header": "Copyright",
      "content": "This BIP is licensed under the 2-clause BSD license."
    },
    {
      "header": "Motivation",
      "content": "BIP32 derivation path format is universal, and a number of schemes for\nderivation were proposed in BIP43 and other documents, such as BIPs\n44,45,49,84. The flexibility of the format also allowed industry\nparticipants to implement custom derivation shemes that fit particular\npurposes, but not necessarily useful in general.\n\nEven when existing BIPs for derivation schemes are used, their usage is\nnot uniform across the different wallets, in part because software\nvendors might have different considerations and priorities when making\ndecisions about derivation paths. This creates friction for users, which\nmight face problems when they try to access their coins using the wallet\nthat derives addresses differently than the one they used before."
    },
    {
      "header": "Known solutions {#known_solutions}",
      "content": "The problem is common enough to warrant the creation of a dedicated\nwebsite ([walletsrecovery.org](https://walletsrecovery.org/)) that\ntracks paths used by different wallets.\n\nAt the time of writing, this website has used their own format to\nsuccintly describe multiple derivation paths. As far as author knows, it\nwas the only publicitly used format to describe path templates before\nintroduction of this BIP. The format was not specified anywhere beside\nthe main page of the website. It used `|` to denote alternative\nderivation indexes (example: `m/|44'|49'|84'/0'/0'`) or whole\nalternative paths (`m/44'/0'/0'|m/44'/1'/0'`).\n\nIt was not declared as a template format to use for processing by\nsoftware, and seems to be an ad-hoc format only intended for\nillustration. In contrast to this ad-hoc format, the format described in\nthis BIP is intended for unambigouos parsing by software, and to be\neasily read by humans at the same time. Humans can visually detect the\n\\'templated\\' parts of the path more easily than the use of `|` in the\ntemplate could allow. Wider range of paths can be defined in a single\ntemplate more succintly and unambiguously."
    },
    {
      "header": "Intended use and advantages {#intended_use_and_advantages}",
      "content": "Wallet software authors can use the proposed format to describe the\nderivation paths that their software uses. This can improve user\nexperience when switching to different wallet software, restoring access\nto old wallets, etc.\n\nUnrestricted derivation path usage might be unsafe in certain contexts.\nIn particular, when \\\"change\\\" outputs of a transaction are sent to the\naddresses derived via paths unknown to the sender, the sender might lose\naccess to the whole change amount.\n\nA simplistic approach of hard-coding the checks for well-known paths\ninto software and firmware leads to reduced interoperability. Vendors\ncannot choose custom paths that are appropriate for their particular,\nnon-general-purpose applications, and are forced to shoehorn their\nsolutions into using well-known paths, or convince other vendors to\nsupport their custom paths. This approach scales poorly.\n\nA flexible approach proposed in this document is to define a standard\nnotation for \\\"BIP32 path templates\\\" that succintly describes the\nconstraints to impose on the derivation path.\n\nWide support for these path templates will increase interoperability and\nflexibility of solutions, and will allow vendors and individual\ndevelopers to easily define their own custom restrictions. This way,\nthey will be able to deal with the risks of accidental or malicious use\nof unrestricted derivation paths in a more flexible and precise manner.\n\nWell-known path templates can be pre-configured by default on devices\nand applications, but users can have an option to turn off the templates\nthat are not relevant to their uses.\n\nHaving a standardized format for custom path templates will enable a\ncommon approach to be developed in the enforcement of\napplication-specific path restrictions in devices and applications. One\nexample of such an approach might be for devices to allow\napplication-specific profiles with path templates and possibly other\ncustom parameters. Care must be taken to prevent the accidental\ninstallation of malicious or incorrect profiles, though."
    },
    {
      "header": "Specification",
      "content": "The format for the template was choosen to make it easy to read,\nconvenient and visually unambigous.\n\nTemplate starts with optional prefix `m/`, and then one or more sections\ndelimited by the slash character (`/`).\n\nImplementations MAY limit the maximum number of sections.\n\nEach section consists of *index template*, optionally followed by the\nhardened marker: either an apostrophe (`'`) or letter `h`.\n\nIndex template can be:\n\n-   An integer value from 0 to 2147483647 (\\\"Unit index template\\\")\n-   A single `*` character, which denotes any value from 0 to 2147483647\n(\\\"Wildcard index template\\\")\n-   The `{` character, followed by a number of *index ranges* delimited\nby commas (`,`), followed by `}` character (\\\"Ranged index\ntemplate\\\")\n\nImplementations MAY limit the maximum number of index ranges within the\nRanged index template.\n\nIf an index template is immediately followed by hardened marker, this\nmeans that all values specified in this index template is to be\nincreased by 2147483648 for the purposes of matching.\n\nIndex range can be:\n\n-   An integer value from 0 to 2147483647 (\\\"Unit range\\\")\n-   An integer value from 0 to 2147483647, followed by the `-`\ncharacter, followed by another integer value from 0 to 2147483647\n(\\\"Non-unit range\\\")\n\nFor Non-unit range, value on the left side of the `-` character is the\nrange_start, and the value on the right side of the `-` character is the\nrange_end.\n\nFor Unit range, we say that range_start is equal to range_end, even\nthough there is no start/end in the Unit range.\n\nUnit index template contains a single index range, which is the Unit\nrange\n\nWildcard index template contains a single index range, and we say that\nits range_start is set to 0 and its range_end is set to 2147483647\n\nConstraints:\n\n1.  To avoid ambiguity, whitespace MUST NOT appear within the path\ntemplate.\n2.  Commas within the Ranged index template MUST only appear in between\nindex ranges.\n3.  To avoid ambiguity, an index range that matches a single value MUST\nbe specified as Unit range.\n4.  To avoid ambiguity, an index range `0-2147483647` is not allowed,\nand MUST be specified as Wildcard index template instead\n5.  For Non-unit range, range_end MUST be larger than range_start.\n6.  If there is more than one index range within the Ranged index\ntemplate, range_start of the second and any subsequent range MUST be\nlarger than the range_end of the preceeding range.\n7.  To avoid ambiguity, all representations of integer values larger\nthan 0 MUST NOT start with character `0` (no leading zeroes\nallowed).\n8.  If hardened marker appears within any section in the path template,\nall preceding sections MUST also specify hardened matching.\n9.  To avoid ambiguity, if a hardened marker appears within any section\nin the path template, all preceding sections MUST also use the same\nhardened marker (either `h` or `'`).\n10. To avoid ambiguity, trailing slashes (for example, `1/2/`) and\nduplicate slashes (for example, `0//1`) MUST NOT appear in the\ntemplate.\n\nIt may be desireable to have fully unambiguous encoding, where for each\nvalid path template string, there is no other valid template string that\nmatches the exact same set of paths. This would enable someone to\ncompare templates for equality through a simple string equality check,\nwithout any parsing.\n\nTo achieve this, two extra rules are needed:\n\n-   Within Ranged index template, subsequent range MUST NOT start with\nthe value that is equal to the end of the previous range plus one.\nThus, `{1,2,3-5}` is not allowed, and should be specified as `{1-5}`\ninstead. This rule might make templates less convenient for frequent\nedits, though.\n\n```{=html}\n<!-- -->\n```\n-   Only one type of hardened marker should be allowed (either `h` or\n`'`).\n\nInstead of requiring the second extra rule, implementations can simply\nreplace one type of marker with another in the template strings before\ncomparing them."
    },
    {
      "header": "Full and partial templates {#full_and_partial_templates}",
      "content": "If the template starts with `m/`, that means that this is the \\\"full\\\"\ntemplate, that matches the whole path.\n\nIf the template does not start with `m/`, that means that this is a\n\\\"partial\\\" template, and it can be used to match a part of the path, in\nthe contexts where this might be appropriate (for example, when\nconstraints for the suffix of the path might be dynamic, while\nconstraints for the prefix of the path are fixed).\n\nFull template can be combined with partial template, where partial\ntemplate extends full template, resulting in new, longer full template.\n\nPartial template can be combined with another partial template,\nresulting in new, longer partial template.\n\nFull template can not be combined with another full template.\n\nImplementations MUST support parsing full templates and matching paths\nagainst full templates.\n\nImplementations MAY support parsing partial templates and matching\nportions of the paths against partial templates, as well as combining\nthe templates."
    },
    {
      "header": "Parsing result {#parsing_result}",
      "content": "The result of successful parsing of a valid path template can be\nrepresented by a list of sections, where each section is a list of index\nranges, where index range is a tuple of (range_start, range_end). The\nlength of the list of sections is also referred to as the \\\"length of\nthe template\\\"."
    },
    {
      "header": "Matching",
      "content": "The matching is to be performed against a list of integer values that\nrepresent a BIP32 path (or a portion of BIP32 path, for partial\ntemplates). The length of this list is referred to as the \\\"length of\nthe path\\\".\n\nNon-hardened indexes in this list should be represented by values from 0\nto 2147483647.\n\nHardened indexes in this list should be represented by values from\n2147483648 to 4294967295.\n\nThe matching algorithm:\n\n`\u00a0\u00a0\u00a01.\u00a0If\u00a0the\u00a0length\u00a0of\u00a0the\u00a0path\u00a0differs\u00a0from\u00a0the\u00a0length\u00a0of\u00a0the\u00a0template,\u00a0fail`\\\n`\u00a0\u00a0\u00a02.\u00a0For\u00a0each\u00a0value\u00a0V\u00a0at\u00a0position\u00a0N\u00a0in\u00a0the\u00a0path:`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0If\u00a0for\u00a0all\u00a0index\u00a0ranges\u00a0within\u00a0the\u00a0section\u00a0at\u00a0position\u00a0N\u00a0in\u00a0the\u00a0template,`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value\u00a0V\u00a0is\u00a0either\u00a0less\u00a0than\u00a0range_start,\u00a0or\u00a0greater\u00a0than\u00a0range_end,\u00a0fail`\\\n`\u00a0\u00a0\u00a03.\u00a0Otherwise,\u00a0succeed`"
    },
    {
      "header": "Formal specification {#formal_specification}",
      "content": "The finite state machine (FSM) for the parser of the described template\nformat, and the matching formula are specified in TLA+ specification\nlanguage at <https://github.com/dgpv/bip32_template_parse_tplaplus_spec>\n\nThe specification can be used with TLC checker and accompanying script\nto generate test data for the implementations."
    },
    {
      "header": "Implementations",
      "content": "While the formal specification specifies an FSM, which would be\nconvenient for implementation without access to rich string handling\nfacilities, when such facilities are available, the implementation might\nuse the whole-string deconstruction approach where the templates are\nfirst split into sections, then sections are split into index templates,\nand then each index template are parsed individually.\n\nA FSM-based approach can be made close to the formal specification,\nthough, and the test data generated with TLC checker would give much\nbetter coverage for a FSM based implementation. If the template string\ncontains several errors, an implementation that uses deconstruction\napproach might detect some of these errors earlier than FSM-based\nimplementation, and vise versa.\n\nAt the moment, three implementations exist:\n\n-   FSM implementation in C:\n<https://github.com/dgpv/bip32_template_c_implementation>\n-   FSM implementation in Python (micropython compatible):\n<https://github.com/dgpv/bip32_template_python_implementation>\n-   non-FSM implementation in python: BIP32PathTemplate class in\nbitcointx.core.key module of python-bitcointx library\n(https://github.com/Simplexum/python-bitcointx)"
    },
    {
      "header": "Compatibility",
      "content": "The full path template that only contains Unit index templates\nrepresents a fully valid BIP32 path.\n\nThere\\'s no other path template standards that is known to the author\ncurrently.\n\nThere is a discussion on path templating for bitcoin script descriptors\nat <https://github.com/bitcoin/bitcoin/issues/17190>, which proposes the\nformat `xpub...{0,1}/*`, of which the `{0,1}/*` part would correspond to\nthe partial path template in the format of this BIP."
    },
    {
      "header": "Examples",
      "content": "`m/{44,49,84}'/0'/0'/{0-1}/{0-50000}` specifies a full template that\nmatches both external and internal chains of BIP44, BIP49 and BIP84\npaths, with a constraint that the address index cannot be larger than\n50000\n\nIts representation after parsing can be (using Python syntax, ignoring\nfull/partial distinction):\n\n`\u00a0\u00a0\u00a0[[(2147483692,\u00a02147483692),\u00a0(2147483697,\u00a02147483697),\u00a0(2147483732,\u00a02147483732)),`\\\n`\u00a0\u00a0\u00a0\u00a0[(2147483648,\u00a02147483648)],`\\\n`\u00a0\u00a0\u00a0\u00a0[(2147483648,\u00a02147483648)],`\\\n`\u00a0\u00a0\u00a0\u00a0[(0,\u00a01)],`\\\n`\u00a0\u00a0\u00a0\u00a0[(0,\u00a050000)]]`\n\n`{0-2,33,123}/*` specifies a partial template that matches non-hardened\nvalues 0, 1, 2, 33, 123 as first index, and any non-hardened value at\nsecond index\n\nIts representation after parsing can be:\n\n`\u00a0\u00a0\u00a0[[(0,\u00a02),\u00a0(33,\u00a033),\u00a0(123,\u00a0123)],\u00a0[(0,\u00a02147483647)]]`\n\n`*h/0` specifies a partial template that matches any hardened index\nfollowed by non-hardened index 0\n\nIts representation after parsing can be:\n\n`\u00a0\u00a0\u00a0[[(2147483648,\u00a04294967295)],\u00a0[(0,\u00a00)]]`"
    },
    {
      "header": "Acknowledgements",
      "content": "Special thanks to Peter D. Gray, Dr. Maxim Orlovsky, Robert Spigler and\nothers for their feedback on the specification, and to Janine\n(github:@Enegnei) for the help in preparing the draft."
    }
  ]
}