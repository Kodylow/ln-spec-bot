{
  "BIP": "38",
  "Layer": "Applications",
  "Title": "Passphrase-protected private key",
  "Author": "Mike Caldwell <mcaldwell@swipeclock.com>",
  "Comments-Summary": "Unanimously Discourage for implementation",
  "Comments-URI": "https://github.com/bitcoin/bips/wiki/Comments:BIP-0038",
  "Status": "Draft (Some confusion applies: The announcements for this never made it to the list, so it hasn't had public discussion)",
  "Type": "Standards Track",
  "Created": "2012-11-20",
  "License": "PD",
  "sections": [
    {
      "header": "Abstract",
      "content": "A method is proposed for encrypting and encoding a passphrase-protected\nBitcoin private key record in the form of a 58-character\nBase58Check-encoded printable string. Encrypted private key records are\nintended for use on paper wallets and physical Bitcoins. Each record\nstring contains all the information needed to reconstitute the private\nkey except for a passphrase, and the methodology uses salting and\n*scrypt* to resist brute-force attacks.\n\nThe method provides two encoding methodologies - one permitting any\nknown private key to be encrypted with any passphrase, and another\npermitting a shared private key generation scheme where the party\ngenerating the final key string and its associated Bitcoin address (such\nas a physical bitcoin manufacturer) knows only a string derived from the\noriginal passphrase, and where the original passphrase is needed in\norder to actually redeem funds sent to the associated Bitcoin address.\n\nA 32-bit hash of the resulting Bitcoin address is encoded in plaintext\nwithin each encrypted key, so it can be correlated to a Bitcoin address\nwith reasonable probability by someone not knowing the passphrase. The\ncomplete Bitcoin address can be derived through successful decryption of\nthe key record."
    },
    {
      "header": "Motivation",
      "content": "The motivation to make this proposal stems from observations of the way\nphysical bitcoins and paper wallets are used.\n\nAn issuer of physical bitcoins must be trustworthy and trusted. Even if\ntrustworthy, users are rightful to be skeptical about a third party with\ntheoretical access to take their funds. A physical bitcoin that cannot\nbe compromised by its issuer is always more intrinsically valuable than\none that can.\n\nA two-factor physical bitcoin solution is highly useful to individuals\nand organizations wishing to securely own bitcoins without any risk of\nelectronic theft and without the responsibility of climbing the\ntechnological learning curve necessary to produce such an environment\nthemselves. Two-factor physical bitcoins allow a secure storage solution\nto be put in a box and sold on the open market, greatly enlarging the\nnumber of people who are able to securely store bitcoins.\n\nExisting methodologies for creating two-factor physical bitcoins are\nlimited and cumbersome. At the time of this proposal, a user could\ncreate their own private key, submit the public key to the physical\nbitcoin issuer, and then receive a physical bitcoin that must be kept\ntogether with some sort of record of the user-generated private key, and\nfinally, must be redeemed through a tool. The fact that the physical\nbitcoin must be kept together with a user-produced private key negates\nmuch of the benefit of the physical bitcoin - the user may as well just\nprint and maintain a private key.\n\nA standardized password-protected private key format makes acquiring and\nredeeming two-factor physical bitcoins simpler for the user. Instead of\nmaintaining a private key that cannot be memorized, the user may choose\na passphrase of their choice. The passphrase may be much shorter than\nthe length of a typical private key, short enough that they could use a\nlabel or engraver to permanently commit their passphrase to their\nphysical Bitcoin piece once they have received it. By adopting a\nstandard way to encrypt a private key, we maximize the possibility that\nthey\\'ll be able to redeem their funds in the venue of their choice,\nrather than relying on an executable redemption tool they may not wish\nto download.\n\nPassword and passphrase-protected private keys enable new practical use\ncases for sending bitcoins from person to person. Someone wanting to\nsend bitcoins through postal mail could send a password-protected paper\nwallet and give the recipient the passphrase over the phone or e-mail,\nmaking the transfer safe from interception of either channel. A user of\npaper wallets or Bitcoin banknote-style vouchers (\\\"cash\\\") could carry\nfunded encrypted private keys while leaving a copy at home as an element\nof protection against accidental loss or theft. A user of paper wallets\nwho leaves bitcoins in a bank vault or safety deposit box could keep the\npassword at home or share it with trusted associates as protection\nagainst someone at the bank gaining access to the paper wallets and\nspending from them. The foreseeable and unforeseeable use cases for\npassword-protected private keys are numerous."
    },
    {
      "header": "Copyright",
      "content": "This proposal is hereby placed in the public domain."
    },
    {
      "header": "Rationale",
      "content": ":   ***User story:** As a Bitcoin user who uses paper wallets, I would\nlike the ability to add encryption, so that my Bitcoin paper storage\ncan be two factor: something I have plus something I know.*\n:   ***User story:** As a Bitcoin user who would like to pay a person or\na company with a private key, I do not want to worry that any part\nof the communication path may result in the interception of the key\nand theft of my funds. I would prefer to offer an encrypted private\nkey, and then follow it up with the password using a different\ncommunication channel (e.g. a phone call or SMS).*\n:   ***User story:** (EC-multiplied keys) As a user of physical\nbitcoins, I would like a third party to be able to create\npassword-protected Bitcoin private keys for me, without them knowing\nthe password, so I can benefit from the physical bitcoin without the\nissuer having access to the private key. I would like to be able to\nchoose a password whose minimum length and required format does not\npreclude me from memorizing it or engraving it on my physical\nbitcoin, without exposing me to an undue risk of password cracking\nand/or theft by the manufacturer of the item.*\n:   \\'**\\'User story:** (EC multiplied keys) As a user of paper wallets,\nI would like the ability to generate a large number of Bitcoin\naddresses protected by the same password, while enjoying a high\ndegree of security (highly expensive scrypt parameters), but without\nhaving to incur the scrypt delay for each address I generate."
    },
    {
      "header": "Specification",
      "content": "This proposal makes use of the following functions and definitions:\n\n-   **AES256Encrypt, AES256Decrypt**: the simple form of the well-known\nAES block cipher without consideration for initialization vectors or\nblock chaining. Each of these functions takes a 256-bit key and 16\nbytes of input, and deterministically yields 16 bytes of output.\n-   **SHA256**, a well-known hashing algorithm that takes an arbitrary\nnumber of bytes as input and deterministically yields a 32-byte\nhash.\n-   **scrypt**: A well-known key derivation algorithm. It takes the\nfollowing parameters: (string) password, (string) salt, (int) n,\n(int) r, (int) p, (int) length, and deterministically yields an\narray of bytes whose length is equal to the length parameter.\n-   **ECMultiply**: Multiplication of an elliptic curve point by a\nscalar integer with respect to the [secp256k1](secp256k1 \"wikilink\")\nelliptic curve.\n-   **G, N**: Constants defined as part of the\n[secp256k1](secp256k1 \"wikilink\") elliptic curve. G is an elliptic\ncurve point, and N is a large positive integer.\n-   **[Base58Check](Base58Check \"wikilink\")**: a method for encoding\narrays of bytes using 58 alphanumeric characters commonly used in\nthe Bitcoin ecosystem."
    },
    {
      "header": "Prefix",
      "content": "It is proposed that the resulting Base58Check-encoded string start with\na \\'6\\'. The number \\'6\\' is intended to represent, from the perspective\nof the user, \\\"a private key that needs something else to be usable\\\" -\nan umbrella definition that could be understood in the future to include\nkeys participating in multisig transactions, and was chosen with\ndeference to the existing prefix \\'5\\' most commonly observed in [Wallet\nImport Format](Wallet_Import_Format \"wikilink\") which denotes an\nunencrypted private key.\n\nIt is proposed that the second character ought to give a hint as to what\nis needed as a second factor, and for an encrypted key requiring a\npassphrase, the uppercase letter P is proposed.\n\nTo keep the size of the encrypted key down, no initialization vectors\n(IVs) are used in the AES encryption. Rather, suitable values for\nIV-like use are derived using scrypt from the passphrase and from using\na 32-bit hash of the resulting Bitcoin address as salt."
    },
    {
      "header": "Proposed specification {#proposed_specification}",
      "content": "-   Object identifier prefix: 0x0142 (non-EC-multiplied) or 0x0143\n(EC-multiplied). These are constant bytes that appear at the\nbeginning of the Base58Check-encoded record, and their presence\ncauses the resulting string to have a predictable prefix.\n-   How the user sees it: 58 characters always starting with \\'6P\\'\n-   Visual cues are present in the third character for visually\nidentifying the EC-multiply and compress flag.\n-   Count of payload bytes (beyond prefix): 37\n-   1 byte (*flagbyte*):\n-   the most significant two bits are set as follows to preserve\nthe visibility of the compression flag in the prefix, as\nwell as to keep the payload within the range of allowable\nvalues that keep the \\\"6P\\\" prefix intact. For\nnon-EC-multiplied keys, the bits are 11. For EC-multiplied\nkeys, the bits are 00.\n-   the bit with value 0x20 when set indicates the key should be\nconverted to a base58check encoded P2PKH bitcoin address\nusing the DER compressed public key format. When not set, it\nshould be a base58check encoded P2PKH bitcoin address using\nthe DER uncompressed public key format.\n-   the bits with values 0x10 and 0x08 are reserved for a future\nspecification that contemplates using multisig as a way to\ncombine the factors such that parties in possession of the\nseparate factors can independently sign a proposed\ntransaction without requiring that any party possess both\nfactors. These bits must be 0 to comply with this version of\nthe specification.\n-   the bit with value 0x04 indicates whether a lot and sequence\nnumber are encoded into the first factor, and activates\nspecial behavior for including them in the decryption\nprocess. This applies to EC-multiplied keys only. Must be 0\nfor non-EC-multiplied keys.\n-   remaining bits are reserved for future use and must all be 0\nto comply with this version of the specification.\n-   4 bytes: SHA256(SHA256(expected_bitcoin_address))\\[0\\...3\\],\nused both for typo checking and as salt\n-   16 bytes: Contents depend on whether EC multiplication is used.\n-   16 bytes: lasthalf: An AES-encrypted key material record\n(contents depend on whether EC multiplication is used)\n-   Range in base58check encoding for non-EC-multiplied keys without\ncompression (prefix 6PR):\n-   Minimum value:\n6PRHv1jg1ytiE4kT2QtrUz8gEjMQghZDWg1FuxjdYDzjUkcJeGdFj9q9Vi\n(based on 01 42 C0 plus thirty-six 00\\'s)\n-   Maximum value:\n6PRWdmoT1ZursVcr5NiD14p5bHrKVGPG7yeEoEeRb8FVaqYSHnZTLEbYsU\n(based on 01 42 C0 plus thirty-six FF\\'s)\n-   Range in base58check encoding for non-EC-multiplied keys with\ncompression (prefix 6PY):\n-   Minimum value:\n6PYJxKpVnkXUsnZAfD2B5ZsZafJYNp4ezQQeCjs39494qUUXLnXijLx6LG\n(based on 01 42 E0 plus thirty-six 00\\'s)\n-   Maximum value:\n6PYXg5tGnLYdXDRZiAqXbeYxwDoTBNthbi3d61mqBxPpwZQezJTvQHsCnk\n(based on 01 42 E0 plus thirty-six FF\\'s)\n-   Range in base58check encoding for EC-multiplied keys without\ncompression (prefix 6Pf):\n-   Minimum value:\n6PfKzduKZXAFXWMtJ19Vg9cSvbFg4va6U8p2VWzSjtHQCCLk3JSBpUvfpf\n(based on 01 43 00 plus thirty-six 00\\'s)\n-   Maximum value:\n6PfYiPy6Z7BQAwEHLxxrCEHrH9kasVQ95ST1NnuEnnYAJHGsgpNPQ9dTHc\n(based on 01 43 00 plus thirty-six FF\\'s)\n-   Range in base58check encoding for EC-multiplied keys with\ncompression (prefix 6Pn):\n-   Minimum value:\n6PnM2wz9LHo2BEAbvoGpGjMLGXCom35XwsDQnJ7rLiRjYvCxjpLenmoBsR\n(based on 01 43 20 plus thirty-six 00\\'s)\n-   Maximum value:\n6PnZki3vKspApf2zym6Anp2jd5hiZbuaZArPfa2ePcgVf196PLGrQNyVUh\n(based on 01 43 20 plus thirty-six FF\\'s)"
    },
    {
      "header": "Encryption when EC multiply flag is not used {#encryption_when_ec_multiply_flag_is_not_used}",
      "content": "Encrypting a private key without the EC multiplication offers the\nadvantage that any known private key can be encrypted. The party\nperforming the encryption must know the passphrase.\n\nEncryption steps:\n\n1.  Compute the Bitcoin address (ASCII), and take the first four bytes\nof SHA256(SHA256()) of it. Let\\'s call this \\\"addresshash\\\".\n2.  Derive a key from the passphrase using scrypt\n-   Parameters: *passphrase* is the passphrase itself encoded in\nUTF-8 and normalized using Unicode Normalization Form C (NFC).\nsalt is *addresshash* from the earlier step, n=16384, r=8, p=8,\nlength=64 (n, r, p are provisional and subject to consensus)\n-   Let\\'s split the resulting 64 bytes in half, and call them\n*derivedhalf1* and *derivedhalf2*.\n3.  Do AES256Encrypt(block = bitcoinprivkey\\[0\\...15\\] xor\nderivedhalf1\\[0\\...15\\], key = derivedhalf2), call the 16-byte\nresult *encryptedhalf1*\n4.  Do AES256Encrypt(block = bitcoinprivkey\\[16\\...31\\] xor\nderivedhalf1\\[16\\...31\\], key = derivedhalf2), call the 16-byte\nresult *encryptedhalf2*\n\nThe encrypted private key is the Base58Check-encoded concatenation of\nthe following, which totals 39 bytes without Base58 checksum:\n\n-   0x01 0x42 + *flagbyte* + *salt* + *encryptedhalf1* +\n*encryptedhalf2*\n\nDecryption steps:\n\n1.  Collect encrypted private key and passphrase from user.\n2.  Derive *derivedhalf1* and *derivedhalf2* by passing the passphrase\nand *addresshash* into scrypt function.\n3.  Decrypt *encryptedhalf1* and *encryptedhalf2* using AES256Decrypt,\nmerge them to form the encrypted private key.\n4.  Convert that private key into a Bitcoin address, honoring the\ncompression preference specified in *flagbyte* of the encrypted key\nrecord.\n5.  Hash the Bitcoin address, and verify that *addresshash* from the\nencrypted private key record matches the hash. If not, report that\nthe passphrase entry was incorrect."
    },
    {
      "header": "Encryption when EC multiply mode is used {#encryption_when_ec_multiply_mode_is_used}",
      "content": "Encrypting a private key with EC multiplication offers the ability for\nsomeone to generate encrypted keys knowing only an EC point derived from\nthe original passphrase and some salt generated by the passphrase\\'s\nowner, and without knowing the passphrase itself. Only the person who\nknows the original passphrase can decrypt the private key. A code known\nas an *intermediate code* conveys the information needed to generate\nsuch a key without knowledge of the passphrase.\n\nThis methodology does not offer the ability to encrypt a known private\nkey - this means that the process of creating encrypted keys is also the\nprocess of generating new addresses. On the other hand, this serves a\nsecurity benefit for someone possessing an address generated this way:\nif the address can be recreated by decrypting its private key with a\npassphrase, and it\\'s a strong passphrase one can be certain only he\nknows himself, then he can safely conclude that nobody could know the\nprivate key to that address.\n\nThe person who knows the passphrase and who is the intended beneficiary\nof the private keys is called the *owner*. He will generate one or more\n\\\"intermediate codes\\\", which are the first factor of a two-factor\nredemption system, and will give them to someone else we\\'ll call\n*printer*, who generates a key pair with an intermediate code can know\nthe address and encrypted private key, but cannot decrypt the private\nkey without the original passphrase.\n\nAn intermediate code should, but is not required to, embed a printable\n\\\"lot\\\" and \\\"sequence\\\" number for the benefit of the user. The\nproposal forces these lot and sequence numbers to be included in any\nvalid private keys generated from them. An owner who has requested\nmultiple private keys to be generated for him will be advised by\napplications to ensure that each private key has a unique lot and\nsequence number consistent with the intermediate codes he generated.\nThese mainly help protect *owner* from potential mistakes and/or attacks\nthat could be made by *printer*.\n\nThe \\\"lot\\\" and \\\"sequence\\\" number are combined into a single 32 bit\nnumber. 20 bits are used for the lot number and 12 bits are used for the\nsequence number, such that the lot number can be any decimal number\nbetween 0 and 1048575, and the sequence number can be any decimal number\nbetween 0 and 4095. For programs that generate batches of intermediate\ncodes for an *owner*, it is recommended that lot numbers be chosen at\nrandom within the range 100000-999999 and that sequence numbers are\nassigned starting with 1.\n\nSteps performed by *owner* to generate a single intermediate code, if\nlot and sequence numbers are being included:\n\n1.  Generate 4 random bytes, call them *ownersalt*.\n2.  Encode the lot and sequence numbers as a 4 byte quantity\n(big-endian): lotnumber \\* 4096 + sequencenumber. Call these four\nbytes *lotsequence*.\n3.  Concatenate *ownersalt* + *lotsequence* and call this\n*ownerentropy*.\n4.  Derive a key from the passphrase using scrypt\n-   Parameters: *passphrase* is the passphrase itself encoded in\nUTF-8 and normalized using Unicode Normalization Form C (NFC).\nsalt is *ownersalt*. n=16384, r=8, p=8, length=32.\n-   Call the resulting 32 bytes *prefactor*.\n-   Take SHA256(SHA256(*prefactor* + *ownerentropy*)) and call this\n*passfactor*. The \\\"+\\\" operator is concatenation.\n5.  Compute the elliptic curve point G \\* *passfactor*, and convert the\nresult to compressed notation (33 bytes). Call this *passpoint*.\nCompressed notation is used for this purpose regardless of whether\nthe intent is to create Bitcoin addresses with or without compressed\npublic keys.\n6.  Convey *ownersalt* and *passpoint* to the party generating the keys,\nalong with a checksum to ensure integrity.\n-   The following Base58Check-encoded format is recommended for this\npurpose: magic bytes \\\"2C E9 B3 E1 FF 39 E2 51\\\" followed by\n*ownerentropy*, and then *passpoint*. The resulting string will\nstart with the word \\\"passphrase\\\" due to the constant bytes,\nwill be 72 characters in length, and encodes 49 bytes (8 bytes\nconstant + 8 bytes *ownerentropy* + 33 bytes *passpoint*). The\nchecksum is handled in the Base58Check encoding. The resulting\nstring is called *intermediate_passphrase_string*.\n\nIf lot and sequence numbers are not being included, then follow the same\nprocedure with the following changes:\n\n-   *ownersalt* is 8 random bytes instead of 4, and *lotsequence* is\nomitted. *ownerentropy* becomes an alias for *ownersalt*.\n-   The SHA256 conversion of *prefactor* to *passfactor* is omitted.\nInstead, the output of scrypt is used directly as *passfactor*.\n-   The magic bytes are \\\"2C E9 B3 E1 FF 39 E2 53\\\" instead (the last\nbyte is 0x53 instead of 0x51).\n\nSteps to create new encrypted private keys given\n*intermediate_passphrase_string* from *owner* (so we have\n*ownerentropy*, and *passpoint*, but we do not have *passfactor* or the\npassphrase):\n\n1.  Set *flagbyte*.\n-   Turn on bit 0x20 if the Bitcoin address will be formed by\nhashing the compressed public key (optional, saves space, but\nmany Bitcoin implementations aren\\'t compatible with it)\n-   Turn on bit 0x04 if *ownerentropy* contains a value for\n*lotsequence*. (While it has no effect on the keypair generation\nprocess, the decryption process needs this flag to know how to\nprocess *ownerentropy*)\n2.  Generate 24 random bytes, call this *seedb*. Take\nSHA256(SHA256(*seedb*)) to yield 32 bytes, call this *factorb*.\n3.  ECMultiply *passpoint* by *factorb*. Use the resulting EC point as a\npublic key and hash it into a Bitcoin address using either\ncompressed or uncompressed public key methodology (specify which\nmethodology is used inside *flagbyte*). This is the generated\nBitcoin address, call it *generatedaddress*.\n4.  Take the first four bytes of SHA256(SHA256(*generatedaddress*)) and\ncall it *addresshash*.\n5.  Now we will encrypt *seedb*. Derive a second key from *passpoint*\nusing scrypt\n-   Parameters: *passphrase* is *passpoint* provided from the first\nparty (expressed in binary as 33 bytes). *salt* is\n*addresshash* + *ownerentropy*, n=1024, r=1, p=1, length=64. The\n\\\"+\\\" operator is concatenation.\n-   Split the result into two 32-byte halves and call them\n*derivedhalf1* and *derivedhalf2*.\n6.  Do AES256Encrypt(block = (seedb\\[0\\...15\\] xor\nderivedhalf1\\[0\\...15\\]), key = derivedhalf2), call the 16-byte\nresult *encryptedpart1*\n7.  Do AES256Encrypt(block = ((encryptedpart1\\[8\\...15\\] +\nseedb\\[16\\...23\\]) xor derivedhalf1\\[16\\...31\\]), key =\nderivedhalf2), call the 16-byte result *encryptedpart2*. The \\\"+\\\"\noperator is concatenation.\n\nThe encrypted private key is the Base58Check-encoded concatenation of\nthe following, which totals 39 bytes without Base58 checksum:\n\n-   0x01 0x43 + *flagbyte* + *addresshash* + *ownerentropy* +\n*encryptedpart1*\\[0\\...7\\] + *encryptedpart2*"
    },
    {
      "header": "Confirmation code {#confirmation_code}",
      "content": "The party generating the Bitcoin address has the option to return a\n*confirmation code* back to *owner* which allows *owner* to\nindependently verify that he has been given a Bitcoin address that\nactually depends on his passphrase, and to confirm the lot and sequence\nnumbers (if applicable). This protects *owner* from being given a\nBitcoin address by the second party that is unrelated to the key\nderivation and possibly spendable by the second party. If a Bitcoin\naddress given to *owner* can be successfully regenerated through the\nconfirmation process, *owner* can be reasonably assured that any\nspending without the passphrase is infeasible. This confirmation code is\n75 characters starting with \\\"cfrm38\\\".\n\nTo generate it, we need *flagbyte*, *ownerentropy*, *factorb*,\n*derivedhalf1* and *derivedhalf2* from the original encryption\noperation.\n\n1.  ECMultiply *factorb* by G, call the result *pointb*. The result is\n33 bytes.\n2.  The first byte is 0x02 or 0x03. XOR it by (derivedhalf2\\[31\\] &\n0x01), call the resulting byte *pointbprefix*.\n3.  Do AES256Encrypt(block = (pointb\\[1\\...16\\] xor\nderivedhalf1\\[0\\...15\\]), key = derivedhalf2) and call the result\n*pointbx1*.\n4.  Do AES256Encrypt(block = (pointb\\[17\\...32\\] xor\nderivedhalf1\\[16\\...31\\]), key = derivedhalf2) and call the result\n*pointbx2*.\n5.  Concatenate *pointbprefix* + *pointbx1* + *pointbx2* (total 33\nbytes) and call the result *encryptedpointb*.\n\nThe result is a Base58Check-encoded concatenation of the following:\n\n-   0x64 0x3B 0xF6 0xA8 0x9A + *flagbyte* + *addresshash* +\n*ownerentropy* + *encryptedpointb*\n\nA confirmation tool, given a passphrase and a confirmation code, can\nrecalculate the address, verify the address hash, and then assert the\nfollowing: \\\"It is confirmed that Bitcoin address *address* depends on\nthis passphrase\\\". If applicable: \\\"The lot number is *lotnumber* and\nthe sequence number is *sequencenumber*.\\\"\n\nTo recalculate the address:\n\n1.  Derive *passfactor* using scrypt with *ownerentropy* and the user\\'s\npassphrase and use it to recompute *passpoint*\n2.  Derive decryption key for *pointb* using scrypt with *passpoint*,\n*addresshash*, and *ownerentropy*\n3.  Decrypt *encryptedpointb* to yield *pointb*\n4.  ECMultiply *pointb* by *passfactor*. Use the resulting EC point as a\npublic key and hash it into *address* using either compressed or\nuncompressed public key methodology as specifid in *flagbyte*."
    },
    {
      "header": "Decryption",
      "content": "1.  Collect encrypted private key and passphrase from user.\n2.  Derive *passfactor* using scrypt with *ownersalt* and the user\\'s\npassphrase and use it to recompute *passpoint*\n3.  Derive decryption key for *seedb* using scrypt with *passpoint*,\n*addresshash*, and *ownerentropy*\n4.  Decrypt *encryptedpart2* using AES256Decrypt to yield the last 8\nbytes of *seedb* and the last 8 bytes of *encryptedpart1*.\n5.  Decrypt *encryptedpart1* to yield the remainder of *seedb*.\n6.  Use *seedb* to compute *factorb*.\n7.  Multiply *passfactor* by *factorb* mod N to yield the private key\nassociated with *generatedaddress*.\n8.  Convert that private key into a Bitcoin address, honoring the\ncompression preference specified in the encrypted key.\n9.  Hash the Bitcoin address, and verify that *addresshash* from the\nencrypted private key record matches the hash. If not, report that\nthe passphrase entry was incorrect."
    },
    {
      "header": "Backwards compatibility {#backwards_compatibility}",
      "content": "Backwards compatibility is minimally applicable since this is a new\nstandard that at most extends [Wallet Import\nFormat](Wallet_Import_Format \"wikilink\"). It is assumed that an entry\npoint for private key data may also accept existing formats of private\nkeys (such as hexadecimal and [Wallet Import\nFormat](Wallet_Import_Format \"wikilink\")); this draft uses a key format\nthat cannot be mistaken for any existing one and preserves\nauto-detection capabilities."
    },
    {
      "header": "Suggestions for implementers of proposal with alt-chains {#suggestions_for_implementers_of_proposal_with_alt_chains}",
      "content": "If this proposal is accepted into alt-chains, it is requested that the\nunused flag bytes not be used for denoting that the key belongs to an\nalt-chain.\n\nAlt-chain implementers should exploit the address hash for this purpose.\nSince each operation in this proposal involves hashing a text\nrepresentation of a coin address which (for Bitcoin) includes the\nleading \\'1\\', an alt-chain can easily be denoted simply by using the\nalt-chain\\'s preferred format for representing an address. Alt-chain\nimplementers may also change the prefix such that encrypted addresses do\nnot start with \\\"6P\\\"."
    },
    {
      "header": "Discussion item: scrypt parameters {#discussion_item_scrypt_parameters}",
      "content": "This proposal leaves the scrypt parameters up in the air. The following\nitems are proposed for consideration:\n\nThe main goal of scrypt is to reduce the feasibility of brute force\nattacks. It must be assumed that an attacker will be able to use an\nefficient implementation of scrypt. The parameters should force a highly\nefficient implementation of scrypt to wait a decent amount of time to\nslow attacks.\n\nOn the other hand, an unavoidably likely place where scrypt will be\nimplemented is using slow interpreted languages such as javascript. What\nmight take milliseconds on an efficient scrypt implementation may take\nseconds in javascript.\n\nIt is believed, however, that someone using a javascript implementation\nis probably dealing with codes by hand, one at a time, rather than\ngenerating or processing large batches of codes. Thus, a wait time of\nseveral seconds is acceptable to a user.\n\nA private key redemption process that forces a server to consume several\nseconds of CPU time would discourage implementation by the server owner,\nbecause they would be opening up a denial of service avenue by inviting\nusers to make numerous attempts to invoke the redemption process.\nHowever, it\\'s also feasible for the server owner to implement his\nredemption process in such a way that the decryption is done by the\nuser\\'s browser, offloading the task from his own server (and providing\nanother reason why the chosen scrypt parameters should be tolerant of\njavascript-based decryptors).\n\nThe preliminary values of 16384, 8, and 8 are hoped to offer the\nfollowing properties:\n\n-   Encryption/decryption in javascript requiring several seconds per\noperation\n-   Use of the parallelization parameter provides a modest opportunity\nfor speedups in environments where concurrent threading is\navailable - such environments would be selected for processes that\nmust handle bulk quantities of encryption/decryption operations.\nEstimated time for an operation is in the tens or hundreds of\nmilliseconds."
    },
    {
      "header": "Reference implementation {#reference_implementation}",
      "content": "Added to alpha version of Casascius Bitcoin Address Utility for Windows\navailable at:\n\n-   via https: <https://casascius.com/btcaddress-alpha.zip>\n-   at github: <https://github.com/casascius/Bitcoin-Address-Utility>\n\nClick \\\"Tools\\\" then \\\"PPEC Keygen\\\" (provisional name)"
    },
    {
      "header": "Other implementations {#other_implementations}",
      "content": "-   Javascript - <https://github.com/bitcoinjs/bip38>"
    },
    {
      "header": "Test vectors {#test_vectors}",
      "content": "### No compression, no EC multiply {#no_compression_no_ec_multiply}\n\nTest 1:\n\n-   Passphrase: TestingOneTwoThree\n-   Encrypted:\n6PRVWUbkzzsbcVac2qwfssoUJAN1Xhrg6bNk8J7Nzm5H7kxEbn2Nh2ZoGg\n-   Unencrypted (WIF):\n5KN7MzqK5wt2TP1fQCYyHBtDrXdJuXbUzm4A9rKAteGu3Qi5CVR\n-   Unencrypted (hex):\nCBF4B9F70470856BB4F40F80B87EDB90865997FFEE6DF315AB166D713AF433A5\n\nTest 2:\n\n-   Passphrase: Satoshi\n-   Encrypted:\n6PRNFFkZc2NZ6dJqFfhRoFNMR9Lnyj7dYGrzdgXXVMXcxoKTePPX1dWByq\n-   Unencrypted (WIF):\n5HtasZ6ofTHP6HCwTqTkLDuLQisYPah7aUnSKfC7h4hMUVw2gi5\n-   Unencrypted (hex):\n09C2686880095B1A4C249EE3AC4EEA8A014F11E6F986D0B5025AC1F39AFBD9AE\n\nTest 3:\n\n-   Passphrase \u03d2\u0301\u2400\ud801\udc00\ud83d\udca9 (`\\u03D2\\u0301\\u0000\\U00010400\\U0001F4A9`; [GREEK\nUPSILON WITH HOOK](http://codepoints.net/U+03D2), [COMBINING ACUTE\nACCENT](http://codepoints.net/U+0301),\n[NULL](http://codepoints.net/U+0000), [DESERET CAPITAL LETTER LONG\nI](http://codepoints.net/U+10400), [PILE OF\nPOO](http://codepoints.net/U+1F4A9))\n-   Encrypted key:\n6PRW5o9FLp4gJDDVqJQKJFTpMvdsSGJxMYHtHaQBF3ooa8mwD69bapcDQn\n-   Bitcoin Address: 16ktGzmfrurhbhi6JGqsMWf7TyqK9HNAeF\n-   Unencrypted private key (WIF):\n5Jajm8eQ22H3pGWLEVCXyvND8dQZhiQhoLJNKjYXk9roUFTMSZ4\n-   *Note:* The non-standard UTF-8 characters in this passphrase should\nbe NFC normalized to result in a passphrase of\n`0xcf9300f0909080f09f92a9` before further processing"
    },
    {
      "header": "Compression, no EC multiply {#compression_no_ec_multiply}",
      "content": "Test 1:\n\n-   Passphrase: TestingOneTwoThree\n-   Encrypted:\n6PYNKZ1EAgYgmQfmNVamxyXVWHzK5s6DGhwP4J5o44cvXdoY7sRzhtpUeo\n-   Unencrypted (WIF):\nL44B5gGEpqEDRS9vVPz7QT35jcBG2r3CZwSwQ4fCewXAhAhqGVpP\n-   Unencrypted (hex):\nCBF4B9F70470856BB4F40F80B87EDB90865997FFEE6DF315AB166D713AF433A5\n\nTest 2:\n\n-   Passphrase: Satoshi\n-   Encrypted:\n6PYLtMnXvfG3oJde97zRyLYFZCYizPU5T3LwgdYJz1fRhh16bU7u6PPmY7\n-   Unencrypted (WIF):\nKwYgW8gcxj1JWJXhPSu4Fqwzfhp5Yfi42mdYmMa4XqK7NJxXUSK7\n-   Unencrypted (hex):\n09C2686880095B1A4C249EE3AC4EEA8A014F11E6F986D0B5025AC1F39AFBD9AE"
    },
    {
      "header": "EC multiply, no compression, no lot/sequence numbers {#ec_multiply_no_compression_no_lotsequence_numbers}",
      "content": "Test 1:\n\n-   Passphrase: TestingOneTwoThree\n-   Passphrase code:\npassphrasepxFy57B9v8HtUsszJYKReoNDV6VHjUSGt8EVJmux9n1J3Ltf1gRxyDGXqnf9qm\n-   Encrypted key:\n6PfQu77ygVyJLZjfvMLyhLMQbYnu5uguoJJ4kMCLqWwPEdfpwANVS76gTX\n-   Bitcoin address: 1PE6TQi6HTVNz5DLwB1LcpMBALubfuN2z2\n-   Unencrypted private key (WIF):\n5K4caxezwjGCGfnoPTZ8tMcJBLB7Jvyjv4xxeacadhq8nLisLR2\n-   Unencrypted private key (hex):\nA43A940577F4E97F5C4D39EB14FF083A98187C64EA7C99EF7CE460833959A519\n\nTest 2:\n\n-   Passphrase: Satoshi\n-   Passphrase code:\npassphraseoRDGAXTWzbp72eVbtUDdn1rwpgPUGjNZEc6CGBo8i5EC1FPW8wcnLdq4ThKzAS\n-   Encrypted key:\n6PfLGnQs6VZnrNpmVKfjotbnQuaJK4KZoPFrAjx1JMJUa1Ft8gnf5WxfKd\n-   Bitcoin address: 1CqzrtZC6mXSAhoxtFwVjz8LtwLJjDYU3V\n-   Unencrypted private key (WIF):\n5KJ51SgxWaAYR13zd9ReMhJpwrcX47xTJh2D3fGPG9CM8vkv5sH\n-   Unencrypted private key (hex):\nC2C8036DF268F498099350718C4A3EF3984D2BE84618C2650F5171DCC5EB660A"
    },
    {
      "header": "EC multiply, no compression, lot/sequence numbers {#ec_multiply_no_compression_lotsequence_numbers}",
      "content": "Test 1:\n\n-   Passphrase: MOLON LABE\n-   Passphrase code:\npassphraseaB8feaLQDENqCgr4gKZpmf4VoaT6qdjJNJiv7fsKvjqavcJxvuR1hy25aTu5sX\n-   Encrypted key:\n6PgNBNNzDkKdhkT6uJntUXwwzQV8Rr2tZcbkDcuC9DZRsS6AtHts4Ypo1j\n-   Bitcoin address: 1Jscj8ALrYu2y9TD8NrpvDBugPedmbj4Yh\n-   Unencrypted private key (WIF):\n5JLdxTtcTHcfYcmJsNVy1v2PMDx432JPoYcBTVVRHpPaxUrdtf8\n-   Unencrypted private key (hex):\n44EA95AFBF138356A05EA32110DFD627232D0F2991AD221187BE356F19FA8190\n-   Confirmation code:\ncfrm38V8aXBn7JWA1ESmFMUn6erxeBGZGAxJPY4e36S9QWkzZKtaVqLNMgnifETYw7BPwWC9aPD\n-   Lot/Sequence: 263183/1\n\nTest 2:\n\n-   Passphrase (all letters are Greek - test UTF-8 compatibility with\nthis): \u039c\u039f\u039b\u03a9\u039d \u039b\u0391\u0392\u0395\n-   Passphrase code:\npassphrased3z9rQJHSyBkNBwTRPkUGNVEVrUAcfAXDyRU1V28ie6hNFbqDwbFBvsTK7yWVK\n-   Encrypted private key:\n6PgGWtx25kUg8QWvwuJAgorN6k9FbE25rv5dMRwu5SKMnfpfVe5mar2ngH\n-   Bitcoin address: 1Lurmih3KruL4xDB5FmHof38yawNtP9oGf\n-   Unencrypted private key (WIF):\n5KMKKuUmAkiNbA3DazMQiLfDq47qs8MAEThm4yL8R2PhV1ov33D\n-   Unencrypted private key (hex):\nCA2759AA4ADB0F96C414F36ABEB8DB59342985BE9FA50FAAC228C8E7D90E3006\n-   Confirmation code:\ncfrm38V8G4qq2ywYEFfWLD5Cc6msj9UwsG2Mj4Z6QdGJAFQpdatZLavkgRd1i4iBMdRngDqDs51\n-   Lot/Sequence: 806938/1"
    }
  ]
}