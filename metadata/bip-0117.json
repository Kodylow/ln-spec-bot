{
  "BIP": "117",
  "Layer": "Consensus (soft fork)",
  "Title": "Tail Call Execution Semantics",
  "Author": "Mark Friedenbach <mark@friedenbach.org>",
  "Comments-Summary": "No comments yet.",
  "Comments-URI": "https://github.com/bitcoin/bips/wiki/Comments:BIP-0117",
  "Status": "Draft",
  "Type": "Standards Track",
  "Created": "2017-08-25",
  "License": "CC-BY-SA-4.0",
  "License-Code": "MIT",
  "sections": [
    {
      "header": "Abstract",
      "content": "BIP16 (Pay to Script Hash)\\[1\\] and BIP141 (Segregated Witness)\\[2\\]\nprovide mechanisms by which script policy can be revealed at spend time\nas part of the execution witness. In both cases only a single script can\nbe committed to by the construct. While useful for achieving the goals\nof these proposals, they still require that all policies be specified\nwithin the confine of a single script, regardless of whether the\npolicies are needed at the time of spend.\n\nThis BIP, in conjunction with BIP116 (MERKLEBRANCHVERIFY)\\[3\\] allows\nfor a script to commit to a practically unbounded number of code\npathways, and then reveal the actual code pathway used at spend time.\nThis achieves a form of generalized MAST\\[4\\] enabling decomposition of\ncomplex branching scripts into a set of non-branching flat execution\npathways, committing to the entire set of possible pathways, and then\nrevealing only the path used at spend time."
    },
    {
      "header": "Copyright",
      "content": "This BIP is licensed under a Creative Commons Attribution-ShareAlike\nlicense. All provided source code is licensed under the MIT license."
    },
    {
      "header": "Specification",
      "content": "If, at the end of script execution:\n\n-   the execution state is non-clean, meaning\n1.  the main stack has more than one item on it, or\n2.  the main stack has exactly one item and the alt-stack is not\nempty;\n-   the top-most element of the main stack evaluates as true when\ninterpreted as a bool; and\n-   the top-most element is not a single byte or is outside the\ninclusive range of `0x51` to `0x60`,\n\nthen that top-most element of the main stack is popped and interpreted\nas a serialized script and executed, while the remaining elements of\nboth stacks remain in place as inputs.\n\nIf the above conditions hold except for the last one, such that:\n\n-   the top-most element *is* a single byte within the inclusive range\nof `0x51` (`OP_1`, meaning N=2) to `0x60` (`OP_16`, meaning N=17);\nand\n-   other than this top-most element there are at least N additional\nelements on the main stack and alt stack combined,\n\nthen the top-most element of the main stack is dropped, and the N=2\n(`0x51`) to 17 (`0x60`) further elements are popped from the main stack,\ncontinuing from the alt stack if the main stack is exhausted, and\nconcatenated together in reverse order to form a serialized script,\nwhich is then executed with the remaining elements of both stacks\nremaining in place as inputs.\n\nThe presence of CHECKSIG or CHECKMULTISIG within the subscript do not\ncount towards the global MAX_BLOCK_SIGOPS_COST limit, and the number of\nnon-push opcodes executed in the subscript is not limited by\nMAX_OPS_PER_SCRIPT. Execution state, other than the above exceptions,\ncarries over into the subscript, and termination of the subscript\nterminates execution of the script as a whole. This is known as\nexecution with tail-call semantics.\n\nOnly one such tail-call of a subscript is allowed per script execution\ncontext, and only from within a segwit redeem script. Alternatively\nstated, neither evaluation of witness stack nor execution of the\nscriptPubKey or scriptSig or P2SH redeem script results in tail-call\nsemantics."
    },
    {
      "header": "Motivation",
      "content": "BIP16 (Pay to Script Hash)\\[1\\] and BIP141 (Segregated Witness)\\[2\\]\nallow delayed revelation of a script\\'s policy until the time of spend.\nHowever these approaches are limited in that only a single policy can be\ncommitted to in a given transaction output. It is not possible to commit\nto multiple policies and then choose, at spend time, which to reveal.\n\nBIP116 (MERKLEBRANCHVERIFY)\\[3\\] allows multiple data elements to be\ncommitted to while only revealing those necessary at the time of spend.\nThe MERKLEBRANCHVERIFY opcode is only able to provide commitments to a\npreselected set of data values, and does not by itself allow for\nexecuting code.\n\nThis BIP generalizes the approach of these prior methods by allowing the\nredeem script to perform any type of computation necessary to place the\npolicy script on the stack. The policy script is then executed from the\ntop of the data stack in a way similar to how BIP16 and BIP141 enable\nredeem scripts to be executed from the top of the witness stack. In\nparticular, using MERKLEBRANCHVERIFY\\[3\\] in the scriptPubKey or redeem\nscript allows selection of the policy script that contains only the\nnecessary conditions for validation of the spend. This is a form of\ngeneralized MAST\\[4\\] where a stage of precomputation splits a syntax\ntree into possible execution pathways, which are then enumerated and\nhashed into a Merkle tree of policy scripts. At spend time membership in\nthis tree of the provided policy script is proven before execution\nrecurses into the policy script."
    },
    {
      "header": "Rationale",
      "content": "This proposal is a soft-fork change to bitcoin\\'s consensus rules\nbecause leaving a script that data-wise evaluates as true from its\nserialized form on the stack as execution terminates would result in the\nscript validation returning true anyway. Giving the subscript a chance\nto terminate execution is only further constraining the validation\nrules. The only scripts which would evaluate as false are the empty\nscript, or a script that does nothing more than push empty/zero values\nto the stack. None of these scripts have any real-world utility, so\nexcluding them to achieve soft-fork compatibility doesn\\'t come with any\ndownsides.\n\nBy restricting ourselves to tail-call evaluation instead of a more\ngeneral EVAL opcode we greatly simplify the implementation. Tail-call\nsemantics means that execution never returns to the calling script\\'s\ncontext, and therefore no state needs to be saved or later restored. The\nimplementation is truly as simple as pulling the subscript off the\nstack, resetting a few state variables, and performing a jump back to\nthe beginning of the script interpreter.\n\nThe restriction to allow only one layer of tail-call recursion is\nadmittedly limiting, however the technical challenges to supporting\nmulti-layer tail-call recursion are significant. A new metric would have\nto be developed to track script resource usage, for which transaction\ndata witness size are only two factors. This new weight would have to be\nrelayed with transactions, used as the basis for fee calculation,\nvalidated in-line with transaction execution, and policy decided upon\nfor DoS-banning peers that propagate violating transactions.\n\nHowever should these problems be overcome, dropping the single recursion\nconstraint is itself a soft-fork for the same reason, applied\ninductively. Allowing only one layer of tail-call recursion allows us to\nreceive the primary benefit of multi-policy commitments / generalized\nMAST, while leaving the door open to future generalized tail-call\nrecursion if and when the necessary changes are made to resource\naccounting and p2p transaction distribution.\n\nThe global SIGOP limit and per-script opcode limits do not apply to the\npolicy script because dynamic selection of the policy script makes it\nnot possible for static analysis tools to verify these limits in\ngeneral, and because performance improvements to libsecp256k1 and\nBitcoin Core have made these limits no longer necessary as they once\nwere. The validation costs are still limited by the number of signature\noperations it is possible to encode within block size limits, and the\nmaximum script size per input is limited to 10,000 + 17\\*520 = 18,840\nbytes.\n\nTo allow for this drop of global and per-script limits, tail-call\nevaluation cannot be allowed for direct execution of the scriptPubKey,\nas such scripts are fetched from the UTXO and do not count towards block\nsize limits of the block being validated. Likewise tail-call from P2SH\nredeem scripts is not supported due to quadratic blow-up vulnerabilities\nthat are fixed in segwit."
    },
    {
      "header": "Generalized MAST {#generalized_mast}",
      "content": "When combined with BIP116 (MERKLEBRANCHVERIFY)\\[3\\], tail-call semantics\nallows for generalized MAST capabilities\\[4\\]. The script author starts\nwith a full description of the entire contract they want to validate at\nthe time of spend. The possible execution pathways through the script\nare then enumerated, with conditional branches replaced by a validation\nof the condition and the branch taken. The list of possible execution\npathways is then put into a Merkle tree, with the flattened policy\nscripts as the leaves of this tree. The final redeem script which funds\nare sent to is as follows:\n\n`\u00a0redeemScript:\u00a0<root>\u00a02\u00a0MERKLEBRANCHVERIFY\u00a02DROP\u00a0DROP`\\\n`\u00a0witness:\u00a0<argN>\u00a0...\u00a0<arg1>\u00a0<policyScript>\u00a0<proof>`\n\nWhere `policyScript` is the flattened execution pathway, `proof` is the\nserialized Merkle branch and path that proves the policyScript is drawn\nfrom the set used to construct the Merkle tree `root`, and `arg1`\nthrough `argN` are the arguments required by `policyScript`. The `2`\nindicates that a single leaf (`1 << 1`) follows, and the leaf value is\nnot pre-hashed. The `2DROP DROP` is necessary to remove the arguments to\nMERKLEBRANCHVERIFY from the stack.\n\nThe above example was designed for clarity, but actually violates the\nCLEANSTACK rule of segwit v0 script execution. Unless the CLEANSTACK\nrule is dropped or modified in a new segwit output version, this would\nscript would have to be modified to use the alt-stack, as follows:\n\n`\u00a0redeemScript:\u00a0[TOALTSTACK]*N\u00a0<root>\u00a02\u00a0MERKLEBRANCHVERIFY\u00a02DROP\u00a0DROP`\\\n`\u00a0witness:\u00a0<policyScript>\u00a0<proof>\u00a0<arg1>\u00a0...\u00a0<argN>`\n\nWhere `[TOALTSTACK]*N` is the TOALTSTACK opcode repeated N times. This\nmoves `arg1` through `argN` to the alt-stack in reverse order, such that\n`arg1` is on the top of the alt-stack when execution of `policyScript`\nbegins. The `policyScript` would also have to be modified to fetch its\narguments from the alt-stack, of course.\n\nIf the total set of policy scripts includes scripts that take a varying\nnumber of parameters, that too can be supported, within reasonable\nlimits. The following redeem script allows between 1 and 3 witness\narguments in addition to the policy script and Merkle proof:\n\n`\u00a0witness:\u00a0<policyScript>\u00a0<proof>\u00a0<arg1>\u00a0...\u00a0<argN>\u00a0//\u00a0N\u00a0is\u00a0between\u00a01\u00a0and\u00a03`\\\n`\u00a0redeemScript:\u00a0DEPTH\u00a0TOALTSTACK\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0Save\u00a0number\u00a0of\u00a0witness\u00a0elements\u00a0to\u00a0alt-stack`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0TOALTSTACK\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0Save\u00a01st\u00a0element\u00a0(required)\u00a0to\u00a0alt-stack`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DEPTH\u00a02\u00a0SUB\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0Calculate\u00a0number\u00a0of\u00a0optional\u00a0elements,\u00a0ignoring\u00a0policyScript\u00a0and\u00a0proof`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DUP\u00a0IF\u00a0SWAP\u00a0TOALTSTACK\u00a01SUB\u00a0ENDIF\u00a0\u00a0\u00a0//\u00a0Save\u00a02nd\u00a0element\u00a0(optional)\u00a0to\u00a0alt-stack,\u00a0if\u00a0it\u00a0is\u00a0present`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0IF\u00a0TOALTSTACK\u00a0ENDIF\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0Save\u00a03rd\u00a0element\u00a0(optional)\u00a0to\u00a0alt-stack,\u00a0if\u00a0it\u00a0is\u00a0present;\u00a0consume\u00a0counter`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<root>\u00a02\u00a0MERKLEBRANCHVERIFY\u00a02DROP\u00a0DROP`\\\n`\u00a0alt-stack:\u00a0<N+2>\u00a0<argN>\u00a0...\u00a0<arg1>`\n\nBecause the number of witness elements is pushed onto the alt-stack,\nthis enables policy scripts to verify the number of arguments passed,\neven though the size of the alt-stack is not usually accessible to\nscript. The following policy script for use with the above redeem script\nwill only accept 2 witness elements on the alt-stack, preventing witness\nmalleability:\n\n`\u00a0policyScript:\u00a0``<nowiki>`{=html}`FROMALTSTACK\u00a0...check\u00a0arg1...\u00a0FROMALTSTACK\u00a0...check&consume\u00a0arg2/arg1&2...\u00a0FROMALTSTACK\u00a04\u00a0EQUAL`\n\nThe number 4 is expected as that includes the `policyScript` and\n`proof`.\n\nThe verbosity of this example can be prevented by using a uniform number\nof witness elements as parameters for all policy subscripts, eliminating\nthe conditionals and stack size counts. Future script version upgrades\nshould also consider relaxing CLEANSTACK rules to allow direct\npass-through of arguments from the witness/redeem script to the policy\nscript on the main stack."
    },
    {
      "header": "Comparison with BIP114 {#comparison_with_bip114}",
      "content": "BIP114 (Merkelized Abstract Syntax Tree)\\[5\\] specifies an explicit MAST\nscheme activated by BIP141 script versioning\\[2\\]. Unlike BIP114, the\nscheme proposed by this BIP in conjunction with BIP116\n(MERKLEBRANCHVERIFY)\\[3\\] implicitly enables MAST constructs using\nscript itself to validate membership of the policy script in the MAST.\nThis has the advantage of requiring vastly fewer consensus code changes,\nas well as potentially enabling future script-based innovation without\nrequiring any further consensus code changes at all, as the MAST scheme\nitself is programmable.\n\nFurthermore, by adding MERKLEBRANCHVERIFY and tail-call semantics to all\nscript using the NOP-expansion space, BIP141 style script versioning is\nnot required. This removes a potentially significant hurdle to\ndeployment by making this feature not dependent on resolving outstanding\nissues over address formats, how script version upgrades should be\ndeployed, and consensus over what other features might go into a v1\nupgrade."
    },
    {
      "header": "Implementation",
      "content": "An implementation of this BIP, including both consensus code changes and\ntests are available at the following Github repository:\n\n[1](https://github.com/maaku/bitcoin/tree/tail-call-semantics)"
    },
    {
      "header": "Deployment",
      "content": "This BIP will be deployed by BIP8 (Version bits with lock-in by\nheight)\\[9\\] with the name \\\"tailcall\\\" and using bit 3.\n\nFor Bitcoin mainnet, the BIP8 startheight will be at height M to be\ndetermined and BIP8 timeout activation will occur on height M + 50,400\nblocks.\n\nFor Bitcoin testnet, the BIP8 startheight will be at height T to be\ndetermined and BIP8 timeout activation will occur on height T + 50,400\nblocks.\n\nWe note that CLEANSTACK means that transactions which use this feature\nare already considered non-standard by the rules of the network, making\ndeployment easier than was the case with, for example, with BIP68\n(Relative lock-time using consensus-enforced sequence numbers)\\[6\\]."
    },
    {
      "header": "Compatibility",
      "content": "The v0 segwit rules prohibit leaving anything on the stack, so for v0\nparameters have to be passed on the alt stack for compatibility reasons."
    },
    {
      "header": "References",
      "content": "\\[1\\] [BIP16: Pay to Script\nHash](https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki)\n\n\\[2\\] [BIP141: Segregated Witness (Consensus\nLayer)](https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki)\n\n\\[3\\] [BIP116:\nMERKLEBRANCHVERIFY](https://github.com/bitcoin/bips/blob/master/bip-0116.mediawiki)\n\n\\[4\\] \\\"[An explanation and justification of the tail-call and MBV\napproach to\nMAST](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-September/015028.html)\\\",\nMark Friedenbach, Bitcoin Development Mailing List, 20 September 2017.\n\n\\[5\\] [BIP114: Merkelized Abstract Syntax\nTree](https://github.com/bitcoin/bips/blob/master/bip-0114.mediawiki)\n\n\\[6\\] [BIP68: Relative lock-time using consensus-enforced sequence\nnumbers](https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki)"
    }
  ]
}