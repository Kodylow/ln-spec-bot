{
  "BIP": "154",
  "Layer": "Peer Services",
  "Title": "Rate Limiting via peer specified challenges",
  "Author": "Karl-Johan Alm <karljohan-alm@garage.co.jp>",
  "Comments-Summary": "No comments yet.",
  "Comments-URI": "https://github.com/bitcoin/bips/wiki/Comments:BIP-0154",
  "Status": "Withdrawn",
  "Type": "Standards Track",
  "Created": "2017-04-12",
  "License": "BSD-2-Clause",
  "sections": [
    {
      "header": "Abstract",
      "content": "An anti-DoS system which provides additional service for peers which\nperform proof of work."
    },
    {
      "header": "Definitions",
      "content": "-   **POW** : a proof of work using some arbitrary algorithm, such as\nSHA256\n-   **challenge** : a problem in the form of a POW specification and\nother data\n-   **solution** : a set of inputs which solve a given challenge\n-   **free connection slot** : an inbound connection slot that does not\nrequire POW\n-   **POW connection slot** : an inbound connection slot that requires\nPOW\n-   **SPH** : Special Purpose Hardware, such as an ASIC chip\n-   **GPH** : General Purpose Hardware, such as a desktop computer\n-   **Work** : A measurement of optimized average resources (clock\ncycles, memory, \\...) required to perform a single attempt at\nsolving a given POW algorithm on GPH"
    },
    {
      "header": "Motivation",
      "content": "The Bitcoin network has a maximum number of inbound and outbound\nconnections (125). It is trivial and relatively cheap to flood the\nnetwork with connections via dummy nodes. Such an attack would result in\n(1) nodes evicting some other nodes in order to facilitate the new\nconnection, and (2) nodes\\' ability to connect to each other being\nseverely hampered. In this state, the network is vulnerable to e.g. a\nSybil attack.\n\nWhile the network is under pressure as in the above case, nodes could\nallow incoming connections anyway by requiring that the incoming peer\nperforms some form of proof of work, to prove that they are not simply\nspamming the network. This would severely ramp up the costs of a Sybil\nattack, as the attacker would now have to perform proof of work for each\nnode, beyond the free slots.\n\nHowever, using the \\\"standard\\\" double-SHA256 POW algorithm in use by\nBitcoin nodes to generate blocks means attackers can use special-purpose\nhardware to greatly accelerate the POW solving process. To counter this,\nthe proof weight would have to be raised, but this would mean standard\nnodes would need to solve unacceptably costly challenges for simple\noperation. Therefore, a different proof of work which is arguably less\nsensitive to special-purpose hardware implementations is introduced. As\nthis is not consensus sensitive, additional POW algorithms may be added\nin the future."
    },
    {
      "header": "Specification",
      "content": "A peer that supports Proof of Work Rate Limiting defines two maximums:\n\n-   max connections, from which the maximum inbound connections is\ncalculated as `nMaxConnections - (nMaxOutbound + nMaxFeeler)`\n-   POW connection slots, which define how many of the above inbound\nconnections require a POW challenge\n\nThe peer must interpret two new network peer message types, `challenge`\nand `solution`.\n\nIn addition, the network handshake sequence must be altered slightly to\nfacilitate the exchange of challenges and/or solutions:\n\n-   when a node connects, it may send a `solution` message prior to the\n`version`\n-   if it does, and\n-   the solution satisfies the local node, it is given a connection,\nbut if\n-   the solution does not satisfy the local node (unknown, wrong,\n\\...), a new `challenge` is sent and the connection is closed\n-   if it does not, and it is marked as needing to do POW, a `challenge`\nis sent and the connection is closed\n\nThis means nodes will be disconnected after receiving the challenge. It\nis then up to the individual nodes whether they solve the challenge and\nreconnect, or discard it and find a different peer (or wait for the peer\nto have an open free slot)."
    },
    {
      "header": "POW Identifiers {#pow_identifiers}",
      "content": "There are two POW identifiers currently. When a new identifier is\nintroduced, it should be added with an increment of 1 to the last\nidentifier in the list. When an identifier is deprecated, its status\nshould be changed to `Deprecated` but it should retain its place in the\nlist indefinitely.\n\nID   Algorithm Name   Work                             Param size   Solution size     Provably Secure   SPH Resistance   Status\n---- ---------------- -------------------------------- ------------ ----------------- ----------------- ---------------- --------\n1    sha256           11k cycles                       11+ bytes    0, 4 or 8 bytes   Yes               Low              Active\n2    cuckoo-cycle     ss 28: 150G cycles / \\~48M RAM   6+ bytes     168 bytes         No                High             Active"
    },
    {
      "header": "sha256",
      "content": "Properties:\n\nProperty               Value\n---------------------- --------------------------------\nSolution probability   `sum((1/2)^i*(1-targetBE[i]))`\n\nChallenge format:\n\nRange   Field Name       Data Type    Description\n------- ---------------- ------------ --------------------------------------------------------------------------\n0       config_length    varint       Length of configuration part; always 9\n1..4    target           uint32       Difficulty target, in the form of a compact size (like nBits in blocks).\n5       nonce_size       uint8        Size of nonce in bytes; must be 0 (no nonce), 4 (uint32) or 8 (uint64)\n6..9    nonce_offset     uint32       Location of nonce value in target\n10..    payload_length   varint       Length of the input data\n..      payload          byte array   Input data\n\nSolution format:\n\nRange   Field Name   Data Type            Description\n------- ------------ -------------------- --------------------------------------------------------------------------------------------------------------------------------------------\n0..     nonce        uint32/64, or data   Nonce value that satisfies challenge; for zero-byte nonces, this is variable data that is appended to the challenge payload before hashing\n\nNote: SHA256 works in two \\\"modes\\\".\n\n1.  One is where the task is to insert a nonce into an existing data\nblock so that the hash of the data block matches a given target;\nthis is the conventional block proof of work behavior.\n2.  The other is where the whole or parts of the data chunk are given as\ninput (a \\\"big nonce\\\"). In this case, the internal nonce size is\nzero bytes, and the task is simply to check whether the hash of the\ndata matches the target. If it does not, there is no way to find a\nsolution except by getting different input from the generator (a\nsuccessor algorithm). This mode is used when SHA256 is a predecessor\nto another algorithm.\n\nAdditional notes:\n\n-   The initial nonce value (when present) for finding a suitable digest\nshould be randomized, or a challenger may deliberately pick a\nchallenge with \\\"poor\\\" outcomes to fool a node into spending more\nthan predicted time solving."
    },
    {
      "header": "cuckoo-cycle {#cuckoo_cycle}",
      "content": "Properties:\n\nProperty               Value\n---------------------- ----------------------------------------------------\nSolution probability   `~1.0` for sizeshift=28, proofsize-min:-max=12:228\n\nChallenge format:\n\nRange   Field Name       Data Type    Description\n------- ---------------- ------------ ---------------------------------------------------------------------------------------------------------------------------------------------\n0       config_length    varint       Length of configuration part; always 5\n1       sizeshift        uint8        Size shift; must be equal to 28, but may be variable in the future\n2..3    proofsize-min    uint16       Minimum number of edges in cycle; must be even and greater than or equal to 12 (recommended: 12)\n4..5    proofsize-max    uint16       Maximum number of edges in cycle; must be even, greater than or equal to proofsize-min, and smaller than or equal to 254 (recommended: 228)\n6       payload_length   varint       Length of the input data; must be 76, but may be variable in the future\n7..     payload          byte array   Input data\n\nSolution format:\n\nRange    Field Name   Data Type      Description\n-------- ------------ -------------- ---------------------------------------------------------------------\n0..3     nonce        uint32         Nonce which is appended to challenge payload to form solution graph\n4..171   edges        uint32 array   42 values which identify each of the 42 edges in the cycle\n\nAdditional notes:\n\n-   The initial nonce value used for finding a graph with a suitable\nsolution should be randomized, or a challenger may deliberately pick\na challenge with \\\"poor\\\" outcomes to fool a node into spending more\nthan predicted time solving.\n-   Further information on the recommended challenge parameters can be\nfound here: <http://bc-2.jp/cuckoo-profile.pdf>"
    },
    {
      "header": "Purpose Identifiers {#purpose_identifiers}",
      "content": "There is only one Purpose Identifier currently. In the future, more\nPurpose Identifiers could be added for at-DoS-risk operations, such as\nbloom filters. When a new identifier is introduced, it should be added\nwith an increment of 1 to the last identifier in the list. When an\nidentifier is deprecated, its status should be changed to `Deprecated`\nbut it should retain its place in the list indefinitely.\n\nID   Purpose Name   Description                         Status\n---- -------------- ----------------------------------- --------\n1    connect        Establish peer to peer connection   Active"
    },
    {
      "header": "Challenges",
      "content": "Challenges consist of one or several chained POW identifiers with\naccompanying parameters, as well as indicators for the purpose of the\nchallenge, and a signature that lets the node verify the challenge\nauthenticity.\n\nAfter creating a challenge, the node signs it, delivers it to the peer,\nthen discards it. When a node provides a solution to a challenge, the\nnode verifies the signature and adds the challenge hash to a list of\nsolved challenges along with its expiration time. This list is pruned on\neach insertion, removing any expired challenges.\n\nIf nodes needed to keep track of unsolved challenges, an attacker could\nhypothetically swarm a node, causing a DoS by having it generate so many\nchallenges that it runs out of memory and crashes. By signing and\ndiscarding challenges, a node only has to retain challenges that were\nsolved, and which have not yet expired, effectively DoS- protecting the\nnode via the challenges themselves."
    },
    {
      "header": "The `challenge` message type {#the_challenge_message_type}",
      "content": "A challenge consists of four parts: the POW specification, a purpose\nidentifier, an expiration date, and a signature. The POW specification\ncontains a list of tuples containing a POW identifier and corresponding\nPOW parameters.\n\n-   Each POW identifier specifies a POW algorithm (see POW Identifiers)\n-   The POW parameters define the inputs and requirements of the POW\nalgorithm\n-   The purpose identifier specifies the purpose of the challenge (see\nPurpose Identifiers)\n-   The expiration date is a UNIX timestamp indicating when the\nchallenge expires\n-   The signed content should contain a signature of the hash\n`SHA256(SHA256(pow-count || pow-id || pow-params || ... || purpose-id || expiration))`,\ni.e. the hash of the entire challenge except for the signature\nlength and data.\n\nField Size   Description   Data type    Description\n------------ ------------- ------------ ---------------------------------------------------\n1 byte       pow-count     uint8        Number of POW algorithms in the range \\[1..255\\]\n4 bytes      pow-id        uint32       The POW algorithm to solve the problem with\n?            pow-params    ?            The POW parameters and payload\n\\...         \\...          \\...         pow-id and pow-params for algorithms 2 and beyond\n4 bytes      purpose-id    uint32       The purpose of the challenge\n8 bytes      expiration    int64        Expiration UNIX timestamp\n?            sign-len      varint       The length of the signature\n?            sign          byte array   The signature data\n\nFor POW specifications with a pow-count \\> 1, the output of the\nsucceeding POW algorithm will be appended to the input of the\npredecessor for all POW algorithms except the last one. Normally\nmid-layer (all but the last) POW algorithms have a zero-length input.\nExample implementing sha256(cuckoo-cycle):\n\nRange      Field Name                    Value           Comment\n---------- ----------------------------- --------------- ----------------------------------------------------------\n0          pow-count                     2               Two POW algorithms\n1..4       pow-id                        1               sha256\n5          pow-params (config_length)    9               \n6..9       pow-params (target)           0x207fffff      Resulting hash must be \\<= the compact hash 0x207fffff\\*\n10         pow-params (nonce_size)       0               No nonce\n11..14     pow-params (nonce_offset)     0               \\--\n15..18     pow-params (payload_length)   0               0 byte input (turns into 32 byte input from successor)\n19..22     pow-id                        2               cuckoo-cycle\n23         pow-params (config_length)    8               \n24         pow-params (sizeshift)        28              \n25..26     pow-params (proofsize-min)    12              \n27..28     pow-params (proofsize-max)    228             \n29         pow-params (payload_length)   76              76 byte input\n30..105    pow-params                    (random data)   A randomized challenge of 76 bytes\n106..109   purpose-id                    1               Purpose is a peer-to-peer connection\n110..117   expiration                    1491285696      Expiration is April 4 2017, 15:01:36 (JST)\n118        sign-len                      71              71 byte signature\n119..189   sign                          (signature)     Signature of above challenge\n\n(\\* Compact 0x207fffff =\n0x7fffff0000000000000000000000000000000000000000000000000000000000.)\n\nThe above should be interpreted as SHA256(cuckoo-cycle(random data \\|\\|\nnonce)) \\<\n0x7fffff0000000000000000000000000000000000000000000000000000000000.\n\n-   Run cuckoo-cycle on random data \\|\\| nonce; increment nonce until\nsolution is found, then\n-   Run SHA256 on 32 byte digest from above; if less than\n0x7fffff0000000000000000000000000000000000000000000000000000000000,\n-   Mark solved.\n-   Otherwise loop back and increase nonce and continue finding\nsolutions"
    },
    {
      "header": "The `solution` message type {#the_solution_message_type}",
      "content": "A solution consists of two parts: the entire challenge, and solution\nparameters:\n\n-   The challenge must match the given challenge up to and including the\nsignature bytes\n-   The solution parameters must form a valid solution to each POW step\nin the challenge\n\nField Size   Description   Data type    Description\n------------ ------------- ------------ -----------------------------------------------------\n1 byte       pow-count     uint8        Number of POW algorithms in the range \\[1..255\\]\n4 bytes      pow-id        uint32       The POW algorithm used to solve the problem\n?            pow-params    ?            The input to the POW solver for the above algorithm\n\\...         \\...          \\...         pow-id and pow-params for algorithms 2 and beyond\n4 bytes      purpose-id    uint32       The purpose of the challenge\n8 bytes      expiration    int64        Expiration UNIX timestamp\n?            sign-len      varint       The length of the signature\n?            sign          byte array   The signature data\n?            solution      ?            The solution to the challenge\n\nNote that the solution contains the parameters for the last algorithm\nonly. For each algorithm except the last one, the input is derived from\nthe output of the successor. Example solution:\n\nRange   Name      Value     Description\n------- --------- --------- -----------------------------------------------------\n0       length    4         The input to the innermost POW is 4 bytes in length\n1..4    nonce32   0x12345   The nonce used as input is 0x12345\n\nThe above example will provide a single nonce for the inner POW. For the\nSHA256(SHA256(challenge data \\|\\| nonce32)) case, the solution would\nclaim that SHA256(SHA256(challenge data \\|\\| 0x00012345)) solves the\nchallenge."
    },
    {
      "header": "Signing and Verifying Challenges {#signing_and_verifying_challenges}",
      "content": "Below is a suggestion for how to sign a challenge. The implementation\ngenerates a new, random key-pair at launch and uses that to sign all\nchallenges until the node is shutdown."
    },
    {
      "header": "Signing a Challenge {#signing_a_challenge}",
      "content": "1.  (first time) Create a new random key-pair `key` and `pubkey` and\nkeep these around until shutdown\n2.  (second+ time) Fetch `key` created above\n3.  Create a double-SHA256 `sighash` of the challenge in serialized form\nup until and including the expiration bytes\n4.  Create a signature `sign` of `sighash` using `key`\n5.  Append `varint(len(sign))` and `sign` to challenge"
    },
    {
      "header": "Verifying a Challenge {#verifying_a_challenge}",
      "content": "1.  Fetch `pubkey` and declare failure if not defined (that means we\nnever issued a challenge)\n2.  Create a double-SHA256 `sighash` of the challenge provided with the\nsolution up until and including the expiration bytes\n3.  Verify `sighash` is not known, and add it to known hashes along with\nits expiration date for pruning purposes\n4.  Set `sign` to the signature included in the challenge\n5.  Verify the signature `sign` using `pubkey` and `sighash`\n6.  Check that the solution solves the challenge\n\nNote that a list of known hashes should be kept and pruned of expired\nchallenges on verification. Otherwise nodes may reuse the same solution\nrepeatedly up until its expiration."
    },
    {
      "header": "Difficulty and Cost {#difficulty_and_cost}",
      "content": "### Estimating Challenge Cost {#estimating_challenge_cost}\n\nNodes need to be able to make a judgement call on whether solving a\ngiven challenge is worth their efforts. If a challenge is expected to\ntake so much time that it would expire before being solved (on average),\nit should be immediately discarded. Beyond this, a threshold should be\nestablished for nodes based on their \\\"value\\\" to the node, which is\ninversely proportional to the current number of connections as a\nfunction of uptime, with arbitrary modifiers (a whitelisted node or a\nnode added via -addnode has a much higher threshold).\n\nIt is hard to obtain an accurate value for `cycles_per_second`, and as\nsuch a fixed value of 1700000000=1.7e9 may be used.\n\nGiven a threshold `t`, calculate the estimated work required to solve\nthe challenge as follows:\n\n1.  Define `p(alg)` as the probability that an attempt at finding a\nsolution given the algorithm `alg` succeeds\n2.  Define `w(alg)` as the work parameter of the algorithm `alg`.\n3.  Let `Wc \u2190 0, Wm \u2190 1, Wi \u2190 1`\n4.  For each proof of work `pow` in the POW specification:\n1.  Let `p \u2190 p(pow)`, `w \u2190 w(pow)`\n2.  Update `Wc \u2190 Wc + w_cycles`, `Wi \u2190 Wi * 1/p`, `Wm \u2190 Wm + w_ram`\n5.  Let `eta \u2190 (Wc * Wi) / cycles_per_second`\n6.  If `date() + eta >= expiration`, discard challenge\n7.  If `eta > t`, discard challenge\n\nExample:\n`SHA256(cuckoo-cycle(...)) < 0x7fffff0000000000000000000000000000000000000000000000000000000000`\n\n1.  `p(cuckoo-cycle) = 1`, `p(sha256, 0x7fffff000...) ~= (1/2)^1 = 1/2`\n2.  `w(cuckoo-cycle) = (1.5e11 cycles, 5e7 ram)`,\n`w(sha256, 0x7fffff000...) = (11e3 cycles)`\n3.  `Wc = 0, Wm = 1, Wi = 1`\n1.  `p = p(cuckoo-cycle) = 1, w = w(cuckoo-cycle) = (1.5e11 cycles, 5e7 ram)`\n2.  `Wc = 0 + 1.5e11 = 1.5e11`, `Wi = 1 * 1 = 1`,\n`Wm = 1 + 5e7 = 5e7`\n3.  `p = p(sha256) = 1/2, w = w(sha256) = (11e3 cycles)`\n4.  `Wc = 1.5e11 + 11e3 ~= 1.5e11, Wi = 1 * 2 = 2, Wm = 5e7 + 0 = 5e7`\n4.  `eta = (1.5e11 * 2) / cycles_per_second` = `7.5e10 / 1.7e9` = 44.1\nseconds`</code>`{=html}\n\nTODO: Determine how memory impacts threshold.\n\nTo avoid other nodes dropping our challenges due to early expiration, we\nuse a fairly generous expiration based on the pressure value\n\nexpiration = date() + 600 * (1 + pressure)\n\nwhich means the expiration is 10 minutes for the weakest challenge, and\ngradually rises to 20 minutes for the hardest one."
    },
    {
      "header": "Establishing Difficulty Parameters {#establishing_difficulty_parameters}",
      "content": "The difficulty setting for the network should change based on connection\nslot availability. The amount of pressure on the network in the sense of\nconnection slot availability is proportional to the number of\nestablished connections over the number of total available connections.\nThis can be locally approximated by a node to the number of local\nconnections compared to the local connection maximum.\n\nIn other words, the network pressure can be approximated by any node as\n`connections / max` and the difficulty can be based on e.g.\n`(connections - free) / pow_slots`.\n\nThe challenge difficulty parameters can be set based on this, where 0.0\nmeans \\\"low pressure\\\" and 1.0 means \\\"maximum pressure\\\". The\n`GetPressure` method below gives 0.0 at 67 connections (for a 50 POW\nslot set up), and hits the 1.0 mark at\n`(nMaxConnections - nMaxOutbound - nMaxFeeler)`, incrementing by 0.02\nfor each new connection:\n\nint nMaxInbound = nMaxConnections - (nMaxOutbound + nMaxFeeler + nPOWConnectionSlots);\nreturn ((double)GetNodeCount(CONNECTIONS_ALL) - nMaxInbound) / nPOWConnectionSlots;\n\nAn example of difficulty for a SHA256(Cuckoo-Cycle) specification would\nbe based on a desired probability of a random SHA256 digest matching a\ngiven target:\n\nprob_target = 1 / (1 + pressure^2 * 15)\n\nThis would result in probability targets according to the table below,\nfor varying pressures (where the pressure is in the range \\[0..1\\]):\n\npressure   prob_target   solution time sha256(cc)\n---------- ------------- --------------------------\n0.0        1.00          00:45\n0.1        0.87          00:51\n0.2        0.63          01:11\n0.3        0.43          01:45\n0.4        0.29          02:32\n0.5        0.21          03:32\n0.6        0.16          04:46\n0.7        0.12          06:13\n0.8        0.09          07:54\n0.9        0.08          09:48\n1.0        0.06          11:55"
    },
    {
      "header": "Cuckoo Cycle {#cuckoo_cycle_1}",
      "content": "Cuckoo Cycle\\[1\\] is a \\\"graph-theoretic proof-of-work system, based on\nfinding small cycles or other structures in large random graphs.\\\"\n\nIt is memory hard, which greatly increases the complexity and cost of\nproducing dedicated (special purpose) hardware, an ideal property for an\nanti-DoS system.\n\nThe implementation specifics of the algorithm are beyond the scope of\nthis BIP, but the github repository\\[2\\] has several reference\nimplementations in various languages."
    },
    {
      "header": "Compatibility",
      "content": "This proposal is backward compatible. Non-supporting peers will ignore\nthe `challenge` message and be disconnected, as if they hit the peer\nconnection limit as normal."
    },
    {
      "header": "Reference implementation {#reference_implementation}",
      "content": "<https://github.com/kallewoof/bitcoin/pull/2>\n(https://github.com/kallewoof/bitcoin/tree/pow-connection-slots)"
    },
    {
      "header": "References",
      "content": "-   \\[1\\] Cuckoo Cycle\n<https://github.com/tromp/cuckoo/blob/master/doc/cuckoo.pdf?raw=true>\n-   \\[2\\] Cuckoo Cycle github <https://github.com/tromp/cuckoo>"
    },
    {
      "header": "Test vectors {#test_vectors}",
      "content": "### Cuckoo-Cycle {#cuckoo_cycle_2}\n\nCuckoo Cycle header (76 bytes):\n\n00..1f   68a639cb 3deab5b6 23054d60 e7856037 8afa0f31 4f08dec1 6cc4ec4f d9bef1ff\n20..3f   468af883 c6c9c3d5 4260087a 046d12a0 7cc3988f 9ff2957a 384de8ed db75b037\n40..4b   798d1073 214b7ea6 954f1b3a\n\nExample solution nonce: 0 (`00000000`)\n\nSolution edges (16 number of 32-bit unsigned integers, read horizontally\nfrom top left):\n\n550b1100 0fc89a00 45034401 ddfce701 08da0e02 6ccc5703 06fe8404 1d3f8504\n559e3e05 d41a9905 17075206 97cfa006 59e50d07 7bd71f07 13fe2607 14493007"
    },
    {
      "header": "SHA256(Cuckoo-Cycle) {#sha256cuckoo_cycle}",
      "content": "SHA256 target: `0x205fffff`\n\nCuckoo Cycle header (76 bytes, same as above):\n\n00..1f   68a639cb 3deab5b6 23054d60 e7856037 8afa0f31 4f08dec1 6cc4ec4f d9bef1ff\n20..3f   468af883 c6c9c3d5 4260087a 046d12a0 7cc3988f 9ff2957a 384de8ed db75b037\n40..4b   798d1073 214b7ea6 954f1b3a\n\nExample solution nonce: 0 (`00000000`)\n\nSHA256 input (cuckoo-cycle nonce + solution):\n\n00000000\n550b1100 0fc89a00 45034401 ddfce701 08da0e02 6ccc5703 06fe8404 1d3f8504\n559e3e05 d41a9905 17075206 97cfa006 59e50d07 7bd71f07 13fe2607 14493007\n\nSHA256 hash:\n`262c8558c7c589b19b3d513abf5fcb15162745473e603f0146889ceff750bcc3`\n\nMust be less than:\n`5fffff0000000000000000000000000000000000000000000000000000000000`"
    },
    {
      "header": "Serialized challenge example {#serialized_challenge_example}",
      "content": "020100000009ffff5f2000000000000002000000051c0c00e4004c68a639cb3deab5b623054d60e7\n8560378afa0f314f08dec16cc4ec4fd9bef1ff468af883c6c9c3d54260087a046d12a07cc3988f9f\nf2957a384de8eddb75b037798d1073214b7ea6954f1b3a01000000a49d0659000000004730450221\n0095fc5fafe2032097c4d12a8901401cda297aad614e16f23ec42d4b78955856c002206ab7ada4ac\n8f6fa9d5bd7cd06f9ba89587a28e14cea14e7f8f8d5ab851541791\n\nHex                                    Description\n-------------------------------------- -------------------------------------\n`0x02`                                 Two proofs of work\n`0x01000000`                           Proof of work ID = 1 (SHA256)\n`0x09`                                 Config is 9 bytes\n`0xffff5f20`                           SHA256: Compact target = 0x205fffff\n`0x00`                                 SHA256: Nonce size is 0 bytes\n`0x00000000`                           SHA256: Nonce offset is 0\n`0x00`                                 Payload is 0 bytes\n`0x02000000`                           Proof of work ID = 2 (cuckoo-cycle)\n`0x05`                                 Config is 5 bytes\n`0x1c`                                 Size shift is 28\n`0x0c00`                               Proof size min is 12\n`0xe400`                               Proof size max is 228\n`0x4c`                                 Payload is 76 bytes\n`0x68a639cb3deab5b623054d60e7856037`   Payload\n`0x8afa0f314f08dec16cc4ec4fd9bef1ff`   \n`0x468af883c6c9c3d54260087a046d12a0`   \n`0x7cc3988f9ff2957a384de8eddb75b037`   \n`0x798d1073214b7ea6954f1b3a`           \n`0x01000000`                           Purpose ID = 1 (PURPOSE_CONNECT)\n`0xa49d065900000000`                   UNIX timestamp 1493605796\n`0x47`                                 71 byte signature\n`0x304502210095fc5fafe2032097c4d12a`   Signature data\n`0x8901401cda297aad614e16f23ec42d4b`   \n`0x78955856c002206ab7ada4ac8f6fa9d5`   \n`0xbd7cd06f9ba89587a28e14cea14e7f8f`   \n`0x8d5ab851541791`"
    },
    {
      "header": "Serialized solution example {#serialized_solution_example}",
      "content": "020100000009ffff5f2000000000000002000000051c0c00e4004c68a639cb3deab5b623054d60e7\n8560378afa0f314f08dec16cc4ec4fd9bef1ff468af883c6c9c3d54260087a046d12a07cc3988f9f\nf2957a384de8eddb75b037798d1073214b7ea6954f1b3a01000000a49d0659000000004730450221\n0095fc5fafe2032097c4d12a8901401cda297aad614e16f23ec42d4b78955856c002206ab7ada4ac\n8f6fa9d5bd7cd06f9ba89587a28e14cea14e7f8f8d5ab8515417914400000000550b11000fc89a00\n45034401ddfce70108da0e026ccc570306fe84041d3f8504559e3e05d41a99051707520697cfa006\n59e50d077bd71f0713fe260714493007\n\nNote that the first 187 bytes are identical to the challenge above.\n\nHex                                    Description\n-------------------------------------- -----------------------------\n`0x0201..1791`                         Challenge\n`0x44`                                 Solution is 68 bytes long\n`0x00000000`                           The cuckoo cycle nonce is 0\n`0x550b11000fc89a0045034401ddfce701`   Cycle edges 0..3\n`0x08da0e026ccc570306fe84041d3f8504`   Cycle edges 4..7\n`0x559e3e05d41a99051707520697cfa006`   Cycle edges 8..11\n`0x59e50d077bd71f0713fe260714493007`   Cycle edges 12..15"
    },
    {
      "header": "Cuckoo-Cycle Example 2 {#cuckoo_cycle_example_2}",
      "content": "Cuckoo Cycle header (76 bytes):\n\n00..1f   3c1e3ee5 c799b7e9 92bcccbb 8985979d cb8dd229 b8d0db06 e677d00b b3a43c88\n20..3f   ef8596a7 7cbd1dda 23b0a0b8 4bdf6084 d7aa28dd bd5e91b5 11b3578c baf92707\n40..4b   c940b051 a0759b3f 80c5fb65\n\nExample solution nonce: 4 (`04000000`)\n\nSolution edges (22 number of 32-bit unsigned integers, read horizontally\nfrom top left):\n\n5a013700 7074ce00 e3dbeb00 e88f7901 06d71d02 984d3d02 091b5002 378a8e02\n90a6d202 b3c67003 757cb703 44d9cf03 297f2004 8e76a604 67e44a05 7b077405\n634f8405 23e88c05 0d887606 109d3e07 c4bdcd07 3db2d407"
    },
    {
      "header": "SHA256(Cuckoo-Cycle) {#sha256cuckoo_cycle_1}",
      "content": "SHA256 target: `0x2021642c`\n\nCuckoo Cycle header (76 bytes, same as above):\n\n00..1f   3c1e3ee5 c799b7e9 92bcccbb 8985979d cb8dd229 b8d0db06 e677d00b b3a43c88\n20..3f   ef8596a7 7cbd1dda 23b0a0b8 4bdf6084 d7aa28dd bd5e91b5 11b3578c baf92707\n40..4b   c940b051 a0759b3f 80c5fb65\n\nExample solution nonce: 4 (`04000000`)\n\nSHA256 input (cuckoo-cycle nonce + solution):\n\n04000000\n5a013700 7074ce00 e3dbeb00 e88f7901 06d71d02 984d3d02 091b5002 378a8e02\n90a6d202 b3c67003 757cb703 44d9cf03 297f2004 8e76a604 67e44a05 7b077405\n634f8405 23e88c05 0d887606 109d3e07 c4bdcd07 3db2d407\n\nSHA256 hash:\n`08210561257e26776135ec1cb92cfe17f46803613c0bdc02043e5545b18556ce`\n\nMust be less than:\n`21642c0000000000000000000000000000000000000000000000000000000000`"
    },
    {
      "header": "Serialized challenge example {#serialized_challenge_example_1}",
      "content": "0201000000092c64212000000000000002000000051c0c00e4004c3c1e3ee5c799b7e992bcccbb89\n85979dcb8dd229b8d0db06e677d00bb3a43c88ef8596a77cbd1dda23b0a0b84bdf6084d7aa28ddbd\n5e91b511b3578cbaf92707c940b051a0759b3f80c5fb650100000024aa0659000000004630440220\n0edfb5c4812a31d84cbbd4b24e631795435a0d16b57d37ef773735b8a87caa8a0220631d0b78b7f1\nd29c9e54a76f3457ff1a2ee19490ff027c528a896f4bf6aff577\n\nHex                                    Description\n-------------------------------------- -------------------------------------\n`0x02`                                 Two proofs of work\n`0x01000000`                           Proof of work ID = 1 (SHA256)\n`0x09`                                 Config is 9 bytes\n`0x2c642120`                           SHA256: Compact target = 0x2021642c\n`0x00`                                 SHA256: Nonce size is 0 bytes\n`0x00000000`                           SHA256: Nonce offset is 0\n`0x00`                                 Payload is 0 bytes\n`0x02000000`                           Proof of work ID = 2 (cuckoo-cycle)\n`0x05`                                 Config is 5 bytes\n`0x1c`                                 Size shift is 28\n`0x0c00`                               Proof size min is 12\n`0xe400`                               Proof size max is 228\n`0x4c`                                 Payload is 76 bytes\n`0x3c1e3ee5c799b7e992bcccbb8985979d`   Payload\n`0xcb8dd229b8d0db06e677d00bb3a43c88`   \n`0xef8596a77cbd1dda23b0a0b84bdf6084`   \n`0xd7aa28ddbd5e91b511b3578cbaf92707`   \n`0xc940b051a0759b3f80c5fb65`           \n`0x01000000`                           Purpose ID = 1 (PURPOSE_CONNECT)\n`0x24aa065900000000`                   UNIX timestamp 1493608996\n`0x46`                                 70 byte signature\n`0x304402200edfb5c4812a31d84cbbd4b2`   Signature data\n`0x4e631795435a0d16b57d37ef773735b8`   \n`0xa87caa8a0220631d0b78b7f1d29c9e54`   \n`0xa76f3457ff1a2ee19490ff027c528a89`   \n`0x6f4bf6aff577`"
    },
    {
      "header": "Serialized solution example {#serialized_solution_example_1}",
      "content": "0201000000092c64212000000000000002000000051c0c00e4004c3c1e3ee5c799b7e992bcccbb89\n85979dcb8dd229b8d0db06e677d00bb3a43c88ef8596a77cbd1dda23b0a0b84bdf6084d7aa28ddbd\n5e91b511b3578cbaf92707c940b051a0759b3f80c5fb650100000024aa0659000000004630440220\n0edfb5c4812a31d84cbbd4b24e631795435a0d16b57d37ef773735b8a87caa8a0220631d0b78b7f1\nd29c9e54a76f3457ff1a2ee19490ff027c528a896f4bf6aff5775c040000005a0137007074ce00e3\ndbeb00e88f790106d71d02984d3d02091b5002378a8e0290a6d202b3c67003757cb70344d9cf0329\n7f20048e76a60467e44a057b077405634f840523e88c050d887606109d3e07c4bdcd073db2d407\n\nNote that the first 186 bytes are identical to the challenge above.\n\nHex                                    Description\n-------------------------------------- -----------------------------\n`0x0201..f577`                         Challenge\n`0x5c`                                 Solution is 92 bytes long\n`0x04000000`                           The cuckoo cycle nonce is 4\n`0x5a0137007074ce00e3dbeb00e88f7901`   Cycle edges 0..3\n`0x06d71d02984d3d02091b5002378a8e02`   Cycle edges 4..7\n`0x90a6d202b3c67003757cb70344d9cf03`   Cycle edges 8..11\n`0x297f20048e76a60467e44a057b077405`   Cycle edges 12..15\n`0x634f840523e88c050d887606109d3e07`   Cycle edges 16..19\n`0xc4bdcd073db2d407`                   Cycle edges 20..21"
    },
    {
      "header": "Copyright",
      "content": "This BIP is licensed under the BSD 2-clause license."
    }
  ]
}