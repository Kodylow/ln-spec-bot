{
  "BIP": "70",
  "Layer": "Applications",
  "Title": "Payment Protocol",
  "Author": "Gavin Andresen <gavinandresen@gmail.com>",
  "Comments-Summary": "No comments yet.",
  "Comments-URI": "https://github.com/bitcoin/bips/wiki/Comments:BIP-0070",
  "Status": "Final",
  "Type": "Standards Track",
  "Created": "2013-07-29",
  "sections": [
    {
      "header": "Abstract",
      "content": "This BIP describes a protocol for communication between a merchant and\ntheir customer, enabling both a better customer experience and better\nsecurity against man-in-the-middle attacks on the payment process."
    },
    {
      "header": "Motivation",
      "content": "The current, minimal Bitcoin payment protocol operates as follows:\n\n1.  Customer adds items to an online shopping basket, and decides to pay\nusing Bitcoin.\n2.  Merchant generates a unique payment address, associates it with the\ncustomer\\'s order, and asks the customer to pay.\n3.  Customer copies the Bitcoin address from the merchant\\'s web page\nand pastes it into whatever wallet they are using OR follows a\nbitcoin: link and their wallet is launched with the amount to be\npaid.\n4.  Customer authorizes payment to the merchant\\'s address and\nbroadcasts the transaction through the Bitcoin p2p network.\n5.  Merchant\\'s server detects payment and after sufficient transaction\nconfirmations considers the transaction final.\n\nThis BIP extends the above protocol to support several new features:\n\n1.  Human-readable, secure payment destinations\\-- customers will be\nasked to authorize payment to \\\"example.com\\\" instead of an\ninscrutable, 34-character bitcoin address.\n2.  Secure proof of payment, which the customer can use in case of a\ndispute with the merchant.\n3.  Resistance from man-in-the-middle attacks that replace a merchant\\'s\nbitcoin address with an attacker\\'s address before a transaction is\nauthorized with a hardware wallet.\n4.  Payment received messages, so the customer knows immediately that\nthe merchant has received, and has processed (or is processing)\ntheir payment.\n5.  Refund addresses, automatically given to the merchant by the\ncustomer\\'s wallet software, so merchants do not have to contact\ncustomers before refunding overpayments or orders that cannot be\nfulfilled for some reason."
    },
    {
      "header": "Protocol",
      "content": "This BIP describes payment protocol messages encoded using Google\\'s\nProtocol Buffers, authenticated using X.509 certificates, and\ncommunicated over http/https. Future BIPs might extend this payment\nprotocol to other encodings, PKI systems, or transport protocols.\n\nThe payment protocol consists of three messages; PaymentRequest,\nPayment, and PaymentACK, and begins with the customer somehow indicating\nthat they are ready to pay and the merchant\\'s server responding with a\nPaymentRequest message:\n\n`<img src=bip-0070/Protocol_Sequence.png>`{=html}`</img>`{=html}"
    },
    {
      "header": "Messages",
      "content": "The Protocol Buffers messages are defined in\n[paymentrequest.proto](bip-0070/paymentrequest.proto \"wikilink\")."
    },
    {
      "header": "Output",
      "content": "Outputs are used in PaymentRequest messages to specify where a payment\n(or part of a payment) should be sent. They are also used in Payment\nmessages to specify where a refund should be sent.\n\nmessage Output {\noptional uint64 amount = 1 [default = 0];\noptional bytes script = 2;\n}\n\n-------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\namount   Number of satoshis (0.00000001 BTC) to be paid\nscript   a \\\"TxOut\\\" script where payment should be sent. This will normally be one of the standard Bitcoin transaction scripts (e.g. pubkey OP_CHECKSIG). This is optional to enable future extensions to this protocol that derive Outputs from a master public key and the PaymentRequest data itself.\n-------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------"
    },
    {
      "header": "PaymentDetails/PaymentRequest",
      "content": "Payment requests are split into two messages to support future\nextensibility. The bulk of the information is contained in the\nPaymentDetails message. It is wrapped inside a PaymentRequest message,\nwhich contains meta-information about the merchant and a digital\nsignature.\n\nmessage PaymentDetails {\noptional string network = 1 [default = \"main\"];\nrepeated Output outputs = 2;\nrequired uint64 time = 3;\noptional uint64 expires = 4;\noptional string memo = 5;\noptional string payment_url = 6;\noptional bytes merchant_data = 7;\n}\n\n--------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\nnetwork         either \\\"main\\\" for payments on the production Bitcoin network, or \\\"test\\\" for payments on test network. If a client receives a PaymentRequest for a network it does not support it must reject the request.\noutputs         one or more outputs where Bitcoins are to be sent. If the sum of outputs.amount is zero, the customer will be asked how much to pay, and the bitcoin client may choose any or all of the Outputs (if there are more than one) for payment. If the sum of outputs.amount is non-zero, then the customer will be asked to pay the sum, and the payment shall be split among the Outputs with non-zero amounts (if there are more than one; Outputs with zero amounts shall be ignored).\ntime            Unix timestamp (seconds since 1-Jan-1970 UTC) when the PaymentRequest was created.\nexpires         Unix timestamp (UTC) after which the PaymentRequest should be considered invalid.\nmemo            UTF-8 encoded, plain-text (no formatting) note that should be displayed to the customer, explaining what this PaymentRequest is for.\npayment_url     Secure (usually https) location where a Payment message (see below) may be sent to obtain a PaymentACK.\nmerchant_data   Arbitrary data that may be used by the merchant to identify the PaymentRequest. May be omitted if the merchant does not need to associate Payments with PaymentRequest or if they associate each PaymentRequest with a separate payment address.\n--------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nThe payment_url specified in the PaymentDetails should remain valid at\nleast until the PaymentDetails expires (or as long as possible if the\nPaymentDetails does not expire). Note that this is irrespective of any\nstate change in the underlying payment request; for example cancellation\nof an order should not invalidate the payment_url, as it is important\nthat the merchant\\'s server can record mis-payments in order to refund\nthe payment.\n\nA PaymentRequest is PaymentDetails optionally tied to a merchant\\'s\nidentity:\n\nmessage PaymentRequest {\noptional uint32 payment_details_version = 1 [default = 1];\noptional string pki_type = 2 [default = \"none\"];\noptional bytes pki_data = 3;\nrequired bytes serialized_payment_details = 4;\noptional bytes signature = 5;\n}\n\n---------------------------- ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\npayment_details_version      See below for a discussion of versioning/upgrading.\npki_type                     public-key infrastructure (PKI) system being used to identify the merchant. All implementation should support \\\"none\\\", \\\"x509+sha256\\\" and \\\"x509+sha1\\\".\npki_data                     PKI-system data that identifies the merchant and can be used to create a digital signature. In the case of X.509 certificates, pki_data contains one or more X.509 certificates (see Certificates section below).\nserialized_payment_details   A protocol-buffer serialized PaymentDetails message.\nsignature                    digital signature over a hash of the protocol buffer serialized variation of the PaymentRequest message, with all serialized fields serialized in numerical order (all current protocol buffer implementations serialize fields in numerical order) and signed using the private key that corresponds to the public key in pki_data. Optional fields that are not set are not serialized (however, setting a field to its default value will cause it to be serialized and will affect the signature). Before serialization, the signature field must be set to an empty value so that the field is included in the signed PaymentRequest hash but contains no data.\n---------------------------- ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nWhen a Bitcoin wallet application receives a PaymentRequest, it must\nauthorize payment by doing the following:\n\n1.  Validate the merchant\\'s identity and signature using the PKI\nsystem, if the pki_type is not \\\"none\\\".\n2.  Validate that customer\\'s system unix time (UTC) is before\nPaymentDetails.expires. If it is not, then the payment request must\nbe rejected.\n3.  Display the merchant\\'s identity and ask the customer if they would\nlike to submit payment (e.g. display the \\\"Common Name\\\" in the\nfirst X.509 certificate).\n\nPaymentRequest messages larger than 50,000 bytes should be rejected by\nthe wallet application, to mitigate denial-of-service attacks."
    },
    {
      "header": "Payment",
      "content": "Payment messages are sent after the customer has authorized payment:\n\nmessage Payment {\noptional bytes merchant_data = 1;\nrepeated bytes transactions = 2;\nrepeated Output refund_to = 3;\noptional string memo = 4;\n}\n\n--------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\nmerchant_data   copied from PaymentDetails.merchant_data. Merchants may use invoice numbers or any other data they require to match Payments to PaymentRequests. Note that malicious clients may modify the merchant_data, so should be authenticated in some way (for example, signed with a merchant-only key).\ntransactions    One or more valid, signed Bitcoin transactions that fully pay the PaymentRequest\nrefund_to       One or more outputs where the merchant may return funds, if necessary. The merchant may return funds using these outputs for up to 2 months after the time of the payment request. After that time has expired, parties must negotiate if returning of funds becomes necessary.\nmemo            UTF-8 encoded, plain-text note from the customer to the merchant.\n--------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIf the customer authorizes payment, then the Bitcoin client:\n\n1.  Creates and signs one or more transactions that satisfy (pay in\nfull) PaymentDetails.outputs\n2.  Validate that customer\\'s system unix time (UTC) is still before\nPaymentDetails.expires. If it is not, the payment should be\ncancelled.\n3.  Broadcast the transactions on the Bitcoin p2p network.\n4.  If PaymentDetails.payment_url is specified, POST a Payment message\nto that URL. The Payment message is serialized and sent as the body\nof the POST request.\n\nErrors communicating with the payment_url server should be communicated\nto the user. In the scenario where the merchant\\'s server receives\nmultiple identical Payment messages for an individual PaymentRequest, it\nmust acknowledge each. The second and further PaymentACK messages sent\nfrom the merchant\\'s server may vary by memo field to indicate current\nstate of the Payment (for example number of confirmations seen on the\nnetwork). This is required in order to ensure that in case of a\ntransport level failure during transmission, recovery is possible by the\nBitcoin client re-sending the Payment message.\n\nPaymentDetails.payment_url should be secure against man-in-the-middle\nattacks that might alter Payment.refund_to (if using HTTP, it must be\nTLS-protected).\n\nWallet software sending Payment messages via HTTP must set appropriate\nContent-Type and Accept headers, as specified in BIP 71:\n\nContent-Type: application/bitcoin-payment\nAccept: application/bitcoin-paymentack\n\nWhen the merchant\\'s server receives the Payment message, it must\ndetermine whether or not the transactions satisfy conditions of payment.\nIf and only if they do, it should broadcast the transaction(s) on the\nBitcoin p2p network.\n\nPayment messages larger than 50,000 bytes should be rejected by the\nmerchant\\'s server, to mitigate denial-of-service attacks."
    },
    {
      "header": "PaymentACK",
      "content": "PaymentACK is the final message in the payment protocol; it is sent from\nthe merchant\\'s server to the bitcoin wallet in response to a Payment\nmessage:\n\nmessage PaymentACK {\nrequired Payment payment = 1;\noptional string memo = 2;\n}\n\n--------- ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------\npayment   Copy of the Payment message that triggered this PaymentACK. Clients may ignore this if they implement another way of associating Payments with PaymentACKs.\nmemo      UTF-8 encoded note that should be displayed to the customer giving the status of the transaction (e.g. \\\"Payment of 1 BTC for eleven tribbles accepted for processing.\\\")\n--------- ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nPaymentACK messages larger than 60,000 bytes should be rejected by the\nwallet application, to mitigate denial-of-service attacks. This is\nlarger than the limits on Payment and PaymentRequest messages as\nPaymentACK contains a full Payment message within it."
    },
    {
      "header": "Localization",
      "content": "Merchants that support multiple languages should generate\nlanguage-specific PaymentRequests, and either associate the language\nwith the request or embed a language tag in the request\\'s\nmerchant_data. They should also generate a language-specific PaymentACK\nbased on the original request.\n\nFor example: A greek-speaking customer browsing the Greek version of a\nmerchant\\'s website clicks on a \\\"\u0391\u03b3\u03bf\u03c1\u03ac \u03c4\u03ce\u03c1\u03b1\\\" link, which generates a\nPaymentRequest with merchant_data set to \\\"lang=el&basketId=11252\\\". The\ncustomer pays, their bitcoin client sends a Payment message, and the\nmerchant\\'s website responds with PaymentACK.message \\\"\u03c3\u03b1\u03c2\n\u03b5\u03c5\u03c7\u03b1\u03c1\u03b9\u03c3\u03c4\u03bf\u03cd\u03bc\u03b5\\\"."
    },
    {
      "header": "Certificates",
      "content": "The default PKI system is X.509 certificates (the same system used to\nauthenticate web servers). The format of pki_data when pki_type is\n\\\"x509+sha256\\\" or \\\"x509+sha1\\\" is a protocol-buffer-encoded\ncertificate chain:\n\nmessage X509Certificates {\nrepeated bytes certificate = 1;\n}\n\nIf pki_type is \\\"x509+sha256\\\", then the PaymentRequest message is\nhashed using the SHA256 algorithm to produce the message digest that is\nsigned. If pki_type is \\\"x509+sha1\\\", then the SHA1 algorithm is used.\n\nEach certificate is a DER \\[ITU.X690.1994\\] PKIX certificate value. The\ncertificate containing the public key of the entity that digitally\nsigned the PaymentRequest must be the first certificate. This MUST be\nfollowed by additional certificates, with each subsequent certificate\nbeing the one used to certify the previous one, up to (but not\nincluding) a trusted root authority. The trusted root authority MAY be\nincluded. The recipient must verify the certificate chain according to\n\\[RFC5280\\] and reject the PaymentRequest if any validation failure\noccurs.\n\nTrusted root certificates may be obtained from the operating system; if\nvalidation is done on a device without an operating system, the [Mozilla\nroot\nstore](http://www.mozilla.org/projects/security/certs/included/index.html)\nis recommended."
    },
    {
      "header": "Extensibility",
      "content": "The protocol buffers serialization format is designed to be extensible.\nIn particular, new, optional fields can be added to a message and will\nbe ignored (but saved/re-transmitted) by old implementations.\n\nPaymentDetails messages may be extended with new optional fields and\nstill be considered \\\"version 1.\\\" Old implementations will be able to\nvalidate signatures against PaymentRequests containing the new fields,\nbut (obviously) will not be able to display whatever information is\ncontained in the new, optional fields to the user.\n\nIf it becomes necessary at some point in the future for merchants to\nproduce PaymentRequest messages that are accepted \\*only\\* by new\nimplementations, they can do so by defining a new PaymentDetails message\nwith version=2. Old implementations should let the user know that they\nneed to upgrade their software when they get an up-version\nPaymentDetails message.\n\nImplementations that need to extend messages in this specification shall\nuse tags starting at 1000, and shall update the [extensions\npage](bip-0070/extensions.mediawiki \"wikilink\") via pull-req to avoid\nconflicts with other extensions."
    },
    {
      "header": "References",
      "content": "[BIP 0071](bip-0071.mediawiki \"wikilink\") : Payment Protocol mime types\n\n[BIP 0072](bip-0072.mediawiki \"wikilink\") : Payment Protocol bitcoin:\nURI extensions\n\nPublic-Key Infrastructure (X.509) working group :\n<http://datatracker.ietf.org/wg/pkix/charter/>\n\nProtocol Buffers : <https://developers.google.com/protocol-buffers/>"
    },
    {
      "header": "Reference implementation {#reference_implementation}",
      "content": "Create Payment Request generator :\n<https://bitcoincore.org/~gavin/createpaymentrequest.php>\n([source](https://github.com/gavinandresen/paymentrequest \"wikilink\"))\n\nBitcoinJ : <https://bitcoinj.github.io/payment-protocol#introduction>"
    },
    {
      "header": "See Also {#see_also}",
      "content": "Javascript Object Signing and Encryption working group :\n<http://datatracker.ietf.org/wg/jose/>\n\nWikipedia\\'s page on Invoices: <http://en.wikipedia.org/wiki/Invoice>\nespecially the list of Electronic Invoice standards\n\nsipa\\'s payment protocol proposal:\n<https://gist.github.com/sipa/1237788>\n\nThomasV\\'s \\\"Signed Aliases\\\" proposal :\n<http://ecdsa.org/bitcoin_URIs.html>\n\nHomomorphic Payment Addresses and the Pay-to-Contract Protocol :\n<http://arxiv.org/abs/1212.3257>"
    }
  ]
}