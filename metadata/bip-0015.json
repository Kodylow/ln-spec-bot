{
  "BIP": "15",
  "Layer": "Applications",
  "Title": "Aliases",
  "Author": "Amir Taaki <genjix@riseup.net>",
  "Comments-Summary": "No comments yet.",
  "Comments-URI": "https://github.com/bitcoin/bips/wiki/Comments:BIP-0015",
  "Status": "Deferred",
  "Type": "Standards Track",
  "Created": "2011-12-10",
  "sections": [
    {
      "header": "Schemes",
      "content": "Here are a few different proposals and the properties of each system."
    },
    {
      "header": "FirstBits",
      "content": "FirstBits is a proposal for using the blockchain as an address book.\n\nWhen bitcoins are sent to an address, that address becomes recorded in\nthe blockchain. It is therefore known that this address exists or did\nexist by simply seeing that there was a payment to that address.\nFirstBits is a method to have a memorable alias. One first converts the\naddress to lower-case, then takes the first few unique characters. This\nis your FirstBits alias.\n\nAs an example, brmlab hackerspace in Prague has an address for\npurchasing food or drink, or making donations:\n\n`\u00a01BRMLAB7nryYgFGrG8x9SYaokb8r2ZwAsX`\n\nTheir FirstBits alias becomes:\n\n`\u00a01brmlab`\n\nIt is enough information to be given the FirstBits alias *1brmlab*. When\nsomeone wishes to make a purchase, without FirstBits, they either have\nto type out their address laboriously by hand, scan their QR code (which\nrequires a mobile handset that this author does not own) or find their\naddress on the internet to copy and paste into the client to send\nbitcoins. FirstBits alleviates this impracticality by providing an easy\nmethod to make payments.\n\nTogether with [Vanitygen (vanity generator)](vanitygen \"wikilink\"), it\nbecomes possible to create memorable unique named addresses. Addresses\nthat are meaningful, rather than an odd assemblage of letters and\nnumbers but add context to the destination.\n\nHowever FirstBits has its own problems. One is that the possible aliases\none is able to generate is limited by the available computing power\navailable. It may not be feasible to generate a complete or precise\nalias that is wanted- only approximates may be possible. It is also\ncomputationally resource intensive which means a large expenditure of\npower for generating unique aliases in the future, and may not scale up\nto the level of individuals at home or participants with hand-held\ndevices in an environment of ubiquitous computing.\n\nFirstBits scales extremely poorly as the network grows. Each indexer or\nlookup node needs to keep track of every bitcoin address ever in\nexistence and provide a fast lookup from the aliases to those addresses.\nAs the network grows linearly, the number of addresses should grow\nexponentially (assuming a networked effect of (n-1)\\*(n-2)/2) rapidly\nmaking this scheme unfeasible.\n\nLight clients of the partial merkle root types become dependent on a\ntrusted third party for their alias lookups. The cost of storing every\nbitcoin address is too high considering their typical use-case on\nlow-resource devices. This factor more than the others, means this\nscheme is sub-optimal and must be rejected."
    },
    {
      "header": "DNS TXT Records {#dns_txt_records}",
      "content": "DNS allows TXT records to be created containing arbitrary data. In a\nbitcoin alias system, a custom format mutually agreed upon by a BIP\nstandard would be used to store mappings to bitcoin addresses from\ndomain names. How such a format would look is out of the scope of this\ndocument.\n\nAn issue is that it requires people who wish to create such mappings to\nbe familiar with configuring DNS records, and be able to run the\nnecessary toolsets to insert the correct data. Although not a huge\nconcern, it is a usability issue.\n\nSecurity wise, DNS is unsafe and insecure by design. It is possible to\nspoof records by being on the same network as another host. A number of\nrevisions to mitigate the issue under the guise of DNSSEC have been in\nthe works since the 1990s and are still being rolled out.\n\nAs of Dec 2011, DNSSEC is still not yet a defacto standard on the\ninternet. Should a participant in the bitcoin network wish to use DNS\nTXT records, they would in addition to having to configure DNS, be able\nto setup DNSSEC. This may not be feasible, especially where some\nregistrars provide access to DNS through a web interface only.\n\nThe disadvantage of DNS TXT records is that updating a record takes\ntime. This encourages people to not use new addresses per transaction\nwhich has certain security issues."
    },
    {
      "header": "Server Service {#server_service}",
      "content": "Aside from using DNS TXT records, another possibility is using the\ndomain name system to lookup hosts and then contact a service running on\na predefined port to get the bitcoin address.\n\n1.  User wishes to send to foo@bar.net\n2.  Client uses DNS to find the IP address of bar.net: 123.123.123.123\n3.  Client connects to port 123.123.123.123:4567 and requests the\nbitcoin address for the user *foo*\n4.  Server responds with the address or error code and terminates the\nconnection.\n5.  Client sends the funds to the address\n\nThe service would be responsible for providing the mechanisms for\nchanging and storing the mappings on their service. A front-end web\ninterface could be provided to users wishing to use the service and\ncustomise their accounts on the server.\n\nThis approach has the positive aspect of providing the best flexibility\nfor the implementer to store the records however they wish in a database\nor plaintext file, and then serve them up quickly using a small server\nside daemon typically written in C. This approach is highly scalable.\n\nHowever this approach also suffers the problem of being reliant on DNS\nand hence also being vulnerable to spoofing. Hence DNSSEC is also\nrequired. This approach is slightly better than the DNS TXT records\nthough since it makes inserting new users and modifying aliases very\neasy which allows people to run these server services more cheaply."
    },
    {
      "header": "HTTPS Web Service {#https_web_service}",
      "content": "HTTPS provides an additional layer of security by encrypting the\nconnection, providing much needed privacy for users. Together with using\nCertificate Authorities, it fixes the issue with using DNSSEC since an\nerror would be thrown up were someone to try to spoof a domain name on\nthe local network.\n\nWhen trying to send to:\n\n`\u00a0genjix@foo.org`\n\nThe request is broken into the handle (genjix) and domain (foo.org) at\nthe last occurrence of the @. The client then constructs a request that\nwill query for the address.\n\n`\u00a0`[`https://foo.org/bitcoin-alias/?handle=genjix`](https://foo.org/bitcoin-alias/?handle=genjix)\n\nbitcoin-alias has been chosen as the query suffix because it allows this\nsystem to co-exist easily within another web root without the fear of\nname clashes.\n\nThe query will then return an address which is used to make the payment.\n\n`\u00a01Hd44nkJfNAcPJeZyrGC5sKJS1TzgmCTjjZ`\n\nThe details of whether a unique address is returned per query, whether\nan address is fetched from a pre-existing pool of addresses, and so on\nis an implementation detail unique to every server. How alias to address\nmappings are setup is dependent on the site which could have a\nweb-interface and be providing a free service to users or be a private\ncustomised service serving pre-existing addresses. This is left up to\nsysop policy, and deliberately not defined here.\n\nA web service is trivial to setup and the cost is low. There are many\nfree out of the box providers on the net that allows anyone with the\nmost basic knowledge of web technologies to create their own website. By\nproviding users with a package, anybody can quickly set themselves up\nwith a bitcoin alias. It could be something as simple as a PHP script\nthat the user edits with their custom settings and uploads themselves to\ntheir website.\n\nIt also scales reasonably- anybody wishing to run a naming service can\nattach a backend with a variety of database technologies then provide a\nweb frontend for users to customise and create their own aliases.\n\nA naive implementation is provided below as an example.\n\n// resolv.h"
    },
    {
      "header": "ifndef NOMRESOLV_H__",
      "content": "#define NOMRESOLV_H__"
    },
    {
      "header": "include <string>",
      "content": "#include \"curl/curl.h\"\n\nusing std::string;\n\n/*\n\nThis class resolves against a server to lookup addresses.\nTo not conflict with the bitcoin addresses, we refer here to people's handles.\nA handle is of the form:\n\ngenjix@foo.org\n\nMost characters are valid for the username + password (and handled accordingly), but the domain follows usual web standards. It is possible to affix a path if needed,\n\ngenjix@bar.com/path/to/\n\n*/\n\nclass NameResolutionService\n{\npublic:\nNameResolutionService();\n~NameResolutionService();\n\n// Three main methods map to RPC actions.\nstring FetchAddress(const string& strHandle, string& strAddy);\n\nprivate:\n// A POST block\nclass PostVariables\n{\npublic:\nPostVariables();\n~PostVariables();\n// Add a new key, value pair\nbool Add(const string& strKey, const string& strVal);\ncurl_httppost* operator()() const;\nprivate:\n// CURL stores POST blocks as linked lists.\ncurl_httppost *pBegin, *pEnd;\n};\n\n// Explodes user@domain => user, domain\nstatic void ExplodeHandle(const string& strHandle, string& strNickname, string& strDomain);\n// Perform the HTTP request. Returns true on success.\nbool Perform();\n\n// CURL error message\nchar pErrorBuffer[CURL_ERROR_SIZE];\n// CURL response\nstring strBuffer;\n// CURL handle\nCURL *curl;\n};"
    },
    {
      "header": "endif",
      "content": "// resolv.cpp"
    },
    {
      "header": "include \"resolv.h\"",
      "content": "#include <boost/lexical_cast.hpp>"
    },
    {
      "header": "include \"access.h\"",
      "content": "// callback used to write response from the server\nstatic int writer(char *pData, size_t nSize, size_t nNmemb, std::string *pBuffer)\n{\nint nResult = 0;\nif (pBuffer != NULL)\n{\npBuffer->append(pData, nSize * nNmemb);\n// How much did we write?\nnResult = nSize * nNmemb;\n}\nreturn nResult;\n}\n\nNameResolutionService::NameResolutionService()\n{\n// Initialise CURL with our various options.\ncurl = curl_easy_init();\n// This goes first in case of any problems below. We get an error message.\ncurl_easy_setopt(curl, CURLOPT_ERRORBUFFER, pErrorBuffer);\n// fail when server sends >= 404\ncurl_easy_setopt(curl, CURLOPT_FAILONERROR, 1);\ncurl_easy_setopt(curl, CURLOPT_HEADER, 0);\ncurl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1);\ncurl_easy_setopt(curl, CURLOPT_POSTREDIR, CURL_REDIR_POST_302);\ncurl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writer);\ncurl_easy_setopt(curl, CURLOPT_USE_SSL, CURLUSESSL_TRY);\ncurl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1);\n// server response goes in strBuffer\ncurl_easy_setopt(curl, CURLOPT_WRITEDATA, &strBuffer);\npErrorBuffer[0] = '\\0';\n}\nNameResolutionService::~NameResolutionService()\n{\ncurl_easy_cleanup(curl);\n}\n\nvoid NameResolutionService::ExplodeHandle(const string& strHandle, string& strNickname, string& strDomain)\n{\n// split address at @ furthrest to the right\nsize_t nPosAtsym = strHandle.rfind('@');\nstrNickname = strHandle.substr(0, nPosAtsym);\nstrDomain = strHandle.substr(nPosAtsym + 1, strHandle.size());\n}\nbool NameResolutionService::Perform()\n{\n// Called after everything has been setup. This actually does the request.\nCURLcode result = curl_easy_perform(curl);\nreturn (result == CURLE_OK);\n}\n\nstring NameResolutionService::FetchAddress(const string& strHandle, string& strAddy)\n{\n// GET is defined for 'getting' data, so we use GET for the low risk fetching of people's addresses\nif (!curl)\n// For some reason CURL didn't start...\nreturn pErrorBuffer;\n// Expand the handle\nstring strNickname, strDomain;\nExplodeHandle(strHandle, strNickname, strDomain);\n// url encode the nickname for get request\nconst char* pszEncodedNick = curl_easy_escape(curl, strNickname.c_str(), strNickname.size());\nif (!pszEncodedNick)\nreturn \"Unable to encode nickname.\";\n// construct url for GET request\nstring strRequestUrl = strDomain + \"/bitcoin-alias/?handle=\" + pszEncodedNick;\n// Pass URL to CURL\ncurl_easy_setopt(curl, CURLOPT_URL, strRequestUrl.c_str());\nif (!Perform())\nreturn pErrorBuffer;\n// Server should respond with a JSON that has the address in.\nstrAddy = strBuffer;\nreturn \"\";  // no error\n}\n\nNameResolutionService::PostVariables::PostVariables()\n{\n// pBegin/pEnd *must* be null before calling curl_formadd\npBegin = NULL;\npEnd = NULL;\n}\nNameResolutionService::PostVariables::~PostVariables()\n{\ncurl_formfree(pBegin);\n}\nbool NameResolutionService::PostVariables::Add(const string& strKey, const string& strVal)\n{\n// Copy strings to this block. Return true on success.\nreturn curl_formadd(&pBegin, &pEnd, CURLFORM_COPYNAME, strKey.c_str(), CURLFORM_COPYCONTENTS, strVal.c_str(), CURLFORM_END) == CURL_FORMADD_OK;\n}\n\ncurl_httppost* NameResolutionService::PostVariables::operator()() const\n{\nreturn pBegin;\n}\n</source>\n\n<source lang=\"cpp\">\n// rpc.cpp\n...\n\nconst Object CheckMaybeThrow(const string& strJsonIn)\n{\n// Parse input JSON\nValue valRequest;\nif (!read_string(strJsonIn, valRequest) || valRequest.type() != obj_type)\nthrow JSONRPCError(-32700, \"Parse error\");\nconst Object& request = valRequest.get_obj();\n// Now check for a key called \"error\"\nconst Value& error  = find_value(request, \"error\");\n// It's an error JSON! so propagate the error.\nif (error.type() != null_type)\nthrow JSONRPCError(-4, error.get_str());\n// Return JSON object\nreturn request;\n}\n\nconst string CollectAddress(const string& strIn)\n{\n// If the handle does not have an @ in it, then it's a normal base58 bitcoin address\nif (strIn.find('@') == (size_t)-1)\nreturn strIn;\n\n// Open the lookup service\nNameResolutionService ns;\n// We established that the input string is not a BTC address, so we use it as a handle now.\nstring strHandle = strIn, strAddy;\nstring strError = ns.FetchAddress(strHandle, strAddy);\nif (!strError.empty())\nthrow JSONRPCError(-4, strError);\n\nconst Object& request(CheckMaybeThrow(strAddy));\n// Get the BTC address from the JSON\nconst Value& address = find_value(request, \"address\");\nif (address.type() != str_type)\nthrow JSONRPCError(-32600, \"Server responded with malformed reply.\");\nreturn address.get_str();\n}\n\n// Named this way to prevent possible conflicts.\nValue rpc_send(const Array& params, bool fHelp)\n{\nif (fHelp || params.size() != 2)\nthrow runtime_error(\n\"send <name@domain or address> <amount>\\n\"\n\"<amount> is a real and is rounded to the nearest 0.01\");\n\n// Intelligent function which looks up address given handle, or returns address\nstring strAddy = CollectAddress(params[0].get_str());\nint64 nAmount = AmountFromValue(params[1]);\n// Do the send\nCWalletTx wtx;\nstring strError = SendMoneyToBitcoinAddress(strAddy, nAmount, wtx);\nif (!strError.empty())\nthrow JSONRPCError(-4, strError);\nreturn wtx.GetHash().GetHex();\n}\n\n..."
    },
    {
      "header": "IP Transactions {#ip_transactions}",
      "content": "An IP transaction is an old transaction format in bitcoin that is\ndisabled and possibly could be deprecated. It involves being given an IP\naddress to make payment to. Upon connecting to the node and requesting\ntheir public key using \\\"checkorder\\\", they will respond with a script\nin the form:\n\n`\u00a0``<public key>`{=html}`\u00a0OP_CHECKSIG`\n\nSimilar to coinbase output transactions. IP transactions have the\nadvantage of being able to contain additional metadata which can be\nuseful in many transactions. Currently no authentication is done making\nthe scheme insecure against man in the middle (MITM) attacks.\n\nThis proposal seeks to enable DNS lookups for IP transactions.\n\nThe \\\"checkorder\\\" message would contain a destination account, which\ncould map to different isolated sets of keypairs/wallets running under\nthe same host. The exact mapping from the checkorder reference info to\nthe local system is implementation defined.\n\nBy using DNS lookups, the MITM problem with IP transactions could be\nmitigated by storing a public key in a DNS TXT record. This public key\nwould be used for all future \\\"reply\\\" messages originating from that\nhost. First time use would require a confirmation for acceptance of that\npublic key; like with SSH. Should the \\\"reply\\\" message not match the\naccepted public key, then the host will be given an error."
    },
    {
      "header": "Namecoin ID {#namecoin_id}",
      "content": "This proposal uses the Namecoin blockchain to associate an alias with a\nbitcoin address. Bitcoin queries a namecoin node. This retreives the\nstructured data containing the bitcoin address(es) associated with this\nalias.\n\nUsing a decentralised domain name system like Namecoin, means no\nexternal server or entity needs to be trusted unlike the other proposals\nlisted here. This indicates a system with the advantage of having a high\navailability and ease of entry (no restrictions for users to create\naliases).\n\nTwo examples are presented below. The first shows a simpler format,\nwhile the second shows several Bitcoin addresses in a structured format.\n\n`$\u00a0namecoind\u00a0name_show\u00a0id/khal`\\\n`{`\\\n`\u00a0\u00a0\"bitcoin\"\u00a0:\u00a0\"1KHAL8bUjnkMRMg9yd2dNrYnJgZGH8Nj6T\"`\\\n`}`\n\n`$\u00a0namecoind\u00a0name_show\u00a0id/khal`\\\n`{`\\\n`\u00a0\u00a0\"bitcoin\"\u00a0:`\\\n`\u00a0\u00a0{`\\\n`\u00a0\u00a0\u00a0\u00a0\"default\"\u00a0:\u00a0\"1KHAL8bUjnkMRMg9yd2dNrYnJgZGH8Nj6T\",`\\\n`\u00a0\u00a0\u00a0\u00a0\"donation\":\u00a0\"1J3EKMfboca3SESWGrQKESsG1MA9yK6vN4\"`\\\n`\u00a0\u00a0}`\\\n`}`\n\n**More possibilities :**\n\n-   Allow to securely use **unsecured channels**\n\nYou can put an url and a bitcoin address that will be used to sign the\nresult. It means that a query to this url will return a bitcoin address\nand a signature. Bitcoin can then check (with the verify_message\nfunction) that the returned address has not been replaced by another\none.\n\n`$\u00a0namecoind\u00a0name_show\u00a0id/khal`\\\n`{`\\\n`\u00a0\u00a0\"bitcoin\"\u00a0:`\\\n`\u00a0\u00a0{`\\\n`\u00a0\u00a0\u00a0\u00a0\"url\"\u00a0:\u00a0\"`[`http://merchant.com/bitcoin/getnewaddres/`](http://merchant.com/bitcoin/getnewaddres/)`\",`\\\n`\u00a0\u00a0\u00a0\u00a0\"signedWith\"\u00a0:\u00a0\"1KHAL8bUjnkMRMg9yd2dNrYnJgZGH8Nj6T\"`\\\n`\u00a0\u00a0}`\\\n`}`\n\n-   Allow to get a different address each time, or per user, per order,\netc\n\n`$\u00a0namecoind\u00a0name_show\u00a0id/khal`\\\n`{`\\\n`\u00a0\u00a0\"bitcoin\"\u00a0:`\\\n`\u00a0\u00a0{`\\\n`\u00a0\u00a0\u00a0\u00a0\"url\"\u00a0:\u00a0\"`[`http://merchant.com/bitcoin/getaddres/{Your`](http://merchant.com/bitcoin/getaddres/%7BYour)`\u00a0customer\u00a0id}\",`\\\n`\u00a0\u00a0\u00a0\u00a0\"signedWith\"\u00a0:\u00a0\"1KHAL8bUjnkMRMg9yd2dNrYnJgZGH8Nj6T\",`\\\n`\u00a0\u00a0\u00a0\u00a0\"useOnce\":\u00a0false`\\\n`\u00a0\u00a0}`\\\n`}`\n\nIn the above example, bitcoin will ask the user for \\\"Your customer id\\\"\nand replace that value in the url before making the http request. The\nmerchant will receive the request and give the user a payment address\nassociated with that customer.\n\nAny text can be put into the brackets, allowing merchants to adapt it to\nall their needs.\n\n-   Specification is extensible\n\nNew features can be added later to support uncovered cases.\n\nSee the specification of [Namecoin\nID](http://dot-bit.org/Namespace:Identity) for more informations.\n\n[E](Category:BIP \"wikilink\")"
    }
  ]
}